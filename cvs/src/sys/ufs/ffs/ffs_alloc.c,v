head	1.108;
access;
symbols
	OPENBSD_6_2:1.108.0.4
	OPENBSD_6_2_BASE:1.108
	OPENBSD_6_1:1.108.0.6
	OPENBSD_6_1_BASE:1.108
	OPENBSD_6_0:1.108.0.2
	OPENBSD_6_0_BASE:1.108
	OPENBSD_5_9:1.106.0.2
	OPENBSD_5_9_BASE:1.106
	OPENBSD_5_8:1.104.0.4
	OPENBSD_5_8_BASE:1.104
	OPENBSD_5_7:1.103.0.2
	OPENBSD_5_7_BASE:1.103
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.99.0.4
	OPENBSD_5_5_BASE:1.99
	OPENBSD_5_4:1.96.0.2
	OPENBSD_5_4_BASE:1.96
	OPENBSD_5_3:1.92.0.6
	OPENBSD_5_3_BASE:1.92
	OPENBSD_5_2:1.92.0.4
	OPENBSD_5_2_BASE:1.92
	OPENBSD_5_1_BASE:1.92
	OPENBSD_5_1:1.92.0.2
	OPENBSD_5_0:1.91.0.2
	OPENBSD_5_0_BASE:1.91
	OPENBSD_4_9:1.89.0.4
	OPENBSD_4_9_BASE:1.89
	OPENBSD_4_8:1.89.0.2
	OPENBSD_4_8_BASE:1.89
	OPENBSD_4_7:1.88.0.2
	OPENBSD_4_7_BASE:1.88
	OPENBSD_4_6:1.87.0.6
	OPENBSD_4_6_BASE:1.87
	OPENBSD_4_5:1.87.0.2
	OPENBSD_4_5_BASE:1.87
	OPENBSD_4_4:1.85.0.2
	OPENBSD_4_4_BASE:1.85
	OPENBSD_4_3:1.82.0.2
	OPENBSD_4_3_BASE:1.82
	OPENBSD_4_2:1.78.0.2
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.66.0.2
	OPENBSD_4_0_BASE:1.66
	OPENBSD_3_9:1.59.0.2
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.55.0.2
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.53.0.2
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.49.0.2
	OPENBSD_3_6_BASE:1.49
	SMP_SYNC_A:1.46
	SMP_SYNC_B:1.46
	OPENBSD_3_5:1.46.0.2
	OPENBSD_3_5_BASE:1.46
	OPENBSD_3_4:1.44.0.2
	OPENBSD_3_4_BASE:1.44
	UBC_SYNC_A:1.42
	OPENBSD_3_3:1.42.0.4
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.42.0.2
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.42
	UBC:1.37.0.2
	UBC_BASE:1.37
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.18.0.6
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.4
	OPENBSD_2_7_BASE:1.18
	SMP:1.18.0.2
	SMP_BASE:1.18
	kame_19991208:1.17
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.108
date	2016.05.23.20.47.49;	author tb;	state Exp;
branches;
next	1.107;
commitid	rqNGeOGBmR41osKa;

1.107
date	2016.05.23.09.31.28;	author natano;	state Exp;
branches;
next	1.106;
commitid	wckQrShbScIX7TCE;

1.106
date	2015.11.28.21.52.02;	author beck;	state Exp;
branches;
next	1.105;
commitid	RTnjsXZgItH5OlTY;

1.105
date	2015.09.27.05.25.00;	author guenther;	state Exp;
branches;
next	1.104;
commitid	PQh1CHLROh0mqpnf;

1.104
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.103;
commitid	p4LJxGKbi0BU2cG6;

1.103
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.102;
commitid	Z1vcFtHO8wRH0yRt;

1.102
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.101;
commitid	uzzBR7hz9ncd4O6G;

1.101
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	EF98ch02VpFassUi;

1.100
date	2014.05.22.02.02.39;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.25.23.31.12;	author guenther;	state Exp;
branches;
next	1.98;

1.98
date	2013.12.12.19.00.09;	author tedu;	state Exp;
branches;
next	1.97;

1.97
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2013.06.08.23.02.26;	author beck;	state Exp;
branches;
next	1.94;

1.94
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2013.04.23.20.42.38;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2011.09.18.23.20.28;	author bluhm;	state Exp;
branches;
next	1.91;

1.91
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.03.18.23.10;	author tedu;	state Exp;
branches;
next	1.89;

1.89
date	2010.07.13.18.52.25;	author otto;	state Exp;
branches;
next	1.88;

1.88
date	2010.01.16.15.45.10;	author chl;	state Exp;
branches;
next	1.87;

1.87
date	2009.01.17.18.50.25;	author grange;	state Exp;
branches;
next	1.86;

1.86
date	2008.08.08.16.17.38;	author thib;	state Exp;
branches;
next	1.85;

1.85
date	2008.08.02.08.34.36;	author otto;	state Exp;
branches;
next	1.84;

1.84
date	2008.07.22.18.44.25;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2008.04.10.19.39.37;	author thib;	state Exp;
branches;
next	1.82;

1.82
date	2008.01.22.20.45.00;	author otto;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.09.09.59.54;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.10.20.59.00;	author thib;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.22.13.59.12;	author thib;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.01.20.23.25;	author pedro;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.01.18.54.27;	author pedro;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.01.06.38.54;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.29.17.58.09;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.03.23.13.21.39;	author pedro;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.26.11.08.39;	author pedro;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.07.15.39.22;	author sturm;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.06.23.30.42;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2006.12.28.20.33.24;	author thib;	state Exp;
branches;
next	1.66;

1.66
date	2006.04.02.22.16.29;	author pedro;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.02.17.16.12;	author pedro;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.02.17.08.14;	author pedro;	state Exp;
branches;
next	1.63;

1.63
date	2006.04.01.12.13.51;	author pedro;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.11.22.52.56;	author pedro;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.11.21.00.48;	author pedro;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.05.10.35.51;	author pedro;	state Exp;
branches;
next	1.59;

1.59
date	2005.12.28.20.48.17;	author pedro;	state Exp;
branches;
next	1.58;

1.58
date	2005.11.06.13.22.39;	author pedro;	state Exp;
branches;
next	1.57;

1.57
date	2005.10.25.21.55.49;	author pedro;	state Exp;
branches;
next	1.56;

1.56
date	2005.09.06.16.42.21;	author pedro;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.03.20.14.01;	author drahn;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.02.13.13.21;	author pedro;	state Exp;
branches;
next	1.53;

1.53
date	2004.11.29.06.20.02;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2004.11.01.15.55.38;	author pedro;	state Exp;
branches;
next	1.51;

1.51
date	2004.10.25.23.36.50;	author pedro;	state Exp;
branches;
next	1.50;

1.50
date	2004.09.18.22.01.18;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.02.13.03.36;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.17.15.08.11;	author mpech;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.23.03.07.22;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.14.03.16.13;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.30.16.37.57;	author art;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.15.06.08.31;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.13.00.10.56;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.09.23.12.19;	author csapuntz;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.27.04.58.48;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.23.02.07.53;	author csapuntz;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.19.16.22.16;	author gluk;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.06.20.43.31;	author gluk;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.27.10.27.49;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.20.17.42.34;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.20.17.11.05;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.20.17.08.45;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.20.17.05.38;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.20.16.58.43;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.20.16.56.12;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.21.23.24.30;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.14.19.23.34;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	99.12.06.06.50.11;	author art;	state Exp;
branches;
next	1.16;

1.16
date	99.06.01.01.48.52;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.02.26.03.56.30;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.01.11.05.12.37;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.03.27.11.51.01;	author pefo;	state Exp;
branches;
next	1.12;

1.12
date	98.03.03.17.05.32;	author ryker;	state Exp;
branches;
next	1.11;

1.11
date	98.03.01.08.07.11;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.05.59.17;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.20.21.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.15.26.28;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.07.22.10.31.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.05.30.08.34.15;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.02.11.06.59.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.11.47.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.32.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.27.34;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches;
next	;

1.18.2.1
date	2001.05.14.22.47.40;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2001.07.04.11.00.47;	author niklas;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.18.2.6;

1.18.2.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.18.2.7;

1.18.2.7
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.18.2.8;

1.18.2.8
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.18.2.9;

1.18.2.9
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.18.2.10;

1.18.2.10
date	2004.02.19.11.01.36;	author niklas;	state Exp;
branches;
next	;

1.37.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.108
log
@Use arc4random_uniform() instead of arc4random() to avoid modulus bias.
This eliminates the idiom 'arc4random() % X' (where X + 1 is not a
power of two) from base.

Part of a patch from Matthew Martin from end of last year.

ok tedu@@ (a long time ago), natano@@
@
text
@/*	$OpenBSD: ffs_alloc.c,v 1.107 2016/05/23 09:31:28 natano Exp $	*/
/*	$NetBSD: ffs_alloc.c,v 1.11 1996/05/11 18:27:09 mycroft Exp $	*/

/*
 * Copyright (c) 2002 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by Marshall
 * Kirk McKusick and Network Associates Laboratories, the Security
 * Research Division of Network Associates, Inc. under DARPA/SPAWAR
 * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS
 * research program.
 *
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_alloc.c	8.11 (Berkeley) 10/27/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/syslog.h>
#include <sys/stdint.h>
#include <sys/time.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ffs/fs.h>
#include <ufs/ffs/ffs_extern.h>

#define ffs_fserr(fs, uid, cp) do {				\
	log(LOG_ERR, "uid %u on %s: %s\n", (uid),		\
	    (fs)->fs_fsmnt, (cp));				\
} while (0)

daddr_t		ffs_alloccg(struct inode *, int, daddr_t, int);
struct buf *	ffs_cgread(struct fs *, struct inode *, int);
daddr_t		ffs_alloccgblk(struct inode *, struct buf *, daddr_t);
ufsino_t	ffs_dirpref(struct inode *);
daddr_t		ffs_fragextend(struct inode *, int, daddr_t, int, int);
daddr_t		ffs_hashalloc(struct inode *, int, daddr_t, int,
		    daddr_t (*)(struct inode *, int, daddr_t, int));
daddr_t		ffs_nodealloccg(struct inode *, int, daddr_t, int);
daddr_t		ffs_mapsearch(struct fs *, struct cg *, daddr_t, int);

static const struct timeval	fserr_interval = { 2, 0 };


/*
 * Allocate a block in the file system.
 *
 * The size of the requested block is given, which must be some
 * multiple of fs_fsize and <= fs_bsize.
 * A preference may be optionally specified. If a preference is given
 * the following hierarchy is used to allocate a block:
 *   1) allocate the requested block.
 *   2) allocate a rotationally optimal block in the same cylinder.
 *   3) allocate a block in the same cylinder group.
 *   4) quadratically rehash into other cylinder groups, until an
 *      available block is located.
 * If no block preference is given the following hierarchy is used
 * to allocate a block:
 *   1) allocate a block in the cylinder group that contains the
 *      inode for the file.
 *   2) quadratically rehash into other cylinder groups, until an
 *      available block is located.
 */
int
ffs_alloc(struct inode *ip, daddr_t lbn, daddr_t bpref, int size,
    struct ucred *cred, daddr_t *bnp)
{
	static struct timeval fsfull_last;
	struct fs *fs;
	daddr_t bno;
	int cg;
	int error;

	*bnp = 0;
	fs = ip->i_fs;
#ifdef DIAGNOSTIC
	if ((u_int)size > fs->fs_bsize || fragoff(fs, size) != 0) {
		printf("dev = 0x%x, bsize = %d, size = %d, fs = %s\n",
		    ip->i_dev, fs->fs_bsize, size, fs->fs_fsmnt);
		panic("ffs_alloc: bad size");
	}
	if (cred == NOCRED)
		panic("ffs_alloc: missing credential");
#endif /* DIAGNOSTIC */
	if (size == fs->fs_bsize && fs->fs_cstotal.cs_nbfree == 0)
		goto nospace;
	if (cred->cr_uid != 0 && freespace(fs, fs->fs_minfree) <= 0)
		goto nospace;

	if ((error = ufs_quota_alloc_blocks(ip, btodb(size), cred)) != 0)
		return (error);

	/*
	 * Start allocation in the preferred block's cylinder group or
	 * the file's inode's cylinder group if no preferred block was
	 * specified.
	 */
	if (bpref >= fs->fs_size)
		bpref = 0;
	if (bpref == 0)
		cg = ino_to_cg(fs, ip->i_number);
	else
		cg = dtog(fs, bpref);

	/* Try allocating a block. */
	bno = ffs_hashalloc(ip, cg, bpref, size, ffs_alloccg);
	if (bno > 0) {
		/* allocation successful, update inode data */
		DIP_ADD(ip, blocks, btodb(size));
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		*bnp = bno;
		return (0);
	}

	/* Restore user's disk quota because allocation failed. */
	(void) ufs_quota_free_blocks(ip, btodb(size), cred);

nospace:
	if (ratecheck(&fsfull_last, &fserr_interval)) {
		ffs_fserr(fs, cred->cr_uid, "file system full");
		uprintf("\n%s: write failed, file system is full\n",
		    fs->fs_fsmnt);
	}
	return (ENOSPC);
}

/*
 * Reallocate a fragment to a bigger size
 *
 * The number and size of the old block is given, and a preference
 * and new size is also specified. The allocator attempts to extend
 * the original block. Failing that, the regular block allocator is
 * invoked to get an appropriate block.
 */
int
ffs_realloccg(struct inode *ip, daddr_t lbprev, daddr_t bpref, int osize,
    int nsize, struct ucred *cred, struct buf **bpp, daddr_t *blknop)
{
	static struct timeval fsfull_last;
	struct fs *fs;
	struct buf *bp = NULL;
	daddr_t quota_updated = 0;
	int cg, request, error;
	daddr_t bprev, bno;

	if (bpp != NULL)
		*bpp = NULL;
	fs = ip->i_fs;
#ifdef DIAGNOSTIC
	if ((u_int)osize > fs->fs_bsize || fragoff(fs, osize) != 0 ||
	    (u_int)nsize > fs->fs_bsize || fragoff(fs, nsize) != 0) {
		printf(
		    "dev = 0x%x, bsize = %d, osize = %d, nsize = %d, fs = %s\n",
		    ip->i_dev, fs->fs_bsize, osize, nsize, fs->fs_fsmnt);
		panic("ffs_realloccg: bad size");
	}
	if (cred == NOCRED)
		panic("ffs_realloccg: missing credential");
#endif /* DIAGNOSTIC */
	if (cred->cr_uid != 0 && freespace(fs, fs->fs_minfree) <= 0)
		goto nospace;

	bprev = DIP(ip, db[lbprev]);

	if (bprev == 0) {
		printf("dev = 0x%x, bsize = %d, bprev = %lld, fs = %s\n",
		    ip->i_dev, fs->fs_bsize, (long long)bprev, fs->fs_fsmnt);
		panic("ffs_realloccg: bad bprev");
	}

	/*
	 * Allocate the extra space in the buffer.
	 */
	if (bpp != NULL) {
		if ((error = bread(ITOV(ip), lbprev, fs->fs_bsize, &bp)) != 0)
			goto error;
		buf_adjcnt(bp, osize);
	}

	if ((error = ufs_quota_alloc_blocks(ip, btodb(nsize - osize), cred))
	    != 0)
		goto error;

	quota_updated = btodb(nsize - osize);

	/*
	 * Check for extension in the existing location.
	 */
	cg = dtog(fs, bprev);
	if ((bno = ffs_fragextend(ip, cg, bprev, osize, nsize)) != 0) {
		DIP_ADD(ip, blocks, btodb(nsize - osize));
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		if (bpp != NULL) {
			if (bp->b_blkno != fsbtodb(fs, bno))
				panic("ffs_realloccg: bad blockno");
#ifdef DIAGNOSTIC
			if (nsize > bp->b_bufsize)
				panic("ffs_realloccg: small buf");
#endif
			buf_adjcnt(bp, nsize);
			bp->b_flags |= B_DONE;
			memset(bp->b_data + osize, 0, nsize - osize);
			*bpp = bp;
		}
		if (blknop != NULL) {
			*blknop = bno;
		}
		return (0);
	}
	/*
	 * Allocate a new disk location.
	 */
	if (bpref >= fs->fs_size)
		bpref = 0;
	switch (fs->fs_optim) {
	case FS_OPTSPACE:
		/*
		 * Allocate an exact sized fragment. Although this makes
		 * best use of space, we will waste time relocating it if
		 * the file continues to grow. If the fragmentation is
		 * less than half of the minimum free reserve, we choose
		 * to begin optimizing for time.
		 */
		request = nsize;
		if (fs->fs_minfree < 5 ||
		    fs->fs_cstotal.cs_nffree >
		    fs->fs_dsize * fs->fs_minfree / (2 * 100))
			break;
		fs->fs_optim = FS_OPTTIME;
		break;
	case FS_OPTTIME:
		/*
		 * At this point we have discovered a file that is trying to
		 * grow a small fragment to a larger fragment. To save time,
		 * we allocate a full sized block, then free the unused portion.
		 * If the file continues to grow, the `ffs_fragextend' call
		 * above will be able to grow it in place without further
		 * copying. If aberrant programs cause disk fragmentation to
		 * grow within 2% of the free reserve, we choose to begin
		 * optimizing for space.
		 */
		request = fs->fs_bsize;
		if (fs->fs_cstotal.cs_nffree <
		    fs->fs_dsize * (fs->fs_minfree - 2) / 100)
			break;
		fs->fs_optim = FS_OPTSPACE;
		break;
	default:
		printf("dev = 0x%x, optim = %d, fs = %s\n",
		    ip->i_dev, fs->fs_optim, fs->fs_fsmnt);
		panic("ffs_realloccg: bad optim");
		/* NOTREACHED */
	}
	bno = ffs_hashalloc(ip, cg, bpref, request, ffs_alloccg);
	if (bno <= 0)
		goto nospace;

	(void) uvm_vnp_uncache(ITOV(ip));
	if (!DOINGSOFTDEP(ITOV(ip)))
		ffs_blkfree(ip, bprev, (long)osize);
	if (nsize < request)
		ffs_blkfree(ip, bno + numfrags(fs, nsize),
		    (long)(request - nsize));
	DIP_ADD(ip, blocks, btodb(nsize - osize));
	ip->i_flag |= IN_CHANGE | IN_UPDATE;
	if (bpp != NULL) {
		bp->b_blkno = fsbtodb(fs, bno);
#ifdef DIAGNOSTIC
		if (nsize > bp->b_bufsize)
			panic("ffs_realloccg: small buf 2");
#endif
		buf_adjcnt(bp, nsize);
		bp->b_flags |= B_DONE;
		memset(bp->b_data + osize, 0, nsize - osize);
		*bpp = bp;
	}
	if (blknop != NULL) {
		*blknop = bno;
	}
	return (0);

nospace:
	if (ratecheck(&fsfull_last, &fserr_interval)) {
		ffs_fserr(fs, cred->cr_uid, "file system full");
		uprintf("\n%s: write failed, file system is full\n",
		    fs->fs_fsmnt);
	}
	error = ENOSPC;

error:
	if (bp != NULL) {
		brelse(bp);
		bp = NULL;
	}

 	/*
	 * Restore user's disk quota because allocation failed.
	 */
	if (quota_updated != 0)
		(void)ufs_quota_free_blocks(ip, quota_updated, cred);

	return error;
}

/*
 * Allocate an inode in the file system.
 *
 * If allocating a directory, use ffs_dirpref to select the inode.
 * If allocating in a directory, the following hierarchy is followed:
 *   1) allocate the preferred inode.
 *   2) allocate an inode in the same cylinder group.
 *   3) quadratically rehash into other cylinder groups, until an
 *      available inode is located.
 * If no inode preference is given the following hierarchy is used
 * to allocate an inode:
 *   1) allocate an inode in cylinder group 0.
 *   2) quadratically rehash into other cylinder groups, until an
 *      available inode is located.
 */
int
ffs_inode_alloc(struct inode *pip, mode_t mode, struct ucred *cred,
    struct vnode **vpp)
{
	static struct timeval fsnoinodes_last;
	struct vnode *pvp = ITOV(pip);
	struct fs *fs;
	struct inode *ip;
	ufsino_t ino, ipref;
	int cg, error;

	*vpp = NULL;
	fs = pip->i_fs;
	if (fs->fs_cstotal.cs_nifree == 0)
		goto noinodes;

	if ((mode & IFMT) == IFDIR)
		ipref = ffs_dirpref(pip);
	else
		ipref = pip->i_number;
	if (ipref >= fs->fs_ncg * fs->fs_ipg)
		ipref = 0;
	cg = ino_to_cg(fs, ipref);

	/*
	 * Track number of dirs created one after another
	 * in a same cg without intervening by files.
	 */
	if ((mode & IFMT) == IFDIR) {
		if (fs->fs_contigdirs[cg] < 255)
			fs->fs_contigdirs[cg]++;
	} else {
		if (fs->fs_contigdirs[cg] > 0)
			fs->fs_contigdirs[cg]--;
	}
	ino = (ufsino_t)ffs_hashalloc(pip, cg, ipref, mode, ffs_nodealloccg);
	if (ino == 0)
		goto noinodes;
	error = VFS_VGET(pvp->v_mount, ino, vpp);
	if (error) {
		ffs_inode_free(pip, ino, mode);
		return (error);
	}

	ip = VTOI(*vpp);

	if (DIP(ip, mode)) {
		printf("mode = 0%o, inum = %u, fs = %s\n",
		    DIP(ip, mode), ip->i_number, fs->fs_fsmnt);
		panic("ffs_valloc: dup alloc");
	}

	if (DIP(ip, blocks)) {
		printf("free inode %s/%d had %lld blocks\n",
		    fs->fs_fsmnt, ino, (long long)DIP(ip, blocks));
		DIP_ASSIGN(ip, blocks, 0);
	}

	DIP_ASSIGN(ip, flags, 0);

	/*
	 * Set up a new generation number for this inode.
	 * XXX - just increment for now, this is wrong! (millert)
	 *       Need a way to preserve randomization.
	 */
	if (DIP(ip, gen) != 0)
		DIP_ADD(ip, gen, 1);
	if (DIP(ip, gen) == 0)
		DIP_ASSIGN(ip, gen, arc4random() & INT_MAX);

	if (DIP(ip, gen) == 0 || DIP(ip, gen) == -1)
		DIP_ASSIGN(ip, gen, 1);	/* Shouldn't happen */

	return (0);

noinodes:
	if (ratecheck(&fsnoinodes_last, &fserr_interval)) {
		ffs_fserr(fs, cred->cr_uid, "out of inodes");
		uprintf("\n%s: create/symlink failed, no inodes free\n",
		    fs->fs_fsmnt);
	}
	return (ENOSPC);
}

/*
 * Find a cylinder group to place a directory.
 *
 * The policy implemented by this algorithm is to allocate a
 * directory inode in the same cylinder group as its parent
 * directory, but also to reserve space for its files inodes
 * and data. Restrict the number of directories which may be
 * allocated one after another in the same cylinder group
 * without intervening allocation of files.
 *
 * If we allocate a first level directory then force allocation
 * in another cylinder group.
 */
ufsino_t
ffs_dirpref(struct inode *pip)
{
	struct fs *fs;
	int	cg, prefcg, dirsize, cgsize;
	int	avgifree, avgbfree, avgndir, curdirsize;
	int	minifree, minbfree, maxndir;
	int	mincg, minndir;
	int	maxcontigdirs;

	fs = pip->i_fs;

	avgifree = fs->fs_cstotal.cs_nifree / fs->fs_ncg;
	avgbfree = fs->fs_cstotal.cs_nbfree / fs->fs_ncg;
	avgndir = fs->fs_cstotal.cs_ndir / fs->fs_ncg;

	/*
	 * Force allocation in another cg if creating a first level dir.
	 */
	if (ITOV(pip)->v_flag & VROOT) {
		prefcg = arc4random_uniform(fs->fs_ncg);
		mincg = prefcg;
		minndir = fs->fs_ipg;
		for (cg = prefcg; cg < fs->fs_ncg; cg++)
			if (fs->fs_cs(fs, cg).cs_ndir < minndir &&
			    fs->fs_cs(fs, cg).cs_nifree >= avgifree &&
			    fs->fs_cs(fs, cg).cs_nbfree >= avgbfree) {
				mincg = cg;
				minndir = fs->fs_cs(fs, cg).cs_ndir;
			}
		for (cg = 0; cg < prefcg; cg++)
			if (fs->fs_cs(fs, cg).cs_ndir < minndir &&
			    fs->fs_cs(fs, cg).cs_nifree >= avgifree &&
			    fs->fs_cs(fs, cg).cs_nbfree >= avgbfree) {
				mincg = cg;
				minndir = fs->fs_cs(fs, cg).cs_ndir;
			}
		cg = mincg;
		goto end;
	} else
		prefcg = ino_to_cg(fs, pip->i_number);

	/*
	 * Count various limits which used for
	 * optimal allocation of a directory inode.
	 */
	maxndir = min(avgndir + fs->fs_ipg / 16, fs->fs_ipg);
	minifree = avgifree - (avgifree / 4);
	if (minifree < 1)
		minifree = 1;
	minbfree = avgbfree - (avgbfree / 4);
	if (minbfree < 1)
		minbfree = 1;

	cgsize = fs->fs_fsize * fs->fs_fpg;
	dirsize = fs->fs_avgfilesize * fs->fs_avgfpdir;
	curdirsize = avgndir ? (cgsize - avgbfree * fs->fs_bsize) / avgndir : 0;
	if (dirsize < curdirsize)
		dirsize = curdirsize;
	if (dirsize <= 0)
		maxcontigdirs = 0;		/* dirsize overflowed */
	else
		maxcontigdirs = min(avgbfree * fs->fs_bsize  / dirsize, 255);
	if (fs->fs_avgfpdir > 0)
		maxcontigdirs = min(maxcontigdirs,
				    fs->fs_ipg / fs->fs_avgfpdir);
	if (maxcontigdirs == 0)
		maxcontigdirs = 1;

	/*
	 * Limit number of dirs in one cg and reserve space for 
	 * regular files, but only if we have no deficit in
	 * inodes or space.
	 *
	 * We are trying to find a suitable cylinder group nearby
	 * our preferred cylinder group to place a new directory.
	 * We scan from our preferred cylinder group forward looking
	 * for a cylinder group that meets our criterion. If we get
	 * to the final cylinder group and do not find anything,
	 * we start scanning backwards from our preferred cylinder
	 * group. The ideal would be to alternate looking forward
	 * and backward, but tha tis just too complex to code for
	 * the gain it would get. The most likely place where the
	 * backward scan would take effect is when we start near
	 * the end of the filesystem and do not find anything from
	 * where we are to the end. In that case, scanning backward
	 * will likely find us a suitable cylinder group much closer
	 * to our desired location than if we were to start scanning
	 * forward from the beginning for the filesystem.
	 */
	for (cg = prefcg; cg < fs->fs_ncg; cg++)
		if (fs->fs_cs(fs, cg).cs_ndir < maxndir &&
		    fs->fs_cs(fs, cg).cs_nifree >= minifree &&
	    	    fs->fs_cs(fs, cg).cs_nbfree >= minbfree) {
			if (fs->fs_contigdirs[cg] < maxcontigdirs)
				goto end;
		}
	for (cg = prefcg - 1; cg >= 0; cg--)
		if (fs->fs_cs(fs, cg).cs_ndir < maxndir &&
		    fs->fs_cs(fs, cg).cs_nifree >= minifree &&
	    	    fs->fs_cs(fs, cg).cs_nbfree >= minbfree) {
			if (fs->fs_contigdirs[cg] < maxcontigdirs)
				goto end;
		}
	/*
	 * This is a backstop when we have deficit in space.
	 */
	for (cg = prefcg; cg < fs->fs_ncg; cg++)
		if (fs->fs_cs(fs, cg).cs_nifree >= avgifree)
			goto end;
	for (cg = prefcg - 1; cg >= 0; cg--)
		if (fs->fs_cs(fs, cg).cs_nifree >= avgifree)
			goto end;
end:
	return ((ufsino_t)(fs->fs_ipg * cg));
}

/*
 * Select the desired position for the next block in a file.  The file is
 * logically divided into sections. The first section is composed of the
 * direct blocks. Each additional section contains fs_maxbpg blocks.
 *
 * If no blocks have been allocated in the first section, the policy is to
 * request a block in the same cylinder group as the inode that describes
 * the file. The first indirect is allocated immediately following the last
 * direct block and the data blocks for the first indirect immediately
 * follow it.
 *
 * If no blocks have been allocated in any other section, the indirect
 * block(s) are allocated in the same cylinder group as its inode in an
 * area reserved immediately following the inode blocks. The policy for
 * the data blocks is to place them in a cylinder group with a greater than
 * average number of free blocks. An appropriate cylinder group is found
 * by using a rotor that sweeps the cylinder groups. When a new group of
 * blocks is needed, the sweep begins in the cylinder group following the
 * cylinder group from which the previous allocation was made. The sweep
 * continues until a cylinder group with greater than the average number
 * of free blocks is found. If the allocation is for the first block in an
 * indirect block, the information on the previous allocation is unavailable;
 * here a best guess is made based upon the logical block number being
 * allocated.
 */
int32_t
ffs1_blkpref(struct inode *ip, daddr_t lbn, int indx, int32_t *bap)
{
	struct fs *fs;
	int cg, inocg, avgbfree, startcg;
	uint32_t pref;

	KASSERT(indx <= 0 || bap != NULL);
	fs = ip->i_fs;
	/*
	 * Allocation of indirect blocks is indicated by passing negative
	 * values in indx: -1 for single indirect, -2 for double indirect,
	 * -3 for triple indirect. As noted below, we attempt to allocate
	 * the first indirect inline with the file data. For all later
	 * indirect blocks, the data is often allocated in other cylinder
	 * groups. However to speed random file access and to speed up
	 * fsck, the filesystem reserves the first fs_metaspace blocks
	 * (typically half of fs_minfree) of the data area of each cylinder
	 * group to hold these later indirect blocks.
	 */
	inocg = ino_to_cg(fs, ip->i_number);
	if (indx < 0) {
		/*
		 * Our preference for indirect blocks is the zone at the
		 * beginning of the inode's cylinder group data area that
		 * we try to reserve for indirect blocks.
		 */
		pref = cgmeta(fs, inocg);
		/*
		 * If we are allocating the first indirect block, try to
		 * place it immediately following the last direct block.
		 */
		if (indx == -1 && lbn < NDADDR + NINDIR(fs) &&
		    ip->i_din1->di_db[NDADDR - 1] != 0)
			pref = ip->i_din1->di_db[NDADDR - 1] + fs->fs_frag;
		return (pref);
	}
	/*
	 * If we are allocating the first data block in the first indirect
	 * block and the indirect has been allocated in the data block area,
	 * try to place it immediately following the indirect block.
	 */
	if (lbn == NDADDR) {
		pref = ip->i_din1->di_ib[0];
		if (pref != 0 && pref >= cgdata(fs, inocg) &&
		    pref < cgbase(fs, inocg + 1))
			return (pref + fs->fs_frag);
	}
	/*
	 * If we are the beginning of a file, or we have already allocated
	 * the maximum number of blocks per cylinder group, or we do not
	 * have a block allocated immediately preceding us, then we need
	 * to decide where to start allocating new blocks.
	 */
	if (indx % fs->fs_maxbpg == 0 || bap[indx - 1] == 0) {
		/*
		 * If we are allocating a directory data block, we want
		 * to place it in the metadata area.
		 */
		if ((DIP(ip, mode) & IFMT) == IFDIR)
			return (cgmeta(fs, inocg));
		/*
		 * Until we fill all the direct and all the first indirect's
		 * blocks, we try to allocate in the data area of the inode's
		 * cylinder group.
		 */
		if (lbn < NDADDR + NINDIR(fs))
			return (cgdata(fs, inocg));
		/*
		 * Find a cylinder with greater than average number of
		 * unused data blocks.
		 */
		if (indx == 0 || bap[indx - 1] == 0)
			startcg = inocg + lbn / fs->fs_maxbpg;
		else
			startcg = dtog(fs, bap[indx - 1]) + 1;
		startcg %= fs->fs_ncg;
		avgbfree = fs->fs_cstotal.cs_nbfree / fs->fs_ncg;
		for (cg = startcg; cg < fs->fs_ncg; cg++)
			if (fs->fs_cs(fs, cg).cs_nbfree >= avgbfree) {
				fs->fs_cgrotor = cg;
				return (cgdata(fs, cg));
			}
		for (cg = 0; cg <= startcg; cg++)
			if (fs->fs_cs(fs, cg).cs_nbfree >= avgbfree) {
				fs->fs_cgrotor = cg;
				return (cgdata(fs, cg));
			}
		return (0);
	}
	/*
	 * Otherwise, we just always try to lay things out contiguously.
	 */
	return (bap[indx - 1] + fs->fs_frag);
}

/*
 * Same as above, for UFS2.
 */
#ifdef FFS2
int64_t
ffs2_blkpref(struct inode *ip, daddr_t lbn, int indx, int64_t *bap)
{
	struct fs *fs;
	int cg, inocg, avgbfree, startcg;
	uint64_t pref;

	KASSERT(indx <= 0 || bap != NULL);
	fs = ip->i_fs;
	/*
	 * Allocation of indirect blocks is indicated by passing negative
	 * values in indx: -1 for single indirect, -2 for double indirect,
	 * -3 for triple indirect. As noted below, we attempt to allocate
	 * the first indirect inline with the file data. For all later
	 * indirect blocks, the data is often allocated in other cylinder
	 * groups. However to speed random file access and to speed up
	 * fsck, the filesystem reserves the first fs_metaspace blocks
	 * (typically half of fs_minfree) of the data area of each cylinder
	 * group to hold these later indirect blocks.
	 */
	inocg = ino_to_cg(fs, ip->i_number);
	if (indx < 0) {
		/*
		 * Our preference for indirect blocks is the zone at the
		 * beginning of the inode's cylinder group data area that
		 * we try to reserve for indirect blocks.
		 */
		pref = cgmeta(fs, inocg);
		/*
		 * If we are allocating the first indirect block, try to
		 * place it immediately following the last direct block.
		 */
		if (indx == -1 && lbn < NDADDR + NINDIR(fs) &&
		    ip->i_din2->di_db[NDADDR - 1] != 0)
			pref = ip->i_din2->di_db[NDADDR - 1] + fs->fs_frag;
		return (pref);
	}
	/*
	 * If we are allocating the first data block in the first indirect
	 * block and the indirect has been allocated in the data block area,
	 * try to place it immediately following the indirect block.
	 */
	if (lbn == NDADDR) {
		pref = ip->i_din2->di_ib[0];
		if (pref != 0 && pref >= cgdata(fs, inocg) &&
		    pref < cgbase(fs, inocg + 1))
			return (pref + fs->fs_frag);
	}
	/*
	 * If we are the beginning of a file, or we have already allocated
	 * the maximum number of blocks per cylinder group, or we do not
	 * have a block allocated immediately preceding us, then we need
	 * to decide where to start allocating new blocks.
	 */

	if (indx % fs->fs_maxbpg == 0 || bap[indx - 1] == 0) {
		/*
		 * If we are allocating a directory data block, we want
		 * to place it in the metadata area.
		 */
		if ((DIP(ip, mode) & IFMT) == IFDIR)
			return (cgmeta(fs, inocg));
		/*
		 * Until we fill all the direct and all the first indirect's
		 * blocks, we try to allocate in the data area of the inode's
		 * cylinder group.
		 */
		if (lbn < NDADDR + NINDIR(fs))
			return (cgdata(fs, inocg));
		/*
		 * Find a cylinder with greater than average number of
		 * unused data blocks.
		 */
		if (indx == 0 || bap[indx - 1] == 0)
			startcg = inocg + lbn / fs->fs_maxbpg;
		else
			startcg = dtog(fs, bap[indx - 1] + 1);

		startcg %= fs->fs_ncg;
		avgbfree = fs->fs_cstotal.cs_nbfree / fs->fs_ncg;

		for (cg = startcg; cg < fs->fs_ncg; cg++)
			if (fs->fs_cs(fs, cg).cs_nbfree >= avgbfree)
				return (cgbase(fs, cg) + fs->fs_frag);

		for (cg = 0; cg < startcg; cg++)
			if (fs->fs_cs(fs, cg).cs_nbfree >= avgbfree)
				return (cgbase(fs, cg) + fs->fs_frag);

		return (0);
	}

	/*
	 * Otherwise, we just always try to lay things out contiguously.
	 */
	return (bap[indx - 1] + fs->fs_frag);
}
#endif /* FFS2 */

/*
 * Implement the cylinder overflow algorithm.
 *
 * The policy implemented by this algorithm is:
 *   1) allocate the block in its requested cylinder group.
 *   2) quadratically rehash on the cylinder group number.
 *   3) brute force search for a free block.
 */
daddr_t
ffs_hashalloc(struct inode *ip, int cg, daddr_t pref, int size,
    daddr_t (*allocator)(struct inode *, int, daddr_t, int))
{
	struct fs *fs;
	daddr_t result;
	int i, icg = cg;

	fs = ip->i_fs;
	/*
	 * 1: preferred cylinder group
	 */
	result = (*allocator)(ip, cg, pref, size);
	if (result)
		return (result);
	/*
	 * 2: quadratic rehash
	 */
	for (i = 1; i < fs->fs_ncg; i *= 2) {
		cg += i;
		if (cg >= fs->fs_ncg)
			cg -= fs->fs_ncg;
		result = (*allocator)(ip, cg, 0, size);
		if (result)
			return (result);
	}
	/*
	 * 3: brute force search
	 * Note that we start at i == 2, since 0 was checked initially,
	 * and 1 is always checked in the quadratic rehash.
	 */
	cg = (icg + 2) % fs->fs_ncg;
	for (i = 2; i < fs->fs_ncg; i++) {
		result = (*allocator)(ip, cg, 0, size);
		if (result)
			return (result);
		cg++;
		if (cg == fs->fs_ncg)
			cg = 0;
	}
	return (0);
}

struct buf *
ffs_cgread(struct fs *fs, struct inode *ip, int cg)
{
	struct buf *bp;

	if (bread(ip->i_devvp, fsbtodb(fs, cgtod(fs, cg)),
	    (int)fs->fs_cgsize, &bp)) {
		brelse(bp);
		return (NULL);
	}

	if (!cg_chkmagic((struct cg *)bp->b_data)) {
		brelse(bp);
		return (NULL);
	}

	return bp;
}

/*
 * Determine whether a fragment can be extended.
 *
 * Check to see if the necessary fragments are available, and
 * if they are, allocate them.
 */
daddr_t
ffs_fragextend(struct inode *ip, int cg, daddr_t bprev, int osize, int nsize)
{
	struct fs *fs;
	struct cg *cgp;
	struct buf *bp;
	daddr_t bno;
	int i, frags, bbase;

	fs = ip->i_fs;
	if (fs->fs_cs(fs, cg).cs_nffree < numfrags(fs, nsize - osize))
		return (0);
	frags = numfrags(fs, nsize);
	bbase = fragnum(fs, bprev);
	if (bbase > fragnum(fs, (bprev + frags - 1))) {
		/* cannot extend across a block boundary */
		return (0);
	}

	if (!(bp = ffs_cgread(fs, ip, cg)))
		return (0);

	cgp = (struct cg *)bp->b_data;
	cgp->cg_ffs2_time = cgp->cg_time = time_second;

	bno = dtogd(fs, bprev);
	for (i = numfrags(fs, osize); i < frags; i++)
		if (isclr(cg_blksfree(cgp), bno + i)) {
			brelse(bp);
			return (0);
		}
	/*
	 * the current fragment can be extended
	 * deduct the count on fragment being extended into
	 * increase the count on the remaining fragment (if any)
	 * allocate the extended piece
	 */
	for (i = frags; i < fs->fs_frag - bbase; i++)
		if (isclr(cg_blksfree(cgp), bno + i))
			break;
	cgp->cg_frsum[i - numfrags(fs, osize)]--;
	if (i != frags)
		cgp->cg_frsum[i - frags]++;
	for (i = numfrags(fs, osize); i < frags; i++) {
		clrbit(cg_blksfree(cgp), bno + i);
		cgp->cg_cs.cs_nffree--;
		fs->fs_cstotal.cs_nffree--;
		fs->fs_cs(fs, cg).cs_nffree--;
	}
	fs->fs_fmod = 1;
	if (DOINGSOFTDEP(ITOV(ip)))
		softdep_setup_blkmapdep(bp, fs, bprev);

	bdwrite(bp);
	return (bprev);
}

/*
 * Determine whether a block can be allocated.
 *
 * Check to see if a block of the appropriate size is available,
 * and if it is, allocate it.
 */
daddr_t
ffs_alloccg(struct inode *ip, int cg, daddr_t bpref, int size)
{
	struct fs *fs;
	struct cg *cgp;
	struct buf *bp;
	daddr_t bno, blkno;
	int i, frags, allocsiz;

	fs = ip->i_fs;
	if (fs->fs_cs(fs, cg).cs_nbfree == 0 && size == fs->fs_bsize)
		return (0);

	if (!(bp = ffs_cgread(fs, ip, cg)))
		return (0);

	cgp = (struct cg *)bp->b_data;
	if (cgp->cg_cs.cs_nbfree == 0 && size == fs->fs_bsize) {
		brelse(bp);
		return (0);
	}

	cgp->cg_ffs2_time = cgp->cg_time = time_second;

	if (size == fs->fs_bsize) {
		/* allocate and return a complete data block */
		bno = ffs_alloccgblk(ip, bp, bpref);
		bdwrite(bp);
		return (bno);
	}
	/*
	 * check to see if any fragments are already available
	 * allocsiz is the size which will be allocated, hacking
	 * it down to a smaller size if necessary
	 */
	frags = numfrags(fs, size);
	for (allocsiz = frags; allocsiz < fs->fs_frag; allocsiz++)
		if (cgp->cg_frsum[allocsiz] != 0)
			break;
	if (allocsiz == fs->fs_frag) {
		/*
		 * no fragments were available, so a block will be
		 * allocated, and hacked up
		 */
		if (cgp->cg_cs.cs_nbfree == 0) {
			brelse(bp);
			return (0);
		}
		bno = ffs_alloccgblk(ip, bp, bpref);
		bpref = dtogd(fs, bno);
		for (i = frags; i < fs->fs_frag; i++)
			setbit(cg_blksfree(cgp), bpref + i);
		i = fs->fs_frag - frags;
		cgp->cg_cs.cs_nffree += i;
		fs->fs_cstotal.cs_nffree += i;
		fs->fs_cs(fs, cg).cs_nffree += i;
		fs->fs_fmod = 1;
		cgp->cg_frsum[i]++;
		bdwrite(bp);
		return (bno);
	}
	bno = ffs_mapsearch(fs, cgp, bpref, allocsiz);
	if (bno < 0) {
		brelse(bp);
		return (0);
	}

	for (i = 0; i < frags; i++)
		clrbit(cg_blksfree(cgp), bno + i);
	cgp->cg_cs.cs_nffree -= frags;
	fs->fs_cstotal.cs_nffree -= frags;
	fs->fs_cs(fs, cg).cs_nffree -= frags;
	fs->fs_fmod = 1;
	cgp->cg_frsum[allocsiz]--;
	if (frags != allocsiz)
		cgp->cg_frsum[allocsiz - frags]++;

	blkno = cgbase(fs, cg) + bno;
	if (DOINGSOFTDEP(ITOV(ip)))
		softdep_setup_blkmapdep(bp, fs, blkno);
	bdwrite(bp);
	return (blkno);
}

/*
 * Allocate a block in a cylinder group.
 * Note that this routine only allocates fs_bsize blocks; these
 * blocks may be fragmented by the routine that allocates them.
 */
daddr_t
ffs_alloccgblk(struct inode *ip, struct buf *bp, daddr_t bpref)
{
	struct fs *fs;
	struct cg *cgp;
	daddr_t bno, blkno;
	u_int8_t *blksfree;
	int cylno, cgbpref;

	fs = ip->i_fs;
	cgp = (struct cg *) bp->b_data;
	blksfree = cg_blksfree(cgp);

	if (bpref == 0) {
		bpref = cgp->cg_rotor;
	} else if ((cgbpref = dtog(fs, bpref)) != cgp->cg_cgx) {
		/* map bpref to correct zone in this cg */
		if (bpref < cgdata(fs, cgbpref))
			bpref = cgmeta(fs, cgp->cg_cgx);
		else
			bpref = cgdata(fs, cgp->cg_cgx);
	}
	/*
	 * If the requested block is available, use it.
	 */
	bno = dtogd(fs, blknum(fs, bpref));
	if (ffs_isblock(fs, blksfree, fragstoblks(fs, bno)))
		goto gotit;
	/*
	 * Take the next available block in this cylinder group.
	 */
	bno = ffs_mapsearch(fs, cgp, bpref, (int) fs->fs_frag);
	if (bno < 0)
		return (0);

	/* Update cg_rotor only if allocated from the data zone */
	if (bno >= dtogd(fs, cgdata(fs, cgp->cg_cgx)))
		cgp->cg_rotor = bno;

gotit:
	blkno = fragstoblks(fs, bno);
	ffs_clrblock(fs, blksfree, blkno);
	ffs_clusteracct(fs, cgp, blkno, -1);
	cgp->cg_cs.cs_nbfree--;
	fs->fs_cstotal.cs_nbfree--;
	fs->fs_cs(fs, cgp->cg_cgx).cs_nbfree--;

	if (fs->fs_magic != FS_UFS2_MAGIC) {
		cylno = cbtocylno(fs, bno);
		cg_blks(fs, cgp, cylno)[cbtorpos(fs, bno)]--;
		cg_blktot(cgp)[cylno]--;
	}

	fs->fs_fmod = 1;
	blkno = cgbase(fs, cgp->cg_cgx) + bno;

	if (DOINGSOFTDEP(ITOV(ip)))
		softdep_setup_blkmapdep(bp, fs, blkno);

	return (blkno);
}

/* inode allocation routine */
daddr_t
ffs_nodealloccg(struct inode *ip, int cg, daddr_t ipref, int mode)
{
	struct fs *fs;
	struct cg *cgp;
	struct buf *bp;
	int start, len, loc, map, i;
#ifdef FFS2
	struct buf *ibp = NULL;
	struct ufs2_dinode *dp2;
#endif

	/*
	 * For efficiency, before looking at the bitmaps for free inodes,
	 * check the counters kept in the superblock cylinder group summaries,
	 * and in the cylinder group itself.
	 */
	fs = ip->i_fs;
	if (fs->fs_cs(fs, cg).cs_nifree == 0)
		return (0);

	if (!(bp = ffs_cgread(fs, ip, cg)))
		return (0);

	cgp = (struct cg *)bp->b_data;
	if (cgp->cg_cs.cs_nifree == 0) {
		brelse(bp);
		return (0);
	}

	/*
	 * We are committed to the allocation from now on, so update the time
	 * on the cylinder group.
	 */
	cgp->cg_ffs2_time = cgp->cg_time = time_second;

	/*
	 * If there was a preferred location for the new inode, try to find it.
	 */
	if (ipref) {
		ipref %= fs->fs_ipg;
		if (isclr(cg_inosused(cgp), ipref))
			goto gotit; /* inode is free, grab it. */
	}

	/*
	 * Otherwise, look for the next available inode, starting at cg_irotor
	 * (the position in the bitmap of the last used inode).
	 */
	start = cgp->cg_irotor / NBBY;
	len = howmany(fs->fs_ipg - cgp->cg_irotor, NBBY);
	loc = skpc(0xff, len, &cg_inosused(cgp)[start]);
	if (loc == 0) {
		/*
		 * If we didn't find a free inode in the upper part of the
		 * bitmap (from cg_irotor to the end), then look at the bottom
		 * part (from 0 to cg_irotor).
		 */
		len = start + 1;
		start = 0;
		loc = skpc(0xff, len, &cg_inosused(cgp)[0]);
		if (loc == 0) {
			/*
			 * If we failed again, then either the bitmap or the
			 * counters kept for the cylinder group are wrong.
			 */
			printf("cg = %d, irotor = %d, fs = %s\n",
			    cg, cgp->cg_irotor, fs->fs_fsmnt);
			panic("ffs_nodealloccg: map corrupted");
			/* NOTREACHED */
		}
	}

	/* skpc() returns the position relative to the end */
	i = start + len - loc;

	/*
	 * Okay, so now in 'i' we have the location in the bitmap of a byte
	 * holding a free inode. Find the corresponding bit and set it,
	 * updating cg_irotor as well, accordingly.
	 */
	map = cg_inosused(cgp)[i];
	ipref = i * NBBY;
	for (i = 1; i < (1 << NBBY); i <<= 1, ipref++) {
		if ((map & i) == 0) {
			cgp->cg_irotor = ipref;
			goto gotit;
		}
	}

	printf("fs = %s\n", fs->fs_fsmnt);
	panic("ffs_nodealloccg: block not in map");
	/* NOTREACHED */

gotit:

#ifdef FFS2
	/*
	 * For FFS2, check if all inodes in this cylinder group have been used
	 * at least once. If they haven't, and we are allocating an inode past
	 * the last allocated block of inodes, read in a block and initialize
	 * all inodes in it.
	 */
	if (fs->fs_magic == FS_UFS2_MAGIC &&
	    /* Inode is beyond last initialized block of inodes? */
	    ipref + INOPB(fs) > cgp->cg_initediblk &&
	    /* Has any inode not been used at least once? */
	    cgp->cg_initediblk < cgp->cg_ffs2_niblk) {

                ibp = getblk(ip->i_devvp, fsbtodb(fs,
                    ino_to_fsba(fs, cg * fs->fs_ipg + cgp->cg_initediblk)),
                    (int)fs->fs_bsize, 0, 0);

                memset(ibp->b_data, 0, fs->fs_bsize);
                dp2 = (struct ufs2_dinode *)(ibp->b_data);

		/* Give each inode a positive generation number */
                for (i = 0; i < INOPB(fs); i++) {
                        dp2->di_gen = (arc4random() & INT32_MAX) / 2 + 1;
                        dp2++;
                }

		/* Update the counter of initialized inodes */
                cgp->cg_initediblk += INOPB(fs);
        }
#endif /* FFS2 */

	if (DOINGSOFTDEP(ITOV(ip)))
		softdep_setup_inomapdep(bp, ip, cg * fs->fs_ipg + ipref);

	setbit(cg_inosused(cgp), ipref);

	/* Update the counters we keep on free inodes */
	cgp->cg_cs.cs_nifree--;
	fs->fs_cstotal.cs_nifree--;
	fs->fs_cs(fs, cg).cs_nifree--;
	fs->fs_fmod = 1; /* file system was modified */

	/* Update the counters we keep on allocated directories */
	if ((mode & IFMT) == IFDIR) {
		cgp->cg_cs.cs_ndir++;
		fs->fs_cstotal.cs_ndir++;
		fs->fs_cs(fs, cg).cs_ndir++;
	}

	bdwrite(bp);

#ifdef FFS2
	if (ibp != NULL)
		bawrite(ibp);
#endif

	/* Return the allocated inode number */
	return (cg * fs->fs_ipg + ipref);
}

/*
 * Free a block or fragment.
 *
 * The specified block or fragment is placed back in the
 * free map. If a fragment is deallocated, a possible
 * block reassembly is checked.
 */
void
ffs_blkfree(struct inode *ip, daddr_t bno, long size)
{
	struct fs *fs;
	struct cg *cgp;
	struct buf *bp;
	daddr_t blkno;
	int i, cg, blk, frags, bbase;

	fs = ip->i_fs;
	if ((u_int)size > fs->fs_bsize || fragoff(fs, size) != 0 ||
	    fragnum(fs, bno) + numfrags(fs, size) > fs->fs_frag) {
		printf("dev = 0x%x, bsize = %d, size = %ld, fs = %s\n",
		    ip->i_dev, fs->fs_bsize, size, fs->fs_fsmnt);
		panic("ffs_blkfree: bad size");
	}
	cg = dtog(fs, bno);
	if ((u_int)bno >= fs->fs_size) {
		printf("bad block %lld, ino %u\n", (long long)bno,
		    ip->i_number);
		ffs_fserr(fs, DIP(ip, uid), "bad block");
		return;
	}
	if (!(bp = ffs_cgread(fs, ip, cg)))
		return;

	cgp = (struct cg *)bp->b_data;
	cgp->cg_ffs2_time = cgp->cg_time = time_second;

	bno = dtogd(fs, bno);
	if (size == fs->fs_bsize) {
		blkno = fragstoblks(fs, bno);
		if (!ffs_isfreeblock(fs, cg_blksfree(cgp), blkno)) {
			printf("dev = 0x%x, block = %lld, fs = %s\n",
			    ip->i_dev, (long long)bno, fs->fs_fsmnt);
			panic("ffs_blkfree: freeing free block");
		}
		ffs_setblock(fs, cg_blksfree(cgp), blkno);
		ffs_clusteracct(fs, cgp, blkno, 1);
		cgp->cg_cs.cs_nbfree++;
		fs->fs_cstotal.cs_nbfree++;
		fs->fs_cs(fs, cg).cs_nbfree++;

		if (fs->fs_magic != FS_UFS2_MAGIC) {
			i = cbtocylno(fs, bno);
			cg_blks(fs, cgp, i)[cbtorpos(fs, bno)]++;
			cg_blktot(cgp)[i]++;
		}

	} else {
		bbase = bno - fragnum(fs, bno);
		/*
		 * decrement the counts associated with the old frags
		 */
		blk = blkmap(fs, cg_blksfree(cgp), bbase);
		ffs_fragacct(fs, blk, cgp->cg_frsum, -1);
		/*
		 * deallocate the fragment
		 */
		frags = numfrags(fs, size);
		for (i = 0; i < frags; i++) {
			if (isset(cg_blksfree(cgp), bno + i)) {
				printf("dev = 0x%x, block = %lld, fs = %s\n",
				    ip->i_dev, (long long)(bno + i),
				    fs->fs_fsmnt);
				panic("ffs_blkfree: freeing free frag");
			}
			setbit(cg_blksfree(cgp), bno + i);
		}
		cgp->cg_cs.cs_nffree += i;
		fs->fs_cstotal.cs_nffree += i;
		fs->fs_cs(fs, cg).cs_nffree += i;
		/*
		 * add back in counts associated with the new frags
		 */
		blk = blkmap(fs, cg_blksfree(cgp), bbase);
		ffs_fragacct(fs, blk, cgp->cg_frsum, 1);
		/*
		 * if a complete block has been reassembled, account for it
		 */
		blkno = fragstoblks(fs, bbase);
		if (ffs_isblock(fs, cg_blksfree(cgp), blkno)) {
			cgp->cg_cs.cs_nffree -= fs->fs_frag;
			fs->fs_cstotal.cs_nffree -= fs->fs_frag;
			fs->fs_cs(fs, cg).cs_nffree -= fs->fs_frag;
			ffs_clusteracct(fs, cgp, blkno, 1);
			cgp->cg_cs.cs_nbfree++;
			fs->fs_cstotal.cs_nbfree++;
			fs->fs_cs(fs, cg).cs_nbfree++;

			if (fs->fs_magic != FS_UFS2_MAGIC) {
				i = cbtocylno(fs, bbase);
				cg_blks(fs, cgp, i)[cbtorpos(fs, bbase)]++;
				cg_blktot(cgp)[i]++;
			}
		}
	}
	fs->fs_fmod = 1;
	bdwrite(bp);
}

int
ffs_inode_free(struct inode *pip, ufsino_t ino, mode_t mode)
{
	struct vnode *pvp = ITOV(pip);

	if (DOINGSOFTDEP(pvp)) {
		softdep_freefile(pvp, ino, mode);
		return (0);
	}

	return (ffs_freefile(pip, ino, mode));
}

/*
 * Do the actual free operation.
 * The specified inode is placed back in the free map.
 */
int
ffs_freefile(struct inode *pip, ufsino_t ino, mode_t mode)
{
	struct fs *fs;
	struct cg *cgp;
	struct buf *bp;
	int cg;

	fs = pip->i_fs;
	if ((u_int)ino >= fs->fs_ipg * fs->fs_ncg)
		panic("ffs_freefile: range: dev = 0x%x, ino = %d, fs = %s",
		    pip->i_dev, ino, fs->fs_fsmnt);

	cg = ino_to_cg(fs, ino);
	if (!(bp = ffs_cgread(fs, pip, cg)))
		return (0);

	cgp = (struct cg *)bp->b_data;
	cgp->cg_ffs2_time = cgp->cg_time = time_second;

	ino %= fs->fs_ipg;
	if (isclr(cg_inosused(cgp), ino)) {
		printf("dev = 0x%x, ino = %u, fs = %s\n",
		    pip->i_dev, ino, fs->fs_fsmnt);
		if (fs->fs_ronly == 0)
			panic("ffs_freefile: freeing free inode");
	}
	clrbit(cg_inosused(cgp), ino);
	if (ino < cgp->cg_irotor)
		cgp->cg_irotor = ino;
	cgp->cg_cs.cs_nifree++;
	fs->fs_cstotal.cs_nifree++;
	fs->fs_cs(fs, cg).cs_nifree++;
	if ((mode & IFMT) == IFDIR) {
		cgp->cg_cs.cs_ndir--;
		fs->fs_cstotal.cs_ndir--;
		fs->fs_cs(fs, cg).cs_ndir--;
	}
	fs->fs_fmod = 1;
	bdwrite(bp);
	return (0);
}


/*
 * Find a block of the specified size in the specified cylinder group.
 *
 * It is a panic if a request is made to find a block if none are
 * available.
 */
daddr_t
ffs_mapsearch(struct fs *fs, struct cg *cgp, daddr_t bpref, int allocsiz)
{
	daddr_t bno;
	int start, len, loc, i;
	int blk, field, subfield, pos;

	/*
	 * find the fragment by searching through the free block
	 * map for an appropriate bit pattern
	 */
	if (bpref)
		start = dtogd(fs, bpref) / NBBY;
	else
		start = cgp->cg_frotor / NBBY;
	len = howmany(fs->fs_fpg, NBBY) - start;
	loc = scanc((u_int)len, (u_char *)&cg_blksfree(cgp)[start],
		(u_char *)fragtbl[fs->fs_frag],
		(u_char)(1 << (allocsiz - 1 + (fs->fs_frag % NBBY))));
	if (loc == 0) {
		len = start + 1;
		start = 0;
		loc = scanc((u_int)len, (u_char *)&cg_blksfree(cgp)[0],
			(u_char *)fragtbl[fs->fs_frag],
			(u_char)(1 << (allocsiz - 1 + (fs->fs_frag % NBBY))));
		if (loc == 0) {
			printf("start = %d, len = %d, fs = %s\n",
			    start, len, fs->fs_fsmnt);
			panic("ffs_alloccg: map corrupted");
			/* NOTREACHED */
		}
	}
	bno = (start + len - loc) * NBBY;
	cgp->cg_frotor = bno;
	/*
	 * found the byte in the map
	 * sift through the bits to find the selected frag
	 */
	for (i = bno + NBBY; bno < i; bno += fs->fs_frag) {
		blk = blkmap(fs, cg_blksfree(cgp), bno);
		blk <<= 1;
		field = around[allocsiz];
		subfield = inside[allocsiz];
		for (pos = 0; pos <= fs->fs_frag - allocsiz; pos++) {
			if ((blk & field) == subfield)
				return (bno + pos);
			field <<= 1;
			subfield <<= 1;
		}
	}
	printf("bno = %lld, fs = %s\n", (long long)bno, fs->fs_fsmnt);
	panic("ffs_alloccg: block not in map");
	return (-1);
}

/*
 * Update the cluster map because of an allocation or free.
 *
 * Cnt == 1 means free; cnt == -1 means allocating.
 */
void
ffs_clusteracct(struct fs *fs, struct cg *cgp, daddr_t blkno, int cnt)
{
	int32_t *sump;
	int32_t *lp;
	u_char *freemapp, *mapp;
	int i, start, end, forw, back, map, bit;

	if (fs->fs_contigsumsize <= 0)
		return;
	freemapp = cg_clustersfree(cgp);
	sump = cg_clustersum(cgp);
	/*
	 * Allocate or clear the actual block.
	 */
	if (cnt > 0)
		setbit(freemapp, blkno);
	else
		clrbit(freemapp, blkno);
	/*
	 * Find the size of the cluster going forward.
	 */
	start = blkno + 1;
	end = start + fs->fs_contigsumsize;
	if (end >= cgp->cg_nclusterblks)
		end = cgp->cg_nclusterblks;
	mapp = &freemapp[start / NBBY];
	map = *mapp++;
	bit = 1 << (start % NBBY);
	for (i = start; i < end; i++) {
		if ((map & bit) == 0)
			break;
		if ((i & (NBBY - 1)) != (NBBY - 1)) {
			bit <<= 1;
		} else {
			map = *mapp++;
			bit = 1;
		}
	}
	forw = i - start;
	/*
	 * Find the size of the cluster going backward.
	 */
	start = blkno - 1;
	end = start - fs->fs_contigsumsize;
	if (end < 0)
		end = -1;
	mapp = &freemapp[start / NBBY];
	map = *mapp--;
	bit = 1 << (start % NBBY);
	for (i = start; i > end; i--) {
		if ((map & bit) == 0)
			break;
		if ((i & (NBBY - 1)) != 0) {
			bit >>= 1;
		} else {
			map = *mapp--;
			bit = 1 << (NBBY - 1);
		}
	}
	back = start - i;
	/*
	 * Account for old cluster and the possibly new forward and
	 * back clusters.
	 */
	i = back + forw + 1;
	if (i > fs->fs_contigsumsize)
		i = fs->fs_contigsumsize;
	sump[i] += cnt;
	if (back > 0)
		sump[back] -= cnt;
	if (forw > 0)
		sump[forw] -= cnt;
	/*
	 * Update cluster summary information.
	 */
	lp = &sump[fs->fs_contigsumsize];
	for (i = fs->fs_contigsumsize; i > 0; i--)
		if (*lp-- > 0)
			break;
	fs->fs_maxcluster[cgp->cg_cgx] = i;
}
@


1.107
log
@VOP_REALLOCBLKS() and related code is unused since the removal of
cluster_write().
ok beck zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.106 2015/11/28 21:52:02 beck Exp $	*/
d471 1
a471 1
		prefcg = (arc4random() & INT_MAX) % fs->fs_ncg;
@


1.106
log
@move buffer size adjustment to buf_adjcnt - from Walter Neto
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.105 2015/09/27 05:25:00 guenther Exp $	*/
a68 1
daddr_t		ffs_clusteralloc(struct inode *, int, daddr_t, int);
a75 9
int ffs1_reallocblks(void *);
#ifdef FFS2
int ffs2_reallocblks(void *);
#endif

#ifdef DIAGNOSTIC
int      ffs_checkblk(struct inode *, daddr_t, long);
#endif

a339 459
 * Reallocate a sequence of blocks into a contiguous sequence of blocks.
 *
 * The vnode and an array of buffer pointers for a range of sequential
 * logical blocks to be made contiguous are given. The allocator attempts
 * to find a range of sequential blocks starting as close as possible to
 * an fs_rotdelay offset from the end of the allocation for the logical
 * block immediately preceding the current range. If successful, the
 * physical block numbers in the buffer pointers and in the inode are
 * changed to reflect the new allocation. If unsuccessful, the allocation
 * is left unchanged. The success in doing the reallocation is returned.
 * Note that the error return is not reflected back to the user. Rather
 * the previous block allocation will be used.
 */

int doasyncfree = 1;
int doreallocblks = 1;
int prtrealloc = 0;

int
ffs1_reallocblks(void *v)
{
	struct vop_reallocblks_args *ap = v;
	struct fs *fs;
	struct inode *ip;
	struct vnode *vp;
	struct buf *sbp, *ebp;
	int32_t *bap, *sbap, *ebap = NULL;
	struct cluster_save *buflist;
	daddr_t start_lbn, end_lbn, soff, newblk, blkno;
	struct indir start_ap[NIADDR + 1], end_ap[NIADDR + 1], *idp;
	int i, len, start_lvl, end_lvl, pref, ssize;

	vp = ap->a_vp;
	ip = VTOI(vp);
	fs = ip->i_fs;
	if (fs->fs_contigsumsize <= 0)
		return (ENOSPC);
	buflist = ap->a_buflist;
	len = buflist->bs_nchildren;
	start_lbn = buflist->bs_children[0]->b_lblkno;
	end_lbn = start_lbn + len - 1;

#ifdef DIAGNOSTIC
	for (i = 0; i < len; i++)
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs1_reallocblks: unallocated block 1");

	for (i = 1; i < len; i++)
		if (buflist->bs_children[i]->b_lblkno != start_lbn + i)
			panic("ffs1_reallocblks: non-logical cluster");

	blkno = buflist->bs_children[0]->b_blkno;
	ssize = fsbtodb(fs, fs->fs_frag);
	for (i = 1; i < len - 1; i++)
		if (buflist->bs_children[i]->b_blkno != blkno + (i * ssize))
			panic("ffs1_reallocblks: non-physical cluster %d", i);
#endif
	/*
	 * If the latest allocation is in a new cylinder group, assume that
	 * the filesystem has decided to move and do not force it back to
	 * the previous cylinder group.
	 */
	if (dtog(fs, dbtofsb(fs, buflist->bs_children[0]->b_blkno)) !=
	    dtog(fs, dbtofsb(fs, buflist->bs_children[len - 1]->b_blkno)))
		return (ENOSPC);
	if (ufs_getlbns(vp, start_lbn, start_ap, &start_lvl) ||
	    ufs_getlbns(vp, end_lbn, end_ap, &end_lvl))
		return (ENOSPC);
	/*
	 * Get the starting offset and block map for the first block.
	 */
	if (start_lvl == 0) {
		sbap = &ip->i_ffs1_db[0];
		soff = start_lbn;
	} else {
		idp = &start_ap[start_lvl - 1];
		if (bread(vp, idp->in_lbn, (int)fs->fs_bsize, &sbp)) {
			brelse(sbp);
			return (ENOSPC);
		}
		sbap = (int32_t *)sbp->b_data;
		soff = idp->in_off;
	}
	/*
	 * Find the preferred location for the cluster.
	 */
	pref = ffs1_blkpref(ip, start_lbn, soff, sbap);
	/*
	 * If the block range spans two block maps, get the second map.
	 */
	if (end_lvl == 0 || (idp = &end_ap[end_lvl - 1])->in_off + 1 >= len) {
		ssize = len;
	} else {
#ifdef DIAGNOSTIC
		if (start_lvl > 1 &&
		    start_ap[start_lvl-1].in_lbn == idp->in_lbn)
			panic("ffs1_reallocblk: start == end");
#endif
		ssize = len - (idp->in_off + 1);
		if (bread(vp, idp->in_lbn, (int)fs->fs_bsize, &ebp))
			goto fail;
		ebap = (int32_t *)ebp->b_data;
	}
	/*
	 * Search the block map looking for an allocation of the desired size.
	 */
	if ((newblk = ffs_hashalloc(ip, dtog(fs, pref), pref, len,
	    ffs_clusteralloc)) == 0)
		goto fail;
	/*
	 * We have found a new contiguous block.
	 *
	 * First we have to replace the old block pointers with the new
	 * block pointers in the inode and indirect blocks associated
	 * with the file.
	 */
#ifdef DEBUG
	if (prtrealloc)
		printf("realloc: ino %u, lbns %lld-%lld\n\told:", ip->i_number,
		    (long long)start_lbn, (long long)end_lbn);
#endif
	blkno = newblk;
	for (bap = &sbap[soff], i = 0; i < len; i++, blkno += fs->fs_frag) {
		if (i == ssize) {
			bap = ebap;
			soff = -i;
		}
#ifdef DIAGNOSTIC
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs1_reallocblks: unallocated block 2");
		if (dbtofsb(fs, buflist->bs_children[i]->b_blkno) != *bap)
			panic("ffs1_reallocblks: alloc mismatch");
#endif
#ifdef DEBUG
		if (prtrealloc)
			printf(" %d,", *bap);
#endif
		if (DOINGSOFTDEP(vp)) {
			if (sbap == &ip->i_ffs1_db[0] && i < ssize)
				softdep_setup_allocdirect(ip, start_lbn + i,
				    blkno, *bap, fs->fs_bsize, fs->fs_bsize,
				    buflist->bs_children[i]);
			else
				softdep_setup_allocindir_page(ip, start_lbn + i,
				    i < ssize ? sbp : ebp, soff + i, blkno,
				    *bap, buflist->bs_children[i]);
		}

		*bap++ = blkno;
	}
	/*
	 * Next we must write out the modified inode and indirect blocks.
	 * For strict correctness, the writes should be synchronous since
	 * the old block values may have been written to disk. In practise
	 * they are almost never written, but if we are concerned about
	 * strict correctness, the `doasyncfree' flag should be set to zero.
	 *
	 * The test on `doasyncfree' should be changed to test a flag
	 * that shows whether the associated buffers and inodes have
	 * been written. The flag should be set when the cluster is
	 * started and cleared whenever the buffer or inode is flushed.
	 * We can then check below to see if it is set, and do the
	 * synchronous write only when it has been cleared.
	 */
	if (sbap != &ip->i_ffs1_db[0]) {
		if (doasyncfree)
			bdwrite(sbp);
		else
			bwrite(sbp);
	} else {
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		if (!doasyncfree) {
			UFS_UPDATE(ip, 1);
		}
	}
	if (ssize < len) {
		if (doasyncfree)
			bdwrite(ebp);
		else
			bwrite(ebp);
	}
	/*
	 * Last, free the old blocks and assign the new blocks to the buffers.
	 */
#ifdef DEBUG
	if (prtrealloc)
		printf("\n\tnew:");
#endif
	for (blkno = newblk, i = 0; i < len; i++, blkno += fs->fs_frag) {
		if (!DOINGSOFTDEP(vp))
			ffs_blkfree(ip,
			    dbtofsb(fs, buflist->bs_children[i]->b_blkno),
			    fs->fs_bsize);
		buflist->bs_children[i]->b_blkno = fsbtodb(fs, blkno);
#ifdef DIAGNOSTIC
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs1_reallocblks: unallocated block 3");
		if (prtrealloc)
			printf(" %lld,", (long long)blkno);
#endif
	}
#ifdef DEBUG
	if (prtrealloc) {
		prtrealloc--;
		printf("\n");
	}
#endif
	return (0);

fail:
	if (ssize < len)
		brelse(ebp);
	if (sbap != &ip->i_ffs1_db[0])
		brelse(sbp);
	return (ENOSPC);
}

#ifdef FFS2
int
ffs2_reallocblks(void *v)
{
	struct vop_reallocblks_args *ap = v;
	struct fs *fs;
	struct inode *ip;
	struct vnode *vp;
	struct buf *sbp, *ebp;
	daddr_t *bap, *sbap, *ebap = NULL;
	struct cluster_save *buflist;
	daddr_t start_lbn, end_lbn;
	daddr_t soff, newblk, blkno, pref;
	struct indir start_ap[NIADDR + 1], end_ap[NIADDR + 1], *idp;
	int i, len, start_lvl, end_lvl, ssize;

	vp = ap->a_vp;
	ip = VTOI(vp);
	fs = ip->i_fs;

	if (fs->fs_contigsumsize <= 0)
		return (ENOSPC);

	buflist = ap->a_buflist;
	len = buflist->bs_nchildren;
	start_lbn = buflist->bs_children[0]->b_lblkno;
	end_lbn = start_lbn + len - 1;

#ifdef DIAGNOSTIC
	for (i = 0; i < len; i++)
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs2_reallocblks: unallocated block 1");

	for (i = 1; i < len; i++)
		if (buflist->bs_children[i]->b_lblkno != start_lbn + i)
			panic("ffs2_reallocblks: non-logical cluster");

	blkno = buflist->bs_children[0]->b_blkno;
	ssize = fsbtodb(fs, fs->fs_frag);

	for (i = 1; i < len - 1; i++)
		if (buflist->bs_children[i]->b_blkno != blkno + (i * ssize))
			panic("ffs2_reallocblks: non-physical cluster %d", i);
#endif

	/*
	 * If the latest allocation is in a new cylinder group, assume that
	 * the filesystem has decided to move and do not force it back to
	 * the previous cylinder group.
	 */
	if (dtog(fs, dbtofsb(fs, buflist->bs_children[0]->b_blkno)) !=
	    dtog(fs, dbtofsb(fs, buflist->bs_children[len - 1]->b_blkno)))
		return (ENOSPC);
	if (ufs_getlbns(vp, start_lbn, start_ap, &start_lvl) ||
	    ufs_getlbns(vp, end_lbn, end_ap, &end_lvl))
		return (ENOSPC);

	/*
	 * Get the starting offset and block map for the first block.
	 */
	if (start_lvl == 0) {
		sbap = &ip->i_din2->di_db[0];
		soff = start_lbn;
	} else {
		idp = &start_ap[start_lvl - 1];
		if (bread(vp, idp->in_lbn, (int)fs->fs_bsize, &sbp)) {
			brelse(sbp);
			return (ENOSPC);
		}
		sbap = (daddr_t *)sbp->b_data;
		soff = idp->in_off;
	}

	/*
	 * If the block range spans two block maps, get the second map.
	 */
	if (end_lvl == 0 || (idp = &end_ap[end_lvl - 1])->in_off + 1 >= len) {
		ssize = len;
	} else {
#ifdef DIAGNOSTIC
		if (start_ap[start_lvl-1].in_lbn == idp->in_lbn)
			panic("ffs2_reallocblk: start == end");
#endif
		ssize = len - (idp->in_off + 1);
		if (bread(vp, idp->in_lbn, (int)fs->fs_bsize, &ebp))
			goto fail;
		ebap = (daddr_t *)ebp->b_data;
	}

	/*
	 * Find the preferred location for the cluster.
	 */
	pref = ffs2_blkpref(ip, start_lbn, soff, sbap);

	/*
	 * Search the block map looking for an allocation of the desired size.
	 */
	if ((newblk = ffs_hashalloc(ip, dtog(fs, pref), pref,
	    len, ffs_clusteralloc)) == 0)
		goto fail;

	/*
	 * We have found a new contiguous block.
	 *
	 * First we have to replace the old block pointers with the new
	 * block pointers in the inode and indirect blocks associated
	 * with the file.
	 */
#ifdef DEBUG
	if (prtrealloc)
		printf("realloc: ino %u, lbns %lld-%lld\n\told:", ip->i_number,
		    (long long)start_lbn, (long long)end_lbn);
#endif

	blkno = newblk;

	for (bap = &sbap[soff], i = 0; i < len; i++, blkno += fs->fs_frag) {
		if (i == ssize) {
			bap = ebap;
			soff = -i;
		}
#ifdef DIAGNOSTIC
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs2_reallocblks: unallocated block 2");
		if (dbtofsb(fs, buflist->bs_children[i]->b_blkno) != *bap)
			panic("ffs2_reallocblks: alloc mismatch");
#endif
#ifdef DEBUG
		if (prtrealloc)
			printf(" %lld,", (long long)*bap);
#endif
		if (DOINGSOFTDEP(vp)) {
			if (sbap == &ip->i_din2->di_db[0] && i < ssize)
				softdep_setup_allocdirect(ip, start_lbn + i,
				    blkno, *bap, fs->fs_bsize, fs->fs_bsize,
				    buflist->bs_children[i]);
			else
				softdep_setup_allocindir_page(ip, start_lbn + i,
				    i < ssize ? sbp : ebp, soff + i, blkno,
				    *bap, buflist->bs_children[i]);
		}
		*bap++ = blkno;
	}

	/*
	 * Next we must write out the modified inode and indirect blocks.
	 * For strict correctness, the writes should be synchronous since
	 * the old block values may have been written to disk. In practise
	 * they are almost never written, but if we are concerned about
	 * strict correctness, the `doasyncfree' flag should be set to zero.
	 *
	 * The test on `doasyncfree' should be changed to test a flag
	 * that shows whether the associated buffers and inodes have
	 * been written. The flag should be set when the cluster is
	 * started and cleared whenever the buffer or inode is flushed.
	 * We can then check below to see if it is set, and do the
	 * synchronous write only when it has been cleared.
	 */
	if (sbap != &ip->i_din2->di_db[0]) {
		if (doasyncfree)
			bdwrite(sbp);
		else
			bwrite(sbp);
	} else {
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		if (!doasyncfree)
			ffs_update(ip, 1);
	}

	if (ssize < len) {
		if (doasyncfree)
			bdwrite(ebp);
		else
			bwrite(ebp);
	}

	/*
	 * Last, free the old blocks and assign the new blocks to the buffers.
	 */
#ifdef DEBUG
	if (prtrealloc)
		printf("\n\tnew:");
#endif
	for (blkno = newblk, i = 0; i < len; i++, blkno += fs->fs_frag) {
		if (!DOINGSOFTDEP(vp))
			ffs_blkfree(ip, dbtofsb(fs,
			    buflist->bs_children[i]->b_blkno), fs->fs_bsize);
		buflist->bs_children[i]->b_blkno = fsbtodb(fs, blkno);
#ifdef DIAGNOSTIC
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs2_reallocblks: unallocated block 3");
#endif
#ifdef DEBUG
		if (prtrealloc)
			printf(" %lld,", (long long)blkno);
#endif
	}
#ifdef DEBUG
	if (prtrealloc) {
		prtrealloc--;
		printf("\n");
	}
#endif

	return (0);

fail:
	if (ssize < len)
		brelse(ebp);

	if (sbap != &ip->i_din2->di_db[0])
		brelse(sbp);

	return (ENOSPC);
}
#endif /* FFS2 */

int
ffs_reallocblks(void *v)
{
#ifdef FFS2
	struct vop_reallocblks_args *ap = v;
#endif

	if (!doreallocblks)
		return (ENOSPC);

#ifdef FFS2
	if (VTOI(ap->a_vp)->i_ump->um_fstype == UM_UFS2)
		return (ffs2_reallocblks(v));
#endif

	return (ffs1_reallocblks(v));
}

/*
a1081 113
/*
 * Determine whether a cluster can be allocated.
 *
 * We do not currently check for optimal rotational layout if there
 * are multiple choices in the same cylinder group. Instead we just
 * take the first one that we find following bpref.
 */
daddr_t
ffs_clusteralloc(struct inode *ip, int cg, daddr_t bpref, int len)
{
	struct fs *fs;
	struct cg *cgp;
	struct buf *bp;
	int i, got, run, bno, bit, map;
	u_char *mapp;
	int32_t *lp;

	fs = ip->i_fs;
	if (fs->fs_maxcluster[cg] < len)
		return (0);

	if (!(bp = ffs_cgread(fs, ip, cg)))
		return (0);

	cgp = (struct cg *)bp->b_data;

	/*
	 * Check to see if a cluster of the needed size (or bigger) is
	 * available in this cylinder group.
	 */
	lp = &cg_clustersum(cgp)[len];
	for (i = len; i <= fs->fs_contigsumsize; i++)
		if (*lp++ > 0)
			break;
	if (i > fs->fs_contigsumsize) {
		/*
		 * This is the first time looking for a cluster in this
		 * cylinder group. Update the cluster summary information
		 * to reflect the true maximum sized cluster so that
		 * future cluster allocation requests can avoid reading
		 * the cylinder group map only to find no clusters.
		 */
		lp = &cg_clustersum(cgp)[len - 1];
		for (i = len - 1; i > 0; i--)
			if (*lp-- > 0)
				break;
		fs->fs_maxcluster[cg] = i;
		goto fail;
	}
	/*
	 * Search the cluster map to find a big enough cluster.
	 * We take the first one that we find, even if it is larger
	 * than we need as we prefer to get one close to the previous
	 * block allocation. We do not search before the current
	 * preference point as we do not want to allocate a block
	 * that is allocated before the previous one (as we will
	 * then have to wait for another pass of the elevator
	 * algorithm before it will be read). We prefer to fail and
	 * be recalled to try an allocation in the next cylinder group.
	 */
	if (dtog(fs, bpref) != cg)
		bpref = cgdata(fs, cg);
	else
		bpref = blknum(fs, bpref);
	bpref = fragstoblks(fs, dtogd(fs, bpref));
	mapp = &cg_clustersfree(cgp)[bpref / NBBY];
	map = *mapp++;
	bit = 1 << (bpref % NBBY);
	for (run = 0, got = bpref; got < cgp->cg_nclusterblks; got++) {
		if ((map & bit) == 0) {
			run = 0;
		} else {
			run++;
			if (run == len)
				break;
		}
		if ((got & (NBBY - 1)) != (NBBY - 1)) {
			bit <<= 1;
		} else {
			map = *mapp++;
			bit = 1;
		}
	}
	if (got >= cgp->cg_nclusterblks)
		goto fail;
	/*
	 * Allocate the cluster that we have found.
	 */
	cgp->cg_ffs2_time = cgp->cg_time = time_second;

#ifdef DIAGNOSTIC
	for (i = 1; i <= len; i++)
		if (!ffs_isblock(fs, cg_blksfree(cgp), got - run + i))
			panic("ffs_clusteralloc: map mismatch");
#endif
	bno = cgbase(fs, cg) + blkstofrags(fs, got - run + 1);
#ifdef DIAGNOSTIC
	if (dtog(fs, bno) != cg)
		panic("ffs_clusteralloc: allocated out of group");
#endif

	len = blkstofrags(fs, len);
	for (i = 0; i < len; i += fs->fs_frag)
		if (ffs_alloccgblk(ip, bp, bno + i) != bno + i)
			panic("ffs_clusteralloc: lost block");
	bdwrite(bp);
	return (bno);

fail:
	brelse(bp);
	return (0);
}

a1405 42

#ifdef DIAGNOSTIC
/*
 * Verify allocation of a block or fragment. Returns true if block or
 * fragment is allocated, false if it is free.
 */
int
ffs_checkblk(struct inode *ip, daddr_t bno, long size)
{
	struct fs *fs;
	struct cg *cgp;
	struct buf *bp;
	int i, frags, free;

	fs = ip->i_fs;
	if ((u_int)size > fs->fs_bsize || fragoff(fs, size) != 0) {
		printf("bsize = %d, size = %ld, fs = %s\n",
		    fs->fs_bsize, size, fs->fs_fsmnt);
		panic("ffs_checkblk: bad size");
	}
	if ((u_int)bno >= fs->fs_size)
		panic("ffs_checkblk: bad block %lld", (long long)bno);

	if (!(bp = ffs_cgread(fs, ip, dtog(fs, bno))))
		return (0);

	cgp = (struct cg *)bp->b_data;
	bno = dtogd(fs, bno);
	if (size == fs->fs_bsize) {
		free = ffs_isblock(fs, cg_blksfree(cgp), fragstoblks(fs, bno));
	} else {
		frags = numfrags(fs, size);
		for (free = 0, i = 0; i < frags; i++)
			if (isset(cg_blksfree(cgp), bno + i))
				free++;
		if (free != 0 && free != frags)
			panic("ffs_checkblk: partially free fragment");
	}
	brelse(bp);
	return (!free);
}
#endif /* DIAGNOSTIC */
@


1.105
log
@lint is dead: delete the trivial uses of /* VARARGS[0-9]+ */
(others require more care)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.104 2015/03/14 03:38:52 jsg Exp $	*/
d221 1
a221 1
		bp->b_bcount = osize;
d244 1
a244 1
			bp->b_bcount = nsize;
d316 1
a316 1
		bp->b_bcount = nsize;
@


1.104
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.103 2014/11/18 02:37:31 tedu Exp $	*/
a1268 1
/*VARARGS5*/
@


1.103
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.102 2014/09/14 14:17:26 jsg Exp $	*/
a48 1
#include <sys/kernel.h>
@


1.102
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.101 2014/07/08 17:19:26 deraadt Exp $	*/
a52 2

#include <dev/rndvar.h>
@


1.101
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.100 2014/05/22 02:02:39 guenther Exp $	*/
a46 1
#include <sys/proc.h>
@


1.100
log
@From FreeBSD: the second argument to UFS_UPDATE/ffs_update is just a
boolean, not a MNT_* flag.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.99 2014/01/25 23:31:12 guenther Exp $	*/
a53 2

#include <uvm/uvm_extern.h>
@


1.99
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.98 2013/12/12 19:00:09 tedu Exp $	*/
d530 1
a530 1
			UFS_UPDATE(ip, MNT_WAIT);
d744 1
a744 1
			ffs_update(ip, MNT_WAIT);
@


1.98
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.97 2013/11/01 17:36:19 krw Exp $	*/
d744 1
a744 1
			ffs_update(ip, NULL, NULL, MNT_WAIT);
@


1.97
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.96 2013/06/11 16:42:18 deraadt Exp $	*/
d252 1
a252 1
			bzero(bp->b_data + osize, (u_int)nsize - osize);
d324 1
a324 1
		bzero(bp->b_data + osize, (u_int)nsize - osize);
d1785 1
a1785 1
                bzero(ibp->b_data, (int)fs->fs_bsize);
@


1.96
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.95 2013/06/08 23:02:26 beck Exp $	*/
d217 1
a217 1
		    ip->i_dev, fs->fs_bsize, bprev, fs->fs_fsmnt);
d476 1
a476 1
		    start_lbn, end_lbn);
d557 1
a557 1
			printf(" %lld,", blkno);
d688 1
a688 1
		    start_lbn, end_lbn);
d707 1
a707 1
			printf(" %lld,", *bap);
d773 1
a773 1
			printf(" %lld,", blkno);
d883 1
a883 1
		    fs->fs_fsmnt, ino, (daddr_t)DIP(ip, blocks));
d1853 2
a1854 1
		printf("bad block %lld, ino %u\n", bno, ip->i_number);
d1869 1
a1869 1
			    ip->i_dev, bno, fs->fs_fsmnt);
d1898 2
a1899 1
				    ip->i_dev, bno + i, fs->fs_fsmnt);
d2016 1
a2016 1
		panic("ffs_checkblk: bad block %lld", bno);
d2095 1
a2095 1
	printf("bno = %lld, fs = %s\n", bno, fs->fs_fsmnt);
@


1.95
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.94 2013/05/30 19:19:09 guenther Exp $	*/
d72 1
a72 1
daddr64_t	ffs_alloccg(struct inode *, int, daddr64_t, int);
d74 2
a75 2
daddr64_t	ffs_alloccgblk(struct inode *, struct buf *, daddr64_t);
daddr64_t	ffs_clusteralloc(struct inode *, int, daddr64_t, int);
d77 5
a81 5
daddr64_t	ffs_fragextend(struct inode *, int, daddr64_t, int, int);
daddr64_t	ffs_hashalloc(struct inode *, int, daddr64_t, int,
    daddr64_t (*)(struct inode *, int, daddr64_t, int));
daddr64_t	ffs_nodealloccg(struct inode *, int, daddr64_t, int);
daddr64_t	ffs_mapsearch(struct fs *, struct cg *, daddr64_t, int);
d89 1
a89 1
int      ffs_checkblk(struct inode *, daddr64_t, long);
d115 2
a116 2
ffs_alloc(struct inode *ip, daddr64_t lbn, daddr64_t bpref, int size,
    struct ucred *cred, daddr64_t *bnp)
d120 1
a120 1
	daddr64_t bno;
d186 2
a187 2
ffs_realloccg(struct inode *ip, daddr64_t lbprev, daddr64_t bpref, int osize,
    int nsize, struct ucred *cred, struct buf **bpp, daddr64_t *blknop)
d192 1
a192 1
	daddr64_t quota_updated = 0;
d194 1
a194 1
	daddr64_t bprev, bno;
d384 1
a384 1
	daddr64_t start_lbn, end_lbn, soff, newblk, blkno;
d585 1
a585 1
	daddr64_t *bap, *sbap, *ebap = NULL;
d587 2
a588 2
	daddr64_t start_lbn, end_lbn;
	daddr64_t soff, newblk, blkno, pref;
d646 1
a646 1
		sbap = (daddr64_t *)sbp->b_data;
d663 1
a663 1
		ebap = (daddr64_t *)ebp->b_data;
d883 1
a883 1
		    fs->fs_fsmnt, ino, (daddr64_t)DIP(ip, blocks));
d1069 1
a1069 1
ffs1_blkpref(struct inode *ip, daddr64_t lbn, int indx, int32_t *bap)
d1169 1
a1169 1
ffs2_blkpref(struct inode *ip, daddr64_t lbn, int indx, int64_t *bap)
d1276 3
a1278 3
daddr64_t
ffs_hashalloc(struct inode *ip, int cg, daddr64_t pref, int size,
    daddr64_t (*allocator)(struct inode *, int, daddr64_t, int))
d1281 1
a1281 1
	daddr64_t result;
d1344 2
a1345 2
daddr64_t
ffs_fragextend(struct inode *ip, int cg, daddr64_t bprev, int osize, int nsize)
d1350 1
a1350 1
	daddr64_t bno;
d1407 2
a1408 2
daddr64_t
ffs_alloccg(struct inode *ip, int cg, daddr64_t bpref, int size)
d1413 1
a1413 1
	daddr64_t bno, blkno;
d1496 2
a1497 2
daddr64_t
ffs_alloccgblk(struct inode *ip, struct buf *bp, daddr64_t bpref)
d1501 1
a1501 1
	daddr64_t bno, blkno;
d1565 2
a1566 2
daddr64_t
ffs_clusteralloc(struct inode *ip, int cg, daddr64_t bpref, int len)
d1672 2
a1673 2
daddr64_t
ffs_nodealloccg(struct inode *ip, int cg, daddr64_t ipref, int mode)
d1836 1
a1836 1
ffs_blkfree(struct inode *ip, daddr64_t bno, long size)
d1841 1
a1841 1
	daddr64_t blkno;
d2000 1
a2000 1
ffs_checkblk(struct inode *ip, daddr64_t bno, long size)
d2043 2
a2044 2
daddr64_t
ffs_mapsearch(struct fs *fs, struct cg *cgp, daddr64_t bpref, int allocsiz)
d2046 1
a2046 1
	daddr64_t bno;
d2104 1
a2104 1
ffs_clusteracct(struct fs *fs, struct cg *cgp, daddr64_t blkno, int cnt)
@


1.94
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.93 2013/04/23 20:42:38 tedu Exp $	*/
d305 1
a305 1
	if (bno <= 0) 
d351 1
a351 1
		
d403 1
a403 1
		
d816 1
a816 1
 * 
d839 1
a839 1
	
d1448 1
a1448 1
		 * no fragments were available, so a block will be 
@


1.93
log
@change ffs layout policy. try to pack meta data in close to the start of
each cylinder group, which should speed up disk access a little and fsck
substantially. adapted from freebsd.
for more info: www.mckusick.com/publications/faster_fsck.pdf
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.92 2011/09/18 23:20:28 bluhm Exp $	*/
d76 1
a76 1
ino_t		ffs_dirpref(struct inode *);
d837 1
a837 1
	ino_t ino, ipref;
d864 1
a864 1
	ino = (ino_t)ffs_hashalloc(pip, cg, ipref, mode, ffs_nodealloccg);
d926 1
a926 1
ino_t
d1040 1
a1040 1
	return ((ino_t)(fs->fs_ipg * cg));
d1935 1
a1935 1
ffs_inode_free(struct inode *pip, ino_t ino, mode_t mode)
d1952 1
a1952 1
ffs_freefile(struct inode *pip, ino_t ino, mode_t mode)
@


1.92
log
@Fix more printf format string bugs in sys/ufs.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.91 2011/07/04 04:30:41 tedu Exp $	*/
d999 16
d1023 1
a1023 1
	for (cg = 0; cg < prefcg; cg++)
d1036 1
a1036 1
	for (cg = 0; cg < prefcg; cg++)
d1050 9
a1058 3
 * the file. If no blocks have been allocated in any other section, the
 * policy is to place the section in a cylinder group with a greater than
 * average number of free blocks.  An appropriate cylinder group is found
d1072 2
a1073 1
	int cg, avgbfree, startcg;
d1075 1
d1077 45
d1123 13
a1135 4
		if (lbn < NDADDR + NINDIR(fs)) {
			cg = ino_to_cg(fs, ip->i_number);
			return (cgbase(fs, cg) + fs->fs_frag);
		}
d1141 1
a1141 2
			startcg =
			    ino_to_cg(fs, ip->i_number) + lbn / fs->fs_maxbpg;
d1149 1
a1149 1
				return (cgbase(fs, cg) + fs->fs_frag);
d1154 1
a1154 1
				return (cgbase(fs, cg) + fs->fs_frag);
d1158 3
a1160 1

d1172 2
a1173 1
	int cg, avgbfree, startcg;
d1175 1
d1177 45
d1224 13
a1236 5
		if (lbn < NDADDR + NINDIR(fs)) {
			cg = ino_to_cg(fs, ip->i_number);
			return (cgbase(fs, cg) + fs->fs_frag);
		}

d1242 1
a1242 2
			startcg = ino_to_cg(fs, ip->i_number) +
			    lbn / fs->fs_maxbpg;
d1261 1
a1261 1
	 * We always just try to lay things out contiguously.
d1503 1
a1503 1
	int cylno;
d1509 1
a1509 1
	if (bpref == 0 || dtog(fs, bpref) != cgp->cg_cgx)
d1511 6
a1516 8
	else {
		bpref = blknum(fs, bpref);
		bno = dtogd(fs, bpref);
		/*
		 * If the requested block is available, use it.
		 */
		if (ffs_isblock(fs, blksfree, fragstoblks(fs, bno)))
			goto gotit;
d1518 6
a1523 1

d1531 3
a1533 1
	cgp->cg_rotor = bno;
d1619 1
a1619 1
		bpref = 0;
d1621 2
a1622 1
		bpref = fragstoblks(fs, dtogd(fs, blknum(fs, bpref)));
@


1.91
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.90 2011/07/03 18:23:10 tedu Exp $	*/
d475 1
a475 1
		printf("realloc: ino %d, lbns %lld-%lld\n\told:", ip->i_number,
d687 1
a687 1
		printf("realloc: ino %d, lbns %lld-%lld\n\told:", ip->i_number,
d876 1
a876 1
		printf("mode = 0%o, inum = %d, fs = %s\n",
@


1.90
log
@correctify NULL 0 confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.89 2010/07/13 18:52:25 otto Exp $	*/
d225 1
a225 2
		if ((error = bread(ITOV(ip), lbprev, fs->fs_bsize,
		    NOCRED, &bp)) != 0)
d433 1
a433 1
		if (bread(vp, idp->in_lbn, (int)fs->fs_bsize, NOCRED, &sbp)) {
d456 1
a456 1
		if (bread(vp, idp->in_lbn, (int)fs->fs_bsize, NOCRED, &ebp))
d642 1
a642 1
		if (bread(vp, idp->in_lbn, (int)fs->fs_bsize, NOCRED, &sbp)) {
d661 1
a661 1
		if (bread(vp, idp->in_lbn, (int)fs->fs_bsize, NOCRED, &ebp))
d1192 1
a1192 1
		(int)fs->fs_cgsize, NOCRED, &bp)) {
@


1.89
log
@fix overflow of dirsize; from FreeBSD; PR 6426; ok beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.88 2010/01/16 15:45:10 chl Exp $	*/
d586 1
a586 1
	daddr64_t *bap, *sbap, *ebap = 0;
@


1.88
log
@Remove dead assignment and newly created unused variable.

Found by LLVM/Clang Static Analyzer.

ok tedu@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.87 2009/01/17 18:50:25 grange Exp $	*/
d986 4
a989 1
	maxcontigdirs = min(avgbfree * fs->fs_bsize  / dirsize, 255);
@


1.87
log
@Use proper assignment macros for dinode manipulations instead of
abusing the DIP() macro which is an rvalue and can't be used
as an lvalue. No functional changes.

ok tedu@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.86 2008/08/08 16:17:38 thib Exp $	*/
a587 1
	struct ufsmount *ump;
a595 1
	ump = ip->i_ump;
@


1.86
log
@use cgbase() instead of doing arthmetic on fs_fpg when calculating
block# too ensure proper casting.

From FreeBSD;

ok miod@@, pedro@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.85 2008/08/02 08:34:36 otto Exp $	*/
d897 3
a899 1
	if (DIP(ip, gen) == 0 || ++(DIP(ip, gen)) == 0)
@


1.85
log
@fix printf format specifiers; ok krw@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.84 2008/07/22 18:44:25 miod Exp $	*/
d1349 1
a1349 1
	blkno = (daddr64_t)cg * fs->fs_fpg + bno;
d1410 1
a1410 1
	blkno = (daddr64_t)cgp->cg_cgx * fs->fs_fpg + bno;
d1512 1
a1512 1
	bno = cg * fs->fs_fpg + blkstofrags(fs, got - run + 1);
@


1.84
log
@Use cgbase() instead of doing arithmetic on fs_fpg, for the former does
proper casts to ensure the result is not truncated.
From FreeBSD via NetBSD. ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.83 2008/04/10 19:39:37 thib Exp $	*/
d216 1
a216 1
		printf("dev = 0x%x, bsize = %d, bprev = %d, fs = %s\n",
d476 1
a476 1
		printf("realloc: ino %d, lbns %d-%d\n\told:", ip->i_number,
d558 1
a558 1
			printf(" %d,", blkno);
d690 2
a691 2
		printf("realloc: ino %d, lbns %jd-%jd\n\told:", ip->i_number,
		    (intmax_t)start_lbn, (intmax_t)end_lbn);
d710 1
a710 1
			printf(" %jd,", (intmax_t)*bap);
d776 1
a776 1
			printf(" %jd,", (intmax_t)blkno);
d885 2
a886 2
		printf("free inode %s/%d had %d blocks\n",
		    fs->fs_fsmnt, ino, DIP(ip, blocks));
d1712 1
a1712 1
		printf("bad block %d, ino %u\n", bno, ip->i_number);
d1726 1
a1726 1
			printf("dev = 0x%x, block = %d, fs = %s\n",
d1755 1
a1755 1
				printf("dev = 0x%x, block = %d, fs = %s\n",
d1873 1
a1873 1
		panic("ffs_checkblk: bad block %d", bno);
d1952 1
a1952 1
	printf("bno = %d, fs = %s\n", bno, fs->fs_fsmnt);
@


1.83
log
@the ffs code is a bit noisy when it runs out of inodes/space etc;
so ratelimit the messages to about once every 2secs.

ok dlg@@ (who also pointed out me missing 'static' in the timeval decls.)
"sounds good to me" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.82 2008/01/22 20:45:00 otto Exp $	*/
d1054 1
a1054 1
			return (fs->fs_fpg * cg + fs->fs_frag);
d1070 1
a1070 1
				return (fs->fs_fpg * cg + fs->fs_frag);
d1075 1
a1075 1
				return (fs->fs_fpg * cg + fs->fs_frag);
d1098 1
a1098 1
			return ((int64_t)fs->fs_fpg * cg + fs->fs_frag);
d1116 1
a1116 2
				return ((int64_t)fs->fs_fpg * cg +
				    fs->fs_frag);
d1120 1
a1120 2
				return ((int64_t)fs->fs_fpg * cg +
				    fs->fs_frag);
@


1.82
log
@with a lot of fragments per cylinder group and lots of cylinder
groups, it is possible that fpg * ncg overflows an int.  Problem
seen by jared rr spiegel while playing with very small fragments
on a large disk.  ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.81 2008/01/05 19:49:26 otto Exp $	*/
d53 1
d92 3
d118 1
d169 5
a173 2
	ffs_fserr(fs, cred->cr_uid, "file system full");
	uprintf("\n%s: write failed, file system is full\n", fs->fs_fsmnt);
d189 1
d334 5
a338 5
	/*
	 * no space available
	 */
	ffs_fserr(fs, cred->cr_uid, "file system full");
	uprintf("\n%s: write failed, file system is full\n", fs->fs_fsmnt);
d836 1
d906 5
a910 2
	ffs_fserr(fs, cred->cr_uid, "out of inodes");
	uprintf("\n%s: create/symlink failed, no inodes free\n", fs->fs_fsmnt);
@


1.81
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.80 2007/11/09 09:59:54 thib Exp $	*/
d1085 1
a1085 1
			return (fs->fs_fpg * cg + fs->fs_frag);
d1103 2
a1104 1
				return (fs->fs_fpg * cg + fs->fs_frag);
d1108 2
a1109 1
				return (fs->fs_fpg * cg + fs->fs_frag);
d1338 1
a1338 1
	blkno = cg * fs->fs_fpg + bno;
d1399 1
a1399 1
	blkno = cgp->cg_cgx * fs->fs_fpg + bno;
@


1.80
log
@Code to read in the cylinder groups is duplicated in a few spots,
factor it into a new function, ffs_cgread(); and use that.

From mickey;

OK art@@, toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.79 2007/09/10 20:59:00 thib Exp $	*/
d71 10
a80 10
daddr_t	ffs_alloccg(struct inode *, int, daddr_t, int);
struct buf *ffs_cgread(struct fs *, struct inode *, int);
daddr_t	ffs_alloccgblk(struct inode *, struct buf *, daddr_t);
daddr_t	ffs_clusteralloc(struct inode *, int, daddr_t, int);
ino_t	ffs_dirpref(struct inode *);
daddr_t	ffs_fragextend(struct inode *, int, long, int, int);
u_long	ffs_hashalloc(struct inode *, int, long, int,
    daddr_t (*)(struct inode *, int, daddr_t, int));
daddr_t	ffs_nodealloccg(struct inode *, int, daddr_t, int);
daddr_t	ffs_mapsearch(struct fs *, struct cg *, daddr_t, int);
d88 1
a88 1
int      ffs_checkblk(struct inode *, daddr_t, long);
d111 2
a112 2
ffs_alloc(struct inode *ip, daddr_t lbn, daddr_t bpref, int size,
    struct ucred *cred, daddr_t *bnp)
d115 1
a115 1
	daddr_t bno;
d151 1
a151 1
	bno = (daddr_t)ffs_hashalloc(ip, cg, (long)bpref, size, ffs_alloccg);
d178 2
a179 2
ffs_realloccg(struct inode *ip, daddr_t lbprev, daddr_t bpref, int osize,
    int nsize, struct ucred *cred, struct buf **bpp, daddr_t *blknop)
d183 1
a183 1
	daddr_t quota_updated = 0;
d185 1
a185 1
	daddr_t bprev, bno;
d232 1
a232 1
	if ((bno = ffs_fragextend(ip, cg, (long)bprev, osize, nsize)) != 0) {
d296 1
a296 2
	bno = (daddr_t)ffs_hashalloc(ip, cg, (long)bpref, request,
	    			     ffs_alloccg);
d374 1
a374 1
	daddr_t *bap, *sbap, *ebap = NULL;
d376 1
a376 1
	daddr_t start_lbn, end_lbn, soff, newblk, blkno;
d429 1
a429 1
		sbap = (daddr_t *)sbp->b_data;
d450 1
a450 1
		ebap = (daddr_t *)ebp->b_data;
d455 2
a456 2
	if ((newblk = (daddr_t)ffs_hashalloc(ip, dtog(fs, pref), (long)pref,
	    len, ffs_clusteralloc)) == 0)
d857 1
a857 1
	ino = (ino_t)ffs_hashalloc(pip, cg, (long)ipref, mode, ffs_nodealloccg);
d1032 1
a1032 1
ffs1_blkpref(struct inode *ip, daddr_t lbn, int indx, int32_t *bap)
d1075 1
a1075 1
ffs2_blkpref(struct inode *ip, daddr_t lbn, int indx, int64_t *bap)
d1128 3
a1130 3
u_long
ffs_hashalloc(struct inode *ip, int cg, long pref, int size,
    daddr_t (*allocator)(struct inode *, int, daddr_t, int))
d1133 1
a1133 1
	long result;
d1196 2
a1197 2
daddr_t
ffs_fragextend(struct inode *ip, int cg, long bprev, int osize, int nsize)
d1202 1
a1202 1
	long bno;
d1259 2
a1260 2
daddr_t
ffs_alloccg(struct inode *ip, int cg, daddr_t bpref, int size)
d1265 1
a1265 1
	daddr_t bno, blkno;
d1340 1
a1340 1
	return ((u_long)blkno);
d1348 2
a1349 2
daddr_t
ffs_alloccgblk(struct inode *ip, struct buf *bp, daddr_t bpref)
d1353 1
a1353 1
	daddr_t bno, blkno;
d1384 1
a1384 1
	ffs_clrblock(fs, blksfree, (long) blkno);
d1412 2
a1413 2
daddr_t
ffs_clusteralloc(struct inode *ip, int cg, daddr_t bpref, int len)
d1518 2
a1519 2
daddr_t
ffs_nodealloccg(struct inode *ip, int cg, daddr_t ipref, int mode)
d1687 1
a1687 1
	daddr_t blkno;
d1846 1
a1846 1
ffs_checkblk(struct inode *ip, daddr_t bno, long size)
d1889 2
a1890 2
daddr_t
ffs_mapsearch(struct fs *fs, struct cg *cgp, daddr_t bpref, int allocsiz)
d1892 1
a1892 1
	daddr_t bno;
d1950 1
a1950 1
ffs_clusteracct(struct fs *fs, struct cg *cgp, daddr_t blkno, int cnt)
@


1.79
log
@When selecting cylinder groups as candidates for new directory creation
make sure that theres a minimum amount of free blocks in that cylinder
group by tweaking the minbfree calculation. Without this, cylinder groups
with no free blocks could be chosen which resaults in expensive searches
for free blocks each time a new file is created in the directory.

Tweak the calculation of minifree (minimum free inodes) in the same
way. Also decrease the maxcontigdirs as the file system fills up to
lessen the chance of directory clusters overflowing the available
space in the cylinder group.

From FreeBSD (Rev 1.116 of sys/ufs/ffs/ffs_alloc.c);

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.78 2007/06/22 13:59:12 thib Exp $	*/
d72 1
d1172 19
d1204 1
a1204 2
	int frags, bbase;
	int i, error;
d1215 2
a1216 4
	error = bread(ip->i_devvp, fsbtodb(fs, cgtod(fs, cg)),
		(int)fs->fs_cgsize, NOCRED, &bp);
	if (error) {
		brelse(bp);
d1218 1
a1218 1
	}
a1219 5
	if (!cg_chkmagic(cgp)) {
		brelse(bp);
		return (0);
	}

d1267 1
a1267 1
	int error, i, frags, allocsiz;
d1272 2
a1273 5
	/* read cylinder group block */
	error = bread(ip->i_devvp, fsbtodb(fs, cgtod(fs, cg)),
		(int)fs->fs_cgsize, NOCRED, &bp);
	if (error) {
		brelse(bp);
d1275 1
a1275 1
	}
d1277 1
a1277 2
	if (!cg_chkmagic(cgp) ||
	    (cgp->cg_cs.cs_nbfree == 0 && size == fs->fs_bsize)) {
d1426 4
a1429 3
	if (bread(ip->i_devvp, fsbtodb(fs, cgtod(fs, cg)), (int)fs->fs_cgsize,
	    NOCRED, &bp))
		goto fail;
d1431 1
a1431 2
	if (!cg_chkmagic(cgp))
		goto fail;
d1525 1
a1525 1
	int error, start, len, loc, map, i;
d1540 1
a1540 4
	error = bread(ip->i_devvp, fsbtodb(fs, cgtod(fs, cg)),
		(int)fs->fs_cgsize, NOCRED, &bp);
	if (error) {
		brelse(bp);
a1541 1
	}
d1544 1
a1544 1
	if (!cg_chkmagic(cgp) || cgp->cg_cs.cs_nifree == 0) {
d1689 1
a1689 1
	int i, error, cg, blk, frags, bbase;
d1704 1
a1704 4
	error = bread(ip->i_devvp, fsbtodb(fs, cgtod(fs, cg)),
		(int)fs->fs_cgsize, NOCRED, &bp);
	if (error) {
		brelse(bp);
d1706 1
a1706 1
	}
a1707 5
	if (!cg_chkmagic(cgp)) {
		brelse(bp);
		return;
	}

d1804 1
a1804 1
	int error, cg;
d1810 1
d1812 1
a1812 9
	error = bread(pip->i_devvp, fsbtodb(fs, cgtod(fs, cg)),
		(int)fs->fs_cgsize, NOCRED, &bp);
	if (error) {
		brelse(bp);
		return (error);
	}
	cgp = (struct cg *)bp->b_data;
	if (!cg_chkmagic(cgp)) {
		brelse(bp);
a1813 1
	}
d1815 1
d1852 1
a1852 1
	int i, error, frags, free;
d1862 2
a1863 4
	error = bread(ip->i_devvp, fsbtodb(fs, cgtod(fs, dtog(fs, bno))),
		(int)fs->fs_cgsize, NOCRED, &bp);
	if (error) {
		brelse(bp);
a1864 1
	}
a1866 5
	if (!cg_chkmagic(cgp)) {
		brelse(bp);
		return (0);
	}

@


1.78
log
@Update ffs[1/2] time last written for cg's in
clusteralloc();

From mickey; ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.77 2007/06/01 23:47:57 deraadt Exp $	*/
a928 1
#if 1
a954 3
#else
	prefcg = ino_to_cg(fs, pip->i_number);
#endif
a959 1
#if 1
d961 7
a967 11
	minifree = avgifree - fs->fs_ipg / 4;
	if (minifree < 0)
		minifree = 0;
	minbfree = avgbfree - fs->fs_fpg / fs->fs_frag / 4;
	if (minbfree < 0)
		minbfree = 0;
#else
	maxndir = avgndir + (fs->fs_ipg - avgndir) / 16;
	minifree = avgifree * 3 / 4;
	minbfree = avgbfree * 3 / 4;
#endif
d973 1
a973 1
	maxcontigdirs = min(cgsize / dirsize, 255);
@


1.77
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.76 2007/06/01 20:23:25 pedro Exp $	*/
d1494 2
@


1.76
log
@Nuke 'ufs_lbn_t', okay otto@@ deraadt@@ krw@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.75 2007/06/01 18:54:27 pedro Exp $	*/
d369 1
a369 4
	struct vop_reallocblks_args /* {
		struct vnode *a_vp;
		struct cluster_save *a_buflist;
	} */ *ap = v;
d572 1
a572 4
	struct vop_reallocblks_args /* {
		struct vnode *a_vp;
		struct cluster_save *a_buflist;
	} */ *ap = v;
@


1.75
log
@cleanup of 'ufs1_daddr_t', first round, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.74 2007/06/01 06:38:54 deraadt Exp $	*/
d586 1
a586 1
	ufs_lbn_t start_lbn, end_lbn;
@


1.74
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.73 2007/05/26 20:26:51 pedro Exp $	*/
d1046 2
a1047 2
ufs1_daddr_t
ffs1_blkpref(struct inode *ip, daddr_t lbn, int indx, ufs1_daddr_t *bap)
d1089 2
a1090 2
daddr64_t
ffs2_blkpref(struct inode *ip, daddr_t lbn, int indx, daddr64_t *bap)
d1692 1
a1692 1
ffs_blkfree(struct inode *ip, daddr_t bno, long size)
@


1.73
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.72 2007/04/29 17:58:09 deraadt Exp $	*/
d583 1
a583 1
	ufs2_daddr_t *bap, *sbap, *ebap = 0;
d587 1
a587 1
	ufs2_daddr_t soff, newblk, blkno, pref;
d646 1
a646 1
		sbap = (ufs2_daddr_t *)sbp->b_data;
d663 1
a663 1
		ebap = (ufs2_daddr_t *)ebp->b_data;
d1089 2
a1090 2
ufs2_daddr_t
ffs2_blkpref(struct inode *ip, daddr_t lbn, int indx, ufs2_daddr_t *bap)
@


1.72
log
@enforce -Wdeclaration-after-statement by hand
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.71 2007/03/23 13:21:39 pedro Exp $	*/
d214 6
a219 3
	if (bpp != NULL &&
	    (error = bread(ITOV(ip), lbprev, osize, NOCRED, &bp)) != 0)
		goto error;
d237 5
a241 1
			allocbuf(bp, nsize);
d243 1
a243 1
			bzero((char *)bp->b_data + osize, (u_int)nsize - osize);
d310 5
a314 1
		allocbuf(bp, nsize);
d316 1
a316 1
		bzero((char *)bp->b_data + osize, (u_int)nsize - osize);
@


1.71
log
@Make FFS allocation functions non-static, okay miod@@ mk@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.70 2007/01/26 11:08:39 pedro Exp $	*/
d788 4
a795 2
	struct vop_reallocblks_args *ap = v;

@


1.70
log
@remove ancient device-specific trick from ffs1_blkpref()
okay toby@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.69 2007/01/07 15:39:22 sturm Exp $	*/
d71 9
a79 9
static daddr_t	ffs_alloccg(struct inode *, int, daddr_t, int);
static daddr_t	ffs_alloccgblk(struct inode *, struct buf *, daddr_t);
static daddr_t	ffs_clusteralloc(struct inode *, int, daddr_t, int);
static ino_t	ffs_dirpref(struct inode *);
static daddr_t	ffs_fragextend(struct inode *, int, long, int, int);
static u_long	ffs_hashalloc(struct inode *, int, long, int,
		    daddr_t (*)(struct inode *, int, daddr_t, int));
static daddr_t	ffs_nodealloccg(struct inode *, int, daddr_t, int);
static daddr_t	ffs_mapsearch(struct fs *, struct cg *, daddr_t, int);
d87 1
a87 1
static int      ffs_checkblk(struct inode *, daddr_t, long);
d907 1
a907 1
static ino_t
d1130 1
a1130 1
static u_long
d1179 1
a1179 1
static daddr_t
d1250 1
a1250 1
static daddr_t
d1343 1
a1343 1
static daddr_t
d1407 1
a1407 1
static daddr_t
d1511 1
a1511 1
static daddr_t
d1857 1
a1857 1
static int
d1909 1
a1909 1
static daddr_t
@


1.69
log
@add some comments

ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.68 2007/01/06 23:30:42 tedu Exp $	*/
a1031 7
 *
 * If a section is already partially allocated, the policy is to
 * contiguously allocate fs_maxcontig blocks.  The end of one of these
 * contiguous blocks and the beginning of the next is physically separated
 * so that the disk head will be in transit between them for at least
 * fs_rotdelay milliseconds.  This is to allow time for the processor to
 * schedule another I/O transfer.
d1037 1
a1037 3
	int cg;
	int avgbfree, startcg;
	ufs1_daddr_t nextblk;
d1068 2
a1069 20
	/*
	 * One or more previous blocks have been laid out. If less
	 * than fs_maxcontig previous blocks are contiguous, the
	 * next block is requested contiguously, otherwise it is
	 * requested rotationally delayed by fs_rotdelay milliseconds.
	 */
	nextblk = bap[indx - 1] + fs->fs_frag;
	if (indx < fs->fs_maxcontig || bap[indx - fs->fs_maxcontig] +
	    blkstofrags(fs, fs->fs_maxcontig) != nextblk)
		return (nextblk);
	if (fs->fs_rotdelay != 0)
		/*
		 * Here we convert ms of delay to frags as:
		 * (frags) = (ms) * (rev/sec) * (sect/rev) /
		 *	((sect/frag) * (ms/sec))
		 * then round up to the next block.
		 */
		nextblk += roundup(fs->fs_rotdelay * fs->fs_rps * fs->fs_nsect /
		    (NSPF(fs) * 1000), fs->fs_frag);
	return (nextblk);
@


1.68
log
@stop printing messages when changing space/time optimizations.
it's not all that important, and mostly seems to just scare people.
ok pedro henning thib ...
also remove dumb casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.67 2006/12/28 20:33:24 thib Exp $	*/
d137 5
d148 2
d152 1
d159 1
a159 3
	/*
	 * Restore user's disk quota because allocation failed.
	 */
d1289 1
d1306 1
@


1.67
log
@Zap nextgennumber, unused since LFS went up into the attic.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.66 2006/04/02 22:16:29 pedro Exp $	*/
d243 1
a243 1
	switch ((int)fs->fs_optim) {
a256 2
		log(LOG_NOTICE, "%s: optimization changed from SPACE to TIME\n",
			fs->fs_fsmnt);
a273 2
		log(LOG_NOTICE, "%s: optimization changed from TIME to SPACE\n",
			fs->fs_fsmnt);
@


1.66
log
@Two changes in the FFS2 lazy inode allocation code:
- Insert some comments and space the code to improve readability
- Make sure the inode's gen number is always positive (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.65 2006/04/02 17:16:12 pedro Exp $	*/
a69 2

extern u_long nextgennumber;
@


1.65
log
@Cope with FFS2's lazy inode allocation policy, adapted from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.64 2006/04/02 17:08:14 pedro Exp $	*/
d52 1
d1637 6
a1642 1
	/* Check to see if we need to initialize more inodes */
d1644 1
d1646 1
d1648 1
d1652 1
d1655 2
d1658 1
a1658 1
                        dp2->di_gen = arc4random() / 2 + 1;
d1661 2
@


1.64
log
@Set cg_ffs2_time whenever cg_time is set
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.63 2006/04/01 12:13:51 pedro Exp $	*/
d1542 4
d1634 19
d1672 5
@


1.63
log
@Don't do cylinder group block accounting for FFS2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.62 2006/03/11 22:52:56 pedro Exp $	*/
d1235 3
a1237 1
	cgp->cg_time = time_second;
d1300 3
a1302 1
	cgp->cg_time = time_second;
d1569 1
a1569 1
	cgp->cg_time = time_second;
d1694 3
a1696 1
	cgp->cg_time = time_second;
d1809 3
a1811 1
	cgp->cg_time = time_second;
@


1.62
log
@No need to check for !doreallocblks in ffs1_reallocblks() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.61 2006/03/11 21:00:48 pedro Exp $	*/
d1405 1
a1405 2
	if ((fs->fs_magic == FS_UFS1_MAGIC) /* && */
	/*  ((fs->fs_flags & FS_FLAGS_UPDATED) == 0)*/) {
d1704 7
a1710 3
		i = cbtocylno(fs, bno);
		cg_blks(fs, cgp, i)[cbtorpos(fs, bno)]++;
		cg_blktot(cgp)[i]++;
d1750 6
a1755 3
			i = cbtocylno(fs, bbase);
			cg_blks(fs, cgp, i)[cbtorpos(fs, bbase)]++;
			cg_blktot(cgp)[i]++;
@


1.61
log
@Add UFS2 block allocation functions, okay tedu@@.
Thanks to all those who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.60 2006/03/05 10:35:51 pedro Exp $	*/
a369 3

	if (doreallocblks == 0)
		return (ENOSPC);
@


1.60
log
@Simplify ffs_alloccgblk() a lot by not caring about allocating
rotationally optimal blocks. There's no point in doing that anymore.
Okay beck@@, marco@@, tedu@@ and krw@@. Various testing for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.59 2005/12/28 20:48:17 pedro Exp $	*/
d5 9
d82 5
d355 1
a355 1
ffs_reallocblks(void *v)
d388 1
a388 1
			panic("ffs_reallocblks: unallocated block 1");
d392 1
a392 1
			panic("ffs_reallocblks: non-logical cluster");
d398 1
a398 1
			panic("ffs_reallocblks: non-physical cluster %d", i);
d429 1
a429 1
	pref = ffs_blkpref(ip, start_lbn, soff, sbap);
d439 1
a439 1
			panic("ffs_reallocblk: start == end");
d473 1
a473 1
			panic("ffs_reallocblks: unallocated block 2");
d475 1
a475 1
			panic("ffs_reallocblks: alloc mismatch");
d541 1
a541 1
			panic("ffs_reallocblks: unallocated block 3");
d562 241
d1042 2
a1043 2
daddr_t
ffs_blkpref(struct inode *ip, daddr_t lbn, int indx, daddr_t *bap)
d1048 1
a1048 1
	daddr_t nextblk;
d1100 49
@


1.59
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.58 2005/11/06 13:22:39 pedro Exp $	*/
a1058 6
 *
 * This algorithm implements the following policy:
 *   1) allocate the requested block.
 *   2) allocate a rotationally optimal block in the same cylinder.
 *   3) allocate the next available block on the block rotor for the
 *      specified cylinder group.
d1068 2
a1069 3
	int cylno, pos, delta;
	short *cylbp;
	int i;
d1072 4
a1075 2
	cgp = (struct cg *)bp->b_data;
	if (bpref == 0 || dtog(fs, bpref) != cgp->cg_cgx) {
d1077 3
a1079 12
		goto norot;
	}
	bpref = blknum(fs, bpref);
	bpref = dtogd(fs, bpref);
	/*
	 * if the requested block is available, use it
	 */
	if (ffs_isblock(fs, cg_blksfree(cgp), fragstoblks(fs, bpref))) {
		bno = bpref;
		goto gotit;
	}
	if (fs->fs_cpc == 0 || fs->fs_nrpos <= 1) {
d1081 1
a1081 6
		 * Block layout information is not available.
		 * Leaving bpref unchanged means we take the
		 * next available free block following the one
		 * we just allocated. Hopefully this will at
		 * least hit a track cache on drives of unknown
		 * geometry (e.g. SCSI).
d1083 2
a1084 1
		goto norot;
d1086 1
d1088 1
a1088 49
	 * check for a block available on the same cylinder
	 */
	cylno = cbtocylno(fs, bpref);
	if (cg_blktot(cgp)[cylno] == 0)
		goto norot;
	/*
	 * check the summary information to see if a block is
	 * available in the requested cylinder starting at the
	 * requested rotational position and proceeding around.
	 */
	cylbp = cg_blks(fs, cgp, cylno);
	pos = cbtorpos(fs, bpref);
	for (i = pos; i < fs->fs_nrpos; i++)
		if (cylbp[i] > 0)
			break;
	if (i == fs->fs_nrpos)
		for (i = 0; i < pos; i++)
			if (cylbp[i] > 0)
				break;
	if (cylbp[i] > 0) {
		/*
		 * found a rotational position, now find the actual
		 * block. A panic if none is actually there.
		 */
		pos = cylno % fs->fs_cpc;
		bno = (cylno - pos) * fs->fs_spc / NSPB(fs);
		if (fs_postbl(fs, pos)[i] == -1) {
			printf("pos = %d, i = %d, fs = %s\n",
			    pos, i, fs->fs_fsmnt);
			panic("ffs_alloccgblk: cyl groups corrupted");
		}
		for (i = fs_postbl(fs, pos)[i];; ) {
			if (ffs_isblock(fs, cg_blksfree(cgp), bno + i)) {
				bno = blkstofrags(fs, (bno + i));
				goto gotit;
			}
			delta = fs_rotbl(fs)[i];
			if (delta <= 0 ||
			    delta + i > fragstoblks(fs, fs->fs_fpg))
				break;
			i += delta;
		}
		printf("pos = %d, i = %d, fs = %s\n", pos, i, fs->fs_fsmnt);
		panic("ffs_alloccgblk: can't find blk in cyl");
	}
norot:
	/*
	 * no blocks in the requested cylinder, so take next
	 * available one in this cylinder group.
d1090 1
a1090 1
	bno = ffs_mapsearch(fs, cgp, bpref, (int)fs->fs_frag);
d1093 1
d1095 1
d1098 1
a1098 1
	ffs_clrblock(fs, cg_blksfree(cgp), (long)blkno);
d1103 8
a1110 3
	cylno = cbtocylno(fs, bno);
	cg_blks(fs, cgp, cylno)[cbtorpos(fs, bno)]--;
	cg_blktot(cgp)[cylno]--;
d1113 1
d1116 1
@


1.58
log
@Use ANSI-style function declarations and deregister, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.57 2005/10/25 21:55:49 pedro Exp $	*/
d132 1
a132 1
		ip->i_ffs_blocks += btodb(size);
d183 4
a186 1
	if ((bprev = ip->i_ffs_db[lbprev]) == 0) {
d191 1
d210 1
a210 1
		ip->i_ffs_blocks += btodb(nsize - osize);
d284 1
a284 1
	ip->i_ffs_blocks += btodb(nsize - osize);
d401 1
a401 1
		sbap = &ip->i_ffs_db[0];
d468 1
a468 1
			if (sbap == &ip->i_ffs_db[0] && i < ssize)
d494 1
a494 1
	if (sbap != &ip->i_ffs_db[0]) {
d543 1
a543 1
	if (sbap != &ip->i_ffs_db[0])
d605 1
d607 2
a608 1
	if (ip->i_ffs_mode) {
d610 1
a610 1
		    ip->i_ffs_mode, ip->i_number, fs->fs_fsmnt);
d613 2
a614 1
	if (ip->i_ffs_blocks) {				/* XXX */
d616 2
a617 2
		    fs->fs_fsmnt, ino, ip->i_ffs_blocks);
		ip->i_ffs_blocks = 0;
d619 3
a621 1
	ip->i_ffs_flags = 0;
d627 6
a632 4
	if (ip->i_ffs_gen == 0 || ++(ip->i_ffs_gen) == 0)
		ip->i_ffs_gen = arc4random() & INT_MAX;
	if (ip->i_ffs_gen == 0 || ip->i_ffs_gen == -1)
		ip->i_ffs_gen = 1;			/* shouldn't happen */
d634 1
d1432 1
a1432 1
		ffs_fserr(fs, ip->i_ffs_uid, "bad block");
@


1.57
log
@Make ffs_fserr() a macro, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.56 2005/09/06 16:42:21 pedro Exp $	*/
d97 2
a98 6
ffs_alloc(ip, lbn, bpref, size, cred, bnp)
	register struct inode *ip;
	daddr_t lbn, bpref;
	int size;
	struct ucred *cred;
	daddr_t *bnp;
d100 1
a100 1
	register struct fs *fs;
d158 2
a159 8
ffs_realloccg(ip, lbprev, bpref, osize, nsize, cred, bpp, blknop)
	register struct inode *ip;
	daddr_t lbprev;
	daddr_t bpref;
	int osize, nsize;
	struct ucred *cred;
	struct buf **bpp;
	daddr_t *blknop;
d161 1
a161 1
	register struct fs *fs;
d337 1
a337 2
ffs_reallocblks(v)
	void *v;
d643 1
a643 2
ffs_dirpref(pip)
	struct inode *pip;
d645 1
a645 1
	register struct fs *fs;
d776 1
a776 5
ffs_blkpref(ip, lbn, indx, bap)
	struct inode *ip;
	daddr_t lbn;
	int indx;
	daddr_t *bap;
d778 2
a779 2
	register struct fs *fs;
	register int cg;
d844 2
a845 6
ffs_hashalloc(ip, cg, pref, size, allocator)
	struct inode *ip;
	int cg;
	long pref;
	int size;	/* size for data blocks, mode for inodes */
	daddr_t (*allocator)(struct inode *, int, daddr_t, int);
d847 1
a847 1
	register struct fs *fs;
d893 1
a893 5
ffs_fragextend(ip, cg, bprev, osize, nsize)
	struct inode *ip;
	int cg;
	long bprev;
	int osize, nsize;
d895 2
a896 2
	register struct fs *fs;
	register struct cg *cgp;
d962 1
a962 5
ffs_alloccg(ip, cg, bpref, size)
	struct inode *ip;
	int cg;
	daddr_t bpref;
	int size;
d964 2
a965 2
	register struct fs *fs;
	register struct cg *cgp;
d1057 1
a1057 4
ffs_alloccgblk(ip, bp, bpref)
	struct inode *ip;
	struct buf *bp;
	daddr_t bpref;
d1064 1
a1064 1
	register int i;
d1172 1
a1172 5
ffs_clusteralloc(ip, cg, bpref, len)
	struct inode *ip;
	int cg;
	daddr_t bpref;
	int len;
d1174 2
a1175 2
	register struct fs *fs;
	register struct cg *cgp;
d1276 1
a1276 5
ffs_nodealloccg(ip, cg, ipref, mode)
	struct inode *ip;
	int cg;
	daddr_t ipref;
	int mode;
d1278 2
a1279 2
	register struct fs *fs;
	register struct cg *cgp;
d1402 1
a1402 4
ffs_blkfree(ip, bno, size)
	register struct inode *ip;
	daddr_t bno;
	long size;
d1404 2
a1405 2
	register struct fs *fs;
	register struct cg *cgp;
d1570 1
a1570 4
ffs_checkblk(ip, bno, size)
	struct inode *ip;
	daddr_t bno;
	long size;
d1622 1
a1622 5
ffs_mapsearch(fs, cgp, bpref, allocsiz)
	register struct fs *fs;
	register struct cg *cgp;
	daddr_t bpref;
	int allocsiz;
d1682 1
a1682 5
ffs_clusteracct(fs, cgp, blkno, cnt)
	struct fs *fs;
	struct cg *cgp;
	daddr_t blkno;
	int cnt;
@


1.56
log
@Describe the steps involved in allocating a new inode and space the code
a bit, to improve readability. Okay krw@@ and art@@, input from deraadt@@
and jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.55 2005/07/03 20:14:01 drahn Exp $	*/
d56 5
a67 1
static void	ffs_fserr(struct fs *, u_int, char *);
a1814 16
}

/*
 * Fserr prints the name of a file system with an error diagnostic.
 *
 * The form of the error message is:
 *	fs: error message
 */
static void
ffs_fserr(fs, uid, cp)
	struct fs *fs;
	u_int uid;
	char *cp;
{

	log(LOG_ERR, "uid %u on %s: %s\n", uid, fs->fs_fsmnt, cp);
@


1.55
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.54 2005/05/02 13:13:21 pedro Exp $	*/
d1305 1
a1305 9
/*
 * Determine whether an inode can be allocated.
 *
 * Check to see if an inode is available, and if it is,
 * allocate it using the following policy:
 *   1) allocate the requested inode.
 *   2) allocate the next available inode after the requested
 *      inode in the specified cylinder group.
 */
d1318 5
d1326 1
d1333 1
d1339 5
d1345 4
d1352 1
a1352 1
			goto gotit;
d1354 5
d1363 5
d1372 4
d1382 2
d1385 6
d1399 1
d1403 1
d1409 2
d1414 3
a1416 1
	fs->fs_fmod = 1;
d1422 1
d1424 2
@


1.54
log
@quadradically -> quadratically, lots of
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.53 2004/11/29 06:20:02 jsg Exp $	*/
a47 1
#include <ufs/ufs/extattr.h>
@


1.53
log
@Spell precede correctly.
'looks fine' millert@@, krw@@. ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.52 2004/11/01 15:55:38 pedro Exp $	*/
d84 1
a84 1
 *   4) quadradically rehash into other cylinder groups, until an
d90 1
a90 1
 *   2) quadradically rehash into other cylinder groups, until an
d559 1
a559 1
 *   3) quadradically rehash into other cylinder groups, until an
d564 1
a564 1
 *   2) quadradically rehash into other cylinder groups, until an
d852 1
a852 1
 *   2) quadradically rehash on the cylinder group number.
@


1.52
log
@english
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.51 2004/10/25 23:36:50 pedro Exp $	*/
d331 1
a331 1
 * block immediately preceeding the current range. If successful, the
@


1.51
log
@don't assume a block is allocated if bread() or cg_chkmagic() fails.
ok marius@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.50 2004/09/18 22:01:18 tedu Exp $	*/
d328 1
a328 1
 * logical blocks to be made contiguous is given. The allocator attempts
@


1.50
log
@hierarchy is spelled hierarchy, from Jonathan Gray
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.49 2004/07/13 21:04:29 millert Exp $	*/
a1590 1
		/* XXX - probably should panic here */
d1592 1
a1592 1
		return (-1);
d1594 1
a1596 1
		/* XXX - probably should panic here */
d1598 1
a1598 1
		return (-1);
d1600 1
@


1.49
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.48 2004/07/02 13:03:36 mickey Exp $	*/
d86 1
a86 1
 * If no block preference is given the following heirarchy is used
d561 1
a561 1
 * If no inode preference is given the following heirarchy is used
@


1.48
log
@printf inode numer as unsigned -- just the way it is
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.47 2004/06/21 23:50:38 tholo Exp $	*/
d131 1
a131 2
	bno = (daddr_t)ffs_hashalloc(ip, cg, (long)bpref, size,
	    			     ffs_alloccg);
d568 1
a568 1
ffs_inode_alloc(struct inode *pip, int mode, struct ucred *cred,
d1500 1
a1500 1
ffs_inode_free(struct inode *pip, ino_t ino, int mode)
d1517 1
a1517 1
ffs_freefile(struct inode *pip, ino_t ino, int mode)
@


1.47
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.46 2004/01/20 03:44:06 tedu Exp $	*/
d1420 1
a1420 1
		printf("bad block %d, ino %d\n", bno, ip->i_number);
d1544 1
a1544 1
		printf("dev = 0x%x, ino = %d, fs = %s\n",
@


1.46
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.45 2003/10/17 15:08:11 mpech Exp $	*/
d944 1
a944 1
	cgp->cg_time = time.tv_sec;
d1011 1
a1011 1
	cgp->cg_time = time.tv_sec;
d1342 1
a1342 1
	cgp->cg_time = time.tv_sec;
d1435 1
a1435 1
	cgp->cg_time = time.tv_sec;
d1541 1
a1541 1
	cgp->cg_time = time.tv_sec;
@


1.45
log
@Be sure i_ffs_gen is always positive.

millert@@, beck@@, tedu@@, deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.44 2003/06/02 23:28:22 millert Exp $	*/
d51 1
@


1.44
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.43 2003/05/26 18:33:16 tedu Exp $	*/
d627 1
a627 1
		ip->i_ffs_gen = arc4random();
d672 1
a672 1
		prefcg = arc4random() % fs->fs_ncg;
@


1.43
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.42 2002/06/23 03:07:22 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.42
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.41 2002/03/14 03:16:13 millert Exp $	*/
d170 1
a170 1
	ufs_daddr_t *blknop;
d174 1
a174 1
	ufs_daddr_t quota_updated = 0;
@


1.41
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.40 2002/03/14 01:27:14 millert Exp $	*/
d1792 1
a1792 1
	log(LOG_ERR, "uid %d on %s: %s\n", uid, fs->fs_fsmnt, cp);
@


1.40
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.39 2002/02/22 20:37:46 drahn Exp $	*/
d68 2
a69 3
static u_long	ffs_hashalloc __P((struct inode *, int, long, int,
				   daddr_t (*)(struct inode *, int, daddr_t,
					       int)));
@


1.39
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.38 2001/12/19 08:58:07 art Exp $	*/
d62 6
a67 6
static daddr_t	ffs_alloccg __P((struct inode *, int, daddr_t, int));
static daddr_t	ffs_alloccgblk __P((struct inode *, struct buf *, daddr_t));
static daddr_t	ffs_clusteralloc __P((struct inode *, int, daddr_t, int));
static ino_t	ffs_dirpref __P((struct inode *));
static daddr_t	ffs_fragextend __P((struct inode *, int, long, int, int));
static void	ffs_fserr __P((struct fs *, u_int, char *));
d71 2
a72 2
static daddr_t	ffs_nodealloccg __P((struct inode *, int, daddr_t, int));
static daddr_t	ffs_mapsearch __P((struct fs *, struct cg *, daddr_t, int));
d75 1
a75 1
static int      ffs_checkblk __P((struct inode *, daddr_t, long));
d867 1
a867 1
	daddr_t (*allocator) __P((struct inode *, int, daddr_t, int));
@


1.38
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.35 2001/11/21 21:23:56 csapuntz Exp $	*/
d52 1
@


1.37
log
@Don't brelse a random pointer in ffs_realloccg when filesystem is full
and bpp == NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.36 2001/11/27 05:27:12 art Exp $	*/
d172 1
a172 1
	struct fs *fs;
a179 1

d285 1
d365 1
a365 2
	/* XXXUBC - don't reallocblks for now */
	if (1 || doreallocblks == 0)
@


1.37.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.37 2001/11/30 16:37:57 art Exp $	*/
a51 1
#include <ufs/ufs/extattr.h>
d61 11
a71 10
static daddr_t	ffs_alloccg(struct inode *, int, daddr_t, int);
static daddr_t	ffs_alloccgblk(struct inode *, struct buf *, daddr_t);
static daddr_t	ffs_clusteralloc(struct inode *, int, daddr_t, int);
static ino_t	ffs_dirpref(struct inode *);
static daddr_t	ffs_fragextend(struct inode *, int, long, int, int);
static void	ffs_fserr(struct fs *, u_int, char *);
static u_long	ffs_hashalloc(struct inode *, int, long, int,
		    daddr_t (*)(struct inode *, int, daddr_t, int));
static daddr_t	ffs_nodealloccg(struct inode *, int, daddr_t, int);
static daddr_t	ffs_mapsearch(struct fs *, struct cg *, daddr_t, int);
d74 1
a74 1
static int      ffs_checkblk(struct inode *, daddr_t, long);
d867 1
a867 1
	daddr_t (*allocator)(struct inode *, int, daddr_t, int);
@


1.37.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.37.2.1 2002/06/11 03:32:50 art Exp $	*/
d1793 1
a1793 1
	log(LOG_ERR, "uid %u on %s: %s\n", uid, fs->fs_fsmnt, cp);
@


1.37.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.37.2.2 2002/10/29 00:36:50 art Exp $	*/
d510 3
a512 2
		if (!doasyncfree)
			UFS_UPDATE(ip, UPDATE_WAIT);
d711 1
a711 1
	minbfree = avgbfree - fragstoblks(fs, fs->fs_fpg) / 4;
d1651 1
a1651 1
		(u_char)(1 << (allocsiz - 1 + (fs->fs_frag & (NBBY - 1)))));
d1657 1
a1657 1
			(u_char)(1 << (allocsiz - 1 + (fs->fs_frag & (NBBY - 1)))));
@


1.36
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.35 2001/11/21 21:23:56 csapuntz Exp $	*/
d173 1
a173 1
	struct buf *bp;
@


1.35
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.34 2001/11/15 06:08:31 art Exp $	*/
d172 2
a173 2
	register struct fs *fs;
	struct buf *bp = NULL;
d180 1
a285 1
	(void) uvm_vnp_uncache(ITOV(ip));
d365 2
a366 1
	if (doreallocblks == 0)
@


1.34
log
@Missed one place to check for bpp == NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.33 2001/11/13 00:10:56 art Exp $	*/
a106 1
#ifdef QUOTA
a107 1
#endif
d124 2
a125 2
#ifdef QUOTA
	if ((error = chkdq(ip, (long)btodb(size), cred, 0)) != 0)
d127 1
a127 1
#endif
d142 1
a142 1
#ifdef QUOTA
d146 2
a147 2
	(void) chkdq(ip, (long)-btodb(size), cred, FORCE);
#endif
d173 2
a174 1
	struct buf *bp;
d203 9
a211 12
	    (error = bread(ITOV(ip), lbprev, osize, NOCRED, &bp)) != 0) {
		brelse(bp);
		return (error);
	}
#ifdef QUOTA
	if ((error = chkdq(ip, (long)btodb(nsize - osize), cred, 0)) != 0) {
		if (bpp != NULL) {
			brelse(bp);
		}
		return (error);
	}
#endif
d282 17
a298 20
	if (bno > 0) {
		(void) uvm_vnp_uncache(ITOV(ip));
		if (!DOINGSOFTDEP(ITOV(ip)))
			ffs_blkfree(ip, bprev, (long)osize);
		if (nsize < request)
			ffs_blkfree(ip, bno + numfrags(fs, nsize),
			    (long)(request - nsize));
		ip->i_ffs_blocks += btodb(nsize - osize);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		if (bpp != NULL) {
			bp->b_blkno = fsbtodb(fs, bno);
			allocbuf(bp, nsize);
			bp->b_flags |= B_DONE;
			bzero((char *)bp->b_data + osize, (u_int)nsize - osize);
			*bpp = bp;
		}
		if (blknop != NULL) {
			*blknop = bno;
		}
		return (0);
d300 2
a301 8
#ifdef QUOTA
	/*
	 * Restore user's disk quota because allocation failed.
	 */
	(void) chkdq(ip, (long)-btodb(nsize - osize), cred, FORCE);
#endif
	if (bpp != NULL) {
		brelse(bp);
d303 2
d311 15
a325 1
	return (ENOSPC);
@


1.33
log
@Allow the bpp arguemnt on ffs_realloccg to be NULL, don't return the
buffer in that case. Also add a new argument - blknop, which can be used to
return the allocated blkno.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.32 2001/11/06 19:53:21 miod Exp $	*/
d179 2
a180 1
	*bpp = 0;
@


1.32
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.31 2001/10/09 23:12:19 csapuntz Exp $	*/
d165 1
a165 1
ffs_realloccg(ip, lbprev, bpref, osize, nsize, cred, bpp)
d172 1
d202 2
a203 1
	if ((error = bread(ITOV(ip), lbprev, osize, NOCRED, &bp)) != 0) {
d209 3
a211 1
		brelse(bp);
a219 2
		if (bp->b_blkno != fsbtodb(fs, bno))
			panic("ffs_realloccg: bad blockno");
d222 11
a232 4
		allocbuf(bp, nsize);
		bp->b_flags |= B_DONE;
		bzero((char *)bp->b_data + osize, (u_int)nsize - osize);
		*bpp = bp;
a285 1
		bp->b_blkno = fsbtodb(fs, bno);
d294 10
a303 4
		allocbuf(bp, nsize);
		bp->b_flags |= B_DONE;
		bzero((char *)bp->b_data + osize, (u_int)nsize - osize);
		*bpp = bp;
d312 3
a314 1
	brelse(bp);
@


1.31
log
@

Fix comparison when start_lvl == 0
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.30 2001/06/27 04:58:48 art Exp $	*/
d48 1
a48 1
#include <vm/vm.h>
@


1.30
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.29 2001/06/23 02:07:53 csapuntz Exp $	*/
d411 2
a412 1
		if (start_ap[start_lvl-1].in_lbn == idp->in_lbn)
@


1.29
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.28 2001/04/19 16:22:16 gluk Exp $	*/
a277 1
#if defined(UVM)
a278 3
#else
		(void) vnode_pager_uncache(ITOV(ip));
#endif
@


1.28
log
@Cleanup dirpref and synhronize superblock with freebsd.
From FreeBSD with little changes.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.27 2001/04/06 20:43:31 gluk Exp $	*/
a75 1
int ffs_freefile __P((struct vop_vfree_args *));
a347 1
	struct timespec ts;
d493 1
a493 2
			TIMEVAL_TO_TIMESPEC(&time, &ts);
			VOP_UPDATE(vp, &ts, &ts, 1);
d555 2
a556 2
ffs_valloc(v)
	void *v;
d558 3
a560 11
	struct vop_valloc_args /* {
		struct vnode *a_pvp;
		int a_mode;
		struct ucred *a_cred;
		struct vnode **a_vpp;
	} */ *ap = v;
	register struct vnode *pvp = ap->a_pvp;
	register struct inode *pip;
	register struct fs *fs;
	register struct inode *ip;
	mode_t mode = ap->a_mode;
d564 1
a564 2
	*ap->a_vpp = NULL;
	pip = VTOI(pvp);
d591 1
a591 1
	error = VFS_VGET(pvp->v_mount, ino, ap->a_vpp);
d593 1
a593 1
		VOP_VFREE(pvp, ino, mode);
d596 1
a596 1
	ip = VTOI(*ap->a_vpp);
d619 1
a619 1
	ffs_fserr(fs, ap->a_cred->cr_uid, "out of inodes");
a1485 3
/*
 * Free an inode.
 */
d1487 1
a1487 2
ffs_vfree(v)
	void *v;
d1489 1
a1489 5
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap = v;
d1491 2
a1492 2
	if (DOINGSOFTDEP(ap->a_pvp)) {
		softdep_freefile(ap->a_pvp, ap->a_ino, ap->a_mode);
d1496 1
a1496 1
	return (ffs_freefile(ap));
d1504 1
a1504 6
ffs_freefile(ap)
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap;
d1506 2
a1507 4
	register struct fs *fs;
	register struct cg *cgp;
	register struct inode *pip;
	ino_t ino = ap->a_ino;
a1510 1
	pip = VTOI(ap->a_pvp);
d1541 1
a1541 1
	if ((ap->a_mode & IFMT) == IFDIR) {
@


1.27
log
@Replace FFS directory preference algorithm(dirpref) by new one.
It allocates directory inode in the same cylinder group as a parent
directory in. This speedup file/directory intensive operations on
a big file systems in times.

Don't forget to recompile fsck_ffs with updated fs.h or you will get
"VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE" at
the next boot. In any case you can ignore this error safely.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.26 2001/03/27 10:27:49 art Exp $	*/
d639 7
a645 5
 * The policy implemented by this algorithm is to allocate inode
 * in the same cylinder group as a parent directory in, but also
 * reserve space for file's data and inodes. Restrict number of
 * directories which may be allocated one after another in a same
 * cg without intervening by files.
d647 1
a647 1
 * in another cg.
a714 2
	if (dirsize <= 0)
		dirsize = 16384 * 64;
a735 2
			else
				continue;
a742 2
			else
				continue;
d744 3
a746 1
	/* This work when we have deficit in space */
@


1.26
log
@clean more dangling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.25 2001/03/20 17:42:34 art Exp $	*/
d64 1
a64 1
static ino_t	ffs_dirpref __P((struct fs *));
d582 1
a582 1
		ipref = ffs_dirpref(fs);
d588 12
d637 1
a637 1
 * Find a cylinder to place a directory.
d639 7
a645 3
 * The policy implemented by this algorithm is to select from
 * among those cylinder groups with above the average number of
 * free inodes, the one with the smallest number of directories.
d648 3
a650 1
ffs_dirpref(fs)
d652 7
a658 2
{
	int cg, minndir, mincg, avgifree;
d661 86
a746 7
	minndir = fs->fs_ipg;
	mincg = 0;
	for (cg = 0; cg < fs->fs_ncg; cg++)
		if (fs->fs_cs(fs, cg).cs_ndir < minndir &&
		    fs->fs_cs(fs, cg).cs_nifree >= avgifree) {
			mincg = cg;
			minndir = fs->fs_cs(fs, cg).cs_ndir;
d748 9
a756 1
	return ((ino_t)(fs->fs_ipg * mincg));
@


1.25
log
@Even more cleanup. This file was a mess.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.24 2001/03/20 17:11:05 art Exp $	*/
d80 1
a80 1
 * 
d178 1
a178 1
	
@


1.24
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.23 2001/03/20 17:08:45 art Exp $	*/
d111 1
a111 1
	
d218 1
a218 1
			panic("bad blockno");
d235 2
a236 2
		 * Allocate an exact sized fragment. Although this makes 
		 * best use of space, we will waste time relocating it if 
d320 1
a320 1
 * block immediately preceding the current range. If successful, the
d463 2
a464 2
				   blkno, *bap, fs->fs_bsize, fs->fs_bsize,
                                   buflist->bs_children[i]);
d467 2
a468 2
                                   i < ssize ? sbp : ebp, soff + i, blkno,
                                   *bap, buflist->bs_children[i]);
d477 1
a477 1
	 * they are almost never written, but if we are concerned about 
d514 1
a514 1
			ffs_blkfree(ip, 
d516 1
a516 1
		            fs->fs_bsize);
d653 1
a653 1
 * 
d667 1
a667 1
 * 
d797 1
a797 1
 * Check to see if the necessary fragments are available, and 
d957 1
a957 1
        bdwrite(bp);
d1004 1
a1004 1
		 * next available free block following the one 
d1018 1
a1018 1
	 * check the summary information to see if a block is 
d1080 1
a1080 1
        return (blkno);
d1265 1
a1265 1
        if (DOINGSOFTDEP(ITOV(ip)))
d1286 1
a1286 1
 * free map. If a fragment is deallocated, a possible 
d1306 1
a1306 1
		panic("blkfree: bad size");
d1332 1
a1332 1
			panic("blkfree: freeing free block");
d1357 1
a1357 1
				panic("blkfree: freeing free frag");
a1402 1

d1417 5
a1421 5
      struct vop_vfree_args /* {
              struct vnode *a_pvp;
              ino_t a_ino;
              int a_mode;
      } */ *ap;
d1433 1
a1433 1
		panic("ifree: range: dev = 0x%x, ino = %d, fs = %s",
d1453 1
a1453 1
			panic("ifree: freeing free inode");
d1491 1
a1491 1
		panic("checkblk: bad size");
d1494 1
a1494 1
		panic("checkblk: bad block %d", bno);
d1517 1
a1517 1
			panic("checkblk: partially free fragment");
d1684 1
a1684 1
 * 
a1696 1

@


1.23
log
@Even more.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.22 2001/03/20 17:05:38 art Exp $	*/
d1077 3
a1079 3
        blkno = cgp->cg_cgx * fs->fs_fpg + bno;
        if (DOINGSOFTDEP(ITOV(ip)))
                softdep_setup_blkmapdep(bp, fs, blkno);
@


1.22
log
@14 more NULL used as integer values.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.21 2001/03/20 16:58:43 art Exp $	*/
d923 1
a923 1
			return (NULL);
a938 5
#if 0
	/*
	 * XXX ffs_mapsearch will panic instead of return -1, and we can't
	 * XXX return NULL as a daddr_t anyway.
	 */
a940 1
		/* XXX - NULL as a daddr_t ??? */
d943 1
a943 1
#endif
a1062 5
#if 0
	/*
	 * XXX ffs_mapsearch will panic instead of return -1, and we can't
	 * XXX return NULL as a daddr_t anyway.
	 */
a1064 1
#endif
@


1.21
log
@NULL is not an u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.20 2001/03/20 16:56:12 art Exp $	*/
d816 1
a816 1
		return (NULL);
d821 1
a821 1
		return (NULL);
d827 1
a827 1
		return (NULL);
d832 1
a832 1
		return (NULL);
d839 1
a839 1
			return (NULL);
d888 1
a888 1
		return (NULL);
d893 1
a893 1
		return (NULL);
d899 1
a899 1
		return (NULL);
d947 1
a947 1
		return (NULL);
d1075 1
a1075 1
		return (NULL);	/* XXX - NULL as a daddr_t ?? */
d1118 1
a1118 1
		return (NULL);
d1232 1
a1232 1
		return (NULL);
d1237 1
a1237 1
		return (NULL);
d1242 1
a1242 1
		return (NULL);
@


1.20
log
@NULL is not a daddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.19 2001/02/21 23:24:30 csapuntz Exp $	*/
d791 1
a791 1
	return (NULL);
@


1.19
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.18 2000/01/14 19:23:34 art Exp $	*/
d714 1
a714 1
		return (NULL);
@


1.18
log
@Try to allocate the first indirect block in the same cg as the inode.
This improves read speed for files of moderate size (100-500k).
From FreeBSD (mckusick@@FreeBSD.ORG).
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.17 1999/12/06 06:50:11 art Exp $	*/
d320 1
a320 1
 * block immediately preceeding the current range. If successful, the
d1417 1
a1417 1
		softdep_freefile(ap);
@


1.18.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.27 2001/04/06 20:43:31 gluk Exp $	*/
d64 1
a64 1
static ino_t	ffs_dirpref __P((struct inode *));
d80 1
a80 1
 *
d111 1
a111 1

d178 1
a178 1

d218 1
a218 1
			panic("ffs_realloccg: bad blockno");
d235 2
a236 2
		 * Allocate an exact sized fragment. Although this makes
		 * best use of space, we will waste time relocating it if
d463 2
a464 2
				    blkno, *bap, fs->fs_bsize, fs->fs_bsize,
				    buflist->bs_children[i]);
d467 2
a468 2
				    i < ssize ? sbp : ebp, soff + i, blkno,
				    *bap, buflist->bs_children[i]);
d477 1
a477 1
	 * they are almost never written, but if we are concerned about
d514 1
a514 1
			ffs_blkfree(ip,
d516 1
a516 1
			    fs->fs_bsize);
d582 1
a582 1
		ipref = ffs_dirpref(pip);
a587 12

	/*
	 * Track number of dirs created one after another
	 * in a same cg without intervening by files.
	 */
	if ((mode & IFMT) == IFDIR) {
		if (fs->fs_contigdirs[cg] < 255)
			fs->fs_contigdirs[cg]++;
	} else {
		if (fs->fs_contigdirs[cg] > 0)
			fs->fs_contigdirs[cg]--;
	}
d625 1
a625 1
 * Find a cylinder group to place a directory.
d627 3
a629 7
 * The policy implemented by this algorithm is to allocate inode
 * in the same cylinder group as a parent directory in, but also
 * reserve space for file's data and inodes. Restrict number of
 * directories which may be allocated one after another in a same
 * cg without intervening by files.
 * If we allocate a first level directory then force allocation
 * in another cg.
d632 2
a633 2
ffs_dirpref(pip)
	struct inode *pip;
d635 1
a635 8
	register struct fs *fs;
	int	cg, prefcg, dirsize, cgsize;
	int	avgifree, avgbfree, avgndir, curdirsize;
	int	minifree, minbfree, maxndir;
	int	mincg, minndir;
	int	maxcontigdirs;

	fs = pip->i_fs;
d638 7
a644 86
	avgbfree = fs->fs_cstotal.cs_nbfree / fs->fs_ncg;
	avgndir = fs->fs_cstotal.cs_ndir / fs->fs_ncg;
#if 1

	/*
	 * Force allocation in another cg if creating a first level dir.
	 */
	if (ITOV(pip)->v_flag & VROOT) {
		prefcg = arc4random() % fs->fs_ncg;
		mincg = prefcg;
		minndir = fs->fs_ipg;
		for (cg = prefcg; cg < fs->fs_ncg; cg++)
			if (fs->fs_cs(fs, cg).cs_ndir < minndir &&
			    fs->fs_cs(fs, cg).cs_nifree >= avgifree &&
			    fs->fs_cs(fs, cg).cs_nbfree >= avgbfree) {
				mincg = cg;
				minndir = fs->fs_cs(fs, cg).cs_ndir;
			}
		for (cg = 0; cg < prefcg; cg++)
			if (fs->fs_cs(fs, cg).cs_ndir < minndir &&
			    fs->fs_cs(fs, cg).cs_nifree >= avgifree &&
			    fs->fs_cs(fs, cg).cs_nbfree >= avgbfree) {
				mincg = cg;
				minndir = fs->fs_cs(fs, cg).cs_ndir;
			}
		cg = mincg;
		goto end;
	} else
		prefcg = ino_to_cg(fs, pip->i_number);
#else
	prefcg = ino_to_cg(fs, pip->i_number);
#endif

	/*
	 * Count various limits which used for
	 * optimal allocation of a directory inode.
	 */
#if 1
	maxndir = min(avgndir + fs->fs_ipg / 16, fs->fs_ipg);
	minifree = avgifree - fs->fs_ipg / 4;
	if (minifree < 0)
		minifree = 0;
	minbfree = avgbfree - fs->fs_fpg / fs->fs_frag / 4;
	if (minbfree < 0)
		minbfree = 0;
#else
	maxndir = avgndir + (fs->fs_ipg - avgndir) / 16;
	minifree = avgifree * 3 / 4;
	minbfree = avgbfree * 3 / 4;
#endif
	cgsize = fs->fs_fsize * fs->fs_fpg;
	dirsize = fs->fs_avgfilesize * fs->fs_avgfpdir;
	if (dirsize <= 0)
		dirsize = 16384 * 64;
	curdirsize = avgndir ? (cgsize - avgbfree * fs->fs_bsize) / avgndir : 0;
	if (dirsize < curdirsize)
		dirsize = curdirsize;
	maxcontigdirs = min(cgsize / dirsize, 255);
	if (fs->fs_avgfpdir > 0)
		maxcontigdirs = min(maxcontigdirs,
				    fs->fs_ipg / fs->fs_avgfpdir);
	if (maxcontigdirs == 0)
		maxcontigdirs = 1;

	/*
	 * Limit number of dirs in one cg and reserve space for 
	 * regular files, but only if we have no deficit in
	 * inodes or space.
	 */
	for (cg = prefcg; cg < fs->fs_ncg; cg++)
		if (fs->fs_cs(fs, cg).cs_ndir < maxndir &&
		    fs->fs_cs(fs, cg).cs_nifree >= minifree &&
	    	    fs->fs_cs(fs, cg).cs_nbfree >= minbfree) {
			if (fs->fs_contigdirs[cg] < maxcontigdirs)
				goto end;
			else
				continue;
		}
	for (cg = 0; cg < prefcg; cg++)
		if (fs->fs_cs(fs, cg).cs_ndir < maxndir &&
		    fs->fs_cs(fs, cg).cs_nifree >= minifree &&
	    	    fs->fs_cs(fs, cg).cs_nbfree >= minbfree) {
			if (fs->fs_contigdirs[cg] < maxcontigdirs)
				goto end;
			else
				continue;
d646 1
a646 9
	/* This work when we have deficit in space */
	for (cg = prefcg; cg < fs->fs_ncg; cg++)
		if (fs->fs_cs(fs, cg).cs_nifree >= avgifree)
			goto end;
	for (cg = 0; cg < prefcg; cg++)
		if (fs->fs_cs(fs, cg).cs_nifree >= avgifree)
			goto end;
end:
	return ((ino_t)(fs->fs_ipg * cg));
d653 1
a653 1
 *
d667 1
a667 1
 *
d714 1
a714 1
		return (0);
d791 1
a791 1
	return (0);
d797 1
a797 1
 * Check to see if the necessary fragments are available, and
d816 1
a816 1
		return (0);
d821 1
a821 1
		return (0);
d827 1
a827 1
		return (0);
d832 1
a832 1
		return (0);
d839 1
a839 1
			return (0);
d888 1
a888 1
		return (0);
d893 1
a893 1
		return (0);
d899 1
a899 1
		return (0);
d923 1
a923 1
			return (0);
d939 5
d946 2
a947 1
		return (0);
d949 1
a949 1

d963 1
a963 1
	bdwrite(bp);
d1010 1
a1010 1
		 * next available free block following the one
d1024 1
a1024 1
	 * check the summary information to see if a block is
d1069 5
d1075 2
a1076 1
		return (0);
d1089 4
a1092 4
	blkno = cgp->cg_cgx * fs->fs_fpg + bno;
	if (DOINGSOFTDEP(ITOV(ip)))
		softdep_setup_blkmapdep(bp, fs, blkno);
	return (blkno);
d1118 1
a1118 1
		return (0);
d1232 1
a1232 1
		return (0);
d1237 1
a1237 1
		return (0);
d1242 1
a1242 1
		return (0);
d1277 1
a1277 1
	if (DOINGSOFTDEP(ITOV(ip)))
d1298 1
a1298 1
 * free map. If a fragment is deallocated, a possible
d1318 1
a1318 1
		panic("ffs_blkfree: bad size");
d1344 1
a1344 1
			panic("ffs_blkfree: freeing free block");
d1369 1
a1369 1
				panic("ffs_blkfree: freeing free frag");
d1415 1
d1417 1
a1417 1
		softdep_freefile(ap->a_pvp, ap->a_ino, ap->a_mode);
d1430 5
a1434 5
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap;
d1446 1
a1446 1
		panic("ffs_freefile: range: dev = 0x%x, ino = %d, fs = %s",
d1466 1
a1466 1
			panic("ffs_freefile: freeing free inode");
d1504 1
a1504 1
		panic("ffs_checkblk: bad size");
d1507 1
a1507 1
		panic("ffs_checkblk: bad block %d", bno);
d1530 1
a1530 1
			panic("ffs_checkblk: partially free fragment");
d1697 1
a1697 1
 *
d1710 1
@


1.18.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.18.2.1 2001/05/14 22:47:40 niklas Exp $	*/
d76 1
d279 1
d281 3
d349 1
d495 2
a496 1
			UFS_UPDATE(ip, MNT_WAIT);
d558 2
a559 2
ffs_inode_alloc(struct inode *pip, int mode, struct ucred *cred,
    struct vnode **vpp)
d561 11
a571 3
	struct vnode *pvp = ITOV(pip);
	struct fs *fs;
	struct inode *ip;
d575 2
a576 1
	*vpp = NULL;
d603 1
a603 1
	error = VFS_VGET(pvp->v_mount, ino, vpp);
d605 1
a605 1
		ffs_inode_free(pip, ino, mode);
d608 1
a608 1
	ip = VTOI(*vpp);
d631 1
a631 1
	ffs_fserr(fs, cred->cr_uid, "out of inodes");
d639 5
a643 7
 * The policy implemented by this algorithm is to allocate a
 * directory inode in the same cylinder group as its parent
 * directory, but also to reserve space for its files inodes
 * and data. Restrict the number of directories which may be
 * allocated one after another in the same cylinder group
 * without intervening allocation of files.
 *
d645 1
a645 1
 * in another cylinder group.
d713 2
d736 2
d745 2
d748 1
a748 3
	/*
	 * This is a backstop when we have deficit in space.
	 */
d1500 3
d1504 2
a1505 1
ffs_inode_free(struct inode *pip, ino_t ino, int mode)
d1507 5
a1511 1
	struct vnode *pvp = ITOV(pip);
d1513 2
a1514 2
	if (DOINGSOFTDEP(pvp)) {
		softdep_freefile(pvp, ino, mode);
d1518 1
a1518 1
	return (ffs_freefile(pip, ino, mode));
d1526 6
a1531 1
ffs_freefile(struct inode *pip, ino_t ino, int mode)
d1533 4
a1536 2
	struct fs *fs;
	struct cg *cgp;
d1540 1
d1571 1
a1571 1
	if ((mode & IFMT) == IFDIR) {
@


1.18.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.18.2.2 2001/07/04 11:00:47 niklas Exp $	*/
d411 1
a411 2
		if (start_lvl > 1 &&
		    start_ap[start_lvl-1].in_lbn == idp->in_lbn)
@


1.18.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#include <uvm/uvm_extern.h>
@


1.18.2.5
log
@Merge in -current
@
text
@d107 1
d109 1
d126 2
a127 2

	if ((error = ufs_quota_alloc_blocks(ip, btodb(size), cred)) != 0)
d129 1
a129 1

d144 1
a144 1

d148 2
a149 2
	(void) ufs_quota_free_blocks(ip, btodb(size), cred);

d165 1
a165 1
ffs_realloccg(ip, lbprev, bpref, osize, nsize, cred, bpp, blknop)
a171 1
	ufs_daddr_t *blknop;
d173 2
a174 3
	struct fs *fs;
	struct buf *bp = NULL;
	ufs_daddr_t quota_updated = 0;
d178 1
a178 3
	if (bpp != NULL)
		*bpp = NULL;

d201 10
a210 10
	if (bpp != NULL &&
	    (error = bread(ITOV(ip), lbprev, osize, NOCRED, &bp)) != 0)
		goto error;

	if ((error = ufs_quota_alloc_blocks(ip, btodb(nsize - osize), cred))
	    != 0)
		goto error;

	quota_updated = btodb(nsize - osize);

d216 2
d220 4
a223 11
		if (bpp != NULL) {
			if (bp->b_blkno != fsbtodb(fs, bno))
				panic("ffs_realloccg: bad blockno");
			allocbuf(bp, nsize);
			bp->b_flags |= B_DONE;
			bzero((char *)bp->b_data + osize, (u_int)nsize - osize);
			*bpp = bp;
		}
		if (blknop != NULL) {
			*blknop = bno;
		}
d276 1
a276 11
	if (bno <= 0) 
		goto nospace;

	if (!DOINGSOFTDEP(ITOV(ip)))
		ffs_blkfree(ip, bprev, (long)osize);
	if (nsize < request)
		ffs_blkfree(ip, bno + numfrags(fs, nsize),
		    (long)(request - nsize));
	ip->i_ffs_blocks += btodb(nsize - osize);
	ip->i_flag |= IN_CHANGE | IN_UPDATE;
	if (bpp != NULL) {
d278 8
d290 1
d292 7
a298 5
	if (blknop != NULL) {
		*blknop = bno;
	}
	return (0);

d305 1
a305 15
	error = ENOSPC;

error:
	if (bp != NULL) {
		brelse(bp);
		bp = NULL;
	}

 	/*
	 * Restore user's disk quota because allocation failed.
	 */
	if (quota_updated != 0)
		(void)ufs_quota_free_blocks(ip, quota_updated, cred);
		
	return error;
d345 1
a345 2
	/* XXXUBC - don't reallocblks for now */
	if (1 || doreallocblks == 0)
@


1.18.2.6
log
@Merge in trunk
@
text
@a51 1
#include <ufs/ufs/extattr.h>
d172 1
a172 1
	register struct fs *fs;
d180 1
a285 1
	(void) uvm_vnp_uncache(ITOV(ip));
d365 2
a366 1
	if (doreallocblks == 0)
@


1.18.2.7
log
@Merge in -current from roughly a week ago
@
text
@d62 11
a72 10
static daddr_t	ffs_alloccg(struct inode *, int, daddr_t, int);
static daddr_t	ffs_alloccgblk(struct inode *, struct buf *, daddr_t);
static daddr_t	ffs_clusteralloc(struct inode *, int, daddr_t, int);
static ino_t	ffs_dirpref(struct inode *);
static daddr_t	ffs_fragextend(struct inode *, int, long, int, int);
static void	ffs_fserr(struct fs *, u_int, char *);
static u_long	ffs_hashalloc(struct inode *, int, long, int,
		    daddr_t (*)(struct inode *, int, daddr_t, int));
static daddr_t	ffs_nodealloccg(struct inode *, int, daddr_t, int);
static daddr_t	ffs_mapsearch(struct fs *, struct cg *, daddr_t, int);
d75 1
a75 1
static int      ffs_checkblk(struct inode *, daddr_t, long);
d867 1
a867 1
	daddr_t (*allocator)(struct inode *, int, daddr_t, int);
@


1.18.2.8
log
@Sync the SMP branch with 3.3
@
text
@d1792 1
a1792 1
	log(LOG_ERR, "uid %u on %s: %s\n", uid, fs->fs_fsmnt, cp);
@


1.18.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.18.2.8 2003/03/28 00:08:47 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d170 1
a170 1
	daddr_t *blknop;
d174 1
a174 1
	daddr_t quota_updated = 0;
@


1.18.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a50 1
#include <ufs/ufs/ufsmount.h>
d627 1
a627 1
		ip->i_ffs_gen = arc4random() & INT_MAX;
d672 1
a672 1
		prefcg = (arc4random() & INT_MAX) % fs->fs_ncg;
@


1.17
log
@#if 0 some broken unreached code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.16 1999/06/01 01:48:52 millert Exp $	*/
d689 1
a689 1
		if (lbn < NDADDR) {
@


1.16
log
@minor comment beautification
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.15 1999/02/26 03:56:30 art Exp $	*/
d939 5
d946 1
d949 1
d1069 5
d1075 2
a1076 1
		return (NULL);
@


1.15
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.14 1999/01/11 05:12:37 millert Exp $	*/
d1498 1
a1498 1
		/* XXX -probably should pannic here */
d1504 1
a1504 1
		/* XXX -probably should pannic here */
@


1.14
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.13 1998/03/27 11:51:01 pefo Exp $	*/
d279 3
d283 1
@


1.13
log
@Make compile without diagnistic possible. (Yes very small kernel)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.12 1998/03/03 17:05:32 ryker Exp $	*/
d121 1
a121 1
		panic("ffs_alloc: missing credential\n");
d190 1
a190 1
		panic("ffs_realloccg: missing credential\n");
d1429 1
a1429 1
		panic("ifree: range: dev = 0x%x, ino = %d, fs = %s\n",
@


1.12
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.11 1998/03/01 08:07:11 niklas Exp $	*/
d514 1
a514 1
#ifdef DEBUG
d1472 1
a1472 1
int
@


1.11
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.10 1997/11/06 05:59:17 csapuntz Exp $	*/
d1485 1
a1485 1
		printf("bsize = %d, size = %d, fs = %s\n",
@


1.10
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.9 1997/10/06 20:21:33 deraadt Exp $	*/
d495 1
a495 1
	if (ssize < len)
d500 1
@


1.9
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.7 1997/07/22 10:31:50 deraadt Exp $	*/
d62 1
a62 1
static daddr_t	ffs_alloccgblk __P((struct fs *, struct cg *, daddr_t));
d73 5
d280 2
a281 1
		ffs_blkfree(ip, bprev, (long)osize);
d323 1
a323 2
#ifdef DEBUG
#include <sys/sysctl.h>
d325 1
a325 1
struct ctldebug debug14 = { "doasyncfree", &doasyncfree };
a326 4
struct ctldebug debug15 = { "prtrealloc", &prtrealloc };
#else
#define doasyncfree 1
#endif
d347 3
d359 1
d361 5
d368 7
a374 1
			panic("ffs_reallocblks: non-cluster");
d441 1
a441 1
		if (i == ssize)
d443 2
d446 3
d456 11
d508 4
a511 2
		ffs_blkfree(ip, dbtofsb(fs, buflist->bs_children[i]->b_blkno),
		    fs->fs_bsize);
d514 3
d855 3
d878 2
a879 2
	register int i;
	int error, bno, frags, allocsiz;
d898 1
a898 1
		bno = ffs_alloccgblk(fs, cgp, bpref);
d920 1
a920 1
		bno = ffs_alloccgblk(fs, cgp, bpref);
d947 6
a952 2
	bdwrite(bp);
	return (cg * fs->fs_fpg + bno);
d967 3
a969 3
ffs_alloccgblk(fs, cgp, bpref)
	register struct fs *fs;
	register struct cg *cgp;
d972 2
d979 2
d1071 4
a1074 1
	return (cgp->cg_cgx * fs->fs_fpg + bno);
d1094 1
a1094 1
	int i, run, bno, bit, map;
d1148 1
a1148 1
	for (run = 0, i = bpref; i < cgp->cg_nclusterblks; i++) {
d1156 1
a1156 1
		if ((i & (NBBY - 1)) != (NBBY - 1)) {
d1163 1
a1163 1
	if (i >= cgp->cg_nclusterblks)
d1168 11
a1178 1
	bno = cg * fs->fs_fpg + blkstofrags(fs, i - run + 1);
d1181 1
a1181 1
		if (ffs_alloccgblk(fs, cgp, bno + i) != bno + i)
d1259 3
d1296 2
a1297 1
	if ((u_int)size > fs->fs_bsize || fragoff(fs, size) != 0) {
d1323 1
a1323 1
		if (ffs_isblock(fs, cg_blksfree(cgp), blkno)) {
a1385 2
 *
 * The specified inode is placed back in the free map.
d1396 22
d1435 1
a1435 1
		return (0);
d1466 54
d1692 1
@


1.8
log
@VFS Lite2 Changes
@
text
@d62 1
a62 1
static daddr_t	ffs_alloccgblk __P((struct inode *, struct buf *, daddr_t));
a72 5
#ifdef DIAGNOSTIC
static int      ffs_checkblk __P((struct inode *, daddr_t, long));
#endif
int ffs_freefile __P((struct vop_vfree_args *));

d275 1
a275 2
		if (!DOINGSOFTDEP(ITOV(ip)))
			ffs_blkfree(ip, bprev, (long)osize);
d317 2
a318 1

d320 1
a320 1
int doreallocblks = 1;
d322 4
a345 3
	if (doreallocblks == 0)
		return (ENOSPC);

a354 1

a355 5
	for (i = 0; i < len; i++)
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs_reallocblks: unallocated block 1");
		
d358 1
a358 7
			panic("ffs_reallocblks: non-logical cluster");

	blkno = buflist->bs_children[0]->b_blkno;
	ssize = fsbtodb(fs, fs->fs_frag);
	for (i = 1; i < len - 1; i++)
		if (buflist->bs_children[i]->b_blkno != blkno + (i * ssize))
			panic("ffs_reallocblks: non-physical cluster %d", i);
d425 1
a425 1
		if (i == ssize) {
a426 2
			soff = -i;
		}
a427 3
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs_reallocblks: unallocated block 2");
a434 11
		if (DOINGSOFTDEP(vp)) {
			if (sbap == &ip->i_ffs_db[0] && i < ssize)
				softdep_setup_allocdirect(ip, start_lbn + i,
				   blkno, *bap, fs->fs_bsize, fs->fs_bsize,
                                   buflist->bs_children[i]);
			else
				softdep_setup_allocindir_page(ip, start_lbn + i,
                                   i < ssize ? sbp : ebp, soff + i, blkno,
                                   *bap, buflist->bs_children[i]);
		}

d476 2
a477 4
		if (!DOINGSOFTDEP(vp))
			ffs_blkfree(ip, 
			    dbtofsb(fs, buflist->bs_children[i]->b_blkno),
		            fs->fs_bsize);
a479 3
		if (!ffs_checkblk(ip,
		   dbtofsb(fs, buflist->bs_children[i]->b_blkno), fs->fs_bsize))
			panic("ffs_reallocblks: unallocated block 3");
a817 3
	if (DOINGSOFTDEP(ITOV(ip)))
		softdep_setup_blkmapdep(bp, fs, bprev);

d838 2
a839 2
	daddr_t bno, blkno;
	int error, i, frags, allocsiz;
d858 1
a858 1
		bno = ffs_alloccgblk(ip, bp, bpref);
d880 1
a880 1
		bno = ffs_alloccgblk(ip, bp, bpref);
d907 2
a908 6

	blkno = cg * fs->fs_fpg + bno;
	if (DOINGSOFTDEP(ITOV(ip)))
		softdep_setup_blkmapdep(bp, fs, blkno);
        bdwrite(bp);
	return ((u_long)blkno);
d923 3
a925 3
ffs_alloccgblk(ip, bp, bpref)
	struct inode *ip;
	struct buf *bp;
a927 2
	struct fs *fs;
	struct cg *cgp;
a932 2
	fs = ip->i_fs;
	cgp = (struct cg *)bp->b_data;
d1023 1
a1023 4
        blkno = cgp->cg_cgx * fs->fs_fpg + bno;
        if (DOINGSOFTDEP(ITOV(ip)))
                softdep_setup_blkmapdep(bp, fs, blkno);
        return (blkno);
d1043 1
a1043 1
	int i, got, run, bno, bit, map;
d1097 1
a1097 1
	for (run = 0, got = bpref; got < cgp->cg_nclusterblks; got++) {
d1105 1
a1105 1
		if ((got & (NBBY - 1)) != (NBBY - 1)) {
d1112 1
a1112 1
	if (got >= cgp->cg_nclusterblks)
d1117 1
a1117 11
#ifdef DIAGNOSTIC
	for (i = 1; i <= len; i++)
		if (!ffs_isblock(fs, cg_blksfree(cgp), got - run + i))
			panic("ffs_clusteralloc: map mismatch");
#endif
	bno = cg * fs->fs_fpg + blkstofrags(fs, got - run + 1);
#ifdef DIAGNOSTIC
	if (dtog(fs, bno) != cg)
		panic("ffs_clusteralloc: allocated out of group");
#endif

d1120 1
a1120 1
		if (ffs_alloccgblk(ip, bp, bno + i) != bno + i)
a1197 3
        if (DOINGSOFTDEP(ITOV(ip)))
		softdep_setup_inomapdep(bp, ip, cg * fs->fs_ipg + ipref);

d1232 1
a1232 2
	if ((u_int)size > fs->fs_bsize || fragoff(fs, size) != 0 ||
	    fragnum(fs, bno) + numfrags(fs, size) > fs->fs_frag) {
d1258 1
a1258 1
		if (!ffs_isfreeblock(fs, cg_blksfree(cgp), blkno)) {
d1321 2
a1332 22


	if (DOINGSOFTDEP(ap->a_pvp)) {
		softdep_freefile(ap);
		return (0);
	}

	return (ffs_freefile(ap));
}

/*
 * Do the actual free operation.
 * The specified inode is placed back in the free map.
 */
int
ffs_freefile(ap)
      struct vop_vfree_args /* {
              struct vnode *a_pvp;
              ino_t a_ino;
              int a_mode;
      } */ *ap;
{
d1350 1
a1350 1
		return (error);
a1380 54
#ifdef DIAGNOSTIC
/*
 * Verify allocation of a block or fragment. Returns true if block or
 * fragment is allocated, false if it is free.
 */
int
ffs_checkblk(ip, bno, size)
	struct inode *ip;
	daddr_t bno;
	long size;
{
	struct fs *fs;
	struct cg *cgp;
	struct buf *bp;
	int i, error, frags, free;

	fs = ip->i_fs;
	if ((u_int)size > fs->fs_bsize || fragoff(fs, size) != 0) {
		printf("bsize = %d, size = %d, fs = %s\n",
		    fs->fs_bsize, size, fs->fs_fsmnt);
		panic("checkblk: bad size");
	}
	if ((u_int)bno >= fs->fs_size)
		panic("checkblk: bad block %d", bno);
	error = bread(ip->i_devvp, fsbtodb(fs, cgtod(fs, dtog(fs, bno))),
		(int)fs->fs_cgsize, NOCRED, &bp);
	if (error) {
		/* XXX -probably should pannic here */
		brelse(bp);
		return (-1);
	}
	cgp = (struct cg *)bp->b_data;
	if (!cg_chkmagic(cgp)) {
		/* XXX -probably should pannic here */
		brelse(bp);
		return (-1);
	}
	bno = dtogd(fs, bno);
	if (size == fs->fs_bsize) {
		free = ffs_isblock(fs, cg_blksfree(cgp), fragstoblks(fs, bno));
	} else {
		frags = numfrags(fs, size);
		for (free = 0, i = 0; i < frags; i++)
			if (isset(cg_blksfree(cgp), bno + i))
				free++;
		if (free != 0 && free != frags)
			panic("checkblk: partially free fragment");
	}
	brelse(bp);
	return (!free);
}
#endif /* DIAGNOSTIC */


a1552 1

@


1.7
log
@range error fix; mckusick@@McKusick.COM
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.6 1997/05/30 08:34:15 downsj Exp $	*/
d62 1
a62 1
static daddr_t	ffs_alloccgblk __P((struct fs *, struct cg *, daddr_t));
d73 5
d280 2
a281 1
		ffs_blkfree(ip, bprev, (long)osize);
d323 1
a323 2
#ifdef DEBUG
#include <sys/sysctl.h>
d325 1
a325 1
struct ctldebug debug14 = { "doasyncfree", &doasyncfree };
a326 4
struct ctldebug debug15 = { "prtrealloc", &prtrealloc };
#else
#define doasyncfree 1
#endif
d347 3
d359 1
d361 5
d368 7
a374 1
			panic("ffs_reallocblks: non-cluster");
d441 1
a441 1
		if (i == ssize)
d443 2
d446 3
d456 11
d508 4
a511 2
		ffs_blkfree(ip, dbtofsb(fs, buflist->bs_children[i]->b_blkno),
		    fs->fs_bsize);
d514 3
d855 3
d878 2
a879 2
	register int i;
	int error, bno, frags, allocsiz;
d898 1
a898 1
		bno = ffs_alloccgblk(fs, cgp, bpref);
d920 1
a920 1
		bno = ffs_alloccgblk(fs, cgp, bpref);
d947 6
a952 2
	bdwrite(bp);
	return (cg * fs->fs_fpg + bno);
d967 3
a969 3
ffs_alloccgblk(fs, cgp, bpref)
	register struct fs *fs;
	register struct cg *cgp;
d972 2
d979 2
d1071 4
a1074 1
	return (cgp->cg_cgx * fs->fs_fpg + bno);
d1094 1
a1094 1
	int i, run, bno, bit, map;
d1148 1
a1148 1
	for (run = 0, i = bpref; i < cgp->cg_nclusterblks; i++) {
d1156 1
a1156 1
		if ((i & (NBBY - 1)) != (NBBY - 1)) {
d1163 1
a1163 1
	if (i >= cgp->cg_nclusterblks)
d1168 11
a1178 1
	bno = cg * fs->fs_fpg + blkstofrags(fs, i - run + 1);
d1181 1
a1181 1
		if (ffs_alloccgblk(fs, cgp, bno + i) != bno + i)
d1259 3
d1296 2
a1297 1
	if ((u_int)size > fs->fs_bsize || fragoff(fs, size) != 0) {
d1323 1
a1323 1
		if (ffs_isblock(fs, cg_blksfree(cgp), blkno)) {
a1385 2
 *
 * The specified inode is placed back in the free map.
d1396 22
d1435 1
a1435 1
		return (0);
d1466 54
d1692 1
@


1.6
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.5 1997/02/11 06:59:27 millert Exp $	*/
d1112 1
a1112 1
	if (i == cgp->cg_nclusterblks)
@


1.5
log
@Add fs_id support and random inode generation numbers for ffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.4 1996/05/22 11:47:17 deraadt Exp $	*/
d135 1
a135 1
		ip->i_blocks += btodb(size);
d189 1
a189 1
	if ((bprev = ip->i_db[lbprev]) == 0) {
d214 1
a214 1
		ip->i_blocks += btodb(nsize - osize);
d279 1
a279 1
		ip->i_blocks += btodb(nsize - osize);
d375 1
a375 1
		sbap = &ip->i_db[0];
d451 1
a451 1
	if (sbap != &ip->i_db[0]) {
d495 1
a495 1
	if (sbap != &ip->i_db[0])
d555 1
a555 1
	if (ip->i_mode) {
d557 1
a557 1
		    ip->i_mode, ip->i_number, fs->fs_fsmnt);
d560 1
a560 1
	if (ip->i_blocks) {				/* XXX */
d562 2
a563 2
		    fs->fs_fsmnt, ino, ip->i_blocks);
		ip->i_blocks = 0;
d565 1
a565 1
	ip->i_flags = 0;
d571 4
a574 4
	if (ip->i_gen == 0 || ++(ip->i_gen) == 0)
		ip->i_gen = arc4random();
	if (ip->i_gen == 0 || ip->i_gen == -1)
		ip->i_gen = 1;				/* shouldn't happen */
d1240 1
a1240 1
		ffs_fserr(fs, ip->i_uid, "bad block");
@


1.4
log
@Change VOP_UPDATE() semantics:
* Make 2nd and 3rd args timespecs, not timevals.
* Consistently pass a Boolean as the 4th arg (except in LFS).
Also, fix ffs_update() and lfs_update() to actually change the nsec fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_alloc.c,v 1.2 1996/02/27 07:27:34 niklas Exp $	*/
d50 2
d568 2
d571 4
a574 3
	if (++nextgennumber < (u_long)time.tv_sec)
		nextgennumber = time.tv_sec;
	ip->i_gen = nextgennumber;
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: ffs_alloc.c,v 1.10 1996/03/17 02:16:18 christos Exp $	*/
d342 1
d456 4
a459 3
		if (!doasyncfree)
			VOP_UPDATE(vp, (struct timeval *)&time,
			    (struct timeval *)&time, MNT_WAIT);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ffs_alloc.c,v 1.9 1996/02/09 22:22:18 christos Exp $	*/
d1226 1
a1226 1
		printf("dev = 0x%x, bsize = %d, size = %d, fs = %s\n",
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ffs_alloc.c,v 1.8 1995/07/19 15:47:36 cgd Exp $	*/
d52 1
d65 4
a68 3
static u_long	ffs_hashalloc
		    __P((struct inode *, int, long, int, u_int32_t (*)()));
static ino_t	ffs_nodealloccg __P((struct inode *, int, daddr_t, int));
d90 1
d100 4
a103 1
	int cg, error;
d121 1
a121 1
	if (error = chkdq(ip, (long)btodb(size), cred, 0))
d131 1
a131 1
	    (u_int32_t (*)())ffs_alloccg);
d158 1
d195 1
a195 1
	if (error = bread(ITOV(ip), lbprev, osize, NOCRED, &bp)) {
d200 1
a200 1
	if (error = chkdq(ip, (long)btodb(nsize - osize), cred, 0)) {
d209 1
a209 1
	if (bno = ffs_fragextend(ip, cg, (long)bprev, osize, nsize)) {
d269 1
a269 1
	    (u_int32_t (*)())ffs_alloccg);
d326 3
a328 1
ffs_reallocblks(ap)
d332 1
a332 2
	} */ *ap;
{
d337 1
a337 1
	daddr_t *bap, *sbap, *ebap;
d339 1
a339 1
	daddr_t start_lbn, end_lbn, soff, eoff, newblk, blkno;
d406 1
a406 1
	    len, (u_int32_t (*)())ffs_clusteralloc)) == 0)
d511 4
a514 1
ffs_valloc(ap)
d520 1
a520 2
	} */ *ap;
{
d704 1
a704 1
	u_int32_t (*allocator)();
d1132 1
a1132 1
static ino_t
d1212 1
d1318 3
a1320 1
ffs_vfree(ap)
d1325 1
a1325 2
	} */ *ap;
{
d1444 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

