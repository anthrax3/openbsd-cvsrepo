head	1.88;
access;
symbols
	OPENBSD_6_1_BASE:1.88
	OPENBSD_6_0:1.87.0.2
	OPENBSD_6_0_BASE:1.87
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.77.0.4
	OPENBSD_5_6_BASE:1.77
	OPENBSD_5_5:1.73.0.4
	OPENBSD_5_5_BASE:1.73
	OPENBSD_5_4:1.71.0.2
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.70.0.2
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.68.0.2
	OPENBSD_5_2_BASE:1.68
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.4
	OPENBSD_5_0:1.67.0.2
	OPENBSD_5_0_BASE:1.67
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.56.0.2
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.52.0.2
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.36.0.2
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.31.0.4
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.27.0.4
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.27
	UBC:1.24.0.2
	UBC_BASE:1.24
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.88
date	2016.09.10.16.53.30;	author natano;	state Exp;
branches;
next	1.87;
commitid	OheBN9SCINTycSAi;

1.87
date	2016.05.23.09.31.28;	author natano;	state Exp;
branches;
next	1.86;
commitid	wckQrShbScIX7TCE;

1.86
date	2016.04.07.11.13.01;	author mpi;	state Exp;
branches;
next	1.85;
commitid	OftkJwBAXsVTLQrg;

1.85
date	2016.03.01.21.00.56;	author natano;	state Exp;
branches;
next	1.84;
commitid	IZU5JUTrd4TpE0ix;

1.84
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.83;
commitid	gFybgYMymUyTbVeS;

1.83
date	2016.02.26.08.56.10;	author natano;	state Exp;
branches;
next	1.82;
commitid	1wcjndbWCkf5R7p2;

1.82
date	2016.02.16.17.56.12;	author stefan;	state Exp;
branches;
next	1.81;
commitid	6HMhQmvFL5xr8Rk9;

1.81
date	2016.01.12.11.41.00;	author mpi;	state Exp;
branches;
next	1.80;
commitid	PdHHohncj6RrnJZN;

1.80
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.79;
commitid	p4LJxGKbi0BU2cG6;

1.79
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.78;
commitid	C5iGb36LQxjM60Q3;

1.78
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.77;
commitid	uzzBR7hz9ncd4O6G;

1.77
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.76;
commitid	EF98ch02VpFassUi;

1.76
date	2014.05.22.02.02.39;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2014.05.09.03.48.58;	author tedu;	state Exp;
branches;
next	1.74;

1.74
date	2014.04.08.18.48.41;	author beck;	state Exp;
branches;
next	1.73;

1.73
date	2013.12.12.19.00.10;	author tedu;	state Exp;
branches;
next	1.72;

1.72
date	2013.09.14.02.28.02;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.16.22.41.47;	author beck;	state Exp;
branches;
next	1.69;

1.69
date	2012.09.17.14.22.23;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2012.07.11.12.39.20;	author guenther;	state Exp;
branches;
next	1.67;

1.67
date	2011.08.16.14.36.39;	author thib;	state Exp;
branches;
next	1.66;

1.66
date	2011.08.03.20.21.19;	author beck;	state Exp;
branches;
next	1.65;

1.65
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2011.06.09.23.31.32;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2011.04.12.19.45.43;	author beck;	state Exp;
branches;
next	1.61;

1.61
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.60;

1.60
date	2010.12.29.21.28.45;	author thib;	state Exp;
branches;
next	1.59;

1.59
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.29.14.48.08;	author thib;	state Exp;
branches;
next	1.55;

1.55
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.25.15.49.26;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.06.18.06.22;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.15.07.58.37;	author grange;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.23.20.15.07;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.13.17.09.22;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.26.11.25.23;	author pedro;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.13.17.41.55;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2006.10.29.00.53.37;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.21.10.01.10;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.31.12.33.33;	author pedro;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.17.13.56.01;	author pedro;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.08.02.29.51;	author pedro;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.03.20.14.02;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.28.02.02.50;	author pedro;	state Exp;
branches;
next	1.32;

1.32
date	2005.02.17.18.07.37;	author jfb;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.02.05.46.01;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.11.08.04.34.18;	author art;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.10.04.45.32;	author art;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.04.22.44.32;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.10.08.48.42;	author gluk;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.27.04.58.48;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.02.07.55;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.22.00.11.36;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.20.17.30.07;	author gluk;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.09.23.09.18;	author gluk;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.01.20.54.36;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.24.19.07.10;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.23.13.59.11;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.12.05.08.30.38;	author art;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.02.26.03.56.30;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.11.12.04.30.02;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	98.08.06.19.35.07;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.05.59.20;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.21.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.26.32;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.47.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.27.41;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.14.22.47.41;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.07.04.11.00.52;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.10.2.9;

1.10.2.9
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.10.2.10;

1.10.2.10
date	2004.02.19.11.01.41;	author niklas;	state Exp;
branches;
next	1.10.2.11;

1.10.2.11
date	2004.06.05.23.13.11;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2003.05.19.22.38.11;	author tedu;	state Exp;
branches;
next	1.24.2.5;

1.24.2.5
date	2003.05.20.04.18.42;	author tedu;	state Exp;
branches;
next	;

1.28.2.1
date	2004.03.03.08.50.13;	author brad;	state Exp;
branches;
next	;

1.29.2.1
date	2004.03.03.08.32.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.88
log
@Add a noperm mount flag for FFS to be used for building release sets
without root privileges. This is only the kernel/mount flag; additional
work in the build Makefile's will be necessary such that the files in
$DESTDIR are created with correct permissions.

tedu couldn't find anything wrong with it in a quick review
idea & ok deraadt
@
text
@/*	$OpenBSD: ffs_vnops.c,v 1.87 2016/05/23 09:31:28 natano Exp $	*/
/*	$NetBSD: ffs_vnops.c,v 1.7 1996/05/11 18:27:24 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_vnops.c	8.10 (Berkeley) 8/10/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/resourcevar.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/buf.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/signalvar.h>
#include <sys/pool.h>
#include <sys/event.h>
#include <sys/specdev.h>

#include <miscfs/fifofs/fifo.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ufs/ufs_extern.h>
#include <ufs/ufs/ufsmount.h>

#include <ufs/ffs/fs.h>
#include <ufs/ffs/ffs_extern.h>

struct vops ffs_vops = {
	.vop_lookup	= ufs_lookup,
	.vop_create	= ufs_create,
	.vop_mknod	= ufs_mknod,
	.vop_open	= ufs_open,
	.vop_close	= ufs_close,
	.vop_access	= ufs_access,
	.vop_getattr	= ufs_getattr,
	.vop_setattr	= ufs_setattr,
	.vop_read	= ffs_read,
	.vop_write	= ffs_write,
	.vop_ioctl	= ufs_ioctl,
	.vop_poll	= ufs_poll,
	.vop_kqfilter	= ufs_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= ffs_fsync,
	.vop_remove	= ufs_remove,
	.vop_link	= ufs_link,
	.vop_rename	= ufs_rename,
	.vop_mkdir	= ufs_mkdir,
	.vop_rmdir	= ufs_rmdir,
	.vop_symlink	= ufs_symlink,
	.vop_readdir	= ufs_readdir,
	.vop_readlink	= ufs_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= ufs_inactive,
	.vop_reclaim	= ffs_reclaim,
	.vop_lock	= ufs_lock,
	.vop_unlock	= ufs_unlock,
	.vop_bmap	= ufs_bmap,
	.vop_strategy	= ufs_strategy,
	.vop_print	= ufs_print,
	.vop_islocked	= ufs_islocked,
	.vop_pathconf	= ufs_pathconf,
	.vop_advlock	= ufs_advlock,
	.vop_bwrite	= vop_generic_bwrite
};

struct vops ffs_specvops = {
	.vop_close	= ufsspec_close,
	.vop_access	= ufs_access,
	.vop_getattr	= ufs_getattr,
	.vop_setattr	= ufs_setattr,
	.vop_read	= ufsspec_read,
	.vop_write	= ufsspec_write,
	.vop_fsync	= ffs_fsync,
	.vop_inactive	= ufs_inactive,
	.vop_reclaim	= ffs_reclaim,
	.vop_lock	= ufs_lock,
	.vop_unlock	= ufs_unlock,
	.vop_print	= ufs_print,
	.vop_islocked	= ufs_islocked,

	/* XXX: Keep in sync with spec_vops */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
};

#ifdef FIFO
struct vops ffs_fifovops = {
	.vop_close	= ufsfifo_close,
	.vop_access	= ufs_access,
	.vop_getattr	= ufs_getattr,
	.vop_setattr	= ufs_setattr,
	.vop_read	= ufsfifo_read,
	.vop_write	= ufsfifo_write,
	.vop_fsync	= ffs_fsync,
	.vop_inactive	= ufs_inactive,
	.vop_reclaim	= ffsfifo_reclaim,
	.vop_lock	= ufs_lock,
	.vop_unlock	= ufs_unlock,
	.vop_print	= ufs_print,
	.vop_islocked	= ufs_islocked,
	.vop_bwrite	= vop_generic_bwrite,

	/* XXX: Keep in sync with fifo_vops */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock
};
#endif /* FIFO */

/*
 * Vnode op for reading.
 */
int
ffs_read(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp;
	struct inode *ip;
	struct uio *uio;
	struct fs *fs;
	struct buf *bp;
	daddr_t lbn, nextlbn;
	off_t bytesinfile;
	int size, xfersize, blkoffset;
	mode_t mode;
	int error;

	vp = ap->a_vp;
	ip = VTOI(vp);
	mode = DIP(ip, mode);
	uio = ap->a_uio;

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_READ)
		panic("ffs_read: mode");

	if (vp->v_type == VLNK) {
		if (DIP(ip, size) < ip->i_ump->um_maxsymlinklen ||
		    (ip->i_ump->um_maxsymlinklen == 0 && DIP(ip, blocks) == 0))
			panic("ffs_read: short symlink");
	} else if (vp->v_type != VREG && vp->v_type != VDIR)
		panic("ffs_read: type %d", vp->v_type);
#endif
	fs = ip->i_fs;
	if (uio->uio_offset < 0)
		return (EINVAL);
	if (uio->uio_resid == 0)
		return (0);

	for (error = 0, bp = NULL; uio->uio_resid > 0; bp = NULL) {
		if ((bytesinfile = DIP(ip, size) - uio->uio_offset) <= 0)
			break;
		lbn = lblkno(fs, uio->uio_offset);
		nextlbn = lbn + 1;
		size = fs->fs_bsize;	/* WAS blksize(fs, ip, lbn); */
		blkoffset = blkoff(fs, uio->uio_offset);
		xfersize = fs->fs_bsize - blkoffset;
		if (uio->uio_resid < xfersize)
			xfersize = uio->uio_resid;
		if (bytesinfile < xfersize)
			xfersize = bytesinfile;

		if (lblktosize(fs, nextlbn) >= DIP(ip, size))
			error = bread(vp, lbn, size, &bp);
		else
			error = bread_cluster(vp, lbn, size, &bp);

		if (error)
			break;

		/*
		 * We should only get non-zero b_resid when an I/O error
		 * has occurred, which should cause us to break above.
		 * However, if the short read did not cause an error,
		 * then we want to ensure that we do not uiomove bad
		 * or uninitialized data.
		 */
		size -= bp->b_resid;
		if (size < xfersize) {
			if (size == 0)
				break;
			xfersize = size;
		}
		error = uiomove(bp->b_data + blkoffset, xfersize, uio);
		if (error)
			break;
		brelse(bp);
	}
	if (bp != NULL)
		brelse(bp);
	if (!(vp->v_mount->mnt_flag & MNT_NOATIME) ||
	    (ip->i_flag & (IN_CHANGE | IN_UPDATE))) {
		ip->i_flag |= IN_ACCESS;
	}
	return (error);
}

/*
 * Vnode op for writing.
 */
int
ffs_write(void *v)
{
	struct vop_write_args *ap = v;
	struct vnode *vp;
	struct uio *uio;
	struct inode *ip;
	struct fs *fs;
	struct buf *bp;
	daddr_t lbn;
	off_t osize;
	int blkoffset, error, extended, flags, ioflag, size, xfersize;
	size_t resid;
	ssize_t overrun;

	extended = 0;
	ioflag = ap->a_ioflag;
	uio = ap->a_uio;
	vp = ap->a_vp;
	ip = VTOI(vp);

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_WRITE)
		panic("ffs_write: mode");
#endif

	/*
	 * If writing 0 bytes, succeed and do not change
	 * update time or file offset (standards compliance)
	 */
	if (uio->uio_resid == 0)
		return (0);

	switch (vp->v_type) {
	case VREG:
		if (ioflag & IO_APPEND)
			uio->uio_offset = DIP(ip, size);
		if ((DIP(ip, flags) & APPEND) && uio->uio_offset != DIP(ip, size))
			return (EPERM);
		/* FALLTHROUGH */
	case VLNK:
		break;
	case VDIR:
		if ((ioflag & IO_SYNC) == 0)
			panic("ffs_write: nonsync dir write");
		break;
	default:
		panic("ffs_write: type");
	}

	fs = ip->i_fs;
	if (uio->uio_offset < 0 ||
	    (u_int64_t)uio->uio_offset + uio->uio_resid > fs->fs_maxfilesize)
		return (EFBIG);

	/* do the filesize rlimit check */
	if ((error = vn_fsizechk(vp, uio, ioflag, &overrun)))
		return (error);

	resid = uio->uio_resid;
	osize = DIP(ip, size);
	flags = ioflag & IO_SYNC ? B_SYNC : 0;

	for (error = 0; uio->uio_resid > 0;) {
		lbn = lblkno(fs, uio->uio_offset);
		blkoffset = blkoff(fs, uio->uio_offset);
		xfersize = fs->fs_bsize - blkoffset;
		if (uio->uio_resid < xfersize)
			xfersize = uio->uio_resid;
		if (fs->fs_bsize > xfersize)
			flags |= B_CLRBUF;
		else
			flags &= ~B_CLRBUF;

		if ((error = UFS_BUF_ALLOC(ip, uio->uio_offset, xfersize,
			 ap->a_cred, flags, &bp)) != 0)
			break;
		if (uio->uio_offset + xfersize > DIP(ip, size)) {
			DIP_ASSIGN(ip, size, uio->uio_offset + xfersize);
			uvm_vnp_setsize(vp, DIP(ip, size));
			extended = 1;
		}
		(void)uvm_vnp_uncache(vp);

		size = blksize(fs, ip, lbn) - bp->b_resid;
		if (size < xfersize)
			xfersize = size;

		error = uiomove(bp->b_data + blkoffset, xfersize, uio);

		if (error != 0)
			memset(bp->b_data + blkoffset, 0, xfersize);

#if 0
		if (ioflag & IO_NOCACHE)
			bp->b_flags |= B_NOCACHE;
#endif
		if (ioflag & IO_SYNC)
			(void)bwrite(bp);
		else if (xfersize + blkoffset == fs->fs_bsize) {
			bawrite(bp);
		} else
			bdwrite(bp);

		if (error || xfersize == 0)
			break;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	/*
	 * If we successfully wrote any data, and we are not the superuser
	 * we clear the setuid and setgid bits as a precaution against
	 * tampering.
	 */
	if (resid > uio->uio_resid && ap->a_cred && ap->a_cred->cr_uid != 0 &&
	    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0)
		DIP_ASSIGN(ip, mode, DIP(ip, mode) & ~(ISUID | ISGID));
	if (resid > uio->uio_resid)
		VN_KNOTE(vp, NOTE_WRITE | (extended ? NOTE_EXTEND : 0));
	if (error) {
		if (ioflag & IO_UNIT) {
			(void)UFS_TRUNCATE(ip, osize,
			    ioflag & IO_SYNC, ap->a_cred);
			uio->uio_offset -= resid - uio->uio_resid;
			uio->uio_resid = resid;
		}
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC)) {
		error = UFS_UPDATE(ip, 1);
	}
	/* correct the result for writes clamped by vn_fsizechk() */
	uio->uio_resid += overrun;
	return (error);
}

/*
 * Synch an open file.
 */
int
ffs_fsync(void *v)
{
	struct vop_fsync_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct buf *bp, *nbp;
	int s, error, passes, skipmeta;

	if (vp->v_type == VBLK &&
	    vp->v_specmountpoint != NULL &&
	    (vp->v_specmountpoint->mnt_flag & MNT_SOFTDEP))
		softdep_fsync_mountdev(vp, ap->a_waitfor);

	/*
	 * Flush all dirty buffers associated with a vnode.
	 */
	passes = NIADDR + 1;
	skipmeta = 0;
	if (ap->a_waitfor == MNT_WAIT)
		skipmeta = 1;
	s = splbio();
loop:
	for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp;
	     bp = LIST_NEXT(bp, b_vnbufs))
		bp->b_flags &= ~B_SCANNED;
	for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp; bp = nbp) {
		nbp = LIST_NEXT(bp, b_vnbufs);
		/* 
		 * Reasons to skip this buffer: it has already been considered
		 * on this pass, this pass is the first time through on a
		 * synchronous flush request and the buffer being considered
		 * is metadata, the buffer has dependencies that will cause
		 * it to be redirtied and it has not already been deferred,
		 * or it is already being written.
		 */
		if (bp->b_flags & (B_BUSY | B_SCANNED))
			continue;
		if ((bp->b_flags & B_DELWRI) == 0)
			panic("ffs_fsync: not dirty");
		if (skipmeta && bp->b_lblkno < 0)
			continue;
		if (ap->a_waitfor != MNT_WAIT &&
		    LIST_FIRST(&bp->b_dep) != NULL &&
		    (bp->b_flags & B_DEFERRED) == 0 &&
		    buf_countdeps(bp, 0, 1)) {
			bp->b_flags |= B_DEFERRED;
			continue;
		}

		bremfree(bp);
		buf_acquire(bp);
		bp->b_flags |= B_SCANNED;
		splx(s);
		/*
		 * On our final pass through, do all I/O synchronously
		 * so that we can find out if our flush is failing
		 * because of write errors.
		 */
		if (passes > 0 || ap->a_waitfor != MNT_WAIT)
			(void) bawrite(bp);
		else if ((error = bwrite(bp)) != 0)
			return (error);
		s = splbio();
		/*
		 * Since we may have slept during the I/O, we need
		 * to start from a known point.
		 */
		nbp = LIST_FIRST(&vp->v_dirtyblkhd);
	}
	if (skipmeta) {
		skipmeta = 0;
		goto loop;
	}
	if (ap->a_waitfor == MNT_WAIT) {
		vwaitforio(vp, 0, "ffs_fsync", 0);

		/*
		 * Ensure that any filesystem metadata associated
		 * with the vnode has been written.
		 */
		splx(s);
		if ((error = softdep_sync_metadata(ap)) != 0)
			return (error);
		s = splbio();
		if (!LIST_EMPTY(&vp->v_dirtyblkhd)) {
			/*
			 * Block devices associated with filesystems may
			 * have new I/O requests posted for them even if
			 * the vnode is locked, so no amount of trying will
			 * get them clean. Thus we give block devices a
			 * good effort, then just give up. For all other file
			 * types, go around and try again until it is clean.
			 */
			if (passes > 0) {
				passes -= 1;
				goto loop;
			}
#ifdef DIAGNOSTIC
			if (vp->v_type != VBLK)
				vprint("ffs_fsync: dirty", vp);
#endif
		}
	}
	splx(s);
	return (UFS_UPDATE(VTOI(vp), ap->a_waitfor == MNT_WAIT));
}

/*
 * Reclaim an inode so that it can be used for other purposes.
 */
int
ffs_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	int error;

	if ((error = ufs_reclaim(vp, ap->a_p)) != 0)
		return (error);

	if (ip->i_din1 != NULL) {
#ifdef FFS2
		if (ip->i_ump->um_fstype == UM_UFS2)
			pool_put(&ffs_dinode2_pool, ip->i_din2);
		else
#endif
			pool_put(&ffs_dinode1_pool, ip->i_din1);
	}

	pool_put(&ffs_ino_pool, ip);

	vp->v_data = NULL;

	return (0);
}

#ifdef FIFO
int
ffsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (ffs_reclaim(v));
}
#endif
@


1.87
log
@VOP_REALLOCBLKS() and related code is unused since the removal of
cluster_write().
ok beck zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.86 2016/04/07 11:13:01 mpi Exp $	*/
d385 2
a386 1
	if (resid > uio->uio_resid && ap->a_cred && ap->a_cred->cr_uid != 0)
@


1.86
log
@Always call bread_cluster() instead of calling it only if the current
logical block is contiguous to the previous one.

This logic is a left-over of the pre-bread_cluster() area.  When the
read-ahead version of bread(9) was used to prefetch blocks. Nowadays
bread_cluster() do the right thing (tm).

ok stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.85 2016/03/01 21:00:56 natano Exp $	*/
a95 1
	.vop_reallocblks = ffs_reallocblks,
@


1.85
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.84 2016/02/27 18:50:38 natano Exp $	*/
d237 1
a237 1
		else if (lbn - 1 == ip->i_ci.ci_lastr) {
a238 2
		} else
			error = bread(vp, lbn, size, &bp);
a241 1
		ip->i_ci.ci_lastr = lbn;
@


1.84
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.83 2016/02/26 08:56:10 natano Exp $	*/
d217 2
a218 3
	if ((u_int64_t)uio->uio_offset > fs->fs_maxfilesize)
		return (EFBIG);

@


1.83
log
@Convert mnt_maxsymlinklen to unsigned.

This allows to remove some truncating casts in symlink handling code.
Also, validate fs_maxsymlinklen in the superblock at mount time and on
fsck to make sure we don't use bogus data.

discussion & ok millert@@, stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.82 2016/02/16 17:56:12 stefan Exp $	*/
d210 2
a211 3
		if (DIP(ip, size) < vp->v_mount->mnt_maxsymlinklen ||
		    (vp->v_mount->mnt_maxsymlinklen == 0 &&
		     DIP(ip, blocks) == 0))
@


1.82
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.81 2016/01/12 11:41:00 mpi Exp $	*/
d210 1
a210 1
		if ((int)DIP(ip, size) < vp->v_mount->mnt_maxsymlinklen ||
@


1.81
log
@Remove the "doclusterread" and "doclusterwrite" buttons.

Cluster read is unconditionnally enabled for FFS since some years and
toggling "doclusterread" has no effect.

OpenBSD no longer support write clustering since the Dynamic Buffer
Cache went in, so there is reason to delay the call to bawrite(9).

Tested by Mathieu, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.80 2015/03/14 03:38:52 jsg Exp $	*/
d196 1
a196 1
	long size, xfersize, blkoffset;
d261 1
a261 1
		error = uiomovei(bp->b_data + blkoffset, (int)xfersize, uio);
d290 2
a291 1
	ssize_t resid, overrun;
d366 1
a366 2
		error =
		    uiomovei(bp->b_data + blkoffset, xfersize, uio);
@


1.80
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.79 2015/02/10 21:56:10 miod Exp $	*/
a182 6
 * Enabling cluster read/write operations.
 */
int doclusterread = 1;
int doclusterwrite = 1;

/*
d378 1
a378 4
			if (doclusterwrite)
				cluster_write(bp, &ip->i_ci, DIP(ip, size));
			else
				bawrite(bp);
@


1.79
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.78 2014/09/14 14:17:26 jsg Exp $	*/
a41 1
#include <sys/conf.h>
@


1.78
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.77 2014/07/08 17:19:26 deraadt Exp $	*/
d268 1
a268 1
		error = uiomove(bp->b_data + blkoffset, (int)xfersize, uio);
d373 1
a373 1
		    uiomove(bp->b_data + blkoffset, xfersize, uio);
@


1.77
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.76 2014/05/22 02:02:39 guenther Exp $	*/
a41 1
#include <sys/proc.h>
@


1.76
log
@From FreeBSD: the second argument to UFS_UPDATE/ffs_update is just a
boolean, not a MNT_* flag.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.75 2014/05/09 03:48:58 tedu Exp $	*/
a50 2

#include <uvm/uvm_extern.h>
@


1.75
log
@disable IO_NOCACHE B_NOCACHE conversion until it works.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.74 2014/04/08 18:48:41 beck Exp $	*/
d416 1
a416 1
		error = UFS_UPDATE(ip, MNT_WAIT);
@


1.74
log
@add IO_NOCACHE flag to vop_write arguments, which in turn sets B_NOCACHE
on the written buffers. Use the flag for writes from the page daemon to
ensure that we free buffers written out by the page daemon rather than
caching them.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.73 2013/12/12 19:00:10 tedu Exp $	*/
d381 1
d384 1
@


1.73
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.72 2013/09/14 02:28:02 guenther Exp $	*/
d381 2
@


1.72
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.71 2013/06/11 16:42:18 deraadt Exp $	*/
d271 1
a271 2
		error = uiomove((char *)bp->b_data + blkoffset, (int)xfersize,
				uio);
d376 1
a376 1
		    uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
d379 1
a379 1
			bzero((char *)bp->b_data + blkoffset, xfersize);
@


1.71
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.70 2013/01/16 22:41:47 beck Exp $	*/
d300 2
a301 2
	int blkoffset, error, extended, flags, ioflag, resid, size, xfersize;
	int overrun;
@


1.70
log
@re-backout the infamous softdep diff - originally committed to get around
the problem of the cleaner not being able to get softdep out of trouble
due to the removal of a reserve back in vienna.  Been run by me for a long
time and beat up, along with a bunch of others. Hopefully this nasty piece
of workaround can stay out for good now.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.69 2012/09/17 14:22:23 markus Exp $	*/
d204 1
a204 1
	daddr64_t lbn, nextlbn;
d298 1
a298 1
	daddr64_t lbn;
@


1.69
log
@fix uninitialized pointer in ffs_write(); ok guenther, beck, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.68 2012/07/11 12:39:20 guenther Exp $	*/
a297 1
	struct proc *p;
a301 1
	extern int num_indirdep, max_indirdep;
d368 1
a368 5
			/* Are we extending into an indirect block? */
			if (bp->b_lblkno < NDADDR)
				extended = 1;
			else
				extended = 2;
d412 2
a413 15
	} else if (resid > uio->uio_resid) {
		if (ioflag & IO_SYNC)
			error = UFS_UPDATE(ip, MNT_WAIT);
		if (DOINGSOFTDEP(vp) && num_indirdep > max_indirdep)
			if (extended > 1) {
				/*
				 * If the number of pending indirect block
				 * dependencies is sufficiently close to the
				 * maximum number of simultaneously mappable
				 * buffers force a sync on the vnode to prevent
				 * buffer cache exhaustion.
				 */
				p = uio->uio_procp;
				VOP_FSYNC(vp, NULL, MNT_WAIT, p);
			}
@


1.68
log
@If the current offset is strictly less than the process filesize
rlimit, then a write that would take it over the limit should be
clamped, making it a partial write.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.67 2011/08/16 14:36:39 thib Exp $	*/
d430 1
@


1.67
log
@Put back the pedro diff for VOP_FSYNC of softdep when its
limit is reached.

Added twist, clamp the max_softdeps to 64 as it is still
possible to exhaust bufkva.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.66 2011/08/03 20:21:19 beck Exp $	*/
d302 1
d344 4
a347 11
	/*
	 * Maybe this should be above the vnode op call, but so long as
	 * file servers have no limits, I don't think it matters.
	 */
	p = uio->uio_procp;
	if (vp->v_type == VREG && p && !(ioflag & IO_NOLIMIT) &&
	    uio->uio_offset + uio->uio_resid >
	    p->p_rlimit[RLIMIT_FSIZE].rlim_cur) {
		psignal(p, SIGXFSZ);
		return (EFBIG);
	}
d433 2
@


1.66
log
@back out pedro diff for VOP_FSYNC of softdep when limit is reached.

The basic analysys is correct, however, the problem in this case is that by forcing
softdept to synchornously flush everything across *all* softdep filesystems we cause a
huge performance problem when we take a 3 second pause and slam everything synchronously.

the right way to fix this is to fix the speedup_softdep code, not make the filesystem
go synchronous when we hit a limit - if we are doing that we may as well not run softdep
it will be faster.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.65 2011/07/04 20:35:35 deraadt Exp $	*/
d302 1
d376 5
a380 1
			extended = 1;
d424 14
a437 2
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC)) {
		error = UFS_UPDATE(ip, MNT_WAIT);
@


1.65
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.64 2011/07/04 04:30:41 tedu Exp $	*/
a301 1
	extern int num_indirdep, max_indirdep;
d375 1
a375 5
			/* Are we extending into an indirect block? */
			if (bp->b_lblkno < NDADDR)
				extended = 1;
			else
				extended = 2;
d419 2
a420 14
	} else if (resid > uio->uio_resid) {
		if (ioflag & IO_SYNC)
			error = UFS_UPDATE(ip, MNT_WAIT);
		if (DOINGSOFTDEP(vp) && num_indirdep > max_indirdep)
			if (extended > 1) {
				/*
				 * If the number of pending indirect block
				 * dependencies is sufficiently close to the
				 * maximum number of simultaneously mappable
				 * buffers force a sync on the vnode to prevent
				 * buffer cache exhaustion.
				 */
				VOP_FSYNC(vp, NULL, MNT_WAIT, p);
			}
@


1.64
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.63 2011/06/09 23:31:32 deraadt Exp $	*/
d50 1
a53 1
#include <miscfs/specfs/specdev.h>
@


1.63
log
@In ffs_write, do not deref to get the p_ucred for VOP_FSYNC (aka ffs_fsync)
when softdep runs out, since it does not use it.  In the nfsiod case, that
ucred is pointless, and ffs_fsync does not use it in any case.
This does not conflict with thib's plans moving forward
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.62 2011/04/12 19:45:43 beck Exp $	*/
d248 1
a248 1
			error = bread(vp, lbn, size, NOCRED, &bp);
d252 1
a252 1
			error = bread(vp, lbn, size, NOCRED, &bp);
@


1.62
log
@Avoid kvm starvation due to softdeps waiting on too many mapped buffers,
thus possibly consuming all of our available kva mapping buffers for
deps. Diff and analysis actually comes from Pedro Martelleto (thanks!)
tested by me and thib

ok thib@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.61 2011/04/05 14:14:07 thib Exp $	*/
d436 1
a436 1
				VOP_FSYNC(vp, p->p_ucred, MNT_WAIT, p);
@


1.61
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.60 2010/12/29 21:28:45 thib Exp $	*/
d302 1
d376 5
a380 1
			extended = 1;
d424 14
a437 2
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC)) {
		error = UFS_UPDATE(ip, MNT_WAIT);
@


1.60
log
@remove two unnecessary comments that snuck in with previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.59 2010/12/21 20:14:44 thib Exp $	*/
a65 1
	.vop_default	= eopnotsupp,
a104 1
	.vop_default	= eopnotsupp,
a145 1
	.vop_default	= eopnotsupp,
@


1.59
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.58 2010/09/10 16:34:09 thib Exp $	*/
a104 1
/* OK. Matches. */
a146 1
/* OK. Matches. */
@


1.58
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.57 2010/09/06 23:44:10 thib Exp $	*/
d65 38
a102 41
/* Global vfs data structures for ufs. */
int (**ffs_vnodeop_p)(void *);
struct vnodeopv_entry_desc ffs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, ufs_lookup },
	{ &vop_create_desc, ufs_create },
	{ &vop_mknod_desc, ufs_mknod },
	{ &vop_open_desc, ufs_open },
	{ &vop_close_desc, ufs_close },
	{ &vop_access_desc, ufs_access },
	{ &vop_getattr_desc, ufs_getattr },
	{ &vop_setattr_desc, ufs_setattr },
	{ &vop_read_desc, ffs_read },
	{ &vop_write_desc, ffs_write },
	{ &vop_ioctl_desc, ufs_ioctl },
	{ &vop_poll_desc, ufs_poll },
	{ &vop_kqfilter_desc, ufs_kqfilter },
	{ &vop_revoke_desc, ufs_revoke },
	{ &vop_fsync_desc, ffs_fsync },
	{ &vop_remove_desc, ufs_remove },
	{ &vop_link_desc, ufs_link },
	{ &vop_rename_desc, ufs_rename },
	{ &vop_mkdir_desc, ufs_mkdir },
	{ &vop_rmdir_desc, ufs_rmdir },
	{ &vop_symlink_desc, ufs_symlink },
	{ &vop_readdir_desc, ufs_readdir },
	{ &vop_readlink_desc, ufs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, ufs_inactive },
	{ &vop_reclaim_desc, ffs_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_bmap_desc, ufs_bmap },
	{ &vop_strategy_desc, ufs_strategy },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ &vop_pathconf_desc, ufs_pathconf },
	{ &vop_advlock_desc, ufs_advlock },
	{ &vop_reallocblks_desc, ffs_reallocblks },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
d105 40
a144 20
struct vnodeopv_desc ffs_vnodeop_opv_desc =
	{ &ffs_vnodeop_p, ffs_vnodeop_entries };

int (**ffs_specop_p)(void *);
struct vnodeopv_entry_desc ffs_specop_entries[] = {
	{ &vop_default_desc, spec_vnoperate },
	{ &vop_close_desc, ufsspec_close },
	{ &vop_access_desc, ufs_access },
	{ &vop_getattr_desc, ufs_getattr },
	{ &vop_setattr_desc, ufs_setattr },
	{ &vop_read_desc, ufsspec_read },
	{ &vop_write_desc, ufsspec_write },
	{ &vop_fsync_desc, ffs_fsync },
	{ &vop_inactive_desc, ufs_inactive },
	{ &vop_reclaim_desc, ffs_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ NULL, NULL }
a146 3
struct vnodeopv_desc ffs_specop_opv_desc =
	{ &ffs_specop_p, ffs_specop_entries };

d148 40
a187 18
int (**ffs_fifoop_p)(void *);
struct vnodeopv_entry_desc ffs_fifoop_entries[] = {
	{ &vop_default_desc, fifo_vnoperate },
	{ &vop_close_desc, ufsfifo_close },
	{ &vop_access_desc, ufs_access },
	{ &vop_getattr_desc, ufs_getattr },
	{ &vop_setattr_desc, ufs_setattr },
	{ &vop_read_desc, ufsfifo_read },
	{ &vop_write_desc, ufsfifo_write },
	{ &vop_fsync_desc, ffs_fsync },
	{ &vop_inactive_desc, ufs_inactive },
	{ &vop_reclaim_desc, ffsfifo_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a188 3

struct vnodeopv_desc ffs_fifoop_opv_desc =
	{ &ffs_fifoop_p, ffs_fifoop_entries };
@


1.57
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.56 2010/06/29 14:48:08 thib Exp $	*/
d65 41
a105 38
struct vops ffs_vops = {
	.vop_default	= eopnotsupp,
	.vop_lookup	= ufs_lookup,
	.vop_create	= ufs_create,
	.vop_mknod	= ufs_mknod,
	.vop_open	= ufs_open,
	.vop_close	= ufs_close,
	.vop_access	= ufs_access,
	.vop_getattr	= ufs_getattr,
	.vop_setattr	= ufs_setattr,
	.vop_read	= ffs_read,
	.vop_write	= ffs_write,
	.vop_ioctl	= ufs_ioctl,
	.vop_poll	= ufs_poll,
	.vop_kqfilter	= ufs_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= ffs_fsync,
	.vop_remove	= ufs_remove,
	.vop_link	= ufs_link,
	.vop_rename	= ufs_rename,
	.vop_mkdir	= ufs_mkdir,
	.vop_rmdir	= ufs_rmdir,
	.vop_symlink	= ufs_symlink,
	.vop_readdir	= ufs_readdir,
	.vop_readlink	= ufs_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= ufs_inactive,
	.vop_reclaim	= ffs_reclaim,
	.vop_lock	= ufs_lock,
	.vop_unlock	= ufs_unlock,
	.vop_bmap	= ufs_bmap,
	.vop_strategy	= ufs_strategy,
	.vop_print	= ufs_print,
	.vop_islocked	= ufs_islocked,
	.vop_pathconf	= ufs_pathconf,
	.vop_advlock	= ufs_advlock,
	.vop_reallocblks = ffs_reallocblks,
	.vop_bwrite	= vop_generic_bwrite
d108 20
a127 40
/* OK. Matches. */
struct vops ffs_specvops = {
	.vop_default	= eopnotsupp,
	.vop_close	= ufsspec_close,
	.vop_access	= ufs_access,
	.vop_getattr	= ufs_getattr,
	.vop_setattr	= ufs_setattr,
	.vop_read	= ufsspec_read,
	.vop_write	= ufsspec_write,
	.vop_fsync	= ffs_fsync,
	.vop_inactive	= ufs_inactive,
	.vop_reclaim	= ffs_reclaim,
	.vop_lock	= ufs_lock,
	.vop_unlock	= ufs_unlock,
	.vop_print	= ufs_print,
	.vop_islocked	= ufs_islocked,

	/* XXX: Keep in sync with spec_vops */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
d130 3
d134 18
a151 40
/* OK. Matches. */
struct vops ffs_fifovops = {
	.vop_default	= eopnotsupp,
	.vop_close	= ufsfifo_close,
	.vop_access	= ufs_access,
	.vop_getattr	= ufs_getattr,
	.vop_setattr	= ufs_setattr,
	.vop_read	= ufsfifo_read,
	.vop_write	= ufsfifo_write,
	.vop_fsync	= ffs_fsync,
	.vop_inactive	= ufs_inactive,
	.vop_reclaim	= ffsfifo_reclaim,
	.vop_lock	= ufs_lock,
	.vop_unlock	= ufs_unlock,
	.vop_print	= ufs_print,
	.vop_islocked	= ufs_islocked,
	.vop_bwrite	= vop_generic_bwrite,

	/* XXX: Keep in sync with fifo_vops */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock
d153 3
@


1.56
log
@remove lies. the arguments are actually used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.55 2009/08/13 15:00:14 jasper Exp $	*/
d65 38
a102 41
/* Global vfs data structures for ufs. */
int (**ffs_vnodeop_p)(void *);
struct vnodeopv_entry_desc ffs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, ufs_lookup },
	{ &vop_create_desc, ufs_create },
	{ &vop_mknod_desc, ufs_mknod },
	{ &vop_open_desc, ufs_open },
	{ &vop_close_desc, ufs_close },
	{ &vop_access_desc, ufs_access },
	{ &vop_getattr_desc, ufs_getattr },
	{ &vop_setattr_desc, ufs_setattr },
	{ &vop_read_desc, ffs_read },
	{ &vop_write_desc, ffs_write },
	{ &vop_ioctl_desc, ufs_ioctl },
	{ &vop_poll_desc, ufs_poll },
	{ &vop_kqfilter_desc, ufs_kqfilter },
	{ &vop_revoke_desc, ufs_revoke },
	{ &vop_fsync_desc, ffs_fsync },
	{ &vop_remove_desc, ufs_remove },
	{ &vop_link_desc, ufs_link },
	{ &vop_rename_desc, ufs_rename },
	{ &vop_mkdir_desc, ufs_mkdir },
	{ &vop_rmdir_desc, ufs_rmdir },
	{ &vop_symlink_desc, ufs_symlink },
	{ &vop_readdir_desc, ufs_readdir },
	{ &vop_readlink_desc, ufs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, ufs_inactive },
	{ &vop_reclaim_desc, ffs_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_bmap_desc, ufs_bmap },
	{ &vop_strategy_desc, ufs_strategy },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ &vop_pathconf_desc, ufs_pathconf },
	{ &vop_advlock_desc, ufs_advlock },
	{ &vop_reallocblks_desc, ffs_reallocblks },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
d105 40
a144 20
struct vnodeopv_desc ffs_vnodeop_opv_desc =
	{ &ffs_vnodeop_p, ffs_vnodeop_entries };

int (**ffs_specop_p)(void *);
struct vnodeopv_entry_desc ffs_specop_entries[] = {
	{ &vop_default_desc, spec_vnoperate },
	{ &vop_close_desc, ufsspec_close },
	{ &vop_access_desc, ufs_access },
	{ &vop_getattr_desc, ufs_getattr },
	{ &vop_setattr_desc, ufs_setattr },
	{ &vop_read_desc, ufsspec_read },
	{ &vop_write_desc, ufsspec_write },
	{ &vop_fsync_desc, ffs_fsync },
	{ &vop_inactive_desc, ufs_inactive },
	{ &vop_reclaim_desc, ffs_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ NULL, NULL }
a146 3
struct vnodeopv_desc ffs_specop_opv_desc =
	{ &ffs_specop_p, ffs_specop_entries };

d148 40
a187 18
int (**ffs_fifoop_p)(void *);
struct vnodeopv_entry_desc ffs_fifoop_entries[] = {
	{ &vop_default_desc, fifo_vnoperate },
	{ &vop_close_desc, ufsfifo_close },
	{ &vop_access_desc, ufs_access },
	{ &vop_getattr_desc, ufs_getattr },
	{ &vop_setattr_desc, ufs_setattr },
	{ &vop_read_desc, ufsfifo_read },
	{ &vop_write_desc, ufsfifo_write },
	{ &vop_fsync_desc, ffs_fsync },
	{ &vop_inactive_desc, ufs_inactive },
	{ &vop_reclaim_desc, ffsfifo_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a188 3

struct vnodeopv_desc ffs_fifoop_opv_desc =
	{ &ffs_fifoop_p, ffs_fifoop_entries };
@


1.55
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.54 2009/06/25 15:49:26 thib Exp $	*/
a166 1
/* ARGSUSED */
a399 1
/* ARGSUSED */
@


1.54
log
@backout the buf_acquire() does the bremfree() since all callers
where doing bremfree() befure calling buf_acquire().

This is causing us headache pinning down a bug that showed up
when deraadt@@ too cvs to current, and will have to be done
anyway as a preperation for backouts.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.52 2009/01/15 07:58:37 grange Exp $	*/
d69 35
a103 35
	{ &vop_lookup_desc, ufs_lookup },		/* lookup */
	{ &vop_create_desc, ufs_create },		/* create */
	{ &vop_mknod_desc, ufs_mknod },			/* mknod */
	{ &vop_open_desc, ufs_open },			/* open */
	{ &vop_close_desc, ufs_close },			/* close */
	{ &vop_access_desc, ufs_access },		/* access */
	{ &vop_getattr_desc, ufs_getattr },		/* getattr */
	{ &vop_setattr_desc, ufs_setattr },		/* setattr */
	{ &vop_read_desc, ffs_read },			/* read */
	{ &vop_write_desc, ffs_write },			/* write */
	{ &vop_ioctl_desc, ufs_ioctl },			/* ioctl */
	{ &vop_poll_desc, ufs_poll },			/* poll */
	{ &vop_kqfilter_desc, ufs_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, ufs_revoke },		/* revoke */
	{ &vop_fsync_desc, ffs_fsync },			/* fsync */
	{ &vop_remove_desc, ufs_remove },		/* remove */
	{ &vop_link_desc, ufs_link },			/* link */
	{ &vop_rename_desc, ufs_rename },		/* rename */
	{ &vop_mkdir_desc, ufs_mkdir },			/* mkdir */
	{ &vop_rmdir_desc, ufs_rmdir },			/* rmdir */
	{ &vop_symlink_desc, ufs_symlink },		/* symlink */
	{ &vop_readdir_desc, ufs_readdir },		/* readdir */
	{ &vop_readlink_desc, ufs_readlink },		/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },	/* abortop */
	{ &vop_inactive_desc, ufs_inactive },		/* inactive */
	{ &vop_reclaim_desc, ffs_reclaim },		/* reclaim */
	{ &vop_lock_desc, ufs_lock },			/* lock */
	{ &vop_unlock_desc, ufs_unlock },		/* unlock */
	{ &vop_bmap_desc, ufs_bmap },			/* bmap */
	{ &vop_strategy_desc, ufs_strategy },		/* strategy */
	{ &vop_print_desc, ufs_print },			/* print */
	{ &vop_islocked_desc, ufs_islocked },		/* islocked */
	{ &vop_pathconf_desc, ufs_pathconf },		/* pathconf */
	{ &vop_advlock_desc, ufs_advlock },		/* advlock */
	{ &vop_reallocblks_desc, ffs_reallocblks },	/* reallocblks */
d114 13
a126 13
	{ &vop_close_desc, ufsspec_close },		/* close */
	{ &vop_access_desc, ufs_access },		/* access */
	{ &vop_getattr_desc, ufs_getattr },		/* getattr */
	{ &vop_setattr_desc, ufs_setattr },		/* setattr */
	{ &vop_read_desc, ufsspec_read },		/* read */
	{ &vop_write_desc, ufsspec_write },		/* write */
	{ &vop_fsync_desc, ffs_fsync },			/* fsync */
	{ &vop_inactive_desc, ufs_inactive },		/* inactive */
	{ &vop_reclaim_desc, ffs_reclaim },		/* reclaim */
	{ &vop_lock_desc, ufs_lock },			/* lock */
	{ &vop_unlock_desc, ufs_unlock },		/* unlock */
	{ &vop_print_desc, ufs_print },			/* print */
	{ &vop_islocked_desc, ufs_islocked },		/* islocked */
d137 13
a149 13
	{ &vop_close_desc, ufsfifo_close },		/* close */
	{ &vop_access_desc, ufs_access },		/* access */
	{ &vop_getattr_desc, ufs_getattr },		/* getattr */
	{ &vop_setattr_desc, ufs_setattr },		/* setattr */
	{ &vop_read_desc, ufsfifo_read },		/* read */
	{ &vop_write_desc, ufsfifo_write },		/* write */
	{ &vop_fsync_desc, ffs_fsync },			/* fsync */
	{ &vop_inactive_desc, ufs_inactive },		/* inactive */
	{ &vop_reclaim_desc, ffsfifo_reclaim },		/* reclaim */
	{ &vop_lock_desc, ufs_lock },			/* lock */
	{ &vop_unlock_desc, ufs_unlock },		/* unlock */
	{ &vop_print_desc, ufs_print },			/* print */
	{ &vop_islocked_desc, ufs_islocked },		/* islocked */
@


1.53
log
@All caller of buf_acquire were doing bremfree before the call.
Just put it in the buf_acquire function.
oga@@ ok
@
text
@d451 1
@


1.52
log
@Use proper *_ASSIGN() macros in assigments instead of abusing rvalue macros.
No binary change.

ok tedu@@

My 1000th commit!
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.51 2008/06/12 06:58:40 deraadt Exp $	*/
a450 1
		bremfree(bp);
@


1.51
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.49 2008/06/10 20:14:37 beck Exp $	*/
d382 1
a382 1
		DIP(ip, mode) &= ~(ISUID | ISGID);
@


1.50
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.48 2008/05/08 17:45:45 thib Exp $	*/
d452 2
a453 1
		bp->b_flags |= B_BUSY | B_SCANNED;
@


1.49
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@d452 1
a452 2
		buf_acquire(bp);
		bp->b_flags |= B_SCANNED;
@


1.48
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.47 2008/01/05 19:49:26 otto Exp $	*/
d452 2
a453 1
		bp->b_flags |= B_BUSY | B_SCANNED;
@


1.47
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.46 2007/09/23 20:15:07 millert Exp $	*/
d68 1
a68 1
	{ &vop_default_desc, vn_default_error },
@


1.46
log
@Move notatime check from ffs_update() to ffs_read() and ufs_setattr().
Fixes a couple cases where atime was being updated even when the
filesystem was mounted with the noatime option.
Adapted from similar placement in FreeBSD and NetBSD.
Tested by myself and naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.45 2007/06/01 23:47:57 deraadt Exp $	*/
d272 1
a272 1
	daddr_t lbn;
@


1.45
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.44 2007/05/26 20:26:51 pedro Exp $	*/
d252 4
a255 1
	ip->i_flag |= IN_ACCESS;
@


1.44
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.43 2007/04/13 17:09:22 thib Exp $	*/
d171 1
a171 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d262 1
a262 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d402 1
a402 6
	struct vop_fsync_args /* {
		struct vnode *a_vp;
		struct ucred *a_cred;
		int a_waitfor;
		struct proc *a_p;
	} */ *ap = v;
d511 1
a511 4
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
@


1.43
log
@Move the declaration of VN_KNOTE() into vnode.h instead of having
multiple defines all over;

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.42 2007/02/26 11:25:23 pedro Exp $	*/
d217 1
a217 1
		size = blksize(fs, ip, lbn);
a226 3
		else if (doclusterread)
			error = cluster_read(vp, &ip->i_ci,
			    DIP(ip, size), lbn, size, NOCRED, &bp);
d228 1
a228 3
			int nextsize = blksize(fs, ip, nextlbn);
			error = breadn(vp, lbn,
			    size, &nextlbn, &nextsize, 1, NOCRED, &bp);
@


1.42
log
@Don't enforce RLIMIT_FSIZE on vnd(4) I/O operations, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.41 2007/01/16 17:52:18 thib Exp $	*/
a162 3

#define VN_KNOTE(vp, b) \
	KNOTE((struct klist *)&vp->v_selectinfo.vsi_selinfo.si_note, (b))
@


1.41
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.40 2007/01/13 17:41:55 thib Exp $	*/
d335 1
a335 1
	if (vp->v_type == VREG && p &&
@


1.40
log
@prettify some panic strings,
s/panic("%s: foo", "func")/panic("func: foo")

ok toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.39 2006/10/29 00:53:37 thib Exp $	*/
a78 1
	{ &vop_lease_desc, ufs_lease_check },		/* lease */
@


1.39
log
@LFS and FFS shared the same read and write vnops, through
the macro games in ufs_readwrite.c (LFS_READWRITE) now that
LFS has gone, make these functions ffs specific and move them
into ffs/ffs_vnops.c zapping ufs_readwrite.c in the process.
Also, remove lfs fields from the inode and ufsmount structs.

ok toby@@,deraadt@@,pedro@@
testing and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.38 2006/06/21 10:01:10 mickey Exp $	*/
d199 1
a199 1
		panic("%s: mode", "ffs_read");
d205 1
a205 1
			panic("%s: short symlink", "ffs_read");
d207 1
a207 1
		panic("%s: type %d", "ffs_read", vp->v_type);
d300 1
a300 1
		panic("%s: mode", "ffs_write");
d321 1
a321 1
			panic("%s: nonsync dir write", "ffs_write");
d324 1
a324 1
		panic("%s: type", "ffs_write");
@


1.38
log
@propagate the wait flag from fsync down to softdep_fsync_mountdev()
and do not perform synchronous sync there is no wait requested by
skipping the drain_output() call. this fixes a problem where
update kthread would sleep forever on some vnode since work is created
faster than it can be flushed. pedro@@ ok; tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.37 2006/03/31 12:33:33 pedro Exp $	*/
d49 1
d165 248
a412 1
#include <ufs/ufs/ufs_readwrite.c>
@


1.37
log
@Teach ffs_reclaim() to put FFS2 dinodes back into their pool
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.36 2005/12/17 13:56:01 pedro Exp $	*/
d186 1
a186 1
		softdep_fsync_mountdev(vp);
@


1.36
log
@Remove the 'on disk' inode (dinode) from the 'in memory' inode in UFS.
Instead of having the dinode inside the inode structure itself, we now
have just a pointer to it, and use a separate pool to allocate dinodes
as needed. Inspiration from FreeBSD, various testing for a while, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.35 2005/11/08 02:29:51 pedro Exp $	*/
d298 8
a305 2
	if (ip->i_din1 != NULL)
		pool_put(&ffs_dinode1_pool, ip->i_din1);
@


1.35
log
@Use ANSI function declarations and deregister, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.34 2005/07/03 20:14:02 drahn Exp $	*/
d291 2
a292 1
	register struct vnode *vp = ap->a_vp;
d297 6
a302 2
	/* XXX - same for for both mfs and ffs */
	pool_put(&ffs_ino_pool, vp->v_data);
d304 1
@


1.34
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.33 2005/05/28 02:02:50 pedro Exp $	*/
d107 1
d129 1
d153 1
d171 1
a171 2
ffs_fsync(v)
	void *v;
d285 1
a285 2
ffs_reclaim(v)
	void *v;
@


1.33
log
@ufs_whiteout() is now pointless, remove it, okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.32 2005/02/17 18:07:37 jfb Exp $	*/
a54 1
#include <ufs/ufs/extattr.h>
a104 4
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
a125 4
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
a148 4
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
@


1.32
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.31 2004/03/02 05:46:01 tedu Exp $	*/
a70 1
	{ &vop_whiteout_desc, ufs_whiteout },		/* whiteout */
@


1.31
log
@silly fifos aren't a real fs, so we have to be sure to call reclaim
in the host fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.30 2003/09/23 16:51:13 millert Exp $	*/
d302 1
a302 1
		sturct proc *a_p;
@


1.30
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.29 2003/06/02 23:28:23 millert Exp $	*/
d153 1
a153 1
	{ &vop_reclaim_desc, ffs_reclaim },		/* reclaim */
d314 9
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.28 2002/11/08 04:34:18 art Exp $	*/
d82 1
a82 1
	{ &vop_select_desc, ufs_select },		/* select */
@


1.29.2.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.29 2003/06/02 23:28:23 millert Exp $	*/
d153 1
a153 1
	{ &vop_reclaim_desc, ffsfifo_reclaim },		/* reclaim */
a313 9

#ifdef FIFO
int
ffsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (ffs_reclaim(v));
}
#endif
@


1.28
log
@Implement simple vnodeop inheritance for specfs and fifofs.

The inheritace is implemented by setting the default vnodeop to a
bypass op that repeats the operation on the spec/fifo vnodeop vector.
The overhead of one extra indirect function call is worth the cleanup
and improved correctness.

This actually solves a few bugs where some vnode ops were missing from
some vectors (like kqfilter or revoke). (and even more on the ubc
branch).

Inspired by the same thing done in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.27 2002/03/14 01:27:14 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.28.2.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.28 2002/11/08 04:34:18 art Exp $	*/
d157 1
a157 1
	{ &vop_reclaim_desc, ffsfifo_reclaim },		/* reclaim */
a317 9

#ifdef FIFO
int
ffsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (ffs_reclaim(v));
}
#endif
@


1.27
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.26 2002/02/22 20:37:46 drahn Exp $	*/
d122 1
a122 5
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, spec_lookup },		/* lookup */
	{ &vop_create_desc, spec_create },		/* create */
	{ &vop_mknod_desc, spec_mknod },		/* mknod */
	{ &vop_open_desc, spec_open },			/* open */
a128 5
	{ &vop_lease_desc, spec_lease_check },		/* lease */
	{ &vop_ioctl_desc, spec_ioctl },		/* ioctl */
	{ &vop_select_desc, spec_select },		/* select */
	{ &vop_kqfilter_desc, spec_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, spec_revoke },		/* revoke */
a129 9
	{ &vop_remove_desc, spec_remove },		/* remove */
	{ &vop_link_desc, spec_link },			/* link */
	{ &vop_rename_desc, spec_rename },		/* rename */
	{ &vop_mkdir_desc, spec_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, spec_rmdir },		/* rmdir */
	{ &vop_symlink_desc, spec_symlink },		/* symlink */
	{ &vop_readdir_desc, spec_readdir },		/* readdir */
	{ &vop_readlink_desc, spec_readlink },		/* readlink */
	{ &vop_abortop_desc, spec_abortop },		/* abortop */
a133 2
	{ &vop_bmap_desc, spec_bmap },			/* bmap */
	{ &vop_strategy_desc, spec_strategy },		/* strategy */
a135 4
	{ &vop_pathconf_desc, spec_pathconf },		/* pathconf */
	{ &vop_advlock_desc, spec_advlock },		/* advlock */
	{ &vop_reallocblks_desc, spec_reallocblks },	/* reallocblks */
	{ &vop_bwrite_desc, vop_generic_bwrite },
d148 1
a148 5
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, fifo_lookup },		/* lookup */
	{ &vop_create_desc, fifo_create },		/* create */
	{ &vop_mknod_desc, fifo_mknod },		/* mknod */
	{ &vop_open_desc, fifo_open },			/* open */
a154 5
	{ &vop_lease_desc, fifo_lease_check },		/* lease */
	{ &vop_ioctl_desc, fifo_ioctl },		/* ioctl */
	{ &vop_select_desc, fifo_select },		/* select */
	{ &vop_kqfilter_desc, fifo_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, fifo_revoke },		/* revoke */
a155 9
	{ &vop_remove_desc, fifo_remove },		/* remove */
	{ &vop_link_desc, fifo_link },			/* link */
	{ &vop_rename_desc, fifo_rename },		/* rename */
	{ &vop_mkdir_desc, fifo_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, fifo_rmdir },		/* rmdir */
	{ &vop_symlink_desc, fifo_symlink },		/* symlink */
	{ &vop_readdir_desc, fifo_readdir },		/* readdir */
	{ &vop_readlink_desc, fifo_readlink },		/* readlink */
	{ &vop_abortop_desc, fifo_abortop },		/* abortop */
a159 2
	{ &vop_bmap_desc, fifo_bmap },			/* bmap */
	{ &vop_strategy_desc, fifo_strategy },		/* strategy */
a161 3
	{ &vop_pathconf_desc, fifo_pathconf },		/* pathconf */
	{ &vop_advlock_desc, fifo_advlock },		/* advlock */
	{ &vop_reallocblks_desc, fifo_reallocblks },	/* reallocblks */
@


1.26
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.25 2001/12/19 08:58:07 art Exp $	*/
d70 1
a70 1
int (**ffs_vnodeop_p) __P((void *));
d120 1
a120 1
int (**ffs_specop_p) __P((void *));
d170 1
a170 1
int (**ffs_fifoop_p) __P((void *));
@


1.25
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.20 2001/11/06 19:53:21 miod Exp $	*/
d59 1
d111 5
a115 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void*)))NULL }
d160 4
d210 4
@


1.24
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.23 2001/12/10 02:19:34 art Exp $	*/
d110 1
a110 4
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_putpages_desc, genfs_putpages },
	{ &vop_mmap_desc, ufs_mmap },
	{ NULL, NULL }
a111 1

a231 1
	struct uvm_object *uobj;
d239 1
a239 1
	 * Flush all dirty data associated with a vnode.
a245 9

	if (vp->v_type == VREG) {
		uobj = &vp->v_uobj;
		simple_lock(&uobj->vmobjlock);
		(uobj->pgops->pgo_flush)(uobj, 0, 0, PGO_ALLPAGES|PGO_CLEANIT|
		    ((ap->a_waitfor == MNT_WAIT) ? PGO_SYNCIO : 0));
		simple_unlock(&uobj->vmobjlock);
	}

d284 1
a284 2
		else if ((error = bwrite(bp)) != 0) {
			printf("ffs_fsync: bwrite failed %d\n", error);
a285 1
		}
d328 1
a328 5
	
	error = (UFS_UPDATE(VTOI(vp), ap->a_waitfor == MNT_WAIT));
	if (error)
		printf("ffs_fsync: UFS_UPDATE failed. %d\n", error);
	return (error);
a350 20
}

/*
 * Return the last logical file offset that should be written for this file
 * if we're doing a write that ends at "size".
 */
void
ffs_gop_size(struct vnode *vp, off_t size, off_t *eobp)
{
	struct inode *ip = VTOI(vp);
	struct fs *fs = ip->i_fs;
	ufs_lbn_t olbn, nlbn;

	olbn = lblkno(fs, ip->i_ffs_size);
	nlbn = lblkno(fs, size);
	if (nlbn < NDADDR && olbn <= nlbn) {
		*eobp = fragroundup(fs, size);
	} else {
		*eobp = blkroundup(fs, size);
	}
@


1.24.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.24 2001/12/10 04:45:32 art Exp $	*/
d255 1
a255 2
		error = (uobj->pgops->pgo_put)(uobj, 0, 0,
		    PGO_ALLPAGES|PGO_CLEANIT|
d257 1
a257 3
		if (error) {
			return (error);
		}
a370 35
}

int
ffs_getpages(void *v)
{
	struct vop_getpages_args /* {
		struct vnode *a_vp;
		voff_t a_offset;
		struct vm_page **a_m;
		int *a_count;
		int a_centeridx;
		vm_prot_t a_access_type;
		int a_advice;
		int a_flags;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct fs *fs = ip->i_fs;
       
	/*
	 * don't allow a softdep write to create pages for only part of a block.
	 * the dependency tracking requires that all pages be in memory for
	 * a block involved in a dependency.
	 */

	if (ap->a_flags & PGO_OVERWRITE &&
	    (blkoff(fs, ap->a_offset) != 0 ||
	     blkoff(fs, *ap->a_count << PAGE_SHIFT) != 0) &&
	    DOINGSOFTDEP(ap->a_vp)) {
		if ((ap->a_flags & PGO_LOCKED) == 0) {
			simple_unlock(&vp->v_uobj.vmobjlock);
		}
		return EINVAL;
	}
	return genfs_getpages(v);
@


1.24.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.24.2.1 2002/02/02 03:28:26 art Exp $	*/
a58 1
#include <ufs/ufs/extattr.h>
d69 1
a69 1
int (**ffs_vnodeop_p)(void *);
a112 4
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
d119 1
a119 1
int (**ffs_specop_p)(void *);
a158 4
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
d165 1
a165 1
int (**ffs_fifoop_p)(void *);
a204 4
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
@


1.24.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.24.2.2 2002/06/11 03:32:50 art Exp $	*/
d127 4
d137 5
d143 9
d156 2
d160 4
a167 1
	SPEC_VNODEOP_DESCS,
d177 4
d187 5
d193 9
d207 1
d210 3
a217 1
	FIFO_VNODEOP_DESCS,
d249 1
d259 5
d266 4
a269 2
		simple_lock(&vp->v_interlock);
		error = VOP_PUTPAGES(vp, 0, 0, PGO_ALLPAGES | PGO_CLEANIT |
a275 6
	passes = NIADDR + 1;
	skipmeta = 0;
	if (ap->a_waitfor == MNT_WAIT)
		skipmeta = 1;
	s = splbio();

d277 2
a278 1
	LIST_FOREACH(bp, &vp->v_dirtyblkhd, b_vnbufs)
a330 1
		splx(s);
d336 1
d350 1
a350 1
				passes--;
d361 1
a361 2
	error = (UFS_UPDATE(VTOI(vp), ap->a_waitfor == MNT_WAIT ?
	    UPDATE_WAIT : 0));
d417 1
a417 1
			simple_unlock(&vp->v_interlock);
a421 54
}

int
ffs_putpages(void *v)
{
	struct vop_putpages_args /* {
		struct vnode *a_vp;
		voff_t a_offlo;
		voff_t a_offhi;
		int a_flags;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uvm_object *uobj = &vp->v_uobj;
	struct inode *ip = VTOI(vp);
	struct fs *fs = ip->i_fs;
	struct vm_page *pg;
	off_t off;
	ufs_lbn_t lbn;

	if (!DOINGSOFTDEP(vp) || (ap->a_flags & PGO_CLEANIT) == 0) {
		return genfs_putpages(v);
	}

	/*
	 * for softdep files, force the pages in a block to be written together.
	 * if we're the pagedaemon and we would have to wait for other pages,
	 * just fail the request.  the pagedaemon will pick a different page.
	 */

	ap->a_offlo &= ~fs->fs_qbmask;
	lbn = lblkno(fs, ap->a_offhi);
	ap->a_offhi = blkroundup(fs, ap->a_offhi);
	if (curproc == uvm.pagedaemon_proc) {
		for (off = ap->a_offlo; off < ap->a_offhi; off += PAGE_SIZE) {
			pg = uvm_pagelookup(uobj, off);

			/*
			 * we only have missing pages here because the
			 * calculation of offhi above doesn't account for
			 * fragments.  so once we see one missing page,
			 * the rest should be missing as well, but we'll
			 * check for the rest just to be paranoid.
			 */

			if (pg == NULL) {
				continue;
			}
			if (pg->flags & PG_BUSY) {
				simple_unlock(&uobj->vmobjlock);
				return EBUSY;
			}
		}
	}
	return genfs_putpages(v);
@


1.24.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 1
a126 1
	{ &vop_default_desc, spec_vnoperate },
d144 1
d153 1
a153 1
	{ &vop_default_desc, fifo_vnoperate },
d165 1
d173 1
@


1.24.2.5
log
@use vnode lock in place of inode lock, switch to genfs_lock
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.24.2.4 2003/05/19 22:38:11 tedu Exp $	*/
d56 1
a57 2
#include <miscfs/genfs/genfs.h>
#include <miscfs/specfs/specdev.h>
@


1.23
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.22 2001/12/04 22:44:32 art Exp $	*/
a109 1
	{ &vop_ballocn_desc, ffs_ballocn },
a111 1
	{ &vop_size_desc, ffs_size },
d159 1
a159 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d205 1
a205 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d377 2
a378 3
int
ffs_size(v)
	void *v;
d380 1
a380 6
	struct vop_size_args /* {
		struct vnode *a_vp;
		off_t a_size;
		off_t *a_eobp;
	} */ *ap = v;
	struct inode *ip = VTOI(ap->a_vp);
d385 1
a385 2
	nlbn = lblkno(fs, ap->a_size);

d387 1
a387 1
		*ap->a_eobp = fragroundup(fs, ap->a_size);
d389 1
a389 1
		*ap->a_eobp = blkroundup(fs, ap->a_size);
a390 1
	return 0;
@


1.22
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.21 2001/11/27 05:27:12 art Exp $	*/
d255 1
a255 1
		uobj = &vp->v_uvm.u_obj;
@


1.21
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.20 2001/11/06 19:53:21 miod Exp $	*/
d114 1
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.19 2001/09/10 08:48:42 gluk Exp $	*/
d110 5
a114 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void*)))NULL }
d116 1
d237 1
d245 1
a245 1
	 * Flush all dirty buffers associated with a vnode.
d252 9
d299 2
a300 1
		else if ((error = bwrite(bp)) != 0)
d302 1
d345 5
a349 1
	return (UFS_UPDATE(VTOI(vp), ap->a_waitfor == MNT_WAIT));
d372 28
@


1.19
log
@Mark buffers with dependencies as B_DEFERRED and skip them one time
when doing sync. From FreeBSD.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.18 2001/06/27 04:58:48 art Exp $	*/
a52 2

#include <vm/vm.h>
@


1.18
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.17 2001/06/23 02:07:55 csapuntz Exp $	*/
d254 8
d268 8
@


1.17
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.16 2001/03/22 00:11:36 art Exp $	*/
a55 1
#if defined(UVM)
a56 1
#endif
@


1.16
log
@Change the ffs inode allocation from using malloc to pool.
Saves approx. 256k memory on a GENERIC i386 and moves 670k out of kmem_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.15 2001/03/20 17:30:07 gluk Exp $	*/
a91 1
	{ &vop_mmap_desc, ufs_mmap },			/* mmap */
a92 1
	{ &vop_seek_desc, ufs_seek },			/* seek */
a111 3
	{ &vop_blkatoff_desc, ffs_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, ffs_valloc },		/* valloc */
	{ &vop_balloc_desc, ffs_balloc },		/* balloc */
a112 3
	{ &vop_vfree_desc, ffs_vfree },			/* vfree */
	{ &vop_truncate_desc, ffs_truncate },		/* truncate */
	{ &vop_update_desc, ffs_update },		/* update */
a136 1
	{ &vop_mmap_desc, spec_mmap },			/* mmap */
a137 1
	{ &vop_seek_desc, spec_seek },			/* seek */
a156 3
	{ &vop_vfree_desc, ffs_vfree },			/* vfree */
	{ &vop_blkatoff_desc, spec_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, spec_valloc },		/* valloc */
a157 3
	{ &vop_vfree_desc, ffs_vfree },			/* vfree */
	{ &vop_truncate_desc, spec_truncate },		/* truncate */
	{ &vop_update_desc, ffs_update },		/* update */
a182 1
	{ &vop_mmap_desc, fifo_mmap },			/* mmap */
a183 1
	{ &vop_seek_desc, fifo_seek },			/* seek */
a202 3
	{ &vop_vfree_desc, ffs_vfree },			/* vfree */
	{ &vop_blkatoff_desc, fifo_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, fifo_valloc },		/* valloc */
a203 3
	{ &vop_vfree_desc, ffs_vfree },			/* vfree */
	{ &vop_truncate_desc, fifo_truncate },		/* truncate */
	{ &vop_update_desc, ffs_update },		/* update */
a234 1
	struct timespec ts;
d316 1
a316 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	return (VOP_UPDATE(vp, &ts, &ts, ap->a_waitfor == MNT_WAIT));
@


1.15
log
@Make fsync a bit more reliable; From Free/NetBSD. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.14 2001/03/09 23:09:18 gluk Exp $	*/
d52 1
d268 1
a268 1
	 * Flush all dirty buffers associated with a vnode
d361 2
a362 2
	FREE(vp->v_data, VFSTOUFS(vp->v_mount)->um_devvp->v_tag == VT_MFS ?
	    M_MFSNODE : M_FFSNODE);
@


1.14
log
@fix comment,
convert spaces -> tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.13 2001/03/01 20:54:36 provos Exp $	*/
d269 1
a269 1
	passes = NIADDR;
d273 1
d275 6
a280 5
	s = splbio();
loop2:
	for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
		nbp = bp->b_vnbufs.le_next;
		if ((bp->b_flags & B_BUSY))
d287 1
a287 1
		bp->b_flags |= B_BUSY;
d290 3
a292 2
		 * Wait for I/O associated with indirect blocks to complete,
		 * since there is no way to quickly wait for them below.
d294 1
a294 1
		if (bp->b_vp == vp || ap->a_waitfor != MNT_WAIT)
d298 6
a303 1
		goto loop;
d307 1
a307 1
		goto loop2;
d320 1
a320 1
		if (vp->v_dirtyblkhd.lh_first) {
d331 1
a331 1
				goto loop2;
@


1.13
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.12 2001/02/24 19:07:10 csapuntz Exp $	*/
d90 1
a90 1
	{ &vop_revoke_desc, ufs_revoke },               /* revoke */
d115 1
a115 1
	{ &vop_balloc_desc, ffs_balloc },               /* balloc */
d166 1
a166 1
	{ &vop_vfree_desc, ffs_vfree },                 /* vfree */
d197 1
a197 1
	{ &vop_revoke_desc, fifo_revoke },              /* revoke */
d220 1
a220 1
	{ &vop_vfree_desc, ffs_vfree },                 /* vfree */
d266 1
a266 1
	/* 
d305 1
a305 1
		 * Ensure that any filesystem metatdata associated
d312 13
a324 13
                if (vp->v_dirtyblkhd.lh_first) {
                       /*
                        * Block devices associated with filesystems may
                        * have new I/O requests posted for them even if
                        * the vnode is locked, so no amount of trying will
                        * get them clean. Thus we give block devices a
                        * good effort, then just give up. For all other file
                        * types, go around and try again until it is clean.
                        */
                       if (passes > 0) {
                               passes -= 1;
                               goto loop2;
                       }
d326 2
a327 2
		       if (vp->v_type != VBLK)
			       vprint("ffs_fsync: dirty", vp);
d329 3
a331 3
                }
        }
        splx(s);
@


1.12
log
@

Cleanup of vnode interface continues. Get rid of VHOLD/HOLDRELE.
Change VM/UVM to use buf_replacevnode to change the vnode associated
with a buffer.

Addition v_bioflag for flags written in interrupt handlers
(and read at splbio, though not strictly necessary)

Add vwaitforio and use it instead of a while loop of v_numoutput.

Fix race conditions when manipulation vnode free list
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.11 2001/02/23 13:59:11 art Exp $	*/
d89 1
d142 2
a143 1
	{ &vop_revoke_desc, spec_revoke },      /* revoke */
d196 1
@


1.11
log
@Convert the sleep in ffs_fsync to a tsleep so we can get a good wmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.10 1999/12/05 08:30:38 art Exp $	*/
d299 2
a300 5
		while (vp->v_numoutput) {
			vp->v_flag |= VBWAIT;
			tsleep((caddr_t)&vp->v_numoutput, PRIBIO + 1,
			    "ffsfsync", 0);
		}
@


1.10
log
@Integrate the latest soft updates code.
From mckusick@@mckusick.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.9 1999/02/26 03:56:30 art Exp $	*/
d299 5
a303 4
                while (vp->v_numoutput) {
                        vp->v_flag |= VBWAIT;
                        sleep((caddr_t)&vp->v_numoutput, PRIBIO + 1);
                }
@


1.10.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.16 2001/03/22 00:11:36 art Exp $	*/
a51 1
#include <sys/pool.h>
d89 1
a89 2
	{ &vop_kqfilter_desc, ufs_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, ufs_revoke },		/* revoke */
d114 1
a114 1
	{ &vop_balloc_desc, ffs_balloc },		/* balloc */
d141 1
a141 2
	{ &vop_kqfilter_desc, spec_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, spec_revoke },		/* revoke */
d164 1
a164 1
	{ &vop_vfree_desc, ffs_vfree },			/* vfree */
d194 1
a194 2
	{ &vop_kqfilter_desc, fifo_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, fifo_revoke },		/* revoke */
d217 1
a217 1
	{ &vop_vfree_desc, ffs_vfree },			/* vfree */
d263 2
a264 2
	/*
	 * Flush all dirty buffers associated with a vnode.
d266 1
a266 1
	passes = NIADDR + 1;
d270 1
d272 4
a275 7
loop:
	for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp;
	     bp = LIST_NEXT(bp, b_vnbufs))
		bp->b_flags &= ~B_SCANNED;
	for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp; bp = nbp) {
		nbp = LIST_NEXT(bp, b_vnbufs);
		if (bp->b_flags & (B_BUSY | B_SCANNED))
d282 1
a282 1
		bp->b_flags |= B_BUSY | B_SCANNED;
d285 2
a286 3
		 * On our final pass through, do all I/O synchronously
		 * so that we can find out if our flush is failing
		 * because of write errors.
d288 1
a288 1
		if (passes > 0 || ap->a_waitfor != MNT_WAIT)
d292 1
a292 6
		s = splbio();
		/*
		 * Since we may have slept during the I/O, we need
		 * to start from a known point.
		 */
		nbp = LIST_FIRST(&vp->v_dirtyblkhd);
d296 1
a296 1
		goto loop;
d299 4
a302 2
		vwaitforio(vp, 0, "ffs_fsync", 0);

d304 1
a304 1
		 * Ensure that any filesystem metadata associated
d311 13
a323 13
		if (!LIST_EMPTY(&vp->v_dirtyblkhd)) {
			/*
			 * Block devices associated with filesystems may
			 * have new I/O requests posted for them even if
			 * the vnode is locked, so no amount of trying will
			 * get them clean. Thus we give block devices a
			 * good effort, then just give up. For all other file
			 * types, go around and try again until it is clean.
			 */
			if (passes > 0) {
				passes -= 1;
				goto loop;
			}
d325 2
a326 2
			if (vp->v_type != VBLK)
				vprint("ffs_fsync: dirty", vp);
d328 3
a330 3
		}
	}
	splx(s);
d351 2
a352 2
	/* XXX - same for for both mfs and ffs */
	pool_put(&ffs_ino_pool, vp->v_data);
@


1.10.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.10.2.1 2001/05/14 22:47:41 niklas Exp $	*/
d56 1
d58 1
d92 1
d94 1
d114 3
d118 3
d145 1
d147 1
d167 3
d171 3
d199 1
d201 1
d221 3
d225 3
d259 1
d341 2
a342 1
	return (UFS_UPDATE(VTOI(vp), ap->a_waitfor == MNT_WAIT));
@


1.10.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.10.2.2 2001/07/04 11:00:52 niklas Exp $	*/
a253 8
		/* 
		 * Reasons to skip this buffer: it has already been considered
		 * on this pass, this pass is the first time through on a
		 * synchronous flush request and the buffer being considered
		 * is metadata, the buffer has dependencies that will cause
		 * it to be redirtied and it has not already been deferred,
		 * or it is already being written.
		 */
a259 8
		if (ap->a_waitfor != MNT_WAIT &&
		    LIST_FIRST(&bp->b_dep) != NULL &&
		    (bp->b_flags & B_DEFERRED) == 0 &&
		    buf_countdeps(bp, 0, 1)) {
			bp->b_flags |= B_DEFERRED;
			continue;
		}

@


1.10.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 2
@


1.10.2.5
log
@Merge in -current
@
text
@d110 1
a110 5
	{ &vop_ballocn_desc, ffs_ballocn },
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_putpages_desc, genfs_putpages },
	{ &vop_size_desc, ffs_size },
	{ NULL, NULL }
a111 1

a231 1
	struct uvm_object *uobj;
d239 1
a239 1
	 * Flush all dirty data associated with a vnode.
a245 9

	if (vp->v_type == VREG) {
		uobj = &vp->v_uvm.u_obj;
		simple_lock(&uobj->vmobjlock);
		(uobj->pgops->pgo_flush)(uobj, 0, 0, PGO_ALLPAGES|PGO_CLEANIT|
		    ((ap->a_waitfor == MNT_WAIT) ? PGO_SYNCIO : 0));
		simple_unlock(&uobj->vmobjlock);
	}

d284 1
a284 2
		else if ((error = bwrite(bp)) != 0) {
			printf("ffs_fsync: bwrite failed %d\n", error);
a285 1
		}
d328 1
a328 5
	
	error = (UFS_UPDATE(VTOI(vp), ap->a_waitfor == MNT_WAIT));
	if (error)
		printf("ffs_fsync: UFS_UPDATE failed. %d\n", error);
	return (error);
a350 28
}

/*
 * Return the last logical file offset that should be written for this file
 * if we're doing a write that ends at "size".
 */
int
ffs_size(v)
	void *v;
{
	struct vop_size_args /* {
		struct vnode *a_vp;
		off_t a_size;
		off_t *a_eobp;
	} */ *ap = v;
	struct inode *ip = VTOI(ap->a_vp);
	struct fs *fs = ip->i_fs;
	ufs_lbn_t olbn, nlbn;

	olbn = lblkno(fs, ip->i_ffs_size);
	nlbn = lblkno(fs, ap->a_size);

	if (nlbn < NDADDR && olbn <= nlbn) {
		*ap->a_eobp = fragroundup(fs, ap->a_size);
	} else {
		*ap->a_eobp = blkroundup(fs, ap->a_size);
	}
	return 0;
@


1.10.2.6
log
@Merge in trunk
@
text
@a58 1
#include <ufs/ufs/extattr.h>
d110 4
a113 4
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
d116 1
d160 1
a160 5
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
	{ NULL, NULL }
d206 1
a206 5
#ifdef UFS_EXTATTR
	{ &vop_getextattr_desc, ufs_vop_getextattr },
	{ &vop_setextattr_desc, ufs_vop_setextattr },
#endif
	{ NULL, NULL }
d237 1
d245 1
a245 1
	 * Flush all dirty buffers associated with a vnode.
d252 9
d299 2
a300 1
		else if ((error = bwrite(bp)) != 0)
d302 1
d345 5
a349 1
	return (UFS_UPDATE(VTOI(vp), ap->a_waitfor == MNT_WAIT));
d372 28
@


1.10.2.7
log
@Merge in -current from roughly a week ago
@
text
@d70 1
a70 1
int (**ffs_vnodeop_p)(void *);
d120 1
a120 1
int (**ffs_specop_p)(void *);
d170 1
a170 1
int (**ffs_fifoop_p)(void *);
@


1.10.2.8
log
@Sync the SMP branch with 3.3
@
text
@d122 5
a126 1
	{ &vop_default_desc, spec_vnoperate },
d133 5
d139 9
d152 2
d156 4
d172 5
a176 1
	{ &vop_default_desc, fifo_vnoperate },
d183 5
d189 9
d202 2
d206 3
@


1.10.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.10.2.8 2003/03/28 00:08:47 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 1
a82 1
	{ &vop_poll_desc, ufs_poll },			/* poll */
@


1.10.2.11
log
@Merge with the trunk
@
text
@d153 1
a153 1
	{ &vop_reclaim_desc, ffsfifo_reclaim },		/* reclaim */
a313 9

#ifdef FIFO
int
ffsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (ffs_reclaim(v));
}
#endif
@


1.9
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.8 1998/11/12 04:30:02 csapuntz Exp $	*/
d257 5
@


1.8
log
@

Integrate latest soft updates patches for McKusick.

Integrate cleaner ffs mount code from FreeBSD. Most notably, this mount
code prevents you from mounting an unclean file system read-write.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.7 1998/08/06 19:35:07 csapuntz Exp $	*/
d54 4
@


1.7
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.6 1997/11/06 05:59:20 csapuntz Exp $	*/
d160 1
d213 1
d323 1
a323 4
	if ((error = VOP_UPDATE(vp, &ts, &ts, ap->a_waitfor == MNT_WAIT)) != 0)               return (error);
	if (DOINGSOFTDEP(vp) && ap->a_waitfor == MNT_WAIT)
		error = softdep_fsync(vp);
	return (error);
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.5 1997/10/06 20:21:38 deraadt Exp $	*/
d97 1
a97 1
	{ &vop_abortop_desc, ufs_abortop },		/* abortop */
d115 1
a115 1
	{ &vop_bwrite_desc, vn_bwrite },
d137 1
a137 1
	{ &vop_revoke_desc, spec_revoke },              /* revoke */
d166 1
a166 1
	{ &vop_bwrite_desc, vn_bwrite },
d218 1
a218 1
	{ &vop_bwrite_desc, vn_bwrite },
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vnops.c,v 1.3 1996/05/22 11:47:18 deraadt Exp $	*/
d85 1
d110 1
d137 1
d189 1
a224 1
#ifdef DEBUG
a227 1
#include <sys/sysctl.h>
a228 1
struct ctldebug debug11 = { "doclusterread", &doclusterread };
a229 6
struct ctldebug debug12 = { "doclusterwrite", &doclusterwrite };
#else
/* XXX for ufs_readwrite */
#define doclusterread 1
#define doclusterwrite 1
#endif
d247 2
a248 1
	register struct vnode *vp = ap->a_vp;
d250 1
d252 68
a319 1
	vflushbuf(vp, ap->a_waitfor == MNT_WAIT);
d321 4
a324 1
	return (VOP_UPDATE(ap->a_vp, &ts, &ts, ap->a_waitfor == MNT_WAIT));
d336 1
d341 1
a341 1
	if ((error = ufs_reclaim(vp)) != 0)
@


1.4
log
@VFS Lite2 Changes
@
text
@a84 1
	{ &vop_revoke_desc, ufs_revoke },               /* revoke */
a108 1
	{ &vop_balloc_desc, ffs_balloc },               /* balloc */
a134 1
	{ &vop_revoke_desc, spec_revoke },              /* revoke */
a185 1
	{ &vop_revoke_desc, fifo_revoke },              /* revoke */
d221 1
d225 1
d227 1
d229 6
d252 1
a252 2
	struct vnode *vp = ap->a_vp;
	struct buf *bp, *nbp;
a253 1
	int s, error, passes, skipmeta;
d255 1
a255 68
	/* 
	 * Flush all dirty buffers associated with a vnode
	 */
	passes = NIADDR;
	skipmeta = 0;
	if (ap->a_waitfor == MNT_WAIT)
		skipmeta = 1;
loop:
	s = splbio();
loop2:
	for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
		nbp = bp->b_vnbufs.le_next;
		if ((bp->b_flags & B_BUSY))
			continue;
		if ((bp->b_flags & B_DELWRI) == 0)
			panic("ffs_fsync: not dirty");
		if (skipmeta && bp->b_lblkno < 0)
			continue;
		bremfree(bp);
		bp->b_flags |= B_BUSY;
		splx(s);
		/*
		 * Wait for I/O associated with indirect blocks to complete,
		 * since there is no way to quickly wait for them below.
		 */
		if (bp->b_vp == vp || ap->a_waitfor != MNT_WAIT)
			(void) bawrite(bp);
		else if ((error = bwrite(bp)) != 0)
			return (error);
		goto loop;
	}
	if (skipmeta) {
		skipmeta = 0;
		goto loop2;
	}
	if (ap->a_waitfor == MNT_WAIT) {
                while (vp->v_numoutput) {
                        vp->v_flag |= VBWAIT;
                        sleep((caddr_t)&vp->v_numoutput, PRIBIO + 1);
                }
		/*
		 * Ensure that any filesystem metatdata associated
		 * with the vnode has been written.
		 */
		splx(s);
		if ((error = softdep_sync_metadata(ap)) != 0)
			return (error);
		s = splbio();
                if (vp->v_dirtyblkhd.lh_first) {
                       /*
                        * Block devices associated with filesystems may
                        * have new I/O requests posted for them even if
                        * the vnode is locked, so no amount of trying will
                        * get them clean. Thus we give block devices a
                        * good effort, then just give up. For all other file
                        * types, go around and try again until it is clean.
                        */
                       if (passes > 0) {
                               passes -= 1;
                               goto loop2;
                       }
#ifdef DIAGNOSTIC
		       if (vp->v_type != VBLK)
			       vprint("ffs_fsync: dirty", vp);
#endif
                }
        }
        splx(s);
d257 1
a257 4
	if ((error = VOP_UPDATE(vp, &ts, &ts, ap->a_waitfor == MNT_WAIT)) != 0)               return (error);
	if (DOINGSOFTDEP(vp) && ap->a_waitfor == MNT_WAIT)
		error = softdep_fsync(vp);
	return (error);
a268 1
		sturct proc *a_p;
d273 1
a273 1
	if ((error = ufs_reclaim(vp, ap->a_p)) != 0)
@


1.3
log
@Change VOP_UPDATE() semantics:
* Make 2nd and 3rd args timespecs, not timevals.
* Consistently pass a Boolean as the 4th arg (except in LFS).
Also, fix ffs_update() and lfs_update() to actually change the nsec fields.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
d110 1
d137 1
d189 1
a224 1
#ifdef DEBUG
a227 1
#include <sys/sysctl.h>
a228 1
struct ctldebug debug11 = { "doclusterread", &doclusterread };
a229 6
struct ctldebug debug12 = { "doclusterwrite", &doclusterwrite };
#else
/* XXX for ufs_readwrite */
#define doclusterread 1
#define doclusterwrite 1
#endif
d247 2
a248 1
	register struct vnode *vp = ap->a_vp;
d250 1
d252 68
a319 1
	vflushbuf(vp, ap->a_waitfor == MNT_WAIT);
d321 4
a324 1
	return (VOP_UPDATE(ap->a_vp, &ts, &ts, ap->a_waitfor == MNT_WAIT));
d336 1
d341 1
a341 1
	if ((error = ufs_reclaim(vp)) != 0)
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: ffs_vnops.c,v 1.6 1996/02/09 22:22:27 christos Exp $	*/
d253 1
a253 1
	struct timeval tv;
d256 2
a257 2
	tv = time;
	return (VOP_UPDATE(ap->a_vp, &tv, &tv, ap->a_waitfor == MNT_WAIT));
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ffs_vnops.c,v 1.5 1994/12/14 13:03:41 mycroft Exp $	*/
d51 1
d68 1
a68 1
int (**ffs_vnodeop_p)();
d114 1
a114 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d119 1
a119 1
int (**ffs_specop_p)();
d164 1
a164 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d170 1
a170 1
int (**ffs_fifoop_p)();
d215 1
a215 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d243 3
a245 1
ffs_fsync(ap)
d251 1
a251 2
	} */ *ap;
{
d264 3
a266 1
ffs_reclaim(ap)
d269 1
a269 2
	} */ *ap;
{
d273 1
a273 1
	if (error = ufs_reclaim(vp))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
