head	1.13;
access;
symbols
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.20
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.18
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.16
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2006.09.24.01.22.51;	author pedro;	state dead;
branches;
next	1.12;

1.12
date	2005.11.15.21.09.46;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.19.08.56.35;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.12.14.02.23;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.02.23.14.52.52;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	96.07.21.08.05.39;	author tholo;	state Exp;
branches
	1.5.16.1;
next	1.4;

1.4
date	96.07.01.07.41.49;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.14.04.39.13;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.13.21;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.33;	author deraadt;	state Exp;
branches;
next	;

1.5.16.1
date	2001.05.14.22.47.42;	author niklas;	state Exp;
branches;
next	1.5.16.2;

1.5.16.2
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.5.16.3;

1.5.16.3
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.5.16.4;

1.5.16.4
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	;

1.7.4.1
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.05.19.22.38.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Zap LFS, okay deraadt@@
@
text
@/*	$OpenBSD: lfs_bio.c,v 1.12 2005/11/15 21:09:46 miod Exp $	*/
/*	$NetBSD: lfs_bio.c,v 1.5 1996/02/09 22:28:49 christos Exp $	*/

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)lfs_bio.c	8.10 (Berkeley) 6/10/95
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/resourcevar.h>
#include <sys/mount.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/lfs/lfs.h>
#include <ufs/lfs/lfs_extern.h>

/*
 * LFS block write function.
 *
 * XXX
 * No write cost accounting is done.
 * This is almost certainly wrong for synchronous operations and NFS.
 */
int	lfs_allclean_wakeup;		/* Cleaner wakeup address. */
int	locked_queue_count;		/* XXX Count of locked-down buffers. */
int	lfs_writing;			/* Set if already kicked off a writer
					   because of buffer space */
/*
#define WRITE_THRESHOLD		((nbuf >> 2) - 10)
#define WAIT_THRESHOLD		((nbuf >> 1) - 10)
*/
#define WAIT_THRESHOLD          (nbuf - (nbuf >> 2) - 10)
#define WRITE_THRESHOLD         ((nbuf >> 1) - 10)
#define LFS_BUFWAIT	2

struct timeout wakeup_timeout;

int
lfs_bwrite(v)
	void *v;
{
	struct vop_bwrite_args /* {
		struct buf *a_bp;
	} */ *ap = v;
	register struct buf *bp = ap->a_bp;
	struct lfs *fs;
	struct inode *ip;
	int db, error, s;

	/*
	 * Set the delayed write flag and use reassignbuf to move the buffer
	 * from the clean list to the dirty one.
	 *
	 * Set the B_LOCKED flag and unlock the buffer, causing brelse to move
	 * the buffer onto the LOCKED free list.  This is necessary, otherwise
	 * getnewbuf() would try to reclaim the buffers using bawrite, which
	 * isn't going to work.
	 *
	 * XXX we don't let meta-data writes run out of space because they can
	 * come from the segment writer.  We need to make sure that there is
	 * enough space reserved so that there's room to write meta-data
	 * blocks.
	 */
	if (!(bp->b_flags & B_LOCKED)) {
		fs = VFSTOUFS(bp->b_vp->v_mount)->um_lfs;
		db = fragstodb(fs, numfrags(fs, bp->b_bcount));
		while (!LFS_FITS(fs, db) && !IS_IFILE(bp) &&
		    bp->b_lblkno > 0) {
			/* Out of space, need cleaner to run */
			wakeup(&lfs_allclean_wakeup);
			wakeup(&fs->lfs_nextseg);
			error = tsleep(&fs->lfs_avail, PCATCH | PUSER,
				       "cleaner", NULL);
			if (error) {
				brelse(bp);
				return (error);
			}
		}
		ip = VTOI((bp)->b_vp);
		if (!(ip->i_flag & IN_MODIFIED))
			++fs->lfs_uinodes;
		ip->i_flag |= IN_CHANGE | IN_MODIFIED | IN_UPDATE;
		fs->lfs_avail -= db;
		++locked_queue_count;
		bp->b_flags |= B_LOCKED;
		TAILQ_INSERT_TAIL(&bdirties, bp, b_synclist);
		bp->b_synctime = time_second + 30;
		s = splbio();
		if (TAILQ_FIRST(&bdirties) == bp) {
			if (timeout_triggered(&wakeup_timeout))
				timeout_del(&wakeup_timeout);
			if (!timeout_initialized(&wakeup_timeout))
				timeout_set(&wakeup_timeout, wakeup, &bdirties);
			timeout_add(&wakeup_timeout, 30 * hz);
		}
		bp->b_flags &= ~(B_READ | B_ERROR);
		buf_dirty(bp);
		splx(s);
	}
	brelse(bp);
	return (0);
}

/*
 * XXX
 * This routine flushes buffers out of the B_LOCKED queue when LFS has too
 * many locked down.  Eventually the pageout daemon will simply call LFS
 * when pages need to be reclaimed.  Note, we have one static count of locked
 * buffers, so we can't have more than a single file system.  To make this
 * work for multiple file systems, put the count into the mount structure.
 */
void
lfs_flush()
{
	register struct mount *mp;

#ifdef DOSTATS
	++lfs_stats.write_exceeded;
#endif
	if (lfs_writing)
		return;
	lfs_writing = 1;
	CIRCLEQ_FOREACH(mp, &mountlist, mnt_list) {
		/* The lock check below is to avoid races with unmount. */
		if (!strncmp(&mp->mnt_stat.f_fstypename[0], MOUNT_LFS, MFSNAMELEN) &&
		    (mp->mnt_flag & (MNT_RDONLY)) == 0 &&
		    !((((struct ufsmount *)mp->mnt_data))->ufsmount_u.lfs)->lfs_dirops ) {
			/*
			 * We set the queue to 0 here because we are about to
			 * write all the dirty buffers we have.  If more come
			 * in while we're writing the segment, they may not
			 * get written, so we want the count to reflect these
			 * new writes after the segwrite completes.
			 */
#ifdef DOSTATS
			++lfs_stats.flush_invoked;
#endif
			lfs_segwrite(mp, 0);
		}
	}
	lfs_writing = 0;
}

int
lfs_check(vp, blkno)
	struct vnode *vp;
	ufs_daddr_t blkno;
{
	int error;

	error = 0;
	if (incore(vp, blkno))
		return (0);
	if (locked_queue_count > WRITE_THRESHOLD)
		lfs_flush();

	/* If out of buffers, wait on writer */
	while (locked_queue_count > WAIT_THRESHOLD) {
#ifdef DOSTATS
	    ++lfs_stats.wait_exceeded;
#endif
	    error = tsleep(&locked_queue_count, PCATCH | PUSER, "buffers",
	        hz * LFS_BUFWAIT);
	}

	return (error);
}
@


1.12
log
@Only two `h' in threshold.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.11 2004/06/21 23:50:38 tholo Exp $	*/
@


1.11
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.10 2003/06/02 23:28:23 millert Exp $	*/
d65 2
a66 2
#define WRITE_THRESHHOLD	((nbuf >> 2) - 10)
#define WAIT_THRESHHOLD		((nbuf >> 1) - 10)
d68 2
a69 2
#define WAIT_THRESHHOLD         (nbuf - (nbuf >> 2) - 10)
#define WRITE_THRESHHOLD        ((nbuf >> 1) - 10)
d125 1
a125 1
		if (bdirties.tqh_first == bp) {
d159 1
a159 2
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist;
	     mp = mp->mnt_list.cqe_next) {
d190 1
a190 1
	if (locked_queue_count > WRITE_THRESHHOLD)
d194 1
a194 1
	while (locked_queue_count > WAIT_THRESHHOLD) {
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.9 2003/02/19 08:56:35 jmc Exp $	*/
d123 1
a123 1
		bp->b_synctime = time.tv_sec + 30;
@


1.9
log
@intial -> initial
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.8 2002/07/12 14:02:23 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Change the locking on the mountpoint slightly. Instead of using mnt_lock
to get shared locks for lookup and get the exclusive lock only with
LK_DRAIN on unmount and do the real exclusive locking with flags in
mnt_flags, we now use shared locks for lookup and an exclusive lock for
unmount.

This is accomplished by slightly changing the semantics of vfs_busy.
Old vfs_busy behavior:
 - with LK_NOWAIT set in flags, a shared lock was obtained if the
   mountpoint wasn't being unmounted, otherwise we just returned an error.
 - with no flags, a shared lock was obtained if the mountpoint was being
   unmounted, otherwise we slept until the unmount was done and returned
   an error.
LK_NOWAIT was used for sync(2) and some statistics code where it isn't really
critical that we get the correct results.
0 was used in fchdir and lookup where it's critical that we get the right
directory vnode for the filesystem root.

After this change vfs_busy keeps the same behavior for no flags and LK_NOWAIT.
But if some other flags are passed into it, they are passed directly
into lockmgr (actually LK_SLEEPFAIL is always added to those flags because
if we sleep for the lock, that means someone was holding the exclusive lock
and the exclusive lock is only held when the filesystem is being unmounted.

More changes:
 dounmount must now be called with the exclusive lock held. (before this
 the caller was supposed to hold the vfs_busy lock, but that wasn't always
 true).
 Zap some (now) unused mount flags.
And the highlight of this change:
 Add some vfs_busy calls to match some vfs_unbusy calls, especially in
 sys_mount. (lockmgr doesn't detect the case where we release a lock noone
 holds (it will do that soon)).

If you've seen hangs on reboot with mfs this should solve it (I repeat this
for the fourth time now, but this time I spent two months fixing and
redesigning this and reading the code so this time I must have gotten
this right).
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.7 2001/08/19 15:07:34 miod Exp $	*/
d132 1
a132 1
			if (!timeout_intialized(&wakeup_timeout))
@


1.7
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.6 2001/02/23 14:52:52 csapuntz Exp $	*/
d167 1
a167 1
		    (mp->mnt_flag & (MNT_MLOCK|MNT_RDONLY|MNT_UNMOUNT)) == 0 &&
@


1.7.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.7 2001/08/19 15:07:34 miod Exp $	*/
d167 1
a167 1
		    (mp->mnt_flag & (MNT_RDONLY)) == 0 &&
@


1.7.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
a132 1
			if (!timeout_initialized(&wakeup_timeout))
@


1.6
log
@

Change the B_DELWRI flag using buf_dirty and buf_undirty instead of
manually twiddling it. This allows the buffer cache to more easily
keep track of dirty buffers and decide when it is appropriate to speed
up the syncer.

Insipired by FreeBSD.
Look over by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.5 1996/07/21 08:05:39 tholo Exp $	*/
d47 1
d76 2
d130 5
a134 4
			untimeout((void (*)__P((void *)))wakeup,
				  &bdirties);
			timeout((void (*)__P((void *)))wakeup,
				&bdirties, 30 * hz);
@


1.5
log
@Ensure we never use more than one callout table slot
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.4 1996/07/01 07:41:49 downsj Exp $	*/
d122 1
a122 1
		bp->b_flags |= B_DELWRI | B_LOCKED;
d125 1
d133 1
a133 2
		s = splbio();
		reassignbuf(bp, bp->b_vp);
@


1.5.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.6 2001/02/23 14:52:52 csapuntz Exp $	*/
d122 1
a122 1
		bp->b_flags |= B_LOCKED;
a124 1
		s = splbio();
d132 2
a133 1
		buf_dirty(bp);
@


1.5.16.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.5.16.1 2001/05/14 22:47:42 niklas Exp $	*/
a46 1
#include <sys/timeout.h>
a74 2
struct timeout wakeup_timeout;

d127 4
a130 5
			if (timeout_triggered(&wakeup_timeout))
				timeout_del(&wakeup_timeout);
			if (!timeout_intialized(&wakeup_timeout))
				timeout_set(&wakeup_timeout, wakeup, &bdirties);
			timeout_add(&wakeup_timeout, 30 * hz);
@


1.5.16.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
a132 1
			if (!timeout_initialized(&wakeup_timeout))
d167 1
a167 1
		    (mp->mnt_flag & (MNT_RDONLY)) == 0 &&
@


1.5.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.5.16.3 2003/03/28 00:08:47 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4
log
@New LFS, based on Lite2.  Still being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.3 1996/06/14 04:39:13 tholo Exp $	*/
d125 3
a127 1
		if (bdirties.tqh_first == bp)
d130 1
@


1.3
log
@Keep dirty list used by in-kernel update(8) in sync with buffers
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_bio.c,v 1.2 1996/02/27 07:13:21 niklas Exp $	*/
d36 1
a36 1
 *	@@(#)lfs_bio.c	8.4 (Berkeley) 12/30/93
d85 1
a85 1
	int error, s;
d103 2
a104 1
		while (!LFS_FITS(fs, fsbtodb(fs, 1)) && !IS_IFILE(bp) &&
d108 1
d120 1
a120 1
		fs->lfs_avail -= fsbtodb(fs, 1);
d181 1
a181 1
	daddr_t blkno;
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 5
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: lfs_bio.c,v 1.4 1995/06/18 14:48:33 cgd Exp $	*/
d40 1
d51 1
d76 3
a78 1
lfs_bwrite(ap)
d81 1
a81 2
	} */ *ap;
{
d107 3
a109 2
			if (error = tsleep(&fs->lfs_avail, PCATCH | PUSER,
			    "cleaner", NULL)) {
a175 1
	extern int lfs_allclean_wakeup;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
