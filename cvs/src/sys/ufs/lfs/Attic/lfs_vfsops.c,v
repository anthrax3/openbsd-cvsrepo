head	1.24;
access;
symbols
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.13.0.6
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2006.09.24.01.22.51;	author pedro;	state dead;
branches;
next	1.23;

1.23
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.06.00.24.17;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.03.20.14.02;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.04.08.06.05;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.27.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.20.01.50.12;	author assar;	state Exp;
branches
	1.13.6.1;
next	1.12;

1.12
date	2000.02.07.04.57.18;	author assar;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.05.31.17.34.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.01.11.05.12.39;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.05.59.22;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.06.20.14.04.33;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.05.30.08.34.48;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.07.01.07.41.55;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.27.06.42.07;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.24.03.35.02;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.32.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.13.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.34;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2001.05.14.22.47.42;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2004.02.19.11.01.42;	author niklas;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2004.06.05.23.13.11;	author niklas;	state Exp;
branches;
next	;

1.13.6.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Zap LFS, okay deraadt@@
@
text
@/*	$OpenBSD: lfs_vfsops.c,v 1.23 2006/03/05 21:48:57 miod Exp $	*/
/*	$NetBSD: lfs_vfsops.c,v 1.11 1996/03/25 12:53:35 pk Exp $	*/

/*
 * Copyright (c) 1989, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)lfs_vfsops.c	8.20 (Berkeley) 6/10/95
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/mbuf.h>
#include <sys/file.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/socket.h>

#include <miscfs/specfs/specdev.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/lfs/lfs.h>
#include <ufs/lfs/lfs_extern.h>

int lfs_mountfs(struct vnode *, struct mount *, struct proc *);

const struct vfsops lfs_vfsops = {
	lfs_mount,
	ufs_start,
	lfs_unmount,
	ufs_root,
	ufs_quotactl,
	lfs_statfs,
	lfs_sync,
	lfs_vget,
	lfs_fhtovp,
	lfs_vptofh,
	lfs_init,
	lfs_sysctl,
	ufs_check_export
};

int
lfs_mountroot()
{
	panic("lfs_mountroot");		/* XXX -- implement */
	return 0;
}

/*
 * VFS Operations.
 *
 * mount system call
 */
int
lfs_mount(mp, path, data, ndp, p)
	register struct mount *mp;
	char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
{
	struct vnode *devvp;
	struct ufs_args args;
	struct ufsmount *ump = NULL;
	register struct lfs *fs = NULL;				/* LFS */
	size_t size;
	int error;
	mode_t accessmode;

	error = copyin(data, (caddr_t)&args, sizeof (struct ufs_args));
	if (error)
		return (error);

	/* Until LFS can do NFS right.		XXX */
	if (args.export_info.ex_flags & MNT_EXPORTED)
		return (EINVAL);

	/*
	 * If updating, check whether changing from read-only to
	 * read/write; if there is no device name, that's all we do.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		ump = VFSTOUFS(mp);
		if (fs->lfs_ronly && (mp->mnt_flag & MNT_WANTRDWR)) {
			/*
			 * If upgrade to read-write by non-root, then verify
			 * that user has necessary permissions on the device.
			 */
			if (p->p_ucred->cr_uid != 0) {
				vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
				error = VOP_ACCESS(ump->um_devvp, VREAD|VWRITE,
						   p->p_ucred, p);
				if (error) {
					VOP_UNLOCK(ump->um_devvp, 0, p);
					return (error);
				}
				VOP_UNLOCK(ump->um_devvp, 0, p);
			}
			fs->lfs_ronly = 0;
		}
		if (args.fspec == 0) {
			/*
			 * Process export requests.
			 */
			return (vfs_export(mp, &ump->um_export, 
			    &args.export_info));
		}
	}
	/*
	 * Not an update, or updating the name: look up the name
	 * and verify that it refers to a sensible block device.
	 */
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_USERSPACE, args.fspec, p);
	if ((error = namei(ndp)) != 0)
		return (error);
	devvp = ndp->ni_vp;
	if (devvp->v_type != VBLK) {
		vrele(devvp);
		return (ENOTBLK);
	}
	if (major(devvp->v_rdev) >= nblkdev) {
		vrele(devvp);
		return (ENXIO);
	}
	/*
	 * If mount by non-root, then verify that user has necessary
	 * permissions on the device.
	 */
	if (p->p_ucred->cr_uid != 0) {
		accessmode = VREAD;
		if ((mp->mnt_flag & MNT_RDONLY) == 0)
			accessmode |= VWRITE;
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
		error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p);
		if (error) {
			vput(devvp);
			return (error);
		}
		VOP_UNLOCK(devvp, 0, p);
	}
	if ((mp->mnt_flag & MNT_UPDATE) == 0)
		error = lfs_mountfs(devvp, mp, p);		/* LFS */
	else {
		if (devvp != ump->um_devvp)
			error = EINVAL;	/* XXX needs translation */
		else
			vrele(devvp);
	}
	if (error) {
		vrele(devvp);
		return (error);
	}
	ump = VFSTOUFS(mp);
	fs = ump->um_lfs;					/* LFS */
#ifdef NOTLFS							/* LFS */
	(void) copyinstr(path, fs->fs_fsmnt, sizeof(fs->fs_fsmnt) - 1, &size);
	bzero(fs->fs_fsmnt + size, sizeof(fs->fs_fsmnt) - size);
	bcopy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
#else
	(void)copyinstr(path, fs->lfs_fsmnt, sizeof(fs->lfs_fsmnt) - 1, &size);
	bzero(fs->lfs_fsmnt + size, sizeof(fs->lfs_fsmnt) - size);
	bcopy(fs->lfs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
#endif
	(void) copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
	bcopy(&args, &mp->mnt_stat.mount_info.ufs_args, sizeof(args));
	return (0);
}

/*
 * Common code for mount and mountroot
 * LFS specific
 */
int
lfs_mountfs(devvp, mp, p)
	register struct vnode *devvp;
	struct mount *mp;
	struct proc *p;
{
	register struct lfs *fs;
	register struct ufsmount *ump;
	struct vnode *vp;
	struct buf *bp;
	struct partinfo dpart;
	dev_t dev;
	int error, i, ronly, size;
	struct ucred *cred;

	cred = p ? p->p_ucred : NOCRED;
	/*
	 * Disallow multiple mounts of the same device.
	 * Disallow mounting of a device that is currently in use
	 * (except for root, which might share swap device for miniroot).
	 * Flush out any old buffers remaining from a previous use.
	 */
	if ((error = vfs_mountedon(devvp)) != 0)
		return (error);
	if (vcount(devvp) > 1 && devvp != rootvp)
		return (EBUSY);
	if ((error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0)) != 0)
		return (error);

	ronly = (mp->mnt_flag & MNT_RDONLY) != 0;
	error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p);
	if (error)
		return (error);

	if (VOP_IOCTL(devvp, DIOCGPART, (caddr_t)&dpart, FREAD, cred, p) != 0)
		size = DEV_BSIZE;
	else {
		size = dpart.disklab->d_secsize;
#ifdef NEVER_USED
		dpart.part->p_fstype = FS_LFS;
		dpart.part->p_fsize = fs->lfs_fsize;	/* frag size */
		dpart.part->p_frag = fs->lfs_frag;	/* frags per block */
		dpart.part->p_cpg = fs->lfs_segshift;	/* segment shift */
#endif
	}

	/* Don't free random space on error. */
	bp = NULL;
	ump = NULL;

	/* Read in the superblock. */
	error = bread(devvp, LFS_LABELPAD / size, LFS_SBPAD, cred, &bp);
	if (error)
		goto out;
	fs = (struct lfs *)bp->b_data;

	/* Check the basics. */
	if (fs->lfs_magic != LFS_MAGIC || fs->lfs_bsize > MAXBSIZE ||
	    fs->lfs_bsize < sizeof(struct lfs)) {
		error = EFTYPE;
		goto out;
	}

	/* Allocate the mount structure, copy the superblock into it. */
	ump = (struct ufsmount *)malloc(sizeof *ump, M_UFSMNT, M_WAITOK);
	fs = ump->um_lfs = malloc(sizeof(struct lfs), M_UFSMNT, M_WAITOK);
	bcopy(bp->b_data, fs, sizeof(struct lfs));
	if (sizeof(struct lfs) < LFS_SBPAD)			/* XXX why? */
		bp->b_flags |= B_INVAL;
	brelse(bp);
	bp = NULL;

	/* Set up the I/O information */
	fs->lfs_iocount = 0;

	/* Set up the ifile and lock aflags */
	fs->lfs_doifile = 0;
	fs->lfs_writer = 0;
	fs->lfs_dirops = 0;
	fs->lfs_seglock = 0;

	/* Set the file system readonly/modify bits. */
	fs->lfs_ronly = ronly;
	if (ronly == 0)
		fs->lfs_fmod = 1;

	/* Initialize the mount structure. */
	dev = devvp->v_rdev;
	mp->mnt_data = (qaddr_t)ump;
	mp->mnt_stat.f_fsid.val[0] = (long)dev;
	mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_LFS);
	mp->mnt_maxsymlinklen = fs->lfs_maxsymlinklen;
	mp->mnt_flag |= MNT_LOCAL;
	ump->um_mountp = mp;
	ump->um_dev = dev;
	ump->um_devvp = devvp;
	ump->um_bptrtodb = 0;
	ump->um_seqinc = 1 << fs->lfs_fsbtodb;
	ump->um_nindir = fs->lfs_nindir;
	for (i = 0; i < MAXQUOTAS; i++)
		ump->um_quotas[i] = NULLVP;
	devvp->v_specflags |= SI_MOUNTEDON;

	/*
	 * We use the ifile vnode for almost every operation.  Instead of
	 * retrieving it from the hash table each time we retrieve it here,
	 * artificially increment the reference count and keep a pointer
	 * to it in the incore copy of the superblock.
	 */
	if ((error = VFS_VGET(mp, LFS_IFILE_INUM, &vp)) != 0)
		goto out;
	fs->lfs_ivnode = vp;
	VREF(vp);
	vput(vp);

	return (0);
out:
	if (bp)
		brelse(bp);
	(void)VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, cred, p);
	if (ump) {
		free(ump->um_lfs, M_UFSMNT);
		free(ump, M_UFSMNT);
		mp->mnt_data = (qaddr_t)0;
	}
	return (error);
}

/*
 * unmount system call
 */
int
lfs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
{
	register struct ufsmount *ump;
	register struct lfs *fs;
	int error, flags, ronly;

	flags = 0;
	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;

	ump = VFSTOUFS(mp);
	fs = ump->um_lfs;
#ifdef QUOTA
	if (mp->mnt_flag & MNT_QUOTA) {
		int i;
		error = vflush(mp, fs->lfs_ivnode, SKIPSYSTEM|flags);
		if (error)
			return (error);
		for (i = 0; i < MAXQUOTAS; i++) {
			if (ump->um_quotas[i] == NULLVP)
				continue;
			quotaoff(p, mp, i);
		}
		/*
		 * Here we fall through to vflush again to ensure
		 * that we have gotten rid of all the system vnodes.
		 */
	}
#endif
	if ((error = vflush(mp, fs->lfs_ivnode, flags)) != 0)
		return (error);
	fs->lfs_clean = 1;
	if ((error = VFS_SYNC(mp, 1, p->p_ucred, p)) != 0)
		return (error);
	if (!LIST_EMPTY(&fs->lfs_ivnode->v_dirtyblkhd))
		panic("lfs_unmount: still dirty blocks on ifile vnode");
	vrele(fs->lfs_ivnode);
	vgone(fs->lfs_ivnode);

	ronly = !fs->lfs_ronly;
	ump->um_devvp->v_specflags &= ~SI_MOUNTEDON;
	error = VOP_CLOSE(ump->um_devvp,
	    ronly ? FREAD : FREAD|FWRITE, NOCRED, p);
	vrele(ump->um_devvp);
	free(fs, M_UFSMNT);
	free(ump, M_UFSMNT);
	mp->mnt_data = (qaddr_t)0;
	mp->mnt_flag &= ~MNT_LOCAL;
	return (error);
}

/*
 * Get file system statistics.
 */
int
lfs_statfs(mp, sbp, p)
	struct mount *mp;
	register struct statfs *sbp;
	struct proc *p;
{
	register struct lfs *fs;
	register struct ufsmount *ump;

	ump = VFSTOUFS(mp);
	fs = ump->um_lfs;
	if (fs->lfs_magic != LFS_MAGIC)
		panic("lfs_statfs: magic");
	sbp->f_type = 0;
	sbp->f_bsize = fs->lfs_bsize;
	sbp->f_iosize = fs->lfs_bsize;
	sbp->f_blocks = dbtofrags(fs,fs->lfs_dsize);
	sbp->f_bfree = dbtofrags(fs, fs->lfs_bfree);
	/*
	 * To compute the available space.  Subtract the minimum free
	 * from the total number of blocks in the file system.  Set avail
	 * to the smaller of this number and fs->lfs_bfree.
	 */
	sbp->f_bavail = fs->lfs_dsize * (100 - fs->lfs_minfree) / 100;
	sbp->f_bavail =
	    sbp->f_bavail > fs->lfs_bfree ? fs->lfs_bfree : sbp->f_bavail;
	sbp->f_bavail = dbtofrags(fs, sbp->f_bavail);
	sbp->f_files = fs->lfs_nfiles;
	sbp->f_ffree = sbp->f_bfree * INOPB(fs);
	if (sbp != &mp->mnt_stat) {
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
		bcopy(&mp->mnt_stat.mount_info.ufs_args,
		    &sbp->mount_info.ufs_args, sizeof(struct ufs_args));
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
	return (0);
}

/*
 * Go through the disk queues to initiate sandbagged IO;
 * go through the inodes to write those that have been modified;
 * initiate the writing of the super block if it has been modified.
 *
 * Should always be called with the mount point locked.
 */
int
lfs_sync(mp, waitfor, cred, p)
	struct mount *mp;
	int waitfor;
	struct ucred *cred;
	struct proc *p;
{
	int error;

	/* All syncs must be checkpoints until roll-forward is implemented. */
	error = lfs_segwrite(mp, SEGM_CKP | (waitfor ? SEGM_SYNC : 0));
#ifdef QUOTA
	qsync(mp);
#endif
	return (error);
}

/*
 * Look up an LFS dinode number to find its incore vnode.  If not already
 * in core, read it in from the specified device.  Return the inode locked.
 * Detection and handling of mount points must be done by the calling routine.
 */
int
lfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{
	register struct lfs *fs;
	register struct inode *ip;
	struct buf *bp;
	struct ifile *ifp;
	struct vnode *vp;
	struct ufsmount *ump;
	ufs_daddr_t daddr;
	dev_t dev;
	int error;

	ump = VFSTOUFS(mp);
	dev = ump->um_dev;
	if ((*vpp = ufs_ihashget(dev, ino)) != NULL)
		return (0);

	/* Translate the inode number to a disk address. */
	fs = ump->um_lfs;
	if (ino == LFS_IFILE_INUM)
		daddr = fs->lfs_idaddr;
	else {
		LFS_IENTRY(ifp, fs, ino, bp);
		daddr = ifp->if_daddr;
		brelse(bp);
		if (daddr == LFS_UNUSED_DADDR)
			return (ENOENT);
	}

	/* Allocate new vnode/inode. */
	if ((error = lfs_vcreate(mp, ino, &vp)) != 0) {
		*vpp = NULL;
		return (error);
	}

	/*
	 * Put it onto its hash chain and lock it so that other requests for
	 * this inode will block if they arrive while we are sleeping waiting
	 * for old data structures to be purged or for the contents of the
	 * disk portion of this inode to be read.
	 */
	ip = VTOI(vp);
	ufs_ihashins(ip);

	/*
	 * XXX
	 * This may not need to be here, logically it should go down with
	 * the i_devvp initialization.
	 * Ask Kirk.
	 */
	ip->i_lfs = ump->um_lfs;

	/* Read in the disk contents for the inode, copy into the inode. */
	error = bread(ump->um_devvp, daddr, (int)fs->lfs_bsize, NOCRED, &bp);
	if (error) {
		/*
		 * The inode does not contain anything useful, so it would
		 * be misleading to leave it on its hash chain. With mode
		 * still zero, it will be unlinked and returned to the free
		 * list by vput().
		 */
		vput(vp);
		brelse(bp);
		*vpp = NULL;
		return (error);
	}
	ip->i_din.ffs_din = *lfs_ifind(fs, ino, (struct dinode *)bp->b_data);
	brelse(bp);

	/*
	 * Initialize the vnode from the inode, check for aliases.  In all
	 * cases re-init ip, the underlying vnode/inode may have changed.
	 */
	error = ufs_vinit(mp, lfs_specop_p, LFS_FIFOOPS, &vp);
	if (error) {
		vput(vp);
		*vpp = NULL;
		return (error);
	}
	/*
	 * Finish inode initialization now that aliasing has been resolved.
	 */
	ip->i_devvp = ump->um_devvp;
	VREF(ip->i_devvp);
	*vpp = vp;
	return (0);
}

/*
 * File handle to vnode
 *
 * Have to be really careful about stale file handles:
 * - check that the inode number is valid
 * - call lfs_vget() to get the locked inode
 * - check for an unallocated inode (i_mode == 0)
 *
 * XXX
 * use ifile to see if inode is allocated instead of reading off disk
 * what is the relationship between my generational number and the NFS
 * generational number.
 */
int
lfs_fhtovp(mp, fhp, vpp)
	register struct mount *mp;
	struct fid *fhp;
	struct vnode **vpp;
{
	register struct ufid *ufhp;

	ufhp = (struct ufid *)fhp;
	if (ufhp->ufid_ino < ROOTINO)
		return (ESTALE);
	return (ufs_fhtovp(mp, ufhp, nam, vpp, exflagsp, credanonp));
}

/*
 * Vnode pointer to File handle
 */
/* ARGSUSED */
int
lfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
{
	register struct inode *ip;
	register struct ufid *ufhp;

	ip = VTOI(vp);
	ufhp = (struct ufid *)fhp;
	ufhp->ufid_len = sizeof(struct ufid);
	ufhp->ufid_ino = ip->i_number;
	ufhp->ufid_gen = ip->i_ffs1_gen;
	return (0);
}

/*
 * Initialize the filesystem, most work done by ufs_init.
 */
void
lfs_init()
{
	ufs_init();
}

/*
 * no sysctl for lfs
 */

int
lfs_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	return (EOPNOTSUPP);
}
@


1.23
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.22 2005/12/28 20:48:18 pedro Exp $	*/
@


1.22
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.21 2005/11/06 00:24:17 pedro Exp $	*/
d381 1
a381 1
	if (fs->lfs_ivnode->v_dirtyblkhd.lh_first)
@


1.21
log
@Replace obsolete comment with one that better describes reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.20 2005/07/03 20:14:02 drahn Exp $	*/
d604 1
a604 1
	ufhp->ufid_gen = ip->i_ffs_gen;
@


1.20
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.19 2004/06/04 08:06:05 tedu Exp $	*/
d445 1
a445 1
 * Note: we are always called with the filesystem marked `MPBUSY'.
@


1.19
log
@rootvp is already externed in systm.h, no need for a local extern
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.18 2003/08/14 07:46:40 mickey Exp $	*/
d76 1
a76 2
	ufs_check_export,
	vfs_stdextattrctl
@


1.18
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.17 2003/06/02 23:28:23 millert Exp $	*/
a218 1
	extern struct vnode *rootvp;
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.16 2002/04/23 18:54:12 espie Exp $	*/
d63 1
a63 1
struct vfsops lfs_vfsops = {
@


1.16
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.15 2002/03/14 01:27:15 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.14 2002/02/22 20:37:46 drahn Exp $	*/
d117 1
a117 1
	if (args.export.ex_flags & MNT_EXPORTED)
d147 2
a148 1
			return (vfs_export(mp, &ump->um_export, &args.export));
@


1.14
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.13 2001/02/20 01:50:12 assar Exp $	*/
d65 1
a65 1
int lfs_mountfs __P((struct vnode *, struct mount *, struct proc *));
@


1.13
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.12 2000/02/07 04:57:18 assar Exp $	*/
d80 2
a81 1
	ufs_check_export
@


1.13.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.13 2001/02/20 01:50:12 assar Exp $	*/
d65 1
a65 1
int lfs_mountfs(struct vnode *, struct mount *, struct proc *);
d80 1
a80 2
	ufs_check_export,
	vfs_stdextattrctl
d116 1
a116 1
	if (args.export_info.ex_flags & MNT_EXPORTED)
d146 1
a146 2
			return (vfs_export(mp, &ump->um_export, 
			    &args.export_info));
@


1.12
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.11 1999/05/31 17:34:55 millert Exp $	*/
d99 1
a99 1
	caddr_t data;
@


1.12.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.13 2001/02/20 01:50:12 assar Exp $	*/
d99 1
a99 1
	void *data;
@


1.12.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 2
	ufs_check_export,
	vfs_stdextattrctl
@


1.12.2.3
log
@Merge in -current from roughly a week ago
@
text
@d65 1
a65 1
int lfs_mountfs(struct vnode *, struct mount *, struct proc *);
@


1.12.2.4
log
@Sync the SMP branch with 3.3
@
text
@d117 1
a117 1
	if (args.export_info.ex_flags & MNT_EXPORTED)
d147 1
a147 2
			return (vfs_export(mp, &ump->um_export, 
			    &args.export_info));
@


1.12.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.12.2.4 2003/03/28 00:08:47 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 1
const struct vfsops lfs_vfsops = {
@


1.12.2.7
log
@Merge with the trunk
@
text
@d219 1
@


1.11
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.10 1999/01/11 05:12:39 millert Exp $	*/
d79 2
a571 2
 * - check that the given client host has export rights and return
 *   those rights via. exflagsp and credanonp
d579 1
a579 1
lfs_fhtovp(mp, fhp, nam, vpp, exflagsp, credanonp)
a581 1
	struct mbuf *nam;
a582 2
	int *exflagsp;
	struct ucred **credanonp;
d589 1
a589 1
	return (ufs_check_export(mp, ufhp, nam, vpp, exflagsp, credanonp));
d619 17
@


1.10
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.9 1997/11/06 05:59:22 csapuntz Exp $	*/
d205 1
d435 2
@


1.9
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.8 1997/06/20 14:04:33 kstailey Exp $	*/
d383 1
a383 1
		panic("lfs_unmount: still dirty blocks on ifile vnode\n");
@


1.8
log
@Change errno cause by mounting invalid filesystems from EINVAL to EFTYPE.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.7 1997/05/30 08:34:48 downsj Exp $	*/
a67 1
	MOUNT_LFS,
d129 1
a129 1
				VOP_LOCK(ump->um_devvp);
d133 1
a133 1
					VOP_UNLOCK(ump->um_devvp);
d136 1
a136 1
				VOP_UNLOCK(ump->um_devvp);
d171 1
a171 1
		VOP_LOCK(devvp);
d177 1
a177 1
		VOP_UNLOCK(devvp);
d435 1
a435 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
@


1.7
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.6 1996/07/01 07:41:55 downsj Exp $	*/
d184 1
a184 1
			error = EINVAL;	/* needs translation */
d273 1
a273 1
		error = EINVAL;		/* XXX needs translation */
@


1.6
log
@New LFS, based on Lite2.  Still being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.5 1996/06/27 06:42:07 downsj Exp $	*/
a81 8
static struct ufs_dirops xlfs_dirops = {
	ufs_dirremove,
	ufs_direnter,
	ufs_dirempty,
	ufs_dirrewrite,
	ufs_checkpath,
};

a312 1
	ump->um_dirops = &xlfs_dirops;
d539 1
a539 1
	ip->i_din = *lfs_ifind(fs, ino, (struct dinode *)bp->b_data);
d609 1
a609 1
	ufhp->ufid_gen = ip->i_gen;
@


1.5
log
@Moving some things around; struct inode still ends up bigger, though.
This should, hopefully, be the last UFS changes required.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.4 1996/06/24 03:35:02 downsj Exp $	*/
d36 1
a36 1
 *	@@(#)lfs_vfsops.c	8.10 (Berkeley) 11/21/94
d428 11
a438 5
	sbp->f_blocks = dbtofsb(fs,fs->lfs_dsize);
	sbp->f_bfree = dbtofsb(fs, fs->lfs_bfree);
	sbp->f_bavail = (fs->lfs_dsize * (100 - fs->lfs_minfree) / 100) -
		(fs->lfs_dsize - fs->lfs_bfree);
	sbp->f_bavail = dbtofsb(fs, sbp->f_bavail);
d490 1
a490 1
	daddr_t daddr;
d620 9
@


1.4
log
@ufs changes: add the notion of directory operators.

gnu/ext2fs: add the second extended filesystem.

Note that I'm commiting this now for the sake of the ufs changes; ext2fs
is not yet fully integrated into the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.3 1996/04/21 22:32:45 deraadt Exp $	*/
d82 1
a82 1
static struct ufs_dirops lfs_dirops = {
d321 1
a526 1
	ip->i_dirops = &lfs_dirops;
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_vfsops.c,v 1.2 1996/02/27 07:13:29 niklas Exp $	*/
d82 8
d526 1
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: lfs_vfsops.c,v 1.10 1996/02/09 22:28:58 christos Exp $	*/
d353 1
a353 1
	int i, error, flags, ronly;
d363 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: lfs_vfsops.c,v 1.9 1995/06/18 14:48:39 cgd Exp $	*/
d86 1
d94 1
d104 2
a105 2
	struct ufsmount *ump;
	register struct lfs *fs;				/* LFS */
d110 2
a111 1
	if (error = copyin(data, (caddr_t)&args, sizeof (struct ufs_args)))
d131 3
a133 2
				if (error = VOP_ACCESS(ump->um_devvp,
				    VREAD | VWRITE, p->p_ucred, p)) {
d153 1
a153 1
	if (error = namei(ndp))
d173 2
a174 1
		if (error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p)) {
d236 1
a236 1
	if (error = vfs_mountedon(devvp))
d240 1
a240 1
	if (error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0))
d244 2
a245 1
	if (error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p))
d265 2
a266 1
	if (error = bread(devvp, LFS_LABELPAD / size, LFS_SBPAD, cred, &bp))
d323 1
a323 1
	if (error = VFS_VGET(mp, LFS_IFILE_INUM, &vp))
d345 1
a350 1
	extern int doforce;
d363 2
a364 1
		if (error = vflush(mp, fs->lfs_ivnode, SKIPSYSTEM|flags))
d377 1
a377 1
	if (error = vflush(mp, fs->lfs_ivnode, flags))
d380 1
a380 1
	if (error = VFS_SYNC(mp, 1, p->p_ucred, p))
d402 1
d440 1
d496 1
a496 1
	if (error = lfs_vcreate(mp, ino, &vp)) {
d519 2
a520 2
	if (error =
	    bread(ump->um_devvp, daddr, (int)fs->lfs_bsize, NOCRED, &bp)) {
d539 2
a540 1
	if (error = ufs_vinit(mp, lfs_specop_p, LFS_FIFOOPS, &vp)) {
d590 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
