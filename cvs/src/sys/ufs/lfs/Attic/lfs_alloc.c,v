head	1.13;
access;
symbols
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.14
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.12
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2006.09.24.01.22.51;	author pedro;	state dead;
branches;
next	1.12;

1.12
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.15;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.01.11.05.12.38;	author millert;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	97.05.30.08.34.33;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.07.01.07.41.47;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.32.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.19.21.10.51;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.13.20;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.33;	author deraadt;	state Exp;
branches;
next	;

1.7.6.1
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Zap LFS, okay deraadt@@
@
text
@/*	$OpenBSD: lfs_alloc.c,v 1.12 2005/12/28 20:48:18 pedro Exp $	*/
/*	$NetBSD: lfs_alloc.c,v 1.4 1996/03/25 12:53:37 pk Exp $	*/

/*
 * Copyright (c) 1991, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)lfs_alloc.c	8.7 (Berkeley) 5/14/95
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/syslog.h>
#include <sys/mount.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/lfs/lfs.h>
#include <ufs/lfs/lfs_extern.h>

extern u_long nextgennumber;

/* Allocate a new inode. */
/* ARGSUSED */
int
lfs_valloc(v)
	void *v;
{
	struct vop_valloc_args /* {
		struct vnode *a_pvp;
		int a_mode;
		struct ucred *a_cred;
		struct vnode **a_vpp;
	} */ *ap = v;
	struct lfs *fs;
	struct buf *bp;
	struct ifile *ifp;
	struct inode *ip;
	struct vnode *vp;
	ufs_daddr_t blkno;
	ino_t new_ino;
	u_long i, max;
	int error;

	/* Get the head of the freelist. */
	fs = VTOI(ap->a_pvp)->i_lfs;
	new_ino = fs->lfs_free;
#ifdef ALLOCPRINT
	printf("lfs_ialloc: allocate inode %d\n", new_ino);
#endif

	/*
	 * Remove the inode from the free list and write the new start
	 * of the free list into the superblock.
	 */
	LFS_IENTRY(ifp, fs, new_ino, bp);
	if (ifp->if_daddr != LFS_UNUSED_DADDR)
		panic("lfs_ialloc: inuse inode on the free list");
	fs->lfs_free = ifp->if_nextfree;
	brelse(bp);

	/* Extend IFILE so that the next lfs_valloc will succeed. */
	if (fs->lfs_free == LFS_UNUSED_INUM) {
		vp = fs->lfs_ivnode;
		ip = VTOI(vp);
		blkno = lblkno(fs, DIP(ip, size));
		lfs_balloc(vp, 0, fs->lfs_bsize, blkno, &bp);
		DIP_ADD(ip, size, fs->lfs_bsize);
		vnode_pager_setsize(vp, (u_long) DIP(ip, size));
		vnode_pager_uncache(vp);

		i = (blkno - fs->lfs_segtabsz - fs->lfs_cleansz) *
		    fs->lfs_ifpb;
		fs->lfs_free = i;
		max = i + fs->lfs_ifpb;
		for (ifp = (struct ifile *)bp->b_data; i < max; ++ifp) {
			ifp->if_version = 1;
			ifp->if_daddr = LFS_UNUSED_DADDR;
			ifp->if_nextfree = ++i;
		}
		ifp--;
		ifp->if_nextfree = LFS_UNUSED_INUM;
		if ((error = VOP_BWRITE(bp)) != 0)
			return (error);
	}

	/* Create a vnode to associate with the inode. */
	if ((error = lfs_vcreate(ap->a_pvp->v_mount, new_ino, &vp)) != 0)
		return (error);


	ip = VTOI(vp);
	/* Zero out the direct and indirect block addresses. */
	bzero(&ip->i_din.ffs_din, sizeof(struct dinode));
	ip->i_din.ffs_din.di_inumber = new_ino;

	/* Set a new generation number for this inode. */
	if (++nextgennumber < (u_long)time_second)
		nextgennumber = time_second;
	DIP_ASSIGN(ip, gen, nextgennumber);

	/* Insert into the inode hash table. */
	ufs_ihashins(ip);

	error = ufs_vinit(vp->v_mount, lfs_specop_p, LFS_FIFOOPS, &vp);
	if (error) {
		vput(vp);
		*ap->a_vpp = NULL;
		return (error);
	}

	*ap->a_vpp = vp;
	vp->v_flag |= VDIROP;
	VREF(ip->i_devvp);

	/* Set superblock modified bit and increment file count. */
	fs->lfs_fmod = 1;
	++fs->lfs_nfiles;
	return (0);
}

/* Create a new vnode/inode pair and initialize what fields we can. */
int
lfs_vcreate(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{
	extern int (**lfs_vnodeop_p)(void *);
	struct inode *ip;
	struct ufsmount *ump;
	int error;
#ifdef QUOTA
	int i;
#endif

	/* Create the vnode. */
	if ((error = getnewvnode(VT_LFS, mp, lfs_vnodeop_p, vpp)) != 0) {
		*vpp = NULL;
		return (error);
	}

	/* Get a pointer to the private mount structure. */
	ump = VFSTOUFS(mp);

	/* Initialize the inode. */
	MALLOC(ip, struct inode *, sizeof(struct inode), M_LFSNODE, M_WAITOK);
	(*vpp)->v_data = ip;
	ip->i_vnode = *vpp;
	ip->i_devvp = ump->um_devvp;
	ip->i_flag = IN_MODIFIED;
	ip->i_dev = ump->um_dev;
	ip->i_number = ip->i_din.ffs_din.di_inumber = ino;
	ip->i_lfs = ump->um_lfs;
#ifdef QUOTA
	for (i = 0; i < MAXQUOTAS; i++)
		ip->i_dquot[i] = NODQUOT;
#endif
	ip->i_lockf = 0;
	ip->i_diroff = 0;
	ip->i_ffs1_mode = 0;
	ip->i_ffs1_size = 0;
	ip->i_ffs1_blocks = 0;
	++ump->um_lfs->lfs_uinodes;
	return (0);
}

/* Free an inode. */
/* ARGUSED */
int
lfs_vfree(v)
	void *v;
{
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap = v;
	SEGUSE *sup;
	struct buf *bp;
	struct ifile *ifp;
	struct inode *ip;
	struct lfs *fs;
	ufs_daddr_t old_iaddr;
	ino_t ino;

	/* Get the inode number and file system. */
	ip = VTOI(ap->a_pvp);
	fs = ip->i_lfs;
	ino = ip->i_number;
	if (ip->i_flag & IN_MODIFIED) {
		--fs->lfs_uinodes;
		ip->i_flag &=
		    ~(IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE);
	}
	/*
	 * Set the ifile's inode entry to unused, increment its version number
	 * and link it into the free chain.
	 */
	LFS_IENTRY(ifp, fs, ino, bp);
	old_iaddr = ifp->if_daddr;
	ifp->if_daddr = LFS_UNUSED_DADDR;
	++ifp->if_version;
	ifp->if_nextfree = fs->lfs_free;
	fs->lfs_free = ino;
	(void) VOP_BWRITE(bp);

	if (old_iaddr != LFS_UNUSED_DADDR) {
		LFS_SEGENTRY(sup, fs, datosn(fs, old_iaddr), bp);
#ifdef DIAGNOSTIC
		if (sup->su_nbytes < sizeof(struct dinode))
			panic("lfs_vfree: negative byte count (segment %d)",
			    datosn(fs, old_iaddr));
#endif
		sup->su_nbytes -= sizeof(struct dinode);
		(void) VOP_BWRITE(bp);
	}

	/* Set superblock modified bit and decrement file count. */
	fs->lfs_fmod = 1;
	--fs->lfs_nfiles;
	return (0);
}
@


1.12
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.11 2004/06/21 23:50:38 tholo Exp $	*/
@


1.11
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.10 2003/06/02 23:28:23 millert Exp $	*/
d100 1
a100 1
		blkno = lblkno(fs, ip->i_ffs_size);
d102 2
a103 2
		ip->i_ffs_size += fs->lfs_bsize;
		vnode_pager_setsize(vp, (u_long)ip->i_ffs_size);
d134 1
a134 1
	ip->i_ffs_gen = nextgennumber;
d195 3
a197 3
	ip->i_ffs_mode = 0;
	ip->i_ffs_size = 0;
	ip->i_ffs_blocks = 0;
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.9 2002/03/14 01:27:15 millert Exp $	*/
d132 2
a133 2
	if (++nextgennumber < (u_long)time.tv_sec)
		nextgennumber = time.tv_sec;
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.8 2001/11/06 19:53:21 miod Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.7 1999/01/11 05:12:38 millert Exp $	*/
d167 1
a167 1
	extern int (**lfs_vnodeop_p) __P((void *));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.8 2001/11/06 19:53:21 miod Exp $	*/
d167 1
a167 1
	extern int (**lfs_vnodeop_p)(void *);
@


1.7
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.6 1997/05/30 08:34:33 downsj Exp $	*/
d49 1
a49 1
#include <vm/vm.h>
@


1.7.6.1
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
#include <uvm/uvm_extern.h>
@


1.7.6.2
log
@Merge in -current from roughly a week ago
@
text
@d167 1
a167 1
	extern int (**lfs_vnodeop_p)(void *);
@


1.7.6.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.7.6.2 2002/03/28 14:54:26 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.5 1996/07/01 07:41:47 downsj Exp $	*/
d250 1
a250 1
			panic("lfs_vfree: negative byte count (segment %d)\n",
@


1.5
log
@New LFS, based on Lite2.  Still being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.4 1996/04/21 22:32:39 deraadt Exp $	*/
d104 1
a104 1
		blkno = lblkno(fs, ip->i_size);
d106 2
a107 2
		ip->i_size += fs->lfs_bsize;
		vnode_pager_setsize(vp, (u_long)ip->i_size);
d132 2
a133 2
	bzero(&ip->i_din, sizeof(struct dinode));
	ip->i_din.di_inumber = new_ino;
d138 1
a138 1
	ip->i_gen = nextgennumber;
d191 1
a191 1
	ip->i_number = ip->i_din.di_inumber = ino;
d199 3
a201 3
	ip->i_mode = 0;
	ip->i_size = 0;
	ip->i_blocks = 0;
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: lfs_alloc.c,v 1.3 1996/03/19 21:10:51 mickey Exp $	*/
d5 1
a5 1
 * Copyright (c) 1991, 1993
d36 1
a36 1
 *	@@(#)lfs_alloc.c	8.4 (Berkeley) 1/4/94
d78 1
a78 1
	daddr_t blkno;
d105 1
a105 1
		lfs_balloc(vp, fs->lfs_bsize, blkno, &bp);
a191 2
ip->i_din.di_spare[0] = 0xdeadbeef;
ip->i_din.di_spare[1] = 0xdeadbeef;
d222 1
a222 1
	daddr_t old_iaddr;
@


1.3
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 2
a2 2
/*	$OpenBSD: lfs_alloc.c,v 1.2 1996/02/27 07:13:20 niklas Exp $	*/
/*	$NetBSD: lfs_alloc.c,v 1.3 1996/02/09 22:28:47 christos Exp $	*/
d170 4
a173 1
	int error, i;
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: lfs_alloc.c,v 1.2 1994/06/29 06:46:47 cgd Exp $	*/
d40 1
d53 1
d63 3
a65 1
lfs_valloc(ap)
d71 1
a71 2
	} */ *ap;
{
d120 1
a120 1
		if (error = VOP_BWRITE(bp))
d125 1
a125 1
	if (error = lfs_vcreate(ap->a_pvp->v_mount, new_ino, &vp))
d142 2
a143 1
	if (error = ufs_vinit(vp->v_mount, lfs_specop_p, LFS_FIFOOPS, &vp)) {
d166 1
a166 1
	extern int (**lfs_vnodeop_p)();
d172 1
a172 1
	if (error = getnewvnode(VT_LFS, mp, lfs_vnodeop_p, vpp)) {
d207 3
a209 1
lfs_vfree(ap)
d214 1
a214 2
	} */ *ap;
{
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
