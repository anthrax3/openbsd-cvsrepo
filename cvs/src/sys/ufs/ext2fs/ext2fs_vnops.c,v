head	1.77;
access;
symbols
	OPENBSD_6_2:1.77.0.8
	OPENBSD_6_2_BASE:1.77
	OPENBSD_6_1:1.77.0.6
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.77.0.2
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.73.0.4
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.67.0.2
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.61.0.8
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.61.0.6
	OPENBSD_5_2_BASE:1.61
	OPENBSD_5_1_BASE:1.61
	OPENBSD_5_1:1.61.0.4
	OPENBSD_5_0:1.61.0.2
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.58.0.2
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.51.0.8
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.4
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.4
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.6
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.6
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.77
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.76;
commitid	gAjwyca5TfuoJAhn;

1.76
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.75;
commitid	gFybgYMymUyTbVeS;

1.75
date	2016.02.26.08.56.10;	author natano;	state Exp;
branches;
next	1.74;
commitid	1wcjndbWCkf5R7p2;

1.74
date	2016.02.16.17.56.12;	author stefan;	state Exp;
branches;
next	1.73;
commitid	6HMhQmvFL5xr8Rk9;

1.73
date	2015.04.17.04.43.21;	author guenther;	state Exp;
branches;
next	1.72;
commitid	zOwbm07fp3gPB2qr;

1.72
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.71;
commitid	p4LJxGKbi0BU2cG6;

1.71
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.70;
commitid	C5iGb36LQxjM60Q3;

1.70
date	2015.01.11.03.05.03;	author guenther;	state Exp;
branches;
next	1.69;
commitid	5gOXYWK6HwhlcEvO;

1.69
date	2014.12.29.05.29.28;	author miod;	state Exp;
branches;
next	1.68;
commitid	UbmX4MifiudCV4qQ;

1.68
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.67;
commitid	EkuwmBeHv2Tqmdnx;

1.67
date	2014.07.13.16.59.35;	author pelikan;	state Exp;
branches;
next	1.66;
commitid	zGe0z6RRYbZJpA8u;

1.66
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	EF98ch02VpFassUi;

1.65
date	2014.05.27.14.31.24;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.25.23.31.12;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2013.12.12.19.00.09;	author tedu;	state Exp;
branches;
next	1.62;

1.62
date	2013.03.28.03.29.44;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.03.18.23.10;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.09.10.37.04;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.02.02.03.22;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.09.23.38.37;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.23.20.15.07;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.17.20.15.25;	author jasper;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.10.17.47.56;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.09.12.43.17;	author pedro;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.14.22.03.01;	author pedro;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.11.20.46.28;	author pedro;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.14.12.41.44;	author pedro;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.28.22.37.39;	author pedro;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.03.20.14.01;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.30.13.58.55;	author niallo;	state Exp;
branches;
next	1.37;

1.37
date	2004.09.18.22.01.18;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.14.04.00.34;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.02.05.52.24;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.25.23.26.55;	author tedu;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2003.08.15.20.32.20;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.11.21.53.10;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.06.09.07.18;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.08.04.34.18;	author art;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.03.14.03.16.13;	author millert;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.12.04.22.44.32;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.26.20.24.47;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.26.02.10.41;	author assar;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.04.58.47;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.23.02.07.52;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.05.21.37.50;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.26.23.24.42;	author jasoni;	state Exp;
branches;
next	1.10;

1.10
date	99.02.26.16.35.33;	author millert;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	99.02.26.03.22.00;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.08.06.19.35.04;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	98.07.28.00.13.15;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.05.59.16;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.07.03.17.49.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.12.21.27.47;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.06.12.21.09.36;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.05.30.08.34.10;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.10.6.1
date	2001.05.14.22.47.39;	author niklas;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2001.07.04.11.00.45;	author niklas;	state Exp;
branches;
next	1.10.6.3;

1.10.6.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.10.6.4;

1.10.6.4
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.10.6.5;

1.10.6.5
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.10.6.6;

1.10.6.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.10.6.7;

1.10.6.7
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.10.6.8;

1.10.6.8
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.10.6.9;

1.10.6.9
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.10.6.10;

1.10.6.10
date	2004.02.19.11.01.36;	author niklas;	state Exp;
branches;
next	1.10.6.11;

1.10.6.11
date	2004.06.05.23.13.11;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.05.19.22.38.11;	author tedu;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2003.05.20.04.18.42;	author tedu;	state Exp;
branches;
next	;

1.24.4.1
date	2003.08.22.00.02.56;	author brad;	state Exp;
branches;
next	;

1.25.2.1
date	2003.08.21.23.36.36;	author brad;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2004.03.03.08.50.13;	author brad;	state Exp;
branches;
next	;

1.30.2.1
date	2004.03.03.08.32.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.77
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/*	$OpenBSD: ext2fs_vnops.c,v 1.76 2016/02/27 18:50:38 natano Exp $	*/
/*	$NetBSD: ext2fs_vnops.c,v 1.1 1997/06/11 09:34:09 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_vnops.c	8.14 (Berkeley) 10/26/94
 * Modified for ext2fs by Manuel Bouyer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/resourcevar.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lockf.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/signalvar.h>
#include <sys/specdev.h>
#include <sys/unistd.h>

#include <miscfs/fifofs/fifo.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufs_extern.h>
#include <ufs/ufs/ufsmount.h>

#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ext2fs/ext2fs_extern.h>
#include <ufs/ext2fs/ext2fs_dir.h>

#include <uvm/uvm_extern.h>

static int ext2fs_chmod(struct vnode *, mode_t, struct ucred *, struct proc *);
static int ext2fs_chown(struct vnode *, uid_t, gid_t, struct ucred *, struct proc *);

/*
 * Create a regular file
 */
int
ext2fs_create(void *v)
{
	struct vop_create_args *ap = v;
	return ext2fs_makeinode(MAKEIMODE(ap->a_vap->va_type,
					  ap->a_vap->va_mode),
			  	ap->a_dvp, ap->a_vpp, ap->a_cnp);
}

/*
 * Mknod vnode call
 */
/* ARGSUSED */
int
ext2fs_mknod(void *v)
{
	struct vop_mknod_args *ap = v;
	struct vattr *vap = ap->a_vap;
	struct vnode **vpp = ap->a_vpp;
	struct inode *ip;
	int error;

	if ((error =
		ext2fs_makeinode(MAKEIMODE(vap->va_type, vap->va_mode),
		ap->a_dvp, vpp, ap->a_cnp)) != 0)
		return (error);
	ip = VTOI(*vpp);
	ip->i_flag |= IN_ACCESS | IN_CHANGE | IN_UPDATE;
	if (vap->va_rdev != VNOVAL) {
		/*
		 * Want to be able to use this to make badblock
		 * inodes, so don't truncate the dev number.
		 */
		ip->i_e2din->e2di_rdev = htole32(vap->va_rdev);
	}
	/*
	 * Remove inode so that it will be reloaded by VFS_VGET and
	 * checked to see if it is an alias of an existing entry in
	 * the inode cache.
	 */
	vput(*vpp);
	(*vpp)->v_type = VNON;
	vgone(*vpp);
	*vpp = NULL;
	return (0);
}

/*
 * Open called.
 *
 * Just check the APPEND flag.
 */
/* ARGSUSED */
int
ext2fs_open(void *v)
{
	struct vop_open_args *ap = v;

	/*
	 * Files marked append-only must be opened for appending.
	 */
	if ((VTOI(ap->a_vp)->i_e2fs_flags & EXT2_APPEND) &&
		(ap->a_mode & (FWRITE | O_APPEND)) == FWRITE)
		return (EPERM);
	return (0);
}

int
ext2fs_access(void *v)
{
	struct vop_access_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	mode_t mode = ap->a_mode;

	/* If immutable bit set, nobody gets to write it. */
	if ((mode & VWRITE) && (ip->i_e2fs_flags & EXT2_IMMUTABLE))
		return (EPERM);

	return (vaccess(vp->v_type, ip->i_e2fs_mode, ip->i_e2fs_uid,
			ip->i_e2fs_gid, mode, ap->a_cred));
}

/* ARGSUSED */
int
ext2fs_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct vattr *vap = ap->a_vap;

	EXT2FS_ITIMES(ip);
	/*
	 * Copy from inode table
	 */
	vap->va_fsid = ip->i_dev;
	vap->va_fileid = ip->i_number;
	vap->va_mode = ip->i_e2fs_mode & ALLPERMS;
	vap->va_nlink = ip->i_e2fs_nlink;
	vap->va_uid = ip->i_e2fs_uid;
	vap->va_gid = ip->i_e2fs_gid;
	vap->va_rdev = (dev_t) letoh32(ip->i_e2din->e2di_rdev);
	vap->va_size = ext2fs_size(ip);
	vap->va_atime.tv_sec = ip->i_e2fs_atime;
	vap->va_atime.tv_nsec = 0;
	vap->va_mtime.tv_sec = ip->i_e2fs_mtime;
	vap->va_mtime.tv_nsec = 0;
	vap->va_ctime.tv_sec = ip->i_e2fs_ctime;
	vap->va_ctime.tv_nsec = 0;
#ifdef EXT2FS_SYSTEM_FLAGS
	vap->va_flags = (ip->i_e2fs_flags & EXT2_APPEND) ? SF_APPEND : 0;
	vap->va_flags |= (ip->i_e2fs_flags & EXT2_IMMUTABLE) ? SF_IMMUTABLE : 0;
#else
	vap->va_flags = (ip->i_e2fs_flags & EXT2_APPEND) ? UF_APPEND : 0;
	vap->va_flags |= (ip->i_e2fs_flags & EXT2_IMMUTABLE) ? UF_IMMUTABLE : 0;
#endif
	vap->va_gen = ip->i_e2fs_gen;
	/* this doesn't belong here */
	if (vp->v_type == VBLK)
		vap->va_blocksize = BLKDEV_IOSIZE;
	else if (vp->v_type == VCHR)
		vap->va_blocksize = MAXBSIZE;
	else
		vap->va_blocksize = vp->v_mount->mnt_stat.f_iosize;
	vap->va_bytes = dbtob((u_quad_t)ip->i_e2fs_nblock);
	vap->va_type = vp->v_type;
	vap->va_filerev = ip->i_modrev;
	return (0);
}

/*
 * Set attribute vnode op. called from several syscalls
 */
int
ext2fs_setattr(void *v)
{
	struct vop_setattr_args *ap = v;
	struct vattr *vap = ap->a_vap;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct ucred *cred = ap->a_cred;
	struct proc *p = ap->a_p;
	int error;

	/*
	 * Check for unsettable attributes.
	 */
	if ((vap->va_type != VNON) || (vap->va_nlink != VNOVAL) ||
		(vap->va_fsid != VNOVAL) || (vap->va_fileid != VNOVAL) ||
		(vap->va_blocksize != VNOVAL) || (vap->va_rdev != VNOVAL) ||
		((int)vap->va_bytes != VNOVAL) || (vap->va_gen != VNOVAL)) {
		return (EINVAL);
	}
	if (vap->va_flags != VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		if (cred->cr_uid != ip->i_e2fs_uid &&
			(error = suser_ucred(cred)))
			return (error);
#ifdef EXT2FS_SYSTEM_FLAGS
		if (cred->cr_uid == 0) {
			if ((ip->i_e2fs_flags &
			    (EXT2_APPEND | EXT2_IMMUTABLE)) && securelevel > 0)
				return (EPERM);
			ip->i_e2fs_flags &= ~(EXT2_APPEND | EXT2_IMMUTABLE);
			ip->i_e2fs_flags |=
			    (vap->va_flags & SF_APPEND) ? EXT2_APPEND : 0 |
			    (vap->va_flags & SF_IMMUTABLE) ? EXT2_IMMUTABLE: 0;
		} else {
			return (EPERM);
		}
#else
		ip->i_e2fs_flags &= ~(EXT2_APPEND | EXT2_IMMUTABLE);
		ip->i_e2fs_flags |=
		    (vap->va_flags & UF_APPEND) ? EXT2_APPEND : 0 |
		    (vap->va_flags & UF_IMMUTABLE) ? EXT2_IMMUTABLE: 0;
#endif
		ip->i_flag |= IN_CHANGE;
		if (vap->va_flags & (IMMUTABLE | APPEND))
			return (0);
	}
	if (ip->i_e2fs_flags & (EXT2_APPEND | EXT2_IMMUTABLE))
		return (EPERM);
	/*
	 * Go through the fields and update iff not VNOVAL.
	 */
	if (vap->va_uid != (uid_t)VNOVAL || vap->va_gid != (gid_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		error = ext2fs_chown(vp, vap->va_uid, vap->va_gid, cred, p);
		if (error)
			return (error);
	}
	if (vap->va_size != VNOVAL) {
		/*
		 * Disallow write attempts on read-only file systems;
		 * unless the file is a socket, fifo, or a block or
		 * character device resident on the file system.
		 */
		switch (vp->v_type) {
		case VDIR:
			return (EISDIR);
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
		default:
			break;
		}
		error = ext2fs_truncate(ip, vap->va_size, 0, cred);
		if (error)
			return (error);
	}
	if ((vap->va_vaflags & VA_UTIMES_CHANGE) ||
	    vap->va_atime.tv_nsec != VNOVAL ||
	    vap->va_mtime.tv_nsec != VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		if (cred->cr_uid != ip->i_e2fs_uid &&
			(error = suser_ucred(cred)) &&
			((vap->va_vaflags & VA_UTIMES_NULL) == 0 ||
			(error = VOP_ACCESS(vp, VWRITE, cred, p))))
			return (error);
		if (vap->va_mtime.tv_nsec != VNOVAL)
			ip->i_flag |= IN_CHANGE | IN_UPDATE;
		else if (vap->va_vaflags & VA_UTIMES_CHANGE)
			ip->i_flag |= IN_CHANGE;
		if (vap->va_atime.tv_nsec != VNOVAL) {
			if (!(vp->v_mount->mnt_flag & MNT_NOATIME) ||
			    (ip->i_flag & (IN_CHANGE | IN_UPDATE)))
				ip->i_flag |= IN_ACCESS;
		}
		EXT2FS_ITIMES(ip);
		if (vap->va_mtime.tv_nsec != VNOVAL)
			ip->i_e2fs_mtime = vap->va_mtime.tv_sec;
		if (vap->va_atime.tv_nsec != VNOVAL)
			ip->i_e2fs_atime = vap->va_atime.tv_sec;
		error = ext2fs_update(ip, 1);
		if (error)
			return (error);
	}
	error = 0;
	if (vap->va_mode != (mode_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		error = ext2fs_chmod(vp, vap->va_mode, cred, p);
	}
	return (error);
}

/*
 * Change the mode on a file.
 * Inode must be locked before calling.
 */
static int
ext2fs_chmod(struct vnode *vp, mode_t mode, struct ucred *cred, struct proc *p)
{
	struct inode *ip = VTOI(vp);
	int error;

	if (cred->cr_uid != ip->i_e2fs_uid && (error = suser_ucred(cred)))
		return (error);
	if (cred->cr_uid) {
		if (vp->v_type != VDIR && (mode & S_ISTXT))
			return (EFTYPE);
		if (!groupmember(ip->i_e2fs_gid, cred) && (mode & ISGID))
			return (EPERM);
	}
	ip->i_e2fs_mode &= ~ALLPERMS;
	ip->i_e2fs_mode |= (mode & ALLPERMS);
	ip->i_flag |= IN_CHANGE;
	if ((vp->v_flag & VTEXT) && (ip->i_e2fs_mode & S_ISTXT) == 0)
		(void) uvm_vnp_uncache(vp);
	return (0);
}

/*
 * Perform chown operation on inode ip;
 * inode must be locked prior to call.
 */
static int
ext2fs_chown(struct vnode *vp, uid_t uid, gid_t gid, struct ucred *cred, struct proc *p)
{
	struct inode *ip = VTOI(vp);
	uid_t ouid;
	gid_t ogid;
	int error = 0;

	if (uid == (uid_t)VNOVAL)
		uid = ip->i_e2fs_uid;
	if (gid == (gid_t)VNOVAL)
		gid = ip->i_e2fs_gid;
	/*
	 * If we don't own the file, are trying to change the owner
	 * of the file, or are not a member of the target group,
	 * the caller must be superuser or the call fails.
	 */
	if ((cred->cr_uid != ip->i_e2fs_uid || uid != ip->i_e2fs_uid ||
		(gid != ip->i_e2fs_gid && !groupmember(gid, cred))) &&
		(error = suser_ucred(cred)))
		return (error);
	ogid = ip->i_e2fs_gid;
	ouid = ip->i_e2fs_uid;

	ip->i_e2fs_gid = gid;
	ip->i_e2fs_uid = uid;
	if (ouid != uid || ogid != gid)
		ip->i_flag |= IN_CHANGE;
	if (ouid != uid && cred->cr_uid != 0)
		ip->i_e2fs_mode &= ~ISUID;
	if (ogid != gid && cred->cr_uid != 0)
		ip->i_e2fs_mode &= ~ISGID;
	return (0);
}

int
ext2fs_remove(void *v)
{
	struct vop_remove_args *ap = v;
	struct inode *ip;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	int error;

	ip = VTOI(vp);
	if (vp->v_type == VDIR ||
		(ip->i_e2fs_flags & (EXT2_IMMUTABLE | EXT2_APPEND)) ||
	    	(VTOI(dvp)->i_e2fs_flags & EXT2_APPEND)) {
		error = EPERM;
		goto out;
	}
	error = ext2fs_dirremove(dvp, ap->a_cnp);
	if (error == 0) {
		ip->i_e2fs_nlink--;
		ip->i_flag |= IN_CHANGE;
	}
out:
	if (dvp == vp)
		vrele(vp);
	else
		vput(vp);
	vput(dvp);
	return (error);
}

/*
 * link vnode call
 */
int
ext2fs_link(void *v)
{
	struct vop_link_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vnode *vp = ap->a_vp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	struct inode *ip;
	int error;

#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("ext2fs_link: no name");
#endif
	if (vp->v_type == VDIR) {
		VOP_ABORTOP(dvp, cnp);
		error = EISDIR;
		goto out2;
	}
	if (dvp->v_mount != vp->v_mount) {
		VOP_ABORTOP(dvp, cnp);
		error = EXDEV;
		goto out2;
	}
	if (dvp != vp && (error = vn_lock(vp, LK_EXCLUSIVE, p))) {
		VOP_ABORTOP(dvp, cnp);
		goto out2;
	}
	ip = VTOI(vp);
	if ((nlink_t)ip->i_e2fs_nlink >= LINK_MAX) {
		VOP_ABORTOP(dvp, cnp);
		error = EMLINK;
		goto out1;
	}
	if (ip->i_e2fs_flags & (EXT2_IMMUTABLE | EXT2_APPEND)) {
		VOP_ABORTOP(dvp, cnp);
		error = EPERM;
		goto out1;
	}
	ip->i_e2fs_nlink++;
	ip->i_flag |= IN_CHANGE;
	error = ext2fs_update(ip, 1);
	if (!error)
		error = ext2fs_direnter(ip, dvp, cnp);
	if (error) {
		ip->i_e2fs_nlink--;
		ip->i_flag |= IN_CHANGE;
	}
	pool_put(&namei_pool, cnp->cn_pnbuf);
out1:
	if (dvp != vp)
		VOP_UNLOCK(vp, p);
out2:
	vput(dvp);
	return (error);
}

/*
 * Rename system call.
 * 	rename("foo", "bar");
 * is essentially
 *	unlink("bar");
 *	link("foo", "bar");
 *	unlink("foo");
 * but ``atomically''.  Can't do full commit without saving state in the
 * inode on disk which isn't feasible at this time.  Best we can do is
 * always guarantee the target exists.
 *
 * Basic algorithm is:
 *
 * 1) Bump link count on source while we're linking it to the
 *    target.  This also ensure the inode won't be deleted out
 *    from underneath us while we work (it may be truncated by
 *    a concurrent `trunc' or `open' for creation).
 * 2) Link source to destination.  If destination already exists,
 *    delete it first.
 * 3) Unlink source reference to inode if still around. If a
 *    directory was moved and the parent of the destination
 *    is different from the source, patch the ".." entry in the
 *    directory.
 */
int
ext2fs_rename(void *v)
{
	struct vop_rename_args  *ap = v;
	struct vnode *tvp = ap->a_tvp;
	struct vnode *tdvp = ap->a_tdvp;
	struct vnode *fvp = ap->a_fvp;
	struct vnode *fdvp = ap->a_fdvp;
	struct componentname *tcnp = ap->a_tcnp;
	struct componentname *fcnp = ap->a_fcnp;
	struct inode *ip, *xp, *dp;
	struct proc *p = fcnp->cn_proc;
	struct ext2fs_dirtemplate dirbuf;
	/* struct timespec ts; */
	int doingdirectory = 0, oldparent = 0, newparent = 0;
	int error = 0;
	u_char namlen;

#ifdef DIAGNOSTIC
	if ((tcnp->cn_flags & HASBUF) == 0 ||
	    (fcnp->cn_flags & HASBUF) == 0)
		panic("ext2fs_rename: no name");
#endif
	/*
	 * Check for cross-device rename.
	 */
	if ((fvp->v_mount != tdvp->v_mount) ||
	    (tvp && (fvp->v_mount != tvp->v_mount))) {
		error = EXDEV;
abortit:
		VOP_ABORTOP(tdvp, tcnp); /* XXX, why not in NFS? */
		if (tdvp == tvp)
			vrele(tdvp);
		else
			vput(tdvp);
		if (tvp)
			vput(tvp);
		VOP_ABORTOP(fdvp, fcnp); /* XXX, why not in NFS? */
		vrele(fdvp);
		vrele(fvp);
		return (error);
	}

	/*
	 * Check if just deleting a link name.
	 */
	if (tvp && ((VTOI(tvp)->i_e2fs_flags & (EXT2_IMMUTABLE | EXT2_APPEND)) ||
	    (VTOI(tdvp)->i_e2fs_flags & EXT2_APPEND))) {
		error = EPERM;
		goto abortit;
	}
	if (fvp == tvp) {
		if (fvp->v_type == VDIR) {
			error = EINVAL;
			goto abortit;
		}

		/* Release destination completely. */
		VOP_ABORTOP(tdvp, tcnp);
		vput(tdvp);
		vput(tvp);

		/* Delete source. */
		vrele(fdvp);
		vrele(fvp);
		fcnp->cn_flags &= ~MODMASK;
		fcnp->cn_flags |= LOCKPARENT | LOCKLEAF;
		if ((fcnp->cn_flags & SAVESTART) == 0)
			panic("ext2fs_rename: lost from startdir");
		fcnp->cn_nameiop = DELETE;
		(void) vfs_relookup(fdvp, &fvp, fcnp);
		return (VOP_REMOVE(fdvp, fvp, fcnp));
	}
	if ((error = vn_lock(fvp, LK_EXCLUSIVE, p)) != 0)
		goto abortit;
	dp = VTOI(fdvp);
	ip = VTOI(fvp);
	if ((nlink_t)ip->i_e2fs_nlink >= LINK_MAX) {
		VOP_UNLOCK(fvp, p);
		error = EMLINK;
		goto abortit;
	}
	if ((ip->i_e2fs_flags & (EXT2_IMMUTABLE | EXT2_APPEND)) ||
		(dp->i_e2fs_flags & EXT2_APPEND)) {
		VOP_UNLOCK(fvp, p);
		error = EPERM;
		goto abortit;
	}
	if ((ip->i_e2fs_mode & IFMT) == IFDIR) {
        	error = VOP_ACCESS(fvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
        	if (!error && tvp)
                	error = VOP_ACCESS(tvp, VWRITE, tcnp->cn_cred,
			    tcnp->cn_proc);
        	if (error) {
                	VOP_UNLOCK(fvp, p);
                	error = EACCES;
                	goto abortit;
        	}
		/*
		 * Avoid ".", "..", and aliases of "." for obvious reasons.
		 */
		if ((fcnp->cn_namelen == 1 && fcnp->cn_nameptr[0] == '.') ||
		    dp == ip ||
			(fcnp->cn_flags&ISDOTDOT) ||
			(tcnp->cn_flags & ISDOTDOT) ||
		    (ip->i_flag & IN_RENAME)) {
			VOP_UNLOCK(fvp, p);
			error = EINVAL;
			goto abortit;
		}
		ip->i_flag |= IN_RENAME;
		oldparent = dp->i_number;
		doingdirectory++;
	}
	vrele(fdvp);

	/*
	 * When the target exists, both the directory
	 * and target vnodes are returned locked.
	 */
	dp = VTOI(tdvp);
	xp = NULL;
	if (tvp)
		xp = VTOI(tvp);

	/*
	 * 1) Bump link count while we're moving stuff
	 *    around.  If we crash somewhere before
	 *    completing our work, the link count
	 *    may be wrong, but correctable.
	 */
	ip->i_e2fs_nlink++;
	ip->i_flag |= IN_CHANGE;
	if ((error = ext2fs_update(ip, 1)) != 0) {
		VOP_UNLOCK(fvp, p);
		goto bad;
	}

	/*
	 * If ".." must be changed (ie the directory gets a new
	 * parent) then the source directory must not be in the
	 * directory hierarchy above the target, as this would
	 * orphan everything below the source directory. Also
	 * the user must have write permission in the source so
	 * as to be able to change "..". We must repeat the call
	 * to namei, as the parent directory is unlocked by the
	 * call to checkpath().
	 */
	error = VOP_ACCESS(fvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
	VOP_UNLOCK(fvp, p);
	if (oldparent != dp->i_number)
		newparent = dp->i_number;
	if (doingdirectory && newparent) {
		if (error)	/* write access check above */
			goto bad;
		if (xp != NULL)
			vput(tvp);
		error = ext2fs_checkpath(ip, dp, tcnp->cn_cred);
		if (error != 0)
			goto out;
		if ((tcnp->cn_flags & SAVESTART) == 0)
			panic("ext2fs_rename: lost to startdir");
		if ((error = vfs_relookup(tdvp, &tvp, tcnp)) != 0)
			goto out;
		dp = VTOI(tdvp);
		xp = NULL;
		if (tvp)
			xp = VTOI(tvp);
	}
	/*
	 * 2) If target doesn't exist, link the target
	 *    to the source and unlink the source.
	 *    Otherwise, rewrite the target directory
	 *    entry to reference the source inode and
	 *    expunge the original entry's existence.
	 */
	if (xp == NULL) {
		if (dp->i_dev != ip->i_dev)
			panic("rename: EXDEV");
		/*
		 * Account for ".." in new directory.
		 * When source and destination have the same
		 * parent we don't fool with the link count.
		 */
		if (doingdirectory && newparent) {
			if ((nlink_t)dp->i_e2fs_nlink >= LINK_MAX) {
				error = EMLINK;
				goto bad;
			}
			dp->i_e2fs_nlink++;
			dp->i_flag |= IN_CHANGE;
			if ((error = ext2fs_update(dp, 1)) != 0)
				goto bad;
		}
		error = ext2fs_direnter(ip, tdvp, tcnp);
		if (error != 0) {
			if (doingdirectory && newparent) {
				dp->i_e2fs_nlink--;
				dp->i_flag |= IN_CHANGE;
				(void)ext2fs_update(dp, 1);
			}
			goto bad;
		}
		vput(tdvp);
	} else {
		if (xp->i_dev != dp->i_dev || xp->i_dev != ip->i_dev)
			panic("rename: EXDEV");
		/*
		 * Short circuit rename(foo, foo).
		 */
		if (xp->i_number == ip->i_number)
			panic("rename: same file");
		/*
		 * If the parent directory is "sticky", then the user must
		 * own the parent directory, or the destination of the rename,
		 * otherwise the destination may not be changed (except by
		 * root). This implements append-only directories.
		 */
		if ((dp->i_e2fs_mode & S_ISTXT) && tcnp->cn_cred->cr_uid != 0 &&
		    tcnp->cn_cred->cr_uid != dp->i_e2fs_uid &&
		    xp->i_e2fs_uid != tcnp->cn_cred->cr_uid) {
			error = EPERM;
			goto bad;
		}
		/*
		 * Target must be empty if a directory and have no links
		 * to it. Also, ensure source and target are compatible
		 * (both directories, or both not directories).
		 */
		if ((xp->i_e2fs_mode & IFMT) == IFDIR) {
			if (!ext2fs_dirempty(xp, dp->i_number, tcnp->cn_cred) ||
				xp->i_e2fs_nlink > 2) {
				error = ENOTEMPTY;
				goto bad;
			}
			if (!doingdirectory) {
				error = ENOTDIR;
				goto bad;
			}
			cache_purge(tdvp);
		} else if (doingdirectory) {
			error = EISDIR;
			goto bad;
		}
		error = ext2fs_dirrewrite(dp, ip, tcnp);
		if (error != 0)
			goto bad;
		/*
		 * If the target directory is in the same
		 * directory as the source directory,
		 * decrement the link count on the parent
		 * of the target directory.
		 */
		 if (doingdirectory && !newparent) {
			dp->i_e2fs_nlink--;
			dp->i_flag |= IN_CHANGE;
		}
		vput(tdvp);
		/*
		 * Adjust the link count of the target to
		 * reflect the dirrewrite above.  If this is
		 * a directory it is empty and there are
		 * no links to it, so we can squash the inode and
		 * any space associated with it.  We disallowed
		 * renaming over top of a directory with links to
		 * it above, as the remaining link would point to
		 * a directory without "." or ".." entries.
		 */
		xp->i_e2fs_nlink--;
		if (doingdirectory) {
			if (--xp->i_e2fs_nlink != 0)
				panic("rename: linked directory");
			error = ext2fs_truncate(xp, (off_t)0, IO_SYNC,
			    tcnp->cn_cred);
		}
		xp->i_flag |= IN_CHANGE;
		vput(tvp);
		xp = NULL;
	}

	/*
	 * 3) Unlink the source.
	 */
	fcnp->cn_flags &= ~MODMASK;
	fcnp->cn_flags |= LOCKPARENT | LOCKLEAF;
	if ((fcnp->cn_flags & SAVESTART) == 0)
		panic("ext2fs_rename: lost from startdir");
	(void) vfs_relookup(fdvp, &fvp, fcnp);
	if (fvp != NULL) {
		xp = VTOI(fvp);
		dp = VTOI(fdvp);
	} else {
		/*
		 * From name has disappeared.
		 */
		if (doingdirectory)
			panic("ext2fs_rename: lost dir entry");
		vrele(ap->a_fvp);
		return (0);
	}
	/*
	 * Ensure that the directory entry still exists and has not
	 * changed while the new name has been entered. If the source is
	 * a file then the entry may have been unlinked or renamed. In
	 * either case there is no further work to be done. If the source
	 * is a directory then it cannot have been rmdir'ed; its link
	 * count of three would cause a rmdir to fail with ENOTEMPTY.
	 * The IRENAME flag ensures that it cannot be moved by another
	 * rename.
	 */
	if (xp != ip) {
		if (doingdirectory)
			panic("ext2fs_rename: lost dir entry");
	} else {
		/*
		 * If the source is a directory with a
		 * new parent, the link count of the old
		 * parent directory must be decremented
		 * and ".." set to point to the new parent.
		 */
		if (doingdirectory && newparent) {
			dp->i_e2fs_nlink--;
			dp->i_flag |= IN_CHANGE;
			error = vn_rdwr(UIO_READ, fvp, (caddr_t)&dirbuf,
				sizeof (struct ext2fs_dirtemplate), (off_t)0,
				UIO_SYSSPACE, IO_NODELOCKED,
				tcnp->cn_cred, NULL, curproc);
			if (error == 0) {
					namlen = dirbuf.dotdot_namlen;
				if (namlen != 2 ||
				    dirbuf.dotdot_name[0] != '.' ||
				    dirbuf.dotdot_name[1] != '.') {
					ufs_dirbad(xp, (doff_t)12,
					    "ext2fs_rename: mangled dir");
				} else {
					dirbuf.dotdot_ino = htole32(newparent);
					(void) vn_rdwr(UIO_WRITE, fvp,
					    (caddr_t)&dirbuf,
					    sizeof (struct dirtemplate),
					    (off_t)0, UIO_SYSSPACE,
					    IO_NODELOCKED|IO_SYNC,
					    tcnp->cn_cred, NULL, curproc);
					cache_purge(fdvp);
				}
			}
		}
		error = ext2fs_dirremove(fdvp, fcnp);
		if (!error) {
			xp->i_e2fs_nlink--;
			xp->i_flag |= IN_CHANGE;
		}
		xp->i_flag &= ~IN_RENAME;
	}
	if (dp)
		vput(fdvp);
	if (xp)
		vput(fvp);
	vrele(ap->a_fvp);
	return (error);

bad:
	if (xp)
		vput(ITOV(xp));
	vput(ITOV(dp));
out:
	if (doingdirectory)
		ip->i_flag &= ~IN_RENAME;
	if (vn_lock(fvp, LK_EXCLUSIVE, p) == 0) {
		ip->i_e2fs_nlink--;
		ip->i_flag |= IN_CHANGE;
		vput(fvp);
	} else
		vrele(fvp);
	return (error);
}

/*
 * Mkdir system call
 */
int
ext2fs_mkdir(void *v)
{
	struct vop_mkdir_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct inode *ip, *dp;
	struct vnode *tvp;
	struct ext2fs_dirtemplate dirtemplate;
	mode_t dmode;
	int error;

#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("ext2fs_mkdir: no name");
#endif
	dp = VTOI(dvp);
	if ((nlink_t)dp->i_e2fs_nlink >= LINK_MAX) {
		error = EMLINK;
		goto out;
	}
	dmode = vap->va_mode & ACCESSPERMS;
	dmode |= IFDIR;
	/*
	 * Must simulate part of ext2fs_makeinode here to acquire the inode,
	 * but not have it entered in the parent directory. The entry is
	 * made later after writing "." and ".." entries.
	 */
	if ((error = ext2fs_inode_alloc(dp, dmode, cnp->cn_cred, &tvp)) != 0)
		goto out;
	ip = VTOI(tvp);
	ip->i_e2fs_uid = cnp->cn_cred->cr_uid;
	ip->i_e2fs_gid = dp->i_e2fs_gid;
	ip->i_flag |= IN_ACCESS | IN_CHANGE | IN_UPDATE;
	ip->i_e2fs_mode = dmode;
	tvp->v_type = VDIR;	/* Rest init'd in getnewvnode(). */
	ip->i_e2fs_nlink = 2;
	error = ext2fs_update(ip, 1);

	/*
	 * Bump link count in parent directory
	 * to reflect work done below.  Should
	 * be done before reference is created
	 * so reparation is possible if we crash.
	 */
	dp->i_e2fs_nlink++;
	dp->i_flag |= IN_CHANGE;
	if ((error = ext2fs_update(dp, 1)) != 0)
		goto bad;

	/* Initialize directory with "." and ".." from static template. */
	memset(&dirtemplate, 0, sizeof(dirtemplate));
	dirtemplate.dot_ino = htole32(ip->i_number);
	dirtemplate.dot_reclen = htole16(12);
	dirtemplate.dot_namlen = 1;
	if (ip->i_e2fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    (ip->i_e2fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_FTYPE)) {
		dirtemplate.dot_type = EXT2_FT_DIR;
	}
	dirtemplate.dot_name[0] = '.';
	dirtemplate.dotdot_ino = htole32(dp->i_number);
	dirtemplate.dotdot_reclen = htole16(VTOI(dvp)->i_e2fs->e2fs_bsize - 12);
	dirtemplate.dotdot_namlen = 2;
	if (ip->i_e2fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    (ip->i_e2fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_FTYPE)) {
		dirtemplate.dotdot_type = EXT2_FT_DIR;
	}
	dirtemplate.dotdot_name[0] = dirtemplate.dotdot_name[1] = '.';
	error = vn_rdwr(UIO_WRITE, tvp, (caddr_t)&dirtemplate,
	    sizeof (dirtemplate), (off_t)0, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_SYNC, cnp->cn_cred, NULL, curproc);
	if (error) {
		dp->i_e2fs_nlink--;
		dp->i_flag |= IN_CHANGE;
		goto bad;
	}
	if (VTOI(dvp)->i_e2fs->e2fs_bsize >
							VFSTOUFS(dvp->v_mount)->um_mountp->mnt_stat.f_bsize)
		panic("ext2fs_mkdir: blksize"); /* XXX should grow with balloc() */
	else {
		error = ext2fs_setsize(ip, VTOI(dvp)->i_e2fs->e2fs_bsize);
  	        if (error) {
  	        	dp->i_e2fs_nlink--;
  	        	dp->i_flag |= IN_CHANGE;
  	        	goto bad;
  	        }
		ip->i_flag |= IN_CHANGE;
	}

	/* Directory set up, now install its entry in the parent directory. */
	error = ext2fs_direnter(ip, dvp, cnp);
	if (error != 0) {
		dp->i_e2fs_nlink--;
		dp->i_flag |= IN_CHANGE;
	}
bad:
	/*
	 * No need to do an explicit VOP_TRUNCATE here, vrele will do this
	 * for us because we set the link count to 0.
	 */
	if (error) {
		ip->i_e2fs_nlink = 0;
		ip->i_flag |= IN_CHANGE;
		vput(tvp);
	} else
		*ap->a_vpp = tvp;
out:
	pool_put(&namei_pool, cnp->cn_pnbuf);
	vput(dvp);
	return (error);
}

/*
 * Rmdir system call.
 */
int
ext2fs_rmdir(void *v)
{
	struct vop_rmdir_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct inode *ip, *dp;
	int error;

	ip = VTOI(vp);
	dp = VTOI(dvp);
	/*
	 * No rmdir "." please.
	 */
	if (dp == ip) {
		vrele(dvp);
		vput(vp);
		return (EINVAL);
	}
	/*
	 * Verify the directory is empty (and valid).
	 * (Rmdir ".." won't be valid since
	 *  ".." will contain a reference to
	 *  the current directory and thus be
	 *  non-empty.)
	 */
	error = 0;
	if (ip->i_e2fs_nlink != 2 ||
	    !ext2fs_dirempty(ip, dp->i_number, cnp->cn_cred)) {
		error = ENOTEMPTY;
		goto out;
	}
	if ((dp->i_e2fs_flags & EXT2_APPEND) ||
				 (ip->i_e2fs_flags & (EXT2_IMMUTABLE | EXT2_APPEND))) {
		error = EPERM;
		goto out;
	}
	/*
	 * Delete reference to directory before purging
	 * inode.  If we crash in between, the directory
	 * will be reattached to lost+found,
	 */
	error = ext2fs_dirremove(dvp, cnp);
	if (error != 0)
		goto out;
	dp->i_e2fs_nlink--;
	dp->i_flag |= IN_CHANGE;
	cache_purge(dvp);
	vput(dvp);
	dvp = NULL;
	/*
	 * Truncate inode.  The only stuff left
	 * in the directory is "." and "..".  The
	 * "." reference is inconsequential since
	 * we're quashing it.  The ".." reference
	 * has already been adjusted above.  We've
	 * removed the "." reference and the reference
	 * in the parent directory, but there may be
	 * other hard links so decrement by 2 and
	 * worry about them later.
	 */
	ip->i_e2fs_nlink -= 2;
	error = ext2fs_truncate(ip, (off_t)0, IO_SYNC, cnp->cn_cred);
	cache_purge(ITOV(ip));
out:
	if (dvp)
		vput(dvp);
	vput(vp);
	return (error);
}

/*
 * symlink -- make a symbolic link
 */
int
ext2fs_symlink(void *v)
{
	struct vop_symlink_args *ap = v;
	struct vnode *vp, **vpp = ap->a_vpp;
	struct inode *ip;
	int len, error;

	error = ext2fs_makeinode(IFLNK | ap->a_vap->va_mode, ap->a_dvp,
			      vpp, ap->a_cnp);
	if (error)
		return (error);
	vp = *vpp;
	len = strlen(ap->a_target);
	if (len < EXT2_MAXSYMLINKLEN) {
		ip = VTOI(vp);
		memcpy(ip->i_e2din->e2di_shortlink, ap->a_target, len);
		error = ext2fs_setsize(ip, len);
		if (error)
			goto bad;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	} else
		error = vn_rdwr(UIO_WRITE, vp, ap->a_target, len, (off_t)0,
		    UIO_SYSSPACE, IO_NODELOCKED, ap->a_cnp->cn_cred, NULL,
		    curproc);
bad:
	vput(vp);
	return (error);
}

/*
 * Return target name of a symbolic link
 */
int
ext2fs_readlink(void *v)
{
	struct vop_readlink_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	u_int64_t isize;

	isize = ext2fs_size(ip);
	if (isize < EXT2_MAXSYMLINKLEN) {
		return (uiomove((char *)ip->i_e2din->e2di_shortlink, isize,
		    ap->a_uio));
	}
	return (VOP_READ(vp, ap->a_uio, 0, ap->a_cred));
}

/*
 * Return POSIX pathconf information applicable to ext2 filesystems.
 */
int
ext2fs_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	int error = 0;

	switch (ap->a_name) {
	case _PC_TIMESTAMP_RESOLUTION:
		*ap->a_retval = 1000000000;	/* 1 billion nanoseconds */
		break;
	default:
		return (ufs_pathconf(v));
	}

	return (error);
}

/*
 * Advisory record locking support
 */
int
ext2fs_advlock(void *v)
{
	struct vop_advlock_args *ap = v;
	struct inode *ip = VTOI(ap->a_vp);

	return (lf_advlock(&ip->i_lockf, ext2fs_size(ip), ap->a_id, ap->a_op,
	    ap->a_fl, ap->a_flags));
}

/*
 * Allocate a new inode.
 */
int
ext2fs_makeinode(int mode, struct vnode *dvp, struct vnode **vpp,
    struct componentname *cnp)
{
	struct inode *ip, *pdir;
	struct vnode *tvp;
	int error;

	pdir = VTOI(dvp);
#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("ext2fs_makeinode: no name");
#endif
	*vpp = NULL;
	if ((mode & IFMT) == 0)
		mode |= IFREG;

	if ((error = ext2fs_inode_alloc(pdir, mode, cnp->cn_cred, &tvp))
	    != 0) {
		pool_put(&namei_pool, cnp->cn_pnbuf);
		vput(dvp);
		return (error);
	}
	ip = VTOI(tvp);
	ip->i_e2fs_gid = pdir->i_e2fs_gid;
	ip->i_e2fs_uid = cnp->cn_cred->cr_uid;
	ip->i_flag |= IN_ACCESS | IN_CHANGE | IN_UPDATE;
	ip->i_e2fs_mode = mode;
	tvp->v_type = IFTOVT(mode);	/* Rest init'd in getnewvnode(). */
	ip->i_e2fs_nlink = 1;
	if ((ip->i_e2fs_mode & ISGID) &&
		!groupmember(ip->i_e2fs_gid, cnp->cn_cred) &&
	    suser_ucred(cnp->cn_cred))
		ip->i_e2fs_mode &= ~ISGID;

	/*
	 * Make sure inode goes to disk before directory entry.
	 */
	if ((error = ext2fs_update(ip, 1)) != 0)
		goto bad;
	error = ext2fs_direnter(ip, dvp, cnp);
	if (error != 0)
		goto bad;
	if ((cnp->cn_flags & SAVESTART) == 0)
		pool_put(&namei_pool, cnp->cn_pnbuf);
	vput(dvp);
	*vpp = tvp;
	return (0);

bad:
	/*
	 * Write error occurred trying to update the inode
	 * or the directory so must deallocate the inode.
	 */
	pool_put(&namei_pool, cnp->cn_pnbuf);
	vput(dvp);
	ip->i_e2fs_nlink = 0;
	ip->i_flag |= IN_CHANGE;
	tvp->v_type = VNON;
	vput(tvp);
	return (error);
}

/*
 * Synch an open file.
 */
/* ARGSUSED */
int
ext2fs_fsync(void *v)
{
	struct vop_fsync_args *ap = v;
	struct vnode *vp = ap->a_vp;

	vflushbuf(vp, ap->a_waitfor == MNT_WAIT);
	return (ext2fs_update(VTOI(ap->a_vp), ap->a_waitfor == MNT_WAIT));
}

/*
 * Reclaim an inode so that it can be used for other purposes.
 */
int
ext2fs_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip;
#ifdef DIAGNOSTIC
	extern int prtactive;

	if (prtactive && vp->v_usecount != 0)
		vprint("ext2fs_reclaim: pushing active", vp);
#endif

	/*
	 * Remove the inode from its hash chain.
	 */
	ip = VTOI(vp);
	ufs_ihashrem(ip);

	/*
	 * Purge old data structures associated with the inode.
	 */
	cache_purge(vp);
	if (ip->i_devvp)
		vrele(ip->i_devvp);

	if (ip->i_e2din != NULL)
		pool_put(&ext2fs_dinode_pool, ip->i_e2din);

	pool_put(&ext2fs_inode_pool, ip);

	vp->v_data = NULL;

	return (0);
}

/* Global vfs data structures for ext2fs. */
struct vops ext2fs_vops = {
        .vop_lookup     = ext2fs_lookup,
        .vop_create     = ext2fs_create,
        .vop_mknod      = ext2fs_mknod,
        .vop_open       = ext2fs_open,
        .vop_close      = ufs_close,
        .vop_access     = ext2fs_access,
        .vop_getattr    = ext2fs_getattr,
        .vop_setattr    = ext2fs_setattr,
        .vop_read       = ext2fs_read,
        .vop_write      = ext2fs_write,
        .vop_ioctl      = ufs_ioctl,
        .vop_poll       = ufs_poll,
        .vop_kqfilter   = vop_generic_kqfilter,
        .vop_fsync      = ext2fs_fsync,
        .vop_remove     = ext2fs_remove,
        .vop_link       = ext2fs_link,
        .vop_rename     = ext2fs_rename,
        .vop_mkdir      = ext2fs_mkdir,
        .vop_rmdir      = ext2fs_rmdir,
        .vop_symlink    = ext2fs_symlink,
        .vop_readdir    = ext2fs_readdir,
        .vop_readlink   = ext2fs_readlink,
        .vop_abortop    = vop_generic_abortop,
        .vop_inactive   = ext2fs_inactive,
        .vop_reclaim    = ext2fs_reclaim,
        .vop_lock       = ufs_lock,
        .vop_unlock     = ufs_unlock,
        .vop_bmap       = ext2fs_bmap,
        .vop_strategy   = ufs_strategy,
        .vop_print      = ufs_print,
        .vop_islocked   = ufs_islocked,
        .vop_pathconf   = ext2fs_pathconf,
        .vop_advlock    = ext2fs_advlock,
        .vop_bwrite     = vop_generic_bwrite
};

struct vops ext2fs_specvops = {
        .vop_close      = ufsspec_close,
        .vop_access     = ext2fs_access,
        .vop_getattr    = ext2fs_getattr,
        .vop_setattr    = ext2fs_setattr,
        .vop_read       = ufsspec_read,
        .vop_write      = ufsspec_write,
        .vop_fsync      = ext2fs_fsync,
        .vop_inactive   = ext2fs_inactive,
        .vop_reclaim    = ext2fs_reclaim,
        .vop_lock       = ufs_lock,
        .vop_unlock     = ufs_unlock,
        .vop_print      = ufs_print,
        .vop_islocked   = ufs_islocked,

        /* XXX: Keep in sync with spec_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
};

#ifdef FIFO
struct vops ext2fs_fifovops = {
        .vop_close      = ufsfifo_close,
        .vop_access     = ufsfifo_close,
        .vop_getattr    = ext2fs_getattr,
        .vop_setattr    = ext2fs_setattr,
        .vop_read       = ufsfifo_read,
        .vop_write      = ufsfifo_write,
        .vop_fsync      = ext2fs_fsync,
        .vop_inactive   = ext2fs_inactive,
        .vop_reclaim    = ext2fsfifo_reclaim,
        .vop_lock       = ufs_lock,
        .vop_unlock     = ufs_unlock,
        .vop_print      = ufs_print,
        .vop_islocked   = ufs_islocked,
        .vop_bwrite     = vop_generic_bwrite,

        /* XXX: Keep in sync with fifo_vops */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock,
};

int
ext2fsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (ext2fs_reclaim(v));
}
#endif /* FIFO */
@


1.76
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.75 2016/02/26 08:56:10 natano Exp $	*/
d480 1
a480 1
		VOP_UNLOCK(vp, 0, p);
d588 1
a588 1
		VOP_UNLOCK(fvp, 0, p);
d594 1
a594 1
		VOP_UNLOCK(fvp, 0, p);
d604 1
a604 1
                	VOP_UNLOCK(fvp, 0, p);
d616 1
a616 1
			VOP_UNLOCK(fvp, 0, p);
d644 1
a644 1
		VOP_UNLOCK(fvp, 0, p);
d659 1
a659 1
	VOP_UNLOCK(fvp, 0, p);
@


1.75
log
@Convert mnt_maxsymlinklen to unsigned.

This allows to remove some truncating casts in symlink handling code.
Also, validate fs_maxsymlinklen in the superblock at mount time and on
fsck to make sure we don't use bogus data.

discussion & ok millert@@, stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.74 2016/02/16 17:56:12 stefan Exp $	*/
d1094 1
a1094 1
	if (len < vp->v_mount->mnt_maxsymlinklen) {
d1122 1
a1122 2
	if (isize < vp->v_mount->mnt_maxsymlinklen ||
	    (vp->v_mount->mnt_maxsymlinklen == 0 && ip->i_e2fs_nblock == 0)) {
@


1.74
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.73 2015/04/17 04:43:21 guenther Exp $	*/
d325 1
a325 1
		error = ext2fs_chmod(vp, (int)vap->va_mode, cred, p);
@


1.73
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.72 2015/03/14 03:38:52 jsg Exp $	*/
d1119 1
a1119 1
	int isize;
d1124 1
a1124 1
		return (uiomovei((char *)ip->i_e2din->e2di_shortlink, isize,
@


1.72
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.71 2015/02/10 21:56:10 miod Exp $	*/
d293 3
a295 1
	if (vap->va_atime.tv_sec != VNOVAL || vap->va_mtime.tv_sec != VNOVAL) {
d303 1
a303 1
		if (vap->va_mtime.tv_sec != VNOVAL)
d305 3
a307 1
		if (vap->va_atime.tv_sec != VNOVAL) {
d313 1
a313 1
		if (vap->va_mtime.tv_sec != VNOVAL)
d315 1
a315 1
		if (vap->va_atime.tv_sec != VNOVAL)
@


1.71
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.70 2015/01/11 03:05:03 guenther Exp $	*/
a47 1
#include <sys/buf.h>
@


1.70
log
@Casting a gid_t to gid_t for a gid_t argument is overkill
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.69 2014/12/29 05:29:28 miod Exp $	*/
d1121 1
a1121 1
		return (uiomove((char *)ip->i_e2din->e2di_shortlink, isize,
@


1.69
log
@Explicitely include <uvm/uvm_extern.h> in order to build on variable page size
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.68 2014/11/03 21:28:35 tedu Exp $	*/
d375 1
a375 1
		(gid != ip->i_e2fs_gid && !groupmember((gid_t)gid, cred))) &&
@


1.68
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.67 2014/07/13 16:59:35 pelikan Exp $	*/
d71 2
@


1.67
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

Some KNF while there.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.66 2014/07/08 17:19:26 deraadt Exp $	*/
d59 1
@


1.66
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.65 2014/05/27 14:31:24 krw Exp $	*/
d110 1
a110 1
		ip->i_e2din->e2di_rdev = h2fs32(vap->va_rdev);
d179 1
a179 1
	vap->va_rdev = (dev_t)fs2h32(ip->i_e2din->e2di_rdev);
d839 1
a839 1
					dirbuf.dotdot_ino = h2fs32(newparent);
d936 2
a937 2
	dirtemplate.dot_ino = h2fs32(ip->i_number);
	dirtemplate.dot_reclen = h2fs16(12);
d944 2
a945 2
	dirtemplate.dotdot_ino = h2fs32(dp->i_number);
	dirtemplate.dotdot_reclen = h2fs16(VTOI(dvp)->i_e2fs->e2fs_bsize - 12);
@


1.65
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.64 2014/01/25 23:31:12 guenther Exp $	*/
a58 2

#include <uvm/uvm_extern.h>
@


1.64
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.63 2013/12/12 19:00:09 tedu Exp $	*/
d83 1
a83 1
	return ext2fs_makeinode(MAKEIMODE(ap->a_vap->va_type, 
d241 1
a241 1
			if ((ip->i_e2fs_flags & 
d245 1
a245 1
			ip->i_e2fs_flags |= 
d253 1
a253 1
		ip->i_e2fs_flags |= 
d298 1
a298 1
			((vap->va_vaflags & VA_UTIMES_NULL) == 0 || 
d597 1
a597 1
                	error = VOP_ACCESS(tvp, VWRITE, tcnp->cn_cred, 
d650 1
a650 1
	 * as to be able to change "..". We must repeat the call 
d677 1
a677 1
	 *    to the source and unlink the source. 
d831 1
a831 1
				UIO_SYSSPACE, IO_NODELOCKED, 
d1101 1
a1101 1
bad:	
d1179 1
a1179 1
	if ((error = ext2fs_inode_alloc(pdir, mode, cnp->cn_cred, &tvp)) 
d1251 1
a1251 1
	if (prtactive && vp->v_usecount != 0) 
@


1.63
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.62 2013/03/28 03:29:44 guenther Exp $	*/
a169 1
	struct timeval tv;
d171 1
a171 2
	getmicrotime(&tv);
	EXT2FS_ITIMES(ip, &tv, &tv);
d308 6
a313 1
		error = ext2fs_update(ip, &vap->va_atime, &vap->va_mtime, 1);
d466 1
a466 1
	error = ext2fs_update(ip, NULL, NULL, 1);
d639 1
a639 1
	if ((error = ext2fs_update(ip, NULL, NULL, 1)) != 0) {
d697 1
a697 1
			if ((error = ext2fs_update(dp, NULL, NULL, 1)) != 0)
d705 1
a705 1
				(void)ext2fs_update(dp, NULL, NULL, 1);
d923 1
a923 1
	error = ext2fs_update(ip, NULL, NULL, 1);
d933 1
a933 1
	if ((error = ext2fs_update(dp, NULL, NULL, 1)) != 0)
d1200 1
a1200 1
	if ((error = ext2fs_update(ip, NULL, NULL, 1)) != 0)
d1236 1
a1236 2
	return (ext2fs_update(VTOI(ap->a_vp), NULL, NULL, 
		    ap->a_waitfor == MNT_WAIT));
@


1.62
log
@Add support for _PC_TIMESTAMP_RESOLUTION for ffs/mfs, cd9600, ext2,
msdos, NFS, fifos and devices, plus support for querying it in
getconf(2) and the requisite pathconf(2) manpage blurb

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.61 2011/07/04 20:35:35 deraadt Exp $	*/
d934 1
a934 1
	bzero(&dirtemplate, sizeof(dirtemplate));
d1089 1
a1089 1
		bcopy(ap->a_target, (char *)ip->i_e2din->e2di_shortlink, len);
@


1.61
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.60 2011/07/03 18:23:10 tedu Exp $	*/
d1124 20
d1309 1
a1309 1
        .vop_pathconf   = ufs_pathconf,
@


1.60
log
@correctify NULL 0 confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.59 2011/04/05 14:14:07 thib Exp $	*/
d58 1
a62 1
#include <miscfs/specfs/specdev.h>
@


1.59
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.58 2010/12/21 20:14:44 thib Exp $	*/
d122 1
a122 1
	*vpp = 0;
@


1.58
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.57 2010/09/23 18:49:39 oga Exp $	*/
a1257 1
        .vop_default    = eopnotsupp,
a1294 1
        .vop_default    = eopnotsupp,
a1335 1
        .vop_default    = eopnotsupp,
@


1.57
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.56 2010/09/10 16:34:09 thib Exp $	*/
d1257 36
a1292 38
int (**ext2fs_vnodeop_p)(void *);
struct vnodeopv_entry_desc ext2fs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, ext2fs_lookup },
	{ &vop_create_desc, ext2fs_create },
	{ &vop_mknod_desc, ext2fs_mknod },
	{ &vop_open_desc, ext2fs_open },
	{ &vop_close_desc, ufs_close },
	{ &vop_access_desc, ext2fs_access },
	{ &vop_getattr_desc, ext2fs_getattr },
	{ &vop_setattr_desc, ext2fs_setattr },
	{ &vop_read_desc, ext2fs_read },
	{ &vop_write_desc, ext2fs_write },
	{ &vop_ioctl_desc, ufs_ioctl },
	{ &vop_poll_desc, ufs_poll },
	{ &vop_kqfilter_desc, vop_generic_kqfilter },
	{ &vop_fsync_desc, ext2fs_fsync },
	{ &vop_remove_desc, ext2fs_remove },
	{ &vop_link_desc, ext2fs_link },
	{ &vop_rename_desc, ext2fs_rename },
	{ &vop_mkdir_desc, ext2fs_mkdir },
	{ &vop_rmdir_desc, ext2fs_rmdir },
	{ &vop_symlink_desc, ext2fs_symlink },
	{ &vop_readdir_desc, ext2fs_readdir },
	{ &vop_readlink_desc, ext2fs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, ext2fs_inactive },
	{ &vop_reclaim_desc, ext2fs_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_bmap_desc, ext2fs_bmap },
	{ &vop_strategy_desc, ufs_strategy },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ &vop_pathconf_desc, ufs_pathconf },
	{ &vop_advlock_desc, ext2fs_advlock },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a1293 2
struct vnodeopv_desc ext2fs_vnodeop_opv_desc =
	{ &ext2fs_vnodeop_p, ext2fs_vnodeop_entries };
d1295 39
a1333 17
int (**ext2fs_specop_p)(void *);
struct vnodeopv_entry_desc ext2fs_specop_entries[] = {
	{ &vop_default_desc, spec_vnoperate },
	{ &vop_close_desc, ufsspec_close },
	{ &vop_access_desc, ext2fs_access },
	{ &vop_getattr_desc, ext2fs_getattr },
	{ &vop_setattr_desc, ext2fs_setattr },
	{ &vop_read_desc, ufsspec_read },
	{ &vop_write_desc, ufsspec_write },
	{ &vop_fsync_desc, ext2fs_fsync },
	{ &vop_inactive_desc, ext2fs_inactive },
	{ &vop_reclaim_desc, ext2fs_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ NULL, NULL }
a1334 2
struct vnodeopv_desc ext2fs_specop_opv_desc =
	{ &ext2fs_specop_p, ext2fs_specop_entries };
d1337 39
a1375 18
int (**ext2fs_fifoop_p)(void *);
struct vnodeopv_entry_desc ext2fs_fifoop_entries[] = {
	{ &vop_default_desc, fifo_vnoperate },
	{ &vop_close_desc, ufsfifo_close },
	{ &vop_access_desc, ext2fs_access },
	{ &vop_getattr_desc, ext2fs_getattr },
	{ &vop_setattr_desc, ext2fs_setattr },
	{ &vop_read_desc, ufsfifo_read },
	{ &vop_write_desc, ufsfifo_write },
	{ &vop_fsync_desc, ext2fs_fsync },
	{ &vop_inactive_desc, ext2fs_inactive },
	{ &vop_reclaim_desc, ext2fsfifo_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a1376 2
struct vnodeopv_desc ext2fs_fifoop_opv_desc =
	{ &ext2fs_fifoop_p, ext2fs_fifoop_entries };
@


1.56
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.55 2010/09/09 10:37:04 thib Exp $	*/
d829 1
a829 1
				tcnp->cn_cred, (size_t *)0, (struct proc *)0);
d844 1
a844 2
					    tcnp->cn_cred, (size_t *)0,
					    (struct proc *)0);
d953 1
a953 1
	    IO_NODELOCKED|IO_SYNC, cnp->cn_cred, (size_t *)0, (struct proc *)0);
d1097 1
a1097 1
		    (struct proc *)0);
@


1.55
log
@Rename lookup/relookup to vfs_lookup/vfs_relookup.

OK oga@@, beck@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.54 2010/09/06 23:44:10 thib Exp $	*/
d1258 38
a1295 36
struct vops ext2fs_vops = {
        .vop_default    = eopnotsupp,
        .vop_lookup     = ext2fs_lookup,
        .vop_create     = ext2fs_create,
        .vop_mknod      = ext2fs_mknod,
        .vop_open       = ext2fs_open,
        .vop_close      = ufs_close,
        .vop_access     = ext2fs_access,
        .vop_getattr    = ext2fs_getattr,
        .vop_setattr    = ext2fs_setattr,
        .vop_read       = ext2fs_read,
        .vop_write      = ext2fs_write,
        .vop_ioctl      = ufs_ioctl,
        .vop_poll       = ufs_poll,
        .vop_kqfilter   = vop_generic_kqfilter,
        .vop_fsync      = ext2fs_fsync,
        .vop_remove     = ext2fs_remove,
        .vop_link       = ext2fs_link,
        .vop_rename     = ext2fs_rename,
        .vop_mkdir      = ext2fs_mkdir,
        .vop_rmdir      = ext2fs_rmdir,
        .vop_symlink    = ext2fs_symlink,
        .vop_readdir    = ext2fs_readdir,
        .vop_readlink   = ext2fs_readlink,
        .vop_abortop    = vop_generic_abortop,
        .vop_inactive   = ext2fs_inactive,
        .vop_reclaim    = ext2fs_reclaim,
        .vop_lock       = ufs_lock,
        .vop_unlock     = ufs_unlock,
        .vop_bmap       = ext2fs_bmap,
        .vop_strategy   = ufs_strategy,
        .vop_print      = ufs_print,
        .vop_islocked   = ufs_islocked,
        .vop_pathconf   = ufs_pathconf,
        .vop_advlock    = ext2fs_advlock,
        .vop_bwrite     = vop_generic_bwrite
d1297 2
d1300 17
a1316 39
struct vops ext2fs_specvops = {
        .vop_default    = eopnotsupp,
        .vop_close      = ufsspec_close,
        .vop_access     = ext2fs_access,
        .vop_getattr    = ext2fs_getattr,
        .vop_setattr    = ext2fs_setattr,
        .vop_read       = ufsspec_read,
        .vop_write      = ufsspec_write,
        .vop_fsync      = ext2fs_fsync,
        .vop_inactive   = ext2fs_inactive,
        .vop_reclaim    = ext2fs_reclaim,
        .vop_lock       = ufs_lock,
        .vop_unlock     = ufs_unlock,
        .vop_print      = ufs_print,
        .vop_islocked   = ufs_islocked,

        /* XXX: Keep in sync with spec_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
d1318 2
d1322 18
a1339 39
struct vops ext2fs_fifovops = {
        .vop_default    = eopnotsupp,
        .vop_close      = ufsfifo_close,
        .vop_access     = ufsfifo_close,
        .vop_getattr    = ext2fs_getattr,
        .vop_setattr    = ext2fs_setattr,
        .vop_read       = ufsfifo_read,
        .vop_write      = ufsfifo_write,
        .vop_fsync      = ext2fs_fsync,
        .vop_inactive   = ext2fs_inactive,
        .vop_reclaim    = ext2fsfifo_reclaim,
        .vop_lock       = ufs_lock,
        .vop_unlock     = ufs_unlock,
        .vop_print      = ufs_print,
        .vop_islocked   = ufs_islocked,
        .vop_bwrite     = vop_generic_bwrite,

        /* XXX: Keep in sync with fifo_vops */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock,
d1341 2
@


1.54
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.53 2010/08/02 02:03:22 matthew Exp $	*/
d573 1
a573 1
		(void) relookup(fdvp, &fvp, fcnp);
d665 1
a665 1
		if ((error = relookup(tdvp, &tvp, tcnp)) != 0)
d790 1
a790 1
	(void) relookup(fdvp, &fvp, fcnp);
@


1.53
log
@Fix readlink(2) on FFS and ext2 filesystems to consistently return
EFAULT when appropriate.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.52 2009/08/13 15:00:14 jasper Exp $	*/
d1258 36
a1293 38
int (**ext2fs_vnodeop_p)(void *);
struct vnodeopv_entry_desc ext2fs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, ext2fs_lookup },
	{ &vop_create_desc, ext2fs_create },
	{ &vop_mknod_desc, ext2fs_mknod },
	{ &vop_open_desc, ext2fs_open },
	{ &vop_close_desc, ufs_close },
	{ &vop_access_desc, ext2fs_access },
	{ &vop_getattr_desc, ext2fs_getattr },
	{ &vop_setattr_desc, ext2fs_setattr },
	{ &vop_read_desc, ext2fs_read },
	{ &vop_write_desc, ext2fs_write },
	{ &vop_ioctl_desc, ufs_ioctl },
	{ &vop_poll_desc, ufs_poll },
	{ &vop_kqfilter_desc, vop_generic_kqfilter },
	{ &vop_fsync_desc, ext2fs_fsync },
	{ &vop_remove_desc, ext2fs_remove },
	{ &vop_link_desc, ext2fs_link },
	{ &vop_rename_desc, ext2fs_rename },
	{ &vop_mkdir_desc, ext2fs_mkdir },
	{ &vop_rmdir_desc, ext2fs_rmdir },
	{ &vop_symlink_desc, ext2fs_symlink },
	{ &vop_readdir_desc, ext2fs_readdir },
	{ &vop_readlink_desc, ext2fs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, ext2fs_inactive },
	{ &vop_reclaim_desc, ext2fs_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_bmap_desc, ext2fs_bmap },
	{ &vop_strategy_desc, ufs_strategy },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ &vop_pathconf_desc, ufs_pathconf },
	{ &vop_advlock_desc, ext2fs_advlock },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a1294 2
struct vnodeopv_desc ext2fs_vnodeop_opv_desc =
	{ &ext2fs_vnodeop_p, ext2fs_vnodeop_entries };
d1296 39
a1334 17
int (**ext2fs_specop_p)(void *);
struct vnodeopv_entry_desc ext2fs_specop_entries[] = {
	{ &vop_default_desc, spec_vnoperate },
	{ &vop_close_desc, ufsspec_close },
	{ &vop_access_desc, ext2fs_access },
	{ &vop_getattr_desc, ext2fs_getattr },
	{ &vop_setattr_desc, ext2fs_setattr },
	{ &vop_read_desc, ufsspec_read },
	{ &vop_write_desc, ufsspec_write },
	{ &vop_fsync_desc, ext2fs_fsync },
	{ &vop_inactive_desc, ext2fs_inactive },
	{ &vop_reclaim_desc, ext2fs_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ NULL, NULL }
a1335 2
struct vnodeopv_desc ext2fs_specop_opv_desc =
	{ &ext2fs_specop_p, ext2fs_specop_entries };
d1338 39
a1376 18
int (**ext2fs_fifoop_p)(void *);
struct vnodeopv_entry_desc ext2fs_fifoop_entries[] = {
	{ &vop_default_desc, fifo_vnoperate },
	{ &vop_close_desc, ufsfifo_close },
	{ &vop_access_desc, ext2fs_access },
	{ &vop_getattr_desc, ext2fs_getattr },
	{ &vop_setattr_desc, ext2fs_setattr },
	{ &vop_read_desc, ufsfifo_read },
	{ &vop_write_desc, ufsfifo_write },
	{ &vop_fsync_desc, ext2fs_fsync },
	{ &vop_inactive_desc, ext2fs_inactive },
	{ &vop_reclaim_desc, ext2fsfifo_reclaim },
	{ &vop_lock_desc, ufs_lock },
	{ &vop_unlock_desc, ufs_unlock },
	{ &vop_print_desc, ufs_print },
	{ &vop_islocked_desc, ufs_islocked },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a1377 2
struct vnodeopv_desc ext2fs_fifoop_opv_desc =
	{ &ext2fs_fifoop_p, ext2fs_fifoop_entries };
@


1.52
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.51 2008/06/09 23:38:37 millert Exp $	*/
d1118 2
a1119 2
		uiomove((char *)ip->i_e2din->e2di_shortlink, isize, ap->a_uio);
		return (0);
@


1.51
log
@Update access(2) to have modern semantics with respect to X_OK and
the superuser.  access(2) will now only indicate success for X_OK on
non-directories if there is at least one execute bit set on the file.
OK deraadt@@ thib@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.50 2008/05/08 17:45:45 thib Exp $	*/
d1261 34
a1294 34
	{ &vop_lookup_desc, ext2fs_lookup },	/* lookup */
	{ &vop_create_desc, ext2fs_create },	/* create */
	{ &vop_mknod_desc, ext2fs_mknod },		/* mknod */
	{ &vop_open_desc, ext2fs_open },		/* open */
	{ &vop_close_desc, ufs_close },			/* close */
	{ &vop_access_desc, ext2fs_access },	/* access */
	{ &vop_getattr_desc, ext2fs_getattr },	/* getattr */
	{ &vop_setattr_desc, ext2fs_setattr },	/* setattr */
	{ &vop_read_desc, ext2fs_read },		/* read */
	{ &vop_write_desc, ext2fs_write },		/* write */
	{ &vop_ioctl_desc, ufs_ioctl },			/* ioctl */
	{ &vop_poll_desc, ufs_poll },		/* poll */
	{ &vop_kqfilter_desc, vop_generic_kqfilter },	/* kqfilter */
	{ &vop_fsync_desc, ext2fs_fsync },		/* fsync */
	{ &vop_remove_desc, ext2fs_remove },	/* remove */
	{ &vop_link_desc, ext2fs_link },		/* link */
	{ &vop_rename_desc, ext2fs_rename },	/* rename */
	{ &vop_mkdir_desc, ext2fs_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, ext2fs_rmdir },		/* rmdir */
	{ &vop_symlink_desc, ext2fs_symlink },	/* symlink */
	{ &vop_readdir_desc, ext2fs_readdir },	/* readdir */
	{ &vop_readlink_desc, ext2fs_readlink },/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },		/* abortop */
	{ &vop_inactive_desc, ext2fs_inactive },/* inactive */
	{ &vop_reclaim_desc, ext2fs_reclaim },	/* reclaim */
	{ &vop_lock_desc, ufs_lock },			/* lock */
	{ &vop_unlock_desc, ufs_unlock },		/* unlock */
	{ &vop_bmap_desc, ext2fs_bmap },		/* bmap */
	{ &vop_strategy_desc, ufs_strategy },	/* strategy */
	{ &vop_print_desc, ufs_print },			/* print */
	{ &vop_islocked_desc, ufs_islocked },	/* islocked */
	{ &vop_pathconf_desc, ufs_pathconf },	/* pathconf */
	{ &vop_advlock_desc, ext2fs_advlock },	/* advlock */
	{ &vop_bwrite_desc, vop_generic_bwrite },		/* bwrite */
d1303 13
a1315 13
	{ &vop_close_desc, ufsspec_close },		/* close */
	{ &vop_access_desc, ext2fs_access },	/* access */
	{ &vop_getattr_desc, ext2fs_getattr },	/* getattr */
	{ &vop_setattr_desc, ext2fs_setattr },	/* setattr */
	{ &vop_read_desc, ufsspec_read },		/* read */
	{ &vop_write_desc, ufsspec_write },		/* write */
	{ &vop_fsync_desc, ext2fs_fsync },		/* fsync */
	{ &vop_inactive_desc, ext2fs_inactive },/* inactive */
	{ &vop_reclaim_desc, ext2fs_reclaim },	/* reclaim */
	{ &vop_lock_desc, ufs_lock },			/* lock */
	{ &vop_unlock_desc, ufs_unlock },		/* unlock */
	{ &vop_print_desc, ufs_print },			/* print */
	{ &vop_islocked_desc, ufs_islocked },	/* islocked */
d1325 14
a1338 14
	{ &vop_close_desc, ufsfifo_close },		/* close */
	{ &vop_access_desc, ext2fs_access },	/* access */
	{ &vop_getattr_desc, ext2fs_getattr },	/* getattr */
	{ &vop_setattr_desc, ext2fs_setattr },	/* setattr */
	{ &vop_read_desc, ufsfifo_read },		/* read */
	{ &vop_write_desc, ufsfifo_write },		/* write */
	{ &vop_fsync_desc, ext2fs_fsync },		/* fsync */
	{ &vop_inactive_desc, ext2fs_inactive },/* inactive */
	{ &vop_reclaim_desc, ext2fsfifo_reclaim },	/* reclaim */
	{ &vop_lock_desc, ufs_lock },			/* lock */
	{ &vop_unlock_desc, ufs_unlock },		/* unlock */
	{ &vop_print_desc, ufs_print },			/* print */
	{ &vop_islocked_desc, ufs_islocked },	/* islocked */
	{ &vop_bwrite_desc, vop_generic_bwrite },		/* bwrite */
@


1.50
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.49 2007/09/23 20:15:07 millert Exp $	*/
d158 2
a159 2
	return (vaccess(ip->i_e2fs_mode, ip->i_e2fs_uid, ip->i_e2fs_gid, mode,
			ap->a_cred));
@


1.49
log
@Move notatime check from ffs_update() to ffs_read() and ufs_setattr().
Fixes a couple cases where atime was being updated even when the
filesystem was mounted with the noatime option.
Adapted from similar placement in FreeBSD and NetBSD.
Tested by myself and naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.48 2007/06/17 20:15:25 jasper Exp $	*/
d1260 1
a1260 1
	{ &vop_default_desc, vn_default_error },
@


1.48
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.47 2007/06/01 23:47:57 deraadt Exp $	*/
a302 3
		if (vap->va_atime.tv_sec != VNOVAL)
			if (!(vp->v_mount->mnt_flag & MNT_NOATIME))
				ip->i_flag |= IN_ACCESS;
d305 5
@


1.47
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.46 2007/04/10 17:47:56 miod Exp $	*/
d80 1
a80 2
ext2fs_create(v)
	void *v;
d93 1
a93 2
ext2fs_mknod(v)
	void *v;
d96 3
a98 3
	register struct vattr *vap = ap->a_vap;
	register struct vnode **vpp = ap->a_vpp;
	register struct inode *ip;
d133 1
a133 2
ext2fs_open(v)
	void *v;
d147 1
a147 2
ext2fs_access(v)
	void *v;
d150 2
a151 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d164 1
a164 2
ext2fs_getattr(v)
	void *v;
d167 3
a169 3
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
	register struct vattr *vap = ap->a_vap;
d216 1
a216 2
ext2fs_setattr(v)
	void *v;
d219 5
a223 5
	register struct vattr *vap = ap->a_vap;
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
	register struct ucred *cred = ap->a_cred;
	register struct proc *p = ap->a_p;
d326 1
a326 5
ext2fs_chmod(vp, mode, cred, p)
	register struct vnode *vp;
	register mode_t mode;
	register struct ucred *cred;
	struct proc *p;
d328 1
a328 1
	register struct inode *ip = VTOI(vp);
d352 1
a352 6
ext2fs_chown(vp, uid, gid, cred, p)
	register struct vnode *vp;
	uid_t uid;
	gid_t gid;
	struct ucred *cred;
	struct proc *p;
d354 1
a354 1
	register struct inode *ip = VTOI(vp);
d387 1
a387 2
ext2fs_remove(v)
	void *v;
d390 3
a392 3
	register struct inode *ip;
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
d420 1
a420 2
ext2fs_link(v)
	void *v;
d423 3
a425 3
	register struct vnode *dvp = ap->a_dvp;
	register struct vnode *vp = ap->a_vp;
	register struct componentname *cnp = ap->a_cnp;
d427 1
a427 1
	register struct inode *ip;
d502 1
a502 2
ext2fs_rename(v)
	void *v;
d506 1
a506 1
	register struct vnode *tdvp = ap->a_tdvp;
d508 4
a511 4
	register struct vnode *fdvp = ap->a_fdvp;
	register struct componentname *tcnp = ap->a_tcnp;
	register struct componentname *fcnp = ap->a_fcnp;
	register struct inode *ip, *xp, *dp;
d514 1
a514 1
	//struct timespec ts;
d882 1
a882 2
ext2fs_mkdir(v)
	void *v;
d885 4
a888 4
	register struct vnode *dvp = ap->a_dvp;
	register struct vattr *vap = ap->a_vap;
	register struct componentname *cnp = ap->a_cnp;
	register struct inode *ip, *dp;
d998 1
a998 2
ext2fs_rmdir(v)
	void *v;
d1001 4
a1004 4
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
	register struct componentname *cnp = ap->a_cnp;
	register struct inode *ip, *dp;
d1073 1
a1073 2
ext2fs_symlink(v)
	void *v;
d1076 2
a1077 2
	register struct vnode *vp, **vpp = ap->a_vpp;
	register struct inode *ip;
d1106 1
a1106 2
ext2fs_readlink(v)
	void *v;
d1109 2
a1110 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d1126 1
a1126 2
ext2fs_advlock(v)
	void *v;
d1129 1
a1129 1
	register struct inode *ip = VTOI(ap->a_vp);
d1139 2
a1140 5
ext2fs_makeinode(mode, dvp, vpp, cnp)
	int mode;
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
d1142 1
a1142 1
	register struct inode *ip, *pdir;
d1206 1
a1206 2
ext2fs_fsync(v)
	void *v;
d1209 1
a1209 1
	register struct vnode *vp = ap->a_vp;
d1220 1
a1220 2
ext2fs_reclaim(v)
	void *v;
d1223 1
a1223 1
	register struct vnode *vp = ap->a_vp;
@


1.46
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.45 2007/01/16 17:52:18 thib Exp $	*/
d83 1
a83 6
	struct vop_create_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d97 1
a97 6
	struct vop_mknod_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d138 1
a138 6
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d153 1
a153 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d171 1
a171 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d224 1
a224 6
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d405 1
a405 5
	struct vop_remove_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d439 1
a439 5
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d522 1
a522 8
	struct vop_rename_args  /* {
		struct vnode *a_fdvp;
		struct vnode *a_fvp;
		struct componentname *a_fcnp;
		struct vnode *a_tdvp;
		struct vnode *a_tvp;
		struct componentname *a_tcnp;
	} */ *ap = v;
d903 1
a903 6
	struct vop_mkdir_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d1020 1
a1020 5
	struct vop_rmdir_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d1096 1
a1096 7
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
d1130 1
a1130 5
	struct vop_readlink_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *ap = v;
d1151 1
a1151 7
	struct vop_advlock_args /* {
		struct vnode *a_vp;
		caddr_t  a_id;
		int  a_op;
		struct flock *a_fl;
		int  a_flags;
	} */ *ap = v;
d1235 1
a1235 6
	struct vop_fsync_args /* {
		struct vnode *a_vp;
		struct ucred *a_cred;
		int a_waitfor;
		struct proc *a_p;
	} */ *ap = v;
d1250 1
a1250 3
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
@


1.45
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.44 2006/01/09 12:43:17 pedro Exp $	*/
d1040 1
a1040 1
	/* Directory set up, now install it's entry in the parent directory. */
@


1.44
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.43 2005/12/14 22:03:01 pedro Exp $	*/
a1373 1
	{ &vop_lease_desc, ufs_lease_check },	/* lease */
@


1.43
log
@Make ext2fs use a memory pool to allocate inodes, okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.42 2005/12/11 20:46:28 pedro Exp $	*/
d1330 1
d1335 1
@


1.42
log
@inode/dinode separation for ext2fs
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.41 2005/08/14 12:41:44 pedro Exp $	*/
d1351 1
a1351 1
	FREE(vp->v_data, M_EXT2FSNODE);
@


1.41
log
@When leaving ext2fs_symlink(), unlock the vnode on both error and
non-error cases, so that later on we don't deadlock trying to look it
up. Fixes buglet introduced in revision 1.38, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.40 2005/07/28 22:37:39 pedro Exp $	*/
a72 1

a75 17
union _qcvt {
	int64_t	qcvt;
	int32_t val[2];
};
#define SETHIGH(q, h) { \
	union _qcvt tmp; \
	tmp.qcvt = (q); \
	tmp.val[_QUAD_HIGHWORD] = (h); \
	(q) = tmp.qcvt; \
}
#define SETLOW(q, l) { \
	union _qcvt tmp; \
	tmp.qcvt = (q); \
	tmp.val[_QUAD_LOWWORD] = (l); \
	(q) = tmp.qcvt; \
}

d124 1
a124 1
		ip->i_e2din.e2di_rdev = h2fs32(vap->va_rdev);
d213 1
a213 1
	vap->va_rdev = (dev_t)fs2h32(ip->i_e2din.e2di_rdev);
d1169 1
a1169 1
		bcopy(ap->a_target, (char *)ip->i_e2din.e2di_shortlink, len);
d1202 1
a1202 1
		uiomove((char *)ip->i_e2din.e2di_shortlink, isize, ap->a_uio);
d1348 3
d1352 1
@


1.40
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.39 2005/07/03 20:14:01 drahn Exp $	*/
d1197 1
a1197 2
	if (error)
		vput(vp);
@


1.39
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.38 2005/04/30 13:58:55 niallo Exp $	*/
d1351 15
a1365 14
    if (prtactive && vp->v_usecount != 0) 
        vprint("ext2fs_reclaim: pushing active", vp);
    /*
     * Remove the inode from its hash chain.
     */
    ip = VTOI(vp);
    ufs_ihashrem(ip);
    /*
     * Purge old data structures associated with the inode.
     */
    cache_purge(vp);
    if (ip->i_devvp) {
        vrele(ip->i_devvp);
    }
d1369 1
@


1.38
log
@Add support for large files (> 4GB).

Automatically converts old filesystems to use this if they are already at
revision 1 (like Linux). Revision 0 filesystems don't get converted (unlike
Linux).

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.37 2004/09/18 22:01:18 tedu Exp $	*/
a63 1
#include <ufs/ufs/extattr.h>
@


1.37
log
@hierarchy is spelled hierarchy, from Jonathan Gray
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.36 2004/07/13 21:04:29 millert Exp $	*/
d233 1
a233 1
	vap->va_size = ip->i_e2fs_size;
d1050 6
a1055 1
		ip->i_e2fs_size = VTOI(dvp)->i_e2fs->e2fs_bsize;
d1189 3
a1191 1
		ip->i_e2fs_size = len;
d1197 3
a1199 1
	vput(vp);
d1219 1
a1219 1
	isize = ip->i_e2fs_size;
d1244 1
a1244 1
	return (lf_advlock(&ip->i_lockf, ip->i_e2fs_size, ap->a_id, ap->a_op,
@


1.36
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.35 2004/06/24 19:35:26 tholo Exp $	*/
d724 1
a724 1
	 * directory heirarchy above the target, as this would
@


1.35
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.34 2004/05/14 04:00:34 tedu Exp $	*/
d75 1
a75 1
static int ext2fs_chmod(struct vnode *, int, struct ucred *, struct proc *);
d383 1
a383 1
	register int mode;
d979 2
a980 1
	int error, dmode;
@


1.34
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.33 2004/03/02 05:52:24 tedu Exp $	*/
d219 1
d221 2
a222 1
	EXT2FS_ITIMES(ip, &time, &time);
@


1.33
log
@call fifo_reclaim here too
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.32 2004/01/20 03:44:06 tedu Exp $	*/
d540 1
a540 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d1069 1
a1069 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d1261 1
a1261 1
		free(cnp->cn_pnbuf, M_NAMEI);
d1286 1
a1286 1
		FREE(cnp->cn_pnbuf, M_NAMEI);
d1296 1
a1296 1
	free(cnp->cn_pnbuf, M_NAMEI);
@


1.32
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.31 2003/09/23 16:51:13 millert Exp $	*/
d1437 1
a1437 1
	{ &vop_reclaim_desc, ext2fs_reclaim },	/* reclaim */
d1447 7
@


1.31
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.30 2003/08/25 23:26:55 tedu Exp $	*/
a1352 1
        ip->i_devvp = 0;
@


1.30
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
few other little cleanups.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.29 2003/08/15 20:32:20 tedu Exp $	*/
d1377 1
a1377 1
	{ &vop_select_desc, ufs_select },		/* select */
@


1.30.2.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.30 2003/08/25 23:26:55 tedu Exp $	*/
d1438 1
a1438 1
	{ &vop_reclaim_desc, ext2fsfifo_reclaim },	/* reclaim */
a1447 7

int
ext2fsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (ext2fs_reclaim(v));
}
@


1.29
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.28 2003/08/11 21:53:10 tedu Exp $	*/
d143 1
a143 1
		ip->i_din.e2fs_din.e2di_rdev = h2fs32(vap->va_rdev);
d230 1
a230 1
	vap->va_rdev = (dev_t)fs2h32(ip->i_din.e2fs_din.e2di_rdev);
d1180 1
a1180 1
		bcopy(ap->a_target, (char *)ip->i_din.e2fs_din.e2di_shortlink, len);
d1210 1
a1210 1
		uiomove((char *)ip->i_din.e2fs_din.e2di_shortlink, isize, ap->a_uio);
@


1.28
log
@if we run out of space, make the dead vnode VNON.  if a VBLK gets out, it
causes trouble later.  netbsd pr22419
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.27 2003/07/06 09:07:18 tedu Exp $	*/
d292 1
a292 1
			(error = suser(cred, &p->p_acflag)))
d352 1
a352 1
			(error = suser(cred, &p->p_acflag)) &&
d388 1
a388 2
	if (cred->cr_uid != ip->i_e2fs_uid &&
		(error = suser(cred, &p->p_acflag)))
d432 1
a432 1
		(error = suser(cred, &p->p_acflag)))
d1274 1
a1274 1
	    suser(cnp->cn_cred, NULL))
@


1.27
log
@remove ext2fs_vinit.  it wasn't used and is identical to ufs_vinit.
otto made the diff for me, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.26 2003/06/02 23:28:22 millert Exp $	*/
d1301 1
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.25 2002/11/08 04:34:18 art Exp $	*/
a1234 67
}

/*
 * Initialize the vnode associated with a new inode, handle aliased
 * vnodes.
 */
int
ext2fs_vinit(mntp, specops, fifoops, vpp)
	struct mount *mntp;
	int (**specops)(void *);
	int (**fifoops)(void *);
	struct vnode **vpp;
{
	struct inode *ip;
	struct vnode *vp, *nvp;
	struct proc *p = curproc;

	vp = *vpp;
	ip = VTOI(vp);
	switch(vp->v_type = IFTOVT(ip->i_e2fs_mode)) {
	case VCHR:
	case VBLK:
		vp->v_op = specops;
		if ((nvp = checkalias(vp, ip->i_din.e2fs_din.e2di_rdev, mntp))
			!= NULL) {
			/*
			 * Discard unneeded vnode, but save its inode.
			 */
			ufs_ihashrem(ip);
			VOP_UNLOCK(vp, 0, p);
			nvp->v_data = vp->v_data;
			vp->v_data = NULL;
			vp->v_op = spec_vnodeop_p;
			vrele(vp);
			vgone(vp);
			/*
			 * Reinitialize aliased inode.
			 */
			vp = nvp;
			ip->i_vnode = vp;
			ufs_ihashins(ip);
		}
		break;
	case VFIFO:
#ifdef FIFO
		vp->v_op = fifoops;
		break;
#else
		return (EOPNOTSUPP);
#endif
	case VNON:
	case VBAD:
	case VSOCK:
	case VLNK:
	case VDIR:
	case VREG:
		break;
	}
	if (ip->i_number == ROOTINO)
                vp->v_flag |= VROOT;
	/*
	 * Initialize modrev times
	 */
	SETHIGH(ip->i_modrev, mono_time.tv_sec);
	SETLOW(ip->i_modrev, mono_time.tv_usec * 4294);
	*vpp = vp;
	return (0);
@


1.25
log
@Implement simple vnodeop inheritance for specfs and fifofs.

The inheritace is implemented by setting the default vnodeop to a
bypass op that repeats the operation on the spec/fifo vnodeop vector.
The overhead of one extra indirect function call is worth the cleanup
and improved correctness.

This actually solves a few bugs where some vnode ops were missing from
some vectors (like kqfilter or revoke). (and even more on the ubc
branch).

Inspired by the same thing done in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.24 2002/03/14 03:16:13 millert Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.25.2.1
log
@MFC:
Fix by tedu@@

if we run out of space, make the dead vnode VNON.  if a VBLK gets out, it
causes trouble later.  netbsd pr22419

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.25 2002/11/08 04:34:18 art Exp $	*/
a1371 1
	tvp->v_type = VNON;
@


1.25.2.2
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.25.2.1 2003/08/21 23:36:36 brad Exp $	*/
d1510 1
a1510 1
	{ &vop_reclaim_desc, ext2fsfifo_reclaim },	/* reclaim */
a1519 7

int
ext2fsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (ext2fs_reclaim(v));
}
@


1.24
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.23 2002/03/14 01:27:14 millert Exp $	*/
d1471 1
a1471 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d1478 1
a1478 5
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, spec_lookup },		/* lookup */
	{ &vop_create_desc, spec_create },		/* create */
	{ &vop_mknod_desc, spec_mknod },		/* mknod */
	{ &vop_open_desc, spec_open },			/* open */
a1484 4
	{ &vop_lease_desc, spec_lease_check },	/* lease */
	{ &vop_ioctl_desc, spec_ioctl },		/* ioctl */
	{ &vop_select_desc, spec_select },		/* poll */
	{ &vop_kqfilter_desc, spec_kqfilter },		/* kqfilter */
a1485 9
	{ &vop_remove_desc, spec_remove },		/* remove */
	{ &vop_link_desc, spec_link },			/* link */
	{ &vop_rename_desc, spec_rename },		/* rename */
	{ &vop_mkdir_desc, spec_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, spec_rmdir },		/* rmdir */
	{ &vop_symlink_desc, spec_symlink },	/* symlink */
	{ &vop_readdir_desc, spec_readdir },	/* readdir */
	{ &vop_readlink_desc, spec_readlink },	/* readlink */
	{ &vop_abortop_desc, spec_abortop },	/* abortop */
a1489 2
	{ &vop_bmap_desc, spec_bmap },			/* bmap */
	{ &vop_strategy_desc, spec_strategy },	/* strategy */
d1492 1
a1492 4
	{ &vop_pathconf_desc, spec_pathconf },	/* pathconf */
	{ &vop_advlock_desc, spec_advlock },	/* advlock */
	{ &vop_bwrite_desc, vop_generic_bwrite },		/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d1500 1
a1500 5
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, fifo_lookup },		/* lookup */
	{ &vop_create_desc, fifo_create },		/* create */
	{ &vop_mknod_desc, fifo_mknod },		/* mknod */
	{ &vop_open_desc, fifo_open },			/* open */
a1506 4
	{ &vop_lease_desc, fifo_lease_check },	/* lease */
	{ &vop_ioctl_desc, fifo_ioctl },		/* ioctl */
	{ &vop_select_desc, fifo_select },		/* select */
	{ &vop_kqfilter_desc, fifo_kqfilter },		/* kqfilter */
a1507 9
	{ &vop_remove_desc, fifo_remove },		/* remove */
	{ &vop_link_desc, fifo_link },			/* link */
	{ &vop_rename_desc, fifo_rename },		/* rename */
	{ &vop_mkdir_desc, fifo_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, fifo_rmdir },		/* rmdir */
	{ &vop_symlink_desc, fifo_symlink },	/* symlink */
	{ &vop_readdir_desc, fifo_readdir },	/* readdir */
	{ &vop_readlink_desc, fifo_readlink },	/* readlink */
	{ &vop_abortop_desc, fifo_abortop },	/* abortop */
a1511 2
	{ &vop_bmap_desc, fifo_bmap },			/* bmap */
	{ &vop_strategy_desc, fifo_strategy },	/* strategy */
a1513 2
	{ &vop_pathconf_desc, fifo_pathconf },	/* pathconf */
	{ &vop_advlock_desc, fifo_advlock },	/* advlock */
d1515 1
a1515 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.24.4.1
log
@MFC:
Fix by tedu@@

if we run out of space, make the dead vnode VNON.  if a VBLK gets out, it
causes trouble later.  netbsd pr22419

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.24 2002/03/14 03:16:13 millert Exp $	*/
a1371 1
	tvp->v_type = VNON;
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.22 2002/02/22 20:37:45 drahn Exp $	*/
d1471 1
a1471 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void*))NULL }
@


1.22
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.21 2001/12/19 08:58:07 art Exp $	*/
d79 2
a80 4
static int ext2fs_chmod
	__P((struct vnode *, int, struct ucred *, struct proc *));
static int ext2fs_chown
	__P((struct vnode *, uid_t, gid_t, struct ucred *, struct proc *));
d1248 2
a1249 2
	int (**specops) __P((void *));
	int (**fifoops) __P((void *));
d1433 1
a1433 1
int (**ext2fs_vnodeop_p) __P((void *));
d1471 1
a1471 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void*)))NULL }
d1476 1
a1476 1
int (**ext2fs_specop_p) __P((void *));
d1514 1
a1514 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d1520 1
a1520 1
int (**ext2fs_fifoop_p) __P((void *));
d1558 1
a1558 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.21
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.17 2001/11/06 19:53:21 miod Exp $	*/
d68 1
@


1.20
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_vnops.c,v 1.19 2001/12/04 22:44:32 art Exp $	*/
/*	$NetBSD: ext2fs_vnops.c,v 1.30 2000/11/27 08:39:53 chs Exp $	*/
d405 2
d1472 1
a1472 4
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_putpages_desc, genfs_putpages },
	{ &vop_mmap_desc, ufs_mmap },
	{ NULL, NULL }
d1515 1
a1515 2
	{ &vop_mmap_desc, spec_mmap },
	{ NULL, NULL }
d1559 1
a1559 2
	{ &vop_mmap_desc, fifo_mmap },
	{ NULL, NULL }
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.20 2001/12/10 04:45:31 art Exp $	*/
a67 1
#include <ufs/ufs/extattr.h>
d78 4
a81 2
static int ext2fs_chmod(struct vnode *, int, struct ucred *, struct proc *);
static int ext2fs_chown(struct vnode *, uid_t, gid_t, struct ucred *, struct proc *);
d1247 2
a1248 2
	int (**specops)(void *);
	int (**fifoops)(void *);
d1432 1
a1432 1
int (**ext2fs_vnodeop_p)(void *);
d1478 1
a1478 1
int (**ext2fs_specop_p)(void *);
d1523 1
a1523 1
int (**ext2fs_fifoop_p)(void *);
@


1.20.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.20.2.1 2002/06/11 03:32:50 art Exp $	*/
d1480 4
d1490 4
d1495 9
d1508 2
d1512 4
a1515 1
	SPEC_VNODEOP_DESCS,
d1525 4
d1536 3
d1540 9
d1554 1
d1557 2
d1560 1
a1560 1
	FIFO_VNODEOP_DESCS,
@


1.20.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1479 1
a1479 1
	{ &vop_default_desc, spec_vnoperate },
d1493 1
d1502 1
a1502 1
	{ &vop_default_desc, fifo_vnoperate },
d1509 1
d1515 1
d1519 1
@


1.20.2.4
log
@use vnode lock in place of inode lock, switch to genfs_lock
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.20.2.3 2003/05/19 22:38:11 tedu Exp $	*/
a65 1
#include <miscfs/genfs/genfs.h>
@


1.19
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.18 2001/11/27 05:27:12 art Exp $	*/
a1469 1
	{ &vop_ballocn_desc, ext2fs_ballocn },
a1471 1
	{ &vop_size_desc, genfs_size },
@


1.18
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.17 2001/11/06 19:53:21 miod Exp $	*/
d1474 1
d1518 2
a1519 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d1563 2
a1564 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_vnops.c,v 1.16 2001/07/26 20:24:47 millert Exp $	*/
/*	$NetBSD: ext2fs_vnops.c,v 1.1 1997/06/11 09:34:09 bouyer Exp $	*/
a404 2
	if ((vp->v_flag & VTEXT) && (ip->i_e2fs_mode & S_ISTXT) == 0)
		(void) uvm_vnp_uncache(vp);
d1470 5
a1474 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void*)))NULL }
@


1.16
log
@Back out changes to symlink and mknod that were not well tested.
A simple mknod at causes a kernel panic (uvm_fault).
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.14 2001/06/27 04:58:47 art Exp $	*/
a61 2

#include <vm/vm.h>
@


1.15
log
@change vop_symlink and vop_mknod to return vpp (the created node)
refed, so that the caller can actually use it.  update callers and
file systems that implement these vnode operations

ok'd by art
@
text
@a136 2
	struct mount *mp;	
	ino_t	     ino;
a160 5
	error = VFS_VGET(mp, ino, vpp);
	if (error != 0) {
		*vpp = NULL;
		return (error);
	}
d1195 1
a1195 2
	if (error)
		vput(vp);
@


1.14
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.13 2001/06/23 02:07:52 csapuntz Exp $	*/
d137 2
d163 5
d1202 2
a1203 1
	vput(vp);
@


1.13
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.12 2001/06/05 21:37:50 provos Exp $	*/
a407 1
#if defined(UVM)
a408 3
#else
		(void) vnode_pager_uncache(vp);
#endif
@


1.12
log
@make kqueue work on ext2fs
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.11 2000/04/26 23:24:42 jasoni Exp $	*/
d351 1
a351 1
		error = VOP_TRUNCATE(vp, vap->va_size, 0, cred, p);
a354 1
	ip = VTOI(vp);
d368 1
a368 1
		error = VOP_UPDATE(vp, &vap->va_atime, &vap->va_mtime, 1);
d545 1
a545 1
	error = VOP_UPDATE(vp, NULL, NULL, 1);
d726 1
a726 1
	if ((error = VOP_UPDATE(fvp, NULL, NULL, 1)) != 0) {
d784 1
a784 1
			if ((error = VOP_UPDATE(tdvp, NULL, NULL, 1)) != 0)
d792 1
a792 1
				(void)VOP_UPDATE(tdvp, NULL, NULL, 1);
d865 2
a866 2
			error = VOP_TRUNCATE(tvp, (off_t)0, IO_SYNC,
			    tcnp->cn_cred, tcnp->cn_proc);
d1007 1
a1007 1
	if ((error = VOP_VALLOC(dvp, dmode, cnp->cn_cred, &tvp)) != 0)
d1016 1
a1016 1
	error = VOP_UPDATE(tvp, NULL, NULL, 1);
d1026 1
a1026 1
	if ((error = VOP_UPDATE(dvp, NULL, NULL, 1)) != 0)
d1157 1
a1157 2
	error = VOP_TRUNCATE(vp, (off_t)0, IO_SYNC, cnp->cn_cred,
	    cnp->cn_proc);
a1325 1
	struct timespec ts;
d1338 2
a1339 1
	if ((error = VOP_VALLOC(dvp, mode, cnp->cn_cred, &tvp)) != 0) {
d1359 1
a1359 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	if ((error = VOP_UPDATE(tvp, &ts, &ts, 1)) != 0)
a1397 1
	struct timespec ts;
d1400 2
a1401 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	return (VOP_UPDATE(ap->a_vp, &ts, &ts, ap->a_waitfor == MNT_WAIT));
a1456 1
	{ &vop_mmap_desc, ufs_mmap },			/* mmap */
a1457 1
	{ &vop_seek_desc, ufs_seek },			/* seek */
a1476 5
	{ &vop_blkatoff_desc, ext2fs_blkatoff },/* blkatoff */
	{ &vop_valloc_desc, ext2fs_valloc },	/* valloc */
	{ &vop_vfree_desc, ext2fs_vfree },		/* vfree */
	{ &vop_truncate_desc, ext2fs_truncate },/* truncate */
	{ &vop_update_desc, ext2fs_update },	/* update */
a1499 1
	{ &vop_mmap_desc, spec_mmap },			/* mmap */
a1500 1
	{ &vop_seek_desc, spec_seek },			/* seek */
a1519 5
	{ &vop_blkatoff_desc, spec_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, spec_valloc },		/* valloc */
	{ &vop_vfree_desc, ext2fs_vfree },		/* vfree */
	{ &vop_truncate_desc, spec_truncate },	/* truncate */
	{ &vop_update_desc, ext2fs_update },	/* update */
a1543 1
	{ &vop_mmap_desc, fifo_mmap },			/* mmap */
a1544 1
	{ &vop_seek_desc, fifo_seek },			/* seek */
a1563 5
	{ &vop_blkatoff_desc, fifo_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, fifo_valloc },		/* valloc */
	{ &vop_vfree_desc, ext2fs_vfree },		/* vfree */
	{ &vop_truncate_desc, fifo_truncate },	/* truncate */
	{ &vop_update_desc, ext2fs_update },	/* update */
@


1.11
log
@Support for ext2fs rev. 1 (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.10 1999/02/26 16:35:33 millert Exp $	*/
d1460 1
d1510 1
d1561 1
@


1.10
log
@ext2fs is missing a LINK_MAX check too
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.9 1999/02/26 03:22:00 art Exp $	*/
d60 1
d65 2
d115 3
a117 3
	return
		ext2fs_makeinode(MAKEIMODE(ap->a_vap->va_type, ap->a_vap->va_mode),
			  ap->a_dvp, ap->a_vpp, ap->a_cnp);
d150 1
a150 1
		ip->i_din.e2fs_din.e2di_rdev = vap->va_rdev;
a203 7
#ifdef DIAGNOSTIC
	if (!VOP_ISLOCKED(vp)) {
		vprint("ext2fs_access: not locked", vp);
		panic("ext2fs_access: not locked");
	}
#endif

d237 1
a237 1
	vap->va_rdev = (dev_t)ip->i_din.e2fs_din.e2di_rdev;
d260 1
a260 1
	vap->va_bytes = dbtob(ip->i_e2fs_nblock);
d296 2
d303 2
a304 2
			if ((ip->i_e2fs_flags & (EXT2_APPEND | EXT2_IMMUTABLE)) &&
				securelevel > 0)
d307 3
a309 2
			ip->i_e2fs_flags |= (vap->va_flags & SF_APPEND) ? EXT2_APPEND : 0 |
					(vap->va_flags & SF_IMMUTABLE) ? EXT2_IMMUTABLE: 0;
d315 3
a317 2
		ip->i_e2fs_flags |= (vap->va_flags & UF_APPEND) ? EXT2_APPEND : 0 |
				(vap->va_flags & UF_IMMUTABLE) ? EXT2_IMMUTABLE: 0;
d329 2
d336 7
a342 1
		if (vp->v_type == VDIR)
d344 7
d357 2
d374 3
a376 1
	if (vap->va_mode != (mode_t)VNOVAL)
d378 1
d410 1
a410 1
		uvm_vnp_uncache(vp);
d477 2
a478 2
	    (ip->i_e2fs_flags & (EXT2_IMMUTABLE | EXT2_APPEND)) ||
	    (VTOI(dvp)->i_e2fs_flags & EXT2_APPEND)) {
a512 1
	struct timespec ts;
d529 1
a529 1
	if (dvp != vp && (error = vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p))) {
d546 1
a546 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	error = VOP_UPDATE(vp, &ts, &ts, 1);
d607 1
a607 1
	struct timespec ts;
d667 1
a667 1
	if ((error = vn_lock(fvp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
d683 9
a691 8
        error = VOP_ACCESS(fvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
        if (!error && tvp)
                error = VOP_ACCESS(tvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
        if (error) {
                VOP_UNLOCK(fvp, 0, p);
                error = EACCES;
                goto abortit;
        }
d727 1
a727 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	if ((error = VOP_UPDATE(fvp, &ts, &ts, 1)) != 0) {
d785 1
a785 1
			if ((error = VOP_UPDATE(tdvp, &ts, &ts, 1)) != 0)
d793 1
a793 1
				(void)VOP_UPDATE(tdvp, &ts, &ts, 1);
d920 1
a920 1
				tcnp->cn_cred, NULL, (struct proc *)0);
d929 1
a929 1
					dirbuf.dotdot_ino = newparent;
d935 1
a935 1
					    tcnp->cn_cred, NULL,
d962 1
a962 1
	if (vn_lock(fvp, LK_EXCLUSIVE | LK_RETRY, p) == 0) {
a971 8
 * A virgin directory (no blushing please).
 */
static struct ext2fs_dirtemplate mastertemplate = {
	0, 12, 1, ".",
	0, - 12, 2, ".." /* XXX -12 should be e2fs_bsize-12 */
};

/*
d989 1
a989 2
	struct ext2fs_dirtemplate dirtemplate, *dtp;
	struct timespec ts;
d1017 1
a1017 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	error = VOP_UPDATE(tvp, &ts, &ts, 1);
d1027 1
a1027 1
	if ((error = VOP_UPDATE(dvp, &ts, &ts, 1)) != 0)
d1031 17
a1047 6
	dtp = &mastertemplate;
	dirtemplate = *dtp;
	dirtemplate.dot_ino = ip->i_number;
	dirtemplate.dotdot_ino = dp->i_number;
	/* Correct reclen of second entry */
    dirtemplate.dotdot_reclen = VTOI(dvp)->i_e2fs->e2fs_bsize - 12;
d1050 1
a1050 1
	    IO_NODELOCKED|IO_SYNC, cnp->cn_cred, NULL, (struct proc *)0);
@


1.10.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.11 2000/04/26 23:24:42 jasoni Exp $	*/
a59 1
#include <sys/pool.h>
a63 2
#include <uvm/uvm_extern.h>

d112 3
a114 3
	return ext2fs_makeinode(MAKEIMODE(ap->a_vap->va_type, 
					  ap->a_vap->va_mode),
			  	ap->a_dvp, ap->a_vpp, ap->a_cnp);
d147 1
a147 1
		ip->i_din.e2fs_din.e2di_rdev = h2fs32(vap->va_rdev);
d201 7
d241 1
a241 1
	vap->va_rdev = (dev_t)fs2h32(ip->i_din.e2fs_din.e2di_rdev);
d264 1
a264 1
	vap->va_bytes = dbtob((u_quad_t)ip->i_e2fs_nblock);
a299 2
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
d305 2
a306 2
			if ((ip->i_e2fs_flags & 
			    (EXT2_APPEND | EXT2_IMMUTABLE)) && securelevel > 0)
d309 2
a310 3
			ip->i_e2fs_flags |= 
			    (vap->va_flags & SF_APPEND) ? EXT2_APPEND : 0 |
			    (vap->va_flags & SF_IMMUTABLE) ? EXT2_IMMUTABLE: 0;
d316 2
a317 3
		ip->i_e2fs_flags |= 
		    (vap->va_flags & UF_APPEND) ? EXT2_APPEND : 0 |
		    (vap->va_flags & UF_IMMUTABLE) ? EXT2_IMMUTABLE: 0;
a328 2
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
d334 1
a334 7
		/*
		 * Disallow write attempts on read-only file systems;
		 * unless the file is a socket, fifo, or a block or
		 * character device resident on the file system.
		 */
		switch (vp->v_type) {
		case VDIR:
a335 7
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
		default:
			break;
		}
a341 2
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
d357 1
a357 3
	if (vap->va_mode != (mode_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
a358 1
	}
d390 1
a390 1
		(void) uvm_vnp_uncache(vp);
d457 2
a458 2
		(ip->i_e2fs_flags & (EXT2_IMMUTABLE | EXT2_APPEND)) ||
	    	(VTOI(dvp)->i_e2fs_flags & EXT2_APPEND)) {
d493 1
d510 1
a510 1
	if (dvp != vp && (error = vn_lock(vp, LK_EXCLUSIVE, p))) {
d527 2
a528 1
	error = VOP_UPDATE(vp, NULL, NULL, 1);
d589 1
a589 1
	//struct timespec ts;
d649 1
a649 1
	if ((error = vn_lock(fvp, LK_EXCLUSIVE, p)) != 0)
d665 8
a672 9
        	error = VOP_ACCESS(fvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
        	if (!error && tvp)
                	error = VOP_ACCESS(tvp, VWRITE, tcnp->cn_cred, 
			    tcnp->cn_proc);
        	if (error) {
                	VOP_UNLOCK(fvp, 0, p);
                	error = EACCES;
                	goto abortit;
        	}
d708 2
a709 1
	if ((error = VOP_UPDATE(fvp, NULL, NULL, 1)) != 0) {
d767 1
a767 1
			if ((error = VOP_UPDATE(tdvp, NULL, NULL, 1)) != 0)
d775 1
a775 1
				(void)VOP_UPDATE(tdvp, NULL, NULL, 1);
d902 1
a902 1
				tcnp->cn_cred, (size_t *)0, (struct proc *)0);
d911 1
a911 1
					dirbuf.dotdot_ino = h2fs32(newparent);
d917 1
a917 1
					    tcnp->cn_cred, (size_t *)0,
d944 1
a944 1
	if (vn_lock(fvp, LK_EXCLUSIVE, p) == 0) {
d954 8
d979 2
a980 1
	struct ext2fs_dirtemplate dirtemplate;
d1008 2
a1009 1
	error = VOP_UPDATE(tvp, NULL, NULL, 1);
d1019 1
a1019 1
	if ((error = VOP_UPDATE(dvp, NULL, NULL, 1)) != 0)
d1023 6
a1028 17
	bzero(&dirtemplate, sizeof(dirtemplate));
	dirtemplate.dot_ino = h2fs32(ip->i_number);
	dirtemplate.dot_reclen = h2fs16(12);
	dirtemplate.dot_namlen = 1;
	if (ip->i_e2fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    (ip->i_e2fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_FTYPE)) {
		dirtemplate.dot_type = EXT2_FT_DIR;
	}
	dirtemplate.dot_name[0] = '.';
	dirtemplate.dotdot_ino = h2fs32(dp->i_number);
	dirtemplate.dotdot_reclen = h2fs16(VTOI(dvp)->i_e2fs->e2fs_bsize - 12);
	dirtemplate.dotdot_namlen = 2;
	if (ip->i_e2fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    (ip->i_e2fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_FTYPE)) {
		dirtemplate.dotdot_type = EXT2_FT_DIR;
	}
	dirtemplate.dotdot_name[0] = dirtemplate.dotdot_name[1] = '.';
d1031 1
a1031 1
	    IO_NODELOCKED|IO_SYNC, cnp->cn_cred, (size_t *)0, (struct proc *)0);
@


1.10.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.10.6.1 2001/05/14 22:47:39 niklas Exp $	*/
d351 1
a351 1
		error = ext2fs_truncate(ip, vap->va_size, 0, cred);
d355 1
d369 1
a369 1
		error = ext2fs_update(ip, &vap->va_atime, &vap->va_mtime, 1);
d409 1
d411 3
d546 1
a546 1
	error = ext2fs_update(ip, NULL, NULL, 1);
d727 1
a727 1
	if ((error = ext2fs_update(ip, NULL, NULL, 1)) != 0) {
d785 1
a785 1
			if ((error = ext2fs_update(dp, NULL, NULL, 1)) != 0)
d793 1
a793 1
				(void)ext2fs_update(dp, NULL, NULL, 1);
d866 2
a867 2
			error = ext2fs_truncate(xp, (off_t)0, IO_SYNC,
			    tcnp->cn_cred);
d1008 1
a1008 1
	if ((error = ext2fs_inode_alloc(dp, dmode, cnp->cn_cred, &tvp)) != 0)
d1017 1
a1017 1
	error = ext2fs_update(ip, NULL, NULL, 1);
d1027 1
a1027 1
	if ((error = ext2fs_update(dp, NULL, NULL, 1)) != 0)
d1158 2
a1159 1
	error = ext2fs_truncate(ip, (off_t)0, IO_SYNC, cnp->cn_cred);
d1328 1
d1341 1
a1341 2
	if ((error = ext2fs_inode_alloc(pdir, mode, cnp->cn_cred, &tvp)) 
	    != 0) {
d1361 2
a1362 1
	if ((error = ext2fs_update(ip, NULL, NULL, 1)) != 0)
d1401 1
d1404 2
a1405 2
	return (ext2fs_update(VTOI(ap->a_vp), NULL, NULL, 
		    ap->a_waitfor == MNT_WAIT));
d1460 1
a1460 1
	{ &vop_kqfilter_desc, vop_generic_kqfilter },	/* kqfilter */
d1462 1
d1482 5
d1509 1
a1509 1
	{ &vop_kqfilter_desc, spec_kqfilter },		/* kqfilter */
d1511 1
d1531 5
d1559 1
a1559 1
	{ &vop_kqfilter_desc, fifo_kqfilter },		/* kqfilter */
d1561 1
d1581 5
@


1.10.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.10.6.2 2001/07/04 11:00:45 niklas Exp $	*/
@


1.10.6.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 2
@


1.10.6.5
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: ext2fs_vnops.c,v 1.30 2000/11/27 08:39:53 chs Exp $	*/
d405 2
d1472 1
a1472 5
	{ &vop_ballocn_desc, ext2fs_ballocn },
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_putpages_desc, genfs_putpages },
	{ &vop_size_desc, genfs_size },
	{ NULL, NULL }
@


1.10.6.6
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: ext2fs_vnops.c,v 1.1 1997/06/11 09:34:09 bouyer Exp $	*/
a67 1
#include <ufs/ufs/extattr.h>
a404 2
	if ((vp->v_flag & VTEXT) && (ip->i_e2fs_mode & S_ISTXT) == 0)
		(void) uvm_vnp_uncache(vp);
d1470 5
a1474 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void*)))NULL }
@


1.10.6.7
log
@Merge in -current from roughly a week ago
@
text
@d79 4
a82 2
static int ext2fs_chmod(struct vnode *, int, struct ucred *, struct proc *);
static int ext2fs_chown(struct vnode *, uid_t, gid_t, struct ucred *, struct proc *);
d1250 2
a1251 2
	int (**specops)(void *);
	int (**fifoops)(void *);
d1435 1
a1435 1
int (**ext2fs_vnodeop_p)(void *);
d1473 1
a1473 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d1478 1
a1478 1
int (**ext2fs_specop_p)(void *);
d1516 1
a1516 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d1522 1
a1522 1
int (**ext2fs_fifoop_p)(void *);
d1560 1
a1560 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.10.6.8
log
@Sync the SMP branch with 3.3
@
text
@d1471 1
a1471 1
	{ NULL, NULL }
d1478 5
a1482 1
	{ &vop_default_desc, spec_vnoperate },
d1489 4
d1494 9
d1507 2
d1511 4
a1514 1
	{ NULL, NULL }
d1522 5
a1526 1
	{ &vop_default_desc, fifo_vnoperate },
d1533 4
d1538 9
d1551 2
d1555 2
d1558 1
a1558 1
	{ NULL, NULL }
@


1.10.6.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.10.6.8 2003/03/28 00:08:47 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.6.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d143 1
a143 1
		ip->i_e2din.e2di_rdev = h2fs32(vap->va_rdev);
d230 1
a230 1
	vap->va_rdev = (dev_t)fs2h32(ip->i_e2din.e2di_rdev);
d292 1
a292 1
			(error = suser_ucred(cred)))
d352 1
a352 1
			(error = suser_ucred(cred)) &&
d388 2
a389 1
	if (cred->cr_uid != ip->i_e2fs_uid && (error = suser_ucred(cred)))
d433 1
a433 1
		(error = suser_ucred(cred)))
d1181 1
a1181 1
		bcopy(ap->a_target, (char *)ip->i_e2din.e2di_shortlink, len);
d1211 1
a1211 1
		uiomove((char *)ip->i_e2din.e2di_shortlink, isize, ap->a_uio);
d1238 67
d1342 1
a1342 1
	    suser_ucred(cnp->cn_cred))
a1367 1
	tvp->v_type = VNON;
d1420 1
d1444 1
a1444 1
	{ &vop_poll_desc, ufs_poll },		/* poll */
@


1.10.6.11
log
@Merge with the trunk
@
text
@d540 1
a540 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1069 1
a1069 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1261 1
a1261 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d1286 1
a1286 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d1296 1
a1296 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1437 1
a1437 1
	{ &vop_reclaim_desc, ext2fsfifo_reclaim },	/* reclaim */
a1446 7

int
ext2fsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (ext2fs_reclaim(v));
}
@


1.9
log
@add compatibility with uvm vnode pagers
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.8 1998/08/06 19:35:04 csapuntz Exp $	*/
d653 5
@


1.8
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.7 1998/07/28 00:13:15 millert Exp $	*/
d389 3
d393 1
@


1.7
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.6 1997/11/06 05:59:16 csapuntz Exp $	*/
d1443 1
a1443 1
	{ &vop_abortop_desc, ufs_abortop },		/* abortop */
d1459 1
a1459 1
	{ &vop_bwrite_desc, vn_bwrite },		/* bwrite */
d1508 1
a1508 1
	{ &vop_bwrite_desc, vn_bwrite },		/* bwrite */
d1558 1
a1558 1
	{ &vop_bwrite_desc, vn_bwrite },		/* bwrite */
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.5 1997/07/03 17:49:45 deraadt Exp $	*/
d893 1
a893 1
				tcnp->cn_cred, (int *)0, (struct proc *)0);
d908 1
a908 1
					    tcnp->cn_cred, (int *)0,
d1022 1
a1022 1
	    IO_NODELOCKED|IO_SYNC, cnp->cn_cred, (int *)0, (struct proc *)0);
d1171 1
a1171 1
		    UIO_SYSSPACE, IO_NODELOCKED, ap->a_cnp->cn_cred, (int *)0,
@


1.5
log
@rm of dir returns EPERM; more careful about ..; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.4 1997/06/12 21:27:47 downsj Exp $	*/
d487 1
d506 1
a506 1
	if (dvp != vp && (error = VOP_LOCK(vp))) {
d534 1
a534 1
		VOP_UNLOCK(vp);
d583 1
d645 1
a645 1
	if ((error = VOP_LOCK(fvp)) != 0)
d651 1
a651 1
		VOP_UNLOCK(fvp);
d660 1
a660 1
                VOP_UNLOCK(fvp);
d672 1
a672 1
			VOP_UNLOCK(fvp);
d701 1
a701 1
		VOP_UNLOCK(fvp);
d716 1
a716 1
	VOP_UNLOCK(fvp);
d935 1
a935 1
	if (VOP_LOCK(fvp) == 0) {
d1235 1
d1249 1
a1249 1
			VOP_UNLOCK(vp);
@


1.4
log
@slight fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.3 1997/06/12 21:09:36 downsj Exp $	*/
a450 4
	if (vp->v_type == VDIR) {
		error = EISDIR;
		goto out;
	}
d452 3
a454 2
	if ((ip->i_e2fs_flags & (EXT2_IMMUTABLE | EXT2_APPEND)) ||
		(VTOI(dvp)->i_e2fs_flags & EXT2_APPEND)) {
d666 3
a668 1
		    dp == ip || (fcnp->cn_flags&ISDOTDOT) ||
@


1.3
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vnops.c,v 1.2 1997/05/30 08:34:10 downsj Exp $	*/
d212 1
a212 1
	return (vaccess(vp->v_type, ip->i_e2fs_uid, ip->i_e2fs_gid, mode,
@


1.2
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 2
a2 4
/*	$OpenBSD$	*/
/*	$NetBSD: ufs_vnops.c,v 1.22 1997/01/30 09:52:27 tls Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d5 1
d43 1
d113 1
a113 1
	    ext2fs_makeinode(MAKEIMODE(ap->a_vap->va_type, ap->a_vap->va_mode),
d137 2
a138 2
	    ext2fs_makeinode(MAKEIMODE(vap->va_type, vap->va_mode),
	    ap->a_dvp, vpp, ap->a_cnp)) != 0)
d182 1
a182 1
	    (ap->a_mode & (FWRITE | O_APPEND)) == FWRITE)
d212 2
a213 2
	return (vaccess(ip->i_e2fs_mode, ip->i_e2fs_uid, ip->i_e2fs_gid, mode,
					ap->a_cred));
d237 1
a237 1
	vap->va_mode = ip->i_e2fs_mode & ~IFMT;
d294 3
a296 3
	    (vap->va_fsid != VNOVAL) || (vap->va_fileid != VNOVAL) ||
	    (vap->va_blocksize != VNOVAL) || (vap->va_rdev != VNOVAL) ||
	    ((int)vap->va_bytes != VNOVAL) || (vap->va_gen != VNOVAL)) {
d301 1
a301 1
		    (error = suser(cred, &p->p_acflag)))
d306 1
a306 1
			    securelevel > 0)
d310 1
a310 1
				    (vap->va_flags & SF_IMMUTABLE) ? EXT2_IMMUTABLE: 0;
d343 3
a345 3
		    (error = suser(cred, &p->p_acflag)) &&
		    ((vap->va_vaflags & VA_UTIMES_NULL) == 0 || 
		    (error = VOP_ACCESS(vp, VWRITE, cred, p))))
d377 1
a377 1
	    (error = suser(cred, &p->p_acflag)))
d420 2
a421 2
	    (gid != ip->i_e2fs_gid && !groupmember((gid_t)gid, cred))) &&
	    (error = suser(cred, &p->p_acflag)))
d457 1
a457 1
	    (VTOI(dvp)->i_e2fs_flags & EXT2_APPEND)) {
d461 2
a462 2
    error = ext2fs_dirremove(dvp, ap->a_cnp);
    if (error == 0) {
d982 1
a982 1
	dmode = vap->va_mode & 0777;
@


1.1
log
@Initial revision
@
text
@d1 1
a64 1
#include <miscfs/genfs/genfs.h>
a229 1
	struct timespec ts;
d231 1
a231 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	EXT2FS_ITIMES(ip, &ts, &ts, &ts);
d1357 22
d1429 1
a1429 1
	{ &vop_poll_desc, ufs_poll },			/* poll */
d1478 1
a1478 1
	{ &vop_poll_desc, spec_poll },			/* poll */
d1528 1
a1528 1
	{ &vop_poll_desc, fifo_poll },			/* poll */
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@
