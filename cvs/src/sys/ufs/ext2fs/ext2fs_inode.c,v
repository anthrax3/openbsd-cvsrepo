head	1.58;
access;
symbols
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.55.0.4
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.55.0.2
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.45.0.6
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.4
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.2
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.43.0.10
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.8
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.4
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.33.0.4
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.21
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.57;
commitid	gAjwyca5TfuoJAhn;

1.57
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.56;
commitid	gFybgYMymUyTbVeS;

1.56
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.55;
commitid	p4LJxGKbi0BU2cG6;

1.55
date	2014.07.31.17.37.52;	author pelikan;	state Exp;
branches;
next	1.54;
commitid	0juiBhtI3vf1GIxq;

1.54
date	2014.07.13.16.59.35;	author pelikan;	state Exp;
branches;
next	1.53;
commitid	zGe0z6RRYbZJpA8u;

1.53
date	2014.07.13.15.07.01;	author pelikan;	state Exp;
branches;
next	1.52;
commitid	CWlwOMbeCyL2ekFr;

1.52
date	2014.07.12.18.44.01;	author tedu;	state Exp;
branches;
next	1.51;
commitid	bDGgAR6yEQVcVl5u;

1.51
date	2014.07.11.14.30.52;	author pelikan;	state Exp;
branches;
next	1.50;
commitid	WfVjFNbKSMyZjiSF;

1.50
date	2014.07.11.12.08.21;	author pelikan;	state Exp;
branches;
next	1.49;
commitid	xTkX7KC9qvI2SOnE;

1.49
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	EF98ch02VpFassUi;

1.48
date	2014.05.27.14.31.24;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2014.01.25.23.31.12;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.12.12.19.00.09;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.23.23.52.35;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.29.17.06.20;	author chl;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.17.20.15.25;	author jasper;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.02.00.45.50;	author pedro;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.11.16.08.50;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.18.14.18.25;	author pedro;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.09.12.43.17;	author pedro;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.15.13.44.28;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.11.20.46.28;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.06.17.43.14;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.14.12.45.24;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.03.20.14.01;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.30.13.58.55;	author niallo;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.25.23.26.55;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.18.01.46.40;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.18.01.21.55;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.16.03.44.22;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.16.02.56.48;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.04.58.47;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.23.02.07.51;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.24.07.13.43;	author jasoni;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.23.02.14.39;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.26.23.24.41;	author jasoni;	state Exp;
branches;
next	1.7;

1.7
date	99.08.17.14.20.46;	author art;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	99.02.26.03.21.59;	author art;	state Exp;
branches;
next	1.5;

1.5
date	98.05.18.01.59.16;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.11.06.05.59.14;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	97.06.12.21.09.33;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.05.30.08.33.55;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.7.4.1
date	2001.05.14.22.47.39;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2001.07.04.11.00.43;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.7.4.7;

1.7.4.7
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.7.4.8;

1.7.4.8
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.7.4.9;

1.7.4.9
date	2004.02.19.11.01.36;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.32.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/*	$OpenBSD: ext2fs_inode.c,v 1.57 2016/02/27 18:50:38 natano Exp $	*/
/*	$NetBSD: ext2fs_inode.c,v 1.24 2001/06/19 12:59:18 wiz Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_inode.c	8.8 (Berkeley) 10/19/94
 * Modified for ext2fs by Manuel Bouyer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/resourcevar.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ext2fs/ext2fs_extern.h>

static int ext2fs_indirtrunc(struct inode *, int32_t, int32_t,
				int32_t, int, long *);

/*
 * Get the size of an inode.
 */
u_int64_t
ext2fs_size(struct inode *ip)
{
	u_int64_t size = ip->i_e2fs_size;

	if ((ip->i_e2fs_mode & IFMT) == IFREG)
		size |= (u_int64_t)ip->i_e2fs_size_hi << 32;

	return (size);
}

int
ext2fs_setsize(struct inode *ip, u_int64_t size)
{
	struct m_ext2fs *fs = ip->i_e2fs;

	if (size <= fs->e2fs_maxfilesize) {
		/* If HUGE_FILEs are off, e2fs_maxfilesize will protect us. */
		if ((ip->i_e2fs_mode & IFMT) == IFREG || ip->i_e2fs_mode == 0)
			ip->i_e2fs_size_hi = size >> 32;

		ip->i_e2fs_size = size;
		return (0);
	}

	/* Linux automagically upgrades to REV1 here! */
	if (fs->e2fs.e2fs_rev <= E2FS_REV0)
		return (EFBIG);

	if ((fs->e2fs.e2fs_features_rocompat & EXT2F_ROCOMPAT_LARGEFILE) == 0) {
		fs->e2fs.e2fs_features_rocompat |= EXT2F_ROCOMPAT_LARGEFILE;
		fs->e2fs_fmod = 1;
	}
	return (EFBIG);
}


/*
 * Last reference to an inode.  If necessary, write or delete it.
 */
int
ext2fs_inactive(void *v)
{
	struct vop_inactive_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct proc *p = ap->a_p;
	struct timespec ts;
	int error = 0;
#ifdef DIAGNOSTIC
	extern int prtactive;

	if (prtactive && vp->v_usecount != 0)
		vprint("ext2fs_inactive: pushing active", vp);
#endif

	/* Get rid of inodes related to stale file handles. */
	if (ip->i_e2din == NULL || ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime)
		goto out;

	error = 0;
	if (ip->i_e2fs_nlink == 0 && (vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
		if (ext2fs_size(ip) != 0) {
			error = ext2fs_truncate(ip, (off_t)0, 0, NOCRED);
		}
		getnanotime(&ts);
		ip->i_e2fs_dtime = ts.tv_sec;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		ext2fs_inode_free(ip, ip->i_number, ip->i_e2fs_mode);
	}
	if (ip->i_flag & (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) {
		ext2fs_update(ip, 0);
	}
out:
	VOP_UNLOCK(vp, p);
	/*
	 * If we are done with the inode, reclaim it
	 * so that it can be reused immediately.
	 */
	if (ip->i_e2din == NULL || ip->i_e2fs_dtime != 0)
		vrecycle(vp, p);
	return (error);
}


/*
 * Update the access, modified, and inode change times as specified by the
 * IACCESS, IUPDATE, and ICHANGE flags respectively. The IMODIFIED flag is
 * used to specify that the inode needs to be updated but that the times have
 * already been set. The access and modified times are taken from the second
 * and third parameters; the inode change time is always taken from the current
 * time. If waitfor is set, then wait for the disk write of the inode to
 * complete.
 */
int
ext2fs_update(struct inode *ip, int waitfor)
{
	struct m_ext2fs *fs;
	struct buf *bp;
	int error;
	caddr_t cp;

	if (ITOV(ip)->v_mount->mnt_flag & MNT_RDONLY)
		return (0);
	EXT2FS_ITIMES(ip);
	if ((ip->i_flag & IN_MODIFIED) == 0)
		return (0);
	ip->i_flag &= ~IN_MODIFIED;
	fs = ip->i_e2fs;
	error = bread(ip->i_devvp,
			  fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
			  (int)fs->e2fs_bsize, &bp);
	if (error) {
		brelse(bp);
		return (error);
	}
	ip->i_flag &= ~(IN_MODIFIED);
	cp = (caddr_t)bp->b_data +
	    (ino_to_fsbo(fs, ip->i_number) * EXT2_DINODE_SIZE(fs));

	/*
	 * See note about 16-bit UID/GID limitation in ext2fs_vget(). Now
	 * that we are about to write the inode, construct the split UID and
	 * GID fields out of the two 32-bit fields we kept in memory.
	 */
	ip->i_e2fs_uid_low = (u_int16_t)ip->i_e2fs_uid;
	ip->i_e2fs_gid_low = (u_int16_t)ip->i_e2fs_gid;
	ip->i_e2fs_uid_high = ip->i_e2fs_uid >> 16;
	ip->i_e2fs_gid_high = ip->i_e2fs_gid >> 16;

	e2fs_isave(fs, ip->i_e2din, (struct ext2fs_dinode *)cp);
	if (waitfor)
		return (bwrite(bp));
	else {
		bdwrite(bp);
		return (0);
	}
}

#define	SINGLE	0	/* index of single indirect block */
#define	DOUBLE	1	/* index of double indirect block */
#define	TRIPLE	2	/* index of triple indirect block */
/*
 * Truncate the inode oip to at most length size, freeing the
 * disk blocks.
 */
int
ext2fs_truncate(struct inode *oip, off_t length, int flags, struct ucred *cred)
{
	struct vnode *ovp = ITOV(oip);
	int32_t lastblock;
	int32_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	int32_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
	struct m_ext2fs *fs;
	struct buf *bp;
	int offset, size, level;
	long count, nblocks, vflags, blocksreleased = 0;
	int i;
	int aflags, error, allerror;
	off_t osize;

	if (length < 0)
		return (EINVAL);

	if (ovp->v_type != VREG &&
	    ovp->v_type != VDIR &&
	    ovp->v_type != VLNK)
		return (0);

	if (ovp->v_type == VLNK && ext2fs_size(oip) < EXT2_MAXSYMLINKLEN) {
#ifdef DIAGNOSTIC
		if (length != 0)
			panic("ext2fs_truncate: partial truncate of symlink");
#endif
		memset(&oip->i_e2din->e2di_shortlink, 0, ext2fs_size(oip));
		(void)ext2fs_setsize(oip, 0);
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (ext2fs_update(oip, 1));
	}

	if (ext2fs_size(oip) == length) {
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (ext2fs_update(oip, 0));
	}
	fs = oip->i_e2fs;
	osize = ext2fs_size(oip);
	/*
	 * Lengthen the size of the file. We must ensure that the
	 * last byte of the file is allocated. Since the smallest
	 * value of osize is 0, length will be at least 1.
	 */
	if (osize < length) {
#if 0 /* XXX */
		if (length > fs->fs_maxfilesize)
			return (EFBIG);
#endif
		offset = blkoff(fs, length - 1);
		lbn = lblkno(fs, length - 1);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = ext2fs_buf_alloc(oip, lbn, offset + 1, cred, &bp,
		    aflags);
		if (error)
			return (error);
		(void)ext2fs_setsize(oip, length);
		uvm_vnp_setsize(ovp, length);
		uvm_vnp_uncache(ovp);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (ext2fs_update(oip, 1));
	}
	/*
	 * Shorten the size of the file. If the file is not being
	 * truncated to a block boundry, the contents of the
	 * partial block following the end of the file must be
	 * zero'ed in case it ever become accessible again because
	 * of subsequent file growth.
	 */
	offset = blkoff(fs, length);
	if (offset == 0) {
		(void)ext2fs_setsize(oip, length);
	} else {
		lbn = lblkno(fs, length);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = ext2fs_buf_alloc(oip, lbn, offset, cred, &bp,
		    aflags);
		if (error)
			return (error);
		(void)ext2fs_setsize(oip, length);
		size = fs->e2fs_bsize;
		uvm_vnp_setsize(ovp, length);
		uvm_vnp_uncache(ovp);
		memset(bp->b_data + offset, 0, size - offset);
		bp->b_bcount = size;
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
	}
	/*
	 * Calculate index into inode's block list of
	 * last direct and indirect blocks (if any)
	 * which we want to keep.  Lastblock is -1 when
	 * the file is truncated to 0.
	 */
	lastblock = lblkno(fs, length + fs->e2fs_bsize - 1) - 1;
	lastiblock[SINGLE] = lastblock - NDADDR;
	lastiblock[DOUBLE] = lastiblock[SINGLE] - NINDIR(fs);
	lastiblock[TRIPLE] = lastiblock[DOUBLE] - NINDIR(fs) * NINDIR(fs);
	nblocks = btodb(fs->e2fs_bsize);
	/*
	 * Update file and block pointers on disk before we start freeing
	 * blocks.  If we crash before free'ing blocks below, the blocks
	 * will be returned to the free list.  lastiblock values are also
	 * normalized to -1 for calls to ext2fs_indirtrunc below.
	 */
	memcpy(oldblks, &oip->i_e2fs_blocks[0], sizeof(oldblks));
	for (level = TRIPLE; level >= SINGLE; level--)
		if (lastiblock[level] < 0) {
			oip->i_e2fs_blocks[NDADDR + level] = 0;
			lastiblock[level] = -1;
		}
	for (i = NDADDR - 1; i > lastblock; i--)
		oip->i_e2fs_blocks[i] = 0;
	oip->i_flag |= IN_CHANGE | IN_UPDATE;
	if ((error = ext2fs_update(oip, 1)) != 0)
		allerror = error;
	/*
	 * Having written the new inode to disk, save its new configuration
	 * and put back the old block pointers long enough to process them.
	 * Note that we save the new block configuration so we can check it
	 * when we are done.
	 */
	memcpy(newblks, &oip->i_e2fs_blocks[0], sizeof(newblks));
	memcpy(&oip->i_e2fs_blocks[0], oldblks, sizeof(oldblks));
	(void)ext2fs_setsize(oip, osize);
	vflags = ((length > 0) ? V_SAVE : 0) | V_SAVEMETA;
	allerror = vinvalbuf(ovp, vflags, cred, curproc, 0, 0);

	/*
	 * Indirect blocks first.
	 */
	indir_lbn[SINGLE] = -NDADDR;
	indir_lbn[DOUBLE] = indir_lbn[SINGLE] - NINDIR(fs) -1;
	indir_lbn[TRIPLE] = indir_lbn[DOUBLE] - NINDIR(fs) * NINDIR(fs) - 1;
	for (level = TRIPLE; level >= SINGLE; level--) {
		bn = letoh32(oip->i_e2fs_blocks[NDADDR + level]);
		if (bn != 0) {
			error = ext2fs_indirtrunc(oip, indir_lbn[level],
			    fsbtodb(fs, bn), lastiblock[level], level, &count);
			if (error)
				allerror = error;
			blocksreleased += count;
			if (lastiblock[level] < 0) {
				oip->i_e2fs_blocks[NDADDR + level] = 0;
				ext2fs_blkfree(oip, bn);
				blocksreleased += nblocks;
			}
		}
		if (lastiblock[level] >= 0)
			goto done;
	}

	/*
	 * All whole direct blocks or frags.
	 */
	for (i = NDADDR - 1; i > lastblock; i--) {
		bn = letoh32(oip->i_e2fs_blocks[i]);
		if (bn == 0)
			continue;
		oip->i_e2fs_blocks[i] = 0;
		ext2fs_blkfree(oip, bn);
		blocksreleased += btodb(fs->e2fs_bsize);
	}

done:
#ifdef DIAGNOSTIC
	for (level = SINGLE; level <= TRIPLE; level++)
		if (newblks[NDADDR + level] !=
		    oip->i_e2fs_blocks[NDADDR + level])
			panic("ext2fs_truncate1");
	for (i = 0; i < NDADDR; i++)
		if (newblks[i] != oip->i_e2fs_blocks[i])
			panic("ext2fs_truncate2");
	if (length == 0 &&
	    (!LIST_EMPTY(&ovp->v_cleanblkhd) ||
	     !LIST_EMPTY(&ovp->v_dirtyblkhd)))
		panic("ext2fs_truncate3");
#endif /* DIAGNOSTIC */
	/*
	 * Put back the real size.
	 */
	(void)ext2fs_setsize(oip, length);
	if (blocksreleased >= oip->i_e2fs_nblock)
		oip->i_e2fs_nblock = 0;
	else
		oip->i_e2fs_nblock -= blocksreleased;
	oip->i_flag |= IN_CHANGE;
	return (allerror);
}

/*
 * Release blocks associated with the inode ip and stored in the indirect
 * block bn.  Blocks are free'd in LIFO order up to (but not including)
 * lastbn.  If level is greater than SINGLE, the block is an indirect block
 * and recursive calls to indirtrunc must be used to cleanse other indirect
 * blocks.
 *
 * NB: triple indirect blocks are untested.
 */
static int
ext2fs_indirtrunc(struct inode *ip, int32_t lbn, int32_t dbn, int32_t lastbn, int level, long *countp)
{
	int i;
	struct buf *bp;
	struct m_ext2fs *fs = ip->i_e2fs;
	int32_t *bap;
	struct vnode *vp;
	int32_t *copy = NULL, nb, nlbn, last;
	long blkcount, factor;
	int nblocks, blocksreleased = 0;
	int error = 0, allerror = 0;

	/*
	 * Calculate index in current block of last
	 * block to be kept.  -1 indicates the entire
	 * block so we need not calculate the index.
	 */
	factor = 1;
	for (i = SINGLE; i < level; i++)
		factor *= NINDIR(fs);
	last = lastbn;
	if (lastbn > 0)
		last /= factor;
	nblocks = btodb(fs->e2fs_bsize);
	/*
	 * Get buffer of block pointers, zero those entries corresponding
	 * to blocks to be free'd, and update on disk copy first.  Since
	 * double(triple) indirect before single(double) indirect, calls
	 * to bmap on these blocks will fail.  However, we already have
	 * the on disk address, so we have to set the b_blkno field
	 * explicitly instead of letting bread do everything for us.
	 */
	vp = ITOV(ip);
	bp = getblk(vp, lbn, (int)fs->e2fs_bsize, 0, 0);
	if (!(bp->b_flags & (B_DONE | B_DELWRI))) {
		curproc->p_ru.ru_inblock++;		/* pay for read */
		bcstats.pendingreads++;
		bcstats.numreads++;
		bp->b_flags |= B_READ;
		if (bp->b_bcount > bp->b_bufsize)
			panic("ext2fs_indirtrunc: bad buffer size");
		bp->b_blkno = dbn;
		VOP_STRATEGY(bp);
		error = biowait(bp);
	}
	if (error) {
		brelse(bp);
		*countp = 0;
		return (error);
	}

	bap = (int32_t *)bp->b_data;
	if (lastbn >= 0) {
		copy = malloc(fs->e2fs_bsize, M_TEMP, M_WAITOK);
		memcpy(copy, bap, fs->e2fs_bsize);
		memset(&bap[last + 1], 0,
		    (NINDIR(fs) - (last + 1)) * sizeof(u_int32_t));
		error = bwrite(bp);
		if (error)
			allerror = error;
		bap = copy;
	}

	/*
	 * Recursively free totally unused blocks.
	 */
	for (i = NINDIR(fs) - 1,
		nlbn = lbn + 1 - i * factor; i > last;
		i--, nlbn += factor) {
		nb = letoh32(bap[i]);
		if (nb == 0)
			continue;
		if (level > SINGLE) {
			error = ext2fs_indirtrunc(ip, nlbn, fsbtodb(fs, nb),
						   (int32_t)-1, level - 1,
						   &blkcount);
			if (error)
				allerror = error;
			blocksreleased += blkcount;
		}
		ext2fs_blkfree(ip, nb);
		blocksreleased += nblocks;
	}

	/*
	 * Recursively free last partial block.
	 */
	if (level > SINGLE && lastbn >= 0) {
		last = lastbn % factor;
		nb = letoh32(bap[i]);
		if (nb != 0) {
			error = ext2fs_indirtrunc(ip, nlbn, fsbtodb(fs, nb),
						   last, level - 1, &blkcount);
			if (error)
				allerror = error;
			blocksreleased += blkcount;
		}
	}

	if (copy != NULL) {
		free(copy, M_TEMP, fs->e2fs_bsize);
	} else {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}

	*countp = blocksreleased;
	return (allerror);
}
@


1.57
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.56 2015/03/14 03:38:52 jsg Exp $	*/
d135 1
a135 1
	VOP_UNLOCK(vp, 0, p);
@


1.56
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.55 2014/07/31 17:37:52 pelikan Exp $	*/
d230 1
a230 4
	if (ovp->v_type == VLNK &&
		(ext2fs_size(oip) < ovp->v_mount->mnt_maxsymlinklen ||
		 (ovp->v_mount->mnt_maxsymlinklen == 0 &&
		  oip->i_e2fs_nblock == 0))) {
@


1.55
log
@use proper on-disk inode size: no more, no less.

Reported by Roman Yakovlev, thanks!

"do it now" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.54 2014/07/13 16:59:35 pelikan Exp $	*/
a40 1
#include <sys/file.h>
@


1.54
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

Some KNF while there.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.53 2014/07/13 15:07:01 pelikan Exp $	*/
d192 1
a192 1
	e2fs_isave(ip->i_e2din, (struct ext2fs_dinode *)cp);
@


1.53
log
@fill in proper sizes in free(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.52 2014/07/12 18:44:01 tedu Exp $	*/
d357 1
a357 1
		bn = fs2h32(oip->i_e2fs_blocks[NDADDR + level]);
d378 1
a378 1
		bn = fs2h32(oip->i_e2fs_blocks[i]);
d491 1
a491 1
		nb = fs2h32(bap[i]);
d511 1
a511 1
		nb = fs2h32(bap[i]);
@


1.52
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.51 2014/07/11 14:30:52 pelikan Exp $	*/
d522 1
a522 1
		free(copy, M_TEMP, 0);
@


1.51
log
@determine and use maximum file size instead of magical constants

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.50 2014/07/11 12:08:21 pelikan Exp $	*/
d522 1
a522 1
		free(copy, M_TEMP);
@


1.50
log
@updated inode format, whitespace, re-formatting
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.49 2014/07/08 17:19:26 deraadt Exp $	*/
d78 1
a78 1
	if (size < /* XXX MAXFILESIZE */ INT_MAX) {
@


1.49
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.48 2014/05/27 14:31:24 krw Exp $	*/
d65 1
a65 1
        u_int64_t size = ip->i_e2fs_size;
d67 2
a68 2
        if ((ip->i_e2fs_mode & IFMT) == IFREG)
                size |= (u_int64_t)ip->i_e2fs_dacl << 32;
d70 1
a70 1
        return (size);
d76 1
a76 19
        if ((ip->i_e2fs_mode & IFMT) == IFREG ||
            ip->i_e2fs_mode == 0) {
                ip->i_e2fs_dacl = size >> 32;
                if (size >= 0x80000000U) {
                        struct m_ext2fs *fs = ip->i_e2fs;

                        if (fs->e2fs.e2fs_rev <= E2FS_REV0) {
                                /* Linux automagically upgrades to REV1 here! */
                                return (EFBIG);
                        }
                        if (!(fs->e2fs.e2fs_features_rocompat
                            & EXT2F_ROCOMPAT_LARGEFILE)) {
                                fs->e2fs.e2fs_features_rocompat |=
                                    EXT2F_ROCOMPAT_LARGEFILE;
                                fs->e2fs_fmod = 1;
                        }
                }
        } else if (size >= 0x80000000U)
                return (EFBIG);
d78 18
a95 3
        ip->i_e2fs_size = size;

        return (0);
@


1.48
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.47 2014/01/25 23:31:12 guenther Exp $	*/
a46 2

#include <uvm/uvm_extern.h>
@


1.47
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.46 2013/12/12 19:00:09 tedu Exp $	*/
d109 1
a109 1
{   
d149 1
a149 1
}   
d249 1
a249 1
	
d300 1
a300 1
		error = ext2fs_buf_alloc(oip, lbn, offset, cred, &bp, 
@


1.46
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.45 2012/03/23 15:51:26 guenther Exp $	*/
d138 1
a138 1
		ext2fs_update(ip, NULL, NULL, 0);
d162 1
a162 2
ext2fs_update(struct inode *ip, struct timespec *atime, struct timespec *mtime,
    int waitfor)
a166 1
	struct timespec ts;
d171 1
a171 4
	getnanotime(&ts);
	EXT2FS_ITIMES(ip,
	    atime ? atime : &ts,
	    mtime ? mtime : &ts);
d247 1
a247 1
		return (ext2fs_update(oip, NULL, NULL, 1));
d252 1
a252 1
		return (ext2fs_update(oip, NULL, NULL, 0));
d283 1
a283 1
		return (ext2fs_update(oip, NULL, NULL, 1));
d341 1
a341 1
	if ((error = ext2fs_update(oip, NULL, NULL, 1)) != 0)
@


1.45
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.44 2011/07/04 04:30:41 tedu Exp $	*/
d249 1
a249 2
		bzero((char *)&oip->i_e2din->e2di_shortlink,
			(u_int)ext2fs_size(oip));
d313 1
a313 1
		bzero(bp->b_data + offset, (u_int)(size - offset));
d337 1
a337 1
	memcpy((caddr_t)oldblks, (caddr_t)&oip->i_e2fs_blocks[0], sizeof oldblks);
d354 2
a355 2
	bcopy((caddr_t)&oip->i_e2fs_blocks[0], (caddr_t)newblks, sizeof newblks);
	bcopy((caddr_t)oldblks, (caddr_t)&oip->i_e2fs_blocks[0], sizeof oldblks);
d486 3
a488 3
		memcpy((caddr_t)copy, (caddr_t)bap, (u_int)fs->e2fs_bsize);
		memset((caddr_t)&bap[last + 1], 0,
			(u_int)(NINDIR(fs) - (last + 1)) * sizeof (u_int32_t));
@


1.44
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.43 2008/11/23 23:52:35 tedu Exp $	*/
d468 1
a468 1
		curproc->p_stats->p_ru.ru_inblock++;	/* pay for read */
@


1.43
log
@fancy new ext2fs can have big inodes.  we can possibly still read them
though if no new features are in play.  diff from Wouter Godefroy
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.42 2008/06/12 06:58:40 deraadt Exp $	*/
d183 1
a183 1
			  (int)fs->e2fs_bsize, NOCRED, &bp);
@


1.42
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.40 2008/06/10 20:14:37 beck Exp $	*/
d190 1
a190 1
	    (ino_to_fsbo(fs, ip->i_number) * EXT2_DINODE_SIZE);
@


1.41
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.39 2007/10/29 17:06:20 chl Exp $	*/
d469 2
@


1.40
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@a468 2
		bcstats.pendingreads++;
		bcstats.numreads++;
@


1.39
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.38 2007/06/17 20:15:25 jasper Exp $	*/
d469 2
@


1.38
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.37 2007/06/02 00:45:50 pedro Exp $	*/
d484 1
a484 1
		MALLOC(copy, int32_t *, fs->e2fs_bsize, M_TEMP, M_WAITOK);
d531 1
a531 1
		FREE(copy, M_TEMP);
@


1.37
log
@ufs1_daddr_t cleanup, okay thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.36 2007/06/01 23:47:57 deraadt Exp $	*/
d108 1
a108 2
ext2fs_inactive(v)
	void *v;
d433 1
a433 6
ext2fs_indirtrunc(ip, lbn, dbn, lastbn, level, countp)
	struct inode *ip;
	int32_t lbn, lastbn;
	int32_t dbn;
	int level;
	long *countp;
@


1.36
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.35 2007/05/26 20:26:51 pedro Exp $	*/
d58 2
a59 2
static int ext2fs_indirtrunc(struct inode *, ufs1_daddr_t, ufs1_daddr_t,
				ufs1_daddr_t, int, long *);
d223 3
a225 3
	ufs1_daddr_t lastblock;
	ufs1_daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	ufs1_daddr_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
d436 2
a437 2
	ufs1_daddr_t lbn, lastbn;
	ufs1_daddr_t dbn;
d444 1
a444 1
	ufs1_daddr_t *bap;
d446 1
a446 1
	ufs1_daddr_t *copy = NULL, nb, nlbn, last;
d488 1
a488 1
	bap = (ufs1_daddr_t *)bp->b_data;
d490 1
a490 1
		MALLOC(copy, ufs1_daddr_t *, fs->e2fs_bsize, M_TEMP, M_WAITOK);
d511 1
a511 1
						   (ufs1_daddr_t)-1, level - 1,
@


1.35
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.34 2007/04/11 16:08:50 thib Exp $	*/
d111 1
a111 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
@


1.34
log
@Remove the simplelock argument from vrecycle();

ok pedro@@, sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.33 2006/06/18 14:18:25 pedro Exp $	*/
d318 2
a319 2
		bzero((char *)bp->b_data + offset, (u_int)(size - offset));
		allocbuf(bp, size);
@


1.33
log
@Under certain circumstances, ext2fs_inactive() can be called without a
backing dinode, in which case we just want to recycle the vnode.

Fixes a crash reported by reyk@@, okay krw@@, mickey@@ and pat@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.32 2006/01/09 12:43:17 pedro Exp $	*/
d151 1
a151 1
		vrecycle(vp, NULL, p);
@


1.32
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.31 2005/12/15 13:44:28 krw Exp $	*/
d128 1
a128 1
	if (ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime != 0)
d150 1
a150 1
	if (ip->i_e2fs_dtime != 0)
@


1.31
log
@A sanity check for an unsigned variable being < 0 after a subtraction
is not useful. Check the value about to be subtracted.

Spotted by lint.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.30 2005/12/11 20:46:28 pedro Exp $	*/
d120 1
d122 1
a122 1
	
d125 2
@


1.30
log
@inode/dinode separation for ext2fs
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.29 2005/10/06 17:43:14 pedro Exp $	*/
d416 1
a416 2
	oip->i_e2fs_nblock -= blocksreleased;
	if (oip->i_e2fs_nblock < 0)			/* sanity */
d418 2
@


1.29
log
@Use part of the reserved space on the disk inode to scatter 16 more bits
for the UID and GID, making them 32-bit. Based on what Linux does, with
a slightly different implementation. Endianess issue in fsck noted by
miod@@, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.28 2005/08/14 12:45:24 pedro Exp $	*/
d203 1
a203 1
	e2fs_isave(&ip->i_e2din, (struct ext2fs_dinode *)cp);
d250 1
a250 1
		bzero((char *)&oip->i_e2din.e2di_shortlink,
@


1.28
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.27 2005/07/03 20:14:01 drahn Exp $	*/
d192 11
@


1.27
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.26 2005/04/30 13:58:55 niallo Exp $	*/
d71 2
a72 1
        return size;
d86 1
a86 1
                                return EFBIG;
d96 1
a96 1
                return EFBIG;
d100 1
a100 1
        return 0;
@


1.26
log
@Add support for large files (> 4GB).

Automatically converts old filesystems to use this if they are already at
revision 1 (like Linux). Revision 0 filesystems don't get converted (unlike
Linux).

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.25 2004/06/24 19:35:26 tholo Exp $	*/
a49 1
#include <ufs/ufs/extattr.h>
@


1.25
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.24 2003/08/25 23:26:55 tedu Exp $	*/
d63 42
d130 1
a130 1
		if (ip->i_e2fs_size != 0) {
d232 1
a232 1
		(oip->i_e2fs_size < ovp->v_mount->mnt_maxsymlinklen ||
d240 2
a241 2
			(u_int)oip->i_e2fs_size);
		oip->i_e2fs_size = 0;
d245 2
a246 1
	if (oip->i_e2fs_size == length) {
d251 1
a251 1
	osize = oip->i_e2fs_size;
d271 1
a271 1
		oip->i_e2fs_size = length;
d290 1
a290 1
		oip->i_e2fs_size = length;
d300 1
a300 1
		oip->i_e2fs_size = length;
d347 1
a347 1
	oip->i_e2fs_size = osize;
d404 1
a404 1
	oip->i_e2fs_size = length;
@


1.24
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
few other little cleanups.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.23 2003/06/02 23:28:22 millert Exp $	*/
d91 1
a91 1
		TIMEVAL_TO_TIMESPEC(&time, &ts);
d132 1
a132 1
	TIMEVAL_TO_TIMESPEC(&time, &ts);
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.22 2003/05/26 18:33:16 tedu Exp $	*/
d150 1
a150 1
	e2fs_isave(&ip->i_din.e2fs_din, (struct ext2fs_dinode *)cp);
d197 1
a197 1
		bzero((char *)&oip->i_din.e2fs_din.e2di_shortlink,
@


1.22
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.21 2002/03/14 01:27:14 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.20 2002/02/22 20:37:45 drahn Exp $	*/
d63 2
a64 2
static int ext2fs_indirtrunc(struct inode *, ufs_daddr_t, ufs_daddr_t,
				ufs_daddr_t, int, long *);
d174 3
a176 3
	ufs_daddr_t lastblock;
	ufs_daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	ufs_daddr_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
d385 2
a386 2
	ufs_daddr_t lbn, lastbn;
	ufs_daddr_t dbn;
d393 1
a393 1
	ufs_daddr_t *bap;
d395 1
a395 1
	ufs_daddr_t *copy = NULL, nb, nlbn, last;
d437 1
a437 1
	bap = (ufs_daddr_t *)bp->b_data;
d439 1
a439 1
		MALLOC(copy, ufs_daddr_t *, fs->e2fs_bsize, M_TEMP, M_WAITOK);
d460 1
a460 1
						   (ufs_daddr_t)-1, level - 1,
@


1.20
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.19 2001/12/19 08:58:07 art Exp $	*/
d63 2
a64 2
static int ext2fs_indirtrunc __P((struct inode *, ufs_daddr_t, ufs_daddr_t,
				ufs_daddr_t, int, long *));
@


1.19
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.17 2001/11/06 19:53:21 miod Exp $	*/
d54 1
@


1.18
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 2
a2 1
/*	$NetBSD: ext2fs_inode.c,v 1.23 2001/02/18 20:17:04 chs Exp $	*/
a61 2
extern int prtactive;

d63 1
a63 1
				  ufs_daddr_t, int, long *));
d81 1
d174 1
a174 1
	ufs_daddr_t bn, lastiblock[NIADDR], indir_lbn[NIADDR];
d177 1
d181 1
a181 1
	int error, allerror;
d222 16
a237 2
		ext2fs_balloc_range(ovp, length - 1, 1, cred,
		    flags & IO_SYNC ? B_SYNC : 0);
d249 12
a260 1
	if (offset != 0) {
d262 8
a269 3

		/* XXXUBC we should handle more than just VREG */
		uvm_vnp_zerorange(ovp, length, size - offset);
a270 3
	oip->i_e2fs_size = length;
	uvm_vnp_setsize(ovp, length);

@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@a52 1
#include <ufs/ufs/extattr.h>
d62 3
a64 2
static int ext2fs_indirtrunc(struct inode *, ufs_daddr_t, ufs_daddr_t,
				ufs_daddr_t, int, long *);
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 2
/*	$OpenBSD: ext2fs_inode.c,v 1.16 2001/09/18 01:46:40 art Exp $	*/
/*	$NetBSD: ext2fs_inode.c,v 1.24 2001/06/19 12:59:18 wiz Exp $	*/
d61 2
d64 1
a64 1
				ufs_daddr_t, int, long *));
a81 1
	extern int prtactive;
d174 1
a174 1
	ufs_daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
a176 1
	struct buf *bp;
d180 1
a180 1
	int aflags, error, allerror;
d221 2
a222 16
		offset = blkoff(fs, length - 1);
		lbn = lblkno(fs, length - 1);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = ext2fs_buf_alloc(oip, lbn, offset + 1, cred, &bp,
		    aflags);
		if (error)
			return (error);
		oip->i_e2fs_size = length;
		uvm_vnp_setsize(ovp, length);
		uvm_vnp_uncache(ovp);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
d234 1
a234 12
	if (offset == 0) {
		oip->i_e2fs_size = length;
	} else {
		lbn = lblkno(fs, length);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = ext2fs_buf_alloc(oip, lbn, offset, cred, &bp, 
		    aflags);
		if (error)
			return (error);
		oip->i_e2fs_size = length;
d236 3
a238 8
		uvm_vnp_setsize(ovp, length);
		uvm_vnp_uncache(ovp);
		bzero((char *)bp->b_data + offset, (u_int)(size - offset));
		allocbuf(bp, size);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
d240 3
@


1.16
log
@move ext2fs_init to where it belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.15 2001/09/18 01:21:55 art Exp $	*/
d52 1
a52 1
#include <vm/vm.h>
@


1.15
log
@More of cleanups, reliability and endianness fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a63 7

int
ext2fs_init(vfsp)
	struct vfsconf *vfsp;
{
	return (ufs_init(vfsp));
}
@


1.14
log
@

Make truncating a device a no-op instead of returning an error. We can
fix the rest of the kernel some other time.
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_inode.c,v 1.13 2001/07/16 02:56:48 csapuntz Exp $	*/
/*	$NetBSD: ext2fs_inode.c,v 1.1 1997/06/11 09:33:56 bouyer Exp $	*/
d62 2
a63 2
static int ext2fs_indirtrunc __P((struct inode *, daddr_t, daddr_t,
    				  daddr_t, int, long *));
d81 1
d83 3
a85 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d93 1
a93 1
	if (ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime != 0) 
d96 1
d98 3
a100 1
		(void) ext2fs_truncate(ip, (off_t)0, 0, NOCRED);
d110 1
a110 1
	VOP_UNLOCK(vp, 0, ap->a_p);
d116 1
a116 1
		vrecycle(vp, (struct simplelock *)0, ap->a_p);
d138 1
d157 4
a160 3
	bcopy(&ip->i_din.e2fs_din,
		((struct ext2fs_dinode *)bp->b_data + ino_to_fsbo(fs, ip->i_number)),
		sizeof(struct ext2fs_dinode));
d180 4
a183 4
	daddr_t lastblock;
	daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	daddr_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
	register struct m_ext2fs *fs;
d187 1
a187 1
	register int i;
d252 1
a252 1
	 * zero'ed in case it ever become accessable again because
d295 1
a295 1
	bcopy((caddr_t)&oip->i_e2fs_blocks[0], (caddr_t)oldblks, sizeof oldblks);
d325 1
a325 1
		bn = oip->i_e2fs_blocks[NDADDR + level];
d328 1
a328 1
				fsbtodb(fs, bn), lastiblock[level], level, &count);
d346 1
a346 1
		bn = oip->i_e2fs_blocks[i];
a352 2
	if (lastblock < 0)
		goto done;
d357 3
a359 2
		if (newblks[NDADDR + level] != oip->i_e2fs_blocks[NDADDR + level])
			panic("itrunc1");
d362 1
a362 1
			panic("itrunc2");
d364 3
a366 2
		(ovp->v_dirtyblkhd.lh_first || ovp->v_cleanblkhd.lh_first))
		panic("itrunc3");
d390 3
a392 3
	register struct inode *ip;
	daddr_t lbn, lastbn;
	daddr_t dbn;
d396 1
a396 1
	register int i;
d398 2
a399 2
	register struct m_ext2fs *fs = ip->i_e2fs;
	register daddr_t *bap;
d401 1
a401 1
	daddr_t *copy = NULL, nb, nlbn, last;
d443 5
a447 5
	bap = (daddr_t *)bp->b_data;
	if (lastbn != -1) {
		MALLOC(copy, daddr_t *, fs->e2fs_bsize, M_TEMP, M_WAITOK);
		bcopy((caddr_t)bap, (caddr_t)copy, (u_int)fs->e2fs_bsize);
		bzero((caddr_t)&bap[last + 1],
d461 1
a461 1
		nb = bap[i];
d466 1
a466 1
						   (daddr_t)-1, level - 1,
d481 1
a481 1
		nb = bap[i];
@


1.13
log
@

Don't try to truncate anything except for symlinks, directories, and
regular files.

ftruncate and truncate that go through FFS/EXT2FS/MFS will now return
EINVAL when done on devices.

Bug introduced when VOP_TRUNCATE was removed, thus removing spec_truncate.

Thanks to millert@@ for tracking this one down.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.12 2001/06/27 04:58:47 art Exp $	*/
d190 1
a190 1
		return (EINVAL);
@


1.12
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.11 2001/06/23 02:07:51 csapuntz Exp $	*/
d95 1
a95 1
		error = ext2fs_truncate(ip, (off_t)0, 0, NOCRED);
d185 5
@


1.11
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.10 2001/05/24 07:13:43 jasoni Exp $	*/
a226 1
#if defined(UVM)
a228 4
#else
		vnode_pager_setsize(ovp, (u_long)length);
		(void) vnode_pager_uncache(ovp);
#endif
a256 1
#if defined(UVM)
a258 4
#else
		vnode_pager_setsize(ovp, (u_long)length);
		(void) vnode_pager_uncache(ovp);
#endif
@


1.10
log
@- fix pr 1548: Cannot set arbitrary atime/mtime on ext2fs volume
- checked by gluk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.9 2000/06/23 02:14:39 mickey Exp $	*/
d95 1
a95 1
		error = VOP_TRUNCATE(vp, (off_t)0, 0, NOCRED, NULL); 
d99 1
a99 1
		VOP_VFREE(vp, ip->i_number, ip->i_e2fs_mode);
d102 1
a102 2
		TIMEVAL_TO_TIMESPEC(&time, &ts);
		VOP_UPDATE(vp, &ts, &ts, 0);
d126 2
a127 2
ext2fs_update(v)
	void *v;
d129 1
a129 7
	struct vop_update_args /* {
		struct vnode *a_vp;
		struct timespec *a_access;
		struct timespec *a_modify;
		int a_waitfor;
	} */ *ap = v;
	register struct m_ext2fs *fs;
a130 1
	struct inode *ip;
d134 1
a134 1
	if (ap->a_vp->v_mount->mnt_flag & MNT_RDONLY)
a135 1
	ip = VTOI(ap->a_vp);
d138 2
a139 2
	    ap->a_access ? ap->a_access : &ts,
	    ap->a_modify ? ap->a_modify : &ts);
d154 1
a154 1
	if (ap->a_waitfor)
d170 1
a170 2
ext2fs_truncate(v)
	void *v;
d172 2
a173 10
	struct vop_truncate_args /* {
		struct vnode *a_vp;
		off_t a_length;
		int a_flags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	register struct vnode *ovp = ap->a_vp;
	register daddr_t lastblock;
	register struct inode *oip;
a175 1
	off_t length = ap->a_length;
a179 1
	struct timespec ts;
a186 2
	oip = VTOI(ovp);
	TIMEVAL_TO_TIMESPEC(&time, &ts);
d199 1
a199 1
		return (VOP_UPDATE(ovp, &ts, &ts, 1));
d203 1
a203 1
		return (VOP_UPDATE(ovp, &ts, &ts, 0));
d220 1
a220 1
		if (ap->a_flags & IO_SYNC)
d222 2
a223 2
		error = ext2fs_balloc(oip, lbn, offset + 1, ap->a_cred, &bp,
				   aflags);
d239 1
a239 1
		return (VOP_UPDATE(ovp, &ts, &ts, 1));
d254 1
a254 1
		if (ap->a_flags & IO_SYNC)
d256 2
a257 1
		error = ext2fs_balloc(oip, lbn, offset, ap->a_cred, &bp, aflags);
d302 1
a302 1
	if ((error = VOP_UPDATE(ovp, &ts, &ts, 1)) != 0)
d314 1
a314 1
	allerror = vinvalbuf(ovp, vflags, ap->a_cred, ap->a_p, 0, 0);
@


1.9
log
@remove obsolete vtrace guts; art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.8 2000/04/26 23:24:41 jasoni Exp $	*/
d140 1
d145 4
a148 1
	EXT2FS_ITIMES(ip, &time, &time);
@


1.8
log
@Support for ext2fs rev. 1 (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.7 1999/08/17 14:20:46 art Exp $	*/
a49 1
#include <sys/trace.h>
d443 1
a443 5
	if (bp->b_flags & (B_DONE | B_DELWRI)) {
		/* Braces must be here in case trace evaluates to nothing. */
		trace(TR_BREADHIT, pack(vp, fs->e2fs_bsize), lbn);
	} else {
		trace(TR_BREADMISS, pack(vp, fs->e2fs_bsize), lbn);
@


1.7
log
@we're lucky that the return values from VOP_INACTIVE are ignored
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.6 1999/02/26 03:21:59 art Exp $	*/
d64 1
a64 1
									daddr_t, int, long *));
@


1.7.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.9 2000/06/23 02:14:39 mickey Exp $	*/
d50 1
d64 1
a64 1
    				  daddr_t, int, long *));
d444 5
a448 1
	if (!(bp->b_flags & (B_DONE | B_DELWRI))) {
@


1.7.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.7.4.1 2001/05/14 22:47:39 niklas Exp $	*/
d95 1
a95 1
		error = ext2fs_truncate(ip, (off_t)0, 0, NOCRED);
d99 1
a99 1
		ext2fs_inode_free(ip, ip->i_number, ip->i_e2fs_mode);
d102 2
a103 1
		ext2fs_update(ip, NULL, NULL, 0);
d127 2
a128 2
ext2fs_update(struct inode *ip, struct timespec *atime, struct timespec *mtime,
    int waitfor)
d130 7
a136 1
	struct m_ext2fs *fs;
d138 1
a139 1
	struct timespec ts;
d141 1
a141 1
	if (ITOV(ip)->v_mount->mnt_flag & MNT_RDONLY)
d143 2
a144 4
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	EXT2FS_ITIMES(ip,
	    atime ? atime : &ts,
	    mtime ? mtime : &ts);
d159 1
a159 1
	if (waitfor)
d175 2
a176 1
ext2fs_truncate(struct inode *oip, off_t length, int flags, struct ucred *cred)
d178 10
a187 2
	struct vnode *ovp = ITOV(oip);
	daddr_t lastblock;
d190 1
d195 1
d203 2
d217 1
a217 1
		return (ext2fs_update(oip, NULL, NULL, 1));
d221 1
a221 1
		return (ext2fs_update(oip, NULL, NULL, 0));
d238 1
a238 1
		if (flags & IO_SYNC)
d240 2
a241 2
		error = ext2fs_buf_alloc(oip, lbn, offset + 1, cred, &bp,
		    aflags);
d245 1
d248 4
d257 1
a257 1
		return (ext2fs_update(oip, NULL, NULL, 1));
d272 1
a272 1
		if (flags & IO_SYNC)
d274 1
a274 2
		error = ext2fs_buf_alloc(oip, lbn, offset, cred, &bp, 
		    aflags);
d279 1
d282 4
d319 1
a319 1
	if ((error = ext2fs_update(oip, NULL, NULL, 1)) != 0)
d331 1
a331 1
	allerror = vinvalbuf(ovp, vflags, cred, curproc, 0, 0);
@


1.7.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_inode.c,v 1.7.4.2 2001/07/04 11:00:43 niklas Exp $	*/
/*	$NetBSD: ext2fs_inode.c,v 1.24 2001/06/19 12:59:18 wiz Exp $	*/
d62 9
a70 2
static int ext2fs_indirtrunc __P((struct inode *, ufs_daddr_t, ufs_daddr_t,
				ufs_daddr_t, int, long *));
a80 1
		struct proc *a_p;
d82 2
a83 3
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct proc *p = ap->a_p;
d91 1
a91 1
	if (ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime != 0)
a93 1
	error = 0;
d95 1
a95 3
		if (ip->i_e2fs_size != 0) {
			error = ext2fs_truncate(ip, (off_t)0, 0, NOCRED);
		}
d105 1
a105 1
	VOP_UNLOCK(vp, 0, p);
d111 1
a111 1
		vrecycle(vp, NULL, p);
a132 1
	caddr_t cp;
d151 3
a153 4
	ip->i_flag &= ~(IN_MODIFIED);
	cp = (caddr_t)bp->b_data +
	    (ino_to_fsbo(fs, ip->i_number) * EXT2_DINODE_SIZE);
	e2fs_isave(&ip->i_din.e2fs_din, (struct ext2fs_dinode *)cp);
d173 4
a176 4
	ufs_daddr_t lastblock;
	ufs_daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	ufs_daddr_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
	struct m_ext2fs *fs;
d180 1
a180 1
	int i;
a186 5
	if (ovp->v_type != VREG &&
	    ovp->v_type != VDIR &&
	    ovp->v_type != VLNK)
		return (0);

d240 1
a240 1
	 * zero'ed in case it ever become accessible again because
d283 1
a283 1
	memcpy((caddr_t)oldblks, (caddr_t)&oip->i_e2fs_blocks[0], sizeof oldblks);
d313 1
a313 1
		bn = fs2h32(oip->i_e2fs_blocks[NDADDR + level]);
d316 1
a316 1
			    fsbtodb(fs, bn), lastiblock[level], level, &count);
d334 1
a334 1
		bn = fs2h32(oip->i_e2fs_blocks[i]);
d341 2
d347 2
a348 3
		if (newblks[NDADDR + level] !=
		    oip->i_e2fs_blocks[NDADDR + level])
			panic("ext2fs_truncate1");
d351 1
a351 1
			panic("ext2fs_truncate2");
d353 2
a354 3
	    (!LIST_EMPTY(&ovp->v_cleanblkhd) ||
	     !LIST_EMPTY(&ovp->v_dirtyblkhd)))
		panic("ext2fs_truncate3");
d378 3
a380 3
	struct inode *ip;
	ufs_daddr_t lbn, lastbn;
	ufs_daddr_t dbn;
d384 1
a384 1
	int i;
d386 2
a387 2
	struct m_ext2fs *fs = ip->i_e2fs;
	ufs_daddr_t *bap;
d389 1
a389 1
	ufs_daddr_t *copy = NULL, nb, nlbn, last;
d431 5
a435 5
	bap = (ufs_daddr_t *)bp->b_data;
	if (lastbn >= 0) {
		MALLOC(copy, ufs_daddr_t *, fs->e2fs_bsize, M_TEMP, M_WAITOK);
		memcpy((caddr_t)copy, (caddr_t)bap, (u_int)fs->e2fs_bsize);
		memset((caddr_t)&bap[last + 1], 0,
d449 1
a449 1
		nb = fs2h32(bap[i]);
d454 1
a454 1
						   (ufs_daddr_t)-1, level - 1,
d469 1
a469 1
		nb = fs2h32(bap[i]);
@


1.7.4.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
#include <uvm/uvm_extern.h>
@


1.7.4.5
log
@Merge in -current
@
text
@d1 2
a2 1
/*	$NetBSD: ext2fs_inode.c,v 1.23 2001/02/18 20:17:04 chs Exp $	*/
a61 2
extern int prtactive;

d63 1
a63 1
				  ufs_daddr_t, int, long *));
d81 1
d174 1
a174 1
	ufs_daddr_t bn, lastiblock[NIADDR], indir_lbn[NIADDR];
d177 1
d181 1
a181 1
	int error, allerror;
d222 16
a237 2
		ext2fs_balloc_range(ovp, length - 1, 1, cred,
		    flags & IO_SYNC ? B_SYNC : 0);
d249 12
a260 1
	if (offset != 0) {
d262 8
a269 3

		/* XXXUBC we should handle more than just VREG */
		uvm_vnp_zerorange(ovp, length, size - offset);
a270 3
	oip->i_e2fs_size = length;
	uvm_vnp_setsize(ovp, length);

@


1.7.4.6
log
@Merge in trunk
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: ext2fs_inode.c,v 1.24 2001/06/19 12:59:18 wiz Exp $	*/
a52 1
#include <ufs/ufs/extattr.h>
d61 2
d64 1
a64 1
				ufs_daddr_t, int, long *));
a81 1
	extern int prtactive;
d174 1
a174 1
	ufs_daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
a176 1
	struct buf *bp;
d180 1
a180 1
	int aflags, error, allerror;
d221 2
a222 16
		offset = blkoff(fs, length - 1);
		lbn = lblkno(fs, length - 1);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = ext2fs_buf_alloc(oip, lbn, offset + 1, cred, &bp,
		    aflags);
		if (error)
			return (error);
		oip->i_e2fs_size = length;
		uvm_vnp_setsize(ovp, length);
		uvm_vnp_uncache(ovp);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
d234 1
a234 12
	if (offset == 0) {
		oip->i_e2fs_size = length;
	} else {
		lbn = lblkno(fs, length);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = ext2fs_buf_alloc(oip, lbn, offset, cred, &bp, 
		    aflags);
		if (error)
			return (error);
		oip->i_e2fs_size = length;
d236 3
a238 8
		uvm_vnp_setsize(ovp, length);
		uvm_vnp_uncache(ovp);
		bzero((char *)bp->b_data + offset, (u_int)(size - offset));
		allocbuf(bp, size);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
d240 3
@


1.7.4.7
log
@Merge in -current from roughly a week ago
@
text
@d63 2
a64 2
static int ext2fs_indirtrunc(struct inode *, ufs_daddr_t, ufs_daddr_t,
				ufs_daddr_t, int, long *);
@


1.7.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.7.4.7 2002/03/28 14:54:25 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
d63 2
a64 2
static int ext2fs_indirtrunc(struct inode *, ufs1_daddr_t, ufs1_daddr_t,
				ufs1_daddr_t, int, long *);
d174 3
a176 3
	ufs1_daddr_t lastblock;
	ufs1_daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	ufs1_daddr_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
d385 2
a386 2
	ufs1_daddr_t lbn, lastbn;
	ufs1_daddr_t dbn;
d393 1
a393 1
	ufs1_daddr_t *bap;
d395 1
a395 1
	ufs1_daddr_t *copy = NULL, nb, nlbn, last;
d437 1
a437 1
	bap = (ufs1_daddr_t *)bp->b_data;
d439 1
a439 1
		MALLOC(copy, ufs1_daddr_t *, fs->e2fs_bsize, M_TEMP, M_WAITOK);
d460 1
a460 1
						   (ufs1_daddr_t)-1, level - 1,
@


1.7.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d150 1
a150 1
	e2fs_isave(&ip->i_e2din, (struct ext2fs_dinode *)cp);
d197 1
a197 1
		bzero((char *)&oip->i_e2din.e2di_shortlink,
@


1.6
log
@add compatibility with uvm vnode pagers
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.5 1998/05/18 01:59:16 art Exp $	*/
d86 1
a86 1
	int error;
@


1.5
log
@The warnings shouldn't tell that this is ffs. It's confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.4 1997/11/06 05:59:14 csapuntz Exp $	*/
d246 4
d252 1
d280 4
d286 1
@


1.4
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.3 1997/06/12 21:09:33 downsj Exp $	*/
d90 1
a90 1
		vprint("ffs_inactive: pushing active", vp);
@


1.3
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_inode.c,v 1.2 1997/05/30 08:33:55 downsj Exp $	*/
d66 3
a68 2
void
ext2fs_init()
d70 1
a70 7
	static int done = 0;

	if (done)
		return;
	done = 1;
	ufs_ihashinit();
	return;
d92 2
a93 5
	if (ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime != 0) {
		if ((vp->v_flag & VXLOCK) == 0)
			vgone(vp);
		return (0);
	}
a94 10
	error = 0;
#ifdef DIAGNOSTIC
	if (VOP_ISLOCKED(vp))
		panic("ffs_inactive: locked inode");
	if (curproc)
		ip->i_lockholder = curproc->p_pid;
	else
		ip->i_lockholder = -1;
#endif
	ip->i_flag |= IN_LOCKED;
d106 2
a107 1
	VOP_UNLOCK(vp);
d112 2
a113 2
	if (vp->v_usecount == 0 && ip->i_e2fs_dtime != 0)
		vgone(vp);
@


1.2
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 2
a2 4
/*	$OpenBSD$	*/
/*	$NetBSD: ffs_inode.c,v 1.12 1996/11/06 03:02:59 thorpej Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d5 1
d38 1
d69 1
a69 1
    static int done = 0;
d71 5
a75 5
    if (done)
        return;
    done = 1;
    ufs_ihashinit();
    return;
d83 1
a83 1
    void *v;
d85 19
a103 19
    struct vop_inactive_args /* {
        struct vnode *a_vp;
    } */ *ap = v;
    register struct vnode *vp = ap->a_vp;
    register struct inode *ip = VTOI(vp);
    struct timespec ts;
    int error;
    extern int prtactive;
    
    if (prtactive && vp->v_usecount != 0)
        vprint("ffs_inactive: pushing active", vp);
    /* Get rid of inodes related to stale file handles. */
    if (ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime != 0) {
        if ((vp->v_flag & VXLOCK) == 0)
            vgone(vp);
        return (0);
    }
    
    error = 0;
d105 6
a110 6
    if (VOP_ISLOCKED(vp))
        panic("ffs_inactive: locked inode");
    if (curproc)
        ip->i_lockholder = curproc->p_pid;
    else
        ip->i_lockholder = -1;
d112 3
a114 3
    ip->i_flag |= IN_LOCKED;
    if (ip->i_e2fs_nlink == 0 && (vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
        error = VOP_TRUNCATE(vp, (off_t)0, 0, NOCRED, NULL); 
d117 15
a131 15
        ip->i_flag |= IN_CHANGE | IN_UPDATE;
        VOP_VFREE(vp, ip->i_number, ip->i_e2fs_mode);
    }
    if (ip->i_flag & (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) {
        TIMEVAL_TO_TIMESPEC(&time, &ts);
        VOP_UPDATE(vp, &ts, &ts, 0);
    }
    VOP_UNLOCK(vp);
    /*
     * If we are done with the inode, reclaim it
     * so that it can be reused immediately.
     */
    if (vp->v_usecount == 0 && ip->i_e2fs_dtime != 0)
        vgone(vp);
    return (error);
d168 2
a169 2
		      fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
		      (int)fs->e2fs_bsize, NOCRED, &bp);
d224 3
a226 3
	    (oip->i_e2fs_size < ovp->v_mount->mnt_maxsymlinklen ||
	     (ovp->v_mount->mnt_maxsymlinklen == 0 &&
	      oip->i_e2fs_nblock == 0))) {
d351 1
a351 1
			    fsbtodb(fs, bn), lastiblock[level], level, &count);
d388 1
a388 1
	    (ovp->v_dirtyblkhd.lh_first || ovp->v_cleanblkhd.lh_first))
d487 1
a487 1
	    i--, nlbn += factor) {
d493 2
a494 2
					       (daddr_t)-1, level - 1,
					       &blkcount);
d511 1
a511 1
					       last, level - 1, &blkcount);
@


1.1
log
@Initial revision
@
text
@d1 1
a157 1
	struct timespec ts;
d162 1
a162 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	EXT2FS_ITIMES(ip, ap->a_access, ap->a_modify, &ts);
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@
