head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.4
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.4
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.2
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.04.27.11.27.24;	author krw;	state Exp;
branches;
next	1.22;
commitid	bejTi8cGKUZtl5wF;

1.22
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.21;
commitid	LS2TNeCue5R9L67C;

1.21
date	2014.07.14.08.54.13;	author pelikan;	state Exp;
branches;
next	1.20;
commitid	5pxoUiNNvSjZa1j9;

1.20
date	2014.07.13.16.59.35;	author pelikan;	state Exp;
branches;
next	1.19;
commitid	zGe0z6RRYbZJpA8u;

1.19
date	2014.07.13.13.28.26;	author pelikan;	state Exp;
branches;
next	1.18;
commitid	dOiPqBMzR47FMb48;

1.18
date	2014.07.11.14.30.52;	author pelikan;	state Exp;
branches;
next	1.17;
commitid	WfVjFNbKSMyZjiSF;

1.17
date	2014.07.10.09.24.18;	author pelikan;	state Exp;
branches;
next	1.16;
commitid	qkMPClqJrQ3Iamib;

1.16
date	2014.05.27.14.31.24;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.16.08.24.13;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.02.00.45.50;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.04.22.46.22;	author pedro;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.30.13.58.55;	author niallo;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.29.04.01.09;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.18.00.06.21;	author art;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.04.26.23.24.39;	author jasoni;	state Exp;
branches;
next	1.3;

1.3
date	97.06.12.21.09.30;	author downsj;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	97.05.30.08.33.32;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.3.12.1
date	2001.05.14.22.47.38;	author niklas;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.3.12.4;

1.3.12.4
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.3.12.5;

1.3.12.5
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.32.49;	author art;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Pad struct ext2fs out to 1024 (a.k.a. ext2fs SBSIZE) bytes. Satisfies
assumptions in fsck_ext2fs and eliminates spurious "VALUES IN SUPER
BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE" messages.

Part of the problem reported to bugs@@ by Lampshade.

ok beck@@
@
text
@/*	$OpenBSD: ext2fs.h,v 1.22 2014/12/19 22:44:59 guenther Exp $	*/
/*	$NetBSD: ext2fs.h,v 1.10 2000/01/28 16:00:23 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fs.h	8.10 (Berkeley) 10/27/94
 *  Modified for ext2fs by Manuel Bouyer.
 */

#include <sys/endian.h>

/*
 * Each disk drive contains some number of file systems.
 * A file system consists of a number of cylinder groups.
 * Each cylinder group has inodes and data.
 *
 * A file system is described by its super-block, which in turn
 * describes the cylinder groups.  The super-block is critical
 * data and is replicated in each cylinder group to protect against
 * catastrophic loss.  This is done at `newfs' time and the critical
 * super-block data does not change, so the copies need not be
 * referenced further unless disaster strikes.
 *
 * The first boot and super blocks are given in absolute disk addresses.
 * The byte-offset forms are preferred, as they don't imply a sector size.
 */
#define BBSIZE		1024
#define SBSIZE		1024
#define	BBOFF		((off_t)(0))
#define	SBOFF		((off_t)(BBOFF + BBSIZE))
#define	BBLOCK		((daddr_t)(0))
#define	SBLOCK		((daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))

/*
 * Inodes are, like in UFS, 32-bit unsigned integers and therefore ufsino_t.
 * Disk blocks are 32-bit, if the filesystem isn't operating in 64-bit mode
 * (the incompatible ext4 64BIT flag).  More work is needed to properly use
 * daddr_t as the disk block data type on both BE and LE architectures.
 * XXX disk blocks are simply u_int32_t for now.
 */

/*
 * MINBSIZE is the smallest allowable block size.
 * MINBSIZE must be big enough to hold a cylinder group block,
 * thus changes to (struct cg) must keep its size within MINBSIZE.
 * Note that super blocks are always of size SBSIZE,
 * and that both SBSIZE and MAXBSIZE must be >= MINBSIZE.
 * FSIZE means fragment size.
 */
#define LOG_MINBSIZE	10
#define MINBSIZE	(1 << LOG_MINBSIZE)
#define LOG_MINFSIZE	10
#define MINFSIZE	(1 << LOG_MINFSIZE)

/*
 * The path name on which the file system is mounted is maintained
 * in fs_fsmnt. MAXMNTLEN defines the amount of space allocated in
 * the super block for this name.
 */
#define MAXMNTLEN	512

/*
 * MINFREE gives the minimum acceptable percentage of file system
 * blocks which may be free. If the freelist drops below this level
 * only the superuser may continue to allocate blocks. This may
 * be set to 0 if no reserve of free blocks is deemed necessary,
 * however throughput drops by fifty percent if the file system
 * is run at between 95% and 100% full; thus the minimum default
 * value of fs_minfree is 5%. However, to get good clustering
 * performance, 10% is a better choice. hence we use 10% as our
 * default value. With 10% free space, fragmentation is not a
 * problem, so we choose to optimize for time.
 */
#define MINFREE		5

/*
 * Super block for an ext2fs file system.
 */
struct ext2fs {
	u_int32_t  e2fs_icount;		/* Inode count */
	u_int32_t  e2fs_bcount;		/* blocks count */
	u_int32_t  e2fs_rbcount;	/* reserved blocks count */
	u_int32_t  e2fs_fbcount;	/* free blocks count */
	u_int32_t  e2fs_ficount;	/* free inodes count */
	u_int32_t  e2fs_first_dblock;	/* first data block */
	u_int32_t  e2fs_log_bsize;	/* block size = 1024*(2^e2fs_log_bsize) */
	u_int32_t  e2fs_log_fsize;	/* fragment size log2 */
	u_int32_t  e2fs_bpg;		/* blocks per group */
	u_int32_t  e2fs_fpg;		/* frags per group */
	u_int32_t  e2fs_ipg;		/* inodes per group */
	u_int32_t  e2fs_mtime;		/* mount time */
	u_int32_t  e2fs_wtime;		/* write time */
	u_int16_t  e2fs_mnt_count;	/* mount count */
	u_int16_t  e2fs_max_mnt_count;	/* max mount count */
	u_int16_t  e2fs_magic;		/* magic number */
	u_int16_t  e2fs_state;		/* file system state */
	u_int16_t  e2fs_beh;		/* behavior on errors */
	u_int16_t  e2fs_minrev;		/* minor revision level */
	u_int32_t  e2fs_lastfsck;	/* time of last fsck */
	u_int32_t  e2fs_fsckintv;	/* max time between fscks */
	u_int32_t  e2fs_creator;	/* creator OS */
	u_int32_t  e2fs_rev;		/* revision level */
	u_int16_t  e2fs_ruid;		/* default uid for reserved blocks */
	u_int16_t  e2fs_rgid;		/* default gid for reserved blocks */
	/* EXT2_DYNAMIC_REV superblocks */
	u_int32_t  e2fs_first_ino;	/* first non-reserved inode */
	u_int16_t  e2fs_inode_size;	/* size of inode structure */
	u_int16_t  e2fs_block_group_nr;	/* block grp number of this sblk*/
	u_int32_t  e2fs_features_compat; /*  compatible feature set */
	u_int32_t  e2fs_features_incompat; /* incompatible feature set */
	u_int32_t  e2fs_features_rocompat; /* RO-compatible feature set */
	u_int8_t   e2fs_uuid[16];	/* 128-bit uuid for volume */
	char       e2fs_vname[16];	/* volume name */
	char       e2fs_fsmnt[64];	/* name mounted on */
	u_int32_t  e2fs_algo;		/* For compression */
	u_int8_t   e2fs_prealloc;	/* # of blocks to preallocate */
	u_int8_t   e2fs_dir_prealloc;	/* # of blocks to preallocate for dir */
	u_int16_t  e2fs_reserved_ngdb;	/* # of reserved gd blocks for resize */
	/* Ext3 JBD2 journaling. */
	u_int8_t   e2fs_journal_uuid[16];
	u_int32_t  e2fs_journal_ino;
	u_int32_t  e2fs_journal_dev;
	u_int32_t  e2fs_last_orphan;	/* start of list of inodes to delete */
	u_int32_t  e2fs_hash_seed[4];	/* htree hash seed */
	u_int8_t   e2fs_def_hash_version;
	u_int8_t   e2fs_journal_backup_type;
	u_int16_t  e2fs_gdesc_size;
	u_int32_t  e2fs_default_mount_opts;
	u_int32_t  e2fs_first_meta_bg;
	u_int32_t  e2fs_mkfs_time;
	u_int32_t  e2fs_journal_backup[17];
	u_int32_t  reserved2[172];
};


/* in-memory data for ext2fs */
struct m_ext2fs {
	struct ext2fs e2fs;
	u_char	e2fs_fsmnt[MAXMNTLEN];	/* name mounted on */
	int8_t	e2fs_ronly;	/* mounted read-only flag */
	int8_t	e2fs_fmod;	/* super block modified flag */
	int32_t e2fs_fsize;	/* fragment size */
	int32_t	e2fs_bsize;	/* block size */
	int32_t e2fs_bshift;	/* ``lblkno'' calc of logical blkno */
	int32_t e2fs_bmask;	/* ``blkoff'' calc of blk offsets */
	int64_t e2fs_qbmask;	/* ~fs_bmask - for use with quad size */
	int32_t	e2fs_fsbtodb;	/* fsbtodb and dbtofsb shift constant */
	int32_t	e2fs_ncg;	/* number of cylinder groups */
	int32_t	e2fs_ngdb;	/* number of group descriptor block */
	int32_t	e2fs_ipb;	/* number of inodes per block */
	int32_t	e2fs_itpg;	/* number of inode table per group */
	off_t	e2fs_maxfilesize;	/* depends on LARGE/HUGE flags */
	struct	ext2_gd *e2fs_gd; /* group descriptors */
};

static inline int
e2fs_overflow(struct m_ext2fs *fs, off_t lower, off_t value)
{
	return (value < lower || value > fs->e2fs_maxfilesize);
}

/*
 * Filesystem identification
 */
#define	E2FS_MAGIC	0xef53	/* the ext2fs magic number */
#define E2FS_REV0	0	/* revision levels */
#define E2FS_REV1	1	/* revision levels */

/* compatible/imcompatible features */
#define EXT2F_COMPAT_PREALLOC		0x0001
#define EXT2F_COMPAT_HASJOURNAL		0x0004
#define EXT2F_COMPAT_RESIZE		0x0010
#define EXT2F_COMPAT_DIRHASHINDEX	0x0020


#define EXT2F_ROCOMPAT_SPARSESUPER	0x0001
#define EXT2F_ROCOMPAT_LARGEFILE	0x0002
#define EXT2F_ROCOMPAT_BTREE_DIR	0x0004
#define EXT2F_ROCOMPAT_HUGE_FILE	0x0008

#define EXT2F_INCOMPAT_COMP		0x0001
#define EXT2F_INCOMPAT_FTYPE		0x0002
#define EXT2F_INCOMPAT_RECOVER		0x0004
#define EXT2F_INCOMPAT_JOURNAL_DEV	0x0008
#define EXT2F_INCOMPAT_META_BG		0x0010
#define EXT2F_INCOMPAT_EXTENTS		0x0040
#define EXT2F_INCOMPAT_FLEX_BG		0x0200

/* features supported in this implementation */
#define EXT2F_COMPAT_SUPP		0x0000
#define EXT2F_ROCOMPAT_SUPP		(EXT2F_ROCOMPAT_SPARSESUPER | \
					 EXT2F_ROCOMPAT_LARGEFILE)
#define EXT2F_INCOMPAT_SUPP		(EXT2F_INCOMPAT_FTYPE)
#define EXT4F_RO_INCOMPAT_SUPP		(EXT2F_INCOMPAT_EXTENTS | \
					 EXT2F_INCOMPAT_FLEX_BG | \
					 EXT2F_INCOMPAT_META_BG | \
					 EXT2F_INCOMPAT_RECOVER)

/*
 * Definitions of behavior on errors
 */
#define E2FS_BEH_CONTINUE	1	/* continue operation */
#define E2FS_BEH_READONLY	2	/* remount fs read only */
#define E2FS_BEH_PANIC		3	/* cause panic */
#define E2FS_BEH_DEFAULT	E2FS_BEH_CONTINUE

/*
 * OS identification
 */
#define E2FS_OS_LINUX 0
#define E2FS_OS_HURD  1
#define E2FS_OS_MASIX 2

/*
 * Filesystem clean flags
 */
#define	E2FS_ISCLEAN	0x01
#define	E2FS_ERRORS	0x02

/* ext2 file system block group descriptor */

struct ext2_gd {
	u_int32_t ext2bgd_b_bitmap;	/* blocks bitmap block */
	u_int32_t ext2bgd_i_bitmap;	/* inodes bitmap block */
	u_int32_t ext2bgd_i_tables;	/* inodes table block  */
	u_int16_t ext2bgd_nbfree;	/* number of free blocks */
	u_int16_t ext2bgd_nifree;	/* number of free inodes */
	u_int16_t ext2bgd_ndirs;	/* number of directories */
	u_int16_t reserved;
	u_int32_t reserved2[3];
};

/*
 * If the EXT2F_ROCOMPAT_SPARSESUPER flag is set, the cylinder group has a
 * copy of the super and cylinder group descriptors blocks only if it's
 * a power of 3, 5 or 7
 */

static __inline__ int cg_has_sb(int) __attribute__((__unused__));
static __inline int
cg_has_sb(i)
	int i;
{
	int a3 ,a5 , a7;

	if (i == 0 || i == 1)
		return 1;
	for (a3 = 3, a5 = 5, a7 = 7;
	    a3 <= i || a5 <= i || a7 <= i;
	    a3 *= 3, a5 *= 5, a7 *= 7)
		if (i == a3 || i == a5 || i == a7)
			return 1;
	return 0;
}

/*
 * Ext2 metadata is stored in little-endian byte order.
 * JBD2 journal used in ext3 and ext4 is big-endian!
 */
#if BYTE_ORDER == LITTLE_ENDIAN
#define e2fs_sbload(old, new) memcpy((new), (old), SBSIZE);
#define e2fs_cgload(old, new, size) memcpy((new), (old), (size));
#define e2fs_sbsave(old, new) memcpy((new), (old), SBSIZE);
#define e2fs_cgsave(old, new, size) memcpy((new), (old), (size));
#else
void e2fs_sb_bswap(struct ext2fs *, struct ext2fs *);
void e2fs_cg_bswap(struct ext2_gd *, struct ext2_gd *, int);
#define e2fs_sbload(old, new) e2fs_sb_bswap((old), (new))
#define e2fs_cgload(old, new, size) e2fs_cg_bswap((old), (new), (size));
#define e2fs_sbsave(old, new) e2fs_sb_bswap((old), (new))
#define e2fs_cgsave(old, new, size) e2fs_cg_bswap((old), (new), (size));
#endif

/*
 * Turn file system block numbers into disk block addresses.
 * This maps file system blocks to device size blocks.
 */
#define fsbtodb(fs, b)	((b) << (fs)->e2fs_fsbtodb)
#define dbtofsb(fs, b)	((b) >> (fs)->e2fs_fsbtodb)

/*
 * Macros for handling inode numbers:
 *	 inode number to file system block offset.
 *	 inode number to cylinder group number.
 *	 inode number to file system block address.
 */
#define	ino_to_cg(fs, x)	(((x) - 1) / (fs)->e2fs.e2fs_ipg)
#define	ino_to_fsba(fs, x)						\
	((fs)->e2fs_gd[ino_to_cg(fs, x)].ext2bgd_i_tables + \
	(((x)-1) % (fs)->e2fs.e2fs_ipg)/(fs)->e2fs_ipb)
#define	ino_to_fsbo(fs, x)	(((x)-1) % (fs)->e2fs_ipb)

/*
 * Give cylinder group number for a file system block.
 * Give cylinder group block number for a file system block.
 */
#define	dtog(fs, d) (((d) - (fs)->e2fs.e2fs_first_dblock) / (fs)->e2fs.e2fs_fpg)
#define	dtogd(fs, d) \
	(((d) - (fs)->e2fs.e2fs_first_dblock) % (fs)->e2fs.e2fs_fpg)

/*
 * The following macros optimize certain frequently calculated
 * quantities by using shifts and masks in place of divisions
 * modulos and multiplications.
 */
#define blkoff(fs, loc)		/* calculates (loc % fs->e2fs_bsize) */ \
	((loc) & (fs)->e2fs_qbmask)
#define lblktosize(fs, blk)	/* calculates (blk * fs->e2fs_bsize) */ \
	((blk) << (fs)->e2fs_bshift)
#define lblkno(fs, loc)		/* calculates (loc / fs->e2fs_bsize) */ \
	((loc) >> (fs)->e2fs_bshift)
#define blkroundup(fs, size)	/* calculates roundup(size, fs->e2fs_bsize) */ \
	(((size) + (fs)->e2fs_qbmask) & (fs)->e2fs_bmask)
#define fragroundup(fs, size)	/* calculates roundup(size, fs->e2fs_bsize) */ \
	(((size) + (fs)->e2fs_qbmask) & (fs)->e2fs_bmask)
/*
 * Determine the number of available frags given a
 * percentage to hold in reserve.
 */
#define freespace(fs) \
   ((fs)->e2fs.e2fs_fbcount - (fs)->e2fs.e2fs_rbcount)

/*
 * Number of indirects in a file system block.
 */
#define	NINDIR(fs)	((fs)->e2fs_bsize / sizeof(u_int32_t))
@


1.22
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.21 2014/07/14 08:54:13 pelikan Exp $	*/
d141 1
a141 1
	char       e2fs_fsmnt[64]; 	/* name mounted on */
d159 1
a159 1
	u_int32_t  reserved2[76];
@


1.21
log
@better type safety and KNF.

Because ext2fs has only 32-bit inode numbers, use ufsino_t as in FFS.
Disk blocks are u_int32_t as well, because we don't support the 64BIT flag.
When we do, there's going to be a lot more going on than just daddr_t.

While there, add some journaling-related bits into the superblock to play with.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.20 2014/07/13 16:59:35 pelikan Exp $	*/
d37 1
a37 1
#include <machine/endian.h>
@


1.20
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

Some KNF while there.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.19 2014/07/13 13:28:26 pelikan Exp $	*/
d62 5
a66 2
 * Addresses stored in inodes are capable of addressing blocks
 * XXX
d146 14
a159 1
	u_int32_t  reserved2[204];
@


1.19
log
@ext4 (extents) read support

Tested on amd64 with > 4GB files and 50,000 subdirectories.
From FreeBSD, thanks!

ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.18 2014/07/11 14:30:52 pelikan Exp $	*/
d268 2
a269 2
 * EXT2FS metadatas are stored in little-endian byte order. These macros
 * helps reading theses metadatas
a270 5

#define h2fs16(x) htole16(x)
#define h2fs32(x) htole32(x)
#define fs2h16(x) letoh16(x)
#define fs2h32(x) letoh32(x)
@


1.18
log
@determine and use maximum file size instead of magical constants

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.17 2014/07/10 09:24:18 pelikan Exp $	*/
d72 1
d74 1
a74 1
#define LOG_MINBSIZE 10
d76 2
d111 1
a111 1
	u_int32_t  e2fs_fsize;		/* fragment size */
d153 1
@


1.17
log
@prepare for upcoming ext4 read support

Parts of the on-disk inode changed their meaning in order to support bigger
sizes.  More flags & prettification.  No functional change.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.16 2014/05/27 14:31:24 krw Exp $	*/
d159 1
d163 5
a167 1

@


1.16
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.15 2013/06/11 16:42:18 deraadt Exp $	*/
d175 1
d181 1
d187 3
d193 7
a199 3
#define EXT2F_ROCOMPAT_SUPP		(EXT2F_ROCOMPAT_SPARSESUPER \
					| EXT2F_ROCOMPAT_LARGEFILE)
#define EXT2F_INCOMPAT_SUPP		EXT2F_INCOMPAT_FTYPE
@


1.15
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.14 2010/02/16 08:24:13 otto Exp $	*/
d314 1
a314 1
/* 
d317 1
a317 1
 */   
d319 1
a319 1
   ((fs)->e2fs.e2fs_fbcount - (fs)->e2fs.e2fs_rbcount) 
@


1.14
log
@add some defines needed for the upcoming newfs_ext2fs; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.13 2008/01/05 19:49:26 otto Exp $	*/
d58 2
a59 2
#define	BBLOCK		((daddr64_t)(0))
#define	SBLOCK		((daddr64_t)(BBLOCK + BBSIZE / DEV_BSIZE))
@


1.13
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.12 2007/06/02 00:45:50 pedro Exp $	*/
d139 1
a139 1
	u_int16_t  pad1;
d173 3
d191 8
@


1.12
log
@ufs1_daddr_t cleanup, okay thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.11 2005/10/04 22:46:22 pedro Exp $	*/
d58 2
a59 2
#define	BBLOCK		((daddr_t)(0))
#define	SBLOCK		((daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
@


1.11
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.10 2005/04/30 13:58:55 niallo Exp $	*/
d58 2
a59 2
#define	BBLOCK		((ufs1_daddr_t)(0))
#define	SBLOCK		((ufs1_daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
@


1.10
log
@Add support for large files (> 4GB).

Automatically converts old filesystems to use this if they are already at
revision 1 (like Linux). Revision 0 filesystems don't get converted (unlike
Linux).

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.9 2003/06/02 23:28:22 millert Exp $	*/
d159 1
a159 1
	struct	ext2_gd *e2fs_gd; /* group descripors */
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.8 2003/05/26 18:33:16 tedu Exp $	*/
d185 2
a186 1
#define EXT2F_ROCOMPAT_SUPP		EXT2F_ROCOMPAT_SPARSESUPER
@


1.8
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.7 2002/07/29 04:01:09 fgsch Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@add 2 flags from ext3. useful to help you diagnose problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.6 2002/03/14 01:27:14 millert Exp $	*/
d62 2
a63 2
#define	BBLOCK		((ufs_daddr_t)(0))
#define	SBLOCK		((ufs_daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.5 2001/09/18 00:06:21 art Exp $	*/
d184 2
@


1.5
log
@More cleanups from NetBSD and a bunch of endianness fixes.
The file ext2fs_bswap.c contains some functions to aid bigendian machines.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d222 1
a222 1
static __inline__ int cg_has_sb __P((int)) __attribute__((__unused__));
d254 2
a255 2
void e2fs_sb_bswap __P((struct ext2fs *, struct ext2fs *));
void e2fs_cg_bswap __P((struct ext2_gd *, struct ext2_gd *, int));
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.5 2001/09/18 00:06:21 art Exp $	*/
d222 1
a222 1
static __inline__ int cg_has_sb(int) __attribute__((__unused__));
d254 2
a255 2
void e2fs_sb_bswap(struct ext2fs *, struct ext2fs *);
void e2fs_cg_bswap(struct ext2_gd *, struct ext2_gd *, int);
@


1.5.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.5.4.1 2002/06/11 03:32:49 art Exp $	*/
a183 2
#define EXT2F_INCOMPAT_RECOVER		0x0004
#define EXT2F_INCOMPAT_JOURNAL_DEV	0x0008
@


1.4
log
@Support for ext2fs rev. 1 (from NetBSD)
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs.h,v 1.3 1997/06/12 21:09:30 downsj Exp $	*/
/*	$NetBSD: ext2fs.h,v 1.1 1997/06/11 09:33:37 bouyer Exp $	*/
d41 2
d62 2
a63 2
#define	BBLOCK		((daddr_t)(0))
#define	SBLOCK		((daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
d152 12
a163 12
	int8_t	e2fs_ronly;		/* mounted read-only flag */
	int8_t	e2fs_fmod;		/* super block modified flag */
	int32_t	e2fs_bsize;		/* block size */
	int32_t e2fs_bshift;		/* ``lblkno'' calc of logical blkno */
	int32_t e2fs_bmask;		/* ``blkoff'' calc of blk offsets */
	int64_t e2fs_qbmask;		/* ~fs_bmask - for use with quad size */
	int32_t	e2fs_fsbtodb;		/* fsbtodb and dbtofsb shift constant */
	int32_t	e2fs_ncg;		/* number of cylinder groups */
	int32_t	e2fs_ngdb;		/* number of group descriptor block */
	int32_t	e2fs_ipb;		/* number of inodes per block */
	int32_t	e2fs_itpg;		/* number of inode table per group */
	struct	ext2_gd *e2fs_gd;	/* group descripors */
d172 2
a173 2
#define E2FS_REV0	0	/* revision level */
#define E2FS_REV1	1	/* revision level */
d240 2
a241 2
 * EXT2FS metadatas are stored in little-endian byte order.  These macros
 * should aide in support for big-endian machines.
d243 18
a260 8
#define h2fs16(x) (x)
#define h2fs32(x) (x)
#define fs2h16(x) (x)
#define fs2h32(x) (x)
#define e2fs_sbload(old, new) bcopy((old), (new), SBSIZE);
#define e2fs_cgload(old, new, size) bcopy((old), (new), (size));
#define e2fs_sbsave(old, new) bcopy((old), (new), SBSIZE);
#define e2fs_cgsave(old, new, size) bcopy((old), (new), (size));
@


1.3
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.2 1997/05/30 08:33:32 downsj Exp $	*/
d103 5
a107 5
	u_int32_t  e2fs_icount;			/* Inode count */
	u_int32_t  e2fs_bcount;			/* blocks count */
	u_int32_t  e2fs_rbcount;		/* reserved blocks count */
	u_int32_t  e2fs_fbcount;		/* free blocks count */
	u_int32_t  e2fs_ficount;		/* free inodes count */
d109 8
a116 8
	u_int32_t  e2fs_log_bsize;		/* block size = 1024*(2^e2fs_log_bsize) */
	u_int32_t  e2fs_fsize;			/* fragment size */
	u_int32_t  e2fs_bpg;			/* blocks per group */
	u_int32_t  e2fs_fpg;			/* frags per group */
	u_int32_t  e2fs_ipg;			/* inodes per group */
	u_int32_t  e2fs_mtime;			/* mount time */
	u_int32_t  e2fs_wtime;			/* write time */
	u_int16_t  e2fs_mnt_count;		/* mount count */
d118 25
a142 11
	u_int16_t  e2fs_magic;			/* magic number */
	u_int16_t  e2fs_state;			/* file system state */
	u_int16_t  e2fs_beh;			/* behavior on errors */
	u_int16_t  reserved;
	u_int32_t  e2fs_lastfsck;		/* time of last fsck */
	u_int32_t  e2fs_fsckintv;		/* max time between fscks */
	u_int32_t  e2fs_creator;		/* creator OS */
	u_int32_t  e2fs_rev;			/* revision level */
	u_int16_t  e2fs_ruid;			/* default uid for reserved blocks */
	u_int16_t  e2fs_rgid;			/* default gid for reserved blocks */
	u_int32_t  reserved2[235];
d150 12
a161 12
	int8_t	e2fs_ronly;				/* mounted read-only flag */
	int8_t	e2fs_fmod;				/* super block modified flag */
	int32_t	e2fs_bsize;				/* block size */
	int32_t e2fs_bshift;			/* ``lblkno'' calc of logical blkno */
	int32_t e2fs_bmask;				/* ``blkoff'' calc of blk offsets */
	int64_t e2fs_qbmask;			/* ~fs_bmask - for use with quad size */
	int32_t	e2fs_fsbtodb;			/* fsbtodb and dbtofsb shift constant */
	int32_t	e2fs_ncg;				/* number of cylinder groups */
	int32_t	e2fs_ngdb;				/* number of group descriptor block */
	int32_t	e2fs_ipb;				/* number of inodes per block */
	int32_t	e2fs_itpg;				/* number of inode table per group */
	struct	ext2_gd *e2fs_gd;		/* group descripors */
d170 17
a186 1
#define E2FS_REV	0		/* revision level */
d199 1
a199 1
#define	E2FS_ERRORS		0x02
d212 1
d214 35
a248 1
};
@


1.3.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.4 2000/04/26 23:24:39 jasoni Exp $	*/
d103 5
a107 5
	u_int32_t  e2fs_icount;		/* Inode count */
	u_int32_t  e2fs_bcount;		/* blocks count */
	u_int32_t  e2fs_rbcount;	/* reserved blocks count */
	u_int32_t  e2fs_fbcount;	/* free blocks count */
	u_int32_t  e2fs_ficount;	/* free inodes count */
d109 8
a116 8
	u_int32_t  e2fs_log_bsize;	/* block size = 1024*(2^e2fs_log_bsize) */
	u_int32_t  e2fs_fsize;		/* fragment size */
	u_int32_t  e2fs_bpg;		/* blocks per group */
	u_int32_t  e2fs_fpg;		/* frags per group */
	u_int32_t  e2fs_ipg;		/* inodes per group */
	u_int32_t  e2fs_mtime;		/* mount time */
	u_int32_t  e2fs_wtime;		/* write time */
	u_int16_t  e2fs_mnt_count;	/* mount count */
d118 11
a128 25
	u_int16_t  e2fs_magic;		/* magic number */
	u_int16_t  e2fs_state;		/* file system state */
	u_int16_t  e2fs_beh;		/* behavior on errors */
	u_int16_t  e2fs_minrev;		/* minor revision level */
	u_int32_t  e2fs_lastfsck;	/* time of last fsck */
	u_int32_t  e2fs_fsckintv;	/* max time between fscks */
	u_int32_t  e2fs_creator;	/* creator OS */
	u_int32_t  e2fs_rev;		/* revision level */
	u_int16_t  e2fs_ruid;		/* default uid for reserved blocks */
	u_int16_t  e2fs_rgid;		/* default gid for reserved blocks */
	/* EXT2_DYNAMIC_REV superblocks */
	u_int32_t  e2fs_first_ino;	/* first non-reserved inode */
	u_int16_t  e2fs_inode_size;	/* size of inode structure */
	u_int16_t  e2fs_block_group_nr;	/* block grp number of this sblk*/
	u_int32_t  e2fs_features_compat; /*  compatible feature set */
	u_int32_t  e2fs_features_incompat; /* incompatible feature set */
	u_int32_t  e2fs_features_rocompat; /* RO-compatible feature set */
	u_int8_t   e2fs_uuid[16];	/* 128-bit uuid for volume */
	char       e2fs_vname[16];	/* volume name */
	char       e2fs_fsmnt[64]; 	/* name mounted on */
	u_int32_t  e2fs_algo;		/* For compression */
	u_int8_t   e2fs_prealloc;	/* # of blocks to preallocate */
	u_int8_t   e2fs_dir_prealloc;	/* # of blocks to preallocate for dir */
	u_int16_t  pad1;
	u_int32_t  reserved2[204];
d136 12
a147 12
	int8_t	e2fs_ronly;		/* mounted read-only flag */
	int8_t	e2fs_fmod;		/* super block modified flag */
	int32_t	e2fs_bsize;		/* block size */
	int32_t e2fs_bshift;		/* ``lblkno'' calc of logical blkno */
	int32_t e2fs_bmask;		/* ``blkoff'' calc of blk offsets */
	int64_t e2fs_qbmask;		/* ~fs_bmask - for use with quad size */
	int32_t	e2fs_fsbtodb;		/* fsbtodb and dbtofsb shift constant */
	int32_t	e2fs_ncg;		/* number of cylinder groups */
	int32_t	e2fs_ngdb;		/* number of group descriptor block */
	int32_t	e2fs_ipb;		/* number of inodes per block */
	int32_t	e2fs_itpg;		/* number of inode table per group */
	struct	ext2_gd *e2fs_gd;	/* group descripors */
d156 1
a156 17
#define E2FS_REV0	0	/* revision level */
#define E2FS_REV1	1	/* revision level */

/* compatible/imcompatible features */
#define EXT2F_COMPAT_PREALLOC		0x0001

#define EXT2F_ROCOMPAT_SPARSESUPER	0x0001
#define EXT2F_ROCOMPAT_LARGEFILE	0x0002
#define EXT2F_ROCOMPAT_BTREE_DIR	0x0004

#define EXT2F_INCOMPAT_COMP		0x0001
#define EXT2F_INCOMPAT_FTYPE		0x0002

/* features supported in this implementation */
#define EXT2F_COMPAT_SUPP		0x0000
#define EXT2F_ROCOMPAT_SUPP		EXT2F_ROCOMPAT_SPARSESUPER
#define EXT2F_INCOMPAT_SUPP		EXT2F_INCOMPAT_FTYPE
d169 1
a169 1
#define	E2FS_ERRORS	0x02
d182 1
a183 36

/*
 * If the EXT2F_ROCOMPAT_SPARSESUPER flag is set, the cylinder group has a
 * copy of the super and cylinder group descriptors blocks only if it's
 * a power of 3, 5 or 7
 */

static __inline__ int cg_has_sb __P((int)) __attribute__((__unused__));
static __inline int
cg_has_sb(i)
	int i;
{
	int a3 ,a5 , a7;

	if (i == 0 || i == 1)
		return 1;
	for (a3 = 3, a5 = 5, a7 = 7;
	    a3 <= i || a5 <= i || a7 <= i;
	    a3 *= 3, a5 *= 5, a7 *= 7)
		if (i == a3 || i == a5 || i == a7)
			return 1;
	return 0;
}

/*
 * EXT2FS metadatas are stored in little-endian byte order.  These macros
 * should aide in support for big-endian machines.
 */
#define h2fs16(x) (x)
#define h2fs32(x) (x)
#define fs2h16(x) (x)
#define fs2h32(x) (x)
#define e2fs_sbload(old, new) bcopy((old), (new), SBSIZE);
#define e2fs_cgload(old, new, size) bcopy((old), (new), (size));
#define e2fs_sbsave(old, new) bcopy((old), (new), SBSIZE);
#define e2fs_cgsave(old, new, size) bcopy((old), (new), (size));
@


1.3.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs.h,v 1.3.12.1 2001/05/14 22:47:38 niklas Exp $	*/
/*	$NetBSD: ext2fs.h,v 1.10 2000/01/28 16:00:23 bouyer Exp $	*/
a40 2
#include <machine/endian.h>

d60 2
a61 2
#define	BBLOCK		((ufs_daddr_t)(0))
#define	SBLOCK		((ufs_daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
d150 12
a161 12
	int8_t	e2fs_ronly;	/* mounted read-only flag */
	int8_t	e2fs_fmod;	/* super block modified flag */
	int32_t	e2fs_bsize;	/* block size */
	int32_t e2fs_bshift;	/* ``lblkno'' calc of logical blkno */
	int32_t e2fs_bmask;	/* ``blkoff'' calc of blk offsets */
	int64_t e2fs_qbmask;	/* ~fs_bmask - for use with quad size */
	int32_t	e2fs_fsbtodb;	/* fsbtodb and dbtofsb shift constant */
	int32_t	e2fs_ncg;	/* number of cylinder groups */
	int32_t	e2fs_ngdb;	/* number of group descriptor block */
	int32_t	e2fs_ipb;	/* number of inodes per block */
	int32_t	e2fs_itpg;	/* number of inode table per group */
	struct	ext2_gd *e2fs_gd; /* group descripors */
d170 2
a171 2
#define E2FS_REV0	0	/* revision levels */
#define E2FS_REV1	1	/* revision levels */
d238 2
a239 2
 * EXT2FS metadatas are stored in little-endian byte order. These macros
 * helps reading theses metadatas
d241 8
a248 18

#define h2fs16(x) htole16(x)
#define h2fs32(x) htole32(x)
#define fs2h16(x) letoh16(x)
#define fs2h32(x) letoh32(x)
#if BYTE_ORDER == LITTLE_ENDIAN
#define e2fs_sbload(old, new) memcpy((new), (old), SBSIZE);
#define e2fs_cgload(old, new, size) memcpy((new), (old), (size));
#define e2fs_sbsave(old, new) memcpy((new), (old), SBSIZE);
#define e2fs_cgsave(old, new, size) memcpy((new), (old), (size));
#else
void e2fs_sb_bswap __P((struct ext2fs *, struct ext2fs *));
void e2fs_cg_bswap __P((struct ext2_gd *, struct ext2_gd *, int));
#define e2fs_sbload(old, new) e2fs_sb_bswap((old), (new))
#define e2fs_cgload(old, new, size) e2fs_cg_bswap((old), (new), (size));
#define e2fs_sbsave(old, new) e2fs_sb_bswap((old), (new))
#define e2fs_cgsave(old, new, size) e2fs_cg_bswap((old), (new), (size));
#endif
@


1.3.12.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d222 1
a222 1
static __inline__ int cg_has_sb(int) __attribute__((__unused__));
d254 2
a255 2
void e2fs_sb_bswap(struct ext2fs *, struct ext2fs *);
void e2fs_cg_bswap(struct ext2_gd *, struct ext2_gd *, int);
@


1.3.12.4
log
@Sync the SMP branch with 3.3
@
text
@a183 2
#define EXT2F_INCOMPAT_RECOVER		0x0004
#define EXT2F_INCOMPAT_JOURNAL_DEV	0x0008
@


1.3.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs.h,v 1.3.12.4 2003/03/28 00:08:47 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
d62 2
a63 2
#define	BBLOCK		((ufs1_daddr_t)(0))
#define	SBLOCK		((ufs1_daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
@


1.2
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 2
a2 4
/*	$OpenBSD$	*/
/*	$NetBSD: fs.h,v 1.6 1995/04/12 21:21:02 mycroft Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d5 1
d38 1
d169 1
a169 1
#define	E2FS_ERRORS	    0x02
d194 3
a196 3
 *     inode number to file system block offset.
 *     inode number to cylinder group number.
 *     inode number to file system block address.
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@
