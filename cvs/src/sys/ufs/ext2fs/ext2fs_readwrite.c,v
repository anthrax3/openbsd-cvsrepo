head	1.40;
access;
symbols
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.2
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.2
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.4
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.16
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.14
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.10
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.12
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.8
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.6
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2016.03.01.21.00.56;	author natano;	state Exp;
branches;
next	1.39;
commitid	IZU5JUTrd4TpE0ix;

1.39
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.38;
commitid	gFybgYMymUyTbVeS;

1.38
date	2016.02.26.08.56.10;	author natano;	state Exp;
branches;
next	1.37;
commitid	1wcjndbWCkf5R7p2;

1.37
date	2016.02.16.17.56.12;	author stefan;	state Exp;
branches;
next	1.36;
commitid	6HMhQmvFL5xr8Rk9;

1.36
date	2016.01.12.11.44.21;	author mpi;	state Exp;
branches;
next	1.35;
commitid	KN4gzhbs7dVYcwxs;

1.35
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.34;
commitid	p4LJxGKbi0BU2cG6;

1.34
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.33;
commitid	C5iGb36LQxjM60Q3;

1.33
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.32;
commitid	uzzBR7hz9ncd4O6G;

1.32
date	2014.07.13.13.28.26;	author pelikan;	state Exp;
branches;
next	1.31;
commitid	dOiPqBMzR47FMb48;

1.31
date	2014.07.11.15.11.00;	author pelikan;	state Exp;
branches;
next	1.30;
commitid	hiGFqXvu0ypkr0tt;

1.30
date	2014.07.11.14.30.52;	author pelikan;	state Exp;
branches;
next	1.29;
commitid	WfVjFNbKSMyZjiSF;

1.29
date	2014.05.09.03.48.58;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.08.18.48.41;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2014.01.25.23.31.12;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2013.09.14.02.28.03;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2012.07.11.12.39.20;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.17.20.15.25;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.02.00.45.50;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.16.11.27.53;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.30.13.58.55;	author niallo;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.30.10.37.40;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.09.17.55.56;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.10.02.19.34;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.18.01.39.48;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.27.04.58.47;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.23.02.07.51;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.23.14.42.39;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	99.02.26.03.22.00;	author art;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	98.03.01.08.07.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.06.12.21.09.34;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.05.30.08.33.59;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.5.6.1
date	2001.05.14.22.47.39;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2001.07.04.11.00.44;	author niklas;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.5.6.5;

1.5.6.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.5.6.6;

1.5.6.6
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	;

1.11.2.1
date	2002.01.31.22.55.49;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.40
log
@*** empty log message ***
@
text
@/*	$OpenBSD: ext2fs_readwrite.c,v 1.39 2016/02/27 18:50:38 natano Exp $	*/
/*	$NetBSD: ext2fs_readwrite.c,v 1.16 2001/02/27 04:37:47 chs Exp $	*/

/*-
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_readwrite.c	8.8 (Berkeley) 8/4/94
 * Modified for ext2fs by Manuel Bouyer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/resourcevar.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/buf.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/signalvar.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/inode.h>
#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ext2fs/ext2fs_extern.h>


static int	ext2_ind_read(struct vnode *, struct inode *, struct m_ext2fs *, struct uio *);
static int	ext4_ext_read(struct vnode *, struct inode *, struct m_ext2fs *, struct uio *);

/*
 * Vnode op for reading.
 */
/* ARGSUSED */
int
ext2fs_read(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp;
	struct inode *ip;
	struct uio *uio;
	struct m_ext2fs *fs;

	vp = ap->a_vp;
	ip = VTOI(vp);
	uio = ap->a_uio;
	fs = ip->i_e2fs;

	if (ip->i_e2fs_flags & EXT4_EXTENTS)
		return ext4_ext_read(vp, ip, fs, uio);
	else
		return ext2_ind_read(vp, ip, fs, uio);
}

static int
ext2_ind_read(struct vnode *vp, struct inode *ip, struct m_ext2fs *fs,
    struct uio *uio)
{
	struct buf *bp;
	daddr_t lbn, nextlbn;
	off_t bytesinfile;
	int size, xfersize, blkoffset;
	int error;

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_READ)
		panic("%s: mode", "ext2fs_read");

	if (vp->v_type == VLNK) {
		if (ext2fs_size(ip) < EXT2_MAXSYMLINKLEN)
			panic("%s: short symlink", "ext2fs_read");
	} else if (vp->v_type != VREG && vp->v_type != VDIR)
		panic("%s: type %d", "ext2fs_read", vp->v_type);
#endif
	if (uio->uio_offset < 0)
		return (EINVAL);
	if (uio->uio_resid == 0)
		return (0);

	for (error = 0, bp = NULL; uio->uio_resid > 0; bp = NULL) {
		if ((bytesinfile = ext2fs_size(ip) - uio->uio_offset) <= 0)
			break;
		lbn = lblkno(fs, uio->uio_offset);
		nextlbn = lbn + 1;
		size = fs->e2fs_bsize;
		blkoffset = blkoff(fs, uio->uio_offset);
		xfersize = fs->e2fs_bsize - blkoffset;
		if (uio->uio_resid < xfersize)
			xfersize = uio->uio_resid;
		if (bytesinfile < xfersize)
			xfersize = bytesinfile;

		if (lblktosize(fs, nextlbn) >= ext2fs_size(ip))
			error = bread(vp, lbn, size, &bp);
		else if (lbn - 1 == ip->i_ci.ci_lastr) {
			int nextsize = fs->e2fs_bsize;
			error = breadn(vp, lbn, size, &nextlbn, &nextsize,
			    1, &bp);
		} else
			error = bread(vp, lbn, size, &bp);
		if (error)
			break;
		ip->i_ci.ci_lastr = lbn;

		/*
		 * We should only get non-zero b_resid when an I/O error
		 * has occurred, which should cause us to break above.
		 * However, if the short read did not cause an error,
		 * then we want to ensure that we do not uiomove bad
		 * or uninitialized data.
		 */
		size -= bp->b_resid;
		if (size < xfersize) {
			if (size == 0)
				break;
			xfersize = size;
		}
		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
		if (error)
			break;
		brelse(bp);
	}
	if (bp != NULL)
		brelse(bp);

	if (!(vp->v_mount->mnt_flag & MNT_NOATIME)) {
		ip->i_flag |= IN_ACCESS;
	}
	return (error);
}

int
ext4_ext_read(struct vnode *vp, struct inode *ip, struct m_ext2fs *fs, struct uio *uio)
{
	struct ext4_extent_path path;
	struct ext4_extent nex, *ep;
	struct buf *bp;
	daddr_t lbn, pos;
	off_t bytesinfile;
	int size, xfersize, blkoffset;
	int error, cache_type;

	memset(&path, 0, sizeof path);

	if (uio->uio_offset < 0)
		return (EINVAL);
	if (uio->uio_resid == 0)
		return (0);

	while (uio->uio_resid > 0) {
		if ((bytesinfile = ext2fs_size(ip) - uio->uio_offset) <= 0)
			break;
		lbn = lblkno(fs, uio->uio_offset);
		size = fs->e2fs_bsize;
		blkoffset = blkoff(fs, uio->uio_offset);

		xfersize = fs->e2fs_fsize - blkoffset;
		xfersize = MIN(xfersize, uio->uio_resid);
		xfersize = MIN(xfersize, bytesinfile);

		cache_type = ext4_ext_in_cache(ip, lbn, &nex);
		switch (cache_type) {
		case EXT4_EXT_CACHE_NO:
			ext4_ext_find_extent(fs, ip, lbn, &path);
			if ((ep = path.ep_ext) == NULL)
				return (EIO);
			ext4_ext_put_cache(ip, ep, EXT4_EXT_CACHE_IN);

			pos = lbn - ep->e_blk + (((daddr_t) ep->e_start_hi << 32) | ep->e_start_lo);
			if (path.ep_bp != NULL) {
				brelse(path.ep_bp);
				path.ep_bp = NULL;
			}
			break;
		case EXT4_EXT_CACHE_GAP:
			/* block has not been allocated yet */
			return (0);
		case EXT4_EXT_CACHE_IN:
			pos = lbn - nex.e_blk + (((daddr_t) nex.e_start_hi << 32) | nex.e_start_lo);
			break;
		}
		error = bread(ip->i_devvp, fsbtodb(fs, pos), size, &bp);
		if (error) {
			brelse(bp);
			return (error);
		}
		size -= bp->b_resid;
		if (size < xfersize) {
			if (size == 0) {
				brelse(bp);
				break;
			}
			xfersize = size;
		}
		error = uiomove(bp->b_data + blkoffset, xfersize, uio);
		brelse(bp);
		if (error)
			return (error);
	}
	return (0);
}

/*
 * Vnode op for writing.
 */
int
ext2fs_write(void *v)
{
	struct vop_write_args *ap = v;
	struct vnode *vp;
	struct uio *uio;
	struct inode *ip;
	struct m_ext2fs *fs;
	struct buf *bp;
	int32_t lbn;
	off_t osize;
	int blkoffset, error, flags, ioflag, size, xfersize;
	size_t resid;
	ssize_t overrun;

	ioflag = ap->a_ioflag;
	uio = ap->a_uio;
	vp = ap->a_vp;
	ip = VTOI(vp);

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_WRITE)
		panic("%s: mode", "ext2fs_write");
#endif

	/*
	 * If writing 0 bytes, succeed and do not change
	 * update time or file offset (standards compliance)
	 */
	if (uio->uio_resid == 0)
		return (0);

	switch (vp->v_type) {
	case VREG:
		if (ioflag & IO_APPEND)
			uio->uio_offset = ext2fs_size(ip);
		if ((ip->i_e2fs_flags & EXT2_APPEND) &&
			uio->uio_offset != ext2fs_size(ip))
			return (EPERM);
		/* FALLTHROUGH */
	case VLNK:
		break;
	case VDIR:
		if ((ioflag & IO_SYNC) == 0)
			panic("%s: nonsync dir write", "ext2fs_write");
		break;
	default:
		panic("%s: type", "ext2fs_write");
	}

	fs = ip->i_e2fs;
	if (e2fs_overflow(fs, uio->uio_resid, uio->uio_offset + uio->uio_resid))
		return (EFBIG);

	/* do the filesize rlimit check */
	if ((error = vn_fsizechk(vp, uio, ioflag, &overrun)))
		return (error);

	resid = uio->uio_resid;
	osize = ext2fs_size(ip);
	flags = ioflag & IO_SYNC ? B_SYNC : 0;

	for (error = 0; uio->uio_resid > 0;) {
		lbn = lblkno(fs, uio->uio_offset);
		blkoffset = blkoff(fs, uio->uio_offset);
		xfersize = fs->e2fs_bsize - blkoffset;
		if (uio->uio_resid < xfersize)
			xfersize = uio->uio_resid;
		if (fs->e2fs_bsize > xfersize)
			flags |= B_CLRBUF;
		else
			flags &= ~B_CLRBUF;

		error = ext2fs_buf_alloc(ip,
			lbn, blkoffset + xfersize, ap->a_cred, &bp, flags);
		if (error)
			break;
		if (uio->uio_offset + xfersize > ext2fs_size(ip)) {
			error = ext2fs_setsize(ip, uio->uio_offset + xfersize);
			if (error)
				break;
			uvm_vnp_setsize(vp, ip->i_e2fs_size);
		}
		uvm_vnp_uncache(vp);

		size = fs->e2fs_bsize - bp->b_resid;
		if (size < xfersize)
			xfersize = size;

		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
#if 0
		if (ioflag & IO_NOCACHE)
			bp->b_flags |= B_NOCACHE;
#endif
		if (ioflag & IO_SYNC)
			(void)bwrite(bp);
		else if (xfersize + blkoffset == fs->e2fs_bsize)
			bawrite(bp);
		else
			bdwrite(bp);
		if (error || xfersize == 0)
			break;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	/*
	 * If we successfully wrote any data, and we are not the superuser
	 * we clear the setuid and setgid bits as a precaution against
	 * tampering.
	 */
	if (resid > uio->uio_resid && ap->a_cred && ap->a_cred->cr_uid != 0)
		ip->i_e2fs_mode &= ~(ISUID | ISGID);
	if (error) {
		if (ioflag & IO_UNIT) {
			(void)ext2fs_truncate(ip, osize,
				ioflag & IO_SYNC, ap->a_cred);
			uio->uio_offset -= resid - uio->uio_resid;
			uio->uio_resid = resid;
		}
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC)) {
		error = ext2fs_update(ip, 1);
	}
	/* correct the result for writes clamped by vn_fsizechk() */
	uio->uio_resid += overrun;
	return (error);
}
@


1.39
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.38 2016/02/26 08:56:10 natano Exp $	*/
d103 2
a104 2
	if (e2fs_overflow(fs, 0, uio->uio_offset))
		return (EFBIG);
a165 1
	size_t orig_resid;
d173 3
a175 2
	orig_resid = uio->uio_resid;
	if (orig_resid == 0)
a176 3

	if (e2fs_overflow(fs, 0, uio->uio_offset))
		return (EFBIG);
@


1.38
log
@Convert mnt_maxsymlinklen to unsigned.

This allows to remove some truncating casts in symlink handling code.
Also, validate fs_maxsymlinklen in the superblock at mount time and on
fsck to make sure we don't use bogus data.

discussion & ok millert@@, stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.37 2016/02/16 17:56:12 stefan Exp $	*/
d98 1
a98 3
		if (ext2fs_size(ip) < vp->v_mount->mnt_maxsymlinklen ||
		    (vp->v_mount->mnt_maxsymlinklen == 0 &&
		    ip->i_e2fs_nblock == 0))
@


1.37
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.36 2016/01/12 11:44:21 mpi Exp $	*/
d98 1
a98 1
		if ((int)ext2fs_size(ip) < vp->v_mount->mnt_maxsymlinklen ||
@


1.36
log
@Kill the "doclusterread" and "doclusterwrite" defines.

They are defined to 0 since the import of ext2fs 19 years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.35 2015/03/14 03:38:52 jsg Exp $	*/
d90 1
a90 1
	long size, xfersize, blkoffset;
d148 1
a148 1
		error = uiomovei((char *)bp->b_data + blkoffset, xfersize, uio);
d171 1
a171 1
	long size, xfersize, blkoffset;
d228 1
a228 1
		error = uiomovei(bp->b_data + blkoffset, xfersize, uio);
d251 2
a252 1
	ssize_t resid, overrun;
d328 1
a328 2
		error =
			uiomovei((char *)bp->b_data + blkoffset, (int)xfersize, uio);
@


1.35
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.34 2015/02/10 21:56:10 miod Exp $	*/
a58 3
#define doclusterread 0 /* XXX underway */
#define doclusterwrite 0

d335 3
a337 6
		else if (xfersize + blkoffset == fs->e2fs_bsize) {
			if (doclusterwrite)
				cluster_write(bp, &ip->i_ci, ext2fs_size(ip));
			else
				bawrite(bp);
		} else
@


1.34
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.33 2014/09/14 14:17:26 jsg Exp $	*/
a43 1
#include <sys/conf.h>
@


1.33
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.32 2014/07/13 13:28:26 pelikan Exp $	*/
d152 1
a152 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
d232 1
a232 1
		error = uiomove(bp->b_data + blkoffset, xfersize, uio);
d332 1
a332 1
			uiomove((char *)bp->b_data + blkoffset, (int)xfersize, uio);
@


1.32
log
@ext4 (extents) read support

Tested on amd64 with > 4GB files and 50,000 subdirectories.
From FreeBSD, thanks!

ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.31 2014/07/11 15:11:00 pelikan Exp $	*/
a43 1
#include <sys/proc.h>
@


1.31
log
@split ext2fs_read for the upcoming ext4 extent bits, like FreeBSD has done

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.30 2014/07/11 14:30:52 pelikan Exp $	*/
d52 1
d59 1
d82 4
a85 1
	return ext2_ind_read(vp, ip, fs, uio);
d165 74
@


1.30
log
@determine and use maximum file size instead of magical constants

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.29 2014/05/09 03:48:58 tedu Exp $	*/
d57 2
d74 13
a92 4
	vp = ap->a_vp;
	ip = VTOI(vp);
	uio = ap->a_uio;

d99 2
a100 2
			(vp->v_mount->mnt_maxsymlinklen == 0 &&
			 ip->i_e2fs_nblock == 0))
a104 1
	fs = ip->i_e2fs;
@


1.29
log
@disable IO_NOCACHE B_NOCACHE conversion until it works.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.28 2014/04/08 18:48:41 beck Exp $	*/
d95 1
a95 2
	if ((u_int64_t)uio->uio_offset >
		((u_int64_t)0x80000000 * fs->e2fs_bsize - 1))
d205 1
a205 3
	if (uio->uio_offset < 0 ||
		(u_int64_t)uio->uio_offset + uio->uio_resid >
		((u_int64_t)0x80000000 * fs->e2fs_bsize - 1))
@


1.28
log
@add IO_NOCACHE flag to vop_write arguments, which in turn sets B_NOCACHE
on the written buffers. Use the flag for writes from the page daemon to
ensure that we free buffers written out by the page daemon rather than
caching them.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.27 2014/01/25 23:31:12 guenther Exp $	*/
d248 1
d251 1
@


1.27
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.26 2013/09/14 02:28:03 guenther Exp $	*/
d248 2
@


1.26
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.25 2013/06/11 16:42:18 deraadt Exp $	*/
d276 1
a276 1
		error = ext2fs_update(ip, NULL, NULL, 1);
@


1.25
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.24 2012/07/11 12:39:20 guenther Exp $	*/
d167 2
a168 1
	int blkoffset, error, flags, ioflag, resid, size, xfersize, overrun;
@


1.24
log
@If the current offset is strictly less than the process filesize
rlimit, then a write that would take it over the limit should be
clamped, making it a partial write.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.23 2011/07/04 04:30:41 tedu Exp $	*/
d73 1
a73 1
	daddr64_t lbn, nextlbn;
@


1.23
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.22 2007/06/17 20:15:25 jasper Exp $	*/
a164 1
	struct proc *p;
d167 1
a167 1
	int blkoffset, error, flags, ioflag, resid, size, xfersize;
d209 4
a212 11
	/*
	 * Maybe this should be above the vnode op call, but so long as
	 * file servers have no limits, I don't think it matters.
	 */
	p = uio->uio_procp;
	if (vp->v_type == VREG && p &&
		uio->uio_offset + uio->uio_resid >
		p->p_rlimit[RLIMIT_FSIZE].rlim_cur) {
		psignal(p, SIGXFSZ);
		return (EFBIG);
	}
d277 2
@


1.22
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.21 2007/06/02 00:45:50 pedro Exp $	*/
d115 1
a115 1
			error = bread(vp, lbn, size, NOCRED, &bp);
d118 2
a119 2
			error = breadn(vp, lbn,
				size, &nextlbn, &nextsize, 1, NOCRED, &bp);
d121 1
a121 1
			error = bread(vp, lbn, size, NOCRED, &bp);
@


1.21
log
@ufs1_daddr_t cleanup, okay thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.20 2007/06/01 23:47:57 deraadt Exp $	*/
d65 1
a65 2
ext2fs_read(v)
	void *v;
d157 1
a157 2
ext2fs_write(v)
	void *v;
@


1.20
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.19 2007/05/26 20:26:51 pedro Exp $	*/
d168 1
a168 1
	ufs1_daddr_t lbn;
@


1.19
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.18 2006/10/16 11:27:53 pedro Exp $	*/
d68 1
a68 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d161 1
a161 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
@


1.18
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.17 2005/04/30 13:58:55 niallo Exp $	*/
a121 3
		else if (doclusterread)
			error = cluster_read(vp, &ip->i_ci,
				ext2fs_size(ip), lbn, size, NOCRED, &bp);
@


1.17
log
@Add support for large files (> 4GB).

Automatically converts old filesystems to use this if they are already at
revision 1 (like Linux). Revision 0 filesystems don't get converted (unlike
Linux).

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.16 2003/06/02 23:28:22 millert Exp $	*/
d79 1
a79 1
	ufs1_daddr_t lbn, nextlbn;
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.15 2003/05/26 18:33:16 tedu Exp $	*/
d93 1
a93 1
		if ((int)ip->i_e2fs_size < vp->v_mount->mnt_maxsymlinklen ||
d108 1
a108 1
		if ((bytesinfile = ip->i_e2fs_size - uio->uio_offset) <= 0)
d120 1
a120 1
		if (lblktosize(fs, nextlbn) >= ip->i_e2fs_size)
d124 1
a124 1
				ip->i_e2fs_size, lbn, size, NOCRED, &bp);
d205 1
a205 1
			uio->uio_offset = ip->i_e2fs_size;
d207 1
a207 1
			uio->uio_offset != ip->i_e2fs_size)
d238 1
a238 1
	osize = ip->i_e2fs_size;
d256 4
a259 2
		if (uio->uio_offset + xfersize > ip->i_e2fs_size) {
			ip->i_e2fs_size = uio->uio_offset + xfersize;
d274 1
a274 1
				cluster_write(bp, &ip->i_ci, ip->i_e2fs_size);
@


1.15
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.14 2002/03/30 10:37:40 niklas Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@RCSId
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.16 2001/02/27 04:37:47 chs Exp $	*/
d83 1
a83 1
	ufs_daddr_t lbn, nextlbn;
d185 1
a185 1
	ufs_daddr_t lbn;
@


1.13
log
@If a write(2) is done with a length of zero bytes, short-circuit and do not
update the modification time -- required by POSIX.  ok millert@@ drahn@@
@
text
@d1 1
@


1.12
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d198 7
@


1.11
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@a81 2
	void *win;
	vsize_t bytelen;
a109 21
	if (vp->v_type == VREG) {
		error = 0;
		while (uio->uio_resid > 0) {

			bytelen = MIN(ip->i_e2fs_size - uio->uio_offset,
			    uio->uio_resid);

			if (bytelen == 0) {
				break;
			}
			win = ubc_alloc(&vp->v_uobj, uio->uio_offset,
					&bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error) {
				break;
			}
		}
		goto out;
	}

a158 1
out:
a160 2
		if ((ap->a_ioflag & IO_SYNC) == IO_SYNC)
			error = ext2fs_update(ip, NULL, NULL, 1);
d186 1
a186 5
	int blkoffset, error, flags, ioflag, resid, xfersize;
	vsize_t bytelen;
	void *win;
	off_t oldoff;
	boolean_t rv;
a191 1
	error = 0;
d235 1
a236 42
	if (vp->v_type == VREG) {
		while (uio->uio_resid > 0) {
			oldoff = uio->uio_offset;
			blkoffset = blkoff(fs, uio->uio_offset);
			bytelen = MIN(fs->e2fs_bsize - blkoffset,
			    uio->uio_resid);

			/*
			 * XXXUBC if file is mapped and this is the last block,
			 * process one page at a time.
			 */

			error = ext2fs_balloc_range(vp, uio->uio_offset,
			    bytelen, ap->a_cred, 0);
			if (error) {
				break;
			}
			win = ubc_alloc(&vp->v_uobj, uio->uio_offset,
			    &bytelen, UBC_WRITE);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error) {
				break;
			}

			/*
			 * flush what we just wrote if necessary.
			 * XXXUBC simplistic async flushing.
			 */

			if (oldoff >> 16 != uio->uio_offset >> 16) {
				simple_lock(&vp->v_uobj.vmobjlock);
				rv = vp->v_uobj.pgops->pgo_flush(
				    &vp->v_uobj, (oldoff >> 16) << 16,
				    (uio->uio_offset >> 16) << 16, PGO_CLEANIT);
				simple_unlock(&vp->v_uobj.vmobjlock);
			}
		}
		goto out;
	}

	flags = ioflag & IO_SYNC ? B_SYNC : 0;
d240 4
a243 2
		xfersize = MIN(fs->e2fs_bsize - blkoffset, uio->uio_resid);
		if (xfersize < fs->e2fs_bsize)
d247 1
d249 1
a249 1
		    lbn, blkoffset + xfersize, ap->a_cred, &bp, flags);
d252 1
a252 1
		if (ip->i_e2fs_size < uio->uio_offset + xfersize) {
d254 1
d256 8
a263 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
d275 1
a281 2
out:
	ip->i_flag |= IN_CHANGE | IN_UPDATE;
d291 1
a291 1
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC) == IO_SYNC)
d293 1
@


1.11.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@a228 7
	/*
	 * If writing 0 bytes, succeed and do not change
	 * update time or file offset (standards compliance)
	 */
	if (uio->uio_resid == 0)
		return (0);

@


1.11.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d216 1
d281 5
d306 1
a306 1
				error = vp->v_uobj.pgops->pgo_put(
d309 1
a311 5
		if (error == 0 && ioflag & IO_SYNC) {
			simple_lock(&vp->v_uobj.vmobjlock);
			error = vp->v_uobj.pgops->pgo_put(&vp->v_uobj, oldoff,
			    oldoff + bytelen, PGO_CLEANIT|PGO_SYNCIO);
		}
d354 6
a359 3
		(void)ext2fs_truncate(ip, osize, ioflag & IO_SYNC, ap->a_cred);
		uio->uio_offset -= resid - uio->uio_resid;
		uio->uio_resid = resid;
@


1.11.2.3
log
@Sync UBC branch to -current
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.10
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d122 1
a122 1
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
d284 1
a284 1
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
d298 3
a300 3
				simple_lock(&vp->v_uvm.u_obj.vmobjlock);
				rv = vp->v_uvm.u_obj.pgops->pgo_flush(
				    &vp->v_uvm.u_obj, (oldoff >> 16) << 16,
d302 1
a302 1
				simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
@


1.9
log
@various cleanups from NetBSD
@
text
@d82 2
d112 21
d182 1
d185 2
d212 5
a216 1
	int blkoffset, error, flags, ioflag, resid, size, xfersize;
d222 1
d266 42
a308 1

d312 2
a313 4
		xfersize = fs->e2fs_bsize - blkoffset;
		if (uio->uio_resid < xfersize)
			xfersize = uio->uio_resid;
		if (fs->e2fs_bsize > xfersize)
a316 1

d318 1
a318 1
			lbn, blkoffset + xfersize, ap->a_cred, &bp, flags);
d321 1
a321 1
		if (uio->uio_offset + xfersize > ip->i_e2fs_size) {
a322 1
			uvm_vnp_setsize(vp, ip->i_e2fs_size);
d324 1
a324 8
		uvm_vnp_uncache(vp);

		size = fs->e2fs_bsize - bp->b_resid;
		if (size < xfersize)
			xfersize = size;

		error =
			uiomove((char *)bp->b_data + blkoffset, (int)xfersize, uio);
a335 1
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
d342 2
d353 1
a353 1
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC)) {
a354 1
	}
@


1.8
log
@Remove old vm.
@
text
@d1 1
a1 2
/*	$OpenBSD: ext2fs_readwrite.c,v 1.7 2001/06/23 02:07:51 csapuntz Exp $	*/
/*	$NetBSD: ext2fs_readwrite.c,v 1.1 1997/06/11 09:34:01 bouyer Exp $	*/
a53 2
#include <vm/vm.h>

d77 4
a80 4
	register struct vnode *vp;
	register struct inode *ip;
	register struct uio *uio;
	register struct m_ext2fs *fs;
d82 1
a82 1
	daddr_t lbn, nextlbn;
a85 1
	u_short mode;
a88 1
	mode = ip->i_e2fs_mode;
d151 1
a151 2
		error = uiomove((char *)bp->b_data + blkoffset, (int)xfersize,
				uio);
d158 2
a159 1
	if (!(vp->v_mount->mnt_flag & MNT_NOATIME))
d161 1
d178 4
a181 4
	register struct vnode *vp;
	register struct uio *uio;
	register struct inode *ip;
	register struct m_ext2fs *fs;
d184 1
a184 1
	daddr_t lbn;
@


1.7
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.6 2001/02/23 14:42:39 csapuntz Exp $	*/
a257 1
#if defined(UVM)
a258 3
#else
			vnode_pager_setsize(vp, (u_long)ip->i_e2fs_size);
#endif
a259 1
#if defined(UVM)
a260 3
#else
		(void)vnode_pager_uncache(vp);
#endif
@


1.6
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.5 1999/02/26 03:22:00 art Exp $	*/
a190 1
	struct timespec ts;
d252 1
a252 1
		error = ext2fs_balloc(ip,
d298 2
a299 2
			(void)VOP_TRUNCATE(vp, osize,
				ioflag & IO_SYNC, ap->a_cred, uio->uio_procp);
d304 1
a304 2
		TIMEVAL_TO_TIMESPEC(&time, &ts);
		error = VOP_UPDATE(vp, &ts, &ts, 1);
@


1.5
log
@add compatibility with uvm vnode pagers
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.4 1998/03/01 08:07:09 niklas Exp $	*/
d131 1
a131 1
			error = cluster_read(vp,
d133 1
a133 1
		else if (lbn - 1 == vp->v_lastr) {
d141 1
a141 1
		vp->v_lastr = lbn;
d281 1
a281 1
				cluster_write(bp, ip->i_e2fs_size);
@


1.5.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.6 2001/02/23 14:42:39 csapuntz Exp $	*/
d131 1
a131 1
			error = cluster_read(vp, &ip->i_ci,
d133 1
a133 1
		else if (lbn - 1 == ip->i_ci.ci_lastr) {
d141 1
a141 1
		ip->i_ci.ci_lastr = lbn;
d281 1
a281 1
				cluster_write(bp, &ip->i_ci, ip->i_e2fs_size);
@


1.5.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.5.6.1 2001/05/14 22:47:39 niklas Exp $	*/
d191 1
d253 1
a253 1
		error = ext2fs_buf_alloc(ip,
d259 1
d261 3
d265 1
d267 3
d299 2
a300 2
			(void)ext2fs_truncate(ip, osize,
				ioflag & IO_SYNC, ap->a_cred);
d305 2
a306 1
		error = ext2fs_update(ip, NULL, NULL, 1);
@


1.5.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_readwrite.c,v 1.5.6.2 2001/07/04 11:00:44 niklas Exp $	*/
/*	$NetBSD: ext2fs_readwrite.c,v 1.16 2001/02/27 04:37:47 chs Exp $	*/
d55 2
d80 4
a83 4
	struct vnode *vp;
	struct inode *ip;
	struct uio *uio;
	struct m_ext2fs *fs;
d85 1
a85 1
	ufs_daddr_t lbn, nextlbn;
d89 1
d93 1
d156 2
a157 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
d164 1
a164 2

	if (!(vp->v_mount->mnt_flag & MNT_NOATIME)) {
a165 1
	}
d182 4
a185 4
	struct vnode *vp;
	struct uio *uio;
	struct inode *ip;
	struct m_ext2fs *fs;
d188 1
a188 1
	ufs_daddr_t lbn;
@


1.5.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a82 2
	void *win;
	vsize_t bytelen;
a110 21
	if (vp->v_type == VREG) {
		error = 0;
		while (uio->uio_resid > 0) {

			bytelen = MIN(ip->i_e2fs_size - uio->uio_offset,
			    uio->uio_resid);

			if (bytelen == 0) {
				break;
			}
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
					&bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error) {
				break;
			}
		}
		goto out;
	}

a159 1
out:
a161 2
		if ((ap->a_ioflag & IO_SYNC) == IO_SYNC)
			error = ext2fs_update(ip, NULL, NULL, 1);
d187 1
a187 5
	int blkoffset, error, flags, ioflag, resid, xfersize;
	vsize_t bytelen;
	void *win;
	off_t oldoff;
	boolean_t rv;
a192 1
	error = 0;
d236 1
a237 42
	if (vp->v_type == VREG) {
		while (uio->uio_resid > 0) {
			oldoff = uio->uio_offset;
			blkoffset = blkoff(fs, uio->uio_offset);
			bytelen = MIN(fs->e2fs_bsize - blkoffset,
			    uio->uio_resid);

			/*
			 * XXXUBC if file is mapped and this is the last block,
			 * process one page at a time.
			 */

			error = ext2fs_balloc_range(vp, uio->uio_offset,
			    bytelen, ap->a_cred, 0);
			if (error) {
				break;
			}
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
			    &bytelen, UBC_WRITE);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error) {
				break;
			}

			/*
			 * flush what we just wrote if necessary.
			 * XXXUBC simplistic async flushing.
			 */

			if (oldoff >> 16 != uio->uio_offset >> 16) {
				simple_lock(&vp->v_uvm.u_obj.vmobjlock);
				rv = vp->v_uvm.u_obj.pgops->pgo_flush(
				    &vp->v_uvm.u_obj, (oldoff >> 16) << 16,
				    (uio->uio_offset >> 16) << 16, PGO_CLEANIT);
				simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
			}
		}
		goto out;
	}

	flags = ioflag & IO_SYNC ? B_SYNC : 0;
d241 4
a244 2
		xfersize = MIN(fs->e2fs_bsize - blkoffset, uio->uio_resid);
		if (xfersize < fs->e2fs_bsize)
d248 1
d250 1
a250 1
		    lbn, blkoffset + xfersize, ap->a_cred, &bp, flags);
d253 1
a253 1
		if (ip->i_e2fs_size < uio->uio_offset + xfersize) {
d255 1
d257 8
a264 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
d276 1
a282 2
out:
	ip->i_flag |= IN_CHANGE | IN_UPDATE;
d292 1
a292 1
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC) == IO_SYNC)
d294 1
@


1.5.6.5
log
@Merge in trunk
@
text
@d83 2
d113 21
d183 1
d186 2
d213 5
a217 1
	int blkoffset, error, flags, ioflag, resid, size, xfersize;
d223 1
a229 7
	/*
	 * If writing 0 bytes, succeed and do not change
	 * update time or file offset (standards compliance)
	 */
	if (uio->uio_resid == 0)
		return (0);

d267 42
a309 1

d313 2
a314 4
		xfersize = fs->e2fs_bsize - blkoffset;
		if (uio->uio_resid < xfersize)
			xfersize = uio->uio_resid;
		if (fs->e2fs_bsize > xfersize)
a317 1

d319 1
a319 1
			lbn, blkoffset + xfersize, ap->a_cred, &bp, flags);
d322 1
a322 1
		if (uio->uio_offset + xfersize > ip->i_e2fs_size) {
a323 1
			uvm_vnp_setsize(vp, ip->i_e2fs_size);
d325 1
a325 8
		uvm_vnp_uncache(vp);

		size = fs->e2fs_bsize - bp->b_resid;
		if (size < xfersize)
			xfersize = size;

		error =
			uiomove((char *)bp->b_data + blkoffset, (int)xfersize, uio);
a336 1
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
d343 2
d354 1
a354 1
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC)) {
a355 1
	}
@


1.5.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.5.6.5 2002/03/06 02:17:13 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
d83 1
a83 1
	ufs1_daddr_t lbn, nextlbn;
d185 1
a185 1
	ufs1_daddr_t lbn;
@


1.4
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.3 1997/06/12 21:09:34 downsj Exp $	*/
d259 3
d263 1
d265 3
d269 1
@


1.3
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_readwrite.c,v 1.2 1997/05/30 08:33:59 downsj Exp $	*/
d271 1
a271 1
		else if (xfersize + blkoffset == fs->e2fs_bsize)
d276 1
a276 1
		else
@


1.2
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 2
a2 4
/*	$OpenBSD$	*/
/*	$NetBSD: ufs_readwrite.c,v 1.10 1997/01/30 09:52:26 tls Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d5 1
d38 1
d102 2
a103 2
		    (vp->v_mount->mnt_maxsymlinklen == 0 &&
		     ip->i_e2fs_nblock == 0))
d109 1
a109 1
    if ((u_int64_t)uio->uio_offset >
d112 2
d128 1
a128 1
        if (lblktosize(fs, nextlbn) >= ip->i_e2fs_size)
d132 1
a132 1
			    ip->i_e2fs_size, lbn, size, NOCRED, &bp);
d136 1
a136 1
			    size, &nextlbn, &nextsize, 1, NOCRED, &bp);
d223 1
a223 1
        (u_int64_t)uio->uio_offset + uio->uio_resid >
d232 2
a233 2
	    uio->uio_offset + uio->uio_resid >
	    p->p_rlimit[RLIMIT_FSIZE].rlim_cur) {
d253 2
a254 2
        error = ext2fs_balloc(ip,
		    lbn, blkoffset + xfersize, ap->a_cred, &bp, flags);
d268 1
a268 1
		    uiomove((char *)bp->b_data + blkoffset, (int)xfersize, uio);
d292 1
a292 1
			    ioflag & IO_SYNC, ap->a_cred, uio->uio_procp);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@

