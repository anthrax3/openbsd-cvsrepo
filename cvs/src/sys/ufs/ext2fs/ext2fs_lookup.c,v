head	1.42;
access;
symbols
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.37.0.2
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.10
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.8
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.10
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.6
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.6
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.41;
commitid	gAjwyca5TfuoJAhn;

1.41
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.40;
commitid	kCz5QgxnxRMKOzNf;

1.40
date	2016.02.16.17.56.12;	author stefan;	state Exp;
branches;
next	1.39;
commitid	6HMhQmvFL5xr8Rk9;

1.39
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.38;
commitid	p4LJxGKbi0BU2cG6;

1.38
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.37;
commitid	C5iGb36LQxjM60Q3;

1.37
date	2014.07.13.16.59.35;	author pelikan;	state Exp;
branches;
next	1.36;
commitid	zGe0z6RRYbZJpA8u;

1.36
date	2014.07.13.15.07.01;	author pelikan;	state Exp;
branches;
next	1.35;
commitid	CWlwOMbeCyL2ekFr;

1.35
date	2014.07.12.18.44.01;	author tedu;	state Exp;
branches;
next	1.34;
commitid	bDGgAR6yEQVcVl5u;

1.34
date	2014.07.12.10.55.33;	author pelikan;	state Exp;
branches;
next	1.33;
commitid	ke7f1cqhQ7pPX3Ue;

1.33
date	2014.07.11.07.59.04;	author pelikan;	state Exp;
branches;
next	1.32;
commitid	yEmnkjDnfpCG9P4r;

1.32
date	2014.07.10.09.24.18;	author pelikan;	state Exp;
branches;
next	1.31;
commitid	qkMPClqJrQ3Iamib;

1.31
date	2014.05.27.14.31.24;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2013.12.12.19.00.09;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2013.08.13.05.52.27;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2010.11.18.21.18.10;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.09.00.38.59;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.17.20.15.25;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.28.20.48.17;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.16.15.37.24;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.03.20.14.01;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.30.13.58.55;	author niallo;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.06.09.23.25;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.12.01.09.45;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.18.01.21.55;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.06.23.02.07.51;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.06.02.26.12;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.25.03.53.35;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.26.23.24.41;	author jasoni;	state Exp;
branches;
next	1.6;

1.6
date	99.01.11.05.12.37;	author millert;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	98.07.28.00.13.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.01.12.00.45.06;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	97.11.06.05.59.15;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	97.06.12.21.09.34;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.6.6.1
date	2001.05.14.22.47.39;	author niklas;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2001.07.04.11.00.44;	author niklas;	state Exp;
branches;
next	1.6.6.3;

1.6.6.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.6.6.4;

1.6.6.4
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.6.6.5;

1.6.6.5
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.6.6.6;

1.6.6.6
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.6.6.7;

1.6.6.7
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.6.6.8;

1.6.6.8
date	2004.02.19.11.01.36;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.32.49;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2003.05.19.22.38.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/*	$OpenBSD: ext2fs_lookup.c,v 1.41 2016/03/14 23:08:06 krw Exp $	*/
/*	$NetBSD: ext2fs_lookup.c,v 1.16 2000/08/03 20:29:26 thorpej Exp $	*/

/*
 * Modified for NetBSD 1.2E
 * May 1997, Manuel Bouyer
 * Laboratoire d'informatique de Paris VI
 */
/*
 *  modified for Lites 1.1
 *
 *  Aug 1995, Godmar Back (gback@@cs.utah.edu)
 *  University of Utah, Department of Computer Science
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_lookup.c	8.6 (Berkeley) 4/1/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/buf.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/dirent.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ext2fs/ext2fs_extern.h>
#include <ufs/ext2fs/ext2fs_dir.h>
#include <ufs/ext2fs/ext2fs.h>

extern	int dirchk;

static void	ext2fs_dirconv2ffs(struct ext2fs_direct *e2dir,
    struct dirent *ffsdir);
static int	ext2fs_dirbadentry(struct vnode *dp, struct ext2fs_direct *de,
    int entryoffsetinblock);
static int	ext2fs_search_dirblock(struct inode *, void *, int *,
    struct componentname *, int *, doff_t *, doff_t *,
    struct ext2fs_searchslot *);

/*
 * the problem that is tackled below is the fact that FFS
 * includes the terminating zero on disk while EXT2FS doesn't
 * this implies that we need to introduce some padding.
 * For instance, a filename "sbin" has normally a reclen 12
 * in EXT2, but 16 in FFS.
 * This reminds me of that Pepsi commercial: 'Kid saved a lousy nine cents...'
 * If it wasn't for that, the complete ufs code for directories would
 * have worked w/o changes (except for the difference in DIRBLKSIZ)
 */
static void
ext2fs_dirconv2ffs(struct ext2fs_direct	*e2dir, struct dirent *ffsdir)
{
	memset(ffsdir, 0, sizeof(struct dirent));
	ffsdir->d_fileno = letoh32(e2dir->e2d_ino);
	ffsdir->d_namlen = e2dir->e2d_namlen;

	ffsdir->d_type = DT_UNKNOWN;		/* don't know more here */
#ifdef DIAGNOSTIC
	/*
	 * XXX Rigth now this can't happen, but if one day
	 * MAXNAMLEN != E2FS_MAXNAMLEN we should handle this more gracefully !
	 */
	/* XXX: e2d_namlen is to small for such comparison
	if (e2dir->e2d_namlen > MAXNAMLEN)
		panic("ext2fs: e2dir->e2d_namlen");
	*/
#endif
	strncpy(ffsdir->d_name, e2dir->e2d_name, ffsdir->d_namlen);

	/* Godmar thinks: since e2dir->e2d_reclen can be big and means
	   nothing anyway, we compute our own reclen according to what
	   we think is right
	 */
	ffsdir->d_reclen = DIRENT_SIZE(ffsdir);
}

/*
 * Vnode op for reading directories.
 *
 * Convert the on-disk entries to <sys/dirent.h> entries.
 * the problem is that the conversion will blow up some entries by four bytes,
 * so it can't be done in place. This is too bad. Right now the conversion is
 * done entry by entry, the converted entry is sent via uiomove.
 *
 * XXX allocate a buffer, convert as many entries as possible, then send
 * the whole buffer to uiomove
 */
int
ext2fs_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	struct uio *uio = ap->a_uio;
	int error;
	size_t e2fs_count, readcnt, entries;
	struct vnode *vp = ap->a_vp;
	struct m_ext2fs *fs = VTOI(vp)->i_e2fs;

	struct ext2fs_direct *dp;
	struct dirent dstd;
	struct uio auio;
	struct iovec aiov;
	caddr_t dirbuf;
	off_t off = uio->uio_offset;
	int e2d_reclen;

	if (vp->v_type != VDIR)
		return (ENOTDIR);

	e2fs_count = uio->uio_resid;
	entries = (uio->uio_offset + e2fs_count) & (fs->e2fs_bsize - 1);

	/* Make sure we don't return partial entries. */
	if (e2fs_count <= entries)
		return (EINVAL);

	e2fs_count -= entries;
	auio = *uio;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_segflg = UIO_SYSSPACE;
	aiov.iov_len = e2fs_count;
	auio.uio_resid = e2fs_count;
	dirbuf = malloc(e2fs_count, M_TEMP, M_WAITOK | M_ZERO);
	aiov.iov_base = dirbuf;

	error = VOP_READ(ap->a_vp, &auio, 0, ap->a_cred);
	if (error == 0) {
		readcnt = e2fs_count - auio.uio_resid;
		dp = (struct ext2fs_direct *) dirbuf;
		while ((char *) dp < (char *) dirbuf + readcnt) {
			e2d_reclen = letoh16(dp->e2d_reclen);
			if (e2d_reclen == 0) {
				error = EIO;
				break;
			}
			ext2fs_dirconv2ffs(dp, &dstd);
			if(dstd.d_reclen > uio->uio_resid) {
				break;
			}
			dstd.d_off = off + e2d_reclen;
			if ((error = uiomove((caddr_t)&dstd, dstd.d_reclen, uio)) != 0) {
				break;
			}
			off = off + e2d_reclen;
			/* advance dp */
			dp = (struct ext2fs_direct *) ((char *)dp + e2d_reclen);
		}
		/* we need to correct uio_offset */
		uio->uio_offset = off;
	}
	free(dirbuf, M_TEMP, e2fs_count);
	*ap->a_eofflag = ext2fs_size(VTOI(ap->a_vp)) <= uio->uio_offset;
	return (error);
}

/*
 * Convert a component of a pathname into a pointer to a locked inode.
 * This is a very central and rather complicated routine.
 * If the file system is not maintained in a strict tree hierarchy,
 * this can result in a deadlock situation (see comments in code below).
 *
 * The cnp->cn_nameiop argument is LOOKUP, CREATE, RENAME, or DELETE depending
 * on whether the name is to be looked up, created, renamed, or deleted.
 * When CREATE, RENAME, or DELETE is specified, information usable in
 * creating, renaming, or deleting a directory entry may be calculated.
 * If flag has LOCKPARENT or'ed into it and the target of the pathname
 * exists, lookup returns both the target and its parent directory locked.
 * When creating or renaming and LOCKPARENT is specified, the target may
 * not be ".".  When deleting and LOCKPARENT is specified, the target may
 * be "."., but the caller must check to ensure it does an vrele and vput
 * instead of two vputs.
 *
 * Overall outline of ext2fs_lookup:
 *
 *	check accessibility of directory
 *	look for name in cache, if found, then if at end of path
 *	  and deleting or creating, drop it, else return name
 *	search for name in directory, to found or notfound
 * notfound:
 *	if creating, return locked directory, leaving info on available slots
 *	else return error
 * found:
 *	if at end of path and deleting, return information to allow delete
 *	if at end of path and rewriting (RENAME and LOCKPARENT), lock target
 *	  inode and return info to allow rewrite
 *	if not at end, add name to cache; if at end and neither creating
 *	  nor deleting, add name to cache
 */
int
ext2fs_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct vnode *vdp;	/* vnode for directory being searched */
	struct inode *dp;	/* inode for directory being searched */
	struct buf *bp;			/* a buffer of directory entries */
	struct ext2fs_direct *ep; /* the current directory entry */
	int entryoffsetinblock;		/* offset of ep in bp's buffer */
	struct ext2fs_searchslot ss;
	int numdirpasses;		/* strategy for directory search */
	doff_t endsearch;		/* offset to end directory search */
	doff_t prevoff;			/* prev entry dp->i_offset */
	struct vnode *pdp;		/* saved dp during symlink work */
	struct vnode *tdp;		/* returned by VFS_VGET */
	doff_t enduseful;		/* pointer past last used dir slot */
	u_long bmask;			/* block offset mask */
	int lockparent;			/* 1 => lockparent flag is set */
	int wantparent;			/* 1 => wantparent or lockparent flag */
	struct vnode **vpp = ap->a_vpp;
	struct componentname *cnp = ap->a_cnp;
	struct ucred *cred = cnp->cn_cred;
	int flags = cnp->cn_flags;
	int nameiop = cnp->cn_nameiop;
	struct proc *p = cnp->cn_proc;
	int dirblksize, entry_found = 0, error;

	ss.slotstatus = FOUND;
	ss.slotoffset = -1;
	ss.slotfreespace = ss.slotsize = ss.slotneeded = 0;

	bp = NULL;
	*vpp = NULL;
	vdp = ap->a_dvp;
	dp = VTOI(vdp);
	dirblksize = dp->i_e2fs->e2fs_bsize;
	lockparent = flags & LOCKPARENT;
	wantparent = flags & (LOCKPARENT|WANTPARENT);

	/*
	 * Check accessiblity of directory.
	 */
	if ((error = VOP_ACCESS(vdp, VEXEC, cred, cnp->cn_proc)) != 0)
		return (error);

	if ((flags & ISLASTCN) && (vdp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

	/*
	 * We now have a segment name to search for, and a directory to search.
	 *
	 * Before tediously performing a linear scan of the directory,
	 * check the name cache to see if the directory/name pair
	 * we are looking for is known already.
	 */
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);

	/*
	 * Suppress search for slots unless creating
	 * file and at end of pathname, in which case
	 * we watch for a place to put the new file in
	 * case it doesn't already exist.
	 */
	if ((nameiop == CREATE || nameiop == RENAME) && (flags & ISLASTCN)) {
		ss.slotstatus = NONE;
		ss.slotneeded = EXT2FS_DIRSIZ(cnp->cn_namelen);
	}

	/*
	 * If there is cached information on a previous search of
	 * this directory, pick up where we last left off.
	 * We cache only lookups as these are the most common
	 * and have the greatest payoff. Caching CREATE has little
	 * benefit as it usually must search the entire directory
	 * to determine that the entry does not exist. Caching the
	 * location of the last DELETE or RENAME has not reduced
	 * profiling time and hence has been removed in the interest
	 * of simplicity.
	 */
	bmask = VFSTOUFS(vdp->v_mount)->um_mountp->mnt_stat.f_iosize - 1;
	if (nameiop != LOOKUP || dp->i_diroff == 0 ||
	    dp->i_diroff > ext2fs_size(dp)) {
		entryoffsetinblock = 0;
		dp->i_offset = 0;
		numdirpasses = 1;
	} else {
		dp->i_offset = dp->i_diroff;
		if ((entryoffsetinblock = dp->i_offset & bmask) &&
		    (error = ext2fs_bufatoff(dp, (off_t)dp->i_offset,
		    NULL, &bp)))
			return (error);
		numdirpasses = 2;
	}
	prevoff = dp->i_offset;
	endsearch = roundup(ext2fs_size(dp), dirblksize);
	enduseful = 0;

searchloop:
	while (dp->i_offset < endsearch) {
		/*
		 * If necessary, get the next directory block.
		 */
		if (bp != NULL)
			brelse(bp);

		error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, NULL, &bp);
		if (error != 0)
			return (error);
		entryoffsetinblock = 0;

		/*
		 * If still looking for a slot, and at a dirblksize
		 * boundary, have to start looking for free space again.
		 */
		if (ss.slotstatus == NONE) {
			ss.slotoffset = -1;
			ss.slotfreespace = 0;
		}

		error = ext2fs_search_dirblock(dp, bp->b_data, &entry_found,
		    cnp, &entryoffsetinblock, &prevoff, &enduseful, &ss);
		if (error) {
			brelse(bp);
			return (error);
		}
		if (entry_found) {
			ep = (struct ext2fs_direct *)
			    ((char *)bp->b_data + (entryoffsetinblock & bmask));
/* foundentry: */
			dp->i_ino = letoh32(ep->e2d_ino);
			dp->i_reclen = letoh16(ep->e2d_reclen);
			goto found;
		}
	}
/* notfound: */
	/*
	 * If we started in the middle of the directory and failed
	 * to find our target, we must check the beginning as well.
	 */
	if (numdirpasses == 2) {
		numdirpasses--;
		dp->i_offset = 0;
		endsearch = dp->i_diroff;
		goto searchloop;
	}
	if (bp != NULL)
		brelse(bp);
	/*
	 * If creating, and at end of pathname and current
	 * directory has not been removed, then can consider
	 * allowing file to be created.
	 */
	if ((nameiop == CREATE || nameiop == RENAME) &&
		(flags & ISLASTCN) && dp->i_e2fs_nlink != 0) {
		/*
		 * Creation of files on a read-only mounted file system
		 * is pointless, so don't proceed any further.
		 */
		if (vdp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		/*
		 * Access for write is interpreted as allowing
		 * creation of files in the directory.
		 */
		if ((error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc)) != 0)
			return (error);
		/*
		 * Return an indication of where the new directory
		 * entry should be put.  If we didn't find a slot,
		 * then set dp->i_count to 0 indicating
		 * that the new slot belongs at the end of the
		 * directory. If we found a slot, then the new entry
		 * can be put in the range from dp->i_offset to
		 * dp->i_offset + dp->i_count.
		 */
		if (ss.slotstatus == NONE) {
			dp->i_offset = roundup(ext2fs_size(dp), dirblksize);
			dp->i_count = 0;
			enduseful = dp->i_offset;
		} else {
			dp->i_offset = ss.slotoffset;
			dp->i_count = ss.slotsize;
			if (enduseful < ss.slotoffset + ss.slotsize)
				enduseful = ss.slotoffset + ss.slotsize;
		}
		dp->i_endoff = roundup(enduseful, dirblksize);
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
		/*
		 * We return with the directory locked, so that
		 * the parameters we set up above will still be
		 * valid if we actually decide to do a direnter().
		 * We return ni_vp == NULL to indicate that the entry
		 * does not currently exist; we leave a pointer to
		 * the (locked) directory inode in ndp->ni_dvp.
		 * The pathname buffer is saved so that the name
		 * can be obtained later.
		 *
		 * NB - if the directory is unlocked, then this
		 * information cannot be used.
		 */
		cnp->cn_flags |= SAVENAME;
		if (!lockparent) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (EJUSTRETURN);
	}
	/*
	 * Insert name into cache (as non-existent) if appropriate.
	 */
	if ((cnp->cn_flags & MAKEENTRY) && nameiop != CREATE)
		cache_enter(vdp, *vpp, cnp);
	return (ENOENT);

found:
	/*
	 * Check that directory length properly reflects presence
	 * of this entry.
	 */
	if (entryoffsetinblock + EXT2FS_DIRSIZ(ep->e2d_namlen)
	    > ext2fs_size(dp)) {
		ufs_dirbad(dp, dp->i_offset, "i_size too small");
		error = ext2fs_setsize(dp,
			entryoffsetinblock + EXT2FS_DIRSIZ(ep->e2d_namlen));
		if (error) {
			brelse(bp);
			return(error);
		}
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	brelse(bp);

	/*
	 * Found component in pathname.
	 * If the final component of path name, save information
	 * in the cache as to where the entry was found.
	 */
	if ((flags & ISLASTCN) && nameiop == LOOKUP)
		dp->i_diroff = dp->i_offset &~ (dirblksize - 1);

	/*
	 * If deleting, and at end of pathname, return
	 * parameters which can be used to remove file.
	 * If the wantparent flag isn't set, we return only
	 * the directory (in ndp->ni_dvp), otherwise we go
	 * on and lock the inode, being careful with ".".
	 */
	if (nameiop == DELETE && (flags & ISLASTCN)) {
		/*
		 * Write access to directory required to delete files.
		 */
		if ((error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc)) != 0)
			return (error);
		/*
		 * Return pointer to current entry in dp->i_offset,
		 * and distance past previous entry (if there
		 * is a previous entry in this block) in dp->i_count.
		 * Save directory inode pointer in ndp->ni_dvp for dirremove().
		 */
		if ((dp->i_offset & (dirblksize - 1)) == 0)
			dp->i_count = 0;
		else
			dp->i_count = dp->i_offset - prevoff;
		if (dp->i_number == dp->i_ino) {
			vref(vdp);
			*vpp = vdp;
			return (0);
		}
		if ((error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp)) != 0)
			return (error);
		/*
		 * If directory is "sticky", then user must own
		 * the directory, or the file in it, else she
		 * may not delete it (unless she's root). This
		 * implements append-only directories.
		 */
		if ((dp->i_e2fs_mode & ISVTX) &&
			cred->cr_uid != 0 &&
			cred->cr_uid != dp->i_e2fs_uid &&
			VTOI(tdp)->i_e2fs_uid != cred->cr_uid) {
			vput(tdp);
			return (EPERM);
		}
		*vpp = tdp;
		if (!lockparent) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (0);
	}

	/*
	 * If rewriting (RENAME), return the inode and the
	 * information required to rewrite the present directory
	 * Must get inode of directory entry to verify it's a
	 * regular file, or empty directory.
	 */
	if (nameiop == RENAME && wantparent && (flags & ISLASTCN)) {
		if ((error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc)) != 0)
			return (error);
		/*
		 * Careful about locking second inode.
		 * This can only occur if the target is ".".
		 */
		if (dp->i_number == dp->i_ino)
			return (EISDIR);
		if ((error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp)) != 0)
			return (error);
		*vpp = tdp;
		cnp->cn_flags |= SAVENAME;
		if (!lockparent) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (0);
	}

	/*
	 * Step through the translation in the name.  We do not `vput' the
	 * directory because we may need it again if a symbolic link
	 * is relative to the current directory.  Instead we save it
	 * unlocked as "pdp".  We must get the target inode before unlocking
	 * the directory to insure that the inode will not be removed
	 * before we get it.  We prevent deadlock by always fetching
	 * inodes from the root, moving down the directory tree. Thus
	 * when following backward pointers ".." we must unlock the
	 * parent directory before getting the requested directory.
	 * There is a potential race condition here if both the current
	 * and parent directories are removed before the VFS_VGET for the
	 * inode associated with ".." returns.  We hope that this occurs
	 * infrequently since we cannot avoid this race condition without
	 * implementing a sophisticated deadlock detection algorithm.
	 * Note also that this simple deadlock detection scheme will not
	 * work if the file system has any hard links other than ".."
	 * that point backwards in the directory structure.
	 */
	pdp = vdp;
	if (flags & ISDOTDOT) {
		VOP_UNLOCK(pdp, p);	/* race to get the inode */
		cnp->cn_flags |= PDIRUNLOCK;
		if ((error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp)) != 0) {
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p)) != 0) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}
		*vpp = tdp;
	} else if (dp->i_number == dp->i_ino) {
		vref(vdp);	/* we want ourself, ie "." */
		*vpp = vdp;
	} else {
		if ((error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp)) != 0)
			return (error);
		if (!lockparent || !(flags & ISLASTCN)) {
			VOP_UNLOCK(pdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		*vpp = tdp;
	}

	/*
	 * Insert name into cache if appropriate.
	 */
	if (cnp->cn_flags & MAKEENTRY)
		cache_enter(vdp, *vpp, cnp);
	return (0);
}

int
ext2fs_search_dirblock(struct inode *ip, void *data, int *foundp,
    struct componentname *cnp, int *entryoffsetinblockp,
    doff_t *prevoffp, doff_t *endusefulp, struct ext2fs_searchslot *ssp)
{
	struct ext2fs_direct *ep, *lim;
	struct vnode *vdp;
	int offset = *entryoffsetinblockp;
	int dirblksize = ip->i_e2fs->e2fs_bsize;
	size_t namlen;

	vdp = ITOV(ip);

	lim = (struct ext2fs_direct *)
	    ((char *)data + dirblksize - EXT2FS_DIRSIZ(0));
	ep = (struct ext2fs_direct *) ((char *)data + offset);

	while (ep < lim) {
		/*
		 * Full validation checks are slow, so we only check
		 * enough to insure forward progress through the
		 * directory. Complete checks can be run by patching
		 * "dirchk" to be true.
		 */
		if (ep->e2d_reclen == 0 ||
		    (dirchk && ext2fs_dirbadentry(vdp, ep, offset))) {
			int i;
			ufs_dirbad(ip, ip->i_offset, "mangled entry");
			i = dirblksize - (offset & (dirblksize - 1));
			ip->i_offset += i;
			offset += i;
			continue;
		}

		/*
		 * If an appropriate sized slot has not yet been found,
		 * check to see if one is available. Also accumulate space
		 * in the current block so that we can determine if
		 * compaction is viable.
		 */
		if (ssp->slotstatus != FOUND) {
			int size = letoh16(ep->e2d_reclen);

			if (ep->e2d_ino != 0)
				size -= EXT2FS_DIRSIZ(ep->e2d_namlen);
			if (size > 0) {
				if (size >= ssp->slotneeded) {
					ssp->slotstatus = FOUND;
					ssp->slotoffset = ip->i_offset;
					ssp->slotsize = letoh16(ep->e2d_reclen);
				} else if (ssp->slotstatus == NONE) {
					ssp->slotfreespace += size;
					if (ssp->slotoffset == -1)
						ssp->slotoffset = ip->i_offset;
					if (ssp->slotfreespace >= ssp->slotneeded) {
						ssp->slotstatus = COMPACT;
						ssp->slotsize = ip->i_offset +
							  letoh16(ep->e2d_reclen) - ssp->slotoffset;
					}
				}
			}
		}

		/*
		 * Check for a name match.
		 */
		if (ep->e2d_ino) {
			namlen = ep->e2d_namlen;
			if (namlen == cnp->cn_namelen &&
			    !memcmp(cnp->cn_nameptr, ep->e2d_name, namlen)) {
				/*
				 * Save directory entry's inode number and
				 * reclen in ndp->ni_ufs area, and release
				 * directory buffer.
				 */
				*foundp = 1;
				return (0);
			}
		}
		*prevoffp = ip->i_offset;
		ip->i_offset += letoh16(ep->e2d_reclen);
		offset += letoh16(ep->e2d_reclen);
		*entryoffsetinblockp = offset;
		if (ep->e2d_ino)
			*endusefulp = ip->i_offset;

		/*
		 * Get pointer to the next entry.
		 */
		ep = (struct ext2fs_direct *) ((char *)data + offset);
	}

	return (0);
}

/*
 * Do consistency checking on a directory entry:
 *	record length must be multiple of 4
 *	entry must fit in rest of its dirblksize block
 *	record must be large enough to contain entry
 *	name is not longer than MAXNAMLEN
 *	name must be as long as advertised, and null terminated
 */
/*
 *	changed so that it confirms to ext2fs_check_dir_entry
 */
static int
ext2fs_dirbadentry(struct vnode *dp, struct ext2fs_direct *de,
    int entryoffsetinblock)
{
	int dirblksize = VTOI(dp)->i_e2fs->e2fs_bsize;
	char *error_msg = NULL;
	int reclen = letoh16(de->e2d_reclen);
	int namlen = de->e2d_namlen;

	if (reclen < EXT2FS_DIRSIZ(1)) /* e2d_namlen = 1 */
		error_msg = "rec_len is smaller than minimal";
	else if (reclen % 4 != 0)
		error_msg = "rec_len % 4 != 0";
	else if (reclen < EXT2FS_DIRSIZ(namlen))
		error_msg = "reclen is too small for name_len";
	else if (entryoffsetinblock + reclen > dirblksize)
		error_msg = "directory entry across blocks";
	else if (letoh32(de->e2d_ino) > VTOI(dp)->i_e2fs->e2fs.e2fs_icount)
		error_msg = "inode out of bounds";

	if (error_msg != NULL) {
		printf("bad directory entry: %s\n"
		    "offset=%d, inode=%u, rec_len=%d, name_len=%d \n",
		    error_msg, entryoffsetinblock, letoh32(de->e2d_ino),
		    reclen, namlen);
		panic(__func__);
	}
	return (0);
}

/*
 * Write a directory entry after a call to namei, using the parameters
 * that it left in nameidata.  The argument ip is the inode which the new
 * directory entry will refer to.  Dvp is a pointer to the directory to
 * be written, which was left locked by namei. Remaining parameters
 * (dp->i_offset, dp->i_count) indicate how the space for the new
 * entry is to be obtained.
 */
int
ext2fs_direnter(struct inode *ip, struct vnode *dvp,
    struct componentname *cnp)
{
	struct ext2fs_direct *ep, *nep;
	struct inode *dp;
	struct buf *bp;
	struct ext2fs_direct newdir;
	struct iovec aiov;
	struct uio auio;
	u_int dsize;
	int error, loc, newentrysize, spacefree;
	char *dirbuf;
	int dirblksize = ip->i_e2fs->e2fs_bsize;


#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & SAVENAME) == 0)
		panic("direnter: missing name");
#endif
	dp = VTOI(dvp);
	newdir.e2d_ino = htole32(ip->i_number);
	newdir.e2d_namlen = cnp->cn_namelen;
	if (ip->i_e2fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    (ip->i_e2fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_FTYPE)) {
		newdir.e2d_type = inot2ext2dt(IFTODT(ip->i_e2fs_mode));
	} else {
		newdir.e2d_type = 0;
	};
	memcpy(newdir.e2d_name, cnp->cn_nameptr, (unsigned)cnp->cn_namelen + 1);
	newentrysize = EXT2FS_DIRSIZ(cnp->cn_namelen);
	if (dp->i_count == 0) {
		/*
		 * If dp->i_count is 0, then namei could find no
		 * space in the directory. Here, dp->i_offset will
		 * be on a directory block boundary and we will write the
		 * new entry into a fresh block.
		 */
		if (dp->i_offset & (dirblksize - 1))
			panic("ext2fs_direnter: newblk");
		auio.uio_offset = dp->i_offset;
		newdir.e2d_reclen = htole16(dirblksize);
		auio.uio_resid = newentrysize;
		aiov.iov_len = newentrysize;
		aiov.iov_base = (caddr_t)&newdir;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_rw = UIO_WRITE;
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_procp = NULL;
		error = VOP_WRITE(dvp, &auio, IO_SYNC, cnp->cn_cred);
		if (dirblksize >
			VFSTOUFS(dvp->v_mount)->um_mountp->mnt_stat.f_bsize)
			/* XXX should grow with balloc() */
			panic("ext2fs_direnter: frag size");
		else if (!error) {
			error = ext2fs_setsize(dp,
				roundup(ext2fs_size(dp), dirblksize));
			if (error)
				return (error);
			dp->i_flag |= IN_CHANGE;
		}
		return (error);
	}

	/*
	 * If dp->i_count is non-zero, then namei found space
	 * for the new entry in the range dp->i_offset to
	 * dp->i_offset + dp->i_count in the directory.
	 * To use this space, we may have to compact the entries located
	 * there, by copying them together towards the beginning of the
	 * block, leaving the free space in one usable chunk at the end.
	 */

	/*
	 * Get the block containing the space for the new directory entry.
	 */
	if ((error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, &dirbuf, &bp))
	    != 0)
		return (error);
	/*
	 * Find space for the new entry. In the simple case, the entry at
	 * offset base will have the space. If it does not, then namei
	 * arranged that compacting the region dp->i_offset to
	 * dp->i_offset + dp->i_count would yield the
	 * space.
	 */
	ep = (struct ext2fs_direct *)dirbuf;
	dsize = EXT2FS_DIRSIZ(ep->e2d_namlen);
	spacefree = letoh16(ep->e2d_reclen) - dsize;
	for (loc = letoh16(ep->e2d_reclen); loc < dp->i_count; ) {
		nep = (struct ext2fs_direct *)(dirbuf + loc);
		if (ep->e2d_ino) {
			/* trim the existing slot */
			ep->e2d_reclen = htole16(dsize);
			ep = (struct ext2fs_direct *)((char *)ep + dsize);
		} else {
			/* overwrite; nothing there; header is ours */
			spacefree += dsize;
		}
		dsize = EXT2FS_DIRSIZ(nep->e2d_namlen);
		spacefree += letoh16(nep->e2d_reclen) - dsize;
		loc += letoh16(nep->e2d_reclen);
		memcpy(ep, nep, dsize);
	}
	/*
	 * Update the pointer fields in the previous entry (if any),
	 * copy in the new entry, and write out the block.
	 */
	if (ep->e2d_ino == 0) {
#ifdef DIAGNOSTIC
		if (spacefree + dsize < newentrysize)
			panic("ext2fs_direnter: compact1");
#endif
		newdir.e2d_reclen = htole16(spacefree + dsize);
	} else {
#ifdef DIAGNOSTIC
		if (spacefree < newentrysize) {
			printf("ext2fs_direnter: compact2 %u %u",
			    (u_int)spacefree, (u_int)newentrysize);
			panic("ext2fs_direnter: compact2");
		}
#endif
		newdir.e2d_reclen = htole16(spacefree);
		ep->e2d_reclen = htole16(dsize);
		ep = (struct ext2fs_direct *)((char *)ep + dsize);
	}
	memcpy(ep, &newdir, newentrysize);
	error = VOP_BWRITE(bp);
	dp->i_flag |= IN_CHANGE | IN_UPDATE;
	if (!error && dp->i_endoff && dp->i_endoff < ext2fs_size(dp))
		error = ext2fs_truncate(dp, (off_t)dp->i_endoff, IO_SYNC,
		    cnp->cn_cred);
	return (error);
}

/*
 * Remove a directory entry after a call to namei, using
 * the parameters which it left in nameidata. The entry
 * dp->i_offset contains the offset into the directory of the
 * entry to be eliminated.  The dp->i_count field contains the
 * size of the previous record in the directory.  If this
 * is 0, the first entry is being deleted, so we need only
 * zero the inode number to mark the entry as free.  If the
 * entry is not the first in the directory, we must reclaim
 * the space of the now empty record by adding the record size
 * to the size of the previous entry.
 */
int
ext2fs_dirremove(struct vnode *dvp, struct componentname *cnp)
{
	struct inode *dp;
	struct ext2fs_direct *ep;
	struct buf *bp;
	int error;

	dp = VTOI(dvp);
	if (dp->i_count == 0) {
		/*
		 * First entry in block: set d_ino to zero.
		 */
		error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, (char **)&ep,
		    &bp);
		if (error != 0)
			return (error);
		ep->e2d_ino = 0;
		error = VOP_BWRITE(bp);
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
		return (error);
	}
	/*
	 * Collapse new free space into previous entry.
	 */
	error = ext2fs_bufatoff(dp, (off_t)(dp->i_offset - dp->i_count),
	    (char **)&ep, &bp);
	if (error != 0)
		return (error);
	ep->e2d_reclen = htole16(letoh16(ep->e2d_reclen) + dp->i_reclen);
	error = VOP_BWRITE(bp);
	dp->i_flag |= IN_CHANGE | IN_UPDATE;
	return (error);
}

/*
 * Rewrite an existing directory entry to point at the inode
 * supplied.  The parameters describing the directory entry are
 * set up by a call to namei.
 */
int
ext2fs_dirrewrite(struct inode *dp, struct inode *ip,
    struct componentname *cnp)
{
	struct buf *bp;
	struct ext2fs_direct *ep;
	int error;

	error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, (char **)&ep, &bp);
	if (error != 0)
		return (error);
	ep->e2d_ino = htole32(ip->i_number);
	if (ip->i_e2fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    (ip->i_e2fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_FTYPE)) {
		ep->e2d_type = inot2ext2dt(IFTODT(ip->i_e2fs_mode));
	} else {
		ep->e2d_type = 0;
	}
	error = VOP_BWRITE(bp);
	dp->i_flag |= IN_CHANGE | IN_UPDATE;
	return (error);
}

/*
 * Check if a directory is empty or not.
 * Inode supplied must be locked.
 *
 * Using a struct dirtemplate here is not precisely
 * what we want, but better than using a struct ext2fs_direct.
 *
 * NB: does not handle corrupted directories.
 */
int
ext2fs_dirempty(struct inode *ip, ufsino_t parentino, struct ucred *cred)
{
	off_t off;
	struct ext2fs_dirtemplate dbuf;
	struct ext2fs_direct *dp = (struct ext2fs_direct *)&dbuf;
	int error, namlen;
	size_t count;

#define	MINDIRSIZ (sizeof (struct ext2fs_dirtemplate) / 2)

	for (off = 0; off < ext2fs_size(ip); off += letoh16(dp->e2d_reclen)) {
		error = vn_rdwr(UIO_READ, ITOV(ip), (caddr_t)dp, MINDIRSIZ, off,
		   UIO_SYSSPACE, IO_NODELOCKED, cred, &count, curproc);
		/*
		 * Since we read MINDIRSIZ, residual must
		 * be 0 unless we're at end of file.
		 */
		if (error || count != 0)
			return (0);
		/* avoid infinite loops */
		if (dp->e2d_reclen == 0)
			return (0);
		/* skip empty entries */
		if (dp->e2d_ino == 0)
			continue;
		/* accept only "." and ".." */
		namlen = dp->e2d_namlen;
		if (namlen > 2)
			return (0);
		if (dp->e2d_name[0] != '.')
			return (0);
		/*
		 * At this point namlen must be 1 or 2.
		 * 1 implies ".", 2 implies ".." if second
		 * char is also "."
		 */
		if (namlen == 1)
			continue;
		if (dp->e2d_name[1] == '.' && letoh32(dp->e2d_ino) == parentino)
			continue;
		return (0);
	}
	return (1);
}

/*
 * Check if source directory is in the path of the target directory.
 * Target is supplied locked, source is unlocked.
 * The target is always vput before returning.
 */
int
ext2fs_checkpath(struct inode *source, struct inode *target,
   struct ucred *cred)
{
	struct vnode *vp;
	int error, rootino, namlen;
	struct ext2fs_dirtemplate dirbuf;
	u_int32_t ino;

	vp = ITOV(target);
	if (target->i_number == source->i_number) {
		error = EEXIST;
		goto out;
	}
	rootino = ROOTINO;
	error = 0;
	if (target->i_number == rootino)
		goto out;

	for (;;) {
		if (vp->v_type != VDIR) {
			error = ENOTDIR;
			break;
		}
		error = vn_rdwr(UIO_READ, vp, (caddr_t)&dirbuf,
			sizeof (struct ext2fs_dirtemplate), (off_t)0,
			UIO_SYSSPACE, IO_NODELOCKED, cred, NULL,
			curproc);
		if (error != 0)
			break;
		namlen = dirbuf.dotdot_namlen;
		if (namlen != 2 ||
			dirbuf.dotdot_name[0] != '.' ||
			dirbuf.dotdot_name[1] != '.') {
			error = ENOTDIR;
			break;
		}
		ino = letoh32(dirbuf.dotdot_ino);
		if (ino == source->i_number) {
			error = EINVAL;
			break;
		}
		if (ino == rootino)
			break;
		vput(vp);
		error = VFS_VGET(vp->v_mount, ino, &vp);
		if (error != 0) {
			vp = NULL;
			break;
		}
	}

out:
	if (error == ENOTDIR) {
		printf("checkpath: .. not a directory\n");
		panic("checkpath");
	}
	if (vp != NULL)
		vput(vp);
	return (error);
}
@


1.41
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.40 2016/02/16 17:56:12 stefan Exp $	*/
d432 1
a432 1
			VOP_UNLOCK(vdp, 0, p);
d515 1
a515 1
			VOP_UNLOCK(vdp, 0, p);
d541 1
a541 1
			VOP_UNLOCK(vdp, 0, p);
d568 1
a568 1
		VOP_UNLOCK(pdp, 0, p);	/* race to get the inode */
d590 1
a590 1
			VOP_UNLOCK(pdp, 0, p);
@


1.40
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.39 2015/03/14 03:38:52 jsg Exp $	*/
d797 1
a797 1
		auio.uio_procp = (struct proc *)0;
@


1.39
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.38 2015/02/10 21:56:10 miod Exp $	*/
d180 1
a180 1
			if ((error = uiomovei((caddr_t)&dstd, dstd.d_reclen, uio)) != 0) {
@


1.38
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.37 2014/07/13 16:59:35 pelikan Exp $	*/
a54 1
#include <sys/file.h>
@


1.37
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

Some KNF while there.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.36 2014/07/13 15:07:01 pelikan Exp $	*/
d181 1
a181 1
			if ((error = uiomove((caddr_t)&dstd, dstd.d_reclen, uio)) != 0) {
@


1.36
log
@fill in proper sizes in free(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.35 2014/07/12 18:44:01 tedu Exp $	*/
d94 1
a94 1
	ffsdir->d_fileno = fs2h32(e2dir->e2d_ino);
d171 1
a171 1
			e2d_reclen = fs2h16(dp->e2d_reclen);
d360 2
a361 2
			dp->i_ino = fs2h32(ep->e2d_ino);
			dp->i_reclen = fs2h16(ep->e2d_reclen);
d646 1
a646 1
			int size = fs2h16(ep->e2d_reclen);
d654 1
a654 1
					ssp->slotsize = fs2h16(ep->e2d_reclen);
d662 1
a662 1
							  fs2h16(ep->e2d_reclen) - ssp->slotoffset;
d685 2
a686 2
		ip->i_offset += fs2h16(ep->e2d_reclen);
		offset += fs2h16(ep->e2d_reclen);
d715 24
a738 27
	int	dirblksize = VTOI(dp)->i_e2fs->e2fs_bsize;

		char * error_msg = NULL;
		int reclen = fs2h16(de->e2d_reclen);
		int namlen = de->e2d_namlen;

		if (reclen < EXT2FS_DIRSIZ(1)) /* e2d_namlen = 1 */
				error_msg = "rec_len is smaller than minimal";
		else if (reclen % 4 != 0)
				error_msg = "rec_len % 4 != 0";
		else if (reclen < EXT2FS_DIRSIZ(namlen))
				error_msg = "reclen is too small for name_len";
		else if (entryoffsetinblock + reclen > dirblksize)
				error_msg = "directory entry across blocks";
		else if (fs2h32(de->e2d_ino) >
		    VTOI(dp)->i_e2fs->e2fs.e2fs_icount)
				error_msg = "inode out of bounds";

		if (error_msg != NULL) {
			printf( "bad directory entry: %s\n"
			    "offset=%d, inode=%lu, rec_len=%d, name_len=%d \n",
			    error_msg, entryoffsetinblock,
			    (unsigned long) fs2h32(de->e2d_ino),
			    reclen, namlen);
			panic("ext2fs_dirbadentry");
		}
		return error_msg == NULL ? 0 : 1;
d770 1
a770 1
	newdir.e2d_ino = h2fs32(ip->i_number);
d790 1
a790 1
		newdir.e2d_reclen = h2fs16(dirblksize);
d838 2
a839 2
	spacefree = fs2h16(ep->e2d_reclen) - dsize;
	for (loc = fs2h16(ep->e2d_reclen); loc < dp->i_count; ) {
d843 1
a843 1
			ep->e2d_reclen = h2fs16(dsize);
d850 2
a851 2
		spacefree += fs2h16(nep->e2d_reclen) - dsize;
		loc += fs2h16(nep->e2d_reclen);
d863 1
a863 1
		newdir.e2d_reclen = h2fs16(spacefree + dsize);
d872 2
a873 2
		newdir.e2d_reclen = h2fs16(spacefree);
		ep->e2d_reclen = h2fs16(dsize);
d926 1
a926 1
	ep->e2d_reclen = h2fs16(fs2h16(ep->e2d_reclen) + dp->i_reclen);
d948 1
a948 1
	ep->e2d_ino = h2fs32(ip->i_number);
d980 1
a980 1
	for (off = 0; off < ext2fs_size(ip); off += fs2h16(dp->e2d_reclen)) {
d1008 1
a1008 1
		if (dp->e2d_name[1] == '.' && fs2h32(dp->e2d_ino) == parentino)
d1057 1
a1057 1
		ino = fs2h32(dirbuf.dotdot_ino);
@


1.35
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.34 2014/07/12 10:55:33 pelikan Exp $	*/
d191 1
a191 1
	free(dirbuf, M_TEMP, 0);
@


1.34
log
@pull dirblock search code from ext2fs_lookup() like FreeBSD has done

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.33 2014/07/11 07:59:04 pelikan Exp $	*/
d191 1
a191 1
	free(dirbuf, M_TEMP);
@


1.33
log
@separate searchslot variables into a structure like FreeBSD

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.32 2014/07/10 09:24:18 pelikan Exp $	*/
d73 6
a78 4
					  struct dirent *ffsdir);
static int	ext2fs_dirbadentry(struct vnode *dp,
					  struct ext2fs_direct *de,
					  int entryoffsetinblock);
a247 1
	int namlen, error;
d254 1
a254 1
	int	dirblksize = VTOI(ap->a_dvp)->i_e2fs->e2fs_bsize;
d264 1
d333 8
a340 10
		if ((dp->i_offset & bmask) == 0) {
			if (bp != NULL)
				brelse(bp);

			error = ext2fs_bufatoff(dp, (off_t)dp->i_offset,
			    NULL, &bp);
			if (error != 0)
				return (error);
			entryoffsetinblock = 0;
		}
d345 1
a345 2
		if (ss.slotstatus == NONE &&
		    (entryoffsetinblock & (dirblksize - 1)) == 0) {
a348 20
		/*
		 * Get pointer to next entry.
		 * Full validation checks are slow, so we only check
		 * enough to insure forward progress through the
		 * directory. Complete checks can be run by patching
		 * "dirchk" to be true.
		 */
		ep = (struct ext2fs_direct *)
		    ((char *)bp->b_data + entryoffsetinblock);
		if (ep->e2d_reclen == 0 ||
		    (dirchk &&
		    ext2fs_dirbadentry(vdp, ep, entryoffsetinblock))) {
			int i;
			ufs_dirbad(dp, dp->i_offset, "mangled entry");
			i = dirblksize -
			    (entryoffsetinblock & (dirblksize - 1));
			dp->i_offset += i;
			entryoffsetinblock += i;
			continue;
		}
d350 5
a354 27
		/*
		 * If an appropriate sized slot has not yet been found,
		 * check to see if one is available. Also accumulate space
		 * in the current block so that we can determine if
		 * compaction is viable.
		 */
		if (ss.slotstatus != FOUND) {
			int size = fs2h16(ep->e2d_reclen);

			if (ep->e2d_ino != 0)
				size -= EXT2FS_DIRSIZ(ep->e2d_namlen);
			if (size > 0) {
				if (size >= ss.slotneeded) {
					ss.slotstatus = FOUND;
					ss.slotoffset = dp->i_offset;
					ss.slotsize = fs2h16(ep->e2d_reclen);
				} else if (ss.slotstatus == NONE) {
					ss.slotfreespace += size;
					if (ss.slotoffset == -1)
						ss.slotoffset = dp->i_offset;
					if (ss.slotfreespace >= ss.slotneeded) {
						ss.slotstatus = COMPACT;
						ss.slotsize = dp->i_offset +
							  fs2h16(ep->e2d_reclen) - ss.slotoffset;
					}
				}
			}
d356 7
a362 19

		/*
		 * Check for a name match.
		 */
		if (ep->e2d_ino) {
			namlen = ep->e2d_namlen;
			if (namlen == cnp->cn_namelen &&
				!memcmp(cnp->cn_nameptr, ep->e2d_name,
				(unsigned)namlen)) {
				/*
				 * Save directory entry's inode number and
				 * reclen in ndp->ni_ufs area, and release
				 * directory buffer.
				 */
				dp->i_ino = fs2h32(ep->e2d_ino);
				dp->i_reclen = fs2h16(ep->e2d_reclen);
				brelse(bp);
				goto found;
			}
a363 5
		prevoff = dp->i_offset;
		dp->i_offset += fs2h16(ep->e2d_reclen);
		entryoffsetinblock += fs2h16(ep->e2d_reclen);
		if (ep->e2d_ino)
			enduseful = dp->i_offset;
d461 1
d602 95
@


1.32
log
@prepare for upcoming ext4 read support

Parts of the on-disk inode changed their meaning in order to support bigger
sizes.  More flags & prettification.  No functional change.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.31 2014/05/27 14:31:24 krw Exp $	*/
d236 1
a236 5
	enum {NONE, COMPACT, FOUND} slotstatus;
	doff_t slotoffset;		/* offset of area with free space */
	int slotsize;			/* size of area at slotoffset */
	int slotfreespace;		/* amount of space free in slot */
	int slotneeded;			/* size of the entry we're seeking */
d255 4
a259 1
	slotoffset = -1;
d292 3
a294 6
	slotstatus = FOUND;
	slotfreespace = slotsize = slotneeded = 0;
	if ((nameiop == CREATE || nameiop == RENAME) &&
		(flags & ISLASTCN)) {
		slotstatus = NONE;
		slotneeded = EXT2FS_DIRSIZ(cnp->cn_namelen);
d310 1
a310 1
		dp->i_diroff >ext2fs_size(dp)) {
d317 2
a318 2
			(error = ext2fs_bufatoff(dp, (off_t)dp->i_offset,
			    NULL, &bp)))
d345 4
a348 4
		if (slotstatus == NONE &&
			(entryoffsetinblock & (dirblksize - 1)) == 0) {
			slotoffset = -1;
			slotfreespace = 0;
d358 1
a358 1
			((char *)bp->b_data + entryoffsetinblock);
d377 1
a377 1
		if (slotstatus != FOUND) {
d383 12
a394 12
				if (size >= slotneeded) {
					slotstatus = FOUND;
					slotoffset = dp->i_offset;
					slotsize = fs2h16(ep->e2d_reclen);
				} else if (slotstatus == NONE) {
					slotfreespace += size;
					if (slotoffset == -1)
						slotoffset = dp->i_offset;
					if (slotfreespace >= slotneeded) {
						slotstatus = COMPACT;
						slotsize = dp->i_offset +
							  fs2h16(ep->e2d_reclen) - slotoffset;
d450 1
a450 1
					return (EROFS);
d466 1
a466 1
		if (slotstatus == NONE) {
d471 4
a474 4
			dp->i_offset = slotoffset;
			dp->i_count = slotsize;
			if (enduseful < slotoffset + slotsize)
				enduseful = slotoffset + slotsize;
d587 1
a587 2
	if (nameiop == RENAME && wantparent &&
		(flags & ISLASTCN)) {
@


1.31
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.30 2013/12/12 19:00:09 tedu Exp $	*/
d167 2
a168 2
		for (dp = (struct ext2fs_direct *)dirbuf;
			(char *)dp < (char *)dirbuf + readcnt; ) {
d266 1
d338 1
@


1.30
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.29 2013/08/13 05:52:27 guenther Exp $	*/
d4 1
a4 1
/* 
d82 2
a83 2
 * For instance, a filename "sbin" has normally a reclen 12 
 * in EXT2, but 16 in FFS. 
d108 1
a108 1
	/* Godmar thinks: since e2dir->e2d_reclen can be big and means 
d121 1
a121 1
 * done entry by entry, the converted entry is sent via uiomove. 
d167 1
a167 1
		for (dp = (struct ext2fs_direct *)dirbuf; 
d320 1
a320 1
			(error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, 
d337 1
a337 1
			error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, 
d796 1
a796 1
	if ((error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, &dirbuf, &bp)) 
d874 1
a874 1
	 
d880 1
a880 1
		error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, (char **)&ep, 
d947 1
a947 1
		 
@


1.29
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.28 2013/05/30 19:19:09 guenther Exp $	*/
d822 1
a822 1
		memcpy((caddr_t)ep, (caddr_t)nep, dsize);
d846 1
a846 1
	memcpy((caddr_t)ep, (caddr_t)&newdir, (u_int)newentrysize);
@


1.28
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.27 2010/11/18 21:18:10 miod Exp $	*/
a141 2
	u_long *cookies = NULL;
	int nc = 0, ncookies = 0;
a161 5
	if (ap->a_ncookies) {
		nc = ncookies = e2fs_count / 16;
		cookies = malloc(sizeof(*cookies) * ncookies, M_TEMP, M_WAITOK);
		*ap->a_cookies = cookies;
	}
d178 1
a182 6
			if (cookies != NULL) {
				*cookies++ = off;
				if (--ncookies <= 0){
					break;  /* out of cookies */
				}
			}
a190 8
	if (ap->a_ncookies) {
		if (error) {
			free(*ap->a_cookies, M_TEMP);
			*ap->a_ncookies = 0;
			*ap->a_cookies = NULL;
		} else
			*ap->a_ncookies = nc - ncookies;
	}
@


1.27
log
@Make sure readdir cookies are actually allocated with the correct size
(in case eventually we change their type from u_long to something else),
and do not truncate them to 32 bits in the ntfs code.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.26 2010/09/23 18:49:39 oga Exp $	*/
d960 1
a960 1
ext2fs_dirempty(struct inode *ip, ino_t parentino, struct ucred *cred)
@


1.26
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.25 2009/07/09 22:29:56 thib Exp $	*/
d166 1
a166 1
		cookies = malloc(sizeof (off_t) * ncookies, M_TEMP, M_WAITOK);
@


1.25
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.23 2007/06/17 20:15:25 jasper Exp $	*/
d972 1
a972 1
		   UIO_SYSSPACE, IO_NODELOCKED, cred, &count, (struct proc *)0);
d1036 2
a1037 2
			UIO_SYSSPACE, IO_NODELOCKED, cred, (size_t *)0,
			(struct proc *)0);
@


1.24
log
@MALLOC+memset(,0,) -> malloc+M_ZERO. Don't forget FREE->free this time.
@
text
@d576 1
a576 1
			VREF(vdp);
d667 1
a667 1
		VREF(vdp);	/* we want ourself, ie "." */
@


1.23
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.22 2007/06/01 23:47:57 deraadt Exp $	*/
d163 1
a163 1
	MALLOC(dirbuf, caddr_t, e2fs_count, M_TEMP, M_WAITOK);
a168 1
	memset(dirbuf, 0, e2fs_count);
d201 1
a201 1
	FREE(dirbuf, M_TEMP);
@


1.22
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.21 2005/12/28 20:48:17 pedro Exp $	*/
d89 1
a89 3
ext2fs_dirconv2ffs( e2dir, ffsdir)
	struct ext2fs_direct	*e2dir;
	struct dirent 		*ffsdir;
d127 1
a127 2
ext2fs_readdir(v)
	void *v;
d249 1
a249 2
ext2fs_lookup(v)
	void *v;
d700 2
a701 4
ext2fs_dirbadentry(dp, de, entryoffsetinblock)
	struct vnode *dp;
	struct ext2fs_direct *de;
	int entryoffsetinblock;
d741 2
a742 4
ext2fs_direnter(ip, dvp, cnp)
	struct inode *ip;
	struct vnode *dvp;
	struct componentname *cnp;
d889 1
a889 3
ext2fs_dirremove(dvp, cnp)
	struct vnode *dvp;
	struct componentname *cnp;
d929 2
a930 3
ext2fs_dirrewrite(dp, ip, cnp)
	struct inode *dp, *ip;
	struct componentname *cnp;
d961 1
a961 4
ext2fs_dirempty(ip, parentino, cred)
	struct inode *ip;
	ino_t parentino;
	struct ucred *cred;
d1012 2
a1013 3
ext2fs_checkpath(source, target, cred)
	struct inode *source, *target;
	struct ucred *cred;
@


1.21
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.20 2005/12/16 15:37:24 pedro Exp $	*/
d132 1
a132 8
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int **a_eofflag;
		off_t **a_cookies;
		int ncookies;
	} */ *ap = v;
d255 1
a255 5
	struct vop_lookup_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap = v;
@


1.20
log
@Fix unsigned < 0 check in ext2fs_readdir(), okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.19 2005/07/03 20:14:01 drahn Exp $	*/
d784 1
a784 1
		newdir.e2d_type = inot2ext2dt(IFTODT(ip->i_ffs_mode));
d964 1
a964 1
		ep->e2d_type = inot2ext2dt(IFTODT(ip->i_ffs_mode));
@


1.19
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.18 2005/04/30 13:58:55 niallo Exp $	*/
d142 1
a142 1
	size_t e2fs_count, readcnt;
d160 2
d163 1
a163 2
	e2fs_count -= (uio->uio_offset + e2fs_count) & (fs->e2fs_bsize -1);
	if (e2fs_count <= 0)
d166 1
@


1.18
log
@Add support for large files (> 4GB).

Automatically converts old filesystems to use this if they are already at
revision 1 (like Linux). Revision 0 filesystems don't get converted (unlike
Linux).

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.17 2003/12/06 09:23:25 grange Exp $	*/
a60 1
#include <ufs/ufs/extattr.h>
@


1.17
log
@u_int8_t variable can't be > 255; pointed out by Mr. GCC3.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.16 2003/06/02 23:28:22 millert Exp $	*/
d212 1
a212 1
	*ap->a_eofflag = VTOI(ap->a_vp)->i_e2fs_size <= uio->uio_offset;
d348 1
a348 1
		dp->i_diroff > dp->i_e2fs_size) {
d361 1
a361 1
	endsearch = roundup(dp->i_e2fs_size, dirblksize);
d504 1
a504 1
			dp->i_offset = roundup(dp->i_e2fs_size, dirblksize);
d548 1
a548 1
	    > dp->i_e2fs_size) {
d550 6
a555 2
		dp->i_e2fs_size = entryoffsetinblock +
			EXT2FS_DIRSIZ(ep->e2d_namlen);
d814 4
a817 1
			dp->i_e2fs_size = roundup(dp->i_e2fs_size, dirblksize);
d888 1
a888 1
	if (!error && dp->i_endoff && dp->i_endoff < dp->i_e2fs_size)
d995 1
a995 1
	for (off = 0; off < ip->i_e2fs_size; off += fs2h16(dp->e2d_reclen)) {
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.15 2003/01/31 17:37:50 art Exp $	*/
d104 1
d107 1
@


1.15
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.14 2002/10/12 01:09:45 krw Exp $	*/
d32 1
a32 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.13 2002/03/14 01:27:14 millert Exp $	*/
d320 2
a321 44
	if ((error = cache_lookup(vdp, vpp, cnp)) != 0) {
		int vpid;	/* capability number of vnode */

		if (error == ENOENT)
			return (error);
		/*
		 * Get the next vnode in the path.
		 * See comment below starting `Step through' for
		 * an explaination of the locking protocol.
		 */
		pdp = vdp;
		dp = VTOI(*vpp);
		vdp = *vpp;
		vpid = vdp->v_id;
		if (pdp == vdp) {   /* lookup on "." */
			VREF(vdp);
			error = 0;
		} else if (flags & ISDOTDOT) {
			VOP_UNLOCK(pdp, 0, p);
			error = vget(vdp, LK_EXCLUSIVE, p);
			if (!error && lockparent && (flags & ISLASTCN))
				error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
		} else {
			error = vget(vdp, LK_EXCLUSIVE, p);
			if (!lockparent || error || !(flags & ISLASTCN))
				VOP_UNLOCK(pdp, 0, p);
		}
		/*
		 * Check that the capability number did not change
		 * while we were waiting for the lock.
		 */
		if (!error) {
			if (vpid == vdp->v_id)
				return (0);
			vput(vdp);
			if (lockparent && pdp != vdp && (flags & ISLASTCN))
				VOP_UNLOCK(pdp, 0, p);
		}
		if ((error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
			return (error);
		vdp = pdp;
		dp = VTOI(pdp);
		*vpp = NULL;
	}
d531 1
a531 1
		if (!lockparent)
d533 2
d609 1
a609 1
		if (!lockparent)
d611 2
d636 1
a636 1
		if (!lockparent)
d638 2
d665 1
d667 2
a668 1
			vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d671 6
a676 4
		if (lockparent && (flags & ISLASTCN) &&
			(error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p)) != 0) {
			vput(tdp);
			return (error);
d685 1
a685 1
		if (!lockparent || !(flags & ISLASTCN))
d687 2
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.12 2002/02/22 20:37:45 drahn Exp $	*/
d109 1
a109 1
		panic("ext2fs: e2dir->e2d_namlen\n");
@


1.12
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.11 2001/09/18 01:21:55 art Exp $	*/
d77 3
a79 3
static void	ext2fs_dirconv2ffs __P((struct ext2fs_direct *e2dir,
					  struct dirent *ffsdir));
static int	ext2fs_dirbadentry __P((struct vnode *dp,
d81 1
a81 1
					  int entryoffsetinblock));
@


1.11
log
@More of cleanups, reliability and endianness fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.11 2001/09/18 01:21:55 art Exp $	*/
a64 1
#include <ufs/ufs/extattr.h>
d76 3
a78 3
static void	ext2fs_dirconv2ffs(struct ext2fs_direct *e2dir,
					  struct dirent *ffsdir);
static int	ext2fs_dirbadentry(struct vnode *dp,
d80 1
a80 1
					  int entryoffsetinblock);
@


1.11.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.11.4.1 2002/06/11 03:32:49 art Exp $	*/
d109 1
a109 1
		panic("ext2fs: e2dir->e2d_namlen");
@


1.11.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d320 44
a363 2
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);
d573 1
a573 1
		if (!lockparent) {
a574 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d649 1
a649 1
		if (!lockparent) {
a650 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d674 1
a674 1
		if (!lockparent) {
a675 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
a700 1
		cnp->cn_flags |= PDIRUNLOCK;
d702 1
a702 2
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
d705 4
a708 6
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p)) != 0) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
d717 1
a717 1
		if (!lockparent || !(flags & ISLASTCN)) {
a718 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
@


1.10
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_lookup.c,v 1.9 2001/04/06 02:26:12 csapuntz Exp $	*/
/*	$NetBSD: ext2fs_lookup.c,v 1.1 1997/06/11 09:33:59 bouyer Exp $	*/
d28 1
a28 1
 *	notice, this list of conditions and the following disclaimer.
d30 2
a31 2
 *	notice, this list of conditions and the following disclaimer in the
 *	documentation and/or other materials provided with the distribution.
d33 1
a33 1
 *	must display the following acknowledgement:
d37 2
a38 2
 *	may be used to endorse or promote products derived from this software
 *	without specific prior written permission.
d97 2
a98 2
	bzero(ffsdir, sizeof(struct dirent));
	ffsdir->d_fileno = e2dir->e2d_ino;
d107 2
a108 1
	if (e2dir->e2d_namlen > MAXNAMLEN) panic("ext2fs: e2dir->e2d_namlen");
d138 2
a139 2
		int *a_eofflag;
		u_long *a_cookies;
d142 1
a142 1
	register struct uio *uio = ap->a_uio;
d144 3
a146 2
	size_t count, readcnt, lost;
	struct m_ext2fs *fs = VTOI(ap->a_vp)->i_e2fs;
a153 1
	int ncookies = 0;
d155 7
a161 1
	count = uio->uio_resid;
d163 2
a164 2
	count -= (uio->uio_offset + count) & (fs->e2fs_bsize -1);
	if (count <= 0)
a165 3
	lost = uio->uio_resid - count;
	uio->uio_resid = count;
	uio->uio_iov->iov_len = count;
d171 3
a173 23
	aiov.iov_len = count;
	MALLOC(dirbuf, caddr_t, count, M_TEMP, M_WAITOK);
	bzero(dirbuf, count);
	aiov.iov_base = dirbuf;

	error = VOP_READ(ap->a_vp, &auio, 0, ap->a_cred);
	if (error) 
		goto err_exit;

	
	readcnt = count - auio.uio_resid;
	
	for (dp = (struct ext2fs_direct *)dirbuf; 
	     (char *)dp < (char *)dirbuf + readcnt; ) {
		if (dp->e2d_reclen <= 0) {
			error = EIO;
			goto err_exit;
		}
		dp = (struct ext2fs_direct *) ((char *)dp + dp->e2d_reclen);
		ncookies++;
	}


d175 2
a176 3
		MALLOC(cookies, u_long *, ncookies * sizeof(u_long), M_TEMP,
		       M_WAITOK);
		*ap->a_ncookies = ncookies;
d179 2
d182 26
a207 9

	for (dp = (struct ext2fs_direct *)dirbuf; 
	     (char *)dp < (char *)dirbuf + readcnt; ) {

		ext2fs_dirconv2ffs(dp, &dstd);
		if(dstd.d_reclen > uio->uio_resid) {
			break;
		}
		if ((error = uiomove((caddr_t)&dstd, dstd.d_reclen, uio)) != 0) {			goto err_exit;
d209 2
a210 7

		off = off + dp->e2d_reclen;

		if (cookies)
			*cookies++ = off;

		dp = (struct ext2fs_direct *) ((char *)dp + dp->e2d_reclen);			/* advance dp */
a211 4
	/* we need to correct uio_offset */
	uio->uio_offset = off;

err_exit:
d213 8
a220 5

	if (error && cookies) {
		FREE(*ap->a_cookies, M_TEMP);
		*ap->a_cookies = 0;
		*ap->a_ncookies = 0;
a221 3
	*ap->a_eofflag = VTOI(ap->a_vp)->i_e2fs_size <= uio->uio_offset;
	uio->uio_resid += lost;
	
d267 2
a268 2
	register struct vnode *vdp;	/* vnode for directory being searched */
	register struct inode *dp;	/* inode for directory being searched */
d270 1
a270 1
	register struct ext2fs_direct *ep; /* the current directory entry */
d308 4
d440 2
a441 1
			(dirchk && ext2fs_dirbadentry(vdp, ep, entryoffsetinblock))) {
d444 2
a445 1
			i = dirblksize - (entryoffsetinblock & (dirblksize - 1));
d458 1
a458 1
			int size = ep->e2d_reclen;
d466 1
a466 1
					slotsize = ep->e2d_reclen;
d474 1
a474 1
							  ep->e2d_reclen - slotoffset;
d486 1
a486 1
				!bcmp(cnp->cn_nameptr, ep->e2d_name,
d493 2
a494 2
				dp->i_ino = ep->e2d_ino;
				dp->i_reclen = ep->e2d_reclen;
d500 2
a501 2
		dp->i_offset += ep->e2d_reclen;
		entryoffsetinblock += ep->e2d_reclen;
d589 1
a589 1
		> dp->i_e2fs_size) {
d591 2
a592 1
		dp->i_e2fs_size = entryoffsetinblock+EXT2FS_DIRSIZ(ep->e2d_namlen);
d743 1
a743 1
	register struct ext2fs_direct *de;
d749 2
d752 1
a752 1
		if (de->e2d_reclen < EXT2FS_DIRSIZ(1)) /* e2d_namlen = 1 */
d754 1
a754 1
		else if (de->e2d_reclen % 4 != 0)
d756 1
a756 1
		else if (de->e2d_reclen < EXT2FS_DIRSIZ(de->e2d_namlen))
d758 1
a758 1
		else if (entryoffsetinblock + de->e2d_reclen > dirblksize)
d760 2
a761 1
		else if (de->e2d_ino > VTOI(dp)->i_e2fs->e2fs.e2fs_icount)
d766 4
a769 3
						"offset=%d, inode=%lu, rec_len=%d, name_len=%d \n",
						error_msg, entryoffsetinblock, 
			(unsigned long) de->e2d_ino, de->e2d_reclen, de->e2d_namlen);
d787 1
a787 1
	register struct componentname *cnp;
d789 2
a790 2
	register struct ext2fs_direct *ep, *nep;
	register struct inode *dp;
d798 1
a798 1
	int	 dirblksize = ip->i_e2fs->e2fs_bsize;
d814 2
a815 2
	bcopy(cnp->cn_nameptr, newdir.e2d_name, (unsigned)cnp->cn_namelen + 1);
	newentrysize = EXT2FS_DIRSIZ(newdir.e2d_namlen);
d826 1
a826 1
		newdir.e2d_reclen = dirblksize;
d871 2
a872 2
	spacefree = ep->e2d_reclen - dsize;
	for (loc = ep->e2d_reclen; loc < dp->i_count; ) {
d876 1
a876 1
			ep->e2d_reclen = dsize;
d883 3
a885 3
		spacefree += nep->e2d_reclen - dsize;
		loc += nep->e2d_reclen;
		bcopy((caddr_t)nep, (caddr_t)ep, dsize);
d896 1
a896 1
		newdir.e2d_reclen = spacefree + dsize;
d901 1
a901 1
						(u_int)spacefree, (u_int)newentrysize);
d905 2
a906 2
		newdir.e2d_reclen = spacefree;
		ep->e2d_reclen = dsize;
d909 1
a909 1
	bcopy((caddr_t)&newdir, (caddr_t)ep, (u_int)newentrysize);
d914 1
a914 1
			cnp->cn_cred);
d935 1
a935 1
	register struct inode *dp;
d958 1
a958 1
			(char **)&ep, &bp);
d961 1
a961 1
	ep->e2d_reclen += dp->i_reclen;
d1007 1
a1007 1
	register struct inode *ip;
d1011 1
a1011 1
	register off_t off;
d1013 1
a1013 1
	register struct ext2fs_direct *dp = (struct ext2fs_direct *)&dbuf;
d1019 1
a1019 1
	for (off = 0; off < ip->i_e2fs_size; off += dp->e2d_reclen) {
d1047 1
a1047 1
		if (dp->e2d_name[1] == '.' && dp->e2d_ino == parentino)
d1067 1
d1085 3
a1087 2
			sizeof (struct ext2fs_dirtemplate), (off_t)0, UIO_SYSSPACE,
			IO_NODELOCKED, cred, NULL, (struct proc *)0);
d1097 2
a1098 1
		if (dirbuf.dotdot_ino == source->i_number) {
d1102 1
a1102 1
		if (dirbuf.dotdot_ino == rootino)
d1105 1
a1105 1
		error = VFS_VGET(vp->v_mount, dirbuf.dotdot_ino, &vp);
a1120 1

@


1.9
log
@

Free the right variable on error
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.8 2001/03/25 03:53:35 csapuntz Exp $	*/
d401 2
a402 1
			(error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset, NULL, &bp)))
d418 2
a419 1
			error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset, NULL, &bp);
d855 2
a856 1
	if ((error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, &dirbuf, &bp)) != 0)
d909 2
a910 2
		error = VOP_TRUNCATE(dvp, (off_t)dp->i_endoff, IO_SYNC,
			cnp->cn_cred, cnp->cn_proc);
d941 2
a942 1
		error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, (char **)&ep, &bp);
d953 1
a953 1
	error = VOP_BLKATOFF(dvp, (off_t)(dp->i_offset - dp->i_count),
a974 1
	struct vnode *vdp = ITOV(dp);
d977 1
a977 1
	error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset, (char **)&ep, &bp);
@


1.8
log
@Free the right variable. Thanks to Dawson and team.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.7 2000/04/26 23:24:41 jasoni Exp $	*/
d222 1
a222 1
		FREE(cookies, M_TEMP);
@


1.7
log
@Support for ext2fs rev. 1 (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.6 1999/01/11 05:12:37 millert Exp $	*/
d222 1
a222 1
		FREE(ap->a_cookies, M_TEMP);
@


1.6
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.5 1998/07/28 00:13:14 millert Exp $	*/
d800 1
a800 1
	newdir.e2d_ino = ip->i_number;
d802 6
d977 7
a983 1
	ep->e2d_ino = ip->i_number;
@


1.6.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.9 2001/04/06 02:26:12 csapuntz Exp $	*/
d222 1
a222 1
		FREE(*ap->a_cookies, M_TEMP);
d800 1
a800 1
	newdir.e2d_ino = h2fs32(ip->i_number);
a801 6
	if (ip->i_e2fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    (ip->i_e2fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_FTYPE)) {
		newdir.e2d_type = inot2ext2dt(IFTODT(ip->i_ffs_mode));
	} else {
		newdir.e2d_type = 0;
	};
d971 1
a971 7
	ep->e2d_ino = h2fs32(ip->i_number);
	if (ip->i_e2fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    (ip->i_e2fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_FTYPE)) {
		ep->e2d_type = inot2ext2dt(IFTODT(ip->i_ffs_mode));
	} else {
		ep->e2d_type = 0;
	}
@


1.6.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.6.6.1 2001/05/14 22:47:39 niklas Exp $	*/
d401 1
a401 2
			(error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, 
			    NULL, &bp)))
d417 1
a417 2
			error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, 
			    NULL, &bp);
d853 1
a853 2
	if ((error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, &dirbuf, &bp)) 
	    != 0)
d906 2
a907 2
		error = ext2fs_truncate(dp, (off_t)dp->i_endoff, IO_SYNC,
			cnp->cn_cred);
d938 1
a938 2
		error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, (char **)&ep, 
		    &bp);
d949 1
a949 1
	error = ext2fs_bufatoff(dp, (off_t)(dp->i_offset - dp->i_count),
d971 1
d974 1
a974 1
	error = ext2fs_bufatoff(dp, (off_t)dp->i_offset, (char **)&ep, &bp);
@


1.6.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_lookup.c,v 1.6.6.2 2001/07/04 11:00:44 niklas Exp $	*/
/*	$NetBSD: ext2fs_lookup.c,v 1.16 2000/08/03 20:29:26 thorpej Exp $	*/
d28 1
a28 1
 *    notice, this list of conditions and the following disclaimer.
d30 2
a31 2
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d33 1
a33 1
 *    must display the following acknowledgement:
d37 2
a38 2
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d97 2
a98 2
	memset(ffsdir, 0, sizeof(struct dirent));
	ffsdir->d_fileno = fs2h32(e2dir->e2d_ino);
d107 1
a107 2
	if (e2dir->e2d_namlen > MAXNAMLEN)
		panic("ext2fs: e2dir->e2d_namlen\n");
d137 2
a138 2
		int **a_eofflag;
		off_t **a_cookies;
d141 1
a141 1
	struct uio *uio = ap->a_uio;
d143 2
a144 3
	size_t e2fs_count, readcnt;
	struct vnode *vp = ap->a_vp;
	struct m_ext2fs *fs = VTOI(vp)->i_e2fs;
d152 1
d154 1
a154 7
	int nc = 0, ncookies = 0;
	int e2d_reclen;

	if (vp->v_type != VDIR)
		return (ENOTDIR);

	e2fs_count = uio->uio_resid;
d156 2
a157 2
	e2fs_count -= (uio->uio_offset + e2fs_count) & (fs->e2fs_bsize -1);
	if (e2fs_count <= 0)
d159 3
d167 23
a189 3
	aiov.iov_len = e2fs_count;
	auio.uio_resid = e2fs_count;
	MALLOC(dirbuf, caddr_t, e2fs_count, M_TEMP, M_WAITOK);
d191 3
a193 2
		nc = ncookies = e2fs_count / 16;
		cookies = malloc(sizeof (off_t) * ncookies, M_TEMP, M_WAITOK);
a195 2
	memset(dirbuf, 0, e2fs_count);
	aiov.iov_base = dirbuf;
d197 9
a205 26
	error = VOP_READ(ap->a_vp, &auio, 0, ap->a_cred);
	if (error == 0) {
		readcnt = e2fs_count - auio.uio_resid;
		for (dp = (struct ext2fs_direct *)dirbuf; 
			(char *)dp < (char *)dirbuf + readcnt; ) {
			e2d_reclen = fs2h16(dp->e2d_reclen);
			if (e2d_reclen == 0) {
				error = EIO;
				break;
			}
			ext2fs_dirconv2ffs(dp, &dstd);
			if(dstd.d_reclen > uio->uio_resid) {
				break;
			}
			if ((error = uiomove((caddr_t)&dstd, dstd.d_reclen, uio)) != 0) {
				break;
			}
			off = off + e2d_reclen;
			if (cookies != NULL) {
				*cookies++ = off;
				if (--ncookies <= 0){
					break;  /* out of cookies */
				}
			}
			/* advance dp */
			dp = (struct ext2fs_direct *) ((char *)dp + e2d_reclen);
d207 7
a213 2
		/* we need to correct uio_offset */
		uio->uio_offset = off;
d215 4
d220 6
d227 2
a228 8
	if (ap->a_ncookies) {
		if (error) {
			free(*ap->a_cookies, M_TEMP);
			*ap->a_ncookies = 0;
			*ap->a_cookies = NULL;
		} else
			*ap->a_ncookies = nc - ncookies;
	}
d274 2
a275 2
	struct vnode *vdp;	/* vnode for directory being searched */
	struct inode *dp;	/* inode for directory being searched */
d277 1
a277 1
	struct ext2fs_direct *ep; /* the current directory entry */
a314 4
	if ((flags & ISLASTCN) && (vdp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

d443 1
a443 2
		    (dirchk &&
		    ext2fs_dirbadentry(vdp, ep, entryoffsetinblock))) {
d446 1
a446 2
			i = dirblksize -
			    (entryoffsetinblock & (dirblksize - 1));
d459 1
a459 1
			int size = fs2h16(ep->e2d_reclen);
d467 1
a467 1
					slotsize = fs2h16(ep->e2d_reclen);
d475 1
a475 1
							  fs2h16(ep->e2d_reclen) - slotoffset;
d487 1
a487 1
				!memcmp(cnp->cn_nameptr, ep->e2d_name,
d494 2
a495 2
				dp->i_ino = fs2h32(ep->e2d_ino);
				dp->i_reclen = fs2h16(ep->e2d_reclen);
d501 2
a502 2
		dp->i_offset += fs2h16(ep->e2d_reclen);
		entryoffsetinblock += fs2h16(ep->e2d_reclen);
d590 1
a590 1
	    > dp->i_e2fs_size) {
d592 1
a592 2
		dp->i_e2fs_size = entryoffsetinblock +
			EXT2FS_DIRSIZ(ep->e2d_namlen);
d743 1
a743 1
	struct ext2fs_direct *de;
a748 2
		int reclen = fs2h16(de->e2d_reclen);
		int namlen = de->e2d_namlen;
d750 1
a750 1
		if (reclen < EXT2FS_DIRSIZ(1)) /* e2d_namlen = 1 */
d752 1
a752 1
		else if (reclen % 4 != 0)
d754 1
a754 1
		else if (reclen < EXT2FS_DIRSIZ(namlen))
d756 1
a756 1
		else if (entryoffsetinblock + reclen > dirblksize)
d758 1
a758 2
		else if (fs2h32(de->e2d_ino) >
		    VTOI(dp)->i_e2fs->e2fs.e2fs_icount)
d763 3
a765 4
			    "offset=%d, inode=%lu, rec_len=%d, name_len=%d \n",
			    error_msg, entryoffsetinblock,
			    (unsigned long) fs2h32(de->e2d_ino),
			    reclen, namlen);
d783 1
a783 1
	struct componentname *cnp;
d785 2
a786 2
	struct ext2fs_direct *ep, *nep;
	struct inode *dp;
d794 1
a794 1
	int dirblksize = ip->i_e2fs->e2fs_bsize;
d810 2
a811 2
	memcpy(newdir.e2d_name, cnp->cn_nameptr, (unsigned)cnp->cn_namelen + 1);
	newentrysize = EXT2FS_DIRSIZ(cnp->cn_namelen);
d822 1
a822 1
		newdir.e2d_reclen = h2fs16(dirblksize);
d867 2
a868 2
	spacefree = fs2h16(ep->e2d_reclen) - dsize;
	for (loc = fs2h16(ep->e2d_reclen); loc < dp->i_count; ) {
d872 1
a872 1
			ep->e2d_reclen = h2fs16(dsize);
d879 3
a881 3
		spacefree += fs2h16(nep->e2d_reclen) - dsize;
		loc += fs2h16(nep->e2d_reclen);
		memcpy((caddr_t)ep, (caddr_t)nep, dsize);
d892 1
a892 1
		newdir.e2d_reclen = h2fs16(spacefree + dsize);
d897 1
a897 1
			    (u_int)spacefree, (u_int)newentrysize);
d901 2
a902 2
		newdir.e2d_reclen = h2fs16(spacefree);
		ep->e2d_reclen = h2fs16(dsize);
d905 1
a905 1
	memcpy((caddr_t)ep, (caddr_t)&newdir, (u_int)newentrysize);
d910 1
a910 1
		    cnp->cn_cred);
d931 1
a931 1
	struct inode *dp;
d954 1
a954 1
	    (char **)&ep, &bp);
d957 1
a957 1
	ep->e2d_reclen = h2fs16(fs2h16(ep->e2d_reclen) + dp->i_reclen);
d1003 1
a1003 1
	struct inode *ip;
d1007 1
a1007 1
	off_t off;
d1009 1
a1009 1
	struct ext2fs_direct *dp = (struct ext2fs_direct *)&dbuf;
d1015 1
a1015 1
	for (off = 0; off < ip->i_e2fs_size; off += fs2h16(dp->e2d_reclen)) {
d1043 1
a1043 1
		if (dp->e2d_name[1] == '.' && fs2h32(dp->e2d_ino) == parentino)
a1062 1
	u_int32_t ino;
d1080 2
a1081 3
			sizeof (struct ext2fs_dirtemplate), (off_t)0,
			UIO_SYSSPACE, IO_NODELOCKED, cred, (size_t *)0,
			(struct proc *)0);
d1091 1
a1091 2
		ino = fs2h32(dirbuf.dotdot_ino);
		if (ino == source->i_number) {
d1095 1
a1095 1
		if (ino == rootino)
d1098 1
a1098 1
		error = VFS_VGET(vp->v_mount, ino, &vp);
d1114 1
@


1.6.6.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a64 1
#include <ufs/ufs/extattr.h>
@


1.6.6.5
log
@Merge in -current from roughly a week ago
@
text
@d77 3
a79 3
static void	ext2fs_dirconv2ffs(struct ext2fs_direct *e2dir,
					  struct dirent *ffsdir);
static int	ext2fs_dirbadentry(struct vnode *dp,
d81 1
a81 1
					  int entryoffsetinblock);
@


1.6.6.6
log
@Sync the SMP branch with 3.3
@
text
@d109 1
a109 1
		panic("ext2fs: e2dir->e2d_namlen");
d320 44
a363 2
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);
d573 1
a573 1
		if (!lockparent) {
a574 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d649 1
a649 1
		if (!lockparent) {
a650 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d674 1
a674 1
		if (!lockparent) {
a675 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
a700 1
		cnp->cn_flags |= PDIRUNLOCK;
d702 1
a702 2
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
d705 4
a708 6
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p)) != 0) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
d717 1
a717 1
		if (!lockparent || !(flags & ISLASTCN)) {
a718 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
@


1.6.6.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.6.6.6 2003/03/28 00:08:47 niklas Exp $	*/
d32 5
a36 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.6.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a103 1
	/* XXX: e2d_namlen is to small for such comparison
a105 1
	*/
@


1.5
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.4 1998/01/12 00:45:06 csapuntz Exp $	*/
d107 1
a107 1
	if (e2dir->e2d_namlen > MAXNAMLEN) panic("ext2fs: e2dir->e2d_namlen\n");
@


1.4
log
@Free cookies correctly in case of error
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.3 1997/11/06 05:59:15 csapuntz Exp $	*/
d995 2
a996 1
	int error, count, namlen;
d1066 1
a1066 1
			IO_NODELOCKED, cred, (int *)0, (struct proc *)0);
@


1.3
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.2 1997/06/12 21:09:34 downsj Exp $	*/
d205 1
a205 5
		if ((error = uiomove((caddr_t)&dstd, dstd.d_reclen, uio)) != 0) {
			FREE(ap->a_ncookies, M_TEMP);
			*ap->a_cookies = 0;
			
			goto err_exit;
d220 6
@


1.2
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_lookup.c,v 1.1.1.1 1997/05/30 05:18:51 downsj Exp $	*/
d152 2
a153 3
	u_long *cookies = ap->a_cookies;
	int ncookies = ap->a_ncookies;

d173 37
a209 24
	if (error == 0) {
		readcnt = count - auio.uio_resid;
		for (dp = (struct ext2fs_direct *)dirbuf; 
			(char *)dp < (char *)dirbuf + readcnt; ) {
			if (dp->e2d_reclen <= 0) {
				error = EIO;
				break;
			}
			ext2fs_dirconv2ffs(dp, &dstd);
			if(dstd.d_reclen > uio->uio_resid) {
				break;
			}
			if ((error = uiomove((caddr_t)&dstd, dstd.d_reclen, uio)) != 0) {
				break;
			}
			off = off + dp->e2d_reclen;
			if (cookies != NULL) {
				*cookies++ = off;
				if (--ncookies <= 0){
					break;  /* out of cookies */
				}
			}
			/* advance dp */
			dp = (struct ext2fs_direct *) ((char *)dp + dp->e2d_reclen);
d211 7
a217 2
		/* we need to correct uio_offset */
		uio->uio_offset = off;
d219 4
d226 1
d297 1
a297 1

d338 2
a339 2
			VOP_UNLOCK(pdp);
			error = vget(vdp, 1);
d341 1
a341 1
				error = VOP_LOCK(pdp);
d343 1
a343 1
			error = vget(vdp, 1);
d345 1
a345 1
				VOP_UNLOCK(pdp);
d356 1
a356 1
				VOP_UNLOCK(pdp);
d358 1
a358 1
		if ((error = VOP_LOCK(pdp)) != 0)
d570 1
a570 1
			VOP_UNLOCK(vdp);
d645 1
a645 1
			VOP_UNLOCK(vdp);
d670 1
a670 1
			VOP_UNLOCK(vdp);
d695 1
a695 1
		VOP_UNLOCK(pdp);	/* race to get the inode */
d697 1
a697 1
			VOP_LOCK(pdp);
d701 1
a701 1
			(error = VOP_LOCK(pdp)) != 0) {
d713 1
a713 1
			VOP_UNLOCK(pdp);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 3
/*	$OpenBSD: ext2_lookup.c,v 1.3 1996/10/18 15:23:38 mickey Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d4 5
a287 2
	if ((dp->i_e2fs_mode & IFMT) != IFDIR)
		return (ENOTDIR);
d500 6
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@
