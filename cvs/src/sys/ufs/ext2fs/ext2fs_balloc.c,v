head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.4
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.2
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.06.03.18.00.10;	author natano;	state Exp;
branches;
next	1.25;
commitid	U9Tuk3fIFh5Jjh7C;

1.25
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.23;
commitid	uzzBR7hz9ncd4O6G;

1.23
date	2014.07.14.08.54.13;	author pelikan;	state Exp;
branches;
next	1.22;
commitid	5pxoUiNNvSjZa1j9;

1.22
date	2014.07.13.16.59.35;	author pelikan;	state Exp;
branches;
next	1.21;
commitid	zGe0z6RRYbZJpA8u;

1.21
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	EF98ch02VpFassUi;

1.20
date	2014.05.27.14.31.24;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.05.17.23.43;	author jasper;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.21.17.48.38;	author jasper;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.02.00.45.50;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.17.23.31.39;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.23.02.07.50;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.12.36;	author millert;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.06.12.21.09.31;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.05.30.08.33.39;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.4.6.1
date	2001.07.04.11.00.41;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.4.6.5;

1.4.6.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.4.6.6;

1.4.6.6
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	;

1.10.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Unsigned integers can't be negative.
from David Hill and mmcc@@
ok stefan
@
text
@/*	$OpenBSD: ext2fs_balloc.c,v 1.25 2015/03/14 03:38:52 jsg Exp $	*/
/*	$NetBSD: ext2fs_balloc.c,v 1.10 2001/07/04 21:16:01 chs Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_balloc.c	8.4 (Berkeley) 9/23/93
 * Modified for ext2fs by Manuel Bouyer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/vnode.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ext2fs/ext2fs_extern.h>

/*
 * Balloc defines the structure of file system storage
 * by allocating the physical blocks on a device given
 * the inode and the logical block number in a file.
 */
int
ext2fs_buf_alloc(struct inode *ip, u_int32_t bn, int size, struct ucred *cred,
    struct buf **bpp, int flags)
{
	struct m_ext2fs *fs;
	struct buf *bp, *nbp;
	struct vnode *vp = ITOV(ip);
	struct indir indirs[NIADDR + 2];
	u_int32_t nb, newb, *bap;
	int num, i, error;
	u_int deallocated;
	u_int32_t *allocib, *blkp, *allocblk, allociblk[NIADDR + 1];
	int unwindidx = -1;
	daddr_t lbn, pref;

	*bpp = NULL;
	fs = ip->i_e2fs;
	lbn = bn;

	/*
	 * The first NDADDR blocks are direct blocks
	 */
	if (bn < NDADDR) {
		nb = letoh32(ip->i_e2fs_blocks[bn]);
		if (nb != 0) {
			error = bread(vp, bn, fs->e2fs_bsize, &bp);
			if (error) {
				brelse(bp);
				return (error);
			}
			*bpp = bp;
			return (0);
		}

		/*
		 * allocate a new direct block.
		 */
		error = ext2fs_alloc(ip, bn,
		    ext2fs_blkpref(ip, bn, (int)bn, &ip->i_e2fs_blocks[0]),
		    cred, &newb);
		if (error)
			return (error);
		ip->i_e2fs_last_lblk = lbn;
		ip->i_e2fs_last_blk = newb;
		ip->i_e2fs_blocks[bn] = htole32(newb);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		bp = getblk(vp, bn, fs->e2fs_bsize, 0, 0);
		bp->b_blkno = fsbtodb(fs, newb);
		if (flags & B_CLRBUF)
			clrbuf(bp);
		*bpp = bp;
		return (0);
	}
	/*
	 * Determine the number of levels of indirection.
	 */
	pref = 0;
	if ((error = ufs_getlbns(vp, bn, indirs, &num)) != 0)
		return(error);
#ifdef DIAGNOSTIC
	if (num < 1)
		panic ("ext2fs_balloc: ufs_getlbns returned indirect block");
#endif
	/*
	 * Fetch the first indirect block allocating if necessary.
	 */
	--num;
	nb = letoh32(ip->i_e2fs_blocks[NDADDR + indirs[0].in_off]);
	allocib = NULL;
	allocblk = allociblk;
	if (nb == 0) {
		pref = ext2fs_blkpref(ip, lbn, 0, NULL);
		error = ext2fs_alloc(ip, lbn, pref, cred, &newb);
		if (error)
			return (error);
		nb = newb;
		*allocblk++ = nb;
		ip->i_e2fs_last_blk = newb;
		bp = getblk(vp, indirs[1].in_lbn, fs->e2fs_bsize, 0, 0);
		bp->b_blkno = fsbtodb(fs, newb);
		clrbuf(bp);
		/*
		 * Write synchronously so that indirect blocks
		 * never point at garbage.
		 */
		if ((error = bwrite(bp)) != 0)
			goto fail;
		unwindidx = 0;
		allocib = &ip->i_e2fs_blocks[NDADDR + indirs[0].in_off];
		*allocib = htole32(newb);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	/*
	 * Fetch through the indirect blocks, allocating as necessary.
	 */
	for (i = 1;;) {
		error = bread(vp, indirs[i].in_lbn, (int)fs->e2fs_bsize, &bp);
		if (error) {
			brelse(bp);
			goto fail;
		}
		bap = (u_int32_t *)bp->b_data;
		nb = letoh32(bap[indirs[i].in_off]);
		if (i == num)
			break;
		i++;
		if (nb != 0) {
			brelse(bp);
			continue;
		}
		pref = ext2fs_blkpref(ip, lbn, 0, NULL);
		error = ext2fs_alloc(ip, lbn, pref, cred, &newb);
		if (error) {
			brelse(bp);
			goto fail;
		}
		nb = newb;
		*allocblk++ = nb;
		ip->i_e2fs_last_blk = newb;
		nbp = getblk(vp, indirs[i].in_lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		clrbuf(nbp);
		/*
		 * Write synchronously so that indirect blocks
		 * never point at garbage.
		 */
		if ((error = bwrite(nbp)) != 0) {
			brelse(bp);
			goto fail;
		}
		if (unwindidx < 0)
			unwindidx = i - 1;
		bap[indirs[i - 1].in_off] = htole32(nb);
		/*
		 * If required, write synchronously, otherwise use
		 * delayed write.
		 */
		if (flags & B_SYNC) {
			bwrite(bp);
		} else {
			bdwrite(bp);
		}
	}
	/*
	 * Get the data block, allocating if necessary.
	 */
	if (nb == 0) {
		pref = ext2fs_blkpref(ip, lbn, indirs[num].in_off, bap);
		error = ext2fs_alloc(ip, lbn, pref, cred, &newb);
		if (error) {
			brelse(bp);
			goto fail;
		}
		nb = newb;
		*allocblk++ = nb;
		ip->i_e2fs_last_lblk = lbn;
		ip->i_e2fs_last_blk = newb;
		bap[indirs[num].in_off] = htole32(nb);
		/*
		 * If required, write synchronously, otherwise use
		 * delayed write.
		 */
		if (flags & B_SYNC) {
			bwrite(bp);
		} else {
			bdwrite(bp);
		}
		nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		if (flags & B_CLRBUF)
			clrbuf(nbp);
		*bpp = nbp;
		return (0);
	}
	brelse(bp);
	if (flags & B_CLRBUF) {
		error = bread(vp, lbn, (int)fs->e2fs_bsize, &nbp);
		if (error) {
			brelse(nbp);
			goto fail;
		}
	} else {
		nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
	}

	*bpp = nbp;
	return (0);
fail:
	/*
	 * If we have failed part way through block allocation, we
	 * have to deallocate any indirect blocks that we have allocated.
	 */
	for (deallocated = 0, blkp = allociblk; blkp < allocblk; blkp++) {
		ext2fs_blkfree(ip, *blkp);
		deallocated += fs->e2fs_bsize;
	}
	if (unwindidx >= 0) {
		if (unwindidx == 0) {
			*allocib = 0;
		} else {
			int r;

			r = bread(vp, indirs[unwindidx].in_lbn,
			    (int)fs->e2fs_bsize, &bp);
			if (r) {
				panic("Could not unwind indirect block, error %d", r);
			} else {
				bap = (u_int32_t *)bp->b_data;
				bap[indirs[unwindidx].in_off] = 0;
				if (flags & B_SYNC)
					bwrite(bp);
				else
					bdwrite(bp);
			}
		}
		for (i = unwindidx + 1; i <= num; i++) {
			bp = getblk(vp, indirs[i].in_lbn, (int)fs->e2fs_bsize,
			    0, 0);
			bp->b_flags |= B_INVAL;
			brelse(bp);
		}
	}
	if (deallocated) {
		ip->i_e2fs_nblock -= btodb(deallocated);
		ip->i_e2fs_flags |= IN_CHANGE | IN_UPDATE;
	}
	return error;
}
@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.24 2014/09/14 14:17:26 jsg Exp $	*/
a69 2
	if (bn < 0)
		return (EFBIG);
@


1.24
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.23 2014/07/14 08:54:13 pelikan Exp $	*/
a39 1
#include <sys/file.h>
@


1.23
log
@better type safety and KNF.

Because ext2fs has only 32-bit inode numbers, use ufsino_t as in FFS.
Disk blocks are u_int32_t as well, because we don't support the 64BIT flag.
When we do, there's going to be a lot more going on than just daddr_t.

While there, add some journaling-related bits into the superblock to play with.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.22 2014/07/13 16:59:35 pelikan Exp $	*/
a39 1
#include <sys/proc.h>
@


1.22
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

Some KNF while there.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.21 2014/07/08 17:19:26 deraadt Exp $	*/
d57 1
a57 1
ext2fs_buf_alloc(struct inode *ip, daddr_t bn, int size, struct ucred *cred,
d64 1
a64 1
	int32_t nb, newb, *bap;
d67 1
a67 1
	int32_t *allocib, *blkp, *allocblk, allociblk[NIADDR + 1];
d129 1
a129 1
		pref = ext2fs_blkpref(ip, lbn, 0, (int32_t *)0);
d159 1
a159 1
		bap = (int32_t *)bp->b_data;
d168 1
a168 1
		pref = ext2fs_blkpref(ip, lbn, 0, (int32_t *)0);
d205 1
a205 1
		pref = ext2fs_blkpref(ip, lbn, indirs[num].in_off, &bap[0]);
d266 1
a266 1
				bap = (int32_t *)bp->b_data;
@


1.21
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.20 2014/05/27 14:31:24 krw Exp $	*/
d81 1
a81 1
		nb = fs2h32(ip->i_e2fs_blocks[bn]);
d102 1
a102 1
		ip->i_e2fs_blocks[bn] = h2fs32(newb);
d125 1
a125 1
	nb = fs2h32(ip->i_e2fs_blocks[NDADDR + indirs[0].in_off]);
d147 1
a147 1
		*allocib = h2fs32(newb);
d160 1
a160 1
		nb = fs2h32(bap[indirs[i].in_off]);
d190 1
a190 1
		bap[indirs[i - 1].in_off] = h2fs32(nb);
d215 1
a215 1
		bap[indirs[num].in_off] = h2fs32(nb);
@


1.20
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.19 2013/06/11 16:42:18 deraadt Exp $	*/
a42 2

#include <uvm/uvm_extern.h>
@


1.19
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.18 2011/07/04 04:30:41 tedu Exp $	*/
d59 1
a59 1
ext2fs_buf_alloc(struct inode *ip, daddr_t bn, int size, struct ucred *cred, 
d262 2
a263 2
	
			r = bread(vp, indirs[unwindidx].in_lbn, 
@


1.18
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.17 2009/09/05 17:23:43 jasper Exp $	*/
d59 1
a59 1
ext2fs_buf_alloc(struct inode *ip, daddr64_t bn, int size, struct ucred *cred, 
d71 1
a71 1
	daddr64_t lbn, pref;
@


1.17
log
@- don't try to shove a daddr64_t value into an int32_t.
eventhough this won't really harm as ext2fs doesn't handle files that large,
it was not correct.

no objections from thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.16 2009/08/21 17:48:38 jasper Exp $	*/
d85 1
a85 1
			error = bread(vp, bn, fs->e2fs_bsize, NOCRED, &bp);
d156 1
a156 2
		error = bread(vp,
		    indirs[i].in_lbn, (int)fs->e2fs_bsize, NOCRED, &bp);
d236 1
a236 1
		error = bread(vp, lbn, (int)fs->e2fs_bsize, NOCRED, &nbp);
d264 1
a264 1
			    (int)fs->e2fs_bsize, NOCRED, &bp);
@


1.16
log
@- remove statement after panic(), it won't be reached.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.15 2008/01/05 19:49:26 otto Exp $	*/
a62 1
	int32_t nb;
d66 1
a66 1
	int32_t newb, lbn, *bap, pref;
d71 1
@


1.15
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.14 2007/06/02 00:45:50 pedro Exp $	*/
a267 1
				brelse(bp);
@


1.14
log
@ufs1_daddr_t cleanup, okay thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.13 2003/06/02 23:28:22 millert Exp $	*/
d59 1
a59 1
ext2fs_buf_alloc(struct inode *ip, daddr_t bn, int size, struct ucred *cred, 
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.12 2003/05/26 18:33:16 tedu Exp $	*/
d63 1
a63 1
	ufs1_daddr_t nb;
d67 1
a67 1
	ufs1_daddr_t newb, lbn, *bap, pref;
d70 1
a70 1
	ufs1_daddr_t *allocib, *blkp, *allocblk, allociblk[NIADDR + 1];
d131 1
a131 1
		pref = ext2fs_blkpref(ip, lbn, 0, (ufs1_daddr_t *)0);
d162 1
a162 1
		bap = (ufs1_daddr_t *)bp->b_data;
d171 1
a171 1
		pref = ext2fs_blkpref(ip, lbn, 0, (ufs1_daddr_t *)0);
d270 1
a270 1
				bap = (ufs1_daddr_t *)bp->b_data;
@


1.12
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.11 2001/12/19 08:58:07 art Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.7 2001/11/06 19:53:21 miod Exp $	*/
d67 1
a67 1
	ufs_daddr_t nb;
d71 1
a71 1
	ufs_daddr_t newb, lbn, *bap, pref;
d74 1
a74 1
	ufs_daddr_t *allocib, *blkp, *allocblk, allociblk[NIADDR + 1];
d135 1
a135 1
		pref = ext2fs_blkpref(ip, lbn, 0, (ufs_daddr_t *)0);
d166 1
a166 1
		bap = (ufs_daddr_t *)bp->b_data;
d175 1
a175 1
		pref = ext2fs_blkpref(ip, lbn, 0, (ufs_daddr_t *)0);
d274 1
a274 1
				bap = (ufs_daddr_t *)bp->b_data;
@


1.10
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 2
a2 1
/*	$NetBSD: ext2fs_balloc.c,v 1.8 2000/12/10 06:38:31 chs Exp $	*/
a46 1
#include <sys/mount.h>
d48 1
a48 1
#include <uvm/uvm.h>
a75 1
	UVMHIST_FUNC("ext2fs_buf_alloc"); UVMHIST_CALLED(ubchist);
d77 1
a77 5
	UVMHIST_LOG(ubchist, "bn 0x%x", bn,0,0,0);

	if (bpp != NULL) {
		*bpp = NULL;
	}
d89 4
a92 13

			/*
			 * the block is already allocated, just read it.
			 */

			if (bpp != NULL) {
				error = bread(vp, bn, fs->e2fs_bsize, NOCRED,
					      &bp);
				if (error) {
					brelse(bp);
					return (error);
				}
				*bpp = bp;
d94 1
a100 1

d102 1
a102 1
		    ext2fs_blkpref(ip, bn, bn, &ip->i_e2fs_blocks[0]),
d110 5
a114 7
		if (bpp != NULL) {
			bp = getblk(vp, bn, fs->e2fs_bsize, 0, 0);
			bp->b_blkno = fsbtodb(fs, newb);
			if (flags & B_CLRBUF)
				clrbuf(bp);
			*bpp = bp;
		}
d232 5
a236 7
		if (bpp != NULL) {
			nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
			if (flags & B_CLRBUF)
				clrbuf(nbp);
			*bpp = nbp;
		}
d240 5
a244 11
	if (bpp != NULL) {
		if (flags & B_CLRBUF) {
			error = bread(vp, lbn, (int)fs->e2fs_bsize, NOCRED,
				      &nbp);
			if (error) {
				brelse(nbp);
				goto fail;
			}
		} else {
			nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
d246 3
a248 1
		*bpp = nbp;
d250 2
a293 139
}

int
ext2fs_gop_alloc(struct vnode *vp, off_t off, off_t len, int flags,
    struct ucred *cred)
{
	struct inode *ip = VTOI(vp);
	struct m_ext2fs *fs = ip->i_e2fs;
	int error, delta, bshift, bsize;
	UVMHIST_FUNC("ext2fs_gop_alloc"); UVMHIST_CALLED(ubchist);

	bshift = fs->e2fs_bshift;
	bsize = 1 << bshift;

	delta = off & (bsize - 1);
	off -= delta;
	len += delta;

	while (len > 0) {
		bsize = min(bsize, len);
		UVMHIST_LOG(ubchist, "off 0x%x len 0x%x bsize 0x%x",
			    off, len, bsize, 0);

		error = ext2fs_buf_alloc(ip, lblkno(fs, off), bsize, cred,
		    NULL, flags);
		if (error) {
			UVMHIST_LOG(ubchist, "error %d", error, 0,0,0);
			return error;
		}

		/*
		 * increase file size now, VOP_BALLOC() requires that
		 * EOF be up-to-date before each call.
		 */

		if (ip->i_e2fs_size < off + bsize) {
			UVMHIST_LOG(ubchist, "old 0x%x new 0x%x",
				    ip->i_e2fs_size, off + bsize,0,0);
			ip->i_e2fs_size = off + bsize;
			if (vp->v_size < ip->i_e2fs_size) {
				uvm_vnp_setsize(vp, ip->i_e2fs_size);
			}
		}

		off += bsize;
		len -= bsize;
	}
	return 0;
}

/*
 * allocate a range of blocks in a file.
 * after this function returns, any page entirely contained within the range
 * will map to invalid data and thus must be overwritten before it is made
 * accessible to others.
 */

int
ext2fs_balloc_range(vp, off, len, cred, flags)
	struct vnode *vp;
	off_t off, len;
	struct ucred *cred;
	int flags;
{
	off_t oldeof, eof, pagestart;
	struct uvm_object *uobj;
	struct genfs_node *gp = VTOG(vp);
	int i, delta, error, npages;
	int bshift = vp->v_mount->mnt_fs_bshift;
	int bsize = 1 << bshift;
	int ppb = max(bsize >> PAGE_SHIFT, 1);
	struct vm_page *pgs[ppb];
	UVMHIST_FUNC("ext2fs_balloc_range"); UVMHIST_CALLED(ubchist);
	UVMHIST_LOG(ubchist, "vp %p off 0x%x len 0x%x u_size 0x%x",
		    vp, off, len, vp->v_size);

	error = 0;
	uobj = &vp->v_uobj;
	oldeof = vp->v_size;
	eof = max(oldeof, off + len);
	UVMHIST_LOG(ubchist, "new eof 0x%x", eof,0,0,0);
	pgs[0] = NULL;

	/*
	 * cache the new range of the file.  this will create zeroed pages
	 * where the new block will be and keep them locked until the
	 * new block is allocated, so there will be no window where
	 * the old contents of the new block is visible to racing threads.
	 */

	pagestart = trunc_page(off) & ~(bsize - 1);
	npages = min(ppb, (round_page(eof) - pagestart) >> PAGE_SHIFT);
	memset(pgs, 0, npages);
	simple_lock(&uobj->vmobjlock);
	error = VOP_GETPAGES(vp, pagestart, pgs, &npages, 0,
	    VM_PROT_READ, 0, PGO_SYNCIO | PGO_PASTEOF);
	if (error) {
		UVMHIST_LOG(ubchist, "getpages %d", error,0,0,0);
		goto errout;
	}
	for (i = 0; i < npages; i++) {
		UVMHIST_LOG(ubchist, "got pgs[%d] %p", i, pgs[i],0,0);
		KASSERT((pgs[i]->flags & PG_RELEASED) == 0);
		pgs[i]->flags &= ~PG_CLEAN;
		uvm_pageactivate(pgs[i]);
	}

	/*
	 * adjust off to be block-aligned.
	 */

	delta = off & (bsize - 1);
	off -= delta;
	len += delta;

	/*
	 * now allocate the range.
	 */

	lockmgr(&gp->g_glock, LK_EXCLUSIVE, NULL, curproc);
	error = GOP_ALLOC(vp, off, len, flags, cred);
	UVMHIST_LOG(ubchist, "alloc %d", error,0,0,0);
	lockmgr(&gp->g_glock, LK_RELEASE, NULL, curproc);

	/*
	 * unbusy any pages we are holding.
	 */

errout:
	simple_lock(&uobj->vmobjlock);
	if (error) {
		(void) (uobj->pgops->pgo_flush)(uobj, oldeof, pagestart + ppb,
		    PGO_FREE);
	}
	if (pgs[0] != NULL) {
		uvm_page_unbusy(pgs, npages);
	}
	simple_unlock(&uobj->vmobjlock);
	return (error);
@


1.10.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d445 1
a445 1
		(void) (uobj->pgops->pgo_put)(uobj, oldeof, pagestart + ppb,
a446 1
		simple_lock(&uobj->vmobjlock);
@


1.9
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d317 2
a318 2
ext2fs_ballocn(v)
	void *v;
a319 9
	struct vop_ballocn_args /* {
		struct vnode *a_vp;
		off_t a_offset;
		off_t a_length;
		struct ucred *a_cred;
		int a_flags;
	} */ *ap = v;
	off_t off, len;
	struct vnode *vp = ap->a_vp;
d323 1
a323 1
	UVMHIST_FUNC("ext2fs_ballocn"); UVMHIST_CALLED(ubchist);
a327 3
	off = ap->a_offset;
	len = ap->a_length;

d337 2
a338 2
		error = ext2fs_buf_alloc(ip, lblkno(fs, off), bsize, ap->a_cred,
		    NULL, ap->a_flags);
d380 1
d433 4
a436 4
	lockmgr(&vp->v_glock, LK_EXCLUSIVE, NULL, curproc);
	error = VOP_BALLOCN(vp, off, len, cred, flags);
	UVMHIST_LOG(ubchist, "ballocn %d", error,0,0,0);
	lockmgr(&vp->v_glock, LK_RELEASE, NULL, curproc);
@


1.8
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d365 1
a365 1
			if (vp->v_uvm.u_size < ip->i_e2fs_size) {
d399 1
a399 1
		    vp, off, len, vp->v_uvm.u_size);
d402 2
a403 2
	uobj = &vp->v_uvm.u_obj;
	oldeof = vp->v_uvm.u_size;
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 2
/*	$OpenBSD: ext2fs_balloc.c,v 1.6 2001/09/17 23:31:39 art Exp $	*/
/*	$NetBSD: ext2fs_balloc.c,v 1.10 2001/07/04 21:16:01 chs Exp $	*/
d46 1
d48 1
a48 1
#include <uvm/uvm_extern.h>
d76 1
d78 5
a82 1
	*bpp = NULL;
d94 13
a106 4
			error = bread(vp, bn, fs->e2fs_bsize, NOCRED, &bp);
			if (error) {
				brelse(bp);
				return (error);
a107 1
			*bpp = bp;
d114 1
d116 1
a116 1
		    ext2fs_blkpref(ip, bn, (int)bn, &ip->i_e2fs_blocks[0]),
d124 7
a130 5
		bp = getblk(vp, bn, fs->e2fs_bsize, 0, 0);
		bp->b_blkno = fsbtodb(fs, newb);
		if (flags & B_CLRBUF)
			clrbuf(bp);
		*bpp = bp;
d248 7
a254 5
		nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		if (flags & B_CLRBUF)
			clrbuf(nbp);
		*bpp = nbp;
d258 11
a268 5
	if (flags & B_CLRBUF) {
		error = bread(vp, lbn, (int)fs->e2fs_bsize, NOCRED, &nbp);
		if (error) {
			brelse(nbp);
			goto fail;
d270 1
a270 3
	} else {
		nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
a271 2

	*bpp = nbp;
d314 150
@


1.6
log
@Some changes from NetBSD. Some cosmetic, some endianness fixes.
Plus the unwinding code that undoes allocation if a part of it fails
originally from ufs and FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.5 2001/06/23 02:07:50 csapuntz Exp $	*/
d48 1
a48 1
#include <vm/vm.h>
@


1.5
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_balloc.c,v 1.4 1999/01/11 05:12:36 millert Exp $	*/
/*	$NetBSD: ext2fs_balloc.c,v 1.1 1997/06/11 09:33:44 bouyer Exp $	*/
d67 1
a67 1
	daddr_t nb;
d71 1
a71 1
	daddr_t newb, lbn, *bap, pref;
d73 3
d87 1
a87 1
		nb = ip->i_e2fs_blocks[bn];
a95 12
		} else {
			error = ext2fs_alloc(ip, bn,
				ext2fs_blkpref(ip, bn, (int)bn, &ip->i_e2fs_blocks[0]),
				cred, &newb);
			if (error)
				return (error);
			ip->i_e2fs_last_lblk = lbn;
			ip->i_e2fs_last_blk = newb;
			bp = getblk(vp, bn, fs->e2fs_bsize, 0, 0);
			bp->b_blkno = fsbtodb(fs, newb);
			if (flags & B_CLRBUF)
				clrbuf(bp);
d97 12
a108 1
		ip->i_e2fs_blocks[bn] = dbtofsb(fs, bp->b_blkno);
d110 4
d131 3
a133 1
	nb = ip->i_e2fs_blocks[NDADDR + indirs[0].in_off];
d135 2
a136 3
		pref = ext2fs_blkpref(ip, lbn, 0, (daddr_t *)0);
			error = ext2fs_alloc(ip, lbn, pref,
				  cred, &newb);
d140 1
d149 5
a153 5
		if ((error = bwrite(bp)) != 0) {
			ext2fs_blkfree(ip, nb);
			return (error);
		}
		ip->i_e2fs_blocks[NDADDR + indirs[0].in_off] = newb;
d161 1
a161 1
			indirs[i].in_lbn, (int)fs->e2fs_bsize, NOCRED, &bp);
d164 1
a164 1
			return (error);
d166 2
a167 2
		bap = (daddr_t *)bp->b_data;
		nb = bap[indirs[i].in_off];
d170 1
a170 1
		i += 1;
d175 2
a176 3
		pref = ext2fs_blkpref(ip, lbn, 0, (daddr_t *)0);
		error = ext2fs_alloc(ip, lbn, pref, cred,
				  &newb);
d179 1
a179 1
			return (error);
d182 1
a191 1
			ext2fs_blkfree(ip, nb);
d193 1
a193 1
			return (error);
d195 3
a197 1
		bap[indirs[i - 1].in_off] = nb;
d212 2
a213 3
		pref = ext2fs_blkpref(ip, lbn, indirs[i].in_off, &bap[0]);
		error = ext2fs_alloc(ip, lbn, pref, cred,
				  &newb);
d216 1
a216 1
			return (error);
d219 1
d222 1
a222 5
		nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		if (flags & B_CLRBUF)
			clrbuf(nbp);
		bap[indirs[i].in_off] = nb;
d232 4
d244 1
a244 1
			return (error);
d250 1
d253 41
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.3 1997/06/12 21:09:31 downsj Exp $	*/
d63 2
a64 7
ext2fs_balloc(ip, bn, size, cred, bpp, flags)
	register struct inode *ip;
	register daddr_t bn;
	int size;
	struct ucred *cred;
	struct buf **bpp;
	int flags;
d66 2
a67 2
	register struct m_ext2fs *fs;
	register daddr_t nb;
@


1.4.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.4 1999/01/11 05:12:36 millert Exp $	*/
d63 7
a69 2
ext2fs_buf_alloc(struct inode *ip, daddr_t bn, int size, struct ucred *cred, 
    struct buf **bpp, int flags)
d71 2
a72 2
	struct m_ext2fs *fs;
	daddr_t nb;
@


1.4.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_balloc.c,v 1.4.6.1 2001/07/04 11:00:41 niklas Exp $	*/
/*	$NetBSD: ext2fs_balloc.c,v 1.10 2001/07/04 21:16:01 chs Exp $	*/
d67 1
a67 1
	ufs_daddr_t nb;
d71 1
a71 1
	ufs_daddr_t newb, lbn, *bap, pref;
a72 3
	u_int deallocated;
	ufs_daddr_t *allocib, *blkp, *allocblk, allociblk[NIADDR + 1];
	int unwindidx = -1;
d84 1
a84 1
		nb = fs2h32(ip->i_e2fs_blocks[bn]);
d93 12
d106 1
a106 12

		/*
		 * allocate a new direct block.
		 */
		error = ext2fs_alloc(ip, bn,
		    ext2fs_blkpref(ip, bn, (int)bn, &ip->i_e2fs_blocks[0]),
		    cred, &newb);
		if (error)
			return (error);
		ip->i_e2fs_last_lblk = lbn;
		ip->i_e2fs_last_blk = newb;
		ip->i_e2fs_blocks[bn] = h2fs32(newb);
a107 4
		bp = getblk(vp, bn, fs->e2fs_bsize, 0, 0);
		bp->b_blkno = fsbtodb(fs, newb);
		if (flags & B_CLRBUF)
			clrbuf(bp);
d125 1
a125 3
	nb = fs2h32(ip->i_e2fs_blocks[NDADDR + indirs[0].in_off]);
	allocib = NULL;
	allocblk = allociblk;
d127 3
a129 2
		pref = ext2fs_blkpref(ip, lbn, 0, (ufs_daddr_t *)0);
		error = ext2fs_alloc(ip, lbn, pref, cred, &newb);
a132 1
		*allocblk++ = nb;
d141 5
a145 5
		if ((error = bwrite(bp)) != 0)
			goto fail;
		unwindidx = 0;
		allocib = &ip->i_e2fs_blocks[NDADDR + indirs[0].in_off];
		*allocib = h2fs32(newb);
d153 1
a153 1
		    indirs[i].in_lbn, (int)fs->e2fs_bsize, NOCRED, &bp);
d156 1
a156 1
			goto fail;
d158 2
a159 2
		bap = (ufs_daddr_t *)bp->b_data;
		nb = fs2h32(bap[indirs[i].in_off]);
d162 1
a162 1
		i++;
d167 3
a169 2
		pref = ext2fs_blkpref(ip, lbn, 0, (ufs_daddr_t *)0);
		error = ext2fs_alloc(ip, lbn, pref, cred, &newb);
d172 1
a172 1
			goto fail;
a174 1
		*allocblk++ = nb;
d184 1
d186 1
a186 1
			goto fail;
d188 1
a188 3
		if (unwindidx < 0)
			unwindidx = i - 1;
		bap[indirs[i - 1].in_off] = h2fs32(nb);
d203 3
a205 2
		pref = ext2fs_blkpref(ip, lbn, indirs[num].in_off, &bap[0]);
		error = ext2fs_alloc(ip, lbn, pref, cred, &newb);
d208 1
a208 1
			goto fail;
a210 1
		*allocblk++ = nb;
d213 5
a217 1
		bap[indirs[num].in_off] = h2fs32(nb);
a226 4
		nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		if (flags & B_CLRBUF)
			clrbuf(nbp);
d235 1
a235 1
			goto fail;
a240 1

a242 41
fail:
	/*
	 * If we have failed part way through block allocation, we
	 * have to deallocate any indirect blocks that we have allocated.
	 */
	for (deallocated = 0, blkp = allociblk; blkp < allocblk; blkp++) {
		ext2fs_blkfree(ip, *blkp);
		deallocated += fs->e2fs_bsize;
	}
	if (unwindidx >= 0) {
		if (unwindidx == 0) {
			*allocib = 0;
		} else {
			int r;
	
			r = bread(vp, indirs[unwindidx].in_lbn, 
			    (int)fs->e2fs_bsize, NOCRED, &bp);
			if (r) {
				panic("Could not unwind indirect block, error %d", r);
				brelse(bp);
			} else {
				bap = (ufs_daddr_t *)bp->b_data;
				bap[indirs[unwindidx].in_off] = 0;
				if (flags & B_SYNC)
					bwrite(bp);
				else
					bdwrite(bp);
			}
		}
		for (i = unwindidx + 1; i <= num; i++) {
			bp = getblk(vp, indirs[i].in_lbn, (int)fs->e2fs_bsize,
			    0, 0);
			bp->b_flags |= B_INVAL;
			brelse(bp);
		}
	}
	if (deallocated) {
		ip->i_e2fs_nblock -= btodb(deallocated);
		ip->i_e2fs_flags |= IN_CHANGE | IN_UPDATE;
	}
	return error;
@


1.4.6.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#include <uvm/uvm_extern.h>
@


1.4.6.4
log
@Merge in -current
@
text
@d1 2
a2 1
/*	$NetBSD: ext2fs_balloc.c,v 1.8 2000/12/10 06:38:31 chs Exp $	*/
a46 1
#include <sys/mount.h>
d48 1
a48 1
#include <uvm/uvm.h>
a75 1
	UVMHIST_FUNC("ext2fs_buf_alloc"); UVMHIST_CALLED(ubchist);
d77 1
a77 5
	UVMHIST_LOG(ubchist, "bn 0x%x", bn,0,0,0);

	if (bpp != NULL) {
		*bpp = NULL;
	}
d89 4
a92 13

			/*
			 * the block is already allocated, just read it.
			 */

			if (bpp != NULL) {
				error = bread(vp, bn, fs->e2fs_bsize, NOCRED,
					      &bp);
				if (error) {
					brelse(bp);
					return (error);
				}
				*bpp = bp;
d94 1
a100 1

d102 1
a102 1
		    ext2fs_blkpref(ip, bn, bn, &ip->i_e2fs_blocks[0]),
d110 5
a114 7
		if (bpp != NULL) {
			bp = getblk(vp, bn, fs->e2fs_bsize, 0, 0);
			bp->b_blkno = fsbtodb(fs, newb);
			if (flags & B_CLRBUF)
				clrbuf(bp);
			*bpp = bp;
		}
d232 5
a236 7
		if (bpp != NULL) {
			nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
			if (flags & B_CLRBUF)
				clrbuf(nbp);
			*bpp = nbp;
		}
d240 5
a244 11
	if (bpp != NULL) {
		if (flags & B_CLRBUF) {
			error = bread(vp, lbn, (int)fs->e2fs_bsize, NOCRED,
				      &nbp);
			if (error) {
				brelse(nbp);
				goto fail;
			}
		} else {
			nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
d246 3
a248 1
		*bpp = nbp;
d250 2
a293 150
}

int
ext2fs_ballocn(v)
	void *v;
{
	struct vop_ballocn_args /* {
		struct vnode *a_vp;
		off_t a_offset;
		off_t a_length;
		struct ucred *a_cred;
		int a_flags;
	} */ *ap = v;
	off_t off, len;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct m_ext2fs *fs = ip->i_e2fs;
	int error, delta, bshift, bsize;
	UVMHIST_FUNC("ext2fs_ballocn"); UVMHIST_CALLED(ubchist);

	bshift = fs->e2fs_bshift;
	bsize = 1 << bshift;

	off = ap->a_offset;
	len = ap->a_length;

	delta = off & (bsize - 1);
	off -= delta;
	len += delta;

	while (len > 0) {
		bsize = min(bsize, len);
		UVMHIST_LOG(ubchist, "off 0x%x len 0x%x bsize 0x%x",
			    off, len, bsize, 0);

		error = ext2fs_buf_alloc(ip, lblkno(fs, off), bsize, ap->a_cred,
		    NULL, ap->a_flags);
		if (error) {
			UVMHIST_LOG(ubchist, "error %d", error, 0,0,0);
			return error;
		}

		/*
		 * increase file size now, VOP_BALLOC() requires that
		 * EOF be up-to-date before each call.
		 */

		if (ip->i_e2fs_size < off + bsize) {
			UVMHIST_LOG(ubchist, "old 0x%x new 0x%x",
				    ip->i_e2fs_size, off + bsize,0,0);
			ip->i_e2fs_size = off + bsize;
			if (vp->v_uvm.u_size < ip->i_e2fs_size) {
				uvm_vnp_setsize(vp, ip->i_e2fs_size);
			}
		}

		off += bsize;
		len -= bsize;
	}
	return 0;
}

/*
 * allocate a range of blocks in a file.
 * after this function returns, any page entirely contained within the range
 * will map to invalid data and thus must be overwritten before it is made
 * accessible to others.
 */

int
ext2fs_balloc_range(vp, off, len, cred, flags)
	struct vnode *vp;
	off_t off, len;
	struct ucred *cred;
	int flags;
{
	off_t oldeof, eof, pagestart;
	struct uvm_object *uobj;
	int i, delta, error, npages;
	int bshift = vp->v_mount->mnt_fs_bshift;
	int bsize = 1 << bshift;
	int ppb = max(bsize >> PAGE_SHIFT, 1);
	struct vm_page *pgs[ppb];
	UVMHIST_FUNC("ext2fs_balloc_range"); UVMHIST_CALLED(ubchist);
	UVMHIST_LOG(ubchist, "vp %p off 0x%x len 0x%x u_size 0x%x",
		    vp, off, len, vp->v_uvm.u_size);

	error = 0;
	uobj = &vp->v_uvm.u_obj;
	oldeof = vp->v_uvm.u_size;
	eof = max(oldeof, off + len);
	UVMHIST_LOG(ubchist, "new eof 0x%x", eof,0,0,0);
	pgs[0] = NULL;

	/*
	 * cache the new range of the file.  this will create zeroed pages
	 * where the new block will be and keep them locked until the
	 * new block is allocated, so there will be no window where
	 * the old contents of the new block is visible to racing threads.
	 */

	pagestart = trunc_page(off) & ~(bsize - 1);
	npages = min(ppb, (round_page(eof) - pagestart) >> PAGE_SHIFT);
	memset(pgs, 0, npages);
	simple_lock(&uobj->vmobjlock);
	error = VOP_GETPAGES(vp, pagestart, pgs, &npages, 0,
	    VM_PROT_READ, 0, PGO_SYNCIO | PGO_PASTEOF);
	if (error) {
		UVMHIST_LOG(ubchist, "getpages %d", error,0,0,0);
		goto errout;
	}
	for (i = 0; i < npages; i++) {
		UVMHIST_LOG(ubchist, "got pgs[%d] %p", i, pgs[i],0,0);
		KASSERT((pgs[i]->flags & PG_RELEASED) == 0);
		pgs[i]->flags &= ~PG_CLEAN;
		uvm_pageactivate(pgs[i]);
	}

	/*
	 * adjust off to be block-aligned.
	 */

	delta = off & (bsize - 1);
	off -= delta;
	len += delta;

	/*
	 * now allocate the range.
	 */

	lockmgr(&vp->v_glock, LK_EXCLUSIVE, NULL, curproc);
	error = VOP_BALLOCN(vp, off, len, cred, flags);
	UVMHIST_LOG(ubchist, "ballocn %d", error,0,0,0);
	lockmgr(&vp->v_glock, LK_RELEASE, NULL, curproc);

	/*
	 * unbusy any pages we are holding.
	 */

errout:
	simple_lock(&uobj->vmobjlock);
	if (error) {
		(void) (uobj->pgops->pgo_flush)(uobj, oldeof, pagestart + ppb,
		    PGO_FREE);
	}
	if (pgs[0] != NULL) {
		uvm_page_unbusy(pgs, npages);
	}
	simple_unlock(&uobj->vmobjlock);
	return (error);
@


1.4.6.5
log
@Merge in trunk
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: ext2fs_balloc.c,v 1.10 2001/07/04 21:16:01 chs Exp $	*/
d46 1
d48 1
a48 1
#include <uvm/uvm_extern.h>
d76 1
d78 5
a82 1
	*bpp = NULL;
d94 13
a106 4
			error = bread(vp, bn, fs->e2fs_bsize, NOCRED, &bp);
			if (error) {
				brelse(bp);
				return (error);
a107 1
			*bpp = bp;
d114 1
d116 1
a116 1
		    ext2fs_blkpref(ip, bn, (int)bn, &ip->i_e2fs_blocks[0]),
d124 7
a130 5
		bp = getblk(vp, bn, fs->e2fs_bsize, 0, 0);
		bp->b_blkno = fsbtodb(fs, newb);
		if (flags & B_CLRBUF)
			clrbuf(bp);
		*bpp = bp;
d248 7
a254 5
		nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		if (flags & B_CLRBUF)
			clrbuf(nbp);
		*bpp = nbp;
d258 11
a268 5
	if (flags & B_CLRBUF) {
		error = bread(vp, lbn, (int)fs->e2fs_bsize, NOCRED, &nbp);
		if (error) {
			brelse(nbp);
			goto fail;
d270 1
a270 3
	} else {
		nbp = getblk(vp, lbn, fs->e2fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
a271 2

	*bpp = nbp;
d314 150
@


1.4.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.4.6.5 2002/03/06 02:17:13 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
d67 1
a67 1
	ufs1_daddr_t nb;
d71 1
a71 1
	ufs1_daddr_t newb, lbn, *bap, pref;
d74 1
a74 1
	ufs1_daddr_t *allocib, *blkp, *allocblk, allociblk[NIADDR + 1];
d135 1
a135 1
		pref = ext2fs_blkpref(ip, lbn, 0, (ufs1_daddr_t *)0);
d166 1
a166 1
		bap = (ufs1_daddr_t *)bp->b_data;
d175 1
a175 1
		pref = ext2fs_blkpref(ip, lbn, 0, (ufs1_daddr_t *)0);
d274 1
a274 1
				bap = (ufs1_daddr_t *)bp->b_data;
@


1.3
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_balloc.c,v 1.2 1997/05/30 08:33:39 downsj Exp $	*/
d124 1
a124 1
		panic ("ext2fs_balloc: ufs_getlbns returned indirect block\n");
@


1.2
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 2
a2 4
/*	$OpenBSD$	*/
/*	$NetBSD: ffs_balloc.c,v 1.3 1996/02/09 22:22:21 christos Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d5 1
d38 1
d100 2
a101 2
			    ext2fs_blkpref(ip, bn, (int)bn, &ip->i_e2fs_blocks[0]),
			    cred, &newb);
d133 1
a133 1
	        error = ext2fs_alloc(ip, lbn, pref,
d158 1
a158 1
		    indirs[i].in_lbn, (int)fs->e2fs_bsize, NOCRED, &bp);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@
