head	1.36;
access;
symbols
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.6
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.2
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.27.0.6
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.14
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.12
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.8
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.20.0.6
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.06.03.18.00.10;	author natano;	state Exp;
branches;
next	1.35;
commitid	U9Tuk3fIFh5Jjh7C;

1.35
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.34;
commitid	p4LJxGKbi0BU2cG6;

1.34
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.33;
commitid	uzzBR7hz9ncd4O6G;

1.33
date	2014.07.14.08.54.13;	author pelikan;	state Exp;
branches;
next	1.32;
commitid	5pxoUiNNvSjZa1j9;

1.32
date	2014.07.13.16.59.35;	author pelikan;	state Exp;
branches;
next	1.31;
commitid	zGe0z6RRYbZJpA8u;

1.31
date	2014.05.27.14.31.24;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2013.12.12.19.00.09;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.18.23.20.28;	author bluhm;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.22.09.55.17;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.17.20.15.25;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.02.00.45.50;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.14.13.56.42;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.11.20.46.28;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.03.20.14.01;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.02.13.13.21;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.18.22.01.18;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.25.23.26.55;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.06.05.24.16;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.16.13;	author millert;	state Exp;
branches
	1.9.4.1
	1.9.6.1;
next	1.8;

1.8
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.17.23.25.04;	author art;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.06.23.02.07.50;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.23.24.40;	author jasoni;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.12.35;	author millert;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.06.12.21.09.31;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.05.30.08.33.36;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.4.6.1
date	2001.05.14.22.47.39;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.07.04.11.00.41;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.4.6.5;

1.4.6.5
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.4.6.6;

1.4.6.6
date	2004.02.19.11.01.35;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.32.49;	author art;	state Exp;
branches;
next	;

1.9.4.1
date	2003.08.03.23.18.51;	author brad;	state Exp;
branches;
next	;

1.9.6.1
date	2003.07.16.18.17.26;	author brad;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Unsigned integers can't be negative.
from David Hill and mmcc@@
ok stefan
@
text
@/*	$OpenBSD: ext2fs_alloc.c,v 1.35 2015/03/14 03:38:52 jsg Exp $	*/
/*	$NetBSD: ext2fs_alloc.c,v 1.10 2001/07/05 08:38:27 toshii Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_alloc.c	8.11 (Berkeley) 10/27/94
 *  Modified for ext2fs by Manuel Bouyer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/syslog.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ext2fs/ext2fs_extern.h>

u_long ext2gennumber;

static u_int32_t	ext2fs_alloccg(struct inode *, int, u_int32_t, int);
static int		ext2fs_dirpref(struct m_ext2fs *);
static void		ext2fs_fserr(struct m_ext2fs *, uid_t, char *);
static u_int32_t	ext2fs_hashalloc(struct inode *, int, u_int32_t, int,
			    u_int32_t (*)(struct inode *, int, u_int32_t, int));
static ufsino_t		ext2fs_nodealloccg(struct inode *, int, ufsino_t, int);
static u_int32_t	ext2fs_mapsearch(struct m_ext2fs *, char *, u_int32_t);

/*
 * Allocate a block in the file system.
 *
 * A preference may be optionally specified. If a preference is given
 * the following hierarchy is used to allocate a block:
 *   1) allocate the requested block.
 *   2) allocate a rotationally optimal block in the same cylinder.
 *   3) allocate a block in the same cylinder group.
 *   4) quadratically rehash into other cylinder groups, until an
 *	  available block is located.
 * If no block preference is given the following hierarchy is used
 * to allocate a block:
 *   1) allocate a block in the cylinder group that contains the
 *	  inode for the file.
 *   2) quadratically rehash into other cylinder groups, until an
 *	  available block is located.
 */
int
ext2fs_alloc(struct inode *ip, u_int32_t lbn, u_int32_t bpref,
    struct ucred *cred, u_int32_t *bnp)
{
	struct m_ext2fs *fs;
	u_int32_t bno;
	int cg;

	*bnp = 0;
	fs = ip->i_e2fs;
#ifdef DIAGNOSTIC
	if (cred == NOCRED)
		panic("ext2fs_alloc: missing credential");
#endif /* DIAGNOSTIC */
	if (fs->e2fs.e2fs_fbcount == 0)
		goto nospace;
	if (cred->cr_uid != 0 && freespace(fs) <= 0)
		goto nospace;
	if (bpref >= fs->e2fs.e2fs_bcount)
		bpref = 0;
	if (bpref == 0)
		cg = ino_to_cg(fs, ip->i_number);
	else
		cg = dtog(fs, bpref);
	bno = ext2fs_hashalloc(ip, cg, bpref, fs->e2fs_bsize, ext2fs_alloccg);
	if (bno > 0) {
		ip->i_e2fs_nblock += btodb(fs->e2fs_bsize);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		*bnp = bno;
		return (0);
	}
nospace:
	ext2fs_fserr(fs, cred->cr_uid, "file system full");
	uprintf("\n%s: write failed, file system is full\n", fs->e2fs_fsmnt);
	return (ENOSPC);
}

/*
 * Allocate an inode in the file system.
 *
 * If allocating a directory, use ext2fs_dirpref to select the inode.
 * If allocating in a directory, the following hierarchy is followed:
 *   1) allocate the preferred inode.
 *   2) allocate an inode in the same cylinder group.
 *   3) quadratically rehash into other cylinder groups, until an
 *	  available inode is located.
 * If no inode preference is given the following hierarchy is used
 * to allocate an inode:
 *   1) allocate an inode in cylinder group 0.
 *   2) quadratically rehash into other cylinder groups, until an
 *	  available inode is located.
 */
int
ext2fs_inode_alloc(struct inode *pip, mode_t mode, struct ucred *cred,
    struct vnode **vpp)
{
	struct vnode *pvp;
	struct m_ext2fs *fs;
	struct inode *ip;
	ufsino_t ino, ipref;
	int cg, error;

	*vpp = NULL;
	pvp = ITOV(pip);
	fs = pip->i_e2fs;
	if (fs->e2fs.e2fs_ficount == 0)
		goto noinodes;

	if ((mode & IFMT) == IFDIR)
		cg = ext2fs_dirpref(fs);
	else
		cg = ino_to_cg(fs, pip->i_number);
	ipref = cg * fs->e2fs.e2fs_ipg + 1;
	ino = ext2fs_hashalloc(pip, cg, ipref, mode, ext2fs_nodealloccg);
	if (ino == 0)
		goto noinodes;
	error = VFS_VGET(pvp->v_mount, ino, vpp);
	if (error) {
		ext2fs_inode_free(pip, ino, mode);
		return (error);
	}
	ip = VTOI(*vpp);
	if (ip->i_e2fs_mode && ip->i_e2fs_nlink != 0) {
		printf("mode = 0%o, nlinks %u, inum = %u, fs = %s\n",
		    ip->i_e2fs_mode, ip->i_e2fs_nlink, ip->i_number,
		    fs->e2fs_fsmnt);
		panic("ext2fs_valloc: dup alloc");
	}

	memset(ip->i_e2din, 0, sizeof(struct ext2fs_dinode));

	/*
	 * Set up a new generation number for this inode.
	 */
	if (++ext2gennumber < (u_long)time_second)
		ext2gennumber = time_second;
	ip->i_e2fs_gen = ext2gennumber;
	return (0);
 noinodes:
	ext2fs_fserr(fs, cred->cr_uid, "out of inodes");
	uprintf("\n%s: create/symlink failed, no inodes free\n", fs->e2fs_fsmnt);
	return (ENOSPC);
}

/*
 * Find a cylinder to place a directory.
 *
 * The policy implemented by this algorithm is to select from
 * among those cylinder groups with above the average number of
 * free inodes, the one with the smallest number of directories.
 */
static int
ext2fs_dirpref(struct m_ext2fs *fs)
{
	int cg, maxspace, mincg, avgifree;

	avgifree = fs->e2fs.e2fs_ficount / fs->e2fs_ncg;
	maxspace = 0;
	mincg = -1;
	for (cg = 0; cg < fs->e2fs_ncg; cg++)
		if ( fs->e2fs_gd[cg].ext2bgd_nifree >= avgifree) {
			if (mincg == -1 || fs->e2fs_gd[cg].ext2bgd_nbfree > maxspace) {
				mincg = cg;
				maxspace = fs->e2fs_gd[cg].ext2bgd_nbfree;
			}
		}
	return mincg;
}

/*
 * Select the desired position for the next block in a file.  The file is
 * logically divided into sections. The first section is composed of the
 * direct blocks. Each additional section contains fs_maxbpg blocks.
 *
 * If no blocks have been allocated in the first section, the policy is to
 * request a block in the same cylinder group as the inode that describes
 * the file. Otherwise, the policy is to try to allocate the blocks
 * contigously. The two fields of the ext2 inode extension (see
 * ufs/ufs/inode.h) help this.
 */
daddr_t
ext2fs_blkpref(struct inode *ip, u_int32_t lbn, int baps, u_int32_t *bap)
{
	struct m_ext2fs *fs;
	int cg, i;

	fs = ip->i_e2fs;
	/*
	 * if we are doing contigous lbn allocation, try to alloc blocks
	 * contigously on disk
	 */

	if ( ip->i_e2fs_last_blk && lbn == ip->i_e2fs_last_lblk + 1) {
		return ip->i_e2fs_last_blk + 1;
	}

	/*
	 * bap, if provided, gives us a list of blocks to which we want to
	 * stay close
	 */

	if (bap) {
		for (i = baps; i >= 0 ; i--) {
			if (bap[i]) {
				return letoh32(bap[i]) + 1;
			}
		}
	}

	/* fall back to the first block of the cylinder containing the inode */

	cg = ino_to_cg(fs, ip->i_number);
	return fs->e2fs.e2fs_bpg * cg + fs->e2fs.e2fs_first_dblock + 1;
}

/*
 * Implement the cylinder overflow algorithm.
 *
 * The policy implemented by this algorithm is:
 *   1) allocate the block in its requested cylinder group.
 *   2) quadratically rehash on the cylinder group number.
 *   3) brute force search for a free block.
 */
static u_int32_t
ext2fs_hashalloc(struct inode *ip, int cg, u_int32_t pref, int size,
    u_int32_t (*allocator)(struct inode *, int, u_int32_t, int))
{
	struct m_ext2fs *fs;
	long result;
	int i, icg = cg;

	fs = ip->i_e2fs;
	/*
	 * 1: preferred cylinder group
	 */
	result = (*allocator)(ip, cg, pref, size);
	if (result)
		return (result);
	/*
	 * 2: quadratic rehash
	 */
	for (i = 1; i < fs->e2fs_ncg; i *= 2) {
		cg += i;
		if (cg >= fs->e2fs_ncg)
			cg -= fs->e2fs_ncg;
		result = (*allocator)(ip, cg, 0, size);
		if (result)
			return (result);
	}
	/*
	 * 3: brute force search
	 * Note that we start at i == 2, since 0 was checked initially,
	 * and 1 is always checked in the quadratic rehash.
	 */
	cg = (icg + 2) % fs->e2fs_ncg;
	for (i = 2; i < fs->e2fs_ncg; i++) {
		result = (*allocator)(ip, cg, 0, size);
		if (result)
			return (result);
		cg++;
		if (cg == fs->e2fs_ncg)
			cg = 0;
	}
	return (0);
}

/*
 * Determine whether a block can be allocated.
 *
 * Check to see if a block of the appropriate size is available,
 * and if it is, allocate it.
 */
static u_int32_t
ext2fs_alloccg(struct inode *ip, int cg, u_int32_t bpref, int size)
{
	struct m_ext2fs *fs;
	char *bbp;
	struct buf *bp;
	u_int32_t bno;
	int error, start, end, loc;

	fs = ip->i_e2fs;
	if (fs->e2fs_gd[cg].ext2bgd_nbfree == 0)
		return (0);
	error = bread(ip->i_devvp, fsbtodb(fs,
	    fs->e2fs_gd[cg].ext2bgd_b_bitmap), (int)fs->e2fs_bsize, &bp);
	if (error || fs->e2fs_gd[cg].ext2bgd_nbfree == 0) {
		brelse(bp);
		return (0);
	}
	bbp = (char *)bp->b_data;

	if (dtog(fs, bpref) != cg)
		bpref = 0;
	if (bpref != 0) {
		bpref = dtogd(fs, bpref);
		/*
		 * if the requested block is available, use it
		 */
		if (isclr(bbp, bpref)) {
			bno = bpref;
			goto gotit;
		}
	}
	/*
	 * no blocks in the requested cylinder, so take next
	 * available one in this cylinder group.
	 * first try to get 8 contigous blocks, then fall back to a single
	 * block.
	 */
	if (bpref)
		start = dtogd(fs, bpref) / NBBY;
	else
		start = 0;
	end = howmany(fs->e2fs.e2fs_fpg, NBBY) - start;
	for (loc = start; loc < end; loc++) {
		if (bbp[loc] == 0) {
			bno = loc * NBBY;
			goto gotit;
		}
	}
	for (loc = 0; loc < start; loc++) {
		if (bbp[loc] == 0) {
			bno = loc * NBBY;
			goto gotit;
		}
	}

	bno = ext2fs_mapsearch(fs, bbp, bpref);
 gotit:
#ifdef DIAGNOSTIC
	if (isset(bbp, bno)) {
		panic("%s: dup alloc: cg=%d bno=%u fs=%s\n",
		    __func__, cg, bno, fs->e2fs_fsmnt);
	}
#endif
	setbit(bbp, bno);
	fs->e2fs.e2fs_fbcount--;
	fs->e2fs_gd[cg].ext2bgd_nbfree--;
	fs->e2fs_fmod = 1;
	bdwrite(bp);
	return (cg * fs->e2fs.e2fs_fpg + fs->e2fs.e2fs_first_dblock + bno);
}

/*
 * Determine whether an inode can be allocated.
 *
 * Check to see if an inode is available, and if it is,
 * allocate it using the following policy:
 *   1) allocate the requested inode.
 *   2) allocate the next available inode after the requested
 *	  inode in the specified cylinder group.
 */
static ufsino_t
ext2fs_nodealloccg(struct inode *ip, int cg, ufsino_t ipref, int mode)
{
	struct m_ext2fs *fs;
	char *ibp;
	struct buf *bp;
	int error, start, len, loc, map, i;

	ipref--; /* to avoid a lot of (ipref -1) */
	fs = ip->i_e2fs;
	if (fs->e2fs_gd[cg].ext2bgd_nifree == 0)
		return (0);
	error = bread(ip->i_devvp, fsbtodb(fs,
	    fs->e2fs_gd[cg].ext2bgd_i_bitmap), (int)fs->e2fs_bsize, &bp);
	if (error) {
		brelse(bp);
		return (0);
	}
	ibp = (char *)bp->b_data;
	if (ipref) {
		ipref %= fs->e2fs.e2fs_ipg;
		if (isclr(ibp, ipref))
			goto gotit;
	}
	start = ipref / NBBY;
	len = howmany(fs->e2fs.e2fs_ipg - ipref, NBBY);
	loc = skpc(0xff, len, &ibp[start]);
	if (loc == 0) {
		len = start + 1;
		start = 0;
		loc = skpc(0xff, len, &ibp[0]);
		if (loc == 0) {
			printf("cg = %d, ipref = %u, fs = %s\n",
			    cg, ipref, fs->e2fs_fsmnt);
			panic("ext2fs_nodealloccg: map corrupted");
			/* NOTREACHED */
		}
	}
	i = start + len - loc;
	map = ibp[i];
	ipref = i * NBBY;
	for (i = 1; i < (1 << NBBY); i <<= 1, ipref++) {
		if ((map & i) == 0) {
			goto gotit;
		}
	}
	printf("fs = %s\n", fs->e2fs_fsmnt);
	panic("ext2fs_nodealloccg: block not in map");
	/* NOTREACHED */
 gotit:
	setbit(ibp, ipref);
	fs->e2fs.e2fs_ficount--;
	fs->e2fs_gd[cg].ext2bgd_nifree--;
	fs->e2fs_fmod = 1;
	if ((mode & IFMT) == IFDIR) {
		fs->e2fs_gd[cg].ext2bgd_ndirs++;
	}
	bdwrite(bp);
	return (cg * fs->e2fs.e2fs_ipg + ipref + 1);
}

/*
 * Free a block.
 *
 * The specified block is placed back in the
 * free map.
 */
void
ext2fs_blkfree(struct inode *ip, u_int32_t bno)
{
	struct m_ext2fs *fs;
	char *bbp;
	struct buf *bp;
	int error, cg;

	fs = ip->i_e2fs;
	cg = dtog(fs, bno);
	if (bno >= fs->e2fs.e2fs_bcount) {
		printf("bad block %u, ino %u\n", bno, ip->i_number);
		ext2fs_fserr(fs, ip->i_e2fs_uid, "bad block");
		return;
	}
	error = bread(ip->i_devvp,
	    fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_b_bitmap),
	    (int)fs->e2fs_bsize, &bp);
	if (error) {
		brelse(bp);
		return;
	}
	bbp = (char *)bp->b_data;
	bno = dtogd(fs, bno);
	if (isclr(bbp, bno))
		panic("%s: freeing free block: dev = 0x%x, block = %u, fs = %s\n",
		    __func__, ip->i_dev, bno, fs->e2fs_fsmnt);

	clrbit(bbp, bno);
	fs->e2fs.e2fs_fbcount++;
	fs->e2fs_gd[cg].ext2bgd_nbfree++;

	fs->e2fs_fmod = 1;
	bdwrite(bp);
}

/*
 * Free an inode.
 *
 * The specified inode is placed back in the free map.
 */
void
ext2fs_inode_free(struct inode *pip, ufsino_t ino, mode_t mode)
{
	struct m_ext2fs *fs;
	char *ibp;
	struct buf *bp;
	int error, cg;

	fs = pip->i_e2fs;
	if (ino > fs->e2fs.e2fs_icount || ino < EXT2_FIRSTINO)
		panic("ifree: range: dev = 0x%x, ino = %u, fs = %s",
		    pip->i_dev, ino, fs->e2fs_fsmnt);
	cg = ino_to_cg(fs, ino);
	error = bread(pip->i_devvp,
	    fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_i_bitmap),
	    (int)fs->e2fs_bsize, &bp);
	if (error) {
		brelse(bp);
		return;
	}
	ibp = (char *)bp->b_data;
	ino = (ino - 1) % fs->e2fs.e2fs_ipg;
	if (isclr(ibp, ino)) {
		printf("dev = 0x%x, ino = %d, fs = %s\n",
		    pip->i_dev, ino, fs->e2fs_fsmnt);
		if (fs->e2fs_ronly == 0)
			panic("ifree: freeing free inode");
	}
	clrbit(ibp, ino);
	fs->e2fs.e2fs_ficount++;
	fs->e2fs_gd[cg].ext2bgd_nifree++;
	if ((mode & IFMT) == IFDIR) {
		fs->e2fs_gd[cg].ext2bgd_ndirs--;
	}
	fs->e2fs_fmod = 1;
	bdwrite(bp);
}

/*
 * Find a block in the specified cylinder group.
 *
 * It is a panic if a request is made to find a block if none are
 * available.
 */

static u_int32_t
ext2fs_mapsearch(struct m_ext2fs *fs, char *bbp, u_int32_t bpref)
{
	u_int32_t bno;
	int start, len, loc, i, map;

	/*
	 * find the fragment by searching through the free block
	 * map for an appropriate bit pattern
	 */
	if (bpref)
		start = dtogd(fs, bpref) / NBBY;
	else
		start = 0;
	len = howmany(fs->e2fs.e2fs_fpg, NBBY) - start;
	loc = skpc(0xff, len, &bbp[start]);
	if (loc == 0) {
		len = start + 1;
		start = 0;
		loc = skpc(0xff, len, &bbp[start]);
		if (loc == 0) {
			printf("start = %d, len = %d, fs = %s\n",
				start, len, fs->e2fs_fsmnt);
			panic("ext2fs_alloccg: map corrupted");
			/* NOTREACHED */
		}
	}
	i = start + len - loc;
	map = bbp[i];
	bno = i * NBBY;
	for (i = 1; i < (1 << NBBY); i <<= 1, bno++) {
		if ((map & i) == 0)
			return (bno);
	}
	printf("fs = %s\n", fs->e2fs_fsmnt);
	panic("ext2fs_mapsearch: block not in map");
	/* NOTREACHED */
}

/*
 * Fserr prints the name of a file system with an error diagnostic.
 *
 * The form of the error message is:
 *	fs: error message
 */
static void
ext2fs_fserr(struct m_ext2fs *fs, uid_t uid, char *cp)
{
	log(LOG_ERR, "uid %u on %s: %s\n", uid, fs->e2fs_fsmnt, cp);
}
@


1.35
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.34 2014/09/14 14:17:26 jsg Exp $	*/
a367 2
	if (bno < 0)
		return (0);
@


1.34
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.33 2014/07/14 08:54:13 pelikan Exp $	*/
a41 1
#include <sys/kernel.h>
@


1.33
log
@better type safety and KNF.

Because ext2fs has only 32-bit inode numbers, use ufsino_t as in FFS.
Disk blocks are u_int32_t as well, because we don't support the 64BIT flag.
When we do, there's going to be a lot more going on than just daddr_t.

While there, add some journaling-related bits into the superblock to play with.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.32 2014/07/13 16:59:35 pelikan Exp $	*/
a39 1
#include <sys/proc.h>
@


1.32
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

Some KNF while there.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.31 2014/05/27 14:31:24 krw Exp $	*/
d56 7
a62 7
static int32_t	ext2fs_alloccg(struct inode *, int, int32_t, int);
static u_long	ext2fs_dirpref(struct m_ext2fs *);
static void	ext2fs_fserr(struct m_ext2fs *, uid_t, char *);
static u_long	ext2fs_hashalloc(struct inode *, int, long, int,
		    int32_t (*)(struct inode *, int, int32_t, int));
static int32_t	ext2fs_nodealloccg(struct inode *, int, int32_t, int);
static int32_t	ext2fs_mapsearch(struct m_ext2fs *, char *, int32_t);
d82 2
a83 2
ext2fs_alloc(struct inode *ip, int32_t lbn, int32_t bpref,
    struct ucred *cred, int32_t *bnp)
d86 1
a86 1
	int32_t bno;
d105 1
a105 2
	bno = (int32_t)ext2fs_hashalloc(ip, cg, bpref, fs->e2fs_bsize,
						 ext2fs_alloccg);
d154 1
a154 1
	ino = (ufsino_t)ext2fs_hashalloc(pip, cg, (long)ipref, mode, ext2fs_nodealloccg);
d179 1
a179 1
noinodes:
d192 1
a192 1
static u_long
d222 1
a222 1
ext2fs_blkpref(struct inode *ip, int32_t lbn, int indx, int32_t *bap)
d243 1
a243 1
		for (i = indx; i >= 0 ; i--) {
d264 3
a266 3
static u_long
ext2fs_hashalloc(struct inode *ip, int cg, long pref, int size,
    int32_t (*allocator)(struct inode *, int, int32_t, int))
d313 2
a314 3

static int32_t
ext2fs_alloccg(struct inode *ip, int cg, int32_t bpref, int size)
d319 2
a320 1
	int error, bno, start, end, loc;
d372 1
a372 1
gotit:
d374 3
a376 4
	if (isset(bbp, (long)bno)) {
		printf("ext2fs_alloccgblk: cg=%d bno=%d fs=%s\n",
			cg, bno, fs->e2fs_fsmnt);
		panic("ext2fs_alloccg: dup alloc");
d379 1
a379 1
	setbit(bbp, (long)bno);
d396 2
a397 2
static int32_t
ext2fs_nodealloccg(struct inode *ip, int cg, int32_t ipref, int mode)
d428 2
a429 2
			printf("cg = %d, ipref = %d, fs = %s\n",
				cg, ipref, fs->e2fs_fsmnt);
d445 1
a445 1
gotit:
d454 1
a454 1
	return (cg * fs->e2fs.e2fs_ipg + ipref +1);
d464 1
a464 1
ext2fs_blkfree(struct inode *ip, int32_t bno)
d473 2
a474 2
	if ((u_int)bno >= fs->e2fs.e2fs_bcount) {
		printf("bad block %d, ino %u\n", bno, ip->i_number);
d479 2
a480 2
		fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_b_bitmap),
		(int)fs->e2fs_bsize, &bp);
d487 4
a490 5
	if (isclr(bbp, bno)) {
		printf("dev = 0x%x, block = %d, fs = %s\n",
			ip->i_dev, bno, fs->e2fs_fsmnt);
		panic("blkfree: freeing free block");
	}
d504 1
a504 1
int
d513 2
a514 2
	if ((u_int)ino > fs->e2fs.e2fs_icount || (u_int)ino < EXT2_FIRSTINO)
		panic("ifree: range: dev = 0x%x, ino = %d, fs = %s",
d522 1
a522 1
		return (0);
a539 1
	return (0);
d549 2
a550 2
static int32_t
ext2fs_mapsearch(struct m_ext2fs *fs, char *bbp, int32_t bpref)
d552 1
a552 1
	int32_t bno;
a596 1

@


1.31
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.30 2013/12/12 19:00:09 tedu Exp $	*/
d166 2
a167 1
			ip->i_e2fs_mode, ip->i_e2fs_nlink, ip->i_number, fs->e2fs_fsmnt);
d246 1
a246 1
				return fs2h32(bap[i]) + 1;
d327 1
a327 2
		fs->e2fs_gd[cg].ext2bgd_b_bitmap),
		(int)fs->e2fs_bsize, &bp);
d411 1
a411 2
		fs->e2fs_gd[cg].ext2bgd_i_bitmap),
		(int)fs->e2fs_bsize, &bp);
d518 1
a518 1
			pip->i_dev, ino, fs->e2fs_fsmnt);
d521 2
a522 2
	        fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_i_bitmap),
		(int)fs->e2fs_bsize, &bp);
d531 1
a531 1
			pip->i_dev, ino, fs->e2fs_fsmnt);
@


1.30
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.29 2013/06/11 16:42:18 deraadt Exp $	*/
d66 1
a66 1
 * 
d88 1
a88 1
	
d121 1
a121 1
 * 
d143 1
a143 1
	
d214 1
a214 1
 * 
d521 1
a521 1
	error = bread(pip->i_devvp, 
d595 1
a595 1
 * 
@


1.29
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.28 2013/05/30 19:19:09 guenther Exp $	*/
d170 1
a170 1
	bzero(ip->i_e2din, sizeof(struct ext2fs_dinode));
@


1.28
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.27 2011/09/18 23:20:28 bluhm Exp $	*/
d221 1
a221 1
daddr64_t
@


1.27
log
@Fix more printf format string bugs in sys/ufs.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.26 2011/07/04 04:30:41 tedu Exp $	*/
d141 1
a141 1
	ino_t ino, ipref;
d155 1
a155 1
	ino = (ino_t)ext2fs_hashalloc(pip, cg, (long)ipref, mode, ext2fs_nodealloccg);
d509 1
a509 1
ext2fs_inode_free(struct inode *pip, ino_t ino, mode_t mode)
@


1.26
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.25 2008/01/05 19:49:26 otto Exp $	*/
d165 1
a165 1
		printf("mode = 0%o, nlinks %d, inum = %d, fs = %s\n",
d477 1
a477 1
		printf("bad block %d, ino %d\n", bno, ip->i_number);
@


1.25
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.24 2007/06/22 09:55:17 jasper Exp $	*/
d327 1
a327 1
		(int)fs->e2fs_bsize, NOCRED, &bp);
d412 1
a412 1
		(int)fs->e2fs_bsize, NOCRED, &bp);
d483 1
a483 1
		(int)fs->e2fs_bsize, NOCRED, &bp);
d523 1
a523 1
		(int)fs->e2fs_bsize, NOCRED, &bp);
@


1.24
log
@declare "uid" as uid_t instead of u_int, and fix format string accordingly

ok pedro@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.23 2007/06/17 20:15:25 jasper Exp $	*/
d221 1
a221 1
int32_t
@


1.23
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.22 2007/06/02 00:45:50 pedro Exp $	*/
d58 1
a58 1
static void	ext2fs_fserr(struct m_ext2fs *, u_int, char *);
d600 1
a600 1
ext2fs_fserr(struct m_ext2fs *fs, u_int uid, char *cp)
d603 1
a603 1
	log(LOG_ERR, "uid %d on %s: %s\n", uid, fs->e2fs_fsmnt, cp);
@


1.22
log
@ufs1_daddr_t cleanup, okay thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.21 2007/03/14 13:56:42 pedro Exp $	*/
d82 2
a83 5
ext2fs_alloc(ip, lbn, bpref, cred, bnp)
	struct inode *ip;
	int32_t lbn, bpref;
	struct ucred *cred;
	int32_t *bnp;
d193 1
a193 2
ext2fs_dirpref(fs)
	struct m_ext2fs *fs;
d222 1
a222 5
ext2fs_blkpref(ip, lbn, indx, bap)
	struct inode *ip;
	int32_t lbn;
	int indx;
	int32_t *bap;
d265 2
a266 6
ext2fs_hashalloc(ip, cg, pref, size, allocator)
	struct inode *ip;
	int cg;
	long pref;
	int size;	/* size for data blocks, mode for inodes */
	int32_t (*allocator)(struct inode *, int, int32_t, int);
d315 1
a315 5
ext2fs_alloccg(ip, cg, bpref, size)
	struct inode *ip;
	int cg;
	int32_t bpref;
	int size;
d399 1
a399 5
ext2fs_nodealloccg(ip, cg, ipref, mode)
	struct inode *ip;
	int cg;
	int32_t ipref;
	int mode;
d467 1
a467 3
ext2fs_blkfree(ip, bno)
	struct inode *ip;
	int32_t bno;
d511 2
a512 2
	register struct m_ext2fs *fs;
	register char *ibp;
d555 1
a555 4
ext2fs_mapsearch(fs, bbp, bpref)
	struct m_ext2fs *fs;
	char *bbp;
	int32_t bpref;
d600 1
a600 4
ext2fs_fserr(fs, uid, cp)
	struct m_ext2fs *fs;
	u_int uid;
	char *cp;
@


1.21
log
@Check if there are still blocks left to be allocated _after_ we have
read in the bitmap (an operation that might cause us to sleep), and
before committing to the allocation. Fixes PR 5230, okay krw@@, millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.20 2005/12/11 20:46:28 pedro Exp $	*/
d56 1
a56 1
static ufs1_daddr_t	ext2fs_alloccg(struct inode *, int, ufs1_daddr_t, int);
d60 3
a62 3
		    ufs1_daddr_t (*)(struct inode *, int, ufs1_daddr_t, int));
static ufs1_daddr_t	ext2fs_nodealloccg(struct inode *, int, ufs1_daddr_t, int);
static ufs1_daddr_t	ext2fs_mapsearch(struct m_ext2fs *, char *, ufs1_daddr_t);
d84 1
a84 1
	ufs1_daddr_t lbn, bpref;
d86 1
a86 1
	ufs1_daddr_t *bnp;
d89 1
a89 1
	ufs1_daddr_t bno;
d108 1
a108 1
	bno = (ufs1_daddr_t)ext2fs_hashalloc(ip, cg, bpref, fs->e2fs_bsize,
d225 1
a225 1
ufs1_daddr_t
d228 1
a228 1
	ufs1_daddr_t lbn;
d230 1
a230 1
	ufs1_daddr_t *bap;
d278 1
a278 1
	ufs1_daddr_t (*allocator)(struct inode *, int, ufs1_daddr_t, int);
d326 1
a326 1
static ufs1_daddr_t
d330 1
a330 1
	ufs1_daddr_t bpref;
d414 1
a414 1
static ufs1_daddr_t
d418 1
a418 1
	ufs1_daddr_t ipref;
d489 1
a489 1
	ufs1_daddr_t bno;
d576 1
a576 1
static ufs1_daddr_t
d580 1
a580 1
	ufs1_daddr_t bpref;
d582 1
a582 1
	ufs1_daddr_t bno;
@


1.20
log
@inode/dinode separation for ext2fs
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.19 2005/07/03 20:14:01 drahn Exp $	*/
d344 1
a344 1
	if (error) {
@


1.19
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.18 2005/05/02 13:13:21 pedro Exp $	*/
d173 1
a173 1
	bzero(&(ip->i_e2din), sizeof(struct ext2fs_dinode));
@


1.18
log
@quadradically -> quadratically, lots of
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.17 2004/09/18 22:01:18 tedu Exp $	*/
a47 1
#include <ufs/ufs/extattr.h>
@


1.17
log
@hierarchy is spelled hierarchy, from Jonathan Gray
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.16 2004/07/13 21:04:29 millert Exp $	*/
d73 1
a73 1
 *   4) quadradically rehash into other cylinder groups, until an
d79 1
a79 1
 *   2) quadradically rehash into other cylinder groups, until an
d130 1
a130 1
 *   3) quadradically rehash into other cylinder groups, until an
d135 1
a135 1
 *   2) quadradically rehash into other cylinder groups, until an
d270 1
a270 1
 *   2) quadradically rehash on the cylinder group number.
@


1.16
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.15 2004/06/21 23:50:38 tholo Exp $	*/
d75 1
a75 1
 * If no block preference is given the following heirarchy is used
d132 1
a132 1
 * If no inode preference is given the following heirarchy is used
@


1.15
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.14 2004/01/20 03:44:06 tedu Exp $	*/
d139 1
a139 1
ext2fs_inode_alloc(struct inode *pip, int mode, struct ucred *cred,
d532 1
a532 1
ext2fs_inode_free(struct inode *pip, ino_t ino, int mode)
@


1.14
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.13 2003/08/25 23:26:55 tedu Exp $	*/
d179 2
a180 2
	if (++ext2gennumber < (u_long)time.tv_sec)
		ext2gennumber = time.tv_sec;
@


1.13
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
few other little cleanups.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.12 2003/07/06 05:24:16 tedu Exp $	*/
d48 2
@


1.12
log
@fix off by one.  inodes start at 1, so e2fs_icount is a valid inode number.
from otto moerbeek
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.11 2003/06/02 23:28:22 millert Exp $	*/
d172 1
a172 1
	bzero(&(ip->i_din.e2fs_din), sizeof(struct ext2fs_dinode));
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.10 2003/05/26 18:33:16 tedu Exp $	*/
d538 1
a538 1
	if ((u_int)ino >= fs->e2fs.e2fs_icount || (u_int)ino < EXT2_FIRSTINO)
@


1.10
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.9 2002/03/14 03:16:13 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.8 2002/03/14 01:27:14 millert Exp $	*/
d59 1
a59 1
static ufs_daddr_t	ext2fs_alloccg(struct inode *, int, ufs_daddr_t, int);
d63 3
a65 3
		    ufs_daddr_t (*)(struct inode *, int, ufs_daddr_t, int));
static ufs_daddr_t	ext2fs_nodealloccg(struct inode *, int, ufs_daddr_t, int);
static ufs_daddr_t	ext2fs_mapsearch(struct m_ext2fs *, char *, ufs_daddr_t);
d87 1
a87 1
	ufs_daddr_t lbn, bpref;
d89 1
a89 1
	ufs_daddr_t *bnp;
d92 1
a92 1
	ufs_daddr_t bno;
d111 1
a111 1
	bno = (ufs_daddr_t)ext2fs_hashalloc(ip, cg, bpref, fs->e2fs_bsize,
d228 1
a228 1
ufs_daddr_t
d231 1
a231 1
	ufs_daddr_t lbn;
d233 1
a233 1
	ufs_daddr_t *bap;
d281 1
a281 1
	ufs_daddr_t (*allocator)(struct inode *, int, ufs_daddr_t, int);
d329 1
a329 1
static ufs_daddr_t
d333 1
a333 1
	ufs_daddr_t bpref;
d417 1
a417 1
static ufs_daddr_t
d421 1
a421 1
	ufs_daddr_t ipref;
d492 1
a492 1
	ufs_daddr_t bno;
d579 1
a579 1
static ufs_daddr_t
d583 1
a583 1
	ufs_daddr_t bpref;
d585 1
a585 1
	ufs_daddr_t bno;
@


1.9.4.1
log
@MFC:
Fix by tedu@@

fix off by one.  inodes start at 1, so e2fs_icount is a valid inode
number.  from otto moerbeek

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.9 2002/03/14 03:16:13 millert Exp $	*/
d542 1
a542 1
	if ((u_int)ino > fs->e2fs.e2fs_icount || (u_int)ino < EXT2_FIRSTINO)
@


1.9.6.1
log
@MFC:
Fix by tedu@@

fix off by one.  inodes start at 1, so e2fs_icount is a valid inode
number.  from otto moerbeek

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.9 2002/03/14 03:16:13 millert Exp $	*/
d542 1
a542 1
	if ((u_int)ino > fs->e2fs.e2fs_icount || (u_int)ino < EXT2_FIRSTINO)
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.7 2001/09/17 23:25:04 art Exp $	*/
d62 2
a63 3
static u_long	ext2fs_hashalloc __P((struct inode *, int, long, int,
				   ufs_daddr_t (*)(struct inode *, int, ufs_daddr_t,
						   int)));
@


1.7
log
@Cleanups. Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 3
a61 3
static ufs_daddr_t	ext2fs_alloccg __P((struct inode *, int, ufs_daddr_t, int));
static u_long	ext2fs_dirpref __P((struct m_ext2fs *));
static void	ext2fs_fserr __P((struct m_ext2fs *, u_int, char *));
d65 2
a66 2
static ufs_daddr_t	ext2fs_nodealloccg __P((struct inode *, int, ufs_daddr_t, int));
static ufs_daddr_t	ext2fs_mapsearch __P((struct m_ext2fs *, char *, ufs_daddr_t));
d282 1
a282 1
	ufs_daddr_t (*allocator) __P((struct inode *, int, ufs_daddr_t, int));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.7 2001/09/17 23:25:04 art Exp $	*/
d59 8
a66 7
static ufs_daddr_t	ext2fs_alloccg(struct inode *, int, ufs_daddr_t, int);
static u_long	ext2fs_dirpref(struct m_ext2fs *);
static void	ext2fs_fserr(struct m_ext2fs *, u_int, char *);
static u_long	ext2fs_hashalloc(struct inode *, int, long, int,
		    ufs_daddr_t (*)(struct inode *, int, ufs_daddr_t, int));
static ufs_daddr_t	ext2fs_nodealloccg(struct inode *, int, ufs_daddr_t, int);
static ufs_daddr_t	ext2fs_mapsearch(struct m_ext2fs *, char *, ufs_daddr_t);
d282 1
a282 1
	ufs_daddr_t (*allocator)(struct inode *, int, ufs_daddr_t, int);
@


1.6
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_alloc.c,v 1.5 2000/04/26 23:24:40 jasoni Exp $	*/
/*	$NetBSD: ext2fs_alloc.c,v 1.1 1997/06/11 09:33:41 bouyer Exp $	*/
a49 2
#include <vm/vm.h>

d59 1
a59 1
static daddr_t	ext2fs_alloccg __P((struct inode *, int, daddr_t, int));
d63 1
a63 1
				   daddr_t (*)(struct inode *, int, daddr_t,
d65 2
a66 2
static daddr_t	ext2fs_nodealloccg __P((struct inode *, int, daddr_t, int));
static daddr_t	ext2fs_mapsearch __P((struct m_ext2fs *, char *, daddr_t));
d87 2
a88 2
	register struct inode *ip;
	daddr_t lbn, bpref;
d90 1
a90 1
	daddr_t *bnp;
d92 2
a93 2
	register struct m_ext2fs *fs;
	daddr_t bno;
d112 1
a112 1
	bno = (daddr_t)ext2fs_hashalloc(ip, cg, bpref, fs->e2fs_bsize,
d201 1
a201 1
	register struct m_ext2fs *fs;
d226 1
a226 1
 * contigously. The two fields of the ext2 inode extention (see
d229 1
a229 1
daddr_t
d232 1
a232 1
	daddr_t lbn;
d234 1
a234 1
	daddr_t *bap;
d236 2
a237 2
	register struct m_ext2fs *fs;
	register int cg, i;
d282 1
a282 1
	daddr_t (*allocator) __P((struct inode *, int, daddr_t, int));
d284 1
a284 1
	register struct m_ext2fs *fs;
d320 1
a320 1
	return (NULL);
d330 1
a330 1
static daddr_t
d334 1
a334 1
	daddr_t bpref;
d337 2
a338 2
	register struct m_ext2fs *fs;
	register char *bbp;
d344 3
a346 3
		return (NULL);
	error = bread(ip->i_devvp, fsbtodb(fs, 
	        fs->e2fs_gd[cg].ext2bgd_b_bitmap),
d350 1
a350 1
		return (NULL);
d392 1
a392 1
		return (NULL);
d398 1
a398 1
		panic("ext2fs_valloc: dup alloc");
d418 1
a418 1
static daddr_t
d422 1
a422 1
	daddr_t ipref;
d425 2
a426 2
	register struct m_ext2fs *fs;
	register char *ibp;
d433 3
a435 3
		return (NULL);
	error = bread(ip->i_devvp, fsbtodb(fs, 
	        fs->e2fs_gd[cg].ext2bgd_i_bitmap),
d439 1
a439 1
		return (NULL);
d492 2
a493 2
	register struct inode *ip;
	daddr_t bno;
d495 2
a496 2
	register struct m_ext2fs *fs;
	register char *bbp;
d507 2
a508 2
	error = bread(ip->i_devvp, fsbtodb(fs, 
	        fs->e2fs_gd[cg].ext2bgd_b_bitmap),
d580 1
a580 1
static daddr_t
d582 3
a584 3
	register struct m_ext2fs *fs;
	register char *bbp;
	daddr_t bpref;
d586 1
a586 1
	daddr_t bno;
@


1.5
log
@Support for ext2fs rev. 1 (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.4 1999/01/11 05:12:35 millert Exp $	*/
d144 2
a145 2
ext2fs_valloc(v)
	void *v;
d147 3
a149 11
	struct vop_valloc_args /* {
		struct vnode *a_pvp;
		int a_mode;
		struct ucred *a_cred;
		struct vnode **a_vpp;
	} */ *ap = v;
	register struct vnode *pvp = ap->a_pvp;
	register struct inode *pip;
	register struct m_ext2fs *fs;
	register struct inode *ip;
	mode_t mode = ap->a_mode;
d153 2
a154 2
	*ap->a_vpp = NULL;
	pip = VTOI(pvp);
d167 1
a167 1
	error = VFS_VGET(pvp->v_mount, ino, ap->a_vpp);
d169 1
a169 1
		VOP_VFREE(pvp, ino, mode);
d172 1
a172 1
	ip = VTOI(*ap->a_vpp);
d189 1
a189 1
	ext2fs_fserr(fs, ap->a_cred->cr_uid, "out of inodes");
d537 1
a537 2
ext2fs_vfree(v)
	void *v;
a538 5
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap = v;
a540 2
	register struct inode *pip;
	ino_t ino = ap->a_ino;
a543 1
	pip = VTOI(ap->a_pvp);
d567 1
a567 1
	if ((ap->a_mode & IFMT) == IFDIR) {
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.3 1997/06/12 21:09:31 downsj Exp $	*/
d267 1
a267 1
				return bap[i] + 1;
d355 2
a356 1
	error = bread(ip->i_devvp, fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_b_bitmap),
d444 2
a445 1
	error = bread(ip->i_devvp, fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_i_bitmap),
d517 2
a518 1
	error = bread(ip->i_devvp, fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_b_bitmap),
d566 2
a567 1
	error = bread(pip->i_devvp, fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_i_bitmap),
@


1.4.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.5 2000/04/26 23:24:40 jasoni Exp $	*/
d267 1
a267 1
				return fs2h32(bap[i]) + 1;
d355 1
a355 2
	error = bread(ip->i_devvp, fsbtodb(fs, 
	        fs->e2fs_gd[cg].ext2bgd_b_bitmap),
d443 1
a443 2
	error = bread(ip->i_devvp, fsbtodb(fs, 
	        fs->e2fs_gd[cg].ext2bgd_i_bitmap),
d515 1
a515 2
	error = bread(ip->i_devvp, fsbtodb(fs, 
	        fs->e2fs_gd[cg].ext2bgd_b_bitmap),
d563 1
a563 2
	error = bread(pip->i_devvp, 
	        fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_i_bitmap),
@


1.4.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.4.6.1 2001/05/14 22:47:39 niklas Exp $	*/
d144 2
a145 2
ext2fs_inode_alloc(struct inode *pip, int mode, struct ucred *cred,
    struct vnode **vpp)
d147 11
a157 3
	struct vnode *pvp;
	struct m_ext2fs *fs;
	struct inode *ip;
d161 2
a162 2
	*vpp = NULL;
	pvp = ITOV(pip);
d175 1
a175 1
	error = VFS_VGET(pvp->v_mount, ino, vpp);
d177 1
a177 1
		ext2fs_inode_free(pip, ino, mode);
d180 1
a180 1
	ip = VTOI(*vpp);
d197 1
a197 1
	ext2fs_fserr(fs, cred->cr_uid, "out of inodes");
d545 2
a546 1
ext2fs_inode_free(struct inode *pip, ino_t ino, int mode)
d548 5
d555 2
d560 1
d584 1
a584 1
	if ((mode & IFMT) == IFDIR) {
@


1.4.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_alloc.c,v 1.4.6.2 2001/07/04 11:00:41 niklas Exp $	*/
/*	$NetBSD: ext2fs_alloc.c,v 1.10 2001/07/05 08:38:27 toshii Exp $	*/
d50 2
d61 1
a61 1
static ufs_daddr_t	ext2fs_alloccg __P((struct inode *, int, ufs_daddr_t, int));
d65 1
a65 1
				   ufs_daddr_t (*)(struct inode *, int, ufs_daddr_t,
d67 2
a68 2
static ufs_daddr_t	ext2fs_nodealloccg __P((struct inode *, int, ufs_daddr_t, int));
static ufs_daddr_t	ext2fs_mapsearch __P((struct m_ext2fs *, char *, ufs_daddr_t));
d89 2
a90 2
	struct inode *ip;
	ufs_daddr_t lbn, bpref;
d92 1
a92 1
	ufs_daddr_t *bnp;
d94 2
a95 2
	struct m_ext2fs *fs;
	ufs_daddr_t bno;
d114 1
a114 1
	bno = (ufs_daddr_t)ext2fs_hashalloc(ip, cg, bpref, fs->e2fs_bsize,
d203 1
a203 1
	struct m_ext2fs *fs;
d228 1
a228 1
 * contigously. The two fields of the ext2 inode extension (see
d231 1
a231 1
ufs_daddr_t
d234 1
a234 1
	ufs_daddr_t lbn;
d236 1
a236 1
	ufs_daddr_t *bap;
d238 2
a239 2
	struct m_ext2fs *fs;
	int cg, i;
d284 1
a284 1
	ufs_daddr_t (*allocator) __P((struct inode *, int, ufs_daddr_t, int));
d286 1
a286 1
	struct m_ext2fs *fs;
d322 1
a322 1
	return (0);
d332 1
a332 1
static ufs_daddr_t
d336 1
a336 1
	ufs_daddr_t bpref;
d339 2
a340 2
	struct m_ext2fs *fs;
	char *bbp;
d346 3
a348 3
		return (0);
	error = bread(ip->i_devvp, fsbtodb(fs,
		fs->e2fs_gd[cg].ext2bgd_b_bitmap),
d352 1
a352 1
		return (0);
d394 1
a394 1
		return (0);
d400 1
a400 1
		panic("ext2fs_alloccg: dup alloc");
d420 1
a420 1
static ufs_daddr_t
d424 1
a424 1
	ufs_daddr_t ipref;
d427 2
a428 2
	struct m_ext2fs *fs;
	char *ibp;
d435 3
a437 3
		return (0);
	error = bread(ip->i_devvp, fsbtodb(fs,
		fs->e2fs_gd[cg].ext2bgd_i_bitmap),
d441 1
a441 1
		return (0);
d494 2
a495 2
	struct inode *ip;
	ufs_daddr_t bno;
d497 2
a498 2
	struct m_ext2fs *fs;
	char *bbp;
d509 2
a510 2
	error = bread(ip->i_devvp,
		fsbtodb(fs, fs->e2fs_gd[cg].ext2bgd_b_bitmap),
d582 1
a582 1
static ufs_daddr_t
d584 3
a586 3
	struct m_ext2fs *fs;
	char *bbp;
	ufs_daddr_t bpref;
d588 1
a588 1
	ufs_daddr_t bno;
@


1.4.6.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 8
a66 7
static ufs_daddr_t	ext2fs_alloccg(struct inode *, int, ufs_daddr_t, int);
static u_long	ext2fs_dirpref(struct m_ext2fs *);
static void	ext2fs_fserr(struct m_ext2fs *, u_int, char *);
static u_long	ext2fs_hashalloc(struct inode *, int, long, int,
		    ufs_daddr_t (*)(struct inode *, int, ufs_daddr_t, int));
static ufs_daddr_t	ext2fs_nodealloccg(struct inode *, int, ufs_daddr_t, int);
static ufs_daddr_t	ext2fs_mapsearch(struct m_ext2fs *, char *, ufs_daddr_t);
d282 1
a282 1
	ufs_daddr_t (*allocator)(struct inode *, int, ufs_daddr_t, int);
@


1.4.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.4.6.4 2002/03/28 14:54:25 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
d59 1
a59 1
static ufs1_daddr_t	ext2fs_alloccg(struct inode *, int, ufs1_daddr_t, int);
d63 3
a65 3
		    ufs1_daddr_t (*)(struct inode *, int, ufs1_daddr_t, int));
static ufs1_daddr_t	ext2fs_nodealloccg(struct inode *, int, ufs1_daddr_t, int);
static ufs1_daddr_t	ext2fs_mapsearch(struct m_ext2fs *, char *, ufs1_daddr_t);
d87 1
a87 1
	ufs1_daddr_t lbn, bpref;
d89 1
a89 1
	ufs1_daddr_t *bnp;
d92 1
a92 1
	ufs1_daddr_t bno;
d111 1
a111 1
	bno = (ufs1_daddr_t)ext2fs_hashalloc(ip, cg, bpref, fs->e2fs_bsize,
d228 1
a228 1
ufs1_daddr_t
d231 1
a231 1
	ufs1_daddr_t lbn;
d233 1
a233 1
	ufs1_daddr_t *bap;
d281 1
a281 1
	ufs1_daddr_t (*allocator)(struct inode *, int, ufs1_daddr_t, int);
d329 1
a329 1
static ufs1_daddr_t
d333 1
a333 1
	ufs1_daddr_t bpref;
d417 1
a417 1
static ufs1_daddr_t
d421 1
a421 1
	ufs1_daddr_t ipref;
d492 1
a492 1
	ufs1_daddr_t bno;
d579 1
a579 1
static ufs1_daddr_t
d583 1
a583 1
	ufs1_daddr_t bpref;
d585 1
a585 1
	ufs1_daddr_t bno;
@


1.4.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 2
#include <ufs/ufs/extattr.h>
#include <ufs/ufs/ufsmount.h>
d172 1
a172 1
	bzero(&(ip->i_e2din), sizeof(struct ext2fs_dinode));
d538 1
a538 1
	if ((u_int)ino > fs->e2fs.e2fs_icount || (u_int)ino < EXT2_FIRSTINO)
@


1.3
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_alloc.c,v 1.2 1997/05/30 08:33:36 downsj Exp $	*/
d102 1
a102 1
		panic("ext2fs_alloc: missing credential\n");
d560 1
a560 1
		panic("ifree: range: dev = 0x%x, ino = %d, fs = %s\n",
@


1.2
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 2
a2 4
/*	$OpenBSD$	*/
/*	$NetBSD: ffs_alloc.c,v 1.13 1996/10/12 21:58:44 christos Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d5 1
d38 1
d66 1
a66 1
					       int)));
d79 1
a79 1
 *      available block is located.
d83 1
a83 1
 *      inode for the file.
d85 1
a85 1
 *      available block is located.
d114 2
a115 2
	bno = (daddr_t)ext2fs_hashalloc(ip, cg, (long)bpref, fs->e2fs_bsize,
	    			     ext2fs_alloccg);
d136 1
a136 1
 *      available inode is located.
d141 1
a141 1
 *      available inode is located.
d171 1
a171 1
	ipref = cg * fs->e2fs.e2fs_ipg;
d183 1
a183 1
	    	ip->i_e2fs_mode, ip->i_e2fs_nlink, ip->i_number, fs->e2fs_fsmnt);
d425 1
a425 1
 *      inode in the specified cylinder group.
d464 1
a464 1
			    cg, ipref, fs->e2fs_fsmnt);
d525 1
a525 1
		    ip->i_dev, bno, fs->e2fs_fsmnt);
d561 1
a561 1
		    pip->i_dev, ino, fs->e2fs_fsmnt);
d573 1
a573 1
		    pip->i_dev, ino, fs->e2fs_fsmnt);
d620 1
a620 1
			    start, len, fs->e2fs_fsmnt);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@
