head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.12
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.10
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.6
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.2
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.21.0.6
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.20.0.4
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.25;
commitid	p4LJxGKbi0BU2cG6;

1.25
date	2014.07.14.08.54.13;	author pelikan;	state Exp;
branches;
next	1.24;
commitid	5pxoUiNNvSjZa1j9;

1.24
date	2014.07.13.16.59.35;	author pelikan;	state Exp;
branches;
next	1.23;
commitid	zGe0z6RRYbZJpA8u;

1.23
date	2014.07.13.13.28.26;	author pelikan;	state Exp;
branches;
next	1.22;
commitid	dOiPqBMzR47FMb48;

1.22
date	2014.05.27.14.31.24;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.17.20.15.25;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.02.00.45.50;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.03.20.14.01;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.18.00.22.31;	author art;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2000.06.23.02.14.39;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.04.25.00.36.46;	author millert;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	97.06.12.21.09.31;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.05.30.08.33.42;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.47.39;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.32.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: ext2fs_bmap.c,v 1.25 2014/07/14 08:54:13 pelikan Exp $	*/
/*	$NetBSD: ext2fs_bmap.c,v 1.5 2000/03/30 12:41:11 augustss Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_bmap.c	8.6 (Berkeley) 1/21/94
 * Modified for ext2fs by Manuel Bouyer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/specdev.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>
#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ext2fs/ext2fs_extents.h>
#include <ufs/ext2fs/ext2fs_extern.h>

static int	ext4_bmapext(struct vnode *, daddr_t, daddr_t *, struct indir *,
    int *, int *);
static int	ext2fs_bmaparray(struct vnode *, daddr_t, daddr_t *, struct indir *,
    int *, int *);

/*
 * Bmap converts a the logical block number of a file to its physical block
 * number on the disk. The conversion is done by using the logical block
 * number to index into the array of block pointers described by the dinode.
 */
int
ext2fs_bmap(void *v)
{
	struct vop_bmap_args *ap = v;

	/*
	 * Check for underlying vnode requests and ensure that logical
	 * to physical mapping is requested.
	 */
	if (ap->a_vpp != NULL)
		*ap->a_vpp = VTOI(ap->a_vp)->i_devvp;
	if (ap->a_bnp == NULL)
		return (0);

	if (VTOI(ap->a_vp)->i_e2din->e2di_flags & EXT4_EXTENTS) {
		return (ext4_bmapext(ap->a_vp, ap->a_bn, ap->a_bnp, NULL, NULL,
		    ap->a_runp));
	}
	return (ext2fs_bmaparray(ap->a_vp, ap->a_bn, ap->a_bnp, NULL, NULL,
		ap->a_runp));
}

/*
 * Logical block number of a file -> physical block number on disk within ext4 extents.
 */
int
ext4_bmapext(struct vnode *vp, daddr_t bn, daddr_t *bnp, struct indir *ap, int *nump, int *runp)
{
	struct inode *ip;
	struct m_ext2fs *fs;
	struct ext4_extent *ep;
	struct ext4_extent_path path;
	daddr_t pos;

	ip = VTOI(vp);
	fs = ip->i_e2fs;

	if (runp != NULL)
		*runp = 0;
	if (nump != NULL)
		*nump = 0;

	ext4_ext_find_extent(fs, ip, bn, &path);
	if ((ep = path.ep_ext) == NULL)
		return (EIO);

	pos = bn - ep->e_blk + (((daddr_t)ep->e_start_hi << 32) | ep->e_start_lo);
	if ((*bnp = fsbtodb(fs, pos)) == 0)
		*bnp = -1;
	return (0);
}

/*
 * Indirect blocks are now on the vnode for the file.  They are given negative
 * logical block numbers.  Indirect blocks are addressed by the negative
 * address of the first data block to which they point.  Double indirect blocks
 * are addressed by one less than the address of the first indirect block to
 * which they point.  Triple indirect blocks are addressed by one less than
 * the address of the first double indirect block to which they point.
 *
 * ext2fs_bmaparray does the bmap conversion, and if requested returns the
 * array of logical blocks which must be traversed to get to a block.
 * Each entry contains the offset into that block that gets you to the
 * next block and the disk address of the block (if it is assigned).
 */

int
ext2fs_bmaparray(struct vnode *vp, daddr_t bn, daddr_t *bnp,
    struct indir *ap, int *nump, int *runp)
{
	struct inode *ip;
	struct buf *bp;
	struct ufsmount *ump;
	struct mount *mp;
	struct vnode *devvp;
	struct indir a[NIADDR+1], *xap;
	int32_t daddr;
	long metalbn;
	int error, maxrun = 0, num;

	ip = VTOI(vp);
	mp = vp->v_mount;
	ump = VFSTOUFS(mp);
#ifdef DIAGNOSTIC
	if ((ap != NULL && nump == NULL) || (ap == NULL && nump != NULL))
		panic("ext2fs_bmaparray: invalid arguments");
#endif

	if (runp) {
		/*
		 * XXX
		 * If MAXBSIZE is the largest transfer the disks can handle,
		 * we probably want maxrun to be 1 block less so that we
		 * don't create a block larger than the device can handle.
		 */
		*runp = 0;
		maxrun = MAXBSIZE / mp->mnt_stat.f_iosize - 1;
	}

	xap = ap == NULL ? a : ap;
	if (!nump)
		nump = &num;
	if ((error = ufs_getlbns(vp, bn, xap, nump)) != 0)
		return (error);

	num = *nump;
	if (num == 0) {
		*bnp = blkptrtodb(ump, letoh32(ip->i_e2fs_blocks[bn]));
		if (*bnp == 0)
			*bnp = -1;
		else if (runp)
			for (++bn; bn < NDADDR && *runp < maxrun &&
			    is_sequential(ump,
			    letoh32(ip->i_e2fs_blocks[bn - 1]),
			    letoh32(ip->i_e2fs_blocks[bn]));
			    ++bn, ++*runp)
				/* nothing */;
		return (0);
	}


	/* Get disk address out of indirect block array */
	daddr = letoh32(ip->i_e2fs_blocks[NDADDR + xap->in_off]);

	devvp = VFSTOUFS(vp->v_mount)->um_devvp;

#ifdef DIAGNOSTIC
    if (num > NIADDR + 1 || num < 1) {
		printf("ext2fs_bmaparray: num=%d\n", num);
		panic("ext2fs_bmaparray: num");
	}
#endif
	for (bp = NULL, ++xap; --num; ++xap) {
		/*
		 * Exit the loop if there is no disk address assigned yet and
		 * the indirect block isn't in the cache, or if we were
		 * looking for an indirect block and we've found it.
		 */

		metalbn = xap->in_lbn;
		if ((daddr == 0 && !incore(vp, metalbn)) || metalbn == bn)
			break;
		/*
		 * If we get here, we've either got the block in the cache
		 * or we have a disk address for it, go fetch it.
		 */
		if (bp)
			brelse(bp);

		xap->in_exists = 1;
		bp = getblk(vp, metalbn, mp->mnt_stat.f_iosize, 0, 0);
		if (bp->b_flags & (B_DONE | B_DELWRI)) {
			;
		}
#ifdef DIAGNOSTIC
		else if (!daddr)
			panic("ext2fs_bmaparry: indirect block not in cache");
#endif
		else {
			bp->b_blkno = blkptrtodb(ump, daddr);
			bp->b_flags |= B_READ;
			VOP_STRATEGY(bp);
			curproc->p_ru.ru_inblock++;		/* XXX */
			bcstats.pendingreads++;
			if ((error = biowait(bp)) != 0) {
				brelse(bp);
				return (error);
			}
		}

		daddr = letoh32(((int32_t *)bp->b_data)[xap->in_off]);
		if (num == 1 && daddr && runp)
			for (bn = xap->in_off + 1;
			    bn < MNINDIR(ump) && *runp < maxrun &&
			    is_sequential(ump, ((u_int32_t *)bp->b_data)[bn - 1],
			    ((u_int32_t *)bp->b_data)[bn]);
			    ++bn, ++*runp)
				/* nothing */;
	}
	if (bp)
		brelse(bp);

	daddr = blkptrtodb(ump, daddr);
	*bnp = daddr == 0 ? -1 : daddr;
	return (0);
}
@


1.25
log
@better type safety and KNF.

Because ext2fs has only 32-bit inode numbers, use ufsino_t as in FFS.
Disk blocks are u_int32_t as well, because we don't support the 64BIT flag.
When we do, there's going to be a lot more going on than just daddr_t.

While there, add some journaling-related bits into the superblock to play with.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.24 2014/07/13 16:59:35 pelikan Exp $	*/
a47 1
#include <sys/resourcevar.h>
@


1.24
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

Some KNF while there.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.23 2014/07/13 13:28:26 pelikan Exp $	*/
d242 5
a246 4
				bn < MNINDIR(ump) && *runp < maxrun &&
				is_sequential(ump, ((int32_t *)bp->b_data)[bn - 1],
				((int32_t *)bp->b_data)[bn]);
				++bn, ++*runp);
@


1.23
log
@ext4 (extents) read support

Tested on amd64 with > 4GB files and 50,000 subdirectories.
From FreeBSD, thanks!

ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.22 2014/05/27 14:31:24 krw Exp $	*/
d176 1
a176 1
		*bnp = blkptrtodb(ump, fs2h32(ip->i_e2fs_blocks[bn]));
d181 5
a185 3
				is_sequential(ump, fs2h32(ip->i_e2fs_blocks[bn - 1]),
							  fs2h32(ip->i_e2fs_blocks[bn]));
				++bn, ++*runp);
d191 1
a191 1
	daddr = fs2h32(ip->i_e2fs_blocks[NDADDR + xap->in_off]);
d239 1
a239 1
		daddr = fs2h32(((int32_t *)bp->b_data)[xap->in_off]);
@


1.22
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.21 2013/06/11 16:42:18 deraadt Exp $	*/
d56 1
d59 4
a62 2
static int ext2fs_bmaparray(struct vnode *, int32_t, daddr_t *,
    struct indir *, int *, int *);
d73 1
d83 4
d92 30
d136 1
a136 1
ext2fs_bmaparray(struct vnode *vp, int32_t bn, daddr_t *bnp,
@


1.21
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.20 2012/03/23 15:51:26 guenther Exp $	*/
d162 1
a162 1
		/* 
@


1.20
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.19 2011/07/04 20:35:35 deraadt Exp $	*/
d58 1
a58 1
static int ext2fs_bmaparray(struct vnode *, int32_t, daddr64_t *,
d98 1
a98 1
ext2fs_bmaparray(struct vnode *vp, int32_t bn, daddr64_t *bnp,
@


1.19
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.18 2008/06/12 06:58:40 deraadt Exp $	*/
d191 1
a191 1
			curproc->p_stats->p_ru.ru_inblock++;	/* XXX */
@


1.18
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.16 2008/06/10 20:14:37 beck Exp $	*/
d49 1
a49 2

#include <miscfs/specfs/specdev.h>
@


1.17
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.15 2007/06/17 20:15:25 jasper Exp $	*/
d193 1
@


1.16
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@a192 1
			bcstats.pendingreads++;
@


1.15
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.14 2007/06/02 00:45:50 pedro Exp $	*/
d193 1
@


1.14
log
@ufs1_daddr_t cleanup, okay thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.13 2007/06/01 23:47:57 deraadt Exp $	*/
d68 1
a68 2
ext2fs_bmap(v)
	void *v;
d99 2
a100 7
ext2fs_bmaparray(vp, bn, bnp, ap, nump, runp)
	struct vnode *vp;
	int32_t bn;
	daddr64_t *bnp;
	struct indir *ap;
	int *nump;
	int *runp;
@


1.13
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.12 2006/10/03 19:49:06 pedro Exp $	*/
d59 1
a59 1
static int ext2fs_bmaparray(struct vnode *, ufs1_daddr_t, daddr64_t *,
d102 1
a102 1
	ufs1_daddr_t bn;
d114 1
a114 1
	ufs1_daddr_t daddr;
d205 1
a205 1
		daddr = fs2h32(((ufs1_daddr_t *)bp->b_data)[xap->in_off]);
d209 2
a210 2
				is_sequential(ump, ((ufs1_daddr_t *)bp->b_data)[bn - 1],
				((ufs1_daddr_t *)bp->b_data)[bn]);
@


1.12
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.11 2005/07/03 20:14:01 drahn Exp $	*/
d71 1
a71 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
@


1.11
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.10 2003/06/02 23:28:22 millert Exp $	*/
d59 2
a60 2
static int ext2fs_bmaparray(struct vnode *, ufs1_daddr_t, ufs1_daddr_t *,
								struct indir *, int *, int *);
d109 1
a109 1
	ufs1_daddr_t *bnp;
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.9 2003/05/26 18:33:16 tedu Exp $	*/
a51 1
#include <ufs/ufs/extattr.h>
@


1.9
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.8 2002/03/14 01:27:14 millert Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.7 2002/02/22 20:37:45 drahn Exp $	*/
d64 1
a64 1
static int ext2fs_bmaparray(struct vnode *, ufs_daddr_t, ufs_daddr_t *,
d113 2
a114 2
	ufs_daddr_t bn;
	ufs_daddr_t *bnp;
d125 1
a125 1
	ufs_daddr_t daddr;
d216 1
a216 1
		daddr = fs2h32(((ufs_daddr_t *)bp->b_data)[xap->in_off]);
d220 2
a221 2
				is_sequential(ump, ((ufs_daddr_t *)bp->b_data)[bn - 1],
				((ufs_daddr_t *)bp->b_data)[bn]);
@


1.7
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.6 2001/09/18 00:22:31 art Exp $	*/
d64 2
a65 2
static int ext2fs_bmaparray __P((struct vnode *, ufs_daddr_t, ufs_daddr_t *,
								struct indir *, int *, int *));
@


1.6
log
@cosmetic and endianness fixes from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.6 2001/09/18 00:22:31 art Exp $	*/
a55 1
#include <ufs/ufs/extattr.h>
d63 2
a64 2
static int ext2fs_bmaparray(struct vnode *, ufs_daddr_t, ufs_daddr_t *,
								struct indir *, int *, int *);
@


1.5
log
@remove obsolete vtrace guts; art@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_bmap.c,v 1.4 1999/04/25 00:36:46 millert Exp $	*/
/*	$NetBSD: ext2fs_bmap.c,v 1.1 1997/06/11 09:33:46 bouyer Exp $	*/
d60 1
d63 1
a63 1
static int ext2fs_bmaparray __P((struct vnode *, daddr_t, daddr_t *,
d112 2
a113 2
	register daddr_t bn;
	daddr_t *bnp;
d118 1
a118 1
	register struct inode *ip;
d124 1
a124 1
	daddr_t daddr;
d155 1
a155 1
		*bnp = blkptrtodb(ump, ip->i_e2fs_blocks[bn]);
d160 2
a161 2
				is_sequential(ump, ip->i_e2fs_blocks[bn - 1],
							  ip->i_e2fs_blocks[bn]);
d168 1
a168 1
	daddr = ip->i_e2fs_blocks[NDADDR + xap->in_off];
d171 7
d215 1
a215 1
		daddr = ((daddr_t *)bp->b_data)[xap->in_off];
d219 2
a220 2
				is_sequential(ump, ((daddr_t *)bp->b_data)[bn - 1],
				((daddr_t *)bp->b_data)[bn]);
@


1.4
log
@Reading large file from ext2fs caused vm_fault; gluk@@ecsc.mipt.ru
Approved by csapuntz@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.3 1997/06/12 21:09:31 downsj Exp $	*/
a52 1
#include <sys/trace.h>
d190 1
a190 1
			trace(TR_BREADHIT, pack(vp, size), metalbn);
a196 1
			trace(TR_BREADMISS, pack(vp, size), metalbn);
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.5 2000/06/23 02:14:39 mickey Exp $	*/
d53 1
d191 1
a191 1
			;
d198 1
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_bmap.c,v 1.4.4.1 2001/05/14 22:47:39 niklas Exp $	*/
/*	$NetBSD: ext2fs_bmap.c,v 1.5 2000/03/30 12:41:11 augustss Exp $	*/
a59 1
#include <ufs/ext2fs/ext2fs.h>
d62 1
a62 1
static int ext2fs_bmaparray __P((struct vnode *, ufs_daddr_t, ufs_daddr_t *,
d111 2
a112 2
	ufs_daddr_t bn;
	ufs_daddr_t *bnp;
d117 1
a117 1
	struct inode *ip;
d123 1
a123 1
	ufs_daddr_t daddr;
d154 1
a154 1
		*bnp = blkptrtodb(ump, fs2h32(ip->i_e2fs_blocks[bn]));
d159 2
a160 2
				is_sequential(ump, fs2h32(ip->i_e2fs_blocks[bn - 1]),
							  fs2h32(ip->i_e2fs_blocks[bn]));
d167 1
a167 1
	daddr = fs2h32(ip->i_e2fs_blocks[NDADDR + xap->in_off]);
a169 7

#ifdef DIAGNOSTIC
    if (num > NIADDR + 1 || num < 1) {
		printf("ext2fs_bmaparray: num=%d\n", num);
		panic("ext2fs_bmaparray: num");
	}
#endif
d207 1
a207 1
		daddr = fs2h32(((ufs_daddr_t *)bp->b_data)[xap->in_off]);
d211 2
a212 2
				is_sequential(ump, ((ufs_daddr_t *)bp->b_data)[bn - 1],
				((ufs_daddr_t *)bp->b_data)[bn]);
@


1.4.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a55 1
#include <ufs/ufs/extattr.h>
@


1.4.4.4
log
@Merge in -current from roughly a week ago
@
text
@d64 2
a65 2
static int ext2fs_bmaparray(struct vnode *, ufs_daddr_t, ufs_daddr_t *,
								struct indir *, int *, int *);
@


1.4.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.4.4.4 2002/03/28 14:54:25 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
d64 1
a64 1
static int ext2fs_bmaparray(struct vnode *, ufs1_daddr_t, ufs1_daddr_t *,
d113 2
a114 2
	ufs1_daddr_t bn;
	ufs1_daddr_t *bnp;
d125 1
a125 1
	ufs1_daddr_t daddr;
d216 1
a216 1
		daddr = fs2h32(((ufs1_daddr_t *)bp->b_data)[xap->in_off]);
d220 2
a221 2
				is_sequential(ump, ((ufs1_daddr_t *)bp->b_data)[bn - 1],
				((ufs1_daddr_t *)bp->b_data)[bn]);
@


1.3
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_bmap.c,v 1.2 1997/05/30 08:33:42 downsj Exp $	*/
d123 1
a123 1
	struct indir a[NIADDR], *xap;
@


1.2
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 2
a2 4
/*	$OpenBSD$	*/
/*	$NetBSD: ufs_bmap.c,v 1.3 1996/02/09 22:36:00 christos Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d5 1
d43 1
d92 1
a92 1
	    ap->a_runp));
d160 1
a160 1
			    is_sequential(ump, ip->i_e2fs_blocks[bn - 1],
d162 1
a162 1
			    ++bn, ++*runp);
d212 4
a215 4
			    bn < MNINDIR(ump) && *runp < maxrun &&
			    is_sequential(ump, ((daddr_t *)bp->b_data)[bn - 1],
			    ((daddr_t *)bp->b_data)[bn]);
			    ++bn, ++*runp);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@
