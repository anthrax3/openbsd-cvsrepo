head	1.97;
access;
symbols
	OPENBSD_6_1:1.97.0.2
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.93.0.2
	OPENBSD_6_0_BASE:1.93
	OPENBSD_5_9:1.85.0.2
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.85.0.4
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.84.0.2
	OPENBSD_5_7_BASE:1.84
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.68.0.2
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.65.0.2
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.64.0.6
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.4
	OPENBSD_5_0:1.64.0.2
	OPENBSD_5_0_BASE:1.64
	OPENBSD_4_9:1.59.0.2
	OPENBSD_4_9_BASE:1.59
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.52.0.6
	OPENBSD_4_6_BASE:1.52
	OPENBSD_4_5:1.52.0.2
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.49.0.4
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.45.0.4
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.2
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.25
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.97
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.96;
commitid	RlO92XR575sygHqm;

1.96
date	2016.09.07.17.30.12;	author natano;	state Exp;
branches;
next	1.95;
commitid	D0avTYSlvEmEjLyB;

1.95
date	2016.08.13.21.28.09;	author guenther;	state Exp;
branches;
next	1.94;
commitid	4rRWJtWC5CyaufQd;

1.94
date	2016.08.10.07.53.02;	author natano;	state Exp;
branches;
next	1.93;
commitid	q0VebnKSesRYhwvy;

1.93
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.92;
commitid	wHLNY5GFNXJSFYaC;

1.92
date	2016.06.19.10.21.56;	author dlg;	state Exp;
branches;
next	1.91;
commitid	J5HRbCm5olgUBGNw;

1.91
date	2016.05.22.20.27.04;	author bluhm;	state Exp;
branches;
next	1.90;
commitid	IMex9jbP378m0AFa;

1.90
date	2016.04.26.18.37.03;	author natano;	state Exp;
branches;
next	1.89;
commitid	WbumX8gCUOD8jZ5X;

1.89
date	2016.03.27.11.39.37;	author bluhm;	state Exp;
branches;
next	1.88;
commitid	C0IKsjKoZxFScK3M;

1.88
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.87;
commitid	gAjwyca5TfuoJAhn;

1.87
date	2016.03.17.18.52.31;	author bluhm;	state Exp;
branches;
next	1.86;
commitid	XOU3hWgTktDOU9BT;

1.86
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.85;
commitid	gFybgYMymUyTbVeS;

1.85
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.84;
commitid	p4LJxGKbi0BU2cG6;

1.84
date	2014.12.23.01.53.33;	author tedu;	state Exp;
branches;
next	1.83;
commitid	6nkNTy1tuOQfzz0f;

1.83
date	2014.07.31.19.11.38;	author pelikan;	state Exp;
branches;
next	1.82;
commitid	BRJHkrAVS231KELJ;

1.82
date	2014.07.31.17.37.52;	author pelikan;	state Exp;
branches;
next	1.81;
commitid	0juiBhtI3vf1GIxq;

1.81
date	2014.07.13.15.07.01;	author pelikan;	state Exp;
branches;
next	1.80;
commitid	CWlwOMbeCyL2ekFr;

1.80
date	2014.07.13.13.28.26;	author pelikan;	state Exp;
branches;
next	1.79;
commitid	dOiPqBMzR47FMb48;

1.79
date	2014.07.12.18.44.01;	author tedu;	state Exp;
branches;
next	1.78;
commitid	bDGgAR6yEQVcVl5u;

1.78
date	2014.07.12.13.23.59;	author pelikan;	state Exp;
branches;
next	1.77;
commitid	p6c0vj0ceN7w2MQB;

1.77
date	2014.07.12.11.03.11;	author pelikan;	state Exp;
branches;
next	1.76;
commitid	PkOKRAZpe243iG5G;

1.76
date	2014.07.12.09.30.02;	author pelikan;	state Exp;
branches;
next	1.75;
commitid	kYWw1DvnEB65yyQ1;

1.75
date	2014.07.12.09.04.35;	author pelikan;	state Exp;
branches;
next	1.74;
commitid	9skp5Q55F2d25iF3;

1.74
date	2014.07.12.08.53.38;	author pelikan;	state Exp;
branches;
next	1.73;
commitid	owpmzluLaSzlU64s;

1.73
date	2014.07.11.15.54.52;	author tobias;	state Exp;
branches;
next	1.72;
commitid	wNY0uOVg0D2FyJm1;

1.72
date	2014.07.11.14.30.52;	author pelikan;	state Exp;
branches;
next	1.71;
commitid	WfVjFNbKSMyZjiSF;

1.71
date	2014.05.27.14.31.24;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2013.12.12.19.00.09;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.65;

1.65
date	2012.09.10.11.11.00;	author jsing;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.04.04.15.26;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.03.18.23.10;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2011.06.30.15.08.59;	author jsing;	state Exp;
branches;
next	1.59;

1.59
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.23.18.40.00;	author oga;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.53;

1.53
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2008.11.24.00.01.20;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.23.23.52.35;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.12.12.27.27;	author blambert;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.06.23.50.55;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.17.20.15.25;	author jasper;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.02.00.45.50;	author pedro;	state Exp;
branches;
next	1.46;

1.46
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.14.22.03.01;	author pedro;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.11.21.06.10;	author pedro;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.11.20.46.28;	author pedro;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.30.10.35.08;	author pedro;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.06.00.24.17;	author pedro;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.06.17.43.14;	author pedro;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.28.23.11.25;	author pedro;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.03.20.14.01;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.30.13.58.55;	author niallo;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.26.21.22.14;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.04.08.06.04;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.06.17.41.03;	author grange;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.25.23.26.55;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.06.09.02.11;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.29.17.45.20;	author fgsch;	state Exp;
branches
	1.25.2.1
	1.25.4.1;
next	1.24;

1.24
date	2002.07.28.21.22.27;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.21.22.21.48;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.18.01.46.40;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.04.06.32.41;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.20.01.50.12;	author assar;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.26.23.24.41;	author jasoni;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.07.04.57.18;	author assar;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.05.31.17.34.53;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.02.08.22.41.48;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	98.01.09.20.41.54;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.11.10.19.30.24;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.11.09.13.12.17;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.59.15;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.06.20.14.04.31;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.12.21.09.35;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.05.30.08.34.06;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.05.18.51;	author downsj;	state Exp;
branches;
next	;

1.11.2.1
date	2001.05.14.22.47.39;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2004.02.19.11.01.36;	author niklas;	state Exp;
branches;
next	1.11.2.9;

1.11.2.9
date	2004.06.05.23.13.10;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2003.05.20.04.18.42;	author tedu;	state Exp;
branches;
next	;

1.25.2.1
date	2003.08.03.23.19.27;	author brad;	state Exp;
branches;
next	;

1.25.4.1
date	2003.07.16.18.04.56;	author brad;	state Exp;
branches;
next	;


desc
@@


1.97
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: ext2fs_vfsops.c,v 1.96 2016/09/07 17:30:12 natano Exp $	*/
/*	$NetBSD: ext2fs_vfsops.c,v 1.1 1997/06/11 09:34:07 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1989, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *	notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *	notice, this list of conditions and the following disclaimer in the
 *	documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *	may be used to endorse or promote products derived from this software
 *	without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_vfsops.c	8.14 (Berkeley) 11/28/94
 * Modified for ext2fs by Manuel Bouyer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/socket.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/disk.h>
#include <sys/mbuf.h>
#include <sys/file.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/lock.h>
#include <sys/dkio.h>
#include <sys/specdev.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ext2fs/ext2fs_extern.h>

extern struct lock ufs_hashlock;

int ext2fs_sbupdate(struct ufsmount *, int);
static int	e2fs_sbcheck(struct ext2fs *, int);

const struct vfsops ext2fs_vfsops = {
	ext2fs_mount,
	ufs_start,
	ext2fs_unmount,
	ufs_root,
	ufs_quotactl,
	ext2fs_statfs,
	ext2fs_sync,
	ext2fs_vget,
	ext2fs_fhtovp,
	ext2fs_vptofh,
	ext2fs_init,
	ext2fs_sysctl,
	ufs_check_export
};

struct pool ext2fs_inode_pool;
struct pool ext2fs_dinode_pool;

extern u_long ext2gennumber;

int
ext2fs_init(struct vfsconf *vfsp)
{
	pool_init(&ext2fs_inode_pool, sizeof(struct inode), 0,
	    IPL_NONE, PR_WAITOK, "ext2inopl", NULL);
	pool_init(&ext2fs_dinode_pool, sizeof(struct ext2fs_dinode), 0,
	    IPL_NONE, PR_WAITOK, "ext2dinopl", NULL);

	return (ufs_init(vfsp));
}

/*
 * Called by main() when ext2fs is going to be mounted as root.
 *
 * Name is updated by mount(8) after booting.
 */
#define ROOTNAME	"root_device"

int
ext2fs_mountroot(void)
{
	struct m_ext2fs *fs;
        struct mount *mp;
	struct proc *p = curproc;	/* XXX */
	struct ufsmount *ump;
	int error;

	/*
	 * Get vnodes for swapdev and rootdev.
	 */
	if (bdevvp(swapdev, &swapdev_vp) || bdevvp(rootdev, &rootvp))
		panic("ext2fs_mountroot: can't setup bdevvp's");

	if ((error = vfs_rootmountalloc("ext2fs", "root_device", &mp)) != 0) {
		vrele(rootvp);
		return (error);
	}

	if ((error = ext2fs_mountfs(rootvp, mp, p)) != 0) {
		mp->mnt_vfc->vfc_refcount--;
		vfs_unbusy(mp);
		free(mp, M_MOUNT, sizeof *mp);
		vrele(rootvp);
		return (error);
	}

	TAILQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	ump = VFSTOUFS(mp);
	fs = ump->um_e2fs;
	memset(fs->e2fs_fsmnt, 0, sizeof(fs->e2fs_fsmnt));
	strlcpy(fs->e2fs_fsmnt, mp->mnt_stat.f_mntonname, sizeof(fs->e2fs_fsmnt));
	if (fs->e2fs.e2fs_rev > E2FS_REV0) {
		memset(fs->e2fs.e2fs_fsmnt, 0, sizeof(fs->e2fs.e2fs_fsmnt));
		strlcpy(fs->e2fs.e2fs_fsmnt, mp->mnt_stat.f_mntonname,
		    sizeof(fs->e2fs.e2fs_fsmnt));
	}
	(void)ext2fs_statfs(mp, &mp->mnt_stat, p);
	vfs_unbusy(mp);
	inittodr(fs->e2fs.e2fs_wtime);
	return (0);
}

/*
 * VFS Operations.
 *
 * mount system call
 */
int
ext2fs_mount(struct mount *mp, const char *path, void *data,
    struct nameidata *ndp, struct proc *p)
{
	struct vnode *devvp;
	struct ufs_args args;
	struct ufsmount *ump = NULL;
	struct m_ext2fs *fs;
	char fname[MNAMELEN];
	char fspec[MNAMELEN];
	int error, flags;

	error = copyin(data, &args, sizeof(struct ufs_args));
	if (error)
		return (error);

	/*
	 * If updating, check whether changing from read-only to
	 * read/write; if there is no device name, that's all we do.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		ump = VFSTOUFS(mp);
		fs = ump->um_e2fs;
		if (fs->e2fs_ronly == 0 && (mp->mnt_flag & MNT_RDONLY)) {
			flags = WRITECLOSE;
			if (mp->mnt_flag & MNT_FORCE)
				flags |= FORCECLOSE;
			error = ext2fs_flushfiles(mp, flags, p);
			if (error == 0 &&
			    ext2fs_cgupdate(ump, MNT_WAIT) == 0 &&
			    (fs->e2fs.e2fs_state & E2FS_ERRORS) == 0) {
				fs->e2fs.e2fs_state = E2FS_ISCLEAN;
				(void)ext2fs_sbupdate(ump, MNT_WAIT);
			}
			if (error)
				return (error);
			fs->e2fs_ronly = 1;
		}
		if (mp->mnt_flag & MNT_RELOAD) {
			error = ext2fs_reload(mp, ndp->ni_cnd.cn_cred, p);
			if (error)
				return (error);
		}
		if (fs->e2fs_ronly && (mp->mnt_flag & MNT_WANTRDWR)) {
			fs->e2fs_ronly = 0;
			if (fs->e2fs.e2fs_state == E2FS_ISCLEAN)
				fs->e2fs.e2fs_state = 0;
			else
				fs->e2fs.e2fs_state = E2FS_ERRORS;
			fs->e2fs_fmod = 1;
		}
		if (args.fspec == NULL) {
			/*
			 * Process export requests.
			 */
			return (vfs_export(mp, &ump->um_export,
			    &args.export_info));
		}
	}
	/*
	 * Not an update, or updating the name: look up the name
	 * and verify that it refers to a sensible block device.
	 */
	error = copyinstr(args.fspec, fspec, sizeof(fspec), NULL);
	if (error)
		goto error;

	if (disk_map(fspec, fname, MNAMELEN, DM_OPENBLCK) == -1)
		memcpy(fname, fspec, sizeof(fname));

	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fname, p);
	if ((error = namei(ndp)) != 0)
		goto error;
	devvp = ndp->ni_vp;

	if (devvp->v_type != VBLK) {
		error = ENOTBLK;
		goto error_devvp;
	}
	if (major(devvp->v_rdev) >= nblkdev) {
		error = ENXIO;
		goto error_devvp;
	}
	if ((mp->mnt_flag & MNT_UPDATE) == 0)
		error = ext2fs_mountfs(devvp, mp, p);
	else {
		if (devvp != ump->um_devvp)
			error = EINVAL;	/* XXX needs translation */
		else
			vrele(devvp);
	}
	if (error)
		goto error_devvp;
	ump = VFSTOUFS(mp);
	fs = ump->um_e2fs;

	memset(fs->e2fs_fsmnt, 0, sizeof(fs->e2fs_fsmnt));
	strlcpy(fs->e2fs_fsmnt, path, sizeof(fs->e2fs_fsmnt));
	if (fs->e2fs.e2fs_rev > E2FS_REV0) {
		memset(fs->e2fs.e2fs_fsmnt, 0, sizeof(fs->e2fs.e2fs_fsmnt));
		strlcpy(fs->e2fs.e2fs_fsmnt, mp->mnt_stat.f_mntonname,
		    sizeof(fs->e2fs.e2fs_fsmnt));
	}
	memcpy(mp->mnt_stat.f_mntonname, fs->e2fs_fsmnt, MNAMELEN);
	memset(mp->mnt_stat.f_mntfromname, 0, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromname, fname, MNAMELEN);
	memset(mp->mnt_stat.f_mntfromspec, 0, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);
	memcpy(&mp->mnt_stat.mount_info.ufs_args, &args, sizeof(args));

	if (fs->e2fs_fmod != 0) {	/* XXX */
		fs->e2fs_fmod = 0;
		if (fs->e2fs.e2fs_state == 0)
			fs->e2fs.e2fs_wtime = time_second;
		else
			printf("%s: file system not clean; please fsck(8)\n",
			    mp->mnt_stat.f_mntfromname);
		ext2fs_cgupdate(ump, MNT_WAIT);
	}

	goto success;

error_devvp:
	/* Error with devvp held. */
	vrele(devvp);

error:
	/* Error with no state to backout. */

success:
	return (error);
}

int ext2fs_reload_vnode(struct vnode *, void *args);

struct ext2fs_reload_args {
	struct m_ext2fs *fs;
	struct proc *p;
	struct ucred *cred;
	struct vnode *devvp;
};

int
ext2fs_reload_vnode(struct vnode *vp, void *args)
{
	struct ext2fs_reload_args *era = args;
	struct buf *bp;
	struct inode *ip;
	int error;
	caddr_t cp;

	/*
	 * Step 4: invalidate all inactive vnodes.
	 */
	if (vp->v_usecount == 0) {
		vgonel(vp, era->p);
		return (0);
	}

	/*
	 * Step 5: invalidate all cached file data.
	 */
	if (vget(vp, LK_EXCLUSIVE, era->p))
		return (0);

	if (vinvalbuf(vp, 0, era->cred, era->p, 0, 0))
		panic("ext2fs_reload: dirty2");
	/*
	 * Step 6: re-read inode data for all active vnodes.
	 */
	ip = VTOI(vp);
	error = bread(era->devvp,
	    fsbtodb(era->fs, ino_to_fsba(era->fs, ip->i_number)),
	    (int)era->fs->e2fs_bsize, &bp);
	if (error) {
		vput(vp);
		return (error);
	}
	cp = (caddr_t)bp->b_data +
	    (ino_to_fsbo(era->fs, ip->i_number) * EXT2_DINODE_SIZE(era->fs));
	e2fs_iload(era->fs, (struct ext2fs_dinode *)cp, ip->i_e2din);
	brelse(bp);
	vput(vp);
	return (0);
}

static off_t
ext2fs_maxfilesize(struct m_ext2fs *fs)
{
	bool huge = fs->e2fs.e2fs_features_rocompat & EXT2F_ROCOMPAT_HUGE_FILE;
	off_t b = fs->e2fs_bsize / 4;
	off_t physically, logically;

	physically = dbtob(huge ? ((1ULL << 48) - 1) : UINT_MAX);
	logically = (12ULL + b + b*b + b*b*b) * fs->e2fs_bsize;

	return MIN(logically, physically);
}

static int
e2fs_sbfill(struct vnode *devvp, struct m_ext2fs *fs)
{
	struct buf *bp = NULL;
	int i, error;

	/* XXX assume hardware block size == 512 */
	fs->e2fs_ncg = howmany(fs->e2fs.e2fs_bcount - fs->e2fs.e2fs_first_dblock,
	    fs->e2fs.e2fs_bpg);
	fs->e2fs_fsbtodb = fs->e2fs.e2fs_log_bsize + 1;
	fs->e2fs_bsize = 1024 << fs->e2fs.e2fs_log_bsize;
	fs->e2fs_bshift = LOG_MINBSIZE + fs->e2fs.e2fs_log_bsize;
	fs->e2fs_fsize = 1024 << fs->e2fs.e2fs_log_fsize;

	fs->e2fs_qbmask = fs->e2fs_bsize - 1;
	fs->e2fs_bmask = ~fs->e2fs_qbmask;

	fs->e2fs_ipb = fs->e2fs_bsize / EXT2_DINODE_SIZE(fs);
	fs->e2fs_itpg = fs->e2fs.e2fs_ipg / fs->e2fs_ipb;

	/* Re-read group descriptors from the disk. */
	fs->e2fs_ngdb = howmany(fs->e2fs_ncg,
	    fs->e2fs_bsize / sizeof(struct ext2_gd));
	fs->e2fs_gd = mallocarray(fs->e2fs_ngdb, fs->e2fs_bsize,
	    M_UFSMNT, M_WAITOK);

	for (i = 0; i < fs->e2fs_ngdb; ++i) {
		daddr_t dblk = ((fs->e2fs_bsize > 1024) ? 0 : 1) + i + 1;
		size_t gdesc = i * fs->e2fs_bsize / sizeof(struct ext2_gd);
		struct ext2_gd *gd;

		error = bread(devvp, fsbtodb(fs, dblk), fs->e2fs_bsize, &bp);
		if (error) {
			size_t gdescs_space = fs->e2fs_ngdb * fs->e2fs_bsize;

			free(fs->e2fs_gd, M_UFSMNT, gdescs_space);
			fs->e2fs_gd = NULL;
			brelse(bp);
			return (error);
		}

		gd = (struct ext2_gd *) bp->b_data;
		e2fs_cgload(gd, fs->e2fs_gd + gdesc, fs->e2fs_bsize);
		brelse(bp);
		bp = NULL;
	}

	if ((fs->e2fs.e2fs_features_rocompat & EXT2F_ROCOMPAT_LARGEFILE) == 0 ||
	    (fs->e2fs.e2fs_rev == E2FS_REV0))
		fs->e2fs_maxfilesize = INT_MAX;
	else
		fs->e2fs_maxfilesize = ext2fs_maxfilesize(fs);

	if (fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_EXTENTS)
		fs->e2fs_maxfilesize *= 4;

	return (0);
}

/*
 * Reload all incore data for a filesystem (used after running fsck on
 * the root filesystem and finding things to fix). The filesystem must
 * be mounted read-only.
 *
 * Things to do to update the mount:
 *	1) invalidate all cached meta-data.
 *	2) re-read superblock from disk.
 *	3) re-read summary information from disk.
 *	4) invalidate all inactive vnodes.
 *	5) invalidate all cached file data.
 *	6) re-read inode data for all active vnodes.
 */
int
ext2fs_reload(struct mount *mountp, struct ucred *cred, struct proc *p)
{
	struct vnode *devvp;
	struct buf *bp;
	struct m_ext2fs *fs;
	struct ext2fs *newfs;
	int error;
	struct ext2fs_reload_args era;

	if ((mountp->mnt_flag & MNT_RDONLY) == 0)
		return (EINVAL);
	/*
	 * Step 1: invalidate all cached meta-data.
	 */
	devvp = VFSTOUFS(mountp)->um_devvp;
	if (vinvalbuf(devvp, 0, cred, p, 0, 0))
		panic("ext2fs_reload: dirty1");

	/*
	 * Step 2: re-read superblock from disk.
	 */
	error = bread(devvp, (daddr_t)(SBOFF / DEV_BSIZE), SBSIZE, &bp);
	if (error) {
		brelse(bp);
		return (error);
	}
	newfs = (struct ext2fs *)bp->b_data;
	error = e2fs_sbcheck(newfs, (mountp->mnt_flag & MNT_RDONLY));
	if (error) {
		brelse(bp);
		return (error);
	}

	fs = VFSTOUFS(mountp)->um_e2fs;
	/*
	 * Copy in the new superblock, compute in-memory values
	 * and load group descriptors.
	 */
	e2fs_sbload(newfs, &fs->e2fs);
	if ((error = e2fs_sbfill(devvp, fs)) != 0)
		return (error);

	era.p = p;
	era.cred = cred;
	era.fs = fs;
	era.devvp = devvp;

	error = vfs_mount_foreach_vnode(mountp, ext2fs_reload_vnode, &era);

	return (error);
}

/*
 * Common code for mount and mountroot
 */
int
ext2fs_mountfs(struct vnode *devvp, struct mount *mp, struct proc *p)
{
	struct ufsmount *ump;
	struct buf *bp;
	struct ext2fs *fs;
	dev_t dev;
	int error, ronly;
	struct ucred *cred;

	dev = devvp->v_rdev;
	cred = p ? p->p_ucred : NOCRED;
	/*
	 * Disallow multiple mounts of the same device.
	 * Disallow mounting of a device that is currently in use
	 * (except for root, which might share swap device for miniroot).
	 * Flush out any old buffers remaining from a previous use.
	 */
	if ((error = vfs_mountedon(devvp)) != 0)
		return (error);
	if (vcount(devvp) > 1 && devvp != rootvp)
		return (EBUSY);
	if ((error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0)) != 0)
		return (error);

	ronly = (mp->mnt_flag & MNT_RDONLY) != 0;
	error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p);
	if (error)
		return (error);

	bp = NULL;
	ump = NULL;

	/*
	 * Read the superblock from disk.
	 */
	error = bread(devvp, (daddr_t)(SBOFF / DEV_BSIZE), SBSIZE, &bp);
	if (error)
		goto out;
	fs = (struct ext2fs *)bp->b_data;
	error = e2fs_sbcheck(fs, ronly);
	if (error)
		goto out;

	ump = malloc(sizeof *ump, M_UFSMNT, M_WAITOK | M_ZERO);
	ump->um_e2fs = malloc(sizeof(struct m_ext2fs), M_UFSMNT,
	    M_WAITOK | M_ZERO);

	/*
	 * Copy in the superblock, compute in-memory values
	 * and load group descriptors.
	 */
	e2fs_sbload(fs, &ump->um_e2fs->e2fs);
	if ((error = e2fs_sbfill(devvp, ump->um_e2fs)) != 0)
		goto out;
	brelse(bp);
	bp = NULL;
	fs = &ump->um_e2fs->e2fs;
	ump->um_e2fs->e2fs_ronly = ronly;
	ump->um_fstype = UM_EXT2FS;

	if (ronly == 0) {
		if (fs->e2fs_state == E2FS_ISCLEAN)
			fs->e2fs_state = 0;
		else
			fs->e2fs_state = E2FS_ERRORS;
		ump->um_e2fs->e2fs_fmod = 1;
	}

	mp->mnt_data = ump;
	mp->mnt_stat.f_fsid.val[0] = (long)dev;
	mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
	mp->mnt_stat.f_namemax = MAXNAMLEN;
	mp->mnt_flag |= MNT_LOCAL;
	ump->um_mountp = mp;
	ump->um_dev = dev;
	ump->um_devvp = devvp;
	ump->um_nindir = NINDIR(ump->um_e2fs);
	ump->um_bptrtodb = ump->um_e2fs->e2fs_fsbtodb;
	ump->um_seqinc = 1; /* no frags */
	ump->um_maxsymlinklen = EXT2_MAXSYMLINKLEN;
	devvp->v_specmountpoint = mp;
	return (0);
out:
	if (devvp->v_specinfo)
		devvp->v_specmountpoint = NULL;
	if (bp)
		brelse(bp);
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	(void)VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, cred, p);
	VOP_UNLOCK(devvp, p);
	if (ump) {
		free(ump->um_e2fs, M_UFSMNT, sizeof *ump->um_e2fs);
		free(ump, M_UFSMNT, sizeof *ump);
		mp->mnt_data = NULL;
	}
	return (error);
}

/*
 * unmount system call
 */
int
ext2fs_unmount(struct mount *mp, int mntflags, struct proc *p)
{
	struct ufsmount *ump;
	struct m_ext2fs *fs;
	int error, flags;
	size_t gdescs_space;

	flags = 0;
	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;
	if ((error = ext2fs_flushfiles(mp, flags, p)) != 0)
		return (error);
	ump = VFSTOUFS(mp);
	fs = ump->um_e2fs;
	gdescs_space = fs->e2fs_ngdb * fs->e2fs_bsize;

	if (!fs->e2fs_ronly && ext2fs_cgupdate(ump, MNT_WAIT) == 0 &&
	    (fs->e2fs.e2fs_state & E2FS_ERRORS) == 0) {
		fs->e2fs.e2fs_state = E2FS_ISCLEAN;
		(void) ext2fs_sbupdate(ump, MNT_WAIT);
	}

	if (ump->um_devvp->v_type != VBAD)
		ump->um_devvp->v_specmountpoint = NULL;
	vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
	(void)VOP_CLOSE(ump->um_devvp, fs->e2fs_ronly ? FREAD : FREAD|FWRITE,
	    NOCRED, p);
	vput(ump->um_devvp);
	free(fs->e2fs_gd, M_UFSMNT, gdescs_space);
	free(fs, M_UFSMNT, sizeof *fs);
	free(ump, M_UFSMNT, sizeof *ump);
	mp->mnt_data = NULL;
	mp->mnt_flag &= ~MNT_LOCAL;
	return (0);
}

/*
 * Flush out all the files in a filesystem.
 */
int
ext2fs_flushfiles(struct mount *mp, int flags, struct proc *p)
{
	struct ufsmount *ump;
	int error;

	ump = VFSTOUFS(mp);
	/*
	 * Flush all the files.
	 */
	if ((error = vflush(mp, NULL, flags)) != 0)
		return (error);
	/*
	 * Flush filesystem metadata.
	 */
	vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = VOP_FSYNC(ump->um_devvp, p->p_ucred, MNT_WAIT, p);
	VOP_UNLOCK(ump->um_devvp, p);
	return (error);
}

/*
 * Get file system statistics.
 */
int
ext2fs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	struct ufsmount *ump;
	struct m_ext2fs *fs;
	u_int32_t overhead, overhead_per_group;
	int i, ngroups;

	ump = VFSTOUFS(mp);
	fs = ump->um_e2fs;
	if (fs->e2fs.e2fs_magic != E2FS_MAGIC)
		panic("ext2fs_statfs");

	/*
	 * Compute the overhead (FS structures)
	 */
	overhead_per_group = 1 /* block bitmap */ + 1 /* inode bitmap */ +
	    fs->e2fs_itpg;
	overhead = fs->e2fs.e2fs_first_dblock +
	    fs->e2fs_ncg * overhead_per_group;
	if (fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    fs->e2fs.e2fs_features_rocompat & EXT2F_ROCOMPAT_SPARSESUPER) {
		for (i = 0, ngroups = 0; i < fs->e2fs_ncg; i++) {
			if (cg_has_sb(i))
				ngroups++;
		}
	} else {
		ngroups = fs->e2fs_ncg;
	}
	overhead += ngroups * (1 + fs->e2fs_ngdb);

	sbp->f_bsize = fs->e2fs_bsize;
	sbp->f_iosize = fs->e2fs_bsize;
	sbp->f_blocks = fs->e2fs.e2fs_bcount - overhead;
	sbp->f_bfree = fs->e2fs.e2fs_fbcount;
	sbp->f_bavail = sbp->f_bfree - fs->e2fs.e2fs_rbcount;
	sbp->f_files =  fs->e2fs.e2fs_icount;
	sbp->f_favail = sbp->f_ffree = fs->e2fs.e2fs_ficount;
	copy_statfs_info(sbp, mp);

	return (0);
}

int ext2fs_sync_vnode(struct vnode *vp, void *);

struct ext2fs_sync_args {
	int allerror;
	int waitfor;
	struct proc *p;
	struct ucred *cred;
};

int
ext2fs_sync_vnode(struct vnode *vp, void *args)
{
	struct ext2fs_sync_args *esa = args;
	struct inode *ip;
	int error;

	ip = VTOI(vp);
	if (vp->v_type == VNON ||
	    ((ip->i_flag & (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
	    LIST_EMPTY(&vp->v_dirtyblkhd)) ||
	    esa->waitfor == MNT_LAZY) {
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT, esa->p))
		return (0);

	if ((error = VOP_FSYNC(vp, esa->cred, esa->waitfor, esa->p)) != 0)
		esa->allerror = error;
	vput(vp);
	return (0);
}
/*
 * Go through the disk queues to initiate sandbagged IO;
 * go through the inodes to write those that have been modified;
 * initiate the writing of the super block if it has been modified.
 *
 * Should always be called with the mount point locked.
 */
int
ext2fs_sync(struct mount *mp, int waitfor, struct ucred *cred, struct proc *p)
{
	struct ufsmount *ump = VFSTOUFS(mp);
	struct m_ext2fs *fs;
	int error, allerror = 0;
	struct ext2fs_sync_args esa;

	fs = ump->um_e2fs;
	if (fs->e2fs_ronly != 0) {		/* XXX */
		printf("fs = %s\n", fs->e2fs_fsmnt);
		panic("update: rofs mod");
	}

	/*
	 * Write back each (modified) inode.
	 */
	esa.p = p;
	esa.cred = cred;
	esa.allerror = 0;
	esa.waitfor = waitfor;

	vfs_mount_foreach_vnode(mp, ext2fs_sync_vnode, &esa);
	if (esa.allerror != 0)
		allerror = esa.allerror;

	/*
	 * Force stale file system control information to be flushed.
	 */
	if (waitfor != MNT_LAZY) {
		vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
		if ((error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p)) != 0)
			allerror = error;
		VOP_UNLOCK(ump->um_devvp, p);
	}
	/*
	 * Write back modified superblock.
	 */
	if (fs->e2fs_fmod != 0) {
		fs->e2fs_fmod = 0;
		fs->e2fs.e2fs_wtime = time_second;
		if ((error = ext2fs_cgupdate(ump, waitfor)))
			allerror = error;
	}
	return (allerror);
}

/*
 * Look up a EXT2FS dinode number to find its incore vnode, otherwise read it
 * in from disk.  If it is in core, wait for the lock bit to clear, then
 * return the inode locked.  Detection and handling of mount points must be
 * done by the calling routine.
 */
int
ext2fs_vget(struct mount *mp, ino_t ino, struct vnode **vpp)
{
	struct m_ext2fs *fs;
	struct inode *ip;
	struct ext2fs_dinode *dp;
	struct ufsmount *ump;
	struct buf *bp;
	struct vnode *vp;
	dev_t dev;
	int error;

	if (ino > (ufsino_t)-1)
		panic("ext2fs_vget: alien ino_t %llu",
		    (unsigned long long)ino);

	ump = VFSTOUFS(mp);
	dev = ump->um_dev;

 retry:
	if ((*vpp = ufs_ihashget(dev, ino)) != NULL)
		return (0);

	/* Allocate a new vnode/inode. */
	if ((error = getnewvnode(VT_EXT2FS, mp, &ext2fs_vops, &vp)) != 0) {
		*vpp = NULL;
		return (error);
	}

	ip = pool_get(&ext2fs_inode_pool, PR_WAITOK|PR_ZERO);
	rrw_init(&ip->i_lock, "inode");
	vp->v_data = ip;
	ip->i_vnode = vp;
	ip->i_ump = ump;
	ip->i_e2fs = fs = ump->um_e2fs;
	ip->i_dev = dev;
	ip->i_number = ino;
	ip->i_e2fs_last_lblk = 0;
	ip->i_e2fs_last_blk = 0;

	/*
	 * Put it onto its hash chain and lock it so that other requests for
	 * this inode will block if they arrive while we are sleeping waiting
	 * for old data structures to be purged or for the contents of the
	 * disk portion of this inode to be read.
	 */
	error = ufs_ihashins(ip);

	if (error) {
		vrele(vp);

		if (error == EEXIST)
			goto retry;

		return (error);
	}

	/* Read in the disk contents for the inode, copy into the inode. */
	error = bread(ump->um_devvp, fsbtodb(fs, ino_to_fsba(fs, ino)),
	    (int)fs->e2fs_bsize, &bp);
	if (error) {
		/*
		 * The inode does not contain anything useful, so it would
	 	 * be misleading to leave it on its hash chain. With mode
		 * still zero, it will be unlinked and returned to the free
		 * list by vput().
		 */
		vput(vp);
		brelse(bp);
		*vpp = NULL;
		return (error);
	}

	dp = (struct ext2fs_dinode *) ((char *)bp->b_data
	    + EXT2_DINODE_SIZE(fs) * ino_to_fsbo(fs, ino));

	ip->i_e2din = pool_get(&ext2fs_dinode_pool, PR_WAITOK);
	e2fs_iload(fs, dp, ip->i_e2din);
	brelse(bp);

	ip->i_effnlink = ip->i_e2fs_nlink;

	/*
	 * The fields for storing the UID and GID of an ext2fs inode are
	 * limited to 16 bits. To overcome this limitation, Linux decided to
	 * scatter the highest bits of these values into a previously reserved
	 * area on the disk inode. We deal with this situation by having two
	 * 32-bit fields *out* of the disk inode to hold the complete values.
	 * Now that we are reading in the inode, compute these fields.
	 */
	ip->i_e2fs_uid = ip->i_e2fs_uid_low | (ip->i_e2fs_uid_high << 16);
	ip->i_e2fs_gid = ip->i_e2fs_gid_low | (ip->i_e2fs_gid_high << 16);

	/* If the inode was deleted, reset all fields */
	if (ip->i_e2fs_dtime != 0) {
		ip->i_e2fs_mode = ip->i_e2fs_nblock = 0;
		(void)ext2fs_setsize(ip, 0);
	}

	/*
	 * Initialize the vnode from the inode, check for aliases.
	 * Note that the underlying vnode may have changed.
	 */
	error = ext2fs_vinit(mp, &vp);
	if (error) {
		vput(vp);
		*vpp = NULL;
		return (error);
	}

	/*
	 * Finish inode initialization now that aliasing has been resolved.
	 */
	vref(ip->i_devvp);
	/*
	 * Set up a generation number for this inode if it does not
	 * already have one. This should only happen on old filesystems.
	 */
	if (ip->i_e2fs_gen == 0) {
		if (++ext2gennumber < (u_long)time_second)
			ext2gennumber = time_second;
		ip->i_e2fs_gen = ext2gennumber;
		if ((vp->v_mount->mnt_flag & MNT_RDONLY) == 0)
			ip->i_flag |= IN_MODIFIED;
	}

	*vpp = vp;
	return (0);
}

/*
 * File handle to vnode
 *
 * Have to be really careful about stale file handles:
 * - check that the inode number is valid
 * - call ext2fs_vget() to get the locked inode
 * - check for an unallocated inode (i_mode == 0)
 * - check that the given client host has export rights and return
 *   those rights via. exflagsp and credanonp
 */
int
ext2fs_fhtovp(struct mount *mp, struct fid *fhp, struct vnode **vpp)
{
	struct inode *ip;
	struct vnode *nvp;
	int error;
	struct ufid *ufhp;
	struct m_ext2fs *fs;

	ufhp = (struct ufid *)fhp;
	fs = VFSTOUFS(mp)->um_e2fs;
	if ((ufhp->ufid_ino < EXT2_FIRSTINO && ufhp->ufid_ino != EXT2_ROOTINO) ||
	    ufhp->ufid_ino > fs->e2fs_ncg * fs->e2fs.e2fs_ipg)
		return (ESTALE);

	if ((error = VFS_VGET(mp, ufhp->ufid_ino, &nvp)) != 0) {
		*vpp = NULLVP;
		return (error);
	}
	ip = VTOI(nvp);
	if (ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime != 0 ||
	    ip->i_e2fs_gen != ufhp->ufid_gen) {
		vput(nvp);
		*vpp = NULLVP;
		return (ESTALE);
	}
	*vpp = nvp;
	return (0);
}

/*
 * Vnode pointer to File handle
 */
/* ARGSUSED */
int
ext2fs_vptofh(struct vnode *vp, struct fid *fhp)
{
	struct inode *ip;
	struct ufid *ufhp;

	ip = VTOI(vp);
	ufhp = (struct ufid *)fhp;
	ufhp->ufid_len = sizeof(struct ufid);
	ufhp->ufid_ino = ip->i_number;
	ufhp->ufid_gen = ip->i_e2fs_gen;
	return (0);
}

/*
 * no sysctl for ext2fs
 */

int
ext2fs_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen, struct proc *p)
{
	return (EOPNOTSUPP);
}

/*
 * Write a superblock and associated information back to disk.
 */
int
ext2fs_sbupdate(struct ufsmount *mp, int waitfor)
{
	struct m_ext2fs *fs = mp->um_e2fs;
	struct buf *bp;
	int error = 0;

	bp = getblk(mp->um_devvp, SBLOCK, SBSIZE, 0, 0);
	e2fs_sbsave(&fs->e2fs, (struct ext2fs *) bp->b_data);
	if (waitfor == MNT_WAIT)
		error = bwrite(bp);
	else
		bawrite(bp);
	return (error);
}

int
ext2fs_cgupdate(struct ufsmount *mp, int waitfor)
{
	struct m_ext2fs *fs = mp->um_e2fs;
	struct buf *bp;
	int i, error = 0, allerror = 0;

	allerror = ext2fs_sbupdate(mp, waitfor);
	for (i = 0; i < fs->e2fs_ngdb; i++) {
		bp = getblk(mp->um_devvp, fsbtodb(fs, ((fs->e2fs_bsize>1024)?0:1)+i+1),
		    fs->e2fs_bsize, 0, 0);
		e2fs_cgsave(&fs->e2fs_gd[i* fs->e2fs_bsize / sizeof(struct ext2_gd)], (struct ext2_gd*)bp->b_data, fs->e2fs_bsize);
		if (waitfor == MNT_WAIT)
			error = bwrite(bp);
		else
			bawrite(bp);
	}

	if (!allerror && error)
		allerror = error;
	return (allerror);
}

/* This is called before the superblock is copied.  Watch out for endianity! */
static int
e2fs_sbcheck(struct ext2fs *fs, int ronly)
{
	u_int32_t tmp;

	tmp = letoh16(fs->e2fs_magic);
	if (tmp != E2FS_MAGIC) {
		printf("ext2fs: wrong magic number 0x%x\n", tmp);
		return (EIO);		/* XXX needs translation */
	}

	tmp = letoh32(fs->e2fs_log_bsize);
	if (tmp > 2) {
		/* skewed log(block size): 1024 -> 0 | 2048 -> 1 | 4096 -> 2 */
		tmp += 10;
		printf("ext2fs: wrong log2(block size) %d\n", tmp);
		return (EIO);	   /* XXX needs translation */
	}

	if (fs->e2fs_bpg == 0) {
		printf("ext2fs: zero blocks per group\n");
		return (EIO);
	}

	tmp = letoh32(fs->e2fs_rev);
	if (tmp > E2FS_REV1) {
		printf("ext2fs: wrong revision number 0x%x\n", tmp);
		return (EIO);		/* XXX needs translation */
	}
	else if (tmp == E2FS_REV0)
		return (0);

	tmp = letoh32(fs->e2fs_first_ino);
	if (tmp != EXT2_FIRSTINO) {
		printf("ext2fs: first inode at 0x%x\n", tmp);
		return (EINVAL);      /* XXX needs translation */
	}

	tmp = letoh32(fs->e2fs_features_incompat);
	if (tmp & ~(EXT2F_INCOMPAT_SUPP | EXT4F_RO_INCOMPAT_SUPP)) {
		printf("ext2fs: unsupported incompat features 0x%x\n", tmp);
		return (EINVAL);      /* XXX needs translation */
	}

	if (!ronly && (tmp & EXT4F_RO_INCOMPAT_SUPP)) {
		printf("ext4fs: only read-only support right now\n");
		return (EROFS);      /* XXX needs translation */
	}

	if (tmp & EXT2F_INCOMPAT_RECOVER) {
		printf("ext2fs: your file system says it needs recovery\n");
		if (!ronly)
			return (EROFS);	/* XXX needs translation */
	}

	tmp = letoh32(fs->e2fs_features_rocompat);
	if (!ronly && (tmp & ~EXT2F_ROCOMPAT_SUPP)) {
		printf("ext2fs: unsupported R/O compat features 0x%x\n", tmp);
		return (EROFS);      /* XXX needs translation */
	}

	return (0);
}
@


1.96
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.95 2016/08/13 21:28:09 guenther Exp $	*/
d96 4
a99 6
	pool_init(&ext2fs_inode_pool, sizeof(struct inode), 0, 0, PR_WAITOK,
	    "ext2inopl", NULL);
	pool_setipl(&ext2fs_inode_pool, IPL_NONE);
	pool_init(&ext2fs_dinode_pool, sizeof(struct ext2fs_dinode), 0, 0,
	    PR_WAITOK, "ext2dinopl", NULL);
	pool_setipl(&ext2fs_dinode_pool, IPL_NONE);
@


1.95
log
@Missed a couple qaddr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.94 2016/08/10 07:53:02 natano Exp $	*/
a172 1
	mode_t accessmode;
a205 13
			/*
			 * If upgrade to read-write by non-root, then verify
			 * that user has necessary permissions on the device.
			 */
			if (suser(p, 0) != 0) {
				devvp = ump->um_devvp;
				vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
				error = VOP_ACCESS(devvp, VREAD | VWRITE,
				    p->p_ucred, p);
				VOP_UNLOCK(devvp, p);
				if (error)
					return (error);
			}
a243 14
	}
	/*
	 * If mount by non-root, then verify that user has necessary
	 * permissions on the device.
	 */
	if (suser(p, 0) != 0) {
		accessmode = VREAD;
		if ((mp->mnt_flag & MNT_RDONLY) == 0)
			accessmode |= VWRITE;
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
		error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p);
		VOP_UNLOCK(devvp, p);
		if (error)
			goto error_devvp;
@


1.94
log
@ext2fs only has one set of specops/fifoops
ok mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.93 2016/06/19 11:54:33 natano Exp $	*/
d586 1
a586 1
	mp->mnt_data = (qaddr_t)ump;
@


1.93
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.92 2016/06/19 10:21:56 dlg Exp $	*/
d921 1
a921 1
	error = ext2fs_vinit(mp, &ext2fs_specvops, EXT2FS_FIFOOPS, &vp);
@


1.92
log
@add pool_setipl on all pools.

ok tedu@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.91 2016/05/22 20:27:04 bluhm Exp $	*/
d848 1
a848 1
	lockinit(&ip->i_lock, PINOD, "inode", 0, 0);
@


1.91
log
@When pulling an msdos formated umass stick during mount while the
usb stack was busy, the kernel could trigger an uvm fault.  There
is a race between vop_generic_revoke() and sys_mount() where vgonel()
could reset v_specinfo.  Then v_specmountpoint is no longer valid.
So after sleeping, msdosfs_mountfs() could crash in the error path.
The code in the different *_mountfs() functions was inconsistent,
implement the same check everywhere.
OK krw@@ natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.90 2016/04/26 18:37:03 natano Exp $	*/
d98 1
d101 1
@


1.90
log
@Populate all necessary statfs members in .vfs_statfs. cd9660, udf,
msdosfs and nfsv2 don't set f_namemax. ntfs and ext2fs don't set
f_namemeax and f_favail. fusefs doesn't set f_mntfromspec, f_favail and
f_iosize. Also, make all filesystems use copy_statfs_info(), so that all
statfs information is filled in correctly for the (sb != &mp->mnt-stat)
case.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.89 2016/03/27 11:39:37 bluhm Exp $	*/
d599 2
@


1.89
log
@When pulling and unmounting an umass USB stick, the file system
could end up in an inconsistent state.  The fstype dependent
mp->mnt_data was NULL, but the general mp was still listed as a
valid mount point.  Next access to the file system would crash with
a NULL pointer dereference.
If closing the device fails, the mount point must go away anyway.
There is nothing we can do about it.  Remove the workaround for the
EIO error in the general unmount code, but do not generate any error
in the file system specific unmount functions.
OK natano@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.88 2016/03/19 12:04:16 natano Exp $	*/
d296 1
d587 1
d716 3
a718 7
	sbp->f_ffree = fs->e2fs.e2fs_ficount;
	if (sbp != &mp->mnt_stat) {
		memcpy(sbp->f_mntonname, mp->mnt_stat.f_mntonname, MNAMELEN);
		memcpy(sbp->f_mntfromname, mp->mnt_stat.f_mntfromname, MNAMELEN);
		memcpy(sbp->f_mntfromspec, mp->mnt_stat.f_mntfromspec, MNAMELEN);
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
@


1.88
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.87 2016/03/17 18:52:31 bluhm Exp $	*/
d639 1
a639 1
	error = VOP_CLOSE(ump->um_devvp, fs->e2fs_ronly ? FREAD : FREAD|FWRITE,
d647 1
a647 1
	return (error);
@


1.87
log
@Set mnt_data to NULL after freeing the file system specific mount point.
OK krw@@ natano@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.86 2016/02/27 18:50:38 natano Exp $	*/
d214 1
a214 1
				VOP_UNLOCK(devvp, 0, p);
d267 1
a267 1
		VOP_UNLOCK(devvp, 0, p);
d601 1
a601 1
	VOP_UNLOCK(devvp, 0, p);
d670 1
a670 1
	VOP_UNLOCK(ump->um_devvp, 0, p);
d796 1
a796 1
		VOP_UNLOCK(ump->um_devvp, 0, p);
@


1.86
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.85 2015/03/14 03:38:52 jsg Exp $	*/
d605 1
a605 1
		mp->mnt_data = (qaddr_t)0;
d645 1
a645 1
	mp->mnt_data = (qaddr_t)0;
@


1.85
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.84 2014/12/23 01:53:33 tedu Exp $	*/
a585 1
	mp->mnt_maxsymlinklen = EXT2_MAXSYMLINKLEN;
d593 1
@


1.84
log
@change pool_init allocator to NULL and pass PR_WAITOK in flags as a sign
that these don't need to support interrupts
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.83 2014/07/31 19:11:38 pelikan Exp $	*/
a45 1
#include <sys/device.h>
@


1.83
log
@always use the little-endian copy of a superblock.

Damn those memcpy-wrapping macros!

"do it" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.82 2014/07/31 17:37:52 pelikan Exp $	*/
d97 4
a100 4
	pool_init(&ext2fs_inode_pool, sizeof(struct inode), 0, 0, 0,
	    "ext2inopl", &pool_allocator_nointr);
	pool_init(&ext2fs_dinode_pool, sizeof(struct ext2fs_dinode), 0, 0, 0,
	    "ext2dinopl", &pool_allocator_nointr);
@


1.82
log
@use proper on-disk inode size: no more, no less.

Reported by Roman Yakovlev, thanks!

"do it now" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.81 2014/07/13 15:07:01 pelikan Exp $	*/
d388 1
a388 1
e2fs_sbfill(struct vnode *devvp, struct m_ext2fs *fs, struct ext2fs *sb)
d394 6
a399 6
	fs->e2fs_ncg = howmany(sb->e2fs_bcount - sb->e2fs_first_dblock,
	    sb->e2fs_bpg);
	fs->e2fs_fsbtodb = sb->e2fs_log_bsize + 1;
	fs->e2fs_bsize = 1024 << sb->e2fs_log_bsize;
	fs->e2fs_bshift = LOG_MINBSIZE + sb->e2fs_log_bsize;
	fs->e2fs_fsize = 1024 << sb->e2fs_log_fsize;
d405 1
a405 1
	fs->e2fs_itpg = sb->e2fs_ipg / fs->e2fs_ipb;
d434 2
a435 2
	if ((sb->e2fs_features_rocompat & EXT2F_ROCOMPAT_LARGEFILE) == 0 ||
	    (sb->e2fs_rev == E2FS_REV0))
d440 1
a440 1
	if (sb->e2fs_features_incompat & EXT2F_INCOMPAT_EXTENTS)
d499 1
a499 1
	if ((error = e2fs_sbfill(devvp, fs, newfs)) != 0)
d568 1
a568 1
	if ((error = e2fs_sbfill(devvp, ump->um_e2fs, fs)) != 0)
@


1.81
log
@fill in proper sizes in free(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.80 2014/07/13 13:28:26 pelikan Exp $	*/
d368 1
a368 1
	e2fs_iload((struct ext2fs_dinode *)cp, ip->i_e2din);
d894 1
a894 1
	e2fs_iload(dp, ip->i_e2din);
@


1.80
log
@ext4 (extents) read support

Tested on amd64 with > 4GB files and 50,000 subdirectories.
From FreeBSD, thanks!

ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.79 2014/07/12 18:44:01 tedu Exp $	*/
d135 1
a135 1
		free(mp, M_MOUNT, 0);
d420 3
a422 1
			free(fs->e2fs_gd, M_UFSMNT, 0);
d604 2
a605 2
		free(ump->um_e2fs, M_UFSMNT, 0);
		free(ump, M_UFSMNT, 0);
d620 1
d629 4
a632 3
	if (fs->e2fs_ronly == 0 &&
		ext2fs_cgupdate(ump, MNT_WAIT) == 0 &&
		(fs->e2fs.e2fs_state & E2FS_ERRORS) == 0) {
d643 3
a645 3
	free(fs->e2fs_gd, M_UFSMNT, 0);
	free(fs, M_UFSMNT, 0);
	free(ump, M_UFSMNT, 0);
@


1.79
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.78 2014/07/12 13:23:59 pelikan Exp $	*/
d399 1
d1094 1
a1094 1
	if (tmp & ~EXT2F_INCOMPAT_SUPP) {
d1097 11
@


1.78
log
@fix a type error on BE architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.77 2014/07/12 11:03:11 pelikan Exp $	*/
d135 1
a135 1
		free(mp, M_MOUNT);
d419 1
a419 1
			free(fs->e2fs_gd, M_UFSMNT);
d601 2
a602 2
		free(ump->um_e2fs, M_UFSMNT);
		free(ump, M_UFSMNT);
d638 3
a640 3
	free(fs->e2fs_gd, M_UFSMNT);
	free(fs, M_UFSMNT);
	free(ump, M_UFSMNT);
@


1.77
log
@in-memory superblock was being filled in two places -> merge them

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.76 2014/07/12 09:30:02 pelikan Exp $	*/
d415 1
d425 2
a426 1
		e2fs_cgload(bp->b_data, fs->e2fs_gd + gdesc, fs->e2fs_bsize);
@


1.76
log
@print more useful information on wrong superblocks.

Function renames for consistency and readability.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.75 2014/07/12 09:04:35 pelikan Exp $	*/
d304 1
a304 1
				mp->mnt_stat.f_mntfromname);
d387 54
d461 1
a461 1
	int i, error;
d490 2
a491 1
	 * copy in new superblock, and compute in-memory values
d494 2
a495 40
	fs->e2fs_ncg =
	    howmany(fs->e2fs.e2fs_bcount - fs->e2fs.e2fs_first_dblock,
	    fs->e2fs.e2fs_bpg);
	/* XXX assume hw bsize = 512 */
	fs->e2fs_fsbtodb = fs->e2fs.e2fs_log_bsize + 1;
	fs->e2fs_bsize = 1024 << fs->e2fs.e2fs_log_bsize;
	fs->e2fs_bshift = LOG_MINBSIZE + fs->e2fs.e2fs_log_bsize;
	fs->e2fs_qbmask = fs->e2fs_bsize - 1;
	fs->e2fs_bmask = ~fs->e2fs_qbmask;
	fs->e2fs_ngdb = howmany(fs->e2fs_ncg,
	    fs->e2fs_bsize / sizeof(struct ext2_gd));
	fs->e2fs_ipb = fs->e2fs_bsize / EXT2_DINODE_SIZE(fs);
	fs->e2fs_itpg = fs->e2fs.e2fs_ipg/fs->e2fs_ipb;

	if ((fs->e2fs.e2fs_features_rocompat & EXT2F_ROCOMPAT_LARGEFILE) == 0 ||
	    (fs->e2fs.e2fs_rev == E2FS_REV0))
		fs->e2fs_maxfilesize = INT_MAX;
	else
		fs->e2fs_maxfilesize = ext2fs_maxfilesize(fs);

	if (fs->e2fs.e2fs_features_incompat & EXT2F_INCOMPAT_EXTENTS)
		fs->e2fs_maxfilesize *= 4;

	/*
	 * Step 3: re-read summary information from disk.
	 */

	for (i=0; i < fs->e2fs_ngdb; i++) {
		error = bread(devvp ,
		    fsbtodb(fs, ((fs->e2fs_bsize>1024)? 0 : 1) + i + 1),
		    fs->e2fs_bsize, &bp);
		if (error) {
			brelse(bp);
			return (error);
		}
		e2fs_cgload((struct ext2_gd*)bp->b_data,
		    &fs->e2fs_gd[i* fs->e2fs_bsize / sizeof(struct ext2_gd)],
		    fs->e2fs_bsize);
		brelse(bp);
	}
a515 1
	struct m_ext2fs *m_fs;
d517 1
a517 1
	int error, i, ronly;
d543 3
a545 3
#ifdef DEBUG_EXT2
	printf("ext2 sb size: %d\n", sizeof(struct ext2fs));
#endif
d553 1
d557 8
a564 1
	e2fs_sbload((struct ext2fs*)bp->b_data, &ump->um_e2fs->e2fs);
d567 2
a568 2
	m_fs = ump->um_e2fs;
	m_fs->e2fs_ronly = ronly;
a570 3
#ifdef DEBUG_EXT2
	printf("ext2 ino size %d\n", EXT2_DINODE_SIZE(m_fs));
#endif
d572 2
a573 2
		if (m_fs->e2fs.e2fs_state == E2FS_ISCLEAN)
			m_fs->e2fs.e2fs_state = 0;
d575 2
a576 35
			m_fs->e2fs.e2fs_state = E2FS_ERRORS;
		m_fs->e2fs_fmod = 1;
	}

	/* compute dynamic sb infos */
	m_fs->e2fs_ncg =
		howmany(m_fs->e2fs.e2fs_bcount - m_fs->e2fs.e2fs_first_dblock,
		m_fs->e2fs.e2fs_bpg);
	/* XXX assume hw bsize = 512 */
	m_fs->e2fs_fsbtodb = m_fs->e2fs.e2fs_log_bsize + 1;
	m_fs->e2fs_bsize = 1024 << m_fs->e2fs.e2fs_log_bsize;
	m_fs->e2fs_bshift = LOG_MINBSIZE + m_fs->e2fs.e2fs_log_bsize;
	m_fs->e2fs_qbmask = m_fs->e2fs_bsize - 1;
	m_fs->e2fs_bmask = ~m_fs->e2fs_qbmask;
	m_fs->e2fs_ngdb = howmany(m_fs->e2fs_ncg,
		m_fs->e2fs_bsize / sizeof(struct ext2_gd));
	m_fs->e2fs_ipb = m_fs->e2fs_bsize / EXT2_DINODE_SIZE(m_fs);
	m_fs->e2fs_itpg = m_fs->e2fs.e2fs_ipg/m_fs->e2fs_ipb;

	m_fs->e2fs_gd = malloc(m_fs->e2fs_ngdb * m_fs->e2fs_bsize,
	    M_UFSMNT, M_WAITOK);
	for (i=0; i < m_fs->e2fs_ngdb; i++) {
		error = bread(devvp ,
		    fsbtodb(m_fs, ((m_fs->e2fs_bsize>1024)? 0 : 1) + i + 1),
		    m_fs->e2fs_bsize, &bp);
		if (error) {
			free(m_fs->e2fs_gd, M_UFSMNT);
			goto out;
		}
		e2fs_cgload((struct ext2_gd*)bp->b_data,
		    &m_fs->e2fs_gd[i * m_fs->e2fs_bsize
		    / sizeof(struct ext2_gd)],
		    m_fs->e2fs_bsize);
		brelse(bp);
		bp = NULL;
d587 2
a588 2
	ump->um_nindir = NINDIR(m_fs);
	ump->um_bptrtodb = m_fs->e2fs_fsbtodb;
@


1.75
log
@revert previous unwanted commit.  sorry!
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.74 2014/07/12 08:53:38 pelikan Exp $	*/
d71 1
a71 1
static int ext2fs_checksb(struct ext2fs *, int);
d428 1
a428 1
	error = ext2fs_checksb(newfs, (mountp->mnt_flag & MNT_RDONLY) != 0);
d534 1
a534 1
	error = ext2fs_checksb(fs, ronly);
d1063 1
d1065 1
a1065 1
ext2fs_checksb(struct ext2fs *fs, int ronly)
d1067 5
a1071 1
	if (fs2h16(fs->e2fs_magic) != E2FS_MAGIC) {
d1074 6
a1079 12
	if (fs2h32(fs->e2fs_rev) > E2FS_REV1) {
#ifdef DIAGNOSTIC
		printf("Ext2 fs: unsupported revision number: %x\n",
		    fs2h32(fs->e2fs_rev));
#endif
		return (EIO);		/* XXX needs translation */
	}
	if (fs2h32(fs->e2fs_log_bsize) > 2) { /* block size = 1024|2048|4096 */
#ifdef DIAGNOSTIC
		printf("Ext2 fs: bad block size: %d (expected <=2 for ext2 fs)\n",
		    fs2h32(fs->e2fs_log_bsize));
#endif
d1082 1
d1084 1
a1084 3
#ifdef DIAGNOSTIC
		printf("Ext2 fs: bad blocks per group: 0\n");
#endif
d1087 25
a1111 14
	if (fs2h32(fs->e2fs_rev) > E2FS_REV0) {
		if (fs2h32(fs->e2fs_first_ino) != EXT2_FIRSTINO) {
			printf("Ext2 fs: unsupported first inode position");
			return (EINVAL);      /* XXX needs translation */
		}
		if (fs2h32(fs->e2fs_features_incompat) &
		    ~EXT2F_INCOMPAT_SUPP) {
			printf("Ext2 fs: unsupported optional feature\n");
			return (EINVAL);      /* XXX needs translation */
		}
		if (!ronly && fs2h32(fs->e2fs_features_rocompat) &
		    ~EXT2F_ROCOMPAT_SUPP) {
			return (EROFS);      /* XXX needs translation */
		}
d1113 1
@


1.74
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.73 2014/07/11 15:54:52 tobias Exp $	*/
d71 1
a71 1
static int	e2fs_sbcheck(struct ext2fs *, const char *, int);
d428 1
a428 2
	error = e2fs_sbcheck(newfs, mountp->mnt_stat.f_mntfromname,
	    (mountp->mnt_flag & MNT_RDONLY));
d534 1
a534 1
	error = e2fs_sbcheck(fs, mp->mnt_stat.f_mntfromname, ronly);
a1062 1
/* This is called before the superblock is copied.  Watch out for endianity! */
d1064 1
a1064 1
e2fs_sbcheck(struct ext2fs *fs, const char *path, int ronly)
d1066 8
a1073 5
	u_int32_t tmp;

	tmp = letoh16(fs->e2fs_magic);
	if (tmp != E2FS_MAGIC) {
		printf("ext2fs at %s: wrong magic number 0x%x\n", path, tmp);
d1076 5
a1080 6

	tmp = letoh32(fs->e2fs_log_bsize);
	if (tmp > 2) {
		/* skewed log(block size): 1024 -> 0 | 2048 -> 1 | 4096 -> 2 */
		tmp += 10;
		printf("ext2fs at %s: wrong log2(block size) %d\n", path, tmp);
a1082 1

d1084 3
a1086 1
		printf("ext2fs at %s: zero blocks per group\n", path);
d1089 14
a1102 5

	tmp = letoh32(fs->e2fs_rev);
	if (tmp > E2FS_REV1) {
		printf("ext2fs at %s: wrong revision number 0x%x\n", path, tmp);
		return (EIO);		/* XXX needs translation */
a1103 23
	else if (tmp == E2FS_REV0)
		return (0);

	tmp = letoh32(fs->e2fs_first_ino);
	if (tmp != EXT2_FIRSTINO) {
		printf("ext2fs at %s: first inode at 0x%x\n", path, tmp);
		return (EINVAL);      /* XXX needs translation */
	}

	tmp = letoh32(fs->e2fs_features_incompat);
	if (tmp & ~EXT2F_INCOMPAT_SUPP) {
		printf("ext2fs at %s: unsupported incompat features 0x%x\n",
		    path, tmp);
		return (EINVAL);      /* XXX needs translation */
	}

	tmp = letoh32(fs->e2fs_features_rocompat);
	if (!ronly && (tmp & ~EXT2F_ROCOMPAT_SUPP)) {
		printf("ext2fs at %s: unsupported R/O compat features 0x%x\n",
		    path, tmp);
		return (EROFS);      /* XXX needs translation */
	}

@


1.73
log
@Prevent division by zero on erroneous file systems.

ok pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.72 2014/07/11 14:30:52 pelikan Exp $	*/
d71 1
a71 1
static int ext2fs_checksb(struct ext2fs *, int);
d428 2
a429 1
	error = ext2fs_checksb(newfs, (mountp->mnt_flag & MNT_RDONLY) != 0);
d535 1
a535 1
	error = ext2fs_checksb(fs, ronly);
d1064 1
d1066 1
a1066 1
ext2fs_checksb(struct ext2fs *fs, int ronly)
d1068 5
a1072 1
	if (fs2h16(fs->e2fs_magic) != E2FS_MAGIC) {
d1075 6
a1080 12
	if (fs2h32(fs->e2fs_rev) > E2FS_REV1) {
#ifdef DIAGNOSTIC
		printf("Ext2 fs: unsupported revision number: %x\n",
		    fs2h32(fs->e2fs_rev));
#endif
		return (EIO);		/* XXX needs translation */
	}
	if (fs2h32(fs->e2fs_log_bsize) > 2) { /* block size = 1024|2048|4096 */
#ifdef DIAGNOSTIC
		printf("Ext2 fs: bad block size: %d (expected <=2 for ext2 fs)\n",
		    fs2h32(fs->e2fs_log_bsize));
#endif
d1083 1
d1085 1
a1085 3
#ifdef DIAGNOSTIC
		printf("Ext2 fs: bad blocks per group: 0\n");
#endif
d1088 27
a1114 14
	if (fs2h32(fs->e2fs_rev) > E2FS_REV0) {
		if (fs2h32(fs->e2fs_first_ino) != EXT2_FIRSTINO) {
			printf("Ext2 fs: unsupported first inode position");
			return (EINVAL);      /* XXX needs translation */
		}
		if (fs2h32(fs->e2fs_features_incompat) &
		    ~EXT2F_INCOMPAT_SUPP) {
			printf("Ext2 fs: unsupported optional feature\n");
			return (EINVAL);      /* XXX needs translation */
		}
		if (!ronly && fs2h32(fs->e2fs_features_rocompat) &
		    ~EXT2F_ROCOMPAT_SUPP) {
			return (EROFS);      /* XXX needs translation */
		}
d1116 1
@


1.72
log
@determine and use maximum file size instead of magical constants

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.71 2014/05/27 14:31:24 krw Exp $	*/
d1082 6
@


1.71
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.70 2013/12/12 19:00:09 tedu Exp $	*/
d374 13
d452 9
@


1.70
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.69 2013/12/01 16:40:56 krw Exp $	*/
d230 1
a230 1
			return (vfs_export(mp, &ump->um_export, 
d352 1
a352 1
	
d359 1
a359 1
	error = bread(era->devvp, 
d422 1
a422 1
	/* 
d524 1
a524 1
	       
d718 1
a718 1
ext2fs_sync_vnode(struct vnode *vp, void *args) 
d725 1
a725 1
	if (vp->v_type == VNON || 
d875 1
a875 1
	
d960 1
a960 1
	if (ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime != 0 || 
d1035 1
a1035 1
	
@


1.69
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.68 2013/06/11 16:42:18 deraadt Exp $	*/
d143 2
a144 3
	bzero(fs->e2fs_fsmnt, sizeof(fs->e2fs_fsmnt));
	(void)copystr(mp->mnt_stat.f_mntonname, fs->e2fs_fsmnt, 
	    sizeof(fs->e2fs_fsmnt) - 1, NULL);
d146 3
a148 3
		bzero(fs->e2fs.e2fs_fsmnt, sizeof(fs->e2fs.e2fs_fsmnt));
		(void)copystr(mp->mnt_stat.f_mntonname, fs->e2fs.e2fs_fsmnt,
		    sizeof(fs->e2fs.e2fs_fsmnt) - 1, NULL);
d243 1
a243 1
		bcopy(fspec, fname, sizeof(fname));
d285 1
a285 1
	bzero(fs->e2fs_fsmnt, sizeof(fs->e2fs_fsmnt));
d288 1
a288 1
		bzero(fs->e2fs.e2fs_fsmnt, sizeof(fs->e2fs.e2fs_fsmnt));
d292 2
a293 2
	bcopy(fs->e2fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
d295 1
a295 1
	bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
d700 3
a702 3
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromspec, sbp->f_mntfromspec, MNAMELEN);
@


1.68
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.67 2013/05/30 19:19:09 guenther Exp $	*/
d140 1
a140 1
	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
@


1.67
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.66 2013/04/15 15:32:19 jsing Exp $	*/
d410 1
a410 1
	error = bread(devvp, (daddr64_t)(SBOFF / DEV_BSIZE), SBSIZE, &bp);
d509 1
a509 1
	error = bread(devvp, (daddr64_t)(SBOFF / DEV_BSIZE), SBSIZE, &bp);
@


1.66
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.65 2012/09/10 11:11:00 jsing Exp $	*/
d812 4
@


1.65
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.63 2011/07/04 04:30:41 tedu Exp $	*/
d170 1
d175 1
a175 1
	error = copyin(data, (caddr_t)&args, sizeof (struct ufs_args));
a241 1
	disk_map(fspec, fspec, MNAMELEN, DM_OPENBLCK);
d243 4
a246 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fspec, p);
d295 3
a297 1
	strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN);
d306 1
a306 1
		(void)ext2fs_cgupdate(ump, MNT_WAIT);
d703 1
@


1.64
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d170 1
a170 1
	size_t size;
a172 1
	char *fspec = NULL;
d226 1
a226 1
		if (args.fspec == 0) {
d238 1
a238 2
	fspec = malloc(MNAMELEN, M_MOUNT, M_WAITOK);
	error = copyinstr(args.fspec, fspec, MNAMELEN - 1, &size);
d282 3
a284 3
	(void)copyinstr(path, fs->e2fs_fsmnt, sizeof(fs->e2fs_fsmnt) - 1,
	    &size);
	bzero(fs->e2fs_fsmnt + size, sizeof(fs->e2fs_fsmnt) - size);
d286 3
a288 3
		(void)copystr(mp->mnt_stat.f_mntonname, fs->e2fs.e2fs_fsmnt,
		    sizeof(fs->e2fs.e2fs_fsmnt) - 1, &size);
		bzero(fs->e2fs.e2fs_fsmnt, sizeof(fs->e2fs.e2fs_fsmnt) - size);
d291 3
a293 2
	size = strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN - 1);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
a313 3
	if (fspec)
		free(fspec, M_MOUNT);

@


1.63
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.62 2011/07/04 04:15:26 krw Exp $	*/
d57 1
a57 2

#include <miscfs/specfs/specdev.h>
@


1.62
log
@bread() takes daddr64_t block address, not int32_t, so use correct cast. bread() always
takes DEV_BSIZE address units so don't bother getting the disklabel and trying to
convert units to d_secsize. Nukes last references to d_secsize in ufs/.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.61 2011/07/03 18:23:10 tedu Exp $	*/
d362 1
a362 1
	    (int)era->fs->e2fs_bsize, NOCRED, &bp);
d410 1
a410 1
	error = bread(devvp, (daddr64_t)(SBOFF / DEV_BSIZE), SBSIZE, NOCRED, &bp);
d448 1
a448 1
		    fs->e2fs_bsize, NOCRED, &bp);
d509 1
a509 1
	error = bread(devvp, (daddr64_t)(SBOFF / DEV_BSIZE), SBSIZE, cred, &bp);
d557 1
a557 1
		    m_fs->e2fs_bsize, NOCRED, &bp);
d855 1
a855 1
	    (int)fs->e2fs_bsize, NOCRED, &bp);
@


1.61
log
@correctify NULL 0 confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.60 2011/06/30 15:08:59 jsing Exp $	*/
d395 1
a395 2
	struct partinfo dpart;
	int i, size, error;
d410 1
a410 5
	if (VOP_IOCTL(devvp, DIOCGPART, (caddr_t)&dpart, FREAD, NOCRED, p) != 0)
		size = DEV_BSIZE;
	else
		size = dpart.disklab->d_secsize;
	error = bread(devvp, (int32_t)(SBOFF / size), SBSIZE, NOCRED, &bp);
d480 1
a480 2
	struct partinfo dpart;
	int error, i, size, ronly;
a501 4
	if (VOP_IOCTL(devvp, DIOCGPART, (caddr_t)&dpart, FREAD, cred, p) != 0)
		size = DEV_BSIZE;
	else
		size = dpart.disklab->d_secsize;
d509 1
a509 1
	error = bread(devvp, (SBOFF / DEV_BSIZE), SBSIZE, cred, &bp);
@


1.60
log
@Add DUID support for ext2fs mounts.

Initial diff from and tested by Luca Corti - thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.58 2010/09/23 18:40:00 oga Exp $	*/
d146 1
a146 1
	    sizeof(fs->e2fs_fsmnt) - 1, 0);
d150 1
a150 1
		    sizeof(fs->e2fs.e2fs_fsmnt) - 1, 0);
@


1.59
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d47 1
d174 1
d179 1
d240 7
a246 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_USERSPACE, args.fspec, p);
d248 1
a248 1
		return (error);
d252 2
a253 2
		vrele(devvp);
		return (ENOTBLK);
d256 2
a257 2
		vrele(devvp);
		return (ENXIO);
a268 4
		if (error) {
			vput(devvp);
			return (error);
		}
d270 2
d281 2
a282 4
	if (error) {
		vrele(devvp);
		return (error);
	}
d294 1
a294 2
	(void)copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1, 
		&size);
d305 15
a319 1
	return (0);
@


1.58
log
@Change:

	/* something */
	if (error) {
		VOP_UNLOCK();
		return;
	}
	VOP_UNLOCK();

to the clearer and shorter:

	VOP_UNLOCK();
	if (error)
		return;

ok thib@@, jsing@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.57 2010/09/10 16:34:09 thib Exp $	*/
a72 15
extern struct vnodeopv_desc ext2fs_vnodeop_opv_desc;
extern struct vnodeopv_desc ext2fs_specop_opv_desc;
#ifdef FIFO
extern struct vnodeopv_desc ext2fs_fifoop_opv_desc;
#endif

struct vnodeopv_desc *ext2fs_vnodeopv_descs[] = {
	&ext2fs_vnodeop_opv_desc,
	&ext2fs_specop_opv_desc,
#ifdef FIFO
	&ext2fs_fifoop_opv_desc,
#endif
	NULL,
};

d812 1
a812 1
	if ((error = getnewvnode(VT_EXT2FS, mp, ext2fs_vnodeop_p, &vp)) != 0) {
d891 1
a891 1
	error = ext2fs_vinit(mp, ext2fs_specop_p, EXT2FS_FIFOOPS, &vp);
@


1.57
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.56 2010/09/06 23:44:10 thib Exp $	*/
d229 2
a230 2
				if (error) {
					VOP_UNLOCK(devvp, 0, p);
a231 2
				}
				VOP_UNLOCK(devvp, 0, p);
@


1.56
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.55 2010/05/18 04:41:14 dlg Exp $	*/
d73 15
d829 1
a829 1
	if ((error = getnewvnode(VT_EXT2FS, mp, &ext2fs_vops, &vp)) != 0) {
d908 1
a908 1
	error = ext2fs_vinit(mp, &ext2fs_specvops, EXT2FS_FIFOOPS, &vp);
@


1.55
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.54 2009/10/31 12:00:08 fgsch Exp $	*/
a72 15
extern struct vnodeopv_desc ext2fs_vnodeop_opv_desc;
extern struct vnodeopv_desc ext2fs_specop_opv_desc;
#ifdef FIFO
extern struct vnodeopv_desc ext2fs_fifoop_opv_desc;
#endif

struct vnodeopv_desc *ext2fs_vnodeopv_descs[] = {
	&ext2fs_vnodeop_opv_desc,
	&ext2fs_specop_opv_desc,
#ifdef FIFO
	&ext2fs_fifoop_opv_desc,
#endif
	NULL,
};

d814 1
a814 1
	if ((error = getnewvnode(VT_EXT2FS, mp, ext2fs_vnodeop_p, &vp)) != 0) {
d893 1
a893 1
	error = ext2fs_vinit(mp, ext2fs_specop_p, EXT2FS_FIFOOPS, &vp);
@


1.54
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.53 2009/07/09 22:29:56 thib Exp $	*/
d55 1
@


1.53
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.51 2008/11/23 23:52:35 tedu Exp $	*/
d223 1
a223 1
			if (p->p_ucred->cr_uid != 0) {
d270 1
a270 1
	if (p->p_ucred->cr_uid != 0) {
@


1.52
log
@styled code is happy code
@
text
@d917 1
a917 1
	VREF(ip->i_devvp);
@


1.51
log
@fancy new ext2fs can have big inodes.  we can possibly still read them
though if no new features are in play.  diff from Wouter Godefroy
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.50 2008/09/12 12:27:27 blambert Exp $	*/
d158 1
a158 1
	(void) copystr(mp->mnt_stat.f_mntonname, fs->e2fs_fsmnt, 
d162 1
a162 1
		(void) copystr(mp->mnt_stat.f_mntonname, fs->e2fs.e2fs_fsmnt,
d204 2
a205 2
				ext2fs_cgupdate(ump, MNT_WAIT) == 0 &&
				(fs->e2fs.e2fs_state & E2FS_ERRORS) == 0) {
d207 1
a207 1
				(void) ext2fs_sbupdate(ump, MNT_WAIT);
d227 1
a227 1
						   p->p_ucred, p);
d296 1
a296 1
	(void) copyinstr(path, fs->e2fs_fsmnt, sizeof(fs->e2fs_fsmnt) - 1,
d300 1
a300 1
		(void) copystr(mp->mnt_stat.f_mntonname, fs->e2fs.e2fs_fsmnt,
d305 1
a305 1
	(void) copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1, 
d315 1
a315 1
		(void) ext2fs_cgupdate(ump, MNT_WAIT);
d440 1
a440 1
			fs->e2fs_bsize / sizeof(struct ext2_gd));
d561 1
a561 1
		M_UFSMNT, M_WAITOK);
d571 2
a572 2
		    &m_fs->e2fs_gd[
			i * m_fs->e2fs_bsize / sizeof(struct ext2_gd)],
d633 1
a633 1
		NOCRED, p);
d686 2
a687 3
	overhead_per_group = 1 /* block bitmap */ +
				 1 /* inode bitmap */ +
				 fs->e2fs_itpg;
d689 1
a689 1
		   fs->e2fs_ncg * overhead_per_group;
d735 1
a735 1
		LIST_EMPTY(&vp->v_dirtyblkhd)) ||
d863 1
a863 1
			  (int)fs->e2fs_bsize, NOCRED, &bp);
d878 1
a878 1
			  + EXT2_DINODE_SIZE(fs) * ino_to_fsbo(fs, ino));
d956 1
a956 1
		ufhp->ufid_ino > fs->e2fs_ncg * fs->e2fs.e2fs_ipg)
d965 1
a965 1
		ip->i_e2fs_gen != ufhp->ufid_gen) {
@


1.50
log
@Remove bzero/memset calls after pool_gets by passing the PR_ZERO
flag to the pool_get call.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.49 2007/10/06 23:50:55 krw Exp $	*/
d366 1
a366 1
	    (ino_to_fsbo(era->fs, ip->i_number) * EXT2_DINODE_SIZE);
d441 1
a441 1
	fs->e2fs_ipb = fs->e2fs_bsize / EXT2_DINODE_SIZE;
d515 1
a515 2
	printf("sb size: %d ino size %d\n", sizeof(struct ext2fs),
	    EXT2_DINODE_SIZE);
d533 4
d557 1
a557 1
	m_fs->e2fs_ipb = m_fs->e2fs_bsize / EXT2_DINODE_SIZE;
d878 3
a880 1
	dp = (struct ext2fs_dinode *) bp->b_data + ino_to_fsbo(fs, ino);
d1067 2
a1068 3
		if (fs2h32(fs->e2fs_first_ino) != EXT2_FIRSTINO ||
		    fs2h16(fs->e2fs_inode_size) != EXT2_DINODE_SIZE) {
			printf("Ext2 fs: unsupported inode size\n");
@


1.49
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.48 2007/06/17 20:15:25 jasper Exp $	*/
d831 1
a831 2
	ip = pool_get(&ext2fs_inode_pool, PR_WAITOK);
	memset(ip, 0, sizeof(struct inode));
@


1.48
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.47 2007/06/02 00:45:50 pedro Exp $	*/
d525 3
a527 4
	ump = malloc(sizeof *ump, M_UFSMNT, M_WAITOK);
	memset((caddr_t)ump, 0, sizeof *ump);
	ump->um_e2fs = malloc(sizeof(struct m_ext2fs), M_UFSMNT, M_WAITOK);
	memset((caddr_t)ump->um_e2fs, 0, sizeof(struct m_ext2fs));
@


1.47
log
@ufs1_daddr_t cleanup, okay thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.46 2007/03/21 17:29:32 thib Exp $	*/
d109 1
a109 2
ext2fs_init(vfsp)
	struct vfsconf *vfsp;
d127 1
a127 1
ext2fs_mountroot()
d129 1
a129 1
	register struct m_ext2fs *fs;
d177 2
a178 6
ext2fs_mount(mp, path, data, ndp, p)
	register struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
d183 1
a183 1
	register struct m_ext2fs *fs;
d330 2
a331 1
ext2fs_reload_vnode(struct vnode *vp, void *args) {
d387 1
a387 4
ext2fs_reload(mountp, cred, p)
	register struct mount *mountp;
	struct ucred *cred;
	struct proc *p;
d476 1
a476 4
ext2fs_mountfs(devvp, mp, p)
	register struct vnode *devvp;
	struct mount *mp;
	struct proc *p;
d478 1
a478 1
	register struct ufsmount *ump;
d480 2
a481 2
	register struct ext2fs *fs;
	register struct m_ext2fs *m_fs;
d607 1
a607 4
ext2fs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
d609 2
a610 2
	register struct ufsmount *ump;
	register struct m_ext2fs *fs;
d645 1
a645 4
ext2fs_flushfiles(mp, flags, p)
	register struct mount *mp;
	int flags;
	struct proc *p;
d647 1
a647 1
	register struct ufsmount *ump;
d669 1
a669 4
ext2fs_statfs(mp, sbp, p)
	struct mount *mp;
	register struct statfs *sbp;
	struct proc *p;
d671 2
a672 2
	register struct ufsmount *ump;
	register struct m_ext2fs *fs;
d755 1
a755 5
ext2fs_sync(mp, waitfor, cred, p)
	struct mount *mp;
	int waitfor;
	struct ucred *cred;
	struct proc *p;
d808 1
a808 4
ext2fs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
d810 2
a811 2
	register struct m_ext2fs *fs;
	register struct inode *ip;
d943 1
a943 4
ext2fs_fhtovp(mp, fhp, vpp)
	register struct mount *mp;
	struct fid *fhp;
	struct vnode **vpp;
d945 1
a945 1
	register struct inode *ip;
d948 1
a948 1
	register struct ufid *ufhp;
d977 1
a977 3
ext2fs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
d979 2
a980 2
	register struct inode *ip;
	register struct ufid *ufhp;
d995 2
a996 8
ext2fs_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d1005 1
a1005 3
ext2fs_sbupdate(mp, waitfor)
	struct ufsmount *mp;
	int waitfor;
d1007 2
a1008 2
	register struct m_ext2fs *fs = mp->um_e2fs;
	register struct buf *bp;
d1021 1
a1021 3
ext2fs_cgupdate(mp, waitfor)
	struct ufsmount *mp;
	int waitfor;
d1023 2
a1024 2
	register struct m_ext2fs *fs = mp->um_e2fs;
	register struct buf *bp;
d1044 1
a1044 3
ext2fs_checksb(fs, ronly)
	struct ext2fs *fs;
	int ronly;
@


1.46
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.45 2006/04/19 11:55:55 pedro Exp $	*/
d420 1
a420 1
	error = bread(devvp, (ufs1_daddr_t)(SBOFF / size), SBSIZE, NOCRED, &bp);
@


1.45
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.44 2005/12/14 22:03:01 pedro Exp $	*/
d353 1
a353 1
	if (vget(vp, LK_EXCLUSIVE  | LK_INTERLOCK, era->p))
a754 1
		simple_unlock(&vp->v_interlock);
d758 1
a758 1
	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, esa->p))
@


1.44
log
@Make ext2fs use a memory pool to allocate inodes, okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.43 2005/12/11 21:06:10 pedro Exp $	*/
d154 1
a154 1
	simple_lock(&mountlist_slock);
a155 1
	simple_unlock(&mountlist_slock);
@


1.43
log
@Use e2fs_sbsave() instead of bcopy() when dumping the super-block back
to disk, fixes ext2fs on big-endian architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.42 2005/12/11 20:46:28 pedro Exp $	*/
d103 1
a103 1
/* struct pool ext2fs_inode_pool; */
d112 2
d859 3
a861 2
	MALLOC(ip, struct inode *, sizeof(struct inode), M_EXT2FSNODE, M_WAITOK);
	bzero((caddr_t)ip, sizeof(struct inode));
@


1.42
log
@inode/dinode separation for ext2fs
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.41 2005/11/30 10:35:08 pedro Exp $	*/
d1050 1
a1050 1
	bcopy((caddr_t)(&fs->e2fs), bp->b_data, SBSIZE);
@


1.41
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.40 2005/11/06 00:24:17 pedro Exp $	*/
d104 1
d112 3
d370 1
a370 1
	e2fs_iload((struct ext2fs_dinode *)cp, &ip->i_e2din);
d838 1
d901 6
a906 2
	bcopy(((struct ext2fs_dinode*)bp->b_data + ino_to_fsbo(fs, ino)),
				&ip->i_e2din, sizeof(struct ext2fs_dinode));
a919 2
	brelse(bp);

d930 1
a930 1
	error = ufs_vinit(mp, ext2fs_specop_p, EXT2FS_FIFOOPS, &vp);
d936 1
@


1.40
log
@Replace obsolete comment with one that better describes reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.39 2005/10/06 17:43:14 pedro Exp $	*/
d143 1
a143 1
		vfs_unbusy(mp, p);
d162 1
a162 1
	vfs_unbusy(mp, p);
@


1.39
log
@Use part of the reserved space on the disk inode to scatter 16 more bits
for the UID and GID, making them 32-bit. Based on what Linux does, with
a slightly different implementation. Endianess issue in fsck noted by
miod@@, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.38 2005/07/28 23:11:25 pedro Exp $	*/
d767 1
a767 1
 * Note: we are always called with the filesystem marked `MPBUSY'.
@


1.38
log
@no point in having an inode pool if we don't use it
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.37 2005/07/03 20:14:01 drahn Exp $	*/
d899 12
@


1.37
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.36 2005/04/30 13:58:55 niallo Exp $	*/
d103 1
a103 1
struct pool ext2fs_inode_pool;
@


1.36
log
@Add support for large files (> 4GB).

Automatically converts old filesystems to use this if they are already at
revision 1 (like Linux). Revision 0 filesystems don't get converted (unlike
Linux).

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.35 2004/12/26 21:22:14 miod Exp $	*/
a57 1
#include <ufs/ufs/extattr.h>
d100 1
a100 2
	ufs_check_export,
	vfs_stdextattrctl
@


1.35
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.34 2004/06/21 23:50:38 tholo Exp $	*/
d905 2
a906 1
		ip->i_e2fs_mode = ip->i_e2fs_size = ip->i_e2fs_nblock = 0;
@


1.34
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.33 2004/06/04 08:06:04 tedu Exp $	*/
d750 1
a750 1
		vp->v_dirtyblkhd.lh_first == NULL) ||
@


1.33
log
@rootvp is already externed in systm.h, no need for a local extern
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.32 2004/05/06 17:41:03 grange Exp $	*/
d313 1
a313 1
			fs->e2fs.e2fs_wtime = time.tv_sec;
d815 1
a815 1
		fs->e2fs.e2fs_wtime = time.tv_sec;
d927 2
a928 2
		if (++ext2gennumber < (u_long)time.tv_sec)
			ext2gennumber = time.tv_sec;
@


1.32
log
@Two missing ifdef FIFO; noticed by form@@pdp-11.org.ru.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.31 2004/01/20 03:44:06 tedu Exp $	*/
a125 1
	extern struct vnode *rootvp;
a492 1
	extern struct vnode *rootvp;
@


1.31
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.30 2003/08/25 23:26:55 tedu Exp $	*/
d75 1
d77 1
d82 1
d84 1
@


1.30
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
few other little cleanups.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.29 2003/08/14 07:46:40 mickey Exp $	*/
d539 1
d857 1
a918 1
	ip->i_devvp = ump->um_devvp;
@


1.29
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.28 2003/07/06 09:02:11 tedu Exp $	*/
d365 1
a365 1
	e2fs_iload((struct ext2fs_dinode *)cp, &ip->i_din.e2fs_din);
d895 1
a895 1
				&ip->i_din, sizeof(struct ext2fs_dinode));
@


1.28
log
@reset inode fields if deleted, prevents a panic after deleting a device.
from netbsd via otto moerbeek
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.27 2003/06/02 23:28:22 millert Exp $	*/
d84 1
a84 1
struct vfsops ext2fs_vfsops = {
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.26 2003/05/26 18:33:16 tedu Exp $	*/
d898 5
@


1.26
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.25 2002/07/29 17:45:20 fgsch Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *	must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.25
log
@Fix two off-by-one errors when sanity-checking inode numbers. In
ext2fs, inode numbers start at 1, so the maximum valid inode number
is (s_inodes_per_group * s_groups_count), not one less.
From FreeBSD.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.24 2002/07/28 21:22:27 fgsch Exp $	*/
d418 1
a418 1
	error = bread(devvp, (ufs_daddr_t)(SBOFF / size), SBSIZE, NOCRED, &bp);
@


1.25.2.1
log
@MFC:
Fix by tedu@@

reset inode fields if deleted, prevents a panic after deleting a device.
from netbsd via otto moerbeek

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.25 2002/07/29 17:45:20 fgsch Exp $	*/
a901 5

	/* If the inode was deleted, reset all fields */
	if (ip->i_e2fs_dtime != 0) {
		ip->i_e2fs_mode = ip->i_e2fs_size = ip->i_e2fs_nblock = 0;
	}
@


1.25.4.1
log
@MFC:
Fix by tedu@@

reset inode fields if deleted, prevents a panic after deleting a device.
from netbsd via otto moerbeek

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.25 2002/07/29 17:45:20 fgsch Exp $	*/
a901 5

	/* If the inode was deleted, reset all fields */
	if (ip->i_e2fs_dtime != 0) {
		ip->i_e2fs_mode = ip->i_e2fs_size = ip->i_e2fs_nblock = 0;
	}
@


1.24
log
@optionnal -> optional.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.23 2002/04/23 18:54:12 espie Exp $	*/
d959 1
a959 1
		ufhp->ufid_ino >= fs->e2fs_ncg * fs->e2fs.e2fs_ipg)
@


1.23
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.22 2002/03/14 01:27:14 millert Exp $	*/
d1090 1
a1090 1
			printf("Ext2 fs: unsupported optionnal feature\n");
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.21 2002/02/22 20:37:45 drahn Exp $	*/
d248 2
a249 1
			return (vfs_export(mp, &ump->um_export, &args.export));
@


1.21
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.20 2001/12/19 08:58:07 art Exp $	*/
d74 2
a75 2
int ext2fs_sbupdate __P((struct ufsmount *, int));
static int ext2fs_checksb __P((struct ext2fs *, int));
@


1.20
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.16 2001/11/21 22:21:48 csapuntz Exp $	*/
d62 1
d101 2
a102 1
	ufs_check_export
@


1.19
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_vfsops.c,v 1.18 2001/12/10 02:19:34 art Exp $	*/
/*	$NetBSD: ext2fs_vfsops.c,v 1.40 2000/11/27 08:39:53 chs Exp $	*/
a102 5
struct genfs_ops ext2fs_genfsops = {
	genfs_size,
	ext2fs_gop_alloc,
};

d405 1
a405 4
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, 0, cred, p, 0, 0);
	VOP_UNLOCK(devvp, 0, p);
	if (error)
d407 1
a585 2
	mp->mnt_dev_bshift = DEV_BSHIFT;	/* XXX */
	mp->mnt_fs_bshift = m_fs->e2fs_bshift;
a589 1
	ump->um_lognindir = ffs(NINDIR(m_fs)) - 1;
a593 1

a912 1
	genfs_node_init(vp, &ext2fs_genfsops);
a926 1
	vp->v_size = ip->i_e2fs_size;
@


1.19.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.19 2001/12/10 04:45:31 art Exp $	*/
a105 1
	genfs_gop_write
@


1.19.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.19.2.1 2002/02/02 03:28:26 art Exp $	*/
a61 1
#include <ufs/ufs/extattr.h>
d73 2
a74 2
int ext2fs_sbupdate(struct ufsmount *, int);
static int ext2fs_checksb(struct ext2fs *, int);
d100 1
a100 2
	ufs_check_export,
	vfs_stdextattrctl
d252 1
a252 2
			return (vfs_export(mp, &ump->um_export, 
			    &args.export_info));
@


1.19.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.19.2.2 2002/06/11 03:32:50 art Exp $	*/
d973 1
a973 1
		ufhp->ufid_ino > fs->e2fs_ncg * fs->e2fs.e2fs_ipg)
d1104 1
a1104 1
			printf("Ext2 fs: unsupported optional feature\n");
@


1.19.2.4
log
@use vnode lock in place of inode lock, switch to genfs_lock
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.19.2.3 2002/10/29 00:36:50 art Exp $	*/
d869 1
a869 1
	vp->v_vnlock = &vp->v_lock;
@


1.18
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.17 2001/11/27 05:27:12 art Exp $	*/
d103 5
d924 1
@


1.17
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.16 2001/11/21 22:21:48 csapuntz Exp $	*/
d933 1
a933 1
	vp->v_uvm.u_size = ip->i_e2fs_size;
@


1.16
log
@Use vfs_mount_foreach_vnode
@
text
@d1 2
a2 2
/*	$OpenBSD: ext2fs_vfsops.c,v 1.15 2001/09/18 01:46:40 art Exp $	*/
/*	$NetBSD: ext2fs_vfsops.c,v 1.1 1997/06/11 09:34:07 bouyer Exp $	*/
d405 4
a408 1
	if (vinvalbuf(devvp, 0, cred, p, 0, 0))
a409 1

d588 2
d594 1
d599 1
d933 1
@


1.15
log
@move ext2fs_init to where it belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.14 2001/03/04 06:32:41 csapuntz Exp $	*/
d320 52
d391 1
a391 2
	register struct vnode *vp, *nvp, *devvp;
	struct inode *ip;
d397 1
a397 1
	caddr_t cp;
a462 8
	
loop:
	simple_lock(&mntvnode_slock);
	for (vp = mountp->mnt_vnodelist.lh_first; vp != NULL; vp = nvp) {
		if (vp->v_mount != mountp) {
			simple_unlock(&mntvnode_slock);
			goto loop;
		}
d464 8
a471 35
		nvp = vp->v_mntvnodes.le_next;
		/*
		 * Step 4: invalidate all inactive vnodes.
		 */
		if (vrecycle(vp, &mntvnode_slock, p))
			goto loop;

		/*
		 * Step 5: invalidate all cached file data.
		 */
		simple_lock(&vp->v_interlock);
		simple_unlock(&mntvnode_slock);
		if (vget(vp, LK_EXCLUSIVE  | LK_INTERLOCK, p))
			goto loop;
		if (vinvalbuf(vp, 0, cred, p, 0, 0))
			panic("ext2fs_reload: dirty2");
		/*
		 * Step 6: re-read inode data for all active vnodes.
		 */
		ip = VTOI(vp);
		error = bread(devvp, fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
				  (int)fs->e2fs_bsize, NOCRED, &bp);
		if (error) {
			vput(vp);
			return (error);
		}
		cp = (caddr_t)bp->b_data +
		    (ino_to_fsbo(fs, ip->i_number) * EXT2_DINODE_SIZE);
		e2fs_iload((struct ext2fs_dinode *)cp, &ip->i_din.e2fs_din);
		brelse(bp);
		vput(vp);
		simple_lock(&mntvnode_slock);
	}
	simple_unlock(&mntvnode_slock);
	return (0);
d729 33
d776 2
a777 4
	register struct vnode *vp, *nvp;
	register struct inode *ip;
	register struct ufsmount *ump = VFSTOUFS(mp);
	register struct m_ext2fs *fs;
d779 1
d790 9
a798 33
	simple_lock(&mntvnode_slock);
loop:
	for (vp = mp->mnt_vnodelist.lh_first; vp != NULL; vp = nvp) {
		/*
		 * If the vnode that we are about to sync is no longer
		 * associated with this mount point, start over.
		 */
		if (vp->v_mount != mp)
			goto loop;
		simple_lock(&vp->v_interlock);
		nvp = vp->v_mntvnodes.le_next;
		ip = VTOI(vp);
		if (vp->v_type == VNON || ((ip->i_flag &
		     (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
		     vp->v_dirtyblkhd.lh_first == NULL) ||
		     waitfor == MNT_LAZY) {
			simple_unlock(&vp->v_interlock);
			continue;
		}
		simple_unlock(&mntvnode_slock);
		error = vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p);
		if (error) {
			simple_lock(&mntvnode_slock);
			if (error == ENOENT)
				goto loop;
			continue;
		}
		if ((error = VOP_FSYNC(vp, cred, waitfor, p)) != 0)
			allerror = error;
		vput(vp);
		simple_lock(&mntvnode_slock);
	}
	simple_unlock(&mntvnode_slock);
@


1.14
log
@These file systems don't do softudpates.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.13 2001/02/20 01:50:12 assar Exp $	*/
d106 7
@


1.13
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.12 2000/04/26 23:24:41 jasoni Exp $	*/
a771 2
		if (ump->um_mountp->mnt_flag & MNT_SOFTDEP)
			waitfor = MNT_NOWAIT;
@


1.12
log
@Support for ext2fs rev. 1 (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.11 2000/02/07 04:57:18 assar Exp $	*/
d170 1
a170 1
	caddr_t data;
@


1.11
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.10 1999/05/31 17:34:53 millert Exp $	*/
d57 2
d71 2
d74 12
d103 2
d130 2
a131 1
	if ((error = vfs_rootmountalloc("ext2fs", "root_device", &mp)) != 0)
d133 2
d139 1
d147 8
a154 1
	(void) copystr(mp->mnt_stat.f_mntonname, fs->e2fs_fsmnt, MNAMELEN -1, 0);
a155 1

a233 1
			(void) ext2fs_sbupdate(ump, MNT_WAIT);
d289 2
a290 2
	(void) copyinstr(path, fs->e2fs_fsmnt, sizeof(fs->e2fs_fsmnt) - 1, &size);
	bcopy(&args, &mp->mnt_stat.mount_info.ufs_args, sizeof(args));
d292 5
d339 1
d347 1
a347 4
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, 0, cred, p, 0, 0);
	VOP_UNLOCK(devvp, 0, p);
	if (error)
d357 3
a359 2
	error = bread(devvp, (daddr_t)(SBOFF / size), SBSIZE, NOCRED, &bp);
	if (error)
d361 1
d363 2
a364 7
	if (newfs->e2fs_magic != E2FS_MAGIC || newfs->e2fs_rev != E2FS_REV) {
#ifdef DIAGNOSTIC
		printf("Wrong magic number: %x (expected %x for ext2 fs)",
					newfs->e2fs_magic, E2FS_MAGIC);
		printf("or wrong revision number: %x (expected %x for ext2 fs)",
					newfs->e2fs_rev, E2FS_REV);
#endif
d366 1
a366 9
		return (EIO);		/* XXX needs translation */
	}
	if (newfs->e2fs_log_bsize > 2) { /* block size = 1024|2048|4096 */
#ifdef DIAGNOSTIC
		printf("wrong block size: %d (expected <=2 for ext2 fs)\n",
			newfs->e2fs_log_bsize);
#endif
		brelse(bp);
		return (EIO);	   /* XXX needs translation */
a368 1

d373 4
a376 3
	bcopy(newfs, &fs->e2fs, SBSIZE);
	fs->e2fs_ncg = howmany(fs->e2fs.e2fs_bcount - fs->e2fs.e2fs_first_dblock,
		fs->e2fs.e2fs_bpg);
d385 1
a385 1
	fs->e2fs_ipb = fs->e2fs_bsize / sizeof(struct ext2fs_dinode);
d393 5
a397 3
		error = bread(devvp , fsbtodb(fs, ((fs->e2fs_bsize>1024)?0:1)+i+1),
				fs->e2fs_bsize, NOCRED, &bp);
		if (error)
d399 4
a402 3
		bcopy(bp->b_data,
			&fs->e2fs_gd[i* fs->e2fs_bsize / sizeof(struct ext2_gd)],
			fs->e2fs_bsize);
d440 3
a442 4
		bcopy((struct ext2fs_dinode *)bp->b_data +
			ino_to_fsbo(fs, ip->i_number),
			&ip->i_din.e2fs_din, sizeof(struct ext2fs_dinode));
		ip->i_effnlink = ip->i_e2fs_nlink;
d482 1
a482 4
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0);
	VOP_UNLOCK(devvp, 0, p);
	if (error)
d499 1
a499 1
			sizeof(struct ext2fs_dinode));
d505 2
a506 17
	if (fs->e2fs_magic != E2FS_MAGIC || fs->e2fs_rev != E2FS_REV) {
#ifdef DIAGNOSTIC
		printf("Wrong magic number: %x (expected %x for ext2 fs)",
			fs->e2fs_magic, E2FS_MAGIC);
		printf(" or wrong revision number: %x (expected %x for ext2 fs)\n",
			fs->e2fs_rev, E2FS_REV);
#endif
		error = EFTYPE;
		goto out;
	}

	if (fs->e2fs_log_bsize > 2) { /* block size = 1024|2048|4096 */
#ifdef DIAGNOSTIC
		printf("wrong block size: %d (expected <2 for ext2 fs)\n",
			fs->e2fs_log_bsize);
#endif
		error = EFTYPE;
a507 2
	}

d509 1
a509 1
	bzero((caddr_t)ump, sizeof *ump);
d511 2
a512 1
	bcopy(bp->b_data, ump->um_e2fs, SBSIZE);
d537 1
a537 1
	m_fs->e2fs_ipb = m_fs->e2fs_bsize / sizeof(struct ext2fs_dinode);
d543 3
a545 2
		error = bread(devvp , fsbtodb(m_fs, ((m_fs->e2fs_bsize>1024)?0:1)+i+1),
			m_fs->e2fs_bsize, NOCRED, &bp);
d550 4
a553 3
		bcopy(bp->b_data,
			&m_fs->e2fs_gd[i* m_fs->e2fs_bsize / sizeof(struct ext2_gd)],
			m_fs->e2fs_bsize);
d562 1
a571 1
	devvp->v_specmountpoint = NULL;
d574 1
d576 1
d612 3
a614 1
	ump->um_devvp->v_specmountpoint = NULL;
d617 1
a617 1
	vrele(ump->um_devvp);
d622 1
d665 1
d675 3
a677 5
	overhead_per_group = 1 /* super block */ +
						 fs->e2fs_ngdb +
						 1 /* block bitmap */ +
						 1 /* inode bitmap */ +
						 fs->e2fs_itpg;
d680 10
a689 1

a700 2
		bcopy(&mp->mnt_stat.mount_info.ufs_args,
		    &sbp->mount_info.ufs_args, sizeof(struct ufs_args));
d727 1
a727 6
	/*
	 * Write back modified superblock.
	 * Consistency check that the superblock
	 * is still in the buffer cache.
	 */
	if (fs->e2fs_fmod != 0 && fs->e2fs_ronly != 0) {	/* XXX */
d731 1
d737 1
a737 3
	for (vp = mp->mnt_vnodelist.lh_first;
		 vp != NULL;
		 vp = nvp) {
a743 1

d764 1
a764 2
		VOP_UNLOCK(vp, 0, p);
		vrele(vp);
d782 6
a787 3
	
	if (fs->e2fs_fmod != 0 && (error = ext2fs_sbupdate(ump, waitfor)) != 0)
		allerror = error;
d1015 2
a1016 3
			fs->e2fs_bsize, 0, 0);
		bcopy(&fs->e2fs_gd[i* fs->e2fs_bsize / sizeof(struct ext2_gd)],
		 bp->b_data, fs->e2fs_bsize);
d1022 1
a1022 1

d1026 41
@


1.11.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.14 2001/03/04 06:32:41 csapuntz Exp $	*/
a56 2
#include <sys/pool.h>
#include <sys/lock.h>
a68 2
extern struct lock ufs_hashlock;

a69 12
static int ext2fs_checksb __P((struct ext2fs *, int));

extern struct vnodeopv_desc ext2fs_vnodeop_opv_desc;
extern struct vnodeopv_desc ext2fs_specop_opv_desc;
extern struct vnodeopv_desc ext2fs_fifoop_opv_desc;

struct vnodeopv_desc *ext2fs_vnodeopv_descs[] = {
	&ext2fs_vnodeop_opv_desc,
	&ext2fs_specop_opv_desc,
	&ext2fs_fifoop_opv_desc,
	NULL,
};
a86 2
struct pool ext2fs_inode_pool;

d112 1
a112 2
	if ((error = vfs_rootmountalloc("ext2fs", "root_device", &mp)) != 0) {
		vrele(rootvp);
a113 2
	}

a117 1
		vrele(rootvp);
d125 1
a125 8
	bzero(fs->e2fs_fsmnt, sizeof(fs->e2fs_fsmnt));
	(void) copystr(mp->mnt_stat.f_mntonname, fs->e2fs_fsmnt, 
	    sizeof(fs->e2fs_fsmnt) - 1, 0);
	if (fs->e2fs.e2fs_rev > E2FS_REV0) {
		bzero(fs->e2fs.e2fs_fsmnt, sizeof(fs->e2fs.e2fs_fsmnt));
		(void) copystr(mp->mnt_stat.f_mntonname, fs->e2fs.e2fs_fsmnt,
		    sizeof(fs->e2fs.e2fs_fsmnt) - 1, 0);
	}
d127 1
d142 1
a142 1
	void *data;
d206 1
d262 2
a263 2
	(void) copyinstr(path, fs->e2fs_fsmnt, sizeof(fs->e2fs_fsmnt) - 1,
	    &size);
a264 5
	if (fs->e2fs.e2fs_rev > E2FS_REV0) {
		(void) copystr(mp->mnt_stat.f_mntonname, fs->e2fs.e2fs_fsmnt,
		    sizeof(fs->e2fs.e2fs_fsmnt) - 1, &size);
		bzero(fs->e2fs.e2fs_fsmnt, sizeof(fs->e2fs.e2fs_fsmnt) - size);
	}
a306 1
	caddr_t cp;
d314 4
a317 1
	if (vinvalbuf(devvp, 0, cred, p, 0, 0))
d327 11
a337 2
	error = bread(devvp, (ufs_daddr_t)(SBOFF / size), SBSIZE, NOCRED, &bp);
	if (error) {
d339 1
a339 1
		return (error);
d341 5
a345 3
	newfs = (struct ext2fs *)bp->b_data;
	error = ext2fs_checksb(newfs, (mountp->mnt_flag & MNT_RDONLY) != 0);
	if (error) {
d347 1
a347 1
		return (error);
d350 1
d355 3
a357 4
	e2fs_sbload(newfs, &fs->e2fs);
	fs->e2fs_ncg =
	    howmany(fs->e2fs.e2fs_bcount - fs->e2fs.e2fs_first_dblock,
	    fs->e2fs.e2fs_bpg);
d366 1
a366 1
	fs->e2fs_ipb = fs->e2fs_bsize / EXT2_DINODE_SIZE;
d374 3
a376 5
		error = bread(devvp ,
		    fsbtodb(fs, ((fs->e2fs_bsize>1024)? 0 : 1) + i + 1),
		    fs->e2fs_bsize, NOCRED, &bp);
		if (error) {
			brelse(bp);
d378 3
a380 4
		}
		e2fs_cgload((struct ext2_gd*)bp->b_data,
		    &fs->e2fs_gd[i* fs->e2fs_bsize / sizeof(struct ext2_gd)],
		    fs->e2fs_bsize);
d418 4
a421 3
		cp = (caddr_t)bp->b_data +
		    (ino_to_fsbo(fs, ip->i_number) * EXT2_DINODE_SIZE);
		e2fs_iload((struct ext2fs_dinode *)cp, &ip->i_din.e2fs_din);
d461 4
a464 1
	if ((error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0)) != 0)
d481 1
a481 1
	    EXT2_DINODE_SIZE);
d487 17
a503 2
	error = ext2fs_checksb(fs, ronly);
	if (error)
d505 2
d508 1
a508 1
	memset((caddr_t)ump, 0, sizeof *ump);
d510 1
a510 2
	memset((caddr_t)ump->um_e2fs, 0, sizeof(struct m_ext2fs));
	e2fs_sbload((struct ext2fs*)bp->b_data, &ump->um_e2fs->e2fs);
d535 1
a535 1
	m_fs->e2fs_ipb = m_fs->e2fs_bsize / EXT2_DINODE_SIZE;
d541 2
a542 3
		error = bread(devvp ,
		    fsbtodb(m_fs, ((m_fs->e2fs_bsize>1024)? 0 : 1) + i + 1),
		    m_fs->e2fs_bsize, NOCRED, &bp);
d547 3
a549 4
		e2fs_cgload((struct ext2_gd*)bp->b_data,
		    &m_fs->e2fs_gd[
			i * m_fs->e2fs_bsize / sizeof(struct ext2_gd)],
		    m_fs->e2fs_bsize);
a557 1
	mp->mnt_flag |= MNT_LOCAL;
d567 1
a569 1
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
a570 1
	VOP_UNLOCK(devvp, 0, p);
d606 1
a606 3
	if (ump->um_devvp->v_type != VBAD)
		ump->um_devvp->v_specmountpoint = NULL;
	vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
d609 1
a609 1
	vput(ump->um_devvp);
a613 1
	mp->mnt_flag &= ~MNT_LOCAL;
a655 1
	int i, ngroups;
d665 5
a669 3
	overhead_per_group = 1 /* block bitmap */ +
				 1 /* inode bitmap */ +
				 fs->e2fs_itpg;
d672 1
a672 10
	if (fs->e2fs.e2fs_rev > E2FS_REV0 &&
	    fs->e2fs.e2fs_features_rocompat & EXT2F_ROCOMPAT_SPARSESUPER) {
		for (i = 0, ngroups = 0; i < fs->e2fs_ncg; i++) {
			if (cg_has_sb(i))
				ngroups++;
		}
	} else {
		ngroups = fs->e2fs_ncg;
	}
	overhead += ngroups * (1 + fs->e2fs_ngdb);
d684 2
d712 6
a717 1
	if (fs->e2fs_ronly != 0) {		/* XXX */
a720 1

d726 3
a728 1
	for (vp = mp->mnt_vnodelist.lh_first; vp != NULL; vp = nvp) {
d735 1
d756 2
a757 1
		vput(vp);
d765 2
d775 3
a777 6
	if (fs->e2fs_fmod != 0) {
		fs->e2fs_fmod = 0;
		fs->e2fs.e2fs_wtime = time.tv_sec;
		if ((error = ext2fs_cgupdate(ump, waitfor)))
			allerror = error;
	}
d1005 3
a1007 2
		    fs->e2fs_bsize, 0, 0);
		e2fs_cgsave(&fs->e2fs_gd[i* fs->e2fs_bsize / sizeof(struct ext2_gd)], (struct ext2_gd*)bp->b_data, fs->e2fs_bsize);
d1013 1
a1013 1
	
a1016 41
}

static int
ext2fs_checksb(fs, ronly)
	struct ext2fs *fs;
	int ronly;
{
	if (fs2h16(fs->e2fs_magic) != E2FS_MAGIC) {
		return (EIO);		/* XXX needs translation */
	}
	if (fs2h32(fs->e2fs_rev) > E2FS_REV1) {
#ifdef DIAGNOSTIC
		printf("Ext2 fs: unsupported revision number: %x\n",
		    fs2h32(fs->e2fs_rev));
#endif
		return (EIO);		/* XXX needs translation */
	}
	if (fs2h32(fs->e2fs_log_bsize) > 2) { /* block size = 1024|2048|4096 */
#ifdef DIAGNOSTIC
		printf("Ext2 fs: bad block size: %d (expected <=2 for ext2 fs)\n",
		    fs2h32(fs->e2fs_log_bsize));
#endif
		return (EIO);	   /* XXX needs translation */
	}
	if (fs2h32(fs->e2fs_rev) > E2FS_REV0) {
		if (fs2h32(fs->e2fs_first_ino) != EXT2_FIRSTINO ||
		    fs2h16(fs->e2fs_inode_size) != EXT2_DINODE_SIZE) {
			printf("Ext2 fs: unsupported inode size\n");
			return (EINVAL);      /* XXX needs translation */
		}
		if (fs2h32(fs->e2fs_features_incompat) &
		    ~EXT2F_INCOMPAT_SUPP) {
			printf("Ext2 fs: unsupported optionnal feature\n");
			return (EINVAL);      /* XXX needs translation */
		}
		if (!ronly && fs2h32(fs->e2fs_features_rocompat) &
		    ~EXT2F_ROCOMPAT_SUPP) {
			return (EROFS);      /* XXX needs translation */
		}
	}
	return (0);
@


1.11.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.11.2.1 2001/05/14 22:47:39 niklas Exp $	*/
a105 7

int
ext2fs_init(vfsp)
	struct vfsconf *vfsp;
{
	return (ufs_init(vfsp));
}
@


1.11.2.3
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ext2fs_vfsops.c,v 1.40 2000/11/27 08:39:53 chs Exp $	*/
a319 52
int ext2fs_reload_vnode(struct vnode *, void *args);

struct ext2fs_reload_args {
	struct m_ext2fs *fs;
	struct proc *p;
	struct ucred *cred;
	struct vnode *devvp;
};

int
ext2fs_reload_vnode(struct vnode *vp, void *args) {
	struct ext2fs_reload_args *era = args;
	struct buf *bp;
	struct inode *ip;
	int error;
	caddr_t cp;

	/*
	 * Step 4: invalidate all inactive vnodes.
	 */
	if (vp->v_usecount == 0) {
		vgonel(vp, era->p);
		return (0);
	}

	/*
	 * Step 5: invalidate all cached file data.
	 */
	if (vget(vp, LK_EXCLUSIVE  | LK_INTERLOCK, era->p))
		return (0);
	
	if (vinvalbuf(vp, 0, era->cred, era->p, 0, 0))
		panic("ext2fs_reload: dirty2");
	/*
	 * Step 6: re-read inode data for all active vnodes.
	 */
	ip = VTOI(vp);
	error = bread(era->devvp, 
	    fsbtodb(era->fs, ino_to_fsba(era->fs, ip->i_number)),
	    (int)era->fs->e2fs_bsize, NOCRED, &bp);
	if (error) {
		vput(vp);
		return (error);
	}
	cp = (caddr_t)bp->b_data +
	    (ino_to_fsbo(era->fs, ip->i_number) * EXT2_DINODE_SIZE);
	e2fs_iload((struct ext2fs_dinode *)cp, &ip->i_din.e2fs_din);
	brelse(bp);
	vput(vp);
	return (0);
}

d339 2
a340 1
	struct vnode *devvp;
d346 1
a346 1
	struct ext2fs_reload_args era;
d354 1
a354 4
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, 0, cred, p, 0, 0);
	VOP_UNLOCK(devvp, 0, p);
	if (error)
d356 1
d412 8
d421 6
a426 4
	era.p = p;
	era.cred = cred;
	era.fs = fs;
	era.devvp = devvp;
d428 28
a455 3
	error = vfs_mount_foreach_vnode(mountp, ext2fs_reload_vnode, &era);

	return (error);
a569 2
	mp->mnt_dev_bshift = DEV_BSHIFT;	/* XXX */
	mp->mnt_fs_bshift = m_fs->e2fs_bshift;
a573 1
	ump->um_lognindir = ffs(NINDIR(m_fs)) - 1;
a577 1

a712 33
int ext2fs_sync_vnode(struct vnode *vp, void *);

struct ext2fs_sync_args {
	int allerror;
	int waitfor;
	struct proc *p;
	struct ucred *cred;
};

int
ext2fs_sync_vnode(struct vnode *vp, void *args) 
{
	struct ext2fs_sync_args *esa = args;
	struct inode *ip;
	int error;

	ip = VTOI(vp);
	if (vp->v_type == VNON || 
	    ((ip->i_flag & (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
		vp->v_dirtyblkhd.lh_first == NULL) ||
	    esa->waitfor == MNT_LAZY) {
		simple_unlock(&vp->v_interlock);
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, esa->p))
		return (0);

	if ((error = VOP_FSYNC(vp, esa->cred, esa->waitfor, esa->p)) != 0)
		esa->allerror = error;
	vput(vp);
	return (0);
}
d727 4
a730 2
	struct ufsmount *ump = VFSTOUFS(mp);
	struct m_ext2fs *fs;
a731 1
	struct ext2fs_sync_args esa;
d742 33
a774 9
	esa.p = p;
	esa.cred = cred;
	esa.allerror = 0;
	esa.waitfor = waitfor;

	vfs_mount_foreach_vnode(mp, ext2fs_sync_vnode, &esa);
	if (esa.allerror != 0)
		allerror = esa.allerror;

a902 1
	vp->v_uvm.u_size = ip->i_e2fs_size;
@


1.11.2.4
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: ext2fs_vfsops.c,v 1.1 1997/06/11 09:34:07 bouyer Exp $	*/
a61 1
#include <ufs/ufs/extattr.h>
d100 1
a100 2
	ufs_check_export,
	vfs_stdextattrctl
d405 4
a408 1
	if (vinvalbuf(devvp, 0, cred, p, 0, 0))
a409 1

d588 2
d594 1
d599 1
d933 1
@


1.11.2.5
log
@Merge in -current from roughly a week ago
@
text
@d74 2
a75 2
int ext2fs_sbupdate(struct ufsmount *, int);
static int ext2fs_checksb(struct ext2fs *, int);
@


1.11.2.6
log
@Sync the SMP branch with 3.3
@
text
@d248 1
a248 2
			return (vfs_export(mp, &ump->um_export, 
			    &args.export_info));
d958 1
a958 1
		ufhp->ufid_ino > fs->e2fs_ncg * fs->e2fs.e2fs_ipg)
d1089 1
a1089 1
			printf("Ext2 fs: unsupported optional feature\n");
@


1.11.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.11.2.6 2003/03/28 00:08:47 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
d418 1
a418 1
	error = bread(devvp, (ufs1_daddr_t)(SBOFF / size), SBSIZE, NOCRED, &bp);
@


1.11.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
a84 1
const struct vfsops ext2fs_vfsops = {
d365 1
a365 1
	e2fs_iload((struct ext2fs_dinode *)cp, &ip->i_e2din);
a538 1
	ump->um_fstype = UM_EXT2FS;
a855 1
	ip->i_ump = ump;
d895 1
a895 1
				&ip->i_e2din, sizeof(struct ext2fs_dinode));
a898 5
	/* If the inode was deleted, reset all fields */
	if (ip->i_e2fs_dtime != 0) {
		ip->i_e2fs_mode = ip->i_e2fs_size = ip->i_e2fs_nblock = 0;
	}

d912 1
@


1.11.2.9
log
@Merge with the trunk
@
text
@a74 1
#ifdef FIFO
a75 1
#endif
a79 1
#ifdef FIFO
a80 1
#endif
d122 1
d490 1
@


1.10
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.9 1998/02/08 22:41:48 tholo Exp $	*/
a69 2
int ext2fs_check_export __P((struct mount *, struct ufid *, struct mbuf *,
	struct vnode **, int *, struct ucred **));
d83 2
a89 47
 * This is the generic part of fhtovp called after the underlying
 * filesystem has validated the file handle.
 *
 * Verify that a host should have access to a filesystem, and if so
 * return a vnode for the presented file handle.
 */
int
ext2fs_check_export(mp, ufhp, nam, vpp, exflagsp, credanonp)
	register struct mount *mp;
	struct ufid *ufhp;
	struct mbuf *nam;
	struct vnode **vpp;
	int *exflagsp;
	struct ucred **credanonp;
{
	register struct inode *ip;
	register struct netcred *np;
	register struct ufsmount *ump = VFSTOUFS(mp);
	struct vnode *nvp;
	int error;

	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &ump->um_export, nam);
	if (np == NULL)
		return (EACCES);

	if ((error = VFS_VGET(mp, ufhp->ufid_ino, &nvp)) != 0) {
		*vpp = NULLVP;
		return (error);
	}
	ip = VTOI(nvp);
	if (ip->i_e2fs_mode == 0 || ip->i_e2fs_dtime != 0 || 
		ip->i_e2fs_gen != ufhp->ufid_gen) {
		vput(nvp);
		*vpp = NULLVP;
		return (ESTALE);
	}
	*vpp = nvp;
	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
	return (0);
}   


/*
d903 1
a903 1
ext2fs_fhtovp(mp, fhp, nam, vpp, exflagsp, credanonp)
a905 1
	struct mbuf *nam;
a906 2
	int *exflagsp;
	struct ucred **credanonp;
d908 3
d919 14
a932 1
	return (ext2fs_check_export(mp, ufhp, nam, vpp, exflagsp, credanonp));
d953 17
@


1.9
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.8 1998/01/09 20:41:54 csapuntz Exp $	*/
d310 1
a707 5
#ifdef COMPAT_09
	sbp->f_type = 1;
#else
	sbp->f_type = 0;
#endif
a728 1
		sbp->f_type = mp->mnt_vfc->vfc_typenum;
d731 2
@


1.8
log
@Similar race in Ext2FS
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.7 1997/11/10 19:30:24 provos Exp $	*/
d188 1
a188 1
	char *path;
@


1.7
log
@fix foul up from last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.6 1997/11/09 13:12:17 provos Exp $	*/
d853 2
d880 10
a889 1
	ufs_ihashins(ip);
@


1.6
log
@dont panic on sync, merge in changes from ffs_vfsops.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.5 1997/11/06 05:59:15 csapuntz Exp $	*/
d602 2
a603 2
	mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_EXT2FS);
	mp->mnt_maxsymlinklen = mp->mnt_vfc->vfc_typenum;;
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.4 1997/06/20 14:04:31 kstailey Exp $	*/
d253 1
d360 4
a363 1
	if (vinvalbuf(devvp, 0, cred, p, 0, 0))
d365 1
d431 1
d433 5
d442 3
a444 4
		if (vp->v_usecount == 0) {
			vgone(vp);
			continue;
		}
d448 3
a450 1
		if (vget(vp, LK_EXCLUSIVE, p))
d467 1
d470 1
a470 2
		if (vp->v_mount != mountp)
			goto loop;
d472 1
d507 4
a510 1
	if ((error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0)) != 0)
d603 1
a603 2
	mp->mnt_maxsymlinklen = EXT2_MAXSYMLINKLEN;
	mp->mnt_flag |= MNT_LOCAL;
d613 1
a659 1
	mp->mnt_flag &= ~MNT_LOCAL;
a671 1
	extern int doforce;
a674 2
	if (!doforce)
		flags &= ~FORCECLOSE;
d676 11
a686 1
	error = vflush(mp, NULLVP, flags);
d755 1
a755 1
	register struct vnode *vp;
d767 3
a769 8
	if (fs->e2fs_fmod != 0) {
		if (fs->e2fs_ronly != 0) {		/* XXX */
			printf("fs = %s\n", fs->e2fs_fsmnt);
			panic("update: rofs mod");
		}
		fs->e2fs_fmod = 0;
		fs->e2fs.e2fs_wtime = time.tv_sec;
		allerror = ext2fs_cgupdate(ump, waitfor);
d774 1
d778 1
a778 1
		 vp = vp->v_mntvnodes.le_next) {
d785 9
a793 1
		if (VOP_ISLOCKED(vp))
d795 7
a801 4
		ip = VTOI(vp);
		if ((ip->i_flag &
			(IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
			vp->v_dirtyblkhd.lh_first == NULL)
d803 1
a803 2
		if (vget(vp, LK_EXCLUSIVE, p))
			goto loop;
d806 3
a808 1
		vput(vp);
d810 1
d814 13
a826 1
	if ((error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p)) != 0)
d863 1
d886 1
a886 1
		 * be misleading to leave it on its hash chain. With mode
d897 1
a897 1

@


1.4
log
@Change errno cause by mounting invalid filesystems from EINVAL to EFTYPE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.3 1997/06/12 21:09:35 downsj Exp $	*/
a73 1
	MOUNT_EXT2FS,
d148 1
a148 1
	register struct mount *mp;
a150 1
	size_t size;
d159 2
a160 4
	mp = malloc(sizeof(struct mount), M_MOUNT, M_WAITOK);
	bzero((char *)mp, sizeof(struct mount));
	mp->mnt_op = &ext2fs_vfsops;
	mp->mnt_flag = MNT_RDONLY;
d162 2
d167 1
a167 5
	if ((error = vfs_lock(mp)) != 0) {
		(void)ext2fs_unmount(mp, 0, p);
		free(mp, M_MOUNT);
		return (error);
	}
d169 1
a169 1
	mp->mnt_vnodecovered = NULLVP;
d172 1
a172 6
	bzero(fs->e2fs_fsmnt, sizeof(fs->e2fs_fsmnt));
	fs->e2fs_fsmnt[0] = '/';
	bcopy(fs->e2fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
	(void) copystr(ROOTNAME, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
		&size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d174 2
a175 1
	vfs_unlock(mp);
a214 2
			if (vfs_busy(mp))
				return (EBUSY);
a221 1
			vfs_unbusy(mp);
d238 1
a238 1
				VOP_LOCK(devvp);
d242 1
a242 1
					VOP_UNLOCK(devvp);
d245 1
a245 1
				VOP_UNLOCK(devvp);
d286 1
a286 1
		VOP_LOCK(devvp);
d292 1
a292 1
		VOP_UNLOCK(devvp);
d438 1
a438 1
		if (vget(vp, 1))
d595 1
a595 1
	devvp->v_specflags |= SI_MOUNTEDON;
d635 2
a636 1
	ump->um_devvp->v_specflags &= ~SI_MOUNTEDON;
d711 1
d715 1
a715 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d774 1
a774 1
		if (vget(vp, 1))
@


1.3
log
@Sync with NetBSD, mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext2fs_vfsops.c,v 1.2 1997/05/30 08:34:06 downsj Exp $	*/
d311 1
a311 1
			error = EINVAL;	/* needs translation */
d537 1
a537 1
		error = EINVAL;		/* XXX needs translation */
d546 1
a546 1
		error = EINVAL;	 /* XXX needs translation */
@


1.2
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 2
a2 4
/*	$OpenBSD$	*/
/*	$NetBSD: ffs_vfsops.c,v 1.21 1996/10/12 21:58:47 christos Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d5 1
d38 1
@


1.1
log
@Initial revision
@
text
@d1 1
a85 1
	ext2fs_mountroot,
a154 3
	if (root_device->dv_class != DV_DISK)
		return (ENODEV);
	
d198 2
a199 2
	const char *path;
	void * data;
@


1.1.1.1
log
@Non-GPLd ext2fs code from Manuel, unmodified.
@
text
@@
