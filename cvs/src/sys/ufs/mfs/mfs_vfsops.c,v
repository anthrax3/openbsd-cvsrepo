head	1.54;
access;
symbols
	OPENBSD_6_1_BASE:1.54
	OPENBSD_6_0:1.50.0.2
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.47.0.6
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.42.0.8
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.6
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.39.0.12
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.8
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.10
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.6
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.34.0.6
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.4
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.22
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.11
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.54
date	2017.01.10.19.48.32;	author bluhm;	state Exp;
branches;
next	1.53;
commitid	nzxicVheAaFpfTKW;

1.53
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.52;
commitid	W7ztnDZwvjCaeQTS;

1.52
date	2016.09.08.16.57.29;	author tedu;	state Exp;
branches;
next	1.51;
commitid	RGzDsU7wDrVqyAFh;

1.51
date	2016.09.08.16.44.46;	author tedu;	state Exp;
branches;
next	1.50;
commitid	bunjYKq8UY9BzXoO;

1.50
date	2016.04.26.18.37.03;	author natano;	state Exp;
branches;
next	1.49;
commitid	WbumX8gCUOD8jZ5X;

1.49
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.48;
commitid	kCz5QgxnxRMKOzNf;

1.48
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.47;
commitid	p4LJxGKbi0BU2cG6;

1.47
date	2013.12.12.19.00.10;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.15.11.20.55;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2012.12.29.14.54.11;	author beck;	state Exp;
branches;
next	1.43;

1.43
date	2012.09.10.11.11.00;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.16.21.21.25;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.06.21.49.37;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.04.19.32.13;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.28.19.31.31;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.24.12.57.18;	author mpf;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.25.15.01.54;	author sturm;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.14.20.01.50;	author sturm;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.30.14.20.08;	author sturm;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.28.13.18.17;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.30.10.35.08;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.03.20.14.02;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.04.08.06.05;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.11.03.30.25;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.06.20.52.14;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.12.14.02.23;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.21.00.40.08;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.27.15;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.18.09.23.26;	author ericj;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.23.01.40.59;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.05.08.24.33;	author espie;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.04.12.17.16.52;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.20.01.50.12;	author assar;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.07.04.57.18;	author assar;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.12.06.07.28.06;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.10.15.15.16.13;	author art;	state Exp;
branches;
next	1.9;

1.9
date	99.09.03.18.18.16;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.05.31.17.34.55;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.03.09.00.17.05;	author art;	state Exp;
branches;
next	1.6;

1.6
date	98.02.08.22.41.52;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.59.23;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.20.21.41;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.27.12;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.15.47;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.34;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2001.05.14.22.47.42;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.12.2.8;

1.12.2.8
date	2004.02.19.11.01.42;	author niklas;	state Exp;
branches;
next	1.12.2.9;

1.12.2.9
date	2004.06.05.23.13.11;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2002.01.31.22.55.50;	author niklas;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	1.15.4.4;

1.15.4.4
date	2003.05.19.22.38.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Remove the unused olddp parameter from function dounmount().
OK mpi@@ millert@@
@
text
@/*	$OpenBSD: mfs_vfsops.c,v 1.53 2016/11/07 00:26:33 guenther Exp $	*/
/*	$NetBSD: mfs_vfsops.c,v 1.10 1996/02/09 22:31:28 christos Exp $	*/

/*
 * Copyright (c) 1989, 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mfs_vfsops.c	8.4 (Berkeley) 4/16/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/mount.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/kthread.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ffs/fs.h>
#include <ufs/ffs/ffs_extern.h>

#include <ufs/mfs/mfsnode.h>
#include <ufs/mfs/mfs_extern.h>

static	int mfs_minor;	/* used for building internal dev_t */

/*
 * mfs vfs operations.
 */
const struct vfsops mfs_vfsops = {
	mfs_mount,
	mfs_start,
	ffs_unmount,
	ufs_root,
	ufs_quotactl,
	ffs_statfs,
	ffs_sync,
	ffs_vget,
	ffs_fhtovp,
	ffs_vptofh,
	mfs_init,
	ffs_sysctl,
	mfs_checkexp
};

/*
 * VFS Operations.
 *
 * mount system call
 */
int
mfs_mount(struct mount *mp, const char *path, void *data,
    struct nameidata *ndp, struct proc *p)
{
	struct vnode *devvp;
	struct mfs_args args;
	struct ufsmount *ump;
	struct fs *fs;
	struct mfsnode *mfsp;
	char fspec[MNAMELEN];
	int flags, error;

	error = copyin(data, &args, sizeof(struct mfs_args));
	if (error)
		return (error);

	/*
	 * If updating, check whether changing from read-only to
	 * read/write; if there is no device name, that's all we do.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		ump = VFSTOUFS(mp);
		fs = ump->um_fs;
		if (fs->fs_ronly == 0 && (mp->mnt_flag & MNT_RDONLY)) {
			flags = WRITECLOSE;
			if (mp->mnt_flag & MNT_FORCE)
				flags |= FORCECLOSE;
			error = ffs_flushfiles(mp, flags, p);
			if (error)
				return (error);
		}
		if (fs->fs_ronly && (mp->mnt_flag & MNT_WANTRDWR))
			fs->fs_ronly = 0;
#ifdef EXPORTMFS
		if (args.fspec == NULL)
			return (vfs_export(mp, &ump->um_export, 
			    &args.export_info));
#endif
		return (0);
	}
	error = copyinstr(args.fspec, fspec, sizeof(fspec), NULL);
	if (error)
		return (error);
	error = getnewvnode(VT_MFS, NULL, &mfs_vops, &devvp);
	if (error)
		return (error);
	devvp->v_type = VBLK;
	if (checkalias(devvp, makedev(255, mfs_minor), NULL))
		panic("mfs_mount: dup dev");
	mfs_minor++;
	mfsp = malloc(sizeof *mfsp, M_MFSNODE, M_WAITOK | M_ZERO);
	devvp->v_data = mfsp;
	mfsp->mfs_baseoff = args.base;
	mfsp->mfs_size = args.size;
	mfsp->mfs_vnode = devvp;
	mfsp->mfs_tid = p->p_tid;
	bufq_init(&mfsp->mfs_bufq, BUFQ_FIFO);
	if ((error = ffs_mountfs(devvp, mp, p)) != 0) {
		mfsp->mfs_shutdown = 1;
		vrele(devvp);
		return (error);
	}
	ump = VFSTOUFS(mp);
	fs = ump->um_fs;

	memset(fs->fs_fsmnt, 0, sizeof(fs->fs_fsmnt));
	strlcpy(fs->fs_fsmnt, path, sizeof(fs->fs_fsmnt));
	memcpy(mp->mnt_stat.f_mntonname, fs->fs_fsmnt, MNAMELEN);
	memset(mp->mnt_stat.f_mntfromname, 0, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN);
	memset(mp->mnt_stat.f_mntfromspec, 0, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);
	memcpy(&mp->mnt_stat.mount_info.mfs_args, &args, sizeof(args));

	return (0);
}

/*
 * Used to grab the process and keep it in the kernel to service
 * memory filesystem I/O requests.
 *
 * Loop servicing I/O requests.
 * Copy the requested data into or out of the memory filesystem
 * address space.
 */
int
mfs_start(struct mount *mp, int flags, struct proc *p)
{
	struct vnode *vp = VFSTOUFS(mp)->um_devvp;
	struct mfsnode *mfsp = VTOMFS(vp);
	struct buf *bp;
	int sleepreturn = 0;

	while (1) {
		while (1) {
			if (mfsp->mfs_shutdown == 1)
				break;
			bp = bufq_dequeue(&mfsp->mfs_bufq);
			if (bp == NULL)
				break;
			mfs_doio(mfsp, bp);
			wakeup(bp);
		}
		if (mfsp->mfs_shutdown == 1)
			break;

		/*
		 * If a non-ignored signal is received, try to unmount.
		 * If that fails, clear the signal (it has been "processed"),
		 * otherwise we will loop here, as tsleep will always return
		 * EINTR/ERESTART.
		 */
		if (sleepreturn != 0) {
			if (vfs_busy(mp, VB_WRITE|VB_NOWAIT) ||
			    dounmount(mp,
			    (CURSIG(p) == SIGKILL) ? MNT_FORCE : 0, p))
				CLRSIG(p, CURSIG(p));
			sleepreturn = 0;
			continue;
		}
		sleepreturn = tsleep(vp, PWAIT | PCATCH, "mfsidl", 0);
	}
	return (0);
}

/*
 * check export permission, not supported
 */
int
mfs_checkexp(struct mount *mp, struct mbuf *nam, int *exflagsp,
    struct ucred **credanonp)
{
	return (EOPNOTSUPP);
}

/*
 * Memory based filesystem initialization.
 */
int
mfs_init(struct vfsconf *vfsp)
{
	return (ffs_init(vfsp));
}
@


1.53
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.52 2016/09/08 16:57:29 tedu Exp $	*/
d198 1
a198 1
			    (CURSIG(p) == SIGKILL) ? MNT_FORCE : 0, p, NULL))
@


1.52
log
@move mfs_pri into tsleep so it's easy to see and it doesn't change
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.51 2016/09/08 16:44:46 tedu Exp $	*/
d138 1
a138 1
	mfsp->mfs_pid = p->p_pid;
@


1.51
log
@delete useless comments, such as how KVA is mapped on HP
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.50 2016/04/26 18:37:03 natano Exp $	*/
a159 2
int	mfs_pri = PWAIT | PCATCH;		/* XXX prob. temp */

d203 1
a203 1
		sleepreturn = tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0);
@


1.50
log
@Populate all necessary statfs members in .vfs_statfs. cd9660, udf,
msdosfs and nfsv2 don't set f_namemax. ntfs and ext2fs don't set
f_namemeax and f_favail. fusefs doesn't set f_mntfromspec, f_favail and
f_iosize. Also, make all filesystems use copy_statfs_info(), so that all
statfs information is filled in correctly for the (sb != &mp->mnt-stat)
case.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.49 2016/03/14 23:08:06 krw Exp $	*/
a82 1
/* ARGSUSED */
a169 1
/* ARGSUSED */
a212 1
/* ARGUSED */
@


1.49
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.48 2015/03/14 03:38:52 jsg Exp $	*/
d68 1
a68 1
	mfs_statfs,
a209 16
}

/*
 * Get file system statistics.
 */
int
mfs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	int error;

	error = ffs_statfs(mp, sbp, p);
	strncpy(&sbp->f_fstypename[0], mp->mnt_vfc->vfc_name, MFSNAMELEN);
	if (sbp != &mp->mnt_stat)
		memcpy(&sbp->mount_info.mfs_args,
		    &mp->mnt_stat.mount_info.mfs_args, sizeof(struct mfs_args));
	return (error);
@


1.48
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.47 2013/12/12 19:00:10 tedu Exp $	*/
d131 1
a131 1
	if (checkalias(devvp, makedev(255, mfs_minor), (struct mount *)0))
@


1.47
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.46 2013/04/15 15:32:19 jsing Exp $	*/
a37 1
#include <sys/kernel.h>
@


1.46
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.45 2013/01/15 11:20:55 jsing Exp $	*/
d150 1
a150 1
	bzero(fs->fs_fsmnt, sizeof(fs->fs_fsmnt));
d152 2
a153 2
	bcopy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
d155 1
a155 1
	bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
d157 1
a157 1
	bcopy(&args, &mp->mnt_stat.mount_info.mfs_args, sizeof(args));
d224 2
a225 2
		bcopy(&mp->mnt_stat.mount_info.mfs_args,
		    &sbp->mount_info.mfs_args, sizeof(struct mfs_args));
@


1.45
log
@Switch mfs to bufq. This simplifies the code, gives us queue limits for
free and uses FIFO queueing (rather than the current LIFO queueing).

Tested by sthen@@

ok beck@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.44 2012/12/29 14:54:11 beck Exp $	*/
d97 1
a97 1
	error = copyin(data, (caddr_t)&args, sizeof(struct mfs_args));
d155 2
@


1.44
log
@Keep mfs from potentially consuming the entire buffer cache if it gets
behind.
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.43 2012/09/10 11:11:00 jsing Exp $	*/
d135 1
a135 1
	mfsp = malloc(sizeof *mfsp, M_MFSNODE, M_WAITOK);
d141 1
a141 2
	mfsp->mfs_numbufs = 0;
	mfsp->mfs_buflist = (struct buf *)0;
d143 1
a143 1
		mfsp->mfs_buflist = (struct buf *)-1;
d177 1
a177 1
	int sleepreturn = 0, s;
d181 4
a184 4
			s = splbio();
			bp = mfsp->mfs_buflist;
			if (bp == NULL || bp == (struct buf *)-1) {
				splx(s);
a185 4
			}
			mfsp->mfs_buflist = bp->b_actf;
			mfsp->mfs_numbufs--;
			splx(s);
d187 1
a187 2
			wakeup((caddr_t)bp);
			wakeup(&mfsp->mfs_numbufs);
d189 1
a189 1
		if (bp == (struct buf *)-1)
d191 1
@


1.43
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.41 2010/09/10 16:34:09 thib Exp $	*/
d141 1
d189 1
d193 1
@


1.42
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d94 1
a94 1
	size_t size;
d97 1
a97 1
	error = copyin(data, (caddr_t)&args, sizeof (struct mfs_args));
d119 1
a119 1
		if (args.fspec == 0)
d125 3
d149 3
a151 2
	(void) copyinstr(path, fs->fs_fsmnt, sizeof(fs->fs_fsmnt) - 1, &size);
	bzero(fs->fs_fsmnt + size, sizeof(fs->fs_fsmnt) - size);
d153 2
a154 3
	(void) copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d156 1
@


1.41
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.40 2010/09/06 23:44:10 thib Exp $	*/
a59 2
extern int (**mfs_vnodeop_p)(void *);

d125 1
a125 1
	error = getnewvnode(VT_MFS, (struct mount *)0, mfs_vnodeop_p, &devvp);
@


1.40
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.39 2007/12/16 21:21:25 otto Exp $	*/
d60 2
d127 1
a127 1
	error = getnewvnode(VT_MFS, NULL, &mfs_vops, &devvp);
@


1.39
log
@fix remaining cases of potential concurrent mfs_buflist access;
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.38 2007/12/06 21:49:37 otto Exp $	*/
a59 2
extern int (**mfs_vnodeop_p)(void *);

d125 1
a125 1
	error = getnewvnode(VT_MFS, (struct mount *)0, mfs_vnodeop_p, &devvp);
@


1.38
log
@solve the biggest problem with concurrent buflist access; makes mfs on
SMP machines reliable. few corner cases remain, which will be
dealt with later; ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.37 2007/12/04 19:32:13 otto Exp $	*/
d177 1
a177 1
	while (mfsp->mfs_buflist != (struct buf *)-1) {
d181 1
a181 1
			if (bp == NULL) {
d190 2
@


1.37
log
@fix out of partition/memory bounds access when accessing blocks at the tail
end; avoids bad address errors; original diff by me with cleanup by
millert@@; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.36 2007/11/28 19:31:31 millert Exp $	*/
d175 1
a175 1
	int sleepreturn = 0;
d178 7
a184 1
		while ((bp = mfsp->mfs_buflist) != NULL) {
d186 1
@


1.36
log
@g/c mfs_mountroot() and mfs_initminiroot().  We don't support root on
mfs.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.35 2007/11/24 12:57:18 mpf Exp $	*/
a174 1
	caddr_t base;
a176 1
	base = mfsp->mfs_baseoff;
d180 1
a180 1
			mfs_doio(bp, base);
@


1.35
log
@Try a forced unmount if mount_mfs is killed with SIGKILL.
OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.34 2006/06/25 15:01:54 sturm Exp $	*/
a57 3
caddr_t	mfs_rootbase;	/* address of mini-root in kernel virtual memory */
u_long	mfs_rootsize;	/* size of mini-root in bytes */

a79 71

/*
 * Called by main() when mfs is going to be mounted as root.
 */

int
mfs_mountroot(void)
{
	struct fs *fs;
	struct mount *mp;
	struct proc *p = curproc;
	struct ufsmount *ump;
	struct mfsnode *mfsp;
	int error;

	if ((error = bdevvp(swapdev, &swapdev_vp)) ||
	    (error = bdevvp(rootdev, &rootvp))) {
		printf("mfs_mountroot: can't setup bdevvp's");
		return (error);
	}
	if ((error = vfs_rootmountalloc("mfs", "mfs_root", &mp)) != 0)
		return (error);
	mfsp = malloc(sizeof *mfsp, M_MFSNODE, M_WAITOK);
	rootvp->v_data = mfsp;
	rootvp->v_op = mfs_vnodeop_p;
	rootvp->v_tag = VT_MFS;
	mfsp->mfs_baseoff = mfs_rootbase;
	mfsp->mfs_size = mfs_rootsize;
	mfsp->mfs_vnode = rootvp;
	mfsp->mfs_pid = p->p_pid;
	mfsp->mfs_buflist = (struct buf *)0;
	if ((error = ffs_mountfs(rootvp, mp, p)) != 0) {
		mp->mnt_vfc->vfc_refcount--;
		vfs_unbusy(mp);
		free(mp, M_MOUNT);
		free(mfsp, M_MFSNODE);
		return (error);
	}

	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	ump = VFSTOUFS(mp);
	fs = ump->um_fs;
	(void) copystr(mp->mnt_stat.f_mntonname, fs->fs_fsmnt, MNAMELEN - 1, 0);
	(void)ffs_statfs(mp, &mp->mnt_stat, p);
	vfs_unbusy(mp);
	inittodr((time_t)0);

	return (0);
}

/*
 * This is called early in boot to set the base address and size
 * of the mini-root.
 */
int
mfs_initminiroot(caddr_t base)
{
	struct fs *fs = (struct fs *)(base + SBOFF);
	extern int (*mountroot)(void);

	/* check for valid super block */
	if (fs->fs_magic != FS_MAGIC || fs->fs_bsize > MAXBSIZE ||
	    fs->fs_bsize < sizeof(struct fs))
		return (0);
	mountroot = mfs_mountroot;
	mfs_rootbase = base;
	mfs_rootsize = fs->fs_fsize * fs->fs_size;
	rootdev = makedev(255, mfs_minor);
	mfs_minor++;
	return (mfs_rootsize);
}
@


1.34
log
@rename vfs_busy() flags VB_UMIGNORE/VB_UMWAIT to VB_NOWAIT/VB_WAIT

requested by and ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.33 2006/06/14 20:01:50 sturm Exp $	*/
d267 2
a268 1
			    dounmount(mp, 0, p, NULL))
@


1.33
log
@move vfs_busy() to rwlocks and properly hide the locking api from vfs

ok tedu, pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.32 2006/04/30 14:20:08 sturm Exp $	*/
d266 1
a266 1
			if (vfs_busy(mp, VB_WRITE|VB_UMIGNORE) ||
@


1.32
log
@remove the simplelock argument from vfs_busy() which is currently not
used and will never be used this way in VFS

requested by and ok pedro, ok krw, biorn
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.31 2006/04/19 11:55:55 pedro Exp $	*/
d266 1
a266 1
			if (vfs_busy(mp, LK_EXCLUSIVE|LK_NOWAIT) ||
@


1.31
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.30 2006/03/28 13:18:17 pedro Exp $	*/
d266 1
a266 1
			if (vfs_busy(mp, LK_EXCLUSIVE|LK_NOWAIT, NULL) ||
@


1.30
log
@ANSIfy and deregister, no binary change.
From: Thordur I. Bjornsson <thib@@mi.is>
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.29 2005/11/30 10:35:08 pedro Exp $	*/
d121 1
a121 1
	simple_lock(&mountlist_slock);
a122 1
	simple_unlock(&mountlist_slock);
d129 1
@


1.29
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.28 2005/07/03 20:14:02 drahn Exp $	*/
d89 1
a89 1
mfs_mountroot()
d91 1
a91 1
	register struct fs *fs;
d93 1
a93 1
	struct proc *p = curproc;	/* XXX */
d138 1
a138 2
mfs_initminiroot(base)
	caddr_t base;
d162 2
a163 6
mfs_mount(mp, path, data, ndp, p)
	register struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
d168 2
a169 2
	register struct fs *fs;
	register struct mfsnode *mfsp;
d244 1
a244 4
mfs_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
d281 1
a281 4
mfs_statfs(mp, sbp, p)
	struct mount *mp;
	struct statfs *sbp;
	struct proc *p;
d298 2
a299 5
mfs_checkexp(mp, nam, exflagsp, credanonp)
	register struct mount *mp;
	struct mbuf *nam;
	int *exflagsp;
	struct ucred **credanonp;
d308 1
a308 2
mfs_init(vfsp)
	struct vfsconf *vfsp;
@


1.28
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.27 2004/06/04 08:06:05 tedu Exp $	*/
d116 1
a116 1
		vfs_unbusy(mp, p);
d128 1
a128 1
	vfs_unbusy(mp, p);
d274 1
a274 1
			if (vfs_busy(mp, LK_EXCLUSIVE|LK_NOWAIT, NULL, p) ||
@


1.27
log
@rootvp is already externed in systm.h, no need for a local extern
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.26 2003/08/14 07:46:40 mickey Exp $	*/
a46 1
#include <ufs/ufs/extattr.h>
d81 1
a81 2
	mfs_checkexp,
	vfs_stdextattrctl
@


1.26
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.25 2003/06/02 23:28:23 millert Exp $	*/
a92 1
	extern struct vnode *rootvp;
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.24 2003/05/11 03:30:25 tedu Exp $	*/
d69 1
a69 1
struct vfsops mfs_vfsops = {
@


1.24
log
@revert part of previous.  if mfs gets a signal, it doesn't attempt to
force the unmount, so there's no need to mess with resetting
processes' working dirs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.23 2003/05/06 20:52:14 tedu Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@attempt to put a process's cwd back in place after a forced umount.
won't always work, but it's the best we can do for now.  this covers
at least some of the failure cases the previous commit to vfs_lookup.c
checks for.
ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.22 2002/07/12 14:02:23 art Exp $	*/
a261 1
	struct vnode *rvp;
a280 4
			if (ufs_root(mp, &rvp))
				rvp = NULL;
			else
				vput(rvp);
d282 1
a282 1
			    dounmount(mp, 0, p, rvp))
@


1.22
log
@Change the locking on the mountpoint slightly. Instead of using mnt_lock
to get shared locks for lookup and get the exclusive lock only with
LK_DRAIN on unmount and do the real exclusive locking with flags in
mnt_flags, we now use shared locks for lookup and an exclusive lock for
unmount.

This is accomplished by slightly changing the semantics of vfs_busy.
Old vfs_busy behavior:
 - with LK_NOWAIT set in flags, a shared lock was obtained if the
   mountpoint wasn't being unmounted, otherwise we just returned an error.
 - with no flags, a shared lock was obtained if the mountpoint was being
   unmounted, otherwise we slept until the unmount was done and returned
   an error.
LK_NOWAIT was used for sync(2) and some statistics code where it isn't really
critical that we get the correct results.
0 was used in fchdir and lookup where it's critical that we get the right
directory vnode for the filesystem root.

After this change vfs_busy keeps the same behavior for no flags and LK_NOWAIT.
But if some other flags are passed into it, they are passed directly
into lockmgr (actually LK_SLEEPFAIL is always added to those flags because
if we sleep for the lock, that means someone was holding the exclusive lock
and the exclusive lock is only held when the filesystem is being unmounted.

More changes:
 dounmount must now be called with the exclusive lock held. (before this
 the caller was supposed to hold the vfs_busy lock, but that wasn't always
 true).
 Zap some (now) unused mount flags.
And the highlight of this change:
 Add some vfs_busy calls to match some vfs_unbusy calls, especially in
 sys_mount. (lockmgr doesn't detect the case where we release a lock noone
 holds (it will do that soon)).

If you've seen hangs on reboot with mfs this should solve it (I repeat this
for the fourth time now, but this time I spent two months fixing and
redesigning this and reading the code so this time I must have gotten
this right).
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.21 2002/06/21 00:40:08 art Exp $	*/
d262 1
d282 4
d287 1
a287 1
			    dounmount(mp, 0, p))
@


1.21
log
@Remove pointless macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.20 2002/04/23 18:54:12 espie Exp $	*/
d261 4
a264 4
	register struct vnode *vp = VFSTOUFS(mp)->um_devvp;
	register struct mfsnode *mfsp = VTOMFS(vp);
	register struct buf *bp;
	register caddr_t base;
d281 1
a281 1
			if (vfs_busy(mp, LK_NOWAIT, NULL, p) ||
@


1.20
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.19 2002/03/14 01:27:15 millert Exp $	*/
d269 4
a272 5
#define	DOIO() \
		while ((bp = mfsp->mfs_buflist) != NULL) {	\
			mfsp->mfs_buflist = bp->b_actf;		\
			mfs_doio(bp, base);			\
			wakeup((caddr_t)bp);			\
a273 1
		DOIO();
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.18 2002/02/22 20:37:46 drahn Exp $	*/
d208 2
a209 1
			return (vfs_export(mp, &ump->um_export, &args.export));
@


1.18
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.17 2002/02/18 09:23:26 ericj Exp $	*/
d68 1
a68 1
extern int (**mfs_vnodeop_p) __P((void *));
d149 1
a149 1
	extern int (*mountroot) __P((void));
@


1.17
log
@
fix possible panic on reboot for mfs mounted fs.
fix from NetBSD
pr#1693
art@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.16 2002/01/23 01:40:59 art Exp $	*/
d51 1
d86 2
a87 1
	mfs_checkexp
@


1.16
log
@minor cleanup I just happened to do when in this area.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.15 2001/07/05 08:24:33 espie Exp $	*/
d262 1
d279 1
a279 1
		if (tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0)) {
d283 2
d286 1
@


1.15
log
@makedev is a macro. Admittedly, it's not function-like at all,
and should probably be spelled MAKEDEV to not trip people.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.14 2001/04/12 17:16:52 csapuntz Exp $	*/
d217 1
a217 1
	mfsp = (struct mfsnode *)malloc(sizeof *mfsp, M_MFSNODE, M_WAITOK);
@


1.15.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.16 2002/01/23 01:40:59 art Exp $	*/
d217 1
a217 1
	mfsp = malloc(sizeof *mfsp, M_MFSNODE, M_WAITOK);
@


1.15.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.15.4.1 2002/01/31 22:55:50 niklas Exp $	*/
a50 1
#include <ufs/ufs/extattr.h>
d67 1
a67 1
extern int (**mfs_vnodeop_p)(void *);
d85 1
a85 2
	mfs_checkexp,
	vfs_stdextattrctl
d147 1
a147 1
	extern int (*mountroot)(void);
d206 1
a206 2
			return (vfs_export(mp, &ump->um_export, 
			    &args.export_info));
a261 1
	int sleepreturn = 0;
d278 1
a278 1
		if (sleepreturn != 0) {
a281 2
			sleepreturn = 0;
			continue;
a282 1
		sleepreturn = tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0);
@


1.15.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.15.4.2 2002/06/11 03:32:50 art Exp $	*/
d261 4
a264 4
	struct vnode *vp = VFSTOUFS(mp)->um_devvp;
	struct mfsnode *mfsp = VTOMFS(vp);
	struct buf *bp;
	caddr_t base;
d269 5
a273 4
		while ((bp = mfsp->mfs_buflist) != NULL) {
			mfsp->mfs_buflist = bp->b_actf;
			mfs_doio(bp, base);
			wakeup((caddr_t)bp);
d275 1
d283 1
a283 1
			if (vfs_busy(mp, LK_EXCLUSIVE|LK_NOWAIT, NULL, p) ||
@


1.15.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d282 1
a282 1
			    dounmount(mp, 0, p, NULL))
@


1.14
log
@

Allow kernels with just MFS and no FFS. Fixes PR#323.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.13 2001/02/20 01:50:12 assar Exp $	*/
d156 2
a157 1
	rootdev = makedev(255, mfs_minor++);
d214 1
a214 1
	if (checkalias(devvp, makedev(255, mfs_minor++), (struct mount *)0))
d216 1
@


1.13
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.12 2000/02/07 04:57:18 assar Exp $	*/
d316 10
@


1.12
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.11 1999/12/06 07:28:06 art Exp $	*/
d170 1
a170 1
	caddr_t data;
@


1.12.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.14 2001/04/12 17:16:52 csapuntz Exp $	*/
d170 1
a170 1
	void *data;
a315 10
}

/*
 * Memory based filesystem initialization.
 */
int
mfs_init(vfsp)
	struct vfsconf *vfsp;
{
	return (ffs_init(vfsp));
@


1.12.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.12.2.1 2001/05/14 22:47:42 niklas Exp $	*/
d156 1
a156 2
	rootdev = makedev(255, mfs_minor);
	mfs_minor++;
d213 1
a213 1
	if (checkalias(devvp, makedev(255, mfs_minor), (struct mount *)0))
a214 1
	mfs_minor++;
@


1.12.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a50 1
#include <ufs/ufs/extattr.h>
d85 1
a85 2
	mfs_checkexp,
	vfs_stdextattrctl
d217 1
a217 1
	mfsp = malloc(sizeof *mfsp, M_MFSNODE, M_WAITOK);
a261 1
	int sleepreturn = 0;
d278 1
a278 1
		if (sleepreturn != 0) {
a281 2
			sleepreturn = 0;
			continue;
a282 1
		sleepreturn = tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0);
@


1.12.2.4
log
@Merge in -current from roughly a week ago
@
text
@d68 1
a68 1
extern int (**mfs_vnodeop_p)(void *);
d149 1
a149 1
	extern int (*mountroot)(void);
@


1.12.2.5
log
@Sync the SMP branch with 3.3
@
text
@d208 1
a208 2
			return (vfs_export(mp, &ump->um_export, 
			    &args.export_info));
d260 4
a263 4
	struct vnode *vp = VFSTOUFS(mp)->um_devvp;
	struct mfsnode *mfsp = VTOMFS(vp);
	struct buf *bp;
	caddr_t base;
d268 5
a272 4
		while ((bp = mfsp->mfs_buflist) != NULL) {
			mfsp->mfs_buflist = bp->b_actf;
			mfs_doio(bp, base);
			wakeup((caddr_t)bp);
d274 1
d282 1
a282 1
			if (vfs_busy(mp, LK_EXCLUSIVE|LK_NOWAIT, NULL, p) ||
@


1.12.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.12.2.5 2003/03/28 00:08:47 niklas Exp $	*/
d282 1
a282 1
			    dounmount(mp, 0, p, NULL))
@


1.12.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.12.2.6 2003/05/13 19:36:57 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a69 1
const struct vfsops mfs_vfsops = {
@


1.12.2.9
log
@Merge with the trunk
@
text
@d93 1
@


1.11
log
@Yet another solution to the mfs unmount/kill race (not ugly this time).
Require that the mount point is vfs_busy on entry to dounmount.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.10 1999/10/15 15:16:13 art Exp $	*/
d84 2
a85 1
	ffs_sysctl
d302 14
@


1.10
log
@Yet another unmount/kill race. (I hate this)
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.9 1999/09/03 18:18:16 art Exp $	*/
a68 3
int	mfs_dounmount __P((struct mount *));
void	mfs_dounmount1 __P((void *));

d276 3
a278 2
			mfs_dounmount(mp);
			CLRSIG(p, CURSIG(p));
a300 31
}

/*
 * Spawn off a kernel thread to do the unmounting to avoid all deadlocks.
 * XXX - this is horrible, but it was the only sane thing to do.
 */
int
mfs_dounmount(mp)
	struct mount *mp;
{
	if (kthread_create(mfs_dounmount1, (void *)mp, NULL, "mfs_unmount"))
		return 1;

	return 0;
}

void
mfs_dounmount1(v)
	void *v;
{
	struct mount *mp = v;

	/*
	 * Don't try to do the unmount if someone else is trying to do that.
	 * XXX - should be done with vfs_busy, but the problem is that
	 *       we can't pass a locked mp into dounmount.
	 */
	if (!(mp->mnt_flag & MNT_UNMOUNT))
		dounmount(mp, 0, curproc);

	kthread_exit(0);
@


1.9
log
@Horrible workaround for hanging mount_mfs processes that received a signal.
After finding the third deadlock during dounmount, I decided that it would
be less painful to let the unmounting be handled with a separate thread.
XXX - this is a kludge.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.8 1999/05/31 17:34:55 millert Exp $	*/
d325 7
a331 1
	dounmount(mp, 0, curproc);
@


1.8
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.7 1999/03/09 00:17:05 art Exp $	*/
d49 1
d69 3
d279 2
a280 10
			/*
			 * Don't attempt to unmount when MNT_UNMOUNT is set,
			 * that means that someone is waiting for us to
			 * finish our operations and it also means that
			 * we will sleep until he is finished. deadlock.
			 * XXX - there is a multiprocessor race here.
			 */
			if ((mp->mnt_flag & MNT_UNMOUNT) ||
			    dounmount(mp, 0, p) != 0)
				CLRSIG(p, CURSIG(p));
d303 25
@


1.7
log
@workaround deadlocks in the unmount/kill mount_mfs race.
XXX - This is wrong. I have to rethink this/rewrite mfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.6 1998/02/08 22:41:52 tholo Exp $	*/
d233 1
a301 5
#ifdef COMPAT_09
	sbp->f_type = mp->mnt_vfc->vfc_typenum;
#else
	sbp->f_type = 0;
#endif
d303 3
@


1.6
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.5 1997/11/06 05:59:23 csapuntz Exp $	*/
d273 12
a284 3
		if (tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0) &&
		    dounmount(mp, 0, p) != 0)
			CLRSIG(p, CURSIG(p));
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.4 1997/10/06 20:21:41 deraadt Exp $	*/
d167 1
a167 1
	char *path;
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vfsops.c,v 1.2 1996/02/27 07:15:47 niklas Exp $	*/
a71 1
	MOUNT_MFS,
d83 1
a87 2
 *
 * Name is updated by mount(8) after booting.
a88 1
#define ROOTNAME	"mfs_root"
d95 1
a95 1
	register struct mount *mp;
a98 1
	size_t size;
d101 7
a107 10
	/*
	 * Get vnodes for swapdev and rootdev.
	 */
	if (bdevvp(swapdev, &swapdev_vp) || bdevvp(rootdev, &rootvp))
		panic("mfs_mountroot: can't setup bdevvp's");

	mp = malloc((u_long)sizeof(struct mount), M_MOUNT, M_WAITOK);
	bzero((char *)mp, (u_long)sizeof(struct mount));
	mp->mnt_op = &mfs_vfsops;
	mp->mnt_flag = MNT_RDONLY;
d118 2
d124 1
a124 6
	if ((error = vfs_lock(mp)) != 0) {
		(void)ffs_unmount(mp, 0, p);
		free(mp, M_MOUNT);
		free(mfsp, M_MFSNODE);
		return (error);
	}
d126 1
a126 1
	mp->mnt_vnodecovered = NULLVP;
d129 1
a129 6
	bzero(fs->fs_fsmnt, sizeof(fs->fs_fsmnt));
	fs->fs_fsmnt[0] = '/';
	bcopy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
	(void) copystr(ROOTNAME, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d131 1
a131 1
	vfs_unlock(mp);
a194 2
			if (vfs_busy(mp))
				return (EBUSY);
a195 1
			vfs_unbusy(mp);
a256 1
	int error = 0;
d273 3
a275 5
		if ((error = tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0)) != 0) {
			DOIO();
			if (dounmount(mp, 0, p) != 0)
				CLRSIG(p, CURSIG(p));
		}
d277 1
a277 1
	return (error);
d293 1
a293 1
	sbp->f_type = 3;
d297 1
a297 1
	strncpy(&sbp->f_fstypename[0], mp->mnt_op->vfs_name, MFSNAMELEN);
@


1.3
log
@VFS Lite2 Changes
@
text
@d72 1
a83 1
	ffs_sysctl
d88 2
d91 1
d98 1
a98 1
	struct mount *mp;
d102 1
d105 10
a114 7
	if ((error = bdevvp(swapdev, &swapdev_vp)) ||
	    (error = bdevvp(rootdev, &rootvp))) {
		printf("mfs_mountroot: can't setup bdevvp's");
		return (error);
	}
	if ((error = vfs_rootmountalloc("mfs", "mfs_root", &mp)) != 0)
		return (error);
a124 2
		mp->mnt_vfc->vfc_refcount--;
		vfs_unbusy(mp, p);
d129 6
a134 1
	simple_lock(&mountlist_slock);
d136 1
a136 1
	simple_unlock(&mountlist_slock);
d139 6
a144 1
	(void) copystr(mp->mnt_stat.f_mntonname, fs->fs_fsmnt, MNAMELEN - 1, 0);
d146 1
a146 1
	vfs_unbusy(mp, p);
d210 2
d213 1
d275 1
d292 5
a296 3
		if (tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0) &&
		    dounmount(mp, 0, p) != 0)
			CLRSIG(p, CURSIG(p));
d298 1
a298 1
	return (0);
d314 1
a314 1
	sbp->f_type = mp->mnt_vfc->vfc_typenum;
d318 1
a318 1
	strncpy(&sbp->f_fstypename[0], mp->mnt_vfc->vfc_name, MFSNAMELEN);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a71 1
	MOUNT_MFS,
d83 1
a87 2
 *
 * Name is updated by mount(8) after booting.
a88 1
#define ROOTNAME	"mfs_root"
d95 1
a95 1
	register struct mount *mp;
a98 1
	size_t size;
d101 7
a107 10
	/*
	 * Get vnodes for swapdev and rootdev.
	 */
	if (bdevvp(swapdev, &swapdev_vp) || bdevvp(rootdev, &rootvp))
		panic("mfs_mountroot: can't setup bdevvp's");

	mp = malloc((u_long)sizeof(struct mount), M_MOUNT, M_WAITOK);
	bzero((char *)mp, (u_long)sizeof(struct mount));
	mp->mnt_op = &mfs_vfsops;
	mp->mnt_flag = MNT_RDONLY;
d118 2
d124 1
a124 6
	if ((error = vfs_lock(mp)) != 0) {
		(void)ffs_unmount(mp, 0, p);
		free(mp, M_MOUNT);
		free(mfsp, M_MFSNODE);
		return (error);
	}
d126 1
a126 1
	mp->mnt_vnodecovered = NULLVP;
d129 1
a129 6
	bzero(fs->fs_fsmnt, sizeof(fs->fs_fsmnt));
	fs->fs_fsmnt[0] = '/';
	bcopy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
	(void) copystr(ROOTNAME, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d131 1
a131 1
	vfs_unlock(mp);
a194 2
			if (vfs_busy(mp))
				return (EBUSY);
a195 1
			vfs_unbusy(mp);
a256 1
	int error = 0;
d273 3
a275 5
		if ((error = tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0)) != 0) {
			DOIO();
			if (dounmount(mp, 0, p) != 0)
				CLRSIG(p, CURSIG(p));
		}
d277 1
a277 1
	return (error);
d293 1
a293 1
	sbp->f_type = 3;
d297 1
a297 1
	strncpy(&sbp->f_fstypename[0], mp->mnt_op->vfs_name, MFSNAMELEN);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: mfs_vfsops.c,v 1.9 1995/09/01 19:39:18 mycroft Exp $	*/
d66 1
a66 1
extern int (**mfs_vnodeop_p)();
d93 1
d124 1
a124 1
	if (error = ffs_mountfs(rootvp, mp, p)) {
d129 1
a129 1
	if (error = vfs_lock(mp)) {
d155 1
d160 1
a160 1
	extern int (*mountroot)();
d195 2
a196 1
	if (error = copyin(data, (caddr_t)&args, sizeof (struct mfs_args)))
d238 1
a238 1
	if (error = ffs_mountfs(devvp, mp, p)) {
d280 4
a283 4
		while (bp = mfsp->mfs_buflist) {	\
			mfsp->mfs_buflist = bp->b_actf;	\
			mfs_doio(bp, base);		\
			wakeup((caddr_t)bp);		\
d292 1
a292 1
		if (error = tsleep((caddr_t)vp, mfs_pri, "mfsidl", 0)) {
d304 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
