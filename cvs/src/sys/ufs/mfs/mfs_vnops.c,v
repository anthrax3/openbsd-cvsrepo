head	1.49;
access;
symbols
	OPENBSD_6_2:1.49.0.6
	OPENBSD_6_2_BASE:1.49
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.47.0.2
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.8
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.4
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.42.0.6
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.6
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.22
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.6
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.48;
commitid	W7ztnDZwvjCaeQTS;

1.48
date	2016.09.08.16.44.46;	author tedu;	state Exp;
branches;
next	1.47;
commitid	bunjYKq8UY9BzXoO;

1.47
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.46;
commitid	gAjwyca5TfuoJAhn;

1.46
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.45;
commitid	p4LJxGKbi0BU2cG6;

1.45
date	2014.07.12.18.44.01;	author tedu;	state Exp;
branches;
next	1.44;
commitid	bDGgAR6yEQVcVl5u;

1.44
date	2013.01.15.11.20.55;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2012.12.29.14.54.11;	author beck;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.30.15.29.15;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.03.14.41.29;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2008.04.24.17.39.45;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.16.21.21.25;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2007.12.06.21.49.37;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.04.19.32.13;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.28.19.31.31;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.07.15.20.39;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.28.13.18.17;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.06.16.30.53;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.13.14.16.42;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.15;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.23.01.40.59;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.04.22.44.32;	author art;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.06.23.02.07.56;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.12.17.16.52;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.08.16.39.03;	author niklas;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	99.08.30.18.05.52;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.03.17.18.34.15;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.01.22.21.15.21;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.01.12.04.24.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.11.05.12.39;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.10.21.12.08;	author art;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.59.24;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.21.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.27.13;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.32.49;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.19.16.10.41;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.15.48;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.34;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2001.05.14.22.47.42;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2001.07.04.11.00.54;	author niklas;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.14.2.6;

1.14.2.6
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.14.2.7;

1.14.2.7
date	2004.02.19.11.01.42;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.50;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.05.20.04.18.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@/*	$OpenBSD: mfs_vnops.c,v 1.48 2016/09/08 16:44:46 tedu Exp $	*/
/*	$NetBSD: mfs_vnops.c,v 1.8 1996/03/17 02:16:32 christos Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mfs_vnops.c	8.5 (Berkeley) 7/28/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/specdev.h>

#include <ufs/mfs/mfsnode.h>
#include <ufs/mfs/mfs_extern.h>

/* mfs vnode operations. */
struct vops mfs_vops = {
        .vop_lookup     = mfs_badop,
        .vop_create     = mfs_badop,
        .vop_mknod      = mfs_badop,
        .vop_open       = mfs_open,
        .vop_close      = mfs_close,
        .vop_access     = mfs_badop,
        .vop_getattr    = mfs_badop,
        .vop_setattr    = mfs_badop,
        .vop_read       = mfs_badop,
        .vop_write      = mfs_badop,
        .vop_ioctl      = mfs_ioctl,
        .vop_poll       = mfs_badop,
        .vop_revoke     = mfs_revoke,
        .vop_fsync      = spec_fsync,
        .vop_remove     = mfs_badop,
        .vop_link       = mfs_badop,
        .vop_rename     = mfs_badop,
        .vop_mkdir      = mfs_badop,
        .vop_rmdir      = mfs_badop,
        .vop_symlink    = mfs_badop,
        .vop_readdir    = mfs_badop,
        .vop_readlink   = mfs_badop,
        .vop_abortop    = mfs_badop,
        .vop_inactive   = mfs_inactive,
        .vop_reclaim    = mfs_reclaim,
        .vop_lock       = vop_generic_lock,
        .vop_unlock     = vop_generic_unlock,
        .vop_bmap       = vop_generic_bmap,
        .vop_strategy   = mfs_strategy,
        .vop_print      = mfs_print,
        .vop_islocked   = vop_generic_islocked,
        .vop_pathconf   = mfs_badop,
        .vop_advlock    = mfs_badop,
        .vop_bwrite     = vop_generic_bwrite
};

/*
 * Vnode Operations.
 *
 * Open called to allow memory filesystem to initialize and
 * validate before actual IO. Record our process identifier
 * so we can tell when we are doing I/O to ourself.
 */
int
mfs_open(void *v)
{
#ifdef DIAGNOSTIC
	struct vop_open_args *ap = v;

	if (ap->a_vp->v_type != VBLK) {
		panic("mfs_open not VBLK");
	}
#endif
	return (0);
}

/*
 * Ioctl operation.
 */
int
mfs_ioctl(void *v)
{

	return (ENOTTY);
}

/*
 * Pass I/O requests to the memory filesystem process.
 */
int
mfs_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	struct buf *bp = ap->a_bp;
	struct mfsnode *mfsp;
	struct vnode *vp;
	struct proc *p = curproc;

	if (!vfinddev(bp->b_dev, VBLK, &vp) || vp->v_usecount == 0)
		panic("mfs_strategy: bad dev");

	mfsp = VTOMFS(vp);
	if (p != NULL && mfsp->mfs_tid == p->p_tid) {
		mfs_doio(mfsp, bp);
	} else {
		bufq_queue(&mfsp->mfs_bufq, bp);
		wakeup(vp);
	}
	return (0);
}

/*
 * Memory file system I/O.
 */
void
mfs_doio(struct mfsnode *mfsp, struct buf *bp)
{
	caddr_t base;
	long offset = bp->b_blkno << DEV_BSHIFT;
	int s;

	if (bp->b_bcount > mfsp->mfs_size - offset)
		bp->b_bcount = mfsp->mfs_size - offset;

	base = mfsp->mfs_baseoff + offset;
	if (bp->b_flags & B_READ)
		bp->b_error = copyin(base, bp->b_data, bp->b_bcount);
	else
		bp->b_error = copyout(bp->b_data, base, bp->b_bcount);
	if (bp->b_error)
		bp->b_flags |= B_ERROR;
	else
		bp->b_resid = 0;
	s = splbio();
	biodone(bp);
	splx(s);
}

/*
 * Memory filesystem close routine
 */
int
mfs_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct mfsnode *mfsp = VTOMFS(vp);
	struct buf *bp;
	int error;

	/*
	 * Finish any pending I/O requests.
	 */
	while (1) {
		bp = bufq_dequeue(&mfsp->mfs_bufq);
		if (bp == NULL)
			break;
		mfs_doio(mfsp, bp);
		wakeup(bp);
	}

	/*
	 * On last close of a memory filesystem we must invalidate any in
	 * core blocks, so that we can free up its vnode.
	 */
	if ((error = vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p, 0, 0)) != 0)
		return (error);

#ifdef DIAGNOSTIC
	/*
	 * There should be no way to have any more buffers on this vnode.
	 */
	if (bufq_peek(&mfsp->mfs_bufq))
		printf("mfs_close: dirty buffers\n");
#endif

	/*
	 * Send a request to the filesystem server to exit.
	 */
	mfsp->mfs_shutdown = 1;
	wakeup(vp);
	return (0);
}

/*
 * Memory filesystem inactive routine
 */
int
mfs_inactive(void *v)
{
	struct vop_inactive_args *ap = v;
#ifdef DIAGNOSTIC
	struct mfsnode *mfsp = VTOMFS(ap->a_vp);

	if (mfsp->mfs_shutdown && bufq_peek(&mfsp->mfs_bufq))
		panic("mfs_inactive: not inactive");
#endif
	VOP_UNLOCK(ap->a_vp, ap->a_p);
	return (0);
}

/*
 * Reclaim a memory filesystem devvp so that it can be reused.
 */
int
mfs_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;

	free(vp->v_data, M_MFSNODE, 0);
	vp->v_data = NULL;
	return (0);
}

/*
 * Print out the contents of an mfsnode.
 */
int
mfs_print(void *v)
{
	struct vop_print_args *ap = v;
	struct mfsnode *mfsp = VTOMFS(ap->a_vp);

	printf("tag VT_MFS, tid %d, base %p, size %ld\n", mfsp->mfs_tid,
	    mfsp->mfs_baseoff, mfsp->mfs_size);
	return (0);
}

/*
 * Block device bad operation
 */
int
mfs_badop(void *v)
{
	panic("mfs_badop called");
}
@


1.48
log
@delete useless comments, such as how KVA is mapped on HP
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.47 2016/03/19 12:04:16 natano Exp $	*/
d133 1
a133 1
	if (p != NULL && mfsp->mfs_pid == p->p_pid) {
d255 1
a255 1
	printf("tag VT_MFS, pid %d, base %p, size %ld\n", mfsp->mfs_pid,
@


1.47
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.46 2015/03/14 03:38:52 jsg Exp $	*/
a93 1
/* ARGSUSED */
a101 1
		/* NOTREACHED */
a109 1
/* ARGSUSED */
a112 3
#if 0
	struct vop_ioctl_args *ap = v;
#endif
a143 2
 *
 * Trivial on the HP since buffer has already been mapped into KVA space.
a171 1
/* ARGSUSED */
a217 1
/* ARGSUSED */
a266 1
	/* NOTREACHED */
@


1.46
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.45 2014/07/12 18:44:01 tedu Exp $	*/
d238 1
a238 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
@


1.45
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.44 2013/01/15 11:20:55 jsing Exp $	*/
a44 2

#include <machine/vmparam.h>
@


1.44
log
@Switch mfs to bufq. This simplifies the code, gives us queue limits for
free and uses FIFO queueing (rather than the current LIFO queueing).

Tested by sthen@@

ok beck@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.43 2012/12/29 14:54:11 beck Exp $	*/
d253 1
a253 1
	free(vp->v_data, M_MFSNODE);
@


1.43
log
@Keep mfs from potentially consuming the entire buffer cache if it gets
behind.
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.42 2011/07/04 20:35:35 deraadt Exp $	*/
a135 6
	int bufmax;
	int s;

	/* Constrain queue to a sensible value. */
	bufmax = MIN(256, bcstats.kvaslots / 16);
	bufmax = MIN(bufmax, bcstats.numbufs / 16);
d144 2
a145 8
		s = splbio();
		while (mfsp->mfs_numbufs > bufmax)
			tsleep(&mfsp->mfs_numbufs, PRIBIO + 1, "mfsbufs", 0);
		bp->b_actf = mfsp->mfs_buflist;
		mfsp->mfs_buflist = bp;
		mfsp->mfs_numbufs++;
		splx(s);
		wakeup((caddr_t)vp);
d190 1
a190 1
	int error, s;
d196 2
a197 4
		s = splbio();
		bp = mfsp->mfs_buflist;
		if (bp == NULL) {
			splx(s);
a198 3
		}
		mfsp->mfs_buflist = bp->b_actf;
		splx(s);
d200 1
a200 1
		wakeup((caddr_t)bp);
d202 1
d204 2
a205 3
	 * On last close of a memory filesystem
	 * we must invalidate any in core blocks, so that
	 * we can free up its vnode.
d209 1
d214 1
a214 1
	if (mfsp->mfs_buflist)
d217 1
d221 2
a222 2
	mfsp->mfs_buflist = (struct buf *)(-1);
	wakeup((caddr_t)vp);
d237 2
a238 3
	if (mfsp->mfs_buflist && mfsp->mfs_buflist != (struct buf *)(-1))
		panic("mfs_inactive: not inactive (mfs_buflist %p)",
			mfsp->mfs_buflist);
@


1.42
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.41 2011/04/05 14:14:07 thib Exp $	*/
d43 1
d136 1
d139 4
d151 2
d155 1
@


1.41
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.40 2010/12/21 20:14:44 thib Exp $	*/
d43 1
a43 2

#include <miscfs/specfs/specdev.h>
@


1.40
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.39 2010/09/10 16:34:09 thib Exp $	*/
a52 1
        .vop_default    = eopnotsupp,
@


1.39
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.38 2010/09/06 23:44:10 thib Exp $	*/
d51 37
a87 41
/*
 * mfs vnode operations.
 */
int (**mfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc mfs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, mfs_badop },
	{ &vop_create_desc, mfs_badop },
	{ &vop_mknod_desc, mfs_badop },
	{ &vop_open_desc, mfs_open },
	{ &vop_close_desc, mfs_close },
	{ &vop_access_desc, mfs_badop },
	{ &vop_getattr_desc, mfs_badop },
	{ &vop_setattr_desc, mfs_badop },
	{ &vop_read_desc, mfs_badop },
	{ &vop_write_desc, mfs_badop },
	{ &vop_ioctl_desc, mfs_ioctl },
	{ &vop_poll_desc, mfs_badop },
	{ &vop_revoke_desc, mfs_revoke },
	{ &vop_fsync_desc, spec_fsync },
	{ &vop_remove_desc, mfs_badop },
	{ &vop_link_desc, mfs_badop },
	{ &vop_rename_desc, mfs_badop },
	{ &vop_mkdir_desc, mfs_badop },
	{ &vop_rmdir_desc, mfs_badop },
	{ &vop_symlink_desc, mfs_badop },
	{ &vop_readdir_desc, mfs_badop },
	{ &vop_readlink_desc, mfs_badop },
	{ &vop_abortop_desc, mfs_badop },
	{ &vop_inactive_desc, mfs_inactive },
	{ &vop_reclaim_desc, mfs_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, vop_generic_bmap },
	{ &vop_strategy_desc, mfs_strategy },
	{ &vop_print_desc, mfs_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, mfs_badop },
	{ &vop_advlock_desc, mfs_badop },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a88 2
struct vnodeopv_desc mfs_vnodeop_opv_desc =
	{ &mfs_vnodeop_p, mfs_vnodeop_entries };
@


1.38
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.37 2009/08/13 15:00:14 jasper Exp $	*/
d51 41
a91 37
/* mfs vnode operations. */
struct vops mfs_vops = {
        .vop_default    = eopnotsupp,
        .vop_lookup     = mfs_badop,
        .vop_create     = mfs_badop,
        .vop_mknod      = mfs_badop,
        .vop_open       = mfs_open,
        .vop_close      = mfs_close,
        .vop_access     = mfs_badop,
        .vop_getattr    = mfs_badop,
        .vop_setattr    = mfs_badop,
        .vop_read       = mfs_badop,
        .vop_write      = mfs_badop,
        .vop_ioctl      = mfs_ioctl,
        .vop_poll       = mfs_badop,
        .vop_revoke     = mfs_revoke,
        .vop_fsync      = spec_fsync,
        .vop_remove     = mfs_badop,
        .vop_link       = mfs_badop,
        .vop_rename     = mfs_badop,
        .vop_mkdir      = mfs_badop,
        .vop_rmdir      = mfs_badop,
        .vop_symlink    = mfs_badop,
        .vop_readdir    = mfs_badop,
        .vop_readlink   = mfs_badop,
        .vop_abortop    = mfs_badop,
        .vop_inactive   = mfs_inactive,
        .vop_reclaim    = mfs_reclaim,
        .vop_lock       = vop_generic_lock,
        .vop_unlock     = vop_generic_unlock,
        .vop_bmap       = vop_generic_bmap,
        .vop_strategy   = mfs_strategy,
        .vop_print      = mfs_print,
        .vop_islocked   = vop_generic_islocked,
        .vop_pathconf   = mfs_badop,
        .vop_advlock    = mfs_badop,
        .vop_bwrite     = vop_generic_bwrite
d93 2
@


1.37
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.36 2008/09/30 15:29:15 millert Exp $	*/
d51 37
a87 41
/*
 * mfs vnode operations.
 */
int (**mfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc mfs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, mfs_badop },
	{ &vop_create_desc, mfs_badop },
	{ &vop_mknod_desc, mfs_badop },
	{ &vop_open_desc, mfs_open },
	{ &vop_close_desc, mfs_close },
	{ &vop_access_desc, mfs_badop },
	{ &vop_getattr_desc, mfs_badop },
	{ &vop_setattr_desc, mfs_badop },
	{ &vop_read_desc, mfs_badop },
	{ &vop_write_desc, mfs_badop },
	{ &vop_ioctl_desc, mfs_ioctl },
	{ &vop_poll_desc, mfs_badop },
	{ &vop_revoke_desc, mfs_revoke },
	{ &vop_fsync_desc, spec_fsync },
	{ &vop_remove_desc, mfs_badop },
	{ &vop_link_desc, mfs_badop },
	{ &vop_rename_desc, mfs_badop },
	{ &vop_mkdir_desc, mfs_badop },
	{ &vop_rmdir_desc, mfs_badop },
	{ &vop_symlink_desc, mfs_badop },
	{ &vop_readdir_desc, mfs_badop },
	{ &vop_readlink_desc, mfs_badop },
	{ &vop_abortop_desc, mfs_badop },
	{ &vop_inactive_desc, mfs_inactive },
	{ &vop_reclaim_desc, mfs_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, vop_generic_bmap },
	{ &vop_strategy_desc, mfs_strategy },
	{ &vop_print_desc, mfs_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, mfs_badop },
	{ &vop_advlock_desc, mfs_badop },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a88 2
struct vnodeopv_desc mfs_vnodeop_opv_desc =
	{ &mfs_vnodeop_p, mfs_vnodeop_entries };
@


1.36
log
@Fix an occasional mfs-related panic on reboot in mfs_close.  There's no
need to check v_usecount, the buffer queue check is sufficient.
From mickey.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.35 2008/05/08 17:45:45 thib Exp $	*/
d57 34
a90 34
	{ &vop_lookup_desc, mfs_badop },		/* lookup */
	{ &vop_create_desc, mfs_badop },		/* create */
	{ &vop_mknod_desc, mfs_badop },			/* mknod */
	{ &vop_open_desc, mfs_open },			/* open */
	{ &vop_close_desc, mfs_close },			/* close */
	{ &vop_access_desc, mfs_badop },		/* access */
	{ &vop_getattr_desc, mfs_badop },		/* getattr */
	{ &vop_setattr_desc, mfs_badop },		/* setattr */
	{ &vop_read_desc, mfs_badop },			/* read */
	{ &vop_write_desc, mfs_badop },			/* write */
	{ &vop_ioctl_desc, mfs_ioctl },			/* ioctl */
	{ &vop_poll_desc, mfs_badop },			/* poll */
	{ &vop_revoke_desc, mfs_revoke },               /* revoke */
	{ &vop_fsync_desc, spec_fsync },		/* fsync */
	{ &vop_remove_desc, mfs_badop },		/* remove */
	{ &vop_link_desc, mfs_badop },			/* link */
	{ &vop_rename_desc, mfs_badop },		/* rename */
	{ &vop_mkdir_desc, mfs_badop },			/* mkdir */
	{ &vop_rmdir_desc, mfs_badop },			/* rmdir */
	{ &vop_symlink_desc, mfs_badop },		/* symlink */
	{ &vop_readdir_desc, mfs_badop },		/* readdir */
	{ &vop_readlink_desc, mfs_badop },		/* readlink */
	{ &vop_abortop_desc, mfs_badop },		/* abortop */
	{ &vop_inactive_desc, mfs_inactive },		/* inactive */
	{ &vop_reclaim_desc, mfs_reclaim },		/* reclaim */
	{ &vop_lock_desc, vop_generic_lock },		/* lock */
	{ &vop_unlock_desc, vop_generic_unlock },	/* unlock */
	{ &vop_bmap_desc, vop_generic_bmap },		/* bmap */
	{ &vop_strategy_desc, mfs_strategy },		/* strategy */
	{ &vop_print_desc, mfs_print },			/* print */
	{ &vop_islocked_desc, vop_generic_islocked },	/* islocked */
	{ &vop_pathconf_desc, mfs_badop },		/* pathconf */
	{ &vop_advlock_desc, mfs_badop },		/* advlock */
	{ &vop_bwrite_desc, vop_generic_bwrite },	/* bwrite */
@


1.35
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.34 2008/05/03 14:41:29 thib Exp $	*/
d227 1
a227 2
	 * There should be no way to have any more uses of this
	 * vnode, so if we find any other uses, it is a panic.
a228 2
	if (vp->v_usecount > 1)
		printf("mfs_close: ref count %d > 1\n", vp->v_usecount);
a230 2
	if (vp->v_usecount > 1 || mfsp->mfs_buflist)
		panic("mfs_close");
@


1.34
log
@Introduce vop_generic_bmap(); use it where applicable.
one thing of note, fifofs changes in that its bmap now
sets the runp too 0, but that was an oversight in the
old code.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.33 2008/04/24 17:39:45 thib Exp $	*/
d56 1
a56 1
	{ &vop_default_desc, vn_default_error },
@


1.33
log
@remove useless defines for the vnode operations, and instead
init the op array functions with whatever the define was set
too.

ok dlg@@,blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.32 2007/12/16 21:21:25 otto Exp $	*/
d84 1
a84 1
	{ &vop_bmap_desc, mfs_bmap },			/* bmap */
a187 18
}

/*
 * This is a noop, simply returning what one has been given.
 */
int
mfs_bmap(void *v)
{
	struct vop_bmap_args *ap = v;

	if (ap->a_vpp != NULL)
		*ap->a_vpp = ap->a_vp;
	if (ap->a_bnp != NULL)
		*ap->a_bnp = ap->a_bn;
	if (ap->a_runp != NULL)
		*ap->a_runp = 0;

	return (0);
@


1.32
log
@fix remaining cases of potential concurrent mfs_buflist access;
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.31 2007/12/06 21:49:37 otto Exp $	*/
d57 3
a59 3
	{ &vop_lookup_desc, mfs_lookup },		/* lookup */
	{ &vop_create_desc, mfs_create },		/* create */
	{ &vop_mknod_desc, mfs_mknod },			/* mknod */
d62 5
a66 5
	{ &vop_access_desc, mfs_access },		/* access */
	{ &vop_getattr_desc, mfs_getattr },		/* getattr */
	{ &vop_setattr_desc, mfs_setattr },		/* setattr */
	{ &vop_read_desc, mfs_read },			/* read */
	{ &vop_write_desc, mfs_write },			/* write */
d68 1
a68 1
	{ &vop_poll_desc, mfs_poll },			/* poll */
d71 9
a79 9
	{ &vop_remove_desc, mfs_remove },		/* remove */
	{ &vop_link_desc, mfs_link },			/* link */
	{ &vop_rename_desc, mfs_rename },		/* rename */
	{ &vop_mkdir_desc, mfs_mkdir },			/* mkdir */
	{ &vop_rmdir_desc, mfs_rmdir },			/* rmdir */
	{ &vop_symlink_desc, mfs_symlink },		/* symlink */
	{ &vop_readdir_desc, mfs_readdir },		/* readdir */
	{ &vop_readlink_desc, mfs_readlink },		/* readlink */
	{ &vop_abortop_desc, mfs_abortop },		/* abortop */
d82 2
a83 2
	{ &vop_lock_desc, mfs_lock },			/* lock */
	{ &vop_unlock_desc, mfs_unlock },		/* unlock */
d87 5
a91 5
	{ &vop_islocked_desc, mfs_islocked },		/* islocked */
	{ &vop_pathconf_desc, mfs_pathconf },		/* pathconf */
	{ &vop_advlock_desc, mfs_advlock },		/* advlock */
	{ &vop_bwrite_desc, mfs_bwrite },		/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.31
log
@solve the biggest problem with concurrent buflist access; makes mfs on
SMP machines reliable. few corner cases remain, which will be
dealt with later; ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.30 2007/12/04 19:32:13 otto Exp $	*/
d219 1
a219 1
	int error;
d224 7
a230 1
	while ((bp = mfsp->mfs_buflist) != NULL) {
d232 1
@


1.30
log
@fix out of partition/memory bounds access when accessing blocks at the tail
end; avoids bad address errors; original diff by me with cleanup by
millert@@; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.29 2007/11/28 19:31:31 millert Exp $	*/
d143 1
d152 1
d155 1
@


1.29
log
@g/c mfs_mountroot() and mfs_initminiroot().  We don't support root on
mfs.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.28 2007/06/01 23:47:57 deraadt Exp $	*/
d149 1
a149 1
		mfs_doio(bp, mfsp->mfs_baseoff);
d164 1
a164 1
mfs_doio(struct buf *bp, caddr_t base)
d166 2
d170 4
a173 1
	base += (bp->b_blkno << DEV_BSHIFT);
d223 1
a223 1
		mfs_doio(bp, mfsp->mfs_baseoff);
@


1.28
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.27 2007/02/07 15:20:39 jmc Exp $	*/
a142 1
	int s;
d148 1
a148 13
	/* check for mini-root access */
	if (mfsp->mfs_pid == 0) {
		caddr_t base;

		base = mfsp->mfs_baseoff + (bp->b_blkno << DEV_BSHIFT);
		if (bp->b_flags & B_READ)
			bcopy(base, bp->b_data, bp->b_bcount);
		else
			bcopy(bp->b_data, base, bp->b_bcount);
		s = splbio();
		biodone(bp);
		splx(s);
	} else if (p !=  NULL && mfsp->mfs_pid == p->p_pid) {
@


1.27
log
@grammar fix; from bret lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.26 2006/03/28 13:18:17 pedro Exp $	*/
d108 1
a108 6
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d126 1
a126 8
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d138 1
a138 3
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
d201 1
a201 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
d220 1
a220 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d268 1
a268 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
d286 1
a286 3
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d300 1
a300 3
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
@


1.26
log
@ANSIfy and deregister, no binary change.
From: Thordur I. Bjornsson <thib@@mi.is>
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.25 2005/03/06 16:30:53 pedro Exp $	*/
d262 1
a262 1
	 * we can, free up its vnode.
@


1.25
log
@Use V_SAVE instead of hardcoding it, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.24 2003/09/23 16:51:13 millert Exp $	*/
d105 1
a105 2
mfs_open(v)
	void *v;
d128 1
a128 2
mfs_ioctl(v)
	void *v;
d148 1
a148 2
mfs_strategy(v)
	void *v;
d156 1
a156 1
	struct proc *p = curproc;		/* XXX */
d188 1
a188 1
 * Trivial on the HP since buffer has already been mapping into KVA space.
d191 1
a191 3
mfs_doio(bp, base)
	struct buf *bp;
	caddr_t base;
d213 1
a213 2
mfs_bmap(v)
	void *v;
d238 1
a238 2
mfs_close(v)
	void *v;
d246 3
a248 3
	register struct vnode *vp = ap->a_vp;
	register struct mfsnode *mfsp = VTOMFS(vp);
	register struct buf *bp;
d291 1
a291 2
mfs_inactive(v)
	void *v;
d298 1
a298 1
	register struct mfsnode *mfsp = VTOMFS(ap->a_vp);
d312 1
a312 2
mfs_reclaim(v)
	void *v;
d328 1
a328 2
mfs_print(v)
	void *v;
d333 1
a333 1
	register struct mfsnode *mfsp = VTOMFS(ap->a_vp);
d344 1
a344 2
mfs_badop(v)
	void *v;
a345 1

@


1.24
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.23 2003/06/02 23:28:23 millert Exp $	*/
d271 1
a271 1
	if ((error = vinvalbuf(vp, 1, ap->a_cred, ap->a_p, 0, 0)) != 0)
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.22 2002/05/13 14:16:42 art Exp $	*/
d68 1
a68 1
	{ &vop_select_desc, mfs_select },		/* select */
@


1.22
log
@Protect calls to biodone with splbio.
I'm not completly sure it's needed, but better safe than sorry. And this
simplifies some spl assertions in the still not comitted splassert code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.21 2002/03/14 01:27:15 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.20 2002/01/23 01:40:59 art Exp $	*/
d160 2
a161 2
	register struct buf *bp = ap->a_bp;
	register struct mfsnode *mfsp;
d164 1
d179 1
d181 1
d199 1
a199 1
	register struct buf *bp;
d202 1
d213 1
d215 1
@


1.20
log
@minor cleanup I just happened to do when in this area.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.19 2002/01/16 20:50:17 miod Exp $	*/
d58 1
a58 1
int (**mfs_vnodeop_p) __P((void *));
d95 1
a95 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.19
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.18 2001/12/19 08:58:07 art Exp $	*/
d324 1
a324 1
	register struct vnode *vp = ap->a_vp;
d326 1
a326 1
	FREE(vp->v_data, M_MFSNODE);
@


1.18
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.16 2001/06/23 02:07:56 csapuntz Exp $	*/
a44 1
#include <sys/map.h>
@


1.17
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d96 1
a96 2
	{ &vop_mmap_desc, mfs_mmap },
	{ NULL, NULL }
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.20 2002/01/23 01:40:59 art Exp $	*/
d45 1
d326 1
a326 1
	struct vnode *vp = ap->a_vp;
d328 1
a328 1
	free(vp->v_data, M_MFSNODE);
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.17.2.1 2002/01/31 22:55:50 niklas Exp $	*/
d58 1
a58 1
int (**mfs_vnodeop_p)(void *);
d161 2
a162 2
	struct buf *bp = ap->a_bp;
	struct mfsnode *mfsp;
a164 1
	int s;
a178 1
		s = splbio();
a179 1
		splx(s);
d197 1
a197 1
	struct buf *bp;
a199 1
	int s;
a209 1
	s = splbio();
a210 1
	splx(s);
@


1.17.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.17.2.2 2002/06/11 03:32:50 art Exp $	*/
a95 1
	{ &vop_putpages_desc, mfs_putpages },
@


1.17.2.4
log
@use vnode lock in place of inode lock, switch to genfs_lock
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 1
#include <miscfs/genfs/genfs.h>
@


1.16
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.15 2001/04/12 17:16:52 csapuntz Exp $	*/
d96 2
a97 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.15
log
@

Allow kernels with just MFS and no FFS. Fixes PR#323.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.14 2000/02/08 16:39:03 niklas Exp $	*/
a74 1
	{ &vop_mmap_desc, mfs_mmap },			/* mmap */
a75 1
	{ &vop_seek_desc, mfs_seek },			/* seek */
a94 5
	{ &vop_blkatoff_desc, mfs_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, mfs_valloc },		/* valloc */
	{ &vop_vfree_desc, mfs_vfree },			/* vfree */
	{ &vop_truncate_desc, mfs_truncate },		/* truncate */
	{ &vop_update_desc, mfs_update },		/* update */
@


1.14
log
@prevent a panic when suspending on an idle system
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.13 1999/08/30 18:05:52 art Exp $	*/
a365 10
}

/*
 * Memory based filesystem initialization.
 */
int
mfs_init(vfsp)
	struct vfsconf *vfsp;
{
	return  (0);
@


1.14.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.15 2001/04/12 17:16:52 csapuntz Exp $	*/
d366 10
@


1.14.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.14.2.1 2001/05/14 22:47:42 niklas Exp $	*/
d75 1
d77 1
d97 5
@


1.14.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
d325 1
a325 1
	struct vnode *vp = ap->a_vp;
d327 1
a327 1
	free(vp->v_data, M_MFSNODE);
@


1.14.2.4
log
@Merge in -current from roughly a week ago
@
text
@d58 1
a58 1
int (**mfs_vnodeop_p)(void *);
d95 1
a95 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.14.2.5
log
@Sync the SMP branch with 3.3
@
text
@d160 2
a161 2
	struct buf *bp = ap->a_bp;
	struct mfsnode *mfsp;
a163 1
	int s;
a177 1
		s = splbio();
a178 1
		splx(s);
d196 1
a196 1
	struct buf *bp;
a198 1
	int s;
a208 1
	s = splbio();
a209 1
	splx(s);
@


1.14.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.14.2.5 2003/03/28 00:08:47 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
	{ &vop_poll_desc, mfs_poll },			/* poll */
@


1.13
log
@Kill mfsiom.h. We are not using anything from it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.12 1999/03/17 18:34:15 art Exp $	*/
d187 1
a187 1
	} else if (mfsp->mfs_pid == p->p_pid) {
@


1.12
log
@If an mfs io is successful set b_resid to 0.
From Chuck Silvers <chs@@netbsd>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.11 1999/01/22 21:15:21 art Exp $	*/
a53 1
#include <ufs/mfs/mfsiom.h>
@


1.11
log
@I'm stupid. Fix a panic when not DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.10 1999/01/12 04:24:10 millert Exp $	*/
d216 2
@


1.10
log
@fixed unused variable warnings when  DIAGNOSTIC not defined
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.9 1999/01/11 05:12:39 millert Exp $	*/
a173 1
#ifdef DIAGNOSTIC
d176 1
a176 1
#endif
@


1.9
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.8 1999/01/10 21:12:08 art Exp $	*/
d121 1
a128 1
#ifdef DIAGNOSTIC
d311 1
a313 1
#ifdef DIAGNOSTIC
@


1.8
log
@fix panic messages and put some code in DIAGNOSTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.7 1997/11/06 05:59:24 csapuntz Exp $	*/
d364 1
a364 1
	panic("mfs_badop called\n");
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.6 1997/10/06 20:21:42 deraadt Exp $	*/
d128 1
d130 1
a130 1
		panic("mfs_ioctl not VBLK");
d133 1
d174 1
d177 1
d279 1
d286 2
d290 1
d313 1
d317 1
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.4 1996/04/21 22:32:49 deraadt Exp $	*/
d75 1
d235 3
d301 1
d308 1
d361 3
a363 2
void
mfs_init()
d365 1
a365 1

@


1.5
log
@VFS Lite2 Changes
@
text
@a74 1
	{ &vop_revoke_desc, mfs_revoke },               /* revoke */
a233 3
	if (ap->a_runp != NULL)
		*ap->a_runp = 0;

a296 1
		struct proc *a_p;
a302 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
d355 2
a356 3
int
mfs_init(vfsp)
	struct vfsconf *vfsp;
d358 1
a358 1
	return  (0);
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: mfs_vnops.c,v 1.3 1996/04/19 16:10:41 niklas Exp $	*/
d75 1
d235 3
d301 1
d308 1
d361 3
a363 2
void
mfs_init()
d365 1
a365 1

@


1.3
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: mfs_vnops.c,v 1.2 1996/02/27 07:15:48 niklas Exp $	*/
/*	$NetBSD: mfs_vnops.c,v 1.7 1996/02/21 00:06:45 cgd Exp $	*/
d301 1
a301 1
		panic("mfs_inactive: not inactive (mfs_buflist %x)",
d335 2
a336 2
	printf("tag VT_MFS, pid %d, base %p, size %d\n", mfsp->mfs_pid,
		mfsp->mfs_baseoff, mfsp->mfs_size);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mfs_vnops.c,v 1.6 1996/02/09 22:31:30 christos Exp $	*/
d335 2
a336 2
	printf("tag VT_MFS, pid %d, base %d, size %d\n", mfsp->mfs_pid,
		(unsigned int) mfsp->mfs_baseoff, mfsp->mfs_size);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: mfs_vnops.c,v 1.5 1994/12/14 13:03:52 mycroft Exp $	*/
d60 1
a60 1
int (**mfs_vnodeop_p)();
d103 1
a103 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d117 3
a119 1
mfs_open(ap)
d125 1
a125 2
	} */ *ap;
{
d139 4
a142 1
mfs_ioctl(ap)
d150 2
a151 2
	} */ *ap;
{
d160 3
a162 1
mfs_strategy(ap)
d165 1
a165 2
	} */ *ap;
{
d219 3
a221 1
mfs_bmap(ap)
d228 1
a228 2
	} */ *ap;
{
d242 3
a244 1
mfs_close(ap)
d250 1
a250 2
	} */ *ap;
{
d259 1
a259 1
	while (bp = mfsp->mfs_buflist) {
d269 1
a269 1
	if (error = vinvalbuf(vp, 1, ap->a_cred, ap->a_p, 0, 0))
d292 3
a294 1
mfs_inactive(ap)
d297 1
a297 2
	} */ *ap;
{
d310 3
a312 1
mfs_reclaim(ap)
d315 1
a315 2
	} */ *ap;
{
d327 3
a329 1
mfs_print(ap)
d332 1
a332 2
	} */ *ap;
{
d336 1
a336 1
		mfsp->mfs_baseoff, mfsp->mfs_size);
d344 2
a345 1
mfs_badop()
d355 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
