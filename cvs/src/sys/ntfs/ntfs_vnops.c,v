head	1.42;
access;
symbols
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	SMP:1.4.0.2;
locks; strict;
comment	@ * @;


1.42
date	2016.09.01.08.40.39;	author natano;	state Exp;
branches;
next	1.41;
commitid	NvsKsQuRDuQNpuOz;

1.41
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.40;
commitid	gAjwyca5TfuoJAhn;

1.40
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.39;
commitid	p4LJxGKbi0BU2cG6;

1.39
date	2015.02.10.21.58.16;	author miod;	state Exp;
branches;
next	1.38;
commitid	8W7jyIoa34bQUU1a;

1.38
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.37;
commitid	C5iGb36LQxjM60Q3;

1.37
date	2014.12.16.19.56.33;	author tedu;	state Exp;
branches;
next	1.36;
commitid	QDtD6hT4TizWpQLS;

1.36
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.35;
commitid	FE3DG5cICjyI4jWx;

1.35
date	2013.12.14.02.57.25;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2013.12.12.06.51.08;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2013.12.02.16.05.07;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.24.16.02.30;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2013.08.13.05.52.26;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.28.02.08.39;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.14.09.44.57;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.13.04.07.49;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.03.16.06.01;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2012.06.20.17.30.22;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.20.09.13.07;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.18.21.18.07;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.07.00.41.05;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.12.04.05.03;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.20.22.05.44;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.13.16.00.53;	author jasper;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.02.20.48.48;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.09.21.28.53;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.01.23.52.38;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.09.12.43.16;	author pedro;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.19.16.50.47;	author pedro;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.21.19.43.20;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.21.18.05.58;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.16.16.28.42;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.08.15.45.20;	author pat;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.28.20;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.05.20.03.36.42;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.20.03.23.12;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.20.03.03.27;	author tedu;	state Exp;
branches;
next	;

1.4.2.1
date	2003.06.07.10.47.03;	author ho;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove the unused ntfs write code. ok benno beck
@
text
@/*	$OpenBSD: ntfs_vnops.c,v 1.41 2016/03/19 12:04:16 natano Exp $	*/
/*	$NetBSD: ntfs_vnops.c,v 1.6 2003/04/10 21:57:26 jdolecek Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * John Heidemann of the UCLA Ficus project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	Id: ntfs_vnops.c,v 1.5 1999/05/12 09:43:06 semenu Exp
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/dirent.h>
#include <sys/specdev.h>

/*#define NTFS_DEBUG 1*/
#include <ntfs/ntfs.h>
#include <ntfs/ntfs_inode.h>
#include <ntfs/ntfs_subr.h>

#include <sys/unistd.h> /* for pathconf(2) constants */

int	ntfs_read(void *);
int	ntfs_getattr(void *);
int	ntfs_inactive(void *);
int	ntfs_print(void *);
int	ntfs_reclaim(void *);
int	ntfs_strategy(void *);
int	ntfs_access(void *v);
int	ntfs_open(void *v);
int	ntfs_close(void *);
int	ntfs_readdir(void *);
int	ntfs_lookup(void *);
int	ntfs_bmap(void *);
int	ntfs_fsync(void *);
int	ntfs_pathconf(void *);

int	ntfs_prtactive = 0;	/* 1 => print out reclaim of active vnodes */

/*
 * This is a noop, simply returning what one has been given.
 */
int
ntfs_bmap(void *v)
{
	struct vop_bmap_args *ap = v;
	DPRINTF("ntfs_bmap: vn: %p, blk: %lld\n",
	    ap->a_vp, (long long)ap->a_bn);
	if (ap->a_vpp != NULL)
		*ap->a_vpp = ap->a_vp;
	if (ap->a_bnp != NULL)
		*ap->a_bnp = ap->a_bn;
	if (ap->a_runp != NULL)
		*ap->a_runp = 0;
	return (0);
}

int
ntfs_read(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fnode *fp = VTOF(vp);
	struct ntnode *ip = FTONT(fp);
	struct uio *uio = ap->a_uio;
	struct ntfsmount *ntmp = ip->i_mp;
	u_int64_t toread;
	int error;

	DPRINTF("ntfs_read: ino: %u, off: %lld resid: %zu, segflg: %d\n",
	    ip->i_number, uio->uio_offset, uio->uio_resid, uio->uio_segflg);

	DPRINTF("ntfs_read: filesize: %llu", fp->f_size);

	/* don't allow reading after end of file */
	if (uio->uio_offset > fp->f_size)
		toread = 0;
	else
		toread = MIN(uio->uio_resid, fp->f_size - uio->uio_offset);

	DPRINTF(", toread: %llu\n", toread);

	if (toread == 0)
		return (0);

	error = ntfs_readattr(ntmp, ip, fp->f_attrtype,
		fp->f_attrname, uio->uio_offset, toread, NULL, uio);
	if (error) {
		printf("ntfs_read: ntfs_readattr failed: %d\n",error);
		return (error);
	}

	return (0);
}

int
ntfs_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fnode *fp = VTOF(vp);
	struct ntnode *ip = FTONT(fp);
	struct vattr *vap = ap->a_vap;

	DPRINTF("ntfs_getattr: %u, flags: %u\n", ip->i_number, ip->i_flag);

	vap->va_fsid = ip->i_dev;
	vap->va_fileid = ip->i_number;
	vap->va_mode = ip->i_mp->ntm_mode;
	vap->va_nlink = ip->i_nlink;
	vap->va_uid = ip->i_mp->ntm_uid;
	vap->va_gid = ip->i_mp->ntm_gid;
	vap->va_rdev = 0;				/* XXX UNODEV ? */
	vap->va_size = fp->f_size;
	vap->va_bytes = fp->f_allocated;
	vap->va_atime = ntfs_nttimetounix(fp->f_times.t_access);
	vap->va_mtime = ntfs_nttimetounix(fp->f_times.t_write);
	vap->va_ctime = ntfs_nttimetounix(fp->f_times.t_create);
	vap->va_flags = ip->i_flag;
	vap->va_gen = 0;
	vap->va_blocksize = ip->i_mp->ntm_spc * ip->i_mp->ntm_bps;
	vap->va_type = vp->v_type;
	vap->va_filerev = 0;

	/*
	 * Ensure that a directory link count is always 1 so that things
	 * like fts_read() do not try to be smart and end up skipping over
	 * directories. Additionally, ip->i_nlink will not be initialised
	 * until the ntnode has been loaded for the file.
	 */
	if (vp->v_type == VDIR || ip->i_nlink < 1)
		vap->va_nlink = 1;

	return (0);
}


/*
 * Last reference to an ntnode.  If necessary, write or delete it.
 */
int
ntfs_inactive(void *v)
{
	struct vop_inactive_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct proc *p = ap->a_p;
#ifdef NTFS_DEBUG
	struct ntnode *ip = VTONT(vp);
#endif

	DPRINTF("ntfs_inactive: vnode: %p, ntnode: %u\n", vp, ip->i_number);

#ifdef DIAGNOSTIC
	if (ntfs_prtactive && vp->v_usecount != 0)
		vprint("ntfs_inactive: pushing active", vp);
#endif

	VOP_UNLOCK(vp, p);

	/* XXX since we don't support any filesystem changes
	 * right now, nothing more needs to be done
	 */
	return (0);
}

/*
 * Reclaim an fnode/ntnode so that it can be used for other purposes.
 */
int
ntfs_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fnode *fp = VTOF(vp);
	struct ntnode *ip = FTONT(fp);
	struct proc *p = ap->a_p;
	int error;

	DPRINTF("ntfs_reclaim: vnode: %p, ntnode: %u\n", vp, ip->i_number);

#ifdef DIAGNOSTIC
	if (ntfs_prtactive && vp->v_usecount != 0)
		vprint("ntfs_reclaim: pushing active", vp);
#endif

	if ((error = ntfs_ntget(ip, p)) != 0)
		return (error);
	
	/* Purge old data structures associated with the inode. */
	cache_purge(vp);

	ntfs_frele(fp);
	ntfs_ntput(ip, p);

	vp->v_data = NULL;

	return (0);
}

int
ntfs_print(void *v)
{
	struct vop_print_args *ap = v;
	struct ntnode *ip = VTONT(ap->a_vp);

	printf("tag VT_NTFS, ino %u, flag %#x, usecount %d, nlink %ld\n",
	    ip->i_number, ip->i_flag, ip->i_usecount, ip->i_nlink);

	return (0);
}

/*
 * Calculate the logical to physical mapping if not done already,
 * then call the device strategy routine.
 */
int
ntfs_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	struct buf *bp = ap->a_bp;
	struct vnode *vp = bp->b_vp;
	struct fnode *fp = VTOF(vp);
	struct ntnode *ip = FTONT(fp);
	struct ntfsmount *ntmp = ip->i_mp;
	int error, s;

	DPRINTF("ntfs_strategy: blkno: %lld, lblkno: %lld\n",
	    (long long)bp->b_blkno, (long long)bp->b_lblkno);

	DPRINTF("strategy: bcount: %ld flags: 0x%lx\n",
	    bp->b_bcount, bp->b_flags);

	if (bp->b_flags & B_READ) {
		u_int32_t toread;

		if (ntfs_cntob(bp->b_blkno) >= fp->f_size) {
			clrbuf(bp);
			error = 0;
		} else {
			toread = MIN(bp->b_bcount,
				 fp->f_size - ntfs_cntob(bp->b_blkno));
			DPRINTF("ntfs_strategy: toread: %u, fsize: %llu\n",
			    toread, fp->f_size);

			error = ntfs_readattr(ntmp, ip, fp->f_attrtype,
				fp->f_attrname, ntfs_cntob(bp->b_blkno),
				toread, bp->b_data, NULL);

			if (error) {
				printf("ntfs_strategy: ntfs_readattr failed\n");
				bp->b_error = error;
				bp->b_flags |= B_ERROR;
			}

			bzero(bp->b_data + toread, bp->b_bcount - toread);
		}
	} else {
		bp->b_error = error = EROFS;
		bp->b_flags |= B_ERROR;
	}
	s = splbio();
	biodone(bp);
	splx(s);
	return (error);
}

int
ntfs_access(void *v)
{
	struct vop_access_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct ntnode *ip = VTONT(vp);
	struct ucred *cred = ap->a_cred;
	mode_t mask, mode = ap->a_mode;
	gid_t *gp;
	int i;

	DPRINTF("ntfs_access: %u\n", ip->i_number);

	/*
	 * Disallow write attempts unless the file is a socket, fifo, or
	 * a block or character device resident on the file system.
	 */
	if (mode & VWRITE) {
		switch ((int)vp->v_type) {
		case VDIR:
		case VLNK:
		case VREG:
			return (EROFS);
		}
	}

	/* Otherwise, user id 0 always gets access. */
	if (cred->cr_uid == 0)
		return (0);

	mask = 0;

	/* Otherwise, check the owner. */
	if (cred->cr_uid == ip->i_mp->ntm_uid) {
		if (mode & VEXEC)
			mask |= S_IXUSR;
		if (mode & VREAD)
			mask |= S_IRUSR;
		if (mode & VWRITE)
			mask |= S_IWUSR;
		return ((ip->i_mp->ntm_mode & mask) == mask ? 0 : EACCES);
	}

	/* Otherwise, check the groups. */
	for (i = 0, gp = cred->cr_groups; i < cred->cr_ngroups; i++, gp++)
		if (ip->i_mp->ntm_gid == *gp) {
			if (mode & VEXEC)
				mask |= S_IXGRP;
			if (mode & VREAD)
				mask |= S_IRGRP;
			if (mode & VWRITE)
				mask |= S_IWGRP;
			return ((ip->i_mp->ntm_mode&mask) == mask ? 0 : EACCES);
		}

	/* Otherwise, check everyone else. */
	if (mode & VEXEC)
		mask |= S_IXOTH;
	if (mode & VREAD)
		mask |= S_IROTH;
	if (mode & VWRITE)
		mask |= S_IWOTH;
	return ((ip->i_mp->ntm_mode & mask) == mask ? 0 : EACCES);
}

/*
 * Open called.
 *
 * Nothing to do.
 */
int
ntfs_open(void *v)
{
#if NTFS_DEBUG
	struct vop_open_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct ntnode *ip = VTONT(vp);

	printf("ntfs_open: %d\n",ip->i_number);
#endif

	/*
	 * Files marked append-only must be opened for appending.
	 */

	return (0);
}

/*
 * Close called.
 *
 * Update the times on the inode.
 */
int
ntfs_close(void *v)
{
#if NTFS_DEBUG
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct ntnode *ip = VTONT(vp);

	printf("ntfs_close: %d\n",ip->i_number);
#endif

	return (0);
}

int
ntfs_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fnode *fp = VTOF(vp);
	struct ntnode *ip = FTONT(fp);
	struct uio *uio = ap->a_uio;
	struct ntfsmount *ntmp = ip->i_mp;
	int i, error = 0;
	u_int32_t faked = 0, num;
	struct dirent cde;
	off_t off;

	DPRINTF("ntfs_readdir %u off: %lld resid: %zu\n", ip->i_number,
	    uio->uio_offset, uio->uio_resid);

	off = uio->uio_offset;
	memset(&cde, 0, sizeof(cde));

	/* Simulate . in every dir except ROOT */
	if (ip->i_number != NTFS_ROOTINO && uio->uio_offset == 0) {
		cde.d_fileno = ip->i_number;
		cde.d_reclen = sizeof(struct dirent);
		cde.d_type = DT_DIR;
		cde.d_namlen = 1;
		cde.d_off = sizeof(struct dirent);
		cde.d_name[0] = '.';
		cde.d_name[1] = '\0';
		error = uiomove(&cde, sizeof(struct dirent), uio);
		if (error)
			goto out;
	}

	/* Simulate .. in every dir including ROOT */
	if (uio->uio_offset < 2 * sizeof(struct dirent)) {
		cde.d_fileno = NTFS_ROOTINO;	/* XXX */
		cde.d_reclen = sizeof(struct dirent);
		cde.d_type = DT_DIR;
		cde.d_namlen = 2;
		cde.d_off = 2 * sizeof(struct dirent);
		cde.d_name[0] = '.';
		cde.d_name[1] = '.';
		cde.d_name[2] = '\0';
		error = uiomove(&cde, sizeof(struct dirent), uio);
		if (error)
			goto out;
	}

	faked = (ip->i_number == NTFS_ROOTINO) ? 1 : 2;
	num = uio->uio_offset / sizeof(struct dirent) - faked;

	while (uio->uio_resid >= sizeof(struct dirent)) {
		struct attr_indexentry *iep;
		char *fname;
		size_t remains;
		int sz;

		error = ntfs_ntreaddir(ntmp, fp, num, &iep, uio->uio_procp);
		if (error)
			goto out;

		if (NULL == iep)
			break;

		for(; !(iep->ie_flag & NTFS_IEFLAG_LAST) && (uio->uio_resid >= sizeof(struct dirent));
			iep = NTFS_NEXTREC(iep, struct attr_indexentry *))
		{
			if(!ntfs_isnamepermitted(ntmp,iep))
				continue;

			remains = sizeof(cde.d_name) - 1;
			fname = cde.d_name;
			for(i=0; i<iep->ie_fnamelen; i++) {
				sz = (*ntmp->ntm_wput)(fname, remains,
						iep->ie_fname[i]);
				fname += sz;
				remains -= sz;
			}
			*fname = '\0';
			DPRINTF("ntfs_readdir: elem: %u, fname:[%s] type: %u, "
			    "flag: %u, ",
			    num, cde.d_name, iep->ie_fnametype, iep->ie_flag);
			cde.d_namlen = fname - (char *) cde.d_name;
			cde.d_fileno = iep->ie_number;
			cde.d_type = (iep->ie_fflag & NTFS_FFLAG_DIR) ? DT_DIR : DT_REG;
			cde.d_reclen = sizeof(struct dirent);
			cde.d_off = uio->uio_offset + sizeof(struct dirent);
			DPRINTF("%s\n", cde.d_type == DT_DIR ? "dir" : "reg");

			error = uiomove(&cde, sizeof(struct dirent), uio);
			if (error)
				goto out;
			num++;
		}
	}

	DPRINTF("ntfs_readdir: %u entries (%lld bytes) read\n",
	    num, uio->uio_offset - off);
	DPRINTF("ntfs_readdir: off: %lld resid: %zu\n",
	    uio->uio_offset, uio->uio_resid);

/*
	if (ap->a_eofflag)
	    *ap->a_eofflag = VTONT(ap->a_vp)->i_size <= uio->uio_offset;
*/
out:
	if (fp->f_dirblbuf != NULL) {
		free(fp->f_dirblbuf, M_NTFSDIR, 0);
		fp->f_dirblbuf = NULL;
	}
	return (error);
}

int
ntfs_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct ntnode *dip = VTONT(dvp);
	struct ntfsmount *ntmp = dip->i_mp;
	struct componentname *cnp = ap->a_cnp;
	struct ucred *cred = cnp->cn_cred;
	int error;
	int lockparent = cnp->cn_flags & LOCKPARENT;
	struct proc *p = cnp->cn_proc;
#if NTFS_DEBUG
	int wantparent = cnp->cn_flags & (LOCKPARENT|WANTPARENT);
#endif
	DPRINTF("ntfs_lookup: \"%.*s\" (%ld bytes) in %u, lp: %d, wp: %d \n",
	    (unsigned int)cnp->cn_namelen, cnp->cn_nameptr, cnp->cn_namelen,
	    dip->i_number, lockparent, wantparent);

	error = VOP_ACCESS(dvp, VEXEC, cred, cnp->cn_proc);
	if(error)
		return (error);

	if ((cnp->cn_flags & ISLASTCN) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

	/*
	 * We now have a segment name to search for, and a directory
	 * to search.
	 *
	 * Before tediously performing a linear scan of the directory,
	 * check the name cache to see if the directory/name pair
	 * we are looking for is known already.
	 */
	if ((error = cache_lookup(ap->a_dvp, ap->a_vpp, cnp)) >= 0)
		return (error);

	if(cnp->cn_namelen == 1 && cnp->cn_nameptr[0] == '.') {
		DPRINTF("ntfs_lookup: faking . directory in %u\n",
		    dip->i_number);

		vref(dvp);
		*ap->a_vpp = dvp;
		error = 0;
	} else if (cnp->cn_flags & ISDOTDOT) {
		struct ntvattr *vap;

		DPRINTF("ntfs_lookup: faking .. directory in %u\n",
		    dip->i_number);

		VOP_UNLOCK(dvp, p);
		cnp->cn_flags |= PDIRUNLOCK;

		error = ntfs_ntvattrget(ntmp, dip, NTFS_A_NAME, NULL, 0, &vap);
		if(error)
			return (error);

		DPRINTF("ntfs_lookup: parentdir: %u\n",
		    vap->va_a_name->n_pnumber);
		error = VFS_VGET(ntmp->ntm_mountp,
				 vap->va_a_name->n_pnumber,ap->a_vpp); 
		ntfs_ntvattrrele(vap);
		if (error) {
			if (vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}

		if (lockparent && (cnp->cn_flags & ISLASTCN)) {
			error = vn_lock(dvp, LK_EXCLUSIVE, p);
			if (error) {
				vput( *(ap->a_vpp) );
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}
	} else {
		error = ntfs_ntlookupfile(ntmp, dvp, cnp, ap->a_vpp, p);
		if (error) {
			DPRINTF("ntfs_ntlookupfile: returned %d\n", error);
			return (error);
		}

		DPRINTF("ntfs_lookup: found ino: %u\n",
		    VTONT(*ap->a_vpp)->i_number);

		if(!lockparent || (cnp->cn_flags & ISLASTCN) == 0) {
			VOP_UNLOCK(dvp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
	}

	if (cnp->cn_flags & MAKEENTRY)
		cache_enter(dvp, *ap->a_vpp, cnp);

	return (error);
}

/*
 * Flush the blocks of a file to disk.
 *
 * This function is worthless for vnodes that represent directories. Maybe we
 * could just do a sync if they try an fsync on a directory file.
 */
int
ntfs_fsync(void *v)
{
	return (0);
}

/*
 * Return POSIX pathconf information applicable to NTFS filesystem
 */
int
ntfs_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = 1;
		break;
	case _PC_NAME_MAX:
		*ap->a_retval = NTFS_MAXFILENAME;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	case _PC_NO_TRUNC:
		*ap->a_retval = 0;
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * Global vfs data structures
 */
struct vops ntfs_vops = {
	.vop_getattr	= ntfs_getattr,
	.vop_inactive	= ntfs_inactive,
	.vop_reclaim	= ntfs_reclaim,
	.vop_print	= ntfs_print,
	.vop_pathconf	= ntfs_pathconf,
	.vop_islocked	= vop_generic_islocked,
	.vop_unlock	= vop_generic_unlock,
	.vop_lock	= vop_generic_lock,
	.vop_lookup	= ntfs_lookup,
	.vop_access	= ntfs_access,
	.vop_close	= ntfs_close,
	.vop_open	= ntfs_open,
	.vop_readdir	= ntfs_readdir,
	.vop_fsync	= ntfs_fsync,
	.vop_bmap	= ntfs_bmap,
	.vop_strategy	= ntfs_strategy,
	.vop_bwrite	= vop_generic_bwrite,
	.vop_read	= ntfs_read,
};
@


1.41
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.40 2015/03/14 03:38:52 jsg Exp $	*/
a59 1
int	ntfs_write(void *);
d294 2
a295 23
		size_t tmp;
		u_int32_t towrite;

		if (ntfs_cntob(bp->b_blkno) + bp->b_bcount >= fp->f_size) {
			printf("ntfs_strategy: CAN'T EXTEND FILE\n");
			bp->b_error = error = EFBIG;
			bp->b_flags |= B_ERROR;
		} else {
			towrite = MIN(bp->b_bcount,
				fp->f_size - ntfs_cntob(bp->b_blkno));
			DPRINTF("ntfs_strategy: towrite: %u, fsize: %llu\n",
			    towrite, fp->f_size);

			error = ntfs_writeattr_plain(ntmp, ip, fp->f_attrtype,	
				fp->f_attrname, ntfs_cntob(bp->b_blkno),towrite,
				bp->b_data, &tmp, NULL);

			if (error) {
				printf("ntfs_strategy: ntfs_writeattr fail\n");
				bp->b_error = error;
				bp->b_flags |= B_ERROR;
			}
		}
a303 36
ntfs_write(void *v)
{
	struct vop_write_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fnode *fp = VTOF(vp);
	struct ntnode *ip = FTONT(fp);
	struct uio *uio = ap->a_uio;
	struct ntfsmount *ntmp = ip->i_mp;
	u_int64_t towrite;
	size_t written;
	int error;

	DPRINTF("ntfs_write: ino: %u, off: %lld resid: %zu, segflg: %d\n",
	    ip->i_number, uio->uio_offset, uio->uio_resid, uio->uio_segflg);
	DPRINTF("ntfs_write: filesize: %llu", fp->f_size);

	if (uio->uio_resid + uio->uio_offset > fp->f_size) {
		printf("ntfs_write: CAN'T WRITE BEYOND END OF FILE\n");
		return (EFBIG);
	}

	towrite = MIN(uio->uio_resid, fp->f_size - uio->uio_offset);

	DPRINTF(", towrite: %llu\n", towrite);

	error = ntfs_writeattr_plain(ntmp, ip, fp->f_attrtype,
		fp->f_attrname, uio->uio_offset, towrite, NULL, &written, uio);
#ifdef NTFS_DEBUG
	if (error)
		printf("ntfs_write: ntfs_writeattr failed: %d\n", error);
#endif

	return (error);
}

int
d317 2
a318 3
	 * Disallow write attempts on read-only file systems;
	 * unless the file is a socket, fifo, or a block or
	 * character device resident on the file system.
d325 1
a325 3
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
			break;
a547 1
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
a686 1
	.vop_write	= ntfs_write,
@


1.40
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.39 2015/02/10 21:58:16 miod Exp $	*/
d195 1
a195 1
	VOP_UNLOCK(vp, 0, p);
d637 1
a637 1
		VOP_UNLOCK(dvp, 0, p);
d674 1
a674 1
			VOP_UNLOCK(dvp, 0, p);
@


1.39
log
@Switch uiomovei(..., sizeof whatever, ...) to uiomove().
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.38 2015/02/10 21:56:10 miod Exp $	*/
a40 1
#include <sys/kernel.h>
@


1.38
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.37 2014/12/16 19:56:33 tedu Exp $	*/
d501 1
a501 1
		error = uiomovei(&cde, sizeof(struct dirent), uio);
d516 1
a516 1
		error = uiomovei(&cde, sizeof(struct dirent), uio);
d562 1
a562 1
			error = uiomovei(&cde, sizeof(struct dirent), uio);
@


1.37
log
@must include lock.h if you want to play with locks
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.36 2014/07/12 18:43:52 tedu Exp $	*/
d501 1
a501 1
		error = uiomove(&cde, sizeof(struct dirent), uio);
d516 1
a516 1
		error = uiomove(&cde, sizeof(struct dirent), uio);
d562 1
a562 1
			error = uiomove(&cde, sizeof(struct dirent), uio);
@


1.36
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.35 2013/12/14 02:57:25 guenther Exp $	*/
d45 1
@


1.35
log
@Zero out dirent structures that will be copied out to avoid leaking garbage
in the padding or trailing name bytes.

ok beck@@ millert@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.34 2013/12/12 06:51:08 guenther Exp $	*/
d579 1
a579 1
		free(fp->f_dirblbuf, M_NTFSDIR);
@


1.34
log
@Set the d_off member as getdents() expects in ntfs_readdir()

ok and nudge jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.33 2013/12/02 16:05:07 jsing Exp $	*/
d482 1
a482 1
	struct dirent *cde;
d489 1
a489 2

	cde = malloc(sizeof(struct dirent), M_TEMP, M_WAITOK);
d493 8
a500 7
		cde->d_fileno = ip->i_number;
		cde->d_reclen = sizeof(struct dirent);
		cde->d_type = DT_DIR;
		cde->d_namlen = 1;
		cde->d_off = sizeof(struct dirent);
		strncpy(cde->d_name, ".", 2);
		error = uiomove(cde, sizeof(struct dirent), uio);
d507 9
a515 8
		cde->d_fileno = NTFS_ROOTINO;	/* XXX */
		cde->d_reclen = sizeof(struct dirent);
		cde->d_type = DT_DIR;
		cde->d_namlen = 2;
		cde->d_off = 2 * sizeof(struct dirent);
		strncpy(cde->d_name, "..", 3);

		error = uiomove(cde, sizeof(struct dirent), uio);
d542 2
a543 2
			remains = sizeof(cde->d_name) - 1;
			fname = cde->d_name;
d553 7
a559 7
			    num, cde->d_name, iep->ie_fnametype, iep->ie_flag);
			cde->d_namlen = fname - (char *) cde->d_name;
			cde->d_fileno = iep->ie_number;
			cde->d_type = (iep->ie_fflag & NTFS_FFLAG_DIR) ? DT_DIR : DT_REG;
			cde->d_reclen = sizeof(struct dirent);
			cde->d_off = uio->uio_offset + sizeof(struct dirent);
			DPRINTF("%s\n", cde->d_type == DT_DIR ? "dir" : "reg");
d561 1
a561 1
			error = uiomove((void *)cde, sizeof(struct dirent), uio);
a581 1
	free(cde, M_TEMP);
@


1.33
log
@Use appropriate format specifiers in debug messages. In particular, avoid
casting almost everything to u_int32_t, then formatting as a signed int
(which really helps when you're trying to debug based on 64-bit values).

Looked over by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.32 2013/11/24 16:02:30 jsing Exp $	*/
d557 1
@


1.32
log
@Clean up the NTFS debug code - use uppercase names for the debug macros,
especially since 'dprintf' now has another meaning (at least outside of
the kernel). Tweak the macro syntax so we can avoid having to double
bracket all invocations. Also apply a good dose of style(9).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.31 2013/08/13 05:52:26 guenther Exp $	*/
d84 2
a85 1
	DPRINTF("ntfs_bmap: vn: %p, blk: %d\n", ap->a_vp, (u_int32_t)ap->a_bn);
d107 2
a108 3
	DPRINTF("ntfs_read: ino: %d, off: %d resid: %d, segflg: %d\n",
	    ip->i_number, (u_int32_t)uio->uio_offset, uio->uio_resid,
	    uio->uio_segflg);
d110 1
a110 1
	DPRINTF("ntfs_read: filesize: %d", (u_int32_t)fp->f_size);
d116 1
a116 1
		toread = MIN(uio->uio_resid, fp->f_size - uio->uio_offset );
d118 1
a118 1
	DPRINTF(", toread: %d\n", (u_int32_t)toread);
d142 1
a142 1
	DPRINTF("ntfs_getattr: %d, flags: %d\n", ip->i_number, ip->i_flag);
d188 1
a188 1
	DPRINTF("ntfs_inactive: vnode: %p, ntnode: %d\n", vp, ip->i_number);
d216 1
a216 1
	DPRINTF("ntfs_reclaim: vnode: %p, ntnode: %d\n", vp, ip->i_number);
d264 2
a265 2
	DPRINTF("ntfs_strategy: blkno: %d, lblkno: %d\n",
	    (u_int32_t)bp->b_blkno, (u_int32_t)bp->b_lblkno);
d267 2
a268 2
	DPRINTF("strategy: bcount: %u flags: 0x%x\n",
	    (u_int32_t)bp->b_bcount, bp->b_flags);
d279 2
a280 2
			DPRINTF("ntfs_strategy: toread: %d, fsize: %d\n",
			    toread, (u_int32_t)fp->f_size);
d305 2
a306 2
			DPRINTF("ntfs_strategy: towrite: %d, fsize: %d\n",
			    towrite, (u_int32_t)fp->f_size);
d338 3
a340 4
	DPRINTF("ntfs_write: ino: %d, off: %d resid: %d, segflg: %d\n",
	    ip->i_number, (u_int32_t)uio->uio_offset, uio->uio_resid,
	    uio->uio_segflg);
	DPRINTF("ntfs_write: filesize: %d", (u_int32_t)fp->f_size);
d349 1
a349 1
	DPRINTF(", towrite: %d\n", (u_int32_t)towrite);
d372 1
a372 1
	DPRINTF("ntfs_access: %d\n", ip->i_number);
d485 1
a485 1
	DPRINTF("ntfs_readdir %d off: %lld resid: %d\n", ip->i_number,
d550 2
a551 2
			DPRINTF("ntfs_readdir: elem: %d, fname:[%s] type: %d, "
			    "flag: %d, ",
d566 4
a569 4
	DPRINTF("ntfs_readdir: %d entries (%d bytes) read\n",
	    num, (u_int)(uio->uio_offset - off));
	DPRINTF("ntfs_readdir: off: %d resid: %d\n",
	    (u_int32_t)uio->uio_offset, uio->uio_resid);
d599 2
a600 2
	DPRINTF("ntfs_lookup: \"%.*s\" (%ld bytes) in %d, lp: %d, wp: %d \n",
	    (int)cnp->cn_namelen, cnp->cn_nameptr, cnp->cn_namelen,
d624 1
a624 1
		DPRINTF("ntfs_lookup: faking . directory in %d\n",
d633 1
a633 1
		DPRINTF("ntfs_lookup: faking .. directory in %d\n",
d643 1
a643 1
		DPRINTF("ntfs_lookup: parentdir: %d\n",
d669 1
a669 1
		DPRINTF("ntfs_lookup: found ino: %d\n",
@


1.31
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.30 2013/03/28 02:08:39 guenther Exp $	*/
d84 1
a84 1
	dprintf(("ntfs_bmap: vn: %p, blk: %d\n", ap->a_vp,(u_int32_t)ap->a_bn));
d106 3
a108 1
	dprintf(("ntfs_read: ino: %d, off: %d resid: %d, segflg: %d\n",ip->i_number,(u_int32_t)uio->uio_offset,uio->uio_resid,uio->uio_segflg));
d110 1
a110 1
	dprintf(("ntfs_read: filesize: %d",(u_int32_t)fp->f_size));
d118 1
a118 1
	dprintf((", toread: %d\n",(u_int32_t)toread));
d142 1
a142 1
	dprintf(("ntfs_getattr: %d, flags: %d\n",ip->i_number,ip->i_flag));
d188 1
a188 1
	dprintf(("ntfs_inactive: vnode: %p, ntnode: %d\n", vp, ip->i_number));
d216 1
a216 1
	dprintf(("ntfs_reclaim: vnode: %p, ntnode: %d\n", vp, ip->i_number));
d264 2
a265 3
	dprintf(("ntfs_strategy: blkno: %d, lblkno: %d\n",
		(u_int32_t)bp->b_blkno,
		(u_int32_t)bp->b_lblkno));
d267 2
a268 2
	dprintf(("strategy: bcount: %u flags: 0x%x\n", 
		(u_int32_t)bp->b_bcount,bp->b_flags));
d279 2
a280 2
			dprintf(("ntfs_strategy: toread: %d, fsize: %d\n",
				toread,(u_int32_t)fp->f_size));
d305 2
a306 2
			dprintf(("ntfs_strategy: towrite: %d, fsize: %d\n",
				towrite,(u_int32_t)fp->f_size));
d338 4
a341 2
	dprintf(("ntfs_write: ino: %d, off: %d resid: %d, segflg: %d\n",ip->i_number,(u_int32_t)uio->uio_offset,uio->uio_resid,uio->uio_segflg));
	dprintf(("ntfs_write: filesize: %d",(u_int32_t)fp->f_size));
d350 1
a350 1
	dprintf((", towrite: %d\n",(u_int32_t)towrite));
d373 1
a373 1
	dprintf(("ntfs_access: %d\n",ip->i_number));
d486 2
a487 2
	dprintf(("ntfs_readdir %d off: %lld resid: %d\n", ip->i_number,
	    uio->uio_offset, uio->uio_resid));
d551 3
a553 3
			dprintf(("ntfs_readdir: elem: %d, fname:[%s] type: %d, flag: %d, ",
				num, cde->d_name, iep->ie_fnametype,
				iep->ie_flag));
d558 1
a558 1
			dprintf(("%s\n", (cde->d_type == DT_DIR) ? "dir":"reg"));
d567 4
a570 4
	dprintf(("ntfs_readdir: %d entries (%d bytes) read\n",
		ncookies,(u_int)(uio->uio_offset - off)));
	dprintf(("ntfs_readdir: off: %d resid: %d\n",
		(u_int32_t)uio->uio_offset,uio->uio_resid));
d600 3
a602 3
	dprintf(("ntfs_lookup: \"%.*s\" (%ld bytes) in %d, lp: %d, wp: %d \n",
		(int)cnp->cn_namelen, cnp->cn_nameptr, cnp->cn_namelen,
		dip->i_number, lockparent, wantparent));
d625 2
a626 2
		dprintf(("ntfs_lookup: faking . directory in %d\n",
			dip->i_number));
d634 2
a635 2
		dprintf(("ntfs_lookup: faking .. directory in %d\n",
			 dip->i_number));
d644 2
a645 2
		dprintf(("ntfs_lookup: parentdir: %d\n",
			 vap->va_a_name->n_pnumber));
d666 1
a666 1
			dprintf(("ntfs_ntlookupfile: returned %d\n", error));
d670 2
a671 2
		dprintf(("ntfs_lookup: found ino: %d\n", 
			VTONT(*ap->a_vpp)->i_number));
@


1.30
log
@Handle the pathconf _PC_PATH_MAX, _PC_PIPE_BUF, _PC_ASYNC_IO,
_PC_PRIO_IO, and _PC_SYNC_IO names in VOP_PATHCONF(), as they're
fs-independent for us.  Since we don't support latter three on any
fs, we can also define the related _POSIX_{ASYNC,PRIO,SYNC}_IO
symbols in <unistd.h> (via sys/unistd.h) with value -1.

Also, zap pointless tty-only values from procfs(!).

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.29 2013/01/14 09:44:57 jsing Exp $	*/
a479 1
	int ncookies = 0;
d483 2
a484 1
	dprintf(("ntfs_readdir %d off: %d resid: %d\n",ip->i_number,(u_int32_t)uio->uio_offset,uio->uio_resid));
d491 1
a491 2
	if (ip->i_number != NTFS_ROOTINO
	    && uio->uio_offset < sizeof(struct dirent)) {
d496 1
d498 1
a498 1
		error = uiomove((void *)cde, sizeof(struct dirent), uio);
a500 2

		ncookies++;
d509 1
d512 1
a512 1
		error = uiomove((void *) cde, sizeof(struct dirent), uio);
a514 2

		ncookies++;
a559 2

			ncookies++;
a568 22
	if (!error && ap->a_ncookies != NULL) {
		struct dirent* dpStart;
		struct dirent* dp;
		u_long *cookies;
		u_long *cookiep;

		dprintf(("ntfs_readdir: %d cookies\n",ncookies));
		if (uio->uio_segflg != UIO_SYSSPACE || uio->uio_iovcnt != 1)
			panic("ntfs_readdir: unexpected uio from NFS server");
		dpStart = (struct dirent *)
		     ((caddr_t)uio->uio_iov->iov_base -
			 (uio->uio_offset - off));
		cookies = malloc(ncookies * sizeof(*cookies), M_TEMP, M_WAITOK);
		for (dp = dpStart, cookiep = cookies, i=0;
		     i < ncookies;
		     dp = (struct dirent *)((caddr_t) dp + dp->d_reclen), i++) {
			off += dp->d_reclen;
			*cookiep++ = off;
		}
		*ap->a_ncookies = ncookies;
		*ap->a_cookies = cookies;
	}
@


1.29
log
@Free the directory block buffer at the completion of a readdir,
significantly reducing NTFS kernel memory usage. Without this the buffer
is not usually freed until the vnode is reclaimed.

Tested by Sebastian Neuper.

ok beck@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.28 2013/01/13 04:07:49 jsing Exp $	*/
a735 3
		break;
	case _PC_PATH_MAX:
		*ap->a_retval = PATH_MAX;
@


1.28
log
@Destatic.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.27 2013/01/03 16:06:01 jsing Exp $	*/
d600 5
a604 1
    out:
@


1.27
log
@Ensure that a directory link count is always 1 so that things like
fts_read() do not try to be smart and end up skipping over directories.
Additionally, ip->i_nlink will not be initialised until the ntnode has
been loaded for the file.

Makes find(1) behave predictably on a mounted NTFS file system.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.26 2012/06/20 17:30:22 matthew Exp $	*/
d59 15
a73 15
static int	ntfs_read(void *);
static int	ntfs_write(void *);
static int	ntfs_getattr(void *);
static int	ntfs_inactive(void *);
static int	ntfs_print(void *);
static int	ntfs_reclaim(void *);
static int	ntfs_strategy(void *);
static int	ntfs_access(void *);
static int	ntfs_open(void *);
static int	ntfs_close(void *);
static int	ntfs_readdir(void *);
static int	ntfs_lookup(void *);
static int	ntfs_bmap(void *);
static int	ntfs_fsync(void *);
static int	ntfs_pathconf(void *);
d94 1
a94 1
static int
d131 1
a131 1
static int
d235 1
a235 1
static int
d324 1
a324 1
static int
d432 1
a432 2
/* ARGSUSED */
static int
d455 1
a455 2
/* ARGSUSED */
static int
d711 1
a711 1
static int
d720 1
a720 1
static int
@


1.26
log
@Cleanup our filesystem pathconf() code a little bit to make it easier
to diff against FreeBSD's.

From Brad; no object file change on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.25 2011/12/20 09:13:07 mikeb Exp $	*/
d159 10
@


1.25
log
@respect the MNT_FORCE flag in ntfs_unmount and proceed even if there's
someone holding a system vnode.  prevents crashes with forced unmounts.
silence ntfs_reclaim so that kernel won't spit out vprint's angrily.

ok krw, beck
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.24 2011/07/04 20:35:35 deraadt Exp $	*/
d716 1
d721 1
a721 1
		return (0);
d724 1
a724 1
		return (0);
d727 1
a727 1
		return (0);
d730 1
a730 1
		return (0);
d733 1
a733 1
		return (0);
d735 2
a736 1
		return (EINVAL);
d738 2
a739 1
	/* NOTREACHED */
@


1.24
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.23 2011/04/05 14:14:07 thib Exp $	*/
d75 1
a75 1
int	ntfs_prtactive = 1;	/* 1 => print out reclaim of active vnodes */
@


1.23
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.22 2010/12/21 20:14:43 thib Exp $	*/
d50 1
a55 2

#include <miscfs/specfs/specdev.h>
@


1.22
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.21 2010/11/18 21:18:07 miod Exp $	*/
a743 1
	.vop_default	= eopnotsupp,
@


1.21
log
@Make sure readdir cookies are actually allocated with the correct size
(in case eventually we change their type from u_long to something else),
and do not truncate them to 32 bits in the ntfs code.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.20 2010/09/10 16:34:09 thib Exp $	*/
d60 14
a73 15
static int	ntfs_bypass(struct vop_generic_args *ap);
static int	ntfs_read(struct vop_read_args *);
static int	ntfs_write(struct vop_write_args *ap);
static int	ntfs_getattr(struct vop_getattr_args *ap);
static int	ntfs_inactive(struct vop_inactive_args *ap);
static int	ntfs_print(struct vop_print_args *ap);
static int	ntfs_reclaim(struct vop_reclaim_args *ap);
static int	ntfs_strategy(struct vop_strategy_args *ap);
static int	ntfs_access(struct vop_access_args *ap);
static int	ntfs_open(struct vop_open_args *ap);
static int	ntfs_close(struct vop_close_args *ap);
static int	ntfs_readdir(struct vop_readdir_args *ap);
static int	ntfs_lookup(struct vop_lookup_args *ap);
static int	ntfs_bmap(struct vop_bmap_args *ap);
static int	ntfs_fsync(struct vop_fsync_args *ap);
d82 1
a82 2
ntfs_bmap(ap)
	struct vop_bmap_args *ap;
d84 1
d96 1
a96 2
ntfs_read(ap)
	struct vop_read_args *ap;
d98 1
d133 1
a133 12
ntfs_bypass(ap)
	struct vop_generic_args *ap;
{
	int error = ENOTTY;
	dprintf(("ntfs_bypass: %s\n", ap->a_desc->vdesc_name));
	return (error);
}


static int
ntfs_getattr(ap)
	struct vop_getattr_args *ap;
d135 1
d168 1
a168 2
ntfs_inactive(ap)
	struct vop_inactive_args *ap;
d170 1
d196 1
a196 2
ntfs_reclaim(ap)
	struct vop_reclaim_args *ap;
d198 1
d227 1
a227 2
ntfs_print(ap)
	struct vop_print_args *ap;
d229 1
d243 1
a243 2
ntfs_strategy(ap)
	struct vop_strategy_args *ap;
d245 1
d316 1
a316 2
ntfs_write(ap)
	struct vop_write_args *ap;
d318 1
d351 1
a351 2
ntfs_access(ap)
	struct vop_access_args *ap;
d353 1
d425 1
a425 2
ntfs_open(ap)
	struct vop_open_args *ap;
d428 1
d449 1
a449 2
ntfs_close(ap)
	struct vop_close_args *ap;
d452 1
d463 1
a463 2
ntfs_readdir(ap)
	struct vop_readdir_args *ap;
d465 1
d599 1
a599 2
ntfs_lookup(ap)
	struct vop_lookup_args *ap;
d601 1
d705 1
a705 2
ntfs_fsync(ap)
	struct vop_fsync_args *ap;
d714 1
a714 2
ntfs_pathconf(v)
	void *v;
d743 21
a763 29
vop_t **ntfs_vnodeop_p;
static
struct vnodeopv_entry_desc ntfs_vnodeop_entries[] = {
	{ &vop_default_desc, (vop_t *)ntfs_bypass },

	{ &vop_getattr_desc, (vop_t *)ntfs_getattr },
	{ &vop_inactive_desc, (vop_t *)ntfs_inactive },
	{ &vop_reclaim_desc, (vop_t *)ntfs_reclaim },
	{ &vop_print_desc, (vop_t *)ntfs_print },
	{ &vop_pathconf_desc, ntfs_pathconf },

	{ &vop_islocked_desc, (vop_t *)vop_generic_islocked },
	{ &vop_unlock_desc, (vop_t *)vop_generic_unlock },
	{ &vop_lock_desc, (vop_t *)vop_generic_lock },
	{ &vop_lookup_desc, (vop_t *)ntfs_lookup },

	{ &vop_access_desc, (vop_t *)ntfs_access },
	{ &vop_close_desc, (vop_t *)ntfs_close },
	{ &vop_open_desc, (vop_t *)ntfs_open },
	{ &vop_readdir_desc, (vop_t *)ntfs_readdir },
	{ &vop_fsync_desc, (vop_t *)ntfs_fsync },

	{ &vop_bmap_desc, (vop_t *)ntfs_bmap },
	{ &vop_strategy_desc, (vop_t *)ntfs_strategy },
	{ &vop_bwrite_desc, (vop_t *)vop_generic_bwrite },
	{ &vop_read_desc, (vop_t *)ntfs_read },
	{ &vop_write_desc, (vop_t *)ntfs_write },

	{ NULL, NULL }
a764 3

const struct vnodeopv_desc ntfs_vnodeop_opv_desc =
	{ &ntfs_vnodeop_p, ntfs_vnodeop_entries };
@


1.20
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.17 2010/04/20 22:05:44 tedu Exp $	*/
d590 1
a590 1
		cookies = malloc(ncookies * sizeof(off_t), M_TEMP, M_WAITOK);
d595 1
a595 1
			*cookiep++ = (u_int) off;
@


1.19
log
@Allow NTFS to compile by cutting it over to the new VOP world order.
Small cleanup while here, nuke the ntfs_bypass function and just
use eopnotsupp like every other filesystem, it makes no sense to
return ENOTTY for unimplemented VOPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.18 2010/08/12 04:05:03 tedu Exp $	*/
d60 15
a74 14
static int	ntfs_read(void *);
static int	ntfs_write(void *);
static int	ntfs_getattr(void *);
static int	ntfs_inactive(void *);
static int	ntfs_print(void *);
static int	ntfs_reclaim(void *);
static int	ntfs_strategy(void *);
static int	ntfs_access(void *);
static int	ntfs_open(void *);
static int	ntfs_close(void *);
static int	ntfs_readdir(void *);
static int	ntfs_lookup(void *);
static int	ntfs_bmap(void *);
static int	ntfs_fsync(void *);
d83 2
a84 1
ntfs_bmap(void *v)
a85 1
	struct vop_bmap_args *ap = v;
d97 2
a98 1
ntfs_read(void *v)
a99 1
	struct vop_read_args *ap = v;
d134 12
a145 1
ntfs_getattr(void *v)
a146 1
	struct vop_getattr_args *ap = v;
d179 2
a180 1
ntfs_inactive(void *v)
a181 1
	struct vop_inactive_args *ap = v;
d207 2
a208 1
ntfs_reclaim(void *v)
a209 1
	struct vop_reclaim_args *ap = v;
d238 2
a239 1
ntfs_print(void *v)
a240 1
	struct vop_print_args *ap = v;
d254 2
a255 1
ntfs_strategy(void *v)
a256 1
	struct vop_strategy_args *ap = v;
d327 2
a328 1
ntfs_write(void *v)
a329 1
	struct vop_write_args *ap = v;
d362 2
a363 1
ntfs_access(void *v)
a364 1
	struct vop_access_args *ap = v;
d436 2
a437 1
ntfs_open(void *v)
a439 1
	struct vop_open_args *ap = v;
d460 2
a461 1
ntfs_close(void *v)
a463 1
	struct vop_close_args *ap = v;
d474 2
a475 1
ntfs_readdir(void *v)
a476 1
	struct vop_readdir_args *ap = v;
d610 2
a611 1
ntfs_lookup(void *v)
a612 1
	struct vop_lookup_args *ap = v;
d716 2
a717 1
ntfs_fsync(void *v)
d726 2
a727 1
ntfs_pathconf(void *v)
d756 29
a784 21
struct vops ntfs_vops = {
	.vop_default	= eopnotsupp,
	.vop_getattr	= ntfs_getattr,
	.vop_inactive	= ntfs_inactive,
	.vop_reclaim	= ntfs_reclaim,
	.vop_print	= ntfs_print,
	.vop_pathconf	= ntfs_pathconf,
	.vop_islocked	= vop_generic_islocked,
	.vop_unlock	= vop_generic_unlock,
	.vop_lock	= vop_generic_lock,
	.vop_lookup	= ntfs_lookup,
	.vop_access	= ntfs_access,
	.vop_close	= ntfs_close,
	.vop_open	= ntfs_open,
	.vop_readdir	= ntfs_readdir,
	.vop_fsync	= ntfs_fsync,
	.vop_bmap	= ntfs_bmap,
	.vop_strategy	= ntfs_strategy,
	.vop_bwrite	= vop_generic_bwrite,
	.vop_read	= ntfs_read,
	.vop_write	= ntfs_write,
d786 3
@


1.18
log
@clean up some macro obfuscation and assorted styling problems.
fix a bonus off by one bug.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.17 2010/04/20 22:05:44 tedu Exp $	*/
d60 14
a73 15
static int	ntfs_bypass(struct vop_generic_args *ap);
static int	ntfs_read(struct vop_read_args *);
static int	ntfs_write(struct vop_write_args *ap);
static int	ntfs_getattr(struct vop_getattr_args *ap);
static int	ntfs_inactive(struct vop_inactive_args *ap);
static int	ntfs_print(struct vop_print_args *ap);
static int	ntfs_reclaim(struct vop_reclaim_args *ap);
static int	ntfs_strategy(struct vop_strategy_args *ap);
static int	ntfs_access(struct vop_access_args *ap);
static int	ntfs_open(struct vop_open_args *ap);
static int	ntfs_close(struct vop_close_args *ap);
static int	ntfs_readdir(struct vop_readdir_args *ap);
static int	ntfs_lookup(struct vop_lookup_args *ap);
static int	ntfs_bmap(struct vop_bmap_args *ap);
static int	ntfs_fsync(struct vop_fsync_args *ap);
d82 1
a82 2
ntfs_bmap(ap)
	struct vop_bmap_args *ap;
d84 1
d96 1
a96 2
ntfs_read(ap)
	struct vop_read_args *ap;
d98 1
d133 1
a133 12
ntfs_bypass(ap)
	struct vop_generic_args *ap;
{
	int error = ENOTTY;
	dprintf(("ntfs_bypass: %s\n", ap->a_desc->vdesc_name));
	return (error);
}


static int
ntfs_getattr(ap)
	struct vop_getattr_args *ap;
d135 1
d168 1
a168 2
ntfs_inactive(ap)
	struct vop_inactive_args *ap;
d170 1
d196 1
a196 2
ntfs_reclaim(ap)
	struct vop_reclaim_args *ap;
d198 1
d227 1
a227 2
ntfs_print(ap)
	struct vop_print_args *ap;
d229 1
d243 1
a243 2
ntfs_strategy(ap)
	struct vop_strategy_args *ap;
d245 1
d316 1
a316 2
ntfs_write(ap)
	struct vop_write_args *ap;
d318 1
d351 1
a351 2
ntfs_access(ap)
	struct vop_access_args *ap;
d353 1
d425 1
a425 2
ntfs_open(ap)
	struct vop_open_args *ap;
d428 1
d449 1
a449 2
ntfs_close(ap)
	struct vop_close_args *ap;
d452 1
d463 1
a463 2
ntfs_readdir(ap)
	struct vop_readdir_args *ap;
d465 1
d599 1
a599 2
ntfs_lookup(ap)
	struct vop_lookup_args *ap;
d601 1
d705 1
a705 2
ntfs_fsync(ap)
	struct vop_fsync_args *ap;
d714 1
a714 2
ntfs_pathconf(v)
	void *v;
d743 21
a763 29
vop_t **ntfs_vnodeop_p;
static
struct vnodeopv_entry_desc ntfs_vnodeop_entries[] = {
	{ &vop_default_desc, (vop_t *)ntfs_bypass },

	{ &vop_getattr_desc, (vop_t *)ntfs_getattr },
	{ &vop_inactive_desc, (vop_t *)ntfs_inactive },
	{ &vop_reclaim_desc, (vop_t *)ntfs_reclaim },
	{ &vop_print_desc, (vop_t *)ntfs_print },
	{ &vop_pathconf_desc, ntfs_pathconf },

	{ &vop_islocked_desc, (vop_t *)vop_generic_islocked },
	{ &vop_unlock_desc, (vop_t *)vop_generic_unlock },
	{ &vop_lock_desc, (vop_t *)vop_generic_lock },
	{ &vop_lookup_desc, (vop_t *)ntfs_lookup },

	{ &vop_access_desc, (vop_t *)ntfs_access },
	{ &vop_close_desc, (vop_t *)ntfs_close },
	{ &vop_open_desc, (vop_t *)ntfs_open },
	{ &vop_readdir_desc, (vop_t *)ntfs_readdir },
	{ &vop_fsync_desc, (vop_t *)ntfs_fsync },

	{ &vop_bmap_desc, (vop_t *)ntfs_bmap },
	{ &vop_strategy_desc, (vop_t *)ntfs_strategy },
	{ &vop_bwrite_desc, (vop_t *)vop_generic_bwrite },
	{ &vop_read_desc, (vop_t *)ntfs_read },
	{ &vop_write_desc, (vop_t *)ntfs_write },

	{ NULL, NULL }
a764 3

const struct vnodeopv_desc ntfs_vnodeop_opv_desc =
	{ &ntfs_vnodeop_p, ntfs_vnodeop_entries };
@


1.17
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.16 2009/08/13 16:00:53 jasper Exp $	*/
d195 1
a195 1
	VOP__UNLOCK(vp, 0, p);
d661 1
a661 1
		VOP__UNLOCK(dvp, 0, p);
d674 1
a674 1
			if (VN_LOCK(dvp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
d680 1
a680 1
			error = VN_LOCK(dvp, LK_EXCLUSIVE, p);
d698 1
a698 1
			VOP__UNLOCK(dvp, 0, p);
@


1.16
log
@- remove super-obvious comments from vnodeop_entries[]
- remove #ifdef someos blocks, makes this a tad easier to read

agreed by art@@ and thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.15 2009/07/09 22:29:56 thib Exp $	*/
a49 3

#include <sys/sysctl.h>

@


1.15
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.13 2008/05/13 02:24:08 brad Exp $	*/
a50 8
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#include <vm/vm.h>
#endif

#if defined(__FreeBSD__)
#include <vm/vnode_pager.h>
#endif

a54 6
#if defined(__FreeBSD__) || defined(__NetBSD__)
#include <fs/ntfs/ntfs.h>
#include <fs/ntfs/ntfs_inode.h>
#include <fs/ntfs/ntfs_subr.h>
#include <miscfs/genfs/genfs.h>
#else
a57 1
#endif
a76 5
#if defined(__FreeBSD__)
static int	ntfs_getpages(struct vop_getpages_args *ap);
static int	ntfs_putpages(struct vop_putpages_args *);
#endif
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a77 1
#endif
a81 18
#if defined(__FreeBSD__)
int
ntfs_getpages(ap)
	struct vop_getpages_args *ap;
{
	return vnode_pager_generic_getpages(ap->a_vp, ap->a_m, ap->a_count,
		ap->a_reqpage);
}

int
ntfs_putpages(ap)
	struct vop_putpages_args *ap;
{
	return vnode_pager_generic_putpages(ap->a_vp, ap->a_m, ap->a_count,
		ap->a_sync, ap->a_rtvals);
}
#endif

a95 4
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
	if (ap->a_runb != NULL)
		*ap->a_runb = 0;
#endif
a156 3
#if defined(__FreeBSD__)
	vap->va_fsid = dev2udev(ip->i_dev);
#else /* NetBSD */
a157 1
#endif
a185 1
#ifdef __OpenBSD__
a186 1
#endif
a215 1
#ifdef __OpenBSD__
a216 1
#endif
a225 3
#ifndef __OpenBSD__
	if ((error = ntfs_ntget(ip)) != 0)
#else
a226 1
#endif
a232 3
#ifndef __OpenBSD__
	ntfs_ntput(ip);
#else
d234 1
a234 1
#endif
a266 5
#ifdef __FreeBSD__
	dprintf(("ntfs_strategy: offset: %d, blkno: %d, lblkno: %d\n",
		(u_int32_t)bp->b_offset,(u_int32_t)bp->b_blkno,
		(u_int32_t)bp->b_lblkno));
#else
a269 1
#endif
a535 3
#ifndef __OpenBSD__
		error = ntfs_ntreaddir(ntmp, fp, num, &iep);
#else
a536 1
#endif
a583 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a585 4
#else /* defined(__NetBSD__) */
		off_t *cookies;
		off_t *cookiep;
#endif
a592 4
#if defined(__FreeBSD__)
		MALLOC(cookies, u_long *, ncookies * sizeof(u_long),
		       M_TEMP, M_WAITOK);
#else /* defined(__NetBSD__) */
a593 1
#endif
a622 1
#ifdef __OpenBSD__
a623 1
#endif
a639 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a649 1
#endif
a690 3
#ifndef __OpenBSD__
		error = ntfs_ntlookupfile(ntmp, dvp, cnp, ap->a_vpp);
#else
a691 1
#endif
a711 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a723 1
#endif
a749 8
#ifdef __NetBSD__
	case _PC_SYNC_IO:
		*ap->a_retval = 1;
		return (0);
	case _PC_FILESIZEBITS:
		*ap->a_retval = 64;
		return (0);
#endif
a759 41
#if defined(__FreeBSD__)
static
struct vnodeopv_entry_desc ntfs_vnodeop_entries[] = {
	{ &vop_default_desc, (vop_t *)ntfs_bypass },

	{ &vop_getattr_desc, (vop_t *)ntfs_getattr },
	{ &vop_inactive_desc, (vop_t *)ntfs_inactive },
	{ &vop_reclaim_desc, (vop_t *)ntfs_reclaim },
	{ &vop_print_desc, (vop_t *)ntfs_print },
	{ &vop_pathconf_desc, ntfs_pathconf },

	{ &vop_islocked_desc, (vop_t *)vop_stdislocked },
	{ &vop_unlock_desc, (vop_t *)vop_stdunlock },
	{ &vop_lock_desc, (vop_t *)vop_stdlock },
	{ &vop_cachedlookup_desc, (vop_t *)ntfs_lookup },
	{ &vop_lookup_desc, (vop_t *)vfs_cache_lookup },

	{ &vop_access_desc, (vop_t *)ntfs_access },
	{ &vop_close_desc, (vop_t *)ntfs_close },
	{ &vop_open_desc, (vop_t *)ntfs_open },
	{ &vop_readdir_desc, (vop_t *)ntfs_readdir },
	{ &vop_fsync_desc, (vop_t *)ntfs_fsync },

	{ &vop_bmap_desc, (vop_t *)ntfs_bmap },
	{ &vop_getpages_desc, (vop_t *) ntfs_getpages },
	{ &vop_putpages_desc, (vop_t *) ntfs_putpages },
	{ &vop_strategy_desc, (vop_t *)ntfs_strategy },
	{ &vop_bwrite_desc, (vop_t *)vop_stdbwrite },
	{ &vop_read_desc, (vop_t *)ntfs_read },
	{ &vop_write_desc, (vop_t *)ntfs_write },

	{ NULL, NULL }
};

static
struct vnodeopv_desc ntfs_vnodeop_opv_desc =
	{ &ntfs_vnodeop_p, ntfs_vnodeop_entries };

VNODEOP_SET(ntfs_vnodeop_opv_desc);

#elif defined(__OpenBSD__)
a791 58

#else /* !FreeBSD && !OpenBSD*/

const struct vnodeopv_entry_desc ntfs_vnodeop_entries[] = {
	{ &vop_default_desc, (vop_t *) ntfs_bypass },
	{ &vop_lookup_desc, (vop_t *) ntfs_lookup },	/* lookup */
	{ &vop_create_desc, genfs_eopnotsupp },		/* create */
	{ &vop_mknod_desc, genfs_eopnotsupp },		/* mknod */
	{ &vop_open_desc, (vop_t *) ntfs_open },	/* open */
	{ &vop_close_desc,(vop_t *)  ntfs_close },	/* close */
	{ &vop_access_desc, (vop_t *) ntfs_access },	/* access */
	{ &vop_getattr_desc, (vop_t *) ntfs_getattr },	/* getattr */
	{ &vop_setattr_desc, genfs_eopnotsupp },	/* setattr */
	{ &vop_read_desc, (vop_t *) ntfs_read },	/* read */
	{ &vop_write_desc, (vop_t *) ntfs_write },	/* write */
	{ &vop_lease_desc, genfs_lease_check },		/* lease */
	{ &vop_fcntl_desc, genfs_fcntl },		/* fcntl */
	{ &vop_ioctl_desc, genfs_enoioctl },		/* ioctl */
	{ &vop_poll_desc, genfs_poll },			/* poll */
	{ &vop_kqfilter_desc, genfs_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, genfs_revoke },		/* revoke */
	{ &vop_mmap_desc, genfs_mmap },			/* mmap */
	{ &vop_fsync_desc, genfs_fsync },		/* fsync */
	{ &vop_seek_desc, genfs_seek },			/* seek */
	{ &vop_remove_desc, genfs_eopnotsupp },		/* remove */
	{ &vop_link_desc, genfs_eopnotsupp },		/* link */
	{ &vop_rename_desc, genfs_eopnotsupp },		/* rename */
	{ &vop_mkdir_desc, genfs_eopnotsupp },		/* mkdir */
	{ &vop_rmdir_desc, genfs_eopnotsupp },		/* rmdir */
	{ &vop_symlink_desc, genfs_eopnotsupp },	/* symlink */
	{ &vop_readdir_desc, (vop_t *) ntfs_readdir },	/* readdir */
	{ &vop_readlink_desc, genfs_eopnotsupp },	/* readlink */
	{ &vop_abortop_desc, genfs_abortop },		/* abortop */
	{ &vop_inactive_desc, (vop_t *) ntfs_inactive },	/* inactive */
	{ &vop_reclaim_desc, (vop_t *) ntfs_reclaim },	/* reclaim */
	{ &vop_lock_desc, genfs_lock },			/* lock */
	{ &vop_unlock_desc, genfs_unlock },		/* unlock */
	{ &vop_bmap_desc, (vop_t *) ntfs_bmap },	/* bmap */
	{ &vop_strategy_desc, (vop_t *) ntfs_strategy },	/* strategy */
	{ &vop_print_desc, (vop_t *) ntfs_print },	/* print */
	{ &vop_islocked_desc, genfs_islocked },		/* islocked */
	{ &vop_pathconf_desc, ntfs_pathconf },		/* pathconf */
	{ &vop_advlock_desc, genfs_nullop },		/* advlock */
	{ &vop_blkatoff_desc, genfs_eopnotsupp },	/* blkatoff */
	{ &vop_valloc_desc, genfs_eopnotsupp },		/* valloc */
	{ &vop_reallocblks_desc, genfs_eopnotsupp },	/* reallocblks */
	{ &vop_vfree_desc, genfs_eopnotsupp },		/* vfree */
	{ &vop_truncate_desc, genfs_eopnotsupp },	/* truncate */
	{ &vop_update_desc, genfs_eopnotsupp },		/* update */
	{ &vop_bwrite_desc, vn_bwrite },		/* bwrite */
	{ &vop_getpages_desc, genfs_compat_getpages },	/* getpages */
	{ &vop_putpages_desc, genfs_putpages },		/* putpages */
	{ NULL, NULL }
};
const struct vnodeopv_desc ntfs_vnodeop_opv_desc =
	{ &ntfs_vnodeop_p, ntfs_vnodeop_entries };

#endif
@


1.14
log
@- make sure biodone() gets run at IPL_BIO

OK thib@@
@
text
@d737 1
a737 1
		VREF(dvp);
@


1.13
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.12 2007/12/09 21:28:53 hshoexer Exp $	*/
d323 1
a323 1
	int error;
d387 1
d389 1
@


1.12
log
@MALLOC/FREE -> malloc/free

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.11 2007/06/01 23:52:38 deraadt Exp $	*/
a37 5

#include <sys/cdefs.h>
#ifdef __KERNEL_RCSID
__KERNEL_RCSID(0, "$NetBSD: ntfs_vnops.c,v 1.6 2003/04/10 21:57:26 jdolecek Exp $");
#endif
@


1.11
log
@more vop argument "ap = v" comment removal; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.10 2006/01/09 12:43:16 pedro Exp $	*/
d562 1
a562 1
	MALLOC(cde, struct dirent *, sizeof(struct dirent), M_TEMP, M_WAITOK);
d689 1
a689 1
	FREE(cde, M_TEMP);
@


1.10
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.9 2005/10/19 16:50:47 pedro Exp $	*/
d131 1
a131 8
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
		int *a_runb;
	} */ *ap;
d149 1
a149 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap;
d186 1
a186 4
	struct vop_generic_args /* {
		struct vnodeop_desc *a_desc;
		<other random data follows, presumably>
	} */ *ap;
d196 1
a196 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d235 1
a235 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap;
d265 1
a265 4
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap;
d305 1
a305 3
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap;
d321 1
a321 3
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap;
d398 1
a398 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap;
d433 1
a433 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d507 1
a507 6
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d531 1
a531 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d545 1
a545 8
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		int *a_ncookies;
		u_long **a_cookies;
	} */ *ap;
d695 1
a695 5
	struct vop_lookup_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap;
d810 1
a810 8
	struct vop_fsync_args /* {
		struct vnode *a_vp;
		struct ucred *a_cred;
		int a_waitfor;
		off_t offlo;
		off_t offhi;
		struct proc *a_p;
	} */ *ap;
d823 1
a823 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
@


1.9
log
@Remove v_vnlock from struct vnode, okay krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.8 2005/05/21 19:43:20 brad Exp $	*/
d270 1
d273 1
d303 1
d306 1
@


1.8
log
@fix parenthesis
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.7 2005/05/21 18:05:58 brad Exp $	*/
d335 1
a335 5
#if 0
	printf("       ");
	lockmgr_printinfo(ap->a_vp->v_vnlock);
	printf("\n");
#endif
@


1.7
log
@- use MIN()/MAX() rather than min()/max(), to avoid possible truncation
  of 64bit values to 'int'
- read always single cluster of data, to avoid confusing the buffer
  cache; this appears to fix the random file content corruption which
  happens when more than one cluster is read at the same time, i.e. for
  files > 3*cluster_size
- fix some questionable pointer arithmetics; gcc-3.4.x didn't like it
- g/c redundant debug printf
- remove all traces of non-working quota support
  add quota support to TODO - makes sense only once writing support
  would be implemented, and only once NTFS would support notion of file 'owner'
- use 64bit local variable for free space computation

From NetBSD

- Comment fixes from joris@@

ok millert@@ joris@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.6 2005/04/16 16:28:42 joris Exp $	*/
d720 1
a720 1
		dprintf("ntfs_readdir: %d cookies\n",ncookies);
@


1.6
log
@

comment out some code which is causing ntfs panics due
to the fact ntfs uses the generic locking functions which
do not lock anything right now.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.5 2005/03/08 15:45:20 pat Exp $	*/
d179 1
a179 1
		toread = min( uio->uio_resid, fp->f_size - uio->uio_offset );
d370 1
a370 1
	dprintf(("strategy: bcount: %d flags: 0x%lx\n", 
d380 2
a381 2
			toread = min(bp->b_bcount,
				 fp->f_size-ntfs_cntob(bp->b_blkno));
d406 2
a407 2
			towrite = min(bp->b_bcount,
				fp->f_size-ntfs_cntob(bp->b_blkno));
d452 1
a452 1
	towrite = min(uio->uio_resid, fp->f_size - uio->uio_offset);
a480 3
#if defined(__NetBSD__) && defined(QUOTA)
	int error;
#endif
a495 4
#if defined(__NetBSD__) && defined(QUOTA)
			if (error = getinoquota(ip))
				return (error);
#endif
d720 1
a720 1
		printf("ntfs_readdir: %d cookies\n",ncookies);
@


1.5
log
@fix a page fault that occurs when a reclaimed vnode is then reused.
from FreeBSD

ok pedro tedu miod, tested by millert and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.4 2003/06/02 23:28:20 millert Exp $	*/
d335 1
d339 1
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.3 2003/05/20 03:36:42 tedu Exp $	*/
a312 4
	if (ip->i_devvp) {
		vrele(ip->i_devvp);
		ip->i_devvp = NULL;
	}
@


1.4.2.1
log
@add file to SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3
log
@un __P
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.2 2003/05/20 03:23:12 mickey Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@fix the tags
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vnops.c,v 1.1 2003/05/20 03:03:27 tedu Exp $	*/
d87 14
a100 14
static int	ntfs_bypass (struct vop_generic_args *ap);
static int	ntfs_read (struct vop_read_args *);
static int	ntfs_write (struct vop_write_args *ap);
static int	ntfs_getattr (struct vop_getattr_args *ap);
static int	ntfs_inactive (struct vop_inactive_args *ap);
static int	ntfs_print (struct vop_print_args *ap);
static int	ntfs_reclaim (struct vop_reclaim_args *ap);
static int	ntfs_strategy (struct vop_strategy_args *ap);
static int	ntfs_access (struct vop_access_args *ap);
static int	ntfs_open (struct vop_open_args *ap);
static int	ntfs_close (struct vop_close_args *ap);
static int	ntfs_readdir (struct vop_readdir_args *ap);
static int	ntfs_lookup (struct vop_lookup_args *ap);
static int	ntfs_bmap (struct vop_bmap_args *ap);
d102 2
a103 2
static int	ntfs_getpages (struct vop_getpages_args *ap);
static int	ntfs_putpages (struct vop_putpages_args *);
d106 1
a106 1
static int	ntfs_fsync (struct vop_fsync_args *ap);
d108 1
a108 1
static int	ntfs_pathconf (void *);
@


1.1
log
@by popular request, NTFS support.  read only.
The code comes from NetBSD and was ported by Julian Bordet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id$	*/
@

