head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.2
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.22
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.20
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.18
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.16
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.14
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.12
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.10
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.20
date	2016.09.24.18.38.23;	author tedu;	state Exp;
branches;
next	1.19;
commitid	MPQxYy8mwzE8urJx;

1.19
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.18;
commitid	p4LJxGKbi0BU2cG6;

1.18
date	2015.01.09.05.01.57;	author tedu;	state Exp;
branches;
next	1.17;
commitid	KWogeIYA2sxG3IjB;

1.17
date	2014.11.18.10.42.15;	author dlg;	state Exp;
branches;
next	1.16;
commitid	4DOHz2gKfCx7RejS;

1.16
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.15;
commitid	uzzBR7hz9ncd4O6G;

1.15
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.14;
commitid	FE3DG5cICjyI4jWx;

1.14
date	2014.01.19.18.35.45;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.30.20.11.06;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.14.02.41.03;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.02.08.12.13;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.04.21.35.58;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.22.21.23.07;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.12.04.05.03;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.23.19.32.57;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.13.16.00.53;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.25.20.39.47;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.02.23.28.20;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.05.20.03.23.11;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.20.03.03.27;	author tedu;	state Exp;
branches;
next	;

1.3.2.1
date	2003.06.07.10.47.03;	author ho;	state Exp;
branches;
next	;


desc
@@


1.20
log
@use hashfree in fs code. from Mathieu -
ok guenther
@
text
@/*	$OpenBSD: ntfs_ihash.c,v 1.19 2015/03/14 03:38:52 jsg Exp $	*/
/*	$NetBSD: ntfs_ihash.c,v 1.1 2002/12/23 17:38:32 jdolecek Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_ihash.c	8.7 (Berkeley) 5/17/95
 * Id: ntfs_ihash.c,v 1.5 1999/05/12 09:42:58 semenu Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/rwlock.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/mount.h>

#include <crypto/siphash.h>

#include <ntfs/ntfs.h>
#include <ntfs/ntfs_inode.h>
#include <ntfs/ntfs_ihash.h>

/*
 * Structures associated with inode cacheing.
 */
u_int ntfs_hash(dev_t, ntfsino_t);
static LIST_HEAD(nthashhead, ntnode) *ntfs_nthashtbl;
static SIPHASH_KEY ntfs_nthashkey;
static u_long	ntfs_nthash;		/* size of hash table - 1 */
#define	NTNOHASH(device, inum) ntfs_hash((device), (inum))
struct rwlock ntfs_hashlock = RWLOCK_INITIALIZER("ntfs_nthashlock");

/*
 * Initialize inode hash table.
 */
void
ntfs_nthashinit(void)
{
	u_long nthash;
	void *nthashtbl;

	if (ntfs_nthashtbl)
		return;

	nthashtbl = hashinit(initialvnodes, M_NTFSNTHASH, M_WAITOK, &nthash);
	if (ntfs_nthashtbl) {
		hashfree(nthashtbl, initialvnodes, M_NTFSNTHASH);
		return;
	}
	ntfs_nthashtbl = nthashtbl;
	ntfs_nthash = nthash;

	arc4random_buf(&ntfs_nthashkey, sizeof(ntfs_nthashkey));
}

u_int
ntfs_hash(dev_t dev, ntfsino_t inum)
{
	SIPHASH_CTX ctx;

	SipHash24_Init(&ctx, &ntfs_nthashkey);
	SipHash24_Update(&ctx, &dev, sizeof(dev));
	SipHash24_Update(&ctx, &inum, sizeof(inum));

	return (SipHash24_End(&ctx) & ntfs_nthash);
}

/*
 * Use the device/inum pair to find the incore inode, and return a pointer
 * to it. If it is in core, return it, even if it is locked.
 */
struct ntnode *
ntfs_nthashlookup(dev_t dev, ntfsino_t inum)
{
	struct ntnode *ip;
	struct nthashhead *ipp;

	/* XXXLOCKING lock hash list? */
	ipp = &ntfs_nthashtbl[NTNOHASH(dev, inum)];
	LIST_FOREACH(ip, ipp, i_hash) {
		if (inum == ip->i_number && dev == ip->i_dev)
			break;
	}
	/* XXXLOCKING unlock hash list? */

	return (ip);
}

/*
 * Insert the ntnode into the hash table.
 */
void
ntfs_nthashins(struct ntnode *ip)
{
	struct nthashhead *ipp;

	/* XXXLOCKING lock hash list? */
	ipp = &ntfs_nthashtbl[NTNOHASH(ip->i_dev, ip->i_number)];
	LIST_INSERT_HEAD(ipp, ip, i_hash);
	ip->i_flag |= IN_HASHED;
	/* XXXLOCKING unlock hash list? */
}

/*
 * Remove the inode from the hash table.
 */
void
ntfs_nthashrem(struct ntnode *ip)
{
	/* XXXLOCKING lock hash list? */
	if (ip->i_flag & IN_HASHED) {
		ip->i_flag &= ~IN_HASHED;
		LIST_REMOVE(ip, i_hash);
	}
	/* XXXLOCKING unlock hash list? */
}
@


1.19
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.18 2015/01/09 05:01:57 tedu Exp $	*/
d73 1
a73 1
		free(nthashtbl, M_NTFSNTHASH, 0);
@


1.18
log
@rename desiredvnodes to initialvnodes. less of a lie. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.17 2014/11/18 10:42:15 dlg Exp $	*/
a37 1
#include <sys/kernel.h>
@


1.17
log
@use siphash for key lookups in all the filesystem hashes.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.16 2014/09/14 14:17:26 jsg Exp $	*/
d72 1
a72 1
	nthashtbl = hashinit(desiredvnodes, M_NTFSNTHASH, M_WAITOK, &nthash);
@


1.16
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.15 2014/07/12 18:43:52 tedu Exp $	*/
d44 2
d53 1
d55 1
d57 1
a57 1
#define	NTNOHASH(device, inum)	((minor(device) + (inum)) & ntfs_nthash)
d79 14
@


1.15
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.14 2014/01/19 18:35:45 tedu Exp $	*/
a41 1
#include <sys/proc.h>
@


1.14
log
@lazy init nthash to save some memory when it's not used. ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.13 2013/05/30 20:11:06 guenther Exp $	*/
d71 1
a71 1
		free(nthashtbl, M_NTFSNTHASH);
@


1.13
log
@More of the same: ntfs doesn't do inode numbers >2^32, so use a smaller type
internally, only using ino_t in the VFS layer APIs: vget, readdir, getattr
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.12 2013/01/14 02:41:03 jsing Exp $	*/
d63 13
a75 2
	ntfs_nthashtbl = hashinit(desiredvnodes, M_NTFSNTHASH, M_WAITOK,
	    &ntfs_nthash);
@


1.12
log
@Ansify and apply style(9) to function definitions.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.11 2013/01/02 08:12:13 jsing Exp $	*/
d72 1
a72 1
ntfs_nthashlookup(dev_t dev, ino_t inum)
@


1.11
log
@Remove code that is not used on OpenBSD.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.10 2010/09/04 21:35:58 tedu Exp $	*/
d61 1
a61 1
ntfs_nthashinit()
d72 1
a72 3
ntfs_nthashlookup(dev, inum)
	dev_t dev;
	ino_t inum;
d92 1
a92 2
ntfs_nthashins(ip)
	struct ntnode *ip;
d107 1
a107 2
ntfs_nthashrem(ip)
	struct ntnode *ip;
@


1.10
log
@revert previous "simplification".  kcornies at gmail says it doesn't work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.9 2010/08/22 21:23:07 tedu Exp $	*/
a47 4

#ifdef MALLOC_DEFINE
MALLOC_DEFINE(M_NTFSNTHASH, "NTFS nthash", "NTFS ntnode hash tables");
#endif
@


1.9
log
@the upper case table code was a lot more complicated than it needed to be.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.8 2010/08/12 04:05:03 tedu Exp $	*/
d42 1
d48 4
@


1.8
log
@clean up some macro obfuscation and assorted styling problems.
fix a bonus off by one bug.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.7 2010/04/23 19:32:57 oga Exp $	*/
a41 1
#include <sys/proc.h>
a46 4

#ifdef MALLOC_DEFINE
MALLOC_DEFINE(M_NTFSNTHASH, "NTFS nthash", "NTFS ntnode hash tables");
#endif
@


1.7
log
@It is about time that we stopped pretending simple_locks are locks.

replace ntfs_nthash_slock usage with comments prefixed XXXLOCKING (for
grepability).

This lock looks to be correct, but it could well be the bad way to do it
(having a rwlock for inserts to avoid races inserting the same inode but
then simple locking on list accesses).

approach discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.6 2009/08/13 16:00:53 jasper Exp $	*/
d67 1
a67 1
	ntfs_nthashtbl = HASHINIT(desiredvnodes, M_NTFSNTHASH, M_WAITOK,
@


1.6
log
@- remove super-obvious comments from vnodeop_entries[]
- remove #ifdef someos blocks, makes this a tad easier to read

agreed by art@@ and thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.5 2009/03/25 20:39:47 oga Exp $	*/
a38 1
#include <sys/lock.h>
a58 3
#ifndef NULL_SIMPLELOCKS
static struct simplelock ntfs_nthash_slock;
#endif
a68 1
	simple_lock_init(&ntfs_nthash_slock);
d83 1
a83 1
	simple_lock(&ntfs_nthash_slock);
d89 1
a89 1
	simple_unlock(&ntfs_nthash_slock);
d103 1
a103 1
	simple_lock(&ntfs_nthash_slock);
d107 1
a107 1
	simple_unlock(&ntfs_nthash_slock);
d117 1
a117 1
	simple_lock(&ntfs_nthash_slock);
d122 1
a122 1
	simple_unlock(&ntfs_nthash_slock);
@


1.5
log
@convert lockmgr over to rwlock in ntfs, mostly trivial.

Tested by a couple of people, no regressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.4 2008/05/13 02:24:08 brad Exp $	*/
a45 5
#if defined(__FreeBSD__) || defined(__NetBSD__)
#include <fs/ntfs/ntfs.h>
#include <fs/ntfs/ntfs_inode.h>
#include <fs/ntfs/ntfs_ihash.h>
#else
a48 1
#endif
a74 42

#ifdef __NetBSD__
/*
 * Reinitialize inode hash table.
 */

void
ntfs_nthashreinit()
{
	struct ntnode *ip;
	struct nthashhead *oldhash, *hash;
	u_long oldmask, mask, val;
	int i;

	hash = HASHINIT(desiredvnodes, M_NTFSNTHASH, M_WAITOK, &mask);

	simple_lock(&ntfs_nthash_slock);
	oldhash = ntfs_nthashtbl;
	oldmask = ntfs_nthash;
	ntfs_nthashtbl = hash;
	ntfs_nthash = mask;
	for (i = 0; i <= oldmask; i++) {
		while ((ip = LIST_FIRST(&oldhash[i])) != NULL) {
			LIST_REMOVE(ip, i_hash);
			val = NTNOHASH(ip->i_dev, ip->i_number);
			LIST_INSERT_HEAD(&hash[val], ip, i_hash);
		}
	}
	simple_unlock(&ntfs_nthash_slock);
	hashdone(oldhash, M_NTFSNTHASH);
}

/*
 * Free the inode hash table. Called from ntfs_done(), only needed
 * on NetBSD.
 */
void
ntfs_nthashdone()
{
	hashdone(ntfs_nthashtbl, M_NTFSNTHASH);
}
#endif
@


1.4
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.3 2003/06/02 23:28:20 millert Exp $	*/
d40 1
d69 1
a69 1
struct lock ntfs_hashlock;
a76 1
	lockinit(&ntfs_hashlock, PINOD, "ntfs_nthashlock", 0, 0);
@


1.3
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.2 2003/05/20 03:23:11 mickey Exp $	*/
a34 5

#include <sys/cdefs.h>
#ifdef __KERNEL_RCSID
__KERNEL_RCSID(0, "$NetBSD: ntfs_ihash.c,v 1.1 2002/12/23 17:38:32 jdolecek Exp $");
#endif
@


1.3.2.1
log
@add file to SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@fix the tags
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_ihash.c,v 1.1 2003/05/20 03:03:27 tedu Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.1
log
@by popular request, NTFS support.  read only.
The code comes from NetBSD and was ported by Julian Bordet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id$	*/
@

