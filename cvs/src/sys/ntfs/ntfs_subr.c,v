head	1.48;
access;
symbols
	OPENBSD_6_1:1.48.0.4
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.46.0.2
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.48
date	2016.09.01.08.40.39;	author natano;	state Exp;
branches;
next	1.47;
commitid	NvsKsQuRDuQNpuOz;

1.47
date	2016.08.31.15.13.57;	author tom;	state Exp;
branches;
next	1.46;
commitid	1JX4fnSuNHnyuTIa;

1.46
date	2016.06.01.15.44.07;	author natano;	state Exp;
branches;
next	1.45;
commitid	XHjCt7dioDc4fepb;

1.45
date	2016.02.07.09.31.14;	author stefan;	state Exp;
branches;
next	1.44;
commitid	kZnlTMcEhaYbKRgS;

1.44
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.43;
commitid	p4LJxGKbi0BU2cG6;

1.43
date	2015.02.10.22.04.00;	author miod;	state Exp;
branches;
next	1.42;
commitid	xPdkHWWd7nmZkTX3;

1.42
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.41;
commitid	C5iGb36LQxjM60Q3;

1.41
date	2014.12.16.19.56.33;	author tedu;	state Exp;
branches;
next	1.40;
commitid	QDtD6hT4TizWpQLS;

1.40
date	2014.12.09.07.16.41;	author doug;	state Exp;
branches;
next	1.39;
commitid	tPDMRisjAolmdVN1;

1.39
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.38;
commitid	uzzBR7hz9ncd4O6G;

1.38
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.37;
commitid	FE3DG5cICjyI4jWx;

1.37
date	2014.01.19.18.35.45;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2013.12.02.16.23.16;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2013.12.02.16.19.08;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2013.12.02.16.05.07;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.24.16.02.30;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.05.30.20.11.06;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.18.05.09.21;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.14.02.41.03;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.13.04.07.49;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.03.16.13.16;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.02.08.12.13;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.09.11.31.40;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.04.21.35.58;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.22.21.23.07;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.12.04.05.03;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2010.08.06.00.00.41;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.13.16.00.53;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.25.20.39.47;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.09.21.28.53;	author hshoexer;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.06.02.18.39;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.02.01.02.56;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.12.22.02.57;	author thib;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.24.05.43.31;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.22.04.38.54;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.21.18.05.58;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.08.15.45.20;	author pat;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.20.03.36.42;	author tedu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.05.20.03.23.12;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.20.03.03.27;	author tedu;	state Exp;
branches;
next	;

1.3.2.1
date	2003.06.07.10.47.03;	author ho;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Remove the unused ntfs write code. ok benno beck
@
text
@/*	$OpenBSD: ntfs_subr.c,v 1.47 2016/08/31 15:13:57 tom Exp $	*/
/*	$NetBSD: ntfs_subr.c,v 1.4 2003/04/10 21:37:32 jdolecek Exp $	*/

/*-
 * Copyright (c) 1998, 1999 Semen Ustimenko (semenu@@FreeBSD.org)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	Id: ntfs_subr.c,v 1.4 1999/05/12 09:43:01 semenu Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/rwlock.h>
#include <sys/specdev.h>

/* #define NTFS_DEBUG 1 */
#include <ntfs/ntfs.h>
#include <ntfs/ntfsmount.h>
#include <ntfs/ntfs_inode.h>
#include <ntfs/ntfs_vfsops.h>
#include <ntfs/ntfs_subr.h>
#include <ntfs/ntfs_compr.h>
#include <ntfs/ntfs_ihash.h>

#if defined(NTFS_DEBUG)
int ntfs_debug = NTFS_DEBUG;
#endif

/* Local struct used in ntfs_ntlookupfile() */
struct ntfs_lookup_ctx {
	u_int32_t	aoff;
	u_int32_t	rdsize;
	cn_t		cn;
	struct ntfs_lookup_ctx *prev;
};

int ntfs_ntlookupattr(struct ntfsmount *, const char *, int, int *, char **);
int ntfs_findvattr(struct ntfsmount *, struct ntnode *, struct ntvattr **, struct ntvattr **, u_int32_t, const char *, size_t, cn_t);
int ntfs_uastricmp(struct ntfsmount *, const wchar *, size_t, const char *, size_t);
int ntfs_uastrcmp(struct ntfsmount *, const wchar *, size_t, const char *, size_t);

/* table for mapping Unicode chars into uppercase; it's filled upon first
 * ntfs mount, freed upon last ntfs umount */
static wchar *ntfs_toupper_tab;
#define NTFS_U28(ch)		((((ch) & 0xE0) == 0) ? '_' : (ch) & 0xFF)
#define NTFS_TOUPPER(ch)	(ntfs_toupper_tab[(unsigned char)(ch)])
struct rwlock ntfs_toupper_lock = RWLOCK_INITIALIZER("ntfs_toupper");
static signed int ntfs_toupper_usecount;

/* support macro for ntfs_ntvattrget() */
#define NTFS_AALPCMP(aalp,type,name,namelen) (				\
  (aalp->al_type == type) && (aalp->al_namelen == namelen) &&		\
  !ntfs_uastrcmp(ntmp, aalp->al_name,aalp->al_namelen,name,namelen) )

/*
 * 
 */
int
ntfs_ntvattrrele(struct ntvattr *vap)
{
	DPRINTF("ntfs_ntvattrrele: ino: %u, type: 0x%x\n",
	    vap->va_ip->i_number, vap->va_type);

	ntfs_ntrele(vap->va_ip);

	return (0);
}

/*
 * find the attribute in the ntnode
 */
int
ntfs_findvattr(struct ntfsmount *ntmp, struct ntnode *ip,
    struct ntvattr **lvapp, struct ntvattr **vapp, u_int32_t type,
    const char *name, size_t namelen, cn_t vcn)
{
	int error;
	struct ntvattr *vap;

	if((ip->i_flag & IN_LOADED) == 0) {
		DPRINTF("ntfs_findvattr: node not loaded, ino: %u\n",
		    ip->i_number);
		error = ntfs_loadntnode(ntmp,ip);
		if (error) {
			printf("ntfs_findvattr: FAILED TO LOAD INO: %d\n",
			       ip->i_number);
			return (error);
		}
	} else {
		/* Update LRU loaded list. */
		TAILQ_REMOVE(&ntmp->ntm_ntnodeq, ip, i_loaded);
		TAILQ_INSERT_HEAD(&ntmp->ntm_ntnodeq, ip, i_loaded);
	}

	*lvapp = NULL;
	*vapp = NULL;
	LIST_FOREACH(vap, &ip->i_valist, va_list) {
		DDPRINTF("ntfs_findvattr: type: 0x%x, vcn: %llu - %llu\n",
		    vap->va_type, vap->va_vcnstart, vap->va_vcnend);
		if ((vap->va_type == type) &&
		    (vap->va_vcnstart <= vcn) && (vap->va_vcnend >= vcn) &&
		    (vap->va_namelen == namelen) &&
		    (strncmp(name, vap->va_name, namelen) == 0)) {
			*vapp = vap;
			ntfs_ntref(vap->va_ip);
			return (0);
		}
		if (vap->va_type == NTFS_A_ATTRLIST)
			*lvapp = vap;
	}

	return (-1);
}

/*
 * Search attribute specified in ntnode (load ntnode if necessary).
 * If not found but ATTR_A_ATTRLIST present, read it in and search through.
 * VOP_VGET node needed, and lookup through its ntnode (load if necessary).
 *
 * ntnode should be locked
 */
int
ntfs_ntvattrget(struct ntfsmount *ntmp, struct ntnode *ip, u_int32_t type,
    const char *name, cn_t vcn, struct ntvattr **vapp)
{
	struct ntvattr *lvap = NULL;
	struct attr_attrlist *aalp;
	struct attr_attrlist *nextaalp;
	struct vnode   *newvp;
	struct ntnode  *newip;
	caddr_t         alpool;
	size_t		namelen, len;
	int             error;

	*vapp = NULL;

	if (name) {
		DPRINTF("ntfs_ntvattrget: ino: %u, type: 0x%x, name: %s, "
		    "vcn: %llu\n", ip->i_number, type, name, vcn);
		namelen = strlen(name);
	} else {
		DPRINTF("ntfs_ntvattrget: ino: %u, type: 0x%x, vcn: %llu\n",
		    ip->i_number, type, vcn);
		name = "";
		namelen = 0;
	}

	error = ntfs_findvattr(ntmp, ip, &lvap, vapp, type, name, namelen, vcn);
	if (error >= 0)
		return (error);

	if (!lvap) {
		DPRINTF("ntfs_ntvattrget: UNEXISTED ATTRIBUTE: ino: %u, "
		    "type: 0x%x, name: %s, vcn: %llu\n", ip->i_number, type,
		    name, vcn);
		return (ENOENT);
	}
	/* Scan $ATTRIBUTE_LIST for requested attribute */
	len = lvap->va_datalen;
	alpool = malloc(len, M_TEMP, M_WAITOK);
	error = ntfs_readntvattr_plain(ntmp, ip, lvap, 0, len, alpool, &len,
			NULL);
	if (error)
		goto out;

	aalp = (struct attr_attrlist *) alpool;
	nextaalp = NULL;

	for(; len > 0; aalp = nextaalp) {
		DPRINTF("ntfs_ntvattrget: attrlist: ino: %u, attr: 0x%x, "
		    "vcn: %llu\n", aalp->al_inumber, aalp->al_type,
		    aalp->al_vcnstart);

		if (len > aalp->reclen) {
			nextaalp = NTFS_NEXTREC(aalp, struct attr_attrlist *);
		} else {
			nextaalp = NULL;
		}
		len -= aalp->reclen;

		if (!NTFS_AALPCMP(aalp, type, name, namelen) ||
		    (nextaalp && (nextaalp->al_vcnstart <= vcn) &&
		     NTFS_AALPCMP(nextaalp, type, name, namelen)))
			continue;

		DPRINTF("ntfs_ntvattrget: attribute in ino: %u\n",
		    aalp->al_inumber);

		/* this is not a main record, so we can't use just plain
		   vget() */
		error = ntfs_vgetex(ntmp->ntm_mountp, aalp->al_inumber,
				NTFS_A_DATA, NULL, LK_EXCLUSIVE,
				VG_EXT, curproc, &newvp);
		if (error) {
			printf("ntfs_ntvattrget: CAN'T VGET INO: %d\n",
			       aalp->al_inumber);
			goto out;
		}
		newip = VTONT(newvp);
		/* XXX have to lock ntnode */
		error = ntfs_findvattr(ntmp, newip, &lvap, vapp,
				type, name, namelen, vcn);
		vput(newvp);
		if (error == 0)
			goto out;
		printf("ntfs_ntvattrget: ATTRLIST ERROR.\n");
		break;
	}
	error = ENOENT;

	DPRINTF("ntfs_ntvattrget: UNEXISTED ATTRIBUTE: ino: %u, type: 0x%x, "
	    "name: %.*s, vcn: %llu\n", ip->i_number, type,
	    (unsigned int)namelen, name, vcn);
out:
	free(alpool, M_TEMP, 0);
	return (error);
}

/*
 * Read ntnode from disk, make ntvattr list.
 *
 * ntnode should be locked
 */
int
ntfs_loadntnode(struct ntfsmount *ntmp, struct ntnode *ip)
{
	struct ntnode	*oip;
	struct ntvattr	*vap;
	struct filerec	*mfrp;
	struct attr	*ap;
	daddr_t		bn;
 	int		error,off;
 
 	DPRINTF("ntfs_loadntnode: loading ino: %u\n", ip->i_number);
 
	KASSERT((ip->i_flag & IN_LOADED) == 0);

	if (ntmp->ntm_ntnodes >= LOADED_NTNODE_HI) {
		oip = TAILQ_LAST(&ntmp->ntm_ntnodeq, ntnodeq);
		TAILQ_REMOVE(&ntmp->ntm_ntnodeq, oip, i_loaded);
		ntmp->ntm_ntnodes--;

		DPRINTF("ntfs_loadntnode: unloading ino: %u\n", oip->i_number);

		KASSERT((oip->i_flag & IN_LOADED));
		oip->i_flag &= ~IN_LOADED;
		while ((vap = LIST_FIRST(&oip->i_valist)) != NULL) {
			LIST_REMOVE(vap, va_list);
			ntfs_freentvattr(vap);
		}
	}

 	mfrp = malloc(ntfs_bntob(ntmp->ntm_bpmftrec), M_TEMP, M_WAITOK);
 
	if (ip->i_number < NTFS_SYSNODESNUM) {
		struct buf     *bp;

		DPRINTF("ntfs_loadntnode: read system node\n");

		bn = ntfs_cntobn(ntmp->ntm_mftcn) +
			ntmp->ntm_bpmftrec * ip->i_number;

		error = bread(ntmp->ntm_devvp, bn,
		    ntfs_bntob(ntmp->ntm_bpmftrec), &bp);
		if (error) {
			printf("ntfs_loadntnode: BREAD FAILED\n");
			brelse(bp);
			goto out;
		}
		memcpy(mfrp, bp->b_data, ntfs_bntob(ntmp->ntm_bpmftrec));
		brelse(bp);
	} else {
		struct vnode   *vp;

		vp = ntmp->ntm_sysvn[NTFS_MFTINO];
		error = ntfs_readattr(ntmp, VTONT(vp), NTFS_A_DATA, NULL,
			       ip->i_number * ntfs_bntob(ntmp->ntm_bpmftrec),
			       ntfs_bntob(ntmp->ntm_bpmftrec), mfrp, NULL);
		if (error) {
			printf("ntfs_loadntnode: ntfs_readattr failed\n");
			goto out;
		}
	}

	/* Check if magic and fixups are correct */
	error = ntfs_procfixups(ntmp, NTFS_FILEMAGIC, (caddr_t)mfrp,
				ntfs_bntob(ntmp->ntm_bpmftrec));
	if (error) {
		printf("ntfs_loadntnode: BAD MFT RECORD %d\n",
		       (u_int32_t) ip->i_number);
		goto out;
	}

	DPRINTF("ntfs_loadntnode: load attrs for ino: %u\n", ip->i_number);
	off = mfrp->fr_attroff;
	ap = (struct attr *) ((caddr_t)mfrp + off);

	LIST_INIT(&ip->i_valist);
	
	while (ap->a_hdr.a_type != -1) {
		error = ntfs_attrtontvattr(ntmp, &vap, ap);
		if (error)
			break;
		vap->va_ip = ip;

		LIST_INSERT_HEAD(&ip->i_valist, vap, va_list);

		off += ap->a_hdr.reclen;
		ap = (struct attr *) ((caddr_t)mfrp + off);
	}
	if (error) {
		printf("ntfs_loadntnode: failed to load attr ino: %d\n",
		       ip->i_number);
		goto out;
	}

	ip->i_mainrec = mfrp->fr_mainrec;
	ip->i_nlink = mfrp->fr_nlink;
	ip->i_frflag = mfrp->fr_flags;

	ip->i_flag |= IN_LOADED;

	/* Add to loaded list. */
	TAILQ_INSERT_HEAD(&ntmp->ntm_ntnodeq, ip, i_loaded);
	ntmp->ntm_ntnodes++;

out:
	free(mfrp, M_TEMP, 0);
	return (error);
}

/*
 * Routine locks ntnode and increase usecount, just opposite of
 * ntfs_ntput().
 */
int
ntfs_ntget(struct ntnode *ip, struct proc *p)
{
	DPRINTF("ntfs_ntget: get ntnode %u: %p, usecount: %d\n",
	    ip->i_number, ip, ip->i_usecount);

	ip->i_usecount++;

	rw_enter_write(&ip->i_lock);

	return 0;
}

/*
 * Routine search ntnode in hash, if found: lock, inc usecount and return.
 * If not in hash allocate structure for ntnode, prefill it, lock,
 * inc count and return.
 *
 * ntnode returned locked
 */
int
ntfs_ntlookup(struct ntfsmount *ntmp, ntfsino_t ino, struct ntnode **ipp,
    struct proc *p)
{
	struct ntnode  *ip;

	DPRINTF("ntfs_ntlookup: looking for ntnode %u\n", ino);

	do {
		if ((ip = ntfs_nthashlookup(ntmp->ntm_dev, ino)) != NULL) {
			ntfs_ntget(ip, p);
			DPRINTF("ntfs_ntlookup: ntnode %u: %p, usecount: %d\n",
			    ino, ip, ip->i_usecount);
			*ipp = ip;
			return (0);
		}
	} while (rw_enter(&ntfs_hashlock, RW_WRITE | RW_SLEEPFAIL));

	ip = malloc(sizeof(*ip), M_NTFSNTNODE, M_WAITOK | M_ZERO);
	DDPRINTF("ntfs_ntlookup: allocating ntnode: %u: %p\n", ino, ip);

	/* Generic initialization */
	ip->i_devvp = ntmp->ntm_devvp;
	ip->i_dev = ntmp->ntm_dev;
	ip->i_number = ino;
	ip->i_mp = ntmp;

	LIST_INIT(&ip->i_fnlist);
	vref(ip->i_devvp);

	/* init lock and lock the newborn ntnode */
	rw_init(&ip->i_lock, "ntnode");
	ntfs_ntget(ip, p);

	ntfs_nthashins(ip);

	rw_exit(&ntfs_hashlock);

	*ipp = ip;

	DPRINTF("ntfs_ntlookup: ntnode %u: %p, usecount: %d\n",
	    ino, ip, ip->i_usecount);

	return (0);
}

/*
 * Decrement usecount of ntnode and unlock it, if usecount reach zero,
 * deallocate ntnode.
 *
 * ntnode should be locked on entry, and unlocked on return.
 */
void
ntfs_ntput(struct ntnode *ip, struct proc *p)
{
	struct ntfsmount *ntmp = ip->i_mp;
	struct ntvattr *vap;

	DPRINTF("ntfs_ntput: rele ntnode %u: %p, usecount: %d\n",
	    ip->i_number, ip, ip->i_usecount);

	ip->i_usecount--;

#ifdef DIAGNOSTIC
	if (ip->i_usecount < 0) {
		panic("ntfs_ntput: ino: %d usecount: %d ",
		      ip->i_number,ip->i_usecount);
	}
#endif

	if (ip->i_usecount > 0) {
		rw_exit_write(&ip->i_lock);
		return;
	}

	DPRINTF("ntfs_ntput: deallocating ntnode: %u\n", ip->i_number);

	if (LIST_FIRST(&ip->i_fnlist))
		panic("ntfs_ntput: ntnode has fnodes");

	ntfs_nthashrem(ip);

	/* Remove from loaded list. */
	if (ip->i_flag & IN_LOADED) {
		TAILQ_REMOVE(&ntmp->ntm_ntnodeq, ip, i_loaded);
		ntmp->ntm_ntnodes--;
	}

	while ((vap = LIST_FIRST(&ip->i_valist)) != NULL) {
		LIST_REMOVE(vap, va_list);
		ntfs_freentvattr(vap);
	}

	vrele(ip->i_devvp);
	free(ip, M_NTFSNTNODE, 0);
}

/*
 * increment usecount of ntnode 
 */
void
ntfs_ntref(struct ntnode *ip)
{
	ip->i_usecount++;

	DPRINTF("ntfs_ntref: ino %u, usecount: %d\n",
	    ip->i_number, ip->i_usecount);
}

/*
 * Decrement usecount of ntnode.
 */
void
ntfs_ntrele(struct ntnode *ip)
{
	DPRINTF("ntfs_ntrele: rele ntnode %u: %p, usecount: %d\n",
	    ip->i_number, ip, ip->i_usecount);

	ip->i_usecount--;

	if (ip->i_usecount < 0)
		panic("ntfs_ntrele: ino: %d usecount: %d ",
		      ip->i_number,ip->i_usecount);
}

/*
 * Deallocate all memory allocated for ntvattr
 */
void
ntfs_freentvattr(struct ntvattr *vap)
{
	if (vap->va_flag & NTFS_AF_INRUN) {
		if (vap->va_vruncn)
			free(vap->va_vruncn, M_NTFSRUN, 0);
		if (vap->va_vruncl)
			free(vap->va_vruncl, M_NTFSRUN, 0);
	} else {
		if (vap->va_datap)
			free(vap->va_datap, M_NTFSRDATA, 0);
	}
	free(vap, M_NTFSNTVATTR, 0);
}

/*
 * Convert disk image of attribute into ntvattr structure,
 * runs are expanded also.
 */
int
ntfs_attrtontvattr(struct ntfsmount *ntmp, struct ntvattr **rvapp,
    struct attr *rap)
{
	int             error, i;
	struct ntvattr *vap;

	error = 0;
	*rvapp = NULL;

	vap = malloc(sizeof(*vap), M_NTFSNTVATTR, M_WAITOK | M_ZERO);
	vap->va_ip = NULL;
	vap->va_flag = rap->a_hdr.a_flag;
	vap->va_type = rap->a_hdr.a_type;
	vap->va_compression = rap->a_hdr.a_compression;
	vap->va_index = rap->a_hdr.a_index;

	DDPRINTF("type: 0x%x, index: %u", vap->va_type, vap->va_index);

	vap->va_namelen = rap->a_hdr.a_namelen;
	if (rap->a_hdr.a_namelen) {
		wchar *unp = (wchar *) ((caddr_t) rap + rap->a_hdr.a_nameoff);
		DDPRINTF(", name:[");
		for (i = 0; i < vap->va_namelen; i++) {
			vap->va_name[i] = unp[i];
			DDPRINTF("%c", vap->va_name[i]);
		}
		DDPRINTF("]");
	}
	if (vap->va_flag & NTFS_AF_INRUN) {
		DDPRINTF(", nonres.");
		vap->va_datalen = rap->a_nr.a_datalen;
		vap->va_allocated = rap->a_nr.a_allocated;
		vap->va_vcnstart = rap->a_nr.a_vcnstart;
		vap->va_vcnend = rap->a_nr.a_vcnend;
		vap->va_compressalg = rap->a_nr.a_compressalg;
		error = ntfs_runtovrun(&(vap->va_vruncn), &(vap->va_vruncl),
				       &(vap->va_vruncnt),
				       (caddr_t) rap + rap->a_nr.a_dataoff);
	} else {
		vap->va_compressalg = 0;
		DDPRINTF(", res.");
		vap->va_datalen = rap->a_r.a_datalen;
		vap->va_allocated = rap->a_r.a_datalen;
		vap->va_vcnstart = 0;
		vap->va_vcnend = ntfs_btocn(vap->va_allocated);
		vap->va_datap = malloc(vap->va_datalen, M_NTFSRDATA, M_WAITOK);
		memcpy(vap->va_datap, (caddr_t) rap + rap->a_r.a_dataoff,
		       rap->a_r.a_datalen);
	}
	DDPRINTF(", len: %llu", vap->va_datalen);

	if (error)
		free(vap, M_NTFSNTVATTR, 0);
	else
		*rvapp = vap;

	DDPRINTF("\n");

	return (error);
}

/*
 * Expand run into more utilizable and more memory eating format.
 */
int
ntfs_runtovrun(cn_t **rcnp, cn_t **rclp, u_long *rcntp, u_int8_t *run)
{
	u_int32_t       off;
	u_int32_t       sz, i;
	cn_t           *cn;
	cn_t           *cl;
	u_long		cnt;
	cn_t		prev;
	cn_t		tmp;

	off = 0;
	cnt = 0;
	while (run[off]) {
		off += (run[off] & 0xF) + ((run[off] >> 4) & 0xF) + 1;
		cnt++;
	}
	cn = mallocarray(cnt, sizeof(cn_t), M_NTFSRUN, M_WAITOK);
	cl = mallocarray(cnt, sizeof(cn_t), M_NTFSRUN, M_WAITOK);

	off = 0;
	cnt = 0;
	prev = 0;
	while (run[off]) {

		sz = run[off++];
		cl[cnt] = 0;

		for (i = 0; i < (sz & 0xF); i++)
			cl[cnt] += (u_int32_t) run[off++] << (i << 3);

		sz >>= 4;
		if (run[off + sz - 1] & 0x80) {
			tmp = ((u_int64_t) - 1) << (sz << 3);
			for (i = 0; i < sz; i++)
				tmp |= (u_int64_t) run[off++] << (i << 3);
		} else {
			tmp = 0;
			for (i = 0; i < sz; i++)
				tmp |= (u_int64_t) run[off++] << (i << 3);
		}
		if (tmp)
			prev = cn[cnt] = prev + tmp;
		else
			cn[cnt] = tmp;

		cnt++;
	}
	*rcnp = cn;
	*rclp = cl;
	*rcntp = cnt;
	return (0);
}

/*
 * Compare unicode and ascii string case insens.
 */
int
ntfs_uastricmp(struct ntfsmount *ntmp, const wchar *ustr, size_t ustrlen,
    const char *astr, size_t astrlen)
{
	size_t  i;
	int             res;
	const char *astrend = astr + astrlen;

	for (i = 0; i < ustrlen && astr < astrend; i++) {
		res = (*ntmp->ntm_wcmp)(NTFS_TOUPPER(ustr[i]),
				NTFS_TOUPPER((*ntmp->ntm_wget)(&astr)) );
		if (res)
			return res;
	}

	if (i == ustrlen && astr == astrend)
		return 0;
	else if (i == ustrlen)
		return -1;
	else
		return 1;
}

/*
 * Compare unicode and ascii string case sens.
 */
int
ntfs_uastrcmp(struct ntfsmount *ntmp, const wchar *ustr, size_t ustrlen,
    const char *astr, size_t astrlen)
{
	size_t             i;
	int             res;
	const char *astrend = astr + astrlen;

	for (i = 0; (i < ustrlen) && (astr < astrend); i++) {
		res = (*ntmp->ntm_wcmp)(ustr[i], (*ntmp->ntm_wget)(&astr));
		if (res)
			return res;
	}

	if (i == ustrlen && astr == astrend)
		return 0;
	else if (i == ustrlen)
		return -1;
	else
		return 1;
}

/* 
 * Search fnode in ntnode, if not found allocate and preinitialize.
 *
 * ntnode should be locked on entry.
 */
int
ntfs_fget(struct ntfsmount *ntmp, struct ntnode *ip, int attrtype,
    char *attrname, struct fnode **fpp)
{
	struct fnode *fp;

	DPRINTF("ntfs_fget: ino: %u, attrtype: 0x%x, attrname: %s\n",
	    ip->i_number, attrtype, attrname ? attrname : "");
	*fpp = NULL;
	LIST_FOREACH(fp, &ip->i_fnlist, f_fnlist) {
		DPRINTF("ntfs_fget: fnode: attrtype: %u, attrname: %s\n",
		    fp->f_attrtype, fp->f_attrname ? fp->f_attrname : "");

		if ((attrtype == fp->f_attrtype) && 
		    ((!attrname && !fp->f_attrname) ||
		     (attrname && fp->f_attrname &&
		      !strcmp(attrname,fp->f_attrname)))){
			DPRINTF("ntfs_fget: found existed: %p\n", fp);
			*fpp = fp;
		}
	}

	if (*fpp)
		return (0);

	fp = malloc(sizeof(*fp), M_NTFSFNODE, M_WAITOK | M_ZERO);
	DPRINTF("ntfs_fget: allocating fnode: %p\n", fp);

	fp->f_ip = ip;
	fp->f_attrname = attrname;
	if (fp->f_attrname) fp->f_flag |= FN_AATTRNAME;
	fp->f_attrtype = attrtype;

	ntfs_ntref(ip);

	LIST_INSERT_HEAD(&ip->i_fnlist, fp, f_fnlist);

	*fpp = fp;

	return (0);
}

/*
 * Deallocate fnode, remove it from ntnode's fnode list.
 *
 * ntnode should be locked.
 */
void
ntfs_frele(struct fnode *fp)
{
	struct ntnode *ip = FTONT(fp);

	DPRINTF("ntfs_frele: fnode: %p for %u: %p\n", fp, ip->i_number, ip);

	DPRINTF("ntfs_frele: deallocating fnode\n");
	LIST_REMOVE(fp,f_fnlist);
	if (fp->f_flag & FN_AATTRNAME)
		free(fp->f_attrname, M_TEMP, 0);
	if (fp->f_dirblbuf)
		free(fp->f_dirblbuf, M_NTFSDIR, 0);
	free(fp, M_NTFSFNODE, 0);
	ntfs_ntrele(ip);
}

/*
 * Lookup attribute name in format: [[:$ATTR_TYPE]:$ATTR_NAME], 
 * $ATTR_TYPE is searched in attrdefs read from $AttrDefs.
 * If $ATTR_TYPE not specified, ATTR_A_DATA assumed.
 */
int
ntfs_ntlookupattr(struct ntfsmount *ntmp, const char *name, int namelen,
    int *attrtype, char **attrname)
{
	const char *sys;
	size_t syslen, i;
	struct ntvattrdef *adp;

	if (namelen == 0)
		return (0);

	if (name[0] == '$') {
		sys = name;
		for (syslen = 0; syslen < namelen; syslen++) {
			if(sys[syslen] == ':') {
				name++;
				namelen--;
				break;
			}
		}
		name += syslen;
		namelen -= syslen;

		adp = ntmp->ntm_ad;
		for (i = 0; i < ntmp->ntm_adnum; i++, adp++){
			if (syslen != adp->ad_namelen || 
			    strncmp(sys, adp->ad_name, syslen) != 0)
				continue;

			*attrtype = adp->ad_type;
			goto out;
		}
		return (ENOENT);
	}

    out:
	if (namelen) {
		*attrname = malloc(namelen + 1, M_TEMP, M_WAITOK);
		memcpy(*attrname, name, namelen);
		(*attrname)[namelen] = '\0';
		*attrtype = NTFS_A_DATA;
	}

	return (0);
}

/*
 * Lookup specified node for filename, matching cnp, return fnode filled.
 */
int
ntfs_ntlookupfile(struct ntfsmount *ntmp, struct vnode *vp,
    struct componentname *cnp, struct vnode **vpp, struct proc *p)
{
	struct fnode   *fp = VTOF(vp);
	struct ntnode  *ip = FTONT(fp);
	struct ntvattr *vap = NULL;	/* Root attribute */
	cn_t            cn = 0;	/* VCN in current attribute */
	caddr_t         rdbuf = NULL;	/* Buffer to read directory's blocks */
	u_int32_t       blsize;
	u_int32_t       rdsize;	/* Length of data to read from current block */
	struct attr_indexentry *iep;
	int             error, res, anamelen, fnamelen;
	const char     *fname,*aname;
	u_int32_t       aoff;
	int attrtype = NTFS_A_DATA;
	char *attrname = NULL;
	struct fnode   *nfp;
	struct vnode   *nvp;
	enum vtype	f_type;
	int fullscan = 0;
	struct ntfs_lookup_ctx *lookup_ctx = NULL, *tctx;

	error = ntfs_ntget(ip, p);
	if (error)
		return (error);

	error = ntfs_ntvattrget(ntmp, ip, NTFS_A_INDXROOT, "$I30", 0, &vap);
	if (error || (vap->va_flag & NTFS_AF_INRUN)) {
		error = ENOTDIR;
		goto fail;
	}

	/*
	 * Divide file name into: foofilefoofilefoofile[:attrspec]
	 * Store like this:       fname:fnamelen       [aname:anamelen]
	 */
	fname = cnp->cn_nameptr;
	aname = NULL;
	anamelen = 0;
	for (fnamelen = 0; fnamelen < cnp->cn_namelen; fnamelen++)
		if(fname[fnamelen] == ':') {
			aname = fname + fnamelen + 1;
			anamelen = cnp->cn_namelen - fnamelen - 1;
			DPRINTF("ntfs_ntlookupfile: %s (%d), attr: %s (%d)\n",
			    fname, fnamelen, aname, anamelen);
			break;
		}

	blsize = vap->va_a_iroot->ir_size;
	DPRINTF("ntfs_ntlookupfile: blksz: %u\n", blsize);

	rdbuf = malloc(blsize, M_TEMP, M_WAITOK);

    loop:
	rdsize = vap->va_datalen;
	DPRINTF("ntfs_ntlookupfile: rdsz: %u\n", rdsize);

	error = ntfs_readattr(ntmp, ip, NTFS_A_INDXROOT, "$I30",
			       0, rdsize, rdbuf, NULL);
	if (error)
		goto fail;

	aoff = sizeof(struct attr_indexroot);

	do {
		iep = (struct attr_indexentry *) (rdbuf + aoff);

		for (; !(iep->ie_flag & NTFS_IEFLAG_LAST) && (rdsize > aoff);
			aoff += iep->reclen,
			iep = (struct attr_indexentry *) (rdbuf + aoff))
		{
			DDPRINTF("scan: %u, %u\n", iep->ie_number,
			    iep->ie_fnametype);
 
			/* check the name - the case-insensitive check
			 * has to come first, to break from this for loop
			 * if needed, so we can dive correctly */
			res = ntfs_uastricmp(ntmp, iep->ie_fname,
				iep->ie_fnamelen, fname, fnamelen);
			if (!fullscan) {
				if (res > 0) break;
				if (res < 0) continue;
			}

			if (iep->ie_fnametype == 0 ||
			    !(ntmp->ntm_flag & NTFS_MFLAG_CASEINS))
			{
				res = ntfs_uastrcmp(ntmp, iep->ie_fname,
					iep->ie_fnamelen, fname, fnamelen);
				if (res != 0 && !fullscan) continue;
			}

			/* if we perform full scan, the file does not match
			 * and this is subnode, dive */
			if (fullscan && res != 0) {
			    if (iep->ie_flag & NTFS_IEFLAG_SUBNODE) {
				tctx = malloc(sizeof(struct ntfs_lookup_ctx),
					M_TEMP, M_WAITOK);
				tctx->aoff	= aoff + iep->reclen;
				tctx->rdsize	= rdsize;
				tctx->cn	= cn;
				tctx->prev	= lookup_ctx;
				lookup_ctx = tctx;
				break;
			    } else
				continue;
			}

			if (aname) {
				error = ntfs_ntlookupattr(ntmp,
					aname, anamelen,
					&attrtype, &attrname);
				if (error)
					goto fail;
			}

			/* Check if we've found ourselves */
			if ((iep->ie_number == ip->i_number) &&
			    (attrtype == fp->f_attrtype) &&
			    ((!attrname && !fp->f_attrname) ||
			     (attrname && fp->f_attrname &&
			      !strcmp(attrname, fp->f_attrname))))
			{
				vref(vp);
				*vpp = vp;
				error = 0;
				goto fail;
			}

			/* free the buffer returned by ntfs_ntlookupattr() */
			if (attrname) {
				free(attrname, M_TEMP, 0);
				attrname = NULL;
			}

			/* vget node, but don't load it */
			error = ntfs_vgetex(ntmp->ntm_mountp,
				   iep->ie_number, attrtype, attrname,
				   LK_EXCLUSIVE, VG_DONTLOADIN | VG_DONTVALIDFN,
				   curproc, &nvp);
			if (error)
				goto fail;

			nfp = VTOF(nvp);

			if (nfp->f_flag & FN_VALID) {
				*vpp = nvp;
				goto fail;
			}

			nfp->f_fflag = iep->ie_fflag;
			nfp->f_pnumber = iep->ie_fpnumber;
			nfp->f_times = iep->ie_ftimes;

			if((nfp->f_fflag & NTFS_FFLAG_DIR) &&
			   (nfp->f_attrtype == NTFS_A_DATA) &&
			   (nfp->f_attrname == NULL))
				f_type = VDIR;	
			else
				f_type = VREG;	

			nvp->v_type = f_type;

			if ((nfp->f_attrtype == NTFS_A_DATA) &&
			    (nfp->f_attrname == NULL))
			{
				/* Opening default attribute */
				nfp->f_size = iep->ie_fsize;
				nfp->f_allocated = iep->ie_fallocated;
				nfp->f_flag |= FN_PRELOADED;
			} else {
				error = ntfs_filesize(ntmp, nfp,
					    &nfp->f_size, &nfp->f_allocated);
				if (error) {
					vput(nvp);
					goto fail;
				}
			}

			nfp->f_flag &= ~FN_VALID;
			*vpp = nvp;
			goto fail;
		}

		/* Dive if possible */
		if (iep->ie_flag & NTFS_IEFLAG_SUBNODE) {
			DPRINTF("ntfs_ntlookupfile: diving\n");

			cn = *(cn_t *) (rdbuf + aoff +
					iep->reclen - sizeof(cn_t));
			rdsize = blsize;

			error = ntfs_readattr(ntmp, ip, NTFS_A_INDX, "$I30",
					ntfs_cntob(cn), rdsize, rdbuf, NULL);
			if (error)
				goto fail;

			error = ntfs_procfixups(ntmp, NTFS_INDXMAGIC,
						rdbuf, rdsize);
			if (error)
				goto fail;

			aoff = (((struct attr_indexalloc *) rdbuf)->ia_hdrsize +
				0x18);
		} else if (fullscan && lookup_ctx) {
			cn = lookup_ctx->cn;
			aoff = lookup_ctx->aoff;
			rdsize = lookup_ctx->rdsize;

			error = ntfs_readattr(ntmp, ip,
				(cn == 0) ? NTFS_A_INDXROOT : NTFS_A_INDX,
				"$I30", ntfs_cntob(cn), rdsize, rdbuf, NULL);
			if (error)
				goto fail;
			
			if (cn != 0) {
				error = ntfs_procfixups(ntmp, NTFS_INDXMAGIC,
						rdbuf, rdsize);
				if (error)
					goto fail;
			}

			tctx = lookup_ctx;
			lookup_ctx = lookup_ctx->prev;
			free(tctx, M_TEMP, 0);
		} else {
			DPRINTF("ntfs_ntlookupfile: nowhere to dive :-(\n");
			error = ENOENT;
			break;
		}
	} while (1);

	if (error == ENOENT) {
		/* perform full scan if no entry was found */
		if (!fullscan) {
			fullscan = 1;
			cn = 0;		/* need zero, used by lookup_ctx */

			DDPRINTF("ntfs_ntlookupfile: fullscan performed for: %.*s\n",
			    (unsigned int)fnamelen, fname);
			goto loop;
		}

		if ((cnp->cn_flags & ISLASTCN) &&
		    (cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME))
			error = EJUSTRETURN;
	}

	DPRINTF("finish\n");

fail:
	if (vap)
		ntfs_ntvattrrele(vap);
	if (rdbuf)
		free(rdbuf, M_TEMP, 0);
	if (attrname)
		free(attrname, M_TEMP, 0);
	if (lookup_ctx) {
		while(lookup_ctx) {
			tctx = lookup_ctx;
			lookup_ctx = lookup_ctx->prev;
			free(tctx, M_TEMP, 0);
		}
	}
	ntfs_ntput(ip, p);
	return (error);
}

/*
 * Check if name type is permitted to show.
 */
int
ntfs_isnamepermitted(struct ntfsmount *ntmp, struct attr_indexentry *iep)
{
	if (ntmp->ntm_flag & NTFS_MFLAG_ALLNAMES)
		return 1;

	switch (iep->ie_fnametype) {
	case 2:
		DDPRINTF("ntfs_isnamepermitted: skipped DOS name\n");
		return 0;
	case 0: case 1: case 3:
		return 1;
	default:
		printf("ntfs_isnamepermitted: " \
		       "WARNING! Unknown file name type: %d\n",
		       iep->ie_fnametype);
		break;
	}
	return 0;
}

/*
 * Read ntfs dir like stream of attr_indexentry, not like btree of them.
 * This is done by scanning $BITMAP:$I30 for busy clusters and reading them.
 * Of course $INDEX_ROOT:$I30 is read before. Last read values are stored in
 * fnode, so we can skip toward record number num almost immediately.
 * Anyway this is rather slow routine. The problem is that we don't know
 * how many records are there in $INDEX_ALLOCATION:$I30 block.
 */
int
ntfs_ntreaddir(struct ntfsmount *ntmp, struct fnode *fp, u_int32_t num,
    struct attr_indexentry **riepp, struct proc *p)
{
	struct ntnode  *ip = FTONT(fp);
	struct ntvattr *vap = NULL;	/* IndexRoot attribute */
	struct ntvattr *bmvap = NULL;	/* BitMap attribute */
	struct ntvattr *iavap = NULL;	/* IndexAllocation attribute */
	caddr_t         rdbuf;		/* Buffer to read directory's blocks  */
	u_int8_t       *bmp = NULL;	/* Bitmap */
	u_int32_t       blsize;		/* Index allocation size (2048) */
	u_int32_t       rdsize;		/* Length of data to read */
	u_int32_t       attrnum;	/* Current attribute type */
	u_int32_t       cpbl = 1;	/* Clusters per directory block */
	u_int32_t       blnum;
	struct attr_indexentry *iep;
	int             error = ENOENT;
	u_int32_t       aoff, cnum;

	DPRINTF("ntfs_ntreaddir: read ino: %u, num: %u\n", ip->i_number, num);
	error = ntfs_ntget(ip, p);
	if (error)
		return (error);

	error = ntfs_ntvattrget(ntmp, ip, NTFS_A_INDXROOT, "$I30", 0, &vap);
	if (error) {
		error = ENOTDIR;
		goto fail;
	}

	if (fp->f_dirblbuf == NULL) {
		fp->f_dirblsz = vap->va_a_iroot->ir_size;
		fp->f_dirblbuf = malloc(MAX(vap->va_datalen,fp->f_dirblsz),
		    M_NTFSDIR, M_WAITOK);
	}

	blsize = fp->f_dirblsz;
	rdbuf = fp->f_dirblbuf;

	DPRINTF("ntfs_ntreaddir: rdbuf: %p, blsize: %u\n", rdbuf, blsize);

	if (vap->va_a_iroot->ir_flag & NTFS_IRFLAG_INDXALLOC) {
		error = ntfs_ntvattrget(ntmp, ip, NTFS_A_INDXBITMAP, "$I30",
					0, &bmvap);
		if (error) {
			error = ENOTDIR;
			goto fail;
		}
		bmp = malloc(bmvap->va_datalen, M_TEMP, M_WAITOK);
		error = ntfs_readattr(ntmp, ip, NTFS_A_INDXBITMAP, "$I30", 0,
				       bmvap->va_datalen, bmp, NULL);
		if (error)
			goto fail;

		error = ntfs_ntvattrget(ntmp, ip, NTFS_A_INDX, "$I30",
					0, &iavap);
		if (error) {
			error = ENOTDIR;
			goto fail;
		}
		cpbl = ntfs_btocn(blsize + ntfs_cntob(1) - 1);
		DPRINTF("ntfs_ntreaddir: indexalloc: %llu, cpbl: %u\n",
		    iavap->va_datalen, cpbl);
	} else {
		DPRINTF("ntfs_ntreadidir: w/o BitMap and IndexAllocation\n");
		iavap = bmvap = NULL;
		bmp = NULL;
	}

	/* Try use previous values */
	if ((fp->f_lastdnum < num) && (fp->f_lastdnum != 0)) {
		attrnum = fp->f_lastdattr;
		aoff = fp->f_lastdoff;
		blnum = fp->f_lastdblnum;
		cnum = fp->f_lastdnum;
	} else {
		attrnum = NTFS_A_INDXROOT;
		aoff = sizeof(struct attr_indexroot);
		blnum = 0;
		cnum = 0;
	}

	do {
		DPRINTF("ntfs_ntreaddir: scan: 0x%x, %u, %u, %u, %u\n",
		    attrnum, blnum, cnum, num, aoff);
		rdsize = (attrnum == NTFS_A_INDXROOT) ? vap->va_datalen : blsize;
		error = ntfs_readattr(ntmp, ip, attrnum, "$I30",
				ntfs_cntob(blnum * cpbl), rdsize, rdbuf, NULL);
		if (error)
			goto fail;

		if (attrnum == NTFS_A_INDX) {
			error = ntfs_procfixups(ntmp, NTFS_INDXMAGIC,
						rdbuf, rdsize);
			if (error)
				goto fail;
		}
		if (aoff == 0)
			aoff = (attrnum == NTFS_A_INDX) ?
				(0x18 + ((struct attr_indexalloc *) rdbuf)->ia_hdrsize) :
				sizeof(struct attr_indexroot);

		iep = (struct attr_indexentry *) (rdbuf + aoff);
		for (; !(iep->ie_flag & NTFS_IEFLAG_LAST) && (rdsize > aoff);
			aoff += iep->reclen,
			iep = (struct attr_indexentry *) (rdbuf + aoff))
		{
			if (!ntfs_isnamepermitted(ntmp, iep)) continue;

			if (cnum >= num) {
				fp->f_lastdnum = cnum;
				fp->f_lastdoff = aoff;
				fp->f_lastdblnum = blnum;
				fp->f_lastdattr = attrnum;

				*riepp = iep;

				error = 0;
				goto fail;
			}
			cnum++;
		}

		if (iavap) {
			if (attrnum == NTFS_A_INDXROOT)
				blnum = 0;
			else
				blnum++;

			while (ntfs_cntob(blnum * cpbl) < iavap->va_datalen) {
				if (bmp[blnum >> 3] & (1 << (blnum & 7)))
					break;
				blnum++;
			}

			attrnum = NTFS_A_INDX;
			aoff = 0;
			if (ntfs_cntob(blnum * cpbl) >= iavap->va_datalen)
				break;
			DPRINTF("ntfs_ntreaddir: blnum: %u\n", blnum);
		}
	} while (iavap);

	*riepp = NULL;
	fp->f_lastdnum = 0;

fail:
	if (vap)
		ntfs_ntvattrrele(vap);
	if (bmvap)
		ntfs_ntvattrrele(bmvap);
	if (iavap)
		ntfs_ntvattrrele(iavap);
	if (bmp)
		free(bmp, M_TEMP, 0);
	ntfs_ntput(ip, p);

	return (error);
}

/*
 * Convert NTFS times that are in 100 ns units and begins from
 * 1601 Jan 1 into unix times.
 */
struct timespec
ntfs_nttimetounix(u_int64_t nt)
{
	struct timespec t;

	/* WindowNT times are in 100 ns and from 1601 Jan 1 */
	t.tv_nsec = (nt % (1000 * 1000 * 10)) * 100;
	t.tv_sec = nt / (1000 * 1000 * 10) -
		369LL * 365LL * 24LL * 60LL * 60LL -
		89LL * 1LL * 24LL * 60LL * 60LL;
	return (t);
}

/*
 * Get file sizes from corresponding attribute. 
 * 
 * ntnode under fnode should be locked.
 */
int
ntfs_filesize(struct ntfsmount *ntmp, struct fnode *fp, u_int64_t *size,
    u_int64_t *bytes)
{
	struct ntvattr *vap;
	struct ntnode *ip = FTONT(fp);
	u_int64_t       sz, bn;
	int             error;

	DPRINTF("ntfs_filesize: ino: %u\n", ip->i_number);

	error = ntfs_ntvattrget(ntmp, ip,
		fp->f_attrtype, fp->f_attrname, 0, &vap);
	if (error)
		return (error);

	bn = vap->va_allocated;
	sz = vap->va_datalen;

	DPRINTF("ntfs_filesize: %llu bytes (%llu bytes allocated)\n", sz, bn);

	if (size)
		*size = sz;
	if (bytes)
		*bytes = bn;

	ntfs_ntvattrrele(vap);

	return (0);
}

/*
 * This is one of the read routines.
 *
 * ntnode should be locked.
 */
int
ntfs_readntvattr_plain(struct ntfsmount *ntmp, struct ntnode *ip,
    struct ntvattr *vap, off_t roff, size_t rsize, void *rdata, size_t *initp,
    struct uio *uio)
{
	int             error = 0;
	off_t		off;

	*initp = 0;
	if (vap->va_flag & NTFS_AF_INRUN) {
		int             cnt;
		cn_t            ccn, ccl, cn, cl;
		caddr_t         data = rdata;
		struct buf     *bp;
		size_t          left, tocopy;

		DDPRINTF("ntfs_readntvattr_plain: data in run: %lu chains\n",
		    vap->va_vruncnt);

		off = roff;
		left = rsize;
		ccl = 0;
		ccn = 0;
		cnt = 0;
		while (left && (cnt < vap->va_vruncnt)) {
			ccn = vap->va_vruncn[cnt];
			ccl = vap->va_vruncl[cnt];

			DDPRINTF("ntfs_readntvattr_plain: left %zu, "
			    "cn: 0x%llx, cl: %llu, off: %lld\n",
			    left, ccn, ccl, off);

			if (ntfs_cntob(ccl) < off) {
				off -= ntfs_cntob(ccl);
				cnt++;
				continue;
			}
			if (ccn || ip->i_number == NTFS_BOOTINO) {
				ccl -= ntfs_btocn(off);
				cn = ccn + ntfs_btocn(off);
				off = ntfs_btocnoff(off);

				while (left && ccl) {
					/*
					 * Always read single clusters at a
					 * time - we need to avoid reading
					 * differently-sized blocks at the
					 * same disk offsets to avoid
					 * confusing the buffer cache.
					 */
					tocopy = MIN(left,
					    ntfs_cntob(1) - off);
					cl = ntfs_btocl(tocopy + off);
					KASSERT(cl == 1 &&
					    tocopy <= ntfs_cntob(1));

					DDPRINTF("ntfs_readntvattr_plain: "
					    "read: cn: 0x%llx cl: %llu, "
					    "off: %lld, len: %zu, "
					    "left: %zu\n",
					    cn, cl, off, tocopy, left);
					error = bread(ntmp->ntm_devvp,
						      ntfs_cntobn(cn),
						      ntfs_cntob(cl),
						      &bp);
					if (error) {
						brelse(bp);
						return (error);
					}
					if (uio) {
						error = uiomove(bp->b_data + off,
							tocopy, uio);
						if (error != 0)
							break;
					} else {
						memcpy(data, bp->b_data + off,
							tocopy);
					}
					brelse(bp);
					data = data + tocopy;
					*initp += tocopy;
					off = 0;
					left -= tocopy;
					cn += cl;
					ccl -= cl;
				}
			} else {
				tocopy = MIN(left, ntfs_cntob(ccl) - off);
				DDPRINTF("ntfs_readntvattr_plain: hole: "
				    "ccn: 0x%llx ccl: %llu, off: %lld, "
				    "len: %zu, left: %zu\n",
				    ccn, ccl, off, tocopy, left);
				left -= tocopy;
				off = 0;
				if (uio) {
					size_t remains = tocopy;
					for(; remains; remains--) {
						error = uiomove("", 1, uio);
						if (error != 0)
							break;
					}
				} else 
					bzero(data, tocopy);
				data = data + tocopy;
			}
			cnt++;
			if (error != 0)
				break;
		}
		if (left && error == 0) {
			printf("ntfs_readntvattr_plain: POSSIBLE RUN ERROR\n");
			error = E2BIG;
		}
	} else {
		DDPRINTF("ntfs_readnvattr_plain: data is in mft record\n");
		if (uio) 
			error = uiomove(vap->va_datap + roff, rsize, uio);
		else
			memcpy(rdata, vap->va_datap + roff, rsize);
		*initp += rsize;
	}

	return (error);
}

/*
 * This is one of read routines.
 */
int
ntfs_readattr_plain(struct ntfsmount *ntmp, struct ntnode *ip,
    u_int32_t attrnum, char *attrname, off_t roff, size_t rsize, void *rdata,
    size_t *initp, struct uio *uio)
{
	size_t          init;
	int             error = 0;
	off_t           off = roff;
	size_t		left = rsize, toread;
	caddr_t         data = rdata;
	struct ntvattr *vap;
	*initp = 0;

	while (left) {
		error = ntfs_ntvattrget(ntmp, ip, attrnum, attrname,
					ntfs_btocn(off), &vap);
		if (error)
			return (error);
		toread = MIN(left, ntfs_cntob(vap->va_vcnend + 1) - off);
		DDPRINTF("ntfs_readattr_plain: o: %lld, s: %zu "
		    "(%llu - %llu)\n", off, toread,
		    vap->va_vcnstart, vap->va_vcnend);
		error = ntfs_readntvattr_plain(ntmp, ip, vap,
					 off - ntfs_cntob(vap->va_vcnstart),
					 toread, data, &init, uio);
		if (error) {
			printf("ntfs_readattr_plain: ntfs_readntvattr_plain "
			    "failed: o: %lld, s: %zu\n", off, toread);
			printf("ntfs_readattr_plain: attrib: %llu - %llu\n",
			       vap->va_vcnstart, vap->va_vcnend);
			ntfs_ntvattrrele(vap);
			break;
		}
		ntfs_ntvattrrele(vap);
		left -= toread;
		off += toread;
		data = data + toread;
		*initp += init;
	}

	return (error);
}

/*
 * This is one of read routines.
 */
int
ntfs_readattr(struct ntfsmount *ntmp, struct ntnode *ip, u_int32_t attrnum,
    char *attrname, off_t roff, size_t rsize, void *rdata, struct uio *uio)
{
	int             error = 0;
	struct ntvattr *vap;
	size_t          init;

	DDPRINTF("ntfs_readattr: reading %u: 0x%x, from %lld size %zu bytes\n",
	    ip->i_number, attrnum, roff, rsize);

	error = ntfs_ntvattrget(ntmp, ip, attrnum, attrname, 0, &vap);
	if (error)
		return (error);

	if ((roff > vap->va_datalen) ||
	    (roff + rsize > vap->va_datalen)) {
		printf("ntfs_readattr: offset too big: %lld (%lld) > %llu\n",
		    roff, roff + rsize, vap->va_datalen);
		ntfs_ntvattrrele(vap);
		return (E2BIG);
	}
	if (vap->va_compression && vap->va_compressalg) {
		u_int8_t       *cup;
		u_int8_t       *uup;
		off_t           off = roff;
		caddr_t         data = rdata;
		cn_t            cn;
		size_t		left = rsize, tocopy;

		DDPRINTF("ntfs_ntreadattr: compression: %u\n",
		    vap->va_compressalg);

		cup = malloc(ntfs_cntob(NTFS_COMPUNIT_CL), M_NTFSDECOMP,
		    M_WAITOK);
		uup = malloc(ntfs_cntob(NTFS_COMPUNIT_CL), M_NTFSDECOMP,
		    M_WAITOK);

		cn = (ntfs_btocn(roff)) & (~(NTFS_COMPUNIT_CL - 1));
		off = roff - ntfs_cntob(cn);

		while (left) {
			error = ntfs_readattr_plain(ntmp, ip, attrnum,
						  attrname, ntfs_cntob(cn),
					          ntfs_cntob(NTFS_COMPUNIT_CL),
						  cup, &init, NULL);
			if (error)
				break;

			tocopy = MIN(left, ntfs_cntob(NTFS_COMPUNIT_CL) - off);

			if (init == ntfs_cntob(NTFS_COMPUNIT_CL)) {
				if (uio)
					error = uiomove(cup + off, tocopy, uio);
				else
					memcpy(data, cup + off, tocopy);
			} else if (init == 0) {
				if (uio) {
					size_t remains = tocopy;
					for(; remains; remains--) {
						error = uiomove("", 1, uio);
						if (error != 0)
							break;
					}
				}
				else
					bzero(data, tocopy);
			} else {
				error = ntfs_uncompunit(ntmp, uup, cup);
				if (error)
					break;
				if (uio)
					error = uiomove(uup + off, tocopy, uio);
				else
					memcpy(data, uup + off, tocopy);
			}
			if (error)
				break;

			left -= tocopy;
			data = data + tocopy;
			off += tocopy - ntfs_cntob(NTFS_COMPUNIT_CL);
			cn += NTFS_COMPUNIT_CL;
		}

		free(uup, M_NTFSDECOMP, 0);
		free(cup, M_NTFSDECOMP, 0);
	} else
		error = ntfs_readattr_plain(ntmp, ip, attrnum, attrname,
					     roff, rsize, rdata, &init, uio);
	ntfs_ntvattrrele(vap);
	return (error);
}

#if UNUSED_CODE
int
ntfs_parserun(cn_t *cn, cn_t *cl, u_int8_t *run, u_long len, u_long *off)
{
	u_int8_t        sz;
	int             i;

	if (NULL == run) {
		printf("ntfs_parsetun: run == NULL\n");
		return (EINVAL);
	}
	sz = run[(*off)++];
	if (0 == sz) {
		printf("ntfs_parserun: trying to go out of run\n");
		return (E2BIG);
	}
	*cl = 0;
	if ((sz & 0xF) > 8 || (*off) + (sz & 0xF) > len) {
		printf("ntfs_parserun: " \
		       "bad run: length too big: sz: 0x%02x (%ld < %ld + sz)\n",
		       sz, len, *off);
		return (EINVAL);
	}
	for (i = 0; i < (sz & 0xF); i++)
		*cl += (u_int32_t) run[(*off)++] << (i << 3);

	sz >>= 4;
	if ((sz & 0xF) > 8 || (*off) + (sz & 0xF) > len) {
		printf("ntfs_parserun: " \
		       "bad run: length too big: sz: 0x%02x (%ld < %ld + sz)\n",
		       sz, len, *off);
		return (EINVAL);
	}
	for (i = 0; i < (sz & 0xF); i++)
		*cn += (u_int32_t) run[(*off)++] << (i << 3);

	return (0);
}
#endif

/*
 * Process fixup routine on given buffer.
 */
int
ntfs_procfixups(struct ntfsmount *ntmp, u_int32_t magic, caddr_t buf,
    size_t len)
{
	struct fixuphdr *fhp = (struct fixuphdr *) buf;
	int             i;
	u_int16_t       fixup;
	u_int16_t      *fxp;
	u_int16_t      *cfxp;

	if (fhp->fh_magic != magic) {
		printf("ntfs_procfixups: magic doesn't match: %08x != %08x\n",
		       fhp->fh_magic, magic);
		return (EINVAL);
	}
	if ((fhp->fh_fnum - 1) * ntmp->ntm_bps != len) {
		printf("ntfs_procfixups: " \
		       "bad fixups number: %d for %ld bytes block\n", 
		       fhp->fh_fnum, (long)len);	/* XXX printf kludge */
		return (EINVAL);
	}
	if (fhp->fh_foff >= ntmp->ntm_spc * ntmp->ntm_mftrecsz * ntmp->ntm_bps) {
		printf("ntfs_procfixups: invalid offset: %x", fhp->fh_foff);
		return (EINVAL);
	}
	fxp = (u_int16_t *) (buf + fhp->fh_foff);
	cfxp = (u_int16_t *) (buf + ntmp->ntm_bps - 2);
	fixup = *fxp++;
	for (i = 1; i < fhp->fh_fnum; i++, fxp++) {
		if (*cfxp != fixup) {
			printf("ntfs_procfixups: fixup %d doesn't match\n", i);
			return (EINVAL);
		}
		*cfxp = *fxp;
		cfxp = (u_int16_t *)((caddr_t)cfxp + ntmp->ntm_bps);
	}
	return (0);
}

#if UNUSED_CODE
int
ntfs_runtocn(cn_t *cn, struct ntfsmount *ntmp, u_int8_t *run, u_long len,
    cn_t vcn)
{
	cn_t            ccn = 0;
	cn_t            ccl = 0;
	u_long          off = 0;
	int             error = 0;

#if NTFS_DEBUG
	int             i;
	printf("ntfs_runtocn: run: %p, %ld bytes, vcn:%ld\n",
		run, len, (u_long) vcn);
	printf("ntfs_runtocn: run: ");
	for (i = 0; i < len; i++)
		printf("0x%02x ", run[i]);
	printf("\n");
#endif

	if (NULL == run) {
		printf("ntfs_runtocn: run == NULL\n");
		return (EINVAL);
	}
	do {
		if (run[off] == 0) {
			printf("ntfs_runtocn: vcn too big\n");
			return (E2BIG);
		}
		vcn -= ccl;
		error = ntfs_parserun(&ccn, &ccl, run, len, &off);
		if (error) {
			printf("ntfs_runtocn: ntfs_parserun failed\n");
			return (error);
		}
	} while (ccl <= vcn);
	*cn = ccn + vcn;
	return (0);
}
#endif

/*
 * if the ntfs_toupper_tab[] is filled already, just raise use count;
 * otherwise read the data from the filesystem we are currently mounting
 */
int
ntfs_toupper_use(struct mount *mp, struct ntfsmount *ntmp, struct proc *p)
{
	int error = 0;
	struct vnode *vp;

	/* get exclusive access */
	rw_enter_write(&ntfs_toupper_lock);

	/* only read the translation data from a file if it hasn't been
	 * read already */
	if (ntfs_toupper_tab)
		goto out;

	/*
	 * Read in Unicode lowercase -> uppercase translation file.
	 * XXX for now, just the first 256 entries are used anyway,
	 * so don't bother reading more
	 */
	ntfs_toupper_tab = malloc(256 * 256 * sizeof(wchar), M_NTFSRDATA,
	    M_WAITOK);

	if ((error = VFS_VGET(mp, NTFS_UPCASEINO, &vp)))
		goto out;
	error = ntfs_readattr(ntmp, VTONT(vp), NTFS_A_DATA, NULL,
			0, 256*256*sizeof(wchar), (char *) ntfs_toupper_tab,
			NULL);
	vput(vp);

    out:
	ntfs_toupper_usecount++;
	rw_exit_write(&ntfs_toupper_lock);
	return (error);
}

/*
 * lower the use count and if it reaches zero, free the memory
 * tied by toupper table
 */
void
ntfs_toupper_unuse(struct proc *p)
{
	/* get exclusive access */
	rw_enter_write(&ntfs_toupper_lock);

	ntfs_toupper_usecount--;
	if (ntfs_toupper_usecount == 0) {
		free(ntfs_toupper_tab, M_NTFSRDATA, 0);
		ntfs_toupper_tab = NULL;
	}
#ifdef DIAGNOSTIC
	else if (ntfs_toupper_usecount < 0) {
		panic("ntfs_toupper_unuse(): use count negative: %d",
			ntfs_toupper_usecount);
	}
#endif
	
	/* release the lock */
	rw_exit_write(&ntfs_toupper_lock);
}
@


1.47
log
@Remove some unnecessary assignments in ntfs_subr.c, and move one
assignment into the for() loop where it looks better

ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.46 2016/06/01 15:44:07 natano Exp $	*/
a1335 146
}

/*
 * This is one of the write routines.
 */
int
ntfs_writeattr_plain(struct ntfsmount *ntmp, struct ntnode *ip,
    u_int32_t attrnum, char *attrname, off_t roff, size_t rsize, void *rdata,
    size_t *initp, struct uio *uio)
{
	size_t          init;
	int             error = 0;
	off_t           off = roff;
	size_t		left = rsize, towrite;
	caddr_t         data = rdata;
	struct ntvattr *vap;
	*initp = 0;

	while (left) {
		error = ntfs_ntvattrget(ntmp, ip, attrnum, attrname,
					ntfs_btocn(off), &vap);
		if (error)
			return (error);
		towrite = MIN(left, ntfs_cntob(vap->va_vcnend + 1) - off);
		DDPRINTF("ntfs_writeattr_plain: o: %lld, s: %zu "
		    "(%llu - %llu)\n", off, towrite,
		    vap->va_vcnstart, vap->va_vcnend);
		error = ntfs_writentvattr_plain(ntmp, ip, vap,
					 off - ntfs_cntob(vap->va_vcnstart),
					 towrite, data, &init, uio);
		if (error) {
			DPRINTF("ntfs_writeattr_plain: ntfs_writentvattr_plain "
			    "failed: o: %lld, s: %zu\n", off, towrite);
			DPRINTF("ntfs_writeattr_plain: attrib: %llu - %llu\n",
			    vap->va_vcnstart, vap->va_vcnend);
			ntfs_ntvattrrele(vap);
			break;
		}
		ntfs_ntvattrrele(vap);
		left -= towrite;
		off += towrite;
		data = data + towrite;
		*initp += init;
	}

	return (error);
}

/*
 * This is one of the write routines.
 *
 * ntnode should be locked.
 */
int
ntfs_writentvattr_plain(struct ntfsmount *ntmp, struct ntnode *ip,
    struct ntvattr *vap, off_t roff, size_t rsize, void *rdata, size_t *initp,
    struct uio *uio)
{
	int             error = 0;
	off_t		off;
	int             cnt;
	cn_t            ccn, ccl, cn, cl;
	caddr_t         data = rdata;
	struct buf     *bp;
	size_t          left, tocopy;

	*initp = 0;

	if ((vap->va_flag & NTFS_AF_INRUN) == 0) {
		DPRINTF("ntfs_writevattr_plain: CAN'T WRITE RES. ATTRIBUTE\n");
		return ENOTTY;
	}

	DDPRINTF("ntfs_writentvattr_plain: data in run: %lu chains\n",
	    vap->va_vruncnt);

	off = roff;
	left = rsize;

	for (cnt = 0; left && (cnt < vap->va_vruncnt); cnt++) {
		ccn = vap->va_vruncn[cnt];
		ccl = vap->va_vruncl[cnt];

		DDPRINTF("ntfs_writentvattr_plain: left %zu, cn: 0x%llx, "
		    "cl: %llu, off: %lld\n", left, ccn, ccl, off);

		if (ntfs_cntob(ccl) < off) {
			off -= ntfs_cntob(ccl);
			cnt++;
			continue;
		}
		if (!ccn && ip->i_number != NTFS_BOOTINO)
			continue; /* XXX */

		ccl -= ntfs_btocn(off);
		cn = ccn + ntfs_btocn(off);
		off = ntfs_btocnoff(off);

		while (left && ccl) {
			/*
			 * Always read and write single clusters at a time -
			 * we need to avoid requesting differently-sized
			 * blocks at the same disk offsets to avoid
			 * confusing the buffer cache.
			 */
			tocopy = MIN(left, ntfs_cntob(1) - off);
			cl = ntfs_btocl(tocopy + off);
			KASSERT(cl == 1 && tocopy <= ntfs_cntob(1));
			DDPRINTF("ntfs_writentvattr_plain: write: cn: 0x%llx "
			    "cl: %llu, off: %lld len: %zu, left: %zu\n",
			    cn, cl, off, tocopy, left);
			if ((off == 0) && (tocopy == ntfs_cntob(cl)))
			{
				bp = getblk(ntmp->ntm_devvp, ntfs_cntobn(cn),
					    ntfs_cntob(cl), 0, 0);
				clrbuf(bp);
			} else {
				error = bread(ntmp->ntm_devvp, ntfs_cntobn(cn),
					      ntfs_cntob(cl), &bp);
				if (error) {
					brelse(bp);
					return (error);
				}
			}
			if (uio) {
				error = uiomove(bp->b_data + off, tocopy, uio);
				if (error != 0)
					break;
			} else
				memcpy(bp->b_data + off, data, tocopy);
			bawrite(bp);
			data = data + tocopy;
			*initp += tocopy;
			off = 0;
			left -= tocopy;
			cn += cl;
			ccl -= cl;
		}
	}

	if (left && error == 0) {
		printf("ntfs_writentvattr_plain: POSSIBLE RUN ERROR\n");
		error = EINVAL;
	}

	return (error);
@


1.46
log
@mkdir() on ntfs should return EROFS, not ENOENT.
issue found by landry
ok kettenis millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.45 2016/02/07 09:31:14 stefan Exp $	*/
a608 1
	i = 0;
d1414 2
a1415 4
	ccl = 0;
	ccn = 0;
	cnt = 0;
	for (; left && (cnt < vap->va_vruncnt); cnt++) {
@


1.45
log
@Convert to uiomove. While there, use size_t consistently for
variables 'left' and 'tocopy' and adapt printf and DPRINTF format
strings accordingly.

From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.44 2015/03/14 03:38:52 jsg Exp $	*/
d1058 14
a1071 8
	/* perform full scan if no entry was found */
	if (!fullscan && error == ENOENT) {
		fullscan = 1;
		cn = 0;		/* need zero, used by lookup_ctx */

		DDPRINTF("ntfs_ntlookupfile: fullscan performed for: %.*s\n",
		    (unsigned int)fnamelen, fname);
		goto loop;
@


1.44
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.43 2015/02/10 22:04:00 miod Exp $	*/
d1343 2
a1344 1
	off_t           off = roff, left = rsize, towrite;
d1355 1
a1355 1
		DDPRINTF("ntfs_writeattr_plain: o: %lld, s: %lld "
d1363 3
a1365 5
			    "failed: o: %d, s: %d\n",
			    (u_int32_t)off, (u_int32_t)towrite);
			DPRINTF("ntfs_writeattr_plain: attrib: %d - %d\n",
			    (u_int32_t)vap->va_vcnstart,
			    (u_int32_t)vap->va_vcnend);
d1392 1
a1392 1
	cn_t            ccn, ccl, cn, left, cl;
d1395 1
a1395 1
	size_t          tocopy;
d1416 1
a1416 1
		DDPRINTF("ntfs_writentvattr_plain: left %llu, cn: 0x%llx, "
d1442 1
a1442 1
			    "cl: %llu, off: %lld len: %llu, left: %llu\n",
d1458 1
a1458 1
				error = uiomovei(bp->b_data + off, tocopy, uio);
d1497 1
a1497 1
		cn_t            ccn, ccl, cn, left, cl;
d1500 1
a1500 1
		size_t          tocopy;
d1514 1
a1514 1
			DDPRINTF("ntfs_readntvattr_plain: left %llu, "
d1544 2
a1545 2
					    "off: %lld, len: %llu, "
					    "left: %llu\n",
d1556 1
a1556 1
						error = uiomovei(bp->b_data + off,
d1576 1
a1576 1
				    "len: %llu, left: %llu\n",
d1602 1
a1602 1
			error = uiomovei(vap->va_datap + roff, rsize, uio);
d1621 2
a1622 1
	off_t           off = roff, left = rsize, toread;
d1633 1
a1633 1
		DDPRINTF("ntfs_readattr_plain: o: %lld, s: %lld "
d1640 4
a1643 6
			printf("ntfs_readattr_plain: " \
			       "ntfs_readntvattr_plain failed: o: %d, s: %d\n",
			       (u_int32_t) off, (u_int32_t) toread);
			printf("ntfs_readattr_plain: attrib: %d - %d\n",
			       (u_int32_t) vap->va_vcnstart, 
			       (u_int32_t) vap->va_vcnend);
d1685 1
a1685 1
		off_t           off = roff, left = rsize, tocopy;
d1688 1
d1713 1
a1713 1
					error = uiomovei(cup + off, tocopy, uio);
d1732 1
a1732 1
					error = uiomovei(uup + off, tocopy, uio);
@


1.43
log
@Convert uiomovei() with a constant size argument to uiomove().
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.42 2015/02/10 21:56:10 miod Exp $	*/
a39 1
#include <sys/file.h>
@


1.42
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.41 2014/12/16 19:56:33 tedu Exp $	*/
d1585 1
a1585 1
						error = uiomovei("", 1, uio);
d1722 1
a1722 1
						error = uiomovei("", 1, uio);
@


1.41
log
@must include lock.h if you want to play with locks
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.40 2014/12/09 07:16:41 doug Exp $	*/
d1460 1
a1460 1
				error = uiomove(bp->b_data + off, tocopy, uio);
d1558 1
a1558 1
						error = uiomove(bp->b_data + off,
d1585 1
a1585 1
						error = uiomove("", 1, uio);
d1604 1
a1604 1
			error = uiomove(vap->va_datap + roff, rsize, uio);
d1715 1
a1715 1
					error = uiomove(cup + off, tocopy, uio);
d1722 1
a1722 1
						error = uiomove("", 1, uio);
d1734 1
a1734 1
					error = uiomove(uup + off, tocopy, uio);
@


1.40
log
@Sprinkle in a little more mallocarray().

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.39 2014/09/14 14:17:26 jsg Exp $	*/
d37 1
@


1.39
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.38 2014/07/12 18:43:52 tedu Exp $	*/
d614 2
a615 2
	cn = malloc(cnt * sizeof(cn_t), M_NTFSRUN, M_WAITOK);
	cl = malloc(cnt * sizeof(cn_t), M_NTFSRUN, M_WAITOK);
@


1.38
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.37 2014/01/19 18:35:45 tedu Exp $	*/
a34 1
#include <sys/proc.h>
@


1.37
log
@lazy init nthash to save some memory when it's not used. ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.36 2013/12/02 16:23:16 jsing Exp $	*/
d244 1
a244 1
	free(alpool, M_TEMP);
d357 1
a357 1
	free(mfrp, M_TEMP);
d479 1
a479 1
	free(ip, M_NTFSNTNODE);
d518 1
a518 1
			free(vap->va_vruncn, M_NTFSRUN);
d520 1
a520 1
			free(vap->va_vruncl, M_NTFSRUN);
d523 1
a523 1
			free(vap->va_datap, M_NTFSRDATA);
d525 1
a525 1
	free(vap, M_NTFSNTVATTR);
d585 1
a585 1
		free(vap, M_NTFSNTVATTR);
d765 1
a765 1
		free(fp->f_attrname, M_TEMP);
d767 2
a768 2
		free(fp->f_dirblbuf, M_NTFSDIR);
	free(fp, M_NTFSFNODE);
d958 1
a958 1
				free(attrname, M_TEMP);
d1051 1
a1051 1
			free(tctx, M_TEMP);
d1075 1
a1075 1
		free(rdbuf, M_TEMP);
d1077 1
a1077 1
		free(attrname, M_TEMP);
d1082 1
a1082 1
			free(tctx, M_TEMP);
d1275 1
a1275 1
		free(bmp, M_TEMP);
d1747 2
a1748 2
		free(uup, M_NTFSDECOMP);
		free(cup, M_NTFSDECOMP);
d1930 1
a1930 1
		free(ntfs_toupper_tab, M_NTFSRDATA);
@


1.36
log
@Stop trying to put an off_t into an int, which results in a 2GB limit.

From NetBSD.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.35 2013/12/02 16:19:08 jsing Exp $	*/
a1877 11

/*
 * this initializes toupper table & dependant variables to be ready for
 * later work
 */
void
ntfs_toupper_init(void)
{
	ntfs_toupper_tab = (wchar *) NULL;
	ntfs_toupper_usecount = 0;
}
@


1.35
log
@Avoid truncating 64-bit on disk attribute values to 32-bits. Otherwise an
attribute's data length value wraps at 4GB.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.34 2013/12/02 16:05:07 jsing Exp $	*/
d1392 1
a1392 1
	int             off;
d1494 1
a1494 1
	int             off;
@


1.34
log
@Use appropriate format specifiers in debug messages. In particular, avoid
casting almost everything to u_int32_t, then formatting as a signed int
(which really helps when you're trying to debug based on 64-bit values).

Looked over by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.33 2013/11/24 16:02:30 jsing Exp $	*/
d582 1
a582 1
	DDPRINTF(", len: %u", vap->va_datalen);
d1182 1
a1182 1
		DPRINTF("ntfs_ntreaddir: indexalloc: %u, cpbl: %u\n",
d1680 1
a1680 1
		printf("ntfs_readattr: offset too big: %lld (%lld) > %u\n",
@


1.33
log
@Clean up the NTFS debug code - use uppercase names for the debug macros,
especially since 'dprintf' now has another meaning (at least outside of
the kernel). Tweak the macro syntax so we can avoid having to double
bracket all invocations. Also apply a good dose of style(9).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.32 2013/06/11 16:42:17 deraadt Exp $	*/
d90 1
a90 1
	DPRINTF("ntfs_ntvattrrele: ino: %d, type: 0x%x\n",
d110 1
a110 1
		DPRINTF("ntfs_findvattr: node not loaded, ino: %d\n",
d127 2
a128 3
		DDPRINTF("ntfs_findvattr: type: 0x%x, vcn: %d - %d\n",
		    vap->va_type, (u_int32_t)vap->va_vcnstart,
		    (u_int32_t)vap->va_vcnend);
d167 2
a168 2
		DPRINTF("ntfs_ntvattrget: ino: %d, type: 0x%x, name: %s, "
		    "vcn: %d\n", ip->i_number, type, name, (u_int32_t)vcn);
d171 2
a172 2
		DPRINTF("ntfs_ntvattrget: ino: %d, type: 0x%x, vcn: %d\n",
		    ip->i_number, type, (u_int32_t)vcn);
d182 3
a184 3
		DPRINTF("ntfs_ntvattrget: UNEXISTED ATTRIBUTE: ino: %d, "
		    "type: 0x%x, name: %s, vcn: %d\n", ip->i_number, type,
		    name, (u_int32_t)vcn);
d199 3
a201 3
		DPRINTF("ntfs_ntvattrget: attrlist: ino: %d, attr: 0x%x, "
		    "vcn: %d\n", aalp->al_inumber, aalp->al_type,
		    (u_int32_t)aalp->al_vcnstart);
d215 1
a215 1
		DPRINTF("ntfs_ntvattrget: attribute in ino: %d\n",
d240 3
a242 3
	DPRINTF("ntfs_ntvattrget: UNEXISTED ATTRIBUTE: ino: %d, type: 0x%x, "
	    "name: %.*s, vcn: %d\n", ip->i_number, type, (int)namelen, name,
	    (u_int32_t)vcn);
d263 1
a263 1
 	DPRINTF("ntfs_loadntnode: loading ino: %d\n", ip->i_number);
d272 1
a272 1
		DPRINTF("ntfs_loadntnode: unloading ino: %d\n", oip->i_number);
d323 1
a323 1
	DPRINTF("ntfs_loadntnode: load attrs for ino: %d\n", ip->i_number);
d368 1
a368 1
	DPRINTF("ntfs_ntget: get ntnode %d: %p, usecount: %d\n",
d391 1
a391 1
	DPRINTF("ntfs_ntlookup: looking for ntnode %d\n", ino);
d396 1
a396 1
			DPRINTF("ntfs_ntlookup: ntnode %d: %p, usecount: %d\n",
d404 1
a404 1
	DDPRINTF("ntfs_ntlookup: allocating ntnode: %d: %p\n", ino, ip);
d425 1
a425 1
	DPRINTF("ntfs_ntlookup: ntnode %d: %p, usecount: %d\n",
d443 1
a443 1
	DPRINTF("ntfs_ntput: rele ntnode %d: %p, usecount: %d\n",
d460 1
a460 1
	DPRINTF("ntfs_ntput: deallocating ntnode: %d\n", ip->i_number);
d490 1
a490 1
	DPRINTF("ntfs_ntref: ino %d, usecount: %d\n",
d500 1
a500 1
	DPRINTF("ntfs_ntrele: rele ntnode %d: %p, usecount: %d\n",
d549 1
a549 1
	DDPRINTF("type: 0x%x, index: %d", vap->va_type, vap->va_index);
d582 1
a582 1
	DDPRINTF(", len: %d", vap->va_datalen);
d714 1
a714 1
	DPRINTF("ntfs_fget: ino: %d, attrtype: 0x%x, attrname: %s\n",
d718 1
a718 1
		DPRINTF("ntfs_fget: fnode: attrtype: %d, attrname: %s\n",
d760 1
a760 1
	DPRINTF("ntfs_frele: fnode: %p for %d: %p\n", fp, ip->i_number, ip);
d876 1
a876 1
	DPRINTF("ntfs_ntlookupfile: blksz: %d\n", blsize);
d882 1
a882 1
	DPRINTF("ntfs_ntlookupfile: rdsz: %d\n", rdsize);
d898 2
a899 2
			DDPRINTF("scan: %d, %d\n", (u_int32_t)iep->ie_number,
			    (u_int32_t)iep->ie_fnametype);
d1065 1
a1065 1
		    (int)fnamelen, fname);
d1140 1
a1140 1
	DPRINTF("ntfs_ntreaddir: read ino: %d, num: %d\n", ip->i_number, num);
d1160 1
a1160 1
	DPRINTF("ntfs_ntreaddir: rdbuf: %p, blsize: %d\n", rdbuf, blsize);
d1182 1
a1182 1
		DPRINTF("ntfs_ntreaddir: indexalloc: %d, cpbl: %d\n",
d1204 2
a1205 2
		DPRINTF("ntfs_ntreaddir: scan: 0x%x, %d, %d, %d, %d\n",
		    attrnum, (u_int32_t)blnum, cnum, num, aoff);
d1260 1
a1260 2
			DPRINTF("ntfs_ntreaddir: blnum: %d\n",
			    (u_int32_t)blnum);
d1312 1
a1312 1
	DPRINTF("ntfs_filesize: ino: %d\n", ip->i_number);
d1322 1
a1322 2
	DPRINTF("ntfs_filesize: %d bytes (%d bytes allocated)\n",
	    (u_int32_t)sz, (u_int32_t)bn);
d1355 3
a1357 3
		DDPRINTF("ntfs_writeattr_plain: o: %d, s: %d (%d - %d)\n",
		    (u_int32_t)off, (u_int32_t)towrite,
		    (u_int32_t)vap->va_vcnstart, (u_int32_t)vap->va_vcnend);
d1418 2
a1419 3
		DDPRINTF("ntfs_writentvattr_plain: left %d, cn: 0x%x, cl: %d, "
		    "off: %d\n", (u_int32_t)left, (u_int32_t)ccn,
		    (u_int32_t)ccl, (u_int32_t)off);
d1443 3
a1445 4
			DDPRINTF("ntfs_writentvattr_plain: write: cn: 0x%x "
			    "cl: %d, off: %d len: %d, left: %d\n",
			    (u_int32_t)cn, (u_int32_t)cl, (u_int32_t)off,
			    (u_int32_t) tocopy, (u_int32_t)left);
d1516 3
a1518 3
			DDPRINTF("ntfs_readntvattr_plain: left %d, cn: 0x%x, "
			    "cl: %d, off: %d\n", (u_int32_t)left,
			    (u_int32_t)ccn, (u_int32_t)ccl, (u_int32_t)off);
d1545 4
a1548 5
					    "read: cn: 0x%x cl: %d, off: %d, "
					    "len: %d, left: %d\n",
					    (u_int32_t)cn, (u_int32_t)cl, 
					    (u_int32_t)off, (u_int32_t)tocopy, 
					    (u_int32_t)left);
d1577 3
a1579 5
				    "ccn: 0x%x ccl: %d, off: %d, len: %d, "
				    "left: %d\n",
				    (u_int32_t)ccn, (u_int32_t)ccl, 
				    (u_int32_t)off, (u_int32_t)tocopy, 
				    (u_int32_t)left);
d1634 3
a1636 3
		DDPRINTF("ntfs_readattr_plain: o: %d, s: %d (%d - %d)\n",
		    (u_int32_t)off, (u_int32_t)toread,
		    (u_int32_t)vap->va_vcnstart, (u_int32_t)vap->va_vcnend);
d1671 2
a1672 2
	DDPRINTF("ntfs_readattr: reading %d: 0x%x, from %d size %d bytes\n",
	    ip->i_number, attrnum, (u_int32_t)roff, (u_int32_t)rsize);
d1680 2
a1681 3
		printf("ntfs_readattr: offset too big: %ld (%ld) > %ld\n",
			(long int) roff, (long int) roff + rsize,
			(long int) vap->va_datalen);
d1692 1
a1692 1
		DDPRINTF("ntfs_ntreadattr: compression: %d\n",
@


1.32
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.31 2013/05/30 20:11:06 guenther Exp $	*/
d90 2
a91 2
	dprintf(("ntfs_ntvattrrele: ino: %d, type: 0x%x\n",
		 vap->va_ip->i_number, vap->va_type));
d110 2
a111 2
		dprintf(("ntfs_findvattr: node not loaded, ino: %d\n",
		       ip->i_number));
d127 3
a129 3
		ddprintf(("ntfs_findvattr: type: 0x%x, vcn: %d - %d\n", \
			  vap->va_type, (u_int32_t) vap->va_vcnstart, \
			  (u_int32_t) vap->va_vcnend));
d168 2
a169 3
		dprintf(("ntfs_ntvattrget: " \
			 "ino: %d, type: 0x%x, name: %s, vcn: %d\n", \
			 ip->i_number, type, name, (u_int32_t) vcn));
d172 2
a173 3
		dprintf(("ntfs_ntvattrget: " \
			 "ino: %d, type: 0x%x, vcn: %d\n", \
			 ip->i_number, type, (u_int32_t) vcn));
d183 3
a185 3
		dprintf(("ntfs_ntvattrget: UNEXISTED ATTRIBUTE: " \
		       "ino: %d, type: 0x%x, name: %s, vcn: %d\n", \
		       ip->i_number, type, name, (u_int32_t) vcn));
d200 3
a202 4
		dprintf(("ntfs_ntvattrget: " \
			 "attrlist: ino: %d, attr: 0x%x, vcn: %d\n", \
			 aalp->al_inumber, aalp->al_type, \
			 (u_int32_t) aalp->al_vcnstart));
d216 2
a217 2
		dprintf(("ntfs_ntvattrget: attribute in ino: %d\n",
				 aalp->al_inumber));
d241 3
a243 3
	dprintf(("ntfs_ntvattrget: UNEXISTED ATTRIBUTE: " \
	       "ino: %d, type: 0x%x, name: %.*s, vcn: %d\n", \
	       ip->i_number, type, (int) namelen, name, (u_int32_t) vcn));
d264 1
a264 1
 	dprintf(("ntfs_loadntnode: loading ino: %d\n",ip->i_number));
d273 1
a273 2
		dprintf(("ntfs_loadntnode: unloading ino: %d\n",
		    oip->i_number));
d288 1
a288 1
		dprintf(("ntfs_loadntnode: read system node\n"));
d324 1
a324 1
	dprintf(("ntfs_loadntnode: load attrs for ino: %d\n",ip->i_number));
d369 2
a370 2
	dprintf(("ntfs_ntget: get ntnode %d: %p, usecount: %d\n",
		ip->i_number, ip, ip->i_usecount));
d392 1
a392 1
	dprintf(("ntfs_ntlookup: looking for ntnode %d\n", ino));
d397 2
a398 2
			dprintf(("ntfs_ntlookup: ntnode %d: %p, usecount: %d\n",
				ino, ip, ip->i_usecount));
d405 1
a405 1
	ddprintf(("ntfs_ntlookup: allocating ntnode: %d: %p\n", ino, ip));
d426 2
a427 2
	dprintf(("ntfs_ntlookup: ntnode %d: %p, usecount: %d\n",
		ino, ip, ip->i_usecount));
d444 2
a445 2
	dprintf(("ntfs_ntput: rele ntnode %d: %p, usecount: %d\n",
		ip->i_number, ip, ip->i_usecount));
d461 1
a461 1
	dprintf(("ntfs_ntput: deallocating ntnode: %d\n", ip->i_number));
d491 2
a492 3
	dprintf(("ntfs_ntref: ino %d, usecount: %d\n",
		ip->i_number, ip->i_usecount));
			
d501 2
a502 2
	dprintf(("ntfs_ntrele: rele ntnode %d: %p, usecount: %d\n",
		ip->i_number, ip, ip->i_usecount));
d550 1
a550 1
	ddprintf(("type: 0x%x, index: %d", vap->va_type, vap->va_index));
d555 1
a555 1
		ddprintf((", name:["));
d558 1
a558 1
			ddprintf(("%c", vap->va_name[i]));
d560 1
a560 1
		ddprintf(("]"));
d563 1
a563 1
		ddprintf((", nonres."));
d574 1
a574 1
		ddprintf((", res."));
d583 1
a583 1
	ddprintf((", len: %d", vap->va_datalen));
d590 1
a590 1
	ddprintf(("\n"));
d715 2
a716 2
	dprintf(("ntfs_fget: ino: %d, attrtype: 0x%x, attrname: %s\n",
		ip->i_number,attrtype, attrname?attrname:""));
d719 2
a720 2
		dprintf(("ntfs_fget: fnode: attrtype: %d, attrname: %s\n",
			fp->f_attrtype, fp->f_attrname?fp->f_attrname:""));
d726 1
a726 1
			dprintf(("ntfs_fget: found existed: %p\n",fp));
d735 1
a735 1
	dprintf(("ntfs_fget: allocating fnode: %p\n",fp));
d761 1
a761 1
	dprintf(("ntfs_frele: fnode: %p for %d: %p\n", fp, ip->i_number, ip));
d763 1
a763 1
	dprintf(("ntfs_frele: deallocating fnode\n"));
d871 2
a872 2
			dprintf(("ntfs_ntlookupfile: %s (%d), attr: %s (%d)\n",
				fname, fnamelen, aname, anamelen));
d877 1
a877 1
	dprintf(("ntfs_ntlookupfile: blksz: %d\n", blsize));
d883 1
a883 1
	dprintf(("ntfs_ntlookupfile: rdsz: %d\n", rdsize));
d899 2
a900 3
			ddprintf(("scan: %d, %d\n",
				  (u_int32_t) iep->ie_number,
				  (u_int32_t) iep->ie_fnametype));
d1014 1
a1014 1
			dprintf(("ntfs_ntlookupfile: diving\n"));
d1054 1
a1054 1
			dprintf(("ntfs_ntlookupfile: nowhere to dive :-(\n"));
d1065 2
a1066 2
		ddprintf(("ntfs_ntlookupfile: fullscan performed for: %.*s\n",
			(int) fnamelen, fname));
d1070 1
a1070 1
	dprintf(("finish\n"));
d1101 1
a1101 1
		ddprintf(("ntfs_isnamepermitted: skipped DOS name\n"));
d1141 1
a1141 1
	dprintf(("ntfs_ntreaddir: read ino: %d, num: %d\n", ip->i_number, num));
d1161 1
a1161 1
	dprintf(("ntfs_ntreaddir: rdbuf: %p, blsize: %d\n", rdbuf, blsize));
d1183 2
a1184 2
		dprintf(("ntfs_ntreaddir: indexalloc: %d, cpbl: %d\n",
			 iavap->va_datalen, cpbl));
d1186 1
a1186 1
		dprintf(("ntfs_ntreadidir: w/o BitMap and IndexAllocation\n"));
d1205 2
a1206 2
		dprintf(("ntfs_ntreaddir: scan: 0x%x, %d, %d, %d, %d\n",
			 attrnum, (u_int32_t) blnum, cnum, num, aoff));
d1261 2
a1262 1
			dprintf(("ntfs_ntreaddir: blnum: %d\n", (u_int32_t) blnum));
d1314 1
a1314 1
	dprintf(("ntfs_filesize: ino: %d\n", ip->i_number));
d1324 2
a1325 2
	dprintf(("ntfs_filesize: %d bytes (%d bytes allocated)\n",
		(u_int32_t) sz, (u_int32_t) bn));
d1358 3
a1360 4
		ddprintf(("ntfs_writeattr_plain: o: %d, s: %d (%d - %d)\n",
			 (u_int32_t) off, (u_int32_t) towrite,
			 (u_int32_t) vap->va_vcnstart,
			 (u_int32_t) vap->va_vcnend));
d1365 6
a1370 6
			dprintf(("ntfs_writeattr_plain: " \
			       "ntfs_writentvattr_plain failed: o: %d, s: %d\n",
			       (u_int32_t) off, (u_int32_t) towrite));
			dprintf(("ntfs_writeattr_plain: attrib: %d - %d\n",
			       (u_int32_t) vap->va_vcnstart, 
			       (u_int32_t) vap->va_vcnend));
d1405 1
a1405 1
		dprintf(("ntfs_writevattr_plain: CAN'T WRITE RES. ATTRIBUTE\n"));
d1409 2
a1410 2
	ddprintf(("ntfs_writentvattr_plain: data in run: %lu chains\n",
		 vap->va_vruncnt));
d1421 3
a1423 4
		ddprintf(("ntfs_writentvattr_plain: " \
			 "left %d, cn: 0x%x, cl: %d, off: %d\n", \
			 (u_int32_t) left, (u_int32_t) ccn, \
			 (u_int32_t) ccl, (u_int32_t) off));
d1447 4
a1450 5
			ddprintf(("ntfs_writentvattr_plain: write: " \
				"cn: 0x%x cl: %d, off: %d len: %d, left: %d\n",
				(u_int32_t) cn, (u_int32_t) cl, 
				(u_int32_t) off, (u_int32_t) tocopy, 
				(u_int32_t) left));
d1509 2
a1510 2
		ddprintf(("ntfs_readntvattr_plain: data in run: %lu chains\n",
			 vap->va_vruncnt));
d1521 3
a1523 4
			ddprintf(("ntfs_readntvattr_plain: " \
				 "left %d, cn: 0x%x, cl: %d, off: %d\n", \
				 (u_int32_t) left, (u_int32_t) ccn, \
				 (u_int32_t) ccl, (u_int32_t) off));
d1549 6
a1554 8
					ddprintf(("ntfs_readntvattr_plain: " \
						"read: cn: 0x%x cl: %d, " \
						"off: %d len: %d, left: %d\n",
						(u_int32_t) cn, 
						(u_int32_t) cl, 
						(u_int32_t) off, 
						(u_int32_t) tocopy, 
						(u_int32_t) left));
d1582 6
a1587 6
				ddprintf(("ntfs_readntvattr_plain: "
					"hole: ccn: 0x%x ccl: %d, off: %d, " \
					" len: %d, left: %d\n", 
					(u_int32_t) ccn, (u_int32_t) ccl, 
					(u_int32_t) off, (u_int32_t) tocopy, 
					(u_int32_t) left));
d1610 1
a1610 1
		ddprintf(("ntfs_readnvattr_plain: data is in mft record\n"));
d1642 3
a1644 4
		ddprintf(("ntfs_readattr_plain: o: %d, s: %d (%d - %d)\n",
			 (u_int32_t) off, (u_int32_t) toread,
			 (u_int32_t) vap->va_vcnstart,
			 (u_int32_t) vap->va_vcnend));
d1679 2
a1680 2
	ddprintf(("ntfs_readattr: reading %d: 0x%x, from %d size %d bytes\n",
	       ip->i_number, attrnum, (u_int32_t) roff, (u_int32_t) rsize));
d1701 2
a1702 2
		ddprintf(("ntfs_ntreadattr: compression: %d\n",
			 vap->va_compressalg));
@


1.31
log
@More of the same: ntfs doesn't do inode numbers >2^32, so use a smaller type
internally, only using ino_t in the VFS layer APIs: vget, readdir, getattr
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.30 2013/01/18 05:09:21 jsing Exp $	*/
d264 1
a264 1
	daddr64_t	bn;
@


1.30
log
@Constrain the amount of kernel memory used by NTFS. Keep a small cache of
loaded ntnodes and once the maximum is reached, unload the least recently
used ntnode before loading a new one. This avoids leaving large data
structures hanging around, which only get cleaned up when the vnode is
reclaimed. Additionally, the buffer cache should contain the data needed
to reload the ntnode.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.29 2013/01/14 02:41:03 jsing Exp $	*/
d391 1
a391 1
ntfs_ntlookup(struct ntfsmount *ntmp, ino_t ino, struct ntnode **ipp,
@


1.29
log
@Ansify and apply style(9) to function definitions.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.28 2013/01/13 04:07:49 jsing Exp $	*/
d118 4
d260 26
a285 9
	struct filerec  *mfrp;
	daddr64_t         bn;
	int		error,off;
	struct attr    *ap;
	struct ntvattr *nvap;

	dprintf(("ntfs_loadntnode: loading ino: %d\n",ip->i_number));

	mfrp = malloc(ntfs_bntob(ntmp->ntm_bpmftrec), M_TEMP, M_WAITOK);
d287 2
d335 1
a335 1
		error = ntfs_attrtontvattr(ntmp, &nvap, ap);
d338 1
a338 1
		nvap->va_ip = ip;
d340 1
a340 1
		LIST_INSERT_HEAD(&ip->i_valist, nvap, va_list);
d357 4
d445 1
d471 6
@


1.28
log
@Destatic.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.27 2013/01/03 16:13:16 jsing Exp $	*/
d88 1
a88 2
ntfs_ntvattrrele(vap)
	struct ntvattr * vap;
d102 3
a104 8
ntfs_findvattr(ntmp, ip, lvapp, vapp, type, name, namelen, vcn)
	struct ntfsmount *ntmp;
	struct ntnode *ip;
	struct ntvattr **lvapp, **vapp;
	u_int32_t type;
	const char *name;
	size_t namelen;
	cn_t vcn;
d149 2
a150 7
ntfs_ntvattrget(
		struct ntfsmount * ntmp,
		struct ntnode * ip,
		u_int32_t type,
		const char *name,
		cn_t vcn,
		struct ntvattr ** vapp)
d254 1
a254 3
ntfs_loadntnode(
	      struct ntfsmount * ntmp,
	      struct ntnode * ip)
d344 1
a344 4
ntfs_ntget(
	struct ntnode *ip,
	struct proc *p
	)
d364 2
a365 5
ntfs_ntlookup(
	   struct ntfsmount * ntmp,
	   ino_t ino,
	   struct ntnode ** ipp,
	   struct proc * p)
d416 1
a416 4
ntfs_ntput(
	struct ntnode *ip,
	struct proc *p
	)
d457 1
a457 2
ntfs_ntref(ip)
	struct ntnode *ip;
d470 1
a470 2
ntfs_ntrele(ip)
	struct ntnode *ip;
d486 1
a486 2
ntfs_freentvattr(vap)
	struct ntvattr * vap;
d505 2
a506 4
ntfs_attrtontvattr(
		   struct ntfsmount * ntmp,
		   struct ntvattr ** rvapp,
		   struct attr * rap)
d570 1
a570 5
ntfs_runtovrun(
	       cn_t ** rcnp,
	       cn_t ** rclp,
	       u_long * rcntp,
	       u_int8_t * run)
d628 2
a629 6
ntfs_uastricmp(ntmp, ustr, ustrlen, astr, astrlen)
	struct ntfsmount *ntmp;
	const wchar *ustr;
	size_t ustrlen;
	const char *astr;
	size_t astrlen;
d654 2
a655 6
ntfs_uastrcmp(ntmp, ustr, ustrlen, astr, astrlen)
	struct ntfsmount *ntmp;
	const wchar *ustr;
	size_t ustrlen;
	const char *astr;
	size_t astrlen;
d681 2
a682 6
ntfs_fget(
	struct ntfsmount *ntmp,
	struct ntnode *ip,
	int attrtype,
	char *attrname,
	struct fnode **fpp)
d728 1
a728 2
ntfs_frele(
	struct fnode *fp)
d750 2
a751 6
ntfs_ntlookupattr(
		struct ntfsmount * ntmp,
		const char * name,
		int namelen,
		int *attrtype,
		char **attrname)
d796 1
a796 2
 * Lookup specified node for filename, matching cnp,
 * return fnode filled.
d799 2
a800 6
ntfs_ntlookupfile(
	      struct ntfsmount * ntmp,
	      struct vnode * vp,
	      struct componentname * cnp,
	      struct vnode ** vpp,
	      struct proc *p)
d1066 1
a1066 3
ntfs_isnamepermitted(
		     struct ntfsmount * ntmp,
		     struct attr_indexentry * iep)
d1095 2
a1096 6
ntfs_ntreaddir(
	       struct ntfsmount * ntmp,
	       struct fnode * fp,
	       u_int32_t num,
	       struct attr_indexentry ** riepp,
	       struct proc *p)
d1259 1
a1259 2
ntfs_nttimetounix(
		  u_int64_t nt)
d1277 2
a1278 5
ntfs_filesize(
	      struct ntfsmount * ntmp,
	      struct fnode * fp,
	      u_int64_t * size,
	      u_int64_t * bytes)
d1312 3
a1314 10
ntfs_writeattr_plain(
	struct ntfsmount * ntmp,
	struct ntnode * ip,
	u_int32_t attrnum,	
	char *attrname,
	off_t roff,
	size_t rsize,
	void *rdata,
	size_t * initp,
	struct uio *uio)
d1362 3
a1364 9
ntfs_writentvattr_plain(
	struct ntfsmount * ntmp,
	struct ntnode * ip,
	struct ntvattr * vap,
	off_t roff,
	size_t rsize,
	void *rdata,
	size_t * initp,
	struct uio *uio)
d1468 3
a1470 9
ntfs_readntvattr_plain(
	struct ntfsmount * ntmp,
	struct ntnode * ip,
	struct ntvattr * vap,
	off_t roff,
	size_t rsize,
	void *rdata,
	size_t * initp,
	struct uio *uio)
d1602 3
a1604 10
ntfs_readattr_plain(
	struct ntfsmount * ntmp,
	struct ntnode * ip,
	u_int32_t attrnum,	
	char *attrname,
	off_t roff,
	size_t rsize,
	void *rdata,
	size_t * initp,
	struct uio *uio)
d1650 2
a1651 9
ntfs_readattr(
	struct ntfsmount * ntmp,
	struct ntnode * ip,
	u_int32_t attrnum,
	char *attrname,
	off_t roff,
	size_t rsize,
	void *rdata,
	struct uio *uio)
d1745 1
a1745 6
ntfs_parserun(
	      cn_t * cn,
	      cn_t * cl,
	      u_int8_t * run,
	      u_long len,
	      u_long *off)
d1787 2
a1788 5
ntfs_procfixups(
		struct ntfsmount * ntmp,
		u_int32_t magic,
		caddr_t buf,
		size_t len)
d1827 2
a1828 6
ntfs_runtocn(
	     cn_t * cn,	
	     struct ntfsmount * ntmp,
	     u_int8_t * run,
	     u_long len,
	     cn_t vcn)
d1871 1
a1871 1
ntfs_toupper_init()
d1882 1
a1882 4
ntfs_toupper_use(mp, ntmp, p)
	struct mount *mp;
	struct ntfsmount *ntmp;
	struct proc *p;
d1921 1
a1921 2
ntfs_toupper_unuse(p)
	struct proc *p;
@


1.27
log
@Correct error handling in two hard to hit ENOTDIR error cases. These would
previously leave the ntnode locked and neglect to decrement the use count.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.26 2013/01/02 08:12:13 jsing Exp $	*/
d66 4
a69 4
static int ntfs_ntlookupattr(struct ntfsmount *, const char *, int, int *, char **);
static int ntfs_findvattr(struct ntfsmount *, struct ntnode *, struct ntvattr **, struct ntvattr **, u_int32_t, const char *, size_t, cn_t);
static int ntfs_uastricmp(struct ntfsmount *, const wchar *, size_t, const char *, size_t);
static int ntfs_uastrcmp(struct ntfsmount *, const wchar *, size_t, const char *, size_t);
d102 1
a102 1
static int
d658 1
a658 1
static int
d688 1
a688 1
static int
d793 1
a793 1
static int
@


1.26
log
@Remove code that is not used on OpenBSD.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.25 2011/07/04 20:35:35 deraadt Exp $	*/
d857 1
a857 1
	struct ntvattr *vap;	/* Root attribute */
d859 1
a859 1
	caddr_t         rdbuf;	/* Buffer to read directory's blocks  */
a874 1

d879 4
a882 2
	if (error || (vap->va_flag & NTFS_AF_INRUN))
		return (ENOTDIR);
d1098 4
a1110 1
	ntfs_ntvattrrele(vap);
a1111 1
	free(rdbuf, M_TEMP);
d1178 4
a1181 2
	if (error)
		return (ENOTDIR);
@


1.25
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.24 2011/07/04 04:30:41 tedu Exp $	*/
a55 7
#endif

#ifdef MALLOC_DEFINE
MALLOC_DEFINE(M_NTFSNTVATTR, "NTFS vattr", "NTFS file attribute information");
MALLOC_DEFINE(M_NTFSRDATA, "NTFS res data", "NTFS resident data");
MALLOC_DEFINE(M_NTFSRUN, "NTFS vrun", "NTFS vrun storage");
MALLOC_DEFINE(M_NTFSDECOMP, "NTFS decomp", "NTFS decompression temporary");
@


1.24
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.23 2010/09/09 11:31:40 miod Exp $	*/
d43 1
a43 2

#include <miscfs/specfs/specdev.h>
@


1.23
log
@nessesary -> necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.22 2010/09/04 21:35:58 tedu Exp $	*/
d295 2
a296 3
		error = bread(ntmp->ntm_devvp,
			      bn, ntfs_bntob(ntmp->ntm_bpmftrec),
			      NOCRED, &bp);
d1511 1
a1511 1
					      ntfs_cntob(cl), NOCRED, &bp);
d1620 1
a1620 1
						      NOCRED, &bp);
@


1.22
log
@revert previous "simplification".  kcornies at gmail says it doesn't work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.21 2010/08/22 21:23:07 tedu Exp $	*/
d158 1
a158 1
 * VOP_VGET node needed, and lookup through its ntnode (load if nessesary).
@


1.21
log
@the upper case table code was a lot more complicated than it needed to be.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.20 2010/08/12 04:05:03 tedu Exp $	*/
d35 1
d59 7
d79 2
a80 1
/* table for mapping Unicode chars into uppercase */
d84 2
d1979 13
a1991 2
 * if the ntfs_toupper_tab[] is not filled already
 * read the data from the filesystem we are currently mounting
d1994 4
a1997 1
ntfs_load_toupper(struct mount *mp, struct ntfsmount *ntmp)
a1999 1
	wchar *buf = NULL;
d2002 3
d2015 2
a2016 1
	buf = malloc(256 * sizeof(wchar), M_NTFSRDATA, M_WAITOK);
d2020 3
a2022 2
	error = ntfs_readattr(ntmp, VTONT(vp), NTFS_A_DATA, NULL, 0,
	    256 * sizeof(wchar), ntfs_toupper_tab, NULL);
d2025 5
a2029 5
	/* check we didn't lose a race */
	if (!ntfs_toupper_tab) {
		ntfs_toupper_tab = buf;
		buf = NULL;
	}
d2031 10
a2040 3
out:
	if (buf)
		free(buf, M_NTFSRDATA);
d2042 14
a2055 1
	return (error);
@


1.20
log
@clean up some macro obfuscation and assorted styling problems.
fix a bonus off by one bug.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.19 2010/08/06 00:00:41 miod Exp $	*/
a34 1
#include <sys/proc.h>
a57 7
#ifdef MALLOC_DEFINE
MALLOC_DEFINE(M_NTFSNTVATTR, "NTFS vattr", "NTFS file attribute information");
MALLOC_DEFINE(M_NTFSRDATA, "NTFS res data", "NTFS resident data");
MALLOC_DEFINE(M_NTFSRUN, "NTFS vrun", "NTFS vrun storage");
MALLOC_DEFINE(M_NTFSDECOMP, "NTFS decomp", "NTFS decompression temporary");
#endif

d71 1
a71 2
/* table for mapping Unicode chars into uppercase; it's filled upon first
 * ntfs mount, freed upon last ntfs umount */
a74 2
struct rwlock ntfs_toupper_lock = RWLOCK_INITIALIZER("ntfs_toupper");
static signed int ntfs_toupper_usecount;
d1968 2
a1969 13
 * this initializes toupper table & dependant variables to be ready for
 * later work
 */
void
ntfs_toupper_init()
{
	ntfs_toupper_tab = (wchar *) NULL;
	ntfs_toupper_usecount = 0;
}

/*
 * if the ntfs_toupper_tab[] is filled already, just raise use count;
 * otherwise read the data from the filesystem we are currently mounting
d1972 1
a1972 4
ntfs_toupper_use(mp, ntmp, p)
	struct mount *mp;
	struct ntfsmount *ntmp;
	struct proc *p;
d1975 1
a1977 3
	/* get exclusive access */
	rw_enter_write(&ntfs_toupper_lock);

d1988 1
a1988 2
	ntfs_toupper_tab = malloc(256 * 256 * sizeof(wchar), M_NTFSRDATA,
	    M_WAITOK);
d1992 2
a1993 3
	error = ntfs_readattr(ntmp, VTONT(vp), NTFS_A_DATA, NULL,
			0, 256*256*sizeof(wchar), (char *) ntfs_toupper_tab,
			NULL);
d1996 5
a2000 5
    out:
	ntfs_toupper_usecount++;
	rw_exit_write(&ntfs_toupper_lock);
	return (error);
}
d2002 3
a2004 10
/*
 * lower the use count and if it reaches zero, free the memory
 * tied by toupper table
 */
void
ntfs_toupper_unuse(p)
	struct proc *p;
{
	/* get exclusive access */
	rw_enter_write(&ntfs_toupper_lock);
d2006 1
a2006 14
	ntfs_toupper_usecount--;
	if (ntfs_toupper_usecount == 0) {
		free(ntfs_toupper_tab, M_NTFSRDATA);
		ntfs_toupper_tab = NULL;
	}
#ifdef DIAGNOSTIC
	else if (ntfs_toupper_usecount < 0) {
		panic("ntfs_toupper_unuse(): use count negative: %d",
			ntfs_toupper_usecount);
	}
#endif
	
	/* release the lock */
	rw_exit_write(&ntfs_toupper_lock);
@


1.19
log
@Every time you ignore uiomove() return value, $DEITY kills a little
$ADORABLE_FELINE.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.18 2009/08/13 16:00:53 jasper Exp $	*/
d207 1
a207 1
	alpool = (caddr_t) malloc(len, M_TEMP, M_WAITOK);
d285 1
a285 2
	mfrp = (struct filerec *) malloc(ntfs_bntob(ntmp->ntm_bpmftrec),
	       M_TEMP, M_WAITOK);
d304 1
a304 1
		bqrelse(bp);
d586 1
a586 2
		vap->va_datap = (caddr_t) malloc(vap->va_datalen,
		       M_NTFSRDATA, M_WAITOK);
d627 2
a628 2
	cn = (cn_t *) malloc(cnt * sizeof(cn_t), M_NTFSRUN, M_WAITOK);
	cl = (cn_t *) malloc(cnt * sizeof(cn_t), M_NTFSRUN, M_WAITOK);
d832 1
a832 1
			   strncmp(sys, adp->ad_name, syslen) != 0)
d843 2
a844 2
		*attrname = (char *) malloc(namelen, M_TEMP, M_WAITOK);
		memcpy((*attrname), name, namelen);
d911 1
a911 1
	rdbuf = (caddr_t) malloc(blsize, M_TEMP, M_WAITOK);
d1189 2
a1190 2
		fp->f_dirblbuf = (caddr_t) malloc(
		       MAX(vap->va_datalen,fp->f_dirblsz), M_NTFSDIR, M_WAITOK);
d1205 1
a1205 1
		bmp = (u_int8_t *) malloc(bmvap->va_datalen, M_TEMP, M_WAITOK);
@


1.18
log
@- remove super-obvious comments from vnodeop_entries[]
- remove #ifdef someos blocks, makes this a tad easier to read

agreed by art@@ and thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.17 2009/07/09 22:29:56 thib Exp $	*/
d1520 5
a1524 3
			if (uio)
				uiomove(bp->b_data + off, tocopy, uio);
			else
d1536 1
a1536 1
	if (left) {
d1629 1
a1629 1
						uiomove(bp->b_data + off,
d1631 2
d1657 5
a1661 2
					for(; remains; remains--)
						uiomove("", 1, uio);
d1667 2
d1670 1
a1670 1
		if (left) {
d1677 1
a1677 1
			uiomove(vap->va_datap + roff, rsize, uio);
d1804 1
a1804 1
					uiomove(cup + off, tocopy, uio);
d1810 5
a1814 2
					for(; remains; remains--)
						uiomove("", 1, uio);
d1823 1
a1823 1
					uiomove(uup + off, tocopy, uio);
d1827 2
@


1.17
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.15 2008/05/13 02:24:08 brad Exp $	*/
a42 3
#if defined(__FreeBSD__)
#include <machine/clock.h>
#endif
a46 9
#if defined(__FreeBSD__) || defined(__NetBSD__)
#include <fs/ntfs/ntfs.h>
#include <fs/ntfs/ntfsmount.h>
#include <fs/ntfs/ntfs_inode.h>
#include <fs/ntfs/ntfs_vfsops.h>
#include <fs/ntfs/ntfs_subr.h>
#include <fs/ntfs/ntfs_compr.h>
#include <fs/ntfs/ntfs_ihash.h>
#else
a53 1
#endif
a368 1
#ifdef __OpenBSD__
a369 1
#endif
a392 3
#ifndef __OpenBSD__
	   struct ntnode ** ipp)
#else
a394 1
#endif
a401 3
#ifndef __OpenBSD__
			ntfs_ntget(ip);
#else
a402 1
#endif
a423 3
#ifndef __OpenBSD__
	ntfs_ntget(ip);
#else
a424 1
#endif
a446 1
#ifdef __OpenBSD__
a447 1
#endif
a862 3
#ifndef __OpenBSD__
	      struct vnode ** vpp)
#else
a864 1
#endif
a884 3
#ifndef __OpenBSD__
	error = ntfs_ntget(ip);
#else
d886 1
a886 1
#endif
a1117 3
#ifndef __OpenBSD__
	ntfs_ntput(ip);
#else
a1118 1
#endif
a1161 3
#ifndef __OpenBSD__
	       struct attr_indexentry ** riepp)
#else
a1163 1
#endif
a1180 3
#ifndef __OpenBSD__
	error = ntfs_ntget(ip);
#else
a1181 1
#endif
a1313 3
#ifndef __OpenBSD__
	ntfs_ntput(ip);
#else
d1315 1
a1315 1
#endif
a1336 32
#ifndef __OpenBSD__
/*
 * Get file times from NTFS_A_NAME attribute.
 */
int
ntfs_times(
	   struct ntfsmount * ntmp,
	   struct ntnode * ip,
	   ntfs_times_t * tm)
{
	struct ntvattr *vap;
	int             error;

	dprintf(("ntfs_times: ino: %d...\n", ip->i_number));

	error = ntfs_ntget(ip);
	if (error)
		return (error);

	error = ntfs_ntvattrget(ntmp, ip, NTFS_A_NAME, NULL, 0, &vap);
	if (error) {
		ntfs_ntput(ip);
		return (error);
	}
	*tm = vap->va_a_name->n_times;
	ntfs_ntvattrrele(vap);
	ntfs_ntput(ip);

	return (0);
}
#endif

a1981 5
#ifndef __OpenBSD__
ntfs_toupper_use(mp, ntmp)
	struct mount *mp;
	struct ntfsmount *ntmp;
#else
a1985 1
#endif
a2023 3
#ifndef __OpenBSD__
ntfs_toupper_unuse()
#else
a2025 1
#endif
@


1.16
log
@convert lockmgr over to rwlock in ntfs, mostly trivial.

Tested by a couple of people, no regressions.
@
text
@d443 1
a443 1
	VREF(ip->i_devvp);
d1022 1
a1022 1
				VREF(vp);
@


1.15
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.14 2007/12/09 21:28:53 hshoexer Exp $	*/
d42 1
a42 1
#include <sys/lock.h>
d97 1
a97 1
static struct lock ntfs_toupper_lock;
d392 1
a392 1
	lockmgr(&ip->i_lock, LK_EXCLUSIVE, NULL);
d431 1
a431 1
	} while (lockmgr(&ntfs_hashlock, LK_EXCLUSIVE | LK_SLEEPFAIL, NULL));
d446 1
a446 1
	lockinit(&ip->i_lock, PINOD, "ntnode", 0, LK_EXCLUSIVE);
d455 1
a455 1
	lockmgr(&ntfs_hashlock, LK_RELEASE, NULL);
d494 1
a494 1
		lockmgr(&ip->i_lock, LK_RELEASE, NULL);
a2056 1
	lockinit(&ntfs_toupper_lock, PVFS, "ntfs_toupper", 0, 0);
d2080 1
a2080 1
	lockmgr(&ntfs_toupper_lock, LK_EXCLUSIVE, NULL);
d2104 1
a2104 1
	lockmgr(&ntfs_toupper_lock, LK_RELEASE, NULL);
d2121 1
a2121 1
	lockmgr(&ntfs_toupper_lock, LK_EXCLUSIVE, NULL);
d2136 1
a2136 1
	lockmgr(&ntfs_toupper_lock, LK_RELEASE, NULL);
@


1.14
log
@MALLOC/FREE -> malloc/free

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.13 2007/10/06 02:18:39 krw Exp $	*/
a30 5

#include <sys/cdefs.h>
#ifdef __KERNEL_RCSID
__KERNEL_RCSID(0, "$NetBSD: ntfs_subr.c,v 1.4 2003/04/10 21:37:32 jdolecek Exp $");
#endif
@


1.13
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.12 2007/10/03 10:52:11 krw Exp $	*/
d826 1
a826 1
		FREE(fp->f_attrname, M_TEMP);
d828 1
a828 1
		FREE(fp->f_dirblbuf, M_NTFSDIR);
d1000 1
a1000 2
				MALLOC(tctx, struct ntfs_lookup_ctx *,
					sizeof(struct ntfs_lookup_ctx),
d1035 1
a1035 1
				FREE(attrname, M_TEMP);
d1128 1
a1128 1
			FREE(tctx, M_TEMP);
d1150 1
a1150 1
		FREE(attrname, M_TEMP);
d1155 1
a1155 1
			FREE(tctx, M_TEMP);
d1366 1
a1366 1
		FREE(bmp, M_TEMP);
d1863 4
a1866 4
		MALLOC(cup, u_int8_t *, ntfs_cntob(NTFS_COMPUNIT_CL),
		       M_NTFSDECOMP, M_WAITOK);
		MALLOC(uup, u_int8_t *, ntfs_cntob(NTFS_COMPUNIT_CL),
		       M_NTFSDECOMP, M_WAITOK);
d1910 2
a1911 2
		FREE(uup, M_NTFSDECOMP);
		FREE(cup, M_NTFSDECOMP);
d2098 2
a2099 2
	MALLOC(ntfs_toupper_tab, wchar *, 256 * 256 * sizeof(wchar),
		M_NTFSRDATA, M_WAITOK);
d2131 1
a2131 1
		FREE(ntfs_toupper_tab, M_NTFSRDATA);
@


1.12
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.11 2007/06/02 01:02:56 deraadt Exp $	*/
d516 1
a516 1
	FREE(ip, M_NTFSNTNODE);
d566 1
a566 1
	FREE(vap, M_NTFSNTVATTR);
d629 1
a629 1
		FREE(vap, M_NTFSNTVATTR);
d829 1
a829 1
	FREE(fp, M_NTFSFNODE);
@


1.11
log
@do the daddr_t -> daddr64_t or int32_t dance here as well
"this code sucks -- pedro", "just put it in -- tom".
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.10 2007/04/12 22:02:57 thib Exp $	*/
d438 1
a438 2
	MALLOC(ip, struct ntnode *, sizeof(struct ntnode),
	       M_NTFSNTNODE, M_WAITOK);
a439 1
	bzero((caddr_t) ip, sizeof(struct ntnode));
d585 1
a585 3
	MALLOC(vap, struct ntvattr *, sizeof(struct ntvattr),
		M_NTFSNTVATTR, M_WAITOK);
	bzero(vap, sizeof(struct ntvattr));
d793 1
a793 2
	MALLOC(fp, struct fnode *, sizeof(struct fnode), M_NTFSFNODE, M_WAITOK);
	bzero(fp, sizeof(struct fnode));
@


1.10
log
@Remove the i_interlock simplelock from struct ntnode
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.9 2006/03/05 21:48:57 miod Exp $	*/
d296 1
a296 1
	daddr_t         bn;
@


1.9
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.8 2005/11/19 02:18:01 pedro Exp $	*/
a394 1
	simple_lock(&ip->i_interlock);
d397 1
a397 1
	lockmgr(&ip->i_lock, LK_EXCLUSIVE | LK_INTERLOCK, &ip->i_interlock);
a453 1
	simple_lock_init(&ip->i_interlock);
a490 1
	simple_lock(&ip->i_interlock);
d501 1
a501 1
		lockmgr(&ip->i_lock, LK_RELEASE|LK_INTERLOCK, &ip->i_interlock);
a527 1
	simple_lock(&ip->i_interlock);
a528 1
	simple_unlock(&ip->i_interlock);
a544 1
	simple_lock(&ip->i_interlock);
a549 1
	simple_unlock(&ip->i_interlock);
@


1.8
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.7 2005/05/24 05:43:31 brad Exp $	*/
d154 1
a154 1
	for (vap = ip->i_valist.lh_first; vap; vap = vap->va_list.le_next) {
d788 1
a788 1
	for (fp = ip->i_fnlist.lh_first; fp != NULL; fp = fp->f_fnlist.le_next){
@


1.7
log
@Fix our NTFS readdir function.

To check a directory's in-use bitmap bit by bit, we use
a pointer to an 8 bit wide unsigned value.

The index used to dereference this pointer is calculated
by shifting the bit index right 3 bits.  Then we do a
logical AND with the bit# represented by the lower 3
bits of the bit index.

This is an idiomatic way of iterating through a bit map
with simple bitwise operations.

This commit fixes the bug that we only checked bits
3:0 of each 8 bit chunk, because we only used bits 1:0
of the bit index for the bit# in the current 8 bit value.
This resulted in files not being returned by getdirentries(2).

Change the type of the bit map pointer from `char *' to
`u_int8_t *'.

From FreeBSD

ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.6 2005/05/22 04:38:54 brad Exp $	*/
d397 1
a397 1
#ifndef __OpenBSD__
a398 3
#else
	lockmgr(&ip->i_lock, LK_EXCLUSIVE | LK_INTERLOCK, &ip->i_interlock, p);
#endif
a436 1
#ifndef __OpenBSD__
a437 3
#else
	} while (lockmgr(&ntfs_hashlock, LK_EXCLUSIVE | LK_SLEEPFAIL, NULL, p));
#endif
a463 1
#ifndef __OpenBSD__
a464 3
#else
	lockmgr(&ntfs_hashlock, LK_RELEASE, NULL, p);
#endif
a503 1
#ifndef __OpenBSD__
a504 3
#else
		lockmgr(&ip->i_lock, LK_RELEASE|LK_INTERLOCK, &ip->i_interlock, p);
#endif
a2098 1
#ifndef __OpenBSD__
d2100 1
a2100 4
#else
	lockmgr(&ntfs_toupper_lock, LK_EXCLUSIVE, NULL, p);
#endif
	
a2122 1
#ifndef __OpenBSD__
a2123 3
#else
	lockmgr(&ntfs_toupper_lock, LK_RELEASE, NULL, p);
#endif
a2139 1
#ifndef __OpenBSD__
a2140 3
#else
	lockmgr(&ntfs_toupper_lock, LK_EXCLUSIVE, NULL, p);
#endif
a2154 1
#ifndef __OpenBSD__
d2156 1
a2156 4
#else
	lockmgr(&ntfs_toupper_lock, LK_RELEASE, NULL, p);
#endif
} 
@


1.6
log
@The printf(9) `%p' conversion specifier puts an "0x" in
front of the pointer value.  Therefore, remove the "0x"
from the format string.

From FreeBSD

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.5 2005/05/21 18:05:58 brad Exp $	*/
d1247 1
a1247 1
	u_char         *bmp = NULL;	/* Bitmap */
d1288 1
a1288 1
		bmp = (u_char *) malloc(bmvap->va_datalen, M_TEMP, M_WAITOK);
d1370 1
a1370 1
				if (bmp[blnum >> 3] & (1 << (blnum & 3)))
@


1.5
log
@- use MIN()/MAX() rather than min()/max(), to avoid possible truncation
  of 64bit values to 'int'
- read always single cluster of data, to avoid confusing the buffer
  cache; this appears to fix the random file content corruption which
  happens when more than one cluster is read at the same time, i.e. for
  files > 3*cluster_size
- fix some questionable pointer arithmetics; gcc-3.4.x didn't like it
- g/c redundant debug printf
- remove all traces of non-working quota support
  add quota support to TODO - makes sense only once writing support
  would be implemented, and only once NTFS would support notion of file 'owner'
- use 64bit local variable for free space computation

From NetBSD

- Comment fixes from joris@@

ok millert@@ joris@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.4 2005/03/08 15:45:20 pat Exp $	*/
d1279 1
a1279 1
	dprintf(("ntfs_ntreaddir: rdbuf: 0x%p, blsize: %d\n", rdbuf, blsize));
d2053 1
a2053 1
	printf("ntfs_runtocn: run: 0x%p, %ld bytes, vcn:%ld\n",
@


1.4
log
@fix a page fault that occurs when a reclaimed vnode is then reused.
from FreeBSD

ok pedro tedu miod, tested by millert and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.3 2003/05/20 03:36:42 tedu Exp $	*/
a982 3
	dprintf(("ntfs_ntlookupfile: blksz: %d\n", blsize, rdsize));


d1273 1
a1273 1
		       max(vap->va_datalen,fp->f_dirblsz), M_NTFSDIR, M_WAITOK);
d1494 1
a1494 1
 * This is one of write routine.
d1520 1
a1520 1
		towrite = min(left, ntfs_cntob(vap->va_vcnend + 1) - off);
d1549 1
a1549 1
 * This is one of write routine.
d1609 7
a1615 2
			tocopy = min(left,
				  min(ntfs_cntob(ccl) - off, MAXBSIZE - off));
d1617 1
d1659 1
a1659 1
 * This is one of read routines.
a1712 5
					tocopy = min(left,
						  min(ntfs_cntob(ccl) - off,
						      MAXBSIZE - off));
					cl = ntfs_btocl(tocopy + off);

d1714 5
a1718 5
					 * If 'off' pushes us to next
					 * block, don't attempt to read whole
					 * 'tocopy' at once. This is to avoid
					 * bread() with varying 'size' for
					 * same 'blkno', which is not good.
d1720 5
a1724 5
					if (cl > ntfs_btocl(tocopy)) {
						tocopy -=
						    ntfs_btocnoff(tocopy + off);
						cl--;
					}
d1758 1
a1758 1
				tocopy = min(left, ntfs_cntob(ccl) - off);
d1820 1
a1820 1
		toread = min(left, ntfs_cntob(vap->va_vcnend + 1) - off);
d1907 1
a1907 1
			tocopy = min(left, ntfs_cntob(NTFS_COMPUNIT_CL) - off);
d2032 1
a2032 1
		((caddr_t) cfxp) += ntmp->ntm_bps;
@


1.3
log
@un __P
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.2 2003/05/20 03:23:12 mickey Exp $	*/
d379 1
a379 1
		
d458 1
d514 1
d516 1
a516 1
	lockmgr(&ip->i_lock, LK_RELEASE|LK_INTERLOCK, &ip->i_interlock);
d518 1
a518 1
	lockmgr(&ip->i_lock, LK_RELEASE|LK_INTERLOCK, &ip->i_interlock, p);
d520 2
d523 1
a523 3
	if (ip->i_usecount == 0) {
		dprintf(("ntfs_ntput: deallocating ntnode: %d\n",
			ip->i_number));
d525 2
a526 2
		if (ip->i_fnlist.lh_first)
			panic("ntfs_ntput: ntnode has fnodes");
d528 1
a528 1
		ntfs_nthashrem(ip);
d530 3
a532 6
		while (ip->i_valist.lh_first != NULL) {
			vap = ip->i_valist.lh_first;
			LIST_REMOVE(vap,va_list);
			ntfs_freentvattr(vap);
		}
		FREE(ip, M_NTFSNTNODE);
d534 3
@


1.3.2.1
log
@add file to SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@fix the tags
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_subr.c,v 1.1 2003/05/20 03:03:27 tedu Exp $	*/
d92 4
a95 4
static int ntfs_ntlookupattr __P((struct ntfsmount *, const char *, int, int *, char **));
static int ntfs_findvattr __P((struct ntfsmount *, struct ntnode *, struct ntvattr **, struct ntvattr **, u_int32_t, const char *, size_t, cn_t));
static int ntfs_uastricmp __P((struct ntfsmount *, const wchar *, size_t, const char *, size_t));
static int ntfs_uastrcmp __P((struct ntfsmount *, const wchar *, size_t, const char *, size_t));
@


1.1
log
@by popular request, NTFS support.  read only.
The code comes from NetBSD and was ported by Julian Bordet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id$	*/
@

