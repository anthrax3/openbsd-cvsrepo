head	1.56;
access;
symbols
	OPENBSD_6_2_BASE:1.56
	OPENBSD_6_1:1.56.0.4
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.28.0.4
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.2
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	SMP:1.4.0.2;
locks; strict;
comment	@ * @;


1.56
date	2017.03.20.16.44.03;	author jca;	state Exp;
branches;
next	1.55;
commitid	S3Yk4ZW0Ynxtc7qk;

1.55
date	2016.09.07.17.30.12;	author natano;	state Exp;
branches;
next	1.54;
commitid	D0avTYSlvEmEjLyB;

1.54
date	2016.09.01.08.40.39;	author natano;	state Exp;
branches;
next	1.53;
commitid	NvsKsQuRDuQNpuOz;

1.53
date	2016.08.13.20.53.17;	author guenther;	state Exp;
branches;
next	1.52;
commitid	15rk0aE492iEzsGW;

1.52
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.51;
commitid	wHLNY5GFNXJSFYaC;

1.51
date	2016.05.22.20.27.04;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	IMex9jbP378m0AFa;

1.50
date	2016.04.26.18.37.03;	author natano;	state Exp;
branches;
next	1.49;
commitid	WbumX8gCUOD8jZ5X;

1.49
date	2016.03.27.11.39.37;	author bluhm;	state Exp;
branches;
next	1.48;
commitid	C0IKsjKoZxFScK3M;

1.48
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.47;
commitid	gAjwyca5TfuoJAhn;

1.47
date	2016.03.17.18.52.31;	author bluhm;	state Exp;
branches;
next	1.46;
commitid	XOU3hWgTktDOU9BT;

1.46
date	2016.03.05.20.40.05;	author natano;	state Exp;
branches;
next	1.45;
commitid	sN6b5HrgHlg7qQZo;

1.45
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.44;
commitid	gFybgYMymUyTbVeS;

1.44
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.43;
commitid	p4LJxGKbi0BU2cG6;

1.43
date	2014.12.16.19.56.33;	author tedu;	state Exp;
branches;
next	1.42;
commitid	QDtD6hT4TizWpQLS;

1.42
date	2014.12.09.07.16.41;	author doug;	state Exp;
branches;
next	1.41;
commitid	tPDMRisjAolmdVN1;

1.41
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.40;
commitid	Qb045HZ5OhQfU69H;

1.40
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.39;
commitid	FE3DG5cICjyI4jWx;

1.39
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	EF98ch02VpFassUi;

1.38
date	2014.01.19.18.35.45;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2013.12.02.16.05.07;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2013.11.24.16.02.30;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2013.05.30.20.11.06;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.18.05.09.21;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.14.02.41.03;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.13.04.07.49;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.02.08.12.13;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2012.09.10.11.11.00;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.20.09.13.07;	author mikeb;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.03.17.17.41;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.07.00.41.05;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.04.21.35.58;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.22.21.23.07;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2010.08.12.04.05.03;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.08.01.28.33;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.03.00.12.31;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.29.04.09.32;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.13.16.00.53;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.10.15.55.07;	author pedro;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.21.18.05.58;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.08.15.45.20;	author pat;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.01.11.29.59;	author pedro;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.09.22.58.57;	author pat;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.24.21.48.05;	author tedu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.05.20.03.36.42;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.20.03.23.12;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.20.03.03.27;	author tedu;	state Exp;
branches;
next	;

1.4.2.1
date	2003.06.07.10.47.03;	author ho;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.02.19.10.57.27;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Read the free clusters bitmap in 1MB chunks

instead of trying to read it in one go and panic in malloc(9) with large
NTFS filesystems.  panic reported and fix tested by landry@@
@
text
@/*	$OpenBSD: ntfs_vfsops.c,v 1.55 2016/09/07 17:30:12 natano Exp $	*/
/*	$NetBSD: ntfs_vfsops.c,v 1.7 2003/04/24 07:50:19 christos Exp $	*/

/*-
 * Copyright (c) 1998, 1999 Semen Ustimenko
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	Id: ntfs_vfsops.c,v 1.7 1999/05/31 11:28:30 phk Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/disk.h>
#include <sys/fcntl.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/specdev.h>

/*#define NTFS_DEBUG 1*/
#include <ntfs/ntfs.h>
#include <ntfs/ntfs_inode.h>
#include <ntfs/ntfs_subr.h>
#include <ntfs/ntfs_vfsops.h>
#include <ntfs/ntfs_ihash.h>

int	ntfs_mount(struct mount *, const char *, void *,
				struct nameidata *, struct proc *);
int	ntfs_quotactl(struct mount *, int, uid_t, caddr_t,
				   struct proc *);
int	ntfs_root(struct mount *, struct vnode **);
int	ntfs_start(struct mount *, int, struct proc *);
int	ntfs_statfs(struct mount *, struct statfs *,
				 struct proc *);
int	ntfs_sync(struct mount *, int, struct ucred *,
			       struct proc *);
int	ntfs_unmount(struct mount *, int, struct proc *);
int	ntfs_vget(struct mount *mp, ino_t ino,
			       struct vnode **vpp);
int	ntfs_mountfs(struct vnode *, struct mount *, 
				  struct ntfs_args *, struct proc *);
int	ntfs_vptofh(struct vnode *, struct fid *);

int	ntfs_init(struct vfsconf *);
int	ntfs_fhtovp(struct mount *, struct fid *,
   			     struct vnode **);
int	ntfs_checkexp(struct mount *, struct mbuf *,
			       int *, struct ucred **);
int	ntfs_sysctl(int *, u_int, void *, size_t *, void *,
 			     size_t, struct proc *);

/*
 * Verify a remote client has export rights and return these rights via.
 * exflagsp and credanonp.
 */
int
ntfs_checkexp(struct mount *mp, struct mbuf *nam, int *exflagsp,
    struct ucred **credanonp)
{
	struct netcred *np;
	struct ntfsmount *ntm = VFSTONTFS(mp);

	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &ntm->ntm_export, nam);
	if (np == NULL)
		return (EACCES);

	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
	return (0);
}

int
ntfs_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	return (EINVAL);
}

int
ntfs_init(struct vfsconf *vcp)
{
	return 0;
}

int
ntfs_mount(struct mount *mp, const char *path, void *data,
    struct nameidata *ndp, struct proc *p)
{
	int		err = 0;
	struct vnode	*devvp;
	struct ntfs_args args;
	char fname[MNAMELEN];
	char fspec[MNAMELEN];

	ntfs_nthashinit();

	/*
	 ***
	 * Mounting non-root file system or updating a file system
	 ***
	 */

	/* copy in user arguments*/
	err = copyin(data, (caddr_t)&args, sizeof (struct ntfs_args));
	if (err)
		goto error_1;		/* can't get arguments*/

	/*
	 * If updating, check whether changing from read-only to
	 * read/write; if there is no device name, that's all we do.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		/* if not updating name...*/
		if (args.fspec == NULL) {
			/*
			 * Process export requests.  Jumping to "success"
			 * will return the vfs_export() error code.
			 */
			struct ntfsmount *ntm = VFSTONTFS(mp);
			err = vfs_export(mp, &ntm->ntm_export, &args.export_info);
			goto success;
		}

		printf("ntfs_mount(): MNT_UPDATE not supported\n");
		err = EINVAL;
		goto error_1;
	}

	/*
	 * Not an update, or updating the name: look up the name
	 * and verify that it refers to a sensible block device.
	 */
	err = copyinstr(args.fspec, fspec, sizeof(fspec), NULL);
	if (err)
		goto error_1;

	if (disk_map(fspec, fname, sizeof(fname), DM_OPENBLCK) == -1)
		bcopy(fspec, fname, sizeof(fname));

	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fname, p);
	err = namei(ndp);
	if (err) {
		/* can't get devvp!*/
		goto error_1;
	}

	devvp = ndp->ni_vp;

	if (devvp->v_type != VBLK) {
		err = ENOTBLK;
		goto error_2;
	}

	if (major(devvp->v_rdev) >= nblkdev) {
		err = ENXIO;
		goto error_2;
	}

	if (mp->mnt_flag & MNT_UPDATE) {
#if 0
		/*
		 ********************
		 * UPDATE
		 ********************
		 */

		if (devvp != ntmp->um_devvp)
			err = EINVAL;	/* needs translation */
		else
			vrele(devvp);
		/*
		 * Update device name only on success
		 */
		if( !err) {
			err = set_statfs_info(NULL, UIO_USERSPACE, args.fspec,
			    UIO_USERSPACE, mp, p);
		}
#endif
	} else {
		/*
		 ********************
		 * NEW MOUNT
		 ********************
		 */

		/*
		 * Since this is a new mount, we want the names for
		 * the device and the mount point copied in.  If an
		 * error occurs,  the mountpoint is discarded by the
		 * upper level code.
		 */
		/* Save "last mounted on" info for mount point (NULL pad)*/
		bzero(mp->mnt_stat.f_mntonname, MNAMELEN);
		strlcpy(mp->mnt_stat.f_mntonname, path, MNAMELEN);
		bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
		strlcpy(mp->mnt_stat.f_mntfromname, fname, MNAMELEN);
		bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
		strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);
		bcopy(&args, &mp->mnt_stat.mount_info.ntfs_args, sizeof(args));
		if ( !err) {
			err = ntfs_mountfs(devvp, mp, &args, p);
		}
	}
	if (err) {
		goto error_2;
	}

	/*
	 * Initialize FS stat information in mount struct; uses both
	 * mp->mnt_stat.f_mntonname and mp->mnt_stat.f_mntfromname
	 *
	 * This code is common to root and non-root mounts
	 */
	(void)VFS_STATFS(mp, &mp->mnt_stat, p);

	goto success;


error_2:	/* error with devvp held*/

	/* release devvp before failing*/
	vrele(devvp);

error_1:	/* no state to back out*/

success:
	return(err);
}

/*
 * Common code for mount and mountroot
 */
int
ntfs_mountfs(struct vnode *devvp, struct mount *mp, struct ntfs_args *argsp,
    struct proc *p)
{
	struct buf *bp;
	struct ntfsmount *ntmp = NULL;
	dev_t dev = devvp->v_rdev;
	int error, ncount, i;
	struct vnode *vp;

	/*
	 * Disallow multiple mounts of the same device.
	 * Disallow mounting of a device that is currently in use
	 * (except for root, which might share swap device for miniroot).
	 * Flush out any old buffers remaining from a previous use.
	 */
	error = vfs_mountedon(devvp);
	if (error)
		return (error);
	ncount = vcount(devvp);
	if (ncount > 1 && devvp != rootvp)
		return (EBUSY);
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0);
	VOP_UNLOCK(devvp, p);
	if (error)
		return (error);

	error = VOP_OPEN(devvp, FREAD, FSCRED, p);
	if (error)
		return (error);

	bp = NULL;

	error = bread(devvp, BBLOCK, BBSIZE, &bp);
	if (error)
		goto out;
	ntmp = malloc(sizeof *ntmp, M_NTFSMNT, M_WAITOK | M_ZERO);
	bcopy(bp->b_data, &ntmp->ntm_bootfile, sizeof(struct bootfile));
	brelse(bp);
	bp = NULL;

	if (strncmp(ntmp->ntm_bootfile.bf_sysid, NTFS_BBID, NTFS_BBIDLEN)) {
		error = EINVAL;
		DPRINTF("ntfs_mountfs: invalid boot block\n");
		goto out;
	}

	{
		int8_t cpr = ntmp->ntm_mftrecsz;
		if( cpr > 0 )
			ntmp->ntm_bpmftrec = ntmp->ntm_spc * cpr;
		else
			ntmp->ntm_bpmftrec = (1 << (-cpr)) / ntmp->ntm_bps;
	}
	DPRINTF("ntfs_mountfs(): bps: %u, spc: %u, media: %x, "
	    "mftrecsz: %u (%u sects)\n", ntmp->ntm_bps, ntmp->ntm_spc,
	    ntmp->ntm_bootfile.bf_media, ntmp->ntm_mftrecsz,
	    ntmp->ntm_bpmftrec);
	DPRINTF("ntfs_mountfs(): mftcn: 0x%llx|0x%llx\n",
	    ntmp->ntm_mftcn, ntmp->ntm_mftmirrcn);

	ntmp->ntm_mountp = mp;
	ntmp->ntm_dev = dev;
	ntmp->ntm_devvp = devvp;
	ntmp->ntm_uid = argsp->uid;
	ntmp->ntm_gid = argsp->gid;
	ntmp->ntm_mode = argsp->mode;
	ntmp->ntm_flag = argsp->flag;
	mp->mnt_data = ntmp;
	TAILQ_INIT(&ntmp->ntm_ntnodeq);

	/* set file name encode/decode hooks XXX utf-8 only for now */
	ntmp->ntm_wget = ntfs_utf8_wget;
	ntmp->ntm_wput = ntfs_utf8_wput;
	ntmp->ntm_wcmp = ntfs_utf8_wcmp;

	DPRINTF("ntfs_mountfs(): case-%s,%s uid: %d, gid: %d, mode: %o\n",
	    (ntmp->ntm_flag & NTFS_MFLAG_CASEINS) ? "insens." : "sens.",
	    (ntmp->ntm_flag & NTFS_MFLAG_ALLNAMES) ? " allnames," : "",
	    ntmp->ntm_uid, ntmp->ntm_gid, ntmp->ntm_mode);

	/*
	 * We read in some system nodes to do not allow 
	 * reclaim them and to have everytime access to them.
	 */ 
	{
		int pi[3] = { NTFS_MFTINO, NTFS_ROOTINO, NTFS_BITMAPINO };
		for (i=0; i<3; i++) {
			error = VFS_VGET(mp, pi[i], &(ntmp->ntm_sysvn[pi[i]]));
			if(error)
				goto out1;
			ntmp->ntm_sysvn[pi[i]]->v_flag |= VSYSTEM;
			vref(ntmp->ntm_sysvn[pi[i]]);
			vput(ntmp->ntm_sysvn[pi[i]]);
		}
	}

	/* read the Unicode lowercase --> uppercase translation table,
	 * if necessary */
	if ((error = ntfs_toupper_use(mp, ntmp, p)))
		goto out1;

	/*
	 * Scan $BitMap and count free clusters
	 */
	error = ntfs_calccfree(ntmp, &ntmp->ntm_cfree);
	if(error)
		goto out1;

	/*
	 * Read and translate to internal format attribute
	 * definition file. 
	 */
	{
		int num,j;
		struct attrdef ad;

		/* Open $AttrDef */
		error = VFS_VGET(mp, NTFS_ATTRDEFINO, &vp );
		if(error) 
			goto out1;

		/* Count valid entries */
		for(num = 0; ; num++) {
			error = ntfs_readattr(ntmp, VTONT(vp),
			    NTFS_A_DATA, NULL, num * sizeof(ad), sizeof(ad),
			    &ad, NULL);
			if (error)
				goto out1;
			if (ad.ad_name[0] == 0)
				break;
		}

		/* Alloc memory for attribute definitions */
		ntmp->ntm_ad = mallocarray(num, sizeof(struct ntvattrdef),
		    M_NTFSMNT, M_WAITOK);

		ntmp->ntm_adnum = num;

		/* Read them and translate */
		for(i = 0; i < num; i++){
			error = ntfs_readattr(ntmp, VTONT(vp),
			    NTFS_A_DATA, NULL, i * sizeof(ad), sizeof(ad),
			    &ad, NULL);
			if (error)
				goto out1;
			j = 0;
			do {
				ntmp->ntm_ad[i].ad_name[j] = ad.ad_name[j];
			} while(ad.ad_name[j++]);
			ntmp->ntm_ad[i].ad_namelen = j - 1;
			ntmp->ntm_ad[i].ad_type = ad.ad_type;
		}

		vput(vp);
	}

	mp->mnt_stat.f_fsid.val[0] = dev;
	mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
	mp->mnt_stat.f_namemax = NTFS_MAXFILENAME;
	mp->mnt_flag |= MNT_LOCAL;
	devvp->v_specmountpoint = mp;
	return (0);

out1:
	for (i = 0; i < NTFS_SYSNODESNUM; i++)
		if (ntmp->ntm_sysvn[i])
			vrele(ntmp->ntm_sysvn[i]);

	if (vflush(mp,NULLVP,0))
		DPRINTF("ntfs_mountfs: vflush failed\n");

out:
	if (devvp->v_specinfo)
		devvp->v_specmountpoint = NULL;
	if (bp)
		brelse(bp);

	if (ntmp != NULL) {
		if (ntmp->ntm_ad != NULL)
			free(ntmp->ntm_ad, M_NTFSMNT, 0);
		free(ntmp, M_NTFSMNT, 0);
		mp->mnt_data = NULL;
	}

	/* lock the device vnode before calling VOP_CLOSE() */
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	(void)VOP_CLOSE(devvp, FREAD, NOCRED, p);
	VOP_UNLOCK(devvp, p);
	
	return (error);
}

int
ntfs_start(struct mount *mp, int flags, struct proc *p)
{
	return (0);
}

int
ntfs_unmount(struct mount *mp, int mntflags, struct proc *p)
{
	struct ntfsmount *ntmp;
	int error, flags, i;

	DPRINTF("ntfs_unmount: unmounting...\n");
	ntmp = VFSTONTFS(mp);

	flags = 0;
	if(mntflags & MNT_FORCE)
		flags |= FORCECLOSE;

	DPRINTF("ntfs_unmount: vflushing...\n");
	error = vflush(mp,NULLVP,flags | SKIPSYSTEM);
	if (error) {
		DPRINTF("ntfs_unmount: vflush failed: %d\n", error);
		return (error);
	}

	/* Check if system vnodes are still referenced */
	for(i=0;i<NTFS_SYSNODESNUM;i++) {
		if(((mntflags & MNT_FORCE) == 0) && (ntmp->ntm_sysvn[i] &&
		    ntmp->ntm_sysvn[i]->v_usecount > 1))
			return (EBUSY);
	}

	/* Dereference all system vnodes */
	for(i=0;i<NTFS_SYSNODESNUM;i++)
		 if(ntmp->ntm_sysvn[i]) vrele(ntmp->ntm_sysvn[i]);

	/* vflush system vnodes */
	error = vflush(mp,NULLVP,flags);
	if (error) {
		/* XXX should this be panic() ? */
		printf("ntfs_unmount: vflush failed(sysnodes): %d\n",error);
	}

	/* Check if the type of device node isn't VBAD before
	 * touching v_specinfo.  If the device vnode is revoked, the
	 * field is NULL and touching it causes null pointer derefercence.
	 */
	if (ntmp->ntm_devvp->v_type != VBAD)
		ntmp->ntm_devvp->v_specmountpoint = NULL;

	/* lock the device vnode before calling VOP_CLOSE() */
	vn_lock(ntmp->ntm_devvp, LK_EXCLUSIVE | LK_RETRY, p);
	vinvalbuf(ntmp->ntm_devvp, V_SAVE, NOCRED, p, 0, 0);
	(void)VOP_CLOSE(ntmp->ntm_devvp, FREAD, NOCRED, p);
	vput(ntmp->ntm_devvp);

	/* free the toupper table, if this has been last mounted ntfs volume */
	ntfs_toupper_unuse(p);

	DPRINTF("ntfs_unmount: freeing memory...\n");
	free(ntmp->ntm_ad, M_NTFSMNT, 0);
	free(ntmp, M_NTFSMNT, 0);
	mp->mnt_data = NULL;
	mp->mnt_flag &= ~MNT_LOCAL;
	return (0);
}

int
ntfs_root(struct mount *mp, struct vnode **vpp)
{
	struct vnode *nvp;
	int error = 0;

	DPRINTF("ntfs_root(): sysvn: %p\n",
	    VFSTONTFS(mp)->ntm_sysvn[NTFS_ROOTINO]);
	error = VFS_VGET(mp, (ino_t)NTFS_ROOTINO, &nvp);
	if(error) {
		printf("ntfs_root: VFS_VGET failed: %d\n",error);
		return (error);
	}

	*vpp = nvp;
	return (0);
}

/*
 * Do operations associated with quotas, not supported
 */
int
ntfs_quotactl(struct mount *mp, int cmds, uid_t uid, caddr_t arg,
    struct proc *p)
{
	return EOPNOTSUPP;
}

int
ntfs_calccfree(struct ntfsmount *ntmp, cn_t *cfreep)
{
	struct vnode *vp;
	u_int8_t *tmp;
	int j, error;
	cn_t cfree = 0;
	uint64_t bmsize, offset;
	size_t chunksize, i;

	vp = ntmp->ntm_sysvn[NTFS_BITMAPINO];

	bmsize = VTOF(vp)->f_size;

	if (bmsize > 1024 * 1024)
		chunksize = 1024 * 1024;
	else
		chunksize = bmsize;

	tmp = malloc(chunksize, M_TEMP, M_WAITOK);

	for (offset = 0; offset < bmsize; offset += chunksize) {
		if (chunksize > bmsize - offset)
			chunksize = bmsize - offset;

		error = ntfs_readattr(ntmp, VTONT(vp), NTFS_A_DATA, NULL,
		    offset, chunksize, tmp, NULL);
		if (error)
			goto out;

		for (i = 0; i < chunksize; i++)
			for (j = 0; j < 8; j++)
				if (~tmp[i] & (1 << j))
					cfree++;
	}

	*cfreep = cfree;

    out:
	free(tmp, M_TEMP, 0);
	return(error);
}

int
ntfs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	struct ntfsmount *ntmp = VFSTONTFS(mp);
	u_int64_t mftallocated;

	DPRINTF("ntfs_statfs():\n");

	mftallocated = VTOF(ntmp->ntm_sysvn[NTFS_MFTINO])->f_allocated;

	sbp->f_bsize = ntmp->ntm_bps;
	sbp->f_iosize = ntmp->ntm_bps * ntmp->ntm_spc;
	sbp->f_blocks = ntmp->ntm_bootfile.bf_spv;
	sbp->f_bfree = sbp->f_bavail = ntfs_cntobn(ntmp->ntm_cfree);
	sbp->f_ffree = sbp->f_favail = sbp->f_bfree / ntmp->ntm_bpmftrec;
	sbp->f_files = mftallocated / ntfs_bntob(ntmp->ntm_bpmftrec) +
		       sbp->f_ffree;
	copy_statfs_info(sbp, mp);

	return (0);
}

int
ntfs_sync(struct mount *mp, int waitfor, struct ucred *cred, struct proc *p)
{
	/*DPRINTF("ntfs_sync():\n");*/
	return (0);
}

int
ntfs_fhtovp(struct mount *mp, struct fid *fhp, struct vnode **vpp)
{
	struct ntfid *ntfhp = (struct ntfid *)fhp;
	int error;

	DDPRINTF("ntfs_fhtovp(): %s: %u\n",
	    mp->mnt_stat.f_mntonname, ntfhp->ntfid_ino);

	error = ntfs_vgetex(mp, ntfhp->ntfid_ino, ntfhp->ntfid_attr, NULL,
			LK_EXCLUSIVE | LK_RETRY, 0, curproc, vpp); /* XXX */
	if (error != 0) {
		*vpp = NULLVP;
		return (error);
	}

	/* XXX as unlink/rmdir/mkdir/creat are not currently possible
	 * with NTFS, we don't need to check anything else for now */
	return (0);
}

int
ntfs_vptofh(struct vnode *vp, struct fid *fhp)
{
	struct ntnode *ntp;
	struct ntfid *ntfhp;
	struct fnode *fn;

	DDPRINTF("ntfs_fhtovp(): %s: %p\n",
	    vp->v_mount->mnt_stat.f_mntonname, vp);

	fn = VTOF(vp);
	ntp = VTONT(vp);
	ntfhp = (struct ntfid *)fhp;
	ntfhp->ntfid_len = sizeof(struct ntfid);
	ntfhp->ntfid_ino = ntp->i_number;
	ntfhp->ntfid_attr = fn->f_attrtype;
#ifdef notyet
	ntfhp->ntfid_gen = ntp->i_gen;
#endif
	return (0);
}

int
ntfs_vgetex(struct mount *mp, ntfsino_t ino, u_int32_t attrtype, char *attrname,
    u_long lkflags, u_long flags, struct proc *p, struct vnode **vpp) 
{
	int error;
	struct ntfsmount *ntmp;
	struct ntnode *ip;
	struct fnode *fp;
	struct vnode *vp;
	enum vtype f_type;

	DPRINTF("ntfs_vgetex: ino: %u, attr: 0x%x:%s, lkf: 0x%lx, f: 0x%lx\n",
	    ino, attrtype, attrname ? attrname : "", lkflags, flags);

	ntmp = VFSTONTFS(mp);
	*vpp = NULL;

	/* Get ntnode */
	error = ntfs_ntlookup(ntmp, ino, &ip, p);
	if (error) {
		printf("ntfs_vget: ntfs_ntget failed\n");
		return (error);
	}

	/* It may be not initialized fully, so force load it */
	if (!(flags & VG_DONTLOADIN) && !(ip->i_flag & IN_LOADED)) {
		error = ntfs_loadntnode(ntmp, ip);
		if(error) {
			printf("ntfs_vget: CAN'T LOAD ATTRIBUTES FOR INO: %d\n",
			       ip->i_number);
			ntfs_ntput(ip, p);

			return (error);
		}
	}

	error = ntfs_fget(ntmp, ip, attrtype, attrname, &fp);
	if (error) {
		printf("ntfs_vget: ntfs_fget failed\n");
		ntfs_ntput(ip, p);

		return (error);
	}

	if (!(flags & VG_DONTVALIDFN) && !(fp->f_flag & FN_VALID)) {
		if ((ip->i_frflag & NTFS_FRFLAG_DIR) &&
		    (fp->f_attrtype == NTFS_A_DATA && fp->f_attrname == NULL)) {
			f_type = VDIR;
		} else if (flags & VG_EXT) {
			f_type = VNON;
			fp->f_size = fp->f_allocated = 0;
		} else {
			f_type = VREG;	

			error = ntfs_filesize(ntmp, fp, 
					      &fp->f_size, &fp->f_allocated);
			if (error) {
				ntfs_ntput(ip, p);

				return (error);
			}
		}

		fp->f_flag |= FN_VALID;
	}

	/*
	 * We may be calling vget() now. To avoid potential deadlock, we need
	 * to release ntnode lock, since due to locking order vnode
	 * lock has to be acquired first.
	 * ntfs_fget() bumped ntnode usecount, so ntnode won't be recycled
	 * prematurely.
	 */
	ntfs_ntput(ip, p);

	if (FTOV(fp)) {
		/* vget() returns error if the vnode has been recycled */
		if (vget(FTOV(fp), lkflags, p) == 0) {
			*vpp = FTOV(fp);
			return (0);
		}
	}

	error = getnewvnode(VT_NTFS, ntmp->ntm_mountp, &ntfs_vops, &vp);
	if(error) {
		ntfs_frele(fp);
		ntfs_ntput(ip, p);

		return (error);
	}
	DPRINTF("ntfs_vget: vnode: %p for ntnode: %u\n", vp, ino);

	fp->f_vp = vp;
	vp->v_data = fp;
	vp->v_type = f_type;

	if (ino == NTFS_ROOTINO)
		vp->v_flag |= VROOT;

	if (lkflags & LK_TYPE_MASK) {
		error = vn_lock(vp, lkflags, p);
		if (error) {
			vput(vp);
			return (error);
		}
	}

	*vpp = vp;
	return (0);
}

int
ntfs_vget(struct mount *mp, ino_t ino, struct vnode **vpp) 
{
	if (ino > (ntfsino_t)-1)
		panic("ntfs_vget: alien ino_t %llu", (unsigned long long)ino);
	return ntfs_vgetex(mp, ino, NTFS_A_DATA, NULL,
			LK_EXCLUSIVE | LK_RETRY, 0, curproc, vpp); /* XXX */
}

const struct vfsops ntfs_vfsops = {
	ntfs_mount,
	ntfs_start,
	ntfs_unmount,
	ntfs_root,
	ntfs_quotactl,
	ntfs_statfs,
	ntfs_sync,
	ntfs_vget,
	ntfs_fhtovp,
	ntfs_vptofh,
	ntfs_init,
	ntfs_sysctl,
	ntfs_checkexp,
};
@


1.55
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.54 2016/09/01 08:40:39 natano Exp $	*/
d561 2
a562 1
	size_t bmsize, i;
d568 21
a588 6
	tmp = malloc(bmsize, M_TEMP, M_WAITOK);

	error = ntfs_readattr(ntmp, VTONT(vp), NTFS_A_DATA, NULL,
			       0, bmsize, tmp, NULL);
	if (error)
		goto out;
a589 3
	for(i=0;i<bmsize;i++)
		for(j=0;j<8;j++)
			if(~tmp[i] & (1 << j)) cfree++;
@


1.54
log
@Remove the unused ntfs write code. ok benno beck
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.53 2016/08/13 20:53:17 guenther Exp $	*/
a187 12
	}

	/*
	 * If we are not root, make sure we have permission to access the
	 * requested device.
	 */
	if (p->p_ucred->cr_uid) {
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
		err = VOP_ACCESS(devvp, VREAD, p->p_ucred, p);
		VOP_UNLOCK(devvp, p);
		if (err)
			goto error_2;
@


1.53
log
@Eliminate pointless casts to qaddr_t of a value being assigned to a void*

ok kettenis@@ krw@@ natano@@ dlg@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.52 2016/06/19 11:54:33 natano Exp $	*/
a124 1
	mode_t amode;
a194 1
		amode = (mp->mnt_flag & MNT_RDONLY) ? VREAD : (VREAD | VWRITE);
d196 1
a196 1
		err = VOP_ACCESS(devvp, amode, p->p_ucred, p);
d283 1
a283 1
	int error, ronly, ncount, i;
d304 1
a304 2
	ronly = (mp->mnt_flag & MNT_RDONLY) != 0;
	error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p);
d464 1
a464 1
	(void)VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED, p);
d480 1
a480 1
	int error, ronly = 0, flags, i;
d524 1
a524 2
	(void)VOP_CLOSE(ntmp->ntm_devvp, ronly ? FREAD : FREAD|FWRITE,
	    NOCRED, p);
@


1.52
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.51 2016/05/22 20:27:04 bluhm Exp $	*/
d348 1
a348 1
	mp->mnt_data = (qaddr_t) ntmp;
@


1.51
log
@When pulling an msdos formated umass stick during mount while the
usb stack was busy, the kernel could trigger an uvm fault.  There
is a race between vop_generic_revoke() and sys_mount() where vgonel()
could reset v_specinfo.  Then v_specmountpoint is no longer valid.
So after sleeping, msdosfs_mountfs() could crash in the error path.
The code in the different *_mountfs() functions was inconsistent,
implement the same check everywhere.
OK krw@@ natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.50 2016/04/26 18:37:03 natano Exp $	*/
d525 1
a525 1
	VOP_LOCK(ntmp->ntm_devvp, LK_EXCLUSIVE | LK_RETRY, p);
@


1.50
log
@Populate all necessary statfs members in .vfs_statfs. cd9660, udf,
msdosfs and nfsv2 don't set f_namemax. ntfs and ext2fs don't set
f_namemeax and f_favail. fusefs doesn't set f_mntfromspec, f_favail and
f_iosize. Also, make all filesystems use copy_statfs_info(), so that all
statfs information is filled in correctly for the (sb != &mp->mnt-stat)
case.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.49 2016/03/27 11:39:37 bluhm Exp $	*/
d453 2
a454 1
	devvp->v_specmountpoint = NULL;
@


1.49
log
@When pulling and unmounting an umass USB stick, the file system
could end up in an inconsistent state.  The fstype dependent
mp->mnt_data was NULL, but the general mp was still listed as a
valid mount point.  Next access to the file system would crash with
a NULL pointer dereference.
If closing the device fails, the mount point must go away anyway.
There is nothing we can do about it.  Remove the workaround for the
EIO error in the general unmount code, but do not generate any error
in the file system specific unmount functions.
OK natano@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.48 2016/03/19 12:04:16 natano Exp $	*/
d439 1
d613 1
a613 1
	sbp->f_ffree = sbp->f_bfree / ntmp->ntm_bpmftrec;
d616 1
a616 8
	sbp->f_flags = mp->mnt_flag;
	if (sbp != &mp->mnt_stat) {
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
		bcopy(&mp->mnt_stat.mount_info.ntfs_args,
		    &sbp->mount_info.ntfs_args, sizeof(struct ntfs_args));
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
@


1.48
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.47 2016/03/17 18:52:31 bluhm Exp $	*/
d525 2
a526 4

	error = VOP_CLOSE(ntmp->ntm_devvp, ronly ? FREAD : FREAD|FWRITE,
		NOCRED, p);

d537 1
a537 1
	return (error);
@


1.47
log
@Set mnt_data to NULL after freeing the file system specific mount point.
OK krw@@ natano@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.46 2016/03/05 20:40:05 natano Exp $	*/
d199 1
a199 1
		VOP_UNLOCK(devvp, 0, p);
d302 1
a302 1
	VOP_UNLOCK(devvp, 0, p);
d466 1
a466 1
	VOP_UNLOCK(devvp, 0, p);
@


1.46
log
@ntfs populates ntfs_args, not msdosfs_args; ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.45 2016/02/27 18:50:38 natano Exp $	*/
d535 2
a538 2
	free(ntmp->ntm_ad, M_NTFSMNT, 0);
	free(ntmp, M_NTFSMNT, 0);
@


1.45
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.44 2015/03/14 03:38:52 jsg Exp $	*/
d621 2
a622 2
		bcopy(&mp->mnt_stat.mount_info.msdosfs_args,
		    &sbp->mount_info.msdosfs_args, sizeof(struct msdosfs_args));
@


1.44
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.43 2014/12/16 19:56:33 tedu Exp $	*/
a438 1
	mp->mnt_maxsymlinklen = 0;
@


1.43
log
@must include lock.h if you want to play with locks
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.42 2014/12/09 07:16:41 doug Exp $	*/
a53 1
#include <ntfs/ntfsmount.h>
@


1.42
log
@Sprinkle in a little more mallocarray().

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.41 2014/11/18 23:55:01 krw Exp $	*/
d38 1
@


1.41
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.40 2014/07/12 18:43:52 tedu Exp $	*/
d414 1
a414 1
		ntmp->ntm_ad = malloc(num * sizeof(struct ntvattrdef),
@


1.40
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.39 2014/07/08 17:19:26 deraadt Exp $	*/
a42 1
#include <sys/systm.h>
@


1.39
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.38 2014/01/19 18:35:45 tedu Exp $	*/
d460 2
a461 2
			free(ntmp->ntm_ad, M_NTFSMNT);
		free(ntmp, M_NTFSMNT);
d539 2
a540 2
	free(ntmp->ntm_ad, M_NTFSMNT);
	free(ntmp, M_NTFSMNT);
d598 1
a598 1
	free(tmp, M_TEMP);
@


1.38
log
@lazy init nthash to save some memory when it's not used. ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.37 2013/12/02 16:05:07 jsing Exp $	*/
a46 2

#include <uvm/uvm_extern.h>
@


1.37
log
@Use appropriate format specifiers in debug messages. In particular, avoid
casting almost everything to u_int32_t, then formatting as a signed int
(which really helps when you're trying to debug based on 64-bit values).

Looked over by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.36 2013/11/24 16:02:30 jsing Exp $	*/
a115 2
	ntfs_nthashinit();
	ntfs_toupper_init();
d129 2
@


1.36
log
@Clean up the NTFS debug code - use uppercase names for the debug macros,
especially since 'dprintf' now has another meaning (at least outside of
the kernel). Tweak the macro syntax so we can avoid having to double
bracket all invocations. Also apply a good dose of style(9).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.35 2013/05/30 20:11:06 guenther Exp $	*/
d337 2
a338 2
	DPRINTF("ntfs_mountfs(): bps: %d, spc: %d, media: %x, "
	    "mftrecsz: %d (%d sects)\n", ntmp->ntm_bps, ntmp->ntm_spc,
d341 2
a342 2
	DPRINTF("ntfs_mountfs(): mftcn: 0x%x|0x%x\n",
	    (u_int32_t)ntmp->ntm_mftcn, (u_int32_t)ntmp->ntm_mftmirrcn);
d646 1
a646 1
	DDPRINTF("ntfs_fhtovp(): %s: %d\n",
d694 2
a695 3
	DPRINTF("ntfs_vgetex: ino: %d, attr: 0x%x:%s, lkf: 0x%lx, f: 0x%lx\n",
	    ino, attrtype, attrname ? attrname : "", (u_long)lkflags,
	    (u_long)flags);
d773 1
a773 1
	DPRINTF("ntfs_vget: vnode: %p for ntnode: %d\n", vp, ino);
@


1.35
log
@More of the same: ntfs doesn't do inode numbers >2^32, so use a smaller type
internally, only using ino_t in the VFS layer APIs: vget, readdir, getattr
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.34 2013/04/15 15:32:19 jsing Exp $	*/
d326 1
a326 1
		dprintf(("ntfs_mountfs: invalid boot block\n"));
d337 6
a342 5
	dprintf(("ntfs_mountfs(): bps: %d, spc: %d, media: %x, mftrecsz: %d (%d sects)\n",
		ntmp->ntm_bps,ntmp->ntm_spc,ntmp->ntm_bootfile.bf_media,
		ntmp->ntm_mftrecsz,ntmp->ntm_bpmftrec));
	dprintf(("ntfs_mountfs(): mftcn: 0x%x|0x%x\n",
		(u_int32_t)ntmp->ntm_mftcn,(u_int32_t)ntmp->ntm_mftmirrcn));
d359 4
a362 4
	dprintf(("ntfs_mountfs(): case-%s,%s uid: %d, gid: %d, mode: %o\n",
		(ntmp->ntm_flag & NTFS_MFLAG_CASEINS)?"insens.":"sens.",
		(ntmp->ntm_flag & NTFS_MFLAG_ALLNAMES)?" allnames,":"",
		ntmp->ntm_uid, ntmp->ntm_gid, ntmp->ntm_mode));
d453 1
a453 1
		dprintf(("ntfs_mountfs: vflush failed\n"));
d487 1
a487 1
	dprintf(("ntfs_unmount: unmounting...\n"));
d494 1
a494 1
	dprintf(("ntfs_unmount: vflushing...\n"));
d497 1
a497 1
		dprintf(("ntfs_unmount: vflush failed: %d\n",error));
d538 1
a538 1
	dprintf(("ntfs_unmount: freeing memory...\n"));
d552 2
a553 2
	dprintf(("ntfs_root(): sysvn: %p\n",
		VFSTONTFS(mp)->ntm_sysvn[NTFS_ROOTINO]));
d610 1
a610 1
	dprintf(("ntfs_statfs():\n"));
d636 1
a636 1
	/*dprintf(("ntfs_sync():\n"));*/
d646 2
a647 2
	ddprintf(("ntfs_fhtovp(): %s: %d\n", mp->mnt_stat.f_mntonname,
		ntfhp->ntfid_ino));
d668 2
a669 2
	ddprintf(("ntfs_fhtovp(): %s: %p\n", vp->v_mount->mnt_stat.f_mntonname,
		vp));
d694 3
a696 3
	dprintf(("ntfs_vgetex: ino: %d, attr: 0x%x:%s, lkf: 0x%lx, f: 0x%lx\n",
		ino, attrtype, attrname?attrname:"", (u_long)lkflags,
		(u_long)flags ));
d774 1
a774 1
	dprintf(("ntfs_vget: vnode: %p for ntnode: %d\n", vp,ino));
@


1.34
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.33 2013/01/18 05:09:21 jsing Exp $	*/
d683 1
a683 1
ntfs_vgetex(struct mount *mp, ino_t ino, u_int32_t attrtype, char *attrname,
d797 2
@


1.33
log
@Constrain the amount of kernel memory used by NTFS. Keep a small cache of
loaded ntnodes and once the maximum is reached, unload the least recently
used ntnode before loading a new one. This avoids leaving large data
structures hanging around, which only get cleaned up when the vnode is
reclaimed. Additionally, the buffer cache should contain the data needed
to reload the ntnode.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.32 2013/01/14 02:41:03 jsing Exp $	*/
d128 1
a170 1
	disk_map(fspec, fspec, MNAMELEN, DM_OPENBLCK);
d172 4
a175 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fspec, p);
d244 3
a246 1
		strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN);
@


1.32
log
@Ansify and apply style(9) to function definitions.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.31 2013/01/13 04:07:49 jsing Exp $	*/
d346 1
@


1.31
log
@Destatic.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.30 2013/01/02 08:12:13 jsing Exp $	*/
d88 2
a89 5
ntfs_checkexp(mp, nam, exflagsp, credanonp)
	struct mount *mp;
	struct mbuf *nam;
	int *exflagsp;
	struct ucred **credanonp;
d107 2
a108 8
ntfs_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d114 1
a114 2
ntfs_init (
	struct vfsconf *vcp )
d122 2
a123 6
ntfs_mount( 
	struct mount *mp,
	const char *path,
	void *data,
	struct nameidata *ndp,
	struct proc *p )
d277 2
a278 5
ntfs_mountfs(devvp, mp, argsp, p)
	struct vnode *devvp;
	struct mount *mp;
	struct ntfs_args *argsp;
	struct proc *p;
d469 1
a469 4
ntfs_start (
	struct mount *mp,
	int flags,
	struct proc *p )
d475 1
a475 4
ntfs_unmount( 
	struct mount *mp,
	int mntflags,
	struct proc *p)
d540 1
a540 3
ntfs_root(
	struct mount *mp,
	struct vnode **vpp )
d561 2
a562 6
ntfs_quotactl ( 
	struct mount *mp,
	int cmds,
	uid_t uid,
	caddr_t arg,
	struct proc *p)
a563 1

d568 1
a568 3
ntfs_calccfree(
	struct ntfsmount *ntmp,
	cn_t *cfreep)
d598 1
a598 4
ntfs_statfs(
	struct mount *mp,
	struct statfs *sbp,
	struct proc *p)
d627 1
a627 5
ntfs_sync (
	struct mount *mp,
	int waitfor,
	struct ucred *cred,
	struct proc *p)
d634 1
a634 4
ntfs_fhtovp(
	struct mount *mp,
	struct fid *fhp,
	struct vnode **vpp)
d655 1
a655 3
ntfs_vptofh(
	struct vnode *vp,
	struct fid *fhp)
d677 2
a678 9
ntfs_vgetex(
	struct mount *mp,
	ino_t ino,
	u_int32_t attrtype,
	char *attrname,
	u_long lkflags,
	u_long flags,
	struct proc *p,
	struct vnode **vpp) 
d789 1
a789 4
ntfs_vget(
	struct mount *mp,
	ino_t ino,
	struct vnode **vpp) 
@


1.30
log
@Remove code that is not used on OpenBSD.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.29 2012/09/10 11:11:00 jsing Exp $	*/
d58 1
a58 1
static int	ntfs_mount(struct mount *, const char *, void *,
d60 1
a60 1
static int	ntfs_quotactl(struct mount *, int, uid_t, caddr_t,
d62 3
a64 3
static int	ntfs_root(struct mount *, struct vnode **);
static int	ntfs_start(struct mount *, int, struct proc *);
static int	ntfs_statfs(struct mount *, struct statfs *,
d66 1
a66 1
static int	ntfs_sync(struct mount *, int, struct ucred *,
d68 2
a69 2
static int	ntfs_unmount(struct mount *, int, struct proc *);
static int	ntfs_vget(struct mount *mp, ino_t ino,
d71 1
a71 1
static int	ntfs_mountfs(struct vnode *, struct mount *, 
d73 1
a73 1
static int	ntfs_vptofh(struct vnode *, struct fid *);
d75 2
a76 2
static int	ntfs_init(struct vfsconf *);
static int	ntfs_fhtovp(struct mount *, struct fid *,
d78 1
a78 1
static int	ntfs_checkexp(struct mount *, struct mbuf *,
d80 1
a80 1
static int	ntfs_sysctl(int *, u_int, void *, size_t *, void *,
d87 1
a87 1
static int
d109 1
a109 2
/*ARGSUSED*/
static int
d122 1
a122 1
static int
d131 1
a131 1
static int
d485 1
a485 1
static int
d494 1
a494 1
static int
d562 1
a562 1
static int
d585 1
a585 2
/* ARGSUSED */
static int
d629 1
a629 1
static int
d661 1
a661 1
static int
d672 1
a672 2
/*ARGSUSED*/
static int
d696 1
a696 1
static int
d839 1
a839 1
static int
@


1.29
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.27 2011/07/04 20:35:35 deraadt Exp $	*/
a47 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a48 3
#else
#include <vm/vm.h>
#endif
a50 8
#if defined(__FreeBSD__) || defined(__NetBSD__)
#include <fs/ntfs/ntfs.h>
#include <fs/ntfs/ntfs_inode.h>
#include <fs/ntfs/ntfs_subr.h>
#include <fs/ntfs/ntfs_vfsops.h>
#include <fs/ntfs/ntfs_ihash.h>
#include <fs/ntfs/ntfsmount.h>
#else
a56 1
#endif
a57 11
#ifdef MALLOC_DEFINE
MALLOC_DEFINE(M_NTFSMNT, "NTFS mount", "NTFS mount structure");
MALLOC_DEFINE(M_NTFSNTNODE,"NTFS ntnode",  "NTFS ntnode information");
MALLOC_DEFINE(M_NTFSFNODE,"NTFS fnode",  "NTFS fnode information");
MALLOC_DEFINE(M_NTFSDIR,"NTFS dir",  "NTFS dir buffer");
#endif

#if defined(__FreeBSD__)
static int	ntfs_mount(struct mount *, char *, caddr_t,
				struct nameidata *, struct proc *);
#else
a59 1
#endif
@


1.28
log
@respect the MNT_FORCE flag in ntfs_unmount and proceed even if there's
someone holding a system vnode.  prevents crashes with forced unmounts.
silence ntfs_reclaim so that kernel won't spit out vprint's angrily.

ok krw, beck
@
text
@d168 1
a168 1
	size_t size;
a169 1
	char *fspec = NULL;
d188 1
a188 1
		if (args.fspec == 0) {
d207 1
a207 2
	fspec = malloc(MNAMELEN, M_MOUNT, M_WAITOK);
	err = copyinstr(args.fspec, fspec, MNAMELEN - 1, &size);
d278 4
a281 6
		(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1,
		           &size);
		bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);

		size = strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN - 1);
		bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
a309 3
	if (fspec)
		free(fspec, M_MOUNT);

@


1.27
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.26 2011/07/04 04:30:41 tedu Exp $	*/
d550 6
a555 4
	/* Check if only system vnodes are rest */
	for(i=0;i<NTFS_SYSNODESNUM;i++)
		 if((ntmp->ntm_sysvn[i]) && 
		    (ntmp->ntm_sysvn[i]->v_usecount > 1)) return (EBUSY);
@


1.26
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.25 2011/04/03 17:17:41 jsing Exp $	*/
d46 1
a52 2

#include <miscfs/specfs/specdev.h>
@


1.25
log
@Teach ntfs_mount() how to handle disklabel UIDs.

Diff from Antti Harri.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.23 2010/09/10 16:34:09 thib Exp $	*/
d362 1
a362 1
	error = bread(devvp, BBLOCK, BBSIZE, NOCRED, &bp);
@


1.24
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d40 1
d171 1
d209 7
a215 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_USERSPACE, args.fspec, p);
d284 2
a285 2
		(void) copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, 
		           MNAMELEN - 1, &size);
d315 3
d586 1
a586 1
	dprintf(("ntfs_umount: freeing memory...\n"));
@


1.23
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.22 2010/09/07 00:41:05 thib Exp $	*/
d834 1
a834 1
	error = getnewvnode(VT_NTFS, ntmp->ntm_mountp, ntfs_vnodeop_p, &vp);
a870 7

extern const struct vnodeopv_desc ntfs_vnodeop_opv_desc;

const struct vnodeopv_desc * const ntfs_vnodeopv_descs[] = {
	&ntfs_vnodeop_opv_desc,
	NULL,
};
@


1.22
log
@Allow NTFS to compile by cutting it over to the new VOP world order.
Small cleanup while here, nuke the ntfs_bypass function and just
use eopnotsupp like every other filesystem, it makes no sense to
return ENOTTY for unimplemented VOPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.21 2010/09/04 21:35:58 tedu Exp $	*/
d834 1
a834 1
	error = getnewvnode(VT_NTFS, ntmp->ntm_mountp, &ntfs_vops, &vp);
d871 7
@


1.21
log
@revert previous "simplification".  kcornies at gmail says it doesn't work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.20 2010/08/22 21:23:07 tedu Exp $	*/
d834 1
a834 1
	error = getnewvnode(VT_NTFS, ntmp->ntm_mountp, ntfs_vnodeop_p, &vp);
a870 7

extern const struct vnodeopv_desc ntfs_vnodeop_opv_desc;

const struct vnodeopv_desc * const ntfs_vnodeopv_descs[] = {
	&ntfs_vnodeop_opv_desc,
	NULL,
};
@


1.20
log
@the upper case table code was a lot more complicated than it needed to be.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.19 2010/08/12 04:05:03 tedu Exp $	*/
d71 7
d153 1
d415 1
a415 1
	if ((error = ntfs_load_toupper(mp, ntmp)))
d422 1
a422 1
	if (error)
d571 3
@


1.19
log
@clean up some macro obfuscation and assorted styling problems.
fix a bonus off by one bug.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.18 2010/08/08 01:28:33 tedu Exp $	*/
a70 7
#ifdef MALLOC_DEFINE
MALLOC_DEFINE(M_NTFSMNT, "NTFS mount", "NTFS mount structure");
MALLOC_DEFINE(M_NTFSNTNODE,"NTFS ntnode",  "NTFS ntnode information");
MALLOC_DEFINE(M_NTFSFNODE,"NTFS fnode",  "NTFS fnode information");
MALLOC_DEFINE(M_NTFSDIR,"NTFS dir",  "NTFS dir buffer");
#endif

a145 1
	ntfs_toupper_init();
d407 1
a407 1
	if ((error = ntfs_toupper_use(mp, ntmp, p)))
d414 1
a414 1
	if(error)
a562 3

	/* free the toupper table, if this has been last mounted ntfs volume */
	ntfs_toupper_unuse(p);
@


1.18
log
@do not unlock vnode before calling vput. should fix ray's panic.
ok deraadt krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.17 2010/07/03 00:12:31 krw Exp $	*/
d439 1
a439 1
		for(num=0;;num++) {
d441 2
a442 3
					NTFS_A_DATA, NULL,
					num * sizeof(ad), sizeof(ad),
					&ad, NULL);
d450 2
a451 3
		ntmp->ntm_ad = (struct ntvattrdef *) malloc(
			num * sizeof(struct ntvattrdef),
			M_NTFSMNT, M_WAITOK);
d456 1
a456 1
		for(i=0;i<num;i++){
d458 2
a459 3
					NTFS_A_DATA, NULL,
					i * sizeof(ad), sizeof(ad),
					&ad, NULL);
d501 1
a501 1
	VN_LOCK(devvp, LK_EXCLUSIVE | LK_RETRY, p);
d503 1
a503 1
	VOP__UNLOCK(devvp, 0, p);
d634 1
a634 1
	tmp = (u_int8_t *) malloc(bmsize, M_TEMP, M_WAITOK);
d828 1
a828 1
		if (VGET(FTOV(fp), lkflags, p) == 0) {
d851 1
a851 1
		error = VN_LOCK(vp, lkflags, p);
@


1.17
log
@Last bit of thib@@ locking diff from long ago. Put proper locking
around vinvalbuf(). vrele() -> vput() after VOP_CLOSE().

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.16 2010/06/29 04:09:32 tedu Exp $	*/
a571 1
	VOP__UNLOCK(ntmp->ntm_devvp, 0, p);
@


1.16
log
@makefstype was only used in ported from freebsd filesystems.  fix them
and remove the function.  ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.15 2009/08/13 16:00:53 jasper Exp $	*/
d338 1
d340 1
d566 2
a569 2
	/* lock the device vnode before calling VOP_CLOSE() */
	VOP_LOCK(ntmp->ntm_devvp, LK_EXCLUSIVE | LK_RETRY, p);
d574 1
a574 1
	vrele(ntmp->ntm_devvp);
@


1.15
log
@- remove super-obvious comments from vnodeop_entries[]
- remove #ifdef someos blocks, makes this a tad easier to read

agreed by art@@ and thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.14 2009/07/09 22:29:56 thib Exp $	*/
d475 1
a475 1
	mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_NTFS);
@


1.14
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.12 2007/09/17 01:33:33 krw Exp $	*/
a99 17
#if defined(__FreeBSD__)
static int	ntfs_init(struct vfsconf *);
static int	ntfs_fhtovp(struct mount *, struct fid *,
				 struct sockaddr *, struct vnode **,
				 int *, struct ucred **);
#elif defined(__NetBSD__)
static void	ntfs_init(void);
static void	ntfs_reinit(void);
static void	ntfs_done(void);
static int	ntfs_fhtovp(struct mount *, struct fid *,
				 struct vnode **);
static int	ntfs_checkexp(struct mount *, struct mbuf *,
				   int *, struct ucred **);
static int	ntfs_mountroot(void);
static int	ntfs_sysctl(int *, u_int, void *, size_t *, void *,
				 size_t, struct proc *);
#elif defined(__OpenBSD__)
a106 14
#else
static int	ntfs_init(void);
static int	ntfs_fhtovp(struct mount *, struct fid *,
				 struct mbuf *, struct vnode **,
				 int *, struct ucred **);
#endif

#if defined(__FreeBSD__) || defined(__NetBSD__)
struct genfs_ops ntfs_genfsops = {
	NULL,
	NULL,
	genfs_compat_gop_write,
};
#endif
a107 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a147 88
#endif

#ifdef __NetBSD__
static int
ntfs_mountroot()
{
	struct mount *mp;
	struct proc *p = curproc;	/* XXX */
	int error;
	struct ntfs_args args;

	if (root_device->dv_class != DV_DISK)
		return (ENODEV);

	/*
	 * Get vnodes for rootdev.
	 */
	if (bdevvp(rootdev, &rootvp))
		panic("ntfs_mountroot: can't setup rootvp");

	if ((error = vfs_rootmountalloc(MOUNT_NTFS, "root_device", &mp))) {
		vrele(rootvp);
		return (error);
	}

	args.flag = 0;
	args.uid = 0;
	args.gid = 0;
	args.mode = 0777;

	if ((error = ntfs_mountfs(rootvp, mp, &args, p)) != 0) {
		mp->mnt_op->vfs_refcount--;
		vfs_unbusy(mp);
		free(mp, M_MOUNT);
		vrele(rootvp);
		return (error);
	}

	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	(void)ntfs_statfs(mp, &mp->mnt_stat, p);
	vfs_unbusy(mp);

	return (0);
}

static void
ntfs_init()
{
#ifdef _LKM
	malloc_type_attach(M_NTFSMNT);
	malloc_type_attach(M_NTFSNTNODE);
	malloc_type_attach(M_NTFSFNODE);
	malloc_type_attach(M_NTFSDIR);
	malloc_type_attach(M_NTFSNTHASH);
	malloc_type_attach(M_NTFSNTVATTR);
	malloc_type_attach(M_NTFSRDATA);
	malloc_type_attach(M_NTFSDECOMP);
	malloc_type_attach(M_NTFSRUN);
#endif
	ntfs_nthashinit();
	ntfs_toupper_init();
}

static void
ntfs_reinit()
{
	ntfs_nthashreinit();
}

static void
ntfs_done()
{
	ntfs_nthashdone();
#ifdef _LKM
	malloc_type_detach(M_NTFSMNT);
	malloc_type_detach(M_NTFSNTNODE);
	malloc_type_detach(M_NTFSFNODE);
	malloc_type_detach(M_NTFSDIR);
	malloc_type_detach(M_NTFSNTHASH);
	malloc_type_detach(M_NTFSNTVATTR);
	malloc_type_detach(M_NTFSRDATA);
	malloc_type_detach(M_NTFSDECOMP);
	malloc_type_detach(M_NTFSRUN);
#endif
}

#elif defined(__FreeBSD__) || defined(__OpenBSD__)

a156 2
#endif /* NetBSD */

a159 4
#if defined(__FreeBSD__)
	char *path,
	caddr_t data,
#else
a161 1
#endif
a170 48
#ifdef __FreeBSD__
	/*
	 * Use NULL path to flag a root mount
	 */
	if( path == NULL) {
		/*
		 ***
		 * Mounting root file system
		 ***
		 */
	
		/* Get vnode for root device*/
		if( bdevvp( rootdev, &rootvp))
			panic("ffs_mountroot: can't setup bdevvp for root");

		/*
		 * FS specific handling
		 */
		mp->mnt_flag |= MNT_RDONLY;	/* XXX globally applicable?*/

		/*
		 * Attempt mount
		 */
		if( ( err = ntfs_mountfs(rootvp, mp, &args, p)) != 0) {
			/* fs specific cleanup (if any)*/
			goto error_1;
		}

		goto dostatfs;		/* success*/

	}
#endif /* FreeBSD */

#ifdef __NetBSD__
	if (mp->mnt_flag & MNT_GETARGS) {
		struct ntfsmount *ntmp = VFSTONTFS(mp);
		if (ntmp == NULL)
			return EIO;
		args.fspec = NULL;
		args.uid = ntmp->ntm_uid;
		args.gid = ntmp->ntm_gid;
		args.mode = ntmp->ntm_mode;
		args.flag = ntmp->ntm_flag;
		vfs_showexport(mp, &args.export, &ntmp->ntm_export);
		return copyout(&args, data, sizeof(args));
	}
#endif

a220 5
#ifdef __FreeBSD__
	if (bdevsw(devvp->v_rdev) == NULL) {
#elif defined(__NetBSD__)
	if (bdevsw_lookup(devvp->v_rdev) == NULL) {
#else
a221 1
#endif
a272 4
#if defined(__FreeBSD__) || defined(__NetBSD__) 
		err = set_statfs_info(path, UIO_USERSPACE, args.fspec,
		    UIO_USERSPACE, mp, p);
#else
a279 1
#endif
a287 3
#ifdef __FreeBSD__
dostatfs:
#endif
a382 1
#ifdef __OpenBSD__
a383 3
#else
	mp->mnt_data = ntmp;
#endif
a412 3
#ifndef __OpenBSD__
	if ((error = ntfs_toupper_use(mp, ntmp)))
#else
a413 1
#endif
a473 4
#if defined(__FreeBSD__)
	mp->mnt_stat.f_fsid.val[0] = dev2udev(dev);
	mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
#else
a475 1
#endif
a566 3
#ifndef __OpenBSD__
	VOP_LOCK(ntmp->ntm_devvp, LK_EXCLUSIVE | LK_RETRY);
#else
a567 1
#endif
a574 3
#ifndef __OpenBSD__
	ntfs_toupper_unuse();
#else
a575 1
#endif
a665 7
#if defined(__FreeBSD__)
	sbp->f_type = mp->mnt_vfc->vfc_typenum;
#elif defined(__NetBSD__)
	sbp->f_type = 0;
#elif !defined(__OpenBSD__)
	sbp->f_type = MOUNT_NTFS;
#endif
a673 3
#if !defined(__OpenBSD__)
	copy_statfs_info(sbp, mp);
#else
d681 1
a681 1
#endif
a698 8
#if defined(__FreeBSD__)
	struct mount *mp,
	struct fid *fhp,
	struct sockaddr *nam,
	struct vnode **vpp,
	int *exflagsp,
	struct ucred **credanonp)
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a701 8
#else
	struct mount *mp,
	struct fid *fhp,
	struct mbuf *nam,
	struct vnode **vpp,
	int *exflagsp,
	struct ucred **credanonp)
#endif
a770 3
#ifndef __OpenBSD__
	error = ntfs_ntlookup(ntmp, ino, &ip);
#else
a771 1
#endif
a782 3
#ifndef __OpenBSD__
			ntfs_ntput(ip);
#else
d784 1
a784 1
#endif
a791 3
#ifndef __OpenBSD__
		ntfs_ntput(ip);
#else
d793 1
a793 1
#endif
a809 3
#ifndef __OpenBSD__
				ntfs_ntput(ip);
#else
d811 1
a811 1
#endif
a825 3
#ifndef __OpenBSD__
	ntfs_ntput(ip);
#else
a826 1
#endif
a838 3
#ifndef __OpenBSD__
		ntfs_ntput(ip);
#else
d840 1
a840 1
#endif
a844 3
#ifdef __FreeBSD__
	lockinit(&fp->f_lock, PINOD, "fnode", 0, 0);
#endif
a859 3
#if defined(__FreeBSD__) || defined(__NetBSD__)
	genfs_node_init(vp, &ntfs_genfsops);
#endif
a873 45
#if defined(__FreeBSD__)
static struct vfsops ntfs_vfsops = {
	ntfs_mount,
	ntfs_start,
	ntfs_unmount,
	ntfs_root,
	ntfs_quotactl,
	ntfs_statfs,
	ntfs_sync,
	ntfs_vget,
	ntfs_fhtovp,
	ntfs_vptofh,
	ntfs_init,
	NULL
};
VFS_SET(ntfs_vfsops, ntfs, 0);
#elif defined(__NetBSD__)
extern const struct vnodeopv_desc ntfs_vnodeop_opv_desc;

const struct vnodeopv_desc * const ntfs_vnodeopv_descs[] = {
	&ntfs_vnodeop_opv_desc,
	NULL,
};

struct vfsops ntfs_vfsops = {
	MOUNT_NTFS,
	ntfs_mount,
	ntfs_start,
	ntfs_unmount,
	ntfs_root,
	ntfs_quotactl,
	ntfs_statfs,
	ntfs_sync,
	ntfs_vget,
	ntfs_fhtovp,
	ntfs_vptofh,
	ntfs_init,
	ntfs_reinit,
	ntfs_done,
	ntfs_sysctl,
	ntfs_mountroot,
	ntfs_checkexp,
	ntfs_vnodeopv_descs,
};
#elif defined(__OpenBSD__)
a895 2

#endif
@


1.13
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d599 1
a599 1
			VREF(ntmp->ntm_sysvn[pi[i]]);
@


1.12
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.11 2006/04/19 11:55:55 pedro Exp $	*/
a30 5

#include <sys/cdefs.h>
#ifdef __KERNEL_RCSID
__KERNEL_RCSID(0, "$NetBSD: ntfs_vfsops.c,v 1.7 2003/04/24 07:50:19 christos Exp $");
#endif
@


1.11
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.10 2005/10/10 15:55:07 pedro Exp $	*/
d546 1
a546 2
	ntmp = malloc(sizeof *ntmp, M_NTFSMNT, M_WAITOK);
	bzero(ntmp, sizeof *ntmp);
@


1.10
log
@Use free(9) to free memory allocated with malloc(9), okay krw@@, marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.9 2005/05/21 18:05:58 brad Exp $	*/
a222 1
	simple_lock(&mountlist_slock);
a223 1
	simple_unlock(&mountlist_slock);
d226 1
@


1.9
log
@- use MIN()/MAX() rather than min()/max(), to avoid possible truncation
  of 64bit values to 'int'
- read always single cluster of data, to avoid confusing the buffer
  cache; this appears to fix the random file content corruption which
  happens when more than one cluster is read at the same time, i.e. for
  files > 3*cluster_size
- fix some questionable pointer arithmetics; gcc-3.4.x didn't like it
- g/c redundant debug printf
- remove all traces of non-working quota support
  add quota support to TODO - makes sense only once writing support
  would be implemented, and only once NTFS would support notion of file 'owner'
- use 64bit local variable for free space computation

From NetBSD

- Comment fixes from joris@@

ok millert@@ joris@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.8 2005/03/08 15:45:20 pat Exp $	*/
d798 1
a798 1
	FREE(ntmp, M_NTFSMNT);
@


1.8
log
@fix a page fault that occurs when a reclaimed vnode is then reused.
from FreeBSD

ok pedro tedu miod, tested by millert and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.7 2005/02/01 11:29:59 pedro Exp $	*/
d822 4
d834 1
a834 1
	printf("\nntfs_quotactl():\n");
d846 1
a846 1
	long cfree = 0;
@


1.7
log
@Before carrying on with the mount request, make sure the process has
enough permissions to access the given device. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.6 2004/12/09 22:58:57 pat Exp $	*/
a1124 1
	VREF(ip->i_devvp);
@


1.6
log
@* plug memory leak on mount failure.
* spacing

ok tedu pedro millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.5 2003/08/14 07:46:40 mickey Exp $	*/
d286 1
a286 1
ntfs_mount ( 
d302 1
d401 1
d412 14
@


1.5
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.4 2003/05/24 21:48:05 tedu Exp $	*/
d500 1
a500 1
	struct ntfsmount *ntmp;
d531 4
a534 4
	ntmp = malloc( sizeof *ntmp, M_NTFSMNT, M_WAITOK );
	bzero( ntmp, sizeof *ntmp );
	bcopy( bp->b_data, &ntmp->ntm_bootfile, sizeof(struct bootfile) );
	brelse( bp );
d675 3
a677 2
	for(i=0;i<NTFS_SYSNODESNUM;i++)
		if(ntmp->ntm_sysvn[i]) vrele(ntmp->ntm_sysvn[i]);
d686 7
@


1.4
log
@rename export to export_info for c++ safety.  report by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.3 2003/05/20 03:36:42 tedu Exp $	*/
d1168 1
a1168 1
struct vfsops ntfs_vfsops = {
@


1.4.2.1
log
@add file to SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1168 1
a1168 1
const struct vfsops ntfs_vfsops = {
@


1.3
log
@un __P
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.2 2003/05/20 03:23:12 mickey Exp $	*/
d374 1
a374 1
			err = vfs_export(mp, &ntm->ntm_export, &args.export);
@


1.2
log
@fix the tags
@
text
@d1 1
a1 1
/*	$OpenBSD: ntfs_vfsops.c,v 1.1 2003/05/20 03:03:27 tedu Exp $	*/
d84 2
a85 2
static int	ntfs_mount __P((struct mount *, char *, caddr_t,
				struct nameidata *, struct proc *));
d87 2
a88 2
static int	ntfs_mount __P((struct mount *, const char *, void *,
				struct nameidata *, struct proc *));
d90 14
a103 14
static int	ntfs_quotactl __P((struct mount *, int, uid_t, caddr_t,
				   struct proc *));
static int	ntfs_root __P((struct mount *, struct vnode **));
static int	ntfs_start __P((struct mount *, int, struct proc *));
static int	ntfs_statfs __P((struct mount *, struct statfs *,
				 struct proc *));
static int	ntfs_sync __P((struct mount *, int, struct ucred *,
			       struct proc *));
static int	ntfs_unmount __P((struct mount *, int, struct proc *));
static int	ntfs_vget __P((struct mount *mp, ino_t ino,
			       struct vnode **vpp));
static int	ntfs_mountfs __P((struct vnode *, struct mount *, 
				  struct ntfs_args *, struct proc *));
static int	ntfs_vptofh __P((struct vnode *, struct fid *));
d106 2
a107 2
static int	ntfs_init __P((struct vfsconf *));
static int	ntfs_fhtovp __P((struct mount *, struct fid *,
d109 1
a109 1
				 int *, struct ucred **));
d111 10
a120 10
static void	ntfs_init __P((void));
static void	ntfs_reinit __P((void));
static void	ntfs_done __P((void));
static int	ntfs_fhtovp __P((struct mount *, struct fid *,
				 struct vnode **));
static int	ntfs_checkexp __P((struct mount *, struct mbuf *,
				   int *, struct ucred **));
static int	ntfs_mountroot __P((void));
static int	ntfs_sysctl __P((int *, u_int, void *, size_t *, void *,
				 size_t, struct proc *));
d122 2
a123 2
static int	ntfs_init (struct vfsconf *);
static int	ntfs_fhtovp (struct mount *, struct fid *,
d125 1
a125 1
static int	ntfs_checkexp (struct mount *, struct mbuf *,
d127 1
a127 1
static int	ntfs_sysctl (int *, u_int, void *, size_t *, void *,
d130 2
a131 2
static int	ntfs_init __P((void));
static int	ntfs_fhtovp __P((struct mount *, struct fid *,
d133 1
a133 1
				 int *, struct ucred **));
@


1.1
log
@by popular request, NTFS support.  read only.
The code comes from NetBSD and was ported by Julian Bordet.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id$	*/
@

