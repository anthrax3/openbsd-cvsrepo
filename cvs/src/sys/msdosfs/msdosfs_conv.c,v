head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.24
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.20
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.18
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.16
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.10
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.16
	OPENBSD_2_8:1.8.0.14
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.12
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.10
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.8
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.10.23.10.45.31;	author krw;	state Exp;
branches;
next	1.18;
commitid	SncnQqnXMdpzMlro;

1.18
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.17;
commitid	P6Av4XGqOi3rFasL;

1.17
date	2014.04.21.15.35.02;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.01.20.22.13;	author sf;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.06.19.06.04;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.13.22.34.29;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.14.04.05.05;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.12.21.04.15;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.31.18.48.15;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.29.19.26.38;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.17.00.58.01;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	98.01.11.20.39.06;	author provos;	state Exp;
branches
	1.8.10.1;
next	1.7;

1.7
date	97.10.04.19.08.11;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.03.02.18.01.53;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.03.02.00.54.54;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.29.10.46.49;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.21.07.41.05;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.19.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches;
next	;

1.8.10.1
date	2001.07.04.10.49.25;	author niklas;	state Exp;
branches;
next	1.8.10.2;

1.8.10.2
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.8.10.3;

1.8.10.3
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Nuke a bunch of leading/embedded/trailing whitespace so the code can be
read without generating spurious headaches.
@
text
@/*	$OpenBSD: msdosfs_conv.c,v 1.18 2014/12/16 18:30:04 tedu Exp $	*/
/*	$NetBSD: msdosfs_conv.c,v 1.24 1997/10/17 11:23:54 ws Exp $	*/

/*-
 * Copyright (C) 1995, 1997 Wolfgang Solfrank.
 * Copyright (C) 1995, 1997 TooLs GmbH.
 * All rights reserved.
 * Original code by Paul Popelka (paulp@@uts.amdahl.com) (see below).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Written by Paul Popelka (paulp@@uts.amdahl.com)
 *
 * You can do anything you want with this software, just don't say you wrote
 * it, and don't remove this notice.
 *
 * This software is provided "as is".
 *
 * The author supplies this software to be publicly redistributed on the
 * understanding that the author is not responsible for the correct
 * functioning of this software in any circumstances and is not liable for
 * any damages caused by this software.
 *
 * October 1992
 */

/*
 * System include files.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>		/* defines tz */
#include <sys/dirent.h>
#include <sys/vnode.h>
#include <sys/lock.h>

/*
 * MSDOSFS include files.
 */
#include <msdosfs/direntry.h>
#include <msdosfs/denode.h>

/*
 * Days in each month in a regular year.
 */
const u_short regyear[] = {
	31, 28, 31, 30, 31, 30,
	31, 31, 30, 31, 30, 31
};

/*
 * Days in each month in a leap year.
 */
const u_short leapyear[] = {
	31, 29, 31, 30, 31, 30,
	31, 31, 30, 31, 30, 31
};

/*
 * Variables used to remember parts of the last time conversion.  Maybe we
 * can avoid a full conversion.
 */
time_t lasttime;
uint32_t lastday;
u_short lastddate;
u_short lastdtime;

/*
 * Convert the unix version of time to dos's idea of time to be used in
 * file timestamps. The passed in unix time is assumed to be in GMT.
 */
void
unix2dostime(struct timespec *tsp, u_int16_t *ddp, u_int16_t *dtp, u_int8_t *dhp)
{
	time_t t;
	uint32_t days;
	uint32_t inc;
	uint32_t year;
	uint32_t month;
	const u_short *months;

	/*
	 * If the time from the last conversion is the same as now, then
	 * skip the computations and use the saved result.
	 */
	t = tsp->tv_sec - (tz.tz_minuteswest * 60)
	     /* +- daylight saving time correction */ ;
	t &= ~1;
	/*
	 * Before 1/1/1980 there is only a timeless void. After 12/31/2107
	 * there is only Cthulhu.
	 */
#define DOSEPOCH 315532800LL
#define DOSENDTIME 4354775999LL
	if (t < DOSEPOCH || t > DOSENDTIME)
		t = DOSEPOCH;

	if (lasttime != t) {
		lasttime = t;
		lastdtime = (((t / 2) % 30) << DT_2SECONDS_SHIFT)
		    + (((t / 60) % 60) << DT_MINUTES_SHIFT)
		    + (((t / 3600) % 24) << DT_HOURS_SHIFT);

		/*
		 * If the number of days since 1970 is the same as the last
		 * time we did the computation then skip all this leap year
		 * and month stuff.
		 */
		days = t / (24 * 60 * 60);
		if (days != lastday) {
			lastday = days;
			for (year = 1970;; year++) {
				inc = year & 0x03 ? 365 : 366;
				if (days < inc)
					break;
				days -= inc;
			}
			months = year & 0x03 ? regyear : leapyear;
			for (month = 0; month < 12; month++) {
				if (days < months[month])
					break;
				days -= months[month];
			}
			lastddate = ((days + 1) << DD_DAY_SHIFT)
			    + ((month + 1) << DD_MONTH_SHIFT);
			/*
			 * Remember dos's idea of time is relative to 1980.
			 * unix's is relative to 1970.  If somehow we get a
			 * time before 1980 then don't give totally crazy
			 * results.
			 */
			if (year > 1980)
				lastddate += (year - 1980) << DD_YEAR_SHIFT;
		}
	}

	if (dtp != NULL)
		*dtp = lastdtime;
	if (dhp != NULL)
	        *dhp = (tsp->tv_sec & 1) * 100 + tsp->tv_nsec / 10000000;

	*ddp = lastddate;
}

/*
 * The number of seconds between Jan 1, 1970 and Jan 1, 1980. In that
 * interval there were 8 regular years and 2 leap years.
 */
#define	SECONDSTO1980	(((8 * 365) + (2 * 366)) * (24 * 60 * 60))

u_short lastdosdate;
uint32_t lastseconds;

/*
 * Convert from dos' idea of time to unix'. This will probably only be
 * called from the stat(), and fstat() system calls and so probably need
 * not be too efficient.
 */
void
dos2unixtime(u_int dd, u_int dt, u_int dh, struct timespec *tsp)
{
	uint32_t seconds;
	uint32_t m, month;
	uint32_t y, year;
	uint32_t days;
	const u_short *months;

	if (dd == 0) {
		/*
		 * Uninitialized field, return the epoch.
		 */
		tsp->tv_sec = 0;
		tsp->tv_nsec = 0;
		return;
	}
	seconds = ((dt & DT_2SECONDS_MASK) >> DT_2SECONDS_SHIFT) * 2
	    + ((dt & DT_MINUTES_MASK) >> DT_MINUTES_SHIFT) * 60
	    + ((dt & DT_HOURS_MASK) >> DT_HOURS_SHIFT) * 3600
	    + dh / 100;
	/*
	 * If the year, month, and day from the last conversion are the
	 * same then use the saved value.
	 */
	if (lastdosdate != dd) {
		lastdosdate = dd;
		days = 0;
		year = (dd & DD_YEAR_MASK) >> DD_YEAR_SHIFT;
		for (y = 0; y < year; y++)
			days += y & 0x03 ? 365 : 366;
		months = year & 0x03 ? regyear : leapyear;
		/*
		 * Prevent going from 0 to 0xffffffff in the following
		 * loop.
		 */
		month = (dd & DD_MONTH_MASK) >> DD_MONTH_SHIFT;
		if (month == 0) {
			printf("dos2unixtime(): month value out of range (%u)\n",
			    month);
			month = 1;
		}
		for (m = 0; m < month - 1; m++)
			days += months[m];
		days += ((dd & DD_DAY_MASK) >> DD_DAY_SHIFT) - 1;
		lastseconds = (days * 24 * 60 * 60) + SECONDSTO1980;
	}
	tsp->tv_sec = seconds + lastseconds + (tz.tz_minuteswest * 60)
	     /* -+ daylight saving time correction */ ;
	tsp->tv_nsec = (dh % 100) * 10000000;
}

static const u_char
unix2dos[256] = {
	0,    0,    0,    0,    0,    0,    0,    0,	/* 00-07 */
	0,    0,    0,    0,    0,    0,    0,    0,	/* 08-0f */
	0,    0,    0,    0,    0,    0,    0,    0,	/* 10-17 */
	0,    0,    0,    0,    0,    0,    0,    0,	/* 18-1f */
	0,    0x21, 0,    0x23, 0x24, 0x25, 0x26, 0x27,	/* 20-27 */
	0x28, 0x29, 0,    0,    0,    0x2d, 0,    0,	/* 28-2f */
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,	/* 30-37 */
	0x38, 0x39, 0,    0,    0,    0,    0,    0,	/* 38-3f */
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	/* 40-47 */
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,	/* 48-4f */
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	/* 50-57 */
	0x58, 0x59, 0x5a, 0,    0,    0,    0x5e, 0x5f,	/* 58-5f */
	0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	/* 60-67 */
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,	/* 68-6f */
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	/* 70-77 */
	0x58, 0x59, 0x5a, 0x7b, 0,    0x7d, 0x7e, 0,	/* 78-7f */
	0,    0,    0,    0,    0,    0,    0,    0,	/* 80-87 */
	0,    0,    0,    0,    0,    0,    0,    0,	/* 88-8f */
	0,    0,    0,    0,    0,    0,    0,    0,	/* 90-97 */
	0,    0,    0,    0,    0,    0,    0,    0,	/* 98-9f */
	0,    0xad, 0xbd, 0x9c, 0xcf, 0xbe, 0xdd, 0xf5,	/* a0-a7 */
	0xf9, 0xb8, 0xa6, 0xae, 0xaa, 0xf0, 0xa9, 0xee,	/* a8-af */
	0xf8, 0xf1, 0xfd, 0xfc, 0xef, 0xe6, 0xf4, 0xfa,	/* b0-b7 */
	0xf7, 0xfb, 0xa7, 0xaf, 0xac, 0xab, 0xf3, 0xa8,	/* b8-bf */
	0xb7, 0xb5, 0xb6, 0xc7, 0x8e, 0x8f, 0x92, 0x80,	/* c0-c7 */
	0xd4, 0x90, 0xd2, 0xd3, 0xde, 0xd6, 0xd7, 0xd8,	/* c8-cf */
	0xd1, 0xa5, 0xe3, 0xe0, 0xe2, 0xe5, 0x99, 0x9e,	/* d0-d7 */
	0x9d, 0xeb, 0xe9, 0xea, 0x9a, 0xed, 0xe8, 0xe1,	/* d8-df */
	0xb7, 0xb5, 0xb6, 0xc7, 0x8e, 0x8f, 0x92, 0x80,	/* e0-e7 */
	0xd4, 0x90, 0xd2, 0xd3, 0xde, 0xd6, 0xd7, 0xd8,	/* e8-ef */
	0xd1, 0xa5, 0xe3, 0xe0, 0xe2, 0xe5, 0x99, 0xf6,	/* f0-f7 */
	0x9d, 0xeb, 0xe9, 0xea, 0x9a, 0xed, 0xe8, 0x98,	/* f8-ff */
};

static const u_char
dos2unix[256] = {
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,	/* 00-07 */
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,	/* 08-0f */
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,	/* 10-17 */
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,	/* 18-1f */
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,	/* 20-27 */
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,	/* 28-2f */
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,	/* 30-37 */
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,	/* 38-3f */
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	/* 40-47 */
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,	/* 48-4f */
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	/* 50-57 */
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,	/* 58-5f */
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,	/* 60-67 */
	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,	/* 68-6f */
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,	/* 70-77 */
	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,	/* 78-7f */
	0xc7, 0xfc, 0xe9, 0xe2, 0xe4, 0xe0, 0xe5, 0xe7,	/* 80-87 */
	0xea, 0xeb, 0xe8, 0xef, 0xee, 0xec, 0xc4, 0xc5,	/* 88-8f */
	0xc9, 0xe6, 0xc6, 0xf4, 0xf6, 0xf2, 0xfb, 0xf9,	/* 90-97 */
	0xff, 0xd6, 0xdc, 0xf8, 0xa3, 0xd8, 0xd7, 0x3f,	/* 98-9f */
	0xe1, 0xed, 0xf3, 0xfa, 0xf1, 0xd1, 0xaa, 0xba,	/* a0-a7 */
	0xbf, 0xae, 0xac, 0xbd, 0xbc, 0xa1, 0xab, 0xbb,	/* a8-af */
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0xc1, 0xc2, 0xc0,	/* b0-b7 */
	0xa9, 0x3f, 0x3f, 0x3f, 0x3f, 0xa2, 0xa5, 0x3f,	/* b8-bf */
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0xe3, 0xc3,	/* c0-c7 */
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0xa4,	/* c8-cf */
	0xf0, 0xd0, 0xca, 0xcb, 0xc8, 0x3f, 0xcd, 0xce,	/* d0-d7 */
	0xcf, 0x3f, 0x3f, 0x3f, 0x3f, 0xa6, 0xcc, 0x3f,	/* d8-df */
	0xd3, 0xdf, 0xd4, 0xd2, 0xf5, 0xd5, 0xb5, 0xfe,	/* e0-e7 */
	0xde, 0xda, 0xdb, 0xd9, 0xfd, 0xdd, 0xaf, 0x3f,	/* e8-ef */
	0xad, 0xb1, 0x3f, 0xbe, 0xb6, 0xa7, 0xf7, 0xb8,	/* f0-f7 */
	0xb0, 0xa8, 0xb7, 0xb9, 0xb3, 0xb2, 0x3f, 0x3f,	/* f8-ff */
};

static const u_char
u2l[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, /* 00-07 */
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, /* 08-0f */
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, /* 10-17 */
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, /* 18-1f */
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, /* 20-27 */
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, /* 28-2f */
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, /* 30-37 */
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, /* 38-3f */
	0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, /* 40-47 */
	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, /* 48-4f */
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, /* 50-57 */
	0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, /* 58-5f */
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, /* 60-67 */
	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, /* 68-6f */
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, /* 70-77 */
	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, /* 78-7f */
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, /* 80-87 */
	0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, /* 88-8f */
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, /* 90-97 */
	0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, /* 98-9f */
	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, /* a0-a7 */
	0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, /* a8-af */
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, /* b0-b7 */
	0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, /* b8-bf */
	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, /* c0-c7 */
	0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, /* c8-cf */
	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xd7, /* d0-d7 */
	0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf, /* d8-df */
	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, /* e0-e7 */
	0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, /* e8-ef */
	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, /* f0-f7 */
	0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, /* f8-ff */
};

/*
 * DOS filenames are made of 2 parts, the name part and the extension part.
 * The name part is 8 characters long and the extension part is 3
 * characters long.  They may contain trailing blanks if the name or
 * extension are not long enough to fill their respective fields.
 */

/*
 * Convert a DOS filename to a unix filename. And, return the number of
 * characters in the resulting unix filename excluding the terminating
 * null.
 */
int
dos2unixfn(u_char dn[11], u_char *un, int lower)
{
	int i;
	int thislong = 1;
	u_char c;

	/*
	 * If first char of the filename is SLOT_E5 (0x05), then the real
	 * first char of the filename should be 0xe5. But, they couldn't
	 * just have a 0xe5 mean 0xe5 because that is used to mean a freed
	 * directory slot. Another dos quirk.
	 */
	if (*dn == SLOT_E5)
		c = dos2unix[0xe5];
	else
		c = dos2unix[*dn];
	*un++ = lower ? u2l[c] : c;
	dn++;

	/*
	 * Copy the name portion into the unix filename string.
	 */
	for (i = 1; i < 8 && *dn != ' '; i++) {
		c = dos2unix[*dn++];
		*un++ = lower ? u2l[c] : c;
		thislong++;
	}
	dn += 8 - i;

	/*
	 * Now, if there is an extension then put in a period and copy in
	 * the extension.
	 */
	if (*dn != ' ') {
		*un++ = '.';
		thislong++;
		for (i = 0; i < 3 && *dn != ' '; i++) {
			c = dos2unix[*dn++];
			*un++ = lower ? u2l[c] : c;
			thislong++;
		}
	}
	*un++ = 0;

	return (thislong);
}

/*
 * Convert a unix filename to a DOS filename according to Win95 rules.
 * If applicable and gen is not 0, it is inserted into the converted
 * filename as a generation number.
 * Returns
 *	0 if name couldn't be converted
 *	1 if the converted name is the same as the original
 *	  (no long filename entry necessary for Win95)
 *	2 if conversion was successful
 *	3 if conversion was successful and generation number was inserted
 */
int
unix2dosfn(u_char *un, u_char dn[11], int unlen, u_int gen)
{
	int i, j, l;
	int conv = 1;
	u_char *cp, *dp, *dp1;
	u_char gentext[6];

	/*
	 * Fill the dos filename string with blanks. These are DOS's pad
	 * characters.
	 */
	for (i = 0; i < 11; i++)
		dn[i] = ' ';

	/*
	 * The filenames "." and ".." are handled specially, since they
	 * don't follow dos filename rules.
	 */
	if (un[0] == '.' && unlen == 1) {
		dn[0] = '.';
		return gen <= 1;
	}
	if (un[0] == '.' && un[1] == '.' && unlen == 2) {
		dn[0] = '.';
		dn[1] = '.';
		return gen <= 1;
	}

	/*
	 * Filenames with only blanks and dots are not allowed!
	 */
	for (cp = un, i = unlen; --i >= 0; cp++)
		if (*cp != ' ' && *cp != '.')
			break;
	if (i < 0)
		return 0;

	/*
	 * Now find the extension
	 * Note: dot as first char doesn't start extension
	 *	 and trailing dots and blanks are ignored
	 */
	dp = dp1 = 0;
	for (cp = un + 1, i = unlen - 1; --i >= 0;) {
		switch (*cp++) {
		case '.':
			if (!dp1)
				dp1 = cp;
			break;
		case ' ':
			break;
		default:
			if (dp1)
				dp = dp1;
			dp1 = 0;
			break;
		}
	}

	/*
	 * Now convert it
	 */
	if (dp) {
		if (dp1)
			l = dp1 - dp;
		else
			l = unlen - (dp - un);
		for (i = 0, j = 8; i < l && j < 11; i++, j++) {
			if (dp[i] != (dn[j] = unix2dos[dp[i]])
			    && conv != 3)
				conv = 2;
			if (!dn[j]) {
				conv = 3;
				dn[j--] = ' ';
			}
		}
		if (i < l)
			conv = 3;
		dp--;
	} else {
		for (dp = cp; *--dp == ' ' || *dp == '.';);
		dp++;
	}

	/*
	 * Now convert the rest of the name
	 */
	for (i = j = 0; un < dp && j < 8; i++, j++, un++) {
		if (*un != (dn[j] = unix2dos[*un])
		    && conv != 3)
			conv = 2;
		if (!dn[j]) {
			conv = 3;
			dn[j--] = ' ';
		}
	}
	if (un < dp)
		conv = 3;
	/*
	 * If we didn't have any chars in filename,
	 * generate a default
	 */
	if (!j)
		dn[0] = '_';

	/*
	 * The first character cannot be E5,
	 * because that means a deleted entry
	 */
	if (dn[0] == 0xe5)
		dn[0] = SLOT_E5;

	/*
	 * If there wasn't any char dropped,
	 * there is no place for generation numbers
	 */
	if (conv != 3) {
		if (gen > 1)
			return 0;
		return conv;
	}

	/*
	 * Now insert the generation number into the filename part
	 */
	for (cp = gentext + sizeof(gentext); cp > gentext && gen; gen /= 10)
		*--cp = gen % 10 + '0';
	if (gen)
		return 0;
	for (i = 8; dn[--i] == ' ';);
	if (gentext + sizeof(gentext) - cp + 1 > 8 - i)
		i = 8 - (gentext + sizeof(gentext) - cp + 1);
	dn[i++] = '~';
	while (cp < gentext + sizeof(gentext))
		dn[i++] = *cp++;
	return 3;
}

/*
 * Create a Win95 long name directory entry
 * Note: assumes that the filename is valid,
 *	 i.e. doesn't consist solely of blanks and dots
 */
int
unix2winfn(u_char *un, int unlen, struct winentry *wep, int cnt, int chksum)
{
	u_int8_t *cp;
	int i;

	/*
	 * Drop trailing blanks and dots
	 */
	for (cp = un + unlen; *--cp == ' ' || *cp == '.'; unlen--);

	un += (cnt - 1) * WIN_CHARS;
	unlen -= (cnt - 1) * WIN_CHARS;

	/*
	 * Initialize winentry to some useful default
	 */
	for (cp = (u_int8_t *)wep, i = sizeof(*wep); --i >= 0; *cp++ = 0xff);
	wep->weCnt = cnt;
	wep->weAttributes = ATTR_WIN95;
	wep->weReserved1 = 0;
	wep->weChksum = chksum;
	wep->weReserved2 = 0;

	/*
	 * Now convert the filename parts
	 */
	for (cp = wep->wePart1, i = sizeof(wep->wePart1)/2; --i >= 0;) {
		if (--unlen < 0)
			goto done;
		*cp++ = *un++;
		*cp++ = 0;
	}
	for (cp = wep->wePart2, i = sizeof(wep->wePart2)/2; --i >= 0;) {
		if (--unlen < 0)
			goto done;
		*cp++ = *un++;
		*cp++ = 0;
	}
	for (cp = wep->wePart3, i = sizeof(wep->wePart3)/2; --i >= 0;) {
		if (--unlen < 0)
			goto done;
		*cp++ = *un++;
		*cp++ = 0;
	}
	if (!unlen)
		wep->weCnt |= WIN_LAST;
	return unlen;

done:
	*cp++ = 0;
	*cp++ = 0;
	wep->weCnt |= WIN_LAST;
	return 0;
}

/*
 * Compare our filename to the one in the Win95 entry
 * Returns the checksum or -1 if no match
 */
int
winChkName(u_char *un, int unlen, struct winentry *wep, int chksum)
{
	u_int8_t *cp;
	int i;

	/*
	 * First compare checksums
	 */
	if (wep->weCnt&WIN_LAST)
		chksum = wep->weChksum;
	else if (chksum != wep->weChksum)
		chksum = -1;
	if (chksum == -1)
		return -1;

	/*
	 * Offset of this entry
	 */
	i = ((wep->weCnt&WIN_CNT) - 1) * WIN_CHARS;
	if ((unlen -= i) <= 0)
		return -1;
	un += i;

	if ((wep->weCnt&WIN_LAST) && unlen > WIN_CHARS)
		return -1;

	/*
	 * Compare the name parts
	 */
	for (cp = wep->wePart1, i = sizeof(wep->wePart1)/2; --i >= 0;) {
		if (--unlen < 0) {
			if (!*cp++ && !*cp)
				return chksum;
			return -1;
		}
		if (u2l[*cp++] != u2l[*un++] || *cp++)
			return -1;
	}
	for (cp = wep->wePart2, i = sizeof(wep->wePart2)/2; --i >= 0;) {
		if (--unlen < 0) {
			if (!*cp++ && !*cp)
				return chksum;
			return -1;
		}
		if (u2l[*cp++] != u2l[*un++] || *cp++)
			return -1;
	}
	for (cp = wep->wePart3, i = sizeof(wep->wePart3)/2; --i >= 0;) {
		if (--unlen < 0) {
			if (!*cp++ && !*cp)
				return chksum;
			return -1;
		}
		if (u2l[*cp++] != u2l[*un++] || *cp++)
			return -1;
	}
	return chksum;
}

/*
 * Convert Win95 filename to dirbuf.
 * Returns the checksum or -1 if impossible
 */
int
win2unixfn(struct winentry *wep, struct dirent *dp, int chksum)
{
	u_int8_t *cp;
	u_int8_t *np, *ep = dp->d_name + WIN_MAXLEN;
	int i;

	if ((wep->weCnt&WIN_CNT) > howmany(WIN_MAXLEN, WIN_CHARS)
	    || !(wep->weCnt&WIN_CNT))
		return -1;

	/*
	 * First compare checksums
	 */
	if (wep->weCnt&WIN_LAST) {
		chksum = wep->weChksum;
		/*
		 * This works even though d_namlen is one byte!
		 */
		dp->d_namlen = (wep->weCnt&WIN_CNT) * WIN_CHARS;
	} else if (chksum != wep->weChksum)
		chksum = -1;
	if (chksum == -1)
		return -1;

	/*
	 * Offset of this entry
	 */
	i = ((wep->weCnt&WIN_CNT) - 1) * WIN_CHARS;
	np = (u_int8_t *)dp->d_name + i;

	/*
	 * Convert the name parts
	 */
	for (cp = wep->wePart1, i = sizeof(wep->wePart1)/2; --i >= 0;) {
		switch (*np++ = *cp++) {
		case 0:
			dp->d_namlen -= sizeof(wep->wePart2)/2
			    + sizeof(wep->wePart3)/2 + i + 1;
			return chksum;
		case '/':
			np[-1] = 0;
			return -1;
		}
		/*
		 * The size comparison should result in the compiler
		 * optimizing the whole if away
		 */
		if (WIN_MAXLEN % WIN_CHARS < sizeof(wep->wePart1) / 2
		    && np > ep) {
			np[-1] = 0;
			return -1;
		}
		if (*cp++)
			return -1;
	}
	for (cp = wep->wePart2, i = sizeof(wep->wePart2)/2; --i >= 0;) {
		switch (*np++ = *cp++) {
		case 0:
			dp->d_namlen -= sizeof(wep->wePart3)/2 + i + 1;
			return chksum;
		case '/':
			np[-1] = 0;
			return -1;
		}
		/*
		 * The size comparisons should be optimized away
		 */
		if (WIN_MAXLEN % WIN_CHARS >= sizeof(wep->wePart1) / 2
		    && WIN_MAXLEN % WIN_CHARS < (sizeof(wep->wePart1) + sizeof(wep->wePart2)) / 2
		    && np > ep) {
			np[-1] = 0;
			return -1;
		}
		if (*cp++)
			return -1;
	}
	for (cp = wep->wePart3, i = sizeof(wep->wePart3)/2; --i >= 0;) {
		switch (*np++ = *cp++) {
		case 0:
			dp->d_namlen -= i + 1;
			return chksum;
		case '/':
			np[-1] = 0;
			return -1;
		}
		/*
		 * See above
		 */
		if (WIN_MAXLEN % WIN_CHARS >= (sizeof(wep->wePart1) + sizeof(wep->wePart2)) / 2
		    && np > ep) {
			np[-1] = 0;
			return -1;
		}
		if (*cp++)
			return -1;
	}
	return chksum;
}

/*
 * Compute the checksum of a DOS filename for Win95 use
 */
u_int8_t
winChksum(u_int8_t *name)
{
	int i;
	u_int8_t s;

	for (s = 0, i = 11; --i >= 0; s += *name++)
		s = (s << 7)|(s >> 1);
	return s;
}

/*
 * Determine the number of slots necessary for Win95 names
 */
int
winSlotCnt(u_char *un, int unlen)
{
	for (un += unlen; unlen > 0; unlen--)
		if (*--un != ' ' && *un != '.')
			break;
	if (unlen > WIN_MAXLEN)
		return 0;
	return howmany(unlen, WIN_CHARS);
}
@


1.18
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.17 2014/04/21 15:35:02 krw Exp $	*/
d37 1
a37 1
 * 
d40 1
a40 1
 * 
d42 1
a42 1
 * 
d47 1
a47 1
 * 
d375 1
a375 1
	
d385 1
a385 1
	
d422 1
a422 1
	
d429 1
a429 1
	
d452 1
a452 1
	
d474 1
a474 1
	
d520 1
a520 1
	
d527 1
a527 1
	
d537 1
a537 1
	
d572 1
a572 1
	
d582 1
a582 1
	
d624 1
a624 1
	
d634 1
a634 1
	
d645 1
a645 1
	
d693 1
a693 1
	
d707 1
a707 1
	
d713 1
a713 1
	
d791 1
a791 1
	
@


1.17
log
@msdosfs timestamps can only represent 1/1/1980 through
12/31/2107. 64-bit time_t now dominates that entire range, so simply
set all dates that cannot be represented to 1/1/1980 like Redmond
intended.

Problem reported by Alessandro De Laurenzis via misc@@.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.16 2013/10/01 20:22:13 sf Exp $	*/
d60 1
@


1.16
log
@Format string fixes: %hu/%hd for uint16_t, %u/%d/%x for uint32_t

- despite the name, ntohl returns uint32_t, not long
- also fix some %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.15 2012/09/06 19:06:04 krw Exp $	*/
d87 1
a87 1
uint32_t lasttime;
d99 1
a99 1
	uint32_t t;
d113 9
@


1.15
log
@Remove the need to occasionally treat dos file names as strings by
using "%.11s" to print them out. Make all dos file names 11 byte
arrays and nuke the attempt to put '\0' at the 12th position of
such an array.

Fixes 'panic: smashed stack in msdosfs_rename.c' reported by
MERHIGI Marcus via tech@@.

Tested by MERHIGI Marcus. Suggestions and ok tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.14 2009/08/13 22:34:29 jasper Exp $	*/
d212 1
a212 1
			printf("dos2unixtime(): month value out of range (%ld)\n",
@


1.14
log
@- ansify function declarations, no binary change

"fine" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.13 2004/05/14 04:05:05 tedu Exp $	*/
d406 1
a406 1
unix2dosfn(u_char *un, u_char dn[12], int unlen, u_int gen)
a418 1
	dn[11] = 0;
@


1.13
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.11 2004/03/31 18:48:15 millert Exp $	*/
d97 1
a97 5
unix2dostime(tsp, ddp, dtp, dhp)
	struct timespec *tsp;
	u_int16_t *ddp;
	u_int16_t *dtp;
	u_int8_t *dhp;
d175 1
a175 5
dos2unixtime(dd, dt, dh, tsp)
	u_int dd;
	u_int dt;
	u_int dh;
	struct timespec *tsp;
d347 1
a347 4
dos2unixfn(dn, un, lower)
	u_char dn[11];
	u_char *un;
	int lower;
d406 1
a406 5
unix2dosfn(un, dn, unlen, gen)
	u_char *un;
	u_char dn[12];
	int unlen;
	u_int gen;
d551 1
a551 6
unix2winfn(un, unlen, wep, cnt, chksum)
	u_char *un;
	int unlen;
	struct winentry *wep;
	int cnt;
	int chksum;
d611 1
a611 5
winChkName(un, unlen, wep, chksum)
	u_char *un;
	int unlen;
	struct winentry *wep;
	int chksum;
d675 1
a675 4
win2unixfn(wep, dp, chksum)
	struct winentry *wep;
	struct dirent *dp;
	int chksum;
d778 1
a778 2
winChksum(name)
	u_int8_t *name;
d792 1
a792 3
winSlotCnt(un, unlen)
	u_char *un;
	int unlen;
@


1.12
log
@32 bit ints are uint32_t, not u_long.  works on 64bit now.  ok deraadt@@
@
text
@@


1.11
log
@Fix false positives when comparing long file names that have the
same first 13 (or some multiple thereof) characters.
Fix was verified by reporter (Kong Long); from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.10 2003/07/29 19:26:38 mickey Exp $	*/
d87 2
a88 2
u_long lasttime;
u_long lastday;
d103 5
a107 5
	u_long t;
	u_long days;
	u_long inc;
	u_long year;
	u_long month;
d171 1
a171 1
u_long lastseconds;
d185 4
a188 4
	u_long seconds;
	u_long m, month;
	u_long y, year;
	u_long days;
@


1.10
log
@constify the conversion tables
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.9 2001/05/17 00:58:01 pvalchev Exp $	*/
d657 3
@


1.9
log
@It's Daylight Saving Time, not Savings.  Fix comments.
Discussed with pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.8 1998/01/11 20:39:06 provos Exp $	*/
d70 1
a70 1
u_short regyear[] = {
d78 1
a78 1
u_short leapyear[] = {
d108 1
a108 1
	u_short *months;
d189 1
a189 1
	u_short *months;
d234 1
a234 1
static u_char
d270 1
a270 1
static u_char
d306 1
a306 1
static u_char
@


1.8
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.7 1997/10/04 19:08:11 deraadt Exp $	*/
d115 1
a115 1
	     /* +- daylight savings time correction */ ;
d230 1
a230 1
	     /* -+ daylight savings time correction */ ;
@


1.8.10.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.8 1998/01/11 20:39:06 provos Exp $	*/
d115 1
a115 1
	     /* +- daylight saving time correction */ ;
d230 1
a230 1
	     /* -+ daylight saving time correction */ ;
@


1.8.10.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
const u_short regyear[] = {
d78 1
a78 1
const u_short leapyear[] = {
d108 1
a108 1
	const u_short *months;
d189 1
a189 1
	const u_short *months;
d234 1
a234 1
static const u_char
d270 1
a270 1
static const u_char
d306 1
a306 1
static const u_char
@


1.8.10.3
log
@Merge with the trunk
@
text
@d87 2
a88 2
uint32_t lasttime;
uint32_t lastday;
d103 5
a107 5
	uint32_t t;
	uint32_t days;
	uint32_t inc;
	uint32_t year;
	uint32_t month;
d171 1
a171 1
uint32_t lastseconds;
d185 4
a188 4
	uint32_t seconds;
	uint32_t m, month;
	uint32_t y, year;
	uint32_t days;
a656 3

	if ((wep->weCnt&WIN_LAST) && unlen > WIN_CHARS)
		return -1;
@


1.7
log
@cleanup timestamp code for NT/Win95; khym@@bga.com
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_conv.c,v 1.6 1997/03/02 18:01:53 millert Exp $	*/
/*	$NetBSD: msdosfs_conv.c,v 1.17 1996/02/09 19:13:42 christos Exp $	*/
d5 2
a6 2
 * Copyright (C) 1995 Wolfgang Solfrank.
 * Copyright (C) 1995 TooLs GmbH.
d97 1
a97 1
unix2dostime(tsp, ddp, dtp)
d101 1
d116 1
d158 3
d179 1
a179 1
dos2unixtime(dd, dt, tsp)
d182 1
d201 2
a202 1
	    + ((dt & DT_HOURS_MASK) >> DT_HOURS_SHIFT) * 3600;
d231 1
a231 1
	tsp->tv_nsec = 0;
d556 1
a556 1
		dn[i] = *cp++;
@


1.6
log
@Sync msdosfs with NetBSD sans const-ness.  NetSBD log messages:
    Fix panic on mkdir.
    Thanks to Dave Huang for finding the bug.
    Fixes a bug with allowed/forbidden characters in non-W95 filenames.
    Don't extend directory when nothing is written to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.5 1996/03/02 00:54:54 niklas Exp $	*/
d153 3
a155 1
	*dtp = lastdtime;
@


1.5
log
@Fix missed s/ts_/tv_/ replacements in last patch
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_conv.c,v 1.4 1996/02/29 10:46:49 niklas Exp $	*/
a107 9
	struct timespec ts;

	/*
	 * NULL means to read the current time.
	 */
	if (tsp == NULL) {
		TIMEVAL_TO_TIMESPEC(&time, &ts);
		tsp = &ts;
	}
a210 1
#if 0
d212 1
a212 2
			       month);
#endif
d231 2
a232 2
	0,    0x21, 0,    0x23, 0x24, 0x25, 0x26, 0,	/* 20-27 */
	0x28, 0x29, 0,    0,    0x2c, 0x2d, 0,    0,	/* 28-2f */
d234 1
a234 1
	0x38, 0x39, 0,    0x3b, 0,    0,    0,    0,	/* 38-3f */
d238 1
a238 1
	0x58, 0x59, 0x5a, 0,    0,    0,    0,    0x5f,	/* 58-5f */
@


1.4
log
@From NetBSD: merge with 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d122 1
a122 1
	t = tsp->ts_sec - (tz.tz_minuteswest * 60)
d231 1
a231 1
	tsp->ts_sec = seconds + lastseconds + (tz.tz_minuteswest * 60)
d233 1
a233 1
	tsp->ts_nsec = 0;
@


1.3
log
@elliminate unneccessary printf in dos2unix time conversion,
coze for Windoze 95 fs it is ok.
@
text
@d1 2
a2 1
/*	$OpenBSD: msdosfs_conv.c,v 1.13 1995/11/29 15:08:36 ws Exp $	*/
d55 1
d126 1
a126 1
		lastdtime = (((t % 60) >> 1) << DT_2SECONDS_SHIFT)
d192 9
a200 1
	seconds = ((dt & DT_2SECONDS_MASK) >> DT_2SECONDS_SHIFT)
@


1.2
log
@from netbsd (mostly by ws):
Win95 ignores case on lookup
Really don't generate long names when mounted with -s
Fix cookie handling
Don't forward credentials to bread, it makes nfs panic
(Of course, nfs shouldn't rely on the credentials not being referenced)
Don't give directory entry to deget, it could result in a deadlock
Use device blocks, not clusters for logical block numbers
Add support for Win'95 separate creation/modification/access timestamps
Re-introduce lowercase filenames for non-Win'95-filesystems
Fix thinko with block boundaries in directories
Don't overwrite dirclust, it's needed later on
Enable flock(2).
@
text
@d1 1
a1 1
/*	$NetBSD: msdosfs_conv.c,v 1.13 1995/11/29 15:08:36 ws Exp $	*/
d210 1
d213 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: msdosfs_conv.c,v 1.10 1994/12/27 18:36:24 mycroft Exp $	*/
d3 31
d56 2
d63 1
d224 107
a330 8
/*
 * Cheezy macros to do case detection and conversion for the ascii
 * character set.  DOESN'T work for ebcdic.
 */
#define	isupper(c)	(c >= 'A'  &&  c <= 'Z')
#define	islower(c)	(c >= 'a'  &&  c <= 'z')
#define	toupper(c)	(c & ~' ')
#define	tolower(c)	(c | ' ')
d345 1
a345 1
dos2unixfn(dn, un)
d348 1
d351 1
a351 3
	int ni;
	int ei;
	int thislong = 0;
a352 1
	u_char *origun = un;
d355 4
a358 9
	 * Find the last character in the name portion of the dos filename.
	 */
	for (ni = 7; ni >= 0; ni--)
		if (dn[ni] != ' ')
			break;

	/*
	 * Find the last character in the extension portion of the
	 * filename.
d360 13
a372 13
	for (ei = 10; ei >= 8; ei--)
		if (dn[ei] != ' ')
			break;

	/*
	 * Copy the name portion into the unix filename string. NOTE: DOS
	 * filenames are usually kept in upper case.  To make it more unixy
	 * we convert all DOS filenames to lower case.  Some may like this,
	 * some may not.
	 */
	for (i = 0; i <= ni; i++) {
		c = dn[i];
		*un++ = isupper(c) ? tolower(c) : c;
d375 2
a376 1

d381 1
a381 1
	if (ei >= 8) {
d384 3
a386 3
		for (i = 8; i <= ei; i++) {
			c = dn[i];
			*un++ = isupper(c) ? tolower(c) : c;
a391 9
	/*
	 * If first char of the filename is SLOT_E5 (0x05), then the real
	 * first char of the filename should be 0xe5. But, they couldn't
	 * just have a 0xe5 mean 0xe5 because that is used to mean a freed
	 * directory slot. Another dos quirk.
	 */
	if (*origun == SLOT_E5)
		*origun = 0xe5;

d396 9
a404 2
 * Convert a unix filename to a DOS filename. This function does not ensure
 * that valid characters for a dos filename are supplied.
d406 2
a407 2
void
unix2dosfn(un, dn, unlen)
d409 1
a409 1
	u_char dn[11];
d411 1
d413 5
a417 3
	int i;
	u_char c;

d422 1
a422 1
	for (i = 0; i <= 10; i++)
d424 2
a425 1

d432 1
a432 1
		return;
d437 1
a437 1
		return;
d441 32
a472 4
	 * Copy the unix filename into the dos filename string upto the end
	 * of string, a '.', or 8 characters. Whichever happens first stops
	 * us. This forms the name portion of the dos filename. Fold to
	 * upper case.
d474 20
a493 4
	for (i = 0; i <= 7 && unlen && (c = *un) && c != '.'; i++) {
		dn[i] = islower(c) ? toupper(c) : c;
		un++;
		unlen--;
d497 1
a497 5
	 * If the first char of the filename is 0xe5, then translate it to
	 * 0x05.  This is because 0xe5 is the marker for a deleted
	 * directory slot.  I guess this means you can't have filenames
	 * that start with 0x05.  I suppose we should check for this and
	 * doing something about it.
d499 23
a521 1
	if (dn[0] == SLOT_DELETED)
d523 42
d567 1
a567 2
	 * Strip any further characters up to a '.' or the end of the
	 * string.
d569 108
a676 6
	while (unlen && (c = *un)) {
		un++;
		unlen--;
		/* Make sure we've skipped over the dot before stopping. */
		if (c == '.')
			break;
d678 2
d681 18
d700 84
a783 8
	 * Copy in the extension part of the name, if any. Force to upper
	 * case. Note that the extension is allowed to contain '.'s.
	 * Filenames in this form are probably inaccessable under dos.
	 */
	for (i = 8; i <= 10 && unlen && (c = *un); i++) {
		dn[i] = islower(c) ? toupper(c) : c;
		un++;
		unlen--;
d785 32
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
