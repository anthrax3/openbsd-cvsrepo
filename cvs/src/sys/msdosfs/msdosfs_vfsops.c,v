head	1.84;
access;
symbols
	OPENBSD_6_2:1.84.0.4
	OPENBSD_6_2_BASE:1.84
	OPENBSD_6_1:1.83.0.4
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.78.0.2
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.73.0.2
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.71.0.6
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.63.0.6
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.63.0.2
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.62.0.2
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.61.0.6
	OPENBSD_5_2_BASE:1.61
	OPENBSD_5_1_BASE:1.61
	OPENBSD_5_1:1.61.0.4
	OPENBSD_5_0:1.61.0.2
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.59.0.2
	OPENBSD_4_9_BASE:1.59
	OPENBSD_4_8:1.57.0.4
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.57.0.2
	OPENBSD_4_7_BASE:1.57
	OPENBSD_4_6:1.51.0.6
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.50.0.4
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.2
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.47.0.2
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.36.0.6
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.36.0.4
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.32.0.4
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.30
	UBC:1.27.0.2
	UBC_BASE:1.27
	OPENBSD_3_0:1.23.0.4
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.20.0.4
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.19.0.2
	SMP_BASE:1.19
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.15.0.4
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.84
date	2017.05.29.14.07.16;	author sf;	state Exp;
branches;
next	1.83;
commitid	RrA5U39Nh8YngKWp;

1.83
date	2016.10.10.00.34.50;	author bluhm;	state Exp;
branches;
next	1.82;
commitid	acCovoubhhVmbWtj;

1.82
date	2016.10.09.23.49.54;	author bluhm;	state Exp;
branches;
next	1.81;
commitid	kue1rFKSznav4622;

1.81
date	2016.09.28.18.49.11;	author jca;	state Exp;
branches;
next	1.80;
commitid	mAzI7lxqp1iNVc8B;

1.80
date	2016.09.07.17.30.12;	author natano;	state Exp;
branches;
next	1.79;
commitid	D0avTYSlvEmEjLyB;

1.79
date	2016.08.13.20.53.17;	author guenther;	state Exp;
branches;
next	1.78;
commitid	15rk0aE492iEzsGW;

1.78
date	2016.05.22.20.27.04;	author bluhm;	state Exp;
branches;
next	1.77;
commitid	IMex9jbP378m0AFa;

1.77
date	2016.04.26.18.37.03;	author natano;	state Exp;
branches;
next	1.76;
commitid	WbumX8gCUOD8jZ5X;

1.76
date	2016.03.27.11.39.37;	author bluhm;	state Exp;
branches;
next	1.75;
commitid	C0IKsjKoZxFScK3M;

1.75
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.74;
commitid	gAjwyca5TfuoJAhn;

1.74
date	2016.03.17.18.52.31;	author bluhm;	state Exp;
branches;
next	1.73;
commitid	XOU3hWgTktDOU9BT;

1.73
date	2015.10.23.17.21.34;	author krw;	state Exp;
branches;
next	1.72;
commitid	OojuukoxD2uoNfhb;

1.72
date	2015.10.23.10.45.31;	author krw;	state Exp;
branches;
next	1.71;
commitid	SncnQqnXMdpzMlro;

1.71
date	2015.02.13.13.35.03;	author millert;	state Exp;
branches;
next	1.70;
commitid	AdfxL7vCLZYT5vxT;

1.70
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.69;
commitid	P6Av4XGqOi3rFasL;

1.69
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.68;
commitid	zM5ckwX4kwwmipG0;

1.68
date	2014.07.12.18.50.41;	author tedu;	state Exp;
branches;
next	1.67;
commitid	6GFaFyr1WL4xRwvz;

1.67
date	2014.06.23.18.54.33;	author tobias;	state Exp;
branches;
next	1.66;
commitid	eqCuzBMbA1Y9mFO2;

1.66
date	2014.06.18.17.24.46;	author tobias;	state Exp;
branches;
next	1.65;
commitid	PcFKoKWMluazbjIE;

1.65
date	2014.05.27.21.52.19;	author sf;	state Exp;
branches;
next	1.64;

1.64
date	2014.05.09.03.54.28;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.62;

1.62
date	2012.09.10.11.10.59;	author jsing;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2010.11.17.12.27.03;	author jsing;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.23.18.40.00;	author oga;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.24.18.12.46;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2009.12.19.00.27.17;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.54;

1.54
date	2009.08.30.15.31.24;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2009.08.14.11.35.03;	author jasper;	state Exp;
branches;
next	1.52;

1.52
date	2009.08.13.22.34.29;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.05.01.14.40;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.26.00.30.44;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.15.19.11.52;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.16.12.44.05;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2006.12.15.03.04.24;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.14.10.55.03;	author tom;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.14.07.37.24;	author tom;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.29.13.35.07;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.26.00.59.32;	author pedro;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.22.19.30.48;	author sturm;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.07.15.50.42;	author pedro;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.06.18.42.01;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.19.15.48.06;	author sturm;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.02.00.46.10;	author tom;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.14.04.05.05;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.12.21.04.15;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.14.17.55.07;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.10.02.19.34;	author art;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.21.21.37.01;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.21.21.16.18;	author csapuntz;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.04.06.32.40;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.20.01.50.11;	author assar;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.07.17.51.48;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.15.03.18.02;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.07.04.57.17;	author assar;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	99.05.31.17.34.51;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.05.01.23.47.21;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.01.10.21.53.02;	author art;	state Exp;
branches;
next	1.15;

1.15
date	98.02.23.20.10.38;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	98.02.08.22.41.44;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	98.01.11.20.39.10;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.11.10.21.17.29;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.11.09.23.15.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.05.58.57;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.20.20.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.15.22.39;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.06.20.14.04.30;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.03.02.18.01.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.28.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.02.29.10.46.57;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.29.07.05.58;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.19.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches;
next	;

1.19.2.1
date	2000.03.24.09.09.30;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.05.14.22.32.59;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2002.03.06.02.13.25;	author niklas;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2003.03.28.00.00.21;	author niklas;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2003.05.13.19.21.30;	author ho;	state Exp;
branches;
next	1.19.2.8;

1.19.2.8
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.19.2.9;

1.19.2.9
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.27.2.1
date	2002.06.11.03.30.32;	author art;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2003.05.19.22.27.06;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.84
log
@msdosfs & ffs: flush cache if updating mount from r/w to r/o

ok deraadt@@
@
text
@/*	$OpenBSD: msdosfs_vfsops.c,v 1.83 2016/10/10 00:34:50 bluhm Exp $	*/
/*	$NetBSD: msdosfs_vfsops.c,v 1.48 1997/10/18 02:54:57 briggs Exp $	*/

/*-
 * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995, 1997 TooLs GmbH.
 * All rights reserved.
 * Original code by Paul Popelka (paulp@@uts.amdahl.com) (see below).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Written by Paul Popelka (paulp@@uts.amdahl.com)
 *
 * You can do anything you want with this software, just don't say you wrote
 * it, and don't remove this notice.
 *
 * This software is provided "as is".
 *
 * The author supplies this software to be publicly redistributed on the
 * understanding that the author is not responsible for the correct
 * functioning of this software in any circumstances and is not liable for
 * any damages caused by this software.
 *
 * October 1992
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/specdev.h> /* XXX */	/* defines v_rdev */
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/file.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/dirent.h>
#include <sys/disk.h>
#include <sys/dkio.h>
#include <sys/stdint.h>

#include <msdosfs/bpb.h>
#include <msdosfs/bootsect.h>
#include <msdosfs/direntry.h>
#include <msdosfs/denode.h>
#include <msdosfs/msdosfsmount.h>
#include <msdosfs/fat.h>

int msdosfs_mount(struct mount *, const char *, void *, struct nameidata *,
		       struct proc *);
int msdosfs_start(struct mount *, int, struct proc *);
int msdosfs_unmount(struct mount *, int, struct proc *);
int msdosfs_root(struct mount *, struct vnode **);
int msdosfs_statfs(struct mount *, struct statfs *, struct proc *);
int msdosfs_sync(struct mount *, int, struct ucred *, struct proc *);
int msdosfs_fhtovp(struct mount *, struct fid *, struct vnode **);
int msdosfs_vptofh(struct vnode *, struct fid *);
int msdosfs_check_export(struct mount *mp, struct mbuf *nam,
			      int *extflagsp, struct ucred **credanonp);

int msdosfs_mountfs(struct vnode *, struct mount *, struct proc *,
			 struct msdosfs_args *);

int msdosfs_sync_vnode(struct vnode *, void *);

/*
 * mp - path - addr in user space of mount point (ie /usr or whatever)
 * data - addr in user space of mount params including the name of the block
 * special file to treat as a filesystem.
 */
int
msdosfs_mount(struct mount *mp, const char *path, void *data,
    struct nameidata *ndp, struct proc *p)
{
	struct vnode *devvp;	  /* vnode for blk device to mount */
	struct msdosfs_args args; /* will hold data from mount request */
	/* msdosfs specific mount control block */
	struct msdosfsmount *pmp = NULL;
	char fname[MNAMELEN];
	char fspec[MNAMELEN];
	int error, flags;

	error = copyin(data, &args, sizeof(struct msdosfs_args));
	if (error)
		return (error);

	/*
	 * If updating, check whether changing from read-only to
	 * read/write; if there is no device name, that's all we do.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		pmp = VFSTOMSDOSFS(mp);
		error = 0;
		if (!(pmp->pm_flags & MSDOSFSMNT_RONLY) &&
		    (mp->mnt_flag & MNT_RDONLY)) {
			mp->mnt_flag &= ~MNT_RDONLY;
			VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p);
			mp->mnt_flag |= MNT_RDONLY;

			flags = WRITECLOSE;
			if (mp->mnt_flag & MNT_FORCE)
				flags |= FORCECLOSE;
			error = vflush(mp, NULLVP, flags);
			if (!error) {
				int force = 0;

				pmp->pm_flags |= MSDOSFSMNT_RONLY;
				/* may be not supported, ignore error */
				VOP_IOCTL(pmp->pm_devvp, DIOCCACHESYNC,
				    &force, FWRITE, FSCRED, p);
			}
		}
		if (!error && (mp->mnt_flag & MNT_RELOAD))
			/* not yet implemented */
			error = EOPNOTSUPP;
		if (error)
			return (error);
		if ((pmp->pm_flags & MSDOSFSMNT_RONLY) &&
		    (mp->mnt_flag & MNT_WANTRDWR))
			pmp->pm_flags &= ~MSDOSFSMNT_RONLY;

		if (args.fspec == NULL) {
#ifdef	__notyet__		/* doesn't work correctly with current mountd	XXX */
			if (args.flags & MSDOSFSMNT_MNTOPT) {
				pmp->pm_flags &= ~MSDOSFSMNT_MNTOPT;
				pmp->pm_flags |= args.flags & MSDOSFSMNT_MNTOPT;
				if (pmp->pm_flags & MSDOSFSMNT_NOWIN95)
					pmp->pm_flags |= MSDOSFSMNT_SHORTNAME;
			}
#endif
			/*
			 * Process export requests.
			 */
			return (vfs_export(mp, &pmp->pm_export,
			    &args.export_info));
		}
	}

	/*
	 * Not an update, or updating the name: look up the name
	 * and verify that it refers to a sensible block device.
	 */
	error = copyinstr(args.fspec, fspec, sizeof(fspec), NULL);
	if (error)
		goto error;

	if (disk_map(fspec, fname, sizeof(fname), DM_OPENBLCK) == -1)
		bcopy(fspec, fname, sizeof(fname));

	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fname, p);
	if ((error = namei(ndp)) != 0)
		goto error;

	devvp = ndp->ni_vp;

	if (devvp->v_type != VBLK) {
		error = ENOTBLK;
		goto error_devvp;
	}
	if (major(devvp->v_rdev) >= nblkdev) {
		error = ENXIO;
		goto error_devvp;
	}

	if ((mp->mnt_flag & MNT_UPDATE) == 0)
		error = msdosfs_mountfs(devvp, mp, p, &args);
	else {
		if (devvp != pmp->pm_devvp)
			error = EINVAL;	/* XXX needs translation */
		else
			vrele(devvp);
	}
	if (error)
		goto error_devvp;

	pmp = VFSTOMSDOSFS(mp);
	pmp->pm_gid = args.gid;
	pmp->pm_uid = args.uid;
	pmp->pm_mask = args.mask;
	pmp->pm_flags |= args.flags & MSDOSFSMNT_MNTOPT;

	if (pmp->pm_flags & MSDOSFSMNT_NOWIN95)
		pmp->pm_flags |= MSDOSFSMNT_SHORTNAME;
	else if (!(pmp->pm_flags &
	    (MSDOSFSMNT_SHORTNAME | MSDOSFSMNT_LONGNAME))) {
		struct vnode *rvp;

		/*
		 * Try to divine whether to support Win'95 long filenames
		 */
		if (FAT32(pmp))
		        pmp->pm_flags |= MSDOSFSMNT_LONGNAME;
		else {
		        if ((error = msdosfs_root(mp, &rvp)) != 0) {
			        msdosfs_unmount(mp, MNT_FORCE, p);
			        goto error;
			}
			pmp->pm_flags |= findwin95(VTODE(rvp))
			     ? MSDOSFSMNT_LONGNAME
			     : MSDOSFSMNT_SHORTNAME;
			vput(rvp);
		}
	}

	if (pmp->pm_flags & MSDOSFSMNT_LONGNAME)
		mp->mnt_stat.f_namemax = WIN_MAXLEN;
	else
		mp->mnt_stat.f_namemax = 12;

	bzero(mp->mnt_stat.f_mntonname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntonname, path, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromname, fname, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);
	bcopy(&args, &mp->mnt_stat.mount_info.msdosfs_args, sizeof(args));

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_mount(): mp %p, pmp %p, inusemap %p\n", mp,
	    pmp, pmp->pm_inusemap);
#endif

	return (0);

error_devvp:
	vrele(devvp);

error:
	return (error);
}

int
msdosfs_mountfs(struct vnode *devvp, struct mount *mp, struct proc *p,
    struct msdosfs_args *argp)
{
	struct msdosfsmount *pmp;
	struct buf *bp;
	dev_t dev = devvp->v_rdev;
	union bootsector *bsp;
	struct byte_bpb33 *b33;
	struct byte_bpb50 *b50;
	struct byte_bpb710 *b710;
	extern struct vnode *rootvp;
	u_int8_t SecPerClust;
	int	ronly, error, bmapsiz;
	uint32_t fat_max_clusters;

	/*
	 * Disallow multiple mounts of the same device.
	 * Disallow mounting of a device that is currently in use
	 * (except for root, which might share swap device for miniroot).
	 * Flush out any old buffers remaining from a previous use.
	 */
	if ((error = vfs_mountedon(devvp)) != 0)
		return (error);
	if (vcount(devvp) > 1 && devvp != rootvp)
		return (EBUSY);
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0);
	VOP_UNLOCK(devvp, p);
	if (error)
		return (error);

	ronly = (mp->mnt_flag & MNT_RDONLY) != 0;
	error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p);
	if (error)
		return (error);

	bp  = NULL; /* both used in error_exit */
	pmp = NULL;

	/*
	 * Read the boot sector of the filesystem, and then check the
	 * boot signature.  If not a dos boot sector then error out.
	 */
	if ((error = bread(devvp, 0, 4096, &bp)) != 0)
		goto error_exit;
	bsp = (union bootsector *)bp->b_data;
	b33 = (struct byte_bpb33 *)bsp->bs33.bsBPB;
	b50 = (struct byte_bpb50 *)bsp->bs50.bsBPB;
	b710 = (struct byte_bpb710 *)bsp->bs710.bsBPB;

	pmp = malloc(sizeof *pmp, M_MSDOSFSMNT, M_WAITOK | M_ZERO);
	pmp->pm_mountp = mp;

	/*
	 * Compute several useful quantities from the bpb in the
	 * bootsector.  Copy in the dos 5 variant of the bpb then fix up
	 * the fields that are different between dos 5 and dos 3.3.
	 */
	SecPerClust = b50->bpbSecPerClust;
	pmp->pm_BytesPerSec = getushort(b50->bpbBytesPerSec);
	pmp->pm_ResSectors = getushort(b50->bpbResSectors);
	pmp->pm_FATs = b50->bpbFATs;
	pmp->pm_RootDirEnts = getushort(b50->bpbRootDirEnts);
	pmp->pm_Sectors = getushort(b50->bpbSectors);
	pmp->pm_FATsecs = getushort(b50->bpbFATsecs);
	pmp->pm_SecPerTrack = getushort(b50->bpbSecPerTrack);
	pmp->pm_Heads = getushort(b50->bpbHeads);
	pmp->pm_Media = b50->bpbMedia;

	/* Determine the number of DEV_BSIZE blocks in a MSDOSFS sector */
	pmp->pm_BlkPerSec = pmp->pm_BytesPerSec / DEV_BSIZE;

	if (!pmp->pm_BytesPerSec || !SecPerClust) {
		error = EFTYPE;
		goto error_exit;
	}

	if (pmp->pm_Sectors == 0) {
		pmp->pm_HiddenSects = getulong(b50->bpbHiddenSecs);
		pmp->pm_HugeSectors = getulong(b50->bpbHugeSectors);
	} else {
		pmp->pm_HiddenSects = getushort(b33->bpbHiddenSecs);
		pmp->pm_HugeSectors = pmp->pm_Sectors;
	}

	if (pmp->pm_RootDirEnts == 0) {
		if (pmp->pm_Sectors || pmp->pm_FATsecs ||
		    getushort(b710->bpbFSVers)) {
		        error = EINVAL;
			goto error_exit;
		}
		pmp->pm_fatmask = FAT32_MASK;
		pmp->pm_fatmult = 4;
		pmp->pm_fatdiv = 1;
		pmp->pm_FATsecs = getulong(b710->bpbBigFATsecs);
		if (getushort(b710->bpbExtFlags) & FATMIRROR)
		        pmp->pm_curfat = getushort(b710->bpbExtFlags) & FATNUM;
		else
		        pmp->pm_flags |= MSDOSFS_FATMIRROR;
	} else
	        pmp->pm_flags |= MSDOSFS_FATMIRROR;

	/*
	 * More sanity checks:
	 *	MSDOSFS sectors per cluster: >0 && power of 2
	 *	MSDOSFS sector size: >= DEV_BSIZE && power of 2
	 *	HUGE sector count: >0
	 *	FAT sectors: >0
	 */
	if ((SecPerClust == 0) || (SecPerClust & (SecPerClust - 1)) ||
	    (pmp->pm_BytesPerSec < DEV_BSIZE) ||
	    (pmp->pm_BytesPerSec & (pmp->pm_BytesPerSec - 1)) ||
	    (pmp->pm_HugeSectors == 0) || (pmp->pm_FATsecs == 0) ||
	    (SecPerClust * pmp->pm_BlkPerSec > MAXBSIZE / DEV_BSIZE)) {
		error = EINVAL;
		goto error_exit;
	}

	pmp->pm_HugeSectors *= pmp->pm_BlkPerSec;
	pmp->pm_HiddenSects *= pmp->pm_BlkPerSec;
	pmp->pm_FATsecs *= pmp->pm_BlkPerSec;
	pmp->pm_fatblk = pmp->pm_ResSectors * pmp->pm_BlkPerSec;
	SecPerClust *= pmp->pm_BlkPerSec;

	if (FAT32(pmp)) {
	        pmp->pm_rootdirblk = getulong(b710->bpbRootClust);
		pmp->pm_firstcluster = pmp->pm_fatblk
		        + (pmp->pm_FATs * pmp->pm_FATsecs);
		pmp->pm_fsinfo = getushort(b710->bpbFSInfo) * pmp->pm_BlkPerSec;
	} else {
	        pmp->pm_rootdirblk = pmp->pm_fatblk +
		        (pmp->pm_FATs * pmp->pm_FATsecs);
		pmp->pm_rootdirsize = (pmp->pm_RootDirEnts * sizeof(struct direntry)
				       + DEV_BSIZE - 1) / DEV_BSIZE;
		pmp->pm_firstcluster = pmp->pm_rootdirblk + pmp->pm_rootdirsize;
	}

	pmp->pm_nmbrofclusters = (pmp->pm_HugeSectors - pmp->pm_firstcluster) /
	    SecPerClust;
	pmp->pm_maxcluster = pmp->pm_nmbrofclusters + 1;
	pmp->pm_fatsize = pmp->pm_FATsecs * DEV_BSIZE;

	if (pmp->pm_fatmask == 0) {
		if (pmp->pm_maxcluster
		    <= ((CLUST_RSRVD - CLUST_FIRST) & FAT12_MASK)) {
			/*
			 * This will usually be a floppy disk. This size makes
			 * sure that one fat entry will not be split across
			 * multiple blocks.
			 */
			pmp->pm_fatmask = FAT12_MASK;
			pmp->pm_fatmult = 3;
			pmp->pm_fatdiv = 2;
		} else {
			pmp->pm_fatmask = FAT16_MASK;
			pmp->pm_fatmult = 2;
			pmp->pm_fatdiv = 1;
		}
	}
	if (FAT12(pmp))
		pmp->pm_fatblocksize = 3 * pmp->pm_BytesPerSec;
	else
		pmp->pm_fatblocksize = MAXBSIZE;

	/*
	 * We now have the number of sectors in each FAT, so can work
	 * out how many clusters can be represented in a FAT.  Let's
	 * make sure the file system doesn't claim to have more clusters
	 * than this.
	 *
	 * We perform the calculation like we do to avoid integer overflow.
	 *
	 * This will give us a count of clusters.  They are numbered
	 * from 0, so the max cluster value is one less than the value
	 * we end up with.
	 */
	fat_max_clusters = pmp->pm_fatsize / pmp->pm_fatmult;
	fat_max_clusters *= pmp->pm_fatdiv;
	if (pmp->pm_maxcluster >= fat_max_clusters) {
#ifndef SMALL_KERNEL
		printf("msdosfs: reducing max cluster to %d from %d "
		    "due to FAT size\n", fat_max_clusters - 1,
		    pmp->pm_maxcluster);
#endif
		pmp->pm_maxcluster = fat_max_clusters - 1;
	}

	pmp->pm_fatblocksec = pmp->pm_fatblocksize / DEV_BSIZE;
	pmp->pm_bnshift = ffs(DEV_BSIZE) - 1;

	/*
	 * Compute mask and shift value for isolating cluster relative byte
	 * offsets and cluster numbers from a file offset.
	 */
	pmp->pm_bpcluster = SecPerClust * DEV_BSIZE;
	pmp->pm_crbomask = pmp->pm_bpcluster - 1;
	pmp->pm_cnshift = ffs(pmp->pm_bpcluster) - 1;

	/*
	 * Check for valid cluster size
	 * must be a power of 2
	 */
	if (pmp->pm_bpcluster ^ (1 << pmp->pm_cnshift)) {
		error = EFTYPE;
		goto error_exit;
	}

	/*
	 * Release the bootsector buffer.
	 */
	brelse(bp);
	bp = NULL;

	/*
	 * Check FSInfo
	 */
	if (pmp->pm_fsinfo) {
	        struct fsinfo *fp;

		if ((error = bread(devvp, pmp->pm_fsinfo, fsi_size(pmp),
		    &bp)) != 0)
		        goto error_exit;
		fp = (struct fsinfo *)bp->b_data;
		if (!bcmp(fp->fsisig1, "RRaA", 4)
		    && !bcmp(fp->fsisig2, "rrAa", 4)
		    && !bcmp(fp->fsisig3, "\0\0\125\252", 4)
		    && !bcmp(fp->fsisig4, "\0\0\125\252", 4))
		        /* Valid FSInfo. */
			;
		else
		        pmp->pm_fsinfo = 0;
		/* XXX make sure this tiny buf doesn't come back in fillinusemap! */
		SET(bp->b_flags, B_INVAL);
		brelse(bp);
		bp = NULL;
	}

	/*
	 * Check and validate (or perhaps invalidate?) the fsinfo structure? XXX
	 */

	/*
	 * Allocate memory for the bitmap of allocated clusters, and then
	 * fill it in.
	 */
	bmapsiz = howmany(pmp->pm_maxcluster + 1, N_INUSEBITS);
	if (bmapsiz == 0 || SIZE_MAX / bmapsiz < sizeof(*pmp->pm_inusemap)) {
		/* detect multiplicative integer overflow */
		error = EINVAL;
		goto error_exit;
	}
	pmp->pm_inusemap = mallocarray(bmapsiz, sizeof(*pmp->pm_inusemap),
	    M_MSDOSFSFAT, M_WAITOK | M_CANFAIL);
	if (pmp->pm_inusemap == NULL) {
		error = EINVAL;
		goto error_exit;
	}

	/*
	 * fillinusemap() needs pm_devvp.
	 */
	pmp->pm_dev = dev;
	pmp->pm_devvp = devvp;

	/*
	 * Have the inuse map filled in.
	 */
	if ((error = fillinusemap(pmp)) != 0)
		goto error_exit;

	/*
	 * If they want fat updates to be synchronous then let them suffer
	 * the performance degradation in exchange for the on disk copy of
	 * the fat being correct just about all the time.  I suppose this
	 * would be a good thing to turn on if the kernel is still flakey.
	 */
	if (mp->mnt_flag & MNT_SYNCHRONOUS)
		pmp->pm_flags |= MSDOSFSMNT_WAITONFAT;

	/*
	 * Finish up.
	 */
	if (ronly)
		pmp->pm_flags |= MSDOSFSMNT_RONLY;
	else
		pmp->pm_fmod = 1;
	mp->mnt_data = pmp;
        mp->mnt_stat.f_fsid.val[0] = (long)dev;
        mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
#ifdef QUOTA
	/*
	 * If we ever do quotas for DOS filesystems this would be a place
	 * to fill in the info in the msdosfsmount structure. You dolt,
	 * quotas on dos filesystems make no sense because files have no
	 * owners on dos filesystems. of course there is some empty space
	 * in the directory entry where we could put uid's and gid's.
	 */
#endif
	devvp->v_specmountpoint = mp;

	return (0);

error_exit:
	if (devvp->v_specinfo)
		devvp->v_specmountpoint = NULL;
	if (bp)
		brelse(bp);

	vn_lock(devvp, LK_EXCLUSIVE|LK_RETRY, p);
	(void) VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED, p);
	VOP_UNLOCK(devvp, p);

	if (pmp) {
		if (pmp->pm_inusemap)
			free(pmp->pm_inusemap, M_MSDOSFSFAT, 0);
		free(pmp, M_MSDOSFSMNT, 0);
		mp->mnt_data = NULL;
	}
	return (error);
}

int
msdosfs_start(struct mount *mp, int flags, struct proc *p)
{

	return (0);
}

/*
 * Unmount the filesystem described by mp.
 */
int
msdosfs_unmount(struct mount *mp, int mntflags,struct proc *p)
{
	struct msdosfsmount *pmp;
	int error, flags;
	struct vnode *vp;

	flags = 0;
	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;
	if ((error = vflush(mp, NULLVP, flags)) != 0)
		return (error);
	pmp = VFSTOMSDOSFS(mp);
	pmp->pm_devvp->v_specmountpoint = NULL;
	vp = pmp->pm_devvp;
#ifdef MSDOSFS_DEBUG
	vprint("msdosfs_umount(): just before calling VOP_CLOSE()\n", vp);
#endif
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	(void)VOP_CLOSE(vp,
	    pmp->pm_flags & MSDOSFSMNT_RONLY ? FREAD : FREAD|FWRITE, NOCRED, p);
	vput(vp);
	free(pmp->pm_inusemap, M_MSDOSFSFAT, 0);
	free(pmp, M_MSDOSFSMNT, 0);
	mp->mnt_data = NULL;
	mp->mnt_flag &= ~MNT_LOCAL;
	return (0);
}

int
msdosfs_root(struct mount *mp, struct vnode **vpp)
{
	struct msdosfsmount *pmp = VFSTOMSDOSFS(mp);
	struct denode *ndep;
	int error;

	if ((error = deget(pmp, MSDOSFSROOT, MSDOSFSROOT_OFS, &ndep)) != 0)
		return (error);

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_root(); mp %p, pmp %p, ndep %p, vp %p\n",
	    mp, pmp, ndep, DETOV(ndep));
#endif

	*vpp = DETOV(ndep);
	return (0);
}

int
msdosfs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	struct msdosfsmount *pmp;

	pmp = VFSTOMSDOSFS(mp);
	sbp->f_bsize = pmp->pm_bpcluster;
	sbp->f_iosize = pmp->pm_bpcluster;
	sbp->f_blocks = pmp->pm_nmbrofclusters;
	sbp->f_bfree = pmp->pm_freeclustercount;
	sbp->f_bavail = pmp->pm_freeclustercount;
	sbp->f_files = pmp->pm_RootDirEnts;			/* XXX */
	sbp->f_ffree = sbp->f_favail = 0;	/* what to put in here? */
	copy_statfs_info(sbp, mp);

	return (0);
}


struct msdosfs_sync_arg {
	struct proc *p;
	struct ucred *cred;
	int allerror;
	int waitfor;
};

int
msdosfs_sync_vnode(struct vnode *vp, void *arg)
{
	struct msdosfs_sync_arg *msa = arg;
	int error;
	struct denode *dep;

	dep = VTODE(vp);
	if (vp->v_type == VNON ||
	    ((dep->de_flag & (DE_ACCESS | DE_CREATE | DE_UPDATE | DE_MODIFIED)) == 0
	      && LIST_EMPTY(&vp->v_dirtyblkhd)) ||
	    msa->waitfor == MNT_LAZY) {
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT, msa->p))
		return (0);

	if ((error = VOP_FSYNC(vp, msa->cred, msa->waitfor, msa->p)) != 0)
		msa->allerror = error;
	VOP_UNLOCK(vp, msa->p);
	vrele(vp);

	return (0);
}


int
msdosfs_sync(struct mount *mp, int waitfor, struct ucred *cred, struct proc *p)
{
	struct msdosfsmount *pmp = VFSTOMSDOSFS(mp);
	struct msdosfs_sync_arg msa;
	int error;

	msa.allerror = 0;
	msa.p = p;
	msa.cred = cred;
	msa.waitfor = waitfor;

	/*
	 * If we ever switch to not updating all of the fats all the time,
	 * this would be the place to update them from the first one.
	 */
	if (pmp->pm_fmod != 0) {
		if (pmp->pm_flags & MSDOSFSMNT_RONLY)
			panic("msdosfs_sync: rofs mod");
		else {
			/* update fats here */
		}
	}
	/*
	 * Write back each (modified) denode.
	 */
	vfs_mount_foreach_vnode(mp, msdosfs_sync_vnode, &msa);

	/*
	 * Force stale file system control information to be flushed.
	 */
	if (waitfor != MNT_LAZY) {
		vn_lock(pmp->pm_devvp, LK_EXCLUSIVE | LK_RETRY, p);
		if ((error = VOP_FSYNC(pmp->pm_devvp, cred, waitfor, p)) != 0)
			msa.allerror = error;
		VOP_UNLOCK(pmp->pm_devvp, p);
	}

	return (msa.allerror);
}

int
msdosfs_fhtovp(struct mount *mp, struct fid *fhp, struct vnode **vpp)
{
	struct msdosfsmount *pmp = VFSTOMSDOSFS(mp);
	struct defid *defhp = (struct defid *) fhp;
	struct denode *dep;
	int error;

	error = deget(pmp, defhp->defid_dirclust, defhp->defid_dirofs, &dep);
	if (error) {
		*vpp = NULLVP;
		return (error);
	}
	*vpp = DETOV(dep);
	return (0);
}

int
msdosfs_vptofh(struct vnode *vp, struct fid *fhp)
{
	struct denode *dep;
	struct defid *defhp;

	dep = VTODE(vp);
	defhp = (struct defid *)fhp;
	defhp->defid_len = sizeof(struct defid);
	defhp->defid_dirclust = dep->de_dirclust;
	defhp->defid_dirofs = dep->de_diroffset;
	/* defhp->defid_gen = dep->de_gen; */
	return (0);
}

int
msdosfs_check_export(struct mount *mp, struct mbuf *nam, int *exflagsp,
    struct ucred **credanonp)
{
	struct netcred *np;
	struct msdosfsmount *pmp = VFSTOMSDOSFS(mp);

	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &pmp->pm_export, nam);
	if (np == NULL)
		return (EACCES);

	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
	return (0);
}

#define msdosfs_vget ((int (*)(struct mount *, ino_t, struct vnode **)) \
		      eopnotsupp)

#define msdosfs_quotactl ((int (*)(struct mount *, int, uid_t, caddr_t, \
					struct proc *))eopnotsupp)

#define msdosfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
                                    size_t, struct proc *))eopnotsupp)

const struct vfsops msdosfs_vfsops = {
	msdosfs_mount,
	msdosfs_start,
	msdosfs_unmount,
	msdosfs_root,
	msdosfs_quotactl,
	msdosfs_statfs,
	msdosfs_sync,
	msdosfs_vget,
	msdosfs_fhtovp,
	msdosfs_vptofh,
	msdosfs_init,
	msdosfs_sysctl,
	msdosfs_check_export
};
@


1.83
log
@Rename BIOS parameter block field from bsPBP to bsBPB.  This typo
has been fixed in FreeBSD in 2002.  No binary change.
From Alexander von Gernler; OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.82 2016/10/09 23:49:54 bluhm Exp $	*/
d67 1
d132 3
a134 1
			if (!error)
d136 4
@


1.82
log
@Do not check the SecPerTrack field of the BPB when mounting a MSDOS
file system.  In modern images the field is not set properly and
the value is not used anyway.  FreeBSD has removed the check already
in 2008.
From Alexander von Gernler; OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.81 2016/09/28 18:49:11 jca Exp $	*/
d302 1
a302 1
	b710 = (struct byte_bpb710 *)bsp->bs710.bsPBP;
@


1.81
log
@Kill empty ifdef; ok fcambus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.80 2016/09/07 17:30:12 natano Exp $	*/
d326 1
a326 1
	if (!pmp->pm_BytesPerSec || !SecPerClust || pmp->pm_SecPerTrack > 64) {
@


1.80
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.79 2016/08/13 20:53:17 guenther Exp $	*/
a594 2
#ifdef QUOTA
#endif
@


1.79
log
@Eliminate pointless casts to qaddr_t of a value being assigned to a void*

ok kettenis@@ krw@@ natano@@ dlg@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.78 2016/05/22 20:27:04 bluhm Exp $	*/
a108 1
	mode_t accessmode;
d140 1
a140 14
		    (mp->mnt_flag & MNT_WANTRDWR)) {
			/*
			 * If upgrade to read-write by non-root, then verify
			 * that user has necessary permissions on the device.
			 */
			if (suser(p, 0) != 0) {
				devvp = pmp->pm_devvp;
				vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
				error = VOP_ACCESS(devvp, VREAD | VWRITE,
						   p->p_ucred, p);
				VOP_UNLOCK(devvp, p);
				if (error)
					return (error);
			}
d142 1
a142 1
		}
a183 15
	}

	/*
	 * If mount by non-root, then verify that user has necessary
	 * permissions on the device.
	 */
	if (suser(p, 0) != 0) {
		accessmode = VREAD;
		if ((mp->mnt_flag & MNT_RDONLY) == 0)
			accessmode |= VWRITE;
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
		error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p);
		VOP_UNLOCK(devvp, p);
		if (error)
			goto error_devvp;
@


1.78
log
@When pulling an msdos formated umass stick during mount while the
usb stack was busy, the kernel could trigger an uvm fault.  There
is a race between vop_generic_revoke() and sys_mount() where vgonel()
could reset v_specinfo.  Then v_specmountpoint is no longer valid.
So after sleeping, msdosfs_mountfs() could crash in the error path.
The code in the different *_mountfs() functions was inconsistent,
implement the same check everywhere.
OK krw@@ natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.77 2016/04/26 18:37:03 natano Exp $	*/
d569 1
a569 1
	mp->mnt_data = (qaddr_t)pmp;
@


1.77
log
@Populate all necessary statfs members in .vfs_statfs. cd9660, udf,
msdosfs and nfsv2 don't set f_namemax. ntfs and ext2fs don't set
f_namemeax and f_favail. fusefs doesn't set f_mntfromspec, f_favail and
f_iosize. Also, make all filesystems use copy_statfs_info(), so that all
statfs information is filled in correctly for the (sb != &mp->mnt-stat)
case.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.76 2016/03/27 11:39:37 bluhm Exp $	*/
d586 2
a587 1
	devvp->v_specmountpoint = NULL;
@


1.76
log
@When pulling and unmounting an umass USB stick, the file system
could end up in an inconsistent state.  The fstype dependent
mp->mnt_data was NULL, but the general mp was still listed as a
valid mount point.  Next access to the file system would crash with
a NULL pointer dereference.
If closing the device fails, the mount point must go away anyway.
There is nothing we can do about it.  Remove the workaround for the
EIO error in the general unmount code, but do not generate any error
in the file system specific unmount functions.
OK natano@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.75 2016/03/19 12:04:16 natano Exp $	*/
d255 5
d675 3
a677 8
	sbp->f_ffree = 0;	/* what to put in here? */
	if (sbp != &mp->mnt_stat) {
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
		bcopy(&mp->mnt_stat.mount_info.msdosfs_args,
		    &sbp->mount_info.msdosfs_args, sizeof(struct msdosfs_args));
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
@


1.75
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.74 2016/03/17 18:52:31 bluhm Exp $	*/
d629 2
a630 2
	error = VOP_CLOSE(vp,
	   pmp->pm_flags & MSDOSFSMNT_RONLY ? FREAD : FREAD|FWRITE, NOCRED, p);
d636 1
a636 1
	return (error);
@


1.74
log
@Set mnt_data to NULL after freeing the file system specific mount point.
OK krw@@ natano@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.73 2015/10/23 17:21:34 krw Exp $	*/
d151 1
a151 1
				VOP_UNLOCK(devvp, 0, p);
d210 1
a210 1
		VOP_UNLOCK(devvp, 0, p);
d305 1
a305 1
	VOP_UNLOCK(devvp, 0, p);
d587 1
a587 1
	VOP_UNLOCK(devvp, 0, p);
d709 1
a709 1
	VOP_UNLOCK(vp, 0, msa->p);
d751 1
a751 1
		VOP_UNLOCK(pmp->pm_devvp, 0, p);
@


1.73
log
@Fix printf() types so kernel compiles with or w/o MSDOSFS_DEBUG.
e.g. print pointers with %p instead of %08x. No changes outside of
MSDOSFS_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.72 2015/10/23 10:45:31 krw Exp $	*/
d593 1
a593 1
		mp->mnt_data = (qaddr_t)0;
d634 1
a634 1
	mp->mnt_data = (qaddr_t)0;
@


1.72
log
@Nuke a bunch of leading/embedded/trailing whitespace so the code can be
read without generating spurious headaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.71 2015/02/13 13:35:03 millert Exp $	*/
d264 1
a264 1
	printf("msdosfs_mount(): mp %x, pmp %x, inusemap %x\n", mp,
d650 1
a650 1
	printf("msdosfs_root(); mp %08x, pmp %08x, ndep %08x, vp %08x\n",
@


1.71
log
@Include sys/stdint.h for SIZE_MAX instead of relying on the misplaced
define in sys/limits.h.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.70 2014/12/16 18:30:04 tedu Exp $	*/
d37 1
a37 1
 * 
d40 1
a40 1
 * 
d42 1
a42 1
 * 
d47 1
a47 1
 * 
d94 1
a94 1
 * mp - path - addr in user space of mount point (ie /usr or whatever) 
d96 1
a96 1
 * special file to treat as a filesystem. 
d169 1
a169 1
			return (vfs_export(mp, &pmp->pm_export, 
d237 1
a237 1
		
d350 1
a350 1
    	if (!pmp->pm_BytesPerSec || !SecPerClust || pmp->pm_SecPerTrack > 64) {
d385 1
a385 1
	 * 	FAT sectors: >0
d394 2
a395 2
	}		
	
d697 1
a697 1
	if (vp->v_type == VNON || 
@


1.70
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.69 2014/12/09 07:05:06 doug Exp $	*/
d67 1
@


1.69
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.68 2014/07/12 18:50:41 tedu Exp $	*/
d57 1
@


1.68
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.67 2014/06/23 18:54:33 tobias Exp $	*/
d527 1
a527 1
	pmp->pm_inusemap = malloc(bmapsiz * sizeof(*pmp->pm_inusemap),
@


1.67
log
@Fix possible crash on invalid filesystems.
Merged from FreeBSD's revision 206098.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.66 2014/06/18 17:24:46 tobias Exp $	*/
d589 2
a590 2
			free(pmp->pm_inusemap, M_MSDOSFSFAT);
		free(pmp, M_MSDOSFSMNT);
d630 2
a631 2
	free(pmp->pm_inusemap, M_MSDOSFSFAT);
	free(pmp, M_MSDOSFSMNT);
@


1.66
log
@Fix off by one in pm_inusemap.

FreeBSD did this years ago in revision 126086 as pointed out by
John-Mark Gurney on tech.  Merge it and sync two occurrences.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.65 2014/05/27 21:52:19 sf Exp $	*/
d388 2
a389 1
	    (pmp->pm_HugeSectors == 0) || (pmp->pm_FATsecs == 0)) {
@


1.65
log
@Fix 'mount -ur' for msdosfs

* fix bug preventing sync after more than one rw -> ro cycle.
* sync data and not only metadata

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.64 2014/05/09 03:54:28 tedu Exp $	*/
d520 1
a520 1
	bmapsiz = (pmp->pm_maxcluster + N_INUSEBITS - 1) / N_INUSEBITS;
@


1.64
log
@stop using B_AGE, it was effectively retired some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.63 2013/04/15 15:32:19 jsing Exp $	*/
d122 4
d130 2
@


1.63
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.62 2012/09/10 11:10:59 jsing Exp $	*/
a314 1
	bp->b_flags |= B_AGE;
@


1.62
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.60 2011/07/04 04:30:41 tedu Exp $	*/
d104 1
a172 1
	disk_map(fspec, fspec, MNAMELEN, DM_OPENBLCK);
d174 4
a177 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fspec, p);
d250 3
a252 1
	strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN);
@


1.61
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d104 1
a104 1
	size_t size;
a106 1
	char *fspec = NULL;
d148 1
a148 1
		if (args.fspec == 0) {
d169 1
a169 2
	fspec = malloc(MNAMELEN, M_MOUNT, M_WAITOK);
	error = copyinstr(args.fspec, fspec, MNAMELEN - 1, &size);
a242 2
	(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
	bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);
d244 4
a247 2
	size = strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN - 1);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d249 1
d254 1
a260 3
	if (fspec)
		free(fspec, M_MOUNT);

@


1.60
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.59 2010/11/17 12:27:03 jsing Exp $	*/
d57 1
a57 1
#include <miscfs/specfs/specdev.h> /* XXX */	/* defines v_rdev */
@


1.59
log
@Teach msdosfs_mount() how to handle disklabel UIDs.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.57 2010/01/24 18:12:46 krw Exp $	*/
d311 1
a311 1
	if ((error = bread(devvp, 0, 4096, NOCRED, &bp)) != 0)
d488 1
a488 1
		    NOCRED, &bp)) != 0)
@


1.58
log
@Change:

	/* something */
	if (error) {
		VOP_UNLOCK();
		return;
	}
	VOP_UNLOCK();

to the clearer and shorter:

	VOP_UNLOCK();
	if (error)
		return;

ok thib@@, jsing@@ as part of a larger diff.
@
text
@d65 1
d107 1
d112 1
d120 2
a121 1
		if (!(pmp->pm_flags & MSDOSFSMNT_RONLY) && (mp->mnt_flag & MNT_RDONLY)) {
d132 2
a133 1
		if ((pmp->pm_flags & MSDOSFSMNT_RONLY) && (mp->mnt_flag & MNT_WANTRDWR)) {
d165 1
d170 7
a176 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_USERSPACE, args.fspec, p);
d178 2
a179 1
		return (error);
d183 2
a184 2
		vrele(devvp);
		return (ENOTBLK);
d187 2
a188 2
		vrele(devvp);
		return (ENXIO);
d190 1
a200 4
		if (error) {
			vput(devvp);
			return (error);
		}
d202 2
d205 1
d214 3
a216 4
	if (error) {
		vrele(devvp);
		return (error);
	}
d225 2
a226 1
	else if (!(pmp->pm_flags & (MSDOSFSMNT_SHORTNAME | MSDOSFSMNT_LONGNAME))) {
d237 1
a237 1
			        return (error);
d247 2
a248 2
	(void) copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
d252 2
a253 1
	printf("msdosfs_mount(): mp %x, pmp %x, inusemap %x\n", mp, pmp, pmp->pm_inusemap);
d256 9
@


1.57
log
@"Fix" crash caused by FAT32 re-use of small buf from buffer cache,
at least until problem (starting somewhere between 4.1 and 4.2)
in buffer cache is found and a general fix is in place. Simply
B_INVAL small buf so it doesn't come back.

Addresses PR#6290, confirmed by submitter RD Thrush.

ok tedu@@ "should be marked XXX" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.56 2009/12/19 00:27:17 krw Exp $	*/
d138 2
a139 2
				if (error) {
					VOP_UNLOCK(devvp, 0, p);
a140 2
				}
				VOP_UNLOCK(devvp, 0, p);
@


1.56
log
@Re-introduce the remaining bits of thib@@'s Aug 2006 VOP_CLOSE()
locking fixes. Tweak cd9660 code to be the same as everywhere else,
no functional change.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.55 2009/10/31 12:00:08 fgsch Exp $	*/
d478 2
@


1.55
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.54 2009/08/30 15:31:24 thib Exp $	*/
d551 2
d554 2
@


1.54
log
@lock the vnode before calling VOP_CLOSE() in msdofs_unmount().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.52 2009/08/13 22:34:29 jasper Exp $	*/
d133 1
a133 1
			if (p->p_ucred->cr_uid != 0) {
d183 1
a183 1
	if (p->p_ucred->cr_uid != 0) {
@


1.53
log
@- deregister; no binary change

ok thibski@@
@
text
@d591 1
d594 1
a594 1
	vrele(vp);
@


1.52
log
@- ansify function declarations, no binary change

"fine" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.51 2009/01/05 01:14:40 krw Exp $	*/
d755 2
a756 2
	register struct netcred *np;
	register struct msdosfsmount *pmp = VFSTOMSDOSFS(mp);
@


1.51
log
@The FAT32 fsinxtfree field is advisory in nature and we don't use
it. So leave it untouched. Similiar to but more ruthless than the
fixes FreeBSD did, since they do use the value.  Basically avoid
various off-by-one and off-by-many errors.

Fixes problems encountered by jsg@@ and deraadt@@ where filesystems
found on SDHC cards caused UVM faults.

Original fixes found by jsg@@. ok jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.50 2007/11/26 00:30:44 krw Exp $	*/
d96 2
a97 6
msdosfs_mount(mp, path, data, ndp, p)
	struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
d247 2
a248 5
msdosfs_mountfs(devvp, mp, p, argp)
	struct vnode *devvp;
	struct mount *mp;
	struct proc *p;
	struct msdosfs_args *argp;
d562 1
a562 4
msdosfs_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
d572 1
a572 4
msdosfs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
d602 1
a602 3
msdosfs_root(mp, vpp)
	struct mount *mp;
	struct vnode **vpp;
d621 1
a621 4
msdosfs_statfs(mp, sbp, p)
	struct mount *mp;
	struct statfs *sbp;
	struct proc *p;
d679 1
a679 5
msdosfs_sync(mp, waitfor, cred, p)
	struct mount *mp;
	int waitfor;
	struct ucred *cred;
	struct proc *p;
d720 1
a720 4
msdosfs_fhtovp(mp, fhp, vpp)
	struct mount *mp;
	struct fid *fhp;
	struct vnode **vpp;
d737 1
a737 3
msdosfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
d752 2
a753 5
msdosfs_check_export(mp, nam, exflagsp, credanonp)
	register struct mount *mp;
	struct mbuf *nam;
	int *exflagsp;
	struct ucred **credanonp;
@


1.50
log
@Fix jsg@@'s iRiver Clix by relaxing the test for SecPerTrack to allow
64 instead of 63. deraadt@@, weingart@@, millert@@, thib@@, miod@@ ok with
eliminating test entirely but tom@@'s voice of caution wins out for the
quick commit. Tested by jsg@@ to confirm it fixes his device.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.49 2007/11/15 19:11:52 deraadt Exp $	*/
d481 2
a482 1
		        pmp->pm_nxtfree = getulong(fp->fsinxtfree);
@


1.49
log
@read boot sector as 4K block, because of new ipod nano
from Alexey Vatchenko; ok tom
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.48 2007/09/17 01:33:33 krw Exp $	*/
d327 1
a327 1
    	if (!pmp->pm_BytesPerSec || !SecPerClust || pmp->pm_SecPerTrack > 63) {
@


1.48
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.47 2007/03/21 17:29:32 thib Exp $	*/
d297 1
a297 1
	if ((error = bread(devvp, 0, 2048, NOCRED, &bp)) != 0)
@


1.47
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.46 2006/12/16 12:44:05 krw Exp $	*/
d305 1
a305 2
	pmp = malloc(sizeof *pmp, M_MSDOSFSMNT, M_WAITOK);
	bzero((caddr_t)pmp, sizeof *pmp);
@


1.46
log
@Adopt FreeBSD's code for non-DEV_BSIZE formatted MSDOSFS filesystems.

Enables devices (e.g. newer iPods, various other mp3 players) that use
2048 byte sectors.

Inspired by original diffs from weingart@@ and Alexey Vatchenk.

ok tom@@ pedro@@ deraadt@@ weingart@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.45 2006/12/15 03:04:24 krw Exp $	*/
a680 1
		simple_unlock(&vp->v_interlock);
d684 1
a684 1
	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, msa->p))
@


1.45
log
@Nuke GEMDOSFS. Unused part of unused atari port. Simplifies
MSDOSFS code. Eliminates -G option to mount_msdos.

Nit detection by gwk@@, tom@@, jmc@@.

ok weingart@@ tom@@ thib@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.44 2006/12/14 10:55:03 tom Exp $	*/
d297 1
a297 1
	if ((error = bread(devvp, 0, 512, NOCRED, &bp)) != 0)
d325 3
d358 21
a378 1
	pmp->pm_fatblk = pmp->pm_ResSectors;
d383 1
a383 1
		pmp->pm_fsinfo = getushort(b710->bpbFSInfo);
d388 1
a388 2
				       + pmp->pm_BytesPerSec - 1)
		        / pmp->pm_BytesPerSec;/* in sectors */
d395 1
a395 1
	pmp->pm_fatsize = pmp->pm_FATsecs * pmp->pm_BytesPerSec;
d442 2
a443 2
	pmp->pm_fatblocksec = pmp->pm_fatblocksize / pmp->pm_BytesPerSec;
	pmp->pm_bnshift = ffs(pmp->pm_BytesPerSec) - 1;
d449 1
a449 1
	pmp->pm_bpcluster = SecPerClust * pmp->pm_BytesPerSec;
d474 2
a475 1
		if ((error = bread(devvp, pmp->pm_fsinfo, 1024, NOCRED, &bp)) != 0)
@


1.44
log
@Remove dirsperblk, which is not used after it is calculated.

ok weingart@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.43 2006/12/14 07:37:24 tom Exp $	*/
a216 6
	/*
	 * GEMDOS knows nothing (yet) about win95
	 */
	if (pmp->pm_flags & MSDOSFSMNT_GEMDOSFS)
		pmp->pm_flags |= MSDOSFSMNT_NOWIN95;
	
a259 1
	struct partinfo dpart;
a266 1
	int	bsize = 0, dtype = 0, tmp;
a292 24
	if (argp->flags & MSDOSFSMNT_GEMDOSFS) {
		/*
	 	 * We need the disklabel to calculate the size of a FAT entry
		 * later on. Also make sure the partition contains a filesystem
		 * of type FS_MSDOS. This doesn't work for floppies, so we have
		 * to check for them too.
	 	 *
	 	 * At least some parts of the msdos fs driver seem to assume
		 * that the size of a disk block will always be 512 bytes.
		 * Let's check it...
		 */
		error = VOP_IOCTL(devvp, DIOCGPART, (caddr_t)&dpart,
				  FREAD, NOCRED, p);
		if (error)
			goto error_exit;
		tmp   = dpart.part->p_fstype;
		dtype = dpart.disklab->d_type;
		bsize = dpart.disklab->d_secsize;
		if (bsize != 512 || (dtype!=DTYPE_FLOPPY && tmp!=FS_MSDOS)) {
			error = EFTYPE;
			goto error_exit;
		}
	}

d325 3
a327 6
	if (!(argp->flags & MSDOSFSMNT_GEMDOSFS)) {
    		if (!pmp->pm_BytesPerSec || !SecPerClust
	    	    || pmp->pm_SecPerTrack > 63) {
			error = EFTYPE;
			goto error_exit;
		}
a354 41
	if (argp->flags & MSDOSFSMNT_GEMDOSFS) {
	        if (FAT32(pmp)) {
		        /*
			 * GEMDOS doesn't know fat32.
			 */
		        error = EINVAL;
			goto error_exit;
		}

		/*
		 * Check a few values (could do some more):
		 * - logical sector size: power of 2, >= block size
		 * - sectors per cluster: power of 2, >= 1
		 * - number of sectors:   >= 1, <= size of partition
		 */
		if ( (SecPerClust == 0)
		  || (SecPerClust & (SecPerClust - 1))
		  || (pmp->pm_BytesPerSec < bsize)
		  || (pmp->pm_BytesPerSec & (pmp->pm_BytesPerSec - 1))
		  || (pmp->pm_HugeSectors == 0)
		  || (pmp->pm_HugeSectors * (pmp->pm_BytesPerSec / bsize)
							> dpart.part->p_size)
		   ) {
			error = EFTYPE;
			goto error_exit;
		}
		/*
		 * XXX - Many parts of the msdos fs driver seem to assume that
		 * the number of bytes per logical sector (BytesPerSec) will
		 * always be the same as the number of bytes per disk block
		 * Let's pretend it is.
		 */
		tmp = pmp->pm_BytesPerSec / bsize;
		pmp->pm_BytesPerSec  = bsize;
		pmp->pm_HugeSectors *= tmp;
		pmp->pm_HiddenSects *= tmp;
		pmp->pm_ResSectors  *= tmp;
		pmp->pm_Sectors     *= tmp;
		pmp->pm_FATsecs     *= tmp;
		SecPerClust         *= tmp;
	}
d375 1
a375 14
	if (argp->flags & MSDOSFSMNT_GEMDOSFS) {
		if ((pmp->pm_nmbrofclusters <= (0xff0 - 2))
		      && ((dtype == DTYPE_FLOPPY) || ((dtype == DTYPE_VNODE)
		      && ((pmp->pm_Heads == 1) || (pmp->pm_Heads == 2))))
		     ) {
		        pmp->pm_fatmask = FAT12_MASK;
			pmp->pm_fatmult = 3;
			pmp->pm_fatdiv = 2;
		} else {
		        pmp->pm_fatmask = FAT16_MASK;
			pmp->pm_fatmult = 2;
			pmp->pm_fatdiv = 1;
		}
	} else if (pmp->pm_fatmask == 0) {
@


1.43
log
@If an MS-DOS filesystem claims to have more clusters than can be
represented in the FAT, limit the number of clusters we work with
to the FAT value.  This stops corrupt filesystems causing us to run
off the end of the FAT and panic()ing in fillinusemap().

Found by Jason Crawford (jasonrcrawford at gmail.com) with the MOKB
fs fuzzer.  Initial debugging by thib@@.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.42 2006/11/29 13:35:07 deraadt Exp $	*/
a274 1
	uint32_t dirsperblk;
a371 2

	dirsperblk = pmp->pm_BytesPerSec / sizeof(struct direntry);
@


1.42
log
@detect potential multiplicative overflow before allocation, and return via
the error path; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.41 2006/11/26 00:59:32 pedro Exp $	*/
d276 1
d488 23
@


1.41
log
@Fix malloc() panic in msdosfs_mountfs(), okay thib@@ deraadt@@
Found using fuzz generator written by lmh@@info-pull.com
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.40 2006/08/22 19:30:48 sturm Exp $	*/
d273 1
a273 1
	int	ronly, error;
d542 8
a549 4
	pmp->pm_inusemap = malloc(((pmp->pm_maxcluster + N_INUSEBITS - 1)
				   / N_INUSEBITS)
				  * sizeof(*pmp->pm_inusemap),
				  M_MSDOSFSFAT, M_WAITOK | M_CANFAIL);
@


1.40
log
@remove the check for the number of heads reported by the BPB altogether,
there are devices reporting zero heads; we don't use this value anyways

ok pedro, reported by Igor Grabin <violent at death.kiev.ua>
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.39 2006/08/07 15:50:42 pedro Exp $	*/
d545 5
a549 1
				  M_MSDOSFSFAT, M_WAITOK);
@


1.39
log
@Revert last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.37 2006/07/19 15:48:06 sturm Exp $	*/
d358 1
a358 2
		/* XXX - We should probably check more values here */
    		if (!pmp->pm_BytesPerSec || !SecPerClust || !pmp->pm_Heads
@


1.38
log
@obey the locking disaplince wrt to VOP_CLOSE during umounts
and mount error paths.

ok sturm@@ pedro@@
@
text
@a595 1
	vn_lock(devvp, LK_EXCLUSIVE|LK_RETRY, p);
a596 1
	VOP_UNLOCK(devvp, 0, p);
a641 1
	vn_lock(vp, LK_EXCLUSIVE|LK_RETRY, p);
d644 1
a644 2
	vput(vp);

@


1.37
log
@from FreeBSD:
Don't reject FAT file systems with a number of "Heads" greater than
255; USB keychains exist that use 256 as the number of heads.  This
check has also been removed in Darwin (along with most of the other
head/sector sanity checks).

this fixes pr 4988, ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.36 2005/03/02 00:46:10 tom Exp $	*/
d596 1
d598 1
d644 1
d647 2
a648 1
	vrele(vp);
@


1.36
log
@(And remember to remove the block on filesystems > 128 GB)

Add support for MS-DOS filesystems > 128 GB, by changing the way we
calculate fileids (fake inode numbers).  This uses some hash code by
Thomas Wang, who has agreed to the existing licence on the file (i.e.
his name just needed to be added to the copyright list).  Thanks.

Also a tiny bit of KNF.

Closes PR 4119; works for the OP Pawel Rogocz.

Help with testing todd@@, thanks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.35 2004/12/26 21:22:13 miod Exp $	*/
d359 2
a360 2
    		if (!pmp->pm_BytesPerSec || !SecPerClust
	    		|| pmp->pm_Heads > 255 || pmp->pm_SecPerTrack > 63) {
@


1.35
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.34 2004/05/14 04:05:05 tedu Exp $	*/
a374 9
	if (pmp->pm_HugeSectors > 0xffffffff / dirsperblk + 1) {
	        /*
		 * We cannot deal currently with this size of disk
		 * due to fileid limitations (see msdosfs_getattr and
		 * msdosfs_readdir)
		 */
	        error = EINVAL;
		goto error_exit;
	}
@


1.34
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.32 2003/08/14 07:46:40 mickey Exp $	*/
d726 1
a726 1
		&& vp->v_dirtyblkhd.lh_first == NULL) ||
@


1.33
log
@32 bit ints are uint32_t, not u_long.  works on 64bit now.  ok deraadt@@
@
text
@@


1.32
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.31 2003/04/14 17:55:07 tedu Exp $	*/
d275 1
a275 1
	u_long dirsperblk;
@


1.31
log
@rename rootvp to rvp to avoid global.  ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.30 2002/04/23 18:54:12 espie Exp $	*/
d857 1
a857 1
struct vfsops msdosfs_vfsops = {
@


1.30
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.29 2002/03/14 01:27:09 millert Exp $	*/
d226 1
a226 1
		struct vnode *rootvp;
d234 1
a234 1
		        if ((error = msdosfs_root(mp, &rootvp)) != 0) {
d238 1
a238 1
			pmp->pm_flags |= findwin95(VTODE(rootvp))
d241 1
a241 1
			vput(rootvp);
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.28 2001/12/19 08:58:06 art Exp $	*/
d162 2
a163 1
			return (vfs_export(mp, &pmp->pm_export, &args.export));
@


1.28
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.25 2001/11/21 21:37:01 csapuntz Exp $	*/
d73 11
a83 11
int msdosfs_mount __P((struct mount *, const char *, void *, struct nameidata *,
		       struct proc *));
int msdosfs_start __P((struct mount *, int, struct proc *));
int msdosfs_unmount __P((struct mount *, int, struct proc *));
int msdosfs_root __P((struct mount *, struct vnode **));
int msdosfs_statfs __P((struct mount *, struct statfs *, struct proc *));
int msdosfs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int msdosfs_fhtovp __P((struct mount *, struct fid *, struct vnode **));
int msdosfs_vptofh __P((struct vnode *, struct fid *));
int msdosfs_check_export __P((struct mount *mp, struct mbuf *nam,
			      int *extflagsp, struct ucred **credanonp));
d85 2
a86 2
int msdosfs_mountfs __P((struct vnode *, struct mount *, struct proc *,
			 struct msdosfs_args *));
d847 1
a847 1
#define msdosfs_vget ((int (*) __P((struct mount *, ino_t, struct vnode **))) \
d850 2
a851 2
#define msdosfs_quotactl ((int (*) __P((struct mount *, int, uid_t, caddr_t, \
					struct proc *)))eopnotsupp)
d853 2
a854 2
#define msdosfs_sysctl ((int (*) __P((int *, u_int, void *, size_t *, void *, \
                                    size_t, struct proc *)))eopnotsupp)
@


1.27
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.26 2001/11/27 05:27:12 art Exp $	*/
d587 9
a595 3
	mp->mnt_dev_bshift = pmp->pm_bnshift;
	mp->mnt_fs_bshift = pmp->pm_cnshift;

d723 4
a726 5
	if (msa->waitfor == MNT_LAZY || vp->v_type == VNON ||
	    (((dep->de_flag &
	    (DE_ACCESS | DE_CREATE | DE_UPDATE | DE_MODIFIED)) == 0) &&
	    (LIST_EMPTY(&vp->v_dirtyblkhd) &&
	     vp->v_uobj.uo_npages == 0))) {
@


1.27.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.27 2001/12/10 02:19:34 art Exp $	*/
d73 11
a83 11
int msdosfs_mount(struct mount *, const char *, void *, struct nameidata *,
		       struct proc *);
int msdosfs_start(struct mount *, int, struct proc *);
int msdosfs_unmount(struct mount *, int, struct proc *);
int msdosfs_root(struct mount *, struct vnode **);
int msdosfs_statfs(struct mount *, struct statfs *, struct proc *);
int msdosfs_sync(struct mount *, int, struct ucred *, struct proc *);
int msdosfs_fhtovp(struct mount *, struct fid *, struct vnode **);
int msdosfs_vptofh(struct vnode *, struct fid *);
int msdosfs_check_export(struct mount *mp, struct mbuf *nam,
			      int *extflagsp, struct ucred **credanonp);
d85 2
a86 2
int msdosfs_mountfs(struct vnode *, struct mount *, struct proc *,
			 struct msdosfs_args *);
d162 1
a162 2
			return (vfs_export(mp, &pmp->pm_export, 
			    &args.export_info));
d842 1
a842 1
#define msdosfs_vget ((int (*)(struct mount *, ino_t, struct vnode **)) \
d845 2
a846 2
#define msdosfs_quotactl ((int (*)(struct mount *, int, uid_t, caddr_t, \
					struct proc *))eopnotsupp)
d848 2
a849 2
#define msdosfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
                                    size_t, struct proc *))eopnotsupp)
@


1.27.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d226 1
a226 1
		struct vnode *rvp;
d234 1
a234 1
		        if ((error = msdosfs_root(mp, &rvp)) != 0) {
d238 1
a238 1
			pmp->pm_flags |= findwin95(VTODE(rvp))
d241 1
a241 1
			vput(rvp);
@


1.26
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.25 2001/11/21 21:37:01 csapuntz Exp $	*/
d721 1
a721 1
	     vp->v_uvm.u_obj.uo_npages == 0))) {
@


1.25
log
@VOP_UNLOCK + vrele does not alway == vput
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.24 2001/11/21 21:16:18 csapuntz Exp $	*/
d587 3
a589 9
#ifdef QUOTA
	/*
	 * If we ever do quotas for DOS filesystems this would be a place
	 * to fill in the info in the msdosfsmount structure. You dolt,
	 * quotas on dos filesystems make no sense because files have no
	 * owners on dos filesystems. of course there is some empty space
	 * in the directory entry where we could put uid's and gid's.
	 */
#endif
d717 5
a721 4
	if (vp->v_type == VNON || 
	    ((dep->de_flag & (DE_ACCESS | DE_CREATE | DE_UPDATE | DE_MODIFIED)) == 0
		&& vp->v_dirtyblkhd.lh_first == NULL) ||
	    msa->waitfor == MNT_LAZY) {
@


1.24
log
@

Use vfs_mount_foreach_vnode
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.23 2001/03/04 06:32:40 csapuntz Exp $	*/
d736 2
a737 1
	vput(vp);
@


1.23
log
@These file systems don't do softudpates.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.22 2001/02/20 01:50:11 assar Exp $	*/
d88 2
d707 35
a748 2
	struct vnode *vp, *nvp;
	struct denode *dep;
d750 7
a756 1
	int error, allerror = 0;
d772 1
a772 11
	simple_lock(&mntvnode_slock);
loop:
	for (vp = mp->mnt_vnodelist.lh_first;
	     vp != NULL;
	     vp = nvp) {
		/*
		 * If the vnode that we are about to sync is no longer
		 * assoicated with this mount point, start over.
		 */
		if (vp->v_mount != mp)
			goto loop;
a773 25
		simple_lock(&vp->v_interlock);
		nvp = vp->v_mntvnodes.le_next;
		dep = VTODE(vp);
		if (vp->v_type == VNON || ((dep->de_flag &
		    (DE_ACCESS | DE_CREATE | DE_UPDATE | DE_MODIFIED)) == 0
		    && vp->v_dirtyblkhd.lh_first == NULL) ||
		    waitfor == MNT_LAZY) {
			simple_unlock(&vp->v_interlock);
			continue;
		}
		simple_unlock(&mntvnode_slock);
		error = vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p);
		if (error) {
			simple_lock(&mntvnode_slock);
			if (error == ENOENT)
				goto loop;
			continue;
		}
		if ((error = VOP_FSYNC(vp, cred, waitfor, p)) != 0)
			allerror = error;
		VOP_UNLOCK(vp, 0, p);
		vrele(vp);
		simple_lock(&mntvnode_slock);
	}
	simple_unlock(&mntvnode_slock);
d780 1
a780 1
			allerror = error;
d783 2
a784 3
#ifdef QUOTA
#endif
	return (allerror);
@


1.22
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.21 2001/02/07 17:51:48 mickey Exp $	*/
a771 2
		if (pmp->pm_mountp->mnt_flag & MNT_SOFTDEP)
			waitfor = MNT_NOWAIT;
@


1.21
log
@fix debug case; from Mike Pechkin <mpech@@prosoft.org.lv>
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.21 2001/02/07 17:48:30 mickey Exp $	*/
d73 1
a73 1
int msdosfs_mount __P((struct mount *, const char *, caddr_t, struct nameidata *,
d97 1
a97 1
	caddr_t data;
d109 1
a109 1
	error = copyin(data, (caddr_t)&args, sizeof(struct msdosfs_args));
@


1.20
log
@Support FAT32 partitions >4GB (up to 128GB, in fact); d@@ ok, from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.19 2000/02/07 04:57:17 assar Exp $	*/
d667 3
d674 1
a674 2
	if ((error = deget(pmp, MSDOSFSROOT, MSDOSFSROOT_OFS, &ndep)) != 0)
		return (error);
@


1.19
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.18 1999/05/31 17:34:51 millert Exp $	*/
d272 1
d370 3
a372 1
	if (pmp->pm_HugeSectors > 0xffffffff / pmp->pm_BytesPerSec + 1) {
@


1.19.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a271 1
	u_long dirsperblk;
d369 1
a369 3

	dirsperblk = pmp->pm_BytesPerSec / sizeof(struct direntry);
	if (pmp->pm_HugeSectors > 0xffffffff / dirsperblk + 1) {
@


1.19.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.23 2001/03/04 06:32:40 csapuntz Exp $	*/
d73 1
a73 1
int msdosfs_mount __P((struct mount *, const char *, void *, struct nameidata *,
d97 1
a97 1
	void *data;
d109 1
a109 1
	error = copyin(data, &args, sizeof(struct msdosfs_args));
a666 3
	if ((error = deget(pmp, MSDOSFSROOT, MSDOSFSROOT_OFS, &ndep)) != 0)
		return (error);

d671 2
a672 1

d770 2
@


1.19.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a87 2
int msdosfs_sync_vnode(struct vnode *, void *);

d585 9
a593 3
	mp->mnt_dev_bshift = pmp->pm_bnshift;
	mp->mnt_fs_bshift = pmp->pm_cnshift;

a704 37

struct msdosfs_sync_arg {
	struct proc *p;
	struct ucred *cred;
	int allerror;
	int waitfor;
};

int
msdosfs_sync_vnode(struct vnode *vp, void *arg)
{
	struct msdosfs_sync_arg *msa = arg;
	int error;
	struct denode *dep;

	dep = VTODE(vp);
	if (msa->waitfor == MNT_LAZY || vp->v_type == VNON ||
	    (((dep->de_flag &
	    (DE_ACCESS | DE_CREATE | DE_UPDATE | DE_MODIFIED)) == 0) &&
	    (LIST_EMPTY(&vp->v_dirtyblkhd) &&
	     vp->v_uvm.u_obj.uo_npages == 0))) {
		simple_unlock(&vp->v_interlock);
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, msa->p))
		return (0);

	if ((error = VOP_FSYNC(vp, msa->cred, msa->waitfor, msa->p)) != 0)
		msa->allerror = error;
	VOP_UNLOCK(vp, 0, msa->p);
	vrele(vp);

	return (0);
}


d712 2
d715 1
a715 7
	struct msdosfs_sync_arg msa;
	int error;

	msa.allerror = 0;
	msa.p = p;
	msa.cred = cred;
	msa.waitfor = waitfor;
d731 11
a741 1
	vfs_mount_foreach_vnode(mp, msdosfs_sync_vnode, &msa);
d743 25
d774 1
a774 1
			msa.allerror = error;
d777 3
a779 2

	return (msa.allerror);
@


1.19.2.4
log
@Merge in trunk
@
text
@d587 3
a589 9
#ifdef QUOTA
	/*
	 * If we ever do quotas for DOS filesystems this would be a place
	 * to fill in the info in the msdosfsmount structure. You dolt,
	 * quotas on dos filesystems make no sense because files have no
	 * owners on dos filesystems. of course there is some empty space
	 * in the directory entry where we could put uid's and gid's.
	 */
#endif
d717 5
a721 4
	if (vp->v_type == VNON || 
	    ((dep->de_flag & (DE_ACCESS | DE_CREATE | DE_UPDATE | DE_MODIFIED)) == 0
		&& vp->v_dirtyblkhd.lh_first == NULL) ||
	    msa->waitfor == MNT_LAZY) {
@


1.19.2.5
log
@Merge in -current from roughly a week ago
@
text
@d73 11
a83 11
int msdosfs_mount(struct mount *, const char *, void *, struct nameidata *,
		       struct proc *);
int msdosfs_start(struct mount *, int, struct proc *);
int msdosfs_unmount(struct mount *, int, struct proc *);
int msdosfs_root(struct mount *, struct vnode **);
int msdosfs_statfs(struct mount *, struct statfs *, struct proc *);
int msdosfs_sync(struct mount *, int, struct ucred *, struct proc *);
int msdosfs_fhtovp(struct mount *, struct fid *, struct vnode **);
int msdosfs_vptofh(struct vnode *, struct fid *);
int msdosfs_check_export(struct mount *mp, struct mbuf *nam,
			      int *extflagsp, struct ucred **credanonp);
d85 2
a86 2
int msdosfs_mountfs(struct vnode *, struct mount *, struct proc *,
			 struct msdosfs_args *);
d847 1
a847 1
#define msdosfs_vget ((int (*)(struct mount *, ino_t, struct vnode **)) \
d850 2
a851 2
#define msdosfs_quotactl ((int (*)(struct mount *, int, uid_t, caddr_t, \
					struct proc *))eopnotsupp)
d853 2
a854 2
#define msdosfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
                                    size_t, struct proc *))eopnotsupp)
@


1.19.2.6
log
@Sync the SMP branch with 3.3
@
text
@d162 1
a162 2
			return (vfs_export(mp, &pmp->pm_export, 
			    &args.export_info));
@


1.19.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.19.2.6 2003/03/28 00:00:21 niklas Exp $	*/
d226 1
a226 1
		struct vnode *rvp;
d234 1
a234 1
		        if ((error = msdosfs_root(mp, &rvp)) != 0) {
d238 1
a238 1
			pmp->pm_flags |= findwin95(VTODE(rvp))
d241 1
a241 1
			vput(rvp);
@


1.19.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d857 1
a857 1
const struct vfsops msdosfs_vfsops = {
@


1.19.2.9
log
@Merge with the trunk
@
text
@d275 1
a275 1
	uint32_t dirsperblk;
@


1.18
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.17 1999/05/01 23:47:21 deraadt Exp $	*/
d80 1
a80 2
int msdosfs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
		        struct vnode **, int *, struct ucred **));
d82 2
d780 1
a780 1
msdosfs_fhtovp(mp, fhp, nam, vpp, exflagsp, credanonp)
a782 1
	struct mbuf *nam;
a783 2
	int *exflagsp;
	struct ucred **credanonp;
a787 1
	struct netcred *np;
a789 3
	np = vfs_export_lookup(mp, &pmp->pm_export, nam);
	if (np == NULL)
		return (EACCES);
a795 2
	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
d816 22
d859 2
a860 1
	msdosfs_sysctl
@


1.17
log
@do not count on BOOTSIG0 and BOOTSIG1 being in a msdos filesystem.  Not
all filesystems need to contain those; mark@@nfr.net
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.16 1999/01/10 21:53:02 art Exp $	*/
d245 1
a681 5
#ifdef COMPAT_09
	sbp->f_type = 4;
#else
	sbp->f_type = 0;
#endif
d692 2
@


1.16
log
@make this compile with MSDOSFS_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.15 1998/02/23 20:10:38 niklas Exp $	*/
a329 7
	if (!(argp->flags & MSDOSFSMNT_GEMDOSFS)) {
	        if (bsp->bs50.bsBootSectSig0 != BOOTSIG0
		    || bsp->bs50.bsBootSectSig1 != BOOTSIG1) {
		        error = EINVAL;
			goto error_exit;
		}
	}
d378 2
a379 5
                if (bsp->bs710.bsBootSectSig2 != BOOTSIG2
		    || bsp->bs710.bsBootSectSig3 != BOOTSIG3
		    || pmp->pm_Sectors
		    || pmp->pm_FATsecs
		    || getushort(b710->bpbFSVers)) {
@


1.15
log
@GAS 2.8 + KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.14 1998/02/08 22:41:44 tholo Exp $	*/
d638 1
d649 1
d651 1
a651 11
	printf("msdosfs_umount(): just before calling VOP_CLOSE()\n");
	printf("flag %08x, usecount %d, writecount %d, holdcnt %d\n",
	    vp->v_flag, vp->v_usecount, vp->v_writecount, vp->v_holdcnt);
	printf("lastr %d, id %d, mount %08x, op %08x\n",
	    vp->v_lastr, vp->v_id, vp->v_mount, vp->v_op);
	printf("freef %08x, freeb %08x, mountf %08x, mountb %08x\n",
	    vp->v_freef, vp->v_freeb, vp->v_mountf, vp->v_mountb);
	printf("cleanblkhd %08x, dirtyblkhd %08x, numoutput %d, type %d\n",
	    vp->v_cleanblkhd, vp->v_dirtyblkhd, vp->v_numoutput, vp->v_type);
	printf("union %08x, tag %d, data[0] %08x, data[1] %08x\n",
	    vp->v_socket, vp->v_tag, vp->v_data[0], vp->v_data[1]);
d653 3
a655 3
	error = VOP_CLOSE(pmp->pm_devvp,
	    pmp->pm_flags & MSDOSFSMNT_RONLY ? FREAD : FREAD|FWRITE, NOCRED, p);
	vrele(pmp->pm_devvp);
@


1.14
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.13 1998/01/11 20:39:10 provos Exp $	*/
d735 1
a735 1
	if (pmp->pm_fmod != 0)
d741 1
@


1.13
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.12 1997/11/10 21:17:29 provos Exp $	*/
d73 1
a73 1
int msdosfs_mount __P((struct mount *, char *, caddr_t, struct nameidata *,
d95 1
a95 1
	char *path;
@


1.12
log
@dont crash on update mounting.
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_vfsops.c,v 1.11 1997/11/09 23:15:12 millert Exp $	*/
/*	$NetBSD: msdosfs_vfsops.c,v 1.44 1996/12/22 10:10:32 cgd Exp $	*/
d5 2
a6 2
 * Copyright (C) 1994, 1995 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995 TooLs GmbH.
d227 11
a237 3
		if ((error = msdosfs_root(mp, &rootvp)) != 0) {
			msdosfs_unmount(mp, MNT_FORCE, p);
			return (error);
a238 4
		pmp->pm_flags |= findwin95(VTODE(rootvp))
		    ? MSDOSFSMNT_LONGNAME
		    : MSDOSFSMNT_SHORTNAME;
		vput(rootvp);
d265 1
d329 7
a335 5
#ifdef MSDOSFS_CHECKSIG
	if (!(argp->flags & MSDOSFSMNT_GEMDOSFS)
		&& (bsp->bs50.bsBootSectSig != BOOTSIG)) {
		error = EFTYPE;
		goto error_exit;
a336 1
#endif
d374 29
d405 8
d446 14
a459 6
	pmp->pm_rootdirblk = pmp->pm_fatblk +
	    (pmp->pm_FATs * pmp->pm_FATsecs);
	pmp->pm_rootdirsize = (pmp->pm_RootDirEnts * sizeof(struct direntry)
	    + pmp->pm_BytesPerSec - 1)
	    / pmp->pm_BytesPerSec;/* in sectors */
	pmp->pm_firstcluster = pmp->pm_rootdirblk + pmp->pm_rootdirsize;
d469 10
a478 5
		   )
			pmp->pm_fatentrysize = 12;
		else
			pmp->pm_fatentrysize = 16;
	} else {
d480 1
a480 1
		    <= ((CLUST_RSRVS - CLUST_FIRST) & FAT12_MASK))
d486 8
a493 3
			pmp->pm_fatentrysize = 12;
		else
			pmp->pm_fatentrysize = 16;
d525 24
@


1.11
log
@Don't panic on sync, based on changes from ext2fs_vfsops.c and ffs_vfsops.c
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.10 1997/11/06 05:58:57 csapuntz Exp $	*/
a121 2
			if (vfs_busy(mp, 0, 0, p))
				return (EBUSY);
a122 1
			vfs_unbusy(mp, p);
d504 1
a504 2
        mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_MSDOS);
	mp->mnt_flag |= MNT_LOCAL;
d518 2
a519 1
error_exit:;
@


1.10
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.9 1997/10/06 20:20:59 deraadt Exp $	*/
d279 4
a282 1
	if ((error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0)) != 0)
d644 1
a644 1
	struct vnode *vp;
d662 1
d666 1
a666 1
	     vp = vp->v_mntvnodes.le_next) {
d673 9
a681 1
		if (VOP_ISLOCKED(vp))
d683 7
a689 4
		dep = VTODE(vp);
		if (((dep->de_flag
		    & (DE_ACCESS | DE_CREATE | DE_UPDATE | DE_MODIFIED)) == 0)
		    && (vp->v_dirtyblkhd.lh_first == NULL || waitfor == MNT_LAZY))
d691 1
a691 2
		if (vget(vp, LK_EXCLUSIVE, p))
			goto loop;
d694 3
a696 1
		vput(vp);
d698 1
d702 8
a709 2
	if ((error = VOP_FSYNC(pmp->pm_devvp, cred, waitfor, p)) != 0)
		allerror = error;
@


1.9
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.7 1997/06/20 14:04:30 kstailey Exp $	*/
a77 1
int msdosfs_quotactl __P((struct mount *, int, uid_t, caddr_t, struct proc *));
a79 1
int msdosfs_vget __P((struct mount *, ino_t, struct vnode **));
d122 1
a122 1
			if (vfs_busy(mp))
d125 1
a125 1
			vfs_unbusy(mp);
d139 1
a139 1
				VOP_LOCK(devvp);
d143 1
a143 1
					VOP_UNLOCK(devvp);
d146 1
a146 1
				VOP_UNLOCK(devvp);
d190 1
a190 1
		VOP_LOCK(devvp);
d196 1
a196 1
		VOP_UNLOCK(devvp);
d515 1
a515 1
	devvp->v_specflags |= SI_MOUNTEDON;
d562 1
a562 1
	pmp->pm_devvp->v_specflags &= ~SI_MOUNTEDON;
a605 16
msdosfs_quotactl(mp, cmds, uid, arg, p)
	struct mount *mp;
	int cmds;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

#ifdef QUOTA
	return (EOPNOTSUPP);
#else
	return (EOPNOTSUPP);
#endif
}

int
d630 1
a630 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d674 1
a674 1
		    && (vp->v_dirtyblkhd.lh_first == NULL))
d676 1
a676 1
		if (vget(vp, 1))
d738 5
a742 6
int
msdosfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{
d744 2
a745 2
	return (EOPNOTSUPP);
}
a747 1
	MOUNT_MSDOS,
d758 2
a759 1
	msdosfs_init
@


1.8
log
@VFS Lite2 Changes
@
text
@d78 1
d81 1
d124 1
a124 1
			if (vfs_busy(mp, 0, 0, p))
d127 1
a127 1
			vfs_unbusy(mp, p);
d141 1
a141 1
				vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
d145 1
a145 1
					VOP_UNLOCK(devvp, 0, p);
d148 1
a148 1
				VOP_UNLOCK(devvp, 0, p);
d192 1
a192 1
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
d198 1
a198 1
		VOP_UNLOCK(devvp, 0, p);
d517 1
a517 1
	devvp->v_specmountpoint = mp;
d564 1
a564 1
	pmp->pm_devvp->v_specmountpoint = NULL;
d608 16
d648 1
a648 1
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
d692 1
a692 1
		    && (vp->v_dirtyblkhd.lh_first == NULL || waitfor == MNT_LAZY))
d694 1
a694 1
		if (vget(vp, LK_EXCLUSIVE, p))
d756 6
a761 2
#define msdosfs_vget ((int (*) __P((struct mount *, ino_t, struct vnode **))) \
		      eopnotsupp)
d763 2
a764 5
#define msdosfs_quotactl ((int (*) __P((struct mount *, int, uid_t, caddr_t, \
					struct proc *)))eopnotsupp)

#define msdosfs_sysctl ((int (*) __P((int *, u_int, void *, size_t *, void *, \
                                    size_t, struct proc *)))eopnotsupp)
d767 1
d778 1
a778 2
	msdosfs_init,
	msdosfs_sysctl
@


1.7
log
@Change errno cause by mounting invalid filesystems from EINVAL to EFTYPE.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.6 1997/03/02 18:01:59 millert Exp $	*/
a77 1
int msdosfs_quotactl __P((struct mount *, int, uid_t, caddr_t, struct proc *));
a79 1
int msdosfs_vget __P((struct mount *, ino_t, struct vnode **));
d122 1
a122 1
			if (vfs_busy(mp))
d125 1
a125 1
			vfs_unbusy(mp);
d139 1
a139 1
				VOP_LOCK(devvp);
d143 1
a143 1
					VOP_UNLOCK(devvp);
d146 1
a146 1
				VOP_UNLOCK(devvp);
d190 1
a190 1
		VOP_LOCK(devvp);
d196 1
a196 1
		VOP_UNLOCK(devvp);
d515 1
a515 1
	devvp->v_specflags |= SI_MOUNTEDON;
d562 1
a562 1
	pmp->pm_devvp->v_specflags &= ~SI_MOUNTEDON;
a605 16
msdosfs_quotactl(mp, cmds, uid, arg, p)
	struct mount *mp;
	int cmds;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

#ifdef QUOTA
	return (EOPNOTSUPP);
#else
	return (EOPNOTSUPP);
#endif
}

int
d630 1
a630 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d674 1
a674 1
		    && (vp->v_dirtyblkhd.lh_first == NULL))
d676 1
a676 1
		if (vget(vp, 1))
d738 5
a742 6
int
msdosfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{
d744 2
a745 2
	return (EOPNOTSUPP);
}
a747 1
	MOUNT_MSDOS,
d758 2
a759 1
	msdosfs_init
@


1.6
log
@Sync msdosfs with NetBSD sans const-ness.  NetSBD log messages:
    Fix panic on mkdir.
    Thanks to Dave Huang for finding the bug.
    Fixes a bug with allowed/forbidden characters in non-W95 filenames.
    Don't extend directory when nothing is written to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vfsops.c,v 1.5 1996/04/21 22:28:22 deraadt Exp $	*/
d204 1
a204 1
			error = EINVAL;	/* needs translation */
d311 1
a311 1
			error = EINVAL;
d329 1
a329 1
		error = EINVAL;
d358 1
a358 1
			error = EINVAL;
d386 1
a386 1
			error = EINVAL;
d457 1
a457 1
		error = EINVAL;
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_vfsops.c,v 1.4 1996/02/29 10:46:57 niklas Exp $	*/
/*	$NetBSD: msdosfs_vfsops.c,v 1.41 1996/03/20 00:45:40 thorpej Exp $	*/
@


1.4
log
@From NetBSD: merge with 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: msdosfs_vfsops.c,v 1.40 1996/02/11 22:48:16 ws Exp $	*/
d690 3
a692 3
		if (dep->de_flag
		    & (DE_ACCESS | DE_CREATE | DE_UPDATE | DE_MODIFIED) == 0
		    && vp->v_dirtyblkhd.lh_first == NULL)
@


1.3
log
@from netbsd;
Instead of using '#ifdef atari' to handle the differences of Gemdosfs and
Msdosfs, use a flag that can be set by mount_msdos. This is definitely
more flexible.
Fix error in previous change: don't use the local FS mount data before
it's actually allocated. Pass mount arguments to msdosfs_mountfs instead,
and use them (as in iso_mountfs for example).
@
text
@d1 2
a2 1
/*	$NetBSD: msdosfs_vfsops.c,v 1.38 1996/01/21 16:35:29 fvdl Exp $	*/
d73 16
d104 2
a105 1
	struct msdosfsmount *pmp; /* msdosfs specific mount control block */
d110 2
a111 1
	if (error = copyin(data, (caddr_t)&args, sizeof(struct msdosfs_args)))
d142 3
a144 2
				if (error = VOP_ACCESS(devvp, VREAD | VWRITE,
				    p->p_ucred, p)) {
d172 1
a172 1
	if (error = namei(ndp))
d193 2
a194 1
		if (error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p)) {
d232 1
a232 1
		if (error = msdosfs_root(mp, &rootvp)) {
d269 1
a269 1
	int	bsize, dtype, tmp;
d277 1
a277 1
	if (error = vfs_mountedon(devvp))
d281 1
a281 1
	if (error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0))
d285 2
a286 1
	if (error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p))
d303 3
a305 2
		if (error = VOP_IOCTL(devvp, DIOCGPART, (caddr_t)&dpart,
							FREAD, NOCRED, p))
d320 1
a320 1
	if (error = bread(devvp, 0, 512, NOCRED, &bp))
d422 5
a426 4
		else pmp->pm_fatentrysize = 16;
	}
	else {
		if (pmp->pm_maxcluster <= 4086)
d433 2
a434 1
		else pmp->pm_fatentrysize = 16;
d436 1
a436 1
	if(FAT12(pmp))
d438 2
a439 1
	else pmp->pm_fatblocksize = MAXBSIZE;
d485 1
a485 1
	if (error = fillinusemap(pmp))
d561 1
a561 1
	if (error = vflush(mp, NULLVP, flags))
d601 1
a601 1
	if (error = deget(pmp, MSDOSFSROOT, MSDOSFSROOT_OFS, &ndep))
d696 1
a696 1
		if (error = VOP_FSYNC(vp, cred, waitfor, p))
d703 1
a703 1
	if (error = VOP_FSYNC(pmp->pm_devvp, cred, waitfor, p))
@


1.2
log
@from netbsd (mostly by ws):
Win95 ignores case on lookup
Really don't generate long names when mounted with -s
Fix cookie handling
Don't forward credentials to bread, it makes nfs panic
(Of course, nfs shouldn't rely on the credentials not being referenced)
Don't give directory entry to deget, it could result in a deadlock
Use device blocks, not clusters for logical block numbers
Add support for Win'95 separate creation/modification/access timestamps
Re-introduce lowercase filenames for non-Win'95-filesystems
Fix thinko with block boundaries in directories
Don't overwrite dirclust, it's needed later on
Enable flock(2).
@
text
@d1 1
a1 1
/*	$NetBSD: msdosfs_vfsops.c,v 1.36 1995/11/29 15:08:40 ws Exp $	*/
d180 1
a180 1
		error = msdosfs_mountfs(devvp, mp, p);
d196 7
d232 1
a232 1
msdosfs_mountfs(devvp, mp, p)
d236 1
a247 1
#ifdef	atari
a248 1
#endif	/* !atari */
d266 1
a266 1
#ifdef	atari
d269 22
a290 16
	/*
	 * We need the disklabel to calculate the size of a FAT entry later on.
	 * Also make sure the partition contains a filesystem of type FS_MSDOS.
	 * This doesn't work for floppies, so we have to check for them too.
	 *
	 * At least some parts of the msdos fs driver seem to assume that the
	 * size of a disk block will always be 512 bytes. Let's check it...
	 */
	if (error = VOP_IOCTL(devvp, DIOCGPART, (caddr_t)&dpart, FREAD, NOCRED, p))
		goto error_exit;
	tmp   = dpart.part->p_fstype;
	dtype = dpart.disklab->d_type;
	bsize = dpart.disklab->d_secsize;
	if (bsize != 512 || (dtype != DTYPE_FLOPPY && tmp != FS_MSDOS)) {
		error = EINVAL;
		goto error_exit;
a291 1
#else	/* !atari */
d294 2
a295 2
	 * Read the boot sector of the filesystem, and then check the boot
	 * signature.  If not a dos boot sector then error out.
a296 3
	bp = NULL;
	pmp = NULL;
#endif	/* !atari */
d304 2
a305 1
	if (bsp->bs50.bsBootSectSig != BOOTSIG) {
a326 9
#ifdef	atari
	/*
	 * Meaningless on  a gemdos fs. This kind of information
	 * should be extracted from the disklabel structure.
	 */
	pmp->pm_SecPerTrack = 1;	/* anything between 1 and  63 */
	pmp->pm_Heads = 1;		/* anything between 1 and 255 */
	pmp->pm_Media = 0;		/* unused, any value will do  */
#else	/* !atari */
d331 7
a337 5
	/* XXX - We should probably check more values here */
    	if (!pmp->pm_BytesPerSec || !SecPerClust ||
	    pmp->pm_Heads > 255 || pmp->pm_SecPerTrack > 63) {
		error = EINVAL;
		goto error_exit;
a338 1
#endif	/* !atari */
d347 33
a379 16
#ifdef	atari
	/*
	 * Check a few values (could do some more):
	 * - logical sector size: power of 2, >= block size
	 * - sectors per cluster: power of 2, >= 1
	 * - number of sectors:   >= 1, <= size of partition
	 */
	if ( pmp->pm_BytesPerSec < bsize
	  || pmp->pm_BytesPerSec & (pmp->pm_BytesPerSec - 1)
	  || !SecPerClust
	  || SecPerClust & (SecPerClust - 1)
	  || !pmp->pm_HugeSectors
	  || pmp->pm_HugeSectors * pmp->pm_BytesPerSec
				> dpart.part->p_size * bsize) {
		error = EINVAL;
		goto error_exit;
a380 14
	/*
	 * XXX - Many parts of the msdos fs driver seem to assume that
	 * the number of bytes per logical sector (BytesPerSec) will
	 * always be the same as the number of bytes per disk block
	 * Let's pretend it is.
	 */
	tmp = pmp->pm_BytesPerSec / bsize;
	pmp->pm_BytesPerSec = bsize;
	pmp->pm_HugeSectors *= tmp;
	pmp->pm_HiddenSects *= tmp;
	pmp->pm_ResSectors *= tmp;
	pmp->pm_Sectors *= tmp;
	pmp->pm_FATsecs *= tmp;
#endif	/* atari */
d392 18
a409 7
#ifdef	atari
	if (dtype == DTYPE_FLOPPY) {
		pmp->pm_fatentrysize = 12;
		pmp->pm_fatblocksize = 3 * pmp->pm_BytesPerSec;
	} else {
		pmp->pm_fatentrysize = 16;
		pmp->pm_fatblocksize = MAXBSIZE;
d411 1
a411 7
#else	/* !atari */
	if (FAT12(pmp))
		/*
		 * This will usually be a floppy disk. This size makes sure
		 * that one fat entry will not be split across multiple
		 * blocks.
		 */
d413 2
a414 7
	else
		/*
		 * This will usually be a hard disk. Reading or writing one
		 * block should be quite fast.
		 */
		pmp->pm_fatblocksize = MAXBSIZE;
#endif	/* !atari */
a425 6
#ifdef	atari
	/*
	 * We already know that the number of sectors per cluster is
	 * > 0 and a power of 2.
	 */
#else	/* !atari */
a433 1
#endif	/* !atari */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: msdosfs_vfsops.c,v 1.32 1995/09/09 19:38:08 ws Exp $	*/
d4 2
a5 2
 * Copyright (C) 1994 Wolfgang Solfrank.
 * Copyright (C) 1994 TooLs GmbH.
d63 1
d101 1
a101 1
		if (pmp->pm_ronly == 0 && (mp->mnt_flag & MNT_RDONLY)) {
d115 1
a115 1
		if (pmp->pm_ronly && (mp->mnt_flag & MNT_WANTRDWR)) {
d130 1
a130 1
			pmp->pm_ronly = 0;
d133 8
d195 18
d238 1
d311 1
a312 1
	pmp->pm_SectPerClust = b50->bpbSecPerClust;
d332 1
a332 1
    	if (!pmp->pm_BytesPerSec || !pmp->pm_SectPerClust ||
d355 2
a356 2
	  || !pmp->pm_SectPerClust
	  || pmp->pm_SectPerClust & (pmp->pm_SectPerClust - 1)
a370 1
	pmp->pm_SectPerClust *= tmp;
d380 3
a382 10
#ifdef	atari
	tmp = pmp->pm_RootDirEnts * sizeof(struct direntry);
	tmp += pmp->pm_BytesPerSec - 1;
	tmp /= pmp->pm_BytesPerSec;
	pmp->pm_rootdirsize = tmp;	/* in sectors */
#else	/* !atari */
	pmp->pm_rootdirsize = (pmp->pm_RootDirEnts * sizeof(struct direntry))
	    /
	    pmp->pm_BytesPerSec;/* in sectors */
#endif	/* !atari */
d385 1
a385 1
	    pmp->pm_SectPerClust;
d412 9
d424 1
a424 10
	 * Be prepared for block size != 512
	 */
	pmp->pm_brbomask = bsize - 1;
	for (tmp = 0; bsize >>= 1; ++tmp)
		;
	pmp->pm_bnshift = tmp;
	/*
	 * Compute mask and shift value for isolating cluster relative
	 * byte offsets and cluster numbers from a file offset. We
	 * already know that the number of sectors per cluster is
a426 7
	bsize = pmp->pm_SectPerClust * pmp->pm_BytesPerSec;
	pmp->pm_crbomask  = bsize - 1;
	pmp->pm_bpcluster = bsize;
	for (tmp = 0; bsize >>= 1; ++tmp)
		;
	pmp->pm_cnshift = tmp;

d429 2
a430 2
	 * Compute mask and shift value for isolating cluster relative byte
	 * offsets and cluster numbers from a file offset.
d432 1
a432 5
	pmp->pm_bpcluster = pmp->pm_SectPerClust * pmp->pm_BytesPerSec;
	pmp->pm_crbomask = pmp->pm_bpcluster - 1;
	pmp->pm_cnshift = ffs(pmp->pm_bpcluster) - 1;
	if (pmp->pm_cnshift < 0
	    || pmp->pm_bpcluster ^ (1 << pmp->pm_cnshift)) {
a435 3

	pmp->pm_brbomask = 0x01ff;	/* 512 byte blocks only (so far) */
	pmp->pm_bnshift = 9;	/* shift right 9 bits to get bn */
d471 2
a472 1
	pmp->pm_waitonfat = mp->mnt_flag & MNT_SYNCHRONOUS;
d477 3
a479 2
	pmp->pm_ronly = ronly;
	if (ronly == 0)
d555 2
a556 2
	error = VOP_CLOSE(pmp->pm_devvp, pmp->pm_ronly ? FREAD : FREAD|FWRITE,
	    NOCRED, p);
d578 1
a578 1
	if (error = deget(pmp, MSDOSFSROOT, MSDOSFSROOT_OFS, NULL, &ndep))
d646 1
a646 1
		if (pmp->pm_ronly != 0)
d667 3
a669 2
		if ((dep->de_flag & DE_UPDATE) == 0 &&
		    vp->v_dirtyblkhd.lh_first == NULL)
d705 1
a705 2
	error = deget(pmp, defhp->defid_dirclust, defhp->defid_dirofs,
	    NULL, &dep);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
