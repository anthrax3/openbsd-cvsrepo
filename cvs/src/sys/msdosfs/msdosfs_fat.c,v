head	1.28;
access;
symbols
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.6
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.8
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.6
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.14
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2015.10.23.17.21.34;	author krw;	state Exp;
branches;
next	1.27;
commitid	OojuukoxD2uoNfhb;

1.27
date	2015.10.23.10.45.31;	author krw;	state Exp;
branches;
next	1.26;
commitid	SncnQqnXMdpzMlro;

1.26
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.25;
commitid	P6Av4XGqOi3rFasL;

1.25
date	2014.06.18.17.24.46;	author tobias;	state Exp;
branches;
next	1.24;
commitid	PcFKoKWMluazbjIE;

1.24
date	2013.06.11.16.42.16;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.05.09.26.40;	author mikeb;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.13.22.34.29;	author jasper;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.05.01.14.40;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.16.12.44.05;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.16.19.00.51;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.14.04.05.05;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.12.21.04.15;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.10.07.46.33;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.04.21.13.37;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.22.19.04.23;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches
	1.11.6.1
	1.11.8.1;
next	1.10;

1.10
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.01.10.21.50.32;	author art;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	98.05.02.09.03.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.04.17.19.31.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.01.11.20.39.08;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.03.02.18.01.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.10.46.53;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.19.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches;
next	;

1.8.6.1
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.03.06.02.13.25;	author niklas;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.8.6.4;

1.8.6.4
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.8.6.5;

1.8.6.5
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.30.32;	author art;	state Exp;
branches;
next	;

1.11.6.1
date	2003.10.31.06.29.34;	author brad;	state Exp;
branches;
next	;

1.11.8.1
date	2003.10.31.06.05.28;	author brad;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Fix printf() types so kernel compiles with or w/o MSDOSFS_DEBUG.
e.g. print pointers with %p instead of %08x. No changes outside of
MSDOSFS_DEBUG.
@
text
@/*	$OpenBSD: msdosfs_fat.c,v 1.27 2015/10/23 10:45:31 krw Exp $	*/
/*	$NetBSD: msdosfs_fat.c,v 1.26 1997/10/17 11:24:02 ws Exp $	*/

/*-
 * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995, 1997 TooLs GmbH.
 * All rights reserved.
 * Original code by Paul Popelka (paulp@@uts.amdahl.com) (see below).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Written by Paul Popelka (paulp@@uts.amdahl.com)
 *
 * You can do anything you want with this software, just don't say you wrote
 * it, and don't remove this notice.
 *
 * This software is provided "as is".
 *
 * The author supplies this software to be publicly redistributed on the
 * understanding that the author is not responsible for the correct
 * functioning of this software in any circumstances and is not liable for
 * any damages caused by this software.
 *
 * October 1992
 */

/*
 * kernel include files.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/file.h>
#include <sys/namei.h>
#include <sys/mount.h>		/* to define statfs structure */
#include <sys/vnode.h>		/* to define vattr structure */
#include <sys/lock.h>
#include <sys/errno.h>
#include <sys/dirent.h>

/*
 * msdosfs include files.
 */
#include <msdosfs/bpb.h>
#include <msdosfs/msdosfsmount.h>
#include <msdosfs/direntry.h>
#include <msdosfs/denode.h>
#include <msdosfs/fat.h>

/*
 * Fat cache stats.
 */
int fc_fileextends;		/* # of file extends			 */
int fc_lfcempty;		/* # of time last file cluster cache entry
				 * was empty */
int fc_bmapcalls;		/* # of times pcbmap was called		 */

#define	LMMAX	20
int fc_lmdistance[LMMAX];	/* counters for how far off the last
				 * cluster mapped entry was. */
int fc_largedistance;		/* off by more than LMMAX		 */

static void fatblock(struct msdosfsmount *, uint32_t, uint32_t *, uint32_t *,
			  uint32_t *);
void updatefats(struct msdosfsmount *, struct buf *, uint32_t);
static __inline void usemap_free(struct msdosfsmount *, uint32_t);
static __inline void usemap_alloc(struct msdosfsmount *, uint32_t);
static int fatchain(struct msdosfsmount *, uint32_t, uint32_t, uint32_t);
int chainlength(struct msdosfsmount *, uint32_t, uint32_t);
int chainalloc(struct msdosfsmount *, uint32_t, uint32_t, uint32_t, uint32_t *,
		    uint32_t *);

static void
fatblock(struct msdosfsmount *pmp, uint32_t ofs, uint32_t *bnp, uint32_t *sizep,
    uint32_t *bop)
{
	uint32_t bn, size;

	bn = ofs / pmp->pm_fatblocksize * pmp->pm_fatblocksec;
	size = min(pmp->pm_fatblocksec, pmp->pm_FATsecs - bn) * DEV_BSIZE;
	bn += pmp->pm_fatblk + pmp->pm_curfat * pmp->pm_FATsecs;

	if (bnp)
		*bnp = bn;
	if (sizep)
		*sizep = size;
	if (bop)
		*bop = ofs % pmp->pm_fatblocksize;
}

/*
 * Map the logical cluster number of a file into a physical disk sector
 * that is filesystem relative.
 *
 * dep	  - address of denode representing the file of interest
 * findcn - file relative cluster whose filesystem relative cluster number
 *	    and/or block number are/is to be found
 * bnp	  - address of where to place the file system relative block number.
 *	    If this pointer is null then don't return this quantity.
 * cnp	  - address of where to place the file system relative cluster number.
 *	    If this pointer is null then don't return this quantity.
 *
 * NOTE: Either bnp or cnp must be non-null.
 * This function has one side effect.  If the requested file relative cluster
 * is beyond the end of file, then the actual number of clusters in the file
 * is returned in *cnp.  This is useful for determining how long a directory is.
 *  If cnp is null, nothing is returned.
 */
int
pcbmap(struct denode *dep, uint32_t findcn, daddr_t *bnp, uint32_t *cnp,
    int *sp)
{
	int error;
	uint32_t i;
	uint32_t cn;
	uint32_t prevcn = 0; /* XXX: prevcn could be used uninitialized */
	uint32_t byteoffset;
	uint32_t bn;
	uint32_t bo;
	struct buf *bp = NULL;
	uint32_t bp_bn = -1;
	struct msdosfsmount *pmp = dep->de_pmp;
	uint32_t bsize;

	fc_bmapcalls++;

	/*
	 * If they don't give us someplace to return a value then don't
	 * bother doing anything.
	 */
	if (bnp == NULL && cnp == NULL && sp == NULL)
		return (0);

	cn = dep->de_StartCluster;
	/*
	 * The "file" that makes up the root directory is contiguous,
	 * permanently allocated, of fixed size, and is not made up of
	 * clusters.  If the cluster number is beyond the end of the root
	 * directory, then return the number of clusters in the file.
	 */
	if (cn == MSDOSFSROOT) {
		if (dep->de_Attributes & ATTR_DIRECTORY) {
			if (de_cn2off(pmp, findcn) >= dep->de_FileSize) {
				if (cnp)
					*cnp = de_bn2cn(pmp, pmp->pm_rootdirsize);
				return (E2BIG);
			}
			if (bnp)
				*bnp = pmp->pm_rootdirblk + de_cn2bn(pmp, findcn);
			if (cnp)
				*cnp = MSDOSFSROOT;
			if (sp)
				*sp = min(pmp->pm_bpcluster,
				    dep->de_FileSize - de_cn2off(pmp, findcn));
			return (0);
		} else {		/* just an empty file */
			if (cnp)
				*cnp = 0;
			return (E2BIG);
		}
	}

	/*
	 * All other files do I/O in cluster sized blocks
	 */
	if (sp)
		*sp = pmp->pm_bpcluster;

	/*
	 * Rummage around in the fat cache, maybe we can avoid tromping
	 * thru every fat entry for the file. And, keep track of how far
	 * off the cache was from where we wanted to be.
	 */
	i = 0;
	fc_lookup(dep, findcn, &i, &cn);
	if ((bn = findcn - i) >= LMMAX)
		fc_largedistance++;
	else
		fc_lmdistance[bn]++;

	/*
	 * Handle all other files or directories the normal way.
	 */
	for (; i < findcn; i++) {
		/*
		 * Stop with all reserved clusters, not just with EOF.
		 */
		if ((cn | ~pmp->pm_fatmask) >= CLUST_RSRVD)
			goto hiteof;
		byteoffset = FATOFS(pmp, cn);
		fatblock(pmp, byteoffset, &bn, &bsize, &bo);
		if (bn != bp_bn) {
			if (bp)
				brelse(bp);
			error = bread(pmp->pm_devvp, bn, bsize, &bp);
			if (error) {
				brelse(bp);
				return (error);
			}
			bp_bn = bn;
		}
		prevcn = cn;
		if (bo >= bsize) {
			if (bp)
				brelse(bp);
			return (EIO);
		}
		if (FAT32(pmp))
			cn = getulong(&bp->b_data[bo]);
		else
			cn = getushort(&bp->b_data[bo]);
		if (FAT12(pmp) && (prevcn & 1))
			cn >>= 4;
		cn &= pmp->pm_fatmask;

		/*
		 * Force the special cluster numbers
		 * to be the same for all cluster sizes
		 * to let the rest of msdosfs handle
		 * all cases the same.
		 */
		if ((cn | ~pmp->pm_fatmask) >= CLUST_RSRVD)
			cn |= ~pmp->pm_fatmask;
	}

	if (!MSDOSFSEOF(pmp, cn)) {
		if (bp)
			brelse(bp);
		if (bnp)
			*bnp = cntobn(pmp, cn);
		if (cnp)
			*cnp = cn;
		fc_setcache(dep, FC_LASTMAP, i, cn);
		return (0);
	}

hiteof:;
	if (cnp)
		*cnp = i;
	if (bp)
		brelse(bp);
	/* update last file cluster entry in the fat cache */
	fc_setcache(dep, FC_LASTFC, i - 1, prevcn);
	return (E2BIG);
}

/*
 * Find the closest entry in the fat cache to the cluster we are looking
 * for.
 */
void
fc_lookup(struct denode *dep, uint32_t findcn, uint32_t *frcnp, uint32_t *fsrcnp)
{
	int i;
	uint32_t cn;
	struct fatcache *closest = 0;

	for (i = 0; i < FC_SIZE; i++) {
		cn = dep->de_fc[i].fc_frcn;
		if (cn != FCE_EMPTY && cn <= findcn) {
			if (closest == 0 || cn > closest->fc_frcn)
				closest = &dep->de_fc[i];
		}
	}
	if (closest) {
		*frcnp = closest->fc_frcn;
		*fsrcnp = closest->fc_fsrcn;
	}
}

/*
 * Purge the fat cache in denode dep of all entries relating to file
 * relative cluster frcn and beyond.
 */
void
fc_purge(struct denode *dep, u_int frcn)
{
	int i;
	struct fatcache *fcp;

	fcp = dep->de_fc;
	for (i = 0; i < FC_SIZE; i++, fcp++) {
		if (fcp->fc_frcn >= frcn)
			fcp->fc_frcn = FCE_EMPTY;
	}
}

/*
 * Update the fat.
 * If mirroring the fat, update all copies, with the first copy as last.
 * Else update only the current fat (ignoring the others).
 *
 * pmp	 - msdosfsmount structure for filesystem to update
 * bp	 - addr of modified fat block
 * fatbn - block number relative to begin of filesystem of the modified fat block.
 */
void
updatefats(struct msdosfsmount *pmp, struct buf *bp, uint32_t fatbn)
{
	int i;
	struct buf *bpn;

#ifdef MSDOSFS_DEBUG
	printf("updatefats(pmp %p, buf %p, fatbn %d)\n", pmp, bp, fatbn);
#endif

	/*
	 * If we have an FSInfo block, update it.
	 */
	if (pmp->pm_fsinfo) {
		if (bread(pmp->pm_devvp, pmp->pm_fsinfo, fsi_size(pmp),
		    &bpn) != 0) {
			/*
			 * Ignore the error, but turn off FSInfo update for the future.
			 */
			pmp->pm_fsinfo = 0;
			brelse(bpn);
		} else {
			struct fsinfo *fp = (struct fsinfo *)bpn->b_data;

			putulong(fp->fsinfree, pmp->pm_freeclustercount);
			if (pmp->pm_flags & MSDOSFSMNT_WAITONFAT)
				bwrite(bpn);
			else
				bdwrite(bpn);
		}
	}

	if (pmp->pm_flags & MSDOSFS_FATMIRROR) {
		/*
		 * Now copy the block(s) of the modified fat to the other copies of
		 * the fat and write them out.  This is faster than reading in the
		 * other fats and then writing them back out.  This could tie up
		 * the fat for quite a while. Preventing others from accessing it.
		 * To prevent us from going after the fat quite so much we use
		 * delayed writes, unless they specfied "synchronous" when the
		 * filesystem was mounted.  If synch is asked for then use
		 * bwrite()'s and really slow things down.
		 */
		for (i = 1; i < pmp->pm_FATs; i++) {
			fatbn += pmp->pm_FATsecs;
			/* getblk() never fails */
			bpn = getblk(pmp->pm_devvp, fatbn, bp->b_bcount, 0, 0);
			bcopy(bp->b_data, bpn->b_data, bp->b_bcount);
			if (pmp->pm_flags & MSDOSFSMNT_WAITONFAT)
				bwrite(bpn);
			else
				bdwrite(bpn);
		}
	}

	/*
	 * Write out the first (or current) fat last.
	 */
	if (pmp->pm_flags & MSDOSFSMNT_WAITONFAT)
		bwrite(bp);
	else
		bdwrite(bp);
	/*
	 * Maybe update fsinfo sector here?
	 */
}

/*
 * Updating entries in 12 bit fats is a pain in the butt.
 *
 * The following picture shows where nibbles go when moving from a 12 bit
 * cluster number into the appropriate bytes in the FAT.
 *
 *	byte m        byte m+1      byte m+2
 *	+----+----+   +----+----+   +----+----+
 *	|  0    1 |   |  2    3 |   |  4    5 |   FAT bytes
 *	+----+----+   +----+----+   +----+----+
 *
 *	+----+----+----+   +----+----+----+
 *	|  3    0    1 |   |  4    5    2 |
 *	+----+----+----+   +----+----+----+
 *	cluster n	   cluster n+1
 *
 * Where n is even. m = n + (n >> 2)
 *
 */
static __inline void
usemap_alloc(struct msdosfsmount *pmp, uint32_t cn)
{

	pmp->pm_inusemap[cn / N_INUSEBITS] |= 1 << (cn % N_INUSEBITS);
	pmp->pm_freeclustercount--;
}

static __inline void
usemap_free(struct msdosfsmount *pmp, uint32_t cn)
{

	pmp->pm_freeclustercount++;
	pmp->pm_inusemap[cn / N_INUSEBITS] &= ~(1 << (cn % N_INUSEBITS));
}

int
clusterfree(struct msdosfsmount *pmp, uint32_t cluster, uint32_t *oldcnp)
{
	int error;
	uint32_t oldcn;

	usemap_free(pmp, cluster);
	error = fatentry(FAT_GET_AND_SET, pmp, cluster, &oldcn, MSDOSFSFREE);
	if (error) {
		usemap_alloc(pmp, cluster);
		return (error);
	}
	/*
	 * If the cluster was successfully marked free, then update
	 * the count of free clusters, and turn off the "allocated"
	 * bit in the "in use" cluster bit map.
	 */
	if (oldcnp)
		*oldcnp = oldcn;
	return (0);
}

/*
 * Get or Set or 'Get and Set' the cluster'th entry in the fat.
 *
 * function	- whether to get or set a fat entry
 * pmp		- address of the msdosfsmount structure for the filesystem
 *		  whose fat is to be manipulated.
 * cn		- which cluster is of interest
 * oldcontents	- address of a word that is to receive the contents of the
 *		  cluster'th entry if this is a get function
 * newcontents	- the new value to be written into the cluster'th element of
 *		  the fat if this is a set function.
 *
 * This function can also be used to free a cluster by setting the fat entry
 * for a cluster to 0.
 *
 * All copies of the fat are updated if this is a set function. NOTE: If
 * fatentry() marks a cluster as free it does not update the inusemap in
 * the msdosfsmount structure. This is left to the caller.
 */
int
fatentry(int function, struct msdosfsmount *pmp, uint32_t cn, uint32_t *oldcontents,
    uint32_t newcontents)
{
	int error;
	uint32_t readcn;
	uint32_t bn, bo, bsize, byteoffset;
	struct buf *bp;

#ifdef MSDOSFS_DEBUG
	 printf("fatentry(func %d, pmp %p, clust %d, oldcon %p, "
	     "newcon %d)\n", function, pmp, cn, oldcontents, newcontents);
#endif

#ifdef DIAGNOSTIC
	/*
	 * Be sure they asked us to do something.
	 */
	if ((function & (FAT_SET | FAT_GET)) == 0) {
		printf("fatentry(): function code doesn't specify get or set\n");
		return (EINVAL);
	}

	/*
	 * If they asked us to return a cluster number but didn't tell us
	 * where to put it, give them an error.
	 */
	if ((function & FAT_GET) && oldcontents == NULL) {
		printf("fatentry(): get function with no place to put result\n");
		return (EINVAL);
	}
#endif

	/*
	 * Be sure the requested cluster is in the filesystem.
	 */
	if (cn < CLUST_FIRST || cn > pmp->pm_maxcluster)
		return (EINVAL);

	byteoffset = FATOFS(pmp, cn);
	fatblock(pmp, byteoffset, &bn, &bsize, &bo);
	if ((error = bread(pmp->pm_devvp, bn, bsize, &bp)) != 0) {
		brelse(bp);
		return (error);
	}

	if (function & FAT_GET) {
		if (FAT32(pmp))
			readcn = getulong(&bp->b_data[bo]);
		else
			readcn = getushort(&bp->b_data[bo]);
		if (FAT12(pmp) && (cn & 1))
			readcn >>= 4;
		readcn &= pmp->pm_fatmask;
		/* map reserved fat entries to same values for all fats */
		if ((readcn | ~pmp->pm_fatmask) >= CLUST_RSRVD)
			readcn |= ~pmp->pm_fatmask;
		*oldcontents = readcn;
	}
	if (function & FAT_SET) {
		switch (pmp->pm_fatmask) {
		case FAT12_MASK:
			readcn = getushort(&bp->b_data[bo]);
			if (cn & 1) {
				readcn &= 0x000f;
				readcn |= newcontents << 4;
			} else {
				readcn &= 0xf000;
				readcn |= newcontents & 0xfff;
			}
			putushort(&bp->b_data[bo], readcn);
			break;
		case FAT16_MASK:
			putushort(&bp->b_data[bo], newcontents);
			break;
		case FAT32_MASK:
			/*
			 * According to spec we have to retain the
			 * high order bits of the fat entry.
			 */
			readcn = getulong(&bp->b_data[bo]);
			readcn &= ~FAT32_MASK;
			readcn |= newcontents & FAT32_MASK;
			putulong(&bp->b_data[bo], readcn);
			break;
		}
		updatefats(pmp, bp, bn);
		bp = NULL;
		pmp->pm_fmod = 1;
	}
	if (bp)
		brelse(bp);
	return (0);
}

/*
 * Update a contiguous cluster chain
 *
 * pmp	    - mount point
 * start    - first cluster of chain
 * count    - number of clusters in chain
 * fillwith - what to write into fat entry of last cluster
 */
static int
fatchain(struct msdosfsmount *pmp, uint32_t start, uint32_t count, uint32_t fillwith)
{
	int error;
	uint32_t bn, bo, bsize, byteoffset, readcn, newc;
	struct buf *bp;

#ifdef MSDOSFS_DEBUG
	printf("fatchain(pmp %p, start %d, count %d, fillwith %d)\n",
	    pmp, start, count, fillwith);
#endif
	/*
	 * Be sure the clusters are in the filesystem.
	 */
	if (start < CLUST_FIRST || start + count - 1 > pmp->pm_maxcluster)
		return (EINVAL);

	while (count > 0) {
		byteoffset = FATOFS(pmp, start);
		fatblock(pmp, byteoffset, &bn, &bsize, &bo);
		error = bread(pmp->pm_devvp, bn, bsize, &bp);
		if (error) {
			brelse(bp);
			return (error);
		}
		while (count > 0) {
			start++;
			newc = --count > 0 ? start : fillwith;
			switch (pmp->pm_fatmask) {
			case FAT12_MASK:
				readcn = getushort(&bp->b_data[bo]);
				if (start & 1) {
					readcn &= 0xf000;
					readcn |= newc & 0xfff;
				} else {
					readcn &= 0x000f;
					readcn |= newc << 4;
				}
				putushort(&bp->b_data[bo], readcn);
				bo++;
				if (!(start & 1))
					bo++;
				break;
			case FAT16_MASK:
				putushort(&bp->b_data[bo], newc);
				bo += 2;
				break;
			case FAT32_MASK:
				readcn = getulong(&bp->b_data[bo]);
				readcn &= ~pmp->pm_fatmask;
				readcn |= newc & pmp->pm_fatmask;
				putulong(&bp->b_data[bo], readcn);
				bo += 4;
				break;
			}
			if (bo >= bsize)
				break;
		}
		updatefats(pmp, bp, bn);
	}
	pmp->pm_fmod = 1;
	return (0);
}

/*
 * Check the length of a free cluster chain starting at start.
 *
 * pmp	 - mount point
 * start - start of chain
 * count - maximum interesting length
 */
int
chainlength(struct msdosfsmount *pmp, uint32_t start, uint32_t count)
{
	uint32_t idx, max_idx;
	u_int map;
	uint32_t len;

	max_idx = pmp->pm_maxcluster / N_INUSEBITS;
	idx = start / N_INUSEBITS;
	start %= N_INUSEBITS;
	map = pmp->pm_inusemap[idx];
	map &= ~((1 << start) - 1);
	if (map) {
		len = ffs(map) - 1 - start;
		return (len > count ? count : len);
	}
	len = N_INUSEBITS - start;
	if (len >= count)
		return (count);
	while (++idx <= max_idx) {
		if (len >= count)
			break;
		if ((map = pmp->pm_inusemap[idx]) != 0) {
			len +=  ffs(map) - 1;
			break;
		}
		len += N_INUSEBITS;
	}
	return (len > count ? count : len);
}

/*
 * Allocate contigous free clusters.
 *
 * pmp	      - mount point.
 * start      - start of cluster chain.
 * count      - number of clusters to allocate.
 * fillwith   - put this value into the fat entry for the
 *		last allocated cluster.
 * retcluster - put the first allocated cluster's number here.
 * got	      - how many clusters were actually allocated.
 */
int
chainalloc(struct msdosfsmount *pmp, uint32_t start, uint32_t count,
    uint32_t fillwith, uint32_t *retcluster, uint32_t *got)
{
	int error;
	uint32_t cl, n;

	for (cl = start, n = count; n-- > 0;)
		usemap_alloc(pmp, cl++);
	if ((error = fatchain(pmp, start, count, fillwith)) != 0)
		return (error);
#ifdef MSDOSFS_DEBUG
	printf("clusteralloc(): allocated cluster chain at %d (%d clusters)\n",
	    start, count);
#endif
	if (retcluster)
		*retcluster = start;
	if (got)
		*got = count;
	return (0);
}

/*
 * Allocate contiguous free clusters.
 *
 * pmp	      - mount point.
 * start      - preferred start of cluster chain.
 * count      - number of clusters requested.
 * fillwith   - put this value into the fat entry for the
 *		last allocated cluster.
 * retcluster - put the first allocated cluster's number here.
 * got	      - how many clusters were actually allocated.
 */
int
clusteralloc(struct msdosfsmount *pmp, uint32_t start, uint32_t count,
    uint32_t fillwith, uint32_t *retcluster, uint32_t *got)
{
	uint32_t idx;
	uint32_t len, newst, foundl, cn, l;
	uint32_t foundcn = 0; /* XXX: foundcn could be used uninitialized */
	u_int map;

#ifdef MSDOSFS_DEBUG
	printf("clusteralloc(): find %d clusters\n",count);
#endif
	if (start) {
		if ((len = chainlength(pmp, start, count)) >= count)
			return (chainalloc(pmp, start, count, fillwith, retcluster, got));
	} else {
		/*
		 * This is a new file, initialize start
		 */
		struct timeval tv;

		microtime(&tv);
		start = (tv.tv_usec >> 10) | tv.tv_usec;
		len = 0;
	}

	/*
	 * Start at a (pseudo) random place to maximize cluster runs
	 * under multiple writers.
	 */
	newst = (start * 1103515245 + 12345) % (pmp->pm_maxcluster + 1);
	foundl = 0;

	for (cn = newst; cn <= pmp->pm_maxcluster;) {
		idx = cn / N_INUSEBITS;
		map = pmp->pm_inusemap[idx];
		map |= (1 << (cn % N_INUSEBITS)) - 1;
		if (map != (u_int)-1) {
			cn = idx * N_INUSEBITS + ffs(map^(u_int)-1) - 1;
			if ((l = chainlength(pmp, cn, count)) >= count)
				return (chainalloc(pmp, cn, count, fillwith, retcluster, got));
			if (l > foundl) {
				foundcn = cn;
				foundl = l;
			}
			cn += l + 1;
			continue;
		}
		cn += N_INUSEBITS - cn % N_INUSEBITS;
	}
	for (cn = 0; cn < newst;) {
		idx = cn / N_INUSEBITS;
		map = pmp->pm_inusemap[idx];
		map |= (1 << (cn % N_INUSEBITS)) - 1;
		if (map != (u_int)-1) {
			cn = idx * N_INUSEBITS + ffs(map^(u_int)-1) - 1;
			if ((l = chainlength(pmp, cn, count)) >= count)
				return (chainalloc(pmp, cn, count, fillwith, retcluster, got));
			if (l > foundl) {
				foundcn = cn;
				foundl = l;
			}
			cn += l + 1;
			continue;
		}
		cn += N_INUSEBITS - cn % N_INUSEBITS;
	}

	if (!foundl)
		return (ENOSPC);

	if (len)
		return (chainalloc(pmp, start, len, fillwith, retcluster, got));
	else
		return (chainalloc(pmp, foundcn, foundl, fillwith, retcluster, got));
}


/*
 * Free a chain of clusters.
 *
 * pmp		- address of the msdosfs mount structure for the filesystem
 *		  containing the cluster chain to be freed.
 * startcluster - number of the 1st cluster in the chain of clusters to be
 *		  freed.
 */
int
freeclusterchain(struct msdosfsmount *pmp, uint32_t cluster)
{
	int error;
	struct buf *bp = NULL;
	uint32_t bn, bo, bsize, byteoffset;
	uint32_t readcn, lbn = -1;

	while (cluster >= CLUST_FIRST && cluster <= pmp->pm_maxcluster) {
		byteoffset = FATOFS(pmp, cluster);
		fatblock(pmp, byteoffset, &bn, &bsize, &bo);
		if (lbn != bn) {
			if (bp)
				updatefats(pmp, bp, lbn);
			error = bread(pmp->pm_devvp, bn, bsize, &bp);
			if (error) {
				brelse(bp);
				return (error);
			}
			lbn = bn;
		}
		usemap_free(pmp, cluster);
		switch (pmp->pm_fatmask) {
		case FAT12_MASK:
			readcn = getushort(&bp->b_data[bo]);
			if (cluster & 1) {
				cluster = readcn >> 4;
				readcn &= 0x000f;
				readcn |= MSDOSFSFREE << 4;
			} else {
				cluster = readcn;
				readcn &= 0xf000;
				readcn |= MSDOSFSFREE & 0xfff;
			}
			putushort(&bp->b_data[bo], readcn);
			break;
		case FAT16_MASK:
			cluster = getushort(&bp->b_data[bo]);
			putushort(&bp->b_data[bo], MSDOSFSFREE);
			break;
		case FAT32_MASK:
			cluster = getulong(&bp->b_data[bo]);
			putulong(&bp->b_data[bo],
				 (MSDOSFSFREE & FAT32_MASK) | (cluster & ~FAT32_MASK));
			break;
		}
		cluster &= pmp->pm_fatmask;
		if ((cluster | ~pmp->pm_fatmask) >= CLUST_RSRVD)
			cluster |= pmp->pm_fatmask;
	}
	if (bp)
		updatefats(pmp, bp, bn);
	return (0);
}

/*
 * Read in fat blocks looking for free clusters. For every free cluster
 * found turn off its corresponding bit in the pm_inusemap.
 */
int
fillinusemap(struct msdosfsmount *pmp)
{
	struct buf *bp = NULL;
	uint32_t cn, readcn;
	int error;
	uint32_t bn, bo, bsize, byteoffset;

	/*
	 * Mark all clusters in use, we mark the free ones in the fat scan
	 * loop further down.
	 */
	for (cn = 0; cn < howmany(pmp->pm_maxcluster + 1, N_INUSEBITS); cn++)
		pmp->pm_inusemap[cn] = (u_int)-1;

	/*
	 * Figure how many free clusters are in the filesystem by ripping
	 * through the fat counting the number of entries whose content is
	 * zero.  These represent free clusters.
	 */
	pmp->pm_freeclustercount = 0;
	for (cn = CLUST_FIRST; cn <= pmp->pm_maxcluster; cn++) {
		byteoffset = FATOFS(pmp, cn);
		bo = byteoffset % pmp->pm_fatblocksize;
		if (!bo || !bp) {
			/* Read new FAT block */
			if (bp)
				brelse(bp);
			fatblock(pmp, byteoffset, &bn, &bsize, NULL);
			error = bread(pmp->pm_devvp, bn, bsize, &bp);
			if (error) {
				brelse(bp);
				return (error);
			}
		}
		if (FAT32(pmp))
			readcn = getulong(&bp->b_data[bo]);
		else
			readcn = getushort(&bp->b_data[bo]);
		if (FAT12(pmp) && (cn & 1))
			readcn >>= 4;
		readcn &= pmp->pm_fatmask;

		if (readcn == 0)
			usemap_free(pmp, cn);
	}
	brelse(bp);
	return (0);
}

/*
 * Allocate a new cluster and chain it onto the end of the file.
 *
 * dep	 - the file to extend
 * count - number of clusters to allocate
 * bpp	 - where to return the address of the buf header for the first new
 *	   file block
 * ncp	 - where to put cluster number of the first newly allocated cluster
 *	   If this pointer is 0, do not return the cluster number.
 * flags - see fat.h
 *
 * NOTE: This function is not responsible for turning on the DE_UPDATE bit of
 * the de_flag field of the denode and it does not change the de_FileSize
 * field.  This is left for the caller to do.
 */
int
extendfile(struct denode *dep, uint32_t count, struct buf **bpp, uint32_t *ncp,
    int flags)
{
	int error;
	uint32_t frcn;
	uint32_t cn, got;
	struct msdosfsmount *pmp = dep->de_pmp;
	struct buf *bp;

	/*
	 * Don't try to extend the root directory
	 */
	if (dep->de_StartCluster == MSDOSFSROOT
	    && (dep->de_Attributes & ATTR_DIRECTORY)) {
		printf("extendfile(): attempt to extend root directory\n");
		return (ENOSPC);
	}

	/*
	 * If the "file's last cluster" cache entry is empty, and the file
	 * is not empty, then fill the cache entry by calling pcbmap().
	 */
	fc_fileextends++;
	if (dep->de_fc[FC_LASTFC].fc_frcn == FCE_EMPTY &&
	    dep->de_StartCluster != 0) {
		fc_lfcempty++;
		error = pcbmap(dep, 0xffff, 0, &cn, 0);
		/* we expect it to return E2BIG */
		if (error != E2BIG)
			return (error);
	}

	/*
	 * Preserve value for the last cluster before extending the file
	 * to speed up further lookups.
	 */
	fc_setcache(dep, FC_OLASTFC, dep->de_fc[FC_LASTFC].fc_frcn,
	    dep->de_fc[FC_LASTFC].fc_fsrcn);

	while (count > 0) {
		/*
		 * Allocate a new cluster chain and cat onto the end of the
		 * file.  * If the file is empty we make de_StartCluster point
		 * to the new block.  Note that de_StartCluster being 0 is
		 * sufficient to be sure the file is empty since we exclude
		 * attempts to extend the root directory above, and the root
		 * dir is the only file with a startcluster of 0 that has
		 * blocks allocated (sort of).
		 */
		if (dep->de_StartCluster == 0)
			cn = 0;
		else
			cn = dep->de_fc[FC_LASTFC].fc_fsrcn + 1;
		error = clusteralloc(pmp, cn, count, CLUST_EOFE, &cn, &got);
		if (error)
			return (error);

		count -= got;

		/*
		 * Give them the filesystem relative cluster number if they want
		 * it.
		 */
		if (ncp) {
			*ncp = cn;
			ncp = NULL;
		}

		if (dep->de_StartCluster == 0) {
			dep->de_StartCluster = cn;
			frcn = 0;
		} else {
			error = fatentry(FAT_SET, pmp,
					 dep->de_fc[FC_LASTFC].fc_fsrcn,
					 0, cn);
			if (error) {
				clusterfree(pmp, cn, NULL);
				return (error);
			}
			frcn = dep->de_fc[FC_LASTFC].fc_frcn + 1;
		}

		/*
		 * Update the "last cluster of the file" entry in the denode's fat
		 * cache.
		 */
		fc_setcache(dep, FC_LASTFC, frcn + got - 1, cn + got - 1);

		if (flags & DE_CLEAR) {
			while (got-- > 0) {
				/*
				 * Get the buf header for the new block of the file.
				 */
				if (dep->de_Attributes & ATTR_DIRECTORY)
					bp = getblk(pmp->pm_devvp, cntobn(pmp, cn++),
						    pmp->pm_bpcluster, 0, 0);
				else {
					bp = getblk(DETOV(dep), de_cn2bn(pmp, frcn++),
					    pmp->pm_bpcluster, 0, 0);
					/*
					 * Do the bmap now, as in msdosfs_write
					 */
					if (pcbmap(dep,
					    de_bn2cn(pmp, bp->b_lblkno),
					    &bp->b_blkno, 0, 0))
						bp->b_blkno = -1;
					if (bp->b_blkno == -1)
						panic("extendfile: pcbmap");
				}
				clrbuf(bp);
				if (bpp) {
					*bpp = bp;
					bpp = NULL;
				} else
					bdwrite(bp);
			}
		}
	}

	return (0);
}
@


1.27
log
@Nuke a bunch of leading/embedded/trailing whitespace so the code can be
read without generating spurious headaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.26 2014/12/16 18:30:04 tedu Exp $	*/
d328 1
a328 1
	printf("updatefats(pmp %08, buf %x, fatbn %ld)\n", pmp, bp, fatbn);
d474 2
a475 2
	 printf("fatentry(func %d, pmp %08x, clust %d, oldcon %08x, newcon %d)\n",
	     function, pmp, cn, oldcontents, newcontents);
d575 1
a575 1
	printf("fatchain(pmp %08x, start %d, count %d, fillwith %d)\n",
@


1.26
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.25 2014/06/18 17:24:46 tobias Exp $	*/
d37 1
a37 1
 * 
d40 1
a40 1
 * 
d42 1
a42 1
 * 
d47 1
a47 1
 * 
d390 1
a390 1
 * 
d393 1
a393 1
 * 
d398 1
a398 1
 * 
d402 2
a403 2
 *	cluster n  	   cluster n+1
 * 
d405 1
a405 1
 * 
d456 1
a456 1
 * 
d459 1
a459 1
 * 
d509 1
a509 1
	
d573 1
a573 1
	
d583 1
a583 1
	
d644 1
a644 1
	
d721 1
a721 1
	
d733 1
a733 1
		
d738 1
a738 1
	
d745 1
a745 1
	
d932 1
a932 1
	
d980 1
a980 1
		
d982 1
a982 1
		
d991 1
a991 1
		
d1005 1
a1005 1
		
d1011 1
a1011 1
		
d1042 1
a1042 1
	
@


1.25
log
@Fix off by one in pm_inusemap.

FreeBSD did this years ago in revision 126086 as pointed out by
John-Mark Gurney on tech.  Merge it and sync two occurrences.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.24 2013/06/11 16:42:16 deraadt Exp $	*/
d61 1
@


1.24
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.23 2012/04/05 09:26:40 mikeb Exp $	*/
d869 1
a869 1
	for (cn = 0; cn < (pmp->pm_maxcluster + N_INUSEBITS) / N_INUSEBITS; cn++)
@


1.23
log
@As it was made evident by Olaf 'Rhialto' Seibert in the NetBSD PR 34583,
caching the last cluster in the file before extending it considerably
speeds up further lookups.  As a consequence this keeps write speed from
gradually decreasing and provides a measurable (up to 2x) performance
increase.  Prompted by the diff from Alexander Polakov, ok miod, krw.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.22 2011/07/04 04:30:41 tedu Exp $	*/
d133 1
a133 1
pcbmap(struct denode *dep, uint32_t findcn, daddr64_t *bnp, uint32_t *cnp,
@


1.22
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.21 2009/08/13 22:34:29 jasper Exp $	*/
d954 7
@


1.21
log
@- ansify function declarations, no binary change

"fine" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.20 2009/01/05 01:14:40 krw Exp $	*/
d218 1
a218 1
			error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp);
d334 1
a334 1
		if (bread(pmp->pm_devvp, pmp->pm_fsinfo, fsi_size(pmp), NOCRED,
d504 1
a504 1
	if ((error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp)) != 0) {
d586 1
a586 1
		error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp);
d812 1
a812 1
			error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp);
d886 1
a886 1
			error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp);
@


1.20
log
@The FAT32 fsinxtfree field is advisory in nature and we don't use
it. So leave it untouched. Similiar to but more ruthless than the
fixes FreeBSD did, since they do use the value.  Basically avoid
various off-by-one and off-by-many errors.

Fixes problems encountered by jsg@@ and deraadt@@ where filesystems
found on SDHC cards caused UVM faults.

Original fixes found by jsg@@. ok jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.19 2006/12/16 12:44:05 krw Exp $	*/
d97 2
a98 6
fatblock(pmp, ofs, bnp, sizep, bop)
	struct msdosfsmount *pmp;
	uint32_t ofs;
	uint32_t *bnp;
	uint32_t *sizep;
	uint32_t *bop;
d133 2
a134 6
pcbmap(dep, findcn, bnp, cnp, sp)
	struct denode *dep;
	uint32_t findcn;		/* file relative cluster to get		 */
	daddr64_t *bnp;		/* returned filesys relative blk number	 */
	uint32_t *cnp;		/* returned cluster number		 */
	int *sp;		/* returned block size			 */
d275 1
a275 5
fc_lookup(dep, findcn, frcnp, fsrcnp)
	struct denode *dep;
	uint32_t findcn;
	uint32_t *frcnp;
	uint32_t *fsrcnp;
d299 1
a299 3
fc_purge(dep, frcn)
	struct denode *dep;
	u_int frcn;
d321 1
a321 4
updatefats(pmp, bp, fatbn)
	struct msdosfsmount *pmp;
	struct buf *bp;
	uint32_t fatbn;
d407 1
a407 3
usemap_alloc(pmp, cn)
	struct msdosfsmount *pmp;
	uint32_t cn;
d415 1
a415 3
usemap_free(pmp, cn)
	struct msdosfsmount *pmp;
	uint32_t cn;
d423 1
a423 4
clusterfree(pmp, cluster, oldcnp)
	struct msdosfsmount *pmp;
	uint32_t cluster;
	uint32_t *oldcnp;
d464 2
a465 6
fatentry(function, pmp, cn, oldcontents, newcontents)
	int function;
	struct msdosfsmount *pmp;
	uint32_t cn;
	uint32_t *oldcontents;
	uint32_t newcontents;
d567 1
a567 5
fatchain(pmp, start, count, fillwith)
	struct msdosfsmount *pmp;
	uint32_t start;
	uint32_t count;
	uint32_t fillwith;
d638 1
a638 4
chainlength(pmp, start, count)
	struct msdosfsmount *pmp;
	uint32_t start;
	uint32_t count;
d680 2
a681 7
chainalloc(pmp, start, count, fillwith, retcluster, got)
	struct msdosfsmount *pmp;
	uint32_t start;
	uint32_t count;
	uint32_t fillwith;
	uint32_t *retcluster;
	uint32_t *got;
d713 2
a714 7
clusteralloc(pmp, start, count, fillwith, retcluster, got)
	struct msdosfsmount *pmp;
	uint32_t start;
	uint32_t count;
	uint32_t fillwith;
	uint32_t *retcluster;
	uint32_t *got;
d799 1
a799 3
freeclusterchain(pmp, cluster)
	struct msdosfsmount *pmp;
	uint32_t cluster;
d858 1
a858 2
fillinusemap(pmp)
	struct msdosfsmount *pmp;
d923 2
a924 6
extendfile(dep, count, bpp, ncp, flags)
	struct denode *dep;
	uint32_t count;
	struct buf **bpp;
	uint32_t *ncp;
	int flags;
@


1.19
log
@Adopt FreeBSD's code for non-DEV_BSIZE formatted MSDOSFS filesystems.

Enables devices (e.g. newer iPods, various other mp3 players) that use
2048 byte sectors.

Inspired by original diffs from weingart@@ and Alexey Vatchenk.

ok tom@@ pedro@@ deraadt@@ weingart@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.18 2006/10/03 19:49:06 pedro Exp $	*/
a350 16
		uint32_t cn = pmp->pm_nxtfree;

		if (pmp->pm_freeclustercount
		    && (pmp->pm_inusemap[cn / N_INUSEBITS]
			& (1 << (cn % N_INUSEBITS)))) {
			/*
			 * The cluster indicated in FSInfo isn't free
			 * any longer.  Got get a new free one.
			 */
			for (cn = 0; cn < pmp->pm_maxcluster; cn++)
				if (pmp->pm_inusemap[cn / N_INUSEBITS] != (u_int)-1)
					break;
			pmp->pm_nxtfree = cn
				+ ffs(pmp->pm_inusemap[cn / N_INUSEBITS]
				      ^ (u_int)-1) - 1;
		}
a361 1
			putulong(fp->fsinxtfree, pmp->pm_nxtfree);
@


1.18
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.17 2004/05/16 19:00:51 tedu Exp $	*/
d107 1
a107 2
	size = min(pmp->pm_fatblocksec, pmp->pm_FATsecs - bn)
	    * pmp->pm_BytesPerSec;
d367 2
a368 1
		if (bread(pmp->pm_devvp, pmp->pm_fsinfo, 1024, NOCRED, &bpn) != 0) {
@


1.17
log
@remove printfs i left in.  noticed by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.16 2004/05/14 04:05:05 tedu Exp $	*/
d141 1
a141 1
	daddr_t *bnp;		/* returned filesys relative blk number	 */
@


1.16
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.14 2003/12/10 07:46:33 itojun Exp $	*/
a177 1
				printf("E2BIG 1\n");
a190 1
			printf("E2BIG 2\n");
a275 1
	printf("E2BIG 3\n");
@


1.15
log
@32 bit ints are uint32_t, not u_long.  works on 64bit now.  ok deraadt@@
@
text
@@


1.14
log
@fix NULL/0 mixup
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.13 2003/12/04 21:13:37 miod Exp $	*/
d86 9
a94 9
static void fatblock(struct msdosfsmount *, u_long, u_long *, u_long *,
			  u_long *);
void updatefats(struct msdosfsmount *, struct buf *, u_long);
static __inline void usemap_free(struct msdosfsmount *, u_long);
static __inline void usemap_alloc(struct msdosfsmount *, u_long);
static int fatchain(struct msdosfsmount *, u_long, u_long, u_long);
int chainlength(struct msdosfsmount *, u_long, u_long);
int chainalloc(struct msdosfsmount *, u_long, u_long, u_long, u_long *,
		    u_long *);
d99 4
a102 4
	u_long ofs;
	u_long *bnp;
	u_long *sizep;
	u_long *bop;
d104 1
a104 1
	u_long bn, size;
d140 1
a140 1
	u_long findcn;		/* file relative cluster to get		 */
d142 1
a142 1
	u_long *cnp;		/* returned cluster number		 */
d146 6
a151 6
	u_long i;
	u_long cn;
	u_long prevcn = 0; /* XXX: prevcn could be used uninitialized */
	u_long byteoffset;
	u_long bn;
	u_long bo;
d153 1
a153 1
	u_long bp_bn = -1;
d155 1
a155 1
	u_long bsize;
d178 1
d192 1
d278 1
d289 3
a291 3
	u_long findcn;
	u_long *frcnp;
	u_long *fsrcnp;
d294 1
a294 1
	u_long cn;
d342 1
a342 1
	u_long fatbn;
d355 1
a355 1
		u_long cn = pmp->pm_nxtfree;
d446 1
a446 1
	u_long cn;
d456 1
a456 1
	u_long cn;
d466 2
a467 2
	u_long cluster;
	u_long *oldcnp;
d470 1
a470 1
	u_long oldcn;
d511 3
a513 3
	u_long cn;
	u_long *oldcontents;
	u_long newcontents;
d516 2
a517 2
	u_long readcn;
	u_long bn, bo, bsize, byteoffset;
d617 3
a619 3
	u_long start;
	u_long count;
	u_long fillwith;
d622 1
a622 1
	u_long bn, bo, bsize, byteoffset, readcn, newc;
d692 2
a693 2
	u_long start;
	u_long count;
d695 1
a695 1
	u_long idx, max_idx;
d697 1
a697 1
	u_long len;
d737 5
a741 5
	u_long start;
	u_long count;
	u_long fillwith;
	u_long *retcluster;
	u_long *got;
d744 1
a744 1
	u_long cl, n;
d775 9
a783 9
	u_long start;
	u_long count;
	u_long fillwith;
	u_long *retcluster;
	u_long *got;
{
	u_long idx;
	u_long len, newst, foundl, cn, l;
	u_long foundcn = 0; /* XXX: foundcn could be used uninitialized */
d866 1
a866 1
	u_long cluster;
d870 2
a871 2
	u_long bn, bo, bsize, byteoffset;
	u_long readcn, lbn = -1;
d929 1
a929 1
	u_long cn, readcn;
d931 1
a931 1
	u_long bn, bo, bsize, byteoffset;
d993 1
a993 1
	u_long count;
d995 1
a995 1
	u_long *ncp;
d999 2
a1000 2
	u_long frcn;
	u_long cn, got;
@


1.13
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.12 2003/10/22 19:04:23 tedu Exp $	*/
d711 1
a711 1
		if ((map = pmp->pm_inusemap[idx]) != NULL) {
@


1.12
log
@from netbsd:
Fix a panic that occurred when trying to traverse a corrupt msdosfs
filesystem.  With this particular corruption, the code in pcbmap()
would compute an offset into an array that was way out of bounds,
so check the bounds before trying to access and return an error if
the offset would be out of bounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.11 2002/03/14 01:27:09 millert Exp $	*/
d148 1
a148 1
	u_long prevcn = 0; /* XXX: prevcn could be used unititialized */
d780 1
a780 1
	u_long foundcn = 0; /* XXX: foundcn could be used unititialized */
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.10 2001/12/19 08:58:06 art Exp $	*/
d235 5
@


1.11.6.1
log
@MFC:
Fix by tedu@@

from netbsd:
Fix a panic that occurred when trying to traverse a corrupt msdosfs
filesystem.  With this particular corruption, the code in pcbmap()
would compute an offset into an array that was way out of bounds,
so check the bounds before trying to access and return an error if
the offset would be out of bounds.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.11 2002/03/14 01:27:09 millert Exp $	*/
a234 5
		if (bo >= bsize) {
			if (bp)
				brelse(bp);
			return (EIO);
		}
@


1.11.8.1
log
@MFC:
Fix by tedu@@

from netbsd:
Fix a panic that occurred when trying to traverse a corrupt msdosfs
filesystem.  With this particular corruption, the code in pcbmap()
would compute an offset into an array that was way out of bounds,
so check the bounds before trying to access and return an error if
the offset would be out of bounds.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.11 2002/03/14 01:27:09 millert Exp $	*/
a234 5
		if (bo >= bsize) {
			if (bp)
				brelse(bp);
			return (EIO);
		}
@


1.10
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.8 1999/01/10 21:50:32 art Exp $	*/
d86 9
a94 9
static void fatblock __P((struct msdosfsmount *, u_long, u_long *, u_long *,
			  u_long *));
void updatefats __P((struct msdosfsmount *, struct buf *, u_long));
static __inline void usemap_free __P((struct msdosfsmount *, u_long));
static __inline void usemap_alloc __P((struct msdosfsmount *, u_long));
static int fatchain __P((struct msdosfsmount *, u_long, u_long, u_long));
int chainlength __P((struct msdosfsmount *, u_long, u_long));
int chainalloc __P((struct msdosfsmount *, u_long, u_long, u_long, u_long *,
		    u_long *));
@


1.9
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d991 2
a992 1
	u_long frcn = 0, cn, got;
d1063 2
a1064 2
		 * Update the "last cluster of the file" entry in the
		 * denode's fat cache.
a1065 1

d1067 2
a1068 2
		if (flags & DE_CLEAR &&
		    (dep->de_Attributes & ATTR_DIRECTORY)) {
d1070 19
a1088 2
				bp = getblk(pmp->pm_devvp, cntobn(pmp, cn++),
				    pmp->pm_bpcluster, 0, 0);
d1093 1
a1093 1
				} else {
a1094 1
				}
d1098 1
a1098 1

@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.9 2001/11/27 05:27:12 art Exp $	*/
d86 9
a94 9
static void fatblock(struct msdosfsmount *, u_long, u_long *, u_long *,
			  u_long *);
void updatefats(struct msdosfsmount *, struct buf *, u_long);
static __inline void usemap_free(struct msdosfsmount *, u_long);
static __inline void usemap_alloc(struct msdosfsmount *, u_long);
static int fatchain(struct msdosfsmount *, u_long, u_long, u_long);
int chainlength(struct msdosfsmount *, u_long, u_long);
int chainalloc(struct msdosfsmount *, u_long, u_long, u_long, u_long *,
		    u_long *);
@


1.8
log
@make this work with MSDOSFS_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.7 1998/05/02 09:03:03 deraadt Exp $	*/
d991 1
a991 2
	u_long frcn;
	u_long cn, got;
d1062 2
a1063 2
		 * Update the "last cluster of the file" entry in the denode's fat
		 * cache.
d1065 1
d1067 2
a1068 2
		
		if (flags & DE_CLEAR) {
d1070 2
a1071 19
				/*
				 * Get the buf header for the new block of the file.
				 */
				if (dep->de_Attributes & ATTR_DIRECTORY)
					bp = getblk(pmp->pm_devvp, cntobn(pmp, cn++),
						    pmp->pm_bpcluster, 0, 0);
				else {
					bp = getblk(DETOV(dep), de_cn2bn(pmp, frcn++),
					    pmp->pm_bpcluster, 0, 0);
					/*
					 * Do the bmap now, as in msdosfs_write
					 */
					if (pcbmap(dep,
					    de_bn2cn(pmp, bp->b_lblkno),
					    &bp->b_blkno, 0, 0))
						bp->b_blkno = -1;
					if (bp->b_blkno == -1)
						panic("extendfile: pcbmap");
				}
d1076 1
a1076 1
				} else
d1078 1
d1082 1
a1082 1
	
@


1.8.6.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d991 2
a992 1
	u_long frcn = 0, cn, got;
d1063 2
a1064 2
		 * Update the "last cluster of the file" entry in the
		 * denode's fat cache.
a1065 1

d1067 2
a1068 2
		if (flags & DE_CLEAR &&
		    (dep->de_Attributes & ATTR_DIRECTORY)) {
d1070 19
a1088 2
				bp = getblk(pmp->pm_devvp, cntobn(pmp, cn++),
				    pmp->pm_bpcluster, 0, 0);
d1093 1
a1093 1
				} else {
a1094 1
				}
d1098 1
a1098 1

@


1.8.6.2
log
@Merge in trunk
@
text
@d991 1
a991 2
	u_long frcn;
	u_long cn, got;
d1062 2
a1063 2
		 * Update the "last cluster of the file" entry in the denode's fat
		 * cache.
d1065 1
d1067 2
a1068 2
		
		if (flags & DE_CLEAR) {
d1070 2
a1071 19
				/*
				 * Get the buf header for the new block of the file.
				 */
				if (dep->de_Attributes & ATTR_DIRECTORY)
					bp = getblk(pmp->pm_devvp, cntobn(pmp, cn++),
						    pmp->pm_bpcluster, 0, 0);
				else {
					bp = getblk(DETOV(dep), de_cn2bn(pmp, frcn++),
					    pmp->pm_bpcluster, 0, 0);
					/*
					 * Do the bmap now, as in msdosfs_write
					 */
					if (pcbmap(dep,
					    de_bn2cn(pmp, bp->b_lblkno),
					    &bp->b_blkno, 0, 0))
						bp->b_blkno = -1;
					if (bp->b_blkno == -1)
						panic("extendfile: pcbmap");
				}
d1076 1
a1076 1
				} else
d1078 1
d1082 1
a1082 1
	
@


1.8.6.3
log
@Merge in -current from roughly a week ago
@
text
@d86 9
a94 9
static void fatblock(struct msdosfsmount *, u_long, u_long *, u_long *,
			  u_long *);
void updatefats(struct msdosfsmount *, struct buf *, u_long);
static __inline void usemap_free(struct msdosfsmount *, u_long);
static __inline void usemap_alloc(struct msdosfsmount *, u_long);
static int fatchain(struct msdosfsmount *, u_long, u_long, u_long);
int chainlength(struct msdosfsmount *, u_long, u_long);
int chainalloc(struct msdosfsmount *, u_long, u_long, u_long, u_long *,
		    u_long *);
@


1.8.6.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d148 1
a148 1
	u_long prevcn = 0; /* XXX: prevcn could be used uninitialized */
a234 5
		if (bo >= bsize) {
			if (bp)
				brelse(bp);
			return (EIO);
		}
d706 1
a706 1
		if ((map = pmp->pm_inusemap[idx]) != 0) {
d775 1
a775 1
	u_long foundcn = 0; /* XXX: foundcn could be used uninitialized */
@


1.8.6.5
log
@Merge with the trunk
@
text
@d86 9
a94 9
static void fatblock(struct msdosfsmount *, uint32_t, uint32_t *, uint32_t *,
			  uint32_t *);
void updatefats(struct msdosfsmount *, struct buf *, uint32_t);
static __inline void usemap_free(struct msdosfsmount *, uint32_t);
static __inline void usemap_alloc(struct msdosfsmount *, uint32_t);
static int fatchain(struct msdosfsmount *, uint32_t, uint32_t, uint32_t);
int chainlength(struct msdosfsmount *, uint32_t, uint32_t);
int chainalloc(struct msdosfsmount *, uint32_t, uint32_t, uint32_t, uint32_t *,
		    uint32_t *);
d99 4
a102 4
	uint32_t ofs;
	uint32_t *bnp;
	uint32_t *sizep;
	uint32_t *bop;
d104 1
a104 1
	uint32_t bn, size;
d140 1
a140 1
	uint32_t findcn;		/* file relative cluster to get		 */
d142 1
a142 1
	uint32_t *cnp;		/* returned cluster number		 */
d146 6
a151 6
	uint32_t i;
	uint32_t cn;
	uint32_t prevcn = 0; /* XXX: prevcn could be used uninitialized */
	uint32_t byteoffset;
	uint32_t bn;
	uint32_t bo;
d153 1
a153 1
	uint32_t bp_bn = -1;
d155 1
a155 1
	uint32_t bsize;
d286 3
a288 3
	uint32_t findcn;
	uint32_t *frcnp;
	uint32_t *fsrcnp;
d291 1
a291 1
	uint32_t cn;
d339 1
a339 1
	uint32_t fatbn;
d352 1
a352 1
		uint32_t cn = pmp->pm_nxtfree;
d443 1
a443 1
	uint32_t cn;
d453 1
a453 1
	uint32_t cn;
d463 2
a464 2
	uint32_t cluster;
	uint32_t *oldcnp;
d467 1
a467 1
	uint32_t oldcn;
d508 3
a510 3
	uint32_t cn;
	uint32_t *oldcontents;
	uint32_t newcontents;
d513 2
a514 2
	uint32_t readcn;
	uint32_t bn, bo, bsize, byteoffset;
d614 3
a616 3
	uint32_t start;
	uint32_t count;
	uint32_t fillwith;
d619 1
a619 1
	uint32_t bn, bo, bsize, byteoffset, readcn, newc;
d689 2
a690 2
	uint32_t start;
	uint32_t count;
d692 1
a692 1
	uint32_t idx, max_idx;
d694 1
a694 1
	uint32_t len;
d734 5
a738 5
	uint32_t start;
	uint32_t count;
	uint32_t fillwith;
	uint32_t *retcluster;
	uint32_t *got;
d741 1
a741 1
	uint32_t cl, n;
d772 9
a780 9
	uint32_t start;
	uint32_t count;
	uint32_t fillwith;
	uint32_t *retcluster;
	uint32_t *got;
{
	uint32_t idx;
	uint32_t len, newst, foundl, cn, l;
	uint32_t foundcn = 0; /* XXX: foundcn could be used uninitialized */
d863 1
a863 1
	uint32_t cluster;
d867 2
a868 2
	uint32_t bn, bo, bsize, byteoffset;
	uint32_t readcn, lbn = -1;
d926 1
a926 1
	uint32_t cn, readcn;
d928 1
a928 1
	uint32_t bn, bo, bsize, byteoffset;
d990 1
a990 1
	uint32_t count;
d992 1
a992 1
	uint32_t *ncp;
d996 2
a997 2
	uint32_t frcn;
	uint32_t cn, got;
@


1.7
log
@correct a fat32 write lockup; oki@@yk.rim.or.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.6 1998/04/17 19:31:08 deraadt Exp $	*/
d340 1
a340 2
	printf("fatentry(func %d, pmp %08x, clust %d, oldcon %08x, newcon %d)\n",
	    function, pmp, cluster, oldcontents, newcontents);
d514 1
a514 1
	     function, pmp, cluster, oldcontents, newcontents);
@


1.6
log
@confusion over & and &&; cross@@va.pubnix.com
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.5 1998/01/11 20:39:08 provos Exp $	*/
d357 1
a357 1
			for (cn = 0; cn < pmp->pm_maxcluster;)
@


1.5
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_fat.c,v 1.4 1997/03/02 18:01:56 millert Exp $	*/
d555 1
a555 1
		if (FAT12(pmp) & (cn & 1))
@


1.4
log
@Sync msdosfs with NetBSD sans const-ness.  NetSBD log messages:
    Fix panic on mkdir.
    Thanks to Dave Huang for finding the bug.
    Fixes a bug with allowed/forbidden characters in non-W95 filenames.
    Don't extend directory when nothing is written to it.
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_fat.c,v 1.3 1996/02/29 10:46:53 niklas Exp $	*/
/*	$NetBSD: msdosfs_fat.c,v 1.24 1996/10/13 04:16:32 christos Exp $	*/
d5 2
a6 2
 * Copyright (C) 1994, 1995 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995 TooLs GmbH.
a85 3
/* Byte offset in FAT on filesystem pmp, cluster cn */
#define	FATOFS(pmp, cn)	(FAT12(pmp) ? (cn) * 3 / 2 : (cn) * 2)

d109 2
a110 1
	bn += pmp->pm_fatblk;
a155 1
	int fat12 = FAT12(pmp);	/* 12 bit fat	 */
d217 4
a220 1
		if (MSDOSFSEOF(cn))
d235 16
a250 14
		cn = getushort(&bp->b_data[bo]);
		if (fat12) {
			if (prevcn & 1)
				cn >>= 4;
			cn &= 0x0fff;
			/*
			 * Force the special cluster numbers in the range
			 * 0x0ff0-0x0fff to be the same as for 16 bit
			 * cluster numbers to let the rest of msdosfs think
			 * it is always dealing with 16 bit fats.
			 */
			if ((cn & 0x0ff0) == 0x0ff0)
				cn |= 0xf000;
		}
d253 1
a253 1
	if (!MSDOSFSEOF(cn)) {
d322 3
a324 1
 * Update all copies of the fat. The first copy is updated last.
d345 58
a402 18
	 * Now copy the block(s) of the modified fat to the other copies of
	 * the fat and write them out.  This is faster than reading in the
	 * other fats and then writing them back out.  This could tie up
	 * the fat for quite a while. Preventing others from accessing it.
	 * To prevent us from going after the fat quite so much we use
	 * delayed writes, unless they specfied "synchronous" when the
	 * filesystem was mounted.  If synch is asked for then use
	 * bwrite()'s and really slow things down.
	 */
	for (i = 1; i < pmp->pm_FATs; i++) {
		fatbn += pmp->pm_FATsecs;
		/* getblk() never fails */
		bpn = getblk(pmp->pm_devvp, fatbn, bp->b_bcount, 0, 0);
		bcopy(bp->b_data, bpn->b_data, bp->b_bcount);
		if (pmp->pm_flags & MSDOSFSMNT_WAITONFAT)
			bwrite(bpn);
		else
			bdwrite(bpn);
d404 1
d406 1
a406 1
	 * Write out the first fat last.
d412 3
d465 1
d467 2
a468 1
	if (error)
d470 1
a475 1
	usemap_free(pmp, cluster);
d513 1
a513 1
#if 0
d551 10
a560 9
		readcn = getushort(&bp->b_data[bo]);
		if (FAT12(pmp)) {
			if (cn & 1)
				readcn >>= 4;
			readcn &= 0x0fff;
			/* map certain 12 bit fat entries to 16 bit */
			if ((readcn & 0x0ff0) == 0x0ff0)
				readcn |= 0xf000;
		}
d564 2
a565 1
		if (FAT12(pmp)) {
d575 2
a576 1
		} else
d578 12
d639 2
a640 1
			if (FAT12(pmp)) {
d653 2
a654 1
			} else {
d657 8
d737 4
a740 1
	
a750 2
	while (count-- > 0)
		usemap_alloc(pmp, start++);
d880 3
a882 2
		readcn = getushort(&bp->b_data[bo]);
		if (FAT12(pmp)) {
d893 3
a895 5
			cluster &= 0x0fff;
			if ((cluster&0x0ff0) == 0x0ff0)
				cluster |= 0xf000;
		} else {
			cluster = readcn;
d897 6
d904 3
a923 1
	int fat12 = FAT12(pmp);
d953 7
a959 6
		readcn = getushort(&bp->b_data[bo]);
		if (fat12) {
			if (cn & 1)
				readcn >>= 4;
			readcn &= 0x0fff;
		}
d1000 2
a1001 1
	if (DETOV(dep)->v_flag & VROOT) {
@


1.3
log
@From NetBSD: merge with 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: msdosfs_fat.c,v 1.22 1996/02/09 19:13:45 christos Exp $	*/
d336 2
a337 2
	printf("updatefats(pmp %08x, bp %08x, fatbn %d)\n",
	       pmp, bp, fatbn);
d463 4
a466 4
	/*
	 * printf("fatentry(func %d, pmp %08x, clust %d, oldcon %08x, newcon %d)\n",
	 *	  function, pmp, cluster, oldcontents, newcontents);
	 */
d555 1
a555 1
	       pmp, start, count, fillwith);
d667 1
a667 1
	       start, count);
@


1.2
log
@from netbsd (mostly by ws):
Win95 ignores case on lookup
Really don't generate long names when mounted with -s
Fix cookie handling
Don't forward credentials to bread, it makes nfs panic
(Of course, nfs shouldn't rely on the credentials not being referenced)
Don't give directory entry to deget, it could result in a deadlock
Use device blocks, not clusters for logical block numbers
Add support for Win'95 separate creation/modification/access timestamps
Re-introduce lowercase filenames for non-Win'95-filesystems
Fix thinko with block boundaries in directories
Don't overwrite dirclust, it's needed later on
Enable flock(2).
@
text
@d1 2
a2 1
/*	$NetBSD: msdosfs_fat.c,v 1.21 1995/11/05 18:47:53 ws Exp $	*/
d89 10
d150 1
a150 1
	u_long prevcn;
d227 2
a228 2
			if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED,
					  &bp)) {
d417 2
a418 1
	if (error = fatentry(FAT_GET_AND_SET, pmp, cluster, &oldcn, MSDOSFSFREE))
d495 1
a495 1
	if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp)) {
d566 2
a567 1
		if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp)) {
d632 1
a632 1
		if (map = pmp->pm_inusemap[idx]) {
d663 1
a663 1
	if (error = fatchain(pmp, start, count, fillwith))
d699 2
a700 1
	u_long len, newst, foundcn, foundl, cn, l;
d796 2
a797 1
			if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp)) {
d864 2
a865 1
			if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp)) {
d937 7
a943 6
		 * Allocate a new cluster chain and cat onto the end of the file.
		 * If the file is empty we make de_StartCluster point to the new
		 * block.  Note that de_StartCluster being 0 is sufficient to be
		 * sure the file is empty since we exclude attempts to extend the
		 * root directory above, and the root dir is the only file with a
		 * startcluster of 0 that has blocks allocated (sort of).
d949 2
a950 1
		if (error = clusteralloc(pmp, cn, count, CLUST_EOFE, &cn, &got))
d968 4
a971 3
			if (error = fatentry(FAT_SET, pmp,
					     dep->de_fc[FC_LASTFC].fc_fsrcn,
					     0, cn)) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: msdosfs_fat.c,v 1.19 1995/09/09 19:38:04 ws Exp $	*/
d4 2
a5 2
 * Copyright (C) 1994 Wolfgang Solfrank.
 * Copyright (C) 1994 TooLs GmbH.
d61 1
d167 1
a167 1
			if (findcn * pmp->pm_SectPerClust >= pmp->pm_rootdirsize) {
d169 1
a169 1
					*cnp = pmp->pm_rootdirsize / pmp->pm_SectPerClust;
d173 1
a173 1
				*bnp = pmp->pm_rootdirblk + findcn * pmp->pm_SectPerClust;
d178 1
a178 1
				    dep->de_FileSize - findcn * pmp->pm_bpcluster);
d217 2
a218 1
					  &bp))
d220 1
d344 1
a344 1
		if (pmp->pm_waitonfat)
d352 1
a352 1
	if (pmp->pm_waitonfat)
d483 2
a484 1
	if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp))
d486 1
d554 2
a555 1
		if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp))
d557 1
d782 2
a783 1
			if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp))
d785 1
d849 2
a850 1
			if (error = bread(pmp->pm_devvp, bn, bsize, NOCRED, &bp))
d852 1
d974 2
a975 1
					bp = getblk(DETOV(dep), frcn++, pmp->pm_bpcluster, 0, 0);
d979 3
a981 1
					if (pcbmap(dep, bp->b_lblkno, &bp->b_blkno, 0, 0))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
