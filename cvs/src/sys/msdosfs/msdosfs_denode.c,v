head	1.57;
access;
symbols
	OPENBSD_6_1:1.57.0.6
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.53.0.6
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.35.0.10
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.6
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.4
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.28.0.6
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.24.0.10
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.8
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.6
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.10
	OPENBSD_2_8:1.16.0.8
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.6
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.4
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.56;
commitid	wHLNY5GFNXJSFYaC;

1.56
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.55;
commitid	gAjwyca5TfuoJAhn;

1.55
date	2015.10.23.17.21.34;	author krw;	state Exp;
branches;
next	1.54;
commitid	OojuukoxD2uoNfhb;

1.54
date	2015.10.23.10.45.31;	author krw;	state Exp;
branches;
next	1.53;
commitid	SncnQqnXMdpzMlro;

1.53
date	2015.01.09.05.01.57;	author tedu;	state Exp;
branches;
next	1.52;
commitid	KWogeIYA2sxG3IjB;

1.52
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.51;
commitid	P6Av4XGqOi3rFasL;

1.51
date	2014.11.18.10.42.15;	author dlg;	state Exp;
branches;
next	1.50;
commitid	4DOHz2gKfCx7RejS;

1.50
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.49;
commitid	uzzBR7hz9ncd4O6G;

1.49
date	2014.07.12.18.50.41;	author tedu;	state Exp;
branches;
next	1.48;
commitid	6GFaFyr1WL4xRwvz;

1.48
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	EF98ch02VpFassUi;

1.47
date	2013.12.24.00.18.46;	author halex;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.01.20.22.13;	author sf;	state Exp;
branches;
next	1.45;

1.45
date	2013.06.11.16.42.16;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2012.09.06.19.06.04;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2010.10.27.19.16.17;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.29.23.33.39;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2009.08.13.22.34.29;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.13.21.27.09;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.06.02.18.38;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.02.02.04.21;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.11.16.08.50;	author thib;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.09.12.43.16;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.14.04.05.05;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.12.21.04.15;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.27.04.58.45;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.02.15.24;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	99.04.28.09.28.16;	author art;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	99.02.26.03.28.13;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.01.08.11.00.53;	author art;	state Exp;
branches;
next	1.13;

1.13
date	98.08.21.22.40.02;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	98.08.21.22.36.11;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	98.01.11.20.39.07;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.11.11.18.57.16;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.22.52.46;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.11.06.05.58.56;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.20.20.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.15.22.38;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.04.19.08.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.02.18.01.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.10.46.51;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.19.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches;
next	;

1.16.4.1
date	2001.07.04.10.49.26;	author niklas;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.16.4.4;

1.16.4.4
date	2002.03.06.02.13.25;	author niklas;	state Exp;
branches;
next	1.16.4.5;

1.16.4.5
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.16.4.6;

1.16.4.6
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.02.02.03.28.25;	author art;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.06.11.03.30.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@/*	$OpenBSD: msdosfs_denode.c,v 1.56 2016/03/19 12:04:16 natano Exp $	*/
/*	$NetBSD: msdosfs_denode.c,v 1.23 1997/10/17 11:23:58 ws Exp $	*/

/*-
 * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995, 1997 TooLs GmbH.
 * All rights reserved.
 * Original code by Paul Popelka (paulp@@uts.amdahl.com) (see below).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Written by Paul Popelka (paulp@@uts.amdahl.com)
 *
 * You can do anything you want with this software, just don't say you wrote
 * it, and don't remove this notice.
 *
 * This software is provided "as is".
 *
 * The author supplies this software to be publicly redistributed on the
 * understanding that the author is not responsible for the correct
 * functioning of this software in any circumstances and is not liable for
 * any damages caused by this software.
 *
 * October 1992
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mount.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/kernel.h>		/* defines "time" */
#include <sys/dirent.h>
#include <sys/namei.h>

#include <crypto/siphash.h>

#include <msdosfs/bpb.h>
#include <msdosfs/msdosfsmount.h>
#include <msdosfs/direntry.h>
#include <msdosfs/denode.h>
#include <msdosfs/fat.h>

u_int msdosfs_dehash(dev_t, uint32_t, uint32_t);

struct denode **dehashtbl;
SIPHASH_KEY dehashkey;
u_long dehash;			/* size of hash table - 1 */
#define	DEHASH(dev, dcl, doff) msdosfs_dehash((dev), (dcl), (doff))

static struct denode *msdosfs_hashget(dev_t, uint32_t, uint32_t);
static int msdosfs_hashins(struct denode *);
static void msdosfs_hashrem(struct denode *);

/*ARGSUSED*/
int
msdosfs_init(struct vfsconf *vfsp)
{
	dehashtbl = hashinit(initialvnodes / 2, M_MSDOSFSMNT, M_WAITOK, &dehash);
	arc4random_buf(&dehashkey, sizeof(dehashkey));
	return (0);
}

u_int
msdosfs_dehash(dev_t dev, uint32_t dirclust, uint32_t diroff)
{
	SIPHASH_CTX ctx;

	SipHash24_Init(&ctx, &dehashkey);
	SipHash24_Update(&ctx, &dev, sizeof(dev));
	SipHash24_Update(&ctx, &dirclust, sizeof(dirclust));
	SipHash24_Update(&ctx, &diroff, sizeof(diroff));

	return (SipHash24_End(&ctx) & dehash);
}

static struct denode *
msdosfs_hashget(dev_t dev, uint32_t dirclust, uint32_t diroff)
{
	struct denode *dep;
	struct proc *p = curproc; /* XXX */

	for (;;)
		for (dep = dehashtbl[DEHASH(dev, dirclust, diroff)]; ;
		     dep = dep->de_next) {
			if (dep == NULL)
				return (NULL);
			if (dirclust == dep->de_dirclust &&
			    diroff == dep->de_diroffset &&
			    dev == dep->de_dev &&
			    dep->de_refcnt != 0) {
				struct vnode *vp = DETOV(dep);

				if (!vget(vp, LK_EXCLUSIVE, p))
					return (dep);
				break;
			}
		}
	/* NOTREACHED */
}

static int
msdosfs_hashins(struct denode *dep)
{
	struct denode **depp, *deq;

	depp = &dehashtbl[DEHASH(dep->de_dev, dep->de_dirclust,
				 dep->de_diroffset)];

	for (deq = *depp; deq; deq = deq->de_next) {
		if (dep->de_dirclust == deq->de_dirclust &&
		    dep->de_diroffset == deq->de_diroffset &&
		    dep->de_dev == deq->de_dev &&
		    deq->de_refcnt != 0) {
			return (EEXIST);
		}
	}

	if ((deq = *depp) != NULL)
		deq->de_prev = &dep->de_next;
	dep->de_next = deq;
	dep->de_prev = depp;
	*depp = dep;
	return (0);
}

static void
msdosfs_hashrem(struct denode *dep)
{
	struct denode *deq;

	if (dep->de_prev == NULL)
		return;

	if ((deq = dep->de_next) != NULL)
		deq->de_prev = dep->de_prev;
	*dep->de_prev = deq;
#ifdef DIAGNOSTIC
	dep->de_next = NULL;
	dep->de_prev = NULL;
#endif
}

/*
 * If deget() succeeds it returns with the gotten denode locked().
 *
 * pmp	     - address of msdosfsmount structure of the filesystem containing
 *	       the denode of interest.  The pm_dev field and the address of
 *	       the msdosfsmount structure are used.
 * dirclust  - which cluster bp contains, if dirclust is 0 (root directory)
 *	       diroffset is relative to the beginning of the root directory,
 *	       otherwise it is cluster relative.
 * diroffset - offset past begin of cluster of denode we want
 * depp	     - returns the address of the gotten denode.
 */
int
deget(struct msdosfsmount *pmp, uint32_t dirclust, uint32_t diroffset,
    struct denode **depp)
{
	int error;
	extern struct vops msdosfs_vops;
	struct direntry *direntptr;
	struct denode *ldep;
	struct vnode *nvp;
	struct buf *bp;
	struct proc *p = curproc; /* XXX */

#ifdef MSDOSFS_DEBUG
	printf("deget(pmp %p, dirclust %d, diroffset %x, depp %p)\n",
	    pmp, dirclust, diroffset, depp);
#endif

	/*
	 * On FAT32 filesystems, root is a (more or less) normal
	 * directory
	 */
	if (FAT32(pmp) && dirclust == MSDOSFSROOT)
		dirclust = pmp->pm_rootdirblk;

	/*
	 * See if the denode is in the denode cache. Use the location of
	 * the directory entry to compute the hash value. For subdir use
	 * address of "." entry. For root dir (if not FAT32) use cluster
	 * MSDOSFSROOT, offset MSDOSFSROOT_OFS
	 *
	 * NOTE: The check for de_refcnt > 0 below insures the denode being
	 * examined does not represent an unlinked but still open file.
	 * These files are not to be accessible even when the directory
	 * entry that represented the file happens to be reused while the
	 * deleted file is still open.
	 */
retry:
	ldep = msdosfs_hashget(pmp->pm_dev, dirclust, diroffset);
	if (ldep) {
		*depp = ldep;
		return (0);
	}

	/*
	 * Directory entry was not in cache, have to create a vnode and
	 * copy it from the passed disk buffer.
	 */
	/* getnewvnode() does a vref() on the vnode */
	error = getnewvnode(VT_MSDOSFS, pmp->pm_mountp, &msdosfs_vops, &nvp);
	if (error) {
		*depp = 0;
		return (error);
	}
	ldep = malloc(sizeof(*ldep), M_MSDOSFSNODE, M_WAITOK | M_ZERO);
	rrw_init(&ldep->de_lock, "denode");
	nvp->v_data = ldep;
	ldep->de_vnode = nvp;
	ldep->de_flag = 0;
	ldep->de_devvp = 0;
	ldep->de_lockf = 0;
	ldep->de_dev = pmp->pm_dev;
	ldep->de_dirclust = dirclust;
	ldep->de_diroffset = diroffset;
	fc_purge(ldep, 0);	/* init the fat cache for this denode */

	/*
	 * Insert the denode into the hash queue and lock the denode so it
	 * can't be accessed until we've read it in and have done what we
	 * need to it.
	 */
	vn_lock(nvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = msdosfs_hashins(ldep);

	if (error) {
		vput (nvp);

		if (error == EEXIST)
			goto retry;

		return (error);
	}

	ldep->de_pmp = pmp;
	ldep->de_devvp = pmp->pm_devvp;
	ldep->de_refcnt = 1;
	/*
	 * Copy the directory entry into the denode area of the vnode.
	 */
	if ((dirclust == MSDOSFSROOT
	     || (FAT32(pmp) && dirclust == pmp->pm_rootdirblk))
	    && diroffset == MSDOSFSROOT_OFS) {
		/*
		 * Directory entry for the root directory. There isn't one,
		 * so we manufacture one. We should probably rummage
		 * through the root directory and find a label entry (if it
		 * exists), and then use the time and date from that entry
		 * as the time and date for the root denode.
		 */
	        nvp->v_flag |= VROOT; /* should be further down         XXX */

		ldep->de_Attributes = ATTR_DIRECTORY;
		if (FAT32(pmp))
		        ldep->de_StartCluster = pmp->pm_rootdirblk;
		        /* de_FileSize will be filled in further down */
		else {
		        ldep->de_StartCluster = MSDOSFSROOT;
		        ldep->de_FileSize = pmp->pm_rootdirsize * pmp->pm_BytesPerSec;
		}
		/*
		 * fill in time and date so that dos2unixtime() doesn't
		 * spit up when called from msdosfs_getattr() with root
		 * denode
		 */
		ldep->de_CTime = 0x0000;	/* 00:00:00	 */
		ldep->de_CTimeHundredth = 0;
		ldep->de_CDate = (0 << DD_YEAR_SHIFT) | (1 << DD_MONTH_SHIFT)
		    | (1 << DD_DAY_SHIFT);
		/* Jan 1, 1980	 */
		ldep->de_ADate = ldep->de_CDate;
		ldep->de_MTime = ldep->de_CTime;
		ldep->de_MDate = ldep->de_CDate;
		/* leave the other fields as garbage */
	} else {
		error = readep(pmp, dirclust, diroffset, &bp, &direntptr);
		if (error)
			return (error);
		DE_INTERNALIZE(ldep, direntptr);
		brelse(bp);
	}

	/*
	 * Fill in a few fields of the vnode and finish filling in the
	 * denode.  Then return the address of the found denode.
	 */
	if (ldep->de_Attributes & ATTR_DIRECTORY) {
		/*
		 * Since DOS directory entries that describe directories
		 * have 0 in the filesize field, we take this opportunity
		 * to find out the length of the directory and plug it into
		 * the denode structure.
		 */
		uint32_t size;

		nvp->v_type = VDIR;
		if (ldep->de_StartCluster != MSDOSFSROOT) {
			error = pcbmap(ldep, 0xffff, 0, &size, 0);
			if (error == E2BIG) {
				ldep->de_FileSize = de_cn2off(pmp, size);
				error = 0;
			} else if (error) {
				printf("deget(): pcbmap returned %d\n", error);
				return (error);
			}
		}
	} else
		nvp->v_type = VREG;
	vref(ldep->de_devvp);
	*depp = ldep;
	return (0);
}

int
deupdat(struct denode *dep, int waitfor)
{
	struct buf *bp;
	struct direntry *dirp;
	int error;
	struct timespec ts;

	if (DETOV(dep)->v_mount->mnt_flag & MNT_RDONLY)
		return (0);
	getnanotime(&ts);
	DETIMES(dep, &ts, &ts, &ts);
	if ((dep->de_flag & DE_MODIFIED) == 0)
		return (0);
	dep->de_flag &= ~DE_MODIFIED;
	if (dep->de_Attributes & ATTR_DIRECTORY)
		return (0);
	if (dep->de_refcnt <= 0)
		return (0);
	error = readde(dep, &bp, &dirp);
	if (error)
		return (error);
	DE_EXTERNALIZE(dirp, dep);
	if (waitfor)
		return (bwrite(bp));
	else {
		bdwrite(bp);
		return (0);
	}
}

/*
 * Truncate the file described by dep to the length specified by length.
 */
int
detrunc(struct denode *dep, uint32_t length, int flags, struct ucred *cred,
    struct proc *p)
{
	int error;
	int allerror;
	int vflags;
	uint32_t eofentry;
	uint32_t chaintofree = 0;
	daddr_t bn;
	int boff;
	int isadir = dep->de_Attributes & ATTR_DIRECTORY;
	struct buf *bp;
	struct msdosfsmount *pmp = dep->de_pmp;

#ifdef MSDOSFS_DEBUG
	printf("detrunc(): file %.11s, length %u, flags %d\n",
	    dep->de_Name, length, flags);
#endif

	/*
	 * Disallow attempts to truncate the root directory since it is of
	 * fixed size.  That's just the way dos filesystems are.  We use
	 * the VROOT bit in the vnode because checking for the directory
	 * bit and a startcluster of 0 in the denode is not adequate to
	 * recognize the root directory at this point in a file or
	 * directory's life.
	 */
	if ((DETOV(dep)->v_flag & VROOT) && !FAT32(pmp)) {
		printf("detrunc(): can't truncate root directory, clust %u, offset %u\n",
		    dep->de_dirclust, dep->de_diroffset);
		return (EINVAL);
	}

	uvm_vnp_setsize(DETOV(dep), length);

	if (dep->de_FileSize < length)
		return (deextend(dep, length, cred));

	/*
	 * If the desired length is 0 then remember the starting cluster of
	 * the file and set the StartCluster field in the directory entry
	 * to 0.  If the desired length is not zero, then get the number of
	 * the last cluster in the shortened file.  Then get the number of
	 * the first cluster in the part of the file that is to be freed.
	 * Then set the next cluster pointer in the last cluster of the
	 * file to CLUST_EOFE.
	 */
	if (length == 0) {
		chaintofree = dep->de_StartCluster;
		dep->de_StartCluster = 0;
		eofentry = ~0;
	} else {
		error = pcbmap(dep, de_clcount(pmp, length) - 1, 0,
			       &eofentry, 0);
		if (error) {
#ifdef MSDOSFS_DEBUG
			printf("detrunc(): pcbmap fails %d\n", error);
#endif
			return (error);
		}
	}

	fc_purge(dep, de_clcount(pmp, length));

	/*
	 * If the new length is not a multiple of the cluster size then we
	 * must zero the tail end of the new last cluster in case it
	 * becomes part of the file again because of a seek.
	 */
	if ((boff = length & pmp->pm_crbomask) != 0) {
		if (isadir) {
			bn = cntobn(pmp, eofentry);
			error = bread(pmp->pm_devvp, bn, pmp->pm_bpcluster, &bp);
		} else {
			bn = de_blk(pmp, length);
			error = bread(DETOV(dep), bn, pmp->pm_bpcluster, &bp);
		}
		if (error) {
			brelse(bp);
#ifdef MSDOSFS_DEBUG
			printf("detrunc(): bread fails %d\n", error);
#endif
			return (error);
		}
		uvm_vnp_uncache(DETOV(dep));
		/*
		 * is this the right place for it?
		 */
		bzero(bp->b_data + boff, pmp->pm_bpcluster - boff);
		if (flags & IO_SYNC)
			bwrite(bp);
		else
			bdwrite(bp);
	}

	/*
	 * Write out the updated directory entry.  Even if the update fails
	 * we free the trailing clusters.
	 */
	dep->de_FileSize = length;
	if (!isadir)
		dep->de_flag |= DE_UPDATE|DE_MODIFIED;
	vflags = (length > 0 ? V_SAVE : 0) | V_SAVEMETA;
	vinvalbuf(DETOV(dep), vflags, cred, p, 0, 0);
	allerror = deupdat(dep, 1);
#ifdef MSDOSFS_DEBUG
	printf("detrunc(): allerror %d, eofentry %d\n",
	       allerror, eofentry);
#endif

	/*
	 * If we need to break the cluster chain for the file then do it
	 * now.
	 */
	if (eofentry != ~0) {
		error = fatentry(FAT_GET_AND_SET, pmp, eofentry,
				 &chaintofree, CLUST_EOFE);
		if (error) {
#ifdef MSDOSFS_DEBUG
			printf("detrunc(): fatentry errors %d\n", error);
#endif
			return (error);
		}
		fc_setcache(dep, FC_LASTFC, de_cluster(pmp, length - 1),
			    eofentry);
	}

	/*
	 * Now free the clusters removed from the file because of the
	 * truncation.
	 */
	if (chaintofree != 0 && !MSDOSFSEOF(pmp, chaintofree))
		freeclusterchain(pmp, chaintofree);

	return (allerror);
}

/*
 * Extend the file described by dep to length specified by length.
 */
int
deextend(struct denode *dep, uint32_t length, struct ucred *cred)
{
	struct msdosfsmount *pmp = dep->de_pmp;
	uint32_t count;
	int error;

	/*
	 * The root of a DOS filesystem cannot be extended.
	 */
	if ((DETOV(dep)->v_flag & VROOT) && !FAT32(pmp))
		return (EINVAL);

	/*
	 * Directories cannot be extended.
	 */
	if (dep->de_Attributes & ATTR_DIRECTORY)
		return (EISDIR);

	if (length <= dep->de_FileSize)
		panic("deextend: file too large");

	/*
	 * Compute the number of clusters to allocate.
	 */
	count = de_clcount(pmp, length) - de_clcount(pmp, dep->de_FileSize);
	if (count > 0) {
		if (count > pmp->pm_freeclustercount)
			return (ENOSPC);
		error = extendfile(dep, count, NULL, NULL, DE_CLEAR);
		if (error) {
			/* truncate the added clusters away again */
			(void) detrunc(dep, dep->de_FileSize, 0, cred, NULL);
			return (error);
		}
	}

	dep->de_FileSize = length;
	dep->de_flag |= DE_UPDATE|DE_MODIFIED;
	return (deupdat(dep, 1));
}

/*
 * Move a denode to its correct hash queue after the file it represents has
 * been moved to a new directory.
 */
void
reinsert(struct denode *dep)
{
	/*
	 * Fix up the denode cache.  If the denode is for a directory,
	 * there is nothing to do since the hash is based on the starting
	 * cluster of the directory file and that hasn't changed.  If for a
	 * file the hash is based on the location of the directory entry,
	 * so we must remove it from the cache and re-enter it with the
	 * hash based on the new location of the directory entry.
	 */
	if (dep->de_Attributes & ATTR_DIRECTORY)
		return;
	msdosfs_hashrem(dep);
	msdosfs_hashins(dep);
}

int
msdosfs_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct denode *dep = VTODE(vp);
#ifdef DIAGNOSTIC
	extern int prtactive;

	if (prtactive && vp->v_usecount != 0)
		vprint("msdosfs_reclaim(): pushing active", vp);
#endif

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_reclaim(): dep %p, file %.11s, refcnt %ld\n",
	    dep, dep->de_Name, dep->de_refcnt);
#endif

	/*
	 * Remove the denode from its hash chain.
	 */
	msdosfs_hashrem(dep);
	/*
	 * Purge old data structures associated with the denode.
	 */
	cache_purge(vp);
	if (dep->de_devvp) {
		vrele(dep->de_devvp);
		dep->de_devvp = 0;
	}
#if 0 /* XXX */
	dep->de_flag = 0;
#endif
	free(dep, M_MSDOSFSNODE, 0);
	vp->v_data = NULL;
	return (0);
}

int
msdosfs_inactive(void *v)
{
	struct vop_inactive_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct denode *dep = VTODE(vp);
	struct proc *p = ap->a_p;
	int error;
#ifdef DIAGNOSTIC
	extern int prtactive;

	if (prtactive && vp->v_usecount != 0)
		vprint("msdosfs_inactive(): pushing active", vp);
#endif

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_inactive(): dep %p, de_Name[0] %x\n", dep,
	    dep->de_Name[0]);
#endif

	error = 0;

	/*
	 * Get rid of denodes related to stale file handles.
	 */
	if (dep->de_Name[0] == SLOT_DELETED)
		goto out;

	/*
	 * If the file has been deleted and it is on a read/write
	 * filesystem, then truncate the file, and mark the directory slot
	 * as empty.  (This may not be necessary for the dos filesystem.)
	 */
#ifdef MSDOSFS_DEBUG
	printf("msdosfs_inactive(): dep %p, refcnt %ld, mntflag %x, "
	    "MNT_RDONLY %x\n", dep, dep->de_refcnt, vp->v_mount->mnt_flag,
	    MNT_RDONLY);
#endif
	if (dep->de_refcnt <= 0 && (vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
		error = detrunc(dep, (uint32_t)0, 0, NOCRED, NULL);
		dep->de_Name[0] = SLOT_DELETED;
	}
	deupdat(dep, 0);

out:
	VOP_UNLOCK(vp, p);
	/*
	 * If we are done with the denode, reclaim it
	 * so that it can be reused immediately.
	 */
#ifdef MSDOSFS_DEBUG
	printf("msdosfs_inactive(): v_usecount %d, de_Name[0] %x\n",
	    vp->v_usecount, dep->de_Name[0]);
#endif
	if (dep->de_Name[0] == SLOT_DELETED)
		vrecycle(vp, p);
	return (error);
}
@


1.56
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.55 2015/10/23 17:21:34 krw Exp $	*/
d236 1
a236 1
	lockinit(&ldep->de_lock, PINOD, "denode", 0, 0);
@


1.55
log
@Fix printf() types so kernel compiles with or w/o MSDOSFS_DEBUG.
e.g. print pointers with %p instead of %08x. No changes outside of
MSDOSFS_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.54 2015/10/23 10:45:31 krw Exp $	*/
d664 1
a664 1
	VOP_UNLOCK(vp, 0, p);
@


1.54
log
@Nuke a bunch of leading/embedded/trailing whitespace so the code can be
read without generating spurious headaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.53 2015/01/09 05:01:57 tedu Exp $	*/
d195 1
a195 1
	printf("deget(pmp %08x, dirclust %d, diroffset %x, depp %08x)\n",
d393 1
a393 1
	printf("detrunc(): file %.11s, length %ld, flags %d\n",
d595 1
a595 1
	printf("msdosfs_reclaim(): dep %08x, file %.11s, refcnt %d\n",
d635 1
a635 1
	printf("msdosfs_inactive(): dep %08x, de_Name[0] %x\n", dep,
d653 3
a655 2
	printf("msdosfs_inactive(): dep %08x, refcnt %d, mntflag %x, MNT_RDONLY %x\n",
	       dep, dep->de_refcnt, vp->v_mount->mnt_flag, MNT_RDONLY);
@


1.53
log
@rename desiredvnodes to initialvnodes. less of a lie. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.52 2014/12/16 18:30:04 tedu Exp $	*/
d37 1
a37 1
 * 
d40 1
a40 1
 * 
d42 1
a42 1
 * 
d47 1
a47 1
 * 
d108 1
a108 1
       
d135 1
a135 1
	
d171 1
a171 1
 * If deget() succeeds it returns with the gotten denode locked(). 
d175 1
a175 1
 *	       the msdosfsmount structure are used. 
d178 2
a179 2
 *	       otherwise it is cluster relative. 
 * diroffset - offset past begin of cluster of denode we want 
d211 1
a211 1
	 * 
d257 1
a257 1
		
d524 1
a524 1
	
d539 1
a539 1
	
d554 1
a554 1
		
d593 1
a593 1
	
d633 1
a633 1
	
d644 1
a644 1
	if (dep->de_Name[0] == SLOT_DELETED) 
@


1.52
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.51 2014/11/18 10:42:15 dlg Exp $	*/
d85 1
a85 1
	dehashtbl = hashinit(desiredvnodes/2, M_MSDOSFSMNT, M_WAITOK, &dehash);
@


1.51
log
@use siphash for key lookups in all the filesystem hashes.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.50 2014/09/14 14:17:26 jsg Exp $	*/
d57 1
@


1.50
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.49 2014/07/12 18:50:41 tedu Exp $	*/
d61 2
d69 2
d72 1
d74 1
a74 2
#define	DEHASH(dev, dcl, doff)	(((dev) + (dcl) + (doff) / sizeof(struct direntry)) \
				 & dehash)
d85 1
d87 13
@


1.49
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.48 2014/07/08 17:19:25 deraadt Exp $	*/
a54 1
#include <sys/proc.h>
@


1.48
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.47 2013/12/24 00:18:46 halex Exp $	*/
d596 1
a596 1
	free(dep, M_MSDOSFSNODE);
@


1.47
log
@fix error checking oddity in msdosfs code, as noted by kettenis@@

ok mikeb@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.46 2013/10/01 20:22:13 sf Exp $	*/
a60 2

#include <uvm/uvm_extern.h>
@


1.46
log
@Format string fixes: %hu/%hd for uint16_t, %u/%d/%x for uint32_t

- despite the name, ntohl returns uint32_t, not long
- also fix some %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.45 2013/06/11 16:42:16 deraadt Exp $	*/
d315 1
a315 1
			} else {
@


1.45
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.44 2012/09/06 19:06:04 krw Exp $	*/
d390 1
a390 1
		printf("detrunc(): can't truncate root directory, clust %ld, offset %ld\n",
@


1.44
log
@Remove the need to occasionally treat dos file names as strings by
using "%.11s" to print them out. Make all dos file names 11 byte
arrays and nuke the attempt to put '\0' at the 12th position of
such an array.

Fixes 'panic: smashed stack in msdosfs_rename.c' reported by
MERHIGI Marcus via tech@@.

Tested by MERHIGI Marcus. Suggestions and ok tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.43 2011/07/04 04:30:41 tedu Exp $	*/
d370 1
a370 1
	daddr64_t bn;
@


1.43
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.42 2010/12/21 20:14:43 thib Exp $	*/
d377 2
a378 1
	printf("detrunc(): file %s, length %ld, flags %d\n", dep->de_Name, length, flags);
d579 1
a579 1
	printf("msdosfs_reclaim(): dep %08x, file %s, refcnt %d\n",
d619 2
a620 1
	printf("msdosfs_inactive(): dep %08x, de_Name[0] %x\n", dep, dep->de_Name[0]);
d653 2
a654 2
	printf("msdosfs_inactive(): v_usecount %d, de_Name[0] %x\n", vp->v_usecount,
	       dep->de_Name[0]);
@


1.42
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.41 2010/10/27 19:16:17 deraadt Exp $	*/
d433 1
a433 2
			error = bread(pmp->pm_devvp, bn, pmp->pm_bpcluster,
			    NOCRED, &bp);
d436 1
a436 2
			error = bread(DETOV(dep), bn, pmp->pm_bpcluster,
			    NOCRED, &bp);
@


1.41
log
@improve the look of a for loop
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.40 2010/09/10 16:34:08 thib Exp $	*/
d171 1
a171 1
	extern int (**msdosfs_vnodeop_p)(void *);
d214 1
a214 2
	error = getnewvnode(VT_MSDOSFS, pmp->pm_mountp,
			    msdosfs_vnodeop_p, &nvp);
@


1.40
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.39 2010/09/06 23:44:10 thib Exp $	*/
d94 1
a94 1
		for (dep = dehashtbl[DEHASH(dev, dirclust, diroff)];;
@


1.39
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.38 2010/03/29 23:33:39 krw Exp $	*/
d171 1
a171 1
	extern struct vops msdosfs_vops;
d214 2
a215 1
	error = getnewvnode(VT_MSDOSFS, pmp->pm_mountp, &msdosfs_vops, &nvp);
@


1.38
log
@Initialize various uninitialized variables. Found by jsg@@ via Clang.

Feedback from miod@@ and kettenis@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.37 2009/08/13 22:34:29 jasper Exp $	*/
d171 1
a171 1
	extern int (**msdosfs_vnodeop_p)(void *);
d214 1
a214 2
	error = getnewvnode(VT_MSDOSFS, pmp->pm_mountp,
			    msdosfs_vnodeop_p, &nvp);
@


1.37
log
@- ansify function declarations, no binary change

"fine" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.36 2009/07/09 22:29:56 thib Exp $	*/
d370 1
a370 1
	uint32_t chaintofree;
@


1.36
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.34 2007/10/06 02:18:38 krw Exp $	*/
d81 1
a81 2
msdosfs_init(vfsp)
	struct vfsconf *vfsp;
d88 1
a88 4
msdosfs_hashget(dev, dirclust, diroff)
	dev_t dev;
	uint32_t dirclust;
	uint32_t diroff;
d113 1
a113 2
msdosfs_hashins(dep)
	struct denode *dep;
d138 1
a138 2
msdosfs_hashrem(dep)
	struct denode *dep;
d167 2
a168 5
deget(pmp, dirclust, diroffset, depp)
	struct msdosfsmount *pmp;	/* so we know the maj/min number */
	uint32_t dirclust;		/* cluster this dir entry came from */
	uint32_t diroffset;		/* index of entry within the cluster */
	struct denode **depp;		/* returns the addr of the gotten denode */
d329 1
a329 3
deupdat(dep, waitfor)
	struct denode *dep;
	int waitfor;
d363 2
a364 6
detrunc(dep, length, flags, cred, p)
	struct denode *dep;
	uint32_t length;
	int flags;
	struct ucred *cred;
	struct proc *p;
d505 1
a505 4
deextend(dep, length, cred)
	struct denode *dep;
	uint32_t length;
	struct ucred *cred;
d551 1
a551 2
reinsert(dep)
	struct denode *dep;
d568 1
a568 2
msdosfs_reclaim(v)
	void *v;
d606 1
a606 2
msdosfs_inactive(v)
	void *v;
@


1.35
log
@Return pcbmap() errors from deget() rather than ignoring them. EIO at
least has been seen from ian@@'s new iPod, causing inappropriate
mounting.

ok miod@@
@
text
@d222 1
a222 1
	/* getnewvnode() does a VREF() on the vnode */
d332 1
a332 1
	VREF(ldep->de_devvp);
@


1.34
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.33 2007/10/03 10:52:11 krw Exp $	*/
d325 1
a325 1
			} else
d327 2
@


1.33
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.32 2007/06/02 02:04:21 deraadt Exp $	*/
d618 1
a618 1
	FREE(dep, M_MSDOSFSNODE);
@


1.32
log
@convert all daddr_t types to either daddr64_t or uint32_t or other such
things based on their use.  ok with fixes from tom, tested by grange too
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.31 2007/06/01 23:47:57 deraadt Exp $	*/
d229 1
a229 3
	MALLOC(ldep, struct denode *, sizeof(struct denode), M_MSDOSFSNODE,
	    M_WAITOK);
	bzero((caddr_t)ldep, sizeof *ldep);
@


1.31
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.30 2007/04/11 16:08:50 thib Exp $	*/
d386 1
a386 1
	daddr_t bn;
@


1.30
log
@Remove the simplelock argument from vrecycle();

ok pedro@@, sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.29 2007/03/21 17:29:32 thib Exp $	*/
d590 1
a590 3
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d629 1
a629 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
@


1.29
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.28 2006/01/09 12:43:16 pedro Exp $	*/
d684 1
a684 1
		vrecycle(vp, (struct simplelock *)0, p);
@


1.28
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.27 2004/06/24 19:35:25 tholo Exp $	*/
d108 1
a108 2
				simple_lock(&vp->v_interlock);
				if (!vget(vp, LK_EXCLUSIVE  | LK_INTERLOCK, p))
@


1.27
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.26 2004/05/14 04:05:05 tedu Exp $	*/
d596 1
d598 4
a607 2
	if (prtactive && vp->v_usecount != 0)
		vprint("msdosfs_reclaim(): pushing active", vp);
d640 1
d642 4
a649 3

	if (prtactive && vp->v_usecount != 0)
		vprint("msdosfs_inactive(): pushing active", vp);
@


1.26
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.24 2002/03/14 01:27:09 millert Exp $	*/
d350 1
a350 1
	TIMEVAL_TO_TIMESPEC(&time, &ts);
@


1.25
log
@32 bit ints are uint32_t, not u_long.  works on 64bit now.  ok deraadt@@
@
text
@@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.23 2001/12/19 08:58:06 art Exp $	*/
d75 1
a75 1
static struct denode *msdosfs_hashget(dev_t, u_long, u_long);
d91 2
a92 2
	u_long dirclust;
	u_long diroff;
d176 2
a177 2
	u_long dirclust;		/* cluster this dir entry came from */
	u_long diroffset;		/* index of entry within the cluster */
d320 1
a320 1
		u_long size;
d377 1
a377 1
	u_long length;
d385 2
a386 2
	u_long eofentry;
	u_long chaintofree;
d523 1
a523 1
	u_long length;
d527 1
a527 1
	u_long count;
d664 1
a664 1
		error = detrunc(dep, (u_long)0, 0, NOCRED, NULL);
@


1.23
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.19 2001/11/06 19:53:20 miod Exp $	*/
d75 3
a77 3
static struct denode *msdosfs_hashget __P((dev_t, u_long, u_long));
static int msdosfs_hashins __P((struct denode *));
static void msdosfs_hashrem __P((struct denode *));
d181 1
a181 1
	extern int (**msdosfs_vnodeop_p) __P((void *));
@


1.22
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.21 2001/12/10 02:19:34 art Exp $	*/
a74 7
extern int prtactive;

struct genfs_ops msdosfs_genfsops = {
	genfs_size,
	msdosfs_gop_alloc,
};

a332 1
	genfs_node_init(nvp, &msdosfs_genfsops);
a334 1
	nvp->v_size = ldep->de_FileSize;
d464 1
a464 1

d527 1
a527 1
	u_long count, osize;
a559 1
	osize = dep->de_FileSize;
a560 1
	uvm_vnp_setsize(DETOV(dep), (voff_t)dep->de_FileSize);
a561 2
	uvm_vnp_zerorange(DETOV(dep), (off_t)osize,
	    (size_t)(dep->de_FileSize - osize));
d596 1
d637 1
d664 1
a664 3
		if (dep->de_FileSize != 0) {
			error = detrunc(dep, (u_long)0, 0, NOCRED, NULL);
		}
a681 7
}

int
msdosfs_gop_alloc(struct vnode *vp, off_t off, off_t len, int flags,
    struct ucred *cred)
{
	return 0;
@


1.22.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.22 2001/12/10 04:45:31 art Exp $	*/
a79 1
	genfs_gop_write
@


1.22.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.22.2.1 2002/02/02 03:28:25 art Exp $	*/
d83 3
a85 3
static struct denode *msdosfs_hashget(dev_t, u_long, u_long);
static int msdosfs_hashins(struct denode *);
static void msdosfs_hashrem(struct denode *);
d189 1
a189 1
	extern int (**msdosfs_vnodeop_p)(void *);
@


1.21
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.20 2001/11/27 05:27:12 art Exp $	*/
d77 5
d340 1
d695 7
@


1.20
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.19 2001/11/06 19:53:20 miod Exp $	*/
d337 1
a337 1
	nvp->v_uvm.u_size = ldep->de_FileSize;
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.18 2001/06/27 04:58:45 art Exp $	*/
d75 2
d337 1
d467 1
a467 1
		uvm_vnp_uncache(DETOV(dep));
d530 1
a530 1
	u_long count;
d563 1
d565 1
d567 2
a602 1
	extern int prtactive;
a642 1
	extern int prtactive;
d669 3
a671 1
		error = detrunc(dep, (u_long)0, 0, NOCRED, NULL);
@


1.18
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.17 2001/06/23 02:15:24 csapuntz Exp $	*/
d62 1
a62 1
#include <vm/vm.h>
@


1.17
log
@Get rid of several vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.16 1999/04/28 09:28:16 art Exp $	*/
a410 1
#if defined(UVM)
a411 3
#else
	vnode_pager_setsize(DETOV(dep), length);
#endif
a463 1
#if defined(UVM)
a464 3
#else
		vnode_pager_uncache(DETOV(dep));	/* what's this for? */
#endif
@


1.16
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.15 1999/02/26 03:28:13 art Exp $	*/
d343 3
d348 2
d351 18
a368 1
	return (VOP_UPDATE(DETOV(dep), &ts, &ts, waitfor));
@


1.16.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.16 1999/04/28 09:28:16 art Exp $	*/
a342 3
	struct buf *bp;
	struct direntry *dirp;
	int error;
a344 2
	if (DETOV(dep)->v_mount->mnt_flag & MNT_RDONLY)
		return (0);
d346 1
a346 18
	DETIMES(dep, &ts, &ts, &ts);
	if ((dep->de_flag & DE_MODIFIED) == 0)
		return (0);
	dep->de_flag &= ~DE_MODIFIED;
	if (dep->de_Attributes & ATTR_DIRECTORY)
		return (0);
	if (dep->de_refcnt <= 0)
		return (0);
	error = readde(dep, &bp, &dirp);
	if (error)
		return (error);
	DE_EXTERNALIZE(dirp, dep);
	if (waitfor)
		return (bwrite(bp));
	else {
		bdwrite(bp);
		return (0);
	}
d389 1
d391 3
d446 1
d448 3
@


1.16.4.2
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a62 1
#include <uvm/uvm_extern.h>
@


1.16.4.3
log
@Merge in -current
@
text
@a74 2
extern int prtactive;

a334 1
	nvp->v_uvm.u_size = ldep->de_FileSize;
d464 1
a464 1

d527 1
a527 1
	u_long count, osize;
a559 1
	osize = dep->de_FileSize;
a560 1
	uvm_vnp_setsize(DETOV(dep), (voff_t)dep->de_FileSize);
a561 2
	uvm_vnp_zerorange(DETOV(dep), (off_t)osize,
	    (size_t)(dep->de_FileSize - osize));
d596 1
d637 1
d664 1
a664 3
		if (dep->de_FileSize != 0) {
			error = detrunc(dep, (u_long)0, 0, NOCRED, NULL);
		}
@


1.16.4.4
log
@Merge in trunk
@
text
@d75 2
d337 1
d467 1
a467 1
		uvm_vnp_uncache(DETOV(dep));
d530 1
a530 1
	u_long count;
d563 1
d565 1
d567 2
a602 1
	extern int prtactive;
a642 1
	extern int prtactive;
d669 3
a671 1
		error = detrunc(dep, (u_long)0, 0, NOCRED, NULL);
@


1.16.4.5
log
@Merge in -current from roughly a week ago
@
text
@d75 3
a77 3
static struct denode *msdosfs_hashget(dev_t, u_long, u_long);
static int msdosfs_hashins(struct denode *);
static void msdosfs_hashrem(struct denode *);
d181 1
a181 1
	extern int (**msdosfs_vnodeop_p)(void *);
@


1.16.4.6
log
@Merge with the trunk
@
text
@d75 1
a75 1
static struct denode *msdosfs_hashget(dev_t, uint32_t, uint32_t);
d91 2
a92 2
	uint32_t dirclust;
	uint32_t diroff;
d176 2
a177 2
	uint32_t dirclust;		/* cluster this dir entry came from */
	uint32_t diroffset;		/* index of entry within the cluster */
d320 1
a320 1
		uint32_t size;
d377 1
a377 1
	uint32_t length;
d385 2
a386 2
	uint32_t eofentry;
	uint32_t chaintofree;
d523 1
a523 1
	uint32_t length;
d527 1
a527 1
	uint32_t count;
d664 1
a664 1
		error = detrunc(dep, (uint32_t)0, 0, NOCRED, NULL);
@


1.15
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.14 1999/01/08 11:00:53 art Exp $	*/
d84 1
a84 1
	dehashtbl = hashinit(desiredvnodes/2, M_MSDOSFSMNT, &dehash);
@


1.14
log
@always initialize error in inactive
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.13 1998/08/21 22:40:02 csapuntz Exp $	*/
d389 3
d393 1
d446 3
d450 1
@


1.13
log
@

Make tabbing better.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.12 1998/08/21 22:36:11 csapuntz Exp $	*/
d624 2
a631 1
	error = 0;
@


1.12
log
@

malloc can block so there was a race in this code which could cause two
vnodes to be created for a given file.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.11 1998/01/11 20:39:07 provos Exp $	*/
d124 2
a125 2
	    dep->de_diroffset)];

d150 1
a150 1
	  return;
d254 1
a254 1

@


1.11
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.10 1997/11/11 18:57:16 niklas Exp $	*/
d76 1
a76 1
static void msdosfs_hashins __P((struct denode *));
d117 1
a117 1
static void
d125 10
d140 1
d149 3
d212 1
d250 10
a259 1
	msdosfs_hashins(ldep);
@


1.10
log
@Initialize the de_lock.  some KNF
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_denode.c,v 1.9 1997/11/06 22:52:46 csapuntz Exp $	*/
/*	$NetBSD: msdosfs_denode.c,v 1.22 1996/10/13 04:16:31 christos Exp $	*/
d5 2
a6 2
 * Copyright (C) 1994, 1995 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995 TooLs GmbH.
d180 7
d189 2
a190 2
	 * address of "." entry. for root dir use cluster MSDOSFSROOT,
	 * offset MSDOSFSROOT_OFS
d237 3
d243 3
a245 1
	if (dirclust == MSDOSFSROOT && diroffset == MSDOSFSROOT_OFS) {
d253 2
d256 7
a262 2
		ldep->de_StartCluster = MSDOSFSROOT;
		ldep->de_FileSize = pmp->pm_rootdirsize * pmp->pm_BytesPerSec;
a288 3
	ldep->de_pmp = pmp;
	ldep->de_devvp = pmp->pm_devvp;
	ldep->de_refcnt = 1;
d299 1
a299 3
		if (ldep->de_StartCluster == MSDOSFSROOT)
			nvp->v_flag |= VROOT;
		else {
d359 1
a359 1
	if (DETOV(dep)->v_flag & VROOT) {
d465 1
a465 1
	if (chaintofree != 0 && !MSDOSFSEOF(chaintofree))
d487 1
a487 1
	if (DETOV(dep)->v_flag & VROOT)
@


1.9
log
@Fixed minor bug in msdosfs_hashget
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.8 1997/11/06 05:58:56 csapuntz Exp $	*/
d122 3
a124 2
	
	depp = &dehashtbl[DEHASH(dep->de_dev, dep->de_dirclust, dep->de_diroffset)];
d208 2
a209 1
	MALLOC(ldep, struct denode *, sizeof(struct denode), M_MSDOSFSNODE, M_WAITOK);
d211 1
@


1.8
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.7 1997/10/06 20:20:57 deraadt Exp $	*/
d96 1
a96 1

d106 2
d109 1
a109 1
				if (!vget(DETOV(dep), LK_EXCLUSIVE  | LK_INTERLOCK, p))
@


1.7
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.5 1997/10/04 19:08:12 deraadt Exp $	*/
d79 4
a82 2
void
msdosfs_init()
d85 1
d95 2
a96 1
	
d106 2
a107 6
				if (dep->de_flag & DE_LOCKED) {
					dep->de_flag |= DE_WANTED;
					sleep(dep, PINOD);
					break;
				}
				if (!vget(DETOV(dep), 1))
d169 1
d222 1
a222 1
	VOP_LOCK(nvp);
d566 1
d570 1
d584 2
a585 5
	if (dep->de_Name[0] == SLOT_DELETED) {
		if ((vp->v_flag & VXLOCK) == 0)
			vgone(vp);
		return (0);
	}
a587 9
#ifdef DIAGNOSTIC
	if (VOP_ISLOCKED(vp))
		panic("msdosfs_inactive: locked denode");
	if (curproc)
		dep->de_lockholder = curproc->p_pid;
	else
		dep->de_lockholder = -1;
#endif
	dep->de_flag |= DE_LOCKED;
d602 3
a604 1
	VOP_UNLOCK(vp);
d613 2
a614 2
	if (vp->v_usecount == 0 && dep->de_Name[0] == SLOT_DELETED)
		vgone(vp);
@


1.6
log
@VFS Lite2 Changes
@
text
@d79 2
a80 4
/*ARGSUSED*/
int
msdosfs_init(vfsp)
	struct vfsconf *vfsp;
a82 1
	return (0);
d92 1
a92 2
	struct proc *p = curproc; /* XXX */

d107 1
a107 1
				if (!vget(DETOV(dep), LK_EXCLUSIVE, p))
a168 1
	struct proc *p = curproc; /* XXX */
d221 1
a221 1
	vn_lock(nvp, LK_EXCLUSIVE | LK_RETRY, p);
a564 1
		struct proc *a_p;
a567 1
	struct proc *p = ap->a_p;
d611 1
a611 1
	VOP_UNLOCK(vp, 0, p);
@


1.5
log
@cleanup timestamp code for NT/Win95; khym@@bga.com
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.4 1997/03/02 18:01:54 millert Exp $	*/
d79 4
a82 2
void
msdosfs_init()
d85 1
d95 2
a96 1
	
d111 1
a111 1
				if (!vget(DETOV(dep), 1))
d173 1
d226 1
a226 1
	VOP_LOCK(nvp);
d570 1
d574 1
d618 1
a618 1
	VOP_UNLOCK(vp);
@


1.4
log
@Sync msdosfs with NetBSD sans const-ness.  NetSBD log messages:
    Fix panic on mkdir.
    Thanks to Dave Huang for finding the bug.
    Fixes a bug with allowed/forbidden characters in non-W95 filenames.
    Don't extend directory when nothing is written to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_denode.c,v 1.3 1996/02/29 10:46:51 niklas Exp $	*/
d244 1
a247 1
		ldep->de_ATime = ldep->de_CTime;
@


1.3
log
@From NetBSD: merge with 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: msdosfs_denode.c,v 1.19 1996/02/09 19:13:43 christos Exp $	*/
d172 1
a172 1
	       pmp, dirclust, diroffset, depp);
d299 1
a299 26
	int error;
	struct buf *bp;
	struct direntry *dirp;
	struct vnode *vp = DETOV(dep);

#ifdef MSDOSFS_DEBUG
	printf("deupdat(): dep %08x\n", dep);
#endif

	/* If the time stamp needs updating, do it now. */
	DE_TIMES(dep);

	/*
	 * If the modified bit is off, or this denode is from a readonly
	 * filesystem, or the denode represents an open but unlinked file
	 * then don't do anything. DOS directory entries that describe a
	 * directory do not ever get updated.  This is the way dos treats
	 * them.
	 */
	if ((dep->de_flag & DE_MODIFIED) == 0)
		return (0);

	dep->de_flag &= ~DE_MODIFIED;

	if (dep->de_Attributes & ATTR_DIRECTORY)
		panic("deupdat: directory");
d301 2
a302 28
	if (vp->v_mount->mnt_flag & MNT_RDONLY ||
	    dep->de_refcnt <= 0)
		return (0);

	/*
	 * Read in the cluster containing the directory entry we want to
	 * update.
	 */
	if ((error = readde(dep, &bp, &dirp)) != 0)
		return (error);

	/*
	 * Copy the directory entry out of the denode into the cluster it
	 * came from.
	 */
	DE_EXTERNALIZE(dirp, dep);

	/*
	 * Write the cluster back to disk.  If they asked for us to wait
	 * for the write to complete, then use bwrite() otherwise use
	 * bdwrite().
	 */
	error = 0;		/* note that error is 0 from above, but ... */
	if (waitfor)
		error = bwrite(bp);
	else
		bdwrite(bp);
	return (error);
@


1.2
log
@from netbsd (mostly by ws):
Win95 ignores case on lookup
Really don't generate long names when mounted with -s
Fix cookie handling
Don't forward credentials to bread, it makes nfs panic
(Of course, nfs shouldn't rely on the credentials not being referenced)
Don't give directory entry to deget, it could result in a deadlock
Use device blocks, not clusters for logical block numbers
Add support for Win'95 separate creation/modification/access timestamps
Re-introduce lowercase filenames for non-Win'95-filesystems
Fix thinko with block boundaries in directories
Don't overwrite dirclust, it's needed later on
Enable flock(2).
@
text
@d1 2
a2 1
/*	$NetBSD: msdosfs_denode.c,v 1.18 1995/11/29 15:08:38 ws Exp $	*/
d60 3
d75 5
a79 1
int
a81 1

d122 1
a122 1
	if (deq = *depp)
d135 1
a135 1
	if (deq = dep->de_next)
d164 1
a164 1
	extern int (**msdosfs_vnodeop_p)();
d187 2
a188 1
	if (ldep = msdosfs_hashget(pmp->pm_dev, dirclust, diroffset)) {
d198 3
a200 1
	if (error = getnewvnode(VT_MSDOSFS, pmp->pm_mountp, msdosfs_vnodeop_p, &nvp)) {
d253 2
a254 1
		if (error = readep(pmp, dirclust, diroffset, &bp, &direntptr))
d334 1
a334 1
	if (error = readde(dep, &bp, &dirp))
d415 3
a417 1
		if (error = pcbmap(dep, de_clcount(pmp, length) - 1, 0, &eofentry, 0)) {
d480 3
a482 2
		if (error = fatentry(FAT_GET_AND_SET, pmp, eofentry,
				     &chaintofree, CLUST_EOFE)) {
d537 2
a538 1
		if (error = extendfile(dep, count, NULL, NULL, DE_CLEAR)) {
a557 2
	struct denode **depp, *deq;

d573 3
a575 1
msdosfs_reclaim(ap)
d578 1
a578 2
	} */ *ap;
{
d611 3
a613 1
msdosfs_inactive(ap)
d616 1
a616 2
	} */ *ap;
{
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: msdosfs_denode.c,v 1.15 1995/09/09 19:38:03 ws Exp $	*/
d4 2
a5 2
 * Copyright (C) 1994 Wolfgang Solfrank.
 * Copyright (C) 1994 TooLs GmbH.
d58 1
a146 2
 * direntptr - address of the direntry structure of interest. If direntptr is
 *	       NULL, the block is read if necessary. 
d150 1
a150 1
deget(pmp, dirclust, diroffset, direntptr, depp)
a153 1
	struct direntry *direntptr;
d158 1
d164 2
a165 2
	printf("deget(pmp %08x, dirclust %d, diroffset %x, direntptr %x, depp %08x)\n",
	       pmp, dirclust, diroffset, direntptr, depp);
a168 12
	 * If dir entry is given and refers to a directory, convert to
	 * canonical form
	 */
	if (direntptr && (direntptr->deAttributes & ATTR_DIRECTORY)) {
		dirclust = getushort(direntptr->deStartCluster);
		if (dirclust == MSDOSFSROOT)
			diroffset = MSDOSFSROOT_OFS;
		else
			diroffset = 0;
	}

	/*
d233 2
a234 2
		ldep->de_Time = 0x0000;	/* 00:00:00	 */
		ldep->de_Date = (0 << DD_YEAR_SHIFT) | (1 << DD_MONTH_SHIFT)
d237 4
d243 2
a244 7
		bp = NULL;
		if (!direntptr) {
			error = readep(pmp, dirclust, diroffset, &bp,
				       &direntptr);
			if (error)
				return (error);
		}
d246 1
a246 2
		if (bp)
			brelse(bp);
d271 1
a271 1
				ldep->de_FileSize = size << pmp->pm_cnshift;
d412 1
a412 1
	fc_purge(dep, (length + pmp->pm_crbomask) >> pmp->pm_cnshift);
d430 1
d474 1
a474 1
		fc_setcache(dep, FC_LASTFC, (length - 1) >> pmp->pm_cnshift,
d508 1
a508 2
	 * Directories can only be extended by the superuser.
	 * Is this really important?
d510 2
a511 4
	if (dep->de_Attributes & ATTR_DIRECTORY) {
		if (error = suser(cred, (u_short *)0))
			return (error);
	}
d642 1
a642 1
	if (dep->de_refcnt <= 0 && (vp->v_mount->mnt_flag & MNT_RDONLY) == 0)
d644 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
