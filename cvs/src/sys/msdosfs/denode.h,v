head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.26.0.12
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.21.0.10
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.12
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.8
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.08.30.19.47.23;	author sf;	state Exp;
branches;
next	1.29;
commitid	NRpgyTuO0n9X0z7e;

1.29
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.28;
commitid	wHLNY5GFNXJSFYaC;

1.28
date	2016.01.13.10.00.55;	author mpi;	state Exp;
branches;
next	1.27;
commitid	ru9jHQwQX09BC5Bw;

1.27
date	2015.10.23.10.45.31;	author krw;	state Exp;
branches;
next	1.26;
commitid	SncnQqnXMdpzMlro;

1.26
date	2013.06.11.16.42.16;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2012.09.06.19.06.04;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2012.04.05.09.26.40;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.17.19.27.07;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.16.20.26.39;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.02.02.04.21;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.18.15.05.33;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.01.14.24.33;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.14.04.05.05;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.12.21.04.15;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.14.21.26.10;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.06.23.02.15.24;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.23.14.42.38;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	99.11.17.09.27.22;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	98.01.11.20.39.04;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.05.58.55;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.04.19.08.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.02.18.01.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.10.46.45;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.19.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.32.59;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.49.24;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.30.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Revert "Implement VFS read clustering for MSDOSFS"

This caused garbage to be written instead of blocks of 0-bytes if a
file is extended by seeking past the end. This happens for example
when extracting files containing lots of 0-bytes with tar.

ok mpi@@

Details of original commit:

  msdosfs_vnops.c revision 1.105
  denode.h revision 1.28
  date: 2016/01/13 10:00:55;  author: mpi;  commitid: ru9jHQwQX09BC5Bw;

  Implement VFS read clustering for MSDOSFS.

  The logic used in msdosfs_bmap() to loop calling pcbmap() comes from
  FreeBSD and is not really efficient but it is good enough since it is
  only called when generating I/O.

  With this diff I get a 100% improvement when reading big files from a
  crappy USB stick.

  With this and bread_cluster(9) modified to not re-fetch B_CACHED buffers,
  reading large contiguous files with chunk sizes of MAXPHYS is almost as
  fast as physio(9) on the same device.

  For a 'real world' example, when copying music files from a USB stick I
  see a speed jump from 15MB/s on -current to 24Mb/s with this diff.

  While here rename some 'lbn' variables into 'cn' to better reflect what
  we're dealing with.

  Tested by Mathieu, with support from deraadt@@
@
text
@/*	$OpenBSD: denode.h,v 1.29 2016/06/19 11:54:33 natano Exp $	*/
/*	$NetBSD: denode.h,v 1.24 1997/10/17 11:23:39 ws Exp $	*/

/*-
 * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995, 1997 TooLs GmbH.
 * All rights reserved.
 * Original code by Paul Popelka (paulp@@uts.amdahl.com) (see below).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Written by Paul Popelka (paulp@@uts.amdahl.com)
 *
 * You can do anything you want with this software, just don't say you wrote
 * it, and don't remove this notice.
 *
 * This software is provided "as is".
 *
 * The author supplies this software to be publicly redistributed on the
 * understanding that the author is not responsible for the correct
 * functioning of this software in any circumstances and is not liable for
 * any damages caused by this software.
 *
 * October 1992
 */

/*
 * This is the pc filesystem specific portion of the vnode structure.
 *
 * To describe a file uniquely the de_dirclust, de_diroffset, and
 * de_StartCluster fields are used.
 *
 * de_dirclust contains the cluster number of the directory cluster
 *	containing the entry for a file or directory.
 * de_diroffset is the index into the cluster for the entry describing
 *	a file or directory.
 * de_StartCluster is the number of the first cluster of the file or directory.
 *
 * Now to describe the quirks of the pc filesystem.
 * - Clusters 0 and 1 are reserved.
 * - The first allocatable cluster is 2.
 * - The root directory is of fixed size and all blocks that make it up
 *   are contiguous.
 * - Cluster 0 refers to the root directory when it is found in the
 *   startcluster field of a directory entry that points to another directory.
 * - Cluster 0 implies a 0 length file when found in the start cluster field
 *   of a directory entry that points to a file.
 * - You can't use the cluster number 0 to derive the address of the root
 *   directory.
 * - Multiple directory entries can point to a directory. The entry in the
 *   parent directory points to a child directory.  Any directories in the
 *   child directory contain a ".." entry that points back to the parent.
 *   The child directory itself contains a "." entry that points to itself.
 * - The root directory does not contain a "." or ".." entry.
 * - Directory entries for directories are never changed once they are created
 *   (except when removed).  The size stays 0, and the last modification time
 *   is never changed.  This is because so many directory entries can point to
 *   the physical clusters that make up a directory.  It would lead to an
 *   update nightmare.
 * - The length field in a directory entry pointing to a directory contains 0
 *   (always).  The only way to find the end of a directory is to follow the
 *   cluster chain until the "last cluster" marker is found.
 *
 * My extensions to make this house of cards work.  These apply only to the in
 * memory copy of the directory entry.
 * - A reference count for each denode will be kept since dos doesn't keep such
 *   things.
 */

/*
 * Internal pseudo-offset for (nonexistent) directory entry for the root
 * dir in the root dir
 */
#define	MSDOSFSROOT_OFS	0x1fffffff

/*
 * The fat cache structure. fc_fsrcn is the filesystem relative cluster
 * number that corresponds to the file relative cluster number in this
 * structure (fc_frcn).
 */
struct fatcache {
	uint32_t fc_frcn;		/* file relative cluster number */
	uint32_t fc_fsrcn;	/* filesystem relative cluster number */
};

/*
 * The fat entry cache as it stands helps make extending files a "quick"
 * operation by avoiding having to scan the fat to discover the last
 * cluster of the file. The cache also helps sequential reads by
 * remembering the last cluster read from the file.  This also prevents us
 * from having to rescan the fat to find the next cluster to read.  This
 * cache is probably pretty worthless if a file is opened by multiple
 * processes.
 */
#define	FC_SIZE		3	/* number of entries in the cache */
#define	FC_LASTMAP	0	/* entry the last call to pcbmap() resolved
				 * to */
#define	FC_LASTFC	1	/* entry for the last cluster in the file */
#define	FC_OLASTFC	2	/* entry for the previous last cluster */

#define	FCE_EMPTY	0xffffffff	/* doesn't represent an actual cluster # */

/*
 * Set a slot in the fat cache.
 */
#define	fc_setcache(dep, slot, frcn, fsrcn) \
	(dep)->de_fc[slot].fc_frcn = frcn; \
	(dep)->de_fc[slot].fc_fsrcn = fsrcn;

/*
 * This is the in memory variant of a dos directory entry.  It is usually
 * contained within a vnode.
 */
struct denode {
	struct denode *de_next;	/* Hash chain forward */
	struct denode **de_prev; /* Hash chain back */
	struct vnode *de_vnode;	/* addr of vnode we are part of */
	struct vnode *de_devvp;	/* vnode of blk dev we live on */
	uint32_t de_flag;		/* flag bits */
	dev_t de_dev;		/* device where direntry lives */
	daddr_t de_lastr;
	uint32_t de_dirclust;	/* cluster of the directory file containing this entry */
	uint32_t de_diroffset;	/* offset of this entry in the directory cluster */
	uint32_t de_fndoffset;	/* offset of found dir entry */
	int de_fndcnt;		/* number of slots before de_fndoffset */
	long de_refcnt;		/* reference count */
	struct msdosfsmount *de_pmp;	/* addr of our mount struct */
	struct lockf *de_lockf;	/* byte level lock list */
	struct rrwlock de_lock;	/* denode lock */
	u_char de_Name[11];	/* name, from DOS directory entry */
	u_char de_Attributes;	/* attributes, from directory entry */
	u_char de_CTimeHundredth; /* creation time, 1/100th of a sec */
	u_short de_CTime;	/* creation time */
	u_short de_CDate;	/* creation date */
	u_short de_ADate;	/* access date */
	u_short de_MTime;	/* modification time */
	u_short de_MDate;	/* modification date */
	uint32_t de_StartCluster; /* starting cluster of file */
	uint32_t de_FileSize;	/* size of file in bytes */
	struct fatcache de_fc[FC_SIZE];	/* fat cache */
};

/*
 * Values for the de_flag field of the denode.
 */
#define	DE_UPDATE	0x0004	/* Modification time update request. */
#define	DE_CREATE	0x0008	/* Creation time update */
#define	DE_ACCESS	0x0010	/* Access time update */
#define	DE_MODIFIED	0x0020	/* Denode has been modified. */
#define	DE_RENAME	0x0040	/* Denode is in the process of being renamed */

/*
 * Maximum filename length in Win95
 * Note: Must be < sizeof(dirent.d_name)
 */
#define	WIN_MAXLEN	255

/* Maximum size of a file on a FAT filesystem */
#define MSDOSFS_FILESIZE_MAX	0xFFFFFFFFLL

/*
 * Transfer directory entries between internal and external form.
 * dep is a struct denode * (internal form),
 * dp is a struct direntry * (external form).
 */
#define DE_INTERNALIZE32(dep, dp)                      \
        ((dep)->de_StartCluster |= getushort((dp)->deHighClust) << 16)
#define DE_INTERNALIZE(dep, dp)			\
	(bcopy((dp)->deName, (dep)->de_Name, 8),	\
	 bcopy((dp)->deExtension, (dep)->de_Name + 8, 3), \
	 (dep)->de_Attributes = (dp)->deAttributes,	\
	 (dep)->de_CTimeHundredth = (dp)->deCTimeHundredth, \
	 (dep)->de_CTime = getushort((dp)->deCTime),	\
	 (dep)->de_CDate = getushort((dp)->deCDate),	\
	 (dep)->de_ADate = getushort((dp)->deADate),	\
	 (dep)->de_MTime = getushort((dp)->deMTime),	\
	 (dep)->de_MDate = getushort((dp)->deMDate),	\
	 (dep)->de_StartCluster = getushort((dp)->deStartCluster), \
	 (dep)->de_FileSize = getulong((dp)->deFileSize), \
	 (FAT32((dep)->de_pmp) ? DE_INTERNALIZE32((dep), (dp)) : 0))

#define DE_EXTERNALIZE(dp, dep)				\
	(bcopy((dep)->de_Name, (dp)->deName, 8),	\
	 bcopy((dep)->de_Name + 8, (dp)->deExtension, 3), \
	 (dp)->deAttributes = (dep)->de_Attributes,	\
	 (dp)->deLowerCase = CASE_LOWER_BASE | CASE_LOWER_EXT,	\
	 (dp)->deCTimeHundredth = (dep)->de_CTimeHundredth, \
	 putushort((dp)->deCTime, (dep)->de_CTime),	\
	 putushort((dp)->deCDate, (dep)->de_CDate),	\
	 putushort((dp)->deADate, (dep)->de_ADate),	\
	 putushort((dp)->deMTime, (dep)->de_MTime),	\
	 putushort((dp)->deMDate, (dep)->de_MDate),	\
	 putushort((dp)->deStartCluster, (dep)->de_StartCluster), \
	 putulong((dp)->deFileSize, \
	     ((dep)->de_Attributes & ATTR_DIRECTORY) ? 0 : (dep)->de_FileSize),\
	 putushort((dp)->deHighClust, \
	     FAT32((dep)->de_pmp) ? (dep)->de_StartCluster >> 16 : 0))

#define	de_forw		de_chain[0]
#define	de_back		de_chain[1]

#define	VTODE(vp)	((struct denode *)(vp)->v_data)
#define	DETOV(de)	((de)->de_vnode)

#define	DETIMES(dep, acc, mod, cre) \
	if ((dep)->de_flag & (DE_UPDATE | DE_CREATE | DE_ACCESS)) { \
		(dep)->de_flag |= DE_MODIFIED; \
		if ((dep)->de_flag & DE_UPDATE) { \
			unix2dostime((mod), &(dep)->de_MDate, &(dep)->de_MTime, NULL); \
			(dep)->de_Attributes |= ATTR_ARCHIVE; \
		} \
		if (!((dep)->de_pmp->pm_flags & MSDOSFSMNT_NOWIN95)) { \
			if ((dep)->de_flag & DE_ACCESS) \
				unix2dostime((acc), &(dep)->de_ADate, NULL, NULL); \
			if ((dep)->de_flag & DE_CREATE) \
				unix2dostime((cre), &(dep)->de_CDate, &(dep)->de_CTime, &(dep)->de_CTimeHundredth); \
		} \
		(dep)->de_flag &= ~(DE_UPDATE | DE_CREATE | DE_ACCESS); \
	}

/*
 * This overlays the fid structure (see mount.h)
 */
struct defid {
	u_short defid_len;	/* length of structure */
	u_short defid_pad;	/* force long alignment */

	uint32_t defid_dirclust;	/* cluster this dir entry came from */
	uint32_t defid_dirofs;	/* offset of entry within the cluster */
#if 0
	uint32_t	defid_gen;	/* generation number */
#endif
};


#ifdef _KERNEL
/*
 * Prototypes for MSDOSFS vnode operations
 */
int	msdosfs_lookup(void *);
int	msdosfs_create(void *);
int	msdosfs_mknod(void *);
int	msdosfs_open(void *);
int	msdosfs_close(void *);
int	msdosfs_access(void *);
int	msdosfs_getattr(void *);
int	msdosfs_setattr(void *);
int	msdosfs_read(void *);
int	msdosfs_write(void *);
int	msdosfs_ioctl(void *);
int	msdosfs_poll(void *);
int	msdosfs_fsync(void *);
int	msdosfs_remove(void *);
int	msdosfs_link(void *);
int	msdosfs_rename(void *);
int	msdosfs_mkdir(void *);
int	msdosfs_rmdir(void *);
int	msdosfs_symlink(void *);
int	msdosfs_readdir(void *);
int	msdosfs_readlink(void *);
int	msdosfs_inactive(void *);
int	msdosfs_reclaim(void *);
int	msdosfs_lock(void *);
int	msdosfs_unlock(void *);
int	msdosfs_bmap(void *);
int	msdosfs_strategy(void *);
int	msdosfs_print(void *);
int	msdosfs_islocked(void *);
int	msdosfs_advlock(void *);
int	msdosfs_pathconf(void *);

/*
 * Internal service routine prototypes.
 */
int createde(struct denode *, struct denode *, struct denode **, struct componentname *);
int deextend(struct denode *, uint32_t, struct ucred *);
int deget(struct msdosfsmount *, uint32_t, uint32_t, struct denode **);
int detrunc(struct denode *, uint32_t, int, struct ucred *, struct proc *);
int deupdat(struct denode *, int);
int doscheckpath(struct denode *, struct denode *);
int dosdirempty(struct denode *);
int readde(struct denode *, struct buf **, struct direntry **);
int readep(struct msdosfsmount *, uint32_t, uint32_t, struct buf **, struct direntry **);
void reinsert(struct denode *);
int removede(struct denode *, struct denode *);
int uniqdosname(struct denode *, struct componentname *, u_char *);
int findwin95(struct denode *);
#endif	/* _KERNEL */
@


1.29
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.28 2016/01/13 10:00:55 mpi Exp $	*/
d145 1
@


1.28
log
@Implement VFS read clustering for MSDOSFS.

The logic used in msdosfs_bmap() to loop calling pcbmap() comes from
FreeBSD and is not really efficient but it is good enough since it is
only called when generating I/O.

With this diff I get a 100% improvement when reading big files from a
crappy USB stick.

With this and bread_cluster(9) modified to not re-fetch B_CACHED buffers,
reading large contiguous files with chunk sizes of MAXPHYS is almost as
fast as physio(9) on the same device.

For a 'real world' example, when copying music files from a USB stick I
see a speed jump from 15MB/s on -current to 24Mb/s with this diff.

While here rename some 'lbn' variables into 'cn' to better reflect what
we're dealing with.

Tested by Mathieu, with support from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.27 2015/10/23 10:45:31 krw Exp $	*/
d152 1
a152 1
	struct lock de_lock;    /* denode lock */
@


1.27
log
@Nuke a bunch of leading/embedded/trailing whitespace so the code can be
read without generating spurious headaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.26 2013/06/11 16:42:16 deraadt Exp $	*/
a144 1
	daddr_t de_lastr;
@


1.26
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.25 2012/09/06 19:06:04 krw Exp $	*/
d37 1
a37 1
 * 
d40 1
a40 1
 * 
d42 1
a42 1
 * 
d47 1
a47 1
 * 
@


1.25
log
@Remove the need to occasionally treat dos file names as strings by
using "%.11s" to print them out. Make all dos file names 11 byte
arrays and nuke the attempt to put '\0' at the 12th position of
such an array.

Fixes 'panic: smashed stack in msdosfs_rename.c' reported by
MERHIGI Marcus via tech@@.

Tested by MERHIGI Marcus. Suggestions and ok tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.24 2012/04/05 09:26:40 mikeb Exp $	*/
d145 1
a145 1
	daddr64_t de_lastr;
@


1.24
log
@As it was made evident by Olaf 'Rhialto' Seibert in the NetBSD PR 34583,
caching the last cluster in the file before extending it considerably
speeds up further lookups.  As a consequence this keeps write speed from
gradually decreasing and provides a measurable (up to 2x) performance
increase.  Prompted by the diff from Alexander Polakov, ok miod, krw.
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.23 2010/07/17 19:27:07 guenther Exp $	*/
d154 1
a154 1
	u_char de_Name[12];	/* name, from DOS directory entry */
@


1.23
log
@Move some macros in <msdosfs/denode.h> to outside the #ifdef _KERNEL
so that libkvm doesn't need to define that, thereby avoiding some warnings.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.22 2010/05/16 20:26:39 nicm Exp $	*/
d119 1
a119 1
#define	FC_SIZE		2	/* number of entries in the cache */
d123 1
@


1.22
log
@Make the DE_INTERNALIZE/EXTERNALIZE macros copy to/from the struct
direntry deName[8]/deExtension[3] buffers separately rather than in one
11 byte copy. Makes gcc4 -Wbounded happy.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.21 2007/06/02 02:04:21 deraadt Exp $	*/
a224 2
#ifdef _KERNEL

d258 2
@


1.21
log
@convert all daddr_t types to either daddr64_t or uint32_t or other such
things based on their use.  ok with fixes from tom, tested by grange too
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.20 2007/03/18 15:05:33 mickey Exp $	*/
d192 2
a193 1
	(bcopy((dp)->deName, (dep)->de_Name, 11),	\
d206 2
a207 1
	(bcopy((dep)->de_Name, (dp)->deName, 11),	\
@


1.20
log
@get rid of noop vop_reallocblks; pedro@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.19 2007/01/16 17:52:18 thib Exp $	*/
d144 1
a144 1
	daddr_t de_lastr;
@


1.19
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.18 2005/03/01 14:24:33 tom Exp $	*/
a290 1
int	msdosfs_reallocblks(void *);
@


1.18
log
@The maximum file size on MS-DOS filesystems is 4 GB - 1 byte, so
don't bother trying to write files bigger than this.  Just return
EFBIG to caller, rather than panic()ing later.

Closes PR 4090.  Assistance from otto@@, tested by OP and moritz@@;
thanks.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.17 2004/05/14 04:05:05 tedu Exp $	*/
a270 6
#ifdef NFSSERVER
int	lease_check(void *);
#define	msdosfs_lease_check lease_check
#else
#define	msdosfs_lease_check nullop
#endif
@


1.17
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.15 2003/09/23 16:51:13 millert Exp $	*/
d180 3
@


1.16
log
@32 bit ints are uint32_t, not u_long.  works on 64bit now.  ok deraadt@@
@
text
@@


1.15
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.14 2003/08/14 21:26:10 tedu Exp $	*/
d106 2
a107 2
	u_long fc_frcn;		/* file relative cluster number */
	u_long fc_fsrcn;	/* filesystem relative cluster number */
d142 1
a142 1
	u_long de_flag;		/* flag bits */
d145 3
a147 3
	u_long de_dirclust;	/* cluster of the directory file containing this entry */
	u_long de_diroffset;	/* offset of this entry in the directory cluster */
	u_long de_fndoffset;	/* offset of found dir entry */
d161 2
a162 2
	u_long de_StartCluster; /* starting cluster of file */
	u_long de_FileSize;	/* size of file in bytes */
d248 2
a249 2
	u_long defid_dirclust;	/* cluster this dir entry came from */
	u_long defid_dirofs;	/* offset of entry within the cluster */
d251 1
a251 1
	u_long	defid_gen;	/* generation number */
d301 3
a303 3
int deextend(struct denode *, u_long, struct ucred *);
int deget(struct msdosfsmount *, u_long, u_long, struct denode **);
int detrunc(struct denode *, u_long, int, struct ucred *, struct proc *);
d308 1
a308 1
int readep(struct msdosfsmount *, u_long, u_long, struct buf **, struct direntry **);
@


1.14
log
@don't write grabage in unused direntry field.  newer windows versions
don't like it.  pr3400
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.13 2002/03/14 01:27:09 millert Exp $	*/
d275 1
a275 1
int	msdosfs_select(void *);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.12 2001/12/19 08:58:06 art Exp $	*/
a200 2
#define DE_EXTERNALIZE32(dp, dep)                     \
         putushort((dp)->deHighClust, (dep)->de_StartCluster >> 16)
d214 2
a215 1
	 (FAT32((dep)->de_pmp) ? DE_EXTERNALIZE32((dp), (dep)) : 0))
@


1.12
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.10 2001/06/23 02:15:24 csapuntz Exp $	*/
d259 10
a268 10
int	msdosfs_lookup		__P((void *));
int	msdosfs_create		__P((void *));
int	msdosfs_mknod		__P((void *));
int	msdosfs_open		__P((void *));
int	msdosfs_close		__P((void *));
int	msdosfs_access		__P((void *));
int	msdosfs_getattr		__P((void *));
int	msdosfs_setattr		__P((void *));
int	msdosfs_read		__P((void *));
int	msdosfs_write		__P((void *));
d270 1
a270 1
int	lease_check		__P((void *));
d275 22
a296 22
int	msdosfs_ioctl		__P((void *));
int	msdosfs_select		__P((void *));
int	msdosfs_fsync		__P((void *));
int	msdosfs_remove		__P((void *));
int	msdosfs_link		__P((void *));
int	msdosfs_rename		__P((void *));
int	msdosfs_mkdir		__P((void *));
int	msdosfs_rmdir		__P((void *));
int	msdosfs_symlink		__P((void *));
int	msdosfs_readdir		__P((void *));
int	msdosfs_readlink	__P((void *));
int	msdosfs_inactive	__P((void *));
int	msdosfs_reclaim		__P((void *));
int	msdosfs_lock		__P((void *));
int	msdosfs_unlock		__P((void *));
int	msdosfs_bmap		__P((void *));
int	msdosfs_strategy	__P((void *));
int	msdosfs_print		__P((void *));
int	msdosfs_islocked	__P((void *));
int	msdosfs_advlock		__P((void *));
int	msdosfs_reallocblks	__P((void *));
int	msdosfs_pathconf	__P((void *));
d301 13
a313 13
int createde __P((struct denode *, struct denode *, struct denode **, struct componentname *));
int deextend __P((struct denode *, u_long, struct ucred *));
int deget __P((struct msdosfsmount *, u_long, u_long, struct denode **));
int detrunc __P((struct denode *, u_long, int, struct ucred *, struct proc *));
int deupdat __P((struct denode *, int));
int doscheckpath __P((struct denode *, struct denode *));
int dosdirempty __P((struct denode *));
int readde __P((struct denode *, struct buf **, struct direntry **));
int readep __P((struct msdosfsmount *, u_long, u_long, struct buf **, struct direntry **));
void reinsert __P((struct denode *));
int removede __P((struct denode *, struct denode *));
int uniqdosname __P((struct denode *, struct componentname *, u_char *));
int findwin95 __P((struct denode *));
@


1.11
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@a93 2
#include <miscfs/genfs/genfs.h>

a137 1
	struct genfs_node de_gnode;
a313 1
int msdosfs_gop_alloc __P((struct vnode *, off_t, off_t, int, struct ucred *));
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.11 2001/12/10 04:45:31 art Exp $	*/
d262 10
a271 10
int	msdosfs_lookup(void *);
int	msdosfs_create(void *);
int	msdosfs_mknod(void *);
int	msdosfs_open(void *);
int	msdosfs_close(void *);
int	msdosfs_access(void *);
int	msdosfs_getattr(void *);
int	msdosfs_setattr(void *);
int	msdosfs_read(void *);
int	msdosfs_write(void *);
d273 1
a273 1
int	lease_check(void *);
d278 22
a299 22
int	msdosfs_ioctl(void *);
int	msdosfs_select(void *);
int	msdosfs_fsync(void *);
int	msdosfs_remove(void *);
int	msdosfs_link(void *);
int	msdosfs_rename(void *);
int	msdosfs_mkdir(void *);
int	msdosfs_rmdir(void *);
int	msdosfs_symlink(void *);
int	msdosfs_readdir(void *);
int	msdosfs_readlink(void *);
int	msdosfs_inactive(void *);
int	msdosfs_reclaim(void *);
int	msdosfs_lock(void *);
int	msdosfs_unlock(void *);
int	msdosfs_bmap(void *);
int	msdosfs_strategy(void *);
int	msdosfs_print(void *);
int	msdosfs_islocked(void *);
int	msdosfs_advlock(void *);
int	msdosfs_reallocblks(void *);
int	msdosfs_pathconf(void *);
d304 14
a317 14
int createde(struct denode *, struct denode *, struct denode **, struct componentname *);
int deextend(struct denode *, u_long, struct ucred *);
int deget(struct msdosfsmount *, u_long, u_long, struct denode **);
int detrunc(struct denode *, u_long, int, struct ucred *, struct proc *);
int deupdat(struct denode *, int);
int doscheckpath(struct denode *, struct denode *);
int dosdirempty(struct denode *);
int readde(struct denode *, struct buf **, struct direntry **);
int readep(struct msdosfsmount *, u_long, u_long, struct buf **, struct direntry **);
void reinsert(struct denode *);
int removede(struct denode *, struct denode *);
int uniqdosname(struct denode *, struct componentname *, u_char *);
int findwin95(struct denode *);
int msdosfs_gop_alloc(struct vnode *, off_t, off_t, int, struct ucred *);
@


1.10
log
@Get rid of several vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.9 2001/02/23 14:42:38 csapuntz Exp $	*/
d94 2
d140 1
d317 1
@


1.9
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.8 1999/11/17 09:27:22 art Exp $	*/
a276 1
int	msdosfs_mmap		__P((void *));
a277 1
int	msdosfs_seek		__P((void *));
a296 1
int	msdosfs_update		__P((void *));
@


1.8
log
@There is no msdosfs_abortop. Remove prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.7 1998/01/11 20:39:04 provos Exp $	*/
d144 1
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.9 2001/02/23 14:42:38 csapuntz Exp $	*/
a143 1
	daddr_t de_lastr;
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.8.2.1 2001/05/14 22:32:59 niklas Exp $	*/
d277 1
d279 1
d299 1
@


1.8.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d259 10
a268 10
int	msdosfs_lookup(void *);
int	msdosfs_create(void *);
int	msdosfs_mknod(void *);
int	msdosfs_open(void *);
int	msdosfs_close(void *);
int	msdosfs_access(void *);
int	msdosfs_getattr(void *);
int	msdosfs_setattr(void *);
int	msdosfs_read(void *);
int	msdosfs_write(void *);
d270 1
a270 1
int	lease_check(void *);
d275 22
a296 22
int	msdosfs_ioctl(void *);
int	msdosfs_select(void *);
int	msdosfs_fsync(void *);
int	msdosfs_remove(void *);
int	msdosfs_link(void *);
int	msdosfs_rename(void *);
int	msdosfs_mkdir(void *);
int	msdosfs_rmdir(void *);
int	msdosfs_symlink(void *);
int	msdosfs_readdir(void *);
int	msdosfs_readlink(void *);
int	msdosfs_inactive(void *);
int	msdosfs_reclaim(void *);
int	msdosfs_lock(void *);
int	msdosfs_unlock(void *);
int	msdosfs_bmap(void *);
int	msdosfs_strategy(void *);
int	msdosfs_print(void *);
int	msdosfs_islocked(void *);
int	msdosfs_advlock(void *);
int	msdosfs_reallocblks(void *);
int	msdosfs_pathconf(void *);
d301 13
a313 13
int createde(struct denode *, struct denode *, struct denode **, struct componentname *);
int deextend(struct denode *, u_long, struct ucred *);
int deget(struct msdosfsmount *, u_long, u_long, struct denode **);
int detrunc(struct denode *, u_long, int, struct ucred *, struct proc *);
int deupdat(struct denode *, int);
int doscheckpath(struct denode *, struct denode *);
int dosdirempty(struct denode *);
int readde(struct denode *, struct buf **, struct direntry **);
int readep(struct msdosfsmount *, u_long, u_long, struct buf **, struct direntry **);
void reinsert(struct denode *);
int removede(struct denode *, struct denode *);
int uniqdosname(struct denode *, struct componentname *, u_char *);
int findwin95(struct denode *);
@


1.8.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d201 2
d216 1
a216 2
	 putushort((dp)->deHighClust, \
	     FAT32((dep)->de_pmp) ? (dep)->de_StartCluster >> 16 : 0))
d276 1
a276 1
int	msdosfs_poll(void *);
@


1.8.2.5
log
@Merge with the trunk
@
text
@d106 2
a107 2
	uint32_t fc_frcn;		/* file relative cluster number */
	uint32_t fc_fsrcn;	/* filesystem relative cluster number */
d142 1
a142 1
	uint32_t de_flag;		/* flag bits */
d145 3
a147 3
	uint32_t de_dirclust;	/* cluster of the directory file containing this entry */
	uint32_t de_diroffset;	/* offset of this entry in the directory cluster */
	uint32_t de_fndoffset;	/* offset of found dir entry */
d161 2
a162 2
	uint32_t de_StartCluster; /* starting cluster of file */
	uint32_t de_FileSize;	/* size of file in bytes */
d248 2
a249 2
	uint32_t defid_dirclust;	/* cluster this dir entry came from */
	uint32_t defid_dirofs;	/* offset of entry within the cluster */
d251 1
a251 1
	uint32_t	defid_gen;	/* generation number */
d301 3
a303 3
int deextend(struct denode *, uint32_t, struct ucred *);
int deget(struct msdosfsmount *, uint32_t, uint32_t, struct denode **);
int detrunc(struct denode *, uint32_t, int, struct ucred *, struct proc *);
d308 1
a308 1
int readep(struct msdosfsmount *, uint32_t, uint32_t, struct buf **, struct direntry **);
@


1.7
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.6 1997/11/06 05:58:55 csapuntz Exp $	*/
a286 1
int	msdosfs_abortop		__P((void *));
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 2
a2 2
/*	$OpenBSD: denode.h,v 1.5 1997/10/04 19:08:10 deraadt Exp $	*/
/*	$NetBSD: denode.h,v 1.20 1996/02/09 19:13:39 christos Exp $	*/
d5 2
a6 2
 * Copyright (C) 1994, 1995 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995 TooLs GmbH.
d106 2
a107 2
	u_short fc_frcn;	/* file relative cluster number */
	u_short fc_fsrcn;	/* filesystem relative cluster number */
d124 1
a124 1
#define	FCE_EMPTY	0xffff	/* doesn't represent an actual cluster # */
d160 1
a160 1
	u_short de_StartCluster; /* starting cluster of file */
d185 2
d197 2
a198 1
	 (dep)->de_FileSize = getulong((dp)->deFileSize))
d200 2
a209 2
	 (dp)->deReserved[0] = 0,			\
	 (dp)->deReserved[1] = 0,			\
d214 2
a215 1
	     ((dep)->de_Attributes & ATTR_DIRECTORY) ? 0 : (dep)->de_FileSize))
d229 1
a229 1
			unix2dostime((mod), &(dep)->de_MDate, &(dep)->de_MTime); \
d234 3
a236 5
				unix2dostime((acc), &(dep)->de_ADate, NULL); \
			if ((dep)->de_flag & DE_CREATE) { \
				unix2dostime((cre), &(dep)->de_CDate, &(dep)->de_CTime); \
				(dep)->de_CTimeHundredth = ((cre)->tv_sec & 1 ? 100 : 0) + (cre)->tv_nsec / 10000000; \
			} \
@


1.5
log
@cleanup timestamp code for NT/Win95; khym@@bga.com
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.4 1997/03/02 18:01:50 millert Exp $	*/
d151 1
a151 2
	pid_t de_lockholder;	/* current lock holder */
	pid_t de_lockwaiter;	/* lock wanter */
a167 2
#define	DE_LOCKED	0x0001	/* Denode lock. */
#define	DE_WANTED	0x0002	/* Denode is wanted by a process. */
@


1.4
log
@Sync msdosfs with NetBSD sans const-ness.  NetSBD log messages:
    Fix panic on mkdir.
    Thanks to Dave Huang for finding the bug.
    Fixes a bug with allowed/forbidden characters in non-W95 filenames.
    Don't extend directory when nothing is written to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: denode.h,v 1.3 1996/02/29 10:46:45 niklas Exp $	*/
d155 1
a158 1
	u_short de_ATime;	/* access time */
d191 1
a193 1
	 (dep)->de_ATime = getushort((dp)->deATime),	\
d203 2
a206 1
	 putushort((dp)->deATime, (dep)->de_ATime),	\
d208 2
d233 2
a234 2
				unix2dostime((acc), &(dep)->de_ADate, &(dep)->de_ATime); \
			if ((dep)->de_flag & DE_CREATE) \
d236 2
@


1.3
log
@From NetBSD: merge with 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d221 1
a221 1
#define	DE_TIMES(dep) \
d223 10
a232 13
		if (((dep)->de_Attributes & ATTR_DIRECTORY) == 0) { \
			if ((dep)->de_pmp->pm_flags & MSDOSFSMNT_NOWIN95 \
			    || (dep)->de_flag & DE_UPDATE) { \
				unix2dostime(NULL, &(dep)->de_MDate, &(dep)->de_MTime); \
				(dep)->de_Attributes |= ATTR_ARCHIVE; \
			} \
			if (!((dep)->de_pmp->pm_flags & MSDOSFSMNT_NOWIN95)) { \
				if ((dep)->de_flag & DE_ACCESS) \
					unix2dostime(NULL, &(dep)->de_ADate, &(dep)->de_ATime); \
				if ((dep)->de_flag & DE_CREATE) \
					unix2dostime(NULL, &(dep)->de_CDate, &(dep)->de_CTime); \
			} \
			(dep)->de_flag |= DE_MODIFIED; \
d295 1
@


1.2
log
@from netbsd (mostly by ws):
Win95 ignores case on lookup
Really don't generate long names when mounted with -s
Fix cookie handling
Don't forward credentials to bread, it makes nfs panic
(Of course, nfs shouldn't rely on the credentials not being referenced)
Don't give directory entry to deget, it could result in a deadlock
Use device blocks, not clusters for logical block numbers
Add support for Win'95 separate creation/modification/access timestamps
Re-introduce lowercase filenames for non-Win'95-filesystems
Fix thinko with block boundaries in directories
Don't overwrite dirclust, it's needed later on
Enable flock(2).
@
text
@d1 2
a2 1
/*	$NetBSD: denode.h,v 1.19 1995/11/29 15:08:32 ws Exp $	*/
d249 3
a251 2

	/* u_long	defid_gen;	/* generation number */
d257 10
a266 10
int	msdosfs_lookup __P((struct vop_lookup_args *));
int	msdosfs_create __P((struct vop_create_args *));
int	msdosfs_mknod __P((struct vop_mknod_args *));
int	msdosfs_open __P((struct vop_open_args *));
int	msdosfs_close __P((struct vop_close_args *));
int	msdosfs_access __P((struct vop_access_args *));
int	msdosfs_getattr __P((struct vop_getattr_args *));
int	msdosfs_setattr __P((struct vop_setattr_args *));
int	msdosfs_read __P((struct vop_read_args *));
int	msdosfs_write __P((struct vop_write_args *));
d268 1
a268 1
int	lease_check __P((struct vop_lease_args *));
d271 1
a271 1
#define	msdosfs_lease_check ((int (*) __P((struct vop_lease_args *)))nullop)
d273 25
a297 24
int	msdosfs_ioctl __P((struct vop_ioctl_args *));
int	msdosfs_select __P((struct vop_select_args *));
int	msdosfs_mmap __P((struct vop_mmap_args *));
int	msdosfs_fsync __P((struct vop_fsync_args *));
int	msdosfs_seek __P((struct vop_seek_args *));
int	msdosfs_remove __P((struct vop_remove_args *));
int	msdosfs_link __P((struct vop_link_args *));
int	msdosfs_rename __P((struct vop_rename_args *));
int	msdosfs_mkdir __P((struct vop_mkdir_args *));
int	msdosfs_rmdir __P((struct vop_rmdir_args *));
int	msdosfs_symlink __P((struct vop_symlink_args *));
int	msdosfs_readdir __P((struct vop_readdir_args *));
int	msdosfs_readlink __P((struct vop_readlink_args *));
int	msdosfs_abortop __P((struct vop_abortop_args *));
int	msdosfs_inactive __P((struct vop_inactive_args *));
int	msdosfs_reclaim __P((struct vop_reclaim_args *));
int	msdosfs_lock __P((struct vop_lock_args *));
int	msdosfs_unlock __P((struct vop_unlock_args *));
int	msdosfs_bmap __P((struct vop_bmap_args *));
int	msdosfs_strategy __P((struct vop_strategy_args *));
int	msdosfs_print __P((struct vop_print_args *));
int	msdosfs_islocked __P((struct vop_islocked_args *));
int	msdosfs_advlock __P((struct vop_advlock_args *));
int	msdosfs_reallocblks __P((struct vop_reallocblks_args *));
d314 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: denode.h,v 1.16 1995/09/09 19:38:00 ws Exp $	*/
d4 2
a5 2
 * Copyright (C) 1994 Wolfgang Solfrank.
 * Copyright (C) 1994 TooLs GmbH.
d144 1
a144 2
	u_long de_diroffset;	/* ordinal of this entry in the directory */
	u_long de_fndclust;	/* cluster of found dir entry */
d146 1
d152 1
a152 3
	/* the next two fields must be contiguous in memory... */
	u_char de_Name[8];	/* name, from directory entry */
	u_char de_Extension[3];	/* extension, from directory entry */
d154 6
a159 2
	u_short de_Time;	/* creation time */
	u_short de_Date;	/* creation date */
d171 10
a180 2
#define	DE_MODIFIED	0x0008	/* Denode has been modified. */
#define	DE_RENAME	0x0010	/* Denode is in the process of being renamed */
d190 6
a195 2
	 (dep)->de_Time = getushort((dp)->deTime),	\
	 (dep)->de_Date = getushort((dp)->deDate),	\
d202 6
a207 2
	 putushort((dp)->deTime, (dep)->de_Time),	\
	 putushort((dp)->deDate, (dep)->de_Date),	\
d221 1
a221 2
	if ((dep)->de_flag & DE_UPDATE) { \
		(dep)->de_flag &= ~DE_UPDATE; \
d223 11
a233 2
			unix2dostime(NULL, &(dep)->de_Date, &(dep)->de_Time); \
			(dep)->de_Attributes |= ATTR_ARCHIVE; \
d236 1
d299 1
a299 1
int createde __P((struct denode *, struct denode *, struct denode **));
d301 1
a301 1
int deget __P((struct msdosfsmount *, u_long, u_long, struct direntry *, struct denode **));
d310 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
