head	1.113;
access;
symbols
	OPENBSD_6_1:1.113.0.4
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.112.0.2
	OPENBSD_6_0_BASE:1.112
	OPENBSD_5_9:1.107.0.2
	OPENBSD_5_9_BASE:1.107
	OPENBSD_5_8:1.100.0.4
	OPENBSD_5_8_BASE:1.100
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.91.0.4
	OPENBSD_5_5_BASE:1.91
	OPENBSD_5_4:1.87.0.2
	OPENBSD_5_4_BASE:1.87
	OPENBSD_5_3:1.83.0.2
	OPENBSD_5_3_BASE:1.83
	OPENBSD_5_2:1.82.0.2
	OPENBSD_5_2_BASE:1.82
	OPENBSD_5_1_BASE:1.79
	OPENBSD_5_1:1.79.0.4
	OPENBSD_5_0:1.79.0.2
	OPENBSD_5_0_BASE:1.79
	OPENBSD_4_9:1.76.0.2
	OPENBSD_4_9_BASE:1.76
	OPENBSD_4_8:1.72.0.4
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.72.0.2
	OPENBSD_4_7_BASE:1.72
	OPENBSD_4_6:1.67.0.8
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.67.0.4
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.67.0.2
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.65.0.2
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.64.0.2
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.59.0.2
	OPENBSD_4_1_BASE:1.59
	OPENBSD_4_0:1.56.0.4
	OPENBSD_4_0_BASE:1.56
	OPENBSD_3_9:1.56.0.2
	OPENBSD_3_9_BASE:1.56
	OPENBSD_3_8:1.53.0.4
	OPENBSD_3_8_BASE:1.53
	OPENBSD_3_7:1.53.0.2
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.46.0.2
	OPENBSD_3_6_BASE:1.46
	SMP_SYNC_A:1.45
	SMP_SYNC_B:1.45
	OPENBSD_3_5:1.43.0.2
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.41.0.2
	OPENBSD_3_4_BASE:1.41
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.37.0.4
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.36.0.2
	OPENBSD_3_1_BASE:1.36
	UBC_SYNC_B:1.37
	UBC:1.34.0.2
	UBC_BASE:1.34
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.21.0.8
	OPENBSD_2_7_BASE:1.21
	SMP:1.21.0.6
	SMP_BASE:1.21
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.4
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.113
date	2016.08.30.19.47.23;	author sf;	state Exp;
branches;
next	1.112;
commitid	NRpgyTuO0n9X0z7e;

1.112
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.111;
commitid	wHLNY5GFNXJSFYaC;

1.111
date	2016.05.21.18.11.36;	author natano;	state Exp;
branches;
next	1.110;
commitid	h6HuALSffVqURa2m;

1.110
date	2016.05.21.15.11.46;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	pdvYlWLCCFSMZYXU;

1.109
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.108;
commitid	gAjwyca5TfuoJAhn;

1.108
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.107;
commitid	kCz5QgxnxRMKOzNf;

1.107
date	2016.02.05.19.27.02;	author stefan;	state Exp;
branches;
next	1.106;
commitid	sI3d5UOuSt4JWOre;

1.106
date	2016.01.27.17.09.41;	author stefan;	state Exp;
branches;
next	1.105;
commitid	y3JQLoWe4RxmQwMc;

1.105
date	2016.01.13.10.00.55;	author mpi;	state Exp;
branches;
next	1.104;
commitid	ru9jHQwQX09BC5Bw;

1.104
date	2015.10.23.18.04.37;	author krw;	state Exp;
branches;
next	1.103;
commitid	w5EbqI2WFgDzV9qB;

1.103
date	2015.10.23.17.21.34;	author krw;	state Exp;
branches;
next	1.102;
commitid	OojuukoxD2uoNfhb;

1.102
date	2015.10.23.10.45.31;	author krw;	state Exp;
branches;
next	1.101;
commitid	SncnQqnXMdpzMlro;

1.101
date	2015.09.23.15.37.26;	author tedu;	state Exp;
branches;
next	1.100;
commitid	xTdRXaXuj71z4icR;

1.100
date	2015.04.17.04.43.21;	author guenther;	state Exp;
branches;
next	1.99;
commitid	zOwbm07fp3gPB2qr;

1.99
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.98;
commitid	p4LJxGKbi0BU2cG6;

1.98
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.97;
commitid	C5iGb36LQxjM60Q3;

1.97
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.96;
commitid	P6Av4XGqOi3rFasL;

1.96
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.95;
commitid	EkuwmBeHv2Tqmdnx;

1.95
date	2014.08.10.09.23.06;	author jsg;	state Exp;
branches;
next	1.94;
commitid	Af0D58K1tqLmcSUu;

1.94
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	EF98ch02VpFassUi;

1.93
date	2014.05.09.03.48.58;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2014.04.08.18.48.41;	author beck;	state Exp;
branches;
next	1.91;

1.91
date	2013.12.14.02.57.25;	author guenther;	state Exp;
branches;
next	1.90;

1.90
date	2013.10.01.20.22.13;	author sf;	state Exp;
branches;
next	1.89;

1.89
date	2013.09.14.02.28.03;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2013.08.13.05.52.24;	author guenther;	state Exp;
branches;
next	1.87;

1.87
date	2013.06.11.16.42.16;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2013.05.23.09.11.00;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2013.03.28.03.29.44;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.28.02.08.39;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2013.01.15.06.05.47;	author martynas;	state Exp;
branches;
next	1.82;

1.82
date	2012.07.11.12.39.20;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2012.06.20.17.30.22;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	2012.02.16.08.58.49;	author robert;	state Exp;
branches;
next	1.79;

1.79
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.77;

1.77
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.76;

1.76
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.75;

1.75
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.74;

1.74
date	2010.09.09.10.37.04;	author thib;	state Exp;
branches;
next	1.73;

1.73
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.72;

1.72
date	2009.08.14.11.35.03;	author jasper;	state Exp;
branches;
next	1.71;

1.71
date	2009.08.13.22.34.29;	author jasper;	state Exp;
branches;
next	1.70;

1.70
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.69;

1.69
date	2009.08.13.12.20.52;	author jasper;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.09.21.58.00;	author martynas;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.09.23.38.37;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.29.15.39.01;	author chl;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.02.02.04.21;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.02.21.18.59;	author pedro;	state Exp;
branches;
next	1.61;

1.61
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.60;

1.60
date	2007.03.18.15.05.33;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.16.11.27.53;	author pedro;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.01.22.13.33;	author pedro;	state Exp;
branches;
next	1.55;

1.55
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.54;

1.54
date	2005.10.08.09.38.22;	author tom;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.14.22.31.52;	author tom;	state Exp;
branches
	1.53.4.1;
next	1.52;

1.52
date	2005.03.02.00.44.12;	author tom;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.01.14.29.01;	author tom;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.01.14.24.33;	author tom;	state Exp;
branches;
next	1.49;

1.49
date	2004.11.30.12.39.43;	author pedro;	state Exp;
branches;
next	1.48;

1.48
date	2004.11.29.17.05.06;	author grange;	state Exp;
branches;
next	1.47;

1.47
date	2004.09.18.22.01.18;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.14.04.05.05;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.12.21.04.15;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.13.17.19.40;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.07.22.16.26;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.26.10.23.07;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.18.22.12.25;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.24.08.54.24;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.04.22.44.32;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.02.18.30.30;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.28.23.28.32;	author jakob;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.23.13.52.35;	author aaron;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.26.01.53.09;	author assar;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.27.04.58.45;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.23.02.15.24;	author csapuntz;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.23.14.42.38;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.07.15.04.06;	author art;	state Exp;
branches;
next	1.21;

1.21
date	99.02.26.03.28.13;	author art;	state Exp;
branches
	1.21.6.1
	1.21.8.1;
next	1.20;

1.20
date	99.01.11.05.12.28;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.01.10.23.21.19;	author art;	state Exp;
branches;
next	1.18;

1.18
date	98.08.06.19.34.54;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	98.06.09.17.56.03;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.02.23.20.10.39;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	98.01.11.20.39.10;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.11.11.18.57.17;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.11.06.05.58.58;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.20.21.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.15.22.40;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.10.04.19.08.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.03.17.49.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.03.02.18.02.01;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.10.24.17.56.18;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.10.04.03.05.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.28.24;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.19.16.10.03;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.10.46.59;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.19.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches;
next	;

1.21.6.1
date	2001.05.14.22.32.59;	author niklas;	state Exp;
branches;
next	1.21.6.2;

1.21.6.2
date	2001.07.04.10.49.27;	author niklas;	state Exp;
branches;
next	1.21.6.3;

1.21.6.3
date	2001.10.31.03.26.30;	author nate;	state Exp;
branches;
next	1.21.6.4;

1.21.6.4
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.21.6.5;

1.21.6.5
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.21.6.6;

1.21.6.6
date	2002.03.06.02.13.25;	author niklas;	state Exp;
branches;
next	1.21.6.7;

1.21.6.7
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.21.6.8;

1.21.6.8
date	2003.03.28.00.00.21;	author niklas;	state Exp;
branches;
next	1.21.6.9;

1.21.6.9
date	2003.05.13.19.21.30;	author ho;	state Exp;
branches;
next	1.21.6.10;

1.21.6.10
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.21.6.11;

1.21.6.11
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.21.8.1
date	2000.06.09.05.22.16;	author jason;	state Exp;
branches;
next	;

1.34.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.06.11.03.30.32;	author art;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2003.05.19.22.27.06;	author tedu;	state Exp;
branches;
next	;

1.53.4.1
date	2006.07.22.03.35.35;	author brad;	state Exp;
branches;
next	;


desc
@@


1.113
log
@Revert "Implement VFS read clustering for MSDOSFS"

This caused garbage to be written instead of blocks of 0-bytes if a
file is extended by seeking past the end. This happens for example
when extracting files containing lots of 0-bytes with tar.

ok mpi@@

Details of original commit:

  msdosfs_vnops.c revision 1.105
  denode.h revision 1.28
  date: 2016/01/13 10:00:55;  author: mpi;  commitid: ru9jHQwQX09BC5Bw;

  Implement VFS read clustering for MSDOSFS.

  The logic used in msdosfs_bmap() to loop calling pcbmap() comes from
  FreeBSD and is not really efficient but it is good enough since it is
  only called when generating I/O.

  With this diff I get a 100% improvement when reading big files from a
  crappy USB stick.

  With this and bread_cluster(9) modified to not re-fetch B_CACHED buffers,
  reading large contiguous files with chunk sizes of MAXPHYS is almost as
  fast as physio(9) on the same device.

  For a 'real world' example, when copying music files from a USB stick I
  see a speed jump from 15MB/s on -current to 24Mb/s with this diff.

  While here rename some 'lbn' variables into 'cn' to better reflect what
  we're dealing with.

  Tested by Mathieu, with support from deraadt@@
@
text
@/*	$OpenBSD: msdosfs_vnops.c,v 1.112 2016/06/19 11:54:33 natano Exp $	*/
/*	$NetBSD: msdosfs_vnops.c,v 1.63 1997/10/17 11:24:19 ws Exp $	*/

/*-
 * Copyright (C) 2005 Thomas Wang.
 * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995, 1997 TooLs GmbH.
 * All rights reserved.
 * Original code by Paul Popelka (paulp@@uts.amdahl.com) (see below).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Written by Paul Popelka (paulp@@uts.amdahl.com)
 *
 * You can do anything you want with this software, just don't say you wrote
 * it, and don't remove this notice.
 *
 * This software is provided "as is".
 *
 * The author supplies this software to be publicly redistributed on the
 * understanding that the author is not responsible for the correct
 * functioning of this software in any circumstances and is not liable for
 * any damages caused by this software.
 *
 * October 1992
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/resourcevar.h>	/* defines plimit structure in proc struct */
#include <sys/file.h>		/* define FWRITE ... */
#include <sys/stat.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/signalvar.h>
#include <sys/specdev.h> /* XXX */	/* defines v_rdev */
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/dirent.h>		/* defines dirent structure */
#include <sys/lockf.h>
#include <sys/poll.h>
#include <sys/unistd.h>

#include <msdosfs/bpb.h>
#include <msdosfs/direntry.h>
#include <msdosfs/denode.h>
#include <msdosfs/msdosfsmount.h>
#include <msdosfs/fat.h>

static uint32_t fileidhash(uint64_t);

int msdosfs_kqfilter(void *);
int filt_msdosfsread(struct knote *, long);
int filt_msdosfswrite(struct knote *, long);
int filt_msdosfsvnode(struct knote *, long);
void filt_msdosfsdetach(struct knote *);


/*
 * Some general notes:
 *
 * In the ufs filesystem the inodes, superblocks, and indirect blocks are
 * read/written using the vnode for the filesystem. Blocks that represent
 * the contents of a file are read/written using the vnode for the file
 * (including directories when they are read/written as files). This
 * presents problems for the dos filesystem because data that should be in
 * an inode (if dos had them) resides in the directory itself.  Since we
 * must update directory entries without the benefit of having the vnode
 * for the directory we must use the vnode for the filesystem.  This means
 * that when a directory is actually read/written (via read, write, or
 * readdir, or seek) we must use the vnode for the filesystem instead of
 * the vnode for the directory as would happen in ufs. This is to insure we
 * retrieve the correct block from the buffer cache since the hash value is
 * based upon the vnode address and the desired block number.
 */

/*
 * Create a regular file. On entry the directory to contain the file being
 * created is locked.  We must release before we return. We must also free
 * the pathname buffer pointed at by cnp->cn_pnbuf, always on error, or
 * only if the SAVESTART bit in cn_flags is clear on success.
 */
int
msdosfs_create(void *v)
{
	struct vop_create_args *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct denode ndirent;
	struct denode *dep;
	struct denode *pdep = VTODE(ap->a_dvp);
	int error;
	struct timespec ts;

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_create(cnp %p, vap %p\n", cnp, ap->a_vap);
#endif

	/*
	 * If this is the root directory and there is no space left we
	 * can't do anything.  This is because the root directory can not
	 * change size.
	 */
	if (pdep->de_StartCluster == MSDOSFSROOT
	    && pdep->de_fndoffset >= pdep->de_FileSize) {
		error = ENOSPC;
		goto bad;
	}

	/*
	 * Create a directory entry for the file, then call createde() to
	 * have it installed. NOTE: DOS files are always executable.  We
	 * use the absence of the owner write bit to make the file
	 * readonly.
	 */
#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("msdosfs_create: no name");
#endif
	bzero(&ndirent, sizeof(ndirent));
	if ((error = uniqdosname(pdep, cnp, ndirent.de_Name)) != 0)
		goto bad;

	ndirent.de_Attributes = (ap->a_vap->va_mode & VWRITE) ?
				ATTR_ARCHIVE : ATTR_ARCHIVE | ATTR_READONLY;
	ndirent.de_StartCluster = 0;
	ndirent.de_FileSize = 0;
	ndirent.de_dev = pdep->de_dev;
	ndirent.de_devvp = pdep->de_devvp;
	ndirent.de_pmp = pdep->de_pmp;
	ndirent.de_flag = DE_ACCESS | DE_CREATE | DE_UPDATE;
	getnanotime(&ts);
	DETIMES(&ndirent, &ts, &ts, &ts);
	if ((error = createde(&ndirent, pdep, &dep, cnp)) != 0)
		goto bad;
	if ((cnp->cn_flags & SAVESTART) == 0)
		pool_put(&namei_pool, cnp->cn_pnbuf);
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	vput(ap->a_dvp);
	*ap->a_vpp = DETOV(dep);
	return (0);

bad:
	pool_put(&namei_pool, cnp->cn_pnbuf);
	vput(ap->a_dvp);
	return (error);
}

int
msdosfs_mknod(void *v)
{
	struct vop_mknod_args *ap = v;

	pool_put(&namei_pool, ap->a_cnp->cn_pnbuf);
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	vput(ap->a_dvp);
	return (EINVAL);
}

int
msdosfs_open(void *v)
{
#if 0
	struct vop_open_args /* {
		struct vnode *a_vp;
		int a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
#endif

	return (0);
}

int
msdosfs_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct denode *dep = VTODE(vp);
	struct timespec ts;

	if (vp->v_usecount > 1 && !VOP_ISLOCKED(vp)) {
		getnanotime(&ts);
		DETIMES(dep, &ts, &ts, &ts);
	}
	return (0);
}

int
msdosfs_access(void *v)
{
	struct vop_access_args *ap = v;
	struct denode *dep = VTODE(ap->a_vp);
	struct msdosfsmount *pmp = dep->de_pmp;
	mode_t dosmode;

	dosmode = (S_IRUSR|S_IRGRP|S_IROTH);
	if ((dep->de_Attributes & ATTR_READONLY) == 0)
		dosmode |= (S_IWUSR|S_IWGRP|S_IWOTH);
	if (dep->de_Attributes & ATTR_DIRECTORY) {
		dosmode |= (dosmode & S_IRUSR) ? S_IXUSR : 0;
		dosmode |= (dosmode & S_IRGRP) ? S_IXGRP : 0;
		dosmode |= (dosmode & S_IROTH) ? S_IXOTH : 0;
	}
	dosmode &= pmp->pm_mask;

	return (vaccess(ap->a_vp->v_type, dosmode, pmp->pm_uid, pmp->pm_gid,
	    ap->a_mode, ap->a_cred));
}

int
msdosfs_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct denode *dep = VTODE(ap->a_vp);
	struct msdosfsmount *pmp = dep->de_pmp;
	struct vattr *vap = ap->a_vap;
	struct timespec ts;
	uint32_t fileid;

	getnanotime(&ts);
	DETIMES(dep, &ts, &ts, &ts);
	vap->va_fsid = dep->de_dev;

	/*
	 * The following computation of the fileid must be the same as
	 * that used in msdosfs_readdir() to compute d_fileno. If not,
	 * pwd doesn't work.
	 *
	 * We now use the starting cluster number as the fileid/fileno.
	 * This works for both files and directories (including the root
	 * directory, on FAT32).  Even on FAT32, this will at most be a
	 * 28-bit number, as the high 4 bits of FAT32 cluster numbers
	 * are reserved.
	 *
	 * However, we do need to do something for 0-length files, which
	 * will not have a starting cluster number.
	 *
	 * These files cannot be directories, since (except for /, which
	 * is special-cased anyway) directories contain entries for . and
	 * .., so must have non-zero length.
	 *
	 * In this case, we just create a non-cryptographic hash of the
	 * original fileid calculation, and set the top bit.
	 *
	 * This algorithm has the benefit that all directories, and all
	 * non-zero-length files, will have fileids that are persistent
	 * across mounts and reboots, and that cannot collide (as long
	 * as the filesystem is not corrupt).  Zero-length files will
	 * have fileids that are persistent, but that may collide.  We
	 * will just have to live with that.
	 */
	fileid = dep->de_StartCluster;

	if (dep->de_Attributes & ATTR_DIRECTORY) {
		/* Special-case root */
		if (dep->de_StartCluster == MSDOSFSROOT)
			fileid = FAT32(pmp) ? pmp->pm_rootdirblk : 1;
	} else {
		if (dep->de_FileSize == 0) {
			uint32_t dirsperblk;
			uint64_t fileid64;

			dirsperblk = pmp->pm_BytesPerSec /
			    sizeof(struct direntry);

			fileid64 = (dep->de_dirclust == MSDOSFSROOT) ?
			    roottobn(pmp, 0) : cntobn(pmp, dep->de_dirclust);
			fileid64 *= dirsperblk;
			fileid64 += dep->de_diroffset / sizeof(struct direntry);

			fileid = fileidhash(fileid64);
		}
	}

	vap->va_fileid = fileid;
	vap->va_mode = (S_IRUSR|S_IRGRP|S_IROTH);
	if ((dep->de_Attributes & ATTR_READONLY) == 0)
		vap->va_mode |= (S_IWUSR|S_IWGRP|S_IWOTH);
	if (dep->de_Attributes & ATTR_DIRECTORY) {
		vap->va_mode |= S_IFDIR;
		vap->va_mode |= (vap->va_mode & S_IRUSR) ? S_IXUSR : 0;
		vap->va_mode |= (vap->va_mode & S_IRGRP) ? S_IXGRP : 0;
		vap->va_mode |= (vap->va_mode & S_IROTH) ? S_IXOTH : 0;
	}
	vap->va_mode &= dep->de_pmp->pm_mask;
	vap->va_nlink = 1;
	vap->va_gid = dep->de_pmp->pm_gid;
	vap->va_uid = dep->de_pmp->pm_uid;
	vap->va_rdev = 0;
	vap->va_size = dep->de_FileSize;
	dos2unixtime(dep->de_MDate, dep->de_MTime, 0, &vap->va_mtime);
	if (dep->de_pmp->pm_flags & MSDOSFSMNT_LONGNAME) {
		dos2unixtime(dep->de_ADate, 0, 0, &vap->va_atime);
		dos2unixtime(dep->de_CDate, dep->de_CTime, dep->de_CTimeHundredth, &vap->va_ctime);
	} else {
		vap->va_atime = vap->va_mtime;
		vap->va_ctime = vap->va_mtime;
	}
	vap->va_flags = 0;
	if ((dep->de_Attributes & ATTR_ARCHIVE) == 0)
		vap->va_flags |= SF_ARCHIVED;
	vap->va_gen = 0;
	vap->va_blocksize = dep->de_pmp->pm_bpcluster;
	vap->va_bytes = (dep->de_FileSize + dep->de_pmp->pm_crbomask) &
				~(dep->de_pmp->pm_crbomask);
	vap->va_type = ap->a_vp->v_type;
	return (0);
}

int
msdosfs_setattr(void *v)
{
	struct vop_setattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct denode *dep = VTODE(ap->a_vp);
	struct msdosfsmount *pmp = dep->de_pmp;
	struct vattr *vap = ap->a_vap;
	struct ucred *cred = ap->a_cred;
	int error = 0;

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_setattr(): vp %p, vap %p, cred %p, p %p\n",
	    ap->a_vp, vap, cred, ap->a_p);
#endif
	if ((vap->va_type != VNON) || (vap->va_nlink != VNOVAL) ||
	    (vap->va_fsid != VNOVAL) || (vap->va_fileid != VNOVAL) ||
	    (vap->va_blocksize != VNOVAL) || (vap->va_rdev != VNOVAL) ||
	    (vap->va_bytes != VNOVAL) || (vap->va_gen != VNOVAL)) {
#ifdef MSDOSFS_DEBUG
		printf("msdosfs_setattr(): returning EINVAL\n");
		printf("    va_type %d, va_nlink %x, va_fsid %ld, "
		    "va_fileid %llx\n", vap->va_type, vap->va_nlink,
		    vap->va_fsid, (unsigned long long)vap->va_fileid);
		printf("    va_blocksize %lx, va_rdev %x, va_bytes %llx, "
		    "va_gen %lx\n", vap->va_blocksize,
		    (unsigned int)vap->va_rdev,
		    (unsigned long long)vap->va_bytes, vap->va_gen);
#endif
		return (EINVAL);
	}
	if (vap->va_flags != VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EINVAL);
		if (cred->cr_uid != pmp->pm_uid) {
			error = suser_ucred(cred);
			if (error)
				return (error);
		}
		/*
		 * We are very inconsistent about handling unsupported
		 * attributes.  We ignored the access time and the
		 * read and execute bits.  We were strict for the other
		 * attributes.
		 *
		 * Here we are strict, stricter than ufs in not allowing
		 * users to attempt to set SF_SETTABLE bits or anyone to
		 * set unsupported bits.  However, we ignore attempts to
		 * set ATTR_ARCHIVE for directories `cp -pr' from a more
		 * sensible filesystem attempts it a lot.
		 */
		if (vap->va_flags & SF_SETTABLE) {
			error = suser_ucred(cred);
			if (error)
				return (error);
		}
		if (vap->va_flags & ~SF_ARCHIVED)
			return EOPNOTSUPP;
		if (vap->va_flags & SF_ARCHIVED)
			dep->de_Attributes &= ~ATTR_ARCHIVE;
		else if (!(dep->de_Attributes & ATTR_DIRECTORY))
			dep->de_Attributes |= ATTR_ARCHIVE;
		dep->de_flag |= DE_MODIFIED;
	}

	if (vap->va_uid != (uid_t)VNOVAL || vap->va_gid != (gid_t)VNOVAL) {
		uid_t uid;
		gid_t gid;

		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EINVAL);
		uid = vap->va_uid;
		if (uid == (uid_t)VNOVAL)
			uid = pmp->pm_uid;
		gid = vap->va_gid;
		if (gid == (gid_t)VNOVAL)
			gid = pmp->pm_gid;
		if (cred->cr_uid != pmp->pm_uid || uid != pmp->pm_uid ||
		    (gid != pmp->pm_gid && !groupmember(gid, cred))) {
			error = suser_ucred(cred);
			if (error)
				return (error);
		}
		if (uid != pmp->pm_uid || gid != pmp->pm_gid)
			return EINVAL;
	}

	if (vap->va_size != VNOVAL) {
		switch (vp->v_type) {
		case VDIR:
			return (EISDIR);
		case VREG:
			/*
			 * Truncation is only supported for regular files,
			 * Disallow it if the filesystem is read-only.
			 */
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EINVAL);
			break;
		default:
			/*
			 * According to POSIX, the result is unspecified
			 * for file types other than regular files,
			 * directories and shared memory objects.  We
			 * don't support any file types except regular
			 * files and directories in this file system, so
			 * this (default) case is unreachable and can do
			 * anything.  Keep falling through to detrunc()
			 * for now.
			 */
			break;
		}
		error = detrunc(dep, vap->va_size, 0, cred, ap->a_p);
		if (error)
			return error;
	}
	if ((vap->va_vaflags & VA_UTIMES_CHANGE) ||
	    vap->va_atime.tv_nsec != VNOVAL ||
	    vap->va_mtime.tv_nsec != VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EINVAL);
		if (cred->cr_uid != pmp->pm_uid &&
		    (error = suser_ucred(cred)) &&
		    ((vap->va_vaflags & VA_UTIMES_NULL) == 0 ||
		    (error = VOP_ACCESS(ap->a_vp, VWRITE, cred, ap->a_p))))
			return (error);
		if (vp->v_type != VDIR) {
			if ((pmp->pm_flags & MSDOSFSMNT_NOWIN95) == 0 &&
			    vap->va_atime.tv_nsec != VNOVAL) {
				dep->de_flag &= ~DE_ACCESS;
				unix2dostime(&vap->va_atime, &dep->de_ADate,
				    NULL, NULL);
			}
			if (vap->va_mtime.tv_nsec != VNOVAL) {
				dep->de_flag &= ~DE_UPDATE;
				unix2dostime(&vap->va_mtime, &dep->de_MDate,
				    &dep->de_MTime, NULL);
			}
			dep->de_Attributes |= ATTR_ARCHIVE;
			dep->de_flag |= DE_MODIFIED;
		}
	}
	/*
	 * DOS files only have the ability to have their writability
	 * attribute set, so we use the owner write bit to set the readonly
	 * attribute.
	 */
	if (vap->va_mode != (mode_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EINVAL);
		if (cred->cr_uid != pmp->pm_uid) {
			error = suser_ucred(cred);
			if (error)
				return (error);
		}
		if (vp->v_type != VDIR) {
			/* We ignore the read and execute bits. */
			if (vap->va_mode & VWRITE)
				dep->de_Attributes &= ~ATTR_READONLY;
			else
				dep->de_Attributes |= ATTR_READONLY;
			dep->de_Attributes |= ATTR_ARCHIVE;
			dep->de_flag |= DE_MODIFIED;
		}
	}
	VN_KNOTE(ap->a_vp, NOTE_ATTRIB);
	return (deupdat(dep, 1));
}

int
msdosfs_read(void *v)
{
	struct vop_read_args *ap = v;
	int error = 0;
	uint32_t diff;
	int blsize;
	int isadir;
	uint32_t n;
	long on;
	daddr_t lbn, rablock, rablkno;
	struct buf *bp;
	struct vnode *vp = ap->a_vp;
	struct denode *dep = VTODE(vp);
	struct msdosfsmount *pmp = dep->de_pmp;
	struct uio *uio = ap->a_uio;

	/*
	 * If they didn't ask for any data, then we are done.
	 */
	if (uio->uio_resid == 0)
		return (0);
	if (uio->uio_offset < 0)
		return (EINVAL);

	isadir = dep->de_Attributes & ATTR_DIRECTORY;
	do {
		if (uio->uio_offset >= dep->de_FileSize)
			return (0);

		lbn = de_cluster(pmp, uio->uio_offset);
		on = uio->uio_offset & pmp->pm_crbomask;
		n = ulmin(pmp->pm_bpcluster - on, uio->uio_resid);

		/*
		 * de_FileSize is uint32_t, and we know that uio_offset <
		 * de_FileSize, so uio->uio_offset < 2^32.  Therefore
		 * the cast to uint32_t on the next line is safe.
		 */
		diff = dep->de_FileSize - (uint32_t)uio->uio_offset;
		if (diff < n)
			n = diff;

		/* convert cluster # to block # if a directory */
		if (isadir) {
			error = pcbmap(dep, lbn, &lbn, 0, &blsize);
			if (error)
				return (error);
		}
		/*
		 * If we are operating on a directory file then be sure to
		 * do i/o with the vnode for the filesystem instead of the
		 * vnode for the directory.
		 */
		if (isadir) {
			error = bread(pmp->pm_devvp, lbn, blsize, &bp);
		} else {
			rablock = lbn + 1;
			rablkno = de_cn2bn(pmp, rablock);
			if (dep->de_lastr + 1 == lbn &&
			    de_cn2off(pmp, rablock) < dep->de_FileSize)
				error = breadn(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, &rablkno,
				    &pmp->pm_bpcluster, 1, &bp);
			else
				error = bread(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, &bp);
			dep->de_lastr = lbn;
		}
		n = min(n, pmp->pm_bpcluster - bp->b_resid);
		if (error) {
			brelse(bp);
			return (error);
		}
		error = uiomove(bp->b_data + on, n, uio);
		brelse(bp);
	} while (error == 0 && uio->uio_resid > 0 && n != 0);
	if (!isadir && !(vp->v_mount->mnt_flag & MNT_NOATIME))
		dep->de_flag |= DE_ACCESS;
	return (error);
}

/*
 * Write data to a file or directory.
 */
int
msdosfs_write(void *v)
{
	struct vop_write_args *ap = v;
	uint32_t n, croffset;
	size_t resid;
	ssize_t overrun;
	int extended = 0;
	uint32_t osize;
	int error = 0;
	uint32_t count, lastcn;
	daddr_t bn;
	struct buf *bp;
	int ioflag = ap->a_ioflag;
	struct uio *uio = ap->a_uio;
	struct vnode *vp = ap->a_vp;
	struct vnode *thisvp;
	struct denode *dep = VTODE(vp);
	struct msdosfsmount *pmp = dep->de_pmp;
	struct ucred *cred = ap->a_cred;

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_write(vp %p, uio %p, ioflag %08x, cred %p\n",
	    vp, uio, ioflag, cred);
	printf("msdosfs_write(): diroff %d, dirclust %d, startcluster %d\n",
	    dep->de_diroffset, dep->de_dirclust, dep->de_StartCluster);
#endif

	switch (vp->v_type) {
	case VREG:
		if (ioflag & IO_APPEND)
			uio->uio_offset = dep->de_FileSize;
		thisvp = vp;
		break;
	case VDIR:
		return EISDIR;
	default:
		panic("msdosfs_write(): bad file type");
	}

	if (uio->uio_offset < 0)
		return (EINVAL);

	if (uio->uio_resid == 0)
		return (0);

	/* Don't bother to try to write files larger than the f/s limit */
	if (uio->uio_offset > MSDOSFS_FILESIZE_MAX ||
	    uio->uio_resid > (MSDOSFS_FILESIZE_MAX - uio->uio_offset))
		return (EFBIG);

	/* do the filesize rlimit check */
	if ((error = vn_fsizechk(vp, uio, ioflag, &overrun)))
		return (error);

	/*
	 * If the offset we are starting the write at is beyond the end of
	 * the file, then they've done a seek.  Unix filesystems allow
	 * files with holes in them, DOS doesn't so we must fill the hole
	 * with zeroed blocks.
	 */
	if (uio->uio_offset > dep->de_FileSize) {
		if ((error = deextend(dep, uio->uio_offset, cred)) != 0)
			goto out;
	}

	/*
	 * Remember some values in case the write fails.
	 */
	resid = uio->uio_resid;
	osize = dep->de_FileSize;

	/*
	 * If we write beyond the end of the file, extend it to its ultimate
	 * size ahead of the time to hopefully get a contiguous area.
	 */
	if (uio->uio_offset + resid > osize) {
		extended = 1;
		count = de_clcount(pmp, uio->uio_offset + resid) -
			de_clcount(pmp, osize);
		if ((error = extendfile(dep, count, NULL, NULL, 0)) &&
		    (error != ENOSPC || (ioflag & IO_UNIT)))
			goto errexit;
		lastcn = dep->de_fc[FC_LASTFC].fc_frcn;
	} else
		lastcn = de_clcount(pmp, osize) - 1;

	do {
		if (de_cluster(pmp, uio->uio_offset) > lastcn) {
			error = ENOSPC;
			break;
		}

		bn = de_blk(pmp, uio->uio_offset);
		if ((uio->uio_offset & pmp->pm_crbomask) == 0
		    && (de_blk(pmp, uio->uio_offset + uio->uio_resid) > de_blk(pmp, uio->uio_offset)
			|| uio->uio_offset + uio->uio_resid >= dep->de_FileSize)) {
			/*
			 * If either the whole cluster gets written,
			 * or we write the cluster from its start beyond EOF,
			 * then no need to read data from disk.
			 */
			bp = getblk(thisvp, bn, pmp->pm_bpcluster, 0, 0);
			clrbuf(bp);
			/*
			 * Do the bmap now, since pcbmap needs buffers
			 * for the fat table. (see msdosfs_strategy)
			 */
			if (bp->b_blkno == bp->b_lblkno) {
				error = pcbmap(dep,
					       de_bn2cn(pmp, bp->b_lblkno),
					       &bp->b_blkno, 0, 0);
				if (error)
					bp->b_blkno = -1;
			}
			if (bp->b_blkno == -1) {
				brelse(bp);
				if (!error)
					error = EIO;		/* XXX */
				break;
			}
		} else {
			/*
			 * The block we need to write into exists, so read it in.
			 */
			error = bread(thisvp, bn, pmp->pm_bpcluster, &bp);
			if (error) {
				brelse(bp);
				break;
			}
		}

		croffset = uio->uio_offset & pmp->pm_crbomask;
		n = ulmin(uio->uio_resid, pmp->pm_bpcluster - croffset);
		if (uio->uio_offset + n > dep->de_FileSize) {
			dep->de_FileSize = uio->uio_offset + n;
			uvm_vnp_setsize(vp, dep->de_FileSize);
		}
		uvm_vnp_uncache(vp);
		/*
		 * Should these vnode_pager_* functions be done on dir
		 * files?
		 */

		/*
		 * Copy the data from user space into the buf header.
		 */
		error = uiomove(bp->b_data + croffset, n, uio);

		/*
		 * If they want this synchronous then write it and wait for
		 * it.  Otherwise, if on a cluster boundary write it
		 * asynchronously so we can move on to the next block
		 * without delay.  Otherwise do a delayed write because we
		 * may want to write somemore into the block later.
		 */
#if 0
		if (ioflag & IO_NOCACHE)
			bp->b_flags |= B_NOCACHE;
#endif
		if (ioflag & IO_SYNC)
			(void) bwrite(bp);
		else if (n + croffset == pmp->pm_bpcluster)
			bawrite(bp);
		else
			bdwrite(bp);
		dep->de_flag |= DE_UPDATE;
	} while (error == 0 && uio->uio_resid > 0);

	if (resid > uio->uio_resid)
		 VN_KNOTE(ap->a_vp, NOTE_WRITE | (extended ? NOTE_EXTEND : 0));

	if (dep->de_FileSize < osize)
		VN_KNOTE(ap->a_vp, NOTE_TRUNCATE);

	/*
	 * If the write failed and they want us to, truncate the file back
	 * to the size it was before the write was attempted.
	 */
errexit:
	if (error) {
		if (ioflag & IO_UNIT) {
			detrunc(dep, osize, ioflag & IO_SYNC, NOCRED, NULL);
			uio->uio_offset -= resid - uio->uio_resid;
			uio->uio_resid = resid;
		} else {
			detrunc(dep, dep->de_FileSize, ioflag & IO_SYNC, NOCRED, NULL);
			if (uio->uio_resid != resid)
				error = 0;
		}
	} else if (ioflag & IO_SYNC)
		error = deupdat(dep, 1);

out:
	/* correct the result for writes clamped by vn_fsizechk() */
	uio->uio_resid += overrun;
	return (error);
}

int
msdosfs_ioctl(void *v)
{
#if 0
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		uint32_t a_command;
		caddr_t a_data;
		int a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
#endif

	return (ENOTTY);
}

int
msdosfs_poll(void *v)
{
	struct vop_poll_args *ap = v;

	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}

/*
 * Flush the blocks of a file to disk.
 *
 * This function is worthless for vnodes that represent directories. Maybe we
 * could just do a sync if they try an fsync on a directory file.
 */
int
msdosfs_fsync(void *v)
{
	struct vop_fsync_args *ap = v;
	struct vnode *vp = ap->a_vp;

	vflushbuf(vp, ap->a_waitfor == MNT_WAIT);
	return (deupdat(VTODE(vp), ap->a_waitfor == MNT_WAIT));
}

/*
 * Flush the blocks of a file to disk.
 *
 * This function is worthless for vnodes that represent directories. Maybe we
 * could just do a sync if they try an fsync on a directory file.
 */
int
msdosfs_remove(void *v)
{
	struct vop_remove_args *ap = v;
	struct denode *dep = VTODE(ap->a_vp);
	struct denode *ddep = VTODE(ap->a_dvp);
	int error;

	if (ap->a_vp->v_type == VDIR)
		error = EPERM;
	else
		error = removede(ddep, dep);

	VN_KNOTE(ap->a_vp, NOTE_DELETE);
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_remove(), dep %p, v_usecount %d\n", dep,
	    ap->a_vp->v_usecount);
#endif
	if (ddep == dep)
		vrele(ap->a_vp);
	else
		vput(ap->a_vp);	/* causes msdosfs_inactive() to be called
				 * via vrele() */
	vput(ap->a_dvp);
	return (error);
}

/*
 * DOS filesystems don't know what links are. But since we already called
 * msdosfs_lookup() with create and lockparent, the parent is locked so we
 * have to free it before we return the error.
 */
int
msdosfs_link(void *v)
{
	struct vop_link_args *ap = v;

	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EOPNOTSUPP);
}

/*
 * Renames on files require moving the denode to a new hash queue since the
 * denode's location is used to compute which hash queue to put the file
 * in. Unless it is a rename in place.  For example "mv a b".
 *
 * What follows is the basic algorithm:
 *
 * if (file move) {
 *	if (dest file exists) {
 *		remove dest file
 *	}
 *	if (dest and src in same directory) {
 *		rewrite name in existing directory slot
 *	} else {
 *		write new entry in dest directory
 *		update offset and dirclust in denode
 *		move denode to new hash chain
 *		clear old directory entry
 *	}
 * } else {
 *	directory move
 *	if (dest directory exists) {
 *		if (dest is not empty) {
 *			return ENOTEMPTY
 *		}
 *		remove dest directory
 *	}
 *	if (dest and src in same directory) {
 *		rewrite name in existing entry
 *	} else {
 *		be sure dest is not a child of src directory
 *		write entry in dest directory
 *		update "." and ".." in moved directory
 *		update offset and dirclust in denode
 *		move denode to new hash chain
 *		clear old directory entry for moved directory
 *	}
 * }
 *
 * On entry:
 *	source's parent directory is unlocked
 *	source file or directory is unlocked
 *	destination's parent directory is locked
 *	destination file or directory is locked if it exists
 *
 * On exit:
 *	all denodes should be released
 *
 * Notes:
 * I'm not sure how the memory containing the pathnames pointed at by the
 * componentname structures is freed, there may be some memory bleeding
 * for each rename done.
 */
int
msdosfs_rename(void *v)
{
	struct vop_rename_args *ap = v;
	struct vnode *tvp = ap->a_tvp;
	struct vnode *tdvp = ap->a_tdvp;
	struct vnode *fvp = ap->a_fvp;
	struct vnode *fdvp = ap->a_fdvp;
	struct componentname *tcnp = ap->a_tcnp;
	struct componentname *fcnp = ap->a_fcnp;
	struct proc *p = curproc; /* XXX */
	struct denode *ip, *xp, *dp, *zp;
	u_char toname[11], oldname[11];
	uint32_t from_diroffset, to_diroffset;
	u_char to_count;
	int doingdirectory = 0, newparent = 0;
	int error;
	uint32_t cn, pcl;
	daddr_t bn;
	struct msdosfsmount *pmp;
	struct direntry *dotdotp;
	struct buf *bp;

	pmp = VFSTOMSDOSFS(fdvp->v_mount);

#ifdef DIAGNOSTIC
	if ((tcnp->cn_flags & HASBUF) == 0 ||
	    (fcnp->cn_flags & HASBUF) == 0)
		panic("msdosfs_rename: no name");
#endif
	/*
	 * Check for cross-device rename.
	 */
	if ((fvp->v_mount != tdvp->v_mount) ||
	    (tvp && (fvp->v_mount != tvp->v_mount))) {
		error = EXDEV;
abortit:
		VOP_ABORTOP(tdvp, tcnp);
		if (tdvp == tvp)
			vrele(tdvp);
		else
			vput(tdvp);
		if (tvp)
			vput(tvp);
		VOP_ABORTOP(fdvp, fcnp);
		vrele(fdvp);
		vrele(fvp);
		return (error);
	}

	/*
	 * If source and dest are the same, do nothing.
	 */
	if (tvp == fvp) {
		error = 0;
		goto abortit;
	}

	/* */
	if ((error = vn_lock(fvp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
		goto abortit;
	dp = VTODE(fdvp);
	ip = VTODE(fvp);

	/*
	 * Be sure we are not renaming ".", "..", or an alias of ".". This
	 * leads to a crippled directory tree.  It's pretty tough to do a
	 * "ls" or "pwd" with the "." directory entry missing, and "cd .."
	 * doesn't work if the ".." entry is missing.
	 */
	if (ip->de_Attributes & ATTR_DIRECTORY) {
		/*
		 * Avoid ".", "..", and aliases of "." for obvious reasons.
		 */
		if ((fcnp->cn_namelen == 1 && fcnp->cn_nameptr[0] == '.') ||
		    dp == ip ||
		    (fcnp->cn_flags & ISDOTDOT) ||
		    (tcnp->cn_flags & ISDOTDOT) ||
		    (ip->de_flag & DE_RENAME)) {
			VOP_UNLOCK(fvp, p);
			error = EINVAL;
			goto abortit;
		}
		ip->de_flag |= DE_RENAME;
		doingdirectory++;
	}
	VN_KNOTE(fdvp, NOTE_WRITE);	/* XXX right place? */

	/*
	 * When the target exists, both the directory
	 * and target vnodes are returned locked.
	 */
	dp = VTODE(tdvp);
	xp = tvp ? VTODE(tvp) : NULL;
	/*
	 * Remember direntry place to use for destination
	 */
	to_diroffset = dp->de_fndoffset;
	to_count = dp->de_fndcnt;

	/*
	 * If ".." must be changed (ie the directory gets a new
	 * parent) then the source directory must not be in the
	 * directory hierarchy above the target, as this would
	 * orphan everything below the source directory. Also
	 * the user must have write permission in the source so
	 * as to be able to change "..". We must repeat the call
	 * to namei, as the parent directory is unlocked by the
	 * call to doscheckpath().
	 */
	error = VOP_ACCESS(fvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
	VOP_UNLOCK(fvp, p);
	if (VTODE(fdvp)->de_StartCluster != VTODE(tdvp)->de_StartCluster)
		newparent = 1;
	vrele(fdvp);
	if (doingdirectory && newparent) {
		if (error)	/* write access check above */
			goto bad1;
		if (xp != NULL)
			vput(tvp);
		/*
		 * doscheckpath() vput()'s dp,
		 * so we have to do a relookup afterwards
		 */
		if ((error = doscheckpath(ip, dp)) != 0)
			goto out;
		if ((tcnp->cn_flags & SAVESTART) == 0)
			panic("msdosfs_rename: lost to startdir");
		if ((error = vfs_relookup(tdvp, &tvp, tcnp)) != 0)
			goto out;
		dp = VTODE(tdvp);
		xp = tvp ? VTODE(tvp) : NULL;
	}

	VN_KNOTE(tdvp, NOTE_WRITE);

	if (xp != NULL) {
		/*
		 * Target must be empty if a directory and have no links
		 * to it. Also, ensure source and target are compatible
		 * (both directories, or both not directories).
		 */
		if (xp->de_Attributes & ATTR_DIRECTORY) {
			if (!dosdirempty(xp)) {
				error = ENOTEMPTY;
				goto bad1;
			}
			if (!doingdirectory) {
				error = ENOTDIR;
				goto bad1;
			}
			cache_purge(tdvp);
		} else if (doingdirectory) {
			error = EISDIR;
			goto bad1;
		}
		if ((error = removede(dp, xp)) != 0)
			goto bad1;
		VN_KNOTE(tvp, NOTE_DELETE);
		vput(tvp);
		xp = NULL;
	}

	/*
	 * Convert the filename in tcnp into a dos filename. We copy this
	 * into the denode and directory entry for the destination
	 * file/directory.
	 */
	if ((error = uniqdosname(VTODE(tdvp), tcnp, toname)) != 0)
		goto bad1;

	/*
	 * Since from wasn't locked at various places above,
	 * have to do a relookup here.
	 */
	fcnp->cn_flags &= ~MODMASK;
	fcnp->cn_flags |= LOCKPARENT | LOCKLEAF;
	if ((fcnp->cn_flags & SAVESTART) == 0)
		panic("msdosfs_rename: lost from startdir");
	if (!newparent)
		VOP_UNLOCK(tdvp, p);
	(void) vfs_relookup(fdvp, &fvp, fcnp);
	if (fvp == NULL) {
		/*
		 * From name has disappeared.
		 */
		if (doingdirectory)
			panic("rename: lost dir entry");
		vrele(ap->a_fvp);
		if (newparent)
			VOP_UNLOCK(tdvp, p);
		vrele(tdvp);
		return 0;
	}
	xp = VTODE(fvp);
	zp = VTODE(fdvp);
	from_diroffset = zp->de_fndoffset;

	/*
	 * Ensure that the directory entry still exists and has not
	 * changed till now. If the source is a file the entry may
	 * have been unlinked or renamed. In either case there is
	 * no further work to be done. If the source is a directory
	 * then it cannot have been rmdir'ed or renamed; this is
	 * prohibited by the DE_RENAME flag.
	 */
	if (xp != ip) {
		if (doingdirectory)
			panic("rename: lost dir entry");
		vrele(ap->a_fvp);
		if (newparent)
			VOP_UNLOCK(fdvp, p);
		xp = NULL;
	} else {
		vrele(fvp);
		xp = NULL;

		/*
		 * First write a new entry in the destination
		 * directory and mark the entry in the source directory
		 * as deleted.  Then move the denode to the correct hash
		 * chain for its new location in the filesystem.  And, if
		 * we moved a directory, then update its .. entry to point
		 * to the new parent directory.
		 */
		bcopy(ip->de_Name, oldname, 11);
		bcopy(toname, ip->de_Name, 11);	/* update denode */
		dp->de_fndoffset = to_diroffset;
		dp->de_fndcnt = to_count;
		error = createde(ip, dp, NULL, tcnp);
		if (error) {
			bcopy(oldname, ip->de_Name, 11);
			if (newparent)
				VOP_UNLOCK(fdvp, p);
			goto bad;
		}
		ip->de_refcnt++;
		zp->de_fndoffset = from_diroffset;
		if ((error = removede(zp, ip)) != 0) {
			/* XXX should really panic here, fs is corrupt */
			if (newparent)
				VOP_UNLOCK(fdvp, p);
			goto bad;
		}

		cache_purge(fvp);

		if (!doingdirectory) {
			error = pcbmap(dp, de_cluster(pmp, to_diroffset), 0,
				       &ip->de_dirclust, 0);
			if (error) {
				/* XXX should really panic here, fs is corrupt */
				if (newparent)
					VOP_UNLOCK(fdvp, p);
				goto bad;
			}
			ip->de_diroffset = to_diroffset;
			if (ip->de_dirclust != MSDOSFSROOT)
				ip->de_diroffset &= pmp->pm_crbomask;
		}
		reinsert(ip);
		if (newparent)
			VOP_UNLOCK(fdvp, p);
	}

	/*
	 * If we moved a directory to a new parent directory, then we must
	 * fixup the ".." entry in the moved directory.
	 */
	if (doingdirectory && newparent) {
		cn = ip->de_StartCluster;
		if (cn == MSDOSFSROOT) {
			/* this should never happen */
			panic("msdosfs_rename: updating .. in root directory?");
		} else
			bn = cntobn(pmp, cn);
		error = bread(pmp->pm_devvp, bn, pmp->pm_bpcluster, &bp);
		if (error) {
			/* XXX should really panic here, fs is corrupt */
			brelse(bp);
			goto bad;
		}
		dotdotp = (struct direntry *)bp->b_data;
		putushort(dotdotp[0].deStartCluster, cn);
		pcl = dp->de_StartCluster;
		if (FAT32(pmp) && pcl == pmp->pm_rootdirblk)
			pcl = 0;
		putushort(dotdotp[1].deStartCluster, pcl);
		if (FAT32(pmp)) {
			putushort(dotdotp[0].deHighClust, cn >> 16);
			putushort(dotdotp[1].deHighClust, pcl >> 16);
		}
		if ((error = bwrite(bp)) != 0) {
			/* XXX should really panic here, fs is corrupt */
			goto bad;
		}
	}

	VN_KNOTE(fvp, NOTE_RENAME);

bad:
	VOP_UNLOCK(fvp, p);
	vrele(fdvp);
bad1:
	if (xp)
		vput(tvp);
	vput(tdvp);
out:
	ip->de_flag &= ~DE_RENAME;
	vrele(fvp);
	return (error);

}

struct {
	struct direntry dot;
	struct direntry dotdot;
} dosdirtemplate = {
	{	".       ", "   ",			/* the . entry */
		ATTR_DIRECTORY,				/* file attribute */
		CASE_LOWER_BASE | CASE_LOWER_EXT,	/* lower case */
		0,					/* create time 100ths */
		{ 0, 0 }, { 0, 0 },			/* create time & date */
		{ 0, 0 },				/* access date */
		{ 0, 0 },				/* high bits of start cluster */
		{ 210, 4 }, { 210, 4 },			/* modify time & date */
		{ 0, 0 },				/* startcluster */
		{ 0, 0, 0, 0 }				/* filesize */
	},
	{	"..      ", "   ",			/* the .. entry */
		ATTR_DIRECTORY,				/* file attribute */
		CASE_LOWER_BASE | CASE_LOWER_EXT,	/* lower case */
		0,					/* create time 100ths */
		{ 0, 0 }, { 0, 0 },			/* create time & date */
		{ 0, 0 },				/* access date */
		{ 0, 0 },				/* high bits of start cluster */
		{ 210, 4 }, { 210, 4 },			/* modify time & date */
		{ 0, 0 },				/* startcluster */
		{ 0, 0, 0, 0 }				/* filesize */
	}
};

int
msdosfs_mkdir(void *v)
{
	struct vop_mkdir_args *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct denode ndirent;
	struct denode *dep;
	struct denode *pdep = VTODE(ap->a_dvp);
	int error;
	daddr_t bn;
	uint32_t newcluster, pcl;
	struct direntry *denp;
	struct msdosfsmount *pmp = pdep->de_pmp;
	struct buf *bp;
	struct timespec ts;

	/*
	 * If this is the root directory and there is no space left we
	 * can't do anything.  This is because the root directory can not
	 * change size.
	 */
	if (pdep->de_StartCluster == MSDOSFSROOT
	    && pdep->de_fndoffset >= pdep->de_FileSize) {
		error = ENOSPC;
		goto bad2;
	}

	/*
	 * Allocate a cluster to hold the about to be created directory.
	 */
	error = clusteralloc(pmp, 0, 1, CLUST_EOFE, &newcluster, NULL);
	if (error)
		goto bad2;

	bzero(&ndirent, sizeof(ndirent));
	ndirent.de_pmp = pmp;
	ndirent.de_flag = DE_ACCESS | DE_CREATE | DE_UPDATE;
	getnanotime(&ts);
	DETIMES(&ndirent, &ts, &ts, &ts);

	/*
	 * Now fill the cluster with the "." and ".." entries. And write
	 * the cluster to disk.  This way it is there for the parent
	 * directory to be pointing at if there were a crash.
	 */
	bn = cntobn(pmp, newcluster);
	/* always succeeds */
	bp = getblk(pmp->pm_devvp, bn, pmp->pm_bpcluster, 0, 0);
	bzero(bp->b_data, pmp->pm_bpcluster);
	bcopy(&dosdirtemplate, bp->b_data, sizeof dosdirtemplate);
	denp = (struct direntry *)bp->b_data;
	putushort(denp[0].deStartCluster, newcluster);
	putushort(denp[0].deCDate, ndirent.de_CDate);
	putushort(denp[0].deCTime, ndirent.de_CTime);
	denp[0].deCTimeHundredth = ndirent.de_CTimeHundredth;
	putushort(denp[0].deADate, ndirent.de_ADate);
	putushort(denp[0].deMDate, ndirent.de_MDate);
	putushort(denp[0].deMTime, ndirent.de_MTime);
	pcl = pdep->de_StartCluster;
	if (FAT32(pmp) && pcl == pmp->pm_rootdirblk)
		pcl = 0;
	putushort(denp[1].deStartCluster, pcl);
	putushort(denp[1].deCDate, ndirent.de_CDate);
	putushort(denp[1].deCTime, ndirent.de_CTime);
	denp[1].deCTimeHundredth = ndirent.de_CTimeHundredth;
	putushort(denp[1].deADate, ndirent.de_ADate);
	putushort(denp[1].deMDate, ndirent.de_MDate);
	putushort(denp[1].deMTime, ndirent.de_MTime);
	if (FAT32(pmp)) {
		putushort(denp[0].deHighClust, newcluster >> 16);
		putushort(denp[1].deHighClust, pdep->de_StartCluster >> 16);
	}

	if ((error = bwrite(bp)) != 0)
		goto bad;

	/*
	 * Now build up a directory entry pointing to the newly allocated
	 * cluster.  This will be written to an empty slot in the parent
	 * directory.
	 */
#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("msdosfs_mkdir: no name");
#endif
	if ((error = uniqdosname(pdep, cnp, ndirent.de_Name)) != 0)
		goto bad;

	ndirent.de_Attributes = ATTR_DIRECTORY;
	ndirent.de_StartCluster = newcluster;
	ndirent.de_FileSize = 0;
	ndirent.de_dev = pdep->de_dev;
	ndirent.de_devvp = pdep->de_devvp;
	if ((error = createde(&ndirent, pdep, &dep, cnp)) != 0)
		goto bad;
	if ((cnp->cn_flags & SAVESTART) == 0)
		pool_put(&namei_pool, cnp->cn_pnbuf);
	VN_KNOTE(ap->a_dvp, NOTE_WRITE | NOTE_LINK);
	vput(ap->a_dvp);
	*ap->a_vpp = DETOV(dep);
	return (0);

bad:
	clusterfree(pmp, newcluster, NULL);
bad2:
	pool_put(&namei_pool, cnp->cn_pnbuf);
	vput(ap->a_dvp);
	return (error);
}

int
msdosfs_rmdir(void *v)
{
	struct vop_rmdir_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct denode *ip, *dp;
	int error;

	ip = VTODE(vp);
	dp = VTODE(dvp);
	/*
	 * No rmdir "." please.
	 */
	if (dp == ip) {
		vrele(dvp);
		vput(vp);
		return (EINVAL);
	}
	/*
	 * Verify the directory is empty (and valid).
	 * (Rmdir ".." won't be valid since
	 *  ".." will contain a reference to
	 *  the current directory and thus be
	 *  non-empty.)
	 */
	error = 0;
	if (!dosdirempty(ip) || ip->de_flag & DE_RENAME) {
		error = ENOTEMPTY;
		goto out;
	}

	VN_KNOTE(dvp, NOTE_WRITE | NOTE_LINK);

	/*
	 * Delete the entry from the directory.  For dos filesystems this
	 * gets rid of the directory entry on disk, the in memory copy
	 * still exists but the de_refcnt is <= 0.  This prevents it from
	 * being found by deget().  When the vput() on dep is done we give
	 * up access and eventually msdosfs_reclaim() will be called which
	 * will remove it from the denode cache.
	 */
	if ((error = removede(dp, ip)) != 0)
		goto out;
	/*
	 * This is where we decrement the link count in the parent
	 * directory.  Since dos filesystems don't do this we just purge
	 * the name cache and let go of the parent directory denode.
	 */
	cache_purge(dvp);
	vput(dvp);
	dvp = NULL;
	/*
	 * Truncate the directory that is being deleted.
	 */
	error = detrunc(ip, (uint32_t)0, IO_SYNC, cnp->cn_cred, cnp->cn_proc);
	cache_purge(vp);
out:
	if (dvp)
		vput(dvp);
	VN_KNOTE(vp, NOTE_DELETE);
	vput(vp);
	return (error);
}

/*
 * DOS filesystems don't know what symlinks are.
 */
int
msdosfs_symlink(void *v)
{
	struct vop_symlink_args *ap = v;

	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EOPNOTSUPP);
}

int
msdosfs_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	int error = 0;
	int diff;
	long n;
	int blsize;
	long on;
	long lost;
	long count;
	uint32_t dirsperblk;
	uint32_t cn, lbn;
	uint32_t fileno;
	long bias = 0;
	daddr_t bn;
	struct buf *bp;
	struct denode *dep = VTODE(ap->a_vp);
	struct msdosfsmount *pmp = dep->de_pmp;
	struct direntry *dentp;
	struct dirent dirbuf;
	struct uio *uio = ap->a_uio;
	off_t offset, wlast = -1;
	int chksum = -1;

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_readdir(): vp %p, uio %p, cred %p, eofflagp %p\n",
	    ap->a_vp, uio, ap->a_cred, ap->a_eofflag);
#endif

	/*
	 * msdosfs_readdir() won't operate properly on regular files since
	 * it does i/o only with the filesystem vnode, and hence can
	 * retrieve the wrong block from the buffer cache for a plain file.
	 * So, fail attempts to readdir() on a plain file.
	 */
	if ((dep->de_Attributes & ATTR_DIRECTORY) == 0)
		return (ENOTDIR);

	/*
	 * To be safe, initialize dirbuf
	 */
	bzero(&dirbuf, sizeof(dirbuf));

	/*
	 * If the user buffer is smaller than the size of one dos directory
	 * entry or the file offset is not a multiple of the size of a
	 * directory entry, then we fail the read.
	 */
	count = uio->uio_resid & ~(sizeof(struct direntry) - 1);
	offset = uio->uio_offset;
	if (count < sizeof(struct direntry) ||
	    (offset & (sizeof(struct direntry) - 1)))
		return (EINVAL);
	lost = uio->uio_resid - count;
	uio->uio_resid = count;

	dirsperblk = pmp->pm_BytesPerSec / sizeof(struct direntry);

	/*
	 * If they are reading from the root directory then, we simulate
	 * the . and .. entries since these don't exist in the root
	 * directory.  We also set the offset bias to make up for having to
	 * simulate these entries. By this I mean that at file offset 64 we
	 * read the first entry in the root directory that lives on disk.
	 */
	if (dep->de_StartCluster == MSDOSFSROOT
	    || (FAT32(pmp) && dep->de_StartCluster == pmp->pm_rootdirblk)) {
#if 0
		printf("msdosfs_readdir(): going after . or .. in root dir, offset %d\n",
		    offset);
#endif
		bias = 2 * sizeof(struct direntry);
		if (offset < bias) {
			for (n = (int)offset / sizeof(struct direntry);
			     n < 2; n++) {
			        if (FAT32(pmp))
				        dirbuf.d_fileno = pmp->pm_rootdirblk;
				else
				        dirbuf.d_fileno = 1;
				dirbuf.d_type = DT_DIR;
				switch (n) {
				case 0:
					dirbuf.d_namlen = 1;
					strlcpy(dirbuf.d_name, ".",
					    sizeof dirbuf.d_name);
					break;
				case 1:
					dirbuf.d_namlen = 2;
					strlcpy(dirbuf.d_name, "..",
					    sizeof dirbuf.d_name);
					break;
				}
				dirbuf.d_reclen = DIRENT_SIZE(&dirbuf);
				dirbuf.d_off = offset +
				    sizeof(struct direntry);
				if (uio->uio_resid < dirbuf.d_reclen)
					goto out;
				error = uiomove(&dirbuf, dirbuf.d_reclen, uio);
				if (error)
					goto out;
				offset = dirbuf.d_off;
			}
		}
	}

	while (uio->uio_resid > 0) {
		lbn = de_cluster(pmp, offset - bias);
		on = (offset - bias) & pmp->pm_crbomask;
		n = min(pmp->pm_bpcluster - on, uio->uio_resid);
		diff = dep->de_FileSize - (offset - bias);
		if (diff <= 0)
			break;
		n = min(n, diff);
		if ((error = pcbmap(dep, lbn, &bn, &cn, &blsize)) != 0)
			break;
		error = bread(pmp->pm_devvp, bn, blsize, &bp);
		if (error) {
			brelse(bp);
			return (error);
		}
		n = min(n, blsize - bp->b_resid);

		/*
		 * Convert from dos directory entries to fs-independent
		 * directory entries.
		 */
		for (dentp = (struct direntry *)(bp->b_data + on);
		     (char *)dentp < bp->b_data + on + n;
		     dentp++, offset += sizeof(struct direntry)) {
#if 0
			printf("rd: dentp %08x prev %08x crnt %08x deName %02x attr %02x\n",
			    dentp, prev, crnt, dentp->deName[0], dentp->deAttributes);
#endif
			/*
			 * If this is an unused entry, we can stop.
			 */
			if (dentp->deName[0] == SLOT_EMPTY) {
				brelse(bp);
				goto out;
			}
			/*
			 * Skip deleted entries.
			 */
			if (dentp->deName[0] == SLOT_DELETED) {
				chksum = -1;
				wlast = -1;
				continue;
			}

			/*
			 * Handle Win95 long directory entries
			 */
			if (dentp->deAttributes == ATTR_WIN95) {
				struct winentry *wep;
				if (pmp->pm_flags & MSDOSFSMNT_SHORTNAME)
					continue;
				wep = (struct winentry *)dentp;
				chksum = win2unixfn(wep, &dirbuf, chksum);
				if (wep->weCnt & WIN_LAST)
					wlast = offset;
				continue;
			}

			/*
			 * Skip volume labels
			 */
			if (dentp->deAttributes & ATTR_VOLUME) {
				chksum = -1;
				wlast = -1;
				continue;
			}

			/*
			 * This computation of d_fileno must match
			 * the computation of va_fileid in
			 * msdosfs_getattr.
			 */
			fileno = getushort(dentp->deStartCluster);
			if (FAT32(pmp))
			    fileno |= getushort(dentp->deHighClust) << 16;

			if (dentp->deAttributes & ATTR_DIRECTORY) {
				/* Special-case root */
				if (fileno == MSDOSFSROOT)  {
					fileno = FAT32(pmp) ?
					    pmp->pm_rootdirblk : 1;
				}

				dirbuf.d_fileno = fileno;
				dirbuf.d_type = DT_DIR;
			} else {
				if (getulong(dentp->deFileSize) == 0) {
					uint64_t fileno64;

					fileno64 = (cn == MSDOSFSROOT) ?
					    roottobn(pmp, 0) : cntobn(pmp, cn);

					fileno64 *= dirsperblk;
					fileno64 += dentp -
					    (struct direntry *)bp->b_data;

					fileno = fileidhash(fileno64);
				}

				dirbuf.d_fileno = fileno;
				dirbuf.d_type = DT_REG;
			}

			if (chksum != winChksum(dentp->deName))
				dirbuf.d_namlen = dos2unixfn(dentp->deName,
				    (u_char *)dirbuf.d_name,
				    pmp->pm_flags & MSDOSFSMNT_SHORTNAME);
			else
				dirbuf.d_name[dirbuf.d_namlen] = 0;
			chksum = -1;
			dirbuf.d_reclen = DIRENT_SIZE(&dirbuf);
			dirbuf.d_off = offset + sizeof(struct direntry);
			if (uio->uio_resid < dirbuf.d_reclen) {
				brelse(bp);
				/* Remember long-name offset. */
				if (wlast != -1)
					offset = wlast;
				goto out;
			}
			wlast = -1;
			error = uiomove(&dirbuf, dirbuf.d_reclen, uio);
			if (error) {
				brelse(bp);
				goto out;
			}
		}
		brelse(bp);
	}

out:
	uio->uio_offset = offset;
	uio->uio_resid += lost;
	if (dep->de_FileSize - (offset - bias) <= 0)
		*ap->a_eofflag = 1;
	else
		*ap->a_eofflag = 0;
	return (error);
}

/*
 * DOS filesystems don't know what symlinks are.
 */
int
msdosfs_readlink(void *v)
{
#if 0
	struct vop_readlink_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *ap;
#endif

	return (EINVAL);
}

int
msdosfs_lock(void *v)
{
	struct vop_lock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	return rrw_enter(&VTODE(vp)->de_lock, ap->a_flags & LK_RWFLAGS);
}

int
msdosfs_unlock(void *v)
{
	struct vop_unlock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	rrw_exit(&VTODE(vp)->de_lock);
	return 0;
}

int
msdosfs_islocked(void *v)
{
	struct vop_islocked_args *ap = v;

	return rrw_status(&VTODE(ap->a_vp)->de_lock);
}

/*
 * vp  - address of vnode file the file
 * bn  - which cluster we are interested in mapping to a filesystem block number.
 * vpp - returns the vnode for the block special file holding the filesystem
 *	 containing the file of interest
 * bnp - address of where to return the filesystem relative block number
 */
int
msdosfs_bmap(void *v)
{
	struct vop_bmap_args *ap = v;
	struct denode *dep = VTODE(ap->a_vp);
	struct msdosfsmount *pmp = dep->de_pmp;

	if (ap->a_vpp != NULL)
		*ap->a_vpp = dep->de_devvp;
	if (ap->a_bnp == NULL)
		return (0);
	if (ap->a_runp) {
		/*
		 * Sequential clusters should be counted here.
		 */
		*ap->a_runp = 0;
	}
	return (pcbmap(dep, de_bn2cn(pmp, ap->a_bn), ap->a_bnp, 0, 0));
}

int
msdosfs_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	struct buf *bp = ap->a_bp;
	struct denode *dep = VTODE(bp->b_vp);
	struct vnode *vp;
	int error = 0;
	int s;

	if (bp->b_vp->v_type == VBLK || bp->b_vp->v_type == VCHR)
		panic("msdosfs_strategy: spec");
	/*
	 * If we don't already know the filesystem relative block number
	 * then get it using pcbmap().  If pcbmap() returns the block
	 * number as -1 then we've got a hole in the file.  DOS filesystems
	 * don't allow files with holes, so we shouldn't ever see this.
	 */
	if (bp->b_blkno == bp->b_lblkno) {
		error = pcbmap(dep, de_bn2cn(dep->de_pmp, bp->b_lblkno),
			       &bp->b_blkno, 0, 0);
		if (error)
			bp->b_blkno = -1;
		if (bp->b_blkno == -1)
			clrbuf(bp);
	}
	if (bp->b_blkno == -1) {
		s = splbio();
		biodone(bp);
		splx(s);
		return (error);
	}

	/*
	 * Read/write the block from/to the disk that contains the desired
	 * file block.
	 */

	vp = dep->de_devvp;
	bp->b_dev = vp->v_rdev;
	(vp->v_op->vop_strategy)(ap);
	return (0);
}

int
msdosfs_print(void *v)
{
	struct vop_print_args *ap = v;
	struct denode *dep = VTODE(ap->a_vp);

	printf(
	    "tag VT_MSDOSFS, startcluster %u, dircluster %u, diroffset %u ",
	    dep->de_StartCluster, dep->de_dirclust, dep->de_diroffset);
	printf(" dev %d, %d, %s\n",
	    major(dep->de_dev), minor(dep->de_dev),
	    VOP_ISLOCKED(ap->a_vp) ? "(LOCKED)" : "");
#ifdef DIAGNOSTIC
	printf("\n");
#endif

	return (0);
}

int
msdosfs_advlock(void *v)
{
	struct vop_advlock_args *ap = v;
	struct denode *dep = VTODE(ap->a_vp);

	return (lf_advlock(&dep->de_lockf, dep->de_FileSize, ap->a_id, ap->a_op,
	    ap->a_fl, ap->a_flags));
}

int
msdosfs_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	struct msdosfsmount *pmp = VTODE(ap->a_vp)->de_pmp;
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = 1;
		break;
	case _PC_NAME_MAX:
		*ap->a_retval = pmp->pm_flags & MSDOSFSMNT_LONGNAME ? WIN_MAXLEN : 12;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	case _PC_NO_TRUNC:
		*ap->a_retval = 0;
		break;
	case _PC_TIMESTAMP_RESOLUTION:
		*ap->a_retval = 2000000000;	/* 2 billion nanoseconds */
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * Thomas Wang's hash function, severely hacked to always set the high
 * bit on the number it returns (so no longer a proper hash function).
 */
static uint32_t
fileidhash(uint64_t fileid)
{
	uint64_t c1 = 0x6e5ea73858134343LL;
	uint64_t c2 = 0xb34e8f99a2ec9ef5LL;

	/*
	 * We now have the original fileid value, as 64-bit value.
	 * We need to reduce it to 32-bits, with the top bit set.
	 */
	fileid ^= ((c1 ^ fileid) >> 32);
	fileid *= c1;
	fileid ^= ((c2 ^ fileid) >> 31);
	fileid *= c2;
	fileid ^= ((c1 ^ fileid) >> 32);

	return (uint32_t)(fileid | 0x80000000);
}

/* Global vfs data structures for msdosfs */
struct vops msdosfs_vops = {
	.vop_lookup	= msdosfs_lookup,
	.vop_create	= msdosfs_create,
	.vop_mknod	= msdosfs_mknod,
	.vop_open	= msdosfs_open,
	.vop_close	= msdosfs_close,
	.vop_access	= msdosfs_access,
	.vop_getattr	= msdosfs_getattr,
	.vop_setattr	= msdosfs_setattr,
	.vop_read	= msdosfs_read,
	.vop_write	= msdosfs_write,
	.vop_ioctl	= msdosfs_ioctl,
	.vop_poll	= msdosfs_poll,
	.vop_kqfilter	= msdosfs_kqfilter,
	.vop_fsync	= msdosfs_fsync,
	.vop_remove	= msdosfs_remove,
	.vop_link	= msdosfs_link,
	.vop_rename	= msdosfs_rename,
	.vop_mkdir	= msdosfs_mkdir,
	.vop_rmdir	= msdosfs_rmdir,
	.vop_symlink	= msdosfs_symlink,
	.vop_readdir	= msdosfs_readdir,
	.vop_readlink	= msdosfs_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= msdosfs_inactive,
	.vop_reclaim	= msdosfs_reclaim,
	.vop_lock	= msdosfs_lock,
	.vop_unlock	= msdosfs_unlock,
	.vop_bmap	= msdosfs_bmap,
	.vop_strategy	= msdosfs_strategy,
	.vop_print	= msdosfs_print,
	.vop_islocked	= msdosfs_islocked,
	.vop_pathconf	= msdosfs_pathconf,
	.vop_advlock	= msdosfs_advlock,
	.vop_bwrite	= vop_generic_bwrite,
	.vop_revoke	= vop_generic_revoke,
};

struct filterops msdosfsread_filtops =
	{ 1, NULL, filt_msdosfsdetach, filt_msdosfsread };
struct filterops msdosfswrite_filtops =
	{ 1, NULL, filt_msdosfsdetach, filt_msdosfswrite };
struct filterops msdosfsvnode_filtops =
	{ 1, NULL, filt_msdosfsdetach, filt_msdosfsvnode };

int
msdosfs_kqfilter(void *v)
{
	struct vop_kqfilter_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct knote *kn = ap->a_kn;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &msdosfsread_filtops;
		break;
	case EVFILT_WRITE:
		kn->kn_fop = &msdosfswrite_filtops;
		break;
	case EVFILT_VNODE:
		kn->kn_fop = &msdosfsvnode_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)vp;

	SLIST_INSERT_HEAD(&vp->v_selectinfo.si_note, kn, kn_selnext);

	return (0);
}

void
filt_msdosfsdetach(struct knote *kn)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;

	SLIST_REMOVE(&vp->v_selectinfo.si_note, kn, knote, kn_selnext);
}

int
filt_msdosfsread(struct knote *kn, long hint)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;
	struct denode *dep = VTODE(vp);

	/*
	 * filesystem is gone, so set the EOF flag and schedule
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = dep->de_FileSize - kn->kn_fp->f_offset;
	if (kn->kn_data == 0 && kn->kn_sfflags & NOTE_EOF) {
		kn->kn_fflags |= NOTE_EOF;
		return (1);
	}
	return (kn->kn_data != 0);
}

int
filt_msdosfswrite(struct knote *kn, long hint)
{
	/*
	 * filesystem is gone, so set the EOF flag and schedule
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = 0;
	return (1);
}

int
filt_msdosfsvnode(struct knote *kn, long hint)
{
	if (kn->kn_sfflags & hint)
		kn->kn_fflags |= hint;
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	return (kn->kn_fflags != 0);
}
@


1.112
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.111 2016/05/21 18:11:36 natano Exp $	*/
a79 1
int msdosfs_bmaparray(struct vnode *, daddr_t, daddr_t *, int *);
d86 1
d512 8
a523 4
	int isadir, error = 0;
	uint32_t n, diff, size, on;
	struct buf *bp;
	daddr_t cn;
d538 1
a538 2
		cn = de_cluster(pmp, uio->uio_offset);
		size = pmp->pm_bpcluster;
d551 6
d563 1
a563 4
			error = pcbmap(dep, cn, &cn, 0, &size);
			if (error)
				return (error);
			error = bread(pmp->pm_devvp, cn, size, &bp);
d565 7
a571 2
			if (de_cn2off(pmp, cn + 1) >= dep->de_FileSize)
				error = bread(vp, cn, size, &bp);
d573 3
a575 1
				error = bread_cluster(vp, cn, size, &bp);
d604 1
a604 1
	daddr_t cn;
d681 1
a681 4
		croffset = uio->uio_offset & pmp->pm_crbomask;
		cn = de_cluster(pmp, uio->uio_offset);

		if (cn > lastcn) {
d686 4
a689 3
		if (croffset == 0 &&
		    (de_cluster(pmp, uio->uio_offset + uio->uio_resid) > cn ||
		     (uio->uio_offset + uio->uio_resid) >= dep->de_FileSize)) {
d695 1
a695 1
			bp = getblk(thisvp, cn, pmp->pm_bpcluster, 0, 0);
d702 3
a704 1
				error = pcbmap(dep, bp->b_lblkno, &cn, 0, 0);
a706 2
				else
					bp->b_blkno = cn;
d716 1
a716 2
			 * The block we need to write into exists, so
			 * read it in.
d718 1
a718 1
			error = bread(thisvp, cn, pmp->pm_bpcluster, &bp);
d725 1
d1758 1
a1758 1
 * bn  - which cluster we are interested in mapping to a filesystem block number
d1768 1
d1774 1
a1774 16

	return (msdosfs_bmaparray(ap->a_vp, ap->a_bn, ap->a_bnp, ap->a_runp));
}

int
msdosfs_bmaparray(struct vnode *vp, daddr_t cn, daddr_t *bnp, int *runp)
{
	struct denode *dep = VTODE(vp);
	struct msdosfsmount *pmp = dep->de_pmp;
	struct mount *mp;
	int error, maxrun = 0, run;
	daddr_t daddr;

	mp = vp->v_mount;

	if (runp) {
d1776 1
a1776 4
		 * XXX
		 * If MAXBSIZE is the largest transfer the disks can handle,
		 * we probably want maxrun to be 1 block less so that we
		 * don't create a block larger than the device can handle.
d1778 1
a1778 3
		*runp = 0;
		maxrun = min(MAXBSIZE / mp->mnt_stat.f_iosize - 1,
		    pmp->pm_maxcluster - cn);
d1780 1
a1780 14

	if ((error = pcbmap(dep, cn, bnp, 0, 0)) != 0)
		return (error);

	for (run = 1; run <= maxrun; run++) {
		error = pcbmap(dep, cn + run, &daddr, 0, 0);
		if (error != 0 || (daddr != *bnp + de_cn2bn(pmp, run)))
			break;
	}

	if (runp)
		*runp = run - 1;

	return (0);
d1802 2
a1803 1
		error = pcbmap(dep, bp->b_lblkno, &bp->b_blkno, 0, 0);
@


1.111
log
@Remove the -x flag from mount_msdos and always assume the execute bit
for readable directories, while making it subject to the mask option
(-m in mount_msdos), so it is still possible to mount with
non-executable directories, but with semantics that are easier to
comprehend.

This makes directory listings with default mount options work again.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.110 2016/05/21 15:11:46 deraadt Exp $	*/
d1724 1
a1724 1
	return (lockmgr(&VTODE(vp)->de_lock, ap->a_flags, NULL));
d1733 2
a1734 1
	return (lockmgr(&VTODE(vp)->de_lock, LK_RELEASE, NULL));
d1742 1
a1742 1
	return (lockstatus(&VTODE(ap->a_vp)->de_lock));
@


1.110
log
@by default, files were made executable.  that does not make sense today.
noone should be executing a binary from a msdos filesystem, considering
the mountpoint tracking permission mode model
ok natano krw
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.109 2016/03/19 12:04:16 natano Exp $	*/
d228 1
a228 3
	dosmode &= pmp->pm_mask;
	if (dep->de_Attributes & ATTR_DIRECTORY
	    && pmp->pm_flags & MSDOSFSMNT_ALLOWDIRX) {
d233 1
d305 3
a307 3
	vap->va_mode = (S_IRUSR|S_IRGRP|S_IROTH) |
	    ((dep->de_Attributes & ATTR_READONLY) ? 0 : (S_IWUSR|S_IWGRP|S_IWOTH));
	vap->va_mode &= dep->de_pmp->pm_mask;
d310 3
a312 5
		if (pmp->pm_flags & MSDOSFSMNT_ALLOWDIRX) {
			vap->va_mode |= (vap->va_mode & S_IRUSR) ? S_IXUSR : 0;
			vap->va_mode |= (vap->va_mode & S_IRGRP) ? S_IXGRP : 0;
			vap->va_mode |= (vap->va_mode & S_IROTH) ? S_IXOTH : 0;
		}
d314 1
@


1.109
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.108 2016/03/14 23:08:06 krw Exp $	*/
d225 1
a225 1
	dosmode = (S_IXUSR|S_IXGRP|S_IXOTH) | (S_IRUSR|S_IRGRP|S_IROTH);
d306 1
a306 1
	vap->va_mode = (S_IXUSR|S_IXGRP|S_IXOTH) | (S_IRUSR|S_IRGRP|S_IROTH) |
@


1.108
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.107 2016/02/05 19:27:02 stefan Exp $	*/
d1006 1
a1006 1
			VOP_UNLOCK(fvp, 0, p);
d1038 1
a1038 1
	VOP_UNLOCK(fvp, 0, p);
d1107 1
a1107 1
		VOP_UNLOCK(tdvp, 0, p);
d1117 1
a1117 1
			VOP_UNLOCK(tdvp, 0, p);
d1138 1
a1138 1
			VOP_UNLOCK(fdvp, 0, p);
d1160 1
a1160 1
				VOP_UNLOCK(fdvp, 0, p);
d1168 1
a1168 1
				VOP_UNLOCK(fdvp, 0, p);
d1180 1
a1180 1
					VOP_UNLOCK(fdvp, 0, p);
d1189 1
a1189 1
			VOP_UNLOCK(fdvp, 0, p);
d1228 1
a1228 1
	VOP_UNLOCK(fvp, 0, p);
d1735 1
a1735 1
	return (lockmgr(&VTODE(vp)->de_lock, ap->a_flags | LK_RELEASE, NULL));
@


1.107
log
@Guard against integer overflow when checking whether
writing to a file on msdosfs stays within the max. file size.

ok kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.106 2016/01/27 17:09:41 stefan Exp $	*/
d1156 1
a1156 1
		error = createde(ip, dp, (struct denode **)0, tcnp);
@


1.106
log
@Convert min + uiomovei to ulmin + uiomove.

From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.105 2016/01/13 10:00:55 mpi Exp $	*/
d629 2
a630 1
	if (uio->uio_offset + uio->uio_resid > MSDOSFS_FILESIZE_MAX)
@


1.105
log
@Implement VFS read clustering for MSDOSFS.

The logic used in msdosfs_bmap() to loop calling pcbmap() comes from
FreeBSD and is not really efficient but it is good enough since it is
only called when generating I/O.

With this diff I get a 100% improvement when reading big files from a
crappy USB stick.

With this and bread_cluster(9) modified to not re-fetch B_CACHED buffers,
reading large contiguous files with chunk sizes of MAXPHYS is almost as
fast as physio(9) on the same device.

For a 'real world' example, when copying music files from a USB stick I
see a speed jump from 15MB/s on -current to 24Mb/s with this diff.

While here rename some 'lbn' variables into 'cn' to better reflect what
we're dealing with.

Tested by Mathieu, with support from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.104 2015/10/23 18:04:37 krw Exp $	*/
d519 1
a519 1
	uint32_t n, diff, size;
a521 1
	long on;
d539 1
a539 1
		n = min((uint32_t) (pmp->pm_bpcluster - on), uio->uio_resid);
d571 1
a571 1
		error = uiomovei(bp->b_data + on, (int) n, uio);
d586 2
a587 3
	int n;
	int croffset;
	int resid;
d716 1
a716 1
		n = min(uio->uio_resid, pmp->pm_bpcluster - croffset);
d730 1
a730 1
		error = uiomovei(bp->b_data + croffset, n, uio);
d1555 1
a1555 1
				error = uiomovei(&dirbuf, dirbuf.d_reclen, uio);
d1683 1
a1683 1
			error = uiomovei(&dirbuf, dirbuf.d_reclen, uio);
@


1.104
log
@Fix renaming in the root directory by correctly setting directory
offset.

From Serguey Parkhomovsky via bugs@@, in response to problem report
from matthieu@@. Same fix is in NetBSD for one.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.103 2015/10/23 17:21:34 krw Exp $	*/
d80 1
a86 1

a513 8
	int error = 0;
	uint32_t diff;
	int blsize;
	int isadir;
	uint32_t n;
	long on;
	daddr_t lbn, rablock, rablkno;
	struct buf *bp;
d518 5
d537 2
a538 1
		lbn = de_cluster(pmp, uio->uio_offset);
a550 6
		/* convert cluster # to block # if a directory */
		if (isadir) {
			error = pcbmap(dep, lbn, &lbn, 0, &blsize);
			if (error)
				return (error);
		}
d557 4
a560 1
			error = bread(pmp->pm_devvp, lbn, blsize, &bp);
d562 2
a563 7
			rablock = lbn + 1;
			rablkno = de_cn2bn(pmp, rablock);
			if (dep->de_lastr + 1 == lbn &&
			    de_cn2off(pmp, rablock) < dep->de_FileSize)
				error = breadn(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, &rablkno,
				    &pmp->pm_bpcluster, 1, &bp);
d565 1
a565 3
				error = bread(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, &bp);
			dep->de_lastr = lbn;
d595 1
a595 1
	daddr_t bn;
d671 4
a674 1
		if (de_cluster(pmp, uio->uio_offset) > lastcn) {
d679 3
a681 4
		bn = de_blk(pmp, uio->uio_offset);
		if ((uio->uio_offset & pmp->pm_crbomask) == 0
		    && (de_blk(pmp, uio->uio_offset + uio->uio_resid) > de_blk(pmp, uio->uio_offset)
			|| uio->uio_offset + uio->uio_resid >= dep->de_FileSize)) {
d687 1
a687 1
			bp = getblk(thisvp, bn, pmp->pm_bpcluster, 0, 0);
d694 1
a694 3
				error = pcbmap(dep,
					       de_bn2cn(pmp, bp->b_lblkno),
					       &bp->b_blkno, 0, 0);
d697 2
d708 2
a709 1
			 * The block we need to write into exists, so read it in.
d711 1
a711 1
			error = bread(thisvp, bn, pmp->pm_bpcluster, &bp);
a717 1
		croffset = uio->uio_offset & pmp->pm_crbomask;
d1749 1
a1749 1
 * bn  - which cluster we are interested in mapping to a filesystem block number.
a1758 1
	struct msdosfsmount *pmp = dep->de_pmp;
d1764 16
a1779 1
	if (ap->a_runp) {
d1781 4
a1784 1
		 * Sequential clusters should be counted here.
d1786 3
a1788 1
		*ap->a_runp = 0;
d1790 14
a1803 1
	return (pcbmap(dep, de_bn2cn(pmp, ap->a_bn), ap->a_bnp, 0, 0));
d1825 1
a1825 2
		error = pcbmap(dep, de_bn2cn(dep->de_pmp, bp->b_lblkno),
			       &bp->b_blkno, 0, 0);
@


1.103
log
@Fix printf() types so kernel compiles with or w/o MSDOSFS_DEBUG.
e.g. print pointers with %p instead of %08x. No changes outside of
MSDOSFS_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.102 2015/10/23 10:45:31 krw Exp $	*/
d1194 1
d1196 1
a1196 1
				ip->de_diroffset = to_diroffset & pmp->pm_crbomask;
@


1.102
log
@Nuke a bunch of leading/embedded/trailing whitespace so the code can be
read without generating spurious headaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.101 2015/09/23 15:37:26 tedu Exp $	*/
d123 1
a123 1
	printf("msdosfs_create(cnp %08x, vap %08x\n", cnp, ap->a_vap);
d353 1
a353 1
	printf("msdosfs_setattr(): vp %08x, vap %08x, cred %08x, p %08x\n",
d362 7
a368 4
		printf("    va_type %d, va_nlink %x, va_fsid %x, va_fileid %x\n",
		    vap->va_type, vap->va_nlink, vap->va_fsid, vap->va_fileid);
		printf("    va_blocksize %x, va_rdev %x, va_bytes %x, va_gen %x\n",
		    vap->va_blocksize, vap->va_rdev, vap->va_bytes, vap->va_gen);
d618 1
a618 1
	printf("msdosfs_write(vp %08x, uio %08x, ioflag %08x, cred %08x\n",
d858 2
a859 1
	printf("msdosfs_remove(), dep %08x, v_usecount %d\n", dep, ap->a_vp->v_usecount);
d1494 1
a1494 1
	printf("msdosfs_readdir(): vp %08x, uio %08x, cred %08x, eofflagp %08x\n",
@


1.101
log
@remove lockmgr_printinfo stubs. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.100 2015/04/17 04:43:21 guenther Exp $	*/
d336 1
a336 1
	    			~(dep->de_pmp->pm_crbomask);
d983 1
a983 1
	
d1256 1
a1256 1
		{ 0, 0 },	 			/* access date */
d1260 1
a1260 1
		{ 0, 0, 0, 0 } 				/* filesize */
d1806 1
a1806 1
		s = splbio();	
@


1.100
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.99 2015/03/14 03:38:51 jsg Exp $	*/
a1835 1
	lockmgr_printinfo(&dep->de_lock);
@


1.99
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.98 2015/02/10 21:56:10 miod Exp $	*/
d454 3
a456 1
	if (vap->va_atime.tv_sec != VNOVAL || vap->va_mtime.tv_sec != VNOVAL) {
d466 1
a466 1
			    vap->va_atime.tv_sec != VNOVAL) {
d471 1
a471 1
			if (vap->va_mtime.tv_sec != VNOVAL) {
@


1.98
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.97 2014/12/16 18:30:04 tedu Exp $	*/
a55 1
#include <sys/kernel.h>
@


1.97
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.96 2014/11/03 21:28:35 tedu Exp $	*/
d580 1
a580 1
		error = uiomove(bp->b_data + on, (int) n, uio);
d738 1
a738 1
		error = uiomove(bp->b_data + croffset, n, uio);
d1561 1
a1561 1
				error = uiomove(&dirbuf, dirbuf.d_reclen, uio);
d1689 1
a1689 1
			error = uiomove(&dirbuf, dirbuf.d_reclen, uio);
@


1.96
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.95 2014/08/10 09:23:06 jsg Exp $	*/
d63 1
@


1.95
log
@fix kqueue read/write filters for msdosfs and fusefs
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.94 2014/07/08 17:19:25 deraadt Exp $	*/
d70 1
@


1.94
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.93 2014/05/09 03:48:58 tedu Exp $	*/
d80 2
a81 1
int filt_msdosfsreadwrite(struct knote *, long);
d1943 4
a1946 2
struct filterops msdosfsreadwrite_filtops =
	{ 1, NULL, filt_msdosfsdetach, filt_msdosfsreadwrite };
d1959 1
a1959 1
		kn->kn_fop = &msdosfsreadwrite_filtops;
d1962 1
a1962 1
		kn->kn_fop = &msdosfsreadwrite_filtops;
d1987 1
a1987 1
filt_msdosfsreadwrite(struct knote *kn, long hint)
d1989 3
d2001 5
d2007 16
@


1.93
log
@disable IO_NOCACHE B_NOCACHE conversion until it works.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.92 2014/04/08 18:48:41 beck Exp $	*/
a69 2

#include <uvm/uvm_extern.h>
@


1.92
log
@add IO_NOCACHE flag to vop_write arguments, which in turn sets B_NOCACHE
on the written buffers. Use the flag for writes from the page daemon to
ensure that we free buffers written out by the page daemon rather than
caching them.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.91 2013/12/14 02:57:25 guenther Exp $	*/
d746 1
d749 1
@


1.91
log
@Zero out dirent structures that will be copied out to avoid leaking garbage
in the padding or trailing name bytes.

ok beck@@ millert@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.90 2013/10/01 20:22:13 sf Exp $	*/
d746 2
@


1.90
log
@Format string fixes: %hu/%hd for uint16_t, %u/%d/%x for uint32_t

- despite the name, ntohl returns uint32_t, not long
- also fix some %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.89 2013/09/14 02:28:03 guenther Exp $	*/
d1500 1
a1500 1
	bzero(dirbuf.d_name, sizeof(dirbuf.d_name));
@


1.89
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.88 2013/08/13 05:52:24 guenther Exp $	*/
d1824 1
a1824 1
	    "tag VT_MSDOSFS, startcluster %ld, dircluster %ld, diroffset %ld ",
@


1.88
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.87 2013/06/11 16:42:16 deraadt Exp $	*/
d597 1
a597 1
	int overrun;
@


1.87
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.86 2013/05/23 09:11:00 espie Exp $	*/
a1479 2
	u_long *cookies = NULL;
	int ncookies = 0;
a1514 7
	if (ap->a_ncookies) {
		ncookies = uio->uio_resid / sizeof(struct direntry) + 3;
		cookies = malloc(ncookies * sizeof(u_long), M_TEMP, M_WAITOK);
		*ap->a_cookies = cookies;
		*ap->a_ncookies = ncookies;
	}

d1552 2
d1556 1
a1556 2
				error = uiomove((caddr_t) &dirbuf,
						dirbuf.d_reclen, uio);
d1559 1
a1559 6
				offset += sizeof(struct direntry);
				if (cookies) {
					*cookies++ = offset;
					if (--ncookies <= 0)
						goto out;
				}
d1675 1
d1684 1
a1684 2
			error = uiomove((caddr_t) &dirbuf,
					dirbuf.d_reclen, uio);
a1688 7
			if (cookies) {
				*cookies++ = offset + sizeof(struct direntry);
				if (--ncookies <= 0) {
					brelse(bp);
					goto out;
				}
			}
a1693 4
	/* Subtract unused cookies */
	if (ap->a_ncookies)
		*ap->a_ncookies -= ncookies;

@


1.86
log
@revoke's default imp works.
okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.85 2013/03/28 03:29:44 guenther Exp $	*/
d515 1
a515 1
	daddr64_t lbn, rablock, rablkno;
d602 1
a602 1
	daddr64_t bn;
d946 1
a946 1
	daddr64_t bn;
d1278 1
a1278 1
	daddr64_t bn;
d1473 1
a1473 1
	daddr64_t bn;
@


1.85
log
@Add support for _PC_TIMESTAMP_RESOLUTION for ffs/mfs, cd9600, ext2,
msdos, NFS, fifos and devices, plus support for querying it in
getconf(2) and the requisite pathconf(2) manpage blurb

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.84 2013/03/28 02:08:39 guenther Exp $	*/
d1960 2
a1961 1
	.vop_bwrite	= vop_generic_bwrite
@


1.84
log
@Handle the pathconf _PC_PATH_MAX, _PC_PIPE_BUF, _PC_ASYNC_IO,
_PC_PRIO_IO, and _PC_SYNC_IO names in VOP_PATHCONF(), as they're
fs-independent for us.  Since we don't support latter three on any
fs, we can also define the related _POSIX_{ASYNC,PRIO,SYNC}_IO
symbols in <unistd.h> (via sys/unistd.h) with value -1.

Also, zap pointless tty-only values from procfs(!).

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.83 2013/01/15 06:05:47 martynas Exp $	*/
d1890 3
@


1.83
log
@Make the FAT setattr handling more consistent about unsupported
attributes;  making it more "user-friendly".  Mostly from FreeBSD.
OK guenther@@, krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.82 2012/07/11 12:39:20 guenther Exp $	*/
a1883 3
		break;
	case _PC_PATH_MAX:
		*ap->a_retval = PATH_MAX;
@


1.82
log
@If the current offset is strictly less than the process filesize
rlimit, then a write that would take it over the limit should be
clamped, making it a partial write.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.81 2012/06/20 17:30:22 matthew Exp $	*/
d345 1
a345 1
	int error = 0;
d347 1
d350 1
d359 1
a359 2
	    (vap->va_bytes != VNOVAL) || (vap->va_gen != VNOVAL) ||
	    (vap->va_uid != VNOVAL) || (vap->va_gid != VNOVAL)) {
a365 2
		printf("    va_uid %x, va_gid %x\n",
		    vap->va_uid, vap->va_gid);
d369 55
a423 5
	/*
	 * Directories must not ever get their attributes modified
	 */
	if (ap->a_vp->v_type == VDIR)
		return (0);
d426 25
a450 1
		error = detrunc(dep, (uint32_t)vap->va_size, 0, cred, ap->a_p);
d452 1
a452 1
			return (error);
d455 3
a457 1
		if (cred->cr_uid != dep->de_pmp->pm_uid &&
d462 15
a476 7
		if (!(dep->de_pmp->pm_flags & MSDOSFSMNT_NOWIN95)
		    && vap->va_atime.tv_sec != VNOVAL)
			unix2dostime(&vap->va_atime, &dep->de_ADate, NULL, NULL);
		if (vap->va_mtime.tv_sec != VNOVAL)
			unix2dostime(&vap->va_mtime, &dep->de_MDate, &dep->de_MTime, NULL);
		dep->de_Attributes |= ATTR_ARCHIVE;
		dep->de_flag |= DE_MODIFIED;
d484 13
a496 20
		if (cred->cr_uid != dep->de_pmp->pm_uid &&
		    (error = suser_ucred(cred)))
			return (error);
		/* We ignore the read and execute bits. */
		if (vap->va_mode & VWRITE)
			dep->de_Attributes &= ~ATTR_READONLY;
		else
			dep->de_Attributes |= ATTR_READONLY;
		dep->de_flag |= DE_MODIFIED;
	}
	/*
	 * Allow the `archived' bit to be toggled.
	 */
	if (vap->va_flags != VNOVAL) {
		if (cred->cr_uid != dep->de_pmp->pm_uid &&
		    (error = suser_ucred(cred)))
			return (error);
		if (vap->va_flags & SF_ARCHIVED)
			dep->de_Attributes &= ~ATTR_ARCHIVE;
		else
d498 2
a499 1
		dep->de_flag |= DE_MODIFIED;
@


1.81
log
@Cleanup our filesystem pathconf() code a little bit to make it easier
to diff against FreeBSD's.

From Brad; no object file change on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.80 2012/02/16 08:58:49 robert Exp $	*/
d520 1
a528 1
	struct proc *p = uio->uio_procp;
d564 3
a566 9
	/*
	 * If they've exceeded their filesize limit, tell them about it.
	 */
	if (p &&
	    ((uio->uio_offset + uio->uio_resid) >
	    p->p_rlimit[RLIMIT_FSIZE].rlim_cur)) {
		psignal(p, SIGXFSZ);
		return (EFBIG);
	}
d576 1
a576 1
			return (error);
d701 4
@


1.80
log
@add kevent support for msdosfs to make applications
monitoring fs mounts happy

tested by ajacoutot@@ and ok by thib@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.79 2011/07/04 20:35:35 deraadt Exp $	*/
d1801 1
d1806 1
a1806 1
		return (0);
d1809 1
a1809 1
		return (0);
d1812 1
a1812 1
		return (0);
d1815 1
a1815 1
		return (0);
d1818 1
a1818 1
		return (0);
d1820 2
a1821 1
		return (EINVAL);
d1823 2
a1824 1
	/* NOTREACHED */
@


1.79
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.78 2011/07/04 04:30:41 tedu Exp $	*/
d81 6
d165 1
d182 1
d424 1
d520 1
d596 1
d684 6
d769 4
d939 1
d987 2
d1011 1
d1150 2
d1291 1
d1336 3
d1365 1
d1861 1
d1882 1
a1882 1
	.vop_bwrite	= vop_generic_bwrite 
d1884 68
@


1.78
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.77 2011/04/05 14:14:07 thib Exp $	*/
d64 1
a64 1
#include <miscfs/specfs/specdev.h> /* XXX */	/* defines v_rdev */
@


1.77
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.76 2010/12/21 20:14:43 thib Exp $	*/
d474 1
a474 1
			error = bread(pmp->pm_devvp, lbn, blsize, NOCRED, &bp);
d482 1
a482 1
				    &pmp->pm_bpcluster, 1, NOCRED, &bp);
d485 1
a485 1
				    pmp->pm_bpcluster, NOCRED, &bp);
d633 1
a633 2
			error = bread(thisvp, bn, pmp->pm_bpcluster,
				      NOCRED, &bp);
d1103 1
a1103 2
		error = bread(pmp->pm_devvp, bn, pmp->pm_bpcluster,
			      NOCRED, &bp);
d1480 1
a1480 1
		error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp);
@


1.76
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.75 2010/09/10 16:34:08 thib Exp $	*/
a1818 1
	.vop_default	= eopnotsupp,
@


1.75
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.74 2010/09/09 10:37:04 thib Exp $	*/
d1732 1
a1732 1
	VOCALL(vp->v_op, VOFFSET(vop_strategy), ap);
d1818 35
a1852 37
int (**msdosfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc msdosfs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, msdosfs_lookup },
	{ &vop_create_desc, msdosfs_create },
	{ &vop_mknod_desc, msdosfs_mknod },
	{ &vop_open_desc, msdosfs_open },
	{ &vop_close_desc, msdosfs_close },
	{ &vop_access_desc, msdosfs_access },
	{ &vop_getattr_desc, msdosfs_getattr },
	{ &vop_setattr_desc, msdosfs_setattr },
	{ &vop_read_desc, msdosfs_read },
	{ &vop_write_desc, msdosfs_write },
	{ &vop_ioctl_desc, msdosfs_ioctl },
	{ &vop_poll_desc, msdosfs_poll },
	{ &vop_fsync_desc, msdosfs_fsync },
	{ &vop_remove_desc, msdosfs_remove },
	{ &vop_link_desc, msdosfs_link },
	{ &vop_rename_desc, msdosfs_rename },
	{ &vop_mkdir_desc, msdosfs_mkdir },
	{ &vop_rmdir_desc, msdosfs_rmdir },
	{ &vop_symlink_desc, msdosfs_symlink },
	{ &vop_readdir_desc, msdosfs_readdir },
	{ &vop_readlink_desc, msdosfs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, msdosfs_inactive },
	{ &vop_reclaim_desc, msdosfs_reclaim },
	{ &vop_lock_desc, msdosfs_lock },
	{ &vop_unlock_desc, msdosfs_unlock },
	{ &vop_bmap_desc, msdosfs_bmap },
	{ &vop_strategy_desc, msdosfs_strategy },
	{ &vop_print_desc, msdosfs_print },
	{ &vop_islocked_desc, msdosfs_islocked },
	{ &vop_pathconf_desc, msdosfs_pathconf },
	{ &vop_advlock_desc, msdosfs_advlock },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ (struct vnodeop_desc *)NULL, (int (*)(void *))NULL }
a1853 2
struct vnodeopv_desc msdosfs_vnodeop_opv_desc =
	{ &msdosfs_vnodeop_p, msdosfs_vnodeop_entries };
@


1.74
log
@Rename lookup/relookup to vfs_lookup/vfs_relookup.

OK oga@@, beck@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.73 2010/09/06 23:44:10 thib Exp $	*/
d1732 1
a1732 1
	(vp->v_op->vop_strategy)(ap);
d1818 37
a1854 35
struct vops msdosfs_vops = {
	.vop_default	= eopnotsupp,
	.vop_lookup	= msdosfs_lookup,
	.vop_create	= msdosfs_create,
	.vop_mknod	= msdosfs_mknod,
	.vop_open	= msdosfs_open,
	.vop_close	= msdosfs_close,
	.vop_access	= msdosfs_access,
	.vop_getattr	= msdosfs_getattr,
	.vop_setattr	= msdosfs_setattr,
	.vop_read	= msdosfs_read,
	.vop_write	= msdosfs_write,
	.vop_ioctl	= msdosfs_ioctl,
	.vop_poll	= msdosfs_poll,
	.vop_fsync	= msdosfs_fsync,
	.vop_remove	= msdosfs_remove,
	.vop_link	= msdosfs_link,
	.vop_rename	= msdosfs_rename,
	.vop_mkdir	= msdosfs_mkdir,
	.vop_rmdir	= msdosfs_rmdir,
	.vop_symlink	= msdosfs_symlink,
	.vop_readdir	= msdosfs_readdir,
	.vop_readlink	= msdosfs_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= msdosfs_inactive,
	.vop_reclaim	= msdosfs_reclaim,
	.vop_lock	= msdosfs_lock,
	.vop_unlock	= msdosfs_unlock,
	.vop_bmap	= msdosfs_bmap,
	.vop_strategy	= msdosfs_strategy,
	.vop_print	= msdosfs_print,
	.vop_islocked	= msdosfs_islocked,
	.vop_pathconf	= msdosfs_pathconf,
	.vop_advlock	= msdosfs_advlock,
	.vop_bwrite	= vop_generic_bwrite 
d1856 2
@


1.73
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.72 2009/08/14 11:35:03 jasper Exp $	*/
d960 1
a960 1
		if ((error = relookup(tdvp, &tvp, tcnp)) != 0)
d1010 1
a1010 1
	(void) relookup(fdvp, &fvp, fcnp);
@


1.72
log
@- deregister; no binary change

ok thibski@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.71 2009/08/13 22:34:29 jasper Exp $	*/
d1732 1
a1732 1
	VOCALL(vp->v_op, VOFFSET(vop_strategy), ap);
d1818 35
a1852 37
int (**msdosfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc msdosfs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, msdosfs_lookup },
	{ &vop_create_desc, msdosfs_create },
	{ &vop_mknod_desc, msdosfs_mknod },
	{ &vop_open_desc, msdosfs_open },
	{ &vop_close_desc, msdosfs_close },
	{ &vop_access_desc, msdosfs_access },
	{ &vop_getattr_desc, msdosfs_getattr },
	{ &vop_setattr_desc, msdosfs_setattr },
	{ &vop_read_desc, msdosfs_read },
	{ &vop_write_desc, msdosfs_write },
	{ &vop_ioctl_desc, msdosfs_ioctl },
	{ &vop_poll_desc, msdosfs_poll },
	{ &vop_fsync_desc, msdosfs_fsync },
	{ &vop_remove_desc, msdosfs_remove },
	{ &vop_link_desc, msdosfs_link },
	{ &vop_rename_desc, msdosfs_rename },
	{ &vop_mkdir_desc, msdosfs_mkdir },
	{ &vop_rmdir_desc, msdosfs_rmdir },
	{ &vop_symlink_desc, msdosfs_symlink },
	{ &vop_readdir_desc, msdosfs_readdir },
	{ &vop_readlink_desc, msdosfs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, msdosfs_inactive },
	{ &vop_reclaim_desc, msdosfs_reclaim },
	{ &vop_lock_desc, msdosfs_lock },
	{ &vop_unlock_desc, msdosfs_unlock },
	{ &vop_bmap_desc, msdosfs_bmap },
	{ &vop_strategy_desc, msdosfs_strategy },
	{ &vop_print_desc, msdosfs_print },
	{ &vop_islocked_desc, msdosfs_islocked },
	{ &vop_pathconf_desc, msdosfs_pathconf },
	{ &vop_advlock_desc, msdosfs_advlock },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ (struct vnodeop_desc *)NULL, (int (*)(void *))NULL }
a1853 2
struct vnodeopv_desc msdosfs_vnodeop_opv_desc =
	{ &msdosfs_vnodeop_p, msdosfs_vnodeop_entries };
@


1.71
log
@- ansify function declarations, no binary change

"fine" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.70 2009/08/13 15:00:14 jasper Exp $	*/
d838 1
a838 1
	register struct vnode *tdvp = ap->a_tdvp;
d840 3
a842 3
	register struct vnode *fdvp = ap->a_fdvp;
	register struct componentname *tcnp = ap->a_tcnp;
	register struct componentname *fcnp = ap->a_fcnp;
d844 1
a844 1
	register struct denode *ip, *xp, *dp, *zp;
d1282 4
a1285 4
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
	register struct componentname *cnp = ap->a_cnp;
	register struct denode *ip, *dp;
d1760 1
a1760 1
	register struct denode *dep = VTODE(ap->a_vp);
@


1.70
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.69 2009/08/13 12:20:52 jasper Exp $	*/
d106 1
a106 2
msdosfs_create(v)
	void *v;
d170 1
a170 2
msdosfs_mknod(v)
	void *v;
d180 1
a180 2
msdosfs_open(v)
	void *v;
d195 1
a195 2
msdosfs_close(v)
	void *v;
d210 1
a210 2
msdosfs_access(v)
	void *v;
d233 1
a233 2
msdosfs_getattr(v)
	void *v;
d334 1
a334 2
msdosfs_setattr(v)
	void *v;
d420 1
a420 2
msdosfs_read(v)
	void *v;
d505 1
a505 2
msdosfs_write(v)
	void *v;
d695 1
a695 2
msdosfs_ioctl(v)
	void *v;
d712 1
a712 2
msdosfs_poll(v)
	void *v;
d726 1
a726 2
msdosfs_fsync(v)
	void *v;
d742 1
a742 2
msdosfs_remove(v)
	void *v;
d771 1
a771 2
msdosfs_link(v)
	void *v;
d834 1
a834 2
msdosfs_rename(v)
	void *v;
d1170 1
a1170 2
msdosfs_mkdir(v)
	void *v;
d1279 1
a1279 2
msdosfs_rmdir(v)
	void *v;
d1344 1
a1344 2
msdosfs_symlink(v)
	void *v;
d1354 1
a1354 2
msdosfs_readdir(v)
	void *v;
d1626 1
a1626 2
msdosfs_readlink(v)
	void *v;
d1640 1
a1640 2
msdosfs_lock(v)
	void *v;
d1649 1
a1649 2
msdosfs_unlock(v)
	void *v;
d1658 1
a1658 2
msdosfs_islocked(v)
	void *v;
d1673 1
a1673 2
msdosfs_bmap(v)
	void *v;
d1693 1
a1693 2
msdosfs_strategy(v)
	void *v;
d1737 1
a1737 2
msdosfs_print(v)
	void *v;
d1757 1
a1757 2
msdosfs_advlock(v)
	void *v;
d1767 1
a1767 2
msdosfs_pathconf(v)
	void *v;
@


1.69
log
@- missing printf("\n"); after calling lockmgr_printinfo()

"do it" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.68 2009/08/09 21:58:00 martynas Exp $	*/
d1849 33
a1881 33
	{ &vop_lookup_desc, msdosfs_lookup },		/* lookup */
	{ &vop_create_desc, msdosfs_create },		/* create */
	{ &vop_mknod_desc, msdosfs_mknod },		/* mknod */
	{ &vop_open_desc, msdosfs_open },		/* open */
	{ &vop_close_desc, msdosfs_close },		/* close */
	{ &vop_access_desc, msdosfs_access },		/* access */
	{ &vop_getattr_desc, msdosfs_getattr },		/* getattr */
	{ &vop_setattr_desc, msdosfs_setattr },		/* setattr */
	{ &vop_read_desc, msdosfs_read },		/* read */
	{ &vop_write_desc, msdosfs_write },		/* write */
	{ &vop_ioctl_desc, msdosfs_ioctl },		/* ioctl */
	{ &vop_poll_desc, msdosfs_poll },		/* poll */
	{ &vop_fsync_desc, msdosfs_fsync },		/* fsync */
	{ &vop_remove_desc, msdosfs_remove },		/* remove */
	{ &vop_link_desc, msdosfs_link },		/* link */
	{ &vop_rename_desc, msdosfs_rename },		/* rename */
	{ &vop_mkdir_desc, msdosfs_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, msdosfs_rmdir },		/* rmdir */
	{ &vop_symlink_desc, msdosfs_symlink },		/* symlink */
	{ &vop_readdir_desc, msdosfs_readdir },		/* readdir */
	{ &vop_readlink_desc, msdosfs_readlink },	/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },	/* abortop */
	{ &vop_inactive_desc, msdosfs_inactive },	/* inactive */
	{ &vop_reclaim_desc, msdosfs_reclaim },		/* reclaim */
	{ &vop_lock_desc, msdosfs_lock },		/* lock */
	{ &vop_unlock_desc, msdosfs_unlock },		/* unlock */
	{ &vop_bmap_desc, msdosfs_bmap },		/* bmap */
	{ &vop_strategy_desc, msdosfs_strategy },	/* strategy */
	{ &vop_print_desc, msdosfs_print },		/* print */
	{ &vop_islocked_desc, msdosfs_islocked },	/* islocked */
	{ &vop_pathconf_desc, msdosfs_pathconf },	/* pathconf */
	{ &vop_advlock_desc, msdosfs_advlock },		/* advlock */
	{ &vop_bwrite_desc, vop_generic_bwrite },		/* bwrite */
@


1.68
log
@indicate success for setting directory attributes;  first step towards
making directory moves work...  discussed w. & makes sense - millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.67 2008/06/09 23:38:37 millert Exp $	*/
d1776 1
@


1.67
log
@Update access(2) to have modern semantics with respect to X_OK and
the superuser.  access(2) will now only indicate success for X_OK on
non-directories if there is at least one execute bit set on the file.
OK deraadt@@ thib@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.66 2008/05/08 17:45:45 thib Exp $	*/
d373 1
a373 1
		return EISDIR;
@


1.66
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.65 2007/10/29 15:39:01 chl Exp $	*/
d233 2
a234 2
	return (vaccess(dosmode, pmp->pm_uid, pmp->pm_gid, ap->a_mode,
	    ap->a_cred));
@


1.65
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.64 2007/06/02 02:04:21 deraadt Exp $	*/
d1847 1
a1847 1
	{ &vop_default_desc, vn_default_error },
@


1.64
log
@convert all daddr_t types to either daddr64_t or uint32_t or other such
things based on their use.  ok with fixes from tom, tested by grange too
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.63 2007/06/01 23:47:57 deraadt Exp $	*/
d1433 1
a1433 2
		MALLOC(cookies, u_long *, ncookies * sizeof(u_long), M_TEMP,
		       M_WAITOK);
@


1.63
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.62 2007/04/02 21:18:59 pedro Exp $	*/
d522 2
a523 2
	uint32_t count;
	daddr_t bn, lastcn;
d866 1
a866 1
	daddr_t bn;
d1194 1
a1194 1
	int bn;
d1384 1
a1384 1
	uint32_t cn;
a1386 1
	daddr_t lbn;
@


1.62
log
@When running out of space to place a directory entry in msdosfs_readdir(),
save the correct offset in case the directory has support for long file
names, and return it to the caller so she can proceed from a valid point.
From Alexey Vatchenko, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.61 2007/03/21 17:29:32 thib Exp $	*/
d109 1
a109 6
	struct vop_create_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d174 1
a174 6
	struct vop_mknod_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d201 1
a201 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d217 1
a217 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d241 1
a241 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d343 1
a343 6
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d430 1
a430 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d516 1
a516 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d725 1
a725 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;
		struct proc *a_p;
	} */ *ap = v;
d740 1
a740 6
	struct vop_fsync_args /* {
		struct vnode *a_vp;
		struct ucred *a_cred;
		int a_waitfor;
		struct proc *a_p;
	} */ *ap = v;
d757 1
a757 5
	struct vop_remove_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d787 1
a787 5
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d851 1
a851 8
	struct vop_rename_args /* {
		struct vnode *a_fdvp;
		struct vnode *a_fvp;
		struct componentname *a_fcnp;
		struct vnode *a_tdvp;
		struct vnode *a_tvp;
		struct componentname *a_tcnp;
	} */ *ap = v;
d1188 1
a1188 6
	struct vop_mkdir_args /* {
		struct vnode *a_dvp;
		struvt vnode **a_vpp;
		struvt componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d1298 1
a1298 5
	struct vop_rmdir_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d1364 1
a1364 7
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
d1375 1
a1375 8
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long **a_cookies;
		int *a_ncookies;
	} */ *ap = v;
d1665 1
a1665 5
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
d1675 1
a1675 3
	struct vop_unlock_args /* {
		struct vnode *vp;
	} */ *ap = v;
d1685 1
a1685 3
	struct vop_islocked_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d1701 1
a1701 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
d1722 1
a1722 3
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
d1767 1
a1767 3
	struct vop_print_args /* {
		struct vnode *vp;
	} */ *ap = v;
d1787 1
a1787 7
	struct vop_advlock_args /* {
		struct vnode *a_vp;
		caddr_t a_id;
		int a_op;
		struct flock *a_fl;
		int a_flags;
	} */ *ap = v;
d1798 1
a1798 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
@


1.61
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.60 2007/03/18 15:05:33 mickey Exp $	*/
d1483 1
a1483 1
	off_t offset;
d1619 1
d1627 1
d1630 4
a1633 1
				chksum = win2unixfn((struct winentry *)dentp, &dirbuf, chksum);
d1642 1
d1692 3
d1697 1
@


1.60
log
@get rid of noop vop_reallocblks; pedro@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.59 2007/01/16 17:52:18 thib Exp $	*/
d1748 1
a1748 1
	return (lockmgr(&VTODE(vp)->de_lock, ap->a_flags, &vp->v_interlock));
d1760 1
a1760 2
	return (lockmgr(&VTODE(vp)->de_lock, ap->a_flags | LK_RELEASE,
	    &vp->v_interlock));
@


1.59
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.58 2006/10/16 11:27:53 pedro Exp $	*/
a1809 15
msdosfs_reallocblks(v)
	void *v;
{
#if 0
	struct vop_reallocblks_args /* {
		struct vnode *a_vp;
		struct cluster_save *a_buflist;
	} */ *ap = v;
#endif

	/* Currently no support for clustering */		/* XXX */
	return (ENOSPC);
}

int
a1986 1
	{ &vop_reallocblks_desc, msdosfs_reallocblks },	/* reallocblks */
@


1.58
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.57 2006/10/03 19:49:06 pedro Exp $	*/
a1979 1
	{ &vop_lease_desc, msdosfs_lease_check },	/* lease */
@


1.57
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.56 2005/12/01 22:13:33 pedro Exp $	*/
d472 1
a472 3
	daddr64_t lbn;
	daddr_t rablock;
	daddr_t rablkno;
@


1.56
log
@Add missing cache_purge() in msdosfs_rename().
Spotted by tedu@@, okay tom@@ and tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.55 2005/11/19 02:18:01 pedro Exp $	*/
d472 1
a472 1
	daddr_t lbn;
d1475 2
a1476 1
	daddr_t bn, lbn;
@


1.55
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.54 2005/10/08 09:38:22 tom Exp $	*/
d1154 3
@


1.54
log
@When moving a directory to under a new parent, write the correct
cluster number into our . pointer.  This fixes filesystem corruption
seen under these circumstances.

Testing nick@@, krw@@, ian@@ and others - thanks.

"i agree" pedro@@; "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.53 2005/03/14 22:31:52 tom Exp $	*/
d1746 1
a1746 2
	return (lockmgr(&VTODE(vp)->de_lock, ap->a_flags, &vp->v_interlock,
	    ap->a_p));
d1759 1
a1759 1
	    &vp->v_interlock, ap->a_p));
@


1.53
log
@Fix typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.52 2005/03/02 00:44:12 tom Exp $	*/
d1190 1
a1190 1
		putushort(dotdotp[0].deStartCluster, dp->de_StartCluster);
@


1.53.4.1
log
@MFC:
Fixes by tom@@ and pedro@@

rev 1.56
Add missing cache_purge() in msdosfs_rename().

rev 1.54
When moving a directory to under a new parent, write the correct
cluster number into our . pointer.  This fixes filesystem corruption
seen under these circumstances.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.53 2005/03/14 22:31:52 tom Exp $	*/
a1153 3

		cache_purge(fvp);

d1190 1
a1190 1
		putushort(dotdotp[0].deStartCluster, cn);
@


1.52
log
@Add support for MS-DOS filesystems > 128 GB, by changing the way we
calculate fileids (fake inode numbers).  This uses some hash code by
Thomas Wang, who has agreed to the existing licence on the file (i.e.
his name just needed to be added to the copyright list).  Thanks.

Also a tiny bit of KNF.

Closes PR 4119; works for the OP Pawel Rogocz.

Help with testing todd@@, thanks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.51 2005/03/01 14:29:01 tom Exp $	*/
d1954 1
a1954 1
	 * We need to reduce it to 32-bits, with the toe bit set.
@


1.51
log
@Fix an integer overflow that prevented us from reading files >= 2 GB
from MS-DOS filesystems.

Assistance otto@@; thanks.

"looks ok" krw@@; ok derradt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.50 2005/03/01 14:24:33 tom Exp $	*/
d5 1
d79 2
a270 1
	uint32_t dirsperblk = pmp->pm_BytesPerSec / sizeof(struct direntry);
d276 1
d278 26
a303 3
	 * The following computation of the fileid must be the same as that
	 * used in msdosfs_readdir() to compute d_fileno. If not, pwd
	 * doesn't work.
d305 2
d308 1
a308 1
	        fileid = cntobn(pmp, dep->de_StartCluster) * dirsperblk;
d310 1
a310 1
		        fileid = 1;
d312 14
a325 4
	        fileid = cntobn(pmp, dep->de_dirclust) * dirsperblk;
		if (dep->de_dirclust == MSDOSFSROOT)
		        fileid = roottobn(pmp, 0) * dirsperblk;
		fileid += dep->de_diroffset / sizeof(struct direntry);
d327 1
d968 1
a968 1
	        error = 0;
d1313 1
a1313 1
	        pcl = 0;
d1322 1
a1322 1
	        putushort(denp[0].deHighClust, newcluster >> 16);
d1544 1
a1544 3
				        dirbuf.d_fileno = cntobn(pmp,
								 pmp->pm_rootdirblk)
					                  * dirsperblk;
d1637 1
d1643 4
d1648 6
a1653 14
				fileno = getushort(dentp->deStartCluster);
				if (FAT32(pmp))
				        fileno |=
					    getushort(dentp->deHighClust) <<
					    16;
				/* if this is the root directory */
				if (fileno == MSDOSFSROOT)
				        fileno = FAT32(pmp) ?
					    cntobn(pmp, pmp->pm_rootdirblk) *
					    dirsperblk :
					    1;
				else
				        fileno = cntobn(pmp, fileno) *
					    dirsperblk;
d1657 13
a1669 9
				/*
				 * If the file's dirent lives in
				 * root dir.
				 */
			        fileno = cntobn(pmp, cn) * dirsperblk;
				if (cn == MSDOSFSROOT)
				        fileno = roottobn(pmp, 0) * dirsperblk;
				fileno +=
				    dentp - (struct direntry *)bp->b_data;
d1673 1
d1744 1
a1744 1
        struct vnode *vp = ap->a_vp;
d1940 23
@


1.50
log
@The maximum file size on MS-DOS filesystems is 4 GB - 1 byte, so
don't bother trying to write files bigger than this.  Just return
EFBIG to caller, rather than panic()ing later.

Closes PR 4090.  Assistance from otto@@, tested by OP and moritz@@;
thanks.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.49 2004/11/30 12:39:43 pedro Exp $	*/
d428 1
a428 1
	int diff;
d431 1
a431 1
	long n;
d452 3
d458 7
a464 3
		diff = dep->de_FileSize - uio->uio_offset;
		if (diff <= 0)
			return (0);
d467 1
@


1.49
log
@kill breada(), from Sven Dehmlow. ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.48 2004/11/29 17:05:06 grange Exp $	*/
d553 4
@


1.48
log
@Don't use seltrue() in poll ops since it requires v_rdev dereferencing
which is not possible here. Problem found and fixed by form@@.

ok millert@@ fgsch@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.47 2004/09/18 22:01:18 tedu Exp $	*/
d435 1
d475 1
d478 3
a480 3
				error = breada(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, de_cn2bn(pmp, rablock),
				    pmp->pm_bpcluster, NOCRED, &bp);
@


1.47
log
@hierarchy is spelled hierarchy, from Jonathan Gray
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.46 2004/06/24 19:35:25 tholo Exp $	*/
d720 1
a720 1
	return (seltrue(ap->a_vp->v_rdev, ap->a_events, ap->a_p));
@


1.46
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.45 2004/05/14 04:05:05 tedu Exp $	*/
d963 1
a963 1
	 * directory heirarchy above the target, as this would
@


1.45
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.43 2003/11/13 17:19:40 drahn Exp $	*/
d156 1
a156 1
	TIMEVAL_TO_TIMESPEC(&time, &ts);
d219 1
a219 1
		TIMEVAL_TO_TIMESPEC(&time, &ts);
d271 1
a271 1
	TIMEVAL_TO_TIMESPEC(&time, &ts);
d1237 1
a1237 1
	TIMEVAL_TO_TIMESPEC(&time, &ts);
@


1.44
log
@32 bit ints are uint32_t, not u_long.  works on 64bit now.  ok deraadt@@
@
text
@d65 1
d161 1
a161 1
		FREE(cnp->cn_pnbuf, M_NAMEI);
d167 1
a167 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d183 1
a183 1
	FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
d1296 1
a1296 1
		FREE(cnp->cn_pnbuf, M_NAMEI);
d1304 1
a1304 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
@


1.43
log
@Couple of typos in poll changes. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.42 2003/09/23 16:51:13 millert Exp $	*/
d267 2
a268 2
	u_long dirsperblk = pmp->pm_BytesPerSec / sizeof(struct direntry);
	u_long fileid;
d366 1
a366 1
		error = detrunc(dep, (u_long)vap->va_size, 0, cred, ap->a_p);
d452 1
a452 1
		n = min((u_long) (pmp->pm_bpcluster - on), uio->uio_resid);
d512 1
a512 1
	u_long osize;
d514 1
a514 1
	u_long count;
d698 1
a698 1
		u_long a_command;
d873 1
a873 1
	u_long from_diroffset, to_diroffset;
d877 1
a877 1
	u_long cn, pcl;
d1209 1
a1209 1
	u_long newcluster, pcl;
d1366 1
a1366 1
	error = detrunc(ip, (u_long)0, IO_SYNC, cnp->cn_cred, cnp->cn_proc);
d1414 3
a1416 3
	u_long dirsperblk;
	u_long cn;
	u_long fileno;
@


1.42
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.41 2003/08/15 20:32:19 tedu Exp $	*/
d717 1
a717 1
	} */ *ap;
@


1.41
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.40 2003/05/07 22:16:26 deraadt Exp $	*/
d67 1
d710 1
a710 1
msdosfs_select(v)
d713 1
a713 2
#if 0
	struct vop_select_args /* {
d715 1
a715 3
		int a_which;
		int a_fflags;
		struct ucred *a_cred;
a717 1
#endif
d719 1
a719 1
	return (1);             /* DOS filesystems never block? */
d1904 1
a1904 1
	{ &vop_select_desc, msdosfs_select },		/* select */
@


1.40
log
@string cleaning; ok art tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.39 2003/04/26 10:23:07 tedu Exp $	*/
d371 1
a371 1
		    (error = suser(cred, &ap->a_p->p_acflag)) &&
d390 1
a390 1
		    (error = suser(cred, &ap->a_p->p_acflag)))
d404 1
a404 1
		    (error = suser(cred, &ap->a_p->p_acflag)))
@


1.39
log
@fix handling when renaming directories on fat32.  mv a/b . would mess up the
file system.

submitted by mpech@@ in pr1675
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.38 2003/04/18 22:12:25 tedu Exp $	*/
d1502 2
a1503 1
					strcpy(dirbuf.d_name, ".");
d1507 2
a1508 1
					strcpy(dirbuf.d_name, "..");
@


1.38
log
@support for making directories +x without affecting normal files

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.37 2002/05/24 08:54:24 art Exp $	*/
d880 1
a880 1
	u_long cn;
d1138 10
a1147 2
		dotdotp = (struct direntry *)bp->b_data + 1;
		putushort(dotdotp->deStartCluster, dp->de_StartCluster);
@


1.37
log
@protect biodone with splbio
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.36 2002/03/14 01:27:09 millert Exp $	*/
d241 6
d289 1
a289 1
		((dep->de_Attributes & ATTR_READONLY) ? 0 : (S_IWUSR|S_IWGRP|S_IWOTH));
d291 1
a291 1
	if (dep->de_Attributes & ATTR_DIRECTORY)
d293 6
@


1.36
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.35 2001/12/19 08:58:06 art Exp $	*/
d1761 1
d1780 1
d1782 1
@


1.35
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.28 2001/11/06 19:53:20 miod Exp $	*/
d1867 1
a1867 1
int (**msdosfs_vnodeop_p) __P((void *));
d1905 1
a1905 1
	{ (struct vnodeop_desc *)NULL, (int (*) __P((void *)))NULL }
@


1.34
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.33 2001/12/10 02:19:34 art Exp $	*/
a322 1
	struct msdosfsmount *pmp = dep->de_pmp;
d334 1
a334 2
	    (vap->va_uid != VNOVAL && vap->va_uid != pmp->pm_uid) ||
	    (vap->va_gid != VNOVAL && vap->va_gid != pmp->pm_gid)) {
d416 1
d420 1
a420 2
	void *win;
	vsize_t bytelen;
d435 1
a435 19
	if (vp->v_type == VREG) {
		while (uio->uio_resid > 0) {
			bytelen = MIN(dep->de_FileSize - uio->uio_offset,
			    uio->uio_resid);

			if (bytelen == 0)
				break;
			win = ubc_alloc(&vp->v_uobj, uio->uio_offset,
			    &bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error)
				break;
		}
		dep->de_flag |= DE_ACCESS;
		goto out;
	}

	/* this loop is only for directories now */
d439 1
a439 1
		n = MIN((pmp->pm_bpcluster - on), uio->uio_resid);
d446 5
a450 3
		error = pcbmap(dep, lbn, &lbn, 0, &blsize);
		if (error)
			return (error);
d456 15
a470 2
		error = bread(pmp->pm_devvp, lbn, blsize, NOCRED, &bp);
		n = MIN(n, pmp->pm_bpcluster - bp->b_resid);
d478 2
a479 4

out:
	if ((ap->a_ioflag & IO_SYNC) == IO_SYNC)
		error = deupdat(dep, 1);
d496 2
d502 2
a503 1
	daddr_t lastcn;
a504 4
	void *win;
	vsize_t bytelen;
	off_t oldoff;
	boolean_t rv;
d508 1
d524 1
a578 5
	if (dep->de_FileSize < uio->uio_offset + resid) {
		dep->de_FileSize = uio->uio_offset + resid;
		uvm_vnp_setsize(vp, dep->de_FileSize);
	}

d580 1
a580 2
		oldoff = uio->uio_offset;
		if (de_cluster(pmp, oldoff) > lastcn) {
a583 1
		bytelen = MIN(dep->de_FileSize - oldoff, uio->uio_resid);
d585 47
d633 2
a634 2
		 * XXXUBC if file is mapped and this is the last block,
		 * process one page at a time.
a636 8
		if (bytelen == 0)
			break;
		win = ubc_alloc(&vp->v_uobj, oldoff, &bytelen, UBC_WRITE);
		error = uiomove(win, bytelen, uio);
		ubc_release(win, 0);
		if (error) {
			break;
		}
d638 10
a647 2
		 * flush what we just wrote if necessary.
		 * XXXUBC simplistic async flushing.
d649 7
a655 14
		if (ioflag & IO_SYNC) {
			
			simple_lock(&vp->v_uobj.vmobjlock);
			rv = vp->v_uobj.pgops->pgo_flush(
			    &vp->v_uobj, oldoff,
			    oldoff + bytelen, PGO_CLEANIT|PGO_SYNCIO);
			simple_unlock(&vp->v_uobj.vmobjlock);
		} else if (oldoff >> 16 != uio->uio_offset >> 16) {
			simple_lock(&vp->v_uobj.vmobjlock);
			rv = vp->v_uobj.pgops->pgo_flush(
			    &vp->v_uobj, (oldoff >> 16) << 16,
			    (uio->uio_offset >> 16) << 16, PGO_CLEANIT);
			simple_unlock(&vp->v_uobj.vmobjlock);
		}
a656 1
	dep->de_flag |= DE_UPDATE;
d669 1
a669 2
			detrunc(dep, dep->de_FileSize, ioflag & IO_SYNC, NOCRED,
			    NULL);
d1509 1
a1509 1
		n = MIN(pmp->pm_bpcluster - on, uio->uio_resid);
d1513 1
a1513 1
		n = MIN(n, diff);
d1521 1
a1521 1
		n = MIN(n, blsize - bp->b_resid);
d1720 1
d1732 1
a1732 1
	return (pcbmap(dep, ap->a_bn, ap->a_bnp, 0, 0));
d1905 1
a1905 4
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_putpages_desc, genfs_putpages },
	{ &vop_mmap_desc, vop_generic_mmap },
	{ NULL, NULL }
@


1.34.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.34 2001/12/10 04:45:31 art Exp $	*/
d291 1
a291 1
	vap->va_size = ap->a_vp->v_size;
d512 1
d592 10
a601 1
		bytelen = uio->uio_resid;
d603 2
d615 8
a622 1
		if (oldoff >> 16 != uio->uio_offset >> 16) {
d624 1
a624 1
			error = vp->v_uobj.pgops->pgo_put(
d627 1
a629 5
	if (error == 0 && ioflag & IO_SYNC) {
		simple_lock(&vp->v_uobj.vmobjlock);
		error = vp->v_uobj.pgops->pgo_put(&vp->v_uobj, oldoff,
		    oldoff + bytelen, PGO_CLEANIT|PGO_SYNCIO);
	}
d638 10
a647 3
		detrunc(dep, osize, ioflag & IO_SYNC, NOCRED, NULL);
		uio->uio_offset -= resid - uio->uio_resid;
		uio->uio_resid = resid;
@


1.34.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.34.2.1 2002/02/02 03:28:26 art Exp $	*/
a1712 1
	int s;
a1730 1
		s = splbio();	
a1731 1
		splx(s);
d1819 1
a1819 1
int (**msdosfs_vnodeop_p)(void *);
@


1.34.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a240 6
	if (dep->de_Attributes & ATTR_DIRECTORY
	    && pmp->pm_flags & MSDOSFSMNT_ALLOWDIRX) {
		dosmode |= (dosmode & S_IRUSR) ? S_IXUSR : 0;
		dosmode |= (dosmode & S_IRGRP) ? S_IXGRP : 0;
		dosmode |= (dosmode & S_IROTH) ? S_IXOTH : 0;
	}
d283 1
a283 1
	    ((dep->de_Attributes & ATTR_READONLY) ? 0 : (S_IWUSR|S_IWGRP|S_IWOTH));
d285 1
a285 1
	if (dep->de_Attributes & ATTR_DIRECTORY) {
a286 6
		if (pmp->pm_flags & MSDOSFSMNT_ALLOWDIRX) {
			vap->va_mode |= (vap->va_mode & S_IRUSR) ? S_IXUSR : 0;
			vap->va_mode |= (vap->va_mode & S_IRGRP) ? S_IXGRP : 0;
			vap->va_mode |= (vap->va_mode & S_IROTH) ? S_IXOTH : 0;
		}
	}
d821 1
a821 1
	u_long cn, pcl;
d1079 2
a1080 10
		dotdotp = (struct direntry *)bp->b_data;
		putushort(dotdotp[0].deStartCluster, dp->de_StartCluster);
		pcl = dp->de_StartCluster;
		if (FAT32(pmp) && pcl == pmp->pm_rootdirblk)
			pcl = 0;
		putushort(dotdotp[1].deStartCluster, pcl);
		if (FAT32(pmp)) {
			putushort(dotdotp[0].deHighClust, cn >> 16);
			putushort(dotdotp[1].deHighClust, pcl >> 16);
		}
d1435 1
a1435 2
					strlcpy(dirbuf.d_name, ".",
					    sizeof dirbuf.d_name);
d1439 1
a1439 2
					strlcpy(dirbuf.d_name, "..",
					    sizeof dirbuf.d_name);
@


1.33
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.32 2001/12/04 22:44:32 art Exp $	*/
d1881 1
a1881 2
	{ &vop_size_desc, genfs_size },
	{ &vop_mmap_desc, genfs_mmap },
@


1.32
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.31 2001/12/02 18:30:30 drahn Exp $	*/
d444 1
a444 1
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
d605 1
a605 1
		win = ubc_alloc(&vp->v_uvm.u_obj, oldoff, &bytelen, UBC_WRITE);
d617 3
a619 3
			simple_lock(&vp->v_uvm.u_obj.vmobjlock);
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj, oldoff,
d621 1
a621 1
			simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
d623 3
a625 3
			simple_lock(&vp->v_uvm.u_obj.vmobjlock);
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj, (oldoff >> 16) << 16,
d627 1
a627 1
			simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
@


1.31
log
@Fix msdos filesystem read/write errors with large files, bug introduced
with UBC. part of fix from csapuntz@@. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.30 2001/11/28 23:28:32 jakob Exp $	*/
d1882 1
@


1.30
log
@don't generate an error if setting the gid/uid doesn't actually change
the gid/uid. among other things, this eliminates tons of warnings when
unpacking a tar file in an msdos fs. from NetBSD. ok millert@@, fgs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.29 2001/11/27 05:27:12 art Exp $	*/
d605 1
a605 1
		win = ubc_alloc(&vp->v_uvm.u_obj, oldoff, &bytelen, UBC_READ);
a1694 1
	struct msdosfsmount *pmp = dep->de_pmp;
d1706 1
a1706 1
	return (pcbmap(dep, de_bn2cn(pmp, ap->a_bn), ap->a_bnp, 0, 0));
@


1.29
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.28 2001/11/06 19:53:20 miod Exp $	*/
d323 1
d335 2
a336 1
	    (vap->va_uid != VNOVAL) || (vap->va_gid != VNOVAL)) {
@


1.28
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.27 2001/08/23 13:52:35 aaron Exp $	*/
a415 1
	int isadir;
d419 2
a420 1
	daddr_t rablock;
d435 19
a453 1
	isadir = dep->de_Attributes & ATTR_DIRECTORY;
d457 1
a457 1
		n = min((u_long) (pmp->pm_bpcluster - on), uio->uio_resid);
d464 3
a466 5
		if (isadir) {
			error = pcbmap(dep, lbn, &lbn, 0, &blsize);
			if (error)
				return (error);
		}
d472 2
a473 15
		if (isadir) {
			error = bread(pmp->pm_devvp, lbn, blsize, NOCRED, &bp);
		} else {
			rablock = lbn + 1;
			if (dep->de_lastr + 1 == lbn &&
			    de_cn2off(pmp, rablock) < dep->de_FileSize)
				error = breada(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, de_cn2bn(pmp, rablock),
				    pmp->pm_bpcluster, NOCRED, &bp);
			else
				error = bread(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, NOCRED, &bp);
			dep->de_lastr = lbn;
		}
		n = min(n, pmp->pm_bpcluster - bp->b_resid);
d481 4
a484 2
	if (!isadir && !(vp->v_mount->mnt_flag & MNT_NOATIME))
		dep->de_flag |= DE_ACCESS;
a500 2
	int n;
	int croffset;
d505 1
a505 2
	daddr_t bn, lastcn;
	struct buf *bp;
d507 4
a513 1
	struct vnode *thisvp;
a528 1
		thisvp = vp;
d583 5
d589 2
a590 1
		if (de_cluster(pmp, uio->uio_offset) > lastcn) {
d594 1
a595 47
		bn = de_blk(pmp, uio->uio_offset);
		if ((uio->uio_offset & pmp->pm_crbomask) == 0
		    && (de_blk(pmp, uio->uio_offset + uio->uio_resid) > de_blk(pmp, uio->uio_offset)
			|| uio->uio_offset + uio->uio_resid >= dep->de_FileSize)) {
			/*
			 * If either the whole cluster gets written,
			 * or we write the cluster from its start beyond EOF,
			 * then no need to read data from disk.
			 */
			bp = getblk(thisvp, bn, pmp->pm_bpcluster, 0, 0);
			clrbuf(bp);
			/*
			 * Do the bmap now, since pcbmap needs buffers
			 * for the fat table. (see msdosfs_strategy)
			 */
			if (bp->b_blkno == bp->b_lblkno) {
				error = pcbmap(dep,
					       de_bn2cn(pmp, bp->b_lblkno),
					       &bp->b_blkno, 0, 0);
				if (error)
					bp->b_blkno = -1;
			}
			if (bp->b_blkno == -1) {
				brelse(bp);
				if (!error)
					error = EIO;		/* XXX */
				break;
			}
		} else {
			/*
			 * The block we need to write into exists, so read it in.
			 */
			error = bread(thisvp, bn, pmp->pm_bpcluster,
				      NOCRED, &bp);
			if (error) {
				brelse(bp);
				break;
			}
		}

		croffset = uio->uio_offset & pmp->pm_crbomask;
		n = min(uio->uio_resid, pmp->pm_bpcluster - croffset);
		if (uio->uio_offset + n > dep->de_FileSize) {
			dep->de_FileSize = uio->uio_offset + n;
			uvm_vnp_setsize(vp, dep->de_FileSize);
		}
		uvm_vnp_uncache(vp);
d597 2
a598 2
		 * Should these vnode_pager_* functions be done on dir
		 * files?
d601 8
d610 2
a611 1
		 * Copy the data from user space into the buf header.
d613 14
a626 16
		error = uiomove(bp->b_data + croffset, n, uio);

		/*
		 * If they want this synchronous then write it and wait for
		 * it.  Otherwise, if on a cluster boundary write it
		 * asynchronously so we can move on to the next block
		 * without delay.  Otherwise do a delayed write because we
		 * may want to write somemore into the block later.
		 */
		if (ioflag & IO_SYNC)
			(void) bwrite(bp);
		else if (n + croffset == pmp->pm_bpcluster)
			bawrite(bp);
		else
			bdwrite(bp);
		dep->de_flag |= DE_UPDATE;
d628 1
d641 2
a642 1
			detrunc(dep, dep->de_FileSize, ioflag & IO_SYNC, NOCRED, NULL);
d1482 1
a1482 1
		n = min(pmp->pm_bpcluster - on, uio->uio_resid);
d1486 1
a1486 1
		n = min(n, diff);
d1494 1
a1494 1
		n = min(n, blsize - bp->b_resid);
d1755 1
a1755 2
#ifdef DIAGNOSTIC
#endif
d1760 1
d1878 4
a1881 1
	{ (struct vnodeop_desc *)NULL, (int (*) __P((void *)))NULL }
@


1.27
log
@retreive -> retrieve
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.26 2001/07/26 01:53:09 assar Exp $	*/
d68 1
a68 1
#include <vm/vm.h>
@


1.26
log
@remove unused support for creating files and directories from
msdosfs_mknod.  ok'd by art
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.25 2001/06/27 04:58:45 art Exp $	*/
d90 1
a90 1
 * retreive the correct block from the buffer cache since the hash value is
@


1.25
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.24 2001/06/23 02:15:24 csapuntz Exp $	*/
d181 3
a183 15
	switch (ap->a_vap->va_type) {
	case VDIR:
		return (msdosfs_mkdir((struct vop_mkdir_args *)ap));
		break;

	case VREG:
		return (msdosfs_create((struct vop_create_args *)ap));
		break;

	default:
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
		vput(ap->a_dvp);
		return (EINVAL);
	}
	/* NOTREACHED */
@


1.24
log
@Get rid of several vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.23 2001/02/23 14:42:38 csapuntz Exp $	*/
a640 1
#if defined(UVM)
a641 3
#else
			vnode_pager_setsize(vp, dep->de_FileSize);	/* why? */
#endif
a642 1
#if defined(UVM)
a643 3
#else
		(void) vnode_pager_uncache(vp);	/* why not? */
#endif
@


1.23
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.22 2000/06/07 15:04:06 art Exp $	*/
a732 16
int
msdosfs_mmap(v)
	void *v;
{
#if 0
	struct vop_mmap_args /* {
		struct vnode *a_vp;
		int a_fflags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
#endif

	return (EINVAL);
}

a755 60
 * Now the whole work of extending a file is done in the write function.
 * So nothing to do here.
 */
int
msdosfs_seek(v)
	void *v;
{
#if 0
	struct vop_seek_args /* {
		struct vnode *a_vp;
		off_t a_oldoff;
		off_t a_newoff;
		struct ucred *a_cred;
	} */ *ap = v;
#endif

	return (0);
}

int
msdosfs_update(v)
	void *v;
{
	struct vop_update_args /* {
		struct vnode *a_vp;
		struct timespec *a_access;
		struct timespec *a_modify;
		int a_waitfor;
	} */ *ap = v;
	struct buf *bp;
	struct direntry *dirp;
	struct denode *dep;
	int error;
	struct timespec ts;

	if (ap->a_vp->v_mount->mnt_flag & MNT_RDONLY)
		return (0);
	dep = VTODE(ap->a_vp);
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	DETIMES(dep, ap->a_access, ap->a_modify, &ts);
	if ((dep->de_flag & DE_MODIFIED) == 0)
		return (0);
	dep->de_flag &= ~DE_MODIFIED;
	if (dep->de_Attributes & ATTR_DIRECTORY)
		return (0);
	if (dep->de_refcnt <= 0)
		return (0);
	error = readde(dep, &bp, &dirp);
	if (error)
		return (error);
	DE_EXTERNALIZE(dirp, dep);
	if (ap->a_waitfor)
		return (bwrite(bp));
	else {
		bdwrite(bp);
		return (0);
	}
}

/*
a1902 1
	{ &vop_mmap_desc, msdosfs_mmap },		/* mmap */
a1903 1
	{ &vop_seek_desc, msdosfs_seek },		/* seek */
a1923 1
	{ &vop_update_desc, msdosfs_update },		/* update */
@


1.22
log
@Avoid superfluous vrele in msdosfs_rename.
fixes 1249.
From gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.21 1999/02/26 03:28:13 art Exp $	*/
d472 1
a472 1
			if (vp->v_lastr + 1 == lbn &&
d480 1
a480 1
			vp->v_lastr = lbn;
@


1.21
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.20 1999/01/11 05:12:28 millert Exp $	*/
d1063 1
a1063 1
			goto bad;
d1089 1
a1089 1
				goto bad;
d1093 1
a1093 1
				goto bad;
d1098 1
a1098 1
			goto bad;
d1101 1
a1101 1
			goto bad;
d1112 1
a1112 1
		goto abortit;
a1152 1
		VOP_UNLOCK(fvp, 0, p);
a1176 1
			VOP_UNLOCK(fvp, 0, p);
a1184 1
			VOP_UNLOCK(fvp, 0, p);
a1193 1
				VOP_UNLOCK(fvp, 0, p);
a1219 1
			VOP_UNLOCK(fvp, 0, p);
a1225 1
			VOP_UNLOCK(fvp, 0, p);
d1230 1
d1232 2
a1233 1
bad:
a1238 1
	vrele(fdvp);
@


1.21.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.23 2001/02/23 14:42:38 csapuntz Exp $	*/
d472 1
a472 1
			if (dep->de_lastr + 1 == lbn &&
d480 1
a480 1
			dep->de_lastr = lbn;
d1063 1
a1063 1
			goto bad1;
d1089 1
a1089 1
				goto bad1;
d1093 1
a1093 1
				goto bad1;
d1098 1
a1098 1
			goto bad1;
d1101 1
a1101 1
			goto bad1;
d1112 1
a1112 1
		goto bad1;
d1153 1
d1178 1
d1187 1
d1197 1
d1224 1
d1231 1
d1236 1
a1237 3
	VOP_UNLOCK(fvp, 0, p);
	vrele(fdvp);
bad1:
d1243 1
@


1.21.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.21.6.1 2001/05/14 22:32:59 niklas Exp $	*/
d641 1
d643 3
d647 1
d649 3
d733 16
d772 60
d1979 1
d1981 1
d2002 1
@


1.21.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.21.6.2 2001/07/04 10:49:27 niklas Exp $	*/
d90 1
a90 1
 * retrieve the correct block from the buffer cache since the hash value is
d181 15
a195 3
	FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	vput(ap->a_dvp);
	return (EINVAL);
@


1.21.6.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
#include <uvm/uvm_extern.h>
@


1.21.6.5
log
@Merge in -current
@
text
@a322 1
	struct msdosfsmount *pmp = dep->de_pmp;
d334 1
a334 2
	    (vap->va_uid != VNOVAL && vap->va_uid != pmp->pm_uid) ||
	    (vap->va_gid != VNOVAL && vap->va_gid != pmp->pm_gid)) {
d416 1
d420 1
a420 2
	void *win;
	vsize_t bytelen;
d435 1
a435 19
	if (vp->v_type == VREG) {
		while (uio->uio_resid > 0) {
			bytelen = MIN(dep->de_FileSize - uio->uio_offset,
			    uio->uio_resid);

			if (bytelen == 0)
				break;
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
			    &bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error)
				break;
		}
		dep->de_flag |= DE_ACCESS;
		goto out;
	}

	/* this loop is only for directories now */
d439 1
a439 1
		n = MIN((pmp->pm_bpcluster - on), uio->uio_resid);
d446 5
a450 3
		error = pcbmap(dep, lbn, &lbn, 0, &blsize);
		if (error)
			return (error);
d456 15
a470 2
		error = bread(pmp->pm_devvp, lbn, blsize, NOCRED, &bp);
		n = MIN(n, pmp->pm_bpcluster - bp->b_resid);
d478 2
a479 4

out:
	if ((ap->a_ioflag & IO_SYNC) == IO_SYNC)
		error = deupdat(dep, 1);
d496 2
d502 2
a503 1
	daddr_t lastcn;
a504 4
	void *win;
	vsize_t bytelen;
	off_t oldoff;
	boolean_t rv;
d508 1
d524 1
a578 5
	if (dep->de_FileSize < uio->uio_offset + resid) {
		dep->de_FileSize = uio->uio_offset + resid;
		uvm_vnp_setsize(vp, dep->de_FileSize);
	}

d580 1
a580 2
		oldoff = uio->uio_offset;
		if (de_cluster(pmp, oldoff) > lastcn) {
a583 1
		bytelen = MIN(dep->de_FileSize - oldoff, uio->uio_resid);
d585 47
d633 2
a634 2
		 * XXXUBC if file is mapped and this is the last block,
		 * process one page at a time.
a636 8
		if (bytelen == 0)
			break;
		win = ubc_alloc(&vp->v_uvm.u_obj, oldoff, &bytelen, UBC_WRITE);
		error = uiomove(win, bytelen, uio);
		ubc_release(win, 0);
		if (error) {
			break;
		}
d638 10
a647 2
		 * flush what we just wrote if necessary.
		 * XXXUBC simplistic async flushing.
d649 7
a655 14
		if (ioflag & IO_SYNC) {
			
			simple_lock(&vp->v_uvm.u_obj.vmobjlock);
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj, oldoff,
			    oldoff + bytelen, PGO_CLEANIT|PGO_SYNCIO);
			simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
		} else if (oldoff >> 16 != uio->uio_offset >> 16) {
			simple_lock(&vp->v_uvm.u_obj.vmobjlock);
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj, (oldoff >> 16) << 16,
			    (uio->uio_offset >> 16) << 16, PGO_CLEANIT);
			simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
		}
a656 1
	dep->de_flag |= DE_UPDATE;
d669 1
a669 2
			detrunc(dep, dep->de_FileSize, ioflag & IO_SYNC, NOCRED,
			    NULL);
d1509 1
a1509 1
		n = MIN(pmp->pm_bpcluster - on, uio->uio_resid);
d1513 1
a1513 1
		n = MIN(n, diff);
d1521 1
a1521 1
		n = MIN(n, blsize - bp->b_resid);
d1720 1
d1732 1
a1732 1
	return (pcbmap(dep, ap->a_bn, ap->a_bnp, 0, 0));
d1782 2
a1783 1

a1787 1

d1905 1
a1905 4
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_putpages_desc, genfs_putpages },
	{ &vop_size_desc, genfs_size },
	{ NULL, NULL }
@


1.21.6.6
log
@Merge in trunk
@
text
@d323 1
d335 2
a336 1
	    (vap->va_uid != VNOVAL) || (vap->va_gid != VNOVAL)) {
a417 1
	int isadir;
d421 2
a422 1
	daddr_t rablock;
d437 19
a455 1
	isadir = dep->de_Attributes & ATTR_DIRECTORY;
d459 1
a459 1
		n = min((u_long) (pmp->pm_bpcluster - on), uio->uio_resid);
d466 3
a468 5
		if (isadir) {
			error = pcbmap(dep, lbn, &lbn, 0, &blsize);
			if (error)
				return (error);
		}
d474 2
a475 15
		if (isadir) {
			error = bread(pmp->pm_devvp, lbn, blsize, NOCRED, &bp);
		} else {
			rablock = lbn + 1;
			if (dep->de_lastr + 1 == lbn &&
			    de_cn2off(pmp, rablock) < dep->de_FileSize)
				error = breada(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, de_cn2bn(pmp, rablock),
				    pmp->pm_bpcluster, NOCRED, &bp);
			else
				error = bread(vp, de_cn2bn(pmp, lbn),
				    pmp->pm_bpcluster, NOCRED, &bp);
			dep->de_lastr = lbn;
		}
		n = min(n, pmp->pm_bpcluster - bp->b_resid);
d483 4
a486 2
	if (!isadir && !(vp->v_mount->mnt_flag & MNT_NOATIME))
		dep->de_flag |= DE_ACCESS;
a502 2
	int n;
	int croffset;
d507 1
a507 2
	daddr_t bn, lastcn;
	struct buf *bp;
d509 4
a515 1
	struct vnode *thisvp;
a530 1
		thisvp = vp;
d585 5
d591 2
a592 1
		if (de_cluster(pmp, uio->uio_offset) > lastcn) {
d596 1
a597 47
		bn = de_blk(pmp, uio->uio_offset);
		if ((uio->uio_offset & pmp->pm_crbomask) == 0
		    && (de_blk(pmp, uio->uio_offset + uio->uio_resid) > de_blk(pmp, uio->uio_offset)
			|| uio->uio_offset + uio->uio_resid >= dep->de_FileSize)) {
			/*
			 * If either the whole cluster gets written,
			 * or we write the cluster from its start beyond EOF,
			 * then no need to read data from disk.
			 */
			bp = getblk(thisvp, bn, pmp->pm_bpcluster, 0, 0);
			clrbuf(bp);
			/*
			 * Do the bmap now, since pcbmap needs buffers
			 * for the fat table. (see msdosfs_strategy)
			 */
			if (bp->b_blkno == bp->b_lblkno) {
				error = pcbmap(dep,
					       de_bn2cn(pmp, bp->b_lblkno),
					       &bp->b_blkno, 0, 0);
				if (error)
					bp->b_blkno = -1;
			}
			if (bp->b_blkno == -1) {
				brelse(bp);
				if (!error)
					error = EIO;		/* XXX */
				break;
			}
		} else {
			/*
			 * The block we need to write into exists, so read it in.
			 */
			error = bread(thisvp, bn, pmp->pm_bpcluster,
				      NOCRED, &bp);
			if (error) {
				brelse(bp);
				break;
			}
		}

		croffset = uio->uio_offset & pmp->pm_crbomask;
		n = min(uio->uio_resid, pmp->pm_bpcluster - croffset);
		if (uio->uio_offset + n > dep->de_FileSize) {
			dep->de_FileSize = uio->uio_offset + n;
			uvm_vnp_setsize(vp, dep->de_FileSize);
		}
		uvm_vnp_uncache(vp);
d599 2
a600 2
		 * Should these vnode_pager_* functions be done on dir
		 * files?
d603 8
d612 2
a613 1
		 * Copy the data from user space into the buf header.
d615 14
a628 16
		error = uiomove(bp->b_data + croffset, n, uio);

		/*
		 * If they want this synchronous then write it and wait for
		 * it.  Otherwise, if on a cluster boundary write it
		 * asynchronously so we can move on to the next block
		 * without delay.  Otherwise do a delayed write because we
		 * may want to write somemore into the block later.
		 */
		if (ioflag & IO_SYNC)
			(void) bwrite(bp);
		else if (n + croffset == pmp->pm_bpcluster)
			bawrite(bp);
		else
			bdwrite(bp);
		dep->de_flag |= DE_UPDATE;
d630 1
d643 2
a644 1
			detrunc(dep, dep->de_FileSize, ioflag & IO_SYNC, NOCRED, NULL);
d1484 1
a1484 1
		n = min(pmp->pm_bpcluster - on, uio->uio_resid);
d1488 1
a1488 1
		n = min(n, diff);
d1496 1
a1496 1
		n = min(n, blsize - bp->b_resid);
a1694 1
	struct msdosfsmount *pmp = dep->de_pmp;
d1706 1
a1706 1
	return (pcbmap(dep, de_bn2cn(pmp, ap->a_bn), ap->a_bnp, 0, 0));
d1879 4
a1882 1
	{ (struct vnodeop_desc *)NULL, (int (*) __P((void *)))NULL }
@


1.21.6.7
log
@Merge in -current from roughly a week ago
@
text
@d1867 1
a1867 1
int (**msdosfs_vnodeop_p)(void *);
d1905 1
a1905 1
	{ (struct vnodeop_desc *)NULL, (int (*)(void *))NULL }
@


1.21.6.8
log
@Sync the SMP branch with 3.3
@
text
@a1760 1
	int s;
a1778 1
		s = splbio();	
a1779 1
		splx(s);
@


1.21.6.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.21.6.8 2003/03/28 00:00:21 niklas Exp $	*/
a240 6
	if (dep->de_Attributes & ATTR_DIRECTORY
	    && pmp->pm_flags & MSDOSFSMNT_ALLOWDIRX) {
		dosmode |= (dosmode & S_IRUSR) ? S_IXUSR : 0;
		dosmode |= (dosmode & S_IRGRP) ? S_IXGRP : 0;
		dosmode |= (dosmode & S_IROTH) ? S_IXOTH : 0;
	}
d283 1
a283 1
	    ((dep->de_Attributes & ATTR_READONLY) ? 0 : (S_IWUSR|S_IWGRP|S_IWOTH));
d285 1
a285 1
	if (dep->de_Attributes & ATTR_DIRECTORY) {
a286 6
		if (pmp->pm_flags & MSDOSFSMNT_ALLOWDIRX) {
			vap->va_mode |= (vap->va_mode & S_IRUSR) ? S_IXUSR : 0;
			vap->va_mode |= (vap->va_mode & S_IRGRP) ? S_IXGRP : 0;
			vap->va_mode |= (vap->va_mode & S_IROTH) ? S_IXOTH : 0;
		}
	}
d868 1
a868 1
	u_long cn, pcl;
d1126 2
a1127 10
		dotdotp = (struct direntry *)bp->b_data;
		putushort(dotdotp[0].deStartCluster, dp->de_StartCluster);
		pcl = dp->de_StartCluster;
		if (FAT32(pmp) && pcl == pmp->pm_rootdirblk)
			pcl = 0;
		putushort(dotdotp[1].deStartCluster, pcl);
		if (FAT32(pmp)) {
			putushort(dotdotp[0].deHighClust, cn >> 16);
			putushort(dotdotp[1].deHighClust, pcl >> 16);
		}
d1482 1
a1482 2
					strlcpy(dirbuf.d_name, ".",
					    sizeof dirbuf.d_name);
d1486 1
a1486 2
					strlcpy(dirbuf.d_name, "..",
					    sizeof dirbuf.d_name);
@


1.21.6.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a66 1
#include <sys/poll.h>
d371 1
a371 1
		    (error = suser_ucred(cred)) &&
d390 1
a390 1
		    (error = suser_ucred(cred)))
d404 1
a404 1
		    (error = suser_ucred(cred)))
d709 1
a709 1
msdosfs_poll(v)
d712 2
a713 1
	struct vop_poll_args /* {
d715 3
a717 1
		int a_events;
d719 2
a720 1
	} */ *ap = v;
d722 1
a722 1
	return (seltrue(ap->a_vp->v_rdev, ap->a_events, ap->a_p));
d1907 1
a1907 1
	{ &vop_poll_desc, msdosfs_poll },		/* poll */
@


1.21.6.11
log
@Merge with the trunk
@
text
@a64 1
#include <sys/pool.h>
d160 1
a160 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d166 1
a166 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d182 1
a182 1
	pool_put(&namei_pool, ap->a_cnp->cn_pnbuf);
d267 2
a268 2
	uint32_t dirsperblk = pmp->pm_BytesPerSec / sizeof(struct direntry);
	uint32_t fileid;
d366 1
a366 1
		error = detrunc(dep, (uint32_t)vap->va_size, 0, cred, ap->a_p);
d452 1
a452 1
		n = min((uint32_t) (pmp->pm_bpcluster - on), uio->uio_resid);
d512 1
a512 1
	uint32_t osize;
d514 1
a514 1
	uint32_t count;
d698 1
a698 1
		uint32_t a_command;
d873 1
a873 1
	uint32_t from_diroffset, to_diroffset;
d877 1
a877 1
	uint32_t cn, pcl;
d1209 1
a1209 1
	uint32_t newcluster, pcl;
d1295 1
a1295 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d1303 1
a1303 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1366 1
a1366 1
	error = detrunc(ip, (uint32_t)0, IO_SYNC, cnp->cn_cred, cnp->cn_proc);
d1414 3
a1416 3
	uint32_t dirsperblk;
	uint32_t cn;
	uint32_t fileno;
@


1.21.8.1
log
@Pull in patch from current:
Errata:
Some operations in msdosfs could result in a system panic.
Fix (art):
Avoid superfluous vrele in msdosfs_rename.
fixes 1249.
From gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.22 2000/06/07 15:04:06 art Exp $	*/
d1063 1
a1063 1
			goto bad1;
d1089 1
a1089 1
				goto bad1;
d1093 1
a1093 1
				goto bad1;
d1098 1
a1098 1
			goto bad1;
d1101 1
a1101 1
			goto bad1;
d1112 1
a1112 1
		goto bad1;
d1153 1
d1178 1
d1187 1
d1197 1
d1224 1
d1231 1
d1236 1
a1237 3
	VOP_UNLOCK(fvp, 0, p);
	vrele(fdvp);
bad1:
d1243 1
@


1.20
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.19 1999/01/10 23:21:19 art Exp $	*/
d641 3
d645 1
d647 3
d651 1
@


1.19
log
@honor MNT_NOATIME. from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.17 1998/06/09 17:56:03 deraadt Exp $	*/
d1208 1
a1208 1
			panic("msdosfs_rename: updating .. in root directory?\n");
@


1.18
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@a487 2
		if (!isadir)
			dep->de_flag |= DE_ACCESS;
d490 2
@


1.17
log
@the the
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.16 1998/02/23 20:10:39 niklas Exp $	*/
a1755 14
msdosfs_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;

	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
}

int
d1987 1
a1987 1
	{ &vop_abortop_desc, msdosfs_abortop },		/* abortop */
d2000 1
a2000 1
	{ &vop_bwrite_desc, vn_bwrite },		/* bwrite */
@


1.16
log
@GAS 2.8 + KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.15 1998/01/11 20:39:10 provos Exp $	*/
d1513 1
a1513 1
	 * it does i/o only with the the filesystem vnode, and hence can
@


1.15
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.14 1997/11/11 18:57:17 niklas Exp $	*/
d1667 3
a1669 1
				        fileno |= getushort(dentp->deHighClust) << 16;
d1672 4
a1675 6
				        if (FAT32(pmp))
					        fileno = cntobn(pmp,
								pmp->pm_rootdirblk)
						         * dirsperblk;
					else
					        fileno = 1;
d1677 2
a1678 1
				        fileno = cntobn(pmp, fileno) * dirsperblk;
d1689 2
a1690 1
				fileno += dentp - (struct direntry *)bp->b_data;
@


1.14
log
@Initialize the de_lock.  some KNF
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_vnops.c,v 1.13 1997/11/06 05:58:58 csapuntz Exp $	*/
/*	$NetBSD: msdosfs_vnops.c,v 1.48 1996/03/20 00:45:43 thorpej Exp $	*/
d5 2
a6 2
 * Copyright (C) 1994, 1995 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995 TooLs GmbH.
a267 1
	u_int cn;
d269 1
d272 2
d284 3
a286 2
		if ((cn = dep->de_StartCluster) == MSDOSFSROOT)
			cn = 1;
d288 4
a291 4
		if ((cn = dep->de_dirclust) == MSDOSFSROOT)
			cn = 1;
		cn = (cn << 16)
		    | ((dep->de_diroffset / sizeof(struct direntry)) & 0xffff);
d293 1
a293 1
	vap->va_fileid = cn;
d304 1
a304 1
	dos2unixtime(dep->de_MDate, dep->de_MTime, &vap->va_mtime);
d306 2
a307 8
		dos2unixtime(dep->de_ADate, 0, &vap->va_atime);
		dos2unixtime(dep->de_CDate, dep->de_CTime, &vap->va_ctime);
		if (dep->de_CTimeHundredth >= 100) {
			vap->va_ctime.tv_sec++;
			vap->va_ctime.tv_nsec = (dep->de_CTimeHundredth - 100) * 10000000;
		} else
			vap->va_ctime.tv_nsec = dep->de_CTimeHundredth * 10000000; 

d377 1
a377 1
			unix2dostime(&vap->va_atime, &dep->de_ADate, NULL);
d379 1
a379 1
			unix2dostime(&vap->va_mtime, &dep->de_MDate, &dep->de_MTime);
d988 8
d1251 1
a1251 1
		{ 0, 0 },				/* reserved */
d1262 1
a1262 1
		{ 0, 0 },				/* reserved */
d1285 1
a1285 1
	u_long newcluster;
d1333 4
a1336 1
	putushort(denp[1].deStartCluster, pdep->de_StartCluster);
d1343 5
d1490 1
d1546 2
d1555 2
a1556 1
	if (dep->de_StartCluster == MSDOSFSROOT) {
d1565 6
a1570 1
				dirbuf.d_fileno = 1;
d1665 3
a1668 1
				fileno = getushort(dentp->deStartCluster);
d1670 10
a1679 1
					fileno = 1;
d1685 6
a1690 4
				if ((fileno = cn) == MSDOSFSROOT)
					fileno = 1;
				fileno = (fileno << 16) |
				    ((dentp - (struct direntry *)bp->b_data) & 0xffff);
a1691 3
			dirbuf.d_fileno = fileno;
			dirbuf.d_type =
			    (dentp->deAttributes & ATTR_DIRECTORY) ? DT_DIR : DT_REG;
d1909 1
a1909 1
	    "tag VT_MSDOSFS, startcluster %d, dircluster %ld, diroffset %ld ",
@


1.13
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.12 1997/10/06 20:21:00 deraadt Exp $	*/
d1747 1
a1747 1
			ap->a_p));
d1760 1
a1760 1
		&vp->v_interlock, ap->a_p));
@


1.12
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.10 1997/10/04 19:08:13 deraadt Exp $	*/
d228 1
a228 1
	if (vp->v_usecount > 1 && !(dep->de_flag & DE_LOCKED)) {
d952 1
d993 1
a993 1
	if ((error = VOP_LOCK(fvp)) != 0)
d1013 1
a1013 1
			VOP_UNLOCK(fvp);
d1044 1
a1044 1
	VOP_UNLOCK(fvp);
d1110 1
a1110 1
		VOP_UNLOCK(tdvp);
d1120 1
a1120 1
			VOP_UNLOCK(tdvp);
d1140 1
a1140 1
		VOP_UNLOCK(fvp);
d1142 1
a1142 1
			VOP_UNLOCK(fdvp);
d1164 2
a1165 2
				VOP_UNLOCK(fdvp);
			VOP_UNLOCK(fvp);
d1173 2
a1174 2
				VOP_UNLOCK(fdvp);
			VOP_UNLOCK(fvp);
d1183 2
a1184 2
					VOP_UNLOCK(fdvp);
				VOP_UNLOCK(fvp);
d1192 1
a1192 1
			VOP_UNLOCK(fdvp);
d1211 1
a1211 1
			VOP_UNLOCK(fvp);
d1218 1
a1218 1
			VOP_UNLOCK(fvp);
d1223 1
a1223 1
	VOP_UNLOCK(fvp);
d1467 2
a1468 2
		u_long *a_cookies;
		int a_ncookies;
d1487 2
a1488 2
	u_long *cookies;
	int ncookies;
d1524 7
a1530 2
	cookies = ap->a_cookies;
	ncookies = ap->a_ncookies;
d1690 4
d1741 2
d1744 1
a1744 5
	register struct vnode *vp = ap->a_vp;
	register struct denode *dep;
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */
#endif
d1746 2
a1747 34
start:
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		sleep((caddr_t)vp, PINOD);
	}
	if (vp->v_tag == VT_NON)
		return (ENOENT);
	dep = VTODE(vp);
	if (dep->de_flag & DE_LOCKED) {
		dep->de_flag |= DE_WANTED;
#ifdef DIAGNOSTIC
		if (p) {
			if (p->p_pid == dep->de_lockholder)
				panic("locking against myself");
			dep->de_lockwaiter = p->p_pid;
		} else
			dep->de_lockwaiter = -1;
#endif
		(void) sleep((caddr_t)dep, PINOD);
		goto start;
	}
#ifdef DIAGNOSTIC
	dep->de_lockwaiter = 0;
	if (dep->de_lockholder != 0)
		panic("lockholder (%d) != 0", dep->de_lockholder);
	if (p && p->p_pid == 0)
		printf("locking by process 0\n");
	if (p)
		dep->de_lockholder = p->p_pid;
	else
		dep->de_lockholder = -1;
#endif
	dep->de_flag |= DE_LOCKED;
	return (0);
d1757 1
a1757 4
	register struct denode *dep = VTODE(ap->a_vp);
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */
#endif
d1759 2
a1760 17
#ifdef DIAGNOSTIC
	if ((dep->de_flag & DE_LOCKED) == 0) {
		vprint("msdosfs_unlock: unlocked denode", ap->a_vp);
		panic("msdosfs_unlock NOT LOCKED");
	}
	if (p && p->p_pid != dep->de_lockholder && p->p_pid > -1 &&
	    dep->de_lockholder > -1/* && lockcount++ < 100*/)
		panic("unlocker (%d) != lock holder (%d)",
		    p->p_pid, dep->de_lockholder);
	dep->de_lockholder = 0;
#endif
	dep->de_flag &= ~DE_LOCKED;
	if (dep->de_flag & DE_WANTED) {
		dep->de_flag &= ~DE_WANTED;
		wakeup((caddr_t)dep);
	}
	return (0);
d1771 1
a1771 3
	if (VTODE(ap->a_vp)->de_flag & DE_LOCKED)
		return (1);
	return (0);
d1881 1
a1881 1
	    dep->de_flag & DE_LOCKED ? "(LOCKED)" : "");
d1883 1
a1883 6
	if (dep->de_lockholder) {
		printf("    owner pid %d", dep->de_lockholder);
		if (dep->de_lockwaiter)
			printf(" waiting pid %d", dep->de_lockwaiter);
		printf("\n");
	}
d1885 1
@


1.11
log
@VFS Lite2 Changes
@
text
@a951 1
	struct proc *p = curproc; /* XXX */
d992 1
a992 1
	if ((error = vn_lock(fvp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
d1012 1
a1012 1
			VOP_UNLOCK(fvp, 0, p);
d1043 1
a1043 1
	VOP_UNLOCK(fvp, 0, p);
d1109 1
a1109 1
		VOP_UNLOCK(tdvp, 0, p);
d1119 1
a1119 1
			VOP_UNLOCK(tdvp, 0, p);
d1139 1
a1139 1
		VOP_UNLOCK(fvp, 0, p);
d1141 1
a1141 1
			VOP_UNLOCK(fdvp, 0, p);
d1163 2
a1164 2
				VOP_UNLOCK(fdvp, 0, p);
			VOP_UNLOCK(fvp, 0, p);
d1172 2
a1173 2
				VOP_UNLOCK(fdvp, 0, p);
			VOP_UNLOCK(fvp, 0, p);
d1182 2
a1183 2
					VOP_UNLOCK(fdvp, 0, p);
				VOP_UNLOCK(fvp, 0, p);
d1191 1
a1191 1
			VOP_UNLOCK(fdvp, 0, p);
d1210 1
a1210 1
			VOP_UNLOCK(fvp, 0, p);
d1217 1
a1217 1
			VOP_UNLOCK(fvp, 0, p);
d1222 1
a1222 1
	VOP_UNLOCK(fvp, 0, p);
d1466 2
a1467 2
		u_long **a_cookies;
		int *a_ncookies;
d1486 2
a1487 2
	u_long *cookies = NULL;
	int ncookies = 0;
d1523 2
a1524 7
	if (ap->a_ncookies) {
		ncookies = uio->uio_resid / sizeof(struct direntry) + 3;
		MALLOC(cookies, u_long *, ncookies * sizeof(u_long), M_TEMP,
		       M_WAITOK);
		*ap->a_cookies = cookies;
		*ap->a_ncookies = ncookies;
	}
a1683 4
	/* Subtract unused cookies */
	if (ap->a_ncookies)
		*ap->a_ncookies -= ncookies;

@


1.10
log
@cleanup timestamp code for NT/Win95; khym@@bga.com
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.9 1997/07/03 17:49:53 deraadt Exp $	*/
d952 1
d993 1
a993 1
	if ((error = VOP_LOCK(fvp)) != 0)
d1013 1
a1013 1
			VOP_UNLOCK(fvp);
d1044 1
a1044 1
	VOP_UNLOCK(fvp);
d1110 1
a1110 1
		VOP_UNLOCK(tdvp);
d1120 1
a1120 1
			VOP_UNLOCK(tdvp);
d1140 1
a1140 1
		VOP_UNLOCK(fvp);
d1142 1
a1142 1
			VOP_UNLOCK(fdvp);
d1164 2
a1165 2
				VOP_UNLOCK(fdvp);
			VOP_UNLOCK(fvp);
d1173 2
a1174 2
				VOP_UNLOCK(fdvp);
			VOP_UNLOCK(fvp);
d1183 2
a1184 2
					VOP_UNLOCK(fdvp);
				VOP_UNLOCK(fvp);
d1192 1
a1192 1
			VOP_UNLOCK(fdvp);
d1211 1
a1211 1
			VOP_UNLOCK(fvp);
d1218 1
a1218 1
			VOP_UNLOCK(fvp);
d1223 1
a1223 1
	VOP_UNLOCK(fvp);
d1467 2
a1468 2
		u_long *a_cookies;
		int a_ncookies;
d1487 2
a1488 2
	u_long *cookies;
	int ncookies;
d1524 7
a1530 2
	cookies = ap->a_cookies;
	ncookies = ap->a_ncookies;
d1690 4
@


1.9
log
@rm of dir returns EPERM; more careful about ..; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.8 1997/03/02 18:02:01 millert Exp $	*/
d303 1
a303 1
		dos2unixtime(dep->de_ADate, dep->de_ATime, &vap->va_atime);
d305 6
d380 1
a380 1
			unix2dostime(&vap->va_atime, &dep->de_ADate, &dep->de_ATime);
d1241 2
a1242 1
		{ 0, 0 }, 				/* reserved */
d1244 2
a1245 1
		{ 0, 0 }, { 0, 0 },			/* access time & date */
d1252 2
a1253 1
		{ 0, 0 }, 				/* reserved */
d1255 2
a1256 1
		{ 0, 0 }, { 0, 0 },			/* access time & date */
d1323 1
a1324 1
	putushort(denp[0].deATime, ndirent.de_ATime);
d1330 1
a1331 1
	putushort(denp[1].deATime, ndirent.de_ATime);
@


1.8
log
@Sync msdosfs with NetBSD sans const-ness.  NetSBD log messages:
    Fix panic on mkdir.
    Thanks to Dave Huang for finding the bug.
    Fixes a bug with allowed/forbidden characters in non-W95 filenames.
    Don't extend directory when nothing is written to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.7 1996/10/24 17:56:18 tholo Exp $	*/
d839 4
a842 1
	error = removede(ddep, dep);
d1002 3
a1004 1
		    dp == ip || (fcnp->cn_flags & ISDOTDOT) ||
@


1.7
log
@<sys/dir.h> is for use as a compatibility interface only.  Warn if
included by kernel modules, and also remove use from any modules that
currently attempt to use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.6 1996/10/04 03:05:32 deraadt Exp $	*/
d37 1
a37 1
 * 
d40 1
a40 1
 * 
d42 1
a42 1
 * 
d47 1
a47 1
 * 
d78 1
a78 1
 * 
d115 1
d145 1
a145 1
		
d154 2
a155 1
	DE_TIMES(&ndirent);
d180 1
a180 1
	
d226 1
d228 4
a231 2
	if (vp->v_usecount > 1 && !(dep->de_flag & DE_LOCKED))
		DE_TIMES(dep);
d248 1
a248 1
	
d271 1
d273 2
a274 1
	DE_TIMES(dep);
d334 1
a334 1
	
d337 1
a337 1
	       ap->a_vp, vap, cred, ap->a_p);
d347 1
a347 1
		       vap->va_type, vap->va_nlink, vap->va_fsid, vap->va_fileid);
d349 1
a349 1
		       vap->va_blocksize, vap->va_rdev, vap->va_bytes, vap->va_gen);
d351 1
a351 1
		       vap->va_uid, vap->va_gid);
d369 1
a369 1
		    ((vap->va_vaflags & VA_UTIMES_NULL) == 0 || 
d521 1
a521 1
	
d524 1
a524 1
	       vp, uio, ioflag, cred);
d526 1
a526 1
	       dep->de_diroffset, dep->de_dirclust, dep->de_StartCluster);
d587 1
a587 1
	
d593 1
a593 1
		
d719 1
a719 1
	return (1);		/* DOS filesystems never block? */
d740 1
a740 1
 * 
d781 46
d876 1
a876 1
 * 
d878 1
a878 1
 * 
d910 1
a910 1
 * 
d916 1
a916 1
 * 
d1027 1
a1027 1
	 * as to be able to change "..". We must repeat the call 
d1182 1
a1182 1
	
d1268 1
d1289 4
a1292 5
	if (!(pmp->pm_flags & MSDOSFSMNT_NOWIN95)) {
		unix2dostime(NULL, &ndirent.de_CDate, &ndirent.de_CTime);
		unix2dostime(NULL, &ndirent.de_ADate, &ndirent.de_ATime);
	}
	unix2dostime(NULL, &ndirent.de_MDate, &ndirent.de_MTime);
d1333 1
a1333 1
	
d1475 1
a1475 1
	
d1478 1
a1478 1
	       ap->a_vp, uio, ap->a_cred, ap->a_eofflag);
d1494 1
a1494 1
	
d1510 1
a1510 1
	
d1519 4
a1522 4
		/*
		 * printf("msdosfs_readdir(): going after . or .. in root dir, offset %d\n",
		 *	  offset);
		 */
d1580 4
a1583 4
			/*
			 * printf("rd: dentp %08x prev %08x crnt %08x deName %02x attr %02x\n",
			 *	  dentp, prev, crnt, dentp->deName[0], dentp->deAttributes);
			 */
d1598 1
a1598 1
			
d1608 1
a1608 1
			
d2012 2
a2013 1
	{ &vop_bwrite_desc, vn_bwrite },
@


1.6
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_vnops.c,v 1.4 1996/04/19 16:10:03 niklas Exp $	*/
d65 1
a65 1
#include <sys/dir.h>		/* defines dirent structure */
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@a928 8
	/*
	 * Convert the filename in tcnp into a dos filename. We copy this
	 * into the denode and directory entry for the destination
	 * file/directory.
	 */
	if ((error = uniqdosname(VTODE(tdvp), tcnp, toname)) != 0)
		goto abortit;

d1027 8
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_vnops.c,v 1.3 1996/02/29 10:46:59 niklas Exp $	*/
/*	$NetBSD: msdosfs_vnops.c,v 1.47 1996/03/08 18:13:10 scottr Exp $	*/
d1666 1
d1668 1
d1714 1
d1716 1
d1852 3
a1854 2
	printf("tag VT_MSDOSFS, startcluster %d, dircluster %d, diroffset %d ",
	       dep->de_StartCluster, dep->de_dirclust, dep->de_diroffset);
d1856 2
a1857 2
	       major(dep->de_dev), minor(dep->de_dev),
	       dep->de_flag & DE_LOCKED ? "(LOCKED)" : "");
@


1.3
log
@From NetBSD: merge with 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: msdosfs_vnops.c,v 1.46 1996/02/09 19:13:53 christos Exp $	*/
d1486 1
a1486 1
				dirbuf.d_reclen = DIRSIZ(&dirbuf);
d1593 1
a1593 1
			dirbuf.d_reclen = DIRSIZ(&dirbuf);
@


1.2
log
@from netbsd (mostly by ws):
Win95 ignores case on lookup
Really don't generate long names when mounted with -s
Fix cookie handling
Don't forward credentials to bread, it makes nfs panic
(Of course, nfs shouldn't rely on the credentials not being referenced)
Don't give directory entry to deget, it could result in a deadlock
Use device blocks, not clusters for logical block numbers
Add support for Win'95 separate creation/modification/access timestamps
Re-introduce lowercase filenames for non-Win'95-filesystems
Fix thinko with block boundaries in directories
Don't overwrite dirclust, it's needed later on
Enable flock(2).
@
text
@d1 2
a2 1
/*	$NetBSD: msdosfs_vnops.c,v 1.43 1995/12/01 07:26:58 mycroft Exp $	*/
d62 1
d68 2
d101 3
a103 1
msdosfs_create(ap)
d109 1
a109 2
	} */ *ap;
{
d142 1
a142 1
	if (error = uniqdosname(pdep, cnp, ndirent.de_Name))
d154 1
a154 1
	if (error = createde(&ndirent, pdep, &dep, cnp))
d169 3
a171 1
msdosfs_mknod(ap)
d177 1
a177 3
	} */ *ap;
{
	int error;
d197 4
a200 1
msdosfs_open(ap)
d207 1
a207 1
{
d213 3
a215 1
msdosfs_close(ap)
d221 1
a221 2
	} */ *ap;
{
d231 3
a233 1
msdosfs_access(ap)
d239 1
a239 2
	} */ *ap;
{
d254 3
a256 1
msdosfs_getattr(ap)
d262 1
a262 2
	} */ *ap;
{
d314 3
a316 1
msdosfs_setattr(ap)
d322 1
a322 2
	} */ *ap;
{
d355 2
a356 1
		if (error = detrunc(dep, (u_long)vap->va_size, 0, cred, ap->a_p))
d359 1
a359 1
	if (vap->va_atime.ts_sec != VNOVAL || vap->va_mtime.ts_sec != VNOVAL) {
d366 1
a366 1
		    && vap->va_atime.ts_sec != VNOVAL)
d368 1
a368 1
		if (vap->va_mtime.ts_sec != VNOVAL)
d406 3
a408 1
msdosfs_read(ap)
d414 1
a414 2
	} */ *ap;
{
d489 3
a491 1
msdosfs_write(ap)
d497 1
a497 2
	} */ *ap;
{
d502 1
a502 1
	int error;
d557 1
a557 1
		if (error = deextend(dep, uio->uio_offset, cred))
d603 4
a606 3
				if (error = pcbmap(dep,
				    de_bn2cn(pmp, bp->b_lblkno),
				    &bp->b_blkno, 0, 0)) 
d619 3
a621 1
			if (error = bread(thisvp, bn, pmp->pm_bpcluster, NOCRED, &bp)) {
d681 4
a684 1
msdosfs_ioctl(ap)
d693 1
a693 1
{
d699 4
a702 1
msdosfs_select(ap)
d710 1
a710 1
{
d716 4
a719 1
msdosfs_mmap(ap)
d726 1
a726 1
{
d738 3
a740 1
msdosfs_fsync(ap)
d746 1
a746 2
	} */ *ap;
{
d758 4
a761 1
msdosfs_seek(ap)
d767 2
a768 2
	} */ *ap;
{
d774 3
a776 1
msdosfs_remove(ap)
d781 1
a781 2
	} */ *ap;
{
d805 3
a807 1
msdosfs_link(ap)
d809 1
a810 1
		struct vnode *a_tdvp;
d812 1
a812 2
	} */ *ap;
{
d814 2
a815 2
	VOP_ABORTOP(ap->a_vp, ap->a_cnp);
	vput(ap->a_vp);
d873 3
a875 1
msdosfs_rename(ap)
d883 1
a883 2
	} */ *ap;
{
a899 1
	struct direntry *ep;
d934 1
a934 1
	if (error = uniqdosname(VTODE(tdvp), tcnp, toname))
d938 1
a938 1
	if (error = VOP_LOCK(fvp))
d1000 1
a1000 1
		if (error = doscheckpath(ip, dp))
d1004 1
a1004 1
		if (error = relookup(tdvp, &tvp, tcnp))
d1030 1
a1030 1
		if (error = removede(dp, xp))
d1095 2
a1096 1
		if (error = createde(ip, dp, (struct denode **)0, tcnp)) {
d1105 1
a1105 1
		if (error = removede(zp, ip)) {
d1113 3
a1115 2
			if (error = pcbmap(dp, de_cluster(pmp, to_diroffset), 0,
					   &ip->de_dirclust, 0)) {
d1141 3
a1143 2
		if (error = bread(pmp->pm_devvp, bn, pmp->pm_bpcluster, NOCRED,
				  &bp)) {
d1151 1
a1151 1
		if (error = bwrite(bp)) {
d1175 18
a1192 12
	".       ", "   ",		/* the . entry */
	ATTR_DIRECTORY,			/* file attribute */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* resevered */
	210, 4, 210, 4,			/* time and date */
	0, 0,				/* startcluster */
	0, 0, 0, 0,			/* filesize */
	"..      ", "   ",		/* the .. entry */
	ATTR_DIRECTORY,			/* file attribute */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* resevered */
	210, 4, 210, 4,			/* time and date */
	0, 0,				/* startcluster */
	0, 0, 0, 0,			/* filesize */
d1196 3
a1198 1
msdosfs_mkdir(ap)
d1204 1
a1204 2
	} */ *ap;
{
d1230 2
a1231 1
	if (error = clusteralloc(pmp, 0, 1, CLUST_EOFE, &newcluster, NULL))
d1266 1
a1266 1
	if (error = bwrite(bp))
d1278 1
a1278 1
	if (error = uniqdosname(pdep, cnp, ndirent.de_Name))
d1286 1
a1286 1
	if (error = createde(&ndirent, pdep, &dep, cnp))
d1303 3
a1305 1
msdosfs_rmdir(ap)
d1310 1
a1310 2
	} */ *ap;
{
d1347 1
a1347 1
	if (error = removede(dp, ip))
d1373 3
a1375 1
msdosfs_symlink(ap)
d1382 1
a1382 4
	} */ *ap;
{
	register struct vnode *dvp = ap->a_dvp;
	register struct componentname *cnp = ap->a_cnp;
d1384 3
a1386 3
	FREE(cnp->cn_pnbuf, M_NAMEI);
	vput(dvp);
	return (EINVAL);
d1390 3
a1392 1
msdosfs_readdir(ap)
d1400 1
a1400 2
	} */ *ap;
{
a1416 1
	int i = 0;
d1489 3
a1491 1
				if (error = uiomove(&dirbuf, dirbuf.d_reclen, uio))
d1511 1
a1511 1
		if (error = pcbmap(dep, lbn, &bn, &cn, &blsize))
d1513 2
a1514 1
		if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) {
d1598 3
a1600 1
			if (error = uiomove(&dirbuf, dirbuf.d_reclen, uio)) {
d1629 4
a1632 1
msdosfs_readlink(ap)
d1638 1
a1638 1
{
d1644 3
a1646 1
msdosfs_abortop(ap)
d1650 1
a1650 2
	} */ *ap;
{
d1658 3
a1660 1
msdosfs_lock(ap)
d1663 1
a1663 2
	} */ *ap;
{
d1705 3
a1707 1
msdosfs_unlock(ap)
d1710 1
a1710 2
	} */ *ap;
{
d1734 3
a1736 1
msdosfs_islocked(ap)
d1739 1
a1739 2
	} */ *ap;
{
d1754 3
a1756 1
msdosfs_bmap(ap)
d1763 1
a1763 2
	} */ *ap;
{
d1781 4
a1784 1
msdosfs_reallocblks(ap)
d1788 2
a1789 2
	} */ *ap;
{
d1796 3
a1798 1
msdosfs_strategy(ap)
d1801 1
a1801 2
	} */ *ap;
{
d1816 3
a1818 2
		if (error = pcbmap(dep, de_bn2cn(dep->de_pmp, bp->b_lblkno),
		    &bp->b_blkno, 0, 0))
d1840 3
a1842 1
msdosfs_print(ap)
d1845 1
a1845 2
	} */ *ap;
{
d1861 1
d1865 3
a1867 1
msdosfs_advlock(ap)
d1874 1
a1874 2
	} */ *ap;
{
d1882 3
a1884 1
msdosfs_pathconf(ap)
d1889 1
a1889 2
	} */ *ap;
{
d1915 1
a1915 1
int (**msdosfs_vnodeop_p)();
d1955 1
a1955 1
	{ (struct vnodeop_desc *)NULL, (int (*)())NULL }
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: msdosfs_vnops.c,v 1.37 1995/09/09 19:38:10 ws Exp $	*/
d4 2
a5 2
 * Copyright (C) 1994 Wolfgang Solfrank.
 * Copyright (C) 1994 TooLs GmbH.
d64 1
d120 2
a121 1
	if (pdep->de_StartCluster == MSDOSFSROOT && pdep->de_fndclust == (u_long)-1) {
d137 3
a139 2
	unix2dostime(NULL, &ndirent.de_Date, &ndirent.de_Time);
	unix2dosfn((u_char *)cnp->cn_nameptr, ndirent.de_Name, cnp->cn_namelen);
d146 4
a149 1
	if (error = createde(&ndirent, pdep, &dep))
d283 8
a290 7
	dos2unixtime(dep->de_Date, dep->de_Time, &vap->va_atime);
	vap->va_mtime = vap->va_atime;
#ifndef MSDOSFS_NODIRMOD
	if (vap->va_mode & S_IFDIR)
		TIMEVAL_TO_TIMESPEC(&time, &vap->va_mtime);
#endif
	vap->va_ctime = vap->va_atime;
d336 3
d346 1
a346 1
	if (vap->va_mtime.ts_sec != VNOVAL) {
d352 5
a356 1
		unix2dostime(&vap->va_mtime, &dep->de_Date, &dep->de_Time);
d389 1
a389 1
	return (0);
d425 1
a425 1
		lbn = uio->uio_offset >> pmp->pm_cnshift;
d449 7
a455 7
			    rablock * pmp->pm_bpcluster < dep->de_FileSize) {
				error = breada(vp, lbn, pmp->pm_bpcluster,
					       rablock, pmp->pm_bpcluster, NOCRED, &bp);
			} else {
				error = bread(vp, lbn, pmp->pm_bpcluster, NOCRED,
					      &bp);
			}
d464 2
d507 2
a508 1
	if (vp->v_type == VREG) {
d512 4
a515 1
	} else
d517 1
d528 1
a528 1
	if (vp->v_type == VREG && p &&
d530 1
a530 1
		p->p_rlimit[RLIMIT_FSIZE].rlim_cur)) {
a535 9
	 * If attempting to write beyond the end of the root directory we
	 * stop that here because the root directory can not grow.
	 */
	if ((dep->de_Attributes & ATTR_DIRECTORY) &&
	    dep->de_StartCluster == MSDOSFSROOT &&
	    (uio->uio_offset + uio->uio_resid) > dep->de_FileSize)
		return (ENOSPC);

	/*
d567 1
a567 2
		bn = de_blk(pmp, uio->uio_offset);
		if (bn > lastcn) {
d572 1
d588 3
a590 2
				if (error = pcbmap(dep, bp->b_lblkno,
						   &bp->b_blkno, 0, 0)) 
d603 2
a604 1
			if (error = bread(thisvp, bn, pmp->pm_bpcluster, cred, &bp))
d606 1
d657 1
a657 1
	} else
d856 1
a856 1
	register struct denode *ip, *xp, *dp;
d858 2
a859 1
	u_long to_dirclust, to_diroffset;
d901 2
a902 1
	unix2dosfn((u_char *)tcnp->cn_nameptr, toname, tcnp->cn_namelen);
a939 1
	to_dirclust = dp->de_fndclust;
d941 1
d963 4
a966 1
		/* doscheckpath() vput()'s dp */
d1027 2
d1051 6
a1056 3
		 * If the source and destination are in the same directory then
		 * just read in the directory entry, change the name in the
		 * directory entry and write it back to disk.
d1058 7
a1064 32
		if (!newparent) {
			if (error = readep(dp->de_pmp,
					   dp->de_fndclust,
					   dp->de_fndoffset,
					   &bp, &ep)) {
				VOP_UNLOCK(fvp);
				goto bad;
			}
			bcopy(toname, ep->deName, 11);
			if (error = bwrite(bp)) {
				VOP_UNLOCK(fvp);
				goto bad;
			}
			bcopy(toname, ip->de_Name, 11);	/* update denode */
		} else {
			struct denode *zp;

			/*
			 * If the source and destination are in different
			 * directories, then write a new entry in the destination
			 * directory and mark the entry in the source directory
			 * as deleted.  Then move the denode to the correct hash
			 * chain for its new location in the filesystem.  And, if
			 * we moved a directory, then update its .. entry to point
			 * to the new parent directory.
			 */
			bcopy(ip->de_Name, oldname, 11);
			bcopy(toname, ip->de_Name, 11);	/* update denode */
			dp->de_fndclust = to_dirclust;
			dp->de_fndoffset = to_diroffset;
			if (error = createde(ip, dp, (struct denode **)0)) {
				bcopy(oldname, ip->de_Name, 11);
d1066 8
a1073 7
				VOP_UNLOCK(fvp);
				goto bad;
			}
			zp = VTODE(fdvp);
			if (error = readep(zp->de_pmp, zp->de_fndclust, zp->de_fndoffset,
					   &bp, &ep)) {
				/* XXX should really panic here, fs is corrupt */
d1075 6
a1080 5
				VOP_UNLOCK(fvp);
				goto bad;
			}
			ep->deName[0] = SLOT_DELETED;
			if (error = bwrite(bp)) {
d1082 2
a1083 1
				VOP_UNLOCK(fdvp);
d1087 5
a1091 5
			if (!doingdirectory) {
				ip->de_dirclust = to_dirclust;
				ip->de_diroffset = to_diroffset;
			}
			reinsert(ip);
d1093 19
d1113 6
a1118 25

		/*
		 * If we moved a directory to a new parent directory, then we must
		 * fixup the ".." entry in the moved directory.
		 */
		if (doingdirectory && newparent) {
			cn = ip->de_StartCluster;
			if (cn == MSDOSFSROOT) {
				/* this should never happen */
				panic("msdosfs_rename: updating .. in root directory?\n");
			} else
				bn = cntobn(pmp, cn);
			if (error = bread(pmp->pm_devvp, bn, pmp->pm_bpcluster, NOCRED,
					  &bp)) {
				/* XXX should really panic here, fs is corrupt */
				VOP_UNLOCK(fvp);
				goto bad;
			}
			dotdotp = (struct direntry *)bp->b_data + 1;
			putushort(dotdotp->deStartCluster, dp->de_StartCluster);
			if (error = bwrite(bp)) {
				/* XXX should really panic here, fs is corrupt */
				VOP_UNLOCK(fvp);
				goto bad;
			}
d1178 2
a1179 1
	if (pdep->de_StartCluster == MSDOSFSROOT && pdep->de_fndclust == (u_long)-1) {
d1191 5
a1195 1
	unix2dostime(NULL, &ndirent.de_Date, &ndirent.de_Time);
d1209 6
a1214 2
	putushort(denp[0].deDate, ndirent.de_Date);
	putushort(denp[0].deTime, ndirent.de_Time);
d1216 6
a1221 2
	putushort(denp[1].deDate, ndirent.de_Date);
	putushort(denp[1].deTime, ndirent.de_Time);
d1234 3
a1236 1
	unix2dosfn((u_char *)cnp->cn_nameptr, ndirent.de_Name, cnp->cn_namelen);
d1242 1
a1242 1
	if (error = createde(&ndirent, pdep, &dep))
d1377 2
a1378 1

d1394 5
d1458 1
a1458 1
		lbn = (offset - bias) >> pmp->pm_cnshift;
d1479 1
a1479 1
		     dentp++) {
d1492 9
a1500 1
			 * Skip deleted entries and volume labels.
d1502 12
a1513 3
			if (dentp->deName[0] == SLOT_DELETED ||
			    (dentp->deAttributes & ATTR_VOLUME)) {
				offset += sizeof(struct direntry);
d1539 7
a1545 2
			dirbuf.d_namlen = dos2unixfn(dentp->deName,
						     (u_char *)dirbuf.d_name);
a1554 1
			offset += sizeof(struct direntry);
d1556 1
a1556 1
				*cookies++ = offset;
d1720 1
a1720 2
	return (pcbmap(dep, ap->a_bn << (pmp->pm_cnshift - pmp->pm_bnshift),
		       ap->a_bnp, 0, 0));
d1755 2
a1756 1
		if (error = pcbmap(dep, bp->b_lblkno, &bp->b_blkno, 0, 0))
d1810 1
d1812 2
a1813 1
	return (EINVAL);		/* we don't do locking yet */
d1824 1
d1831 1
a1831 1
		*ap->a_retval = 12;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
