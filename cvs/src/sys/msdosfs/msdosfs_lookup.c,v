head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.6
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.20
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.18
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.11.0.16
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.14
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.12
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.29;
commitid	gAjwyca5TfuoJAhn;

1.29
date	2015.10.23.17.21.34;	author krw;	state Exp;
branches;
next	1.28;
commitid	OojuukoxD2uoNfhb;

1.28
date	2015.10.23.10.45.31;	author krw;	state Exp;
branches;
next	1.27;
commitid	SncnQqnXMdpzMlro;

1.27
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.26;
commitid	P6Av4XGqOi3rFasL;

1.26
date	2013.06.11.16.42.16;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2012.09.06.19.06.04;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.17.20.23.58;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.13.22.34.29;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.02.02.04.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.10.15.21.04;	author pedro;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.02.00.35.04;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.14.04.05.05;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.12.21.04.15;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.02.19.17.26.17;	author art;	state Exp;
branches
	1.11.6.1
	1.11.16.1;
next	1.10;

1.10
date	98.01.11.20.39.09;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.11.11.18.57.16;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.11.06.05.58.57;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.20.20.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.15.22.39;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.03.02.18.01.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.04.19.16.10.00;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.10.46.55;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.19.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.04;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2003.03.28.00.00.21;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.11.16.1
date	2003.05.19.22.27.06;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/*	$OpenBSD: msdosfs_lookup.c,v 1.29 2015/10/23 17:21:34 krw Exp $	*/
/*	$NetBSD: msdosfs_lookup.c,v 1.34 1997/10/18 22:12:27 ws Exp $	*/

/*-
 * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995, 1997 TooLs GmbH.
 * All rights reserved.
 * Original code by Paul Popelka (paulp@@uts.amdahl.com) (see below).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Written by Paul Popelka (paulp@@uts.amdahl.com)
 *
 * You can do anything you want with this software, just don't say you wrote
 * it, and don't remove this notice.
 *
 * This software is provided "as is".
 *
 * The author supplies this software to be publicly redistributed on the
 * understanding that the author is not responsible for the correct
 * functioning of this software in any circumstances and is not liable for
 * any damages caused by this software.
 *
 * October 1992
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/dirent.h>

#include <msdosfs/bpb.h>
#include <msdosfs/direntry.h>
#include <msdosfs/denode.h>
#include <msdosfs/msdosfsmount.h>
#include <msdosfs/fat.h>

/*
 * When we search a directory the blocks containing directory entries are
 * read and examined.  The directory entries contain information that would
 * normally be in the inode of a unix filesystem.  This means that some of
 * a directory's contents may also be in memory resident denodes (sort of
 * an inode).  This can cause problems if we are searching while some other
 * process is modifying a directory.  To prevent one process from accessing
 * incompletely modified directory information we depend upon being the
 * sole owner of a directory block.  bread/brelse provide this service.
 * This being the case, when a process modifies a directory it must first
 * acquire the disk block that contains the directory entry to be modified.
 * Then update the disk block and the denode, and then write the disk block
 * out to disk.  This way disk blocks containing directory entries and in
 * memory denode's will be in synch.
 */
int
msdosfs_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct vnode *vdp = ap->a_dvp;
	struct vnode **vpp = ap->a_vpp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	daddr_t bn;
	int error;
	int lockparent;
	int wantparent;
	int slotcount;
	int slotoffset = 0;
	int frcn;
	uint32_t cluster;
	int blkoff;
	int diroff;
	int blsize;
	int isadir;		/* ~0 if found direntry is a directory	 */
	uint32_t scn;		/* starting cluster number		 */
	struct vnode *pdp;
	struct denode *dp;
	struct denode *tdp;
	struct msdosfsmount *pmp;
	struct buf *bp = 0;
	struct direntry *dep;
	u_char dosfilename[11];
	u_char *adjp;
	int adjlen;
	int flags;
	int nameiop = cnp->cn_nameiop;
	int wincnt = 1;
	int chksum = -1, chksum_ok;
	int olddos = 1;

	cnp->cn_flags &= ~PDIRUNLOCK; /* XXX why this ?? */
	flags = cnp->cn_flags;

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_lookup(): looking for %s\n", cnp->cn_nameptr);
#endif
	dp = VTODE(vdp);
	pmp = dp->de_pmp;
	*vpp = NULL;
	lockparent = flags & LOCKPARENT;
	wantparent = flags & (LOCKPARENT | WANTPARENT);
#ifdef MSDOSFS_DEBUG
	printf("msdosfs_lookup(): vdp %p, dp %p, Attr %02x\n",
	    vdp, dp, dp->de_Attributes);
#endif

	/*
	 * Check accessiblity of directory.
	 */
	if ((dp->de_Attributes & ATTR_DIRECTORY) == 0)
		return (ENOTDIR);
	if ((error = VOP_ACCESS(vdp, VEXEC, cnp->cn_cred, cnp->cn_proc)) != 0)
		return (error);

	/*
	 * We now have a segment name to search for, and a directory to search.
	 *
	 * Before tediously performing a linear scan of the directory,
	 * check the name cache to see if the directory/name pair
	 * we are looking for is known already.
	 */
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);

	/*
	 * If they are going after the . or .. entry in the root directory,
	 * they won't find it.  DOS filesystems don't have them in the root
	 * directory.  So, we fake it. deget() is in on this scam too.
	 */
	if ((vdp->v_flag & VROOT) && cnp->cn_nameptr[0] == '.' &&
	    (cnp->cn_namelen == 1 ||
		(cnp->cn_namelen == 2 && cnp->cn_nameptr[1] == '.'))) {
		isadir = ATTR_DIRECTORY;
		scn = MSDOSFSROOT;
#ifdef MSDOSFS_DEBUG
		printf("msdosfs_lookup(): looking for . or .. in root directory\n");
#endif
		cluster = MSDOSFSROOT;
		blkoff = MSDOSFSROOT_OFS;
		goto foundroot;
	}

	switch (unix2dosfn((u_char *)cnp->cn_nameptr, dosfilename, cnp->cn_namelen, 0)) {
	case 0:
		return (EINVAL);
	case 1:
		break;
	case 2:
		wincnt = winSlotCnt((u_char *)cnp->cn_nameptr, cnp->cn_namelen) + 1;
		break;
	case 3:
		olddos = 0;
		wincnt = winSlotCnt((u_char *)cnp->cn_nameptr, cnp->cn_namelen) + 1;
		break;
	}
	if (pmp->pm_flags & MSDOSFSMNT_SHORTNAME)
		wincnt = 1;

	/*
	 * Suppress search for slots unless creating
	 * file and at end of pathname, in which case
	 * we watch for a place to put the new file in
	 * case it doesn't already exist.
	 */
	slotcount = wincnt;
	if ((nameiop == CREATE || nameiop == RENAME) &&
	    (flags & ISLASTCN))
		slotcount = 0;

#ifdef MSDOSFS_DEBUG
	printf("msdosfs_lookup(): dos version of filename '%.11s', "
	    "length %ld\n", dosfilename, cnp->cn_namelen);
#endif

	/*
	 * We want to search the directory pointed to by vdp for the name
	 * pointed to by cnp->cn_nameptr.
	 *
	 * XXX UNIX allows filenames with trailing dots and blanks; we don't.
	 *     Most of the routines in msdosfs_conv.c adjust for this, but
	 *     winChkName() does not, so we do it here.  Otherwise, a file
	 *     such as ".foobar." cannot be retrieved properly.
	 *
	 *     (Note that this is also faster: perform the adjustment once,
	 *     rather than on each call to winChkName.  However, it is still
	 *     a nasty hack.)
	 */
	adjp = cnp->cn_nameptr;
	adjlen = cnp->cn_namelen;

	for (adjp += adjlen; adjlen > 0; adjlen--)
		if (*--adjp != ' ' && *adjp != '.')
			break;

	tdp = NULL;
	/*
	 * The outer loop ranges over the clusters that make up the
	 * directory.  Note that the root directory is different from all
	 * other directories.  It has a fixed number of blocks that are not
	 * part of the pool of allocatable clusters.  So, we treat it a
	 * little differently. The root directory starts at "cluster" 0.
	 */
	diroff = 0;
	for (frcn = 0;; frcn++) {
		if ((error = pcbmap(dp, frcn, &bn, &cluster, &blsize)) != 0) {
			if (error == E2BIG)
				break;
			return (error);
		}
		error = bread(pmp->pm_devvp, bn, blsize, &bp);
		if (error) {
			brelse(bp);
			return (error);
		}
		for (blkoff = 0; blkoff < blsize;
		     blkoff += sizeof(struct direntry),
		     diroff += sizeof(struct direntry)) {
			dep = (struct direntry *)(bp->b_data + blkoff);
			/*
			 * If the slot is empty and we are still looking
			 * for an empty then remember this one.  If the
			 * slot is not empty then check to see if it
			 * matches what we are looking for.  If the slot
			 * has never been filled with anything, then the
			 * remainder of the directory has never been used,
			 * so there is no point in searching it.
			 */
			if (dep->deName[0] == SLOT_EMPTY ||
			    dep->deName[0] == SLOT_DELETED) {
				/*
				 * Drop memory of previous long matches
				 */
				chksum = -1;

				if (slotcount < wincnt) {
					slotcount++;
					slotoffset = diroff;
				}
				if (dep->deName[0] == SLOT_EMPTY) {
					brelse(bp);
					goto notfound;
				}
			} else {
				/*
				 * If there wasn't enough space for our winentries,
				 * forget about the empty space
				 */
				if (slotcount < wincnt)
					slotcount = 0;

				/*
				 * Check for Win95 long filename entry
				 */
				if (dep->deAttributes == ATTR_WIN95) {
					if (pmp->pm_flags & MSDOSFSMNT_SHORTNAME)
						continue;

					chksum = winChkName((u_char *)cnp->cn_nameptr,
							    adjlen,
							    (struct winentry *)dep,
							    chksum);
					continue;
				}

				/*
				 * Ignore volume labels (anywhere, not just
				 * the root directory).
				 */
				if (dep->deAttributes & ATTR_VOLUME) {
					chksum = -1;
					continue;
				}

				/*
				 * Check for a checksum or name match
				 */
				chksum_ok = (chksum == winChksum(dep->deName));
				if (!chksum_ok
				    && (!olddos || bcmp(dosfilename, dep->deName, 11))) {
					chksum = -1;
					continue;
				}
#ifdef MSDOSFS_DEBUG
				printf("msdosfs_lookup(): match blkoff %d, diroff %d\n",
				    blkoff, diroff);
#endif
				/*
				 * Remember where this directory
				 * entry came from for whoever did
				 * this lookup.
				 */
				dp->de_fndoffset = diroff;
				if (chksum_ok && nameiop == RENAME) {
					/*
					 * Target had correct long name
					 * directory entries, reuse them as
					 * needed.
					 */
					dp->de_fndcnt = wincnt - 1;
				} else {
					/*
					 * Long name directory entries not
					 * present or corrupt, can only reuse
					 * dos directory entry.
					 */
					dp->de_fndcnt = 0;
				}
				goto found;
			}
		}	/* for (blkoff = 0; .... */
		/*
		 * Release the buffer holding the directory cluster just
		 * searched.
		 */
		brelse(bp);
	}	/* for (frcn = 0; ; frcn++) */

notfound:;
	/*
	 * We hold no disk buffers at this point.
	 */

	/*
	 * Fixup the slot description to point to the place where
	 * we might put the new DOS direntry (putting the Win95
	 * long name entries before that)
	 */
	if (!slotcount) {
		slotcount = 1;
		slotoffset = diroff;
	}
	if (wincnt > slotcount)
		slotoffset += sizeof(struct direntry) * (wincnt - slotcount);

	/*
	 * If we get here we didn't find the entry we were looking for. But
	 * that's ok if we are creating or renaming and are at the end of
	 * the pathname and the directory hasn't been removed.
	 */
#ifdef MSDOSFS_DEBUG
	printf("msdosfs_lookup(): op %d, refcnt %ld\n",
	    nameiop, dp->de_refcnt);
	printf("               slotcount %d, slotoffset %d\n",
	    slotcount, slotoffset);
#endif
	if ((nameiop == CREATE || nameiop == RENAME) &&
	    (flags & ISLASTCN) && dp->de_refcnt != 0) {
		/*
		 * Access for write is interpreted as allowing
		 * creation of files in the directory.
		 */
		error = VOP_ACCESS(vdp, VWRITE, cnp->cn_cred, cnp->cn_proc);
		if (error)
			return (error);
		/*
		 * Return an indication of where the new directory
		 * entry should be put.
		 */
		dp->de_fndoffset = slotoffset;
		dp->de_fndcnt = wincnt - 1;

		/*
		 * We return with the directory locked, so that
		 * the parameters we set up above will still be
		 * valid if we actually decide to do a direnter().
		 * We return ni_vp == NULL to indicate that the entry
		 * does not currently exist; we leave a pointer to
		 * the (locked) directory inode in ndp->ni_dvp.
		 * The pathname buffer is saved so that the name
		 * can be obtained later.
		 *
		 * NB - if the directory is unlocked, then this
		 * information cannot be used.
		 */
		cnp->cn_flags |= SAVENAME;
		if (!lockparent) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (EJUSTRETURN);
	}
	/*
	 * Insert name into cache (as non-existent) if appropriate.
	 */
	if ((cnp->cn_flags & MAKEENTRY) && nameiop != CREATE)
		cache_enter(vdp, *vpp, cnp);
	return (ENOENT);

found:;
	/*
	 * NOTE:  We still have the buffer with matched directory entry at
	 * this point.
	 */
	isadir = dep->deAttributes & ATTR_DIRECTORY;
	scn = getushort(dep->deStartCluster);
	if (FAT32(pmp)) {
		scn |= getushort(dep->deHighClust) << 16;
		if (scn == pmp->pm_rootdirblk) {
			/*
			 * There should actually be 0 here.
			 * Just ignore the error.
			 */
			scn = MSDOSFSROOT;
		}
	}

	if (cluster == MSDOSFSROOT)
		blkoff = diroff;

	if (isadir) {
		cluster = scn;
		if (cluster == MSDOSFSROOT)
			blkoff = MSDOSFSROOT_OFS;
		else
			blkoff = 0;
	}

	/*
	 * Now release buf to allow deget to read the entry again.
	 * Reserving it here and giving it to deget could result
	 * in a deadlock.
	 */
	brelse(bp);

foundroot:;
	/*
	 * If we entered at foundroot, then we are looking for the . or ..
	 * entry of the filesystems root directory.  isadir and scn were
	 * setup before jumping here.  And, bp is already null.
	 */
	if (FAT32(pmp) && scn == MSDOSFSROOT)
		scn = pmp->pm_rootdirblk;

	/*
	 * If deleting, and at end of pathname, return
	 * parameters which can be used to remove file.
	 * If the wantparent flag isn't set, we return only
	 * the directory (in ndp->ni_dvp), otherwise we go
	 * on and lock the inode, being careful with ".".
	 */
	if (nameiop == DELETE && (flags & ISLASTCN)) {
		/*
		 * Don't allow deleting the root.
		 */
		if (blkoff == MSDOSFSROOT_OFS)
			return EROFS;				/* really? XXX */

		/*
		 * Write access to directory required to delete files.
		 */
		error = VOP_ACCESS(vdp, VWRITE, cnp->cn_cred, cnp->cn_proc);
		if (error)
			return (error);

		/*
		 * Return pointer to current entry in dp->i_offset.
		 * Save directory inode pointer in ndp->ni_dvp for dirremove().
		 */
		if (dp->de_StartCluster == scn && isadir) {	/* "." */
			vref(vdp);
			*vpp = vdp;
			return (0);
		}
		if ((error = deget(pmp, cluster, blkoff, &tdp)) != 0)
			return (error);
		*vpp = DETOV(tdp);
		if (!lockparent) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (0);
	}

	/*
	 * If rewriting (RENAME), return the inode and the
	 * information required to rewrite the present directory
	 * Must get inode of directory entry to verify it's a
	 * regular file, or empty directory.
	 */
	if (nameiop == RENAME && wantparent &&
	    (flags & ISLASTCN)) {
		if (blkoff == MSDOSFSROOT_OFS)
			return EROFS;				/* really? XXX */

		error = VOP_ACCESS(vdp, VWRITE, cnp->cn_cred, cnp->cn_proc);
		if (error)
			return (error);

		/*
		 * Careful about locking second inode.
		 * This can only occur if the target is ".".
		 */
		if (dp->de_StartCluster == scn && isadir)
			return (EISDIR);

		if ((error = deget(pmp, cluster, blkoff, &tdp)) != 0)
			return (error);
		*vpp = DETOV(tdp);
		cnp->cn_flags |= SAVENAME;
		if (!lockparent)
			VOP_UNLOCK(vdp, p);
		return (0);
	}

	/*
	 * Step through the translation in the name.  We do not `vput' the
	 * directory because we may need it again if a symbolic link
	 * is relative to the current directory.  Instead we save it
	 * unlocked as "pdp".  We must get the target inode before unlocking
	 * the directory to insure that the inode will not be removed
	 * before we get it.  We prevent deadlock by always fetching
	 * inodes from the root, moving down the directory tree. Thus
	 * when following backward pointers ".." we must unlock the
	 * parent directory before getting the requested directory.
	 * There is a potential race condition here if both the current
	 * and parent directories are removed before the VFS_VGET for the
	 * inode associated with ".." returns.  We hope that this occurs
	 * infrequently since we cannot avoid this race condition without
	 * implementing a sophisticated deadlock detection algorithm.
	 * Note also that this simple deadlock detection scheme will not
	 * work if the file system has any hard links other than ".."
	 * that point backwards in the directory structure.
	 */
	pdp = vdp;
	if (flags & ISDOTDOT) {
		VOP_UNLOCK(pdp, p);	/* race to get the inode */
		cnp->cn_flags |= PDIRUNLOCK;
		if ((error = deget(pmp, cluster, blkoff, &tdp)) != 0) {
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY,
			    p))) {
				vput(DETOV(tdp));
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}
		*vpp = DETOV(tdp);
	} else if (dp->de_StartCluster == scn && isadir) {
		vref(vdp);	/* we want ourself, ie "." */
		*vpp = vdp;
	} else {
		if ((error = deget(pmp, cluster, blkoff, &tdp)) != 0)
			return (error);
		if (!lockparent || !(flags & ISLASTCN)) {
			VOP_UNLOCK(pdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		*vpp = DETOV(tdp);
	}

	/*
	 * Insert name into cache if appropriate.
	 */
	if (cnp->cn_flags & MAKEENTRY)
		cache_enter(vdp, *vpp, cnp);
	return (0);
}

/*
 * dep  - directory entry to copy into the directory
 * ddep - directory to add to
 * depp - return the address of the denode for the created directory entry
 *	  if depp != 0
 * cnp  - componentname needed for Win95 long filenames
 */
int
createde(struct denode *dep, struct denode *ddep, struct denode **depp,
    struct componentname *cnp)
{
	int error;
	uint32_t dirclust, diroffset;
	struct direntry *ndep;
	struct msdosfsmount *pmp = ddep->de_pmp;
	struct buf *bp;
	daddr_t bn;
	int blsize;

#ifdef MSDOSFS_DEBUG
	printf("createde(dep %p, ddep %p, depp %p, cnp %p)\n",
	    dep, ddep, depp, cnp);
#endif

	/*
	 * If no space left in the directory then allocate another cluster
	 * and chain it onto the end of the file.  There is one exception
	 * to this.  That is, if the root directory has no more space it
	 * can NOT be expanded.  extendfile() checks for and fails attempts
	 * to extend the root directory.  We just return an error in that
	 * case.
	 */
	if (ddep->de_fndoffset >= ddep->de_FileSize) {
		diroffset = ddep->de_fndoffset + sizeof(struct direntry)
		    - ddep->de_FileSize;
		dirclust = de_clcount(pmp, diroffset);
		if ((error = extendfile(ddep, dirclust, 0, 0, DE_CLEAR)) != 0) {
			(void)detrunc(ddep, ddep->de_FileSize, 0, NOCRED, NULL);
			return error;
		}

		/*
		 * Update the size of the directory
		 */
		ddep->de_FileSize += de_cn2off(pmp, dirclust);
	}

	/*
	 * We just read in the cluster with space.  Copy the new directory
	 * entry in.  Then write it to disk. NOTE:  DOS directories
	 * do not get smaller as clusters are emptied.
	 */
	error = pcbmap(ddep, de_cluster(pmp, ddep->de_fndoffset),
		       &bn, &dirclust, &blsize);
	if (error)
		return error;
	diroffset = ddep->de_fndoffset;
	if (dirclust != MSDOSFSROOT)
		diroffset &= pmp->pm_crbomask;
	if ((error = bread(pmp->pm_devvp, bn, blsize, &bp)) != 0) {
		brelse(bp);
		return error;
	}
	ndep = bptoep(pmp, bp, ddep->de_fndoffset);

	DE_EXTERNALIZE(ndep, dep);

	/*
	 * Now write the Win95 long name
	 */
	if (ddep->de_fndcnt > 0) {
		u_int8_t chksum = winChksum(ndep->deName);
		u_char *un = (u_char *)cnp->cn_nameptr;
		int unlen = cnp->cn_namelen;
		int cnt = 1;

		while (--ddep->de_fndcnt >= 0) {
			if (!(ddep->de_fndoffset & pmp->pm_crbomask)) {
				if ((error = bwrite(bp)) != 0)
					return error;

				ddep->de_fndoffset -= sizeof(struct direntry);
				error = pcbmap(ddep,
					       de_cluster(pmp,
							  ddep->de_fndoffset),
					       &bn, 0, &blsize);
				if (error)
					return error;

				error = bread(pmp->pm_devvp, bn, blsize, &bp);
				if (error) {
					brelse(bp);
					return error;
				}
				ndep = bptoep(pmp, bp, ddep->de_fndoffset);
			} else {
				ndep--;
				ddep->de_fndoffset -= sizeof(struct direntry);
			}
			if (!unix2winfn(un, unlen, (struct winentry *)ndep, cnt++, chksum))
				break;
		}
	}

	if ((error = bwrite(bp)) != 0)
		return error;

	/*
	 * If they want us to return with the denode gotten.
	 */
	if (depp) {
		if (dep->de_Attributes & ATTR_DIRECTORY) {
			dirclust = dep->de_StartCluster;
			if (FAT32(pmp) && dirclust == pmp->pm_rootdirblk)
				dirclust = MSDOSFSROOT;
			if (dirclust == MSDOSFSROOT)
				diroffset = MSDOSFSROOT_OFS;
			else
				diroffset = 0;
		}
		return deget(pmp, dirclust, diroffset, depp);
	}

	return 0;
}

/*
 * Be sure a directory is empty except for "." and "..". Return 1 if empty,
 * return 0 if not empty or error.
 */
int
dosdirempty(struct denode *dep)
{
	int blsize;
	int error;
	uint32_t cn;
	daddr_t bn;
	struct buf *bp;
	struct msdosfsmount *pmp = dep->de_pmp;
	struct direntry *dentp;

	/*
	 * Since the filesize field in directory entries for a directory is
	 * zero, we just have to feel our way through the directory until
	 * we hit end of file.
	 */
	for (cn = 0;; cn++) {
		if ((error = pcbmap(dep, cn, &bn, 0, &blsize)) != 0) {
			if (error == E2BIG)
				return (1);	/* it's empty */
			return (0);
		}
		error = bread(pmp->pm_devvp, bn, blsize, &bp);
		if (error) {
			brelse(bp);
			return (0);
		}
		for (dentp = (struct direntry *)bp->b_data;
		     (char *)dentp < bp->b_data + blsize;
		     dentp++) {
			if (dentp->deName[0] != SLOT_DELETED &&
			    (dentp->deAttributes & ATTR_VOLUME) == 0) {
				/*
				 * In dos directories an entry whose name
				 * starts with SLOT_EMPTY (0) starts the
				 * beginning of the unused part of the
				 * directory, so we can just return that it
				 * is empty.
				 */
				if (dentp->deName[0] == SLOT_EMPTY) {
					brelse(bp);
					return (1);
				}
				/*
				 * Any names other than "." and ".." in a
				 * directory mean it is not empty.
				 */
				if (bcmp(dentp->deName, ".          ", 11) &&
				    bcmp(dentp->deName, "..         ", 11)) {
					brelse(bp);
#ifdef MSDOSFS_DEBUG
					printf("dosdirempty(): entry found %02x, %02x\n",
					    dentp->deName[0], dentp->deName[1]);
#endif
					return (0);	/* not empty */
				}
			}
		}
		brelse(bp);
	}
	/* NOTREACHED */
}

/*
 * Check to see if the directory described by target is in some
 * subdirectory of source.  This prevents something like the following from
 * succeeding and leaving a bunch or files and directories orphaned. mv
 * /a/b/c /a/b/c/d/e/f Where c and f are directories.
 *
 * source - the inode for /a/b/c
 * target - the inode for /a/b/c/d/e/f
 *
 * Returns 0 if target is NOT a subdirectory of source.
 * Otherwise returns a non-zero error number.
 * The target inode is always unlocked on return.
 */
int
doscheckpath(struct denode *source, struct denode *target)
{
	uint32_t scn;
	struct msdosfsmount *pmp;
	struct direntry *ep;
	struct denode *dep;
	struct buf *bp = NULL;
	int error = 0;

	dep = target;
	if ((target->de_Attributes & ATTR_DIRECTORY) == 0 ||
	    (source->de_Attributes & ATTR_DIRECTORY) == 0) {
		error = ENOTDIR;
		goto out;
	}
	if (dep->de_StartCluster == source->de_StartCluster) {
		error = EEXIST;
		goto out;
	}
	if (dep->de_StartCluster == MSDOSFSROOT)
		goto out;
	pmp = dep->de_pmp;
#ifdef	DIAGNOSTIC
	if (pmp != source->de_pmp)
		panic("doscheckpath: source and target on different filesystems");
#endif
	if (FAT32(pmp) && dep->de_StartCluster == pmp->pm_rootdirblk)
		goto out;

	for (;;) {
		if ((dep->de_Attributes & ATTR_DIRECTORY) == 0) {
			error = ENOTDIR;
			break;
		}
		scn = dep->de_StartCluster;
		error = bread(pmp->pm_devvp, cntobn(pmp, scn),
			      pmp->pm_bpcluster, &bp);
		if (error)
			break;

		ep = (struct direntry *) bp->b_data + 1;
		if ((ep->deAttributes & ATTR_DIRECTORY) == 0 ||
		    bcmp(ep->deName, "..         ", 11) != 0) {
			error = ENOTDIR;
			break;
		}
		scn = getushort(ep->deStartCluster);
		if (FAT32(pmp))
			scn |= getushort(ep->deHighClust) << 16;

		if (scn == source->de_StartCluster) {
			error = EINVAL;
			break;
		}
		if (scn == MSDOSFSROOT)
			break;
		if (FAT32(pmp) && scn == pmp->pm_rootdirblk) {
			/*
			 * scn should be 0 in this case,
			 * but we silently ignore the error.
			 */
			break;
		}

		vput(DETOV(dep));
		brelse(bp);
		bp = NULL;
		/* NOTE: deget() clears dep on error */
		if ((error = deget(pmp, scn, 0, &dep)) != 0)
			break;
	}
out:;
	if (bp)
		brelse(bp);
	if (error == ENOTDIR)
		printf("doscheckpath(): .. not a directory?\n");
	if (dep != NULL)
		vput(DETOV(dep));
	return (error);
}

/*
 * Read in the disk block containing the directory entry (dirclu, dirofs)
 * and return the address of the buf header, and the address of the
 * directory entry within the block.
 */
int
readep(struct msdosfsmount *pmp, uint32_t dirclust, uint32_t diroffset,
    struct buf **bpp, struct direntry **epp)
{
	int error;
	daddr_t bn;
	int blsize;

	blsize = pmp->pm_bpcluster;
	if (dirclust == MSDOSFSROOT
	    && de_blk(pmp, diroffset + blsize) > pmp->pm_rootdirsize)
		blsize = de_bn2off(pmp, pmp->pm_rootdirsize) & pmp->pm_crbomask;
	bn = detobn(pmp, dirclust, diroffset);
	if ((error = bread(pmp->pm_devvp, bn, blsize, bpp)) != 0) {
		brelse(*bpp);
		*bpp = NULL;
		return (error);
	}
	if (epp)
		*epp = bptoep(pmp, *bpp, diroffset);
	return (0);
}

/*
 * Read in the disk block containing the directory entry dep came from and
 * return the address of the buf header, and the address of the directory
 * entry within the block.
 */
int
readde(struct denode *dep, struct buf **bpp, struct direntry **epp)
{

	return (readep(dep->de_pmp, dep->de_dirclust, dep->de_diroffset,
	    bpp, epp));
}

/*
 * Remove a directory entry. At this point the file represented by the
 * directory entry to be removed is still full length until noone has it
 * open.  When the file no longer being used msdosfs_inactive() is called
 * and will truncate the file to 0 length.  When the vnode containing the
 * denode is needed for some other purpose by VFS it will call
 * msdosfs_reclaim() which will remove the denode from the denode cache.
 *
 * pdep - directory where the entry is removed
 * dep - file to be removed
 */
int
removede(struct denode *pdep, struct denode *dep)
{
	int error;
	struct direntry *ep;
	struct buf *bp;
	daddr_t bn;
	int blsize;
	struct msdosfsmount *pmp = pdep->de_pmp;
	uint32_t offset = pdep->de_fndoffset;

#ifdef MSDOSFS_DEBUG
	printf("removede(): filename %.11s, dep %p, offset %x\n",
	    dep->de_Name, dep, offset);
#endif

	dep->de_refcnt--;
	offset += sizeof(struct direntry);
	do {
		offset -= sizeof(struct direntry);
		error = pcbmap(pdep, de_cluster(pmp, offset), &bn, 0, &blsize);
		if (error)
			return error;
		error = bread(pmp->pm_devvp, bn, blsize, &bp);
		if (error) {
			brelse(bp);
			return error;
		}
		ep = bptoep(pmp, bp, offset);
		/*
		 * Check whether, if we came here the second time, i.e.
		 * when underflowing into the previous block, the last
		 * entry in this block is a longfilename entry, too.
		 */
		if (ep->deAttributes != ATTR_WIN95
		    && offset != pdep->de_fndoffset) {
			brelse(bp);
			break;
		}
		offset += sizeof(struct direntry);
		while (1) {
			/*
			 * We are a bit aggressive here in that we delete any Win95
			 * entries preceding this entry, not just the ones we "own".
			 * Since these presumably aren't valid anyway,
			 * there should be no harm.
			 */
			offset -= sizeof(struct direntry);
			ep--->deName[0] = SLOT_DELETED;
			if ((pmp->pm_flags & MSDOSFSMNT_NOWIN95)
			    || !(offset & pmp->pm_crbomask)
			    || ep->deAttributes != ATTR_WIN95)
				break;
		}
		if ((error = bwrite(bp)) != 0)
			return error;
	} while (!(pmp->pm_flags & MSDOSFSMNT_NOWIN95)
	    && !(offset & pmp->pm_crbomask)
	    && offset);
	return 0;
}

/*
 * Create a unique DOS name in dvp
 */
int
uniqdosname(struct denode *dep, struct componentname *cnp, u_char *cp)
{
	struct msdosfsmount *pmp = dep->de_pmp;
	struct direntry *dentp;
	int gen;
	int blsize;
	uint32_t cn;
	daddr_t bn;
	struct buf *bp;
	int error;

	for (gen = 1;; gen++) {
		/*
		 * Generate DOS name with generation number
		 */
		if (!unix2dosfn((u_char *)cnp->cn_nameptr, cp, cnp->cn_namelen, gen))
			return gen == 1 ? EINVAL : EEXIST;

		/*
		 * Now look for a dir entry with this exact name
		 */
		for (cn = error = 0; !error; cn++) {
			if ((error = pcbmap(dep, cn, &bn, 0, &blsize)) != 0) {
				if (error == E2BIG)	/* EOF reached and not found */
					return 0;
				return error;
			}
			error = bread(pmp->pm_devvp, bn, blsize, &bp);
			if (error) {
				brelse(bp);
				return error;
			}
			for (dentp = (struct direntry *)bp->b_data;
			     (char *)dentp < bp->b_data + blsize;
			     dentp++) {
				if (dentp->deName[0] == SLOT_EMPTY) {
					/*
					 * Last used entry and not found
					 */
					brelse(bp);
					return 0;
				}
				/*
				 * Ignore volume labels and Win95 entries
				 */
				if (dentp->deAttributes & ATTR_VOLUME)
					continue;
				if (!bcmp(dentp->deName, cp, 11)) {
					error = EEXIST;
					break;
				}
			}
			brelse(bp);
		}
	}

	return (EEXIST);
}

/*
 * Find any Win'95 long filename entry in directory dep
 */
int
findwin95(struct denode *dep)
{
	struct msdosfsmount *pmp = dep->de_pmp;
	struct direntry *dentp;
	int blsize;
	uint32_t cn;
	daddr_t bn;
	struct buf *bp;

	/*
	 * Read through the directory looking for Win'95 entries
	 * Note: Error currently handled just as EOF			XXX
	 */
	for (cn = 0;; cn++) {
		if (pcbmap(dep, cn, &bn, 0, &blsize))
			return 0;
		if (bread(pmp->pm_devvp, bn, blsize, &bp)) {
			brelse(bp);
			return 0;
		}
		for (dentp = (struct direntry *)bp->b_data;
		     (char *)dentp < bp->b_data + blsize;
		     dentp++) {
			if (dentp->deName[0] == SLOT_EMPTY) {
				/*
				 * Last used entry and not found
				 */
				brelse(bp);
				return 0;
			}
			if (dentp->deName[0] == SLOT_DELETED) {
				/*
				 * Ignore deleted files
				 * Note: might be an indication of Win'95 anyway	XXX
				 */
				continue;
			}
			if (dentp->deAttributes == ATTR_WIN95) {
				brelse(bp);
				return 1;
			}
		}
		brelse(bp);
	}
}
@


1.29
log
@Fix printf() types so kernel compiles with or w/o MSDOSFS_DEBUG.
e.g. print pointers with %p instead of %08x. No changes outside of
MSDOSFS_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.28 2015/10/23 10:45:31 krw Exp $	*/
d403 1
a403 1
			VOP_UNLOCK(vdp, 0, p);
d494 1
a494 1
			VOP_UNLOCK(vdp, 0, p);
d527 1
a527 1
			VOP_UNLOCK(vdp, 0, p);
d552 1
a552 1
		VOP_UNLOCK(pdp, 0, p);	/* race to get the inode */
d575 1
a575 1
			VOP_UNLOCK(pdp, 0, p);
@


1.28
log
@Nuke a bunch of leading/embedded/trailing whitespace so the code can be
read without generating spurious headaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.27 2014/12/16 18:30:04 tedu Exp $	*/
d129 1
a129 1
	printf("msdosfs_lookup(): vdp %08x, dp %08x, Attr %02x\n",
d197 2
a198 2
	printf("msdosfs_lookup(): dos version of filename '%.11s', length %d\n",
	    dosfilename, cnp->cn_namelen);
d367 1
a367 1
	printf("msdosfs_lookup(): op %d, refcnt %d\n",
d609 1
a609 1
	printf("createde(dep %08x, ddep %08x, depp %08x, cnp %08x)\n",
d941 1
a941 1
	printf("removede(): filename %.11s, dep %08x, offset %08x\n",
@


1.27
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.26 2013/06/11 16:42:16 deraadt Exp $	*/
d37 1
a37 1
 * 
d40 1
a40 1
 * 
d42 1
a42 1
 * 
d47 1
a47 1
 * 
d195 1
a195 1
	
d260 1
a260 1
				
d276 1
a276 1
				
d290 1
a290 1
				
d360 1
a360 1
	
d450 1
a450 1
	
d607 1
a607 1
	
d635 1
a635 1
	
d653 1
a653 1
	
d664 1
a664 1
		
d692 1
a692 1
	
d711 1
a711 1
	
d939 1
a939 1
	
d1012 1
a1012 1
		
@


1.26
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.25 2012/09/06 19:06:04 krw Exp $	*/
d56 1
@


1.25
log
@Remove the need to occasionally treat dos file names as strings by
using "%.11s" to print them out. Make all dos file names 11 byte
arrays and nuke the attempt to put '\0' at the 12th position of
such an array.

Fixes 'panic: smashed stack in msdosfs_rename.c' reported by
MERHIGI Marcus via tech@@.

Tested by MERHIGI Marcus. Suggestions and ok tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.24 2011/07/04 04:30:41 tedu Exp $	*/
d88 1
a88 1
	daddr64_t bn;
d604 1
a604 1
	daddr64_t bn;
d724 1
a724 1
	daddr64_t bn;
d886 1
a886 1
	daddr64_t bn;
d934 1
a934 1
	daddr64_t bn;
d1001 1
a1001 1
	daddr64_t bn;
d1063 1
a1063 1
	daddr64_t bn;
@


1.24
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.23 2010/01/17 20:23:58 chl Exp $	*/
d107 1
a107 1
	u_char dosfilename[12];
d196 1
a196 1
	printf("msdosfs_lookup(): dos version of filename %s, length %d\n",
d199 1
d940 1
a940 1
	printf("removede(): filename %s, dep %08x, offset %08x\n",
@


1.23
log
@Remove dead assignment and newly created unused variable.

Found by LLVM/Clang Static Analyzer.

ok tedu@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.22 2009/08/13 22:34:29 jasper Exp $	*/
d234 1
a234 1
		error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp);
d646 1
a646 1
	if ((error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) != 0) {
d676 1
a676 2
				error = bread(pmp->pm_devvp, bn, blsize,
					      NOCRED, &bp);
d739 1
a739 1
		error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp);
d830 1
a830 1
			      pmp->pm_bpcluster, NOCRED, &bp);
d893 1
a893 1
	if ((error = bread(pmp->pm_devvp, bn, blsize, NOCRED, bpp)) != 0) {
d950 1
a950 1
		error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp);
d1020 1
a1020 1
			error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp);
d1072 1
a1072 1
		if (bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) {
@


1.22
log
@- ansify function declarations, no binary change

"fine" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.21 2009/07/09 22:29:56 thib Exp $	*/
a887 1
	uint32_t boff;
a888 1
	boff = diroffset & ~pmp->pm_crbomask;
@


1.21
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.19 2007/06/02 02:04:21 deraadt Exp $	*/
d81 1
a81 2
msdosfs_lookup(v)
	void *v;
d595 2
a596 5
createde(dep, ddep, depp, cnp)
	struct denode *dep;
	struct denode *ddep;
	struct denode **depp;
	struct componentname *cnp;
d719 1
a719 2
dosdirempty(dep)
	struct denode *dep;
d795 1
a795 3
doscheckpath(source, target)
	struct denode *source;
	struct denode *target;
d882 2
a883 5
readep(pmp, dirclust, diroffset, bpp, epp)
	struct msdosfsmount *pmp;
	uint32_t dirclust, diroffset;
	struct buf **bpp;
	struct direntry **epp;
d912 1
a912 4
readde(dep, bpp, epp)
	struct denode *dep;
	struct buf **bpp;
	struct direntry **epp;
d926 3
d931 1
a931 3
removede(pdep, dep)
	struct denode *pdep;	/* directory where the entry is removed */
	struct denode *dep;	/* file to be removed */
d996 1
a996 4
uniqdosname(dep, cnp, cp)
	struct denode *dep;
	struct componentname *cnp;
	u_char *cp;
d1059 1
a1059 2
findwin95(dep)
	struct denode *dep;
@


1.20
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d485 1
a485 1
			VREF(vdp);
d568 1
a568 1
		VREF(vdp);	/* we want ourself, ie "." */
@


1.19
log
@convert all daddr_t types to either daddr64_t or uint32_t or other such
things based on their use.  ok with fixes from tom, tested by grange too
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.18 2007/06/01 23:47:57 deraadt Exp $	*/
d984 1
a984 1
			 * We are a bit agressive here in that we delete any Win95
@


1.18
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.17 2007/04/10 15:21:04 pedro Exp $	*/
d804 1
a804 1
	daddr_t scn;
d896 1
a896 1
	daddr_t bn;
@


1.17
log
@When doing a rename and finding out the destination name already
exists, keep the containing directory's long name capabilities.
From NetBSD via Enache Adrian, okay millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.16 2006/10/03 19:49:06 pedro Exp $	*/
d84 1
a84 5
	struct vop_lookup_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap = v;
@


1.16
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.15 2005/03/02 00:35:04 tom Exp $	*/
d118 1
a118 1
	int chksum = -1;
d306 2
a307 1
				if (chksum != winChksum(dep->deName)
d322 15
a336 2
				dp->de_fndcnt = 0;	/* unused anyway */
				
@


1.15
log
@Make all the MS-DOS filesystem code ignore trailing dots and spaces, in
the same way that Windows does.  Without this, `touch .foobar.' followed
by `touch .foobar.' will create two directory entries called `.foobar',
thereby corrupting the filesystem.

Found by todd@@, who has been doing things with msdosfs that are truly
obscene.

"alright" tedu@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.14 2004/05/14 04:05:05 tedu Exp $	*/
d93 1
a93 1
	daddr_t bn;
d597 1
a597 1
	daddr_t bn;
d719 1
a719 1
	daddr_t bn;
d938 1
a938 1
	daddr_t bn;
d1008 1
a1008 1
	daddr_t bn;
d1071 1
a1071 1
	daddr_t bn;
@


1.14
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.12 2003/01/31 17:37:50 art Exp $	*/
d113 2
d205 11
a215 2
	 * Search the directory pointed at by vdp for the name pointed at
	 * by cnp->cn_nameptr.
d217 7
d288 1
a288 1
							    cnp->cn_namelen,
@


1.13
log
@32 bit ints are uint32_t, not u_long.  works on 64bit now.  ok deraadt@@
@
text
@@


1.12
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.11 1999/02/19 17:26:17 art Exp $	*/
d100 1
a100 1
	u_long cluster;
d105 1
a105 1
	u_long scn;		/* starting cluster number		 */
d575 1
a575 1
	u_long dirclust, diroffset;
d700 1
a700 1
	u_long cn;
d863 1
a863 1
	u_long dirclust, diroffset;
d870 1
a870 1
	u_long boff;
d923 1
a923 1
	u_long offset = pdep->de_fndoffset;
d989 1
a989 1
	u_long cn;
d1052 1
a1052 1
	u_long cn;
@


1.11
log
@Fix a bug where the root directory could look corrupted on FAT12.
I'm not sure if this fix is correct but: some comments in the code say that
it should be done this way, it fixes the particular problem, it doesn't break
anything else, noone who got the diff complained (in two months).
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.10 1998/01/11 20:39:09 provos Exp $	*/
d113 1
a113 1
	int flags = cnp->cn_flags;
d118 4
a121 1
	
d150 2
a151 50
	if ((error = cache_lookup(vdp, vpp, cnp)) != 0) {
		int vpid;

		if (error == ENOENT)
			return (error);
		/*
		 * Get the next vnode in the path.
		 * See comment below starting `Step through' for
		 * an explaination of the locking protocol.
		 */
		pdp = vdp;
		dp = VTODE(*vpp);
		vdp = *vpp;
		vpid = vdp->v_id;
		if (pdp == vdp) {   /* lookup on "." */
			VREF(vdp);
			error = 0;
		} else if (flags & ISDOTDOT) {
			VOP_UNLOCK(pdp, 0, p);
			error = vget(vdp, LK_EXCLUSIVE, p);
			if (!error && lockparent && (flags & ISLASTCN))
				error =
				    vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
		} else {
			error = vget(vdp, LK_EXCLUSIVE, p);
			if (!lockparent || error || !(flags & ISLASTCN))
				VOP_UNLOCK(pdp, 0, p);
		}
		/*
		 * Check that the capability number did not change
		 * while we were waiting for the lock.
		 */
		if (!error) {
			if (vpid == vdp->v_id) {
#ifdef MSDOSFS_DEBUG
				printf("msdosfs_lookup(): cache hit, vnode %08x, file %s\n",
				    vdp, dp->de_Name);
#endif
				return (0);
			}
			vput(vdp);
			if (lockparent && pdp != vdp && (flags & ISLASTCN))
				VOP_UNLOCK(pdp, 0, p);
		}
		if ((error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
			return (error);
		vdp = pdp;
		dp = VTODE(vdp);
		*vpp = NULL;
	}
d373 1
a373 1
		if (!lockparent)
d375 2
d464 1
a464 1
		if (!lockparent)
d466 2
d524 1
d526 2
a527 1
			vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d530 7
a536 4
		if (lockparent && (flags & ISLASTCN) &&
		    (error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p))) {
			vput(DETOV(tdp));
			return (error);
d545 1
a545 1
		if (!lockparent || !(flags & ISLASTCN))
d547 2
@


1.11.16.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 1
	int flags;
d118 1
a118 4

	cnp->cn_flags &= ~PDIRUNLOCK; /* XXX why this ?? */
	flags = cnp->cn_flags;

d147 50
a196 2
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);
d418 1
a418 1
		if (!lockparent) {
a419 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d507 1
a507 1
		if (!lockparent) {
a508 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
a564 1
		cnp->cn_flags |= PDIRUNLOCK;
d566 1
a566 2
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
d569 4
a572 7
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY,
			    p))) {
				vput(DETOV(tdp));
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
d581 1
a581 1
		if (!lockparent || !(flags & ISLASTCN)) {
a582 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
@


1.11.6.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 1
	int flags;
d118 1
a118 4

	cnp->cn_flags &= ~PDIRUNLOCK; /* XXX why this ?? */
	flags = cnp->cn_flags;

d147 50
a196 2
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);
d418 1
a418 1
		if (!lockparent) {
a419 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d507 1
a507 1
		if (!lockparent) {
a508 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
a564 1
		cnp->cn_flags |= PDIRUNLOCK;
d566 1
a566 2
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
d569 4
a572 7
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY,
			    p))) {
				vput(DETOV(tdp));
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
d581 1
a581 1
		if (!lockparent || !(flags & ISLASTCN)) {
a582 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
@


1.11.6.2
log
@Merge with the trunk
@
text
@d100 1
a100 1
	uint32_t cluster;
d105 1
a105 1
	uint32_t scn;		/* starting cluster number		 */
d575 1
a575 1
	uint32_t dirclust, diroffset;
d700 1
a700 1
	uint32_t cn;
d863 1
a863 1
	uint32_t dirclust, diroffset;
d870 1
a870 1
	uint32_t boff;
d923 1
a923 1
	uint32_t offset = pdep->de_fndoffset;
d989 1
a989 1
	uint32_t cn;
d1052 1
a1052 1
	uint32_t cn;
@


1.10
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.9 1997/11/11 18:57:16 niklas Exp $	*/
d446 3
@


1.9
log
@Initialize the de_lock.  some KNF
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_lookup.c,v 1.8 1997/11/06 05:58:57 csapuntz Exp $	*/
/*	$NetBSD: msdosfs_lookup.c,v 1.30 1996/10/25 23:14:08 cgd Exp $	*/
d5 2
a6 2
 * Copyright (C) 1994, 1995 Wolfgang Solfrank.
 * Copyright (C) 1994, 1995 TooLs GmbH.
d436 10
a446 2
	if (cluster == MSDOSFSROOT)
		blkoff = diroff;
d468 2
d480 6
d517 3
d660 1
a660 1
	
d708 2
d826 8
a838 1
		pmp = dep->de_pmp;
d852 3
d861 8
d937 1
a937 1
 * directory entry to be removed is still full length until no one has it
d962 1
d964 1
d974 11
d992 1
a993 1
			offset -= sizeof(struct direntry);
d995 1
a995 1
			    || !((offset + sizeof(struct direntry)) & pmp->pm_crbomask)
d1002 2
a1003 2
	    && offset
	    && !(offset & pmp->pm_crbomask));
d1069 2
@


1.8
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.7 1997/10/06 20:20:58 deraadt Exp $	*/
d168 2
a169 1
				error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
@


1.7
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.5 1997/03/02 18:01:57 millert Exp $	*/
d92 1
d165 2
a166 2
			VOP_UNLOCK(pdp);
			error = vget(vdp, 1);
d168 1
a168 1
				error = VOP_LOCK(pdp);
d170 1
a170 1
			error = vget(vdp, 1);
d172 1
a172 1
				VOP_UNLOCK(pdp);
d188 1
a188 1
				VOP_UNLOCK(pdp);
d190 1
a190 1
		if ((error = VOP_LOCK(pdp)) != 0)
d418 1
a418 1
			VOP_UNLOCK(vdp);
d488 1
a488 1
			VOP_UNLOCK(vdp);
d516 1
a516 1
			VOP_UNLOCK(vdp);
d541 1
a541 1
		VOP_UNLOCK(pdp);	/* race to get the inode */
d543 1
a543 1
			VOP_LOCK(pdp);
d547 1
a547 1
		    (error = VOP_LOCK(pdp))) {
d559 1
a559 1
			VOP_UNLOCK(pdp);
@


1.6
log
@VFS Lite2 Changes
@
text
@a91 1
	struct proc *p = cnp->cn_proc;
d164 2
a165 2
			VOP_UNLOCK(pdp, 0, p);
			error = vget(vdp, LK_EXCLUSIVE, p);
d167 1
a167 1
				error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d169 1
a169 1
			error = vget(vdp, LK_EXCLUSIVE, p);
d171 1
a171 1
				VOP_UNLOCK(pdp, 0, p);
d187 1
a187 1
				VOP_UNLOCK(pdp, 0, p);
d189 1
a189 1
		if ((error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
d417 1
a417 1
			VOP_UNLOCK(vdp, 0, p);
d487 1
a487 1
			VOP_UNLOCK(vdp, 0, p);
d515 1
a515 1
			VOP_UNLOCK(vdp, 0, p);
d540 1
a540 1
		VOP_UNLOCK(pdp, 0, p);	/* race to get the inode */
d542 1
a542 1
			vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d546 1
a546 1
		    (error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p))) {
d558 1
a558 1
			VOP_UNLOCK(pdp, 0, p);
@


1.5
log
@Sync msdosfs with NetBSD sans const-ness.  NetSBD log messages:
    Fix panic on mkdir.
    Thanks to Dave Huang for finding the bug.
    Fixes a bug with allowed/forbidden characters in non-W95 filenames.
    Don't extend directory when nothing is written to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: msdosfs_lookup.c,v 1.4 1996/04/19 16:10:00 niklas Exp $	*/
d92 1
d165 2
a166 2
			VOP_UNLOCK(pdp);
			error = vget(vdp, 1);
d168 1
a168 1
				error = VOP_LOCK(pdp);
d170 1
a170 1
			error = vget(vdp, 1);
d172 1
a172 1
				VOP_UNLOCK(pdp);
d188 1
a188 1
				VOP_UNLOCK(pdp);
d190 1
a190 1
		if ((error = VOP_LOCK(pdp)) != 0)
d418 1
a418 1
			VOP_UNLOCK(vdp);
d488 1
a488 1
			VOP_UNLOCK(vdp);
d516 1
a516 1
			VOP_UNLOCK(vdp);
d541 1
a541 1
		VOP_UNLOCK(pdp);	/* race to get the inode */
d543 1
a543 1
			VOP_LOCK(pdp);
d547 1
a547 1
		    (error = VOP_LOCK(pdp))) {
d559 1
a559 1
			VOP_UNLOCK(pdp);
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: msdosfs_lookup.c,v 1.3 1996/02/29 10:46:55 niklas Exp $	*/
/*	$NetBSD: msdosfs_lookup.c,v 1.26 1996/03/07 13:30:46 ws Exp $	*/
d128 1
a128 1
	       vdp, dp, dp->de_Attributes);
d181 1
a181 1
				       vdp, dp->de_Name);
d220 1
a220 1
		wincnt = winSlotCnt((u_char *)cnp->cn_nameptr,cnp->cn_namelen) + 1;
d224 1
a224 1
		wincnt = winSlotCnt((u_char *)cnp->cn_nameptr,cnp->cn_namelen) + 1;
d243 1
a243 1
	       dosfilename, cnp->cn_namelen);
d338 1
a338 1
				       blkoff, diroff);
d382 1
a382 1
	       nameiop, dp->de_refcnt);
d384 1
a384 1
	       slotcount, slotoffset);
d594 1
a594 1
	       dep, ddep, depp, cnp);
d609 2
a610 1
		if ((error = extendfile(ddep, dirclust, 0, 0, DE_CLEAR)) != 0)
d612 2
d755 1
a755 1
					       dentp->deName[0], dentp->deName[1]);
@


1.3
log
@From NetBSD: merge with 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: msdosfs_lookup.c,v 1.25 1996/02/09 19:13:47 christos Exp $	*/
d920 1
a920 1
		if (error);
@


1.2
log
@from netbsd (mostly by ws):
Win95 ignores case on lookup
Really don't generate long names when mounted with -s
Fix cookie handling
Don't forward credentials to bread, it makes nfs panic
(Of course, nfs shouldn't rely on the credentials not being referenced)
Don't give directory entry to deget, it could result in a deadlock
Use device blocks, not clusters for logical block numbers
Add support for Win'95 separate creation/modification/access timestamps
Re-introduce lowercase filenames for non-Win'95-filesystems
Fix thinko with block boundaries in directories
Don't overwrite dirclust, it's needed later on
Enable flock(2).
@
text
@d1 2
a2 1
/*	$NetBSD: msdosfs_lookup.c,v 1.24 1995/11/30 19:00:57 ws Exp $	*/
d52 1
d81 3
a83 1
msdosfs_lookup(ap)
d88 1
a88 2
	} */ *ap;
{
d97 1
a97 1
	int slotoffset;
d136 1
a136 1
	if (error = VOP_ACCESS(vdp, VEXEC, cnp->cn_cred, cnp->cn_proc))
d146 1
a146 1
	if (error = cache_lookup(vdp, vpp, cnp)) {
d189 1
a189 1
		if (error = VOP_LOCK(pdp))
d259 1
a259 1
		if (error = pcbmap(dp, frcn, &bn, &cluster, &blsize)) {
d264 2
a265 1
		if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) {
d392 2
a393 1
		if (error = VOP_ACCESS(vdp, VWRITE, cnp->cn_cred, cnp->cn_proc))
d470 2
a471 1
		if (error = VOP_ACCESS(vdp, VWRITE, cnp->cn_cred, cnp->cn_proc))
d483 1
a483 1
		if (error = deget(pmp, cluster, blkoff, &tdp))
d499 2
a500 1
		if (error = VOP_ACCESS(vdp, VWRITE, cnp->cn_cred, cnp->cn_proc))
d510 1
a510 1
		if (error = deget(pmp, cluster, blkoff, &tdp))
d541 1
a541 1
		if (error = deget(pmp, cluster, blkoff, &tdp)) {
d555 1
a555 1
		if (error = deget(pmp, cluster, blkoff, &tdp))
d609 1
a609 1
		if (error = extendfile(ddep, dirclust, 0, 0, DE_CLEAR))
d622 3
a624 2
	if (error = pcbmap(ddep, de_cluster(pmp, ddep->de_fndoffset),
	    &bn, &dirclust, &blsize))
d629 1
a629 1
	if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) {
d648 1
a648 1
				if (error = bwrite(bp))
d652 5
a656 3
				if (error = pcbmap(ddep,
				    de_cluster(pmp, ddep->de_fndoffset),
				    &bn, 0, &blsize))
d659 3
a661 1
				if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) {
d675 1
a675 1
	if (error = bwrite(bp))
d717 1
a717 1
		if (error = pcbmap(dep, cn, &bn, 0, &blsize)) {
d722 2
a723 1
		if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) {
d807 3
a809 2
		if (error = bread(pmp->pm_devvp, cntobn(pmp, scn),
				  pmp->pm_bpcluster, NOCRED, &bp))
d829 1
a829 1
		if (error = deget(pmp, scn, 0, &dep))
d865 1
a865 1
	if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, bpp)) {
d919 2
a920 1
		if (error = pcbmap(pdep, de_cluster(pmp, offset), &bn, 0, &blsize))
d922 2
a923 1
		if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) {
d942 1
a942 1
		if (error = bwrite(bp))
d979 1
a979 1
			if (error = pcbmap(dep, cn, &bn, 0, &blsize)) {
d984 2
a985 1
			if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp)) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: msdosfs_lookup.c,v 1.17 1995/09/09 19:38:06 ws Exp $	*/
d4 2
a5 2
 * Copyright (C) 1994 Wolfgang Solfrank.
 * Copyright (C) 1994 TooLs GmbH.
d55 1
d71 1
a71 1
 * soul owner of a directory block.  bread/brelse provide this service.
d93 1
a93 4
	int slotstatus;

#define	NONE	0
#define	FOUND	1
a94 1
	int slotcluster;
d97 1
a97 1
	int rootreloff;
d111 4
a114 1

d207 1
a207 1
		diroff = MSDOSFSROOT_OFS;
d211 16
d233 1
a233 1
	slotstatus = FOUND;
d235 3
a237 7
	    (flags & ISLASTCN)) {
		slotstatus = NONE;
		slotoffset = -1;
	}

	unix2dosfn((u_char *)cnp->cn_nameptr, dosfilename, cnp->cn_namelen);
	dosfilename[11] = 0;
d254 1
a254 1
	rootreloff = 0;
d261 2
a262 1
		if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp))
d264 5
a268 4
		for (diroff = 0; diroff < blsize;
		     diroff += sizeof(struct direntry),
		     rootreloff += sizeof(struct direntry)) {
			dep = (struct direntry *)(bp->b_data + diroff);
d280 8
a287 7
				if (slotstatus != FOUND) {
					slotstatus = FOUND;
					if (cluster == MSDOSFSROOT)
						slotoffset = rootreloff;
					else
						slotoffset = diroff;
					slotcluster = cluster;
d295 21
d319 2
a320 1
				if (dep->deAttributes & ATTR_VOLUME)
d322 2
d325 1
a325 1
				 * Check for a name match.
d327 3
a329 1
				if (bcmp(dosfilename, dep->deName, 11))
d331 1
d333 2
a334 2
				printf("msdosfs_lookup(): match diroff %d, rootreloff %d\n",
				       diroff, rootreloff);
d339 1
a339 5
				 * this lookup. If this is the root
				 * directory we are interested in
				 * the offset relative to the
				 * beginning of the directory (not
				 * the beginning of the cluster).
a340 2
				if (cluster == MSDOSFSROOT)
					diroff = rootreloff;
d342 2
a343 1
				dp->de_fndclust = cluster;
d346 1
a346 1
		}	/* for (diroff = 0; .... */
d360 12
d377 4
a380 4
	printf("msdosfs_lookup(): op %d, refcnt %d, slotstatus %d\n",
	       nameiop, dp->de_refcnt, slotstatus);
	printf("               slotoffset %d, slotcluster %d\n",
	       slotoffset, slotcluster);
d392 4
a395 16
		 * entry should be put.  If we didn't find a slot,
		 * then set dp->de_fndoffset to -1 indicating
		 * that the new slot belongs at the end of the
		 * directory. If we found a slot, then the new entry
		 * can be put at dp->de_fndoffset.
		 */
		if (slotstatus == NONE) {
			dp->de_fndoffset = (u_long)-1;
			dp->de_fndclust = (u_long)-1;
		} else {
#ifdef MSDOSFS_DEBUG
			printf("msdosfs_lookup(): saving empty slot location\n");
#endif
			dp->de_fndoffset = slotoffset;
			dp->de_fndclust = slotcluster;
		}
d430 17
d451 1
a451 2
	 * setup before jumping here.  And, bp is null.  There is no buf
	 * header.
d465 1
a465 3
		if (error = VOP_ACCESS(vdp, VWRITE, cnp->cn_cred, cnp->cn_proc)) {
			if (bp)
				brelse(bp);
d467 1
a467 1
		}
a474 2
			if (bp)
				brelse(bp);
d477 1
a477 3
		if (error = deget(pmp, cluster, diroff, dep, &tdp)) {
			if (bp)
				brelse(bp);
a478 1
		}
a481 2
		if (bp)
			brelse(bp);
d493 1
a493 3
		if (error = VOP_ACCESS(vdp, VWRITE, cnp->cn_cred, cnp->cn_proc)) {
			if (bp)
				brelse(bp);
d495 1
a495 1
		}
d500 1
a500 3
		if (dp->de_StartCluster == scn && isadir) {
			if (bp)
				brelse(bp);
d502 2
a503 5
		}
		error = deget(pmp, cluster, diroff, dep, &tdp);
		if (error) {
			if (bp)
				brelse(bp);
a504 1
		}
a508 2
		if (bp)
			brelse(bp);
d534 1
a534 1
		if (error = deget(pmp, cluster, diroff, dep, &tdp)) {
a535 2
			if (bp)
				brelse(bp);
a540 2
			if (bp)
				brelse(bp);
d548 1
a548 3
		if (error = deget(pmp, cluster, diroff, dep, &tdp)) {
			if (bp)
				brelse(bp);
a549 1
		}
a553 2
	if (bp)
		brelse(bp);
d568 1
d571 1
a571 1
createde(dep, ddep, depp)
d575 1
d582 3
a584 1

d586 2
a587 1
	printf("createde(dep %08x, ddep %08x, depp %08x)\n", dep, ddep, depp);
d598 6
a603 9
	if (ddep->de_fndclust == (u_long)-1) {
		if (error = extendfile(ddep, 1, &bp, &dirclust, DE_CLEAR))
			return (error);
		ndep = (struct direntry *)bp->b_data;
		/*
		 * Let caller know where we put the directory entry.
		 */
		ddep->de_fndclust = dirclust;
		ddep->de_fndoffset = diroffset = 0;
d607 17
a623 12
		ddep->de_FileSize += pmp->pm_bpcluster;
	} else {
		/*
		 * There is space in the existing directory.  So, we just
		 * read in the cluster with space.  Copy the new directory
		 * entry in.  Then write it to disk. NOTE:  DOS directories
		 * do not get smaller as clusters are emptied.
		 */
		dirclust = ddep->de_fndclust;
		diroffset = ddep->de_fndoffset;
		if (error = readep(pmp, dirclust, diroffset, &bp, &ndep))
			return (error);
d625 2
d628 37
d670 8
a677 6
		if (error = deget(pmp, dirclust, diroffset, ndep, depp))
			return (error);
	}
	if (error = bwrite(bp)) {
		vput(DETOV(*depp));	/* free the vnode we got on error */
		return (error);
d679 2
a680 52
	return (0);
}

/*
 * Read in a directory entry and mark it as being deleted.
 */
int
markdeleted(pmp, dirclust, diroffset)
	struct msdosfsmount *pmp;
	u_long dirclust;
	u_long diroffset;
{
	int error;
	struct direntry *ep;
	struct buf *bp;

	if (error = readep(pmp, dirclust, diroffset, &bp, &ep))
		return (error);
	ep->deName[0] = SLOT_DELETED;
	return (bwrite(bp));
}

/*
 * Remove a directory entry. At this point the file represented by the
 * directory entry to be removed is still full length until no one has it
 * open.  When the file no longer being used msdosfs_inactive() is called
 * and will truncate the file to 0 length.  When the vnode containing the
 * denode is needed for some other purpose by VFS it will call
 * msdosfs_reclaim() which will remove the denode from the denode cache.
 */
int
removede(pdep, dep)
	struct denode *pdep;	/* directory where the entry is removed */
	struct denode *dep;	/* file to be removed */
{
	int error;

#ifdef MSDOSFS_DEBUG
	printf("removede(): filename %s\n", dep->de_Name);
	printf("removede(): dep %08x, ndpcluster %d, ndpoffset %d\n",
	       dep, pdep->de_fndclust, pdep->de_fndoffset);
#endif

	/*
	 * Read the directory block containing the directory entry we are
	 * to make free.  The nameidata structure holds the cluster number
	 * and directory entry index number of the entry to free.
	 */
	if (error = markdeleted(pdep->de_pmp, pdep->de_fndclust, pdep->de_fndoffset))
		return (error);
	dep->de_refcnt--;
	return (0);
d705 9
a713 5
		error = pcbmap(dep, cn, &bn, 0, &blsize);
		if (error == E2BIG)
			return (1);	/* it's empty */
		if (error = bread(pmp->pm_devvp, bn, blsize, NOCRED, &bp))
			return (error);
d790 1
a790 1
			goto out;
d797 1
a811 2
		/* NOTE: deget() clears dep on error */
		error = deget(pmp, scn, 0, ep, &dep);
d814 2
a815 1
		if (error)
d848 2
a849 2
	    && boff + blsize > (pmp->pm_rootdirsize << pmp->pm_bnshift))
		blsize = (pmp->pm_rootdirsize << pmp->pm_bnshift) - boff;
d852 1
d875 171
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
