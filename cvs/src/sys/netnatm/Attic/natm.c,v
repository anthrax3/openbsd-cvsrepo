head	1.13;
access;
symbols
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.22
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.20
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.18
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.16
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.14
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.12
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.10
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.8
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.12
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2013.08.20.09.14.28;	author mpi;	state dead;
branches;
next	1.12;

1.12
date	2010.02.11.22.33.33;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.31.19.17.20;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.27.19.57.45;	author thib;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.09.21.36.40;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.12.18.45.14;	author mk;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.16.12.54.08;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	97.10.11.01.32.08;	author angelos;	state Exp;
branches
	1.5.12.1;
next	1.4;

1.4
date	97.10.11.01.21.16;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	96.11.09.03.28.59;	author chuck;	state Exp;
branches;
next	1.2;

1.2
date	96.07.03.17.24.29;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	96.06.30.21.40.12;	author chuck;	state Exp;
branches;
next	;

1.5.12.1
date	2001.07.04.10.55.41;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.13
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@/*	$OpenBSD: natm.c,v 1.12 2010/02/11 22:33:33 claudio Exp $	*/

/*
 *
 * Copyright (c) 1996 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *      Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * natm.c: native mode ATM access (both aal0 and aal5).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/domain.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/protosw.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

#include <net/if.h>
#include <net/if_atm.h>
#include <net/netisr.h>
#include <net/radix.h>
#include <net/route.h>

#include <netinet/in.h>

#include <netnatm/natm.h>

u_long natm5_sendspace = 16*1024;
u_long natm5_recvspace = 16*1024;

u_long natm0_sendspace = 16*1024;
u_long natm0_recvspace = 16*1024;

/*
 * user requests
 */

int natm_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control, struct proc *p)
{
  int error = 0, s, s2;
  struct natmpcb *npcb;
  struct sockaddr_natm *snatm;
  struct atm_pseudoioctl api;
  struct atm_pseudohdr *aph;
  struct atm_rawioctl ario;
  struct ifnet *ifp;
  int proto = so->so_proto->pr_protocol;

  s = splsoftnet();

  npcb = (struct natmpcb *) so->so_pcb;

  if (npcb == NULL && req != PRU_ATTACH) {
    error = EINVAL;
    goto done;
  }
    

  switch (req) {
    case PRU_ATTACH:			/* attach protocol to up */

      if (npcb) {
	error = EISCONN;
	break;
      }

      if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) {
	if (proto == PROTO_NATMAAL5) 
          error = soreserve(so, natm5_sendspace, natm5_recvspace);
	else
          error = soreserve(so, natm0_sendspace, natm0_recvspace);
        if (error)
          break;
      }

      so->so_pcb = (caddr_t) (npcb = npcb_alloc(M_WAITOK));
      npcb->npcb_socket = so;

      break;

    case PRU_DETACH:			/* detach protocol from up */

      /*
       * we turn on 'drain' *before* we sofree.
       */

      npcb_free(npcb, NPCB_DESTROY);	/* drain */
      so->so_pcb = NULL;
      sofree(so);

      break;

    case PRU_CONNECT:			/* establish connection to peer */

      /*
       * validate nam and npcb
       */

      if (nam->m_len != sizeof(*snatm)) {
        error = EINVAL;
	break;
      }
      snatm = mtod(nam, struct sockaddr_natm *);
      if (snatm->snatm_len != sizeof(*snatm) ||
		(npcb->npcb_flags & NPCB_FREE) == 0) {
	error = EINVAL;
	break;
      }
      if (snatm->snatm_family != AF_NATM) {
	error = EAFNOSUPPORT;
	break;
      }

      snatm->snatm_if[IFNAMSIZ-1] = '\0';  /* XXX ensure null termination
						since ifunit() uses strcmp */

      /*
       * convert interface string to ifp, validate.
       */

      ifp = ifunit(snatm->snatm_if);
      if (ifp == NULL || (ifp->if_flags & IFF_RUNNING) == 0) {
	error = ENXIO;
	break;
      }
      if (ifp->if_output != atm_output) {
	error = EAFNOSUPPORT;
	break;
      }


      /*
       * register us with the NATM PCB layer
       */

      if (npcb_add(npcb, ifp, snatm->snatm_vci, snatm->snatm_vpi) != npcb) {
        error = EADDRINUSE;
        break;
      }

      /*
       * enable rx
       */

      ATM_PH_FLAGS(&api.aph) = (proto == PROTO_NATMAAL5) ? ATM_PH_AAL5 : 0;
      ATM_PH_VPI(&api.aph) = npcb->npcb_vpi;
      ATM_PH_SETVCI(&api.aph, npcb->npcb_vci);
      api.rxhand = npcb;
      s2 = splnet();
      if (ifp->if_ioctl == NULL || 
	  ifp->if_ioctl(ifp, SIOCATMENA, (caddr_t) &api) != 0) {
	splx(s2);
	npcb_free(npcb, NPCB_REMOVE);
        error = EIO;
	break;
      }
      splx(s2);

      soisconnected(so);

      break;

    case PRU_DISCONNECT:		/* disconnect from peer */

      if ((npcb->npcb_flags & NPCB_CONNECTED) == 0) {
        printf("natm: disconnected check\n");
        error = EIO;
	break;
      }
      ifp = npcb->npcb_ifp;

      /*
       * disable rx
       */

      ATM_PH_FLAGS(&api.aph) = ATM_PH_AAL5;
      ATM_PH_VPI(&api.aph) = npcb->npcb_vpi;
      ATM_PH_SETVCI(&api.aph, npcb->npcb_vci);
      api.rxhand = npcb;
      s2 = splnet();
      if (ifp->if_ioctl != NULL)
	  ifp->if_ioctl(ifp, SIOCATMDIS, (caddr_t) &api);
      splx(s2);

      npcb_free(npcb, NPCB_REMOVE);
      soisdisconnected(so);

      break;

    case PRU_SHUTDOWN:			/* won't send any more data */
      socantsendmore(so);
      break;

    case PRU_SEND:			/* send this data */
      if (control && control->m_len) {
	m_freem(control);
	m_freem(m);
	error = EINVAL;
	break;
      }

      /*
       * send the data.   we must put an atm_pseudohdr on first
       */

      M_PREPEND(m, sizeof(*aph), M_WAITOK);
      aph = mtod(m, struct atm_pseudohdr *);
      ATM_PH_VPI(aph) = npcb->npcb_vpi;
      ATM_PH_SETVCI(aph, npcb->npcb_vci);
      ATM_PH_FLAGS(aph) = (proto == PROTO_NATMAAL5) ? ATM_PH_AAL5 : 0;

      error = atm_output(npcb->npcb_ifp, m, NULL, NULL);

      break;

    case PRU_SENSE:			/* return status into m */
      /* return zero? */
      break;

    case PRU_PEERADDR:			/* fetch peer's address */
      snatm = mtod(nam, struct sockaddr_natm *);
      bzero(snatm, sizeof(*snatm));
      nam->m_len = snatm->snatm_len = sizeof(*snatm);
      snatm->snatm_family = AF_NATM;
#if defined(__NetBSD__) || defined(__OpenBSD__)
      bcopy(npcb->npcb_ifp->if_xname, snatm->snatm_if, sizeof(snatm->snatm_if));
#elif defined(__FreeBSD__)
      sprintf(snatm->snatm_if, "%s%d", npcb->npcb_ifp->if_name,
	npcb->npcb_ifp->if_unit);
#endif
      snatm->snatm_vci = npcb->npcb_vci;
      snatm->snatm_vpi = npcb->npcb_vpi;
      break;

    case PRU_CONTROL:			/* control operations on protocol */
      /*
       * raw atm ioctl.   comes in as a SIOCRAWATM.   we convert it to
       * SIOCXRAWATM and pass it to the driver.
       */
      if ((u_long)m == SIOCRAWATM) {
        if (npcb->npcb_ifp == NULL) {
          error = ENOTCONN;
          break;
        }
        ario.npcb = npcb;
        ario.rawvalue = *((int *)nam);
        error = npcb->npcb_ifp->if_ioctl(npcb->npcb_ifp, 
				SIOCXRAWATM, (caddr_t) &ario);
	if (!error) {
          if (ario.rawvalue) 
	    npcb->npcb_flags |= NPCB_RAW;
	  else
	    npcb->npcb_flags &= ~(NPCB_RAW);
	}

        break;
      }

      error = EOPNOTSUPP;
      break;

    case PRU_BIND:			/* bind socket to address */
    case PRU_LISTEN:			/* listen for connection */
    case PRU_ACCEPT:			/* accept connection from peer */
    case PRU_CONNECT2:			/* connect two sockets */
    case PRU_ABORT:			/* abort (fast DISCONNECT, DETACH) */
					/* (only happens if LISTEN socket) */
    case PRU_RCVD:			/* have taken data; more room now */
    case PRU_FASTTIMO:			/* 200ms timeout */
    case PRU_SLOWTIMO:			/* 500ms timeout */
    case PRU_RCVOOB:			/* retrieve out of band data */
    case PRU_SENDOOB:			/* send out of band data */
    case PRU_PROTORCV:			/* receive from below */
    case PRU_PROTOSEND:			/* send to below */
    case PRU_SOCKADDR:			/* fetch socket's address */
#ifdef DIAGNOSTIC
      printf("natm: PRU #%d unsupported\n", req);
#endif
      error = EOPNOTSUPP;
      break;
   
    default: panic("natm usrreq");
  }

done:
  splx(s);
  return(error);
}

/*
 * natmintr: splsoftnet interrupt
 *
 * note: we expect a socket pointer in rcvif rather than an interface
 * pointer.    we can get the interface pointer from the so's PCB if
 * we really need it.
 */

void
natmintr()

{
  int s;
  struct mbuf *m;
  struct socket *so;
  struct natmpcb *npcb;

next:
  s = splnet();
  IF_DEQUEUE(&natmintrq, m);
  splx(s);
  if (m == NULL)
    return;

#ifdef DIAGNOSTIC
  if ((m->m_flags & M_PKTHDR) == 0)
    panic("natmintr no HDR");
#endif

  npcb = (struct natmpcb *) m->m_pkthdr.rcvif; /* XXX: overloaded */
  so = npcb->npcb_socket;

  s = splnet();			/* could have atm devs @@ different levels */
  npcb->npcb_inq--;
  splx(s);

  if (npcb->npcb_flags & NPCB_DRAIN) {
    m_freem(m);
    if (npcb->npcb_inq == 0)
      free(npcb, M_PCB);			/* done! */
    goto next;
  }

  if (npcb->npcb_flags & NPCB_FREE) {
    m_freem(m);					/* drop */
    goto next;
  }

#ifdef NEED_TO_RESTORE_IFP
  m->m_pkthdr.rcvif = npcb->npcb_ifp;
#else
#ifdef DIAGNOSTIC
m->m_pkthdr.rcvif = NULL;	/* null it out to be safe */
#endif
#endif

  if (sbspace(&so->so_rcv) > m->m_pkthdr.len ||
     ((npcb->npcb_flags & NPCB_RAW) != 0 && so->so_rcv.sb_cc < NPCB_RAWCC) ) {
#ifdef NATM_STAT
    natm_sookcnt++;
    natm_sookbytes += m->m_pkthdr.len;
#endif
    sbappendrecord(&so->so_rcv, m);
    sorwakeup(so);
  } else {
#ifdef NATM_STAT
    natm_sodropcnt++;
    natm_sodropbytes += m->m_pkthdr.len;
#endif
    m_freem(m);
  }

  goto next;
}

#if defined(__FreeBSD__)
NETISR_SET(NETISR_NATM, natmintr);
#endif


/* 
 * natm0_sysctl: not used, but here in case we want to add something
 * later...
 */

int natm0_sysctl(name, namelen, oldp, oldlenp, newp, newlen)

int *name;
u_int namelen;
void *oldp;
size_t *oldlenp;
void *newp;
size_t newlen;

{
  /* All sysctl names at this level are terminal. */
  if (namelen != 1)
    return (ENOTDIR);
  return (ENOPROTOOPT);
}

/* 
 * natm5_sysctl: not used, but here in case we want to add something
 * later...
 */

int natm5_sysctl(name, namelen, oldp, oldlenp, newp, newlen)

int *name;
u_int namelen;
void *oldp;
size_t *oldlenp;
void *newp;
size_t newlen;

{
  /* All sysctl names at this level are terminal. */
  if (namelen != 1)
    return (ENOTDIR);
  return (ENOPROTOOPT);
}
@


1.12
log
@Correct argument for splx() is s2 not s so that the splx() calls match to the
spl(soft)net() calls. Found by Gleydson Soares.
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.11 2009/05/31 19:17:20 claudio Exp $	*/
@


1.11
log
@Remove some #ifdef / #define maze that is not needed at all.
OK deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.10 2008/05/27 19:57:45 thib Exp $	*/
d216 1
a216 1
      splx(s);
@


1.10
log
@bring the netnatm usrreq's also up to speed on the addition of the
struct proc argument to the usrreq's routines...
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.9 2007/12/09 21:36:40 hshoexer Exp $	*/
d82 1
a82 1
  s = SPLSOFTNET();
@


1.9
log
@another FREE->free

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.8 2007/09/12 18:45:14 mk Exp $	*/
d70 2
a71 11
#if defined(__NetBSD__)
int natm_usrreq(so, req, m, nam, control)
#elif defined(__OpenBSD__) || defined(__FreeBSD__)
int natm_usrreq(so, req, m, nam, control)
#endif
struct socket *so;
int req;
struct mbuf *m, *nam, *control;
#if defined(__NetBSD__)
struct proc *p;
#endif
@


1.8
log
@There is no such word as `detatch'.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.7 2006/03/04 22:40:16 brad Exp $	*/
d371 1
a371 1
      FREE(npcb, M_PCB);			/* done! */
@


1.7
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.6 2001/05/16 12:54:08 ho Exp $	*/
d308 1
a308 1
    case PRU_ABORT:			/* abort (fast DISCONNECT, DETATCH) */
@


1.6
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.5 1997/10/11 01:32:08 angelos Exp $	*/
d191 1
a191 1
      s2 = splimp();
d222 1
a222 1
      s2 = splimp();
d350 1
a350 1
  s = splimp();
d364 1
a364 1
  s = splimp();			/* could have atm devs @@ different levels */
@


1.5
log
@Keep the ifdef for NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.4 1997/10/11 01:21:16 angelos Exp $	*/
a248 4
      if (m == NULL) {
        error = ENOBUFS;
	break;
      }
@


1.5.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.5 1997/10/11 01:32:08 angelos Exp $	*/
d249 4
@


1.4
log
@Fix some minor compilation problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.3 1996/11/09 03:28:59 chuck Exp $	*/
d70 1
d72 3
d78 3
@


1.3
log
@netbsd pr#2918 (jukka.partanen@@research.nokia.com):
 - fix up netnatm so that it compiles with new warning flags (and
        install headers)
 - sync in some minor changes from netbsd (Matthias Drochner)
@
text
@d1 1
a1 1
/*	$OpenBSD: natm.c,v 1.5 1996/11/09 03:26:26 chuck Exp $	*/
a69 3
#if defined(__NetBSD__) || defined(__OpenBSD__)
int natm_usrreq(so, req, m, nam, control, p)
#elif defined(__FreeBSD__)
a70 2
#endif

a73 4
#if defined(__NetBSD__) || defined(__OpenBSD__)
struct proc *p;
#endif

@


1.2
log
@ported to FreeBSD 2.2-960612-SNAP.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d277 1
a277 1
			npcb->npcb_ifp->if_unit);
d364 1
a364 1
    panic("ipintr no HDR");
d400 1
a400 1
    sbappend(&so->so_rcv, m);
@


1.1
log
@new: protocol layer to provide you with native mode ATM access.
	you can open raw aal5 and aal0 vcs with this protocol layer.
@
text
@d41 1
d52 1
d70 1
d72 3
d79 1
d81 1
d93 1
a93 1
  s = splsoftnet();
d120 1
a120 1
      so->so_pcb = npcb = npcb_alloc(M_WAITOK);
d270 1
d273 1
d275 4
d412 5
@
