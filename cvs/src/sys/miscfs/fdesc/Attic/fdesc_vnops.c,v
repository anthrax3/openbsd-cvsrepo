head	1.39;
access;
symbols
	OPENBSD_3_8:1.37.0.6
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.37.0.4
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.37.0.2
	OPENBSD_3_6_BASE:1.37
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.34
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.32
	UBC:1.26.0.2
	UBC_BASE:1.26
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.10
	OPENBSD_2_8:1.16.0.8
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.6
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.4
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2005.12.06.20.18.57;	author pedro;	state dead;
branches;
next	1.38;

1.38
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.20.18.32.37;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.28.10;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.06.21.43.26;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.01.27.07;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.12.18.41.21;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.02.16.05.58;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.04.22.44.31;	author art;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.26.12.03.28;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.23.02.14.24;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.23.14.34.30;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.15.07.49.45;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.15.07.26.28;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.14.13.43.54;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.14.11.04.05;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.14.10.51.27;	author art;	state Exp;
branches;
next	1.16;

1.16
date	99.10.13.06.32.23;	author art;	state Exp;
branches
	1.16.4.1
	1.16.10.1;
next	1.15;

1.15
date	99.08.13.07.05.46;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	99.08.13.04.50.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.04.28.09.28.15;	author art;	state Exp;
branches;
next	1.12;

1.12
date	98.08.06.19.34.32;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	98.06.11.16.34.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.05.58.33;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.21.04.43;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.15.19.01;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.08.01.05.58.55;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.26.11.52.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.10.16.44.22;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.09.07.18.11.18;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.04.46.59;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.51.41;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.59;	author deraadt;	state Exp;
branches;
next	;

1.16.4.1
date	2001.07.04.10.49.06;	author niklas;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2001.10.31.03.26.30;	author nate;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.16.4.4;

1.16.4.4
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.16.4.5;

1.16.4.5
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.16.4.6;

1.16.4.6
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	1.16.4.7;

1.16.4.7
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.16.4.8;

1.16.4.8
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.16.4.9;

1.16.4.9
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	1.16.4.10;

1.16.4.10
date	2004.06.05.23.13.05;	author niklas;	state Exp;
branches;
next	;

1.16.10.1
date	2001.05.31.05.08.31;	author jason;	state Exp;
branches;
next	;

1.26.2.1
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2003.05.19.22.36.11;	author tedu;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2003.05.20.04.05.38;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Remove fdescfs
@
text
@/*	$OpenBSD: fdesc_vnops.c,v 1.38 2005/11/19 02:18:01 pedro Exp $	*/
/*	$NetBSD: fdesc_vnops.c,v 1.32 1996/04/11 11:24:29 mrg Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software donated to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fdesc_vnops.c	8.12 (Berkeley) 8/20/94
 *
 * #Id: fdesc_vnops.c,v 1.12 1993/04/06 16:17:17 jsp Exp #
 */

/*
 * /dev/fd Filesystem
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/kernel.h>	/* boottime */
#include <sys/resourcevar.h>
#include <sys/socketvar.h>
#include <sys/filedesc.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/buf.h>
#include <sys/dirent.h>
#include <sys/tty.h>
#include <sys/poll.h>

#include <miscfs/fdesc/fdesc.h>

#include <uvm/uvm_extern.h>

#include <sys/pipe.h>

#define cttyvp(p) ((p)->p_flag & P_CONTROLT ? (p)->p_session->s_ttyvp : NULL)

static struct lock fdcache_lock;

dev_t devctty;

#if (FD_STDIN != FD_STDOUT-1) || (FD_STDOUT != FD_STDERR-1)
FD_STDIN, FD_STDOUT, FD_STDERR must be a sequence n, n+1, n+2
#endif

#define	NFDCACHE 4

#define FD_NHASH(ix) \
	(&fdhashtbl[(ix) & fdhash])
LIST_HEAD(fdhashhead, fdescnode) *fdhashtbl;
static u_long fdhash;

int	fdesc_badop(void *);

int	fdesc_lookup(void *);
#define	fdesc_create	eopnotsupp
#define	fdesc_mknod	eopnotsupp
int	fdesc_open(void *);
#define	fdesc_close	nullop
#define	fdesc_access	nullop
int	fdesc_getattr(void *);
int	fdesc_setattr(void *);
int	fdesc_read(void *);
int	fdesc_write(void *);
int	fdesc_ioctl(void *);
int	fdesc_poll(void *);
#define	fdesc_fsync	nullop
#define	fdesc_remove	eopnotsupp
#define fdesc_revoke    vop_generic_revoke
int	fdesc_link(void *);
#define	fdesc_rename	eopnotsupp
#define	fdesc_mkdir	eopnotsupp
#define	fdesc_rmdir	eopnotsupp
int	fdesc_symlink(void *);
int	fdesc_readdir(void *);
int	fdesc_readlink(void *);
int	fdesc_inactive(void *);
int	fdesc_reclaim(void *);
#define	fdesc_lock	vop_generic_lock
#define	fdesc_unlock	vop_generic_unlock
#define	fdesc_bmap	fdesc_badop
#define	fdesc_strategy	fdesc_badop
int	fdesc_print(void *);
int	fdesc_pathconf(void *);
#define	fdesc_islocked	vop_generic_islocked
#define	fdesc_advlock	eopnotsupp
#define	fdesc_bwrite	eopnotsupp

int (**fdesc_vnodeop_p)(void *);
struct vnodeopv_entry_desc fdesc_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, fdesc_lookup },	/* lookup */
	{ &vop_create_desc, fdesc_create },	/* create */
	{ &vop_mknod_desc, fdesc_mknod },	/* mknod */
	{ &vop_open_desc, fdesc_open },		/* open */
	{ &vop_close_desc, fdesc_close },	/* close */
	{ &vop_access_desc, fdesc_access },	/* access */
	{ &vop_getattr_desc, fdesc_getattr },	/* getattr */
	{ &vop_setattr_desc, fdesc_setattr },	/* setattr */
	{ &vop_read_desc, fdesc_read },		/* read */
	{ &vop_write_desc, fdesc_write },	/* write */
	{ &vop_ioctl_desc, fdesc_ioctl },	/* ioctl */
	{ &vop_revoke_desc, fdesc_revoke },     /* revoke */
	{ &vop_poll_desc, fdesc_poll },		/* poll */
	{ &vop_fsync_desc, fdesc_fsync },	/* fsync */
	{ &vop_remove_desc, fdesc_remove },	/* remove */
	{ &vop_link_desc, fdesc_link },		/* link */
	{ &vop_rename_desc, fdesc_rename },	/* rename */
	{ &vop_mkdir_desc, fdesc_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, fdesc_rmdir },	/* rmdir */
	{ &vop_symlink_desc, fdesc_symlink },	/* symlink */
	{ &vop_readdir_desc, fdesc_readdir },	/* readdir */
	{ &vop_readlink_desc, fdesc_readlink },	/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },	/* abortop */
	{ &vop_inactive_desc, fdesc_inactive },	/* inactive */
	{ &vop_reclaim_desc, fdesc_reclaim },	/* reclaim */
	{ &vop_lock_desc, fdesc_lock },		/* lock */
	{ &vop_unlock_desc, fdesc_unlock },	/* unlock */
	{ &vop_bmap_desc, fdesc_bmap },		/* bmap */
	{ &vop_strategy_desc, fdesc_strategy },	/* strategy */
	{ &vop_print_desc, fdesc_print },	/* print */
	{ &vop_islocked_desc, fdesc_islocked },	/* islocked */
	{ &vop_pathconf_desc, fdesc_pathconf },	/* pathconf */
	{ &vop_advlock_desc, fdesc_advlock },	/* advlock */
	{ &vop_bwrite_desc, fdesc_bwrite },	/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
};

struct vnodeopv_desc fdesc_vnodeop_opv_desc =
	{ &fdesc_vnodeop_p, fdesc_vnodeop_entries };

/*
 * Initialise cache headers
 */
int
fdesc_init(vfsp)
	struct vfsconf *vfsp;
{
	int cttymajor;

	/* locate the major number */
	for (cttymajor = 0; cttymajor < nchrdev; cttymajor++)
		if (cdevsw[cttymajor].d_open == cttyopen)
			break;
	devctty = makedev(cttymajor, 0);
	fdhashtbl = hashinit(NFDCACHE, M_CACHE, M_WAITOK, &fdhash);
	lockinit(&fdcache_lock, PVFS, "fdfs", 0, 0);
	return (0);
}

int
fdesc_allocvp(ftype, ix, mp, vpp)
	fdntype ftype;
	int ix;
	struct mount *mp;
	struct vnode **vpp;
{
	struct proc *p = curproc;
	struct fdhashhead *fc;
	struct fdescnode *fd;
	int error = 0;

	if ((error = lockmgr(&fdcache_lock, LK_EXCLUSIVE, NULL)) != 0)
		return error;

	fc = FD_NHASH(ix);
loop:
	LIST_FOREACH(fd, fc, fd_hash) {
		if (fd->fd_ix == ix && fd->fd_vnode->v_mount == mp) {
			if (vget(fd->fd_vnode, 0, p))
				goto loop;
			*vpp = fd->fd_vnode;
			goto out;
		}
	}

	error = getnewvnode(VT_FDESC, mp, fdesc_vnodeop_p, vpp);
	if (error)
		goto out;
	MALLOC(fd, void *, sizeof(struct fdescnode), M_TEMP, M_WAITOK);
	(*vpp)->v_data = fd;
	fd->fd_vnode = *vpp;
	fd->fd_type = ftype;
	fd->fd_fd = -1;
	fd->fd_link = 0;
	fd->fd_ix = ix;
	LIST_INSERT_HEAD(fc, fd, fd_hash);

out:
	lockmgr(&fdcache_lock, LK_RELEASE, NULL);

	return (error);
}

/*
 * vp is the current namei directory
 * ndp is the name to locate in that directory...
 */
int
fdesc_lookup(v)
	void *v;
{
	struct vop_lookup_args /* {
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
	struct vnode **vpp = ap->a_vpp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	char *pname = cnp->cn_nameptr;
	struct proc *p = cnp->cn_proc;
	int nfiles = p->p_fd->fd_nfiles;
	unsigned fd = 0;
	int error;
	struct vnode *fvp;
	char *ln;

	if (cnp->cn_namelen == 1 && *pname == '.') {
		*vpp = dvp;
		VREF(dvp);
		return (0);
	}

	switch (VTOFDESC(dvp)->fd_type) {
	default:
	case Flink:
	case Fdesc:
	case Fctty:
		error = ENOTDIR;
		goto bad;

	case Froot:
		if (cnp->cn_namelen == 2 && bcmp(pname, "fd", 2) == 0) {
			error = fdesc_allocvp(Fdevfd, FD_DEVFD, dvp->v_mount, &fvp);
			if (error)
				goto bad;
			*vpp = fvp;
			fvp->v_type = VDIR;
			goto good;
		}

		if (cnp->cn_namelen == 3 && bcmp(pname, "tty", 3) == 0) {
			struct vnode *ttyvp = cttyvp(p);
			if (ttyvp == NULL) {
				error = ENXIO;
				goto bad;
			}
			error = fdesc_allocvp(Fctty, FD_CTTY, dvp->v_mount, &fvp);
			if (error)
				goto bad;
			*vpp = fvp;
			fvp->v_type = VCHR;
			goto good;
		}

		ln = 0;
		switch (cnp->cn_namelen) {
		case 5:
			if (bcmp(pname, "stdin", 5) == 0) {
				ln = "fd/0";
				fd = FD_STDIN;
			}
			break;
		case 6:
			if (bcmp(pname, "stdout", 6) == 0) {
				ln = "fd/1";
				fd = FD_STDOUT;
			} else
			if (bcmp(pname, "stderr", 6) == 0) {
				ln = "fd/2";
				fd = FD_STDERR;
			}
			break;
		}

		if (ln) {
			error = fdesc_allocvp(Flink, fd, dvp->v_mount, &fvp);
			if (error)
				goto bad;
			VTOFDESC(fvp)->fd_link = ln;
			*vpp = fvp;
			fvp->v_type = VLNK;
			goto good;
		} else {
			error = ENOENT;
			goto bad;
		}

		/* FALL THROUGH */

	case Fdevfd:
		if (cnp->cn_namelen == 2 && bcmp(pname, "..", 2) == 0) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
			error = fdesc_root(dvp->v_mount, vpp);
			if (error)
				goto bad;
			/* If we're at the last component and need the
			 * parent locked, undo the unlock above.
			 */
			if (((~cnp->cn_flags & (ISLASTCN | LOCKPARENT)) == 0) &&
			    ((error = vn_lock(dvp, LK_EXCLUSIVE, p)) == 0))
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}

		fd = 0;
		while (*pname >= '0' && *pname <= '9') {
			fd = 10 * fd + *pname++ - '0';
			if (fd >= nfiles)
				break;
		}

		if (*pname != '\0') {
			error = ENOENT;
			goto bad;
		}

		if (fd_getfile(p->p_fd, fd) == NULL) {
			error = EBADF;
			goto bad;
		}

		error = fdesc_allocvp(Fdesc, FD_DESC+fd, dvp->v_mount, &fvp);
		if (error)
			goto bad;
		VTOFDESC(fvp)->fd_fd = fd;
		*vpp = fvp;
		goto good;
	}

bad:
	*vpp = NULL;
	return (error);

good:
	/*
	 * As "." was special cased above, we now unlock the parent if we're
	 * supposed to. We're only supposed to not unlock if this is the
	 * last component, and the caller requested LOCKPARENT. So if either
	 * condition is false, unlock.
	 */
	if (((~cnp->cn_flags) & (ISLASTCN | LOCKPARENT)) != 0) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
	return (0);
}

int
fdesc_open(v)
	void *v;
{
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;

	switch (VTOFDESC(vp)->fd_type) {
	case Fdesc:
		/*
		 * XXX Kludge: set p->p_dupfd to contain the value of the
		 * the file descriptor being sought for duplication. The error 
		 * return ensures that the vnode for this device will be
		 * released by vn_open. Open will detect this special error and
		 * take the actions in dupfdopen.  Other callers of vn_open or
		 * VOP_OPEN will simply report the error.
		 */
		ap->a_p->p_dupfd = VTOFDESC(vp)->fd_fd;	/* XXX */
		return (ENODEV);

	case Fctty:
		return (cttyopen(devctty, ap->a_mode, 0, ap->a_p));
	case Froot:
	case Fdevfd:
	case Flink:
		break;
	}

	return (0);
}

int
fdesc_getattr(v)
	void *v;
{
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vattr *vap = ap->a_vap;
	unsigned int fd;
	struct stat stb;
        struct filedesc *fdp;
	struct file *fp;
	int error = 0;

	switch (VTOFDESC(vp)->fd_type) {
	case Froot:
	case Fdevfd:
	case Flink:
	case Fctty:
		bzero(vap, sizeof(*vap));
		vattr_null(vap);
		vap->va_fileid = VTOFDESC(vp)->fd_ix;

#define R_ALL (S_IRUSR|S_IRGRP|S_IROTH)
#define W_ALL (S_IWUSR|S_IWGRP|S_IWOTH)
#define X_ALL (S_IXUSR|S_IXGRP|S_IXOTH)

		switch (VTOFDESC(vp)->fd_type) {
		case Flink:
			vap->va_mode = R_ALL|X_ALL;
			vap->va_type = VLNK;
			vap->va_rdev = 0;
			vap->va_nlink = 1;
			vap->va_size = strlen(VTOFDESC(vp)->fd_link);
			break;

		case Fctty:
			vap->va_mode = R_ALL|W_ALL;
			vap->va_type = VCHR;
			vap->va_rdev = devctty;
			vap->va_nlink = 1;
			vap->va_size = 0;
			break;

		default:
			vap->va_mode = R_ALL|X_ALL;
			vap->va_type = VDIR;
			vap->va_rdev = 0;
			vap->va_nlink = 2;
			vap->va_size = DEV_BSIZE;
			break;
		}
		vap->va_uid = 0;
		vap->va_gid = 0;
		vap->va_fsid = vp->v_mount->mnt_stat.f_fsid.val[0];
		vap->va_blocksize = DEV_BSIZE;
		vap->va_atime.tv_sec = boottime.tv_sec;
		vap->va_atime.tv_nsec = 0;
		vap->va_mtime = vap->va_atime;
		vap->va_ctime = vap->va_mtime;
		vap->va_gen = 0;
		vap->va_flags = 0;
		vap->va_bytes = 0;
		break;

	case Fdesc:
		fd = VTOFDESC(vp)->fd_fd;
		fdp = ap->a_p->p_fd;
		if ((fp = fd_getfile(fdp, fd)) == NULL)
			return (EBADF);
		memset(&stb, 0, sizeof(stb));
		FREF(fp);
		error = (*fp->f_ops->fo_stat)(fp, &stb, ap->a_p);
		FRELE(fp);
		if (error != 0)
			break;
		vattr_null(vap);
		vap->va_type = IFTOVT(stb.st_mode);
		vap->va_mode = stb.st_mode;
		/*
		 * directories can cause loops in the namespace,
		 * so turn off the 'x' bits to avoid trouble.
		 */
		if (vap->va_type == VDIR)
			vap->va_mode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
		vap->va_nlink = stb.st_nlink;
		vap->va_uid = stb.st_uid;
		vap->va_gid = stb.st_gid;
		vap->va_fsid = stb.st_dev;
		vap->va_fileid = stb.st_ino;
		vap->va_size = stb.st_size;
		vap->va_blocksize = stb.st_blksize;
		vap->va_atime = stb.st_atimespec;
		vap->va_mtime = stb.st_mtimespec;
		vap->va_ctime = stb.st_ctimespec;
		vap->va_gen = stb.st_gen;
		vap->va_flags = stb.st_flags;
		vap->va_rdev = stb.st_rdev;
		vap->va_bytes = stb.st_blocks * stb.st_blksize;
		break;

	default:
		panic("fdesc_getattr");
		break;	
	}

	if (error == 0)
		vp->v_type = vap->va_type;

	return (error);
}

int
fdesc_setattr(v)
	void *v;
{
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct vattr *vap = ap->a_vap;
	struct proc *p = ap->a_p;
	struct vnode *vp;
	struct file *fp;
	int error;

	/*
	 * Can't mess with the root vnode
	 */
	switch (VTOFDESC(ap->a_vp)->fd_type) {
	case Fdesc:
		break;

	case Fctty:
		if (vap->va_flags != VNOVAL)
			return (EOPNOTSUPP);
		return (0);

	default:
		return (EACCES);
	}

	if ((error = getvnode(p->p_fd, VTOFDESC(ap->a_vp)->fd_fd, &fp)) != 0) {
		/*
		 * getvnode returns EINVAL if the file is not a vnode.
		 * We siltently drop all changes except chflags when that
		 * happens.
		 */
		if (error == EINVAL) {
			if (vap->va_flags == VNOVAL)
				error = 0;
			else
				error = EOPNOTSUPP;
		}
		return (error);
	}
	vp = (struct vnode *)fp->f_data;
	if (vp->v_mount->mnt_flag & MNT_RDONLY) {
		error = EROFS;
		goto out;
	}
	/*
	 * Directories can cause deadlocks.
	 */
	if (vp->v_type == VDIR) {
		error = EOPNOTSUPP;
		goto out;
	}
	vn_lock(vp, LK_EXCLUSIVE|LK_RETRY, p);
	error = VOP_SETATTR(vp, vap, ap->a_cred, p);
	VOP_UNLOCK(vp, 0, p);
out:
	FRELE(fp);
	return (error);
}

#define UIO_MX 32

struct fdesc_target {
	ino_t ft_fileno;
	u_char ft_type;
	u_char ft_namlen;
	char *ft_name;
} fdesc_targets[] = {
/* NOTE: The name must be less than UIO_MX-16 chars in length */
#define N(s) sizeof(s)-1, s
	{ FD_DEVFD,  DT_DIR,     N("fd")     },
	{ FD_STDIN,  DT_LNK,     N("stdin")  },
	{ FD_STDOUT, DT_LNK,     N("stdout") },
	{ FD_STDERR, DT_LNK,     N("stderr") },
	{ FD_CTTY,   DT_UNKNOWN, N("tty")    },
#undef N
};
static int nfdesc_targets = sizeof(fdesc_targets) / sizeof(fdesc_targets[0]);

int
fdesc_readdir(v)
	void *v;
{
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		int *a_ncookies;
		u_long **a_cookies;
	} */ *ap = v;
	struct uio *uio = ap->a_uio;
	struct dirent d;
	struct filedesc *fdp;
	int i;
	int error;

	switch (VTOFDESC(ap->a_vp)->fd_type) {
	case Fctty:
		return (0);

	case Fdesc:
		return (ENOTDIR);

	default:
		break;
	}

	fdp = uio->uio_procp->p_fd;

	if (uio->uio_resid < UIO_MX)
		return (EINVAL);

	error = 0;
	i = uio->uio_offset;
	if (i < 0)
		return (EINVAL);
	bzero(&d, UIO_MX);
	d.d_reclen = UIO_MX;

	if (VTOFDESC(ap->a_vp)->fd_type == Froot) {
		struct fdesc_target *ft;

		for (ft = &fdesc_targets[i];
		     uio->uio_resid >= UIO_MX && i < nfdesc_targets; ft++, i++) {
			switch (ft->ft_fileno) {
			case FD_CTTY:
				if (cttyvp(uio->uio_procp) == NULL)
					continue;
				break;

			case FD_STDIN:
			case FD_STDOUT:
			case FD_STDERR:
				if ((ft->ft_fileno - FD_STDIN) >= fdp->fd_nfiles)
					continue;
				if (fd_getfile(fdp, ft->ft_fileno - FD_STDIN) == NULL)
					continue;
				break;
			}

			d.d_fileno = ft->ft_fileno;
			d.d_namlen = ft->ft_namlen;
			bcopy(ft->ft_name, d.d_name, ft->ft_namlen + 1);
			d.d_type = ft->ft_type;

			if ((error = uiomove(&d, UIO_MX, uio)) != 0)
				break;
		}
	} else {
		for (; i - 2 < fdp->fd_nfiles && uio->uio_resid >= UIO_MX;
		     i++) {
			switch (i) {
			case 0:
			case 1:
				d.d_fileno = FD_ROOT;		/* XXX */
				d.d_namlen = i + 1;
				bcopy("..", d.d_name, d.d_namlen);
				d.d_name[i + 1] = '\0';
				d.d_type = DT_DIR;
				break;
	
			default:
				if (fd_getfile(fdp, i - 2) == NULL)
					continue;
				d.d_fileno = i - 2 + FD_STDIN;
				d.d_namlen = snprintf(d.d_name, sizeof d.d_name,
				    "%d", i - 2);
				d.d_type = DT_UNKNOWN;
				break;
			}

			if ((error = uiomove(&d, UIO_MX, uio)) != 0)
				break;
		}
	}

	uio->uio_offset = i;
	return (error);
}

int
fdesc_readlink(v)
	void *v;
{
	struct vop_readlink_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	int error;

	if (vp->v_type != VLNK)
		return (EPERM);

	if (VTOFDESC(vp)->fd_type == Flink) {
		char *ln = VTOFDESC(vp)->fd_link;
		error = uiomove(ln, strlen(ln), ap->a_uio);
	} else {
		error = EOPNOTSUPP;
	}

	return (error);
}

int
fdesc_read(v)
	void *v;
{
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
	int error = EOPNOTSUPP;

	switch (VTOFDESC(ap->a_vp)->fd_type) {
	case Fctty:
		error = cttyread(devctty, ap->a_uio, ap->a_ioflag);
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}
	
	return (error);
}

int
fdesc_write(v)
	void *v;
{
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
	int error = EOPNOTSUPP;

	switch (VTOFDESC(ap->a_vp)->fd_type) {
	case Fctty:
		error = cttywrite(devctty, ap->a_uio, ap->a_ioflag);
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}
	
	return (error);
}

int
fdesc_ioctl(v)
	void *v;
{
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	int error = EOPNOTSUPP;

	switch (VTOFDESC(ap->a_vp)->fd_type) {
	case Fctty:
		error = cttyioctl(devctty, ap->a_command, ap->a_data,
				  ap->a_fflag, ap->a_p);
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}
	
	return (error);
}

int
fdesc_poll(v)
	void *v;
{
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int  a_events;
		struct proc *a_p;
	} */ *ap = v;
	int revents;

	switch (VTOFDESC(ap->a_vp)->fd_type) {
	case Fctty:
		revents = cttypoll(devctty, ap->a_events, ap->a_p);
		break;

	default:
		revents = ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM);
		break;
	}
	
	return (revents);
}

int
fdesc_inactive(v)
	void *v;
{
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;

	/*
	 * Clear out the v_type field to avoid
	 * nasty things happening in vgone().
	 */
	VOP_UNLOCK(vp, 0, ap->a_p);
	vp->v_type = VNON;
	return (0);
}

int
fdesc_reclaim(v)
	void *v;
{
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fdescnode *fd = VTOFDESC(vp);

	LIST_REMOVE(fd, fd_hash);
	FREE(vp->v_data, M_TEMP);
	vp->v_data = 0;

	return (0);
}

/*
 * Return POSIX pathconf information applicable to special devices.
 */
int
fdesc_pathconf(v)
	void *v;
{
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		return (0);
	case _PC_MAX_CANON:
		*ap->a_retval = MAX_CANON;
		return (0);
	case _PC_MAX_INPUT:
		*ap->a_retval = MAX_INPUT;
		return (0);
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
		return (0);
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		return (0);
	case _PC_VDISABLE:
		*ap->a_retval = _POSIX_VDISABLE;
		return (0);
	default:
		return (EINVAL);
	}
	/* NOTREACHED */
}

/*
 * Print out the contents of a /dev/fd vnode.
 */
/* ARGSUSED */
int
fdesc_print(v)
	void *v;
{
	printf("tag VT_NON, fdesc vnode\n");
	return (0);
}

int
fdesc_link(v) 
	void *v;
{
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;  
		struct componentname *a_cnp;
	} */ *ap = v;
 
	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

int
fdesc_symlink(v)
	void *v;
{
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
  
	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

/*
 * /dev/fd "should never get here" operation
 */
/*ARGSUSED*/
int
fdesc_badop(v)
	void *v;
{

	panic("fdesc: bad op");
	/* NOTREACHED */
}
@


1.38
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.37 2004/05/20 18:32:37 tedu Exp $	*/
@


1.37
log
@remove more caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.36 2003/09/23 16:51:12 millert Exp $	*/
d193 1
a193 1
	struct proc *p = curproc;       /* XXX */
d198 1
a198 1
	if ((error = lockmgr(&fdcache_lock, LK_EXCLUSIVE, NULL, p)) != 0)
d225 1
a225 1
	lockmgr(&fdcache_lock, LK_RELEASE, NULL, p);
@


1.36
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.35 2003/06/02 23:28:10 millert Exp $	*/
d445 1
a445 1
		bzero((caddr_t) vap, sizeof(*vap));
d661 1
a661 1
	bzero((caddr_t)&d, UIO_MX);
d690 1
a690 1
			if ((error = uiomove((caddr_t)&d, UIO_MX, uio)) != 0)
d716 1
a716 1
			if ((error = uiomove((caddr_t)&d, UIO_MX, uio)) != 0)
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.34 2003/05/06 21:43:26 deraadt Exp $	*/
d63 1
d101 1
a101 1
int	fdesc_select(void *);
d139 1
a139 1
	{ &vop_select_desc, fdesc_select },	/* select */
d829 1
a829 1
fdesc_select(v)
d832 1
a832 1
	struct vop_select_args /* {
d834 1
a834 3
		int  a_which;
		int  a_fflags;
		struct ucred *a_cred;
d837 1
a837 1
	int error = EOPNOTSUPP;
d841 1
a841 1
		error = cttyselect(devctty, ap->a_fflags, ap->a_p);
d845 1
a845 1
		error = EOPNOTSUPP;
d849 1
a849 1
	return (error);
@


1.34
log
@string cleaning; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.33 2003/01/31 17:37:50 art Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.33
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.32 2002/08/23 15:39:31 art Exp $	*/
d713 2
a714 1
				d.d_namlen = sprintf(d.d_name, "%d", i - 2);
@


1.32
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.31 2002/03/14 01:27:07 millert Exp $	*/
a256 1
	VOP_UNLOCK(dvp, 0, p);
a259 1
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d278 1
a278 2
			vn_lock(fvp, LK_SHARED | LK_RETRY, p);
			return (0);
d292 1
a292 2
			vn_lock(fvp, LK_SHARED | LK_RETRY, p);
			return (0);
d322 1
a322 2
			vn_lock(fvp, LK_SHARED | LK_RETRY, p);
			return (0);
d332 4
a335 1
			if ((error = fdesc_root(dvp->v_mount, vpp))) 
d337 7
a343 2

			return (0);
a366 1
		vn_lock(fvp, LK_SHARED | LK_RETRY, p);
d368 1
a368 1
		return (0);
d371 1
a371 2
bad:;
	vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d374 13
@


1.31
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.30 2002/02/13 19:08:06 art Exp $	*/
a572 1
	FREF(fp);
@


1.30
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.29 2002/02/12 18:41:21 art Exp $	*/
d91 1
a91 1
int	fdesc_badop	__P((void *));
d93 1
a93 1
int	fdesc_lookup	__P((void *));
d96 1
a96 1
int	fdesc_open	__P((void *));
d99 6
a104 6
int	fdesc_getattr	__P((void *));
int	fdesc_setattr	__P((void *));
int	fdesc_read	__P((void *));
int	fdesc_write	__P((void *));
int	fdesc_ioctl	__P((void *));
int	fdesc_select	__P((void *));
d108 1
a108 1
int	fdesc_link	__P((void *));
d112 5
a116 5
int	fdesc_symlink	__P((void *));
int	fdesc_readdir	__P((void *));
int	fdesc_readlink	__P((void *));
int	fdesc_inactive	__P((void *));
int	fdesc_reclaim	__P((void *));
d121 2
a122 2
int	fdesc_print	__P((void *));
int	fdesc_pathconf	__P((void *));
d127 1
a127 1
int (**fdesc_vnodeop_p) __P((void *));
d164 1
a164 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.29
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.28 2002/02/02 16:05:58 art Exp $	*/
d486 1
d488 1
@


1.28
log
@Be more consistent about using fd_getfile where it matters.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.27 2001/12/19 08:58:06 art Exp $	*/
d571 1
d573 4
a576 2
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		return (EROFS);
d580 4
a583 2
	if (vp->v_type == VDIR)
		return (EOPNOTSUPP);
d587 2
@


1.27
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.25 2001/11/06 19:53:20 miod Exp $	*/
d355 1
a355 1
		if (fd >= nfiles || p->p_fd->fd_ofiles[fd] == NULL) {
d661 1
a661 1
				if (fdp->fd_ofiles[ft->ft_fileno - FD_STDIN] == NULL)
d688 1
a688 1
				if (fdp->fd_ofiles[i - 2] == NULL)
@


1.26
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@a125 1
#define	fdesc_mmap	eopnotsupp
d164 1
a164 2
	{ &vop_mmap_desc, fdesc_mmap },
	{ NULL, NULL }
@


1.26.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.26 2001/12/04 22:44:31 art Exp $	*/
d91 1
a91 1
int	fdesc_badop(void *);
d93 1
a93 1
int	fdesc_lookup(void *);
d96 1
a96 1
int	fdesc_open(void *);
d99 6
a104 6
int	fdesc_getattr(void *);
int	fdesc_setattr(void *);
int	fdesc_read(void *);
int	fdesc_write(void *);
int	fdesc_ioctl(void *);
int	fdesc_select(void *);
d108 1
a108 1
int	fdesc_link(void *);
d112 5
a116 5
int	fdesc_symlink(void *);
int	fdesc_readdir(void *);
int	fdesc_readlink(void *);
int	fdesc_inactive(void *);
int	fdesc_reclaim(void *);
d121 2
a122 2
int	fdesc_print(void *);
int	fdesc_pathconf(void *);
d128 1
a128 1
int (**fdesc_vnodeop_p)(void *);
d357 1
a357 1
		if (fd_getfile(p->p_fd, fd) == NULL) {
a487 1
		FREF(fp);
a488 1
		FRELE(fp);
a572 1
	FREF(fp);
d574 2
a575 4
	if (vp->v_mount->mnt_flag & MNT_RDONLY) {
		error = EROFS;
		goto out;
	}
d579 2
a580 4
	if (vp->v_type == VDIR) {
		error = EOPNOTSUPP;
		goto out;
	}
a583 2
out:
	FRELE(fp);
d663 1
a663 1
				if (fd_getfile(fdp, ft->ft_fileno - FD_STDIN) == NULL)
d690 1
a690 1
				if (fd_getfile(fdp, i - 2) == NULL)
@


1.26.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.26.2.1 2002/06/11 03:30:20 art Exp $	*/
d575 1
@


1.26.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d259 1
d263 1
d282 2
a283 1
			goto good;
d297 2
a298 1
			goto good;
d328 2
a329 1
			goto good;
d339 1
a339 4
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
			error = fdesc_root(dvp->v_mount, vpp);
			if (error)
d341 2
a342 7
			/* If we're at the last component and need the
			 * parent locked, undo the unlock above.
			 */
			if (((~cnp->cn_flags & (ISLASTCN | LOCKPARENT)) == 0) &&
			    ((error = vn_lock(dvp, LK_EXCLUSIVE, p)) == 0))
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
d366 1
d368 1
a368 1
		goto good;
d371 2
a372 1
bad:
a374 13

good:
	/*
	 * As "." was special cased above, we now unlock the parent if we're
	 * supposed to. We're only supposed to not unlock if this is the
	 * last component, and the caller requested LOCKPARENT. So if either
	 * condition is false, unlock.
	 */
	if (((~cnp->cn_flags) & (ISLASTCN | LOCKPARENT)) != 0) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
	return (0);
d701 1
a701 2
				d.d_namlen = snprintf(d.d_name, sizeof d.d_name,
				    "%d", i - 2);
@


1.26.2.4
log
@convert to genfs_nolock.  genfs_lock for kern and procfs
@
text
@a68 1
#include <miscfs/genfs/genfs.h>
d117 2
a118 2
#define	fdesc_lock	genfs_nolock
#define	fdesc_unlock	genfs_nounlock
d123 1
a123 1
#define	fdesc_islocked	genfs_noislocked
@


1.25
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.24 2001/10/26 12:03:28 art Exp $	*/
d126 1
d165 2
a166 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.24
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.23 2001/06/23 02:14:24 csapuntz Exp $	*/
d70 1
a70 1
#include <vm/vm.h>
@


1.23
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.22 2001/05/23 14:34:30 art Exp $	*/
d483 1
a483 1
		if (fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
@


1.22
log
@Fix getattr and setattr.
 - getattr now uses fo_stat from fileops to obtain information about the fd
   and translates it back to vattr.
 - setattr now uses getvnode to the get vnode from the fd and obeys
   MNT_RDONLY flag.
 - Do proper locking on setattr.
 - Don't allow setattr on directories because of possible deadlocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.21 2001/05/15 07:49:45 art Exp $	*/
a104 1
#define	fdesc_mmap	eopnotsupp
a105 1
#define	fdesc_seek	nullop
a124 5
#define	fdesc_blkatoff	eopnotsupp
#define	fdesc_valloc	eopnotsupp
int	fdesc_vfree	__P((void *));
#define	fdesc_truncate	eopnotsupp
#define	fdesc_update	eopnotsupp
a142 1
	{ &vop_mmap_desc, fdesc_mmap },		/* mmap */
a143 1
	{ &vop_seek_desc, fdesc_seek },		/* seek */
a162 5
	{ &vop_blkatoff_desc, fdesc_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, fdesc_valloc },	/* valloc */
	{ &vop_vfree_desc, fdesc_vfree },	/* vfree */
	{ &vop_truncate_desc, fdesc_truncate },	/* truncate */
	{ &vop_update_desc, fdesc_update },	/* update */
a916 7
	return (0);
}

int
fdesc_vfree(v)
	void *v;
{
@


1.21
log
@LIST_FOREACH instead of manually doing the same thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.20 2001/05/15 07:26:28 art Exp $	*/
a133 2
static int fdesc_attr __P((int, struct vattr *, struct ucred *, struct proc *));

a424 81
static int
fdesc_attr(fd, vap, cred, p)
	int fd;
	struct vattr *vap;
	struct ucred *cred;
	struct proc *p;
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct stat stb;
	int error;

	if (fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
		return (EBADF);

	switch (fp->f_type) {
	case DTYPE_VNODE:
		error = VOP_GETATTR((struct vnode *) fp->f_data, vap, cred, p);
		if (error == 0 && vap->va_type == VDIR) {
			/*
			 * directories can cause loops in the namespace,
			 * so turn off the 'x' bits to avoid trouble.
			 */
			vap->va_mode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
		}
		break;

	case DTYPE_SOCKET:
		error = soo_stat(fp, &stb, p);
		if (error == 0) {
			vattr_null(vap);
			vap->va_type = VSOCK;
			vap->va_mode = stb.st_mode;
			vap->va_nlink = stb.st_nlink;
			vap->va_uid = stb.st_uid;
			vap->va_gid = stb.st_gid;
			vap->va_fsid = stb.st_dev;
			vap->va_fileid = stb.st_ino;
			vap->va_size = stb.st_size;
			vap->va_blocksize = stb.st_blksize;
			vap->va_atime = stb.st_atimespec;
			vap->va_mtime = stb.st_mtimespec;
			vap->va_ctime = stb.st_ctimespec;
			vap->va_gen = stb.st_gen;
			vap->va_flags = stb.st_flags;
			vap->va_rdev = stb.st_rdev;
			vap->va_bytes = stb.st_blocks * stb.st_blksize;
		}
		break;

	case DTYPE_PIPE:
		error = pipe_stat(fp, &stb, p);
		if (error == 0) {
			vattr_null(vap);
			vap->va_type = VFIFO;
			vap->va_mode = stb.st_mode;
			vap->va_nlink = stb.st_nlink;
			vap->va_uid = stb.st_uid;
			vap->va_gid = stb.st_gid;
			vap->va_fsid = stb.st_dev;
			vap->va_fileid = stb.st_ino;
			vap->va_size = stb.st_size;
			vap->va_blocksize = stb.st_blksize;
			vap->va_atime = stb.st_atimespec;
			vap->va_mtime = stb.st_mtimespec;
			vap->va_ctime = stb.st_ctimespec;
			vap->va_gen = stb.st_gen;
			vap->va_flags = stb.st_flags;
			vap->va_rdev = stb.st_rdev;
			vap->va_bytes = stb.st_blocks * stb.st_blksize;
		}
		break;

	default:
		panic("fdesc attr");
		break;
	}

	return (error);
}

d437 4
a440 1
	unsigned fd;
d496 30
a525 1
		error = fdesc_attr(fd, vap, ap->a_cred, ap->a_p);
a548 1
	struct filedesc *fdp = ap->a_p->p_fd;
d550 2
a552 1
	unsigned fd;
d571 13
a583 3
	fd = VTOFDESC(ap->a_vp)->fd_fd;
	if (fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL) {
		return (EBADF);
d585 3
a587 1

d589 1
a589 1
	 * Can setattr the underlying vnode, but not sockets!
d591 5
a595 18
	switch (fp->f_type) {
	case DTYPE_VNODE:
		error = VOP_SETATTR((struct vnode *) fp->f_data, ap->a_vap, ap->a_cred, ap->a_p);
		break;

	case DTYPE_PIPE:
	case DTYPE_SOCKET:
		if (vap->va_flags != VNOVAL)
			error = EOPNOTSUPP;
		else
			error = 0;
		break;

	default:
		panic("fdesc setattr");
		break;
	}

@


1.20
log
@Switch from homegrown locking of the hash to lockmgr.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.19 2001/05/14 13:43:54 art Exp $	*/
d222 1
a222 1
	for (fd = fc->lh_first; fd != 0; fd = fd->fd_hash.le_next) {
a229 1

@


1.19
log
@gc OLD_PIPE.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.18 2001/05/14 11:04:05 art Exp $	*/
d76 1
a76 3
#define FDL_WANT	0x01
#define FDL_LOCKED	0x02
static int fdcache_lock;
d89 1
a89 1
u_long fdhash;
d201 1
d217 3
d227 1
a227 1
			return (error);
a230 10
	/*
	 * otherwise lock the array while we call getnewvnode
	 * since that can block.
	 */ 
	if (fdcache_lock & FDL_LOCKED) {
		fdcache_lock |= FDL_WANT;
		sleep((caddr_t) &fdcache_lock, PINOD);
		goto loop;
	}
	fdcache_lock |= FDL_LOCKED;
d244 2
a245 7
out:;
	fdcache_lock &= ~FDL_LOCKED;

	if (fdcache_lock & FDL_WANT) {
		fdcache_lock &= ~FDL_WANT;
		wakeup((caddr_t) &fdcache_lock);
	}
@


1.18
log
@More generic arguments to soo_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.17 2001/05/14 10:51:27 art Exp $	*/
a491 3
#ifdef OLD_PIPE
		error = 0;
#else
a511 1
#endif
@


1.17
log
@More generic arguments to pipe_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.16 1999/10/13 06:32:23 art Exp $	*/
d469 1
a469 1
		error = soo_stat((struct socket *)fp->f_data, &stb);
@


1.16
log
@Don't try to call VOP_SETATTR on a pipe. From <cky@@pobox.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.15 1999/08/13 07:05:46 csapuntz Exp $	*/
d495 1
a495 1
		error = pipe_stat((struct pipe *)fp->f_data, &stb);
@


1.16.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.16 1999/10/13 06:32:23 art Exp $	*/
d76 3
a78 1
static struct lock fdcache_lock;
d91 1
a91 1
static u_long fdhash;
d107 1
d109 1
d129 5
d136 2
d154 1
d156 1
d176 5
a202 1
	lockinit(&fdcache_lock, PVFS, "fdfs", 0, 0);
a217 3
	if ((error = lockmgr(&fdcache_lock, LK_EXCLUSIVE, NULL, p)) != 0)
		return error;

d220 1
a220 1
	LIST_FOREACH(fd, fc, fd_hash) {
d225 1
a225 1
			goto out;
d229 11
d252 7
a258 2
out:
	lockmgr(&fdcache_lock, LK_RELEASE, NULL, p);
d441 85
d538 1
a538 4
	unsigned int fd;
	struct stat stb;
        struct filedesc *fdp;
	struct file *fp;
d594 1
a594 30
		fdp = ap->a_p->p_fd;
		if (fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
			return (EBADF);
		memset(&stb, 0, sizeof(stb));
		error = (*fp->f_ops->fo_stat)(fp, &stb, ap->a_p);
		if (error != 0)
			break;
		vattr_null(vap);
		vap->va_type = IFTOVT(stb.st_mode);
		vap->va_mode = stb.st_mode;
		/*
		 * directories can cause loops in the namespace,
		 * so turn off the 'x' bits to avoid trouble.
		 */
		if (vap->va_type == VDIR)
			vap->va_mode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
		vap->va_nlink = stb.st_nlink;
		vap->va_uid = stb.st_uid;
		vap->va_gid = stb.st_gid;
		vap->va_fsid = stb.st_dev;
		vap->va_fileid = stb.st_ino;
		vap->va_size = stb.st_size;
		vap->va_blocksize = stb.st_blksize;
		vap->va_atime = stb.st_atimespec;
		vap->va_mtime = stb.st_mtimespec;
		vap->va_ctime = stb.st_ctimespec;
		vap->va_gen = stb.st_gen;
		vap->va_flags = stb.st_flags;
		vap->va_rdev = stb.st_rdev;
		vap->va_bytes = stb.st_blocks * stb.st_blksize;
d618 1
a619 2
	struct proc *p = ap->a_p;
	struct vnode *vp;
d621 1
d640 5
a644 17
	if ((error = getvnode(p->p_fd, VTOFDESC(ap->a_vp)->fd_fd, &fp)) != 0) {
		/*
		 * getvnode returns EINVAL if the file is not a vnode.
		 * We siltently drop all changes except chflags when that
		 * happens.
		 */
		if (error == EINVAL) {
			if (vap->va_flags == VNOVAL)
				error = 0;
			else
				error = EOPNOTSUPP;
		}
		return (error);
	}
	vp = (struct vnode *)fp->f_data;
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		return (EROFS);
d646 1
a646 1
	 * Directories can cause deadlocks.
d648 18
a665 5
	if (vp->v_type == VDIR)
		return (EOPNOTSUPP);
	vn_lock(vp, LK_EXCLUSIVE|LK_RETRY, p);
	error = VOP_SETATTR(vp, vap, ap->a_cred, p);
	VOP_UNLOCK(vp, 0, p);
d1001 7
@


1.16.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.16.4.1 2001/07/04 10:49:06 niklas Exp $	*/
d483 1
a483 1
		if ((fp = fd_getfile(fdp, fd)) == NULL)
@


1.16.4.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
#include <uvm/uvm_extern.h>
@


1.16.4.4
log
@Merge in trunk
@
text
@d355 1
a355 1
		if (fd_getfile(p->p_fd, fd) == NULL) {
a485 1
		FREF(fp);
a486 1
		FRELE(fp);
a570 1
	FREF(fp);
d572 2
a573 4
	if (vp->v_mount->mnt_flag & MNT_RDONLY) {
		error = EROFS;
		goto out;
	}
d577 2
a578 4
	if (vp->v_type == VDIR) {
		error = EOPNOTSUPP;
		goto out;
	}
a581 2
out:
	FRELE(fp);
d661 1
a661 1
				if (fd_getfile(fdp, ft->ft_fileno - FD_STDIN) == NULL)
d688 1
a688 1
				if (fd_getfile(fdp, i - 2) == NULL)
@


1.16.4.5
log
@Merge in -current from roughly a week ago
@
text
@d91 1
a91 1
int	fdesc_badop(void *);
d93 1
a93 1
int	fdesc_lookup(void *);
d96 1
a96 1
int	fdesc_open(void *);
d99 6
a104 6
int	fdesc_getattr(void *);
int	fdesc_setattr(void *);
int	fdesc_read(void *);
int	fdesc_write(void *);
int	fdesc_ioctl(void *);
int	fdesc_select(void *);
d108 1
a108 1
int	fdesc_link(void *);
d112 5
a116 5
int	fdesc_symlink(void *);
int	fdesc_readdir(void *);
int	fdesc_readlink(void *);
int	fdesc_inactive(void *);
int	fdesc_reclaim(void *);
d121 2
a122 2
int	fdesc_print(void *);
int	fdesc_pathconf(void *);
d127 1
a127 1
int (**fdesc_vnodeop_p)(void *);
d164 1
a164 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.16.4.6
log
@Sync the SMP branch with 3.3
@
text
@d257 1
d261 1
d280 2
a281 1
			goto good;
d295 2
a296 1
			goto good;
d326 2
a327 1
			goto good;
d337 1
a337 4
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
			error = fdesc_root(dvp->v_mount, vpp);
			if (error)
d339 2
a340 7
			/* If we're at the last component and need the
			 * parent locked, undo the unlock above.
			 */
			if (((~cnp->cn_flags & (ISLASTCN | LOCKPARENT)) == 0) &&
			    ((error = vn_lock(dvp, LK_EXCLUSIVE, p)) == 0))
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
d364 1
d366 1
a366 1
		goto good;
d369 2
a370 1
bad:
a372 13

good:
	/*
	 * As "." was special cased above, we now unlock the parent if we're
	 * supposed to. We're only supposed to not unlock if this is the
	 * last component, and the caller requested LOCKPARENT. So if either
	 * condition is false, unlock.
	 */
	if (((~cnp->cn_flags) & (ISLASTCN | LOCKPARENT)) != 0) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
	return (0);
d573 1
@


1.16.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.16.4.6 2003/03/28 00:00:19 niklas Exp $	*/
d713 1
a713 2
				d.d_namlen = snprintf(d.d_name, sizeof d.d_name,
				    "%d", i - 2);
@


1.16.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.16.4.7 2003/05/13 19:21:29 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a62 1
#include <sys/poll.h>
d100 1
a100 1
int	fdesc_poll(void *);
d138 1
a138 1
	{ &vop_poll_desc, fdesc_poll },		/* poll */
d828 1
a828 1
fdesc_poll(v)
d831 1
a831 1
	struct vop_poll_args /* {
d833 3
a835 1
		int  a_events;
d838 1
a838 1
	int revents;
d842 1
a842 1
		revents = cttypoll(devctty, ap->a_events, ap->a_p);
d846 1
a846 1
		revents = ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM);
d850 1
a850 1
	return (revents);
@


1.16.4.10
log
@Merge with the trunk
@
text
@d445 1
a445 1
		bzero(vap, sizeof(*vap));
d661 1
a661 1
	bzero(&d, UIO_MX);
d690 1
a690 1
			if ((error = uiomove(&d, UIO_MX, uio)) != 0)
d716 1
a716 1
			if ((error = uiomove(&d, UIO_MX, uio)) != 0)
@


1.16.10.1
log
@Fix (art):
don't panic on kqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.16 1999/10/13 06:32:23 art Exp $	*/
d519 2
a520 1
		return (EOPNOTSUPP);
d653 2
a654 1
	default:
d659 4
@


1.15
log
@

Better fix for fdesc/procfs panic.
@
text
@d1 1
a1 1
/*	$OpenBSD:  $	*/
a648 1
	case DTYPE_PIPE:
d653 1
@


1.14
log
@in *_readdir(), constrain uio_offset to make sure it is right; cstone@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.13 1999/04/28 09:28:15 art Exp $	*/
d719 1
a719 1
	if (uio->uio_offset < 0 || uio->uio_offset % UIO_MX)
d724 2
a730 3

		if (nfdesc_targets <= uio->uio_offset/UIO_MX)
			return (EINVAL);
@


1.13
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.12 1998/08/06 19:34:32 csapuntz Exp $	*/
d719 1
a719 3
	if (uio->uio_resid < UIO_MX)
		return (EINVAL);
	if (uio->uio_offset < 0)
d729 3
@


1.12
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.11 1998/06/11 16:34:21 deraadt Exp $	*/
d202 1
a202 1
	fdhashtbl = hashinit(NFDCACHE, M_CACHE, &fdhash);
@


1.11
log
@return EOPNOTSUPP for chflags() changes; peter@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.10 1997/11/06 05:58:33 csapuntz Exp $	*/
d111 1
a111 1
#define fdesc_revoke    vop_revoke
a118 1
int	fdesc_abortop	__P((void *));
d121 2
a122 2
#define	fdesc_lock	vop_nolock
#define	fdesc_unlock	vop_nounlock
d127 1
a127 1
#define	fdesc_islocked	vop_noislocked
d165 1
a165 1
	{ &vop_abortop_desc, fdesc_abortop },	/* abortop */
a1040 14
}

int
fdesc_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;
 
	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
@


1.10
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.9 1997/10/06 21:04:43 deraadt Exp $	*/
d620 1
d633 2
d650 1
d656 4
a659 2
	case DTYPE_PIPE:
		error = 0;
@


1.9
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.7 1997/08/01 05:58:55 millert Exp $	*/
a93 1
int	fdesc_enotsupp	__P((void *));
d96 2
a97 2
#define	fdesc_create	fdesc_enotsupp
#define	fdesc_mknod	fdesc_enotsupp
d107 1
a107 1
#define	fdesc_mmap	fdesc_enotsupp
d110 2
a111 1
#define	fdesc_remove	fdesc_enotsupp
d113 3
a115 3
#define	fdesc_rename	fdesc_enotsupp
#define	fdesc_mkdir	fdesc_enotsupp
#define	fdesc_rmdir	fdesc_enotsupp
d122 2
a123 2
#define	fdesc_lock	nullop
#define	fdesc_unlock	nullop
d128 4
a131 4
#define	fdesc_islocked	nullop
#define	fdesc_advlock	fdesc_enotsupp
#define	fdesc_blkatoff	fdesc_enotsupp
#define	fdesc_valloc	fdesc_enotsupp
d133 3
a135 3
#define	fdesc_truncate	fdesc_enotsupp
#define	fdesc_update	fdesc_enotsupp
#define	fdesc_bwrite	fdesc_enotsupp
d153 1
d192 3
a194 2
void
fdesc_init()
d204 1
d214 1
d223 1
a223 1
			if (vget(fd->fd_vnode, 0))
d279 4
a282 3
	char *pname;
	struct proc *p;
	int nfiles;
d288 2
a289 2
	pname = ap->a_cnp->cn_nameptr;
	if (ap->a_cnp->cn_namelen == 1 && *pname == '.') {
d291 2
a292 2
		VREF(dvp);	
		VOP_LOCK(dvp);
a295 3
	p = ap->a_cnp->cn_proc;
	nfiles = p->p_fd->fd_nfiles;

d305 1
a305 1
		if (ap->a_cnp->cn_namelen == 2 && bcmp(pname, "fd", 2) == 0) {
d311 1
a311 1
			VOP_LOCK(fvp);
d315 1
a315 1
		if (ap->a_cnp->cn_namelen == 3 && bcmp(pname, "tty", 3) == 0) {
d326 1
a326 1
			VOP_LOCK(fvp);
d331 1
a331 1
		switch (ap->a_cnp->cn_namelen) {
d357 1
a357 1
			VOP_LOCK(fvp);
d367 5
a371 3
		if (ap->a_cnp->cn_namelen == 2 && bcmp(pname, "..", 2) == 0) {
			error = fdesc_root(dvp->v_mount, vpp);
			return (error);
d395 1
d401 1
d692 2
a693 2
		u_long *a_cookies;
		int a_ncookies;
a699 2
	u_long *cookies = ap->a_cookies;
	int ncookies = ap->a_ncookies;
a751 2
			if (ncookies-- > 0)
				*cookies++ = i + 1;
a776 2
			if (ncookies-- > 0)
				*cookies++ = i + 1;
d919 1
d927 1
a1049 12
}

/*
 * /dev/fd vnode unsupported operation
 */
/*ARGSUSED*/
int
fdesc_enotsupp(v)
	void *v;
{

	return (EOPNOTSUPP);
@


1.8
log
@VFS Lite2 Changes
@
text
@d94 1
d97 2
a98 2
#define	fdesc_create	eopnotsupp
#define	fdesc_mknod	eopnotsupp
d108 1
a108 1
#define	fdesc_mmap	eopnotsupp
d111 1
a111 2
#define	fdesc_remove	eopnotsupp
#define fdesc_revoke    vop_revoke
d113 3
a115 3
#define	fdesc_rename	eopnotsupp
#define	fdesc_mkdir	eopnotsupp
#define	fdesc_rmdir	eopnotsupp
d122 2
a123 2
#define	fdesc_lock	vop_nolock
#define	fdesc_unlock	vop_nounlock
d128 4
a131 4
#define	fdesc_islocked	vop_noislocked
#define	fdesc_advlock	eopnotsupp
#define	fdesc_blkatoff	eopnotsupp
#define	fdesc_valloc	eopnotsupp
d133 3
a135 3
#define	fdesc_truncate	eopnotsupp
#define	fdesc_update	eopnotsupp
#define	fdesc_bwrite	eopnotsupp
a152 1
	{ &vop_revoke_desc, fdesc_revoke },     /* revoke */
d191 2
a192 3
int
fdesc_init(vfsp)
	struct vfsconf *vfsp;
a201 1
	return (0);
a210 1
	struct proc *p = curproc;       /* XXX */
d219 1
a219 1
			if (vget(fd->fd_vnode, 0, p))
d275 3
a277 4
	struct componentname *cnp = ap->a_cnp;
	char *pname = cnp->cn_nameptr;
	struct proc *p = cnp->cn_proc;
	int nfiles = p->p_fd->fd_nfiles;
d283 2
a284 2
	VOP_UNLOCK(dvp, 0, p);
	if (cnp->cn_namelen == 1 && *pname == '.') {
d286 2
a287 2
		VREF(dvp);
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d291 3
d303 1
a303 1
		if (cnp->cn_namelen == 2 && bcmp(pname, "fd", 2) == 0) {
d309 1
a309 1
			vn_lock(fvp, LK_SHARED | LK_RETRY, p);
d313 1
a313 1
		if (cnp->cn_namelen == 3 && bcmp(pname, "tty", 3) == 0) {
d324 1
a324 1
			vn_lock(fvp, LK_SHARED | LK_RETRY, p);
d329 1
a329 1
		switch (cnp->cn_namelen) {
d355 1
a355 1
			vn_lock(fvp, LK_SHARED | LK_RETRY, p);
d365 3
a367 5
		if (cnp->cn_namelen == 2 && bcmp(pname, "..", 2) == 0) {
			if ((error = fdesc_root(dvp->v_mount, vpp))) 
				goto bad;

			return (0);
a390 1
		vn_lock(fvp, LK_SHARED | LK_RETRY, p);
a395 1
	vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d686 2
a687 2
		int *a_ncookies;
		u_long **a_cookies;
d694 2
d748 2
d775 2
a918 1
		struct proc *a_p;
a925 1
	VOP_UNLOCK(vp, 0, ap->a_p);
d1048 12
@


1.7
log
@From NetBSD (mycroft):
    Eliminate bogus uses of V{READ,WRITE,EXEC}.  Use S_I[RWX]{USR,GRP,OTH}
    where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.6 1996/09/26 11:52:35 deraadt Exp $	*/
a93 1
int	fdesc_enotsupp	__P((void *));
d96 2
a97 2
#define	fdesc_create	fdesc_enotsupp
#define	fdesc_mknod	fdesc_enotsupp
d107 1
a107 1
#define	fdesc_mmap	fdesc_enotsupp
d110 2
a111 1
#define	fdesc_remove	fdesc_enotsupp
d113 3
a115 3
#define	fdesc_rename	fdesc_enotsupp
#define	fdesc_mkdir	fdesc_enotsupp
#define	fdesc_rmdir	fdesc_enotsupp
d122 2
a123 2
#define	fdesc_lock	nullop
#define	fdesc_unlock	nullop
d128 4
a131 4
#define	fdesc_islocked	nullop
#define	fdesc_advlock	fdesc_enotsupp
#define	fdesc_blkatoff	fdesc_enotsupp
#define	fdesc_valloc	fdesc_enotsupp
d133 3
a135 3
#define	fdesc_truncate	fdesc_enotsupp
#define	fdesc_update	fdesc_enotsupp
#define	fdesc_bwrite	fdesc_enotsupp
d153 1
d192 3
a194 2
void
fdesc_init()
d204 1
d214 1
d223 1
a223 1
			if (vget(fd->fd_vnode, 0))
d279 4
a282 3
	char *pname;
	struct proc *p;
	int nfiles;
d288 2
a289 2
	pname = ap->a_cnp->cn_nameptr;
	if (ap->a_cnp->cn_namelen == 1 && *pname == '.') {
d291 2
a292 2
		VREF(dvp);	
		VOP_LOCK(dvp);
a295 3
	p = ap->a_cnp->cn_proc;
	nfiles = p->p_fd->fd_nfiles;

d305 1
a305 1
		if (ap->a_cnp->cn_namelen == 2 && bcmp(pname, "fd", 2) == 0) {
d311 1
a311 1
			VOP_LOCK(fvp);
d315 1
a315 1
		if (ap->a_cnp->cn_namelen == 3 && bcmp(pname, "tty", 3) == 0) {
d326 1
a326 1
			VOP_LOCK(fvp);
d331 1
a331 1
		switch (ap->a_cnp->cn_namelen) {
d357 1
a357 1
			VOP_LOCK(fvp);
d367 5
a371 3
		if (ap->a_cnp->cn_namelen == 2 && bcmp(pname, "..", 2) == 0) {
			error = fdesc_root(dvp->v_mount, vpp);
			return (error);
d395 1
d401 1
d692 2
a693 2
		u_long *a_cookies;
		int a_ncookies;
a699 2
	u_long *cookies = ap->a_cookies;
	int ncookies = ap->a_ncookies;
a751 2
			if (ncookies-- > 0)
				*cookies++ = i + 1;
a776 2
			if (ncookies-- > 0)
				*cookies++ = i + 1;
d919 1
d927 1
a1049 12
}

/*
 * /dev/fd vnode unsupported operation
 */
/*ARGSUSED*/
int
fdesc_enotsupp(v)
	void *v;
{

	return (EOPNOTSUPP);
@


1.6
log
@still handle OLD_PIPE case
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.5 1996/09/10 16:44:22 niklas Exp $	*/
d459 1
a459 1
			vap->va_mode &= ~((VEXEC)|(VEXEC>>3)|(VEXEC>>6));
@


1.5
log
@Bring pipe_stat prototype in scope
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.4 1996/09/07 18:11:18 tholo Exp $	*/
d487 3
d510 1
@


1.4
log
@Understand DTYPE_PIPE
@
text
@d1 1
a1 1
/*	$OpenBSD: fdesc_vnops.c,v 1.2 1996/02/27 07:51:41 niklas Exp $	*/
d67 1
d69 4
@


1.3
log
@fix a bug w/ fd/tty file (from netbsd).
@
text
@d481 23
d637 1
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: fdesc_vnops.c,v 1.31 1996/02/13 13:12:52 mycroft Exp $	*/
d59 1
d189 1
d191 5
a195 1
	devctty = makedev(nchrdev, 0);
d318 1
a318 1
			fvp->v_type = VFIFO;
d521 1
d528 2
a529 1
			vap->va_type = VFIFO;
d537 1
a551 1
		vap->va_rdev = 0;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: fdesc_vnops.c,v 1.27 1995/10/09 14:20:04 mycroft Exp $	*/
d55 1
d65 1
d87 95
d185 1
d254 3
a256 1
fdesc_lookup(ap)
d261 1
a261 2
	} */ *ap;
{
d267 1
a267 1
	unsigned fd;
d390 3
a392 1
fdesc_open(ap)
d398 1
a398 2
	} */ *ap;
{
d416 4
d484 3
a486 1
fdesc_getattr(ap)
d492 1
a492 2
	} */ *ap;
{
d507 4
d513 1
a513 1
			vap->va_mode = S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
d520 1
a520 1
			vap->va_mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;
d527 1
a527 1
			vap->va_mode = S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
d537 2
a538 2
		vap->va_atime.ts_sec = boottime.tv_sec;
		vap->va_atime.ts_nsec = 0;
d564 3
a566 1
fdesc_setattr(ap)
d572 1
a572 2
	} */ *ap;
{
d637 3
a639 1
fdesc_readdir(ap)
d647 1
a647 2
	} */ *ap;
{
d662 3
d705 1
a705 1
			if (error = uiomove((caddr_t)&d, UIO_MX, uio))
d732 1
a732 1
			if (error = uiomove((caddr_t)&d, UIO_MX, uio))
d744 3
a746 1
fdesc_readlink(ap)
d751 1
a751 2
	} */ *ap;
{
d769 3
a771 1
fdesc_read(ap)
d777 1
a777 2
	} */ *ap;
{
d794 3
a796 1
fdesc_write(ap)
d802 1
a802 2
	} */ *ap;
{
d819 3
a821 1
fdesc_ioctl(ap)
d829 1
a829 2
	} */ *ap;
{
d835 1
a835 1
					ap->a_fflag, ap->a_p);
d847 3
a849 1
fdesc_select(ap)
d856 1
a856 2
	} */ *ap;
{
d873 3
a875 1
fdesc_inactive(ap)
d878 1
a878 2
	} */ *ap;
{
d890 3
a892 1
fdesc_reclaim(ap)
d895 1
a895 2
	} */ *ap;
{
d909 4
a912 1
fdesc_pathconf(ap)
d917 1
a917 2
	} */ *ap;
{
d949 2
a950 4
fdesc_print(ap)
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap;
d952 3
d956 4
a959 1
	printf("tag VT_NON, fdesc vnode\n");
a962 1
/*void*/
d964 2
a965 6
fdesc_vfree(ap)
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap;
d967 10
d978 28
d1012 1
d1014 2
a1015 1
fdesc_enotsupp()
d1024 1
d1026 2
a1027 1
fdesc_badop()
a1032 91

/*
 * /dev/fd vnode null operation
 */
int
fdesc_nullop()
{

	return (0);
}

#define fdesc_create ((int (*) __P((struct  vop_create_args *)))fdesc_enotsupp)
#define fdesc_mknod ((int (*) __P((struct  vop_mknod_args *)))fdesc_enotsupp)
#define fdesc_close ((int (*) __P((struct  vop_close_args *)))nullop)
#define fdesc_access ((int (*) __P((struct  vop_access_args *)))nullop)
#define fdesc_mmap ((int (*) __P((struct  vop_mmap_args *)))fdesc_enotsupp)
#define fdesc_fsync ((int (*) __P((struct  vop_fsync_args *)))nullop)
#define fdesc_seek ((int (*) __P((struct  vop_seek_args *)))nullop)
#define fdesc_remove ((int (*) __P((struct  vop_remove_args *)))fdesc_enotsupp)
#define fdesc_link ((int (*) __P((struct  vop_link_args *)))fdesc_enotsupp)
#define fdesc_rename ((int (*) __P((struct  vop_rename_args *)))fdesc_enotsupp)
#define fdesc_mkdir ((int (*) __P((struct  vop_mkdir_args *)))fdesc_enotsupp)
#define fdesc_rmdir ((int (*) __P((struct  vop_rmdir_args *)))fdesc_enotsupp)
#define fdesc_symlink ((int (*) __P((struct vop_symlink_args *)))fdesc_enotsupp)
#define fdesc_abortop ((int (*) __P((struct  vop_abortop_args *)))nullop)
#define fdesc_lock ((int (*) __P((struct  vop_lock_args *)))nullop)
#define fdesc_unlock ((int (*) __P((struct  vop_unlock_args *)))nullop)
#define fdesc_bmap ((int (*) __P((struct  vop_bmap_args *)))fdesc_badop)
#define fdesc_strategy ((int (*) __P((struct  vop_strategy_args *)))fdesc_badop)
#define fdesc_islocked ((int (*) __P((struct  vop_islocked_args *)))nullop)
#define fdesc_advlock ((int (*) __P((struct vop_advlock_args *)))fdesc_enotsupp)
#define fdesc_blkatoff \
	((int (*) __P((struct  vop_blkatoff_args *)))fdesc_enotsupp)
#define fdesc_vget ((int (*) __P((struct  vop_vget_args *)))fdesc_enotsupp)
#define fdesc_valloc ((int(*) __P(( \
		struct vnode *pvp, \
		int mode, \
		struct ucred *cred, \
		struct vnode **vpp))) fdesc_enotsupp)
#define fdesc_truncate \
	((int (*) __P((struct  vop_truncate_args *)))fdesc_enotsupp)
#define fdesc_update ((int (*) __P((struct  vop_update_args *)))fdesc_enotsupp)
#define fdesc_bwrite ((int (*) __P((struct  vop_bwrite_args *)))fdesc_enotsupp)

int (**fdesc_vnodeop_p)();
struct vnodeopv_entry_desc fdesc_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, fdesc_lookup },	/* lookup */
	{ &vop_create_desc, fdesc_create },	/* create */
	{ &vop_mknod_desc, fdesc_mknod },	/* mknod */
	{ &vop_open_desc, fdesc_open },		/* open */
	{ &vop_close_desc, fdesc_close },	/* close */
	{ &vop_access_desc, fdesc_access },	/* access */
	{ &vop_getattr_desc, fdesc_getattr },	/* getattr */
	{ &vop_setattr_desc, fdesc_setattr },	/* setattr */
	{ &vop_read_desc, fdesc_read },		/* read */
	{ &vop_write_desc, fdesc_write },	/* write */
	{ &vop_ioctl_desc, fdesc_ioctl },	/* ioctl */
	{ &vop_select_desc, fdesc_select },	/* select */
	{ &vop_mmap_desc, fdesc_mmap },		/* mmap */
	{ &vop_fsync_desc, fdesc_fsync },	/* fsync */
	{ &vop_seek_desc, fdesc_seek },		/* seek */
	{ &vop_remove_desc, fdesc_remove },	/* remove */
	{ &vop_link_desc, fdesc_link },		/* link */
	{ &vop_rename_desc, fdesc_rename },	/* rename */
	{ &vop_mkdir_desc, fdesc_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, fdesc_rmdir },	/* rmdir */
	{ &vop_symlink_desc, fdesc_symlink },	/* symlink */
	{ &vop_readdir_desc, fdesc_readdir },	/* readdir */
	{ &vop_readlink_desc, fdesc_readlink },	/* readlink */
	{ &vop_abortop_desc, fdesc_abortop },	/* abortop */
	{ &vop_inactive_desc, fdesc_inactive },	/* inactive */
	{ &vop_reclaim_desc, fdesc_reclaim },	/* reclaim */
	{ &vop_lock_desc, fdesc_lock },		/* lock */
	{ &vop_unlock_desc, fdesc_unlock },	/* unlock */
	{ &vop_bmap_desc, fdesc_bmap },		/* bmap */
	{ &vop_strategy_desc, fdesc_strategy },	/* strategy */
	{ &vop_print_desc, fdesc_print },	/* print */
	{ &vop_islocked_desc, fdesc_islocked },	/* islocked */
	{ &vop_pathconf_desc, fdesc_pathconf },	/* pathconf */
	{ &vop_advlock_desc, fdesc_advlock },	/* advlock */
	{ &vop_blkatoff_desc, fdesc_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, fdesc_valloc },	/* valloc */
	{ &vop_vfree_desc, fdesc_vfree },	/* vfree */
	{ &vop_truncate_desc, fdesc_truncate },	/* truncate */
	{ &vop_update_desc, fdesc_update },	/* update */
	{ &vop_bwrite_desc, fdesc_bwrite },	/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
};
struct vnodeopv_desc fdesc_vnodeop_opv_desc =
	{ &fdesc_vnodeop_p, fdesc_vnodeop_entries };
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
