head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.6
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.16
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.14
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.10
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.15.0.14
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.12
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.10
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.8
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.13
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.12
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.28;
commitid	p4LJxGKbi0BU2cG6;

1.28
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.27;
commitid	P6Av4XGqOi3rFasL;

1.27
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.26;
commitid	uzzBR7hz9ncd4O6G;

1.26
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.13.15.00.13;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.12.16.01.42;	author thib;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.27.13.59.12;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.08.16.37.10;	author pedro;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.28.10;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.08.18.43.34;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.24.13.41.27;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.07;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.04.22.44.31;	author art;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.06.23.02.14.23;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	98.11.13.00.31.25;	author art;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	98.08.06.19.34.30;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.58.31;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.20.20.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.18.59;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.49.43;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.59;	author deraadt;	state Exp;
branches;
next	;

1.7.6.1
date	2001.07.04.10.49.04;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	1.7.6.4;

1.7.6.4
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.7.6.5;

1.7.6.5
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.05.20.04.05.38;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: dead_vnops.c,v 1.28 2014/12/16 18:30:04 tedu Exp $	*/
/*	$NetBSD: dead_vnops.c,v 1.16 1996/02/13 13:12:48 mycroft Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)dead_vnops.c	8.2 (Berkeley) 11/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/errno.h>
#include <sys/buf.h>
#include <sys/poll.h>

/*
 * Prototypes for dead operations on vnodes.
 */
int	dead_badop(void *);
int	dead_ebadf(void *);

int	dead_open(void *);
int	dead_read(void *);
int	dead_write(void *);
int	dead_ioctl(void *);
int	dead_poll(void *);
int	dead_lock(void *);
int	dead_bmap(void *);
int	dead_strategy(void *);
int	dead_print(void *);

int	chkvnlock(struct vnode *);

struct vops dead_vops = {
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= dead_badop,
	.vop_mknod	= dead_badop,
	.vop_open	= dead_open,
	.vop_close	= nullop,
	.vop_access	= dead_ebadf,
	.vop_getattr	= dead_ebadf,
	.vop_setattr	= dead_ebadf,
	.vop_read	= dead_read,
	.vop_write	= dead_write,
	.vop_ioctl	= dead_ioctl,
	.vop_poll	= dead_poll,
	.vop_fsync	= nullop,
	.vop_remove	= dead_badop,
	.vop_link	= dead_badop,
	.vop_rename	= dead_badop,
	.vop_mkdir	= dead_badop,
	.vop_rmdir	= dead_badop,
	.vop_symlink	= dead_badop,
	.vop_readdir	= dead_ebadf,
	.vop_readlink	= dead_ebadf,
	.vop_abortop	= dead_badop,
	.vop_inactive	= nullop,
	.vop_reclaim	= nullop,
	.vop_lock	= dead_lock,
	.vop_unlock	= vop_generic_unlock,
	.vop_bmap	= dead_bmap,
	.vop_strategy	= dead_strategy,
	.vop_print	= dead_print,
	.vop_islocked	= vop_generic_islocked,
	.vop_pathconf	= dead_ebadf,
	.vop_advlock	= dead_ebadf,
	.vop_bwrite	= nullop,
};

/*
 * Open always fails as if device did not exist.
 */
/* ARGSUSED */
int
dead_open(void *v)
{
	return (ENXIO);
}

/*
 * Vnode op for read
 */
/* ARGSUSED */
int
dead_read(void *v)
{
	struct vop_read_args *ap = v;

	if (chkvnlock(ap->a_vp))
		panic("dead_read: lock");
	/*
	 * Return EOF for tty devices, EIO for others
	 */
	if ((ap->a_vp->v_flag & VISTTY) == 0)
		return (EIO);
	return (0);
}

/*
 * Vnode op for write
 */
/* ARGSUSED */
int
dead_write(void *v)
{
	struct vop_write_args *ap = v;

	if (chkvnlock(ap->a_vp))
		panic("dead_write: lock");
	return (EIO);
}

/*
 * Device ioctl operation.
 */
/* ARGSUSED */
int
dead_ioctl(void *v)
{
	struct vop_ioctl_args *ap = v;

	if (!chkvnlock(ap->a_vp))
		return (EBADF);
	return ((ap->a_vp->v_op->vop_ioctl)(ap));
}

/* ARGSUSED */
int
dead_poll(void *v)
{
#if 0
	struct vop_poll_args *ap = v;
#endif

	/*
	 * Let the user find out that the descriptor is gone.
	 */
	return (POLLHUP);
}

/*
 * Just call the device strategy routine
 */
int
dead_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	int s;

	if (ap->a_bp->b_vp == NULL || !chkvnlock(ap->a_bp->b_vp)) {
		ap->a_bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(ap->a_bp);
		splx(s);
		return (EIO);
	}
	return (VOP_STRATEGY(ap->a_bp));
}

/*
 * Wait until the vnode has finished changing state.
 */
int
dead_lock(void *v)
{
	struct vop_lock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	if (ap->a_flags & LK_DRAIN || !chkvnlock(vp))
		return (0);

	return ((vp->v_op->vop_lock)(ap));
}

/*
 * Wait until the vnode has finished changing state.
 */
int
dead_bmap(void *v)
{
	struct vop_bmap_args *ap = v;

	if (!chkvnlock(ap->a_vp))
		return (EIO);
	return (VOP_BMAP(ap->a_vp, ap->a_bn, ap->a_vpp, ap->a_bnp, ap->a_runp));
}

/*
 * Print out the contents of a dead vnode.
 */
/* ARGSUSED */
int
dead_print(void *v)
{
	printf("tag VT_NON, dead vnode\n");
	return 0;
}

/*
 * Empty vnode failed operation
 */
/*ARGSUSED*/
int
dead_ebadf(void *v)
{
	return (EBADF);
}

/*
 * Empty vnode bad operation
 */
/*ARGSUSED*/
int
dead_badop(void *v)
{
	panic("dead_badop called");
	/* NOTREACHED */
}

/*
 * We have to wait during times when the vnode is
 * in a state of change.
 */
int
chkvnlock(struct vnode *vp)
{
	int locked = 0;

	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		tsleep(vp, PINOD, "chkvnlock", 0);
		locked = 1;
	}
	return (locked);
}
@


1.28
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.27 2014/09/14 14:17:26 jsg Exp $	*/
a40 1
#include <sys/namei.h>
@


1.27
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.26 2011/04/05 14:14:07 thib Exp $	*/
d39 1
@


1.26
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.25 2010/12/21 20:14:43 thib Exp $	*/
a41 1
#include <sys/proc.h>
@


1.25
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.24 2010/09/10 16:34:08 thib Exp $	*/
a63 1
	.vop_default	= eopnotsupp,
@


1.24
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.23 2010/09/06 23:44:10 thib Exp $	*/
d63 35
a97 38
int (**dead_vnodeop_p)(void *);

struct vnodeopv_entry_desc dead_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, vop_generic_lookup },
	{ &vop_create_desc, dead_badop },
	{ &vop_mknod_desc, dead_badop },
	{ &vop_open_desc, dead_open },
	{ &vop_close_desc, nullop },
	{ &vop_access_desc, dead_ebadf },
	{ &vop_getattr_desc, dead_ebadf },
	{ &vop_setattr_desc, dead_ebadf },
	{ &vop_read_desc, dead_read },
	{ &vop_write_desc, dead_write },
	{ &vop_ioctl_desc, dead_ioctl },
	{ &vop_poll_desc, dead_poll },
	{ &vop_fsync_desc, nullop },
	{ &vop_remove_desc, dead_badop },
	{ &vop_link_desc, dead_badop },
	{ &vop_rename_desc, dead_badop },
	{ &vop_mkdir_desc, dead_badop },
	{ &vop_rmdir_desc, dead_badop },
	{ &vop_symlink_desc, dead_badop },
	{ &vop_readdir_desc, dead_ebadf },
	{ &vop_readlink_desc, dead_ebadf },
	{ &vop_abortop_desc, dead_badop },
	{ &vop_inactive_desc, nullop },
	{ &vop_reclaim_desc, nullop },
	{ &vop_lock_desc, dead_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, dead_bmap },
	{ &vop_strategy_desc, dead_strategy },
	{ &vop_print_desc, dead_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, dead_ebadf },
	{ &vop_advlock_desc, dead_ebadf },
	{ &vop_bwrite_desc, nullop },
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
a98 2
struct vnodeopv_desc dead_vnodeop_opv_desc =
	{ &dead_vnodeop_p, dead_vnodeop_entries };
d154 1
a154 1
	return (VCALL(ap->a_vp, VOFFSET(vop_ioctl), ap));
d202 1
a202 1
	return (VCALL(vp, VOFFSET(vop_lock), ap));
@


1.23
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.22 2009/08/13 15:00:13 jasper Exp $	*/
d63 38
a100 35
struct vops dead_vops = {
	.vop_default	= eopnotsupp,
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= dead_badop,
	.vop_mknod	= dead_badop,
	.vop_open	= dead_open,
	.vop_close	= nullop,
	.vop_access	= dead_ebadf,
	.vop_getattr	= dead_ebadf,
	.vop_setattr	= dead_ebadf,
	.vop_read	= dead_read,
	.vop_write	= dead_write,
	.vop_ioctl	= dead_ioctl,
	.vop_poll	= dead_poll,
	.vop_fsync	= nullop,
	.vop_remove	= dead_badop,
	.vop_link	= dead_badop,
	.vop_rename	= dead_badop,
	.vop_mkdir	= dead_badop,
	.vop_rmdir	= dead_badop,
	.vop_symlink	= dead_badop,
	.vop_readdir	= dead_ebadf,
	.vop_readlink	= dead_ebadf,
	.vop_abortop	= dead_badop,
	.vop_inactive	= nullop,
	.vop_reclaim	= nullop,
	.vop_lock	= dead_lock,
	.vop_unlock	= vop_generic_unlock,
	.vop_bmap	= dead_bmap,
	.vop_strategy	= dead_strategy,
	.vop_print	= dead_print,
	.vop_islocked	= vop_generic_islocked,
	.vop_pathconf	= dead_ebadf,
	.vop_advlock	= dead_ebadf,
	.vop_bwrite	= nullop,
d102 2
d159 1
a159 1
	return ((ap->a_vp->v_op->vop_ioctl)(ap));
d207 1
a207 1
	return ((vp->v_op->vop_lock)(ap));
@


1.22
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.21 2008/05/08 17:45:45 thib Exp $	*/
d63 35
a97 38
int (**dead_vnodeop_p)(void *);

struct vnodeopv_entry_desc dead_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, vop_generic_lookup },
	{ &vop_create_desc, dead_badop },
	{ &vop_mknod_desc, dead_badop },
	{ &vop_open_desc, dead_open },
	{ &vop_close_desc, nullop },
	{ &vop_access_desc, dead_ebadf },
	{ &vop_getattr_desc, dead_ebadf },
	{ &vop_setattr_desc, dead_ebadf },
	{ &vop_read_desc, dead_read },
	{ &vop_write_desc, dead_write },
	{ &vop_ioctl_desc, dead_ioctl },
	{ &vop_poll_desc, dead_poll },
	{ &vop_fsync_desc, nullop },
	{ &vop_remove_desc, dead_badop },
	{ &vop_link_desc, dead_badop },
	{ &vop_rename_desc, dead_badop },
	{ &vop_mkdir_desc, dead_badop },
	{ &vop_rmdir_desc, dead_badop },
	{ &vop_symlink_desc, dead_badop },
	{ &vop_readdir_desc, dead_ebadf },
	{ &vop_readlink_desc, dead_ebadf },
	{ &vop_abortop_desc, dead_badop },
	{ &vop_inactive_desc, nullop },
	{ &vop_reclaim_desc, nullop },
	{ &vop_lock_desc, dead_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, dead_bmap },
	{ &vop_strategy_desc, dead_strategy },
	{ &vop_print_desc, dead_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, dead_ebadf },
	{ &vop_advlock_desc, dead_ebadf },
	{ &vop_bwrite_desc, nullop },
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
a98 2
struct vnodeopv_desc dead_vnodeop_opv_desc =
	{ &dead_vnodeop_p, dead_vnodeop_entries };
d154 1
a154 1
	return (VCALL(ap->a_vp, VOFFSET(vop_ioctl), ap));
d202 1
a202 1
	return (VCALL(vp, VOFFSET(vop_lock), ap));
@


1.21
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.20 2008/04/12 16:01:42 thib Exp $	*/
d67 33
a99 33
	{ &vop_lookup_desc, vop_generic_lookup },	/* lookup */
	{ &vop_create_desc, dead_badop },	/* create */
	{ &vop_mknod_desc, dead_badop },	/* mknod */
	{ &vop_open_desc, dead_open },		/* open */
	{ &vop_close_desc, nullop },		/* close */
	{ &vop_access_desc, dead_ebadf },	/* access */
	{ &vop_getattr_desc, dead_ebadf },	/* getattr */
	{ &vop_setattr_desc, dead_ebadf },	/* setattr */
	{ &vop_read_desc, dead_read },		/* read */
	{ &vop_write_desc, dead_write },	/* write */
	{ &vop_ioctl_desc, dead_ioctl },	/* ioctl */
	{ &vop_poll_desc, dead_poll },		/* poll */
	{ &vop_fsync_desc, nullop },		/* fsync */
	{ &vop_remove_desc, dead_badop },	/* remove */
	{ &vop_link_desc, dead_badop },		/* link */
	{ &vop_rename_desc, dead_badop },	/* rename */
	{ &vop_mkdir_desc, dead_badop },	/* mkdir */
	{ &vop_rmdir_desc, dead_badop },	/* rmdir */
	{ &vop_symlink_desc, dead_badop },	/* symlink */
	{ &vop_readdir_desc, dead_ebadf },	/* readdir */
	{ &vop_readlink_desc, dead_ebadf },	/* readlink */
	{ &vop_abortop_desc, dead_badop },	/* abortop */
	{ &vop_inactive_desc, nullop },		/* inactive */
	{ &vop_reclaim_desc, nullop },		/* reclaim */
	{ &vop_lock_desc, dead_lock },		/* lock */
	{ &vop_unlock_desc, vop_generic_unlock },	/* unlock */
	{ &vop_bmap_desc, dead_bmap },		/* bmap */
	{ &vop_strategy_desc, dead_strategy },	/* strategy */
	{ &vop_print_desc, dead_print },	/* print */
	{ &vop_islocked_desc, vop_generic_islocked },	/* islocked */
	{ &vop_pathconf_desc, dead_ebadf },	/* pathconf */
	{ &vop_advlock_desc, dead_ebadf },	/* advlock */
	{ &vop_bwrite_desc, nullop },		/* bwrite */
@


1.20
log
@remove useless defines for the vnode operations, and instead
init the op array functions with whatever the define was set
too.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.19 2007/12/27 13:59:12 thib Exp $	*/
d66 1
a66 1
	{ &vop_default_desc, vn_default_error },
@


1.19
log
@fifofs, deadfs and specfs all have the same "trivial lookup routine that
always fails". Introduce vop_generic_lookup(), which is a trivial lookup
routine that always fails and use that instead, zap the redundant copies.

ok toby@@, tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.18 2007/06/01 23:47:57 deraadt Exp $	*/
a50 2
#define dead_create	dead_badop
#define dead_mknod	dead_badop
a51 4
#define dead_close	nullop
#define dead_access	dead_ebadf
#define dead_getattr	dead_ebadf
#define dead_setattr	dead_ebadf
a55 12
#define dead_fsync	nullop
#define dead_remove	dead_badop
#define dead_link	dead_badop
#define dead_rename	dead_badop
#define dead_mkdir	dead_badop
#define dead_rmdir	dead_badop
#define dead_symlink	dead_badop
#define dead_readdir	dead_ebadf
#define dead_readlink	dead_ebadf
#define dead_abortop	dead_badop
#define dead_inactive	nullop
#define dead_reclaim	nullop
a56 1
#define dead_unlock	vop_generic_unlock
a59 4
#define dead_islocked	vop_generic_islocked
#define dead_pathconf	dead_ebadf
#define dead_advlock	dead_ebadf
#define dead_bwrite	nullop
d68 2
a69 2
	{ &vop_create_desc, dead_create },	/* create */
	{ &vop_mknod_desc, dead_mknod },	/* mknod */
d71 4
a74 4
	{ &vop_close_desc, dead_close },	/* close */
	{ &vop_access_desc, dead_access },	/* access */
	{ &vop_getattr_desc, dead_getattr },	/* getattr */
	{ &vop_setattr_desc, dead_setattr },	/* setattr */
d79 12
a90 12
	{ &vop_fsync_desc, dead_fsync },	/* fsync */
	{ &vop_remove_desc, dead_remove },	/* remove */
	{ &vop_link_desc, dead_link },		/* link */
	{ &vop_rename_desc, dead_rename },	/* rename */
	{ &vop_mkdir_desc, dead_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, dead_rmdir },	/* rmdir */
	{ &vop_symlink_desc, dead_symlink },	/* symlink */
	{ &vop_readdir_desc, dead_readdir },	/* readdir */
	{ &vop_readlink_desc, dead_readlink },	/* readlink */
	{ &vop_abortop_desc, dead_abortop },	/* abortop */
	{ &vop_inactive_desc, dead_inactive },	/* inactive */
	{ &vop_reclaim_desc, dead_reclaim },	/* reclaim */
d92 1
a92 1
	{ &vop_unlock_desc, dead_unlock },	/* unlock */
d96 4
a99 4
	{ &vop_islocked_desc, dead_islocked },	/* islocked */
	{ &vop_pathconf_desc, dead_pathconf },	/* pathconf */
	{ &vop_advlock_desc, dead_advlock },	/* advlock */
	{ &vop_bwrite_desc, dead_bwrite },	/* bwrite */
@


1.18
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.17 2007/04/08 16:37:10 pedro Exp $	*/
a50 1
int	dead_lookup(void *);
d90 1
a90 1
	{ &vop_lookup_desc, dead_lookup },	/* lookup */
a126 13

/*
 * Trivial lookup routine that always fails.
 */
/* ARGSUSED */
int
dead_lookup(void *v)
{
	struct vop_lookup_args *ap = v;

	*ap->a_vpp = NULL;
	return (ENOTDIR);
}
@


1.17
log
@ansify and deregister, no binary change, okay mickey@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.16 2007/03/21 17:29:32 thib Exp $	*/
d136 1
a136 5
	struct vop_lookup_args /* {
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
d159 1
a159 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d178 1
a178 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d192 1
a192 8
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d204 1
a204 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;
		struct proc *a_p;
	} */ *ap = v;
d219 1
a219 3
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
d238 1
a238 5
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
d253 1
a253 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
@


1.16
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.15 2003/09/23 16:51:12 millert Exp $	*/
d134 1
a134 2
dead_lookup(v)
	void *v;
d151 1
a151 2
dead_open(v)
	void *v;
a152 1

d161 1
a161 2
dead_read(v)
	void *v;
d185 1
a185 2
dead_write(v)
	void *v;
d204 1
a204 2
dead_ioctl(v)
	void *v;
d222 1
a222 2
dead_poll(v)
	void *v;
d242 1
a242 2
dead_strategy(v)
	void *v;
a243 1

d263 1
a263 2
dead_lock(v)
	void *v;
d282 1
a282 2
dead_bmap(v)
	void *v;
d302 1
a302 2
dead_print(v)
	void *v;
d313 1
a313 2
dead_ebadf(v)
	void *v;
a314 1

d323 1
a323 2
dead_badop(v)
	void *v;
a324 1

d334 1
a334 2
chkvnlock(vp)
	register struct vnode *vp;
@


1.15
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.14 2003/06/02 23:28:10 millert Exp $	*/
a281 8
	/*
	 * Since we are not using the lock manager, we must clear
	 * the interlock here.
	 */
	if (ap->a_flags & LK_INTERLOCK) {
		simple_unlock(&vp->v_interlock);
		ap->a_flags &= ~LK_INTERLOCK;
	}
d283 1
a283 1
 		return (0);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.13 2002/06/08 18:43:34 art Exp $	*/
d43 1
d62 1
a62 1
int	dead_select(void *);
d102 1
a102 1
	{ &vop_select_desc, dead_select },	/* select */
d228 1
a228 1
dead_select(v)
d231 8
d242 1
a242 1
	return (1);
@


1.13
log
@Use tsleep instead of sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.12 2002/05/24 13:41:27 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@splbio around biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.11 2002/03/14 01:27:07 millert Exp $	*/
d360 1
a360 1
		sleep((caddr_t)vp, PINOD);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.10 2001/12/19 08:58:06 art Exp $	*/
d251 2
d255 1
d257 1
@


1.10
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.8 2001/06/23 02:14:23 csapuntz Exp $	*/
d51 2
a52 2
int	dead_badop	__P((void *));
int	dead_ebadf	__P((void *));
d54 1
a54 1
int	dead_lookup	__P((void *));
d57 1
a57 1
int	dead_open	__P((void *));
d62 4
a65 4
int	dead_read	__P((void *));
int	dead_write	__P((void *));
int	dead_ioctl	__P((void *));
int	dead_select	__P((void *));
d78 1
a78 1
int	dead_lock	__P((void *));
d80 3
a82 3
int	dead_bmap	__P((void *));
int	dead_strategy	__P((void *));
int	dead_print	__P((void *));
d88 1
a88 1
int	chkvnlock __P((struct vnode *));
d90 1
a90 1
int (**dead_vnodeop_p) __P((void *));
d127 1
a127 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.9
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@a86 1
#define dead_mmap	dead_badop
d127 1
a127 2
	{ &vop_mmap_desc, dead_mmap },
	{ NULL, NULL }
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.9 2001/12/04 22:44:31 art Exp $	*/
d51 2
a52 2
int	dead_badop(void *);
int	dead_ebadf(void *);
d54 1
a54 1
int	dead_lookup(void *);
d57 1
a57 1
int	dead_open(void *);
d62 4
a65 4
int	dead_read(void *);
int	dead_write(void *);
int	dead_ioctl(void *);
int	dead_select(void *);
d78 1
a78 1
int	dead_lock(void *);
d80 3
a82 3
int	dead_bmap(void *);
int	dead_strategy(void *);
int	dead_print(void *);
d89 1
a89 1
int	chkvnlock(struct vnode *);
d91 1
a91 1
int (**dead_vnodeop_p)(void *);
a252 2
	int s;

a254 1
		s = splbio();
a255 1
		splx(s);
d358 1
a358 1
		tsleep(vp, PINOD, "chkvnlock", 0);
@


1.9.2.2
log
@convert to genfs_nolock.  genfs_lock for kern and procfs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 2
#include <miscfs/genfs/genfs.h>

d79 1
a79 1
#define dead_unlock	genfs_nounlock
d83 1
a83 1
#define dead_islocked	genfs_noislocked
@


1.8
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.7 1998/11/13 00:31:25 art Exp $	*/
d87 1
d128 2
a129 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.7
log
@When vclean calls VOP_LOCK (dead_lock in this case) it has already set
the VXLOCK flag. Calling chkvnlock in that case causes a deadlock.
XXX note that only vclean passes LK_DRAIN to VOP_LOCK and don't call chkvnlock
XXX in that case.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.6 1998/08/06 19:34:30 csapuntz Exp $	*/
a65 1
#define dead_mmap	dead_badop
a66 1
#define dead_seek	nullop
a85 5
#define dead_blkatoff	dead_badop
#define dead_valloc	dead_badop
#define dead_vfree	dead_badop
#define dead_truncate	nullop
#define dead_update	nullop
a105 1
	{ &vop_mmap_desc, dead_mmap },		/* mmap */
a106 1
	{ &vop_seek_desc, dead_seek },		/* seek */
a125 5
	{ &vop_blkatoff_desc, dead_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, dead_valloc },	/* valloc */
	{ &vop_vfree_desc, dead_vfree },	/* vfree */
	{ &vop_truncate_desc, dead_truncate },	/* truncate */
	{ &vop_update_desc, dead_update },	/* update */
@


1.7.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.7 1998/11/13 00:31:25 art Exp $	*/
d66 1
d68 1
d88 5
d113 1
d115 1
d135 5
@


1.7.6.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 2
a52 2
int	dead_badop(void *);
int	dead_ebadf(void *);
d54 1
a54 1
int	dead_lookup(void *);
d57 1
a57 1
int	dead_open(void *);
d62 4
a65 4
int	dead_read(void *);
int	dead_write(void *);
int	dead_ioctl(void *);
int	dead_select(void *);
d78 1
a78 1
int	dead_lock(void *);
d80 3
a82 3
int	dead_bmap(void *);
int	dead_strategy(void *);
int	dead_print(void *);
d88 1
a88 1
int	chkvnlock(struct vnode *);
d90 1
a90 1
int (**dead_vnodeop_p)(void *);
d127 1
a127 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.7.6.3
log
@Sync the SMP branch with 3.3
@
text
@a250 2
	int s;

a252 1
		s = splbio();
a253 1
		splx(s);
d356 1
a356 1
		tsleep(vp, PINOD, "chkvnlock", 0);
@


1.7.6.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.7.6.3 2003/03/28 00:00:19 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.6.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a42 1
#include <sys/poll.h>
d61 1
a61 1
int	dead_poll(void *);
d101 1
a101 1
	{ &vop_poll_desc, dead_poll },		/* poll */
d227 1
a227 1
dead_poll(v)
a229 8
#if 0
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;
		struct proc *a_p;
	} */ *ap = v;
#endif

d233 1
a233 1
	return (POLLHUP);
@


1.6
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.5 1997/11/06 05:58:31 csapuntz Exp $	*/
d295 1
a295 1
	if (!chkvnlock(vp))
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.4 1997/10/06 20:20:20 deraadt Exp $	*/
d81 1
a81 1
#define dead_unlock	vop_nounlock
d85 1
a85 1
#define dead_islocked	vop_noislocked
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: dead_vnops.c,v 1.2 1996/02/27 07:49:43 niklas Exp $	*/
d81 1
a81 1
#define dead_unlock	nullop
d85 1
a85 1
#define dead_islocked	nullop
d282 2
d285 12
d298 1
a298 3
	if (!chkvnlock(ap->a_vp))
		return (0);
	return (VCALL(ap->a_vp, VOFFSET(vop_lock), ap));
@


1.3
log
@VFS Lite2 Changes
@
text
@d81 1
a81 1
#define dead_unlock	vop_nounlock
d85 1
a85 1
#define dead_islocked	vop_noislocked
a281 2
		int a_flags;
		struct proc *a_p;
a282 1
	struct vnode *vp = ap->a_vp;
d284 3
a286 12
	/*
	 * Since we are not using the lock manager, we must clear
	 * the interlock here.
	 */
	if (ap->a_flags & LK_INTERLOCK) {
		simple_unlock(&vp->v_interlock);
		ap->a_flags &= ~LK_INTERLOCK;
	}
	if (!chkvnlock(vp))
 		return (0);

	return (VCALL(vp, VOFFSET(vop_lock), ap));
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
a81 1
#define dead_unlock	nullop
d85 1
a85 1
#define dead_islocked	nullop
d282 2
d285 12
d298 1
a298 3
	if (!chkvnlock(ap->a_vp))
		return (0);
	return (VCALL(ap->a_vp, VOFFSET(vop_lock), ap));
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: dead_vnops.c,v 1.13 1995/04/10 00:48:46 mycroft Exp $	*/
d46 1
d51 47
a97 42
int	dead_badop(),
	dead_ebadf();
int	dead_lookup __P((struct vop_lookup_args *));
#define dead_create ((int (*) __P((struct  vop_create_args *)))dead_badop)
#define dead_mknod ((int (*) __P((struct  vop_mknod_args *)))dead_badop)
int	dead_open __P((struct vop_open_args *));
#define dead_close ((int (*) __P((struct  vop_close_args *)))nullop)
#define dead_access ((int (*) __P((struct  vop_access_args *)))dead_ebadf)
#define dead_getattr ((int (*) __P((struct  vop_getattr_args *)))dead_ebadf)
#define dead_setattr ((int (*) __P((struct  vop_setattr_args *)))dead_ebadf)
int	dead_read __P((struct vop_read_args *));
int	dead_write __P((struct vop_write_args *));
int	dead_ioctl __P((struct vop_ioctl_args *));
int	dead_select __P((struct vop_select_args *));
#define dead_mmap ((int (*) __P((struct  vop_mmap_args *)))dead_badop)
#define dead_fsync ((int (*) __P((struct  vop_fsync_args *)))nullop)
#define dead_seek ((int (*) __P((struct  vop_seek_args *)))nullop)
#define dead_remove ((int (*) __P((struct  vop_remove_args *)))dead_badop)
#define dead_link ((int (*) __P((struct  vop_link_args *)))dead_badop)
#define dead_rename ((int (*) __P((struct  vop_rename_args *)))dead_badop)
#define dead_mkdir ((int (*) __P((struct  vop_mkdir_args *)))dead_badop)
#define dead_rmdir ((int (*) __P((struct  vop_rmdir_args *)))dead_badop)
#define dead_symlink ((int (*) __P((struct  vop_symlink_args *)))dead_badop)
#define dead_readdir ((int (*) __P((struct  vop_readdir_args *)))dead_ebadf)
#define dead_readlink ((int (*) __P((struct  vop_readlink_args *)))dead_ebadf)
#define dead_abortop ((int (*) __P((struct  vop_abortop_args *)))dead_badop)
#define dead_inactive ((int (*) __P((struct  vop_inactive_args *)))nullop)
#define dead_reclaim ((int (*) __P((struct  vop_reclaim_args *)))nullop)
int	dead_lock __P((struct vop_lock_args *));
#define dead_unlock ((int (*) __P((struct  vop_unlock_args *)))nullop)
int	dead_bmap __P((struct vop_bmap_args *));
int	dead_strategy __P((struct vop_strategy_args *));
int	dead_print __P((struct vop_print_args *));
#define dead_islocked ((int (*) __P((struct  vop_islocked_args *)))nullop)
#define dead_pathconf ((int (*) __P((struct  vop_pathconf_args *)))dead_ebadf)
#define dead_advlock ((int (*) __P((struct  vop_advlock_args *)))dead_ebadf)
#define dead_blkatoff ((int (*) __P((struct  vop_blkatoff_args *)))dead_badop)
#define dead_valloc ((int (*) __P((struct  vop_valloc_args *)))dead_badop)
#define dead_vfree ((int (*) __P((struct  vop_vfree_args *)))dead_badop)
#define dead_truncate ((int (*) __P((struct  vop_truncate_args *)))nullop)
#define dead_update ((int (*) __P((struct  vop_update_args *)))nullop)
#define dead_bwrite ((int (*) __P((struct  vop_bwrite_args *)))nullop)
a98 1
int (**dead_vnodeop_p)();
d104 1
a104 1
	{ &vop_open_desc, dead_open },	/* open */
d109 1
a109 1
	{ &vop_read_desc, dead_read },	/* read */
d113 1
a113 1
	{ &vop_mmap_desc, dead_mmap },	/* mmap */
d115 1
a115 1
	{ &vop_seek_desc, dead_seek },	/* seek */
d117 1
a117 1
	{ &vop_link_desc, dead_link },	/* link */
d127 1
a127 1
	{ &vop_lock_desc, dead_lock },	/* lock */
d129 1
a129 1
	{ &vop_bmap_desc, dead_bmap },	/* bmap */
d141 1
a141 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d151 3
a153 1
dead_lookup(ap)
d158 1
a158 2
	} */ *ap;
{
d168 3
a170 7
dead_open(ap)
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d180 4
a183 1
dead_read(ap)
d189 1
a189 2
	} */ *ap;
{
d205 4
a208 1
dead_write(ap)
d214 1
a214 2
	} */ *ap;
{
d225 4
a228 1
dead_ioctl(ap)
d236 1
a236 2
	} */ *ap;
{
d244 3
a246 8
dead_select(ap)
	struct vop_select_args /* {
		struct vnode *a_vp;
		int  a_which;
		int  a_fflags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
a247 1

d257 5
a261 1
dead_strategy(ap)
d264 1
a264 3
	} */ *ap;
{

d276 4
a279 1
dead_lock(ap)
d282 1
a282 2
	} */ *ap;
{
d292 4
a295 1
dead_bmap(ap)
d302 1
a302 2
	} */ *ap;
{
d313 3
a315 4
dead_print(ap)
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap;
a316 1

d318 1
d324 4
a327 1
dead_ebadf()
d336 4
a339 1
dead_badop()
a346 9
 * Empty vnode null operation
 */
dead_nullop()
{

	return (0);
}

/*
d350 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
