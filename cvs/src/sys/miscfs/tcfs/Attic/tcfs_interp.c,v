head	1.4;
access;
symbols
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_2:1.3.0.14
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.12
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.10
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.4
date	2003.02.24.01.17.39;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2000.06.17.20.25.54;	author provos;	state Exp;
branches
	1.3.6.1
	1.3.10.1;
next	1.2;

1.2
date	2000.06.17.17.32.27;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.17.17.16.06;	author provos;	state Exp;
branches;
next	;

1.3.6.1
date	2001.05.14.22.32.57;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2003.03.28.00.00.20;	author niklas;	state dead;
branches;
next	;

1.3.10.1
date	2003.05.19.22.36.12;	author tedu;	state dead;
branches;
next	;


desc
@@


1.4
log
@Remove tcfs until this entire licensing mess is cleaned up.  This is
ANOTHER case of a developer having ignored licenses when importing code.
@
text
@/*	$OpenBSD: tcfs_interp.c,v 1.3 2000/06/17 20:25:54 provos Exp $	*/
/*
 * Copyright 2000 The TCFS Project at http://tcfs.dia.unisa.it/
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/types.h>
#include <sys/malloc.h>
#include <sys/errno.h>

#include <miscfs/tcfs/tcfs_keytab.h>
#include <miscfs/tcfs/tcfs_cipher.h>

int interp(tcfs_grp_data *,unsigned char *);
void doinverse(void);

static int inverse[]={
      0,1,129,86,193,103,43,147,225,200,180,187,150,178,
      202,120,241,121,100,230,90,49,222,190,75,72,89,238,
      101,195,60,199,249,148,189,235,50,132,115,145,45,163,
      153,6,111,40,95,175,166,21,36,126,173,97,119,243,179,248,
      226,61,30,59,228,102,253,87,74,234,223,149,246,181,25,
      169,66,24,186,247,201,244,151,165,210,96,205,127,3,65,
      184,26,20,209,176,152,216,46,83,53,139,135,18,28,63,5,
      215,164,177,245,188,224,250,44,218,116,124,38,113,134,
      159,54,15,17,158,140,114,220,51,85,255,2,172,206,37,143,
      117,99,240,242,203,98,123,144,219,133,141,39,213,7,33,69,
      12,80,93,42,252,194,229,239,122,118,204,174,211,41,105,
      81,48,237,231,73,192,254,130,52,161,47,92,106,13,56,10,
      71,233,191,88,232,76,11,108,34,23,183,170,4,155,29,198,
      227,196,31,9,78,14,138,160,84,131,221,236,91,82,162,217,
      146,251,104,94,212,112,142,125,207,22,68,109,8,58,197,
      62,156,19,168,185,182,67,35,208,167,27,157,136,16,137,
      55,79,107,70,77,57,32,110,214,154,64,171,128,256
};

union bobbit { 
	unsigned char byte;
	struct {
		unsigned char b1:1;
		unsigned char b2:1;
		unsigned char b3:1;
		unsigned char b4:1;
		unsigned char b5:1;
		unsigned char b6:1;
		unsigned char b7:1;
		unsigned char b8:1;
	} bf;
};

#define mod(a)	((unsigned int)((a)%257))
/*
unsigned int mod(long a) 
{
	return (unsigned int) a%257;
}
*/

int 
interp(tcfs_grp_data *gd,unsigned char *gidkey)
{
	unsigned int tp,kkk;
	int i = 0, j, l, idx;
	tcfs_grp_uinfo ktmp[MAXUSRPERGRP], *gui;
	unsigned int inv, ttt;
	union bobbit obits;
	int k;

	k = gd->gd_k;

	for (i = 0; i < MAXUSRPERGRP && i < k; i++) {
		gui = &(gd->gd_part[i]);
		if (!IS_SET_GUI(*gui))
			continue;
		ktmp[i].gui_uid = gui->gui_uid;

		for(l = 0; l < KEYSIZE/8; l++) {
			obits.byte = gui->gui_tcfskey[9*l+8];
			ktmp[i].gui_tcfskey[8*l+0] = mod(obits.bf.b1<<8 | gui->gui_tcfskey[9*l+0]);
			ktmp[i].gui_tcfskey[8*l+1] = mod(obits.bf.b2<<8 | gui->gui_tcfskey[9*l+1]);
			ktmp[i].gui_tcfskey[8*l+2] = mod(obits.bf.b3<<8 | gui->gui_tcfskey[9*l+2]);
			ktmp[i].gui_tcfskey[8*l+3] = mod(obits.bf.b4<<8 | gui->gui_tcfskey[9*l+3]);
			ktmp[i].gui_tcfskey[8*l+4] = mod(obits.bf.b5<<8 | gui->gui_tcfskey[9*l+4]);
			ktmp[i].gui_tcfskey[8*l+5] = mod(obits.bf.b6<<8 | gui->gui_tcfskey[9*l+5]);
			ktmp[i].gui_tcfskey[8*l+6] = mod(obits.bf.b7<<8 | gui->gui_tcfskey[9*l+6]);
			ktmp[i].gui_tcfskey[8*l+7] = mod(obits.bf.b8<<8 | gui->gui_tcfskey[9*l+7]);
		}

		i++;
	}

	for (idx = 0;idx<KEYSIZE;idx++) {
		kkk = 0;
		for (i = 0; i < k; i++) {
			tp = 1;
			for (j = 0; j < k; j++) {
				if (j != i) {
					inv = inverse[mod(ktmp[i].gui_uid-ktmp[j].gui_uid)];
					ttt = mod(inv * mod(-ktmp[j].gui_uid));
					tp = mod(tp * ttt);
				}
			}
			tp *= mod(ktmp[i].gui_tcfskey[idx]);
			kkk= (tp + kkk);
		}
		gidkey[idx] = (unsigned char)mod(kkk);
	}
	return 0;
}

void
doinverse(void)
{
	int i, j;
	for (i = 0; i < 257; i++) {
		for (j = 0; j < 257; j++) {
			if (mod((i*j)) == 1)
				inverse[i] = j;
		}
	}
}

int
tcfs_interp(struct tcfs_mount *mp, tcfs_keytab_node* x) 
{
        void *ks;
        char key[KEYSIZE];

        interp(x->kn_data,key);
	ks = TCFS_INIT_KEY(mp,key);
	if (!ks)
		return ENOMEM;

        x->kn_key = ks;
        return TCFS_OK;
}
@


1.3
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_interp.c,v 1.2 2000/06/17 17:32:27 provos Exp $	*/
@


1.3.10.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_interp.c,v 1.3 2000/06/17 20:25:54 provos Exp $	*/
@


1.3.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_interp.c,v 1.3 2000/06/17 20:25:54 provos Exp $	*/
@


1.3.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_interp.c,v 1.3.6.1 2001/05/14 22:32:57 niklas Exp $	*/
@


1.2
log
@BSD copyright + tags
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.17 2000/06/12 17:24:26 itojun Exp $	*/
d28 6
a33 5
#include<sys/types.h>
#include<sys/malloc.h>
#include<sys/errno.h>
#include "tcfs_keytab.h"
#include "tcfs_cipher.h"
d80 2
a81 1
int interp(tcfs_grp_data *gd,unsigned char *gidkey)
d84 3
a86 3
	int i=0,j,l,idx;
	tcfs_grp_uinfo ktmp[MAXUSRPERGRP],*gui;
	unsigned int inv,ttt;
d90 1
a90 1
	k=gd->gd_k;
d92 3
a94 4
	for (i=0;i<MAXUSRPERGRP && i<k;i++)
	{
		gui=&(gd->gd_part[i]);
		if(!IS_SET_GUI(*gui))
d96 1
a96 1
		ktmp[i].gui_uid=gui->gui_uid;
d98 10
a107 10
		for(l=0;l<KEYSIZE/8;l++){
			obits.byte=gui->gui_tcfskey[9*l+8];
			ktmp[i].gui_tcfskey[8*l+0]=mod(obits.bf.b1<<8 | gui->gui_tcfskey[9*l+0]);
			ktmp[i].gui_tcfskey[8*l+1]=mod(obits.bf.b2<<8 | gui->gui_tcfskey[9*l+1]);
			ktmp[i].gui_tcfskey[8*l+2]=mod(obits.bf.b3<<8 | gui->gui_tcfskey[9*l+2]);
			ktmp[i].gui_tcfskey[8*l+3]=mod(obits.bf.b4<<8 | gui->gui_tcfskey[9*l+3]);
			ktmp[i].gui_tcfskey[8*l+4]=mod(obits.bf.b5<<8 | gui->gui_tcfskey[9*l+4]);
			ktmp[i].gui_tcfskey[8*l+5]=mod(obits.bf.b6<<8 | gui->gui_tcfskey[9*l+5]);
			ktmp[i].gui_tcfskey[8*l+6]=mod(obits.bf.b7<<8 | gui->gui_tcfskey[9*l+6]);
			ktmp[i].gui_tcfskey[8*l+7]=mod(obits.bf.b8<<8 | gui->gui_tcfskey[9*l+7]);
d113 6
a118 6
	for (idx=0;idx<KEYSIZE;idx++) {
		kkk=0;
		for (i=0;i<k;i++) {
			tp=1;
			for (j=0;j<k;j++) {
				if (j!=i) {
d125 1
a125 1
			kkk=(tp+kkk);
d127 1
a127 1
		gidkey[idx]=(unsigned char)mod(kkk);
d132 2
a133 1
void doinverse(void)
d135 5
a139 5
	int i,j;
	for (i=0;i<257;i++) {
		for (j=0;j<257;j++) {
			if (mod((i*j))==1)
				inverse[i]=j;
d144 2
a145 1
int tcfs_interp(struct tcfs_mount *mp, tcfs_keytab_node* x) 
d151 1
a151 1
	ks=TCFS_INIT_KEY(mp,key);
d155 1
a155 1
        x->kn_key=ks;
a157 1

@


1.1
log
@initial import of tcfs.
@
text
@d1 27
@

