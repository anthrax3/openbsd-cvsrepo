head	1.4;
access;
symbols
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_2:1.3.0.14
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.12
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.10
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.4
date	2003.02.24.01.17.39;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2000.06.17.20.25.55;	author provos;	state Exp;
branches
	1.3.6.1
	1.3.10.1;
next	1.2;

1.2
date	2000.06.17.17.32.27;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.17.17.16.06;	author provos;	state Exp;
branches;
next	;

1.3.6.1
date	2001.05.14.22.32.57;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2003.03.28.00.00.20;	author niklas;	state dead;
branches;
next	;

1.3.10.1
date	2003.05.19.22.36.12;	author tedu;	state dead;
branches;
next	;


desc
@@


1.4
log
@Remove tcfs until this entire licensing mess is cleaned up.  This is
ANOTHER case of a developer having ignored licenses when importing code.
@
text
@/*	$OpenBSD: tcfs_keytab.c,v 1.3 2000/06/17 20:25:55 provos Exp $	*/
/*
 * Copyright 2000 The TCFS Project at http://tcfs.dia.unisa.it/
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/errno.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <miscfs/tcfs/tcfs_keytab.h>
#include <sys/malloc.h>

tcfs_keytab_node *
tcfs_keytab_newnode()
{
	tcfs_keytab_node *n;

	n = (tcfs_keytab_node*)malloc(sizeof(tcfs_keytab_node),
				      M_FREE, M_NOWAIT); 
	if (!n)
		return n;

	n->kn_key = (void*)0;
	n->kn_data = (tcfs_grp_data*)0;
	n->kn_type = CLEAN;
	n->kn_n = n->kn_p = NIL;
	return n;
}

tcfs_keytab_node *
tcfs_keytab_newgidnode()
{
	tcfs_keytab_node *n;
	tcfs_grp_data *gd;
	int i;

	n = tcfs_keytab_newnode();
	if (!n)
		return n;
	
	gd = (tcfs_grp_data*)malloc(sizeof(tcfs_grp_data), M_FREE, M_NOWAIT);
	if (!gd) {
		tcfs_keytab_dispnode(n);
		return NIL;
	}
	gd->gd_n = 0;
	gd->gd_k = 0;
	for(i = 0; i < MAXUSRPERGRP; i++); {
		gd->gd_part[i].gui_flag = GUI_CLEAN;
		gd->gd_part[i].gui_uid = -2; /* nfs nobody */
	}

	n->kn_data = gd;
	n->kn_type = GID_KEY;
	n->kn_key = (void*)0;

	return n;
}
	
	
	
void
tcfs_keytab_dispnode(tcfs_keytab_node *n)
{
	if (n->kn_key)
		free(n->kn_key,M_FREE);


	if (n->kn_data)
		free(n->kn_data,M_FREE);

	if (n)
		free(n,M_FREE);
}
		
	

tcfs_keytab *
tcfs_keytab_init()
{
	tcfs_keytab *x;
	int i;

	x = (tcfs_keytab*)malloc(sizeof(tcfs_keytab),M_FREE,M_NOWAIT);
	if (!x)
		return x;

	x->cnt = 0;

	for(i = 0; i < KEYTABSIZE; i++) /* one bzero or similar even */
		x->node[i] = NIL;

	return x;
}

void
tcfs_keytab_dispose(tcfs_keytab *kt)  
{
	tcfs_keytab_node *p,*q;
	int i = 0;
		
	if(kt->cnt)
		for(i = 0;i < KEYTABSIZE; i++) {
			p = kt->node[i];
			while (p != NIL) {
				q = p->kn_n;
				tcfs_keytab_dispnode(p);
				p = q;
			}
		}

	free(kt, M_FREE);
}

int
tcfs_keytab_check_uid(tcfs_keytab *t, uid_t uid)
{
	int pos;
	tcfs_keytab_node *p;

	pos = tcfs_keytab_hash(uid);
	p = t->node[pos];

	while(p!=NIL) {
		if (IS_UID_NODE(p) && p->kn_uid == uid)
			return 1;
		p=p->kn_n;
	}
 	return 0;	
}

tcfs_keytab_node *
tcfs_keytab_fetch_uid(tcfs_keytab *t, uid_t uid)
{
	tcfs_keytab_node *p;
	int pos;
	
	pos = tcfs_keytab_hash(uid);
	p = t->node[pos];
	while (p != NIL) {
		if (IS_UID_NODE(p) && p->kn_uid == uid)
			break;
		p = p->kn_n;
	}
	return p;
}

int
tcfs_keytab_check_gid(tcfs_keytab *t, gid_t gid)
{
	tcfs_keytab_node *p;
	int pos;
	
	pos = tcfs_keytab_hash(gid);
	p = t->node[pos];

	while (p!=NIL) {
		if (IS_GID_NODE(p) && p->kn_gid == gid &&
		    IS_READY_GD(p->kn_data))
			return 1;
		p=p->kn_n;
	}
	return 0;
}
		
tcfs_keytab_node *
tcfs_keytab_fetch_gid(tcfs_keytab *t, gid_t gid)
{
	tcfs_keytab_node *p;
	int pos;
	
	pos = tcfs_keytab_hash(gid);
	p = t->node[pos];
	while (p != NIL) {
		if (IS_GID_NODE(p) && p->kn_gid == gid)
			break;
		p = p->kn_n;
	}
	return p;
}

int
tcfs_keytab_check_pid(tcfs_keytab *t, uid_t uid, pid_t pid)
{
	int pos;
	tcfs_keytab_node *p;

	pos = tcfs_keytab_hash(pid);
	p = t->node[pos];

	while (p != NIL) {
		if (IS_PID_NODE(p) && p->kn_pid == pid && p->kn_uid == uid)
			return 1;
		p = p->kn_n;
	}
 	return 0;	
}

tcfs_keytab_node *
tcfs_keytab_fetch_pid(tcfs_keytab *t, uid_t uid, pid_t pid)
{
	tcfs_keytab_node *p;
	int pos;
	
	pos = tcfs_keytab_hash(pid);
	p = t->node[pos];

	while (p != NIL) {
		if (IS_PID_NODE(p) && p->kn_pid == pid && p->kn_uid == uid)
			break;
		p = p->kn_n;
	}
	return (p);
}

int
tcfs_keytab_push_pid(tcfs_keytab *t, uid_t uid, pid_t pid, void *ks) 
{
	int pos = 0;
	tcfs_keytab_node *p,*q;
	
	if (tcfs_keytab_fetch_pid(t, uid, pid) != NIL)
		return (EINVAL);
	
	q = tcfs_keytab_newnode();
	if (!q)
		return (ENOMEM);

	pos = tcfs_keytab_hash(pid);

	p = t->node[pos];
	q->kn_n = p;
	if (p != NIL)
		p->kn_p = q;
	t->node[pos] = q;
	t->cnt++;

	q->kn_uid = uid;
	q->kn_pid = pid;
	q->kn_key = ks;
	q->kn_type = PID_KEY;

	return TCFS_OK;
}

int
tcfs_keytab_push_uid(tcfs_keytab *t, uid_t uid, void *key)
{
	int pos = 0;
	tcfs_keytab_node *p,*q;

	if (tcfs_keytab_fetch_uid(t,uid) != NIL)
		return (EINVAL);
	
	q = tcfs_keytab_newnode();
	if (!q)
		return (ENOMEM);

	pos = tcfs_keytab_hash(uid);

	p = t->node[pos];
	q->kn_n = p;
	if (p != NIL)
		p->kn_p = q;
	t->node[pos] = q;
	t->cnt++;

	q->kn_uid = uid;
	q->kn_pid = 0;
	q->kn_key = key;
	q->kn_type = UID_KEY;

	return (TCFS_OK);
}

int
tcfs_keytab_push_gidpart(struct tcfs_mount *mp,tcfs_keytab_node *kn,uid_t uid,
			 gid_t gid, int k, char *key)
{
	int i = 0;
	int first = -1;
	tcfs_grp_data *p;

	p = kn->kn_data;
	
	if (IS_FULL_GD(p))
		return (EINVAL);

	for (i = 0; i < MAXUSRPERGRP; i++) {
		if (first < 0 && !IS_SET_GUI(p->gd_part[i])) {
			first=i;
			continue;
		}
		if(IS_SET_GUI(p->gd_part[i]) && p->gd_part[i].gui_uid == uid)
			return (EINVAL);
	}
	
	p->gd_part[first].gui_uid = uid;
	p->gd_part[first].gui_flag = GUI_SET;
	memcpy(p->gd_part[first].gui_tcfskey, key, KEYPARTSIZE);
 	if (IS_CLEAN_GD(p))
		p->gd_k = k;	

	p->gd_n++;

	if (IS_READY_GD(p) && (!kn->kn_key))
		tcfs_interp(mp,kn);
		
	return (TCFS_OK);
}

int
tcfs_keytab_rm_gidpart(tcfs_keytab_node *kn, uid_t uid, gid_t gid)
{
	int i = 0;
	tcfs_grp_data *p;

	p = kn->kn_data;
	
	if (IS_CLEAN_GD(p))
		return (EINVAL);

	for (i = 0; i < MAXUSRPERGRP; i++)
		if (IS_SET_GUI(p->gd_part[i]))
			if(p->gd_part[i].gui_uid == uid) {
				p->gd_part[i].gui_flag=GUI_CLEAN;
				break;
			}
				
	if ( i == MAXUSRPERGRP)
		return EINVAL;

	p->gd_n--;

	if (!IS_READY_GD(p))
		if(kn->kn_key) {
			free(kn->kn_key,M_FREE);
			kn->kn_key=(void*)0;
		}
		
	return (TCFS_OK);
}
	
int
tcfs_keytab_push_gid(struct tcfs_mount *mp, tcfs_keytab *t, uid_t uid,
		     gid_t gid, int k, char *key)
{
	int pos = 0;
	tcfs_keytab_node *p,*q,*r;
	
	q = r = tcfs_keytab_fetch_gid(t,gid);

	if (r == NIL) {
		q = tcfs_keytab_newgidnode();
		if (!q)
			return (ENOMEM);

		pos = tcfs_keytab_hash(gid);

		p = t->node[pos];
		q->kn_n = p;
		if (p != NIL)
			p->kn_p = q;
		t->node[pos] = q;
		t->cnt++;

		q->kn_gid = gid;
		q->kn_pid = 0;
		q->kn_uid = 0;
	}
	
	return tcfs_keytab_push_gidpart(mp, q, uid, gid, k, key);
}

int
tcfs_keytab_rm_uid(tcfs_keytab *t, uid_t uid)
{
	int pos = 0;
	tcfs_keytab_node *p;

	p = tcfs_keytab_fetch_uid(t, uid);
	if (p == NIL)
		return (EINVAL);

	if (p->kn_p == NIL) {
		 pos = tcfs_keytab_hash(uid);
		 t->node[pos] = p->kn_n;
	} else
		 p->kn_p->kn_n = p->kn_n;

	if (p->kn_n != NIL)
		p->kn_n->kn_p = p->kn_p;	 
	
	t->cnt--;
	tcfs_keytab_dispnode(p);

	return (TCFS_OK);
}
	
int
tcfs_keytab_rm_pid(tcfs_keytab *t, uid_t uid, pid_t pid)
{
	int pos = 0;
	tcfs_keytab_node *p;

	p = tcfs_keytab_fetch_pid(t,uid,pid);
	if (p == NIL)
		return (EINVAL);

	if(p->kn_p == NIL) {
		 pos = tcfs_keytab_hash(pid);
		 t->node[pos] = p->kn_n;
	} else
		 p->kn_p->kn_n = p->kn_n;

	if(p->kn_n != NIL)
		p->kn_n->kn_p = p->kn_p;	 
	
	t->cnt--;
	tcfs_keytab_dispnode(p);

	return (TCFS_OK);
}

int
tcfs_keytab_rm_gid(tcfs_keytab *t, uid_t uid, gid_t gid)
{
	int pos = 0,ret = 0;
	tcfs_keytab_node *p;

	p = tcfs_keytab_fetch_gid(t,gid);
	if (p == NIL)
		return (EINVAL);

	ret = tcfs_keytab_rm_gidpart(p, uid, gid);

	if (ret)
		return (ret); 	

	if (!IS_CLEAN_GD(p->kn_data))
		return (TCFS_OK);

	if (p->kn_p == NIL) {
		 pos = tcfs_keytab_hash(gid);
		 t->node[pos] = p->kn_n;
	} else
		 p->kn_p->kn_n = p->kn_n;

	if (p->kn_n != NIL)
		p->kn_n->kn_p = p->kn_p;	 
	
	t->cnt--;
	tcfs_keytab_dispnode(p);

	return (TCFS_OK);
}
@


1.3
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_keytab.c,v 1.2 2000/06/17 17:32:27 provos Exp $	*/
@


1.3.10.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_keytab.c,v 1.3 2000/06/17 20:25:55 provos Exp $	*/
@


1.3.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_keytab.c,v 1.3 2000/06/17 20:25:55 provos Exp $	*/
@


1.3.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_keytab.c,v 1.3.6.1 2001/05/14 22:32:57 niklas Exp $	*/
@


1.2
log
@BSD copyright + tags
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.17 2000/06/12 17:24:26 itojun Exp $	*/
d28 5
a32 7
#include<sys/errno.h>
#include<sys/types.h>
#include<sys/systm.h>
#ifndef _TCFS_KEYTAB_H_
#include "tcfs_keytab.h"
#endif
#include<sys/malloc.h>
d34 2
a35 1
tcfs_keytab_node *tcfs_keytab_newnode()
d39 3
a41 2
	n=(tcfs_keytab_node*)malloc(sizeof(tcfs_keytab_node),M_FREE,M_NOWAIT); 
	if(!n)
d44 4
a47 4
	n->kn_key=(void*)0;
	n->kn_data=(tcfs_grp_data*)0;
	n->kn_type=CLEAN;
	n->kn_n=n->kn_p=NIL;
d51 2
a52 1
tcfs_keytab_node *tcfs_keytab_newgidnode()
d58 2
a59 2
	n=tcfs_keytab_newnode();
	if(!n)
d62 11
a72 13
	gd=(tcfs_grp_data*)malloc(sizeof(tcfs_grp_data),M_FREE,M_NOWAIT);
	if(!gd)
		{
			tcfs_keytab_dispnode(n);
			return NIL;
		}
	gd->gd_n=0;
	gd->gd_k=0;
	for(i=0;i<MAXUSRPERGRP;i++);
		{
		 gd->gd_part[i].gui_flag=GUI_CLEAN;
		 gd->gd_part[i].gui_uid=65535; /* nobody */
		}
d74 3
a76 3
	n->kn_data=gd;
	n->kn_type=GID_KEY;
	n->kn_key=(void*)0;
d83 2
a84 1
void tcfs_keytab_dispnode(tcfs_keytab_node *n)
d86 1
a86 1
	if(n->kn_key)
d90 1
a90 1
	if(n->kn_data)
d93 1
a93 1
	if(n)
d99 2
a100 1
tcfs_keytab *tcfs_keytab_init()
d105 1
a105 1
	x=(tcfs_keytab*)malloc(sizeof(tcfs_keytab),M_FREE,M_NOWAIT);
d109 1
a109 1
	x->cnt=0;
d111 2
a112 2
	for(i=0;i<KEYTABSIZE;i++) /*una bzero o simile magari */
		x->node[i]=NIL;
d117 2
a118 1
void tcfs_keytab_dispose(tcfs_keytab *kt)  
d121 1
a121 1
	int i=0;
d124 6
a129 9
		 for(i=0;i<KEYTABSIZE;i++)
			{
			 p=kt->node[i];
			 while(p!=NIL)
			 	{
  			 	 q=p->kn_n;
			 	 tcfs_keytab_dispnode(p);
				 p=q;
				}
d131 1
d133 1
a133 1
	free(kt,M_FREE);
d136 2
a137 1
int tcfs_keytab_check_uid(tcfs_keytab *t, uid_t uid)
d142 2
a143 2
	pos=tcfs_keytab_hash(uid);
	p=t->node[pos];
d145 2
a146 3
	while(p!=NIL)
	{
		if (IS_UID_NODE(p) && p->kn_uid==uid)
d153 2
a154 2

tcfs_keytab_node *tcfs_keytab_fetch_uid(tcfs_keytab *t, uid_t uid)
d159 4
a162 5
	pos=tcfs_keytab_hash(uid);
	p=t->node[pos];
	while(p!=NIL)
	{
		if(IS_UID_NODE(p) && p->kn_uid==uid)
d164 1
a164 1
		p=p->kn_n;
d169 2
a170 1
int tcfs_keytab_check_gid(tcfs_keytab *t, gid_t gid)
d175 2
a176 2
	pos=tcfs_keytab_hash(gid);
	p=t->node[pos];
d178 3
a180 3
	while (p!=NIL)
	{
		if(IS_GID_NODE(p) && p->kn_gid==gid && IS_READY_GD(p->kn_data))
a185 1

d187 2
a188 1
tcfs_keytab_node *tcfs_keytab_fetch_gid(tcfs_keytab *t, gid_t gid)
d193 4
a196 5
	pos=tcfs_keytab_hash(gid);
	p=t->node[pos];
	while(p!=NIL)
	{
		if(IS_GID_NODE(p) && p->kn_gid==gid)
d198 1
a198 1
		p=p->kn_n;
a201 2
	
	
d203 2
a204 1
int tcfs_keytab_check_pid(tcfs_keytab *t, uid_t uid, pid_t pid)
d209 2
a210 2
	pos=tcfs_keytab_hash(pid);
	p=t->node[pos];
d212 2
a213 3
	while(p!=NIL)
	{
		if (IS_PID_NODE(p) && p->kn_pid==pid && p->kn_uid==uid)
d215 1
a215 1
		p=p->kn_n;
d220 2
a221 1
tcfs_keytab_node *tcfs_keytab_fetch_pid(tcfs_keytab *t, uid_t uid, pid_t pid)
d226 2
a227 2
	pos=tcfs_keytab_hash(pid);
	p=t->node[pos];
d229 2
a230 3
	while(p!=NIL)
	{
		if(IS_PID_NODE(p) && p->kn_pid==pid && p->kn_uid==uid)
d232 1
a232 1
		p=p->kn_n;
d234 1
a234 1
	return p;
d237 2
a238 1
int tcfs_keytab_push_pid(tcfs_keytab *t, uid_t uid, pid_t pid, void *ks) 
d240 1
a240 1
	int pos=0;
d243 2
a244 2
	if(tcfs_keytab_fetch_pid(t,uid,pid)!=NIL)
		return EINVAL;
d246 11
a256 11
	q=tcfs_keytab_newnode();
	if(!q)
		return ENOMEM;

	pos=tcfs_keytab_hash(pid);

	p=t->node[pos];
	q->kn_n=p;
	if(p!=NIL)
		p->kn_p=q;
	t->node[pos]=q;
d259 4
a262 4
	q->kn_uid=uid;
	q->kn_pid=pid;
	q->kn_key=ks;
	q->kn_type=PID_KEY;
d267 2
a268 1
int tcfs_keytab_push_uid(tcfs_keytab *t, uid_t uid, void *key)
d270 1
a270 1
	int pos=0;
d273 2
d276 11
a286 14
	if(tcfs_keytab_fetch_uid(t,uid)!=NIL)
		return EINVAL;
	
	q=tcfs_keytab_newnode();
	if(!q)
		return ENOMEM;

	pos=tcfs_keytab_hash(uid);

	p=t->node[pos];
	q->kn_n=p;
	if(p!=NIL)
		p->kn_p=q;
	t->node[pos]=q;
d289 4
a292 4
	q->kn_uid=uid;
	q->kn_pid=0;
	q->kn_key=key;
	q->kn_type=UID_KEY;
d294 1
a294 1
	return TCFS_OK;
d297 3
a299 1
int tcfs_keytab_push_gidpart(struct tcfs_mount *mp,tcfs_keytab_node *kn,uid_t uid, gid_t gid, int k,char *key)
d301 2
a302 2
	int i=0;
	int first=-1;
d305 1
a305 1
	p=kn->kn_data;
d307 2
a308 2
	if(IS_FULL_GD(p))
		return EINVAL;
d310 7
a316 10
	for (i=0;i<MAXUSRPERGRP;i++)
	{
		if(first<0 && !IS_SET_GUI(p->gd_part[i]))
			{
			 first=i;
			 continue;
			}
		if(IS_SET_GUI(p->gd_part[i]) && 
				p->gd_part[i].gui_uid==uid)
			return EINVAL;
d319 5
a323 5
	p->gd_part[first].gui_uid=uid;
	p->gd_part[first].gui_flag=GUI_SET;
	memcpy(p->gd_part[first].gui_tcfskey,key,KEYPARTSIZE);
 	if(IS_CLEAN_GD(p))
		p->gd_k=k;	
d327 1
a327 1
	if(IS_READY_GD(p)&&(!kn->kn_key))
d330 1
a330 1
	return TCFS_OK;
d333 2
a334 1
int tcfs_keytab_rm_gidpart(tcfs_keytab_node *kn, uid_t uid, gid_t gid)
d336 1
a336 1
	int i=0;
d339 1
a339 1
	p=kn->kn_data;
d341 2
a342 2
	if(IS_CLEAN_GD(p))
		return EINVAL;
d344 6
a349 7
	for (i=0;i<MAXUSRPERGRP;i++)
		if(IS_SET_GUI(p->gd_part[i]))
			if(p->gd_part[i].gui_uid==uid)
				{
				 p->gd_part[i].gui_flag=GUI_CLEAN;
				 break;
				}
d351 1
a351 1
	if (i==MAXUSRPERGRP)
d356 5
a360 6
	if(!IS_READY_GD(p))
		 if(kn->kn_key)
			{
		 	 free(kn->kn_key,M_FREE);
		 	 kn->kn_key=(void*)0;
			}
d362 1
a362 1
	return TCFS_OK;
d365 3
a367 1
int tcfs_keytab_push_gid(struct tcfs_mount *mp,tcfs_keytab *t, uid_t uid, gid_t gid, int k, char* key)
d369 1
a369 1
	int pos=0;
d372 1
a372 1
	q=r=tcfs_keytab_fetch_gid(t,gid);
d374 12
a385 13
	if(r==NIL)
	{
		q=tcfs_keytab_newgidnode();
		if(!q)
			return ENOMEM;

		pos=tcfs_keytab_hash(gid);

		p=t->node[pos];
		q->kn_n=p;
		if(p!=NIL)
			p->kn_p=q;
		t->node[pos]=q;
d388 3
a390 3
		q->kn_gid=gid;
		q->kn_pid=0;
		q->kn_uid=0;
d393 1
a393 1
	return tcfs_keytab_push_gidpart(mp,q,uid,gid,k,key);
d396 2
a397 1
int tcfs_keytab_rm_uid(tcfs_keytab *t, uid_t uid)
d399 1
a399 1
	int pos=0;
d402 9
a410 11
	p=tcfs_keytab_fetch_uid(t,uid);
	if(p==NIL)
		return EINVAL;

	if(p->kn_p==NIL)
		{
		 pos=tcfs_keytab_hash(uid);
		 t->node[pos]=p->kn_n;
		}
	else
		 p->kn_p->kn_n=p->kn_n;
d412 2
a413 2
	if(p->kn_n!=NIL)
		p->kn_n->kn_p=p->kn_p;	 
d418 1
a418 1
	return TCFS_OK;
d421 2
a422 1
int tcfs_keytab_rm_pid(tcfs_keytab *t, uid_t uid, pid_t pid)
d424 1
a424 1
	int pos=0;
d427 9
a435 3
	p=tcfs_keytab_fetch_pid(t,uid,pid);
	if(p==NIL)
		return EINVAL;
d437 2
a438 10
	if(p->kn_p==NIL)
		{
		 pos=tcfs_keytab_hash(pid);
		 t->node[pos]=p->kn_n;
		}
	else
		 p->kn_p->kn_n=p->kn_n;

	if(p->kn_n!=NIL)
		p->kn_n->kn_p=p->kn_p;	 
d443 1
a443 1
	return TCFS_OK;
d446 2
a447 1
int tcfs_keytab_rm_gid(tcfs_keytab *t, uid_t uid, gid_t gid)
d449 1
a449 1
	int pos=0,ret=0;
d452 3
a454 3
	p=tcfs_keytab_fetch_gid(t,gid);
	if(p==NIL)
		return EINVAL;
d456 1
a456 1
	ret=tcfs_keytab_rm_gidpart(p,uid,gid);
d459 1
a459 1
		return ret; 	
d461 2
a462 2
	if(!IS_CLEAN_GD(p->kn_data))
		return TCFS_OK;
d464 5
a468 7
	if(p->kn_p==NIL)
		{
		 pos=tcfs_keytab_hash(gid);
		 t->node[pos]=p->kn_n;
		}
	else
		 p->kn_p->kn_n=p->kn_n;
d470 2
a471 2
	if(p->kn_n!=NIL)
		p->kn_n->kn_p=p->kn_p;	 
d476 1
a476 1
	return TCFS_OK;
a477 1

@


1.1
log
@initial import of tcfs.
@
text
@d1 27
@

