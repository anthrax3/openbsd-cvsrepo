head	1.24;
access;
symbols
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.6
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2005.12.11.21.30.31;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2005.11.04.21.48.07;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.20.09.20.41;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.05.23.52.10;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.09.01.34.00;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.30.20.45.35;	author nordin;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.20.11.27.52;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.01.44.23;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.09.19.18.06.17;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.04.58.43;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.24.07.32.43;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.15.02.44.12;	author ericj;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	99.02.26.03.46.25;	author art;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	98.08.30.13.42.14;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	97.09.11.05.26.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.29.04.24.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.16.02.00.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.22.04.15.17;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	97.01.07.05.37.35;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.08.03.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches;
next	;

1.9.6.1
date	2001.05.14.22.32.55;	author niklas;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2001.07.04.10.49.15;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2001.10.31.03.26.30;	author nate;	state Exp;
branches;
next	1.9.6.4;

1.9.6.4
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.9.6.5;

1.9.6.5
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.9.6.6;

1.9.6.6
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.9.6.7;

1.9.6.7
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.9.6.8;

1.9.6.8
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.9.6.9;

1.9.6.9
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2002.02.20.08.52.36;	author miod;	state Exp;
branches;
next	;

1.14.2.1
date	2002.01.23.03.10.01;	author jason;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.42;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.22.36.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@/*	$OpenBSD: procfs_mem.c,v 1.23 2005/11/04 21:48:07 miod Exp $	*/
/*	$NetBSD: procfs_mem.c,v 1.8 1996/02/09 22:40:50 christos Exp $	*/

/*
 * Copyright (c) 1993 Jan-Simon Pendry
 * Copyright (c) 1993 Sean Eric Fagan
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry and Sean Eric Fagan.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)procfs_mem.c	8.5 (Berkeley) 6/15/94
 */

/*
 * This is a lightly hacked and merged version
 * of sef's pread/pwrite functions
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <miscfs/procfs/procfs.h>

#include <uvm/uvm_extern.h>

/*
 * Copy data in and out of the target process.
 * We do this by mapping the process's page into
 * the kernel and then doing a uiomove direct
 * from the kernel address space.
 */
int
procfs_domem(curp, p, pfs, uio)
	struct proc *curp;		/* tracer */
	struct proc *p;			/* traced */
	struct pfsnode *pfs;
	struct uio *uio;
{
	int error;
	vaddr_t addr;
	vsize_t len;

	len = uio->uio_resid;
	if (len == 0)
		return (0);

	if ((error = procfs_checkioperm(curp, p)) != 0)
		return (error);

	/* XXXCDC: how should locking work here? */
	if ((p->p_flag & P_WEXIT) || (p->p_vmspace->vm_refcnt < 1)) 
		return(EFAULT);
	addr = uio->uio_offset;
	p->p_vmspace->vm_refcnt++;  /* XXX */
	error = uvm_io(&p->p_vmspace->vm_map, uio,
	    uio->uio_rw == UIO_WRITE ? UVM_IO_FIXPROT : 0);
	uvmspace_free(p->p_vmspace);

	if (error == 0 && uio->uio_rw == UIO_WRITE)
		pmap_proc_iflush(p, addr, len);

	return error;
}

/*
 * Ensure that a process has permission to perform I/O on another.
 * Arguments:
 *	p   The process wishing to do the I/O (the tracer).
 *	t   The process who's memory/registers will be read/written.
 *
 * You cannot attach to a process's mem/regs if:
 *
 *	(1) It's not owned by you, or the last exec
 *	    gave us setuid/setgid privs (unless
 *	    you're root), or...
 *
 *	(2) It's init, which controls the security level
 *	    of the entire system, and the system was not
 *	    compiled with permanently insecure mode turned
 *	    on.
 *
 *      (3) It's currently execing.
 */
int
procfs_checkioperm(p, t)
	struct proc *p, *t;
{
	int error;

	if ((t->p_cred->p_ruid != p->p_cred->p_ruid ||
	    ISSET(t->p_flag, P_SUGIDEXEC) ||
	    ISSET(t->p_flag, P_SUGID)) &&
	    (error = suser(p, 0)) != 0)
		return (error);

	if ((t->p_pid == 1) && (securelevel > -1))
		return (EPERM);

	if (t->p_flag & P_INEXEC)
		return (EAGAIN);

	return (0);
}
@


1.23
log
@Add an extra flags argument to uvm_io(), to specify whether we want to fix
the protection of the memory mapping we're doing I/O on, or if we want to
leave them as they are. This should only be necessary for breakpoint
insertion in code, so we'll only use it for ptrace requests.

Initially from art@@ after discussion with kettenis@@ millert@@ and I,
tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.22 2004/05/20 09:20:41 kettenis Exp $	*/
@


1.22
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.21 2004/05/05 23:52:10 tedu Exp $	*/
d84 2
a85 1
	error = uvm_io(&p->p_vmspace->vm_map, uio);
@


1.21
log
@make sure uio_offset is a safe value, with suggestions from millert@@
ok deraadt@@ millert@@
problem noticed by deprotect.com
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.20 2003/08/15 20:32:19 tedu Exp $	*/
d69 2
d72 2
a73 1
	if (uio->uio_resid == 0)
d78 1
d82 1
d86 3
@


1.20
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.19 2003/06/02 23:28:11 millert Exp $	*/
a123 1

@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.18 2003/03/09 01:34:00 millert Exp $	*/
d113 1
a113 1
	    (error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.18
log
@Disallow ptrace if P_SUGIDEXEC flag is set (we already disallow if P_SUGID
is set).  deraadt@@ and tholo@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.17 2002/01/30 20:45:35 nordin Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.16 2002/01/20 11:27:52 art Exp $	*/
d115 1
@


1.16
log
@When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.15 2001/11/06 01:44:23 art Exp $	*/
a57 2

#define	ISSET(t, f)	((t) & (f))
@


1.15
log
@redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.14 2001/09/19 18:06:17 art Exp $	*/
d107 2
d123 3
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.17 2002/01/30 20:45:35 nordin Exp $	*/
d59 2
a106 2
 *
 *      (3) It's currently execing.
a120 3

	if (t->p_flag & P_INEXEC)
		return (EAGAIN);
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a114 1
	    ISSET(t->p_flag, P_SUGIDEXEC) ||
@


1.14
log
@No need to PHOLD/PRELE here, really.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.13 2001/09/11 20:05:25 miod Exp $	*/
a55 2
#include <vm/vm.h>
#include <vm/vm_page.h>
@


1.14.2.1
log
@Pull in patch from current:
Errata 012:
A race condition between the ptrace(2) and execve(2) system
calls allows an attacker to modify the memory contents of
suid/sgid processes which could lead to compromise of the
super-user account.
Fix (art):
When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.14 2001/09/19 18:06:17 art Exp $	*/
a108 2
 *
 *      (3) It's currently execing.
a122 3

	if (t->p_flag & P_INEXEC)
		return (EAGAIN);
@


1.13
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.12 2001/06/27 04:58:43 art Exp $	*/
a85 1
	PHOLD(p);
a87 1
	PRELE(p);
@


1.12
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.11 2001/05/24 07:32:43 aaron Exp $	*/
a56 1
#include <vm/vm_kern.h>
@


1.11
log
@Garbage collect procfs_findtextvp().
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.10 2000/08/15 02:44:12 ericj Exp $	*/
a59 1
#if defined(UVM)
a60 1
#endif
a63 145
#if !defined(UVM)
int
procfs_rwmem(p, uio)
	struct proc *p;
	struct uio *uio;
{
	int error;
	int writing;

	writing = uio->uio_rw == UIO_WRITE;

	/*
	 * Only map in one page at a time.  We don't have to, but it
	 * makes things easier.  This way is trivial - right?
	 */
	do {
		vm_map_t map, tmap;
		vm_object_t object;
		vm_offset_t kva;
		vm_offset_t uva;
		int page_offset;		/* offset into page */
		vm_offset_t pageno;		/* page number */
		vm_map_entry_t out_entry;
		vm_prot_t out_prot;
		vm_page_t m;
		boolean_t wired, single_use;
		vm_offset_t off;
		u_int len;
		int fix_prot;

		uva = (vm_offset_t) uio->uio_offset;
		if (uva > VM_MAXUSER_ADDRESS) {
			error = 0;
			break;
		}

		/*
		 * Get the page number of this segment.
		 */
		pageno = trunc_page(uva);
		page_offset = uva - pageno;

		/*
		 * How many bytes to copy
		 */
		len = min(PAGE_SIZE - page_offset, uio->uio_resid);

		/*
		 * The map we want...
		 */
		map = &p->p_vmspace->vm_map;

		/*
		 * Check the permissions for the area we're interested
		 * in.
		 */
		fix_prot = 0;
		if (writing)
			fix_prot = !vm_map_check_protection(map, pageno,
					pageno + PAGE_SIZE, VM_PROT_WRITE);

		if (fix_prot) {
			/*
			 * If the page is not writable, we make it so.
			 * XXX It is possible that a page may *not* be
			 * read/executable, if a process changes that!
			 * We will assume, for now, that a page is either
			 * VM_PROT_ALL, or VM_PROT_READ|VM_PROT_EXECUTE.
			 */
			error = vm_map_protect(map, pageno,
					pageno + PAGE_SIZE, VM_PROT_ALL, 0);
			if (error)
				break;
		}

		/*
		 * Now we need to get the page.  out_entry, out_prot, wired,
		 * and single_use aren't used.  One would think the vm code
		 * would be a *bit* nicer...  We use tmap because
		 * vm_map_lookup() can change the map argument.
		 */
		tmap = map;
		error = vm_map_lookup(&tmap, pageno,
				      writing ? VM_PROT_WRITE : VM_PROT_READ,
				      &out_entry, &object, &off, &out_prot,
				      &wired, &single_use);
		/*
		 * We're done with tmap now.
		 */
		if (!error)
			vm_map_lookup_done(tmap, out_entry);

		/*
		 * Fault the page in...
		 */
		if (!error && writing && object->shadow) {
			m = vm_page_lookup(object, off);
			if (m == 0 || (m->flags & PG_COPYONWRITE)) {
#ifdef __i386__
				pmap_prefault(map, uva, 4);
#endif
				error = vm_fault(map, pageno,
							VM_PROT_WRITE, FALSE);
				}
		}

		/* Find space in kernel_map for the page we're interested in */
		if (!error) {
			kva = VM_MIN_KERNEL_ADDRESS;
			error = vm_map_find(kernel_map, object, off, &kva,
					PAGE_SIZE, 1);
		}

		if (!error) {
			/*
			 * Neither vm_map_lookup() nor vm_map_find() appear
			 * to add a reference count to the object, so we do
			 * that here and now.
			 */
			vm_object_reference(object);

			/*
			 * Mark the page we just found as pageable.
			 */
			error = vm_map_pageable(kernel_map, kva,
				kva + PAGE_SIZE, 0);

			/*
			 * Now do the i/o move.
			 */
			if (!error)
				error = uiomove((caddr_t) (kva + page_offset),
						len, uio);

			vm_map_remove(kernel_map, kva, kva + PAGE_SIZE);
		}
		if (fix_prot)
			vm_map_protect(map, pageno, pageno + PAGE_SIZE,
					VM_PROT_READ|VM_PROT_EXECUTE, 0);
	} while (error == 0 && uio->uio_resid > 0);

	return (error);
}
#endif

a83 1
#if defined(UVM)
a91 5
#else
	PHOLD(p);
	error = procfs_rwmem(p, uio);
	PRELE(p);
#endif
@


1.10
log
@make procfs compile on non-uvm systems
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.9 1999/02/26 03:46:25 art Exp $	*/
a249 19
 * Given process (p), find the vnode from which
 * it's text segment is being executed.
 *
 * It would be nice to grab this information from
 * the VM system, however, there is no sure-fire
 * way of doing that.  Instead, fork(), exec() and
 * wait() all maintain the p_textvp field in the
 * process proc structure which contains a held
 * reference to the exec'ed vnode.
 */
struct vnode *
procfs_findtextvp(p)
	struct proc *p;
{

	return (p->p_textvp);
}

/*
a282 66
#ifdef probably_never
/*
 * Given process (p), find the vnode from which
 * it's text segment is being mapped.
 *
 * (This is here, rather than in procfs_subr in order
 * to keep all the VM related code in one place.)
 */
struct vnode *
procfs_findtextvp(p)
	struct proc *p;
{
	int error;
	vm_object_t object;
	vm_offset_t pageno;		/* page number */

	/* find a vnode pager for the user address space */

	for (pageno = VM_MIN_ADDRESS;
			pageno < VM_MAXUSER_ADDRESS;
			pageno += PAGE_SIZE) {
		vm_map_t map;
		vm_map_entry_t out_entry;
		vm_prot_t out_prot;
		boolean_t wired, single_use;
		vm_offset_t off;

		map = &p->p_vmspace->vm_map;
		error = vm_map_lookup(&map, pageno,
			      VM_PROT_READ,
			      &out_entry, &object, &off, &out_prot,
			      &wired, &single_use);

		if (!error) {
			vm_pager_t pager;

			printf("procfs: found vm object\n");
			vm_map_lookup_done(map, out_entry);
			printf("procfs: vm object = %p\n", object);

			/*
			 * At this point, assuming no errors, object
			 * is the VM object mapping UVA (pageno).
			 * Ensure it has a vnode pager, then grab
			 * the vnode from that pager's handle.
			 */

			pager = object->pager;
			printf("procfs: pager = %p\n", pager);
			if (pager)
				printf("procfs: found pager, type = %d\n",
				    pager->pg_type);
			if (pager && pager->pg_type == PG_VNODE) {
				struct vnode *vp;

				vp = (struct vnode *) pager->pg_handle;
				printf("procfs: vp = %p\n", vp);
				return (vp);
			}
		}
	}

	printf("procfs: text object not found\n");
	return (0);
}
#endif /* probably_never */
@


1.10.4.1
log
@MFC, requested by art@@ some time ago:
When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.10 2000/08/15 02:44:12 ericj Exp $	*/
a283 2
 *
 *	(3) It's currently execing.
a297 3

	if (t->p_flag & P_INEXEC)
		return (EAGAIN);
@


1.9
log
@memory reads from other vmspace are different under uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.8 1998/08/30 13:42:14 pefo Exp $	*/
d67 1
a67 3
static int procfs_rwmem __P((struct proc *, struct uio *));

static int
@


1.9.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.10 2000/08/15 02:44:12 ericj Exp $	*/
d67 3
a69 1
int
@


1.9.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.9.6.1 2001/05/14 22:32:55 niklas Exp $	*/
d60 1
d62 1
d66 145
d231 1
d240 5
d250 19
d302 66
@


1.9.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.9.6.2 2001/07/04 10:49:15 niklas Exp $	*/
d57 1
d87 1
d90 1
@


1.9.6.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 2
@


1.9.6.5
log
@Merge in trunk
@
text
@d59 2
a106 2
 *
 *      (3) It's currently execing.
a120 3

	if (t->p_flag & P_INEXEC)
		return (EAGAIN);
@


1.9.6.6
log
@Sync the SMP branch with 3.3
@
text
@a114 1
	    ISSET(t->p_flag, P_SUGIDEXEC) ||
@


1.9.6.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.9.6.6 2003/03/28 00:00:20 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.6.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 1
	    (error = suser(p, 0)) != 0)
@


1.9.6.9
log
@Merge with the trunk
@
text
@a68 2
	vaddr_t addr;
	vsize_t len;
d70 1
a70 2
	len = uio->uio_resid;
	if (len == 0)
a74 1

a77 1
	addr = uio->uio_offset;
a81 3
	if (error == 0 && uio->uio_rw == UIO_WRITE)
		pmap_proc_iflush(p, addr, len);

d124 1
@


1.8
log
@OK, this is another fix for the infamous i386 "PTDI panic". This fix is the
same as is used in 'vslock()'. The situation when this occurs is when a
process tries to read or write to another process vm space and the _segment_
referenced have not yet been mapped. A certain way of crashing a system is
to debug a program larger than 4 Mb (yes, those critters exist!). Set a break
in an address above 4 Mb and pmap_enter panics because it can't fault in a
new ptd page since it is not the process itself that calls pmap_enter.
This is a fix, not a solution, but at least a user can't crash the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.7 1997/09/11 05:26:14 millert Exp $	*/
d60 4
d66 1
d211 1
d233 14
d248 1
a248 1
	return (procfs_rwmem(p, uio));
@


1.7
log
@Fix {KERNFS,NULLFS,UMAPFS,UNION}_DIAGNOSTIC kernel compilation errors.
From Alan Barrett <apb@@iafrica.com> with some changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.6 1997/08/29 04:24:38 millert Exp $	*/
d160 4
a163 1
			if (m == 0 || (m->flags & PG_COPYONWRITE))
d166 1
@


1.6
log
@From NetBSD (thorpej):
    Fix a reversed argument which caused procfs_checkioperm() to always
    return OK".  Add a few comments to avoid further confusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.5 1997/08/16 02:00:49 millert Exp $	*/
d318 1
a318 1
			printf("procfs: vm object = %x\n", object);
d328 1
a328 1
			printf("procfs: pager = %x\n", pager);
d336 1
a336 1
				printf("procfs: vp = 0x%x\n", vp);
@


1.5
log
@1) pfs_mode should be mode_t, not u_short
2) Fix procfs security hole.  This is basically the NetBSD fix
   (which is based in part on Sean Eric Fagan's FreeBSD fix)
   with a few minor changes.  The change creates as function,
   procfs_checkioperm(), that has check numbers 3 and 4 from sys_ptrace().
3) Make procfs_control() use procfs_checkioperm() as well (it
   already had the same basic checks but some of them were incorrect).
4) Minor stylistic cleanups, including the use of the SET/CLR/ISSET
   macros to aid general grokability.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.4 1997/01/22 04:15:17 tholo Exp $	*/
d211 2
a212 2
	struct proc *curp;
	struct proc *p;
d247 5
d254 1
a254 1
 *	(1) it's not owned by you, or the last exec
d258 1
a258 1
 *	(2) ...it's init, which controls the security level
d264 2
a265 2
procfs_checkioperm(t, p)
	struct proc *t, *p;
@


1.4
log
@Don't fault a page in twice (first prefault, then vm_fault); the first was
not neccecary (and actually caused some problems).
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.3 1997/01/07 05:37:35 tholo Exp $	*/
d60 2
d114 1
a114 1
  
d216 1
d221 3
d246 28
d325 2
a326 1
				printf("procfs: found pager, type = %d\n", pager->pg_type);
@


1.3
log
@Fix for final ptdi panic on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_mem.c,v 1.2 1996/02/27 08:03:36 niklas Exp $	*/
a151 4

#ifdef __i386__
		pmap_prefault(map, pageno, PAGE_SIZE);
#endif
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d152 5
a156 1
  
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: procfs_mem.c,v 1.7 1995/01/05 07:10:54 chopps Exp $	*/
d60 2
d188 2
a189 1
				error = uiomove(kva + page_offset, len, uio);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
