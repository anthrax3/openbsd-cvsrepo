head	1.61;
access;
symbols
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.56.0.2
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.55.0.4
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.2
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.52.0.2
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.47.0.4
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.45.0.8
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.4
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.38.0.4
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.4
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.26
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.6
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2014.09.08.01.57.00;	author guenther;	state dead;
branches;
next	1.60;
commitid	0HlTPhRuQ0I9ZG6q;

1.60
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	EF98ch02VpFassUi;

1.59
date	2014.01.21.01.48.22;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2014.01.20.03.23.42;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2013.03.28.02.08.39;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2012.06.20.17.30.22;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.53;

1.53
date	2011.12.24.04.34.20;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.51;

1.51
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.46;

1.46
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.09.23.38.37;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.09.10.22.50;	author thib;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2008.04.24.17.39.45;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.11.21.30.31;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.21.23.28.55;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.16.22.19.28;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.01.20.16.01;	author pedro;	state Exp;
branches;
next	1.33;

1.33
date	2004.10.19.12.42.28;	author pedro;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.20.18.32.38;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.07.23.43.25;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.06.23.40.13;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.00.42.25;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.11.15.39.27;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.30.20.29.44;	author nordin;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.04.22.44.32;	author art;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.23.02.14.25;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.24.07.32.43;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.24.04.09.39;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.09.07.14.23;	author tholo;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2000.08.12.04.29.24;	author jasoni;	state Exp;
branches;
next	1.14;

1.14
date	99.08.13.07.05.46;	author csapuntz;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.08.13.04.50.48;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.08.06.19.34.46;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	98.06.27.07.32.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.06.09.18.13.48;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.05.58.43;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.20.20.35;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.15.19.11;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.08.29.04.24.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.16.02.00.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.08.01.05.58.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.28.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.08.03.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.05.14.22.32.56;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.07.04.10.49.18;	author niklas;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.14.4.6;

1.14.4.6
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.14.4.7;

1.14.4.7
date	2003.05.13.19.21.30;	author ho;	state Exp;
branches;
next	1.14.4.8;

1.14.4.8
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.14.4.9;

1.14.4.9
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.14.4.10;

1.14.4.10
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2001.06.06.03.31.50;	author jason;	state Exp;
branches;
next	;

1.21.2.1
date	2002.01.31.22.55.42;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.06.11.03.30.21;	author art;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2003.05.19.22.36.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Actually remove the procfs files
@
text
@/*	$OpenBSD: procfs_vnops.c,v 1.60 2014/07/08 17:19:25 deraadt Exp $	*/
/*	$NetBSD: procfs_vnops.c,v 1.40 1996/03/16 23:52:55 christos Exp $	*/

/*
 * Copyright (c) 1993 Jan-Simon Pendry
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)procfs_vnops.c	8.8 (Berkeley) 6/15/94
 */

/*
 * procfs vnode interface
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/namei.h>
#include <sys/malloc.h>
#include <sys/dirent.h>
#include <sys/resourcevar.h>
#include <sys/poll.h>
#include <sys/ptrace.h>
#include <sys/stat.h>

#include <machine/reg.h>

#include <miscfs/procfs/procfs.h>

/*
 * Vnode Operations.
 *
 */
static int procfs_validfile_linux(struct proc *, struct mount *);

/*
 * This is a list of the valid names in the
 * process-specific sub-directories.  It is
 * used in procfs_lookup and procfs_readdir
 */
struct proc_target {
	u_char	pt_type;
	u_char	pt_namlen;
	char	*pt_name;
	pfstype	pt_pfstype;
	int	(*pt_valid)(struct proc *p, struct mount *mp);
} proc_targets[] = {
#define N(s) sizeof(s)-1, s
	/*	  name		type		validp */
	{ DT_DIR, N("."),	Pproc,		NULL },
	{ DT_DIR, N(".."),	Proot,		NULL },
	{ DT_REG, N("file"),	Pfile,		procfs_validfile },
	{ DT_REG, N("mem"),	Pmem,		NULL },
	{ DT_REG, N("status"),	Pstatus,	NULL },
	{ DT_REG, N("cmdline"), Pcmdline,	NULL },
	{ DT_REG, N("exe"),	Pfile,		procfs_validfile_linux },
#undef N
};
static int nproc_targets = sizeof(proc_targets) / sizeof(proc_targets[0]);

/*
 * List of files in the root directory.  Note: the validate function
 * will be called with p == NULL for these
 */
struct proc_target proc_root_targets[] = {
#define N(s) sizeof(s)-1, s
	/*	  name		type		validp */
	{ DT_REG, N("meminfo"),	Pmeminfo,	procfs_validfile_linux },
	{ DT_REG, N("cpuinfo"),	Pcpuinfo,	procfs_validfile_linux },
#undef N
};
static int nproc_root_targets =
    sizeof(proc_root_targets) / sizeof(proc_root_targets[0]);

static pid_t atopid(const char *, u_int);

/*
 * Prototypes for procfs vnode ops
 */
int	procfs_badop(void *);

int	procfs_lookup(void *);
int	procfs_open(void *);
int	procfs_close(void *);
int	procfs_access(void *);
int	procfs_getattr(void *);
int	procfs_setattr(void *);
int	procfs_ioctl(void *);
int	procfs_link(void *);
int	procfs_symlink(void *);
int	procfs_readdir(void *);
int	procfs_readlink(void *);
int	procfs_inactive(void *);
int	procfs_reclaim(void *);
int	procfs_print(void *);
int	procfs_pathconf(void *);

static pid_t atopid(const char *, u_int);

/*
 * procfs vnode operations.
 */
struct vops procfs_vops = {
	.vop_lookup	= procfs_lookup,
	.vop_create	= procfs_badop,
	.vop_mknod	= procfs_badop,
	.vop_open	= procfs_open,
	.vop_close	= procfs_close,
	.vop_access	= procfs_access,
	.vop_getattr	= procfs_getattr,
	.vop_setattr	= procfs_setattr,
	.vop_read	= procfs_rw,
	.vop_write	= procfs_rw,
	.vop_ioctl	= procfs_ioctl,
	.vop_poll	= procfs_poll,
	.vop_fsync	= procfs_badop,
	.vop_remove	= procfs_badop,
	.vop_link	= procfs_link,
	.vop_rename	= procfs_badop,
	.vop_mkdir	= procfs_badop,
	.vop_rmdir	= procfs_badop,
	.vop_symlink	= procfs_symlink,
	.vop_readdir	= procfs_readdir,
	.vop_readlink	= procfs_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= procfs_inactive,
	.vop_reclaim	= procfs_reclaim,
	.vop_lock	= nullop,
	.vop_unlock	= nullop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= procfs_badop,
	.vop_print	= procfs_print,
	.vop_islocked	= nullop,
	.vop_pathconf	= procfs_pathconf,
	.vop_advlock	= procfs_badop,
};
/*
 * set things up for doing i/o on
 * the pfsnode (vp).  (vp) is locked
 * on entry, and should be left locked
 * on exit.
 *
 * for procfs we don't need to do anything
 * in particular for i/o.  all that is done
 * is to support exclusive open on process
 * memory images.
 */
int
procfs_open(void *v)
{
	struct vop_open_args *ap = v;
	struct pfsnode *pfs = VTOPFS(ap->a_vp);
	struct proc *p1 = ap->a_p;	/* tracer */
	struct proc *p2;		/* traced */
	int error;

	if ((p2 = pfind(pfs->pfs_pid)) == 0 || (p2->p_flag & P_THREAD))
		return (ENOENT);	/* was ESRCH, jsp */

	switch (pfs->pfs_type) {
	case Pmem:
		if (((pfs->pfs_flags & FWRITE) && (ap->a_mode & O_EXCL)) ||
		    ((pfs->pfs_flags & O_EXCL) && (ap->a_mode & FWRITE)))
			return (EBUSY);

		if ((error = process_checkioperm(p1, p2->p_p)) != 0)
			return (error);

		if (ap->a_mode & FWRITE)
			pfs->pfs_flags = ap->a_mode & (FWRITE|O_EXCL);

		return (0);

	default:
		break;
	}

	return (0);
}

/*
 * close the pfsnode (vp) after doing i/o.
 * (vp) is not locked on entry or exit.
 *
 * nothing to do for procfs other than undo
 * any exclusive open flag (see _open above).
 */
int
procfs_close(void *v)
{
	struct vop_close_args *ap = v;
	struct pfsnode *pfs = VTOPFS(ap->a_vp);

	switch (pfs->pfs_type) {
	case Pmem:
		if ((ap->a_fflag & FWRITE) && (pfs->pfs_flags & O_EXCL))
			pfs->pfs_flags &= ~(FWRITE|O_EXCL);
		break;
	case Pctl:
	case Pstatus:
	case Pnotepg:
	case Pnote:
	case Proot:
	case Pcurproc:
	case Pself:
	case Pproc:
	case Pfile:
	case Pregs:
	case Pfpregs:
	case Pcmdline:
	case Pmeminfo:
	case Pcpuinfo:
		break;
	}

	return (0);
}

/*
 * do an ioctl operation on pfsnode (vp).
 * (vp) is not locked on entry or exit.
 */
/*ARGSUSED*/
int
procfs_ioctl(void *v)
{

	return (ENOTTY);
}

/*
 * _inactive is called when the pfsnode
 * is vrele'd and the reference count goes
 * to zero.  (vp) will be on the vnode free
 * list, so to get it back vget() must be
 * used.
 *
 * for procfs, check if the process is still
 * alive and if it isn't then just throw away
 * the vnode by calling vgone().  this may
 * be overkill and a waste of time since the
 * chances are that the process will still be
 * there and pfind is not free.
 *
 * (vp) is not locked on entry or exit.
 */
int
procfs_inactive(void *v)
{
	struct vop_inactive_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct pfsnode *pfs = VTOPFS(vp);

	if (pfind(pfs->pfs_pid) == NULL && !(vp->v_flag & VXLOCK))
		vgone(vp);

	return (0);
}

/*
 * _reclaim is called when getnewvnode()
 * wants to make use of an entry on the vnode
 * free list.  at this time the filesystem needs
 * to free any private data and remove the node
 * from any private lists.
 */
int
procfs_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;

	return (procfs_freevp(ap->a_vp));
}

/*
 * Return POSIX pathconf information applicable to special devices.
 */
int
procfs_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * _print is used for debugging.
 * just print a readable description
 * of (vp).
 */
int
procfs_print(void *v)
{
	struct vop_print_args *ap = v;
	struct pfsnode *pfs = VTOPFS(ap->a_vp);

	printf("tag VT_PROCFS, type %d, pid %d, mode %x, flags %lx\n",
	    pfs->pfs_type, pfs->pfs_pid, pfs->pfs_mode, pfs->pfs_flags);
	return 0;
}

int
procfs_link(void *v)
{
	struct vop_link_args *ap = v;

	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

int
procfs_symlink(void *v)
{
	struct vop_symlink_args *ap = v;

	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}


/*
 * generic entry point for unsupported operations
 */
/*ARGSUSED*/
int
procfs_badop(void *v)
{

	return (EIO);
}

/*
 * Invent attributes for pfsnode (vp) and store
 * them in (vap).
 * Directories lengths are returned as zero since
 * any real length would require the genuine size
 * to be computed, and nothing cares anyway.
 *
 * this is relatively minimal for procfs.
 */
int
procfs_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct pfsnode *pfs = VTOPFS(ap->a_vp);
	struct vattr *vap = ap->a_vap;
	struct proc *procp;
	int error;

	/* first check the process still exists */
	switch (pfs->pfs_type) {
	case Proot:
	case Pcurproc:
	case Pcpuinfo:
	case Pmeminfo:
		procp = 0;
		break;

	default:
		procp = pfind(pfs->pfs_pid);
		if (procp == 0 || (procp->p_flag & P_THREAD))
			return (ENOENT);
	}

	error = 0;

	/* start by zeroing out the attributes */
	VATTR_NULL(vap);

	/* next do all the common fields */
	vap->va_type = ap->a_vp->v_type;
	vap->va_mode = pfs->pfs_mode;
	vap->va_fileid = pfs->pfs_fileno;
	vap->va_flags = 0;
	vap->va_blocksize = PAGE_SIZE;
	vap->va_bytes = vap->va_size = 0;

	/*
	 * Make all times be current TOD.
	 * It would be possible to get the process start
	 * time from the p_stat structure, but there's
	 * no "file creation" time stamp anyway, and the
	 * p_stat structure is not addressible if u. gets
	 * swapped out for that process.
	 */
	getnanotime(&vap->va_ctime);
	vap->va_atime = vap->va_mtime = vap->va_ctime;

	switch (pfs->pfs_type) {
	case Pregs:
	case Pfpregs:
#ifndef PTRACE
		break;
#endif
	case Pmem:
		/*
		 * If the process has exercised some setuid or setgid
		 * privilege, then rip away read/write permission so
		 * that only root can gain access.
		 */
		if (procp->p_p->ps_flags & PS_SUGID)
			vap->va_mode &= ~(S_IRUSR|S_IWUSR);
		/* FALLTHROUGH */
	case Pctl:
	case Pstatus:
	case Pnote:
	case Pnotepg:
	case Pcmdline:
		vap->va_nlink = 1;
		vap->va_uid = procp->p_ucred->cr_uid;
		vap->va_gid = procp->p_ucred->cr_gid;
		break;
	case Pmeminfo:
	case Pcpuinfo:
		vap->va_nlink = 1;
		vap->va_uid = vap->va_gid = 0;
		break;
	case Pproc:
	case Pfile:
	case Proot:
	case Pcurproc:
	case Pself:
		break;
	}

	/*
	 * now do the object specific fields
	 *
	 * The size could be set from struct reg, but it's hardly
	 * worth the trouble, and it puts some (potentially) machine
	 * dependent data into this machine-independent code.  If it
	 * becomes important then this function should break out into
	 * a per-file stat function in the corresponding .c file.
	 */

	switch (pfs->pfs_type) {
	case Proot:
		/*
		 * Set nlink to 1 to tell fts(3) we don't actually know.
		 */
		vap->va_nlink = 1;
		vap->va_uid = 0;
		vap->va_gid = 0;
		vap->va_size = vap->va_bytes = DEV_BSIZE;
		break;

	case Pcurproc: {
		char buf[16];		/* should be enough */
		int len;

		len = snprintf(buf, sizeof buf, "%ld", (long)curproc->p_pid);
		if (len == -1 || len >= sizeof buf) {
			error = EINVAL;
			break;
		}
		vap->va_nlink = 1;
		vap->va_uid = 0;
		vap->va_gid = 0;
		vap->va_size = vap->va_bytes = len;
		break;
	}

	case Pself:
		vap->va_nlink = 1;
		vap->va_uid = 0;
		vap->va_gid = 0;
		vap->va_size = vap->va_bytes = sizeof("curproc");
		break;

	case Pproc:
		vap->va_nlink = 2;
		vap->va_uid = procp->p_ucred->cr_uid;
		vap->va_gid = procp->p_ucred->cr_gid;
		vap->va_size = vap->va_bytes = DEV_BSIZE;
		break;

	case Pfile:
		error = EOPNOTSUPP;
		break;

	case Pmem:
		vap->va_bytes = vap->va_size =
			ptoa(procp->p_vmspace->vm_tsize +
				    procp->p_vmspace->vm_dsize +
				    procp->p_vmspace->vm_ssize);
		break;

	case Pregs:
#ifdef PTRACE
		vap->va_bytes = vap->va_size = sizeof(struct reg);
#endif
		break;

	case Pfpregs:
#if defined(PT_GETFPREGS) || defined(PT_SETFPREGS)
#ifdef PTRACE
		vap->va_bytes = vap->va_size = sizeof(struct fpreg);
#endif
#endif
		break;

	case Pctl:
	case Pstatus:
	case Pnote:
	case Pnotepg:
	case Pcmdline:
	case Pmeminfo:
	case Pcpuinfo:
		vap->va_bytes = vap->va_size = 0;
		break;

#ifdef DIAGNOSTIC
	default:
		panic("procfs_getattr");
#endif
	}

	return (error);
}

/*ARGSUSED*/
int
procfs_setattr(void *v)
{
	/*
	 * just fake out attribute setting
	 * it's not good to generate an error
	 * return, otherwise things like creat()
	 * will fail when they try to set the
	 * file length to 0.  worse, this means
	 * that echo $note > /proc/$pid/note will fail.
	 */

	return (0);
}

/*
 * implement access checking.
 *
 * actually, the check for super-user is slightly
 * broken since it will allow read access to write-only
 * objects.  this doesn't cause any particular trouble
 * but does mean that the i/o entry points need to check
 * that the operation really does make sense.
 */
int
procfs_access(void *v)
{
	struct vop_access_args *ap = v;
	struct vattr va;
	int error;

	if ((error = VOP_GETATTR(ap->a_vp, &va, ap->a_cred, ap->a_p)) != 0)
		return (error);

	return (vaccess(ap->a_vp->v_type, va.va_mode, va.va_uid, va.va_gid,
			ap->a_mode, ap->a_cred));
}

/*
 * lookup.  this is incredibly complicated in the
 * general case, however for most pseudo-filesystems
 * very little needs to be done.
 *
 * unless you want to get a migraine, just make sure your
 * filesystem doesn't do any locking of its own.  otherwise
 * read and inwardly digest ufs_lookup().
 */
int
procfs_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct vnode **vpp = ap->a_vpp;
	struct vnode *dvp = ap->a_dvp;
	char *pname = cnp->cn_nameptr;
	struct proc *curp = curproc;
	struct proc_target *pt;
	struct vnode *fvp;
	pid_t pid;
	struct pfsnode *pfs;
	struct proc *p = NULL;
	int i, error, wantpunlock, iscurproc = 0, isself = 0;

	*vpp = NULL;
	cnp->cn_flags &= ~PDIRUNLOCK;

	if (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME)
		return (EROFS);

	if (cnp->cn_namelen == 1 && *pname == '.') {
		*vpp = dvp;
		vref(dvp);
		return (0);
	}

	wantpunlock = (~cnp->cn_flags & (LOCKPARENT | ISLASTCN));
	pfs = VTOPFS(dvp);
	switch (pfs->pfs_type) {
	case Proot:
		if (cnp->cn_flags & ISDOTDOT)
			return (EIO);

		iscurproc = CNEQ(cnp, "curproc", 7);
		isself = CNEQ(cnp, "self", 4);

		if (iscurproc || isself) {
			error = procfs_allocvp(dvp->v_mount, vpp, 0,
			    iscurproc ? Pcurproc : Pself);
			if ((error == 0) && (wantpunlock)) {
				VOP_UNLOCK(dvp, 0, curp);
				cnp->cn_flags |= PDIRUNLOCK;
			}
			return (error);
		}

		for (i = 0; i < nproc_root_targets; i++) {
			pt = &proc_root_targets[i];
			if (cnp->cn_namelen == pt->pt_namlen &&
			    memcmp(pt->pt_name, pname, cnp->cn_namelen) == 0 &&
			    (pt->pt_valid == NULL ||
			     (*pt->pt_valid)(p, dvp->v_mount)))
				break;
		}

		if (i != nproc_root_targets) {
			error = procfs_allocvp(dvp->v_mount, vpp, 0,
			    pt->pt_pfstype);
			if ((error == 0) && (wantpunlock)) {
				VOP_UNLOCK(dvp, 0, curp);
				cnp->cn_flags |= PDIRUNLOCK;
			}
			return (error);
		}

		pid = atopid(pname, cnp->cn_namelen);
		if (pid == NO_PID)
			break;

		p = pfind(pid);
		if (p == 0 || (p->p_flag & P_THREAD))
			break;

		error = procfs_allocvp(dvp->v_mount, vpp, pid, Pproc);
		if ((error == 0) && wantpunlock) {
			VOP_UNLOCK(dvp, 0, curp);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (error);

	case Pproc:
		/*
		 * do the .. dance. We unlock the directory, and then
		 * get the root dir. That will automatically return ..
		 * locked. Then if the caller wanted dvp locked, we
		 * re-lock.
		 */
		if (cnp->cn_flags & ISDOTDOT) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
			error = procfs_root(dvp->v_mount, vpp);
			if ((error == 0) && (wantpunlock == 0) &&
			    ((error = vn_lock(dvp, LK_EXCLUSIVE, curp)) == 0))
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}

		p = pfind(pfs->pfs_pid);
		if (p == 0 || (p->p_flag & P_THREAD))
			break;

		for (pt = proc_targets, i = 0; i < nproc_targets; pt++, i++) {
			if (cnp->cn_namelen == pt->pt_namlen &&
			    bcmp(pt->pt_name, pname, cnp->cn_namelen) == 0 &&
			    (pt->pt_valid == NULL ||
			     (*pt->pt_valid)(p, dvp->v_mount)))
				goto found;
		}
		break;

	found:
		if (pt->pt_pfstype == Pfile) {
			fvp = p->p_p->ps_textvp;
			/* We already checked that it exists. */
			vref(fvp);
			vn_lock(fvp, LK_EXCLUSIVE | LK_RETRY, curp);
			if (wantpunlock) {
				VOP_UNLOCK(dvp, 0, curp);
				cnp->cn_flags |= PDIRUNLOCK;
			}
			*vpp = fvp;
			return (0);
		}

		error =  procfs_allocvp(dvp->v_mount, vpp, pfs->pfs_pid,
		    pt->pt_pfstype);
		if ((error == 0) && (wantpunlock)) {
			VOP_UNLOCK(dvp, 0, curp);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (error);

	default:
		return (ENOTDIR);
	}

	return (cnp->cn_nameiop == LOOKUP ? ENOENT : EROFS);
}

int
procfs_validfile(struct proc *p, struct mount *mp)
{

	return (p->p_p->ps_textvp != NULLVP);
}

int
procfs_validfile_linux(struct proc *p, struct mount *mp)
{
	int flags;

	flags = VFSTOPROC(mp)->pmnt_flags;
	return ((flags & PROCFSMNT_LINUXCOMPAT) &&
	    (p == NULL || procfs_validfile(p, mp)));
}

/*
 * readdir returns directory entries from pfsnode (vp).
 *
 * the strategy here with procfs is to generate a single
 * directory entry at a time (struct dirent) and then
 * copy that out to userland using uiomove.  a more efficent
 * though more complex implementation, would try to minimize
 * the number of calls to uiomove().  for procfs, this is
 * hardly worth the added code complexity.
 *
 * this should just be done through read()
 */
int
procfs_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	struct uio *uio = ap->a_uio;
	struct dirent d;
	struct pfsnode *pfs;
	struct vnode *vp;
	int i;
	int error;

	vp = ap->a_vp;
	pfs = VTOPFS(vp);

	if (uio->uio_resid < UIO_MX)
		return (EINVAL);

	error = 0;
	i = uio->uio_offset;
	if (i < 0)
		return (EINVAL);
	bzero(&d, UIO_MX);
	d.d_reclen = UIO_MX;

	switch (pfs->pfs_type) {
	/*
	 * this is for the process-specific sub-directories.
	 * all that is needed to is copy out all the entries
	 * from the procent[] table (top of this file).
	 */
	case Pproc: {
		struct proc *p;
		struct proc_target *pt;

		p = pfind(pfs->pfs_pid);
		if (p == NULL || (p->p_flag & P_THREAD))
			break;

		for (pt = &proc_targets[i];
		     uio->uio_resid >= UIO_MX && i < nproc_targets; pt++, i++) {
			if (pt->pt_valid &&
			    (*pt->pt_valid)(p, vp->v_mount) == 0)
				continue;
			
			d.d_fileno = PROCFS_FILENO(pfs->pfs_pid, pt->pt_pfstype);
			d.d_namlen = pt->pt_namlen;
			bcopy(pt->pt_name, d.d_name, pt->pt_namlen + 1);
			d.d_type = pt->pt_type;

			if ((error = uiomove(&d, UIO_MX, uio)) != 0)
				break;
		}

	    	break;
	}

	/*
	 * this is for the root of the procfs filesystem
	 * what is needed is a special entry for "curproc"
	 * followed by an entry for each process on allprocess
#ifdef PROCFS_ZOMBIE
	 * and zombprocess.
#endif
	 */

	case Proot: {
#ifdef PROCFS_ZOMBIE
		int doingzomb = 0;
#endif
		int pcnt = i;
		volatile struct process *pr = LIST_FIRST(&allprocess);

		if (pcnt > 3)
			pcnt = 3;
#ifdef PROCFS_ZOMBIE
	again:
#endif
		for (; pr && uio->uio_resid >= UIO_MX; i++, pcnt++) {
			switch (i) {
			case 0:		/* `.' */
			case 1:		/* `..' */
				d.d_fileno = PROCFS_FILENO(0, Proot);
				d.d_namlen = i + 1;
				bcopy("..", d.d_name, d.d_namlen);
				d.d_name[i + 1] = '\0';
				d.d_type = DT_DIR;
				break;

			case 2:
				d.d_fileno = PROCFS_FILENO(0, Pcurproc);
				d.d_namlen = 7;
				bcopy("curproc", d.d_name, 8);
				d.d_type = DT_LNK;
				break;

			case 3:
				d.d_fileno = PROCFS_FILENO(0, Pself);
				d.d_namlen = 4;
				bcopy("self", d.d_name, 5);
				d.d_type = DT_LNK;
				break;

			case 4:
				if (VFSTOPROC(vp->v_mount)->pmnt_flags &
				    PROCFSMNT_LINUXCOMPAT) {
					d.d_fileno = PROCFS_FILENO(0, Pcpuinfo);
					d.d_namlen = 7;
					bcopy("cpuinfo", d.d_name, 8);
					d.d_type = DT_REG;
					break;
				}
				/* fall through */

			case 5:
				if (VFSTOPROC(vp->v_mount)->pmnt_flags &
				    PROCFSMNT_LINUXCOMPAT) {
					d.d_fileno = PROCFS_FILENO(0, Pmeminfo);
					d.d_namlen = 7;
					bcopy("meminfo", d.d_name, 8);
					d.d_type = DT_REG;
					break;
				}
				/* fall through */

			default:
				while (pcnt < i)
					pcnt++;
				d.d_fileno = PROCFS_FILENO(pr->ps_pid, Pproc);
				d.d_namlen = snprintf(d.d_name, sizeof(d.d_name),
				    "%ld", (long)pr->ps_pid);
				d.d_type = DT_REG;
				break;
			}

			if ((error = uiomove(&d, UIO_MX, uio)) != 0)
				break;
		}
#ifdef PROCFS_ZOMBIE
		if (pr == NULL && doingzomb == 0) {
			doingzomb = 1;
			pr = LIST_FIRST(&zombprocess);
			goto again;
		}
#endif

		break;

	}

	default:
		error = ENOTDIR;
		break;
	}

	uio->uio_offset = i;
	return (error);
}

/*
 * readlink reads the link of `curproc'
 */
int
procfs_readlink(void *v)
{
	struct vop_readlink_args *ap = v;
	char buf[16];		/* should be enough */
	int len;

	if (VTOPFS(ap->a_vp)->pfs_fileno == PROCFS_FILENO(0, Pcurproc))
		len = snprintf(buf, sizeof buf, "%ld", (long)curproc->p_pid);
	else if (VTOPFS(ap->a_vp)->pfs_fileno == PROCFS_FILENO(0, Pself))
		len = strlcpy(buf, "curproc", sizeof buf);
	else
		return (EINVAL);
	if (len == -1 || len >= sizeof buf)
		return (EINVAL);

	return (uiomove(buf, len, ap->a_uio));
}

/*
 * convert decimal ascii to pid_t
 */
static pid_t
atopid(const char *b, u_int len)
{
	pid_t p = 0;

	while (len--) {
		char c = *b++;
		if (c < '0' || c > '9')
			return (NO_PID);
		p = 10 * p + (c - '0');
		if (p > PID_MAX)
			return (NO_PID);
	}

	return (p);
}
int
procfs_poll(void *v)
{
	struct vop_poll_args *ap = v;

	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}
@


1.60
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.59 2014/01/21 01:48:22 tedu Exp $	*/
@


1.59
log
@naughty guenther didn't compile
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.58 2014/01/20 21:19:28 guenther Exp $	*/
a57 2

#include <uvm/uvm_extern.h>	/* for PAGE_SIZE */
@


1.58
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.57 2014/01/20 03:23:42 guenther Exp $	*/
a925 2
	done:

@


1.57
log
@Move p_textvp from struct proc to struct process so that the exit code
can be further simplified.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.56 2013/03/28 02:08:39 guenther Exp $	*/
d848 1
a848 1
	 * followed by an entry for each process on allproc
d850 1
a850 1
	 * and zombproc.
d859 1
a859 1
		volatile struct proc *p = LIST_FIRST(&allproc);
d866 1
a866 3
		while (p && (p->p_flag & P_THREAD))
			p = LIST_NEXT(p, p_list);
		for (; p && uio->uio_resid >= UIO_MX; i++, pcnt++) {
d914 1
a914 1
				while (pcnt < i) {
d916 1
a916 7
					do {
						p = LIST_NEXT(p, p_list);
					} while (p && (p->p_flag & P_THREAD));
					if (!p)
						goto done;
				}
				d.d_fileno = PROCFS_FILENO(p->p_pid, Pproc);
d918 1
a918 1
				    "%ld", (long)p->p_pid);
a919 3
				do {
					p = LIST_NEXT(p, p_list);
				} while (p && (p->p_flag & P_THREAD));
d929 1
a929 1
		if (p == 0 && doingzomb == 0) {
d931 1
a931 1
			p = LIST_FIRST(&zombproc);
@


1.56
log
@Handle the pathconf _PC_PATH_MAX, _PC_PIPE_BUF, _PC_ASYNC_IO,
_PC_PRIO_IO, and _PC_SYNC_IO names in VOP_PATHCONF(), as they're
fs-independent for us.  Since we don't support latter three on any
fs, we can also define the related _POSIX_{ASYNC,PRIO,SYNC}_IO
symbols in <unistd.h> (via sys/unistd.h) with value -1.

Also, zap pointless tty-only values from procfs(!).

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.55 2012/06/20 17:30:22 matthew Exp $	*/
d733 1
a733 1
			fvp = p->p_textvp;
d764 1
a764 1
	return (p->p_textvp != NULLVP);
@


1.55
log
@Cleanup our filesystem pathconf() code a little bit to make it easier
to diff against FreeBSD's.

From Brad; no object file change on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.54 2012/02/20 22:23:39 guenther Exp $	*/
a322 9
	case _PC_MAX_CANON:
		*ap->a_retval = MAX_CANON;
		break;
	case _PC_MAX_INPUT:
		*ap->a_retval = MAX_INPUT;
		break;
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
		break;
a324 3
		break;
	case _PC_VDISABLE:
		*ap->a_retval = _POSIX_VDISABLE;
@


1.54
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.53 2011/12/24 04:34:20 guenther Exp $	*/
d317 1
d322 1
a322 1
		return (0);
d325 1
a325 1
		return (0);
d328 1
a328 1
		return (0);
d331 1
a331 1
		return (0);
d334 1
a334 1
		return (0);
d337 1
a337 1
		return (0);
d339 2
a340 1
		return (EINVAL);
d342 2
a343 1
	/* NOTREACHED */
@


1.53
log
@Remove the ability to ptrace via procfs, as no one is using it, so fixing
and extending it to support rthreads would be a waste of time.  Also, don't
show rthreads in the process listing in procfs.

Reassurances that compat_linux doesn't need this from ajacoutot@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.52 2011/04/05 14:14:07 thib Exp $	*/
d201 1
a201 1
		if ((error = process_checkioperm(p1, p2)) != 0)
@


1.52
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.51 2011/04/02 17:04:35 guenther Exp $	*/
a88 1
	{ DT_REG, N("ctl"),	Pctl,		NULL },
a89 2
	{ DT_REG, N("note"),	Pnote,		NULL },
	{ DT_REG, N("notepg"),	Pnotepg,	NULL },
d192 1
a192 1
	if ((p2 = pfind(pfs->pfs_pid)) == 0)
d420 1
a420 1
		if (procp == 0)
d700 1
a700 1
		if (p == 0)
d728 1
a728 1
		if (p == 0)
d833 1
a833 1
		if (p == NULL)
d875 2
d927 3
a929 1
					p = LIST_NEXT(p, p_list);
d937 3
a939 1
				p = LIST_NEXT(p, p_list);
@


1.51
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.50 2010/12/21 20:14:43 thib Exp $	*/
a141 1
	.vop_default	= eopnotsupp,
@


1.50
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.49 2010/09/10 16:34:08 thib Exp $	*/
d464 1
a464 1
		if (procp->p_flag & P_SUGID)
@


1.49
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.48 2010/09/06 23:44:10 thib Exp $	*/
d141 34
a174 36
int (**procfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc procfs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, procfs_lookup },
	{ &vop_create_desc, procfs_badop },
	{ &vop_mknod_desc, procfs_badop },
	{ &vop_open_desc, procfs_open },
	{ &vop_close_desc, procfs_close },
	{ &vop_access_desc, procfs_access },
	{ &vop_getattr_desc, procfs_getattr },
	{ &vop_setattr_desc, procfs_setattr },
	{ &vop_read_desc, procfs_rw },
	{ &vop_write_desc, procfs_rw },
	{ &vop_ioctl_desc, procfs_ioctl },
	{ &vop_poll_desc, procfs_poll },
	{ &vop_fsync_desc, procfs_badop},
	{ &vop_remove_desc, procfs_badop },
	{ &vop_link_desc, procfs_link },
	{ &vop_rename_desc, procfs_badop },
	{ &vop_mkdir_desc, procfs_badop },
	{ &vop_rmdir_desc, procfs_badop },
	{ &vop_symlink_desc, procfs_symlink },
	{ &vop_readdir_desc, procfs_readdir },
	{ &vop_readlink_desc, procfs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, procfs_inactive },
	{ &vop_reclaim_desc, procfs_reclaim },
	{ &vop_lock_desc, nullop },
	{ &vop_unlock_desc, nullop },
	{ &vop_bmap_desc, vop_generic_bmap },
	{ &vop_strategy_desc, procfs_badop },
	{ &vop_print_desc, procfs_print },
	{ &vop_islocked_desc, nullop },
	{ &vop_pathconf_desc, procfs_pathconf },
	{ &vop_advlock_desc, procfs_badop },
	{ NULL, NULL }
a175 2
struct vnodeopv_desc procfs_vnodeop_opv_desc =
	{ &procfs_vnodeop_p, procfs_vnodeop_entries };
@


1.48
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.47 2009/08/13 15:00:14 jasper Exp $	*/
d141 36
a176 34
struct vops procfs_vops = {
	.vop_default	= eopnotsupp,
	.vop_lookup	= procfs_lookup,
	.vop_create	= procfs_badop,
	.vop_mknod	= procfs_badop,
	.vop_open	= procfs_open,
	.vop_close	= procfs_close,
	.vop_access	= procfs_access,
	.vop_getattr	= procfs_getattr,
	.vop_setattr	= procfs_setattr,
	.vop_read	= procfs_rw,
	.vop_write	= procfs_rw,
	.vop_ioctl	= procfs_ioctl,
	.vop_poll	= procfs_poll,
	.vop_fsync	= procfs_badop,
	.vop_remove	= procfs_badop,
	.vop_link	= procfs_link,
	.vop_rename	= procfs_badop,
	.vop_mkdir	= procfs_badop,
	.vop_rmdir	= procfs_badop,
	.vop_symlink	= procfs_symlink,
	.vop_readdir	= procfs_readdir,
	.vop_readlink	= procfs_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= procfs_inactive,
	.vop_reclaim	= procfs_reclaim,
	.vop_lock	= nullop,
	.vop_unlock	= nullop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= procfs_badop,
	.vop_print	= procfs_print,
	.vop_islocked	= nullop,
	.vop_pathconf	= procfs_pathconf,
	.vop_advlock	= procfs_badop,
d178 2
@


1.47
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.46 2009/07/09 22:29:56 thib Exp $	*/
d141 34
a174 36
int (**procfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc procfs_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, procfs_lookup },
	{ &vop_create_desc, procfs_badop },
	{ &vop_mknod_desc, procfs_badop },
	{ &vop_open_desc, procfs_open },
	{ &vop_close_desc, procfs_close },
	{ &vop_access_desc, procfs_access },
	{ &vop_getattr_desc, procfs_getattr },
	{ &vop_setattr_desc, procfs_setattr },
	{ &vop_read_desc, procfs_rw },
	{ &vop_write_desc, procfs_rw },
	{ &vop_ioctl_desc, procfs_ioctl },
	{ &vop_poll_desc, procfs_poll },
	{ &vop_fsync_desc, procfs_badop},
	{ &vop_remove_desc, procfs_badop },
	{ &vop_link_desc, procfs_link },
	{ &vop_rename_desc, procfs_badop },
	{ &vop_mkdir_desc, procfs_badop },
	{ &vop_rmdir_desc, procfs_badop },
	{ &vop_symlink_desc, procfs_symlink },
	{ &vop_readdir_desc, procfs_readdir },
	{ &vop_readlink_desc, procfs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, procfs_inactive },
	{ &vop_reclaim_desc, procfs_reclaim },
	{ &vop_lock_desc, nullop },
	{ &vop_unlock_desc, nullop },
	{ &vop_bmap_desc, vop_generic_bmap },
	{ &vop_strategy_desc, procfs_badop },
	{ &vop_print_desc, procfs_print },
	{ &vop_islocked_desc, nullop },
	{ &vop_pathconf_desc, procfs_pathconf },
	{ &vop_advlock_desc, procfs_badop },
	{ NULL, NULL }
a175 2
struct vnodeopv_desc procfs_vnodeop_opv_desc =
	{ &procfs_vnodeop_p, procfs_vnodeop_entries };
@


1.46
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.44 2008/05/09 10:22:50 thib Exp $	*/
d144 32
a175 32
	{ &vop_lookup_desc, procfs_lookup },		/* lookup */
	{ &vop_create_desc, procfs_badop },		/* create */
	{ &vop_mknod_desc, procfs_badop },		/* mknod */
	{ &vop_open_desc, procfs_open },		/* open */
	{ &vop_close_desc, procfs_close },		/* close */
	{ &vop_access_desc, procfs_access },		/* access */
	{ &vop_getattr_desc, procfs_getattr },		/* getattr */
	{ &vop_setattr_desc, procfs_setattr },		/* setattr */
	{ &vop_read_desc, procfs_rw },			/* read */
	{ &vop_write_desc, procfs_rw },			/* write */
	{ &vop_ioctl_desc, procfs_ioctl },		/* ioctl */
	{ &vop_poll_desc, procfs_poll },		/* poll */
	{ &vop_fsync_desc, procfs_badop},		/* fsync */
	{ &vop_remove_desc, procfs_badop },		/* remove */
	{ &vop_link_desc, procfs_link },		/* link */
	{ &vop_rename_desc, procfs_badop },		/* rename */
	{ &vop_mkdir_desc, procfs_badop },		/* mkdir */
	{ &vop_rmdir_desc, procfs_badop },		/* rmdir */
	{ &vop_symlink_desc, procfs_symlink },		/* symlink */
	{ &vop_readdir_desc, procfs_readdir },		/* readdir */
	{ &vop_readlink_desc, procfs_readlink },	/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },	/* abortop */
	{ &vop_inactive_desc, procfs_inactive },	/* inactive */
	{ &vop_reclaim_desc, procfs_reclaim },		/* reclaim */
	{ &vop_lock_desc, nullop },			/* lock */
	{ &vop_unlock_desc, nullop },			/* unlock */
	{ &vop_bmap_desc, vop_generic_bmap },		/* bmap */
	{ &vop_strategy_desc, procfs_badop },		/* strategy */
	{ &vop_print_desc, procfs_print },		/* print */
	{ &vop_islocked_desc, nullop },			/* islocked */
	{ &vop_pathconf_desc, procfs_pathconf },	/* pathconf */
	{ &vop_advlock_desc, procfs_badop },		/* advlock */
@


1.45
log
@Update access(2) to have modern semantics with respect to X_OK and
the superuser.  access(2) will now only indicate success for X_OK on
non-directories if there is at least one execute bit set on the file.
OK deraadt@@ thib@@ otto@@
@
text
@d660 1
a660 1
		VREF(dvp);
d752 1
a752 1
			VREF(fvp);
@


1.44
log
@procfs can use vop_generic_bmap too;
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.43 2008/05/08 17:45:45 thib Exp $	*/
d623 2
a624 2
	return (vaccess(va.va_mode, va.va_uid, va.va_gid, ap->a_mode,
			ap->a_cred));
@


1.43
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.42 2008/04/24 17:39:45 thib Exp $	*/
a132 1
int	procfs_bmap(void *);
d170 1
a170 1
	{ &vop_bmap_desc, procfs_bmap },		/* bmap */
a271 22
}

/*
 * do block mapping for pfsnode (vp).
 * since we don't use the buffer cache
 * for procfs this function should never
 * be called.  in any case, it's not clear
 * what part of the kernel ever makes use
 * of this function.  for sanity, this is the
 * usual no-op bmap, although returning
 * (EIO) would be a reasonable alternative.
 */
int
procfs_bmap(void *v)
{
	struct vop_bmap_args *ap = v;

	if (ap->a_vpp != NULL)
		*ap->a_vpp = ap->a_vp;
	if (ap->a_bnp != NULL)
		*ap->a_bnp = ap->a_bn;
	return (0);
@


1.42
log
@remove useless defines for the vnode operations, and instead
init the op array functions with whatever the define was set
too.

ok dlg@@,blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.41 2007/09/01 15:14:44 martin Exp $	*/
d144 1
a144 1
	{ &vop_default_desc, vn_default_error },
@


1.41
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.40 2007/06/18 08:30:07 jasper Exp $	*/
a120 2
#define	procfs_create	procfs_badop
#define	procfs_mknod	procfs_badop
a125 2
#define	procfs_read	procfs_rw
#define	procfs_write	procfs_rw
a126 2
#define	procfs_fsync	procfs_badop
#define	procfs_remove	procfs_badop
a127 3
#define	procfs_rename	procfs_badop
#define	procfs_mkdir	procfs_badop
#define	procfs_rmdir	procfs_badop
a132 2
#define	procfs_lock	nullop
#define	procfs_unlock	nullop
a133 1
#define	procfs_strategy	procfs_badop
a135 2
#define	procfs_islocked	nullop
#define	procfs_advlock	procfs_badop
d146 2
a147 2
	{ &vop_create_desc, procfs_create },		/* create */
	{ &vop_mknod_desc, procfs_mknod },		/* mknod */
d153 2
a154 2
	{ &vop_read_desc, procfs_read },		/* read */
	{ &vop_write_desc, procfs_write },		/* write */
d157 2
a158 2
	{ &vop_fsync_desc, procfs_fsync },		/* fsync */
	{ &vop_remove_desc, procfs_remove },		/* remove */
d160 3
a162 3
	{ &vop_rename_desc, procfs_rename },		/* rename */
	{ &vop_mkdir_desc, procfs_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, procfs_rmdir },		/* rmdir */
d169 2
a170 2
	{ &vop_lock_desc, procfs_lock },		/* lock */
	{ &vop_unlock_desc, procfs_unlock },		/* unlock */
d172 1
a172 1
	{ &vop_strategy_desc, procfs_strategy },	/* strategy */
d174 1
a174 1
	{ &vop_islocked_desc, procfs_islocked },	/* islocked */
d176 1
a176 1
	{ &vop_advlock_desc, procfs_advlock },		/* advlock */
@


1.40
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.39 2007/06/01 23:47:57 deraadt Exp $	*/
d587 1
a587 1
			ctob(procp->p_vmspace->vm_tsize +
@


1.39
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.38 2006/03/05 21:48:56 miod Exp $	*/
d207 1
a207 2
procfs_open(v)
	void *v;
d247 1
a247 2
procfs_close(v)
	void *v;
d283 1
a283 2
procfs_ioctl(v)
	void *v;
d300 1
a300 2
procfs_bmap(v)
	void *v;
d328 1
a328 2
procfs_inactive(v)
	void *v;
d348 1
a348 2
procfs_reclaim(v)
	void *v;
d359 1
a359 2
procfs_pathconf(v)
	void *v;
d394 1
a394 2
procfs_print(v)
	void *v;
d405 1
a405 2
procfs_link(v)
	void *v;
d415 1
a415 2
procfs_symlink(v)
	void *v;
d430 1
a430 2
procfs_badop(v)
	void *v;
d446 1
a446 2
procfs_getattr(v)
	void *v;
d627 1
a627 2
procfs_setattr(v)
	void *v;
d651 1
a651 2
procfs_access(v)
	void *v;
d674 1
a674 2
procfs_lookup(v)
	void *v;
d815 1
a815 3
procfs_validfile(p, mp)
	struct proc *p;
	struct mount *mp;
d822 1
a822 3
procfs_validfile_linux(p, mp)
	struct proc *p;
	struct mount *mp;
d844 1
a844 2
procfs_readdir(v)
	void *v;
d1012 1
a1012 2
procfs_readlink(v)
	void *v;
d1034 1
a1034 3
atopid(b, len)
	const char *b;
	u_int len;
d1050 1
a1050 2
procfs_poll(v)
	void *v;
@


1.38
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.37 2005/12/11 21:30:31 miod Exp $	*/
d210 1
a210 6
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d251 1
a251 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d306 1
a306 6
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
	} */ *ap = v;
d335 1
a335 3
	struct vop_inactive_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d356 1
a356 3
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d368 1
a368 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
d404 1
a404 3
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d416 1
a416 5
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d427 1
a427 7
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
d460 1
a460 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d667 1
a667 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d691 1
a691 5
	struct vop_lookup_args /* {
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
d866 1
a866 8
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long *a_cookies;
		int a_ncookies;
	} */ *ap = v;
d1076 1
a1076 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;
		struct proc *a_p;
	} */ *ap = v;
@


1.37
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.36 2005/04/21 23:28:55 deraadt Exp $	*/
d989 1
a989 1
		volatile struct proc *p = allproc.lh_first;
d1066 1
a1066 1
			p = zombproc.lh_first;
@


1.36
log
@careful strlcpy and snprintf return handling; ok pedro beck
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.35 2005/04/16 22:19:28 kettenis Exp $	*/
d230 1
a230 1
		if ((error = procfs_checkioperm(p1, p2)) != 0)
@


1.35
log
@Remove regs and fpregs pseudo-files from procfs.
ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.34 2005/04/01 20:16:01 pedro Exp $	*/
d605 7
d615 1
a615 2
		vap->va_size = vap->va_bytes =
		    snprintf(buf, sizeof buf, "%ld", (long)curproc->p_pid);
d1100 2
@


1.34
log
@calling pfind() and checking that the process doesn't exist is not
enough to allow us to call vgone() from procfs_inactive(). to avoid a
deadlock, check for VXLOCK as well, in case we were called from
vclean(). problem report from Sho Fujita, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.33 2004/10/19 12:42:28 pedro Exp $	*/
a88 4
#ifdef PTRACE
	{ DT_REG, N("regs"),	Pregs,		procfs_validregs },
	{ DT_REG, N("fpregs"),	Pfpregs,	procfs_validfpregs },
#endif
@


1.33
log
@use queue.h provided macro when traversing the process list, no changes
in generated object file. from Joris Vink.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.32 2004/06/24 19:35:25 tholo Exp $	*/
d357 2
a358 1
	struct pfsnode *pfs = VTOPFS(ap->a_vp);
d360 2
a361 2
	if (pfind(pfs->pfs_pid) == 0)
		vgone(ap->a_vp);
@


1.32
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.31 2004/05/20 18:32:38 tedu Exp $	*/
d1043 1
a1043 1
					p = p->p_list.le_next;
d1051 1
a1051 1
				p = p->p_list.le_next;
@


1.31
log
@remove more caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.30 2003/09/23 16:51:13 millert Exp $	*/
a506 1
	struct timeval tv;
d545 1
a545 2
	microtime(&tv);
	TIMEVAL_TO_TIMESPEC(&tv, &vap->va_ctime);
@


1.30
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.29 2003/06/02 23:28:11 millert Exp $	*/
d939 1
a939 1
	bzero((caddr_t)&d, UIO_MX);
d967 1
a967 1
			if ((error = uiomove((caddr_t)&d, UIO_MX, uio)) != 0)
d1057 1
a1057 1
			if ((error = uiomove((caddr_t)&d, UIO_MX, uio)) != 0)
d1101 1
a1101 1
	return (uiomove((caddr_t)buf, len, ap->a_uio));
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.28 2003/04/07 23:43:25 tedu Exp $	*/
d55 1
a134 1
#define	procfs_select	procfs_badop
d174 1
a174 1
	{ &vop_select_desc, procfs_select },		/* select */
d1124 12
@


1.28
log
@sprintf elimination from rohee.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.27 2003/01/31 17:37:50 art Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.27
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.26 2002/04/06 23:40:13 miod Exp $	*/
d618 1
a618 1
		    sprintf(buf, "%ld", (long)curproc->p_pid);
d1054 2
a1055 2
				d.d_namlen = sprintf(d.d_name, "%ld",
				    (long)p->p_pid);
d1099 1
a1099 1
		len = sprintf(buf, "%ld", (long)curproc->p_pid);
d1101 1
a1101 1
		len = sprintf(buf, "%s", "curproc");
@


1.26
log
@Do not hide Pfpregs from a switch() if PT_[GS]ETFPREGS are not defined,
so that this compiles with option DIAGNOSTIC; fixes PR #2528
ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.25 2002/03/14 01:27:08 millert Exp $	*/
d754 1
a754 1
	int i, error, iscurproc = 0, isself = 0;
d757 1
a764 1
		/*VOP_LOCK(dvp);*/
d768 1
a780 1
#if 0
d782 1
a782 1
				VOP_UNLOCK(dvp, 0);
a784 1
#endif
a799 1
#if 0
d801 1
a801 1
				VOP_UNLOCK(dvp, 0);
a803 1
#endif
d815 6
a820 1
		return (procfs_allocvp(dvp->v_mount, vpp, pid, Pproc));
d823 15
a837 2
		if (cnp->cn_flags & ISDOTDOT)
			return (procfs_root(dvp->v_mount, vpp));
d858 4
d866 7
a872 2
		return (procfs_allocvp(dvp->v_mount, vpp, pfs->pfs_pid,
		    pt->pt_pfstype));
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.24 2002/03/14 00:42:25 miod Exp $	*/
d653 1
a654 1
	case Pfpregs:
d658 1
a659 1
#endif
@


1.24
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.23 2002/03/11 15:39:27 art Exp $	*/
d72 1
a72 1
static int procfs_validfile_linux __P((struct proc *, struct mount *));
d84 1
a84 1
	int	(*pt_valid) __P((struct proc *p, struct mount *mp));
d120 1
a120 1
static pid_t atopid __P((const char *, u_int));
d125 1
a125 1
int	procfs_badop	__P((void *));
d127 1
a127 1
int	procfs_lookup	__P((void *));
d130 5
a134 5
int	procfs_open	__P((void *));
int	procfs_close	__P((void *));
int	procfs_access	__P((void *));
int	procfs_getattr	__P((void *));
int	procfs_setattr	__P((void *));
d137 1
a137 1
int	procfs_ioctl	__P((void *));
d141 1
a141 1
int	procfs_link	__P((void *));
d145 5
a149 5
int	procfs_symlink	__P((void *));
int	procfs_readdir	__P((void *));
int	procfs_readlink	__P((void *));
int	procfs_inactive	__P((void *));
int	procfs_reclaim	__P((void *));
d152 1
a152 1
int	procfs_bmap	__P((void *));
d154 2
a155 2
int	procfs_print	__P((void *));
int	procfs_pathconf	__P((void *));
d159 1
a159 1
static pid_t atopid __P((const char *, u_int));
d164 1
a164 1
int (**procfs_vnodeop_p) __P((void *));
@


1.23
log
@Since all archs implement PT_GETREGS and PT_SETREGS, make then unoptional.
They still stay in MD code for backwards compatibility, but a check in
ptrace.h checks if they are defined.

Note - the same thing will be done with PT_{GET,SET}FPREGS once vax implements
 them and with PT_STEP when it's implemented by sparc, sparc64 and alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.22 2002/01/30 20:29:44 nordin Exp $	*/
d92 1
d95 1
a554 1
	case Pmem:
d557 4
d648 1
d650 1
d655 1
d657 1
d671 1
d674 1
@


1.22
log
@Add proc0 to the PIDHASH table. art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.21 2001/12/04 22:44:32 art Exp $	*/
a641 1
#if defined(PT_GETREGS) || defined(PT_SETREGS)
a644 1
#endif
@


1.21
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.20 2001/11/06 19:53:20 miod Exp $	*/
d227 1
a227 1
	if ((p2 = PFIND(pfs->pfs_pid)) == 0)
d348 1
a348 1
 * there and PFIND is not free.
d361 1
a361 1
	if (PFIND(pfs->pfs_pid) == 0)
d522 1
a522 1
		procp = PFIND(pfs->pfs_pid);
d805 1
a805 1
		p = PFIND(pid);
d815 1
a815 1
		p = PFIND(pfs->pfs_pid);
d923 1
a923 1
		p = PFIND(pfs->pfs_pid);
@


1.21.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.22 2002/01/30 20:29:44 nordin Exp $	*/
d227 1
a227 1
	if ((p2 = pfind(pfs->pfs_pid)) == 0)
d348 1
a348 1
 * there and pfind is not free.
d361 1
a361 1
	if (pfind(pfs->pfs_pid) == 0)
d522 1
a522 1
		procp = pfind(pfs->pfs_pid);
d805 1
a805 1
		p = pfind(pid);
d815 1
a815 1
		p = pfind(pfs->pfs_pid);
d923 1
a923 1
		p = pfind(pfs->pfs_pid);
@


1.21.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.21.2.1 2002/01/31 22:55:42 niklas Exp $	*/
d72 1
a72 1
static int procfs_validfile_linux(struct proc *, struct mount *);
d84 1
a84 1
	int	(*pt_valid)(struct proc *p, struct mount *mp);
a91 1
#ifdef PTRACE
a93 1
#endif
d118 1
a118 1
static pid_t atopid(const char *, u_int);
d123 1
a123 1
int	procfs_badop(void *);
d125 1
a125 1
int	procfs_lookup(void *);
d128 5
a132 5
int	procfs_open(void *);
int	procfs_close(void *);
int	procfs_access(void *);
int	procfs_getattr(void *);
int	procfs_setattr(void *);
d135 1
a135 1
int	procfs_ioctl(void *);
d139 1
a139 1
int	procfs_link(void *);
d143 5
a147 5
int	procfs_symlink(void *);
int	procfs_readdir(void *);
int	procfs_readlink(void *);
int	procfs_inactive(void *);
int	procfs_reclaim(void *);
d150 1
a150 1
int	procfs_bmap(void *);
d152 2
a153 2
int	procfs_print(void *);
int	procfs_pathconf(void *);
d157 1
a157 1
static pid_t atopid(const char *, u_int);
d162 1
a162 1
int (**procfs_vnodeop_p)(void *);
d553 1
a555 4
#ifndef PTRACE
		break;
#endif
	case Pmem:
d642 1
a643 1
#ifdef PTRACE
d645 1
a646 1
		break;
d648 1
a649 2
#if defined(PT_GETFPREGS) || defined(PT_SETFPREGS)
#ifdef PTRACE
d651 1
a652 2
#endif
		break;
a663 1
#ifdef DIAGNOSTIC
a665 1
#endif
@


1.21.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d618 1
a618 1
		    snprintf(buf, sizeof buf, "%ld", (long)curproc->p_pid);
d754 1
a754 1
	int i, error, wantpunlock, iscurproc = 0, isself = 0;
a756 1
	cnp->cn_flags &= ~PDIRUNLOCK;
d764 1
a767 1
	wantpunlock = (~cnp->cn_flags & (LOCKPARENT | ISLASTCN));
d780 1
d782 1
a782 1
				VOP_UNLOCK(dvp, 0, curp);
d785 1
d801 1
d803 1
a803 1
				VOP_UNLOCK(dvp, 0, curp);
d806 1
d818 1
a818 6
		error = procfs_allocvp(dvp->v_mount, vpp, pid, Pproc);
		if ((error == 0) && wantpunlock) {
			VOP_UNLOCK(dvp, 0, curp);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (error);
d821 2
a822 15
		/*
		 * do the .. dance. We unlock the directory, and then
		 * get the root dir. That will automatically return ..
		 * locked. Then if the caller wanted dvp locked, we
		 * re-lock.
		 */
		if (cnp->cn_flags & ISDOTDOT) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
			error = procfs_root(dvp->v_mount, vpp);
			if ((error == 0) && (wantpunlock == 0) &&
			    ((error = vn_lock(dvp, LK_EXCLUSIVE, curp)) == 0))
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}
a842 4
			if (wantpunlock) {
				VOP_UNLOCK(dvp, 0, curp);
				cnp->cn_flags |= PDIRUNLOCK;
			}
d847 2
a848 7
		error =  procfs_allocvp(dvp->v_mount, vpp, pfs->pfs_pid,
		    pt->pt_pfstype);
		if ((error == 0) && (wantpunlock)) {
			VOP_UNLOCK(dvp, 0, curp);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (error);
d1030 2
a1031 2
				d.d_namlen = snprintf(d.d_name, sizeof(d.d_name),
				    "%ld", (long)p->p_pid);
d1075 1
a1075 1
		len = snprintf(buf, sizeof buf, "%ld", (long)curproc->p_pid);
d1077 1
a1077 1
		len = strlcpy(buf, "curproc", sizeof buf);
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.19 2001/06/23 02:14:25 csapuntz Exp $	*/
d197 1
a197 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.19
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.18 2001/05/24 07:32:43 aaron Exp $	*/
d62 1
a62 1
#include <vm/vm.h>	/* for PAGE_SIZE */
@


1.18
log
@Garbage collect procfs_findtextvp().
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.17 2001/05/24 04:09:39 art Exp $	*/
a136 1
#define	procfs_mmap	procfs_badop
a137 1
#define	procfs_seek	procfs_badop
a155 5
#define	procfs_blkatoff	procfs_badop
#define	procfs_valloc	procfs_badop
#define	procfs_vfree	nullop
#define	procfs_truncate	procfs_badop
#define	procfs_update	nullop
a176 1
	{ &vop_mmap_desc, procfs_mmap },		/* mmap */
a177 1
	{ &vop_seek_desc, procfs_seek },		/* seek */
a196 5
	{ &vop_blkatoff_desc, procfs_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, procfs_valloc },		/* valloc */
	{ &vop_vfree_desc, procfs_vfree },		/* vfree */
	{ &vop_truncate_desc, procfs_truncate },	/* truncate */
	{ &vop_update_desc, procfs_update },		/* update */
@


1.17
log
@Initialize p to NULL in lookup.
How this could have ever worked without this is beyond me.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.16 2001/04/09 07:14:23 tholo Exp $	*/
d844 1
a844 1
			fvp = procfs_findtextvp(p);
d868 1
a868 1
	return (procfs_findtextvp(p) != NULLVP);
@


1.16
log
@Add emulation of Linux features to procfs; mostly from NetBSD.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.15 2000/08/12 04:29:24 jasoni Exp $	*/
d758 1
a758 1
	struct proc *p;
@


1.16.2.1
log
@Pull in patch from current:
Fix (art):
Initialize p to NULL in lookup.
How this could have ever worked without this is beyond me.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.16 2001/04/09 07:14:23 tholo Exp $	*/
d758 1
a758 1
	struct proc *p = NULL;
@


1.15
log
@Add procfs/cmdline; to help with linux emulation.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.14 1999/08/13 07:05:46 csapuntz Exp $	*/
d53 1
d72 1
d84 1
a84 1
	int	(*pt_valid) __P((struct proc *p));
d99 1
d104 14
d295 1
d301 2
d530 2
d587 5
d596 1
d631 7
d673 2
d759 1
a759 1
	int i;
d779 35
a813 2
		if (CNEQ(cnp, "curproc", 7))
			return (procfs_allocvp(dvp->v_mount, vpp, 0, Pcurproc));
d836 2
a837 1
			    (pt->pt_valid == NULL || (*pt->pt_valid)(p)))
d863 1
a863 1
procfs_validfile(p)
d865 1
d871 12
d910 1
d914 2
a915 1
	pfs = VTOPFS(ap->a_vp);
d943 2
a944 1
			if (pt->pt_valid && (*pt->pt_valid)(p) == 0)
d998 29
d1079 5
a1083 1
	if (VTOPFS(ap->a_vp)->pfs_fileno != PROCFS_FILENO(0, Pcurproc))
a1084 2

	len = sprintf(buf, "%ld", (long)curproc->p_pid);
@


1.14
log
@

Better fix for fdesc/procfs panic.
@
text
@d1 1
a1 1
/*	$OpenBSD:  $	*/
d96 1
d282 1
d560 1
d637 2
@


1.14.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.16 2001/04/09 07:14:23 tholo Exp $	*/
a52 1
#include <sys/mount.h>
a70 1
static int procfs_validfile_linux __P((struct proc *, struct mount *));
d82 1
a82 1
	int	(*pt_valid) __P((struct proc *p, struct mount *mp));
a95 2
	{ DT_REG, N("cmdline"), Pcmdline,	NULL },
	{ DT_REG, N("exe"),	Pfile,		procfs_validfile_linux },
a99 14
/*
 * List of files in the root directory.  Note: the validate function
 * will be called with p == NULL for these
 */
struct proc_target proc_root_targets[] = {
#define N(s) sizeof(s)-1, s
	/*	  name		type		validp */
	{ DT_REG, N("meminfo"),	Pmeminfo,	procfs_validfile_linux },
	{ DT_REG, N("cpuinfo"),	Pcpuinfo,	procfs_validfile_linux },
#undef N
};
static int nproc_root_targets =
    sizeof(proc_root_targets) / sizeof(proc_root_targets[0]);

a276 1
	case Pself:
a280 3
	case Pcmdline:
	case Pmeminfo:
	case Pcpuinfo:
a507 2
	case Pcpuinfo:
	case Pmeminfo:
a557 1
	case Pcmdline:
a561 5
	case Pmeminfo:
	case Pcpuinfo:
		vap->va_nlink = 1;
		vap->va_uid = vap->va_gid = 0;
		break;
a565 1
	case Pself:
a599 7
	case Pself:
		vap->va_nlink = 1;
		vap->va_uid = 0;
		vap->va_gid = 0;
		vap->va_size = vap->va_bytes = sizeof("curproc");
		break;

a633 4
	case Pcmdline:
	case Pmeminfo:
	case Pcpuinfo:
		vap->va_bytes = vap->va_size = 0;
d717 1
a717 1
	int i, error, iscurproc = 0, isself = 0;
d737 2
a738 35
		iscurproc = CNEQ(cnp, "curproc", 7);
		isself = CNEQ(cnp, "self", 4);

		if (iscurproc || isself) {
			error = procfs_allocvp(dvp->v_mount, vpp, 0,
			    iscurproc ? Pcurproc : Pself);
#if 0
			if ((error == 0) && (wantpunlock)) {
				VOP_UNLOCK(dvp, 0);
				cnp->cn_flags |= PDIRUNLOCK;
			}
#endif
			return (error);
		}

		for (i = 0; i < nproc_root_targets; i++) {
			pt = &proc_root_targets[i];
			if (cnp->cn_namelen == pt->pt_namlen &&
			    memcmp(pt->pt_name, pname, cnp->cn_namelen) == 0 &&
			    (pt->pt_valid == NULL ||
			     (*pt->pt_valid)(p, dvp->v_mount)))
				break;
		}

		if (i != nproc_root_targets) {
			error = procfs_allocvp(dvp->v_mount, vpp, 0,
			    pt->pt_pfstype);
#if 0
			if ((error == 0) && (wantpunlock)) {
				VOP_UNLOCK(dvp, 0);
				cnp->cn_flags |= PDIRUNLOCK;
			}
#endif
			return (error);
		}
d761 1
a761 2
			    (pt->pt_valid == NULL ||
			     (*pt->pt_valid)(p, dvp->v_mount)))
d787 1
a787 1
procfs_validfile(p, mp)
a788 1
	struct mount *mp;
a793 12
int
procfs_validfile_linux(p, mp)
	struct proc *p;
	struct mount *mp;
{
	int flags;

	flags = VFSTOPROC(mp)->pmnt_flags;
	return ((flags & PROCFSMNT_LINUXCOMPAT) &&
	    (p == NULL || procfs_validfile(p, mp)));
}

a820 1
	struct vnode *vp;
d824 1
a824 2
	vp = ap->a_vp;
	pfs = VTOPFS(vp);
d852 1
a852 2
			if (pt->pt_valid &&
			    (*pt->pt_valid)(p, vp->v_mount) == 0)
a905 29
			case 3:
				d.d_fileno = PROCFS_FILENO(0, Pself);
				d.d_namlen = 4;
				bcopy("self", d.d_name, 5);
				d.d_type = DT_LNK;
				break;

			case 4:
				if (VFSTOPROC(vp->v_mount)->pmnt_flags &
				    PROCFSMNT_LINUXCOMPAT) {
					d.d_fileno = PROCFS_FILENO(0, Pcpuinfo);
					d.d_namlen = 7;
					bcopy("cpuinfo", d.d_name, 8);
					d.d_type = DT_REG;
					break;
				}
				/* fall through */

			case 5:
				if (VFSTOPROC(vp->v_mount)->pmnt_flags &
				    PROCFSMNT_LINUXCOMPAT) {
					d.d_fileno = PROCFS_FILENO(0, Pmeminfo);
					d.d_namlen = 7;
					bcopy("meminfo", d.d_name, 8);
					d.d_type = DT_REG;
					break;
				}
				/* fall through */

d958 1
a958 5
	if (VTOPFS(ap->a_vp)->pfs_fileno == PROCFS_FILENO(0, Pcurproc))
		len = sprintf(buf, "%ld", (long)curproc->p_pid);
	else if (VTOPFS(ap->a_vp)->pfs_fileno == PROCFS_FILENO(0, Pself))
		len = sprintf(buf, "%s", "curproc");
	else
d960 2
@


1.14.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.14.4.1 2001/05/14 22:32:56 niklas Exp $	*/
d137 1
d139 1
d158 5
d184 1
d186 1
d206 5
d758 1
a758 1
	struct proc *p = NULL;
d844 1
a844 1
			fvp = p->p_textvp;
d868 1
a868 1
	return (p->p_textvp != NULLVP);
@


1.14.4.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a62 1
#include <uvm/uvm_extern.h>	/* for PAGE_SIZE */
@


1.14.4.4
log
@Merge in trunk
@
text
@d197 1
a197 1
	{ NULL, NULL }
d227 1
a227 1
	if ((p2 = pfind(pfs->pfs_pid)) == 0)
d348 1
a348 1
 * there and pfind is not free.
d361 1
a361 1
	if (pfind(pfs->pfs_pid) == 0)
d522 1
a522 1
		procp = pfind(pfs->pfs_pid);
d805 1
a805 1
		p = pfind(pid);
d815 1
a815 1
		p = pfind(pfs->pfs_pid);
d923 1
a923 1
		p = pfind(pfs->pfs_pid);
@


1.14.4.5
log
@Merge in -current from roughly a week ago
@
text
@d72 1
a72 1
static int procfs_validfile_linux(struct proc *, struct mount *);
d84 1
a84 1
	int	(*pt_valid)(struct proc *p, struct mount *mp);
a91 1
#ifdef PTRACE
a93 1
#endif
d118 1
a118 1
static pid_t atopid(const char *, u_int);
d123 1
a123 1
int	procfs_badop(void *);
d125 1
a125 1
int	procfs_lookup(void *);
d128 5
a132 5
int	procfs_open(void *);
int	procfs_close(void *);
int	procfs_access(void *);
int	procfs_getattr(void *);
int	procfs_setattr(void *);
d135 1
a135 1
int	procfs_ioctl(void *);
d139 1
a139 1
int	procfs_link(void *);
d143 5
a147 5
int	procfs_symlink(void *);
int	procfs_readdir(void *);
int	procfs_readlink(void *);
int	procfs_inactive(void *);
int	procfs_reclaim(void *);
d150 1
a150 1
int	procfs_bmap(void *);
d152 2
a153 2
int	procfs_print(void *);
int	procfs_pathconf(void *);
d157 1
a157 1
static pid_t atopid(const char *, u_int);
d162 1
a162 1
int (**procfs_vnodeop_p)(void *);
d553 1
a555 4
#ifndef PTRACE
		break;
#endif
	case Pmem:
d642 1
a643 1
#ifdef PTRACE
d645 1
a646 1
		break;
a649 1
#ifdef PTRACE
a650 1
#endif
a663 1
#ifdef DIAGNOSTIC
a665 1
#endif
@


1.14.4.6
log
@Sync the SMP branch with 3.3
@
text
@d653 1
a654 1
#if defined(PT_GETFPREGS) || defined(PT_SETFPREGS)
d658 1
a659 1
		break;
d754 1
a754 1
	int i, error, wantpunlock, iscurproc = 0, isself = 0;
a756 1
	cnp->cn_flags &= ~PDIRUNLOCK;
d764 1
a767 1
	wantpunlock = (~cnp->cn_flags & (LOCKPARENT | ISLASTCN));
d780 1
d782 1
a782 1
				VOP_UNLOCK(dvp, 0, curp);
d785 1
d801 1
d803 1
a803 1
				VOP_UNLOCK(dvp, 0, curp);
d806 1
d818 1
a818 6
		error = procfs_allocvp(dvp->v_mount, vpp, pid, Pproc);
		if ((error == 0) && wantpunlock) {
			VOP_UNLOCK(dvp, 0, curp);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (error);
d821 2
a822 15
		/*
		 * do the .. dance. We unlock the directory, and then
		 * get the root dir. That will automatically return ..
		 * locked. Then if the caller wanted dvp locked, we
		 * re-lock.
		 */
		if (cnp->cn_flags & ISDOTDOT) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
			error = procfs_root(dvp->v_mount, vpp);
			if ((error == 0) && (wantpunlock == 0) &&
			    ((error = vn_lock(dvp, LK_EXCLUSIVE, curp)) == 0))
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}
a842 4
			if (wantpunlock) {
				VOP_UNLOCK(dvp, 0, curp);
				cnp->cn_flags |= PDIRUNLOCK;
			}
d847 2
a848 7
		error =  procfs_allocvp(dvp->v_mount, vpp, pfs->pfs_pid,
		    pt->pt_pfstype);
		if ((error == 0) && (wantpunlock)) {
			VOP_UNLOCK(dvp, 0, curp);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (error);
@


1.14.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.14.4.6 2003/03/28 00:00:20 niklas Exp $	*/
d618 1
a618 1
		    snprintf(buf, sizeof buf, "%ld", (long)curproc->p_pid);
d1054 2
a1055 2
				d.d_namlen = snprintf(d.d_name, sizeof(d.d_name),
				    "%ld", (long)p->p_pid);
d1099 1
a1099 1
		len = snprintf(buf, sizeof buf, "%ld", (long)curproc->p_pid);
d1101 1
a1101 1
		len = strlcpy(buf, "curproc", sizeof buf);
@


1.14.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.14.4.7 2003/05/13 19:21:30 ho Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a54 1
#include <sys/poll.h>
d134 1
d174 1
a174 1
	{ &vop_poll_desc, procfs_poll },		/* poll */
a1123 12
}
int
procfs_poll(v)
	void *v;
{
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;
		struct proc *a_p;
	} */ *ap = v;

	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
@


1.14.4.10
log
@Merge with the trunk
@
text
@d939 1
a939 1
	bzero(&d, UIO_MX);
d967 1
a967 1
			if ((error = uiomove(&d, UIO_MX, uio)) != 0)
d1057 1
a1057 1
			if ((error = uiomove(&d, UIO_MX, uio)) != 0)
d1101 1
a1101 1
	return (uiomove(buf, len, ap->a_uio));
@


1.13
log
@in *_readdir(), constrain uio_offset to make sure it is right; cstone@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.12 1998/08/06 19:34:46 csapuntz Exp $	*/
d826 1
a826 1
	if (uio->uio_offset < 0 || uio->uio_offset % UIO_MX)
d831 2
a844 3

		if (nproc_targets <= uio->uio_offset/UIO_MX) 
			return (EINVAL);
@


1.12
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.11 1998/06/27 07:32:11 deraadt Exp $	*/
d826 1
a826 3
	if (uio->uio_resid < UIO_MX)
		return (EINVAL);
	if (uio->uio_offset < 0)
d843 3
@


1.11
log
@securelevels do NOT protect running binaries; only filesystem activity
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.9 1997/11/06 05:58:43 csapuntz Exp $	*/
a129 1
int	procfs_abortop	__P((void *));
d177 1
a177 1
	{ &vop_abortop_desc, procfs_abortop },		/* abortop */
a465 19
/*
 * _abortop is called when operations such as
 * rename and create fail.  this entry is responsible
 * for undoing any side-effects caused by the lookup.
 * this will always include freeing the pathname buffer.
 */
int
procfs_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;

	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
}
@


1.10
log
@do not permit ptrace attach to immutable executable
@
text
@a221 1
	struct vattr va;
a234 6

		error = VOP_GETATTR(p2->p_textvp, &va, p1->p_ucred, p1);
		if (error)
			return (error);
		if (va.va_flags & IMMUTABLE)
			return (EPERM);
@


1.9
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.8 1997/10/06 20:20:35 deraadt Exp $	*/
d222 1
d236 6
@


1.8
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.6 1997/08/29 04:24:38 millert Exp $	*/
d731 1
d791 1
a791 1
			VOP_LOCK(fvp);
a842 2
	u_long *cookies = ap->a_cookies;
	int ncookies = ap->a_ncookies;
a881 2
			if (ncookies-- > 0)
				*cookies++ = i + 1;
a942 2
			if (ncookies-- > 0)
				*cookies++ = i + 1;
@


1.7
log
@VFS Lite2 Changes
@
text
@a730 1
	struct proc *curp = curproc;
d790 1
a790 1
			vn_lock(fvp, LK_EXCLUSIVE | LK_RETRY, curp);
d842 2
d883 2
d946 2
@


1.6
log
@From NetBSD (thorpej):
    Fix a reversed argument which caused procfs_checkioperm() to always
    return OK".  Add a few comments to avoid further confusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.5 1997/08/16 02:00:50 millert Exp $	*/
d731 1
d791 1
a791 1
			VOP_LOCK(fvp);
a842 2
	u_long *cookies = ap->a_cookies;
	int ncookies = ap->a_ncookies;
a881 2
			if (ncookies-- > 0)
				*cookies++ = i + 1;
a942 2
			if (ncookies-- > 0)
				*cookies++ = i + 1;
@


1.5
log
@1) pfs_mode should be mode_t, not u_short
2) Fix procfs security hole.  This is basically the NetBSD fix
   (which is based in part on Sean Eric Fagan's FreeBSD fix)
   with a few minor changes.  The change creates as function,
   procfs_checkioperm(), that has check numbers 3 and 4 from sys_ptrace().
3) Make procfs_control() use procfs_checkioperm() as well (it
   already had the same basic checks but some of them were incorrect).
4) Minor stylistic cleanups, including the use of the SET/CLR/ISSET
   macros to aid general grokability.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.4 1997/08/01 05:58:57 millert Exp $	*/
d220 2
a221 2
	struct proc *p1 = ap->a_p;
	struct proc *p2;
@


1.4
log
@From NetBSD (mycroft):
    Eliminate bogus uses of V{READ,WRITE,EXEC}.  Use S_I[RWX]{USR,GRP,OTH}
    where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.3 1996/04/21 22:28:19 deraadt Exp $	*/
d220 6
a228 3
		if (PFIND(pfs->pfs_pid) == 0)
			return (ENOENT);	/* was ESRCH, jsp */

d233 3
d436 1
a436 1
procfs_link(v) 
d441 1
a441 1
		struct vnode *a_vp;  
d444 1
a444 1
 
d461 1
a461 1
  
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vnops.c,v 1.2 1996/02/27 08:03:39 niklas Exp $	*/
d59 2
d62 1
d64 1
a555 5
	/*
	 * If the process has exercised some setuid or setgid
	 * privilege, then rip away read/write permission so
	 * that only root can gain access.
	 */
d560 5
d566 2
a567 3
			vap->va_mode &= ~((VREAD|VWRITE)|
					  ((VREAD|VWRITE)>>3)|
					  ((VREAD|VWRITE)>>6));
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: procfs_vnops.c,v 1.39 1996/02/13 13:12:59 mycroft Exp $	*/
d420 1
a420 1
	printf("tag VT_PROCFS, type %d, pid %d, mode %x, flags %x\n",
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: procfs_vnops.c,v 1.35 1995/10/09 14:03:38 mycroft Exp $	*/
d99 96
d205 4
a208 1
procfs_open(ap)
d214 1
a214 2
	} */ *ap;
{
d222 2
a223 2
		if ((pfs->pfs_flags & FWRITE) && (ap->a_mode & O_EXCL) ||
		    (pfs->pfs_flags & O_EXCL) && (ap->a_mode & FWRITE))
d245 4
a248 1
procfs_close(ap)
d254 1
a254 2
	} */ *ap;
{
d262 11
d282 4
a285 9
procfs_ioctl(ap)
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t a_data;
		int a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d301 4
a304 1
procfs_bmap(ap)
d310 1
a310 2
	} */ *ap;
{
d335 4
a338 1
procfs_inactive(ap)
d341 1
a341 2
	} */ *ap;
{
d357 4
a360 1
procfs_reclaim(ap)
d363 1
a363 2
	} */ *ap;
{
d371 4
a374 1
procfs_pathconf(ap)
d379 1
a379 2
	} */ *ap;
{
d411 4
a414 1
procfs_print(ap)
d417 1
a417 2
	} */ *ap;
{
d420 1
a420 1
	printf("tag VT_PROCFS, type %s, pid %d, mode %x, flags %x\n",
d422 33
d463 4
a466 1
procfs_abortop(ap)
d470 1
a470 2
	} */ *ap;
{
d480 4
a483 1
procfs_badop()
d498 4
a501 1
procfs_getattr(ap)
d507 1
a507 2
	} */ *ap;
{
d573 5
d654 4
a657 7
procfs_setattr(ap)
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d680 4
a683 1
procfs_access(ap)
d689 1
a689 2
	} */ *ap;
{
d693 1
a693 1
	if (error = VOP_GETATTR(ap->a_vp, &va, ap->a_cred, ap->a_p))
d697 1
a697 1
	    ap->a_cred));
d709 4
a712 1
procfs_lookup(ap)
d717 1
a717 2
	} */ *ap;
{
d816 4
a819 1
procfs_readdir(ap)
d827 1
a827 2
	} */ *ap;
{
d872 1
a872 1
			if (error = uiomove((caddr_t)&d, UIO_MX, uio))
d899 1
d901 1
d935 1
a935 1
			if (error = uiomove((caddr_t)&d, UIO_MX, uio))
d966 3
a968 2
procfs_readlink(ap)
	struct vop_readlink_args *ap;
d970 1
a970 1
	struct uio *uio = ap->a_uio;
a1002 50

/*
 * procfs vnode operations.
 */
int (**procfs_vnodeop_p)();
struct vnodeopv_entry_desc procfs_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, procfs_lookup },		/* lookup */
	{ &vop_create_desc, procfs_create },		/* create */
	{ &vop_mknod_desc, procfs_mknod },		/* mknod */
	{ &vop_open_desc, procfs_open },		/* open */
	{ &vop_close_desc, procfs_close },		/* close */
	{ &vop_access_desc, procfs_access },		/* access */
	{ &vop_getattr_desc, procfs_getattr },		/* getattr */
	{ &vop_setattr_desc, procfs_setattr },		/* setattr */
	{ &vop_read_desc, procfs_read },		/* read */
	{ &vop_write_desc, procfs_write },		/* write */
	{ &vop_ioctl_desc, procfs_ioctl },		/* ioctl */
	{ &vop_select_desc, procfs_select },		/* select */
	{ &vop_mmap_desc, procfs_mmap },		/* mmap */
	{ &vop_fsync_desc, procfs_fsync },		/* fsync */
	{ &vop_seek_desc, procfs_seek },		/* seek */
	{ &vop_remove_desc, procfs_remove },		/* remove */
	{ &vop_link_desc, procfs_link },		/* link */
	{ &vop_rename_desc, procfs_rename },		/* rename */
	{ &vop_mkdir_desc, procfs_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, procfs_rmdir },		/* rmdir */
	{ &vop_symlink_desc, procfs_symlink },		/* symlink */
	{ &vop_readdir_desc, procfs_readdir },		/* readdir */
	{ &vop_readlink_desc, procfs_readlink },	/* readlink */
	{ &vop_abortop_desc, procfs_abortop },		/* abortop */
	{ &vop_inactive_desc, procfs_inactive },	/* inactive */
	{ &vop_reclaim_desc, procfs_reclaim },		/* reclaim */
	{ &vop_lock_desc, procfs_lock },		/* lock */
	{ &vop_unlock_desc, procfs_unlock },		/* unlock */
	{ &vop_bmap_desc, procfs_bmap },		/* bmap */
	{ &vop_strategy_desc, procfs_strategy },	/* strategy */
	{ &vop_print_desc, procfs_print },		/* print */
	{ &vop_islocked_desc, procfs_islocked },	/* islocked */
	{ &vop_pathconf_desc, procfs_pathconf },	/* pathconf */
	{ &vop_advlock_desc, procfs_advlock },		/* advlock */
	{ &vop_blkatoff_desc, procfs_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, procfs_valloc },		/* valloc */
	{ &vop_vfree_desc, procfs_vfree },		/* vfree */
	{ &vop_truncate_desc, procfs_truncate },	/* truncate */
	{ &vop_update_desc, procfs_update },		/* update */
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
};
struct vnodeopv_desc procfs_vnodeop_opv_desc =
	{ &procfs_vnodeop_p, procfs_vnodeop_entries };
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
