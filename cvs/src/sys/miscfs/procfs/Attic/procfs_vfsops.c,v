head	1.33;
access;
symbols
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.14
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.10
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.12
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.8
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.24.0.12
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.10
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.8
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.6
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2014.09.08.01.57.00;	author guenther;	state dead;
branches;
next	1.32;
commitid	0HlTPhRuQ0I9ZG6q;

1.32
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.31;
commitid	FE3DG5cICjyI4jWx;

1.31
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	EF98ch02VpFassUi;

1.30
date	2014.05.06.11.50.14;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2012.09.10.11.10.59;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.23.18.43.37;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.20.18.32.38;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.03.05.41.37;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.05.20.47.36;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.24.22.32.46;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.31.20.41.29;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.06.27.04.58.44;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.09.07.14.23;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.20.01.50.10;	author assar;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.07.04.57.16;	author assar;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.05.31.17.34.50;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.02.26.03.47.46;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.02.08.22.41.40;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.58.43;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.20.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.19.11;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.06.21.12.49.56;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.20.15.12.57;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.08.03.38;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2001.05.14.22.32.55;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.07.04.10.49.17;	author niklas;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.30.21;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.22.36.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Actually remove the procfs files
@
text
@/*	$OpenBSD: procfs_vfsops.c,v 1.32 2014/07/12 18:43:52 tedu Exp $	*/
/*	$NetBSD: procfs_vfsops.c,v 1.25 1996/02/09 22:40:53 christos Exp $	*/

/*
 * Copyright (c) 1993 Jan-Simon Pendry
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)procfs_vfsops.c	8.5 (Berkeley) 6/15/94
 */

/*
 * procfs VFS interface
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/syslog.h>
#include <sys/mount.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
#include <sys/malloc.h>

#include <miscfs/procfs/procfs.h>

int	procfs_mount(struct mount *, const char *, void *,
			  struct nameidata *, struct proc *);
int	procfs_start(struct mount *, int, struct proc *);
int	procfs_unmount(struct mount *, int, struct proc *);
int	procfs_statfs(struct mount *, struct statfs *, struct proc *);
/*
 * VFS Operations.
 *
 * mount system call
 */
/* ARGSUSED */
int
procfs_mount(struct mount *mp, const char *path, void *data, struct nameidata *ndp,
    struct proc *p)
{
	struct procfsmount *pmnt;
	struct procfs_args args;
	int error;

	if (UIO_MX & (UIO_MX-1)) {
		log(LOG_ERR, "procfs: invalid directory entry size");
		return (EINVAL);
	}

	if (mp->mnt_flag & MNT_UPDATE)
		return (EOPNOTSUPP);

	if (data != NULL) {
		error = copyin(data, &args, sizeof(args));
		if (error != 0)
			return (error);

		if (args.version != PROCFS_ARGSVERSION)
			return (EINVAL);
	} else
		args.flags = 0;

	mp->mnt_flag |= MNT_LOCAL;
	pmnt = (struct procfsmount *) malloc(sizeof(struct procfsmount),
	    M_MISCFSMNT, M_WAITOK);

	mp->mnt_data = pmnt;
	vfs_getnewfsid(mp);

	bzero(mp->mnt_stat.f_mntonname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntonname, path, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
	bcopy("procfs", mp->mnt_stat.f_mntfromname, sizeof("procfs"));
	bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
	bcopy("procfs", mp->mnt_stat.f_mntfromspec, sizeof("procfs"));
	bcopy(&args, &mp->mnt_stat.mount_info.procfs_args, sizeof(args));

#ifdef notyet
	pmnt->pmnt_exechook = exechook_establish(procfs_revoke_vnodes, mp);
#endif
	pmnt->pmnt_flags = args.flags;

	return (0);
}

/*
 * unmount system call
 */
int
procfs_unmount(struct mount *mp, int mntflags, struct proc *p)
{
	int error;
	extern int doforce;
	int flags = 0;

	if (mntflags & MNT_FORCE) {
		/* procfs can never be rootfs so don't check for it */
		if (!doforce)
			return (EINVAL);
		flags |= FORCECLOSE;
	}

	if ((error = vflush(mp, 0, flags)) != 0)
		return (error);

	free(VFSTOPROC(mp), M_MISCFSMNT, 0);
	mp->mnt_data = 0;

	return (0);
}

int
procfs_root(struct mount *mp, struct vnode **vpp)
{
	int error;

	error = procfs_allocvp(mp, vpp, 0, Proot);
	if (error)
		return (error);
	vn_lock(*vpp, LK_EXCLUSIVE | LK_RETRY, curproc);

	return (0);
}

/* ARGSUSED */
int
procfs_start(struct mount *mp, int flags, struct proc *p)
{

	return (0);
}

/*
 * Get file system statistics.
 */
int
procfs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	sbp->f_bsize = PAGE_SIZE;
	sbp->f_iosize = PAGE_SIZE;
	sbp->f_blocks = uvmexp.npages - uvmexp.free + uvmexp.swpginuse;
	sbp->f_bfree = uvmexp.npages - uvmexp.free - uvmexp.active;
	sbp->f_bavail = 0;
	sbp->f_files = maxprocess;		/* approx */
	sbp->f_ffree = maxprocess - nprocesses;	/* approx */
	if (sbp != &mp->mnt_stat) {
		bcopy(&mp->mnt_stat.f_fsid, &sbp->f_fsid, sizeof(sbp->f_fsid));
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromspec, sbp->f_mntfromspec, MNAMELEN);
		bcopy(&mp->mnt_stat.mount_info.procfs_args,
		    &sbp->mount_info.procfs_args, sizeof(struct procfs_args));
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
	return (0);
}


#define procfs_sync ((int (*)(struct mount *, int, struct ucred *, \
				  struct proc *))nullop)

#define procfs_fhtovp ((int (*)(struct mount *, struct fid *, \
	    struct vnode **))eopnotsupp)
#define procfs_quotactl ((int (*)(struct mount *, int, uid_t, caddr_t, \
	    struct proc *))eopnotsupp)
#define procfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
	    size_t, struct proc *))eopnotsupp)
#define procfs_vget ((int (*)(struct mount *, ino_t, struct vnode **)) \
	    eopnotsupp)
#define procfs_vptofh ((int (*)(struct vnode *, struct fid *))eopnotsupp)
#define procfs_checkexp ((int (*)(struct mount *, struct mbuf *,	\
	int *, struct ucred **))eopnotsupp)

const struct vfsops procfs_vfsops = {
	procfs_mount,
	procfs_start,
	procfs_unmount,
	procfs_root,
	procfs_quotactl,
	procfs_statfs,
	procfs_sync,
	procfs_vget,
	procfs_fhtovp,
	procfs_vptofh,
	procfs_init,
	procfs_sysctl,
	procfs_checkexp
};
@


1.32
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.31 2014/07/08 17:19:25 deraadt Exp $	*/
@


1.31
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.30 2014/05/06 11:50:14 mpi Exp $	*/
d137 1
a137 1
	free(VFSTOPROC(mp), M_MISCFSMNT);
@


1.30
log
@Include <sys/vmmeter.h> directly instead of relying on it being
pulled by <uvm/uvm_extern.h> and turn uvm_total() into a private
function.

The preferred way to get memory stats is through the VM_UVMEXP
sysctl(3) since VM_METER is just a wrapper on top of it.  In the
kernel, use `uvmexp' directly instead of uvm_total().

This change does not remove <sys/vmmeter.h> from <uvm/uvm_extern.h>
to give some more time to port maintainers to fix their ports.

ok guenther@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.29 2013/04/15 15:32:19 jsing Exp $	*/
a55 2

#include <uvm/uvm_extern.h>
@


1.29
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.28 2012/09/10 11:10:59 jsing Exp $	*/
a171 3
	struct vmtotal	vmtotals;

	uvm_total(&vmtotals);
d174 2
a175 2
	sbp->f_blocks = vmtotals.t_vm;
	sbp->f_bfree = vmtotals.t_vm - vmtotals.t_avm;
@


1.28
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.26 2010/09/23 18:43:37 oga Exp $	*/
d107 2
d186 1
@


1.27
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@a73 1
	size_t size;
d87 1
a87 1
		error = copyin(data, &args, sizeof args);
d103 2
a104 2
	(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
	bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);
@


1.26
log
@In procfs_root(), while the vn_lock on a newly-allocated vnode can not
fail it is still good practise to either check the return value or to
provide a flag that won't (to avoid copy pasted code that gets it
wrong).

So change LK_EXCLUSIVE to LK_EXCLUSIVE | LK_RETRY, removing the one
caller of vn_lock in the tree that doesn't either pass LK_RETRY or check
the return value.

ok thib@@, jsing@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.25 2007/06/18 08:30:07 jasper Exp $	*/
d179 2
a180 2
	sbp->f_files = maxproc;			/* approx */
	sbp->f_ffree = maxproc - nprocs;	/* approx */
@


1.25
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.24 2004/05/20 18:32:38 tedu Exp $	*/
d152 1
a152 1
	vn_lock(*vpp, LK_EXCLUSIVE, curproc);
@


1.24
log
@remove more caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.23 2004/03/03 05:41:37 tedu Exp $	*/
d71 2
a72 6
procfs_mount(mp, path, data, ndp, p)
	struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
d122 1
a122 4
procfs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
d145 1
a145 3
procfs_root(mp, vpp)
	struct mount *mp;
	struct vnode **vpp;
d159 1
a159 4
procfs_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
d169 1
a169 4
procfs_statfs(mp, sbp, p)
	struct mount *mp;
	struct statfs *sbp;
	struct proc *p;
@


1.23
log
@save room for nul, so we can unmount later.  pr2327 from peter werner
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.22 2003/08/14 07:46:40 mickey Exp $	*/
d105 1
a105 1
	mp->mnt_data = (qaddr_t)pmnt;
@


1.22
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.21 2003/08/05 20:47:36 tedu Exp $	*/
d108 1
a108 1
	(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN, &size);
@


1.21
log
@make procfs support statfs args.  lossage noticed and patch tested by jolan
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.20 2003/06/02 23:28:11 millert Exp $	*/
d223 1
a223 1
struct vfsops procfs_vfsops = {
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.19 2003/02/24 22:32:46 tedu Exp $	*/
d112 1
d200 2
@


1.19
log
@use M_MISCFSMNT instead of M_UFSMNT for mount data

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.18 2003/01/31 20:41:29 art Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@Sigh. I comitted the wrong diff in the last vfs changes.
These are the files that were ok:ed and tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.17 2003/01/31 17:37:50 art Exp $	*/
d107 1
a107 1
	    M_UFSMNT, M_WAITOK);	/* XXX need new malloc type */
d148 1
a148 1
	free(VFSTOPROC(mp), M_UFSMNT);
@


1.17
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.16 2002/03/14 01:27:08 millert Exp $	*/
a84 1
	struct vnode *rvp;
a104 6
	error = procfs_allocvp(mp, &rvp, 0, Proot);
	if (error)
		return (error);
	rvp->v_type = VDIR;
	rvp->v_flag |= VROOT;

a108 2
	pmnt->rvp = rvp;

a136 1
	struct vnode *rvp = VFSTOPROC(mp)->rvp;
d145 1
a145 4
	vrele(rvp);

	if ((error = vflush(mp, 0, flags)) != 0) {
		vget(rvp, 0, curproc);
a146 1
	}
d159 1
a159 1
	struct vnode *vp = VFSTOPROC(mp)->rvp;
d161 4
a164 3
	VREF(vp);
	vn_lock(vp, LK_EXCLUSIVE, curproc);
	*vpp = vp;
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.15 2001/11/06 19:53:20 miod Exp $	*/
d85 1
d106 6
d116 2
d146 1
d155 4
a158 1
	if ((error = vflush(mp, 0, flags)) != 0)
d160 4
d173 1
d175 5
a179 1
	return (procfs_allocvp(mp, vpp, 0, Proot));
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.14 2001/06/27 04:58:44 art Exp $	*/
d63 5
a67 5
int	procfs_mount __P((struct mount *, const char *, void *,
			  struct nameidata *, struct proc *));
int	procfs_start __P((struct mount *, int, struct proc *));
int	procfs_unmount __P((struct mount *, int, struct proc *));
int	procfs_statfs __P((struct mount *, struct statfs *, struct proc *));
d200 2
a201 2
#define procfs_sync ((int (*) __P((struct mount *, int, struct ucred *, \
				  struct proc *)))nullop)
d203 7
a209 7
#define procfs_fhtovp ((int (*) __P((struct mount *, struct fid *, \
	    struct vnode **)))eopnotsupp)
#define procfs_quotactl ((int (*) __P((struct mount *, int, uid_t, caddr_t, \
	    struct proc *)))eopnotsupp)
#define procfs_sysctl ((int (*) __P((int *, u_int, void *, size_t *, void *, \
	    size_t, struct proc *)))eopnotsupp)
#define procfs_vget ((int (*) __P((struct mount *, ino_t, struct vnode **))) \
d211 3
a213 3
#define procfs_vptofh ((int (*) __P((struct vnode *, struct fid *)))eopnotsupp)
#define procfs_checkexp ((int (*) __P((struct mount *, struct mbuf *,	\
	int *, struct ucred **)))eopnotsupp)
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.15 2001/11/06 19:53:20 miod Exp $	*/
d63 5
a67 5
int	procfs_mount(struct mount *, const char *, void *,
			  struct nameidata *, struct proc *);
int	procfs_start(struct mount *, int, struct proc *);
int	procfs_unmount(struct mount *, int, struct proc *);
int	procfs_statfs(struct mount *, struct statfs *, struct proc *);
d200 2
a201 2
#define procfs_sync ((int (*)(struct mount *, int, struct ucred *, \
				  struct proc *))nullop)
d203 7
a209 7
#define procfs_fhtovp ((int (*)(struct mount *, struct fid *, \
	    struct vnode **))eopnotsupp)
#define procfs_quotactl ((int (*)(struct mount *, int, uid_t, caddr_t, \
	    struct proc *))eopnotsupp)
#define procfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
	    size_t, struct proc *))eopnotsupp)
#define procfs_vget ((int (*)(struct mount *, ino_t, struct vnode **)) \
d211 3
a213 3
#define procfs_vptofh ((int (*)(struct vnode *, struct fid *))eopnotsupp)
#define procfs_checkexp ((int (*)(struct mount *, struct mbuf *,	\
	int *, struct ucred **))eopnotsupp)
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
a107 1
	    M_MISCFSMNT, M_WAITOK);
a147 3
	free(VFSTOPROC(mp), M_MISCFSMNT);
	mp->mnt_data = 0;

a155 1
	int error;
d157 1
a157 6
	error = procfs_allocvp(mp, vpp, 0, Proot);
	if (error)
		return (error);
	vn_lock(*vpp, LK_EXCLUSIVE, curproc);

	return (0);
@


1.14
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.13 2001/04/09 07:14:23 tholo Exp $	*/
a59 2

#include <vm/vm.h>			/* for PAGE_SIZE */
@


1.13
log
@Add emulation of Linux features to procfs; mostly from NetBSD.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.12 2001/02/20 01:50:10 assar Exp $	*/
a62 1
#if defined(UVM)
a63 1
#endif
a183 1
#if defined(UVM)
a184 3
#else
	vmtotal(&vmtotals);
#endif
@


1.12
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.11 2000/02/07 04:57:16 assar Exp $	*/
d57 2
d60 1
d87 3
d99 10
d110 4
a113 1
	mp->mnt_data = 0;
d120 6
@


1.11
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.10 1999/05/31 17:34:50 millert Exp $	*/
d64 1
a64 1
int	procfs_mount __P((struct mount *, const char *, caddr_t,
d79 1
a79 1
	caddr_t data;
@


1.11.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.13 2001/04/09 07:14:23 tholo Exp $	*/
a56 2
#include <sys/malloc.h>

a57 1

d64 1
a64 1
int	procfs_mount __P((struct mount *, const char *, void *,
d79 1
a79 1
	void *data;
a83 3
	struct procfsmount *pmnt;
	struct procfs_args args;
	int error;
a92 10
	if (data != NULL) {
		error = copyin(data, &args, sizeof args);
		if (error != 0)
			return (error);

		if (args.version != PROCFS_ARGSVERSION)
			return (EINVAL);
	} else
		args.flags = 0;

d94 1
a94 4
	pmnt = (struct procfsmount *) malloc(sizeof(struct procfsmount),
	    M_UFSMNT, M_WAITOK);	/* XXX need new malloc type */

	mp->mnt_data = (qaddr_t)pmnt;
a100 6

#ifdef notyet
	pmnt->pmnt_exechook = exechook_establish(procfs_revoke_vnodes, mp);
#endif
	pmnt->pmnt_flags = args.flags;

@


1.11.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.11.2.1 2001/05/14 22:32:55 niklas Exp $	*/
d63 1
d65 1
d186 1
d188 3
@


1.11.2.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 2
@


1.11.2.4
log
@Merge in -current from roughly a week ago
@
text
@d63 5
a67 5
int	procfs_mount(struct mount *, const char *, void *,
			  struct nameidata *, struct proc *);
int	procfs_start(struct mount *, int, struct proc *);
int	procfs_unmount(struct mount *, int, struct proc *);
int	procfs_statfs(struct mount *, struct statfs *, struct proc *);
d200 2
a201 2
#define procfs_sync ((int (*)(struct mount *, int, struct ucred *, \
				  struct proc *))nullop)
d203 7
a209 7
#define procfs_fhtovp ((int (*)(struct mount *, struct fid *, \
	    struct vnode **))eopnotsupp)
#define procfs_quotactl ((int (*)(struct mount *, int, uid_t, caddr_t, \
	    struct proc *))eopnotsupp)
#define procfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
	    size_t, struct proc *))eopnotsupp)
#define procfs_vget ((int (*)(struct mount *, ino_t, struct vnode **)) \
d211 3
a213 3
#define procfs_vptofh ((int (*)(struct vnode *, struct fid *))eopnotsupp)
#define procfs_checkexp ((int (*)(struct mount *, struct mbuf *,	\
	int *, struct ucred **))eopnotsupp)
@


1.11.2.5
log
@Sync the SMP branch with 3.3
@
text
@d107 1
a107 1
	    M_MISCFSMNT, M_WAITOK);
a147 3
	free(VFSTOPROC(mp), M_MISCFSMNT);
	mp->mnt_data = 0;

a155 1
	int error;
d157 1
a157 6
	error = procfs_allocvp(mp, vpp, 0, Proot);
	if (error)
		return (error);
	vn_lock(*vpp, LK_EXCLUSIVE, curproc);

	return (0);
@


1.11.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.11.2.5 2003/03/28 00:00:20 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a111 1
	bcopy(&args, &mp->mnt_stat.mount_info.procfs_args, sizeof(args));
a198 2
		bcopy(&mp->mnt_stat.mount_info.procfs_args,
		    &sbp->mount_info.procfs_args, sizeof(struct procfs_args));
d220 1
a220 1
const struct vfsops procfs_vfsops = {
@


1.11.2.8
log
@Merge with the trunk
@
text
@d105 1
a105 1
	mp->mnt_data = pmnt;
d108 1
a108 1
	(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
@


1.10
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.9 1999/02/26 03:47:46 art Exp $	*/
d187 1
a187 1
	    struct mbuf *, struct vnode **, int *, struct ucred **)))eopnotsupp)
d195 2
d210 2
a211 1
	procfs_sysctl
@


1.9
log
@vmtotal -> uvm_total for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.8 1998/02/08 22:41:40 tholo Exp $	*/
a164 5
#endif
#ifdef COMPAT_09
	sbp->f_type = 10;
#else
	sbp->f_type = 0;
@


1.8
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.7 1997/11/06 05:58:43 csapuntz Exp $	*/
d60 4
d161 3
d165 1
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.6 1997/10/06 20:20:34 deraadt Exp $	*/
d60 1
a60 1
int	procfs_mount __P((struct mount *, char *, caddr_t,
d74 1
a74 1
	char *path;
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.4 1996/06/21 12:49:56 mickey Exp $	*/
a63 2
int	procfs_quotactl __P((struct mount *, int, uid_t, caddr_t,
			     struct proc *));
a64 5
int	procfs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int	procfs_vget __P((struct mount *, ino_t, struct vnode **));
int	procfs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
			   struct vnode **, int *, struct ucred **));
int	procfs_vptofh __P((struct vnode *, struct fid *));
d91 1
a91 1
	getnewfsid(mp, makefstype(MOUNT_PROCFS));
d175 1
a175 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
a178 21
/*ARGSUSED*/
int
procfs_quotactl(mp, cmds, uid, arg, p)
	struct mount *mp;
	int cmds;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

	return (EOPNOTSUPP);
}

/*ARGSUSED*/
int
procfs_sync(mp, waitfor, uc, p)
	struct mount *mp;
	int waitfor;
	struct ucred *uc;
	struct proc *p;
{
d180 2
a181 2
	return (0);
}
d183 9
a191 34
/*ARGSUSED*/
int
procfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{

	return (EOPNOTSUPP);
}

/*ARGSUSED*/
int
procfs_fhtovp(mp, fhp, mb, vpp, what, anon)
	struct mount *mp;
	struct fid *fhp;
	struct mbuf *mb;
	struct vnode **vpp;
	int *what;
	struct ucred **anon;
{

	return (EINVAL);
}

/*ARGSUSED*/
int
procfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
{

	return (EINVAL);
}
a193 1
	MOUNT_PROCFS,
d205 1
@


1.5
log
@VFS Lite2 Changes
@
text
@d64 2
d67 5
d98 1
a98 1
	vfs_getnewfsid(mp);
d182 1
a182 1
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
d186 21
d208 2
a209 2
#define procfs_sync ((int (*) __P((struct mount *, int, struct ucred *, \
				  struct proc *)))nullop)
d211 34
a244 9
#define procfs_fhtovp ((int (*) __P((struct mount *, struct fid *, \
	    struct mbuf *, struct vnode **, int *, struct ucred **)))eopnotsupp)
#define procfs_quotactl ((int (*) __P((struct mount *, int, uid_t, caddr_t, \
	    struct proc *)))eopnotsupp)
#define procfs_sysctl ((int (*) __P((int *, u_int, void *, size_t *, void *, \
	    size_t, struct proc *)))eopnotsupp)
#define procfs_vget ((int (*) __P((struct mount *, ino_t, struct vnode **))) \
	    eopnotsupp)
#define procfs_vptofh ((int (*) __P((struct vnode *, struct fid *)))eopnotsupp)
d247 1
a258 1
	procfs_sysctl
@


1.4
log
@use <sys/queue.h> for pfsnode list.
$OpenBSD$ additions.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.3 1996/06/20 15:12:57 mickey Exp $	*/
a63 2
int	procfs_quotactl __P((struct mount *, int, uid_t, caddr_t,
			     struct proc *));
a64 5
int	procfs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int	procfs_vget __P((struct mount *, ino_t, struct vnode **));
int	procfs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
			   struct vnode **, int *, struct ucred **));
int	procfs_vptofh __P((struct vnode *, struct fid *));
d91 1
a91 1
	getnewfsid(mp, makefstype(MOUNT_PROCFS));
d175 1
a175 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
a178 21
/*ARGSUSED*/
int
procfs_quotactl(mp, cmds, uid, arg, p)
	struct mount *mp;
	int cmds;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

	return (EOPNOTSUPP);
}

/*ARGSUSED*/
int
procfs_sync(mp, waitfor, uc, p)
	struct mount *mp;
	int waitfor;
	struct ucred *uc;
	struct proc *p;
{
d180 2
a181 2
	return (0);
}
d183 9
a191 34
/*ARGSUSED*/
int
procfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{

	return (EOPNOTSUPP);
}

/*ARGSUSED*/
int
procfs_fhtovp(mp, fhp, mb, vpp, what, anon)
	struct mount *mp;
	struct fid *fhp;
	struct mbuf *mb;
	struct vnode **vpp;
	int *what;
	struct ucred **anon;
{

	return (EINVAL);
}

/*ARGSUSED*/
int
procfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
{

	return (EINVAL);
}
a193 1
	MOUNT_PROCFS,
d205 1
@


1.3
log
@show Virtual Memory total/used to df.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_vfsops.c,v 1.2 1996/02/27 08:03:38 niklas Exp $	*/
a243 5
}

void
procfs_init()
{
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d162 1
d164 1
d172 2
a173 2
	sbp->f_blocks = 1;	/* avoid divide by zero in some df's */
	sbp->f_bfree = 0;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: procfs_vfsops.c,v 1.24 1995/06/18 14:47:39 cgd Exp $	*/
d50 1
d60 12
d78 1
d110 1
d127 1
a127 1
	if (error = vflush(mp, 0, flags))
d133 1
d143 1
d156 1
d184 2
d197 3
a199 1
procfs_sync(mp, waitfor)
d202 2
d209 2
d220 3
a222 1
procfs_fhtovp(mp, fhp, vpp)
d225 1
d227 2
d234 2
d244 1
a246 2

	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
