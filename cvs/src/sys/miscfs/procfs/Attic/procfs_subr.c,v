head	1.37;
access;
symbols
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.12
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.8
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.6
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.4
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.28.0.6
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.12
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.10
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2014.09.08.01.57.00;	author guenther;	state dead;
branches;
next	1.36;
commitid	0HlTPhRuQ0I9ZG6q;

1.36
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.35;
commitid	FE3DG5cICjyI4jWx;

1.35
date	2011.12.24.04.34.20;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.10.14.55.11;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2009.04.22.18.57.56;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.04.02.18.43.08;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.09.21.34.32;	author hshoexer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.22.09.38.53;	author jasper;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.11.21.30.31;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.16.22.19.28;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.05.23.52.10;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.11.10.08.04;	author mickey;	state Exp;
branches
	1.20.2.1
	1.20.4.1;
next	1.19;

1.19
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.28.02.00.04;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.00.42.25;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.30.20.29.44;	author nordin;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.15.07.04.21;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.15.07.00.31;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.09.07.14.23;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.12.04.29.24;	author jasoni;	state Exp;
branches;
next	1.11;

1.11
date	97.11.06.05.58.43;	author csapuntz;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	97.10.06.20.20.33;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.15.19.10;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.08.16.02.00.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.08.01.05.58.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.06.21.12.19.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.06.07.00.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.02.06.52.03;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.21.12.49.56;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.08.03.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches;
next	;

1.11.10.1
date	2001.05.14.22.32.55;	author niklas;	state Exp;
branches;
next	1.11.10.2;

1.11.10.2
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.11.10.3;

1.11.10.3
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.11.10.4;

1.11.10.4
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.11.10.5;

1.11.10.5
date	2003.05.13.19.21.30;	author ho;	state Exp;
branches;
next	1.11.10.6;

1.11.10.6
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.11.10.7;

1.11.10.7
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.11.10.8;

1.11.10.8
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.42;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.22.36.12;	author tedu;	state Exp;
branches;
next	;

1.20.2.1
date	2004.05.13.03.08.31;	author brad;	state Exp;
branches;
next	;

1.20.4.1
date	2004.05.13.03.18.21;	author brad;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Actually remove the procfs files
@
text
@/*	$OpenBSD: procfs_subr.c,v 1.36 2014/07/12 18:43:52 tedu Exp $	*/
/*	$NetBSD: procfs_subr.c,v 1.15 1996/02/12 15:01:42 christos Exp $	*/

/*
 * Copyright (c) 1993 Jan-Simon Pendry
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)procfs_subr.c	8.5 (Berkeley) 6/15/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/rwlock.h>
#include <sys/stat.h>
#include <sys/ptrace.h>

#include <miscfs/procfs/procfs.h>

static TAILQ_HEAD(, pfsnode)	pfshead;
struct rwlock pfs_vlock = RWLOCK_INITIALIZER("procfsl");

/*ARGSUSED*/
int
procfs_init(struct vfsconf *vfsp)
{
	TAILQ_INIT(&pfshead);
	return (0);
}

/*
 * allocate a pfsnode/vnode pair.  the vnode is
 * referenced, but not locked.
 *
 * the pid, pfs_type, and mount point uniquely
 * identify a pfsnode.  the mount point is needed
 * because someone might mount this filesystem
 * twice.
 *
 * all pfsnodes are maintained on a singly-linked
 * list.  new nodes are only allocated when they cannot
 * be found on this list.  entries on the list are
 * removed when the vfs reclaim entry is called.
 *
 * a single lock is kept for the entire list.  this is
 * needed because the getnewvnode() function can block
 * waiting for a vnode to become free, in which case there
 * may be more than one process trying to get the same
 * vnode.  this lock is only taken if we are going to
 * call getnewvnode, since the kernel itself is single-threaded.
 *
 * if an entry is found on the list, then call vget() to
 * take a reference.  this is done because there may be
 * zero references to it and so it needs to removed from
 * the vnode free list.
 */
int
procfs_allocvp(struct mount *mp, struct vnode **vpp, pid_t pid, pfstype pfs_type)
{
	struct proc *p = curproc;
	struct pfsnode *pfs;
	struct vnode *vp;
	int error = 0;

	/*
	 * Lock the vp list, getnewvnode can sleep.
	 */
	rw_enter_write(&pfs_vlock);
loop:
	TAILQ_FOREACH(pfs, &pfshead, list) {
		vp = PFSTOV(pfs);
		if (pfs->pfs_pid == pid &&
		    pfs->pfs_type == pfs_type &&
		    vp->v_mount == mp) {
			if (vget(vp, 0, p))
				goto loop;
			*vpp = vp;
			goto out;
		}
	}

	if ((error = getnewvnode(VT_PROCFS, mp, &procfs_vops, vpp)) != 0)
		goto out;
	vp = *vpp;

	pfs = malloc(sizeof(*pfs), M_TEMP, M_WAITOK);
	vp->v_data = pfs;

	pfs->pfs_pid = pid;
	pfs->pfs_type = pfs_type;
	pfs->pfs_vnode = vp;
	pfs->pfs_flags = 0;
	pfs->pfs_fileno = PROCFS_FILENO(pid, pfs_type);

	switch (pfs_type) {
	case Proot:	/* /proc = dr-xr-xr-x */
		pfs->pfs_mode = S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
		vp->v_type = VDIR;
		vp->v_flag = VROOT;
		break;

	case Pcurproc:	/* /proc/curproc = lr--r--r-- */
	case Pself:	/* /proc/self = lr--r--r-- */
		pfs->pfs_mode = S_IRUSR|S_IRGRP|S_IROTH;
		vp->v_type = VLNK;
		break;

	case Pproc:	/* /proc/N = dr-xr-xr-x */
		pfs->pfs_mode = S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
		vp->v_type = VDIR;
		break;

	case Pfile:	/* /proc/N/file = -rw------- */
	case Pmem:	/* /proc/N/mem = -rw------- */
	case Pregs:	/* /proc/N/regs = -rw------- */
	case Pfpregs:	/* /proc/N/fpregs = -rw------- */
		pfs->pfs_mode = S_IRUSR|S_IWUSR;
		vp->v_type = VREG;
		break;

	case Pctl:	/* /proc/N/ctl = --w------ */
	case Pnote:	/* /proc/N/note = --w------ */
	case Pnotepg:	/* /proc/N/notepg = --w------ */
		pfs->pfs_mode = S_IWUSR;
		vp->v_type = VREG;
		break;

	case Pstatus:	/* /proc/N/status = -r--r--r-- */
	case Pcmdline:	/* /proc/N/cmdline = -r--r--r-- */
	case Pmeminfo:	/* /proc/meminfo = -r--r--r-- */
	case Pcpuinfo:	/* /proc/cpuinfo = -r--r--r-- */
		pfs->pfs_mode = S_IRUSR|S_IRGRP|S_IROTH;
		vp->v_type = VREG;
		break;

	default:
		panic("procfs_allocvp");
	}

	/* add to procfs vnode list */
	TAILQ_INSERT_TAIL(&pfshead, pfs, list);
	uvm_vnp_setsize(vp, 0);
out:
	rw_exit_write(&pfs_vlock);

	return (error);
}

int
procfs_freevp(struct vnode *vp)
{
	struct pfsnode *pfs = VTOPFS(vp);

	TAILQ_REMOVE(&pfshead, pfs, list);
	free(vp->v_data, M_TEMP, 0);
	vp->v_data = 0;
	return (0);
}

int
procfs_rw(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uio *uio = ap->a_uio;
	struct proc *curp = uio->uio_procp;
	struct pfsnode *pfs = VTOPFS(vp);
	struct proc *p;

	p = pfind(pfs->pfs_pid);
	if (p == 0 || (p->p_flag & P_THREAD))
		return (EINVAL);
	/* Do not permit games to be played with init(8) */
	if (p->p_pid == 1 && securelevel > 0 && uio->uio_rw == UIO_WRITE)
		return (EPERM);
	if (uio->uio_offset < 0)
		return (EINVAL);

	switch (pfs->pfs_type) {
	case Pstatus:
		return (procfs_dostatus(curp, p, pfs, uio));

	case Pmem:
		return (process_domem(curp, p, uio, PT_WRITE_I));

	case Pcmdline:
		return (procfs_docmdline(curp, p, pfs, uio));

	case Pmeminfo:
		return (procfs_domeminfo(curp, p, pfs, uio));

	case Pcpuinfo:
		return (procfs_docpuinfo(curp, p, pfs, uio));

	default:
		return (EOPNOTSUPP);
	}
}

/*
 * Get a string from userland into (buf).  Strip a trailing
 * nl character (to allow easy access from the shell).
 * The buffer should be *buflenp + 1 chars long.  vfs_getuserstr
 * will automatically add a nul char at the end.
 *
 * Returns 0 on success or the following errors
 *
 * EINVAL:    file offset is non-zero.
 * EMSGSIZE:  message is longer than kernel buffer
 * EFAULT:    user i/o buffer is not addressable
 */
int
vfs_getuserstr(struct uio *uio, char *buf, int *buflenp)
{
	int xlen;
	int error;

	if (uio->uio_offset != 0)
		return (EINVAL);

	xlen = *buflenp;

	/* must be able to read the whole string in one go */
	if (xlen < uio->uio_resid)
		return (EMSGSIZE);
	xlen = uio->uio_resid;

	if ((error = uiomove(buf, xlen, uio)) != 0)
		return (error);

	/* allow multiple writes without seeks */
	uio->uio_offset = 0;

	/* cleanup string and remove trailing newline */
	buf[xlen] = '\0';
	xlen = strlen(buf);
	if (xlen > 0 && buf[xlen-1] == '\n')
		buf[--xlen] = '\0';
	*buflenp = xlen;

	return (0);
}

const vfs_namemap_t *
vfs_findname(const vfs_namemap_t *nm, char *buf, int buflen)
{
	for (; nm->nm_name; nm++)
		if (bcmp(buf, nm->nm_name, buflen + 1) == 0)
			return (nm);

	return (0);
}
@


1.36
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.35 2011/12/24 04:34:20 guenther Exp $	*/
@


1.35
log
@Remove the ability to ptrace via procfs, as no one is using it, so fixing
and extending it to support rthreads would be a waste of time.  Also, don't
show rthreads in the process listing in procfs.

Reassurances that compat_linux doesn't need this from ajacoutot@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.34 2010/12/21 20:14:43 thib Exp $	*/
d187 1
a187 1
	free(vp->v_data, M_TEMP);
@


1.34
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.33 2010/09/10 16:34:08 thib Exp $	*/
d203 1
a203 1
	if (p == 0)
a211 7
	case Pnote:
	case Pnotepg:
		return (procfs_donote(curp, p, pfs, uio));

	case Pctl:
		return (procfs_doctl(curp, p, pfs, uio));

@


1.33
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.32 2010/09/06 23:44:10 thib Exp $	*/
d114 1
a114 1
	if ((error = getnewvnode(VT_PROCFS, mp, procfs_vnodeop_p, vpp)) != 0)
@


1.32
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.31 2009/08/10 14:55:11 oga Exp $	*/
d114 1
a114 1
	if ((error = getnewvnode(VT_PROCFS, mp, &procfs_vops, vpp)) != 0)
@


1.31
log
@lockmgr -> rwlock

same diff as before, with the uninitalized variable fixed.

ok toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.30 2009/04/22 18:57:56 deraadt Exp $	*/
d114 1
a114 1
	if ((error = getnewvnode(VT_PROCFS, mp, procfs_vnodeop_p, vpp)) != 0)
@


1.30
log
@this rwlock conversion breaks procfs (in linux compat), as found out
by Antoine Jacoutot.  back out for oga to look at when he gets back in
touch with earth.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.29 2009/04/02 18:43:08 oga Exp $	*/
d46 1
d53 1
a53 1
struct lock pfs_vlock;
a58 1
	lockinit(&pfs_vlock, PVFS, "procfsl", 0, 0);
d95 1
a95 1
	int error;
d100 1
a100 3
	error = lockmgr(&pfs_vlock, LK_EXCLUSIVE, NULL);
	if (error)
		return (error);
d176 1
a176 1
	lockmgr(&pfs_vlock, LK_RELEASE, NULL);
@


1.29
log
@Convert lockmgr to rwlock. Been in snaps for a while.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.28 2007/12/09 21:34:32 hshoexer Exp $	*/
a42 1
#include <sys/rwlock.h>
d52 1
a52 1
struct rwlock pfs_vlock = RWLOCK_INITIALIZER("procfsl");
d58 1
d100 3
a102 1
	rw_enter_write(&pfs_vlock);
d178 1
a178 1
	rw_exit_write(&pfs_vlock);
@


1.28
log
@MALLOC/FREE -> malloc/free

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.27 2007/06/22 09:38:53 jasper Exp $	*/
d43 1
d53 1
a53 1
struct lock pfs_vlock;
a58 1
	lockinit(&pfs_vlock, PVFS, "procfsl", 0, 0);
d100 1
a100 3
	error = lockmgr(&pfs_vlock, LK_EXCLUSIVE, NULL);
	if (error)
		return (error);
d176 1
a176 1
	lockmgr(&pfs_vlock, LK_RELEASE, NULL);
@


1.27
log
@declare "pid" as pid_t instead of long, and remove unneeded cast to pid_t

ok pedro@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.26 2007/06/18 08:30:07 jasper Exp $	*/
d120 1
a120 1
	MALLOC(pfs, void *, sizeof(struct pfsnode), M_TEMP, M_WAITOK);
d189 1
a189 1
	FREE(vp->v_data, M_TEMP);
@


1.26
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.25 2006/03/05 21:48:56 miod Exp $	*/
d90 1
a90 1
procfs_allocvp(struct mount *mp, struct vnode **vpp, long pid, pfstype pfs_type)
d123 1
a123 1
	pfs->pfs_pid = (pid_t) pid;
@


1.25
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.24 2005/12/11 21:30:31 miod Exp $	*/
d56 1
a56 3
procfs_init(vfsp)
	struct vfsconf *vfsp;

d90 1
a90 5
procfs_allocvp(mp, vpp, pid, pfs_type)
	struct mount *mp;
	struct vnode **vpp;
	long pid;
	pfstype pfs_type;
d184 1
a184 2
procfs_freevp(vp)
	struct vnode *vp;
d195 1
a195 2
procfs_rw(v)
	void *v;
d254 1
a254 4
vfs_getuserstr(uio, buf, buflenp)
	struct uio *uio;
	char *buf;
	int *buflenp;
d286 1
a286 4
vfs_findname(nm, buf, buflen)
	const vfs_namemap_t *nm;
	char *buf;
	int buflen;
a287 1

@


1.24
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.23 2005/11/19 02:18:01 pedro Exp $	*/
d110 1
a110 1
	for (pfs = pfshead.tqh_first; pfs != NULL; pfs = pfs->list.tqe_next) {
@


1.23
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.22 2005/04/16 22:19:28 kettenis Exp $	*/
d47 1
d233 1
a233 1
		return (procfs_domem(curp, p, pfs, uio));
@


1.22
log
@Remove regs and fpregs pseudo-files from procfs.
ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.21 2004/05/05 23:52:10 tedu Exp $	*/
d105 1
a105 1
	error = lockmgr(&pfs_vlock, LK_EXCLUSIVE, NULL, p);
d183 1
a183 1
	lockmgr(&pfs_vlock, LK_RELEASE, NULL, p);
@


1.21
log
@make sure uio_offset is a safe value, with suggestions from millert@@
ok deraadt@@ millert@@
problem noticed by deprotect.com
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.20 2003/08/11 10:08:04 mickey Exp $	*/
a223 8

#ifdef PTRACE
	case Pregs:
		return (procfs_doregs(curp, p, pfs, uio));

	case Pfpregs:
		return (procfs_dofpregs(curp, p, pfs, uio));
#endif
@


1.20
log
@constify constant names
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.19 2003/06/02 23:28:11 millert Exp $	*/
d217 2
@


1.20.4.1
log
@MFC:
Fix by tedu@@

make sure uio_offset is a safe value, with suggestions from millert@@
problem noticed by deprotect.com

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.20 2003/08/11 10:08:04 mickey Exp $	*/
a216 2
	if (uio->uio_offset < 0)
		return (EINVAL);
@


1.20.2.1
log
@MFC:
Fix by tedu@@

make sure uio_offset is a safe value, with suggestions from millert@@
problem noticed by deprotect.com

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.20 2003/08/11 10:08:04 mickey Exp $	*/
a216 2
	if (uio->uio_offset < 0)
		return (EINVAL);
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.18 2003/04/28 02:00:04 tedu Exp $	*/
d301 1
a301 1
vfs_namemap_t *
d303 1
a303 1
	vfs_namemap_t *nm;
d309 1
a309 2
		if (bcmp((const void *) buf, (const void *) nm->nm_name,
		    buflen + 1) == 0)
@


1.18
log
@call lockmgr a bit earlier to avoid a race.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.17 2002/03/14 00:42:25 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.16 2002/01/30 20:29:44 nordin Exp $	*/
d106 6
d121 1
a121 1
			return (0);
a123 5

	/*
	 * Lock the vp list, getnewvnode can sleep.
	 */
	lockmgr(&pfs_vlock, LK_EXCLUSIVE, NULL, p);
@


1.16
log
@Add proc0 to the PIDHASH table. art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.15 2001/11/15 07:04:21 art Exp $	*/
d226 1
d232 1
@


1.15
log
@uvm_vnp_setsize
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.14 2001/11/15 07:00:31 art Exp $	*/
d214 1
a214 1
	p = PFIND(pfs->pfs_pid);
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.16 2002/01/30 20:29:44 nordin Exp $	*/
d214 1
a214 1
	p = pfind(pfs->pfs_pid);
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.15.2.1 2002/01/31 22:55:42 niklas Exp $	*/
a225 1
#ifdef PTRACE
a230 1
#endif
@


1.15.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a105 6
	/*
	 * Lock the vp list, getnewvnode can sleep.
	 */
	error = lockmgr(&pfs_vlock, LK_EXCLUSIVE, NULL, p);
	if (error)
		return (error);
d115 1
a115 1
			goto out;
d118 5
@


1.14
log
@lockmgr instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.13 2001/04/09 07:14:23 tholo Exp $	*/
d184 1
a184 1

@


1.13
log
@Add emulation of Linux features to procfs; mostly from NetBSD.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.12 2000/08/12 04:29:24 jasoni Exp $	*/
d55 1
a55 1
static int pfsvplock;
d63 1
d120 1
a120 2
	 * otherwise lock the vp list while we call getnewvnode
	 * since that can block.
d122 1
a122 6
	if (pfsvplock & PROCFS_LOCKED) {
		pfsvplock |= PROCFS_WANT;
		sleep((caddr_t) &pfsvplock, PINOD);
		goto loop;
	}
	pfsvplock |= PROCFS_LOCKED;
d186 1
a186 6
	pfsvplock &= ~PROCFS_LOCKED;

	if (pfsvplock & PROCFS_WANT) {
		pfsvplock &= ~PROCFS_WANT;
		wakeup((caddr_t) &pfsvplock);
	}
@


1.12
log
@Add procfs/cmdline; to help with linux emulation.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.11 1997/11/06 05:58:43 csapuntz Exp $	*/
d150 1
d176 3
a178 1
	case Pcmdline:
d253 6
@


1.11
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.10 1997/10/06 20:20:33 deraadt Exp $	*/
d175 1
d247 3
@


1.11.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.13 2001/04/09 07:14:23 tholo Exp $	*/
a149 1
	case Pself:	/* /proc/self = lr--r--r-- */
a174 3
	case Pcmdline:	/* /proc/N/cmdline = -r--r--r-- */
	case Pmeminfo:	/* /proc/meminfo = -r--r--r-- */
	case Pcpuinfo:	/* /proc/cpuinfo = -r--r--r-- */
a245 9

	case Pcmdline:
		return (procfs_docmdline(curp, p, pfs, uio));

	case Pmeminfo:
		return (procfs_domeminfo(curp, p, pfs, uio));

	case Pcpuinfo:
		return (procfs_docpuinfo(curp, p, pfs, uio));
@


1.11.10.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
struct lock pfs_vlock;
a62 1
	lockinit(&pfs_vlock, PVFS, "procfsl", 0, 0);
d119 2
a120 1
	 * Lock the vp list, getnewvnode can sleep.
d122 6
a127 1
	lockmgr(&pfs_vlock, LK_EXCLUSIVE, NULL, p);
d189 1
a189 1
	uvm_vnp_setsize(vp, 0);
d191 6
a196 1
	lockmgr(&pfs_vlock, LK_RELEASE, NULL, p);
@


1.11.10.3
log
@Merge in trunk
@
text
@d214 1
a214 1
	p = pfind(pfs->pfs_pid);
@


1.11.10.4
log
@Merge in -current from roughly a week ago
@
text
@a225 1
#ifdef PTRACE
a230 1
#endif
@


1.11.10.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.11.10.4 2002/03/28 15:02:01 niklas Exp $	*/
a105 6
	/*
	 * Lock the vp list, getnewvnode can sleep.
	 */
	error = lockmgr(&pfs_vlock, LK_EXCLUSIVE, NULL, p);
	if (error)
		return (error);
d115 1
a115 1
			goto out;
d118 5
@


1.11.10.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.11.10.5 2003/05/13 19:21:30 ho Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.10.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d301 1
a301 1
const vfs_namemap_t *
d303 1
a303 1
	const vfs_namemap_t *nm;
d309 2
a310 1
		if (bcmp(buf, nm->nm_name, buflen + 1) == 0)
@


1.11.10.8
log
@Merge with the trunk
@
text
@a216 2
	if (uio->uio_offset < 0)
		return (EINVAL);
@


1.10
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.8 1997/08/16 02:00:49 millert Exp $	*/
d57 5
a61 2
void
procfs_init(void)
d64 1
d100 1
d111 1
a111 1
			if (vget(vp, 0))
@


1.9
log
@VFS Lite2 Changes
@
text
@d57 2
a58 5
/*ARGSUSED*/
int
procfs_init(vfsp)
	struct vfsconf *vfsp;

a60 1
	return (0);
a95 1
	struct proc *p = curproc;
d106 1
a106 1
			if (vget(vp, 0, p))
@


1.8
log
@1) pfs_mode should be mode_t, not u_short
2) Fix procfs security hole.  This is basically the NetBSD fix
   (which is based in part on Sean Eric Fagan's FreeBSD fix)
   with a few minor changes.  The change creates as function,
   procfs_checkioperm(), that has check numbers 3 and 4 from sys_ptrace().
3) Make procfs_control() use procfs_checkioperm() as well (it
   already had the same basic checks but some of them were incorrect).
4) Minor stylistic cleanups, including the use of the SET/CLR/ISSET
   macros to aid general grokability.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.7 1997/08/01 05:58:56 millert Exp $	*/
d57 5
a61 2
void
procfs_init(void)
d64 1
d100 1
d111 1
a111 1
			if (vget(vp, 0))
@


1.7
log
@From NetBSD (mycroft):
    Eliminate bogus uses of V{READ,WRITE,EXEC}.  Use S_I[RWX]{USR,GRP,OTH}
    where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.6 1997/06/21 12:19:45 deraadt Exp $	*/
d116 1
a116 1
	 */ 
@


1.6
log
@block all write ops to init in securelevel modes; nash@@mcs.com
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.5 1997/04/06 07:00:14 millert Exp $	*/
d50 2
d139 1
a139 3
		pfs->pfs_mode = (VREAD|VEXEC) |
				(VREAD|VEXEC) >> 3 |
				(VREAD|VEXEC) >> 6;
d145 1
a145 3
		pfs->pfs_mode = (VREAD) |
				(VREAD >> 3) |
				(VREAD >> 6);
d149 2
a150 4
	case Pproc:
		pfs->pfs_mode = (VREAD|VEXEC) |
				(VREAD|VEXEC) >> 3 |
				(VREAD|VEXEC) >> 6;
d154 5
a158 5
	case Pfile:
	case Pmem:
	case Pregs:
	case Pfpregs:
		pfs->pfs_mode = (VREAD|VWRITE);
d162 4
a165 4
	case Pctl:
	case Pnote:
	case Pnotepg:
		pfs->pfs_mode = (VWRITE);
d169 2
a170 4
	case Pstatus:
		pfs->pfs_mode = (VREAD) |
				(VREAD >> 3) |
				(VREAD >> 6);
@


1.5
log
@Fix improper cast (compiler warning).
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.4 1996/07/02 06:52:03 niklas Exp $	*/
d224 3
@


1.4
log
@-Wall & -Wstrict-prototype fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.3 1996/06/21 12:49:56 mickey Exp $	*/
d305 2
a306 1
		if (bcmp(buf, (char *) nm->nm_name, buflen+1) == 0)
@


1.3
log
@use <sys/queue.h> for pfsnode list.
$OpenBSD$ additions.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_subr.c,v 1.2 1996/02/27 08:03:37 niklas Exp $	*/
a95 1
	struct pfsnode **pp;
a201 1
	struct pfsnode **pfspp;
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
static struct pfsnode *pfshead;
d55 6
d100 1
a100 1
	for (pfs = pfshead; pfs != 0; pfs = pfs->pfs_next) {
a129 1
	pfs->pfs_next = 0;
d186 1
a186 3
	for (pp = &pfshead; *pp; pp = &(*pp)->pfs_next)
		continue;
	*pp = pfs;
d206 1
a206 7
	for (pfspp = &pfshead; *pfspp != 0; pfspp = &(*pfspp)->pfs_next) {
		if (*pfspp == pfs) {
			*pfspp = pfs->pfs_next;
			break;
		}
	}

@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: procfs_subr.c,v 1.13 1994/06/29 06:34:57 cgd Exp $	*/
d117 1
a117 1
	if (error = getnewvnode(VT_PROCFS, mp, procfs_vnodeop_p, vpp))
d216 2
a217 2
procfs_rw(ap)
	struct vop_read_args *ap;
d219 1
d286 1
a286 1
	if (error = uiomove(buf, xlen, uio))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
