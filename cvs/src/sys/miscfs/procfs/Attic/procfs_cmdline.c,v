head	1.14;
access;
symbols
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.10.0.10
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.6
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.3.0.12
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.10
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.8
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.2
	UBC_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.6
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.09.08.01.57.00;	author guenther;	state dead;
branches;
next	1.13;
commitid	0HlTPhRuQ0I9ZG6q;

1.13
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.12;
commitid	FE3DG5cICjyI4jWx;

1.12
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	EF98ch02VpFassUi;

1.11
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.10;
commitid	vhXZZxMGVTWiFaF3;

1.10
date	2012.03.10.05.54.28;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.10.03.38.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.29.12.24.18;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.11.21.30.31;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.04.21.48.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.05.23.52.09;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.3.10.1
	1.3.12.1;
next	1.2;

1.2
date	2001.06.27.04.58.43;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.12.04.29.24;	author jasoni;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2001.05.14.22.32.55;	author niklas;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2001.07.04.10.49.14;	author niklas;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.3.10.1
date	2004.05.13.03.08.31;	author brad;	state Exp;
branches;
next	;

1.3.12.1
date	2004.05.13.03.18.21;	author brad;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Actually remove the procfs files
@
text
@/*	$OpenBSD: procfs_cmdline.c,v 1.13 2014/07/12 18:43:52 tedu Exp $	*/
/*	$NetBSD: procfs_cmdline.c,v 1.3 1999/03/13 22:26:48 thorpej Exp $	*/

/*
 * Copyright (c) 1999 Jaromir Dolecek <dolecek@@ics.muni.cz>
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jaromir Dolecek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <sys/syslimits.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/exec.h>
#include <sys/malloc.h>
#include <miscfs/procfs/procfs.h>

/*
 * code for returning process's command line arguments
 */
int
procfs_docmdline(struct proc *curp, struct proc *p, struct pfsnode *pfs, struct uio *uio)
{
	struct process *pr = p->p_p;
	struct ps_strings pss;
	int count, error, i;
	size_t len, xlen, upper_bound;
	struct uio auio;
	struct iovec aiov;
	struct vmspace *vm;
	vaddr_t argv;
	char *arg;

	/* Don't allow writing. */
	if (uio->uio_rw != UIO_READ)
		return (EOPNOTSUPP);

	/*
	 * Allocate a temporary buffer to hold the arguments.
	 */
	arg = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);

	/*
	 * Zombies don't have a stack, so we can't read their psstrings.
	 * System processes also don't have a user stack.  This is what
	 * ps(1) would display.
	 */
	if (pr->ps_flags & (PS_ZOMBIE | PS_SYSTEM)) {
                len = snprintf(arg, PAGE_SIZE, "(%s)", p->p_comm);
                if (uio->uio_offset >= (off_t)len)
                        error = 0;
                else
                        error = uiomove(arg, len - uio->uio_offset, uio);
		
                free(arg, M_TEMP, 0);
                return (error);	
	}

	/*
	 * NOTE: Don't bother doing a process_checkioperm() here
	 * because the psstrings info is available by using ps(1),
	 * so it's not like there's anything to protect here.
	 */

	/*
	 * Lock the process down in memory.
	 */
	/* XXXCDC: how should locking work here? */
	if ((pr->ps_flags & PS_EXITING) || (pr->ps_vmspace->vm_refcnt < 1)) {
		free(arg, M_TEMP, 0);
		return (EFAULT);
	}
	vm = pr->ps_vmspace;
	vm->vm_refcnt++;	/* XXX */

	/*
	 * Read in the ps_strings structure.
	 */
	aiov.iov_base = &pss;
	aiov.iov_len = sizeof(pss);
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_offset = (vaddr_t)PS_STRINGS;
	auio.uio_resid = sizeof(pss);
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_rw = UIO_READ;
	auio.uio_procp = NULL;
	error = uvm_io(&vm->vm_map, &auio, 0);
	if (error)
		goto bad;

	/*
	 * Now read the address of the argument vector.
	 */
	aiov.iov_base = &argv;
	aiov.iov_len = sizeof(argv);
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_offset = (vaddr_t)pss.ps_argvstr;
	auio.uio_resid = sizeof(argv);
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_rw = UIO_READ; 
	auio.uio_procp = NULL;
	error = uvm_io(&vm->vm_map, &auio, 0);
	if (error)
		goto bad;

	/*
	 * Now copy in the actual argument vector, one byte at a time,
	 * since we don't know how long the vector is (though, we do
	 * know how many NUL-terminated strings are in the vector).
	 */
	len = 0;
	count = pss.ps_nargvstr;
	upper_bound = round_page(uio->uio_offset + uio->uio_resid);
	for (; count && len < upper_bound; len += xlen) {
		aiov.iov_base = arg;
		aiov.iov_len = PAGE_SIZE;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_offset = argv + len;
		xlen = PAGE_SIZE - ((argv + len) & PAGE_MASK);
		auio.uio_resid = xlen;
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_rw = UIO_READ;
		auio.uio_procp = NULL;
		error = uvm_io(&vm->vm_map, &auio, 0);
		if (error)
			goto bad;

		for (i = 0; i < xlen && count != 0; i++) {
			if (arg[i] == '\0')
                                count--;        /* one full string */
                }

		if (count == 0)
                        i--;                /* exclude the final NUL */

                if (len + i > uio->uio_offset) {
                        /* Have data in this page, copy it out */
                        error = uiomove(arg + uio->uio_offset - len,
                            i + len - uio->uio_offset, uio);
                        if (error || uio->uio_resid <= 0)
                                break;
                }
	}


 bad:
	uvmspace_free(vm);
	free(arg, M_TEMP, 0);
	return (error);
}
@


1.13
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.12 2014/07/08 17:19:25 deraadt Exp $	*/
@


1.12
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.11 2014/07/04 05:58:31 guenther Exp $	*/
d88 1
a88 1
                free(arg, M_TEMP);
d103 1
a103 1
		free(arg, M_TEMP);
d184 1
a184 1
	free(arg, M_TEMP);
@


1.11
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.10 2012/03/10 05:54:28 guenther Exp $	*/
a49 1
#include <uvm/uvm_extern.h>
@


1.10
log
@Add PS_EXITING to better differentiate between the process exiting and
the main thread exiting.  c.f. regress/sys/kern/main-thread-exited/
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.9 2008/11/10 03:38:53 deraadt Exp $	*/
d58 1
d82 1
a82 1
	if (P_ZOMBIE(p) || (p->p_flag & P_SYSTEM) != 0) {
d103 1
a103 1
	if ((p->p_p->ps_flags & PS_EXITING) || (p->p_vmspace->vm_refcnt < 1)) {
d107 1
a107 1
	vm = p->p_vmspace;
@


1.9
log
@same vmspace song and dance as in kern_sysctl.c 1.167; ok kurt
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.8 2007/06/18 08:30:07 jasper Exp $	*/
d102 1
a102 1
	if ((p->p_flag & P_WEXIT) || (p->p_vmspace->vm_refcnt < 1)) {
@


1.8
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.7 2006/11/29 12:24:18 miod Exp $	*/
d63 1
d106 2
a107 1
	p->p_vmspace->vm_refcnt++;	/* XXX */
d121 1
a121 1
	error = uvm_io(&p->p_vmspace->vm_map, &auio, 0);
d137 1
a137 1
	error = uvm_io(&p->p_vmspace->vm_map, &auio, 0);
d160 1
a160 1
		error = uvm_io(&p->p_vmspace->vm_map, &auio, 0);
d183 1
a183 1
	uvmspace_free(p->p_vmspace);
@


1.7
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.6 2005/12/11 21:30:31 miod Exp $	*/
d56 1
a56 5
procfs_docmdline(curp, p, pfs, uio)
	struct proc *curp;
	struct proc *p;
	struct pfsnode *pfs;
	struct uio *uio;
@


1.6
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.5 2005/11/04 21:48:07 miod Exp $	*/
a108 1
	PHOLD(p);
a184 1
	PRELE(p);
@


1.5
log
@Add an extra flags argument to uvm_io(), to specify whether we want to fix
the protection of the memory mapping we're doing I/O on, or if we want to
leave them as they are. This should only be necessary for breakpoint
insertion in code, so we'll only use it for ptrace requests.

Initially from art@@ after discussion with kettenis@@ millert@@ and I,
tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.4 2004/05/05 23:52:09 tedu Exp $	*/
d96 1
a96 1
	 * NOTE: Don't bother doing a procfs_checkioperm() here
@


1.4
log
@make sure uio_offset is a safe value, with suggestions from millert@@
ok deraadt@@ millert@@
problem noticed by deprotect.com
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.3 2001/11/06 19:53:20 miod Exp $	*/
d124 1
a124 1
	error = uvm_io(&p->p_vmspace->vm_map, &auio);
d140 1
a140 1
	error = uvm_io(&p->p_vmspace->vm_map, &auio);
d163 1
a163 1
		error = uvm_io(&p->p_vmspace->vm_map, &auio);
@


1.3
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.2 2001/06/27 04:58:43 art Exp $	*/
d86 1
a86 2
                xlen = len - uio->uio_offset;
                if (xlen <= 0) 
d89 1
a89 1
                        error = uiomove(arg, xlen, uio);
@


1.3.12.1
log
@MFC:
Fix by tedu@@

make sure uio_offset is a safe value, with suggestions from millert@@
problem noticed by deprotect.com

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.3 2001/11/06 19:53:20 miod Exp $	*/
d86 2
a87 1
                if (uio->uio_offset >= (off_t)len)
d90 1
a90 1
                        error = uiomove(arg, len - uio->uio_offset, uio);
@


1.3.10.1
log
@MFC:
Fix by tedu@@

make sure uio_offset is a safe value, with suggestions from millert@@
problem noticed by deprotect.com

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.3 2001/11/06 19:53:20 miod Exp $	*/
d86 2
a87 1
                if (uio->uio_offset >= (off_t)len)
d90 1
a90 1
                        error = uiomove(arg, len - uio->uio_offset, uio);
@


1.2
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.1 2000/08/12 04:29:24 jasoni Exp $	*/
a49 2
#include <vm/vm.h>

@


1.1
log
@Add procfs/cmdline; to help with linux emulation.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a51 1
#if defined(UVM)
a52 1
#endif
a106 1
#if defined(UVM)
a113 3
#else
	PHOLD(p);
#endif
a126 1
#if defined(UVM)
a127 3
#else
	error = procfs_rwmem(p, &auio);
#endif
a142 1
#if defined(UVM)
a143 3
#else
	error = procfs_rwmem(p, &auio);
#endif
a165 1
#if defined(UVM)
a166 3
#else
		error = procfs_rwmem(p, &auio);
#endif
a188 1
#if defined(UVM)
a190 3
#else
	PRELE(p);
#endif
@


1.1.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.1 2000/08/12 04:29:24 jasoni Exp $	*/
@


1.1.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_cmdline.c,v 1.1.6.1 2001/05/14 22:32:55 niklas Exp $	*/
d52 1
d54 1
d109 1
d117 3
d133 1
d135 3
d153 1
d155 3
d180 1
d182 3
d207 1
d210 3
@


1.1.6.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 2
@


1.1.6.4
log
@Merge with the trunk
@
text
@d86 2
a87 1
                if (uio->uio_offset >= (off_t)len)
d90 1
a90 1
                        error = uiomove(arg, len - uio->uio_offset, uio);
@


