head	1.23;
access;
symbols
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.10
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.12
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.8
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.7.0.22
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.20
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.18
	OPENBSD_2_8:1.7.0.16
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.14
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2011.12.24.04.34.20;	author guenther;	state dead;
branches;
next	1.22;

1.22
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.29.12.24.18;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.28.20.53.18;	author tsi;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.11.21.30.31;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.31.11.35.33;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.29.03.20.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.20.18.32.38;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.11.10.08.04;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.00.42.25;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.30.20.45.35;	author nordin;	state Exp;
branches;
next	1.7;

1.7
date	97.08.29.04.24.37;	author millert;	state Exp;
branches
	1.7.12.1
	1.7.22.1;
next	1.6;

1.6
date	97.08.16.02.00.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.10.14.09.27.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.27.01.52.01;	author bitblt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.26.18.06.34;	author bitblt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.08.03.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.01;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.7.12.5;

1.7.12.5
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.7.22.1
date	2002.01.31.22.55.42;	author niklas;	state Exp;
branches;
next	1.7.22.2;

1.7.22.2
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove the ability to ptrace via procfs, as no one is using it, so fixing
and extending it to support rthreads would be a waste of time.  Also, don't
show rthreads in the process listing in procfs.

Reassurances that compat_linux doesn't need this from ajacoutot@@
ok kettenis@@
@
text
@/*	$OpenBSD: procfs_ctl.c,v 1.22 2010/07/26 01:56:27 guenther Exp $	*/
/*	$NetBSD: procfs_ctl.c,v 1.14 1996/02/09 22:40:48 christos Exp $	*/

/*
 * Copyright (c) 1993 Jan-Simon Pendry
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)procfs_ctl.c	8.4 (Berkeley) 6/15/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <sys/ptrace.h>
#include <sys/sched.h>
#include <miscfs/procfs/procfs.h>

/*
 * True iff process (p) is in trace wait state
 * relative to process (curp)
 */
#define TRACE_WAIT_P(curp, p) \
	((p)->p_stat == SSTOP && \
	 (p)->p_p->ps_pptr == (curp)->p_p && \
	 ISSET((p)->p_flag, P_TRACED))

#ifdef PTRACE

#define PROCFS_CTL_ATTACH	1
#define PROCFS_CTL_DETACH	2
#define PROCFS_CTL_STEP		3
#define PROCFS_CTL_RUN		4
#define PROCFS_CTL_WAIT		5

static const vfs_namemap_t ctlnames[] = {
	/* special /proc commands */
	{ "attach",	PROCFS_CTL_ATTACH },
	{ "detach",	PROCFS_CTL_DETACH },
	{ "step",	PROCFS_CTL_STEP },
	{ "run",	PROCFS_CTL_RUN },
	{ "wait",	PROCFS_CTL_WAIT },
	{ 0 },
};

#endif

static const vfs_namemap_t signames[] = {
	/* regular signal names */
	{ "hup",	SIGHUP },	{ "int",	SIGINT },
	{ "quit",	SIGQUIT },	{ "ill",	SIGILL },
	{ "trap",	SIGTRAP },	{ "abrt",	SIGABRT },
	{ "iot",	SIGIOT },	{ "emt",	SIGEMT },
	{ "fpe",	SIGFPE },	{ "kill",	SIGKILL },
	{ "bus",	SIGBUS },	{ "segv",	SIGSEGV },
	{ "sys",	SIGSYS },	{ "pipe",	SIGPIPE },
	{ "alrm",	SIGALRM },	{ "term",	SIGTERM },
	{ "urg",	SIGURG },	{ "stop",	SIGSTOP },
	{ "tstp",	SIGTSTP },	{ "cont",	SIGCONT },
	{ "chld",	SIGCHLD },	{ "ttin",	SIGTTIN },
	{ "ttou",	SIGTTOU },	{ "io",		SIGIO },
	{ "xcpu",	SIGXCPU },	{ "xfsz",	SIGXFSZ },
	{ "vtalrm",	SIGVTALRM },	{ "prof",	SIGPROF },
	{ "winch",	SIGWINCH },	{ "info",	SIGINFO },
	{ "usr1",	SIGUSR1 },	{ "usr2",	SIGUSR2 },
	{ 0 },
};

#ifdef PTRACE
static int procfs_control(struct proc *, struct proc *, int);

static int
procfs_control(struct proc *curp, struct proc *p, int op)
/* *curp being the tracer, and *p the traced */
{
	int error;
	int s;

	/*
	 * Attach - attaches the target process for debugging
	 * by the calling process.
	 */
	if (op == PROCFS_CTL_ATTACH) {
		/* Can't trace yourself! */
		if (p->p_pid == curp->p_pid)
			return (EINVAL);

		/* Check whether already being traced. */
		if (ISSET(p->p_flag, P_TRACED))
			return (EBUSY);

		if ((error = process_checkioperm(curp, p)) != 0)
			return (error);

		/*
		 * Go ahead and set the trace flag.
		 * Save the old parent (it's reset in
		 *   _DETACH, and also in kern_exit.c:wait4()
		 * Reparent the process so that the tracing
		 *   proc gets to see all the action.
		 * Stop the target.
		 */
		atomic_setbits_int(&p->p_flag, P_TRACED);
		p->p_xstat = 0;		/* XXX ? */
		if (p->p_p->ps_pptr != curp->p_p) {
			p->p_oppid = p->p_p->ps_pptr->ps_pid;
			proc_reparent(p->p_p, curp->p_p);
		}
		psignal(p, SIGSTOP);
		return (0);
	}

	/*
	 * Target process must be stopped, owned by (curp) and
	 * be set up for tracing (P_TRACED flag set).
	 * Allow DETACH to take place at any time for sanity.
	 * Allow WAIT any time, of course.
	 */
	switch (op) {
	case PROCFS_CTL_DETACH:
	case PROCFS_CTL_WAIT:
		break;

	default:
		if (!TRACE_WAIT_P(curp, p))
			return (EBUSY);
	}

	/*
	 * do single-step fixup if needed
	 */
	FIX_SSTEP(p);

	/*
	 * Don't deliver any signal by default.
	 * To continue with a signal, just send
	 * the signal name to the ctl file
	 */
	p->p_xstat = 0;

	switch (op) {
	/*
	 * Detach.  Cleans up the target process, reparent it if possible
	 * and set it running once more.
	 */
	case PROCFS_CTL_DETACH:
		/* if not being traced, then this is a painless no-op */
		if (!ISSET(p->p_flag, P_TRACED))
			return (0);

		/* not being traced any more */
		atomic_clearbits_int(&p->p_flag, P_TRACED);

		/* give process back to original parent */
		if (p->p_oppid != p->p_p->ps_pptr->ps_pid) {
			struct process *ppr;

			ppr = prfind(p->p_oppid);
			if (ppr)
				proc_reparent(p->p_p, ppr);
		}

		p->p_oppid = 0;
		atomic_clearbits_int(&p->p_flag, P_WAITED);
		wakeup(curp);	/* XXX for CTL_WAIT below ? */

		break;

	/*
	 * Step.  Let the target process execute a single instruction.
	 */
	case PROCFS_CTL_STEP:
#ifdef PT_STEP
		error = process_sstep(p, 1);
		if (error)
			return (error);
		break;
#else
		return (EOPNOTSUPP);
#endif

	/*
	 * Run.  Let the target process continue running until a breakpoint
	 * or some other trap.
	 */
	case PROCFS_CTL_RUN:
		break;

	/*
	 * Wait for the target process to stop.
	 * If the target is not being traced then just wait
	 * to enter
	 */
	case PROCFS_CTL_WAIT:
		error = 0;
		if (ISSET(p->p_flag, P_TRACED)) {
			while (error == 0 &&
					(p->p_stat != SSTOP) &&
					ISSET(p->p_flag, P_TRACED) &&
					(p->p_p->ps_pptr == curp->p_p)) {
				error = tsleep(p, PWAIT|PCATCH, "procfsx", 0);
			}
			if (error == 0 && !TRACE_WAIT_P(curp, p))
				error = EBUSY;
		} else {
			while (error == 0 && p->p_stat != SSTOP) {
				error = tsleep(p, PWAIT|PCATCH, "procfs", 0);
			}
		}
		return (error);

#ifdef DIAGNOSTIC
	default:
		panic("procfs_control");
#endif
	}

	SCHED_LOCK(s);
	if (p->p_stat == SSTOP)
		setrunnable(p);
	SCHED_UNLOCK(s);
	return (0);
}
#endif

int
procfs_doctl(struct proc *curp, struct proc *p, struct pfsnode *pfs, struct uio *uio)
{
	int xlen;
	int error;
	char msg[PROCFS_CTLLEN+1];
	const vfs_namemap_t *nm;
	int s;

	if (uio->uio_rw != UIO_WRITE)
		return (EOPNOTSUPP);

	xlen = PROCFS_CTLLEN;
	error = vfs_getuserstr(uio, msg, &xlen);
	if (error)
		return (error);

	/*
	 * Map signal names into signal generation
	 * or debug control.  Unknown commands and/or signals
	 * return EOPNOTSUPP.
	 *
	 * Sending a signal while the process is being debugged
	 * also has the side effect of letting the target continue
	 * to run.  There is no way to single-step a signal delivery.
	 */
	error = EOPNOTSUPP;

#ifdef PTRACE
	nm = vfs_findname(ctlnames, msg, xlen);
	if (nm) {
		error = procfs_control(curp, p, nm->nm_val);
	} else
#endif
	{
		nm = vfs_findname(signames, msg, xlen);
		if (nm) {
			if (TRACE_WAIT_P(curp, p)) {
				p->p_xstat = nm->nm_val;
				FIX_SSTEP(p);
				SCHED_LOCK(s);
				setrunnable(p);
				SCHED_UNLOCK(s);
			} else {
				psignal(p, nm->nm_val);
			}
			error = 0;
		}
	}

	return (error);
}
@


1.22
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.21 2007/06/18 08:30:07 jasper Exp $	*/
@


1.21
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.20 2007/03/15 10:22:30 art Exp $	*/
d60 1
a60 1
	 (p)->p_pptr == (curp) && \
d140 3
a142 3
		if (p->p_pptr != curp) {
			p->p_oppid = p->p_pptr->p_pid;
			proc_reparent(p, curp);
d190 2
a191 2
		if (p->p_oppid != p->p_pptr->p_pid) {
			struct proc *pp;
d193 3
a195 3
			pp = pfind(p->p_oppid);
			if (pp)
				proc_reparent(p, pp);
d235 1
a235 1
					(p->p_pptr == curp)) {
@


1.20
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.19 2006/11/29 12:24:18 miod Exp $	*/
d108 2
a109 4
procfs_control(curp, p, op)
	struct proc *curp;		/* tracer */
	struct proc *p;			/* traced */
	int op;
d262 1
a262 5
procfs_doctl(curp, p, pfs, uio)
	struct proc *curp;
	struct pfsnode *pfs;
	struct uio *uio;
	struct proc *p;
@


1.19
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.18 2006/08/28 20:53:18 tsi Exp $	*/
d140 1
a140 1
		p->p_flag |= P_TRACED;
d189 1
a189 1
		CLR(p->p_flag, P_TRACED);
d201 1
a201 1
		CLR(p->p_flag, P_WAITED); /* XXX ? */
@


1.18
log
@Allow building procfs on systems that don't #define PT_STEP (such as sparc64).

ok pedro@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.17 2005/12/11 21:30:31 miod Exp $	*/
a210 1
		PHOLD(p);
a211 1
		PRELE(p);
@


1.17
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.16 2005/05/31 11:35:33 art Exp $	*/
d210 1
d217 3
@


1.16
log
@Protect the run queues with SCHED_LOCK, not just spl (ot nothing at all in
one case fixed here).

miod@@ "appears to be harmless"
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.14 2005/05/25 23:17:47 niklas Exp $	*/
d129 1
a129 1
		if ((error = procfs_checkioperm(curp, p)) != 0)
@


1.15
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.13 2004/05/20 18:32:38 tedu Exp $	*/
d51 1
d114 1
d253 1
d256 1
d272 1
d305 1
d307 1
@


1.14
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@a50 1
#include <sys/sched.h>
a112 1
	int s;
a250 1
	SCHED_LOCK(s);
a252 1
	SCHED_UNLOCK(s);
a267 1
	int s;
a299 1
				SCHED_LOCK(s);
a300 1
				SCHED_UNLOCK(s);
@


1.13
log
@remove more caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.12 2003/08/11 10:08:04 mickey Exp $	*/
d51 1
d114 1
d253 1
d256 1
d272 1
d305 1
d307 1
@


1.12
log
@constify constant names
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.11 2003/06/02 23:28:11 millert Exp $	*/
d200 1
a200 1
		wakeup((caddr_t) curp);	/* XXX for CTL_WAIT below ? */
d234 1
a234 2
				error = tsleep((caddr_t) p,
						PWAIT|PCATCH, "procfsx", 0);
d240 1
a240 2
				error = tsleep((caddr_t) p,
						PWAIT|PCATCH, "procfs", 0);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.10 2002/03/14 01:27:08 millert Exp $	*/
d70 1
a70 1
static vfs_namemap_t ctlnames[] = {
d82 1
a82 1
static vfs_namemap_t signames[] = {
d269 1
a269 1
	vfs_namemap_t *nm;
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.9 2002/03/14 00:42:25 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.8 2002/01/30 20:45:35 nordin Exp $	*/
d108 1
a108 1
static int procfs_control __P((struct proc *, struct proc *, int));
@


1.8
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.7 1997/08/29 04:24:37 millert Exp $	*/
d66 2
d84 2
d107 1
d251 1
d254 1
d261 1
d294 1
d298 3
a300 1
	} else {
@


1.7
log
@From NetBSD (thorpej):
    Fix a reversed argument which caused procfs_checkioperm() to always
    return OK".  Add a few comments to avoid further confusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.6 1997/08/16 02:00:48 millert Exp $	*/
a103 5

/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))
@


1.7.12.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 5
@


1.7.12.2
log
@Merge in -current from roughly a week ago
@
text
@a65 2
#ifdef PTRACE

a81 2
#endif

d103 1
a103 2
#ifdef PTRACE
static int procfs_control(struct proc *, struct proc *, int);
a245 1
#ifdef DIAGNOSTIC
a247 1
#endif
a253 1
#endif
a285 1
#ifdef PTRACE
d289 1
a289 3
	} else
#endif
	{
@


1.7.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.7.12.2 2002/03/28 15:02:01 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.12.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
static const vfs_namemap_t ctlnames[] = {
d82 1
a82 1
static const vfs_namemap_t signames[] = {
d269 1
a269 1
	const vfs_namemap_t *nm;
@


1.7.12.5
log
@Merge with the trunk
@
text
@d200 1
a200 1
		wakeup(curp);	/* XXX for CTL_WAIT below ? */
d234 2
a235 1
				error = tsleep(p, PWAIT|PCATCH, "procfsx", 0);
d241 2
a242 1
				error = tsleep(p, PWAIT|PCATCH, "procfs", 0);
@


1.7.22.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.8 2002/01/30 20:45:35 nordin Exp $	*/
d104 5
@


1.7.22.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.7.22.1 2002/01/31 22:55:42 niklas Exp $	*/
a65 2
#ifdef PTRACE

a81 2
#endif

d103 1
a103 2
#ifdef PTRACE
static int procfs_control(struct proc *, struct proc *, int);
a245 1
#ifdef DIAGNOSTIC
a247 1
#endif
a253 1
#endif
a285 1
#ifdef PTRACE
d289 1
a289 3
	} else
#endif
	{
@


1.6
log
@1) pfs_mode should be mode_t, not u_short
2) Fix procfs security hole.  This is basically the NetBSD fix
   (which is based in part on Sean Eric Fagan's FreeBSD fix)
   with a few minor changes.  The change creates as function,
   procfs_checkioperm(), that has check numbers 3 and 4 from sys_ptrace().
3) Make procfs_control() use procfs_checkioperm() as well (it
   already had the same basic checks but some of them were incorrect).
4) Minor stylistic cleanups, including the use of the SET/CLR/ISSET
   macros to aid general grokability.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.5 1996/10/14 09:27:54 deraadt Exp $	*/
d112 2
a113 2
	struct proc *curp;
	struct proc *p;
@


1.5
log
@mimic ptrace behaviour; worked out with bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.3 1996/09/26 18:06:34 bitblt Exp $	*/
d64 1
a64 1
	 ((p)->p_flag & P_TRACED))
d123 1
a123 1
		/* can't trace yourself! */
d127 2
a128 2
		/* check whether already being traced */
		if (p->p_flag & P_TRACED)
d131 1
a131 7
		/*
		 * it's not owned by you, or the last exec gave us
		 * setuid/setgid privs (unless you're root),
		 */
		if ((p->p_cred->p_ruid != curp->p_cred->p_ruid ||
			ISSET(p->p_flag, P_SUGID)) &&
		    (error = suser(p->p_ucred, &p->p_acflag)) != 0)
a134 8
		 * ...it's init, which controls the security level
		 * -1 -- permanently insecure
		 *  0 -- insecure/single-user
		 */
		if ((p->p_pid) == 1 && (securelevel > -1))
			return (EPERM);

		/*
d187 1
a187 1
		if ((p->p_flag & P_TRACED) == 0)
d191 1
a191 1
		p->p_flag &= ~P_TRACED;
d203 1
a203 1
		p->p_flag &= ~P_WAITED;	/* XXX ? */
d233 1
a233 1
		if (p->p_flag & P_TRACED) {
d236 1
a236 1
					(p->p_flag & P_TRACED) &&
@


1.4
log
@Boy do I feel like a fool.  I added a bugfix to Theos' changes, and then
discovered that I had commited a bunch of nonfunctional changes Theo
had made, but not debugged.  This undoes both my changes, and Theo's.
When this code is functional, it will be put back in.

Thank you for pointing this out to me David Mazieres.
@
text
@d105 5
d123 4
d131 8
a138 3
		/* can't trace yourself! */
		if (p->p_pid == curp->p_pid)
			return (EINVAL);
d140 7
@


1.3
log
@It should be possible to trace init if securelevel is at 0, single-user mode,
without having to peg the system at securelevel -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_ctl.c,v 1.2 1996/02/27 08:03:35 niklas Exp $	*/
a125 14
		/*
		 * it's not owned by you, or the last exec gave us
		 * setuid/setgid privs (unless you're root),
		 */
		if ((t->p_cred->p_ruid != p->p_cred->p_ruid ||
			ISSET(t->p_flag, P_SUGID)) &&
		    (error = suser(p->p_ucred, &p->p_acflag)) != 0)
			return (error);

		/*
		 * ...it's init, which controls the security level
		 */
		if (t->p_pid == 1 && securelevel > 0)
			return (EPERM);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 15
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: procfs_ctl.c,v 1.13 1995/08/13 09:06:02 mycroft Exp $	*/
d53 1
d102 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
