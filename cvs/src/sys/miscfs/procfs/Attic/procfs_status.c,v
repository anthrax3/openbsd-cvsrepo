head	1.17;
access;
symbols
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.10
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.10
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.8
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.10
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.09.08.01.57.00;	author guenther;	state dead;
branches;
next	1.16;
commitid	0HlTPhRuQ0I9ZG6q;

1.16
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.15;
commitid	FE3DG5cICjyI4jWx;

1.15
date	2013.10.01.20.15.56;	author sf;	state Exp;
branches;
next	1.14;

1.14
date	2013.07.03.15.26.03;	author sf;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.29.12.24.18;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.05.23.52.10;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.03.06.28.12;	author tedu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.05.16.12.48.32;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.18.18.44.28;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.12.30.01.33.14;	author deraadt;	state Exp;
branches
	1.3.10.1
	1.3.14.1;
next	1.2;

1.2
date	96.04.21.22.28.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches;
next	;

1.3.10.1
date	2001.05.14.22.32.55;	author niklas;	state Exp;
branches;
next	1.3.10.2;

1.3.10.2
date	2001.07.04.10.49.16;	author niklas;	state Exp;
branches;
next	1.3.10.3;

1.3.10.3
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.3.10.4;

1.3.10.4
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.3.14.1
date	2000.12.19.22.58.40;	author jason;	state Exp;
branches;
next	;

1.6.2.1
date	2004.05.13.03.08.31;	author brad;	state Exp;
branches;
next	;

1.7.2.1
date	2004.05.13.03.18.21;	author brad;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Actually remove the procfs files
@
text
@/*	$OpenBSD: procfs_status.c,v 1.16 2014/07/12 18:43:52 tedu Exp $	*/
/*	$NetBSD: procfs_status.c,v 1.11 1996/03/16 23:52:50 christos Exp $	*/

/*
 * Copyright (c) 1993 Jan-Simon Pendry
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)procfs_status.c	8.4 (Berkeley) 6/15/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <miscfs/procfs/procfs.h>

int	procfs_stat_gen(struct proc *, char *s, int);

#define COUNTORCAT(s, l, ps, n)	do { \
					if (s) \
						strlcat(s, ps, l); \
					else \
						n += strlen(ps); \
				} while (0)

/* Generates:
 *  comm pid ppid pgid sid maj,min ctty,sldr start ut st wmsg uid gid groups
 */
int
procfs_stat_gen(struct proc *p, char *s, int l)
{
	struct process *pr = p->p_p;
	struct session *sess;
	struct tty *tp;
	struct ucred *cr;
	int pid, ppid, pgid, sid;
	struct timeval ut, st;
	char ps[256], *sep;
	int i, n;

	pid = pr->ps_pid;
	ppid = pr->ps_pptr ? pr->ps_pptr->ps_pid : 0;
	pgid = pr->ps_pgrp->pg_id;
	sess = pr->ps_pgrp->pg_session;
	sid = sess->s_leader ? sess->s_leader->ps_pid : 0;

	n = 0;
	if (s)
		bzero(s, l);

	bcopy(p->p_comm, ps, MAXCOMLEN-1);
	ps[MAXCOMLEN] = '\0';
	COUNTORCAT(s, l, ps, n);

	(void) snprintf(ps, sizeof(ps), " %d %d %d %d ",
	    pid, ppid, pgid, sid);
	COUNTORCAT(s, l, ps, n);

	if ((pr->ps_flags & PS_CONTROLT) && (tp = sess->s_ttyp))
		snprintf(ps, sizeof(ps), "%d,%d ",
		    major(tp->t_dev), minor(tp->t_dev));
	else
		snprintf(ps, sizeof(ps), "%d,%d ",
		    -1, -1);
	COUNTORCAT(s, l, ps, n);

	sep = "";
	if (sess->s_ttyvp) {
		snprintf(ps, sizeof(ps), "%sctty", sep);
		sep = ",";
		COUNTORCAT(s, l, ps, n);
	}

	if (SESS_LEADER(pr)) {
		snprintf(ps, sizeof(ps), "%ssldr", sep);
		sep = ",";
		COUNTORCAT(s, l, ps, n);
	}

	if (*sep != ',') {
		snprintf(ps, sizeof(ps), "noflags");
		COUNTORCAT(s, l, ps, n);
	}

	snprintf(ps, sizeof(ps), " %lld,%ld",
	    (long long)pr->ps_start.tv_sec, pr->ps_start.tv_nsec/1000);
	COUNTORCAT(s, l, ps, n);

	calcru(&pr->ps_tu, &ut, &st, (void *) 0);
	snprintf(ps, sizeof(ps), " %lld,%ld %lld,%ld",
	    (long long)ut.tv_sec, ut.tv_usec,
	    (long long)st.tv_sec, st.tv_usec);
	COUNTORCAT(s, l, ps, n);

	snprintf(ps, sizeof(ps), " %s",
	    (p->p_wchan && p->p_wmesg) ? p->p_wmesg : "nochan");
	COUNTORCAT(s, l, ps, n);

	cr = p->p_ucred;

	snprintf(ps, sizeof(ps), " %u, %u", cr->cr_uid, cr->cr_gid);
	COUNTORCAT(s, l, ps, n);
	for (i = 0; i < cr->cr_ngroups; i++) {
		snprintf(ps, sizeof(ps), ",%u", cr->cr_groups[i]);
		COUNTORCAT(s, l, ps, n);
	}

	snprintf(ps, sizeof(ps), "\n");
	COUNTORCAT(s, l, ps, n);

	return (s != NULL ? strlen(s) + 1 : n + 1);
}

int
procfs_dostatus(struct proc *curp, struct proc *p, struct pfsnode *pfs, struct uio *uio)
{
	char *ps;
	int error, len;

	if (uio->uio_rw != UIO_READ)
		return (EOPNOTSUPP);

	len = procfs_stat_gen(p, NULL, 0);
	ps = malloc(len, M_TEMP, M_WAITOK);
	len = procfs_stat_gen(p, ps, len);

	if (len <= uio->uio_offset)
		error = 0;
	else {
		len -= uio->uio_offset;
		len = imin(len, uio->uio_resid);
		error = uiomove(ps + uio->uio_offset, len, uio);
	}

	free(ps, M_TEMP, 0);
	return (error);
}
@


1.16
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.15 2013/10/01 20:15:56 sf Exp $	*/
@


1.15
log
@Format string fixes: Cast time_t to long long

and mnt_stat.f_ctime is long long, too
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.14 2013/07/03 15:26:03 sf Exp $	*/
d170 1
a170 1
	free(ps, M_TEMP);
@


1.14
log
@cast time_t to long long, time_t is signed, tv_nsec is long

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.13 2013/06/03 16:55:22 guenther Exp $	*/
d125 3
a127 2
	snprintf(ps, sizeof(ps), " %ld,%ld %ld,%ld",
	    ut.tv_sec, ut.tv_usec, st.tv_sec, st.tv_usec);
@


1.13
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.12 2012/03/23 15:51:26 guenther Exp $	*/
d120 2
a121 2
	snprintf(ps, sizeof(ps), " %ld,%ld",
	    pr->ps_start.tv_sec, pr->ps_start.tv_nsec/1000);
@


1.12
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.11 2010/07/26 01:56:27 guenther Exp $	*/
d121 1
a121 1
	    pr->ps_start.tv_sec, pr->ps_start.tv_usec);
@


1.11
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.10 2007/06/18 08:30:07 jasper Exp $	*/
d121 1
a121 1
	    p->p_stats->p_start.tv_sec, p->p_stats->p_start.tv_usec);
d124 1
a124 1
	calcru(p, &ut, &st, (void *) 0);
@


1.10
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.9 2006/11/29 12:24:18 miod Exp $	*/
d67 1
d76 5
a80 5
	pid = p->p_pid;
	ppid = p->p_pptr ? p->p_pptr->p_pid : 0;
	pgid = p->p_pgrp->pg_id;
	sess = p->p_pgrp->pg_session;
	sid = sess->s_leader ? sess->s_leader->p_pid : 0;
d94 1
a94 1
	if ((p->p_flag&P_CONTROLT) && (tp = sess->s_ttyp))
d109 1
a109 1
	if (SESS_LEADER(p)) {
@


1.9
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.8 2004/05/05 23:52:10 tedu Exp $	*/
d65 1
a65 4
procfs_stat_gen(p, s, l)
	struct proc *p;
	char *s;
	int l;
d148 1
a148 5
procfs_dostatus(curp, p, pfs, uio)
	struct proc *curp;
	struct proc *p;
	struct pfsnode *pfs;
	struct uio *uio;
@


1.8
log
@make sure uio_offset is a safe value, with suggestions from millert@@
ok deraadt@@ millert@@
problem noticed by deprotect.com
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.7 2004/03/03 06:28:12 tedu Exp $	*/
d122 2
a123 5
	if (p->p_flag & P_INMEM)
		snprintf(ps, sizeof(ps), " %ld,%ld",
		    p->p_stats->p_start.tv_sec, p->p_stats->p_start.tv_usec);
	else
		snprintf(ps, sizeof(ps), " -1,-1");
@


1.7
log
@repair status by not repeating fields.  fixes pr2101 from jim razmus
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.6 2003/06/02 23:28:11 millert Exp $	*/
d168 1
a168 1
	(void) procfs_stat_gen(p, ps, len);
d170 1
a170 3
	len -= uio->uio_offset;
	len = imin(len, uio->uio_resid);
	if (len <= 0)
d172 3
a174 1
	else
d176 1
a180 1

@


1.7.2.1
log
@MFC:
Fix by tedu@@

make sure uio_offset is a safe value, with suggestions from millert@@
problem noticed by deprotect.com

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.7 2004/03/03 06:28:12 tedu Exp $	*/
d168 1
a168 1
	len = procfs_stat_gen(p, ps, len);
d170 3
a172 1
	if (len <= uio->uio_offset)
d174 1
a174 3
	else {
		len -= uio->uio_offset;
		len = imin(len, uio->uio_resid);
a175 1
	}
d180 1
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.5 2001/05/16 12:48:32 ho Exp $	*/
d108 1
a109 1
	COUNTORCAT(s, l, ps, n);
d114 1
a115 1
	COUNTORCAT(s, l, ps, n);
d117 1
a117 1
	if (*sep != ',')
d119 2
a120 1
	COUNTORCAT(s, l, ps, n);
@


1.6.2.1
log
@MFC:
Fix by tedu@@

make sure uio_offset is a safe value, with suggestions from millert@@
problem noticed by deprotect.com

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.6 2003/06/02 23:28:11 millert Exp $	*/
d167 1
a167 1
	len = procfs_stat_gen(p, ps, len);
d169 3
a171 1
	if (len <= uio->uio_offset)
d173 1
a173 3
	else {
		len -= uio->uio_offset;
		len = imin(len, uio->uio_resid);
a174 1
	}
d179 1
@


1.5
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.4 2000/12/18 18:44:28 provos Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@calculate length and allocate buffer for status. work by deraadt@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.3 1997/12/30 01:33:14 deraadt Exp $	*/
a170 2
	if (!ps)
		return (ENOMEM);
@


1.3
log
@fix a nasty code typo; rotel@@indigo.ie
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.2 1996/04/21 22:28:18 deraadt Exp $	*/
d47 1
d56 12
d69 1
a69 2
procfs_dostatus(curp, p, pfs, uio)
	struct proc *curp;
d71 2
a72 2
	struct pfsnode *pfs;
	struct uio *uio;
a76 2
	char *ps;
	char *sep;
d78 3
a80 7
	int i;
	int xlen;
	int error;
	char psbuf[256];		/* XXX - conservative */

	if (uio->uio_rw != UIO_READ)
		return (EOPNOTSUPP);
d88 3
a90 1
/* comm pid ppid pgid sid maj,min ctty,sldr start ut st wmsg uid gid groups ... */
d92 1
a92 2
	ps = psbuf;
	bcopy(p->p_comm, ps, MAXCOMLEN);
d94 5
a98 2
	ps += strlen(ps);
	ps += sprintf(ps, " %d %d %d %d ", pid, ppid, pgid, sid);
d101 2
a102 1
		ps += sprintf(ps, "%d,%d ", major(tp->t_dev), minor(tp->t_dev));
d104 3
a106 1
		ps += sprintf(ps, "%d,%d ", -1, -1);
d110 1
a110 1
		ps += sprintf(ps, "%sctty", sep);
d113 2
d116 1
a116 1
		ps += sprintf(ps, "%ssldr", sep);
d119 2
d122 2
a123 1
		ps += sprintf(ps, "noflags");
d126 2
a127 3
		ps += sprintf(ps, " %ld,%ld",
			p->p_stats->p_start.tv_sec,
			p->p_stats->p_start.tv_usec);
d129 19
a147 11
		ps += sprintf(ps, " -1,-1");
	
	{
		struct timeval ut, st;

		calcru(p, &ut, &st, (void *) 0);
		ps += sprintf(ps, " %ld,%ld %ld,%ld",
			ut.tv_sec,
			ut.tv_usec,
			st.tv_sec,
			st.tv_usec);
d150 15
a164 2
	ps += sprintf(ps, " %s",
		(p->p_wchan && p->p_wmesg) ? p->p_wmesg : "nochan");
d166 2
a167 1
	cr = p->p_ucred;
d169 9
a177 11
	ps += sprintf(ps, " %d", cr->cr_uid);
	ps += sprintf(ps, " %d", cr->cr_gid);
	for (i = 0; i < cr->cr_ngroups; i++)
		ps += sprintf(ps, ",%d", cr->cr_groups[i]);
	ps += sprintf(ps, "\n");

	xlen = ps - psbuf;
	xlen -= uio->uio_offset;
	ps = psbuf + uio->uio_offset;
	xlen = imin(xlen, uio->uio_resid);
	if (xlen <= 0)
d180 1
a180 1
		error = uiomove(ps, xlen, uio);
d182 1
d185 1
@


1.3.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.4 2000/12/18 18:44:28 provos Exp $	*/
a46 1
#include <sys/malloc.h>
a54 12
int	procfs_stat_gen(struct proc *, char *s, int);

#define COUNTORCAT(s, l, ps, n)	do { \
					if (s) \
						strlcat(s, ps, l); \
					else \
						n += strlen(ps); \
				} while (0)

/* Generates:
 *  comm pid ppid pgid sid maj,min ctty,sldr start ut st wmsg uid gid groups
 */
d56 2
a57 1
procfs_stat_gen(p, s, l)
d59 2
a60 2
	char *s;
	int l;
d65 2
d68 7
a74 3
	struct timeval ut, st;
	char ps[256], *sep;
	int i, n;
d82 1
a82 3
	n = 0;
	if (s)
		bzero(s, l);
d84 2
a85 1
	bcopy(p->p_comm, ps, MAXCOMLEN-1);
d87 2
a88 5
	COUNTORCAT(s, l, ps, n);

	(void) snprintf(ps, sizeof(ps), " %d %d %d %d ",
	    pid, ppid, pgid, sid);
	COUNTORCAT(s, l, ps, n);
d91 1
a91 2
		snprintf(ps, sizeof(ps), "%d,%d ",
		    major(tp->t_dev), minor(tp->t_dev));
d93 1
a93 3
		snprintf(ps, sizeof(ps), "%d,%d ",
		    -1, -1);
	COUNTORCAT(s, l, ps, n);
d97 1
a97 1
		snprintf(ps, sizeof(ps), "%sctty", sep);
a99 2
	COUNTORCAT(s, l, ps, n);

d101 1
a101 1
		snprintf(ps, sizeof(ps), "%ssldr", sep);
a103 2
	COUNTORCAT(s, l, ps, n);

d105 1
a105 2
		snprintf(ps, sizeof(ps), "noflags");
	COUNTORCAT(s, l, ps, n);
d108 3
a110 2
		snprintf(ps, sizeof(ps), " %ld,%ld",
		    p->p_stats->p_start.tv_sec, p->p_stats->p_start.tv_usec);
d112 12
a123 2
		snprintf(ps, sizeof(ps), " -1,-1");
	COUNTORCAT(s, l, ps, n);
d125 2
a126 8
	calcru(p, &ut, &st, (void *) 0);
	snprintf(ps, sizeof(ps), " %ld,%ld %ld,%ld",
	    ut.tv_sec, ut.tv_usec, st.tv_sec, st.tv_usec);
	COUNTORCAT(s, l, ps, n);

	snprintf(ps, sizeof(ps), " %s",
	    (p->p_wchan && p->p_wmesg) ? p->p_wmesg : "nochan");
	COUNTORCAT(s, l, ps, n);
d130 11
a140 35
	snprintf(ps, sizeof(ps), " %u, %u", cr->cr_uid, cr->cr_gid);
	COUNTORCAT(s, l, ps, n);
	for (i = 0; i < cr->cr_ngroups; i++) {
		snprintf(ps, sizeof(ps), ",%u", cr->cr_groups[i]);
		COUNTORCAT(s, l, ps, n);
	}

	snprintf(ps, sizeof(ps), "\n");
	COUNTORCAT(s, l, ps, n);

	return (s != NULL ? strlen(s) + 1 : n + 1);
}

int
procfs_dostatus(curp, p, pfs, uio)
	struct proc *curp;
	struct proc *p;
	struct pfsnode *pfs;
	struct uio *uio;
{
	char *ps;
	int error, len;

	if (uio->uio_rw != UIO_READ)
		return (EOPNOTSUPP);

	len = procfs_stat_gen(p, NULL, 0);
	ps = malloc(len, M_TEMP, M_WAITOK);
	if (!ps)
		return (ENOMEM);
	(void) procfs_stat_gen(p, ps, len);

	len -= uio->uio_offset;
	len = imin(len, uio->uio_resid);
	if (len <= 0)
d143 1
a143 1
		error = uiomove(ps + uio->uio_offset, len, uio);
a144 1
	free(ps, M_TEMP);
a146 1

@


1.3.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.3.10.1 2001/05/14 22:32:55 niklas Exp $	*/
d171 2
@


1.3.10.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.3.10.2 2001/07/04 10:49:16 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.10.4
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a107 1
		COUNTORCAT(s, l, ps, n);
d109 1
a113 1
		COUNTORCAT(s, l, ps, n);
d115 1
d117 1
a117 1
	if (*sep != ',') {
d119 1
a119 2
		COUNTORCAT(s, l, ps, n);
	}
d167 1
a167 1
	len = procfs_stat_gen(p, ps, len);
d169 3
a171 1
	if (len <= uio->uio_offset)
d173 1
a173 3
	else {
		len -= uio->uio_offset;
		len = imin(len, uio->uio_resid);
a174 1
	}
d179 1
@


1.3.14.1
log
@Pull in patch from current:
Errata (013):
Procfs contained numerous overflows, which could lead an intruder to root
permissions.  Procfs is NOT enabled by default in OpenBSD.
Fix (provos):
- strlcat and strlcpy into libkern.
- calculate length and allocate buffer for status. work by deraadt@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: procfs_status.c,v 1.4 2000/12/18 18:44:28 provos Exp $	*/
a46 1
#include <sys/malloc.h>
a54 12
int	procfs_stat_gen(struct proc *, char *s, int);

#define COUNTORCAT(s, l, ps, n)	do { \
					if (s) \
						strlcat(s, ps, l); \
					else \
						n += strlen(ps); \
				} while (0)

/* Generates:
 *  comm pid ppid pgid sid maj,min ctty,sldr start ut st wmsg uid gid groups
 */
d56 2
a57 1
procfs_stat_gen(p, s, l)
d59 2
a60 2
	char *s;
	int l;
d65 2
d68 7
a74 3
	struct timeval ut, st;
	char ps[256], *sep;
	int i, n;
d82 1
a82 3
	n = 0;
	if (s)
		bzero(s, l);
d84 2
a85 1
	bcopy(p->p_comm, ps, MAXCOMLEN-1);
d87 2
a88 5
	COUNTORCAT(s, l, ps, n);

	(void) snprintf(ps, sizeof(ps), " %d %d %d %d ",
	    pid, ppid, pgid, sid);
	COUNTORCAT(s, l, ps, n);
d91 1
a91 2
		snprintf(ps, sizeof(ps), "%d,%d ",
		    major(tp->t_dev), minor(tp->t_dev));
d93 1
a93 3
		snprintf(ps, sizeof(ps), "%d,%d ",
		    -1, -1);
	COUNTORCAT(s, l, ps, n);
d97 1
a97 1
		snprintf(ps, sizeof(ps), "%sctty", sep);
a99 2
	COUNTORCAT(s, l, ps, n);

d101 1
a101 1
		snprintf(ps, sizeof(ps), "%ssldr", sep);
a103 2
	COUNTORCAT(s, l, ps, n);

d105 1
a105 2
		snprintf(ps, sizeof(ps), "noflags");
	COUNTORCAT(s, l, ps, n);
d108 3
a110 2
		snprintf(ps, sizeof(ps), " %ld,%ld",
		    p->p_stats->p_start.tv_sec, p->p_stats->p_start.tv_usec);
d112 12
a123 2
		snprintf(ps, sizeof(ps), " -1,-1");
	COUNTORCAT(s, l, ps, n);
d125 2
a126 8
	calcru(p, &ut, &st, (void *) 0);
	snprintf(ps, sizeof(ps), " %ld,%ld %ld,%ld",
	    ut.tv_sec, ut.tv_usec, st.tv_sec, st.tv_usec);
	COUNTORCAT(s, l, ps, n);

	snprintf(ps, sizeof(ps), " %s",
	    (p->p_wchan && p->p_wmesg) ? p->p_wmesg : "nochan");
	COUNTORCAT(s, l, ps, n);
d130 11
a140 35
	snprintf(ps, sizeof(ps), " %u, %u", cr->cr_uid, cr->cr_gid);
	COUNTORCAT(s, l, ps, n);
	for (i = 0; i < cr->cr_ngroups; i++) {
		snprintf(ps, sizeof(ps), ",%u", cr->cr_groups[i]);
		COUNTORCAT(s, l, ps, n);
	}

	snprintf(ps, sizeof(ps), "\n");
	COUNTORCAT(s, l, ps, n);

	return (s != NULL ? strlen(s) + 1 : n + 1);
}

int
procfs_dostatus(curp, p, pfs, uio)
	struct proc *curp;
	struct proc *p;
	struct pfsnode *pfs;
	struct uio *uio;
{
	char *ps;
	int error, len;

	if (uio->uio_rw != UIO_READ)
		return (EOPNOTSUPP);

	len = procfs_stat_gen(p, NULL, 0);
	ps = malloc(len, M_TEMP, M_WAITOK);
	if (!ps)
		return (ENOMEM);
	(void) procfs_stat_gen(p, ps, len);

	len -= uio->uio_offset;
	len = imin(len, uio->uio_resid);
	if (len <= 0)
d143 1
a143 1
		error = uiomove(ps + uio->uio_offset, len, uio);
a144 1
	free(ps, M_TEMP);
a146 1

@


1.2
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 1
a77 1
	ppid = p->p_pptr ? p->p_pptr->p_pid : 0,
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: procfs_status.c,v 1.10 1995/06/01 22:44:28 jtc Exp $	*/
d108 1
a108 1
		ps += sprintf(ps, " %d,%d",
d118 1
a118 1
		ps += sprintf(ps, " %d,%d %d,%d",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
