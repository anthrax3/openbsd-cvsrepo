head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.2
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2016.09.07.17.53.35;	author natano;	state Exp;
branches;
next	1.15;
commitid	bTUYWm2clD2A9qNB;

1.15
date	2016.08.30.16.45.54;	author natano;	state Exp;
branches;
next	1.14;
commitid	bR1BHPSoghZ5Wk7v;

1.14
date	2016.08.21.09.23.33;	author natano;	state Exp;
branches;
next	1.13;
commitid	7JFBdlG9igjdelzs;

1.13
date	2016.08.16.21.32.58;	author natano;	state Exp;
branches;
next	1.12;
commitid	fvdRrKKkglz7BJvB;

1.12
date	2016.08.12.20.18.44;	author natano;	state Exp;
branches;
next	1.11;
commitid	sKMS4ZsvE4wG5Map;

1.11
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.10;
commitid	gAjwyca5TfuoJAhn;

1.10
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.9;
commitid	P6Av4XGqOi3rFasL;

1.9
date	2014.03.18.08.51.53;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2014.02.01.09.30.38;	author syl;	state Exp;
branches;
next	1.7;

1.7
date	2013.12.03.09.32.23;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.07.18.15.21;	author syl;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.07.18.04.53;	author syl;	state Exp;
branches;
next	1.4;

1.4
date	2013.08.10.00.12.45;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.12.22.55.02;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.05.18.26.06;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.15.50.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Fix fuse node lookups. Currently fusefs nodes in the kernel remember the
parent inode number for ".." lookups. This only works until the kernel
starts to reuse vnodes and the parent's vnode is reclaimed and the ino
to path mapping is removed from the userland process by libfuse. Fix
this by using reference counting in libfuse, so that parent mapping are
retained as long as a child uses them. Also, don't free the root node.

This commit resolves following issue:

$ doas fuse-zip ~/Downloads/foo.zip /mnt
$ ls /mnt
openbsd-www
$ grep -IR foo /usr/src > /dev/null	# force vfs to reclaim vnodes
$ ls /mnt
ls: /mnt: No such file or directory
$

ok tedu
@
text
@/* $OpenBSD: fuse_lookup.c,v 1.15 2016/08/30 16:45:54 natano Exp $ */
/*
 * Copyright (c) 2012-2013 Sylvestre Gallon <ccna.syl@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/fusebuf.h>

#include "fusefs_node.h"
#include "fusefs.h"

int fusefs_lookup(void *);

int
fusefs_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct vnode *vdp;	/* vnode for directory being searched */
	struct fusefs_node *dp;	/* inode for directory being searched */
	struct fusefs_mnt *fmp;	/* file system that directory is in */
	int lockparent;		/* 1 => lockparent flag is set */
	struct vnode *tdp;	/* returned by VOP_VGET */
	struct fusebuf *fbuf;
	struct vnode **vpp = ap->a_vpp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	struct ucred *cred = cnp->cn_cred;
	uint64_t nid;
	enum vtype nvtype;
	int flags;
	int nameiop = cnp->cn_nameiop;
	int wantparent;
	int error = 0;

	flags = cnp->cn_flags;
	*vpp = NULL;
	vdp = ap->a_dvp;
	dp = VTOI(vdp);
	fmp = (struct fusefs_mnt *)dp->ufs_ino.i_ump;
	lockparent = flags & LOCKPARENT;
	wantparent = flags & (LOCKPARENT | WANTPARENT);

	if ((error = VOP_ACCESS(vdp, VEXEC, cred, cnp->cn_proc)) != 0)
		return (error);

	if ((flags & ISLASTCN) && (vdp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

	if (cnp->cn_namelen == 1 && *(cnp->cn_nameptr) == '.') {
		nid = dp->ufs_ino.i_number;
	} else {
		if (!fmp->sess_init)
			return (ENOENT);

		/* got a real entry */
		fbuf = fb_setup(cnp->cn_namelen + 1, dp->ufs_ino.i_number,
		    FBT_LOOKUP, p);

		memcpy(fbuf->fb_dat, cnp->cn_nameptr, cnp->cn_namelen);
		fbuf->fb_dat[cnp->cn_namelen] = '\0';

		error = fb_queue(fmp->dev, fbuf);

		if (error) {
			fb_delete(fbuf);

			/* tsleep return */
			if (error == EWOULDBLOCK)
				return (error);

			if ((nameiop == CREATE || nameiop == RENAME) &&
			    (flags & ISLASTCN)) {
				if (vdp->v_mount->mnt_flag & MNT_RDONLY)
					return (EROFS);

				cnp->cn_flags |= SAVENAME;

				if (!lockparent) {
					VOP_UNLOCK(vdp, p);
					cnp->cn_flags |= PDIRUNLOCK;
				}

				return (EJUSTRETURN);
			}

			return (ENOENT);
		}

		nid = fbuf->fb_attr.st_ino;
		nvtype = IFTOVT(fbuf->fb_attr.st_mode);
		fb_delete(fbuf);
	}

	if (nameiop == DELETE && (flags & ISLASTCN)) {
		/*
		 * Write access to directory required to delete files.
		 */
		error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc);
		if (error)
			goto reclaim;

		cnp->cn_flags |= SAVENAME;
	}

	if (nameiop == RENAME && wantparent && (flags & ISLASTCN)) {
		/*
		 * Write access to directory required to delete files.
		 */
		if ((error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc)) != 0)
			goto reclaim;

		if (nid == dp->ufs_ino.i_number)
			return (EISDIR);

		error = VFS_VGET(fmp->mp, nid, &tdp);
		if (error)
			goto reclaim;

		tdp->v_type = nvtype;
		*vpp = tdp;
		cnp->cn_flags |= SAVENAME;

		return (0);
	}

	if (flags & ISDOTDOT) {
		VOP_UNLOCK(vdp, p);	/* race to get the inode */
		cnp->cn_flags |= PDIRUNLOCK;

		error = VFS_VGET(fmp->mp, nid, &tdp);

		if (error) {
			if (vn_lock(vdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;

			goto reclaim;
		}

		tdp->v_type = nvtype;

		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(vdp, LK_EXCLUSIVE, p))) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}
		*vpp = tdp;

	} else if (nid == dp->ufs_ino.i_number) {
		vref(vdp);
		*vpp = vdp;
		error = 0;
	} else {
		error = VFS_VGET(fmp->mp, nid, &tdp);
		if (error)
			goto reclaim;

		tdp->v_type = nvtype;

		if (!lockparent || !(flags & ISLASTCN)) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}

		*vpp = tdp;
	}

	return (error);

reclaim:
	if (nid != dp->ufs_ino.i_number && nid != FUSE_ROOTINO) {
		fbuf = fb_setup(0, nid, FBT_RECLAIM, p);
		if (fb_queue(fmp->dev, fbuf))
			printf("fusefs: libfuse vnode reclaim failed\n");
		fb_delete(fbuf);
	}
	return (error);
}
@


1.15
log
@Use struct stat for storing attributes in fusebufs, because using struct
vattr in userspace is suboptimal as some related helpers are not
available, e.g. VATTR_NULL() and IFTOVT(). The conversion is now done in
the kernel where it belongs. As a side effect the <sys/vnode.h> include
can be removed from libfuse.

tweaks and ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.14 2016/08/21 09:23:33 natano Exp $ */
d42 1
a42 1
	struct fusebuf *fbuf = NULL;
d47 2
a52 1
	uint64_t nid;
d69 1
a69 6
	if (flags & ISDOTDOT) {
		/* got ".." */
		nid = dp->parent;
		if (nid == 0)
			return (ENOENT);
	} else if (cnp->cn_namelen == 1 && *(cnp->cn_nameptr) == '.') {
d84 6
a89 3
		/* tsleep return */
		if (error == EWOULDBLOCK)
			goto out;
a90 1
		if (error) {
d103 1
a103 2
				error = EJUSTRETURN;
				goto out;
d106 1
a106 2
			error = ENOENT;
			goto out;
d110 2
d120 1
a120 1
			goto out;
d130 1
a130 1
			goto out;
d132 2
a133 4
		if (nid == VTOI(vdp)->ufs_ino.i_number) {
			error = EISDIR;
			goto out;
		}
d137 1
a137 1
			goto out;
d139 1
a139 1
		tdp->v_type = IFTOVT(fbuf->fb_attr.st_mode);
d143 1
a143 1
		goto out;
d156 1
a156 1
			return (error);
d159 2
d177 1
a177 1
			goto out;
d179 1
a179 4
		tdp->v_type = IFTOVT(fbuf->fb_attr.st_mode);

		if (vdp != NULL && vdp->v_type == VDIR)
			VTOI(tdp)->parent = dp->ufs_ino.i_number;
d189 9
a197 2
out:
	fb_delete(fbuf);
@


1.14
log
@There are three callers of update_vattr(). Two of them don't use the
updated struct vattr afterwards, so the call can be removed. Remove both
calls and the function itself, inlining the last remaining call.

ok millert
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.13 2016/08/16 21:32:58 natano Exp $ */
d22 1
d113 1
a113 1
		nid = fbuf->fb_vattr.va_fileid;
d143 1
a143 1
		tdp->v_type = IFTOVT(fbuf->fb_vattr.va_mode);
d181 1
a181 1
		tdp->v_type = IFTOVT(fbuf->fb_vattr.va_mode);
@


1.13
log
@There is no sense in doing caching in fusefs. In case of a non-local
filesystem the tree can change behind our back, resulting in stale cache
entries. "The only winning move is not to play."

ok tedu beck mpi
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.12 2016/08/12 20:18:44 natano Exp $ */
a176 6

		if (!error)
			tdp->v_type = IFTOVT(fbuf->fb_vattr.va_mode);

		update_vattr(fmp->mp, &fbuf->fb_vattr);

d179 2
@


1.12
log
@Dedup vnode type information. Fuse stores the vnode type in two places:
vtype in struct fusefs_node and v_type in struct vnode. Given the fact,
that fusefs_node structs are never allocated without an associated vnode
and those two fields are always in sync, one of those locations is
superfluous.

While there remove the unused nlookup field.

ok mpi
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.11 2016/03/19 12:04:15 natano Exp $ */
a66 3
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);

d120 2
a121 4
		if (error != 0) {
			fb_delete(fbuf);
			return (error);
		}
d130 2
a131 4
		if ((error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc)) != 0) {
			fb_delete(fbuf);
			return (error);
		}
d183 2
a184 4
		if (error) {
			fb_delete(fbuf);
			return (error);
		}
a197 4
	if ((cnp->cn_flags & MAKEENTRY) && nameiop != CREATE &&
	    nameiop != DELETE)
		cache_enter(vdp, *vpp, cnp);

@


1.11
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.10 2014/12/16 18:30:04 tedu Exp $ */
a149 1
		VTOI(tdp)->vtype = tdp->v_type;
d185 1
a185 1
		if (!error) {
a186 2
			VTOI(tdp)->vtype = tdp->v_type;
		}
@


1.10
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.9 2014/03/18 08:51:53 mpi Exp $ */
d103 1
a103 1
					VOP_UNLOCK(vdp, 0, p);
d158 1
a158 1
		VOP_UNLOCK(vdp, 0, p);	/* race to get the inode */
d202 1
a202 1
			VOP_UNLOCK(vdp, 0, p);
@


1.9
log
@Do not rely on the fact that sys/vnode.h includes all the world
through uvm/uvm.h and add proper includes for function definitions.

ok syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.8 2014/02/01 09:30:38 syl Exp $ */
d24 1
@


1.8
log
@Replace the vnode struct vattr cache by VOP_GETATTR() calls.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.7 2013/12/03 09:32:23 syl Exp $ */
d19 1
@


1.7
log
@Add some missing check to know if the communication channel with
libfuse is still open before sending fusebufs.

ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.6 2013/10/07 18:15:21 syl Exp $ */
a189 2
		memcpy(&(VTOI(tdp)->cached_attrs), &fbuf->fb_vattr,
		    sizeof(struct vattr));
@


1.6
log
@Introduce fb_delete() helper and use it in FUSE code.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.5 2013/10/07 18:04:53 syl Exp $ */
d76 3
@


1.5
log
@Rework fuseread() and fusewrite().
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.4 2013/08/10 00:12:45 syl Exp $ */
a20 1
#include <sys/pool.h>
d119 1
a119 2
			if (fbuf)
				pool_put(&fusefs_fbuf_pool, fbuf);
d130 2
a131 1
		if ((error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc)) != 0)
d133 1
d191 1
a191 2
			if (fbuf)
				pool_put(&fusefs_fbuf_pool, fbuf);
d211 1
a211 2
	if (fbuf)
		pool_put(&fusefs_fbuf_pool, fbuf);
@


1.4
log
@Remove debug printfs.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.3 2013/06/12 22:55:02 tedu Exp $ */
d78 2
a79 2
		fbuf = fb_setup(FUSEFDSIZE + cnp->cn_namelen + 1,
		    dp->ufs_ino.i_number, FBT_LOOKUP, p);
@


1.3
log
@remove extra whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.2 2013/06/05 18:26:06 tedu Exp $ */
a28 6
#ifdef	FUSE_DEBUG_VNOP
#define	DPRINTF(fmt, arg...)	printf("fuse vnop: " fmt, ##arg)
#else
#define	DPRINTF(fmt, arg...)
#endif

a57 3

	DPRINTF("lookup path %s\n", cnp->cn_pnbuf);
	DPRINTF("lookup file %s\n", cnp->cn_nameptr);
@


1.2
log
@rename should be working now, from Sylvestre Gallon
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_lookup.c,v 1.1 2013/06/03 15:50:56 tedu Exp $ */
d101 1
a101 1
			    (flags & ISLASTCN) ) {
d218 1
a218 1
	    nameiop != DELETE )
@


1.1
log
@add a bunch of files for ISC-licensed FUSE support. ok beck deraadt
from Sylvestre Gallon ccna.syl gmail.com. Many thanks to Sylvestre for
all the hard work.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d53 1
d63 1
d137 1
a137 1
	if (nameiop == RENAME && (flags & ISLASTCN)) {
d149 7
@

