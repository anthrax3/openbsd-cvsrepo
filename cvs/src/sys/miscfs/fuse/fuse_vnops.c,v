head	1.33;
access;
symbols
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.33
date	2016.09.07.17.53.35;	author natano;	state Exp;
branches;
next	1.32;
commitid	bTUYWm2clD2A9qNB;

1.32
date	2016.08.30.16.45.54;	author natano;	state Exp;
branches;
next	1.31;
commitid	bR1BHPSoghZ5Wk7v;

1.31
date	2016.08.21.09.23.33;	author natano;	state Exp;
branches;
next	1.30;
commitid	7JFBdlG9igjdelzs;

1.30
date	2016.08.16.21.32.58;	author natano;	state Exp;
branches;
next	1.29;
commitid	fvdRrKKkglz7BJvB;

1.29
date	2016.08.12.20.18.44;	author natano;	state Exp;
branches;
next	1.28;
commitid	sKMS4ZsvE4wG5Map;

1.28
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.27;
commitid	wHLNY5GFNXJSFYaC;

1.27
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.26;
commitid	gAjwyca5TfuoJAhn;

1.26
date	2016.01.22.17.09.43;	author stefan;	state Exp;
branches;
next	1.25;
commitid	R7jOf0pHSmx9IO2d;

1.25
date	2015.09.23.15.37.26;	author tedu;	state Exp;
branches;
next	1.24;
commitid	xTdRXaXuj71z4icR;

1.24
date	2015.04.17.04.43.21;	author guenther;	state Exp;
branches;
next	1.23;
commitid	zOwbm07fp3gPB2qr;

1.23
date	2015.02.19.10.22.20;	author tedu;	state Exp;
branches;
next	1.22;
commitid	OIS6yPA7VITHUzjc;

1.22
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.21;
commitid	C5iGb36LQxjM60Q3;

1.21
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.20;
commitid	P6Av4XGqOi3rFasL;

1.20
date	2014.08.10.09.23.06;	author jsg;	state Exp;
branches;
next	1.19;
commitid	Af0D58K1tqLmcSUu;

1.19
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.18;
commitid	FE3DG5cICjyI4jWx;

1.18
date	2014.05.20.13.32.22;	author syl;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.19.13.55.29;	author syl;	state Exp;
branches;
next	1.16;

1.16
date	2014.03.18.08.51.53;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2014.02.01.09.30.38;	author syl;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.29.20.37.18;	author syl;	state Exp;
branches;
next	1.13;

1.13
date	2014.01.16.09.31.44;	author syl;	state Exp;
branches;
next	1.12;

1.12
date	2013.12.20.22.03.26;	author syl;	state Exp;
branches;
next	1.11;

1.11
date	2013.12.03.09.59.40;	author syl;	state Exp;
branches;
next	1.10;

1.10
date	2013.12.03.09.32.23;	author syl;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.07.18.25.32;	author syl;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.07.18.24.12;	author syl;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.07.18.15.21;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.07.18.04.53;	author syl;	state Exp;
branches;
next	1.5;

1.5
date	2013.09.17.19.07.11;	author syl;	state Exp;
branches;
next	1.4;

1.4
date	2013.08.10.00.12.45;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.12.22.55.02;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.05.18.26.06;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.15.50.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Fix fuse node lookups. Currently fusefs nodes in the kernel remember the
parent inode number for ".." lookups. This only works until the kernel
starts to reuse vnodes and the parent's vnode is reclaimed and the ino
to path mapping is removed from the userland process by libfuse. Fix
this by using reference counting in libfuse, so that parent mapping are
retained as long as a child uses them. Also, don't free the root node.

This commit resolves following issue:

$ doas fuse-zip ~/Downloads/foo.zip /mnt
$ ls /mnt
openbsd-www
$ grep -IR foo /usr/src > /dev/null	# force vfs to reclaim vnodes
$ ls /mnt
ls: /mnt: No such file or directory
$

ok tedu
@
text
@/* $OpenBSD: fuse_vnops.c,v 1.32 2016/08/30 16:45:54 natano Exp $ */
/*
 * Copyright (c) 2012-2013 Sylvestre Gallon <ccna.syl@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/dirent.h>
#include <sys/fcntl.h>
#include <sys/file.h>
#include <sys/lockf.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/poll.h>
#include <sys/proc.h>
#include <sys/specdev.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/fusebuf.h>

#include "fusefs_node.h"
#include "fusefs.h"

/* Prototypes for fusefs vnode ops */
int	fusefs_kqfilter(void *);
int	fusefs_lookup(void *);
int	fusefs_open(void *);
int	fusefs_close(void *);
int	fusefs_access(void *);
int	fusefs_getattr(void *);
int	fusefs_setattr(void *);
int	fusefs_ioctl(void *);
int	fusefs_link(void *);
int	fusefs_symlink(void *);
int	fusefs_readdir(void *);
int	fusefs_readlink(void *);
int	fusefs_inactive(void *);
int	fusefs_reclaim(void *);
int	fusefs_print(void *);
int	fusefs_create(void *);
int	fusefs_mknod(void *);
int	fusefs_read(void *);
int	fusefs_write(void *);
int	fusefs_poll(void *);
int	fusefs_remove(void *);
int	fusefs_rename(void *);
int	fusefs_mkdir(void *);
int	fusefs_rmdir(void *);
int	fusefs_strategy(void *);
int	fusefs_lock(void *);
int	fusefs_unlock(void *);
int	fusefs_islocked(void *);
int	fusefs_advlock(void *);

/* Prototypes for fusefs kqfilter */
int	filt_fusefsread(struct knote *, long);
int	filt_fusefswrite(struct knote *, long);
int	filt_fusefsvnode(struct knote *, long);
void	filt_fusefsdetach(struct knote *);

struct vops fusefs_vops = {
	.vop_lookup	= fusefs_lookup,
	.vop_create	= fusefs_create,
	.vop_mknod	= fusefs_mknod,
	.vop_open	= fusefs_open,
	.vop_close	= fusefs_close,
	.vop_access	= fusefs_access,
	.vop_getattr	= fusefs_getattr,
	.vop_setattr	= fusefs_setattr,
	.vop_read	= fusefs_read,
	.vop_write	= fusefs_write,
	.vop_ioctl	= fusefs_ioctl,
	.vop_poll	= fusefs_poll,
	.vop_kqfilter	= fusefs_kqfilter,
	.vop_fsync	= nullop,
	.vop_remove	= fusefs_remove,
	.vop_link	= fusefs_link,
	.vop_rename	= fusefs_rename,
	.vop_mkdir	= fusefs_mkdir,
	.vop_rmdir	= fusefs_rmdir,
	.vop_symlink	= fusefs_symlink,
	.vop_readdir	= fusefs_readdir,
	.vop_readlink	= fusefs_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= fusefs_inactive,
	.vop_reclaim	= fusefs_reclaim,
	.vop_lock	= fusefs_lock,
	.vop_unlock	= fusefs_unlock,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fusefs_strategy,
	.vop_print	= fusefs_print,
	.vop_islocked	= fusefs_islocked,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= fusefs_advlock,
};

struct filterops fusefsread_filtops =
	{ 1, NULL, filt_fusefsdetach, filt_fusefsread };
struct filterops fusefswrite_filtops =
	{ 1, NULL, filt_fusefsdetach, filt_fusefswrite };
struct filterops fusefsvnode_filtops =
	{ 1, NULL, filt_fusefsdetach, filt_fusefsvnode };

int
fusefs_kqfilter(void *v)
{
	struct vop_kqfilter_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct knote *kn = ap->a_kn;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &fusefsread_filtops;
		break;
	case EVFILT_WRITE:
		kn->kn_fop = &fusefswrite_filtops;
		break;
	case EVFILT_VNODE:
		kn->kn_fop = &fusefsvnode_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)vp;

	SLIST_INSERT_HEAD(&vp->v_selectinfo.si_note, kn, kn_selnext);

	return (0);
}

void
filt_fusefsdetach(struct knote *kn)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;

	SLIST_REMOVE(&vp->v_selectinfo.si_note, kn, knote, kn_selnext);
}

int
filt_fusefsread(struct knote *kn, long hint)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;
	struct fusefs_node *ip = VTOI(vp);

	/*
	 * filesystem is gone, so set the EOF flag and schedule
	 * the knote for deletion
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = ip->filesize - kn->kn_fp->f_offset;
	if (kn->kn_data == 0 && kn->kn_sfflags & NOTE_EOF) {
		kn->kn_fflags |= NOTE_EOF;
		return (1);
	}

	return (kn->kn_data != 0);
}

int
filt_fusefswrite(struct knote *kn, long hint)
{
	/*
	 * filesystem is gone, so set the EOF flag and schedule
	 * the knote for deletion
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = 0;
	return (1);
}

int
filt_fusefsvnode(struct knote *kn, long int hint)
{
	if (kn->kn_sfflags & hint)
		kn->kn_fflags |= hint;
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	return (kn->kn_fflags != 0);
}

int
fusefs_open(void *v)
{
	struct vop_open_args *ap;
	struct fusefs_node *ip;
	struct fusefs_mnt *fmp;
	enum fufh_type fufh_type = FUFH_RDONLY;
	int flags = O_RDONLY;
	int error;
	int isdir;

	ap = v;
	ip = VTOI(ap->a_vp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init)
		return (ENXIO);

	isdir = 0;
	if (ap->a_vp->v_type == VDIR)
		isdir = 1;
	else {
		if ((ap->a_mode & FREAD) && (ap->a_mode & FWRITE)) {
			fufh_type = FUFH_RDWR;
			flags = O_RDWR;
		} else if (ap->a_mode  & (FWRITE)) {
			fufh_type = FUFH_WRONLY;
			flags = O_WRONLY;
		}
	}

	/* already open i think all is ok */
	if (ip->fufh[fufh_type].fh_type != FUFH_INVALID)
		return (0);

	error = fusefs_file_open(fmp, ip, fufh_type, flags, isdir, ap->a_p);
	if (error)
		return (error);

	return (error);
}

int
fusefs_close(void *v)
{
	struct vop_close_args *ap;
	struct fusefs_node *ip;
	struct fusefs_mnt *fmp;
	enum fufh_type fufh_type = FUFH_RDONLY;
	int isdir, i;

	ap = v;
	ip = VTOI(ap->a_vp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init)
		return (0);

	if (ap->a_vp->v_type == VDIR) {
		isdir = 1;

		if (ip->fufh[fufh_type].fh_type != FUFH_INVALID)
			return (fusefs_file_close(fmp, ip, fufh_type, O_RDONLY,
			    isdir, ap->a_p));
	} else {
		if (ap->a_fflag & IO_NDELAY)
			return (0);

		if ((ap->a_fflag & FREAD) && (ap->a_fflag & FWRITE))
			fufh_type = FUFH_RDWR;
		else if (ap->a_fflag  & (FWRITE))
			fufh_type = FUFH_WRONLY;
	}

	/*
	 * if fh not valid lookup for another valid fh in vnode.
	 * Do we need panic if there's not a valid fh ?
	 */
	if (ip->fufh[fufh_type].fh_type != FUFH_INVALID) {
		for (i = 0; i < FUFH_MAXTYPE; i++)
			if (ip->fufh[fufh_type].fh_type != FUFH_INVALID)
				break;
		return (0);
	}

	return (0);
}

int
fusefs_access(void *v)
{
	struct vop_access_args *ap;
	struct fusefs_node *ip;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	struct ucred *cred;
	struct vattr vattr;
	struct proc *p;
	uint32_t mask = 0;
	int error = 0;

	ap = v;
	p = ap->a_p;
	cred = p->p_ucred;
	ip = VTOI(ap->a_vp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init)
		return (ENXIO);

	if (fmp->undef_op & UNDEF_ACCESS)
		goto system_check;

	if (ap->a_vp->v_type == VLNK)
		goto system_check;

	if (ap->a_vp->v_type == VREG && (ap->a_mode & VWRITE & VEXEC))
		goto system_check;

	if ((ap->a_mode & VWRITE) && (fmp->mp->mnt_flag & MNT_RDONLY))
		return (EACCES);

	if ((ap->a_mode & VWRITE) != 0)
		mask |= 0x2;

	if ((ap->a_mode & VREAD) != 0)
		mask |= 0x4;

	if ((ap->a_mode & VEXEC) != 0)
		mask |= 0x1;

	fbuf = fb_setup(0, ip->ufs_ino.i_number, FBT_ACCESS, p);
	fbuf->fb_io_mode = mask;

	error = fb_queue(fmp->dev, fbuf);
	if (error) {
		if (error == ENOSYS) {
			fmp->undef_op |= UNDEF_ACCESS;
			fb_delete(fbuf);
			goto system_check;
		}

		printf("fusefs: access error %i\n", error);
		fb_delete(fbuf);
		return (error);
	}

	fb_delete(fbuf);
	return (error);

system_check:
	if ((error = VOP_GETATTR(ap->a_vp, &vattr, cred, p)) != 0)
		return (error);

	return (vaccess(ap->a_vp->v_type, vattr.va_mode & ALLPERMS,
	    vattr.va_uid, vattr.va_gid, ap->a_mode,
	    ap->a_cred));
}

int
fusefs_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fusefs_mnt *fmp;
	struct vattr *vap = ap->a_vap;
	struct proc *p = ap->a_p;
	struct fusefs_node *ip;
	struct fusebuf *fbuf;
	struct stat *st;
	int error = 0;

	ip = VTOI(vp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init)
		return (ENXIO);

	fbuf = fb_setup(0, ip->ufs_ino.i_number, FBT_GETATTR, p);

	error = fb_queue(fmp->dev, fbuf);
	if (error) {
		fb_delete(fbuf);
		return (error);
	}

	VATTR_NULL(vap);
	st = &fbuf->fb_attr;

	vap->va_type = IFTOVT(st->st_mode);
	vap->va_mode = st->st_mode & ~S_IFMT;
	vap->va_nlink = st->st_nlink;
	vap->va_uid = st->st_uid;
	vap->va_gid = st->st_gid;
	vap->va_fsid = fmp->mp->mnt_stat.f_fsid.val[0];
	vap->va_fileid = st->st_ino;
	vap->va_size = st->st_size;
	vap->va_blocksize = st->st_blksize;
	vap->va_atime = st->st_atim;
	vap->va_mtime = st->st_mtim;
	vap->va_ctime = st->st_ctim;
	vap->va_rdev = st->st_rdev;
	vap->va_bytes = st->st_blocks * S_BLKSIZE;

	fb_delete(fbuf);
	return (error);
}

int
fusefs_setattr(void *v)
{
	struct vop_setattr_args *ap = v;
	struct vattr *vap = ap->a_vap;
	struct vnode *vp = ap->a_vp;
	struct fusefs_node *ip = VTOI(vp);
	struct proc *p = ap->a_p;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	struct fb_io *io;
	int error = 0;

	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;
	/*
	 * Check for unsettable attributes.
	 */
	if ((vap->va_type != VNON) || (vap->va_nlink != VNOVAL) ||
	    (vap->va_fsid != VNOVAL) || (vap->va_fileid != VNOVAL) ||
	    (vap->va_blocksize != VNOVAL) || (vap->va_rdev != VNOVAL) ||
	    ((int)vap->va_bytes != VNOVAL) || (vap->va_gen != VNOVAL))
		return (EINVAL);

	if (!fmp->sess_init)
		return (ENXIO);

	if (fmp->undef_op & UNDEF_SETATTR)
		return (ENOSYS);

	fbuf = fb_setup(sizeof(*io), ip->ufs_ino.i_number, FBT_SETATTR, p);
	io = fbtod(fbuf, struct fb_io *);
	io->fi_flags = 0;

	if (vap->va_uid != (uid_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY) {
			error = EROFS;
			goto out;
		}
		fbuf->fb_attr.st_uid = vap->va_uid;
		io->fi_flags |= FUSE_FATTR_UID;
	}

	if (vap->va_gid != (gid_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY) {
			error = EROFS;
			goto out;
		}
		fbuf->fb_attr.st_gid = vap->va_gid;
		io->fi_flags |= FUSE_FATTR_GID;
	}

	if (vap->va_size != VNOVAL) {
		switch (vp->v_type) {
		case VDIR:
			error = EISDIR;
			goto out;
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY) {
				error = EROFS;
				goto out;
			}
			break;
		default:
			break;
		}

		fbuf->fb_attr.st_size = vap->va_size;
		io->fi_flags |= FUSE_FATTR_SIZE;
	}

	if (vap->va_atime.tv_nsec != VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY) {
			error = EROFS;
			goto out;
		}
		fbuf->fb_attr.st_atim = vap->va_atime;
		io->fi_flags |= FUSE_FATTR_ATIME;
	}

	if (vap->va_mtime.tv_nsec != VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY) {
			error = EROFS;
			goto out;
		}
		fbuf->fb_attr.st_mtim = vap->va_mtime;
		io->fi_flags |= FUSE_FATTR_MTIME;
	}
	/* XXX should set a flag if (vap->va_vaflags & VA_UTIMES_CHANGE) */

	if (vap->va_mode != (mode_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY) {
			error = EROFS;
			goto out;
		}
		fbuf->fb_attr.st_mode = vap->va_mode & ALLPERMS;
		io->fi_flags |= FUSE_FATTR_MODE;
	}

	if (!io->fi_flags) {
		goto out;
	}

	error = fb_queue(fmp->dev, fbuf);
	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_SETATTR;
		goto out;
	}

	VN_KNOTE(ap->a_vp, NOTE_ATTRIB);

out:
	fb_delete(fbuf);
	return (error);
}

int
fusefs_ioctl(void *v)
{
	return (ENOTTY);
}

int
fusefs_link(void *v)
{
	struct vop_link_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vnode *vp = ap->a_vp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	struct fusefs_mnt *fmp;
	struct fusefs_node *ip;
	struct fusefs_node *dip;
	struct fusebuf *fbuf;
	int error = 0;

	ip = VTOI(vp);
	dip = VTOI(dvp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init) {
		VOP_ABORTOP(dvp, cnp);
		error = ENXIO;
		goto out2;
	}
	if (fmp->undef_op & UNDEF_LINK) {
		VOP_ABORTOP(dvp, cnp);
		error = ENOSYS;
		goto out2;
	}
	if (vp->v_type == VDIR) {
		VOP_ABORTOP(dvp, cnp);
		error = EISDIR;
		goto out2;
	}
	if (dvp->v_mount != vp->v_mount) {
		VOP_ABORTOP(dvp, cnp);
		error = EXDEV;
		goto out2;
	}
	if (dvp != vp && (error = vn_lock(vp, LK_EXCLUSIVE, p))) {
		VOP_ABORTOP(dvp, cnp);
		goto out2;
	}

	fbuf = fb_setup(cnp->cn_namelen + 1, dip->ufs_ino.i_number,
	    FBT_LINK, p);

	fbuf->fb_io_ino = ip->ufs_ino.i_number;
	memcpy(fbuf->fb_dat, cnp->cn_nameptr, cnp->cn_namelen);
	fbuf->fb_dat[cnp->cn_namelen] = '\0';

	error = fb_queue(fmp->dev, fbuf);

	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_LINK;

		fb_delete(fbuf);
		goto out1;
	}

	fb_delete(fbuf);
	VN_KNOTE(vp, NOTE_LINK);
	VN_KNOTE(dvp, NOTE_WRITE);

out1:
	if (dvp != vp)
		VOP_UNLOCK(vp, p);
out2:
	vput(dvp);
	return (error);
}

int
fusefs_symlink(void *v)
{
	struct vop_symlink_args *ap = v;
	struct vnode **vpp = ap->a_vpp;
	struct componentname *cnp = ap->a_cnp;
	struct vnode *dvp = ap->a_dvp;
	struct proc *p = cnp->cn_proc;
	char *target = ap->a_target;
	struct fusefs_node *dp;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	struct vnode *tdp;
	int error = 0;
	int len;

	dp = VTOI(dvp);
	fmp = (struct fusefs_mnt *)dp->ufs_ino.i_ump;

	if (!fmp->sess_init) {
		error = ENXIO;
		goto bad;
	}

	if (fmp->undef_op & UNDEF_SYMLINK) {
		error = ENOSYS;
		goto bad;
	}

	len = strlen(target) + 1;

	fbuf = fb_setup(len + cnp->cn_namelen + 1, dp->ufs_ino.i_number,
	    FBT_SYMLINK, p);

	memcpy(fbuf->fb_dat, cnp->cn_nameptr, cnp->cn_namelen);
	fbuf->fb_dat[cnp->cn_namelen] = '\0';
	memcpy(&fbuf->fb_dat[cnp->cn_namelen + 1], target, len);

	error = fb_queue(fmp->dev, fbuf);
	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_SYMLINK;

		fb_delete(fbuf);
		goto bad;
	}

	if ((error = VFS_VGET(fmp->mp, fbuf->fb_ino, &tdp))) {
		fb_delete(fbuf);
		goto bad;
	}

	tdp->v_type = VLNK;
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);

	*vpp = tdp;
	fb_delete(fbuf);
	vput(tdp);
bad:
	vput(dvp);
	return (error);
}

int
fusefs_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	struct fusefs_node *ip;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	struct vnode *vp;
	struct proc *p;
	struct uio *uio;
	int error = 0, eofflag = 0;

	vp = ap->a_vp;
	uio = ap->a_uio;
	p = uio->uio_procp;

	ip = VTOI(vp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init)
		return (ENXIO);

	if (uio->uio_resid < sizeof(struct dirent))
		return (EINVAL);

	while (uio->uio_resid > 0) {
		fbuf = fb_setup(0, ip->ufs_ino.i_number, FBT_READDIR, p);

		if (ip->fufh[FUFH_RDONLY].fh_type == FUFH_INVALID) {
			/* TODO open the file */
			fb_delete(fbuf);
			return (error);
		}
		fbuf->fb_io_fd = ip->fufh[FUFH_RDONLY].fh_id;
		fbuf->fb_io_off = uio->uio_offset;
		fbuf->fb_io_len = MIN(uio->uio_resid, fmp->max_read);

		error = fb_queue(fmp->dev, fbuf);

		if (error) {
			fb_delete(fbuf);
			break;
		}

		/* ack end of readdir */
		if (fbuf->fb_len == 0) {
			eofflag = 1;
			fb_delete(fbuf);
			break;
		}

		if ((error = uiomove(fbuf->fb_dat, fbuf->fb_len, uio))) {
			fb_delete(fbuf);
			break;
		}

		fb_delete(fbuf);
	}

	if (!error && ap->a_eofflag != NULL)
		*ap->a_eofflag = eofflag;

	return (error);
}

int
fusefs_inactive(void *v)
{
	struct vop_inactive_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct proc *p = ap->a_p;
	struct ucred *cred = p->p_ucred;
	struct fusefs_node *ip = VTOI(vp);
	struct fusefs_filehandle *fufh = NULL;
	struct fusefs_mnt *fmp;
	struct vattr vattr;
	int error = 0;
	int type;

	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	for (type = 0; type < FUFH_MAXTYPE; type++) {
		fufh = &(ip->fufh[type]);
		if (fufh->fh_type != FUFH_INVALID)
			fusefs_file_close(fmp, ip, fufh->fh_type, type,
			    (vp->v_type == VDIR), ap->a_p);
	}

	error = VOP_GETATTR(vp, &vattr, cred, p);

	VOP_UNLOCK(vp, p);

	if (error)
		vrecycle(vp, p);

	return (0);
}

int
fusefs_readlink(void *v)
{
	struct vop_readlink_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fusefs_node *ip;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	struct uio *uio;
	struct proc *p;
	int error = 0;

	ip = VTOI(vp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;
	uio = ap->a_uio;
	p = uio->uio_procp;

	if (!fmp->sess_init)
		return (ENXIO);

	if (fmp->undef_op & UNDEF_READLINK)
		return (ENOSYS);

	fbuf = fb_setup(0, ip->ufs_ino.i_number, FBT_READLINK, p);

	error = fb_queue(fmp->dev, fbuf);

	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_READLINK;

		fb_delete(fbuf);
		return (error);
	}

	error = uiomove(fbuf->fb_dat, fbuf->fb_len, uio);
	fb_delete(fbuf);

	return (error);
}

int
fusefs_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fusefs_node *ip = VTOI(vp);
	struct fusefs_filehandle *fufh = NULL;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	int type;

	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	/*close opened files*/
	for (type = 0; type < FUFH_MAXTYPE; type++) {
		fufh = &(ip->fufh[type]);
		if (fufh->fh_type != FUFH_INVALID) {
			printf("fusefs: vnode being reclaimed is valid\n");
			fusefs_file_close(fmp, ip, fufh->fh_type, type,
			    (vp->v_type == VDIR), ap->a_p);
		}
	}

	/*
	 * if the fuse connection is opened
	 * ask libfuse to free the vnodes
	 */
	if (fmp->sess_init && ip->ufs_ino.i_number != FUSE_ROOTINO) {
		fbuf = fb_setup(0, ip->ufs_ino.i_number, FBT_RECLAIM, ap->a_p);
		if (fb_queue(fmp->dev, fbuf))
			printf("fusefs: libfuse vnode reclaim failed\n");
		fb_delete(fbuf);
	}

	/*
	 * Remove the inode from its hash chain.
	 */
	ufs_ihashrem(&ip->ufs_ino);

	free(ip, M_FUSEFS, 0);
	vp->v_data = NULL;
	return (0);
}

int
fusefs_print(void *v)
{
	struct vop_print_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fusefs_node *ip = VTOI(vp);

	/* Complete the information given by vprint(). */
	printf("tag VT_FUSE, hash id %u ", ip->ufs_ino.i_number);
	printf("\n");
	return (0);
}

int
fusefs_create(void *v)
{
	struct vop_create_args *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct vnode **vpp = ap->a_vpp;
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct proc *p = cnp->cn_proc;
	struct vnode *tdp = NULL;
	struct fusefs_mnt *fmp;
	struct fusefs_node *ip;
	struct fusebuf *fbuf;
	int error = 0;
	mode_t mode;

	ip = VTOI(dvp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;
	mode = MAKEIMODE(vap->va_type, vap->va_mode);

	if (!fmp->sess_init) {
		error = ENXIO;
		goto out;
	}

	if (fmp->undef_op & UNDEF_CREATE) {
		error = ENOSYS;
		goto out;
	}

	fbuf = fb_setup(cnp->cn_namelen + 1, ip->ufs_ino.i_number,
	    FBT_CREATE, p);

	fbuf->fb_io_mode = mode;
	fbuf->fb_io_flags = O_CREAT | O_RDWR;

	memcpy(fbuf->fb_dat, cnp->cn_nameptr, cnp->cn_namelen);
	fbuf->fb_dat[cnp->cn_namelen] = '\0';

	error = fb_queue(fmp->dev, fbuf);
	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_CREATE;

		fb_delete(fbuf);
		goto out;
	}

	if ((error = VFS_VGET(fmp->mp, fbuf->fb_ino, &tdp))) {
		fb_delete(fbuf);
		goto out;
	}

	tdp->v_type = IFTOVT(fbuf->fb_io_mode);

	*vpp = tdp;
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	fb_delete(fbuf);
out:
	vput(ap->a_dvp);
	return (error);
}

int
fusefs_mknod(void *v)
{
	struct vop_mknod_args *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct vnode **vpp = ap->a_vpp;
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct proc *p = cnp->cn_proc;
	struct vnode *tdp = NULL;
	struct fusefs_mnt *fmp;
	struct fusefs_node *ip;
	struct fusebuf *fbuf;
	int error = 0;

	ip = VTOI(dvp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init) {
		error = ENXIO;
		goto out;
	}

	if (fmp->undef_op & UNDEF_MKNOD) {
		error = ENOSYS;
		goto out;
	}

	fbuf = fb_setup(cnp->cn_namelen + 1, ip->ufs_ino.i_number,
	    FBT_MKNOD, p);

	fbuf->fb_io_mode = MAKEIMODE(vap->va_type, vap->va_mode);
	if (vap->va_rdev != VNOVAL)
		fbuf->fb_io_rdev = vap->va_rdev;

	memcpy(fbuf->fb_dat, cnp->cn_nameptr, cnp->cn_namelen);
	fbuf->fb_dat[cnp->cn_namelen] = '\0';

	error = fb_queue(fmp->dev, fbuf);
	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_MKNOD;

		fb_delete(fbuf);
		goto out;
	}

	if ((error = VFS_VGET(fmp->mp, fbuf->fb_ino, &tdp))) {
		fb_delete(fbuf);
		goto out;
	}

	tdp->v_type = IFTOVT(fbuf->fb_io_mode);

	*vpp = tdp;
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	fb_delete(fbuf);
	vput(ap->a_dvp);

	/* Remove inode so that it will be reloaded by VFS_VGET and
	 * checked to see if it is an alias of an existing entry in
	 * the inode cache.
	 */
	vput(*vpp);
	(*vpp)->v_type = VNON;
	vgone(*vpp);
	*vpp = NULL;
	return (0);
out:
	vput(ap->a_dvp);
	return (error);
}

int
fusefs_read(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uio *uio = ap->a_uio;
	struct proc *p = uio->uio_procp;
	struct fusefs_node *ip;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf = NULL;
	size_t size;
	int error=0;

	ip = VTOI(vp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init)
		return (ENXIO);
	if (uio->uio_resid == 0)
		return (error);
	if (uio->uio_offset < 0)
		return (EINVAL);

	while (uio->uio_resid > 0) {
		fbuf = fb_setup(0, ip->ufs_ino.i_number, FBT_READ, p);

		size = MIN(uio->uio_resid, fmp->max_read);
		fbuf->fb_io_fd = fusefs_fd_get(ip, FUFH_RDONLY);
		fbuf->fb_io_off = uio->uio_offset;
		fbuf->fb_io_len = size;

		error = fb_queue(fmp->dev, fbuf);

		if (error)
			break;

		error = uiomove(fbuf->fb_dat, ulmin(size, fbuf->fb_len), uio);
		if (error)
			break;

		if (fbuf->fb_len < size)
			break;

		fb_delete(fbuf);
		fbuf = NULL;
	}

	fb_delete(fbuf);
	return (error);
}

int
fusefs_write(void *v)
{
	struct vop_write_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uio *uio = ap->a_uio;
	struct proc *p = uio->uio_procp;
	struct ucred *cred = p->p_ucred;
	struct vattr vattr;
	int ioflag = ap->a_ioflag;
	struct fusefs_node *ip;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf = NULL;
	size_t len, diff;
	int error=0;

	ip = VTOI(vp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init)
		return (ENXIO);
	if (uio->uio_resid == 0)
		return (error);

	if (ioflag & IO_APPEND) {
		if ((error = VOP_GETATTR(vp, &vattr, cred, p)) != 0)
			return (error);

		uio->uio_offset = vattr.va_size;
	}

	while (uio->uio_resid > 0) {
		len = MIN(uio->uio_resid, fmp->max_read);
		fbuf = fb_setup(len, ip->ufs_ino.i_number, FBT_WRITE, p);

		fbuf->fb_io_fd = fusefs_fd_get(ip, FUFH_WRONLY);
		fbuf->fb_io_off = uio->uio_offset;
		fbuf->fb_io_len = len;

		if ((error = uiomove(fbuf->fb_dat, len, uio))) {
			printf("fusefs: uio error %i\n", error);
			break;
		}

		error = fb_queue(fmp->dev, fbuf);

		if (error)
			break;

		diff = len - fbuf->fb_io_len;
		if (fbuf->fb_io_len > len) {
			error = EINVAL;
			break;
		}

		uio->uio_resid += diff;
		uio->uio_offset -= diff;

		fb_delete(fbuf);
		fbuf = NULL;
	}

	fb_delete(fbuf);
	return (error);
}

int
fusefs_poll(void *v)
{
	struct vop_poll_args *ap = v;

	/*
	 * We should really check to see if I/O is possible.
	 */
	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}

int
fusefs_rename(void *v)
{
	struct vop_rename_args *ap = v;
	struct vnode *tvp = ap->a_tvp;
	struct vnode *tdvp = ap->a_tdvp;
	struct vnode *fvp = ap->a_fvp;
	struct vnode *fdvp = ap->a_fdvp;
	struct componentname *tcnp = ap->a_tcnp;
	struct componentname *fcnp = ap->a_fcnp;
	struct proc *p = fcnp->cn_proc;
	struct fusefs_node *ip, *dp;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	int error = 0;

#ifdef DIAGNOSTIC
	if ((tcnp->cn_flags & HASBUF) == 0 ||
	    (fcnp->cn_flags & HASBUF) == 0)
		panic("fusefs_rename: no name");
#endif
	/*
	 * Check for cross-device rename.
	 */
	if ((fvp->v_mount != tdvp->v_mount) ||
	    (tvp && (fvp->v_mount != tvp->v_mount))) {
		error = EXDEV;
abortit:
		VOP_ABORTOP(tdvp, tcnp); /* XXX, why not in NFS? */
		if (tdvp == tvp)
			vrele(tdvp);
		else
			vput(tdvp);
		if (tvp)
			vput(tvp);
		VOP_ABORTOP(fdvp, fcnp); /* XXX, why not in NFS? */
		vrele(fdvp);
		vrele(fvp);
		return (error);
	}

	/*
	 * If source and dest are the same, do nothing.
	 */
	if (tvp == fvp) {
		error = 0;
		goto abortit;
	}

	if ((error = vn_lock(fvp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
		goto abortit;
	dp = VTOI(fdvp);
	ip = VTOI(fvp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	/*
	 * Be sure we are not renaming ".", "..", or an alias of ".". This
	 * leads to a crippled directory tree.  It's pretty tough to do a
	 * "ls" or "pwd" with the "." directory entry missing, and "cd .."
	 * doesn't work if the ".." entry is missing.
	 */
	if (fvp->v_type == VDIR) {
		/*
		 * Avoid ".", "..", and aliases of "." for obvious reasons.
		 */
		if ((fcnp->cn_namelen == 1 && fcnp->cn_nameptr[0] == '.') ||
		    dp == ip ||
		    (fcnp->cn_flags & ISDOTDOT) ||
		    (tcnp->cn_flags & ISDOTDOT)) {
			VOP_UNLOCK(fvp, p);
			error = EINVAL;
			goto abortit;
		}
	}
	VN_KNOTE(fdvp, NOTE_WRITE);	/* XXX right place? */

	if (!fmp->sess_init) {
		error = ENXIO;
		VOP_UNLOCK(fvp, p);
		goto abortit;
	}

	if (fmp->undef_op & UNDEF_RENAME) {
		error = ENOSYS;
		VOP_UNLOCK(fvp, p);
		goto abortit;
	}

	fbuf = fb_setup(fcnp->cn_namelen + tcnp->cn_namelen + 2,
	    dp->ufs_ino.i_number, FBT_RENAME, p);

	memcpy(fbuf->fb_dat, fcnp->cn_nameptr, fcnp->cn_namelen);
	fbuf->fb_dat[fcnp->cn_namelen] = '\0';
	memcpy(fbuf->fb_dat + fcnp->cn_namelen + 1, tcnp->cn_nameptr,
	    tcnp->cn_namelen);
	fbuf->fb_dat[fcnp->cn_namelen + tcnp->cn_namelen + 1] = '\0';
	fbuf->fb_io_ino = VTOI(tdvp)->ufs_ino.i_number;

	error = fb_queue(fmp->dev, fbuf);

	if (error) {
		if (error == ENOSYS) {
			fmp->undef_op |= UNDEF_RENAME;
		}

		fb_delete(fbuf);
		VOP_UNLOCK(fvp, p);
		goto abortit;
	}

	fb_delete(fbuf);
	VN_KNOTE(fvp, NOTE_RENAME);

	VOP_UNLOCK(fvp, p);
	if (tdvp == tvp)
		vrele(tdvp);
	else
		vput(tdvp);
	vrele(fdvp);
	vrele(fvp);

	return (error);
}

int
fusefs_mkdir(void *v)
{
	struct vop_mkdir_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vnode **vpp = ap->a_vpp;
	struct componentname *cnp = ap->a_cnp;
	struct vattr *vap = ap->a_vap;
	struct proc *p = cnp->cn_proc;
	struct vnode *tdp = NULL;
	struct fusefs_node *ip;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	int error = 0;

	ip = VTOI(dvp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;


	if (!fmp->sess_init) {
		error = ENXIO;
		goto out;
	}

	if (fmp->undef_op & UNDEF_MKDIR) {
		error = ENOSYS;
		goto out;
	}

	fbuf = fb_setup(cnp->cn_namelen + 1, ip->ufs_ino.i_number,
	    FBT_MKDIR, p);

	fbuf->fb_io_mode = MAKEIMODE(vap->va_type, vap->va_mode);
	memcpy(fbuf->fb_dat, cnp->cn_nameptr, cnp->cn_namelen);
	fbuf->fb_dat[cnp->cn_namelen] = '\0';

	error = fb_queue(fmp->dev, fbuf);
	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_MKDIR;

		fb_delete(fbuf);
		goto out;
	}

	if ((error = VFS_VGET(fmp->mp, fbuf->fb_ino, &tdp))) {
		fb_delete(fbuf);
		goto out;
	}

	tdp->v_type = IFTOVT(fbuf->fb_io_mode);

	*vpp = tdp;
	VN_KNOTE(ap->a_dvp, NOTE_WRITE | NOTE_LINK);
	fb_delete(fbuf);
out:
	vput(dvp);
	return (error);
}

int
fusefs_rmdir(void *v)
{
	struct vop_rmdir_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	struct fusefs_node *ip, *dp;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	int error;

	ip = VTOI(vp);
	dp = VTOI(dvp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init) {
		error = ENXIO;
		goto out;
	}

	if (fmp->undef_op & UNDEF_RMDIR) {
		error = ENOSYS;
		goto out;
	}

	/*
	 * No rmdir "." please.
	 */
	if (dp == ip) {
		vrele(dvp);
		vput(vp);
		return (EINVAL);
	}

	VN_KNOTE(dvp, NOTE_WRITE | NOTE_LINK);

	fbuf = fb_setup(cnp->cn_namelen + 1, dp->ufs_ino.i_number,
	    FBT_RMDIR, p);
	memcpy(fbuf->fb_dat, cnp->cn_nameptr, cnp->cn_namelen);
	fbuf->fb_dat[cnp->cn_namelen] = '\0';

	error = fb_queue(fmp->dev, fbuf);

	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_RMDIR;
		if (error != ENOTEMPTY)
			VN_KNOTE(dvp, NOTE_WRITE | NOTE_LINK);

		fb_delete(fbuf);
		goto out;
	}

	vput(dvp);
	dvp = NULL;

	fb_delete(fbuf);
out:
	if (dvp)
		vput(dvp);
	VN_KNOTE(vp, NOTE_DELETE);
	vput(vp);
	return (error);
}

int
fusefs_remove(void *v)
{
	struct vop_remove_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	struct fusefs_node *ip;
	struct fusefs_node *dp;
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	int error = 0;

	ip = VTOI(vp);
	dp = VTOI(dvp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init) {
		error = ENXIO;
		goto out;
	}

	if (fmp->undef_op & UNDEF_REMOVE) {
		error = ENOSYS;
		goto out;
	}

	fbuf = fb_setup(cnp->cn_namelen + 1, dp->ufs_ino.i_number,
	    FBT_UNLINK, p);
	memcpy(fbuf->fb_dat, cnp->cn_nameptr, cnp->cn_namelen);
	fbuf->fb_dat[cnp->cn_namelen] = '\0';

	error = fb_queue(fmp->dev, fbuf);
	if (error) {
		if (error == ENOSYS)
			fmp->undef_op |= UNDEF_REMOVE;

		fb_delete(fbuf);
		goto out;
	}

	VN_KNOTE(vp, NOTE_DELETE);
	VN_KNOTE(dvp, NOTE_WRITE);
	fb_delete(fbuf);
out:
	if (dvp == vp)
		vrele(vp);
	else
		vput(vp);
	vput(dvp);
	return (error);
}

int
fusefs_strategy(void *v)
{
	return (0);
}

int
fusefs_lock(void *v)
{
	struct vop_lock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	return rrw_enter(&VTOI(vp)->ufs_ino.i_lock, ap->a_flags & LK_RWFLAGS);
}

int
fusefs_unlock(void *v)
{
	struct vop_unlock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	rrw_exit(&VTOI(vp)->ufs_ino.i_lock);
	return 0;
}

int
fusefs_islocked(void *v)
{
	struct vop_islocked_args *ap = v;

	return rrw_status(&VTOI(ap->a_vp)->ufs_ino.i_lock);
}

int
fusefs_advlock(void *v)
{
	struct vop_advlock_args *ap = v;
	struct fusefs_node *ip = VTOI(ap->a_vp);

	return (lf_advlock(&ip->ufs_ino.i_lockf, ip->filesize, ap->a_id,
	    ap->a_op, ap->a_fl, ap->a_flags));
}
@


1.32
log
@Use struct stat for storing attributes in fusebufs, because using struct
vattr in userspace is suboptimal as some related helpers are not
available, e.g. VATTR_NULL() and IFTOVT(). The conversion is now done in
the kernel where it belongs. As a side effect the <sys/vnode.h> include
can be removed from libfuse.

tweaks and ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.31 2016/08/21 09:23:33 natano Exp $ */
a662 1
	VTOI(tdp)->parent = dp->ufs_ino.i_number;
a833 4
	/*
	 * Purge old data structures associated with the inode.
	 */
	ip->parent = 0;
d839 1
a839 1
	if (fmp->sess_init) {
a922 2
	if (dvp != NULL && dvp->v_type == VDIR)
		VTOI(tdp)->parent = ip->ufs_ino.i_number;
a984 2
	if (dvp != NULL && dvp->v_type == VDIR)
		VTOI(tdp)->parent = ip->ufs_ino.i_number;
a1307 2
	if (dvp != NULL && dvp->v_type == VDIR)
		VTOI(tdp)->parent = ip->ufs_ino.i_number;
@


1.31
log
@There are three callers of update_vattr(). Two of them don't use the
updated struct vattr afterwards, so the call can be removed. Remove both
calls and the function itself, inlining the last remaining call.

ok millert
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.30 2016/08/16 21:32:58 natano Exp $ */
d30 1
d376 1
d393 2
a394 1
	memcpy(vap, &fbuf->fb_vattr, sizeof(*vap));
d396 5
d402 8
a409 3
	vap->va_type = IFTOVT(vap->va_mode);
	vap->va_bytes *= S_BLKSIZE;
	vap->va_mode &= ~S_IFMT;
d453 1
a453 1
		fbuf->fb_vattr.va_uid = vap->va_uid;
d462 1
a462 1
		fbuf->fb_vattr.va_gid = vap->va_gid;
d482 1
a482 1
		fbuf->fb_vattr.va_size = vap->va_size;
d491 1
a491 2
		fbuf->fb_vattr.va_atime.tv_sec = vap->va_atime.tv_sec;
		fbuf->fb_vattr.va_atime.tv_nsec = vap->va_atime.tv_nsec;
d500 1
a500 2
		fbuf->fb_vattr.va_mtime.tv_sec = vap->va_mtime.tv_sec;
		fbuf->fb_vattr.va_mtime.tv_nsec = vap->va_mtime.tv_nsec;
d510 1
a510 1
		fbuf->fb_vattr.va_mode = vap->va_mode & ALLPERMS;
a514 5
		goto out;
	}

	if (io->fi_flags & FUSE_FATTR_SIZE && vp->v_type == VDIR) {
		error = EISDIR;
@


1.30
log
@There is no sense in doing caching in fusefs. In case of a non-local
filesystem the tree can change behind our back, resulting in stale cache
entries. "The only winning move is not to play."

ok tedu beck mpi
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.29 2016/08/12 20:18:44 natano Exp $ */
a205 13
void
update_vattr(struct mount *mp, struct vattr *v)
{
	v->va_fsid = mp->mnt_stat.f_fsid.val[0];
	v->va_type = IFTOVT(v->va_mode);
#if (S_BLKSIZE == 512)
	v->va_bytes = v->va_bytes << 9;
#else
	v->va_bytes = v->va_bytes * S_BLKSIZE;
#endif
	v->va_mode = v->va_mode & ~S_IFMT;
}

a390 1
	update_vattr(fmp->mp, &fbuf->fb_vattr);
d392 6
a512 1

a518 2
	update_vattr(fmp->mp, &fbuf->fb_vattr);
	memcpy(vap, &fbuf->fb_vattr, sizeof(*vap));
@


1.29
log
@Dedup vnode type information. Fuse stores the vnode type in two places:
vtype in struct fusefs_node and v_type in struct vnode. Given the fact,
that fusefs_node structs are never allocated without an associated vnode
and those two fields are always in sync, one of those locations is
superfluous.

While there remove the unused nlookup field.

ok mpi
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.28 2016/06/19 11:54:33 natano Exp $ */
a859 1
	cache_purge(vp);
a1387 1
	cache_purge(dvp);
a1390 1
	cache_purge(ITOV(ip));
@


1.28
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.27 2016/03/19 12:04:15 natano Exp $ */
d238 1
a238 1
	if (ip->vtype == VDIR)
d277 1
a277 1
	if (ip->vtype == VDIR) {
a667 1
	VTOI(tdp)->vtype = tdp->v_type;
d764 1
a764 1
			    (ip->vtype == VDIR), ap->a_p);
d837 1
a837 1
			    (ip->vtype == VDIR), ap->a_p);
a933 2
	VTOI(tdp)->vtype = tdp->v_type;

a997 2
	VTOI(tdp)->vtype = tdp->v_type;

d1209 1
a1209 1
	if (ip->vtype == VDIR) {
a1322 2
	VTOI(tdp)->vtype = tdp->v_type;

@


1.27
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.26 2016/01/22 17:09:43 stefan Exp $ */
d1476 1
a1476 1
	return (lockmgr(&VTOI(vp)->ufs_ino.i_lock, ap->a_flags, NULL));
d1485 2
a1486 1
	return (lockmgr(&VTOI(vp)->ufs_ino.i_lock, LK_RELEASE, NULL));
d1494 1
a1494 1
	return (lockstatus(&VTOI(ap->a_vp)->ufs_ino.i_lock));
@


1.26
log
@Straightforward uiomovei -> uiomove conversion. All size arguments for
uiomove had unsigned types already.

Diff from Martin Natano.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.25 2015/09/23 15:37:26 tedu Exp $ */
d609 1
a609 1
		VOP_UNLOCK(vp, 0, p);
d770 1
a770 1
	VOP_UNLOCK(vp, 0, p);
d1222 1
a1222 1
			VOP_UNLOCK(fvp, 0, p);
d1231 1
a1231 1
		VOP_UNLOCK(fvp, 0, p);
d1237 1
a1237 1
		VOP_UNLOCK(fvp, 0, p);
d1259 1
a1259 1
		VOP_UNLOCK(fvp, 0, p);
d1266 1
a1266 1
	VOP_UNLOCK(fvp, 0, p);
d1485 1
a1485 2
	return (lockmgr(&VTOI(vp)->ufs_ino.i_lock, ap->a_flags | LK_RELEASE,
	    NULL));
@


1.25
log
@remove lockmgr_printinfo stubs. from Martin Natano
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.24 2015/04/17 04:43:21 guenther Exp $ */
d731 1
a731 1
		if ((error = uiomovei(fbuf->fb_dat, fbuf->fb_len, uio))) {
d813 1
a813 1
	error = uiomovei(fbuf->fb_dat, fbuf->fb_len, uio);
d1061 1
a1061 1
		error = uiomovei(fbuf->fb_dat, MIN(size, fbuf->fb_len), uio);
d1115 1
a1115 1
		if ((error = uiomovei(fbuf->fb_dat, len, uio))) {
@


1.24
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.23 2015/02/19 10:22:20 tedu Exp $ */
a876 1
	lockmgr_printinfo(&ip->ufs_ino.i_lock);
@


1.23
log
@set the eofflag in readdir like we're supposed to.
from Martin Natano
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.22 2015/02/10 21:56:10 miod Exp $ */
d481 1
a481 1
	if (vap->va_atime.tv_sec != VNOVAL) {
d491 1
a491 1
	if (vap->va_mtime.tv_sec != VNOVAL) {
d500 1
@


1.22
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.21 2014/12/16 18:30:04 tedu Exp $ */
d689 1
a689 1
	int error = 0;
d723 1
a723 1
		/*ack end of readdir */
d725 1
d737 3
@


1.21
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.20 2014/08/10 09:23:06 jsg Exp $ */
d729 1
a729 1
		if ((error = uiomove(fbuf->fb_dat, fbuf->fb_len, uio))) {
d808 1
a808 1
	error = uiomove(fbuf->fb_dat, fbuf->fb_len, uio);
d1057 1
a1057 1
		error = uiomove(fbuf->fb_dat, MIN(size, fbuf->fb_len), uio);
d1111 1
a1111 1
		if ((error = uiomove(fbuf->fb_dat, len, uio))) {
@


1.20
log
@fix kqueue read/write filters for msdosfs and fusefs
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.19 2014/07/12 18:43:52 tedu Exp $ */
d32 1
@


1.19
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.18 2014/05/20 13:32:22 syl Exp $ */
d22 1
d69 2
a70 1
int	filt_fusefsreadwrite(struct knote *, long);
d110 4
a113 2
struct filterops fusefsreadwrite_filtops =
	{ 1, NULL, filt_fusefsdetach, filt_fusefsreadwrite };
d126 1
a126 1
		kn->kn_fop = &fusefsreadwrite_filtops;
d129 1
a129 1
		kn->kn_fop = &fusefsreadwrite_filtops;
d154 1
a154 1
filt_fusefsreadwrite(struct knote *kn, long hint)
d156 3
d168 6
d175 16
@


1.18
log
@Add -o max_read=XXX support in fuse. This is needed by usmb to have a
working read() and write().

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.17 2014/05/19 13:55:29 syl Exp $ */
d828 1
a828 1
	free(ip, M_FUSEFS);
@


1.17
log
@Add some consistency in fuse error handling. We need to return ENXIO
when the fuse communication channel is broken and ENOSYS when the
libfuse callback does not exist.

Reported by Helg Bredow, thanks!
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.16 2014/03/18 08:51:53 mpi Exp $ */
d684 1
a684 1
		fbuf->fb_io_len = MIN(uio->uio_resid, FUSEBUFMAXSIZE);
d1017 1
a1017 1
		size = MIN(uio->uio_resid, FUSEBUFMAXSIZE);
d1074 1
a1074 1
		len = MIN(uio->uio_resid, FUSEBUFMAXSIZE);
@


1.16
log
@Do not rely on the fact that sys/vnode.h includes all the world
through uvm/uvm.h and add proper includes for function definitions.

ok syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.15 2014/02/01 09:30:38 syl Exp $ */
d205 1
a205 1
		return (0);
d296 4
a299 1
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_ACCESS))
d364 1
a364 1
		goto fake;
a377 4
fake:
	bzero(vap, sizeof(*vap));
	vap->va_type = vp->v_type;
	return (0);
d403 1
a403 1
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_SETATTR))
d406 3
d526 14
a554 7
	ip = VTOI(vp);
	dip = VTOI(dvp);
	fmp = (struct fusefs_mnt *)ip->ufs_ino.i_ump;

	if (!fmp->sess_init || (fmp->undef_op & UNDEF_LINK))
		goto out1;

d603 6
a608 1
	if (!fmp->sess_init  || (fmp->undef_op & UNDEF_SYMLINK)) {
d669 1
a669 1
		return (0);
d760 5
a764 4
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_READLINK)) {
		error = ENOSYS;
		goto out;
	}
d775 1
a775 1
		goto out;
d780 1
a780 1
out:
d867 6
a872 1
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_CREATE)) {
d932 6
a937 1
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_MKNOD)) {
d1195 7
a1201 1
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_RENAME)) {
d1262 6
a1267 1
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_MKDIR)) {
d1324 10
a1342 5
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_RMDIR)) {
		error = ENOSYS;
		goto out;
	}

d1394 6
a1399 1
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_REMOVE)) {
@


1.15
log
@Replace the vnode struct vattr cache by VOP_GETATTR() calls.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.14 2014/01/29 20:37:18 syl Exp $ */
d19 1
@


1.14
log
@Add fuse support for IO_APPEND.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.13 2014/01/16 09:31:44 syl Exp $ */
d283 2
d291 1
d336 5
a340 2
	return (vaccess(ap->a_vp->v_type, ip->cached_attrs.va_mode & ALLPERMS,
	    ip->cached_attrs.va_uid, ip->cached_attrs.va_gid, ap->a_mode,
a371 1
	memcpy(&ip->cached_attrs, vap, sizeof(*vap));
d701 1
d705 1
d718 2
d722 1
a722 2
	/* not sure if it is ok to do like that ...*/
	if (ip->cached_attrs.va_mode == 0)
d725 1
a725 1
	return (error);
@


1.13
log
@Add support for mknod in fuse.

OK tedu@@
"it looks good to me" from guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.12 2013/12/20 22:03:26 syl Exp $ */
d26 1
d1015 3
d1031 7
@


1.12
log
@Add support for truncate in fuse.

Input from millert@@.

Ok millert@@, tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.11 2013/12/03 09:59:40 syl Exp $ */
d888 33
d922 16
d939 1
d941 13
a953 1
	return (EINVAL);
@


1.11
log
@Add support for FBT_RECLAIM that allow us to free the representation
of vnode in userspace.

"I think it's right" from tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.10 2013/12/03 09:32:23 syl Exp $ */
d433 1
d438 2
a439 1
		/*XXX to finish*/
@


1.10
log
@Add some missing check to know if the communication channel with
libfuse is still open before sending fusebufs.

ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.9 2013/10/07 18:25:32 syl Exp $ */
d765 1
d783 11
@


1.9
log
@use printf(9) consistently in FUSE
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.8 2013/10/07 18:24:12 syl Exp $ */
d896 2
d947 2
@


1.8
log
@Add kqueue's support for FUSE.

tested with ajacoutot@@ on gvfs+nautilus.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.7 2013/10/07 18:15:21 syl Exp $ */
d773 1
a773 1
			printf("FUSE: vnode being reclaimed is valid\n");
@


1.7
log
@Introduce fb_delete() helper and use it in FUSE code.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.6 2013/10/07 18:04:53 syl Exp $ */
d35 1
d65 5
d83 1
d106 68
d488 1
d555 2
d616 1
a1219 2

	VN_KNOTE(dvp, NOTE_WRITE | NOTE_LINK);
@


1.6
log
@Rework fuseread() and fusewrite().
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.5 2013/09/17 19:07:11 syl Exp $ */
a25 1
#include <sys/pool.h>
d244 1
a244 1
			pool_put(&fusefs_fbuf_pool, fbuf);
d249 1
a249 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d253 1
a253 1
	pool_put(&fusefs_fbuf_pool, fbuf);
d284 1
a284 1
		pool_put(&fusefs_fbuf_pool, fbuf);
a287 6
	/* check if we got a response */
	if (fbuf->fb_len == 0) {
		pool_put(&fusefs_fbuf_pool, fbuf);
		goto fake;
	}

d291 1
a291 1
	pool_put(&fusefs_fbuf_pool, fbuf);
d415 1
a415 1
	pool_put(&fusefs_fbuf_pool, fbuf);
d474 1
a474 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d478 1
a478 1
	pool_put(&fusefs_fbuf_pool, fbuf);
d526 1
a526 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d531 1
a531 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d540 1
a540 1
	pool_put(&fusefs_fbuf_pool, fbuf);
d577 1
a577 1
			pool_put(&fusefs_fbuf_pool, fbuf);
d587 1
a587 1
			pool_put(&fusefs_fbuf_pool, fbuf);
d593 1
a593 1
			pool_put(&fusefs_fbuf_pool, fbuf);
d598 1
a598 1
			pool_put(&fusefs_fbuf_pool, fbuf);
d602 1
a602 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d668 1
a668 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d673 1
a673 1
	pool_put(&fusefs_fbuf_pool, fbuf);
d768 1
a768 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d773 1
a773 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d785 1
a785 2
	pool_put(&fusefs_fbuf_pool, fbuf);

d842 1
a842 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d846 1
a846 3
	if (fbuf)
		pool_put(&fusefs_fbuf_pool, fbuf);

d896 1
a896 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d900 1
a900 2
	if (fbuf)
		pool_put(&fusefs_fbuf_pool, fbuf);
d1014 1
a1014 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d1019 1
d1069 1
a1069 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d1074 1
a1074 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d1086 1
a1086 1
	pool_put(&fusefs_fbuf_pool, fbuf);
d1138 1
a1138 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d1149 1
a1149 1
	pool_put(&fusefs_fbuf_pool, fbuf);
d1191 1
a1191 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d1197 1
a1197 1
	pool_put(&fusefs_fbuf_pool, fbuf);
@


1.5
log
@size_t could not be < 0.

Thanks to Pedro Martelletto.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.4 2013/08/10 00:12:45 syl Exp $ */
d238 1
a238 1
	fbuf = fb_setup(FUSEFDSIZE, ip->ufs_ino.i_number, FBT_ACCESS, p);
d332 1
a332 2
	fbuf = fb_setup(FUSEFDSIZE + sizeof(*io), ip->ufs_ino.i_number,
	    FBT_SETATTR, p);
d468 2
a469 2
	fbuf = fb_setup(FUSEFDSIZE + cnp->cn_namelen + 1,
	    dip->ufs_ino.i_number, FBT_LINK, p);
d521 2
a522 2
	fbuf = fb_setup(FUSEFDSIZE + len + cnp->cn_namelen + 1,
	    dp->ufs_ino.i_number, FBT_SYMLINK, p);
d580 1
a580 2
		fbuf = fb_setup(FUSEFDSIZE, ip->ufs_ino.i_number, FBT_READDIR,
		    p);
d589 1
a589 1
		fbuf->fb_io_len = MIN(uio->uio_resid, FUSELEN);
d599 1
a599 1
		if (fbdatsize(fbuf) == 0) {
d604 1
a604 1
		if ((error = uiomove(fbuf->fb_dat, fbdatsize(fbuf), uio))) {
d679 1
a679 1
	error = uiomove(fbuf->fb_dat, fbdatsize(fbuf), uio);
d761 2
a762 2
	fbuf = fb_setup(FUSEFDSIZE + cnp->cn_namelen + 1,
	    ip->ufs_ino.i_number, FBT_CREATE, p);
d831 1
a831 1
		fbuf = fb_setup(FUSEFDSIZE, ip->ufs_ino.i_number, FBT_READ, p);
d833 1
a833 1
		size = MIN(uio->uio_resid, FUSELEN);
d843 1
a843 1
		error = uiomove(fbuf->fb_dat, MIN(size, fbdatsize(fbuf)), uio);
d847 1
a847 1
		if (fbdatsize(fbuf) < size)
d880 2
a881 3
		len = MIN(uio->uio_resid, FUSELEN);
		fbuf = fb_setup(FUSEFDSIZE + len, ip->ufs_ino.i_number,
		    FBT_WRITE, p);
d1008 1
a1008 1
	fbuf = fb_setup(FUSEFDSIZE + fcnp->cn_namelen + tcnp->cn_namelen + 2,
d1067 1
a1067 1
	fbuf = fb_setup(FUSEFDSIZE + cnp->cn_namelen + 1, ip->ufs_ino.i_number,
d1135 1
a1135 1
	fbuf = fb_setup(FUSEFDSIZE + cnp->cn_namelen + 1, dp->ufs_ino.i_number,
d1191 1
a1191 1
	fbuf = fb_setup(FUSEFDSIZE + cnp->cn_namelen + 1, dp->ufs_ino.i_number,
@


1.4
log
@Remove debug printfs.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.3 2013/06/12 22:55:02 tedu Exp $ */
d901 1
a901 1
		if (diff < 0) {
@


1.3
log
@remove extra whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.2 2013/06/05 18:26:06 tedu Exp $ */
a34 6
#ifdef	FUSE_DEBUG_VNOP
#define	DPRINTF(fmt, arg...)	printf("fuse vnop: " fmt, ##arg)
#else
#define	DPRINTF(fmt, arg...)
#endif

a123 2
	DPRINTF("fusefs_open\n");

a130 2
	DPRINTF("inode = %i mode=0x%x\n", ip->ufs_ino.i_number, ap->a_mode);

a151 2
	DPRINTF("file open fd : %i\n", ip->fufh[fufh_type].fh_id);

a163 2
	DPRINTF("fusefs_close\n");

a211 2
	DPRINTF("fusefs_access\n");

d249 1
a249 1
		DPRINTF("access error %i\n", error);
a274 2
	DPRINTF("fusefs_getattr\n");

a284 1
		DPRINTF("getattr error\n");
a318 1
	DPRINTF("fusefs_setattr\n");
a429 1
	DPRINTF("fusefs_ioctl\n");
a446 2
	DPRINTF("fusefs_link\n");

a511 1
	DPRINTF("fusefs_symlink\n");
a576 3
	DPRINTF("fusefs_readdir\n");
	DPRINTF("uio resid 0x%x\n", uio->uio_resid);

a628 1
	DPRINTF("fusefs_inactive\n");
a658 2
	DPRINTF("fusefs_readlink\n");

a696 1
	DPRINTF("fusefs_reclaim\n");
d703 1
a703 1
			printf("FUSE: vnode being reclaimed is valid");
a753 2
	DPRINTF("fusefs_create(cnp %08x, vap %08x\n", cnp, vap);

a823 2
	DPRINTF("fusefs_read\n");

a826 3
	DPRINTF("read inode=%i, offset=%llu, resid=%x\n",
	    ip->ufs_ino.i_number, uio->uio_offset, uio->uio_resid);

a874 2
	DPRINTF("fusefs_write\n");

a877 3
	DPRINTF("write inode=%i, offset=%llu, resid=%x\n",
	    ip->ufs_ino.i_number, uio->uio_offset, uio->uio_resid);

d891 1
a891 1
			DPRINTF("uio error %i", error);
a922 2
	DPRINTF("fusefs_poll\n");

a944 2
	DPRINTF("fusefs_rename\n");

a1060 2
	DPRINTF("fusefs_mkdir %s\n", cnp->cn_nameptr);

a1117 2
	DPRINTF("fusefs_rmdir\n");

a1184 2
	DPRINTF("fusefs_remove\n");

a1222 1
	DPRINTF("fusefs_strategy\n");
a1231 1
	DPRINTF("fusefs_lock\n");
a1240 1
	DPRINTF("fusefs_unlock\n");
a1249 1
	DPRINTF("fusefs_islocked\n");
a1258 1
	DPRINTF("fusefs_advlock\n");
@


1.2
log
@rename should be working now, from Sylvestre Gallon
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vnops.c,v 1.1 2013/06/03 15:50:56 tedu Exp $ */
d344 3
a346 3
		(vap->va_fsid != VNOVAL) || (vap->va_fileid != VNOVAL) ||
		(vap->va_blocksize != VNOVAL) || (vap->va_rdev != VNOVAL) ||
		((int)vap->va_bytes != VNOVAL) || (vap->va_gen != VNOVAL))
@


1.1
log
@add a bunch of files for ISC-licensed FUSE support. ok beck deraadt
from Sylvestre Gallon ccna.syl gmail.com. Many thanks to Sylvestre for
all the hard work.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1021 2
a1022 21
		if (fvp->v_type == VDIR) {
			error = EINVAL;
			goto abortit;
		}

		DPRINTF("THE SAME!!!\n");
		/* Release destination completely. */
		VOP_ABORTOP(tdvp, tcnp);
		vput(tdvp);
		vput(tvp);

		/* Delete source. */
		vrele(fdvp);
		vrele(fvp);
		fcnp->cn_flags &= ~MODMASK;
		fcnp->cn_flags |= LOCKPARENT | LOCKLEAF;
		if ((fcnp->cn_flags & SAVESTART) == 0)
			panic("fusefs_rename: lost from startdir");
		fcnp->cn_nameiop = DELETE;
		vfs_relookup(fdvp, &fvp, fcnp);
		return (VOP_REMOVE(fdvp, fvp, fcnp));
a1024 1
	/* */
a1028 1

a1029 8
	/*
	 *If fuse connection down RENAME undef
	 */
	if (!fmp->sess_init || (fmp->undef_op & UNDEF_RMDIR)) {
		VOP_UNLOCK(fvp, 0, p);
		error = ENOSYS;
		goto abortit;
	}
a1037 9
		error = VOP_ACCESS(fvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
		if (!error && tvp)
			error = VOP_ACCESS(tvp, VWRITE, tcnp->cn_cred,
			    tcnp->cn_proc);
		if (error) {
			VOP_UNLOCK(fvp, 0, p);
			error = EACCES;
			goto abortit;
		}
a1049 1
	vrele(fdvp);
d1052 5
a1056 5
	/*
	 * When the target exists, both the directory
	 * and target vnodes are returned locked.
	 */
	dp = VTOI(tdvp);
d1066 1
d1081 1
d1083 6
a1089 4
	if (dp)
		vput(fdvp);

	vrele(ap->a_fvp);
@

