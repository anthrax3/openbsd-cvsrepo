head	1.29;
access;
symbols
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5;
locks; strict;
comment	@ * @;


1.29
date	2017.04.20.14.13.00;	author visa;	state Exp;
branches;
next	1.28;
commitid	GnoPKa34InShCqYl;

1.28
date	2016.09.07.17.53.35;	author natano;	state Exp;
branches;
next	1.27;
commitid	bTUYWm2clD2A9qNB;

1.27
date	2016.08.30.16.45.54;	author natano;	state Exp;
branches;
next	1.26;
commitid	bR1BHPSoghZ5Wk7v;

1.26
date	2016.08.15.07.39.46;	author natano;	state Exp;
branches;
next	1.25;
commitid	hjoLkNqeAOhsoxoz;

1.25
date	2016.08.13.11.42.46;	author natano;	state Exp;
branches;
next	1.24;
commitid	LIBcLca7UGbaJAAZ;

1.24
date	2016.08.12.20.18.44;	author natano;	state Exp;
branches;
next	1.23;
commitid	sKMS4ZsvE4wG5Map;

1.23
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.22;
commitid	wHLNY5GFNXJSFYaC;

1.22
date	2016.05.26.16.03.29;	author natano;	state Exp;
branches;
next	1.21;
commitid	ehJudmeVJQv8BMD4;

1.21
date	2016.04.26.18.37.02;	author natano;	state Exp;
branches;
next	1.20;
commitid	WbumX8gCUOD8jZ5X;

1.20
date	2016.03.27.11.39.37;	author bluhm;	state Exp;
branches;
next	1.19;
commitid	C0IKsjKoZxFScK3M;

1.19
date	2016.03.17.18.52.31;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	XOU3hWgTktDOU9BT;

1.18
date	2016.02.25.19.07.45;	author natano;	state Exp;
branches;
next	1.17;
commitid	idVVK6x2L5mhw0t5;

1.17
date	2016.02.25.18.59.26;	author natano;	state Exp;
branches;
next	1.16;
commitid	alx4Q7MxMQJyWAFI;

1.16
date	2015.07.19.14.21.14;	author tedu;	state Exp;
branches;
next	1.15;
commitid	CTLriaFHzkiQC3Ge;

1.15
date	2014.12.23.04.54.45;	author tedu;	state Exp;
branches;
next	1.14;
commitid	8hl8hiLGdHv6QTVm;

1.14
date	2014.12.23.04.53.20;	author tedu;	state Exp;
branches;
next	1.13;
commitid	tEy6KipIOXG40w3N;

1.13
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.12;
commitid	P6Av4XGqOi3rFasL;

1.12
date	2014.10.03.18.53.13;	author tedu;	state Exp;
branches;
next	1.11;
commitid	I6aYnmXYbZiXoZOE;

1.11
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.10;
commitid	FE3DG5cICjyI4jWx;

1.10
date	2014.06.04.18.52.53;	author syl;	state Exp;
branches;
next	1.9;
commitid	rYthFETsFoa4JClk;

1.9
date	2014.05.20.13.32.22;	author syl;	state Exp;
branches;
next	1.8;

1.8
date	2013.12.10.13.43.05;	author pelikan;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.07.18.25.32;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.07.18.15.21;	author syl;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.21.21.30.38;	author syl;	state Exp;
branches;
next	1.4;

1.4
date	2013.06.12.22.55.02;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.09.12.51.40;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.04.20.52.54;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.15.50.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Tweak lock inits to make the system runnable with witness(4)
on amd64 and i386.
@
text
@/* $OpenBSD: fuse_vfsops.c,v 1.28 2016/09/07 17:53:35 natano Exp $ */
/*
 * Copyright (c) 2012-2013 Sylvestre Gallon <ccna.syl@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/specdev.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/sysctl.h>
#include <sys/vnode.h>
#include <sys/fusebuf.h>

#include "fusefs_node.h"
#include "fusefs.h"

int	fusefs_mount(struct mount *, const char *, void *, struct nameidata *,
	    struct proc *);
int	fusefs_start(struct mount *, int, struct proc *);
int	fusefs_unmount(struct mount *, int, struct proc *);
int	fusefs_root(struct mount *, struct vnode **);
int	fusefs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
int	fusefs_statfs(struct mount *, struct statfs *, struct proc *);
int	fusefs_sync(struct mount *, int, struct ucred *, struct proc *);
int	fusefs_vget(struct mount *, ino_t, struct vnode **);
int	fusefs_fhtovp(struct mount *, struct fid *, struct vnode **);
int	fusefs_vptofh(struct vnode *, struct fid *);
int	fusefs_init(struct vfsconf *);
int	fusefs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
	    struct proc *);
int	fusefs_checkexp(struct mount *, struct mbuf *, int *,
	    struct ucred **);

const struct vfsops fusefs_vfsops = {
	fusefs_mount,
	fusefs_start,
	fusefs_unmount,
	fusefs_root,
	fusefs_quotactl,
	fusefs_statfs,
	fusefs_sync,
	fusefs_vget,
	fusefs_fhtovp,
	fusefs_vptofh,
	fusefs_init,
	fusefs_sysctl,
	fusefs_checkexp
};

struct pool fusefs_fbuf_pool;

int
fusefs_mount(struct mount *mp, const char *path, void *data,
    struct nameidata *ndp, struct proc *p)
{
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	struct fusefs_args args;
	struct vnode *vp;
	struct file *fp;
	int error;

	if (mp->mnt_flag & MNT_UPDATE)
		return (EOPNOTSUPP);

	error = copyin(data, &args, sizeof(struct fusefs_args));
	if (error)
		return (error);

	if ((fp = fd_getfile(p->p_fd, args.fd)) == NULL)
		return (EBADF);

	if (fp->f_type != DTYPE_VNODE)
		return (EINVAL);

	vp = fp->f_data;
	if (vp->v_type != VCHR)
		return (EBADF);

	fmp = malloc(sizeof(*fmp), M_FUSEFS, M_WAITOK | M_ZERO);
	fmp->mp = mp;
	fmp->sess_init = 0;
	fmp->dev = vp->v_rdev;
	if (args.max_read > 0)
		fmp->max_read = MIN(args.max_read, FUSEBUFMAXSIZE);
	else
		fmp->max_read = FUSEBUFMAXSIZE;

	mp->mnt_data = fmp;
	mp->mnt_flag |= MNT_LOCAL;
	vfs_getnewfsid(mp);

	bzero(mp->mnt_stat.f_mntonname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntonname, path, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromname, "fusefs", MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromspec, "fusefs", MNAMELEN);

	fuse_device_set_fmp(fmp, 1);
	fbuf = fb_setup(0, 0, FBT_INIT, p);

	/* cannot tsleep on mount */
	fuse_device_queue_fbuf(fmp->dev, fbuf);

	return (0);
}

int
fusefs_start(struct mount *mp, int flags, struct proc *p)
{
	return (0);
}

int
fusefs_unmount(struct mount *mp, int mntflags, struct proc *p)
{
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	int flags = 0;
	int error;

	fmp = VFSTOFUSEFS(mp);

	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;

	if ((error = vflush(mp, NULLVP, flags)))
		return (error);

	if (fmp->sess_init) {
		fmp->sess_init = 0;
		fbuf = fb_setup(0, 0, FBT_DESTROY, p);

		error = fb_queue(fmp->dev, fbuf);

		if (error)
			printf("fusefs: error %d on destroy\n", error);

		fb_delete(fbuf);
	}

	fuse_device_cleanup(fmp->dev, NULL);
	fuse_device_set_fmp(fmp, 0);
	free(fmp, M_FUSEFS, 0);
	mp->mnt_data = NULL;

	return (0);
}

int
fusefs_root(struct mount *mp, struct vnode **vpp)
{
	struct vnode *nvp;
	int error;

	if ((error = VFS_VGET(mp, FUSE_ROOTINO, &nvp)) != 0)
		return (error);

	nvp->v_type = VDIR;

	*vpp = nvp;
	return (0);
}

int
fusefs_quotactl(struct mount *mp, int cmds, uid_t uid, caddr_t arg,
    struct proc *p)
{
	return (EOPNOTSUPP);
}

int
fusefs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	struct fusefs_mnt *fmp;
	struct fusebuf *fbuf;
	int error;

	fmp = VFSTOFUSEFS(mp);

	copy_statfs_info(sbp, mp);

	if (fmp->sess_init) {
		fbuf = fb_setup(0, FUSE_ROOTINO, FBT_STATFS, p);

		error = fb_queue(fmp->dev, fbuf);

		if (error) {
			fb_delete(fbuf);
			return (error);
		}

		sbp->f_bavail = fbuf->fb_stat.f_bavail;
		sbp->f_bfree = fbuf->fb_stat.f_bfree;
		sbp->f_blocks = fbuf->fb_stat.f_blocks;
		sbp->f_files = fbuf->fb_stat.f_files;
		sbp->f_ffree = fbuf->fb_stat.f_ffree;
		sbp->f_favail = fbuf->fb_stat.f_favail;
		sbp->f_bsize = fbuf->fb_stat.f_frsize;
		sbp->f_iosize = fbuf->fb_stat.f_bsize;
		sbp->f_namemax = fbuf->fb_stat.f_namemax;
		fb_delete(fbuf);
	} else {
		sbp->f_bavail = 0;
		sbp->f_bfree = 0;
		sbp->f_blocks = 0;
		sbp->f_ffree = 0;
		sbp->f_favail = 0;
		sbp->f_files = 0;
		sbp->f_bsize = 0;
		sbp->f_iosize = 0;
		sbp->f_namemax = 0;
	}

	return (0);
}

int
fusefs_sync(struct mount *mp, int waitfor, struct ucred *cred,
    struct proc *p)
{
	return (0);
}

int
fusefs_vget(struct mount *mp, ino_t ino, struct vnode **vpp)
{
	struct fusefs_mnt *fmp;
	struct fusefs_node *ip;
	struct vnode *nvp;
	int i;
	int error;
retry:
	fmp = VFSTOFUSEFS(mp);
	/*
	 * check if vnode is in hash.
	 */
	if ((*vpp = ufs_ihashget(fmp->dev, ino)) != NULLVP)
		return (0);

	/*
	 * if not create it
	 */
	if ((error = getnewvnode(VT_FUSEFS, mp, &fusefs_vops, &nvp)) != 0) {
		printf("fusefs: getnewvnode error\n");
		*vpp = NULLVP;
		return (error);
	}

	ip = malloc(sizeof(*ip), M_FUSEFS, M_WAITOK | M_ZERO);
	rrw_init_flags(&ip->ufs_ino.i_lock, "fuseinode", RWL_DUPOK);
	nvp->v_data = ip;
	ip->ufs_ino.i_vnode = nvp;
	ip->ufs_ino.i_dev = fmp->dev;
	ip->ufs_ino.i_number = ino;

	for (i = 0; i < FUFH_MAXTYPE; i++)
		ip->fufh[i].fh_type = FUFH_INVALID;

	error = ufs_ihashins(&ip->ufs_ino);
	if (error) {
		vrele(nvp);

		if (error == EEXIST)
			goto retry;

		return (error);
	}

	ip->ufs_ino.i_ump = (struct ufsmount *)fmp;

	if (ino == FUSE_ROOTINO)
		nvp->v_flag |= VROOT;

	*vpp = nvp;

	return (0);
}

int
fusefs_fhtovp(struct mount *mp, struct fid *fhp, struct vnode **vpp)
{
	return (EINVAL);
}

int
fusefs_vptofh(struct vnode *vp, struct fid *fhp)
{
	return (EINVAL);
}

int
fusefs_init(struct vfsconf *vfc)
{
	pool_init(&fusefs_fbuf_pool, sizeof(struct fusebuf), 0, 0, PR_WAITOK,
	    "fmsg", NULL);

	return (0);
}

int
fusefs_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen, struct proc *p)
{
	extern int stat_fbufs_in, stat_fbufs_wait, stat_opened_fusedev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case FUSEFS_OPENDEVS:
		return (sysctl_rdint(oldp, oldlenp, newp,
		    stat_opened_fusedev));
	case FUSEFS_INFBUFS:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_fbufs_in));
	case FUSEFS_WAITFBUFS:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_fbufs_wait));
	case FUSEFS_POOL_NBPAGES:
		return (sysctl_rdint(oldp, oldlenp, newp,
		    fusefs_fbuf_pool.pr_npages));
	default:
		return (EOPNOTSUPP);
	}
}

int
fusefs_checkexp(struct mount *mp, struct mbuf *nam, int *extflagsp,
    struct ucred **credanonp)
{
	return (EOPNOTSUPP);
}
@


1.28
log
@Fix fuse node lookups. Currently fusefs nodes in the kernel remember the
parent inode number for ".." lookups. This only works until the kernel
starts to reuse vnodes and the parent's vnode is reclaimed and the ino
to path mapping is removed from the userland process by libfuse. Fix
this by using reference counting in libfuse, so that parent mapping are
retained as long as a child uses them. Also, don't free the root node.

This commit resolves following issue:

$ doas fuse-zip ~/Downloads/foo.zip /mnt
$ ls /mnt
openbsd-www
$ grep -IR foo /usr/src > /dev/null	# force vfs to reclaim vnodes
$ ls /mnt
ls: /mnt: No such file or directory
$

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.27 2016/08/30 16:45:54 natano Exp $ */
d271 1
a271 1
	rrw_init(&ip->ufs_ino.i_lock, "fuseinode");
@


1.27
log
@Use struct stat for storing attributes in fusebufs, because using struct
vattr in userspace is suboptimal as some related helpers are not
available, e.g. VATTR_NULL() and IFTOVT(). The conversion is now done in
the kernel where it belongs. As a side effect the <sys/vnode.h> include
can be removed from libfuse.

tweaks and ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.26 2016/08/15 07:39:46 natano Exp $ */
a275 1
	ip->parent = 0;
@


1.26
log
@Neuter fuse_vptofh() and fuse_fhtovp(). I implemented those functions
under the assumption, that fuse_vget() has reasonable semantics, while
this is not the case. fusefs_vget() only functions correctly, if the
file in questions has recently been accessed and is still in the vnode
cache of the userspace daemon associated with the mount point.

As a matter of fact the fuse api doesn't feature a reasonable way to map
inode numbers to a handle at all (see struct fuse_operations).

ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.25 2016/08/13 11:42:46 natano Exp $ */
d27 1
@


1.25
log
@Kill FUSE_ROOT_ID and use FUSE_ROOTINO instead. Also, remove one (ino_t)
cast from FUSE_ROOTINO, as it is already included in the #define.

ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.24 2016/08/12 20:18:44 natano Exp $ */
d303 1
a303 8
	struct ufid *ufhp;

	ufhp = (struct ufid *)fhp;
	if (ufhp->ufid_len != sizeof(struct ufid) ||
	    ufhp->ufid_ino < FUSE_ROOTINO)
		return (ESTALE);

	return (VFS_VGET(mp, ufhp->ufid_ino, vpp));
d309 1
a309 9
	struct fusefs_node *ip;
	struct ufid *ufhp;

	ip = VTOI(vp);
	ufhp = (struct ufid *)fhp;
	ufhp->ufid_len = sizeof(struct ufid);
	ufhp->ufid_ino = ip->ufs_ino.i_number;

	return (0);
@


1.24
log
@Dedup vnode type information. Fuse stores the vnode type in two places:
vtype in struct fusefs_node and v_type in struct vnode. Given the fact,
that fusefs_node structs are never allocated without an associated vnode
and those two fields are always in sync, one of those locations is
superfluous.

While there remove the unused nlookup field.

ok mpi
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.23 2016/06/19 11:54:33 natano Exp $ */
d175 1
a175 1
	if ((error = VFS_VGET(mp, (ino_t)FUSE_ROOTINO, &nvp)) != 0)
d203 1
a203 1
		fbuf = fb_setup(0, FUSE_ROOT_ID, FBT_STATFS, p);
@


1.23
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.22 2016/05/26 16:03:29 natano Exp $ */
a172 1
	struct fusefs_node *ip;
a177 1
	ip = VTOI(nvp);
a178 1
	ip->vtype = VDIR;
@


1.22
log
@The doforce variable isn't modified anywhere. Also, the only filesystem
left using it is fuse. It has been removed from all other filesystems.

ok millert deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.21 2016/04/26 18:37:02 natano Exp $ */
d273 1
a273 1
	lockinit(&ip->ufs_ino.i_lock, PINOD, "fuseinode", 0, 0);
@


1.21
log
@Populate all necessary statfs members in .vfs_statfs. cd9660, udf,
msdosfs and nfsv2 don't set f_namemax. ntfs and ext2fs don't set
f_namemeax and f_favail. fusefs doesn't set f_mntfromspec, f_favail and
f_iosize. Also, make all filesystems use copy_statfs_info(), so that all
statfs information is filled in correctly for the (sb != &mp->mnt-stat)
case.

ok stefan
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.20 2016/03/27 11:39:37 bluhm Exp $ */
a137 1
	extern int doforce;
d143 1
a143 5
	if (mntflags & MNT_FORCE) {
		/* fusefs can never be rootfs so don't check for it */
		if (!doforce)
			return (EINVAL);

a144 1
	}
@


1.20
log
@When pulling and unmounting an umass USB stick, the file system
could end up in an inconsistent state.  The fstype dependent
mp->mnt_data was NULL, but the general mp was still listed as a
valid mount point.  Next access to the file system would crash with
a NULL pointer dereference.
If closing the device fails, the mount point must go away anyway.
There is nothing we can do about it.  Remove the workaround for the
EIO error in the general unmount code, but do not generate any error
in the file system specific unmount functions.
OK natano@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.19 2016/03/17 18:52:31 bluhm Exp $ */
d114 3
a116 1
	bcopy("fusefs", mp->mnt_stat.f_mntfromname, sizeof("fusefs"));
d209 2
d226 1
d228 1
d236 1
d239 1
@


1.19
log
@Set mnt_data to NULL after freeing the file system specific mount point.
OK krw@@ natano@@ as part of a larger diff
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.18 2016/02/25 19:07:45 natano Exp $ */
d170 1
a170 1
	return (error);
@


1.18
log
@Replace a usage of ROOTINO ((ufsino_t)2 with FUSE_ROOTINO ((ino_t)1).

The FUSE_ROOTINO define is used everywhere else in fuse, so the mismatch
caused a file handle for the filesystem root to be falsely rejected with
ESTALE.

ok stefan@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.17 2016/02/25 18:59:26 natano Exp $ */
d168 1
@


1.17
log
@fuse doesn't support NFS; prevent a uvm fault caused by claiming otherwise

ok stefan@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.16 2015/07/19 14:21:14 tedu Exp $ */
d307 1
a307 1
	    ufhp->ufid_ino < ROOTINO)
@


1.16
log
@basic fh functions. better than panicing!
from Martin Natano
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.15 2014/12/23 04:54:45 tedu Exp $ */
d366 1
a366 1
	return (0);
@


1.15
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.14 2014/12/23 04:53:20 tedu Exp $ */
d303 8
a310 1
	return (0);
d316 8
@


1.14
log
@convert from nointr to waitok
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.13 2014/12/16 18:30:04 tedu Exp $ */
d190 2
a191 1
int fusefs_quotactl(struct mount *mp, int cmds, uid_t uid, caddr_t arg,
d197 2
a198 1
int fusefs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
d237 2
a238 1
int fusefs_sync(struct mount *mp, int waitfor, struct ucred *cred,
d244 2
a245 1
int fusefs_vget(struct mount *mp, ino_t ino, struct vnode **vpp)
d300 2
a301 1
int fusefs_fhtovp(struct mount *mp, struct fid *fhp, struct vnode **vpp)
d306 2
a307 1
int fusefs_vptofh(struct vnode *vp, struct fid *fhp)
d312 2
a313 1
int fusefs_init(struct vfsconf *vfc)
d321 2
a322 1
int fusefs_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
d347 2
a348 1
int fusefs_checkexp(struct mount *mp, struct mbuf *nam, int *extflagsp,
@


1.13
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.12 2014/10/03 18:53:13 tedu Exp $ */
d308 2
a309 2
	pool_init(&fusefs_fbuf_pool, sizeof(struct fusebuf), 0, 0, 0,
	    "fmsg", &pool_allocator_nointr);
@


1.12
log
@EOPNOTSUPP for quotactl. from Martin Natano
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.11 2014/07/12 18:43:52 tedu Exp $ */
d19 1
@


1.11
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.10 2014/06/04 18:52:53 syl Exp $ */
d192 1
a192 1
	return (0);
@


1.10
log
@In fusefs_unmount() we need to send the FBT_DESTROY fusebuf only if
vflush(9) succeed.

Problem reported by Helg Bredow.
OK sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.9 2014/05/20 13:32:22 syl Exp $ */
d166 1
a166 1
	free(fmp, M_FUSEFS);
@


1.9
log
@Add -o max_read=XXX support in fuse. This is needed by usmb to have a
working read() and write().

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.8 2013/12/10 13:43:05 pelikan Exp $ */
d141 11
a162 11

	if (mntflags & MNT_FORCE) {
		/* fusefs can never be rootfs so don't check for it */
		if (!doforce)
			return (EINVAL);

		flags |= FORCECLOSE;
	}

	if ((error = vflush(mp, 0, flags)))
		return (error);
@


1.8
log
@Unset fuse_mnt in fusefs_unmount after vflushing and freeing fbufs in use.

This way, if fuse unmounts a FS without FBT_DESTROY, the fuse_mnt pointer
is already invalidated.  Also, on weird unmount situations with vnodes in
use, vflush() them before doing fuse_device_cleanup().

Tested with ntfs-3g, ok syl@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.7 2013/10/07 18:25:32 syl Exp $ */
d101 5
a106 1

@


1.7
log
@use printf(9) consistently in FUSE
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.6 2013/10/07 18:15:21 syl Exp $ */
d111 1
a111 1
	fuse_device_set_fmp(fmp);
d144 1
a144 1
			printf("fusefs: error from fuse\n");
a148 2
	fuse_device_cleanup(fmp->dev, NULL);

d160 2
@


1.6
log
@Introduce fb_delete() helper and use it in FUSE code.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.5 2013/06/21 21:30:38 syl Exp $ */
d144 1
a144 1
			printf("error from fuse\n");
d255 1
a255 1
		printf("fuse: getnewvnode error\n");
@


1.5
log
@Make fuse device clonable.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.4 2013/06/12 22:55:02 tedu Exp $ */
a141 1
		pool_put(&fusefs_fbuf_pool, fbuf);
d145 2
a146 2
	} else {
		fuse_device_cleanup(fmp->dev, NULL);
d149 2
d205 1
a205 1
			pool_put(&fusefs_fbuf_pool, fbuf);
d216 1
a216 1
		pool_put(&fusefs_fbuf_pool, fbuf);
@


1.4
log
@remove extra whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.3 2013/06/09 12:51:40 tedu Exp $ */
d19 2
d24 2
d76 2
d87 10
d100 1
a100 1
	fmp->dev = args.dev;
@


1.3
log
@move fuse sysctl defines up and add _KERNEL. from Sylvestre Gallon
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.2 2013/06/04 20:52:54 tedu Exp $ */
a121 1

a129 1

@


1.2
log
@delete a printf, from sylvestre
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_vfsops.c,v 1.1 2013/06/03 15:50:56 tedu Exp $ */
d304 1
a304 1
	case FUSEFS_NB_OPENDEVS:
@


1.1
log
@add a bunch of files for ISC-licensed FUSE support. ok beck deraadt
from Sylvestre Gallon ccna.syl gmail.com. Many thanks to Sylvestre for
all the hard work.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a84 1
	printf("fusefs: mount dev %i\n", fmp->dev);
@

