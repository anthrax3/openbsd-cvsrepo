head	1.20;
access;
symbols
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.14
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.12
	OPENBSD_2_8:1.12.0.10
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.6
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2005.05.26.00.38.50;	author pedro;	state dead;
branches;
next	1.19;

1.19
date	2003.10.24.19.13.22;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.12.23.39.14;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.12.21.02.10;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.23.03.07.22;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.04.22.44.32;	author art;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.01.11.05.12.27;	author millert;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	98.08.06.23.06.20;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	98.08.06.19.34.50;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.05.58.49;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.20.20.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.15.19.15;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	96.05.29.07.12.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.30.01.40.50;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.25.18.02.58;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.13.08.07;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.26.07.20.12;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.03;	author deraadt;	state Exp;
branches;
next	;

1.12.6.1
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.12.6.4;

1.12.6.4
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.12.6.5;

1.12.6.5
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.12.6.6;

1.12.6.6
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.11.03.30.21;	author art;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2003.05.19.22.36.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@bye bye, rest in attic ad infinitum, amen
@
text
@/*	$OpenBSD: umap_vnops.c,v 1.19 2003/10/24 19:13:22 tedu Exp $ */
/*	$NetBSD: umap_vnops.c,v 1.22 2002/01/04 07:19:34 chs Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software donated to Berkeley by
 * the UCLA Ficus project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)umap_vnops.c	8.6 (Berkeley) 5/22/95
 */

/*
 * Umap Layer
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <miscfs/umapfs/umap.h>
#include <miscfs/genfs/layer_extern.h>

int	umap_lookup(void *);
int	umap_getattr(void *);
int	umap_print(void *);
int	umap_rename(void *);

/*
 * Global vfs data structures
 */
/*
 * XXX - strategy, bwrite are hand coded currently.  They should
 * go away with a merged buffer/block cache.
 *
 */
int (**umapfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc umapfs_vnodeop_entries[] = {
	{ &vop_default_desc,	umap_bypass },

	{ &vop_lookup_desc,	umap_lookup },
	{ &vop_getattr_desc,	umap_getattr },
	{ &vop_print_desc,	umap_print },
	{ &vop_rename_desc,	umap_rename },

	{ &vop_lock_desc,	layer_lock },
	{ &vop_unlock_desc,	layer_unlock },
	{ &vop_islocked_desc,	layer_islocked },
	{ &vop_fsync_desc,	layer_fsync },
	{ &vop_inactive_desc,	layer_inactive },
	{ &vop_reclaim_desc,	layer_reclaim },
	{ &vop_open_desc,	layer_open },
	{ &vop_setattr_desc,	layer_setattr },
	{ &vop_access_desc,	layer_access },

	{ &vop_strategy_desc,	layer_strategy },
	{ &vop_bwrite_desc,	layer_bwrite },
	{ &vop_bmap_desc,	layer_bmap },
	{ NULL, NULL }
};
const struct vnodeopv_desc umapfs_vnodeop_opv_desc =
	{ &umapfs_vnodeop_p, umapfs_vnodeop_entries };

/*
 * This is the 08-June-1999 bypass routine.
 * See layer_vnops.c:layer_bypass for more details.
 */ 
int
umap_bypass(v)
	void *v;
{
	struct vop_generic_args /* {
		struct vnodeop_desc *a_desc;
		<other random data follows, presumably>
	} */ *ap = v;
	struct ucred **credpp = 0, *credp = 0;
	struct ucred *savecredp = 0, *savecompcredp = 0;
	struct ucred *compcredp = 0;
	struct vnode **this_vp_p;
	int error, error1;
	int (**our_vnodeop_p)(void *);
	struct vnode *old_vps[VDESC_MAX_VPS], *vp0;
	struct vnode **vps_p[VDESC_MAX_VPS];
	struct vnode ***vppp;
	struct vnodeop_desc *descp = ap->a_desc;
	int reles, i, flags;
	struct componentname **compnamepp = 0;

#ifdef SAFETY
	/*
	 * We require at least one vp.
	 */
	if (descp->vdesc_vp_offsets == NULL ||
	    descp->vdesc_vp_offsets[0] == VDESC_NO_OFFSET)
		panic("umap_bypass: no vp's in map");
#endif
	vps_p[0] = VOPARG_OFFSETTO(struct vnode**,descp->vdesc_vp_offsets[0],
				ap);
	vp0 = *vps_p[0];
	flags = MOUNTTOUMAPMOUNT(vp0->v_mount)->umapm_flags;
	our_vnodeop_p = vp0->v_op;

	if (flags & LAYERFS_MBYPASSDEBUG)
		printf("umap_bypass: %s\n", descp->vdesc_name);

	/*
	 * Map the vnodes going in.
	 * Later, we'll invoke the operation based on
	 * the first mapped vnode's operation vector.
	 */
	reles = descp->vdesc_flags;
	for (i = 0; i < VDESC_MAX_VPS; reles >>= 1, i++) {
		if (descp->vdesc_vp_offsets[i] == VDESC_NO_OFFSET)
			break;   /* bail out at end of list */
		vps_p[i] = this_vp_p = 
			VOPARG_OFFSETTO(struct vnode**, descp->vdesc_vp_offsets[i], ap);

		/*
		 * We're not guaranteed that any but the first vnode
		 * are of our type.  Check for and don't map any
		 * that aren't.  (Must map first vp or vclean fails.)
		 */

		if (i && ((*this_vp_p)==NULL ||
		    (*this_vp_p)->v_op != our_vnodeop_p)) {
			old_vps[i] = NULL;
		} else {
			old_vps[i] = *this_vp_p;
			*(vps_p[i]) = UMAPVPTOLOWERVP(*this_vp_p);
			if (reles & 1)
				VREF(*this_vp_p);
		}
			
	}

	/*
	 * Fix the credentials.  (That's the purpose of this layer.)
	 */

	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET) {

		credpp = VOPARG_OFFSETTO(struct ucred**, 
		    descp->vdesc_cred_offset, ap);

		/* Save old values */

		savecredp = *credpp;
		if (savecredp != NOCRED)
			*credpp = crdup(savecredp);
		credp = *credpp;

		if ((flags & LAYERFS_MBYPASSDEBUG) && credp->cr_uid != 0)
			printf("umap_bypass: user was %d, group %d\n", 
			    credp->cr_uid, credp->cr_gid);

		/* Map all ids in the credential structure. */

		umap_mapids(vp0->v_mount, credp);

		if ((flags & LAYERFS_MBYPASSDEBUG) && credp->cr_uid != 0)
			printf("umap_bypass: user now %d, group %d\n", 
			    credp->cr_uid, credp->cr_gid);
	}

	/* BSD often keeps a credential in the componentname structure
	 * for speed.  If there is one, it better get mapped, too. 
	 */

	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET) {

		compnamepp = VOPARG_OFFSETTO(struct componentname**, 
		    descp->vdesc_componentname_offset, ap);

		savecompcredp = (*compnamepp)->cn_cred;
		if (savecompcredp != NOCRED)
			(*compnamepp)->cn_cred = crdup(savecompcredp);
		compcredp = (*compnamepp)->cn_cred;

		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_bypass: component credit user was %d, group %d\n", 
			    compcredp->cr_uid, compcredp->cr_gid);

		/* Map all ids in the credential structure. */

		umap_mapids(vp0->v_mount, compcredp);

		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_bypass: component credit user now %d, group %d\n", 
			    compcredp->cr_uid, compcredp->cr_gid);
	}

	/*
	 * Call the operation on the lower layer
	 * with the modified argument structure.
	 */
	error = VCALL(*(vps_p[0]), descp->vdesc_offset, ap);

	/*
	 * Maintain the illusion of call-by-value
	 * by restoring vnodes in the argument structure
	 * to their original value.
	 */
	reles = descp->vdesc_flags;
	for (i = 0; i < VDESC_MAX_VPS; reles >>= 1, i++) {
		if (descp->vdesc_vp_offsets[i] == VDESC_NO_OFFSET)
			break;   /* bail out at end of list */
		if (old_vps[i]) {
			*(vps_p[i]) = old_vps[i];
			if (reles & VDESC_VP0_WILLUNLOCK)
				LAYERFS_UPPERUNLOCK(*(vps_p[i]), 0, error1);
			if (reles & VDESC_VP0_WILLRELE)
				vrele(*(vps_p[i]));
		}
	}

	/*
	 * Map the possible out-going vpp
	 * (Assumes that the lower layer always returns
	 * a VREF'ed vpp unless it gets an error.)
	 */
	if (descp->vdesc_vpp_offset != VDESC_NO_OFFSET &&
	    !(descp->vdesc_flags & VDESC_NOMAP_VPP) &&
	    !error) {
		if (descp->vdesc_flags & VDESC_VPP_WILLRELE)
			goto out;
		vppp = VOPARG_OFFSETTO(struct vnode***,
				 descp->vdesc_vpp_offset, ap);
		error = layer_node_create(old_vps[0]->v_mount, **vppp, *vppp);
	}

 out:
	/* 
	 * Free duplicate cred structure and restore old one.
	 */
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET) {
		if ((flags & LAYERFS_MBYPASSDEBUG) && credp &&
					credp->cr_uid != 0)
			printf("umap_bypass: returning-user was %d\n",
			    credp->cr_uid);

		if (savecredp != NOCRED) {
			crfree(credp);
			*credpp = savecredp;
			if ((flags & LAYERFS_MBYPASSDEBUG) && credpp &&
					(*credpp)->cr_uid != 0)
			 	printf("umap_bypass: returning-user now %d\n\n", 
				    savecredp->cr_uid);
		}
	}

	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET) {
		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp &&
					compcredp->cr_uid != 0)
			printf("umap_bypass: returning-component-user was %d\n", 
			    compcredp->cr_uid);

		if (savecompcredp != NOCRED) {
			crfree(compcredp);
			(*compnamepp)->cn_cred = savecompcredp;
			if ((flags & LAYERFS_MBYPASSDEBUG) && savecompcredp &&
					savecompcredp->cr_uid != 0)
			 	printf("umap_bypass: returning-component-user now %d\n", 
				    savecompcredp->cr_uid);
		}
	}

	return (error);
}

/*
 * This is based on the 08-June-1999 bypass routine.
 * See layer_vnops.c:layer_bypass for more details.
 */ 
int
umap_lookup(v)
	void *v;
{
	struct vop_lookup_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct ucred *savecompcredp = NULL;
	struct ucred *compcredp = NULL;
	struct vnode *dvp, *vp, *ldvp;
	struct mount *mp;
	int error;
	int i, flags, cnf = cnp->cn_flags;

	dvp = ap->a_dvp;
	mp = dvp->v_mount;

	if ((cnf & ISLASTCN) && (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
		(cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

	flags = MOUNTTOUMAPMOUNT(mp)->umapm_flags;
	ldvp = UMAPVPTOLOWERVP(dvp);

	if (flags & LAYERFS_MBYPASSDEBUG)
		printf("umap_lookup\n");

	/*
	 * Fix the credentials.  (That's the purpose of this layer.)
	 *
	 * BSD often keeps a credential in the componentname structure
	 * for speed.  If there is one, it better get mapped, too. 
	 */

	if ((savecompcredp = cnp->cn_cred)) {
		compcredp = crdup(savecompcredp);
		cnp->cn_cred = compcredp;

		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_lookup: component credit user was %d, group %d\n", 
			    compcredp->cr_uid, compcredp->cr_gid);

		/* Map all ids in the credential structure. */
		umap_mapids(mp, compcredp);
	}

	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_lookup: component credit user now %d, group %d\n", 
		    compcredp->cr_uid, compcredp->cr_gid);

	ap->a_dvp = ldvp;
	error = VCALL(ldvp, ap->a_desc->vdesc_offset, ap);
	vp = *ap->a_vpp;

	if (error == EJUSTRETURN && (cnf & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME))
		error = EROFS;

	/* Do locking fixup as appropriate. See layer_lookup() for info */
	if ((cnp->cn_flags & PDIRUNLOCK)) {
		LAYERFS_UPPERUNLOCK(dvp, 0, i);
	}
	if (ldvp == vp) {
		*ap->a_vpp = dvp;
		VREF(dvp);
		vrele(vp);
	} else if (vp != NULL) {
		error = layer_node_create(mp, vp, ap->a_vpp);
	}

	/* 
	 * Free duplicate cred structure and restore old one.
	 */
	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp &&
					compcredp->cr_uid != 0)
		printf("umap_lookup: returning-component-user was %d\n", 
			    compcredp->cr_uid);

	if (savecompcredp != NOCRED) {
		crfree(compcredp);
		cnp->cn_cred = savecompcredp;
		if ((flags & LAYERFS_MBYPASSDEBUG) && savecompcredp &&
				savecompcredp->cr_uid != 0)
		 	printf("umap_lookup: returning-component-user now %d\n", 
			    savecompcredp->cr_uid);
	}

	return (error);
}

/*
 *  We handle getattr to change the fsid.
 */
int
umap_getattr(v)
	void *v;
{
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	uid_t uid;
	gid_t gid;
	int error, tmpid, unentries, gnentries, flags;
	u_long (*umapdata)[2];
	u_long (*gmapdata)[2];
	struct vnode **vp1p;
	const struct vnodeop_desc *descp = ap->a_desc;

	if ((error = umap_bypass(ap)) != 0)
		return (error);
	/* Requires that arguments be restored. */
	ap->a_vap->va_fsid = ap->a_vp->v_mount->mnt_stat.f_fsid.val[0];

	flags = MOUNTTOUMAPMOUNT(ap->a_vp->v_mount)->umapm_flags;
	/*
	 * Umap needs to map the uid and gid returned by a stat
	 * into the proper values for this site.  This involves
	 * finding the returned uid in the mapping information,
	 * translating it into the uid on the other end,
	 * and filling in the proper field in the vattr
	 * structure pointed to by ap->a_vap.  The group
	 * is easier, since currently all groups will be
	 * translate to the NULLGROUP.
	 */

	/* Find entry in map */

	uid = ap->a_vap->va_uid;
	gid = ap->a_vap->va_gid;
	if ((flags & LAYERFS_MBYPASSDEBUG))
		printf("umap_getattr: mapped uid = %d, mapped gid = %d\n", uid, 
		    gid);

	vp1p = VOPARG_OFFSETTO(struct vnode**, descp->vdesc_vp_offsets[0], ap);
	unentries =  MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_unentries;
	umapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_umapdata);
	gnentries =  MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_gnentries;
	gmapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_gmapdata);

	/* Reverse map the uid for the vnode.  Since it's a reverse
		map, we can't use umap_mapids() to do it. */

	tmpid = umap_reverse_findid(uid, umapdata, unentries);

	if (tmpid != -1) {
		ap->a_vap->va_uid = (uid_t) tmpid;
		if ((flags & LAYERFS_MBYPASSDEBUG))
			printf("umap_getattr: original uid = %d\n", uid);
	} else 
		ap->a_vap->va_uid = (uid_t) NOBODY;

	/* Reverse map the gid for the vnode. */

	tmpid = umap_reverse_findid(gid, gmapdata, gnentries);

	if (tmpid != -1) {
		ap->a_vap->va_gid = (gid_t) tmpid;
		if ((flags & LAYERFS_MBYPASSDEBUG))
			printf("umap_getattr: original gid = %d\n", gid);
	} else
		ap->a_vap->va_gid = (gid_t) NULLGROUP;
	
	return (0);
}

int
umap_print(v)
	void *v;
{
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	printf("\ttag VT_UMAPFS, vp=%p, lowervp=%p\n", vp,
	    UMAPVPTOLOWERVP(vp));
	return (0);
}

int
umap_rename(v)
	void *v;
{
	struct vop_rename_args  /* {
		struct vnode *a_fdvp;
		struct vnode *a_fvp;
		struct componentname *a_fcnp;
		struct vnode *a_tdvp;
		struct vnode *a_tvp;
		struct componentname *a_tcnp;
	} */ *ap = v;
	int error, flags;
	struct componentname *compnamep;
	struct ucred *compcredp, *savecompcredp;
	struct vnode *vp;

	/*
	 * Rename is irregular, having two componentname structures.
	 * We need to map the cre in the second structure,
	 * and then bypass takes care of the rest.
	 */

	vp = ap->a_fdvp;
	flags = MOUNTTOUMAPMOUNT(vp->v_mount)->umapm_flags;
	compnamep = ap->a_tcnp;
	compcredp = compnamep->cn_cred;

	savecompcredp = compcredp;
	compcredp = compnamep->cn_cred = crdup(savecompcredp);

	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_rename: rename component credit user was %d, group %d\n", 
		    compcredp->cr_uid, compcredp->cr_gid);

	/* Map all ids in the credential structure. */

	umap_mapids(vp->v_mount, compcredp);

	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_rename: rename component credit user now %d, group %d\n", 
		    compcredp->cr_uid, compcredp->cr_gid);

	error = umap_bypass(ap);
	
	/* Restore the additional mapped componentname cred structure. */

	crfree(compcredp);
	compnamep->cn_cred = savecompcredp;

	return error;
}
@


1.19
log
@style(9)ed panics, from tom cosgrove.
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.18 2003/06/02 23:28:11 millert Exp $ */
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.17 2003/05/12 23:39:14 tedu Exp $ */
d125 1
a125 1
		panic ("umap_bypass: no vp's in map.\n");
@


1.17
log
@mapdata -> umapdata like it was before
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.16 2003/05/12 21:02:10 tedu Exp $ */
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@umapfs uses the new layer stuff now too.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d419 1
a419 1
	u_long (*mapdata)[2];
d451 1
a451 1
	mapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_umapdata);
d458 1
a458 1
	tmpid = umap_reverse_findid(uid, mapdata, unentries);
@


1.15
log
@uid_t and gid_t are unsigned
@
text
@d1 2
a2 2
/*	$OpenBSD: umap_vnops.c,v 1.14 2002/03/14 01:27:08 millert Exp $	*/
/*	$NetBSD: umap_vnops.c,v 1.5.4.1 1996/05/25 22:13:35 jtc Exp $	*/
d39 1
a39 1
 *	@@(#)umap_vnops.c	8.3 (Berkeley) 1/5/94
d46 1
a49 1
#include <sys/types.h>
a54 1
#include <miscfs/nullfs/null.h>
d56 1
d58 1
a58 4

int umap_bug_bypass = 0;   /* for debugging: enables bypass printf'ing */

int	umap_bypass(void *);
a59 2
int	umap_inactive(void *);
int	umap_reclaim(void *);
a61 4
int	umap_strategy(void *);
int	umap_bwrite(void *);
int	umap_unlock(void *);
int	umap_lock(void *);
d71 22
a92 14
int (**umap_vnodeop_p)(void *);
struct vnodeopv_entry_desc umap_vnodeop_entries[] = {
	{ &vop_default_desc, umap_bypass },

	{ &vop_getattr_desc, umap_getattr },
	{ &vop_inactive_desc, umap_inactive },
	{ &vop_reclaim_desc, umap_reclaim },
	{ &vop_print_desc, umap_print },
	{ &vop_rename_desc, umap_rename },
	{ &vop_lock_desc, umap_lock },
	{ &vop_unlock_desc, umap_unlock },
	{ &vop_strategy_desc, umap_strategy },
	{ &vop_bwrite_desc, umap_bwrite },

d95 2
a96 2
struct vnodeopv_desc umap_vnodeop_opv_desc =
	{ &umap_vnodeop_p, umap_vnodeop_entries };
d99 2
a100 2
 * This is the 10-Apr-92 bypass routine.
 * See null_vnops.c:null_bypass for more details.
d114 3
a116 3
	int error = 0;
	struct vnode *old_vps[VDESC_MAX_VPS];
	struct vnode *vp1 = 0;
d120 1
a120 1
	int reles, i;
a122 3
	if (umap_bug_bypass)
		printf ("umap_bypass: %s\n", descp->vdesc_name);

d129 1
a129 1
		panic ("umap_bypass: no vp's in map.");
d131 8
a151 4
		if (i == 0) {
			vp1 = *vps_p[0];
		}

d158 2
a159 2
		if (i && (*this_vp_p == NULLVP ||
		    (*this_vp_p)->v_op != umap_vnodeop_p)) {
d174 4
a177 3
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET
	    && *(credpp = VOPARG_OFFSETTO(struct ucred**, 
		    descp->vdesc_cred_offset, ap)) != NOCRED ) {
d182 2
a183 1
		*credpp = crdup(savecredp);
d186 2
a187 2
		if (umap_bug_bypass && credp->cr_uid != 0)
			printf("umap_bypass: user was %u, group %u\n", 
d192 1
a192 1
		umap_mapids(vp1->v_mount, credp);
d194 2
a195 2
		if (umap_bug_bypass && credp->cr_uid != 0)
			printf("umap_bypass: user now %u, group %u\n", 
d203 4
a206 3
	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET
	   && (*(compnamepp = VOPARG_OFFSETTO(struct componentname**, 
		    descp->vdesc_componentname_offset, ap)))->cn_cred != NOCRED ) {
d209 2
a210 1
		(*compnamepp)->cn_cred = crdup(savecompcredp);
d213 2
a214 2
		if (umap_bug_bypass && compcredp->cr_uid != 0)
			printf("umap_bypass: component credit user was %u, group %u\n", 
d219 1
a219 1
		umap_mapids(vp1->v_mount, compcredp);
d221 2
a222 2
		if (umap_bug_bypass && compcredp->cr_uid != 0)
			printf("umap_bypass: component credit user now %u, group %u\n", 
d241 1
a241 1
		if (old_vps[i] != NULLVP) {
d243 3
a245 1
			if (reles & 1)
d247 2
a248 2
		};
	};
d258 40
a297 5
		if (!(descp->vdesc_flags & VDESC_VPP_WILLRELE)) {
			vppp = VOPARG_OFFSETTO(struct vnode***,
				descp->vdesc_vpp_offset, ap);
			error = umap_node_create(old_vps[0]->v_mount,
				**vppp, *vppp);
d301 82
d386 4
a389 18
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET
	    && *credpp != NOCRED) {
		if (umap_bug_bypass && credp && credp->cr_uid != 0)
			printf("umap_bypass: returning-user was %u\n",
					credp->cr_uid);

		crfree(credp);
		*credpp = savecredp;
		if (umap_bug_bypass && credpp && (*credpp)->cr_uid != 0)
		 	printf("umap_bypass: returning-user now %u\n\n", 
			    savecredp->cr_uid);
	}

	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET
	    && savecompcredp != NOCRED ) {
		if (umap_bug_bypass && compcredp && compcredp->cr_uid != 0)
			printf("umap_bypass: returning-component-user was %u\n", 
				compcredp->cr_uid);
d391 1
d393 4
a396 3
		(*compnamepp)->cn_cred = savecompcredp;
		if (umap_bug_bypass && credpp && (*credpp)->cr_uid != 0)
		 	printf("umap_bypass: returning-component-user now %u\n", 
a402 1

d416 7
a422 6
	uid_t	uid;
	gid_t	gid;
	int	error, tmpid, unentries, gnentries;
	id_map_t	umapdata, gmapdata;
	struct vnode	**vp1p;
	struct vnodeop_desc	*descp = ap->a_desc;
d429 1
d445 2
a446 2
	if (umap_bug_bypass)
		printf("umap_getattr: mapped uid = %u, mapped gid = %u\n", uid, 
d451 1
a451 1
	umapdata  = (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_umapdata);
d453 1
a453 1
	gmapdata  = (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_gmapdata);
d458 1
a458 1
	tmpid = umap_reverse_findid(uid, umapdata, unentries);
d462 2
a463 2
		if (umap_bug_bypass)
			printf("umap_getattr: original uid = %u\n", uid);
d473 2
a474 2
		if (umap_bug_bypass)
			printf("umap_getattr: original gid = %u\n", gid);
a480 131
/*ARGSUSED*/
int
umap_inactive(v)
	void *v;
{
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
	/*
	 * Do nothing (and _don't_ bypass).
	 * Wait to vrele lowervp until reclaim,
	 * so that until then our umap_node is in the
	 * cache and reusable.
	 *
	 */
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
	return (0);
}

/*
 * We need to process our own vnode lock and then clear the
 * interlock flag as it applies only to our vnode, not the
 * vnodes below us on the stack.
 */
int
umap_lock(v)
	void *v;
{
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;

#if 0
	vop_generic_lock(ap);
#endif
	if ((ap->a_flags & LK_TYPE_MASK) == LK_DRAIN)
		return (0);
	ap->a_flags &= ~LK_INTERLOCK;
	return (umap_bypass(ap));
}

/*
 * We need to process our own vnode unlock and then clear the
 * interlock flag as it applies only to our vnode, not the
 * vnodes below us on the stack.
 */
int
umap_unlock(v)
	void *v;
{
	struct vop_unlock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;

#if 0
	vop_generic_unlock(ap);
#endif
	ap->a_flags &= ~LK_INTERLOCK;
	return (umap_bypass(ap));
}



int
umap_reclaim(v)
	void *v;
{
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct umap_node *xp = VTOUMAP(vp);
	struct vnode *lowervp = xp->umap_lowervp;
	
	/* After this assignment, this node will not be re-used. */
	xp->umap_lowervp = NULL;
	LIST_REMOVE(xp, umap_hash);
	FREE(vp->v_data, M_TEMP);
	vp->v_data = NULL;
	vrele(lowervp);
	return (0);
}

int
umap_strategy(v)
	void *v;
{
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
	struct buf *bp = ap->a_bp;
	int error;
	struct vnode *savedvp;

	savedvp = bp->b_vp;
	bp->b_vp = UMAPVPTOLOWERVP(bp->b_vp);

	error = VOP_STRATEGY(ap->a_bp);

	bp->b_vp = savedvp;

	return (error);
}

int
umap_bwrite(v)
	void *v;
{
	struct vop_bwrite_args /* {
		struct buf *a_bp;
	} */ *ap = v;
	struct buf *bp = ap->a_bp;
	int error;
	struct vnode *savedvp;

	savedvp = bp->b_vp;
	bp->b_vp = UMAPVPTOLOWERVP(bp->b_vp);

	error = VOP_BWRITE(ap->a_bp);

	bp->b_vp = savedvp;

	return (error);
}


d506 1
a506 1
	int error;
d513 1
a513 1
	 * We need to map the cred in the second structure,
d518 1
d525 2
a526 2
	if (umap_bug_bypass && compcredp->cr_uid != 0)
		printf("umap_rename: rename component credit user was %u, group %u\n", 
d533 2
a534 2
	if (umap_bug_bypass && compcredp->cr_uid != 0)
		printf("umap_rename: rename component credit user now %u, group %u\n", 
a545 1

@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.13 2001/12/04 22:44:32 art Exp $	*/
d185 1
a185 1
			printf("umap_bypass: user was %d, group %d\n", 
d193 1
a193 1
			printf("umap_bypass: user now %d, group %d\n", 
d210 1
a210 1
			printf("umap_bypass: component credit user was %d, group %d\n", 
d218 1
a218 1
			printf("umap_bypass: component credit user now %d, group %d\n", 
d266 1
a266 1
			printf("umap_bypass: returning-user was %d\n",
d272 1
a272 1
		 	printf("umap_bypass: returning-user now %d\n\n", 
d279 1
a279 1
			printf("umap_bypass: returning-component-user was %d\n", 
d285 1
a285 1
		 	printf("umap_bypass: returning-component-user now %d\n", 
d334 1
a334 1
		printf("umap_getattr: mapped uid = %d, mapped gid = %d\n", uid, 
d351 1
a351 1
			printf("umap_getattr: original uid = %d\n", uid);
d362 1
a362 1
			printf("umap_getattr: original gid = %d\n", gid);
d544 1
a544 1
		printf("umap_rename: rename component credit user was %d, group %d\n", 
d552 1
a552 1
		printf("umap_rename: rename component credit user now %d, group %d\n", 
@


1.13
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.12 1999/01/11 05:12:27 millert Exp $	*/
d61 10
a70 10
int	umap_bypass	__P((void *));
int	umap_getattr	__P((void *));
int	umap_inactive	__P((void *));
int	umap_reclaim	__P((void *));
int	umap_print	__P((void *));
int	umap_rename	__P((void *));
int	umap_strategy	__P((void *));
int	umap_bwrite	__P((void *));
int	umap_unlock	__P((void *));
int	umap_lock	__P((void *));
d80 1
a80 1
int (**umap_vnodeop_p) __P((void *));
@


1.13.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.13 2001/12/04 22:44:32 art Exp $	*/
d61 10
a70 10
int	umap_bypass(void *);
int	umap_getattr(void *);
int	umap_inactive(void *);
int	umap_reclaim(void *);
int	umap_print(void *);
int	umap_rename(void *);
int	umap_strategy(void *);
int	umap_bwrite(void *);
int	umap_unlock(void *);
int	umap_lock(void *);
d80 1
a80 1
int (**umap_vnodeop_p)(void *);
@


1.13.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.13.2.1 2002/06/11 03:30:21 art Exp $	*/
d185 1
a185 1
			printf("umap_bypass: user was %u, group %u\n", 
d193 1
a193 1
			printf("umap_bypass: user now %u, group %u\n", 
d210 1
a210 1
			printf("umap_bypass: component credit user was %u, group %u\n", 
d218 1
a218 1
			printf("umap_bypass: component credit user now %u, group %u\n", 
d266 1
a266 1
			printf("umap_bypass: returning-user was %u\n",
d272 1
a272 1
		 	printf("umap_bypass: returning-user now %u\n\n", 
d279 1
a279 1
			printf("umap_bypass: returning-component-user was %u\n", 
d285 1
a285 1
		 	printf("umap_bypass: returning-component-user now %u\n", 
d334 1
a334 1
		printf("umap_getattr: mapped uid = %u, mapped gid = %u\n", uid, 
d351 1
a351 1
			printf("umap_getattr: original uid = %u\n", uid);
d362 1
a362 1
			printf("umap_getattr: original gid = %u\n", gid);
d544 1
a544 1
		printf("umap_rename: rename component credit user was %u, group %u\n", 
d552 1
a552 1
		printf("umap_rename: rename component credit user now %u, group %u\n", 
@


1.13.2.3
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: umap_vnops.c,v 1.22 2002/01/04 07:19:34 chs Exp $	*/
d39 1
a39 1
 *	@@(#)umap_vnops.c	8.6 (Berkeley) 5/22/95
a45 1

d49 1
d55 1
a56 1
#include <miscfs/genfs/layer_extern.h>
d58 4
a61 1
int	umap_lookup(void *);
d63 2
d67 4
d80 14
a93 22
int (**umapfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc umapfs_vnodeop_entries[] = {
	{ &vop_default_desc,	umap_bypass },

	{ &vop_lookup_desc,	umap_lookup },
	{ &vop_getattr_desc,	umap_getattr },
	{ &vop_print_desc,	umap_print },
	{ &vop_rename_desc,	umap_rename },

	{ &vop_lock_desc,	layer_lock },
	{ &vop_unlock_desc,	layer_unlock },
	{ &vop_islocked_desc,	layer_islocked },
	{ &vop_fsync_desc,	layer_fsync },
	{ &vop_inactive_desc,	layer_inactive },
	{ &vop_reclaim_desc,	layer_reclaim },
	{ &vop_open_desc,	layer_open },
	{ &vop_setattr_desc,	layer_setattr },
	{ &vop_access_desc,	layer_access },

	{ &vop_strategy_desc,	layer_strategy },
	{ &vop_bwrite_desc,	layer_bwrite },
	{ &vop_bmap_desc,	layer_bmap },
d96 2
a97 2
const struct vnodeopv_desc umapfs_vnodeop_opv_desc =
	{ &umapfs_vnodeop_p, umapfs_vnodeop_entries };
d100 2
a101 2
 * This is the 08-June-1999 bypass routine.
 * See layer_vnops.c:layer_bypass for more details.
d115 3
a117 3
	int error, error1;
	int (**our_vnodeop_p)(void *);
	struct vnode *old_vps[VDESC_MAX_VPS], *vp0;
d121 1
a121 1
	int reles, i, flags;
d124 3
d133 1
a133 1
		panic ("umap_bypass: no vp's in map.\n");
a134 8
	vps_p[0] = VOPARG_OFFSETTO(struct vnode**,descp->vdesc_vp_offsets[0],
				ap);
	vp0 = *vps_p[0];
	flags = MOUNTTOUMAPMOUNT(vp0->v_mount)->umapm_flags;
	our_vnodeop_p = vp0->v_op;

	if (flags & LAYERFS_MBYPASSDEBUG)
		printf("umap_bypass: %s\n", descp->vdesc_name);
d148 4
d158 2
a159 2
		if (i && ((*this_vp_p)==NULL ||
		    (*this_vp_p)->v_op != our_vnodeop_p)) {
d174 3
a176 4
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET) {

		credpp = VOPARG_OFFSETTO(struct ucred**, 
		    descp->vdesc_cred_offset, ap);
d181 1
a181 2
		if (savecredp != NOCRED)
			*credpp = crdup(savecredp);
d184 2
a185 2
		if ((flags & LAYERFS_MBYPASSDEBUG) && credp->cr_uid != 0)
			printf("umap_bypass: user was %d, group %d\n", 
d190 1
a190 1
		umap_mapids(vp0->v_mount, credp);
d192 2
a193 2
		if ((flags & LAYERFS_MBYPASSDEBUG) && credp->cr_uid != 0)
			printf("umap_bypass: user now %d, group %d\n", 
d201 3
a203 4
	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET) {

		compnamepp = VOPARG_OFFSETTO(struct componentname**, 
		    descp->vdesc_componentname_offset, ap);
d206 1
a206 2
		if (savecompcredp != NOCRED)
			(*compnamepp)->cn_cred = crdup(savecompcredp);
d209 2
a210 2
		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_bypass: component credit user was %d, group %d\n", 
d215 1
a215 1
		umap_mapids(vp0->v_mount, compcredp);
d217 2
a218 2
		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_bypass: component credit user now %d, group %d\n", 
d237 1
a237 1
		if (old_vps[i]) {
d239 1
a239 3
			if (reles & VDESC_VP0_WILLUNLOCK)
				LAYERFS_UPPERUNLOCK(*(vps_p[i]), 0, error1);
			if (reles & VDESC_VP0_WILLRELE)
d241 2
a242 2
		}
	}
d252 5
a256 40
		if (descp->vdesc_flags & VDESC_VPP_WILLRELE)
			goto out;
		vppp = VOPARG_OFFSETTO(struct vnode***,
				 descp->vdesc_vpp_offset, ap);
		error = layer_node_create(old_vps[0]->v_mount, **vppp, *vppp);
	}

 out:
	/* 
	 * Free duplicate cred structure and restore old one.
	 */
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET) {
		if ((flags & LAYERFS_MBYPASSDEBUG) && credp &&
					credp->cr_uid != 0)
			printf("umap_bypass: returning-user was %d\n",
			    credp->cr_uid);

		if (savecredp != NOCRED) {
			crfree(credp);
			*credpp = savecredp;
			if ((flags & LAYERFS_MBYPASSDEBUG) && credpp &&
					(*credpp)->cr_uid != 0)
			 	printf("umap_bypass: returning-user now %d\n\n", 
				    savecredp->cr_uid);
		}
	}

	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET) {
		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp &&
					compcredp->cr_uid != 0)
			printf("umap_bypass: returning-component-user was %d\n", 
			    compcredp->cr_uid);

		if (savecompcredp != NOCRED) {
			crfree(compcredp);
			(*compnamepp)->cn_cred = savecompcredp;
			if ((flags & LAYERFS_MBYPASSDEBUG) && savecompcredp &&
					savecompcredp->cr_uid != 0)
			 	printf("umap_bypass: returning-component-user now %d\n", 
				    savecompcredp->cr_uid);
a259 82
	return (error);
}

/*
 * This is based on the 08-June-1999 bypass routine.
 * See layer_vnops.c:layer_bypass for more details.
 */ 
int
umap_lookup(v)
	void *v;
{
	struct vop_lookup_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct ucred *savecompcredp = NULL;
	struct ucred *compcredp = NULL;
	struct vnode *dvp, *vp, *ldvp;
	struct mount *mp;
	int error;
	int i, flags, cnf = cnp->cn_flags;

	dvp = ap->a_dvp;
	mp = dvp->v_mount;

	if ((cnf & ISLASTCN) && (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
		(cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

	flags = MOUNTTOUMAPMOUNT(mp)->umapm_flags;
	ldvp = UMAPVPTOLOWERVP(dvp);

	if (flags & LAYERFS_MBYPASSDEBUG)
		printf("umap_lookup\n");

	/*
	 * Fix the credentials.  (That's the purpose of this layer.)
	 *
	 * BSD often keeps a credential in the componentname structure
	 * for speed.  If there is one, it better get mapped, too. 
	 */

	if ((savecompcredp = cnp->cn_cred)) {
		compcredp = crdup(savecompcredp);
		cnp->cn_cred = compcredp;

		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_lookup: component credit user was %d, group %d\n", 
			    compcredp->cr_uid, compcredp->cr_gid);

		/* Map all ids in the credential structure. */
		umap_mapids(mp, compcredp);
	}

	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_lookup: component credit user now %d, group %d\n", 
		    compcredp->cr_uid, compcredp->cr_gid);

	ap->a_dvp = ldvp;
	error = VCALL(ldvp, ap->a_desc->vdesc_offset, ap);
	vp = *ap->a_vpp;

	if (error == EJUSTRETURN && (cnf & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME))
		error = EROFS;

	/* Do locking fixup as appropriate. See layer_lookup() for info */
	if ((cnp->cn_flags & PDIRUNLOCK)) {
		LAYERFS_UPPERUNLOCK(dvp, 0, i);
	}
	if (ldvp == vp) {
		*ap->a_vpp = dvp;
		VREF(dvp);
		vrele(vp);
	} else if (vp != NULL) {
		error = layer_node_create(mp, vp, ap->a_vpp);
	}

d263 18
a280 4
	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp &&
					compcredp->cr_uid != 0)
		printf("umap_lookup: returning-component-user was %d\n", 
			    compcredp->cr_uid);
a281 1
	if (savecompcredp != NOCRED) {
d283 3
a285 4
		cnp->cn_cred = savecompcredp;
		if ((flags & LAYERFS_MBYPASSDEBUG) && savecompcredp &&
				savecompcredp->cr_uid != 0)
		 	printf("umap_lookup: returning-component-user now %d\n", 
d292 1
d306 6
a311 7
	uid_t uid;
	gid_t gid;
	int error, tmpid, unentries, gnentries, flags;
	u_long (*umapdata)[2];
	u_long (*gmapdata)[2];
	struct vnode **vp1p;
	const struct vnodeop_desc *descp = ap->a_desc;
a317 1
	flags = MOUNTTOUMAPMOUNT(ap->a_vp->v_mount)->umapm_flags;
d333 2
a334 2
	if ((flags & LAYERFS_MBYPASSDEBUG))
		printf("umap_getattr: mapped uid = %d, mapped gid = %d\n", uid, 
d339 1
a339 1
	umapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_umapdata);
d341 1
a341 1
	gmapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_gmapdata);
d350 2
a351 2
		if ((flags & LAYERFS_MBYPASSDEBUG))
			printf("umap_getattr: original uid = %d\n", uid);
d361 2
a362 2
		if ((flags & LAYERFS_MBYPASSDEBUG))
			printf("umap_getattr: original gid = %d\n", gid);
d369 131
d525 1
a525 1
	int error, flags;
d532 1
a532 1
	 * We need to map the cre in the second structure,
a536 1
	flags = MOUNTTOUMAPMOUNT(vp->v_mount)->umapm_flags;
d543 2
a544 2
	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_rename: rename component credit user was %d, group %d\n", 
d551 2
a552 2
	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_rename: rename component credit user now %d, group %d\n", 
d564 1
@


1.12
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.11 1998/08/06 23:06:20 csapuntz Exp $	*/
d94 1
a94 1
	{ (struct vnodeop_desc*) NULL, (int(*) __P((void *))) NULL }
@


1.12.6.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d94 1
a94 1
	{ NULL, NULL }
@


1.12.6.2
log
@Merge in -current from roughly a week ago
@
text
@d61 10
a70 10
int	umap_bypass(void *);
int	umap_getattr(void *);
int	umap_inactive(void *);
int	umap_reclaim(void *);
int	umap_print(void *);
int	umap_rename(void *);
int	umap_strategy(void *);
int	umap_bwrite(void *);
int	umap_unlock(void *);
int	umap_lock(void *);
d80 1
a80 1
int (**umap_vnodeop_p)(void *);
@


1.12.6.3
log
@Sync the SMP branch with 3.3
@
text
@d185 1
a185 1
			printf("umap_bypass: user was %u, group %u\n", 
d193 1
a193 1
			printf("umap_bypass: user now %u, group %u\n", 
d210 1
a210 1
			printf("umap_bypass: component credit user was %u, group %u\n", 
d218 1
a218 1
			printf("umap_bypass: component credit user now %u, group %u\n", 
d266 1
a266 1
			printf("umap_bypass: returning-user was %u\n",
d272 1
a272 1
		 	printf("umap_bypass: returning-user now %u\n\n", 
d279 1
a279 1
			printf("umap_bypass: returning-component-user was %u\n", 
d285 1
a285 1
		 	printf("umap_bypass: returning-component-user now %u\n", 
d334 1
a334 1
		printf("umap_getattr: mapped uid = %u, mapped gid = %u\n", uid, 
d351 1
a351 1
			printf("umap_getattr: original uid = %u\n", uid);
d362 1
a362 1
			printf("umap_getattr: original gid = %u\n", gid);
d544 1
a544 1
		printf("umap_rename: rename component credit user was %u, group %u\n", 
d552 1
a552 1
		printf("umap_rename: rename component credit user now %u, group %u\n", 
@


1.12.6.4
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: umap_vnops.c,v 1.22 2002/01/04 07:19:34 chs Exp $	*/
d39 1
a39 1
 *	@@(#)umap_vnops.c	8.6 (Berkeley) 5/22/95
a45 1

d49 1
d55 1
a56 1
#include <miscfs/genfs/layer_extern.h>
d58 4
a61 1
int	umap_lookup(void *);
d63 2
d67 4
d80 14
a93 22
int (**umapfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc umapfs_vnodeop_entries[] = {
	{ &vop_default_desc,	umap_bypass },

	{ &vop_lookup_desc,	umap_lookup },
	{ &vop_getattr_desc,	umap_getattr },
	{ &vop_print_desc,	umap_print },
	{ &vop_rename_desc,	umap_rename },

	{ &vop_lock_desc,	layer_lock },
	{ &vop_unlock_desc,	layer_unlock },
	{ &vop_islocked_desc,	layer_islocked },
	{ &vop_fsync_desc,	layer_fsync },
	{ &vop_inactive_desc,	layer_inactive },
	{ &vop_reclaim_desc,	layer_reclaim },
	{ &vop_open_desc,	layer_open },
	{ &vop_setattr_desc,	layer_setattr },
	{ &vop_access_desc,	layer_access },

	{ &vop_strategy_desc,	layer_strategy },
	{ &vop_bwrite_desc,	layer_bwrite },
	{ &vop_bmap_desc,	layer_bmap },
d96 2
a97 2
const struct vnodeopv_desc umapfs_vnodeop_opv_desc =
	{ &umapfs_vnodeop_p, umapfs_vnodeop_entries };
d100 2
a101 2
 * This is the 08-June-1999 bypass routine.
 * See layer_vnops.c:layer_bypass for more details.
d115 3
a117 3
	int error, error1;
	int (**our_vnodeop_p)(void *);
	struct vnode *old_vps[VDESC_MAX_VPS], *vp0;
d121 1
a121 1
	int reles, i, flags;
d124 3
d133 1
a133 1
		panic ("umap_bypass: no vp's in map.\n");
a134 8
	vps_p[0] = VOPARG_OFFSETTO(struct vnode**,descp->vdesc_vp_offsets[0],
				ap);
	vp0 = *vps_p[0];
	flags = MOUNTTOUMAPMOUNT(vp0->v_mount)->umapm_flags;
	our_vnodeop_p = vp0->v_op;

	if (flags & LAYERFS_MBYPASSDEBUG)
		printf("umap_bypass: %s\n", descp->vdesc_name);
d148 4
d158 2
a159 2
		if (i && ((*this_vp_p)==NULL ||
		    (*this_vp_p)->v_op != our_vnodeop_p)) {
d174 3
a176 4
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET) {

		credpp = VOPARG_OFFSETTO(struct ucred**, 
		    descp->vdesc_cred_offset, ap);
d181 1
a181 2
		if (savecredp != NOCRED)
			*credpp = crdup(savecredp);
d184 2
a185 2
		if ((flags & LAYERFS_MBYPASSDEBUG) && credp->cr_uid != 0)
			printf("umap_bypass: user was %d, group %d\n", 
d190 1
a190 1
		umap_mapids(vp0->v_mount, credp);
d192 2
a193 2
		if ((flags & LAYERFS_MBYPASSDEBUG) && credp->cr_uid != 0)
			printf("umap_bypass: user now %d, group %d\n", 
d201 3
a203 4
	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET) {

		compnamepp = VOPARG_OFFSETTO(struct componentname**, 
		    descp->vdesc_componentname_offset, ap);
d206 1
a206 2
		if (savecompcredp != NOCRED)
			(*compnamepp)->cn_cred = crdup(savecompcredp);
d209 2
a210 2
		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_bypass: component credit user was %d, group %d\n", 
d215 1
a215 1
		umap_mapids(vp0->v_mount, compcredp);
d217 2
a218 2
		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_bypass: component credit user now %d, group %d\n", 
d237 1
a237 1
		if (old_vps[i]) {
d239 1
a239 3
			if (reles & VDESC_VP0_WILLUNLOCK)
				LAYERFS_UPPERUNLOCK(*(vps_p[i]), 0, error1);
			if (reles & VDESC_VP0_WILLRELE)
d241 2
a242 2
		}
	}
d252 5
a256 40
		if (descp->vdesc_flags & VDESC_VPP_WILLRELE)
			goto out;
		vppp = VOPARG_OFFSETTO(struct vnode***,
				 descp->vdesc_vpp_offset, ap);
		error = layer_node_create(old_vps[0]->v_mount, **vppp, *vppp);
	}

 out:
	/* 
	 * Free duplicate cred structure and restore old one.
	 */
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET) {
		if ((flags & LAYERFS_MBYPASSDEBUG) && credp &&
					credp->cr_uid != 0)
			printf("umap_bypass: returning-user was %d\n",
			    credp->cr_uid);

		if (savecredp != NOCRED) {
			crfree(credp);
			*credpp = savecredp;
			if ((flags & LAYERFS_MBYPASSDEBUG) && credpp &&
					(*credpp)->cr_uid != 0)
			 	printf("umap_bypass: returning-user now %d\n\n", 
				    savecredp->cr_uid);
		}
	}

	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET) {
		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp &&
					compcredp->cr_uid != 0)
			printf("umap_bypass: returning-component-user was %d\n", 
			    compcredp->cr_uid);

		if (savecompcredp != NOCRED) {
			crfree(compcredp);
			(*compnamepp)->cn_cred = savecompcredp;
			if ((flags & LAYERFS_MBYPASSDEBUG) && savecompcredp &&
					savecompcredp->cr_uid != 0)
			 	printf("umap_bypass: returning-component-user now %d\n", 
				    savecompcredp->cr_uid);
a259 82
	return (error);
}

/*
 * This is based on the 08-June-1999 bypass routine.
 * See layer_vnops.c:layer_bypass for more details.
 */ 
int
umap_lookup(v)
	void *v;
{
	struct vop_lookup_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct ucred *savecompcredp = NULL;
	struct ucred *compcredp = NULL;
	struct vnode *dvp, *vp, *ldvp;
	struct mount *mp;
	int error;
	int i, flags, cnf = cnp->cn_flags;

	dvp = ap->a_dvp;
	mp = dvp->v_mount;

	if ((cnf & ISLASTCN) && (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
		(cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

	flags = MOUNTTOUMAPMOUNT(mp)->umapm_flags;
	ldvp = UMAPVPTOLOWERVP(dvp);

	if (flags & LAYERFS_MBYPASSDEBUG)
		printf("umap_lookup\n");

	/*
	 * Fix the credentials.  (That's the purpose of this layer.)
	 *
	 * BSD often keeps a credential in the componentname structure
	 * for speed.  If there is one, it better get mapped, too. 
	 */

	if ((savecompcredp = cnp->cn_cred)) {
		compcredp = crdup(savecompcredp);
		cnp->cn_cred = compcredp;

		if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
			printf("umap_lookup: component credit user was %d, group %d\n", 
			    compcredp->cr_uid, compcredp->cr_gid);

		/* Map all ids in the credential structure. */
		umap_mapids(mp, compcredp);
	}

	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_lookup: component credit user now %d, group %d\n", 
		    compcredp->cr_uid, compcredp->cr_gid);

	ap->a_dvp = ldvp;
	error = VCALL(ldvp, ap->a_desc->vdesc_offset, ap);
	vp = *ap->a_vpp;

	if (error == EJUSTRETURN && (cnf & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME))
		error = EROFS;

	/* Do locking fixup as appropriate. See layer_lookup() for info */
	if ((cnp->cn_flags & PDIRUNLOCK)) {
		LAYERFS_UPPERUNLOCK(dvp, 0, i);
	}
	if (ldvp == vp) {
		*ap->a_vpp = dvp;
		VREF(dvp);
		vrele(vp);
	} else if (vp != NULL) {
		error = layer_node_create(mp, vp, ap->a_vpp);
	}

d263 18
a280 4
	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp &&
					compcredp->cr_uid != 0)
		printf("umap_lookup: returning-component-user was %d\n", 
			    compcredp->cr_uid);
a281 1
	if (savecompcredp != NOCRED) {
d283 3
a285 4
		cnp->cn_cred = savecompcredp;
		if ((flags & LAYERFS_MBYPASSDEBUG) && savecompcredp &&
				savecompcredp->cr_uid != 0)
		 	printf("umap_lookup: returning-component-user now %d\n", 
d292 1
d306 6
a311 7
	uid_t uid;
	gid_t gid;
	int error, tmpid, unentries, gnentries, flags;
	u_long (*umapdata)[2];
	u_long (*gmapdata)[2];
	struct vnode **vp1p;
	const struct vnodeop_desc *descp = ap->a_desc;
a317 1
	flags = MOUNTTOUMAPMOUNT(ap->a_vp->v_mount)->umapm_flags;
d333 2
a334 2
	if ((flags & LAYERFS_MBYPASSDEBUG))
		printf("umap_getattr: mapped uid = %d, mapped gid = %d\n", uid, 
d339 1
a339 1
	umapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_umapdata);
d341 1
a341 1
	gmapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_gmapdata);
d350 2
a351 2
		if ((flags & LAYERFS_MBYPASSDEBUG))
			printf("umap_getattr: original uid = %d\n", uid);
d361 2
a362 2
		if ((flags & LAYERFS_MBYPASSDEBUG))
			printf("umap_getattr: original gid = %d\n", gid);
d369 131
d525 1
a525 1
	int error, flags;
d532 1
a532 1
	 * We need to map the cre in the second structure,
a536 1
	flags = MOUNTTOUMAPMOUNT(vp->v_mount)->umapm_flags;
d543 2
a544 2
	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_rename: rename component credit user was %d, group %d\n", 
d551 2
a552 2
	if ((flags & LAYERFS_MBYPASSDEBUG) && compcredp->cr_uid != 0)
		printf("umap_rename: rename component credit user now %d, group %d\n", 
d564 1
@


1.12.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.12.6.4 2003/05/16 00:29:43 niklas Exp $ */
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d125 1
a125 1
		panic("umap_bypass: no vp's in map");
@


1.11
log
@

Fix the typos that prevented umap from working. They, of course, lead
to the obvious question: don't you run this stuff before you check it
in? Sadly, the answer was no in this case. But, I'm trying to learn.
Slowly, painfully....
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.10 1998/08/06 19:34:50 csapuntz Exp $	*/
d133 1
a133 1
		panic ("umap_bypass: no vp's in map.\n");
@


1.10
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.9 1997/11/06 05:58:49 csapuntz Exp $	*/
d374 1
a374 1
	struct vop_getattr_args /* {
d404 1
d406 1
d410 1
a410 1
	return (null_bypass(ap));
d428 1
d430 1
d432 1
a432 1
	return (null_bypass(ap));
@


1.9
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.8 1997/10/06 20:20:42 deraadt Exp $	*/
d404 1
a404 1
	vop_nolock(ap);
d426 1
a426 1
	vop_nounlock(ap);
@


1.8
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.6 1996/05/29 07:12:10 deraadt Exp $	*/
d55 1
d69 2
d89 2
a90 1

d385 1
a385 1
	VOP_UNLOCK(ap->a_vp);
d388 44
@


1.7
log
@VFS Lite2 Changes
@
text
@a54 1
#include <miscfs/nullfs/null.h>
a67 2
int	umap_unlock	__P((void *));
int	umap_lock	__P((void *));
d86 1
a86 2
	{ &vop_lock_desc, umap_lock },
	{ &vop_unlock_desc, umap_unlock },
d381 1
a381 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
a383 44

/*
 * We need to process our own vnode lock and then clear the
 * interlock flag as it applies only to our vnode, not the
 * vnodes below us on the stack.
 */
int
umap_lock(v)
	void *v;
{
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;

	vop_nolock(ap);
	if ((ap->a_flags & LK_TYPE_MASK) == LK_DRAIN)
		return (0);
	ap->a_flags &= ~LK_INTERLOCK;
	return (null_bypass(ap));
}

/*
 * We need to process our own vnode unlock and then clear the
 * interlock flag as it applies only to our vnode, not the
 * vnodes below us on the stack.
 */
int
umap_unlock(v)
	void *v;
{
	struct vop_unlock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;

	vop_nounlock(ap);
	ap->a_flags &= ~LK_INTERLOCK;
	return (null_bypass(ap));
}


@


1.6
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.4 1996/03/25 18:02:58 mickey Exp $	*/
d55 1
d69 2
d89 2
a90 1

d385 1
a385 1
	VOP_UNLOCK(ap->a_vp);
d388 44
@


1.5
log
@Bug w/ rename fixed.
Strange thing still present w/ removes, the situation
seemd to be like extra VREF made somewhere, that is,
lower nfs does not remove, but rename file in '.nfs*' thing that
disapears at umap umount. this thing happend w/ nullfs too.
@
text
@d2 1
a2 1
/*	$NetBSD: umap_vnops.c,v 1.5 1996/02/09 22:41:06 christos Exp $	*/
d456 2
a457 2
	printf("\ttag VT_UMAPFS, vp=%x, lowervp=%x\n", 
	       (unsigned int) vp, (unsigned int) UMAPVPTOLOWERVP(vp));
@


1.4
log
@Fixed bug while copying args in mount that may cause a crash.
Types changes and so.
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.3 1996/02/29 13:08:07 niklas Exp $	*/
d111 1
a111 1
	int error;
d154 2
a155 1
		if (i && (*this_vp_p)->v_op != umap_vnodeop_p) {
d177 1
a177 2
		if (savecredp != NOCRED)
			*credpp = crdup(savecredp);
d202 1
a202 2
		if (savecompcredp != NOCRED)
			(*compnamepp)->cn_cred = crdup(savecompcredp);
d233 1
a233 1
		if (old_vps[i]) {
d248 7
a254 6
		if (descp->vdesc_flags & VDESC_VPP_WILLRELE)
			goto out;
		vppp = VOPARG_OFFSETTO(struct vnode***,
				 descp->vdesc_vpp_offset, ap);
		error = umap_node_create(old_vps[0]->v_mount, **vppp, *vppp);
	};
a255 1
 out:
d265 5
a269 7
		if (savecredp != NOCRED) {
			crfree(credp);
			*credpp = savecredp;
			if (umap_bug_bypass && credpp && (*credpp)->cr_uid != 0)
			 	printf("umap_bypass: returning-user now %d\n\n", 
				    savecredp->cr_uid);
		}
d273 1
a273 1
	    && (*compnamepp)->cn_cred != NOCRED ) {
d278 5
a282 7
		if (savecompcredp != NOCRED) {
			crfree(compcredp);
			(*compnamepp)->cn_cred = savecompcredp;
			if (umap_bug_bypass && credpp && (*credpp)->cr_uid != 0)
			 	printf("umap_bypass: returning-component-user now %d\n", 
				    savecompcredp->cr_uid);
		}
d370 4
d381 1
@


1.3
log
@Reinstate $NetBSD$ headers (we want them for tracking purposes)
Sync with NetBSD 960217
@
text
@d1 1
a1 1
/*	$OpenBSD: umap_vnops.c,v 1.2 1996/02/26 07:20:12 mickey Exp $	*/
d307 6
a312 7
	uid_t uid;
	gid_t gid;
	int error, tmpid, nentries, gnentries;
	u_long (*mapdata)[2];
	u_long (*gmapdata)[2];
	struct vnode **vp1p;
	struct vnodeop_desc *descp = ap->a_desc;
d339 2
a340 2
	nentries =  MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_nentries;
	mapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_mapdata);
d342 1
a342 1
	gmapdata =  (MOUNTTOUMAPMOUNT((*vp1p)->v_mount)->info_gmapdata);
d347 1
a347 1
	tmpid = umap_reverse_findid(uid, mapdata, nentries);
d480 1
a480 1
	 * We need to map the cre in the second structure,
@


1.2
log
@Bug fixes (such as missing arguments).
Still seemed to have at least one bug. Strange panic happened
when unmounting from NFS tree.
@
text
@d1 2
a2 1
/*	$OpenBSD: umap_vnops.c,v 1.5 1996/02/09 22:41:06 christos Exp $	*/
d315 1
a315 1
	if (error = umap_bypass(ap))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: umap_vnops.c,v 1.4 1995/04/15 01:57:39 cgd Exp $	*/
d59 35
d99 3
a101 1
umap_bypass(ap)
d105 1
a105 3
	} */ *ap;
{
	extern int (**umap_vnodeop_p)();  /* not extern, really "forward" */
d107 1
a107 1
	struct ucred *savecredp, *savecompcredp = 0;
d168 3
a170 4
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET) {

		credpp = VOPARG_OFFSETTO(struct ucred**, 
		    descp->vdesc_cred_offset, ap);
d196 3
a198 4
	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET) {

		compnamepp = VOPARG_OFFSETTO(struct componentname**, 
		    descp->vdesc_componentname_offset, ap);
d259 2
a260 1
	if (descp->vdesc_cred_offset != VDESC_NO_OFFSET) {
d274 2
a275 1
	if (descp->vdesc_componentname_offset != VDESC_NO_OFFSET) {
d297 3
a299 1
umap_getattr(ap)
d305 1
a305 2
	} */ *ap;
{
d370 1
d372 2
a373 4
umap_inactive(ap)
	struct vop_inactive_args /* {
		struct vnode *a_vp;
	} */ *ap;
d386 3
a388 1
umap_reclaim(ap)
d391 1
a391 2
	} */ *ap;
{
d406 3
a408 1
umap_strategy(ap)
d411 1
a411 2
	} */ *ap;
{
d427 3
a429 1
umap_bwrite(ap)
d432 1
a432 2
	} */ *ap;
{
d449 3
a451 1
umap_print(ap)
d454 1
a454 2
	} */ *ap;
{
d456 2
a457 1
	printf("\ttag VT_UMAPFS, vp=%x, lowervp=%x\n", vp, UMAPVPTOLOWERVP(vp));
d462 3
a464 1
umap_rename(ap)
d472 1
a472 2
	} */ *ap;
{
a512 25
/*
 * Global vfs data structures
 */
/*
 * XXX - strategy, bwrite are hand coded currently.  They should
 * go away with a merged buffer/block cache.
 *
 */
int (**umap_vnodeop_p)();
struct vnodeopv_entry_desc umap_vnodeop_entries[] = {
	{ &vop_default_desc, umap_bypass },

	{ &vop_getattr_desc, umap_getattr },
	{ &vop_inactive_desc, umap_inactive },
	{ &vop_reclaim_desc, umap_reclaim },
	{ &vop_print_desc, umap_print },
	{ &vop_rename_desc, umap_rename },

	{ &vop_strategy_desc, umap_strategy },
	{ &vop_bwrite_desc, umap_bwrite },

	{ (struct vnodeop_desc*) NULL, (int(*)()) NULL }
};
struct vnodeopv_desc umap_vnodeop_opv_desc =
	{ &umap_vnodeop_p, umap_vnodeop_entries };
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
