head	1.23;
access;
symbols
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.6
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2005.05.26.00.38.50;	author pedro;	state dead;
branches;
next	1.22;

1.22
date	2004.06.01.21.58.19;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.20.18.32.37;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.18.12.37.51;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.18.02.23.41;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.03.06.01.49;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.14.07.46.39;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.28.10;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.12.21.00.39;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.24.22.32.46;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.20.01.50.10;	author assar;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2000.02.07.04.57.16;	author assar;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.05.31.17.34.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.08.06.23.38.39;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	98.02.08.22.41.38;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.58.40;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.20.30;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.19.07;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.09.11.05.26.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.12.04.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.58.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.01;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2001.05.14.22.32.54;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.12.6.1
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2003.05.19.22.35.55;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@bye bye, rest in attic ad infinitum, amen
@
text
@/*	$OpenBSD: null_vfsops.c,v 1.22 2004/06/01 21:58:19 pedro Exp $	*/
/*	$NetBSD: null_vfsops.c,v 1.38 2002/09/21 18:09:29 christos Exp $	*/

/*
 * Copyright (c) 1999 National Aeronautics & Space Administration
 * All rights reserved.
 *
 * This software was written by William Studenmund of the
 * Numerical Aerospace Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the National Aeronautics & Space Administration
 *    nor the names of its contributors may be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NATIONAL AERONAUTICS & SPACE ADMINISTRATION
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ADMINISTRATION OR CONTRIB-
 * UTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1992, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software donated to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Id: lofs_vfsops.c,v 1.9 1992/05/30 10:26:24 jsp Exp
 *	from: @@(#)lofs_vfsops.c	1.2 (Berkeley) 6/18/92
 *	@@(#)null_vfsops.c	8.7 (Berkeley) 5/14/95
 */

/*
 * Null Layer
 * (See null_vnops.c for a description of what this does.)
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/malloc.h>

#include <miscfs/nullfs/null.h>
#include <miscfs/genfs/layer_extern.h>

int	nullfs_mount(struct mount *, const char *, void *,
	    struct nameidata *, struct proc *);
int	nullfs_unmount(struct mount *, int, struct proc *);

/*
 * Mount null layer
 */
int
nullfs_mount(mp, path, data, ndp, p)
	struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
{
	struct null_args args;
	struct vnode *lowerrootvp, *vp;
	struct null_mount *nmp;
	struct layer_mount *lmp;
	size_t size;
	int error = 0;

#ifdef NULLFS_DIAGNOSTIC
	printf("nullfs_mount(mp = %p)\n", mp);
#endif
#if 0
	if (mp->mnt_flag & MNT_GETARGS) {
		lmp = MOUNTTOLAYERMOUNT(mp);
		if (lmp == NULL)
			return EIO;
		args.la.target = NULL;
		vfs_showexport(mp, &args.la.export, &lmp->layerm_export);
		return copyout(&args, data, sizeof(args));
	}
#endif
	/*
	 * Get argument
	 */
	error = copyin(data, &args, sizeof(struct null_args));
	if (error)
		return (error);

	/*
	 * Update only does export updating.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		lmp = MOUNTTOLAYERMOUNT(mp);
		if (args.nulla_target == NULL)
			return (vfs_export(mp, &lmp->layerm_export,
			    &args.la.export));
		else
			return (EOPNOTSUPP);
	}

	/*
	 * Find lower node
	 */
	NDINIT(ndp, LOOKUP, FOLLOW|LOCKLEAF,
		UIO_USERSPACE, args.la.target, p);
	if ((error = namei(ndp)) != 0)
		return (error);

	/*
	 * Sanity check on lower vnode
	 */
	lowerrootvp = ndp->ni_vp;

	/*
	 * First cut at fixing up upper mount point
	 */
	nmp = (struct null_mount *) malloc(sizeof(struct null_mount),
	    M_MISCFSMNT, M_WAITOK);
	memset(nmp, 0, sizeof(struct null_mount));

	mp->mnt_data = nmp;
	nmp->nullm_vfs = lowerrootvp->v_mount;
	if (nmp->nullm_vfs->mnt_flag & MNT_LOCAL)
		mp->mnt_flag |= MNT_LOCAL;

	/*
	 * Make sure that the mount point is sufficiently initialized
	 * that the node create call will work.
	 */
	vfs_getnewfsid(mp);

	nmp->nullm_size = sizeof(struct null_node);
	nmp->nullm_tag = VT_NULL;
	nmp->nullm_bypass = layer_bypass;
	nmp->nullm_alloc = layer_node_alloc;	/* the default alloc is fine */
	nmp->nullm_vnodeop_p = nullfs_vnodeop_p;
	simple_lock_init(&nmp->nullm_hashlock);
	nmp->nullm_node_hashtbl = hashinit(desiredvnodes, M_CACHE,
	    M_WAITOK, &nmp->nullm_node_hash);

	/*
	 * Fix up null node for root vnode
	 */
	error = layer_node_create(mp, lowerrootvp, &vp);
	/*
	 * Make sure the fixup worked
	 */
	if (error) {
		vput(lowerrootvp);
		free(nmp->nullm_node_hashtbl, M_CACHE);
		free(nmp, M_MISCFSMNT);
		return (error);
	}
	/*
	 * Unlock the node
	 */
	VOP_UNLOCK(vp, 0, p);

	/*
	 * Keep a held reference to the root vnode.
	 * It is vrele'd in nullfs_unmount.
	 */
	vp->v_flag |= VROOT;
	nmp->nullm_rootvp = vp;

	(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
	memset(mp->mnt_stat.f_mntonname + size, 0, MNAMELEN - size);
	(void) copyinstr(args.la.target, mp->mnt_stat.f_mntfromname,
	    MNAMELEN - 1, &size);
	memset(mp->mnt_stat.f_mntfromname + size, 0, MNAMELEN - size);
#ifdef NULLFS_DIAGNOSTIC
	printf("nullfs_mount: lower %s, alias at %s\n",
	    mp->mnt_stat.f_mntfromname, mp->mnt_stat.f_mntonname);
#endif
	return (0);
}

/*
 * Free reference to null layer
 */
int
nullfs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
{
	struct null_mount *nmp = MOUNTTONULLMOUNT(mp);
	struct vnode *null_rootvp = nmp->nullm_rootvp;
	int error;
	int flags = 0;

#ifdef NULLFS_DIAGNOSTIC
	printf("nullfs_unmount(mp = %p)\n", mp);
#endif

	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;

	/*
	 * Clear out buffer cache.  I don't think we
	 * ever get anything cached at this level at the
	 * moment, but who knows...
	 */
#if 0
	mntflushbuf(mp, 0);
	if (mntinvalbuf(mp, 1))
		return (EBUSY);
#endif
	if (null_rootvp->v_usecount > 1 && !(flags & FORCECLOSE))
		return (EBUSY);
	if ((error = vflush(mp, null_rootvp, flags)) != 0)
		return (error);

#ifdef NULLFS_DIAGNOSTIC
	vprint("alias root of lower", null_rootvp);
#endif
	/*
	 * Release reference on underlying root vnode
	 */
	vrele(null_rootvp);

	/*
	 * And blow it away for future re-use
	 */
	vgone(null_rootvp);

	/*
	 * Finally, throw away the null_mount structure
	 */
	free(nmp->nullm_node_hashtbl, M_CACHE);
	free(mp->mnt_data, M_MISCFSMNT);
	mp->mnt_data = NULL;
	return (0);
}

extern const struct vnodeopv_desc nullfs_vnodeop_opv_desc;

const struct vnodeopv_desc * const nullfs_vnodeopv_descs[] = {
	&nullfs_vnodeop_opv_desc,
	NULL,
};

const struct vfsops nullfs_vfsops = {
	nullfs_mount,
	layerfs_start,
	nullfs_unmount,
	layerfs_root,
	layerfs_quotactl,
	layerfs_statfs,
	layerfs_sync,
	layerfs_vget,
	layerfs_fhtovp,
	layerfs_vptofh,
	layerfs_init,
	layerfs_sysctl,
	layerfs_checkexp
};
@


1.22
log
@use M_MISCFSMNT to allocate nullfs memory, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.21 2004/05/20 18:32:37 tedu Exp $	*/
@


1.21
log
@remove more caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.20 2004/05/18 12:37:51 pedro Exp $	*/
d161 1
a161 1
	    M_UFSMNT, M_WAITOK);		/* XXX */
d194 1
a194 1
		free(nmp, M_UFSMNT);
d276 1
a276 1
	return 0;
@


1.20
log
@useless caddr_t casts removal, same sha1s
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.19 2004/05/18 02:23:41 pedro Exp $	*/
d164 1
a164 1
	mp->mnt_data = (qaddr_t)nmp;
@


1.19
log
@fix memory leak, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.18 2004/03/03 06:01:49 tedu Exp $	*/
d128 1
a128 1
	error = copyin(data, (caddr_t)&args, sizeof(struct null_args));
d162 1
a162 1
	memset((caddr_t)nmp, 0, sizeof(struct null_mount));
@


1.18
log
@support forced unmounts.  pr2394 from peter werner
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.17 2003/08/14 07:46:39 mickey Exp $	*/
d194 1
@


1.17
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.16 2003/06/02 23:28:10 millert Exp $	*/
d251 1
a251 1
	if (null_rootvp->v_usecount > 1)
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.15 2003/05/12 21:00:39 tedu Exp $	*/
d285 1
a285 1
struct vfsops nullfs_vfsops = {
@


1.15
log
@most of the fixes for nullfs.  use the new common layer stuff in genfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.14 2003/02/24 22:32:46 tedu Exp $	*/
d51 1
a51 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@use M_MISCFSMNT instead of M_UFSMNT for mount data

ok art@@
@
text
@d1 2
a2 2
/*	$OpenBSD: null_vfsops.c,v 1.13 2002/03/14 01:27:08 millert Exp $	*/
/*	$NetBSD: null_vfsops.c,v 1.11 1996/05/10 22:50:56 jtk Exp $	*/
d5 33
a37 1
 * Copyright (c) 1992, 1993
d73 1
a73 1
 *	@@(#)null_vfsops.c	8.2 (Berkeley) 1/21/94
d81 1
d84 1
a85 2
#include <sys/time.h>
#include <sys/types.h>
d90 1
d92 1
d95 1
a95 2
			  struct nameidata *, struct proc *);
int	nullfs_start(struct mount *, int, struct proc *);
d97 1
a97 8
int	nullfs_root(struct mount *, struct vnode **);
int	nullfs_quotactl(struct mount *, int, uid_t, caddr_t,
			     struct proc *);
int	nullfs_statfs(struct mount *, struct statfs *, struct proc *);
int	nullfs_sync(struct mount *, int, struct ucred *, struct proc *);
int	nullfs_vget(struct mount *, ino_t, struct vnode **);
int	nullfs_fhtovp(struct mount *, struct fid *, struct vnode **);
int	nullfs_vptofh(struct vnode *, struct fid *);
a108 1
	int error = 0;
d111 2
a112 2
	struct vnode *nullm_rootvp;
	struct null_mount *xmp;
d114 1
d119 8
a126 7

	/*
	 * Update is a no-op
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		return (EOPNOTSUPP);
		/* return VFS_MOUNT(MOUNTTONULLMOUNT(mp)->nullm_vfs, path, data, ndp, p);*/
d128 1
a128 1

d132 1
a132 1
	error = copyin(data, &args, sizeof(struct null_args));
d137 12
d151 2
a152 2
	NDINIT(ndp, LOOKUP, FOLLOW|WANTPARENT|LOCKLEAF,
		UIO_USERSPACE, args.target, p);
a160 11
	vrele(ndp->ni_dvp);
	ndp->ni_dvp = NULL;

	if (lowerrootvp->v_type != VDIR) {
		vput(lowerrootvp);
		return (EINVAL);
	}

	xmp = (struct null_mount *) malloc(sizeof(struct null_mount),
				M_MISCFSMNT, M_WAITOK);

d162 1
a162 1
	 * Save reference to underlying FS
d164 8
a171 1
	xmp->nullm_vfs = lowerrootvp->v_mount;
d174 2
a175 2
	 * Save reference.  Each mount also holds
	 * a reference on the root vnode.
d177 11
a187 1
	error = null_node_create(mp, lowerrootvp, &vp, 1);
d189 1
a189 1
	 * Unlock the node (either the lower or the alias)
d191 1
a191 1
	VOP_UNLOCK(vp, 0, p);
d193 1
a193 1
	 * Make sure the node alias worked
d196 2
a197 2
		vrele(lowerrootvp);
		free(xmp, M_MISCFSMNT);
d200 4
d209 2
a210 7
	nullm_rootvp = vp;
	nullm_rootvp->v_flag |= VROOT;
	xmp->nullm_rootvp = nullm_rootvp;
	if (NULLVPTOLOWERVP(nullm_rootvp)->v_mount->mnt_flag & MNT_LOCAL)
		mp->mnt_flag |= MNT_LOCAL;
	mp->mnt_data = (qaddr_t) xmp;
	vfs_getnewfsid(mp);
d213 4
a216 4
	bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);
	(void) copyinstr(args.target, mp->mnt_stat.f_mntfromname, MNAMELEN - 1, 
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d219 1
a219 1
		mp->mnt_stat.f_mntfromname, mp->mnt_stat.f_mntonname);
a224 16
 * VFS start.  Nothing needed here - the start routine
 * on the underlying filesystem will have been called
 * when that filesystem was mounted.
 */
int
nullfs_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
{

	return (0);
	/* return VFS_START(MOUNTTONULLMOUNT(mp)->nullm_vfs, flags, p); */
}

/*
d233 2
a234 1
	struct vnode *nullm_rootvp = MOUNTTONULLMOUNT(mp)->nullm_rootvp;
d242 1
a242 1
	if (mntflags & MNT_FORCE) {
a243 1
	}
d251 1
a251 1
	mntflushbuf(mp, 0); 
d255 1
a255 1
	if (nullm_rootvp->v_usecount > 1)
d257 1
a257 1
	if ((error = vflush(mp, nullm_rootvp, flags)) != 0)
d261 2
a262 2
	vprint("alias root of lower", nullm_rootvp);
#endif	 
d266 2
a267 1
	vrele(nullm_rootvp);
d271 2
a272 1
	vgone(nullm_rootvp);
d276 1
d278 1
a278 1
	mp->mnt_data = 0;
d282 1
a282 122
int
nullfs_root(mp, vpp)
	struct mount *mp;
	struct vnode **vpp;
{
	struct vnode *vp;
	struct proc *p = curproc;

#ifdef NULLFS_DIAGNOSTIC
	printf("nullfs_root(mp = %p, vp = %p->%p)\n", mp,
			MOUNTTONULLMOUNT(mp)->nullm_rootvp,
			NULLVPTOLOWERVP(MOUNTTONULLMOUNT(mp)->nullm_rootvp)
			);
#endif

	/*
	 * Return locked reference to root.
	 */
	vp = MOUNTTONULLMOUNT(mp)->nullm_rootvp;
	VREF(vp);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	*vpp = vp;
	return 0;
}

int
nullfs_quotactl(mp, cmd, uid, arg, p)
	struct mount *mp;
	int cmd;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

	return VFS_QUOTACTL(MOUNTTONULLMOUNT(mp)->nullm_vfs, cmd, uid, arg, p);
}

int
nullfs_statfs(mp, sbp, p)
	struct mount *mp;
	struct statfs *sbp;
	struct proc *p;
{
	int error;
	struct statfs mstat;

#ifdef NULLFS_DIAGNOSTIC
	printf("nullfs_statfs(mp = %p, vp = %p->%p)\n", mp,
			MOUNTTONULLMOUNT(mp)->nullm_rootvp,
			NULLVPTOLOWERVP(MOUNTTONULLMOUNT(mp)->nullm_rootvp)
			);
#endif

	bzero(&mstat, sizeof(mstat));

	error = VFS_STATFS(MOUNTTONULLMOUNT(mp)->nullm_vfs, &mstat, p);
	if (error)
		return (error);

	/* now copy across the "interesting" information and fake the rest */
	sbp->f_flags = mstat.f_flags;
	sbp->f_bsize = mstat.f_bsize;
	sbp->f_iosize = mstat.f_iosize;
	sbp->f_blocks = mstat.f_blocks;
	sbp->f_bfree = mstat.f_bfree;
	sbp->f_bavail = mstat.f_bavail;
	sbp->f_files = mstat.f_files;
	sbp->f_ffree = mstat.f_ffree;
	if (sbp != &mp->mnt_stat) {
		bcopy(&mp->mnt_stat.f_fsid, &sbp->f_fsid, sizeof(sbp->f_fsid));
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
	return (0);
}

int
nullfs_sync(mp, waitfor, cred, p)
	struct mount *mp;
	int waitfor;
	struct ucred *cred;
	struct proc *p;
{

	/*
	 * XXX - Assumes no data cached at null layer.
	 */
	return (0);
}

int
nullfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{
	
	return VFS_VGET(MOUNTTONULLMOUNT(mp)->nullm_vfs, ino, vpp);
}

int
nullfs_fhtovp(mp, fidp, vpp)
	struct mount *mp;
	struct fid *fidp;
	struct vnode **vpp;
{

	return (EOPNOTSUPP);
}

int
nullfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
{

	return (EOPNOTSUPP);
}

#define nullfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
           size_t, struct proc *))eopnotsupp)
d284 4
a287 2
#define nullfs_checkexp ((int (*)(struct mount *, struct mbuf *,	\
	int *, struct ucred **))eopnotsupp)
d289 1
a289 1
struct vfsops null_vfsops = {
d291 1
a291 1
	nullfs_start,
d293 10
a302 10
	nullfs_root,
	nullfs_quotactl,
	nullfs_statfs,
	nullfs_sync,
	nullfs_vget,
	nullfs_fhtovp,
	nullfs_vptofh,
	nullfs_init,
	nullfs_sysctl,
	nullfs_checkexp
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.12 2001/02/20 01:50:10 assar Exp $	*/
d131 1
a131 1
				M_UFSMNT, M_WAITOK);	/* XXX */
d152 1
a152 1
		free(xmp, M_UFSMNT);	/* XXX */
d246 1
a246 1
	free(mp->mnt_data, M_UFSMNT);	/* XXX */
@


1.12
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.11 2000/02/07 04:57:16 assar Exp $	*/
d60 12
a71 12
int	nullfs_mount __P((struct mount *, const char *, void *,
			  struct nameidata *, struct proc *));
int	nullfs_start __P((struct mount *, int, struct proc *));
int	nullfs_unmount __P((struct mount *, int, struct proc *));
int	nullfs_root __P((struct mount *, struct vnode **));
int	nullfs_quotactl __P((struct mount *, int, uid_t, caddr_t,
			     struct proc *));
int	nullfs_statfs __P((struct mount *, struct statfs *, struct proc *));
int	nullfs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int	nullfs_vget __P((struct mount *, ino_t, struct vnode **));
int	nullfs_fhtovp __P((struct mount *, struct fid *, struct vnode **));
int	nullfs_vptofh __P((struct vnode *, struct fid *));
d371 2
a372 2
#define nullfs_sysctl ((int (*) __P((int *, u_int, void *, size_t *, void *, \
           size_t, struct proc *)))eopnotsupp)
d374 2
a375 2
#define nullfs_checkexp ((int (*) __P((struct mount *, struct mbuf *,	\
	int *, struct ucred **)))eopnotsupp)
@


1.12.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.12 2001/02/20 01:50:10 assar Exp $	*/
d60 12
a71 12
int	nullfs_mount(struct mount *, const char *, void *,
			  struct nameidata *, struct proc *);
int	nullfs_start(struct mount *, int, struct proc *);
int	nullfs_unmount(struct mount *, int, struct proc *);
int	nullfs_root(struct mount *, struct vnode **);
int	nullfs_quotactl(struct mount *, int, uid_t, caddr_t,
			     struct proc *);
int	nullfs_statfs(struct mount *, struct statfs *, struct proc *);
int	nullfs_sync(struct mount *, int, struct ucred *, struct proc *);
int	nullfs_vget(struct mount *, ino_t, struct vnode **);
int	nullfs_fhtovp(struct mount *, struct fid *, struct vnode **);
int	nullfs_vptofh(struct vnode *, struct fid *);
d371 2
a372 2
#define nullfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
           size_t, struct proc *))eopnotsupp)
d374 2
a375 2
#define nullfs_checkexp ((int (*)(struct mount *, struct mbuf *,	\
	int *, struct ucred **))eopnotsupp)
@


1.12.6.2
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: null_vfsops.c,v 1.38 2002/09/21 18:09:29 christos Exp $	*/
d5 1
a5 33
 * Copyright (c) 1999 National Aeronautics & Space Administration
 * All rights reserved.
 *
 * This software was written by William Studenmund of the
 * Numerical Aerospace Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the National Aeronautics & Space Administration
 *    nor the names of its contributors may be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NATIONAL AERONAUTICS & SPACE ADMINISTRATION
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ADMINISTRATION OR CONTRIB-
 * UTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1992, 1993, 1995
d41 1
a41 1
 *	@@(#)null_vfsops.c	8.7 (Berkeley) 5/14/95
a48 1

d51 1
d53 1
a53 1
#include <sys/proc.h>
a57 1

a58 1
#include <miscfs/genfs/layer_extern.h>
d61 2
a62 1
	    struct nameidata *, struct proc *);
d64 8
a71 1

d83 1
d86 2
a87 2
	struct null_mount *nmp;
	struct layer_mount *lmp;
a88 1
	int error = 0;
d93 7
a99 8
#if 0
	if (mp->mnt_flag & MNT_GETARGS) {
		lmp = MOUNTTOLAYERMOUNT(mp);
		if (lmp == NULL)
			return EIO;
		args.la.target = NULL;
		vfs_showexport(mp, &args.la.export, &lmp->layerm_export);
		return copyout(&args, data, sizeof(args));
d101 1
a101 1
#endif
d105 1
a105 1
	error = copyin(data, (caddr_t)&args, sizeof(struct null_args));
a109 12
	 * Update only does export updating.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		lmp = MOUNTTOLAYERMOUNT(mp);
		if (args.nulla_target == NULL)
			return (vfs_export(mp, &lmp->layerm_export,
			    &args.la.export));
		else
			return (EOPNOTSUPP);
	}

	/*
d112 2
a113 2
	NDINIT(ndp, LOOKUP, FOLLOW|LOCKLEAF,
		UIO_USERSPACE, args.la.target, p);
d122 11
d134 1
a134 1
	 * First cut at fixing up upper mount point
d136 1
a136 8
	nmp = (struct null_mount *) malloc(sizeof(struct null_mount),
	    M_UFSMNT, M_WAITOK);		/* XXX */
	memset((caddr_t)nmp, 0, sizeof(struct null_mount));

	mp->mnt_data = (qaddr_t)nmp;
	nmp->nullm_vfs = lowerrootvp->v_mount;
	if (nmp->nullm_vfs->mnt_flag & MNT_LOCAL)
		mp->mnt_flag |= MNT_LOCAL;
d139 2
a140 2
	 * Make sure that the mount point is sufficiently initialized
	 * that the node create call will work.
d142 1
a142 11
	vfs_getnewfsid(mp);

	nmp->nullm_size = sizeof(struct null_node);
	nmp->nullm_tag = VT_NULL;
	nmp->nullm_bypass = layer_bypass;
	nmp->nullm_alloc = layer_node_alloc;	/* the default alloc is fine */
	nmp->nullm_vnodeop_p = nullfs_vnodeop_p;
	simple_lock_init(&nmp->nullm_hashlock);
	nmp->nullm_node_hashtbl = hashinit(desiredvnodes, M_CACHE,
	    M_WAITOK, &nmp->nullm_node_hash);

d144 1
a144 1
	 * Fix up null node for root vnode
d146 1
a146 1
	error = layer_node_create(mp, lowerrootvp, &vp);
d148 1
a148 1
	 * Make sure the fixup worked
d151 2
a152 2
		vput(lowerrootvp);
		free(nmp->nullm_node_hashtbl, M_CACHE);
a154 4
	/*
	 * Unlock the node
	 */
	VOP_UNLOCK(vp, 0, p);
d160 7
a166 2
	vp->v_flag |= VROOT;
	nmp->nullm_rootvp = vp;
d169 4
a172 4
	memset(mp->mnt_stat.f_mntonname + size, 0, MNAMELEN - size);
	(void) copyinstr(args.la.target, mp->mnt_stat.f_mntfromname,
	    MNAMELEN - 1, &size);
	memset(mp->mnt_stat.f_mntfromname + size, 0, MNAMELEN - size);
d175 1
a175 1
	    mp->mnt_stat.f_mntfromname, mp->mnt_stat.f_mntonname);
d181 16
d205 1
a205 2
	struct null_mount *nmp = MOUNTTONULLMOUNT(mp);
	struct vnode *null_rootvp = nmp->nullm_rootvp;
d213 1
a213 1
	if (mntflags & MNT_FORCE)
d215 1
d223 1
a223 1
	mntflushbuf(mp, 0);
d227 1
a227 1
	if (null_rootvp->v_usecount > 1)
d229 1
a229 1
	if ((error = vflush(mp, null_rootvp, flags)) != 0)
d233 2
a234 2
	vprint("alias root of lower", null_rootvp);
#endif
d238 1
a238 2
	vrele(null_rootvp);

d242 23
a264 1
	vgone(null_rootvp);
d267 1
a267 1
	 * Finally, throw away the null_mount structure
d269 4
a272 3
	free(nmp->nullm_node_hashtbl, M_CACHE);
	free(mp->mnt_data, M_MISCFSMNT);
	mp->mnt_data = NULL;
d276 97
a372 1
extern const struct vnodeopv_desc nullfs_vnodeop_opv_desc;
d374 2
a375 4
const struct vnodeopv_desc * const nullfs_vnodeopv_descs[] = {
	&nullfs_vnodeop_opv_desc,
	NULL,
};
d377 1
a377 1
struct vfsops nullfs_vfsops = {
d379 1
a379 1
	layerfs_start,
d381 10
a390 10
	layerfs_root,
	layerfs_quotactl,
	layerfs_statfs,
	layerfs_sync,
	layerfs_vget,
	layerfs_fhtovp,
	layerfs_vptofh,
	layerfs_init,
	layerfs_sysctl,
	layerfs_checkexp
@


1.11
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.10 1999/05/31 17:34:49 millert Exp $	*/
d60 1
a60 1
int	nullfs_mount __P((struct mount *, const char *, caddr_t,
d79 1
a79 1
	caddr_t data;
d105 1
a105 1
	error = copyin(data, (caddr_t)&args, sizeof(struct null_args));
@


1.11.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.12 2001/02/20 01:50:10 assar Exp $	*/
d60 1
a60 1
int	nullfs_mount __P((struct mount *, const char *, void *,
d79 1
a79 1
	void *data;
d105 1
a105 1
	error = copyin(data, &args, sizeof(struct null_args));
@


1.11.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 12
a71 12
int	nullfs_mount(struct mount *, const char *, void *,
			  struct nameidata *, struct proc *);
int	nullfs_start(struct mount *, int, struct proc *);
int	nullfs_unmount(struct mount *, int, struct proc *);
int	nullfs_root(struct mount *, struct vnode **);
int	nullfs_quotactl(struct mount *, int, uid_t, caddr_t,
			     struct proc *);
int	nullfs_statfs(struct mount *, struct statfs *, struct proc *);
int	nullfs_sync(struct mount *, int, struct ucred *, struct proc *);
int	nullfs_vget(struct mount *, ino_t, struct vnode **);
int	nullfs_fhtovp(struct mount *, struct fid *, struct vnode **);
int	nullfs_vptofh(struct vnode *, struct fid *);
d371 2
a372 2
#define nullfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
           size_t, struct proc *))eopnotsupp)
d374 2
a375 2
#define nullfs_checkexp ((int (*)(struct mount *, struct mbuf *,	\
	int *, struct ucred **))eopnotsupp)
@


1.11.2.3
log
@Sync the SMP branch with 3.3
@
text
@d131 1
a131 1
				M_MISCFSMNT, M_WAITOK);
d152 1
a152 1
		free(xmp, M_MISCFSMNT);
d246 1
a246 1
	free(mp->mnt_data, M_MISCFSMNT);
@


1.11.2.4
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d2 1
a2 1
/*	$NetBSD: null_vfsops.c,v 1.38 2002/09/21 18:09:29 christos Exp $	*/
d5 1
a5 33
 * Copyright (c) 1999 National Aeronautics & Space Administration
 * All rights reserved.
 *
 * This software was written by William Studenmund of the
 * Numerical Aerospace Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the National Aeronautics & Space Administration
 *    nor the names of its contributors may be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NATIONAL AERONAUTICS & SPACE ADMINISTRATION
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ADMINISTRATION OR CONTRIB-
 * UTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1992, 1993, 1995
d41 1
a41 1
 *	@@(#)null_vfsops.c	8.7 (Berkeley) 5/14/95
a48 1

d51 1
d53 1
a53 1
#include <sys/proc.h>
a57 1

a58 1
#include <miscfs/genfs/layer_extern.h>
d61 2
a62 1
	    struct nameidata *, struct proc *);
d64 8
a71 1

d83 1
d86 2
a87 2
	struct null_mount *nmp;
	struct layer_mount *lmp;
a88 1
	int error = 0;
d93 7
a99 8
#if 0
	if (mp->mnt_flag & MNT_GETARGS) {
		lmp = MOUNTTOLAYERMOUNT(mp);
		if (lmp == NULL)
			return EIO;
		args.la.target = NULL;
		vfs_showexport(mp, &args.la.export, &lmp->layerm_export);
		return copyout(&args, data, sizeof(args));
d101 1
a101 1
#endif
d105 1
a105 1
	error = copyin(data, (caddr_t)&args, sizeof(struct null_args));
a109 12
	 * Update only does export updating.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		lmp = MOUNTTOLAYERMOUNT(mp);
		if (args.nulla_target == NULL)
			return (vfs_export(mp, &lmp->layerm_export,
			    &args.la.export));
		else
			return (EOPNOTSUPP);
	}

	/*
d112 2
a113 2
	NDINIT(ndp, LOOKUP, FOLLOW|LOCKLEAF,
		UIO_USERSPACE, args.la.target, p);
d122 11
d134 1
a134 1
	 * First cut at fixing up upper mount point
d136 1
a136 8
	nmp = (struct null_mount *) malloc(sizeof(struct null_mount),
	    M_UFSMNT, M_WAITOK);		/* XXX */
	memset((caddr_t)nmp, 0, sizeof(struct null_mount));

	mp->mnt_data = (qaddr_t)nmp;
	nmp->nullm_vfs = lowerrootvp->v_mount;
	if (nmp->nullm_vfs->mnt_flag & MNT_LOCAL)
		mp->mnt_flag |= MNT_LOCAL;
d139 2
a140 2
	 * Make sure that the mount point is sufficiently initialized
	 * that the node create call will work.
d142 1
a142 11
	vfs_getnewfsid(mp);

	nmp->nullm_size = sizeof(struct null_node);
	nmp->nullm_tag = VT_NULL;
	nmp->nullm_bypass = layer_bypass;
	nmp->nullm_alloc = layer_node_alloc;	/* the default alloc is fine */
	nmp->nullm_vnodeop_p = nullfs_vnodeop_p;
	simple_lock_init(&nmp->nullm_hashlock);
	nmp->nullm_node_hashtbl = hashinit(desiredvnodes, M_CACHE,
	    M_WAITOK, &nmp->nullm_node_hash);

d144 1
a144 1
	 * Fix up null node for root vnode
d146 1
a146 1
	error = layer_node_create(mp, lowerrootvp, &vp);
d148 1
a148 1
	 * Make sure the fixup worked
d151 2
a152 2
		vput(lowerrootvp);
		free(nmp->nullm_node_hashtbl, M_CACHE);
a154 4
	/*
	 * Unlock the node
	 */
	VOP_UNLOCK(vp, 0, p);
d160 7
a166 2
	vp->v_flag |= VROOT;
	nmp->nullm_rootvp = vp;
d169 4
a172 4
	memset(mp->mnt_stat.f_mntonname + size, 0, MNAMELEN - size);
	(void) copyinstr(args.la.target, mp->mnt_stat.f_mntfromname,
	    MNAMELEN - 1, &size);
	memset(mp->mnt_stat.f_mntfromname + size, 0, MNAMELEN - size);
d175 1
a175 1
	    mp->mnt_stat.f_mntfromname, mp->mnt_stat.f_mntonname);
d181 16
d205 1
a205 2
	struct null_mount *nmp = MOUNTTONULLMOUNT(mp);
	struct vnode *null_rootvp = nmp->nullm_rootvp;
d213 1
a213 1
	if (mntflags & MNT_FORCE)
d215 1
d223 1
a223 1
	mntflushbuf(mp, 0);
d227 1
a227 1
	if (null_rootvp->v_usecount > 1)
d229 1
a229 1
	if ((error = vflush(mp, null_rootvp, flags)) != 0)
d233 2
a234 2
	vprint("alias root of lower", null_rootvp);
#endif
d238 1
a238 2
	vrele(null_rootvp);

d242 1
a242 2
	vgone(null_rootvp);

a245 1
	free(nmp->nullm_node_hashtbl, M_CACHE);
d247 1
a247 1
	mp->mnt_data = NULL;
d251 122
a372 1
extern const struct vnodeopv_desc nullfs_vnodeop_opv_desc;
d374 2
a375 4
const struct vnodeopv_desc * const nullfs_vnodeopv_descs[] = {
	&nullfs_vnodeop_opv_desc,
	NULL,
};
d377 1
a377 1
struct vfsops nullfs_vfsops = {
d379 1
a379 1
	layerfs_start,
d381 10
a390 10
	layerfs_root,
	layerfs_quotactl,
	layerfs_statfs,
	layerfs_sync,
	layerfs_vget,
	layerfs_fhtovp,
	layerfs_vptofh,
	layerfs_init,
	layerfs_sysctl,
	layerfs_checkexp
@


1.11.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.11.2.4 2003/05/16 00:29:43 niklas Exp $	*/
d51 5
a55 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d285 1
a285 1
const struct vfsops nullfs_vfsops = {
@


1.11.2.7
log
@Merge with the trunk
@
text
@d128 1
a128 1
	error = copyin(data, &args, sizeof(struct null_args));
d161 2
a162 2
	    M_MISCFSMNT, M_WAITOK);
	memset(nmp, 0, sizeof(struct null_mount));
d164 1
a164 1
	mp->mnt_data = nmp;
a193 1
		free(nmp, M_MISCFSMNT);
d251 1
a251 1
	if (null_rootvp->v_usecount > 1 && !(flags & FORCECLOSE))
d275 1
a275 1
	return (0);
@


1.10
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.9 1998/08/06 23:38:39 csapuntz Exp $	*/
d70 1
a70 2
int	nullfs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
			   struct vnode **, int *, struct ucred **));
d353 1
a353 1
nullfs_fhtovp(mp, fidp, nam, vpp, exflagsp, credanonp)
a355 1
	struct mbuf *nam;
a356 2
	int *exflagsp;
	struct ucred**credanonp;
d374 3
d389 2
a390 1
	nullfs_sysctl
@


1.9
log
@

Null mounts must be from directories
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.8 1998/02/08 22:41:38 tholo Exp $	*/
a311 1
	sbp->f_type = mstat.f_type;
@


1.8
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.7 1997/11/06 05:58:40 csapuntz Exp $	*/
d125 5
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.6 1997/10/06 20:20:30 deraadt Exp $	*/
d60 1
a60 1
int	nullfs_mount __P((struct mount *, char *, caddr_t,
d79 1
a79 1
	char *path;
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.4 1997/09/11 05:26:12 millert Exp $	*/
d51 1
d142 1
a142 1
	VOP_UNLOCK(vp);
d162 1
a162 1
	getnewfsid(mp, makefstype(MOUNT_LOFS));
a203 1
	extern int doforce;
a209 3
		/* lofs can never be rootfs so don't check for it */
		if (!doforce)
			return (EINVAL);
d253 1
d267 1
a267 1
	VOP_LOCK(vp);
d321 1
a321 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d371 3
a374 1
	MOUNT_NULL,
d386 1
@


1.5
log
@VFS Lite2 Changes
@
text
@a50 1
#include <sys/proc.h>
d141 1
a141 1
	VOP_UNLOCK(vp, 0, p);
d161 1
a161 1
	vfs_getnewfsid(mp);
d203 1
d210 3
a255 1
	struct proc *p = curproc;
d269 1
a269 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d323 1
a323 1
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
a372 3
#define nullfs_sysctl ((int (*) __P((int *, u_int, void *, size_t *, void *, \
           size_t, struct proc *)))eopnotsupp)

d374 1
a385 1
	nullfs_sysctl
@


1.4
log
@Fix {KERNFS,NULLFS,UMAPFS,UNION}_DIAGNOSTIC kernel compilation errors.
From Alan Barrett <apb@@iafrica.com> with some changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: null_vfsops.c,v 1.3 1996/05/22 12:04:36 deraadt Exp $	*/
d51 1
d142 1
a142 1
	VOP_UNLOCK(vp);
d162 1
a162 1
	getnewfsid(mp, makefstype(MOUNT_LOFS));
a203 1
	extern int doforce;
a209 3
		/* lofs can never be rootfs so don't check for it */
		if (!doforce)
			return (EINVAL);
d253 1
d267 1
a267 1
	VOP_LOCK(vp);
d321 1
a321 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d371 3
a374 1
	MOUNT_NULL,
d386 1
@


1.3
log
@latest locking changes from jtk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 1
a91 1
	printf("nullfs_mount(mp = %x)\n", mp);
d206 1
a206 1
	printf("nullfs_unmount(mp = %x)\n", mp);
d258 1
a258 1
	printf("nullfs_root(mp = %x, vp = %x->%x)\n", mp,
d296 1
a296 1
	printf("nullfs_statfs(mp = %x, vp = %x->%x)\n", mp,
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: null_vfsops.c,v 1.10 1996/02/09 22:40:31 christos Exp $	*/
d137 1
a137 1
	error = null_node_create(mp, lowerrootvp, &vp);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: null_vfsops.c,v 1.9 1995/06/18 14:47:32 cgd Exp $	*/
d59 13
d105 2
a106 1
	if (error = copyin(data, (caddr_t)&args, sizeof(struct null_args)))
d114 1
a114 1
	if (error = namei(ndp))
d228 1
a228 1
	if (error = vflush(mp, nullm_rootvp, flags))
a371 2

int nullfs_init __P((void));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
