head	1.26;
access;
symbols
	OPENBSD_3_8:1.25.0.10
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.8
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.6
	OPENBSD_2_1_BASE:1.4
	syms:1.4.0.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2005.11.24.12.08.16;	author pedro;	state dead;
branches;
next	1.25;

1.25
date	2003.08.14.07.46.39;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.11.10.19.24;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.28.10;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.11.01.47.00;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.31.20.41.29;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.12.02.03.46;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.17.04.29.52;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.06.27.04.58.42;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.20.01.50.09;	author assar;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.07.04.57.16;	author assar;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.05.31.17.34.49;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.02.26.03.44.16;	author art;	state Exp;
branches;
next	1.10;

1.10
date	98.12.24.01.40.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.02.08.22.41.38;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.11.06.05.58.35;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.20.20.25;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.15.19.04;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.09.11.05.26.10;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.20.14.30.08;	author mickey;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	96.05.02.13.20.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.55.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.00;	author deraadt;	state Exp;
branches;
next	;

1.4.4.1
date	96.10.14.13.38.03;	author mickey;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	97.05.29.00.52.39;	author mickey;	state Exp;
branches;
next	;

1.13.2.1
date	2001.05.14.22.32.54;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.07.04.10.49.09;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.13.2.9;

1.13.2.9
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.05.19.22.36.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Remove kernfs, okay deraadt@@.
@
text
@/*	$OpenBSD: kernfs_vfsops.c,v 1.25 2003/08/14 07:46:39 mickey Exp $	*/
/*	$NetBSD: kernfs_vfsops.c,v 1.26 1996/04/22 01:42:27 christos Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software donated to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kernfs_vfsops.c	8.5 (Berkeley) 6/15/94
 */

/*
 * Kernel params Filesystem
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/types.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>	/* for uvmexp */

#include <miscfs/specfs/specdev.h>
#include <miscfs/kernfs/kernfs.h>

dev_t rrootdev = NODEV;

void	kernfs_get_rrootdev(void);
int	kernfs_mount(struct mount *, const char *, void *, struct nameidata *,
			  struct proc *);
int	kernfs_start(struct mount *, int, struct proc *);
int	kernfs_unmount(struct mount *, int, struct proc *);
int	kernfs_root(struct mount *, struct vnode **);
int	kernfs_statfs(struct mount *, struct statfs *, struct proc *);

void
kernfs_get_rrootdev()
{
	static int tried = 0;
	int cmaj;

	if (tried) {
		/* Already did it once. */
		return;
	}
	tried = 1;

	if (rootdev == NODEV)
		return;
	for (cmaj = 0; cmaj < nchrdev; cmaj++) {
		rrootdev = makedev(cmaj, minor(rootdev));
		if (chrtoblk(rrootdev) == rootdev)
			return;
	}
	rrootdev = NODEV;
	printf("kernfs_get_rrootdev: no raw root device\n");
}

/*
 * Mount the Kernel params filesystem
 */
int
kernfs_mount(mp, path, data, ndp, p)
	struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
{
	size_t size;

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_mount(mp = %p)\n", mp);
#endif

	/*
	 * Update is a no-op
	 */
	if (mp->mnt_flag & MNT_UPDATE)
		return (EOPNOTSUPP);

	mp->mnt_flag |= MNT_LOCAL;
	vfs_getnewfsid(mp);

	(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
	bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);
	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
	bcopy("kernfs", mp->mnt_stat.f_mntfromname, sizeof("kernfs"));
#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_mount: at %s\n", mp->mnt_stat.f_mntonname);
#endif

	kernfs_get_rrootdev();
	return (0);
}

int
kernfs_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
{
	return (0);
}

int
kernfs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
{
	int error;
	int flags = 0;

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_unmount(mp = %p)\n", mp);
#endif

	if (mntflags & MNT_FORCE) {
		flags |= FORCECLOSE;
	}

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_unmount: calling vflush\n");
#endif
	if ((error = vflush(mp, 0, flags)) != 0)
		return (error);

	return (0);
}

int
kernfs_root(mp, vpp)
	struct mount *mp;
	struct vnode **vpp;
{
	const struct kern_target *kt;
	int error;

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_root(mp = %p)\n", mp);
#endif
	kt = kernfs_findtarget(".", 1);
	error = kernfs_allocvp(kt, mp, vpp);
	if (error)
		return (error);
	vn_lock(*vpp, LK_EXCLUSIVE | LK_RETRY, curproc);

	return (0);
}

int
kernfs_statfs(mp, sbp, p)
	struct mount *mp;
	struct statfs *sbp;
	struct proc *p;
{
	extern long numvnodes; /* XXX */

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_statfs(mp = %p)\n", mp);
#endif

	sbp->f_flags = 0;
	sbp->f_bsize = uvmexp.pagesize;
	sbp->f_iosize = uvmexp.pagesize;
	sbp->f_bfree = physmem - uvmexp.wired;
	sbp->f_blocks = physmem;
	sbp->f_bavail = 0;
	sbp->f_files = desiredvnodes;
	sbp->f_ffree = desiredvnodes - numvnodes;
	if (sbp != &mp->mnt_stat) {
		bcopy(&mp->mnt_stat.f_fsid, &sbp->f_fsid, sizeof(sbp->f_fsid));
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
	return (0);
}

const struct vfsops kernfs_vfsops = {
	kernfs_mount,
	kernfs_start,
	kernfs_unmount,
	kernfs_root,
	kernfs_quotactl,
	kernfs_statfs,
	kernfs_sync,
	kernfs_vget,
	kernfs_fhtovp,
	kernfs_vptofh,
	kernfs_init,
	kernfs_sysctl,
	kernfs_checkexp
};
@


1.25
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.24 2003/08/11 10:19:24 mickey Exp $	*/
@


1.24
log
@constify constant targets
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.23 2003/06/02 23:28:10 millert Exp $	*/
d212 1
a212 1
struct vfsops kernfs_vfsops = {
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.22 2003/05/11 01:47:00 tedu Exp $	*/
d168 1
a168 1
	struct kern_target *kt;
@


1.22
log
@use LK_EXCLUSIVE like all other file systems.
use LK_RETRY in kernfs_root().  "just in case" stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.21 2003/01/31 20:41:29 art Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@Sigh. I comitted the wrong diff in the last vfs changes.
These are the files that were ok:ed and tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.20 2003/01/31 17:37:50 art Exp $	*/
d182 1
a182 1
	vn_lock(*vpp, LK_EXCLUSIVE, curproc);
@


1.20
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.19 2002/10/12 02:03:46 krw Exp $	*/
a104 1
	int error = 0;
a105 2
	struct vnode *rvp;
	struct kern_target *kt;
a116 8
	kt = kernfs_findtarget(".", 1);
	error = kernfs_allocvp(kt, mp, &rvp);
	if (error)
		return (error);

	rvp->v_type = VDIR;
	rvp->v_flag |= VROOT;

a117 2
	mp->mnt_data = (qaddr_t)rvp;
	vrele(rvp);
d161 1
a161 2

	if ((error = vflush(mp, 0, flags)) != 0) {
a162 3
	}

	mp->mnt_data = 0;
d172 2
a173 1
	struct vnode *vp = (struct vnode *)mp->mnt_data;
d178 5
a182 3

	vget(vp, LK_EXCLUSIVE | LK_RETRY, curproc);
	*vpp = vp;
@


1.19
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Last bits of diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.18 2002/03/14 01:27:08 millert Exp $	*/
d105 1
d107 2
d120 8
d129 2
d174 2
a175 1
	if ((error = vflush(mp, 0, flags)) != 0)
d177 3
d189 1
a189 2
	struct kern_target *kt;
	int error;
a193 9
	kt = kernfs_findtarget(".", 1);
	/* this should never happen */
	if (kt == NULL) 
		panic("kernfs_root: findtarget returned NULL");
	
	error = kernfs_allocvp(kt, mp, vpp);
	/* this should never happen */
	if (error) 
		panic("kernfs_root: couldn't find root");
d195 4
a198 2
	return(0);
	
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.17 2002/02/17 04:29:52 art Exp $	*/
d181 1
a181 1
		panic("kernfs_root: findtarget returned NULL\n");
d186 1
a186 1
		panic("kernfs_root: couldn't find root\n");
@


1.17
log
@Cache vnodes, don't hold on to the root vnode, some cleanups, handle
physmem and usermem correctly.

kernel/2404 from peterw@@ifost.org.au with some small fixups from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.16 2001/11/06 19:53:20 miod Exp $	*/
d63 7
a69 7
void	kernfs_get_rrootdev __P((void));
int	kernfs_mount __P((struct mount *, const char *, void *, struct nameidata *,
			  struct proc *));
int	kernfs_start __P((struct mount *, int, struct proc *));
int	kernfs_unmount __P((struct mount *, int, struct proc *));
int	kernfs_root __P((struct mount *, struct vnode **));
int	kernfs_statfs __P((struct mount *, struct statfs *, struct proc *));
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.15 2001/06/27 04:58:42 art Exp $	*/
a62 1
int kernfs_init __P((struct vfsconf *));
a70 8
/*ARGSUSED*/
int
kernfs_init(vfsp)
	struct vfsconf *vfsp;
{
	return (0);
}

a104 1
	int error = 0;
a105 2
	struct kernfs_mount *fmp;
	struct vnode *rvp;
a116 12
	error = getnewvnode(VT_KERNFS, mp, kernfs_vnodeop_p, &rvp);
	if (error)
		return (error);

	MALLOC(fmp, struct kernfs_mount *, sizeof(struct kernfs_mount),
	    M_MISCFSMNT, M_WAITOK);
	rvp->v_type = VDIR;
	rvp->v_flag |= VROOT;
#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_mount: root vp = %p\n", rvp);
#endif
	fmp->kf_root = rvp;
a117 1
	mp->mnt_data = (qaddr_t)fmp;
a137 1

a148 1
	struct vnode *rootvp = VFSTOKERNFS(mp)->kf_root;
a157 7
	/*
	 * Clear out buffer cache.  I don't think we
	 * ever get anything cached at this level at the
	 * moment, but who knows...
	 */
	if (rootvp->v_usecount > 1)
		return (EBUSY);
d161 1
a161 1
	if ((error = vflush(mp, rootvp, flags)) != 0)
a163 13
#ifdef KERNFS_DIAGNOSTIC
	vprint("kernfs root", rootvp);
#endif
	/*
	 * Clean out the old root vnode for reuse.
	 */
	vrele(rootvp);
	vgone(rootvp);
	/*
	 * Finally, throw away the kernfs_mount structure
	 */
	free(mp->mnt_data, M_MISCFSMNT);
	mp->mnt_data = 0;
d172 2
a173 2
	struct vnode *vp;
	struct proc *p = curproc;
d178 9
d188 2
a189 8
	/*
	 * Return locked reference to root.
	 */
	vp = VFSTOKERNFS(mp)->kf_root;
	VREF(vp);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	*vpp = vp;
	return (0);
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.16 2001/11/06 19:53:20 miod Exp $	*/
d63 16
a78 7
void	kernfs_get_rrootdev(void);
int	kernfs_mount(struct mount *, const char *, void *, struct nameidata *,
			  struct proc *);
int	kernfs_start(struct mount *, int, struct proc *);
int	kernfs_unmount(struct mount *, int, struct proc *);
int	kernfs_root(struct mount *, struct vnode **);
int	kernfs_statfs(struct mount *, struct statfs *, struct proc *);
d114 1
d116 2
d129 12
d142 1
d163 1
d175 1
d185 7
d195 1
a195 1
	if ((error = vflush(mp, 0, flags)) != 0)
d198 13
d219 2
a220 2
	struct kern_target *kt;
	int error;
a224 9
	kt = kernfs_findtarget(".", 1);
	/* this should never happen */
	if (kt == NULL) 
		panic("kernfs_root: findtarget returned NULL\n");
	
	error = kernfs_allocvp(kt, mp, vpp);
	/* this should never happen */
	if (error) 
		panic("kernfs_root: couldn't find root\n");
d226 8
a233 2
	return(0);
	
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.16.2.1 2002/06/11 03:30:20 art Exp $	*/
d181 1
a181 1
		panic("kernfs_root: findtarget returned NULL");
d186 1
a186 1
		panic("kernfs_root: couldn't find root");
@


1.16.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d179 4
d184 3
a186 3
	if (error)
		return (error);
	vn_lock(*vpp, LK_EXCLUSIVE | LK_RETRY, curproc);
d188 2
a189 1
	return (0);
@


1.15
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.14 2001/02/20 01:50:09 assar Exp $	*/
a55 1
#include <vm/vm.h>
@


1.14
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.13 2000/02/07 04:57:16 assar Exp $	*/
a55 1
#if defined(UVM)
a57 3
#else
#include <sys/vmmeter.h>	/* for cnt */
#endif
a249 1
#if defined(UVM)
a252 5
#else
	sbp->f_bsize = cnt.v_page_size;
	sbp->f_iosize = cnt.v_page_size;
	sbp->f_bfree = physmem - cnt.v_wire_count;
#endif
@


1.13
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.12 1999/05/31 17:34:49 millert Exp $	*/
d70 1
a70 1
int	kernfs_mount __P((struct mount *, const char *, caddr_t, struct nameidata *,
d115 1
a115 1
	caddr_t data;
@


1.13.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.14 2001/02/20 01:50:09 assar Exp $	*/
d70 1
a70 1
int	kernfs_mount __P((struct mount *, const char *, void *, struct nameidata *,
d115 1
a115 1
	void *data;
@


1.13.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.13.2.1 2001/05/14 22:32:54 niklas Exp $	*/
d56 1
d59 3
d254 1
d258 5
@


1.13.2.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
@


1.13.2.4
log
@Merge in trunk
@
text
@d63 1
d72 8
d114 1
d116 2
d129 12
d142 1
d163 1
d175 1
d185 7
d195 1
a195 1
	if ((error = vflush(mp, 0, flags)) != 0)
d198 13
d219 2
a220 2
	struct kern_target *kt;
	int error;
a224 9
	kt = kernfs_findtarget(".", 1);
	/* this should never happen */
	if (kt == NULL) 
		panic("kernfs_root: findtarget returned NULL\n");
	
	error = kernfs_allocvp(kt, mp, vpp);
	/* this should never happen */
	if (error) 
		panic("kernfs_root: couldn't find root\n");
d226 8
a233 2
	return(0);
	
@


1.13.2.5
log
@Merge in -current from roughly a week ago
@
text
@d63 7
a69 7
void	kernfs_get_rrootdev(void);
int	kernfs_mount(struct mount *, const char *, void *, struct nameidata *,
			  struct proc *);
int	kernfs_start(struct mount *, int, struct proc *);
int	kernfs_unmount(struct mount *, int, struct proc *);
int	kernfs_root(struct mount *, struct vnode **);
int	kernfs_statfs(struct mount *, struct statfs *, struct proc *);
@


1.13.2.6
log
@Sync the SMP branch with 3.3
@
text
@d179 4
d184 3
a186 3
	if (error)
		return (error);
	vn_lock(*vpp, LK_EXCLUSIVE, curproc);
d188 2
a189 1
	return (0);
@


1.13.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.13.2.6 2003/03/28 00:00:20 niklas Exp $	*/
d182 1
a182 1
	vn_lock(*vpp, LK_EXCLUSIVE | LK_RETRY, curproc);
@


1.13.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.13.2.7 2003/05/13 19:21:29 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.13.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d168 1
a168 1
	const struct kern_target *kt;
d212 1
a212 1
const struct vfsops kernfs_vfsops = {
@


1.12
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.11 1999/02/26 03:44:16 art Exp $	*/
d288 2
a289 1
	kernfs_sysctl
@


1.11
log
@cnt is called uvmexp in uvm and the members have different names
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.10 1998/12/24 01:40:27 millert Exp $	*/
a252 3
#ifdef COMPAT_09
	sbp->f_type = 7;
#endif
a267 1
		sbp->f_type = mp->mnt_vfc->vfc_typenum;
@


1.10
log
@in kernfs_statfs set f_flags to 0
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.9 1998/02/08 22:41:38 tholo Exp $	*/
d55 5
d61 1
d257 5
d264 2
a266 1
	sbp->f_bfree = physmem - cnt.v_wire_count;
@


1.9
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.8 1997/11/06 05:58:35 csapuntz Exp $	*/
d250 1
@


1.8
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.7 1997/10/06 20:20:25 deraadt Exp $	*/
d64 1
a64 1
int	kernfs_mount __P((struct mount *, char *, caddr_t, struct nameidata *,
d108 1
a108 1
	char *path;
@


1.7
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.5 1997/09/11 05:26:10 millert Exp $	*/
d62 1
a62 1
void	kernfs_init __P((void));
a69 7
int	kernfs_quotactl __P((struct mount *, int, uid_t, caddr_t,
			     struct proc *));
int	kernfs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int	kernfs_vget __P((struct mount *, ino_t, struct vnode **));
int	kernfs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
			   struct vnode **, int *, struct ucred **));
int	kernfs_vptofh __P((struct vnode *, struct fid *));
d72 3
a74 2
void
kernfs_init()
d76 1
d142 1
a142 1
	getnewfsid(mp, makefstype(MOUNT_KERNFS));
a173 1
	extern int doforce;
a180 3
		/* kernfs can never be rootfs so don't check for it */
		if (!doforce)
			return (EINVAL);
d219 1
d230 1
a230 1
	VOP_LOCK(vp);
a235 12
kernfs_quotactl(mp, cmd, uid, arg, p)
	struct mount *mp;
	int cmd;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

	return (EOPNOTSUPP);
}

int
a248 2
#else
	sbp->f_type = 0;
d258 1
d263 1
a263 13
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
	return (0);
}

/*ARGSUSED*/
int
kernfs_sync(mp, waitfor, uc, p)
	struct mount *mp;
	int waitfor;
	struct ucred *uc;
	struct proc *p;
{

a266 38
/*
 * Kernfs flat namespace lookup.
 * Currently unsupported.
 */
int
kernfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{

	return (EOPNOTSUPP);
}

/*ARGSUSED*/
int
kernfs_fhtovp(mp, fhp, mb, vpp, what, anon)
	struct mount *mp;
	struct fid *fhp;
	struct mbuf *mb;
	struct vnode **vpp;
	int *what;
	struct ucred **anon;
{

	return (EOPNOTSUPP);
}

/*ARGSUSED*/
int
kernfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
{

	return (EOPNOTSUPP);
}

a267 1
	MOUNT_KERNFS,
d279 1
@


1.6
log
@VFS Lite2 Changes
@
text
@d62 1
a62 1
int kernfs_init __P((struct vfsconf *));
d70 7
d79 2
a80 3
int
kernfs_init(vfsp)
	struct vfsconf *vfsp;
a81 1
	return (0);
d147 1
a147 1
	vfs_getnewfsid(mp);
d179 1
d187 3
a227 1
	struct proc *p = curproc;
d238 1
a238 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d244 12
d269 2
a279 1
		sbp->f_type = mp->mnt_vfc->vfc_typenum;
d284 13
a296 1
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
d300 38
d339 1
a350 1
	kernfs_sysctl
@


1.5
log
@Fix {KERNFS,NULLFS,UMAPFS,UNION}_DIAGNOSTIC kernel compilation errors.
From Alan Barrett <apb@@iafrica.com> with some changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.4 1996/06/20 14:30:08 mickey Exp $	*/
d62 1
a62 1
void	kernfs_init __P((void));
a69 7
int	kernfs_quotactl __P((struct mount *, int, uid_t, caddr_t,
			     struct proc *));
int	kernfs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int	kernfs_vget __P((struct mount *, ino_t, struct vnode **));
int	kernfs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
			   struct vnode **, int *, struct ucred **));
int	kernfs_vptofh __P((struct vnode *, struct fid *));
d72 3
a74 2
void
kernfs_init()
d76 1
d142 1
a142 1
	getnewfsid(mp, makefstype(MOUNT_KERNFS));
a173 1
	extern int doforce;
a180 3
		/* kernfs can never be rootfs so don't check for it */
		if (!doforce)
			return (EINVAL);
d219 1
d230 1
a230 1
	VOP_LOCK(vp);
a235 12
kernfs_quotactl(mp, cmd, uid, arg, p)
	struct mount *mp;
	int cmd;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

	return (EOPNOTSUPP);
}

int
a248 2
#else
	sbp->f_type = 0;
d258 1
d263 1
a263 13
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
	return (0);
}

/*ARGSUSED*/
int
kernfs_sync(mp, waitfor, uc, p)
	struct mount *mp;
	int waitfor;
	struct ucred *uc;
	struct proc *p;
{

a266 38
/*
 * Kernfs flat namespace lookup.
 * Currently unsupported.
 */
int
kernfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{

	return (EOPNOTSUPP);
}

/*ARGSUSED*/
int
kernfs_fhtovp(mp, fhp, mb, vpp, what, anon)
	struct mount *mp;
	struct fid *fhp;
	struct mbuf *mb;
	struct vnode **vpp;
	int *what;
	struct ucred **anon;
{

	return (EOPNOTSUPP);
}

/*ARGSUSED*/
int
kernfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
{

	return (EOPNOTSUPP);
}

a267 1
	MOUNT_KERNFS,
d279 1
@


1.4
log
@add more kernel variables. calculate used/free physmem and vnodes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.2 1996/02/27 07:55:18 niklas Exp $	*/
d124 1
a124 1
	printf("kernfs_mount(mp = %x)\n", mp);
d142 1
a142 1
	printf("kernfs_mount: root vp = %x\n", rvp);
d183 1
a183 1
	printf("kernfs_unmount(mp = %x)\n", mp);
d230 1
a230 1
	printf("kernfs_root(mp = %x)\n", mp);
d264 1
a264 1
	printf("kernfs_statfs(mp = %x)\n", mp);
@


1.4.4.1
log
@show symbol tables form ddb to userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.4 1996/06/20 14:30:08 mickey Exp $	*/
d78 6
d227 2
d233 8
a240 1
	return (kernfs_allocvp(mp, vpp, NULL, Kroot));
@


1.4.4.2
log
@last (i hope ;) branch commit for kernfs
/kern/sym/* working now (after i'll put all the ddb pieces in
it's cool.
@
text
@d1 2
a2 1
/*	$OpenBSD: kernfs_vfsops.c,v 1.4.4.1 1996/10/14 13:38:03 mickey Exp $	*/
a4 1
 * Copyright (c) 1996, 1997 Michael Shalayeff
a55 1
#include <sys/exec.h>
@


1.3
log
@no sys/cpu.h
@
text
@d55 1
d261 1
d272 4
a275 4
	sbp->f_bsize = DEV_BSIZE;
	sbp->f_iosize = DEV_BSIZE;
	sbp->f_blocks = 2;		/* 1K to keep df happy */
	sbp->f_bfree = 0;
d277 2
a278 2
	sbp->f_files = 0;
	sbp->f_ffree = 0;
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kernfs_vfsops.c,v 1.25 1996/02/09 22:40:22 christos Exp $	*/
a54 1
#include <sys/cpu.h>
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kernfs_vfsops.c,v 1.24 1995/06/18 14:47:27 cgd Exp $	*/
d55 1
d62 18
a81 1

d110 1
d133 2
a134 1
	if (error = getnewvnode(VT_KERNFS, mp, kernfs_vnodeop_p, &rvp))
d161 1
d171 1
d203 1
a203 1
	if (error = vflush(mp, rootvp, flags))
d222 1
d243 1
d255 1
d287 3
a289 1
kernfs_sync(mp, waitfor)
d292 2
d303 1
d313 3
a315 2

kernfs_fhtovp(mp, fhp, setgen, vpp)
d318 1
a318 1
	int setgen;
d320 2
d327 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
