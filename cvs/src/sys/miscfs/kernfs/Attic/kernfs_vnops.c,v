head	1.44;
access;
symbols
	OPENBSD_3_8:1.42.0.4
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.38
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.27.0.4
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.28
	UBC:1.24.0.2
	UBC_BASE:1.24
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.6
	OPENBSD_2_8:1.19.0.4
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	SMP:1.17.0.2
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.16.0.4
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	syms:1.4.0.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2005.11.24.12.08.16;	author pedro;	state dead;
branches;
next	1.43;

1.43
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.18.17.12.33;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2004.09.01.21.06.17;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.12.17.53.18;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.20.18.32.37;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.09.11.56.08;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.15.21.09.39;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.11.10.19.24;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.23.28.10;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.11.01.47.00;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.07.23.37.05;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.30.22.28.05;	author rohee;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.12.02.03.46;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.17.04.29.52;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.11.16.48.12;	author millert;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.12.04.22.44.31;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.04.58.42;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.23.02.14.25;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.13.04.05.15;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.22.19.28.06;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.11.10.23.17.39;	author csapuntz;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	99.02.26.03.44.16;	author art;	state Exp;
branches;
next	1.15;

1.15
date	98.08.06.19.34.36;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	98.06.11.16.34.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.11.06.05.58.38;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.20.20.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.15.19.05;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.09.11.05.26.11;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.04.26.12.10.00;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.03.27.04.39.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.02.20.01.08.12;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.03.06.28;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.10.27.07.59.05;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.06.20.14.30.09;	author mickey;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	96.04.21.22.28.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.55.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.00;	author deraadt;	state Exp;
branches;
next	;

1.4.4.1
date	96.10.14.13.38.03;	author mickey;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	96.10.18.11.22.20;	author mickey;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	96.10.27.07.57.12;	author mickey;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	97.02.07.06.07.56;	author mickey;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	97.02.07.06.16.36;	author mickey;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	97.02.07.06.47.06;	author mickey;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	97.04.13.04.48.13;	author mickey;	state Exp;
branches;
next	1.4.4.8;

1.4.4.8
date	97.05.29.00.52.40;	author mickey;	state Exp;
branches;
next	;

1.17.2.1
date	2000.03.02.07.04.41;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2000.03.24.09.09.29;	author niklas;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2001.07.04.10.49.10;	author niklas;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2001.11.13.23.04.24;	author niklas;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.17.2.6;

1.17.2.6
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.17.2.7;

1.17.2.7
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.17.2.8;

1.17.2.8
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.17.2.9;

1.17.2.9
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.17.2.10;

1.17.2.10
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.17.2.11;

1.17.2.11
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	1.17.2.12;

1.17.2.12
date	2004.06.13.08.50.16;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2003.05.19.22.36.11;	author tedu;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2003.05.20.04.05.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Remove kernfs, okay deraadt@@.
@
text
@/*	$OpenBSD: kernfs_vnops.c,v 1.43 2005/11/19 02:18:01 pedro Exp $	*/
/*	$NetBSD: kernfs_vnops.c,v 1.43 1996/03/16 23:52:47 christos Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software donated to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kernfs_vnops.c	8.9 (Berkeley) 6/15/94
 */

/*
 * Kernel parameter filesystem (/kern)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/buf.h>
#include <sys/dirent.h>
#include <sys/msgbuf.h>
#include <sys/poll.h>
#include <miscfs/kernfs/kernfs.h>

#include <uvm/uvm_extern.h>

#define KSTRING	256		/* Largest I/O available via this filesystem */
#define	UIO_MX 32

#define	READ_MODE	(S_IRUSR|S_IRGRP|S_IROTH)
#define	WRITE_MODE	(S_IWUSR|READ_MODE)
#define DIR_MODE	(S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)

static int	byteorder = BYTE_ORDER;
static int	posix = _POSIX_VERSION;
static int	osrev = OpenBSD;
extern int	ncpus;
extern char machine[], cpu_model[];

#ifdef IPSEC
extern int ipsp_kern(int, char **, int);
#endif

const struct kern_target kern_targets[] = {
/* NOTE: The name must be less than UIO_MX-16 chars in length */
#define N(s) sizeof(s)-1, s
     /*        name            data          tag           type  ro/rw */
     { DT_DIR, N("."),         0,            KTT_NULL,     VDIR, DIR_MODE   },
     { DT_DIR, N(".."),        0,            KTT_NULL,     VDIR, DIR_MODE   },
     { DT_REG, N("boottime"),  &boottime.tv_sec, KTT_INT,  VREG, READ_MODE  },
     { DT_REG, N("byteorder"), &byteorder,   KTT_INT,      VREG, READ_MODE  },
     { DT_REG, N("copyright"), (void*)copyright,KTT_STRING,   VREG, READ_MODE  },
     { DT_REG, N("hostname"),  0,            KTT_HOSTNAME, VREG, WRITE_MODE },
     { DT_REG, N("domainname"),0,            KTT_DOMAIN,   VREG, WRITE_MODE },
     { DT_REG, N("hz"),        &hz,          KTT_INT,      VREG, READ_MODE  },
     { DT_REG, N("loadavg"),   0,            KTT_AVENRUN,  VREG, READ_MODE  },
     { DT_REG, N("machine"),   machine,      KTT_STRING,   VREG, READ_MODE  },
     { DT_REG, N("model"),     cpu_model,    KTT_STRING,   VREG, READ_MODE  },
     { DT_REG, N("msgbuf"),    0,	     KTT_MSGBUF,   VREG, READ_MODE  },
     { DT_REG, N("ncpu"),      &ncpus,       KTT_INT,      VREG, READ_MODE  },
     { DT_REG, N("ostype"),    (void*)&ostype,KTT_STRING,   VREG, READ_MODE  },
     { DT_REG, N("osrelease"), (void*)&osrelease,KTT_STRING,VREG, READ_MODE  },
     { DT_REG, N("osrev"),     &osrev,	     KTT_INT,      VREG, READ_MODE  },
     { DT_REG, N("pagesize"),  &uvmexp.pagesize, KTT_INT,  VREG, READ_MODE  },
     { DT_REG, N("physmem"),   &physmem,     KTT_PHYSMEM,  VREG, READ_MODE  },
     { DT_REG, N("posix"),     &posix,       KTT_INT,      VREG, READ_MODE  },
#if 0
     { DT_DIR, N("root"),      0,            KTT_NULL,     VDIR, DIR_MODE   },
#endif
     { DT_BLK, N("rootdev"),   &rootdev,     KTT_DEVICE,   VBLK, READ_MODE  },
     { DT_CHR, N("rrootdev"),  &rrootdev,    KTT_DEVICE,   VCHR, READ_MODE  },
     { DT_REG, N("time"),      0,            KTT_TIME,     VREG, READ_MODE  },
     { DT_REG, N("usermem"),   0,            KTT_USERMEM,  VREG, READ_MODE  },
     { DT_REG, N("version"),   (void*)version,KTT_STRING,  VREG, READ_MODE  },
#ifdef IPSEC
     { DT_REG, N("ipsec"),     0,            KTT_IPSECSPI, VREG, READ_MODE  },
#endif
#undef N
};
static const int nkern_targets = sizeof(kern_targets) / sizeof(kern_targets[0]);

int	kernfs_badop(void *);

int	kernfs_lookup(void *);
#define	kernfs_create	eopnotsupp
#define	kernfs_mknod	eopnotsupp
int	kernfs_open(void *);
#define	kernfs_close	nullop
int	kernfs_access(void *);
int	kernfs_getattr(void *);
int	kernfs_setattr(void *);
int	kernfs_read(void *);
int	kernfs_write(void *);
#define	kernfs_ioctl	(int (*)(void *))enoioctl
#define	kernfs_mmap	eopnotsupp
#define	kernfs_fsync	nullop
#define	kernfs_seek	nullop
#define	kernfs_remove	eopnotsupp
int	kernfs_link(void *);
#define	kernfs_rename	eopnotsupp
#define kernfs_revoke   vop_generic_revoke
#define	kernfs_mkdir	eopnotsupp
#define	kernfs_rmdir	eopnotsupp
int	kernfs_symlink(void *);
int	kernfs_readdir(void *);
#define	kernfs_readlink	eopnotsupp
int	kernfs_inactive(void *);
int	kernfs_reclaim(void *);
#define	kernfs_lock	vop_generic_lock
#define	kernfs_unlock	vop_generic_unlock
#define	kernfs_bmap	kernfs_badop
#define	kernfs_strategy	kernfs_badop
int	kernfs_print(void *);
#define	kernfs_islocked	vop_generic_islocked
int	kernfs_pathconf(void *);
#define	kernfs_advlock	eopnotsupp
#define	kernfs_blkatoff	eopnotsupp
#define	kernfs_valloc	eopnotsupp
int	kernfs_vfree(void *);
#define	kernfs_truncate	eopnotsupp
#define	kernfs_update	eopnotsupp
#define	kernfs_bwrite	eopnotsupp

int	kernfs_xread(const struct kern_target *, int, char **, int);
int	kernfs_xwrite(const struct kern_target *, char *, int);
int	kernfs_freevp(struct vnode *, struct proc *);

int (**kernfs_vnodeop_p)(void *);
struct vnodeopv_entry_desc kernfs_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, kernfs_lookup },	/* lookup */
	{ &vop_create_desc, kernfs_create },	/* create */
	{ &vop_mknod_desc, kernfs_mknod },	/* mknod */
	{ &vop_open_desc, kernfs_open },	/* open */
	{ &vop_close_desc, kernfs_close },	/* close */
	{ &vop_access_desc, kernfs_access },	/* access */
	{ &vop_getattr_desc, kernfs_getattr },	/* getattr */
	{ &vop_setattr_desc, kernfs_setattr },	/* setattr */
	{ &vop_read_desc, kernfs_read },	/* read */
	{ &vop_write_desc, kernfs_write },	/* write */
	{ &vop_ioctl_desc, kernfs_ioctl },	/* ioctl */
	{ &vop_poll_desc, kernfs_poll },	/* poll */
	{ &vop_revoke_desc, kernfs_revoke },    /* revoke */
	{ &vop_fsync_desc, kernfs_fsync },	/* fsync */
	{ &vop_remove_desc, kernfs_remove },	/* remove */
	{ &vop_link_desc, kernfs_link },	/* link */
	{ &vop_rename_desc, kernfs_rename },	/* rename */
	{ &vop_mkdir_desc, kernfs_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, kernfs_rmdir },	/* rmdir */
	{ &vop_symlink_desc, kernfs_symlink },	/* symlink */
	{ &vop_readdir_desc, kernfs_readdir },	/* readdir */
	{ &vop_readlink_desc, kernfs_readlink },/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },	/* abortop */
	{ &vop_inactive_desc, kernfs_inactive },/* inactive */
	{ &vop_reclaim_desc, kernfs_reclaim },	/* reclaim */
	{ &vop_lock_desc, kernfs_lock },	/* lock */
	{ &vop_unlock_desc, kernfs_unlock },	/* unlock */
	{ &vop_bmap_desc, kernfs_bmap },	/* bmap */
	{ &vop_strategy_desc, kernfs_strategy },/* strategy */
	{ &vop_print_desc, kernfs_print },	/* print */
	{ &vop_islocked_desc, kernfs_islocked },/* islocked */
	{ &vop_pathconf_desc, kernfs_pathconf },/* pathconf */
	{ &vop_advlock_desc, kernfs_advlock },	/* advlock */
	{ &vop_bwrite_desc, kernfs_bwrite },	/* bwrite */
	{ NULL, NULL }
};
struct vnodeopv_desc kernfs_vnodeop_opv_desc =
	{ &kernfs_vnodeop_p, kernfs_vnodeop_entries };

TAILQ_HEAD(, kernfs_node) kfshead;
static struct lock kfscache_lock;

int
kernfs_init(vfsp)
	struct vfsconf *vfsp;
{
	lockinit(&kfscache_lock, PVFS, "kfs", 0, 0);
	TAILQ_INIT(&kfshead);
	return(0);
}

int
kernfs_allocvp(kt, mp, vpp)
	const struct kern_target *kt;
	struct mount *mp;
	struct vnode **vpp;
{
	struct proc *p = curproc;
	struct kernfs_node *kf;
	struct vnode *vp;
	int error = 0;

#ifdef KERNFS_DIAGNOSTIC
	/* this should never happen */
	if (kt == NULL) 
		panic("kernfs_allocvp passed NULL kt, mp %p, vpp %p!", mp, vpp);

	printf("kernfs_allocvp: looking for %s\n", kt->kt_name);
#endif
	if ((error = lockmgr(&kfscache_lock, LK_EXCLUSIVE, NULL)) != 0)
		return(error);

loop:
	for (kf = TAILQ_FIRST(&kfshead); kf != NULL; kf = TAILQ_NEXT(kf, list)) {
		vp = KERNTOV(kf);
		if (vp->v_mount == mp && kt->kt_namlen == kf->kf_namlen &&
			bcmp(kf->kf_name, kt->kt_name, kt->kt_namlen) == 0) {
#ifdef KERNFS_DIAGNOSTIC
			printf("kernfs_allocvp: hit %s\n", kt->kt_name);
#endif
			if (vget(vp, 0, p)) 
				goto loop;
			*vpp = vp;
			goto out;
		}
	}

	MALLOC(kf, void *, sizeof(struct kernfs_node), M_TEMP, M_WAITOK);
	error = getnewvnode(VT_KERNFS, mp, kernfs_vnodeop_p, vpp);
	if (error) {
		FREE(kf, M_TEMP);
		goto out;
	}
	vp = *vpp;
	kf->kf_kt = kt;
	kf->kf_vnode = vp;
	vp->v_type = kf->kf_vtype;
	vp->v_data = kf; 
	if (kf->kf_namlen == 1 && bcmp(kf->kf_name, ".", 1) == 0) 
		vp->v_flag |= VROOT;

	TAILQ_INSERT_TAIL(&kfshead, kf, list);
out:
	lockmgr(&kfscache_lock, LK_RELEASE, NULL);

#ifdef KERNFS_DIAGNOSTIC
	if (error) 
		printf("kernfs_allocvp: error %d\n", error);
#endif
	return(error);
}

int
kernfs_freevp(vp, p)
	struct vnode *vp;
	struct proc *p;
{
	struct kernfs_node *kf = VTOKERN(vp);

	TAILQ_REMOVE(&kfshead, kf, list);
	FREE(vp->v_data, M_TEMP);
	vp->v_data = 0;
	return(0);
}

const struct kern_target *
kernfs_findtarget(name, namlen)
	char	*name;
	int	namlen;
{
	const struct kern_target *kt = NULL;
	int i;
	
	for (i = 0; i < nkern_targets; i++) {
		if (kern_targets[i].kt_namlen == namlen && 
			bcmp(kern_targets[i].kt_name, name, namlen) == 0) {
			kt = &kern_targets[i];
			break;
		}
	}

#ifdef KERNFS_DIAGNOSTIC
	if (i == nkern_targets || kt == NULL)
		printf("kernfs_findtarget: no match for %s\n", name);
#endif
	return(kt);
}
	
	
int
kernfs_xread(kt, off, bufp, len)
	const struct kern_target *kt;
	int off;
	char **bufp;
	int len;
{

	switch (kt->kt_tag) {
	case KTT_TIME: {
		struct timeval tv;

		microtime(&tv);
		snprintf(*bufp, len, "%ld %ld\n", tv.tv_sec, tv.tv_usec);
		break;
	}

	case KTT_INT: {
		int *ip = kt->kt_data;

		snprintf(*bufp, len, "%d\n", *ip);
		break;
	}

	case KTT_STRING: {
		char *cp = kt->kt_data;
		size_t end = strlen(cp);

		if (end && cp[end - 1] != '\n') {
			strlcpy(*bufp, cp, len - 1);
			strlcat(*bufp, "\n", len);
		} else
			*bufp = cp;

		break;
	}

	case KTT_MSGBUF: {
		extern struct msgbuf *msgbufp;
		long n;

		if (msgbufp == NULL || msgbufp->msg_magic != MSG_MAGIC)
			return (ENXIO);

		/*
		 * Note that reads of /kern/msgbuf won't necessarily yield
		 * consistent results, if the message buffer is modified
		 * while the read is in progress.  The worst that can happen
		 * is that incorrect data will be read.  There's no way
		 * that this can crash the system unless the values in the
		 * message buffer header are corrupted, but that'll cause
		 * the system to die anyway.
		 */
		if (msgbufp->msg_bufl < msgbufp->msg_bufs) {
			if (off >= msgbufp->msg_bufx)
				return (0);
			n = off;
			len = msgbufp->msg_bufx - n;
		} else {
			if (off >= msgbufp->msg_bufs)
				return (0);
			n = msgbufp->msg_bufx + off;
			if (n >= msgbufp->msg_bufs)
				n -= msgbufp->msg_bufs;
			len = min(msgbufp->msg_bufs - n, msgbufp->msg_bufs - off);
		}
		*bufp = msgbufp->msg_bufc + n;
		return (len);
	}

	case KTT_HOSTNAME: {
		char *cp = hostname;
		int xlen = hostnamelen;

		if (xlen >= (len-2))
			return (EINVAL);

		bcopy(cp, *bufp, xlen);
		(*bufp)[xlen] = '\n';
		(*bufp)[xlen+1] = '\0';
		break;
	}

	case KTT_DOMAIN: {
		char *cp = domainname;
		int xlen = domainnamelen;

		if (xlen >= (len-2))
			return (EINVAL);

		bcopy(cp, *bufp, xlen);
		(*bufp)[xlen] = '\n';
		(*bufp)[xlen+1] = '\0';
		break;
	}

	case KTT_AVENRUN:
		averunnable.fscale = FSCALE;
		snprintf(*bufp, len, "%d %d %d %ld\n",
		    averunnable.ldavg[0], averunnable.ldavg[1],
		    averunnable.ldavg[2], averunnable.fscale);
		break;

	case KTT_USERMEM:
		snprintf(*bufp, len, "%u\n", ctob(physmem - uvmexp.wired));
		break;

	case KTT_PHYSMEM:
		snprintf(*bufp, len, "%u\n", ctob(physmem));
		break;

#ifdef IPSEC
	case KTT_IPSECSPI:
		return(ipsp_kern(off, bufp, len));
#endif
	default:
		return (0);
	}

	len = strlen(*bufp);
	if (len <= off)
		return (0);
	*bufp += off;
	return (len - off);
}

int
kernfs_xwrite(kt, buf, len)
	const struct kern_target *kt;
	char *buf;
	int len;
{

	switch (kt->kt_tag) {
	case KTT_DOMAIN:
		if (buf[len-1] == '\n')
			--len;
		bcopy(buf, domainname, len);
		domainname[len] = '\0';
		domainnamelen = len;
		return (0);

	case KTT_HOSTNAME:
		if (buf[len-1] == '\n')
			--len;
		bcopy(buf, hostname, len);
		hostname[len] = '\0';
		hostnamelen = len;
		return (0);

	default:
		return (EIO);
	}
}


/*
 * vp is the current namei directory
 * ndp is the name to locate in that directory...
 */
int
kernfs_lookup(v)
	void *v;
{
	struct vop_lookup_args /* {
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct vnode **vpp = ap->a_vpp;
	struct vnode *dvp = ap->a_dvp;
	char *pname = cnp->cn_nameptr;
	struct proc *p = cnp->cn_proc;
	const struct kern_target *kt;
	struct vnode *vp;
	int error, wantpunlock;

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_lookup(%p)\n", ap);
	printf("kernfs_lookup(dp = %p, vpp = %p, cnp = %p)\n", dvp, vpp, ap->a_cnp);
	printf("kernfs_lookup(%s)\n", pname);
#endif

	*vpp = NULLVP;
	cnp->cn_flags &= ~PDIRUNLOCK;

	if (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME)
		return (EROFS);

	if (cnp->cn_namelen == 1 && *pname == '.') { 
		*vpp = dvp;
		VREF(dvp);
		return (0);
	}

	wantpunlock = (~cnp->cn_flags & (LOCKPARENT | ISLASTCN));

	kt = kernfs_findtarget(pname, cnp->cn_namelen);
	if (kt == NULL) {
		/* not found */
		return(cnp->cn_nameiop == LOOKUP ? ENOENT : EROFS);
	}

	if (kt->kt_tag == KTT_DEVICE) {
		dev_t *dp = kt->kt_data;
		
	loop:
		if (*dp == NODEV || !vfinddev(*dp, kt->kt_vtype, &vp)) 
			return(ENOENT);
		
		*vpp = vp;
		if (vget(vp, LK_EXCLUSIVE, p)) 
			goto loop;
		if (wantpunlock) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return(0);
	}


	if ((error = kernfs_allocvp(kt, dvp->v_mount, vpp)) != 0) {
		return(error);
	}

	vn_lock(*vpp, LK_EXCLUSIVE | LK_RETRY, p);

	if (wantpunlock) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
	return (0);
}
		
/*ARGSUSED*/
int
kernfs_open(v)
	void *v;
{
	/* Only need to check access permissions. */
	return (0);
}

int
kernfs_access(v)
	void *v;
{
	struct vop_access_args /* {
		struct vnode *a_vp;
		int a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	
	mode_t fmode = (vp->v_flag & VROOT) ? DIR_MODE : VTOKERN(vp)->kf_mode;

	return (vaccess(fmode, (uid_t)0, (gid_t)0, ap->a_mode, ap->a_cred));
}

int
kernfs_getattr(v)
	void *v;
{
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vattr *vap = ap->a_vap;
	int error = 0;
	char strbuf[KSTRING], *buf;


	bzero(vap, sizeof(*vap));
	vattr_null(vap);
	vap->va_uid = 0;
	vap->va_gid = 0;
	vap->va_fsid = vp->v_mount->mnt_stat.f_fsid.val[0];
	vap->va_size = 0;
	vap->va_blocksize = DEV_BSIZE;
	getnanotime(&vap->va_atime);
	vap->va_mtime = vap->va_atime;
	vap->va_ctime = vap->va_atime;
	vap->va_gen = 0;
	vap->va_flags = 0;
	vap->va_rdev = 0;
	vap->va_bytes = 0;

	if (vp->v_flag & VROOT) {
#ifdef KERNFS_DIAGNOSTIC
		struct kern_target *kt = VTOKERN(vp)->kf_kt;
		printf("kernfs_getattr: stat rootdir (%s)\n", kt->kt_name);
#endif
		vap->va_type = VDIR;
		vap->va_mode = DIR_MODE;
		vap->va_nlink = 2;
		vap->va_fileid = 2;
		vap->va_size = DEV_BSIZE;
	} else {
		const struct kern_target *kt = VTOKERN(vp)->kf_kt;
		int nbytes, total;
#ifdef KERNFS_DIAGNOSTIC
		printf("kernfs_getattr: stat target %s\n", kt->kt_name);
#endif
		if (kt == &kern_targets[2]) {
			/* set boottime times to boottime */
			TIMEVAL_TO_TIMESPEC(&boottime, &vap->va_atime);
			vap->va_mtime = vap->va_atime;
			vap->va_ctime = vap->va_atime;
		}
		vap->va_type = kt->kt_vtype;
		vap->va_mode = kt->kt_mode;
		vap->va_nlink = 1;
		vap->va_fileid = 3 + (kt - kern_targets);
		total = 0;
		while (buf = strbuf,
		       nbytes = kernfs_xread(kt, total, &buf, sizeof(strbuf))) {
			if (total <= INT_MAX - nbytes)
				break;		/* XXX - should use quad */
			total += nbytes;
		}
		vap->va_size = total;
	}

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_getattr: return error %d\n", error);
#endif
	return (error);
}

/*ARGSUSED*/
int
kernfs_setattr(v)
	void *v;
{
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;

	if (ap->a_vap->va_flags != VNOVAL)
		return (EOPNOTSUPP);

	/*
	 * Silently ignore attribute changes.
	 * This allows for open with truncate to have no
	 * effect until some data is written.  I want to
	 * do it this way because all writes are atomic.
	 */
	return (0);
}

int
kernfs_read(v)
	void *v;
{
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uio *uio = ap->a_uio;
	const struct kern_target *kt;
	char strbuf[KSTRING], *buf;
	int off, len;
	int error;

	if (vp->v_type == VDIR)
		return (EOPNOTSUPP);

	kt = VTOKERN(vp)->kf_kt;

#ifdef KERNFS_DIAGNOSTIC
	printf("kern_read %s\n", kt->kt_name);
#endif

	if (uio->uio_offset < 0)
		return (EINVAL);
	off = uio->uio_offset;
#if 0
	while (buf = strbuf,
#else
	if (buf = strbuf,
#endif
	    len = kernfs_xread(kt, off, &buf, sizeof(strbuf))) {
		if ((error = uiomove(buf, len, uio)) != 0)
			return (error);
	}
	return (0);
}

int
kernfs_write(v)
	void *v;
{
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uio *uio = ap->a_uio;
	const struct kern_target *kt;
	int error, xlen;
	char strbuf[KSTRING];

	if (vp->v_type == VDIR)
		return (EOPNOTSUPP);

	kt = VTOKERN(vp)->kf_kt;

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_write %s\n", kt->kt_name);
#endif

	if (uio->uio_offset != 0)
		return (EINVAL);

	xlen = min(uio->uio_resid, KSTRING-1);
	if ((error = uiomove(strbuf, xlen, uio)) != 0)
		return (error);

	if (uio->uio_resid != 0)
		return (EIO);

	strbuf[xlen] = '\0';
	xlen = strlen(strbuf);
	return (kernfs_xwrite(kt, strbuf, xlen));
}

int
kernfs_readdir(v)
	void *v;
{
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long *a_cookies;
		int a_ncookies;
	} */ *ap = v;
	int error, i;
	struct uio *uio = ap->a_uio;
	struct dirent d;
	const struct kern_target *kt;

	if (ap->a_vp->v_type != VDIR)
		return (ENOTDIR);

	if (uio->uio_resid < UIO_MX)
		return (EINVAL);
	if (uio->uio_offset < 0)
		return (EINVAL);

	error = 0;
	i = uio->uio_offset;
	bzero(&d, UIO_MX);
	d.d_reclen = UIO_MX;

	for (kt = &kern_targets[i];
	     uio->uio_resid >= UIO_MX && i < nkern_targets; kt++, i++) {
#ifdef KERNFS_DIAGNOSTIC
		printf("kernfs_readdir: i = %d\n", i);
#endif

		if (kt->kt_tag == KTT_DEVICE) {
			dev_t *dp = kt->kt_data;
			struct vnode *fvp;

			if (*dp == NODEV || !vfinddev(*dp, kt->kt_vtype, &fvp))
				continue;
		}

		d.d_fileno = i + 3;
		d.d_namlen = kt->kt_namlen;
		bcopy(kt->kt_name, d.d_name, kt->kt_namlen + 1);
		d.d_type = kt->kt_type;

		if ((error = uiomove(&d, UIO_MX, uio)) != 0)
			break;
	}

	uio->uio_offset = i;
	return (error);
}

int
kernfs_inactive(v)
	void *v;
{
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
#ifdef KERNFS_DIAGNOSTIC
	struct kernfs_node *kf;

	kf = VTOKERN(vp);

	printf("kernfs_inactive(%p) %s\n", vp, kf->kf_name);
#endif
	VOP_UNLOCK(vp, 0, ap->a_p);
	return (0);
}

int
kernfs_reclaim(v)
	void *v;
{
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct proc *p = curproc;
#ifdef KERNFS_DIAGNOSTIC
	struct kernfs_node *kf;

	kf = VTOKERN(vp);

	printf("kernfs_reclaim(%p) %s\n", vp, kf->kf_name);
#endif
	return(kernfs_freevp(vp, p));
}

/*
 * Return POSIX pathconf information applicable to special devices.
 */
int
kernfs_pathconf(v)
	void *v;
{
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		return (0);
	case _PC_MAX_CANON:
		*ap->a_retval = MAX_CANON;
		return (0);
	case _PC_MAX_INPUT:
		*ap->a_retval = MAX_INPUT;
		return (0);
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
		return (0);
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		return (0);
	case _PC_VDISABLE:
		*ap->a_retval = _POSIX_VDISABLE;
		return (0);
	default:
		return (EINVAL);
	}
	/* NOTREACHED */
}

/*
 * Print out some details of a kernfs vnode.
 */
/* ARGSUSED */
int
kernfs_print(v)
	void *v;
{
	struct vop_print_args /*
		struct vnode *a_vp;
	} */ *ap = v;
	struct kernfs_node *kf = VTOKERN(ap->a_vp);

	printf("tag VT_KERNFS, kernfs vnode: name %s, vp %p, tag %d\n", 
		kf->kf_name, kf->kf_vnode, kf->kf_tag); 
		
	return (0);
}

/*ARGSUSED*/
int
kernfs_vfree(v)
	void *v;
{
	return (0);
}

int
kernfs_link(v) 
	void *v;
{
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;  
		struct componentname *a_cnp;
	} */ *ap = v;
 
	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

int
kernfs_symlink(v)
	void *v;
{
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;

	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

/*
 * kernfs "should never get here" operation
 */
/*ARGSUSED*/
int
kernfs_badop(v)
	void *v;
{

	panic("kernfs: bad op");
	return 0;
}

int
kernfs_poll(v)
	void *v;
{
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;  
		struct proc *a_p;   
	} */ *ap = v;

	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}
@


1.43
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.42 2004/11/18 17:12:33 millert Exp $	*/
@


1.42
log
@Better and simpler check for negative offset; from Christer Oberg
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.41 2004/09/01 21:06:17 millert Exp $	*/
d235 1
a235 1
	if ((error = lockmgr(&kfscache_lock, LK_EXCLUSIVE, NULL, p)) != 0)
d269 1
a269 1
	lockmgr(&kfscache_lock, LK_RELEASE, NULL, p);
@


1.41
log
@Make sure we don't call kernfs_xread() with a negative offset.
Problem found by Christer Oberg.  OK henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.40 2004/06/24 19:35:24 tholo Exp $	*/
d699 2
a709 2
		if (off <= INT_MAX - len)
			off += len;	/* XXX - should use quad */
@


1.40
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.39 2004/06/12 17:53:18 deraadt Exp $	*/
d635 3
a637 1
		       nbytes = kernfs_xread(kt, total, &buf, sizeof(strbuf)))
d639 1
d708 2
a709 1
		off += len;
@


1.39
log
@fix ncpu vs ncpus glitch, spotted by Sven Dehmlow
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.38 2004/05/20 18:32:37 tedu Exp $	*/
d599 1
a599 1
	TIMEVAL_TO_TIMESPEC(&time, &vap->va_atime);
@


1.38
log
@remove more caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.37 2003/12/09 11:56:08 mickey Exp $	*/
d72 1
a72 1
static int	ncpu = 1;	/* XXX */
d95 1
a95 1
     { DT_REG, N("ncpu"),      &ncpu,        KTT_INT,      VREG, READ_MODE  },
@


1.37
log
@missing ar; form Alf Schlichting <leopold-bloom@@foni.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.36 2003/11/15 21:09:39 tedu Exp $	*/
d592 1
a592 1
	bzero((caddr_t) vap, sizeof(*vap));
d777 1
a777 1
	bzero((caddr_t)&d, UIO_MX);
d799 1
a799 1
		if ((error = uiomove((caddr_t)&d, UIO_MX, uio)) != 0)
@


1.36
log
@set boottime's time to boottime, handy for find.  requested by markus.
don't bother with microtime.  time should be more than enough precision.
from netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.35 2003/09/23 16:51:13 millert Exp $	*/
d309 1
a309 1
		printf("kernfs_findtarget: no match for %s\n");
@


1.35
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.34 2003/08/11 10:19:24 mickey Exp $	*/
a587 1
	struct timeval tv;
d599 1
a599 2
	microtime(&tv);
	TIMEVAL_TO_TIMESPEC(&tv, &vap->va_atime);
d623 6
@


1.34
log
@constify constant targets
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.33 2003/06/02 23:28:10 millert Exp $	*/
d57 1
a129 1
#define	kernfs_select	eopnotsupp
d177 1
a177 1
	{ &vop_select_desc, kernfs_select },	/* select */
d950 13
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.32 2003/05/11 01:47:00 tedu Exp $	*/
d78 1
a78 1
struct kern_target kern_targets[] = {
d114 1
a114 1
static int nkern_targets = sizeof(kern_targets) / sizeof(kern_targets[0]);
d159 2
a160 2
int	kernfs_xread(struct kern_target *, int, char **, int);
int	kernfs_xwrite(struct kern_target *, char *, int);
d219 1
a219 1
	struct kern_target *kt;
d291 1
a291 1
struct kern_target *
d296 1
a296 1
	struct kern_target *kt = NULL;
d317 1
a317 1
	struct kern_target *kt;
d443 1
a443 1
	struct kern_target *kt;
d489 1
a489 1
	struct kern_target *kt;
d620 1
a620 1
		struct kern_target *kt = VTOKERN(vp)->kf_kt;
d678 1
a678 1
	struct kern_target *kt;
d718 1
a718 1
	struct kern_target *kt;
d761 1
a761 1
	struct kern_target *kt;
@


1.32
log
@use LK_EXCLUSIVE like all other file systems.
use LK_RETRY in kernfs_root().  "just in case" stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.31 2003/04/07 23:37:05 tedu Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.31
log
@some snprintf usage from rohee.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.30 2003/03/30 22:28:05 rohee Exp $	*/
d545 1
a545 1
	vn_lock(*vpp, LK_SHARED | LK_RETRY, p);
@


1.30
log
@Ensure that all files in /kern end with a newline (machine, model,
osrelease and ostype were not).

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.29 2003/01/31 17:37:50 art Exp $	*/
d332 1
a332 1
		sprintf(*bufp, "%ld %ld\n", tv.tv_sec, tv.tv_usec);
d339 1
a339 1
		sprintf(*bufp, "%d\n", *ip);
d345 1
a345 1
		size_t len = strlen(cp);
d347 3
a349 3
		if (len && cp[len - 1] != '\n') {
			strlcpy(*bufp, cp, KSTRING - 1);
			strlcat(*bufp, "\n", KSTRING);
d417 1
a417 1
		sprintf(*bufp, "%d %d %d %ld\n",
d423 1
a423 1
		sprintf(*bufp, "%u\n", ctob(physmem - uvmexp.wired));
d427 1
a427 1
		sprintf(*bufp, "%u\n", ctob(physmem));
@


1.29
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.28 2002/10/12 02:03:46 krw Exp $	*/
d345 7
a352 1
		*bufp = cp;
@


1.28
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Last bits of diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.27 2002/03/14 20:31:31 mickey Exp $	*/
a289 1
	VOP_UNLOCK(vp, 0, p);
d489 1
a489 1
	int error;
d496 1
a496 1
	VOP_UNLOCK(dvp, 0, p);
d498 1
a505 1
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d509 2
a513 1
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d527 4
a535 1
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d540 6
a545 1
	return(error);
@


1.27
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.26 2002/03/14 01:27:08 millert Exp $	*/
d235 1
a235 1
		panic("kernfs_allocvp passed NULL kt, mp %p, vpp %p!\n", mp, vpp);
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.25 2002/02/17 04:29:52 art Exp $	*/
a76 1
extern char ostype[], osrelease[];
d90 1
a90 1
     { DT_REG, N("copyright"), copyright,    KTT_STRING,   VREG, READ_MODE  },
d99 3
a101 3
     { DT_REG, N("ostype"),    &ostype,      KTT_STRING,   VREG, READ_MODE  },
     { DT_REG, N("osrelease"), &osrelease,   KTT_STRING,   VREG, READ_MODE  },
     { DT_REG, N("osrev"),     &osrev,       KTT_INT,      VREG, READ_MODE  },
d112 1
a112 1
     { DT_REG, N("version"),   version,      KTT_STRING,   VREG, READ_MODE  },
@


1.25
log
@Cache vnodes, don't hold on to the root vnode, some cleanups, handle
physmem and usermem correctly.

kernel/2404 from peterw@@ifost.org.au with some small fixups from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.24 2001/12/11 16:48:12 millert Exp $	*/
d80 1
a80 1
extern int ipsp_kern __P((int, char **, int));
d121 1
a121 1
int	kernfs_badop	__P((void *));
d123 1
a123 1
int	kernfs_lookup	__P((void *));
d126 1
a126 1
int	kernfs_open	__P((void *));
d128 6
a133 6
int	kernfs_access	__P((void *));
int	kernfs_getattr	__P((void *));
int	kernfs_setattr	__P((void *));
int	kernfs_read	__P((void *));
int	kernfs_write	__P((void *));
#define	kernfs_ioctl	(int (*) __P((void *)))enoioctl
d139 1
a139 1
int	kernfs_link	__P((void *));
d144 2
a145 2
int	kernfs_symlink	__P((void *));
int	kernfs_readdir	__P((void *));
d147 2
a148 2
int	kernfs_inactive	__P((void *));
int	kernfs_reclaim	__P((void *));
d153 1
a153 1
int	kernfs_print	__P((void *));
d155 1
a155 1
int	kernfs_pathconf	__P((void *));
d159 1
a159 1
int	kernfs_vfree	__P((void *));
d164 3
a166 3
int	kernfs_xread __P((struct kern_target *, int, char **, int));
int	kernfs_xwrite __P((struct kern_target *, char *, int));
int	kernfs_freevp __P((struct vnode *, struct proc *));
d168 1
a168 1
int (**kernfs_vnodeop_p) __P((void *));
@


1.24
log
@Fix typo, noticed by Richard Lowe
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.23 2001/12/04 22:44:31 art Exp $	*/
d104 1
a104 1
     { DT_REG, N("physmem"),   &physmem,     KTT_INT,      VREG, READ_MODE  },
d166 1
d210 111
d419 5
a423 1
		sprintf(*bufp, "%u\n", physmem - uvmexp.wired);
d425 1
d490 2
a491 2
	struct vnode *fvp;
	int error, i;
d498 1
a498 1

d504 1
a504 1
	if (cnp->cn_namelen == 1 && *pname == '.') {
d511 5
a515 13
#if 0
	if (cnp->cn_namelen == 4 && bcmp(pname, "root", 4) == 0) {
		*vpp = rootdir;
		VREF(rootdir);
		vn_lock(rootdir, LK_SHARED | LK_RETRY, p);
		return (0);
	}
#endif

	for (kt = kern_targets, i = 0; i < nkern_targets; kt++, i++) {
		if (cnp->cn_namelen == kt->kt_namlen &&
		    bcmp(kt->kt_name, pname, cnp->cn_namelen) == 0)
			goto found;
a517 8
#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_lookup: i = %d, failed", i);
#endif

	vn_lock(dvp, LK_SHARED | LK_RETRY, p);
	return (cnp->cn_nameiop == LOOKUP ? ENOENT : EROFS);

found:
d520 1
d522 5
a526 4
		if (*dp == NODEV || !vfinddev(*dp, kt->kt_vtype, &fvp))
			return (ENOENT);
		*vpp = fvp;
		if (vget(fvp, LK_EXCLUSIVE, p))
d528 1
a528 1
		return (0);
d531 2
a532 5
#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_lookup: allocate new vnode\n");
#endif
	error = getnewvnode(VT_KERNFS, dvp->v_mount, kernfs_vnodeop_p, &fvp);
	if (error) {
d534 1
a534 1
		return (error);
d537 2
a538 11
	MALLOC(fvp->v_data, void *, sizeof(struct kernfs_node), M_TEMP,
	    M_WAITOK);
	VTOKERN(fvp)->kf_kt = kt;
	fvp->v_type = kt->kt_vtype;
	vn_lock(fvp, LK_SHARED | LK_RETRY, p);
	*vpp = fvp;

#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_lookup: newvp = %p\n", fvp);
#endif
	return (0);
d540 1
a540 1

d561 2
a562 2
	mode_t fmode =
	    (vp->v_flag & VROOT) ? DIR_MODE : VTOKERN(vp)->kf_kt->kt_mode;
d583 1
d602 2
a603 1
		printf("kernfs_getattr: stat rootdir\n");
d718 4
d803 4
d808 1
a808 2
#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_inactive(%p)\n", vp);
a809 4
	/*
	 * Clear out the v_type field to avoid
	 * nasty things happening in vgone().
	 */
a810 1
	vp->v_type = VNON;
d822 5
d828 1
a828 2
#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_reclaim(%p)\n", vp);
d830 1
a830 5
	if (vp->v_data) {
		FREE(vp->v_data, M_TEMP);
		vp->v_data = 0;
	}
	return (0);
d872 1
a872 1
 * Print out the contents of a /dev/fd vnode.
d879 4
d884 3
a886 1
	printf("tag VT_KERNFS, kernfs vnode\n");
a894 1

d924 1
a924 1
  
d931 1
a931 1
 * /dev/fd "should never get here" operation
@


1.24.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.24 2001/12/11 16:48:12 millert Exp $	*/
d77 1
d80 1
a80 1
extern int ipsp_kern(int, char **, int);
d91 1
a91 1
     { DT_REG, N("copyright"), (void*)copyright,KTT_STRING,   VREG, READ_MODE  },
d100 3
a102 3
     { DT_REG, N("ostype"),    (void*)&ostype,KTT_STRING,   VREG, READ_MODE  },
     { DT_REG, N("osrelease"), (void*)&osrelease,KTT_STRING,VREG, READ_MODE  },
     { DT_REG, N("osrev"),     &osrev,	     KTT_INT,      VREG, READ_MODE  },
d104 1
a104 1
     { DT_REG, N("physmem"),   &physmem,     KTT_PHYSMEM,  VREG, READ_MODE  },
d113 1
a113 1
     { DT_REG, N("version"),   (void*)version,KTT_STRING,  VREG, READ_MODE  },
d121 1
a121 1
int	kernfs_badop(void *);
d123 1
a123 1
int	kernfs_lookup(void *);
d126 1
a126 1
int	kernfs_open(void *);
d128 6
a133 6
int	kernfs_access(void *);
int	kernfs_getattr(void *);
int	kernfs_setattr(void *);
int	kernfs_read(void *);
int	kernfs_write(void *);
#define	kernfs_ioctl	(int (*)(void *))enoioctl
d139 1
a139 1
int	kernfs_link(void *);
d144 2
a145 2
int	kernfs_symlink(void *);
int	kernfs_readdir(void *);
d147 2
a148 2
int	kernfs_inactive(void *);
int	kernfs_reclaim(void *);
d153 1
a153 1
int	kernfs_print(void *);
d155 1
a155 1
int	kernfs_pathconf(void *);
d159 1
a159 1
int	kernfs_vfree(void *);
d164 2
a165 3
int	kernfs_xread(struct kern_target *, int, char **, int);
int	kernfs_xwrite(struct kern_target *, char *, int);
int	kernfs_freevp(struct vnode *, struct proc *);
d167 1
a167 1
int (**kernfs_vnodeop_p)(void *);
a208 111
TAILQ_HEAD(, kernfs_node) kfshead;
static struct lock kfscache_lock;

int
kernfs_init(vfsp)
	struct vfsconf *vfsp;
{
	lockinit(&kfscache_lock, PVFS, "kfs", 0, 0);
	TAILQ_INIT(&kfshead);
	return(0);
}

int
kernfs_allocvp(kt, mp, vpp)
	struct kern_target *kt;
	struct mount *mp;
	struct vnode **vpp;
{
	struct proc *p = curproc;
	struct kernfs_node *kf;
	struct vnode *vp;
	int error = 0;

#ifdef KERNFS_DIAGNOSTIC
	/* this should never happen */
	if (kt == NULL) 
		panic("kernfs_allocvp passed NULL kt, mp %p, vpp %p!\n", mp, vpp);

	printf("kernfs_allocvp: looking for %s\n", kt->kt_name);
#endif
	if ((error = lockmgr(&kfscache_lock, LK_EXCLUSIVE, NULL, p)) != 0)
		return(error);

loop:
	for (kf = TAILQ_FIRST(&kfshead); kf != NULL; kf = TAILQ_NEXT(kf, list)) {
		vp = KERNTOV(kf);
		if (vp->v_mount == mp && kt->kt_namlen == kf->kf_namlen &&
			bcmp(kf->kf_name, kt->kt_name, kt->kt_namlen) == 0) {
#ifdef KERNFS_DIAGNOSTIC
			printf("kernfs_allocvp: hit %s\n", kt->kt_name);
#endif
			if (vget(vp, 0, p)) 
				goto loop;
			*vpp = vp;
			goto out;
		}
	}

	MALLOC(kf, void *, sizeof(struct kernfs_node), M_TEMP, M_WAITOK);
	error = getnewvnode(VT_KERNFS, mp, kernfs_vnodeop_p, vpp);
	if (error) {
		FREE(kf, M_TEMP);
		goto out;
	}
	vp = *vpp;
	kf->kf_kt = kt;
	kf->kf_vnode = vp;
	vp->v_type = kf->kf_vtype;
	vp->v_data = kf; 
	if (kf->kf_namlen == 1 && bcmp(kf->kf_name, ".", 1) == 0) 
		vp->v_flag |= VROOT;

	TAILQ_INSERT_TAIL(&kfshead, kf, list);
out:
	lockmgr(&kfscache_lock, LK_RELEASE, NULL, p);

#ifdef KERNFS_DIAGNOSTIC
	if (error) 
		printf("kernfs_allocvp: error %d\n", error);
#endif
	return(error);
}

int
kernfs_freevp(vp, p)
	struct vnode *vp;
	struct proc *p;
{
	struct kernfs_node *kf = VTOKERN(vp);

	TAILQ_REMOVE(&kfshead, kf, list);
	VOP_UNLOCK(vp, 0, p);
	FREE(vp->v_data, M_TEMP);
	vp->v_data = 0;
	return(0);
}

struct kern_target *
kernfs_findtarget(name, namlen)
	char	*name;
	int	namlen;
{
	struct kern_target *kt = NULL;
	int i;
	
	for (i = 0; i < nkern_targets; i++) {
		if (kern_targets[i].kt_namlen == namlen && 
			bcmp(kern_targets[i].kt_name, name, namlen) == 0) {
			kt = &kern_targets[i];
			break;
		}
	}

#ifdef KERNFS_DIAGNOSTIC
	if (i == nkern_targets || kt == NULL)
		printf("kernfs_findtarget: no match for %s\n");
#endif
	return(kt);
}
	
	
d307 1
a307 5
		sprintf(*bufp, "%u\n", ctob(physmem - uvmexp.wired));
		break;

	case KTT_PHYSMEM:
		sprintf(*bufp, "%u\n", ctob(physmem));
a308 1

d373 2
a374 2
	struct vnode *vp;
	int error;
d381 1
a381 1
	VOP_UNLOCK(dvp, 0, p);
d387 1
a387 1
	if (cnp->cn_namelen == 1 && *pname == '.') { 
d394 13
a406 5
	kt = kernfs_findtarget(pname, cnp->cn_namelen);
	if (kt == NULL) {
		/* not found */
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
		return(cnp->cn_nameiop == LOOKUP ? ENOENT : EROFS);
d409 8
a418 1
		
d420 4
a423 5
		if (*dp == NODEV || !vfinddev(*dp, kt->kt_vtype, &vp)) 
			return(ENOENT);
		
		*vpp = vp;
		if (vget(vp, LK_EXCLUSIVE, p)) 
d425 1
a425 1
		return(0);
d428 5
a432 2

	if ((error = kernfs_allocvp(kt, dvp->v_mount, vpp)) != 0) {
d434 1
a434 1
		return(error);
d437 11
a447 2
	vn_lock(*vpp, LK_SHARED | LK_RETRY, p);
	return(error);
d449 1
a449 1
		
d470 2
a471 2
	
	mode_t fmode = (vp->v_flag & VROOT) ? DIR_MODE : VTOKERN(vp)->kf_mode;
a491 1

d510 1
a510 2
		struct kern_target *kt = VTOKERN(vp)->kf_kt;
		printf("kernfs_getattr: stat rootdir (%s)\n", kt->kt_name);
a624 4
#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_write %s\n", kt->kt_name);
#endif

d706 1
d708 1
a708 5
	struct kernfs_node *kf;

	kf = VTOKERN(vp);

	printf("kernfs_inactive(%p) %s\n", vp, kf->kf_name);
d710 4
d715 1
d727 1
a727 1
	struct proc *p = curproc;
d729 1
a729 5
	struct kernfs_node *kf;

	kf = VTOKERN(vp);

	printf("kernfs_reclaim(%p) %s\n", vp, kf->kf_name);
d731 5
a735 1
	return(kernfs_freevp(vp, p));
d777 1
a777 1
 * Print out some details of a kernfs vnode.
a783 4
	struct vop_print_args /*
		struct vnode *a_vp;
	} */ *ap = v;
	struct kernfs_node *kf = VTOKERN(ap->a_vp);
d785 1
a785 3
	printf("tag VT_KERNFS, kernfs vnode: name %s, vp %p, tag %d\n", 
		kf->kf_name, kf->kf_vnode, kf->kf_tag); 
		
d794 1
d824 1
a824 1

d831 1
a831 1
 * kernfs "should never get here" operation
@


1.24.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.24.2.1 2002/06/11 03:30:20 art Exp $	*/
d235 1
a235 1
		panic("kernfs_allocvp passed NULL kt, mp %p, vpp %p!", mp, vpp);
@


1.24.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d290 1
d333 1
a333 1
		snprintf(*bufp, len, "%ld %ld\n", tv.tv_sec, tv.tv_usec);
d340 1
a340 1
		snprintf(*bufp, len, "%d\n", *ip);
a345 7
		size_t end = strlen(cp);

		if (end && cp[end - 1] != '\n') {
			strlcpy(*bufp, cp, len - 1);
			strlcat(*bufp, "\n", len);
		} else
			*bufp = cp;
d347 1
d412 1
a412 1
		snprintf(*bufp, len, "%d %d %d %ld\n",
d418 1
a418 1
		snprintf(*bufp, len, "%u\n", ctob(physmem - uvmexp.wired));
d422 1
a422 1
		snprintf(*bufp, len, "%u\n", ctob(physmem));
d490 1
a490 1
	int error, wantpunlock;
d497 1
a497 1

a498 1
	cnp->cn_flags &= ~PDIRUNLOCK;
d506 1
a509 2
	wantpunlock = (~cnp->cn_flags & (LOCKPARENT | ISLASTCN));

d513 1
a526 4
		if (wantpunlock) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
d532 1
d536 2
a537 7
	vn_lock(*vpp, LK_EXCLUSIVE | LK_RETRY, p);

	if (wantpunlock) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
	return (0);
@


1.24.2.4
log
@convert to genfs_nolock.  genfs_lock for kern and procfs
@
text
@a60 2

#include <miscfs/genfs/genfs.h>
d148 2
a149 2
#define	kernfs_lock	genfs_lock
#define	kernfs_unlock	genfs_unlock
d153 1
a153 1
#define	kernfs_islocked	genfs_islocked
@


1.23
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.22 2001/11/06 19:53:20 miod Exp $	*/
d502 1
a502 1
	vap->va_ctime = vap->va_ctime;
@


1.22
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.21 2001/06/27 04:58:42 art Exp $	*/
d204 1
a204 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.21
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.20 2001/06/23 02:14:25 csapuntz Exp $	*/
a62 1
#include <vm/vm.h>
@


1.20
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.19 2000/03/13 04:05:15 millert Exp $	*/
a62 1
#if defined(UVM)
a64 3
#else
#include <sys/vmmeter.h>
#endif
a103 1
#if defined(UVM)
a104 3
#else
     { DT_REG, N("pagesize"),  &cnt.v_page_size, KTT_INT,  VREG, READ_MODE  },
#endif
a307 1
#if defined(UVM)
a308 3
#else
		sprintf(*bufp, "%u\n", physmem - cnt.v_wire_count);
#endif
@


1.19
log
@Get rid of leading NULs in /kern/msgbuf.  If the msgbuf modified in between
reads at just the right time is is possible to get duplicate output but
in practice this is extremely rare.  Joint effort with Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.18 2000/02/22 19:28:06 deraadt Exp $	*/
a191 1
	{ &vop_mmap_desc, kernfs_mmap },	/* mmap */
a192 1
	{ &vop_seek_desc, kernfs_seek },	/* seek */
a211 5
	{ &vop_blkatoff_desc, kernfs_blkatoff },/* blkatoff */
	{ &vop_valloc_desc, kernfs_valloc },	/* valloc */
	{ &vop_vfree_desc, kernfs_vfree },	/* vfree */
	{ &vop_truncate_desc, kernfs_truncate },/* truncate */
	{ &vop_update_desc, kernfs_update },	/* update */
@


1.18
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.17 1999/11/10 23:17:39 csapuntz Exp $	*/
d272 13
a284 6
		if (off >= msgbufp->msg_bufs)
			return (0);
		n = msgbufp->msg_bufx + off;
		if (n >= msgbufp->msg_bufs)
			n -= msgbufp->msg_bufs;
		len = min(msgbufp->msg_bufs - n, msgbufp->msg_bufs - off);
@


1.17
log
@

Fix to use enoioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.16 1999/02/26 03:44:16 art Exp $	*/
d260 13
a272 1
		if (off >= MSG_BSIZE)
d275 3
a277 3
		if (n >= MSG_BSIZE)
			n -= MSG_BSIZE;
		len = min(MSG_BSIZE - n, MSG_BSIZE - off);
d323 2
a324 2
        case KTT_IPSECSPI:
                return(ipsp_kern(off, bufp, len));
@


1.17.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d260 1
a260 13
		if (msgbufp == NULL || msgbufp->msg_magic != MSG_MAGIC)
			return (ENXIO);

		/*
		 * Note that reads of /kern/msgbuf won't necessarily yield
		 * consistent results, if the message buffer is modified
		 * while the read is in progress.  The worst that can happen
		 * is that incorrect data will be read.  There's no way
		 * that this can crash the system unless the values in the
		 * message buffer header are corrupted, but that'll cause
		 * the system to die anyway.
		 */
		if (off >= msgbufp->msg_bufs)
d263 3
a265 3
		if (n >= msgbufp->msg_bufs)
			n -= msgbufp->msg_bufs;
		len = min(msgbufp->msg_bufs - n, msgbufp->msg_bufs - off);
d311 2
a312 2
	case KTT_IPSECSPI:
		return(ipsp_kern(off, bufp, len));
@


1.17.2.2
log
@Sync with -current
@
text
@d272 6
a277 13
		if (msgbufp->msg_bufl < msgbufp->msg_bufs) {
			if (off >= msgbufp->msg_bufx)
				return (0);
			n = off;
			len = msgbufp->msg_bufx - n;
		} else {
			if (off >= msgbufp->msg_bufs)
				return (0);
			n = msgbufp->msg_bufx + off;
			if (n >= msgbufp->msg_bufs)
				n -= msgbufp->msg_bufs;
			len = min(msgbufp->msg_bufs - n, msgbufp->msg_bufs - off);
		}
@


1.17.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.17.2.2 2000/03/24 09:09:29 niklas Exp $	*/
d63 1
d66 3
d108 1
d110 3
d192 1
d194 1
d214 5
d323 1
d325 3
@


1.17.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
@


1.17.2.5
log
@Merge in trunk
@
text
@d104 1
a104 1
     { DT_REG, N("physmem"),   &physmem,     KTT_PHYSMEM,  VREG, READ_MODE  },
a165 1
int	kernfs_freevp __P((struct vnode *, struct proc *));
d204 1
a204 1
	{ NULL, NULL }
a208 111
TAILQ_HEAD(, kernfs_node) kfshead;
static struct lock kfscache_lock;

int
kernfs_init(vfsp)
	struct vfsconf *vfsp;
{
	lockinit(&kfscache_lock, PVFS, "kfs", 0, 0);
	TAILQ_INIT(&kfshead);
	return(0);
}

int
kernfs_allocvp(kt, mp, vpp)
	struct kern_target *kt;
	struct mount *mp;
	struct vnode **vpp;
{
	struct proc *p = curproc;
	struct kernfs_node *kf;
	struct vnode *vp;
	int error = 0;

#ifdef KERNFS_DIAGNOSTIC
	/* this should never happen */
	if (kt == NULL) 
		panic("kernfs_allocvp passed NULL kt, mp %p, vpp %p!\n", mp, vpp);

	printf("kernfs_allocvp: looking for %s\n", kt->kt_name);
#endif
	if ((error = lockmgr(&kfscache_lock, LK_EXCLUSIVE, NULL, p)) != 0)
		return(error);

loop:
	for (kf = TAILQ_FIRST(&kfshead); kf != NULL; kf = TAILQ_NEXT(kf, list)) {
		vp = KERNTOV(kf);
		if (vp->v_mount == mp && kt->kt_namlen == kf->kf_namlen &&
			bcmp(kf->kf_name, kt->kt_name, kt->kt_namlen) == 0) {
#ifdef KERNFS_DIAGNOSTIC
			printf("kernfs_allocvp: hit %s\n", kt->kt_name);
#endif
			if (vget(vp, 0, p)) 
				goto loop;
			*vpp = vp;
			goto out;
		}
	}

	MALLOC(kf, void *, sizeof(struct kernfs_node), M_TEMP, M_WAITOK);
	error = getnewvnode(VT_KERNFS, mp, kernfs_vnodeop_p, vpp);
	if (error) {
		FREE(kf, M_TEMP);
		goto out;
	}
	vp = *vpp;
	kf->kf_kt = kt;
	kf->kf_vnode = vp;
	vp->v_type = kf->kf_vtype;
	vp->v_data = kf; 
	if (kf->kf_namlen == 1 && bcmp(kf->kf_name, ".", 1) == 0) 
		vp->v_flag |= VROOT;

	TAILQ_INSERT_TAIL(&kfshead, kf, list);
out:
	lockmgr(&kfscache_lock, LK_RELEASE, NULL, p);

#ifdef KERNFS_DIAGNOSTIC
	if (error) 
		printf("kernfs_allocvp: error %d\n", error);
#endif
	return(error);
}

int
kernfs_freevp(vp, p)
	struct vnode *vp;
	struct proc *p;
{
	struct kernfs_node *kf = VTOKERN(vp);

	TAILQ_REMOVE(&kfshead, kf, list);
	VOP_UNLOCK(vp, 0, p);
	FREE(vp->v_data, M_TEMP);
	vp->v_data = 0;
	return(0);
}

struct kern_target *
kernfs_findtarget(name, namlen)
	char	*name;
	int	namlen;
{
	struct kern_target *kt = NULL;
	int i;
	
	for (i = 0; i < nkern_targets; i++) {
		if (kern_targets[i].kt_namlen == namlen && 
			bcmp(kern_targets[i].kt_name, name, namlen) == 0) {
			kt = &kern_targets[i];
			break;
		}
	}

#ifdef KERNFS_DIAGNOSTIC
	if (i == nkern_targets || kt == NULL)
		printf("kernfs_findtarget: no match for %s\n");
#endif
	return(kt);
}
	
	
d307 1
a307 5
		sprintf(*bufp, "%u\n", ctob(physmem - uvmexp.wired));
		break;

	case KTT_PHYSMEM:
		sprintf(*bufp, "%u\n", ctob(physmem));
a308 1

d373 2
a374 2
	struct vnode *vp;
	int error;
d381 1
a381 1
	VOP_UNLOCK(dvp, 0, p);
d387 1
a387 1
	if (cnp->cn_namelen == 1 && *pname == '.') { 
d394 13
a406 5
	kt = kernfs_findtarget(pname, cnp->cn_namelen);
	if (kt == NULL) {
		/* not found */
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
		return(cnp->cn_nameiop == LOOKUP ? ENOENT : EROFS);
d409 8
a418 1
		
d420 4
a423 5
		if (*dp == NODEV || !vfinddev(*dp, kt->kt_vtype, &vp)) 
			return(ENOENT);
		
		*vpp = vp;
		if (vget(vp, LK_EXCLUSIVE, p)) 
d425 1
a425 1
		return(0);
d428 5
a432 2

	if ((error = kernfs_allocvp(kt, dvp->v_mount, vpp)) != 0) {
d434 1
a434 1
		return(error);
d437 11
a447 2
	vn_lock(*vpp, LK_SHARED | LK_RETRY, p);
	return(error);
d449 1
a449 1
		
d470 2
a471 2
	
	mode_t fmode = (vp->v_flag & VROOT) ? DIR_MODE : VTOKERN(vp)->kf_mode;
a491 1

d502 1
a502 1
	vap->va_ctime = vap->va_atime;
d510 1
a510 2
		struct kern_target *kt = VTOKERN(vp)->kf_kt;
		printf("kernfs_getattr: stat rootdir (%s)\n", kt->kt_name);
a624 4
#ifdef KERNFS_DIAGNOSTIC
	printf("kernfs_write %s\n", kt->kt_name);
#endif

d706 1
d708 1
a708 5
	struct kernfs_node *kf;

	kf = VTOKERN(vp);

	printf("kernfs_inactive(%p) %s\n", vp, kf->kf_name);
d710 4
d715 1
d727 1
a727 1
	struct proc *p = curproc;
d729 1
a729 5
	struct kernfs_node *kf;

	kf = VTOKERN(vp);

	printf("kernfs_reclaim(%p) %s\n", vp, kf->kf_name);
d731 5
a735 1
	return(kernfs_freevp(vp, p));
d777 1
a777 1
 * Print out some details of a kernfs vnode.
a783 4
	struct vop_print_args /*
		struct vnode *a_vp;
	} */ *ap = v;
	struct kernfs_node *kf = VTOKERN(ap->a_vp);
d785 1
a785 3
	printf("tag VT_KERNFS, kernfs vnode: name %s, vp %p, tag %d\n", 
		kf->kf_name, kf->kf_vnode, kf->kf_tag); 
		
d794 1
d824 1
a824 1

d831 1
a831 1
 * kernfs "should never get here" operation
@


1.17.2.6
log
@Merge in -current from roughly a week ago
@
text
@d77 1
d80 1
a80 1
extern int ipsp_kern(int, char **, int);
d91 1
a91 1
     { DT_REG, N("copyright"), (void*)copyright,KTT_STRING,   VREG, READ_MODE  },
d100 3
a102 3
     { DT_REG, N("ostype"),    (void*)&ostype,KTT_STRING,   VREG, READ_MODE  },
     { DT_REG, N("osrelease"), (void*)&osrelease,KTT_STRING,VREG, READ_MODE  },
     { DT_REG, N("osrev"),     &osrev,	     KTT_INT,      VREG, READ_MODE  },
d113 1
a113 1
     { DT_REG, N("version"),   (void*)version,KTT_STRING,  VREG, READ_MODE  },
d121 1
a121 1
int	kernfs_badop(void *);
d123 1
a123 1
int	kernfs_lookup(void *);
d126 1
a126 1
int	kernfs_open(void *);
d128 6
a133 6
int	kernfs_access(void *);
int	kernfs_getattr(void *);
int	kernfs_setattr(void *);
int	kernfs_read(void *);
int	kernfs_write(void *);
#define	kernfs_ioctl	(int (*)(void *))enoioctl
d139 1
a139 1
int	kernfs_link(void *);
d144 2
a145 2
int	kernfs_symlink(void *);
int	kernfs_readdir(void *);
d147 2
a148 2
int	kernfs_inactive(void *);
int	kernfs_reclaim(void *);
d153 1
a153 1
int	kernfs_print(void *);
d155 1
a155 1
int	kernfs_pathconf(void *);
d159 1
a159 1
int	kernfs_vfree(void *);
d164 3
a166 3
int	kernfs_xread(struct kern_target *, int, char **, int);
int	kernfs_xwrite(struct kern_target *, char *, int);
int	kernfs_freevp(struct vnode *, struct proc *);
d168 1
a168 1
int (**kernfs_vnodeop_p)(void *);
@


1.17.2.7
log
@Sync the SMP branch with 3.3
@
text
@d235 1
a235 1
		panic("kernfs_allocvp passed NULL kt, mp %p, vpp %p!", mp, vpp);
d290 1
d490 1
a490 1
	int error, wantpunlock;
d497 1
a497 1

a498 1
	cnp->cn_flags &= ~PDIRUNLOCK;
d506 1
a509 2
	wantpunlock = (~cnp->cn_flags & (LOCKPARENT | ISLASTCN));

d513 1
a526 4
		if (wantpunlock) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
d532 1
d537 1
a537 6

	if (wantpunlock) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
	return (0);
@


1.17.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.17.2.7 2003/03/28 00:00:20 niklas Exp $	*/
d332 1
a332 1
		snprintf(*bufp, len, "%ld %ld\n", tv.tv_sec, tv.tv_usec);
d339 1
a339 1
		snprintf(*bufp, len, "%d\n", *ip);
a344 7
		size_t end = strlen(cp);

		if (end && cp[end - 1] != '\n') {
			strlcpy(*bufp, cp, len - 1);
			strlcat(*bufp, "\n", len);
		} else
			*bufp = cp;
d346 1
d411 1
a411 1
		snprintf(*bufp, len, "%d %d %d %ld\n",
d417 1
a417 1
		snprintf(*bufp, len, "%u\n", ctob(physmem - uvmexp.wired));
d421 1
a421 1
		snprintf(*bufp, len, "%u\n", ctob(physmem));
d539 1
a539 1
	vn_lock(*vpp, LK_EXCLUSIVE | LK_RETRY, p);
@


1.17.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.17.2.8 2003/05/13 19:21:29 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a56 1
#include <sys/poll.h>
d78 1
a78 1
const struct kern_target kern_targets[] = {
d114 1
a114 1
static const int nkern_targets = sizeof(kern_targets) / sizeof(kern_targets[0]);
d129 1
d159 2
a160 2
int	kernfs_xread(const struct kern_target *, int, char **, int);
int	kernfs_xwrite(const struct kern_target *, char *, int);
d177 1
a177 1
	{ &vop_poll_desc, kernfs_poll },	/* poll */
d219 1
a219 1
	const struct kern_target *kt;
d291 1
a291 1
const struct kern_target *
d296 1
a296 1
	const struct kern_target *kt = NULL;
d309 1
a309 1
		printf("kernfs_findtarget: no match for %s\n", name);
d317 1
a317 1
	const struct kern_target *kt;
d443 1
a443 1
	const struct kern_target *kt;
d489 1
a489 1
	const struct kern_target *kt;
d588 1
d600 2
a601 1
	TIMEVAL_TO_TIMESPEC(&time, &vap->va_atime);
d620 1
a620 1
		const struct kern_target *kt = VTOKERN(vp)->kf_kt;
a624 6
		if (kt == &kern_targets[2]) {
			/* set boottime times to boottime */
			TIMEVAL_TO_TIMESPEC(&boottime, &vap->va_atime);
			vap->va_mtime = vap->va_atime;
			vap->va_ctime = vap->va_atime;
		}
d678 1
a678 1
	const struct kern_target *kt;
d718 1
a718 1
	const struct kern_target *kt;
d761 1
a761 1
	const struct kern_target *kt;
a949 13
}

int
kernfs_poll(v)
	void *v;
{
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;  
		struct proc *a_p;   
	} */ *ap = v;

	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
@


1.17.2.11
log
@Merge with the trunk
@
text
@d592 1
a592 1
	bzero(vap, sizeof(*vap));
d777 1
a777 1
	bzero(&d, UIO_MX);
d799 1
a799 1
		if ((error = uiomove(&d, UIO_MX, uio)) != 0)
@


1.17.2.12
log
@sync to HEAD
@
text
@d72 1
a72 1
extern int	ncpus;
d95 1
a95 1
     { DT_REG, N("ncpu"),      &ncpus,       KTT_INT,      VREG, READ_MODE  },
@


1.16
log
@cnt is called uvmexp in uvm and the members have different names
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.15 1998/08/06 19:34:36 csapuntz Exp $	*/
d142 1
a142 1
#define	kernfs_ioctl	eopnotsupp
@


1.15
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.14 1998/06/11 16:34:23 deraadt Exp $	*/
a48 1
#include <sys/vmmeter.h>
d63 7
d108 3
d112 1
d304 3
d308 1
@


1.14
log
@return EOPNOTSUPP for chflags() changes; peter@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.13 1997/11/06 05:58:38 csapuntz Exp $	*/
d140 1
a140 1
#define kernfs_revoke   vop_revoke
a145 1
int	kernfs_abortop	__P((void *));
d148 2
a149 2
#define	kernfs_lock	vop_nolock
#define	kernfs_unlock	vop_nounlock
d153 1
a153 1
#define	kernfs_islocked	vop_noislocked
d193 1
a193 1
	{ &vop_abortop_desc, kernfs_abortop },	/* abortop */
a814 14
}

int
kernfs_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;
 
	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
@


1.13
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.12 1997/10/06 20:20:26 deraadt Exp $	*/
d533 10
@


1.12
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.10 1997/09/11 05:26:11 millert Exp $	*/
a120 1
int	kernfs_enotsupp __P((void *));
d123 2
a124 2
#define	kernfs_create	kernfs_enotsupp
#define	kernfs_mknod	kernfs_enotsupp
d132 3
a134 3
#define	kernfs_ioctl	kernfs_enotsupp
#define	kernfs_select	kernfs_enotsupp
#define	kernfs_mmap	kernfs_enotsupp
d137 1
a137 1
#define	kernfs_remove	kernfs_enotsupp
d139 4
a142 3
#define	kernfs_rename	kernfs_enotsupp
#define	kernfs_mkdir	kernfs_enotsupp
#define	kernfs_rmdir	kernfs_enotsupp
d145 1
a145 1
#define	kernfs_readlink	kernfs_enotsupp
d149 2
a150 2
#define	kernfs_lock	nullop
#define	kernfs_unlock	nullop
d154 1
a154 1
#define	kernfs_islocked	nullop
d156 3
a158 3
#define	kernfs_advlock	kernfs_enotsupp
#define	kernfs_blkatoff	kernfs_enotsupp
#define	kernfs_valloc	kernfs_enotsupp
d160 3
a162 3
#define	kernfs_truncate	kernfs_enotsupp
#define	kernfs_update	kernfs_enotsupp
#define	kernfs_bwrite	kernfs_enotsupp
d182 1
d359 1
d378 1
a378 1
		/*VOP_LOCK(dvp);*/
d386 1
a386 1
		VOP_LOCK(rootdir);
d401 1
d411 1
a411 1
		if (vget(fvp, 1))
d420 2
a421 1
	if (error)
d423 1
d429 1
d630 1
a633 4
	int i;
	int error;
	u_long *cookies = ap->a_cookies;
	int ncookies = ap->a_ncookies;
a668 2
		if (ncookies-- > 0)
			*cookies++ = i + 1;
d681 1
d692 1
a819 12
}

/*
 * /dev/fd vnode unsupported operation
 */
/*ARGSUSED*/
int
kernfs_enotsupp(v)
	void *v;
{

	return (EOPNOTSUPP);
@


1.11
log
@VFS Lite2 Changes
@
text
@d121 1
d124 2
a125 2
#define	kernfs_create	eopnotsupp
#define	kernfs_mknod	eopnotsupp
d133 3
a135 3
#define	kernfs_ioctl	eopnotsupp
#define	kernfs_select	eopnotsupp
#define	kernfs_mmap	eopnotsupp
d138 1
a138 1
#define	kernfs_remove	eopnotsupp
d140 3
a142 4
#define	kernfs_rename	eopnotsupp
#define kernfs_revoke   vop_revoke
#define	kernfs_mkdir	eopnotsupp
#define	kernfs_rmdir	eopnotsupp
d145 1
a145 1
#define	kernfs_readlink	eopnotsupp
d149 2
a150 2
#define	kernfs_lock	vop_nolock
#define	kernfs_unlock	vop_nounlock
d154 1
a154 1
#define	kernfs_islocked	vop_noislocked
d156 3
a158 3
#define	kernfs_advlock	eopnotsupp
#define	kernfs_blkatoff	eopnotsupp
#define	kernfs_valloc	eopnotsupp
d160 3
a162 3
#define	kernfs_truncate	eopnotsupp
#define	kernfs_update	eopnotsupp
#define	kernfs_bwrite	eopnotsupp
a181 1
	{ &vop_revoke_desc, kernfs_revoke },    /* revoke */
a357 1
	struct proc *p = cnp->cn_proc;
d376 1
a376 1
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d384 1
a384 1
		vn_lock(rootdir, LK_SHARED | LK_RETRY, p);
a398 1
	vn_lock(dvp, LK_SHARED | LK_RETRY, p);
d408 1
a408 1
		if (vget(fvp, LK_EXCLUSIVE, p))
d417 1
a417 2
	if (error) {
		vn_lock(dvp, LK_SHARED | LK_RETRY, p);
a418 1
	}
a423 1
	vn_lock(fvp, LK_SHARED | LK_RETRY, p);
a623 1
	int error, i;
d627 4
d666 2
a679 1
		struct proc *a_p;
a689 1
	VOP_UNLOCK(vp, 0, ap->a_p);
d817 12
@


1.10
log
@Fix {KERNFS,NULLFS,UMAPFS,UNION}_DIAGNOSTIC kernel compilation errors.
From Alan Barrett <apb@@iafrica.com> with some changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.9 1997/04/26 12:10:00 kstailey Exp $	*/
a120 1
int	kernfs_enotsupp __P((void *));
d123 2
a124 2
#define	kernfs_create	kernfs_enotsupp
#define	kernfs_mknod	kernfs_enotsupp
d132 3
a134 3
#define	kernfs_ioctl	kernfs_enotsupp
#define	kernfs_select	kernfs_enotsupp
#define	kernfs_mmap	kernfs_enotsupp
d137 1
a137 1
#define	kernfs_remove	kernfs_enotsupp
d139 4
a142 3
#define	kernfs_rename	kernfs_enotsupp
#define	kernfs_mkdir	kernfs_enotsupp
#define	kernfs_rmdir	kernfs_enotsupp
d145 1
a145 1
#define	kernfs_readlink	kernfs_enotsupp
d149 2
a150 2
#define	kernfs_lock	nullop
#define	kernfs_unlock	nullop
d154 1
a154 1
#define	kernfs_islocked	nullop
d156 3
a158 3
#define	kernfs_advlock	kernfs_enotsupp
#define	kernfs_blkatoff	kernfs_enotsupp
#define	kernfs_valloc	kernfs_enotsupp
d160 3
a162 3
#define	kernfs_truncate	kernfs_enotsupp
#define	kernfs_update	kernfs_enotsupp
#define	kernfs_bwrite	kernfs_enotsupp
d182 1
d359 1
d378 1
a378 1
		/*VOP_LOCK(dvp);*/
d386 1
a386 1
		VOP_LOCK(rootdir);
d401 1
d411 1
a411 1
		if (vget(fvp, 1))
d420 2
a421 1
	if (error)
d423 1
d429 1
d630 1
a633 4
	int i;
	int error;
	u_long *cookies = ap->a_cookies;
	int ncookies = ap->a_ncookies;
a668 2
		if (ncookies-- > 0)
			*cookies++ = i + 1;
d681 1
d692 1
a819 12
}

/*
 * /dev/fd vnode unsupported operation
 */
/*ARGSUSED*/
int
kernfs_enotsupp(v)
	void *v;
{

	return (EOPNOTSUPP);
@


1.9
log
@struct definitions in .h files and instances in .c file please.

Vic Able:

> While <miscfs/kernfs/kernfs.h> has a kernfs_node, it depends
> on a structure that's defined in <miscfs/kernfs/kernfs_vnops.c>.
> Oops!  That's not very social.  :-)

[I built a new kernel fine, but don't have time to run "make build"
 it is my intuition that this will not have any bad effects, but
 I didn't test.  Just back it out if it hurts you and I'll try again.]
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.8 1997/03/27 04:39:39 millert Exp $	*/
d363 2
a364 2
	printf("kernfs_lookup(%x)\n", ap);
	printf("kernfs_lookup(dp = %x, vpp = %x, cnp = %x)\n", dvp, vpp, ap->a_cnp);
d427 1
a427 1
	printf("kernfs_lookup: newvp = %x\n", fvp);
d684 1
a684 1
	printf("kernfs_inactive(%x)\n", vp);
d704 1
a704 1
	printf("kernfs_reclaim(%x)\n", vp);
@


1.8
log
@Make kern.osrevision (sysctl) and /kern/osrev report value of
OpenBSD define, not BSD which is a bit more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.7 1997/02/20 01:08:12 deraadt Exp $	*/
d82 1
a82 22
struct kern_target {
	u_char kt_type;
	u_char kt_namlen;
	char *kt_name;
	void *kt_data;
#define	KTT_NULL	 1
#define	KTT_TIME	 5
#define KTT_INT		17
#define	KTT_STRING	31
#define KTT_HOSTNAME	47
#define KTT_AVENRUN	53
#define KTT_DEVICE	71
#define	KTT_MSGBUF	89
#define KTT_USERMEM	91
#define KTT_DOMAIN	95
#ifdef IPSEC
#define KTT_IPSECSPI	107
#endif
	u_char kt_tag;
	u_char kt_vtype;
	mode_t kt_mode;
} kern_targets[] = {
@


1.7
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.6 1997/01/15 03:06:28 kstailey Exp $	*/
d73 1
a73 1
static int	osrev = BSD;
@


1.6
log
@fixed warning:
kernfs_vnops.c:305: warning: long unsigned int format, u_int arg (arg 3)
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.5 1996/10/27 07:59:05 mickey Exp $	*/
d78 4
d97 3
d134 3
d317 4
a320 1

@


1.5
log
@and the same for the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4 1996/06/20 14:30:09 mickey Exp $	*/
d305 1
a305 1
		sprintf(*bufp, "%lu\n", physmem - cnt.v_wire_count);
@


1.4
log
@add more kernel variables. calculate used/free physmem and vnodes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.3 1996/04/21 22:28:14 deraadt Exp $	*/
d305 1
a305 1
		sprintf(*bufp, "%lu\n", ctob(physmem - cnt.v_wire_count));
@


1.4.4.1
log
@show symbol tables form ddb to userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4 1996/06/20 14:30:09 mickey Exp $	*/
a62 5
#ifdef DDB
#include <vm/vm_param.h>
#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#endif
d78 19
a96 1
struct kern_target kern_targets[] = {
d99 22
a120 33
 /* type    name            data          tag          type   vtype mode */
  { DT_DIR, N("."),         0,            KTT_NULL,    Kroot, VDIR, DIR_MODE  },
  { DT_DIR, N(".."),        0,            KTT_NULL,    Kroot, VDIR, DIR_MODE  },
  { DT_REG, N("boottime"),  &boottime.tv_sec, KTT_INT, Kvar,  VREG, READ_MODE },
  { DT_REG, N("byteorder"), &byteorder,   KTT_INT,     Kvar,  VREG, READ_MODE },
  { DT_REG, N("copyright"), copyright,    KTT_STRING,  Kvar,  VREG, READ_MODE },
  { DT_REG, N("domainname"),0,            KTT_DOMAIN,  Kvar,  VREG, WRITE_MODE},
  { DT_REG, N("hostname"),  0,            KTT_HOSTNAME,Kvar,  VREG, WRITE_MODE},
  { DT_REG, N("hz"),        &hz,          KTT_INT,     Kvar,  VREG, READ_MODE },
  { DT_REG, N("loadavg"),   0,            KTT_AVENRUN, Kvar,  VREG, READ_MODE },
  { DT_REG, N("machine"),   machine,      KTT_STRING,  Kvar,  VREG, READ_MODE },
  { DT_REG, N("model"),     cpu_model,    KTT_STRING,  Kvar,  VREG, READ_MODE },
  { DT_REG, N("msgbuf"),    0,	          KTT_MSGBUF,  Kvar,  VREG, READ_MODE },
  { DT_REG, N("ncpu"),      &ncpu,        KTT_INT,     Kvar,  VREG, READ_MODE },
  { DT_REG, N("osrelease"), &osrelease,   KTT_STRING,  Kvar,  VREG, READ_MODE },
  { DT_REG, N("osrev"),     &osrev,       KTT_INT,     Kvar,  VREG, READ_MODE },
  { DT_REG, N("ostype"),    &ostype,      KTT_STRING,  Kvar,  VREG, READ_MODE },
  { DT_REG, N("pagesize"),  &cnt.v_page_size, KTT_INT, Kvar,  VREG, READ_MODE },
  { DT_REG, N("physmem"),   &physmem,     KTT_INT,     Kvar,  VREG, READ_MODE },
  { DT_REG, N("posix"),     &posix,       KTT_INT,     Kvar,  VREG, READ_MODE },
#if notdef
  { DT_DIR, N("root"),      0,            KTT_NULL,    Kvar,  VDIR, DIR_MODE  },
#endif
  { DT_BLK, N("rootdev"),   &rootdev,     KTT_DEVICE,  Kvar,  VBLK, READ_MODE },
  { DT_CHR, N("rrootdev"),  &rrootdev,    KTT_DEVICE,  Kvar,  VCHR, READ_MODE },
#ifdef DDB
  { DT_DIR, N("sym"),       0,            KTT_NULL,    Ksym,  VDIR, DIR_MODE  },
#endif
  { DT_REG, N("time"),      0,            KTT_TIME,    Kvar,  VREG, READ_MODE },
  { DT_REG, N("usermem"),   0,            KTT_USERMEM, Kvar,  VREG, READ_MODE },
  { DT_REG, N("version"),   version,      KTT_STRING,  Kvar,  VREG, READ_MODE },
#if notdef
  { DT_DIR, N("var"),       0,            KTT_NULL,    Kvar,  VDIR, DIR_MODE  },
d122 5
a127 1
  { 0,      0, NULL,        0,            KTT_NULL,    0,     0,    0         }
d129 1
a129 1
#define	kern_ntargets	(sizeof(kern_targets)/sizeof(kern_targets[0]))
d138 1
a138 1
int	kernfs_close	__P((void *));
a307 3
	case KTT_SYMTAB:
		return 0;

a342 3
	case KTT_SYMTAB:
		return 0;

d366 1
d368 1
a368 2
	struct kernfs_node *kfs;
	int error;
a387 7
	kfs = VTOKERN(dvp);
	switch (kfs->kf_type) {
	case Kroot:
	{
		struct kern_target *kt;
		if (cnp->cn_flags & ISDOTDOT)
			return (EIO);
d389 6
a394 6
		if (cnp->cn_namelen == 4 && bcmp(pname, "root", 4) == 0) {
			*vpp = rootdir;
			VREF(rootdir);
			VOP_LOCK(rootdir);
			return (0);
		}
d397 5
a401 5
		for (kt = kern_targets; kt->kt_name != NULL; kt++) {
			if (cnp->cn_namelen == kt->kt_namlen &&
			    bcmp(kt->kt_name, pname, cnp->cn_namelen) == 0)
				break;
		}
a402 1
		if (kt->kt_name == NULL) {
d404 1
a404 1
			printf("kernfs_lookup: pname = %s, failed", pname);
d407 1
a407 2
			return (cnp->cn_nameiop == LOOKUP ? ENOENT : EROFS);
		}
d409 11
a419 11
		if (kt->kt_tag == KTT_DEVICE) {
			dev_t *dp = kt->kt_data;

			do {
				if (*dp == NODEV || !vfinddev(*dp, kt->kt_vtype, &fvp))
					return (ENOENT);
				*vpp = fvp;
			} while (vget(fvp, 1));

			return (0);
		}
d422 1
a422 1
		printf("kernfs_lookup: allocate new vnode\n");
d424 9
a432 2
		if ((error = kernfs_allocvp(dvp->v_mount, vpp, kt, kt->kt_ktype)) != 0)
			return error;
d435 1
a435 1
		printf("kernfs_lookup: newvp = %p\n", fvp);
a436 29
		return 0;
	}

	case Ksym:
	{
		db_symtab_t	st;

		if (cnp->cn_flags & ISDOTDOT)
			return (kernfs_root(dvp->v_mount, vpp));

		for (st = db_symiter(NULL); st != NULL; st = db_symiter(st))
			if (cnp->cn_namelen == strlen(st->name) &&
			     bcmp(st->name, pname, cnp->cn_namelen) == 0)
				break;

		if (st == NULL) {                               
#ifdef KERNFS_DIAGNOSTIC                                      
			printf("kernfs_lookup: pname = %s, failed", pname);
#endif
			return (cnp->cn_nameiop == LOOKUP ? ENOENT : EROFS);
		}

		return kernfs_allocvp(dvp->v_mount, vpp, st, Ksymtab );
	}

	default:
		return (ENOTDIR);
	}

d440 1
a444 21
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct kernfs_node *kfs = VTOKERN(ap->a_vp);

	switch (kfs->kf_type) {
	case Ksymtab:
		if (((kfs->kf_flags & FWRITE) && (ap->a_mode & O_EXCL)) ||
		    ((kfs->kf_flags & O_EXCL) && (ap->a_mode & FWRITE)))
			return (EBUSY);

		if (ap->a_mode & FWRITE)
			kfs->kf_flags = ap->a_mode & (FWRITE|O_EXCL);
		break;
	default:
		break;
	}

a449 22
kernfs_close(v)
	void *v;
{
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct kernfs_node *kfs = VTOKERN(ap->a_vp);

	switch (kfs->kf_type) {
	case Ksymtab:
		if ((ap->a_fflag & FWRITE) && (kfs->kf_flags & O_EXCL))
			kfs->kf_flags &= ~(FWRITE|O_EXCL);
		break;
	}

	return 0;
}

int
d461 1
a461 1
	    (vp->v_flag & VROOT) ? DIR_MODE : VTOKERN(vp)->kf_mode;
a476 1
	struct kernfs_node *kfs = VTOKERN(vp);
d480 1
d482 2
a483 3
	/* start by zeroing out the attributes */
	VATTR_NULL(vap);

d487 1
d492 2
a493 1
	vap->va_ctime = vap->va_atime;
d495 2
a496 2
	vap->va_bytes = vap->va_size = 0;
	vap->va_mode = kfs->kf_mode;
d503 1
d507 3
a509 4

#ifdef DDB
	} else if (kfs->kf_type == Ksymtab) {

d511 1
a511 1
		printf("kernfs_getattr: stat symtab %s\n", kfs->kf_st->name);
d513 2
a514 1
		vap->va_type = VREG;
d516 6
a521 25
		vap->va_fileid = 3 + kern_ntargets + kfs->kf_st->id;
		vap->va_size = kfs->kf_st->rend - kfs->kf_st->start;
#endif
	} else {
#ifdef KERNFS_DIAGNOSTIC
		printf("kernfs_getattr: stat target %s\n", kfs->kf_kt->kt_name);
#endif
		vap->va_type = kfs->kf_kt->kt_vtype;
		vap->va_fileid = 3 + (kfs->kf_kt - kern_targets);
		if (kfs->kf_type == Ksym) {
			vap->va_nlink = 2;
			vap->va_size = DEV_BSIZE;
		} else {
			int nbytes = 0, total = 0;
			char strbuf[KSTRING], *p = strbuf;

			do {
				p = strbuf;
				total += nbytes;
			} while ((nbytes =
				kernfs_xread(kfs->kf_kt, total, &p,
					     sizeof(strbuf)) != 0));
			vap->va_size = total;
			vap->va_nlink = 1;
		}
a554 1
	struct kernfs_node *kfs = VTOKERN(vp);
d556 1
a556 1
	struct kern_target *kt = kfs->kf_kt;
d564 1
a565 3
	off = uio->uio_offset;
	switch (kfs->kf_type) {
	case Kvar:
d567 1
a567 1
		printf("kern_read %s\n", kt->kt_name);
d569 2
d572 1
a572 1
		while (buf = strbuf,
d574 1
a574 12
		if (buf = strbuf,
#endif
		    len = kernfs_xread(kt, off, &buf, sizeof(strbuf))) {
			if ((error = uiomove(buf, len, uio)) != 0)
				return (error);
			off += len;
		}
		break;

	case Ksymtab:
#ifdef KERNFS_DIAGNOSTIC
		printf("kern_read %s, off = %d\n", kfs->kf_st->name, off);
d576 4
a579 7
		len = (kfs->kf_st->rend - kfs->kf_st->start);
		if (off > len)
			return 0;
		len = min(len, uio->uio_resid);
		if ((error = uiomove(kfs->kf_st->start + off, len, uio)) != 0)
			return error;
		break;
a580 1

d634 1
a634 1
	struct kernfs_node *kfs;
d636 1
a636 1
	int error = 0;
d645 2
d648 1
a651 40
	kfs = VTOKERN(ap->a_vp);

	switch (kfs->kf_type) {
	case Kroot:
	{
		register struct kern_target *kt;

		for (kt = &kern_targets[i];
		     uio->uio_resid >= UIO_MX &&
			 kt->kt_name != NULL &&
			 i < kern_ntargets;
		     kt++, i++) {
#ifdef KERNFS_DIAGNOSTIC
			printf("kernfs_readdir: kt = %s\n", kt->kt_name);
#endif

			if (kt->kt_tag == KTT_DEVICE) {
				dev_t *dp = kt->kt_data;
				struct vnode *fvp;

				if (*dp == NODEV || !vfinddev(*dp, kt->kt_vtype, &fvp))
					continue;
			}

			d.d_fileno = i + 3;
			d.d_namlen = kt->kt_namlen;
			bcopy(kt->kt_name, d.d_name, kt->kt_namlen + 1);
			d.d_type = kt->kt_type;

			if ((error = uiomove((caddr_t)&d, UIO_MX, uio)) != 0)
				break;
			if (ncookies-- > 0)
				*cookies++ = i + 1;
		}
	}
	break;

	case Ksym:
	{
		register db_symtab_t	st;
d653 2
d658 7
a664 29
		if (i == 0 || i == 1) {
			d.d_fileno = 3+ ((i==1)? -1: kfs->kf_kt - kern_targets);
			d.d_namlen = i + 1;
			bcopy("..", d.d_name, d.d_namlen);
			d.d_name[i + 1] = '\0';
			d.d_type = DT_DIR;

			if ((error = uiomove((caddr_t)&d, UIO_MX, uio)) != 0)
				break;
			if (ncookies-- > 0)
				*cookies++ = i + 1;
			i++;
		} else {
			register int j = i - 2;
			for (st = db_symiter(NULL);
			     st != NULL && j--;st = db_symiter(st));

			for (;st != NULL &&
			     uio->uio_resid >= UIO_MX; i++, st = db_symiter(st)) {
				d.d_fileno = st->id + 3 + kern_ntargets;
				d.d_namlen = strlen(st->name);
				bcopy(st->name, d.d_name, d.d_namlen+1);
				d.d_type = DT_REG;

				if ((error = uiomove((caddr_t)&d, UIO_MX, uio)) != 0)
					break;
				if (ncookies-- > 0)
					*cookies++ = i + 1;
			}
a665 2
	}
	break;
d667 9
a675 3
	default:
		error = ENOTDIR;
		break;
a689 2
	struct kernfs_node *kfs = VTOKERN(vp);
	db_symtab_t	st;
d694 5
a698 8
	if (kfs == NULL || kfs->kf_type != Ksymtab)
		return 0;

	for (st = db_symiter(NULL); st != NULL && st != kfs->kf_st; st = db_symiter(st))
		;

	if (st == NULL)
		vgone(vp);
d714 5
a718 1
	return (kernfs_freevp(ap->a_vp));
a766 4
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	struct kernfs_node *kfs = VTOKERN(ap->a_vp);
d768 1
a768 2
	printf("tag VT_KERNFS, type %d, mode %x, flags %lx\n",
		kfs->kf_type, kfs->kf_mode, kfs->kf_flags);
@


1.4.4.2
log
@-Wall happy
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4.4.1 1996/10/14 13:38:03 mickey Exp $	*/
a516 3

	default:
		break;
a684 3

	default:
		break;
a872 1
#ifdef KERNFS_DIAGNOSTIC
d875 1
@


1.4.4.3
log
@show both {user,phys}mem in pages, not in bytes
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4.4.2 1996/10/18 11:22:20 mickey Exp $	*/
d299 1
a299 1
		sprintf(*bufp, "%lu\n", physmem - cnt.v_wire_count);
@


1.4.4.4
log
@add exec header
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4.4.3 1996/10/27 07:57:12 mickey Exp $	*/
a61 1
#include <sys/exec.h>
d302 3
d340 3
d441 1
a441 1
#ifdef DDB
d463 1
a463 1
#endif
a483 1
#ifdef DDB
a491 1
#endif
a512 1
#ifdef DDB
d517 1
a517 1
#endif
d591 1
a591 2
		vap->va_size = sizeof(struct exec) +
			kfs->kf_st->rend - kfs->kf_st->start;
d676 1
a676 1
#ifdef DDB
a677 3
	{
		caddr_t p;
		struct exec xh;
d681 3
a683 12
		if (off < sizeof(struct exec)) {
			db_stub_xh(kfs->kf_st, &xh);
			len = sizeof(xh);
			p = (caddr_t)&xh;
		} else if (sizeof(struct exec) <= off &&
			   off < (sizeof(struct exec) +
				  (kfs->kf_st->rend - kfs->kf_st->rstart))) {
			len = (kfs->kf_st->rend - kfs->kf_st->rstart);
			off -= sizeof(struct exec);
			p = kfs->kf_st->rstart;
		} else
			return EIO;
d685 1
a685 1
		if ((error = uiomove(p + off, len, uio)) != 0)
a686 1
	}
d688 1
a688 1
#endif
d797 1
a797 1
#ifdef DDB
d837 1
a837 1
#endif
@


1.4.4.5
log
@wrong var rename.
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4.4.4 1997/02/07 06:07:56 mickey Exp $	*/
d590 1
a590 1
			kfs->kf_st->private - kfs->kf_st->start;
d689 2
a690 2
				  (kfs->kf_st->private - kfs->kf_st->rstart))) {
			len = (kfs->kf_st->private - kfs->kf_st->rstart);
@


1.4.4.6
log
@wrong private name
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4.4.5 1997/02/07 06:16:36 mickey Exp $	*/
d590 1
a590 1
			kfs->kf_st->rend - kfs->kf_st->start;
d689 2
a690 2
				  (kfs->kf_st->rend - kfs->kf_st->private))) {
			len = (kfs->kf_st->rend - kfs->kf_st->private);
d692 1
a692 1
			p = kfs->kf_st->private;
@


1.4.4.7
log
@clean compile w/o DDB and KERNFS_DIAGNOSTIC defined
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4.4.6 1997/02/07 06:47:06 mickey Exp $	*/
a862 1
#if defined(KERNFS_DIAGNOSTIC) || defined(DDB)
a866 2
#endif
#ifdef DDB
a868 1
#endif
a872 2

#ifdef DDB
a880 1
#endif
@


1.4.4.8
log
@last (i hope ;) branch commit for kernfs
/kern/sym/* working now (after i'll put all the ddb pieces in
it's cool.
@
text
@d1 2
a2 1
/*	$OpenBSD: kernfs_vnops.c,v 1.4.4.7 1997/04/13 04:48:13 mickey Exp $	*/
a4 1
 * Copyright (c) 1996, 1997 Michael Shalayeff
d64 1
d68 1
d84 1
a84 1
kern_target_t kern_targets[] = {
d87 1
a87 1
 /* type    name            data          tag          ktype  vtype mode */
d112 1
d114 1
d170 2
a171 2
int	kernfs_xread __P((kern_target_t *, int, char **, int));
int	kernfs_xwrite __P((kern_target_t *, char *, int));
d223 1
a223 1
	kern_target_t *kt;
d316 1
a316 1
	kern_target_t *kt;
a362 1
	kern_target_t *kt;
d387 1
d436 1
d455 2
a456 7
		
		if (!(error = kernfs_allocvp(dvp->v_mount, vpp, NULL, Ksymtab ))) {
			kfs = VTOKERN(*vpp);
			kfs->kf_st = st;
			db_stub_xh(st, &kfs->kf_xh);
		}
		return error;
d458 1
d479 1
d488 1
d510 1
d515 1
a551 1
	kern_target_t *kt = kfs->kf_kt;
d580 1
d589 3
a591 2
		vap->va_size = sizeof(struct exec) + kfs->kf_xh.a_text +
			kfs->kf_xh.a_data + db_symtablen(kfs->kf_st);
d594 1
a594 1
		printf("kernfs_getattr: stat target %s\n", kt->kt_name);
d596 1
a596 1
		vap->va_type = kt->kt_vtype;
d609 1
a609 1
				kernfs_xread(kt, total, &p,
d649 1
a649 1
	kern_target_t *kt = kfs->kf_kt;
d675 1
d679 1
a679 1
		char buf[512];
d684 10
a693 3
			len = sizeof(struct exec);
			p = (caddr_t)&kfs->kf_xh;
		} else if (off < N_SYMOFF(kfs->kf_xh)) {
d695 1
a695 9
		} else {
			off -= N_SYMOFF(kfs->kf_xh);
			len = sizeof(buf);
			p = buf;
			if (db_symatoff(kfs->kf_st, off, buf, &len))
				return EIO;
			off = 0;
		}
		len = min(len - off, uio->uio_resid);
d700 1
d720 1
a720 1
	kern_target_t *kt;
d778 1
a778 1
		register kern_target_t *kt;
d809 1
d849 1
d863 1
d868 2
d872 1
d878 1
d882 1
a882 2
	for (st = db_symiter(NULL); st != NULL && st != kfs->kf_st;
	     st = db_symiter(st))
d887 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: kernfs_vnops.c,v 1.2 1996/02/27 07:55:19 niklas Exp $	*/
d68 1
a68 1
#define	WRITE_MODE	(S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH)
d71 7
d91 2
d103 1
d106 1
d109 2
d112 4
d118 1
d125 1
d284 13
d304 4
d327 8
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kernfs_vnops.c,v 1.42 1996/02/13 13:12:55 mycroft Exp $	*/
d220 1
a220 1
		sprintf(*bufp, "%d %d\n", tv.tv_sec, tv.tv_usec);
d267 1
a267 1
		sprintf(*bufp, "%ld %ld %ld %ld\n",
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kernfs_vnops.c,v 1.39 1995/10/09 14:25:02 mycroft Exp $	*/
d112 95
d309 4
a312 1
kernfs_lookup(ap)
d317 1
a317 2
	} */ *ap;
{
d380 2
a381 2
	if (error = getnewvnode(VT_KERNFS, dvp->v_mount, kernfs_vnodeop_p,
	    &fvp))
d396 4
a399 7
kernfs_open(ap)
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
a400 1

d406 3
a408 1
kernfs_access(ap)
d414 1
a414 2
	} */ *ap;
{
d422 4
a425 1
kernfs_getattr(ap)
d431 1
a431 2
	} */ *ap;
{
d486 4
a489 7
kernfs_setattr(ap)
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
a490 1

d501 3
a503 1
kernfs_read(ap)
d509 1
a509 2
	} */ *ap;
{
d533 1
a533 1
		if (error = uiomove(buf, len, uio))
d541 3
a543 1
kernfs_write(ap)
d549 1
a549 2
	} */ *ap;
{
d565 1
a565 1
	if (error = uiomove(strbuf, xlen, uio))
d576 4
a579 1
kernfs_readdir(ap)
d587 1
a587 2
	} */ *ap;
{
d628 1
a628 1
		if (error = uiomove((caddr_t)&d, UIO_MX, uio))
d638 4
a641 1
kernfs_inactive(ap)
d644 1
a644 2
	} */ *ap;
{
d658 4
a661 1
kernfs_reclaim(ap)
d664 1
a664 2
	} */ *ap;
{
d680 4
a683 1
kernfs_pathconf(ap)
d688 1
a688 2
	} */ *ap;
{
d719 3
a721 4
kernfs_print(ap)
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap;
d728 27
a754 7
/*void*/
kernfs_vfree(ap)
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap;
d756 12
d769 11
d786 4
a789 1
kernfs_enotsupp()
d798 4
a801 1
kernfs_badop()
d805 1
a805 10
	/* NOTREACHED */
}

/*
 * kernfs vnode null operation
 */
kernfs_nullop()
{

	return (0);
a806 83

#define kernfs_create ((int (*) __P((struct  vop_create_args *)))kernfs_enotsupp)
#define kernfs_mknod ((int (*) __P((struct  vop_mknod_args *)))kernfs_enotsupp)
#define kernfs_close ((int (*) __P((struct  vop_close_args *)))nullop)
#define kernfs_ioctl ((int (*) __P((struct  vop_ioctl_args *)))kernfs_enotsupp)
#define kernfs_select ((int (*) __P((struct  vop_select_args *)))kernfs_enotsupp)
#define kernfs_mmap ((int (*) __P((struct  vop_mmap_args *)))kernfs_enotsupp)
#define kernfs_fsync ((int (*) __P((struct  vop_fsync_args *)))nullop)
#define kernfs_seek ((int (*) __P((struct  vop_seek_args *)))nullop)
#define kernfs_remove ((int (*) __P((struct  vop_remove_args *)))kernfs_enotsupp)
#define kernfs_link ((int (*) __P((struct  vop_link_args *)))kernfs_enotsupp)
#define kernfs_rename ((int (*) __P((struct  vop_rename_args *)))kernfs_enotsupp)
#define kernfs_mkdir ((int (*) __P((struct  vop_mkdir_args *)))kernfs_enotsupp)
#define kernfs_rmdir ((int (*) __P((struct  vop_rmdir_args *)))kernfs_enotsupp)
#define kernfs_symlink ((int (*) __P((struct vop_symlink_args *)))kernfs_enotsupp)
#define kernfs_readlink \
	((int (*) __P((struct  vop_readlink_args *)))kernfs_enotsupp)
#define kernfs_abortop ((int (*) __P((struct  vop_abortop_args *)))nullop)
#define kernfs_lock ((int (*) __P((struct  vop_lock_args *)))nullop)
#define kernfs_unlock ((int (*) __P((struct  vop_unlock_args *)))nullop)
#define kernfs_bmap ((int (*) __P((struct  vop_bmap_args *)))kernfs_badop)
#define kernfs_strategy ((int (*) __P((struct  vop_strategy_args *)))kernfs_badop)
#define kernfs_islocked ((int (*) __P((struct  vop_islocked_args *)))nullop)
#define kernfs_advlock ((int (*) __P((struct vop_advlock_args *)))kernfs_enotsupp)
#define kernfs_blkatoff \
	((int (*) __P((struct  vop_blkatoff_args *)))kernfs_enotsupp)
#define kernfs_valloc ((int(*) __P(( \
		struct vnode *pvp, \
		int mode, \
		struct ucred *cred, \
		struct vnode **vpp))) kernfs_enotsupp)
#define kernfs_truncate \
	((int (*) __P((struct  vop_truncate_args *)))kernfs_enotsupp)
#define kernfs_update ((int (*) __P((struct  vop_update_args *)))kernfs_enotsupp)
#define kernfs_bwrite ((int (*) __P((struct  vop_bwrite_args *)))kernfs_enotsupp)

int (**kernfs_vnodeop_p)();
struct vnodeopv_entry_desc kernfs_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, kernfs_lookup },	/* lookup */
	{ &vop_create_desc, kernfs_create },	/* create */
	{ &vop_mknod_desc, kernfs_mknod },	/* mknod */
	{ &vop_open_desc, kernfs_open },	/* open */
	{ &vop_close_desc, kernfs_close },	/* close */
	{ &vop_access_desc, kernfs_access },	/* access */
	{ &vop_getattr_desc, kernfs_getattr },	/* getattr */
	{ &vop_setattr_desc, kernfs_setattr },	/* setattr */
	{ &vop_read_desc, kernfs_read },	/* read */
	{ &vop_write_desc, kernfs_write },	/* write */
	{ &vop_ioctl_desc, kernfs_ioctl },	/* ioctl */
	{ &vop_select_desc, kernfs_select },	/* select */
	{ &vop_mmap_desc, kernfs_mmap },	/* mmap */
	{ &vop_fsync_desc, kernfs_fsync },	/* fsync */
	{ &vop_seek_desc, kernfs_seek },	/* seek */
	{ &vop_remove_desc, kernfs_remove },	/* remove */
	{ &vop_link_desc, kernfs_link },	/* link */
	{ &vop_rename_desc, kernfs_rename },	/* rename */
	{ &vop_mkdir_desc, kernfs_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, kernfs_rmdir },	/* rmdir */
	{ &vop_symlink_desc, kernfs_symlink },	/* symlink */
	{ &vop_readdir_desc, kernfs_readdir },	/* readdir */
	{ &vop_readlink_desc, kernfs_readlink },/* readlink */
	{ &vop_abortop_desc, kernfs_abortop },	/* abortop */
	{ &vop_inactive_desc, kernfs_inactive },/* inactive */
	{ &vop_reclaim_desc, kernfs_reclaim },	/* reclaim */
	{ &vop_lock_desc, kernfs_lock },	/* lock */
	{ &vop_unlock_desc, kernfs_unlock },	/* unlock */
	{ &vop_bmap_desc, kernfs_bmap },	/* bmap */
	{ &vop_strategy_desc, kernfs_strategy },/* strategy */
	{ &vop_print_desc, kernfs_print },	/* print */
	{ &vop_islocked_desc, kernfs_islocked },/* islocked */
	{ &vop_pathconf_desc, kernfs_pathconf },/* pathconf */
	{ &vop_advlock_desc, kernfs_advlock },	/* advlock */
	{ &vop_blkatoff_desc, kernfs_blkatoff },/* blkatoff */
	{ &vop_valloc_desc, kernfs_valloc },	/* valloc */
	{ &vop_vfree_desc, kernfs_vfree },	/* vfree */
	{ &vop_truncate_desc, kernfs_truncate },/* truncate */
	{ &vop_update_desc, kernfs_update },	/* update */
	{ &vop_bwrite_desc, kernfs_bwrite },	/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
};
struct vnodeopv_desc kernfs_vnodeop_opv_desc =
	{ &kernfs_vnodeop_p, kernfs_vnodeop_entries };
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
