head	1.57;
access;
symbols
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.51.0.2
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.37.0.4
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.4
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.10
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.8
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.10
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2017.07.08.09.19.02;	author mpi;	state Exp;
branches;
next	1.56;
commitid	5bYsyVcQqSuIdi7J;

1.56
date	2017.07.03.08.31.39;	author mpi;	state Exp;
branches;
next	1.55;
commitid	7YnXtPu60EljDjTB;

1.55
date	2017.07.03.08.27.07;	author mpi;	state Exp;
branches;
next	1.54;
commitid	qIdO0WksPcjTX0Ea;

1.54
date	2017.06.26.09.32.31;	author mpi;	state Exp;
branches;
next	1.53;
commitid	gZMpLuRopIsWa0cT;

1.53
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.52;
commitid	QqHqT2WhCBWqYgGJ;

1.52
date	2016.09.20.14.04.37;	author bluhm;	state Exp;
branches;
next	1.51;
commitid	lQED4FYdIyIchR76;

1.51
date	2016.06.07.06.12.37;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	3b5aikHetmWeZowP;

1.50
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.49;
commitid	gAjwyca5TfuoJAhn;

1.49
date	2015.09.01.07.17.57;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	Os95aupSQGE90rst;

1.48
date	2015.07.18.15.00.01;	author guenther;	state Exp;
branches;
next	1.47;
commitid	roluigiGALHjIxXb;

1.47
date	2015.05.10.22.35.39;	author millert;	state Exp;
branches;
next	1.46;
commitid	rtX5Mpzd4CgHtDmM;

1.46
date	2015.05.05.20.14.10;	author millert;	state Exp;
branches;
next	1.45;
commitid	9FdU1unXRSor93aJ;

1.45
date	2015.02.12.14.31.02;	author millert;	state Exp;
branches;
next	1.44;
commitid	MxGvBFBZmHEquZDd;

1.44
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.43;
commitid	P6Av4XGqOi3rFasL;

1.43
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.42;
commitid	EkuwmBeHv2Tqmdnx;

1.42
date	2014.10.09.16.36.36;	author millert;	state Exp;
branches;
next	1.41;
commitid	ybkKw3qJ6Hzuhega;

1.41
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.40;
commitid	uzzBR7hz9ncd4O6G;

1.40
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.39;
commitid	FE3DG5cICjyI4jWx;

1.39
date	2013.03.28.03.29.44;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.28.02.08.39;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2012.06.20.17.30.22;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.22.07.47.22;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.03.14.41.29;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.24.17.39.45;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.27.13.59.12;	author thib;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.29.15.38.00;	author chl;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.18.12.37.51;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.14.21.33.58;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.02.04.42.52;	author tedu;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2004.02.24.03.56.06;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.28.23.53.57;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.10;	author millert;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.11.08.04.34.17;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2002.03.14.01.27.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.22.44.31;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.06.23.02.14.24;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.01.20.54.34;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.15.23.21.42;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.58.34;	author csapuntz;	state Exp;
branches
	1.7.10.1;
next	1.6;

1.6
date	97.10.06.20.20.23;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.19.03;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.11.04.03.31.54;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.28.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.53.43;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.00;	author deraadt;	state Exp;
branches;
next	;

1.7.10.1
date	2001.05.14.22.32.53;	author niklas;	state Exp;
branches;
next	1.7.10.2;

1.7.10.2
date	2001.07.04.10.49.09;	author niklas;	state Exp;
branches;
next	1.7.10.3;

1.7.10.3
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.7.10.4;

1.7.10.4
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	1.7.10.5;

1.7.10.5
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.7.10.6;

1.7.10.6
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.7.10.7;

1.7.10.7
date	2004.06.05.23.13.05;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.11.04.18.02.31;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.22.36.11;	author tedu;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.05.20.04.05.38;	author tedu;	state Exp;
branches;
next	;

1.14.2.1
date	2004.03.03.08.50.13;	author brad;	state Exp;
branches;
next	;

1.15.2.1
date	2004.03.03.08.32.11;	author brad;	state Exp;
branches;
next	;

1.19.2.1
date	2004.05.26.20.27.43;	author brad;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Revert grabbing the socket lock in kqueue filters.

It is unsafe to sleep while iterating the list of pending events in
kqueue_scan().

Reported by abieber@@ and juanfra@@
@
text
@/*	$OpenBSD: fifo_vnops.c,v 1.56 2017/07/03 08:31:39 mpi Exp $	*/
/*	$NetBSD: fifo_vnops.c,v 1.18 1996/03/16 23:52:42 christos Exp $	*/

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fifo_vnops.c	8.4 (Berkeley) 8/10/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/event.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/poll.h>
#include <sys/unistd.h>

#include <miscfs/fifofs/fifo.h>

/*
 * This structure is associated with the FIFO vnode and stores
 * the state associated with the FIFO.
 */
struct fifoinfo {
	struct socket	*fi_readsock;
	struct socket	*fi_writesock;
	long		fi_readers;
	long		fi_writers;
};

struct vops fifo_vops = {
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_close	= fifo_close,
	.vop_access	= fifo_ebadf,
	.vop_getattr	= fifo_ebadf,
	.vop_setattr	= fifo_ebadf,
	.vop_read	= fifo_read,
	.vop_write	= fifo_write,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= nullop,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_inactive	= fifo_inactive,
	.vop_reclaim	= fifo_reclaim,
	.vop_lock	= vop_generic_lock,
	.vop_unlock	= vop_generic_unlock,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_print	= fifo_print,
	.vop_islocked	= vop_generic_islocked,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock,
	.vop_bwrite	= nullop
};

void	filt_fifordetach(struct knote *kn);
int	filt_fiforead(struct knote *kn, long hint);
void	filt_fifowdetach(struct knote *kn);
int	filt_fifowrite(struct knote *kn, long hint);

struct filterops fiforead_filtops =
	{ 1, NULL, filt_fifordetach, filt_fiforead };
struct filterops fifowrite_filtops =
	{ 1, NULL, filt_fifowdetach, filt_fifowrite };

/*
 * Open called to set up a new instance of a fifo or
 * to find an active instance of a fifo.
 */
/* ARGSUSED */
int
fifo_open(void *v)
{
	struct vop_open_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fifoinfo *fip;
	struct proc *p = ap->a_p;
	struct socket *rso, *wso;
	int error;

	if ((fip = vp->v_fifoinfo) == NULL) {
		fip = malloc(sizeof(*fip), M_VNODE, M_WAITOK);
		vp->v_fifoinfo = fip;
		if ((error = socreate(AF_LOCAL, &rso, SOCK_STREAM, 0)) != 0) {
			free(fip, M_VNODE, sizeof *fip);
			vp->v_fifoinfo = NULL;
			return (error);
		}
		fip->fi_readsock = rso;
		if ((error = socreate(AF_LOCAL, &wso, SOCK_STREAM, 0)) != 0) {
			(void)soclose(rso);
			free(fip, M_VNODE, sizeof *fip);
			vp->v_fifoinfo = NULL;
			return (error);
		}
		fip->fi_writesock = wso;
		if ((error = soconnect2(wso, rso)) != 0) {
			(void)soclose(wso);
			(void)soclose(rso);
			free(fip, M_VNODE, sizeof *fip);
			vp->v_fifoinfo = NULL;
			return (error);
		}
		fip->fi_readers = fip->fi_writers = 0;
		wso->so_state |= SS_CANTSENDMORE;
		wso->so_snd.sb_lowat = PIPE_BUF;
	}
	if (ap->a_mode & FREAD) {
		fip->fi_readers++;
		if (fip->fi_readers == 1) {
			fip->fi_writesock->so_state &= ~SS_CANTSENDMORE;
			if (fip->fi_writers > 0)
				wakeup(&fip->fi_writers);
		}
	}
	if (ap->a_mode & FWRITE) {
		fip->fi_writers++;
		if ((ap->a_mode & O_NONBLOCK) && fip->fi_readers == 0) {
			error = ENXIO;
			goto bad;
		}
		if (fip->fi_writers == 1) {
			fip->fi_readsock->so_state &= ~(SS_CANTRCVMORE|SS_ISDISCONNECTED);
			if (fip->fi_readers > 0)
				wakeup(&fip->fi_readers);
		}
	}
	if ((ap->a_mode & O_NONBLOCK) == 0) {
		if ((ap->a_mode & FREAD) && fip->fi_writers == 0) {
			VOP_UNLOCK(vp, p);
			error = tsleep(&fip->fi_readers,
			    PCATCH | PSOCK, "fifor", 0);
			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
			if (error)
				goto bad;
		}
		if ((ap->a_mode & FWRITE) && fip->fi_readers == 0) {
			VOP_UNLOCK(vp, p);
			error = tsleep(&fip->fi_writers,
			    PCATCH | PSOCK, "fifow", 0);
			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
			if (error)
				goto bad;
		}
	}
	return (0);
bad:
	VOP_CLOSE(vp, ap->a_mode, ap->a_cred, ap->a_p);
	return (error);
}

/*
 * Vnode op for read
 */
/* ARGSUSED */
int
fifo_read(void *v)
{
	struct vop_read_args *ap = v;
	struct uio *uio = ap->a_uio;
	struct socket *rso = ap->a_vp->v_fifoinfo->fi_readsock;
	struct proc *p = uio->uio_procp;
	int error;

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_READ)
		panic("fifo_read mode");
#endif
	if (uio->uio_resid == 0)
		return (0);
	if (ap->a_ioflag & IO_NDELAY)
		rso->so_state |= SS_NBIO;
	VOP_UNLOCK(ap->a_vp, p);
	error = soreceive(rso, NULL, uio, NULL, NULL, NULL, 0);
	vn_lock(ap->a_vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (ap->a_ioflag & IO_NDELAY) {
		rso->so_state &= ~SS_NBIO;
		if (error == EWOULDBLOCK &&
		    ap->a_vp->v_fifoinfo->fi_writers == 0)
			error = 0;
	}
	return (error);
}

/*
 * Vnode op for write
 */
/* ARGSUSED */
int
fifo_write(void *v)
{
	struct vop_write_args *ap = v;
	struct socket *wso = ap->a_vp->v_fifoinfo->fi_writesock;
	struct proc *p = ap->a_uio->uio_procp;
	int error;

#ifdef DIAGNOSTIC
	if (ap->a_uio->uio_rw != UIO_WRITE)
		panic("fifo_write mode");
#endif
	if (ap->a_ioflag & IO_NDELAY)
		wso->so_state |= SS_NBIO;
	VOP_UNLOCK(ap->a_vp, p);
	error = sosend(wso, NULL, ap->a_uio, NULL, NULL, 0);
	vn_lock(ap->a_vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (ap->a_ioflag & IO_NDELAY)
		wso->so_state &= ~SS_NBIO;
	return (error);
}

/*
 * Device ioctl operation.
 */
/* ARGSUSED */
int
fifo_ioctl(void *v)
{
	struct vop_ioctl_args *ap = v;
	struct file filetmp;
	int error;

	if (ap->a_command == FIONBIO)
		return (0);
	if (ap->a_fflag & FREAD) {
		filetmp.f_data = ap->a_vp->v_fifoinfo->fi_readsock;
		error = soo_ioctl(&filetmp, ap->a_command, ap->a_data, ap->a_p);
		if (error)
			return (error);
	}
	if (ap->a_fflag & FWRITE) {
		filetmp.f_data = ap->a_vp->v_fifoinfo->fi_writesock;
		error = soo_ioctl(&filetmp, ap->a_command, ap->a_data, ap->a_p);
		if (error)
			return (error);
	}
	return (0);
}

/* ARGSUSED */
int
fifo_poll(void *v)
{
	struct vop_poll_args *ap = v;
	struct socket *rso = ap->a_vp->v_fifoinfo->fi_readsock;
	struct socket *wso = ap->a_vp->v_fifoinfo->fi_writesock;
	int events = 0;
	int revents = 0;

	/*
	 * FIFOs don't support out-of-band or high priority data.
	 */
	if (ap->a_fflag & FREAD)
		events |= ap->a_events & (POLLIN | POLLRDNORM);
	if (ap->a_fflag & FWRITE)
		events |= ap->a_events & (POLLOUT | POLLWRNORM);

	if (events & (POLLIN | POLLRDNORM)) {
		if (soreadable(rso))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	/* NOTE: POLLHUP and POLLOUT/POLLWRNORM are mutually exclusive */
	if ((rso->so_state & SS_ISDISCONNECTED) && !(ap->a_events & POLL_NOHUP)) {
		revents |= POLLHUP;
	} else if (events & (POLLOUT | POLLWRNORM)) {
		if (sowriteable(wso))
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (revents == 0) {
		/* We want to return POLLHUP even if no valid events set. */
		if (events == 0 && !(ap->a_events & POLL_NOHUP))
			events = POLLIN;
		if (events & (POLLIN | POLLRDNORM)) {
			selrecord(ap->a_p, &rso->so_rcv.sb_sel);
			rso->so_rcv.sb_flagsintr |= SB_SEL;
		}
		if (events & (POLLOUT | POLLWRNORM)) {
			selrecord(ap->a_p, &wso->so_snd.sb_sel);
			wso->so_snd.sb_flagsintr |= SB_SEL;
		}
	}
	return (revents);
}

int
fifo_inactive(void *v)
{
	struct vop_inactive_args *ap = v;

	VOP_UNLOCK(ap->a_vp, ap->a_p);
	return (0);
}


/*
 * Device close routine
 */
/* ARGSUSED */
int
fifo_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fifoinfo *fip = vp->v_fifoinfo;
	int s, error1 = 0, error2 = 0;

	if (fip == NULL)
		return (0);

	if (ap->a_fflag & FREAD) {
		if (--fip->fi_readers == 0) {
			struct socket *wso = fip->fi_writesock;

			s = solock(wso);
			socantsendmore(wso);
			sounlock(s);
		}
	}
	if (ap->a_fflag & FWRITE) {
		if (--fip->fi_writers == 0) {
			struct socket *rso = fip->fi_readsock;

			s = solock(rso);
			/* SS_ISDISCONNECTED will result in POLLHUP */
			rso->so_state |= SS_ISDISCONNECTED;
			socantrcvmore(rso);
			sounlock(s);
		}
	}
	if (fip->fi_readers == 0 && fip->fi_writers == 0) {
		error1 = soclose(fip->fi_readsock);
		error2 = soclose(fip->fi_writesock);
		free(fip, M_VNODE, sizeof *fip);
		vp->v_fifoinfo = NULL;
	}
	return (error1 ? error1 : error2);
}

int
fifo_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fifoinfo *fip = vp->v_fifoinfo;

	if (fip == NULL)
		return (0);

	soclose(fip->fi_readsock);
	soclose(fip->fi_writesock);
	free(fip, M_VNODE, sizeof *fip);
	vp->v_fifoinfo = NULL;

	return (0);
}

/*
 * Print out the contents of a fifo vnode.
 */
int
fifo_print(void *v)
{
	struct vop_print_args *ap = v;

	printf("tag VT_NON");
	fifo_printinfo(ap->a_vp);
	printf("\n");
	return 0;
}

/*
 * Print out internal contents of a fifo vnode.
 */
void
fifo_printinfo(struct vnode *vp)
{
	struct fifoinfo *fip = vp->v_fifoinfo;

	printf(", fifo with %ld readers and %ld writers",
		fip->fi_readers, fip->fi_writers);
}

/*
 * Return POSIX pathconf information applicable to fifo's.
 */
int
fifo_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	case _PC_TIMESTAMP_RESOLUTION:
		*ap->a_retval = 1;
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * Fifo failed operation
 */
/*ARGSUSED*/
int
fifo_ebadf(void *v)
{

	return (EBADF);
}

/*
 * Fifo advisory byte-level locks.
 */
/* ARGSUSED */
int
fifo_advlock(void *v)
{
	return (EOPNOTSUPP);
}

/*
 * Fifo bad operation
 */
/*ARGSUSED*/
int
fifo_badop(void *v)
{

	panic("fifo_badop called");
	/* NOTREACHED */
	return(0);
}


int
fifo_kqfilter(void *v)
{
	struct vop_kqfilter_args *ap = v;
	struct socket *so = (struct socket *)ap->a_vp->v_fifoinfo->fi_readsock;
	struct sockbuf *sb;

	switch (ap->a_kn->kn_filter) {
	case EVFILT_READ:
		ap->a_kn->kn_fop = &fiforead_filtops;
		sb = &so->so_rcv;
		break;
	case EVFILT_WRITE:
		ap->a_kn->kn_fop = &fifowrite_filtops;
		sb = &so->so_snd;
		break;
	default:
		return (EINVAL);
	}

	ap->a_kn->kn_hook = so;

	SLIST_INSERT_HEAD(&sb->sb_sel.si_note, ap->a_kn, kn_selnext);
	sb->sb_flags |= SB_KNOTE;

	return (0);
}

void
filt_fifordetach(struct knote *kn)
{
	struct socket *so = (struct socket *)kn->kn_hook;

	SLIST_REMOVE(&so->so_rcv.sb_sel.si_note, kn, knote, kn_selnext);
	if (SLIST_EMPTY(&so->so_rcv.sb_sel.si_note))
		so->so_rcv.sb_flags &= ~SB_KNOTE;
}

int
filt_fiforead(struct knote *kn, long hint)
{
	struct socket *so = (struct socket *)kn->kn_hook;
	int rv;

	kn->kn_data = so->so_rcv.sb_cc;
	if (so->so_state & SS_CANTRCVMORE) {
		kn->kn_flags |= EV_EOF;
		rv = 1;
	} else {
		kn->kn_flags &= ~EV_EOF;
		rv = (kn->kn_data > 0);
	}

	return (rv);
}

void
filt_fifowdetach(struct knote *kn)
{
	struct socket *so = (struct socket *)kn->kn_hook;

	SLIST_REMOVE(&so->so_snd.sb_sel.si_note, kn, knote, kn_selnext);
	if (SLIST_EMPTY(&so->so_snd.sb_sel.si_note))
		so->so_snd.sb_flags &= ~SB_KNOTE;
}

int
filt_fifowrite(struct knote *kn, long hint)
{
	struct socket *so = (struct socket *)kn->kn_hook;
	int rv;

	kn->kn_data = sbspace(so, &so->so_snd);
	if (so->so_state & SS_CANTSENDMORE) {
		kn->kn_flags |= EV_EOF;
		rv = 1;
	} else {
		kn->kn_flags &= ~EV_EOF;
		rv = (kn->kn_data >= so->so_snd.sb_lowat);
	}

	return (rv);
}
@


1.56
log
@Protect `so_state', `so_snd' and `so_rcv' with the socket lock in
kqueue filters.

ok millert@@, bluhm@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.55 2017/07/03 08:27:07 mpi Exp $	*/
d534 1
a534 1
	int s, rv;
a535 2
	if (!(hint & NOTE_SUBMIT))
		s = solock(so);
a543 2
	if (!(hint & NOTE_SUBMIT))
		sounlock(s);
d562 1
a562 1
	int s, rv;
a563 2
	if (!(hint & NOTE_SUBMIT))
		s = solock(so);
a571 2
	if (!(hint & NOTE_SUBMIT))
		sounlock(s);
@


1.55
log
@Not all sockets require the NET_LOCK().  So use solock() instead in
fifo_close().

ok millert@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.54 2017/06/26 09:32:31 mpi Exp $	*/
d534 1
d536 2
d541 4
a544 1
		return (1);
d546 4
a549 2
	kn->kn_flags &= ~EV_EOF;
	return (kn->kn_data > 0);
d566 1
d568 2
d573 4
a576 1
		return (1);
d578 4
a581 2
	kn->kn_flags &= ~EV_EOF;
	return (kn->kn_data >= so->so_snd.sb_lowat);
@


1.54
log
@Assert that the corresponding socket is locked when manipulating socket
buffers.

This is one step towards unlocking TCP input path.  Note that all the
functions asserting for the socket lock are not necessarilly MP-safe.
All the fields of 'struct socket' aren't protected.

Introduce a new kernel-only kqueue hint, NOTE_SUBMIT, to be able to
tell when a filter needs to lock the underlying data structures.  Logic
and name taken from NetBSD.

Tested by Hrvoje Popovski.

ok claudio@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.53 2016/12/19 08:36:49 mpi Exp $	*/
d359 5
a363 3
			NET_LOCK(s);
			socantsendmore(fip->fi_writesock);
			NET_UNLOCK(s);
d368 3
a370 1
			NET_LOCK(s);
d372 3
a374 3
			fip->fi_readsock->so_state |= SS_ISDISCONNECTED;
			socantrcvmore(fip->fi_readsock);
			NET_UNLOCK(s);
@


1.53
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.52 2016/09/20 14:04:37 bluhm Exp $	*/
d555 1
a555 1
	kn->kn_data = sbspace(&so->so_snd);
@


1.52
log
@Fifo did work around the socket layer.  Better call soconnect2()
instead of unp_connect2().  This adds the missing splsoftnet().
Require that socantsendmore() and socantrcvmore() in uipc_socket2.c
should be called with splsoftnet().
Found by David Hill; OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.51 2016/06/07 06:12:37 deraadt Exp $	*/
d359 1
a359 1
			s = splsoftnet();
d361 1
a361 1
			splx(s);
d366 1
a366 1
			s = splsoftnet();
d370 1
a370 1
			splx(s);
@


1.51
log
@ktrace support for pollfd[] arrays
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.50 2016/03/19 12:04:15 natano Exp $	*/
a50 1
#include <sys/unpcb.h>
d145 1
a145 1
		if ((error = unp_connect2(wso, rso)) != 0) {
d352 1
a352 1
	int error1 = 0, error2 = 0;
d358 2
a359 1
		if (--fip->fi_readers == 0)
d361 2
d366 1
d370 1
@


1.50
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.49 2015/09/01 07:17:57 deraadt Exp $	*/
d311 1
a311 1
	if ((rso->so_state & SS_ISDISCONNECTED) && !(ap->a_events & POLLNOHUP)) {
d319 1
a319 1
		if (events == 0 && !(ap->a_events & POLLNOHUP))
@


1.49
log
@trivial size for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.48 2015/07/18 15:00:01 guenther Exp $	*/
d179 1
a179 1
			VOP_UNLOCK(vp, 0, p);
d187 1
a187 1
			VOP_UNLOCK(vp, 0, p);
d222 1
a222 1
	VOP_UNLOCK(ap->a_vp, 0, p);
d252 1
a252 1
	VOP_UNLOCK(ap->a_vp, 0, p);
d338 1
a338 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
@


1.48
log
@Change unp_scan() and its callbacks to pass the array of struct file **
and a count instead of calling the callback on each one, while also renders
the 'dispose' argument superfluous.
Move unp_*() prototypes from <sys/un.h> to <sys/unpcb.h>

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.47 2015/05/10 22:35:39 millert Exp $	*/
d134 1
a134 1
			free(fip, M_VNODE, 0);
d141 1
a141 1
			free(fip, M_VNODE, 0);
d149 1
a149 1
			free(fip, M_VNODE, 0);
d372 1
a372 1
		free(fip, M_VNODE, 0);
d390 1
a390 1
	free(fip, M_VNODE, 0);
@


1.47
log
@Set POLLHUP even if no valid events were specified as per POSIX.
Since we use the poll backend for select(2), care must be taken not
to set the fd's bit in writefds in this case.  A kernel-only flag,
POLLNOHUP, is used by selscan() to tell the poll backend not to
return POLLHUP on EOF.  This is currently only used by fifo_poll().
The fifofs regress now passes.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.46 2015/05/05 20:14:10 millert Exp $	*/
d51 1
a51 1
#include <sys/un.h>
@


1.46
log
@Now that we have a_fflag in struct vop_poll_args we can handle
things like POLLOUT on a read-only fd more sensibly.  Previously,
any poll events could be used regardless of the actual file flags
of the descriptor.  The new fifo_poll() is effectively a pared down
soo_poll() with slightly different semantics to batter match FIFOs.
OK and feedback from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.45 2015/02/12 14:31:02 millert Exp $	*/
a298 1
	 * Just return if there are no supported events specified,
a304 2
	if (events == 0)
		return (0);
d311 1
a311 1
	if (rso->so_state & SS_ISDISCONNECTED) {
d318 3
@


1.45
log
@Fix a bug introduced in the last commit that broke EOF handling
in the normal, blocking case.  No longer passes regress but that
will be fixed later.  OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.44 2014/12/16 18:30:04 tedu Exp $	*/
d41 1
d293 3
a295 2
	struct file filetmp;
	const int events = ap->a_events;
d298 21
a318 4
	if (events & (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND)) {
		filetmp.f_data = ap->a_vp->v_fifoinfo->fi_readsock;
		if (filetmp.f_data)
			revents |= soo_poll(&filetmp, events, ap->a_p);
d320 8
a327 6
	/* POLLHUP and POLLOUT/POLLWRNORM/POLLWRBAND are mutually exclusive */
	if (!(revents & POLLHUP)) {
		if (events & (POLLOUT | POLLWRNORM | POLLWRBAND)) {
			filetmp.f_data = ap->a_vp->v_fifoinfo->fi_writesock;
			if (filetmp.f_data)
				revents |= soo_poll(&filetmp, events, ap->a_p);
@


1.44
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.43 2014/11/03 21:28:35 tedu Exp $	*/
a229 3
	/* Clear EOF indicator so we have a clean slate for a new writer. */
	if (error == 0)
		rso->so_state &= ~(SS_CANTRCVMORE|SS_ISDISCONNECTED);
d293 1
d296 1
a296 1
	if (ap->a_events & (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND)) {
d299 1
a299 1
			revents |= soo_poll(&filetmp, ap->a_events, ap->a_p);
d301 7
a307 4
	if (ap->a_events & (POLLOUT | POLLWRNORM | POLLWRBAND)) {
		filetmp.f_data = ap->a_vp->v_fifoinfo->fi_writesock;
		if (filetmp.f_data)
			revents |= soo_poll(&filetmp, ap->a_events, ap->a_p);
@


1.43
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.42 2014/10/09 16:36:36 millert Exp $	*/
d40 1
@


1.42
log
@Instead of trying to emulate select/poll semantics with respect to EOF
by mutating so_state before calling soo_poll(), call soo_poll() normally
but avoid setting SS_CANTRCVMORE in the reader's so_state on first open.
This fixes EOF detection in select/poll on the reader side when the write
side is closed.  Also set SS_ISDISCONNECTED when the writer count reaches
zero so POLLHUP is set in revents.  Unlike Unix domain sockets, we need
to clear the EOF indicator after it has been read so that subsequent
reads will block waiting for a new writer.  This now passes regress.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.41 2014/09/14 14:17:26 jsg Exp $	*/
d50 2
@


1.41
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.40 2014/07/12 18:43:52 tedu Exp $	*/
d150 1
a151 1
		rso->so_state |= SS_CANTRCVMORE;
d168 1
a168 1
			fip->fi_readsock->so_state &= ~SS_CANTRCVMORE;
d227 3
a292 1
	short ostate;
a295 10
		/*
		 * Socket and FIFO poll(2) semantics differ wrt EOF on read.
		 * Unlike a normal socket, FIFOs don't care whether or not
		 * SS_CANTRCVMORE is set.  To get the correct semantics we
		 * must clear SS_CANTRCVMORE from so_state temporarily.
		 */
		ostate = ap->a_vp->v_fifoinfo->fi_readsock->so_state;
		if (ap->a_events & (POLLIN | POLLRDNORM))
			ap->a_vp->v_fifoinfo->fi_readsock->so_state &=
			    ~SS_CANTRCVMORE;
a298 1
		ap->a_vp->v_fifoinfo->fi_readsock->so_state = ostate;
d338 3
a340 1
		if (--fip->fi_writers == 0)
d342 1
@


1.40
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.39 2013/03/28 03:29:44 guenther Exp $	*/
a35 1
#include <sys/proc.h>
@


1.39
log
@Add support for _PC_TIMESTAMP_RESOLUTION for ffs/mfs, cd9600, ext2,
msdos, NFS, fifos and devices, plus support for querying it in
getconf(2) and the requisite pathconf(2) manpage blurb

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.38 2013/03/28 02:08:39 guenther Exp $	*/
d131 1
a131 1
			free(fip, M_VNODE);
d138 1
a138 1
			free(fip, M_VNODE);
d146 1
a146 1
			free(fip, M_VNODE);
d354 1
a354 1
		free(fip, M_VNODE);
d372 1
a372 1
	free(fip, M_VNODE);
@


1.38
log
@Handle the pathconf _PC_PATH_MAX, _PC_PIPE_BUF, _PC_ASYNC_IO,
_PC_PRIO_IO, and _PC_SYNC_IO names in VOP_PATHCONF(), as they're
fs-independent for us.  Since we don't support latter three on any
fs, we can also define the related _POSIX_{ASYNC,PRIO,SYNC}_IO
symbols in <unistd.h> (via sys/unistd.h) with value -1.

Also, zap pointless tty-only values from procfs(!).

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.37 2012/06/20 17:30:22 matthew Exp $	*/
d418 3
@


1.37
log
@Cleanup our filesystem pathconf() code a little bit to make it easier
to diff against FreeBSD's.

From Brad; no object file change on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.36 2011/07/02 22:20:08 nicm Exp $	*/
a415 3
		break;
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
@


1.36
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.35 2011/04/05 14:14:07 thib Exp $	*/
d411 1
d416 1
a416 1
		return (0);
d419 1
a419 1
		return (0);
d422 1
a422 1
		return (0);
d424 2
a425 1
		return (EINVAL);
d427 2
a428 1
	/* NOTREACHED */
@


1.35
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.34 2010/12/21 20:14:43 thib Exp $	*/
d480 1
a480 1
		return (1);
@


1.34
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.33 2010/09/10 16:34:08 thib Exp $	*/
a64 1
	.vop_default	= eopnotsupp,
@


1.33
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.32 2010/09/06 23:44:10 thib Exp $	*/
d64 37
a100 39
int (**fifo_vnodeop_p)(void *);
struct vnodeopv_entry_desc fifo_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, vop_generic_lookup },
	{ &vop_create_desc, fifo_badop },
	{ &vop_mknod_desc, fifo_badop },
	{ &vop_open_desc, fifo_open },
	{ &vop_close_desc, fifo_close },
	{ &vop_access_desc, fifo_ebadf },
	{ &vop_getattr_desc, fifo_ebadf },
	{ &vop_setattr_desc, fifo_ebadf },
	{ &vop_read_desc, fifo_read },
	{ &vop_write_desc, fifo_write },
	{ &vop_ioctl_desc, fifo_ioctl },
	{ &vop_poll_desc, fifo_poll },
	{ &vop_kqfilter_desc, fifo_kqfilter },
	{ &vop_revoke_desc, vop_generic_revoke },
	{ &vop_fsync_desc, nullop },
	{ &vop_remove_desc, fifo_badop },
	{ &vop_link_desc, fifo_badop },
	{ &vop_rename_desc, fifo_badop },
	{ &vop_mkdir_desc, fifo_badop },
	{ &vop_rmdir_desc, fifo_badop },
	{ &vop_symlink_desc, fifo_badop },
	{ &vop_readdir_desc, fifo_badop },
	{ &vop_readlink_desc, fifo_badop },
	{ &vop_abortop_desc, fifo_badop },
	{ &vop_inactive_desc, fifo_inactive },
	{ &vop_reclaim_desc, fifo_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, vop_generic_bmap },
	{ &vop_strategy_desc, fifo_badop },
	{ &vop_print_desc, fifo_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, fifo_pathconf },
	{ &vop_advlock_desc, fifo_advlock },
	{ &vop_bwrite_desc, nullop },
	{ NULL, NULL }
a101 11

struct vnodeopv_desc fifo_vnodeop_opv_desc =
	{ &fifo_vnodeop_p, fifo_vnodeop_entries };

int
fifo_vnoperate(void *v)
{
	struct vop_generic_args *ap = v;

	return (VOCALL(fifo_vnodeop_p, ap->a_desc->vdesc_offset, ap));
}
@


1.32
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.31 2009/08/13 15:00:14 jasper Exp $	*/
d64 39
a102 37
struct vops fifo_vops = {
	.vop_default	= eopnotsupp,
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_close	= fifo_close,
	.vop_access	= fifo_ebadf,
	.vop_getattr	= fifo_ebadf,
	.vop_setattr	= fifo_ebadf,
	.vop_read	= fifo_read,
	.vop_write	= fifo_write,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= nullop,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_inactive	= fifo_inactive,
	.vop_reclaim	= fifo_reclaim,
	.vop_lock	= vop_generic_lock,
	.vop_unlock	= vop_generic_unlock,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_print	= fifo_print,
	.vop_islocked	= vop_generic_islocked,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock,
	.vop_bwrite	= nullop
d104 11
@


1.31
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.30 2009/02/22 07:47:22 otto Exp $	*/
d64 37
a100 39
int (**fifo_vnodeop_p)(void *);
struct vnodeopv_entry_desc fifo_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, vop_generic_lookup },
	{ &vop_create_desc, fifo_badop },
	{ &vop_mknod_desc, fifo_badop },
	{ &vop_open_desc, fifo_open },
	{ &vop_close_desc, fifo_close },
	{ &vop_access_desc, fifo_ebadf },
	{ &vop_getattr_desc, fifo_ebadf },
	{ &vop_setattr_desc, fifo_ebadf },
	{ &vop_read_desc, fifo_read },
	{ &vop_write_desc, fifo_write },
	{ &vop_ioctl_desc, fifo_ioctl },
	{ &vop_poll_desc, fifo_poll },
	{ &vop_kqfilter_desc, fifo_kqfilter },
	{ &vop_revoke_desc, vop_generic_revoke },
	{ &vop_fsync_desc, nullop },
	{ &vop_remove_desc, fifo_badop },
	{ &vop_link_desc, fifo_badop },
	{ &vop_rename_desc, fifo_badop },
	{ &vop_mkdir_desc, fifo_badop },
	{ &vop_rmdir_desc, fifo_badop },
	{ &vop_symlink_desc, fifo_badop },
	{ &vop_readdir_desc, fifo_badop },
	{ &vop_readlink_desc, fifo_badop },
	{ &vop_abortop_desc, fifo_badop },
	{ &vop_inactive_desc, fifo_inactive },
	{ &vop_reclaim_desc, fifo_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, vop_generic_bmap },
	{ &vop_strategy_desc, fifo_badop },
	{ &vop_print_desc, fifo_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, fifo_pathconf },
	{ &vop_advlock_desc, fifo_advlock },
	{ &vop_bwrite_desc, nullop },
	{ NULL, NULL }
a101 11

struct vnodeopv_desc fifo_vnodeop_opv_desc =
	{ &fifo_vnodeop_p, fifo_vnodeop_entries };

int
fifo_vnoperate(void *v)
{
	struct vop_generic_args *ap = v;

	return (VOCALL(fifo_vnodeop_p, ap->a_desc->vdesc_offset, ap));
}
@


1.30
log
@fix PR 6082: do not create more fd's than will fit in the message on
the receiving side when passing fd's. ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.29 2008/05/08 17:45:45 thib Exp $	*/
d67 35
a101 35
	{ &vop_lookup_desc, vop_generic_lookup },	/* lookup */
	{ &vop_create_desc, fifo_badop },		/* create */
	{ &vop_mknod_desc, fifo_badop },		/* mknod */
	{ &vop_open_desc, fifo_open },			/* open */
	{ &vop_close_desc, fifo_close },		/* close */
	{ &vop_access_desc, fifo_ebadf },		/* access */
	{ &vop_getattr_desc, fifo_ebadf },		/* getattr */
	{ &vop_setattr_desc, fifo_ebadf },		/* setattr */
	{ &vop_read_desc, fifo_read },			/* read */
	{ &vop_write_desc, fifo_write },		/* write */
	{ &vop_ioctl_desc, fifo_ioctl },		/* ioctl */
	{ &vop_poll_desc, fifo_poll },			/* poll */
	{ &vop_kqfilter_desc, fifo_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, vop_generic_revoke },	/* revoke */
	{ &vop_fsync_desc, nullop },			/* fsync */
	{ &vop_remove_desc, fifo_badop },		/* remove */
	{ &vop_link_desc, fifo_badop },			/* link */
	{ &vop_rename_desc, fifo_badop },		/* rename */
	{ &vop_mkdir_desc, fifo_badop },		/* mkdir */
	{ &vop_rmdir_desc, fifo_badop },		/* rmdir */
	{ &vop_symlink_desc, fifo_badop },		/* symlink */
	{ &vop_readdir_desc, fifo_badop },		/* readdir */
	{ &vop_readlink_desc, fifo_badop },		/* readlink */
	{ &vop_abortop_desc, fifo_badop },		/* abortop */
	{ &vop_inactive_desc, fifo_inactive },		/* inactive */
	{ &vop_reclaim_desc, fifo_reclaim },		/* reclaim */
	{ &vop_lock_desc, vop_generic_lock },		/* lock */
	{ &vop_unlock_desc, vop_generic_unlock },	/* unlock */
	{ &vop_bmap_desc, vop_generic_bmap },		/* bmap */
	{ &vop_strategy_desc, fifo_badop },		/* strategy */
	{ &vop_print_desc, fifo_print },		/* print */
	{ &vop_islocked_desc, vop_generic_islocked },	/* islocked */
	{ &vop_pathconf_desc, fifo_pathconf },		/* pathconf */
	{ &vop_advlock_desc, fifo_advlock },		/* advlock */
	{ &vop_bwrite_desc, nullop },			/* bwrite */
@


1.29
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.28 2008/05/03 14:41:29 thib Exp $	*/
d234 1
a234 1
	error = soreceive(rso, NULL, uio, NULL, NULL, NULL);
@


1.28
log
@Introduce vop_generic_bmap(); use it where applicable.
one thing of note, fifofs changes in that its bmap now
sets the runp too 0, but that was an oversight in the
old code.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.27 2008/04/24 17:39:45 thib Exp $	*/
d66 1
a66 1
	{ &vop_default_desc, vn_default_error },
@


1.27
log
@remove useless defines for the vnode operations, and instead
init the op array functions with whatever the define was set
too.

ok dlg@@,blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.26 2007/12/27 13:59:12 thib Exp $	*/
d95 1
a95 1
	{ &vop_bmap_desc, fifo_bmap },			/* bmap */
a340 14
/*
 * This is a noop, simply returning what one has been given.
 */
int
fifo_bmap(void *v)
{
	struct vop_bmap_args *ap = v;

	if (ap->a_vpp != NULL)
		*ap->a_vpp = ap->a_vp;
	if (ap->a_bnp != NULL)
		*ap->a_bnp = ap->a_bn;
	return (0);
}
@


1.26
log
@fifofs, deadfs and specfs all have the same "trivial lookup routine that
always fails". Introduce vop_generic_lookup(), which is a trivial lookup
routine that always fails and use that instead, zap the redundant copies.

ok toby@@, tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.25 2007/10/29 15:38:00 chl Exp $	*/
d68 2
a69 2
	{ &vop_create_desc, fifo_create },		/* create */
	{ &vop_mknod_desc, fifo_mknod },		/* mknod */
d72 3
a74 3
	{ &vop_access_desc, fifo_access },		/* access */
	{ &vop_getattr_desc, fifo_getattr },		/* getattr */
	{ &vop_setattr_desc, fifo_setattr },		/* setattr */
d80 11
a90 11
	{ &vop_revoke_desc, fifo_revoke },              /* revoke */
	{ &vop_fsync_desc, fifo_fsync },		/* fsync */
	{ &vop_remove_desc, fifo_remove },		/* remove */
	{ &vop_link_desc, fifo_link },			/* link */
	{ &vop_rename_desc, fifo_rename },		/* rename */
	{ &vop_mkdir_desc, fifo_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, fifo_rmdir },		/* rmdir */
	{ &vop_symlink_desc, fifo_symlink },		/* symlink */
	{ &vop_readdir_desc, fifo_readdir },		/* readdir */
	{ &vop_readlink_desc, fifo_readlink },		/* readlink */
	{ &vop_abortop_desc, fifo_abortop },		/* abortop */
d93 2
a94 2
	{ &vop_lock_desc, fifo_lock },			/* lock */
	{ &vop_unlock_desc, fifo_unlock },		/* unlock */
d96 1
a96 1
	{ &vop_strategy_desc, fifo_strategy },		/* strategy */
d98 1
a98 1
	{ &vop_islocked_desc, fifo_islocked },		/* islocked */
d101 1
a101 1
	{ &vop_bwrite_desc, fifo_bwrite },		/* bwrite */
@


1.25
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.24 2007/06/18 08:30:07 jasper Exp $	*/
d67 1
a67 1
	{ &vop_lookup_desc, fifo_lookup },		/* lookup */
a124 13

/*
 * Trivial lookup routine that always fails.
 */
/* ARGSUSED */
int
fifo_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	
	*ap->a_vpp = NULL;
	return (ENOTDIR);
}
@


1.24
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.23 2007/06/01 23:47:57 deraadt Exp $	*/
d155 1
a155 1
		MALLOC(fip, struct fifoinfo *, sizeof(*fip), M_VNODE, M_WAITOK);
d395 1
a395 1
		FREE(fip, M_VNODE);
d413 1
a413 1
	FREE(fip, M_VNODE);
@


1.23
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.22 2007/01/16 17:52:18 thib Exp $	*/
d131 1
a131 2
fifo_lookup(v)
	void *v;
d145 1
a145 2
fifo_open(v)
	void *v;
d148 2
a149 2
	register struct vnode *vp = ap->a_vp;
	register struct fifoinfo *fip;
d230 1
a230 2
fifo_read(v)
	void *v;
d233 2
a234 2
	register struct uio *uio = ap->a_uio;
	register struct socket *rso = ap->a_vp->v_fifoinfo->fi_readsock;
d263 1
a263 2
fifo_write(v)
	void *v;
d289 1
a289 2
fifo_ioctl(v)
	void *v;
d314 1
a314 2
fifo_poll(v)
	void *v;
d346 1
a346 2
fifo_inactive(v)
	void *v;
d358 1
a358 2
fifo_bmap(v)
	void *v;
d374 1
a374 2
fifo_close(v)
	void *v;
d377 2
a378 2
	register struct vnode *vp = ap->a_vp;
	register struct fifoinfo *fip = vp->v_fifoinfo;
d423 1
a423 2
fifo_print(v)
	void *v;
d437 1
a437 2
fifo_printinfo(vp)
	struct vnode *vp;
d439 1
a439 1
	register struct fifoinfo *fip = vp->v_fifoinfo;
d449 1
a449 2
fifo_pathconf(v)
	void *v;
d474 1
a474 2
fifo_ebadf(v)
	void *v;
d485 1
a485 2
fifo_advlock(v)
	void *v;
d495 1
a495 2
fifo_badop(v)
	void *v;
d505 1
a505 2
fifo_kqfilter(v)
	void *v;
@


1.22
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.21 2004/05/18 12:37:51 pedro Exp $	*/
d134 1
a134 5
	struct vop_lookup_args /* {
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
d149 1
a149 6
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d235 1
a235 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d269 1
a269 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d296 1
a296 8
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d322 1
a322 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int  a_events;
		struct proc *a_p;
	} */ *ap = v;
d355 1
a355 4
	struct vop_inactive_args /* {
	     struct vnode *a_vp;
	     struct proc *a_p;
	} */ *ap = v;
d368 1
a368 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
d385 1
a385 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d435 1
a435 3
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d463 1
a463 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
d523 1
a523 4
	struct vop_kqfilter_args /* {
		struct vnode *a_vp;
		struct knote *a_kn;
	} */ *ap = v;
@


1.21
log
@useless caddr_t casts removal, same sha1s
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.20 2004/05/14 21:33:58 millert Exp $	*/
a76 1
	{ &vop_lease_desc, fifo_lease_check },		/* lease */
@


1.20
log
@Fix a bug that occurs when a FIFO is opened for writing with
O_NONBLOCK set and there are no readers.  Before returning ENXIO
fifo_open calls VOP_CLOSE (and hence fifo_close).  However, since
fi_writers has not yet been incremented, when fifo_close decements
fi_writers it is one too few.  This could cause qmail processes
to spin, consuming all the CPU.

Noticed by avsm@@ and henning@@, test case provided by claudio@@, Ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.19 2004/03/02 04:42:52 tedu Exp $	*/
d330 1
a330 1
		filetmp.f_data = (caddr_t)ap->a_vp->v_fifoinfo->fi_readsock;
d336 1
a336 1
		filetmp.f_data = (caddr_t)ap->a_vp->v_fifoinfo->fi_writesock;
d369 1
a369 1
		filetmp.f_data = (caddr_t)ap->a_vp->v_fifoinfo->fi_readsock;
d375 1
a375 1
		filetmp.f_data = (caddr_t)ap->a_vp->v_fifoinfo->fi_writesock;
d594 1
a594 1
	ap->a_kn->kn_hook = (caddr_t)so;
@


1.19
log
@prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.18 2004/02/24 03:56:06 millert Exp $	*/
d194 2
a195 1
		if (fip->fi_readers++ == 0) {
d202 1
d207 1
a207 1
		if (fip->fi_writers++ == 0) {
@


1.19.2.1
log
@MFC:
Fix by millert@@

Fix a bug that occurs when a FIFO is opened for writing with
O_NONBLOCK set and there are no readers.  Before returning ENXIO
fifo_open calls VOP_CLOSE (and hence fifo_close).  However, since
fi_writers has not yet been incremented, when fifo_close decements
fi_writers it is one too few.  This could cause qmail processes
to spin, consuming all the CPU.

Noticed by avsm@@ and henning@@

ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.19 2004/03/02 04:42:52 tedu Exp $	*/
d194 1
a194 2
		fip->fi_readers++;
		if (fip->fi_readers == 1) {
a200 1
		fip->fi_writers++;
d205 1
a205 1
		if (fip->fi_writers == 1) {
@


1.18
log
@FIFO fixes adapted from FreeBSD:
o use different wchan string for reading and writing
o make O_RDWR not block forever
o remove some useless casts
o reorganize the normal, blocking code path (ie: O_NONBLOCK not set)
o fix select/poll semantics wrt EOF.

With these changes we pass the FIFO regress.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.17 2004/01/28 23:53:57 millert Exp $	*/
d433 3
d451 18
@


1.17
log
@Don't rely on vp->v_usecount to tell when we can dispose of our resources
in fifo_close().  If the FIFO is accessed via a layed fs (e.g. nullfs),
v_usecount will always be 1.  Instead, just check fip->if_readers and
fip->fi_writers.  If either one is non-zero we know the FIFO is in use
and we should not free up its resources.  Adapted from FreeBSD, NetBSD
has an equivalent change (but they keep a counter instead).
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.16 2003/09/23 16:51:13 millert Exp $	*/
a164 1
	static char openstr[] = "fifo";
d190 2
a191 2
		wso->so_state |= SS_CANTRCVMORE;
		rso->so_state |= SS_CANTSENDMORE;
d197 7
a203 1
				wakeup((caddr_t)&fip->fi_writers);
a204 1
	} else if (ap->a_mode & FWRITE) {
d208 1
a208 1
				wakeup((caddr_t)&fip->fi_readers);
d211 8
a218 11
	if (ap->a_mode & FREAD) {
		if (ap->a_mode & O_NONBLOCK) {
		} else {
			while (fip->fi_writers == 0) {
				VOP_UNLOCK(vp, 0, p);
				error = tsleep((caddr_t)&fip->fi_readers,
				    PCATCH | PSOCK, openstr, 0);
				vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
				if (error)
					goto bad;
			}
d220 6
a225 4
	} else if (ap->a_mode & FWRITE) {
		if (ap->a_mode & O_NONBLOCK) {
			if (fip->fi_readers == 0) {
				error = ENXIO;
a226 10
			}
		} else {
			while (fip->fi_readers == 0) {
				VOP_UNLOCK(vp, 0, p);
				error = tsleep((caddr_t)&fip->fi_writers,
				    PCATCH | PSOCK, openstr, 0);
				vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
				if (error)
					goto bad;
			}
d252 1
a252 1
	int error, startresid;
a261 1
	startresid = uio->uio_resid;
d263 1
a263 2
	error = soreceive(rso, (struct mbuf **)0, uio, (struct mbuf **)0,
	    (struct mbuf **)0, (int *)0);
d265 1
a265 6
	/*
	 * Clear EOF indication after first such return.
	 */
	if (uio->uio_resid == startresid)
		rso->so_state &= ~SS_CANTRCVMORE;
	if (ap->a_ioflag & IO_NDELAY)
d267 4
a270 3
	if ((ap->a_ioflag & IO_NDELAY) && error == EWOULDBLOCK &&
	    ap->a_vp->v_fifoinfo->fi_writers == 0)
		error = 0;
d299 1
a299 1
	error = sosend(wso, (struct mbuf *)0, ap->a_uio, 0, (struct mbuf *)0, 0);
d353 1
d357 10
d370 1
d431 1
a431 1
	int error1, error2;
d441 7
a447 9
	if (fip->fi_readers != 0 || fip->fi_writers != 0)
		return (0);
	error1 = soclose(fip->fi_readsock);
	error2 = soclose(fip->fi_writesock);
	FREE(fip, M_VNODE);
	vp->v_fifoinfo = NULL;
	if (error1)
		return (error1);
	return (error2);
@


1.16
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.15 2003/06/02 23:28:10 millert Exp $	*/
d442 1
a442 1
	if (vp->v_usecount > 1)
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.14 2002/11/08 04:34:17 art Exp $	*/
d49 1
d79 1
a79 1
	{ &vop_select_desc, fifo_select },		/* select */
d357 1
a357 1
fifo_select(v)
d360 1
a360 1
	struct vop_select_args /* {
d362 1
a362 3
		int  a_which;
		int  a_fflags;
		struct ucred *a_cred;
d366 1
a366 1
	int ready;
d368 1
a368 1
	if (ap->a_fflags & FREAD) {
d370 4
a373 4
		ready = soo_select(&filetmp, ap->a_which, ap->a_p);
		if (ready)
			return (ready);
	} else if (ap->a_fflags & FWRITE) {
d375 2
a376 3
		ready = soo_select(&filetmp, ap->a_which, ap->a_p);
		if (ready)
			return (ready);
d378 1
a378 1
	return (0);
@


1.15.2.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.15 2003/06/02 23:28:10 millert Exp $	*/
a435 3
	if (fip == NULL)
		return (0);

a452 18
}

int
fifo_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fifoinfo *fip = vp->v_fifoinfo;

	if (fip == NULL)
		return (0);

	soclose(fip->fi_readsock);
	soclose(fip->fi_writesock);
	FREE(fip, M_VNODE);
	vp->v_fifoinfo = NULL;

	return (0);
@


1.14
log
@Implement simple vnodeop inheritance for specfs and fifofs.

The inheritace is implemented by setting the default vnodeop to a
bypass op that repeats the operation on the spec/fifo vnodeop vector.
The overhead of one extra indirect function call is worth the cleanup
and improved correctness.

This actually solves a few bugs where some vnode ops were missing from
some vectors (like kqfilter or revoke). (and even more on the ubc
branch).

Inspired by the same thing done in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.13 2002/03/14 01:27:07 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14.2.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.14 2002/11/08 04:34:17 art Exp $	*/
a439 3
	if (fip == NULL)
		return (0);

a456 18
}

int
fifo_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fifoinfo *fip = vp->v_fifoinfo;

	if (fip == NULL)
		return (0);

	soclose(fip->fi_readsock);
	soclose(fip->fi_writesock);
	FREE(fip, M_VNODE);
	vp->v_fifoinfo = NULL;

	return (0);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.12 2001/12/19 08:58:06 art Exp $	*/
d106 1
a106 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d109 11
a128 3

struct vnodeopv_desc fifo_vnodeop_opv_desc =
	{ &fifo_vnodeop_p, fifo_vnodeop_entries };
@


1.12
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.10 2001/06/23 02:14:24 csapuntz Exp $	*/
d67 1
a67 1
int (**fifo_vnodeop_p) __P((void *));
d106 1
a106 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.11
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d106 1
a106 2
	{ &vop_mmap_desc, fifo_mmap },
	{ NULL, NULL }
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.11 2001/12/04 22:44:31 art Exp $	*/
d67 1
a67 1
int (**fifo_vnodeop_p)(void *);
@


1.11.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.11.2.1 2002/06/11 03:30:20 art Exp $	*/
d70 4
d80 5
d86 9
d100 1
d103 2
d106 1
a106 1
	FIFO_VNODEOP_DESCS,
@


1.11.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a69 4
	{ &vop_lookup_desc, fifo_lookup },		/* lookup */
	{ &vop_create_desc, fifo_create },		/* create */
	{ &vop_mknod_desc, fifo_mknod },		/* mknod */
	{ &vop_open_desc, fifo_open },			/* open */
a75 5
	{ &vop_lease_desc, fifo_lease_check },		/* lease */
	{ &vop_ioctl_desc, fifo_ioctl },		/* ioctl */
	{ &vop_select_desc, fifo_select },		/* select */
	{ &vop_kqfilter_desc, fifo_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, fifo_revoke },		/* revoke */
a76 9
	{ &vop_remove_desc, fifo_remove },		/* remove */
	{ &vop_link_desc, fifo_link },			/* link */
	{ &vop_rename_desc, fifo_rename },		/* rename */
	{ &vop_mkdir_desc, fifo_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, fifo_rmdir },		/* rmdir */
	{ &vop_symlink_desc, fifo_symlink },		/* symlink */
	{ &vop_readdir_desc, fifo_readdir },		/* readdir */
	{ &vop_readlink_desc, fifo_readlink },		/* readlink */
	{ &vop_abortop_desc, fifo_abortop },		/* abortop */
a81 1
	{ &vop_strategy_desc, fifo_strategy },		/* strategy */
a83 2
	{ &vop_pathconf_desc, fifo_pathconf },		/* pathconf */
	{ &vop_advlock_desc, fifo_advlock },		/* advlock */
d85 1
a85 2
	{ &vop_putpages_desc, fifo_putpages },		/* putpages */
	{ &vop_mmap_desc, fifo_mmap },			/* mmap */
a88 11
struct vnodeopv_desc fifo_vnodeop_opv_desc =
	{ &fifo_vnodeop_p, fifo_vnodeop_entries };

int
fifo_vnoperate(void *v)
{
	struct vop_generic_args *ap = v;

	return (VOCALL(fifo_vnodeop_p, ap->a_desc->vdesc_offset, ap));
}

d98 3
@


1.11.2.4
log
@convert to genfs_nolock.  genfs_lock for kern and procfs
@
text
@a53 2

#include <miscfs/genfs/genfs.h>
@


1.10
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.9 2001/03/01 20:54:34 provos Exp $	*/
d106 2
a107 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.9
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.8 2000/11/15 23:21:42 provos Exp $	*/
a84 1
	{ &vop_mmap_desc, fifo_mmap },			/* mmap */
a85 1
	{ &vop_seek_desc, fifo_seek },			/* seek */
a104 5
	{ &vop_blkatoff_desc, fifo_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, fifo_valloc },		/* valloc */
	{ &vop_vfree_desc, fifo_vfree },		/* vfree */
	{ &vop_truncate_desc, fifo_truncate },		/* truncate */
	{ &vop_update_desc, fifo_update },		/* update */
@


1.8
log
@deal with stupid legacy applications that open a fifo O_RDWR. okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.7 1997/11/06 05:58:34 csapuntz Exp $	*/
d50 1
d83 1
d115 11
d552 81
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.6 1997/10/06 20:20:23 deraadt Exp $	*/
d189 1
a189 2
	}
	if (ap->a_mode & FWRITE) {
d208 1
a208 2
	}
	if (ap->a_mode & FWRITE) {
d364 1
a364 2
	}
	if (ap->a_fflags & FWRITE) {
@


1.7.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.9 2001/03/01 20:54:34 provos Exp $	*/
a49 1
#include <sys/event.h>
a81 1
	{ &vop_kqfilter_desc, fifo_kqfilter },		/* kqfilter */
a112 11

void	filt_fifordetach(struct knote *kn);
int	filt_fiforead(struct knote *kn, long hint);
void	filt_fifowdetach(struct knote *kn);
int	filt_fifowrite(struct knote *kn, long hint);

struct filterops fiforead_filtops =
	{ 1, NULL, filt_fifordetach, filt_fiforead };
struct filterops fifowrite_filtops =
	{ 1, NULL, filt_fifowdetach, filt_fifowrite };

d189 2
a190 1
	} else if (ap->a_mode & FWRITE) {
d209 2
a210 1
	} else if (ap->a_mode & FWRITE) {
d366 2
a367 1
	} else if (ap->a_fflags & FWRITE) {
a541 81
}


int
fifo_kqfilter(v)
	void *v;
{
	struct vop_kqfilter_args /* {
		struct vnode *a_vp;
		struct knote *a_kn;
	} */ *ap = v;
	struct socket *so = (struct socket *)ap->a_vp->v_fifoinfo->fi_readsock;
	struct sockbuf *sb;

	switch (ap->a_kn->kn_filter) {
	case EVFILT_READ:
		ap->a_kn->kn_fop = &fiforead_filtops;
		sb = &so->so_rcv;
		break;
	case EVFILT_WRITE:
		ap->a_kn->kn_fop = &fifowrite_filtops;
		sb = &so->so_snd;
		break;
	default:
		return (1);
	}

	ap->a_kn->kn_hook = (caddr_t)so;

	SLIST_INSERT_HEAD(&sb->sb_sel.si_note, ap->a_kn, kn_selnext);
	sb->sb_flags |= SB_KNOTE;

	return (0);
}

void
filt_fifordetach(struct knote *kn)
{
	struct socket *so = (struct socket *)kn->kn_hook;

	SLIST_REMOVE(&so->so_rcv.sb_sel.si_note, kn, knote, kn_selnext);
	if (SLIST_EMPTY(&so->so_rcv.sb_sel.si_note))
		so->so_rcv.sb_flags &= ~SB_KNOTE;
}

int
filt_fiforead(struct knote *kn, long hint)
{
	struct socket *so = (struct socket *)kn->kn_hook;

	kn->kn_data = so->so_rcv.sb_cc;
	if (so->so_state & SS_CANTRCVMORE) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	kn->kn_flags &= ~EV_EOF;
	return (kn->kn_data > 0);
}

void
filt_fifowdetach(struct knote *kn)
{
	struct socket *so = (struct socket *)kn->kn_hook;

	SLIST_REMOVE(&so->so_snd.sb_sel.si_note, kn, knote, kn_selnext);
	if (SLIST_EMPTY(&so->so_snd.sb_sel.si_note))
		so->so_snd.sb_flags &= ~SB_KNOTE;
}

int
filt_fifowrite(struct knote *kn, long hint)
{
	struct socket *so = (struct socket *)kn->kn_hook;

	kn->kn_data = sbspace(&so->so_snd);
	if (so->so_state & SS_CANTSENDMORE) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	kn->kn_flags &= ~EV_EOF;
	return (kn->kn_data >= so->so_snd.sb_lowat);
@


1.7.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.7.10.1 2001/05/14 22:32:53 niklas Exp $	*/
d85 1
d87 1
d107 5
@


1.7.10.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
int (**fifo_vnodeop_p)(void *);
d106 1
a106 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.7.10.4
log
@Sync the SMP branch with 3.3
@
text
@d106 1
a106 1
	{ NULL, NULL }
a108 11
struct vnodeopv_desc fifo_vnodeop_opv_desc =
	{ &fifo_vnodeop_p, fifo_vnodeop_entries };

int
fifo_vnoperate(void *v)
{
	struct vop_generic_args *ap = v;

	return (VOCALL(fifo_vnodeop_p, ap->a_desc->vdesc_offset, ap));
}

d118 3
@


1.7.10.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.7.10.4 2003/03/28 00:00:19 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.10.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 1
#include <sys/poll.h>
d78 1
a78 1
	{ &vop_poll_desc, fifo_poll },			/* poll */
d356 1
a356 1
fifo_poll(v)
d359 1
a359 1
	struct vop_poll_args /* {
d361 3
a363 1
		int  a_events;
d367 1
a367 1
	int revents = 0;
d369 1
a369 1
	if (ap->a_events & (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND)) {
d371 4
a374 4
		if (filetmp.f_data)
			revents |= soo_poll(&filetmp, ap->a_events, ap->a_p);
	}
	if (ap->a_events & (POLLOUT | POLLWRNORM | POLLWRBAND)) {
d376 3
a378 2
		if (filetmp.f_data)
			revents |= soo_poll(&filetmp, ap->a_events, ap->a_p);
d380 1
a380 1
	return (revents);
d444 1
a444 1
	if (fip->fi_readers != 0 || fip->fi_writers != 0)
@


1.7.10.7
log
@Merge with the trunk
@
text
@d165 1
d191 2
a192 2
		wso->so_snd.sb_lowat = PIPE_BUF;
		rso->so_state |= SS_CANTRCVMORE;
d195 1
a195 2
		fip->fi_readers++;
		if (fip->fi_readers == 1) {
d198 1
a198 1
				wakeup(&fip->fi_writers);
d200 2
a201 8
	}
	if (ap->a_mode & FWRITE) {
		fip->fi_writers++;
		if ((ap->a_mode & O_NONBLOCK) && fip->fi_readers == 0) {
			error = ENXIO;
			goto bad;
		}
		if (fip->fi_writers == 1) {
d204 1
a204 1
				wakeup(&fip->fi_readers);
d207 11
a217 8
	if ((ap->a_mode & O_NONBLOCK) == 0) {
		if ((ap->a_mode & FREAD) && fip->fi_writers == 0) {
			VOP_UNLOCK(vp, 0, p);
			error = tsleep(&fip->fi_readers,
			    PCATCH | PSOCK, "fifor", 0);
			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
			if (error)
				goto bad;
d219 4
a222 6
		if ((ap->a_mode & FWRITE) && fip->fi_readers == 0) {
			VOP_UNLOCK(vp, 0, p);
			error = tsleep(&fip->fi_writers,
			    PCATCH | PSOCK, "fifow", 0);
			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
			if (error)
d224 10
d259 1
a259 1
	int error;
d269 1
d271 2
a272 1
	error = soreceive(rso, NULL, uio, NULL, NULL, NULL);
d274 6
a279 1
	if (ap->a_ioflag & IO_NDELAY) {
d281 3
a283 4
		if (error == EWOULDBLOCK &&
		    ap->a_vp->v_fifoinfo->fi_writers == 0)
			error = 0;
	}
d312 1
a312 1
	error = sosend(wso, NULL, ap->a_uio, NULL, NULL, 0);
d341 1
a341 1
		filetmp.f_data = ap->a_vp->v_fifoinfo->fi_readsock;
d347 1
a347 1
		filetmp.f_data = ap->a_vp->v_fifoinfo->fi_writesock;
a365 1
	short ostate;
d369 1
a369 11
		/*
		 * Socket and FIFO poll(2) semantics differ wrt EOF on read.
		 * Unlike a normal socket, FIFOs don't care whether or not
		 * SS_CANTRCVMORE is set.  To get the correct semantics we
		 * must clear SS_CANTRCVMORE from so_state temporarily.
		 */
		ostate = ap->a_vp->v_fifoinfo->fi_readsock->so_state;
		if (ap->a_events & (POLLIN | POLLRDNORM))
			ap->a_vp->v_fifoinfo->fi_readsock->so_state &=
			    ~SS_CANTRCVMORE;
		filetmp.f_data = ap->a_vp->v_fifoinfo->fi_readsock;
a371 1
		ap->a_vp->v_fifoinfo->fi_readsock->so_state = ostate;
d374 1
a374 1
		filetmp.f_data = ap->a_vp->v_fifoinfo->fi_writesock;
d432 1
a432 4
	int error1 = 0, error2 = 0;

	if (fip == NULL)
		return (0);
d442 1
a442 17
	if (fip->fi_readers == 0 && fip->fi_writers == 0) {
		error1 = soclose(fip->fi_readsock);
		error2 = soclose(fip->fi_writesock);
		FREE(fip, M_VNODE);
		vp->v_fifoinfo = NULL;
	}
	return (error1 ? error1 : error2);
}

int
fifo_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct fifoinfo *fip = vp->v_fifoinfo;

	if (fip == NULL)
d444 2
a445 3

	soclose(fip->fi_readsock);
	soclose(fip->fi_writesock);
d448 3
a450 2

	return (0);
d574 1
a574 1
	ap->a_kn->kn_hook = so;
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.4 1996/11/04 03:31:54 tholo Exp $	*/
d41 1
a47 1
#include <sys/systm.h>
d82 1
d151 1
d201 1
a201 1
				VOP_UNLOCK(vp);
d204 1
a204 1
				VOP_LOCK(vp);
d218 1
a218 1
				VOP_UNLOCK(vp);
d221 1
a221 1
				VOP_LOCK(vp);
d249 1
d261 1
a261 1
	VOP_UNLOCK(ap->a_vp);
d264 1
a264 1
	VOP_LOCK(ap->a_vp);
d293 1
d302 1
a302 1
	VOP_UNLOCK(ap->a_vp);
d304 1
a304 1
	VOP_LOCK(ap->a_vp);
d376 13
d401 1
a411 20
 * At the moment we do not do any locking.
 */
/* ARGSUSED */
int
fifo_lock(v)
	void *v;
{
	return (0);
}

/* ARGSUSED */
int
fifo_unlock(v)
	void *v;
{

	return (0);
}

/*
d541 1
@


1.5
log
@VFS Lite2 Changes
@
text
@a40 1
#include <sys/systm.h>
d47 1
a81 1
	{ &vop_revoke_desc, fifo_revoke },              /* revoke */
a149 1
	struct proc *p = ap->a_p;
d199 1
a199 1
				VOP_UNLOCK(vp, 0, p);
d202 1
a202 1
				vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d216 1
a216 1
				VOP_UNLOCK(vp, 0, p);
d219 1
a219 1
				vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
a246 1
	struct proc *p = uio->uio_procp;
d258 1
a258 1
	VOP_UNLOCK(ap->a_vp, 0, p);
d261 1
a261 1
	vn_lock(ap->a_vp, LK_EXCLUSIVE | LK_RETRY, p);
a289 1
	struct proc *p = ap->a_uio->uio_procp;
d298 1
a298 1
	VOP_UNLOCK(ap->a_vp, 0, p);
d300 1
a300 1
	vn_lock(ap->a_vp, LK_EXCLUSIVE | LK_RETRY, p);
a371 13
int
fifo_inactive(v)
	void *v;
{
	struct vop_inactive_args /* {
	     struct vnode *a_vp;
	     struct proc *a_p;
	} */ *ap = v;

	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
	return (0);
}

a383 1
		int *a_runp;
d394 20
a542 1
	return(0);
@


1.4
log
@We should return 0 on non-blocking read from FIFO with no writers
@
text
@d1 1
a1 1
/*	$OpenBSD: fifo_vnops.c,v 1.2 1996/02/27 07:53:43 niklas Exp $	*/
d41 1
a47 1
#include <sys/systm.h>
d82 1
d151 1
d201 1
a201 1
				VOP_UNLOCK(vp);
d204 1
a204 1
				VOP_LOCK(vp);
d218 1
a218 1
				VOP_UNLOCK(vp);
d221 1
a221 1
				VOP_LOCK(vp);
d249 1
d261 1
a261 1
	VOP_UNLOCK(ap->a_vp);
d264 1
a264 1
	VOP_LOCK(ap->a_vp);
d293 1
d302 1
a302 1
	VOP_UNLOCK(ap->a_vp);
d304 1
a304 1
	VOP_LOCK(ap->a_vp);
d376 13
d401 1
a411 20
 * At the moment we do not do any locking.
 */
/* ARGSUSED */
int
fifo_lock(v)
	void *v;
{
	return (0);
}

/* ARGSUSED */
int
fifo_unlock(v)
	void *v;
{

	return (0);
}

/*
d541 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d269 3
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: fifo_vnops.c,v 1.17 1996/02/09 22:40:16 christos Exp $	*/
d473 1
a473 1
	printf(", fifo with %d readers and %d writers",
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: fifo_vnops.c,v 1.16 1995/04/14 23:30:14 mycroft Exp $	*/
d52 1
d66 1
a66 1
int (**fifo_vnodeop_p)();
d110 1
a110 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d119 4
a122 1
fifo_lookup(ap)
d127 1
a127 2
	} */ *ap;
{
d138 4
a141 1
fifo_open(ap)
d147 1
a147 2
	} */ *ap;
{
d157 1
a157 1
		if (error = socreate(AF_LOCAL, &rso, SOCK_STREAM, 0)) {
d163 1
a163 1
		if (error = socreate(AF_LOCAL, &wso, SOCK_STREAM, 0)) {
d170 1
a170 1
		if (error = unp_connect2(wso, rso)) {
d235 4
a238 1
fifo_read(ap)
d244 1
a244 2
	} */ *ap;
{
d276 4
a279 1
fifo_write(ap)
d285 1
a285 2
	} */ *ap;
{
d307 4
a310 1
fifo_ioctl(ap)
d318 1
a318 2
	} */ *ap;
{
d340 4
a343 1
fifo_select(ap)
d350 1
a350 2
	} */ *ap;
{
d372 4
a375 1
fifo_bmap(ap)
d381 1
a381 2
	} */ *ap;
{
d394 3
a396 4
fifo_lock(ap)
	struct vop_lock_args /* {
		struct vnode *a_vp;
	} */ *ap;
a397 1

d402 3
a404 4
fifo_unlock(ap)
	struct vop_unlock_args /* {
		struct vnode *a_vp;
	} */ *ap;
d414 4
a417 1
fifo_close(ap)
d423 1
a423 2
	} */ *ap;
{
d450 4
a453 1
fifo_print(ap)
d456 1
a456 2
	} */ *ap;
{
d461 1
d467 1
d480 4
a483 1
fifo_pathconf(ap)
d488 1
a488 2
	} */ *ap;
{
d509 4
a512 1
fifo_ebadf()
d522 3
a524 8
fifo_advlock(ap)
	struct vop_advlock_args /* {
		struct vnode *a_vp;
		caddr_t  a_id;
		int  a_op;
		struct flock *a_fl;
		int  a_flags;
	} */ *ap;
a525 1

d532 4
a535 1
fifo_badop()
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
