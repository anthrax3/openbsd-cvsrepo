head	1.32;
access;
symbols
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.22.0.12
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.10
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.8
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.8
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2011.04.05.18.51.26;	author thib;	state dead;
branches;
next	1.31;

1.31
date	2009.08.14.16.32.21;	author jasper;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2008.11.02.11.37.32;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.24.17.39.45;	author thib;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.29.15.38.00;	author chl;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.22.06.12.43;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.06.01.00.51;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.18.12.37.51;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.23.17.43.48;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.21.20.08.32;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.10;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.24.03.54.22;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.02.16.05.58;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.04.22.44.32;	author art;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.06.23.02.14.25;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	99.11.10.23.17.39;	author csapuntz;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	98.08.06.19.34.44;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	98.06.11.16.34.25;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.58.41;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.21.04.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.19.09;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.59.43;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.01;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.07.04.10.49.12;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.06.07.11.06.05;	author ho;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2004.06.07.20.41.35;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.30.20;	author art;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2003.05.19.22.36.11;	author tedu;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2003.05.20.04.05.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Remove portalfs.

While it is a terribly cool idea, it's just awful and since noone has stepped
up to the plate to keep it up with the current vop state, retire it to the
attic.

ok krw@@, deraadt@@, guenther@@, miod@@.
comments from jmc@@
@
text
@/*	$OpenBSD: portal_vnops.c,v 1.31 2009/08/14 16:32:21 jasper Exp $	*/
/*	$NetBSD: portal_vnops.c,v 1.17 1996/02/13 13:12:57 mycroft Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software donated to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Id: portal_vnops.c,v 1.4 1992/05/30 10:05:24 jsp Exp
 *	@@(#)portal_vnops.c	8.8 (Berkeley) 1/21/94
 */

/*
 * Portal Filesystem
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/filedesc.h>
#include <sys/vnode.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/malloc.h>
#include <sys/namei.h>
#include <sys/mbuf.h>
#include <sys/poll.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/un.h>
#include <sys/unpcb.h>
#include <sys/syscallargs.h>
#include <miscfs/portal/portal.h>

static int portal_fileid = PORTAL_ROOTFILEID+1;

static void	portal_closefd(struct proc *, int);
static int	portal_connect(struct socket *, struct socket *);


int	portal_badop(void *);

int	portal_lookup(void *);
int	portal_open(void *);
int	portal_getattr(void *);
int	portal_setattr(void *);
int	portal_link(void *);
int	portal_symlink(void *);
int	portal_readdir(void *);
int	portal_inactive(void *);
int	portal_reclaim(void *);
int	portal_print(void *);
int	portal_pathconf(void *);
int	portal_poll(void *);

int (**portal_vnodeop_p)(void *);
struct vnodeopv_entry_desc portal_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, portal_lookup },
	{ &vop_create_desc, eopnotsupp },
	{ &vop_mknod_desc, eopnotsupp },
	{ &vop_open_desc, portal_open },
	{ &vop_close_desc, nullop },
	{ &vop_access_desc, nullop },
	{ &vop_getattr_desc, portal_getattr },
	{ &vop_setattr_desc, portal_setattr },
	{ &vop_read_desc, eopnotsupp },
	{ &vop_write_desc, eopnotsupp },
	{ &vop_ioctl_desc, (int (*)(void *))enoioctl },
	{ &vop_poll_desc, portal_poll },
	{ &vop_revoke_desc, vop_generic_revoke },
	{ &vop_fsync_desc, nullop },
	{ &vop_remove_desc, eopnotsupp },
	{ &vop_link_desc, portal_link },
	{ &vop_rename_desc, eopnotsupp },
	{ &vop_mkdir_desc, eopnotsupp },
	{ &vop_rmdir_desc, eopnotsupp },
	{ &vop_symlink_desc, portal_symlink },
	{ &vop_readdir_desc, portal_readdir },
	{ &vop_readlink_desc, eopnotsupp },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, portal_inactive },
	{ &vop_reclaim_desc, portal_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, portal_badop },
	{ &vop_strategy_desc, portal_badop },
	{ &vop_print_desc, portal_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, portal_pathconf },
	{ &vop_advlock_desc, eopnotsupp },
	{ &vop_bwrite_desc, eopnotsupp },
	{ NULL, NULL }
};
struct vnodeopv_desc portal_vnodeop_opv_desc =
	{ &portal_vnodeop_p, portal_vnodeop_entries };

static void
portal_closefd(struct proc *p, int fd)
{
	struct sys_close_args /* {
		syscallarg(int) fd;
	} */ ua;
	register_t retval[2];
	int error;

	SCARG(&ua, fd) = fd;
	error = sys_close(p, &ua, retval);
	/*
	 * We should never get an error, and there isn't anything
	 * we could do if we got one, so just print a message.
	 */
	if (error)
		printf("portal_closefd: error = %d\n", error);
}

/*
 * vp is the current namei directory
 * cnp is the name to locate in that directory...
 */
int
portal_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct vnode **vpp = ap->a_vpp;
	struct vnode *dvp = ap->a_dvp;
	char *pname = cnp->cn_nameptr;
	struct proc *p = cnp->cn_proc;
	struct portalnode *pt;
	int error;
	struct vnode *fvp = 0;
	char *path;
	int size;

	*vpp = NULLVP;

	if (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME)
		return (EROFS);

	if (cnp->cn_namelen == 1 && *pname == '.') {
		*vpp = dvp;
		vref(dvp);
		return (0);
	}

	error = getnewvnode(VT_PORTAL, dvp->v_mount, portal_vnodeop_p, &fvp);
	if (error)
		goto bad;
	fvp->v_type = VREG;
	fvp->v_data = malloc(sizeof(struct portalnode), M_TEMP, M_WAITOK);

	pt = VTOPORTAL(fvp);
	/*
	 * Save all of the remaining pathname and
	 * advance the namei next pointer to the end
	 * of the string.
	 */
	for (size = 0, path = pname; *path; path++)
		size++;
	cnp->cn_consume = size - cnp->cn_namelen;

	pt->pt_arg = malloc(size+1, M_TEMP, M_WAITOK);
	pt->pt_size = size+1;
	bcopy(pname, pt->pt_arg, pt->pt_size);
	pt->pt_fileid = portal_fileid++;

	*vpp = fvp;
	VOP_LOCK(fvp, LK_EXCLUSIVE, p);
	/*
	 * As we are the last component of the path name, fix up
	 * the locking on the directory node.
	 */
	if ((cnp->cn_flags & LOCKPARENT) == 0) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
	return (0);

bad:;
	if (fvp)
		vrele(fvp);
	return (error);
}

static int
portal_connect(struct socket *so, struct socket *so2)
{
	/* from unp_connect, bypassing the namei stuff... */
	struct socket *so3;
	struct unpcb *unp2;
	struct unpcb *unp3;

	if (so2 == 0)
		return (ECONNREFUSED);

	if (so->so_type != so2->so_type)
		return (EPROTOTYPE);

	if ((so2->so_options & SO_ACCEPTCONN) == 0)
		return (ECONNREFUSED);

	if ((so3 = sonewconn(so2, 0)) == 0)
		return (ECONNREFUSED);

	unp2 = sotounpcb(so2);
	unp3 = sotounpcb(so3);
	if (unp2->unp_addr)
		unp3->unp_addr = m_copy(unp2->unp_addr, 0, (int)M_COPYALL);

	so2 = so3;


	return (unp_connect2(so, so2));
}

int
portal_open(void *v)
{
	struct vop_open_args *ap = v;
	struct socket *so = 0;
	struct portalnode *pt;
	struct proc *p = ap->a_p;
	struct vnode *vp = ap->a_vp;
	int s;
	struct uio auio;
	struct iovec aiov[2];
	int res;
	struct mbuf *cm = 0;
	struct cmsghdr *cmsg;
	int newfds;
	int *ip;
	int fd;
	int error;
	int len;
	struct portalmount *fmp;
	struct file *fp;
	struct portal_cred pcred;

	/*
	 * Nothing to do when opening the root node.
	 */
	if (vp->v_flag & VROOT)
		return (0);

	/*
	 * Can't be opened unless the caller is set up
	 * to deal with the side effects.  Check for this
	 * by testing whether the p_dupfd has been set.
	 */
	if (p->p_dupfd >= 0)
		return (ENODEV);

	pt = VTOPORTAL(vp);
	fmp = VFSTOPORTAL(vp->v_mount);

	/*
	 * Create a new socket.
	 */
	error = socreate(AF_UNIX, &so, SOCK_STREAM, 0);
	if (error)
		goto bad;

	/*
	 * Reserve some buffer space
	 */
	res = pt->pt_size + sizeof(pcred) + 512;	/* XXX */
	error = soreserve(so, res, res);
	if (error)
		goto bad;

	/*
	 * Kick off connection
	 */
	s = splsoftnet();
	error = portal_connect(so, (struct socket *)fmp->pm_server->f_data);
	splx(s);
	if (error)
		goto bad;

	/*
	 * Wait for connection to complete
	 */
	/*
	 * XXX: Since the mount point is holding a reference on the
	 * underlying server socket, it is not easy to find out whether
	 * the server process is still running.  To handle this problem
	 * we loop waiting for the new socket to be connected (something
	 * which will only happen if the server is still running) or for
	 * the reference count on the server socket to drop to 1, which
	 * will happen if the server dies.  Sleep for 5 second intervals
	 * and keep polling the reference count.   XXX.
	 */
	s = splsoftnet();
	while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) {
		if (fmp->pm_server->f_count == 1) {
			error = ECONNREFUSED;
			splx(s);
			goto bad;
		}
		(void) tsleep(&so->so_timeo, PSOCK, "portalcon", 5 * hz);
	}
	splx(s);

	if (so->so_error) {
		error = so->so_error;
		goto bad;
	}
		
	/*
	 * Set miscellaneous flags
	 */
	so->so_rcv.sb_timeo = 0;
	so->so_snd.sb_timeo = 0;
	so->so_rcv.sb_flags |= SB_NOINTR;
	so->so_snd.sb_flags |= SB_NOINTR;


	pcred.pcr_flag = ap->a_mode;
	pcred.pcr_uid = ap->a_cred->cr_uid;
	pcred.pcr_gid = ap->a_cred->cr_gid;
	pcred.pcr_ngroups = ap->a_cred->cr_ngroups;
	bcopy(ap->a_cred->cr_groups, pcred.pcr_groups, NGROUPS * sizeof(gid_t));
	aiov[0].iov_base = &pcred;
	aiov[0].iov_len = sizeof(pcred);
	aiov[1].iov_base = pt->pt_arg;
	aiov[1].iov_len = pt->pt_size;
	auio.uio_iov = aiov;
	auio.uio_iovcnt = 2;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = p;
	auio.uio_offset = 0;
	auio.uio_resid = aiov[0].iov_len + aiov[1].iov_len;

	error = sosend(so, (struct mbuf *) 0, &auio,
			(struct mbuf *) 0, (struct mbuf *) 0, 0);
	if (error)
		goto bad;

	len = auio.uio_resid = sizeof(int);
	do {
		struct mbuf *m = 0;
		int flags = MSG_WAITALL;
		fdpunlock(p->p_fd);
		error = soreceive(so, (struct mbuf **) 0, &auio,
					&m, &cm, &flags, 0);
		fdplock(p->p_fd);
		if (error)
			goto bad;

		/*
		 * Grab an error code from the mbuf.
		 */
		if (m) {
			m = m_pullup(m, sizeof(int));	/* Needed? */
			if (m) {
				error = *(mtod(m, int *));
				m_freem(m);
			} else {
				error = EINVAL;
			}
		} else {
			if (cm == 0) {
				error = ECONNRESET;	 /* XXX */
#ifdef notdef
				break;
#endif
			}
		}
	} while (cm == 0 && auio.uio_resid == len && !error);

	if (cm == 0)
		goto bad;

	if (auio.uio_resid) {
		error = 0;
#ifdef notdef
		error = EMSGSIZE;
		goto bad;
#endif
	}

	/*
	 * XXX: Break apart the control message, and retrieve the
	 * received file descriptor.  Note that more than one descriptor
	 * may have been received, or that the rights chain may have more
	 * than a single mbuf in it.  What to do?
	 */
	cmsg = mtod(cm, struct cmsghdr *);
	if (cmsg->cmsg_len < CMSG_LEN(0)) {
		error = EMSGSIZE;
		goto bad;
	}
	newfds = (cmsg->cmsg_len - sizeof(*cmsg)) / sizeof (int);
	if (newfds == 0) {
		error = ECONNREFUSED;
		goto bad;
	}
	/*
	 * At this point the rights message consists of a control message
	 * header, followed by a data region containing a vector of
	 * integer file descriptors.  The fds were allocated by the action
	 * of receiving the control message.
	 */
	ip = (int *)CMSG_DATA(cmsg);
	fd = *ip++;
	if (newfds > 1) {
		/*
		 * Close extra fds.
		 */
		int i;
		printf("portal_open: %d extra fds\n", newfds - 1);
		for (i = 1; i < newfds; i++) {
			portal_closefd(p, *ip);
			ip++;
		}
	}

	/*
	 * Check that the mode the file is being opened for is a subset 
	 * of the mode of the existing descriptor.
	 */
	if ((fp = fd_getfile(p->p_fd, fd)) == NULL) {
		error = EBADF;
		goto bad;
	}
	if (((ap->a_mode & (FREAD|FWRITE)) | fp->f_flag) != fp->f_flag) {
		portal_closefd(p, fd);
		error = EACCES;
		goto bad;
	}

	/*
	 * Save the dup fd in the proc structure then return the
	 * special error code (ENXIO) which causes magic things to
	 * happen in vn_open.  The whole concept is, well, hmmm.
	 */
	p->p_dupfd = fd;
	error = ENXIO;

bad:;
	/*
	 * And discard the control message.
	 */
	if (cm) { 
		m_freem(cm);
	}

	if (so) {
		soshutdown(so, 2);
		soclose(so);
	}
	return (error);
}

int
portal_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vattr *vap = ap->a_vap;

	bzero(vap, sizeof(*vap));
	vattr_null(vap);
	vap->va_uid = 0;
	vap->va_gid = 0;
	vap->va_fsid = vp->v_mount->mnt_stat.f_fsid.val[0];
	vap->va_size = DEV_BSIZE;
	vap->va_blocksize = DEV_BSIZE;
	getnanotime(&vap->va_atime);
	vap->va_mtime = vap->va_atime;
	vap->va_ctime = vap->va_atime;
	vap->va_gen = 0;
	vap->va_flags = 0;
	vap->va_rdev = 0;
	/* vap->va_qbytes = 0; */
	vap->va_bytes = 0;
	/* vap->va_qsize = 0; */
	if (vp->v_flag & VROOT) {
		vap->va_type = VDIR;
		vap->va_mode = S_IRUSR|S_IWUSR|S_IXUSR|
				S_IRGRP|S_IWGRP|S_IXGRP|
				S_IROTH|S_IWOTH|S_IXOTH;
		vap->va_nlink = 2;
		vap->va_fileid = 2;
	} else {
		vap->va_type = VREG;
		vap->va_mode = S_IRUSR|S_IWUSR|
				S_IRGRP|S_IWGRP|
				S_IROTH|S_IWOTH;
		vap->va_nlink = 1;
		vap->va_fileid = VTOPORTAL(vp)->pt_fileid;
	}
	return (0);
}

int
portal_setattr(void *v)
{
	struct vop_setattr_args *ap = v;

	/*
	 * Can't mess with the root vnode
	 */
	if (ap->a_vp->v_flag & VROOT)
		return (EACCES);

	if (ap->a_vap->va_flags != VNOVAL)
		return (EOPNOTSUPP);

	return (0);
}

/*
 * Fake readdir, just return empty directory.
 * It is hard to deal with '.' and '..' so don't bother.
 */
/*ARGSUSED*/
int
portal_readdir(void *v)
{
 	return (0);
}

/*ARGSUSED*/
int
portal_inactive(void *v)
{
 	struct vop_inactive_args *ap = v;

	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
	return (0);
}

int
portal_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct portalnode *pt = VTOPORTAL(ap->a_vp);

	if (pt->pt_arg) {
		free(pt->pt_arg, M_TEMP);
		pt->pt_arg = 0;
	}
	free(ap->a_vp->v_data, M_TEMP);
	ap->a_vp->v_data = 0;

	return (0);
}

/*
 * Return POSIX pathconf information applicable to special devices.
 */
int
portal_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		return (0);
	case _PC_MAX_CANON:
		*ap->a_retval = MAX_CANON;
		return (0);
	case _PC_MAX_INPUT:
		*ap->a_retval = MAX_INPUT;
		return (0);
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
		return (0);
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		return (0);
	case _PC_VDISABLE:
		*ap->a_retval = _POSIX_VDISABLE;
		return (0);
	default:
		return (EINVAL);
	}
	/* NOTREACHED */
}

/*
 * Print out the contents of a Portal vnode.
 */
/* ARGSUSED */
int
portal_print(void *v)
{
	printf("tag VT_PORTAL, portal vnode\n");
	return (0);
}

int
portal_link(void *v) 
{
	struct vop_link_args *ap = v;
 
	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

int
portal_symlink(void *v)
{
	struct vop_symlink_args *ap = v;
  
	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

int
portal_badop(void *v)
{
	panic ("portal: bad op");
	return (0);
}

int
portal_poll(void *v)
{
	struct vop_poll_args *ap = v;

	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}
@


1.31
log
@- let this compile after soreceive() changes

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.30 2009/08/13 15:00:14 jasper Exp $	*/
@


1.30
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.29 2009/07/09 22:29:56 thib Exp $	*/
d377 1
a377 1
					&m, &cm, &flags);
@


1.29
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.27 2008/05/08 17:45:45 thib Exp $	*/
d89 34
a122 34
	{ &vop_lookup_desc, portal_lookup },		/* lookup */
	{ &vop_create_desc, eopnotsupp },		/* create */
	{ &vop_mknod_desc, eopnotsupp },		/* mknod */
	{ &vop_open_desc, portal_open },		/* open */
	{ &vop_close_desc, nullop },			/* close */
	{ &vop_access_desc, nullop },			/* access */
	{ &vop_getattr_desc, portal_getattr },		/* getattr */
	{ &vop_setattr_desc, portal_setattr },		/* setattr */
	{ &vop_read_desc, eopnotsupp },			/* read */
	{ &vop_write_desc, eopnotsupp },		/* write */
	{ &vop_ioctl_desc, (int (*)(void *))enoioctl },	/* ioctl */
	{ &vop_poll_desc, portal_poll },		/* poll */
	{ &vop_revoke_desc, vop_generic_revoke },	/* revoke */
	{ &vop_fsync_desc, nullop },			/* fsync */
	{ &vop_remove_desc, eopnotsupp },		/* remove */
	{ &vop_link_desc, portal_link },		/* link */
	{ &vop_rename_desc, eopnotsupp },		/* rename */
	{ &vop_mkdir_desc, eopnotsupp },		/* mkdir */
	{ &vop_rmdir_desc, eopnotsupp },		/* rmdir */
	{ &vop_symlink_desc, portal_symlink },		/* symlink */
	{ &vop_readdir_desc, portal_readdir },		/* readdir */
	{ &vop_readlink_desc, eopnotsupp },		/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },	/* abortop */
	{ &vop_inactive_desc, portal_inactive },	/* inactive */
	{ &vop_reclaim_desc, portal_reclaim },		/* reclaim */
	{ &vop_lock_desc, vop_generic_lock },		/* lock */
	{ &vop_unlock_desc, vop_generic_unlock },	/* unlock */
	{ &vop_bmap_desc, portal_badop },		/* bmap */
	{ &vop_strategy_desc, portal_badop },		/* strategy */
	{ &vop_print_desc, portal_print },		/* print */
	{ &vop_islocked_desc, vop_generic_islocked },	/* islocked */
	{ &vop_pathconf_desc, portal_pathconf },	/* pathconf */
	{ &vop_advlock_desc, eopnotsupp },		/* advlock */
	{ &vop_bwrite_desc, eopnotsupp },		/* bwrite */
@


1.28
log
@- Use CMSG_DATA(), to correctly to get a descriptor, fixing
  a locking botch in portal_open();
- set f_namemax at mount time and use copy_statfs_info() in
  portal_statfs();

This diff is a slight tweak of the diff sent in PR5968 by
Frank Denis (j at pureftpd.org) Thanks!
@
text
@d173 1
a173 1
		VREF(dvp);
@


1.27
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.26 2008/04/24 17:39:45 thib Exp $	*/
d421 4
d436 1
a436 1
	ip = (int *)(cmsg + 1);
@


1.26
log
@remove useless defines for the vnode operations, and instead
init the op array functions with whatever the define was set
too.

ok dlg@@,blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.25 2007/10/29 15:38:00 chl Exp $	*/
d88 1
a88 1
	{ &vop_default_desc, vn_default_error },
@


1.25
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.24 2007/06/18 08:30:07 jasper Exp $	*/
d71 1
a71 1
int portal_badop(void *);
a73 2
#define	portal_create	eopnotsupp
#define	portal_mknod	eopnotsupp
a74 2
#define	portal_close	nullop
#define	portal_access	nullop
a76 5
#define	portal_read	eopnotsupp
#define	portal_write	eopnotsupp
#define	portal_ioctl    (int (*)(void *))enoioctl
#define	portal_fsync	nullop
#define	portal_remove	eopnotsupp
a77 3
#define	portal_rename	eopnotsupp
#define	portal_mkdir	eopnotsupp
#define	portal_rmdir	eopnotsupp
a79 2
#define portal_revoke   vop_generic_revoke
#define	portal_readlink	eopnotsupp
a81 4
#define	portal_lock	vop_generic_lock
#define	portal_unlock	vop_generic_unlock
#define	portal_bmap	portal_badop
#define	portal_strategy	portal_badop
a82 1
#define	portal_islocked	vop_generic_islocked
a83 2
#define	portal_advlock	eopnotsupp
#define	portal_bwrite	eopnotsupp
d90 2
a91 2
	{ &vop_create_desc, portal_create },		/* create */
	{ &vop_mknod_desc, portal_mknod },		/* mknod */
d93 2
a94 2
	{ &vop_close_desc, portal_close },		/* close */
	{ &vop_access_desc, portal_access },		/* access */
d97 3
a99 3
	{ &vop_read_desc, portal_read },		/* read */
	{ &vop_write_desc, portal_write },		/* write */
	{ &vop_ioctl_desc, portal_ioctl },		/* ioctl */
d101 3
a103 3
	{ &vop_revoke_desc, portal_revoke },            /* revoke */
	{ &vop_fsync_desc, portal_fsync },		/* fsync */
	{ &vop_remove_desc, portal_remove },		/* remove */
d105 3
a107 3
	{ &vop_rename_desc, portal_rename },		/* rename */
	{ &vop_mkdir_desc, portal_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, portal_rmdir },		/* rmdir */
d110 2
a111 2
	{ &vop_readlink_desc, portal_readlink },	/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },		/* abortop */
d114 4
a117 4
	{ &vop_lock_desc, portal_lock },		/* lock */
	{ &vop_unlock_desc, portal_unlock },		/* unlock */
	{ &vop_bmap_desc, portal_bmap },		/* bmap */
	{ &vop_strategy_desc, portal_strategy },	/* strategy */
d119 1
a119 1
	{ &vop_islocked_desc, portal_islocked },	/* islocked */
d121 2
a122 2
	{ &vop_advlock_desc, portal_advlock },		/* advlock */
	{ &vop_bwrite_desc, portal_bwrite },		/* bwrite */
@


1.24
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.23 2007/06/01 23:47:57 deraadt Exp $	*/
d202 1
a202 2
	MALLOC(fvp->v_data, void *, sizeof(struct portalnode), M_TEMP,
	    M_WAITOK);
d593 1
a593 1
	FREE(ap->a_vp->v_data, M_TEMP);
@


1.23
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.22 2004/07/22 06:12:43 tedu Exp $	*/
d150 1
a150 3
portal_closefd(p, fd)
	struct proc *p;
	int fd;
d173 1
a173 2
portal_lookup(v)
	void *v;
d239 1
a239 3
portal_connect(so, so2)
	struct socket *so;
	struct socket *so2;
d270 1
a270 2
portal_open(v)
	void *v;
d506 1
a506 2
portal_getattr(v)
	void *v;
d547 1
a547 2
portal_setattr(v)
	void *v;
d569 1
a569 2
portal_readdir(v)
	void *v;
d576 1
a576 2
portal_inactive(v)
	void *v;
d585 1
a585 2
portal_reclaim(v)
	void *v;
d604 1
a604 2
portal_pathconf(v)
	void *v;
d638 1
a638 2
portal_print(v)
	void *v;
d645 1
a645 2
portal_link(v) 
	void *v;
d655 1
a655 2
portal_symlink(v)
	void *v;
d665 1
a665 2
portal_badop(v)
	void *v;
d672 1
a672 2
portal_poll(v)
	void *v;
@


1.22
log
@remove p arg from fdplock
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.21 2004/06/24 19:35:25 tholo Exp $	*/
d178 1
a178 5
	struct vop_lookup_args /* {
		struct vnode * a_dvp;
		struct vnode ** a_vpp;
		struct componentname * a_cnp;
	} */ *ap = v;
d278 1
a278 6
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d515 1
a515 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d557 1
a557 6
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d588 1
a588 4
 	struct vop_inactive_args /* {
 		struct vnode *a_vp;
		struct proc *a_p;
 	} */ *ap = v;
d598 1
a598 3
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d618 1
a618 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
d661 1
a661 5
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;  
		struct componentname *a_cnp;
	} */ *ap = v;
d672 1
a672 7
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
d691 1
a691 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;  
		struct proc *a_p;   
	} */ *ap = v;
@


1.21
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.20 2004/06/06 01:00:51 tedu Exp $	*/
d415 1
a415 1
		fdplock(p->p_fd, p);
@


1.20
log
@portal_connect needs splsoftnet.
using CMSG_ALIGN was wrong, userland fires in data not so aligned.
if fd_getfile returns NULL, don't try to close the fd, since it's not there.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.19 2004/05/18 12:37:51 pedro Exp $	*/
a531 1
	struct timeval tv;
d540 1
a540 2
	microtime(&tv);
	TIMEVAL_TO_TIMESPEC(&tv, &vap->va_atime);
@


1.19
log
@useless caddr_t casts removal, same sha1s
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.18 2004/04/23 17:43:48 tedu Exp $	*/
d342 1
d344 1
d458 1
a458 1
	newfds = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(*cmsg))) / sizeof (int);
d469 1
a469 1
	ip = (int *)CMSG_DATA(cmsg);
a487 1
		portal_closefd(p, fd);
@


1.18
log
@use CMSG macros.  netbsd via pedro marteletto.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.17 2004/02/21 20:08:32 tedu Exp $	*/
d366 1
a366 1
		(void) tsleep((caddr_t) &so->so_timeo, PSOCK, "portalcon", 5 * hz);
d389 1
a389 1
	aiov[0].iov_base = (caddr_t) &pcred;
d627 1
a627 1
		free((caddr_t) pt->pt_arg, M_TEMP);
@


1.17
log
@fiddle with filedesc lock to prevent recursion.  crash and fix confirmed
by marc balmer
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.16 2003/09/23 16:51:13 millert Exp $	*/
d456 1
a456 1
	newfds = (cmsg->cmsg_len - sizeof(*cmsg)) / sizeof (int);
d467 1
a467 1
	ip = (int *) (cmsg + 1);
@


1.16
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.15 2003/06/02 23:28:10 millert Exp $	*/
d410 1
d413 1
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.14 2003/02/24 03:54:22 tedu Exp $	*/
d57 1
a83 1
#define	portal_select	eopnotsupp
d105 1
d121 1
a121 1
	{ &vop_select_desc, portal_select },		/* select */
d722 13
@


1.14
log
@correct typo

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.13 2003/01/31 17:37:50 art Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.12 2002/03/14 01:27:08 millert Exp $	*/
d544 1
a544 1
	vap->va_ctime = vap->va_ctime;
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.11 2002/02/02 16:05:58 art Exp $	*/
d190 1
a204 1
		/*VOP_LOCK(dvp);*/
d231 9
a239 1
	/*VOP_LOCK(fvp);*/
@


1.11
log
@Be more consistent about using fd_getfile where it matters.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.10 2001/12/04 22:44:32 art Exp $	*/
d70 2
a71 2
static void	portal_closefd __P((struct proc *, int));
static int	portal_connect __P((struct socket *, struct socket *));
d74 1
a74 1
int portal_badop __P((void *));
d76 1
a76 1
int	portal_lookup	__P((void *));
d79 1
a79 1
int	portal_open	__P((void *));
d82 2
a83 2
int	portal_getattr	__P((void *));
int	portal_setattr	__P((void *));
d86 1
a86 1
#define	portal_ioctl    (int (*) __P((void *)))enoioctl
d90 1
a90 1
int	portal_link	__P((void *));
d94 2
a95 2
int	portal_symlink	__P((void *));
int	portal_readdir	__P((void *));
d98 2
a99 2
int	portal_inactive	__P((void *));
int	portal_reclaim	__P((void *));
d104 1
a104 1
int	portal_print	__P((void *));
d106 1
a106 1
int	portal_pathconf	__P((void *));
d110 1
a110 1
int (**portal_vnodeop_p) __P((void *));
@


1.10
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.9 2001/06/23 02:14:25 csapuntz Exp $	*/
d478 5
a482 1
 	fp = p->p_fd->fd_ofiles[fd];
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.10 2001/12/04 22:44:32 art Exp $	*/
d70 2
a71 2
static void	portal_closefd(struct proc *, int);
static int	portal_connect(struct socket *, struct socket *);
d74 1
a74 1
int portal_badop(void *);
d76 1
a76 1
int	portal_lookup(void *);
d79 1
a79 1
int	portal_open(void *);
d82 2
a83 2
int	portal_getattr(void *);
int	portal_setattr(void *);
d86 1
a86 1
#define	portal_ioctl    (int (*)(void *))enoioctl
d90 1
a90 1
int	portal_link(void *);
d94 2
a95 2
int	portal_symlink(void *);
int	portal_readdir(void *);
d98 2
a99 2
int	portal_inactive(void *);
int	portal_reclaim(void *);
d104 1
a104 1
int	portal_print(void *);
d106 1
a106 1
int	portal_pathconf(void *);
d110 1
a110 1
int (**portal_vnodeop_p)(void *);
d478 1
a478 5
	if ((fp = fd_getfile(p->p_fd, fd)) == NULL) {
		portal_closefd(p, fd);
		error = EBADF;
		goto bad;
	}
@


1.10.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a189 1
	struct proc *p = cnp->cn_proc;
d204 1
d231 1
a231 9
	VOP_LOCK(fvp, LK_EXCLUSIVE, p);
	/*
	 * As we are the last component of the path name, fix up
	 * the locking on the directory node.
	 */
	if ((cnp->cn_flags & LOCKPARENT) == 0) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
d536 1
a536 1
	vap->va_ctime = vap->va_atime;
@


1.10.2.3
log
@convert to genfs_nolock.  genfs_lock for kern and procfs
@
text
@a65 2

#include <miscfs/genfs/genfs.h>
d100 2
a101 2
#define	portal_lock	genfs_nolock
#define	portal_unlock	genfs_nounlock
d105 1
a105 1
#define	portal_islocked	genfs_noislocked
@


1.9
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.8 1999/11/10 23:17:39 csapuntz Exp $	*/
d147 1
a147 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.8
log
@

Fix to use enoioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.7 1998/08/06 19:34:44 csapuntz Exp $	*/
a87 1
#define	portal_mmap	eopnotsupp
a88 1
#define	portal_seek	nullop
a107 5
#define	portal_blkatoff	eopnotsupp
#define	portal_valloc	eopnotsupp
int	portal_vfree	__P((void *));
#define	portal_truncate	eopnotsupp
#define	portal_update	eopnotsupp
a125 1
	{ &vop_mmap_desc, portal_mmap },		/* mmap */
a126 1
	{ &vop_seek_desc, portal_seek },		/* seek */
a145 5
	{ &vop_blkatoff_desc, portal_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, portal_valloc },		/* valloc */
	{ &vop_vfree_desc, portal_vfree },		/* vfree */
	{ &vop_truncate_desc, portal_truncate },	/* truncate */
	{ &vop_update_desc, portal_update },		/* update */
a671 9
	return (0);
}

/* ARGSUSED */
int
portal_vfree(v)
	void *v;
{

@


1.8.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.8 1999/11/10 23:17:39 csapuntz Exp $	*/
d88 1
d90 1
d110 5
d133 1
d135 1
d155 5
d686 9
@


1.8.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d147 1
a147 1
	{ NULL, NULL }
d478 1
a478 5
	if ((fp = fd_getfile(p->p_fd, fd)) == NULL) {
		portal_closefd(p, fd);
		error = EBADF;
		goto bad;
	}
@


1.8.2.3
log
@Merge in -current from roughly a week ago
@
text
@d70 2
a71 2
static void	portal_closefd(struct proc *, int);
static int	portal_connect(struct socket *, struct socket *);
d74 1
a74 1
int portal_badop(void *);
d76 1
a76 1
int	portal_lookup(void *);
d79 1
a79 1
int	portal_open(void *);
d82 2
a83 2
int	portal_getattr(void *);
int	portal_setattr(void *);
d86 1
a86 1
#define	portal_ioctl    (int (*)(void *))enoioctl
d90 1
a90 1
int	portal_link(void *);
d94 2
a95 2
int	portal_symlink(void *);
int	portal_readdir(void *);
d98 2
a99 2
int	portal_inactive(void *);
int	portal_reclaim(void *);
d104 1
a104 1
int	portal_print(void *);
d106 1
a106 1
int	portal_pathconf(void *);
d110 1
a110 1
int (**portal_vnodeop_p)(void *);
@


1.8.2.4
log
@Sync the SMP branch with 3.3
@
text
@a189 1
	struct proc *p = cnp->cn_proc;
d204 1
d231 1
a231 9
	VOP_LOCK(fvp, LK_EXCLUSIVE, p);
	/*
	 * As we are the last component of the path name, fix up
	 * the locking on the directory node.
	 */
	if ((cnp->cn_flags & LOCKPARENT) == 0) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;
	}
d536 1
a536 1
	vap->va_ctime = vap->va_atime;
@


1.8.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.8.2.4 2003/03/28 00:00:20 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a56 1
#include <sys/poll.h>
d83 1
a104 1
int	portal_poll(void *);
d120 1
a120 1
	{ &vop_poll_desc, portal_poll },		/* poll */
a720 13
}

int
portal_poll(v)
	void *v;
{
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;  
		struct proc *a_p;   
	} */ *ap = v;

	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
@


1.8.2.7
log
@Merge with the trunk
@
text
@d366 1
a366 1
		(void) tsleep(&so->so_timeo, PSOCK, "portalcon", 5 * hz);
d389 1
a389 1
	aiov[0].iov_base = &pcred;
a409 1
		fdpunlock(p->p_fd);
a411 1
		fdplock(p->p_fd, p);
d454 1
a454 1
	newfds = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(*cmsg))) / sizeof (int);
d465 1
a465 1
	ip = (int *)CMSG_DATA(cmsg);
d625 1
a625 1
		free(pt->pt_arg, M_TEMP);
@


1.8.2.8
log
@sync to head
@
text
@a341 1
	s = splsoftnet();
a342 1
	splx(s);
d456 1
a456 1
	newfds = (cmsg->cmsg_len - sizeof(*cmsg)) / sizeof (int);
d467 1
a467 1
	ip = (int *)(cmsg + 1);
d486 1
@


1.7
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.6 1998/06/11 16:34:25 deraadt Exp $	*/
d86 1
a86 1
#define	portal_ioctl	eopnotsupp
@


1.6
log
@return EOPNOTSUPP for chflags() changes; peter@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.5 1997/11/06 05:58:41 csapuntz Exp $	*/
d98 1
a98 1
#define portal_revoke   vop_revoke
a99 1
int	portal_abortop	__P((void *));
d102 2
a103 2
#define	portal_lock	vop_nolock
#define	portal_unlock	vop_nounlock
d107 1
a107 1
#define	portal_islocked	vop_noislocked
d144 1
a144 1
	{ &vop_abortop_desc, portal_abortop },		/* abortop */
a727 14
}

int
portal_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;
 
	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.4 1997/10/06 21:04:47 deraadt Exp $	*/
d588 3
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: portal_vnops.c,v 1.2 1996/02/27 07:59:43 niklas Exp $	*/
d73 2
a74 2
int	portal_badop	__P((void *));
int	portal_enotsupp	__P((void *));
d77 2
a78 2
#define	portal_create	portal_enotsupp
#define	portal_mknod	portal_enotsupp
d84 5
a88 5
#define	portal_read	portal_enotsupp
#define	portal_write	portal_enotsupp
#define	portal_ioctl	portal_enotsupp
#define	portal_select	portal_enotsupp
#define	portal_mmap	portal_enotsupp
d91 1
a91 1
#define	portal_remove	portal_enotsupp
d93 3
a95 3
#define	portal_rename	portal_enotsupp
#define	portal_mkdir	portal_enotsupp
#define	portal_rmdir	portal_enotsupp
d98 2
a99 1
#define	portal_readlink	portal_enotsupp
d103 2
a104 2
#define	portal_lock	nullop
#define	portal_unlock	nullop
d108 1
a108 1
#define	portal_islocked	nullop
d110 3
a112 3
#define	portal_advlock	portal_enotsupp
#define	portal_blkatoff	portal_enotsupp
#define	portal_valloc	portal_enotsupp
d114 3
a116 3
#define	portal_truncate	portal_enotsupp
#define	portal_update	portal_enotsupp
#define	portal_bwrite	portal_enotsupp
d133 1
d601 1
a601 1
	return (0);
d609 4
d614 1
a741 16
/*
 * Portal vnode unsupported operation
 */
/*ARGSUSED*/
int
portal_enotsupp(v)
	void *v;
{

	return (EOPNOTSUPP);
}

/*
 * Portal "should never get here" operation
 */
/*ARGSUSED*/
d746 2
a747 3

	panic("portal: bad op");
	/* NOTREACHED */
@


1.3
log
@VFS Lite2 Changes
@
text
@d73 2
a74 2

int portal_badop __P((void *));
d77 2
a78 2
#define	portal_create	eopnotsupp
#define	portal_mknod	eopnotsupp
d84 5
a88 5
#define	portal_read	eopnotsupp
#define	portal_write	eopnotsupp
#define	portal_ioctl	eopnotsupp
#define	portal_select	eopnotsupp
#define	portal_mmap	eopnotsupp
d91 1
a91 1
#define	portal_remove	eopnotsupp
d93 3
a95 3
#define	portal_rename	eopnotsupp
#define	portal_mkdir	eopnotsupp
#define	portal_rmdir	eopnotsupp
d98 1
a98 2
#define portal_revoke   vop_revoke
#define	portal_readlink	eopnotsupp
d102 2
a103 2
#define	portal_lock	vop_nolock
#define	portal_unlock	vop_nounlock
d107 1
a107 1
#define	portal_islocked	vop_noislocked
d109 3
a111 3
#define	portal_advlock	eopnotsupp
#define	portal_blkatoff	eopnotsupp
#define	portal_valloc	eopnotsupp
d113 3
a115 3
#define	portal_truncate	eopnotsupp
#define	portal_update	eopnotsupp
#define	portal_bwrite	eopnotsupp
a131 1
	{ &vop_revoke_desc, portal_revoke },            /* revoke */
d599 1
a599 1
 	return (0);
a606 4
 	struct vop_inactive_args /* {
 		struct vnode *a_vp;
		struct proc *a_p;
 	} */ *ap = v;
a607 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
d735 16
d755 3
a757 2
	panic ("portal: bad op");
	return (0);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 2
a74 2
int	portal_badop	__P((void *));
int	portal_enotsupp	__P((void *));
d77 2
a78 2
#define	portal_create	portal_enotsupp
#define	portal_mknod	portal_enotsupp
d84 5
a88 5
#define	portal_read	portal_enotsupp
#define	portal_write	portal_enotsupp
#define	portal_ioctl	portal_enotsupp
#define	portal_select	portal_enotsupp
#define	portal_mmap	portal_enotsupp
d91 1
a91 1
#define	portal_remove	portal_enotsupp
d93 3
a95 3
#define	portal_rename	portal_enotsupp
#define	portal_mkdir	portal_enotsupp
#define	portal_rmdir	portal_enotsupp
d98 2
a99 1
#define	portal_readlink	portal_enotsupp
d103 2
a104 2
#define	portal_lock	nullop
#define	portal_unlock	nullop
d108 1
a108 1
#define	portal_islocked	nullop
d110 3
a112 3
#define	portal_advlock	portal_enotsupp
#define	portal_blkatoff	portal_enotsupp
#define	portal_valloc	portal_enotsupp
d114 3
a116 3
#define	portal_truncate	portal_enotsupp
#define	portal_update	portal_enotsupp
#define	portal_bwrite	portal_enotsupp
d133 1
d601 1
a601 1
	return (0);
d609 4
d614 1
a741 16
/*
 * Portal vnode unsupported operation
 */
/*ARGSUSED*/
int
portal_enotsupp(v)
	void *v;
{

	return (EOPNOTSUPP);
}

/*
 * Portal "should never get here" operation
 */
/*ARGSUSED*/
d746 2
a747 3

	panic("portal: bad op");
	/* NOTREACHED */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: portal_vnops.c,v 1.14 1995/10/07 06:28:55 mycroft Exp $	*/
a65 1

d70 95
d191 3
a193 1
portal_lookup(ap)
d198 1
a198 2
	} */ *ap;
{
d287 3
a289 1
portal_open(ap)
d295 1
a295 2
	} */ *ap;
{
d522 3
a524 1
portal_getattr(ap)
d530 1
a530 2
	} */ *ap;
{
d571 3
a573 1
portal_setattr(ap)
d579 1
a579 2
	} */ *ap;
{
d594 1
d596 2
a597 6
portal_readdir(ap)
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *ap;
a598 1

d602 1
d604 2
a605 4
portal_inactive(ap)
	struct vop_inactive_args /* {
		struct vnode *a_vp;
	} */ *ap;
d612 3
a614 1
portal_reclaim(ap)
d617 1
a617 2
	} */ *ap;
{
d633 4
a636 1
portal_pathconf(ap)
d641 1
a641 2
	} */ *ap;
{
d673 2
a674 4
portal_print(ap)
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap;
a675 1

d680 1
a680 1
/*void*/
d682 2
a683 6
portal_vfree(ap)
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap;
d689 45
d738 1
d740 2
a741 1
portal_enotsupp()
d750 1
d752 2
a753 1
portal_badop()
a758 99

/*
 * Portal vnode null operation
 */
int
portal_nullop()
{

	return (0);
}

#define portal_create ((int (*) __P((struct vop_create_args *)))portal_enotsupp)
#define portal_mknod ((int (*) __P((struct  vop_mknod_args *)))portal_enotsupp)
#define portal_close ((int (*) __P((struct  vop_close_args *)))nullop)
#define portal_access ((int (*) __P((struct  vop_access_args *)))nullop)
#define portal_read ((int (*) __P((struct  vop_read_args *)))portal_enotsupp)
#define portal_write ((int (*) __P((struct  vop_write_args *)))portal_enotsupp)
#define portal_ioctl ((int (*) __P((struct  vop_ioctl_args *)))portal_enotsupp)
#define portal_select ((int (*) __P((struct vop_select_args *)))portal_enotsupp)
#define portal_mmap ((int (*) __P((struct  vop_mmap_args *)))portal_enotsupp)
#define portal_fsync ((int (*) __P((struct  vop_fsync_args *)))nullop)
#define portal_seek ((int (*) __P((struct  vop_seek_args *)))nullop)
#define portal_remove ((int (*) __P((struct vop_remove_args *)))portal_enotsupp)
#define portal_link ((int (*) __P((struct  vop_link_args *)))portal_enotsupp)
#define portal_rename ((int (*) __P((struct vop_rename_args *)))portal_enotsupp)
#define portal_mkdir ((int (*) __P((struct  vop_mkdir_args *)))portal_enotsupp)
#define portal_rmdir ((int (*) __P((struct  vop_rmdir_args *)))portal_enotsupp)
#define portal_symlink \
	((int (*) __P((struct  vop_symlink_args *)))portal_enotsupp)
#define portal_readlink \
	((int (*) __P((struct  vop_readlink_args *)))portal_enotsupp)
#define portal_abortop ((int (*) __P((struct  vop_abortop_args *)))nullop)
#define portal_lock ((int (*) __P((struct  vop_lock_args *)))nullop)
#define portal_unlock ((int (*) __P((struct  vop_unlock_args *)))nullop)
#define portal_bmap ((int (*) __P((struct  vop_bmap_args *)))portal_badop)
#define portal_strategy \
	((int (*) __P((struct  vop_strategy_args *)))portal_badop)
#define portal_islocked ((int (*) __P((struct  vop_islocked_args *)))nullop)
#define portal_advlock \
	((int (*) __P((struct  vop_advlock_args *)))portal_enotsupp)
#define portal_blkatoff \
	((int (*) __P((struct  vop_blkatoff_args *)))portal_enotsupp)
#define portal_valloc ((int(*) __P(( \
		struct vnode *pvp, \
		int mode, \
		struct ucred *cred, \
		struct vnode **vpp))) portal_enotsupp)
#define portal_truncate \
	((int (*) __P((struct  vop_truncate_args *)))portal_enotsupp)
#define portal_update ((int (*) __P((struct vop_update_args *)))portal_enotsupp)
#define portal_bwrite ((int (*) __P((struct vop_bwrite_args *)))portal_enotsupp)

int (**portal_vnodeop_p)();
struct vnodeopv_entry_desc portal_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, portal_lookup },		/* lookup */
	{ &vop_create_desc, portal_create },		/* create */
	{ &vop_mknod_desc, portal_mknod },		/* mknod */
	{ &vop_open_desc, portal_open },		/* open */
	{ &vop_close_desc, portal_close },		/* close */
	{ &vop_access_desc, portal_access },		/* access */
	{ &vop_getattr_desc, portal_getattr },		/* getattr */
	{ &vop_setattr_desc, portal_setattr },		/* setattr */
	{ &vop_read_desc, portal_read },		/* read */
	{ &vop_write_desc, portal_write },		/* write */
	{ &vop_ioctl_desc, portal_ioctl },		/* ioctl */
	{ &vop_select_desc, portal_select },		/* select */
	{ &vop_mmap_desc, portal_mmap },		/* mmap */
	{ &vop_fsync_desc, portal_fsync },		/* fsync */
	{ &vop_seek_desc, portal_seek },		/* seek */
	{ &vop_remove_desc, portal_remove },		/* remove */
	{ &vop_link_desc, portal_link },		/* link */
	{ &vop_rename_desc, portal_rename },		/* rename */
	{ &vop_mkdir_desc, portal_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, portal_rmdir },		/* rmdir */
	{ &vop_symlink_desc, portal_symlink },		/* symlink */
	{ &vop_readdir_desc, portal_readdir },		/* readdir */
	{ &vop_readlink_desc, portal_readlink },	/* readlink */
	{ &vop_abortop_desc, portal_abortop },		/* abortop */
	{ &vop_inactive_desc, portal_inactive },	/* inactive */
	{ &vop_reclaim_desc, portal_reclaim },		/* reclaim */
	{ &vop_lock_desc, portal_lock },		/* lock */
	{ &vop_unlock_desc, portal_unlock },		/* unlock */
	{ &vop_bmap_desc, portal_bmap },		/* bmap */
	{ &vop_strategy_desc, portal_strategy },	/* strategy */
	{ &vop_print_desc, portal_print },		/* print */
	{ &vop_islocked_desc, portal_islocked },	/* islocked */
	{ &vop_pathconf_desc, portal_pathconf },	/* pathconf */
	{ &vop_advlock_desc, portal_advlock },		/* advlock */
	{ &vop_blkatoff_desc, portal_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, portal_valloc },		/* valloc */
	{ &vop_vfree_desc, portal_vfree },		/* vfree */
	{ &vop_truncate_desc, portal_truncate },	/* truncate */
	{ &vop_update_desc, portal_update },		/* update */
	{ &vop_bwrite_desc, portal_bwrite },		/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
};
struct vnodeopv_desc portal_vnodeop_opv_desc =
	{ &portal_vnodeop_p, portal_vnodeop_entries };
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
