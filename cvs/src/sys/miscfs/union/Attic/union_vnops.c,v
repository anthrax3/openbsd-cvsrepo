head	1.25;
access;
symbols
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.14
	OPENBSD_2_8:1.12.0.12
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.10
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.8
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2005.05.26.00.38.50;	author pedro;	state dead;
branches;
next	1.24;

1.24
date	2004.04.25.19.46.40;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.25.03.21.19;	author jolan;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.12.21.45.35;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.18.43.34;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.04.22.44.32;	author art;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.07.26.20.46.29;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.26.02.10.41;	author assar;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.23.02.14.26;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	98.08.18.07.08.29;	author deraadt;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	98.08.06.19.34.51;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	98.07.13.02.52.01;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.05.58.54;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.21.04.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.15.19.18;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	96.12.08.17.40.29;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.29.07.12.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.12.04.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.27.08.09.03;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.06.15.33.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.03;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2001.07.04.10.49.21;	author niklas;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2001.10.31.03.26.30;	author nate;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.12.8.4;

1.12.8.4
date	2003.03.28.00.00.21;	author niklas;	state Exp;
branches;
next	1.12.8.5;

1.12.8.5
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.12.8.6;

1.12.8.6
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.12.8.7;

1.12.8.7
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.12.8.8;

1.12.8.8
date	2004.06.05.23.13.06;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.30.21;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.01.11.09;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.05.19.22.36.12;	author tedu;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2003.05.20.04.05.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@bye bye, rest in attic ad infinitum, amen
@
text
@/*	$OpenBSD: union_vnops.c,v 1.24 2004/04/25 19:46:40 tedu Exp $ */
/*	$NetBSD: union_vnops.c,v 1.59 2002/09/27 15:37:48 provos Exp $	*/

/*
 * Copyright (c) 1992, 1993, 1994, 1995 Jan-Simon Pendry.
 * Copyright (c) 1992, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)union_vnops.c	8.33 (Berkeley) 7/31/95
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/queue.h>
#include <sys/lock.h>

#if 0
#include <miscfs/genfs/genfs.h>
#endif
#include <miscfs/union/union.h>


int union_lookup(void *);
int union_create(void *);
int union_whiteout(void *);
int union_mknod(void *);
int union_open(void *);
int union_close(void *);
int union_access(void *);
int union_getattr(void *);
int union_setattr(void *);
int union_read(void *);
int union_write(void *);
int union_lease(void *);
int union_ioctl(void *);
int union_poll(void *);
int union_fsync(void *);
int union_remove(void *);
int union_link(void *);
int union_rename(void *);
int union_mkdir(void *);
int union_rmdir(void *);
int union_revoke(void *);
int union_symlink(void *);
int union_readdir(void *);
int union_readlink(void *);
int union_abortop(void *);
int union_inactive(void *);
int union_reclaim(void *);
int union_lock(void *);
int union_unlock(void *);
int union_bmap(void *);
int union_print(void *);
int union_islocked(void *);
int union_pathconf(void *);
int union_advlock(void *);
int union_strategy(void *);

static void union_fixup(struct union_node *, struct proc *);
static int union_lookup1(struct vnode *, struct vnode **,
	struct vnode **, struct componentname *);


/*
 * Global vfs data structures
 */
int (**union_vnodeop_p)(void *);
struct vnodeopv_entry_desc union_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, union_lookup },		/* lookup */
	{ &vop_create_desc, union_create },		/* create */
	{ &vop_whiteout_desc, union_whiteout },		/* whiteout */
	{ &vop_mknod_desc, union_mknod },		/* mknod */
	{ &vop_open_desc, union_open },			/* open */
	{ &vop_close_desc, union_close },		/* close */
	{ &vop_access_desc, union_access },		/* access */
	{ &vop_getattr_desc, union_getattr },		/* getattr */
	{ &vop_setattr_desc, union_setattr },		/* setattr */
	{ &vop_read_desc, union_read },			/* read */
	{ &vop_write_desc, union_write },		/* write */
	{ &vop_lease_desc, union_lease },		/* lease */
	{ &vop_ioctl_desc, union_ioctl },		/* ioctl */
	{ &vop_poll_desc, union_poll },			/* poll */
	{ &vop_fsync_desc, union_fsync },		/* fsync */
	{ &vop_remove_desc, union_remove },		/* remove */
	{ &vop_link_desc, union_link },			/* link */
	{ &vop_rename_desc, union_rename },		/* rename */
	{ &vop_mkdir_desc, union_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, union_rmdir },		/* rmdir */
	{ &vop_symlink_desc, union_symlink },		/* symlink */
	{ &vop_readdir_desc, union_readdir },		/* readdir */
	{ &vop_readlink_desc, union_readlink },		/* readlink */
	{ &vop_revoke_desc, union_revoke },             /* revoke */
	{ &vop_abortop_desc, union_abortop },		/* abortop */
	{ &vop_inactive_desc, union_inactive },		/* inactive */
	{ &vop_reclaim_desc, union_reclaim },		/* reclaim */
	{ &vop_lock_desc, union_lock },			/* lock */
	{ &vop_unlock_desc, union_unlock },		/* unlock */
	{ &vop_bmap_desc, union_bmap },			/* bmap */
	{ &vop_strategy_desc, union_strategy },		/* strategy */
	{ &vop_print_desc, union_print },		/* print */
	{ &vop_islocked_desc, union_islocked },		/* islocked */
	{ &vop_pathconf_desc, union_pathconf },		/* pathconf */
	{ &vop_advlock_desc, union_advlock },		/* advlock */
#ifdef notdef
	{ &vop_blkatoff_desc, union_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, union_valloc },		/* valloc */
	{ &vop_vfree_desc, union_vfree },		/* vfree */
	{ &vop_truncate_desc, union_truncate },		/* truncate */
	{ &vop_update_desc, union_update },		/* update */
	{ &vop_bwrite_desc, union_bwrite },		/* bwrite */
#endif
	{ NULL, NULL }
};
const struct vnodeopv_desc union_vnodeop_opv_desc =
	{ &union_vnodeop_p, union_vnodeop_entries };

#define FIXUP(un, _p) { \
	if (((un)->un_flags & UN_ULOCK) == 0) { \
		union_fixup(un, _p); \
	} \
}

static void
union_fixup(un, p)
	struct union_node *un;
	struct proc *p;
{

	vn_lock(un->un_uppervp, LK_EXCLUSIVE | LK_RETRY, p);
	un->un_flags |= UN_ULOCK;
}

static int
union_lookup1(udvp, dvpp, vpp, cnp)
	struct vnode *udvp;
	struct vnode **dvpp;
	struct vnode **vpp;
	struct componentname *cnp;
{
	struct proc *p = cnp->cn_proc;
	int error;
	struct vnode *tdvp;
	struct vnode *dvp;
	struct mount *mp;

	dvp = *dvpp;

	/*
	 * If stepping up the directory tree, check for going
	 * back across the mount point, in which case do what
	 * lookup would do by stepping back down the mount
	 * hierarchy.
	 */
	if (cnp->cn_flags & ISDOTDOT) {
		while ((dvp != udvp) && (dvp->v_flag & VROOT)) {
			/*
			 * Don't do the NOCROSSMOUNT check
			 * at this level.  By definition,
			 * union fs deals with namespaces, not
			 * filesystems.
			 */
			tdvp = dvp;
			*dvpp = dvp = dvp->v_mount->mnt_vnodecovered;
			vput(tdvp);
			VREF(dvp);
			vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
		}
	}

	error = VOP_LOOKUP(dvp, &tdvp, cnp);
	if (error)
		return (error);

	/*
	 * The parent directory will have been unlocked, unless lookup
	 * found the last component.  In which case, re-lock the node
	 * here to allow it to be unlocked again (phew) in union_lookup.
	 */
	if (dvp != tdvp && !(cnp->cn_flags & ISLASTCN))
		vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);

	dvp = tdvp;

	/*
	 * Lastly check if the current node is a mount point in
	 * which case walk up the mount hierarchy making sure not to
	 * bump into the root of the mount tree (ie. dvp != udvp).
	 */
	while (dvp != udvp && (dvp->v_type == VDIR) &&
		(mp = dvp->v_mountedhere)) {

		if (vfs_busy(mp, 0, 0, p))
			continue;

		error = VFS_ROOT(mp, &tdvp);
		vfs_unbusy(mp, p);
		vput(dvp);
		if (error)
			return (error);

		dvp = tdvp;
	}

	*vpp = dvp;
	return (0);
}

int
union_lookup(v)
	void *v;
{
	struct vop_lookup_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap = v;
	int error;
	int uerror, lerror;
	struct vnode *uppervp, *lowervp;
	struct vnode *upperdvp, *lowerdvp;
	struct vnode *dvp = ap->a_dvp;
	struct union_node *dun = VTOUNION(dvp);
	struct proc *p = curproc;
	struct componentname *cnp = ap->a_cnp;
	int lockparent = cnp->cn_flags & LOCKPARENT;
	struct union_mount *um = MOUNTTOUNIONMOUNT(dvp->v_mount);
	struct ucred *saved_cred = NULL;
	int iswhiteout;
	struct vattr va;

#ifdef notyet
	if (cnp->cn_namelen == 3 &&
			cnp->cn_nameptr[2] == '.' &&
			cnp->cn_nameptr[1] == '.' &&
			cnp->cn_nameptr[0] == '.') {
		dvp = *ap->a_vpp = LOWERVP(ap->a_dvp);
		if (dvp == NULLVP)
			return (ENOENT);
		VREF(dvp);
		vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
		if (!lockparent || !(cnp->cn_flags & ISLASTCN))
			VOP_UNLOCK(ap->a_dvp, 0, p);
		return (0);
	}
#endif

	if ((cnp->cn_flags & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

	cnp->cn_flags |= LOCKPARENT;

	upperdvp = dun->un_uppervp;
	lowerdvp = dun->un_lowervp;
	uppervp = NULLVP;
	lowervp = NULLVP;
	iswhiteout = 0;

	/*
	 * do the lookup in the upper level.
	 * if that level consumes additional pathnames,
	 * then assume that something special is going
	 * on and just return that vnode.
	 */
	if (upperdvp != NULLVP) {
		FIXUP(dun, p);
		/*
		 * If we're doing `..' in the underlying filesystem,
		 * we must drop our lock on the union node before
		 * going up the tree in the lower file system--if we block
		 * on the lowervp lock, and that's held by someone else
		 * coming down the tree and who's waiting for our lock,
		 * we would be hosed.
		 */
		if (cnp->cn_flags & ISDOTDOT) {
			/* retain lock on underlying VP */
			dun->un_flags |= UN_KLOCK;
			VOP_UNLOCK(dvp, 0, p);
		}
		uerror = union_lookup1(um->um_uppervp, &upperdvp,
					&uppervp, cnp);

		if (cnp->cn_flags & ISDOTDOT) {
			if (dun->un_uppervp == upperdvp) {
				/*
				 * we got the underlying bugger back locked...
				 * now take back the union node lock.  Since we
				 * hold the uppervp lock, we can diddle union
				 * locking flags at will. :)
				 */
				dun->un_flags |= UN_ULOCK;
			}
			/*
			 * if upperdvp got swapped out, it means we did
			 * some mount point magic, and we do not have
			 * dun->un_uppervp locked currently--so we get it
			 * locked here (don't set the UN_ULOCK flag).
			 */
			vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
		}
		if (cnp->cn_consume != 0) {
			*ap->a_vpp = uppervp;
			if (!lockparent)
				cnp->cn_flags &= ~LOCKPARENT;
			return (uerror);
		}
		if (uerror == ENOENT || uerror == EJUSTRETURN) {
			if (cnp->cn_flags & ISWHITEOUT) {
				iswhiteout = 1;
			} else if (lowerdvp != NULLVP) {
				lerror = VOP_GETATTR(upperdvp, &va,
					cnp->cn_cred, cnp->cn_proc);
				if (lerror == 0 && (va.va_flags & OPAQUE))
					iswhiteout = 1;
			}
		}
	} else {
		uerror = ENOENT;
	}

	/*
	 * in a similar way to the upper layer, do the lookup
	 * in the lower layer.   this time, if there is some
	 * component magic going on, then vput whatever we got
	 * back from the upper layer and return the lower vnode
	 * instead.
	 */
	if (lowerdvp != NULLVP && !iswhiteout) {
		int nameiop;

		vn_lock(lowerdvp, LK_EXCLUSIVE | LK_RETRY, p);

		/*
		 * Only do a LOOKUP on the bottom node, since
		 * we won't be making changes to it anyway.
		 */
		nameiop = cnp->cn_nameiop;
		cnp->cn_nameiop = LOOKUP;
		if (um->um_op == UNMNT_BELOW) {
			saved_cred = cnp->cn_cred;
			cnp->cn_cred = um->um_cred;
		}
		/*
		 * we shouldn't have to worry about locking interactions
		 * between the lower layer and our union layer (w.r.t.
		 * `..' processing) because we don't futz with lowervp
		 * locks in the union-node instantiation code path.
		 */
		lerror = union_lookup1(um->um_lowervp, &lowerdvp,
				&lowervp, cnp);
		if (um->um_op == UNMNT_BELOW)
			cnp->cn_cred = saved_cred;
		cnp->cn_nameiop = nameiop;

		if (lowervp != lowerdvp)
			VOP_UNLOCK(lowerdvp, 0, p);

		if (cnp->cn_consume != 0) {
			if (uppervp != NULLVP) {
				if (uppervp == upperdvp)
					vrele(uppervp);
				else
					vput(uppervp);
				uppervp = NULLVP;
			}
			*ap->a_vpp = lowervp;
			if (!lockparent)
				cnp->cn_flags &= ~LOCKPARENT;
			return (lerror);
		}
	} else {
		lerror = ENOENT;
		if ((cnp->cn_flags & ISDOTDOT) && dun->un_pvp != NULLVP) {
			lowervp = LOWERVP(dun->un_pvp);
			if (lowervp != NULLVP) {
				VREF(lowervp);
				vn_lock(lowervp, LK_EXCLUSIVE | LK_RETRY, p);
				lerror = 0;
			}
		}
	}

	if (!lockparent)
		cnp->cn_flags &= ~LOCKPARENT;

	/*
	 * EJUSTRETURN is used by underlying filesystems to indicate that
	 * a directory modification op was started successfully.
	 * This will only happen in the upper layer, since
	 * the lower layer only does LOOKUPs.
	 * If this union is mounted read-only, bounce it now.
	 */

	if ((uerror == EJUSTRETURN) && (cnp->cn_flags & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    ((cnp->cn_nameiop == CREATE) || (cnp->cn_nameiop == RENAME)))
		uerror = EROFS;

	/*
	 * at this point, we have uerror and lerror indicating
	 * possible errors with the lookups in the upper and lower
	 * layers.  additionally, uppervp and lowervp are (locked)
	 * references to existing vnodes in the upper and lower layers.
	 *
	 * there are now three cases to consider.
	 * 1. if both layers returned an error, then return whatever
	 *    error the upper layer generated.
	 *
	 * 2. if the top layer failed and the bottom layer succeeded
	 *    then two subcases occur.
	 *    a.  the bottom vnode is not a directory, in which
	 *	  case just return a new union vnode referencing
	 *	  an empty top layer and the existing bottom layer.
	 *    b.  the bottom vnode is a directory, in which case
	 *	  create a new directory in the top-level and
	 *	  continue as in case 3.
	 *
	 * 3. if the top layer succeeded then return a new union
	 *    vnode referencing whatever the new top layer and
	 *    whatever the bottom layer returned.
	 */

	*ap->a_vpp = NULLVP;


	/* case 1. */
	if ((uerror != 0) && (lerror != 0)) {
		return (uerror);
	}

	/* case 2. */
	if (uerror != 0 /* && (lerror == 0) */ ) {
		if (lowervp->v_type == VDIR) { /* case 2b. */
			/*
			 * We may be racing another process to make the
			 * upper-level shadow directory.  Be careful with
			 * locks/etc!
			 */
			dun->un_flags &= ~UN_ULOCK;
			VOP_UNLOCK(upperdvp, 0, p);
			uerror = union_mkshadow(um, upperdvp, cnp, &uppervp);
			vn_lock(upperdvp, LK_EXCLUSIVE | LK_RETRY, p);
			dun->un_flags |= UN_ULOCK;

			if (uerror) {
				if (lowervp != NULLVP) {
					vput(lowervp);
					lowervp = NULLVP;
				}
				return (uerror);
			}
		}
	}

	if (lowervp != NULLVP)
		VOP_UNLOCK(lowervp, 0, p);

	error = union_allocvp(ap->a_vpp, dvp->v_mount, dvp, upperdvp, cnp,
	    uppervp, lowervp, 1);

	if (error) {
		if (uppervp != NULLVP)
			vput(uppervp);
		if (lowervp != NULLVP)
			vrele(lowervp);
	} else {
		if (*ap->a_vpp != dvp)
			if (!lockparent || !(cnp->cn_flags & ISLASTCN))
				VOP_UNLOCK(dvp, 0, p);
		if (cnp->cn_namelen == 1 &&
		    cnp->cn_nameptr[0] == '.' &&
		    *ap->a_vpp != dvp) {
			panic("union_lookup -> . (%p) != startdir (%p)",
			    ap->a_vpp, dvp);
		}
	}

	return (error);
}

int
union_create(v)
	void *v;
{
	struct vop_create_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_dvp);
	struct vnode *dvp = un->un_uppervp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;

	if (dvp != NULLVP) {
		int error;
		struct vnode *vp;
		struct mount *mp;

		FIXUP(un, p);

		VREF(dvp);
		un->un_flags |= UN_KLOCK;
		mp = ap->a_dvp->v_mount;
		vput(ap->a_dvp);
		error = VOP_CREATE(dvp, &vp, cnp, ap->a_vap);
		if (error)
			return (error);

		error = union_allocvp(ap->a_vpp, mp, NULLVP, NULLVP, cnp, vp,
				NULLVP, 1);
		if (error)
			vput(vp);
		return (error);
	}

	vput(ap->a_dvp);
	return (EROFS);
}

int
union_whiteout(v)
	void *v;
{
	struct vop_whiteout_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
		int a_flags;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_dvp);
	struct componentname *cnp = ap->a_cnp;

	if (un->un_uppervp == NULLVP)
		return (EOPNOTSUPP);

	FIXUP(un, curproc);
	return (VOP_WHITEOUT(un->un_uppervp, cnp, ap->a_flags));
}

int
union_mknod(v)
	void *v;
{
	struct vop_mknod_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_dvp);
	struct vnode *dvp = un->un_uppervp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;

	if (dvp != NULLVP) {
		int error;
		struct vnode *vp;
		struct mount *mp;

		FIXUP(un, p);

		VREF(dvp);
		un->un_flags |= UN_KLOCK;
		mp = ap->a_dvp->v_mount;
		vput(ap->a_dvp);
		error = VOP_MKNOD(dvp, &vp, cnp, ap->a_vap);
		if (error)
			return (error);

		error = union_allocvp(ap->a_vpp, mp, NULLVP, NULLVP,
		    cnp, vp, NULLVP, 1);
		if (error)
			vput(vp);
		return (error);
	}

	vput(ap->a_dvp);
	return (EROFS);
}

int
union_open(v)
	void *v;
{
	struct vop_open_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_vp;
		int a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_vp);
	struct vnode *tvp;
	int mode = ap->a_mode;
	struct ucred *cred = ap->a_cred;
	struct proc *p = ap->a_p;
	int error;

	/*
	 * If there is an existing upper vp then simply open that.
	 */
	tvp = un->un_uppervp;
	if (tvp == NULLVP) {
		/*
		 * If the lower vnode is being opened for writing, then
		 * copy the file contents to the upper vnode and open that,
		 * otherwise can simply open the lower vnode.
		 */
		tvp = un->un_lowervp;
		if ((ap->a_mode & FWRITE) && (tvp->v_type == VREG)) {
			error = union_copyup(un, (mode&O_TRUNC) == 0, cred, p);
			if (error == 0)
				error = VOP_OPEN(un->un_uppervp, mode, cred, p);
			return (error);
		}

		/*
		 * Just open the lower vnode, but check for nodev mount flag
		 */
		if ((tvp->v_type == VBLK || tvp->v_type == VCHR) &&
		    (ap->a_vp->v_mount->mnt_flag & MNT_NODEV))
			return ENXIO;
		un->un_openl++;
		vn_lock(tvp, LK_EXCLUSIVE | LK_RETRY, p);
		error = VOP_OPEN(tvp, mode, cred, p);
		VOP_UNLOCK(tvp, 0, p);

		return (error);
	}
	/*
	 * Just open the upper vnode, checking for nodev mount flag first
	 */
	if ((tvp->v_type == VBLK || tvp->v_type == VCHR) &&
	    (ap->a_vp->v_mount->mnt_flag & MNT_NODEV))
		return ENXIO;

	FIXUP(un, p);

	error = VOP_OPEN(tvp, mode, cred, p);

	return (error);
}

int
union_close(v)
	void *v;
{
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_vp);
	struct vnode *vp;

	vp = un->un_uppervp;
	if (vp == NULLVP) {
#ifdef UNION_DIAGNOSTIC
		if (un->un_openl <= 0)
			panic("union: un_openl cnt");
#endif
		--un->un_openl;
		vp = un->un_lowervp;
	}

#ifdef DIAGNOSTIC
	if (vp == NULLVP) {
		vprint("empty union vnode", vp);
		panic("union_close empty vnode");
	}
#endif

	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_close), ap));
}

/*
 * Check access permission on the union vnode.
 * The access check being enforced is to check
 * against both the underlying vnode, and any
 * copied vnode.  This ensures that no additional
 * file permissions are given away simply because
 * the user caused an implicit file copy.
 */
int
union_access(v)
	void *v;
{
	struct vop_access_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_vp;
		int a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
	int error = EACCES;
	struct proc *p = ap->a_p;
	struct union_mount *um = MOUNTTOUNIONMOUNT(vp->v_mount);

	/*
	 * Disallow write attempts on read-only file systems;
	 * unless the file is a socket, fifo, or a block or
	 * character device resident on the file system.
	 */
	if (ap->a_mode & VWRITE) {
		switch (vp->v_type) {
		case VDIR:
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
			break;
		case VBAD:
		case VBLK:
		case VCHR:
		case VSOCK:
		case VFIFO:
		case VNON:
		default:
			break;
		}
	}


	if ((vp = un->un_uppervp) != NULLVP) {
		FIXUP(un, p);
		ap->a_vp = vp;
		return (VCALL(vp, VOFFSET(vop_access), ap));
	}

	if ((vp = un->un_lowervp) != NULLVP) {
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		ap->a_vp = vp;
		error = VCALL(vp, VOFFSET(vop_access), ap);
		if (error == 0) {
			if (um->um_op == UNMNT_BELOW) {
				ap->a_cred = um->um_cred;
				error = VCALL(vp, VOFFSET(vop_access), ap);
			}
		}
		VOP_UNLOCK(vp, 0, p);
		if (error)
			return (error);
	}

	return (error);
}

/*
 * We handle getattr only to change the fsid and
 * track object sizes
 */
int
union_getattr(v)
	void *v;
{
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	int error;
	struct union_node *un = VTOUNION(ap->a_vp);
	struct vnode *vp = un->un_uppervp;
	struct vattr *vap;
	struct vattr va;
	struct proc *p = ap->a_p;


	/*
	 * Some programs walk the filesystem hierarchy by counting
	 * links to directories to avoid stat'ing all the time.
	 * This means the link count on directories needs to be "correct".
	 * The only way to do that is to call getattr on both layers
	 * and fix up the link count.  The link count will not necessarily
	 * be accurate but will be large enough to defeat the tree walkers.
	 *
	 * To make life more interesting, some filesystems don't keep
	 * track of link counts in the expected way, and return a
	 * link count of `1' for those directories; if either of the
	 * component directories returns a link count of `1', we return a 1.
	 */

	vap = ap->a_vap;

	vp = un->un_uppervp;
	if (vp != NULLVP) {
		/*
		 * It's not clear whether VOP_GETATTR is to be
		 * called with the vnode locked or not.  stat() calls
		 * it with (vp) locked, and fstat calls it with
		 * (vp) unlocked.
		 * In the mean time, compensate here by checking
		 * the union_node's lock flag.
		 */
		if (un->un_flags & UN_LOCKED)
			FIXUP(un, p);

		error = VOP_GETATTR(vp, vap, ap->a_cred, ap->a_p);
		if (error)
			return (error);
		union_newsize(ap->a_vp, vap->va_size, VNOVAL);
	}

	if (vp == NULLVP) {
		vp = un->un_lowervp;
	} else if (vp->v_type == VDIR) {
		vp = un->un_lowervp;
		if (vp != NULLVP)
			vap = &va;
	} else {
		vp = NULLVP;
	}

	if (vp != NULLVP) {
		error = VOP_GETATTR(vp, vap, ap->a_cred, ap->a_p);
		if (error)
			return (error);
		union_newsize(ap->a_vp, VNOVAL, vap->va_size);
	}

	if ((vap != ap->a_vap) && (vap->va_type == VDIR)) {
		/*
		 * Link count manipulation:
		 *	- If both return "2", return 2 (no subdirs)
		 *	- If one or the other return "1", return "1" (ENOCLUE)
		 */
		if ((ap->a_vap->va_nlink == 2) &&
		    (vap->va_nlink == 2))
			;
		else if (ap->a_vap->va_nlink != 1) {
			if (vap->va_nlink == 1)
				ap->a_vap->va_nlink = 1;
			else
				ap->a_vap->va_nlink += vap->va_nlink;
		}
	}
	ap->a_vap->va_fsid = ap->a_vp->v_mount->mnt_stat.f_fsid.val[0];
	return (0);
}

int
union_setattr(v)
	void *v;
{
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	struct vattr *vap = ap->a_vap;
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
	struct proc *p = ap->a_p;
	int error;

	if ((vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
	    vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_sec != VNOVAL ||
	    vap->va_mtime.tv_sec != VNOVAL || vap->va_mode != (mode_t)VNOVAL) &&
	    (vp->v_mount->mnt_flag & MNT_RDONLY))
		return (EROFS);
	if (vap->va_size != VNOVAL) {
		switch (vp->v_type) {
		case VDIR:
			return (EISDIR);
		case VCHR:
		case VBLK:
		case VSOCK:
		case VFIFO:
			break;
		case VREG:
		case VLNK:
 		default:
			/*
			 * Disallow write attempts if the filesystem is
			 * mounted read-only.
			 */
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
		}
	}

	/*
	 * Handle case of truncating lower object to zero size,
	 * by creating a zero length upper object.  This is to
	 * handle the case of open with O_TRUNC and O_CREAT.
	 */
	if ((un->un_uppervp == NULLVP) &&
	    /* assert(un->un_lowervp != NULLVP) */
	    (un->un_lowervp->v_type == VREG)) {
		error = union_copyup(un, (vap->va_size != 0),
						ap->a_cred, ap->a_p);
		if (error)
			return (error);
	}

	/*
	 * Try to set attributes in upper layer,
	 * otherwise return read-only filesystem error.
	 */
	if (un->un_uppervp != NULLVP) {
		FIXUP(un, p);
		error = VOP_SETATTR(un->un_uppervp, vap,
					ap->a_cred, ap->a_p);
		if ((error == 0) && (vap->va_size != VNOVAL))
			union_newsize(ap->a_vp, vap->va_size, VNOVAL);
	} else {
		error = EROFS;
	}

	return (error);
}

int
union_read(v)
	void *v;
{
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
	int error;
	struct vnode *vp = OTHERVP(ap->a_vp);
	int dolock = (vp == LOWERVP(ap->a_vp));
	struct proc *p = curproc;

	if (dolock)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	else
		FIXUP(VTOUNION(ap->a_vp), p);
	error = VOP_READ(vp, ap->a_uio, ap->a_ioflag, ap->a_cred);
	if (dolock)
		VOP_UNLOCK(vp, 0, p);

	/*
	 * XXX
	 * perhaps the size of the underlying object has changed under
	 * our feet.  take advantage of the offset information present
	 * in the uio structure.
	 */
	if (error == 0) {
		struct union_node *un = VTOUNION(ap->a_vp);
		off_t cur = ap->a_uio->uio_offset;

		if (vp == un->un_uppervp) {
			if (cur > un->un_uppersz)
				union_newsize(ap->a_vp, cur, VNOVAL);
		} else {
			if (cur > un->un_lowersz)
				union_newsize(ap->a_vp, VNOVAL, cur);
		}
	}

	return (error);
}

int
union_write(v)
	void *v;
{
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
	int error;
	struct vnode *vp;
	struct union_node *un = VTOUNION(ap->a_vp);
	struct proc *p = curproc;

	vp = UPPERVP(ap->a_vp);
	if (vp == NULLVP)
		panic("union: missing upper layer in write");

	FIXUP(un, p);
	error = VOP_WRITE(vp, ap->a_uio, ap->a_ioflag, ap->a_cred);

	/*
	 * the size of the underlying object may be changed by the
	 * write.
	 */
	if (error == 0) {
		off_t cur = ap->a_uio->uio_offset;

		if (cur > un->un_uppersz)
			union_newsize(ap->a_vp, cur, VNOVAL);
	}

	return (error);
}

int
union_lease(v)
	void *v;
{
	struct vop_lease_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
		struct ucred *a_cred;
		int a_flag;
	} */ *ap = v;
	struct vnode *ovp = OTHERVP(ap->a_vp);

	ap->a_vp = ovp;
	return (VCALL(ovp, VOFFSET(vop_lease), ap));
}

int
union_ioctl(v)
	void *v;
{
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	register struct vnode *vp = OTHERVP(ap->a_vp);

	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_ioctl), ap));
}

int
union_poll(v)
	void *v;
{
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int  a_events;
		struct proc *a_p;
	} */ *ap = v;
	register struct vnode *vp = OTHERVP(ap->a_vp);

	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_poll), ap));
}

int
union_fsync(v)
	void *v;
{
	struct vop_fsync_args /* {
		struct vnode *a_vp;
		struct ucred *a_cred;
		int  a_waitfor;
		struct proc *a_p;
	} */ *ap = v;
	int error = 0;
	struct vnode *targetvp = OTHERVP(ap->a_vp);
	struct proc *p = ap->a_p;

#if 0
	/*
	 * If vinvalbuf is calling us, it's a "shallow fsync" -- don't
	 * bother syncing the underlying vnodes, since (a) they'll be
	 * fsync'ed when reclaimed and (b) we could deadlock if
	 * they're locked; otherwise, pass it through to the
	 * underlying layer.
	 */
	if (ap->a_flags & FSYNC_RECLAIM)
		return (0);
#endif

	if (targetvp != NULLVP) {
		int dolock = (targetvp == LOWERVP(ap->a_vp));

		if (dolock)
			vn_lock(targetvp, LK_EXCLUSIVE | LK_RETRY, p);
		else
			FIXUP(VTOUNION(ap->a_vp), p);
		error = VOP_FSYNC(targetvp, ap->a_cred, ap->a_waitfor, p);
		if (dolock)
			VOP_UNLOCK(targetvp, 0, p);
	}

	return (error);
}

int
union_remove(v)
	void *v;
{
	struct vop_remove_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
	int error;
	struct union_node *dun = VTOUNION(ap->a_dvp);
	struct union_node *un = VTOUNION(ap->a_vp);
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;

	if (dun->un_uppervp == NULLVP)
		panic("union remove: null upper vnode");

	if (un->un_uppervp != NULLVP) {
		struct vnode *dvp = dun->un_uppervp;
		struct vnode *vp = un->un_uppervp;

		FIXUP(dun, p);
		VREF(dvp);
		dun->un_flags |= UN_KLOCK;
		vput(ap->a_dvp);
		FIXUP(un, p);
		VREF(vp);
		un->un_flags |= UN_KLOCK;
		vput(ap->a_vp);

		if (union_dowhiteout(un, cnp->cn_cred, p))
			cnp->cn_flags |= DOWHITEOUT;
		error = VOP_REMOVE(dvp, vp, cnp);
		if (!error)
			union_removed_upper(un);
	} else {
		FIXUP(dun, p);
		error = union_mkwhiteout(
			MOUNTTOUNIONMOUNT(UNIONTOV(dun)->v_mount),
			dun->un_uppervp, ap->a_cnp, un->un_path);
		vput(ap->a_dvp);
		vput(ap->a_vp);
	}

	return (error);
}

int
union_link(v)
	void *v;
{
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
	int error = 0;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	struct union_node *dun;
	struct vnode *vp;
	struct vnode *dvp;

	dun = VTOUNION(ap->a_dvp);

#ifdef DIAGNOSTIC
	if (!(ap->a_cnp->cn_flags & LOCKPARENT)) {
		printf("union_link called without LOCKPARENT set!\n");
		error = EIO; /* need some error code for "caller is a bozo" */
	} else
#endif


	if (ap->a_dvp->v_op != ap->a_vp->v_op) {
		vp = ap->a_vp;
	} else {
		struct union_node *un = VTOUNION(ap->a_vp);
		if (un->un_uppervp == NULLVP) {
			/*
			 * Needs to be copied before we can link it.
			 */
			vn_lock(ap->a_vp, LK_EXCLUSIVE | LK_RETRY, p);
			if (dun->un_uppervp == un->un_dirvp) {
				dun->un_flags &= ~UN_ULOCK;
				VOP_UNLOCK(dun->un_uppervp, 0, p);
			}
			error = union_copyup(un, 1, cnp->cn_cred, p);
			if (dun->un_uppervp == un->un_dirvp) {
				/*
				 * During copyup, we dropped the lock on the
				 * dir and invalidated any saved namei lookup
				 * state for the directory we'll be entering
				 * the link in.  We need to re-run the lookup
				 * in that directory to reset any state needed
				 * for VOP_LINK.
				 * Call relookup on the union-layer to reset
				 * the state.
				 */
				vp = NULLVP;
				if (dun->un_uppervp == NULLVP)
					 panic("union: null upperdvp?");
				/*
				 * relookup starts with an unlocked node,
				 * and since LOCKPARENT is set returns
				 * the starting directory locked.
				 */
				VOP_UNLOCK(ap->a_dvp, 0, p);
				error = relookup(ap->a_dvp, &vp, ap->a_cnp);
				if (error) {
					vrele(ap->a_dvp);
					VOP_UNLOCK(ap->a_vp, 0, p);
					return EROFS;	/* ? */
				}
				if (vp != NULLVP) {
					/*
					 * The name we want to create has
					 * mysteriously appeared (a race?)
					 */
					error = EEXIST;
					VOP_UNLOCK(ap->a_vp, 0, p);
					goto croak;
				}
			}
			VOP_UNLOCK(ap->a_vp, 0, p);
		}
		vp = un->un_uppervp;
	}

	dvp = dun->un_uppervp;
	if (dvp == NULLVP)
		error = EROFS;

	if (error) {
croak:
		vput(ap->a_dvp);
		return (error);
	}

	FIXUP(dun, p);
	VREF(dvp);
	dun->un_flags |= UN_KLOCK;
	vput(ap->a_dvp);

	return (VOP_LINK(dvp, vp, cnp));
}

int
union_rename(v)
	void *v;
{
	struct vop_rename_args  /* {
		struct vnode *a_fdvp;
		struct vnode *a_fvp;
		struct componentname *a_fcnp;
		struct vnode *a_tdvp;
		struct vnode *a_tvp;
		struct componentname *a_tcnp;
	} */ *ap = v;
	int error;

	struct vnode *fdvp = ap->a_fdvp;
	struct vnode *fvp = ap->a_fvp;
	struct vnode *tdvp = ap->a_tdvp;
	struct vnode *tvp = ap->a_tvp;

	if (fdvp->v_op == union_vnodeop_p) {	/* always true */
		struct union_node *un = VTOUNION(fdvp);
		if (un->un_uppervp == NULLVP) {
			/*
			 * this should never happen in normal
			 * operation but might if there was
			 * a problem creating the top-level shadow
			 * directory.
			 */
			error = EXDEV;
			goto bad;
		}

		fdvp = un->un_uppervp;
		VREF(fdvp);
		vrele(ap->a_fdvp);
	}

	if (fvp->v_op == union_vnodeop_p) {	/* always true */
		struct union_node *un = VTOUNION(fvp);
		if (un->un_uppervp == NULLVP) {
			/* XXX: should do a copyup */
			error = EXDEV;
			goto bad;
		}

		if (un->un_lowervp != NULLVP)
			ap->a_fcnp->cn_flags |= DOWHITEOUT;

		fvp = un->un_uppervp;
		VREF(fvp);
		vrele(ap->a_fvp);
	}

	if (tdvp->v_op == union_vnodeop_p) {
		struct union_node *un = VTOUNION(tdvp);
		if (un->un_uppervp == NULLVP) {
			/*
			 * this should never happen in normal
			 * operation but might if there was
			 * a problem creating the top-level shadow
			 * directory.
			 */
			error = EXDEV;
			goto bad;
		}

		tdvp = un->un_uppervp;
		VREF(tdvp);
		un->un_flags |= UN_KLOCK;
		vput(ap->a_tdvp);
	}

	if (tvp != NULLVP && tvp->v_op == union_vnodeop_p) {
		struct union_node *un = VTOUNION(tvp);

		tvp = un->un_uppervp;
		if (tvp != NULLVP) {
			VREF(tvp);
			un->un_flags |= UN_KLOCK;
		}
		vput(ap->a_tvp);
	}

	return (VOP_RENAME(fdvp, fvp, ap->a_fcnp, tdvp, tvp, ap->a_tcnp));

bad:
	vrele(fdvp);
	vrele(fvp);
	vput(tdvp);
	if (tvp != NULLVP)
		vput(tvp);

	return (error);
}

int
union_mkdir(v)
	void *v;
{
	struct vop_mkdir_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_dvp);
	struct vnode *dvp = un->un_uppervp;
	struct proc *p = ap->a_cnp->cn_proc;
	struct componentname *cnp = ap->a_cnp;

	if (dvp != NULLVP) {
		int error;
		struct vnode *vp;

		FIXUP(un, p);
		VREF(dvp);
		un->un_flags |= UN_KLOCK;
		VOP_UNLOCK(ap->a_dvp, 0, p);
		error = VOP_MKDIR(dvp, &vp, cnp, ap->a_vap);
		if (error) {
			vrele(ap->a_dvp);
			return (error);
		}

		error = union_allocvp(ap->a_vpp, ap->a_dvp->v_mount, ap->a_dvp,
				NULLVP, cnp, vp, NULLVP, 1);
		vrele(ap->a_dvp);
		if (error)
			vput(vp);
		return (error);
	}

	vput(ap->a_dvp);
	return (EROFS);
}

int
union_rmdir(v)
	void *v;
{
	struct vop_rmdir_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
	int error;
	struct union_node *dun = VTOUNION(ap->a_dvp);
	struct union_node *un = VTOUNION(ap->a_vp);
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;

	if (dun->un_uppervp == NULLVP)
		panic("union rmdir: null upper vnode");

	if (un->un_uppervp != NULLVP) {
		struct vnode *dvp = dun->un_uppervp;
		struct vnode *vp = un->un_uppervp;

		FIXUP(dun, p);
		VREF(dvp);
		dun->un_flags |= UN_KLOCK;
		vput(ap->a_dvp);
		FIXUP(un, p);
		VREF(vp);
		un->un_flags |= UN_KLOCK;
		vput(ap->a_vp);

		if (union_dowhiteout(un, cnp->cn_cred, cnp->cn_proc))
			cnp->cn_flags |= DOWHITEOUT;
		error = VOP_RMDIR(dvp, vp, ap->a_cnp);
		if (!error)
			union_removed_upper(un);
	} else {
		FIXUP(dun, p);
		error = union_mkwhiteout(
			MOUNTTOUNIONMOUNT(UNIONTOV(dun)->v_mount),
			dun->un_uppervp, ap->a_cnp, un->un_path);
		vput(ap->a_dvp);
		vput(ap->a_vp);
	}

	return (error);
}

int
union_symlink(v)
	void *v;
{
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_dvp);
	struct vnode *dvp = un->un_uppervp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;

	if (dvp != NULLVP) {
		int error;

		FIXUP(un, p);
		VREF(dvp);
		un->un_flags |= UN_KLOCK;
		vput(ap->a_dvp);
		error = VOP_SYMLINK(dvp, ap->a_vpp, cnp, ap->a_vap,
		    ap->a_target);
		return (error);
	}

	vput(ap->a_dvp);
	return (EROFS);
}

/*
 * union_readdir works in concert with getdirentries and
 * readdir(3) to provide a list of entries in the unioned
 * directories.  getdirentries is responsible for walking
 * down the union stack.  readdir(3) is responsible for
 * eliminating duplicate names from the returned data stream.
 */
int
union_readdir(v)
	void *v;
{
	struct vop_readdir_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long *a_cookies;
		int a_ncookies;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_vp);
	struct vnode *uvp = un->un_uppervp;
	struct proc *p = curproc;

	if (uvp == NULLVP)
		return (0);

	FIXUP(un, p);
	ap->a_vp = uvp;
	return (VCALL(uvp, VOFFSET(vop_readdir), ap));
}

int
union_readlink(v)
	void *v;
{
	struct vop_readlink_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *ap = v;
	int error;
	struct vnode *vp = OTHERVP(ap->a_vp);
	int dolock = (vp == LOWERVP(ap->a_vp));
	struct proc *p = curproc;

	if (dolock)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	else
		FIXUP(VTOUNION(ap->a_vp), p);
	ap->a_vp = vp;
	error = VCALL(vp, VOFFSET(vop_readlink), ap);
	if (dolock)
		VOP_UNLOCK(vp, 0, p);

	return (error);
}

int
union_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;
	int error;
	struct vnode *vp = OTHERVP(ap->a_dvp);
	struct union_node *un = VTOUNION(ap->a_dvp);
	struct proc *p = ap->a_cnp->cn_proc;
	int islocked = un->un_flags & UN_LOCKED;
	int dolock = (vp == LOWERVP(ap->a_dvp));

	if (islocked) {
		if (dolock)
			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		else
			FIXUP(VTOUNION(ap->a_dvp), p);
	}
	ap->a_dvp = vp;
	error = VCALL(vp, VOFFSET(vop_abortop), ap);
	if (islocked && dolock)
		VOP_UNLOCK(vp, 0, p);

	return (error);
}

int
union_inactive(v)
	void *v;
{
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
	struct proc *p = ap->a_p;
	struct vnode **vpp;

	/*
	 * Do nothing (and _don't_ bypass).
	 * Wait to vrele lowervp until reclaim,
	 * so that until then our union_node is in the
	 * cache and reusable.
	 *
	 * NEEDSWORK: Someday, consider inactive'ing
	 * the lowervp and then trying to reactivate it
	 * with capabilities (v_id)
	 * like they do in the name lookup cache code.
	 * That's too much work for now.
	 */

	if (un->un_dircache != 0) {
		for (vpp = un->un_dircache; *vpp != NULLVP; vpp++)
			vrele(*vpp);
		free(un->un_dircache, M_TEMP);
		un->un_dircache = 0;
	}

	VOP_UNLOCK(vp, 0, p);

	if ((un->un_flags & UN_CACHED) == 0)
		vgone(vp);

	return (0);
}

int
union_reclaim(v)
	void *v;
{
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;

	union_freevp(ap->a_vp);

	return (0);
}

int
union_lock(v)
	void *v;
{
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	int flags = ap->a_flags;
	struct union_node *un;
	struct proc *p = ap->a_p;
	int error;
#ifdef DIAGNOSTIC
	int drain = 0;
#endif

#if 0
	genfs_nolock(ap);
#else
	vop_generic_lock(ap);
#endif
	/*
	 * Need to do real lockmgr-style locking here.
	 * in the mean time, draining won't work quite right,
	 * which could lead to a few race conditions.
	 * the following test was here, but is not quite right, we
	 * still need to take the lock:
	if ((flags & LK_TYPE_MASK) == LK_DRAIN)
		return (0);
	 */
	flags &= ~LK_INTERLOCK;

	un = VTOUNION(vp);
#ifdef DIAGNOSTIC
	if (un->un_flags & (UN_DRAINING|UN_DRAINED)) {
		if (un->un_flags & UN_DRAINED)
			panic("union: %p: warning: locking decommissioned lock", vp);
		if ((flags & LK_TYPE_MASK) != LK_RELEASE)
			panic("union: %p: non-release on draining lock: %d",
			    vp, flags & LK_TYPE_MASK);
		un->un_flags &= ~UN_DRAINING;
		if ((flags & LK_REENABLE) == 0)
			un->un_flags |= UN_DRAINED;
	}
#endif

	/*
	 * Don't pass DRAIN through to sub-vnode lock; keep track of
	 * DRAIN state at this level, and just get an exclusive lock
	 * on the underlying vnode.
	 */
	if ((flags & LK_TYPE_MASK) == LK_DRAIN) {
#ifdef DIAGNOSTIC
		drain = 1;
#endif
		flags = LK_EXCLUSIVE | (flags & ~LK_TYPE_MASK);
	}
start:
	un = VTOUNION(vp);

	if (un->un_uppervp != NULLVP) {
		if (((un->un_flags & UN_ULOCK) == 0) &&
		    (vp->v_usecount != 0)) {
			/*
			 * We MUST always use the order of: take upper
			 * vp lock, manipulate union node flags, drop
			 * upper vp lock.  This code must not be an
			 */
			error = vn_lock(un->un_uppervp, flags, p);
			if (error)
				return (error);
			un->un_flags |= UN_ULOCK;
		}
#ifdef DIAGNOSTIC
		if (un->un_flags & UN_KLOCK) {
			vprint("union: dangling klock", vp);
			panic("union: dangling upper lock (%p)", vp);
		}
#endif
	}

	/* XXX ignores LK_NOWAIT */
	if (un->un_flags & UN_LOCKED) {
#ifdef DIAGNOSTIC
		if (curproc && un->un_pid == curproc->p_pid &&
		    un->un_pid > -1 && curproc->p_pid > -1)
			panic("union: locking against myself");
#endif
		un->un_flags |= UN_WANTED;
		tsleep(&un->un_flags, PINOD, "unionlk2", 0);
		goto start;
	}

#ifdef DIAGNOSTIC
	if (curproc)
		un->un_pid = curproc->p_pid;
	else
		un->un_pid = -1;
	if (drain)
		un->un_flags |= UN_DRAINING;
#endif

	un->un_flags |= UN_LOCKED;
	return (0);
}

/*
 * When operations want to vput() a union node yet retain a lock on
 * the upper vnode (say, to do some further operations like link(),
 * mkdir(), ...), they set UN_KLOCK on the union node, then call
 * vput() which calls VOP_UNLOCK() and comes here.  union_unlock()
 * unlocks the union node (leaving the upper vnode alone), clears the
 * KLOCK flag, and then returns to vput().  The caller then does whatever
 * is left to do with the upper vnode, and ensures that it gets unlocked.
 *
 * If UN_KLOCK isn't set, then the upper vnode is unlocked here.
 */
int
union_unlock(v)
	void *v;
{
	struct vop_unlock_args /* {
		struct vnode *a_vp;
		int a_flags;
	} */ *ap = v;
	struct union_node *un = VTOUNION(ap->a_vp);
	struct proc *p = ap->a_p;

#ifdef DIAGNOSTIC
	if ((un->un_flags & UN_LOCKED) == 0)
		panic("union: unlock unlocked node");
	if (curproc && un->un_pid != curproc->p_pid &&
			curproc->p_pid > -1 && un->un_pid > -1)
		panic("union: unlocking other process's union node");
	if (un->un_flags & UN_DRAINED)
		panic("union: %p: warning: unlocking decommissioned lock", ap->a_vp);
#endif

	un->un_flags &= ~UN_LOCKED;

	if ((un->un_flags & (UN_ULOCK|UN_KLOCK)) == UN_ULOCK)
		VOP_UNLOCK(un->un_uppervp, 0, p);

	un->un_flags &= ~(UN_ULOCK|UN_KLOCK);

	if (un->un_flags & UN_WANTED) {
		un->un_flags &= ~UN_WANTED;
		wakeup(&un->un_flags);
	}

#ifdef DIAGNOSTIC
	un->un_pid = 0;
	if (un->un_flags & UN_DRAINING) {
		un->un_flags |= UN_DRAINED;
		un->un_flags &= ~UN_DRAINING;
	}
#endif

#if 0
	genfs_nounlock(ap);
#else
	vop_generic_unlock(ap);
#endif

	return (0);
}

int
union_bmap(v)
	void *v;
{
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
	int error;
	struct proc *p = curproc;
	struct vnode *vp = OTHERVP(ap->a_vp);
	int dolock = (vp == LOWERVP(ap->a_vp));

	if (dolock)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	else
		FIXUP(VTOUNION(ap->a_vp), p);
	ap->a_vp = vp;
	error = VCALL(vp, VOFFSET(vop_bmap), ap);
	if (dolock)
		VOP_UNLOCK(vp, 0, p);

	return (error);
}

int
union_print(v)
	void *v;
{
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;

	printf("\ttag VT_UNION, vp=%p, uppervp=%p, lowervp=%p\n",
	    vp, UPPERVP(vp), LOWERVP(vp));
	if (UPPERVP(vp) != NULLVP)
		vprint("union: upper", UPPERVP(vp));
	if (LOWERVP(vp) != NULLVP)
		vprint("union: lower", LOWERVP(vp));
	if (VTOUNION(vp)->un_dircache) {
		struct vnode **vpp;
		for (vpp = VTOUNION(vp)->un_dircache; *vpp != NULLVP; vpp++)
			vprint("dircache:", *vpp);
	}

	return (0);
}

int
union_islocked(v)
	void *v;
{
	struct vop_islocked_args /* {
		struct vnode *a_vp;
	} */ *ap = v;

	return ((VTOUNION(ap->a_vp)->un_flags & UN_LOCKED) ? 1 : 0);
}

int
union_pathconf(v)
	void *v;
{
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		int *a_retval;
	} */ *ap = v;
	int error;
	struct vnode *vp = OTHERVP(ap->a_vp);
	struct proc *p = curproc;
	int dolock = (vp == LOWERVP(ap->a_vp));

	if (dolock)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	else
		FIXUP(VTOUNION(ap->a_vp), p);
	ap->a_vp = vp;
	error = VCALL(vp, VOFFSET(vop_pathconf), ap);
	if (dolock)
		VOP_UNLOCK(vp, 0, p);

	return (error);
}

int
union_revoke(v)
	void *v;
{
	struct vop_revoke_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;

	if (UPPERVP(vp))
		VOP_REVOKE(UPPERVP(vp), ap->a_flags);
	if (LOWERVP(vp))
		VOP_REVOKE(LOWERVP(vp), ap->a_flags);
	vgone(vp);
	return (0);
}

int
union_advlock(v)
	void *v;
{
	struct vop_advlock_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_vp;
		caddr_t  a_id;
		int  a_op;
		struct flock *a_fl;
		int  a_flags;
	} */ *ap = v;
	struct vnode *ovp = OTHERVP(ap->a_vp);

	ap->a_vp = ovp;
	return (VCALL(ovp, VOFFSET(vop_advlock), ap));
}


/*
 * XXX - vop_strategy must be hand coded because it has no
 * vnode in its arguments.
 * This goes away with a merged VM/buffer cache.
 */
int
union_strategy(v)
	void *v;
{
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
	struct buf *bp = ap->a_bp;
	int error;
	struct vnode *savedvp;

	savedvp = bp->b_vp;
	bp->b_vp = OTHERVP(bp->b_vp);

#ifdef DIAGNOSTIC
	if (bp->b_vp == NULLVP)
		panic("union_strategy: nil vp");
	if (((bp->b_flags & B_READ) == 0) &&
	    (bp->b_vp == LOWERVP(savedvp)))
		panic("union_strategy: writing to lowervp");
#endif

	error = VOP_STRATEGY(bp);
	bp->b_vp = savedvp;

	return (error);
}
@


1.24
log
@useless casts
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.23 2004/04/25 03:21:19 jolan Exp $ */
@


1.23
log
@fix typos/spelling in comments, from pedro martelletto
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.23 2004/04/25 03:07:53 jolan Exp $ */
d1725 1
a1725 1
		tsleep((caddr_t)&un->un_flags, PINOD, "unionlk2", 0);
d1783 1
a1783 1
		wakeup((caddr_t)&un->un_flags);
@


1.22
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.21 2003/06/02 23:28:11 millert Exp $ */
d301 1
a301 1
	 * if that level comsumes additional pathnames,
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.20 2003/05/12 21:45:35 tedu Exp $ */
d73 1
a73 1
int union_select(void *);
d120 1
a120 1
	{ &vop_select_desc, union_select },		/* select */
d1076 1
a1076 1
union_select(v)
d1079 1
a1079 1
	struct vop_select_args /* {
d1081 1
a1081 3
		int  a_which;
		int  a_fflags;
		struct ucred *a_cred;
d1087 1
a1087 1
	return (VCALL(vp, VOFFSET(vop_select), ap));
@


1.20
log
@fix up locking and some issues with union.  derived from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@Use tsleep instead of sleep.
@
text
@d1 2
a2 2
/*	$OpenBSD: union_vnops.c,v 1.18 2002/03/14 01:27:08 millert Exp $	*/
/*	$NetBSD: union_vnops.c,v 1.30.4.1 1996/05/25 22:10:14 jtc Exp $	*/
d5 3
a7 3
 * Copyright (c) 1992, 1993, 1994 The Regents of the University of California.
 * Copyright (c) 1992, 1993, 1994 Jan-Simon Pendry.
 * All rights reserved.
d40 1
a40 1
 *	@@(#)union_vnops.c	8.22 (Berkeley) 12/10/94
d43 1
a49 1
#include <sys/types.h>
d56 5
a62 3
/*
 * Global vfs data structures
 */
d100 8
d146 9
a154 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d156 1
a156 1
struct vnodeopv_desc union_vnodeop_opv_desc =
d159 1
a159 1
#define FIXUP(un, p) { \
d161 1
a161 1
		union_fixup(un, p); \
a163 4
static void union_fixup(struct union_node *, struct proc *);
static int union_lookup1(struct vnode *, struct vnode **,
			      struct vnode **, struct componentname *);

d170 1
d212 1
a212 1
        error = VOP_LOOKUP(dvp, &tdvp, cnp);
d232 1
a232 1
	       (mp = dvp->v_mountedhere)) {
d236 1
a236 1
	
a238 1

d240 1
a240 2

		if (error) {
a241 1
		}
d285 1
a285 1
			VOP_UNLOCK(ap->a_dvp, 0, p, 0, p);
d290 5
d320 1
a320 1
			/* retain lock on underlying VP: */
d326 1
a344 4

		/*if (uppervp == upperdvp)
			dun->un_flags |= UN_KLOCK;*/

d356 1
a356 2
						     cnp->cn_cred,
						     cnp->cn_proc);
d431 13
d469 1
d503 1
a503 1
			      uppervp, lowervp, 1);
d515 3
a517 3
			cnp->cn_nameptr[0] == '.' &&
			*ap->a_vpp != dvp) {
			panic("union_lookup returning. (%x) not same as startdir (%x)",
a519 1

d536 1
a536 1
	struct vnode *dvp;
d540 1
a540 1
	if ((dvp = un->un_uppervp) != NULLVP) {
d555 2
a556 9
		error = union_allocvp(
				ap->a_vpp,
				mp,
				NULLVP,
				NULLVP,
				cnp,
				vp,
				NULLVP,
				1);
d576 1
a576 1
	struct proc *p = curproc;
d581 2
a582 2
	FIXUP(un, p);
	return (VOP_WHITEOUT(un->un_uppervp, ap->a_cnp, ap->a_flags));
d596 3
a598 2
	struct vnode *dvp;
	struct proc *p = ap->a_cnp->cn_proc;
d600 1
a600 1
	if ((dvp = un->un_uppervp) != NULLVP) {
d611 1
a611 1
		error = VOP_MKNOD(dvp, &vp, ap->a_cnp, ap->a_vap);
d615 4
a618 13
		if (vp != NULLVP) {
			error = union_allocvp(
					ap->a_vpp,
					mp,
					NULLVP,
					NULLVP,
					ap->a_cnp,
					vp,
					NULLVP,
					1);
			if (error)
				vput(vp);
		}
d663 1
a663 1
		 * Just open the lower vnode
d665 3
d675 6
d702 2
a703 1
	if ((vp = un->un_uppervp) == NULLVP) {
d711 2
a712 5
#ifdef UNION_DIAGNOSTIC
	/*
	 * A stranded union node may end up here with both vnodes NULL,
	 * in which case we don't do anything.
	 */
d714 2
a715 2
	    vprint("empty union vnode", vp);
	    panic("union_close empty vnode");
d742 2
a743 1
	struct union_node *un = VTOUNION(ap->a_vp);
a744 1
	struct vnode *vp;
d746 26
d775 2
a776 1
		return (VOP_ACCESS(vp, ap->a_mode, ap->a_cred, ap->a_p));
d781 2
a782 1
		error = VOP_ACCESS(vp, ap->a_mode, ap->a_cred, ap->a_p);
d784 4
a787 5
			struct union_mount *um = MOUNTTOUNIONMOUNT(ap->a_vp->v_mount);

			if (um->um_op == UNMNT_BELOW)
				error = VOP_ACCESS(vp, ap->a_mode,
						um->um_cred, ap->a_p);
d818 1
d826 5
d835 2
a836 1
	if ((vp = un->un_uppervp) != NULLVP) {
d858 2
a859 1
		vap = &va;
d871 16
a886 3
	if ((vap != ap->a_vap) && (vap->va_type == VDIR))
		ap->a_vap->va_nlink += vap->va_nlink;

d901 3
a903 1
	struct union_node *un = VTOUNION(ap->a_vp);
d907 26
d941 1
a941 1
		error = union_copyup(un, (ap->a_vap->va_size != 0),
d953 1
a953 1
		error = VOP_SETATTR(un->un_uppervp, ap->a_vap,
d955 2
a956 2
		if ((error == 0) && (ap->a_vap->va_size != VNOVAL))
			union_newsize(ap->a_vp, ap->a_vap->va_size, VNOVAL);
d1055 1
a1055 1
	register struct vnode *vp = OTHERVP(ap->a_vp);
d1057 2
a1058 2
	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_lease), ap));
d1110 12
d1129 1
a1129 2
		error = VOP_FSYNC(targetvp, ap->a_cred,
					ap->a_waitfor, ap->a_p);
a1136 4
/* a_dvp: directory in which to link
   a_vp: new target of the link
   a_cnp: name for the link
   */
d1149 2
a1150 1
	struct proc *p = ap->a_cnp->cn_proc;
a1157 1
		struct componentname *cnp = ap->a_cnp;
d1168 1
a1168 1
		if (union_dowhiteout(un, cnp->cn_cred, cnp->cn_proc))
a1184 4
/* a_dvp: directory in which to link
   a_vp: new target of the link
   a_cnp: name for the link
   */
d1195 2
d1198 1
a1199 2
	struct vnode *vp;
	struct proc *p = ap->a_cnp->cn_proc;
d1209 2
a1214 1

d1217 1
a1217 1
			 * needs to be copied up before we can link it.
d1221 2
a1222 1
				VOP_UNLOCK(ap->a_dvp, 0, p);
d1224 1
a1224 2
			error = union_copyup(un, 1, ap->a_cnp->cn_cred,
						ap->a_cnp->cn_proc);
d1226 2
a1227 1
				/* During copyup, we dropped the lock on the
d1233 10
a1242 2
				 * Call relookup on the union-layer to
				 * reset the state.
d1244 3
a1246 9
				vp  = NULLVP;
				if (dun->un_uppervp == NULLVP ||
				    /*
				     * relookup starts with an unlocked node,
				     * and since LOCKPARENT is set returns
				     * the starting directory locked.
				     */
				    (error = relookup(ap->a_dvp,
						      &dvp, ap->a_cnp))) {
d1249 1
a1249 1
					return EROFS;
d1251 5
a1255 3
				if (dvp != NULLVP) {
					/* The name we want to create has
					   mysteriously appeared (a race?) */
d1281 1
a1281 1
	return (VOP_LINK(dvp, vp, ap->a_cnp));
a1301 1
	struct union_node *unfile = (struct union_node *)0;
d1322 2
a1323 2
		unfile = VTOUNION(fvp);
		if (unfile->un_uppervp == NULLVP) {
d1329 1
a1329 1
		if (unfile->un_lowervp != NULLVP)
d1332 1
a1332 1
		fvp = unfile->un_uppervp;
d1334 1
a1334 1
		/* vrele(ap->a_fvp); */ /* hold for later */
d1347 1
a1347 1
			goto badrele;
a1363 7
#if 0
		/* XXX should we toss from the cache? */
		if (un->un_flags & UN_CACHED) {
			un->un_flags &= ~UN_CACHED;
			LIST_REMOVE(un, un_cache);
		}
#endif
d1367 1
a1367 5
	error = VOP_RENAME(fdvp, fvp, ap->a_fcnp, tdvp, tvp, ap->a_tcnp);
	if (!error && unfile)
	    union_removed_upper(unfile);
	vrele(ap->a_fvp);
	return error;
a1368 2
badrele:
	vrele(ap->a_fvp);
d1392 1
d1402 1
a1402 1
		error = VOP_MKDIR(dvp, &vp, ap->a_cnp, ap->a_vap);
d1408 2
a1409 9
		error = union_allocvp(
				ap->a_vpp,
				ap->a_dvp->v_mount,
				ap->a_dvp,
				NULLVP,
				ap->a_cnp,
				vp,
				NULLVP,
				1);
d1432 2
a1433 1
	struct proc *p = ap->a_cnp->cn_proc;
a1440 1
		struct componentname *cnp = ap->a_cnp;
d1453 1
a1453 1
		error = VOP_RMDIR(dvp, vp, cnp);
d1481 2
a1482 1
	struct proc *p = ap->a_cnp->cn_proc;
a1485 1
		struct vnode *vp;
d1491 2
a1492 3
		error = VOP_SYMLINK(dvp, &vp, ap->a_cnp,
					ap->a_vap, ap->a_target);
		*ap->a_vpp = NULLVP;
d1517 2
a1518 3
		int *a_ncookies;
		u_long **a_cookies;

d1520 2
a1521 2
	register struct union_node *un = VTOUNION(ap->a_vp);
	register struct vnode *vp;
d1523 2
a1524 1
	if ((vp = un->un_uppervp) == NULLVP)
d1528 2
a1529 2
	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_readdir), ap));
d1543 1
a1545 2
	int dolock = (vp == LOWERVP(ap->a_vp));

a1557 12
/*
 * When operations want to vput() a union node yet retain a lock on
 * the upper VP (say, to do some further operations like link(),
 * mkdir(), ...), they set UN_KLOCK on the union node, then call
 * vput() which calls VOP_UNLOCK(, 0, p) and comes here.  union_unlock()
 * unlocks the union node (leaving the upper VP alone), clears the
 * KLOCK flag, and then returns to vput().  The caller then does whatever
 * is left to do with the upper VP, and insures that it gets unlocked.
 *
 * If UN_KLOCK isn't set, then the upper VP is unlocked here.
 */

a1569 1

d1595 4
a1598 1
	struct union_node *un = VTOUNION(ap->a_vp);
d1613 6
a1618 8
#ifdef UNION_DIAGNOSTIC
	if (un->un_flags & UN_LOCKED)
		panic("union: inactivating locked node");
	if (un->un_flags & UN_ULOCK)
		panic("union: inactivating w/locked upper node");
#endif

	union_diruncache(un);
d1620 1
a1620 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
d1623 1
a1623 1
		vrecycle(ap->a_vp, (struct simplelock *)0, ap->a_p);
d1645 4
a1648 1
	struct vop_lock_args *ap = v;
d1650 1
d1653 4
a1656 2
	int    flags = ap->a_flags;
	int    error = 0;
d1658 3
d1662 1
d1674 25
d1700 1
a1700 1
 	un = VTOUNION(vp);
d1705 5
d1718 1
a1718 1
			panic("union: dangling upper lock (%lx)", vp);
d1721 1
a1721 1
 	}
d1723 1
d1727 1
a1727 1
			    un->un_pid > -1 && curproc->p_pid > -1)
d1731 1
a1731 1
		tsleep((caddr_t)un, PINOD, "unionlk", 0);
d1740 2
d1750 1
a1750 1
 * the upper VP (say, to do some further operations like link(),
d1752 2
a1753 2
 * vput() which calls VOP_UNLOCK(, 0, p) and comes here.  union_unlock()
 * unlocks the union node (leaving the upper VP alone), clears the
d1755 1
a1755 1
 * is left to do with the upper VP, and insures that it gets unlocked.
d1757 1
a1757 1
 * If UN_KLOCK isn't set, then the upper VP is unlocked here.
a1758 1

d1763 4
a1766 1
	struct vop_lock_args *ap = v;
d1776 2
d1789 1
a1789 1
		wakeup((caddr_t)un);
d1794 4
d1800 5
a1804 1
	vop_generic_unlock(v);
d1848 4
a1851 4
	if (UPPERVP(vp))
		vprint("uppervp", UPPERVP(vp));
	if (LOWERVP(vp))
		vprint("lowervp", LOWERVP(vp));
a1853 1

d1857 1
d1879 1
a1879 1
		register_t *a_retval;
d1908 1
a1908 1
 
a1913 1

d1929 1
a1929 1
	register struct vnode *vp = OTHERVP(ap->a_vp);
d1931 2
a1932 2
	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_advlock), ap));
a1967 1

@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.17 2001/12/19 08:58:06 art Exp $	*/
d1620 1
a1620 1
		sleep((caddr_t)un, PINOD);
@


1.17
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.15 2001/07/26 20:46:29 millert Exp $	*/
d62 35
a96 35
int union_lookup	__P((void *));
int union_create	__P((void *));
int union_whiteout	__P((void *));
int union_mknod		__P((void *));
int union_open		__P((void *));
int union_close		__P((void *));
int union_access	__P((void *));
int union_getattr	__P((void *));
int union_setattr	__P((void *));
int union_read		__P((void *));
int union_write		__P((void *));
int union_lease		__P((void *));
int union_ioctl		__P((void *));
int union_select	__P((void *));
int union_fsync		__P((void *));
int union_remove	__P((void *));
int union_link		__P((void *));
int union_rename	__P((void *));
int union_mkdir		__P((void *));
int union_rmdir		__P((void *));
int union_revoke       	__P((void *));
int union_symlink	__P((void *));
int union_readdir	__P((void *));
int union_readlink	__P((void *));
int union_abortop	__P((void *));
int union_inactive	__P((void *));
int union_reclaim	__P((void *));
int union_lock		__P((void *));
int union_unlock	__P((void *));
int union_bmap		__P((void *));
int union_print		__P((void *));
int union_islocked	__P((void *));
int union_pathconf	__P((void *));
int union_advlock	__P((void *));
int union_strategy	__P((void *));
d98 1
a98 1
int (**union_vnodeop_p) __P((void *));
d136 1
a136 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d146 3
a148 3
static void union_fixup __P((struct union_node *, struct proc *));
static int union_lookup1 __P((struct vnode *, struct vnode **,
			      struct vnode **, struct componentname *));
@


1.16
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@a96 1
int union_mmap		__P((void *));
d136 1
a136 2
	{ &vop_mmap_desc, union_mmap },
	{ NULL, NULL }
a1844 10
int
union_mmap(v)
	void *v;
{
	struct vop_mmap_args *ap = v;
	struct vnode *vp = OTHERVP(ap->a_vp);

	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_mmap), ap));
}@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.16 2001/12/04 22:44:32 art Exp $	*/
d62 36
a97 36
int union_lookup(void *);
int union_create(void *);
int union_whiteout(void *);
int union_mknod(void *);
int union_open(void *);
int union_close(void *);
int union_access(void *);
int union_getattr(void *);
int union_setattr(void *);
int union_read(void *);
int union_write(void *);
int union_lease(void *);
int union_ioctl(void *);
int union_select(void *);
int union_fsync(void *);
int union_remove(void *);
int union_link(void *);
int union_rename(void *);
int union_mkdir(void *);
int union_rmdir(void *);
int union_revoke(void *);
int union_symlink(void *);
int union_readdir(void *);
int union_readlink(void *);
int union_abortop(void *);
int union_inactive(void *);
int union_reclaim(void *);
int union_lock(void *);
int union_unlock(void *);
int union_bmap(void *);
int union_print(void *);
int union_islocked(void *);
int union_pathconf(void *);
int union_advlock(void *);
int union_strategy(void *);
int union_mmap(void *);
d99 1
a99 1
int (**union_vnodeop_p)(void *);
d148 3
a150 3
static void union_fixup(struct union_node *, struct proc *);
static int union_lookup1(struct vnode *, struct vnode **,
			      struct vnode **, struct componentname *);
d1622 1
a1622 1
		tsleep((caddr_t)un, PINOD, "unionlk", 0);
@


1.16.2.2
log
@misc minor cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.16.2.1 2002/06/11 03:30:21 art Exp $	*/
d1856 1
a1856 1
}
@


1.16.2.3
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: union_vnops.c,v 1.59 2002/09/27 15:37:48 provos Exp $	*/
d5 3
a7 3
 * Copyright (c) 1992, 1993, 1994, 1995 Jan-Simon Pendry.
 * Copyright (c) 1992, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
d40 1
a40 1
 *	@@(#)union_vnops.c	8.33 (Berkeley) 7/31/95
a42 1

d49 1
a55 5
#include <sys/lock.h>

#if 0
#include <miscfs/genfs/genfs.h>
#endif
d58 3
a98 8
static void union_fixup(struct union_node *, struct proc *);
static int union_lookup1(struct vnode *, struct vnode **,
	struct vnode **, struct componentname *);


/*
 * Global vfs data structures
 */
a137 8
#ifdef notdef
	{ &vop_blkatoff_desc, union_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, union_valloc },		/* valloc */
	{ &vop_vfree_desc, union_vfree },		/* vfree */
	{ &vop_truncate_desc, union_truncate },		/* truncate */
	{ &vop_update_desc, union_update },		/* update */
	{ &vop_bwrite_desc, union_bwrite },		/* bwrite */
#endif
d140 1
a140 1
const struct vnodeopv_desc union_vnodeop_opv_desc =
d143 1
a143 1
#define FIXUP(un, _p) { \
d145 1
a145 1
		union_fixup(un, _p); \
d148 4
a157 1

d199 1
a199 1
	error = VOP_LOOKUP(dvp, &tdvp, cnp);
d219 1
a219 1
		(mp = dvp->v_mountedhere)) {
d223 1
a223 1

d226 1
d228 2
a229 1
		if (error)
d231 1
d275 1
a275 1
			VOP_UNLOCK(ap->a_dvp, 0, p);
a279 5
	if ((cnp->cn_flags & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

d305 1
a305 1
			/* retain lock on underlying VP */
a310 1

d329 4
d344 2
a345 1
					cnp->cn_cred, cnp->cn_proc);
a419 13
	 * EJUSTRETURN is used by underlying filesystems to indicate that
	 * a directory modification op was started successfully.
	 * This will only happen in the upper layer, since
	 * the lower layer only does LOOKUPs.
	 * If this union is mounted read-only, bounce it now.
	 */

	if ((uerror == EJUSTRETURN) && (cnp->cn_flags & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    ((cnp->cn_nameiop == CREATE) || (cnp->cn_nameiop == RENAME)))
		uerror = EROFS;

	/*
a444 1

d478 1
a478 1
	    uppervp, lowervp, 1);
d490 3
a492 3
		    cnp->cn_nameptr[0] == '.' &&
		    *ap->a_vpp != dvp) {
			panic("union_lookup -> . (%p) != startdir (%p)",
d495 1
d512 1
a512 1
	struct vnode *dvp = un->un_uppervp;
d516 1
a516 1
	if (dvp != NULLVP) {
d531 9
a539 2
		error = union_allocvp(ap->a_vpp, mp, NULLVP, NULLVP, cnp, vp,
				NULLVP, 1);
d559 1
a559 1
	struct componentname *cnp = ap->a_cnp;
d564 2
a565 2
	FIXUP(un, curproc);
	return (VOP_WHITEOUT(un->un_uppervp, cnp, ap->a_flags));
d579 2
a580 3
	struct vnode *dvp = un->un_uppervp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d582 1
a582 1
	if (dvp != NULLVP) {
d593 1
a593 1
		error = VOP_MKNOD(dvp, &vp, cnp, ap->a_vap);
d597 13
a609 4
		error = union_allocvp(ap->a_vpp, mp, NULLVP, NULLVP,
		    cnp, vp, NULLVP, 1);
		if (error)
			vput(vp);
d654 1
a654 1
		 * Just open the lower vnode, but check for nodev mount flag
a655 3
		if ((tvp->v_type == VBLK || tvp->v_type == VCHR) &&
		    (ap->a_vp->v_mount->mnt_flag & MNT_NODEV))
			return ENXIO;
a662 6
	/*
	 * Just open the upper vnode, checking for nodev mount flag first
	 */
	if ((tvp->v_type == VBLK || tvp->v_type == VCHR) &&
	    (ap->a_vp->v_mount->mnt_flag & MNT_NODEV))
		return ENXIO;
d684 1
a684 2
	vp = un->un_uppervp;
	if (vp == NULLVP) {
d692 5
a696 2

#ifdef DIAGNOSTIC
d698 2
a699 2
		vprint("empty union vnode", vp);
		panic("union_close empty vnode");
d726 1
a726 2
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
d728 1
a729 26
	struct union_mount *um = MOUNTTOUNIONMOUNT(vp->v_mount);

	/*
	 * Disallow write attempts on read-only file systems;
	 * unless the file is a socket, fifo, or a block or
	 * character device resident on the file system.
	 */
	if (ap->a_mode & VWRITE) {
		switch (vp->v_type) {
		case VDIR:
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
			break;
		case VBAD:
		case VBLK:
		case VCHR:
		case VSOCK:
		case VFIFO:
		case VNON:
		default:
			break;
		}
	}

d733 1
a733 2
		ap->a_vp = vp;
		return (VCALL(vp, VOFFSET(vop_access), ap));
d738 1
a738 2
		ap->a_vp = vp;
		error = VCALL(vp, VOFFSET(vop_access), ap);
d740 5
a744 4
			if (um->um_op == UNMNT_BELOW) {
				ap->a_cred = um->um_cred;
				error = VCALL(vp, VOFFSET(vop_access), ap);
			}
a774 1

a781 5
	 *
	 * To make life more interesting, some filesystems don't keep
	 * track of link counts in the expected way, and return a
	 * link count of `1' for those directories; if either of the
	 * component directories returns a link count of `1', we return a 1.
d786 1
a786 2
	vp = un->un_uppervp;
	if (vp != NULLVP) {
d808 1
a808 2
		if (vp != NULLVP)
			vap = &va;
d820 3
a822 16
	if ((vap != ap->a_vap) && (vap->va_type == VDIR)) {
		/*
		 * Link count manipulation:
		 *	- If both return "2", return 2 (no subdirs)
		 *	- If one or the other return "1", return "1" (ENOCLUE)
		 */
		if ((ap->a_vap->va_nlink == 2) &&
		    (vap->va_nlink == 2))
			;
		else if (ap->a_vap->va_nlink != 1) {
			if (vap->va_nlink == 1)
				ap->a_vap->va_nlink = 1;
			else
				ap->a_vap->va_nlink += vap->va_nlink;
		}
	}
d837 1
a837 3
	struct vattr *vap = ap->a_vap;
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
a840 26
	if ((vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
	    vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_sec != VNOVAL ||
	    vap->va_mtime.tv_sec != VNOVAL || vap->va_mode != (mode_t)VNOVAL) &&
	    (vp->v_mount->mnt_flag & MNT_RDONLY))
		return (EROFS);
	if (vap->va_size != VNOVAL) {
		switch (vp->v_type) {
		case VDIR:
			return (EISDIR);
		case VCHR:
		case VBLK:
		case VSOCK:
		case VFIFO:
			break;
		case VREG:
		case VLNK:
 		default:
			/*
			 * Disallow write attempts if the filesystem is
			 * mounted read-only.
			 */
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
		}
	}

d849 1
a849 1
		error = union_copyup(un, (vap->va_size != 0),
d861 1
a861 1
		error = VOP_SETATTR(un->un_uppervp, vap,
d863 2
a864 2
		if ((error == 0) && (vap->va_size != VNOVAL))
			union_newsize(ap->a_vp, vap->va_size, VNOVAL);
d963 1
a963 1
	struct vnode *ovp = OTHERVP(ap->a_vp);
d965 2
a966 2
	ap->a_vp = ovp;
	return (VCALL(ovp, VOFFSET(vop_lease), ap));
a1017 12
#if 0
	/*
	 * If vinvalbuf is calling us, it's a "shallow fsync" -- don't
	 * bother syncing the underlying vnodes, since (a) they'll be
	 * fsync'ed when reclaimed and (b) we could deadlock if
	 * they're locked; otherwise, pass it through to the
	 * underlying layer.
	 */
	if (ap->a_flags & FSYNC_RECLAIM)
		return (0);
#endif

d1025 2
a1026 1
		error = VOP_FSYNC(targetvp, ap->a_cred, ap->a_waitfor, p);
d1034 4
d1050 1
a1050 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d1058 1
d1069 1
a1069 1
		if (union_dowhiteout(un, cnp->cn_cred, p))
d1086 4
a1099 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d1101 1
d1103 1
a1103 1
	struct vnode *dvp;
a1112 2


d1117 1
d1120 1
a1120 1
			 * Needs to be copied before we can link it.
d1124 1
a1124 2
				dun->un_flags &= ~UN_ULOCK;
				VOP_UNLOCK(dun->un_uppervp, 0, p);
d1126 2
a1127 1
			error = union_copyup(un, 1, cnp->cn_cred, p);
d1129 1
a1129 2
				/*
				 * During copyup, we dropped the lock on the
d1135 2
a1136 2
				 * Call relookup on the union-layer to reset
				 * the state.
d1138 9
a1146 11
				vp = NULLVP;
				if (dun->un_uppervp == NULLVP)
					 panic("union: null upperdvp?");
				/*
				 * relookup starts with an unlocked node,
				 * and since LOCKPARENT is set returns
				 * the starting directory locked.
				 */
				VOP_UNLOCK(ap->a_dvp, 0, p);
				error = relookup(ap->a_dvp, &vp, ap->a_cnp);
				if (error) {
d1149 1
a1149 1
					return EROFS;	/* ? */
d1151 3
a1153 5
				if (vp != NULLVP) {
					/*
					 * The name we want to create has
					 * mysteriously appeared (a race?)
					 */
d1179 1
a1179 1
	return (VOP_LINK(dvp, vp, cnp));
d1200 1
d1221 2
a1222 2
		struct union_node *un = VTOUNION(fvp);
		if (un->un_uppervp == NULLVP) {
d1228 1
a1228 1
		if (un->un_lowervp != NULLVP)
d1231 1
a1231 1
		fvp = un->un_uppervp;
d1233 1
a1233 1
		vrele(ap->a_fvp);
d1246 1
a1246 1
			goto bad;
d1263 7
d1273 5
a1277 1
	return (VOP_RENAME(fdvp, fvp, ap->a_fcnp, tdvp, tvp, ap->a_tcnp));
d1279 2
a1303 1
	struct componentname *cnp = ap->a_cnp;
d1313 1
a1313 1
		error = VOP_MKDIR(dvp, &vp, cnp, ap->a_vap);
d1319 9
a1327 2
		error = union_allocvp(ap->a_vpp, ap->a_dvp->v_mount, ap->a_dvp,
				NULLVP, cnp, vp, NULLVP, 1);
d1350 1
a1350 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d1358 1
d1371 1
a1371 1
		error = VOP_RMDIR(dvp, vp, ap->a_cnp);
d1399 1
a1399 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d1403 1
d1409 3
a1411 2
		error = VOP_SYMLINK(dvp, ap->a_vpp, cnp, ap->a_vap,
		    ap->a_target);
d1436 3
a1438 2
		u_long *a_cookies;
		int a_ncookies;
d1440 2
a1441 2
	struct union_node *un = VTOUNION(ap->a_vp);
	struct vnode *uvp = un->un_uppervp;
d1443 1
a1443 2

	if (uvp == NULLVP)
d1447 2
a1448 2
	ap->a_vp = uvp;
	return (VCALL(uvp, VOFFSET(vop_readdir), ap));
d1462 2
a1464 1
	struct proc *p = curproc;
d1478 12
d1502 1
d1528 1
a1528 4
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
	struct proc *p = ap->a_p;
	struct vnode **vpp;
d1543 8
a1550 6
	if (un->un_dircache != 0) {
		for (vpp = un->un_dircache; *vpp != NULLVP; vpp++)
			vrele(*vpp);
		free(un->un_dircache, M_TEMP);
		un->un_dircache = 0;
	}
d1552 1
a1552 1
	VOP_UNLOCK(vp, 0, p);
d1555 1
a1555 1
		vgone(vp);
d1577 1
a1577 4
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
	} */ *ap = v;
a1578 1
	int flags = ap->a_flags;
d1581 2
a1582 4
	int error;
#ifdef DIAGNOSTIC
	int drain = 0;
#endif
a1583 3
#if 0
	genfs_nolock(ap);
#else
a1584 1
#endif
a1595 25
	un = VTOUNION(vp);
#ifdef DIAGNOSTIC
	if (un->un_flags & (UN_DRAINING|UN_DRAINED)) {
		if (un->un_flags & UN_DRAINED)
			panic("union: %p: warning: locking decommissioned lock", vp);
		if ((flags & LK_TYPE_MASK) != LK_RELEASE)
			panic("union: %p: non-release on draining lock: %d",
			    vp, flags & LK_TYPE_MASK);
		un->un_flags &= ~UN_DRAINING;
		if ((flags & LK_REENABLE) == 0)
			un->un_flags |= UN_DRAINED;
	}
#endif

	/*
	 * Don't pass DRAIN through to sub-vnode lock; keep track of
	 * DRAIN state at this level, and just get an exclusive lock
	 * on the underlying vnode.
	 */
	if ((flags & LK_TYPE_MASK) == LK_DRAIN) {
#ifdef DIAGNOSTIC
		drain = 1;
#endif
		flags = LK_EXCLUSIVE | (flags & ~LK_TYPE_MASK);
	}
d1597 1
a1597 1
	un = VTOUNION(vp);
a1601 5
			/*
			 * We MUST always use the order of: take upper
			 * vp lock, manipulate union node flags, drop
			 * upper vp lock.  This code must not be an
			 */
d1610 1
a1610 1
			panic("union: dangling upper lock (%p)", vp);
d1613 1
a1613 1
	}
a1614 1
	/* XXX ignores LK_NOWAIT */
d1618 1
a1618 1
		    un->un_pid > -1 && curproc->p_pid > -1)
d1622 1
a1622 1
		tsleep((caddr_t)&un->un_flags, PINOD, "unionlk2", 0);
a1630 2
	if (drain)
		un->un_flags |= UN_DRAINING;
d1639 1
a1639 1
 * the upper vnode (say, to do some further operations like link(),
d1641 2
a1642 2
 * vput() which calls VOP_UNLOCK() and comes here.  union_unlock()
 * unlocks the union node (leaving the upper vnode alone), clears the
d1644 1
a1644 1
 * is left to do with the upper vnode, and ensures that it gets unlocked.
d1646 1
a1646 1
 * If UN_KLOCK isn't set, then the upper vnode is unlocked here.
d1648 1
d1653 1
a1653 4
	struct vop_unlock_args /* {
		struct vnode *a_vp;
		int a_flags;
	} */ *ap = v;
a1662 2
	if (un->un_flags & UN_DRAINED)
		panic("union: %p: warning: unlocking decommissioned lock", ap->a_vp);
d1674 1
a1674 1
		wakeup((caddr_t)&un->un_flags);
a1678 4
	if (un->un_flags & UN_DRAINING) {
		un->un_flags |= UN_DRAINED;
		un->un_flags &= ~UN_DRAINING;
	}
d1681 1
a1681 5
#if 0
	genfs_nounlock(ap);
#else
	vop_generic_unlock(ap);
#endif
d1725 4
a1728 4
	if (UPPERVP(vp) != NULLVP)
		vprint("union: upper", UPPERVP(vp));
	if (LOWERVP(vp) != NULLVP)
		vprint("union: lower", LOWERVP(vp));
d1731 1
a1734 1

d1756 1
a1756 1
		int *a_retval;
d1785 1
a1785 1

d1791 1
d1807 1
a1807 1
	struct vnode *ovp = OTHERVP(ap->a_vp);
d1809 2
a1810 2
	ap->a_vp = ovp;
	return (VCALL(ovp, VOFFSET(vop_advlock), ap));
@


1.16.2.4
log
@convert to genfs_nolock.  genfs_lock for kern and procfs
@
text
@d58 1
d60 1
d1660 1
d1662 3
d1802 1
d1804 3
@


1.15
log
@missed this in previous symlink/mknod backout
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.13 2001/06/23 02:14:26 csapuntz Exp $	*/
d97 1
d137 2
a138 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d1847 10
@


1.14
log
@change vop_symlink and vop_mknod to return vpp (the created node)
refed, so that the caller can actually use it.  update callers and
file systems that implement these vnode operations

ok'd by art
@
text
@d595 13
a607 11
		error = union_allocvp(
			ap->a_vpp,
			mp,
			NULLVP,
			NULLVP,
			ap->a_cnp,
			vp,
			NULLVP,
			1);
		if (error)
			vput(vp);
d1401 1
d1407 1
a1407 1
		error = VOP_SYMLINK(dvp, ap->a_vpp, ap->a_cnp,
d1409 1
@


1.13
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.12 1998/08/18 07:08:29 deraadt Exp $	*/
d595 11
a605 13
		if (vp != NULLVP) {
			error = union_allocvp(
					ap->a_vpp,
					mp,
					NULLVP,
					NULLVP,
					ap->a_cnp,
					vp,
					NULLVP,
					1);
			if (error)
				vput(vp);
		}
a1398 1
		struct vnode *vp;
d1404 1
a1404 1
		error = VOP_SYMLINK(dvp, &vp, ap->a_cnp,
a1405 1
		*ap->a_vpp = NULLVP;
@


1.12
log
@indent # properly; garnett@@bogus.cs.colorado.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.11 1998/08/06 19:34:51 csapuntz Exp $	*/
a75 1
int union_mmap		__P((void *));
a76 1
int union_seek		__P((void *));
a114 1
	{ &vop_mmap_desc, union_mmap },			/* mmap */
a115 1
	{ &vop_seek_desc, union_seek },			/* seek */
a135 8
#ifdef notdef
	{ &vop_blkatoff_desc, union_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, union_valloc },		/* valloc */
	{ &vop_vfree_desc, union_vfree },		/* vfree */
	{ &vop_truncate_desc, union_truncate },		/* truncate */
	{ &vop_update_desc, union_update },		/* update */
	{ &vop_bwrite_desc, union_bwrite },		/* bwrite */
#endif
a1002 16
union_mmap(v)
	void *v;
{
	struct vop_mmap_args /* {
		struct vnode *a_vp;
		int  a_fflags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	register struct vnode *vp = OTHERVP(ap->a_vp);

	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_mmap), ap));
}

int
a1029 16
}

int
union_seek(v)
	void *v;
{
	struct vop_seek_args /* {
		struct vnode *a_vp;
		off_t  a_oldoff;
		off_t  a_newoff;
		struct ucred *a_cred;
	} */ *ap = v;
	register struct vnode *vp = OTHERVP(ap->a_vp);

	ap->a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_seek), ap));
@


1.12.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.12 1998/08/18 07:08:29 deraadt Exp $	*/
d76 1
d78 1
d117 1
d119 1
d140 8
d1015 16
d1058 16
@


1.12.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.12.8.1 2001/07/04 10:49:21 niklas Exp $	*/
@


1.12.8.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 35
a96 35
int union_lookup(void *);
int union_create(void *);
int union_whiteout(void *);
int union_mknod(void *);
int union_open(void *);
int union_close(void *);
int union_access(void *);
int union_getattr(void *);
int union_setattr(void *);
int union_read(void *);
int union_write(void *);
int union_lease(void *);
int union_ioctl(void *);
int union_select(void *);
int union_fsync(void *);
int union_remove(void *);
int union_link(void *);
int union_rename(void *);
int union_mkdir(void *);
int union_rmdir(void *);
int union_revoke(void *);
int union_symlink(void *);
int union_readdir(void *);
int union_readlink(void *);
int union_abortop(void *);
int union_inactive(void *);
int union_reclaim(void *);
int union_lock(void *);
int union_unlock(void *);
int union_bmap(void *);
int union_print(void *);
int union_islocked(void *);
int union_pathconf(void *);
int union_advlock(void *);
int union_strategy(void *);
d98 1
a98 1
int (**union_vnodeop_p)(void *);
d136 1
a136 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d146 3
a148 3
static void union_fixup(struct union_node *, struct proc *);
static int union_lookup1(struct vnode *, struct vnode **,
			      struct vnode **, struct componentname *);
@


1.12.8.4
log
@Sync the SMP branch with 3.3
@
text
@d1620 1
a1620 1
		tsleep((caddr_t)un, PINOD, "unionlk", 0);
@


1.12.8.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: union_vnops.c,v 1.59 2002/09/27 15:37:48 provos Exp $	*/
d5 3
a7 3
 * Copyright (c) 1992, 1993, 1994, 1995 Jan-Simon Pendry.
 * Copyright (c) 1992, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
d40 1
a40 1
 *	@@(#)union_vnops.c	8.33 (Berkeley) 7/31/95
a42 1

d49 1
a55 5
#include <sys/lock.h>

#if 0
#include <miscfs/genfs/genfs.h>
#endif
d58 3
a97 8
static void union_fixup(struct union_node *, struct proc *);
static int union_lookup1(struct vnode *, struct vnode **,
	struct vnode **, struct componentname *);


/*
 * Global vfs data structures
 */
d136 1
a136 9
#ifdef notdef
	{ &vop_blkatoff_desc, union_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, union_valloc },		/* valloc */
	{ &vop_vfree_desc, union_vfree },		/* vfree */
	{ &vop_truncate_desc, union_truncate },		/* truncate */
	{ &vop_update_desc, union_update },		/* update */
	{ &vop_bwrite_desc, union_bwrite },		/* bwrite */
#endif
	{ NULL, NULL }
d138 1
a138 1
const struct vnodeopv_desc union_vnodeop_opv_desc =
d141 1
a141 1
#define FIXUP(un, _p) { \
d143 1
a143 1
		union_fixup(un, _p); \
d146 4
a155 1

d197 1
a197 1
	error = VOP_LOOKUP(dvp, &tdvp, cnp);
d217 1
a217 1
		(mp = dvp->v_mountedhere)) {
d221 1
a221 1

d224 1
d226 2
a227 1
		if (error)
d229 1
d273 1
a273 1
			VOP_UNLOCK(ap->a_dvp, 0, p);
a277 5
	if ((cnp->cn_flags & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

d303 1
a303 1
			/* retain lock on underlying VP */
a308 1

d327 4
d342 2
a343 1
					cnp->cn_cred, cnp->cn_proc);
a417 13
	 * EJUSTRETURN is used by underlying filesystems to indicate that
	 * a directory modification op was started successfully.
	 * This will only happen in the upper layer, since
	 * the lower layer only does LOOKUPs.
	 * If this union is mounted read-only, bounce it now.
	 */

	if ((uerror == EJUSTRETURN) && (cnp->cn_flags & ISLASTCN) &&
	    (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    ((cnp->cn_nameiop == CREATE) || (cnp->cn_nameiop == RENAME)))
		uerror = EROFS;

	/*
a442 1

d476 1
a476 1
	    uppervp, lowervp, 1);
d488 3
a490 3
		    cnp->cn_nameptr[0] == '.' &&
		    *ap->a_vpp != dvp) {
			panic("union_lookup -> . (%p) != startdir (%p)",
d493 1
d510 1
a510 1
	struct vnode *dvp = un->un_uppervp;
d514 1
a514 1
	if (dvp != NULLVP) {
d529 9
a537 2
		error = union_allocvp(ap->a_vpp, mp, NULLVP, NULLVP, cnp, vp,
				NULLVP, 1);
d557 1
a557 1
	struct componentname *cnp = ap->a_cnp;
d562 2
a563 2
	FIXUP(un, curproc);
	return (VOP_WHITEOUT(un->un_uppervp, cnp, ap->a_flags));
d577 2
a578 3
	struct vnode *dvp = un->un_uppervp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d580 1
a580 1
	if (dvp != NULLVP) {
d591 1
a591 1
		error = VOP_MKNOD(dvp, &vp, cnp, ap->a_vap);
d595 13
a607 4
		error = union_allocvp(ap->a_vpp, mp, NULLVP, NULLVP,
		    cnp, vp, NULLVP, 1);
		if (error)
			vput(vp);
d652 1
a652 1
		 * Just open the lower vnode, but check for nodev mount flag
a653 3
		if ((tvp->v_type == VBLK || tvp->v_type == VCHR) &&
		    (ap->a_vp->v_mount->mnt_flag & MNT_NODEV))
			return ENXIO;
a660 6
	/*
	 * Just open the upper vnode, checking for nodev mount flag first
	 */
	if ((tvp->v_type == VBLK || tvp->v_type == VCHR) &&
	    (ap->a_vp->v_mount->mnt_flag & MNT_NODEV))
		return ENXIO;
d682 1
a682 2
	vp = un->un_uppervp;
	if (vp == NULLVP) {
d690 5
a694 2

#ifdef DIAGNOSTIC
d696 2
a697 2
		vprint("empty union vnode", vp);
		panic("union_close empty vnode");
d724 1
a724 2
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
d726 1
a727 26
	struct union_mount *um = MOUNTTOUNIONMOUNT(vp->v_mount);

	/*
	 * Disallow write attempts on read-only file systems;
	 * unless the file is a socket, fifo, or a block or
	 * character device resident on the file system.
	 */
	if (ap->a_mode & VWRITE) {
		switch (vp->v_type) {
		case VDIR:
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
			break;
		case VBAD:
		case VBLK:
		case VCHR:
		case VSOCK:
		case VFIFO:
		case VNON:
		default:
			break;
		}
	}

d731 1
a731 2
		ap->a_vp = vp;
		return (VCALL(vp, VOFFSET(vop_access), ap));
d736 1
a736 2
		ap->a_vp = vp;
		error = VCALL(vp, VOFFSET(vop_access), ap);
d738 5
a742 4
			if (um->um_op == UNMNT_BELOW) {
				ap->a_cred = um->um_cred;
				error = VCALL(vp, VOFFSET(vop_access), ap);
			}
a772 1

a779 5
	 *
	 * To make life more interesting, some filesystems don't keep
	 * track of link counts in the expected way, and return a
	 * link count of `1' for those directories; if either of the
	 * component directories returns a link count of `1', we return a 1.
d784 1
a784 2
	vp = un->un_uppervp;
	if (vp != NULLVP) {
d806 1
a806 2
		if (vp != NULLVP)
			vap = &va;
d818 3
a820 16
	if ((vap != ap->a_vap) && (vap->va_type == VDIR)) {
		/*
		 * Link count manipulation:
		 *	- If both return "2", return 2 (no subdirs)
		 *	- If one or the other return "1", return "1" (ENOCLUE)
		 */
		if ((ap->a_vap->va_nlink == 2) &&
		    (vap->va_nlink == 2))
			;
		else if (ap->a_vap->va_nlink != 1) {
			if (vap->va_nlink == 1)
				ap->a_vap->va_nlink = 1;
			else
				ap->a_vap->va_nlink += vap->va_nlink;
		}
	}
d835 1
a835 3
	struct vattr *vap = ap->a_vap;
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
a838 26
	if ((vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
	    vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_sec != VNOVAL ||
	    vap->va_mtime.tv_sec != VNOVAL || vap->va_mode != (mode_t)VNOVAL) &&
	    (vp->v_mount->mnt_flag & MNT_RDONLY))
		return (EROFS);
	if (vap->va_size != VNOVAL) {
		switch (vp->v_type) {
		case VDIR:
			return (EISDIR);
		case VCHR:
		case VBLK:
		case VSOCK:
		case VFIFO:
			break;
		case VREG:
		case VLNK:
 		default:
			/*
			 * Disallow write attempts if the filesystem is
			 * mounted read-only.
			 */
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
		}
	}

d847 1
a847 1
		error = union_copyup(un, (vap->va_size != 0),
d859 1
a859 1
		error = VOP_SETATTR(un->un_uppervp, vap,
d861 2
a862 2
		if ((error == 0) && (vap->va_size != VNOVAL))
			union_newsize(ap->a_vp, vap->va_size, VNOVAL);
d961 1
a961 1
	struct vnode *ovp = OTHERVP(ap->a_vp);
d963 2
a964 2
	ap->a_vp = ovp;
	return (VCALL(ovp, VOFFSET(vop_lease), ap));
a1015 12
#if 0
	/*
	 * If vinvalbuf is calling us, it's a "shallow fsync" -- don't
	 * bother syncing the underlying vnodes, since (a) they'll be
	 * fsync'ed when reclaimed and (b) we could deadlock if
	 * they're locked; otherwise, pass it through to the
	 * underlying layer.
	 */
	if (ap->a_flags & FSYNC_RECLAIM)
		return (0);
#endif

d1023 2
a1024 1
		error = VOP_FSYNC(targetvp, ap->a_cred, ap->a_waitfor, p);
d1032 4
d1048 1
a1048 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d1056 1
d1067 1
a1067 1
		if (union_dowhiteout(un, cnp->cn_cred, p))
d1084 4
a1097 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d1099 1
d1101 1
a1101 1
	struct vnode *dvp;
a1110 2


d1115 1
d1118 1
a1118 1
			 * Needs to be copied before we can link it.
d1122 1
a1122 2
				dun->un_flags &= ~UN_ULOCK;
				VOP_UNLOCK(dun->un_uppervp, 0, p);
d1124 2
a1125 1
			error = union_copyup(un, 1, cnp->cn_cred, p);
d1127 1
a1127 2
				/*
				 * During copyup, we dropped the lock on the
d1133 2
a1134 10
				 * Call relookup on the union-layer to reset
				 * the state.
				 */
				vp = NULLVP;
				if (dun->un_uppervp == NULLVP)
					 panic("union: null upperdvp?");
				/*
				 * relookup starts with an unlocked node,
				 * and since LOCKPARENT is set returns
				 * the starting directory locked.
d1136 9
a1144 3
				VOP_UNLOCK(ap->a_dvp, 0, p);
				error = relookup(ap->a_dvp, &vp, ap->a_cnp);
				if (error) {
d1147 1
a1147 1
					return EROFS;	/* ? */
d1149 3
a1151 5
				if (vp != NULLVP) {
					/*
					 * The name we want to create has
					 * mysteriously appeared (a race?)
					 */
d1177 1
a1177 1
	return (VOP_LINK(dvp, vp, cnp));
d1198 1
d1219 2
a1220 2
		struct union_node *un = VTOUNION(fvp);
		if (un->un_uppervp == NULLVP) {
d1226 1
a1226 1
		if (un->un_lowervp != NULLVP)
d1229 1
a1229 1
		fvp = un->un_uppervp;
d1231 1
a1231 1
		vrele(ap->a_fvp);
d1244 1
a1244 1
			goto bad;
d1261 7
d1271 5
a1275 1
	return (VOP_RENAME(fdvp, fvp, ap->a_fcnp, tdvp, tvp, ap->a_tcnp));
d1277 2
a1301 1
	struct componentname *cnp = ap->a_cnp;
d1311 1
a1311 1
		error = VOP_MKDIR(dvp, &vp, cnp, ap->a_vap);
d1317 9
a1325 2
		error = union_allocvp(ap->a_vpp, ap->a_dvp->v_mount, ap->a_dvp,
				NULLVP, cnp, vp, NULLVP, 1);
d1348 1
a1348 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d1356 1
d1369 1
a1369 1
		error = VOP_RMDIR(dvp, vp, ap->a_cnp);
d1397 1
a1397 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d1401 1
d1407 3
a1409 2
		error = VOP_SYMLINK(dvp, ap->a_vpp, cnp, ap->a_vap,
		    ap->a_target);
d1434 3
a1436 2
		u_long *a_cookies;
		int a_ncookies;
d1438 2
a1439 2
	struct union_node *un = VTOUNION(ap->a_vp);
	struct vnode *uvp = un->un_uppervp;
d1441 1
a1441 2

	if (uvp == NULLVP)
d1445 2
a1446 2
	ap->a_vp = uvp;
	return (VCALL(uvp, VOFFSET(vop_readdir), ap));
d1460 2
a1462 1
	struct proc *p = curproc;
d1476 12
d1500 1
d1526 1
a1526 4
	struct vnode *vp = ap->a_vp;
	struct union_node *un = VTOUNION(vp);
	struct proc *p = ap->a_p;
	struct vnode **vpp;
d1541 8
a1548 6
	if (un->un_dircache != 0) {
		for (vpp = un->un_dircache; *vpp != NULLVP; vpp++)
			vrele(*vpp);
		free(un->un_dircache, M_TEMP);
		un->un_dircache = 0;
	}
d1550 1
a1550 1
	VOP_UNLOCK(vp, 0, p);
d1553 1
a1553 1
		vgone(vp);
d1575 1
a1575 4
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
	} */ *ap = v;
a1576 1
	int flags = ap->a_flags;
d1579 2
a1580 4
	int error;
#ifdef DIAGNOSTIC
	int drain = 0;
#endif
a1581 3
#if 0
	genfs_nolock(ap);
#else
a1582 1
#endif
a1593 25
	un = VTOUNION(vp);
#ifdef DIAGNOSTIC
	if (un->un_flags & (UN_DRAINING|UN_DRAINED)) {
		if (un->un_flags & UN_DRAINED)
			panic("union: %p: warning: locking decommissioned lock", vp);
		if ((flags & LK_TYPE_MASK) != LK_RELEASE)
			panic("union: %p: non-release on draining lock: %d",
			    vp, flags & LK_TYPE_MASK);
		un->un_flags &= ~UN_DRAINING;
		if ((flags & LK_REENABLE) == 0)
			un->un_flags |= UN_DRAINED;
	}
#endif

	/*
	 * Don't pass DRAIN through to sub-vnode lock; keep track of
	 * DRAIN state at this level, and just get an exclusive lock
	 * on the underlying vnode.
	 */
	if ((flags & LK_TYPE_MASK) == LK_DRAIN) {
#ifdef DIAGNOSTIC
		drain = 1;
#endif
		flags = LK_EXCLUSIVE | (flags & ~LK_TYPE_MASK);
	}
d1595 1
a1595 1
	un = VTOUNION(vp);
a1599 5
			/*
			 * We MUST always use the order of: take upper
			 * vp lock, manipulate union node flags, drop
			 * upper vp lock.  This code must not be an
			 */
d1608 1
a1608 1
			panic("union: dangling upper lock (%p)", vp);
d1611 1
a1611 1
	}
a1612 1
	/* XXX ignores LK_NOWAIT */
d1616 1
a1616 1
		    un->un_pid > -1 && curproc->p_pid > -1)
d1620 1
a1620 1
		tsleep((caddr_t)&un->un_flags, PINOD, "unionlk2", 0);
a1628 2
	if (drain)
		un->un_flags |= UN_DRAINING;
d1637 1
a1637 1
 * the upper vnode (say, to do some further operations like link(),
d1639 2
a1640 2
 * vput() which calls VOP_UNLOCK() and comes here.  union_unlock()
 * unlocks the union node (leaving the upper vnode alone), clears the
d1642 1
a1642 1
 * is left to do with the upper vnode, and ensures that it gets unlocked.
d1644 1
a1644 1
 * If UN_KLOCK isn't set, then the upper vnode is unlocked here.
d1646 1
d1651 1
a1651 4
	struct vop_unlock_args /* {
		struct vnode *a_vp;
		int a_flags;
	} */ *ap = v;
a1660 2
	if (un->un_flags & UN_DRAINED)
		panic("union: %p: warning: unlocking decommissioned lock", ap->a_vp);
d1672 1
a1672 1
		wakeup((caddr_t)&un->un_flags);
a1676 4
	if (un->un_flags & UN_DRAINING) {
		un->un_flags |= UN_DRAINED;
		un->un_flags &= ~UN_DRAINING;
	}
d1679 1
a1679 5
#if 0
	genfs_nounlock(ap);
#else
	vop_generic_unlock(ap);
#endif
d1723 4
a1726 4
	if (UPPERVP(vp) != NULLVP)
		vprint("union: upper", UPPERVP(vp));
	if (LOWERVP(vp) != NULLVP)
		vprint("union: lower", LOWERVP(vp));
d1729 1
a1732 1

d1754 1
a1754 1
		int *a_retval;
d1783 1
a1783 1

d1789 1
d1805 1
a1805 1
	struct vnode *ovp = OTHERVP(ap->a_vp);
d1807 2
a1808 2
	ap->a_vp = ovp;
	return (VCALL(ovp, VOFFSET(vop_advlock), ap));
d1844 1
@


1.12.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.12.8.5 2003/05/16 00:29:43 niklas Exp $ */
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.8.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d73 1
a73 1
int union_poll(void *);
d120 1
a120 1
	{ &vop_poll_desc, union_poll },			/* poll */
d1076 1
a1076 1
union_poll(v)
d1079 1
a1079 1
	struct vop_poll_args /* {
d1081 3
a1083 1
		int  a_events;
d1089 1
a1089 1
	return (VCALL(vp, VOFFSET(vop_poll), ap));
@


1.12.8.8
log
@Merge with the trunk
@
text
@d301 1
a301 1
	 * if that level consumes additional pathnames,
d1725 1
a1725 1
		tsleep(&un->un_flags, PINOD, "unionlk2", 0);
d1783 1
a1783 1
		wakeup(&un->un_flags);
@


1.11
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.10 1998/07/13 02:52:01 csapuntz Exp $	*/
d1647 1
a1647 1
 			un->un_flags |= UN_ULOCK;
d1654 1
a1654 1
 #endif
@


1.10
log
@

Fix locking discipline snafu with UNIONFS. Thanks to Don Schmid (yensid@@imsa.edu) for the original fix and Todd Miller.
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.9 1997/11/06 05:58:54 csapuntz Exp $	*/
d1626 1
a1626 1
	vop_nolock(ap);
d1723 1
a1723 1
	vop_nounlock(v);
@


1.9
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.8 1997/10/06 21:04:51 deraadt Exp $	*/
d1594 2
d1597 1
a1597 1
		vgone(ap->a_vp);
@


1.8
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.6 1996/12/08 17:40:29 kstailey Exp $	*/
d84 1
d128 1
d153 1
a153 1
#define FIXUP(un) { \
d155 1
a155 1
		union_fixup(un); \
d158 1
a158 1
static void union_fixup __P((struct union_node *));
d164 1
a164 1
union_fixup(un)
d166 1
d168 1
a168 2

	VOP_LOCK(un->un_uppervp);
d179 1
d205 1
a205 1
			VOP_LOCK(dvp);
d219 1
a219 1
		VOP_LOCK(dvp);
d231 1
a231 3
		if (mp->mnt_flag & MNT_MLOCK) {
			mp->mnt_flag |= MNT_MWAIT;
			sleep((caddr_t) mp, PVFS);
d233 5
a237 1
		}
d239 1
a239 2
		if ((error = VFS_ROOT(mp, &tdvp)) != 0) {
			vput(dvp);
a242 1
		vput(dvp);
d266 1
d283 1
a283 1
		VOP_LOCK(dvp);
d285 1
a285 1
			VOP_UNLOCK(ap->a_dvp);
d305 1
a305 1
		FIXUP(dun);
d317 1
a317 1
			VOP_UNLOCK(dvp);
d337 1
a337 1
			VOP_LOCK(dvp);
d374 1
a374 1
		VOP_LOCK(lowerdvp);
d399 1
a399 1
			VOP_UNLOCK(lowerdvp);
d420 1
a420 1
				VOP_LOCK(lowervp);
d469 1
a469 1
			VOP_UNLOCK(upperdvp);
d471 1
a471 1
			VOP_LOCK(upperdvp);
d485 1
a485 1
		VOP_UNLOCK(lowervp);
d498 1
a498 1
				VOP_UNLOCK(dvp);
d523 2
d531 1
a531 1
		FIXUP(un);
d537 1
a537 1
		error = VOP_CREATE(dvp, &vp, ap->a_cnp, ap->a_vap);
d546 1
a546 1
				ap->a_cnp,
d569 1
d574 1
a574 1
	FIXUP(un);
d590 1
d597 1
a597 1
		FIXUP(un);
d667 1
a667 1
		VOP_LOCK(tvp);
d669 1
a669 1
		VOP_UNLOCK(tvp);
d674 1
a674 1
	FIXUP(un);
d739 1
d742 1
a742 1
		FIXUP(un);
d747 1
a747 1
		VOP_LOCK(vp);
d756 1
a756 1
		VOP_UNLOCK(vp);
d783 1
a783 1

d806 1
a806 1
			FIXUP(un);
d848 1
d870 1
a870 1
		FIXUP(un);
d895 1
d898 1
a898 1
		VOP_LOCK(vp);
d900 1
a900 1
		FIXUP(VTOUNION(ap->a_vp));
d903 1
a903 1
		VOP_UNLOCK(vp);
d940 1
d946 1
a946 1
	FIXUP(un);
d1042 1
d1048 1
a1048 1
			VOP_LOCK(targetvp);
d1050 1
a1050 1
			FIXUP(VTOUNION(ap->a_vp));
d1054 1
a1054 1
			VOP_UNLOCK(targetvp);
d1092 1
d1102 1
a1102 1
		FIXUP(dun);
d1106 1
a1106 1
		FIXUP(un);
d1117 1
a1117 1
		FIXUP(dun);
d1145 1
d1164 1
a1164 1
			VOP_LOCK(ap->a_vp);
d1166 1
a1166 1
				VOP_UNLOCK(ap->a_dvp);
d1190 1
a1190 1
					VOP_UNLOCK(ap->a_vp);
d1197 1
a1197 1
					VOP_UNLOCK(ap->a_vp);
d1201 1
a1201 1
			VOP_UNLOCK(ap->a_vp);
d1216 1
a1216 1
	FIXUP(dun);
d1345 1
d1351 1
a1351 1
		FIXUP(un);
d1354 1
a1354 1
		VOP_UNLOCK(ap->a_dvp);
d1392 1
d1402 1
a1402 1
		FIXUP(dun);
d1406 1
a1406 1
		FIXUP(un);
d1417 1
a1417 1
		FIXUP(dun);
d1441 1
d1447 1
a1447 1
		FIXUP(un);
d1478 3
a1480 2
		u_long *a_cookies;
		int a_ncookies;
d1484 1
a1484 1

d1488 1
a1488 1
	FIXUP(un);
d1504 2
d1509 1
a1509 1
		VOP_LOCK(vp);
d1511 1
a1511 1
		FIXUP(VTOUNION(ap->a_vp));
d1515 1
a1515 1
		VOP_UNLOCK(vp);
d1524 1
a1524 1
 * vput() which calls VOP_UNLOCK() and comes here.  union_unlock()
d1543 2
d1550 1
a1550 1
			VOP_LOCK(vp);
d1552 1
a1552 1
			FIXUP(VTOUNION(ap->a_dvp));
d1557 1
a1557 1
		VOP_UNLOCK(vp);
d1568 1
d1620 15
d1637 1
a1637 6
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		sleep((caddr_t)vp, PINOD);
	}

	un = VTOUNION(vp);
d1642 4
a1645 8
			/*
			 * We MUST always use the order of: take upper
			 * vp lock, manipulate union node flags, drop
			 * upper vp lock.  This code must not be an
			 * exception.
			 */
			VOP_LOCK(un->un_uppervp);
			un->un_flags |= UN_ULOCK;
d1649 2
a1650 2
			vprint("dangling upper lock", vp);
			panic("union: dangling upper lock");
d1652 2
a1653 2
#endif
	}
d1681 1
a1681 1
 * vput() which calls VOP_UNLOCK() and comes here.  union_unlock()
d1695 1
d1708 1
a1708 1
		VOP_UNLOCK(un->un_uppervp);
d1721 2
d1738 1
d1743 1
a1743 1
		VOP_LOCK(vp);
d1745 1
a1745 1
		FIXUP(VTOUNION(ap->a_vp));
d1749 1
a1749 1
		VOP_UNLOCK(vp);
d1800 1
d1804 1
a1804 1
		VOP_LOCK(vp);
d1806 1
a1806 1
		FIXUP(VTOUNION(ap->a_vp));
d1810 1
a1810 1
		VOP_UNLOCK(vp);
d1813 20
@


1.7
log
@VFS Lite2 Changes
@
text
@d1 1
a1 1
/*	$openbsd: union_vnops.c,v 1.6 1996/12/08 17:40:29 kstailey Exp $	*/
a83 1
int union_revoke       	__P((void *));
a126 1
	{ &vop_revoke_desc, union_revoke },             /* revoke */
d151 1
a151 1
#define FIXUP(un, p) { \
d153 1
a153 1
		union_fixup(un, p); \
d156 1
a156 1
static void union_fixup __P((struct union_node *, struct proc *));
d162 1
a162 1
union_fixup(un, p)
a163 1
	struct proc *p;
d165 2
a166 1
	vn_lock(un->un_uppervp, LK_EXCLUSIVE | LK_RETRY, p);
a176 1
	struct proc *p = cnp->cn_proc;
d202 1
a202 1
			vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
d216 1
a216 1
		vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
d228 3
a230 1
		if (vfs_busy(mp, 0, 0, p))
d232 1
a232 5
	
		error = VFS_ROOT(mp, &tdvp);
		vfs_unbusy(mp, p);

		vput(dvp);
d234 2
a235 1
		if (error) {
d239 1
a262 1
	struct proc *p = curproc;
d279 1
a279 1
		vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
d281 1
a281 1
			VOP_UNLOCK(ap->a_dvp, 0, p, 0, p);
d301 1
a301 1
		FIXUP(dun, p);
d313 1
a313 1
			VOP_UNLOCK(dvp, 0, p);
d333 1
a333 1
			vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
d370 1
a370 1
		vn_lock(lowerdvp, LK_EXCLUSIVE | LK_RETRY, p);
d395 1
a395 1
			VOP_UNLOCK(lowerdvp, 0, p);
d416 1
a416 1
				vn_lock(lowervp, LK_EXCLUSIVE | LK_RETRY, p);
d465 1
a465 1
			VOP_UNLOCK(upperdvp, 0, p);
d467 1
a467 1
			vn_lock(upperdvp, LK_EXCLUSIVE | LK_RETRY, p);
d481 1
a481 1
		VOP_UNLOCK(lowervp, 0, p);
d494 1
a494 1
				VOP_UNLOCK(dvp, 0, p);
a518 2
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
d525 1
a525 1
		FIXUP(un, p);
d531 1
a531 1
		error = VOP_CREATE(dvp, &vp, cnp, ap->a_vap);
d540 1
a540 1
				cnp,
a562 1
	struct proc *p = curproc;
d567 1
a567 1
	FIXUP(un, p);
a582 1
	struct proc *p = ap->a_cnp->cn_proc;
d589 1
a589 1
		FIXUP(un, p);
d659 1
a659 1
		vn_lock(tvp, LK_EXCLUSIVE | LK_RETRY, p);
d661 1
a661 1
		VOP_UNLOCK(tvp, 0, p);
d666 1
a666 1
	FIXUP(un, p);
a730 1
	struct proc *p = ap->a_p;
d733 1
a733 1
		FIXUP(un, p);
d738 1
a738 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d747 1
a747 1
		VOP_UNLOCK(vp, 0, p);
d774 1
a774 1
	struct proc *p = ap->a_p;
d797 1
a797 1
			FIXUP(un, p);
a838 1
	struct proc *p = ap->a_p;
d860 1
a860 1
		FIXUP(un, p);
a884 1
	struct proc *p = curproc;
d887 1
a887 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d889 1
a889 1
		FIXUP(VTOUNION(ap->a_vp), p);
d892 1
a892 1
		VOP_UNLOCK(vp, 0, p);
a928 1
	struct proc *p = curproc;
d934 1
a934 1
	FIXUP(un, p);
a1029 1
	struct proc *p = ap->a_p;
d1035 1
a1035 1
			vn_lock(targetvp, LK_EXCLUSIVE | LK_RETRY, p);
d1037 1
a1037 1
			FIXUP(VTOUNION(ap->a_vp), p);
d1041 1
a1041 1
			VOP_UNLOCK(targetvp, 0, p);
a1078 1
	struct proc *p = ap->a_cnp->cn_proc;
d1088 1
a1088 1
		FIXUP(dun, p);
d1092 1
a1092 1
		FIXUP(un, p);
d1103 1
a1103 1
		FIXUP(dun, p);
a1130 1
	struct proc *p = ap->a_cnp->cn_proc;
d1149 1
a1149 1
			vn_lock(ap->a_vp, LK_EXCLUSIVE | LK_RETRY, p);
d1151 1
a1151 1
				VOP_UNLOCK(ap->a_dvp, 0, p);
d1175 1
a1175 1
					VOP_UNLOCK(ap->a_vp, 0, p);
d1182 1
a1182 1
					VOP_UNLOCK(ap->a_vp, 0, p);
d1186 1
a1186 1
			VOP_UNLOCK(ap->a_vp, 0, p);
d1201 1
a1201 1
	FIXUP(dun, p);
a1329 1
	struct proc *p = ap->a_cnp->cn_proc;
d1335 1
a1335 1
		FIXUP(un, p);
d1338 1
a1338 1
		VOP_UNLOCK(ap->a_dvp, 0, p);
a1375 1
	struct proc *p = ap->a_cnp->cn_proc;
d1385 1
a1385 1
		FIXUP(dun, p);
d1389 1
a1389 1
		FIXUP(un, p);
d1400 1
a1400 1
		FIXUP(dun, p);
a1423 1
	struct proc *p = ap->a_cnp->cn_proc;
d1429 1
a1429 1
		FIXUP(un, p);
d1460 2
a1461 3
		int *a_ncookies;
		u_long **a_cookies;

d1465 1
a1465 1
	struct proc *p = curproc;
d1469 1
a1469 1
	FIXUP(un, p);
a1484 2
	struct proc *p = curproc;

d1488 1
a1488 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1490 1
a1490 1
		FIXUP(VTOUNION(ap->a_vp), p);
d1494 1
a1494 1
		VOP_UNLOCK(vp, 0, p);
d1503 1
a1503 1
 * vput() which calls VOP_UNLOCK(, 0, p) and comes here.  union_unlock()
a1521 2
	struct proc *p = ap->a_cnp->cn_proc;

d1527 1
a1527 1
			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1529 1
a1529 1
			FIXUP(VTOUNION(ap->a_dvp), p);
d1534 1
a1534 1
		VOP_UNLOCK(vp, 0, p);
a1544 1
		struct proc *a_p;
a1595 3
	struct proc *p = ap->a_p;
	int    flags = ap->a_flags;
	int    error = 0;
d1597 5
a1601 11
	vop_nolock(ap);
	/*
	 * Need to do real lockmgr-style locking here.
	 * in the mean time, draining won't work quite right,
	 * which could lead to a few race conditions.
	 * the following test was here, but is not quite right, we
	 * still need to take the lock:
	if ((flags & LK_TYPE_MASK) == LK_DRAIN)
		return (0);
	 */
	flags &= ~LK_INTERLOCK;
d1603 1
a1603 2
start:
 	un = VTOUNION(vp);
d1608 8
a1615 4
			error = vn_lock(un->un_uppervp, flags, p);
			if (error)
				return (error);
 			un->un_flags |= UN_ULOCK;
d1619 2
a1620 2
			vprint("union: dangling klock", vp);
			panic("union: dangling upper lock (%lx)", vp);
d1622 2
a1623 2
 #endif
 	}
d1651 1
a1651 1
 * vput() which calls VOP_UNLOCK(, 0, p) and comes here.  union_unlock()
a1664 1
	struct proc *p = ap->a_p;
d1677 1
a1677 1
		VOP_UNLOCK(un->un_uppervp, 0, p);
a1689 2
	vop_nounlock(v);

a1704 1
	struct proc *p = curproc;
d1709 1
a1709 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1711 1
a1711 1
		FIXUP(VTOUNION(ap->a_vp), p);
d1715 1
a1715 1
		VOP_UNLOCK(vp, 0, p);
a1765 1
	struct proc *p = curproc;
d1769 1
a1769 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1771 1
a1771 1
		FIXUP(VTOUNION(ap->a_vp), p);
d1775 1
a1775 1
		VOP_UNLOCK(vp, 0, p);
a1777 20
}

int
union_revoke(v)
	void *v;
{
	struct vop_revoke_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
 
	if (UPPERVP(vp))
		VOP_REVOKE(UPPERVP(vp), ap->a_flags);
	if (LOWERVP(vp))
		VOP_REVOKE(LOWERVP(vp), ap->a_flags);
	vgone(vp);

	return (0);
@


1.6
log
@fixed comment in union_advlock
@
text
@d1 1
a1 1
/*	$OpenBSD: union_vnops.c,v 1.4 1996/05/22 12:04:37 deraadt Exp $	*/
d84 1
d128 1
d153 1
a153 1
#define FIXUP(un) { \
d155 1
a155 1
		union_fixup(un); \
d158 1
a158 1
static void union_fixup __P((struct union_node *));
d164 1
a164 1
union_fixup(un)
d166 1
d168 1
a168 2

	VOP_LOCK(un->un_uppervp);
d179 1
d205 1
a205 1
			VOP_LOCK(dvp);
d219 1
a219 1
		VOP_LOCK(dvp);
d231 1
a231 3
		if (mp->mnt_flag & MNT_MLOCK) {
			mp->mnt_flag |= MNT_MWAIT;
			sleep((caddr_t) mp, PVFS);
d233 5
a237 1
		}
d239 1
a239 2
		if ((error = VFS_ROOT(mp, &tdvp)) != 0) {
			vput(dvp);
a242 1
		vput(dvp);
d266 1
d283 1
a283 1
		VOP_LOCK(dvp);
d285 1
a285 1
			VOP_UNLOCK(ap->a_dvp);
d305 1
a305 1
		FIXUP(dun);
d317 1
a317 1
			VOP_UNLOCK(dvp);
d337 1
a337 1
			VOP_LOCK(dvp);
d374 1
a374 1
		VOP_LOCK(lowerdvp);
d399 1
a399 1
			VOP_UNLOCK(lowerdvp);
d420 1
a420 1
				VOP_LOCK(lowervp);
d469 1
a469 1
			VOP_UNLOCK(upperdvp);
d471 1
a471 1
			VOP_LOCK(upperdvp);
d485 1
a485 1
		VOP_UNLOCK(lowervp);
d498 1
a498 1
				VOP_UNLOCK(dvp);
d523 2
d531 1
a531 1
		FIXUP(un);
d537 1
a537 1
		error = VOP_CREATE(dvp, &vp, ap->a_cnp, ap->a_vap);
d546 1
a546 1
				ap->a_cnp,
d569 1
d574 1
a574 1
	FIXUP(un);
d590 1
d597 1
a597 1
		FIXUP(un);
d667 1
a667 1
		VOP_LOCK(tvp);
d669 1
a669 1
		VOP_UNLOCK(tvp);
d674 1
a674 1
	FIXUP(un);
d739 1
d742 1
a742 1
		FIXUP(un);
d747 1
a747 1
		VOP_LOCK(vp);
d756 1
a756 1
		VOP_UNLOCK(vp);
d783 1
a783 1

d806 1
a806 1
			FIXUP(un);
d848 1
d870 1
a870 1
		FIXUP(un);
d895 1
d898 1
a898 1
		VOP_LOCK(vp);
d900 1
a900 1
		FIXUP(VTOUNION(ap->a_vp));
d903 1
a903 1
		VOP_UNLOCK(vp);
d940 1
d946 1
a946 1
	FIXUP(un);
d1042 1
d1048 1
a1048 1
			VOP_LOCK(targetvp);
d1050 1
a1050 1
			FIXUP(VTOUNION(ap->a_vp));
d1054 1
a1054 1
			VOP_UNLOCK(targetvp);
d1092 1
d1102 1
a1102 1
		FIXUP(dun);
d1106 1
a1106 1
		FIXUP(un);
d1117 1
a1117 1
		FIXUP(dun);
d1145 1
d1164 1
a1164 1
			VOP_LOCK(ap->a_vp);
d1166 1
a1166 1
				VOP_UNLOCK(ap->a_dvp);
d1190 1
a1190 1
					VOP_UNLOCK(ap->a_vp);
d1197 1
a1197 1
					VOP_UNLOCK(ap->a_vp);
d1201 1
a1201 1
			VOP_UNLOCK(ap->a_vp);
d1216 1
a1216 1
	FIXUP(dun);
d1345 1
d1351 1
a1351 1
		FIXUP(un);
d1354 1
a1354 1
		VOP_UNLOCK(ap->a_dvp);
d1392 1
d1402 1
a1402 1
		FIXUP(dun);
d1406 1
a1406 1
		FIXUP(un);
d1417 1
a1417 1
		FIXUP(dun);
d1441 1
d1447 1
a1447 1
		FIXUP(un);
d1478 3
a1480 2
		u_long *a_cookies;
		int a_ncookies;
d1484 1
a1484 1

d1488 1
a1488 1
	FIXUP(un);
d1504 2
d1509 1
a1509 1
		VOP_LOCK(vp);
d1511 1
a1511 1
		FIXUP(VTOUNION(ap->a_vp));
d1515 1
a1515 1
		VOP_UNLOCK(vp);
d1524 1
a1524 1
 * vput() which calls VOP_UNLOCK() and comes here.  union_unlock()
d1543 2
d1550 1
a1550 1
			VOP_LOCK(vp);
d1552 1
a1552 1
			FIXUP(VTOUNION(ap->a_dvp));
d1557 1
a1557 1
		VOP_UNLOCK(vp);
d1568 1
d1620 15
d1637 1
a1637 6
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		sleep((caddr_t)vp, PINOD);
	}

	un = VTOUNION(vp);
d1642 4
a1645 8
			/*
			 * We MUST always use the order of: take upper
			 * vp lock, manipulate union node flags, drop
			 * upper vp lock.  This code must not be an
			 * exception.
			 */
			VOP_LOCK(un->un_uppervp);
			un->un_flags |= UN_ULOCK;
d1649 2
a1650 2
			vprint("dangling upper lock", vp);
			panic("union: dangling upper lock");
d1652 2
a1653 2
#endif
	}
d1681 1
a1681 1
 * vput() which calls VOP_UNLOCK() and comes here.  union_unlock()
d1695 1
d1708 1
a1708 1
		VOP_UNLOCK(un->un_uppervp);
d1721 2
d1738 1
d1743 1
a1743 1
		VOP_LOCK(vp);
d1745 1
a1745 1
		FIXUP(VTOUNION(ap->a_vp));
d1749 1
a1749 1
		VOP_UNLOCK(vp);
d1800 1
d1804 1
a1804 1
		VOP_LOCK(vp);
d1806 1
a1806 1
		FIXUP(VTOUNION(ap->a_vp));
d1810 1
a1810 1
		VOP_UNLOCK(vp);
d1813 20
@


1.5
log
@sync
@
text
@d1785 1
@


1.4
log
@latest locking changes from jtk
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: union_vnops.c,v 1.30 1996/05/13 07:13:23 mrg Exp $	*/
d1729 2
a1730 3
	printf("\ttag VT_UNION, vp=%x, uppervp=%x, lowervp=%x\n",
			(unsigned int) vp, (unsigned int) UPPERVP(vp),
			(unsigned int) LOWERVP(vp));
@


1.3
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: union_vnops.c,v 1.28 1996/02/13 13:13:03 mycroft Exp $	*/
d350 2
a351 1
					cnp->cn_cred, cnp->cn_proc);
d1063 4
d1498 12
@


1.2
log
@from jtk@@kolvir.arlington.ma.us:
numerous stability fixes related to locking.
@
text
@d1 2
a2 1
/*	$NetBSD: union_vnops.c,v 1.25 1995/07/13 13:19:18 mycroft Exp $	*/
d58 93
d156 4
d234 1
a234 1
		if (error = VFS_ROOT(mp, &tdvp)) {
d248 3
a250 1
union_lookup(ap)
d256 1
a256 2
	} */ *ap;
{
a264 1
	int rdonly = cnp->cn_flags & RDONLY;
d266 1
a266 1
	struct ucred *saved_cred;
d507 3
a509 1
union_create(ap)
d515 1
a515 2
	} */ *ap;
{
d553 3
a555 1
union_whiteout(ap)
d560 1
a560 2
	} */ *ap;
{
d571 3
a573 1
union_mknod(ap)
d579 1
a579 2
	} */ *ap;
{
d619 3
a621 1
union_open(ap)
d628 1
a628 2
	} */ *ap;
{
d673 3
a675 1
union_close(ap)
d681 1
a681 2
	} */ *ap;
{
d717 3
a719 1
union_access(ap)
d726 1
a726 2
	} */ *ap;
{
d759 3
a761 1
union_getattr(ap)
d767 1
a767 2
	} */ *ap;
{
d828 3
a830 1
union_setattr(ap)
d836 1
a836 2
	} */ *ap;
{
d872 3
a874 1
union_read(ap)
d880 1
a880 2
	} */ *ap;
{
d916 3
a918 1
union_write(ap)
d924 1
a924 2
	} */ *ap;
{
d950 4
a953 1
union_lease(ap)
d959 1
a959 2
	} */ *ap;
{
d967 3
a969 1
union_ioctl(ap)
d977 1
a977 2
	} */ *ap;
{
d985 3
a987 1
union_select(ap)
d994 1
a994 2
	} */ *ap;
{
d1002 3
a1004 1
union_mmap(ap)
d1010 1
a1010 2
	} */ *ap;
{
d1018 3
a1020 1
union_fsync(ap)
d1026 1
a1026 2
	} */ *ap;
{
d1047 3
a1049 1
union_seek(ap)
d1055 1
a1055 2
	} */ *ap;
{
d1063 3
a1065 1
union_remove(ap)
d1070 1
a1070 2
	} */ *ap;
{
d1109 2
a1110 2
/* a_vp: directory in which to link
   a_tdvp: new target of the link
d1114 3
a1116 1
union_link(ap)
d1118 1
a1119 1
		struct vnode *a_tdvp;
d1121 1
a1121 2
	} */ *ap;
{
d1123 2
a1124 1
	struct union_node *un;
a1125 1
	struct vnode *tdvp;
d1127 1
a1127 1
	un = VTOUNION(ap->a_vp);
d1135 2
a1136 2
	if (ap->a_vp->v_op != ap->a_tdvp->v_op) {
		tdvp = ap->a_tdvp;
d1138 3
a1140 2
		struct union_node *tdun = VTOUNION(ap->a_tdvp);
		if (tdun->un_uppervp == NULLVP) {
d1144 3
a1146 3
			VOP_LOCK(ap->a_tdvp);
			if (un->un_uppervp == tdun->un_dirvp) {
				VOP_UNLOCK(ap->a_vp);
d1148 1
a1148 1
			error = union_copyup(tdun, 1, ap->a_cnp->cn_cred,
d1150 1
a1150 1
			if (un->un_uppervp == tdun->un_dirvp) {
d1161 1
a1161 1
				if (un->un_uppervp == NULLVP ||
d1167 4
a1170 4
				    (error = relookup(ap->a_vp,
						      &vp, ap->a_cnp))) {
					vrele(ap->a_vp);
					VOP_UNLOCK(ap->a_tdvp);
d1173 1
a1173 1
				if (vp != NULLVP) {
d1177 1
a1177 1
					VOP_UNLOCK(ap->a_tdvp);
d1181 1
a1181 1
			VOP_UNLOCK(ap->a_tdvp);
d1183 1
a1183 1
		tdvp = tdun->un_uppervp;
d1186 2
a1187 2
	vp = un->un_uppervp;
	if (vp == NULLVP)
d1192 1
a1192 1
		vput(ap->a_vp);
d1196 4
a1199 4
	FIXUP(un);
	VREF(vp);
	un->un_flags |= UN_KLOCK;
	vput(ap->a_vp);
d1201 1
a1201 1
	return (VOP_LINK(vp, tdvp, ap->a_cnp));
d1205 3
a1207 1
union_rename(ap)
d1215 1
a1215 2
	} */ *ap;
{
d1314 3
a1316 1
union_mkdir(ap)
d1322 1
a1322 2
	} */ *ap;
{
d1360 3
a1362 1
union_rmdir(ap)
d1367 1
a1367 2
	} */ *ap;
{
d1407 3
a1409 1
union_symlink(ap)
d1416 1
a1416 2
	} */ *ap;
{
a1422 1
		struct mount *mp = ap->a_dvp->v_mount;
d1446 3
a1448 1
union_readdir(ap)
d1457 1
a1457 2
	} */ *ap;
{
d1470 3
a1472 1
union_readlink(ap)
d1477 1
a1477 2
	} */ *ap;
{
d1495 3
a1497 1
union_abortop(ap)
d1501 1
a1501 2
	} */ *ap;
{
d1523 3
a1525 1
union_inactive(ap)
d1528 1
a1528 2
	} */ *ap;
{
d1560 3
a1562 1
union_reclaim(ap)
d1565 1
a1565 2
	} */ *ap;
{
d1573 2
a1574 2
union_lock(ap)
	struct vop_lock_args *ap;
d1576 1
d1643 2
a1644 2
union_unlock(ap)
	struct vop_lock_args *ap;
d1646 1
d1677 3
a1679 1
union_bmap(ap)
d1686 1
a1686 2
	} */ *ap;
{
d1704 3
a1706 1
union_print(ap)
d1709 1
a1709 2
	} */ *ap;
{
d1713 2
a1714 1
			vp, UPPERVP(vp), LOWERVP(vp));
d1729 3
a1731 1
union_islocked(ap)
d1734 1
a1734 2
	} */ *ap;
{
d1740 3
a1742 1
union_pathconf(ap)
d1747 1
a1747 2
	} */ *ap;
{
d1765 3
a1767 1
union_advlock(ap)
d1774 1
a1774 2
	} */ *ap;
{
d1788 3
a1790 1
union_strategy(ap)
d1793 1
a1793 2
	} */ *ap;
{
a1814 54
/*
 * Global vfs data structures
 */
int (**union_vnodeop_p)();
struct vnodeopv_entry_desc union_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, union_lookup },		/* lookup */
	{ &vop_create_desc, union_create },		/* create */
	{ &vop_whiteout_desc, union_whiteout },		/* whiteout */
	{ &vop_mknod_desc, union_mknod },		/* mknod */
	{ &vop_open_desc, union_open },			/* open */
	{ &vop_close_desc, union_close },		/* close */
	{ &vop_access_desc, union_access },		/* access */
	{ &vop_getattr_desc, union_getattr },		/* getattr */
	{ &vop_setattr_desc, union_setattr },		/* setattr */
	{ &vop_read_desc, union_read },			/* read */
	{ &vop_write_desc, union_write },		/* write */
	{ &vop_lease_desc, union_lease },		/* lease */
	{ &vop_ioctl_desc, union_ioctl },		/* ioctl */
	{ &vop_select_desc, union_select },		/* select */
	{ &vop_mmap_desc, union_mmap },			/* mmap */
	{ &vop_fsync_desc, union_fsync },		/* fsync */
	{ &vop_seek_desc, union_seek },			/* seek */
	{ &vop_remove_desc, union_remove },		/* remove */
	{ &vop_link_desc, union_link },			/* link */
	{ &vop_rename_desc, union_rename },		/* rename */
	{ &vop_mkdir_desc, union_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, union_rmdir },		/* rmdir */
	{ &vop_symlink_desc, union_symlink },		/* symlink */
	{ &vop_readdir_desc, union_readdir },		/* readdir */
	{ &vop_readlink_desc, union_readlink },		/* readlink */
	{ &vop_abortop_desc, union_abortop },		/* abortop */
	{ &vop_inactive_desc, union_inactive },		/* inactive */
	{ &vop_reclaim_desc, union_reclaim },		/* reclaim */
	{ &vop_lock_desc, union_lock },			/* lock */
	{ &vop_unlock_desc, union_unlock },		/* unlock */
	{ &vop_bmap_desc, union_bmap },			/* bmap */
	{ &vop_strategy_desc, union_strategy },		/* strategy */
	{ &vop_print_desc, union_print },		/* print */
	{ &vop_islocked_desc, union_islocked },		/* islocked */
	{ &vop_pathconf_desc, union_pathconf },		/* pathconf */
	{ &vop_advlock_desc, union_advlock },		/* advlock */
#ifdef notdef
	{ &vop_blkatoff_desc, union_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, union_valloc },		/* valloc */
	{ &vop_vfree_desc, union_vfree },		/* vfree */
	{ &vop_truncate_desc, union_truncate },		/* truncate */
	{ &vop_update_desc, union_update },		/* update */
	{ &vop_bwrite_desc, union_bwrite },		/* bwrite */
#endif
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
};
struct vnodeopv_desc union_vnodeop_opv_desc =
	{ &union_vnodeop_p, union_vnodeop_entries };
@


1.1
log
@Initial revision
@
text
@d204 13
d219 19
d283 6
d360 5
d396 7
d590 1
a590 2

#ifdef	DIAGNOSTIC
d592 2
a593 2
	 * We should never encounter a vnode with both upper and
	 * lower vnodes NULL.
d596 2
a597 2
		vprint("empty union vnode", vp);
		panic("union_close empty vnode");
d993 4
d1012 6
d1023 3
d1028 1
a1028 2
				un->un_flags &= ~UN_ULOCK;
				VOP_UNLOCK(un->un_uppervp);
d1033 29
a1061 2
				VOP_LOCK(un->un_uppervp);
				un->un_flags |= UN_ULOCK;
d1073 1
d1103 1
d1124 2
a1125 2
		struct union_node *un = VTOUNION(fvp);
		if (un->un_uppervp == NULLVP) {
d1131 1
a1131 1
		if (un->un_lowervp != NULLVP)
d1134 1
a1134 1
		fvp = un->un_uppervp;
d1136 1
a1136 1
		vrele(ap->a_fvp);
d1149 1
a1149 1
			goto bad;
d1166 7
d1176 5
a1180 1
	return (VOP_RENAME(fdvp, fvp, ap->a_fcnp, tdvp, tvp, ap->a_tcnp));
d1182 2
d1464 6
d1503 12
d1588 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
