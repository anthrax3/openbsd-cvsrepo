head	1.21;
access;
symbols
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.6
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2005.06.17.21.02.51;	author henning;	state dead;
branches;
next	1.20;

1.20
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.28.19;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.03.21.16.30;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.03.49.55;	author angelos;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.06.25.01.50.18;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.27.12.29.23;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.22.19.07.12;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.20.08.36.02;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.23.07.35.10;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	99.01.11.05.12.34;	author millert;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	96.10.21.10.58.19;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.05.22.12.02.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.12.03.18.34;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.31.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.24.08.46.19;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.08.20.27;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.20;	author deraadt;	state Exp;
branches;
next	;

1.8.6.1
date	2001.05.14.22.40.23;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2001.07.04.10.55.42;	author niklas;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.8.6.4;

1.8.6.4
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.8.6.5;

1.8.6.5
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.8.6.6;

1.8.6.6
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.05.19.22.40.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@rot in Attic
@
text
@/*	$OpenBSD: ns_ip.c,v 1.20 2004/01/03 14:08:54 espie Exp $	*/
/*	$NetBSD: ns_ip.c,v 1.16 1996/05/09 22:29:40 scottr Exp $	*/

/*
 * Copyright (c) 1984, 1985, 1986, 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ns_ip.c	8.1 (Berkeley) 6/10/93
 */

/*
 * Software interface driver for encapsulating ns in ip.
 */

#ifdef NSIP
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/protosw.h>

#include <machine/cpu.h>	/* XXX for setsoftnet().  This must die. */

#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#include <netns/ns.h>
#include <netns/ns_if.h>
#include <netns/ns_var.h>
#include <netns/idp.h>

#include <sys/stdarg.h>

struct ifnet_en {
	struct ifnet ifen_ifnet;
	struct route ifen_route;
	struct in_addr ifen_src;
	struct in_addr ifen_dst;
	struct ifnet_en *ifen_next;
};

#define LOMTU	(1024+512);

int	nsipif_unit;			/* XXX */
struct ifnet nsipif;
struct ifnet_en *nsip_list;		/* list of all hosts and gateways or
					broadcast addrs */

struct ifnet_en *
nsipattach()
{
	struct ifnet_en *m;
	struct ifnet *ifp;

	if (nsipif.if_mtu == 0) {
		ifp = &nsipif;
		snprintf(ifp->if_xname, sizeof ifp->if_xname,
		    "nsip%d", nsipif_unit);
		ifp->if_mtu = LOMTU;
		ifp->if_ioctl = nsipioctl;
		ifp->if_output = nsipoutput;
		ifp->if_start = nsipstart;
		ifp->if_flags = IFF_POINTOPOINT;
	}

	MALLOC((m), struct ifnet_en *, sizeof(*m), M_PCB, M_NOWAIT);
	if (m == NULL) return (NULL);
	m->ifen_next = nsip_list;
	nsip_list = m;
	ifp = &m->ifen_ifnet;

	snprintf(ifp->if_xname, sizeof ifp->if_xname,
	    "nsip%d", nsipif_unit++);
	ifp->if_mtu = LOMTU;
	ifp->if_ioctl = nsipioctl;
	ifp->if_output = nsipoutput;
	ifp->if_start = nsipstart;
	ifp->if_flags = IFF_POINTOPOINT;
	if_attach(ifp);

	/*
	 * XXX Emulate the side effect of incrementing nsipif.if_unit
	 * XXX in the days before if_xname.
	 */
	bzero(nsipif.if_xname, sizeof(nsipif.if_xname));
	snprintf(nsipif.if_xname, sizeof nsipif.if_xname,
	    "nsip%d", nsipif_unit);

	return (m);
}


/*
 * Process an ioctl request.
 */
/* ARGSUSED */
int
nsipioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	int error = 0;
	struct ifreq *ifr;

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* fall into: */

	case SIOCSIFDSTADDR:
		/*
		 * Everything else is done at a higher level.
		 */
		break;

	case SIOCSIFFLAGS:
		ifr = (struct ifreq *)data;
		if ((ifr->ifr_flags & IFF_UP) == 0)
			error = nsip_free(ifp);


	default:
		error = EINVAL;
	}
	return (error);
}

struct mbuf *nsip_badlen;
struct mbuf *nsip_lastin;
int nsip_hold_input;

void
idpip_input(struct mbuf *m, ...)
{
	struct ifnet *ifp;
	struct ip *ip;
	struct idp *idp;
	struct ifqueue *ifq = &nsintrq;
	int len, s;
	va_list	ap;

	va_start(ap, m);
	ifp = va_arg(ap, struct ifnet *);
	va_end(ap);

	if (nsip_hold_input) {
		if (nsip_lastin) {
			m_freem(nsip_lastin);
		}
		nsip_lastin = m_copym(m, 0, (int)M_COPYALL, M_DONTWAIT);
	}
	/*
	 * Get IP and IDP header together in first mbuf.
	 */
	nsipif.if_ipackets++;
	s = sizeof (struct ip) + sizeof (struct idp);
	if (((m->m_flags & M_EXT) || m->m_len < s) &&
	    (m = m_pullup(m, s)) == 0) {
		nsipif.if_ierrors++;
		return;
	}
	ip = mtod(m, struct ip *);
	if (ip->ip_hl > (sizeof (struct ip) >> 2)) {
		ip_stripoptions(m, (struct mbuf *)0);
		if (m->m_len < s) {
			if ((m = m_pullup(m, s)) == 0) {
				nsipif.if_ierrors++;
				return;
			}
			ip = mtod(m, struct ip *);
		}
	}

	/*
	 * Make mbuf data length reflect IDP length.
	 * If not enough data to reflect IDP length, drop.
	 */
	m->m_data += sizeof (struct ip);
	m->m_len -= sizeof (struct ip);
	m->m_pkthdr.len -= sizeof (struct ip);
	idp = mtod(m, struct idp *);
	len = ntohs(idp->idp_len);
	if (len & 1) len++;		/* Preserve Garbage Byte */
	if (ntohs(ip->ip_len) - (ip->ip_hl << 2) != len) {
		if (len > ip->ip_len - (ip->ip_hl << 2)) {
			nsipif.if_ierrors++;
			if (nsip_badlen) m_freem(nsip_badlen);
			nsip_badlen = m;
			return;
		}
		/* Any extra will be trimmed off by the NS routines */
	}

	/*
	 * Place interface pointer before the data
	 * for the receiving protocol.
	 */
	m->m_pkthdr.rcvif = ifp;
	/*
	 * Deliver to NS
	 */
	s = splimp();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
		splx(s);
		return;
	}
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_NS);
	splx(s);
	return;
}

/* ARGSUSED */
int
nsipoutput(ifp, m, dst, rt)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr *dst;
	struct rtentry *rt;
{

	struct ip *ip;
	int len = 0;
	struct idp *idp = mtod(m, struct idp *);
	struct ifnet_en *ifn = (struct ifnet_en *)ifp;
	struct route ro;
	int error;

	ifn->ifen_ifnet.if_opackets++;
	nsipif.if_opackets++;
	ro.ro_rt = rt;
	ro.ro_dst = *dst;

	/*
	 * Calculate data length and make space
	 * for IP header.
	 */
	len =  ntohs(idp->idp_len);
	if (len & 1) len++;		/* Preserve Garbage Byte */
	/* following clause not necessary on vax */
	if (3 & (int)m->m_data) {
		/* force longword alignment of ip hdr */
		struct mbuf *m0 = m_gethdr(M_DONTWAIT, MT_HEADER);
		if (m0 == 0) {
			m_freem(m);
			return (ENOBUFS);
		}
		M_MOVE_HDR(m0, m);
		MH_ALIGN(m0, sizeof (struct ip));
		m0->m_flags = m->m_flags & M_COPYFLAGS;
		m0->m_next = m;
		m0->m_len = sizeof (struct ip);
		m0->m_pkthdr.len = m0->m_len + m->m_len;
	} else {
		M_PREPEND(m, sizeof (struct ip), M_DONTWAIT);
		if (m == 0)
			return (ENOBUFS);
	}
	/*
	 * Fill in IP header.
	 */
	ip = mtod(m, struct ip *);
	*(long *)ip = 0;
	ip->ip_p = IPPROTO_IDP;
	ip->ip_src = ifn->ifen_src;
	ip->ip_dst = ifn->ifen_dst;
	if (len + sizeof (struct ip) > IP_MAXPACKET) {
		m_freem(m);
		return EMSGSIZE;
	}
	ip->ip_len = htons(len + sizeof (struct ip));
	ip->ip_ttl = MAXTTL;

	/*
	 * Output final datagram.
	 */
	error = ip_output(m, (struct mbuf *)0, &ro, SO_BROADCAST, (void *)NULL,
	    (void *)NULL);
	if (error) {
		ifn->ifen_ifnet.if_oerrors++;
		ifn->ifen_ifnet.if_ierrors = error;
	}
	return (error);
}

void
nsipstart(ifp)
	struct ifnet *ifp;
{
	panic("nsip_start called");
}

struct ifreq ifr = {"nsip0"};		/* XXX */

int
nsip_route(m)
	struct mbuf *m;
{
	struct nsip_req *rq = mtod(m, struct nsip_req *);
	struct sockaddr_ns *ns_dst = satosns(&rq->rq_ns);
	struct sockaddr_in *ip_dst = satosin(&rq->rq_ip);
	struct route ro;
	struct ifnet_en *ifn;
	struct sockaddr_in *src;

	/*
	 * First, make sure we already have an ns address:
	 */
	if (ns_hosteqnh(ns_thishost, ns_zerohost))
		return (EADDRNOTAVAIL);
	/*
	 * Now, determine if we can get to the destination
	 */
	bzero((caddr_t)&ro, sizeof (ro));
	ro.ro_dst = *sintosa(ip_dst);
	rtalloc(&ro);
	if (ro.ro_rt == 0 || ro.ro_rt->rt_ifp == 0) {
		return (ENETUNREACH);
	}

	/*
	 * And see how he's going to get back to us:
	 * i.e., what return ip address do we use?
	 */
	{
		struct in_ifaddr *ia;
		struct ifnet *ifp = ro.ro_rt->rt_ifp;

		for (ia = in_ifaddr.tqh_first; ia != 0;
		    ia = ia->ia_list.tqe_next)
			if (ia->ia_ifp == ifp)
				break;
		if (ia == NULL)
			ia = in_ifaddr.tqh_first;
		if (ia == NULL) {
			RTFREE(ro.ro_rt);
			return (EADDRNOTAVAIL);
		}
		src = satosin(&ia->ia_addr);
	}

	/*
	 * Is there a free (pseudo-)interface or space?
	 */
	for (ifn = nsip_list; ifn; ifn = ifn->ifen_next) {
		if ((ifn->ifen_ifnet.if_flags & IFF_UP) == 0)
			break;
	}
	if (ifn == NULL)
		ifn = nsipattach();
	if (ifn == NULL) {
		RTFREE(ro.ro_rt);
		return (ENOBUFS);
	}
	ifn->ifen_route = ro;
	ifn->ifen_dst =  ip_dst->sin_addr;
	ifn->ifen_src = src->sin_addr;

	/*
	 * now configure this as a point to point link
	 */
	bzero(ifr.ifr_name, sizeof(ifr.ifr_name));
	snprintf(ifr.ifr_name, sizeof ifr.ifr_name,
	    "nsip%d", nsipif_unit - 1);
	ifr.ifr_dstaddr = *snstosa(ns_dst);
	(void)ns_control((struct socket *)0, SIOCSIFDSTADDR, (caddr_t)&ifr,
			(struct ifnet *)ifn);
	satons_addr(ifr.ifr_addr).x_host = ns_thishost;
	return (ns_control((struct socket *)0, SIOCSIFADDR, (caddr_t)&ifr,
			(struct ifnet *)ifn));
}

int
nsip_free(ifp)
struct ifnet *ifp;
{
	struct ifnet_en *ifn = (struct ifnet_en *)ifp;
	struct route *ro = & ifn->ifen_route;

	if (ro->ro_rt) {
		RTFREE(ro->ro_rt);
		ro->ro_rt = 0;
	}
	ifp->if_flags &= ~IFF_UP;
	return (0);
}

void *
nsip_ctlinput(cmd, sa, v)
	int cmd;
	struct sockaddr *sa;
	void *v;
{
	struct sockaddr_in *sin;

	if ((unsigned)cmd >= PRC_NCMDS)
		return NULL;
	if (sa->sa_family != AF_INET && sa->sa_family != AF_IMPLINK)
		return NULL;
	sin = satosin(sa);
	if (sin->sin_addr.s_addr == INADDR_ANY)
		return NULL;

	switch (cmd) {

	case PRC_ROUTEDEAD:
	case PRC_REDIRECT_NET:
	case PRC_REDIRECT_HOST:
	case PRC_REDIRECT_TOSNET:
	case PRC_REDIRECT_TOSHOST:
		nsip_rtchange(&sin->sin_addr);
		break;
	}
	return NULL;
}

int
nsip_rtchange(dst)
	struct in_addr *dst;
{
	struct ifnet_en *ifn;

	for (ifn = nsip_list; ifn; ifn = ifn->ifen_next) {
		if (ifn->ifen_dst.s_addr == dst->s_addr &&
			ifn->ifen_route.ro_rt) {
				RTFREE(ifn->ifen_route.ro_rt);
				ifn->ifen_route.ro_rt = 0;
		}
	}
	return 0;
}
#endif
@


1.20
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.19 2003/12/10 07:22:44 itojun Exp $	*/
@


1.19
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.18 2003/07/09 22:03:16 itojun Exp $	*/
d67 1
a67 1
#include <machine/stdarg.h>
@


1.18
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.17 2003/06/02 23:28:19 millert Exp $	*/
d87 2
a88 2
	register struct ifnet_en *m;
	register struct ifnet *ifp;
d134 1
a134 1
	register struct ifnet *ifp;
d173 3
a175 3
	register struct ip *ip;
	register struct idp *idp;
	register struct ifqueue *ifq = &nsintrq;
d256 1
a256 1
	register struct mbuf *m;
d261 3
a263 3
	register struct ip *ip;
	register int len = 0;
	register struct idp *idp = mtod(m, struct idp *);
d336 1
a336 1
	register struct mbuf *m;
d338 1
a338 1
	register struct nsip_req *rq = mtod(m, struct nsip_req *);
d365 1
a365 1
		register struct in_ifaddr *ia;
d416 1
a416 1
	register struct ifnet_en *ifn = (struct ifnet_en *)ifp;
d458 1
a458 1
	register struct in_addr *dst;
d460 1
a460 1
	register struct ifnet_en *ifn;
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.16 2003/05/03 21:16:30 deraadt Exp $	*/
d221 2
a222 2
	if (ip->ip_len != len) {
		if (len > ip->ip_len) {
d306 5
a310 1
	ip->ip_len = (u_short)len + sizeof (struct ip);
d316 2
a317 1
	error =  (ip_output(m, (struct mbuf *)0, &ro, SO_BROADCAST, (void *)NULL, (void *)NULL));
@


1.16
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.15 2002/08/28 15:43:03 pefo Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.14 2001/06/27 03:49:55 angelos Exp $	*/
d96 2
a97 1
		sprintf(ifp->if_xname, "nsip%d", nsipif_unit);
d111 2
a112 1
	sprintf(ifp->if_xname, "nsip%d", nsipif_unit++);
d125 2
a126 1
	sprintf(nsipif.if_xname, "nsip%d", nsipif_unit);
d401 2
a402 1
	sprintf(ifr.ifr_name, "nsip%d", nsipif_unit - 1);
@


1.14
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.13 2001/06/25 01:50:18 fgsch Exp $	*/
d313 1
a313 1
	error =  (ip_output(m, (struct mbuf *)0, &ro, SO_BROADCAST, NULL));
@


1.14.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.14 2001/06/27 03:49:55 angelos Exp $	*/
d313 1
a313 1
	error =  (ip_output(m, (struct mbuf *)0, &ro, SO_BROADCAST, (void *)NULL, (void *)NULL));
@


1.14.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 1
a96 2
		snprintf(ifp->if_xname, sizeof ifp->if_xname,
		    "nsip%d", nsipif_unit);
d110 1
a110 2
	snprintf(ifp->if_xname, sizeof ifp->if_xname,
	    "nsip%d", nsipif_unit++);
d123 1
a123 2
	snprintf(nsipif.if_xname, sizeof nsipif.if_xname,
	    "nsip%d", nsipif_unit);
d398 1
a398 2
	snprintf(ifr.ifr_name, sizeof ifr.ifr_name,
	    "nsip%d", nsipif_unit - 1);
@


1.13
log
@Move common post M_COPY_HDR manipulation to the macro itself; angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.12 2001/05/27 12:29:23 angelos Exp $	*/
d288 1
a288 1
		M_COPY_HDR(m0, m);
@


1.12
log
@Yup, more tag fixups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.11 2001/05/22 19:07:12 angelos Exp $	*/
a288 2
		m->m_flags &= ~M_PKTHDR;
		m_tag_init(m);
@


1.11
log
@TAILQ_INIT() is preferred.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.10 2001/05/20 08:36:02 angelos Exp $	*/
d288 3
a295 3
		m0->m_pkthdr.tags = m->m_pkthdr.tags;
		m->m_flags &= ~M_PKTHDR;
		TAILQ_INIT(&m->m_pkthdr.tags);
@


1.10
log
@Convert from tdbi to packet tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.9 2001/03/23 07:35:10 angelos Exp $	*/
d295 1
a295 1
		m->m_pkthdr.tags = TAILQ_INITIALIZER(m->m_pkthdr.tags);
@


1.9
log
@Careful with copying mbuf pkthdr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.8 1999/01/11 05:12:34 millert Exp $	*/
d293 1
a293 1
		m0->m_pkthdr.tdbi = m->m_pkthdr.tdbi;
d295 1
a295 1
		m->m_pkthdr.tdbi = NULL;  /* paranoid */
@


1.8
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.7 1996/10/21 10:58:19 mickey Exp $	*/
d293 1
d295 1
@


1.8.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.9 2001/03/23 07:35:10 angelos Exp $	*/
a292 1
		m0->m_pkthdr.tdbi = m->m_pkthdr.tdbi;
a293 1
		m->m_pkthdr.tdbi = NULL;  /* paranoid */
@


1.8.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.8.6.1 2001/05/14 22:40:23 niklas Exp $	*/
a287 1
		M_MOVE_HDR(m0, m);
d293 3
@


1.8.6.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d313 1
a313 1
	error =  (ip_output(m, (struct mbuf *)0, &ro, SO_BROADCAST, (void *)NULL, (void *)NULL));
@


1.8.6.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.8.6.3 2003/03/28 00:06:55 niklas Exp $	*/
d96 1
a96 2
		snprintf(ifp->if_xname, sizeof ifp->if_xname,
		    "nsip%d", nsipif_unit);
d110 1
a110 2
	snprintf(ifp->if_xname, sizeof ifp->if_xname,
	    "nsip%d", nsipif_unit++);
d123 1
a123 2
	snprintf(nsipif.if_xname, sizeof nsipif.if_xname,
	    "nsip%d", nsipif_unit);
d398 1
a398 2
	snprintf(ifr.ifr_name, sizeof ifr.ifr_name,
	    "nsip%d", nsipif_unit - 1);
@


1.8.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.8.6.4 2003/05/13 19:36:18 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
#include <sys/stdarg.h>
d87 2
a88 2
	struct ifnet_en *m;
	struct ifnet *ifp;
d134 1
a134 1
	struct ifnet *ifp;
d173 3
a175 3
	struct ip *ip;
	struct idp *idp;
	struct ifqueue *ifq = &nsintrq;
d221 2
a222 2
	if (ntohs(ip->ip_len) - (ip->ip_hl << 2) != len) {
		if (len > ip->ip_len - (ip->ip_hl << 2)) {
d256 1
a256 1
	struct mbuf *m;
d261 3
a263 3
	struct ip *ip;
	int len = 0;
	struct idp *idp = mtod(m, struct idp *);
d306 1
a306 5
	if (len + sizeof (struct ip) > IP_MAXPACKET) {
		m_freem(m);
		return EMSGSIZE;
	}
	ip->ip_len = htons(len + sizeof (struct ip));
d312 1
a312 2
	error = ip_output(m, (struct mbuf *)0, &ro, SO_BROADCAST, (void *)NULL,
	    (void *)NULL);
d331 1
a331 1
	struct mbuf *m;
d333 1
a333 1
	struct nsip_req *rq = mtod(m, struct nsip_req *);
d360 1
a360 1
		struct in_ifaddr *ia;
d411 1
a411 1
	struct ifnet_en *ifn = (struct ifnet_en *)ifp;
d453 1
a453 1
	struct in_addr *dst;
d455 1
a455 1
	struct ifnet_en *ifn;
@


1.7
log
@-Wall happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.6 1996/05/22 12:02:43 deraadt Exp $	*/
d325 1
a325 1
	panic("nsip_start called\n");
@


1.6
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ns_ip.c,v 1.5 1996/05/12 03:18:34 mickey Exp $	*/
d68 1
a80 3
int	nsipoutput(), nsipioctl();
void	nsipstart();
void	nsip_rtchange __P((register struct in_addr *dst));
d133 1
a242 1
bad:
d254 3
a256 2
nsipoutput(ifn, m, dst)
	struct ifnet_en *ifn;
d259 1
a262 1
	register struct route *ro = &(ifn->ifen_route);
d265 2
d271 2
a272 1

d313 1
a313 1
	error =  (ip_output(m, (struct mbuf *)0, ro, SO_BROADCAST, NULL));
a318 3
bad:
	m_freem(m);
	return (ENETUNREACH);
d330 1
a427 1
	extern u_char inetctlerrmap[];
d431 1
a431 1
		return;
d433 1
a433 1
		return;
d436 1
a436 1
		return;
d451 1
a451 1
void
d464 1
@


1.5
log
@missed ;
@
text
@d1 2
a2 2
/*	$OpenBSD: ns_ip.c,v 1.2 1996/03/04 08:20:27 niklas Exp $	*/
/*	$NetBSD: ns_ip.c,v 1.15 1996/05/07 02:48:08 thorpej Exp $	*/
d53 2
@


1.4
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d122 1
a122 1
	bzero(nsipif.if_xname, sizeof(nsipif.if_xname))
@


1.3
log
@Fix prototyping.
@
text
@d2 1
a2 1
/*	$NetBSD: ns_ip.c,v 1.14 1996/02/13 22:13:58 christos Exp $	*/
d83 1
d96 1
a96 1
		ifp->if_name = "nsip";
d110 1
a110 1
	ifp->if_name = "nsip";
a115 1
	ifp->if_unit = nsipif.if_unit++;
d118 7
d327 1
a327 1
struct ifreq ifr = {"nsip0"};
d395 2
a396 1
	ifr.ifr_name[4] = '0' + nsipif.if_unit - 1;
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 2
d80 1
d162 3
a164 2
idpip_input(m, ifp)
	register struct mbuf *m;
a165 1
{
d170 5
d359 3
a361 3
		if (ia == 0)
			ia = in_ifaddr;
		if (ia == 0) {
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ns_ip.c,v 1.13 1995/06/13 08:37:05 mycroft Exp $	*/
d389 1
d404 2
a405 1
nsip_ctlinput(cmd, sa)
d408 1
a411 1
	int in_rtchange();
d431 1
d434 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
