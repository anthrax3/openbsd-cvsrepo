head	1.9;
access;
symbols
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.26
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.24
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.22
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.20
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.18
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.10
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.06.16.17.37.54;	author henning;	state dead;
branches;
next	1.8;

1.8
date	2004.11.29.06.20.02;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.03.03.06.41.11;	author millert;	state Exp;
branches
	1.5.10.1;
next	1.4;

1.4
date	97.01.27.07.57.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.12.31.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.07.36.33;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.09;	author deraadt;	state Exp;
branches;
next	;

1.5.10.1
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.5.10.2;

1.5.10.2
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove remaining netccitt parts, full ports build test by pval, thanks!
@
text
@/*	$OpenBSD: llc_subr.c,v 1.8 2004/11/29 06:20:02 jsg Exp $	*/
/*	$NetBSD: llc_subr.c,v 1.5 1996/05/07 02:36:08 thorpej Exp $	*/

/* 
 * Copyright (C) Dirk Husemann, Computer Science Department IV, 
 * 		 University of Erlangen-Nuremberg, Germany, 1990, 1991, 1992
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * 
 * This code is derived from software contributed to Berkeley by
 * Dirk Husemann and the Computer Science Department (IV) of
 * the University of Erlangen-Nuremberg, Germany.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)llc_subr.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_llc.h>
#include <net/route.h>

#include <netccitt/dll.h>
#include <netccitt/llc_var.h>

/*
 * Frame names for diagnostic messages
 */
char *frame_names[] = {
	"INFO", "RR", "RNR", "REJ", "DM", "SABME", "DISC",
	"UA", "FRMR", "UI", "XID", "TEST", "ILLEGAL", "TIMER", "N2xT1"
};


/*
 * Trace level
 */
int llc_tracelevel = LLCTR_URGENT;

/*
 * Values for accessing various bitfields
 */
struct bitslice llc_bitslice[] = {
	/* mask, shift value */
	{0x1, 0x0},
	{0xfe, 0x1},
	{0x3, 0x0},
	{0xc, 0x2},
	{0x10, 0x4},
	{0xe0, 0x5},
	{0x1f, 0x0}
};

/*
 * We keep the link control blocks on a doubly linked list -
 * primarily for checking in llc_time()
 */
struct llccb_q  llccb_q = {&llccb_q, &llccb_q};

/*
 * Flag for signalling wether route tree for AF_LINK has been
 * initialized yet.
 */

int af_link_rts_init_done = 0;


/*
 * Functions dealing with struct sockaddr_dl */

/* Compare sdl_a w/ sdl_b */
int
sdl_cmp(sdl_a, sdl_b)
	struct sockaddr_dl *sdl_a;
	struct sockaddr_dl *sdl_b;
{
	if (LLADDRLEN(sdl_a) != LLADDRLEN(sdl_b))
		return (1);
	return (bcmp((caddr_t) sdl_a->sdl_data, (caddr_t) sdl_b->sdl_data,
		     LLADDRLEN(sdl_a)));
}

/* Copy sdl_f to sdl_t */
void
sdl_copy(sdl_f, sdl_t)
	struct sockaddr_dl *sdl_f;
	struct sockaddr_dl *sdl_t;
{
	bcopy((caddr_t) sdl_f, (caddr_t) sdl_t, sdl_f->sdl_len);
}

/* Swap sdl_a w/ sdl_b */
void
sdl_swapaddr(sdl_a, sdl_b)
	struct sockaddr_dl *sdl_a;
	struct sockaddr_dl *sdl_b;
{
	struct sockaddr_dl sdl_tmp;

	sdl_copy(sdl_a, &sdl_tmp);
	sdl_copy(sdl_b, sdl_a);
	sdl_copy(&sdl_tmp, sdl_b);
}

/* Fetch the sdl of the associated if */
struct sockaddr_dl *
sdl_getaddrif(ifp)
	struct ifnet *ifp;
{
	struct ifaddr *ifa;

	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	     ifa = ifa->ifa_list.tqe_next)
		if (ifa->ifa_addr->sa_family == AF_LINK)
			return ((struct sockaddr_dl *) (ifa->ifa_addr));

	return ((struct sockaddr_dl *) 0);
}

/* Check addr of interface with the one given */
int
sdl_checkaddrif(ifp, sdl_c)
	struct ifnet *ifp;
	struct sockaddr_dl *sdl_c;
{
	struct ifaddr *ifa;

	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	     ifa = ifa->ifa_list.tqe_next)
		if (ifa->ifa_addr->sa_family == AF_LINK &&
		    !sdl_cmp((struct sockaddr_dl *) (ifa->ifa_addr), sdl_c))
			return (1);

	return (0);
}

/* Build an sdl from MAC addr, DLSAP addr, and interface */
int
sdl_setaddrif(ifp, mac_addr, dlsap_addr, mac_len, sdl_to)
	struct ifnet *ifp;
	u_char *mac_addr;
	u_char dlsap_addr;
        u_char mac_len;
	struct sockaddr_dl *sdl_to;
{
	struct sockaddr_dl *sdl_tmp;

	if ((sdl_tmp = sdl_getaddrif(ifp))) {
		sdl_copy(sdl_tmp, sdl_to);
		bcopy((caddr_t) mac_addr, (caddr_t) LLADDR(sdl_to), mac_len);
		*(LLADDR(sdl_to) + mac_len) = dlsap_addr;
		sdl_to->sdl_alen = mac_len + 1;
		return (1);
	} else
		return (0);
}

/* Fill out the sdl header aggregate */
int
sdl_sethdrif(ifp, mac_src, dlsap_src, mac_dst, dlsap_dst, mac_len, sdlhdr_to)
	struct ifnet *ifp;
	u_char *mac_src;
	u_char dlsap_src;
	u_char *mac_dst;
	u_char dlsap_dst;
	u_char mac_len;
	struct sdl_hdr *sdlhdr_to;
{
	if (!sdl_setaddrif(ifp, mac_src, dlsap_src, mac_len,
			   &sdlhdr_to->sdlhdr_src) ||
	    !sdl_setaddrif(ifp, mac_dst, dlsap_dst, mac_len,
			   &sdlhdr_to->sdlhdr_dst))
		return (0);
	else
		return (1);
}

static struct sockaddr_dl sap_saddr;
static struct sockaddr_dl sap_sgate = {
	sizeof(struct sockaddr_dl),	/* _len */
	AF_LINK				/* _af */
};

/*
 * Set sapinfo for SAP address, llcconfig, af, and interface
 */
struct npaidbentry *
llc_setsapinfo(ifp, af, sap, llconf)
	struct ifnet *ifp;
	u_char af;
	u_char sap;
	struct dllconfig* llconf;
{
	struct protosw *pp;
	struct sockaddr_dl *ifdl_addr;
	struct rtentry *sirt = (struct rtentry *) 0;
	struct npaidbentry *sapinfo;
	u_char          saploc;
	int             size = sizeof(struct npaidbentry);

	USES_AF_LINK_RTS;

	/*
	 * We rely/assume that only STREAM protocols will make use of
	 * connection oriented LLC2. If this will one day not be the case
	 * this will obviously fail.
	 */
	pp = pffindtype(af, SOCK_STREAM);
	if (pp == 0 || pp->pr_input == 0 || pp->pr_ctlinput == 0) {
		printf("network	level protosw error");
		return 0;
	}
	/*
	 * We need a way to jot down the LLC2 configuration for
	 * a certain LSAP address. To do this we enter
	 * a "route" for the SAP.
	 */
	ifdl_addr = sdl_getaddrif(ifp);
	sdl_copy(ifdl_addr, &sap_saddr);
	sdl_copy(ifdl_addr, &sap_sgate);
	saploc = LLSAPLOC(&sap_saddr, ifp);
	sap_saddr.sdl_data[saploc] = sap;
	sap_saddr.sdl_alen++;

	/* now enter it */
	rtrequest(RTM_ADD, (struct sockaddr *) & sap_saddr,
		  (struct sockaddr *) & sap_sgate, 0, 0, &sirt);
	if (sirt == 0)
		return 0;

	/* Plug in config information in rt->rt_llinfo */

	sirt->rt_llinfo = malloc(size, M_PCB, M_WAITOK);
	sapinfo = (struct npaidbentry *) sirt->rt_llinfo;
	if (sapinfo) {
		bzero((caddr_t) sapinfo, size);
		/*
		 * For the time being we support LLC CLASS II here 	 only
		 */
		sapinfo->si_class = LLC_CLASS_II;
		sapinfo->si_window = llconf->dllcfg_window;
		sapinfo->si_trace = llconf->dllcfg_trace;
		if (sapinfo->si_trace)
			llc_tracelevel--;
		else
			llc_tracelevel++;
		sapinfo->si_input = pp->pr_input;
		sapinfo->si_ctlinput = pp->pr_ctlinput;

		return (sapinfo);
	}
	return 0;
}

/*
 * Get sapinfo for SAP address and interface
 */
struct npaidbentry *
llc_getsapinfo(sap, ifp)
	u_char sap;
	struct ifnet *ifp;
{
	struct sockaddr_dl *ifdl_addr;
	struct sockaddr_dl siaddr;
	struct rtentry *sirt;
	u_char          saploc;

	USES_AF_LINK_RTS;

	ifdl_addr = sdl_getaddrif(ifp);
	sdl_copy(ifdl_addr, &siaddr);
	saploc = LLSAPLOC(&siaddr, ifp);
	siaddr.sdl_data[saploc] = sap;
	siaddr.sdl_alen++;

	if ((sirt = rtalloc1((struct sockaddr *) & siaddr, 0)))
		sirt->rt_refcnt--;
	else
		return (0);

	return ((struct npaidbentry *) sirt->rt_llinfo);
}

/*
 * llc_seq2slot() --- We only allocate enough memory to hold the window. This
 * introduces the necessity to keep track of two ``pointers''
 *
 *        o llcl_freeslot     the next free slot to be used
 *                            this one advances modulo llcl_window
 *        o llcl_projvs       the V(S) associated with the next frame
 *                            to be set via llcl_freeslot
 *                            this one advances modulo LLC_MAX_SEQUENCE
 *
 * A new frame is inserted at llcl_output_buffers[llcl_freeslot], after
 * which both llcl_freeslot and llcl_projvs are incremented.
 *
 * The slot sl(sn) for any given sequence number sn is given by
 *
 *        sl(sn) = (llcl_freeslot + llcl_window - 1 - (llcl_projvs +
 *                  LLC_MAX_SEQUENCE- sn) % LLC_MAX_SEQUENCE) %
 *                  llcl_window
 *
 * i.e. we first calculate the number of frames we need to ``go back''
 * from the current one (really the next one, but that doesn't matter as
 * llcl_projvs is likewise of by plus one) and subtract that from the
 * pointer to the most recently taken frame (llcl_freeslot - 1).
 */

short
llc_seq2slot(linkp, seqn)
	struct llc_linkcb *linkp;
	short seqn;
{
	int sn = 0;

	sn = (linkp->llcl_freeslot + linkp->llcl_window -
	      (linkp->llcl_projvs + LLC_MAX_SEQUENCE - seqn) %
	      LLC_MAX_SEQUENCE) % linkp->llcl_window;

	return sn;
}

/*
 * LLC2 link state handler
 *
 * There is in most cases one function per LLC2 state. The LLC2 standard
 * ISO 8802-2 allows in some cases for ambiguities, i.e. we have the choice
 * to do one thing or the other. Right now I have just chosen one but have also
 * indicated the spot by "multiple possibilities". One could make the behavior
 * in those cases configurable, allowing the superuser to enter a profile word
 * (32/64 bits, whatever is needed) that would suit her needs [I quite like
 * that idea, perhaps I'll get around to it].
 *
 * [Preceding each state handler function is the description as taken from
 * ISO 8802-2, section 7.9.2.1]
 */

/*
 * ADM --- The connection component is in the asynchronous disconnected mode.
 *         It can accept an SABME PDU from a remote LLC SSAP or, at the request
 *         of the service access point user, can initiate an SABME PDU
 *         transmission to a remote LLC DSAP, to establish a data link
 *         connection. It also responds to a DISC command PDU and to any
 *         command PDU with the P bit set to ``1''.
 */
int
llc_state_ADM(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case NL_CONNECT_REQUEST:
		llc_send(linkp, LLCFT_SABME, LLC_CMD, pollfinal);
		LLC_SETFLAG(linkp,P,pollfinal);
		LLC_SETFLAG(linkp,S,0);
		linkp->llcl_retry = 0;
		LLC_NEWSTATE(linkp,SETUP);
		break;
	case LLCFT_SABME + LLC_CMD:
		/*
		 * ISO 8802-2, table 7-1, ADM state says to set the P flag,
		 * yet this will cause an SABME [P] to be answered with an UA
		 * only, not an UA [F], all other `disconnected' states set
		 * the F flag, so ...
		 */
		LLC_SETFLAG(linkp,F,pollfinal);
		LLC_NEWSTATE(linkp,CONN);
		action = LLC_CONNECT_INDICATION;
		break;
	case LLCFT_DISC + LLC_CMD:
		llc_send(linkp, LLCFT_DM, LLC_RSP, pollfinal);
		break;
	default:
		if (cmdrsp == LLC_CMD && pollfinal == 1)
			llc_send(linkp, LLCFT_DM, LLC_RSP, 1);
		/* remain in ADM state */
	}

	return action;
}

/*
 * CONN --- The local connection component has received an SABME PDU from a
 *          remote LLC SSAP, and it is waiting for the local user to accept or
 *          refuse the connection.
 */
int
llc_state_CONN(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
        int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case NL_CONNECT_RESPONSE:
		llc_send(linkp, LLCFT_UA, LLC_RSP, LLC_GETFLAG(linkp,F));
		LLC_RESETCOUNTER(linkp);
		LLC_SETFLAG(linkp,P,0);
		LLC_SETFLAG(linkp,REMOTE_BUSY, 0);
		LLC_NEWSTATE(linkp,NORMAL);
		break;
	case NL_DISCONNECT_REQUEST:
		llc_send(linkp, LLCFT_DM, LLC_RSP, LLC_GETFLAG(linkp,F));
		LLC_NEWSTATE(linkp,ADM);
		break;
	case LLCFT_SABME + LLC_CMD:
		LLC_SETFLAG(linkp,F,pollfinal);
		break;
	case LLCFT_DM + LLC_RSP:
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
		/* all other frames effect nothing here */
	}

	return action;
}

/*
 * RESET_WAIT --- The local connection component is waiting for the local user
 *                 to indicate a RESET_REQUEST or a DISCONNECT_REQUEST.
 */
int
llc_state_RESET_WAIT(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case NL_RESET_REQUEST:
		if (LLC_GETFLAG(linkp,S) == 0) {
			llc_send(linkp, LLCFT_SABME, LLC_CMD, pollfinal);
			LLC_SETFLAG(linkp,P,pollfinal);
			LLC_START_ACK_TIMER(linkp);
			linkp->llcl_retry = 0;
			LLC_NEWSTATE(linkp,RESET);
		} else {
			llc_send(linkp, LLCFT_UA, LLC_RSP,
				 LLC_GETFLAG(linkp,F));
			LLC_RESETCOUNTER(linkp);
			LLC_SETFLAG(linkp,P,0);
			LLC_SETFLAG(linkp,REMOTE_BUSY,0);
			LLC_NEWSTATE(linkp,NORMAL);
			action = LLC_RESET_CONFIRM;
		}
		break;
	case NL_DISCONNECT_REQUEST:
		if (LLC_GETFLAG(linkp,S) == 0) {
			llc_send(linkp, LLCFT_DISC, LLC_CMD, pollfinal);
			LLC_SETFLAG(linkp,P,pollfinal);
			LLC_START_ACK_TIMER(linkp);
			linkp->llcl_retry = 0;
			LLC_NEWSTATE(linkp,D_CONN);
		} else {
			llc_send(linkp, LLCFT_DM, LLC_RSP,
				 LLC_GETFLAG(linkp,F));
			LLC_NEWSTATE(linkp,ADM);
		}
		break;
	case LLCFT_DM + LLC_RSP:
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	case LLCFT_SABME + LLC_CMD:
		LLC_SETFLAG(linkp,S,1);
		LLC_SETFLAG(linkp,F,pollfinal);
		break;
	case LLCFT_DISC + LLC_CMD:
		llc_send(linkp, LLCFT_DM, LLC_RSP, pollfinal);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	}

	return action;
}

/*
 * RESET_CHECK --- The local connection component is waiting for the local user
 *                 to accept or refuse a remote reset request.
 */
int
llc_state_RESET_CHECK(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case NL_RESET_RESPONSE:
		llc_send(linkp, LLCFT_UA, LLC_RSP, LLC_GETFLAG(linkp,F));
		LLC_RESETCOUNTER(linkp);
		LLC_SETFLAG(linkp,P,0);
		LLC_SETFLAG(linkp,REMOTE_BUSY,0);
		LLC_NEWSTATE(linkp,NORMAL);
		break;
	case NL_DISCONNECT_REQUEST:
		llc_send(linkp, LLCFT_DM, LLC_RSP, LLC_GETFLAG(linkp,F));
		LLC_NEWSTATE(linkp,ADM);
		break;
	case LLCFT_DM + LLC_RSP:
		action = LLC_DISCONNECT_INDICATION;
		break;
	case LLCFT_SABME + LLC_CMD:
		LLC_SETFLAG(linkp,F,pollfinal);
		break;
	case LLCFT_DISC + LLC_CMD:
		llc_send(linkp, LLCFT_DM, LLC_RSP, pollfinal);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	}

	return action;
}

/*
 * SETUP --- The connection component has transmitted an SABME command PDU to a
 *           remote LLC DSAP and is waiting for a reply.
 */
int
llc_state_SETUP(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case LLCFT_SABME + LLC_CMD:
		LLC_RESETCOUNTER(linkp);
		llc_send(linkp, LLCFT_UA, LLC_RSP, pollfinal);
		LLC_SETFLAG(linkp,S,1);
		break;
	case LLCFT_UA + LLC_RSP:
		if (LLC_GETFLAG(linkp,P) == pollfinal) {
			LLC_STOP_ACK_TIMER(linkp);
			LLC_RESETCOUNTER(linkp);
			LLC_UPDATE_P_FLAG(linkp,cmdrsp,pollfinal);
			LLC_SETFLAG(linkp,REMOTE_BUSY,0);
			LLC_NEWSTATE(linkp,NORMAL);
			action = LLC_CONNECT_CONFIRM;
		}
		break;
	case LLC_ACK_TIMER_EXPIRED:
		if (LLC_GETFLAG(linkp,S) == 1) {
			LLC_SETFLAG(linkp,P,0);
			LLC_SETFLAG(linkp,REMOTE_BUSY,0),
				LLC_NEWSTATE(linkp,NORMAL);
			action = LLC_CONNECT_CONFIRM;
		} else if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_SABME, LLC_CMD, pollfinal);
			LLC_SETFLAG(linkp,P,pollfinal);
			LLC_START_ACK_TIMER(linkp);
			linkp->llcl_retry++;
		} else {
			LLC_NEWSTATE(linkp,ADM);
			action = LLC_DISCONNECT_INDICATION;
		}
		break;
	case LLCFT_DISC + LLC_CMD:
		llc_send(linkp, LLCFT_DM, LLC_RSP, pollfinal);
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	case LLCFT_DM + LLC_RSP:
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	}

	return action;
}

/*
 * RESET --- As a result of a service access point user request or the receipt
 *           of a FRMR response PDU, the local connection component has sent an
 *           SABME command PDU to the remote LLC DSAP to reset the data link
 *           connection and is waiting for a reply.
 */
int
llc_state_RESET(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case LLCFT_SABME + LLC_CMD:
		LLC_RESETCOUNTER(linkp);
		LLC_SETFLAG(linkp,S,1);
		llc_send(linkp, LLCFT_UA, LLC_RSP, pollfinal);
		break;
	case LLCFT_UA + LLC_RSP:
		if (LLC_GETFLAG(linkp,P) == pollfinal) {
			LLC_STOP_ACK_TIMER(linkp);
			LLC_RESETCOUNTER(linkp);
			LLC_UPDATE_P_FLAG(linkp,cmdrsp,pollfinal);
			LLC_SETFLAG(linkp,REMOTE_BUSY,0);
			LLC_NEWSTATE(linkp,NORMAL);
			action = LLC_RESET_CONFIRM;
		}
		break;
	case LLC_ACK_TIMER_EXPIRED:
		if (LLC_GETFLAG(linkp,S) == 1) {
			LLC_SETFLAG(linkp,P,0);
			LLC_SETFLAG(linkp,REMOTE_BUSY,0);
			LLC_NEWSTATE(linkp,NORMAL);
			action = LLC_RESET_CONFIRM;
		} else if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_SABME, LLC_CMD, pollfinal);
			LLC_SETFLAG(linkp,P,pollfinal);
			LLC_START_ACK_TIMER(linkp);
			linkp->llcl_retry++;
		} else {
			LLC_NEWSTATE(linkp,ADM);
			action = LLC_DISCONNECT_INDICATION;
		}
		break;
	case LLCFT_DISC + LLC_CMD:
		llc_send(linkp, LLCFT_DM, LLC_RSP, pollfinal);
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	case LLCFT_DM + LLC_RSP:
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	}

	return action;
}

/*
 * D_CONN --- At the request of the service access point user, the local LLC
 *            has sent a DISC command PDU to the remote LLC DSAP and is waiting
 *            for a reply.
 */
int
llc_state_D_CONN(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case LLCFT_SABME + LLC_CMD:
		llc_send(linkp, LLCFT_DM, LLC_RSP, pollfinal);
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,ADM);
		break;
	case LLCFT_UA + LLC_RSP:
		if (LLC_GETFLAG(linkp,P) == pollfinal) {
			LLC_STOP_ACK_TIMER(linkp);
			LLC_NEWSTATE(linkp,ADM);
		}
		break;
	case LLCFT_DISC + LLC_CMD:
		llc_send(linkp, LLCFT_UA, LLC_RSP, pollfinal);
		break;
	case LLCFT_DM + LLC_RSP:
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,ADM);
		break;
	case LLC_ACK_TIMER_EXPIRED:
		if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_DISC, LLC_CMD, pollfinal);
			LLC_SETFLAG(linkp,P,pollfinal);
			LLC_START_ACK_TIMER(linkp);
			linkp->llcl_retry++;
		} else
			LLC_NEWSTATE(linkp,ADM);
		break;
	}

	return action;
}

/*
 * ERROR --- The local connection component has detected an error in a received
 *           PDU and has sent a FRMR response PDU. It is waiting for a reply from
 *           the remote connection component.
 */
int
llc_state_ERROR(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case LLCFT_SABME + LLC_CMD:
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,RESET_CHECK);
		action = LLC_RESET_INDICATION_REMOTE;
		break;
	case LLCFT_DISC + LLC_CMD:
		llc_send(linkp, LLCFT_UA, LLC_RSP, pollfinal);
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	case LLCFT_DM + LLC_RSP:
		LLC_STOP_ACK_TIMER(linkp);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	case LLCFT_FRMR + LLC_RSP:
		LLC_STOP_ACK_TIMER(linkp);
		LLC_SETFLAG(linkp,S,0);
		LLC_NEWSTATE(linkp,RESET_WAIT);
		action = LLC_FRMR_RECEIVED;
		break;
	case LLC_ACK_TIMER_EXPIRED:
		if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_FRMR, LLC_RSP, 0);
			LLC_START_ACK_TIMER(linkp);
			linkp->llcl_retry++;
		} else {
			LLC_SETFLAG(linkp,S,0);
			LLC_NEWSTATE(linkp,RESET_WAIT);
			action = LLC_RESET_INDICATION_LOCAL;
		}
		break;
	default:
		if (cmdrsp == LLC_CMD) {
			llc_send(linkp, LLCFT_FRMR, LLC_RSP, pollfinal);
			LLC_START_ACK_TIMER(linkp);
		}
		break;

	}

	return action;
}

/*
 * NORMAL, BUSY, REJECT, AWAIT, AWAIT_BUSY, and AWAIT_REJECT all share
 * a common core state handler.
 */
int
llc_state_NBRAcore(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = 0;

	switch (frame_kind + cmdrsp) {
	case NL_DISCONNECT_REQUEST:
		llc_send(linkp, LLCFT_DISC, LLC_CMD, pollfinal);
		LLC_SETFLAG(linkp,P,pollfinal);
		LLC_STOP_ALL_TIMERS(linkp);
		LLC_START_ACK_TIMER(linkp);
		linkp->llcl_retry = 0;
		LLC_NEWSTATE(linkp,D_CONN);
		break;
	case NL_RESET_REQUEST:
		llc_send(linkp, LLCFT_SABME, LLC_CMD, pollfinal);
		LLC_SETFLAG(linkp,P,pollfinal);
		LLC_STOP_ALL_TIMERS(linkp);
		LLC_START_ACK_TIMER(linkp);
		linkp->llcl_retry = 0;
		LLC_SETFLAG(linkp,S,0);
		LLC_NEWSTATE(linkp,RESET);
		break;
	case LLCFT_SABME + LLC_CMD:
		LLC_SETFLAG(linkp,F,pollfinal);
		LLC_STOP_ALL_TIMERS(linkp);
		LLC_NEWSTATE(linkp,RESET_CHECK);
		action = LLC_RESET_INDICATION_REMOTE;
		break;
	case LLCFT_DISC + LLC_CMD:
		llc_send(linkp, LLCFT_UA, LLC_RSP, pollfinal);
		LLC_STOP_ALL_TIMERS(linkp);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	case LLCFT_FRMR + LLC_RSP:
		LLC_STOP_ALL_TIMERS(linkp);
		LLC_SETFLAG(linkp,S,0);
		LLC_NEWSTATE(linkp,RESET_WAIT);
		action = LLC_FRMR_RECEIVED;
		break;
	case LLCFT_DM + LLC_RSP:
		LLC_STOP_ALL_TIMERS(linkp);
		LLC_NEWSTATE(linkp,ADM);
		action = LLC_DISCONNECT_INDICATION;
		break;
	case LLC_INVALID_NR + LLC_CMD:
	case LLC_INVALID_NS + LLC_CMD:
		LLC_SETFRMR(linkp, frame, cmdrsp,
			    (frame_kind == LLC_INVALID_NR ? LLC_FRMR_Z :
			     (LLC_FRMR_V | LLC_FRMR_W)));
		llc_send(linkp, LLCFT_FRMR, LLC_RSP, pollfinal);
		LLC_STOP_ALL_TIMERS(linkp);
		LLC_START_ACK_TIMER(linkp);
		linkp->llcl_retry = 0;
		LLC_NEWSTATE(linkp,ERROR);
		action = LLC_FRMR_SENT;
		break;
	case LLC_INVALID_NR + LLC_RSP:
	case LLC_INVALID_NS + LLC_RSP:
	case LLCFT_UA + LLC_RSP:
	case LLC_BAD_PDU:{
			char            frmrcause = 0;

			switch (frame_kind) {
			case LLC_INVALID_NR:
				frmrcause = LLC_FRMR_Z;
				break;
			case LLC_INVALID_NS:
				frmrcause = LLC_FRMR_V | LLC_FRMR_W;
				break;
			default:
				frmrcause = LLC_FRMR_W;
			}
			LLC_SETFRMR(linkp,frame,cmdrsp,frmrcause);
			llc_send(linkp, LLCFT_FRMR, LLC_RSP, 0);
			LLC_STOP_ALL_TIMERS(linkp);
			LLC_START_ACK_TIMER(linkp);
			linkp->llcl_retry = 0;
			LLC_NEWSTATE(linkp,ERROR);
			action = LLC_FRMR_SENT;
			break;
		}
	default:
		if (cmdrsp == LLC_RSP && pollfinal == 1 &&
		    LLC_GETFLAG(linkp,P) == 0) {
			LLC_SETFRMR(linkp,frame,cmdrsp,LLC_FRMR_W);
			LLC_STOP_ALL_TIMERS(linkp);
			LLC_START_ACK_TIMER(linkp);
			linkp->llcl_retry = 0;
			LLC_NEWSTATE(linkp,ERROR);
			action = LLC_FRMR_SENT;
		}
		break;
	case LLC_P_TIMER_EXPIRED:
	case LLC_ACK_TIMER_EXPIRED:
	case LLC_REJ_TIMER_EXPIRED:
	case LLC_BUSY_TIMER_EXPIRED:
		if (linkp->llcl_retry >= llc_n2) {
			LLC_STOP_ALL_TIMERS(linkp);
			LLC_SETFLAG(linkp,S,0);
			LLC_NEWSTATE(linkp,RESET_WAIT);
			action = LLC_RESET_INDICATION_LOCAL;
		}
		break;
	}

	return action;
}

/*
 * NORMAL --- A data link connection exists between the local LLC service access
 *            point and the remote LLC service access point. Sending and
 *            reception of information and supervisory PDUs can be performed.
 */
int
llc_state_NORMAL(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = LLC_PASSITON;

	switch (frame_kind + cmdrsp) {
	case NL_DATA_REQUEST:
		if (LLC_GETFLAG(linkp,REMOTE_BUSY) == 0) {
#ifdef not_now
			if (LLC_GETFLAG(linkp,P) == 0) {
				/* multiple possibilities */
				llc_send(linkp, LLCFT_INFO, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				if (LLC_TIMERXPIRED(linkp,ACK) !=
				    LLC_TIMER_RUNNING)
					LLC_START_ACK_TIMER(linkp);
			} else {
#endif
				/* multiple possibilities */
				llc_send(linkp, LLCFT_INFO, LLC_CMD, 0);
				if (LLC_TIMERXPIRED(linkp,ACK) !=
				    LLC_TIMER_RUNNING)
					LLC_START_ACK_TIMER(linkp);
#ifdef not_now
			}
#endif
			action = 0;
		}
		break;
	case LLC_LOCAL_BUSY_DETECTED:
		if (LLC_GETFLAG(linkp,P) == 0) {
			/* multiple possibilities --- action-wise */
			/* multiple possibilities --- CMD/RSP-wise */
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
			LLC_START_P_TIMER(linkp);
			LLC_SETFLAG(linkp,DATA,0);
			LLC_NEWSTATE(linkp,BUSY);
			action = 0;
		} else {
			/* multiple possibilities --- CMD/RSP-wise */
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
			LLC_SETFLAG(linkp,DATA,0);
			LLC_NEWSTATE(linkp,BUSY);
			action = 0;
		}
		break;
	case LLC_INVALID_NS + LLC_CMD:
	case LLC_INVALID_NS + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_REJ, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_START_REJ_TIMER(linkp);
				LLC_NEWSTATE(linkp,REJECT);
				action = 0;
			} else if (pollfinal == 0 && p == 1) {
				llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_START_REJ_TIMER(linkp);
				LLC_NEWSTATE(linkp,REJECT);
				action = 0;
			} else if ((pollfinal == 0 && p == 0) ||
			  (pollfinal == 1 && p == 1 && cmdrsp == LLC_RSP)) {
				llc_send(linkp, LLCFT_REJ, LLC_CMD, 1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_START_P_TIMER(linkp);
				LLC_START_REJ_TIMER(linkp);
				if (cmdrsp == LLC_RSP && pollfinal == 1) {
					LLC_CLEAR_REMOTE_BUSY(linkp,action);
				} else
					action = 0;
				LLC_NEWSTATE(linkp,REJECT);
			}
			break;
		}
	case LLCFT_INFO + LLC_CMD:
	case LLCFT_INFO + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = 
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				LLC_INC(linkp->llcl_vr);
				LLC_SENDACKNOWLEDGE(linkp,LLC_RSP,1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				action = LLC_DATA_INDICATION;
			} else if (pollfinal == 0 && p == 1) {
				LLC_INC(linkp->llcl_vr);
				LLC_SENDACKNOWLEDGE(linkp,LLC_CMD,0);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				action = LLC_DATA_INDICATION;
			} else if ((pollfinal == 0 && p == 0 &&
				    cmdrsp == LLC_CMD) ||
				   (pollfinal == p && cmdrsp == LLC_RSP)) {
				LLC_INC(linkp->llcl_vr);
				LLC_UPDATE_P_FLAG(linkp,cmdrsp,pollfinal);
				LLC_SENDACKNOWLEDGE(linkp,LLC_CMD,0);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (cmdrsp == LLC_RSP && pollfinal == 1)
					LLC_CLEAR_REMOTE_BUSY(linkp,action);
				action = LLC_DATA_INDICATION;
			}
			break;
		}
	case LLCFT_RR + LLC_CMD:
	case LLCFT_RR + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				LLC_SENDACKNOWLEDGE(linkp,LLC_RSP,1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_CLEAR_REMOTE_BUSY(linkp,action);
			} else if ((pollfinal == 0) ||
			  (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
				LLC_UPDATE_P_FLAG(linkp,cmdrsp,pollfinal);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_CLEAR_REMOTE_BUSY(linkp,action);
			}
			break;
		}
	case LLCFT_RNR + LLC_CMD:
	case LLCFT_RNR + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = 
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			} else if ((pollfinal == 0) ||
			  (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
				LLC_UPDATE_P_FLAG(linkp,cmdrsp,pollfinal);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			}
			break;
		}
	case LLCFT_REJ + LLC_CMD:
	case LLCFT_REJ + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				llc_resend(linkp,LLC_RSP,1);
				LLC_CLEAR_REMOTE_BUSY(linkp,action);
			} else if (pollfinal == 0 && p == 1) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp,action);
			} else if ((pollfinal == 0 && p == 0 &&
				    cmdrsp == LLC_CMD) ||
				   (pollfinal == p && cmdrsp == LLC_RSP)) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_START_P_TIMER(linkp);
				llc_resend(linkp, LLC_CMD, 1);
				LLC_CLEAR_REMOTE_BUSY(linkp,action);
			}
			break;
		}
	case NL_INITIATE_PF_CYCLE:
		if (LLC_GETFLAG(linkp,P) == 0) {
			llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			action = 0;
		}
		break;
	case LLC_P_TIMER_EXPIRED:
		if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			linkp->llcl_retry++;
			LLC_NEWSTATE(linkp,AWAIT);
			action = 0;
		}
		break;
	case LLC_ACK_TIMER_EXPIRED:
	case LLC_BUSY_TIMER_EXPIRED:
		if ((LLC_GETFLAG(linkp,P) == 0)
		    && (linkp->llcl_retry < llc_n2)) {
			llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			linkp->llcl_retry++;
			LLC_NEWSTATE(linkp,AWAIT);
			action = 0;
		}
		break;
	}
	if (action == LLC_PASSITON)
		action = llc_state_NBRAcore(linkp, frame, frame_kind,
					    cmdrsp, pollfinal);

	return action;
}

/*
 * BUSY --- A data link connection exists between the local LLC service access
 *          point and the remote LLC service access point. I PDUs may be sent.
 *          Local conditions make it likely that the information feld of
 *          received I PDUs will be ignored. Supervisory PDUs may be both sent
 *          and received.
 */
int
llc_state_BUSY(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = LLC_PASSITON;

	switch (frame_kind + cmdrsp) {
	case NL_DATA_REQUEST:
		if (LLC_GETFLAG(linkp,REMOTE_BUSY) == 0) {
			if (LLC_GETFLAG(linkp,P) == 0) {
				llc_send(linkp, LLCFT_INFO, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				if (LLC_TIMERXPIRED(linkp,ACK) !=
				    LLC_TIMER_RUNNING)
					LLC_START_ACK_TIMER(linkp);
				action = 0;
			} else {
				llc_send(linkp, LLCFT_INFO, LLC_CMD, 0);
				if (LLC_TIMERXPIRED(linkp,ACK) !=
				    LLC_TIMER_RUNNING)
					LLC_START_ACK_TIMER(linkp);
				action = 0;
			}
		}
		break;
	case LLC_LOCAL_BUSY_CLEARED:{
			int    p = LLC_GETFLAG(linkp,P);
			int    df = LLC_GETFLAG(linkp,DATA);

			switch (df) {
			case 1:
				if (p == 0) {
					/* multiple possibilities */
					llc_send(linkp, LLCFT_REJ, LLC_CMD, 1);
					LLC_START_REJ_TIMER(linkp);
					LLC_START_P_TIMER(linkp);
					LLC_NEWSTATE(linkp,REJECT);
					action = 0;
				} else {
					llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
					LLC_START_REJ_TIMER(linkp);
					LLC_NEWSTATE(linkp,REJECT);
					action = 0;
				}
				break;
			case 0:
				if (p == 0) {
					/* multiple possibilities */
					llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
					LLC_START_P_TIMER(linkp);
					LLC_NEWSTATE(linkp,NORMAL);
					action = 0;
				} else {
					llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
					LLC_NEWSTATE(linkp,NORMAL);
					action = 0;
				}
				break;
			case 2:
				if (p == 0) {
					/* multiple possibilities */
					llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
					LLC_START_P_TIMER(linkp);
					LLC_NEWSTATE(linkp,REJECT);
					action = 0;
				} else {
					llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
					LLC_NEWSTATE(linkp,REJECT);
					action = 0;
				}
				break;
			}
			break;
		}
	case LLC_INVALID_NS + LLC_CMD:
	case LLC_INVALID_NS + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = 
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (LLC_GETFLAG(linkp,DATA) == 0)
					LLC_SETFLAG(linkp,DATA,1);
				action = 0;
			} else if ((cmdrsp == LLC_CMD && pollfinal == 0 &&
				    p == 0) ||
				   (cmdrsp == LLC_RSP && pollfinal == p)) {
				llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
				LLC_UPDATE_P_FLAG(linkp,cmdrsp,pollfinal);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (LLC_GETFLAG(linkp,DATA) == 0)
					LLC_SETFLAG(linkp,DATA,1);
				if (cmdrsp == LLC_RSP && pollfinal == 1) {
					LLC_CLEAR_REMOTE_BUSY(linkp,action);
				} else
					action = 0;
			} else if (pollfinal == 0 && p == 1) {
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (LLC_GETFLAG(linkp,DATA) == 0)
					LLC_SETFLAG(linkp,DATA,1);
				action = 0;
			}
			break;
		}
	case LLCFT_INFO + LLC_CMD:
	case LLCFT_INFO + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
				LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				LLC_INC(linkp->llcl_vr);
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (LLC_GETFLAG(linkp,DATA) == 2)
					LLC_STOP_REJ_TIMER(linkp);
				LLC_SETFLAG(linkp,DATA,0);
				action = LLC_DATA_INDICATION;
			} else if ((cmdrsp == LLC_CMD && pollfinal == 0 && p == 0) ||
				   (cmdrsp == LLC_RSP && pollfinal == p)) {
				LLC_INC(linkp->llcl_vr);
				llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (LLC_GETFLAG(linkp,DATA) == 2)
					LLC_STOP_REJ_TIMER(linkp);
				if (cmdrsp == LLC_RSP && pollfinal == 1)
					LLC_CLEAR_REMOTE_BUSY(linkp,action);
				action = LLC_DATA_INDICATION;
			} else if (pollfinal == 0 && p == 1) {
				LLC_INC(linkp->llcl_vr);
				llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (LLC_GETFLAG(linkp,DATA) == 2)
					LLC_STOP_REJ_TIMER(linkp);
				LLC_SETFLAG(linkp,DATA,0);
				action = LLC_DATA_INDICATION;
			}
			break;
		}
	case LLCFT_RR + LLC_CMD:
	case LLCFT_RR + LLC_RSP:
	case LLCFT_RNR + LLC_CMD:
	case LLCFT_RNR + LLC_RSP:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr =
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (frame_kind == LLCFT_RR) {
					LLC_CLEAR_REMOTE_BUSY(linkp,action);
				} else {
					LLC_SET_REMOTE_BUSY(linkp,action);
				}
			} else if (pollfinal == 0 ||
				   (cmdrsp == LLC_RSP && pollfinal == 1)) {
				LLC_UPDATE_P_FLAG(linkp,cmdrsp,pollfinal);
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				if (frame_kind == LLCFT_RR) {
					LLC_CLEAR_REMOTE_BUSY(linkp,action);
				} else {
					LLC_SET_REMOTE_BUSY(linkp,action);
				}
			}
			break;
		}
	case LLCFT_REJ + LLC_CMD:
	case LLCFT_REJ + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp,action);
			} else if ((cmdrsp == LLC_CMD && pollfinal == 0 &&
				    p == 0) ||
				   (cmdrsp == LLC_RSP && pollfinal == p)) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				LLC_UPDATE_P_FLAG(linkp,cmdrsp,pollfinal);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp,action);
			} else if (pollfinal == 0 && p == 1) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp,nr);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp,action);
			}
			break;
		}
	case NL_INITIATE_PF_CYCLE:
		if (LLC_GETFLAG(linkp,P) == 0) {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			action = 0;
		}
		break;
	case LLC_P_TIMER_EXPIRED:
		/* multiple possibilities */
		if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			linkp->llcl_retry++;
			LLC_NEWSTATE(linkp,AWAIT_BUSY);
			action = 0;
		}
		break;
	case LLC_ACK_TIMER_EXPIRED:
	case LLC_BUSY_TIMER_EXPIRED:
		if (LLC_GETFLAG(linkp,P) == 0 && linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			linkp->llcl_retry++;
			LLC_NEWSTATE(linkp,AWAIT_BUSY);
			action = 0;
		}
		break;
	case LLC_REJ_TIMER_EXPIRED:
		if (linkp->llcl_retry < llc_n2) {
			if (LLC_GETFLAG(linkp,P) == 0) {
				/* multiple possibilities */
				llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				linkp->llcl_retry++;
				LLC_SETFLAG(linkp,DATA,1);
				LLC_NEWSTATE(linkp,AWAIT_BUSY);
				action = 0;
			} else {
				LLC_SETFLAG(linkp,DATA,1);
				LLC_NEWSTATE(linkp,BUSY);
				action = 0;
			}
		}
		break;
	}
	if (action == LLC_PASSITON)
		action = llc_state_NBRAcore(linkp, frame, frame_kind,
					    cmdrsp, pollfinal);

	return action;
}

/*
 * REJECT --- A data link connection exists between the local LLC service
 *            access point and the remote LLC service access point. The local
 *            connection component has requested that the remote connection
 *            component resend a specific I PDU that the local connection
 *            componnent has detected as being out of sequence. Both I PDUs and
 *            supervisory PDUs may be sent and received.
 */
int
llc_state_REJECT(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = LLC_PASSITON;

	switch (frame_kind + cmdrsp) {
	case NL_DATA_REQUEST:
		if (LLC_GETFLAG(linkp,P) == 0) {
			llc_send(linkp, LLCFT_INFO, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			if (LLC_TIMERXPIRED(linkp,ACK) != LLC_TIMER_RUNNING)
				LLC_START_ACK_TIMER(linkp);
			LLC_NEWSTATE(linkp,REJECT);
			action = 0;
		} else {
			llc_send(linkp, LLCFT_INFO, LLC_CMD, 0);
			if (LLC_TIMERXPIRED(linkp,ACK) != LLC_TIMER_RUNNING)
				LLC_START_ACK_TIMER(linkp);
			LLC_NEWSTATE(linkp,REJECT);
			action = 0;
		}
		break;
	case NL_LOCAL_BUSY_DETECTED:
		if (LLC_GETFLAG(linkp,P) == 0) {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_SETFLAG(linkp,DATA,2);
			LLC_NEWSTATE(linkp,BUSY);
			action = 0;
		} else {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
			LLC_SETFLAG(linkp,DATA,2);
			LLC_NEWSTATE(linkp,BUSY);
			action = 0;
		}
		break;
	case LLC_INVALID_NS + LLC_CMD:
	case LLC_INVALID_NS + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				action = 0;
			} else if (pollfinal == 0 ||
			  (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
				if (cmdrsp == LLC_RSP && pollfinal == 1) {
					LLC_CLEAR_REMOTE_BUSY(linkp, action);
				} else
					action = 0;
			}
			break;
		}
	case LLCFT_INFO + LLC_CMD:
	case LLCFT_INFO + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				LLC_INC(linkp->llcl_vr);
				LLC_SENDACKNOWLEDGE(linkp, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_STOP_REJ_TIMER(linkp);
				LLC_NEWSTATE(linkp,NORMAL);
				action = LLC_DATA_INDICATION;
			} else if ((cmdrsp = LLC_RSP && pollfinal == p) ||
			  (cmdrsp == LLC_CMD && pollfinal == 0 && p == 0)) {
				LLC_INC(linkp->llcl_vr);
				LLC_SENDACKNOWLEDGE(linkp, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				if (cmdrsp == LLC_RSP && pollfinal == 1)
					LLC_CLEAR_REMOTE_BUSY(linkp, action);
				LLC_STOP_REJ_TIMER(linkp);
				LLC_NEWSTATE(linkp,NORMAL);
				action = LLC_DATA_INDICATION;
			} else if (pollfinal == 0 && p == 1) {
				LLC_INC(linkp->llcl_vr);
				LLC_SENDACKNOWLEDGE(linkp, LLC_CMD, 0);
				LLC_STOP_REJ_TIMER(linkp);
				LLC_NEWSTATE(linkp,NORMAL);
				action = LLC_DATA_INDICATION;
			}
			break;
		}
	case LLCFT_RR + LLC_CMD:
	case LLCFT_RR + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				LLC_SENDACKNOWLEDGE(linkp, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else if (pollfinal == 0 ||
			  (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
				LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			}
			break;
		}
	case LLCFT_RNR + LLC_CMD:
	case LLCFT_RNR + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			} else if (pollfinal == 0 ||
			  (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
				LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				action = 0;
			}
			break;
		}
	case LLCFT_REJ + LLC_CMD:
	case LLCFT_REJ + LLC_RSP:{
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				llc_resend(linkp, LLC_RSP, 1);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else if ((cmdrsp == LLC_CMD && pollfinal == 0 && p == 0) ||
				   (cmdrsp == LLC_RSP && pollfinal == p)) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else if (pollfinal == 0 && p == 1) {
				linkp->llcl_vs = nr;
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			}
			break;
		}
	case NL_INITIATE_PF_CYCLE:
		if (LLC_GETFLAG(linkp,P) == 0) {
			llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			action = 0;
		}
		break;
	case LLC_REJ_TIMER_EXPIRED:
		if (LLC_GETFLAG(linkp,P) == 0 && linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_REJ, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_START_REJ_TIMER(linkp);
			linkp->llcl_retry++;
			action = 0;
		}
	case LLC_P_TIMER_EXPIRED:
		if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_START_REJ_TIMER(linkp);
			linkp->llcl_retry++;
			LLC_NEWSTATE(linkp,AWAIT_REJECT);
			action = 0;
		}
		break;
	case LLC_ACK_TIMER_EXPIRED:
	case LLC_BUSY_TIMER_EXPIRED:
		if (LLC_GETFLAG(linkp,P) == 0 && linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_START_REJ_TIMER(linkp);
			linkp->llcl_retry++;
			/*
			 * I cannot locate the description of RESET_V(S) in
			 * ISO 8802-2, table 7-1, state REJECT, last event,
			 * and  assume they meant to set V(S) to 0 ...
			 */
			linkp->llcl_vs = 0;	/* XXX */
			LLC_NEWSTATE(linkp,AWAIT_REJECT);
			action = 0;
		}
		break;
	}
	if (action == LLC_PASSITON)
		action = llc_state_NBRAcore(linkp, frame, frame_kind,
					    cmdrsp, pollfinal);

	return action;
}

/*
 * AWAIT --- A data link connection exists between the local LLC service access
 *           point and the remote LLC service access point. The local LLC is
 *           performing a timer recovery operation and has sent a command PDU
 *           with the P bit set to ``1'', and is awaiting an acknowledgement
 *           from the remote LLC. I PDUs may be received but not sent.
 *           Supervisory PDUs may be both sent and received.
 */
int
llc_state_AWAIT(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = LLC_PASSITON;

	switch (frame_kind + cmdrsp) {
	case LLC_LOCAL_BUSY_DETECTED:
		llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
		LLC_SETFLAG(linkp,DATA,0);
		LLC_NEWSTATE(linkp,AWAIT_BUSY);
		action = 0;
		break;
	case LLC_INVALID_NS + LLC_CMD:
	case LLC_INVALID_NS + LLC_RSP:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_REJ, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_START_REJ_TIMER(linkp);
				LLC_NEWSTATE(linkp,AWAIT_REJECT);
				action = 0;
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_STOP_P_TIMER(linkp);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_START_REJ_TIMER(linkp);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				LLC_NEWSTATE(linkp,REJECT);
			} else if (pollfinal == 0) {
				llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_START_REJ_TIMER(linkp);
				LLC_NEWSTATE(linkp,AWAIT_REJECT);
				action = 0;
			}
			break;
		}
	case LLCFT_INFO + LLC_RSP:
	case LLCFT_INFO + LLC_CMD:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			LLC_INC(linkp->llcl_vr);
			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				action = LLC_DATA_INDICATION;
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				llc_resend(linkp, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				LLC_NEWSTATE(linkp,NORMAL);
				action = LLC_DATA_INDICATION;
			} else if (pollfinal == 0) {
				llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				action = LLC_DATA_INDICATION;
			}
			break;
		}
	case LLCFT_RR + LLC_CMD:
	case LLCFT_RR + LLC_RSP:
	case LLCFT_REJ + LLC_CMD:
	case LLCFT_REJ + LLC_RSP:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_STOP_P_TIMER(linkp);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				LLC_NEWSTATE(linkp,NORMAL);
			} else if (pollfinal == 0) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			}
			break;
		}
	case LLCFT_RNR + LLC_CMD:
	case LLCFT_RNR + LLC_RSP:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (pollfinal == 1 && cmdrsp == LLC_CMD) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			} else if (pollfinal == 1 && cmdrsp == LLC_RSP) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_STOP_P_TIMER(linkp);
				LLC_SET_REMOTE_BUSY(linkp,action);
				LLC_NEWSTATE(linkp,NORMAL);
			} else if (pollfinal == 0) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			}
			break;
		}
	case LLC_P_TIMER_EXPIRED:
		if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			linkp->llcl_retry++;
			action = 0;
		}
		break;
	}
	if (action == LLC_PASSITON)
		action = llc_state_NBRAcore(linkp, frame, frame_kind,
					    cmdrsp, pollfinal);

	return action;
}

/*
 * AWAIT_BUSY --- A data link connection exists between the local LLC service
 *                access point and the remote LLC service access point. The
 *                local LLC is performing a timer recovery operation and has
 *                sent a command PDU with the P bit set to ``1'', and is
 *                awaiting an acknowledgement from the remote LLC. I PDUs may
 *                not be sent. Local conditions make it likely that the
 *                information feld of receoved I PDUs will be ignored.
 *                Supervisory PDUs may be both sent and received.
 */
int
llc_state_AWAIT_BUSY(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = LLC_PASSITON;

	switch (frame_kind + cmdrsp) {
	case LLC_LOCAL_BUSY_CLEARED:
		switch (LLC_GETFLAG(linkp,DATA)) {
		case 1:
			llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
			LLC_START_REJ_TIMER(linkp);
			LLC_NEWSTATE(linkp,AWAIT_REJECT);
			action = 0;
			break;
		case 0:
			llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
			LLC_NEWSTATE(linkp,AWAIT);
			action = 0;
			break;
		case 2:
			llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
			LLC_NEWSTATE(linkp,AWAIT_REJECT);
			action = 0;
			break;
		}
		break;
	case LLC_INVALID_NS + LLC_CMD:
	case LLC_INVALID_NS + LLC_RSP:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SETFLAG(linkp,DATA,1);
				action = 0;
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				/* optionally */
				llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_STOP_P_TIMER(linkp);
				LLC_SETFLAG(linkp,DATA,1);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_NEWSTATE(linkp,BUSY);
			} else if (pollfinal == 0) {
				/* optionally */
				llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SETFLAG(linkp,DATA,1);
				action = 0;
			}
		}
	case LLCFT_INFO + LLC_CMD:
	case LLCFT_INFO + LLC_RSP:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				LLC_INC(linkp->llcl_vr);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SETFLAG(linkp,DATA,0);
				action = LLC_DATA_INDICATION;
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
				LLC_INC(linkp->llcl_vr);
				LLC_START_P_TIMER(linkp);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_SETFLAG(linkp,DATA,0);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_NEWSTATE(linkp,BUSY);
				action = LLC_DATA_INDICATION;
			} else if (pollfinal == 0) {
				llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
				LLC_INC(linkp->llcl_vr);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SETFLAG(linkp,DATA,0);
				action = LLC_DATA_INDICATION;
			}
			break;
		}
	case LLCFT_RR + LLC_CMD:
	case LLCFT_REJ + LLC_CMD:
	case LLCFT_RR + LLC_RSP:
	case LLCFT_REJ + LLC_RSP:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_STOP_P_TIMER(linkp);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				LLC_NEWSTATE(linkp,BUSY);
			} else if (pollfinal == 0) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_STOP_P_TIMER(linkp);
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			}
			break;
		}
	case LLCFT_RNR + LLC_CMD:
	case LLCFT_RNR + LLC_RSP:{
#if 0
			int    p = LLC_GETFLAG(linkp,P);
#endif
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_STOP_P_TIMER(linkp);
				LLC_SET_REMOTE_BUSY(linkp,action);
				LLC_NEWSTATE(linkp,BUSY);
			} else if (pollfinal == 0) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			}
			break;
		}
	case LLC_P_TIMER_EXPIRED:
		if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			linkp->llcl_retry++;
			action = 0;
		}
		break;
	}
	if (action == LLC_PASSITON)
		action = llc_state_NBRAcore(linkp, frame, frame_kind,
					    cmdrsp, pollfinal);

	return action;
}

/*
 * AWAIT_REJECT --- A data link connection exists between the local LLC service
 *                  access point and the remote LLC service access point. The
 *                  local connection component has requested that the remote
 *                  connection component re-transmit a specific I PDU that the
 *                  local connection component has detected as being out of
 *                  sequence. Before the local LLC entered this state it was
 *                  performing a timer recovery operation and had sent a
 *                  command PDU with the P bit set to ``1'', and is still
 *                  awaiting an acknowledgment from the remote LLC. I PDUs may
 *                  be received but not transmitted. Supervisory PDUs may be
 *                  both transmitted and received.
 */
int
llc_state_AWAIT_REJECT(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int             action = LLC_PASSITON;

	switch (frame_kind + cmdrsp) {
	case LLC_LOCAL_BUSY_DETECTED:
		llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
		LLC_SETFLAG(linkp,DATA,2);
		LLC_NEWSTATE(linkp,AWAIT_BUSY);
		action = 0;
		break;
	case LLC_INVALID_NS + LLC_CMD:
	case LLC_INVALID_NS + LLC_RSP:{
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				action = 0;
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				llc_resend(linkp, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				LLC_NEWSTATE(linkp,REJECT);
			} else if (pollfinal == 0) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				action = 0;
			}
			break;
		}
	case LLCFT_INFO + LLC_CMD:
	case LLCFT_INFO + LLC_RSP:{
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				LLC_INC(linkp->llcl_vr);
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_STOP_REJ_TIMER(linkp);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_NEWSTATE(linkp,AWAIT);
				action = LLC_DATA_INDICATION;
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_INC(linkp->llcl_vr);
				LLC_STOP_P_TIMER(linkp);
				LLC_STOP_REJ_TIMER(linkp);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				llc_resend(linkp, LLC_CMD, 0);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				LLC_NEWSTATE(linkp,NORMAL);
				action = LLC_DATA_INDICATION;
			} else if (pollfinal == 0) {
				LLC_INC(linkp->llcl_vr);
				llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
				LLC_STOP_REJ_TIMER(linkp);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_NEWSTATE(linkp,AWAIT);
				action = LLC_DATA_INDICATION;
			}
			break;
		}
	case LLCFT_RR + LLC_CMD:
	case LLCFT_REJ + LLC_CMD:
	case LLCFT_RR + LLC_RSP:
	case LLCFT_REJ + LLC_RSP:{
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				llc_resend(linkp, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
				LLC_NEWSTATE(linkp,REJECT);
			} else if (pollfinal == 0) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			}
			break;
		}
	case LLCFT_RNR + LLC_CMD:
	case LLCFT_RNR + LLC_RSP:{
			int    nr =
				LLCGBITS(frame->llc_control_ext,s_nr);

			if (cmdrsp == LLC_CMD && pollfinal == 1) {
				llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				linkp->llcl_vs = nr;
				LLC_STOP_P_TIMER(linkp);
				LLC_SET_REMOTE_BUSY(linkp,action);
				LLC_NEWSTATE(linkp,REJECT);
			} else if (pollfinal == 0) {
				LLC_UPDATE_NR_RECEIVED(linkp, nr);
				LLC_SET_REMOTE_BUSY(linkp,action);
			}
			break;
		}
	case LLC_P_TIMER_EXPIRED:
		if (linkp->llcl_retry < llc_n2) {
			llc_send(linkp, LLCFT_REJ, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			linkp->llcl_retry++;
			action = 0;
		}
		break;
	}
	if (action == LLC_PASSITON)
		action = llc_state_NBRAcore(linkp, frame, frame_kind,
					    cmdrsp, pollfinal);

	return action;
}


/*
 * llc_statehandler() --- Wrapper for llc_state_*() functions.
 *                         Deals with action codes and checks for
 *                         ``stuck'' links.
 */

int
llc_statehandler(linkp, frame, frame_kind, cmdrsp, pollfinal)
	struct llc_linkcb *linkp;
	struct llc *frame;
	int frame_kind;
	int cmdrsp;
	int pollfinal;
{
	int    action = 0;

	/*
	 * To check for ``zombie'' links each time llc_statehandler() gets called
	 * the AGE timer of linkp is reset. If it expires llc_timer() will
	 * take care of the link --- i.e. kill it 8=)
	 */
	LLC_STARTTIMER(linkp,AGE);

	/*
	 * Now call the current statehandler function.
	 */
	action = (*linkp->llcl_statehandler) (linkp, frame, frame_kind,
					      cmdrsp, pollfinal);
once_more_and_again:
	switch (action) {
	case LLC_CONNECT_INDICATION:{
			int             naction;

			LLC_TRACE(linkp, LLCTR_INTERESTING, "CONNECT INDICATION");
			linkp->llcl_nlnext =
				(*linkp->llcl_sapinfo->si_ctlinput)
				(PRC_CONNECT_INDICATION,
				 (struct sockaddr *) & linkp->llcl_addr, (caddr_t) linkp);
			if (linkp->llcl_nlnext == 0)
				naction = NL_DISCONNECT_REQUEST;
			else
				naction = NL_CONNECT_RESPONSE;
			action = (*linkp->llcl_statehandler) (linkp, frame, naction, 0, 0);
			goto once_more_and_again;
		}
	case LLC_CONNECT_CONFIRM:
		/* llc_resend(linkp, LLC_CMD, 0); */
		llc_start(linkp);
		break;
	case LLC_DISCONNECT_INDICATION:
		LLC_TRACE(linkp, LLCTR_INTERESTING, "DISCONNECT INDICATION");
		(*linkp->llcl_sapinfo->si_ctlinput)
			(PRC_DISCONNECT_INDICATION,
		(struct sockaddr *) & linkp->llcl_addr, linkp->llcl_nlnext);
		break;
		/* internally visible only */
	case LLC_RESET_CONFIRM:
	case LLC_RESET_INDICATION_LOCAL:
		/*
		 * not much we can do here, the state machine either makes it or
		 * brakes it ...
		 */
		break;
	case LLC_RESET_INDICATION_REMOTE:
		LLC_TRACE(linkp, LLCTR_SHOULDKNOW, "RESET INDICATION (REMOTE)");
		action = (*linkp->llcl_statehandler) (linkp, frame,
						   NL_RESET_RESPONSE, 0, 0);
		goto once_more_and_again;
	case LLC_FRMR_SENT:
		LLC_TRACE(linkp, LLCTR_URGENT, "FRMR SENT");
		break;
	case LLC_FRMR_RECEIVED:
		LLC_TRACE(linkp, LLCTR_URGEN, "FRMR RECEIVED");
		action = (*linkp->llcl_statehandler) (linkp, frame,
						    NL_RESET_REQUEST, 0, 0);

		goto once_more_and_again;
	case LLC_REMOTE_BUSY:
		LLC_TRACE(linkp, LLCTR_SHOULDKNOW, "REMOTE BUSY");
		break;
	case LLC_REMOTE_NOT_BUSY:
		LLC_TRACE(linkp, LLCTR_SHOULDKNOW, "REMOTE BUSY CLEARED");
		/*
		 * try to get queued frames out
		 */
		llc_start(linkp);
		break;
	}

	/*
         * Only LLC_DATA_INDICATION is for the time being
	 * passed up to the network layer entity.
	 * The remaining action codes are for the time
	 * being visible internally only.
         * However, this can/may be changed if necessary.
	 */

	return action;
}


/*
 * Core LLC2 routines
 */

/*
 * The INIT call. This routine is called once after the system is booted.
 */

void
llc_init()
{
	llcintrq.ifq_maxlen = IFQ_MAXLEN;
}


/*
 * In case of a link reset we need to shuffle the frames queued inside the
 * LLC2 window.
 */

void
llc_resetwindow(linkp)
	struct llc_linkcb *linkp;
{
	struct mbuf *mptr = (struct mbuf *) 0;
	struct mbuf *anchor = (struct mbuf *) 0;
	short  i;

	/* Pick up all queued frames and collect them in a linked mbuf list */
	if (linkp->llcl_slotsfree != linkp->llcl_window) {
		i = llc_seq2slot(linkp, linkp->llcl_nr_received);
		anchor = mptr = linkp->llcl_output_buffers[i];
		for (; i != linkp->llcl_freeslot;
		     i = llc_seq2slot(linkp, i + 1)) {
			if (linkp->llcl_output_buffers[i]) {
				mptr->m_nextpkt = linkp->llcl_output_buffers[i];
				mptr = mptr->m_nextpkt;
			} else
				panic("LLC2 window broken");
		}
	}
	/* clean closure */
	if (mptr)
		mptr->m_nextpkt = (struct mbuf *) 0;

	/* Now --- plug 'em in again */
	if (anchor != (struct mbuf *) 0) {
		for (i = 0, mptr = anchor; mptr != (struct mbuf *) 0; i++) {
			linkp->llcl_output_buffers[i] = mptr;
			mptr = mptr->m_nextpkt;
			linkp->llcl_output_buffers[i]->m_nextpkt = (struct mbuf *) 0;
		}
		linkp->llcl_freeslot = i;
	} else
		linkp->llcl_freeslot = 0;

	/* We're resetting the link, the next frame to be acknowledged is 0 */
	linkp->llcl_nr_received = 0;

	/*
	 * set distance between LLC2 sequence number and the top of window to
	 * 0
	 */
	linkp->llcl_projvs = linkp->llcl_freeslot;

	return;
}

/*
 * llc_newlink() --- We allocate enough memory to contain a link control block
 *                   and initialize it properly. We don't intiate the actual
 *		     setup of the LLC2 link here.
 */
struct llc_linkcb *
llc_newlink(dst, ifp, nlrt, nlnext, llrt)
	struct sockaddr_dl *dst;
	struct ifnet *ifp;
	struct rtentry *nlrt;
	caddr_t nlnext;
	struct rtentry *llrt;
{
	struct llc_linkcb *nlinkp;
	u_char          sap = LLSAPADDR(dst);
	short           llcwindow;


	/* allocate memory for link control block */
	MALLOC(nlinkp, struct llc_linkcb *, sizeof(struct llc_linkcb),
	       M_PCB, M_DONTWAIT);
	if (nlinkp == 0)
		return (NULL);
	bzero((caddr_t) nlinkp, sizeof(struct llc_linkcb));

	/* copy link address */
	sdl_copy(dst, &nlinkp->llcl_addr);

	/* hold on to the network layer route entry */
	nlinkp->llcl_nlrt = nlrt;

	/* likewise the network layer control block */
	nlinkp->llcl_nlnext = nlnext;

	/* jot down the link layer route entry */
	nlinkp->llcl_llrt = llrt;

	/* reset writeq */
	nlinkp->llcl_writeqh = nlinkp->llcl_writeqt = NULL;

	/* setup initial state handler function */
	nlinkp->llcl_statehandler = llc_state_ADM;

	/* hold on to interface pointer */
	nlinkp->llcl_if = ifp;

	/* get service access point information */
	nlinkp->llcl_sapinfo = llc_getsapinfo(sap, ifp);

	/* get window size from SAP info block */
	if ((llcwindow = nlinkp->llcl_sapinfo->si_window) == 0)
		llcwindow = LLC_MAX_WINDOW;

	/* allocate memory for window buffer */
	MALLOC(nlinkp->llcl_output_buffers, struct mbuf **,
	       llcwindow * sizeof(struct mbuf *), M_PCB, M_DONTWAIT);
	if (nlinkp->llcl_output_buffers == 0) {
		FREE(nlinkp, M_PCB);
		return (NULL);
	}
	bzero((caddr_t) nlinkp->llcl_output_buffers,
	      llcwindow * sizeof(struct mbuf *));

	/* set window size & slotsfree */
	nlinkp->llcl_slotsfree = nlinkp->llcl_window = llcwindow;

	/* enter into linked listed of link control blocks */
	insque(nlinkp, &llccb_q);

	return (nlinkp);
}

/*
 * llc_dellink() --- farewell to link control block
 */
void
llc_dellink(linkp)
	struct llc_linkcb *linkp;
{
	struct mbuf *m;
	struct mbuf *n;
	struct npaidbentry *sapinfo = linkp->llcl_sapinfo;
	int    i;

	/* notify upper layer of imminent death */
	if (linkp->llcl_nlnext && sapinfo->si_ctlinput)
		(*sapinfo->si_ctlinput)
			(PRC_DISCONNECT_INDICATION,
		(struct sockaddr *) & linkp->llcl_addr, linkp->llcl_nlnext);

	/* pull the plug */
	if (linkp->llcl_llrt)
		((struct npaidbentry *) (linkp->llcl_llrt->rt_llinfo))->np_link
			= (struct llc_linkcb *) 0;

	/* leave link control block queue */
	remque(linkp);

	/* drop queued packets */
	for (m = linkp->llcl_writeqh; m;) {
		n = m->m_act;
		m_freem(m);
		m = n;
	}

	/* drop packets in the window */
	for (i = 0; i < linkp->llcl_window; i++)
		if (linkp->llcl_output_buffers[i])
			m_freem(linkp->llcl_output_buffers[i]);

	/* return the window space */
	FREE((caddr_t) linkp->llcl_output_buffers, M_PCB);

	/* return the control block space --- now it's gone ... */
	FREE((caddr_t) linkp, M_PCB);
}

int
llc_decode(frame, linkp)
	struct llc *frame;
	struct llc_linkcb *linkp;
{
	int    ft = LLC_BAD_PDU;

	if ((frame->llc_control & 01) == 0) {
		ft = LLCFT_INFO;
		/* S or U frame ? */
	} else
		switch (frame->llc_control) {

			/* U frames */
		case LLC_UI:
		case LLC_UI_P:
			ft = LLC_UI;
			break;
		case LLC_DM:
		case LLC_DM_P:
			ft = LLCFT_DM;
			break;
		case LLC_DISC:
		case LLC_DISC_P:
			ft = LLCFT_DISC;
			break;
		case LLC_UA:
		case LLC_UA_P:
			ft = LLCFT_UA;
			break;
		case LLC_SABME:
		case LLC_SABME_P:
			ft = LLCFT_SABME;
			break;
		case LLC_FRMR:
		case LLC_FRMR_P:
			ft = LLCFT_FRMR;
			break;
		case LLC_XID:
		case LLC_XID_P:
			ft = LLCFT_XID;
			break;
		case LLC_TEST:
		case LLC_TEST_P:
			ft = LLCFT_TEST;
			break;

			/* S frames */
		case LLC_RR:
			ft = LLCFT_RR;
			break;
		case LLC_RNR:
			ft = LLCFT_RNR;
			break;
		case LLC_REJ:
			ft = LLCFT_REJ;
			break;
		}		/* switch */

	if (linkp) {
		switch (ft) {
		case LLCFT_INFO:
			if (LLCGBITS(frame->llc_control,i_ns) !=
			    linkp->llcl_vr) {
				ft = LLC_INVALID_NS;
				break;
			}
			/* fall thru --- yeeeeeee */
		case LLCFT_RR:
		case LLCFT_RNR:
		case LLCFT_REJ:
			/* splash! */
			if (LLC_NR_VALID(linkp,
					 LLCGBITS(frame->llc_control_ext,s_nr))
					 == 0)
				ft = LLC_INVALID_NR;
			break;
		}
	}
	return ft;
}

/*
 * llc_anytimersup() --- Checks if at least one timer is still up and running.
 */
int
llc_anytimersup(linkp)
	struct llc_linkcb *linkp;
{
	int    i;

	FOR_ALL_LLC_TIMERS(i)
		if (linkp->llcl_timers[i] > 0)
		break;
	if (i == LLC_AGE_SHIFT)
		return 0;
	else
		return 1;
}

/*
 * llc_link_dump() - dump link info
 */

#define SAL(s) ((struct sockaddr_dl *)&(s)->llcl_addr)
#define CHECK(l,s) if (LLC_STATEEQ(l,s)) return __STRING(s)

char *timer_names[] = {"ACK", "P", "BUSY", "REJ", "AGE"};

char *
llc_getstatename(linkp)
	struct llc_linkcb *linkp;
{
	CHECK(linkp,ADM);
	CHECK(linkp,CONN);
	CHECK(linkp,RESET_WAIT);
	CHECK(linkp,RESET_CHECK);
	CHECK(linkp,SETUP);
	CHECK(linkp,RESET);
	CHECK(linkp,D_CONN);
	CHECK(linkp,ERROR);
	CHECK(linkp,NORMAL);
	CHECK(linkp,BUSY);
	CHECK(linkp,REJECT);
	CHECK(linkp,AWAIT);
	CHECK(linkp,AWAIT_BUSY);
	CHECK(linkp,AWAIT_REJECT);

	return "UNKNOWN - eh?";
}

void
llc_link_dump(linkp, message)
	struct llc_linkcb *linkp;
	const char *message;
{
	int    i;

	/* print interface */
	printf("if %s\n", linkp->llcl_if->if_xname);

	/* print message */
	printf(">> %s <<\n", message);

	/* print MAC and LSAP */
	printf("llc addr ");
	for (i = 0; i < (SAL(linkp)->sdl_alen) - 2; i++)
		printf("%x:", (char) *(LLADDR(SAL(linkp)) + i) & 0xff);
	printf("%x,", (char) *(LLADDR(SAL(linkp)) + i) & 0xff);
	printf("%x\n", (char) *(LLADDR(SAL(linkp)) + i + 1) & 0xff);

	/* print state we're in and timers */
	printf("state %s, ", llc_getstatename(linkp));
	for (i = LLC_ACK_SHIFT; i < LLC_AGE_SHIFT; i++)
		printf("%s-%c %d/", timer_names[i],
		       (linkp->llcl_timerflags & (1 << i) ? 'R' : 'S'),
		       linkp->llcl_timers[i]);
	printf("%s-%c %d\n", timer_names[i], (linkp->llcl_timerflags & (1 << i) ?
					 'R' : 'S'), linkp->llcl_timers[i]);

	/* print flag values */
	printf("flags P %d/F %d/S %d/DATA %d/REMOTE_BUSY %d\n",
	       LLC_GETFLAG(linkp,P), LLC_GETFLAG(linkp,F),
	       LLC_GETFLAG(linkp,S),
	       LLC_GETFLAG(linkp,DATA), LLC_GETFLAG(linkp,REMOTE_BUSY));

	/* print send and receive state variables, ack, and window */
	printf("V(R) %d/V(S) %d/N(R) received %d/window %d/freeslot %d\n",
	       linkp->llcl_vs, linkp->llcl_vr, linkp->llcl_nr_received,
	       linkp->llcl_window, linkp->llcl_freeslot);

	/* further expansions can follow here */

}

void
llc_trace(linkp, level, message)
	struct llc_linkcb *linkp;
	int level;
	const char *message;
{
	if (linkp->llcl_sapinfo->si_trace && level > llc_tracelevel)
		llc_link_dump(linkp, message);
}
@


1.8
log
@Spell precede correctly.
'looks fine' millert@@, krw@@. ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: llc_subr.c,v 1.7 2003/12/10 07:22:42 itojun Exp $	*/
@


1.7
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: llc_subr.c,v 1.6 2003/06/02 23:28:13 millert Exp $	*/
d368 1
a368 1
 * [Preceeding each state handler function is the description as taken from
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: llc_subr.c,v 1.5 1998/03/03 06:41:11 millert Exp $	*/
d144 1
a144 1
	register struct ifaddr *ifa;
d160 1
a160 1
	register struct ifaddr *ifa;
d180 1
a180 1
	register struct sockaddr_dl *sdl_tmp;
d348 1
a348 1
	register int sn = 0;
d978 2
a979 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr =
d1010 2
a1011 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr = 
d1039 2
a1040 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr =
d1057 2
a1058 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr = 
d1075 2
a1076 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr =
d1172 2
a1173 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    df = LLC_GETFLAG(linkp,DATA);
d1222 2
a1223 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr = 
d1255 2
a1256 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr =
d1294 1
a1294 1
			register int    p = LLC_GETFLAG(linkp,P);
d1296 1
a1296 1
			register int    nr =
d1321 2
a1322 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr =
d1450 2
a1451 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1470 2
a1471 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1502 2
a1503 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1519 2
a1520 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1536 2
a1537 2
			register int    p = LLC_GETFLAG(linkp,P);
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1637 1
a1637 1
			register int    p = LLC_GETFLAG(linkp,P);
d1639 1
a1639 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1668 1
a1668 1
			register int    p = LLC_GETFLAG(linkp,P);
d1670 1
a1670 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1697 1
a1697 1
			register int    p = LLC_GETFLAG(linkp,P);
d1699 1
a1699 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1721 1
a1721 1
			register int    p = LLC_GETFLAG(linkp,P);
d1723 1
a1723 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1801 1
a1801 1
			register int    p = LLC_GETFLAG(linkp,P);
d1803 1
a1803 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1831 1
a1831 1
			register int    p = LLC_GETFLAG(linkp,P);
d1833 1
a1833 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1866 1
a1866 1
			register int    p = LLC_GETFLAG(linkp,P);
d1868 1
a1868 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1893 1
a1893 1
			register int    p = LLC_GETFLAG(linkp,P);
d1895 1
a1895 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1961 1
a1961 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1982 1
a1982 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d2015 1
a2015 1
			register int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d2036 1
a2036 1
			register int    nr =
d2086 1
a2086 1
	register int    action = 0;
d2197 3
a2199 3
	register struct mbuf *mptr = (struct mbuf *) 0;
	register struct mbuf *anchor = (struct mbuf *) 0;
	register short  i;
d2320 4
a2323 4
	register struct mbuf *m;
	register struct mbuf *n;
	register struct npaidbentry *sapinfo = linkp->llcl_sapinfo;
	register int    i;
d2363 1
a2363 1
	register int    ft = LLC_BAD_PDU;
d2447 1
a2447 1
	register int    i;
d2494 1
a2494 1
	register int    i;
@


1.5
log
@gcc 2.8 -Wall, noted by toddf@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: llc_subr.c,v 1.4 1997/01/27 07:57:03 deraadt Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.5.10.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: llc_subr.c,v 1.5 1998/03/03 06:41:11 millert Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.10.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d144 1
a144 1
	struct ifaddr *ifa;
d160 1
a160 1
	struct ifaddr *ifa;
d180 1
a180 1
	struct sockaddr_dl *sdl_tmp;
d348 1
a348 1
	int sn = 0;
d978 2
a979 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
d1010 2
a1011 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = 
d1039 2
a1040 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
d1057 2
a1058 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = 
d1075 2
a1076 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
d1172 2
a1173 2
			int    p = LLC_GETFLAG(linkp,P);
			int    df = LLC_GETFLAG(linkp,DATA);
d1222 2
a1223 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = 
d1255 2
a1256 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
d1294 1
a1294 1
			int    p = LLC_GETFLAG(linkp,P);
d1296 1
a1296 1
			int    nr =
d1321 2
a1322 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr =
d1450 2
a1451 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1470 2
a1471 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1502 2
a1503 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1519 2
a1520 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1536 2
a1537 2
			int    p = LLC_GETFLAG(linkp,P);
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1637 1
a1637 1
			int    p = LLC_GETFLAG(linkp,P);
d1639 1
a1639 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1668 1
a1668 1
			int    p = LLC_GETFLAG(linkp,P);
d1670 1
a1670 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1697 1
a1697 1
			int    p = LLC_GETFLAG(linkp,P);
d1699 1
a1699 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1721 1
a1721 1
			int    p = LLC_GETFLAG(linkp,P);
d1723 1
a1723 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1801 1
a1801 1
			int    p = LLC_GETFLAG(linkp,P);
d1803 1
a1803 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1831 1
a1831 1
			int    p = LLC_GETFLAG(linkp,P);
d1833 1
a1833 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1866 1
a1866 1
			int    p = LLC_GETFLAG(linkp,P);
d1868 1
a1868 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1893 1
a1893 1
			int    p = LLC_GETFLAG(linkp,P);
d1895 1
a1895 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1961 1
a1961 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1982 1
a1982 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d2015 1
a2015 1
			int    nr = LLCGBITS(frame->llc_control_ext, s_nr);
d2036 1
a2036 1
			int    nr =
d2086 1
a2086 1
	int    action = 0;
d2197 3
a2199 3
	struct mbuf *mptr = (struct mbuf *) 0;
	struct mbuf *anchor = (struct mbuf *) 0;
	short  i;
d2320 4
a2323 4
	struct mbuf *m;
	struct mbuf *n;
	struct npaidbentry *sapinfo = linkp->llcl_sapinfo;
	int    i;
d2363 1
a2363 1
	int    ft = LLC_BAD_PDU;
d2447 1
a2447 1
	int    i;
d2494 1
a2494 1
	int    i;
@


1.4
log
@more #define fallout from union hiding in siginfo
@
text
@d1 1
a1 1
/*	$OpenBSD: llc_subr.c,v 1.3 1996/05/10 12:31:16 deraadt Exp $	*/
d352 1
a352 1
	register        sn = 0;
d1158 1
a1158 1
		if (LLC_GETFLAG(linkp,REMOTE_BUSY) == 0)
d1173 1
d1379 1
a1379 1
		if (linkp->llcl_retry < llc_n2)
d1393 1
a1393 1

d2327 1
a2327 1
	register        i;
@


1.3
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d302 1
a302 1
	struct sockaddr_dl si_addr;
d309 4
a312 4
	sdl_copy(ifdl_addr, &si_addr);
	saploc = LLSAPLOC(&si_addr, ifp);
	si_addr.sdl_data[saploc] = sap;
	si_addr.sdl_alen++;
d314 1
a314 1
	if ((sirt = rtalloc1((struct sockaddr *) & si_addr, 0)))
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d2 1
a2 1
/*	$NetBSD: llc_subr.c,v 1.4 1996/02/13 22:04:51 christos Exp $	*/
d2500 1
a2500 1
	printf("if %s%d\n", linkp->llcl_if->if_name, linkp->llcl_if->if_unit);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: llc_subr.c,v 1.3 1995/06/13 05:38:51 mycroft Exp $	*/
d67 4
a70 2
char *frame_names[] = { "INFO", "RR", "RNR", "REJ", "DM", "SABME", "DISC",
	"UA", "FRMR", "UI", "XID", "TEST", "ILLEGAL", "TIMER", "N2xT1"};
d82 8
a89 8
/*	  mask, shift value */
	{ 0x1,  0x0 },
	{ 0xfe, 0x1 },
	{ 0x3,  0x0 },
	{ 0xc,  0x2 },
	{ 0x10, 0x4 },
	{ 0xe0, 0x5 },
	{ 0x1f, 0x0 }
d93 2
a94 2
 * We keep the link control blocks on a doubly linked list - 
 * primarily for checking in llc_time() 
d96 1
a96 2

struct llccb_q llccb_q = { &llccb_q, &llccb_q };
d103 1
a103 1
int af_link_rts_init_done = 0; 
d110 4
a113 2

sdl_cmp(struct sockaddr_dl *sdl_a, struct sockaddr_dl *sdl_b)
d116 3
a118 3
		return(1);
	return(bcmp((caddr_t) sdl_a->sdl_data, (caddr_t) sdl_b->sdl_data,
		    LLADDRLEN(sdl_a)));
d122 4
a125 2

sdl_copy(struct sockaddr_dl *sdl_f, struct sockaddr_dl *sdl_t)
d131 4
a134 2

sdl_swapaddr(struct sockaddr_dl *sdl_a, struct sockaddr_dl *sdl_b)
d138 2
a139 2
	sdl_copy(sdl_a, &sdl_tmp); 
	sdl_copy(sdl_b, sdl_a); 
d144 3
a146 3

struct sockaddr_dl * 
sdl_getaddrif(struct ifnet *ifp)
d151 1
a151 1
	    ifa = ifa->ifa_list.tqe_next) 	
d153 1
a153 1
			return((struct sockaddr_dl *)(ifa->ifa_addr));
d155 1
a155 1
	return((struct sockaddr_dl *)0);
d159 4
a162 2

sdl_checkaddrif(struct ifnet *ifp, struct sockaddr_dl *sdl_c)
d167 6
a172 6
	    ifa = ifa->ifa_list.tqe_next) 	
		if (ifa->ifa_addr->sa_family == AF_LINK && 	 
		    !sdl_cmp((struct sockaddr_dl *)(ifa->ifa_addr), sdl_c))
			return(1);
	
	return(0);
d176 7
a182 3

sdl_setaddrif(struct ifnet *ifp, u_char *mac_addr, u_char dlsap_addr, 
	      u_char mac_len, struct sockaddr_dl *sdl_to)
d186 2
a187 2
	if ((sdl_tmp = sdl_getaddrif(ifp)) ) { 	
		sdl_copy(sdl_tmp, sdl_to); 	
d189 5
a193 4
		*(LLADDR(sdl_to)+mac_len) = dlsap_addr;
		sdl_to->sdl_alen = mac_len+1; 	
		return(1); 
	} else return(0);
d197 17
a213 10

sdl_sethdrif(struct ifnet *ifp, u_char *mac_src, u_char dlsap_src, u_char *mac_dst,
	     u_char dlsap_dst, u_char mac_len, struct sdl_hdr *sdlhdr_to)
{
	if ( !sdl_setaddrif(ifp, mac_src, dlsap_src, mac_len,
			     &sdlhdr_to->sdlhdr_src) ||
	     !sdl_setaddrif(ifp, mac_dst, dlsap_dst, mac_len,
			     &sdlhdr_to->sdlhdr_dst) )
		return(0);
	else return(1);
d216 1
a216 1
static struct sockaddr_dl sap_saddr; 
d218 2
a219 2
	sizeof(struct sockaddr_dl), /* _len */ 
	AF_LINK                     /* _af */
d226 12
a237 8
llc_setsapinfo(struct ifnet *ifp, u_char af, u_char sap, struct dllconfig *llconf)
{
	struct protosw *pp; 
	struct sockaddr_dl *ifdl_addr; 
	struct rtentry *sirt = (struct rtentry *)0; 
	struct npaidbentry *sapinfo; 
	u_char saploc; 
	int size = sizeof(struct npaidbentry);
d241 9
a249 9
	/* 
	 * We rely/assume that only STREAM protocols will make use of 
	 * connection oriented LLC2. If this will one day not be the 
	 * case this will obviously fail. 
	 */ 
	pp = pffindtype (af, SOCK_STREAM); 
	if (pp == 0 || pp->pr_input == 0 || pp->pr_ctlinput == 0) { 	
		printf("network	level protosw error"); 	
		return 0; 
a250 1

d253 1
a253 1
	 * a certain LSAP address. To do this we enter 
d257 1
a257 1
	sdl_copy(ifdl_addr, &sap_saddr); 
d259 1
a259 1
	saploc = LLSAPLOC(&sap_saddr, ifp); 
d263 4
a266 4
	/* now enter it */ 
	rtrequest(RTM_ADD, (struct sockaddr *)&sap_saddr,
			(struct sockaddr *)&sap_sgate, 0, 0, &sirt); 
	if (sirt == 0) 	
d271 8
a278 9
	sirt->rt_llinfo = malloc(size , M_PCB, M_WAITOK); 
	sapinfo = (struct npaidbentry *) sirt->rt_llinfo; 
	if (sapinfo) { 	
		bzero ((caddr_t)sapinfo, size); 	
		/* 	 
		 * For the time being we support LLC CLASS II here 	 
		 * only 	 
		 */ 	
		sapinfo->si_class = LLC_CLASS_II; 	
d280 1
a280 1
		sapinfo->si_trace = llconf->dllcfg_trace; 	
d283 4
a286 3
		else llc_tracelevel++;
		sapinfo->si_input = pp->pr_input; 	
		sapinfo->si_ctlinput = (caddr_t (*)())pp->pr_ctlinput;
a289 1

d294 1
a294 1
 * Get sapinfo for SAP address and interface 
d297 8
a304 6
llc_getsapinfo(u_char sap, struct ifnet *ifp)
{
	struct sockaddr_dl *ifdl_addr; 
	struct sockaddr_dl si_addr; 
	struct rtentry *sirt; 
	u_char saploc;
d308 3
a310 3
	ifdl_addr = sdl_getaddrif(ifp); 
	sdl_copy(ifdl_addr, &si_addr); 
	saploc = LLSAPLOC(&si_addr, ifp); 
d314 4
a317 3
	if ((sirt = rtalloc1((struct sockaddr *)&si_addr, 0))) 	
		sirt->rt_refcnt--; 
	else return(0);
d319 1
a319 1
	return((struct npaidbentry *)sirt->rt_llinfo);
d338 2
a339 2
 *                  LLC_MAX_SEQUENCE- sn) % LLC_MAX_SEQUENCE) % 
 *                  llcl_window 
d348 3
a350 1
llc_seq2slot(struct llc_linkcb *linkp, short seqn)
d352 1
a352 1
	register sn = 0;
d354 2
a355 2
	sn = (linkp->llcl_freeslot + linkp->llcl_window - 
	      (linkp->llcl_projvs + LLC_MAX_SEQUENCE - seqn) % 
d366 2
a367 2
 * to do one thing or the other. Right now I have just chosen one but have also 
 * indicated the spot by "multiple possibilities". One could make the behavior 
d369 1
a369 1
 * (32/64 bits, whatever is needed) that would suit her needs [I quite like 
d385 6
a390 2
llc_state_ADM(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
	      int cmdrsp, int pollfinal)
d392 1
a392 1
	int action = 0;
d394 1
a394 1
	switch(frame_kind + cmdrsp) {
d397 2
a398 2
		LLC_SETFLAG(linkp, P, pollfinal);
		LLC_SETFLAG(linkp, S, 0);
d400 1
a400 1
		LLC_NEWSTATE(linkp, SETUP);
d403 5
a407 5
		/* 
		 * ISO 8802-2, table 7-1, ADM state says to set
		 * the P flag, yet this will cause an SABME [P] to be
		 * answered with an UA only, not an UA [F], all
		 * other `disconnected' states set the F flag, so ...
d409 2
a410 2
		LLC_SETFLAG(linkp, F, pollfinal);
		LLC_NEWSTATE(linkp, CONN);
d417 1
a417 1
		if (cmdrsp == LLC_CMD && pollfinal == 1) 
d431 6
a436 2
llc_state_CONN(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
	       int cmdrsp, int pollfinal)
d438 1
a438 1
	int action = 0;
d440 1
a440 1
	switch(frame_kind + cmdrsp) {
d442 1
a442 1
		llc_send(linkp, LLCFT_UA, LLC_RSP, LLC_GETFLAG(linkp, F));
d444 3
a446 3
		LLC_SETFLAG(linkp, P, 0);
		LLC_SETFLAG(linkp, REMOTE_BUSY, 0);
		LLC_NEWSTATE(linkp, NORMAL);
d449 2
a450 2
		llc_send(linkp, LLCFT_DM, LLC_RSP, LLC_GETFLAG(linkp, F));
		LLC_NEWSTATE(linkp, ADM);
d453 1
a453 1
		LLC_SETFLAG(linkp, F, pollfinal);
d456 1
a456 1
		LLC_NEWSTATE(linkp, ADM);
d459 1
a459 1
	/* all other frames effect nothing here */
d467 1
a467 1
 *                 to indicate a RESET_REQUEST or a DISCONNECT_REQUEST.  
d470 6
a475 2
llc_state_RESET_WAIT(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		     int cmdrsp, int pollfinal)
d477 1
a477 1
	int action = 0;
d479 1
a479 1
	switch(frame_kind + cmdrsp) {
d481 1
a481 1
		if (LLC_GETFLAG(linkp, S) == 0) {
d483 1
a483 1
			LLC_SETFLAG(linkp, P, pollfinal);
d486 1
a486 1
			LLC_NEWSTATE(linkp, RESET);
d488 2
a489 2
			llc_send(linkp, LLCFT_UA, LLC_RSP, 
				      LLC_GETFLAG(linkp, F));
d491 3
a493 3
			LLC_SETFLAG(linkp, P, 0);
			LLC_SETFLAG(linkp, REMOTE_BUSY, 0);
			LLC_NEWSTATE(linkp, NORMAL);
d498 1
a498 1
		if (LLC_GETFLAG(linkp, S) == 0) {
d500 1
a500 1
			LLC_SETFLAG(linkp, P, pollfinal);
d503 1
a503 1
			LLC_NEWSTATE(linkp, D_CONN);
d505 3
a507 3
			llc_send(linkp, LLCFT_DM, LLC_RSP, 
				      LLC_GETFLAG(linkp, F));
			LLC_NEWSTATE(linkp, ADM);
d511 1
a511 1
		LLC_NEWSTATE(linkp, ADM);
d515 2
a516 2
		LLC_SETFLAG(linkp, S, 1);
		LLC_SETFLAG(linkp, F, pollfinal);
d520 1
a520 1
		LLC_NEWSTATE(linkp, ADM);
d533 6
a538 2
llc_state_RESET_CHECK(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		      int cmdrsp, int pollfinal)
d540 1
a540 1
	int action = 0;
d542 1
a542 1
	switch(frame_kind + cmdrsp) {
d544 1
a544 1
		llc_send(linkp, LLCFT_UA, LLC_RSP, LLC_GETFLAG(linkp, F));
d546 3
a548 3
		LLC_SETFLAG(linkp, P, 0);
		LLC_SETFLAG(linkp, REMOTE_BUSY, 0);
		LLC_NEWSTATE(linkp, NORMAL);
d551 2
a552 2
		llc_send(linkp, LLCFT_DM, LLC_RSP, LLC_GETFLAG(linkp, F));
		LLC_NEWSTATE(linkp, ADM);
d558 1
a558 1
		LLC_SETFLAG(linkp, F, pollfinal);
d562 1
a562 1
		LLC_NEWSTATE(linkp, ADM);
d575 6
a580 2
llc_state_SETUP(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		int cmdrsp, int pollfinal)
d582 1
a582 1
	int action = 0;
d584 1
a584 1
	switch(frame_kind + cmdrsp) {
d588 1
a588 1
		LLC_SETFLAG(linkp, S, 1);
d591 1
a591 1
		if (LLC_GETFLAG(linkp, P) == pollfinal) {
d594 3
a596 3
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_SETFLAG(linkp, REMOTE_BUSY, 0);
			LLC_NEWSTATE(linkp, NORMAL);
d601 4
a604 4
		if (LLC_GETFLAG(linkp, S) == 1) {
			LLC_SETFLAG(linkp, P, 0);
			LLC_SETFLAG(linkp, REMOTE_BUSY, 0),
			LLC_NEWSTATE(linkp, NORMAL);
d608 1
a608 1
			LLC_SETFLAG(linkp, P, pollfinal);
d612 1
a612 1
			LLC_NEWSTATE(linkp, ADM);
d619 1
a619 1
		LLC_NEWSTATE(linkp, ADM);
d624 1
a624 1
		LLC_NEWSTATE(linkp, ADM);
d639 6
a644 2
llc_state_RESET(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		int cmdrsp, int pollfinal)
d646 1
a646 1
	int action = 0;
d648 1
a648 1
	switch(frame_kind + cmdrsp) {
d651 1
a651 1
		LLC_SETFLAG(linkp, S, 1);
d655 1
a655 1
		if (LLC_GETFLAG(linkp, P) == pollfinal) {
d658 3
a660 3
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_SETFLAG(linkp, REMOTE_BUSY, 0);
			LLC_NEWSTATE(linkp, NORMAL);
d665 4
a668 4
		if (LLC_GETFLAG(linkp, S) == 1) {
			LLC_SETFLAG(linkp, P, 0);
			LLC_SETFLAG(linkp, REMOTE_BUSY, 0);
			LLC_NEWSTATE(linkp, NORMAL);
d672 1
a672 1
			LLC_SETFLAG(linkp, P, pollfinal);
d676 1
a676 1
			LLC_NEWSTATE(linkp, ADM);
d683 1
a683 1
		LLC_NEWSTATE(linkp, ADM);
d688 1
a688 1
		LLC_NEWSTATE(linkp, ADM);
d702 6
a707 2
llc_state_D_CONN(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		 int cmdrsp, int pollfinal)
d709 1
a709 1
	int action = 0;
d711 1
a711 1
	switch(frame_kind + cmdrsp) {
d715 1
a715 1
		LLC_NEWSTATE(linkp, ADM);
d718 1
a718 1
		if (LLC_GETFLAG(linkp, P) == pollfinal) {
d720 1
a720 1
			LLC_NEWSTATE(linkp, ADM);
d728 1
a728 1
		LLC_NEWSTATE(linkp, ADM);
d733 1
a733 1
			LLC_SETFLAG(linkp, P, pollfinal);
d736 2
a737 1
		} else LLC_NEWSTATE(linkp, ADM);
d746 1
a746 1
 *           PDU and has sent a FRMR response PDU. It is waiting for a reply from 
d750 6
a755 2
llc_state_ERROR(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		int cmdrsp, int pollfinal)
d757 1
a757 1
	int action = 0;
d759 1
a759 1
	switch(frame_kind + cmdrsp) {
d762 1
a762 1
		LLC_NEWSTATE(linkp, RESET_CHECK);
d768 1
a768 1
		LLC_NEWSTATE(linkp, ADM);
d773 1
a773 1
		LLC_NEWSTATE(linkp, ADM);
d778 2
a779 2
		LLC_SETFLAG(linkp, S, 0);
		LLC_NEWSTATE(linkp, RESET_WAIT);
d788 2
a789 2
			LLC_SETFLAG(linkp, S, 0);
			LLC_NEWSTATE(linkp, RESET_WAIT);
d794 1
a794 1
		if (cmdrsp == LLC_CMD){
d810 6
a815 2
llc_state_NBRAcore(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		   int cmdrsp, int pollfinal)
d817 1
a817 1
	int action = 0;
d819 1
a819 1
	switch(frame_kind + cmdrsp) {
d822 1
a822 1
		LLC_SETFLAG(linkp, P, pollfinal);
d826 1
a826 1
		LLC_NEWSTATE(linkp, D_CONN);
d830 1
a830 1
		LLC_SETFLAG(linkp, P, pollfinal);
d834 2
a835 2
		LLC_SETFLAG(linkp, S, 0);
		LLC_NEWSTATE(linkp, RESET);
d838 1
a838 1
		LLC_SETFLAG(linkp, F, pollfinal);
d840 1
a840 1
		LLC_NEWSTATE(linkp, RESET_CHECK);
d846 1
a846 1
		LLC_NEWSTATE(linkp, ADM);
d851 3
a853 3
		LLC_SETFLAG(linkp, S, 0);
		LLC_NEWSTATE(linkp, RESET_WAIT);
		action =  LLC_FRMR_RECEIVED;
d857 1
a857 1
		LLC_NEWSTATE(linkp, ADM);
d862 3
a864 3
		LLC_SETFRMR(linkp, frame, cmdrsp, 
			 (frame_kind == LLC_INVALID_NR ? LLC_FRMR_Z :
			  (LLC_FRMR_V | LLC_FRMR_W)));
d869 1
a869 1
		LLC_NEWSTATE(linkp, ERROR);
d875 2
a876 2
	case LLC_BAD_PDU: {
		char frmrcause = 0;
d878 18
a895 4
		switch (frame_kind) {
		case LLC_INVALID_NR: frmrcause = LLC_FRMR_Z; break;
		case LLC_INVALID_NS: frmrcause = LLC_FRMR_V | LLC_FRMR_W; break;
		default: frmrcause = LLC_FRMR_W;
a896 9
		LLC_SETFRMR(linkp, frame, cmdrsp, frmrcause);
		llc_send(linkp, LLCFT_FRMR, LLC_RSP, 0);
		LLC_STOP_ALL_TIMERS(linkp);
		LLC_START_ACK_TIMER(linkp);
		linkp->llcl_retry = 0;
		LLC_NEWSTATE(linkp, ERROR);
		action = LLC_FRMR_SENT;
		break;
	}
d898 3
a900 3
		if (cmdrsp == LLC_RSP && pollfinal == 1 && 
		    LLC_GETFLAG(linkp, P) == 0) {
			LLC_SETFRMR(linkp, frame, cmdrsp, LLC_FRMR_W);
d904 1
a904 1
			LLC_NEWSTATE(linkp, ERROR);
d914 2
a915 2
			LLC_SETFLAG(linkp, S, 0);
			LLC_NEWSTATE(linkp, RESET_WAIT);
d930 6
a935 2
llc_state_NORMAL(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		 int cmdrsp, int pollfinal)
d937 1
a937 1
	int action = LLC_PASSITON;
d939 1
a939 1
	switch(frame_kind + cmdrsp) {
d941 1
a941 1
		if (LLC_GETFLAG(linkp, REMOTE_BUSY) == 0) {
d943 1
a943 1
			if (LLC_GETFLAG(linkp, P) == 0) {
d947 2
a948 1
				if (LLC_TIMERXPIRED(linkp, ACK) != LLC_TIMER_RUNNING)
d951 1
a951 1
#endif 
d954 2
a955 1
				if (LLC_TIMERXPIRED(linkp, ACK) != LLC_TIMER_RUNNING)
d964 1
a964 1
		if (LLC_GETFLAG(linkp, P) == 0) {
d969 2
a970 2
			LLC_SETFLAG(linkp, DATA, 0);
			LLC_NEWSTATE(linkp, BUSY);
d972 1
a972 1
		} else { 
d975 3
a977 3
			LLC_SETFLAG(linkp, DATA, 0);
			LLC_NEWSTATE(linkp, BUSY);
			action = 0;			
d981 30
a1010 26
	case LLC_INVALID_NS + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_REJ, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_START_REJ_TIMER(linkp);
			LLC_NEWSTATE(linkp, REJECT);
			action = 0;
		} else if (pollfinal == 0 && p == 1) {
			llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_START_REJ_TIMER(linkp);
			LLC_NEWSTATE(linkp, REJECT);
			action = 0;
		} else if ((pollfinal == 0 && p == 0) || 
			   (pollfinal == 1 && p == 1 && cmdrsp == LLC_RSP)) {
			llc_send(linkp, LLCFT_REJ, LLC_CMD, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_START_P_TIMER(linkp);
			LLC_START_REJ_TIMER(linkp);
			if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else action = 0;
			LLC_NEWSTATE(linkp, REJECT);
a1011 2
		break;
	} 
d1013 27
a1039 23
	case LLCFT_INFO + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			LLC_INC(linkp->llcl_vr);
			LLC_SENDACKNOWLEDGE(linkp, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			action = LLC_DATA_INDICATION;
		} else if (pollfinal == 0 && p == 1) {
			LLC_INC(linkp->llcl_vr);
			LLC_SENDACKNOWLEDGE(linkp, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			action = LLC_DATA_INDICATION;
		} else if ((pollfinal == 0 && p == 0 && cmdrsp == LLC_CMD) ||
			   (pollfinal == p && cmdrsp == LLC_RSP)) {
			LLC_INC(linkp->llcl_vr);
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_SENDACKNOWLEDGE(linkp, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (cmdrsp == LLC_RSP && pollfinal == 1) 
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			action = LLC_DATA_INDICATION;
a1040 2
		break;
	}
d1042 17
a1058 16
	case LLCFT_RR + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			LLC_SENDACKNOWLEDGE(linkp, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if ((pollfinal == 0) || 
			   (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} 
		break;
	}
d1060 16
a1075 13
	case LLCFT_RNR + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
		} else if ((pollfinal == 0) || 
			   (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
a1076 2
		break;
	}
d1078 25
a1102 21
	case LLCFT_REJ + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			llc_resend(linkp, LLC_RSP, 1);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if (pollfinal == 0 && p == 1) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if ((pollfinal == 0 && p == 0 && cmdrsp == LLC_CMD) ||
			   (pollfinal == p && cmdrsp == LLC_RSP)) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_START_P_TIMER(linkp);
			llc_resend(linkp, LLC_CMD, 1);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
a1103 2
		break;
	}
d1105 1
a1105 1
		if (LLC_GETFLAG(linkp, P) == 0) {
d1116 1
a1116 1
			LLC_NEWSTATE(linkp, AWAIT);
d1122 1
a1122 1
		if ((LLC_GETFLAG(linkp, P) == 0) 
d1127 1
a1127 1
			LLC_NEWSTATE(linkp, AWAIT);
d1133 1
a1133 1
		action = llc_state_NBRAcore(linkp, frame, frame_kind, 
d1147 6
a1152 2
llc_state_BUSY(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
	       int cmdrsp, int pollfinal)
d1154 1
a1154 1
	int action = LLC_PASSITON;
d1156 1
a1156 1
	switch(frame_kind + cmdrsp) {
d1158 2
a1159 2
		if (LLC_GETFLAG(linkp, REMOTE_BUSY) == 0)
			if (LLC_GETFLAG(linkp, P) == 0) {
d1162 2
a1163 1
				if (LLC_TIMERXPIRED(linkp, ACK) != LLC_TIMER_RUNNING)
d1168 2
a1169 1
				if (LLC_TIMERXPIRED(linkp, ACK) != LLC_TIMER_RUNNING)
d1174 46
a1219 18
	case LLC_LOCAL_BUSY_CLEARED: {
		register int p = LLC_GETFLAG(linkp, P);
		register int df = LLC_GETFLAG(linkp, DATA);

		switch (df) {
		case 1: 
			if (p == 0) {
				/* multiple possibilities */
				llc_send(linkp, LLCFT_REJ, LLC_CMD, 1);
				LLC_START_REJ_TIMER(linkp);
				LLC_START_P_TIMER(linkp);
				LLC_NEWSTATE(linkp, REJECT);
				action = 0;
			} else {
				llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
				LLC_START_REJ_TIMER(linkp);
				LLC_NEWSTATE(linkp, REJECT);
				action = 0;
d1222 12
a1233 6
		case 0:
			if (p == 0) {
				/* multiple possibilities */
				llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
				LLC_START_P_TIMER(linkp);
				LLC_NEWSTATE(linkp, NORMAL);
d1235 17
a1251 3
			} else {
				llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
				LLC_NEWSTATE(linkp, NORMAL);
d1255 19
a1273 4
		case 2:
			if (p == 0) {
				/* multiple possibilities */
				llc_send(linkp, LLCFT_RR, LLC_CMD, 1);
d1275 14
a1288 6
				LLC_NEWSTATE(linkp, REJECT);
				action = 0;
			} else {
				llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
				LLC_NEWSTATE(linkp, REJECT);
				action =0;
a1291 67
		break;
	}
	case LLC_INVALID_NS + LLC_CMD:
	case LLC_INVALID_NS + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (LLC_GETFLAG(linkp, DATA) == 0)
				LLC_SETFLAG(linkp, DATA, 1);
			action = 0;
		} else if ((cmdrsp == LLC_CMD && pollfinal == 0 && p == 0) ||
			   (cmdrsp == LLC_RSP && pollfinal == p)) {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (LLC_GETFLAG(linkp, DATA) == 0) 
				LLC_SETFLAG(linkp, DATA, 1);
			if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else action = 0;
		} else if (pollfinal == 0 && p == 1) {
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (LLC_GETFLAG(linkp, DATA) == 0)
				LLC_SETFLAG(linkp, DATA, 1);
			action = 0;
		}
		break;
	}
	case LLCFT_INFO + LLC_CMD:
	case LLCFT_INFO + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			LLC_INC(linkp->llcl_vr);
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (LLC_GETFLAG(linkp, DATA) == 2)
				LLC_STOP_REJ_TIMER(linkp);
			LLC_SETFLAG(linkp, DATA, 0);
			action = LLC_DATA_INDICATION;			
		} else if ((cmdrsp == LLC_CMD && pollfinal == 0 && p == 0) ||
			   (cmdrsp == LLC_RSP && pollfinal == p)) {
			LLC_INC(linkp->llcl_vr);
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (LLC_GETFLAG(linkp, DATA) == 2)
				LLC_STOP_REJ_TIMER(linkp);
			if (cmdrsp == LLC_RSP && pollfinal == 1)
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			action = LLC_DATA_INDICATION;
		} else if (pollfinal == 0 && p == 1) {
			LLC_INC(linkp->llcl_vr);
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (LLC_GETFLAG(linkp, DATA) == 2)
				LLC_STOP_REJ_TIMER(linkp);
			LLC_SETFLAG(linkp, DATA, 0);
			action = LLC_DATA_INDICATION;
		}
		break;
	}
d1293 1
a1293 1
	case LLCFT_RR + LLC_RSP: 
d1295 24
a1318 20
	case LLCFT_RNR + LLC_RSP: { 
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (frame_kind == LLCFT_RR) {
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else {
				LLC_SET_REMOTE_BUSY(linkp, action);
			}
		} else if (pollfinal = 0 || 
			   (cmdrsp == LLC_RSP && pollfinal == 1)) {
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (frame_kind == LLCFT_RR) {
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else  {
				LLC_SET_REMOTE_BUSY(linkp, action);
d1320 1
a1321 2
		break;
	}
d1323 26
a1348 22
	case LLCFT_REJ + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if ((cmdrsp == LLC_CMD && pollfinal == 0 && p == 0) ||
			   (cmdrsp == LLC_RSP && pollfinal == p)) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if (pollfinal == 0 && p == 1) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
a1349 2
		break;
	}
d1351 1
a1351 1
		if (LLC_GETFLAG(linkp, P) == 0) {
d1363 1
a1363 1
			LLC_NEWSTATE(linkp, AWAIT_BUSY);
d1369 1
a1369 1
		if (LLC_GETFLAG(linkp, P) == 0 && linkp->llcl_retry < llc_n2) {
d1373 1
a1373 1
			LLC_NEWSTATE(linkp, AWAIT_BUSY);
d1378 2
a1379 2
		if (linkp->llcl_retry < llc_n2) 
			if (LLC_GETFLAG(linkp, P) == 0) {
d1384 2
a1385 2
				LLC_SETFLAG(linkp, DATA, 1);
				LLC_NEWSTATE(linkp, AWAIT_BUSY);
d1387 3
a1389 3
			} else{
				LLC_SETFLAG(linkp, DATA, 1);
				LLC_NEWSTATE(linkp, BUSY);
d1392 1
a1392 1
		
d1396 1
a1396 1
		action = llc_state_NBRAcore(linkp, frame, frame_kind, 
d1409 1
a1409 1
 */ 
d1411 6
a1416 2
llc_state_REJECT(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		 int cmdrsp, int pollfinal)
d1418 1
a1418 1
	int action = LLC_PASSITON;
d1420 1
a1420 1
	switch(frame_kind + cmdrsp) {
d1422 1
a1422 1
		if (LLC_GETFLAG(linkp, P) == 0) {
d1425 1
a1425 1
			if (LLC_TIMERXPIRED(linkp, ACK) != LLC_TIMER_RUNNING)
d1427 1
a1427 1
			LLC_NEWSTATE(linkp, REJECT);
d1429 1
a1429 1
		} else { 
d1431 1
a1431 1
			if (LLC_TIMERXPIRED(linkp, ACK) != LLC_TIMER_RUNNING)
d1433 1
a1433 1
			LLC_NEWSTATE(linkp, REJECT);
d1438 1
a1438 1
		if (LLC_GETFLAG(linkp, P) == 0) {
d1441 2
a1442 2
			LLC_SETFLAG(linkp, DATA, 2);
			LLC_NEWSTATE(linkp, BUSY);
d1446 2
a1447 2
			LLC_SETFLAG(linkp, DATA, 2);
			LLC_NEWSTATE(linkp, BUSY);
d1452 18
a1469 15
	case LLC_INVALID_NS + LLC_RSP: { 
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			action = 0;
		} else if (pollfinal == 0 || 
			   (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			if (cmdrsp == LLC_RSP && pollfinal == 1) {
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			} else action = 0;
a1470 2
		break;
	}
d1472 30
a1501 28
	case LLCFT_INFO + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			LLC_INC(linkp->llcl_vr);
			LLC_SENDACKNOWLEDGE(linkp, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_STOP_REJ_TIMER(linkp);
			LLC_NEWSTATE(linkp, NORMAL);
			action = LLC_DATA_INDICATION;
		} else if ((cmdrsp = LLC_RSP && pollfinal == p) ||
			   (cmdrsp == LLC_CMD && pollfinal == 0 && p == 0)) {
			LLC_INC(linkp->llcl_vr);
			LLC_SENDACKNOWLEDGE(linkp, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			if (cmdrsp == LLC_RSP && pollfinal == 1)
				LLC_CLEAR_REMOTE_BUSY(linkp, action);
			LLC_STOP_REJ_TIMER(linkp);
			LLC_NEWSTATE(linkp, NORMAL);
			action = LLC_DATA_INDICATION;
		} else if (pollfinal == 0 && p == 1) {
			LLC_INC(linkp->llcl_vr);
			LLC_SENDACKNOWLEDGE(linkp, LLC_CMD, 0);
			LLC_STOP_REJ_TIMER(linkp);
			LLC_NEWSTATE(linkp, NORMAL);
			action = LLC_DATA_INDICATION;
a1502 2
		break;
	}
d1504 15
a1518 13
	case LLCFT_RR + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			LLC_SENDACKNOWLEDGE(linkp, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if (pollfinal == 0 || 
			   (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
a1519 2
		break;
	}
d1521 15
a1535 13
	case LLCFT_RNR + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
		} else if (pollfinal == 0 ||
			   (cmdrsp == LLC_RSP && pollfinal == 1 && p == 1)) {
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			action = 0;
a1536 2
		break;
	}
d1538 23
a1560 21
	case LLCFT_REJ + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			llc_resend(linkp, LLC_RSP, 1);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if ((cmdrsp == LLC_CMD && pollfinal == 0 && p == 0) ||
			   (cmdrsp == LLC_RSP && pollfinal == p)) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_UPDATE_P_FLAG(linkp, cmdrsp, pollfinal);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if (pollfinal == 0 && p == 1) {
			linkp->llcl_vs = nr;
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
a1561 2
		break;
	}
d1563 1
a1563 1
		if (LLC_GETFLAG(linkp, P) == 0) {
d1570 1
a1570 1
		if (LLC_GETFLAG(linkp, P) == 0 && linkp->llcl_retry < llc_n2) {
d1583 1
a1583 1
			LLC_NEWSTATE(linkp, AWAIT_REJECT);
d1589 1
a1589 1
		if (LLC_GETFLAG(linkp, P) == 0 && linkp->llcl_retry < llc_n2) {
d1594 3
a1596 3
			/* 
			 * I cannot locate the description of RESET_V(S)
			 * in ISO 8802-2, table 7-1, state REJECT, last event,
d1599 2
a1600 2
			linkp->llcl_vs = 0; /* XXX */
			LLC_NEWSTATE(linkp, AWAIT_REJECT);
a1602 1

d1606 1
a1606 1
		action = llc_state_NBRAcore(linkp, frame, frame_kind, 
d1621 6
a1626 2
llc_state_AWAIT(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		int cmdrsp, int pollfinal)
d1628 1
a1628 1
	int action = LLC_PASSITON;
d1630 1
a1630 1
	switch(frame_kind + cmdrsp) {
d1633 2
a1634 2
		LLC_SETFLAG(linkp, DATA, 0);
		LLC_NEWSTATE(linkp, AWAIT_BUSY);
d1638 29
a1666 25
	case LLC_INVALID_NS + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_REJ, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_START_REJ_TIMER(linkp);
			LLC_NEWSTATE(linkp, AWAIT_REJECT);
			action = 0;
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_STOP_P_TIMER(linkp);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_START_REJ_TIMER(linkp);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, REJECT);
		} else if (pollfinal == 0) {
			llc_send(linkp, LLCFT_REJ, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_START_REJ_TIMER(linkp);
			LLC_NEWSTATE(linkp, AWAIT_REJECT);
			action = 0;
a1667 2
		break;
	}
d1669 25
a1693 21
	case LLCFT_INFO + LLC_CMD: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		LLC_INC(linkp->llcl_vr);
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			action = LLC_DATA_INDICATION;
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			llc_resend(linkp, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, NORMAL);
			action = LLC_DATA_INDICATION;
		} else if (pollfinal == 0) {
			llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			action = LLC_DATA_INDICATION;
a1694 2
		break;
	}
d1698 23
a1720 21
	case LLCFT_REJ + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_STOP_P_TIMER(linkp);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, NORMAL);
		} else if (pollfinal == 0) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		}	
		break;
	}
d1722 21
a1742 17
	case LLCFT_RNR + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (pollfinal == 1 && cmdrsp == LLC_CMD) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
		} else if (pollfinal == 1 && cmdrsp == LLC_RSP) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_STOP_P_TIMER(linkp);
			LLC_SET_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, NORMAL);
		} else if (pollfinal == 0) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
a1743 2
		break;
	}
d1754 1
a1754 1
		action = llc_state_NBRAcore(linkp, frame, frame_kind, 
d1771 6
a1776 2
llc_state_AWAIT_BUSY(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		     int cmdrsp, int pollfinal)
d1778 1
a1778 1
	int action = LLC_PASSITON;
d1780 1
a1780 1
	switch(frame_kind + cmdrsp) {
d1782 1
a1782 1
		switch (LLC_GETFLAG(linkp, DATA)) {
d1786 1
a1786 1
			LLC_NEWSTATE(linkp, AWAIT_REJECT);
d1791 1
a1791 1
			LLC_NEWSTATE(linkp, AWAIT);
d1796 1
a1796 1
			LLC_NEWSTATE(linkp, AWAIT_REJECT);
d1802 28
a1829 25
	case LLC_INVALID_NS + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SETFLAG(linkp, DATA, 1);
			action = 0;
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			/* optionally */
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_STOP_P_TIMER(linkp);
			LLC_SETFLAG(linkp, DATA, 1);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_NEWSTATE(linkp, BUSY);
		} else if (pollfinal == 0) {
			/* optionally */
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SETFLAG(linkp, DATA, 1);
			action = 0;
a1830 1
	}
d1832 31
a1862 27
	case LLCFT_INFO + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			LLC_INC(linkp->llcl_vr);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SETFLAG(linkp, DATA, 0);
			action = LLC_DATA_INDICATION;
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 1);
			LLC_INC(linkp->llcl_vr);
			LLC_START_P_TIMER(linkp);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_SETFLAG(linkp, DATA, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_NEWSTATE(linkp, BUSY);
			action = LLC_DATA_INDICATION;
		} else if (pollfinal == 0) {
			llc_send(linkp, LLCFT_RNR, LLC_CMD, 0);
			LLC_INC(linkp->llcl_vr);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SETFLAG(linkp, DATA, 0);
			action = LLC_DATA_INDICATION;
a1863 2
		break;
	}
d1867 25
a1891 21
	case LLCFT_REJ + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_STOP_P_TIMER(linkp);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, BUSY);
		} else if (pollfinal == 0) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_STOP_P_TIMER(linkp);
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
a1892 2
		break;
	}
d1894 21
a1914 17
	case LLCFT_RNR + LLC_RSP: {
		register int p = LLC_GETFLAG(linkp, P);
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RNR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_STOP_P_TIMER(linkp);
			LLC_SET_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, BUSY);
		} else if (pollfinal == 0) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
a1915 2
		break;
	}
d1926 1
a1926 1
		action = llc_state_NBRAcore(linkp, frame, frame_kind, 
d1946 6
a1951 2
llc_state_AWAIT_REJECT(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		       int cmdrsp, int pollfinal)
d1953 1
a1953 1
	int action = LLC_PASSITON;
d1955 1
a1955 1
	switch(frame_kind + cmdrsp) {
d1958 2
a1959 2
		LLC_SETFLAG(linkp, DATA, 2);
		LLC_NEWSTATE(linkp, AWAIT_BUSY);
d1963 19
a1981 17
	case LLC_INVALID_NS + LLC_RSP: {
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			action = 0;
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			llc_resend(linkp, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, REJECT);
		} else if (pollfinal == 0) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			action = 0;	
a1982 2
		break;
	}
d1984 2
a1985 2
	case LLCFT_INFO + LLC_RSP: {
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
d1987 26
a2012 24
		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			LLC_INC(linkp->llcl_vr);
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_STOP_REJ_TIMER(linkp);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_NEWSTATE(linkp, AWAIT);
			action = LLC_DATA_INDICATION;
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			LLC_INC(linkp->llcl_vr);
			LLC_STOP_P_TIMER(linkp);
			LLC_STOP_REJ_TIMER(linkp);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			llc_resend(linkp, LLC_CMD, 0);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, NORMAL);
			action = LLC_DATA_INDICATION;
		} else if (pollfinal == 0) {
			LLC_INC(linkp->llcl_vr);
			llc_send(linkp, LLCFT_RR, LLC_CMD, 0);
			LLC_STOP_REJ_TIMER(linkp);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_NEWSTATE(linkp, AWAIT);
			action = LLC_DATA_INDICATION;
a2013 2
		break;
	}
d2017 19
a2035 17
	case LLCFT_REJ + LLC_RSP: {
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);
		
		if (cmdrsp == LLC_CMD && pollfinal ==  1) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			llc_resend(linkp, LLC_CMD, 1);
			LLC_START_P_TIMER(linkp);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, REJECT);
		} else if (pollfinal == 0) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_CLEAR_REMOTE_BUSY(linkp, action);
a2036 2
		break;
	}
d2038 19
a2056 16
	case LLCFT_RNR + LLC_RSP: {
		register int nr = LLCGBITS(frame->llc_control_ext, s_nr);

		if (cmdrsp == LLC_CMD && pollfinal == 1) {
			llc_send(linkp, LLCFT_RR, LLC_RSP, 1);
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
		} else if (cmdrsp == LLC_RSP && pollfinal == 1) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			linkp->llcl_vs = nr;
			LLC_STOP_P_TIMER(linkp);
			LLC_SET_REMOTE_BUSY(linkp, action);
			LLC_NEWSTATE(linkp, REJECT);
		} else if (pollfinal == 0) {
			LLC_UPDATE_NR_RECEIVED(linkp, nr);
			LLC_SET_REMOTE_BUSY(linkp, action);
a2057 2
		break;
	}
d2068 1
a2068 1
		action = llc_state_NBRAcore(linkp, frame, frame_kind, 
d2082 6
a2087 2
llc_statehandler(struct llc_linkcb *linkp, struct llc *frame, int frame_kind,
		 int cmdrsp, int pollfinal)
d2089 1
a2089 1
	register int action = 0;
d2096 1
a2096 1
	LLC_STARTTIMER(linkp, AGE);
d2101 2
a2102 2
	action = (*linkp->llcl_statehandler)(linkp, frame, frame_kind, 
					     cmdrsp, pollfinal);
d2105 2
a2106 2
	case LLC_CONNECT_INDICATION: {
		int naction;
d2108 12
a2119 11
		LLC_TRACE(linkp, LLCTR_INTERESTING, "CONNECT INDICATION");
		linkp->llcl_nlnext = 
		     (*linkp->llcl_sapinfo->si_ctlinput)
		      (PRC_CONNECT_INDICATION,
		       (struct sockaddr *) &linkp->llcl_addr, (caddr_t) linkp);
		if (linkp->llcl_nlnext == 0)
			naction = NL_DISCONNECT_REQUEST;
		else naction = NL_CONNECT_RESPONSE;
		action = (*linkp->llcl_statehandler)(linkp, frame, naction, 0, 0);
		goto once_more_and_again;
	}
d2127 2
a2128 2
		  (PRC_DISCONNECT_INDICATION, 
		   (struct sockaddr *) &linkp->llcl_addr, linkp->llcl_nlnext);
d2130 1
a2130 1
        /* internally visible only */
d2140 2
a2141 2
		action = (*linkp->llcl_statehandler)(linkp, frame, 
						     NL_RESET_RESPONSE, 0, 0);
d2148 3
a2150 3
		action = (*linkp->llcl_statehandler)(linkp, frame,
						     NL_RESET_REQUEST, 0, 0);
		
d2162 1
a2162 1
	}		
d2167 1
a2167 1
	 * The remaining action codes are for the time 
d2178 1
a2178 1
 */ 
d2184 1
d2197 2
a2198 1
llc_resetwindow(struct llc_linkcb *linkp)
d2201 2
a2202 2
	register struct mbuf *anchor = (struct mbuf *)0;
	register short i;
d2207 3
a2209 3
		anchor = mptr = linkp->llcl_output_buffers[i]; 
		for (; i != linkp->llcl_freeslot; 
		     i = llc_seq2slot(linkp, i+1)) {
d2213 2
a2214 1
			} else panic("LLC2 window broken");
d2222 1
a2222 1
	if (anchor != (struct mbuf *)0) {
d2226 1
a2226 1
			linkp->llcl_output_buffers[i]->m_nextpkt = (struct mbuf *)0;
d2229 3
a2231 2
	} else linkp->llcl_freeslot = 0;
	
d2235 4
a2238 1
	/* set distance between LLC2 sequence number and the top of window to 0 */
d2243 1
a2243 1
			
d2246 2
a2247 2
 *                   and initialize it properly. We don't intiate the actual setup
 *                   of the LLC2 link here.
d2250 6
a2255 2
llc_newlink(struct sockaddr_dl *dst, struct ifnet *ifp, struct rtentry *nlrt, 
	    caddr_t nlnext, struct rtentry *llrt)
d2258 2
a2259 2
	u_char sap = LLSAPADDR(dst);
	short llcwindow;
d2267 2
a2268 2
	bzero((caddr_t)nlinkp, sizeof(struct llc_linkcb));
	
d2286 1
a2286 1
	
d2298 2
a2299 2
	MALLOC(nlinkp->llcl_output_buffers, struct mbuf **, 
	       llcwindow*sizeof(struct mbuf *), M_PCB, M_DONTWAIT);
d2302 1
a2302 1
		return(NULL);
d2304 2
a2305 2
	bzero((caddr_t)nlinkp->llcl_output_buffers, 
	      llcwindow*sizeof(struct mbuf *));
d2313 1
a2313 1
	return(nlinkp);
d2319 3
a2321 1
llc_dellink(struct llc_linkcb *linkp)
d2326 1
a2326 1
	register i;
d2331 2
a2332 2
		   (PRC_DISCONNECT_INDICATION, 
		    (struct sockaddr *)&linkp->llcl_addr, linkp->llcl_nlnext);
d2336 1
a2336 1
		((struct npaidbentry *)(linkp->llcl_llrt->rt_llinfo))->np_link 
d2350 1
a2350 1
	for(i = 0; i < linkp->llcl_window; i++)
d2355 1
a2355 1
	FREE((caddr_t)linkp->llcl_output_buffers, M_PCB);
d2358 1
a2358 1
	FREE((caddr_t)linkp, M_PCB);
d2361 4
a2364 1
llc_decode(struct llc* frame, struct llc_linkcb * linkp)
d2366 1
a2366 1
	register int ft = LLC_BAD_PDU;
d2370 37
a2406 2
	/* S or U frame ? */
	} else switch (frame->llc_control) {
d2408 11
a2418 23
	/* U frames */
	case LLC_UI:
	case LLC_UI_P:     ft = LLC_UI; break;
	case LLC_DM:
	case LLC_DM_P:     ft =LLCFT_DM; break;
	case LLC_DISC:
	case LLC_DISC_P:   ft = LLCFT_DISC; break;
	case LLC_UA:
	case LLC_UA_P:     ft = LLCFT_UA; break;
	case LLC_SABME:
	case LLC_SABME_P:  ft = LLCFT_SABME; break;
	case LLC_FRMR:
	case LLC_FRMR_P:   ft = LLCFT_FRMR; break;
	case LLC_XID:
	case LLC_XID_P:    ft = LLCFT_XID; break;
	case LLC_TEST:
	case LLC_TEST_P:   ft = LLCFT_TEST; break;

	/* S frames */
	case LLC_RR:       ft = LLCFT_RR; break;
	case LLC_RNR:      ft = LLCFT_RNR; break;
	case LLC_REJ:      ft = LLCFT_REJ; break;
	} /* switch */
d2423 2
a2424 1
			if (LLCGBITS(frame->llc_control, i_ns) != linkp->llcl_vr) {
d2433 3
a2435 2
			if (LLC_NR_VALID(linkp, LLCGBITS(frame->llc_control_ext, 
							 s_nr)) == 0)
a2439 1

d2447 2
a2448 1
llc_anytimersup(struct llc_linkcb * linkp)
d2450 2
a2451 2
	register int i;
	
d2454 1
a2454 1
			break;
d2457 2
a2458 1
	else return 1;
d2466 1
a2466 1
#define CHECK(l, s) if (LLC_STATEEQ(l, s)) return #s
d2471 2
a2472 1
llc_getstatename(struct llc_linkcb *linkp)
d2474 14
a2487 14
	CHECK(linkp, ADM);
	CHECK(linkp, CONN);
	CHECK(linkp, RESET_WAIT);
	CHECK(linkp, RESET_CHECK);
	CHECK(linkp, SETUP);
	CHECK(linkp, RESET);
	CHECK(linkp, D_CONN);
	CHECK(linkp, ERROR);
	CHECK(linkp, NORMAL);
	CHECK(linkp, BUSY);
	CHECK(linkp, REJECT);
	CHECK(linkp, AWAIT);
	CHECK(linkp, AWAIT_BUSY);
	CHECK(linkp, AWAIT_REJECT);
d2493 3
a2495 1
llc_link_dump(struct llc_linkcb* linkp, const char *message)
d2497 1
a2497 2
	register int i;
	register char *state;
d2501 1
a2501 1
	
d2507 4
a2510 4
	for (i = 0; i < (SAL(linkp)->sdl_alen)-2; i++)
		printf("%x:", (char)*(LLADDR(SAL(linkp))+i) & 0xff);
	printf("%x,", (char)*(LLADDR(SAL(linkp))+i) & 0xff);
	printf("%x\n", (char)*(LLADDR(SAL(linkp))+i+1) & 0xff);
d2513 4
a2516 4
        printf("state %s, ", llc_getstatename(linkp));
        for (i = LLC_ACK_SHIFT; i < LLC_AGE_SHIFT; i++)
		printf("%s-%c %d/", timer_names[i], 
		       (linkp->llcl_timerflags & (1<<i) ? 'R' : 'S'),
d2518 2
a2519 2
	printf("%s-%c %d\n", timer_names[i], (linkp->llcl_timerflags & (1<<i) ? 
					     'R' : 'S'), linkp->llcl_timers[i]);
d2523 3
a2525 2
	       LLC_GETFLAG(linkp, P), LLC_GETFLAG(linkp, S), 
	       LLC_GETFLAG(linkp, DATA), LLC_GETFLAG(linkp, REMOTE_BUSY));
d2537 4
a2540 1
llc_trace(struct llc_linkcb *linkp, int level, const char *message)
a2543 2

	return;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

