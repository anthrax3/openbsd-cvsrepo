head	1.10;
access;
symbols
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.22
	OPENBSD_2_8:1.2.0.20
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.16
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2005.06.16.17.37.55;	author henning;	state dead;
branches;
next	1.9;

1.9
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.08.19.18.12;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.08.18.26.37;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.08.17.07.32;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.16.12.53.35;	author ho;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	96.03.04.07.36.47;	author niklas;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	95.10.18.08.53.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.09;	author deraadt;	state Exp;
branches;
next	;

1.2.16.1
date	2001.07.04.10.54.25;	author niklas;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.2.16.3;

1.2.16.3
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.2.16.4;

1.2.16.4
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.2.16.5;

1.2.16.5
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove remaining netccitt parts, full ports build test by pval, thanks!
@
text
@/*	$OpenBSD: pk_usrreq.c,v 1.9 2003/12/10 07:22:43 itojun Exp $	*/
/*	$NetBSD: pk_usrreq.c,v 1.10 1996/02/13 22:05:43 christos Exp $	*/

/*
 * Copyright (c) University of British Columbia, 1984
 * Copyright (C) Computer Science Department IV,
 * 		 University of Erlangen-Nuremberg, Germany, 1992
 * Copyright (c) 1991, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by the
 * Laboratory for Computation Vision and the Computer Science Department
 * of the the University of British Columbia and the Computer Science
 * Department (IV) of the University of Erlangen-Nuremberg, Germany.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pk_usrreq.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/stat.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>

static void old_to_new(struct mbuf *);
static void new_to_old(struct mbuf *);
/*
 *
 *  X.25 Packet level protocol interface to socket abstraction.
 *
 *  Process an X.25 user request on a logical channel.  If this is a send
 *  request then m is the mbuf chain of the send data. If this is a timer
 *  expiration (called from the software clock routine) them timertype is
 *  the particular timer.
 *
 */
int
pk_usrreq(so, req, m, nam, control)
	struct socket  *so;
	int             req;
	struct mbuf *m, *nam;
	struct mbuf    *control;
{
	struct pklcd *lcp = (struct pklcd *) so->so_pcb;
	int    error = 0;

	if (req == PRU_CONTROL)
		return (pk_control(so, (long) m, (caddr_t) nam,
				   (struct ifnet *) control));
	if (control && control->m_len) {
		error = EINVAL;
		goto release;
	}
	if (lcp == NULL && req != PRU_ATTACH) {
		error = EINVAL;
		goto release;
	}
	/*
		pk_trace (pkcbhead, TR_USER, (struct pklcd *)0,
			req, (struct x25_packet *)0);
	*/

	switch (req) {
		/*
		 * X.25 attaches to socket via PRU_ATTACH and allocates a
		 * logical channel descriptor.  If the socket is to  receive
		 * connections, then the LISTEN state is entered.
		 */
	case PRU_ATTACH:
		if (lcp) {
			error = EISCONN;
			/* Socket already connected. */
			break;
		}
		lcp = pk_attach(so);
		if (lcp == 0)
			error = ENOBUFS;
		break;

		/*
		 * Detach a logical channel from the socket. If the state of
		 * the channel is embryonic, simply discard it. Otherwise we
		 * have to initiate a PRU_DISCONNECT which will finish later.
		 */
	case PRU_DETACH:
		pk_disconnect(lcp);
		break;

		/*
		 * Give the socket an address.
		 */
	case PRU_BIND:
		if (nam->m_len == sizeof(struct x25_sockaddr))
			old_to_new(nam);
		error = pk_bind(lcp, nam);
		break;

		/*
		 * Prepare to accept connections.
		 */
	case PRU_LISTEN:
		error = pk_listen(lcp);
		break;

		/*
		 * Initiate a CALL REQUEST to peer entity. Enter state
		 * SENT_CALL and mark the socket as connecting. Set timer
		 * waiting for CALL ACCEPT or CLEAR.
		 */
	case PRU_CONNECT:
		if (nam->m_len == sizeof(struct x25_sockaddr))
			old_to_new(nam);
		if (pk_checksockaddr(nam))
			return (EINVAL);
		error = pk_connect(lcp, mtod(nam, struct sockaddr_x25 *));
		break;

		/*
		 * Initiate a disconnect to peer entity via a CLEAR REQUEST
		 * packet. The socket will be disconnected when we receive a
		 * confirmation or a clear collision.
		 */
	case PRU_DISCONNECT:
		pk_disconnect(lcp);
		break;

		/*
		 * Accept an INCOMING CALL. Most of the work has already been
		 * done by pk_input. Just return the callers address to the
		 * user.
		 */
	case PRU_ACCEPT:
		if (lcp->lcd_craddr == NULL)
			break;
		bcopy((caddr_t) lcp->lcd_craddr, mtod(nam, caddr_t),
		      sizeof(struct sockaddr_x25));
		nam->m_len = sizeof(struct sockaddr_x25);
		if (lcp->lcd_flags & X25_OLDSOCKADDR)
			new_to_old(nam);
		break;

		/*
		 * After a receive, we should send a RR.
		 */
	case PRU_RCVD:
		pk_flowcontrol(lcp, /* sbspace (&so -> so_rcv) <= */ 0, 1);
		break;

		/*
		 * Send INTERRUPT packet.
		 */
	case PRU_SENDOOB:
		if (m == 0) {
			MGETHDR(m, M_WAITOK, MT_OOBDATA);
			m->m_pkthdr.len = m->m_len = 1;
			*mtod(m, octet *) = 0;
		}
		if (m->m_pkthdr.len > 32) {
			m_freem(m);
			error = EMSGSIZE;
			break;
		}
		MCHTYPE(m, MT_OOBDATA);
		/* FALLTHROUGH */

		/*
		 * Do send by placing data on the socket output queue.
		 */
	case PRU_SEND:
		if (control) {
			struct cmsghdr *ch = mtod(m, struct cmsghdr *);
			control->m_len -= sizeof(*ch);
			control->m_data += sizeof(*ch);
			error = pk_ctloutput(PRCO_SETOPT, so, ch->cmsg_level,
					     ch->cmsg_type, &control);
		}
		if (error == 0 && m)
			error = pk_send(m, lcp);
		break;

		/*
		 * Abort a virtual circuit. For example all completed calls
		 * waiting acceptance.
		 */
	case PRU_ABORT:
		pk_disconnect(lcp);
		break;

		/* Begin unimplemented hooks. */

	case PRU_SHUTDOWN:
		error = EOPNOTSUPP;
		break;

	case PRU_CONTROL:
		error = EOPNOTSUPP;
		break;

	case PRU_SENSE:
#ifdef BSD4_3
		((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat;
#else
		error = EOPNOTSUPP;
#endif
		break;

		/* End unimplemented hooks. */

	case PRU_SOCKADDR:
		if (lcp->lcd_ceaddr == 0)
			return (EADDRNOTAVAIL);
		nam->m_len = sizeof(struct sockaddr_x25);
		bcopy((caddr_t) lcp->lcd_ceaddr, mtod(nam, caddr_t),
		      sizeof(struct sockaddr_x25));
		if (lcp->lcd_flags & X25_OLDSOCKADDR)
			new_to_old(nam);
		break;

	case PRU_PEERADDR:
		if (lcp->lcd_state != DATA_TRANSFER)
			return (ENOTCONN);
		nam->m_len = sizeof(struct sockaddr_x25);
		bcopy(lcp->lcd_craddr ? (caddr_t) lcp->lcd_craddr :
		      (caddr_t) lcp->lcd_ceaddr,
		      mtod(nam, caddr_t), sizeof(struct sockaddr_x25));
		if (lcp->lcd_flags & X25_OLDSOCKADDR)
			new_to_old(nam);
		break;

		/*
		 * Receive INTERRUPT packet.
		 */
	case PRU_RCVOOB:
		if (so->so_options & SO_OOBINLINE) {
			struct mbuf *n = so->so_rcv.sb_mb;
			if (n && n->m_type == MT_OOBDATA) {
				unsigned        len = n->m_pkthdr.len;
				so->so_rcv.sb_mb = n->m_nextpkt;
				SB_EMPTY_FIXUP(&so->so_rcv);
				if (len != n->m_len &&
				    (n = m_pullup(n, len)) == 0)
					break;
				m->m_len = len;
				bcopy(mtod(m, caddr_t), mtod(n, caddr_t), len);
				m_freem(n);
			}
			break;
		}
		m->m_len = 1;
		*mtod(m, char *) = lcp->lcd_intrdata;
		break;

	default:
		panic("pk_usrreq");
	}
release:
	if (control != NULL)
		m_freem(control);
	return (error);
}

/*
 * If you want to use UBC X.25 level 3 in conjunction with some other X.25
 * level 2 driver, have the ifp -> if_ioctl routine assign pk_start to ia ->
 * ia_start when called with SIOCSIFCONF_X25.
 */
/* ARGSUSED */
int
pk_start(lcp)
	struct pklcd *lcp;
{
	pk_output(lcp);
	return (0);		/* XXX pk_output should return a value */
}

#ifndef _offsetof
#define _offsetof(t, m) ((int)((caddr_t)&((t *)0)->m))
#endif
struct sockaddr_x25 pk_sockmask = {
	_offsetof(struct sockaddr_x25, x25_addr[0]),	/* x25_len */
	0,			/* x25_family */
	-1,			/* x25_net id */
};

/* ARGSUSED */
int
pk_control(so, cmd, data, ifp)
	struct socket  *so;
	u_long          cmd;
	caddr_t         data;
	struct ifnet *ifp;
{
	struct ifreq_x25 *ifr = (struct ifreq_x25 *) data;
	struct ifaddr *ifa = 0;
	struct x25_ifaddr *ia = 0;
	int             error = 0, s, old_maxlcn;

	/*
	 * Find address for this interface, if it exists.
	 */
	if (ifp)
		for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
		     ifa = ifa->ifa_list.tqe_next)
			if (ifa->ifa_addr->sa_family == AF_CCITT)
				break;

	ia = (struct x25_ifaddr *) ifa;
	switch (cmd) {
	case SIOCGIFCONF_X25:
		if (ifa == 0)
			return (EADDRNOTAVAIL);
		ifr->ifr_xc = ia->ia_xc;
		return (0);

	case SIOCSIFCONF_X25:
		if ((so->so_state & SS_PRIV) == 0)
			return (EPERM);
		if (ifp == 0)
			panic("pk_control");
		if (ifa == (struct ifaddr *) 0) {
			MALLOC(ia, struct x25_ifaddr *, sizeof(*ia),
			       M_IFADDR, M_WAITOK);
			bzero((caddr_t) ia, sizeof(*ia));
			TAILQ_INSERT_TAIL(&ifp->if_addrlist, &ia->ia_ifa,
					  ifa_list);
			ifa = &ia->ia_ifa;
			ifa->ifa_netmask = (struct sockaddr *) & pk_sockmask;
			ifa->ifa_addr = (struct sockaddr *) & ia->ia_xc.xc_addr;
			ifa->ifa_dstaddr = (struct sockaddr *) & ia->ia_dstaddr;	/* XXX */
			ia->ia_ifp = ifp;
			ia->ia_dstaddr.x25_family = AF_CCITT;
			ia->ia_dstaddr.x25_len = pk_sockmask.x25_len;
		} else if (ISISO8802(ifp) == 0) {
			rtinit(ifa, (int) RTM_DELETE, 0);
		}
		old_maxlcn = ia->ia_maxlcn;
		ia->ia_xc = ifr->ifr_xc;
		ia->ia_dstaddr.x25_net = ia->ia_xc.xc_addr.x25_net;
		if (ia->ia_maxlcn != old_maxlcn && old_maxlcn != 0) {
			/* VERY messy XXX */
			struct pkcb *pkp;
			FOR_ALL_PKCBS(pkp)
				if (pkp->pk_ia == ia)
				pk_resize(pkp);
		}
		/*
		 * Give the interface a chance to initialize if this
p		 * is its first address, and to validate the address.
		 */
		ia->ia_start = pk_start;
		s = splimp();
		if (ifp->if_ioctl)
			error = (*ifp->if_ioctl) (ifp, SIOCSIFCONF_X25,
						  (caddr_t) ifa);
		if (error)
			ifp->if_flags &= ~IFF_UP;
		else if (ISISO8802(ifp) == 0)
			error = rtinit(ifa, (int) RTM_ADD, RTF_UP);
		splx(s);
		return (error);

	default:
		if (ifp == 0 || ifp->if_ioctl == 0)
			return (EOPNOTSUPP);
		return ((*ifp->if_ioctl) (ifp, cmd, data));
	}
}

int
pk_ctloutput(cmd, so, level, optname, mp)
	struct socket  *so;
	struct mbuf   **mp;
	int             cmd, level, optname;
{
	struct mbuf *m = *mp;
	struct pklcd *lcp = (struct pklcd *) so->so_pcb;
	int             error = EOPNOTSUPP;

	if (m == 0)
		return (EINVAL);
	if (cmd == PRCO_SETOPT)
		switch (optname) {
		case PK_FACILITIES:
			if (m == 0)
				return (EINVAL);
			lcp->lcd_facilities = m;
			*mp = 0;
			return (0);

		case PK_ACCTFILE:
			if ((so->so_state & SS_PRIV) == 0)
				error = EPERM;
			else if (m->m_len)
				error = pk_accton(mtod(m, char *));
			else
				error = pk_accton((char *) 0);
			break;

		case PK_RTATTACH:
			error = pk_rtattach(so, m);
			break;

		case PK_PRLISTEN:
			error = pk_user_protolisten(mtod(m, u_char *));
		}
	if (*mp) {
		(void) m_freem(*mp);
		*mp = 0;
	}
	return (error);

}


/*
 * Do an in-place conversion of an "old style"
 * socket address to the new style
 */

static void
old_to_new(m)
	struct mbuf *m;
{
	struct x25_sockaddr *oldp;
	struct sockaddr_x25 *newp;
	char  *ocp, *ncp;
	struct sockaddr_x25 new;

	oldp = mtod(m, struct x25_sockaddr *);
	newp = &new;
	bzero((caddr_t) newp, sizeof(*newp));

	newp->x25_family = AF_CCITT;
	newp->x25_len = sizeof(*newp);
	newp->x25_opts.op_flags = (oldp->xaddr_facilities & X25_REVERSE_CHARGE)
		| X25_MQBIT | X25_OLDSOCKADDR;
	if (oldp->xaddr_facilities & XS_HIPRIO)	/* Datapac specific */
		newp->x25_opts.op_psize = X25_PS128;
	bcopy((caddr_t) oldp->xaddr_addr, newp->x25_addr,
	      (unsigned) min(oldp->xaddr_len, sizeof(newp->x25_addr) - 1));
	if (bcmp((caddr_t) oldp->xaddr_proto, newp->x25_udata, 4) != 0) {
		bcopy((caddr_t) oldp->xaddr_proto, newp->x25_udata, 4);
		newp->x25_udlen = 4;
	}
	ocp = (caddr_t) oldp->xaddr_userdata;
	ncp = newp->x25_udata + 4;
	while (*ocp && ocp < (caddr_t) oldp->xaddr_userdata + 12) {
		if (newp->x25_udlen == 0)
			newp->x25_udlen = 4;
		*ncp++ = *ocp++;
		newp->x25_udlen++;
	}
	bcopy((caddr_t) newp, mtod(m, char *), sizeof(*newp));
	m->m_len = sizeof(*newp);
}

/*
 * Do an in-place conversion of a new style
 * socket address to the old style
 */

static void
new_to_old(m)
	struct mbuf *m;
{
	struct x25_sockaddr *oldp;
	struct sockaddr_x25 *newp;
	char  *ocp, *ncp;
	struct x25_sockaddr old;

	oldp = &old;
	newp = mtod(m, struct sockaddr_x25 *);
	bzero((caddr_t) oldp, sizeof(*oldp));

	oldp->xaddr_facilities = newp->x25_opts.op_flags & X25_REVERSE_CHARGE;
	if (newp->x25_opts.op_psize == X25_PS128)
		oldp->xaddr_facilities |= XS_HIPRIO;	/* Datapac specific */
	ocp = (char *) oldp->xaddr_addr;
	ncp = newp->x25_addr;
	while (*ncp) {
		*ocp++ = *ncp++;
		oldp->xaddr_len++;
	}

	bcopy(newp->x25_udata, (caddr_t) oldp->xaddr_proto, 4);
	if (newp->x25_udlen > 4)
		bcopy(newp->x25_udata + 4, (caddr_t) oldp->xaddr_userdata,
		      (unsigned) (newp->x25_udlen - 4));

	bcopy((caddr_t) oldp, mtod(m, char *), sizeof(*oldp));
	m->m_len = sizeof(*oldp);
}


int
pk_checksockaddr(m)
	struct mbuf    *m;
{
	struct sockaddr_x25 *sa = mtod(m, struct sockaddr_x25 *);
	char  *cp;

	if (m->m_len != sizeof(struct sockaddr_x25))
		return (1);
	if (sa->x25_family != AF_CCITT ||
	    sa->x25_udlen > sizeof(sa->x25_udata))
		return (1);
	for (cp = sa->x25_addr; *cp; cp++) {
		if (*cp < '0' || *cp > '9' ||
		    cp >= &sa->x25_addr[sizeof(sa->x25_addr) - 1])
			return (1);
	}
	return (0);
}

int
pk_send(m, v)
	struct mbuf *m;
	void *v;
{
	struct pklcd   *lcp = v;
	int             mqbit = 0, error = 0;
	struct x25_packet *xp;
	struct socket *so;

	if (m->m_type == MT_OOBDATA) {
		if (lcp->lcd_intrconf_pending)
			error = ETOOMANYREFS;
		if (m->m_pkthdr.len > 32)
			error = EMSGSIZE;
		M_PREPEND(m, PKHEADERLN, M_WAITOK);
		if (error)
			goto bad;
		*(mtod(m, octet *)) = 0;
		xp = mtod(m, struct x25_packet *);
		X25SBITS(xp->bits, fmt_identifier, 1);
		xp->packet_type = X25_INTERRUPT;
		SET_LCN(xp, lcp->lcd_lcn);
		sbinsertoob((so = lcp->lcd_so) ?
			    &so->so_snd : &lcp->lcd_sb, m);
		goto send;
	}
	/*
	 * Application has elected (at call setup time) to prepend
	 * a control byte to each packet written indicating m-bit
	 * and q-bit status.  Examine and then discard this byte.
	 */
	if (lcp->lcd_flags & X25_MQBIT) {
		if (m->m_len < 1) {
			m_freem(m);
			return (EMSGSIZE);
		}
		mqbit = *(mtod(m, u_char *));
		m->m_len--;
		m->m_data++;
		m->m_pkthdr.len--;
	}
	error = pk_fragment(lcp, m, mqbit & 0x80, mqbit & 0x40, 1);
send:
	if (error == 0 && lcp->lcd_state == DATA_TRANSFER)
		lcp->lcd_send(lcp);	/* XXXXXXXXX fix pk_output!!! */
	return (error);
bad:
	if (m)
		m_freem(m);
	return (error);
}
@


1.9
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.8 2003/06/02 23:28:13 millert Exp $	*/
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.7 2002/08/08 19:18:12 provos Exp $	*/
d78 1
a78 1
	register struct mbuf *m, *nam;
d81 2
a82 2
	register struct pklcd *lcp = (struct pklcd *) so->so_pcb;
	register int    error = 0;
d208 1
a208 1
			register struct cmsghdr *ch = mtod(m, struct cmsghdr *);
d272 1
a272 1
			register struct mbuf *n = so->so_rcv.sb_mb;
d307 1
a307 1
	register struct pklcd *lcp;
d328 1
a328 1
	register struct ifnet *ifp;
d330 3
a332 3
	register struct ifreq_x25 *ifr = (struct ifreq_x25 *) data;
	register struct ifaddr *ifa = 0;
	register struct x25_ifaddr *ia = 0;
d378 1
a378 1
			register struct pkcb *pkp;
d412 2
a413 2
	register struct mbuf *m = *mp;
	register struct pklcd *lcp = (struct pklcd *) so->so_pcb;
d459 1
a459 1
	register struct mbuf *m;
d461 3
a463 3
	register struct x25_sockaddr *oldp;
	register struct sockaddr_x25 *newp;
	register char  *ocp, *ncp;
d501 1
a501 1
	register struct mbuf *m;
d503 3
a505 3
	register struct x25_sockaddr *oldp;
	register struct sockaddr_x25 *newp;
	register char  *ocp, *ncp;
d536 2
a537 2
	register struct sockaddr_x25 *sa = mtod(m, struct sockaddr_x25 *);
	register char  *cp;
d554 1
a554 1
	register struct mbuf *m;
d559 2
a560 2
	register struct x25_packet *xp;
	register struct socket *so;
@


1.7
log
@redo socketbuf speedup.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.5 2002/08/08 17:07:32 provos Exp $	*/
d24 1
a24 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@backout the tree break. ok pb@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.4 2002/03/14 01:27:10 millert Exp $	*/
d280 1
@


1.5
log
@socket buf speedup from thorpej@@netbsd, okay art@@ ericj@@:

Make insertion of data into socket buffers O(C):
* Keep pointers to the first and last mbufs of the last record in the
  socket buffer.
* Use the sb_lastrecord pointer in the sbappend*() family of functions
  to avoid traversing the packet chain to find the last record.
* Add a new sbappend_stream() function for stream protocols which
  guarantee that there will never be more than one record in the
  socket buffer.  This function uses the sb_mbtail pointer to perform
  the data insertion.  Make TCP use sbappend_stream(). On a profiling
run, this makes sbappend of a TCP transmission using
a 1M socket buffer go from 50% of the time to .02% of the time. Thanks
to Bill Sommerfeld and YAMAMOTO Takashi for their debugging
assistance!
@
text
@a279 1
				SB_EMPTY_FIXUP(&so->so_rcv);
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.3 2001/05/16 12:53:35 ho Exp $	*/
d280 1
@


1.3
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.2 1996/03/04 07:36:47 niklas Exp $	*/
d66 2
a67 2
static void old_to_new __P((struct mbuf *));
static void new_to_old __P((struct mbuf *));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.3 2001/05/16 12:53:35 ho Exp $	*/
d66 2
a67 2
static void old_to_new(struct mbuf *);
static void new_to_old(struct mbuf *);
@


1.3.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.3.4.1 2002/06/11 03:31:36 art Exp $	*/
a279 1
				SB_EMPTY_FIXUP(&so->so_rcv);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a362 2
			if (ia == 0)
				return (ENOBUFS);
d571 1
a571 1
		if (m == 0 || error)
@


1.2.16.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.2 1996/03/04 07:36:47 niklas Exp $	*/
d363 2
d573 1
a573 1
		if (error)
@


1.2.16.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
a67 2
static void old_to_new(struct mbuf *);
static void new_to_old(struct mbuf *);
@


1.2.16.3
log
@Sync the SMP branch with 3.3
@
text
@a279 1
				SB_EMPTY_FIXUP(&so->so_rcv);
@


1.2.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_usrreq.c,v 1.2.16.3 2003/03/28 00:06:55 niklas Exp $	*/
d24 5
a28 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.16.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
	struct mbuf *m, *nam;
d81 2
a82 2
	struct pklcd *lcp = (struct pklcd *) so->so_pcb;
	int    error = 0;
d208 1
a208 1
			struct cmsghdr *ch = mtod(m, struct cmsghdr *);
d272 1
a272 1
			struct mbuf *n = so->so_rcv.sb_mb;
d307 1
a307 1
	struct pklcd *lcp;
d328 1
a328 1
	struct ifnet *ifp;
d330 3
a332 3
	struct ifreq_x25 *ifr = (struct ifreq_x25 *) data;
	struct ifaddr *ifa = 0;
	struct x25_ifaddr *ia = 0;
d378 1
a378 1
			struct pkcb *pkp;
d412 2
a413 2
	struct mbuf *m = *mp;
	struct pklcd *lcp = (struct pklcd *) so->so_pcb;
d459 1
a459 1
	struct mbuf *m;
d461 3
a463 3
	struct x25_sockaddr *oldp;
	struct sockaddr_x25 *newp;
	char  *ocp, *ncp;
d501 1
a501 1
	struct mbuf *m;
d503 3
a505 3
	struct x25_sockaddr *oldp;
	struct sockaddr_x25 *newp;
	char  *ocp, *ncp;
d536 2
a537 2
	struct sockaddr_x25 *sa = mtod(m, struct sockaddr_x25 *);
	char  *cp;
d554 1
a554 1
	struct mbuf *m;
d559 2
a560 2
	struct x25_packet *xp;
	struct socket *so;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: pk_usrreq.c,v 1.9 1995/06/13 05:38:58 mycroft Exp $	*/
d6 1
a6 1
 * Copyright (C) Computer Science Department IV, 
d64 1
d66 2
a67 2
static old_to_new();
static new_to_old();
d69 1
a69 1
 * 
d78 6
a83 6

pk_usrreq (so, req, m, nam, control)
struct socket *so;
int req;
register struct mbuf *m, *nam;
struct mbuf *control;
d85 2
a86 2
	register struct pklcd *lcp = (struct pklcd *) so -> so_pcb;
	register int error = 0;
d89 3
a91 3
		return (pk_control (so, (long)m, (caddr_t)nam,
			(struct ifnet *)control));
	if (control && control -> m_len) {
d99 4
a102 5

/*
	pk_trace (pkcbhead, TR_USER, (struct pklcd *)0,
		req, (struct x25_packet *)0);
*/
d105 6
a110 6
	/* 
	 *  X.25 attaches to socket via PRU_ATTACH and allocates a logical
	 *  channel descriptor.  If the socket is to  receive connections,
	 *  then the LISTEN state is entered.
	 */
	case PRU_ATTACH: 
d116 1
a116 1
		lcp = pk_attach (so);
d121 7
a127 7
	/* 
	 *  Detach a logical channel from the socket. If the state of the
	 *  channel is embryonic, simply discard it. Otherwise we have to 
	 *  initiate a PRU_DISCONNECT which will finish later.
	 */
	case PRU_DETACH: 
		pk_disconnect (lcp);
d130 7
a136 7
	/* 
	 *  Give the socket an address.
	 */
	case PRU_BIND: 
		if (nam -> m_len == sizeof (struct x25_sockaddr))
			old_to_new (nam);
		error = pk_bind (lcp, nam);
d139 5
a143 5
	/* 
	 *  Prepare to accept connections.
	 */
	case PRU_LISTEN: 
		error = pk_listen (lcp);
d146 9
a154 9
	/* 
	 *  Initiate a CALL REQUEST to peer entity. Enter state SENT_CALL
	 *  and mark the socket as connecting. Set timer waiting for 
	 *  CALL ACCEPT or CLEAR.
	 */
	case PRU_CONNECT: 
		if (nam -> m_len == sizeof (struct x25_sockaddr))
			old_to_new (nam);
		if (pk_checksockaddr (nam))
d156 1
a156 1
		error = pk_connect (lcp, mtod (nam, struct sockaddr_x25 *));
d159 7
a165 7
	/* 
	 *  Initiate a disconnect to peer entity via a CLEAR REQUEST packet.
	 *  The socket will be disconnected when we receive a confirmation
	 *  or a clear collision.
	 */
	case PRU_DISCONNECT: 
		pk_disconnect (lcp);
d168 7
a174 6
	/* 
	 *  Accept an INCOMING CALL. Most of the work has already been done
	 *  by pk_input. Just return the callers address to the user.
	 */
	case PRU_ACCEPT: 
		if (lcp -> lcd_craddr == NULL)
d176 5
a180 5
		bcopy ((caddr_t)lcp -> lcd_craddr, mtod (nam, caddr_t),
			sizeof (struct sockaddr_x25));
		nam -> m_len = sizeof (struct sockaddr_x25);
		if (lcp -> lcd_flags & X25_OLDSOCKADDR)
			new_to_old (nam);
d183 5
a187 5
	/* 
	 *  After a receive, we should send a RR.
	 */
	case PRU_RCVD: 
		pk_flowcontrol (lcp, /*sbspace (&so -> so_rcv) <= */ 0, 1);
d190 4
a193 4
	/* 
	 *  Send INTERRUPT packet.
	 */
	case PRU_SENDOOB: 
d196 2
a197 2
			m -> m_pkthdr.len = m -> m_len = 1;
			*mtod (m, octet *) = 0;
d199 2
a200 2
		if (m -> m_pkthdr.len > 32) {
			m_freem (m);
d207 4
a210 4
	/* 
	 *  Do send by placing data on the socket output queue.
	 */
	case PRU_SEND: 
d212 5
a216 5
			register struct cmsghdr *ch = mtod (m, struct cmsghdr *);
			control -> m_len -= sizeof (*ch);
			control -> m_data += sizeof (*ch);
			error = pk_ctloutput (PRCO_SETOPT, so, ch -> cmsg_level,
					ch -> cmsg_type, &control);
d219 1
a219 1
			error = pk_send (lcp, m);
d222 6
a227 6
	/* 
	 *  Abort a virtual circuit. For example all completed calls
	 *  waiting acceptance.
	 */
	case PRU_ABORT: 
		pk_disconnect (lcp);
d230 1
a230 1
	/* Begin unimplemented hooks. */
d232 1
a232 1
	case PRU_SHUTDOWN: 
d236 1
a236 1
	case PRU_CONTROL: 
d240 1
a240 1
	case PRU_SENSE: 
d242 1
a242 1
		((struct stat *)m) -> st_blksize = so -> so_snd.sb_hiwat;
d248 1
a248 1
	/* End unimplemented hooks. */
d250 2
a251 2
	case PRU_SOCKADDR: 
		if (lcp -> lcd_ceaddr == 0)
d253 5
a257 5
		nam -> m_len = sizeof (struct sockaddr_x25);
		bcopy ((caddr_t)lcp -> lcd_ceaddr, mtod (nam, caddr_t),
			sizeof (struct sockaddr_x25));
		if (lcp -> lcd_flags & X25_OLDSOCKADDR)
			new_to_old (nam);
d261 1
a261 1
		if (lcp -> lcd_state != DATA_TRANSFER)
d263 6
a268 6
		nam -> m_len = sizeof (struct sockaddr_x25);
		bcopy (lcp -> lcd_craddr ? (caddr_t)lcp -> lcd_craddr :
			(caddr_t)lcp -> lcd_ceaddr,
			mtod (nam, caddr_t), sizeof (struct sockaddr_x25));
		if (lcp -> lcd_flags & X25_OLDSOCKADDR)
			new_to_old (nam);
d271 11
a281 11
	/* 
	 *  Receive INTERRUPT packet.
	 */
	case PRU_RCVOOB: 
		if (so -> so_options & SO_OOBINLINE) {
			register struct mbuf *n  = so -> so_rcv.sb_mb;
			if (n && n -> m_type == MT_OOBDATA) {
				unsigned len =  n -> m_pkthdr.len;
				so -> so_rcv.sb_mb = n -> m_nextpkt;
				if (len !=  n -> m_len &&
				    (n = m_pullup (n, len)) == 0)
d283 3
a285 3
				m -> m_len = len;
				bcopy (mtod (m, caddr_t), mtod (n, caddr_t), len);
				m_freem (n);
d289 2
a290 2
		m -> m_len = 1;
		*mtod (m, char *) = lcp -> lcd_intrdata;
d293 2
a294 2
	default: 
		panic ("pk_usrreq");
d298 1
a298 1
		m_freem (control);
d302 4
a305 4
/* 
 * If you want to use UBC X.25 level 3 in conjunction with some
 * other X.25 level 2 driver, have the ifp -> if_ioctl routine
 * assign pk_start to ia -> ia_start when called with SIOCSIFCONF_X25.
d308 3
a310 2
pk_start (lcp)
register struct pklcd *lcp;
d312 2
a313 2
	pk_output (lcp);
	return (0); /* XXX pk_output should return a value */
d320 3
a322 3
	_offsetof(struct sockaddr_x25, x25_addr[0]),      /* x25_len */
	0,                                                /* x25_family */
	-1,                                               /* x25_net id */
d325 7
a331 6
/*ARGSUSED*/
pk_control (so, cmd, data, ifp)
struct socket *so;
u_long cmd;
caddr_t data;
register struct ifnet *ifp;
d333 1
a333 1
	register struct ifreq_x25 *ifr = (struct ifreq_x25 *)data;
d336 1
a336 3
	struct pklcd *dev_lcp = 0;
	int error, s, old_maxlcn;
	unsigned n;
d343 1
a343 1
		    ifa = ifa->ifa_list.tqe_next)
d347 1
a347 1
	ia = (struct x25_ifaddr *)ifa;
d352 1
a352 1
		ifr -> ifr_xc = ia -> ia_xc;
d359 4
a362 6
			panic ("pk_control");
		if (ifa == (struct ifaddr *)0) {
			register struct mbuf *m;

			MALLOC(ia, struct x25_ifaddr *, sizeof (*ia),
				M_IFADDR, M_WAITOK);
d365 1
a365 1
			bzero ((caddr_t)ia, sizeof (*ia));
d367 8
a374 8
			    ifa_list);
			ifa = &ia -> ia_ifa;
			ifa -> ifa_netmask = (struct sockaddr *)&pk_sockmask;
			ifa -> ifa_addr = (struct sockaddr *)&ia -> ia_xc.xc_addr;
			ifa -> ifa_dstaddr = (struct sockaddr *)&ia -> ia_dstaddr; /* XXX */
			ia -> ia_ifp = ifp;
			ia -> ia_dstaddr.x25_family = AF_CCITT;
			ia -> ia_dstaddr.x25_len = pk_sockmask.x25_len;
d376 1
a376 1
			rtinit (ifa, (int)RTM_DELETE, 0);
d378 4
a381 4
		old_maxlcn = ia -> ia_maxlcn;
		ia -> ia_xc = ifr -> ifr_xc;
		ia -> ia_dstaddr.x25_net = ia -> ia_xc.xc_addr.x25_net;
		if (ia -> ia_maxlcn != old_maxlcn && old_maxlcn != 0) {
d385 2
a386 2
				if (pkp -> pk_ia == ia)
					pk_resize (pkp);
d392 1
a392 1
		ia -> ia_start = pk_start;
d394 3
a396 3
		if (ifp -> if_ioctl)
			error = (*ifp -> if_ioctl)(ifp, SIOCSIFCONF_X25, 
						   (caddr_t) ifa);
d398 1
a398 1
			ifp -> if_flags &= ~IFF_UP;
d400 2
a401 2
			error = rtinit (ifa, (int)RTM_ADD, RTF_UP);
		splx (s);
d405 1
a405 1
		if (ifp == 0 || ifp -> if_ioctl == 0)
d407 1
a407 1
		return ((*ifp -> if_ioctl)(ifp, cmd, data));
d411 5
a415 4
pk_ctloutput (cmd, so, level, optname, mp)
struct socket *so;
struct mbuf **mp;
int cmd, level, optname;
d418 2
a419 2
	register struct pklcd *lcp = (struct pklcd *) so -> so_pcb;
	int error = EOPNOTSUPP;
d423 17
a439 7
	if (cmd == PRCO_SETOPT) switch (optname) {
	case PK_FACILITIES:
		if (m == 0)
			return (EINVAL);
		lcp -> lcd_facilities = m;
		*mp = 0;
		return (0);
d441 3
a443 8
	case PK_ACCTFILE:
		if ((so->so_state & SS_PRIV) == 0)
			error = EPERM;
		else if (m -> m_len)
			error = pk_accton (mtod (m, char *));
		else
			error = pk_accton ((char *)0);
		break;
d445 3
a447 7
	case PK_RTATTACH:
		error = pk_rtattach (so, m);
		break;
	    
	case PK_PRLISTEN:
		error = pk_user_protolisten (mtod (m, u_char *));
	}
d449 1
a449 1
		(void) m_freem (*mp);
d462 3
a464 3
static
old_to_new (m)
register struct mbuf *m;
d468 1
a468 1
	register char *ocp, *ncp;
d471 1
a471 1
	oldp = mtod (m, struct x25_sockaddr *);
d473 1
a473 1
	bzero ((caddr_t)newp, sizeof (*newp));
d475 3
a477 3
	newp -> x25_family = AF_CCITT;
	newp -> x25_len = sizeof(*newp);
	newp -> x25_opts.op_flags = (oldp -> xaddr_facilities & X25_REVERSE_CHARGE)
d479 13
a491 13
	if (oldp -> xaddr_facilities & XS_HIPRIO)	/* Datapac specific */
		newp -> x25_opts.op_psize = X25_PS128;
	bcopy ((caddr_t)oldp -> xaddr_addr, newp -> x25_addr,
	       (unsigned)min (oldp -> xaddr_len, sizeof (newp -> x25_addr) - 1));
	if (bcmp ((caddr_t)oldp -> xaddr_proto, newp -> x25_udata, 4) != 0) {
		bcopy ((caddr_t)oldp -> xaddr_proto, newp -> x25_udata, 4);
		newp -> x25_udlen = 4;
	}
	ocp = (caddr_t)oldp -> xaddr_userdata;
	ncp = newp -> x25_udata + 4;
	while (*ocp && ocp < (caddr_t)oldp -> xaddr_userdata + 12) {
		if (newp -> x25_udlen == 0)
			newp -> x25_udlen = 4;
d493 1
a493 1
		newp -> x25_udlen++;
d495 2
a496 2
	bcopy ((caddr_t)newp, mtod (m, char *), sizeof (*newp));
	m -> m_len = sizeof (*newp);
d504 3
a506 3
static
new_to_old (m)
register struct mbuf *m;
d510 1
a510 1
	register char *ocp, *ncp;
d514 2
a515 2
	newp = mtod (m, struct sockaddr_x25 *);
	bzero ((caddr_t)oldp, sizeof (*oldp));
d517 5
a521 5
	oldp -> xaddr_facilities = newp -> x25_opts.op_flags & X25_REVERSE_CHARGE;
	if (newp -> x25_opts.op_psize == X25_PS128)
		oldp -> xaddr_facilities |= XS_HIPRIO;	/* Datapac specific */
	ocp = (char *)oldp -> xaddr_addr;
	ncp = newp -> x25_addr;
d524 1
a524 1
		oldp -> xaddr_len++;
d527 4
a530 4
	bcopy (newp -> x25_udata, (caddr_t)oldp -> xaddr_proto, 4);
	if (newp -> x25_udlen > 4)
		bcopy (newp -> x25_udata + 4, (caddr_t)oldp -> xaddr_userdata,
			(unsigned)(newp -> x25_udlen - 4));
d532 2
a533 2
	bcopy ((caddr_t)oldp, mtod (m, char *), sizeof (*oldp));
	m -> m_len = sizeof (*oldp);
d537 3
a539 2
pk_checksockaddr (m)
struct mbuf *m;
d541 2
a542 2
	register struct sockaddr_x25 *sa = mtod (m, struct sockaddr_x25 *);
	register char *cp;
d544 1
a544 1
	if (m -> m_len != sizeof (struct sockaddr_x25))
d546 2
a547 2
	if (sa -> x25_family != AF_CCITT ||
		sa -> x25_udlen > sizeof (sa -> x25_udata))
d549 1
a549 1
	for (cp = sa -> x25_addr; *cp; cp++) {
d551 1
a551 1
			cp >= &sa -> x25_addr[sizeof (sa -> x25_addr) - 1])
d557 4
a560 3
pk_send (lcp, m)
struct pklcd *lcp;
register struct mbuf *m;
d562 2
a563 1
	int mqbit = 0, error = 0;
d567 2
a568 2
	if (m -> m_type == MT_OOBDATA) {
		if (lcp -> lcd_intrconf_pending)
d570 1
a570 1
		if (m -> m_pkthdr.len > 32)
d575 7
a581 7
		*(mtod (m, octet *)) = 0;
		xp = mtod (m, struct x25_packet *);
		X25SBITS(xp -> bits, fmt_identifier, 1);
		xp -> packet_type = X25_INTERRUPT;
		SET_LCN(xp, lcp -> lcd_lcn);
		sbinsertoob ( (so = lcp -> lcd_so) ?
			&so -> so_snd : &lcp -> lcd_sb, m);
d589 3
a591 3
	if (lcp -> lcd_flags & X25_MQBIT) {
		if (m -> m_len < 1) {
			m_freem (m);
d594 4
a597 4
		mqbit = *(mtod (m, u_char *));
		m -> m_len--;
		m -> m_data++;
		m -> m_pkthdr.len--;
d599 1
a599 1
	error = pk_fragment (lcp, m, mqbit & 0x80, mqbit & 0x40, 1);
d601 2
a602 2
	if (error == 0 && lcp -> lcd_state == DATA_TRANSFER)
		lcp -> lcd_send (lcp); /* XXXXXXXXX fix pk_output!!! */
d606 1
a606 1
		m_freem (m);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
