head	1.9;
access;
symbols
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.22
	OPENBSD_2_8:1.2.0.20
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.16
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.06.16.17.37.55;	author henning;	state dead;
branches;
next	1.8;

1.8
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.16.12.53.35;	author ho;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	96.03.04.07.36.41;	author niklas;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	95.10.18.08.53.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.09;	author deraadt;	state Exp;
branches;
next	;

1.2.16.1
date	2001.07.04.10.54.24;	author niklas;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.2.16.3;

1.2.16.3
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.2.16.4;

1.2.16.4
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove remaining netccitt parts, full ports build test by pval, thanks!
@
text
@/*	$OpenBSD: pk_input.c,v 1.8 2004/01/03 14:08:53 espie Exp $	*/
/*	$NetBSD: pk_input.c,v 1.7 1996/02/13 22:05:21 christos Exp $	*/

/*
 * Copyright (c) University of British Columbia, 1984
 * Copyright (C) Computer Science Department IV,
 * 		 University of Erlangen-Nuremberg, Germany, 1992
 * Copyright (c) 1991, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by the
 * Laboratory for Computation Vision and the Computer Science Department
 * of the the University of British Columbia and the Computer Science
 * Department (IV) of the University of Erlangen-Nuremberg, Germany.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pk_input.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/socketvar.h>
#include <sys/proc.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_llc.h>
#include <net/route.h>

#include <netccitt/dll.h>
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>
#include <netccitt/llc_var.h>
#ifdef HDLC
#include <netccitt/hdlc.h>
#include <netccitt/hd_var.h>
#endif

#include <sys/stdarg.h>

struct pkcb_q   pkcb_q = {&pkcb_q, &pkcb_q};

static void prune_dnic(char *, char *, char *, struct x25config *);
static void save_extra(struct mbuf *, octet *, struct socket *);

/*
 * ccittintr() is the generic interrupt handler for HDLC, LLC2, and X.25. This
 * allows to have kernel running X.25 but no HDLC or LLC2 or both (in case we
 * employ boards that do all the stuff themselves, e.g. ADAX X.25 or TPS ISDN.)
 */
void
ccittintr()
{
	extern struct ifqueue pkintrq;
	extern struct ifqueue hdintrq;
	extern struct ifqueue llcintrq;

#ifdef HDLC
	if (hdintrq.ifq_len)
		hdintr();
#endif
#ifdef LLC
	if (llcintrq.ifq_len)
		llcintr();
#endif
	if (pkintrq.ifq_len)
		pkintr();
}

struct pkcb    *
pk_newlink(ia, llnext)
	struct x25_ifaddr *ia;
	caddr_t         llnext;
{
	struct x25config *xcp = &ia->ia_xc;
	struct pkcb *pkp;
	struct protosw *pp;
	unsigned        size;

	pp = pffindproto(AF_CCITT, (int) xcp->xc_lproto, 0);
	if (pp == 0 || pp->pr_output == 0) {
		pk_message(0, xcp, "link level protosw error");
		return ((struct pkcb *) 0);
	}
	/*
	 * Allocate a network control block structure
	 */
	size = sizeof(struct pkcb);
	pkp = (struct pkcb *) malloc(size, M_PCB, M_WAITOK);
	bzero((caddr_t) pkp, size);
	pkp->pk_lloutput = pp->pr_output;
	pkp->pk_llctlinput = pp->pr_ctlinput;
	pkp->pk_xcp = xcp;
	pkp->pk_ia = ia;
	pkp->pk_state = DTE_WAITING;
	pkp->pk_llnext = llnext;
	insque(pkp, &pkcb_q);

	/*
	 * set defaults
	 */

	if (xcp->xc_pwsize == 0)
		xcp->xc_pwsize = DEFAULT_WINDOW_SIZE;
	if (xcp->xc_psize == 0)
		xcp->xc_psize = X25_PS128;
	/*
	 * Allocate logical channel descriptor vector
	 */

	(void) pk_resize(pkp);
	return (pkp);
}


int
pk_dellink(pkp)
	struct pkcb *pkp;
{
	int    i;
	struct protosw *pp;

	/*
	 * Essentially we have the choice to
	 * (a) go ahead and let the route be deleted and
	 *     leave the pkcb associated with that route
	 *     as it is, i.e. the connections stay open
	 * (b) do a pk_disconnect() on all channels associated
	 *     with the route via the pkcb and then proceed.
	 *
	 * For the time being we stick with (b)
	 */

	for (i = 1; i < pkp->pk_maxlcn; ++i)
		if (pkp->pk_chan[i])
			pk_disconnect(pkp->pk_chan[i]);

	/*
	 * Free the pkcb
	 */

	/*
	 * First find the protoswitch to get hold of the link level
	 * protocol to be notified that the packet level entity is
	 * dissolving ...
	 */
	pp = pffindproto(AF_CCITT, (int) pkp->pk_xcp->xc_lproto, 0);
	if (pp == 0 || pp->pr_output == 0) {
		pk_message(0, pkp->pk_xcp, "link level protosw error");
		return (EPROTONOSUPPORT);
	}
	pkp->pk_refcount--;
	if (!pkp->pk_refcount) {
		struct dll_ctlinfo ctlinfo;

		remque(pkp);
		if (pkp->pk_rt->rt_llinfo == (caddr_t) pkp)
			pkp->pk_rt->rt_llinfo = (caddr_t) NULL;

		/*
		 * Tell the link level that the pkcb is dissolving
		 */
		if (pp->pr_ctlinput && pkp->pk_llnext) {
			ctlinfo.dlcti_pcb = pkp->pk_llnext;
			ctlinfo.dlcti_rt = pkp->pk_rt;
			(*pp->pr_ctlinput) (PRC_DISCONNECT_REQUEST,
					    (struct sockaddr *)pkp->pk_xcp,
					    &ctlinfo);
		}
		free((caddr_t) pkp->pk_chan, M_IFADDR);
		free((caddr_t) pkp, M_PCB);
	}
	return (0);
}


int
pk_resize(pkp)
	struct pkcb *pkp;
{
	struct pklcd   *dev_lcp = 0;
	struct x25config *xcp = pkp->pk_xcp;
	if (pkp->pk_chan &&
	    (pkp->pk_maxlcn != xcp->xc_maxlcn)) {
		pk_restart(pkp, X25_RESTART_NETWORK_CONGESTION);
		dev_lcp = pkp->pk_chan[0];
		free((caddr_t) pkp->pk_chan, M_IFADDR);
		pkp->pk_chan = 0;
	}
	if (pkp->pk_chan == 0) {
		unsigned        size;
		pkp->pk_maxlcn = xcp->xc_maxlcn;
		size = (pkp->pk_maxlcn + 1) * sizeof(struct pklcd *);
		pkp->pk_chan = malloc(size, M_IFADDR, M_WAITOK);
		bzero((caddr_t) pkp->pk_chan, size);
		/*
		 * Allocate a logical channel descriptor for lcn 0
		 */
		if (dev_lcp == 0 &&
		    (dev_lcp = pk_attach((struct socket *) 0)) == 0)
			return (ENOBUFS);
		dev_lcp->lcd_state = READY;
		dev_lcp->lcd_pkp = pkp;
		pkp->pk_chan[0] = dev_lcp;
	}
	return 0;
}

/*
 * This procedure is called by the link level whenever the link becomes
 * operational, is reset, or when the link goes down.
 */
/* VARARGS */
void *
pk_ctlinput(code, src, addr)
	int             code;
	struct sockaddr *src;
	void            *addr;
{
	struct pkcb *pkp = (struct pkcb *) addr;
	struct rtentry *llrt;

	switch (code) {
	case PRC_LINKUP:
		if (pkp->pk_state == DTE_WAITING)
			pk_restart(pkp, X25_RESTART_NETWORK_CONGESTION);
		break;

	case PRC_LINKDOWN:
		pk_restart(pkp, -1);	/* Clear all active circuits */
		pkp->pk_state = DTE_WAITING;
		break;

	case PRC_LINKRESET:
		pk_restart(pkp, X25_RESTART_NETWORK_CONGESTION);
		break;

	case PRC_CONNECT_INDICATION:

		if ((llrt = rtalloc1(src, 0)) == 0)
			return 0;
		else
			llrt->rt_refcnt--;

		pkp = (((struct npaidbentry *) llrt->rt_llinfo)->np_rt) ?
			(struct pkcb *) (((struct npaidbentry *) llrt->rt_llinfo)->np_rt->rt_llinfo) : (struct pkcb *) 0;
		if (pkp == (struct pkcb *) 0)
			return 0;
		pkp->pk_llnext = addr;

		return ((caddr_t) pkp);

	case PRC_DISCONNECT_INDICATION:
		pk_restart(pkp, -1);	/* Clear all active circuits */
		pkp->pk_state = DTE_WAITING;
		pkp->pk_llnext = (caddr_t) 0;
		break;
	}
	return (0);
}
struct ifqueue  pkintrq;
/*
 * This routine is called if there are semi-smart devices that do HDLC
 * in hardware and want to queue the packet and call level 3 directly
 */
void
pkintr()
{
	struct mbuf *m;
	int    s;

	for (;;) {
		s = splimp();
		IF_DEQUEUE(&pkintrq, m);
		splx(s);
		if (m == 0)
			break;
		if (m->m_len < PKHEADERLN) {
			printf("pkintr: packet too short (len=%d)\n",
			       m->m_len);
			m_freem(m);
			continue;
		}
		pk_input(m);
	}
}

struct mbuf    *pk_bad_packet;
struct mbuf_cache pk_input_cache = {0};
/*
 * X.25 PACKET INPUT
 * 
 * This procedure is called by a link level procedure whenever an information
 * frame is received. It decodes the packet and demultiplexes based on the
 * logical channel number.
 * 
 * We change the original conventions of the UBC code here -- since there may be
 * multiple pkcb's for a given interface of type 802.2 class 2, we retrieve
 * which one it is from m_pkthdr.rcvif (which has been overwritten by lower
 * layers); That field is then restored for the benefit of upper layers which
 * may make use of it, such as CLNP.
 * 
 */

#define RESTART_DTE_ORIGINATED(xp) \
	(((xp)->packet_cause == X25_RESTART_DTE_ORIGINATED) || \
	 ((xp)->packet_cause >= X25_RESTART_DTE_ORIGINATED2))

void
pk_input(struct mbuf *m, ...)
{
	struct x25_packet *xp;
	struct pklcd *lcp;
	struct socket *so = 0;
	struct pkcb *pkp;
	int             ptype, lcn, lcdstate = LISTEN;

	if (pk_input_cache.mbc_size || pk_input_cache.mbc_oldsize)
		mbuf_cache(&pk_input_cache, m);
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("pkintr");

	if ((pkp = (struct pkcb *) m->m_pkthdr.rcvif) == 0)
		return;
	xp = mtod(m, struct x25_packet *);
	ptype = pk_decode(xp);
	lcn = LCN(xp);
	lcp = pkp->pk_chan[lcn];

	/*
	 * If the DTE is in Restart  state, then it will ignore data,
	 * interrupt, call setup and clearing, flow control and reset
	 * packets.
	 */
	if (lcn < 0 || lcn > pkp->pk_maxlcn) {
		pk_message(lcn, pkp->pk_xcp, "illegal lcn");
		m_freem(m);
		return;
	}
	pk_trace(pkp->pk_xcp, m, "P-In");

	if (pkp->pk_state != DTE_READY && ptype != PK_RESTART &&
	    ptype != PK_RESTART_CONF) {
		m_freem(m);
		return;
	}
	if (lcp) {
		so = lcp->lcd_so;
		lcdstate = lcp->lcd_state;
	} else {
		if (ptype == PK_CLEAR) {/* idle line probe (Datapac specific) */
			/* send response on lcd 0's output queue */
			lcp = pkp->pk_chan[0];
			lcp->lcd_template = pk_template(lcn, X25_CLEAR_CONFIRM);
			pk_output(lcp);
			m_freem(m);
			return;
		}
		if (ptype != PK_CALL)
			ptype = PK_INVALID_PACKET;
	}

	if (lcn == 0 && ptype != PK_RESTART && ptype != PK_RESTART_CONF) {
		pk_message(0, pkp->pk_xcp, "illegal ptype (%d, %s) on lcn 0",
			   ptype, pk_name[ptype / MAXSTATES]);
		if (pk_bad_packet)
			m_freem(pk_bad_packet);
		pk_bad_packet = m;
		return;
	}
	m->m_pkthdr.rcvif = pkp->pk_ia->ia_ifp;

	switch (ptype + lcdstate) {
		/*
		 * Incoming Call packet received.
		 */
	case PK_CALL + LISTEN:
		pk_incoming_call(pkp, m);
		break;

		/*
		 * Call collision: Just throw this "incoming call" away since
		 * the DCE will ignore it anyway.
		 */
	case PK_CALL + SENT_CALL:
		pk_message((int) lcn, pkp->pk_xcp,
			   "incoming call collision");
		break;

		/*
		 * Call confirmation packet received. This usually means our
		 * previous connect request is now complete.
		 */
	case PK_CALL_ACCEPTED + SENT_CALL:
		MCHTYPE(m, MT_CONTROL);
		pk_call_accepted(lcp, m);
		break;

		/*
		 * This condition can only happen if the previous state was
		 * SENT_CALL. Just ignore the packet, eventually a clear
		 * confirmation should arrive.
		 */
	case PK_CALL_ACCEPTED + SENT_CLEAR:
		break;

		/*
		 * Clear packet received. This requires a complete tear down
		 * of the virtual circuit.  Free buffers and control blocks.
		 * and send a clear confirmation.
		 */
	case PK_CLEAR + READY:
	case PK_CLEAR + RECEIVED_CALL:
	case PK_CLEAR + SENT_CALL:
	case PK_CLEAR + DATA_TRANSFER:
		lcp->lcd_state = RECEIVED_CLEAR;
		lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_CLEAR_CONFIRM);
		pk_output(lcp);
		pk_clearcause(pkp, xp);
		if (lcp->lcd_upper) {
			MCHTYPE(m, MT_CONTROL);
			(*lcp->lcd_upper)(m, lcp);
		}
		pk_close(lcp);
		lcp = 0;
		break;

		/*
		 * Clear collision: Treat this clear packet as a
		 * confirmation.
		 */
	case PK_CLEAR + SENT_CLEAR:
		pk_close(lcp);
		break;

		/*
		 * Clear confirmation received. This usually means the
		 * virtual circuit is now completely removed.
		 */
	case PK_CLEAR_CONF + SENT_CLEAR:
		pk_close(lcp);
		break;

		/*
		 * A clear confirmation on an unassigned logical channel -
		 * just ignore it. Note: All other packets on an unassigned
		 * channel results in a clear.
		 */
	case PK_CLEAR_CONF + READY:
	case PK_CLEAR_CONF + LISTEN:
		break;

		/*
		 * Data packet received. Pass on to next level. Move the Q
		 * and M bits into the data portion for the next level.
		 */
	case PK_DATA + DATA_TRANSFER:
		if (lcp->lcd_reset_condition) {
			ptype = PK_DELETE_PACKET;
			break;
		}
		/*
		 * Process the P(S) flow control information in this Data
		 * packet. Check that the packets arrive in the correct
		 * sequence and that they are within the "lcd_input_window".
		 * Input window rotation is initiated by the receive
		 * interface.
		 */

		if (PS(xp) != ((lcp->lcd_rsn + 1) % MODULUS) ||
		    PS(xp) == ((lcp->lcd_input_window + lcp->lcd_windowsize) % MODULUS)) {
			m_freem(m);
			pk_procerror(PK_RESET, lcp,
				     "p(s) flow control error", 1);
			break;
		}
		lcp->lcd_rsn = PS(xp);

		if (pk_ack(lcp, PR(xp)) != PACKET_OK) {
			m_freem(m);
			break;
		}
		m->m_data += PKHEADERLN;
		m->m_len -= PKHEADERLN;
		m->m_pkthdr.len -= PKHEADERLN;

		lcp->lcd_rxcnt++;
		if (lcp->lcd_flags & X25_MBS_HOLD) {
			struct mbuf *n = lcp->lcd_cps;
			int             mbit = MBIT(xp);
			octet           q_and_d_bits;

			if (n) {
				n->m_pkthdr.len += m->m_pkthdr.len;
				while (n->m_next)
					n = n->m_next;
				n->m_next = m;
				m = lcp->lcd_cps;

				if (lcp->lcd_cpsmax &&
				    n->m_pkthdr.len > lcp->lcd_cpsmax) {
					pk_procerror(PK_RESET, lcp,
						     "C.P.S. overflow", 128);
					return;
				}
				q_and_d_bits = 0xc0 & *(octet *) xp;
				xp = (struct x25_packet *)
					(mtod(m, octet *) - PKHEADERLN);
				*(octet *) xp |= q_and_d_bits;
			}
			if (mbit) {
				lcp->lcd_cps = m;
				pk_flowcontrol(lcp, 0, 1);
				return;
			}
			lcp->lcd_cps = 0;
		}
		if (so == 0)
			break;
		if (lcp->lcd_flags & X25_MQBIT) {
			octet t = (X25GBITS(xp->bits, q_bit)) ? t = 0x80 : 0;

			if (MBIT(xp))
				t |= 0x40;
			m->m_data -= 1;
			m->m_len += 1;
			m->m_pkthdr.len += 1;
			*mtod(m, octet *) = t;
		}
		/*
		 * Discard Q-BIT packets if the application
		 * doesn't want to be informed of M and Q bit status
		 */
		if (X25GBITS(xp->bits, q_bit)
		    && (lcp->lcd_flags & X25_MQBIT) == 0) {
			m_freem(m);
			/*
			 * NB.  This is dangerous: sending a RR here can
			 * cause sequence number errors if a previous data
			 * packet has not yet been passed up to the application
			 * (RR's are normally generated via PRU_RCVD).
			 */
			pk_flowcontrol(lcp, 0, 1);
		} else {
			sbappendrecord(&so->so_rcv, m);
			sorwakeup(so);
		}
		break;

		/*
		 * Interrupt packet received.
		 */
	case PK_INTERRUPT + DATA_TRANSFER:
		if (lcp->lcd_reset_condition)
			break;
		lcp->lcd_intrdata = xp->packet_data;
		lcp->lcd_template = pk_template(lcp->lcd_lcn,
						X25_INTERRUPT_CONFIRM);
		pk_output(lcp);
		m->m_data += PKHEADERLN;
		m->m_len -= PKHEADERLN;
		m->m_pkthdr.len -= PKHEADERLN;
		MCHTYPE(m, MT_OOBDATA);
		if (so) {
			if (so->so_options & SO_OOBINLINE)
				sbinsertoob(&so->so_rcv, m);
			else
				m_freem(m);
			sohasoutofband(so);
		}
		break;

		/*
		 * Interrupt confirmation packet received.
		 */
	case PK_INTERRUPT_CONF + DATA_TRANSFER:
		if (lcp->lcd_reset_condition)
			break;
		if (lcp->lcd_intrconf_pending == TRUE)
			lcp->lcd_intrconf_pending = FALSE;
		else
			pk_procerror(PK_RESET, lcp, "unexpected packet", 43);
		break;

		/*
		 * Receiver ready received. Rotate the output window and
		 * output any data packets waiting transmission.
		 */
	case PK_RR + DATA_TRANSFER:
		if (lcp->lcd_reset_condition ||
		    pk_ack(lcp, PR(xp)) != PACKET_OK) {
			ptype = PK_DELETE_PACKET;
			break;
		}
		if (lcp->lcd_rnr_condition == TRUE)
			lcp->lcd_rnr_condition = FALSE;
		pk_output(lcp);
		break;

		/*
		 * Receiver Not Ready received. Packets up to the P(R) can be
		 * be sent. Condition is cleared with a RR.
		 */
	case PK_RNR + DATA_TRANSFER:
		if (lcp->lcd_reset_condition ||
		    pk_ack(lcp, PR(xp)) != PACKET_OK) {
			ptype = PK_DELETE_PACKET;
			break;
		}
		lcp->lcd_rnr_condition = TRUE;
		break;

		/*
		 * Reset packet received. Set state to FLOW_OPEN.  The Input
		 * and Output window edges ar set to zero. Both the send and
		 * receive numbers are reset. A confirmation is returned.
		 */
	case PK_RESET + DATA_TRANSFER:
		if (lcp->lcd_reset_condition)
			/* Reset collision. Just ignore packet. */
			break;

		pk_resetcause(pkp, xp);
		lcp->lcd_window_condition = lcp->lcd_rnr_condition =
			lcp->lcd_intrconf_pending = FALSE;
		lcp->lcd_output_window = lcp->lcd_input_window =
			lcp->lcd_last_transmitted_pr = 0;
		lcp->lcd_ssn = 0;
		lcp->lcd_rsn = MODULUS - 1;

		lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_RESET_CONFIRM);
		pk_output(lcp);

		pk_flush(lcp);
		if (so == 0)
			break;
		wakeup((caddr_t) & so->so_timeo);
		sorwakeup(so);
		sowwakeup(so);
		break;

		/*
		 * Reset confirmation received.
		 */
	case PK_RESET_CONF + DATA_TRANSFER:
		if (lcp->lcd_reset_condition) {
			lcp->lcd_reset_condition = FALSE;
			pk_output(lcp);
		} else
			pk_procerror(PK_RESET, lcp, "unexpected packet", 32);
		break;

	case PK_DATA + SENT_CLEAR:
		ptype = PK_DELETE_PACKET;
	case PK_RR + SENT_CLEAR:
	case PK_RNR + SENT_CLEAR:
	case PK_INTERRUPT + SENT_CLEAR:
	case PK_INTERRUPT_CONF + SENT_CLEAR:
	case PK_RESET + SENT_CLEAR:
	case PK_RESET_CONF + SENT_CLEAR:
		/*
		 * Just ignore p if we have sent a CLEAR already.
		 */
		break;

		/*
		 * Restart sets all the permanent virtual circuits to the
		 * "Data Transfer" stae and  all the switched virtual
		 * circuits to the "Ready" state.
		 */
	case PK_RESTART + READY:
		switch (pkp->pk_state) {
		case DTE_SENT_RESTART:
			/*
			 * Restart collision. If case the restart cause is
			 * "DTE originated" we have a DTE-DTE situation and
			 * are trying to resolve who is going to play DTE/DCE
			 * [ISO 8208:4.2-4.5]
			 */
			if (RESTART_DTE_ORIGINATED(xp)) {
				pk_restart(pkp, X25_RESTART_DTE_ORIGINATED);
				pk_message(0, pkp->pk_xcp,
					   "RESTART collision");
				if ((pkp->pk_restartcolls++) > MAXRESTARTCOLLISIONS) {
					pk_message(0, pkp->pk_xcp,
					    "excessive RESTART collisions");
					pkp->pk_restartcolls = 0;
				}
				break;
			}
			pkp->pk_state = DTE_READY;
			pkp->pk_dxerole |= DTE_PLAYDTE;
			pkp->pk_dxerole &= ~DTE_PLAYDCE;
			pk_message(0, pkp->pk_xcp,
				   "Packet level operational");
			pk_message(0, pkp->pk_xcp,
				   "Assuming DTE role");
			if (pkp->pk_dxerole & DTE_CONNECTPENDING)
				pk_callcomplete(pkp);
			break;

		default:
			pk_restart(pkp, -1);
			pk_restartcause(pkp, xp);
			pkp->pk_chan[0]->lcd_template = pk_template(0,
						       X25_RESTART_CONFIRM);
			pk_output(pkp->pk_chan[0]);
			pkp->pk_state = DTE_READY;
			pkp->pk_dxerole |= RESTART_DTE_ORIGINATED(xp) ? DTE_PLAYDCE :
				DTE_PLAYDTE;
			if (pkp->pk_dxerole & DTE_PLAYDTE) {
				pkp->pk_dxerole &= ~DTE_PLAYDCE;
				pk_message(0, pkp->pk_xcp,
					   "Assuming DTE role");
			} else {
				pkp->pk_dxerole &= ~DTE_PLAYDTE;
				pk_message(0, pkp->pk_xcp,
					   "Assuming DCE role");
			}
			if (pkp->pk_dxerole & DTE_CONNECTPENDING)
				pk_callcomplete(pkp);
		}
		break;

		/*
		 * Restart confirmation received. All logical channels are
		 * set to READY.
		 */
	case PK_RESTART_CONF + READY:
		switch (pkp->pk_state) {
		case DTE_SENT_RESTART:
			pkp->pk_state = DTE_READY;
			pkp->pk_dxerole |= DTE_PLAYDTE;
			pkp->pk_dxerole &= ~DTE_PLAYDCE;
			pk_message(0, pkp->pk_xcp,
				   "Packet level operational");
			pk_message(0, pkp->pk_xcp,
				   "Assuming DTE role");
			if (pkp->pk_dxerole & DTE_CONNECTPENDING)
				pk_callcomplete(pkp);
			break;

		default:
			/* Restart local procedure error. */
			pk_restart(pkp, X25_RESTART_LOCAL_PROCEDURE_ERROR);
			pkp->pk_state = DTE_SENT_RESTART;
			pkp->pk_dxerole &= ~(DTE_PLAYDTE | DTE_PLAYDCE);
		}
		break;

	default:
		if (lcp) {
			pk_procerror(PK_CLEAR, lcp, "unknown packet error", 33);
			pk_message(lcn, pkp->pk_xcp,
				   "\"%s\" unexpected in \"%s\" state",
			    pk_name[ptype / MAXSTATES], pk_state[lcdstate]);
		} else
			pk_message(lcn, pkp->pk_xcp,
				   "packet arrived on unassigned lcn");
		break;
	}
	if (so == 0 && lcp && lcp->lcd_upper && lcdstate == DATA_TRANSFER) {
		if (ptype != PK_DATA && ptype != PK_INTERRUPT)
			MCHTYPE(m, MT_CONTROL);
		lcp->lcd_upper(m, lcp);
	} else if (ptype != PK_DATA && ptype != PK_INTERRUPT)
		m_freem(m);
}

static void
prune_dnic(from, to, dnicname, xcp)
	char           *from, *to, *dnicname;
	struct x25config *xcp;
{
	char  *cp1 = from, *cp2 = from;
	if (xcp->xc_prepnd0 && *cp1 == '0') {
		from = ++cp1;
		goto copyrest;
	}
	if (xcp->xc_nodnic) {
		for (cp1 = dnicname; (*cp2 = *cp1++) != '\0';)
			cp2++;
		cp1 = from;
	}
copyrest:
	for (cp1 = dnicname; (*cp2 = *cp1++) != '\0';)
		cp2++;
}

void
pk_simple_bsd(from, to, lower, len)
	octet *from, *to;
	int    len, lower;
{
	int    c;
	while (--len >= 0) {
		c = *from;
		if (lower & 0x01)
			from++;
		else
			c >>= 4;
		c &= 0x0f;
		c |= 0x30;
		*to++ = c;
		lower++;
	}
	*to = 0;
}

void
pk_from_bcd(a, iscalling, sa, xcp)
	struct x25_calladdr *a;
	int             iscalling;
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
{
	octet           buf[MAXADDRLN + 1];
	octet          *cp;
	unsigned        count;

	bzero((caddr_t) sa, sizeof(*sa));
	sa->x25_len = sizeof(*sa);
	sa->x25_family = AF_CCITT;
	if (iscalling) {
		cp = a->address_field + (X25GBITS(a->addrlens, called_addrlen) / 2);
		count = X25GBITS(a->addrlens, calling_addrlen);
		pk_simple_bsd(cp, buf, X25GBITS(a->addrlens, called_addrlen), count);
	} else {
		count = X25GBITS(a->addrlens, called_addrlen);
		pk_simple_bsd(a->address_field, buf, 0, count);
	}
	if (xcp->xc_addr.x25_net && (xcp->xc_nodnic || xcp->xc_prepnd0)) {
		octet           dnicname[sizeof(long) * NBBY / 3 + 2];

		sprintf((char *) dnicname, "%d", xcp->xc_addr.x25_net);
		prune_dnic((char *) buf, sa->x25_addr, dnicname, xcp);
	} else
		bcopy((caddr_t) buf, (caddr_t) sa->x25_addr, count + 1);
}

static void
save_extra(m0, fp, so)
	struct mbuf    *m0;
	octet          *fp;
	struct socket  *so;
{
	struct mbuf *m;
	struct cmsghdr  cmsghdr;
	/* XXX: christos:
	 * used to be m_copy(m, 0, ...)
	 * I think it is supposed to be m_copy(m0, 
	 */
	if ((m = m_copy(m0, 0, (int) M_COPYALL)) != NULL) {
		int             off = fp - mtod(m0, octet *);
		int             len = m->m_pkthdr.len - off + sizeof(cmsghdr);
		cmsghdr.cmsg_len = len;
		cmsghdr.cmsg_level = AF_CCITT;
		cmsghdr.cmsg_type = PK_FACILITIES;
		m_adj(m, off);
		M_PREPEND(m, sizeof(cmsghdr), M_DONTWAIT);
		if (m == 0)
			return;
		bcopy((caddr_t) & cmsghdr, mtod(m, caddr_t), sizeof(cmsghdr));
		MCHTYPE(m, MT_CONTROL);
		sbappendrecord(&so->so_rcv, m);
	}
}

/*
 * This routine handles incoming call packets. It matches the protocol field
 * on the Call User Data field (usually the first four bytes) with sockets
 * awaiting connections.
 */

void
pk_incoming_call(pkp, m0)
	struct pkcb    *pkp;
	struct mbuf    *m0;
{
	struct pklcd *lcp = 0, *l;
	struct sockaddr_x25 *sa;
	struct x25_calladdr *a;
	struct socket *so = 0;
	struct x25_packet *xp = mtod(m0, struct x25_packet *);
	struct mbuf    *m;
	struct x25config *xcp = pkp->pk_xcp;
	int             len = m0->m_pkthdr.len;
	unsigned        udlen;
	char           *errstr = "server unavailable";
	octet          *u, *facp;
	int             lcn = LCN(xp);

	/*
	 * First, copy the data from the incoming call packet to a X25
	 * address descriptor. It is to be regretted that you have to parse
	 * the facilities into a sockaddr to determine if reverse charging is
	 * being requested
	 */
	if ((m = m_get(M_DONTWAIT, MT_SONAME)) == 0)
		return;
	sa = mtod(m, struct sockaddr_x25 *);
	a = (struct x25_calladdr *) & xp->packet_data;
	facp = u = (octet *) (a->address_field +
			      ((X25GBITS(a->addrlens, called_addrlen) + X25GBITS(a->addrlens, calling_addrlen) + 1) / 2));
	u += *u + 1;
	udlen = min(16, ((octet *) xp) + len - u);
#if 0
	/* Cannot happen; udlen is unsigned */
	if (udlen < 0)
		udlen = 0;
#endif
	pk_from_bcd(a, 1, sa, pkp->pk_xcp);	/* get calling address */
	pk_parse_facilities(facp, sa);
	bcopy((caddr_t) u, sa->x25_udata, udlen);
	sa->x25_udlen = udlen;

	/*
	 * Now, loop through the listen sockets looking for a match on the
	 * PID. That is the first few octets of the user data field.
	 * This is the closest thing to a port number for X.25 packets.
	 * It does provide a way of multiplexing services at the user level.
	 */

	for (l = pk_listenhead; l; l = l->lcd_listen) {
		struct sockaddr_x25 *sxp = l->lcd_ceaddr;

		if (bcmp(sxp->x25_udata, u, sxp->x25_udlen))
			continue;
		if (sxp->x25_net &&
		    sxp->x25_net != xcp->xc_addr.x25_net)
			continue;
		/*
		 * don't accept incoming calls with the D-Bit on
		 * unless the server agrees
		 */
		if (X25GBITS(xp->bits, d_bit) && !(sxp->x25_opts.op_flags & X25_DBIT)) {
			errstr = "incoming D-Bit mismatch";
			break;
		}
		/*
		 * don't accept incoming collect calls unless
		 * the server sets the reverse charging option.
		 */
		if ((sxp->x25_opts.op_flags & (X25_OLDSOCKADDR | X25_REVERSE_CHARGE)) == 0 &&
		    sa->x25_opts.op_flags & X25_REVERSE_CHARGE) {
			errstr = "incoming collect call refused";
			break;
		}
		if (l->lcd_so) {
			so = sonewconn(l->lcd_so, SS_ISCONNECTED);
			if (so)
				lcp = (struct pklcd *) so->so_pcb;
		} else
			lcp = pk_attach((struct socket *) 0);
		if (lcp == 0) {
			/*
			 * Insufficient space or too many unaccepted
			 * connections.  Just throw the call away.
			 */
			errstr = "server malfunction";
			break;
		}
		lcp->lcd_upper = l->lcd_upper;
		lcp->lcd_upnext = l->lcd_upnext;
		lcp->lcd_lcn = lcn;
		lcp->lcd_state = RECEIVED_CALL;
		sa->x25_opts.op_flags |= (sxp->x25_opts.op_flags &
					~X25_REVERSE_CHARGE) | l->lcd_flags;
		pk_assoc(pkp, lcp, sa);
		lcp->lcd_faddr = *sa;
		lcp->lcd_laddr.x25_udlen = sxp->x25_udlen;
		lcp->lcd_craddr = &lcp->lcd_faddr;
		lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_CALL_ACCEPTED);
		if (lcp->lcd_flags & X25_DBIT) {
			if (X25GBITS(xp->bits, d_bit))
				X25SBITS(mtod(lcp->lcd_template,
				      struct x25_packet *)->bits, d_bit, 1);
			else
				lcp->lcd_flags &= ~X25_DBIT;
		}
		if (so) {
			pk_output(lcp);
			soisconnected(so);
			if (so->so_options & SO_OOBINLINE)
				save_extra(m0, facp, so);
		} else if (lcp->lcd_upper) {
			(*lcp->lcd_upper) (m0, lcp);
		}
		(void) m_free(m);
		return;
	}

	/*
	 * If the call fails for whatever reason, we still need to build a
	 * skeleton LCD in order to be able to properly  receive the CLEAR
	 * CONFIRMATION.
	 */
#ifdef WATERLOO			/* be explicit */
	if (l == 0 && bcmp(sa->x25_udata, "ean", 3) == 0)
		pk_message(lcn, pkp->pk_xcp, "host=%s ean%c: %s",
			   sa->x25_addr, sa->x25_udata[3] & 0xff, errstr);
	else if (l == 0 && bcmp(sa->x25_udata, "\1\0\0\0", 4) == 0)
		pk_message(lcn, pkp->pk_xcp, "host=%s x29d: %s",
			   sa->x25_addr, errstr);
	else
#endif
		pk_message(lcn, pkp->pk_xcp, "host=%s pid=%x %x %x %x: %s",
			   sa->x25_addr, sa->x25_udata[0] & 0xff,
			   sa->x25_udata[1] & 0xff, sa->x25_udata[2] & 0xff,
			   sa->x25_udata[3] & 0xff, errstr);
	if ((lcp = pk_attach((struct socket *) 0)) == 0) {
		(void) m_free(m);
		return;
	}
	lcp->lcd_lcn = lcn;
	lcp->lcd_state = RECEIVED_CALL;
	pk_assoc(pkp, lcp, sa);
	(void) m_free(m);
	pk_clear(lcp, 0, 1);
}

void
pk_call_accepted(lcp, m)
	struct pklcd   *lcp;
	struct mbuf    *m;
{
	struct x25_calladdr *ap;
	octet *fcp;
	struct x25_packet *xp = mtod(m, struct x25_packet *);
	int             len = m->m_len;

	lcp->lcd_state = DATA_TRANSFER;
	if (lcp->lcd_so)
		soisconnected(lcp->lcd_so);
	if ((lcp->lcd_flags & X25_DBIT) && (X25GBITS(xp->bits, d_bit) == 0))
		lcp->lcd_flags &= ~X25_DBIT;
	if (len > 3) {
		ap = (struct x25_calladdr *) & xp->packet_data;
		fcp = (octet *) ap->address_field + (X25GBITS(ap->addrlens, calling_addrlen) +
			    X25GBITS(ap->addrlens, called_addrlen) + 1) / 2;
		if (fcp + *fcp <= ((octet *) xp) + len)
			pk_parse_facilities(fcp, lcp->lcd_ceaddr);
	}
	pk_assoc(lcp->lcd_pkp, lcp, lcp->lcd_ceaddr);
	if (lcp->lcd_so == 0 && lcp->lcd_upper)
		(*lcp->lcd_upper)(m, lcp);
}

void
pk_parse_facilities(fcp, sa)
	octet *fcp;
	struct sockaddr_x25 *sa;
{
	octet *maxfcp;

	maxfcp = fcp + *fcp;
	fcp++;
	while (fcp < maxfcp) {
		/*
		 * Ignore national DCE or DTE facilities
		 */
		if (*fcp == 0 || *fcp == 0xff)
			break;
		switch (*fcp) {
		case FACILITIES_WINDOWSIZE:
			sa->x25_opts.op_wsize = fcp[1];
			fcp += 3;
			break;

		case FACILITIES_PACKETSIZE:
			sa->x25_opts.op_psize = fcp[1];
			fcp += 3;
			break;

		case FACILITIES_THROUGHPUT:
			sa->x25_opts.op_speed = fcp[1];
			fcp += 2;
			break;

		case FACILITIES_REVERSE_CHARGE:
			if (fcp[1] & 01)
				sa->x25_opts.op_flags |= X25_REVERSE_CHARGE;
			/*
			 * Datapac specific: for a X.25(1976) DTE, bit 2
			 * indicates a "hi priority" (eg. international) call.
			 */
			if (fcp[1] & 02 && sa->x25_opts.op_psize == 0)
				sa->x25_opts.op_psize = X25_PS128;
			fcp += 2;
			break;

		default:
			/*
			 * printf("unknown facility %x, class=%d\n", *fcp,
			 * (*fcp & 0xc0) >> 6);
			 */
			switch ((*fcp & 0xc0) >> 6) {
			case 0:/* class A */
				fcp += 2;
				break;

			case 1:
				fcp += 3;
				break;

			case 2:
				fcp += 4;
				break;

			case 3:
				fcp++;
				fcp += *fcp;
			}
		}
	}
}
@


1.8
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.7 2003/12/10 07:22:42 itojun Exp $	*/
@


1.7
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.6 2003/06/02 23:28:13 millert Exp $	*/
d68 1
a68 1
#include <machine/stdarg.h>
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.5 2002/03/15 18:19:52 millert Exp $	*/
d104 3
a106 3
	register struct x25config *xcp = &ia->ia_xc;
	register struct pkcb *pkp;
	register struct protosw *pp;
d147 1
a147 1
	register struct pkcb *pkp;
d149 2
a150 2
	register int    i;
	register struct protosw *pp;
d208 1
a208 1
	register struct pkcb *pkp;
d249 1
a249 1
	register struct pkcb *pkp = (struct pkcb *) addr;
d298 2
a299 2
	register struct mbuf *m;
	register int    s;
d341 4
a344 4
	register struct x25_packet *xp;
	register struct pklcd *lcp;
	register struct socket *so = 0;
	register struct pkcb *pkp;
d518 1
a518 1
			register struct mbuf *n = lcp->lcd_cps;
d802 1
a802 1
	register struct x25config *xcp;
d804 1
a804 1
	register char  *cp1 = from, *cp2 = from;
d821 2
a822 2
	register octet *from, *to;
	register int    len, lower;
d824 1
a824 1
	register int    c;
d841 1
a841 1
	register struct x25_calladdr *a;
d843 2
a844 2
	register struct sockaddr_x25 *sa;
	register struct x25config *xcp;
d876 1
a876 1
	register struct mbuf *m;
d909 4
a912 4
	register struct pklcd *lcp = 0, *l;
	register struct sockaddr_x25 *sa;
	register struct x25_calladdr *a;
	register struct socket *so = 0;
d1056 2
a1057 2
	register struct x25_calladdr *ap;
	register octet *fcp;
d1080 2
a1081 2
	register octet *fcp;
	register struct sockaddr_x25 *sa;
d1083 1
a1083 1
	register octet *maxfcp;
@


1.5
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.4 2002/03/14 01:27:10 millert Exp $	*/
d24 1
a24 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.3 2001/05/16 12:53:35 ho Exp $	*/
a342 1
#if __STDC__
a343 5
#else
pk_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.3
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.2 1996/03/04 07:36:41 niklas Exp $	*/
d76 2
a77 2
static void prune_dnic __P((char *, char *, char *, struct x25config *));
static void save_extra __P((struct mbuf *, octet *, struct socket *));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.3 2001/05/16 12:53:35 ho Exp $	*/
d76 2
a77 2
static void prune_dnic(char *, char *, char *, struct x25config *);
static void save_extra(struct mbuf *, octet *, struct socket *);
d343 1
d345 5
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a122 2
	if (pkp == 0)
		return ((struct pkcb *) 0);
d228 6
a233 14
		if (pkp->pk_chan) {
			bzero((caddr_t) pkp->pk_chan, size);
			/*
			 * Allocate a logical channel descriptor for lcn 0
			 */
			if (dev_lcp == 0 &&
			    (dev_lcp = pk_attach((struct socket *) 0)) == 0)
				return (ENOBUFS);
			dev_lcp->lcd_state = READY;
			dev_lcp->lcd_pkp = pkp;
			pkp->pk_chan[0] = dev_lcp;
		} else {
			if (dev_lcp)
				pk_close(dev_lcp);
d235 3
a237 1
		}
@


1.2.16.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.2 1996/03/04 07:36:41 niklas Exp $	*/
d123 2
d230 14
a243 6
		bzero((caddr_t) pkp->pk_chan, size);
		/*
		 * Allocate a logical channel descriptor for lcn 0
		 */
		if (dev_lcp == 0 &&
		    (dev_lcp = pk_attach((struct socket *) 0)) == 0)
d245 1
a245 3
		dev_lcp->lcd_state = READY;
		dev_lcp->lcd_pkp = pkp;
		pkp->pk_chan[0] = dev_lcp;
@


1.2.16.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 2
a77 2
static void prune_dnic(char *, char *, char *, struct x25config *);
static void save_extra(struct mbuf *, octet *, struct socket *);
d343 1
d345 5
@


1.2.16.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_input.c,v 1.2.16.2 2002/03/28 14:57:37 niklas Exp $	*/
d24 5
a28 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.16.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
#include <sys/stdarg.h>
d104 3
a106 3
	struct x25config *xcp = &ia->ia_xc;
	struct pkcb *pkp;
	struct protosw *pp;
d147 1
a147 1
	struct pkcb *pkp;
d149 2
a150 2
	int    i;
	struct protosw *pp;
d208 1
a208 1
	struct pkcb *pkp;
d249 1
a249 1
	struct pkcb *pkp = (struct pkcb *) addr;
d298 2
a299 2
	struct mbuf *m;
	int    s;
d341 4
a344 4
	struct x25_packet *xp;
	struct pklcd *lcp;
	struct socket *so = 0;
	struct pkcb *pkp;
d518 1
a518 1
			struct mbuf *n = lcp->lcd_cps;
d802 1
a802 1
	struct x25config *xcp;
d804 1
a804 1
	char  *cp1 = from, *cp2 = from;
d821 2
a822 2
	octet *from, *to;
	int    len, lower;
d824 1
a824 1
	int    c;
d841 1
a841 1
	struct x25_calladdr *a;
d843 2
a844 2
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
d876 1
a876 1
	struct mbuf *m;
d909 4
a912 4
	struct pklcd *lcp = 0, *l;
	struct sockaddr_x25 *sa;
	struct x25_calladdr *a;
	struct socket *so = 0;
d1056 2
a1057 2
	struct x25_calladdr *ap;
	octet *fcp;
d1080 2
a1081 2
	octet *fcp;
	struct sockaddr_x25 *sa;
d1083 1
a1083 1
	octet *maxfcp;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: pk_input.c,v 1.6 1994/06/29 06:37:33 cgd Exp $	*/
d6 1
a6 1
 * Copyright (C) Computer Science Department IV, 
d53 1
d65 1
d67 8
d76 2
a77 1
struct pkcb_q pkcb_q = {&pkcb_q, &pkcb_q};
d85 1
a85 1
ccittintr ()
d93 1
a93 1
		hdintr ();
d97 1
a97 1
		llcintr ();
d100 1
a100 1
		pkintr ();
d103 4
a106 4
struct pkcb *
pk_newlink (ia, llnext)
struct x25_ifaddr *ia;
caddr_t llnext;
d108 1
a108 1
	register struct x25config *xcp = &ia -> ia_xc;
a109 1
	register struct pklcd *lcp;
d111 1
a111 1
	unsigned size;
d113 4
a116 4
	pp = pffindproto (AF_CCITT, (int) xcp -> xc_lproto, 0);
	if (pp == 0 || pp -> pr_output == 0) {
		pk_message (0, xcp, "link level protosw error");
		return ((struct pkcb *)0);
d121 2
a122 2
	size = sizeof (struct pkcb);
	pkp = (struct pkcb *) malloc (size, M_PCB, M_WAITOK);
d124 9
a132 9
		return ((struct pkcb *)0);
	bzero ((caddr_t) pkp, size);
	pkp -> pk_lloutput = pp -> pr_output;
	pkp -> pk_llctlinput = (caddr_t (*)()) pp -> pr_ctlinput;
	pkp -> pk_xcp = xcp;
	pkp -> pk_ia = ia;
	pkp -> pk_state = DTE_WAITING;
	pkp -> pk_llnext = llnext;
	insque (pkp, &pkcb_q);
d138 4
a141 4
	if (xcp -> xc_pwsize == 0)
		xcp -> xc_pwsize = DEFAULT_WINDOW_SIZE;
	if (xcp -> xc_psize == 0)
		xcp -> xc_psize = X25_PS128;
d146 1
a146 1
	(void) pk_resize (pkp);
d151 3
a153 2
pk_dellink (pkp)
register struct pkcb *pkp;
d155 1
a155 1
	register int i;
d157 1
a157 1
	
d168 4
a171 4
	
	for (i = 1; i < pkp -> pk_maxlcn; ++i)
		if (pkp -> pk_chan[i])
			pk_disconnect (pkp -> pk_chan[i]);
d182 3
a184 3
	pp = pffindproto (AF_CCITT, (int) pkp -> pk_xcp -> xc_lproto, 0);
	if (pp == 0 || pp -> pr_output == 0) {
		pk_message (0, pkp -> pk_xcp, "link level protosw error");
d187 3
d191 3
a193 3
	pkp -> pk_refcount--;
	if (!pkp -> pk_refcount) {
		struct dll_ctlinfo ctlinfo;
a194 4
		remque (pkp);
		if (pkp -> pk_rt -> rt_llinfo == (caddr_t) pkp)
			pkp -> pk_rt -> rt_llinfo = (caddr_t) NULL;
		
d198 6
a203 5
		if (pp -> pr_ctlinput && pkp -> pk_llnext) {
			ctlinfo.dlcti_pcb = pkp -> pk_llnext;
			ctlinfo.dlcti_rt = pkp -> pk_rt;
			(pp -> pr_ctlinput)(PRC_DISCONNECT_REQUEST, 
					    pkp -> pk_xcp, &ctlinfo);
d205 2
a206 2
		free ((caddr_t) pkp -> pk_chan, M_IFADDR);
		free ((caddr_t) pkp, M_PCB);
a207 1

d212 3
a214 2
pk_resize (pkp)
register struct pkcb *pkp;
d216 16
a231 17
	struct pklcd *dev_lcp = 0;
	struct x25config *xcp = pkp -> pk_xcp;
	if (pkp -> pk_chan &&
	    (pkp -> pk_maxlcn != xcp -> xc_maxlcn)) {
		pk_restart (pkp, X25_RESTART_NETWORK_CONGESTION);
		dev_lcp = pkp -> pk_chan[0];
		free ((caddr_t) pkp -> pk_chan, M_IFADDR);
		pkp -> pk_chan = 0;
	}
	if (pkp -> pk_chan == 0) {
		unsigned size;
		pkp -> pk_maxlcn = xcp -> xc_maxlcn;
		size = (pkp -> pk_maxlcn + 1) * sizeof (struct pklcd *);
		pkp -> pk_chan =
			(struct pklcd **) malloc (size, M_IFADDR, M_WAITOK);
		if (pkp -> pk_chan) {
			bzero ((caddr_t) pkp -> pk_chan, size);
d236 1
a236 1
			    (dev_lcp = pk_attach ((struct socket *)0)) == 0)
d238 3
a240 3
			dev_lcp -> lcd_state = READY;
			dev_lcp -> lcd_pkp = pkp;
			pkp -> pk_chan[0] = dev_lcp;
d243 1
a243 1
				pk_close (dev_lcp);
d250 3
a252 3
/* 
 *  This procedure is called by the link level whenever the link
 *  becomes operational, is reset, or when the link goes down. 
d254 4
a257 3
/*VARARGS*/
caddr_t
pk_ctlinput (code, src, addr)
d259 1
a259 1
	caddr_t addr;
d262 1
d265 3
a267 3
	case PRC_LINKUP: 
		if (pkp -> pk_state == DTE_WAITING)
			pk_restart (pkp, X25_RESTART_NETWORK_CONGESTION);
d270 3
a272 3
	case PRC_LINKDOWN: 
		pk_restart (pkp, -1);	/* Clear all active circuits */
		pkp -> pk_state = DTE_WAITING;
d275 2
a276 2
	case PRC_LINKRESET: 
		pk_restart (pkp, X25_RESTART_NETWORK_CONGESTION);
d278 2
a279 3
		
	case PRC_CONNECT_INDICATION: {
		struct rtentry *llrt;
d283 5
a287 4
		else llrt -> rt_refcnt--;
		
		pkp = (((struct npaidbentry *) llrt -> rt_llinfo) -> np_rt) ?
			(struct pkcb *)(((struct npaidbentry *) llrt -> rt_llinfo) -> np_rt -> rt_llinfo) : (struct pkcb *) 0;
d290 1
a290 1
		pkp -> pk_llnext = addr;
d293 1
a293 1
	}
d295 4
a298 3
		pk_restart (pkp, -1) ;  /* Clear all active circuits */
		pkp -> pk_state = DTE_WAITING;
		pkp -> pk_llnext = (caddr_t) 0;
d302 1
a302 1
struct ifqueue pkintrq;
d307 2
a308 1
pkintr ()
d311 1
a311 3
	register struct ifaddr *ifa;
	register struct ifnet *ifp;
	register int s;
d314 3
a316 3
		s = splimp ();
		IF_DEQUEUE (&pkintrq, m);
		splx (s);
d319 4
a322 4
		if (m -> m_len < PKHEADERLN) {
			printf ("pkintr: packet too short (len=%d)\n",
				m -> m_len);
			m_freem (m);
d325 1
a325 1
		pk_input (m);
d328 16
a343 16
struct mbuf *pk_bad_packet;
struct mbuf_cache pk_input_cache = {0 };
/* 
 *  X.25 PACKET INPUT
 *
 *  This procedure is called by a link level procedure whenever
 *  an information frame is received. It decodes the packet and
 *  demultiplexes based on the logical channel number.
 *
 *  We change the original conventions of the UBC code here --
 *  since there may be multiple pkcb's for a given interface
 *  of type 802.2 class 2, we retrieve which one it is from
 *  m_pkthdr.rcvif (which has been overwritten by lower layers);
 *  That field is then restored for the benefit of upper layers which
 *  may make use of it, such as CLNP.
 *
d346 3
a348 2
#define RESTART_DTE_ORIGINATED(xp) (((xp) -> packet_cause == X25_RESTART_DTE_ORIGINATED) || \
			    ((xp) -> packet_cause >= X25_RESTART_DTE_ORIGINATED2))
d350 8
a357 2
pk_input (m)
register struct mbuf *m;
d363 1
a363 1
	int  ptype, lcn, lcdstate = LISTEN;
d366 3
a368 3
		mbuf_cache (&pk_input_cache, m);
	if ((m -> m_flags & M_PKTHDR) == 0)
		panic ("pkintr");
d370 1
a370 1
	if ((pkp = (struct pkcb *) m -> m_pkthdr.rcvif) == 0)
d372 2
a373 2
	xp = mtod (m, struct x25_packet *);
	ptype = pk_decode (xp);
d375 1
a375 1
	lcp = pkp -> pk_chan[lcn];
d377 8
a384 8
	/* 
	 *  If the DTE is in Restart  state, then it will ignore data, 
	 *  interrupt, call setup and clearing, flow control and reset 
	 *  packets.
	 */
	if (lcn < 0 || lcn > pkp -> pk_maxlcn) {
		pk_message (lcn, pkp -> pk_xcp, "illegal lcn");
		m_freem (m);
d387 1
d389 3
a391 4
	pk_trace (pkp -> pk_xcp, m, "P-In");

	if (pkp -> pk_state != DTE_READY && ptype != RESTART && ptype != RESTART_CONF) {
		m_freem (m);
d395 2
a396 2
		so = lcp -> lcd_so;
		lcdstate = lcp -> lcd_state;
d398 1
a398 1
		if (ptype == CLEAR) {	/* idle line probe (Datapac specific) */
d400 4
a403 4
			lcp = pkp -> pk_chan[0];
			lcp -> lcd_template = pk_template (lcn, X25_CLEAR_CONFIRM);
			pk_output (lcp);
			m_freem (m);
d406 2
a407 2
		if (ptype != CALL)
			ptype = INVALID_PACKET;
d410 3
a412 3
	if (lcn == 0 && ptype != RESTART && ptype != RESTART_CONF) {
		pk_message (0, pkp -> pk_xcp, "illegal ptype (%d, %s) on lcn 0",
			ptype, pk_name[ptype / MAXSTATES]);
d414 1
a414 1
			m_freem (pk_bad_packet);
d418 1
a418 2

	m -> m_pkthdr.rcvif = pkp -> pk_ia -> ia_ifp;
d421 5
a425 5
	/* 
	 *  Incoming Call packet received. 
	 */
	case CALL + LISTEN: 
		pk_incoming_call (pkp, m);
d428 7
a434 7
	/* 	
	 *  Call collision: Just throw this "incoming call" away since 
	 *  the DCE will ignore it anyway. 
	 */
	case CALL + SENT_CALL: 
		pk_message ((int) lcn, pkp -> pk_xcp, 
			"incoming call collision");
d437 5
a441 5
	/* 
	 *  Call confirmation packet received. This usually means our
	 *  previous connect request is now complete.
	 */
	case CALL_ACCEPTED + SENT_CALL: 
d443 1
a443 1
		pk_call_accepted (lcp, m);
d446 6
a451 6
	/* 
	 *  This condition can only happen if the previous state was
	 *  SENT_CALL. Just ignore the packet, eventually a clear 
	 *  confirmation should arrive.
	 */
	case CALL_ACCEPTED + SENT_CLEAR: 
d454 14
a467 14
	/* 
	 *  Clear packet received. This requires a complete tear down
	 *  of the virtual circuit.  Free buffers and control blocks.
	 *  and send a clear confirmation.
	 */
	case CLEAR + READY:
	case CLEAR + RECEIVED_CALL: 
	case CLEAR + SENT_CALL: 
	case CLEAR + DATA_TRANSFER: 
		lcp -> lcd_state = RECEIVED_CLEAR;
		lcp -> lcd_template = pk_template (lcp -> lcd_lcn, X25_CLEAR_CONFIRM);
		pk_output (lcp);
		pk_clearcause (pkp, xp);
		if (lcp -> lcd_upper) {
d469 1
a469 1
			lcp -> lcd_upper (lcp, m);
d471 1
a471 1
		pk_close (lcp);
d475 6
a480 5
	/* 
	 *  Clear collision: Treat this clear packet as a confirmation.
	 */
	case CLEAR + SENT_CLEAR: 
		pk_close (lcp);
d483 6
a488 6
	/* 
	 *  Clear confirmation received. This usually means the virtual
	 *  circuit is now completely removed.
	 */
	case CLEAR_CONF + SENT_CLEAR: 
		pk_close (lcp);
d491 7
a497 7
	/* 
	 *  A clear confirmation on an unassigned logical channel - just
	 *  ignore it. Note: All other packets on an unassigned channel
	 *  results in a clear.
	 */
	case CLEAR_CONF + READY:
	case CLEAR_CONF + LISTEN:
d500 7
a506 7
	/* 
	 *  Data packet received. Pass on to next level. Move the Q and M
	 *  bits into the data portion for the next level.
	 */
	case DATA + DATA_TRANSFER: 
		if (lcp -> lcd_reset_condition) {
			ptype = DELETE_PACKET;
d509 6
a514 6

		/* 
		 *  Process the P(S) flow control information in this Data packet. 
		 *  Check that the packets arrive in the correct sequence and that 
		 *  they are within the "lcd_input_window". Input window rotation is 
		 *  initiated by the receive interface.
d517 5
a521 4
		if (PS(xp) != ((lcp -> lcd_rsn + 1) % MODULUS) ||
			PS(xp) == ((lcp -> lcd_input_window + lcp -> lcd_windowsize) % MODULUS)) {
			m_freem (m);
			pk_procerror (RESET, lcp, "p(s) flow control error", 1);
d524 1
a524 1
		lcp -> lcd_rsn = PS(xp);
d526 2
a527 2
		if (pk_ack (lcp, PR(xp)) != PACKET_OK) {
			m_freem (m);
d530 3
a532 3
		m -> m_data += PKHEADERLN;
		m -> m_len -= PKHEADERLN;
		m -> m_pkthdr.len -= PKHEADERLN;
d534 5
a538 5
		lcp -> lcd_rxcnt++;
		if (lcp -> lcd_flags & X25_MBS_HOLD) {
			register struct mbuf *n = lcp -> lcd_cps;
			int mbit = MBIT(xp);
			octet q_and_d_bits;
d541 10
a550 10
				n -> m_pkthdr.len += m -> m_pkthdr.len;
				while (n -> m_next)
					n = n -> m_next;
				n -> m_next = m;
				m = lcp -> lcd_cps;

				if (lcp -> lcd_cpsmax &&
				    n -> m_pkthdr.len > lcp -> lcd_cpsmax) {
					pk_procerror (RESET, lcp,
						"C.P.S. overflow", 128);
d555 1
a555 1
					(mtod (m, octet *) - PKHEADERLN);
d559 2
a560 2
				lcp -> lcd_cps = m;
				pk_flowcontrol (lcp, 0, 1);
d563 1
a563 1
			lcp -> lcd_cps = 0;
d567 2
a568 2
		if (lcp -> lcd_flags & X25_MQBIT) {
			octet t = (X25GBITS(xp -> bits, q_bit)) ? t = 0x80 : 0;
d572 4
a575 4
			m -> m_data -= 1;
			m -> m_len += 1;
			m -> m_pkthdr.len += 1;
			*mtod (m, octet *) = t;
a576 1

d581 3
a583 3
		if (X25GBITS(xp -> bits, q_bit) 
		    && (lcp -> lcd_flags & X25_MQBIT) == 0) {
			m_freem (m);
d590 1
a590 1
			pk_flowcontrol (lcp, 0, 1);
d592 2
a593 2
			sbappendrecord (&so -> so_rcv, m);
			sorwakeup (so);
d597 5
a601 5
	/* 
	 *  Interrupt packet received.
	 */
	case INTERRUPT + DATA_TRANSFER: 
		if (lcp -> lcd_reset_condition)
d603 7
a609 6
		lcp -> lcd_intrdata = xp -> packet_data;
		lcp -> lcd_template = pk_template (lcp -> lcd_lcn, X25_INTERRUPT_CONFIRM);
		pk_output (lcp);
		m -> m_data += PKHEADERLN;
		m -> m_len -= PKHEADERLN;
		m -> m_pkthdr.len -= PKHEADERLN;
d612 2
a613 2
			if (so -> so_options & SO_OOBINLINE)
				sbinsertoob (&so -> so_rcv, m);
d615 2
a616 2
				m_freem (m);
			sohasoutofband (so);
d620 5
a624 5
	/* 
	 *  Interrupt confirmation packet received.
	 */
	case INTERRUPT_CONF + DATA_TRANSFER: 
		if (lcp -> lcd_reset_condition)
d626 2
a627 2
		if (lcp -> lcd_intrconf_pending == TRUE)
			lcp -> lcd_intrconf_pending = FALSE;
d629 1
a629 1
			pk_procerror (RESET, lcp, "unexpected packet", 43);
d632 8
a639 8
	/* 
	 *  Receiver ready received. Rotate the output window and output
	 *  any data packets waiting transmission.
	 */
	case RR + DATA_TRANSFER: 
		if (lcp -> lcd_reset_condition ||
		    pk_ack (lcp, PR(xp)) != PACKET_OK) {
			ptype = DELETE_PACKET;
d642 3
a644 3
		if (lcp -> lcd_rnr_condition == TRUE)
			lcp -> lcd_rnr_condition = FALSE;
		pk_output (lcp);
d647 8
a654 8
	/* 
	 *  Receiver Not Ready received. Packets up to the P(R) can be
	 *  be sent. Condition is cleared with a RR.
	 */
	case RNR + DATA_TRANSFER: 
		if (lcp -> lcd_reset_condition ||
		    pk_ack (lcp, PR(xp)) != PACKET_OK) {
			ptype = DELETE_PACKET;
d657 1
a657 1
		lcp -> lcd_rnr_condition = TRUE;
d660 7
a666 7
	/* 
	 *  Reset packet received. Set state to FLOW_OPEN.  The Input and
	 *  Output window edges ar set to zero. Both the send and receive
	 *  numbers are reset. A confirmation is returned.
	 */
	case RESET + DATA_TRANSFER: 
		if (lcp -> lcd_reset_condition)
d670 7
a676 7
		pk_resetcause (pkp, xp);
		lcp -> lcd_window_condition = lcp -> lcd_rnr_condition =
			lcp -> lcd_intrconf_pending = FALSE;
		lcp -> lcd_output_window = lcp -> lcd_input_window =
			lcp -> lcd_last_transmitted_pr = 0;
		lcp -> lcd_ssn = 0;
		lcp -> lcd_rsn = MODULUS - 1;
d678 2
a679 2
		lcp -> lcd_template = pk_template (lcp -> lcd_lcn, X25_RESET_CONFIRM);
		pk_output (lcp);
d681 1
a681 1
		pk_flush (lcp);
d684 14
a697 3
		wakeup ((caddr_t) & so -> so_timeo);
		sorwakeup (so);
		sowwakeup (so);
d700 11
a710 10
	/* 
	 *  Reset confirmation received.
	 */
	case RESET_CONF + DATA_TRANSFER: 
		if (lcp -> lcd_reset_condition) {
			lcp -> lcd_reset_condition = FALSE;
			pk_output (lcp);
		}
		else
			pk_procerror (RESET, lcp, "unexpected packet", 32);
d713 13
a725 25
	case DATA + SENT_CLEAR: 
		ptype = DELETE_PACKET;
	case RR + SENT_CLEAR: 
	case RNR + SENT_CLEAR: 
	case INTERRUPT + SENT_CLEAR: 
	case INTERRUPT_CONF + SENT_CLEAR: 
	case RESET + SENT_CLEAR: 
	case RESET_CONF + SENT_CLEAR: 
		/* Just ignore p if we have sent a CLEAR already.
		   */
		break;

	/* 
	 *  Restart sets all the permanent virtual circuits to the "Data
	 *  Transfer" stae and  all the switched virtual circuits to the
	 *  "Ready" state.
	 */
	case RESTART + READY: 
		switch (pkp -> pk_state) {
		case DTE_SENT_RESTART: 
			/* 
			 * Restart collision.
			 * If case the restart cause is "DTE originated" we
			 * have a DTE-DTE situation and are trying to resolve
			 * who is going to play DTE/DCE [ISO 8208:4.2-4.5]
d728 7
a734 7
				pk_restart (pkp, X25_RESTART_DTE_ORIGINATED);
				pk_message (0, pkp -> pk_xcp,
					    "RESTART collision");
				if ((pkp -> pk_restartcolls++) > MAXRESTARTCOLLISIONS) {
					pk_message (0, pkp -> pk_xcp,
						    "excessive RESTART collisions");
					pkp -> pk_restartcolls = 0;
d738 19
a756 19
			pkp -> pk_state = DTE_READY;
			pkp -> pk_dxerole |= DTE_PLAYDTE;
			pkp -> pk_dxerole &= ~DTE_PLAYDCE;
			pk_message (0, pkp -> pk_xcp,
				"Packet level operational");
			pk_message (0, pkp -> pk_xcp, 
				    "Assuming DTE role");
			if (pkp -> pk_dxerole & DTE_CONNECTPENDING)
				pk_callcomplete (pkp);
			break;

		default: 
			pk_restart (pkp, -1);
			pk_restartcause (pkp, xp);
			pkp -> pk_chan[0] -> lcd_template = pk_template (0,
				X25_RESTART_CONFIRM);
			pk_output (pkp -> pk_chan[0]);
			pkp -> pk_state = DTE_READY;
			pkp -> pk_dxerole |= RESTART_DTE_ORIGINATED(xp) ? DTE_PLAYDCE :
d758 4
a761 4
			if (pkp -> pk_dxerole & DTE_PLAYDTE) {
				pkp -> pk_dxerole &= ~DTE_PLAYDCE;
				pk_message (0, pkp -> pk_xcp, 
					    "Assuming DTE role");
d763 3
a765 3
				pkp -> pk_dxerole &= ~DTE_PLAYDTE;
				pk_message (0, pkp -> pk_xcp, 
					 "Assuming DCE role");
d767 2
a768 2
			if (pkp -> pk_dxerole & DTE_CONNECTPENDING)
				pk_callcomplete (pkp);
d772 16
a787 16
	/* 
	 *  Restart confirmation received. All logical channels are set
	 *  to READY. 
	 */
	case RESTART_CONF + READY: 
		switch (pkp -> pk_state) {
		case DTE_SENT_RESTART: 
			pkp -> pk_state = DTE_READY;
			pkp -> pk_dxerole |= DTE_PLAYDTE;
			pkp -> pk_dxerole &= ~DTE_PLAYDCE;
			pk_message (0, pkp -> pk_xcp,
				    "Packet level operational");
			pk_message (0, pkp -> pk_xcp,
				    "Assuming DTE role");
			if (pkp -> pk_dxerole & DTE_CONNECTPENDING)
				pk_callcomplete (pkp);
d790 1
a790 1
		default: 
d792 3
a794 3
			pk_restart (pkp, X25_RESTART_LOCAL_PROCEDURE_ERROR);
			pkp -> pk_state = DTE_SENT_RESTART;
			pkp -> pk_dxerole &= ~(DTE_PLAYDTE | DTE_PLAYDCE);
d798 1
a798 1
	default: 
d800 4
a803 4
			pk_procerror (CLEAR, lcp, "unknown packet error", 33);
			pk_message (lcn, pkp -> pk_xcp,
				"\"%s\" unexpected in \"%s\" state",
				pk_name[ptype/MAXSTATES], pk_state[lcdstate]);
d805 2
a806 2
			pk_message (lcn, pkp -> pk_xcp,
				"packet arrived on unassigned lcn");
d809 2
a810 2
	if (so == 0 && lcp && lcp -> lcd_upper && lcdstate == DATA_TRANSFER) {
		if (ptype != DATA && ptype != INTERRUPT)
d812 3
a814 3
		lcp -> lcd_upper (lcp, m);
	} else if (ptype != DATA && ptype != INTERRUPT)
		m_freem (m);
d817 4
a820 4
static
prune_dnic (from, to, dnicname, xcp)
char *from, *to, *dnicname;
register struct x25config *xcp;
d822 2
a823 2
	register char *cp1 = from, *cp2 = from;
	if (xcp -> xc_prepnd0 && *cp1 == '0') {
d827 2
a828 2
	if (xcp -> xc_nodnic) {
		for (cp1 = dnicname; *cp2 = *cp1++;)
d833 1
a833 1
	for (cp1 = dnicname; *cp2 = *cp1++;)
d836 5
a840 4
/* static */
pk_simple_bsd (from, to, lower, len)
register octet *from, *to;
register len, lower;
d842 1
a842 1
	register int c;
d846 1
a846 1
			*from++;
d849 4
a852 1
		c &= 0x0f; c |= 0x30; *to++ = c; lower++;
d857 6
a862 5
/*static octet * */
pk_from_bcd (a, iscalling, sa, xcp)
register struct x25_calladdr *a;
register struct sockaddr_x25 *sa;
register struct x25config *xcp;
d864 7
a870 7
	octet buf[MAXADDRLN+1];
	octet *cp;
	unsigned count;

	bzero ((caddr_t) sa, sizeof (*sa));
	sa -> x25_len = sizeof (*sa);
	sa -> x25_family = AF_CCITT;
d872 3
a874 3
		cp = a -> address_field + (X25GBITS(a -> addrlens, called_addrlen) / 2);
		count = X25GBITS(a -> addrlens, calling_addrlen);
		pk_simple_bsd (cp, buf, X25GBITS(a -> addrlens, called_addrlen), count);
d876 2
a877 2
		count = X25GBITS(a -> addrlens, called_addrlen);
		pk_simple_bsd (a -> address_field, buf, 0, count);
d879 2
a880 2
	if (xcp -> xc_addr.x25_net && (xcp -> xc_nodnic || xcp -> xc_prepnd0)) {
		octet dnicname[sizeof (long) * NBBY/3 + 2];
d882 2
a883 2
		sprintf ((char *) dnicname, "%d", xcp -> xc_addr.x25_net);
		prune_dnic ((char *) buf, sa -> x25_addr, dnicname, xcp);
d885 1
a885 1
		bcopy ((caddr_t) buf, (caddr_t) sa -> x25_addr, count + 1);
d888 5
a892 5
static
save_extra (m0, fp, so)
struct mbuf *m0;
octet *fp;
struct socket *so;
d895 8
a902 4
	struct cmsghdr cmsghdr;
	if (m = m_copy (m, 0, (int)M_COPYALL)) {
		int off = fp - mtod (m0, octet *);
		int len = m -> m_pkthdr.len - off + sizeof (cmsghdr);
d906 2
a907 2
		m_adj (m, off);
		M_PREPEND (m, sizeof (cmsghdr), M_DONTWAIT);
d910 1
a910 1
		bcopy ((caddr_t)&cmsghdr, mtod (m, caddr_t), sizeof (cmsghdr));
d912 1
a912 1
		sbappendrecord (&so -> so_rcv, m);
d916 4
a919 4
/* 
 * This routine handles incoming call packets. It matches the protocol
 * field on the Call User Data field (usually the first four bytes) with 
 * sockets awaiting connections.
d922 4
a925 3
pk_incoming_call (pkp, m0)
struct mbuf *m0;
struct pkcb *pkp;
d931 16
a946 14
	struct	x25_packet *xp = mtod (m0, struct x25_packet *);
	struct	mbuf *m;
	struct	x25config *xcp = pkp -> pk_xcp;
	int len = m0 -> m_pkthdr.len;
	unsigned udlen;
	char *errstr = "server unavailable";
	octet *u, *facp;
	int lcn = LCN(xp);

	/* First, copy the data from the incoming call packet to a X25 address
	   descriptor. It is to be regretted that you have
	   to parse the facilities into a sockaddr to determine
	   if reverse charging is being requested */
	if ((m = m_get (M_DONTWAIT, MT_SONAME)) == 0)
d948 4
a951 4
	sa = mtod (m, struct sockaddr_x25 *);
	a = (struct x25_calladdr *) &xp -> packet_data;
	facp = u = (octet *) (a -> address_field +
		((X25GBITS(a -> addrlens, called_addrlen) + X25GBITS(a -> addrlens, calling_addrlen) + 1) / 2));
d953 3
a955 1
	udlen = min (16, ((octet *) xp) + len - u);
d958 5
a962 4
	pk_from_bcd (a, 1, sa, pkp -> pk_xcp); /* get calling address */
	pk_parse_facilities (facp, sa);
	bcopy ((caddr_t) u, sa -> x25_udata, udlen);
	sa -> x25_udlen = udlen;
d968 1
a968 1
	 * It does provide a way of multiplexing services at the user level. 
d971 2
a972 2
	for (l = pk_listenhead; l; l = l -> lcd_listen) {
		struct sockaddr_x25 *sxp = l -> lcd_ceaddr;
d974 1
a974 1
		if (bcmp (sxp -> x25_udata, u, sxp -> x25_udlen))
d976 2
a977 2
		if (sxp -> x25_net &&
		    sxp -> x25_net != xcp -> xc_addr.x25_net)
d983 1
a983 1
		if (X25GBITS(xp -> bits, d_bit) && !(sxp -> x25_opts.op_flags & X25_DBIT)) {
d991 2
a992 2
		if ((sxp -> x25_opts.op_flags & (X25_OLDSOCKADDR|X25_REVERSE_CHARGE)) == 0 &&
			sa -> x25_opts.op_flags & X25_REVERSE_CHARGE) {
d996 6
a1001 5
		if (l -> lcd_so) {
			if (so = sonewconn (l -> lcd_so, SS_ISCONNECTED))
				    lcp = (struct pklcd *) so -> so_pcb;
		} else 
			lcp = pk_attach ((struct socket *) 0);
d1010 15
a1024 15
		lcp -> lcd_upper = l -> lcd_upper;
		lcp -> lcd_upnext = l -> lcd_upnext;
		lcp -> lcd_lcn = lcn;
		lcp -> lcd_state = RECEIVED_CALL;
		sa -> x25_opts.op_flags |= (sxp -> x25_opts.op_flags &
			~X25_REVERSE_CHARGE) | l -> lcd_flags;
		pk_assoc (pkp, lcp, sa);
		lcp -> lcd_faddr = *sa;
		lcp -> lcd_laddr.x25_udlen = sxp -> x25_udlen;
		lcp -> lcd_craddr = &lcp -> lcd_faddr;
		lcp -> lcd_template = pk_template (lcp -> lcd_lcn, X25_CALL_ACCEPTED);
		if (lcp -> lcd_flags & X25_DBIT) {
			if (X25GBITS(xp -> bits, d_bit))
				X25SBITS(mtod (lcp -> lcd_template,
					struct x25_packet *) -> bits, d_bit, 1);
d1026 1
a1026 1
				lcp -> lcd_flags &= ~X25_DBIT;
d1029 6
a1034 6
			pk_output (lcp);
			soisconnected (so);
			if (so -> so_options & SO_OOBINLINE)
				save_extra (m0, facp, so);
		} else if (lcp -> lcd_upper) {
			(*lcp -> lcd_upper) (lcp, m0);
d1036 1
a1036 1
		(void) m_free (m);
d1045 7
a1051 7
#ifdef WATERLOO		/* be explicit */
	if (l == 0 && bcmp (sa -> x25_udata, "ean", 3) == 0)
		pk_message (lcn, pkp -> pk_xcp, "host=%s ean%c: %s",
			sa -> x25_addr, sa -> x25_udata[3] & 0xff, errstr);
	else if (l == 0 && bcmp (sa -> x25_udata, "\1\0\0\0", 4) == 0)
		pk_message (lcn, pkp -> pk_xcp, "host=%s x29d: %s",
			sa -> x25_addr, errstr);
d1054 6
a1059 6
	pk_message (lcn, pkp -> pk_xcp, "host=%s pid=%x %x %x %x: %s",
		sa -> x25_addr, sa -> x25_udata[0] & 0xff,
		sa -> x25_udata[1] & 0xff, sa -> x25_udata[2] & 0xff,
		sa -> x25_udata[3] & 0xff, errstr);
	if ((lcp = pk_attach ((struct socket *)0)) == 0) {
		(void) m_free (m);
d1062 5
a1066 5
	lcp -> lcd_lcn = lcn;
	lcp -> lcd_state = RECEIVED_CALL;
	pk_assoc (pkp, lcp, sa);
	(void) m_free (m);
	pk_clear (lcp, 0, 1);
d1069 4
a1072 3
pk_call_accepted (lcp, m)
struct pklcd *lcp;
struct mbuf *m;
d1076 2
a1077 2
	struct x25_packet *xp = mtod (m, struct x25_packet *);
	int len = m -> m_len;
d1079 5
a1083 5
	lcp -> lcd_state = DATA_TRANSFER;
	if (lcp -> lcd_so)
		soisconnected (lcp -> lcd_so);
	if ((lcp -> lcd_flags & X25_DBIT) && (X25GBITS(xp -> bits, d_bit) == 0))
		lcp -> lcd_flags &= ~X25_DBIT;
d1085 3
a1087 3
		ap = (struct x25_calladdr *) &xp -> packet_data;
		fcp = (octet *) ap -> address_field + (X25GBITS(ap -> addrlens, calling_addrlen) +
			X25GBITS(ap -> addrlens, called_addrlen) + 1) / 2;
d1089 1
a1089 1
			pk_parse_facilities (fcp, lcp -> lcd_ceaddr);
d1091 3
a1093 3
	pk_assoc (lcp -> lcd_pkp, lcp, lcp -> lcd_ceaddr);
	if (lcp -> lcd_so == 0 && lcp -> lcd_upper)
		lcp -> lcd_upper (lcp, m);
d1096 4
a1099 3
pk_parse_facilities (fcp, sa)
register octet *fcp;
register struct sockaddr_x25 *sa;
d1113 1
a1113 1
			sa -> x25_opts.op_wsize = fcp[1];
d1118 1
a1118 1
			sa -> x25_opts.op_psize = fcp[1];
d1123 1
a1123 1
			sa -> x25_opts.op_speed = fcp[1];
d1129 1
a1129 1
				sa -> x25_opts.op_flags |= X25_REVERSE_CHARGE;
d1134 2
a1135 2
			if (fcp[1] & 02 && sa -> x25_opts.op_psize == 0)
				sa -> x25_opts.op_psize = X25_PS128;
d1140 4
a1143 1
/*printf("unknown facility %x, class=%d\n", *fcp, (*fcp & 0xc0) >> 6);*/
d1145 1
a1145 1
			case 0:			/* class A */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
