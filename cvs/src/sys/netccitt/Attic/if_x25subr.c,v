head	1.18;
access;
symbols
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.13
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2005.06.16.17.37.54;	author henning;	state dead;
branches;
next	1.17;

1.17
date	2004.07.18.15.44.36;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.08.19.18.12;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.08.18.26.37;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.08.17.07.32;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.27.03.49.53;	author angelos;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.06.25.01.50.17;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.15.03.38.35;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.27.12.19.04;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.19.06.37.37;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	96.05.22.12.02.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.07.36.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.08;	author deraadt;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.40.05;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.07.04.10.54.24;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@remove remaining netccitt parts, full ports build test by pval, thanks!
@
text
@/*	$OpenBSD: if_x25subr.c,v 1.17 2004/07/18 15:44:36 henning Exp $	*/
/*	$NetBSD: if_x25subr.c,v 1.13 1996/05/09 22:29:25 scottr Exp $	*/

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_x25subr.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>

#include <machine/cpu.h>	/* XXX for setsoftnet().  This must die. */

#include <net/if.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>

#include <netccitt/x25.h>
#include <netccitt/x25err.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_var.h>
#else
#ifdef _KERNEL
#error options CCITT assumes options INET
#endif
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

LIST_HEAD(, llinfo_x25) llinfo_x25;
#ifndef _offsetof
#define _offsetof(t, m) ((int)((caddr_t)&((t *)0)->m))
#endif
struct sockaddr *x25_dgram_sockmask;
struct sockaddr_x25 x25_dgmask = {
	_offsetof(struct sockaddr_x25, x25_udata[1]),	/* _len */
	0,		/* _family */
	0,		/* _net */
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},	/* _addr */
	{0},		/* opts */
	-1,		/* _udlen */
	{-1}		/* _udata */
};

struct if_x25stats {
	int             ifx_wrongplen;
	int             ifx_nophdr;
} if_x25stats;
int x25_autoconnect = 0;

#define senderr(x) {error = x; goto bad;}

static struct llinfo_x25 *x25_lxalloc(struct rtentry *);

/*
 * Ancillary routines
 */
static struct llinfo_x25 *
x25_lxalloc(rt)
	struct rtentry *rt;
{
	struct llinfo_x25 *lx;
	struct sockaddr *dst = rt_key(rt);
	struct ifaddr *ifa;

	MALLOC(lx, struct llinfo_x25 *, sizeof(*lx), M_PCB, M_NOWAIT);
	if (lx == 0)
		return lx;
	Bzero(lx, sizeof(*lx));
	lx->lx_rt = rt;
	lx->lx_family = dst->sa_family;
	rt->rt_refcnt++;
	if (rt->rt_llinfo) {
		LIST_INSERT_AFTER(
			  (struct llinfo_x25 *) rt->rt_llinfo, lx, lx_list);
	} else {
		rt->rt_llinfo = (caddr_t) lx;
		LIST_INSERT_HEAD(&llinfo_x25, lx, lx_list);
	}
	for (ifa = rt->rt_ifp->if_addrlist.tqh_first; ifa != 0;
	     ifa = ifa->ifa_list.tqe_next) {
		if (ifa->ifa_addr->sa_family == AF_CCITT)
			lx->lx_ia = (struct x25_ifaddr *) ifa;
	}
	return lx;
}

void
x25_lxfree(lx)
	struct llinfo_x25 *lx;
{
	struct rtentry *rt = lx->lx_rt;
	struct pklcd *lcp = lx->lx_lcd;

	if (lcp) {
		lcp->lcd_upper = 0;
		pk_disconnect(lcp);
	}
	if ((rt->rt_llinfo == (caddr_t) lx) && (lx->lx_list.le_next->lx_rt == rt))
		rt->rt_llinfo = (caddr_t) lx->lx_list.le_next;
	else
		rt->rt_llinfo = 0;
	RTFREE(rt);
	LIST_REMOVE(lx, lx_list);
	FREE(lx, M_PCB);
}
/*
 * Process a x25 packet as datagram;
 */
int
x25_ifinput(m, v)
	struct mbuf *m;
	void *v;
{
	struct pklcd   *lcp = v;
	struct llinfo_x25 *lx = (struct llinfo_x25 *) lcp->lcd_upnext;
	struct ifnet *ifp;
	struct ifqueue *inq;
	int             s, isr;

	if (m == 0 || lcp->lcd_state != DATA_TRANSFER)
		return x25_connect_callback(NULL, lcp);

	pk_flowcontrol(lcp, 0, 1);	/* Generate RR */
	ifp = m->m_pkthdr.rcvif;
	switch (m->m_type) {
	default:
		if (m)
			m_freem(m);
		return 0;

	case MT_DATA:
		 /* FALLTHROUGH */ ;
	}
	switch (lx->lx_family) {
#ifdef INET
	case AF_INET:
		isr = NETISR_IP;
		inq = &ipintrq;
		break;

#endif
#ifdef NS
	case AF_NS:
		isr = NETISR_NS;
		inq = &nsintrq;
		break;

#endif
	default:
		m_freem(m);
		ifp->if_noproto++;
		return 0;
	}
	s = splimp();
	schednetisr(isr);
	if (IF_QFULL(inq)) {
		IF_DROP(inq);
		m_freem(m);
	} else {
		IF_ENQUEUE(inq, m);
		ifp->if_ibytes += m->m_pkthdr.len;
	}
	splx(s);
	return 0;
}

int
x25_connect_callback(m, v)
	struct mbuf *m;
	void *v;
{
	struct pklcd *lcp = v;
	struct llinfo_x25 *lx = (struct llinfo_x25 *) lcp->lcd_upnext;
	int             do_clear = 1;
	if (m == 0)
		goto refused;
	if (m->m_type != MT_CONTROL) {
		printf("x25_connect_callback: should panic\n");
		goto refused;
	}
	switch (pk_decode(mtod(m, struct x25_packet *))) {
	case PK_CALL_ACCEPTED:
		lcp->lcd_upper = x25_ifinput;
		if (lcp->lcd_sb.sb_mb)
			lcp->lcd_send(lcp);	/* XXX start queued packets */
		return 0;
	default:
		do_clear = 0;
refused:
		lcp->lcd_upper = 0;
		lx->lx_lcd = 0;
		if (do_clear)
			pk_disconnect(lcp);
		return 0;
	}
}


#define SA(p) ((struct sockaddr *)(p))
#define RT(p) ((struct rtentry *)(p))

int
x25_dgram_incoming(m0, v)
	struct mbuf    *m0;
	void *v;
{
	struct pklcd *lcp = v;
	struct rtentry *rt, *nrt;
	struct mbuf *m = m0->m_next;	/* m0 has calling
						 * sockaddr_x25 */
	rt = rtalloc1(SA(&lcp->lcd_faddr), 0);
	if (rt == 0) {
refuse:		lcp->lcd_upper = 0;
		pk_close(lcp);
		return 0;
	}
	rt->rt_refcnt--;
	if ((nrt = RT(rt->rt_llinfo)) == 0 || rt_mask(rt) != x25_dgram_sockmask)
		goto refuse;
	if ((nrt->rt_flags & RTF_UP) == 0) {
		rt->rt_llinfo = (caddr_t) rtalloc1(rt->rt_gateway, 0);
		rtfree(nrt);
		if ((nrt = RT(rt->rt_llinfo)) == 0)
			goto refuse;
		nrt->rt_refcnt--;
	}
	if (nrt->rt_ifa == 0 || nrt->rt_ifa->ifa_rtrequest != x25_rtrequest)
		goto refuse;
	lcp->lcd_send(lcp);	/* confirm call */
	x25_rtattach(lcp, nrt);
	m_freem(m);
	return 0;
}

/*
 * X.25 output routine.
 */
int
x25_ifoutput(ifp, m0, dst, rt)
	struct ifnet   *ifp;
	struct mbuf    *m0;
	struct sockaddr *dst;
	struct rtentry *rt;
{
	struct mbuf *m = m0;
	struct llinfo_x25 *lx;
	struct pklcd   *lcp;
	int             error = 0;

	int             plen;
	for (plen = 0; m; m = m->m_next)
		plen += m->m_len;
	m = m0;

	if ((ifp->if_flags & IFF_UP) == 0)
		senderr(ENETDOWN);
	while (rt == 0 || (rt->rt_flags & RTF_GATEWAY)) {
		if (rt) {
			if (rt->rt_llinfo) {
				rt = (struct rtentry *) rt->rt_llinfo;
				continue;
			}
			dst = rt->rt_gateway;
		}
		if ((rt = rtalloc1(dst, 1)) == 0)
			senderr(EHOSTUNREACH);
		rt->rt_refcnt--;
	}
	/*
	 * Sanity checks.
	 */
	if ((rt->rt_ifp != ifp) ||
	    (rt->rt_flags & (RTF_CLONING | RTF_GATEWAY)) ||
	    ((lx = (struct llinfo_x25 *) rt->rt_llinfo) == 0)) {
		senderr(ENETUNREACH);
	}
	if ((m->m_flags & M_PKTHDR) == 0) {
		if_x25stats.ifx_nophdr++;
		m = m_gethdr(M_NOWAIT, MT_HEADER);
		if (m == 0)
			senderr(ENOBUFS);
		M_MOVE_HDR(m, m0);
		m->m_pkthdr.len = plen;
		m->m_next = m0;
	}
	if (plen != m->m_pkthdr.len) {
		if_x25stats.ifx_wrongplen++;
		m->m_pkthdr.len = plen;
	}
next_circuit:
	lcp = lx->lx_lcd;
	if (lcp == 0) {
		lx->lx_lcd = lcp = pk_attach((struct socket *) 0);
		if (lcp == 0)
			senderr(ENOBUFS);
		lcp->lcd_upper = x25_connect_callback;
		lcp->lcd_upnext = (caddr_t) lx;
		lcp->lcd_packetsize = lx->lx_ia->ia_xc.xc_psize;
		lcp->lcd_flags = X25_MBS_HOLD;
	}
	switch (lcp->lcd_state) {
	case READY:
		if (dst->sa_family == AF_INET &&
		    ifp->if_type == IFT_X25DDN &&
		    rt->rt_gateway->sa_family != AF_CCITT)
			x25_ddnip_to_ccitt(dst, rt);
		if (rt->rt_gateway->sa_family != AF_CCITT) {
			if ((rt->rt_flags & RTF_XRESOLVE) == 0)
				senderr(EHOSTUNREACH);
		} else if (x25_autoconnect)
			error = pk_connect(lcp,
				    (struct sockaddr_x25 *) rt->rt_gateway);
		if (error)
			senderr(error);
		/* FALLTHROUGH */
	case SENT_CALL:
	case DATA_TRANSFER:
		if (sbspace(&lcp->lcd_sb) < 0) {
			lx = lx->lx_list.le_next;
			if (lx->lx_rt != rt)
				senderr(ENOSPC);
			goto next_circuit;
		}
		if (lx->lx_ia)
			lcp->lcd_dg_timer =
				lx->lx_ia->ia_xc.xc_dg_idletimo;
		pk_send(m, lcp);
		break;
	default:
		/*
		 * We count on the timer routine to close idle
		 * connections, if there are not enough circuits to go
		 * around.
		 *
		 * So throw away data for now.
		 * After we get it all working, we'll rewrite to handle
		 * actively closing connections (other than by timers),
		 * when circuits get tight.
		 *
		 * In the DDN case, the imp itself closes connections
		 * under heavy load.
		 */
		error = ENOBUFS;
bad:
		if (m)
			m_freem(m);
	}
	return (error);
}

/*
 * Simpleminded timer routine.
 */
void
x25_iftimeout(ifp)
	struct ifnet   *ifp;
{
	struct pkcb *pkcb = 0;
	struct pklcd **lcpp, *lcp;
	int             s = splimp();

	FOR_ALL_PKCBS(pkcb)
		if (pkcb->pk_ia->ia_ifp == ifp)
		for (lcpp = pkcb->pk_chan + pkcb->pk_maxlcn;
		     --lcpp > pkcb->pk_chan;)
			if ((lcp = *lcpp) &&
			    lcp->lcd_state == DATA_TRANSFER &&
			    (lcp->lcd_flags & X25_DG_CIRCUIT) &&
			  (lcp->lcd_dg_timer && --lcp->lcd_dg_timer == 0)) {
				(*lcp->lcd_upper)(NULL, lcp);
			}
	splx(s);
}
/*
 * This routine gets called when validating additions of new routes
 * or deletions of old ones.
 */
void
x25_rtrequest(cmd, rt, info)
	int cmd;
	struct rtentry *rt;
	struct rt_addrinfo *info;
{
	struct llinfo_x25 *lx = (struct llinfo_x25 *) rt->rt_llinfo;
	struct pklcd *lcp;

	/*
	 * would put this pk_init, except routing table doesn't exist yet.
	 */
	if (x25_dgram_sockmask == 0) {
		x25_dgram_sockmask =
			SA(rn_addmask((caddr_t) & x25_dgmask, 0, 4)->rn_key);
	}
	if (rt->rt_flags & RTF_GATEWAY) {
		if (rt->rt_llinfo)
			RTFREE((struct rtentry *) rt->rt_llinfo);
		rt->rt_llinfo = (cmd == RTM_ADD) ?
			(caddr_t) rtalloc1(rt->rt_gateway, 1) : 0;
		return;
	}
	if ((rt->rt_flags & RTF_HOST) == 0)
		return;
	if (cmd == RTM_DELETE) {
		while (rt->rt_llinfo)
			x25_lxfree((struct llinfo_x25 *) rt->rt_llinfo);
		x25_rtinvert(RTM_DELETE, rt->rt_gateway, rt);
		return;
	}
	if (lx == 0 && (lx = x25_lxalloc(rt)) == 0)
		return;
	if ((lcp = lx->lx_lcd) && lcp->lcd_state != READY) {
		/*
		 * This can only happen on a RTM_CHANGE operation
		 * though cmd will be RTM_ADD.
		 */
		if (lcp->lcd_ceaddr &&
		    Bcmp(rt->rt_gateway, lcp->lcd_ceaddr,
			 lcp->lcd_ceaddr->x25_len) != 0) {
			x25_rtinvert(RTM_DELETE,
				     (struct sockaddr *) lcp->lcd_ceaddr, rt);
			lcp->lcd_upper = 0;
			pk_disconnect(lcp);
		}
		lcp = 0;
	}
	x25_rtinvert(RTM_ADD, rt->rt_gateway, rt);
}

int x25_dont_rtinvert = 0;

void
x25_rtinvert(cmd, sa, rt)
	int cmd;
	struct sockaddr *sa;
	struct rtentry *rt;
{
	struct rtentry *rt2 = 0;
	/*
	 * rt_gateway contains PID indicating which proto
	 * family on the other end, so will be different
	 * from general host route via X.25.
	 */
	if (rt->rt_ifp->if_type == IFT_X25DDN || x25_dont_rtinvert)
		return;
	if (sa->sa_family != AF_CCITT)
		return;
	if (cmd != RTM_DELETE) {
		rtrequest(RTM_ADD, sa, rt_key(rt), x25_dgram_sockmask,
			  RTF_PROTO2, &rt2);
		if (rt2) {
			rt2->rt_llinfo = (caddr_t) rt;
			rt->rt_refcnt++;
		}
		return;
	}
	rt2 = rt;
	if ((rt = rtalloc1(sa, 0)) == 0 ||
	    (rt->rt_flags & RTF_PROTO2) == 0 ||
	    rt->rt_llinfo != (caddr_t) rt2) {
		printf("x25_rtchange: inverse route screwup\n");
		return;
	} else
		rt2->rt_refcnt--;
	rtrequest(RTM_DELETE, sa, rt_key(rt2), x25_dgram_sockmask,
		  0, (struct rtentry **) 0);
}

static struct sockaddr_x25 blank_x25 = {sizeof blank_x25, AF_CCITT};
/*
 * IP to X25 address routine copyright ACC, used by permission.
 */
union imp_addr {
	struct in_addr  ip;
	struct imp {
		u_char          s_net;
		u_char          s_host;
		u_char          s_lh;
		u_char          s_impno;
	} imp;
};

/*
 * The following is totally bogus and here only to preserve
 * the IP to X.25 translation.
 */
void
x25_ddnip_to_ccitt(src, rt)
	struct sockaddr *src;
	struct rtentry *rt;
{
	struct sockaddr_x25 *dst = (struct sockaddr_x25 *) rt->rt_gateway;
	union imp_addr  imp_addr;
	int             imp_no, imp_port, temp;
	char           *x25addr = dst->x25_addr;


	imp_addr.ip = ((struct sockaddr_in *) src)->sin_addr;
	*dst = blank_x25;
	if ((imp_addr.imp.s_net & 0x80) == 0x00) {	/* class A */
		imp_no = imp_addr.imp.s_impno;
		imp_port = imp_addr.imp.s_host;
	} else if ((imp_addr.imp.s_net & 0xc0) == 0x80) {	/* class B */
		imp_no = imp_addr.imp.s_impno;
		imp_port = imp_addr.imp.s_lh;
	} else {		/* class C */
		imp_no = imp_addr.imp.s_impno / 32;
		imp_port = imp_addr.imp.s_impno % 32;
	}

	x25addr[0] = 12;	/* length */
	/* DNIC is cleared by struct copy above */

	if (imp_port < 64) {	/* Physical:  0000 0 IIIHH00 [SS] *//* s_impno
				 * -> III, s_host -> HH */
		x25addr[5] = 0;	/* set flag bit */
		x25addr[6] = imp_no / 100;
		x25addr[7] = (imp_no % 100) / 10;
		x25addr[8] = imp_no % 10;
		x25addr[9] = imp_port / 10;
		x25addr[10] = imp_port % 10;
	} else {		/* Logical:   0000 1 RRRRR00 [SS]	 *//* s
				 * _host * 256 + s_impno -> RRRRR */
		temp = (imp_port << 8) + imp_no;
		x25addr[5] = 1;
		x25addr[6] = temp / 10000;
		x25addr[7] = (temp % 10000) / 1000;
		x25addr[8] = (temp % 1000) / 100;
		x25addr[9] = (temp % 100) / 10;
		x25addr[10] = temp % 10;
	}
}

/*
 * This routine is a sketch and is not to be believed!!!!!
 *
 * This is a utility routine to be called by x25 devices when a
 * call request is honored with the intent of starting datagram forwarding.
 */
void
x25_dg_rtinit(dst, ia, af)
	struct sockaddr_x25 *dst;
	struct x25_ifaddr *ia;
	int af;
{
	struct sockaddr *sa = 0;
	struct rtentry *rt;
	struct in_addr  my_addr;
	static struct sockaddr_in sin = {sizeof(sin), AF_INET};

	if (ia->ia_ifp->if_type == IFT_X25DDN && af == AF_INET) {
		/*
		 * Inverse X25 to IP mapping copyright and courtesy ACC.
		 */
		int             imp_no, imp_port, temp;
		union imp_addr  imp_addr;
		{
			/*
			 * First determine our IP addr for network
			 */
			struct in_ifaddr *ina;

			for (ina = in_ifaddr.tqh_first; ina != 0;
			     ina = ina->ia_list.tqe_next)
				if (ina->ia_ifp == ia->ia_ifp) {
					my_addr = ina->ia_addr.sin_addr;
					break;
				}
		}
		{

			char  *x25addr = dst->x25_addr;

			switch (x25addr[5] & 0x0f) {
			case 0:/* Physical:  0000 0 IIIHH00 [SS]	 */
				imp_no =
					((int) (x25addr[6] & 0x0f) * 100) +
					((int) (x25addr[7] & 0x0f) * 10) +
					((int) (x25addr[8] & 0x0f));


				imp_port =
					((int) (x25addr[9] & 0x0f) * 10) +
					((int) (x25addr[10] & 0x0f));
				break;
			case 1:/* Logical:   0000 1 RRRRR00 [SS]	 */
				temp = ((int) (x25addr[6] & 0x0f) * 10000)
					+ ((int) (x25addr[7] & 0x0f) * 1000)
					+ ((int) (x25addr[8] & 0x0f) * 100)
					+ ((int) (x25addr[9] & 0x0f) * 10)
					+ ((int) (x25addr[10] & 0x0f));

				imp_port = temp >> 8;
				imp_no = temp & 0xff;
				break;
			default:
				return;
			}
			imp_addr.ip = my_addr;
			if ((imp_addr.imp.s_net & 0x80) == 0x00) {
				/* class A */
				imp_addr.imp.s_host = imp_port;
				imp_addr.imp.s_impno = imp_no;
				imp_addr.imp.s_lh = 0;
			} else if ((imp_addr.imp.s_net & 0xc0) == 0x80) {
				/* class B */
				imp_addr.imp.s_lh = imp_port;
				imp_addr.imp.s_impno = imp_no;
			} else {
				/* class C */
				imp_addr.imp.s_impno = (imp_no << 5) + imp_port;
			}
		}
		sin.sin_addr = imp_addr.ip;
		sa = (struct sockaddr *) & sin;
	} else {
		/*
		 * This uses the X25 routing table to do inverse
		 * lookup of x25 address to sockaddr.
		 */
		if ((rt = rtalloc1(SA(dst), 0)) != NULL) {
			sa = rt->rt_gateway;
			rt->rt_refcnt--;
		}
	}
	/*
	 * Call to rtalloc1 will create rtentry for reverse path to callee by
	 * virtue of cloning magic and will allocate space for local control
	 * block.
	 */
	if (sa && (rt = rtalloc1(sa, 1)))
		rt->rt_refcnt--;
}


int x25_startproto = 1;

void
pk_init()
{
	/*
	 * warning, sizeof (struct sockaddr_x25) > 32,
	 * but contains no data of interest beyond 32
	 */
	if (x25_startproto) {
		pk_protolisten(0xcc, 1, x25_dgram_incoming);
		pk_protolisten(0x81, 1, x25_dgram_incoming);
	}
}

struct x25_dgproto {
	u_char          spi;
	u_char          spilen;
	int             (*f)(struct mbuf *, void *);
} x25_dgprototab[] = {
	{ 0xcc, 1, x25_dgram_incoming },
	{ 0xcd, 1, x25_dgram_incoming },
	{ 0x81, 1, x25_dgram_incoming },
};

int
pk_user_protolisten(info)
	u_char *info;
{
	struct x25_dgproto *dp = x25_dgprototab
	+ ((sizeof x25_dgprototab) / (sizeof *dp));
	struct pklcd *lcp;

	while (dp > x25_dgprototab)
		if ((--dp)->spi == info[0])
			goto gotspi;
	return ESRCH;

gotspi:if (info[1])
		return pk_protolisten(dp->spi, dp->spilen, dp->f);
	for (lcp = pk_listenhead; lcp; lcp = lcp->lcd_listen)
		if (lcp->lcd_laddr.x25_udlen == dp->spilen &&
		Bcmp(&dp->spi, lcp->lcd_laddr.x25_udata, dp->spilen) == 0) {
			pk_disconnect(lcp);
			return 0;
		}
	return ESRCH;
}

/*
 * This routine transfers an X.25 circuit to or from a routing entry.
 * If the supplied circuit is * in DATA_TRANSFER state, it is added to the
 * routing entry.  If freshly allocated, it glues back the vc from
 * the rtentry to the socket.
 */
int
pk_rtattach(so, m0)
	struct socket *so;
	struct mbuf    *m0;
{
	struct pklcd *lcp = (struct pklcd *) so->so_pcb;
	struct mbuf *m = m0;
	struct sockaddr *dst = mtod(m, struct sockaddr *);
	struct rtentry *rt = rtalloc1(dst, 0);
	struct llinfo_x25 *lx;
	caddr_t         cp;
#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define transfer_sockbuf(s, f, l) \
	while ((m = (s)->sb_mb) != NULL) \
		{ \
			(s)->sb_mb = m->m_nextpkt; \
			SB_EMPTY_FIXUP((s)); \
			m->m_nextpkt = 0; \
			sbfree((s), m); \
			f; \
		}

	if (rt)
		rt->rt_refcnt--;
	cp = (dst->sa_len < m->m_len) ? ROUNDUP(dst->sa_len) + (caddr_t) dst : 0;
	while (rt &&
	       ((cp == 0 && rt_mask(rt) != 0) ||
		(cp != 0 && (rt_mask(rt) == 0 ||
			 Bcmp(cp, rt_mask(rt), rt_mask(rt)->sa_len)) != 0)))
		rt = (struct rtentry *) rt->rt_nodes->rn_dupedkey;
	if (rt == 0 || (rt->rt_flags & RTF_GATEWAY) ||
	    (lx = (struct llinfo_x25 *) rt->rt_llinfo) == 0)
		return ESRCH;
	if (lcp == 0)
		return ENOTCONN;
	switch (lcp->lcd_state) {
	default:
		return ENOTCONN;

	case READY:
		/* Detach VC from rtentry */
		if (lx->lx_lcd == 0)
			return ENOTCONN;
		lcp->lcd_so = 0;
		pk_close(lcp);
		lcp = lx->lx_lcd;
		if (lx->lx_list.le_next->lx_rt == rt)
			x25_lxfree(lx);
		lcp->lcd_so = so;
		lcp->lcd_upper = 0;
		lcp->lcd_upnext = 0;
		transfer_sockbuf(&lcp->lcd_sb, sbappendrecord(&so->so_snd, m),
				 &so->so_snd);
		soisconnected(so);
		return 0;

	case DATA_TRANSFER:
		/* Add VC to rtentry */
		lcp->lcd_so = 0;
		lcp->lcd_sb = so->so_snd;	/* structure copy */
		bzero((caddr_t) & so->so_snd, sizeof(so->so_snd));	/* XXXXXX */
		so->so_pcb = 0;
		x25_rtattach(lcp, rt);
		transfer_sockbuf(&so->so_rcv, x25_ifinput(m, lcp), lcp);
		soisdisconnected(so);
	}
	return 0;
}

int
x25_rtattach(lcp0, rt)
	struct pklcd *lcp0;
	struct rtentry *rt;
{
	struct llinfo_x25 *lx = (struct llinfo_x25 *) rt->rt_llinfo;
	struct pklcd *lcp;
	struct mbuf *m;
	if ((lcp = lx->lx_lcd) != NULL) {	/* adding an additional VC */
		if (lcp->lcd_state == READY) {
			transfer_sockbuf(&lcp->lcd_sb, pk_output(lcp0), lcp0);
			lcp->lcd_upper = 0;
			pk_close(lcp);
		} else {
			lx = x25_lxalloc(rt);
			if (lx == 0)
				return ENOBUFS;
		}
	}
	lx->lx_lcd = lcp = lcp0;
	lcp->lcd_upper = x25_ifinput;
	lcp->lcd_upnext = (caddr_t) lx;
	return 0;
}
@


1.17
log
@kill some more netiso traces - this was in my tree for a bit but I forgot...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.16 2004/06/21 23:50:37 tholo Exp $	*/
@


1.16
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.15 2003/12/10 07:22:42 itojun Exp $	*/
a72 11
#ifdef ISO
#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#ifdef TPCONS
#include <netiso/tp_param.h>
#include <netiso/tp_var.h>
#endif
#endif


a192 6
#ifdef	ISO
	case AF_ISO:
		isr = NETISR_ISO;
		inq = &clnlintrq;
		break;
#endif
a698 3
#if defined(ISO) && defined(TPCONS)
	{ 0x0, 0, tp_incoming },
#endif
@


1.15
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.14 2003/06/02 23:28:13 millert Exp $	*/
a172 1
	extern struct timeval time;
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.13 2002/08/08 19:18:12 provos Exp $	*/
d114 1
a114 1
	register struct rtentry *rt;
d116 3
a118 3
	register struct llinfo_x25 *lx;
	register struct sockaddr *dst = rt_key(rt);
	register struct ifaddr *ifa;
d144 1
a144 1
	register struct llinfo_x25 *lx;
d146 2
a147 2
	register struct rtentry *rt = lx->lx_rt;
	register struct pklcd *lcp = lx->lx_lcd;
d166 1
a166 1
	register struct mbuf *m;
d171 1
a171 1
	register struct ifnet *ifp;
d231 1
a231 1
	register struct mbuf *m;
d234 2
a235 2
	register struct pklcd *lcp = v;
	register struct llinfo_x25 *lx = (struct llinfo_x25 *) lcp->lcd_upnext;
d269 3
a271 3
	register struct pklcd *lcp = v;
	register struct rtentry *rt, *nrt;
	register struct mbuf *m = m0->m_next;	/* m0 has calling
d305 1
a305 1
	register struct rtentry *rt;
d307 2
a308 2
	register struct mbuf *m = m0;
	register struct llinfo_x25 *lx;
d420 2
a421 2
	register struct pkcb *pkcb = 0;
	register struct pklcd **lcpp, *lcp;
d443 1
a443 1
	register struct rtentry *rt;
d446 2
a447 2
	register struct llinfo_x25 *lx = (struct llinfo_x25 *) rt->rt_llinfo;
	register struct pklcd *lcp;
d496 2
a497 2
	register struct sockaddr *sa;
	register struct rtentry *rt;
d551 1
a551 1
	register struct rtentry *rt;
d553 1
a553 1
	register struct sockaddr_x25 *dst = (struct sockaddr_x25 *) rt->rt_gateway;
d604 1
a604 1
	register struct x25_ifaddr *ia;
d622 1
a622 1
			register struct in_ifaddr *ina;
d633 1
a633 1
			register char  *x25addr = dst->x25_addr;
d727 1
a727 1
	register u_char *info;
d729 1
a729 1
	register struct x25_dgproto *dp = x25_dgprototab
d731 1
a731 1
	register struct pklcd *lcp;
d757 1
a757 1
	register struct socket *so;
d760 2
a761 2
	register struct pklcd *lcp = (struct pklcd *) so->so_pcb;
	register struct mbuf *m = m0;
d763 2
a764 2
	register struct rtentry *rt = rtalloc1(dst, 0);
	register struct llinfo_x25 *lx;
d827 1
a827 1
	register struct pklcd *lcp0;
d830 3
a832 3
	register struct llinfo_x25 *lx = (struct llinfo_x25 *) rt->rt_llinfo;
	register struct pklcd *lcp;
	register struct mbuf *m;
@


1.13
log
@redo socketbuf speedup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.11 2002/08/08 17:07:32 provos Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@backout the tree break. ok pb@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.10 2002/03/14 01:27:10 millert Exp $	*/
d774 7
a780 1
		{(s)->sb_mb = m->m_act; m->m_act = 0; sbfree((s), m); f;}
@


1.11
log
@socket buf speedup from thorpej@@netbsd, okay art@@ ericj@@:

Make insertion of data into socket buffers O(C):
* Keep pointers to the first and last mbufs of the last record in the
  socket buffer.
* Use the sb_lastrecord pointer in the sbappend*() family of functions
  to avoid traversing the packet chain to find the last record.
* Add a new sbappend_stream() function for stream protocols which
  guarantee that there will never be more than one record in the
  socket buffer.  This function uses the sb_mbtail pointer to perform
  the data insertion.  Make TCP use sbappend_stream(). On a profiling
run, this makes sbappend of a TCP transmission using
a 1M socket buffer go from 50% of the time to .02% of the time. Thanks
to Bill Sommerfeld and YAMAMOTO Takashi for their debugging
assistance!
@
text
@d774 1
a774 7
		{ \
			(s)->sb_mb = m->m_nextpkt; \
			SB_EMPTY_FIXUP((s)); \
			m->m_nextpkt = 0; \
			sbfree((s), m); \
			f; \
		}
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.9 2001/06/27 03:49:53 angelos Exp $	*/
d774 7
a780 1
		{(s)->sb_mb = m->m_act; m->m_act = 0; sbfree((s), m); f;}
@


1.9
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.8 2001/06/25 01:50:17 fgsch Exp $	*/
d111 1
a111 1
static struct llinfo_x25 *x25_lxalloc __P((struct rtentry *));
d719 1
a719 1
	int             (*f) __P((struct mbuf *, void *));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.9 2001/06/27 03:49:53 angelos Exp $	*/
d111 1
a111 1
static struct llinfo_x25 *x25_lxalloc(struct rtentry *);
d719 1
a719 1
	int             (*f)(struct mbuf *, void *);
@


1.9.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.9.4.1 2002/06/11 03:31:36 art Exp $	*/
d774 1
a774 7
		{ \
			(s)->sb_mb = m->m_nextpkt; \
			SB_EMPTY_FIXUP((s)); \
			m->m_nextpkt = 0; \
			sbfree((s), m); \
			f; \
		}
@


1.8
log
@Move common post M_COPY_HDR manipulation to the macro itself; angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.7 2001/06/15 03:38:35 itojun Exp $	*/
d348 1
a348 1
		M_COPY_HDR(m, m0);
@


1.7
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.6 2001/05/27 12:19:04 angelos Exp $	*/
a348 2
		m_tag_init(m0);
		m0->m_flags &= ~M_PKTHDR;
@


1.6
log
@Fixup packet tags (I'm a masochist).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.5 2001/01/19 06:37:37 itojun Exp $	*/
a184 1
	ifp->if_lastchange = time;
@


1.5
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.4 1999/12/08 06:50:18 itojun Exp $	*/
d349 3
@


1.4
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.3 1996/05/22 12:02:40 deraadt Exp $	*/
d445 1
a445 1
x25_rtrequest(cmd, rt, dst)
d448 1
a448 1
	struct sockaddr *dst;
@


1.4.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.5 2001/01/19 06:37:37 itojun Exp $	*/
d445 1
a445 1
x25_rtrequest(cmd, rt, info)
d448 1
a448 1
	struct rt_addrinfo *info;
@


1.4.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.4.2.1 2001/05/14 22:40:05 niklas Exp $	*/
d185 1
a348 1
		M_MOVE_HDR(m, m0);
@


1.4.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 1
a111 1
static struct llinfo_x25 *x25_lxalloc(struct rtentry *);
d719 1
a719 1
	int             (*f)(struct mbuf *, void *);
@


1.4.2.4
log
@Sync the SMP branch with 3.3
@
text
@d774 1
a774 7
		{ \
			(s)->sb_mb = m->m_nextpkt; \
			SB_EMPTY_FIXUP((s)); \
			m->m_nextpkt = 0; \
			sbfree((s), m); \
			f; \
		}
@


1.4.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_x25subr.c,v 1.4.2.4 2003/03/28 00:06:55 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 1
a114 1
	struct rtentry *rt;
d116 3
a118 3
	struct llinfo_x25 *lx;
	struct sockaddr *dst = rt_key(rt);
	struct ifaddr *ifa;
d144 1
a144 1
	struct llinfo_x25 *lx;
d146 2
a147 2
	struct rtentry *rt = lx->lx_rt;
	struct pklcd *lcp = lx->lx_lcd;
d166 1
a166 1
	struct mbuf *m;
d171 1
a171 1
	struct ifnet *ifp;
d231 1
a231 1
	struct mbuf *m;
d234 2
a235 2
	struct pklcd *lcp = v;
	struct llinfo_x25 *lx = (struct llinfo_x25 *) lcp->lcd_upnext;
d269 3
a271 3
	struct pklcd *lcp = v;
	struct rtentry *rt, *nrt;
	struct mbuf *m = m0->m_next;	/* m0 has calling
d305 1
a305 1
	struct rtentry *rt;
d307 2
a308 2
	struct mbuf *m = m0;
	struct llinfo_x25 *lx;
d420 2
a421 2
	struct pkcb *pkcb = 0;
	struct pklcd **lcpp, *lcp;
d443 1
a443 1
	struct rtentry *rt;
d446 2
a447 2
	struct llinfo_x25 *lx = (struct llinfo_x25 *) rt->rt_llinfo;
	struct pklcd *lcp;
d496 2
a497 2
	struct sockaddr *sa;
	struct rtentry *rt;
d551 1
a551 1
	struct rtentry *rt;
d553 1
a553 1
	struct sockaddr_x25 *dst = (struct sockaddr_x25 *) rt->rt_gateway;
d604 1
a604 1
	struct x25_ifaddr *ia;
d622 1
a622 1
			struct in_ifaddr *ina;
d633 1
a633 1
			char  *x25addr = dst->x25_addr;
d727 1
a727 1
	u_char *info;
d729 1
a729 1
	struct x25_dgproto *dp = x25_dgprototab
d731 1
a731 1
	struct pklcd *lcp;
d757 1
a757 1
	struct socket *so;
d760 2
a761 2
	struct pklcd *lcp = (struct pklcd *) so->so_pcb;
	struct mbuf *m = m0;
d763 2
a764 2
	struct rtentry *rt = rtalloc1(dst, 0);
	struct llinfo_x25 *lx;
d827 1
a827 1
	struct pklcd *lcp0;
d830 3
a832 3
	struct llinfo_x25 *lx = (struct llinfo_x25 *) rt->rt_llinfo;
	struct pklcd *lcp;
	struct mbuf *m;
@


1.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 4
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d2 1
a2 1
/*	$NetBSD: if_x25subr.c,v 1.12 1996/02/13 22:04:39 christos Exp $	*/
d49 2
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: if_x25subr.c,v 1.11 1995/06/15 22:38:20 cgd Exp $	*/
d59 1
a71 1
int tp_incoming();
d75 3
d79 2
d88 7
a94 7
 _offsetof(struct sockaddr_x25, x25_udata[1]),			/* _len */
 0,								/* _family */
 0,								/* _net */
 { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, /* _addr */
 {0},								/* opts */
 -1,								/* _udlen */
 {-1}								/* _udata */
d96 1
a96 1
 
d98 2
a99 2
	int	ifx_wrongplen;
	int	ifx_nophdr;
d104 3
d112 1
a112 1
register struct rtentry *rt;
d118 1
a118 1
	MALLOC(lx, struct llinfo_x25 *, sizeof (*lx), M_PCB, M_NOWAIT);
d127 1
a127 1
		    (struct llinfo_x25 *)rt->rt_llinfo, lx, lx_list);
d129 1
a129 1
		rt->rt_llinfo = (caddr_t)lx;
d133 1
a133 1
	    ifa = ifa->ifa_list.tqe_next) {
d135 1
a135 1
			lx->lx_ia = (struct x25_ifaddr *)ifa;
d139 2
d142 1
a142 1
register struct llinfo_x25 *lx;
d151 2
a152 2
	if ((rt->rt_llinfo == (caddr_t)lx) && (lx->lx_list.le_next->lx_rt == rt))
		rt->rt_llinfo = (caddr_t)lx->lx_list.le_next;
d162 4
a165 3
x25_ifinput(lcp, m)
struct pklcd *lcp;
register struct mbuf *m;
d167 2
a168 1
	struct llinfo_x25 *lx = (struct llinfo_x25 *)lcp->lcd_upnext;
d172 6
a177 7
	int s, len, isr;
 
	if (m == 0 || lcp->lcd_state != DATA_TRANSFER) {
		x25_connect_callback(lcp, 0);
		return;
	}
	pk_flowcontrol(lcp, 0, 1); /* Generate RR */
d184 1
a184 1
		return;
d187 1
a187 1
		/* FALLTHROUGH */;
d213 1
a213 1
		return;
d225 1
d227 5
a231 3
x25_connect_callback(lcp, m)
register struct pklcd *lcp;
register struct mbuf *m;
d233 3
a235 2
	register struct llinfo_x25 *lx = (struct llinfo_x25 *)lcp->lcd_upnext;
	int do_clear = 1;
d243 1
a243 1
	case CALL_ACCEPTED:
d246 2
a247 2
			lcp->lcd_send(lcp); /* XXX start queued packets */
		return;
d250 1
a250 1
	refused:
d255 1
a255 1
		return;
d258 2
d263 4
a266 3
x25_dgram_incoming(lcp, m0)
register struct pklcd *lcp;
struct mbuf *m0;
d268 1
d270 2
a271 3
	register struct mbuf *m = m0->m_next; /* m0 has calling sockaddr_x25 */
	void x25_rtrequest();

d274 1
a274 1
refuse: 	lcp->lcd_upper = 0;
d276 1
a276 1
		return;
d282 1
a282 1
		rt->rt_llinfo = (caddr_t)rtalloc1(rt->rt_gateway, 0);
d290 1
a290 1
	lcp->lcd_send(lcp); /* confirm call */
d293 1
d299 1
d301 14
a314 14
struct	ifnet *ifp;
struct	mbuf *m0;
struct	sockaddr *dst;
register struct	rtentry *rt;
{
	register struct	mbuf *m = m0;
	register struct	llinfo_x25 *lx;
	struct pklcd *lcp;
	int             s, error = 0;

int plen;
for (plen = 0; m; m = m->m_next)
	plen += m->m_len;
m = m0;
d321 1
a321 1
				rt = (struct rtentry *)rt->rt_llinfo;
d335 1
a335 1
	    ((lx = (struct llinfo_x25 *)rt->rt_llinfo) == 0)) {
d338 12
a349 12
if ((m->m_flags & M_PKTHDR) == 0) {
	if_x25stats.ifx_nophdr++;
	m = m_gethdr(M_NOWAIT, MT_HEADER);
	if (m == 0)
		senderr(ENOBUFS);
	m->m_pkthdr.len = plen;
	m->m_next = m0;
}
if (plen != m->m_pkthdr.len) {
	if_x25stats.ifx_wrongplen++;
	m->m_pkthdr.len = plen;
}
d353 1
a353 1
		lx->lx_lcd = lcp = pk_attach((struct socket *)0);
d357 1
a357 1
		lcp->lcd_upnext = (caddr_t)lx;
d372 1
a372 1
					(struct sockaddr_x25 *)rt->rt_gateway);
d386 2
a387 2
				       lx->lx_ia->ia_xc.xc_dg_idletimo;
		pk_send(lcp, m);
d404 1
a404 1
	bad:
d414 1
d416 1
a416 1
struct ifnet *ifp;
d420 1
a420 1
	int s = splimp();
d423 1
a423 1
	    if (pkcb->pk_ia->ia_ifp == ifp)
d429 2
a430 2
			    (lcp->lcd_dg_timer && --lcp->lcd_dg_timer == 0)) {
				lcp->lcd_upper(lcp, 0);
d440 1
d444 1
a444 2
	register struct llinfo_x25 *lx = (struct llinfo_x25 *)rt->rt_llinfo;
	register struct sockaddr_x25 *sa =(struct sockaddr_x25 *)rt->rt_gateway;
d447 3
a449 2
	/* would put this pk_init, except routing table doesn't
	   exist yet. */
a450 1
		struct radix_node *rn_addmask();
d452 1
a452 1
			SA(rn_addmask((caddr_t)&x25_dgmask, 0, 4)->rn_key);
d456 3
a458 3
			RTFREE((struct rtentry *)rt->rt_llinfo);
		rt->rt_llinfo = (cmd == RTM_ADD) ? 
			(caddr_t)rtalloc1(rt->rt_gateway, 1) : 0;
d465 1
a465 1
			x25_lxfree((struct llinfo *)rt->rt_llinfo);
d478 3
a480 2
					 lcp->lcd_ceaddr->x25_len) != 0) {
			x25_rtinvert(RTM_DELETE, lcp->lcd_ceaddr, rt);
d491 1
d493 3
a495 2
register struct sockaddr *sa;
register struct rtentry *rt;
d509 1
a509 1
				RTF_PROTO2, &rt2);
d519 1
a519 1
	    rt->rt_llinfo != (caddr_t)rt2) {
d525 1
a525 1
				0, (struct rtentry **) 0);
d535 5
a539 5
		u_char		s_net;
		u_char		s_host;
		u_char		s_lh;
		u_char		s_impno;
	}		    imp;
d546 1
d548 2
a549 2
struct sockaddr_in *src;
register struct rtentry *rt;
d551 2
a552 2
	register struct sockaddr_x25 *dst = (struct sockaddr_x25 *)rt->rt_gateway;
	union imp_addr imp_addr;
d554 1
a554 1
	char *x25addr = dst->x25_addr;
d557 1
a557 1
	imp_addr.ip = src->sin_addr;
d560 2
a561 2
	    imp_no = imp_addr.imp.s_impno;
	    imp_port = imp_addr.imp.s_host;
d563 2
a564 2
	    imp_no = imp_addr.imp.s_impno;
	    imp_port = imp_addr.imp.s_lh;
d566 2
a567 2
	    imp_no = imp_addr.imp.s_impno / 32;
	    imp_port = imp_addr.imp.s_impno % 32;
d570 1
a570 1
	x25addr[0] = 12; /* length */
d574 7
a580 7
				 *  -> III, s_host -> HH */
	    x25addr[5] = 0;	/* set flag bit */
	    x25addr[6] = imp_no / 100;
	    x25addr[7] = (imp_no % 100) / 10;
	    x25addr[8] = imp_no % 10;
	    x25addr[9] = imp_port / 10;
	    x25addr[10] = imp_port % 10;
d583 7
a589 7
	    temp = (imp_port << 8) + imp_no;
	    x25addr[5] = 1;
	    x25addr[6] = temp / 10000;
	    x25addr[7] = (temp % 10000) / 1000;
	    x25addr[8] = (temp % 1000) / 100;
	    x25addr[9] = (temp % 100) / 10;
	    x25addr[10] = temp % 10;
d599 1
d601 3
a603 2
struct sockaddr_x25 *dst;
register struct x25_ifaddr *ia;
d607 1
a607 1
	struct in_addr my_addr;
a610 6
	/*
	 * Inverse X25 to IP mapping copyright and courtesy ACC.
	 */
		int             imp_no, imp_port, temp;
		union imp_addr imp_addr;
	    {
d612 1
a612 1
		 * First determine our IP addr for network
d614 16
a629 1
		register struct in_ifaddr *ina;
d631 23
a653 4
		for (ina = in_ifaddr.tqh_first; ina != 0;
		    ina = ina->ia_list.tqe_next)
			if (ina->ia_ifp == ia->ia_ifp) {
				my_addr = ina->ia_addr.sin_addr;
d655 16
a671 43
	    }
	    {

		register char *x25addr = dst->x25_addr;

		switch (x25addr[5] & 0x0f) {
		  case 0:	/* Physical:  0000 0 IIIHH00 [SS]	 */
		    imp_no =
			((int) (x25addr[6] & 0x0f) * 100) +
			((int) (x25addr[7] & 0x0f) * 10) +
			((int) (x25addr[8] & 0x0f));


		    imp_port =
			((int) (x25addr[9] & 0x0f) * 10) +
			((int) (x25addr[10] & 0x0f));
		    break;
		  case 1:	/* Logical:   0000 1 RRRRR00 [SS]	 */
		    temp = ((int) (x25addr[6] & 0x0f) * 10000)
			+ ((int) (x25addr[7] & 0x0f) * 1000)
			+ ((int) (x25addr[8] & 0x0f) * 100)
			+ ((int) (x25addr[9] & 0x0f) * 10)
			+ ((int) (x25addr[10] & 0x0f));

		    imp_port = temp >> 8;
		    imp_no = temp & 0xff;
		    break;
		  default:
		    return (0L);
		}
		imp_addr.ip = my_addr;
		if ((imp_addr.imp.s_net & 0x80) == 0x00) {
		/* class A */
		    imp_addr.imp.s_host = imp_port;
		    imp_addr.imp.s_impno = imp_no;
		    imp_addr.imp.s_lh = 0;
		} else if ((imp_addr.imp.s_net & 0xc0) == 0x80) {
		/* class B */
		    imp_addr.imp.s_lh = imp_port;
		    imp_addr.imp.s_impno = imp_no;
		} else {
		/* class C */
		    imp_addr.imp.s_impno = (imp_no << 5) + imp_port;
a672 1
	    }
d674 1
a674 1
		sa = (struct sockaddr *)&sin;
d680 1
a680 1
		if (rt = rtalloc1(SA(dst), 0)) {
d685 4
a688 4
	/* 
	 * Call to rtalloc1 will create rtentry for reverse path
	 * to callee by virtue of cloning magic and will allocate
	 * space for local control block.
d693 2
d697 1
d711 3
a713 3
	u_char spi;
	u_char spilen;
	int (*f)();
d716 1
a716 1
{ 0x0, 0, tp_incoming},
d718 3
a720 3
{ 0xcc, 1, x25_dgram_incoming},
{ 0xcd, 1, x25_dgram_incoming},
{ 0x81, 1, x25_dgram_incoming},
d723 1
d725 1
a725 1
register u_char *info;
d728 1
a728 1
		    + ((sizeof x25_dgprototab) / (sizeof *dp));
d730 1
a730 1
	
d736 1
a736 1
gotspi:	if (info[1])
d740 1
a740 1
		    Bcmp(&dp->spi, lcp->lcd_laddr.x25_udata, dp->spilen) == 0) {
d753 1
d755 2
a756 2
register struct socket *so;
struct mbuf *m0;
d758 1
a758 1
	register struct pklcd *lcp = (struct pklcd *)so->so_pcb;
d763 1
a763 1
	caddr_t cp;
d767 2
a768 2
	while (m = (s)->sb_mb)\
		{(s)->sb_mb = m->m_act; m->m_act = 0; sbfree((s), m); f(l, m);}
d772 1
a772 1
	cp = (dst->sa_len < m->m_len) ? ROUNDUP(dst->sa_len) + (caddr_t)dst : 0;
d776 2
a777 2
			     Bcmp(cp, rt_mask(rt), rt_mask(rt)->sa_len)) != 0)))
			rt = (struct rtentry *)rt->rt_nodes->rn_dupedkey;
d779 1
a779 1
	    (lx = (struct llinfo_x25 *)rt->rt_llinfo) == 0)
d799 2
a800 1
		transfer_sockbuf(&lcp->lcd_sb, sbappendrecord, &so->so_snd);
d807 2
a808 2
		lcp->lcd_sb = so->so_snd; /* structure copy */
		bzero((caddr_t)&so->so_snd, sizeof(so->so_snd)); /* XXXXXX */
d811 1
a811 1
		transfer_sockbuf(&so->so_rcv, x25_ifinput, lcp);
d816 2
d819 2
a820 2
register struct pklcd *lcp0;
struct rtentry *rt;
d822 1
a822 1
	register struct llinfo_x25 *lx = (struct llinfo_x25 *)rt->rt_llinfo;
d825 1
a825 1
	if (lcp = lx->lx_lcd) { /* adding an additional VC */
d827 1
a827 1
			transfer_sockbuf(&lcp->lcd_sb, pk_output, lcp0);
d838 2
a839 1
	lcp->lcd_upnext = (caddr_t)lx;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
