head	1.13;
access;
symbols
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.4.0.20
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.18
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.10
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2005.06.16.17.37.55;	author henning;	state dead;
branches;
next	1.12;

1.12
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.21.15.30.21;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.18.13.14.43;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.04.04.02.55.54;	author don;	state Exp;
branches
	1.4.10.1
	1.4.20.1;
next	1.3;

1.3
date	96.04.21.22.28.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.07.36.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.09;	author deraadt;	state Exp;
branches;
next	;

1.4.10.1
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.4.10.2;

1.4.10.2
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.4.10.3;

1.4.10.3
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.4.10.4;

1.4.10.4
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.4.20.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.4.20.2;

1.4.20.2
date	2003.05.19.22.27.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@remove remaining netccitt parts, full ports build test by pval, thanks!
@
text
@/*	$OpenBSD: pk_subr.c,v 1.12 2004/06/21 23:50:37 tholo Exp $	*/
/*	$NetBSD: pk_subr.c,v 1.12 1996/03/30 21:54:33 christos Exp $	*/

/*
 * Copyright (c) University of British Columbia, 1984
 * Copyright (C) Computer Science Department IV,
 * 		 University of Erlangen-Nuremberg, Germany, 1992
 * Copyright (c) 1991, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by the
 * Laboratory for Computation Vision and the Computer Science Department
 * of the the University of British Columbia and the Computer Science
 * Department (IV) of the University of Erlangen-Nuremberg, Germany.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pk_subr.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>

#include <net/if.h>
#include <net/route.h>

#include <netccitt/dll.h>
#include <netccitt/x25.h>
#include <netccitt/x25err.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>

#include <sys/stdarg.h>

int             pk_sendspace = 1024 * 2 + 8;
int             pk_recvspace = 1024 * 2 + 8;

struct pklcd_q  pklcd_q = {&pklcd_q, &pklcd_q};

struct x25bitslice x25_bitslice[] = {
	/* mask, shift value */
	{0xf0, 0x4},
	{0xf, 0x0},
	{0x80, 0x7},
	{0x40, 0x6},
	{0x30, 0x4},
	{0xe0, 0x5},
	{0x10, 0x4},
	{0xe, 0x1},
	{0x1, 0x0}
};


static struct x25_ifaddr *pk_ifwithaddr(struct sockaddr_x25 *);
static void pk_reset(struct pklcd *, int);

/*
 * Attach X.25 protocol to socket, allocate logical channel descripter and
 * buffer space, and enter LISTEN state if we are to accept IN-COMMING CALL
 * packets.
 * 
 */

struct pklcd *
pk_attach(so)
	struct socket  *so;
{
	struct pklcd *lcp;
	int    error = ENOBUFS;

	MALLOC(lcp, struct pklcd *, sizeof(*lcp), M_PCB, M_NOWAIT);
	if (lcp) {
		bzero((caddr_t) lcp, sizeof(*lcp));
		insque(&lcp->lcd_q, &pklcd_q);
		lcp->lcd_state = READY;
		lcp->lcd_send = pk_output;
		if (so) {
			error = soreserve(so, pk_sendspace, pk_recvspace);
			lcp->lcd_so = so;
			if (so->so_options & SO_ACCEPTCONN)
				lcp->lcd_state = LISTEN;
		} else
			sbreserve(&lcp->lcd_sb, pk_sendspace);
	}
	if (so) {
		so->so_pcb = lcp;
		so->so_error = error;
	}
	return (lcp);
}

/*
 * Disconnect X.25 protocol from socket.
 */
void
pk_disconnect(lcp)
	struct pklcd *lcp;
{
	struct socket *so = lcp->lcd_so;
	struct pklcd *l, *p;

	switch (lcp->lcd_state) {
	case LISTEN:
		for (p = 0, l = pk_listenhead; l && l != lcp; p = l, l = l->lcd_listen);
		if (p == 0) {
			if (l != 0)
				pk_listenhead = l->lcd_listen;
		} else if (l != 0)
			p->lcd_listen = l->lcd_listen;
		pk_close(lcp);
		break;

	case READY:
		pk_acct(lcp);
		pk_close(lcp);
		break;

	case SENT_CLEAR:
	case RECEIVED_CLEAR:
		break;

	default:
		pk_acct(lcp);
		if (so) {
			soisdisconnecting(so);
			sbflush(&so->so_rcv);
		}
		pk_clear(lcp, 241, 0);	/* Normal Disconnect */

	}
}

/*
 * Close an X.25 Logical Channel. Discard all space held by the connection
 * and internal descriptors. Wake up any sleepers.
 */

void
pk_close(lcp)
	struct pklcd   *lcp;
{
	struct socket *so = lcp->lcd_so;

	/*
	 * If the X.25 connection is torn down due to link
	 * level failure (e.g. LLC2 FRMR) and at the same the user
	 * level is still filling up the socket send buffer that
	 * send buffer is locked. An attempt to sbflush () that send
	 * buffer will lead us into - no, not temptation but - panic!
	 * So - we'll just check wether the send buffer is locked
	 * and if that's the case we'll mark the lcp as zombie and
	 * have the pk_timer () do the cleaning ...
	 */

	if (so && so->so_snd.sb_flags & SB_LOCK)
		lcp->lcd_state = LCN_ZOMBIE;
	else
		pk_freelcd(lcp);

	if (so == NULL)
		return;

	so->so_pcb = 0;
	soisdisconnected(so);
#if 0
	sofree (so);	/* gak!!! you can't do that here */
#endif
}

/*
 * Create a template to be used to send X.25 packets on a logical channel. It
 * allocates an mbuf and fills in a skeletal packet depending on its type.
 * This packet is passed to pk_output where the remainer of the packet is
 * filled in.
 */

struct mbuf *
pk_template(lcn, type)
	int             lcn, type;
{
	struct mbuf *m;
	struct x25_packet *xp;

	MGETHDR(m, M_DONTWAIT, MT_HEADER);
	if (m == 0)
		panic("pk_template");
	m->m_act = 0;

	/*
	 * Efficiency hack: leave a four byte gap at the beginning
	 * of the packet level header with the hope that this will
	 * be enough room for the link level to insert its header.
	 */
	m->m_data += max_linkhdr;
	m->m_pkthdr.len = m->m_len = PKHEADERLN;

	xp = mtod(m, struct x25_packet *);
	*(long *) xp = 0;	/* ugly, but fast */
	/* xp->q_bit = 0; */
	X25SBITS(xp->bits, fmt_identifier, 1);
	/* xp->lc_group_number = 0; */

	SET_LCN(xp, lcn);
	xp->packet_type = type;

	return (m);
}

/*
 * This routine restarts all the virtual circuits. Actually, the virtual
 * circuits are not "restarted" as such. Instead, any active switched circuit
 * is simply returned to READY state.
 */

void
pk_restart(pkp, restart_cause)
	struct pkcb *pkp;
	int             restart_cause;
{
	struct mbuf *m;
	struct pklcd *lcp;
	int    i;

	/* Restart all logical channels. */
	if (pkp->pk_chan == 0)
		return;

	/*
	 * Don't do this if we're doing a restart issued from
	 * inside pk_connect () --- which is only done if and
	 * only if the X.25 link is down, i.e. a RESTART needs
	 * to be done to get it up.
	 */
	if (!(pkp->pk_dxerole & DTE_CONNECTPENDING)) {
		for (i = 1; i <= pkp->pk_maxlcn; ++i)
			if ((lcp = pkp->pk_chan[i]) != NULL) {
				if (lcp->lcd_so) {
					lcp->lcd_so->so_error = ENETRESET;
					pk_close(lcp);
				} else {
					pk_flush(lcp);
					lcp->lcd_state = READY;
					if (lcp->lcd_upper)
						(*lcp->lcd_upper)(NULL, lcp);
				}
			}
	}
	if (restart_cause < 0)
		return;

	pkp->pk_state = DTE_SENT_RESTART;
	pkp->pk_dxerole &= ~(DTE_PLAYDCE | DTE_PLAYDTE);
	lcp = pkp->pk_chan[0];
	m = lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_RESTART);
	m->m_pkthdr.len = m->m_len += 2;
	mtod(m, struct x25_packet *)->packet_data = 0;	/* DTE only */
	mtod(m, octet *)[4] = restart_cause;
	pk_output(lcp);
}


/*
 * This procedure frees up the Logical Channel Descripter.
 */

void
pk_freelcd(lcp)
	struct pklcd *lcp;
{
	if (lcp == NULL)
		return;

	if (lcp->lcd_lcn > 0)
		lcp->lcd_pkp->pk_chan[lcp->lcd_lcn] = NULL;

	pk_flush(lcp);
	remque(&lcp->lcd_q);
	free((caddr_t) lcp, M_PCB);
}

static struct x25_ifaddr *
pk_ifwithaddr(sx)
	struct sockaddr_x25 *sx;
{
	struct ifnet   *ifp;
	struct ifaddr  *ifa;
	struct x25_ifaddr *ia;
	char           *addr = sx->x25_addr;

	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
		for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
		     ifa = ifa->ifa_list.tqe_next)
			if (ifa->ifa_addr->sa_family == AF_CCITT) {
				ia = (struct x25_ifaddr *) ifa;
				if (bcmp(addr, ia->ia_xc.xc_addr.x25_addr,
					 16) == 0)
					return (ia);

			}
	return ((struct x25_ifaddr *) 0);
}


/*
 * Bind a address and protocol value to a socket.  The important part is the
 * protocol value - the first four characters of the Call User Data field.
 */

#define XTRACTPKP(rt)	((rt)->rt_flags & RTF_GATEWAY ? \
			 ((rt)->rt_llinfo ? \
			  (struct pkcb *) ((struct rtentry *)((rt)->rt_llinfo))->rt_llinfo : \
			  (struct pkcb *) NULL) : \
			 (struct pkcb *)((rt)->rt_llinfo))

int
pk_bind(lcp, nam)
	struct pklcd   *lcp;
	struct mbuf    *nam;
{
	struct pklcd *pp;
	struct sockaddr_x25 *sa;

	if (nam == NULL)
		return (EADDRNOTAVAIL);
	if (lcp->lcd_ceaddr)	/* XXX */
		return (EADDRINUSE);
	if (pk_checksockaddr(nam))
		return (EINVAL);
	sa = mtod(nam, struct sockaddr_x25 *);

	/*
	 * If the user wishes to accept calls only from a particular
	 * net (net != 0), make sure the net is known
	 */

	if (sa->x25_addr[0]) {
		if (!pk_ifwithaddr(sa))
			return (ENETUNREACH);
	} else if (sa->x25_net) {
		if (!ifa_ifwithnet((struct sockaddr *) sa))
			return (ENETUNREACH);
	}
	/*
	 * For ISO's sake permit default listeners, but only one such . . .
	 */
	for (pp = pk_listenhead; pp; pp = pp->lcd_listen) {
		struct sockaddr_x25 *sa2 = pp->lcd_ceaddr;
		if ((sa2->x25_udlen == sa->x25_udlen) &&
		    (sa2->x25_udlen == 0 ||
		     (bcmp(sa2->x25_udata, sa->x25_udata,
			   min(sa2->x25_udlen, sa->x25_udlen)) == 0)))
			return (EADDRINUSE);
	}
	lcp->lcd_laddr = *sa;
	lcp->lcd_ceaddr = &lcp->lcd_laddr;
	return (0);
}

/*
 * Include a bound control block in the list of listeners.
 */
int
pk_listen(lcp)
	struct pklcd *lcp;
{
	struct pklcd **pp;

	if (lcp->lcd_ceaddr == 0)
		return (EDESTADDRREQ);

	lcp->lcd_state = LISTEN;
	/*
	 * Add default listener at end, any others at start.
	 */
	if (lcp->lcd_ceaddr->x25_udlen == 0) {
		for (pp = &pk_listenhead; *pp;)
			pp = &((*pp)->lcd_listen);
		*pp = lcp;
	} else {
		lcp->lcd_listen = pk_listenhead;
		pk_listenhead = lcp;
	}
	return (0);
}

/*
 * Include a listening control block for the benefit of other protocols.
 */
int
pk_protolisten(spi, spilen, callee)
	int		spi;
	int		spilen;
	int             (*callee)(struct mbuf *, void *);
{
	struct pklcd *lcp = pk_attach((struct socket *) 0);
	struct mbuf *nam;
	struct sockaddr_x25 *sa;
	int             error = ENOBUFS;

	if (lcp) {
		if ((nam = m_getclr(M_DONTWAIT, MT_SONAME)) != NULL) {
			sa = mtod(nam, struct sockaddr_x25 *);
			sa->x25_family = AF_CCITT;
			sa->x25_len = nam->m_len = sizeof(*sa);
			sa->x25_udlen = spilen;
			sa->x25_udata[0] = spi;
			lcp->lcd_upper = callee;
			lcp->lcd_flags = X25_MBS_HOLD;
			if ((error = pk_bind(lcp, nam)) == 0)
				error = pk_listen(lcp);
			(void) m_free(nam);
		}
		if (error)
			pk_freelcd(lcp);
	}
	return error;		/* Hopefully Zero ! */
}

/*
 * Associate a logical channel descriptor with a network.
 * Fill in the default network specific parameters and then
 * set any parameters explicitly specified by the user or
 * by the remote DTE.
 */

void
pk_assoc(pkp, lcp, sa)
	struct pkcb *pkp;
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
{

	lcp->lcd_pkp = pkp;
	lcp->lcd_packetsize = pkp->pk_xcp->xc_psize;
	lcp->lcd_windowsize = pkp->pk_xcp->xc_pwsize;
	lcp->lcd_rsn = MODULUS - 1;
	pkp->pk_chan[lcp->lcd_lcn] = lcp;

	if (sa->x25_opts.op_psize)
		lcp->lcd_packetsize = sa->x25_opts.op_psize;
	else
		sa->x25_opts.op_psize = lcp->lcd_packetsize;
	if (sa->x25_opts.op_wsize)
		lcp->lcd_windowsize = sa->x25_opts.op_wsize;
	else
		sa->x25_opts.op_wsize = lcp->lcd_windowsize;
	sa->x25_net = pkp->pk_xcp->xc_addr.x25_net;
	lcp->lcd_flags |= sa->x25_opts.op_flags;
	lcp->lcd_stime = time_second;
}

int
pk_connect(lcp, sa)
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
{
	struct pkcb *pkp;
	struct rtentry *rt;
	struct rtentry *nrt;

	if (sa->x25_addr[0] == '\0')
		return (EDESTADDRREQ);

	/*
	 * Is the destination address known?
	 */
	if (!(rt = rtalloc1((struct sockaddr *) sa, 1)))
		return (ENETUNREACH);

	if (!(pkp = XTRACTPKP(rt)))
		pkp = pk_newlink((struct x25_ifaddr *) (rt->rt_ifa),
				 (caddr_t) 0);

	/*
	 * Have we entered the LLC address?
	 */
	if ((nrt = npaidb_enter((struct sockaddr_dl *) rt->rt_gateway,
				rt_key(rt), rt, 0)) != NULL)
		pkp->pk_llrt = nrt;

	/*
	 * Have we allocated an LLC2 link yet?
	 */
	if (pkp->pk_llnext == (caddr_t) 0 && pkp->pk_llctlinput) {
		struct dll_ctlinfo ctlinfo;

		ctlinfo.dlcti_rt = rt;
		ctlinfo.dlcti_pcb = (caddr_t) pkp;
		ctlinfo.dlcti_conf =
			(struct dllconfig *) (&((struct x25_ifaddr *) (rt->rt_ifa))->ia_xc);
		pkp->pk_llnext =
			(*pkp->pk_llctlinput)(PRC_CONNECT_REQUEST,
					      NULL, &ctlinfo);
	}
	if (pkp->pk_state != DTE_READY && pkp->pk_state != DTE_WAITING)
		return (ENETDOWN);
	if ((lcp->lcd_lcn = pk_getlcn(pkp)) == 0)
		return (EMFILE);

	lcp->lcd_faddr = *sa;
	lcp->lcd_ceaddr = &lcp->lcd_faddr;
	pk_assoc(pkp, lcp, lcp->lcd_ceaddr);

	/*
	 * If the link is not up yet, initiate an X.25 RESTART
	 */
	if (pkp->pk_state == DTE_WAITING) {
		pkp->pk_dxerole |= DTE_CONNECTPENDING;
		pk_ctlinput(PRC_LINKUP, NULL, pkp);
		if (lcp->lcd_so)
			soisconnecting(lcp->lcd_so);
		return 0;
	}
	if (lcp->lcd_so)
		soisconnecting(lcp->lcd_so);
	lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_CALL);
	pk_callrequest(lcp, lcp->lcd_ceaddr, pkp->pk_xcp);
	return (*pkp->pk_ia->ia_start) (lcp);
}

/*
 * Complete all pending X.25 call requests --- this gets called after
 * the X.25 link has been restarted.
 */
#define RESHUFFLELCN(maxlcn, lcn) ((maxlcn) - (lcn) + 1)

void
pk_callcomplete(pkp)
	struct pkcb *pkp;
{
	struct pklcd *lcp;
	int    i;
	int    ni;


	if (pkp->pk_dxerole & DTE_CONNECTPENDING)
		pkp->pk_dxerole &= ~DTE_CONNECTPENDING;
	else
		return;

	if (pkp->pk_chan == 0)
		return;

	/*
	 * We pretended to be a DTE for allocating lcns, if
	 * it turns out that we are in reality performing as a
	 * DCE we need to reshuffle the lcps.
	 *
         *             /+---------------+--------     -
	 *            / | a  (maxlcn-1) |              \
	 *           /  +---------------+              	\
	 *     +--- *   | b  (maxlcn-2) |         	 \
	 *     |     \  +---------------+         	  \
	 *   r |      \ | c  (maxlcn-3) |         	   \
	 *   e |       \+---------------+         	    |
	 *   s |        |	 .                	    |
	 *   h |        |        .                	    | m
	 *   u |        |	 .      	  	    | a
	 *   f |        |	 .      	  	    | x
	 *   f |        |	 .                	    | l
	 *   l |       /+---------------+         	    | c
	 *   e |      / | c' (   3    ) |         	    | n
	 *     |     /  +---------------+         	    |
	 *     +--> *   | b' (   2    ) |         	   /
	 *           \  +---------------+         	  /
	 *            \ | a' (   1    ) |         	 /
    	 *             \+---------------+               /
         *              | 0             |              /
	 *              +---------------+--------     -
	 *
	 */
	if (pkp->pk_dxerole & DTE_PLAYDCE) {
		/* Sigh, reshuffle it */
		for (i = pkp->pk_maxlcn; i > 0; --i)
			if (pkp->pk_chan[i]) {
				ni = RESHUFFLELCN(pkp->pk_maxlcn, i);
				pkp->pk_chan[ni] = pkp->pk_chan[i];
				pkp->pk_chan[i] = NULL;
				pkp->pk_chan[ni]->lcd_lcn = ni;
			}
	}
	for (i = 1; i <= pkp->pk_maxlcn; ++i)
		if ((lcp = pkp->pk_chan[i]) != NULL) {
			/*
			 * if (lcp->lcd_so) soisconnecting (lcp->lcd_so);
			 */
			lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_CALL);
			pk_callrequest(lcp, lcp->lcd_ceaddr, pkp->pk_xcp);
			(*pkp->pk_ia->ia_start) (lcp);
		}
}

struct bcdinfo {
	octet          *cp;
	unsigned        posn;
};

/*
 * Build the rest of the CALL REQUEST packet. Fill in calling address,
 * facilities fields and the user data field.
 */

void
pk_callrequest(lcp, sa, xcp)
	struct pklcd   *lcp;
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
{
	struct x25_calladdr *a;
	struct mbuf *m = lcp->lcd_template;
	struct x25_packet *xp = mtod(m, struct x25_packet *);
	struct bcdinfo  b;

	if (lcp->lcd_flags & X25_DBIT)
		X25SBITS(xp->bits, d_bit, 1);
	a = (struct x25_calladdr *) & xp->packet_data;
	b.cp = (octet *) a->address_field;
	b.posn = 0;
	X25SBITS(a->addrlens, called_addrlen, to_bcd(&b, sa, xcp));
	X25SBITS(a->addrlens, calling_addrlen, to_bcd(&b, &xcp->xc_addr, xcp));
	if (b.posn & 0x01)
		*b.cp++ &= 0xf0;
	m->m_pkthdr.len = m->m_len += b.cp - (octet *) a;

	if (lcp->lcd_facilities) {
		m->m_pkthdr.len +=
			(m->m_next = lcp->lcd_facilities)->m_pkthdr.len;
		lcp->lcd_facilities = 0;
	} else
		pk_build_facilities(m, sa, (int) xcp->xc_type);

	m_copyback(m, m->m_pkthdr.len, sa->x25_udlen, sa->x25_udata);
}

void
pk_build_facilities(m, sa, type)
	struct mbuf *m;
	struct sockaddr_x25 *sa;
	int type;
{
	octet *cp;
	octet *fcp;
	int    revcharge;

	cp = mtod(m, octet *) + m->m_len;
	fcp = cp + 1;
	revcharge = sa->x25_opts.op_flags & X25_REVERSE_CHARGE ? 1 : 0;
	/*
	 * This is specific to Datapac X.25(1976) DTEs.  International
	 * calls must have the "hi priority" bit on.
	 */
	if (type == X25_1976 && sa->x25_opts.op_psize == X25_PS128)
		revcharge |= 02;
	if (revcharge) {
		*fcp++ = FACILITIES_REVERSE_CHARGE;
		*fcp++ = revcharge;
	}
	switch (type) {
	case X25_1980:
	case X25_1984:
		*fcp++ = FACILITIES_PACKETSIZE;
		*fcp++ = sa->x25_opts.op_psize;
		*fcp++ = sa->x25_opts.op_psize;

		*fcp++ = FACILITIES_WINDOWSIZE;
		*fcp++ = sa->x25_opts.op_wsize;
		*fcp++ = sa->x25_opts.op_wsize;
	}
	*cp = fcp - cp - 1;
	m->m_pkthdr.len = (m->m_len += *cp + 1);
}

int
to_bcd(b, sa, xcp)
	struct bcdinfo *b;
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
{
	char  *x = sa->x25_addr;
	unsigned        start = b->posn;
	/*
	 * The nodnic and prepnd0 stuff looks tedious,
	 * but it does allow full X.121 addresses to be used,
	 * which is handy for routing info (& OSI type 37 addresses).
	 */
	if (xcp->xc_addr.x25_net && (xcp->xc_nodnic || xcp->xc_prepnd0)) {
		char            dnicname[sizeof(long) * NBBY / 3 + 2];
		char  *p = dnicname;

		sprintf(p, "%d", xcp->xc_addr.x25_net & 0x7fff);
		for (; *p; p++)	/* *p == 0 means dnic matched */
			if ((*p ^ *x++) & 0x0f)
				break;
		if (*p || xcp->xc_nodnic == 0)
			x = sa->x25_addr;
		if (*p && xcp->xc_prepnd0) {
			if ((b->posn)++ & 0x01)
				(b->cp)++;
			else
				*(b->cp) = 0;
		}
	}
	while (*x)
		if ((b->posn)++ & 0x01)
			*(b->cp)++ |= *x++ & 0x0F;
		else
			*(b->cp) = *x++ << 4;
	return ((b->posn) - start);
}

/*
 * This routine gets the  first available logical channel number.  The search
 * is - from the highest number to lowest number if playing DTE, and - from
 * lowest to highest number if playing DCE.
 */

int
pk_getlcn(pkp)
	struct pkcb *pkp;
{
	int    i;

	if (pkp->pk_chan == 0)
		return (0);
	if (pkp->pk_dxerole & DTE_PLAYDCE) {
		for (i = 1; i <= pkp->pk_maxlcn; ++i)
			if (pkp->pk_chan[i] == NULL)
				break;
	} else {
		for (i = pkp->pk_maxlcn; i > 0; --i)
			if (pkp->pk_chan[i] == NULL)
				break;
	}
	i = (i > pkp->pk_maxlcn ? 0 : i);
	return (i);
}

/*
 * This procedure sends a CLEAR request packet. The lc state is set to
 * "SENT_CLEAR".
 */

void
pk_clear(lcp, diagnostic, abortive)
	struct pklcd *lcp;
	int diagnostic;
	int abortive;
{
	struct mbuf *m = pk_template(lcp->lcd_lcn, X25_CLEAR);

	m->m_len += 2;
	m->m_pkthdr.len += 2;
	mtod(m, struct x25_packet *)->packet_data = 0;
	mtod(m, octet *)[4] = diagnostic;
	if (lcp->lcd_facilities) {
		m->m_next = lcp->lcd_facilities;
		m->m_pkthdr.len += m->m_next->m_len;
		lcp->lcd_facilities = 0;
	}
	if (abortive)
		lcp->lcd_template = m;
	else {
		struct socket  *so = lcp->lcd_so;
		struct sockbuf *sb = so ? &so->so_snd : &lcp->lcd_sb;
		sbappendrecord(sb, m);
	}
	pk_output(lcp);

}

/*
 * This procedure generates RNR's or RR's to inhibit or enable
 * inward data flow, if the current state changes (blocked ==> open or
 * vice versa), or if forced to generate one.  One forces RNR's to ack data.
 */
void
pk_flowcontrol(lcp, inhibit, forced)
	struct pklcd *lcp;
	int inhibit;
	int forced;
{
	inhibit = (inhibit != 0);
	if (lcp == 0 || lcp->lcd_state != DATA_TRANSFER ||
	    (forced == 0 && lcp->lcd_rxrnr_condition == inhibit))
		return;
	lcp->lcd_rxrnr_condition = inhibit;
	lcp->lcd_template =
		pk_template(lcp->lcd_lcn, inhibit ? X25_RNR : X25_RR);
	pk_output(lcp);
}

/*
 * This procedure sends a RESET request packet. It re-initializes virtual
 * circuit.
 */

static void
pk_reset(lcp, diagnostic)
	struct pklcd *lcp;
	int diagnostic;
{
	struct mbuf *m;
	struct socket *so = lcp->lcd_so;

	if (lcp->lcd_state != DATA_TRANSFER)
		return;

	if (so)
		so->so_error = ECONNRESET;
	lcp->lcd_reset_condition = TRUE;

	/* Reset all the control variables for the channel. */
	pk_flush(lcp);
	lcp->lcd_window_condition = lcp->lcd_rnr_condition =
		lcp->lcd_intrconf_pending = FALSE;
	lcp->lcd_rsn = MODULUS - 1;
	lcp->lcd_ssn = 0;
	lcp->lcd_output_window = lcp->lcd_input_window =
		lcp->lcd_last_transmitted_pr = 0;
	m = lcp->lcd_template = pk_template(lcp->lcd_lcn, X25_RESET);
	m->m_pkthdr.len = m->m_len += 2;
	mtod(m, struct x25_packet *)->packet_data = 0;
	mtod(m, octet *)[4] = diagnostic;
	pk_output(lcp);

}

/*
 * This procedure frees all data queued for output or delivery on a
 *  virtual circuit.
 */
void
pk_flush(lcp)
	struct pklcd *lcp;
{
	struct socket *so;

	if (lcp->lcd_template)
		m_freem(lcp->lcd_template);

	if (lcp->lcd_cps) {
		m_freem(lcp->lcd_cps);
		lcp->lcd_cps = 0;
	}
	if (lcp->lcd_facilities) {
		m_freem(lcp->lcd_facilities);
		lcp->lcd_facilities = 0;
	}
	if ((so = lcp->lcd_so) != NULL)
		sbflush(&so->so_snd);
	else
		sbflush(&lcp->lcd_sb);
}

/*
 * This procedure handles all local protocol procedure errors.
 */

void
pk_procerror(error, lcp, errstr, diagnostic)
	int error;
	struct pklcd *lcp;
	char *errstr;
	int diagnostic;
{

	pk_message(lcp->lcd_lcn, lcp->lcd_pkp->pk_xcp, errstr);

	switch (error) {
	case PK_CLEAR:
		if (lcp->lcd_so) {
			lcp->lcd_so->so_error = ECONNABORTED;
			soisdisconnecting(lcp->lcd_so);
		}
		pk_clear(lcp, diagnostic, 1);
		break;

	case PK_RESET:
		pk_reset(lcp, diagnostic);
	}
}

/*
 * This procedure is called during the DATA TRANSFER state to check and
 * process  the P(R) values  received  in the DATA,  RR OR RNR packets.
 */

int
pk_ack(lcp, pr)
	struct pklcd   *lcp;
	unsigned        pr;
{
	struct socket *so = lcp->lcd_so;

	if (lcp->lcd_output_window == pr)
		return (PACKET_OK);
	if (lcp->lcd_output_window < lcp->lcd_ssn) {
		if (pr < lcp->lcd_output_window || pr > lcp->lcd_ssn) {
			pk_procerror(PK_RESET, lcp,
				     "p(r) flow control error", 2);
			return (ERROR_PACKET);
		}
	} else {
		if (pr < lcp->lcd_output_window && pr > lcp->lcd_ssn) {
			pk_procerror(PK_RESET, lcp,
				     "p(r) flow control error #2", 2);
			return (ERROR_PACKET);
		}
	}

	lcp->lcd_output_window = pr;	/* Rotate window. */
	if (lcp->lcd_window_condition == TRUE)
		lcp->lcd_window_condition = FALSE;

	if (so && sb_notify(&(so->so_snd)))
		sowwakeup(so);

	return (PACKET_OK);
}

/*
 * This procedure decodes the X.25 level 3 packet returning a code to be used
 * in switchs or arrays.
 */

int
pk_decode(xp)
	struct x25_packet *xp;
{
	int    type;

	if (X25GBITS(xp->bits, fmt_identifier) != 1)
		return (PK_INVALID_PACKET);
#ifdef ancient_history
	/*
	 * Make sure that the logical channel group number is 0. This
	 * restriction may be removed at some later date.
	 */
	if (xp->lc_group_number != 0)
		return (PK_INVALID_PACKET);
#endif
	/*
	 * Test for data packet first.
	 */
	if (!(xp->packet_type & DATA_PACKET_DESIGNATOR))
		return (PK_DATA);

	/*
	 * Test if flow control packet (RR or RNR).
	 */
	if (!(xp->packet_type & RR_OR_RNR_PACKET_DESIGNATOR))
		switch (xp->packet_type & 0x1f) {
		case X25_RR:
			return (PK_RR);
		case X25_RNR:
			return (PK_RNR);
		case X25_REJECT:
			return (PK_REJECT);
		}

	/*
	 * Determine the rest of the packet types.
	 */
	switch (xp->packet_type) {
	case X25_CALL:
		type = PK_CALL;
		break;

	case X25_CALL_ACCEPTED:
		type = PK_CALL_ACCEPTED;
		break;

	case X25_CLEAR:
		type = PK_CLEAR;
		break;

	case X25_CLEAR_CONFIRM:
		type = PK_CLEAR_CONF;
		break;

	case X25_INTERRUPT:
		type = PK_INTERRUPT;
		break;

	case X25_INTERRUPT_CONFIRM:
		type = PK_INTERRUPT_CONF;
		break;

	case X25_RESET:
		type = PK_RESET;
		break;

	case X25_RESET_CONFIRM:
		type = PK_RESET_CONF;
		break;

	case X25_RESTART:
		type = PK_RESTART;
		break;

	case X25_RESTART_CONFIRM:
		type = PK_RESTART_CONF;
		break;

	case X25_DIAGNOSTIC:
		type = PK_DIAG_TYPE;
		break;

	default:
		type = PK_INVALID_PACKET;
	}
	return (type);
}

/*
 * A restart packet has been received. Print out the reason for the restart.
 */

void
pk_restartcause(pkp, xp)
	struct pkcb    *pkp;
	struct x25_packet *xp;
{
	struct x25config *xcp = pkp->pk_xcp;
	int    lcn = LCN(xp);

	switch (xp->packet_data) {
	case X25_RESTART_LOCAL_PROCEDURE_ERROR:
		pk_message(lcn, xcp, "restart: local procedure error");
		break;

	case X25_RESTART_NETWORK_CONGESTION:
		pk_message(lcn, xcp, "restart: network congestion");
		break;

	case X25_RESTART_NETWORK_OPERATIONAL:
		pk_message(lcn, xcp, "restart: network operational");
		break;

	default:
		pk_message(lcn, xcp, "restart: unknown cause");
	}
}

#define MAXRESETCAUSE	7

int             Reset_cause[] = {
	EXRESET, EXROUT, 0, EXRRPE, 0, EXRLPE, 0, EXRNCG
};

/*
 * A reset packet has arrived. Return the cause to the user.
 */

void
pk_resetcause(pkp, xp)
	struct pkcb    *pkp;
	struct x25_packet *xp;
{
	struct pklcd *lcp =
	pkp->pk_chan[LCN(xp)];
	int    code = xp->packet_data;

	if (code > MAXRESETCAUSE)
		code = 7;	/* EXRNCG */

	pk_message(LCN(xp), lcp->lcd_pkp->pk_xcp,
		   "reset code 0x%x, diagnostic 0x%x",
		   xp->packet_data, 4[(u_char *) xp]);

	if (lcp->lcd_so)
		lcp->lcd_so->so_error = Reset_cause[code];
}

#define MAXCLEARCAUSE	25

int Clear_cause[] = {
	EXCLEAR, EXCBUSY, 0, EXCINV, 0, EXCNCG, 0,
	0, 0, EXCOUT, 0, EXCAB, 0, EXCNOB, 0, 0, 0, EXCRPE,
	0, EXCLPE, 0, 0, 0, 0, 0, EXCRRC
};

/*
 * A clear packet has arrived. Return the cause to the user.
 */
void
pk_clearcause(pkp, xp)
	struct pkcb    *pkp;
	struct x25_packet *xp;
{
	struct pklcd *lcp =
	pkp->pk_chan[LCN(xp)];
	int    code = xp->packet_data;

	if (code > MAXCLEARCAUSE)
		code = 5;	/* EXRNCG */
	if (lcp->lcd_so)
		lcp->lcd_so->so_error = Clear_cause[code];
}

char *
format_ntn(xcp)
	struct x25config *xcp;
{

	return (xcp->xc_addr.x25_addr);
}

/* VARARGS1 */
void
pk_message(int lcn, struct x25config * xcp, char * fmt,...)
{
	va_list         ap;

	if (lcn) {
		if (!PQEMPTY)
			printf("X.25(%s): lcn %d: ", format_ntn(xcp), lcn);
		else
			printf("X.25: lcn %d: ", lcn);
	} else if (!PQEMPTY)
		printf("X.25(%s): ", format_ntn(xcp));
	else
		printf("X.25: ");

	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
	printf("\n");
}

int
pk_fragment(lcp, m0, qbit, mbit, wait)
	struct mbuf    *m0;
	struct pklcd *lcp;
	int qbit, mbit, wait;
{
	struct mbuf *m = m0;
	struct x25_packet *xp;
	struct sockbuf *sb;
	struct mbuf    *head = 0, *next, **mp = &head;
	int             totlen, psize = 1 << (lcp->lcd_packetsize);

	if (m == 0)
		return 0;
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("pk_fragment");
	totlen = m->m_pkthdr.len;
	m->m_act = 0;
	sb = lcp->lcd_so ? &lcp->lcd_so->so_snd : &lcp->lcd_sb;
	do {
		if (totlen > psize) {
			if ((next = m_split(m, psize, wait)) == 0)
				goto abort;
			totlen -= psize;
		} else
			next = 0;
		M_PREPEND(m, PKHEADERLN, wait);
		if (m == 0)
			goto abort;
		*mp = m;
		mp = &m->m_act;
		*mp = 0;
		xp = mtod(m, struct x25_packet *);
		0[(char *) xp] = 0;
		if (qbit)
			X25SBITS(xp->bits, q_bit, 1);
		if (lcp->lcd_flags & X25_DBIT)
			X25SBITS(xp->bits, d_bit, 1);
		X25SBITS(xp->bits, fmt_identifier, 1);
		xp->packet_type = X25_DATA;
		SET_LCN(xp, lcp->lcd_lcn);
		if (next || (mbit && (totlen == psize ||
				      (lcp->lcd_flags & X25_DBIT))))
			SMBIT(xp, 1);
	} while ((m = next) != NULL);
	for (m = head; m; m = next) {
		next = m->m_act;
		m->m_act = 0;
		sbappendrecord(sb, m);
	}
	return 0;
abort:
	if (wait)
		panic("pk_fragment null mbuf after wait");
	if (next)
		m_freem(next);
	for (m = head; m; m = next) {
		next = m->m_act;
		m_freem(m);
	}
	return ENOBUFS;
}
@


1.12
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.11 2004/01/03 14:08:53 espie Exp $	*/
@


1.11
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.10 2003/12/21 15:30:21 miod Exp $	*/
d479 1
a479 1
	lcp->lcd_stime = time.tv_sec;
@


1.10
log
@Kill non-standard kernel printf %: braindead extension for good.
ok markus@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.9 2003/12/10 07:22:43 itojun Exp $	*/
d63 1
a63 1
#include <machine/stdarg.h>
@


1.9
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.8 2003/06/02 23:28:13 millert Exp $	*/
d1156 1
a1156 1
	printf("%:\n", fmt, ap);
d1158 1
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.7 2003/02/18 13:14:43 jmc Exp $	*/
d98 2
a99 2
	register struct pklcd *lcp;
	register int    error = ENOBUFS;
d127 1
a127 1
	register struct pklcd *lcp;
d129 2
a130 2
	register struct socket *so = lcp->lcd_so;
	register struct pklcd *l, *p;
d172 1
a172 1
	register struct socket *so = lcp->lcd_so;
d211 2
a212 2
	register struct mbuf *m;
	register struct x25_packet *xp;
d247 1
a247 1
	register struct pkcb *pkp;
d250 3
a252 3
	register struct mbuf *m;
	register struct pklcd *lcp;
	register int    i;
d298 1
a298 1
	register struct pklcd *lcp;
d317 1
a317 1
	register struct x25_ifaddr *ia;
d350 2
a351 2
	register struct pklcd *pp;
	register struct sockaddr_x25 *sa;
d377 1
a377 1
		register struct sockaddr_x25 *sa2 = pp->lcd_ceaddr;
d394 1
a394 1
	register struct pklcd *lcp;
d396 1
a396 1
	register struct pklcd **pp;
d425 3
a427 3
	register struct pklcd *lcp = pk_attach((struct socket *) 0);
	register struct mbuf *nam;
	register struct sockaddr_x25 *sa;
d458 3
a460 3
	register struct pkcb *pkp;
	register struct pklcd *lcp;
	register struct sockaddr_x25 *sa;
d484 2
a485 2
	register struct pklcd *lcp;
	register struct sockaddr_x25 *sa;
d487 3
a489 3
	register struct pkcb *pkp;
	register struct rtentry *rt;
	register struct rtentry *nrt;
d559 1
a559 1
	register struct pkcb *pkp;
d561 3
a563 3
	register struct pklcd *lcp;
	register int    i;
	register int    ni;
d636 2
a637 2
	register struct sockaddr_x25 *sa;
	register struct x25config *xcp;
d639 3
a641 3
	register struct x25_calladdr *a;
	register struct mbuf *m = lcp->lcd_template;
	register struct x25_packet *xp = mtod(m, struct x25_packet *);
d667 1
a667 1
	register struct mbuf *m;
d671 3
a673 3
	register octet *cp;
	register octet *fcp;
	register int    revcharge;
d705 1
a705 1
	register struct bcdinfo *b;
d707 1
a707 1
	register struct x25config *xcp;
d709 1
a709 1
	register char  *x = sa->x25_addr;
d718 1
a718 1
		register char  *p = dnicname;
d749 1
a749 1
	register struct pkcb *pkp;
d751 1
a751 1
	register int    i;
d775 1
a775 1
	register struct pklcd *lcp;
d779 1
a779 1
	register struct mbuf *m = pk_template(lcp->lcd_lcn, X25_CLEAR);
d808 1
a808 1
	register struct pklcd *lcp;
d829 1
a829 1
	register struct pklcd *lcp;
d832 2
a833 2
	register struct mbuf *m;
	register struct socket *so = lcp->lcd_so;
d864 1
a864 1
	register struct pklcd *lcp;
d866 1
a866 1
	register struct socket *so;
d892 1
a892 1
	register struct pklcd *lcp;
d923 1
a923 1
	register struct socket *so = lcp->lcd_so;
d958 1
a958 1
	register struct x25_packet *xp;
d960 1
a960 1
	register int    type;
d1052 1
a1052 1
	register struct x25_packet *xp;
d1054 2
a1055 2
	register struct x25config *xcp = pkp->pk_xcp;
	register int    lcn = LCN(xp);
d1088 1
a1088 1
	register struct x25_packet *xp;
d1090 1
a1090 1
	register struct pklcd *lcp =
d1092 1
a1092 1
	register int    code = xp->packet_data;
d1119 1
a1119 1
	register struct x25_packet *xp;
d1121 1
a1121 1
	register struct pklcd *lcp =
d1123 1
a1123 1
	register int    code = xp->packet_data;
d1133 1
a1133 1
	register struct x25config *xcp;
d1163 1
a1163 1
	register struct pklcd *lcp;
d1166 3
a1168 3
	register struct mbuf *m = m0;
	register struct x25_packet *xp;
	register struct sockbuf *sb;
@


1.7
log
@intial -> initial;

the great intial witch hunt, as prompted by tdeval@@

os-aix-dso.c: ok henning@@
ab.C: ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.6 2002/03/15 18:19:52 millert Exp $	*/
d24 1
a24 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.5 2002/03/14 01:27:10 millert Exp $	*/
d827 1
a827 1
 * This procedure sends a RESET request packet. It re-intializes virtual
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.4 1998/04/04 02:55:54 don Exp $	*/
a1144 1
#if __STDC__
a1145 7
#else
pk_message(lcn, xcp, fmt, va_alist)
	int             lcn;
	struct x25config *xcp;
	char           *fmt;
	va_dcl
#endif
@


1.4
log
@gcc 2.8 supplication
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.3 1996/04/21 22:28:53 deraadt Exp $	*/
d88 2
a89 2
static struct x25_ifaddr *pk_ifwithaddr __P((struct sockaddr_x25 *));
static void pk_reset __P((struct pklcd *, int));
d427 1
a427 1
	int             (*callee) __P((struct mbuf *, void *));
@


1.4.20.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.4 1998/04/04 02:55:54 don Exp $	*/
d88 2
a89 2
static struct x25_ifaddr *pk_ifwithaddr(struct sockaddr_x25 *);
static void pk_reset(struct pklcd *, int);
d427 1
a427 1
	int             (*callee)(struct mbuf *, void *);
d1145 1
d1147 7
@


1.4.20.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d827 1
a827 1
 * This procedure sends a RESET request packet. It re-initializes virtual
@


1.4.10.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 2
a89 2
static struct x25_ifaddr *pk_ifwithaddr(struct sockaddr_x25 *);
static void pk_reset(struct pklcd *, int);
d427 1
a427 1
	int             (*callee)(struct mbuf *, void *);
d1145 1
d1147 7
@


1.4.10.2
log
@Sync the SMP branch with 3.3
@
text
@d827 1
a827 1
 * This procedure sends a RESET request packet. It re-initializes virtual
@


1.4.10.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.4.10.2 2003/03/28 00:06:55 niklas Exp $	*/
d24 5
a28 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.10.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 1
#include <sys/stdarg.h>
d98 2
a99 2
	struct pklcd *lcp;
	int    error = ENOBUFS;
d127 1
a127 1
	struct pklcd *lcp;
d129 2
a130 2
	struct socket *so = lcp->lcd_so;
	struct pklcd *l, *p;
d172 1
a172 1
	struct socket *so = lcp->lcd_so;
d211 2
a212 2
	struct mbuf *m;
	struct x25_packet *xp;
d247 1
a247 1
	struct pkcb *pkp;
d250 3
a252 3
	struct mbuf *m;
	struct pklcd *lcp;
	int    i;
d298 1
a298 1
	struct pklcd *lcp;
d317 1
a317 1
	struct x25_ifaddr *ia;
d350 2
a351 2
	struct pklcd *pp;
	struct sockaddr_x25 *sa;
d377 1
a377 1
		struct sockaddr_x25 *sa2 = pp->lcd_ceaddr;
d394 1
a394 1
	struct pklcd *lcp;
d396 1
a396 1
	struct pklcd **pp;
d425 3
a427 3
	struct pklcd *lcp = pk_attach((struct socket *) 0);
	struct mbuf *nam;
	struct sockaddr_x25 *sa;
d458 3
a460 3
	struct pkcb *pkp;
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
d484 2
a485 2
	struct pklcd *lcp;
	struct sockaddr_x25 *sa;
d487 3
a489 3
	struct pkcb *pkp;
	struct rtentry *rt;
	struct rtentry *nrt;
d559 1
a559 1
	struct pkcb *pkp;
d561 3
a563 3
	struct pklcd *lcp;
	int    i;
	int    ni;
d636 2
a637 2
	struct sockaddr_x25 *sa;
	struct x25config *xcp;
d639 3
a641 3
	struct x25_calladdr *a;
	struct mbuf *m = lcp->lcd_template;
	struct x25_packet *xp = mtod(m, struct x25_packet *);
d667 1
a667 1
	struct mbuf *m;
d671 3
a673 3
	octet *cp;
	octet *fcp;
	int    revcharge;
d705 1
a705 1
	struct bcdinfo *b;
d707 1
a707 1
	struct x25config *xcp;
d709 1
a709 1
	char  *x = sa->x25_addr;
d718 1
a718 1
		char  *p = dnicname;
d749 1
a749 1
	struct pkcb *pkp;
d751 1
a751 1
	int    i;
d775 1
a775 1
	struct pklcd *lcp;
d779 1
a779 1
	struct mbuf *m = pk_template(lcp->lcd_lcn, X25_CLEAR);
d808 1
a808 1
	struct pklcd *lcp;
d829 1
a829 1
	struct pklcd *lcp;
d832 2
a833 2
	struct mbuf *m;
	struct socket *so = lcp->lcd_so;
d864 1
a864 1
	struct pklcd *lcp;
d866 1
a866 1
	struct socket *so;
d892 1
a892 1
	struct pklcd *lcp;
d923 1
a923 1
	struct socket *so = lcp->lcd_so;
d958 1
a958 1
	struct x25_packet *xp;
d960 1
a960 1
	int    type;
d1052 1
a1052 1
	struct x25_packet *xp;
d1054 2
a1055 2
	struct x25config *xcp = pkp->pk_xcp;
	int    lcn = LCN(xp);
d1088 1
a1088 1
	struct x25_packet *xp;
d1090 1
a1090 1
	struct pklcd *lcp =
d1092 1
a1092 1
	int    code = xp->packet_data;
d1119 1
a1119 1
	struct x25_packet *xp;
d1121 1
a1121 1
	struct pklcd *lcp =
d1123 1
a1123 1
	int    code = xp->packet_data;
d1133 1
a1133 1
	struct x25config *xcp;
d1156 1
a1156 1
	vprintf(fmt, ap);
a1157 1
	printf("\n");
d1163 1
a1163 1
	struct pklcd *lcp;
d1166 3
a1168 3
	struct mbuf *m = m0;
	struct x25_packet *xp;
	struct sockbuf *sb;
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: pk_subr.c,v 1.2 1996/03/04 07:36:44 niklas Exp $	*/
d1157 1
a1157 1
	if (lcn)
d1162 1
a1162 1
	else if (!PQEMPTY)
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pk_subr.c,v 1.11 1996/02/13 22:05:34 christos Exp $	*/
a1155 1
	static const char *rec = "%r\n";
d1168 1
a1168 1
	printf(rec, fmt, ap);
d1186 1
a1186 1
	if (m->m_flags & M_PKTHDR == 0)
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: pk_subr.c,v 1.10 1995/08/17 02:57:25 mycroft Exp $	*/
d6 1
a6 1
 * Copyright (C) Computer Science Department IV, 
d65 1
d67 1
a67 2
int     pk_sendspace = 1024 * 2 + 8;
int     pk_recvspace = 1024 * 2 + 8;
d69 4
a72 1
struct pklcd_q pklcd_q = {&pklcd_q, &pklcd_q};
d75 10
a84 10
/*	  mask, shift value */
	{ 0xf0, 0x4 },
	{ 0xf,  0x0 },
	{ 0x80, 0x7 },
	{ 0x40, 0x6 },
	{ 0x30, 0x4 },
	{ 0xe0, 0x5 },
	{ 0x10, 0x4 },
	{ 0xe,  0x1 },
	{ 0x1,  0x0 }
d88 8
a95 5
/* 
 *  Attach X.25 protocol to socket, allocate logical channel descripter
 *  and buffer space, and enter LISTEN state if we are to accept
 *  IN-COMMING CALL packets.  
 *
d99 2
a100 2
pk_attach (so)
struct socket *so;
d103 1
a103 2
	register int error = ENOBUFS;
	int pk_output ();
d105 1
a105 1
	MALLOC(lcp, struct pklcd *, sizeof (*lcp), M_PCB, M_NOWAIT);
d107 4
a110 4
		bzero ((caddr_t)lcp, sizeof (*lcp));
		insque (&lcp -> lcd_q, &pklcd_q);
		lcp -> lcd_state = READY;
		lcp -> lcd_send = pk_output;
d112 4
a115 4
			error = soreserve (so, pk_sendspace, pk_recvspace);
			lcp -> lcd_so = so;
			if (so -> so_options & SO_ACCEPTCONN)
				lcp -> lcd_state = LISTEN;
d117 1
a117 1
			sbreserve (&lcp -> lcd_sb, pk_sendspace);
d120 2
a121 2
		so -> so_pcb = lcp;
		so -> so_error = error;
d126 2
a127 2
/* 
 *  Disconnect X.25 protocol from socket.
d129 3
a131 3

pk_disconnect (lcp)
register struct pklcd *lcp;
d133 1
a133 1
	register struct socket *so = lcp -> lcd_so;
d136 3
a138 3
	switch (lcp -> lcd_state) {
	case LISTEN: 
		for (p = 0, l = pk_listenhead; l && l != lcp; p = l, l = l -> lcd_listen);
d141 4
a144 6
				pk_listenhead = l -> lcd_listen;
		}
		else
		if (l != 0)
			p -> lcd_listen = l -> lcd_listen;
		pk_close (lcp);
d147 3
a149 3
	case READY: 
		pk_acct (lcp);
		pk_close (lcp);
d152 2
a153 2
	case SENT_CLEAR: 
	case RECEIVED_CLEAR: 
d156 2
a157 2
	default: 
		pk_acct (lcp);
d159 2
a160 2
			soisdisconnecting (so);
			sbflush (&so -> so_rcv);
d162 1
a162 1
		pk_clear (lcp, 241, 0); /* Normal Disconnect */
d167 3
a169 3
/* 
 *  Close an X.25 Logical Channel. Discard all space held by the
 *  connection and internal descriptors. Wake up any sleepers.
d172 3
a174 2
pk_close (lcp)
struct pklcd *lcp;
d176 1
a176 1
	register struct socket *so = lcp -> lcd_so;
d185 1
a185 1
	 * and if that's the case we'll mark the lcp as zombie and 
d188 3
a190 3
	
	if (so && so -> so_snd.sb_flags & SB_LOCK)
		lcp -> lcd_state = LCN_ZOMBIE;
d192 1
a192 1
		pk_freelcd (lcp);
d197 5
a201 3
	so -> so_pcb = 0;
	soisdisconnected (so);
	/* sofree (so);	/* gak!!! you can't do that here */
d204 6
a209 6
/* 
 *  Create a template to be used to send X.25 packets on a logical
 *  channel. It allocates an mbuf and fills in a skeletal packet
 *  depending on its type. This packet is passed to pk_output where
 *  the remainer of the packet is filled in.
*/
d212 2
a213 2
pk_template (lcn, type)
int lcn, type;
d218 1
a218 1
	MGETHDR (m, M_DONTWAIT, MT_HEADER);
d220 2
a221 2
		panic ("pk_template");
	m -> m_act = 0;
d228 2
a229 2
	m -> m_data += max_linkhdr;
	m -> m_pkthdr.len = m -> m_len = PKHEADERLN;
d231 5
a235 5
	xp = mtod (m, struct x25_packet *);
	*(long *)xp = 0;		/* ugly, but fast */
/*	xp -> q_bit = 0;*/
	X25SBITS(xp -> bits, fmt_identifier, 1);
/*	xp -> lc_group_number = 0;*/
d238 1
a238 1
	xp -> packet_type = type;
d243 4
a246 5
/* 
 *  This routine restarts all the virtual circuits. Actually,
 *  the virtual circuits are not "restarted" as such. Instead,
 *  any active switched circuit is simply returned to READY
 *  state.
d249 4
a252 3
pk_restart (pkp, restart_cause)
register struct pkcb *pkp;
int restart_cause;
d256 1
a256 1
	register int i;
d259 1
a259 1
	if (pkp -> pk_chan == 0)
d268 6
a273 6
	if (!(pkp -> pk_dxerole & DTE_CONNECTPENDING)) {
		for (i = 1; i <= pkp -> pk_maxlcn; ++i)
			if ((lcp = pkp -> pk_chan[i]) != NULL) {
				if (lcp -> lcd_so) {
					lcp -> lcd_so -> so_error = ENETRESET;
					pk_close (lcp);
d275 4
a278 4
					pk_flush (lcp);
					lcp -> lcd_state = READY;
					if (lcp -> lcd_upper)
						lcp -> lcd_upper (lcp, 0);
a281 1

d285 8
a292 8
	pkp -> pk_state = DTE_SENT_RESTART;
	pkp -> pk_dxerole &= ~(DTE_PLAYDCE | DTE_PLAYDTE);
	lcp = pkp -> pk_chan[0];
	m = lcp -> lcd_template = pk_template (lcp -> lcd_lcn, X25_RESTART);
	m -> m_pkthdr.len = m -> m_len += 2;
	mtod (m, struct x25_packet *) -> packet_data = 0;	/* DTE only */
	mtod (m, octet *)[4]  = restart_cause;
	pk_output (lcp);
d296 2
a297 2
/* 
 *  This procedure frees up the Logical Channel Descripter.
d300 3
a302 2
pk_freelcd (lcp)
register struct pklcd *lcp;
d307 2
a308 2
	if (lcp -> lcd_lcn > 0)
		lcp -> lcd_pkp -> pk_chan[lcp -> lcd_lcn] = NULL;
d310 3
a312 3
	pk_flush (lcp);
	remque (&lcp -> lcd_q);
	free ((caddr_t)lcp, M_PCB);
d316 1
a316 1
pk_ifwithaddr (sx)
d319 2
a320 2
	struct ifnet *ifp;
	struct ifaddr *ifa;
d322 1
a322 1
	char *addr = sx -> x25_addr;
d326 4
a329 4
		    ifa = ifa->ifa_list.tqe_next)
			if (ifa -> ifa_addr -> sa_family == AF_CCITT) {
				ia = (struct x25_ifaddr *)ifa;
				if (bcmp (addr, ia -> ia_xc.xc_addr.x25_addr,
d332 1
a332 1
				
d334 1
a334 1
	return ((struct x25_ifaddr *)0);
d338 3
a340 4
/* 
 *  Bind a address and protocol value to a socket.  The important
 *  part is the protocol value - the first four characters of the 
 *  Call User Data field.
d343 3
a345 3
#define XTRACTPKP(rt)	((rt) -> rt_flags & RTF_GATEWAY ? \
			 ((rt) -> rt_llinfo ? \
			  (struct pkcb *) ((struct rtentry *)((rt) -> rt_llinfo)) -> rt_llinfo : \
d347 1
a347 1
			 (struct pkcb *)((rt) -> rt_llinfo))
d349 4
a352 3
pk_bind (lcp, nam)
struct pklcd *lcp;
struct mbuf *nam;
d359 1
a359 1
	if (lcp -> lcd_ceaddr)				/* XXX */
d361 1
a361 1
	if (pk_checksockaddr (nam))
d363 1
a363 1
	sa = mtod (nam, struct sockaddr_x25 *);
d370 2
a371 2
	if (sa -> x25_addr[0]) {
		if (!pk_ifwithaddr (sa))
d373 2
a374 2
	} else if (sa -> x25_net) {
		if (!ifa_ifwithnet ((struct sockaddr *)sa))
a376 1

d380 7
a386 7
	for (pp = pk_listenhead; pp; pp = pp -> lcd_listen) {
		register struct sockaddr_x25 *sa2 = pp -> lcd_ceaddr;
		if ((sa2 -> x25_udlen == sa -> x25_udlen) &&
		    (sa2 -> x25_udlen == 0 ||
		     (bcmp (sa2 -> x25_udata, sa -> x25_udata,
			    min (sa2 -> x25_udlen, sa -> x25_udlen)) == 0)))
				return (EADDRINUSE);
d388 2
a389 2
	lcp -> lcd_laddr = *sa;
	lcp -> lcd_ceaddr = &lcp -> lcd_laddr;
d396 3
a398 2
pk_listen (lcp)
register struct pklcd *lcp;
d402 1
a402 1
	if (lcp -> lcd_ceaddr == 0)
d405 1
a405 1
	lcp -> lcd_state = LISTEN;
d409 3
a411 3
	if (lcp -> lcd_ceaddr -> x25_udlen == 0) {
		for (pp = &pk_listenhead; *pp; )
			pp = &((*pp) -> lcd_listen);
d414 1
a414 1
		lcp -> lcd_listen = pk_listenhead;
d419 1
d423 5
a427 2
pk_protolisten (spi, spilen, callee)
int (*callee) ();
d429 1
a429 1
	register struct pklcd *lcp = pk_attach ((struct socket *)0);
d432 1
a432 1
	int error = ENOBUFS;
d435 11
a445 11
		if (nam = m_getclr (M_DONTWAIT, MT_SONAME)) {
			sa = mtod (nam, struct sockaddr_x25 *);
			sa -> x25_family = AF_CCITT;
			sa -> x25_len = nam -> m_len = sizeof (*sa);
			sa -> x25_udlen = spilen;
			sa -> x25_udata[0] = spi;
			lcp -> lcd_upper = callee;
			lcp -> lcd_flags = X25_MBS_HOLD;
			if ((error = pk_bind (lcp, nam)) == 0)
				error = pk_listen (lcp);
			(void) m_free (nam);
d448 1
a448 1
			pk_freelcd (lcp);
d450 1
a450 1
	return error; /* Hopefully Zero !*/
d460 5
a464 4
pk_assoc (pkp, lcp, sa)
register struct pkcb *pkp;
register struct pklcd *lcp;
register struct sockaddr_x25 *sa;
d467 5
a471 5
	lcp -> lcd_pkp = pkp;
	lcp -> lcd_packetsize = pkp -> pk_xcp -> xc_psize;
	lcp -> lcd_windowsize = pkp -> pk_xcp -> xc_pwsize;
	lcp -> lcd_rsn = MODULUS - 1;
	pkp -> pk_chan[lcp -> lcd_lcn] = lcp;
d473 2
a474 2
	if (sa -> x25_opts.op_psize)
		lcp -> lcd_packetsize = sa -> x25_opts.op_psize;
d476 3
a478 3
		sa -> x25_opts.op_psize = lcp -> lcd_packetsize;
	if (sa -> x25_opts.op_wsize)
		lcp -> lcd_windowsize = sa -> x25_opts.op_wsize;
d480 4
a483 4
		sa -> x25_opts.op_wsize = lcp -> lcd_windowsize;
	sa -> x25_net = pkp -> pk_xcp -> xc_addr.x25_net;
	lcp -> lcd_flags |= sa -> x25_opts.op_flags;
	lcp -> lcd_stime = time.tv_sec;
d486 4
a489 3
pk_connect (lcp, sa)
register struct pklcd *lcp;
register struct sockaddr_x25 *sa;
d495 1
a495 4
	struct rtentry *npaidb_enter ();
	struct pkcb *pk_newlink ();

	if (sa -> x25_addr[0] == '\0')
d501 1
a501 1
	if (!(rt = rtalloc1 ((struct sockaddr *)sa, 1)))
d505 1
a505 1
		pkp = pk_newlink ((struct x25_ifaddr *) (rt -> rt_ifa), 
d511 3
a513 2
	if (nrt = npaidb_enter (rt -> rt_gateway, rt_key (rt), rt, 0))
		pkp -> pk_llrt = nrt;
d518 1
a518 1
	if (pkp -> pk_llnext == (caddr_t)0 && pkp -> pk_llctlinput) {
d523 9
a531 9
		ctlinfo.dlcti_conf = 
			(struct dllconfig *) (&((struct x25_ifaddr *)(rt -> rt_ifa)) -> ia_xc);
		pkp -> pk_llnext = 
			(pkp -> pk_llctlinput) (PRC_CONNECT_REQUEST, 0, &ctlinfo);
	}

	if (pkp -> pk_state != DTE_READY && pkp -> pk_state != DTE_WAITING)
			return (ENETDOWN);
	if ((lcp -> lcd_lcn = pk_getlcn (pkp)) == 0)
d534 3
a536 3
	lcp -> lcd_faddr = *sa;
	lcp -> lcd_ceaddr = & lcp -> lcd_faddr;
	pk_assoc (pkp, lcp, lcp -> lcd_ceaddr);
d541 5
a545 5
	if (pkp -> pk_state == DTE_WAITING) {
		pkp -> pk_dxerole |= DTE_CONNECTPENDING;
		pk_ctlinput (PRC_LINKUP, (struct sockaddr *)0, pkp);
		if (lcp -> lcd_so)
			soisconnecting (lcp -> lcd_so);
d548 5
a552 6

	if (lcp -> lcd_so)
		soisconnecting (lcp -> lcd_so);
	lcp -> lcd_template = pk_template (lcp -> lcd_lcn, X25_CALL);
	pk_callrequest (lcp, lcp -> lcd_ceaddr, pkp -> pk_xcp);
	return (*pkp -> pk_ia -> ia_start) (lcp);
d561 2
a562 1
pk_callcomplete (pkp)
d566 2
a567 7
	register int i;
	register int ni;
	

	if (pkp -> pk_dxerole & DTE_CONNECTPENDING) 
		pkp -> pk_dxerole &= ~DTE_CONNECTPENDING;
	else return;
d569 4
a572 1
	if (pkp -> pk_chan == 0)
d574 4
a577 1
	
d582 9
a590 9
	 *			        	  	      
         *             /+---------------+--------     -	      
	 *            / | a  (maxlcn-1) |              \      
	 *           /  +---------------+              	\     
	 *     +--- *   | b  (maxlcn-2) |         	 \    
	 *     |     \  +---------------+         	  \   
	 *   r |      \ | c  (maxlcn-3) |         	   \  
	 *   e |       \+---------------+         	    | 
	 *   s |        |	 .                	    |  
d597 1
a597 1
	 *     |     /  +---------------+         	    | 
d599 8
a606 8
	 *           \  +---------------+         	  / 
	 *            \ | a' (   1    ) |         	 /  
    	 *             \+---------------+               /   
         *              | 0             |              /    
	 *              +---------------+--------     -     
	 *	    
	 */	    
	if (pkp -> pk_dxerole & DTE_PLAYDCE) {
d608 6
a613 6
		for (i = pkp -> pk_maxlcn; i > 0; --i)
			if (pkp -> pk_chan[i]) {
				ni = RESHUFFLELCN(pkp -> pk_maxlcn, i);
				pkp -> pk_chan[ni] = pkp -> pk_chan[i];
				pkp -> pk_chan[i] = NULL;
				pkp -> pk_chan[ni] -> lcd_lcn = ni;
d616 8
a623 8

	for (i = 1; i <= pkp -> pk_maxlcn; ++i)
		if ((lcp = pkp -> pk_chan[i]) != NULL) {
			/* if (lcp -> lcd_so)
				soisconnecting (lcp -> lcd_so); */
			lcp -> lcd_template = pk_template (lcp -> lcd_lcn, X25_CALL);
			pk_callrequest (lcp, lcp -> lcd_ceaddr, pkp -> pk_xcp);
			(*pkp -> pk_ia -> ia_start) (lcp);
d628 2
a629 2
	octet *cp;
	unsigned posn;
d631 4
a634 3
/* 
 *  Build the rest of the CALL REQUEST packet. Fill in calling
 *  address, facilities fields and the user data field.
d637 5
a641 4
pk_callrequest (lcp, sa, xcp)
struct pklcd *lcp;
register struct sockaddr_x25 *sa;
register struct x25config *xcp;
d644 8
a651 8
	register struct mbuf *m = lcp -> lcd_template;
	register struct x25_packet *xp = mtod (m, struct x25_packet *);
	struct bcdinfo b;

	if (lcp -> lcd_flags & X25_DBIT)
		X25SBITS(xp -> bits, d_bit, 1);
	a = (struct x25_calladdr *) &xp -> packet_data;
	b.cp = (octet *) a -> address_field;
d653 2
a654 2
	X25SBITS(a -> addrlens, called_addrlen, to_bcd (&b, sa, xcp));
	X25SBITS(a -> addrlens, calling_addrlen, to_bcd (&b, &xcp -> xc_addr, xcp));
d657 1
a657 1
	m -> m_pkthdr.len = m -> m_len += b.cp - (octet *) a;
d659 4
a662 4
	if (lcp -> lcd_facilities) {
		m -> m_pkthdr.len += 
			(m -> m_next = lcp -> lcd_facilities) -> m_pkthdr.len;
		lcp -> lcd_facilities = 0;
d664 1
a664 1
		pk_build_facilities (m, sa, (int)xcp -> xc_type);
d666 1
a666 1
	m_copyback (m, m -> m_pkthdr.len, sa -> x25_udlen, sa -> x25_udata);
d669 5
a673 3
pk_build_facilities (m, sa, type)
register struct mbuf *m;
struct sockaddr_x25 *sa;
d677 1
a677 1
	register int revcharge;
d679 1
a679 1
	cp = mtod (m, octet *) + m -> m_len;
d681 1
a681 1
	revcharge = sa -> x25_opts.op_flags & X25_REVERSE_CHARGE ? 1 : 0;
d686 1
a686 1
	if (type == X25_1976 && sa -> x25_opts.op_psize == X25_PS128)
d696 2
a697 2
		*fcp++ = sa -> x25_opts.op_psize;
		*fcp++ = sa -> x25_opts.op_psize;
d700 2
a701 2
		*fcp++ = sa -> x25_opts.op_wsize;
		*fcp++ = sa -> x25_opts.op_wsize;
d704 1
a704 1
	m -> m_pkthdr.len = (m -> m_len += *cp + 1);
d707 5
a711 4
to_bcd (b, sa, xcp)
register struct bcdinfo *b;
struct sockaddr_x25 *sa;
register struct x25config *xcp;
d713 2
a714 2
	register char *x = sa -> x25_addr;
	unsigned start = b -> posn;
d720 3
a722 3
	if (xcp -> xc_addr.x25_net && (xcp -> xc_nodnic || xcp -> xc_prepnd0)) {
		char dnicname[sizeof (long) * NBBY/3 + 2];
		register char *p = dnicname;
d724 2
a725 2
		sprintf (p, "%d", xcp -> xc_addr.x25_net & 0x7fff);
		for (; *p; p++) /* *p == 0 means dnic matched */
d728 5
a732 5
		if (*p || xcp -> xc_nodnic == 0)
			x = sa -> x25_addr;
		if (*p && xcp -> xc_prepnd0) {
			if ((b -> posn)++ & 0x01)
				*(b -> cp)++;
d734 1
a734 1
				*(b -> cp) = 0;
d738 2
a739 2
		if ((b -> posn)++ & 0x01)
			*(b -> cp)++ |= *x++ & 0x0F;
d741 2
a742 2
			*(b -> cp) = *x++ << 4;
	return ((b -> posn) - start);
d745 4
a748 5
/* 
 *  This routine gets the  first available logical channel number.  The
 *  search is 
 *  		- from the highest number to lowest number if playing DTE, and
 *		- from lowest to highest number if playing DCE.
d751 3
a753 2
pk_getlcn (pkp)
register struct pkcb *pkp;
d755 1
a755 1
	register int i;
d757 1
a757 1
	if (pkp -> pk_chan == 0)
d759 3
a761 3
	if ( pkp -> pk_dxerole & DTE_PLAYDCE ) {
		for (i = 1; i <= pkp -> pk_maxlcn; ++i)
			if (pkp -> pk_chan[i] == NULL)
d763 3
a765 3
	} else { 
		for (i = pkp -> pk_maxlcn; i > 0; --i)
			if (pkp -> pk_chan[i] == NULL)
d768 1
a768 1
	i = ( i > pkp -> pk_maxlcn ? 0 : i );
d772 21
a792 18
/* 
 *  This procedure sends a CLEAR request packet. The lc state is
 *  set to "SENT_CLEAR". 
 */

pk_clear (lcp, diagnostic, abortive)
register struct pklcd *lcp;
{
	register struct mbuf *m = pk_template (lcp -> lcd_lcn, X25_CLEAR);

	m -> m_len += 2;
	m -> m_pkthdr.len += 2;
	mtod (m, struct x25_packet *) -> packet_data = 0;
	mtod (m, octet *)[4] = diagnostic;
	if (lcp -> lcd_facilities) {
		m -> m_next = lcp -> lcd_facilities;
		m -> m_pkthdr.len += m -> m_next -> m_len;
		lcp -> lcd_facilities = 0;
d795 1
a795 1
		lcp -> lcd_template = m;
d797 3
a799 3
		struct socket *so = lcp -> lcd_so;
		struct sockbuf *sb = so ? & so -> so_snd : & lcp -> lcd_sb;
		sbappendrecord (sb, m);
d801 1
a801 1
	pk_output (lcp);
d808 1
a808 1
 * vice versa), or if forced to generate one.  One forces RNR's to ack data.  
d810 5
a814 2
pk_flowcontrol (lcp, inhibit, forced)
register struct pklcd *lcp;
d817 2
a818 2
	if (lcp == 0 || lcp -> lcd_state != DATA_TRANSFER ||
	    (forced == 0 && lcp -> lcd_rxrnr_condition == inhibit))
d820 4
a823 4
	lcp -> lcd_rxrnr_condition = inhibit;
	lcp -> lcd_template =
		pk_template (lcp -> lcd_lcn, inhibit ? X25_RNR : X25_RR);
	pk_output (lcp);
d826 3
a828 3
/* 
 *  This procedure sends a RESET request packet. It re-intializes
 *  virtual circuit.
d831 4
a834 3
static
pk_reset (lcp, diagnostic)
register struct pklcd *lcp;
d837 1
a837 1
	register struct socket *so = lcp -> lcd_so;
d839 1
a839 1
	if (lcp -> lcd_state != DATA_TRANSFER)
d843 2
a844 2
		so -> so_error = ECONNRESET;
	lcp -> lcd_reset_condition = TRUE;
d847 12
a858 12
	pk_flush (lcp);
	lcp -> lcd_window_condition = lcp -> lcd_rnr_condition =
		lcp -> lcd_intrconf_pending = FALSE;
	lcp -> lcd_rsn = MODULUS - 1;
	lcp -> lcd_ssn = 0;
	lcp -> lcd_output_window = lcp -> lcd_input_window =
		lcp -> lcd_last_transmitted_pr = 0;
	m = lcp -> lcd_template = pk_template (lcp -> lcd_lcn, X25_RESET);
	m -> m_pkthdr.len = m -> m_len += 2;
	mtod (m, struct x25_packet *) -> packet_data = 0;
	mtod (m, octet *)[4] = diagnostic;
	pk_output (lcp);
d866 3
a868 3

pk_flush (lcp)
register struct pklcd *lcp;
d872 2
a873 2
	if (lcp -> lcd_template)
		m_freem (lcp -> lcd_template);
d875 7
a881 3
	if (lcp -> lcd_cps) {
		m_freem (lcp -> lcd_cps);
		lcp -> lcd_cps = 0;
d883 4
a886 8
	if (lcp -> lcd_facilities) {
		m_freem (lcp -> lcd_facilities);
		lcp -> lcd_facilities = 0;
	}
	if (so = lcp -> lcd_so) 
		sbflush (&so -> so_snd);
	else 
		sbflush (&lcp -> lcd_sb);
d889 2
a890 2
/* 
 *  This procedure handles all local protocol procedure errors.
d893 6
a898 3
pk_procerror (error, lcp, errstr, diagnostic)
register struct pklcd *lcp;
char *errstr;
d901 1
a901 1
	pk_message (lcp -> lcd_lcn, lcp -> lcd_pkp -> pk_xcp, errstr);
d904 4
a907 4
	case CLEAR: 
		if (lcp -> lcd_so) {
			lcp -> lcd_so -> so_error = ECONNABORTED;
			soisdisconnecting (lcp -> lcd_so);
d909 1
a909 1
		pk_clear (lcp, diagnostic, 1);
d912 2
a913 2
	case RESET: 
		pk_reset (lcp, diagnostic);
d917 3
a919 4
/* 
 *  This procedure is called during the DATA TRANSFER state to check 
 *  and  process  the P(R) values  received  in the DATA,  RR OR RNR
 *  packets.
d922 4
a925 3
pk_ack (lcp, pr)
struct pklcd *lcp;
unsigned pr;
d927 1
a927 1
	register struct socket *so = lcp -> lcd_so;
d929 1
a929 1
	if (lcp -> lcd_output_window == pr)
d931 4
a934 4
	if (lcp -> lcd_output_window < lcp -> lcd_ssn) {
		if (pr < lcp -> lcd_output_window || pr > lcp -> lcd_ssn) {
			pk_procerror (RESET, lcp,
				"p(r) flow control error", 2);
d937 4
a940 5
	}
	else {
		if (pr < lcp -> lcd_output_window && pr > lcp -> lcd_ssn) {
			pk_procerror (RESET, lcp,
				"p(r) flow control error #2", 2);
d945 3
a947 3
	lcp -> lcd_output_window = pr;		/* Rotate window. */
	if (lcp -> lcd_window_condition == TRUE)
		lcp -> lcd_window_condition = FALSE;
d949 2
a950 2
	if (so && sb_notify (&(so -> so_snd)))
		sowwakeup (so);
d955 3
a957 3
/* 
 *  This procedure decodes the X.25 level 3 packet returning a 
 *  code to be used in switchs or arrays.
d960 3
a962 2
pk_decode (xp)
register struct x25_packet *xp;
d964 1
a964 1
	register int type;
d966 2
a967 2
	if (X25GBITS(xp -> bits, fmt_identifier) != 1)
		return (INVALID_PACKET);
d969 3
a971 3
	/* 
	 *  Make sure that the logical channel group number is 0.
	 *  This restriction may be removed at some later date.
d973 2
a974 2
	if (xp -> lc_group_number != 0)
		return (INVALID_PACKET);
d976 2
a977 2
	/* 
	 *  Test for data packet first.
d979 2
a980 2
	if (!(xp -> packet_type & DATA_PACKET_DESIGNATOR))
		return (DATA);
d982 2
a983 2
	/* 
	 *  Test if flow control packet (RR or RNR).
d985 2
a986 2
	if (!(xp -> packet_type & RR_OR_RNR_PACKET_DESIGNATOR))
		switch (xp -> packet_type & 0x1f) {
d988 1
a988 1
			return (RR);
d990 1
a990 1
			return (RNR);
d992 1
a992 1
			return (REJECT);
d995 2
a996 2
	/* 
	 *  Determine the rest of the packet types.
d998 3
a1000 3
	switch (xp -> packet_type) {
	case X25_CALL: 
		type = CALL;
d1003 2
a1004 2
	case X25_CALL_ACCEPTED: 
		type = CALL_ACCEPTED;
d1007 2
a1008 2
	case X25_CLEAR: 
		type = CLEAR;
d1011 2
a1012 2
	case X25_CLEAR_CONFIRM: 
		type = CLEAR_CONF;
d1015 2
a1016 2
	case X25_INTERRUPT: 
		type = INTERRUPT;
d1019 2
a1020 2
	case X25_INTERRUPT_CONFIRM: 
		type = INTERRUPT_CONF;
d1023 2
a1024 2
	case X25_RESET: 
		type = RESET;
d1027 2
a1028 2
	case X25_RESET_CONFIRM: 
		type = RESET_CONF;
d1031 2
a1032 2
	case X25_RESTART: 
		type = RESTART;
d1035 2
a1036 2
	case X25_RESTART_CONFIRM: 
		type = RESTART_CONF;
d1040 1
a1040 1
		type = DIAG_TYPE;
d1043 2
a1044 2
	default: 
		type = INVALID_PACKET;
d1049 2
a1050 3
/* 
 *  A restart packet has been received. Print out the reason
 *  for the restart.
d1053 4
a1056 3
pk_restartcause (pkp, xp)
struct pkcb *pkp;
register struct x25_packet *xp;
d1058 2
a1059 2
	register struct x25config *xcp = pkp -> pk_xcp;
	register int lcn = LCN(xp);
d1061 3
a1063 3
	switch (xp -> packet_data) {
	case X25_RESTART_LOCAL_PROCEDURE_ERROR: 
		pk_message (lcn, xcp, "restart: local procedure error");
d1066 2
a1067 2
	case X25_RESTART_NETWORK_CONGESTION: 
		pk_message (lcn, xcp, "restart: network congestion");
d1070 2
a1071 2
	case X25_RESTART_NETWORK_OPERATIONAL: 
		pk_message (lcn, xcp, "restart: network operational");
d1074 2
a1075 2
	default: 
		pk_message (lcn, xcp, "restart: unknown cause");
d1081 1
a1081 1
int     Reset_cause[] = {
d1085 2
a1086 2
/* 
 *  A reset packet has arrived. Return the cause to the user.
d1089 4
a1092 3
pk_resetcause (pkp, xp)
struct pkcb *pkp;
register struct x25_packet *xp;
d1095 2
a1096 2
				pkp -> pk_chan[LCN(xp)];
	register int code = xp -> packet_data;
d1101 6
a1106 5
	pk_message (LCN(xp), lcp -> lcd_pkp, "reset code 0x%x, diagnostic 0x%x",
			xp -> packet_data, 4[(u_char *)xp]);
			
	if (lcp -> lcd_so)
		lcp -> lcd_so -> so_error = Reset_cause[code];
d1111 1
a1111 1
int     Clear_cause[] = {
d1117 2
a1118 2
/* 
 *  A clear packet has arrived. Return the cause to the user.
d1120 4
a1123 4

pk_clearcause (pkp, xp)
struct pkcb *pkp;
register struct x25_packet *xp;
d1126 2
a1127 2
		pkp -> pk_chan[LCN(xp)];
	register int code = xp -> packet_data;
d1131 2
a1132 2
	if (lcp -> lcd_so)
		lcp -> lcd_so -> so_error = Clear_cause[code];
d1136 2
a1137 2
format_ntn (xcp)
register struct x25config *xcp;
d1140 1
a1140 1
	return (xcp -> xc_addr.x25_addr);
d1144 10
a1153 3
pk_message (lcn, xcp, fmt, a1, a2, a3, a4, a5, a6)
struct x25config *xcp;
char *fmt;
d1155 2
d1160 1
a1160 1
			printf ("X.25(%s): lcn %d: ", format_ntn (xcp), lcn);
d1162 3
a1164 1
			printf ("X.25: lcn %d: ", lcn);
d1166 1
a1166 4
		if (!PQEMPTY)
			printf ("X.25(%s): ", format_ntn (xcp));
		else
			printf ("X.25: ");
d1168 3
a1170 2
	printf (fmt, a1, a2, a3, a4, a5, a6);
	printf ("\n");
d1173 5
a1177 3
pk_fragment (lcp, m0, qbit, mbit, wait)
struct mbuf *m0;
register struct pklcd *lcp;
d1182 2
a1183 2
	struct mbuf *head = 0, *next, **mp = &head, *m_split ();
	int totlen, psize = 1 << (lcp -> lcd_packetsize);
d1187 5
a1191 5
	if (m -> m_flags & M_PKTHDR == 0)
		panic ("pk_fragment");
	totlen = m -> m_pkthdr.len;
	m -> m_act = 0;
	sb = lcp -> lcd_so ? &lcp -> lcd_so -> so_snd : & lcp -> lcd_sb;
d1194 1
a1194 1
			if ((next = m_split (m, psize, wait)) == 0)
d1203 1
a1203 1
		mp = & m -> m_act;
d1205 2
a1206 2
		xp = mtod (m, struct x25_packet *);
		0[(char *)xp] = 0;
d1208 6
a1213 6
			X25SBITS(xp -> bits, q_bit, 1);
		if (lcp -> lcd_flags & X25_DBIT)
			X25SBITS(xp -> bits, d_bit, 1);
		X25SBITS(xp -> bits, fmt_identifier, 1);
		xp -> packet_type = X25_DATA;
		SET_LCN(xp, lcp -> lcd_lcn);
d1215 1
a1215 1
				      (lcp -> lcd_flags & X25_DBIT))))
d1217 1
a1217 1
	} while (m = next);
d1219 3
a1221 3
		next = m -> m_act;
		m -> m_act = 0;
		sbappendrecord (sb, m);
d1226 1
a1226 1
		panic ("pk_fragment null mbuf after wait");
d1228 1
a1228 1
		m_freem (next);
d1230 2
a1231 2
		next = m -> m_act;
		m_freem (m);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
