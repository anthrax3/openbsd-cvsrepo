head	1.23;
access;
symbols
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.19.0.6
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.13
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2007.06.06.10.05.48;	author henning;	state dead;
branches;
next	1.22;

1.22
date	2006.06.15.10.08.34;	author pascoe;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.20.23.10.47;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.16;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.03.21.16.30;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.18.07.46.56;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.23.10.22.13;	author mickey;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.05.27.12.16.01;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.20.08.36.02;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.23.07.33.47;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.15.18.49.49;	author fgsch;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.01.13.05.52.42;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.11.19.31.56;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.12.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.26.09.34.51;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.10.18.14.28.22;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.08.16.09.16.00;	author mickey;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.40.21;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.55.30;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.05.19.22.41.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@bye bye
most of the IPX removal work done @@ calgary airport
@
text
@/*	$OpenBSD: ipx_ip.c,v 1.22 2006/06/15 10:08:34 pascoe Exp $	*/

/*-
 *
 * Copyright (c) 1996 Michael Shalayeff
 * Copyright (c) 1995, Mike Mitchell
 * Copyright (c) 1984, 1985, 1986, 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ipx_ip.c
 *
 * from FreeBSD Id: ipx_ip.c,v 1.7 1996/03/11 15:13:50 davidg Exp
 */

/*
 * Software interface driver for encapsulating IPX in IP.
 */

#ifdef IPXIP
#ifndef INET
#error The option IPXIP requires option INET.
#endif

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/protosw.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#include <netipx/ipx_ip.h>

#include <sys/stdarg.h>

struct ifnet ipxipif;
struct ifnet_en *ipxip_list; /* list of all hosts and gateways or broadcast addrs */

void
ipxipprotoinit(void)
{
	(void) ipxipattach();
}

struct ifnet_en *
ipxipattach(void)
{
	struct ifnet_en *m;
	struct ifnet *ifp;

	if (ipxipif.if_mtu == 0) {
		ifp = &ipxipif;
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "ipx0");
		ifp->if_mtu = LOMTU;
		ifp->if_ioctl = ipxipioctl;
		ifp->if_output = ipxipoutput;
		ifp->if_start = ipxipstart;
		ifp->if_flags = IFF_POINTOPOINT;
		ifp->if_type = IFT_NSIP;
	}

	MALLOC((m), struct ifnet_en *, sizeof(*m), M_PCB, M_NOWAIT);
	if (m == NULL)
		return (NULL);
	bzero(m, sizeof(*m));
	m->ifen_next = ipxip_list;
	ipxip_list = m;
	ifp = &m->ifen_ifnet;

	snprintf(ifp->if_xname, sizeof ifp->if_xname, "ipx0");
	ifp->if_mtu = LOMTU;
	ifp->if_ioctl = ipxipioctl;
	ifp->if_output = ipxipoutput;
	ifp->if_start = ipxipstart;
	ifp->if_flags = IFF_POINTOPOINT;
	if_attach(ifp);

	return (m);
}


/*
 * Process an ioctl request.
 */
/* ARGSUSED */
int
ipxipioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	int error = 0;
	struct ifreq *ifr;

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */

	case SIOCSIFDSTADDR:
		/*
		 * Everything else is done at a higher level.
		 */
		break;

	case SIOCSIFFLAGS:
		ifr = (struct ifreq *)data;
		if ((ifr->ifr_flags & IFF_UP) == 0)
			error = ipxip_free(ifp);

	default:
		error = EINVAL;
	}
	return (error);
}

struct mbuf *ipxip_badlen;

void
ipxip_input( struct mbuf *m, ...)
{
	struct ifnet *ifp;
	struct ip *ip;
	struct ipx *ipx;
	struct ifqueue *ifq = &ipxintrq;
	int len, s;
	va_list	ap;

	va_start(ap, m);
	ifp = va_arg(ap, struct ifnet *);
	va_end(ap);

	/*
	 * Get IP and IPX header together in first mbuf.
	 */
	ipxipif.if_ipackets++;
	s = sizeof(struct ip) + sizeof(struct ipx);
	if (((m->m_flags & M_EXT) || m->m_len < s) &&
	    (m = m_pullup(m, s)) == NULL) {
		ipxipif.if_ierrors++;
		return;
	}
	ip = mtod(m, struct ip *);
	if (ip->ip_hl > (sizeof(struct ip) >> 2)) {
		ip_stripoptions(m, (struct mbuf *)0);
		if (m->m_len < s) {
			if ((m = m_pullup(m, s)) == NULL) {
				ipxipif.if_ierrors++;
				return;
			}
			ip = mtod(m, struct ip *);
		}
	}

	/*
	 * Make mbuf data length reflect IPX length.
	 * If not enough data to reflect IPX length, drop.
	 */
	m->m_data += sizeof(struct ip);
	m->m_len -= sizeof(struct ip);
	m->m_pkthdr.len -= sizeof(struct ip);
	ipx = mtod(m, struct ipx *);
	len = ntohs(ipx->ipx_len);
	if (len & 1)
		len++;		/* Preserve Garbage Byte */
	if (ntohs(ip->ip_len) - (ip->ip_hl << 2) != len) {
		if (len > ntohs(ip->ip_len) - (ip->ip_hl << 2)) {
			ipxipif.if_ierrors++;
			if (ipxip_badlen)
				m_freem(ipxip_badlen);
			ipxip_badlen = m;
			return;
		}
		/* Any extra will be trimmed off by the IPX routines */
	}

	/*
	 * Place interface pointer before the data
	 * for the receiving protocol.
	 */
	m->m_pkthdr.rcvif = ifp;
	/*
	 * Deliver to IPX
	 */
	s = splnet();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
		splx(s);
		return;
	}
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IPX);
	splx(s);
	return;
}

/* ARGSUSED */
int
ipxipoutput(ifp, m, dst, rt)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr *dst;
	struct rtentry *rt;
{
	struct ifnet_en *ifn = (struct ifnet_en *)ifp;
	struct ip *ip;
	struct route *ro = &(ifn->ifen_route);
	int len = 0;
	struct ipx *ipx = mtod(m, struct ipx *);
	int error;

	ifn->ifen_ifnet.if_opackets++;
	ipxipif.if_opackets++;

	/*
	 * Calculate data length and make space
	 * for IP header.
	 */
	len =  ntohs(ipx->ipx_len);
	if (len & 1)
		len++;		/* Preserve Garbage Byte */
	/* following clause not necessary on vax */
	if (3 & (long)m->m_data) {
		/* force longword alignment of ip hdr */
		struct mbuf *m0 = m_gethdr(M_DONTWAIT, MT_HEADER);
		if (m0 == NULL) {
			m_freem(m);
			return (ENOBUFS);
		}
		MH_ALIGN(m0, sizeof(struct ip));
		m0->m_flags = m->m_flags & M_COPYFLAGS;
		m0->m_next = m;
		m0->m_len = sizeof(struct ip);
		m0->m_pkthdr.len = m0->m_len + m->m_len;
		m0->m_pkthdr.tags = m->m_pkthdr.tags;
		m->m_flags &= ~M_PKTHDR;
		m_tag_init(m);
	} else {
		M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
		if (m == NULL)
			return (ENOBUFS);
	}
	/*
	 * Fill in IP header.
	 */
	ip = mtod(m, struct ip *);
	*(long *)ip = 0;
	ip->ip_p = IPPROTO_IDP;
	ip->ip_src = ifn->ifen_src;
	ip->ip_dst = ifn->ifen_dst;
	if (len + sizeof(struct ip) > IP_MAXPACKET) {
		m_freem(m);
		return EMSGSIZE;
	}
	ip->ip_len = htons(len + sizeof(struct ip));
	ip->ip_ttl = MAXTTL;

	/*
	 * Output final datagram.
	 */
	error = ip_output(m, NULL, ro, SO_BROADCAST, NULL, NULL);
	if (error) {
		ifn->ifen_ifnet.if_oerrors++;
		ifn->ifen_ifnet.if_ierrors = error;
	}
	return (error);
}

void
ipxipstart(ifp)
	struct ifnet *ifp;
{
	panic("ipxip_start called");
}

struct ifreq ifr_ipxip = {"ipx0"};

int
ipxip_route(m)
	struct mbuf *m;
{
	struct ipxip_req *rq = mtod(m, struct ipxip_req *);
	struct sockaddr_ipx *ipx_dst = (struct sockaddr_ipx *)&rq->rq_ipx;
	struct sockaddr_in *ip_dst = (struct sockaddr_in *)&rq->rq_ip;
	struct route ro;
	struct ifnet_en *ifn;
	struct sockaddr_in *src;

	/*
	 * First, make sure we already have an IPX address.
	 */
	if (TAILQ_EMPTY(&ipx_ifaddr))
		return (EADDRNOTAVAIL);
	/*
	 * Now, determine if we can get to the destination
	 */
	bzero((caddr_t)&ro, sizeof(ro));
	ro.ro_dst = *(struct sockaddr *)ip_dst;
	rtalloc(&ro);
	if (ro.ro_rt == NULL || ro.ro_rt->rt_ifp == NULL) {
		return (ENETUNREACH);
	}

	/*
	 * And see how he's going to get back to us:
	 * i.e., what return ip address do we use?
	 */
	{
		struct in_ifaddr *ia;
		struct ifnet *ifp = ro.ro_rt->rt_ifp;

		TAILQ_FOREACH(ia, &in_ifaddr, ia_list)
			if (ia->ia_ifp == ifp)
				break;
		if (ia == NULL)
			ia = TAILQ_FIRST(&in_ifaddr);
		if (ia == NULL) {
			RTFREE(ro.ro_rt);
			return (EADDRNOTAVAIL);
		}
		src = (struct sockaddr_in *)&ia->ia_addr;
	}

	/*
	 * Is there a free (pseudo-)interface or space?
	 */
	for (ifn = ipxip_list; ifn; ifn = ifn->ifen_next) {
		if ((ifn->ifen_ifnet.if_flags & IFF_UP) == 0)
			break;
	}
	if (ifn == NULL)
		ifn = ipxipattach();
	if (ifn == NULL) {
		RTFREE(ro.ro_rt);
		return (ENOBUFS);
	}
	ifn->ifen_route = ro;
	ifn->ifen_dst =  ip_dst->sin_addr;
	ifn->ifen_src = src->sin_addr;

	/*
	 * now configure this as a point to point link
	 */
	ifr_ipxip.ifr_dstaddr = * (struct sockaddr *) ipx_dst;
	ipx_control((struct socket *)0, (int)SIOCSIFDSTADDR,
		(caddr_t)&ifr_ipxip, (struct ifnet *)ifn);

	satoipx_addr(ifr_ipxip.ifr_addr).ipx_host =
	    TAILQ_FIRST(&ipx_ifaddr)->ia_addr.sipx_addr.ipx_host;

	return (ipx_control((struct socket *)0, (int)SIOCSIFADDR,
			(caddr_t)&ifr_ipxip, (struct ifnet *)ifn));
}

int
ipxip_free(ifp)
	struct ifnet *ifp;
{
	struct ifnet_en *ifn = (struct ifnet_en *)ifp;
	struct route *ro = & ifn->ifen_route;

	if (ro->ro_rt) {
		RTFREE(ro->ro_rt);
		ro->ro_rt = NULL;
	}
	ifp->if_flags &= ~IFF_UP;
	return (0);
}

void *
ipxip_ctlinput(cmd, sa, dummy)
	int cmd;
	struct sockaddr *sa;
	void *dummy;
{
	struct sockaddr_in *sin;

	if ((unsigned)cmd >= PRC_NCMDS)
		return NULL;
	if (sa->sa_family != AF_INET && sa->sa_family != AF_IMPLINK)
		return NULL;
	sin = (struct sockaddr_in *)sa;
	if (sin->sin_addr.s_addr == INADDR_ANY)
		return NULL;

	switch (cmd) {

	case PRC_ROUTEDEAD:
	case PRC_REDIRECT_NET:
	case PRC_REDIRECT_HOST:
	case PRC_REDIRECT_TOSNET:
	case PRC_REDIRECT_TOSHOST:
		ipxip_rtchange(&sin->sin_addr);
		break;
	}
	return NULL;
}

void
ipxip_rtchange(dst)
	struct in_addr *dst;
{
	struct ifnet_en *ifn;

	for (ifn = ipxip_list; ifn; ifn = ifn->ifen_next) {
		if (ifn->ifen_dst.s_addr == dst->s_addr &&
		    ifn->ifen_route.ro_rt) {
			RTFREE(ifn->ifen_route.ro_rt);
			ifn->ifen_route.ro_rt = NULL;
		}
	}
}
#endif /* IPXIP */
@


1.22
log
@Make number of varargs passed to ip_output match reality.

henning@@ claudio@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.21 2006/03/05 21:48:57 miod Exp $	*/
@


1.21
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.20 2006/03/04 22:40:16 brad Exp $	*/
d303 1
a303 1
	error = ip_output(m, NULL, ro, SO_BROADCAST, NULL, NULL, NULL);
@


1.20
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.19 2004/09/20 23:10:47 drahn Exp $	*/
d334 1
a334 1
	if (ipx_ifaddr.tqh_first == NULL)
d354 1
a354 1
		for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next)
d358 1
a358 1
			ia = in_ifaddr.tqh_first;
d391 1
a391 1
	    ipx_ifaddr.tqh_first->ia_addr.sipx_addr.ipx_host;
@


1.19
log
@Fix order of operations for m_gethdr(), found a bit ago, commit after second
prodding.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.18 2004/01/03 14:08:54 espie Exp $	*/
d226 1
a226 1
	s = splimp();
@


1.18
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.17 2003/12/10 07:22:43 itojun Exp $	*/
d267 1
a267 1
		struct mbuf *m0 = m_gethdr(MT_HEADER, M_DONTWAIT);
@


1.17
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.16 2003/07/09 22:03:16 itojun Exp $	*/
d74 1
a74 1
#include <machine/stdarg.h>
@


1.16
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.15 2003/06/02 23:28:16 millert Exp $	*/
d88 2
a89 2
	register struct ifnet_en *m;
	register struct ifnet *ifp;
d128 1
a128 1
	register struct ifnet *ifp;
d164 3
a166 3
	register struct ip *ip;
	register struct ipx *ipx;
	register struct ifqueue *ifq = &ipxintrq;
d243 1
a243 1
	register struct mbuf *m;
d247 5
a251 5
	register struct ifnet_en *ifn = (struct ifnet_en *)ifp;
	register struct ip *ip;
	register struct route *ro = &(ifn->ifen_route);
	register int len = 0;
	register struct ipx *ipx = mtod(m, struct ipx *);
d322 1
a322 1
	register struct mbuf *m;
d324 1
a324 1
	register struct ipxip_req *rq = mtod(m, struct ipxip_req *);
d351 1
a351 1
		register struct in_ifaddr *ia;
d401 1
a401 1
	register struct ifnet_en *ifn = (struct ifnet_en *)ifp;
d443 1
a443 1
	register struct in_addr *dst;
d445 1
a445 1
	register struct ifnet_en *ifn;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.14 2003/05/03 21:16:30 deraadt Exp $	*/
d207 2
a208 2
	if (ip->ip_len != len) {
		if (len > ip->ip_len) {
d293 5
a297 1
	ip->ip_len = (u_short)len + sizeof(struct ip);
@


1.14
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.13 2002/09/18 07:46:56 mickey Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@mad typo, only null can take it
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.12 2002/08/28 15:43:03 pefo Exp $	*/
d97 1
a97 1
		sprintf(ifp->if_xname, "ipx0");
d114 1
a114 1
	sprintf(ifp->if_xname, "ipx0");
@


1.12
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.11 2001/09/23 10:22:13 mickey Exp $	*/
d303 1
a303 1
	error =  (ip_output(m, (struct mbuf *)0, ro, SO_BROADCAST, (void *)NULL), (void *)NULL);
@


1.11
log
@make this compile on alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.10 2001/05/27 12:16:01 angelos Exp $	*/
d303 1
a303 1
	error =  (ip_output(m, (struct mbuf *)0, ro, SO_BROADCAST, NULL));
@


1.11.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.11 2001/09/23 10:22:13 mickey Exp $	*/
d303 1
a303 1
	error = ip_output(m, NULL, ro, SO_BROADCAST, NULL, NULL, NULL);
@


1.11.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 1
a97 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "ipx0");
d114 1
a114 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "ipx0");
@


1.10
log
@Fixup tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.9 2001/05/20 08:36:02 angelos Exp $	*/
d37 1
a37 1
 * 
d269 1
a269 1
	if (3 & (int)m->m_data) {
d392 1
a392 1
		
@


1.9
log
@Convert from tdbi to packet tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.8 2001/03/23 07:33:47 angelos Exp $	*/
d283 1
a283 1
		TAILQ_INIT(&m->m_pkthdr.tags);
@


1.8
log
@Be paranoid when copying m_pkthdr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.7 2000/01/15 18:49:49 fgsch Exp $	*/
d281 1
a281 1
		m0->m_pkthdr.tdbi = m->m_pkthdr.tdbi;
d283 1
a283 1
		m->m_pkthdr.tdbi = NULL;
@


1.7
log
@Check that INET is defined. Revove unused code. Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.6 2000/01/13 05:52:42 fgsch Exp $	*/
d281 1
d283 1
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.8 2001/03/23 07:33:47 angelos Exp $	*/
a280 1
		m0->m_pkthdr.tdbi = m->m_pkthdr.tdbi;
a281 1
		m->m_pkthdr.tdbi = NULL;
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.7.2.1 2001/05/14 22:40:21 niklas Exp $	*/
d281 1
a281 1
		m0->m_pkthdr.tags = m->m_pkthdr.tags;
d283 1
a283 1
		m_tag_init(m);
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.7.2.2 2001/07/04 10:55:30 niklas Exp $	*/
d37 1
a37 1
 *
d269 1
a269 1
	if (3 & (long)m->m_data) {
d392 1
a392 1

@


1.7.2.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d303 1
a303 1
	error = ip_output(m, NULL, ro, SO_BROADCAST, NULL, NULL, NULL);
@


1.7.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.7.2.4 2003/03/28 00:06:55 niklas Exp $	*/
d97 1
a97 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "ipx0");
d114 1
a114 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "ipx0");
@


1.7.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.7.2.5 2003/05/13 19:36:18 ho Exp $	*/
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
#include <sys/stdarg.h>
d88 2
a89 2
	struct ifnet_en *m;
	struct ifnet *ifp;
d128 1
a128 1
	struct ifnet *ifp;
d164 3
a166 3
	struct ip *ip;
	struct ipx *ipx;
	struct ifqueue *ifq = &ipxintrq;
d207 2
a208 2
	if (ntohs(ip->ip_len) - (ip->ip_hl << 2) != len) {
		if (len > ntohs(ip->ip_len) - (ip->ip_hl << 2)) {
d243 1
a243 1
	struct mbuf *m;
d247 5
a251 5
	struct ifnet_en *ifn = (struct ifnet_en *)ifp;
	struct ip *ip;
	struct route *ro = &(ifn->ifen_route);
	int len = 0;
	struct ipx *ipx = mtod(m, struct ipx *);
d293 1
a293 5
	if (len + sizeof(struct ip) > IP_MAXPACKET) {
		m_freem(m);
		return EMSGSIZE;
	}
	ip->ip_len = htons(len + sizeof(struct ip));
d318 1
a318 1
	struct mbuf *m;
d320 1
a320 1
	struct ipxip_req *rq = mtod(m, struct ipxip_req *);
d347 1
a347 1
		struct in_ifaddr *ia;
d397 1
a397 1
	struct ifnet_en *ifn = (struct ifnet_en *)ifp;
d439 1
a439 1
	struct in_addr *dst;
d441 1
a441 1
	struct ifnet_en *ifn;
@


1.6
log
@Fix compilation error introduced recently; thanks mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.5 2000/01/11 19:31:56 fgsch Exp $	*/
d48 4
d107 3
a109 1
	if (m == NULL) return (NULL);
d143 1
a143 1
		/* fall into: */
a155 1

a162 2
struct mbuf *ipxip_lastin;
int ipxip_hold_input;
a177 6
	if (ipxip_hold_input) {
		if (ipxip_lastin) {
			m_freem(ipxip_lastin);
		}
		ipxip_lastin = m_copym(m, 0, (int)M_COPYALL, M_DONTWAIT);
	}
d182 1
a182 1
	s = sizeof (struct ip) + sizeof (struct ipx);
d184 1
a184 1
	    (m = m_pullup(m, s)) == 0) {
d189 1
a189 1
	if (ip->ip_hl > (sizeof (struct ip) >> 2)) {
d192 1
a192 1
			if ((m = m_pullup(m, s)) == 0) {
d204 3
a206 3
	m->m_data += sizeof (struct ip);
	m->m_len -= sizeof (struct ip);
	m->m_pkthdr.len -= sizeof (struct ip);
d209 2
a210 1
	if (len & 1) len++;		/* Preserve Garbage Byte */
d214 2
a215 1
			if (ipxip_badlen) m_freem(ipxip_badlen);
d266 2
a267 1
	if (len & 1) len++;		/* Preserve Garbage Byte */
d272 1
a272 1
		if (m0 == 0) {
d276 1
a276 1
		MH_ALIGN(m0, sizeof (struct ip));
d279 1
a279 1
		m0->m_len = sizeof (struct ip);
d283 2
a284 2
		M_PREPEND(m, sizeof (struct ip), M_DONTWAIT);
		if (m == 0)
d295 1
a295 1
	ip->ip_len = (u_short)len + sizeof (struct ip);
d311 1
a311 1
struct ifnet *ifp;
d337 1
a337 1
	bzero((caddr_t)&ro, sizeof (ro));
d340 1
a340 1
	if (ro.ro_rt == 0 || ro.ro_rt->rt_ifp == 0) {
d397 1
a397 1
struct ifnet *ifp;
d404 1
a404 1
		ro->ro_rt = 0;
a415 1
	/*extern u_char inetctlerrmap[]; */ /*XXX*/ /*JRE*/
a416 1
	/* int in_rtchange(); */ /*XXX*/ /*JRE*/
d447 3
a449 3
			ifn->ifen_route.ro_rt) {
				RTFREE(ifn->ifen_route.ro_rt);
				ifn->ifen_route.ro_rt = 0;
d453 1
a453 1
#endif
@


1.5
log
@Remove references to ipx_thishost; instead find the address from
ipx_ifaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.4 1999/01/11 05:12:33 millert Exp $	*/
d389 1
a389 1
	    ipx_ifaddr->ia_addr.sipx_addr.x_host;
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.3 1996/10/26 09:34:51 mickey Exp $	*/
d330 1
a330 1
	 * First, make sure we already have an IPX address:
d332 1
a332 1
	if (ipx_hosteqnh(ipx_thishost, ipx_zerohost))
d387 4
a390 1
	satoipx_addr(ifr_ipxip.ifr_addr).ipx_host = ipx_thishost;
@


1.3
log
@remove my CVS tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_ip.c,v 1.1 1996/08/16 09:16:00 mickey Exp $	*/
d313 1
a313 1
	panic("ipxip_start called\n");
@


1.2
log
@-Wall happieness. bug fix caused by parens...
@
text
@a1 1
/*	$NOWHERE: ipx_ip.c,v 1.2 1996/05/07 09:49:43 mickey Exp $	*/
@


1.1
log
@initial commit of Free's netipx w/ some changes.
ip<-->ipx encapsulations does not work still.
spx suspected to do too.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a234 1
bad:
a307 3
bad:
	m_freem(m);
	return (ENETUNREACH);
@
