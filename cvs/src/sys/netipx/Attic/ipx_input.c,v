head	1.22;
access;
symbols
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.18
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.16
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.14
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.14.0.12
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.10
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.8
	OPENBSD_2_8:1.14.0.6
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2007.06.06.10.05.48;	author henning;	state dead;
branches;
next	1.21;

1.21
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.20.21.33.00;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.20.21.09.02;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.28.23.17.45;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.16;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.15.09.19.22;	author fgsch;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.01.15.07.07.17;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.15.07.02.13;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.13.07.10.36;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.13.04.41.03;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.11.21.10.34;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.11.20.56.15;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.11.20.30.13;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.11.19.31.55;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.11.01.26.21;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	96.12.23.08.47.04;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.10.26.09.34.51;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.10.18.14.28.22;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.08.16.09.15.59;	author mickey;	state Exp;
branches;
next	;

1.14.2.1
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.22
log
@bye bye
most of the IPX removal work done @@ calgary airport
@
text
@/*	$OpenBSD: ipx_input.c,v 1.21 2006/03/05 21:48:57 miod Exp $	*/

/*-
 *
 * Copyright (c) 1996 Michael Shalayeff
 * Copyright (c) 1995, Mike Mitchell
 * Copyright (c) 1984, 1985, 1986, 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ipx_input.c
 *
 * from FreeBSD Id: ipx_input.c,v 1.8 1996/03/11 15:13:48 davidg Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netipx/ipx.h>
#include <netipx/spx.h>
#include <netipx/ipx_if.h>
#include <netipx/ipx_pcb.h>
#include <netipx/ipx_var.h>

#ifndef IPXPRINTFS
#define IPXPRINTFS	1	/* printing forwarding information */
#endif

int ipxprintfs = IPXPRINTFS;
int ipxcksum = 0;
int ipxdonosocks = 0;
int ipxforwarding = 0;
int ipxnetbios = 0;

union ipx_net	ipx_zeronet;
union ipx_host	ipx_zerohost;

union ipx_net	ipx_broadnet;
union ipx_host	ipx_broadhost;

struct ipxstat ipxstat;
struct sockaddr_ipx ipx_netmask, ipx_hostmask;

static u_int16_t	allones[] = {0xffff, 0xffff, 0xffff};

#ifndef	IPXCBHASHSIZE
#define	IPXCBHASHSIZE	32
#endif
struct ipxpcbtable	ipxrawcbtable;
int			ipxrawcbhashsize = IPXCBHASHSIZE;

struct ipx_ifaddrhead	ipx_ifaddr;
struct ifqueue	ipxintrq;
int	ipxqmaxlen = IFQ_MAXLEN;

u_long	ipx_pexseq;

/*
 * IPX initialization.
 */

void
ipx_init()
{
	ipx_broadnet = * (union ipx_net *) allones;
	ipx_broadhost = * (union ipx_host *) allones;

	ipx_pexseq = arc4random();
	ipxintrq.ifq_maxlen = ipxqmaxlen;

	ipx_netmask.sipx_len = 6;
	ipx_netmask.sipx_addr.ipx_net = ipx_broadnet;

	ipx_hostmask.sipx_len = 12;
	ipx_hostmask.sipx_addr.ipx_net = ipx_broadnet;
	ipx_hostmask.sipx_addr.ipx_host = ipx_broadhost;

	ipx_pcbinit(&ipxrawcbtable, ipxrawcbhashsize);

	TAILQ_INIT(&ipx_ifaddr);
}

/*
 * IPX input routine.  Pass to next level.
 */
void
ipxintr()
{
	struct ipx *ipx;
	struct mbuf *m;
	struct ipxpcb *ipxp;
	struct ipx_ifaddr *ia;
	int len, s;

next:
	/*
	 * Get next datagram off input queue and get IPX header
	 * in first mbuf.
	 */
	s = splnet();
	IF_DEQUEUE(&ipxintrq, m);
	splx(s);
	if (m == NULL) {
		return;
	}

	ipxstat.ipxs_total++;

	if ((m->m_flags & M_EXT || m->m_len < sizeof(struct ipx)) &&
	    (m = m_pullup(m, sizeof(struct ipx))) == 0) {
		ipxstat.ipxs_toosmall++;
		goto next;
	}

	/*
	 * Give any raw listeners a crack at the packet
	 */
	CIRCLEQ_FOREACH(ipxp, &ipxrawcbtable.input_queue, ipxp_queue) {
		struct mbuf *m1 = m_copy(m, 0, (int)M_COPYALL);
		if (m1)
			ipx_input(m1, ipxp);
	}

	ipx = mtod(m, struct ipx *);
	len = ntohs(ipx->ipx_len);
	/*
	 * Check that the amount of data in the buffers
	 * is as at least much as the IPX header would have us expect.
	 * Trim mbufs if longer than we expect.
	 * Drop packet if shorter than we expect.
	 */
	if (m->m_pkthdr.len < len) {
		ipxstat.ipxs_tooshort++;
		goto bad;
	}
	if (m->m_pkthdr.len > len) {
		if (m->m_len == m->m_pkthdr.len) {
			m->m_len = len;
			m->m_pkthdr.len = len;
		} else
			m_adj(m, len - m->m_pkthdr.len);
	}
	if (ipxcksum && ipx->ipx_sum != 0xffff) {
		if (ipx->ipx_sum != ipx_cksum(m, len)) {
			ipxstat.ipxs_badsum++;
			goto bad;
		}
	}

	/*
	 * Propagated (Netbios) packets (type 20) has to be handled  
	 * different. :-(
	 */
	if (ipx->ipx_pt == IPXPROTO_NETBIOS) {
		if (ipxnetbios) {
			ipx_output_type20(m);
			goto next;
		} else
			goto bad;
	}

	/*
	 * Is this a directed broadcast?
	 */
	if (ipx_hosteqnh(ipx_broadhost,ipx->ipx_dna.ipx_host)) {
		if ((!ipx_neteq(ipx->ipx_dna, ipx->ipx_sna)) &&
		    (!ipx_neteqnn(ipx->ipx_dna.ipx_net, ipx_broadnet)) &&
		    (!ipx_neteqnn(ipx->ipx_sna.ipx_net, ipx_zeronet)) &&
		    (!ipx_neteqnn(ipx->ipx_dna.ipx_net, ipx_zeronet)) ) {
			/*
			 * If it is a broadcast to the net where it was
			 * received from, treat it as ours.
			 */
			TAILQ_FOREACH(ia, &ipx->if_addr, ia_list)
				if((ia->ia_ifa.ifa_ifp == m->m_pkthdr.rcvif) &&
				    ipx_neteq(ia->ia_addr.sipx_addr, 
				    ipx->ipx_dna))
                                       goto ours;

			/*
			 * Look to see if I need to eat this packet.
			 * Algorithm is to forward all young packets
			 * and prematurely age any packets which will
			 * by physically broadcasted.
			 * Any very old packets eaten without forwarding
			 * would die anyway.
			 *
			 * Suggestion of Bill Nesheim, Cornell U.
			 */
			if (ipx->ipx_tc < IPX_MAXHOPS) {
				ipx_forward(m);
				goto next;
			}
		}
	/*
	 * Is this our packet? If not, forward.
	 */
	} else {
		TAILQ_FOREACH(ia, &ipx_ifaddr, ia_list)
			if (ipx_hosteq(ipx->ipx_dna, ia->ia_addr.sipx_addr) &&
			    (ipx_neteq(ipx->ipx_dna, ia->ia_addr.sipx_addr) ||
			    ipx_neteqnn(ipx->ipx_dna.ipx_net, ipx_zeronet)))
				break;

		if (ia == NULL) {
			ipx_forward(m);
			goto next;
		}
	}
ours:
	/*
	 * Locate pcb for datagram.
	 */
	ipxp = ipx_pcblookup(&ipx->ipx_sna, ipx->ipx_dna.ipx_port,
	    IPX_WILDCARD);
	/*
	 * Switch out to protocol's input routine.
	 */
	if (ipxp) {
		ipxstat.ipxs_delivered++;
		if ((ipxp->ipxp_flags & IPXP_ALL_PACKETS) == 0)
			switch (ipx->ipx_pt) {

			    case IPXPROTO_SPX:
				    spx_input(m, ipxp);
				    goto next;
			}
		ipx_input(m, ipxp);
	} else
		goto bad;

	goto next;

bad:
	m_freem(m);
	goto next;
}

void *
ipx_ctlinput(cmd, arg_as_sa, dummy)
	int cmd;
	struct sockaddr *arg_as_sa;	/* XXX should be swapped with dummy */
	void *dummy;
{
	caddr_t arg = (/* XXX */ caddr_t)arg_as_sa;
	struct ipx_addr *ipx;

	if (cmd < 0 || cmd >= PRC_NCMDS)
		return NULL;
	switch (cmd) {
		struct sockaddr_ipx *sipx;

	case PRC_IFDOWN:
	case PRC_HOSTDEAD:
	case PRC_HOSTUNREACH:
		sipx = (struct sockaddr_ipx *)arg;
		if (sipx == NULL || sipx->sipx_family != AF_IPX)
			return NULL;
		ipx = &sipx->sipx_addr;
		break;

	default:
		break;
	}
	return NULL;
}

/*
 * Forward a packet.  If some error occurs return the sender
 * an error packet.  Note we can't always generate a meaningful
 * error message because the IPX errors don't have a large enough repetoire
 * of codes and types.
 */
struct route ipx_droute;
struct route ipx_sroute;

void
ipx_forward(m)
struct mbuf *m;
{
	struct ipx *ipx = mtod(m, struct ipx *);
	int error;
	int agedelta = 1;
	int flags = IPX_FORWARDING;
	int ok_there = 0;
	int ok_back = 0;

	if (ipxforwarding == 0) {
		ipxstat.ipxs_cantforward++;
		m_freem(m);
		goto cleanup;
	}
	ipx->ipx_tc++;
	if (ipx->ipx_tc > IPX_MAXHOPS) {
		ipxstat.ipxs_cantforward++;
		m_freem(m);
		goto cleanup;
	}

	if ((ok_there = ipx_do_route(&ipx->ipx_dna,&ipx_droute)) == 0) {
		ipxstat.ipxs_noroute++;
		m_freem(m);
		goto cleanup;
	}
	/*
	 * Here we think about  forwarding  broadcast packets,
	 * so we try to insure that it doesn't go back out
	 * on the interface it came in on.  Also, if we
	 * are going to physically broadcast this, let us
	 * age the packet so we can eat it safely the second time around.
	 */
	if (ipx->ipx_dna.ipx_host.c_host[0] & 0x1) {
		struct ipx_ifaddr *ia = ipx_iaonnetof(&ipx->ipx_dna);
		struct ifnet *ifp;
		if (ia) {
			/* I'm gonna hafta eat this packet */
			agedelta += IPX_MAXHOPS - ipx->ipx_tc;
			ipx->ipx_tc = IPX_MAXHOPS;
		}
		if ((ok_back = ipx_do_route(&ipx->ipx_sna,&ipx_sroute)) == 0) {
			/* error = ENETUNREACH; He'll never get it! */
			ipxstat.ipxs_noroute++;
			m_freem(m);
			goto cleanup;
		}
		if (ipx_droute.ro_rt &&
		    (ifp=ipx_droute.ro_rt->rt_ifp) &&
		    ipx_sroute.ro_rt &&
		    (ifp!=ipx_sroute.ro_rt->rt_ifp)) {
			flags |= IPX_ALLOWBROADCAST;
		} else {
			ipxstat.ipxs_noroute++;
			m_freem(m);
			goto cleanup;
		}
	}
	/*
	 * We don't need to recompute checksum because ipx_tc field
	 * is ignored by checksum calculation routine, however
	 * it may be desirable to reset checksum if ipxcksum == 0
	 */
#if 0
	if (!ipxcksum)
		ipx->ipx_sum = 0xffff;
#endif

	error = ipx_outputfl(m, &ipx_droute, flags);
	if (error == 0) {
		ipxstat.ipxs_forward++;

		if (ipxprintfs) {
			printf("forward: ");
			ipx_printhost(&ipx->ipx_sna);
			printf(" to ");
			ipx_printhost(&ipx->ipx_dna);
			printf(" hops %d\n", ipx->ipx_tc);
		}
	} else {
		switch (error) {

		case ENETUNREACH:
		case EHOSTDOWN:
		case EHOSTUNREACH:
		case ENETDOWN:
		case EPERM:
			ipxstat.ipxs_noroute++;
			break;

		case EMSGSIZE:
			ipxstat.ipxs_mtutoosmall++;
			break;

		case ENOBUFS:
			ipxstat.ipxs_odropped++;
			break;
		}
		m_freem(m);
	}
cleanup:
	if (ok_there)
		ipx_undo_route(&ipx_droute);
	if (ok_back)
		ipx_undo_route(&ipx_sroute);
}

int
ipx_do_route(src, ro)
struct ipx_addr *src;
struct route *ro;
{
	struct sockaddr_ipx *dst;

	bzero((caddr_t)ro, sizeof(*ro));
	dst = (struct sockaddr_ipx *)&ro->ro_dst;

	dst->sipx_len = sizeof(*dst);
	dst->sipx_family = AF_IPX;
	dst->sipx_addr = *src;
	dst->sipx_addr.ipx_port = 0;
	rtalloc(ro);
	if (ro->ro_rt == 0 || ro->ro_rt->rt_ifp == 0) {
		return (0);
	}
	ro->ro_rt->rt_use++;
	return (1);
}

void
ipx_undo_route(ro)
register struct route *ro;
{
	if (ro->ro_rt) {
		RTFREE(ro->ro_rt);
	}
}

void
ipx_watch_output(m, ifp)
struct mbuf *m;
struct ifnet *ifp;
{
	struct ipxpcb *ipxp;
	struct ifaddr *ifa;
	struct ipx_ifaddr *ia;
	/*
	 * Give any raw listeners a crack at the packet
	 */
	CIRCLEQ_FOREACH(ipxp, &ipxrawcbtable.ipxpt_queue, ipxp_queue) {
		struct mbuf *m0 = m_copy(m, 0, (int)M_COPYALL);
		if (m0) {
			struct ipx *ipx;

			M_PREPEND(m0, sizeof(*ipx), M_DONTWAIT);
			if (m0 == NULL)
				continue;
			ipx = mtod(m0, struct ipx *);
			ipx->ipx_sna.ipx_net = ipx_zeronet;
			TAILQ_FOREACH(ia, &ipx_ifaddr, ia_list)
				if (ifp == ia->ia_ifp)
					break;
			if (ia == NULL)
				ipx->ipx_sna.ipx_host = ipx_zerohost;
			else
				ipx->ipx_sna.ipx_host =
				    ia->ia_addr.sipx_addr.ipx_host;

			if (ifp && (ifp->if_flags & IFF_POINTOPOINT))
			    TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
				if (ifa->ifa_addr->sa_family == AF_IPX) {
				    ipx->ipx_sna = IA_SIPX(ifa)->sipx_addr;
				    break;
				}
			    }
			ipx->ipx_len = ntohl(m0->m_pkthdr.len);
			ipx_input(m0, ipxp);
		}
	}
}
@


1.21
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.20 2006/03/04 22:40:16 brad Exp $	*/
@


1.20
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.19 2004/06/20 21:33:00 tholo Exp $	*/
d150 1
a150 3
	for (ipxp = ipxrawcbtable.ipxpt_queue.cqh_first;
	     ipxp != (struct ipxpcb *)&ipxrawcbtable.ipxpt_queue;
	     ipxp = ipxp->ipxp_queue.cqe_next) {
d206 1
a206 2
			for (ia = ipx_ifaddr.tqh_first; ia;
			    ia = ia->ia_list.tqe_next)
d231 1
a231 1
		for (ia = ipx_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next)
d460 1
a460 3
	for (ipxp = ipxrawcbtable.ipxpt_queue.cqh_first;
	    ipxp != (struct ipxpcb *)&ipxrawcbtable.ipxpt_queue;
	    ipxp = ipxp->ipxp_queue.cqe_next) {
d470 1
a470 2
			for (ia = ipx_ifaddr.tqh_first; ia;
			    ia = ia->ia_list.tqe_next)
d480 1
a480 2
			    for(ifa = ifp->if_addrlist.tqh_first; ifa;
					ifa = ifa->ifa_list.tqe_next) {
@


1.19
log
@Use arc4random; request art@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.18 2004/06/20 21:09:02 tholo Exp $	*/
d132 1
a132 1
	s = splimp();
@


1.18
log
@Do not use time based randomization; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.17 2003/12/10 07:22:43 itojun Exp $	*/
d100 1
a100 1
	ipx_pexseq = random();
@


1.17
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.16 2003/09/28 23:17:45 cloder Exp $	*/
d100 1
a100 1
	ipx_pexseq = time.tv_usec;
@


1.16
log
@Correct off-by-ones with respect to PRC_NCMDS.  Mostly from FreeBSD.
OK krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.15 2003/06/02 23:28:16 millert Exp $	*/
d121 3
a123 3
	register struct ipx *ipx;
	register struct mbuf *m;
	register struct ipxpcb *ipxp;
d316 2
a317 2
	register struct ipx *ipx = mtod(m, struct ipx *);
	register int error;
d457 3
a459 3
	register struct ipxpcb *ipxp;
	register struct ifaddr *ifa;
	register struct ipx_ifaddr *ia;
d468 1
a468 1
			register struct ipx *ipx;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.14 2000/01/15 09:19:22 fgsch Exp $	*/
d283 1
a283 1
	if (cmd < 0 || cmd > PRC_NCMDS)
@


1.14
log
@Don't recompute the checksum if tc is modified; from FreeBSD.
I'm not sure why we'd want to reset it. Leave the comment as is by now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.13 2000/01/15 07:07:17 fgsch Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14.2.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.14 2000/01/15 09:19:22 fgsch Exp $	*/
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 3
a123 3
	struct ipx *ipx;
	struct mbuf *m;
	struct ipxpcb *ipxp;
d283 1
a283 1
	if (cmd < 0 || cmd >= PRC_NCMDS)
d316 2
a317 2
	struct ipx *ipx = mtod(m, struct ipx *);
	int error;
d457 3
a459 3
	struct ipxpcb *ipxp;
	struct ifaddr *ifa;
	struct ipx_ifaddr *ia;
d468 1
a468 1
			struct ipx *ipx;
@


1.13
log
@More statistics; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.12 2000/01/15 07:02:13 fgsch Exp $	*/
d376 7
a382 15
	/* need to adjust checksum */
	if (ipxcksum && ipx->ipx_sum != 0xffff) {
		union bytes {
			u_char c[4];
			u_short s[2];
			long l;
		} x;
		register int shift;
		x.l = 0; x.c[0] = agedelta;
		shift = (((((int)ntohs(ipx->ipx_len))+1)>>1)-2) & 0xf;
		x.l = ipx->ipx_sum + (x.s[0] << shift);
		x.l = x.s[0] + x.s[1];
		x.l = x.s[0] + x.s[1];
		if (x.l == 0xffff) ipx->ipx_sum = 0; else ipx->ipx_sum = x.l;
	} else 
d384 1
@


1.12
log
@Remove unneeded mcopy. Add stats for errors in ipx_forward.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.11 2000/01/13 07:10:36 fgsch Exp $	*/
d328 1
d334 1
d340 1
d361 1
d371 1
d395 2
@


1.11
log
@Rearrange IPXPROTO and IPXPORT names; add socket option for checksum; use
higher ports (> 6000) for privileged users; from FreeBSD.
Add some new port entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.10 2000/01/13 04:41:03 fgsch Exp $	*/
a321 1
	struct mbuf *mcopy = NULL;
d397 1
a397 2
	} else if (mcopy != NULL) {
		ipx = mtod(mcopy, struct ipx *);
d405 1
d409 1
d413 1
a415 1
		mcopy = NULL;
a422 2
	if (mcopy != NULL)
		m_freem(mcopy);
@


1.10
log
@some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.9 2000/01/11 21:10:34 fgsch Exp $	*/
d192 1
a192 1
	if (ipx->ipx_pt == IPXPROTO_PPROP) {
@


1.9
log
@Rearrange includes and remove unnecessary ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.8 2000/01/11 20:56:15 fgsch Exp $	*/
d145 2
a146 2
	if ((m->m_flags & M_EXT || m->m_len < sizeof (struct ipx)) &&
	    (m = m_pullup(m, sizeof (struct ipx))) == 0) {
d338 1
a338 1
	if ((ok_there = ipx_do_route(&ipx->ipx_dna,&ipx_droute))==0) {
d357 1
a357 1
		if ((ok_back = ipx_do_route(&ipx->ipx_sna,&ipx_sroute))==0) {
d385 1
a385 1
		if (x.l==0xffff) ipx->ipx_sum = 0; else ipx->ipx_sum = x.l;
d434 1
a434 1
	bzero((caddr_t)ro, sizeof (*ro));
d453 3
a455 1
	if (ro->ro_rt) {RTFREE(ro->ro_rt);}
d476 1
a476 1
			M_PREPEND(m0, sizeof (*ipx), M_DONTWAIT);
@


1.8
log
@Call ipx_output_type20 for type 20 (netbios) packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.7 2000/01/11 20:30:13 fgsch Exp $	*/
a43 1
#include <sys/queue.h>
d45 1
a45 1
#include <sys/malloc.h>
a46 1
#include <sys/domain.h>
a49 5
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <vm/vm.h>
a53 1
#include <net/raw_cb.h>
@


1.7
log
@Remove unnecessary variables and debug code. Use ipxs_total and
ipx_delivered.
Treat packets broadcasted to the net where it was received as ours.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.6 2000/01/11 19:31:55 fgsch Exp $	*/
d77 1
d194 12
@


1.6
log
@Remove references to ipx_thishost; instead find the address from
ipx_ifaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.5 2000/01/11 01:26:21 fgsch Exp $	*/
a86 3
int ipxintr_getpck = 0;
int ipxintr_swtch = 0;

a135 1
	register int i;
d146 1
a146 2
	ipxintr_getpck++;
	if (m == 0) {
d149 3
a151 14
#ifdef	DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("ipxintr: no hdr");
#endif
#ifdef	IPXDEBUG
	if (0) {
	u_int8_t *p = (u_int8_t *)mtod(m, struct ipx *), i;

	printf("ipx: ");
	for (i = sizeof(struct ipx); i--; p++)
		printf("%x ", *p);
	printf("\n");
	}
#endif
a154 3
#ifdef	IPXDEBUG
		printf("ipxintr: too small [%u]\n", m->m_len);
#endif
d170 1
a178 3
#ifdef	IPXDEBUG
		printf("ipxintr: too short [%u]\n", m->m_pkthdr.len);
#endif
d188 2
a189 3
	if (ipxcksum && ((i = ipx->ipx_sum)!=0xffff)) {
		ipx->ipx_sum = 0;
		if (i != (ipx->ipx_sum = ipx_cksum(m, len))) {
a190 3
#ifdef	IPXDEBUG
			printf("ipxintr: bad sum [%u]\n", i);
#endif
d194 1
d204 11
a224 3
#ifdef	IPXDEBUG
				printf("ipxintr: forwarding bcast\n");
#endif
a239 4
#ifdef	IPXDEBUG
			printf("ipxintr: forwarding to %s\n",
			    ipx_ntoa(ipx->ipx_dna));
#endif
d244 1
a252 1
	ipxintr_swtch++;
d254 2
a255 1
		if ((ipxp->ipxp_flags & IPXP_ALL_PACKETS)==0)
a258 3
#ifdef	IPXDEBUG
				    printf("ipxintr: spx packet\n");
#endif
a260 1

a261 3
#ifdef	IPXDEBUG
		printf("ipxintr: ipx packet\n");
#endif
@


1.5
log
@Remove references to ipx_error. IPX does not generate any errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.4 1996/12/23 08:47:04 mickey Exp $	*/
a77 1
union ipx_host	ipx_thishost;
d138 1
d248 8
a255 1
	} else if (!ipx_hosteqnh(ipx_thishost,ipx->ipx_dna.ipx_host)) {
d257 2
a258 1
		printf("ipxintr: forwarding to %s\n", ipx_ntoa(ipx->ipx_dna));
d260 3
a262 2
		ipx_forward(m);
		goto next;
d267 2
a268 1
	ipxp = ipx_pcblookup(&ipx->ipx_sna, ipx->ipx_dna.ipx_port, IPX_WILDCARD);
d484 1
d500 10
a509 1
			ipx->ipx_sna.ipx_host = ipx_thishost;
@


1.4
log
@no panic on ppp down/retry
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.3 1996/10/26 09:34:51 mickey Exp $	*/
a67 1
#include <netipx/ipx_error.h>
d140 1
a140 2
	int len, s, error;
	char oddpacketp;
a188 6
	len = ntohs(ipx->ipx_len);
	if (oddpacketp == (len & 1)) {
		len++;		/* If this packet is of odd length,
				   preserve garbage byte for checksum */
	}

d216 1
a216 7
			ipx->ipx_sum = i;
			if (ipx_hosteqnh(ipx_thishost, ipx->ipx_dna.ipx_host))
				error = IPX_ERR_BADSUM;
			else
				error = IPX_ERR_BADSUM_T;
			ipx_error(m, error, 0);
			goto next;
a263 3
		if (oddpacketp) {
			m_adj(m, -1);
		}
a273 6
			    case IPXPROTO_ERROR:
#ifdef	IPXDEBUG
				    printf("ipxintr: error packet\n");
#endif
				    ipx_err_input(m);
				    goto next;
d280 1
a280 1
		ipx_error(m, IPX_ERR_NOSOCK, 0);
a288 8
u_char ipxctlerrmap[PRC_NCMDS] = {
	ECONNABORTED,	ECONNABORTED,	0,		0,
	0,		0,		EHOSTDOWN,	EHOSTUNREACH,
	ENETUNREACH,	EHOSTUNREACH,	ECONNREFUSED,	ECONNREFUSED,
	EMSGSIZE,	0,		0,		0,
	0,		0,		0,		0
};

a296 3
	struct ipxpcb *ipxp;
	struct ipx_errp *errp;
	int type;
a299 4
	if (ipxctlerrmap[cmd] == 0)
		return NULL;		/* XXX */
	type = IPX_ERR_UNREACH_HOST;
	errp = (struct ipx_errp *)arg;
a312 9
		ipx = &errp->ipx_err_ipx.ipx_dna;
		type = errp->ipx_err_num;
		type = ntohs((u_short)type);
		break;
	}
	switch (type) {

	case IPX_ERR_UNREACH_HOST:
		ipx_pcbnotify(ipx, (int)ipxctlerrmap[cmd], ipx_abort, (long)0);
a313 6

	case IPX_ERR_NOSOCK:
		ipxp = ipx_pcblookup(ipx, errp->ipx_err_ipx.ipx_sna.ipx_port,
			IPX_WILDCARD);
		if(ipxp && ipxdonosocks && ! ipx_nullhost(ipxp->ipxp_faddr))
			(void) ipx_drop(ipxp, (int)ipxctlerrmap[cmd]);
d332 1
a332 1
	register int error, type, code;
d340 2
a341 3
		/* can't tell difference between net and host */
		type = IPX_ERR_UNREACH_HOST, code = 0;
		goto senderror;
d345 2
a346 2
		type = IPX_ERR_TOO_OLD, code = 0;
		goto senderror;
a347 5
	/*
	 * Save at most 42 bytes of the packet in case
	 * we need to generate an IPX error message to the src.
	 */
	mcopy = m_copy(m, 0, imin((int)ntohs(ipx->ipx_len), 42));
d350 2
a351 2
		type = IPX_ERR_UNREACH_HOST, code = 0;
		goto senderror;
d379 2
a380 2
			type = IPX_ERR_UNREACH_HOST, code = 0;
			goto senderror;
d401 9
a409 10

	if (ipxprintfs && !error) {
		printf("forward: ");
		ipx_printhost(&ipx->ipx_sna);
		printf(" to ");
		ipx_printhost(&ipx->ipx_dna);
		printf(" hops %d\n", ipx->ipx_tc);
	}

	if (error && mcopy != NULL) {
a410 1
		type = IPX_ERR_UNSPEC_T, code = 0;
a417 1
			type = IPX_ERR_UNREACH_HOST;
a420 2
			type = IPX_ERR_TOO_BIG;
			code = 576; /* too hard to figure out mtu here */
a423 1
			type = IPX_ERR_UNSPEC_T;
d427 1
a427 2
	senderror:
		ipx_error(m, type, code);
@


1.3
log
@remove my CVS tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipx_input.c,v 1.1 1996/08/16 09:15:59 mickey Exp $	*/
d345 1
a345 1
		if (sipx->sipx_family != AF_IPX)
@


1.2
log
@-Wall happieness. bug fix caused by parens...
@
text
@a1 1
/*	$NOWHERE: ipx_input.c,v 1.2 1996/05/07 09:49:42 mickey Exp $	*/
@


1.1
log
@initial commit of Free's netipx w/ some changes.
ip<-->ipx encapsulations does not work still.
spx suspected to do too.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d193 1
a193 1
	if (oddpacketp = len & 1) {
d334 1
a334 1
		return;
d336 1
a336 1
		return;		/* XXX */
d347 1
a347 1
			return;
@
