head	1.80;
access;
symbols
	OPENBSD_6_0:1.72.0.4
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.69.0.2
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.80
date	2017.01.24.03.57.35;	author dlg;	state Exp;
branches;
next	1.79;
commitid	PERtGPXCvlLRRBr8;

1.79
date	2017.01.21.01.32.19;	author patrick;	state Exp;
branches;
next	1.78;
commitid	Dp9WR4FKe3nPMKYm;

1.78
date	2017.01.06.14.01.19;	author rzalamena;	state Exp;
branches;
next	1.77;
commitid	HqvJlf6KKxwDeViP;

1.77
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.76;
commitid	to0Je2i4V2FtpmS1;

1.76
date	2016.11.08.10.46.05;	author mpi;	state Exp;
branches;
next	1.75;
commitid	FX5giWCmMTBWXuF5;

1.75
date	2016.09.04.15.46.39;	author reyk;	state Exp;
branches;
next	1.74;
commitid	05wK3oqe2BKozGUg;

1.74
date	2016.09.03.09.55.44;	author mpi;	state Exp;
branches;
next	1.73;
commitid	cql4kpEcloSl2LWa;

1.73
date	2016.09.01.10.06.33;	author goda;	state Exp;
branches;
next	1.72;
commitid	53X2QcUepPKjCjvt;

1.72
date	2016.06.10.20.33.29;	author vgross;	state Exp;
branches;
next	1.71;
commitid	qJaxh4rw41tBg4CK;

1.71
date	2016.04.15.05.05.21;	author dlg;	state Exp;
branches;
next	1.70;
commitid	ZmGLFaWO5K4UN2cP;

1.70
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.69;
commitid	Xo6g1xk26RWDGcjJ;

1.69
date	2015.12.18.14.02.15;	author visa;	state Exp;
branches;
next	1.68;
commitid	lTfY0zsNQa4Ic2kV;

1.68
date	2015.12.09.15.05.51;	author mpi;	state Exp;
branches;
next	1.67;
commitid	q2xIbZZsrU0VN6YM;

1.67
date	2015.12.09.03.22.39;	author dlg;	state Exp;
branches;
next	1.66;
commitid	ORE7f8VM8QK0ujAk;

1.66
date	2015.12.08.10.14.58;	author dlg;	state Exp;
branches;
next	1.65;
commitid	F9xki6lintTk7LFM;

1.65
date	2015.12.08.10.06.12;	author dlg;	state Exp;
branches;
next	1.64;
commitid	VAQjlQNQBXJ725Km;

1.64
date	2015.12.05.16.24.59;	author mpi;	state Exp;
branches;
next	1.63;
commitid	ENZlZN1ysYKIbE7F;

1.63
date	2015.12.03.21.11.53;	author sashan;	state Exp;
branches;
next	1.62;
commitid	nhuzteWvIf6uiITt;

1.62
date	2015.12.03.16.27.32;	author mpi;	state Exp;
branches;
next	1.61;
commitid	wK6td35Fr7xdNzh3;

1.61
date	2015.12.03.12.22.51;	author dlg;	state Exp;
branches;
next	1.60;
commitid	Xu3de8VDlKImDsXf;

1.60
date	2015.12.02.08.03.00;	author mpi;	state Exp;
branches;
next	1.59;
commitid	FqXes4NHS61fr0NL;

1.59
date	2015.11.27.15.00.12;	author mpi;	state Exp;
branches;
next	1.58;
commitid	BSd6UzglLbwb3sy0;

1.58
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.57;
commitid	B0kwmVGiD5DVx4kv;

1.57
date	2015.11.23.15.53.35;	author mpi;	state Exp;
branches;
next	1.56;
commitid	oUay5xUsF5SD1zqV;

1.56
date	2015.11.21.01.08.50;	author dlg;	state Exp;
branches;
next	1.55;
commitid	NZSRW1Bv4cWMAzsm;

1.55
date	2015.11.20.11.15.07;	author dlg;	state Exp;
branches;
next	1.54;
commitid	DSo9cWHeceL3peeU;

1.54
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.53;
commitid	eYnPulzvLjDImPCa;

1.53
date	2015.11.18.13.58.02;	author mpi;	state Exp;
branches;
next	1.52;
commitid	uGqqOfOdbFUfC7aN;

1.52
date	2015.11.11.10.23.23;	author mpi;	state Exp;
branches;
next	1.51;
commitid	HAbRB9Scbg3IhXig;

1.51
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.50;
commitid	G2nTzngqgXpQqcJB;

1.50
date	2015.10.24.10.52.05;	author reyk;	state Exp;
branches;
next	1.49;
commitid	PvSfHvj4AhI0uuuE;

1.49
date	2015.10.22.17.48.34;	author mpi;	state Exp;
branches;
next	1.48;
commitid	ToMJCJHoIWfUEPhu;

1.48
date	2015.10.12.13.17.58;	author dlg;	state Exp;
branches;
next	1.47;
commitid	jErEkfao8orfupjn;

1.47
date	2015.10.05.15.19.29;	author uebayasi;	state Exp;
branches;
next	1.46;
commitid	CO29eq1de4LE0DwZ;

1.46
date	2015.09.30.11.33.51;	author dlg;	state Exp;
branches;
next	1.45;
commitid	d4upogI9re630Rga;

1.45
date	2015.09.28.08.24.53;	author mpi;	state Exp;
branches;
next	1.44;
commitid	Nw7RtPUfLwJqeuAc;

1.44
date	2015.09.27.05.23.50;	author dlg;	state Exp;
branches;
next	1.43;
commitid	EOMGnvAfDUkwTLM2;

1.43
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.42;
commitid	zZXiESHR0g5lNO0l;

1.42
date	2015.09.13.09.58.03;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	yv8xOji6j7Idb0Wm;

1.41
date	2015.09.12.20.26.06;	author mpi;	state Exp;
branches;
next	1.40;
commitid	UM7jfgLT8vWQUBm1;

1.40
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.39;
commitid	LU3jSOpFfLxcllFL;

1.39
date	2015.09.10.18.11.05;	author dlg;	state Exp;
branches;
next	1.38;
commitid	g4iEvaKg78JqEZnW;

1.38
date	2015.09.10.16.41.30;	author mikeb;	state Exp;
branches;
next	1.37;
commitid	Dj2db8t0KelqURhl;

1.37
date	2015.09.10.14.56.41;	author dlg;	state Exp;
branches;
next	1.36;
commitid	3T8H8fBJ9bN4PLpC;

1.36
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.35;
commitid	JbEzJsyDrWqOW57C;

1.35
date	2015.09.09.16.01.10;	author dlg;	state Exp;
branches;
next	1.34;
commitid	K9CHsxd7Pm2AnGZf;

1.34
date	2015.07.02.09.40.02;	author mpi;	state Exp;
branches;
next	1.33;
commitid	eKXa0TkOIth1tkBS;

1.33
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.32;
commitid	fE8TgA9vpwdUU5Wy;

1.32
date	2015.06.02.13.23.55;	author mpi;	state Exp;
branches;
next	1.31;
commitid	XBDvq1RY2L1Yg3J3;

1.31
date	2015.05.28.11.57.33;	author mpi;	state Exp;
branches;
next	1.30;
commitid	n844eLrmeRCxN5bA;

1.30
date	2015.05.26.11.39.07;	author mpi;	state Exp;
branches;
next	1.29;
commitid	VJjEISzzvhOYKF2A;

1.29
date	2015.05.19.11.09.24;	author mpi;	state Exp;
branches;
next	1.28;
commitid	i7YRRkkCxLwyGmml;

1.28
date	2015.05.18.13.32.28;	author reyk;	state Exp;
branches;
next	1.27;
commitid	ndMf9FjDLv5uu2sS;

1.27
date	2015.05.15.11.53.06;	author claudio;	state Exp;
branches;
next	1.26;
commitid	cCD2n7Cc79Kk6xSC;

1.26
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.25;
commitid	1aiWjheMGhmTuiHL;

1.25
date	2015.04.23.09.45.24;	author dlg;	state Exp;
branches;
next	1.24;
commitid	BpkIGymqTMK3ZEHF;

1.24
date	2015.04.07.10.46.20;	author mpi;	state Exp;
branches;
next	1.23;
commitid	m3c6YErI0cVMQeYc;

1.23
date	2015.04.01.04.00.55;	author dlg;	state Exp;
branches;
next	1.22;
commitid	CU8KSAkGLLJrGHM7;

1.22
date	2015.03.25.11.49.02;	author dlg;	state Exp;
branches;
next	1.21;
commitid	aTZxHMVtTVBgDDyD;

1.21
date	2015.03.18.12.23.15;	author dlg;	state Exp;
branches;
next	1.20;
commitid	veRr3qZI7HBatTwk;

1.20
date	2015.02.09.03.09.57;	author dlg;	state Exp;
branches;
next	1.19;
commitid	fE9MPAUoNdw8sZYO;

1.19
date	2015.02.08.06.00.52;	author mpi;	state Exp;
branches;
next	1.18;
commitid	LWJ12V7CpWdalkDf;

1.18
date	2015.02.06.06.42.36;	author henning;	state Exp;
branches;
next	1.17;
commitid	zDYiZc9FAEGLbNie;

1.17
date	2015.02.06.06.38.08;	author henning;	state Exp;
branches;
next	1.16;
commitid	bn0V9eOPy3kbOXM1;

1.16
date	2014.12.18.15.29.30;	author krw;	state Exp;
branches;
next	1.15;
commitid	IHhdyKKaQ2noLfVl;

1.15
date	2014.12.08.10.46.14;	author mpi;	state Exp;
branches;
next	1.14;
commitid	ExaN0TCQ4X0c1lo6;

1.14
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.13;
commitid	t9FBKDfc4VDxpEy2;

1.13
date	2014.12.01.15.06.54;	author mikeb;	state Exp;
branches;
next	1.12;
commitid	oohxazEA8Jchx2XI;

1.12
date	2014.07.08.04.02.14;	author dlg;	state Exp;
branches;
next	1.11;
commitid	1jRrZP5Li2zmiVEq;

1.11
date	2014.05.26.08.33.48;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.23.09.30.57;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.19.15.57.25;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.19.11.26.10;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2014.03.20.13.19.06;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.28.11.05.18;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2013.11.21.17.32.12;	author mikeb;	state Exp;
branches;
next	;


desc
@@


1.80
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@/*	$OpenBSD: if_var.h,v 1.79 2017/01/21 01:32:19 patrick Exp $	*/
/*	$NetBSD: if.h,v 1.23 1996/05/07 02:40:27 thorpej Exp $	*/

/*
 * Copyright (c) 2012-2013 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NET_IF_VAR_H_
#define _NET_IF_VAR_H_

#ifdef _KERNEL

#include <sys/queue.h>
#include <sys/mbuf.h>
#include <sys/srp.h>
#include <sys/refcnt.h>
#include <sys/task.h>
#include <sys/time.h>

#include <net/ifq.h>

/*
 * Structures defining a network interface, providing a packet
 * transport mechanism (ala level 0 of the PUP protocols).
 *
 * Each interface accepts output datagrams of a specified maximum
 * length, and provides higher level routines with input datagrams
 * received from its medium.
 *
 * Output occurs when the routine if_output is called, with four parameters:
 *	(*ifp->if_output)(ifp, m, dst, rt)
 * Here m is the mbuf chain to be sent and dst is the destination address.
 * The output routine encapsulates the supplied datagram if necessary,
 * and then transmits it on its medium.
 *
 * On input, each interface unwraps the data received by it, and either
 * places it on the input queue of an internetwork datagram routine
 * and posts the associated software interrupt, or passes the datagram to a raw
 * packet input routine.
 *
 * Routines exist for locating interfaces by their addresses
 * or for locating an interface on a certain network, as well as more general
 * routing and gateway routines maintaining information used to locate
 * interfaces.  These routines live in the files if.c and route.c
 */

struct rtentry;
struct timeout;
struct ifnet;
struct task;

/*
 * Structure describing a `cloning' interface.
 */
struct if_clone {
	LIST_ENTRY(if_clone)	 ifc_list;	/* on list of cloners */
	const char		*ifc_name;	/* name of device, e.g. `gif' */
	size_t			 ifc_namelen;	/* length of name */

	int			(*ifc_create)(struct if_clone *, int);
	int			(*ifc_destroy)(struct ifnet *);
};

#define	IF_CLONE_INITIALIZER(name, create, destroy)			\
	{ { 0 }, name, sizeof(name) - 1, create, destroy }

/*
 * Structure defining a queue for a network interface.
 *
 * (Would like to call this struct ``if'', but C isn't PL/1.)
 */
TAILQ_HEAD(ifnet_head, ifnet);		/* the actual queue head */

struct ifnet {				/* and the entries */
	void	*if_softc;		/* lower-level data for this if */
	struct	refcnt if_refcnt;
	TAILQ_ENTRY(ifnet) if_list;	/* all struct ifnets are chained */
	TAILQ_HEAD(, ifaddr) if_addrlist; /* linked list of addresses per if */
	TAILQ_HEAD(, ifmaddr) if_maddrlist; /* list of multicast records */
	TAILQ_HEAD(, ifg_list) if_groups; /* linked list of groups per if */
	struct hook_desc_head *if_addrhooks; /* address change callbacks */
	struct hook_desc_head *if_linkstatehooks; /* link change callbacks */
	struct hook_desc_head *if_detachhooks; /* detach callbacks */
					/* check or clean routes (+ or -)'d */
	void	(*if_rtrequest)(struct ifnet *, int, struct rtentry *);
	char	if_xname[IFNAMSIZ];	/* external name (name + unit) */
	int	if_pcount;		/* number of promiscuous listeners */
	caddr_t	if_bpf;			/* packet filter structure */
	caddr_t if_bridgeport;		/* used by bridge ports */
	caddr_t if_switchport;		/* used by switch ports */
	caddr_t if_mcast;		/* used by multicast code */
	caddr_t	if_pf_kif;		/* pf interface abstraction */
	union {
		caddr_t	carp_s;		/* carp structure (used by !carp ifs) */
		struct ifnet *carp_d;	/* ptr to carpdev (used by carp ifs) */
	} if_carp_ptr;
#define if_carp		if_carp_ptr.carp_s
#define if_carpdev	if_carp_ptr.carp_d
	unsigned int if_index;		/* numeric abbreviation for this if */
	short	if_timer;		/* time 'til if_watchdog called */
	unsigned short if_flags;	/* up/down, broadcast, etc. */
	int	if_xflags;		/* extra softnet flags */
	struct	if_data if_data;	/* stats and other data about if */
	u_int32_t if_hardmtu;		/* maximum MTU device supports */
	char	if_description[IFDESCRSIZE]; /* interface description */
	u_short	if_rtlabelid;		/* next route label */
	u_int8_t if_priority;
	u_int8_t if_llprio;		/* link layer priority */
	struct	timeout *if_slowtimo;	/* watchdog timeout */
	struct	task *if_watchdogtask;	/* watchdog task */
	struct	task *if_linkstatetask; /* task to do route updates */

	/* procedure handles */
	struct mbuf_queue if_inputqueue;
	struct task *if_inputtask;	/* input task */
	SRPL_HEAD(, ifih) if_inputs;	/* input routines (dequeue) */

					/* output routine (enqueue) */
	int	(*if_output)(struct ifnet *, struct mbuf *, struct sockaddr *,
		     struct rtentry *);

					/* link level output function */
	int	(*if_ll_output)(struct ifnet *, struct mbuf *,
		    struct sockaddr *, struct rtentry *);
					/* initiate output routine */
	void	(*if_start)(struct ifnet *);
					/* ioctl routine */
	int	(*if_ioctl)(struct ifnet *, u_long, caddr_t);
					/* timer routine */
	void	(*if_watchdog)(struct ifnet *);
	int	(*if_wol)(struct ifnet *, int);

	struct	ifqueue if_snd;		/* transmit queue */
	struct	ifqueue **if_ifqs;	/* pointer to an array of sndqs */
	void	(*if_qstart)(struct ifqueue *);
	unsigned int if_nifqs;

	struct sockaddr_dl *if_sadl;	/* pointer to our sockaddr_dl */

	void	*if_afdata[AF_MAX];
};
#define	if_mtu		if_data.ifi_mtu
#define	if_type		if_data.ifi_type
#define	if_addrlen	if_data.ifi_addrlen
#define	if_hdrlen	if_data.ifi_hdrlen
#define	if_metric	if_data.ifi_metric
#define	if_link_state	if_data.ifi_link_state
#define	if_baudrate	if_data.ifi_baudrate
#define	if_ipackets	if_data.ifi_ipackets
#define	if_ierrors	if_data.ifi_ierrors
#define	if_opackets	if_data.ifi_opackets
#define	if_oerrors	if_data.ifi_oerrors
#define	if_collisions	if_data.ifi_collisions
#define	if_ibytes	if_data.ifi_ibytes
#define	if_obytes	if_data.ifi_obytes
#define	if_imcasts	if_data.ifi_imcasts
#define	if_omcasts	if_data.ifi_omcasts
#define	if_iqdrops	if_data.ifi_iqdrops
#define	if_oqdrops	if_data.ifi_oqdrops
#define	if_noproto	if_data.ifi_noproto
#define	if_lastchange	if_data.ifi_lastchange
#define	if_capabilities	if_data.ifi_capabilities
#define	if_rdomain	if_data.ifi_rdomain

/*
 * The ifaddr structure contains information about one address
 * of an interface.  They are maintained by the different address families,
 * are allocated and attached when an address is set, and are linked
 * together so all addresses for an interface can be located.
 */
struct ifaddr {
	struct	sockaddr *ifa_addr;	/* address of interface */
	struct	sockaddr *ifa_dstaddr;	/* other end of p-to-p link */
#define	ifa_broadaddr	ifa_dstaddr	/* broadcast address interface */
	struct	sockaddr *ifa_netmask;	/* used to determine subnet */
	struct	ifnet *ifa_ifp;		/* back-pointer to interface */
	TAILQ_ENTRY(ifaddr) ifa_list;	/* list of addresses for interface */
	u_int	ifa_flags;		/* interface flags, see below */
	u_int	ifa_refcnt;		/* number of `rt_ifa` references */
	int	ifa_metric;		/* cost of going out this interface */
};

#define	IFA_ROUTE		0x01	/* Auto-magically installed route */

/*
 * Interface multicast address.
 */
struct ifmaddr {
	struct sockaddr		*ifma_addr;	/* Protocol address */
	unsigned int		 ifma_ifidx;	/* Index of the interface */
	unsigned int		 ifma_refcnt;	/* Count of references */
	TAILQ_ENTRY(ifmaddr)	 ifma_list;	/* Per-interface list */
};

/*
 * interface groups
 */

struct ifg_group {
	char			 ifg_group[IFNAMSIZ];
	u_int			 ifg_refcnt;
	caddr_t			 ifg_pf_kif;
	int			 ifg_carp_demoted;
	TAILQ_HEAD(, ifg_member) ifg_members;
	TAILQ_ENTRY(ifg_group)	 ifg_next;
};

struct ifg_member {
	TAILQ_ENTRY(ifg_member)	 ifgm_next;
	struct ifnet		*ifgm_ifp;
};

struct ifg_list {
	struct ifg_group	*ifgl_group;
	TAILQ_ENTRY(ifg_list)	 ifgl_next;
};

#define	IFNET_SLOWHZ	1		/* granularity is 1 second */

/*
 * IFQ compat on ifq API
 */

#define	IFQ_ENQUEUE(ifq, m, err)					\
do {									\
	(err) = ifq_enqueue((ifq), (m));				\
} while (/* CONSTCOND */0)

#define	IFQ_DEQUEUE(ifq, m)						\
do {									\
	(m) = ifq_dequeue(ifq);						\
} while (/* CONSTCOND */0)

#define	IFQ_PURGE(ifq)							\
do {									\
	(void)ifq_purge(ifq);						\
} while (/* CONSTCOND */0)

#define	IFQ_LEN(ifq)			ifq_len(ifq)
#define	IFQ_IS_EMPTY(ifq)		ifq_empty(ifq)
#define	IFQ_SET_MAXLEN(ifq, len)	ifq_set_maxlen(ifq, len)

/* default interface priorities */
#define IF_WIRED_DEFAULT_PRIORITY	0
#define IF_WIRELESS_DEFAULT_PRIORITY	4
#define IF_CARP_DEFAULT_PRIORITY	15

/*
 * Network stack input queues.
 */
struct	niqueue {
	struct mbuf_queue	ni_q;
	u_int			ni_isr;
};

#define NIQUEUE_INITIALIZER(_len, _isr) \
    { MBUF_QUEUE_INITIALIZER((_len), IPL_NET), (_isr) }

void		niq_init(struct niqueue *, u_int, u_int);
int		niq_enqueue(struct niqueue *, struct mbuf *);
int		niq_enlist(struct niqueue *, struct mbuf_list *);

#define niq_dequeue(_q)			mq_dequeue(&(_q)->ni_q)
#define niq_dechain(_q)			mq_dechain(&(_q)->ni_q)
#define niq_delist(_q, _ml)		mq_delist(&(_q)->ni_q, (_ml))
#define niq_len(_q)			mq_len(&(_q)->ni_q)
#define niq_drops(_q)			mq_drops(&(_q)->ni_q)
#define sysctl_niq(_n, _l, _op, _olp, _np, _nl, _niq) \
    sysctl_mq((_n), (_l), (_op), (_olp), (_np), (_nl), &(_niq)->ni_q)

extern struct ifnet_head ifnet;
extern struct taskq *softnettq;

void	if_start(struct ifnet *);
int	if_enqueue_try(struct ifnet *, struct mbuf *);
int	if_enqueue(struct ifnet *, struct mbuf *);
void	if_input(struct ifnet *, struct mbuf_list *);
int	if_input_local(struct ifnet *, struct mbuf *, sa_family_t);
void	if_rtrequest_dummy(struct ifnet *, int, struct rtentry *);
void	p2p_rtrequest(struct ifnet *, int, struct rtentry *);

struct	ifaddr *ifa_ifwithaddr(struct sockaddr *, u_int);
struct	ifaddr *ifa_ifwithdstaddr(struct sockaddr *, u_int);
struct	ifaddr *ifaof_ifpforaddr(struct sockaddr *, struct ifnet *);
void	ifafree(struct ifaddr *);

int	if_isconnected(const struct ifnet *, unsigned int);

void	if_clone_attach(struct if_clone *);
void	if_clone_detach(struct if_clone *);

int	if_clone_create(const char *, int);
int	if_clone_destroy(const char *);

struct if_clone *
	if_clone_lookup(const char *, int *);

int     sysctl_mq(int *, u_int, void *, size_t *, void *, size_t,
	    struct mbuf_queue *);

void	ifa_add(struct ifnet *, struct ifaddr *);
void	ifa_del(struct ifnet *, struct ifaddr *);
void	ifa_update_broadaddr(struct ifnet *, struct ifaddr *,
	    struct sockaddr *);

void	if_ih_insert(struct ifnet *, int (*)(struct ifnet *, struct mbuf *,
	    void *), void *);
void	if_ih_remove(struct ifnet *, int (*)(struct ifnet *, struct mbuf *,
	    void *), void *);

void	if_rxr_init(struct if_rxring *, u_int, u_int);
u_int	if_rxr_get(struct if_rxring *, u_int);

#define if_rxr_put(_r, _c)	do { (_r)->rxr_alive -= (_c); } while (0)
#define if_rxr_inuse(_r)	((_r)->rxr_alive)

int	if_rxr_info_ioctl(struct if_rxrinfo *, u_int, struct if_rxring_info *);
int	if_rxr_ioctl(struct if_rxrinfo *, const char *, u_int,
	    struct if_rxring *);

#endif /* _KERNEL */

#endif /* _NET_IF_VAR_H_ */
@


1.79
log
@Make the if_flags member unsigned.  This was prompted by clang
complaining that assigning the MULTICAST flag, which sets the
uppermost bit, would invert the meaning of MULTICAST flag's
numeric value.

ok claudio@@ deraadt@@ tom@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.78 2017/01/06 14:01:19 rzalamena Exp $	*/
d160 6
a165 1
	struct	ifqueue if_snd;		/* output queue */
@


1.78
log
@Remove the global viftable vector that holds the virtual interfaces
configuration and instead use ifnet to store the configuration and
counters. With this we can safely use multicast routing daemons on
multiple domains without vif id colisions.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.77 2016/11/14 10:32:46 mpi Exp $	*/
d129 1
a129 1
	short	if_flags;		/* up/down, broadcast, etc. */
@


1.77
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.76 2016/11/08 10:46:05 mpi Exp $	*/
d119 1
@


1.76
log
@RIP ifa_ifwithnet()

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.75 2016/09/04 15:46:39 reyk Exp $	*/
a293 1
extern unsigned int lo0ifidx;
@


1.75
log
@When auto-creating an interface when opening a /dev/{tun,tap,switch}
device, inherit the rdomain from the calling process.  This adds an
rdomain argument to if_clone_create().

OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.74 2016/09/03 09:55:44 mpi Exp $	*/
a306 1
struct	ifaddr *ifa_ifwithnet(struct sockaddr *, u_int);
@


1.74
log
@Use per-ifp tasks to process incoming packets.

Reduce the number of if_get/if_put from one per packet to one per ring
since we now know that all the packets are coming from the same interface.

Improve forwarding performances by 10Kpps in Hrvoje Popovski's test setup.

ok bluhm@@, henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.73 2016/09/01 10:06:33 goda Exp $	*/
d316 1
a316 1
int	if_clone_create(const char *);
@


1.73
log
@Import switch(4), an in-kernel OpenFlow switch which can work alone.
switch(4) currently supports OpenFlow 1.3.5.
Currently, it's disabled by the kernel config.

With help from yasuoka@@ reyk@@ jsg@@.

ok deraadt@@ yasuoka@@ reyk@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.72 2016/06/10 20:33:29 vgross Exp $	*/
d141 2
@


1.72
log
@Add the "llprio" field to struct ifnet, and the corresponding keyword
to ifconfig.

"llprio" allows one to set the priority of packets that do not go through
pf(4), as the case is for arp(4) or bpf(4).

ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.71 2016/04/15 05:05:21 dlg Exp $	*/
d118 1
@


1.71
log
@remove ml_filter, mq_filter, niq_filter.

theyre currently unused, so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.70 2016/04/13 11:41:15 mpi Exp $	*/
d134 1
@


1.70
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.69 2015/12/18 14:02:15 visa Exp $	*/
a283 1
#define niq_filter(_q, _f, _c)		mq_filter(&(_q)->ni_q, (_f), (_c))
@


1.69
log
@Remove leftover prototype.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.68 2015/12/09 15:05:51 mpi Exp $	*/
a259 1
#define	IFQ_SET_READY(ifq)		do { } while (0)
@


1.68
log
@Keep all ether prototypes in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.67 2015/12/09 03:22:39 dlg Exp $	*/
a295 1
void	if_start_barrier(struct ifnet *);
@


1.67
log
@rework the if_start mpsafe serialisation so it can serialise arbitrary work

work is represented by struct task.

the start routine is now wrapped by a task which is serialised by the
infrastructure. if_start_barrier has been renamed to ifq_barrier and
is now implemented as a task that gets serialised with the start
routine.

this also adds an ifq_restart() function. it serialises a call to
ifq_clr_oactive and calls the start routine again. it exists to
avoid a race that kettenis@@ identified in between when a start
routine discovers theres no space left on a ring, and when it calls
ifq_set_oactive. if the txeof side of the driver empties the ring
and calls ifq_clr_oactive in between the above calls in start, the
queue will be marked oactive and the stack will never call the start
routine again.

by serialising the ifq_set_oactive call in the start routine and
ifq_clr_oactive calls we avoid that race.

tested on various nics
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.64 2015/12/05 16:24:59 mpi Exp $	*/
a76 1
struct arpcom;
a302 9

void	ether_ifattach(struct ifnet *);
void	ether_ifdetach(struct ifnet *);
int	ether_ioctl(struct ifnet *, struct arpcom *, u_long, caddr_t);
int	ether_input(struct ifnet *, struct mbuf *, void *);
int	ether_output(struct ifnet *,
	    struct mbuf *, struct sockaddr *, struct rtentry *);
void	ether_rtrequest(struct ifnet *, int, struct rtentry *);
char	*ether_sprintf(u_char *);
@


1.66
log
@if_stop is unused, so kill it.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.65 2015/12/08 10:06:12 dlg Exp $	*/
d45 1
@


1.65
log
@split the interface send queue (struct ifqueue) implementation out.

the intention is to make it more clear what belongs to a transmit
queue and what belongs to an interface.

suggested by and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.64 2015/12/05 16:24:59 mpi Exp $	*/
a151 2
					/* stop routine */
	int	(*if_stop)(struct ifnet *, int);
@


1.64
log
@Keep kernel definitions under _KERNEL to unbreak ports that include
<net/if_var.h> because some other operating systems have defines in
there.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.63 2015/12/03 21:11:53 sashan Exp $	*/
d47 2
a95 29
 * Structure defining the send queue for a network interface.
 */

struct ifqueue;

struct ifq_ops {
	void			*(*ifqop_alloc)(void *);
	void			 (*ifqop_free)(void *);
	int			 (*ifqop_enq)(struct ifqueue *, struct mbuf *);
	struct mbuf 		*(*ifqop_deq_begin)(struct ifqueue *, void **);
	void			 (*ifqop_deq_commit)(struct ifqueue *,
				    struct mbuf *, void *);
	void	 		 (*ifqop_purge)(struct ifqueue *,
				    struct mbuf_list *);
};

struct ifqueue {
	struct mutex		 ifq_mtx;
	uint64_t		 ifq_drops;
	const struct ifq_ops	*ifq_ops;
	void			*ifq_q;
	unsigned int		 ifq_len;
	unsigned int		 ifq_serializer;
	unsigned int		 ifq_oactive;

	unsigned int		 ifq_maxlen;
};

/*
a237 42
/*
 * Interface send queues.
 */

void		 ifq_init(struct ifqueue *);
void		 ifq_attach(struct ifqueue *, const struct ifq_ops *, void *);
void		 ifq_destroy(struct ifqueue *);
int		 ifq_enqueue_try(struct ifqueue *, struct mbuf *);
int		 ifq_enqueue(struct ifqueue *, struct mbuf *);
struct mbuf	*ifq_deq_begin(struct ifqueue *);
void		 ifq_deq_commit(struct ifqueue *, struct mbuf *);
void		 ifq_deq_rollback(struct ifqueue *, struct mbuf *);
struct mbuf	*ifq_dequeue(struct ifqueue *);
unsigned int	 ifq_purge(struct ifqueue *);
void		*ifq_q_enter(struct ifqueue *, const struct ifq_ops *);
void		 ifq_q_leave(struct ifqueue *, void *);

#define	ifq_len(_ifq)			((_ifq)->ifq_len)
#define	ifq_empty(_ifq)			(ifq_len(_ifq) == 0)
#define	ifq_set_maxlen(_ifq, _l)	((_ifq)->ifq_maxlen = (_l))

static inline void
ifq_set_oactive(struct ifqueue *ifq)
{
	ifq->ifq_oactive = 1;
}

static inline void
ifq_clr_oactive(struct ifqueue *ifq)
{
	ifq->ifq_oactive = 0;
}

static inline unsigned int
ifq_is_oactive(struct ifqueue *ifq)
{
	return (ifq->ifq_oactive);
}

extern const struct ifq_ops * const ifq_priq_ops;

#define	IFQ_MAXLEN	256
@


1.63
log
@ip_send()/ip6_send() allow PF to send response packet in ipsoftnet task.
this avoids current recursion to pf_test() function. the change also
switches icmp_error()/icmp6_error() to use ip_send()/ip6_send() so
they are safe for PF.

The idea comes from Markus Friedl. bluhm, mikeb and mpi helped me
a lot to get it into shape.

OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.62 2015/12/03 16:27:32 mpi Exp $	*/
d39 2
d45 1
a71 2
#include <sys/time.h>

a264 1
#ifdef _KERNEL
@


1.62
log
@Use SRPL_HEAD() and SRPL_ENTRY() to be consistent with and allow to
fallback to a SLIST.

ok dlg@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.61 2015/12/03 12:22:51 dlg Exp $	*/
d364 1
@


1.61
log
@rework if_start to allow nics to provide an mpsafe start routine.

existing start routines will still be called under the kernel lock
and at IPL_NET.

mpsafe start routines will be serialised so only one instance of
each interfaces function will be running in the kernel at any point
in time. this guarantees packets will be dequeued in order, and the
start routines dont have to lock against themselves because if_start
does it for them.

the code to do that is based on the scsi runqueue code.

this also provides an if_start_barrier() function that should wait
until any currently running instances of if_start have finished.

a driver can opt in to the mpsafe if_start call by doing the following:

1. setting ifp->if_xflags = IFXF_MPSAFE
2. only calling if_start() instead of its own start routine
3. clearing IFF_RUNNING before calling if_start_barrier() on its way down
4. only using IFQ_DEQUEUE (not ifq_deq_begin/commit/rollback)

to simplify the implementation the tx mitigation code has been removed.

tested by several
ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.60 2015/12/02 08:03:00 mpi Exp $	*/
d165 1
a165 1
	struct	srpl if_inputs;		/* input routines (dequeue) */
@


1.60
log
@Remove forward declarations that are no longer needed, times and APIs are
changing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.59 2015/11/27 15:00:12 mpi Exp $	*/
a131 1
	TAILQ_ENTRY(ifnet) if_txlist;	/* list of ifnets ready to tx */
d366 1
@


1.59
log
@Keep lo(4) definitions inside if_loop.c
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.58 2015/11/25 03:10:00 dlg Exp $	*/
a70 1
struct proc;
a71 1
struct socket;
a72 1
struct ether_header;
a73 1
struct rt_addrinfo;
a74 1
struct hfsc_if;
@


1.58
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.57 2015/11/23 15:53:35 mpi Exp $	*/
a406 6

int	loioctl(struct ifnet *, u_long, caddr_t);
void	loopattach(int);
int	looutput(struct ifnet *,
	    struct mbuf *, struct sockaddr *, struct rtentry *);
void	lortrequest(struct ifnet *, int, struct rtentry *);
@


1.57
log
@There's no longer a need to include <net/hfsc.h> in <net/if_var.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.56 2015/11/21 01:08:50 dlg Exp $	*/
d121 1
d291 18
@


1.56
log
@simplify ifq_deq_rollback by only having it unlock.

hfsc needed a rollback ifqop to requeue the mbuf because it used
ml_dequeue in the begin op. now it uses MBUF_LIST_FIRST to get a
ref to the first mbuf in deq_begin.

now the disciplines dont need a rollback op, so ifq_deq_rollback
can be simplified to just releasing the mutex.

based on a discussion with kenjiro cho
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.55 2015/11/20 11:15:07 dlg Exp $	*/
a42 3
#ifdef _KERNEL
#include <net/hfsc.h>
#endif
@


1.55
log
@i made a mistake. rename ifq_enq and ifq_deq to ifq_enqueue and ifq_dequeue

fixing it now before i regret it more.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.54 2015/11/20 03:35:23 dlg Exp $	*/
a111 2
				    struct mbuf *, void *);
	void			 (*ifqop_deq_rollback)(struct ifqueue *,
@


1.54
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.53 2015/11/18 13:58:02 mpi Exp $	*/
d282 2
a283 2
int		 ifq_enq_try(struct ifqueue *, struct mbuf *);
int		 ifq_enq(struct ifqueue *, struct mbuf *);
d287 1
a287 1
struct mbuf	*ifq_deq(struct ifqueue *);
d307 1
a307 1
	(err) = ifq_enq((ifq), (m));					\
d312 1
a312 1
	(m) = ifq_deq(ifq);						\
@


1.53
log
@Factorize the bits to check if a L2 route is connected, wether it is
attached to a carp(4) or bridge(4) member, to not dereference rt_ifp
directly.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.52 2015/11/11 10:23:23 mpi Exp $	*/
d101 1
a101 1
 * Structure defining a queue for a network interface.
d103 25
a127 9
struct	ifqueue {
	struct {
		struct	mbuf *head;
		struct	mbuf *tail;
	}			 ifq_q[IFQ_NQUEUES];
	int			 ifq_len;
	int			 ifq_maxlen;
	int			 ifq_drops;
	struct hfsc_if		*ifq_hfsc;
d275 23
d302 2
a303 63
 * Output queues (ifp->if_snd) and internetwork datagram level (pup level 1)
 * input routines have queues of messages stored on ifqueue structures
 * (defined above).  Entries are added to and deleted from these structures
 * by these macros, which should be called with ipl raised to splnet().
 */
#define	IF_QFULL(ifq)		((ifq)->ifq_len >= (ifq)->ifq_maxlen)
#define	IF_DROP(ifq)		((ifq)->ifq_drops++)
#define	IF_ENQUEUE(ifq, m)						\
do {									\
	(m)->m_nextpkt = NULL;						\
	if ((ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail == NULL)		\
		(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].head = m;		\
	else								\
		(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail->m_nextpkt = m; \
	(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail = m;			\
	(ifq)->ifq_len++;						\
} while (/* CONSTCOND */0)
#define	IF_PREPEND(ifq, m)						\
do {									\
	(m)->m_nextpkt = (ifq)->ifq_q[(m)->m_pkthdr.pf.prio].head;	\
	if ((ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail == NULL)		\
		(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail = (m);		\
	(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].head = (m);			\
	(ifq)->ifq_len++;						\
} while (/* CONSTCOND */0)

#define	IF_POLL(ifq, m)							\
do {									\
	int	if_dequeue_prio = IFQ_MAXPRIO;				\
	do {								\
		(m) = (ifq)->ifq_q[if_dequeue_prio].head;		\
	} while (!(m) && --if_dequeue_prio >= 0); 			\
} while (/* CONSTCOND */0)

#define	IF_DEQUEUE(ifq, m)						\
do {									\
	int	if_dequeue_prio = IFQ_MAXPRIO;				\
	do {								\
		(m) = (ifq)->ifq_q[if_dequeue_prio].head;		\
		if (m) {						\
			if (((ifq)->ifq_q[if_dequeue_prio].head =	\
			    (m)->m_nextpkt) == NULL)			\
				(ifq)->ifq_q[if_dequeue_prio].tail = NULL; \
			(m)->m_nextpkt = NULL;				\
			(ifq)->ifq_len--;				\
		}							\
	} while (!(m) && --if_dequeue_prio >= 0);			\
} while (/* CONSTCOND */0)

#define	IF_PURGE(ifq)							\
do {									\
	struct mbuf *__m0;						\
									\
	for (;;) {							\
		IF_DEQUEUE((ifq), __m0);				\
		if (__m0 == NULL)					\
			break;						\
		else							\
			m_freem(__m0);					\
	}								\
} while (/* CONSTCOND */0)
#define	IF_LEN(ifq)		((ifq)->ifq_len)
#define	IF_IS_EMPTY(ifq)	((ifq)->ifq_len == 0)
d307 1
a307 14
	if (HFSC_ENABLED(ifq))						\
		(err) = hfsc_enqueue(((struct ifqueue *)(ifq)), m);	\
	else {								\
		if (IF_QFULL((ifq))) {					\
			(err) = ENOBUFS;				\
		} else {						\
			IF_ENQUEUE((ifq), (m));				\
			(err) = 0;					\
		}							\
	}								\
	if ((err)) {							\
		m_freem((m));						\
		(ifq)->ifq_drops++;					\
	}								\
d312 1
a312 12
	if (HFSC_ENABLED((ifq)))					\
		(m) = hfsc_dequeue(((struct ifqueue *)(ifq)), 1);	\
	else								\
		IF_DEQUEUE((ifq), (m));					\
} while (/* CONSTCOND */0)

#define	IFQ_POLL(ifq, m)						\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(m) = hfsc_dequeue(((struct ifqueue *)(ifq)), 0);	\
	else								\
		IF_POLL((ifq), (m));					\
d317 1
a317 4
	if (HFSC_ENABLED((ifq)))					\
		hfsc_purge(((struct ifqueue *)(ifq)));			\
	else								\
		IF_PURGE((ifq));					\
d320 4
a323 5
#define	IFQ_SET_READY(ifq)	/* nothing */

#define	IFQ_LEN(ifq)			IF_LEN(ifq)
#define	IFQ_IS_EMPTY(ifq)		((ifq)->ifq_len == 0)
#define	IFQ_SET_MAXLEN(ifq, len)	((ifq)->ifq_maxlen = (len))
d358 1
@


1.52
log
@Store the index of the lo0 interface instead of a pointer to its
descriptor.

Allow to get rid of two if_ref() in the output paths.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.51 2015/10/25 11:58:11 mpi Exp $	*/
d428 2
@


1.51
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.50 2015/10/24 10:52:05 reyk Exp $	*/
d405 1
a405 1
extern struct ifnet *lo0ifp;
@


1.50
log
@Add pair(4), a vether-based virtual Ethernet driver to interconnect
rdomains and bridges on the local system.  This can be used to route
through local rdomains, to create L2 devices (like trunks) between
them, and many other things.

Discussed with many, with input from mpi@@
OK sthen@@ phessler@@ yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.49 2015/10/22 17:48:34 mpi Exp $	*/
d132 2
a217 2
					/* check or clean routes (+ or -)'d */
	void	(*ifa_rtrequest)(int, struct rtentry *);
d411 2
d420 1
a427 1
void	p2p_rtrequest(int, struct rtentry *);
d445 1
a445 1
void	lortrequest(int, struct rtentry *);
@


1.49
log
@Kill link_rtrequest(), introduce in 1990 to "fix" the result
of rt_getifa() when adding link level route from outside the
kernel.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.48 2015/10/12 13:17:58 dlg Exp $	*/
d432 3
@


1.48
log
@the pattr argument to IFQ_ENQUEUE is unused, so let's get rid of it.

also the comment above IFQ_ENQUEUE that says the pattr argument is unused.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.47 2015/10/05 15:19:29 uebayasi Exp $	*/
a424 1
void	link_rtrequest(int, struct rtentry *);
@


1.47
log
@Add ifi_oqdrops and its alias to struct if_data.

Necessary bumps in Ports will be handled by sthen@@.

OK mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d327 1
a327 2
/* XXX pattr unused */
#define	IFQ_ENQUEUE(ifq, m, pattr, err)					\
@


1.46
log
@sleep until all references to an interface have been released during detach.

this is done by moving to the refcnt api and using refcnt_finalize.

tested by Hrjove Popovski
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.45 2015/09/28 08:24:53 mpi Exp $	*/
d197 1
@


1.45
log
@Remove "if_tp" from the "struct ifnet".

Instead of violating a layer of abstraction by keeping per pseudo-driver
informations in "struct ifnet", the port trunk is now passed as a cookie
to the interface input handler (ifih).

The time of per pseudo-driver hack in the network stack is over!

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.44 2015/09/27 05:23:50 dlg Exp $	*/
d42 1
d123 1
a123 1
	unsigned int if_refcnt;
@


1.44
log
@pull the m_freem calls out of hfsc_enqueue by having IFQ_ENQUEUE free
the mbuf in both the hfsc and priq error paths.

ok mikeb@@ mpi@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.43 2015/09/13 17:53:44 mpi Exp $	*/
a134 1
	caddr_t	if_tp;			/* used by trunk ports */
@


1.43
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.42 2015/09/13 09:58:03 kettenis Exp $	*/
a332 1
			m_freem((m));					\
d339 2
a340 1
	if ((err))							\
d342 1
@


1.42
log
@Run the interface watchdog timer routine as a task such that we have process
context.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.41 2015/09/12 20:26:06 mpi Exp $	*/
a409 2
int	if_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);
@


1.41
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.40 2015/09/12 13:34:12 mpi Exp $	*/
d153 1
@


1.40
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.39 2015/09/10 18:11:05 dlg Exp $	*/
d409 2
@


1.39
log
@rework how we store and manage the interface index to ifp map in preparation of using SRPs as a backend for if_get.

this also tries to document how things work and what if index 0 is for.

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.38 2015/09/10 16:41:30 mikeb Exp $	*/
d408 1
d440 1
@


1.38
log
@pass a cookie argument to interface input handlers that can be used
to pass additional context or transient data with the similar life
time.

ok mpi, suggestions, hand holding and ok from dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.37 2015/09/10 14:56:41 dlg Exp $	*/
d143 1
a143 1
	u_short	if_index;		/* numeric abbreviation for this if */
d228 1
a228 1
	unsigned short		 ifma_ifidx;	/* Index of the interface */
@


1.37
log
@include srp.h so userland can understand struct srpl.

noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.36 2015/09/10 13:32:19 dlg Exp $	*/
d412 1
a412 1
int	ether_input(struct ifnet *, struct mbuf *);
d444 4
a447 2
void	if_ih_insert(struct ifnet *, int (*)(struct ifnet *, struct mbuf *));
void	if_ih_remove(struct ifnet *, int (*)(struct ifnet *, struct mbuf *));
@


1.36
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.35 2015/09/09 16:01:10 dlg Exp $	*/
d41 1
@


1.35
log
@introduce reference counts for interfaces (ie, struct ifnet *ifp).

if_get can get a reference to an ifp, but it never releases that
reference. this provides an if_put function that can be used to
decrement the refcount.

we cannot come up with a scheme for letting the network stack run on
one (or many) cpus while ioctls are pulling interfaces down on another
cpu without refcounts for the interfaces.

if_put is going in now so we can go through the stack and put the
necessary calls to it in, and then we'll backfill this implementation
to actually check the refcounts when the interface detaches.

ok mpi@@ mikeb@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.34 2015/07/02 09:40:02 mpi Exp $	*/
a112 9
 * Interface input hooks.
 */
struct ifih {
	SLIST_ENTRY(ifih) ifih_next;
	int		(*ifih_input)(struct ifnet *, struct mbuf *);
	int		  ifih_refcnt;
};

/*
d155 1
a155 1
	SLIST_HEAD(, ifih) if_inputs;	/* input routines (dequeue) */
d442 3
@


1.34
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.33 2015/06/30 13:54:42 mpi Exp $	*/
d130 1
@


1.33
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.32 2015/06/02 13:23:55 mpi Exp $	*/
d117 1
a117 1
	int		(*ifih_input)(struct mbuf *);
d419 1
a419 1
int	ether_input(struct mbuf *);
@


1.32
log
@RIP ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.31 2015/05/28 11:57:33 mpi Exp $	*/
d413 1
a413 1
int	if_output(struct ifnet *, struct mbuf *);
@


1.31
log
@Kill unused IF_INPUT_ENQUEUE().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.30 2015/05/26 11:39:07 mpi Exp $	*/
a415 1
void	ether_input_mbuf(struct ifnet *, struct mbuf *);
@


1.30
log
@Now that the Ethernet header is always passed as part of the mbuf, kill
the second (unused) argument of the input packet handlers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.29 2015/05/19 11:09:24 mpi Exp $	*/
a314 10
} while (/* CONSTCOND */0)

#define	IF_INPUT_ENQUEUE(ifq, m)					\
do {									\
	if (IF_QFULL(ifq)) {						\
		IF_DROP(ifq);						\
		m_freem(m);						\
		if_congestion();					\
	} else								\
		IF_ENQUEUE(ifq, m);					\
@


1.29
log
@Take vlan(4) out of ether_input().

To keep the list of input handlers short, multiple vlans share the
same ifih.

if_input_process() now looks if the interface of a mbuf changed to
make sure the corresponding handlers are executed.  This is a hack
and will be improved later.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.28 2015/05/18 13:32:28 reyk Exp $	*/
d117 1
a117 1
	int		(*ifih_input)(struct mbuf *, void *);
d430 1
a430 1
int	ether_input(struct mbuf *, void *);
@


1.28
log
@Move the rdomain from struct ifnet into struct if_data.  This way it
will be exported to userland with the existing sysctl, getifaddrs()
and routing socket (if_msghdr.ifm_data) interfaces that expose
if_data.  All programs and daemons - Apps - that call the
SIOCGIFRDOMAIN ioctl in a getifaddrs() loop or after receiving an
interface message on the routing socket can now remove the pointless
additional ioctl.  In base, that could be: dhclient, isakmpd, dhcpd,
dhcrelay, ntpd, ospfd, ripd, ifconfig.

No ABI breakage because it uses a previously unused pad field in if_data.

OK mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.27 2015/05/15 11:53:06 claudio Exp $	*/
d118 1
@


1.27
log
@Give carp(4) interfaces their own low priority. The change should not
change behaviour for now but will allow to share the same address with
the parent interface without major hacks.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.26 2015/05/15 10:15:13 mpi Exp $	*/
a154 1
	u_int	if_rdomain;		/* routing instance */
d205 1
@


1.26
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.25 2015/04/23 09:45:24 dlg Exp $	*/
d392 1
@


1.25
log
@replace the use of struct ifqueue in pipex with mbuf_queues.

this has a slight semantic change. previously pipex would only
process up to 128 packets on the input and output queues at a time
and would reschedule the softint if there were any left. now it
mq_delists the current set of pending packets and only processes
them. if anything is added to the queues later they'll cause the
softint to run again.

this in turn lets us deprecate sysctl_ifq since nothing uses it
anymore. because niqueues are mostly wrappers around mbuf_queues,
we can provide sysctl_mq and just #define sysctl_niq to it.

pipex bits are ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.24 2015/04/07 10:46:20 mpi Exp $	*/
d421 1
@


1.24
log
@Do not pass an `ifp' argument to interface input handlers since it
might be overwritten by pseudo-drivers.

ok dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.23 2015/04/01 04:00:55 dlg Exp $	*/
d414 2
d446 2
a447 4
int     sysctl_ifq(int *, u_int, void *, size_t *, void *, size_t,
	    struct ifqueue *);
int     sysctl_niq(int *, u_int, void *, size_t *, void *, size_t,
	    struct niqueue *);
@


1.23
log
@create a taskq for network tasks to run in. cut ether_input_mbuf
and if_input up so the work ether_input does gets run on the task
instead of directly from hardware receive handlers.

this is a step toward letting hardware drivers run without biglock
by shoving the work the stack does which needs that lock sideways.

general agreement at s2k15
ok mpi@@ kettenis@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.22 2015/03/25 11:49:02 dlg Exp $	*/
d117 1
a117 1
	int		(*ifih_input)(struct ifnet *, void *, struct mbuf *);
d425 1
a425 1
int	ether_input(struct ifnet *, void *, struct mbuf *);
@


1.22
log
@introduce code for network input queues. these are to replace the
use of struct ifqueue for things handled by softnet. they instead
use an mbuf_queue (yay mpsafe) and wrap up the schednetisr and
if_congestion handling.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.21 2015/03/18 12:23:15 dlg Exp $	*/
d421 1
a421 2
#define	ether_input_mbuf(ifp, m)        ether_input((ifp), NULL, (m))

@


1.21
log
@remove the congestion handling from struct ifqueue.

its only used for the ip and ip6 network stack input queues, so it
seems unfair that every instance of ifqueue has to carry a pointer
around for this specific use case.

this moves the congestion marker to a kernel global. if we detect
that we're congested, we assume the whole system is busy and punish
all input queues.

marking a system as congested is done by setting the global to the
current value of ticks. as the system moves away from that value,
it moves away from being congested until the comparison fails.

written at s2k15
ok henning@@ beck@@ bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.20 2015/02/09 03:09:57 dlg Exp $	*/
d40 1
a71 2
struct mbuf;
struct mbuf_list;
d393 22
d447 2
@


1.20
log
@tweak the new if_input function so it takes an mbuf_list instead
of a single mbuf. this forces us to batch work between the hardware
rx handlers and the stack.

this includes a converstion of bge from ether_input to if_input.

ok claudio@@ pelikan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.19 2015/02/08 06:00:52 mpi Exp $	*/
a110 1
	struct timeout		*ifq_congestion;
d322 1
a322 2
		if (!(ifq)->ifq_congestion)				\
			if_congestion(ifq);				\
a423 1
void	if_congestion(struct ifqueue *);
@


1.19
log
@Introduce if_input() a function to pass packets dequeued from a
recieving ring to the stack.

if_input() is at the moment a drop-in replacement for ether_input_mbuf()
but will let us stack pseudo-driver in a nice way in order to no longer
call ether_input() recursively.

ok pelikan@@, reyk@@, blambert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.18 2015/02/06 06:42:36 henning Exp $	*/
d72 1
d400 1
a400 1
void	if_input(struct ifnet *, struct mbuf *);
@


1.18
log
@since I just touched this file and thus cause an almost full recompile of
everything in the kernel for everybody anyway, can as well use the
opportunity to move the block with the IF_* macros down next to the IFQ_*
versions; has always been slightly confusing - was like that due to the
long gone ALTQ versions of these macros. claudio agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.17 2015/02/06 06:38:08 henning Exp $	*/
d114 8
d164 2
d398 3
d406 1
a406 1
void	ether_input(struct ifnet *, struct ether_header *, struct mbuf *);
@


1.17
log
@g/c unused IFQ_INC_LEN, IFQ_DEC_LEN and IFQ_INC_DROPS, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.15 2014/12/08 10:46:14 mpi Exp $	*/
d198 55
d254 3
a332 60
#define	IFQ_MAXLEN	256
#define	IFNET_SLOWHZ	1		/* granularity is 1 second */
#endif

/*
 * The ifaddr structure contains information about one address
 * of an interface.  They are maintained by the different address families,
 * are allocated and attached when an address is set, and are linked
 * together so all addresses for an interface can be located.
 */
struct ifaddr {
	struct	sockaddr *ifa_addr;	/* address of interface */
	struct	sockaddr *ifa_dstaddr;	/* other end of p-to-p link */
#define	ifa_broadaddr	ifa_dstaddr	/* broadcast address interface */
	struct	sockaddr *ifa_netmask;	/* used to determine subnet */
	struct	ifnet *ifa_ifp;		/* back-pointer to interface */
	TAILQ_ENTRY(ifaddr) ifa_list;	/* list of addresses for interface */
					/* check or clean routes (+ or -)'d */
	void	(*ifa_rtrequest)(int, struct rtentry *);
	u_int	ifa_flags;		/* interface flags, see below */
	u_int	ifa_refcnt;		/* number of `rt_ifa` references */
	int	ifa_metric;		/* cost of going out this interface */
};

#define	IFA_ROUTE		0x01	/* Auto-magically installed route */

/*
 * Interface multicast address.
 */
struct ifmaddr {
	struct sockaddr		*ifma_addr;	/* Protocol address */
	unsigned short		 ifma_ifidx;	/* Index of the interface */
	unsigned int		 ifma_refcnt;	/* Count of references */
	TAILQ_ENTRY(ifmaddr)	 ifma_list;	/* Per-interface list */
};

/*
 * interface groups
 */

struct ifg_group {
	char			 ifg_group[IFNAMSIZ];
	u_int			 ifg_refcnt;
	caddr_t			 ifg_pf_kif;
	int			 ifg_carp_demoted;
	TAILQ_HEAD(, ifg_member) ifg_members;
	TAILQ_ENTRY(ifg_group)	 ifg_next;
};

struct ifg_member {
	TAILQ_ENTRY(ifg_member)	 ifgm_next;
	struct ifnet		*ifgm_ifp;
};

struct ifg_list {
	struct ifg_group	*ifgl_group;
	TAILQ_ENTRY(ifg_list)	 ifgl_next;
};

#ifdef _KERNEL
@


1.16
log
@Change the link state change routing message generation to a taskq.
One less workq to worry about.

Tweaks from many. ok mpi@@ mikeb@@
@
text
@a380 3
#define	IFQ_INC_LEN(ifq)		((ifq)->ifq_len++)
#define	IFQ_DEC_LEN(ifq)		(--(ifq)->ifq_len)
#define	IFQ_INC_DROPS(ifq)		((ifq)->ifq_drops++)
@


1.15
log
@There's no good reason to keep into "struct ifnet" a pointer that's only
used by enc(4) devices to attach their routes.

ok sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.14 2014/12/05 15:50:04 mpi Exp $	*/
d81 1
d153 1
@


1.14
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.13 2014/12/01 15:06:54 mikeb Exp $	*/
a169 1
	struct	ifaddr *if_lladdr;	/* pointer to link-level address */
@


1.13
log
@Make every interface with a watchdog register it's own slow timeout

This removes the system wide if_slowtimo timeout and lets every
interface with a valid if_watchdog method register it's own in
order to get rid of the ifnet loop in the softclock context and
avoid further complications with concurrent access to the ifnet
list.

ok deraadt, input and ok mpi, looked at by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.12 2014/07/08 04:02:14 dlg Exp $	*/
a400 25

void	if_alloc_sadl(struct ifnet *);
void	if_free_sadl(struct ifnet *);
void	if_attach(struct ifnet *);
void	if_attachdomain(void);
void	if_attachtail(struct ifnet *);
void	if_attachhead(struct ifnet *);
void	if_detach(struct ifnet *);
void	if_down(struct ifnet *);
void	if_downall(void);
void	if_link_state_change(struct ifnet *);
void	if_slowtimo(void *);
void	if_up(struct ifnet *);
int	ifconf(u_long, caddr_t);
void	ifinit(void);
int	ifioctl(struct socket *, u_long, caddr_t, struct proc *);
int	ifpromisc(struct ifnet *, int);
struct	ifg_group *if_creategroup(const char *);
int	if_addgroup(struct ifnet *, const char *);
int	if_delgroup(struct ifnet *, const char *);
void	if_group_routechange(struct sockaddr *, struct sockaddr *);
struct	ifnet *ifunit(const char *);
struct	ifnet *if_get(unsigned int);
void	if_start(struct ifnet *);
void	ifnewlladdr(struct ifnet *);
@


1.12
log
@introduce the if_rxr api. it is intended to pull the rx ring accounting
out of the mbuf layer, and break the assumption that an interface will
only have a single ring per mbuf cluster size.

mpi@@ is ok with moving this forward
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.11 2014/05/26 08:33:48 mpi Exp $	*/
d75 1
d151 1
@


1.11
log
@Document that this reference counter is not generic.  It indicates how
many route entries are pointing to this address.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.10 2014/05/05 11:44:33 mpi Exp $	*/
d452 11
@


1.10
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.9 2014/04/23 09:30:57 mpi Exp $	*/
d292 1
a292 1
	u_int	ifa_refcnt;		/* count of references */
@


1.9
log
@You don't want to use ifa_ifwithroute(), it exists for to the routing
crazyness only.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.8 2014/04/19 15:57:25 henning Exp $	*/
d431 1
@


1.8
log
@ifnet's if_snd becomes a regular ifqueue instead of ifaltq, the need to
keep ifqueue and ifaltq in sync is gone and thus the comment obsolete,
and finally there is no more need to include if_altq.h either
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.7 2014/04/19 11:26:10 henning Exp $	*/
a427 2
struct	ifaddr *ifa_ifwithroute(int, struct sockaddr *,
					struct sockaddr *, u_int);
@


1.7
log
@the altq versions of the IFQ_* macros can finally go. chances of this
file becoming readable increase.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.5 2014/03/20 13:19:06 mpi Exp $	*/
a39 1
#include <altq/if_altq.h>
a97 1
 * XXX keep in sync with struct ifaltq.
d169 1
a169 1
	struct	ifaltq if_snd;		/* output queue (includes altq) */
@


1.6
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@a333 67
/* XXX the IFQ_ macros are a giant mess right now. cleanup once altq gone. */

#ifdef ALTQ

/* XXX pattr unused */
/* if_snd becomes ifqueue when altq is gone and the casts go away */
#define	IFQ_ENQUEUE(ifq, m, pattr, err)					\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(err) = hfsc_enqueue(((struct ifqueue *)(ifq)), (m));	\
	else if (ALTQ_IS_ENABLED((ifq))) {				\
		m->m_pkthdr.pf.prio = IFQ_MAXPRIO;			\
		ALTQ_ENQUEUE((ifq), (m), (pattr), (err));		\
	} else {							\
		if (IF_QFULL((ifq))) {					\
			m_freem((m));					\
			(err) = ENOBUFS;				\
		} else {						\
			IF_ENQUEUE((ifq), (m));				\
			(err) = 0;					\
		}							\
	}								\
	if ((err))							\
		(ifq)->ifq_drops++;					\
} while (/* CONSTCOND */0)

#define	IFQ_DEQUEUE(ifq, m)						\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(m) = hfsc_dequeue(((struct ifqueue *)(ifq)), 1);	\
	else if (OLDTBR_IS_ENABLED((ifq)))				\
		(m) = oldtbr_dequeue((ifq), ALTDQ_REMOVE);		\
	else if (ALTQ_IS_ENABLED((ifq)))				\
		ALTQ_DEQUEUE((ifq), (m));				\
	else								\
		IF_DEQUEUE((ifq), (m));					\
} while (/* CONSTCOND */0)

#define	IFQ_POLL(ifq, m)						\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(m) = hfsc_dequeue(((struct ifqueue *)(ifq)), 0);	\
	else if (OLDTBR_IS_ENABLED((ifq)))				\
		(m) = oldtbr_dequeue((ifq), ALTDQ_POLL);		\
	else if (ALTQ_IS_ENABLED((ifq)))				\
		ALTQ_POLL((ifq), (m));					\
	else								\
		IF_POLL((ifq), (m));					\
} while (/* CONSTCOND */0)

#define	IFQ_PURGE(ifq)							\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		hfsc_purge(((struct ifqueue *)(ifq)));			\
	else if (ALTQ_IS_ENABLED((ifq)))				\
		ALTQ_PURGE(ifq);					\
	else								\
		IF_PURGE((ifq));					\
} while (/* CONSTCOND */0)

#define	IFQ_SET_READY(ifq)						\
do {									\
	((ifq)->altq_flags |= ALTQF_READY);				\
} while (/* CONSTCOND */0)

#else /* !ALTQ */

a376 2

#endif /* ALTQ */
@


1.5
log
@Do not pull <sys/tree.h> unconditionally in <net/if.h>, only the address
tree and the 80211 nodes need it.

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.4 2014/01/21 10:18:26 mpi Exp $	*/
d293 1
a293 1
	u_int	ifa_flags;		/* mostly rt_flags for cloning */
d297 2
a298 1
#define	IFA_ROUTE	RTF_UP		/* route installed */
@


1.4
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.3 2013/11/28 11:05:18 mpi Exp $	*/
a39 1
#include <sys/tree.h>
a297 8

struct ifaddr_item {
	RB_ENTRY(ifaddr_item)	 ifai_entry;
	struct sockaddr		*ifai_addr;
	struct ifaddr		*ifai_ifa;
	struct ifaddr_item	*ifai_next;
	u_int			 ifai_rdomain;
};
@


1.3
log
@IFAFREE() was resurrected from the dead with the new bandwith subsytem,
send it back in the Attic.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.2 2013/11/28 10:16:44 mpi Exp $	*/
d313 1
a313 1
	struct ifnet		*ifma_ifp;	/* Back pointer to ifnet */
@


1.2
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_var.h,v 1.1 2013/11/21 17:32:12 mikeb Exp $	*/
a341 8
#define	IFAFREE(ifa) \
do { \
	if ((ifa)->ifa_refcnt <= 0) \
		ifafree(ifa); \
	else \
		(ifa)->ifa_refcnt--; \
} while (/* CONSTCOND */0)

@


1.1
log
@split kernel parts of the if.h into a separate header file if_var.h
which allows us to modify ifnet structure in a relatively safe way;
discussed with deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.152 2013/11/09 06:38:42 dlg Exp $	*/
d126 1
d306 10
@

