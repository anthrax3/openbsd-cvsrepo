head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.2
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11;
locks; strict;
comment	@ * @;


1.29
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.28;
commitid	VyLWTsbepAOk7VQM;

1.28
date	2016.11.29.10.09.57;	author reyk;	state Exp;
branches;
next	1.27;
commitid	KGFiK26819ueNC3N;

1.27
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.26;
commitid	Xo6g1xk26RWDGcjJ;

1.26
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.25;
commitid	ILbVM1M3uPNjwswz;

1.25
date	2015.10.25.12.05.40;	author mpi;	state Exp;
branches;
next	1.24;
commitid	iXTa9MhdGfWGiTE6;

1.24
date	2015.05.23.08.31.05;	author mpi;	state Exp;
branches;
next	1.23;
commitid	SyU080RZMi67aTvX;

1.23
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.22;
commitid	p4LJxGKbi0BU2cG6;

1.22
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.21;
commitid	zhW8jJrfVCoAthrR;

1.21
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	mdGXHklUZmESVFlY;

1.20
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.19;
commitid	B4dZSbxas1X1IpXI;

1.19
date	2013.10.19.14.46.31;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.26.13.19.26;	author mpi;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.22.15.59.40;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.02.21.45.49;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.02.21.32.41;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.02.04.26.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.23.00.35.21;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.12.11.37.08;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.12.11.31.23;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.12.11.29.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.12.11.28.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.12.03.41.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.22.12.33.25;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.18.02.11.53;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.18.02.10.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.12.06.37.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.09.20.38.33;	author mpf;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.09.03.16.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/* $OpenBSD: if_vether.c,v 1.28 2016/11/29 10:09:57 reyk Exp $ */

/*
 * Copyright (c) 2009 Theo de Raadt
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

void	vetherattach(int);
int	vetherioctl(struct ifnet *, u_long, caddr_t);
void	vetherstart(struct ifnet *);
int	vether_clone_create(struct if_clone *, int);
int	vether_clone_destroy(struct ifnet *);
int	vether_media_change(struct ifnet *);
void	vether_media_status(struct ifnet *, struct ifmediareq *);

struct vether_softc {
	struct arpcom		sc_ac;
	struct ifmedia		sc_media;
};

struct if_clone	vether_cloner =
    IF_CLONE_INITIALIZER("vether", vether_clone_create, vether_clone_destroy);

int
vether_media_change(struct ifnet *ifp)
{
	return (0);
}

void
vether_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	imr->ifm_active = IFM_ETHER | IFM_AUTO;
	imr->ifm_status = IFM_AVALID | IFM_ACTIVE;
}

void
vetherattach(int nvether)
{
	if_clone_attach(&vether_cloner);
}

int
vether_clone_create(struct if_clone *ifc, int unit)
{
	struct ifnet		*ifp;
	struct vether_softc	*sc;

	if ((sc = malloc(sizeof(*sc),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	ifp = &sc->sc_ac.ac_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "vether%d", unit);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ether_fakeaddr(ifp);

	ifp->if_softc = sc;
	ifp->if_ioctl = vetherioctl;
	ifp->if_start = vetherstart;
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	ifp->if_hardmtu = ETHER_MAX_HARDMTU_LEN;
	ifp->if_capabilities = IFCAP_VLAN_MTU;

	ifmedia_init(&sc->sc_media, 0, vether_media_change,
	    vether_media_status);
	ifmedia_add(&sc->sc_media, IFM_ETHER | IFM_AUTO, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER | IFM_AUTO);

	if_attach(ifp);
	ether_ifattach(ifp);
	return (0);
}

int
vether_clone_destroy(struct ifnet *ifp)
{
	struct vether_softc	*sc = ifp->if_softc;

	ifmedia_delete_instance(&sc->sc_media, IFM_INST_ANY);
	ether_ifdetach(ifp);
	if_detach(ifp);
	free(sc, M_DEVBUF, sizeof(*sc));
	return (0);
}

/*
 * The bridge has magically already done all the work for us,
 * and we only need to discard the packets.
 */
void
vetherstart(struct ifnet *ifp)
{
	struct mbuf		*m;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			return;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif /* NBPFILTER > 0 */

		m_freem(m);
	}
}

int
vetherioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct vether_softc	*sc = (struct vether_softc *)ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	int			 error = 0, link_state;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			ifp->if_flags |= IFF_RUNNING;
			link_state = LINK_STATE_UP;
		} else {
			ifp->if_flags &= ~IFF_RUNNING;
			link_state = LINK_STATE_DOWN;
		}
		if (ifp->if_link_state != link_state) {
			ifp->if_link_state = link_state;
			if_link_state_change(ifp);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}
	return (error);
}
@


1.28
log
@For virtual Ethernet drivers that don't have a technical limit of the
hardmtu, pick a value of 65435 that leaves space for some
encapsulation and almost a complete max-IP packet.  After some
discussion we picked this arbitrary value.

OK dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.27 2016/04/13 11:41:15 mpi Exp $ */
a135 1
		ifp->if_opackets++;
@


1.27
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.26 2015/12/05 10:07:55 tedu Exp $ */
d92 1
@


1.26
log
@remove old lint annotations
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.25 2015/10/25 12:05:40 mpi Exp $ */
a90 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.25
log
@arp_ifinit() is no longer required.
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.24 2015/05/23 08:31:05 mpi Exp $ */
a140 1
/* ARGSUSED */
@


1.24
log
@Pass output packets to bpf(4).  This is helpful when debugging stack
issues.

ok reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.23 2015/03/14 03:38:51 jsg Exp $ */
a145 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a151 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.23
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.22 2014/12/19 17:14:40 tedu Exp $ */
d32 5
a124 1
	int			 s;
a126 1
		s = splnet();
a127 2
		splx(s);

d130 6
@


1.22
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.21 2014/11/23 07:39:02 deraadt Exp $ */
a26 1
#include <net/if_dl.h>
@


1.21
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.20 2014/07/12 18:44:22 tedu Exp $ */
a29 1
#ifdef INET
a31 1
#endif
a139 1
#ifdef INET
a140 1
#endif
a146 1
#ifdef INET
a148 1
#endif
@


1.20
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.19 2013/10/19 14:46:31 mpi Exp $ */
d111 1
a111 1
	free(sc, M_DEVBUF, 0);
@


1.19
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.18 2013/03/28 16:45:16 tedu Exp $ */
d111 1
a111 1
	free(sc, M_DEVBUF);
@


1.18
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.17 2013/03/26 13:19:26 mpi Exp $ */
d172 1
a172 16
	case SIOCDELMULTI: {
		if (ifr == 0) {
			error = EAFNOSUPPORT;	   /* XXX */
			break;
		}
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ac) :
		    ether_delmulti(ifr, &sc->sc_ac);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly. The good thing is we do
			 * not have a hardware filter (:
			 */
			error = 0;
		}
a173 1
	}
@


1.17
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.16 2011/07/22 15:59:40 deraadt Exp $ */
a21 1
#include <sys/proc.h>
@


1.16
log
@use ifmedia_delete_instance() when destroying a vether
from Martin Pelikan
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.15 2010/04/02 21:45:49 deraadt Exp $ */
d89 1
a89 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.15
log
@ugly spacing
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.14 2010/04/02 21:32:41 stsp Exp $ */
d109 1
@


1.14
log
@Special-case SIOCADDMULTI and SIOCDELMULTI ioctls, based on code from if_tun.
Makes IPv6 work with if_vether.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.13 2010/04/02 04:26:53 deraadt Exp $ */
d74 1
a74 1
	struct ifnet 		*ifp;
a100 1

d122 1
a122 1
	struct mbuf 		*m;
a176 1

d183 1
a183 1
			 * filter accordingly. The good thing is we do 
@


1.13
log
@allow this to compile in the never-gonna-happen world without INET
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.12 2010/03/23 00:35:21 dlg Exp $ */
d171 21
@


1.12
log
@dont maintain a list of vether devices inside the driver if they are never
looked up. can vether get any smaller?

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.11 2010/01/12 11:37:08 deraadt Exp $ */
d143 1
d145 1
@


1.11
log
@delete more left-over stuff from vether development
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.10 2010/01/12 11:31:23 deraadt Exp $ */
a46 1
	LIST_ENTRY(vether_softc) sc_list;
a48 1
LIST_HEAD(, vether_softc)	vether_list;
a67 1
	LIST_INIT(&vether_list);
a75 1
	int 			 s;
a101 3
	s = splnet();
	LIST_INSERT_HEAD(&vether_list, sc, sc_list);
	splx(s);
a108 5
	int			 s;

	s = splnet();
	LIST_REMOVE(sc, sc_list);
	splx(s);
@


1.10
log
@the bridge does bpf for us, so we do not need bpf.h
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.9 2010/01/12 11:29:35 deraadt Exp $ */
a29 5
#include <net/if_types.h>

#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>
a33 1
#include <netinet/in_var.h>
a53 1

a158 1
	ifr = (struct ifreq *)data;
@


1.9
log
@delete the unused debug macros
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.8 2010/01/12 11:28:09 deraadt Exp $ */
a18 3
#include "vether.h"
#include "bpfilter.h"

a39 4
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
@


1.8
log
@do not need rndvar.h anymore
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.7 2010/01/12 03:41:29 deraadt Exp $ */
a46 6
#endif

#ifdef VETHER_DEBUG
#define DPRINTF(x)    do { if (vetherdebug) printf x ; } while (0)
#else
#define DPRINTF(x)
@


1.7
log
@Unify the various fake ethernet generators as ether_fakeaddr() which
is safe for both hardware devices and virtual devices
ok mpf, kettenis, moaning and groaning and slow acceptance from mcbride
XXX should loop checking for uniqueness after new henning diff goes in
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.6 2009/11/22 12:33:25 deraadt Exp $ */
a43 2

#include <dev/rndvar.h>
@


1.6
log
@Add a lot of bpf and counter manipulation to the bridge.  The bridge
sneaks packets on and off network interfaces in some cases without
calling the interrupt, start, or output functions, and thus must do
these tasks which the drivers cannot do.  The gif and vether are
rather special.  Someone should re-check gre.
ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.5 2009/11/18 02:11:53 deraadt Exp $ */
a100 1
	u_int32_t		 macaddr_rnd;
a106 11
	/* from if_tun.c: generate fake MAC address: 00 bd xx xx xx unit_no */
	sc->sc_ac.ac_enaddr[0] = 0x00;
	sc->sc_ac.ac_enaddr[1] = 0xbd;
	/*
	 * This no longer happens pre-scheduler so let's use the real
	 * random subsystem instead of random().
	 */
	macaddr_rnd = arc4random();
	bcopy(&macaddr_rnd, &sc->sc_ac.ac_enaddr[2], sizeof(u_int32_t));
	sc->sc_ac.ac_enaddr[5] = (u_char)unit + 1;

d110 1
@


1.5
log
@improve the bpf path.  packets we send out via the bridge are seen, but
those that come in the bridge are still invisible.  the bridge is going
to have to bpf those for us.
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.4 2009/11/18 02:10:45 deraadt Exp $ */
d162 2
a163 1
 * Start output on the vether interface.
d169 1
a169 1
	int			 s, inout;
d178 2
a179 21

		inout = (m->m_flags & M_PROTO1) ?
		    BPF_DIRECTION_IN : BPF_DIRECTION_OUT;
		m->m_flags &= ~M_PROTO1;

		if (inout == BPF_DIRECTION_IN) {
#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, inout);
#endif
			ether_input_mbuf(ifp, m);
			ifp->if_ipackets++;
		} else {
#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap_ether(ifp->if_bpf, m, inout);
#endif
			ifp->if_opackets++;
			ifp->if_obytes += m->m_pkthdr.len;
			m_freem(m);
		}
@


1.4
log
@set IFCAP_VLAN_MTU; from brad
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.3 2009/11/12 06:37:39 deraadt Exp $ */
d18 1
d20 1
a46 1
#include "bpfilter.h"
d182 1
d184 2
a185 2
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, inout);
a186 2

		if (inout == BPF_DIRECTION_IN) {
d190 4
@


1.3
log
@count packets; from claudio
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.2 2009/11/09 20:38:33 mpf Exp $ */
d121 1
d127 2
@


1.2
log
@s/MPLS_DEBUG/VETHER_DEBUG
OK deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.1 2009/11/09 03:16:05 deraadt Exp $ */
d183 1
a183 1
		if (inout == BPF_DIRECTION_IN)
d185 4
a188 1
		else
d190 1
@


1.1
log
@vether(4) is a virtual ethernet device driver which can be used
so that a bridge-etherip-tunnel host can join into the bridge itself.
It is ridiculous that this capability was missing from our network
stack portfolio, considering we have bgp and ospf daemons...
discussed at length with claudio
@
text
@d1 1
a1 1
/* $OpenBSD: if_vether.c,v 1.16 2009/07/13 12:41:46 dlg Exp $ */
d50 1
a50 1
#ifdef MPLS_DEBUG
@

