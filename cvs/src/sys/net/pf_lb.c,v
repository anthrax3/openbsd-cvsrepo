head	1.61;
access;
symbols
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.55.0.4
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.61
date	2017.07.12.14.07.55;	author bluhm;	state Exp;
branches;
next	1.60;
commitid	emOOzSX58oPKcJhV;

1.60
date	2017.04.23.11.37.11;	author sthen;	state Exp;
branches;
next	1.59;
commitid	rW62UNLR6lCCiL79;

1.59
date	2017.02.08.01.20.40;	author jsg;	state Exp;
branches;
next	1.58;
commitid	GOfENPgflzQa2g5W;

1.58
date	2016.10.26.21.07.22;	author bluhm;	state Exp;
branches;
next	1.57;
commitid	aaKAr0kv3QWNHoVo;

1.57
date	2016.09.27.04.57.17;	author dlg;	state Exp;
branches;
next	1.56;
commitid	irzdR7hwk1GHVaEu;

1.56
date	2016.09.27.02.51.12;	author dlg;	state Exp;
branches;
next	1.55;
commitid	bZuzILta8BoFCDiT;

1.55
date	2016.07.19.12.51.19;	author henning;	state Exp;
branches;
next	1.54;
commitid	eufdLiL7BVjIvgRs;

1.54
date	2016.06.24.13.55.57;	author bluhm;	state Exp;
branches;
next	1.53;
commitid	96j9xEgVzzLIvwdy;

1.53
date	2016.06.15.11.36.06;	author mikeb;	state Exp;
branches;
next	1.52;
commitid	M8Mky6ZXisJyQBHU;

1.52
date	2015.11.24.13.37.16;	author mpi;	state Exp;
branches;
next	1.51;
commitid	djjKhPvMtRdFfuFJ;

1.51
date	2015.10.15.19.48.44;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	ahQEiVs4I5oppDLo;

1.50
date	2015.10.13.19.32.31;	author sashan;	state Exp;
branches;
next	1.49;
commitid	2CkJMFIEZK18G5IB;

1.49
date	2015.08.03.13.33.12;	author jsg;	state Exp;
branches;
next	1.48;
commitid	nqm45UMmbBG79jyS;

1.48
date	2015.07.20.18.42.08;	author jsg;	state Exp;
branches;
next	1.47;
commitid	nffqezEm9k9xuYCt;

1.47
date	2015.07.18.19.19.00;	author sashan;	state Exp;
branches;
next	1.46;
commitid	JLCIxhdc71KA1Osw;

1.46
date	2015.07.18.15.19.44;	author sashan;	state Exp;
branches;
next	1.45;
commitid	FkfdBMmgICAjEgne;

1.45
date	2015.07.17.18.39.55;	author jsg;	state Exp;
branches;
next	1.44;
commitid	JsC6hJslv3DtRbzi;

1.44
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.43;
commitid	STtcOm1B3VSMXz2h;

1.43
date	2015.06.03.11.57.37;	author yasuoka;	state Exp;
branches;
next	1.42;
commitid	gT6jfXKOFFlD6aiN;

1.42
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.41;
commitid	p4LJxGKbi0BU2cG6;

1.41
date	2015.01.06.01.49.45;	author jsg;	state Exp;
branches;
next	1.40;
commitid	bK65QYxP7xuL9Ncd;

1.40
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.39;
commitid	zhW8jJrfVCoAthrR;

1.39
date	2014.12.19.13.04.08;	author reyk;	state Exp;
branches;
next	1.38;
commitid	ctnssYdFDfym7i2Z;

1.38
date	2014.12.19.12.31.03;	author mcbride;	state Exp;
branches;
next	1.37;
commitid	RZkjealeazvSPfHp;

1.37
date	2014.12.18.19.02.56;	author tedu;	state Exp;
branches;
next	1.36;
commitid	PpWhpuDZKmf4pz4j;

1.36
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.35;
commitid	Z1vcFtHO8wRH0yRt;

1.35
date	2014.11.10.18.49.42;	author bluhm;	state Exp;
branches;
next	1.34;
commitid	WsnKJSmVTEoGHu14;

1.34
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.33;
commitid	ZqXwxwmeo3l29NOg;

1.33
date	2014.08.14.07.55.17;	author blambert;	state Exp;
branches;
next	1.32;
commitid	1KEQDaZSvIZAWzRh;

1.32
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.31;
commitid	DQakU8LLWV6Iwx84;

1.31
date	2014.07.02.13.06.00;	author mikeb;	state Exp;
branches;
next	1.30;
commitid	JckIzIJWRz2qRDUp;

1.30
date	2013.10.30.11.21.26;	author mikeb;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.30.11.18.32;	author mikeb;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.17.16.27.42;	author bluhm;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.29.14.59.52;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.29.14.54.45;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.29.14.53.05;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2012.07.09.15.20.57;	author zinke;	state Exp;
branches;
next	1.20;

1.20
date	2012.02.03.01.57.51;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.13.18.23.40;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2011.09.18.11.17.57;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.29.10.48.35;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.03.23.37.55;	author zinke;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.17.12.44.05;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.27.01.39.43;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.04.14.10.12;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2009.12.14.12.31.45;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.07.08.27.45;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.01.13.42.00;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.13.27.34;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.05.03.09.37;	author mcbride;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.18.20.06.23;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.12.02.13.15;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.29.15.12.28;	author pyr;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Use a 32 bit variable to detect integer overflow when searching for
an unused nat port.  Prevents a possible endless loop if high port
is 65535 or low port is 0.
report and analysis Jingmin Zhou; OK sashan@@ visa@@
@
text
@/*	$OpenBSD: pf_lb.c,v 1.60 2017/04/23 11:37:11 sthen Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002 - 2008 Henning Brauer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include "bpfilter.h"
#include "pflog.h"
#include "pfsync.h"
#include "pflow.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/filio.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/kernel.h>
#include <sys/time.h>
#include <sys/pool.h>
#include <sys/rwlock.h>
#include <sys/syslog.h>
#include <sys/stdint.h>

#include <crypto/siphash.h>

#include <net/if.h>
#include <net/bpf.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/if_ether.h>

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#endif /* INET6 */

#include <net/pfvar.h>
#include <net/pfvar_priv.h>

#if NPFLOG > 0
#include <net/if_pflog.h>
#endif	/* NPFLOG > 0 */

#if NPFLOW > 0
#include <net/if_pflow.h>
#endif	/* NPFLOW > 0 */

#if NPFSYNC > 0
#include <net/if_pfsync.h>
#endif /* NPFSYNC > 0 */

u_int64_t		 pf_hash(struct pf_addr *, struct pf_addr *,
			    struct pf_poolhashkey *, sa_family_t);
int			 pf_get_sport(struct pf_pdesc *, struct pf_rule *,
			    struct pf_addr *, u_int16_t *, u_int16_t,
			    u_int16_t, struct pf_src_node **);
int			 pf_get_transaddr_af(struct pf_rule *,
			    struct pf_pdesc *, struct pf_src_node **);
int			 pf_map_addr_sticky(sa_family_t, struct pf_rule *,
			    struct pf_addr *, struct pf_addr *,
			    struct pf_src_node **, struct pf_pool *,
			    enum pf_sn_types);

u_int64_t
pf_hash(struct pf_addr *inaddr, struct pf_addr *hash,
    struct pf_poolhashkey *key, sa_family_t af)
{
	uint64_t res = 0;
#ifdef INET6
	union {
		uint64_t hash64;
		uint32_t hash32[2];
	} h;
#endif	/* INET6 */

	switch (af) {
	case AF_INET:
		res = SipHash24((SIPHASH_KEY *)key,
		    &inaddr->addr32[0], sizeof(inaddr->addr32[0]));
		hash->addr32[0] = res;
		break;
#ifdef INET6
	case AF_INET6:
		res = SipHash24((SIPHASH_KEY *)key, &inaddr->addr32[0],
		    4 * sizeof(inaddr->addr32[0]));
		h.hash64 = res;
		hash->addr32[0] = h.hash32[0];
		hash->addr32[1] = h.hash32[1];
		/*
		 * siphash isn't big enough, but flipping it around is
		 * good enough here.
		 */
		hash->addr32[2] = ~h.hash32[1];
		hash->addr32[3] = ~h.hash32[0];
		break;
#endif /* INET6 */
	default:
		unhandled_af(af);
	}
	return (res);
}

int
pf_get_sport(struct pf_pdesc *pd, struct pf_rule *r,
    struct pf_addr *naddr, u_int16_t *nport, u_int16_t low, u_int16_t high,
    struct pf_src_node **sn)
{
	struct pf_state_key_cmp	key;
	struct pf_addr		init_addr;
	u_int16_t		cut;
	int			dir = (pd->dir == PF_IN) ? PF_OUT : PF_IN;
	int			sidx = pd->sidx;
	int			didx = pd->didx;

	bzero(&init_addr, sizeof(init_addr));
	if (pf_map_addr(pd->naf, r, &pd->nsaddr, naddr, &init_addr, sn, &r->nat,
	    PF_SN_NAT))
		return (1);

	if (pd->proto == IPPROTO_ICMP) {
		if (pd->ndport == htons(ICMP_ECHO)) {
			low = 1;
			high = 65535;
		} else
			return (0);	/* Don't try to modify non-echo ICMP */
	}
#ifdef INET6
	if (pd->proto == IPPROTO_ICMPV6) {
		if (pd->ndport == htons(ICMP6_ECHO_REQUEST)) {
			low = 1;
			high = 65535;
		} else
			return (0);	/* Don't try to modify non-echo ICMP */
	}
#endif /* INET6 */

	do {
		key.af = pd->naf;
		key.proto = pd->proto;
		key.rdomain = pd->rdomain;
		PF_ACPY(&key.addr[didx], &pd->ndaddr, key.af);
		PF_ACPY(&key.addr[sidx], naddr, key.af);
		key.port[didx] = pd->ndport;

		/*
		 * port search; start random, step;
		 * similar 2 portloop in in_pcbbind
		 */
		if (!(pd->proto == IPPROTO_TCP || pd->proto == IPPROTO_UDP ||
		    pd->proto == IPPROTO_ICMP || pd->proto == IPPROTO_ICMPV6)) {
			/* XXX bug: icmp states dont use the id on both
			 * XXX sides (traceroute -I through nat) */
			key.port[sidx] = pd->nsport;
			if (pf_find_state_all(&key, dir, NULL) == NULL) {
				*nport = pd->nsport;
				return (0);
			}
		} else if (low == 0 && high == 0) {
			key.port[sidx] = pd->nsport;
			if (pf_find_state_all(&key, dir, NULL) == NULL) {
				*nport = pd->nsport;
				return (0);
			}
		} else if (low == high) {
			key.port[sidx] = htons(low);
			if (pf_find_state_all(&key, dir, NULL) == NULL) {
				*nport = htons(low);
				return (0);
			}
		} else {
			u_int32_t tmp;

			if (low > high) {
				tmp = low;
				low = high;
				high = tmp;
			}
			/* low < high */
			cut = arc4random_uniform(1 + high - low) + low;
			/* low <= cut <= high */
			for (tmp = cut; tmp <= high && tmp <= 0xffff; ++tmp) {
				key.port[sidx] = htons(tmp);
				if (pf_find_state_all(&key, dir, NULL) ==
				    NULL && !in_baddynamic(tmp, pd->proto)) {
					*nport = htons(tmp);
					return (0);
				}
			}
			tmp = cut;
			for (tmp -= 1; tmp >= low && tmp <= 0xffff; --tmp) {
				key.port[sidx] = htons(tmp);
				if (pf_find_state_all(&key, dir, NULL) ==
				    NULL && !in_baddynamic(tmp, pd->proto)) {
					*nport = htons(tmp);
					return (0);
				}
			}
		}

		switch (r->nat.opts & PF_POOL_TYPEMASK) {
		case PF_POOL_RANDOM:
		case PF_POOL_ROUNDROBIN:
		case PF_POOL_LEASTSTATES:
			/*
			 * pick a different source address since we're out
			 * of free port choices for the current one.
			 */
			if (pf_map_addr(pd->naf, r, &pd->nsaddr, naddr,
			    &init_addr, sn, &r->nat, PF_SN_NAT))
				return (1);
			break;
		case PF_POOL_NONE:
		case PF_POOL_SRCHASH:
		case PF_POOL_BITMASK:
		default:
			return (1);
		}
	} while (! PF_AEQ(&init_addr, naddr, pd->naf) );
	return (1);					/* none available */
}

int
pf_map_addr_sticky(sa_family_t af, struct pf_rule *r, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_src_node **sns, struct pf_pool *rpool,
    enum pf_sn_types type)
{
	struct pf_addr		*raddr, *rmask, *cached;
	struct pf_state		*s;
	struct pf_src_node	 k;
	int			 valid;

	k.af = af;
	k.type = type;
	PF_ACPY(&k.addr, saddr, af);
	k.rule.ptr = r;
	pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
	sns[type] = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
	if (sns[type] == NULL)
		return (-1);

	/* check if the cached entry is still valid */
	cached = &(sns[type])->raddr;
	valid = 0;
	if (PF_AZERO(cached, af)) {
		valid = 1;
	} else if (rpool->addr.type == PF_ADDR_DYNIFTL) {
		if (pfr_kentry_byaddr(rpool->addr.p.dyn->pfid_kt, cached,
		    af, 0))
			valid = 1;
	} else if (rpool->addr.type == PF_ADDR_TABLE) {
		if (pfr_kentry_byaddr(rpool->addr.p.tbl, cached, af, 0))
			valid = 1;
	} else if (rpool->addr.type != PF_ADDR_NOROUTE) {
		raddr = &rpool->addr.v.a.addr;
		rmask = &rpool->addr.v.a.mask;
		valid = pf_match_addr(0, raddr, rmask, cached, af);
	}
	if (!valid) {
		if (pf_status.debug >= LOG_DEBUG) {
			log(LOG_DEBUG, "pf: pf_map_addr: "
			    "stale src tracking (%u) ", type);
			pf_print_host(&k.addr, 0, af);
			addlog(" to ");
			pf_print_host(cached, 0, af);
			addlog("\n");
		}
		if (sns[type]->states != 0) {
			/* XXX expensive */
			RB_FOREACH(s, pf_state_tree_id,
			   &tree_id)
				pf_state_rm_src_node(s,
				    sns[type]);
		}
		sns[type]->expire = 1;
		pf_remove_src_node(sns[type]);
		sns[type] = NULL;
		return (-1);
	}
	if (!PF_AZERO(cached, af))
		PF_ACPY(naddr, cached, af);
	if (pf_status.debug >= LOG_DEBUG) {
		log(LOG_DEBUG, "pf: pf_map_addr: "
		    "src tracking (%u) maps ", type);
		pf_print_host(&k.addr, 0, af);
		addlog(" to ");
		pf_print_host(naddr, 0, af);
		addlog("\n");
	}
	return (0);
}

int
pf_map_addr(sa_family_t af, struct pf_rule *r, struct pf_addr *saddr,
    struct pf_addr *naddr, struct pf_addr *init_addr, struct pf_src_node **sns,
    struct pf_pool *rpool, enum pf_sn_types type)
{
	unsigned char		 hash[16];
	struct pf_addr		 faddr;
	struct pf_addr		*raddr = &rpool->addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->addr.v.a.mask;
	u_int64_t		 states;
	u_int16_t		 weight;
	u_int64_t		 load;
	u_int64_t		 cload;
	u_int64_t		 hashidx;
	int			 cnt;

	if (sns[type] == NULL && rpool->opts & PF_POOL_STICKYADDR &&
	    (rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_NONE &&
	    pf_map_addr_sticky(af, r, saddr, naddr, sns, rpool, type) == 0)
		return (0);

	if (rpool->addr.type == PF_ADDR_NOROUTE)
		return (1);
	if (rpool->addr.type == PF_ADDR_DYNIFTL) {
		switch (af) {
		case AF_INET:
			if (rpool->addr.p.dyn->pfid_acnt4 < 1 &&
			    !PF_POOL_DYNTYPE(rpool->opts))
				return (1);
			raddr = &rpool->addr.p.dyn->pfid_addr4;
			rmask = &rpool->addr.p.dyn->pfid_mask4;
			break;
#ifdef INET6
		case AF_INET6:
			if (rpool->addr.p.dyn->pfid_acnt6 < 1 &&
			    !PF_POOL_DYNTYPE(rpool->opts))
				return (1);
			raddr = &rpool->addr.p.dyn->pfid_addr6;
			rmask = &rpool->addr.p.dyn->pfid_mask6;
			break;
#endif /* INET6 */
		default:
			unhandled_af(af);
		}
	} else if (rpool->addr.type == PF_ADDR_TABLE) {
		if (!PF_POOL_DYNTYPE(rpool->opts))
			return (1); /* unsupported */
	} else {
		raddr = &rpool->addr.v.a.addr;
		rmask = &rpool->addr.v.a.mask;
	}

	switch (rpool->opts & PF_POOL_TYPEMASK) {
	case PF_POOL_NONE:
		PF_ACPY(naddr, raddr, af);
		break;
	case PF_POOL_BITMASK:
		PF_POOLMASK(naddr, raddr, rmask, saddr, af);
		break;
	case PF_POOL_RANDOM:
		if (rpool->addr.type == PF_ADDR_TABLE) {
			cnt = rpool->addr.p.tbl->pfrkt_cnt;
			if (cnt == 0)
				rpool->tblidx = 0;
			else
				rpool->tblidx = (int)arc4random_uniform(cnt);
			memset(&rpool->counter, 0, sizeof(rpool->counter));
			if (pfr_pool_get(rpool, &raddr, &rmask, af))
				return (1);
			PF_ACPY(naddr, &rpool->counter, af);
		} else if (rpool->addr.type == PF_ADDR_DYNIFTL) {
			cnt = rpool->addr.p.dyn->pfid_kt->pfrkt_cnt;
			if (cnt == 0)
				rpool->tblidx = 0;
			else
				rpool->tblidx = (int)arc4random_uniform(cnt);
			memset(&rpool->counter, 0, sizeof(rpool->counter));
			if (pfr_pool_get(rpool, &raddr, &rmask, af))
				return (1);
			PF_ACPY(naddr, &rpool->counter, af);
		} else if (init_addr != NULL && PF_AZERO(init_addr, af)) {
			switch (af) {
			case AF_INET:
				rpool->counter.addr32[0] = arc4random();
				break;
#ifdef INET6
			case AF_INET6:
				if (rmask->addr32[3] != 0xffffffff)
					rpool->counter.addr32[3] = arc4random();
				else
					break;
				if (rmask->addr32[2] != 0xffffffff)
					rpool->counter.addr32[2] = arc4random();
				else
					break;
				if (rmask->addr32[1] != 0xffffffff)
					rpool->counter.addr32[1] = arc4random();
				else
					break;
				if (rmask->addr32[0] != 0xffffffff)
					rpool->counter.addr32[0] = arc4random();
				break;
#endif /* INET6 */
			default:
				unhandled_af(af);
			}
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
			PF_ACPY(init_addr, naddr, af);

		} else {
			PF_AINC(&rpool->counter, af);
			PF_POOLMASK(naddr, raddr, rmask, &rpool->counter, af);
		}
		break;
	case PF_POOL_SRCHASH:
		hashidx =
		    pf_hash(saddr, (struct pf_addr *)&hash, &rpool->key, af);
		if (rpool->addr.type == PF_ADDR_TABLE) {
			cnt = rpool->addr.p.tbl->pfrkt_cnt;
			if (cnt == 0)
				rpool->tblidx = 0;
			else
				rpool->tblidx = (int)(hashidx % cnt);
			memset(&rpool->counter, 0, sizeof(rpool->counter));
			if (pfr_pool_get(rpool, &raddr, &rmask, af))
				return (1);
			PF_ACPY(naddr, &rpool->counter, af);
		} else if (rpool->addr.type == PF_ADDR_DYNIFTL) {
			cnt = rpool->addr.p.dyn->pfid_kt->pfrkt_cnt;
			if (cnt == 0)
				rpool->tblidx = 0;
			else
				rpool->tblidx = (int)(hashidx % cnt);
			memset(&rpool->counter, 0, sizeof(rpool->counter));
			if (pfr_pool_get(rpool, &raddr, &rmask, af))
				return (1);
			PF_ACPY(naddr, &rpool->counter, af);
		} else {
			PF_POOLMASK(naddr, raddr, rmask,
			    (struct pf_addr *)&hash, af);
		}
		break;
	case PF_POOL_ROUNDROBIN:
		if (rpool->addr.type == PF_ADDR_TABLE ||
		    rpool->addr.type == PF_ADDR_DYNIFTL) {
			if (pfr_pool_get(rpool, &raddr, &rmask, af)) {
				/*
				 * reset counter in case its value
				 * has been removed from the pool.
				 */
				bzero(&rpool->counter, sizeof(rpool->counter));
				if (pfr_pool_get(rpool, &raddr, &rmask, af))
					return (1);
			}
		} else if (pf_match_addr(0, raddr, rmask, &rpool->counter, af))
			return (1);

		/* iterate over table if it contains entries which are weighted */
		if ((rpool->addr.type == PF_ADDR_TABLE &&
		    rpool->addr.p.tbl->pfrkt_refcntcost > 0) ||
		    (rpool->addr.type == PF_ADDR_DYNIFTL &&
		    rpool->addr.p.dyn->pfid_kt->pfrkt_refcntcost > 0)) {
			do {
				if (rpool->addr.type == PF_ADDR_TABLE ||
				    rpool->addr.type == PF_ADDR_DYNIFTL) {
					if (pfr_pool_get(rpool,
					    &raddr, &rmask, af))
						return (1);
				} else {
					log(LOG_ERR, "pf: pf_map_addr: "
					    "weighted RR failure");
					return (1);
				}
				if (rpool->weight >= rpool->curweight)
					break;
				PF_AINC(&rpool->counter, af);
			} while (1);
 
			weight = rpool->weight;
		}

		PF_ACPY(naddr, &rpool->counter, af);
		if (init_addr != NULL && PF_AZERO(init_addr, af))
			PF_ACPY(init_addr, naddr, af);
		PF_AINC(&rpool->counter, af);
		break;
	case PF_POOL_LEASTSTATES:
		/* retrieve an address first */
		if (rpool->addr.type == PF_ADDR_TABLE ||
		    rpool->addr.type == PF_ADDR_DYNIFTL) {
			if (pfr_pool_get(rpool, &raddr, &rmask, af)) {
				/* see PF_POOL_ROUNDROBIN */
				bzero(&rpool->counter, sizeof(rpool->counter));
				if (pfr_pool_get(rpool, &raddr, &rmask, af))
					return (1);
			}
		} else if (pf_match_addr(0, raddr, rmask, &rpool->counter, af))
			return (1);

		states = rpool->states;
		weight = rpool->weight;

		if ((rpool->addr.type == PF_ADDR_TABLE &&
		    rpool->addr.p.tbl->pfrkt_refcntcost > 0) ||
		    (rpool->addr.type == PF_ADDR_DYNIFTL &&
		    rpool->addr.p.dyn->pfid_kt->pfrkt_refcntcost > 0))
			load = ((UINT16_MAX * rpool->states) / rpool->weight);
		else
			load = states;

		PF_ACPY(&faddr, &rpool->counter, af);

		PF_ACPY(naddr, &rpool->counter, af);
		if (init_addr != NULL && PF_AZERO(init_addr, af))
			PF_ACPY(init_addr, naddr, af);

		/*
		 * iterate *once* over whole table and find destination with
		 * least connection
		 */
		do  {
			PF_AINC(&rpool->counter, af);
			if (rpool->addr.type == PF_ADDR_TABLE ||
			    rpool->addr.type == PF_ADDR_DYNIFTL) {
				if (pfr_pool_get(rpool, &raddr, &rmask, af))
					return (1);
			} else if (pf_match_addr(0, raddr, rmask,
			    &rpool->counter, af))
				return (1);

			if ((rpool->addr.type == PF_ADDR_TABLE &&
			    rpool->addr.p.tbl->pfrkt_refcntcost > 0) ||
			    (rpool->addr.type == PF_ADDR_DYNIFTL &&
			    rpool->addr.p.dyn->pfid_kt->pfrkt_refcntcost > 0))
				cload = ((UINT16_MAX * rpool->states)
					/ rpool->weight);
			else
				cload = rpool->states;

			/* find lc minimum */
			if (cload < load) {
				states = rpool->states;
				weight = rpool->weight;
				load = cload;

				PF_ACPY(naddr, &rpool->counter, af);
				if (init_addr != NULL &&
				    PF_AZERO(init_addr, af))
				    PF_ACPY(init_addr, naddr, af);
			}
		} while (pf_match_addr(1, &faddr, rmask, &rpool->counter, af) &&
		    (states > 0));

		if (rpool->addr.type == PF_ADDR_TABLE) {
			if (pfr_states_increase(rpool->addr.p.tbl,
			    naddr, af) == -1) {
				if (pf_status.debug >= LOG_DEBUG) {
					log(LOG_DEBUG,"pf: pf_map_addr: "
					    "selected address ");
					pf_print_host(naddr, 0, af);
					addlog(". Failed to increase count!\n");
				}
				return (1);
			}
		} else if (rpool->addr.type == PF_ADDR_DYNIFTL) {
			if (pfr_states_increase(rpool->addr.p.dyn->pfid_kt,
			    naddr, af) == -1) {
				if (pf_status.debug >= LOG_DEBUG) {
					log(LOG_DEBUG, "pf: pf_map_addr: "
					    "selected address ");
					pf_print_host(naddr, 0, af);
					addlog(". Failed to increase count!\n");
				}
				return (1);
			}
		}
		break;
	}

	if (rpool->opts & PF_POOL_STICKYADDR) {
		if (sns[type] != NULL) {
			pf_remove_src_node(sns[type]);
			sns[type] = NULL;
		}
		if (pf_insert_src_node(&sns[type], r, type, af, saddr, naddr))
			return (1);
	}

	if (pf_status.debug >= LOG_INFO &&
	    (rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		log(LOG_INFO, "pf: pf_map_addr: selected address ");
		pf_print_host(naddr, 0, af);
		if ((rpool->opts & PF_POOL_TYPEMASK) ==
		    PF_POOL_LEASTSTATES)
			addlog(" with state count %llu", states);
		if ((rpool->addr.type == PF_ADDR_TABLE &&
		    rpool->addr.p.tbl->pfrkt_refcntcost > 0) ||
		    (rpool->addr.type == PF_ADDR_DYNIFTL &&
		    rpool->addr.p.dyn->pfid_kt->pfrkt_refcntcost > 0))
			addlog(" with weight %u", weight);
		addlog("\n");
	}

	return (0);
}

int
pf_get_transaddr(struct pf_rule *r, struct pf_pdesc *pd,
    struct pf_src_node **sns, struct pf_rule **nr)
{
	struct pf_addr	naddr;
	u_int16_t	nport;

#ifdef INET6
	if (pd->af != pd->naf)
		return (pf_get_transaddr_af(r, pd, sns));
#endif /* INET6 */

	if (r->nat.addr.type != PF_ADDR_NONE) {
		/* XXX is this right? what if rtable is changed at the same
		 * XXX time? where do I need to figure out the sport? */
		nport = 0;
		if (pf_get_sport(pd, r, &naddr, &nport,
		    r->nat.proxy_port[0], r->nat.proxy_port[1], sns)) {
			DPFPRINTF(LOG_NOTICE,
			    "pf: NAT proxy port allocation (%u-%u) failed",
			    r->nat.proxy_port[0],
			    r->nat.proxy_port[1]);
			return (-1);
		}
		*nr = r;
		PF_ACPY(&pd->nsaddr, &naddr, pd->af);
		pd->nsport = nport;
	}
	if (r->rdr.addr.type != PF_ADDR_NONE) {
		if (pf_map_addr(pd->af, r, &pd->nsaddr, &naddr, NULL, sns,
		    &r->rdr, PF_SN_RDR))
			return (-1);
		if ((r->rdr.opts & PF_POOL_TYPEMASK) == PF_POOL_BITMASK)
			PF_POOLMASK(&naddr, &naddr,  &r->rdr.addr.v.a.mask,
			    &pd->ndaddr, pd->af);

		nport = 0;
		if (r->rdr.proxy_port[1]) {
			u_int32_t	tmp_nport;

			tmp_nport = ((ntohs(pd->ndport) -
			    ntohs(r->dst.port[0])) %
			    (r->rdr.proxy_port[1] -
			    r->rdr.proxy_port[0] + 1)) +
			    r->rdr.proxy_port[0];

			/* wrap around if necessary */
			if (tmp_nport > 65535)
				tmp_nport -= 65535;
			nport = htons((u_int16_t)tmp_nport);
		} else if (r->rdr.proxy_port[0])
			nport = htons(r->rdr.proxy_port[0]);
		*nr = r;
		PF_ACPY(&pd->ndaddr, &naddr, pd->af);
		if (nport)
			pd->ndport = nport;
	}

	return (0);
}

#ifdef INET6
int
pf_get_transaddr_af(struct pf_rule *r, struct pf_pdesc *pd,
    struct pf_src_node **sns)
{
	struct pf_addr	ndaddr, nsaddr, naddr;
	u_int16_t	nport;
	int		prefixlen = 96;

	if (pf_status.debug >= LOG_INFO) {
		log(LOG_INFO, "pf: af-to %s %s, ",
		    pd->naf == AF_INET ? "inet" : "inet6",
		    r->rdr.addr.type == PF_ADDR_NONE ? "nat" : "rdr");
		pf_print_host(&pd->nsaddr, pd->nsport, pd->af);
		addlog(" -> ");
		pf_print_host(&pd->ndaddr, pd->ndport, pd->af);
		addlog("\n");
	}

	if (r->nat.addr.type == PF_ADDR_NONE)
		panic("pf_get_transaddr_af: no nat pool for source address");

	/* get source address and port */
	nport = 0;
	if (pf_get_sport(pd, r, &nsaddr, &nport,
	    r->nat.proxy_port[0], r->nat.proxy_port[1], sns)) {
		DPFPRINTF(LOG_NOTICE,
		    "pf: af-to NAT proxy port allocation (%u-%u) failed",
		    r->nat.proxy_port[0],
		    r->nat.proxy_port[1]);
		return (-1);
	}
	pd->nsport = nport;

	if (pd->proto == IPPROTO_ICMPV6 && pd->naf == AF_INET) {
		if (pd->dir == PF_IN) {
			pd->ndport = ntohs(pd->ndport);
			if (pd->ndport == ICMP6_ECHO_REQUEST)
				pd->ndport = ICMP_ECHO;
			else if (pd->ndport == ICMP6_ECHO_REPLY)
				pd->ndport = ICMP_ECHOREPLY;
			pd->ndport = htons(pd->ndport);
		} else {
			pd->nsport = ntohs(pd->nsport);
			if (pd->nsport == ICMP6_ECHO_REQUEST)
				pd->nsport = ICMP_ECHO;
			else if (pd->nsport == ICMP6_ECHO_REPLY)
				pd->nsport = ICMP_ECHOREPLY;
			pd->nsport = htons(pd->nsport);
		}
	} else if (pd->proto == IPPROTO_ICMP && pd->naf == AF_INET6) {
		if (pd->dir == PF_IN) {
			pd->ndport = ntohs(pd->ndport);
			if (pd->ndport == ICMP_ECHO)
				pd->ndport = ICMP6_ECHO_REQUEST;
			else if (pd->ndport == ICMP_ECHOREPLY)
				pd->ndport = ICMP6_ECHO_REPLY;
			pd->ndport = htons(pd->ndport);
		} else {
			pd->nsport = ntohs(pd->nsport);
			if (pd->nsport == ICMP_ECHO)
				pd->nsport = ICMP6_ECHO_REQUEST;
			else if (pd->nsport == ICMP_ECHOREPLY)
				pd->nsport = ICMP6_ECHO_REPLY;
			pd->nsport = htons(pd->nsport);
		}
	}

	/* get the destination address and port */
	if (r->rdr.addr.type != PF_ADDR_NONE) {
		if (pf_map_addr(pd->naf, r, &nsaddr, &naddr, NULL, sns,
		    &r->rdr, PF_SN_RDR))
			return (-1);
		if (r->rdr.proxy_port[0])
			pd->ndport = htons(r->rdr.proxy_port[0]);

		if (pd->naf == AF_INET) {
			/* The prefix is the IPv4 rdr address */
			prefixlen = in_mask2len((struct in_addr *)
			    &r->rdr.addr.v.a.mask);
			inet_nat46(pd->naf, &pd->ndaddr,
			    &ndaddr, &naddr, prefixlen);
		} else {
			/* The prefix is the IPv6 rdr address */
			prefixlen =
			    in6_mask2len((struct in6_addr *)
			    &r->rdr.addr.v.a.mask, NULL);
			inet_nat64(pd->naf, &pd->ndaddr,
			    &ndaddr, &naddr, prefixlen);
		}
	} else {
		if (pd->naf == AF_INET) {
			/* The prefix is the IPv6 dst address */
			prefixlen =
			    in6_mask2len((struct in6_addr *)
			    &r->dst.addr.v.a.mask, NULL);
			if (prefixlen < 32)
				prefixlen = 96;
			inet_nat64(pd->naf, &pd->ndaddr,
			    &ndaddr, &pd->ndaddr, prefixlen);
		} else {
			/*
			 * The prefix is the IPv6 nat address
			 * (that was stored in pd->nsaddr)
			 */
			prefixlen = in6_mask2len((struct in6_addr *)
			    &r->nat.addr.v.a.mask, NULL);
			if (prefixlen > 96)
				prefixlen = 96;
			inet_nat64(pd->naf, &pd->ndaddr,
			    &ndaddr, &nsaddr, prefixlen);
		}
	}

	PF_ACPY(&pd->nsaddr, &nsaddr, pd->naf);
	PF_ACPY(&pd->ndaddr, &ndaddr, pd->naf);

	if (pf_status.debug >= LOG_INFO) {
		log(LOG_INFO, "pf: af-to %s %s done, prefixlen %d, ",
		    pd->naf == AF_INET ? "inet" : "inet6",
		    r->rdr.addr.type == PF_ADDR_NONE ? "nat" : "rdr",
		    prefixlen);
		pf_print_host(&pd->nsaddr, pd->nsport, pd->naf);
		addlog(" -> ");
		pf_print_host(&pd->ndaddr, pd->ndport, pd->naf);
		addlog("\n");
	}

	return (0);
}
#endif /* INET6 */

int
pf_postprocess_addr(struct pf_state *cur)
{
	struct pf_rule		*nr;
	struct pf_state_key	*sks;
	struct pf_pool		 rpool;
	struct pf_addr		 lookup_addr;
	int			 slbcount = -1;

	nr = cur->natrule.ptr;

	if (nr == NULL)
		return (0);

	/* decrease counter */

	sks = cur->key[PF_SK_STACK];

	/* check for outgoing or ingoing balancing */
	if (nr->rt == PF_ROUTETO)
		lookup_addr = cur->rt_addr;
	else if (sks != NULL)
		lookup_addr = sks->addr[1];
	else {
		if (pf_status.debug >= LOG_DEBUG) {
			log(LOG_DEBUG, "pf: %s: unable to obtain address",
			    __func__);
		}
		return (1);
	}

	/* check for appropriate pool */
	if (nr->rdr.addr.type != PF_ADDR_NONE)
		rpool = nr->rdr;
	else if (nr->nat.addr.type != PF_ADDR_NONE)
		rpool = nr->nat;
	else if (nr->route.addr.type != PF_ADDR_NONE)
		rpool = nr->route;
	else
		return (0);

	if (((rpool.opts & PF_POOL_TYPEMASK) != PF_POOL_LEASTSTATES))
		return (0);

	if (rpool.addr.type == PF_ADDR_TABLE) {
		if ((slbcount = pfr_states_decrease(
		    rpool.addr.p.tbl,
		    &lookup_addr, sks->af)) == -1) {
			if (pf_status.debug >= LOG_DEBUG) {
				log(LOG_DEBUG, "pf: %s: selected address ",
				    __func__);
				pf_print_host(&lookup_addr,
				    sks->port[0], sks->af);
				addlog(". Failed to "
				    "decrease count!\n");
			}
			return (1);
		}
	} else if (rpool.addr.type == PF_ADDR_DYNIFTL) {
		if ((slbcount = pfr_states_decrease(
		    rpool.addr.p.dyn->pfid_kt,
		    &lookup_addr, sks->af)) == -1) {
			if (pf_status.debug >= LOG_DEBUG) {
				log(LOG_DEBUG, "pf: %s: selected address ",
				    __func__);
				pf_print_host(&lookup_addr,
				    sks->port[0], sks->af);
				addlog(". Failed to "
				    "decrease count!\n");
			}
			return (1);
		}
	}
	if (slbcount > -1) {
		if (pf_status.debug >= LOG_INFO) {
			log(LOG_INFO, "pf: %s: selected address ", __func__);
			pf_print_host(&lookup_addr, sks->port[0],
			    sks->af);
			addlog(" decreased state count to %u\n",
			    slbcount);
		}
	}
	return (0);
}
@


1.60
log
@Some of the LOG_NOTICE messages from PF were seen in normal operations
with certain rulesets and excessively noisy; move them to LOG_INFO (which was
previously unused).  ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.59 2017/02/08 01:20:40 jsg Exp $ */
d214 1
a214 1
			u_int16_t tmp;
d224 1
a224 1
			for (tmp = cut; tmp <= high; ++(tmp)) {
d232 2
a233 1
			for (tmp = cut - 1; tmp >= low; --(tmp)) {
@


1.59
log
@Remove an uneeded NULL test which was after a deref.
ok mpi@@ henning@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.58 2016/10/26 21:07:22 bluhm Exp $ */
d622 1
a622 1
	if (pf_status.debug >= LOG_NOTICE &&
d624 1
a624 1
		log(LOG_NOTICE, "pf: pf_map_addr: selected address ");
d710 2
a711 2
	if (pf_status.debug >= LOG_NOTICE) {
		log(LOG_NOTICE, "pf: af-to %s %s, ",
d818 2
a819 2
	if (pf_status.debug >= LOG_NOTICE) {
		log(LOG_NOTICE, "pf: af-to %s %s done, prefixlen %d, ",
d907 2
a908 2
		if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE, "pf: %s: selected address ", __func__);
@


1.58
log
@Put union pf_headers and struct pf_pdesc into separate header file
pfvar_priv.h.  The pf_headers had to be defined in multiple .c files
before.  In pfvar.h it would have unknown storage size, this file
is included in too many places.  The idea is to have a private pf
header that is only included in the pf part of the kernel.  For now
it contains pf_pdesc and pf_headers, it may be extended later.
discussion, input and OK henning@@ procter@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.57 2016/09/27 04:57:17 dlg Exp $ */
d849 1
a849 1
	sks = cur ? cur->key[PF_SK_STACK] : NULL;
@


1.57
log
@roll back turning RB into RBT until i get better at this process.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.56 2016/09/27 02:51:12 dlg Exp $ */
d64 1
d66 2
d70 1
a71 2
#include <netinet/ip_icmp.h>
#include <netinet/tcp_timer.h>
a72 1
#include <netinet/icmp_var.h>
d74 5
a78 1
#include <netinet/in_pcb.h>
d81 1
a93 5

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#endif /* INET6 */
@


1.56
log
@move pf from the RB macros to the RBT functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.55 2016/07/19 12:51:19 henning Exp $ */
d278 1
a278 1
	sns[type] = RBT_FIND(pf_src_tree, &tree_src_tracking, &k);
d310 1
a310 1
			RBT_FOREACH(s, pf_state_tree_id,
@


1.55
log
@remove wrong and misleading comment, ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.53 2016/06/15 11:36:06 mikeb Exp $ */
d278 1
a278 1
	sns[type] = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
d310 1
a310 1
			RB_FOREACH(s, pf_state_tree_id,
@


1.54
log
@The function pf_get_sport() did work for out rules only.  Make it
aware of the direction of the packet.  Now nat-to can be used by
in rules and together with divert-to.  Collisions with existing
states are found and produce a "NAT proxy port allocation failed"
message.
OK henning@@ mikeb@@
@
text
@a93 5

/*
 * Global variables
 */

@


1.53
log
@There's no need to convert values returned by arc4random to the network
byte order.  Spotted by Gleb Smirnoff (glebius@@FreeBSD.org), thanks!

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.52 2015/11/24 13:37:16 mpi Exp $ */
d158 3
d188 3
a190 3
		PF_ACPY(&key.addr[0], &pd->ndaddr, key.af);
		PF_ACPY(&key.addr[1], naddr, key.af);
		key.port[0] = pd->ndport;
d200 2
a201 2
			key.port[1] = pd->nsport;
			if (pf_find_state_all(&key, PF_IN, NULL) == NULL) {
d206 2
a207 2
			key.port[1] = pd->nsport;
			if (pf_find_state_all(&key, PF_IN, NULL) == NULL) {
d212 2
a213 2
			key.port[1] = htons(low);
			if (pf_find_state_all(&key, PF_IN, NULL) == NULL) {
d229 2
a230 2
				key.port[1] = htons(tmp);
				if (pf_find_state_all(&key, PF_IN, NULL) ==
d237 2
a238 2
				key.port[1] = htons(tmp);
				if (pf_find_state_all(&key, PF_IN, NULL) ==
@


1.52
log
@No need for <net/if_types.h>

As a bonus this removes a "#if NCARP > 0", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.51 2015/10/15 19:48:44 bluhm Exp $ */
d418 1
a418 1
				rpool->counter.addr32[0] = htonl(arc4random());
d423 1
a423 2
					rpool->counter.addr32[3] =
					    htonl(arc4random());
d427 1
a427 2
					rpool->counter.addr32[2] =
					    htonl(arc4random());
d431 1
a431 2
					rpool->counter.addr32[1] =
					    htonl(arc4random());
d435 1
a435 2
					rpool->counter.addr32[0] =
					    htonl(arc4random());
@


1.51
log
@When using a pf rule with both nat-to and rdr-to, it could happen
that the nated source port was reused as destination port.  Do not
initialize nport at the beginning of the function, but where it is
needed.
OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.50 2015/10/13 19:32:31 sashan Exp $ */
a58 1
#include <net/if_types.h>
@


1.50
log
@- pf_insert_src_node(): global argument (arg6) is useless, function
  always gets pointer to rule.

- pf_remove_src_node(): function should always remove matching src node,
  regardless the sn->rule.ptr being NULL or valid rule

- sn->rule.ptr is never NULL, spotted by mpi and Richard Procter _von_ gmail.com

OK mpi@@, OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.49 2015/08/03 13:33:12 jsg Exp $ */
d651 1
a651 1
	u_int16_t	nport = 0;
d661 1
d682 1
d713 1
a713 1
	u_int16_t	nport = 0;
d730 1
@


1.49
log
@A recently added sanity check panic in pf_postprocess_addr() was
triggered for a reply-to rule.  It turns out this case has been using
uninitialised memory as if it were a valid pf pool.

As the rest of the function assumes a valid pool for now just return.

Problem reported by RD Thrush.

ok jung@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.48 2015/07/20 18:42:08 jsg Exp $ */
d624 1
a624 2
		if (pf_insert_src_node(&sns[type], r, type, af, saddr, naddr,
		    0))
@


1.48
log
@Add some panics to default paths where code later assumes a non default
path was taken.  This both prevents warnings from clang and acts as a
sanity check.

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.47 2015/07/18 19:19:00 sashan Exp $ */
d876 1
a876 1
		panic("no appropriate pool");
@


1.47
log
@msg.mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.46 2015/07/18 15:19:44 sashan Exp $ */
d875 2
@


1.46
log
@INET/INET6 address family check should be unified in PF

it also adds af_unhandled(), where it is currently missing.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.45 2015/07/17 18:39:55 jsg Exp $ */
d77 2
d80 3
d84 1
@


1.45
log
@fix the indentation of a block of code, no binary change
ok mikeb@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.44 2015/07/16 16:12:15 mpi Exp $ */
d116 1
a116 1
#endif
d139 2
d371 2
d437 2
@


1.44
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.43 2015/06/03 11:57:37 yasuoka Exp $ */
d670 2
a671 2
			if (r->rdr.proxy_port[1]) {
				u_int32_t	tmp_nport;
d673 12
a684 12
				tmp_nport = ((ntohs(pd->ndport) -
				    ntohs(r->dst.port[0])) %
				    (r->rdr.proxy_port[1] -
				    r->rdr.proxy_port[0] + 1)) +
				    r->rdr.proxy_port[0];

				/* wrap around if necessary */
				if (tmp_nport > 65535)
					tmp_nport -= 65535;
				nport = htons((u_int16_t)tmp_nport);
			} else if (r->rdr.proxy_port[0])
				nport = htons(r->rdr.proxy_port[0]);
@


1.43
log
@Fix pf_map_addr() not to cause dividing by 0.  This fixes problem when
using table or dynamic interface addresses for source-hash.  Also
avoid calling arc4random_uniform() with upper_bound == 0.

ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.42 2015/03/14 03:38:51 jsg Exp $ */
d729 1
a729 1
			NTOHS(pd->ndport);
d734 1
a734 1
			HTONS(pd->ndport);
d736 1
a736 1
			NTOHS(pd->nsport);
d741 1
a741 1
			HTONS(pd->nsport);
d745 1
a745 1
			NTOHS(pd->ndport);
d750 1
a750 1
			HTONS(pd->ndport);
d752 1
a752 1
			NTOHS(pd->nsport);
d757 1
a757 1
			HTONS(pd->nsport);
@


1.42
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.41 2015/01/06 01:49:45 jsg Exp $ */
d388 4
a391 1
			rpool->tblidx = (int)arc4random_uniform(cnt);
d398 4
a401 1
			rpool->tblidx = (int)arc4random_uniform(cnt);
d447 4
a450 1
			rpool->tblidx = (int)(hashidx % cnt);
d457 4
a460 1
			rpool->tblidx = (int)(hashidx % cnt);
@


1.41
log
@init a potentially uninitialised var in pf_postprocess_addr
ok mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.40 2014/12/19 17:14:40 tedu Exp $ */
a56 1
#include <crypto/md5.h>
@


1.40
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.39 2014/12/19 13:04:08 reyk Exp $ */
d821 1
a821 1
	int			 slbcount;
@


1.39
log
@Support source-hash and random with tables and dynifs; not just pools.
This finally allows to use source-hash for dynamic loadbalancing, eg.
"rdr-to <hosts> source-hash", instead of just round-robin and least-states.

An older pre-siphash version of this diff was tested by many people.

OK tedu@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.38 2014/12/19 12:31:03 mcbride Exp $ */
a119 1
#ifdef INET
a124 1
#endif /* INET */
a353 1
#ifdef INET
a360 1
#endif /* INET */
a402 1
#ifdef INET
a405 1
#endif /* INET */
@


1.38
log
@Comment is no longer true, remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.37 2014/12/18 19:02:56 tedu Exp $ */
d95 1
a95 1
void			 pf_hash(struct pf_addr *, struct pf_addr *,
d107 1
a107 1
void
d111 1
d122 1
a122 1
		hash->addr32[0] = SipHash24((SIPHASH_KEY *)key,
d124 1
d129 1
a129 1
		h.hash64 = SipHash24((SIPHASH_KEY *)key, &inaddr->addr32[0],
d131 1
d143 1
d344 2
d359 1
a359 4
			    ((rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN) &&
			    ((rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_LEASTSTATES))
d368 1
a368 4
			    ((rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN) &&
			    ((rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_LEASTSTATES))
d376 1
a376 2
		if (((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN) &&
		    ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_LEASTSTATES))
d391 15
a405 1
		if (init_addr != NULL && PF_AZERO(init_addr, af)) {
d444 20
a463 2
		pf_hash(saddr, (struct pf_addr *)&hash, &rpool->key, af);
		PF_POOLMASK(naddr, raddr, rmask, (struct pf_addr *)&hash, af);
@


1.37
log
@use siphash for pf_lb. for ipv6, we stretch it out a bit, but good enough.
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.36 2014/11/18 02:37:31 tedu Exp $ */
a106 3
/*
 * hash function based on bridge_hash in if_bridge.c
 */
@


1.36
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.35 2014/11/10 18:49:42 bluhm Exp $ */
d56 1
a106 13
#define mix(a,b,c) \
	do {					\
		a -= b; a -= c; a ^= (c >> 13);	\
		b -= c; b -= a; b ^= (a << 8);	\
		c -= a; c -= b; c ^= (b >> 13);	\
		a -= b; a -= c; a ^= (c >> 12);	\
		b -= c; b -= a; b ^= (a << 16);	\
		c -= a; c -= b; c ^= (b >> 5);	\
		a -= b; a -= c; a ^= (c >> 3);	\
		b -= c; b -= a; b ^= (a << 10);	\
		c -= a; c -= b; c ^= (b >> 15);	\
	} while (0)

d114 6
a119 1
	u_int32_t	a = 0x9e3779b9, b = 0x9e3779b9, c = key->key32[0];
d124 2
a125 4
		a += inaddr->addr32[0];
		b += key->key32[1];
		mix(a, b, c);
		hash->addr32[0] = c + key->key32[2];
d130 10
a139 19
		a += inaddr->addr32[0];
		b += inaddr->addr32[2];
		mix(a, b, c);
		hash->addr32[0] = c;
		a += inaddr->addr32[1];
		b += inaddr->addr32[3];
		c += key->key32[1];
		mix(a, b, c);
		hash->addr32[1] = c;
		a += inaddr->addr32[2];
		b += inaddr->addr32[1];
		c += key->key32[2];
		mix(a, b, c);
		hash->addr32[2] = c;
		a += inaddr->addr32[3];
		b += inaddr->addr32[0];
		c += key->key32[3];
		mix(a, b, c);
		hash->addr32[3] = c;
@


1.35
log
@Split the logic for the ICMP and ICMP6 case in pf_get_sport().  The
types ICMP_ECHO and ICMP6_ECHO_REQUEST have their special meaning
only if the protocol matches.
Put an #ifdef INET6 around ICMP6_ECHO_REQUEST to make the kernel
without IPv6 compile.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.34 2014/09/08 06:24:13 jsg Exp $ */
a75 1
#include <dev/rndvar.h>
@


1.34
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.33 2014/08/14 07:55:17 blambert Exp $ */
d61 1
d74 1
a86 1
#include <netinet/in_pcb.h>
d178 2
a179 3
	if (pd->proto == IPPROTO_ICMP || pd->proto == IPPROTO_ICMPV6) {
		if (pd->ndport == htons(ICMP6_ECHO_REQUEST) ||
		    pd->ndport == htons(ICMP_ECHO)) {
d185 9
@


1.33
log
@fix logging strings (correct function name via __func__ + a typo)

ok florian@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.32 2014/07/22 11:06:10 mpi Exp $ */
a60 2
#include <net/route.h>
#include <net/radix_mpath.h>
a68 1
#include <netinet/in_pcb.h>
a69 1
#include <netinet/tcp_var.h>
@


1.32
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.31 2014/07/02 13:06:00 mikeb Exp $ */
d831 2
a832 2
			log(LOG_DEBUG, "pf: pf_unlink_state: "
			    "unable to optain address");
d853 2
a854 2
				log(LOG_DEBUG, "pf: pf_unlink_state: "
				    "selected address ");
d867 2
a868 3
				log(LOG_DEBUG,
				    "pf: pf_unlink_state: "
				    "selected address ");
d879 1
a879 2
			log(LOG_NOTICE,
			    "pf: pf_unlink_state: selected address ");
@


1.31
log
@better indentation;  no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.30 2013/10/30 11:21:26 mikeb Exp $ */
a64 1
#include <netinet/in_systm.h>
@


1.30
log
@translate icmpv6 echo id's the same way we do for icmpv4;  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.29 2013/10/30 11:18:32 mikeb Exp $ */
d808 7
a814 2
pf_postprocess_addr(struct pf_state *cur) {
	struct pf_rule *nr;
d818 3
d822 31
a852 14
	if (nr != NULL) {
		int			 slbcount;
		struct pf_pool		 rpool;
		struct pf_addr		 lookup_addr;
		struct pf_state_key	*sks;

		sks = cur ? cur->key[PF_SK_STACK] : NULL;

		/* check for outgoing or ingoing balancing */
		if (nr->rt == PF_ROUTETO)
			lookup_addr = cur->rt_addr;
		else if (sks != NULL)
			lookup_addr = sks->addr[1];
		else {
d855 5
a859 1
				    "unable to optain address");
d863 12
a874 40

		/* check for appropriate pool */
		if (nr->rdr.addr.type != PF_ADDR_NONE)
			rpool = nr->rdr;
		else if (nr->nat.addr.type != PF_ADDR_NONE)
			rpool = nr->nat;
		else if (nr->route.addr.type != PF_ADDR_NONE)
			rpool = nr->route;

		if (((rpool.opts & PF_POOL_TYPEMASK) != PF_POOL_LEASTSTATES))
			return (0);

		if (rpool.addr.type == PF_ADDR_TABLE) {
			if ((slbcount = pfr_states_decrease(
			    rpool.addr.p.tbl,
			    &lookup_addr, sks->af)) == -1) {
				if (pf_status.debug >= LOG_DEBUG) {
					log(LOG_DEBUG, "pf: pf_unlink_state: "
					    "selected address ");
					pf_print_host(&lookup_addr,
					    sks->port[0], sks->af);
					addlog(". Failed to "
					    "decrease count!\n");
				}
				return (1);
			}
		} else if (rpool.addr.type == PF_ADDR_DYNIFTL) {
			if ((slbcount = pfr_states_decrease(
			    rpool.addr.p.dyn->pfid_kt,
			    &lookup_addr, sks->af)) == -1) {
				if (pf_status.debug >= LOG_DEBUG) {
					log(LOG_DEBUG,
					    "pf: pf_unlink_state: "
					    "selected address ");
					pf_print_host(&lookup_addr,
					    sks->port[0], sks->af);
					addlog(". Failed to "
					    "decrease count!\n");
				}
				return (1);
d876 1
d878 9
a886 9
		if (slbcount > -1) {
			if (pf_status.debug >= LOG_NOTICE) {
				log(LOG_NOTICE,
				    "pf: pf_unlink_state: selected address ");
				pf_print_host(&lookup_addr, sks->port[0],
				    sks->af);
				addlog(" decreased state count to %u\n",
				    slbcount);
			}
a888 1

@


1.29
log
@add a comment describing why do we call pf_map_addr again if port
selection process fails;  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.28 2013/10/24 11:31:43 mpi Exp $ */
d204 1
a204 1
		    pd->proto == IPPROTO_ICMP)) {
@


1.28
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.27 2013/10/23 15:12:42 mpi Exp $ */
d257 4
@


1.27
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.26 2013/10/17 16:27:42 bluhm Exp $ */
a88 1
#include <netinet6/in6_var.h>
a91 1
#include <netinet6/nd6.h>
@


1.26
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.25 2013/03/28 16:45:16 tedu Exp $ */
a64 1
#include <netinet/in_var.h>
@


1.25
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.24 2012/12/29 14:59:52 markus Exp $ */
d90 1
@


1.24
log
@make sure the entry from tree_src_tracking is still in the pool;
fixes nat with sticky address and ip address change on pppoe(4) for example;
ok henning@@, zinke@@; mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.23 2012/12/29 14:54:45 markus Exp $ */
a51 1
#include <sys/proc.h>
@


1.23
log
@reset the counter in case its current value has been removed
from the pool (e.g. ifconfig em0 1.2.3.4 -alias)
ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.22 2012/12/29 14:53:05 markus Exp $ */
d109 4
d275 70
a352 1
	struct pf_src_node	 k;
d359 3
a361 21
	    (rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		k.af = af;
		k.type = type;
		PF_ACPY(&k.addr, saddr, af);
		k.rule.ptr = r;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		sns[type] = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
		if (sns[type] != NULL) {
			if (!PF_AZERO(&(sns[type])->raddr, af))
				PF_ACPY(naddr, &(sns[type])->raddr, af);
			if (pf_status.debug >= LOG_DEBUG) {
				log(LOG_DEBUG, "pf: pf_map_addr: "
				    "src tracking (%u) maps ", type);
				pf_print_host(&k.addr, 0, af);
				addlog(" to ");
				pf_print_host(naddr, 0, af);
				addlog("\n");
			}
			return (0);
		}
	}
@


1.22
log
@pass pf_pool directly to pfr_pool_get(); simplifies the API;
ok henning@@, zinke@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.21 2012/07/09 15:20:57 zinke Exp $ */
d399 9
a407 2
			if (pfr_pool_get(rpool, &raddr, &rmask, af))
				return (1);
d444 6
a449 2
			if (pfr_pool_get(rpool, &raddr, &rmask, af))
				return (1);
@


1.21
log
@Enable support for the 'weight' keyword in the 'least-states'
load balancing case, this allows Weighted Least States (WLS).
Everything prepared on c2k11 with help from mcbride@@.

This finally makes PF ready for the cloud.

ok henning@@ mikeb@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.20 2012/02/03 01:57:51 bluhm Exp $ */
a108 1
int			 pf_islinklocal(sa_family_t, struct pf_addr *);
a270 8
pf_islinklocal(sa_family_t af, struct pf_addr *addr)
{
	if (af == AF_INET6 && IN6_IS_ADDR_LINKLOCAL(&addr->v6))
		return (1);
	return (0);
}

int
d397 3
a399 13
		if (rpool->addr.type == PF_ADDR_TABLE) {
			if (pfr_pool_get(rpool->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, &rpool->kif,
			    &rpool->states, &rpool->weight,
			    &rpool->curweight, af, NULL))
				return (1);
		} else if (rpool->addr.type == PF_ADDR_DYNIFTL) {
			if (pfr_pool_get(rpool->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, &rpool->kif,
			    &rpool->states, &rpool->weight,
			    &rpool->curweight, af, pf_islinklocal))
d410 4
a413 15
				if (rpool->addr.type == PF_ADDR_TABLE) {
					if (pfr_pool_get(rpool->addr.p.tbl,
					    &rpool->tblidx, &rpool->counter,
					    &raddr, &rmask, &rpool->kif,
					    &rpool->states, &rpool->weight,
					    &rpool->curweight, af, NULL))
						return (1);
				} else if (rpool->addr.type == PF_ADDR_DYNIFTL) {
					if (pfr_pool_get(
					    rpool->addr.p.dyn->pfid_kt,
					    &rpool->tblidx, &rpool->counter,
					    &raddr, &rmask, &rpool->kif,
					    &rpool->states, &rpool->weight,
					    &rpool->curweight, af,
					    pf_islinklocal))
d435 3
a437 13
		if (rpool->addr.type == PF_ADDR_TABLE) {
			if (pfr_pool_get(rpool->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, &rpool->kif,
			    &rpool->states, &rpool->weight,
			    &rpool->curweight, af, NULL))
				return (1);
		} else if (rpool->addr.type == PF_ADDR_DYNIFTL) {
			if (pfr_pool_get(rpool->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, &rpool->kif,
			    &rpool->states, &rpool->weight,
			    &rpool->curweight, af, pf_islinklocal))
d465 3
a467 13
			if (rpool->addr.type == PF_ADDR_TABLE) {
				if (pfr_pool_get(rpool->addr.p.tbl,
				    &rpool->tblidx, &rpool->counter,
				    &raddr, &rmask, &rpool->kif,
				    &rpool->states, &rpool->weight,
				    &rpool->curweight, af, NULL))
					return (1);
			} else if (rpool->addr.type == PF_ADDR_DYNIFTL) {
				if (pfr_pool_get(rpool->addr.p.dyn->pfid_kt,
				    &rpool->tblidx, &rpool->counter,
				    &raddr, &rmask, &rpool->kif,
				    &rpool->states, &rpool->weight,
				    &rpool->curweight, af, pf_islinklocal))
@


1.20
log
@The kernel did not compile without INET6.  Put some #ifdefs into
pf to fix that.
- add #ifdef INET6 in obvious places
- af translation is only possible with both INET and INET6
- interleave #endif /* INET6 */ and closing brace correctly
- it is not necessary to #ifdef function prototypes
- do not compile af translate functions at all instead of empty stub,
  then the linker will report inconsistencies
- pf_poolmask() actually takes an sa_family_t not an u_int8_t argument
No binary change for GENERIC compiled with -O2 and -UDIAGNOSTIC.
reported by Olivier Cochard-Labbe; ok mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.19 2011/10/13 18:23:40 claudio Exp $ */
d55 1
d291 2
d483 9
d522 10
a531 1
 
d533 1
a533 1
			if (states > rpool->states) {
d535 2
d589 1
a589 1
		if (((rpool->addr.type == PF_ADDR_TABLE &&
d592 1
a592 2
		    rpool->addr.p.dyn->pfid_kt->pfrkt_refcntcost > 0)) &&
		    ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_LEASTSTATES)) 
@


1.19
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.18 2011/09/18 11:17:57 miod Exp $ */
d585 1
d588 1
d637 1
d766 1
@


1.18
log
@Fix various format string types to as a minimum match the width of the
variables being processed.
ok bluhm@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.17 2011/07/29 10:48:35 mcbride Exp $ */
d106 2
d177 1
a177 1
	if (pf_map_addr(pd->af, r, &pd->nsaddr, naddr, &init_addr, sn, &r->nat,
d191 1
a191 1
		key.af = pd->af;
d256 1
a256 1
			if (pf_map_addr(pd->af, r, &pd->nsaddr, naddr,
d266 1
a266 1
	} while (! PF_AEQ(&init_addr, naddr, pd->af) );
d585 3
d630 129
@


1.17
log
@Make sure we use the right tbl/dyn pointer to check the pfrkt_refcntcost;
improved debugging for error cases inside the weighted round-robin loop.

original diff from claudio, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.16 2011/07/27 00:26:10 mcbride Exp $ */
d563 1
a563 1
			addlog(" with state count %d", states);
@


1.16
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.15 2011/07/03 23:37:55 zinke Exp $ */
d419 4
a422 1
		if (rpool->addr.p.tbl->pfrkt_refcntcost > 0) {
d440 3
a442 2
				} else if (pf_match_addr(0, raddr, rmask,
				    &rpool->counter, af))
d444 3
d448 1
a448 1
			} while (rpool->weight < rpool->curweight);
d564 5
a568 2
		if ((rpool->addr.p.tbl->pfrkt_refcntcost > 0) &&
		    ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_LEASTSTATES))
@


1.15
log
@bring in least-states load balancing algorithm

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.14 2011/05/17 12:44:05 mikeb Exp $ */
d286 2
a287 1
	u_int32_t		 states;
d405 2
a406 1
			    &rpool->states, af, NULL))
d412 2
a413 1
			    &rpool->states, af, pf_islinklocal))
d418 28
d457 2
a458 1
			    &rpool->states, af, NULL))
d464 2
a465 1
			    &rpool->states, af, pf_islinklocal))
a476 1
		PF_AINC(&rpool->counter, af);
d482 2
a483 3
		while (pf_match_addr(1, &faddr, rmask, &rpool->counter, af) &&
		    (states > 0)) {

d488 2
a489 1
				    &rpool->states, af, NULL))
d495 2
a496 1
				    &rpool->states, af, pf_islinklocal))
d498 4
a501 2
			}

d511 2
a512 2
			PF_AINC(&rpool->counter, af);
		}
d557 3
d568 1
a568 1
    struct pf_src_node **sns)
d584 1
d611 1
a611 1

@


1.14
log
@exclude link local address from the dynamic interface address pool
so that rules like "pass out on vr1 inet6 nat-to (vr1)" won't map
to the non routable ipv6 link local address; with suggestions and
ok claudio, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.13 2010/06/27 01:39:43 henning Exp $ */
d253 1
d282 1
d286 1
d318 4
a321 2
			    (rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
d323 2
a324 2
			 raddr = &rpool->addr.p.dyn->pfid_addr4;
			 rmask = &rpool->addr.p.dyn->pfid_mask4;
d330 4
a333 2
			    (rpool->opts & PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
d341 2
a342 1
		if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN)
d403 2
a404 1
			    &raddr, &rmask, &rpool->kif, af, NULL))
d409 2
a410 1
			    &raddr, &rmask, &rpool->kif, af, pf_islinklocal))
d420 83
d519 3
d576 84
@


1.13
log
@stuff nsaddr/ndaddr/nsport/ndport (addrs/ports after NAT, used a lot while
walking the ruleset and up until state is fully set up) into pf_pdesc instead
of passing around those 4 seperately all the time, also shrinks the argument
count for a few functions that have/partialy had an insane count of arguments.
kinda preparational since we'll need them elsewhere too, soon
ok ryan jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.12 2010/02/04 14:10:12 sthen Exp $ */
d106 1
d268 8
d395 1
a395 1
			    &raddr, &rmask, &rpool->kif, af))
d400 1
a400 1
			    &raddr, &rmask, &rpool->kif, af))
@


1.12
log
@pf_get_sport() picks a random port from the port range specified in a
nat rule. It should check to see if it's in-use (i.e. matches an existing
PF state), if it is, it cycles sequentially through other ports until
it finds a free one. However the check was being done with the state
keys the wrong way round so it was never actually finding the state
to be in-use.

- switch the keys to correct this, avoiding random state collisions
with nat. Fixes PR 6300 and problems reported by robert@@ and viq.

- check pf_get_sport() return code in pf_test(); if port allocation
fails the packet should be dropped rather than sent out untranslated.

Help/ok claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.11 2010/01/18 23:52:46 mcbride Exp $ */
d103 3
a105 4
int			 pf_get_sport(sa_family_t, u_int8_t, struct pf_rule *,
			    struct pf_addr *, u_int16_t, struct pf_addr *,
			    u_int16_t, struct pf_addr *, u_int16_t *,
			    u_int16_t, u_int16_t, struct pf_src_node **, int);
d165 1
a165 3
pf_get_sport(sa_family_t af, u_int8_t proto, struct pf_rule *r,
    struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport,
d167 1
a167 1
    struct pf_src_node **sn, int rdomain)
d174 1
a174 1
	if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn, &r->nat,
d178 3
a180 3
	if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
		if (dport == htons(ICMP6_ECHO_REQUEST) ||
		    dport == htons(ICMP_ECHO)) {
d188 4
a191 4
		key.af = af;
		key.proto = proto;
		key.rdomain = rdomain;
		PF_ACPY(&key.addr[0], daddr, key.af);
d193 1
a193 1
		key.port[0] = dport;
d199 2
a200 2
		if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP ||
		    proto == IPPROTO_ICMP)) {
d203 1
a203 1
			key.port[1] = sport;
d205 1
a205 1
				*nport = sport;
d209 1
a209 1
			key.port[1] = sport;
d211 1
a211 1
				*nport = sport;
d234 1
a234 1
				    NULL && !in_baddynamic(tmp, proto)) {
d242 1
a242 1
				    NULL && !in_baddynamic(tmp, proto)) {
d252 2
a253 2
			if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn,
			    &r->nat, PF_SN_NAT))
d262 1
a262 1
	} while (! PF_AEQ(&init_addr, naddr, af) );
d424 1
a424 2
pf_get_transaddr(struct pf_rule *r, struct pf_pdesc *pd, struct pf_addr *saddr,
    u_int16_t *sport, struct pf_addr *daddr, u_int16_t *dport,
d433 2
a434 3
		if (pf_get_sport(pd->af, pd->proto, r, saddr, *sport,
		    daddr, *dport, &naddr, &nport, r->nat.proxy_port[0],
		    r->nat.proxy_port[1], sns, pd->rdomain)) {
d441 2
a442 2
		PF_ACPY(saddr, &naddr, pd->af);
		*sport = nport;
d445 2
a446 2
		if (pf_map_addr(pd->af, r, saddr, &naddr, NULL, sns, &r->rdr,
		    PF_SN_RDR))
d450 1
a450 1
			    daddr, pd->af);
d455 1
a455 1
				tmp_nport = ((ntohs(*dport) -
d468 1
a468 1
		PF_ACPY(daddr, &naddr, pd->af);
d470 1
a470 1
			*dport = nport;
@


1.11
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.10 2010/01/12 03:20:51 mcbride Exp $ */
d104 3
a106 3
			    struct pf_addr *, struct pf_addr *, u_int16_t,
			    struct pf_addr *, u_int16_t *, u_int16_t, u_int16_t,
			    struct pf_src_node **, int);
d167 2
a168 1
    struct pf_addr *saddr, struct pf_addr *daddr, u_int16_t dport,
d194 3
a196 3
		PF_ACPY(&key.addr[1], daddr, key.af);
		PF_ACPY(&key.addr[0], naddr, key.af);
		key.port[1] = dport;
d204 5
a208 3
			/* XXX bug icmp states dont use the id on both sides */
			key.port[0] = dport;
			if (pf_find_state_all(&key, PF_IN, NULL) == NULL)
d210 1
d212 3
a214 2
			key.port[0] = *nport;
			if (pf_find_state_all(&key, PF_IN, NULL) == NULL)
d216 1
d218 1
a218 1
			key.port[0] = htons(low);
d235 1
a235 1
				key.port[0] = htons(tmp);
d243 1
a243 1
				key.port[0] = htons(tmp);
d437 1
a437 1
		if (pf_get_sport(pd->af, pd->proto, r, saddr,
d447 1
a447 2
		if (nport)
			*sport = nport;
@


1.10
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.9 2009/12/14 12:31:45 henning Exp $ */
d54 1
a96 2
#define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x

d284 3
a286 3
			if (pf_status.debug >= PF_DEBUG_NOISY) {
				printf("pf_map_addr: src tracking (%u) maps ",
				    type);
d288 1
a288 1
				printf(" to ");
d290 1
a290 1
				printf("\n");
d410 1
a410 1
	if (pf_status.debug >= PF_DEBUG_MISC &&
d412 1
a412 1
		printf("pf_map_addr: selected address ");
d414 1
a414 1
		printf("\n");
d434 2
a435 3
			DPFPRINTF(PF_DEBUG_MISC,
			    ("pf: NAT proxy port allocation "
			    "(%u-%u) failed\n",
d437 1
a437 1
			    r->nat.proxy_port[1]));
@


1.9
log
@fix sticky-address - by pretty much re-implementing it. still following
the original approach using a source tracking node.
the reimplementation i smore flexible than the original one, we now have an
slist of source tracking nodes per state. that is cheap because more than
one entry will be an absolute exception.
ok beck and jsg, also stress tested by Sebastian Benoit <benoit-lists at fb12.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.8 2009/11/03 10:59:04 claudio Exp $ */
d270 2
a271 3
	struct pf_addr		*raddr = &rpool->cur->addr.v.a.addr;
	struct pf_addr		*rmask = &rpool->cur->addr.v.a.mask;
	struct pf_pooladdr	*acur = rpool->cur;
d285 1
a285 1
			if (pf_status.debug >= PF_DEBUG_MISC) {
d297 1
a297 1
	if (rpool->cur->addr.type == PF_ADDR_NOROUTE)
d299 1
a299 1
	if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
d303 1
a303 1
			if (rpool->cur->addr.p.dyn->pfid_acnt4 < 1 &&
d307 2
a308 2
			 raddr = &rpool->cur->addr.p.dyn->pfid_addr4;
			 rmask = &rpool->cur->addr.p.dyn->pfid_mask4;
d313 1
a313 1
			if (rpool->cur->addr.p.dyn->pfid_acnt6 < 1 &&
d317 2
a318 2
			raddr = &rpool->cur->addr.p.dyn->pfid_addr6;
			rmask = &rpool->cur->addr.p.dyn->pfid_mask6;
d322 1
a322 1
	} else if (rpool->cur->addr.type == PF_ADDR_TABLE) {
d326 2
a327 2
		raddr = &rpool->cur->addr.v.a.addr;
		rmask = &rpool->cur->addr.v.a.mask;
d381 2
a382 2
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			if (!pfr_pool_get(rpool->cur->addr.p.tbl,
d384 1
a384 21
			    &raddr, &rmask, af))
				goto get_addr;
		} else if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
			if (!pfr_pool_get(rpool->cur->addr.p.dyn->pfid_kt,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af))
				goto get_addr;
		} else if (pf_match_addr(0, raddr, rmask, &rpool->counter, af))
			goto get_addr;

	try_next:
		if ((rpool->cur = TAILQ_NEXT(rpool->cur, entries)) == NULL)
			rpool->cur = TAILQ_FIRST(&rpool->list);
		if (rpool->cur->addr.type == PF_ADDR_TABLE) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.tbl,
			    &rpool->tblidx, &rpool->counter,
			    &raddr, &rmask, af)) {
				/* table contains no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
d386 2
a387 4
			}
		} else if (rpool->cur->addr.type == PF_ADDR_DYNIFTL) {
			rpool->tblidx = -1;
			if (pfr_pool_get(rpool->cur->addr.p.dyn->pfid_kt,
d389 1
a389 4
			    &raddr, &rmask, af)) {
				/* table contains no address of type 'af' */
				if (rpool->cur != acur)
					goto try_next;
d391 2
a392 6
			}
		} else {
			raddr = &rpool->cur->addr.v.a.addr;
			rmask = &rpool->cur->addr.v.a.mask;
			PF_ACPY(&rpool->counter, raddr, af);
		}
a393 1
	get_addr:
d411 1
a411 1
	if (pf_status.debug >= PF_DEBUG_NOISY &&
d429 1
a429 1
	if (!TAILQ_EMPTY(&r->nat.list)) {
d446 1
a446 1
	if (!TAILQ_EMPTY(&r->rdr.list)) {
d451 1
a451 1
			PF_POOLMASK(&naddr, &naddr,  &r->rdr.cur->addr.v.a.mask,
@


1.8
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.7 2009/09/07 08:27:45 sthen Exp $ */
d177 2
a178 1
	if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn, &r->nat))
d251 1
a251 1
			    &r->nat))
d266 2
a267 2
    struct pf_addr *naddr, struct pf_addr *init_addr, struct pf_src_node **sn,
    struct pf_pool *rpool)
d275 1
a275 1
	if (*sn == NULL && rpool->opts & PF_POOL_STICKYADDR &&
d278 1
d280 1
a280 5
		if (r->rule_flag & PFRULE_RULESRCTRACK ||
		    rpool->opts & PF_POOL_STICKYADDR)
			k.rule.ptr = r;
		else
			k.rule.ptr = NULL;
d282 4
a285 3
		*sn = RB_FIND(pf_src_tree, &tree_src_tracking, &k);
		if (*sn != NULL && !PF_AZERO(&(*sn)->raddr, af)) {
			PF_ACPY(naddr, &(*sn)->raddr, af);
d287 2
a288 1
				printf("pf_map_addr: src tracking maps ");
d431 10
a440 2
	if (*sn != NULL)
		PF_ACPY(&(*sn)->raddr, naddr, af);
d454 2
a455 1
    u_int16_t *sport, struct pf_addr *daddr, u_int16_t *dport)
a459 2
	struct pf_src_node srcnode, *sn = &srcnode;

d465 1
a465 1
		    r->nat.proxy_port[1], &sn, pd->rdomain)) {
d478 2
a479 1
		if (pf_map_addr(pd->af, r, saddr, &naddr, NULL, &sn, &r->rdr))
a507 1

@


1.7
log
@Fix static-port, found by jmc@@. ok henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.6 2009/09/01 13:42:00 henning Exp $ */
d107 1
a107 1
			    struct pf_src_node **);
d170 1
a170 1
    struct pf_src_node **sn)
d192 1
d454 2
d458 1
a458 1
		    r->nat.proxy_port[1], &sn)) {
@


1.6
log
@the diff theo calls me insanae for:
rewrite of the NAT code, basically. nat and rdr become actions on regular
rules, seperate nat/rdr/binat rules do not exist any more.
match in on $intf rdr-to 1.2.3.4
match out on $intf nat-to 5.6.7.8
the code is capable of doing nat and rdr in any direction, but we prevent
this in pfctl for now, there are implications that need to be documented
better.
the address rewrite happens inline, subsequent rules will see the already
changed addresses. nat / rdr can be applied multiple times as well.
match in on $intf rdr-to 1.2.3.4
match in on $intf to 1.2.3.4 rdr-to 5.6.7.8
help and ok dlg sthen claudio, reyk tested too
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.5 2009/06/24 13:27:34 sthen Exp $ */
d464 2
a465 1
		*sport = nport;
@


1.5
log
@move the "pf_map_addr: selected address" printf up to -xnoisy.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.4 2009/03/05 03:09:37 mcbride Exp $ */
a103 4
struct pf_rule		*pf_match_translation(struct pf_pdesc *, struct mbuf *,
			    int, int, struct pfi_kif *,
			    struct pf_addr *, u_int16_t, struct pf_addr *,
			    u_int16_t, int);
d106 1
a106 1
			    struct pf_addr *, u_int16_t*, u_int16_t, u_int16_t,
a165 81
struct pf_rule *
pf_match_translation(struct pf_pdesc *pd, struct mbuf *m, int off,
    int direction, struct pfi_kif *kif, struct pf_addr *saddr, u_int16_t sport,
    struct pf_addr *daddr, u_int16_t dport, int rs_num)
{
	struct pf_rule		*r, *rm = NULL;
	struct pf_ruleset	*ruleset = NULL;
	int			 tag = -1;
	int			 rtableid = -1;
	int			 asd = 0;

	r = TAILQ_FIRST(pf_main_ruleset.rules[rs_num].active.ptr);
	while (r && rm == NULL) {
		struct pf_rule_addr	*src = NULL, *dst = NULL;
		struct pf_addr_wrap	*xdst = NULL;

		if (r->action == PF_BINAT && direction == PF_IN) {
			src = &r->dst;
			if (r->rpool.cur != NULL)
				xdst = &r->rpool.cur->addr;
		} else {
			src = &r->src;
			dst = &r->dst;
		}

		r->evaluations++;
		if (pfi_kif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != direction)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != pd->af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&src->addr, saddr, pd->af,
		    src->neg, kif))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_ADDR :
			    PF_SKIP_DST_ADDR].ptr;
		else if (src->port_op && !pf_match_port(src->port_op,
		    src->port[0], src->port[1], sport))
			r = r->skip[src == &r->src ? PF_SKIP_SRC_PORT :
			    PF_SKIP_DST_PORT].ptr;
		else if (dst != NULL &&
		    PF_MISMATCHAW(&dst->addr, daddr, pd->af, dst->neg, NULL))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (xdst != NULL && PF_MISMATCHAW(xdst, daddr, pd->af,
		    0, NULL))
			r = TAILQ_NEXT(r, entries);
		else if (dst != NULL && dst->port_op &&
		    !pf_match_port(dst->port_op, dst->port[0],
		    dst->port[1], dport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->match_tag && !pf_match_tag(m, r, &tag))
			r = TAILQ_NEXT(r, entries);
		else if (r->os_fingerprint != PF_OSFP_ANY && (pd->proto !=
		    IPPROTO_TCP || !pf_osfp_match(pf_osfp_fingerprint(pd, m,
		    off, pd->hdr.tcp), r->os_fingerprint)))
			r = TAILQ_NEXT(r, entries);
		else {
			if (r->tag)
				tag = r->tag;
			if (r->rtableid >= 0)
				rtableid = r->rtableid;
			if (r->anchor == NULL) {
				rm = r;
			} else
				pf_step_into_anchor(&asd, &ruleset, rs_num,
				    &r, NULL, NULL);
		}
		if (r == NULL)
			pf_step_out_of_anchor(&asd, &ruleset, rs_num, &r,
			    NULL, NULL);
	}
	if (pf_tag_packet(m, tag, rtableid))
		return (NULL);
	if (rm != NULL && (rm->action == PF_NONAT ||
	    rm->action == PF_NORDR || rm->action == PF_NOBINAT))
		return (NULL);
	return (rm);
}

d177 1
a177 1
	if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
d181 2
a182 1
		if (dport == ICMP6_ECHO_REQUEST || dport == ICMP_ECHO) {
d202 1
d245 1
a245 1
		switch (r->rpool.opts & PF_POOL_TYPEMASK) {
d248 2
a249 1
			if (pf_map_addr(af, r, saddr, naddr, &init_addr, sn))
d264 2
a265 1
    struct pf_addr *naddr, struct pf_addr *init_addr, struct pf_src_node **sn)
a267 1
	struct pf_pool		*rpool = &r->rpool;
d273 2
a274 2
	if (*sn == NULL && r->rpool.opts & PF_POOL_STICKYADDR &&
	    (r->rpool.opts & PF_POOL_TYPEMASK) != PF_POOL_NONE) {
d278 1
a278 1
		    r->rpool.opts & PF_POOL_STICKYADDR)
d443 3
a445 7
struct pf_rule *
pf_get_translation(struct pf_pdesc *pd, struct mbuf *m, int off, int direction,
    struct pfi_kif *kif, struct pf_src_node **sn,
    struct pf_state_key **skw, struct pf_state_key **sks,
    struct pf_state_key **skp, struct pf_state_key **nkp,
    struct pf_addr *saddr, struct pf_addr *daddr,
    u_int16_t sport, u_int16_t dport)
d447 2
a448 1
	struct pf_rule	*r = NULL;
d450 1
d452 13
a464 12
	if (direction == PF_OUT) {
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sport, daddr, dport, PF_RULESET_BINAT);
		if (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sport, daddr, dport, PF_RULESET_NAT);
	} else {
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sport, daddr, dport, PF_RULESET_RDR);
		if (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sport, daddr, dport, PF_RULESET_BINAT);
d466 6
d473 1
a473 115
	if (r != NULL) {
		struct pf_addr	*naddr;
		u_int16_t	*nport;

		if (pf_state_key_setup(pd, r, skw, sks, skp, nkp,
		    saddr, daddr, sport, dport))
			return r;

		/* XXX We only modify one side for now. */
		naddr = &(*nkp)->addr[1];
		nport = &(*nkp)->port[1];

		switch (r->action) {
		case PF_NONAT:
		case PF_NOBINAT:
		case PF_NORDR:
			return (NULL);
		case PF_NAT:
			if (pf_get_sport(pd->af, pd->proto, r, saddr,
			    daddr, dport, naddr, nport, r->rpool.proxy_port[0],
			    r->rpool.proxy_port[1], sn)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    ("pf: NAT proxy port allocation "
				    "(%u-%u) failed\n",
				    r->rpool.proxy_port[0],
				    r->rpool.proxy_port[1]));
				return (NULL);
			}
			break;
		case PF_BINAT:
			switch (direction) {
			case PF_OUT:
				if (r->rpool.cur->addr.type == PF_ADDR_DYNIFTL){
					switch (pd->af) {
#ifdef INET
					case AF_INET:
						if (r->rpool.cur->addr.p.dyn->
						    pfid_acnt4 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_addr4,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_mask4,
						    saddr, AF_INET);
						break;
#endif /* INET */
#ifdef INET6
					case AF_INET6:
						if (r->rpool.cur->addr.p.dyn->
						    pfid_acnt6 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_addr6,
						    &r->rpool.cur->addr.p.dyn->
						    pfid_mask6,
						    saddr, AF_INET6);
						break;
#endif /* INET6 */
					}
				} else
					PF_POOLMASK(naddr,
					    &r->rpool.cur->addr.v.a.addr,
					    &r->rpool.cur->addr.v.a.mask,
					    saddr, pd->af);
				break;
			case PF_IN:
				if (r->src.addr.type == PF_ADDR_DYNIFTL) {
					switch (pd->af) {
#ifdef INET
					case AF_INET:
						if (r->src.addr.p.dyn->
						    pfid_acnt4 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->src.addr.p.dyn->
						    pfid_addr4,
						    &r->src.addr.p.dyn->
						    pfid_mask4,
						    daddr, AF_INET);
						break;
#endif /* INET */
#ifdef INET6
					case AF_INET6:
						if (r->src.addr.p.dyn->
						    pfid_acnt6 < 1)
							return (NULL);
						PF_POOLMASK(naddr,
						    &r->src.addr.p.dyn->
						    pfid_addr6,
						    &r->src.addr.p.dyn->
						    pfid_mask6,
						    daddr, AF_INET6);
						break;
#endif /* INET6 */
					}
				} else
					PF_POOLMASK(naddr,
					    &r->src.addr.v.a.addr,
					    &r->src.addr.v.a.mask, daddr,
					    pd->af);
				break;
			}
			break;
		case PF_RDR: {
			if (pf_map_addr(pd->af, r, saddr, naddr, NULL, sn))
				return (NULL);
			if ((r->rpool.opts & PF_POOL_TYPEMASK) ==
			    PF_POOL_BITMASK)
				PF_POOLMASK(naddr, naddr,
				    &r->rpool.cur->addr.v.a.mask, daddr,
				    pd->af);

			if (r->rpool.proxy_port[1]) {
d476 1
a476 1
				tmp_nport = ((ntohs(dport) -
d478 3
a480 3
				    (r->rpool.proxy_port[1] -
				    r->rpool.proxy_port[0] + 1)) +
				    r->rpool.proxy_port[0];
d485 7
a491 18
				*nport = htons((u_int16_t)tmp_nport);
			} else if (r->rpool.proxy_port[0])
				*nport = htons(r->rpool.proxy_port[0]);
			break;
		}
		default:
			return (NULL);
		}
		/* 
		 * Translation was a NOP.
		 * Pretend there was no match.
		 */
		if (!bcmp(*skp, *nkp, sizeof(struct pf_state_key_cmp))) {
			pool_put(&pf_state_key_pl, *nkp);
			pool_put(&pf_state_key_pl, *skp);
			*skw = *sks = *nkp = *skp = NULL;
			return (NULL);
		}
d494 1
a494 1
	return (r);
@


1.4
log
@Stricter state checking for ICMP and ICMPv6 packets: include the ICMP type
in one port of the state key, using the type to determine which side should
be the id, and which should be the type. Also:
- Handle ICMP6 messages which are typically sent to multicast addresses but
  recieve unicast replies, by doing fallthrough lookups against the correct
  multicast address.
- Clear up some mistaken assumptions in the PF code:
   - Not all ICMP packets have an icmp_id, so simulate one based on other
     data if we can, otherwise set it to 0.
   - Don't modify the icmp id field in NAT unless it's echo
   - Use the full range of possible id's when NATing icmp6 echoy

ok henning marco
testing matthieu todd
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.3 2009/02/18 20:06:23 henning Exp $ */
d515 1
a515 1
	if (pf_status.debug >= PF_DEBUG_MISC &&
@


1.3
log
@bring back the NAT NOP fix, but this time right.
when we want to pretend pf_get_translation didn't do anything we must
get rid of _both_ state keys and reset all 4 sk pointers to NULL and
not leave one key behind and have all 4 pointers point to it - that must
fail. tested dhill sthen, david agrees, deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.2 2009/02/12 02:13:15 sthen Exp $ */
d265 6
a270 3
	if (proto == IPPROTO_ICMP) {
		low = 1;
		high = 65535;
@


1.2
log
@revert pf.c r1.629 (which moved to this file) which was causing
"panic: pool_do_get(pfstatekeypl): free list modified" discussed with many.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_lb.c,v 1.1 2009/01/29 15:12:28 pyr Exp $ */
d679 10
@


1.1
log
@Split the address selection from pools away from pf.c and put it in
pf_lb.c. This will ease the process of adding more selection types
without bloatening pf.c even more.

ok and a weird death threat, henning@@
raised eyebrow, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.629 2009/01/27 17:33:07 mpf Exp $ */
a678 9
			return (NULL);
		}
		/* 
		 * Translation was a NOP.
		 * Undo separate NAT key and pretend there was no match.
		 */
		if (!bcmp(*skp, *nkp, sizeof(struct pf_state_key_cmp))) {
			pool_put(&pf_state_key_pl, *nkp);
			*skw = *sks = *nkp = *skp;
@

