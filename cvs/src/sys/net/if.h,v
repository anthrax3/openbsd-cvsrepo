head	1.186;
access;
symbols
	OPENBSD_6_2:1.186.0.2
	OPENBSD_6_2_BASE:1.186
	OPENBSD_6_1:1.186.0.4
	OPENBSD_6_1_BASE:1.186
	OPENBSD_6_0:1.177.0.4
	OPENBSD_6_0_BASE:1.177
	OPENBSD_5_9:1.175.0.2
	OPENBSD_5_9_BASE:1.175
	OPENBSD_5_8:1.164.0.4
	OPENBSD_5_8_BASE:1.164
	OPENBSD_5_7:1.160.0.2
	OPENBSD_5_7_BASE:1.160
	OPENBSD_5_6:1.157.0.4
	OPENBSD_5_6_BASE:1.157
	OPENBSD_5_5:1.153.0.4
	OPENBSD_5_5_BASE:1.153
	OPENBSD_5_4:1.144.0.2
	OPENBSD_5_4_BASE:1.144
	OPENBSD_5_3:1.137.0.2
	OPENBSD_5_3_BASE:1.137
	OPENBSD_5_2:1.131.0.4
	OPENBSD_5_2_BASE:1.131
	OPENBSD_5_1_BASE:1.131
	OPENBSD_5_1:1.131.0.2
	OPENBSD_5_0:1.128.0.2
	OPENBSD_5_0_BASE:1.128
	OPENBSD_4_9:1.121.0.2
	OPENBSD_4_9_BASE:1.121
	OPENBSD_4_8:1.117.0.2
	OPENBSD_4_8_BASE:1.117
	OPENBSD_4_7:1.113.0.2
	OPENBSD_4_7_BASE:1.113
	OPENBSD_4_6:1.107.0.4
	OPENBSD_4_6_BASE:1.107
	OPENBSD_4_5:1.103.0.2
	OPENBSD_4_5_BASE:1.103
	OPENBSD_4_4:1.94.0.2
	OPENBSD_4_4_BASE:1.94
	OPENBSD_4_3:1.93.0.2
	OPENBSD_4_3_BASE:1.93
	OPENBSD_4_2:1.91.0.2
	OPENBSD_4_2_BASE:1.91
	OPENBSD_4_1:1.86.0.2
	OPENBSD_4_1_BASE:1.86
	OPENBSD_4_0:1.82.0.2
	OPENBSD_4_0_BASE:1.82
	OPENBSD_3_9:1.77.0.2
	OPENBSD_3_9_BASE:1.77
	OPENBSD_3_8:1.76.0.2
	OPENBSD_3_8_BASE:1.76
	OPENBSD_3_7:1.64.0.2
	OPENBSD_3_7_BASE:1.64
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	SMP_SYNC_A:1.53
	SMP_SYNC_B:1.53
	OPENBSD_3_5:1.49.0.2
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.40.0.4
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.40.0.2
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.34.0.2
	OPENBSD_3_1_BASE:1.34
	UBC_SYNC_B:1.40
	UBC:1.31.0.4
	UBC_BASE:1.31
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.15.0.2
	SMP_BASE:1.15
	kame_19991208:1.14
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.8
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.6
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.186
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.185;
commitid	6c6qq5OdS4VVnyVM;

1.185
date	2017.01.24.03.57.35;	author dlg;	state Exp;
branches;
next	1.184;
commitid	PERtGPXCvlLRRBr8;

1.184
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.183;
commitid	F6oNrr9LCLUSAxgA;

1.183
date	2017.01.23.07.27.21;	author dlg;	state Exp;
branches;
next	1.182;
commitid	GMRaunaipkxtJbHJ;

1.182
date	2017.01.23.01.26.09;	author dlg;	state Exp;
branches;
next	1.181;
commitid	3JbnbVjcNixwggnm;

1.181
date	2016.12.12.09.51.30;	author mpi;	state Exp;
branches;
next	1.180;
commitid	4shAe6LbqmAnsu7t;

1.180
date	2016.10.27.03.00.35;	author dlg;	state Exp;
branches;
next	1.179;
commitid	mVw8XVKgCJUdoyQ9;

1.179
date	2016.09.04.15.10.59;	author reyk;	state Exp;
branches;
next	1.178;
commitid	WiybL9FZDMpyujgS;

1.178
date	2016.09.03.13.46.57;	author reyk;	state Exp;
branches;
next	1.177;
commitid	3QjHFZLzmkdTcUlc;

1.177
date	2016.06.10.20.33.29;	author vgross;	state Exp;
branches;
next	1.176;
commitid	qJaxh4rw41tBg4CK;

1.176
date	2016.03.02.00.00.16;	author dlg;	state Exp;
branches;
next	1.175;
commitid	7U01XYSlRSFgd0i5;

1.175
date	2015.12.05.19.04.37;	author deraadt;	state Exp;
branches;
next	1.174;
commitid	VfiucnCoz9uqpAZN;

1.174
date	2015.12.03.12.22.51;	author dlg;	state Exp;
branches;
next	1.173;
commitid	Xu3de8VDlKImDsXf;

1.173
date	2015.11.20.12.27.42;	author mpi;	state Exp;
branches;
next	1.172;
commitid	3FP0bC2PMwNhAj60;

1.172
date	2015.10.24.10.52.05;	author reyk;	state Exp;
branches;
next	1.171;
commitid	PvSfHvj4AhI0uuuE;

1.171
date	2015.10.23.10.22.29;	author claudio;	state Exp;
branches;
next	1.170;
commitid	T6PH2wUDdHyRNguI;

1.170
date	2015.10.23.01.19.04;	author dlg;	state Exp;
branches;
next	1.169;
commitid	amrA8l73DaZf9wmS;

1.169
date	2015.10.05.15.19.29;	author uebayasi;	state Exp;
branches;
next	1.168;
commitid	CO29eq1de4LE0DwZ;

1.168
date	2015.09.27.16.50.03;	author stsp;	state Exp;
branches;
next	1.167;
commitid	Z03sNcTWKzvxcY9M;

1.167
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.166;
commitid	6vhYvh5CxZAHMnsN;

1.166
date	2015.09.09.16.01.10;	author dlg;	state Exp;
branches;
next	1.165;
commitid	K9CHsxd7Pm2AnGZf;

1.165
date	2015.08.30.10.39.16;	author mpi;	state Exp;
branches;
next	1.164;
commitid	avqdJydG8T8nvZhe;

1.164
date	2015.06.07.12.02.28;	author jsg;	state Exp;
branches;
next	1.163;
commitid	st7eUqjf7vKTD48M;

1.163
date	2015.05.18.13.32.28;	author reyk;	state Exp;
branches;
next	1.162;
commitid	ndMf9FjDLv5uu2sS;

1.162
date	2015.04.10.08.48.24;	author mpi;	state Exp;
branches;
next	1.161;
commitid	izQrYBwx0zII1gXv;

1.161
date	2015.03.18.12.23.15;	author dlg;	state Exp;
branches;
next	1.160;
commitid	veRr3qZI7HBatTwk;

1.160
date	2015.02.08.06.00.52;	author mpi;	state Exp;
branches;
next	1.159;
commitid	LWJ12V7CpWdalkDf;

1.159
date	2015.01.06.21.26.46;	author stsp;	state Exp;
branches;
next	1.158;
commitid	jH0HZyR3DaPVl7Rm;

1.158
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.157;
commitid	t9FBKDfc4VDxpEy2;

1.157
date	2014.07.14.03.45.43;	author dlg;	state Exp;
branches;
next	1.156;
commitid	Mr2kSMK41Wx62IQY;

1.156
date	2014.07.11.16.39.06;	author henning;	state Exp;
branches;
next	1.155;
commitid	AGagL83SRBC6d7e7;

1.155
date	2014.07.08.04.02.14;	author dlg;	state Exp;
branches;
next	1.154;
commitid	1jRrZP5Li2zmiVEq;

1.154
date	2014.06.13.07.28.12;	author mpi;	state Exp;
branches;
next	1.153;
commitid	LDGswZYWsVqKEviC;

1.153
date	2013.11.21.17.32.12;	author mikeb;	state Exp;
branches;
next	1.152;

1.152
date	2013.11.09.06.38.42;	author dlg;	state Exp;
branches;
next	1.151;

1.151
date	2013.11.01.22.55.39;	author pelikan;	state Exp;
branches;
next	1.150;

1.150
date	2013.10.21.15.10.29;	author benno;	state Exp;
branches;
next	1.149;

1.149
date	2013.10.19.14.05.14;	author reyk;	state Exp;
branches;
next	1.148;

1.148
date	2013.10.13.10.10.02;	author reyk;	state Exp;
branches;
next	1.147;

1.147
date	2013.10.12.12.13.10;	author henning;	state Exp;
branches;
next	1.146;

1.146
date	2013.09.17.13.34.17;	author mpi;	state Exp;
branches;
next	1.145;

1.145
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.144;

1.144
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.143;

1.143
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.142;

1.142
date	2013.04.02.08.54.37;	author mpi;	state Exp;
branches;
next	1.141;

1.141
date	2013.03.26.13.19.25;	author mpi;	state Exp;
branches;
next	1.140;

1.140
date	2013.03.20.10.34.12;	author mpi;	state Exp;
branches;
next	1.139;

1.139
date	2013.03.07.09.40.19;	author mpi;	state Exp;
branches;
next	1.138;

1.138
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.137;

1.137
date	2012.11.23.20.12.03;	author sthen;	state Exp;
branches;
next	1.136;

1.136
date	2012.11.11.04.45.37;	author deraadt;	state Exp;
branches;
next	1.135;

1.135
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.134;

1.134
date	2012.09.19.15.29.53;	author henning;	state Exp;
branches;
next	1.133;

1.133
date	2012.09.10.02.24.24;	author guenther;	state Exp;
branches;
next	1.132;

1.132
date	2012.08.21.19.50.39;	author bluhm;	state Exp;
branches;
next	1.131;

1.131
date	2011.12.02.03.15.31;	author haesbaert;	state Exp;
branches;
next	1.130;

1.130
date	2011.11.02.02.03.47;	author haesbaert;	state Exp;
branches;
next	1.129;

1.129
date	2011.10.07.17.10.08;	author henning;	state Exp;
branches;
next	1.128;

1.128
date	2011.07.08.18.48.51;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2011.07.07.20.41.36;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2011.07.05.00.58.27;	author henning;	state Exp;
branches;
next	1.125;

1.125
date	2011.07.03.23.12.29;	author henning;	state Exp;
branches;
next	1.124;

1.124
date	2011.07.03.23.05.35;	author henning;	state Exp;
branches;
next	1.123;

1.123
date	2011.07.03.17.41.50;	author claudio;	state Exp;
branches;
next	1.122;

1.122
date	2011.03.13.15.31.41;	author stsp;	state Exp;
branches;
next	1.121;

1.121
date	2010.11.17.18.51.57;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2010.09.24.13.29.29;	author claudio;	state Exp;
branches;
next	1.119;

1.119
date	2010.09.23.10.49.55;	author dlg;	state Exp;
branches;
next	1.118;

1.118
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.117;

1.117
date	2010.06.26.19.49.54;	author claudio;	state Exp;
branches;
next	1.116;

1.116
date	2010.05.28.12.09.09;	author claudio;	state Exp;
branches;
next	1.115;

1.115
date	2010.04.17.17.46.32;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2010.04.06.14.12.10;	author stsp;	state Exp;
branches;
next	1.113;

1.113
date	2010.01.13.02.26.49;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2010.01.13.02.13.12;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2010.01.12.00.39.18;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2009.09.17.13.27.24;	author claudio;	state Exp;
branches;
next	1.109;

1.109
date	2009.09.14.11.42.52;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2009.08.10.11.22.10;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2009.06.06.12.31.17;	author rainer;	state Exp;
branches;
next	1.106;

1.106
date	2009.06.05.00.05.21;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2009.06.04.19.07.21;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2009.06.03.20.35.37;	author beck;	state Exp;
branches;
next	1.103;

1.103
date	2009.01.27.09.17.51;	author dlg;	state Exp;
branches;
next	1.102;

1.102
date	2008.12.12.22.07.33;	author claudio;	state Exp;
branches;
next	1.101;

1.101
date	2008.12.11.16.45.45;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2008.11.30.00.14.42;	author brad;	state Exp;
branches;
next	1.99;

1.99
date	2008.11.26.17.36.23;	author dlg;	state Exp;
branches;
next	1.98;

1.98
date	2008.11.25.12.47.00;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2008.11.24.14.26.54;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2008.11.24.12.57.37;	author dlg;	state Exp;
branches;
next	1.95;

1.95
date	2008.11.07.05.50.33;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2008.04.10.23.15.45;	author dlg;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.18.12.51.48;	author mpf;	state Exp;
branches;
next	1.92;

1.92
date	2007.09.03.15.24.49;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2007.06.25.16.37.58;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2007.06.14.18.31.49;	author reyk;	state Exp;
branches;
next	1.89;

1.89
date	2007.05.29.18.18.57;	author uwe;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.26.17.13.30;	author jason;	state Exp;
branches;
next	1.87;

1.87
date	2007.03.27.11.22.59;	author jmc;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.09.09.16.59;	author jmc;	state Exp;
branches;
next	1.85;

1.85
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.84;

1.84
date	2006.11.16.13.09.27;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2006.10.31.14.28.29;	author jason;	state Exp;
branches;
next	1.82;

1.82
date	2006.06.02.19.53.12;	author mpf;	state Exp;
branches;
next	1.81;

1.81
date	2006.05.27.10.03.15;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2006.05.26.20.50.41;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2006.05.19.19.50.23;	author reyk;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2006.02.09.00.05.55;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2005.06.14.04.00.39;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2005.06.14.03.54.31;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2005.06.12.00.41.33;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2005.06.07.18.21.44;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2005.06.06.03.44.21;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2005.06.05.20.49.25;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.24.04.20.25;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.24.02.45.17;	author reyk;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.24.02.26.04;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.22.18.23.04;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.21.21.03.57;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.20.23.00.40;	author mpf;	state Exp;
branches;
next	1.64;

1.64
date	2005.02.07.15.00.17;	author mcbride;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.14.11.49.01;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.12.07.20.38.46;	author mcbride;	state Exp;
branches;
next	1.61;

1.61
date	2004.12.07.19.26.46;	author mcbride;	state Exp;
branches;
next	1.60;

1.60
date	2004.12.03.17.31.03;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2004.11.10.21.10.53;	author grange;	state Exp;
branches;
next	1.58;

1.58
date	2004.10.14.21.28.15;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2004.10.11.10.13.49;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.26.17.36.33;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.25.18.24.23;	author pb;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.20.00.38.21;	author beck;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.29.17.54.45;	author jcs;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.18.21.10.14;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.26.05.24.00;	author mcbride;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.17.00.09.01;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.15.10.47.55;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.10.03.30.21;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.08.09.09.03;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.03.13.27.36;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.19.03.58.25;	author david;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.17.21.04.58;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.25.08.18.54;	author fgsch;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.30.13.04.35;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.23.23.55.04;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.27.13.42.16;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.27.02.59.40;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.24.00.51.51;	author dhartmei;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.23.19.16.09;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.05.08.34.46;	author angelos;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2001.07.05.08.27.38;	author jjbg;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.27.05.50.06;	author kjc;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.23.22.52.51;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.15.03.38.33;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.09.06.16.37;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.28.10.29.21;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.28.05.52.51;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.28.05.16.27;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.06.00.22.22;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.19.06.37.36;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.20.13.07.25;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.28.18.30.38;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.26.20.04.16;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.22.11.28.42;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.21.23.31.26;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.02.17.14.36;	author itojun;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.06.23.21.55.28;	author cmetz;	state Exp;
branches;
next	1.11;

1.11
date	99.03.13.19.06.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.02.26.17.01.31;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	99.01.07.06.03.28;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.09.03.06.24.20;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	96.07.02.06.52.04;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.06.29.18.54.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.10.12.31.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.06.05.43.43;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.05.15.44.23;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.21.07.06;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2000.03.24.09.09.31;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.05.14.22.39.59;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.07.04.10.53.53;	author niklas;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.15.2.8;

1.15.2.8
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.15.2.9;

1.15.2.9
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.15.2.10;

1.15.2.10
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.31.4.1
date	2002.01.31.22.55.43;	author niklas;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.31.4.3;

1.31.4.3
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	;


desc
@@


1.186
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: if.h,v 1.185 2017/01/24 03:57:35 dlg Exp $	*/
/*	$NetBSD: if.h,v 1.23 1996/05/07 02:40:27 thorpej Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NET_IF_H_
#define _NET_IF_H_

#include <sys/cdefs.h>

/*
 * Length of interface external name, including terminating '\0'.
 * Note: this is the same size as a generic device's external name.
 */
#define	IF_NAMESIZE	16

struct if_nameindex {
	unsigned int	if_index;
	char		*if_name;
};

#ifndef _KERNEL
__BEGIN_DECLS
unsigned int if_nametoindex(const char *);
char	*if_indextoname(unsigned int, char *);
struct	if_nameindex *if_nameindex(void);
void	if_freenameindex(struct if_nameindex *);
__END_DECLS
#endif

#if __BSD_VISIBLE

/*
 * Structure used to query names of interface cloners.
 */
struct if_clonereq {
	int	ifcr_total;		/* total cloners (out) */
	int	ifcr_count;		/* room for this many in user buffer */
	char	*ifcr_buffer;		/* buffer for cloner names */
};

#define MCLPOOLS	8		/* number of cluster pools */

struct if_rxring {
	int     rxr_adjusted;
	u_int	rxr_alive;
	u_int	rxr_cwm;
	u_int	rxr_lwm;
	u_int	rxr_hwm;
};

struct if_rxring_info {
	char	ifr_name[16];		/* name of the ring */
	u_int	ifr_size;		/* size of the packets on the ring */
	struct if_rxring ifr_info;
};

/* Structure used in SIOCGIFRXR request. */
struct if_rxrinfo {
	u_int	ifri_total;
	struct if_rxring_info *ifri_entries;
};

/*
 * Structure defining statistics and other data kept regarding a network
 * interface.
 */
struct	if_data {
	/* generic interface information */
	u_char		ifi_type;		/* ethernet, tokenring, etc. */
	u_char		ifi_addrlen;		/* media address length */
	u_char		ifi_hdrlen;		/* media header length */
	u_char		ifi_link_state;		/* current link state */
	u_int32_t	ifi_mtu;		/* maximum transmission unit */
	u_int32_t	ifi_metric;		/* routing metric (external only) */
	u_int32_t	ifi_rdomain;		/* routing instance */
	u_int64_t	ifi_baudrate;		/* linespeed */
	/* volatile statistics */
	u_int64_t	ifi_ipackets;		/* packets received on interface */
	u_int64_t	ifi_ierrors;		/* input errors on interface */
	u_int64_t	ifi_opackets;		/* packets sent on interface */
	u_int64_t	ifi_oerrors;		/* output errors on interface */
	u_int64_t	ifi_collisions;		/* collisions on csma interfaces */
	u_int64_t	ifi_ibytes;		/* total number of octets received */
	u_int64_t	ifi_obytes;		/* total number of octets sent */
	u_int64_t	ifi_imcasts;		/* packets received via multicast */
	u_int64_t	ifi_omcasts;		/* packets sent via multicast */
	u_int64_t	ifi_iqdrops;		/* dropped on input, this interface */
	u_int64_t	ifi_oqdrops;		/* dropped on output, this interface */
	u_int64_t	ifi_noproto;		/* destined for unsupported protocol */
	u_int32_t	ifi_capabilities;	/* interface capabilities */
	struct	timeval ifi_lastchange;	/* last operational state change */
};

#define IFQ_NQUEUES	8
#define IFQ_MAXPRIO	IFQ_NQUEUES - 1
#define IFQ_DEFPRIO	3

/*
 * Values for if_link_state.
 */
#define LINK_STATE_UNKNOWN	0	/* link unknown */
#define LINK_STATE_INVALID	1	/* link invalid */
#define LINK_STATE_DOWN		2	/* link is down */
#define LINK_STATE_KALIVE_DOWN	3	/* keepalive reports down */
#define LINK_STATE_UP		4	/* link is up */
#define LINK_STATE_HALF_DUPLEX	5	/* link is up and half duplex */
#define LINK_STATE_FULL_DUPLEX	6	/* link is up and full duplex */

#define LINK_STATE_IS_UP(_s)	\
		((_s) >= LINK_STATE_UP || (_s) == LINK_STATE_UNKNOWN)

/*
 * Status bit descriptions for the various interface types.
 */
struct if_status_description {
	u_char	ifs_type;
	u_char	ifs_state;
	const char *ifs_string;
};

#define LINK_STATE_DESC_MATCH(_ifs, _t, _s)				\
	(((_ifs)->ifs_type == (_t) || (_ifs)->ifs_type == 0) &&		\
	    (_ifs)->ifs_state == (_s))


#define LINK_STATE_DESCRIPTIONS {					\
	{ IFT_ETHER, LINK_STATE_DOWN, "no carrier" },			\
									\
	{ IFT_IEEE80211, LINK_STATE_DOWN, "no network" },		\
									\
	{ IFT_PPP, LINK_STATE_DOWN, "no carrier" },			\
									\
	{ IFT_CARP, LINK_STATE_DOWN, "backup" },			\
	{ IFT_CARP, LINK_STATE_UP, "master" },				\
	{ IFT_CARP, LINK_STATE_HALF_DUPLEX, "master" },			\
	{ IFT_CARP, LINK_STATE_FULL_DUPLEX, "master" },			\
									\
	{ 0, LINK_STATE_UP, "active" },					\
	{ 0, LINK_STATE_HALF_DUPLEX, "active" },			\
	{ 0, LINK_STATE_FULL_DUPLEX, "active" },			\
									\
	{ 0, LINK_STATE_UNKNOWN, "unknown" },				\
	{ 0, LINK_STATE_INVALID, "invalid" },				\
	{ 0, LINK_STATE_DOWN, "down" },					\
	{ 0, LINK_STATE_KALIVE_DOWN, "keepalive down" },		\
	{ 0, 0, NULL }							\
}

/* Traditional BSD name for length of interface external name. */
#define	IFNAMSIZ	IF_NAMESIZE

/*
 * Length of interface description, including terminating '\0'.
 */
#define	IFDESCRSIZE	64

#define	IFF_UP		0x1		/* interface is up */
#define	IFF_BROADCAST	0x2		/* broadcast address valid */
#define	IFF_DEBUG	0x4		/* turn on debugging */
#define	IFF_LOOPBACK	0x8		/* is a loopback net */
#define	IFF_POINTOPOINT	0x10		/* interface is point-to-point link */
#define	IFF_NOTRAILERS	0x20		/* avoid use of trailers */
#define	IFF_RUNNING	0x40		/* resources allocated */
#define	IFF_NOARP	0x80		/* no address resolution protocol */
#define	IFF_PROMISC	0x100		/* receive all packets */
#define	IFF_ALLMULTI	0x200		/* receive all multicast packets */
#define	IFF_OACTIVE	0x400		/* transmission in progress */
#define	IFF_SIMPLEX	0x800		/* can't hear own transmissions */
#define	IFF_LINK0	0x1000		/* per link layer defined bit */
#define	IFF_LINK1	0x2000		/* per link layer defined bit */
#define	IFF_LINK2	0x4000		/* per link layer defined bit */
#define	IFF_MULTICAST	0x8000		/* supports multicast */

/* flags set internally only: */
#define	IFF_CANTCHANGE \
	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_RUNNING|IFF_OACTIVE|\
	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI)

#define	IFXF_MPSAFE		0x1		/* if_start is mpsafe */
#define	IFXF_CLONED		0x2		/* pseudo interface */
#define	IFXF_INET6_NOPRIVACY	0x4		/* don't autoconf privacy */
#define	IFXF_MPLS		0x8		/* supports MPLS */
#define	IFXF_WOL		0x10		/* wake on lan enabled */
#define	IFXF_AUTOCONF6		0x20		/* v6 autoconf enabled */

#define	IFXF_CANTCHANGE \
	(IFXF_MPSAFE|IFXF_CLONED)

/*
 * Some convenience macros used for setting ifi_baudrate.
 */
#define	IF_Kbps(x)	((x) * 1000ULL)			/* kilobits/sec. */
#define	IF_Mbps(x)	(IF_Kbps((x) * 1000ULL))	/* megabits/sec. */
#define	IF_Gbps(x)	(IF_Mbps((x) * 1000ULL))	/* gigabits/sec. */

/* Capabilities that interfaces can advertise. */
#define	IFCAP_CSUM_IPv4		0x00000001	/* can do IPv4 header csum */
#define	IFCAP_CSUM_TCPv4	0x00000002	/* can do IPv4/TCP csum */
#define	IFCAP_CSUM_UDPv4	0x00000004	/* can do IPv4/UDP csum */
#define	IFCAP_VLAN_MTU		0x00000010	/* VLAN-compatible MTU */
#define	IFCAP_VLAN_HWTAGGING	0x00000020	/* hardware VLAN tag support */
#define	IFCAP_CSUM_TCPv6	0x00000080	/* can do IPv6/TCP checksums */
#define	IFCAP_CSUM_UDPv6	0x00000100	/* can do IPv6/UDP checksums */
#define	IFCAP_WOL		0x00008000	/* can do wake on lan */

#define IFCAP_CSUM_MASK		(IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | \
    IFCAP_CSUM_UDPv4 | IFCAP_CSUM_TCPv6 | IFCAP_CSUM_UDPv6)

/* symbolic names for terminal (per-protocol) CTL_IFQ_ nodes */
#define IFQCTL_LEN 1
#define IFQCTL_MAXLEN 2
#define IFQCTL_DROPS 3
#define IFQCTL_CONGESTION 4
#define IFQCTL_MAXID 5

/* sysctl for ifq (per-protocol packet input queue variant of ifqueue) */
#define CTL_IFQ_NAMES  { \
	{ 0, 0 }, \
	{ "len", CTLTYPE_INT }, \
	{ "maxlen", CTLTYPE_INT }, \
	{ "drops", CTLTYPE_INT }, \
	{ "congestion", CTLTYPE_INT }, \
}

/*
 * Message format for use in obtaining information about interfaces
 * from sysctl and the routing socket.
 */
struct if_msghdr {
	u_short	ifm_msglen;	/* to skip over non-understood messages */
	u_char	ifm_version;	/* future binary compatibility */
	u_char	ifm_type;	/* message type */
	u_short ifm_hdrlen;	/* sizeof(if_msghdr) to skip over the header */
	u_short	ifm_index;	/* index for associated ifp */
	u_short	ifm_tableid;	/* routing table id */
	u_char	ifm_pad1;
	u_char	ifm_pad2;
	int	ifm_addrs;	/* like rtm_addrs */
	int	ifm_flags;	/* value of if_flags */
	int	ifm_xflags;
	struct	if_data ifm_data;/* statistics and other data about if */
};

/*
 * Message format for use in obtaining information about interface addresses
 * from sysctl and the routing socket.
 */
struct ifa_msghdr {
	u_short	ifam_msglen;	/* to skip over non-understood messages */
	u_char	ifam_version;	/* future binary compatibility */
	u_char	ifam_type;	/* message type */
	u_short ifam_hdrlen;	/* sizeof(ifa_msghdr) to skip over the header */
	u_short	ifam_index;	/* index for associated ifp */
	u_short	ifam_tableid;	/* routing table id */
	u_char	ifam_pad1;
	u_char	ifam_pad2;
	int	ifam_addrs;	/* like rtm_addrs */
	int	ifam_flags;	/* value of ifa_flags */
	int	ifam_metric;	/* value of ifa_metric */
};

/*
 * Message format announcing the arrival or departure of a network interface.
 */
struct if_announcemsghdr {
	u_short	ifan_msglen;	/* to skip over non-understood messages */
	u_char	ifan_version;	/* future binary compatibility */
	u_char	ifan_type;	/* message type */
	u_short ifan_hdrlen;	/* sizeof(ifa_msghdr) to skip over the header */
	u_short	ifan_index;	/* index for associated ifp */
	u_short	ifan_what;	/* what type of announcement */
	char	ifan_name[IFNAMSIZ];	/* if name, e.g. "en0" */
};

#define IFAN_ARRIVAL	0	/* interface arrival */
#define IFAN_DEPARTURE	1	/* interface departure */

/* message format used to pass interface name to index mappings */
struct if_nameindex_msg {
	unsigned int	if_index;
	char		if_name[IFNAMSIZ];
};

/*
 * interface groups
 */

#define	IFG_ALL		"all"		/* group contains all interfaces */
#define	IFG_EGRESS	"egress"	/* if(s) default route(s) point to */

struct ifg_req {
	union {
		char			 ifgrqu_group[IFNAMSIZ];
		char			 ifgrqu_member[IFNAMSIZ];
	} ifgrq_ifgrqu;
#define	ifgrq_group	ifgrq_ifgrqu.ifgrqu_group
#define	ifgrq_member	ifgrq_ifgrqu.ifgrqu_member
};

struct ifg_attrib {
	int	ifg_carp_demoted;
};

/*
 * Used to lookup groups for an interface
 */
struct ifgroupreq {
	char	ifgr_name[IFNAMSIZ];
	u_int	ifgr_len;
	union {
		char			 ifgru_group[IFNAMSIZ];
		struct	ifg_req		*ifgru_groups;
		struct	ifg_attrib	 ifgru_attrib;
	} ifgr_ifgru;
#define ifgr_group	ifgr_ifgru.ifgru_group
#define ifgr_groups	ifgr_ifgru.ifgru_groups
#define ifgr_attrib	ifgr_ifgru.ifgru_attrib
};

/*
 * Interface request structure used for socket
 * ioctl's.  All interface ioctl's must have parameter
 * definitions which begin with ifr_name.  The
 * remainder may be interface specific.
 */
struct	ifreq {
	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	union {
		struct	sockaddr	ifru_addr;
		struct	sockaddr	ifru_dstaddr;
		struct	sockaddr	ifru_broadaddr;
		short			ifru_flags;
		int			ifru_metric;
		int64_t			ifru_vnetid;
		uint64_t		ifru_media;
		caddr_t			ifru_data;
		unsigned int		ifru_index;
	} ifr_ifru;
#define	ifr_addr	ifr_ifru.ifru_addr	/* address */
#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */
#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
#define	ifr_flags	ifr_ifru.ifru_flags	/* flags */
#define	ifr_metric	ifr_ifru.ifru_metric	/* metric */
#define	ifr_mtu		ifr_ifru.ifru_metric	/* mtu (overload) */
#define	ifr_hardmtu	ifr_ifru.ifru_metric	/* hardmtu (overload) */
#define	ifr_media	ifr_ifru.ifru_media	/* media options */
#define	ifr_rdomainid	ifr_ifru.ifru_metric	/* VRF instance (overload) */
#define ifr_vnetid	ifr_ifru.ifru_vnetid	/* Virtual Net Id */
#define ifr_ttl		ifr_ifru.ifru_metric	/* tunnel TTL (overload) */
#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface */
#define ifr_index	ifr_ifru.ifru_index	/* interface index */
#define ifr_llprio	ifr_ifru.ifru_metric	/* link layer priority */
};

struct ifaliasreq {
	char	ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	union {
		struct	sockaddr ifrau_addr;
		int	ifrau_align;
	 } ifra_ifrau;
#ifndef ifra_addr
#define ifra_addr	ifra_ifrau.ifrau_addr
#endif
	struct	sockaddr ifra_dstaddr;
#define	ifra_broadaddr	ifra_dstaddr
	struct	sockaddr ifra_mask;
};

struct ifmediareq {
	char		ifm_name[IFNAMSIZ];	/* if name, e.g. "en0" */
	uint64_t	ifm_current;		/* get/set current media options */
	uint64_t	ifm_mask;		/* don't care mask */
	uint64_t	ifm_status;		/* media status */
	uint64_t	ifm_active;		/* active options */
	int		ifm_count;		/* # entries in ifm_ulist array */
	uint64_t	*ifm_ulist;		/* media words */
};

struct ifkalivereq {
	char	ikar_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	int	ikar_timeo;
	int	ikar_cnt;
};

/*
 * Structure used in SIOCGIFCONF request.
 * Used to retrieve interface configuration
 * for machine (useful for programs which
 * must know all networks accessible).
 */
struct	ifconf {
	int	ifc_len;		/* size of associated buffer */
	union {
		caddr_t	ifcu_buf;
		struct	ifreq *ifcu_req;
	} ifc_ifcu;
#define	ifc_buf	ifc_ifcu.ifcu_buf	/* buffer address */
#define	ifc_req	ifc_ifcu.ifcu_req	/* array of structures returned */
};

/*
 * Structure for SIOC[AGD]LIFADDR
 */
struct if_laddrreq {
	char iflr_name[IFNAMSIZ];
	unsigned int flags;
#define IFLR_PREFIX	0x8000	/* in: prefix given  out: kernel fills id */
	unsigned int prefixlen;		/* in/out */
	struct sockaddr_storage addr;	/* in/out */
	struct sockaddr_storage dstaddr; /* out */
};

/* SIOCIFAFDETACH */
struct if_afreq {
	char		ifar_name[IFNAMSIZ];
	sa_family_t	ifar_af;
};

/* SIOC[SG]IFPARENT */
struct if_parent {
	char		ifp_name[IFNAMSIZ];
	char		ifp_parent[IFNAMSIZ];
};

#include <net/if_arp.h>

#ifdef _KERNEL
struct socket;
struct ifnet;
struct ifq_ops;

void	if_alloc_sadl(struct ifnet *);
void	if_free_sadl(struct ifnet *);
void	if_attach(struct ifnet *);
void	if_attach_queues(struct ifnet *, unsigned int);
void	if_attach_ifq(struct ifnet *, const struct ifq_ops *, void *);
void	if_attachtail(struct ifnet *);
void	if_attachhead(struct ifnet *);
void	if_deactivate(struct ifnet *);
void	if_detach(struct ifnet *);
void	if_down(struct ifnet *);
void	if_downall(void);
void	if_link_state_change(struct ifnet *);
void	if_up(struct ifnet *);
int	ifconf(u_long, caddr_t);
void	if_getdata(struct ifnet *, struct if_data *);
void	ifinit(void);
int	ifioctl(struct socket *, u_long, caddr_t, struct proc *);
int	ifpromisc(struct ifnet *, int);
struct	ifg_group *if_creategroup(const char *);
int	if_addgroup(struct ifnet *, const char *);
int	if_delgroup(struct ifnet *, const char *);
void	if_group_routechange(struct sockaddr *, struct sockaddr *);
struct	ifnet *ifunit(const char *);
struct	ifnet *if_get(unsigned int);
void	if_put(struct ifnet *);
void	ifnewlladdr(struct ifnet *);
void	if_congestion(void);
int	if_congested(void);
__dead void	unhandled_af(int);
int	if_setlladdr(struct ifnet *, const uint8_t *);

#endif /* _KERNEL */

#endif /* __BSD_VISIBLE */

#endif /* _NET_IF_H_ */
@


1.185
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.184 2017/01/23 11:37:29 mpi Exp $	*/
d404 1
a404 1
	uint64_t	ifm_active;		/* active options */ 
@


1.184
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.183 2017/01/23 07:27:21 dlg Exp $	*/
d460 1
d465 2
@


1.183
log
@i botched the copyout to ifr->ifr_data in SIOCGIFDATA.

this lets pflogd run again.

rename if_data() to if_getdata() while here to make grepping for
things less noisy.

reported by jsg@@
worked through with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.182 2017/01/23 01:26:09 dlg Exp $	*/
d209 2
a210 1
#define IFXF_MPSAFE		0x1		/* if_start is mpsafe */
d217 1
a217 1
	(IFXF_MPSAFE)
@


1.182
log
@merge the ifnet and ifqueue stats together when userland wants them.

a new if_data() function takes a pointer to ifnet and merges its
if_data and ifq statistics. it takes the ifq mutex around the reads
of the ifq stats so they get a consistent copy.

the ifnet and ifq stats are merged because some parts of the stack
still update the ifnet counters.

ok visa@@ (on an earlier diff) mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.181 2016/12/12 09:51:30 mpi Exp $	*/
d472 1
a472 1
void	if_data(struct ifnet *, struct if_data *);
@


1.181
log
@Remove most of the splsoftnet() recursions related to cloned interfaces.

inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.180 2016/10/27 03:00:35 dlg Exp $	*/
d472 1
@


1.180
log
@add a new pool for 2k + 2 byte (mcl2k2) clusters.

a certain vendor likes to make chips that specify the rx buffer
sizes in kilobyte increments. unfortunately it places the ethernet
header on the start of the rx buffer, which means if you give it a
mcl2k cluster, the ethernet header will not be ETHER_ALIGNed cos
mcl2k clusters are always allocated on 2k boundarys (cos they pack
into pages well). that in turn means the ip header wont be aligned
correctly.

the current workaround on these chips has been to let non-strict
alignment archs just use the normal 2k cluster, but use whatever
cluster can fit 2k + 2 on strict archs. that turns out to be the
4k cluster, meaning we waste nearly 2k of space on every packet.

properly aligning the ethernet header and ip headers gives a
performance boost, even on non-strict archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.179 2016/09/04 15:10:59 reyk Exp $	*/
a469 1
void	if_slowtimo(void *);
a486 1
int	if_setrdomain(struct ifnet *, int);
@


1.179
log
@Move code to change the rdomain of an interface from the ioctl switch case
to a new function if_setrdomain().

OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.178 2016/09/03 13:46:57 reyk Exp $	*/
d71 1
a71 1
#define MCLPOOLS	7		/* number of cluster pools */
@


1.178
log
@Add support for a multipoint-to-multipoint mode in vxlan(4).  In this
mode, vxlan(4) must be configured to accept any virtual network
identifier with "vnetid any" and added to a bridge(4) or switch(4).
This way the driver will dynamically learn the tunnel endpoints and
their vnetids for the responses and can be used to dynamically bridge
between VXLANs.  It is also being used in combination with switch(4)
and the OpenFlow tunnel classifiers.

With input from yasuoka@@ goda@@
OK deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.177 2016/06/10 20:33:29 vgross Exp $	*/
d488 1
@


1.177
log
@Add the "llprio" field to struct ifnet, and the corresponding keyword
to ifconfig.

"llprio" allows one to set the priority of packets that do not go through
pf(4), as the case is for arp(4) or bpf(4).

ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.176 2016/03/02 00:00:16 dlg Exp $	*/
d363 1
a363 1
		uint32_t		ifru_vnetid;
@


1.176
log
@provide generic ioctls for managing an interfaces parent

in the future this will subsume the individual vlandev, carpdev,
pppoedev, foodev options for things like vlan, carp, pppoe, etc.

inspired by vnetid

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.175 2015/12/05 19:04:37 deraadt Exp $	*/
d381 1
@


1.175
log
@avoid an ugly wrap in a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.174 2015/12/03 12:22:51 dlg Exp $	*/
d445 6
@


1.174
log
@rework if_start to allow nics to provide an mpsafe start routine.

existing start routines will still be called under the kernel lock
and at IPL_NET.

mpsafe start routines will be serialised so only one instance of
each interfaces function will be running in the kernel at any point
in time. this guarantees packets will be dequeued in order, and the
start routines dont have to lock against themselves because if_start
does it for them.

the code to do that is based on the scsi runqueue code.

this also provides an if_start_barrier() function that should wait
until any currently running instances of if_start have finished.

a driver can opt in to the mpsafe if_start call by doing the following:

1. setting ifp->if_xflags = IFXF_MPSAFE
2. only calling if_start() instead of its own start routine
3. clearing IFF_RUNNING before calling if_start_barrier() on its way down
4. only using IFQ_DEQUEUE (not ifq_deq_begin/commit/rollback)

to simplify the implementation the tx mitigation code has been removed.

tested by several
ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.173 2015/11/20 12:27:42 mpi Exp $	*/
d403 1
a403 2
	int		ifm_count;		/* # entries in ifm_ulist
						array */
@


1.173
log
@Keep if_ref() private, if_get() is what you want to use before if_put().

The thread detaching an interface will sleep until all references to this
interface have been released.  So we decided to only keep references for
a short period of time.

Keeping if_ref() private will hopefully help preserve this goal as long
as it makes sense.

Calling if_get()/if_put() in the same function also allows us to make
use of static analysis tools (thanks jsg@@!) to catch our errors.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.172 2015/10/24 10:52:05 reyk Exp $	*/
d209 1
a209 1
#define IFXF_TXREADY		0x1		/* interface is ready to tx */
d216 1
a216 1
	(IFXF_TXREADY)
@


1.172
log
@Add pair(4), a vether-based virtual Ethernet driver to interconnect
rdomains and bridges on the local system.  This can be used to route
through local rdomains, to create L2 devices (like trunks) between
them, and many other things.

Discussed with many, with input from mpi@@
OK sthen@@ phessler@@ yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.171 2015/10/23 10:22:29 claudio Exp $	*/
a475 1
struct	ifnet *if_ref(struct ifnet *);
@


1.171
log
@Introduce a new sysctl NET_RT_IFNAMES that returns only ifnames to ifindex
mappings. This will be used by if_nameindex(3), if_nametoindex(3) and
if_indextoname(3) soon to fix the issues in pledge because of inet6 link
local addressing.
OK mpi@@ benno@@ deraadt@@
The libc version will follow soon so better start updating your kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.170 2015/10/23 01:19:04 dlg Exp $	*/
d366 1
d380 1
@


1.170
log
@tweak the vnetid so it can be optional and therefore cleared/deleted.

the abstract vnetid is promoted to a uin32_t, and adds a SIOCDVNETID
ioctl so it can be cleared.

this is all because i set an assignment on implementing a virtual
network interface and the students got confused when vnetid 0 didnt
show up in ifconfig output.

the vnetid in the vxlan(4) protocol is optional, but the current
code confuses 0 with no vnetid being set. this makes it clear.

ok reyk@@ who also simplified my diff
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.169 2015/10/05 15:19:29 uebayasi Exp $	*/
d306 6
@


1.169
log
@Add ifi_oqdrops and its alias to struct if_data.

Necessary bumps in Ports will be handled by sthen@@.

OK mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d357 1
d370 1
a370 1
#define ifr_vnetid	ifr_ifru.ifru_metric	/* Virtual Net Id (overload) */
@


1.168
log
@Add if_setlladdr(), factored out from ifioctl(). Will be used by iwm(4) soon.
With suggestions from tedu@@ and guenther@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.167 2015/09/11 13:02:28 stsp Exp $	*/
d118 1
@


1.167
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.166 2015/09/09 16:01:10 dlg Exp $	*/
d472 1
@


1.166
log
@introduce reference counts for interfaces (ie, struct ifnet *ifp).

if_get can get a reference to an ifp, but it never releases that
reference. this provides an if_put function that can be used to
decrement the refcount.

we cannot come up with a scheme for letting the network stack run on
one (or many) cpus while ioctls are pulling interfaces down on another
cpu without refcounts for the interfaces.

if_put is going in now so we can go through the stack and put the
necessary calls to it in, and then we'll backfill this implementation
to actually check the refcounts when the interface detaches.

ok mpi@@ mikeb@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.165 2015/08/30 10:39:16 mpi Exp $	*/
d351 7
a357 6
		struct	sockaddr ifru_addr;
		struct	sockaddr ifru_dstaddr;
		struct	sockaddr ifru_broadaddr;
		short	ifru_flags;
		int	ifru_metric;
		caddr_t	ifru_data;
d366 1
a366 1
#define	ifr_media	ifr_ifru.ifru_metric	/* media options (overload) */
d388 8
a395 8
	char	ifm_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	int	ifm_current;			/* current media options */
	int	ifm_mask;			/* don't care mask */
	int	ifm_status;			/* media status */
	int	ifm_active;			/* active options */ 
	int	ifm_count;			/* # entries in ifm_ulist
							array */
	int	*ifm_ulist;			/* media words */
@


1.165
log
@Use a global table for domains instead of building a list at run time.

As a side effect there's no need to run if_attachdomain() after the
list of domains has been built.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.164 2015/06/07 12:02:28 jsg Exp $	*/
d465 2
@


1.164
log
@Introduce unhandled_af() for cases where code conditionally does
something based on an address family and later assumes one of the paths
was taken.  This was initially just calls to panic until guenther
suggested a function to reduce the amount of strings needed.

This reduces the amount of noise with static analysers and acts
as a sanity check.

ok guenther@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.163 2015/05/18 13:32:28 reyk Exp $	*/
a445 1
void	if_attachdomain(void);
@


1.163
log
@Move the rdomain from struct ifnet into struct if_data.  This way it
will be exported to userland with the existing sysctl, getifaddrs()
and routing socket (if_msghdr.ifm_data) interfaces that expose
if_data.  All programs and daemons - Apps - that call the
SIOCGIFRDOMAIN ioctl in a getifaddrs() loop or after receiving an
interface message on the routing socket can now remove the pointless
additional ioctl.  In base, that could be: dhclient, isakmpd, dhcpd,
dhcrelay, ntpd, ospfd, ripd, ifconfig.

No ABI breakage because it uses a previously unused pad field in if_data.

OK mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.162 2015/04/10 08:48:24 mpi Exp $	*/
d469 1
@


1.162
log
@Run detach hook and similar before cleaning up any other resource when
an interface is destroyed/removed.  This way we can ensure pseudo-driver
changes done after attaching an interface are undone before detaching it.

Note: it is safe to call if_deactivate() multiple times as the interface
should not have any attached pseudo-interface after the first call.

ok deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.161 2015/03/18 12:23:15 dlg Exp $	*/
d105 1
a105 1
	u_int32_t	ifi_pad;
@


1.161
log
@remove the congestion handling from struct ifqueue.

its only used for the ip and ip6 network stack input queues, so it
seems unfair that every instance of ifqueue has to carry a pointer
around for this specific use case.

this moves the congestion marker to a kernel global. if we detect
that we're congested, we assume the whole system is busy and punish
all input queues.

marking a system as congested is done by setting the global to the
current value of ticks. as the system moves away from that value,
it moves away from being congested until the comparison fails.

written at s2k15
ok henning@@ beck@@ bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.160 2015/02/08 06:00:52 mpi Exp $	*/
d449 1
@


1.160
log
@Introduce if_input() a function to pass packets dequeued from a
recieving ring to the stack.

if_input() is at the moment a drop-in replacement for ether_input_mbuf()
but will let us stack pseudo-driver in a nice way in order to no longer
call ether_input() recursively.

ok pelikan@@, reyk@@, blambert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.159 2015/01/06 21:26:46 stsp Exp $	*/
d466 2
@


1.159
log
@Remove the NOINET6 interface flag, a left-over from the times when IPv6
was enabled by default. Add AFATTACH/AFDETACH ioctls which enable/disable
an address family for an interface (currently used for IPv6 only).

New kernel needs new ifconfig for IPv6 configuration (address assignment
still works with old ifconfig making this easy to cross over).

Committing on behalf of henning@@ who is currently lebensmittelvergiftet.
ok stsp, benno, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.158 2014/12/05 15:50:04 mpi Exp $	*/
a464 1
void	if_start(struct ifnet *);
@


1.158
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.157 2014/07/14 03:45:43 dlg Exp $	*/
a208 1
#define	IFXF_NOINET6		0x2		/* don't do inet6 */
d429 6
@


1.157
log
@now that receive ring accounting has been pulled out of the mbuf layer,
we can pull the space the mbuf layer used to do per interface accounting
out of struct if_data.

saves a hundredish bytes on every interface.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.156 2014/07/11 16:39:06 henning Exp $	*/
d435 29
a463 2
#include <net/if_var.h>
#endif
@


1.156
log
@introduce the IFXF_AUTOCONF6 interface flag which controls wether we
accept rtadvs on that interface. the global net.inet6.ip6.accept_rtadv
sysctl just doesn't cut it, even tho the spec wants that - but in their
little absurd world, a host just has one interface by definition anyway...
the sysctlgoes away.
lots of head scratching, brain cell elemination etc from bluhm benno stsp
florian, excitement from simon and todd, ok bluhm stsp benno florian
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.154 2014/06/13 07:28:12 mpi Exp $	*/
a72 9
struct mclpool {
	int	mcl_grown;
	u_int	mcl_livelocks;
	u_short	mcl_alive;
	u_short mcl_hwm;
	u_short mcl_cwm;
	u_short mcl_lwm;
};

a120 2

	struct mclpool	ifi_mclpool[MCLPOOLS];
@


1.155
log
@introduce the if_rxr api. it is intended to pull the rx ring accounting
out of the mbuf layer, and break the assumption that an interface will
only have a single ring per mbuf cluster size.

mpi@@ is ok with moving this forward
@
text
@d224 1
@


1.154
log
@Instead of updating all the cluster allocation water marks of all the
interfaces when the kernel is livelocked, only do it for the current
pool and defer the other updates.

This allow us to get rid of an interface list iteration in a critical
path.

Ridding the libc crank since this change introduce an ABI break.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.153 2013/11/21 17:32:12 mikeb Exp $	*/
d80 20
@


1.153
log
@split kernel parts of the if.h into a separate header file if_var.h
which allows us to modify ifnet structure in a relatively safe way;
discussed with deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.152 2013/11/09 06:38:42 dlg Exp $	*/
d75 1
@


1.152
log
@ticks is compared against mcl_grown to see if time has elapsed since
the rx ring was last allowed to grow and then assigned to it. it
is erroneous to do this because mcl_grown is a u_int and ticks is an
int.

this makes mcl_grown an int, and follows the idiom in kern_timeout.c
of going "thing - ticks < diff", which better copes with ticks
wrapping around and being used to calculate relative intervals.

ok pirofti@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.151 2013/11/01 22:55:39 pelikan Exp $	*/
a4 1
 * Copyright (c) 2012-2013 Henning Brauer <henning@@openbsd.org>
a61 59
#include <sys/queue.h>
#include <sys/tree.h>
#include <altq/if_altq.h>
#ifdef _KERNEL
#include <net/hfsc.h>
#endif

/*
 * Structures defining a network interface, providing a packet
 * transport mechanism (ala level 0 of the PUP protocols).
 *
 * Each interface accepts output datagrams of a specified maximum
 * length, and provides higher level routines with input datagrams
 * received from its medium.
 *
 * Output occurs when the routine if_output is called, with four parameters:
 *	(*ifp->if_output)(ifp, m, dst, rt)
 * Here m is the mbuf chain to be sent and dst is the destination address.
 * The output routine encapsulates the supplied datagram if necessary,
 * and then transmits it on its medium.
 *
 * On input, each interface unwraps the data received by it, and either
 * places it on the input queue of an internetwork datagram routine
 * and posts the associated software interrupt, or passes the datagram to a raw
 * packet input routine.
 *
 * Routines exist for locating interfaces by their addresses
 * or for locating an interface on a certain network, as well as more general
 * routing and gateway routines maintaining information used to locate
 * interfaces.  These routines live in the files if.c and route.c
 */

#include <sys/time.h>

struct mbuf;
struct proc;
struct rtentry;
struct socket;
struct ether_header;
struct arpcom;
struct rt_addrinfo;
struct ifnet;
struct hfsc_if;

/*
 * Structure describing a `cloning' interface.
 */
struct if_clone {
	LIST_ENTRY(if_clone) ifc_list;	/* on list of cloners */
	const char *ifc_name;		/* name of device, e.g. `gif' */
	size_t ifc_namelen;		/* length of name */

	int	(*ifc_create)(struct if_clone *, int);
	int	(*ifc_destroy)(struct ifnet *);
};

#define	IF_CLONE_INITIALIZER(name, create, destroy)			\
	{ { 0 }, name, sizeof(name) - 1, create, destroy }

a117 16
 * Structure defining a queue for a network interface.
 * XXX keep in sync with struct ifaltq.
 */
struct	ifqueue {
	struct {
		struct	mbuf *head;
		struct	mbuf *tail;
	}			 ifq_q[IFQ_NQUEUES];
	int			 ifq_len;
	int			 ifq_maxlen;
	int			 ifq_drops;
	struct hfsc_if		*ifq_hfsc;
	struct timeout		*ifq_congestion;
};

/*
d143 1
a143 2
		
	
a167 7
/*
 * Structure defining a queue for a network interface.
 *
 * (Would like to call this struct ``if'', but C isn't PL/1.)
 */
TAILQ_HEAD(ifnet_head, ifnet);		/* the actual queue head */

a175 76
struct ifnet {				/* and the entries */
	void	*if_softc;		/* lower-level data for this if */
	TAILQ_ENTRY(ifnet) if_list;	/* all struct ifnets are chained */
	TAILQ_ENTRY(ifnet) if_txlist;	/* list of ifnets ready to tx */
	TAILQ_HEAD(, ifaddr) if_addrlist; /* linked list of addresses per if */
	TAILQ_HEAD(, ifg_list) if_groups; /* linked list of groups per if */
	struct hook_desc_head *if_addrhooks; /* address change callbacks */
	struct hook_desc_head *if_linkstatehooks; /* link change callbacks */
	struct hook_desc_head *if_detachhooks; /* detach callbacks */
	char	if_xname[IFNAMSIZ];	/* external name (name + unit) */
	int	if_pcount;		/* number of promiscuous listeners */
	caddr_t	if_bpf;			/* packet filter structure */
	caddr_t if_bridgeport;		/* used by bridge ports */
	caddr_t	if_tp;			/* used by trunk ports */
	caddr_t	if_pf_kif;		/* pf interface abstraction */
	union {
		caddr_t	carp_s;		/* carp structure (used by !carp ifs) */
		struct ifnet *carp_d;	/* ptr to carpdev (used by carp ifs) */
	} if_carp_ptr;
#define if_carp		if_carp_ptr.carp_s
#define if_carpdev	if_carp_ptr.carp_d
	u_short	if_index;		/* numeric abbreviation for this if */
	short	if_timer;		/* time 'til if_watchdog called */
	short	if_flags;		/* up/down, broadcast, etc. */
	int	if_xflags;		/* extra softnet flags */
	struct	if_data if_data;	/* stats and other data about if */
	u_int32_t if_hardmtu;		/* maximum MTU device supports */
	u_int	if_rdomain;		/* routing instance */
	char	if_description[IFDESCRSIZE]; /* interface description */
	u_short	if_rtlabelid;		/* next route label */
	u_int8_t if_priority;

	/* procedure handles */
					/* output routine (enqueue) */
	int	(*if_output)(struct ifnet *, struct mbuf *, struct sockaddr *,
		     struct rtentry *);

					/* link level output function */
	int	(*if_ll_output)(struct ifnet *, struct mbuf *,
		    struct sockaddr *, struct rtentry *);
					/* initiate output routine */
	void	(*if_start)(struct ifnet *);
					/* ioctl routine */
	int	(*if_ioctl)(struct ifnet *, u_long, caddr_t);
					/* stop routine */
	int	(*if_stop)(struct ifnet *, int);
					/* timer routine */
	void	(*if_watchdog)(struct ifnet *);
	int	(*if_wol)(struct ifnet *, int);
	struct	ifaddr *if_lladdr;	/* pointer to link-level address */
	struct	ifaltq if_snd;		/* output queue (includes altq) */
	struct sockaddr_dl *if_sadl;	/* pointer to our sockaddr_dl */

	void	*if_afdata[AF_MAX];
};
#define	if_mtu		if_data.ifi_mtu
#define	if_type		if_data.ifi_type
#define	if_addrlen	if_data.ifi_addrlen
#define	if_hdrlen	if_data.ifi_hdrlen
#define	if_metric	if_data.ifi_metric
#define	if_link_state	if_data.ifi_link_state
#define	if_baudrate	if_data.ifi_baudrate
#define	if_ipackets	if_data.ifi_ipackets
#define	if_ierrors	if_data.ifi_ierrors
#define	if_opackets	if_data.ifi_opackets
#define	if_oerrors	if_data.ifi_oerrors
#define	if_collisions	if_data.ifi_collisions
#define	if_ibytes	if_data.ifi_ibytes
#define	if_obytes	if_data.ifi_obytes
#define	if_imcasts	if_data.ifi_imcasts
#define	if_omcasts	if_data.ifi_omcasts
#define	if_iqdrops	if_data.ifi_iqdrops
#define	if_noproto	if_data.ifi_noproto
#define	if_lastchange	if_data.ifi_lastchange
#define	if_capabilities	if_data.ifi_capabilities

a226 79
/*
 * Output queues (ifp->if_snd) and internetwork datagram level (pup level 1)
 * input routines have queues of messages stored on ifqueue structures
 * (defined above).  Entries are added to and deleted from these structures
 * by these macros, which should be called with ipl raised to splnet().
 */
#define	IF_QFULL(ifq)		((ifq)->ifq_len >= (ifq)->ifq_maxlen)
#define	IF_DROP(ifq)		((ifq)->ifq_drops++)
#define	IF_ENQUEUE(ifq, m)						\
do {									\
	(m)->m_nextpkt = NULL;						\
	if ((ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail == NULL)		\
		(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].head = m;		\
	else								\
		(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail->m_nextpkt = m; \
	(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail = m;			\
	(ifq)->ifq_len++;						\
} while (/* CONSTCOND */0)
#define	IF_PREPEND(ifq, m)						\
do {									\
	(m)->m_nextpkt = (ifq)->ifq_q[(m)->m_pkthdr.pf.prio].head;	\
	if ((ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail == NULL)		\
		(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].tail = (m);		\
	(ifq)->ifq_q[(m)->m_pkthdr.pf.prio].head = (m);			\
	(ifq)->ifq_len++;						\
} while (/* CONSTCOND */0)

#define	IF_POLL(ifq, m)							\
do {									\
	int	if_dequeue_prio = IFQ_MAXPRIO;				\
	do {								\
		(m) = (ifq)->ifq_q[if_dequeue_prio].head;		\
	} while (!(m) && --if_dequeue_prio >= 0); 			\
} while (/* CONSTCOND */0)

#define	IF_DEQUEUE(ifq, m)						\
do {									\
	int	if_dequeue_prio = IFQ_MAXPRIO;				\
	do {								\
		(m) = (ifq)->ifq_q[if_dequeue_prio].head;		\
		if (m) {						\
			if (((ifq)->ifq_q[if_dequeue_prio].head =	\
			    (m)->m_nextpkt) == NULL)			\
				(ifq)->ifq_q[if_dequeue_prio].tail = NULL; \
			(m)->m_nextpkt = NULL;				\
			(ifq)->ifq_len--;				\
		}							\
	} while (!(m) && --if_dequeue_prio >= 0);			\
} while (/* CONSTCOND */0)

#define	IF_INPUT_ENQUEUE(ifq, m)					\
do {									\
	if (IF_QFULL(ifq)) {						\
		IF_DROP(ifq);						\
		m_freem(m);						\
		if (!(ifq)->ifq_congestion)				\
			if_congestion(ifq);				\
	} else								\
		IF_ENQUEUE(ifq, m);					\
} while (/* CONSTCOND */0)

#define	IF_PURGE(ifq)							\
do {									\
	struct mbuf *__m0;						\
									\
	for (;;) {							\
		IF_DEQUEUE((ifq), __m0);				\
		if (__m0 == NULL)					\
			break;						\
		else							\
			m_freem(__m0);					\
	}								\
} while (/* CONSTCOND */0)
#define	IF_LEN(ifq)		((ifq)->ifq_len)
#define	IF_IS_EMPTY(ifq)	((ifq)->ifq_len == 0)

#define	IFQ_MAXLEN	256
#define	IFNET_SLOWHZ	1		/* granularity is 1 second */

a243 29
 * The ifaddr structure contains information about one address
 * of an interface.  They are maintained by the different address families,
 * are allocated and attached when an address is set, and are linked
 * together so all addresses for an interface can be located.
 */
struct ifaddr {
	struct	sockaddr *ifa_addr;	/* address of interface */
	struct	sockaddr *ifa_dstaddr;	/* other end of p-to-p link */
#define	ifa_broadaddr	ifa_dstaddr	/* broadcast address interface */
	struct	sockaddr *ifa_netmask;	/* used to determine subnet */
	struct	ifnet *ifa_ifp;		/* back-pointer to interface */
	TAILQ_ENTRY(ifaddr) ifa_list;	/* list of addresses for interface */
					/* check or clean routes (+ or -)'d */
	void	(*ifa_rtrequest)(int, struct rtentry *);
	u_int	ifa_flags;		/* mostly rt_flags for cloning */
	u_int	ifa_refcnt;		/* count of references */
	int	ifa_metric;		/* cost of going out this interface */
};
#define	IFA_ROUTE	RTF_UP		/* route installed */

struct ifaddr_item {
	RB_ENTRY(ifaddr_item)	 ifai_entry;
	struct sockaddr		*ifai_addr;
	struct ifaddr		*ifai_ifa;
	struct ifaddr_item	*ifai_next;
	u_int			 ifai_rdomain;
};

/*
a279 1

a302 19
struct ifg_group {
	char				 ifg_group[IFNAMSIZ];
	u_int				 ifg_refcnt;
	caddr_t				 ifg_pf_kif;
	int				 ifg_carp_demoted;
	TAILQ_HEAD(, ifg_member)	 ifg_members;
	TAILQ_ENTRY(ifg_group)		 ifg_next;
};

struct ifg_member {
	TAILQ_ENTRY(ifg_member)	 ifgm_next;
	struct ifnet		*ifgm_ifp;
};

struct ifg_list {
	struct ifg_group	*ifgl_group;
	TAILQ_ENTRY(ifg_list)	 ifgl_next;
};

d424 2
a425 199
#define	IFAFREE(ifa) \
do { \
	if ((ifa)->ifa_refcnt <= 0) \
		ifafree(ifa); \
	else \
		(ifa)->ifa_refcnt--; \
} while (/* CONSTCOND */0)

/* XXX the IFQ_ macros are a giant mess right now. cleanup once altq gone. */

#ifdef ALTQ

/* XXX pattr unused */
/* if_snd becomes ifqueue when altq is gone and the casts go away */
#define	IFQ_ENQUEUE(ifq, m, pattr, err)					\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(err) = hfsc_enqueue(((struct ifqueue *)(ifq)), (m));	\
	else if (ALTQ_IS_ENABLED((ifq))) {				\
		m->m_pkthdr.pf.prio = IFQ_MAXPRIO;			\
		ALTQ_ENQUEUE((ifq), (m), (pattr), (err));		\
	} else {							\
		if (IF_QFULL((ifq))) {					\
			m_freem((m));					\
			(err) = ENOBUFS;				\
		} else {						\
			IF_ENQUEUE((ifq), (m));				\
			(err) = 0;					\
		}							\
	}								\
	if ((err))							\
		(ifq)->ifq_drops++;					\
} while (/* CONSTCOND */0)

#define	IFQ_DEQUEUE(ifq, m)						\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(m) = hfsc_dequeue(((struct ifqueue *)(ifq)), 1);	\
	else if (OLDTBR_IS_ENABLED((ifq)))				\
		(m) = oldtbr_dequeue((ifq), ALTDQ_REMOVE);		\
	else if (ALTQ_IS_ENABLED((ifq)))				\
		ALTQ_DEQUEUE((ifq), (m));				\
	else								\
		IF_DEQUEUE((ifq), (m));					\
} while (/* CONSTCOND */0)

#define	IFQ_POLL(ifq, m)						\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(m) = hfsc_dequeue(((struct ifqueue *)(ifq)), 0);	\
	else if (OLDTBR_IS_ENABLED((ifq)))				\
		(m) = oldtbr_dequeue((ifq), ALTDQ_POLL);		\
	else if (ALTQ_IS_ENABLED((ifq)))				\
		ALTQ_POLL((ifq), (m));					\
	else								\
		IF_POLL((ifq), (m));					\
} while (/* CONSTCOND */0)

#define	IFQ_PURGE(ifq)							\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		hfsc_purge(((struct ifqueue *)(ifq)));			\
	else if (ALTQ_IS_ENABLED((ifq)))				\
		ALTQ_PURGE(ifq);					\
	else								\
		IF_PURGE((ifq));					\
} while (/* CONSTCOND */0)

#define	IFQ_SET_READY(ifq)						\
do {									\
	((ifq)->altq_flags |= ALTQF_READY);				\
} while (/* CONSTCOND */0)

#else /* !ALTQ */

/* XXX pattr unused */
#define	IFQ_ENQUEUE(ifq, m, pattr, err)					\
do {									\
	if (HFSC_ENABLED(ifq))						\
		(err) = hfsc_enqueue(((struct ifqueue *)(ifq)), m);	\
	else {								\
		if (IF_QFULL((ifq))) {					\
			m_freem((m));					\
			(err) = ENOBUFS;				\
		} else {						\
			IF_ENQUEUE((ifq), (m));				\
			(err) = 0;					\
		}							\
	}								\
	if ((err))							\
		(ifq)->ifq_drops++;					\
} while (/* CONSTCOND */0)

#define	IFQ_DEQUEUE(ifq, m)						\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(m) = hfsc_dequeue(((struct ifqueue *)(ifq)), 1);	\
	else								\
		IF_DEQUEUE((ifq), (m));					\
} while (/* CONSTCOND */0)

#define	IFQ_POLL(ifq, m)						\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		(m) = hfsc_dequeue(((struct ifqueue *)(ifq)), 0);	\
	else								\
		IF_POLL((ifq), (m));					\
} while (/* CONSTCOND */0)

#define	IFQ_PURGE(ifq)							\
do {									\
	if (HFSC_ENABLED((ifq)))					\
		hfsc_purge(((struct ifqueue *)(ifq)));			\
	else								\
		IF_PURGE((ifq));					\
} while (/* CONSTCOND */0)

#define	IFQ_SET_READY(ifq)	/* nothing */

#endif /* ALTQ */

#define	IFQ_LEN(ifq)			IF_LEN(ifq)
#define	IFQ_IS_EMPTY(ifq)		((ifq)->ifq_len == 0)
#define	IFQ_INC_LEN(ifq)		((ifq)->ifq_len++)
#define	IFQ_DEC_LEN(ifq)		(--(ifq)->ifq_len)
#define	IFQ_INC_DROPS(ifq)		((ifq)->ifq_drops++)
#define	IFQ_SET_MAXLEN(ifq, len)	((ifq)->ifq_maxlen = (len))

/* default interface priorities */
#define IF_WIRED_DEFAULT_PRIORITY 0
#define IF_WIRELESS_DEFAULT_PRIORITY 4

extern struct ifnet_head ifnet;
extern struct ifnet *lo0ifp;

#define	ether_input_mbuf(ifp, m)        ether_input((ifp), NULL, (m))

void	ether_ifattach(struct ifnet *);
void	ether_ifdetach(struct ifnet *);
int	ether_ioctl(struct ifnet *, struct arpcom *, u_long, caddr_t);
void	ether_input(struct ifnet *, struct ether_header *, struct mbuf *);
int	ether_output(struct ifnet *,
	    struct mbuf *, struct sockaddr *, struct rtentry *);
char	*ether_sprintf(u_char *);

void	if_alloc_sadl(struct ifnet *);
void	if_free_sadl(struct ifnet *);
void	if_attach(struct ifnet *);
void	if_attachdomain(void);
void	if_attachtail(struct ifnet *);
void	if_attachhead(struct ifnet *);
void	if_detach(struct ifnet *);
void	if_down(struct ifnet *);
void	if_downall(void);
void	if_link_state_change(struct ifnet *);
void	if_slowtimo(void *);
void	if_up(struct ifnet *);
int	ifconf(u_long, caddr_t);
void	ifinit(void);
int	ifioctl(struct socket *, u_long, caddr_t, struct proc *);
int	ifpromisc(struct ifnet *, int);
struct	ifg_group *if_creategroup(const char *);
int	if_addgroup(struct ifnet *, const char *);
int	if_delgroup(struct ifnet *, const char *);
void	if_group_routechange(struct sockaddr *, struct sockaddr *);
struct	ifnet *ifunit(const char *);
struct	ifnet *if_get(unsigned int);
void	if_start(struct ifnet *);
void	ifnewlladdr(struct ifnet *);

struct	ifaddr *ifa_ifwithaddr(struct sockaddr *, u_int);
struct	ifaddr *ifa_ifwithdstaddr(struct sockaddr *, u_int);
struct	ifaddr *ifa_ifwithnet(struct sockaddr *, u_int);
struct	ifaddr *ifa_ifwithroute(int, struct sockaddr *,
					struct sockaddr *, u_int);
struct	ifaddr *ifaof_ifpforaddr(struct sockaddr *, struct ifnet *);
void	ifafree(struct ifaddr *);
void	link_rtrequest(int, struct rtentry *);

void	if_clone_attach(struct if_clone *);
void	if_clone_detach(struct if_clone *);

int	if_clone_create(const char *);
int	if_clone_destroy(const char *);

void	if_congestion(struct ifqueue *);
int     sysctl_ifq(int *, u_int, void *, size_t *, void *, size_t,
	    struct ifqueue *);

int	loioctl(struct ifnet *, u_long, caddr_t);
void	loopattach(int);
int	looutput(struct ifnet *,
	    struct mbuf *, struct sockaddr *, struct rtentry *);
void	lortrequest(int, struct rtentry *);
void	ifa_add(struct ifnet *, struct ifaddr *);
void	ifa_del(struct ifnet *, struct ifaddr *);
void	ifa_update_broadaddr(struct ifnet *, struct ifaddr *,
	    struct sockaddr *);
#endif /* _KERNEL */
@


1.151
log
@keep net/hfsc.h away from userspace, except in pfctl

tested by naddy, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.150 2013/10/21 15:10:29 benno Exp $	*/
d134 1
a134 1
	u_int	mcl_grown;
@


1.150
log
@nuke comment. How soon is now?
"do it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.149 2013/10/19 14:05:14 reyk Exp $	*/
d66 1
d68 1
@


1.149
log
@Bring back the if_detachhook.  We're going to have more users now.

ok mpi@@ henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.148 2013/10/13 10:10:02 reyk Exp $	*/
d92 1
a92 1
/*  XXX fast fix for SNMP, going away soon */
@


1.148
log
@Import vxlan(4), the virtual extensible local area network tunnel
interface.  VXLAN is a UDP-based tunnelling protocol for overlaying
virtualized layer 2 networks over layer 3 networks. The implementation
is based on draft-mahalingam-dutt-dcops-vxlan-04 and has been tested
with other implementations in the wild.

put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.147 2013/10/12 12:13:10 henning Exp $	*/
a103 1
struct ifvlan;
d266 1
a271 1
	LIST_HEAD(, ifvlan) if_vlist;	/* list of vlans on this interface */
@


1.147
log
@new bandwidth shaping subsystem, kernel side
uses hfsc behind the scenes; altq stays in parallel for a migration phase.
if.h even more messy for the transition, but eventuelly it should become
readable...
looked over & tested by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.146 2013/09/17 13:34:17 mpi Exp $	*/
d644 2
@


1.146
log
@Change vlan(4) detach procedure to not use a hook but a list of vlans
on the parent interface.  This is similar to what bridge(4), trunk(4)
or carp(4) are doing and allows us to get rid of the detachhook.

ok reyk@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.145 2013/08/28 06:58:57 mpi Exp $	*/
d5 1
a64 7

/*
 * Always include ALTQ glue here -- we use the ALTQ interface queue
 * structure even when ALTQ is not configured into the kernel so that
 * the size of struct ifnet does not changed based on the option.  The
 * ALTQ queue structure is API-compatible with the legacy ifqueue.
 */
d66 1
d103 1
d172 1
a172 1
#define IFQ_NQUEUES	ALTQ_IFQ_NQUEUES
d184 6
a189 5
	}	ifq_q[IFQ_NQUEUES];
	int	ifq_len;
	int	ifq_maxlen;
	int	ifq_drops;
	struct	timeout *ifq_congestion;
d709 10
d721 2
d725 3
a727 1
	if (ALTQ_IS_ENABLED((ifq))) {					\
d745 4
a748 2
	if (OLDTBR_IS_ENABLED((ifq)))					\
		(m) = oldtbr_dequeue((ifq), ALTDQ_REMOVE);			\
d757 4
a760 2
	if (TBR_IS_ENABLED((ifq)))					\
		(m) = oldtbr_dequeue((ifq), ALTDQ_POLL);			\
d769 4
a772 2
	if (ALTQ_IS_ENABLED((ifq)))					\
		ALTQ_PURGE((ifq));					\
d784 1
d787 10
a796 6
	if (IF_QFULL((ifq))) {						\
		m_freem((m));						\
		(err) = ENOBUFS;					\
	} else {							\
		IF_ENQUEUE((ifq), (m));					\
		(err) = 0;						\
d802 7
a808 1
#define	IFQ_DEQUEUE(ifq, m)	IF_DEQUEUE((ifq), (m))
d810 7
a816 1
#define	IFQ_POLL(ifq, m)	IF_POLL((ifq), (m))
d818 7
a824 1
#define	IFQ_PURGE(ifq)		IF_PURGE((ifq))
@


1.145
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.144 2013/06/20 12:03:40 mpi Exp $	*/
d108 1
a269 1
	struct hook_desc_head *if_detachhooks; /* detach callbacks */
d275 1
@


1.144
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.143 2013/06/20 09:38:24 mpi Exp $	*/
d497 1
a497 1
	void	(*ifa_rtrequest)(int, struct rtentry *, struct rt_addrinfo *);
d845 1
a845 1
void	link_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
d861 1
a861 1
void	lortrequest(int, struct rtentry *, struct rt_addrinfo *);
@


1.143
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.142 2013/04/02 08:54:37 mpi Exp $	*/
a61 1
#include <sys/systm.h>
d267 3
a269 3
	struct hook_desc_head if_addrhooks; /* address change callbacks */
	struct hook_desc_head if_linkstatehooks; /* link change callbacks */
	struct hook_desc_head if_detachhooks; /* detach callbacks */
@


1.142
log
@Instead of storing the link-level address of every interface in a global
array indexed by interface numbers, add a new field to the interface
descriptor pointing to it.

claudio@@ and todd@@ like it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.141 2013/03/26 13:19:25 mpi Exp $	*/
d62 1
d268 3
a270 3
	struct hook_desc_head *if_addrhooks; /* address change callbacks */
	struct hook_desc_head *if_linkstatehooks; /* link change callbacks */
	struct hook_desc_head *if_detachhooks; /* detach callbacks */
@


1.141
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.140 2013/03/20 10:34:12 mpi Exp $	*/
d310 1
@


1.140
log
@Introduce if_get() to retrieve an interface descriptor pointer given
an interface index and replace all the redondant checks and accesses
to a global array by a call to this function.

With imputs from and ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.139 2013/03/07 09:40:19 mpi Exp $	*/
a798 1
extern int ifqmaxlen;
@


1.139
log
@Remove unused ifa_ifwithaf() function.

ok mikeb@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.138 2013/03/07 09:03:16 mpi Exp $	*/
a800 1
extern struct ifnet **ifindex2ifnet;
a801 1
extern int if_indexlim;
d834 1
@


1.138
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.137 2012/11/23 20:12:03 sthen Exp $	*/
a839 1
struct	ifaddr *ifa_ifwithaf(int, u_int);
@


1.137
log
@Add SIOCGIFHARDMTU to allow retrieving the driver's maximum supported MTU
looks fine reyk@@ ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.136 2012/11/11 04:45:37 deraadt Exp $	*/
a709 8
#define	IFAFREE(ifa) \
do { \
	if ((ifa)->ifa_refcnt <= 0) \
		ifafree(ifa); \
	else \
		(ifa)->ifa_refcnt--; \
} while (/* CONSTCOND */0)

@


1.136
log
@align ifaliasreq.ifra_addr similar to the way that ifreq is fixed --
a gruesome union, to block the compiler from placing the struct
incorrectly aligned on stack frames
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.135 2012/10/05 17:17:04 camield Exp $	*/
d642 1
@


1.135
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.134 2012/09/19 15:29:53 henning Exp $	*/
d649 7
a655 1
	struct	sockaddr ifra_addr;
@


1.134
log
@defina an IFCAP_CSUM_MASK, covering IFCAP_CSUM_*, and use it in if_vlan.c
to replace the list of them.
this actually makes vlan inherit the IPv6 CSUM flags from it's parent, that
had been commented out since this code was committed back in 2001.
ok benno mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.132 2012/08/21 19:50:39 bluhm Exp $	*/
d273 1
a273 1
	caddr_t	if_bridge;		/* bridge structure */
@


1.133
log
@Bring into compliance with POSIX, exposing just the specified bits.

Requested by jasper@@, ok kettenis@@
@
text
@d384 3
@


1.132
log
@Reverse the name and meaning of the IFXF_INET6_PRIVACY interface
flag.  It is now called IFXF_INET6_NOPRIVACY.  So IPv6 privacy
addresses are on by default without resetting the flag during
ifconfig down/up.
OK stsp@@, sperreault@@ (who wrote the same diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.131 2011/12/02 03:15:31 haesbaert Exp $	*/
d38 24
d253 2
a254 6
/*
 * Length of interface external name, including terminating '\0'.
 * Note: this is the same size as a generic device's external name.
 */
#define	IFNAMSIZ	16
#define	IF_NAMESIZE	IFNAMSIZ
a696 14
struct if_nameindex {
	unsigned int	if_index;
	char		*if_name;
};

#ifndef _KERNEL
__BEGIN_DECLS
unsigned int if_nametoindex(const char *);
char	*if_indextoname(unsigned int, char *);
struct	if_nameindex *if_nameindex(void);
void	if_freenameindex(struct if_nameindex *);
__END_DECLS
#endif

d867 3
@


1.131
log
@Kill unused IFCAP_IPSEC and IFCAP_IPCOMP.

ok claudio@@ henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.130 2011/11/02 02:03:47 haesbaert Exp $	*/
d340 1
a340 1
#define	IFXF_INET6_PRIVACY	0x4		/* autoconf privacy extension */
@


1.130
log
@Expose if_capabilities to userland so that ifconfig can display the
device hardware features.
Tune ifconfig to show them with 'hwfeatures' argument.
While here, kill some old unused capabilities and respect 80 columns
in brconfig.h.

ok mcbride@@, henning@@, mpf@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.129 2011/10/07 17:10:08 henning Exp $	*/
a357 1
#define	IFCAP_IPSEC		0x00000008	/* can do IPsec */
a359 1
#define	IFCAP_IPCOMP		0x00000040	/* can do IPcomp */
@


1.129
log
@rename some vars and functions
unfortunately altq is one giant namespace violation. rename just those that
conflict with new stuff for now only to be found on my laptop. reduce pain,
the diff is huge already. ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.127 2011/07/07 20:41:36 henning Exp $	*/
d145 1
a267 1
	int	if_capabilities;	/* interface capabilities */
d314 1
a363 2
#define	IFCAP_CSUM_TCPv4_Rx	0x00000200	/* can do IPv4/TCP (Rx only) */
#define	IFCAP_CSUM_UDPv4_Rx	0x00000400	/* can do IPv4/UDP (Rx only) */
@


1.128
log
@new priority queueing implementation, extremely low overhead, thus fast.
unconditional, always on. 8 priority levels, as every better switch, the
vlan header etc etc. ok ryan mpf sthen, pea tested as well
@
text
@d727 2
a728 2
	if (TBR_IS_ENABLED((ifq)))					\
		(m) = tbr_dequeue((ifq), ALTDQ_REMOVE);			\
d738 1
a738 1
		(m) = tbr_dequeue((ifq), ALTDQ_POLL);			\
@


1.127
log
@provide IF_LEN and IFQ_LEN to access ifq_len on an ifqueue, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.126 2011/07/05 00:58:27 henning Exp $	*/
d83 1
d150 4
d159 4
a162 2
	struct	mbuf *ifq_head;
	struct	mbuf *ifq_tail;
d377 3
a379 3
	(m)->m_nextpkt = 0;						\
	if ((ifq)->ifq_tail == 0)					\
		(ifq)->ifq_head = m;					\
d381 2
a382 2
		(ifq)->ifq_tail->m_nextpkt = m;				\
	(ifq)->ifq_tail = m;						\
d387 4
a390 4
	(m)->m_nextpkt = (ifq)->ifq_head;				\
	if ((ifq)->ifq_tail == 0)					\
		(ifq)->ifq_tail = (m);					\
	(ifq)->ifq_head = (m);						\
d393 9
d404 11
a414 7
	(m) = (ifq)->ifq_head;						\
	if (m) {							\
		if (((ifq)->ifq_head = (m)->m_nextpkt) == 0)		\
			(ifq)->ifq_tail = 0;				\
		(m)->m_nextpkt = 0;					\
		(ifq)->ifq_len--;					\
	}								\
a427 1
#define	IF_POLL(ifq, m)		((m) = (ifq)->ifq_head)
d709 2
a710 1
	if (ALTQ_IS_ENABLED((ifq)))					\
d712 1
a712 1
	else {								\
@


1.126
log
@now of course I only noticed if_qflush is completely unused after
adjusting it to the new world order in my tree... remove it, ok ryan claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.125 2011/07/03 23:12:29 henning Exp $	*/
d421 1
d763 1
@


1.125
log
@IFQ_CLASSIFY is also just schrapnel
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.124 2011/07/03 23:05:35 henning Exp $	*/
a797 1
void	if_qflush(struct ifqueue *);
@


1.124
log
@no traces of ALTQ_DECL to be found anywhere, thus kill the #defines
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.123 2011/07/03 17:41:50 claudio Exp $	*/
a736 11
#define	IFQ_CLASSIFY(ifq, m, af, pa)					\
do {									\
	if (ALTQ_IS_ENABLED((ifq))) {					\
		if (ALTQ_NEEDS_CLASSIFY((ifq)))				\
			(pa)->pattr_class = (*(ifq)->altq_classify)	\
				((ifq)->altq_clfier, (m), (af));	\
		(pa)->pattr_af = (af);					\
		(pa)->pattr_hdr = mtod((m), caddr_t);			\
	}								\
} while (/* CONSTCOND */0)

a758 2

#define	IFQ_CLASSIFY(ifq, m, af, pa) /* nothing */
@


1.123
log
@LINK_STATE_IS_UP() should consider LINK_STATE_UNKNOWN as an up state.
This is now possible because carp no longer uses LINK_STATE_UNKNOWN
for a state that is considered down. This will simplify a lot of code.
OK mpf@@ mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.122 2011/03/13 15:31:41 stsp Exp $	*/
a685 1
#define	ALTQ_DECL(x)		x
a748 1
#define	ALTQ_DECL(x)		/* nothing */
@


1.122
log
@Add a way to enable/disable Wake On LAN with ifconfig.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.121 2010/11/17 18:51:57 henning Exp $	*/
d173 2
a174 1
#define LINK_STATE_IS_UP(_s)	((_s) >= LINK_STATE_UP)
@


1.121
log
@introduce ifa_update_broadaddr to update an ifaddr's broadcast address,
trivial for the moment, more needed soon
tested by many as part of a larger diff, ok sthen claudio dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.120 2010/09/24 13:29:29 claudio Exp $	*/
d281 1
d333 1
d357 1
@


1.120
log
@Implement if_freenameindex() as a real function as required by posix.
OK deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.119 2010/09/23 10:49:55 dlg Exp $	*/
d851 2
@


1.119
log
@tweak the mclgeti algorithm to behave better under load.

instead of letting hardware rings grow on every interrupt, restrict
it so it can only grow once per softclock tick. we can only punish
the rings on softclock ticks, so it make sense to only grow on
softclock tick boundaries too.

the rings are now punished after >1 lost softclock tick rather than
>2. mclgeti is now more aggressive at detecting livelock.

the rings get punished by an 8th, rather than by half.

we now allow the rings to be punished again even if the system is
already considered in livelock.

without this diff a livelocked system will have its rx ring sizes
scale up and down very rapidly, while holding the rings low for too
long. this affected throughput significantly.

discussed and tested heavily at j2k10. there are still some games
with softnet we can play, but this is a good first step.

"put it in" and ok deraadt@@
ok claudio@@ krw@@ henning@@ mcbride@@

if we find out that it sucks we can pull it out again later. till then
we'll run with it and see how it goes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.118 2010/08/27 17:08:01 jsg Exp $	*/
d666 1
a667 1
#define if_freenameindex(x)	free(x)
@


1.118
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.117 2010/06/26 19:49:54 claudio Exp $	*/
d111 1
a146 1
	u_int64_t	ifi_livelocks;		/* livelocks migitaged */
@


1.117
log
@Implement a simple keepalive mechanism in gre(4) that is compatible with
the one used by Cisco. It sends a return gre packet inside a gre packet
to the other side and expects it to return.
OK deraadt, reyk additional testing by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.116 2010/05/28 12:09:09 claudio Exp $	*/
a276 2
					/* init routine */
	int	(*if_init)(struct ifnet *);
@


1.116
log
@Rework the way we handle MPLS in the kernel. Instead of fumbling MPLS into
ether_output() and later on other L2 output functions use a trick and over-
load the ifp->if_output() function pointer on MPLS enabled interfaces to
go through mpls_output() which will then call the link level output function.
By setting IFXF_MPLS on an interface the output pointers are switched.
This now allows to cleanup the MPLS input and output pathes and fix mpe(4)
so that the MPLS code now actually works for both P and PE systems.
Tested by myself and michele
(A custom kernel with MPLS and mpe enabled is still needed).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.115 2010/04/17 17:46:32 deraadt Exp $	*/
d622 6
@


1.115
log
@split SIOCSIFLLADDR code out into an ifnewlladr() function
ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.114 2010/04/06 14:12:10 stsp Exp $	*/
d269 4
d333 1
@


1.114
log
@Simple implementation of RFC4941, "Privacy Extensions for Stateless
Address Autoconfiguration in IPv6". For those among us who are paranoid
about broadcasting their MAC address to the IPv6 internet.

Man page help from jmc, testing by weerd, arc4random API hints from djm.

ok deraadt, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.113 2010/01/13 02:26:49 henning Exp $	*/
d813 1
@


1.113
log
@maintain a global RB tree of all local addresses in the system. this
includes AF_LINK addresses (aka mac addresses in the ethernet case). for
inet this also includes the broadcast addresses.
depends on ifinit() called earlier so we have a chance to pool_init before
autoconf assigns the AF_LINK addresses, the v6 fix, and the ifa_add/del
abstraction i just committed.
this is a change in semantics, it is now illegal to change the actual
address in an ifaddr struct because then the RB tree becomes unbalanced.
nothing using this tree yet.
ok theo ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.112 2010/01/13 02:13:12 henning Exp $	*/
d326 3
a328 2
#define IFXF_TXREADY	0x1		/* interface is ready to tx */
#define	IFXF_NOINET6	0x2		/* don't do inet6 */
@


1.112
log
@instead of fiddling with the per-interface address lists directly in
many places create a proper API (ifa_add / ifa_del) and use it.
ok theo ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.111 2010/01/12 00:39:18 deraadt Exp $	*/
d39 1
d454 8
@


1.111
log
@Make the structures for ifa_msghdr and friends even more like
the route messages so that people and compilers will not get
confused.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.110 2009/09/17 13:27:24 claudio Exp $	*/
d829 2
@


1.110
log
@Remove the comaptibility structures for routing socket version 3.
The RTM_VERSION bump is 2 years ago and so there is no need for this.
Diff made by tedu@@ some time ago but got never commited so I do it now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.109 2009/09/14 11:42:52 claudio Exp $	*/
d465 2
a466 1
	u_short ifm_pad;
d484 2
a485 1
	u_short ifam_pad;
@


1.109
log
@Add a way to convert the ifi_link_state to a string without the use of
if_media. This makes link state tracking a lot easier as there is no need
to convert if types to if_media types, etc. Additionally this allows us
to extend the link states to include states tracked on higher protocol layers.
gre(4) keepalives packets, bfd and udld can be implemented without ugly hacks.
OK henning, michele, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.108 2009/08/10 11:22:10 deraadt Exp $	*/
a504 49

/*
 * Comaptibility structures for version 3 messages.
 * Keep them till after OpenBSD 4.4
 */
struct	if_odata {
	/* generic interface information */
	u_char	ifi_type;		/* ethernet, tokenring, etc. */
	u_char	ifi_addrlen;		/* media address length */
	u_char	ifi_hdrlen;		/* media header length */
	u_char	ifi_link_state;		/* current link state */
	u_long	ifi_mtu;		/* maximum transmission unit */
	u_long	ifi_metric;		/* routing metric (external only) */
	u_long	ifi_baudrate;		/* linespeed */
	/* volatile statistics */
	u_long	ifi_ipackets;		/* packets received on interface */
	u_long	ifi_ierrors;		/* input errors on interface */
	u_long	ifi_opackets;		/* packets sent on interface */
	u_long	ifi_oerrors;		/* output errors on interface */
	u_long	ifi_collisions;		/* collisions on csma interfaces */
	u_long	ifi_ibytes;		/* total number of octets received */
	u_long	ifi_obytes;		/* total number of octets sent */
	u_long	ifi_imcasts;		/* packets received via multicast */
	u_long	ifi_omcasts;		/* packets sent via multicast */
	u_long	ifi_iqdrops;		/* dropped on input, this interface */
	u_long	ifi_noproto;		/* destined for unsupported protocol */
	struct	timeval ifi_lastchange;	/* last operational state change */
};

struct if_omsghdr {
	u_short	ifm_msglen;	/* to skip over non-understood messages */
	u_char	ifm_version;	/* future binary compatibility */
	u_char	ifm_type;	/* message type */
	int	ifm_addrs;	/* like rtm_addrs */
	int	ifm_flags;	/* value of if_flags */
	u_short	ifm_index;	/* index for associated ifp */
	struct	if_odata ifm_data;/* statistics and other data about if */
};

struct ifa_omsghdr {
	u_short	ifam_msglen;	/* to skip over non-understood messages */
	u_char	ifam_version;	/* future binary compatibility */
	u_char	ifam_type;	/* message type */
	int	ifam_addrs;	/* like rtm_addrs */
	int	ifam_flags;	/* value of ifa_flags */
	u_short	ifam_index;	/* index for associated ifp */
	int	ifam_metric;	/* value of ifa_metric */
};

@


1.108
log
@At sys_reboot time, bring all the interfaces down so that their xxstop
functions are called, which will turn off DMA.  Receiving packets into
your memory after a system reboot is pretty nasty.  This will also mean
that the shutdown hooks can go; this solution is smaller.
ok henning miod dlg kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.107 2009/06/06 12:31:17 rainer Exp $	*/
d164 8
a171 5
#define	LINK_STATE_UNKNOWN	0	/* link invalid/unknown */
#define	LINK_STATE_DOWN		1	/* link is down */
#define	LINK_STATE_UP		2	/* link is up */
#define LINK_STATE_HALF_DUPLEX	3	/* link is up and half duplex */
#define LINK_STATE_FULL_DUPLEX	4	/* link is up and full duplex */
d173 38
@


1.107
log
@when xflags got changed, tell the userland by routing sockets

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.106 2009/06/05 00:05:21 claudio Exp $	*/
d794 1
@


1.106
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.105 2009/06/04 19:07:21 henning Exp $	*/
d427 1
a427 1
	int	ifm_pad2;
@


1.105
log
@allow IPvShit to be turned off completely per-interface.
ifconfig em0 -inet6
deletes all v6 addresses including link-local and prevents new ones from
being added.
ifconfig em0 inet6 <addr>
re-enables v6, brings the link local back and adds optional <addr>
ok theo reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.104 2009/06/03 20:35:37 beck Exp $	*/
d218 1
d592 1
d809 4
a812 4
struct	ifaddr *ifa_ifwithaddr(struct sockaddr *);
struct	ifaddr *ifa_ifwithaf(int);
struct	ifaddr *ifa_ifwithdstaddr(struct sockaddr *);
struct	ifaddr *ifa_ifwithnet(struct sockaddr *);
d814 1
a814 1
					struct sockaddr *);
@


1.104
log
@make wireless interfaces priority 4 by default. other interfaces remain
priority 0.  while we are in here make sure we add wi interfaces to group "wlan"
in the same way the net80211 stuff already is.

this makes dhcp multiple default routes useful on laptops.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.103 2009/01/27 09:17:51 dlg Exp $	*/
d284 4
@


1.103
log
@make drivers tell the mclgeti allocator what their maximum ring size is
to prevent the hwm growing beyond that. this allows the livelock mitigation
to do something where the hwm used to grow beyond twice the rx rings size.

ok kettenis@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.102 2008/12/12 22:07:33 claudio Exp $	*/
d759 4
@


1.102
log
@Introduce a if_priority that will be added to RTP_STATIC when routes are
added without an expilict priority. This allows to specify less prefered
interfaces that will only take over if the primary interface loses link.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.101 2008/12/11 16:45:45 deraadt Exp $	*/
d112 1
a112 1
	u_short mcl_size;
@


1.101
log
@export per-interface mbuf cluster pool use statistics out to userland
inside if_data, so that netstat(1) and systat(1) can see them
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.100 2008/11/30 00:14:42 brad Exp $	*/
d220 1
@


1.100
log
@- Remove unused if_reset "bus reset routine" field in the ifnet struct.
- Add if_stop "stop routine" field in the ifnet struct.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.99 2008/11/26 17:36:23 dlg Exp $	*/
d107 9
d143 3
a160 11
#define MCLPOOLS	7		/* number of cluster pools */

struct	mclstat {
	struct {
		u_short	mcl_alive;
		u_short mcl_hwm;
		u_short mcl_size;
		u_short mcl_lwm;
	}	mclpool[MCLPOOLS];
};

a238 2

	struct mclstat if_mclstat;	/* mbuf cluster pool stats */
@


1.99
log
@provide m_clsetlwm, an interface for an interface to raise its low
watermark for mbuf cluster allocations.

this is necessary for things like bge which cannot cope with less than a
certain number of pkts on the ring.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.98 2008/11/25 12:47:00 deraadt Exp $	*/
d230 2
a231 2
					/* XXX bus reset routine */
	int	(*if_reset)(struct ifnet *);
@


1.98
log
@Factor increases are not needed, +1 appears to work as well.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.97 2008/11/24 14:26:54 deraadt Exp $	*/
d156 1
a156 1
		u_short mcl_pad;
@


1.97
log
@move MCLPOOLS to if.h and force uipc_mbuf.c to get if.h, there is no
other option
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.96 2008/11/24 12:57:37 dlg Exp $	*/
d155 2
@


1.96
log
@add several backend pools to allocate mbufs clusters of various sizes out
of. currently limited to MCLBYTES (2048 bytes) and 4096 bytes until pools
can allocate objects of sizes greater than PAGESIZE.

this allows drivers to ask for "jumbo" packets to fill rx rings with.

the second half of this change is per interface mbuf cluster allocator
statistics. drivers can use the new interface (MCLGETI), which will use
these stats to selectively fail allocations based on demand for mbufs. if
the driver isnt rapidly consuming rx mbufs, we dont allow it to allocate
many to put on its rx ring.

drivers require modifications to take advantage of both the new allocation
semantic and large clusters.

this was written and developed with deraadt@@ over the last two days
ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.95 2008/11/07 05:50:33 deraadt Exp $	*/
d148 2
@


1.95
log
@give this some /* CONSTCOND */ love
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.94 2008/04/10 23:15:45 dlg Exp $	*/
d149 7
d234 2
@


1.94
log
@introduce mitigation for the calling of an interfaces start routine.

decent drivers prefer to have a lot of packets on the send queue so they
can queue a lot of them up on the tx ring and then post them all in one
big chunk. unfortunately our stack queues one packet onto the send queue
and then calls the start handler immediately.

this mitigates against that queue, send, queue, send behaviour by trying to
call the start routine only once per softnet. now its queue, queue, queue,
send.

this is the result of a lot of discussion with claudio@@
tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.92 2007/09/03 15:24:49 claudio Exp $	*/
d309 1
a309 1
} while (0)
d317 1
a317 1
} while (0)
d327 1
a327 1
} while (0)
d338 1
a338 1
} while (0)
d352 1
a352 1
} while (0)
d647 1
a647 1
} while (0)
d667 1
a667 1
} while (0)
d677 1
a677 1
} while (0)
d687 1
a687 1
} while (0)
d695 1
a695 1
} while (0)
d698 3
a700 1
	do { ((ifq)->altq_flags |= ALTQF_READY); } while (0)
d711 1
a711 1
} while (0)
d727 1
a727 1
} while (0)
@


1.93
log
@Sync struct ifaltq to match struct ifqueue.
I wonder why 64-bit archs have not been bitten by this.
OK mcbride@@, henning@@
@
text
@d181 1
d202 1
d270 2
d782 1
@


1.92
log
@Bump RTM_VERSION to 4 and start a new aera of routing in OpenBSD :)
Changes include 64bit counters instead of u_long, routing table id in the header
of most messages, reserved routing priority field, added a hdrlen field to skip
over the header so that binary compatibility becomes easier.
A minimal backward support for old binaries is included to ease upgrades but
don't expect anything more than ifconfig, route and dhclient to correctly work.
OK henning@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.91 2007/06/25 16:37:58 henning Exp $	*/
d138 1
@


1.91
log
@crank ifq_maxlen from 50 to 256, so it is not smaller than most interfaces
rx rings any more. forwarding boxes with many fast interfaces can still use
some more, but this is a saner default.
ok deraadt markus henric
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.90 2007/06/14 18:31:49 reyk Exp $	*/
d113 8
a120 7
	u_char	ifi_type;		/* ethernet, tokenring, etc. */
	u_char	ifi_addrlen;		/* media address length */
	u_char	ifi_hdrlen;		/* media header length */
	u_char	ifi_link_state;		/* current link state */
	u_long	ifi_mtu;		/* maximum transmission unit */
	u_long	ifi_metric;		/* routing metric (external only) */
	u_long	ifi_baudrate;		/* linespeed */
d122 11
a132 11
	u_long	ifi_ipackets;		/* packets received on interface */
	u_long	ifi_ierrors;		/* input errors on interface */
	u_long	ifi_opackets;		/* packets sent on interface */
	u_long	ifi_oerrors;		/* output errors on interface */
	u_long	ifi_collisions;		/* collisions on csma interfaces */
	u_long	ifi_ibytes;		/* total number of octets received */
	u_long	ifi_obytes;		/* total number of octets sent */
	u_long	ifi_imcasts;		/* packets received via multicast */
	u_long	ifi_omcasts;		/* packets sent via multicast */
	u_long	ifi_iqdrops;		/* dropped on input, this interface */
	u_long	ifi_noproto;		/* destined for unsupported protocol */
d270 3
a272 3
#define	IF_Kbps(x)	((x) * 1000)		/* kilobits/sec. */
#define	IF_Mbps(x)	(IF_Kbps((x) * 1000))	/* megabits/sec. */
#define	IF_Gbps(x)	(IF_Mbps((x) * 1000))	/* gigabits/sec. */
d398 4
d404 1
a404 1
	u_short	ifm_index;	/* index for associated ifp */
d416 4
a421 1
	u_short	ifam_index;	/* index for associated ifp */
d433 1
d435 1
a436 1
	u_short	ifan_what;	/* what type of announcement */
d441 49
@


1.90
log
@Add a new "rtlabel" option to ifconfig. It allows to specify a route label
which will be used for new interface routes. For example,
	ifconfig em0 10.1.1.0 255.255.255.0 rtlabel RING_1
will set the new interface address and attach the route label RING_1 to
the corresponding route.

manpage bits from jmc@@
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.89 2007/05/29 18:18:57 uwe Exp $	*/
d349 1
a349 1
#define	IFQ_MAXLEN	50
@


1.89
log
@Define IF_ENQUEUE() and friends as proper C statements using do ... while
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.88 2007/05/26 17:13:30 jason Exp $	*/
d203 1
@


1.88
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.87 2007/03/27 11:22:59 jmc Exp $	*/
d293 39
a331 35
#define	IF_ENQUEUE(ifq, m) { \
	(m)->m_nextpkt = 0; \
	if ((ifq)->ifq_tail == 0) \
		(ifq)->ifq_head = m; \
	else \
		(ifq)->ifq_tail->m_nextpkt = m; \
	(ifq)->ifq_tail = m; \
	(ifq)->ifq_len++; \
}
#define	IF_PREPEND(ifq, m) { \
	(m)->m_nextpkt = (ifq)->ifq_head; \
	if ((ifq)->ifq_tail == 0) \
		(ifq)->ifq_tail = (m); \
	(ifq)->ifq_head = (m); \
	(ifq)->ifq_len++; \
}
#define	IF_DEQUEUE(ifq, m) { \
	(m) = (ifq)->ifq_head; \
	if (m) { \
		if (((ifq)->ifq_head = (m)->m_nextpkt) == 0) \
			(ifq)->ifq_tail = 0; \
		(m)->m_nextpkt = 0; \
		(ifq)->ifq_len--; \
	} \
}

#define	IF_INPUT_ENQUEUE(ifq, m) {			\
	if (IF_QFULL(ifq)) {				\
		IF_DROP(ifq);				\
		m_freem(m);				\
		if (!(ifq)->ifq_congestion)		\
			if_congestion(ifq);		\
	} else						\
		IF_ENQUEUE(ifq, m);			\
}
@


1.87
log
@grammar from bret lambert, and one more from me;
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.86 2007/02/09 09:16:59 jmc Exp $	*/
d677 1
@


1.86
log
@grammar fix from bret lambert;
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.85 2006/11/28 19:21:15 reyk Exp $	*/
d68 1
a68 1
 * or for locating a interface on a certain network, as well as more general
@


1.85
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.84 2006/11/16 13:09:27 henning Exp $	*/
d63 1
a63 1
 * places it on the input queue of a internetwork datagram routine
@


1.84
log
@introduce if_creategroup() to create an empty interface group.
code factored out from if_addgroup(), previously a group always had to have
members. ok mpf mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.83 2006/10/31 14:28:29 jason Exp $	*/
d153 3
@


1.83
log
@ether_input_mbuf() isn't necessary, turn it into a macro and deal with
it's "special" case in ether_input().  Based on similiar idea in FreeBSD.
ok brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.82 2006/06/02 19:53:12 mpf Exp $	*/
d705 1
@


1.82
log
@Introduce attributes to interface groups.
As a first user, move the global carp(4) demotion counter
into the interface group. Thus we have the possibility
to define which carp interfaces are demoted together.

Put the demotion counter into the reserved field of the carp header.
With this, we can have carp act smarter if multiple errors occur.
It now always takes over other carp peers, that are advertising
with a higher demote count.  As a side effect, we can also have
group failovers without the need of running in preempt mode.
The protocol change does not break compability with older
implementations.

Collaborative work with mcbride@@

OK mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.81 2006/05/27 10:03:15 brad Exp $	*/
d679 2
a683 1
void	ether_input_mbuf(struct ifnet *, struct mbuf *);
@


1.81
log
@remove IFCAP_JUMBO_MTU interface capabilities flag and set if_hardmtu in a few
more drivers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.80 2006/05/26 20:50:41 deraadt Exp $	*/
d436 1
d460 4
d471 3
a473 2
		char	ifgru_group[IFNAMSIZ];
		struct	ifg_req *ifgru_groups;
d477 1
@


1.80
log
@rename jumbo mtu to if_hardmtu; ok brad reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.79 2006/05/19 19:50:23 reyk Exp $	*/
d277 4
a280 5
#define	IFCAP_JUMBO_MTU		0x00000080	/* jumbo MTU supported */
#define	IFCAP_CSUM_TCPv6	0x00000100	/* can do IPv6/TCP checksums */
#define	IFCAP_CSUM_UDPv6	0x00000200	/* can do IPv6/UDP checksums */
#define	IFCAP_CSUM_TCPv4_Rx	0x00000400	/* can do IPv4/TCP (Rx only) */
#define	IFCAP_CSUM_UDPv4_Rx	0x00000800	/* can do IPv4/UDP (Rx only) */
@


1.79
log
@add a if_jumbo_mtu field to the interface structure for drivers
supporting ethernet jumbo frames. there's no standard for the size of
jumbo MTUs, so either let the driver set it's own value or use 9000
byte jumbo frames by default.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.78 2006/03/04 22:40:15 brad Exp $	*/
d197 1
a197 1
	u_int32_t if_jumbo_mtu;		/* maximum jumbo transmission unit */
@


1.78
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.77 2006/02/09 00:05:55 reyk Exp $	*/
d197 1
d277 1
a277 1
#define	IFCAP_JUMBO_MTU		0x00000080	/* 9000 byte MTU supported */
@


1.77
log
@add an interface detach hook and use it with the vlan(4) driver. this
fixes a possible crash if the parent interface has been destroyed
(like vlan on trunk) before destroying the vlan interface.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.76 2005/06/14 04:00:39 henning Exp $	*/
d286 1
a286 1
 * by these macros, which should be called with ipl raised to splimp().
@


1.76
log
@rename function and define to reflect the external -> egress name change
so it is clear what it is all about
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.75 2005/06/14 03:54:31 henning Exp $	*/
d180 1
@


1.75
log
@use "egress" instead of "external" for the interface group containing the
interfaces the default route(s) point to, proposed deraadt some days ago,
ok djm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.74 2005/06/12 00:41:33 henning Exp $	*/
d429 1
a429 1
#define	IFG_EXTERNAL	"egress"	/* if(s) default route(s) point to */
@


1.74
log
@add SIOCGIFGMEMB ioctl, returns a list of all interfaces who are member of
the given group, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.73 2005/06/07 18:21:44 henning Exp $	*/
d429 1
a429 1
#define	IFG_EXTERNAL	"external"	/* if(s) default route(s) point to */
@


1.73
log
@introduce a default "external" interface group, containing the interface(s)
the the default route(s) point to.
handles IPv4 and IPv6 as well as multipath routes.
follows default route changes, of course.
eases writing pf rulesets especially on laptops etc. that use different
interfaces depending on the environment (wired, wireless, ...)
ok theo ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.72 2005/06/06 03:44:21 henning Exp $	*/
d450 6
a455 1
	char			 ifgrq_group[IFNAMSIZ];
a697 1
int	if_getgroup(caddr_t, struct ifnet *);
@


1.72
log
@use a define instead of hardcoding "all" in 3 places
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.71 2005/06/05 20:49:25 henning Exp $	*/
d428 2
a429 1
#define	IFG_ALL	"all"	/* group containing all interfaces */
d694 1
@


1.71
log
@const'ify the char *groupname param to if_addgroup and if_delgroup
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.70 2005/05/24 04:20:25 markus Exp $	*/
d427 3
@


1.70
log
@add net.inet.ip.ifq for monitoring and changing ifqueue; similar to netbsd
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.69 2005/05/24 02:45:17 reyk Exp $	*/
d687 2
a688 2
int	if_addgroup(struct ifnet *, char *);
int	if_delgroup(struct ifnet *, char *);
@


1.69
log
@initial import of a trunking (link aggregation and link failover)
implementation. it currently supports round robin mode with link state
checking, additional modes will be added later.

ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.68 2005/05/24 02:26:04 henning Exp $	*/
d343 16
d709 2
@


1.68
log
@keep a list of member interfaces in ifg_group
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.67 2005/05/22 18:23:04 henning Exp $	*/
d184 1
@


1.67
log
@allow pf to match on interface groups
pass on mygroup ...
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.66 2005/05/21 21:03:57 henning Exp $	*/
d411 10
a420 4
	char			 ifg_group[IFNAMSIZ];
	u_int			 ifg_refcnt;
	caddr_t			 ifg_pf_kif;
	TAILQ_ENTRY(ifg_group)	 ifg_next;
@


1.66
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.65 2005/04/20 23:00:40 mpf Exp $	*/
d413 1
@


1.65
log
@Introduce if_linkstatehooks.
This converts if_link_state_change() to a generic usable
callback with dohooks().

OK henning@@, camield@@
Tested by camield@@ and Alexey E. Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.64 2005/02/07 15:00:17 mcbride Exp $	*/
d184 1
@


1.64
log
@Add new function if_link_state_change() to take care of sending messages
on the routing socket and notifying carp() of link changes.

ok brad@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.63 2005/01/14 11:49:01 henning Exp $	*/
d179 1
@


1.63
log
@remove old ifgroups ioctls
the old ifgroups haven't been in use ever really, and the new
implementation is 3 months old today. theo ok (3 months ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.62 2004/12/07 20:38:46 mcbride Exp $	*/
d653 1
@


1.62
log
@Convert carp(4) to behave more like a regular interface, much in the same
style as vlan(4). carp interfaces no longer require the physical interface
to be on the same subnet as the carp interface, or even that the physical
interface has an adress at all, so CARP can now be used on /30 networks.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.61 2004/12/07 19:26:46 mcbride Exp $	*/
a434 15
};

/* XXX henning removes this 20050115, compat shitz */
struct oifgroup {
	char ifg_group[IFNAMSIZ];
	TAILQ_ENTRY(oifgroup) ifg_next;
};

struct oifgroupreq {
	char	ifgr_name[IFNAMSIZ];
	u_int	ifgr_len;
	union {
		char	ifgru_group[IFNAMSIZ];
		struct	oifgroup *ifgru_groups;
	} ifgr_ifgru;
@


1.61
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.60 2004/12/03 17:31:03 henning Exp $	*/
d183 6
a188 1
	caddr_t	if_carp;		/* carp structure */
@


1.60
log
@do not use one struct timeout for the if congestion stuff, but embed
a struct timeout to struct ifqueue so that each one has its own - it
is a per-queue thing. from chris pascoe
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.59 2004/11/10 21:10:53 grange Exp $	*/
d522 1
a522 1
	char 		*if_name;
d528 1
a528 1
char 	*if_indextoname(unsigned int, char *);
d652 1
a652 1
	   struct mbuf *, struct sockaddr *, struct rtentry *);
d696 1
a696 1
	   struct mbuf *, struct sockaddr *, struct rtentry *);
@


1.59
log
@Safer IF_INPUT_ENQUEUE macro.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.58 2004/10/14 21:28:15 mickey Exp $	*/
d144 1
a144 1
	int	ifq_congestion;
@


1.58
log
@avoid stupid commons
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.57 2004/10/11 10:13:49 henning Exp $	*/
d311 1
a311 1
		if (!ifq->ifq_congestion)		\
@


1.57
log
@ifgroups reqrite
there is now a TAILQ with all interface groups as members, and
in struct ofnet there is only a pointer to the group structure stored
and not its name.
mostly hacked at c2k4 and somewhere over the atlantic ocean
ok markus mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.56 2004/06/26 17:36:33 markus Exp $	*/
a402 2
TAILQ_HEAD(ifg_head, ifg_group)	ifg_head;

@


1.56
log
@cleanup ioctl for ifgroups; ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.55 2004/06/25 18:24:23 pb Exp $	*/
d177 1
a177 1
	TAILQ_HEAD(, ifgroup) if_groups; /* linked list of groups per if */
d401 1
a401 1
 * The groups on an interface
d403 15
a417 3
struct ifgroup {
	char ifg_group[IFNAMSIZ];
	TAILQ_ENTRY(ifgroup) ifg_next;
d428 1
a428 1
		struct	ifgroup *ifgru_groups;
d434 15
d672 2
a673 2
int	if_addgroup(struct ifgroupreq *, struct ifnet *);
int	if_delgroup(struct ifgroupreq *, struct ifnet *);
@


1.55
log
@introduce "interface groups"

by "ifconfig fxp0 group foobar" "ifconfig xl0 group foobar"
these two interfaces are in one group.
Every interface has its if-family as default group.

idea/design from henning@@, based on some work/disucssion from Joris Vink.

henning@@, mcbride@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.54 2004/06/20 00:38:21 beck Exp $	*/
d404 2
a405 2
	char if_group[IFNAMSIZ];
	TAILQ_ENTRY(ifgroup) group_list;
d412 2
a413 3
	char if_name[IFNAMSIZ];
	u_int ifg_len;

d415 5
a419 7
		char if_group[IFNAMSIZ];
		struct ifgroup *ifg;
	} ifg_ifgu;

	TAILQ_ENTRY(ifgroupreq) next_if;
#define ifg_group	ifg_ifgu.if_group
#define ifg_groups	ifg_ifgu.ifg
@


1.54
log
@undo mbuf cluster breakage that causes free'ed packets to show up on the
input queues when using dhcp and hostap wi, or xl, or fxp....
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.50 2004/04/17 00:09:01 henning Exp $	*/
d177 1
d401 25
d648 3
@


1.53
log
@introduce SIOCSIFDESCR and SIOCGIFDESCR to maintain interface
descriptions, configurable with ifconfig

help from various, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.52 2004/05/18 21:10:14 brad Exp $	*/
d306 8
a313 21
#define	IF_INPUT_ENQUEUE(ifq, m) {					\
	if (IF_QFULL(ifq)) {						\
		IF_DROP(ifq);						\
		m_freem(m);						\
		if (!ifq->ifq_congestion)				\
			if_congestion(ifq);				\
	} else {							\
		if (m->m_next == NULL && (m->m_flags & M_PKTHDR)) {	\
			if ((m->m_flags & M_CLUSTER) &&			\
			    m->m_len <= (MHLEN &~ (sizeof(long) - 1))) {\
				caddr_t data = m->m_data;		\
				caddr_t ext_buf = m->m_ext.ext_buf;	\
				m->m_data = m->m_pktdat;		\
				MH_ALIGN(m, m->m_len);			\
				bcopy(data, m->m_data, m->m_len);	\
				pool_put(&mclpool, ext_buf);		\
				m->m_flags &= ~(M_EXT|M_CLUSTER);	\
			}						\
		}							\
		IF_ENQUEUE(ifq, m);					\
	}								\
@


1.52
log
@if_ether.h
add ETHER_MAX_LEN_JUMBO, ETHER_VLAN_ENCAP_LEN, ETHER_ALIGN, and
ETHERMTU_JUMBO constants.

if.h
add a few more interface capabilities flags.

Some from NetBSD, some from FreeBSD.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.51 2004/04/26 05:24:00 mcbride Exp $	*/
d168 5
d188 1
@


1.51
log
@Before enqueueing the packet, copy the contents of incoming clusters
to the mbuf and free the cluster when it contains a small packet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.50 2004/04/17 00:09:01 henning Exp $	*/
d260 5
@


1.50
log
@add a congestion indicator to if_queue. It is set when the input queue
is full, along with a timer that unsets it again after 10ms.
The input queue beeing full is a reliable indicator for CPU overload, and
this flag allows other subsystems to cope with the situation.
hacked with beck
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.49 2004/01/15 10:47:55 markus Exp $	*/
d295 21
a315 8
#define	IF_INPUT_ENQUEUE(ifq, m) {			\
	if (IF_QFULL(ifq)) {				\
		IF_DROP(ifq);				\
		m_freem(m);				\
		if (!ifq->ifq_congestion)		\
			if_congestion(ifq);		\
	} else						\
		IF_ENQUEUE(ifq, m);			\
@


1.49
log
@add a RTM_IFANNOUNCE message; from netbsd; ok itojun, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.48 2003/12/16 20:33:25 markus Exp $	*/
d144 1
d294 11
d628 2
@


1.48
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.47 2003/12/10 03:30:21 itojun Exp $	*/
d359 16
@


1.47
log
@use if_indexlim (instead of if_index) and ifindex2ifnet[x] != NULL
to check if interface exists, as (1) if_index will have different meaning
(2) ifindex2ifnet could become NULL when interface gets destroyed,
when we introduce dynamically-created interfaces.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.46 2003/12/08 09:09:03 markus Exp $	*/
d92 1
a92 1
	void	(*ifc_destroy)(struct ifnet *);
@


1.46
log
@add IOCIFGCLONERS; ifconfig -C; from netbsd; ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.45 2003/12/03 13:27:36 markus Exp $	*/
d557 1
a557 1
extern int if_index;
@


1.45
log
@support for network interface "cloning", e.g. gif(4) via ifconfig(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.44 2003/10/19 03:58:25 david Exp $	*/
d97 9
@


1.44
log
@more typos
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.43 2003/10/17 21:04:58 mcbride Exp $	*/
d84 15
d574 1
a574 1
struct	ifnet *ifunit(char *);
d585 6
@


1.43
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.42 2003/08/25 08:18:54 fgsch Exp $	*/
d152 1
a152 1
	caddr_t	if_carp;		/* carp sructure */
@


1.42
log
@if_init support, required by ieee80211.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.40 2002/07/03 21:19:08 miod Exp $	*/
d152 1
@


1.41
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d166 2
@


1.40
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.39 2002/06/30 13:04:35 itojun Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.39
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.38 2002/06/23 23:55:04 itojun Exp $	*/
d531 4
a534 4
struct ifnet_head ifnet;
struct ifnet **ifindex2ifnet;
struct ifnet *lo0ifp;
int if_index;
@


1.38
log
@g/c last remains of old ipv6 prefix management
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.37 2002/05/27 13:42:16 itojun Exp $	*/
d175 1
d545 2
@


1.37
log
@if_attach() gets called before domaininit().  scan all interfaces for if_afdata
initialization after domaininit().
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.36 2002/05/27 02:59:40 itojun Exp $	*/
a174 1
	struct ifprefix *if_prefixlist; /* linked list of prefixes per if */
a306 14

/*
 * The prefix structure contains information about one prefix
 * of an interface.  They are maintained by the different address families,
 * are allocated and attached when an prefix or an address is set,
 * and are linked together so all prfefixes for an interface can be located.
 */
struct ifprefix {
	struct	sockaddr *ifpr_prefix;	/* prefix of interface */
	struct	ifnet *ifpr_ifp;	/* back-pointer to interface */
	struct ifprefix *ifpr_next;
	u_char	ifpr_plen;		/* prefix length in bits */
	u_char	ifpr_type;		/* protocol dependent prefix type */
};
@


1.36
log
@framework to add af-dependent data structure to struct ifnet.
as discussed at bsd-api-discuss.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.35 2002/04/24 00:51:51 dhartmei Exp $	*/
d560 1
@


1.35
log
@Add hooks to struct ifnet that allow to register callbacks that will be
notified of interface address changes. ok provos@@, angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.34 2002/03/15 01:20:04 millert Exp $	*/
d176 2
@


1.34
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.33 2002/03/14 01:27:09 millert Exp $	*/
d151 1
@


1.33
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.32 2002/01/23 19:16:09 fgsch Exp $	*/
d162 2
a163 1
	int	(*if_output)		/* output routine (enqueue) */(struct ifnet *, struct mbuf *, struct sockaddr *,
d165 8
a172 4
	void	(*if_start)		/* initiate output routine */(struct ifnet *);
	int	(*if_ioctl)		/* ioctl routine */(struct ifnet *, u_long, caddr_t);
	int	(*if_reset)		/* XXX bus reset routine */(struct ifnet *);
	void	(*if_watchdog)		/* timer routine */(struct ifnet *);
d298 2
a299 1
	void	(*ifa_rtrequest)	/* check or clean routes (+ or -)'d */(int, struct rtentry *, struct rt_addrinfo *);
@


1.32
log
@compatability -> compatibility.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.31 2001/07/05 08:34:46 angelos Exp $	*/
d162 6
a167 11
	int	(*if_output)		/* output routine (enqueue) */
		__P((struct ifnet *, struct mbuf *, struct sockaddr *,
		     struct rtentry *));
	void	(*if_start)		/* initiate output routine */
		__P((struct ifnet *));
	int	(*if_ioctl)		/* ioctl routine */
		__P((struct ifnet *, u_long, caddr_t));
	int	(*if_reset)		/* XXX bus reset routine */
		__P((struct ifnet *));
	void	(*if_watchdog)		/* timer routine */
		__P((struct ifnet *));
d293 1
a293 2
	void	(*ifa_rtrequest)	/* check or clean routes (+ or -)'d */
		    __P((int, struct rtentry *, struct rt_addrinfo *));
d422 3
a424 3
unsigned int if_nametoindex __P((const char *));
char 	*if_indextoname __P((unsigned int, char *));
struct	if_nameindex *if_nameindex __P((void));
d541 38
a578 38
void	ether_ifattach __P((struct ifnet *));
void	ether_ifdetach __P((struct ifnet *));
int	ether_ioctl __P((struct ifnet *, struct arpcom *, u_long, caddr_t));
void	ether_input_mbuf __P((struct ifnet *, struct mbuf *));
void	ether_input __P((struct ifnet *, struct ether_header *, struct mbuf *));
int	ether_output __P((struct ifnet *,
	   struct mbuf *, struct sockaddr *, struct rtentry *));
char	*ether_sprintf __P((u_char *));

void	if_attach __P((struct ifnet *));
void	if_attachtail __P((struct ifnet *));
void	if_attachhead __P((struct ifnet *));
void	if_detach __P((struct ifnet *));
void	if_down __P((struct ifnet *));
void	if_qflush __P((struct ifqueue *));
void	if_slowtimo __P((void *));
void	if_up __P((struct ifnet *));
int	ifconf __P((u_long, caddr_t));
void	ifinit __P((void));
int	ifioctl __P((struct socket *, u_long, caddr_t, struct proc *));
int	ifpromisc __P((struct ifnet *, int));
struct	ifnet *ifunit __P((char *));

struct	ifaddr *ifa_ifwithaddr __P((struct sockaddr *));
struct	ifaddr *ifa_ifwithaf __P((int));
struct	ifaddr *ifa_ifwithdstaddr __P((struct sockaddr *));
struct	ifaddr *ifa_ifwithnet __P((struct sockaddr *));
struct	ifaddr *ifa_ifwithroute __P((int, struct sockaddr *,
					struct sockaddr *));
struct	ifaddr *ifaof_ifpforaddr __P((struct sockaddr *, struct ifnet *));
void	ifafree __P((struct ifaddr *));
void	link_rtrequest __P((int, struct rtentry *, struct rt_addrinfo *));

int	loioctl __P((struct ifnet *, u_long, caddr_t));
void	loopattach __P((int));
int	looutput __P((struct ifnet *,
	   struct mbuf *, struct sockaddr *, struct rtentry *));
void	lortrequest __P((int, struct rtentry *, struct rt_addrinfo *));
@


1.31
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.30 2001/07/05 08:27:38 jjbg Exp $	*/
d326 1
a326 1
	u_char	ifm_version;	/* future binary compatability */
d340 1
a340 1
	u_char	ifam_version;	/* future binary compatability */
@


1.31.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.32 2002/01/23 19:16:09 fgsch Exp $	*/
d326 1
a326 1
	u_char	ifm_version;	/* future binary compatibility */
d340 1
a340 1
	u_char	ifam_version;	/* future binary compatibility */
@


1.31.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.31.4.1 2002/01/31 22:55:43 niklas Exp $	*/
a150 1
	struct hook_desc_head *if_addrhooks; /* address change callbacks */
d162 11
a172 11
					/* output routine (enqueue) */
	int	(*if_output)(struct ifnet *, struct mbuf *, struct sockaddr *,
		     struct rtentry *);
					/* initiate output routine */
	void	(*if_start)(struct ifnet *);
					/* ioctl routine */
	int	(*if_ioctl)(struct ifnet *, u_long, caddr_t);
					/* XXX bus reset routine */
	int	(*if_reset)(struct ifnet *);
					/* timer routine */
	void	(*if_watchdog)(struct ifnet *);
a174 2

	void	*if_afdata[AF_MAX];
d298 2
a299 2
					/* check or clean routes (+ or -)'d */
	void	(*ifa_rtrequest)(int, struct rtentry *, struct rt_addrinfo *);
d428 3
a430 3
unsigned int if_nametoindex(const char *);
char 	*if_indextoname(unsigned int, char *);
struct	if_nameindex *if_nameindex(void);
d547 38
a584 39
void	ether_ifattach(struct ifnet *);
void	ether_ifdetach(struct ifnet *);
int	ether_ioctl(struct ifnet *, struct arpcom *, u_long, caddr_t);
void	ether_input_mbuf(struct ifnet *, struct mbuf *);
void	ether_input(struct ifnet *, struct ether_header *, struct mbuf *);
int	ether_output(struct ifnet *,
	   struct mbuf *, struct sockaddr *, struct rtentry *);
char	*ether_sprintf(u_char *);

void	if_attach(struct ifnet *);
void	if_attachdomain(void);
void	if_attachtail(struct ifnet *);
void	if_attachhead(struct ifnet *);
void	if_detach(struct ifnet *);
void	if_down(struct ifnet *);
void	if_qflush(struct ifqueue *);
void	if_slowtimo(void *);
void	if_up(struct ifnet *);
int	ifconf(u_long, caddr_t);
void	ifinit(void);
int	ifioctl(struct socket *, u_long, caddr_t, struct proc *);
int	ifpromisc(struct ifnet *, int);
struct	ifnet *ifunit(char *);

struct	ifaddr *ifa_ifwithaddr(struct sockaddr *);
struct	ifaddr *ifa_ifwithaf(int);
struct	ifaddr *ifa_ifwithdstaddr(struct sockaddr *);
struct	ifaddr *ifa_ifwithnet(struct sockaddr *);
struct	ifaddr *ifa_ifwithroute(int, struct sockaddr *,
					struct sockaddr *);
struct	ifaddr *ifaof_ifpforaddr(struct sockaddr *, struct ifnet *);
void	ifafree(struct ifaddr *);
void	link_rtrequest(int, struct rtentry *, struct rt_addrinfo *);

int	loioctl(struct ifnet *, u_long, caddr_t);
void	loopattach(int);
int	looutput(struct ifnet *,
	   struct mbuf *, struct sockaddr *, struct rtentry *);
void	lortrequest(int, struct rtentry *, struct rt_addrinfo *);
@


1.31.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.31.4.2 2002/06/11 03:30:45 art Exp $	*/
d175 1
a175 1
	struct sockaddr_dl *if_sadl;	/* pointer to our sockaddr_dl */
d310 14
d545 4
a548 4
extern struct ifnet_head ifnet;
extern struct ifnet **ifindex2ifnet;
extern struct ifnet *lo0ifp;
extern int if_index;
a558 2
void	if_alloc_sadl(struct ifnet *);
void	if_free_sadl(struct ifnet *);
@


1.30
log
@Include files for IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.29 2001/06/27 05:50:06 kjc Exp $	*/
d232 1
a232 1
#define IFCAP_IPCOMP		0x00000040	/* can do IPcomp */
@


1.29
log
@ALTQ base modifications to the kernel.
 - ALTQ introduces a set of new queue macros that coexist with the
   traditional IF_XXX macros.
 - "struct ifaltq" replaces "struct ifqueue" in "struct ifnet".
 - assign cdev major 74 for i386 and 54 for alpha as ALTQ control interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.28 2001/06/23 22:52:51 fgsch Exp $	*/
d232 1
@


1.28
log
@Add ether_input_mbuf to help us remove the ether_header from
ether_input; all drivers should start migrating to this.
Discussed with jason@@, deraadt@@ more or les ok'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.27 2001/06/15 03:38:33 itojun Exp $	*/
d45 8
d116 11
d173 1
a173 7
	struct	ifqueue {
		struct	mbuf *ifq_head;
		struct	mbuf *ifq_tail;
		int	ifq_len;
		int	ifq_maxlen;
		int	ifq_drops;
	} if_snd;			/* output queue */
d266 14
d444 96
@


1.27
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.26 2001/06/09 06:16:37 angelos Exp $	*/
d426 1
@


1.26
log
@By popular demand, protect from multiple inclusion, and fix to use the
same naming style.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.25 2001/05/28 10:29:21 angelos Exp $	*/
d104 1
a104 1
	struct	timeval ifi_lastchange;	/* last updated */
@


1.25
log
@IPSECv4 -> IPSEC
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.24 2001/05/28 05:52:51 angelos Exp $	*/
d39 3
d461 1
@


1.24
log
@No need for separate ESP/AH interface capabilities.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.23 2001/05/28 05:16:27 angelos Exp $	*/
d213 1
a213 1
#define	IFCAP_IPSECv4		0x00000008	/* can do IPv4 IPsec */
@


1.23
log
@Interface capabilities (based on NetBSD, but merge ethercom and ifnet
capabilities into one, in the ifp).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.22 2001/02/06 00:22:22 mickey Exp $	*/
d213 3
a215 4
#define	IFCAP_IPSEC_ESPv4	0x00000008	/* can do IPv4/ESP */
#define	IFCAP_IPSEC_AHv4	0x00000010	/* can do IPv4/AH */
#define	IFCAP_VLAN_MTU		0x00000020	/* VLAN-compatible MTU */
#define	IFCAP_VLAN_HWTAGGING	0x00000040	/* hardware VLAN tag support */
@


1.22
log
@allow changing number of loopbacks in ukc.
change rest of the code to use lo0ifp pointing
to the corresponding struct ifnet.
itojun@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.21 2001/01/19 06:37:36 itojun Exp $	*/
d136 4
a139 2
	struct	if_data if_data;	/* statistics and other data about if */
/* procedure handles */
a203 1
 * XXX 1000 vs. 1024? --thorpej@@netbsd.org
d208 9
@


1.21
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.20 2000/09/20 13:07:25 art Exp $	*/
d408 1
a408 3
#if 0
struct ifnet loif[];
#endif
@


1.20
log
@Since ifa_refcnt was bumped to an int and rt_flags is an int too, bump
ifa_flags to int.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.19 2000/08/28 18:30:38 deraadt Exp $	*/
d74 1
d259 1
a259 1
		    __P((int, struct rtentry *, struct sockaddr *));
d443 1
a443 1
void	link_rtrequest __P((int, struct rtentry *, struct sockaddr *));
d449 1
a449 1
void	lortrequest __P((int, struct rtentry *, struct sockaddr *));
@


1.19
log
@changing the size of if_data has heavy impact on userland compat.  there
was even a u_char slot available for ifi_link_state, which clearly does not
need a full 32 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.18 2000/08/26 20:04:16 nate Exp $	*/
d259 1
a259 1
	u_short	ifa_flags;		/* mostly rt_flags for cloning */
@


1.18
log
@sync mii code with netbsd
adds detach functionality for phys
some code cleanup

Nobody really had time to test all of this out, but theo said commit anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.17 2000/03/22 11:28:42 itojun Exp $	*/
d84 1
a84 1
	int	ifi_link_state;		/* current link state */
@


1.17
log
@remove if_withname(), which was imported during KAME merge by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.16 2000/03/21 23:31:26 mickey Exp $	*/
d84 1
d104 7
d162 1
d198 8
@


1.16
log
@add SIOCGIFMTU/SIOCSIFMTU; remediate redundant code of tun, ppp, sppp; chris@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.15 2000/02/02 17:14:36 itojun Exp $	*/
a415 1
struct  ifnet *if_withname __P((struct sockaddr *));
@


1.15
log
@wrap IFAFREE() by "do {} while (0)".  it wasn't safe enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.14 1999/12/08 06:50:17 itojun Exp $	*/
d311 1
@


1.15.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a310 1
#define	ifr_mtu		ifr_ifru.ifru_metric	/* mtu (overload) */
d415 1
@


1.15.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.22 2001/02/06 00:22:22 mickey Exp $	*/
a73 1
struct rt_addrinfo;
a83 1
	u_char	ifi_link_state;		/* current link state */
a102 7
 * Values for if_link_state.
 */
#define	LINK_STATE_UNKNOWN	0	/* link invalid/unknown */
#define	LINK_STATE_DOWN		1	/* link is down */
#define	LINK_STATE_UP		2	/* link is up */

/*
a153 1
#define	if_link_state	if_data.ifi_link_state
a190 8
 * Some convenience macros used for setting ifi_baudrate.
 * XXX 1000 vs. 1024? --thorpej@@netbsd.org
 */
#define	IF_Kbps(x)	((x) * 1000)		/* kilobits/sec. */
#define	IF_Mbps(x)	(IF_Kbps((x) * 1000))	/* megabits/sec. */
#define	IF_Gbps(x)	(IF_Mbps((x) * 1000))	/* gigabits/sec. */

/*
d241 2
a242 2
		    __P((int, struct rtentry *, struct rt_addrinfo *));
	u_int	ifa_flags;		/* mostly rt_flags for cloning */
d390 3
a392 1
struct ifnet *lo0ifp;
d425 1
a425 1
void	link_rtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
d431 1
a431 1
void	lortrequest __P((int, struct rtentry *, struct rt_addrinfo *));
@


1.15.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.15.2.2 2001/05/14 22:39:59 niklas Exp $	*/
a38 3
#ifndef _NET_IF_H_
#define _NET_IF_H_

a41 8
 * Always include ALTQ glue here -- we use the ALTQ interface queue
 * structure even when ALTQ is not configured into the kernel so that
 * the size of struct ifnet does not changed based on the option.  The
 * ALTQ queue structure is API-compatible with the legacy ifqueue.
 */
#include <altq/if_altq.h>

/*
d101 1
a101 12
	struct	timeval ifi_lastchange;	/* last operational state change */
};

/*
 * Structure defining a queue for a network interface.
 */
struct	ifqueue {
	struct	mbuf *ifq_head;
	struct	mbuf *ifq_tail;
	int	ifq_len;
	int	ifq_maxlen;
	int	ifq_drops;
d136 2
a137 4
	struct	if_data if_data;	/* stats and other data about if */
	int	if_capabilities;	/* interface capabilities */

	/* procedure handles */
d149 7
a155 1
	struct	ifaltq if_snd;		/* output queue (includes altq) */
d202 1
a207 8
/* Capabilities that interfaces can advertise. */
#define	IFCAP_CSUM_IPv4		0x00000001	/* can do IPv4 header csum */
#define	IFCAP_CSUM_TCPv4	0x00000002	/* can do IPv4/TCP csum */
#define	IFCAP_CSUM_UDPv4	0x00000004	/* can do IPv4/UDP csum */
#define	IFCAP_IPSEC		0x00000008	/* can do IPsec */
#define	IFCAP_VLAN_MTU		0x00000010	/* VLAN-compatible MTU */
#define	IFCAP_VLAN_HWTAGGING	0x00000020	/* hardware VLAN tag support */

a240 14
#define	IF_POLL(ifq, m)		((m) = (ifq)->ifq_head)
#define	IF_PURGE(ifq)							\
do {									\
	struct mbuf *__m0;						\
									\
	for (;;) {							\
		IF_DEQUEUE((ifq), __m0);				\
		if (__m0 == NULL)					\
			break;						\
		else							\
			m_freem(__m0);					\
	}								\
} while (0)
#define	IF_IS_EMPTY(ifq)	((ifq)->ifq_len == 0)
a405 96
#ifdef ALTQ
#define	ALTQ_DECL(x)		x

#define	IFQ_ENQUEUE(ifq, m, pattr, err)					\
do {									\
	if (ALTQ_IS_ENABLED((ifq)))					\
		ALTQ_ENQUEUE((ifq), (m), (pattr), (err));		\
	else {								\
		if (IF_QFULL((ifq))) {					\
			m_freem((m));					\
			(err) = ENOBUFS;				\
		} else {						\
			IF_ENQUEUE((ifq), (m));				\
			(err) = 0;					\
		}							\
	}								\
	if ((err))							\
		(ifq)->ifq_drops++;					\
} while (0)

#define	IFQ_DEQUEUE(ifq, m)						\
do {									\
	if (TBR_IS_ENABLED((ifq)))					\
		(m) = tbr_dequeue((ifq), ALTDQ_REMOVE);			\
	else if (ALTQ_IS_ENABLED((ifq)))				\
		ALTQ_DEQUEUE((ifq), (m));				\
	else								\
		IF_DEQUEUE((ifq), (m));					\
} while (0)

#define	IFQ_POLL(ifq, m)						\
do {									\
	if (TBR_IS_ENABLED((ifq)))					\
		(m) = tbr_dequeue((ifq), ALTDQ_POLL);			\
	else if (ALTQ_IS_ENABLED((ifq)))				\
		ALTQ_POLL((ifq), (m));					\
	else								\
		IF_POLL((ifq), (m));					\
} while (0)

#define	IFQ_PURGE(ifq)							\
do {									\
	if (ALTQ_IS_ENABLED((ifq)))					\
		ALTQ_PURGE((ifq));					\
	else								\
		IF_PURGE((ifq));					\
} while (0)

#define	IFQ_SET_READY(ifq)						\
	do { ((ifq)->altq_flags |= ALTQF_READY); } while (0)

#define	IFQ_CLASSIFY(ifq, m, af, pa)					\
do {									\
	if (ALTQ_IS_ENABLED((ifq))) {					\
		if (ALTQ_NEEDS_CLASSIFY((ifq)))				\
			(pa)->pattr_class = (*(ifq)->altq_classify)	\
				((ifq)->altq_clfier, (m), (af));	\
		(pa)->pattr_af = (af);					\
		(pa)->pattr_hdr = mtod((m), caddr_t);			\
	}								\
} while (0)

#else /* !ALTQ */
#define	ALTQ_DECL(x)		/* nothing */

#define	IFQ_ENQUEUE(ifq, m, pattr, err)					\
do {									\
	if (IF_QFULL((ifq))) {						\
		m_freem((m));						\
		(err) = ENOBUFS;					\
	} else {							\
		IF_ENQUEUE((ifq), (m));					\
		(err) = 0;						\
	}								\
	if ((err))							\
		(ifq)->ifq_drops++;					\
} while (0)

#define	IFQ_DEQUEUE(ifq, m)	IF_DEQUEUE((ifq), (m))

#define	IFQ_POLL(ifq, m)	IF_POLL((ifq), (m))

#define	IFQ_PURGE(ifq)		IF_PURGE((ifq))

#define	IFQ_SET_READY(ifq)	/* nothing */

#define	IFQ_CLASSIFY(ifq, m, af, pa) /* nothing */

#endif /* ALTQ */

#define	IFQ_IS_EMPTY(ifq)		((ifq)->ifq_len == 0)
#define	IFQ_INC_LEN(ifq)		((ifq)->ifq_len++)
#define	IFQ_DEC_LEN(ifq)		(--(ifq)->ifq_len)
#define	IFQ_INC_DROPS(ifq)		((ifq)->ifq_drops++)
#define	IFQ_SET_MAXLEN(ifq, len)	((ifq)->ifq_maxlen = (len))

a413 1
void	ether_input_mbuf __P((struct ifnet *, struct mbuf *));
a448 1
#endif /* _NET_IF_H_ */
@


1.15.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.15.2.3 2001/07/04 10:53:53 niklas Exp $	*/
a231 1
#define	IFCAP_IPCOMP		0x00000040	/* can do IPcomp */
@


1.15.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d326 1
a326 1
	u_char	ifm_version;	/* future binary compatibility */
d340 1
a340 1
	u_char	ifam_version;	/* future binary compatibility */
@


1.15.2.6
log
@Merge in -current from roughly a week ago
@
text
@d162 11
a172 11
					/* output routine (enqueue) */
	int	(*if_output)(struct ifnet *, struct mbuf *, struct sockaddr *,
		     struct rtentry *);
					/* initiate output routine */
	void	(*if_start)(struct ifnet *);
					/* ioctl routine */
	int	(*if_ioctl)(struct ifnet *, u_long, caddr_t);
					/* XXX bus reset routine */
	int	(*if_reset)(struct ifnet *);
					/* timer routine */
	void	(*if_watchdog)(struct ifnet *);
d298 2
a299 2
					/* check or clean routes (+ or -)'d */
	void	(*ifa_rtrequest)(int, struct rtentry *, struct rt_addrinfo *);
d428 3
a430 3
unsigned int if_nametoindex(const char *);
char 	*if_indextoname(unsigned int, char *);
struct	if_nameindex *if_nameindex(void);
d547 38
a584 38
void	ether_ifattach(struct ifnet *);
void	ether_ifdetach(struct ifnet *);
int	ether_ioctl(struct ifnet *, struct arpcom *, u_long, caddr_t);
void	ether_input_mbuf(struct ifnet *, struct mbuf *);
void	ether_input(struct ifnet *, struct ether_header *, struct mbuf *);
int	ether_output(struct ifnet *,
	   struct mbuf *, struct sockaddr *, struct rtentry *);
char	*ether_sprintf(u_char *);

void	if_attach(struct ifnet *);
void	if_attachtail(struct ifnet *);
void	if_attachhead(struct ifnet *);
void	if_detach(struct ifnet *);
void	if_down(struct ifnet *);
void	if_qflush(struct ifqueue *);
void	if_slowtimo(void *);
void	if_up(struct ifnet *);
int	ifconf(u_long, caddr_t);
void	ifinit(void);
int	ifioctl(struct socket *, u_long, caddr_t, struct proc *);
int	ifpromisc(struct ifnet *, int);
struct	ifnet *ifunit(char *);

struct	ifaddr *ifa_ifwithaddr(struct sockaddr *);
struct	ifaddr *ifa_ifwithaf(int);
struct	ifaddr *ifa_ifwithdstaddr(struct sockaddr *);
struct	ifaddr *ifa_ifwithnet(struct sockaddr *);
struct	ifaddr *ifa_ifwithroute(int, struct sockaddr *,
					struct sockaddr *);
struct	ifaddr *ifaof_ifpforaddr(struct sockaddr *, struct ifnet *);
void	ifafree(struct ifaddr *);
void	link_rtrequest(int, struct rtentry *, struct rt_addrinfo *);

int	loioctl(struct ifnet *, u_long, caddr_t);
void	loopattach(int);
int	looutput(struct ifnet *,
	   struct mbuf *, struct sockaddr *, struct rtentry *);
void	lortrequest(int, struct rtentry *, struct rt_addrinfo *);
@


1.15.2.7
log
@Sync the SMP branch with 3.3
@
text
@a150 1
	struct hook_desc_head *if_addrhooks; /* address change callbacks */
d174 1
a174 3
	struct sockaddr_dl *if_sadl;	/* pointer to our sockaddr_dl */

	void	*if_afdata[AF_MAX];
d307 14
d542 4
a545 4
extern struct ifnet_head ifnet;
extern struct ifnet **ifindex2ifnet;
extern struct ifnet *lo0ifp;
extern int if_index;
a555 2
void	if_alloc_sadl(struct ifnet *);
void	if_free_sadl(struct ifnet *);
a556 1
void	if_attachdomain(void);
@


1.15.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.15.2.7 2003/03/28 00:41:28 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.15.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a83 24
 * Structure describing a `cloning' interface.
 */
struct if_clone {
	LIST_ENTRY(if_clone) ifc_list;	/* on list of cloners */
	const char *ifc_name;		/* name of device, e.g. `gif' */
	size_t ifc_namelen;		/* length of name */

	int	(*ifc_create)(struct if_clone *, int);
	int	(*ifc_destroy)(struct ifnet *);
};

#define	IF_CLONE_INITIALIZER(name, create, destroy)			\
	{ { 0 }, name, sizeof(name) - 1, create, destroy }

/*
 * Structure used to query names of interface cloners.
 */
struct if_clonereq {
	int	ifcr_total;		/* total cloners (out) */
	int	ifcr_count;		/* room for this many in user buffer */
	char	*ifcr_buffer;		/* buffer for cloner names */
};

/*
a151 1
	caddr_t	if_carp;		/* carp structure */
a165 2
					/* init routine */
	int	(*if_init)(struct ifnet *);
a332 16

/*
 * Message format announcing the arrival or departure of a network interface.
 */
struct if_announcemsghdr {
	u_short	ifan_msglen;	/* to skip over non-understood messages */
	u_char	ifan_version;	/* future binary compatibility */
	u_char	ifan_type;	/* message type */
	u_short	ifan_index;	/* index for associated ifp */
	char	ifan_name[IFNAMSIZ];	/* if name, e.g. "en0" */
	u_short	ifan_what;	/* what type of announcement */
};

#define IFAN_ARRIVAL	0	/* interface arrival */
#define IFAN_DEPARTURE	1	/* interface departure */

d530 1
a530 1
extern int if_indexlim;
d556 1
a556 1
struct	ifnet *ifunit(const char *);
a566 6

void	if_clone_attach(struct if_clone *);
void	if_clone_detach(struct if_clone *);

int	if_clone_create(const char *);
int	if_clone_destroy(const char *);
@


1.15.2.10
log
@Merge with the trunk
@
text
@a143 1
	int	ifq_congestion;
a166 5
/*
 * Length of interface description, including terminating '\0'.
 */
#define	IFDESCRSIZE	64

a181 1
	char	if_description[IFDESCRSIZE]; /* interface description */
a258 5
#define	IFCAP_JUMBO_MTU		0x00000080	/* 9000 byte MTU supported */
#define	IFCAP_CSUM_TCPv6	0x00000100	/* can do IPv6/TCP checksums */
#define	IFCAP_CSUM_UDPv6	0x00000200	/* can do IPv6/UDP checksums */
#define	IFCAP_CSUM_TCPv4_Rx	0x00000400	/* can do IPv4/TCP (Rx only) */
#define	IFCAP_CSUM_UDPv4_Rx	0x00000800	/* can do IPv4/UDP (Rx only) */
a292 24

#define	IF_INPUT_ENQUEUE(ifq, m) {					\
	if (IF_QFULL(ifq)) {						\
		IF_DROP(ifq);						\
		m_freem(m);						\
		if (!ifq->ifq_congestion)				\
			if_congestion(ifq);				\
	} else {							\
		if (m->m_next == NULL && (m->m_flags & M_PKTHDR)) {	\
			if ((m->m_flags & M_CLUSTER) &&			\
			    m->m_len <= (MHLEN &~ (sizeof(long) - 1))) {\
				caddr_t data = m->m_data;		\
				caddr_t ext_buf = m->m_ext.ext_buf;	\
				m->m_data = m->m_pktdat;		\
				MH_ALIGN(m, m->m_len);			\
				bcopy(data, m->m_data, m->m_len);	\
				pool_put(&mclpool, ext_buf);		\
				m->m_flags &= ~(M_EXT|M_CLUSTER);	\
			}						\
		}							\
		IF_ENQUEUE(ifq, m);					\
	}								\
}

a615 2

void	if_congestion(struct ifqueue *);
@


1.14
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.13 1999/08/08 00:43:00 niklas Exp $	*/
d379 2
a380 1
#define	IFAFREE(ifa) { \
d385 1
a385 1
	}
@


1.13
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.12 1999/06/23 21:55:28 cmetz Exp $	*/
d114 1
d147 1
d249 14
d350 12
d367 2
d372 3
a374 2

#define if_freenameindex(x) free(x)
d387 5
d414 1
@


1.12
log
@Added some protocol independent interfaces (supposedly IPv6 support APIs, but
ones that are useful for all protocols, not just IPv6).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.11 1999/03/13 19:06:16 deraadt Exp $	*/
d358 1
d368 1
@


1.11
log
@make ifa_refcnt a u_int; andrewb@@demon.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.10 1999/02/26 17:01:31 jason Exp $	*/
d333 11
@


1.10
log
@Ethernet bridge/IP firewall driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.9 1999/01/07 06:03:28 deraadt Exp $	*/
d241 1
a241 1
	short	ifa_refcnt;		/* count of references */
@


1.9
log
@fix IFAFREE() to be safe for if/else nesting
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.8 1998/09/03 06:24:20 jason Exp $	*/
d122 1
@


1.8
log
@o OpenBSD gets if_media support (from NetBSD)
o rework/simplify if_xl to use it
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.7 1996/07/02 06:52:04 niklas Exp $	*/
d336 1
a336 1
#define	IFAFREE(ifa) \
d340 2
a341 1
		(ifa)->ifa_refcnt--;
@


1.7
log
@-Wall & -Wstrict-prototype fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.6 1996/06/29 18:54:10 deraadt Exp $	*/
d294 1
d304 11
@


1.6
log
@provide if_attachhead(), and make if_loop use it
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.5 1996/05/10 12:31:07 deraadt Exp $	*/
d341 1
@


1.5
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.3 1996/03/05 15:44:23 mickey Exp $	*/
d340 1
@


1.4
log
@if.h was missed from the commit.
if_ethersubr.c: missed variables added.
@
text
@d2 1
a2 1
/*	$NetBSD: if.h,v 1.20 1996/02/13 22:00:12 christos Exp $	*/
d109 6
d116 1
a116 1
	char	*if_name;		/* name, e.g. ``en'' or ``lo'' */
d119 1
a122 1
	short	if_unit;		/* sub-unit for lower level driver */
d135 1
a135 1
		__P((int));
d137 1
a137 1
		__P((int));
a279 1
#define	IFNAMSIZ	16
@


1.3
log
@Changes for ifconfig to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.h,v 1.2 1996/03/03 21:07:06 niklas Exp $	*/
d73 1
d328 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d294 2
a295 1
	struct	sockaddr ifra_broadaddr;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: if.h,v 1.19 1995/06/19 21:57:28 cgd Exp $	*/
d230 2
a231 1
	void	(*ifa_rtrequest)();	/* check or clean routes (+ or -)'d */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
