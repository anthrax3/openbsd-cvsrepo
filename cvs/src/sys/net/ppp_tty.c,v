head	1.46;
access;
symbols
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.43.0.6
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.4
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.20.0.30
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.28
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.24
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.26
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.22
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.20
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.18
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.16
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.14
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.12
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.10
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.45;
commitid	6c6qq5OdS4VVnyVM;

1.45
date	2016.12.19.15.57.30;	author mpi;	state Exp;
branches;
next	1.44;
commitid	aX34cgZiGnZwOvqB;

1.44
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.43;
commitid	RlO92XR575sygHqm;

1.43
date	2016.01.25.18.47.00;	author stefan;	state Exp;
branches;
next	1.42;
commitid	o85lCu4CruswznJc;

1.42
date	2016.01.14.09.44.08;	author sf;	state Exp;
branches;
next	1.41;
commitid	ufhpvQnfS1RjjAYf;

1.41
date	2015.12.21.21.49.02;	author sf;	state Exp;
branches;
next	1.40;
commitid	QfhbTzV3KV3v5lir;

1.40
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.39;
commitid	ILbVM1M3uPNjwswz;

1.39
date	2015.11.24.13.37.16;	author mpi;	state Exp;
branches;
next	1.38;
commitid	djjKhPvMtRdFfuFJ;

1.38
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.37;
commitid	zZXiESHR0g5lNO0l;

1.37
date	2015.09.12.20.26.07;	author mpi;	state Exp;
branches;
next	1.36;
commitid	UM7jfgLT8vWQUBm1;

1.36
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	ncpqEGjDtSFuLAgn;

1.35
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.34;
commitid	9ERVupAoYqW4Iok9;

1.34
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.33;
commitid	h7z8lokZ0dFyuWpg;

1.33
date	2015.06.03.00.50.09;	author dlg;	state Exp;
branches;
next	1.32;
commitid	gxTjkPThodI9Be3R;

1.32
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.31;
commitid	c7ei8kPelCOOwHXy;

1.31
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.30;
commitid	C5iGb36LQxjM60Q3;

1.30
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.29;
commitid	t9FBKDfc4VDxpEy2;

1.29
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.28;
commitid	uuiU9j2I8AUx0fez;

1.28
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.27;
commitid	DQakU8LLWV6Iwx84;

1.27
date	2014.04.19.12.18.35;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2012.03.28.19.39.33;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.11.16.22.33;	author dhill;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.06.02.51.16;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.05.21.11.36;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.05.20.03.23;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.18.19.32.20;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.09.12.03.22;	author kjc;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.01.19.31.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.13.08.14.48;	author kjc;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.15.03.38.34;	author itojun;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.05.16.12.53.34;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.09.14.56.44;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.30.01.05.19;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.07.04.20.39.28;	author deraadt;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	97.09.05.04.27.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.03.19.24;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.07.25.14.20.51;	author joshd;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.31.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.28.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.21.07.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches;
next	;

1.8.4.1
date	2001.05.14.22.40.03;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.07.04.10.54.18;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.8.4.6;

1.8.4.6
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.46
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: ppp_tty.c,v 1.45 2016/12/19 15:57:30 mpi Exp $	*/
/*	$NetBSD: ppp_tty.c,v 1.12 1997/03/24 21:23:10 christos Exp $	*/

/*
 * ppp_tty.c - Point-to-Point Protocol (PPP) driver for asynchronous
 *	       tty devices.
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Based on:
 *	@@(#)if_sl.c	7.6.1.2 (Berkeley) 2/15/89
 *
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Serial Line interface
 *
 * Rick Adams
 * Center for Seismic Studies
 * 1300 N 17th Street, Suite 1450
 * Arlington, Virginia 22209
 * (703)276-7900
 * rick@@seismo.ARPA
 * seismo!rick
 *
 * Pounded on heavily by Chris Torek (chris@@mimsy.umd.edu, umcp-cs!chris).
 * Converted to 4.3BSD Beta by Chris Torek.
 * Other changes made at Berkeley, based in part on code by Kirk Smith.
 *
 * Converted to 4.3BSD+ 386BSD by Brad Parker (brad@@cayman.com)
 * Added VJ tcp header compression; more unified ioctls
 *
 * Extensively modified by Paul Mackerras (paulus@@cs.anu.edu.au).
 * Cleaned up a lot of the mbuf-related code to fix bugs that
 * caused system crashes and packet corruption.  Changed pppstart
 * so that it doesn't just give up with a collision if the whole
 * packet doesn't fit in the output ring buffer.
 *
 * Added priority queueing for interactive IP packets, following
 * the model of if_sl.c, plus hooks for bpf.
 * Paul Mackerras (paulus@@cs.anu.edu.au).
 */

/* from if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp */
/* from NetBSD: if_ppp.c,v 1.15.2.2 1994/07/28 05:17:58 cgd Exp */

#include "ppp.h"
#if NPPP > 0

#define VJC
#define PPP_COMPRESS

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/tty.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/vnode.h>
#include <sys/systm.h>
#include <sys/rwlock.h>
#include <sys/pool.h>

#include <net/if.h>
#include <net/if_var.h>

#ifdef VJC
#include <netinet/in.h>
#include <netinet/ip.h>
#include <net/slcompress.h>
#endif

#include <net/bpf.h>
#include <net/ppp_defs.h>
#include <net/if_ppp.h>
#include <net/if_pppvar.h>

int	pppstart_internal(struct tty *tp, int);

u_int16_t pppfcs(u_int16_t fcs, u_char *cp, int len);
void	pppasyncstart(struct ppp_softc *);
void	pppasyncctlp(struct ppp_softc *);
void	pppasyncrelinq(struct ppp_softc *);
void	ppp_timeout(void *);
void	ppppkt(struct ppp_softc *sc);
void	pppdumpb(u_char *b, int l);
void	ppplogchar(struct ppp_softc *, int);

struct rwlock ppp_pkt_init = RWLOCK_INITIALIZER("ppppktini");
struct pool ppp_pkts;

#define PKT_MAXLEN(_sc) ((_sc)->sc_mru + PPP_HDRLEN + PPP_FCSLEN)

/*
 * Does c need to be escaped?
 */
#define ESCAPE_P(c)	(sc->sc_asyncmap[(c) >> 5] & (1 << ((c) & 0x1F)))

/*
 * Procedures for using an async tty interface for PPP.
 */

/* This is a NetBSD-1.0 or later kernel. */
#define CCOUNT(q)	((q)->c_cc)

/*
 * Line specific open routine for async tty devices.
 * Attach the given tty to the first available ppp unit.
 * Called from device open routine or ttioctl.
 */
int
pppopen(dev_t dev, struct tty *tp, struct proc *p)
{
    struct ppp_softc *sc;
    int error, s;

    if ((error = suser(p, 0)) != 0)
	return (error);

    rw_enter_write(&ppp_pkt_init);
    if (ppp_pkts.pr_size == 0) {
	extern struct kmem_pa_mode kp_dma_contig;

	pool_init(&ppp_pkts, sizeof(struct ppp_pkt), 0,
	  IPL_TTY, 0, "ppppkts", NULL); /* IPL_SOFTTTY */
	pool_set_constraints(&ppp_pkts, &kp_dma_contig);
    }
    rw_exit_write(&ppp_pkt_init);

    s = spltty();

    if (tp->t_line == PPPDISC) {
	sc = (struct ppp_softc *) tp->t_sc;
	if (sc != NULL && sc->sc_devp == (void *) tp) {
	    splx(s);
	    return (0);
	}
    }

    if ((sc = pppalloc(p->p_p->ps_pid)) == NULL) {
	splx(s);
	return ENXIO;
    }

    if (sc->sc_relinq)
	(*sc->sc_relinq)(sc);	/* get previous owner to relinquish the unit */

    timeout_set(&sc->sc_timo, ppp_timeout, sc);
    sc->sc_ilen = 0;
    sc->sc_pkt = NULL;
    bzero(sc->sc_asyncmap, sizeof(sc->sc_asyncmap));
    sc->sc_asyncmap[0] = 0xffffffff;
    sc->sc_asyncmap[3] = 0x60000000;
    sc->sc_rasyncmap = 0;
    sc->sc_devp = (void *) tp;
    sc->sc_start = pppasyncstart;
    sc->sc_ctlp = pppasyncctlp;
    sc->sc_relinq = pppasyncrelinq;
    sc->sc_outm = NULL;
    ppppkt(sc);
    sc->sc_if.if_flags |= IFF_RUNNING;
    sc->sc_if.if_baudrate = tp->t_ospeed;

    tp->t_sc = (caddr_t) sc;
    ttyflush(tp, FREAD | FWRITE);

    splx(s);
    return (0);
}

/*
 * Line specific close routine, called from device close routine
 * and from ttioctl.
 * Detach the tty from the ppp unit.
 * Mimics part of ttyclose().
 */
int
pppclose(struct tty *tp, int flag, struct proc *p)
{
    struct ppp_softc *sc;
    int s;

    s = spltty();
    ttyflush(tp, FREAD|FWRITE);
    tp->t_line = 0;
    sc = (struct ppp_softc *) tp->t_sc;
    if (sc != NULL) {
	tp->t_sc = NULL;
	if (tp == (struct tty *) sc->sc_devp) {
	    pppasyncrelinq(sc);
	    pppdealloc(sc);
	}
    }
    splx(s);
    return 0;
}

/*
 * Relinquish the interface unit to another device.
 */
void
pppasyncrelinq(struct ppp_softc *sc)
{
    int s;

    s = spltty();
    m_freem(sc->sc_outm);
    sc->sc_outm = NULL;

    if (sc->sc_pkt != NULL) {
	ppp_pkt_free(sc->sc_pkt);
	sc->sc_pkt = sc->sc_pktc = NULL;
    }
    if (sc->sc_flags & SC_TIMEOUT) {
	timeout_del(&sc->sc_timo);
	sc->sc_flags &= ~SC_TIMEOUT;
    }
    splx(s);
}

/*
 * Line specific (tty) read routine.
 */
int
pppread(struct tty *tp, struct uio *uio, int flag)
{
    struct ppp_softc *sc = (struct ppp_softc *)tp->t_sc;
    struct mbuf *m, *m0;
    int s;
    int error = 0;

    if (sc == NULL)
	return 0;
    /*
     * Loop waiting for input, checking that nothing disasterous
     * happens in the meantime.
     */
    s = spltty();
    for (;;) {
	if (tp != (struct tty *) sc->sc_devp || tp->t_line != PPPDISC) {
	    splx(s);
	    return 0;
	}
	/* Get the packet from the input queue */
	m0 = mq_dequeue(&sc->sc_inq);
	if (m0 != NULL)
	    break;
	if ((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0
	    && (tp->t_state & TS_ISOPEN)) {
	    splx(s);
	    return 0;		/* end of file */
	}
	if (tp->t_state & TS_ASYNC || flag & IO_NDELAY) {
	    splx(s);
	    return (EWOULDBLOCK);
	}
	error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI|PCATCH, ttyin, 0);
	if (error) {
	    splx(s);
	    return error;
	}
    }

    /* Pull place-holder byte out of canonical queue */
    getc(&tp->t_canq);
    splx(s);

    for (m = m0; m && uio->uio_resid; m = m->m_next)
	if ((error = uiomove(mtod(m, u_char *), m->m_len, uio)) != 0)
	    break;
    m_freem(m0);
    return (error);
}

/*
 * Line specific (tty) write routine.
 */
int
pppwrite(struct tty *tp, struct uio *uio, int flag)
{
    struct ppp_softc *sc = (struct ppp_softc *)tp->t_sc;
    struct mbuf *m, *m0, **mp;
    struct sockaddr dst;
    u_int len;
    int error;

    if ((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0)
	return 0;		/* wrote 0 bytes */
    if (tp->t_line != PPPDISC)
	return (EINVAL);
    if (sc == NULL || tp != (struct tty *) sc->sc_devp)
	return EIO;
    if (uio->uio_resid > sc->sc_if.if_mtu + PPP_HDRLEN ||
	uio->uio_resid < PPP_HDRLEN)
	return (EMSGSIZE);
    for (mp = &m0; uio->uio_resid; mp = &m->m_next) {
	if (mp == &m0) {
	    MGETHDR(m, M_WAIT, MT_DATA);
	    m->m_pkthdr.len = uio->uio_resid - PPP_HDRLEN;
	    m->m_pkthdr.ph_ifidx = 0;
	} else
	    MGET(m, M_WAIT, MT_DATA);
	*mp = m;
	m->m_len = 0;
	if (uio->uio_resid >= MCLBYTES / 2)
	    MCLGET(m, M_DONTWAIT);
	len = M_TRAILINGSPACE(m);
	if (len > uio->uio_resid)
	    len = uio->uio_resid;
	if ((error = uiomove(mtod(m, u_char *), len, uio)) != 0) {
	    m_freem(m0);
	    return (error);
	}
	m->m_len = len;
    }
    dst.sa_family = AF_UNSPEC;
    bcopy(mtod(m0, u_char *), dst.sa_data, PPP_HDRLEN);
    m0->m_data += PPP_HDRLEN;
    m0->m_len -= PPP_HDRLEN;
    return sc->sc_if.if_output(&sc->sc_if, m0, &dst, NULL);
}

/*
 * Line specific (tty) ioctl routine.
 * This discipline requires that tty device drivers call
 * the line specific l_ioctl routine from their ioctl routines.
 */
int
ppptioctl(struct tty *tp, u_long cmd, caddr_t data, int flag, struct proc *p)
{
    struct ppp_softc *sc = (struct ppp_softc *) tp->t_sc;
    int error, s;

    if (sc == NULL || tp != (struct tty *) sc->sc_devp)
	return -1;

    error = 0;
    switch (cmd) {
    case PPPIOCSASYNCMAP:
	if ((error = suser(p, 0)) != 0)
	    break;
	sc->sc_asyncmap[0] = *(u_int *)data;
	break;

    case PPPIOCGASYNCMAP:
	*(u_int *)data = sc->sc_asyncmap[0];
	break;

    case PPPIOCSRASYNCMAP:
	if ((error = suser(p, 0)) != 0)
	    break;
	sc->sc_rasyncmap = *(u_int *)data;
	break;

    case PPPIOCGRASYNCMAP:
	*(u_int *)data = sc->sc_rasyncmap;
	break;

    case PPPIOCSXASYNCMAP:
	if ((error = suser(p, 0)) != 0)
	    break;
	s = spltty();
	bcopy(data, sc->sc_asyncmap, sizeof(sc->sc_asyncmap));
	sc->sc_asyncmap[1] = 0;		    /* mustn't escape 0x20 - 0x3f */
	sc->sc_asyncmap[2] &= ~0x40000000;  /* mustn't escape 0x5e */
	sc->sc_asyncmap[3] |= 0x60000000;   /* must escape 0x7d, 0x7e */
	splx(s);
	break;

    case PPPIOCGXASYNCMAP:
	bcopy(sc->sc_asyncmap, data, sizeof(sc->sc_asyncmap));
	break;

    default:
	error = pppioctl(sc, cmd, data, flag, p);
	if (error == 0 && cmd == PPPIOCSMRU)
	    ppppkt(sc);
    }

    return error;
}

/*
 * FCS lookup table as calculated by genfcstab.
 */
static u_int16_t fcstab[256] = {
	0x0000,	0x1189,	0x2312,	0x329b,	0x4624,	0x57ad,	0x6536,	0x74bf,
	0x8c48,	0x9dc1,	0xaf5a,	0xbed3,	0xca6c,	0xdbe5,	0xe97e,	0xf8f7,
	0x1081,	0x0108,	0x3393,	0x221a,	0x56a5,	0x472c,	0x75b7,	0x643e,
	0x9cc9,	0x8d40,	0xbfdb,	0xae52,	0xdaed,	0xcb64,	0xf9ff,	0xe876,
	0x2102,	0x308b,	0x0210,	0x1399,	0x6726,	0x76af,	0x4434,	0x55bd,
	0xad4a,	0xbcc3,	0x8e58,	0x9fd1,	0xeb6e,	0xfae7,	0xc87c,	0xd9f5,
	0x3183,	0x200a,	0x1291,	0x0318,	0x77a7,	0x662e,	0x54b5,	0x453c,
	0xbdcb,	0xac42,	0x9ed9,	0x8f50,	0xfbef,	0xea66,	0xd8fd,	0xc974,
	0x4204,	0x538d,	0x6116,	0x709f,	0x0420,	0x15a9,	0x2732,	0x36bb,
	0xce4c,	0xdfc5,	0xed5e,	0xfcd7,	0x8868,	0x99e1,	0xab7a,	0xbaf3,
	0x5285,	0x430c,	0x7197,	0x601e,	0x14a1,	0x0528,	0x37b3,	0x263a,
	0xdecd,	0xcf44,	0xfddf,	0xec56,	0x98e9,	0x8960,	0xbbfb,	0xaa72,
	0x6306,	0x728f,	0x4014,	0x519d,	0x2522,	0x34ab,	0x0630,	0x17b9,
	0xef4e,	0xfec7,	0xcc5c,	0xddd5,	0xa96a,	0xb8e3,	0x8a78,	0x9bf1,
	0x7387,	0x620e,	0x5095,	0x411c,	0x35a3,	0x242a,	0x16b1,	0x0738,
	0xffcf,	0xee46,	0xdcdd,	0xcd54,	0xb9eb,	0xa862,	0x9af9,	0x8b70,
	0x8408,	0x9581,	0xa71a,	0xb693,	0xc22c,	0xd3a5,	0xe13e,	0xf0b7,
	0x0840,	0x19c9,	0x2b52,	0x3adb,	0x4e64,	0x5fed,	0x6d76,	0x7cff,
	0x9489,	0x8500,	0xb79b,	0xa612,	0xd2ad,	0xc324,	0xf1bf,	0xe036,
	0x18c1,	0x0948,	0x3bd3,	0x2a5a,	0x5ee5,	0x4f6c,	0x7df7,	0x6c7e,
	0xa50a,	0xb483,	0x8618,	0x9791,	0xe32e,	0xf2a7,	0xc03c,	0xd1b5,
	0x2942,	0x38cb,	0x0a50,	0x1bd9,	0x6f66,	0x7eef,	0x4c74,	0x5dfd,
	0xb58b,	0xa402,	0x9699,	0x8710,	0xf3af,	0xe226,	0xd0bd,	0xc134,
	0x39c3,	0x284a,	0x1ad1,	0x0b58,	0x7fe7,	0x6e6e,	0x5cf5,	0x4d7c,
	0xc60c,	0xd785,	0xe51e,	0xf497,	0x8028,	0x91a1,	0xa33a,	0xb2b3,
	0x4a44,	0x5bcd,	0x6956,	0x78df,	0x0c60,	0x1de9,	0x2f72,	0x3efb,
	0xd68d,	0xc704,	0xf59f,	0xe416,	0x90a9,	0x8120,	0xb3bb,	0xa232,
	0x5ac5,	0x4b4c,	0x79d7,	0x685e,	0x1ce1,	0x0d68,	0x3ff3,	0x2e7a,
	0xe70e,	0xf687,	0xc41c,	0xd595,	0xa12a,	0xb0a3,	0x8238,	0x93b1,
	0x6b46,	0x7acf,	0x4854,	0x59dd,	0x2d62,	0x3ceb,	0x0e70,	0x1ff9,
	0xf78f,	0xe606,	0xd49d,	0xc514,	0xb1ab,	0xa022,	0x92b9,	0x8330,
	0x7bc7,	0x6a4e,	0x58d5,	0x495c,	0x3de3,	0x2c6a,	0x1ef1,	0x0f78
};

/*
 * Calculate a new FCS given the current FCS and the new data.
 */
u_int16_t
pppfcs(u_int16_t fcs, u_char *cp, int len)
{
    while (len--)
	fcs = PPP_FCS(fcs, *cp++);
    return (fcs);
}

/*
 * This gets called from pppoutput when a new packet is
 * put on a queue.
 */
void
pppasyncstart(struct ppp_softc *sc)
{
    struct tty *tp = (struct tty *) sc->sc_devp;
    struct mbuf *m;
    int len;
    u_char *start, *stop, *cp;
    int n, ndone, done, idle;
    struct mbuf *m2;
    int s;

    idle = 0;
    while (CCOUNT(&tp->t_outq) < tp->t_hiwat) {
	/*
	 * See if we have an existing packet partly sent.
	 * If not, get a new packet and start sending it.
	 */
	m = sc->sc_outm;
	if (m == NULL) {
	    /*
	     * Get another packet to be sent.
	     */
	    m = ppp_dequeue(sc);
	    if (m == NULL) {
		idle = 1;
		break;
	    }

	    /*
	     * The extra PPP_FLAG will start up a new packet, and thus
	     * will flush any accumulated garbage.  We do this whenever
	     * the line may have been idle for some time.
	     */
	    if (CCOUNT(&tp->t_outq) == 0) {
		++sc->sc_stats.ppp_obytes;
		(void) putc(PPP_FLAG, &tp->t_outq);
	    }

	    /* Calculate the FCS for the first mbuf's worth. */
	    sc->sc_outfcs = pppfcs(PPP_INITFCS, mtod(m, u_char *), m->m_len);
	}

	for (;;) {
	    start = mtod(m, u_char *);
	    len = m->m_len;
	    stop = start + len;
	    while (len > 0) {
		/*
		 * Find out how many bytes in the string we can
		 * handle without doing something special.
		 */
		for (cp = start; cp < stop; cp++)
		    if (ESCAPE_P(*cp))
			break;
		n = cp - start;
		if (n) {
		    /* NetBSD (0.9 or later), 4.3-Reno or similar. */
		    ndone = n - b_to_q(start, n, &tp->t_outq);
		    len -= ndone;
		    start += ndone;
		    sc->sc_stats.ppp_obytes += ndone;

		    if (ndone < n)
			break;	/* packet doesn't fit */
		}
		/*
		 * If there are characters left in the mbuf,
		 * the first one must be special.
		 * Put it out in a different form.
		 */
		if (len) {
		    s = spltty();
		    if (putc(PPP_ESCAPE, &tp->t_outq)) {
			splx(s);
			break;
		    }
		    if (putc(*start ^ PPP_TRANS, &tp->t_outq)) {
			(void) unputc(&tp->t_outq);
			splx(s);
			break;
		    }
		    splx(s);
		    sc->sc_stats.ppp_obytes += 2;
		    start++;
		    len--;
		}
	    }

	    /*
	     * If we didn't empty this mbuf, remember where we're up to.
	     * If we emptied the last mbuf, try to add the FCS and closing
	     * flag, and if we can't, leave sc_outm pointing to m, but with
	     * m->m_len == 0, to remind us to output the FCS and flag later.
	     */
	    done = len == 0;
	    if (done && m->m_next == NULL) {
		u_char *p, *q;
		int c;
		u_char endseq[8];

		/*
		 * We may have to escape the bytes in the FCS.
		 */
		p = endseq;
		c = ~sc->sc_outfcs & 0xFF;
		if (ESCAPE_P(c)) {
		    *p++ = PPP_ESCAPE;
		    *p++ = c ^ PPP_TRANS;
		} else
		    *p++ = c;
		c = (~sc->sc_outfcs >> 8) & 0xFF;
		if (ESCAPE_P(c)) {
		    *p++ = PPP_ESCAPE;
		    *p++ = c ^ PPP_TRANS;
		} else
		    *p++ = c;
		*p++ = PPP_FLAG;

		/*
		 * Try to output the FCS and flag.  If the bytes
		 * don't all fit, back out.
		 */
		s = spltty();
		for (q = endseq; q < p; ++q)
		    if (putc(*q, &tp->t_outq)) {
			done = 0;
			for (; q > endseq; --q)
			    unputc(&tp->t_outq);
			break;
		    }
		splx(s);
		if (done)
		    sc->sc_stats.ppp_obytes += q - endseq;
	    }

	    if (!done) {
		/* remember where we got to */
		m->m_data = start;
		m->m_len = len;
		break;
	    }

	    /* Finished with this mbuf; free it and move on. */
	    m2 = m_free(m);
	    m = m2;
	    if (m == NULL) {
		/* Finished a packet */
		break;
	    }
	    sc->sc_outfcs = pppfcs(sc->sc_outfcs, mtod(m, u_char *), m->m_len);
	}

	/*
	 * If m == NULL, we have finished a packet.
	 * If m != NULL, we've either done as much work this time
	 * as we need to, or else we've filled up the output queue.
	 */
	sc->sc_outm = m;
	if (m)
	    break;
    }

    /* Call pppstart to start output again if necessary. */
    s = spltty();
    pppstart_internal(tp, 0);

    /*
     * This timeout is needed for operation on a pseudo-tty,
     * because the pty code doesn't call pppstart after it has
     * drained the t_outq.
     */
    if (!idle && (sc->sc_flags & SC_TIMEOUT) == 0) {
	timeout_add(&sc->sc_timo, 1);
	sc->sc_flags |= SC_TIMEOUT;
    }

    splx(s);
}

/*
 * This gets called when a received packet is placed on
 * the inq.
 */
void
pppasyncctlp(struct ppp_softc *sc)
{
    struct tty *tp;
    int s;

    /* Put a placeholder byte in canq for ttpoll()/ttnread(). */
    s = spltty();
    tp = (struct tty *) sc->sc_devp;
    putc(0, &tp->t_canq);
    ttwakeup(tp);
    splx(s);
}

/*
 * Start output on async tty interface.  If the transmit queue
 * has drained sufficiently, arrange for pppasyncstart to be
 * called later.
 */
int
pppstart_internal(struct tty *tp, int force)
{
    struct ppp_softc *sc = (struct ppp_softc *) tp->t_sc;

    /*
     * If there is stuff in the output queue, send it now.
     * We are being called in lieu of ttstart and must do what it would.
     */
    if (tp->t_oproc != NULL)
	(*tp->t_oproc)(tp);

    /*
     * If the transmit queue has drained and the tty has not hung up
     * or been disconnected from the ppp unit, then tell if_ppp.c that
     * we need more output.
     */
    if ((CCOUNT(&tp->t_outq) < tp->t_lowat || force)
	&& !((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0)
	&& sc != NULL && tp == (struct tty *) sc->sc_devp) {
	ppp_restart(sc);
    }

    return 0;
}

int
pppstart(struct tty *tp)
{
	return pppstart_internal(tp, 0);
}

/*
 * Timeout routine - try to start some more output.
 */
void
ppp_timeout(void *x)
{
    struct ppp_softc *sc = (struct ppp_softc *) x;
    struct tty *tp = (struct tty *) sc->sc_devp;
    int s;

    s = spltty();
    sc->sc_flags &= ~SC_TIMEOUT;
    pppstart_internal(tp, 1);
    splx(s);
}

/*
 * Allocate enough mbuf to handle current MRU.
 */
void
ppppkt(struct ppp_softc *sc)
{
    struct ppp_pkt **pktp, *pkt;
    int len;
    int s;

    s = spltty();
    pktp = &sc->sc_pkt;
    for (len = PKT_MAXLEN(sc); len > 0; len -= sizeof(pkt->p_buf)) {
	pkt = *pktp;
	if (pkt == NULL) {
	    pkt = pool_get(&ppp_pkts, PR_NOWAIT);
	    if (pkt == NULL)
		break;
	    PKT_NEXT(pkt) = NULL;
	    PKT_PREV(pkt) = *pktp;
	    PKT_LEN(pkt) = 0;
	    *pktp = pkt;
	}
	pktp = &PKT_NEXT(pkt);
    }
    splx(s);
}

void
ppp_pkt_free(struct ppp_pkt *pkt)
{
	struct ppp_pkt *next;

	while (pkt != NULL) {
		next = PKT_NEXT(pkt);
		pool_put(&ppp_pkts, pkt);
		pkt = next;
	}
}

/*
 * tty interface receiver interrupt.
 */
static unsigned int paritytab[8] = {
    0x96696996, 0x69969669, 0x69969669, 0x96696996,
    0x69969669, 0x96696996, 0x96696996, 0x69969669
};

int
pppinput(int c, struct tty *tp)
{
    struct ppp_softc *sc;
    struct ppp_pkt *pkt;
    int ilen, s;

    sc = (struct ppp_softc *) tp->t_sc;
    if (sc == NULL || tp != (struct tty *) sc->sc_devp)
	return 0;

    ++tk_nin;
    ++sc->sc_stats.ppp_ibytes;

    if (c & TTY_FE) {
	/* framing error or overrun on this char - abort packet */
	if (sc->sc_flags & SC_DEBUG)
	    printf("%s: bad char %x\n", sc->sc_if.if_xname, c);
	goto flush;
    }

    c &= 0xff;

    /*
     * Handle software flow control of output.
     */
    if (tp->t_iflag & IXON) {
	if (c == tp->t_cc[VSTOP] && tp->t_cc[VSTOP] != _POSIX_VDISABLE) {
	    if ((tp->t_state & TS_TTSTOP) == 0) {
		tp->t_state |= TS_TTSTOP;
		(*cdevsw[major(tp->t_dev)].d_stop)(tp, 0);
	    }
	    return 0;
	}
	if (c == tp->t_cc[VSTART] && tp->t_cc[VSTART] != _POSIX_VDISABLE) {
	    tp->t_state &= ~TS_TTSTOP;
	    if (tp->t_oproc != NULL)
		(*tp->t_oproc)(tp);
	    return 0;
	}
    }

    s = spltty();
    if (c & 0x80)
	sc->sc_flags |= SC_RCV_B7_1;
    else
	sc->sc_flags |= SC_RCV_B7_0;
    if (paritytab[c >> 5] & (1 << (c & 0x1F)))
	sc->sc_flags |= SC_RCV_ODDP;
    else
	sc->sc_flags |= SC_RCV_EVNP;
    splx(s);

    if (sc->sc_flags & SC_LOG_RAWIN)
	ppplogchar(sc, c);

    if (c == PPP_FLAG) {
	ilen = sc->sc_ilen;
	sc->sc_ilen = 0;

	if (sc->sc_rawin_count > 0)
	    ppplogchar(sc, -1);

	/*
	 * If SC_ESCAPED is set, then we've seen the packet
	 * abort sequence "}~".
	 */
	if (sc->sc_flags & (SC_FLUSH | SC_ESCAPED)
	    || (ilen > 0 && sc->sc_fcs != PPP_GOODFCS)) {
	    s = spltty();
	    sc->sc_flags |= SC_PKTLOST;	/* note the dropped packet */
	    if ((sc->sc_flags & (SC_FLUSH | SC_ESCAPED)) == 0){
		if (sc->sc_flags & SC_DEBUG)
		    printf("%s: bad fcs %x\n", sc->sc_if.if_xname,
			sc->sc_fcs);
		sc->sc_if.if_ierrors++;
		sc->sc_stats.ppp_ierrors++;
	    } else
		sc->sc_flags &= ~(SC_FLUSH | SC_ESCAPED);
	    splx(s);
	    return 0;
	}

	if (ilen < PPP_HDRLEN + PPP_FCSLEN) {
	    if (ilen) {
		if (sc->sc_flags & SC_DEBUG)
		    printf("%s: too short (%d)\n", sc->sc_if.if_xname, ilen);
		s = spltty();
		sc->sc_if.if_ierrors++;
		sc->sc_stats.ppp_ierrors++;
		sc->sc_flags |= SC_PKTLOST;
		splx(s);
	    }
	    return 0;
	}

	/*
	 * Remove FCS trailer.
	 */
	ilen -= 2;
	pkt = sc->sc_pktc;
	if (--PKT_LEN(pkt) == 0) {
            pkt = PKT_PREV(pkt);
	    sc->sc_pktc = pkt;
	}
	PKT_LEN(pkt)--;

	/* excise this mbuf chain */
	pkt = sc->sc_pkt;
	sc->sc_pkt = sc->sc_pktc = PKT_NEXT(sc->sc_pktc);
	PKT_NEXT(pkt) = NULL;

	ppppktin(sc, pkt, sc->sc_flags & SC_PKTLOST);
	if (sc->sc_flags & SC_PKTLOST) {
	    s = spltty();
	    sc->sc_flags &= ~SC_PKTLOST;
	    splx(s);
	}

	ppppkt(sc);
	return 0;
    }

    if (sc->sc_flags & SC_FLUSH) {
	if (sc->sc_flags & SC_LOG_FLUSH)
	    ppplogchar(sc, c);
	return 0;
    }

    if (c < 0x20 && (sc->sc_rasyncmap & (1 << c)))
	return 0;

    s = spltty();
    if (sc->sc_flags & SC_ESCAPED) {
	sc->sc_flags &= ~SC_ESCAPED;
	c ^= PPP_TRANS;
    } else if (c == PPP_ESCAPE) {
	sc->sc_flags |= SC_ESCAPED;
	splx(s);
	return 0;
    }
    splx(s);

    /*
     * Initialize buffer on first octet received.
     * First octet could be address or protocol (when compressing
     * address/control).
     * Second octet is control.
     * Third octet is first or second (when compressing protocol)
     * octet of protocol.
     * Fourth octet is second octet of protocol.
     */
    if (sc->sc_ilen == 0) {
	/* reset the first input mbuf */
	if (sc->sc_pkt == NULL) {
	    ppppkt(sc);
	    if (sc->sc_pkt == NULL) {
		if (sc->sc_flags & SC_DEBUG)
		    printf("%s: no input mbufs!\n", sc->sc_if.if_xname);
		goto flush;
	    }
	}
	pkt = sc->sc_pkt;
	PKT_LEN(pkt) = 0;
	sc->sc_pktc = pkt;
	sc->sc_pktp = pkt->p_buf;
	sc->sc_fcs = PPP_INITFCS;
	if (c != PPP_ALLSTATIONS) {
	    if (sc->sc_flags & SC_REJ_COMP_AC) {
		if (sc->sc_flags & SC_DEBUG)
		    printf("%s: garbage received: 0x%x (need 0xFF)\n",
			sc->sc_if.if_xname, c);
		goto flush;
	    }
	    *sc->sc_pktp++ = PPP_ALLSTATIONS;
	    *sc->sc_pktp++ = PPP_UI;
	    sc->sc_ilen += 2;
	    PKT_LEN(pkt) += 2;
	}
    }
    if (sc->sc_ilen == 1 && c != PPP_UI) {
	if (sc->sc_flags & SC_DEBUG)
	    printf("%s: missing UI (0x3), got 0x%x\n",
		sc->sc_if.if_xname, c);
	goto flush;
    }
    if (sc->sc_ilen == 2 && (c & 1) == 1) {
	/* a compressed protocol */
	*sc->sc_pktp++ = 0;
	sc->sc_ilen++;
	PKT_LEN(sc->sc_pktc)++;
    }
    if (sc->sc_ilen == 3 && (c & 1) == 0) {
	if (sc->sc_flags & SC_DEBUG)
	    printf("%s: bad protocol %x\n", sc->sc_if.if_xname,
		(sc->sc_pktp[-1] << 8) + c);
	goto flush;
    }

    /* packet beyond configured mru? */
    if (++sc->sc_ilen > PKT_MAXLEN(sc)) {
	if (sc->sc_flags & SC_DEBUG)
	    printf("%s: packet too big\n", sc->sc_if.if_xname);
	goto flush;
    }

    /* is this packet full? */
    pkt = sc->sc_pktc;
    if (PKT_LEN(pkt) >= sizeof(pkt->p_buf)) {
	if (PKT_NEXT(pkt) == NULL) {
	    ppppkt(sc);
	    if (PKT_NEXT(pkt) == NULL) {
		if (sc->sc_flags & SC_DEBUG)
		    printf("%s: too few input packets!\n", sc->sc_if.if_xname);
		goto flush;
	    }
	}
	sc->sc_pktc = pkt = PKT_NEXT(pkt);
	PKT_LEN(pkt) = 0;
	sc->sc_pktp = pkt->p_buf;
    }

    ++PKT_LEN(pkt);
    *sc->sc_pktp++ = c;
    sc->sc_fcs = PPP_FCS(sc->sc_fcs, c);
    return 0;

 flush:
    if (!(sc->sc_flags & SC_FLUSH)) {
	s = spltty();
	sc->sc_if.if_ierrors++;
	sc->sc_stats.ppp_ierrors++;
	sc->sc_flags |= SC_FLUSH;
	splx(s);
	if (sc->sc_flags & SC_LOG_FLUSH)
	    ppplogchar(sc, c);
    }
    return 0;
}

#define MAX_DUMP_BYTES	128

void
ppplogchar(struct ppp_softc *sc, int c)
{
    if (c >= 0)
	sc->sc_rawin[sc->sc_rawin_count++] = c;
    if (sc->sc_rawin_count >= sizeof(sc->sc_rawin)
	|| (c < 0 && sc->sc_rawin_count > 0)) {
	printf("%s input: ", sc->sc_if.if_xname);
	pppdumpb(sc->sc_rawin, sc->sc_rawin_count);
	sc->sc_rawin_count = 0;
    }
}

void
pppdumpb(u_char *b, int l)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    static char digits[] = "0123456789abcdef";

    while (l--) {
	if (bp >= buf + sizeof(buf) - 3) {
	    *bp++ = '>';
	    break;
	}
	*bp++ = digits[*b >> 4]; /* convert byte to ascii hex */
	*bp++ = digits[*b++ & 0xf];
	*bp++ = ' ';
    }

    *bp = 0;
    printf("%s\n", buf);
}

#endif	/* NPPP > 0 */
@


1.45
log
@Stop mentioning splsoftnet() in comments, it's almost history.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.44 2016/09/15 02:00:18 dlg Exp $	*/
d6 1
a6 1
 * 	       tty devices.
@


1.44
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.43 2016/01/25 18:47:00 stefan Exp $	*/
d486 1
a486 1
 * put on a queue, at splsoftnet.
d669 1
a669 1
 * the inq, at splsoftnet.
d688 1
a688 1
 * called later at splsoftnet.
@


1.43
log
@Convert to uiomove(). Diff from Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.42 2016/01/14 09:44:08 sf Exp $	*/
d176 2
a177 2
	pool_init(&ppp_pkts, sizeof(struct ppp_pkt), 0, 0, 0, "ppppkts", NULL);
	pool_setipl(&ppp_pkts, IPL_TTY); /* IPL_SOFTTTY */
@


1.42
log
@Increase buffer sizes and watermarks for tty and ppp

Use 115200 the default speed for buffer sizing in ttymalloc(). A lot
of devices call ttymalloc(0) so this affects quite a few of them.

Increases the buffer size for 9600 < baud <= 115200 from 1k to 4k.

Make ppp use the lo/hi watermarks from the tty layer which are
adjusted according to speed + buffer size. The previous fixed values
of 100 and 400 were way too small

Make pty call ttymalloc() with baud == 1000000, which is the common
value used in the tree for "fast".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.41 2015/12/21 21:49:02 sf Exp $	*/
d321 1
a321 1
	if ((error = uiomovei(mtod(m, u_char *), m->m_len, uio)) != 0)
d336 2
a337 1
    int len, error;
d362 1
a362 1
	if ((error = uiomovei(mtod(m, u_char *), len, uio)) != 0) {
@


1.41
log
@Move ppp, nmea, endrun, and msts prototypes to tty.h

Fix inconsistent arguments for pppopen/pppclose/pppstart.
Use passed in argument p in pppopen instead of curproc.

"Looks good to me" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.40 2015/12/05 10:07:55 tedu Exp $	*/
a157 3
#define PPP_LOWAT	100	/* Process more output when < LOWAT on queue */
#define	PPP_HIWAT	400	/* Don't start a new packet if HIWAT on queue */

d499 1
a499 1
    while (CCOUNT(&tp->t_outq) < PPP_HIWAT) {
d706 1
a706 1
    if ((CCOUNT(&tp->t_outq) < PPP_LOWAT || force)
@


1.40
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.39 2015/11/24 13:37:16 mpi Exp $	*/
d130 1
a130 8
int	pppopen(dev_t dev, struct tty *tp);
int	pppclose(struct tty *tp, int flag);
int	pppread(struct tty *tp, struct uio *uio, int flag);
int	pppwrite(struct tty *tp, struct uio *uio, int flag);
int	ppptioctl(struct tty *tp, u_long cmd, caddr_t data, int flag,
		       struct proc *);
int	pppinput(int c, struct tty *tp);
int	pppstart(struct tty *tp, int);
d167 1
a167 1
pppopen(dev_t dev, struct tty *tp)
a168 1
    struct proc *p = curproc;		/* XXX */
d233 1
a233 1
pppclose(struct tty *tp, int flag)
d654 1
a654 1
    pppstart(tp, 0);
d693 1
a693 1
pppstart(struct tty *tp, int force)
d718 6
d736 1
a736 1
    pppstart(tp, 1);
@


1.39
log
@No need for <net/if_types.h>

As a bonus this removes a "#if NCARP > 0", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.38 2015/09/13 17:53:44 mpi Exp $	*/
a172 1
/* ARGSUSED */
a389 1
/* ARGSUSED */
@


1.38
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.37 2015/09/12 20:26:07 mpi Exp $	*/
a117 1
#include <net/if_types.h>
@


1.37
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.36 2015/07/15 22:16:42 deraadt Exp $	*/
d384 1
a384 1
    return if_output(&sc->sc_if, m0, &dst, NULL);
@


1.36
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.35 2015/07/08 07:21:50 mpi Exp $	*/
d384 1
a384 1
    return ((*sc->sc_if.if_output)(&sc->sc_if, m0, &dst, (struct rtentry *)0));
@


1.35
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.34 2015/06/16 11:09:40 mpi Exp $	*/
d272 3
a274 4
    if (sc->sc_outm) {
	m_freem(sc->sc_outm);
	sc->sc_outm = NULL;
    }
@


1.34
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.33 2015/06/03 00:50:09 dlg Exp $	*/
d645 1
a645 1
	    MFREE(m, m2);
@


1.33
log
@there's been a long standing issue in ppp on a tty/serial line where it allocates mbufs at IPL_SOFTTTY, which is above the IPL_NET the mbuf layer protects itself at.

recent improvements to diagnostics in pools and mbufs now panic
instead of letting these things silently corrupt.

this reworks the ppp handling in the tty layer so it has its own
private pool to allocate packet memory out of. these packets get
built and then queued for softnet to process. softnet dequeues the
packet and attaches it to mbufs as external storage before handing
it on to the rest of the stack.

this was reported on bugs@@ and tested by both Walter Daugherity and
Martin van den Nieuwelaar
ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.32 2015/04/10 13:58:20 dlg Exp $	*/
d365 1
a365 1
	    m->m_pkthdr.rcvif = NULL;
@


1.32
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.31 2015/02/10 21:56:10 miod Exp $	*/
d113 2
d145 1
a145 1
void	pppgetm(struct ppp_softc *sc);
d149 2
a150 4
/*
 * Some useful mbuf macros not in mbuf.h.
 */
#define M_IS_CLUSTER(m)	((m)->m_flags & M_EXT)
d152 1
a152 7
#define M_DATASTART(m)	\
	(M_IS_CLUSTER(m) ? (m)->m_ext.ext_buf : \
	    (m)->m_flags & M_PKTHDR ? (m)->m_pktdat : (m)->m_dat)

#define M_DATASIZE(m)	\
	(M_IS_CLUSTER(m) ? (m)->m_ext.ext_size : \
	    (m)->m_flags & M_PKTHDR ? MHLEN: MLEN)
d185 10
d215 1
a215 1
    sc->sc_m = NULL;
d225 1
a225 1
    pppgetm(sc);
d276 3
a278 3
    if (sc->sc_m) {
	m_freem(sc->sc_m);
	sc->sc_m = NULL;
d443 1
a443 1
	    pppgetm(sc);
d750 1
a750 1
pppgetm(struct ppp_softc *sc)
d752 1
a752 1
    struct mbuf *m, **mp;
d757 6
a762 5
    mp = &sc->sc_m;
    for (len = sc->sc_mru + PPP_HDRLEN + PPP_FCSLEN; len > 0; ){
	if ((m = *mp) == NULL) {
	    MGETHDR(m, M_DONTWAIT, MT_DATA);
	    if (m == NULL)
d764 4
a767 2
	    *mp = m;
	    MCLGET(m, M_DONTWAIT);
d769 1
a769 2
	len -= M_DATASIZE(m);
	mp = &m->m_next;
d774 12
d798 1
a798 1
    struct mbuf *m;
d891 1
a891 1
	 * Remove FCS trailer.  Somewhat painful...
d894 4
a897 4
	if (--sc->sc_mc->m_len == 0) {
	    for (m = sc->sc_m; m->m_next != sc->sc_mc; m = m->m_next)
		;
	    sc->sc_mc = m;
d899 1
a899 1
	sc->sc_mc->m_len--;
d902 3
a904 3
	m = sc->sc_m;
	sc->sc_m = sc->sc_mc->m_next;
	sc->sc_mc->m_next = NULL;
d906 1
a906 1
	ppppktin(sc, m, sc->sc_flags & SC_PKTLOST);
d913 1
a913 1
	pppgetm(sc);
d948 3
a950 3
	if (sc->sc_m == NULL) {
	    pppgetm(sc);
	    if (sc->sc_m == NULL) {
d956 4
a959 5
	m = sc->sc_m;
	m->m_len = 0;
	m->m_data = M_DATASTART(sc->sc_m);
	sc->sc_mc = m;
	sc->sc_mp = mtod(m, char *);
d968 2
a969 2
	    *sc->sc_mp++ = PPP_ALLSTATIONS;
	    *sc->sc_mp++ = PPP_UI;
d971 1
a971 1
	    m->m_len += 2;
d982 1
a982 1
	*sc->sc_mp++ = 0;
d984 1
a984 1
	sc->sc_mc->m_len++;
d989 1
a989 1
		(sc->sc_mp[-1] << 8) + c);
d994 1
a994 1
    if (++sc->sc_ilen > sc->sc_mru + PPP_HDRLEN + PPP_FCSLEN) {
d1000 6
a1005 6
    /* is this mbuf full? */
    m = sc->sc_mc;
    if (M_TRAILINGSPACE(m) <= 0) {
	if (m->m_next == NULL) {
	    pppgetm(sc);
	    if (m->m_next == NULL) {
d1007 1
a1007 1
		    printf("%s: too few input mbufs!\n", sc->sc_if.if_xname);
d1011 3
a1013 4
	sc->sc_mc = m = m->m_next;
	m->m_len = 0;
	m->m_data = M_DATASTART(m);
	sc->sc_mp = mtod(m, char *);
d1016 2
a1017 2
    ++m->m_len;
    *sc->sc_mp++ = c;
@


1.31
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.30 2014/12/05 15:50:04 mpi Exp $	*/
d306 3
a308 1
	if (!IF_IS_EMPTY(&sc->sc_inq))
a327 3

    /* Get the packet from the input queue */
    IF_DEQUEUE(&sc->sc_inq, m0);
@


1.30
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.29 2014/09/15 19:08:21 miod Exp $	*/
d332 1
a332 1
	if ((error = uiomove(mtod(m, u_char *), m->m_len, uio)) != 0)
d372 1
a372 1
	if ((error = uiomove(mtod(m, u_char *), len, uio)) != 0) {
@


1.29
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.28 2014/07/22 11:06:10 mpi Exp $	*/
d115 1
@


1.28
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.27 2014/04/19 12:18:35 henning Exp $	*/
a103 1
#include <sys/dkstat.h>
@


1.27
log
@remove very questionable altq "optimization" - claudio and I can't
convince ourselves that that was right to begin with. anyway, begone.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.25 2012/03/28 19:39:33 claudio Exp $	*/
a119 1
#include <netinet/in_systm.h>
@


1.26
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@a713 9
#ifdef ALTQ
    /*
     * if ALTQ is enabled, don't invoke NETISR_PPP.
     * pppintr() could loop without doing anything useful
     * under rate-limiting.
     */
    if (ALTQ_IS_ENABLED(&sc->sc_if.if_snd))
	return 0;
#endif
@


1.25
log
@More p_pid to p_p->ps_pid updates. OK deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.24 2012/01/11 16:22:33 dhill Exp $	*/
d106 1
@


1.24
log
@ansify and de'register some prototypes

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.23 2011/07/06 02:51:16 henning Exp $	*/
d201 1
a201 1
    if ((sc = pppalloc(p->p_pid)) == NULL) {
@


1.23
log
@use IF_IS_EMPTY istead of mucking if ifqueue internals
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.22 2011/07/05 21:11:36 guenther Exp $	*/
d182 1
a182 3
pppopen(dev, tp)
    dev_t dev;
    struct tty *tp;
d239 1
a239 3
pppclose(tp, flag)
    struct tty *tp;
    int flag;
d263 1
a263 2
pppasyncrelinq(sc)
    struct ppp_softc *sc;
d287 1
a287 4
pppread(tp, uio, flag)
    struct tty *tp;
    struct uio *uio;
    int flag;
d342 1
a342 4
pppwrite(tp, uio, flag)
    struct tty *tp;
    struct uio *uio;
    int flag;
d392 1
a392 6
ppptioctl(tp, cmd, data, flag, p)
    struct tty *tp;
    u_long cmd;
    caddr_t data;
    int flag;
    struct proc *p;
d488 1
a488 4
pppfcs(fcs, cp, len)
    u_int16_t fcs;
    u_char *cp;
    int len;
d500 1
a500 2
pppasyncstart(sc)
    struct ppp_softc *sc;
d683 1
a683 2
pppasyncctlp(sc)
    struct ppp_softc *sc;
d702 1
a702 3
pppstart(tp, force)
    struct tty *tp;
    int force;
d740 1
a740 2
ppp_timeout(x)
    void *x;
d756 1
a756 2
pppgetm(sc)
    struct ppp_softc *sc;
d787 1
a787 3
pppinput(c, tp)
    int c;
    struct tty *tp;
d1031 1
a1031 3
ppplogchar(sc, c)
    struct ppp_softc *sc;
    int c;
d1044 1
a1044 3
pppdumpb(b, l)
    u_char *b;
    int l;
@


1.22
log
@Revert henning's commit-n-run that broke the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.20 2003/12/10 07:22:42 itojun Exp $	*/
d314 1
a314 1
	if (sc->sc_inq.ifq_head != NULL)
@


1.21
log
@IFQ_IS_EMPTY instead of fiddling with ifqueue internals
isn't it awesome that 5 out of 6 cases of this crap were in the various ppp
implementations? ok claudio ryan
the 6th to be fixed when we return from MEC
@
text
@d314 1
a314 1
	if (!IFQ_IS_EMPTY(sc->sc_inq))
@


1.20
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.19 2003/09/23 16:51:13 millert Exp $	*/
d314 1
a314 1
	if (sc->sc_inq.ifq_head != NULL)
@


1.19
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.18 2003/09/18 19:32:20 tedu Exp $	*/
d184 1
a184 1
    register struct tty *tp;
d187 1
a187 1
    register struct ppp_softc *sc;
d245 1
a245 1
    register struct ppp_softc *sc;
d293 1
a293 1
    register struct tty *tp;
d297 1
a297 1
    register struct ppp_softc *sc = (struct ppp_softc *)tp->t_sc;
d299 1
a299 1
    register int s;
d351 1
a351 1
    register struct tty *tp;
d355 1
a355 1
    register struct ppp_softc *sc = (struct ppp_softc *)tp->t_sc;
d505 3
a507 3
    register u_int16_t fcs;
    register u_char *cp;
    register int len;
d520 1
a520 1
    register struct ppp_softc *sc;
d522 4
a525 4
    register struct tty *tp = (struct tty *) sc->sc_devp;
    register struct mbuf *m;
    register int len;
    register u_char *start, *stop, *cp;
d724 1
a724 1
    register struct tty *tp;
d727 1
a727 1
    register struct ppp_softc *sc = (struct ppp_softc *) tp->t_sc;
d781 1
a781 1
    register struct ppp_softc *sc;
d814 1
a814 1
    register struct tty *tp;
d816 1
a816 1
    register struct ppp_softc *sc;
@


1.18
log
@comment spelling, from jonathon gray
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.17 2003/08/15 20:32:19 tedu Exp $	*/
d709 1
a709 1
    /* Put a placeholder byte in canq for ttselect()/ttnread(). */
@


1.17
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.16 2003/03/09 12:03:22 kjc Exp $	*/
d173 1
a173 1
#define	PPP_HIWAT	400	/* Don't start a new packet if HIWAT on que */
@


1.16
log
@use MGETHDR instead of MGET for the first mbuf.
altq expects struct pkthdr in a mbuf chain.
this fixes a panic caused by uninitialized m_pkthdr.tags when altq is
enabled on ppp.
also, initialize m_pkthdr.len and m_pkthdr.rcvif as a caller of
MGETHDR is supposed to do.

report and test by matthieu@@
ok deraadt@@, henning@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.15 2002/07/01 19:31:35 deraadt Exp $	*/
d190 1
a190 1
    if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d419 1
a419 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d429 1
a429 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d439 1
a439 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.15
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.14 2002/03/14 01:27:10 millert Exp $	*/
d370 6
a375 1
	MGET(m, M_WAIT, MT_DATA);
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.13 2002/02/13 08:14:48 kjc Exp $	*/
d8 1
a8 2
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
d10 35
a44 18
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Drew D. Perkins
 * Carnegie Mellon University
 * 4910 Forbes Ave.
 * Pittsburgh, PA 15213
 * (412) 268-8576
 * ddp@@andrew.cmu.edu
@


1.13
log
@sync with KAME.

make altq actually work with kernl ppp.
add if_start for the altq case to kick transmission.
don't call ppp_restart() to prevent useless interrupt
loop under rate-limiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.12 2001/06/15 03:38:34 itojun Exp $	*/
d113 17
a129 17
int	pppopen __P((dev_t dev, struct tty *tp));
int	pppclose __P((struct tty *tp, int flag));
int	pppread __P((struct tty *tp, struct uio *uio, int flag));
int	pppwrite __P((struct tty *tp, struct uio *uio, int flag));
int	ppptioctl __P((struct tty *tp, u_long cmd, caddr_t data, int flag,
		       struct proc *));
int	pppinput __P((int c, struct tty *tp));
int	pppstart __P((struct tty *tp, int));

u_int16_t pppfcs __P((u_int16_t fcs, u_char *cp, int len));
void	pppasyncstart __P((struct ppp_softc *));
void	pppasyncctlp __P((struct ppp_softc *));
void	pppasyncrelinq __P((struct ppp_softc *));
void	ppp_timeout __P((void *));
void	pppgetm __P((struct ppp_softc *sc));
void	pppdumpb __P((u_char *b, int l));
void	ppplogchar __P((struct ppp_softc *, int));
@


1.12
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.11 2001/05/16 12:53:34 ho Exp $	*/
d715 9
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.12 2001/06/15 03:38:34 itojun Exp $	*/
d113 17
a129 17
int	pppopen(dev_t dev, struct tty *tp);
int	pppclose(struct tty *tp, int flag);
int	pppread(struct tty *tp, struct uio *uio, int flag);
int	pppwrite(struct tty *tp, struct uio *uio, int flag);
int	ppptioctl(struct tty *tp, u_long cmd, caddr_t data, int flag,
		       struct proc *);
int	pppinput(int c, struct tty *tp);
int	pppstart(struct tty *tp, int);

u_int16_t pppfcs(u_int16_t fcs, u_char *cp, int len);
void	pppasyncstart(struct ppp_softc *);
void	pppasyncctlp(struct ppp_softc *);
void	pppasyncrelinq(struct ppp_softc *);
void	ppp_timeout(void *);
void	pppgetm(struct ppp_softc *sc);
void	pppdumpb(u_char *b, int l);
void	ppplogchar(struct ppp_softc *, int);
a714 9
#ifdef ALTQ
    /*
     * if ALTQ is enabled, don't invoke NETISR_PPP.
     * pppintr() could loop without doing anything useful
     * under rate-limiting.
     */
    if (ALTQ_IS_ENABLED(&sc->sc_if.if_snd))
	return 0;
#endif
@


1.12.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.12.4.1 2002/06/11 03:30:46 art Exp $	*/
d8 2
a9 1
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
d11 18
a28 35
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.12.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d370 1
a370 6
	if (mp == &m0) {
	    MGETHDR(m, M_WAIT, MT_DATA);
	    m->m_pkthdr.len = uio->uio_resid - PPP_HDRLEN;
	    m->m_pkthdr.rcvif = NULL;
	} else
	    MGET(m, M_WAIT, MT_DATA);
@


1.11
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.10 2001/03/09 14:56:44 aaron Exp $	*/
a537 1
	    sc->sc_if.if_lastchange = time;
@


1.10
log
@Remove two unnecessary splx(). This was missed somewhere along the way, since
this was done long ago in NetBSD during an update to ppp-2.3b4.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.9 2000/06/30 01:05:19 art Exp $	*/
d355 1
a355 4
	if ((*mp = m) == NULL) {
	    m_freem(m0);
	    return (ENOBUFS);
	}
@


1.9
log
@Convert to use new timeout API.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.8 1999/07/04 20:39:28 deraadt Exp $	*/
d792 1
a792 1
    int ilen, s = 0;
a1013 1
    splx(s);
a1025 1
    splx(s);
@


1.8
log
@fix unsigned without a size-type
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.7 1997/09/05 04:27:03 millert Exp $	*/
d195 1
d266 1
a266 1
	untimeout(ppp_timeout, (void *) sc);
d674 1
a674 1
	timeout(ppp_timeout, (void *) sc, 1);
@


1.8.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.10 2001/03/09 14:56:44 aaron Exp $	*/
a194 1
    timeout_set(&sc->sc_timo, ppp_timeout, sc);
d265 1
a265 1
	timeout_del(&sc->sc_timo);
d673 1
a673 1
	timeout_add(&sc->sc_timo, 1);
d791 1
a791 1
    int ilen, s;
d1013 1
d1026 1
@


1.8.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.8.4.1 2001/05/14 22:40:03 niklas Exp $	*/
d355 4
a358 1
	*mp = m;
d541 1
@


1.8.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a714 9
#ifdef ALTQ
    /*
     * if ALTQ is enabled, don't invoke NETISR_PPP.
     * pppintr() could loop without doing anything useful
     * under rate-limiting.
     */
    if (ALTQ_IS_ENABLED(&sc->sc_if.if_snd))
	return 0;
#endif
@


1.8.4.4
log
@Merge in -current from roughly a week ago
@
text
@d113 8
a120 8
int	pppopen(dev_t dev, struct tty *tp);
int	pppclose(struct tty *tp, int flag);
int	pppread(struct tty *tp, struct uio *uio, int flag);
int	pppwrite(struct tty *tp, struct uio *uio, int flag);
int	ppptioctl(struct tty *tp, u_long cmd, caddr_t data, int flag,
		       struct proc *);
int	pppinput(int c, struct tty *tp);
int	pppstart(struct tty *tp, int);
d122 8
a129 8
u_int16_t pppfcs(u_int16_t fcs, u_char *cp, int len);
void	pppasyncstart(struct ppp_softc *);
void	pppasyncctlp(struct ppp_softc *);
void	pppasyncrelinq(struct ppp_softc *);
void	ppp_timeout(void *);
void	pppgetm(struct ppp_softc *sc);
void	pppdumpb(u_char *b, int l);
void	ppplogchar(struct ppp_softc *, int);
@


1.8.4.5
log
@Sync the SMP branch with 3.3
@
text
@d8 14
a21 1
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
d23 6
a28 35
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d354 1
a354 6
	if (mp == &m0) {
	    MGETHDR(m, M_WAIT, MT_DATA);
	    m->m_pkthdr.len = uio->uio_resid - PPP_HDRLEN;
	    m->m_pkthdr.rcvif = NULL;
	} else
	    MGET(m, M_WAIT, MT_DATA);
@


1.8.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d173 1
a173 1
#define	PPP_HIWAT	400	/* Don't start a new packet if HIWAT on queue */
d184 1
a184 1
    struct tty *tp;
d187 1
a187 1
    struct ppp_softc *sc;
d190 1
a190 1
    if ((error = suser(p, 0)) != 0)
d245 1
a245 1
    struct ppp_softc *sc;
d293 1
a293 1
    struct tty *tp;
d297 1
a297 1
    struct ppp_softc *sc = (struct ppp_softc *)tp->t_sc;
d299 1
a299 1
    int s;
d351 1
a351 1
    struct tty *tp;
d355 1
a355 1
    struct ppp_softc *sc = (struct ppp_softc *)tp->t_sc;
d419 1
a419 1
	if ((error = suser(p, 0)) != 0)
d429 1
a429 1
	if ((error = suser(p, 0)) != 0)
d439 1
a439 1
	if ((error = suser(p, 0)) != 0)
d505 3
a507 3
    u_int16_t fcs;
    u_char *cp;
    int len;
d520 1
a520 1
    struct ppp_softc *sc;
d522 4
a525 4
    struct tty *tp = (struct tty *) sc->sc_devp;
    struct mbuf *m;
    int len;
    u_char *start, *stop, *cp;
d709 1
a709 1
    /* Put a placeholder byte in canq for ttpoll()/ttnread(). */
d724 1
a724 1
    struct tty *tp;
d727 1
a727 1
    struct ppp_softc *sc = (struct ppp_softc *) tp->t_sc;
d781 1
a781 1
    struct ppp_softc *sc;
d814 1
a814 1
    struct tty *tp;
d816 1
a816 1
    struct ppp_softc *sc;
@


1.7
log
@Minor changes from ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.6 1997/01/15 03:19:24 kstailey Exp $	*/
d779 1
a779 1
static unsigned paritytab[8] = {
@


1.6
log
@prevent warning:
ppp_tty.c:790: warning: `s' might be used uninitialized in this function
@
text
@d1 2
a2 2
/*	$OpenBSD: ppp_tty.c,v 1.4 1996/05/10 12:31:13 deraadt Exp $	*/
/*	$NetBSD: ppp_tty.c,v 1.6 1996/05/07 02:40:51 thorpej Exp $	*/
d120 1
a120 1
int	pppstart __P((struct tty *tp));
d122 8
a129 8
static u_int16_t pppfcs __P((u_int16_t fcs, u_char *cp, int len));
static void	pppasyncstart __P((struct ppp_softc *));
static void	pppasyncctlp __P((struct ppp_softc *));
static void	pppasyncrelinq __P((struct ppp_softc *));
static void	ppp_timeout __P((void *));
static void	pppgetm __P((struct ppp_softc *sc));
static void	pppdumpb __P((u_char *b, int l));
static void	ppplogchar __P((struct ppp_softc *, int));
d156 1
a156 1
#define PPP_LOWAT     100     /* Process more output when < LOWAT on queue */
d249 1
a249 1
static void
d374 1
a374 1
    return (pppoutput(&sc->sc_if, m0, &dst, (struct rtentry *)0));
d484 1
a484 1
static u_int16_t
d499 1
a499 1
static void
d510 1
a510 1
                
d513 148
a660 146
        /*
         * See if we have an existing packet partly sent.
         * If not, get a new packet and start sending it.
         */
        m = sc->sc_outm;
        if (m == NULL) {
            /*
             * Get another packet to be sent.
             */
            m = ppp_dequeue(sc); 
            if (m == NULL) {
                idle = 1;
                break;
            }
 
            /*
             * The extra PPP_FLAG will start up a new packet, and thus
             * will flush any accumulated garbage.  We do this whenever
             * the line may have been idle for some time.
             */
            if (CCOUNT(&tp->t_outq) == 0) {
                ++sc->sc_stats.ppp_obytes;
                (void) putc(PPP_FLAG, &tp->t_outq);
            }
   
            /* Calculate the FCS for the first mbuf's worth. */
            sc->sc_outfcs = pppfcs(PPP_INITFCS, mtod(m, u_char *), m->m_len);
            sc->sc_if.if_lastchange = time;
        }  
        
        for (;;) {
            start = mtod(m, u_char *);
            len = m->m_len;
            stop = start + len;
            while (len > 0) {    
                /*
                 * Find out how many bytes in the string we can
                 * handle without doing something special.
                 */
                for (cp = start; cp < stop; cp++)
                    if (ESCAPE_P(*cp))
                        break;
                n = cp - start;
                if (n) {
                    /* NetBSD (0.9 or later), 4.3-Reno or similar. */
                    ndone = n - b_to_q(start, n, &tp->t_outq);
                    len -= ndone;
                    start += ndone;
                    sc->sc_stats.ppp_obytes += ndone;
   
                    if (ndone < n)
                        break;  /* packet doesn't fit */
                }
                /*
                 * If there are characters left in the mbuf,
                 * the first one must be special.
                 * Put it out in a different form.
                 */
                if (len) {
                    s = spltty();
                    if (putc(PPP_ESCAPE, &tp->t_outq))
                        break;
                    if (putc(*start ^ PPP_TRANS, &tp->t_outq)) {
                        (void) unputc(&tp->t_outq);
                        splx(s);
                        break;
                    }
                    splx(s);   
                    sc->sc_stats.ppp_obytes += 2;
                    start++;
                    len--;
                }
            }
                    
            /*
             * If we didn't empty this mbuf, remember where we're up to.
             * If we emptied the last mbuf, try to add the FCS and closing
             * flag, and if we can't, leave sc_outm pointing to m, but with
             * m->m_len == 0, to remind us to output the FCS and flag later.
             */
            done = len == 0;
            if (done && m->m_next == NULL) {
                u_char *p, *q;
                int c;
                u_char endseq[8];
                    
                /*
                 * We may have to escape the bytes in the FCS.  
                 */
                p = endseq;
                c = ~sc->sc_outfcs & 0xFF;
                if (ESCAPE_P(c)) {
                    *p++ = PPP_ESCAPE;
                    *p++ = c ^ PPP_TRANS;
                } else
                    *p++ = c;
                c = (~sc->sc_outfcs >> 8) & 0xFF;
                if (ESCAPE_P(c)) {
                    *p++ = PPP_ESCAPE;
                    *p++ = c ^ PPP_TRANS;
                } else
                    *p++ = c;
                *p++ = PPP_FLAG;
             
                /*
                 * Try to output the FCS and flag.  If the bytes
                 * don't all fit, back out. 
                 */
                s = spltty();
                for (q = endseq; q < p; ++q)
                    if (putc(*q, &tp->t_outq)) {
                        done = 0;
                        for (; q > endseq; --q)
                            unputc(&tp->t_outq);
                        break;
                    }
                splx(s);
                if (done)
                    sc->sc_stats.ppp_obytes += q - endseq;
            }
                    
            if (!done) {
                /* remember where we got to */
                m->m_data = start;
                m->m_len = len;
                break;
            }
                
            /* Finished with this mbuf; free it and move on. */
            MFREE(m, m2);
            m = m2;
            if (m == NULL) {
                /* Finished a packet */
                break;
            }
            sc->sc_outfcs = pppfcs(sc->sc_outfcs, mtod(m, u_char *), m->m_len);
        }
                        
        /*
         * If m == NULL, we have finished a packet.
         * If m != NULL, we've either done as much work this time
         * as we need to, or else we've filled up the output queue.
         */
        sc->sc_outm = m;
        if (m)
            break;  
d662 1
a662 1
                
d665 4
a668 4
    pppstart(tp);
             
    /*          
     * This timeout is needed for operation on a pseudo-tty,   
d673 2
a674 2
        timeout(ppp_timeout, (void *) sc, 1);
        sc->sc_flags |= SC_TIMEOUT;
d676 2
a677 3
         
    splx(s);            
          
d684 1
a684 1
static void
d700 4
a703 4
 * Start output on async tty interface.  Get another datagram
 * to send from the interface queue and start sending it.
 * Called at spltty or higher.
 */   
d705 1
a705 1
pppstart(tp)
d707 1
d710 1
a710 1
        
d716 1
a716 1
        (*tp->t_oproc)(tp);
d723 4
a726 4
    if (CCOUNT(&tp->t_outq) < PPP_LOWAT
        && !((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0)
        && sc != NULL && tp == (struct tty *) sc->sc_devp) {
        ppp_restart(sc);
d728 1
a728 1
 
d730 1
a730 2
}  

d735 1
a735 1
static void
d745 1
a745 1
    pppstart(tp);
d752 1
a752 1
static void
d837 1
a838 1
    splx(s);
d846 1
a846 1
	if (sc->sc_rawin_count > 0) 
d860 1
a860 1
			   sc->sc_fcs);
d873 1
d877 1
a877 1
	        splx(s);
d899 2
a900 2
        if (sc->sc_flags & SC_PKTLOST) {
            s = spltty();
d915 1
a915 1
    if (c < 0x20 && (sc->sc_rasyncmap & (1 << c))) {
a916 1
    }
d958 1
a958 1
			   sc->sc_if.if_xname, c);
d970 1
a970 1
		   sc->sc_if.if_xname, c);
d982 1
a982 1
		   (sc->sc_mp[-1] << 8) + c);
d1032 1
a1032 1
static void
d1047 1
a1047 1
static void
@


1.5
log
@Kernel changes for ppp2.3a4.
@
text
@d790 1
a790 1
    int ilen, s;
@


1.4
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp_tty.c,v 1.2 1996/03/03 21:07:12 niklas Exp $	*/
d156 1
d504 5
d510 152
a661 1

d664 13
a676 1
    splx(s);
d702 1
a702 1
 */
d708 1
a708 156
    register struct mbuf *m;
    register int len;
    register u_char *start, *stop, *cp;
    int n, ndone, done, idle;
    struct mbuf *m2;

    if (((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0)
	|| sc == NULL || tp != (struct tty *) sc->sc_devp) {
	if (tp->t_oproc != NULL)
	    (*tp->t_oproc)(tp);
	return 0;
    }

    idle = 0;
    while (CCOUNT(&tp->t_outq) < PPP_HIWAT) {
	/*
	 * See if we have an existing packet partly sent.
	 * If not, get a new packet and start sending it.
	 */
	m = sc->sc_outm;
	if (m == NULL) {
	    /*
	     * Get another packet to be sent.
	     */
	    m = ppp_dequeue(sc);
	    if (m == NULL) {
		idle = 1;
		break;
	    }

	    /*
	     * The extra PPP_FLAG will start up a new packet, and thus
	     * will flush any accumulated garbage.  We do this whenever
	     * the line may have been idle for some time.
	     */
	    if (CCOUNT(&tp->t_outq) == 0) {
		++sc->sc_stats.ppp_obytes;
		(void) putc(PPP_FLAG, &tp->t_outq);
	    }

	    /* Calculate the FCS for the first mbuf's worth. */
	    sc->sc_outfcs = pppfcs(PPP_INITFCS, mtod(m, u_char *), m->m_len);
	    sc->sc_if.if_lastchange = time;
	}

	for (;;) {
	    start = mtod(m, u_char *);
	    len = m->m_len;
	    stop = start + len;
	    while (len > 0) {
		/*
		 * Find out how many bytes in the string we can
		 * handle without doing something special.
		 */
		for (cp = start; cp < stop; cp++)
		    if (ESCAPE_P(*cp))
			break;
		n = cp - start;
		if (n) {
		    /* NetBSD (0.9 or later), 4.3-Reno or similar. */
		    ndone = n - b_to_q(start, n, &tp->t_outq);
		    len -= ndone;
		    start += ndone;
		    sc->sc_stats.ppp_obytes += ndone;

		    if (ndone < n)
			break;	/* packet doesn't fit */
		}
		/*
		 * If there are characters left in the mbuf,
		 * the first one must be special..
		 * Put it out in a different form.
		 */
		if (len) {
		    if (putc(PPP_ESCAPE, &tp->t_outq))
			break;
		    if (putc(*start ^ PPP_TRANS, &tp->t_outq)) {
			(void) unputc(&tp->t_outq);
			break;
		    }
		    sc->sc_stats.ppp_obytes += 2;
		    start++;
		    len--;
		}
	    }

	    /*
	     * If we didn't empty this mbuf, remember where we're up to.
	     * If we emptied the last mbuf, try to add the FCS and closing
	     * flag, and if we can't, leave sc_outm pointing to m, but with
	     * m->m_len == 0, to remind us to output the FCS and flag later.
	     */
	    done = len == 0;
	    if (done && m->m_next == NULL) {
		u_char *p, *q;
		int c;
		u_char endseq[8];

		/*
		 * We may have to escape the bytes in the FCS.
		 */
		p = endseq;
		c = ~sc->sc_outfcs & 0xFF;
		if (ESCAPE_P(c)) {
		    *p++ = PPP_ESCAPE;
		    *p++ = c ^ PPP_TRANS;
		} else
		    *p++ = c;
		c = (~sc->sc_outfcs >> 8) & 0xFF;
		if (ESCAPE_P(c)) {
		    *p++ = PPP_ESCAPE;
		    *p++ = c ^ PPP_TRANS;
		} else
		    *p++ = c;
		*p++ = PPP_FLAG;

		/*
		 * Try to output the FCS and flag.  If the bytes
		 * don't all fit, back out.
		 */
		for (q = endseq; q < p; ++q)
		    if (putc(*q, &tp->t_outq)) {
			done = 0;
			for (; q > endseq; --q)
			    unputc(&tp->t_outq);
			break;
		    }
		sc->sc_stats.ppp_obytes += q - endseq;
	    }

	    if (!done) {
		/* remember where we got to */
		m->m_data = start;
		m->m_len = len;
		break;
	    }

	    /* Finished with this mbuf; free it and move on. */
	    MFREE(m, m2);
	    m = m2;
	    if (m == NULL) {
		/* Finished a packet */
		break;
	    }
	    sc->sc_outfcs = pppfcs(sc->sc_outfcs, mtod(m, u_char *), m->m_len);
	}

	/*
	 * Here we have either finished a packet (m == NULL)
	 * or filled up the output queue (m != NULL).
	 */
	sc->sc_outm = m;
	if (m)
	    break;
    }

d714 1
a714 1
	(*tp->t_oproc)(tp);
d717 3
a719 3
     * This timeout is needed for operation on a pseudo-tty,
     * because the pty code doesn't call pppstart after it has
     * drained the t_outq.
d721 4
a724 3
    if (!idle && (sc->sc_flags & SC_TIMEOUT) == 0) {
	timeout(ppp_timeout, (void *) sc, 1);
	sc->sc_flags |= SC_TIMEOUT;
d726 3
a729 2
    return 0;
}
a795 1
    s = spltty();		/* should be unnecessary */
d827 1
d837 1
d854 1
d875 1
a876 1
	    splx(s);
d897 5
a901 1
	sc->sc_flags &= ~SC_PKTLOST;
a903 1
	splx(s);
a909 1
	splx(s);
a913 1
	splx(s);
d917 1
d926 1
d1017 1
d1021 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: ppp_tty.c,v 1.5 1996/03/15 02:28:10 paulus Exp $	*/
d787 1
a787 1
	    printf("ppp%d: bad char %x\n", sc->sc_if.if_unit, c);
d840 1
a840 1
		    printf("ppp%d: bad fcs %x\n", sc->sc_if.if_unit,
d853 1
a853 1
		    printf("ppp%d: too short (%d)\n", sc->sc_if.if_unit, ilen);
d922 1
a922 1
		    printf("ppp%d: no input mbufs!\n", sc->sc_if.if_unit);
d935 2
a936 2
		    printf("ppp%d: garbage received: 0x%x (need 0xFF)\n",
			   sc->sc_if.if_unit, c);
d947 2
a948 2
	    printf("ppp%d: missing UI (0x3), got 0x%x\n",
		   sc->sc_if.if_unit, c);
d959 1
a959 1
	    printf("ppp%d: bad protocol %x\n", sc->sc_if.if_unit,
d967 1
a967 1
	    printf("ppp%d: packet too big\n", sc->sc_if.if_unit);
d978 1
a978 1
		    printf("ppp%d: too few input mbufs!\n", sc->sc_if.if_unit);
d1017 1
a1017 1
	printf("ppp%d input: ", sc->sc_if.if_unit);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ppp_tty.c,v 1.4 1996/02/13 22:00:30 christos Exp $	*/
d108 1
d231 1
a231 1
    ttywflush(tp);
d575 1
a575 1
		++sc->sc_bytessent;
d602 1
a602 1
		    sc->sc_bytessent += ndone;
d619 1
a619 1
		    sc->sc_bytessent += 2;
d666 1
a666 1
		sc->sc_bytessent += q - endseq;
a680 2
		sc->sc_if.if_opackets++;
		sc->sc_if.if_obytes = sc->sc_bytessent;
d782 1
a782 1
    ++sc->sc_bytesrcvd;
d793 19
a826 1
	sc->sc_if.if_ibytes = sc->sc_bytesrcvd;
d843 1
d855 1
d997 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ppp_tty.c,v 1.3 1995/10/05 05:55:14 mycroft Exp $	*/
d96 1
d170 1
a170 1
    int error, s, i;
d172 1
a172 1
    if (error = suser(p->p_ucred, &p->p_acflag))
a226 1
    struct mbuf *m;
d321 1
a321 1
	if (error = uiomove(mtod(m, u_char *), m->m_len, uio))
d362 1
a362 1
	if (error = uiomove(mtod(m, u_char *), len, uio)) {
d398 1
a398 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d408 1
a408 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d418 1
a418 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d541 1
a541 1
    int n, s, ndone, done, idle;
d544 1
a544 1
    if ((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0
d819 1
a819 1
	    || ilen > 0 && sc->sc_fcs != PPP_GOODFCS) {
d996 1
a996 1
	|| c < 0 && sc->sc_rawin_count > 0) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
