head	1.53;
access;
symbols
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.49.0.8
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.47.0.4
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.47.0.8
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.47.0.6
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.47.0.2
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.46.0.4
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.2
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.8
	OPENBSD_5_0:1.44.0.6
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.4
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.43.0.4
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.42.0.6
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.4
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.42.0.2
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.40.0.6
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.40.0.4
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.39.0.4
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.38
	SMP_SYNC_B:1.38
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.36.0.4
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.36
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.34
	UBC:1.31.0.4
	UBC_BASE:1.31
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.53
date	2017.07.14.16.50.41;	author tedu;	state Exp;
branches;
next	1.52;
commitid	FjZ5YsgPzJxYaSRy;

1.52
date	2017.06.26.09.17.55;	author patrick;	state Exp;
branches;
next	1.51;
commitid	Hy3mtGhkjppRz1X1;

1.51
date	2017.02.28.16.46.27;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	rmbXKt3efXwOBuCw;

1.50
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.49;
commitid	6c6qq5OdS4VVnyVM;

1.49
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.48;
commitid	bQi1IVHgugweH5gs;

1.48
date	2015.03.26.12.21.37;	author mikeb;	state Exp;
branches;
next	1.47;
commitid	GUv4gLlXi8Tx36WA;

1.47
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.45;

1.45
date	2012.03.28.19.43.21;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.43;

1.43
date	2008.10.22.23.04.45;	author mpf;	state Exp;
branches;
next	1.42;

1.42
date	2007.07.30.11.43.59;	author hshoexer;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.28.15.10.07;	author ho;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.10.16.17.05;	author ho;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.31.10.24.00;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.16.19.54.20;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.07.06.16.39;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.31.01.36.33;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.23.22.30.53;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.05.16.48.04;	author jjbg;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2001.07.03.05.16.09;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.01.08.21.15;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.01.08.15.51;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.01.07.32.37;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.08.03.58.48;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.05.02.31.34;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.05.00.17.49;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.30.11.27.34;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.30.10.49.49;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.05.00.33.46;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.19.20.10.15;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.14.00.30.58;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.28.20.03.01;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.21.19.46.10;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.04.20.50.41;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.14.18.07.29;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.14.06.23.51;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.29.19.00.14;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.21.02.38.33;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.20.04.22.45;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.19.08.38.58;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.19.03.19.39;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.23.22.42.51;	author angelos;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.12.20.05.37.47;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.07.02.23.37.33;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.03.27.21.04.18;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	99.03.05.00.58.35;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.02.25.22.17.45;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.02.25.02.48.29;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.02.24.22.36.04;	author angelos;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.40.03;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.54.16;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2004.02.19.10.57.22;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.31.4.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2003.05.19.22.29.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.53
log
@kernels don't build without MROUTING because ip_var.h only sometimes
introduces a forward decl for socket. turns out the affected file doesn't
need ip_var.h, so remove it. then move the decl to the bottom to prevent
the problem from recurring.
bug report by Nick Briggs
ok mpi
@
text
@/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.52 2017/06/26 09:17:55 patrick Exp $	*/

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Craig Metz. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/mbuf.h>
#include <sys/proc.h>
#include <netinet/ip_ipsp.h>
#include <net/pfkeyv2.h>

#if NPF > 0
#include <net/if.h>
#include <net/pfvar.h>
#endif

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

#define BITMAP_SA                      (1LL << SADB_EXT_SA)
#define BITMAP_LIFETIME_CURRENT        (1LL << SADB_EXT_LIFETIME_CURRENT)
#define BITMAP_LIFETIME_HARD           (1LL << SADB_EXT_LIFETIME_HARD)
#define BITMAP_LIFETIME_SOFT           (1LL << SADB_EXT_LIFETIME_SOFT)
#define BITMAP_ADDRESS_SRC             (1LL << SADB_EXT_ADDRESS_SRC)
#define BITMAP_ADDRESS_DST             (1LL << SADB_EXT_ADDRESS_DST)
#define BITMAP_ADDRESS_PROXY           (1LL << SADB_EXT_ADDRESS_PROXY)
#define BITMAP_KEY_AUTH                (1LL << SADB_EXT_KEY_AUTH)
#define BITMAP_KEY_ENCRYPT             (1LL << SADB_EXT_KEY_ENCRYPT)
#define BITMAP_IDENTITY_SRC            (1LL << SADB_EXT_IDENTITY_SRC)
#define BITMAP_IDENTITY_DST            (1LL << SADB_EXT_IDENTITY_DST)
#define BITMAP_SENSITIVITY             (1LL << SADB_EXT_SENSITIVITY)
#define BITMAP_PROPOSAL                (1LL << SADB_EXT_PROPOSAL)
#define BITMAP_SUPPORTED_AUTH          (1LL << SADB_EXT_SUPPORTED_AUTH)
#define BITMAP_SUPPORTED_ENCRYPT       (1LL << SADB_EXT_SUPPORTED_ENCRYPT)
#define BITMAP_SPIRANGE                (1LL << SADB_EXT_SPIRANGE)
#define BITMAP_LIFETIME (BITMAP_LIFETIME_CURRENT | BITMAP_LIFETIME_HARD | BITMAP_LIFETIME_SOFT)
#define BITMAP_ADDRESS (BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST)
#define BITMAP_KEY      (BITMAP_KEY_AUTH | BITMAP_KEY_ENCRYPT)
#define BITMAP_IDENTITY (BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST)
#define BITMAP_MSG                     1
#define BITMAP_X_SRC_MASK              (1LL << SADB_X_EXT_SRC_MASK)
#define BITMAP_X_DST_MASK              (1LL << SADB_X_EXT_DST_MASK)
#define BITMAP_X_PROTOCOL              (1LL << SADB_X_EXT_PROTOCOL)
#define BITMAP_X_SRC_FLOW              (1LL << SADB_X_EXT_SRC_FLOW)
#define BITMAP_X_DST_FLOW              (1LL << SADB_X_EXT_DST_FLOW)
#define BITMAP_X_FLOW_TYPE             (1LL << SADB_X_EXT_FLOW_TYPE)
#define BITMAP_X_SA2                   (1LL << SADB_X_EXT_SA2)
#define BITMAP_X_DST2                  (1LL << SADB_X_EXT_DST2)
#define BITMAP_X_POLICY                (1LL << SADB_X_EXT_POLICY)
#define BITMAP_X_FLOW                  (BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE)
#define BITMAP_X_SUPPORTED_COMP        (1LL << SADB_X_EXT_SUPPORTED_COMP)
#define BITMAP_X_UDPENCAP              (1LL << SADB_X_EXT_UDPENCAP)
#define BITMAP_X_LIFETIME_LASTUSE      (1LL << SADB_X_EXT_LIFETIME_LASTUSE)
#define BITMAP_X_TAG                   (1LL << SADB_X_EXT_TAG)
#define BITMAP_X_TAP                   (1LL << SADB_X_EXT_TAP)
#define BITMAP_X_SATYPE2               (1LL << SADB_X_EXT_SATYPE2)

uint64_t sadb_exts_allowed_in[SADB_MAX+1] =
{
	/* RESERVED */
	~0,
	/* GETSPI */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SPIRANGE,
	/* UPDATE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_ADDRESS_PROXY | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG | BITMAP_X_TAP,
	/* ADD */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_LIFETIME_LASTUSE | BITMAP_X_TAG | BITMAP_X_TAP,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL,
	/* REGISTER */
	0,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST | BITMAP_X_FLOW,
	/* X_DELFLOW */
	BITMAP_X_FLOW,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_SATYPE2,
	/* X_ASKPOLICY */
	BITMAP_X_POLICY,
};

uint64_t sadb_exts_required_in[SADB_MAX+1] =
{
	/* RESERVED */
	0,
	/* GETSPI */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SPIRANGE,
	/* UPDATE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* ADD */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	0,
	/* REGISTER */
	0,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_SATYPE2,
	/* X_ASKPOLICY */
	BITMAP_X_POLICY,
};

uint64_t sadb_exts_allowed_out[SADB_MAX+1] =
{
	/* RESERVED */
	~0,
	/* GETSPI */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* UPDATE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_ADDRESS_PROXY | BITMAP_IDENTITY | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG | BITMAP_X_TAP,
	/* ADD */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG | BITMAP_X_TAP,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_UDPENCAP | BITMAP_X_LIFETIME_LASTUSE | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_FLOW_TYPE | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_TAG | BITMAP_X_TAP,
	/* ACQUIRE */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL,
	/* REGISTER */
	BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
	/* EXPIRE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS,
	/* FLUSH */
	0,
	/* DUMP */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_SATYPE2,
	/* X_ASKPOLICY */
	BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE | BITMAP_X_POLICY,
};

uint64_t sadb_exts_required_out[SADB_MAX+1] =
{
	/* RESERVED */
	0,
	/* GETSPI */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* UPDATE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* ADD */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_LIFETIME_CURRENT | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	0,
	/* REGISTER */
	BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_SATYPE2,
	/* X_REPPOLICY */
	BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE,
};

int pfkeyv2_parsemessage(void *, int, void **);

#define RETURN_EINVAL(line) goto einval;

int
pfkeyv2_parsemessage(void *p, int len, void **headers)
{
	struct sadb_ext *sadb_ext;
	int i, left = len;
	uint64_t allow, seen = 1;
	struct sadb_msg *sadb_msg = (struct sadb_msg *) p;

	bzero(headers, (SADB_EXT_MAX + 1) * sizeof(void *));

	if (left < sizeof(struct sadb_msg)) {
		DPRINTF(("pfkeyv2_parsemessage: message too short\n"));
		return (EINVAL);
	}

	headers[0] = p;

	if (sadb_msg->sadb_msg_len * sizeof(uint64_t) != left) {
		DPRINTF(("pfkeyv2_parsemessage: length not a multiple of 64\n"));
		return (EINVAL);
	}

	p += sizeof(struct sadb_msg);
	left -= sizeof(struct sadb_msg);

	if (sadb_msg->sadb_msg_reserved) {
		DPRINTF(("pfkeyv2_parsemessage: message header reserved "
		    "field set\n"));
		return (EINVAL);
	}

	if (sadb_msg->sadb_msg_type > SADB_MAX) {
		DPRINTF(("pfkeyv2_parsemessage: message type > %d\n",
		    SADB_MAX));
		return (EINVAL);
	}

	if (!sadb_msg->sadb_msg_type) {
		DPRINTF(("pfkeyv2_parsemessage: message type unset\n"));
		return (EINVAL);
	}

	if (sadb_msg->sadb_msg_pid != curproc->p_p->ps_pid) {
		DPRINTF(("pfkeyv2_parsemessage: bad PID value\n"));
		return (EINVAL);
	}

	if (sadb_msg->sadb_msg_errno) {
		if (left) {
			DPRINTF(("pfkeyv2_parsemessage: too-large error message\n"));
			return (EINVAL);
		}
		return (0);
	}

	if (sadb_msg->sadb_msg_type == SADB_X_PROMISC) {
		DPRINTF(("pfkeyv2_parsemessage: message type promiscuous\n"));
		return (0);
	}

	allow = sadb_exts_allowed_in[sadb_msg->sadb_msg_type];

	while (left > 0) {
		sadb_ext = (struct sadb_ext *)p;
		if (left < sizeof(struct sadb_ext)) {
			DPRINTF(("pfkeyv2_parsemessage: extension header too "
			    "short\n"));
			return (EINVAL);
		}

		i = sadb_ext->sadb_ext_len * sizeof(uint64_t);
		if (left < i) {
			DPRINTF(("pfkeyv2_parsemessage: extension header "
			    "exceeds message length\n"));
			return (EINVAL);
		}

		if (sadb_ext->sadb_ext_type > SADB_EXT_MAX) {
			DPRINTF(("pfkeyv2_parsemessage: unknown extension "
			    "header %d\n", sadb_ext->sadb_ext_type));
			return (EINVAL);
		}

		if (!sadb_ext->sadb_ext_type) {
			DPRINTF(("pfkeyv2_parsemessage: unset extension "
			    "header\n"));
			return (EINVAL);
		}

		if (!(allow & (1LL << sadb_ext->sadb_ext_type))) {
			DPRINTF(("pfkeyv2_parsemessage: extension header %d "
			    "not permitted on message type %d\n",
			    sadb_ext->sadb_ext_type, sadb_msg->sadb_msg_type));
			return (EINVAL);
		}

		if (headers[sadb_ext->sadb_ext_type]) {
			DPRINTF(("pfkeyv2_parsemessage: duplicate extension "
			    "header %d\n", sadb_ext->sadb_ext_type));
			return (EINVAL);
		}

		seen |= (1LL << sadb_ext->sadb_ext_type);

		switch (sadb_ext->sadb_ext_type) {
		case SADB_EXT_SA:
		case SADB_X_EXT_SA2:
		{
			struct sadb_sa *sadb_sa = (struct sadb_sa *)p;

			if (i != sizeof(struct sadb_sa)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for SA extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_sa->sadb_sa_state > SADB_SASTATE_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown SA "
				    "state %d in SA extension header %d\n",
				    sadb_sa->sadb_sa_state,
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_sa->sadb_sa_state == SADB_SASTATE_DEAD) {
				DPRINTF(("pfkeyv2_parsemessage: cannot set SA "
				    "state to dead, SA extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_sa->sadb_sa_encrypt > SADB_EALG_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "encryption algorithm %d in SA extension "
				    "header %d\n", sadb_sa->sadb_sa_encrypt,
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_sa->sadb_sa_auth > SADB_AALG_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "authentication algorithm %d in SA "
				    "extension header %d\n",
				    sadb_sa->sadb_sa_auth,
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_sa->sadb_sa_replay > 64) {
				DPRINTF(("pfkeyv2_parsemessage: unsupported "
				    "replay window size %d in SA extension "
				    "header %d\n", sadb_sa->sadb_sa_replay,
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}
		}
		break;
		case SADB_X_EXT_PROTOCOL:
		case SADB_X_EXT_FLOW_TYPE:
		case SADB_X_EXT_SATYPE2:
			if (i != sizeof(struct sadb_protocol)) {
				DPRINTF(("pfkeyv2_parsemessage: bad PROTOCOL/"
				    "FLOW/SATYPE2 header length in extension "
				    "header %d\n", sadb_ext->sadb_ext_type));
				return (EINVAL);
			}
			break;
		case SADB_X_EXT_POLICY:
			if (i != sizeof(struct sadb_x_policy)) {
				DPRINTF(("pfkeyv2_parsemessage: bad POLICY "
				    "header length\n"));
				return (EINVAL);
			}
			break;
		case SADB_EXT_LIFETIME_CURRENT:
		case SADB_EXT_LIFETIME_HARD:
		case SADB_EXT_LIFETIME_SOFT:
		case SADB_X_EXT_LIFETIME_LASTUSE:
			if (i != sizeof(struct sadb_lifetime)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for LIFETIME extension header "
				    "%d\n", sadb_ext->sadb_ext_type));
				return (EINVAL);
			}
			break;
		case SADB_EXT_ADDRESS_SRC:
		case SADB_EXT_ADDRESS_DST:
		case SADB_EXT_ADDRESS_PROXY:
		case SADB_X_EXT_SRC_MASK:
		case SADB_X_EXT_DST_MASK:
		case SADB_X_EXT_SRC_FLOW:
		case SADB_X_EXT_DST_FLOW:
		case SADB_X_EXT_DST2:
		{
			struct sadb_address *sadb_address =
			    (struct sadb_address *)p;
			struct sockaddr *sa = (struct sockaddr *)(p +
			    sizeof(struct sadb_address));

			if (i < sizeof(struct sadb_address) +
			    sizeof(struct sockaddr)) {
				DPRINTF(("pfkeyv2_parsemessage: bad ADDRESS "
				    "extension header %d length\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_address->sadb_address_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: ADDRESS "
				    "extension header %d reserved field set\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}
			if (sa->sa_len &&
			    (i != sizeof(struct sadb_address) +
			    PADUP(sa->sa_len))) {
				DPRINTF(("pfkeyv2_parsemessage: bad sockaddr "
				    "length field in ADDRESS extension "
				    "header %d\n", sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			switch (sa->sa_family) {
			case AF_INET:
				if (sizeof(struct sadb_address) +
				    PADUP(sizeof(struct sockaddr_in)) != i) {
					DPRINTF(("pfkeyv2_parsemessage: "
					    "invalid ADDRESS extension header "
					    "%d length\n",
					    sadb_ext->sadb_ext_type));
					return (EINVAL);
				}

				if (sa->sa_len != sizeof(struct sockaddr_in)) {
					DPRINTF(("pfkeyv2_parsemessage: bad "
					    "sockaddr_in length in ADDRESS "
					    "extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return (EINVAL);
				}

				/* Only check the right pieces */
				switch (sadb_ext->sadb_ext_type)
				{
				case SADB_X_EXT_SRC_MASK:
				case SADB_X_EXT_DST_MASK:
				case SADB_X_EXT_SRC_FLOW:
				case SADB_X_EXT_DST_FLOW:
					break;

				default:
					if (((struct sockaddr_in *)sa)->sin_port) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": port field set in "
						    "sockaddr_in of ADDRESS "
						    "extension header %d\n",
						    sadb_ext->sadb_ext_type));
						return (EINVAL);
					}
					break;
				}

				{
					char zero[sizeof(((struct sockaddr_in *)sa)->sin_zero)];
					bzero(zero, sizeof(zero));

					if (bcmp(&((struct sockaddr_in *)sa)->sin_zero, zero, sizeof(zero))) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": reserved sockaddr_in "
						    "field non-zero'ed in "
						    "ADDRESS extension header "
						    "%d\n",
						    sadb_ext->sadb_ext_type));
						return (EINVAL);
					}
				}
				break;
#ifdef INET6
			case AF_INET6:
				if (i != sizeof(struct sadb_address) +
				    PADUP(sizeof(struct sockaddr_in6))) {
					DPRINTF(("pfkeyv2_parsemessage: "
					    "invalid sockaddr_in6 length in "
					    "ADDRESS extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return (EINVAL);
				}

				if (sa->sa_len !=
				    sizeof(struct sockaddr_in6)) {
					DPRINTF(("pfkeyv2_parsemessage: bad "
					    "sockaddr_in6 length in ADDRESS "
					    "extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return (EINVAL);
				}

				if (((struct sockaddr_in6 *)sa)->sin6_flowinfo) {
					DPRINTF(("pfkeyv2_parsemessage: "
					    "flowinfo field set in "
					    "sockaddr_in6 of ADDRESS "
					    "extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return (EINVAL);
				}

				/* Only check the right pieces */
				switch (sadb_ext->sadb_ext_type)
				{
				case SADB_X_EXT_SRC_MASK:
				case SADB_X_EXT_DST_MASK:
				case SADB_X_EXT_SRC_FLOW:
				case SADB_X_EXT_DST_FLOW:
					break;

				default:
					if (((struct sockaddr_in6 *)sa)->sin6_port) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": port field set in "
						    "sockaddr_in6 of ADDRESS "
						    "extension header %d\n",
						    sadb_ext->sadb_ext_type));
						return (EINVAL);
					}
					break;
				}
				break;
#endif /* INET6 */
			default:
				if (sadb_msg->sadb_msg_satype ==
				    SADB_X_SATYPE_TCPSIGNATURE &&
				    sa->sa_family == 0)
					break;
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "address family %d in ADDRESS extension "
				    "header %d\n",
				    sa->sa_family, sadb_ext->sadb_ext_type));
				return (EINVAL);
			}
		}
		break;
		case SADB_EXT_KEY_AUTH:
		case SADB_EXT_KEY_ENCRYPT:
		{
			struct sadb_key *sadb_key = (struct sadb_key *)p;

			if (i < sizeof(struct sadb_key)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length in KEY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (!sadb_key->sadb_key_bits) {
				DPRINTF(("pfkeyv2_parsemessage: key length "
				    "unset in KEY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (((sadb_key->sadb_key_bits + 63) / 64) * sizeof(uint64_t) != i - sizeof(struct sadb_key)) {
				DPRINTF(("pfkeyv2_parsemessage: invalid key "
				    "length in KEY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_key->sadb_key_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved field"
				    " set in KEY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}
		}
		break;
		case SADB_EXT_IDENTITY_SRC:
		case SADB_EXT_IDENTITY_DST:
		{
			struct sadb_ident *sadb_ident = (struct sadb_ident *)p;

			if (i < sizeof(struct sadb_ident)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length of IDENTITY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_ident->sadb_ident_type > SADB_IDENTTYPE_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "identity type %d in IDENTITY extension "
				    "header %d\n",
				    sadb_ident->sadb_ident_type,
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_ident->sadb_ident_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved "
				    "field set in IDENTITY extension header "
				    "%d\n", sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (i > sizeof(struct sadb_ident)) {
				char *c =
				    (char *)(p + sizeof(struct sadb_ident));
				int j;

				if (*(char *)(p + i - 1)) {
					DPRINTF(("pfkeyv2_parsemessage: non "
					    "NUL-terminated identity in "
					    "IDENTITY extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return (EINVAL);
				}

				j = PADUP(strlen(c) + 1) +
				    sizeof(struct sadb_ident);

				if (i != j) {
					DPRINTF(("pfkeyv2_parsemessage: actual"
					    " identity length does not match "
					    "expected length in identity "
					    "extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return (EINVAL);
				}
			}
		}
		break;
		case SADB_EXT_SENSITIVITY:
		{
			struct sadb_sens *sadb_sens = (struct sadb_sens *)p;

			if (i < sizeof(struct sadb_sens)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for SENSITIVITY extension "
				    "header\n"));
				return (EINVAL);
			}

			if (i != (sadb_sens->sadb_sens_sens_len +
			    sadb_sens->sadb_sens_integ_len) *
			    sizeof(uint64_t) +
			    sizeof(struct sadb_sens)) {
				DPRINTF(("pfkeyv2_parsemessage: bad payload "
				    "length for SENSITIVITY extension "
				    "header\n"));
				return (EINVAL);
			}
		}
		break;
		case SADB_EXT_PROPOSAL:
		{
			struct sadb_prop *sadb_prop = (struct sadb_prop *)p;

			if (i < sizeof(struct sadb_prop)) {
				DPRINTF(("pfkeyv2_parsemessage: bad PROPOSAL "
				    "header length\n"));
				return (EINVAL);
			}

			if (sadb_prop->sadb_prop_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved field"
				    "set in PROPOSAL extension header\n"));
				return (EINVAL);
			}

			if ((i - sizeof(struct sadb_prop)) %
			    sizeof(struct sadb_comb)) {
				DPRINTF(("pfkeyv2_parsemessage: bad proposal "
				    "length\n"));
				return (EINVAL);
			}

			{
				struct sadb_comb *sadb_comb =
				    (struct sadb_comb *)(p +
					sizeof(struct sadb_prop));
				int j;

				for (j = 0;
				    j < (i - sizeof(struct sadb_prop))/
				    sizeof(struct sadb_comb);
				    j++) {
					if (sadb_comb->sadb_comb_auth >
					    SADB_AALG_MAX) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": unknown authentication "
						    "algorithm %d in "
						    "PROPOSAL\n",
						    sadb_comb->sadb_comb_auth));
						return (EINVAL);
					}

					if (sadb_comb->sadb_comb_encrypt >
					    SADB_EALG_MAX) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": unknown encryption "
						    "algorithm %d in "
						    "PROPOSAL\n",
						    sadb_comb->sadb_comb_encrypt));
						return (EINVAL);
					}

					if (sadb_comb->sadb_comb_reserved) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": reserved field set in "
						    "COMB header\n"));
						return (EINVAL);
					}
				}
			}
		}
		break;
		case SADB_EXT_SUPPORTED_AUTH:
		case SADB_EXT_SUPPORTED_ENCRYPT:
		case SADB_X_EXT_SUPPORTED_COMP:
		{
			struct sadb_supported *sadb_supported =
			    (struct sadb_supported *)p;
			int j;

			if (i < sizeof(struct sadb_supported)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for SUPPORTED extension header "
				    "%d\n", sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_supported->sadb_supported_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved "
				    "field set in SUPPORTED extension "
				    "header %d\n", sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			{
				struct sadb_alg *sadb_alg =
				    (struct sadb_alg *)(p +
					sizeof(struct sadb_supported));
				int max_alg;

				max_alg = sadb_ext->sadb_ext_type ==
				    SADB_EXT_SUPPORTED_AUTH ?
				    SADB_AALG_MAX : SADB_EXT_SUPPORTED_ENCRYPT ?
				    SADB_EALG_MAX : SADB_X_CALG_MAX;

				for (j = 0;
				    j < sadb_supported->sadb_supported_len - 1;
				    j++) {
					if (sadb_alg->sadb_alg_id > max_alg) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": unknown algorithm %d "
						    "in SUPPORTED extension "
						    "header %d\n",
						    sadb_alg->sadb_alg_id,
						    sadb_ext->sadb_ext_type));
						return (EINVAL);
					}

					if (sadb_alg->sadb_alg_reserved) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": reserved field set in "
						    "supported algorithms "
						    "header inside SUPPORTED "
						    "extension header %d\n",
						    sadb_ext->sadb_ext_type));
						return (EINVAL);
					}

					sadb_alg++;
				}
			}
		}
		break;
		case SADB_EXT_SPIRANGE:
		{
			struct sadb_spirange *sadb_spirange =
			    (struct sadb_spirange *)p;

			if (i != sizeof(struct sadb_spirange)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length of SPIRANGE extension header\n"));
				return (EINVAL);
			}

			if (sadb_spirange->sadb_spirange_min >
			    sadb_spirange->sadb_spirange_max) {
				DPRINTF(("pfkeyv2_parsemessage: bad SPI "
				    "range\n"));
				return (EINVAL);
			}
		}
		break;
		case SADB_X_EXT_UDPENCAP:
			if (i != sizeof(struct sadb_x_udpencap)) {
				DPRINTF(("pfkeyv2_parsemessage: bad UDPENCAP "
				    "header length\n"));
				return (EINVAL);
			}
			break;
#if NPF > 0
		case SADB_X_EXT_TAG:
			if (i < sizeof(struct sadb_x_tag)) {
				DPRINTF(("pfkeyv2_parsemessage: "
				    "TAG extension header too small"));
				return (EINVAL);
			}
			if (i > (sizeof(struct sadb_x_tag) +
			    PF_TAG_NAME_SIZE)) {
				DPRINTF(("pfkeyv2_parsemessage: "
				    "TAG extension header too long"));
				return (EINVAL);
			}
			break;
		case SADB_X_EXT_TAP:
			if (i < sizeof(struct sadb_x_tap)) {
				DPRINTF(("pfkeyv2_parsemessage: "
				    "TAP extension header too small"));
				return (EINVAL);
			}
			if (i > sizeof(struct sadb_x_tap)) {
				DPRINTF(("pfkeyv2_parsemessage: "
				    "TAP extension header too long"));
				return (EINVAL);
			}
			break;
#endif
		default:
			DPRINTF(("pfkeyv2_parsemessage: unknown extension "
			    "header type %d\n",
			    sadb_ext->sadb_ext_type));
			return (EINVAL);
		}

		headers[sadb_ext->sadb_ext_type] = p;
		p += i;
		left -= i;
	}

	if (left) {
		DPRINTF(("pfkeyv2_parsemessage: message too long\n"));
		return (EINVAL);
	}

	{
		uint64_t required;

		required = sadb_exts_required_in[sadb_msg->sadb_msg_type];

		if ((seen & required) != required) {
			DPRINTF(("pfkeyv2_parsemessage: required fields "
			    "missing\n"));
			return (EINVAL);
		}
	}

	switch (((struct sadb_msg *)headers[0])->sadb_msg_type) {
	case SADB_UPDATE:
		if (((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_state !=
		    SADB_SASTATE_MATURE) {
			DPRINTF(("pfkeyv2_parsemessage: updating non-mature "
			    "SA prohibited\n"));
			return (EINVAL);
		}
		break;
	case SADB_ADD:
		if (((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_state !=
		    SADB_SASTATE_MATURE) {
			DPRINTF(("pfkeyv2_parsemessage: adding non-mature "
			    "SA prohibited\n"));
			return (EINVAL);
		}
		break;
	}

	return (0);
}
@


1.52
log
@Allow updating the destination address of an existing TDB.  Since the
destination address is used as an index when looking for a TDB, we need
to supply the new destination address in a different member.  For this,
re-use the proxy address, that so far no one else has been using.  It
would make sense to rename this member in the future.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.51 2017/02/28 16:46:27 bluhm Exp $	*/
a78 1
#include <netinet/ip_var.h>
@


1.51
log
@Depending on the addresses, ipsecctl(8) automatically groups sa
bundles together.  Extend the kernel interface to export the bundle
information to userland.  Then ipsecctl -ss -v can show the internal
relations.  Unfortunately the header SADB_X_EXT_PROTOCOL was reused
by SADB_X_GRPSPIS, so it cannot be used to transfer the second sa
type with sysctl.  Introduce a new SADB_X_EXT_SATYPE2 and use it
consistently.
OK hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.50 2017/01/24 10:08:30 krw Exp $	*/
d99 1
d138 1
a138 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG | BITMAP_X_TAP,
d210 1
a210 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG | BITMAP_X_TAP,
d467 1
@


1.50
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.49 2015/04/14 12:22:15 mikeb Exp $	*/
d128 1
d161 1
a161 1
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
d197 1
a197 1
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
d233 1
a233 1
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
d269 1
a269 1
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
d438 1
d440 2
a441 2
				DPRINTF(("pfkeyv2_parsemessage: bad "
				    "PROTOCOL/FLOW header length in extension "
@


1.49
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.48 2015/03/26 12:21:37 mikeb Exp $	*/
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d17 4
a20 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d24 1
a24 1
 * 
d36 1
a36 1
 * 
@


1.48
log
@Remove bits of unfinished IPsec proxy support.  DNS' KX records, anyone?
ok markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.47 2013/04/10 08:50:59 mpi Exp $	*/
a121 5
#define BITMAP_X_LOCAL_CREDENTIALS     (1LL << SADB_X_EXT_LOCAL_CREDENTIALS)
#define BITMAP_X_REMOTE_CREDENTIALS    (1LL << SADB_X_EXT_REMOTE_CREDENTIALS)
#define BITMAP_X_LOCAL_AUTH            (1LL << SADB_X_EXT_LOCAL_AUTH)
#define BITMAP_X_REMOTE_AUTH           (1LL << SADB_X_EXT_REMOTE_AUTH)
#define BITMAP_X_CREDENTIALS           (BITMAP_X_LOCAL_CREDENTIALS | BITMAP_X_REMOTE_CREDENTIALS | BITMAP_X_LOCAL_AUTH | BITMAP_X_REMOTE_AUTH)
d136 1
a136 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG | BITMAP_X_TAP,
d138 1
a138 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_LIFETIME_LASTUSE | BITMAP_X_TAG | BITMAP_X_TAP,
d144 1
a144 1
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
d208 1
a208 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG | BITMAP_X_TAP,
d210 1
a210 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG | BITMAP_X_TAP,
d214 1
a214 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_UDPENCAP | BITMAP_X_LIFETIME_LASTUSE | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_FLOW_TYPE | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_TAG | BITMAP_X_TAP,
d216 1
a216 1
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
a646 59
				return (EINVAL);
			}
		}
		break;
		case SADB_X_EXT_LOCAL_AUTH:
		case SADB_X_EXT_REMOTE_AUTH:
		{
			struct sadb_x_cred *sadb_cred =
			    (struct sadb_x_cred *)p;

			if (i < sizeof(struct sadb_x_cred)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for AUTH extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_cred->sadb_x_cred_type > SADB_X_AUTHTYPE_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown auth "
				    "type %d in AUTH extension header %d\n",
				    sadb_cred->sadb_x_cred_type,
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_cred->sadb_x_cred_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved field"
				    " set in AUTH extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}
		}
		break;
		case SADB_X_EXT_LOCAL_CREDENTIALS:
		case SADB_X_EXT_REMOTE_CREDENTIALS:
		{
			struct sadb_x_cred *sadb_cred =
			    (struct sadb_x_cred *)p;

			if (i < sizeof(struct sadb_x_cred)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length of CREDENTIALS extension header "
				    "%d\n", sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_cred->sadb_x_cred_type > SADB_X_CREDTYPE_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "credential type %d in CREDENTIALS "
				    "extension header %d\n",
				    sadb_cred->sadb_x_cred_type,
				    sadb_ext->sadb_ext_type));
				return (EINVAL);
			}

			if (sadb_cred->sadb_x_cred_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved "
				    "field set in CREDENTIALS extension "
				    "header %d\n", sadb_ext->sadb_ext_type));
@


1.47
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.46 2012/06/29 14:48:04 mikeb Exp $	*/
a98 1
#define BITMAP_ADDRESS_PROXY           (1LL << SADB_EXT_ADDRESS_PROXY)
d109 1
a109 1
#define BITMAP_ADDRESS (BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_ADDRESS_PROXY)
a473 1
		case SADB_EXT_ADDRESS_PROXY:
@


1.46
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.45 2012/03/28 19:43:21 claudio Exp $	*/
d79 1
a85 2

extern int encdebug;
@


1.45
log
@pfkey needs some p_p->ps_pid too. OK deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.44 2010/07/01 02:09:45 reyk Exp $	*/
d433 1
a433 1
			if (sadb_sa->sadb_sa_replay > 32) {
@


1.44
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.42 2007/07/30 11:43:59 hshoexer Exp $	*/
d326 1
a326 1
	if (sadb_msg->sadb_msg_pid != curproc->p_pid) {
@


1.43
log
@#if INET  => #ifdef INET
#if INET6 => #ifdef INET6
@
text
@d134 1
d143 1
a143 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG,
d145 1
a145 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_LIFETIME_LASTUSE | BITMAP_X_TAG,
d215 1
a215 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG,
d217 1
a217 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_TAG,
d221 1
a221 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_UDPENCAP | BITMAP_X_LIFETIME_LASTUSE | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_FLOW_TYPE | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_TAG,
d956 12
@


1.42
log
@With adding ipsec tags and exporting flow filters via sysctl SADB_GET
needs to be allowed to export that information too.  Thus, adjust
sadb_exts_allowed_out[] accordingly.

This fixes isakmpd not being able to get the in-kernel last-used-counters
of SAs, which are needed for DPD.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.41 2006/11/24 13:52:14 reyk Exp $	*/
d560 1
a560 1
#if INET6
@


1.41
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.40 2005/05/28 15:10:07 ho Exp $	*/
d220 1
a220 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_UDPENCAP | BITMAP_X_LIFETIME_LASTUSE,
@


1.40
log
@Add SA replay counter synchronization to pfsync(4). Required for IPsec
failover gateways. ok mcbride@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.39 2004/08/10 16:17:05 ho Exp $	*/
d71 2
d81 5
d133 1
d142 1
a142 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP,
d144 1
a144 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP | BITMAP_X_LIFETIME_LASTUSE,
d214 1
a214 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP,
d216 1
a216 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP,
d944 15
@


1.39
log
@Add SADB_X_EXT_LIFETIME_LASTUSE for use with isakmpd/DPD, adding this
extends the bitmap to 64bits. Also repair SADB_GET. hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.38 2004/03/31 10:24:00 henning Exp $	*/
d136 1
a136 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP,
@


1.38
log
@in the tcp md5sig case allow empty (wildcard) src or dst
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.37 2003/12/02 23:16:29 markus Exp $	*/
d87 16
a102 16
#define BITMAP_SA                      (1 << SADB_EXT_SA)
#define BITMAP_LIFETIME_CURRENT        (1 << SADB_EXT_LIFETIME_CURRENT)
#define BITMAP_LIFETIME_HARD           (1 << SADB_EXT_LIFETIME_HARD)
#define BITMAP_LIFETIME_SOFT           (1 << SADB_EXT_LIFETIME_SOFT)
#define BITMAP_ADDRESS_SRC             (1 << SADB_EXT_ADDRESS_SRC)
#define BITMAP_ADDRESS_DST             (1 << SADB_EXT_ADDRESS_DST)
#define BITMAP_ADDRESS_PROXY           (1 << SADB_EXT_ADDRESS_PROXY)
#define BITMAP_KEY_AUTH                (1 << SADB_EXT_KEY_AUTH)
#define BITMAP_KEY_ENCRYPT             (1 << SADB_EXT_KEY_ENCRYPT)
#define BITMAP_IDENTITY_SRC            (1 << SADB_EXT_IDENTITY_SRC)
#define BITMAP_IDENTITY_DST            (1 << SADB_EXT_IDENTITY_DST)
#define BITMAP_SENSITIVITY             (1 << SADB_EXT_SENSITIVITY)
#define BITMAP_PROPOSAL                (1 << SADB_EXT_PROPOSAL)
#define BITMAP_SUPPORTED_AUTH          (1 << SADB_EXT_SUPPORTED_AUTH)
#define BITMAP_SUPPORTED_ENCRYPT       (1 << SADB_EXT_SUPPORTED_ENCRYPT)
#define BITMAP_SPIRANGE                (1 << SADB_EXT_SPIRANGE)
d108 13
a120 13
#define BITMAP_X_SRC_MASK              (1 << SADB_X_EXT_SRC_MASK)
#define BITMAP_X_DST_MASK              (1 << SADB_X_EXT_DST_MASK)
#define BITMAP_X_PROTOCOL              (1 << SADB_X_EXT_PROTOCOL)
#define BITMAP_X_SRC_FLOW              (1 << SADB_X_EXT_SRC_FLOW)
#define BITMAP_X_DST_FLOW              (1 << SADB_X_EXT_DST_FLOW)
#define BITMAP_X_FLOW_TYPE             (1 << SADB_X_EXT_FLOW_TYPE)
#define BITMAP_X_SA2                   (1 << SADB_X_EXT_SA2)
#define BITMAP_X_DST2                  (1 << SADB_X_EXT_DST2)
#define BITMAP_X_POLICY                (1 << SADB_X_EXT_POLICY)
#define BITMAP_X_LOCAL_CREDENTIALS     (1 << SADB_X_EXT_LOCAL_CREDENTIALS)
#define BITMAP_X_REMOTE_CREDENTIALS    (1 << SADB_X_EXT_REMOTE_CREDENTIALS)
#define BITMAP_X_LOCAL_AUTH            (1 << SADB_X_EXT_LOCAL_AUTH)
#define BITMAP_X_REMOTE_AUTH           (1 << SADB_X_EXT_REMOTE_AUTH)
d123 3
a125 2
#define BITMAP_X_SUPPORTED_COMP        (1 << SADB_X_EXT_SUPPORTED_COMP)
#define BITMAP_X_UDPENCAP              (1 << SADB_X_EXT_UDPENCAP)
d127 1
a127 1
uint32_t sadb_exts_allowed_in[SADB_MAX+1] =
d163 1
a163 1
uint32_t sadb_exts_required_in[SADB_MAX+1] =
d176 1
a176 1
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
d199 1
a199 1
uint32_t sadb_exts_allowed_out[SADB_MAX+1] =
d212 1
a212 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY,
d235 1
a235 1
uint32_t sadb_exts_required_out[SADB_MAX+1] =
d280 1
a280 1
	uint32_t allow, seen = 1;
d364 1
a364 1
		if (!(allow & (1 << sadb_ext->sadb_ext_type))) {
d377 1
a377 1
		seen |= (1 << sadb_ext->sadb_ext_type);
d452 1
d954 1
a954 1
		uint32_t required;
@


1.37
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.36 2003/02/16 21:30:13 deraadt Exp $	*/
d602 4
@


1.36
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.35 2003/02/16 19:54:20 jason Exp $	*/
d124 1
d133 1
a133 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
d135 1
a135 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
d205 1
a205 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
d207 1
a207 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
d923 7
@


1.35
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.34 2002/06/07 06:16:39 angelos Exp $	*/
d494 1
a494 1
			switch(sa->sa_family) {
d521 1
a521 1
		      
d586 1
a586 1
		      
d659 1
a659 1
				    sadb_cred->sadb_x_cred_type, 
d809 3
a811 2
				     j < (i - sizeof(struct sadb_prop))/sizeof(struct sadb_comb);
				     j++) {
d870 2
a871 1
				max_alg = sadb_ext->sadb_ext_type == SADB_EXT_SUPPORTED_AUTH ?
d873 1
a873 1
					SADB_EALG_MAX : SADB_X_CALG_MAX;
d875 3
a877 1
				for (j = 0; j < sadb_supported->sadb_supported_len - 1; j++) {
d928 1
a928 1
  
d951 1
a951 1
	switch(((struct sadb_msg *)headers[0])->sadb_msg_type) {
@


1.34
log
@FLOW_TYPE in ADD/UPDATE.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.33 2002/05/31 01:36:33 angelos Exp $	*/
d127 32
a158 32
  /* RESERVED */
  ~0,
  /* GETSPI */
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SPIRANGE,
  /* UPDATE */
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
  /* ADD */
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
  /* DELETE */
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
  /* GET */
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
  /* ACQUIRE */
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
  /* REGISTER */
  0,
  /* EXPIRE */
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
  /* FLUSH */
  0,
  /* DUMP */
  0,
  /* X_PROMISC */
  0,
  /* X_ADDFLOW */
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST | BITMAP_X_FLOW,
  /* X_DELFLOW */
  BITMAP_X_FLOW,
  /* X_GRPSPIS */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
  /* X_ASKPOLICY */
  BITMAP_X_POLICY,
d163 32
a194 32
  /* RESERVED */
  0,
  /* GETSPI */
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SPIRANGE,
  /* UPDATE */
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
  /* ADD */
  BITMAP_SA | BITMAP_ADDRESS_DST,
  /* DELETE */
  BITMAP_SA | BITMAP_ADDRESS_DST,
  /* GET */
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
  /* ACQUIRE */
  0,
  /* REGISTER */
  0,
  /* EXPIRE */
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
  /* FLUSH */
  0,
  /* DUMP */
  0,
  /* X_PROMISC */
  0,
  /* X_ADDFLOW */
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
  /* X_DELFLOW */
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
  /* X_GRPSPIS */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
  /* X_ASKPOLICY */
  BITMAP_X_POLICY,
d199 32
a230 32
  /* RESERVED */
  ~0,
  /* GETSPI */
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
  /* UPDATE */
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
  /* ADD */
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
  /* DELETE */
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
  /* GET */
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY,
  /* ACQUIRE */
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
  /* REGISTER */
  BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
  /* EXPIRE */
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS,
  /* FLUSH */
  0,
  /* DUMP */
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY,
  /* X_PROMISC */
  0,
  /* X_ADDFLOW */
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
  /* X_DELFLOW */
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
  /* X_GRPSPIS */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
  /* X_ASKPOLICY */
  BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE | BITMAP_X_POLICY,
d235 32
a266 32
  /* RESERVED */
  0,
  /* GETSPI */
  BITMAP_SA | BITMAP_ADDRESS_DST,
  /* UPDATE */
  BITMAP_SA | BITMAP_ADDRESS_DST,
  /* ADD */
  BITMAP_SA | BITMAP_ADDRESS_DST,
  /* DELETE */
  BITMAP_SA | BITMAP_ADDRESS_DST,
  /* GET */
  BITMAP_SA | BITMAP_LIFETIME_CURRENT | BITMAP_ADDRESS_DST,
  /* ACQUIRE */
  0,
  /* REGISTER */
  BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
  /* EXPIRE */
  BITMAP_SA | BITMAP_ADDRESS_DST,
  /* FLUSH */
  0,
  /* DUMP */
  0,
  /* X_PROMISC */
  0,
  /* X_ADDFLOW */
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
  /* X_DELFLOW */
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
  /* X_GRPSPIS */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
  /* X_REPPOLICY */
  BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE,
d285 1
a285 1
		return EINVAL;
d292 1
a292 1
		return EINVAL;
d301 1
a301 1
		return EINVAL;
d307 1
a307 1
		return EINVAL;
d312 1
a312 1
		return EINVAL;
d317 1
a317 1
		return EINVAL;
d323 1
a323 1
			return EINVAL;
d325 1
a325 1
		return 0;
d330 1
a330 1
		return 0;
d340 1
a340 1
			return EINVAL;
d347 1
a347 1
			return EINVAL;
d353 1
a353 1
			return EINVAL;
d359 1
a359 1
			return EINVAL;
d366 1
a366 1
			return EINVAL;
d372 1
a372 1
			return EINVAL;
d387 1
a387 1
				return EINVAL;
d395 1
a395 1
				return EINVAL;
d402 1
a402 1
				return EINVAL;
d410 1
a410 1
				return EINVAL;
d419 1
a419 1
				return EINVAL;
d427 1
a427 1
				return EINVAL;
d437 1
a437 1
				return EINVAL;
d444 1
a444 1
				return EINVAL;
d454 1
a454 1
				return EINVAL;
d476 1
a476 1
				return EINVAL;
d483 1
a483 1
				return EINVAL;
d491 1
a491 1
				return EINVAL;
d502 1
a502 1
					return EINVAL;
d510 1
a510 1
					return EINVAL;
d529 1
a529 1
						return EINVAL;
d545 1
a545 1
						return EINVAL;
d557 1
a557 1
					return EINVAL;
d566 1
a566 1
					return EINVAL;
d575 1
a575 1
					return EINVAL;
d594 1
a594 1
						return EINVAL;
d605 1
a605 1
				return EINVAL;
d618 1
a618 1
				return EINVAL;
d625 1
a625 1
				return EINVAL;
d632 1
a632 1
				return EINVAL;
d639 1
a639 1
				return EINVAL;
d653 1
a653 1
				return EINVAL;
d661 1
a661 1
				return EINVAL;
d668 1
a668 1
				return EINVAL;
d682 1
a682 1
				return EINVAL;
d691 1
a691 1
				return EINVAL;
d698 1
a698 1
				return EINVAL;
d711 1
a711 1
				return EINVAL;
d720 1
a720 1
				return EINVAL;
d727 1
a727 1
				return EINVAL;
d740 1
a740 1
					return EINVAL;
d752 1
a752 1
					return EINVAL;
d765 1
a765 1
				return EINVAL;
d775 1
a775 1
				return EINVAL;
d786 1
a786 1
				return EINVAL;
d792 1
a792 1
				return EINVAL;
d799 1
a799 1
				return EINVAL;
d818 1
a818 1
						return EINVAL;
d828 1
a828 1
						return EINVAL;
d835 1
a835 1
						return EINVAL;
d853 1
a853 1
				return EINVAL;
d860 1
a860 1
				return EINVAL;
d881 1
a881 1
						return EINVAL;
d891 1
a891 1
						return EINVAL;
d907 1
a907 1
				return EINVAL;
d914 1
a914 1
				return EINVAL;
d922 1
a922 1
			return EINVAL;
d932 1
a932 1
		return EINVAL;
d943 1
a943 1
			return EINVAL;
d953 1
a953 1
			return EINVAL;
d961 1
a961 1
			return EINVAL;
d966 1
a966 1
	return 0;
@


1.33
log
@Allow auth payloads in ACQUIRE messages. Part of a larger commit to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.32 2002/02/23 22:30:53 angelos Exp $	*/
d122 1
a122 1
#define BITMAP_X_FLOW                  (BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW)
d152 1
a152 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
d154 1
a154 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
@


1.32
log
@SRC prefix is not required for some operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.31 2001/07/05 16:48:04 jjbg Exp $	*/
d140 1
a140 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL,
d212 1
a212 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL,
@


1.31
log
@IPComp. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.30 2001/07/03 05:16:09 angelos Exp $	*/
d238 1
a238 1
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
d240 1
a240 1
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
d242 1
a242 1
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
d246 1
a246 1
  BITMAP_SA | BITMAP_LIFETIME_CURRENT | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
d252 1
a252 1
  BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
@


1.31.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.31 2001/07/05 16:48:04 jjbg Exp $	*/
d122 1
a122 1
#define BITMAP_X_FLOW                  (BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE)
d140 1
a140 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
d152 1
a152 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST | BITMAP_X_FLOW,
d154 1
a154 1
  BITMAP_X_FLOW,
d212 1
a212 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
d238 1
a238 1
  BITMAP_SA | BITMAP_ADDRESS_DST,
d240 1
a240 1
  BITMAP_SA | BITMAP_ADDRESS_DST,
d242 1
a242 1
  BITMAP_SA | BITMAP_ADDRESS_DST,
d246 1
a246 1
  BITMAP_SA | BITMAP_LIFETIME_CURRENT | BITMAP_ADDRESS_DST,
d252 1
a252 1
  BITMAP_SA | BITMAP_ADDRESS_DST,
@


1.31.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d127 32
a158 32
	/* RESERVED */
	~0,
	/* GETSPI */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SPIRANGE,
	/* UPDATE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
	/* ADD */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
	/* REGISTER */
	0,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST | BITMAP_X_FLOW,
	/* X_DELFLOW */
	BITMAP_X_FLOW,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
	/* X_ASKPOLICY */
	BITMAP_X_POLICY,
d163 32
a194 32
	/* RESERVED */
	0,
	/* GETSPI */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SPIRANGE,
	/* UPDATE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* ADD */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	0,
	/* REGISTER */
	0,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
	/* X_ASKPOLICY */
	BITMAP_X_POLICY,
d199 32
a230 32
	/* RESERVED */
	~0,
	/* GETSPI */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* UPDATE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
	/* ADD */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY,
	/* ACQUIRE */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
	/* REGISTER */
	BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
	/* EXPIRE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS,
	/* FLUSH */
	0,
	/* DUMP */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
	/* X_ASKPOLICY */
	BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE | BITMAP_X_POLICY,
d235 32
a266 32
	/* RESERVED */
	0,
	/* GETSPI */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* UPDATE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* ADD */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_LIFETIME_CURRENT | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	0,
	/* REGISTER */
	BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
	/* X_REPPOLICY */
	BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE,
d285 1
a285 1
		return (EINVAL);
d292 1
a292 1
		return (EINVAL);
d301 1
a301 1
		return (EINVAL);
d307 1
a307 1
		return (EINVAL);
d312 1
a312 1
		return (EINVAL);
d317 1
a317 1
		return (EINVAL);
d323 1
a323 1
			return (EINVAL);
d325 1
a325 1
		return (0);
d330 1
a330 1
		return (0);
d340 1
a340 1
			return (EINVAL);
d347 1
a347 1
			return (EINVAL);
d353 1
a353 1
			return (EINVAL);
d359 1
a359 1
			return (EINVAL);
d366 1
a366 1
			return (EINVAL);
d372 1
a372 1
			return (EINVAL);
d387 1
a387 1
				return (EINVAL);
d395 1
a395 1
				return (EINVAL);
d402 1
a402 1
				return (EINVAL);
d410 1
a410 1
				return (EINVAL);
d419 1
a419 1
				return (EINVAL);
d427 1
a427 1
				return (EINVAL);
d437 1
a437 1
				return (EINVAL);
d444 1
a444 1
				return (EINVAL);
d454 1
a454 1
				return (EINVAL);
d476 1
a476 1
				return (EINVAL);
d483 1
a483 1
				return (EINVAL);
d491 1
a491 1
				return (EINVAL);
d494 1
a494 1
			switch (sa->sa_family) {
d502 1
a502 1
					return (EINVAL);
d510 1
a510 1
					return (EINVAL);
d521 1
a521 1

d529 1
a529 1
						return (EINVAL);
d545 1
a545 1
						return (EINVAL);
d557 1
a557 1
					return (EINVAL);
d566 1
a566 1
					return (EINVAL);
d575 1
a575 1
					return (EINVAL);
d586 1
a586 1

d594 1
a594 1
						return (EINVAL);
d605 1
a605 1
				return (EINVAL);
d618 1
a618 1
				return (EINVAL);
d625 1
a625 1
				return (EINVAL);
d632 1
a632 1
				return (EINVAL);
d639 1
a639 1
				return (EINVAL);
d653 1
a653 1
				return (EINVAL);
d659 1
a659 1
				    sadb_cred->sadb_x_cred_type,
d661 1
a661 1
				return (EINVAL);
d668 1
a668 1
				return (EINVAL);
d682 1
a682 1
				return (EINVAL);
d691 1
a691 1
				return (EINVAL);
d698 1
a698 1
				return (EINVAL);
d711 1
a711 1
				return (EINVAL);
d720 1
a720 1
				return (EINVAL);
d727 1
a727 1
				return (EINVAL);
d740 1
a740 1
					return (EINVAL);
d752 1
a752 1
					return (EINVAL);
d765 1
a765 1
				return (EINVAL);
d775 1
a775 1
				return (EINVAL);
d786 1
a786 1
				return (EINVAL);
d792 1
a792 1
				return (EINVAL);
d799 1
a799 1
				return (EINVAL);
d809 2
a810 3
				    j < (i - sizeof(struct sadb_prop))/
				    sizeof(struct sadb_comb);
				    j++) {
d818 1
a818 1
						return (EINVAL);
d828 1
a828 1
						return (EINVAL);
d835 1
a835 1
						return (EINVAL);
d853 1
a853 1
				return (EINVAL);
d860 1
a860 1
				return (EINVAL);
d869 1
a869 2
				max_alg = sadb_ext->sadb_ext_type ==
				    SADB_EXT_SUPPORTED_AUTH ?
d871 1
a871 1
				    SADB_EALG_MAX : SADB_X_CALG_MAX;
d873 1
a873 3
				for (j = 0;
				    j < sadb_supported->sadb_supported_len - 1;
				    j++) {
d881 1
a881 1
						return (EINVAL);
d891 1
a891 1
						return (EINVAL);
d907 1
a907 1
				return (EINVAL);
d914 1
a914 1
				return (EINVAL);
d922 1
a922 1
			return (EINVAL);
d924 1
a924 1

d932 1
a932 1
		return (EINVAL);
d943 1
a943 1
			return (EINVAL);
d947 1
a947 1
	switch (((struct sadb_msg *)headers[0])->sadb_msg_type) {
d953 1
a953 1
			return (EINVAL);
d961 1
a961 1
			return (EINVAL);
d966 1
a966 1
	return (0);
@


1.30
log
@Use PADUP() instead of hand-crafted weirdness; also, it's supposed to
be "strlen(c) + 1", not just "strlen(c)".
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.29 2001/07/01 08:21:15 angelos Exp $	*/
d123 1
d214 1
a214 1
  BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT,
d250 1
a250 1
  BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT,
d843 1
d870 2
a871 1
				    SADB_AALG_MAX : SADB_EALG_MAX;
@


1.29
log
@Add missing space in debug message.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.28 2001/07/01 08:15:51 angelos Exp $	*/
d742 1
a742 2
				j = ((strlen(c) + sizeof(uint64_t)) &
				    ~(sizeof(uint64_t)-1)) +
@


1.28
log
@Fix length check, add some more sanity checks on INET6.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.27 2001/07/01 07:32:37 angelos Exp $	*/
d748 1
a748 1
					    "identity length does not match "
@


1.27
log
@KNF, and add DPRINTFs all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.26 2001/06/08 03:58:48 angelos Exp $	*/
d485 2
a486 1
			    (i != sizeof(struct sadb_address) + sa->sa_len)) {
d496 1
a496 1
				    sizeof(struct sockaddr_in) != i) {
d551 1
a551 1
				    sizeof(struct sockaddr_in6) + 4) {
d575 21
@


1.26
log
@Yet more include file cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.25 2001/06/05 02:31:34 deraadt Exp $	*/
d79 8
d275 4
a278 4
  struct sadb_ext *sadb_ext;
  int i, left = len;
  uint32_t allow, seen = 1;
  struct sadb_msg *sadb_msg = (struct sadb_msg *) p;
d280 1
a280 1
  bzero(headers, (SADB_EXT_MAX + 1) * sizeof(void *));
d282 4
a285 2
  if (left < sizeof(struct sadb_msg))
    return EINVAL;
d287 1
a287 1
  headers[0] = p;
d289 3
a291 93
  if (sadb_msg->sadb_msg_len * sizeof(uint64_t) != left)
    return EINVAL;

  p += sizeof(struct sadb_msg);
  left -= sizeof(struct sadb_msg);

  if (sadb_msg->sadb_msg_reserved)
    return EINVAL;

  if (sadb_msg->sadb_msg_type > SADB_MAX)
    return EINVAL;

  if (!sadb_msg->sadb_msg_type)
    return EINVAL;

  if (sadb_msg->sadb_msg_pid != curproc->p_pid)
    return EINVAL;

  if (sadb_msg->sadb_msg_errno) {
    if (left)
      return EINVAL;

    return 0;
  }

  if (sadb_msg->sadb_msg_type == SADB_X_PROMISC)
    return 0;

  allow = sadb_exts_allowed_in[sadb_msg->sadb_msg_type];

  while (left > 0) {
    sadb_ext = (struct sadb_ext *)p;
    if (left < sizeof(struct sadb_ext))
      return EINVAL;

    i = sadb_ext->sadb_ext_len * sizeof(uint64_t);
    if (left < i)
      return EINVAL;

    if (sadb_ext->sadb_ext_type > SADB_EXT_MAX)
      return EINVAL;

    if (!sadb_ext->sadb_ext_type)
      return EINVAL;

    if (!(allow & (1 << sadb_ext->sadb_ext_type)))
      return EINVAL;

    if (headers[sadb_ext->sadb_ext_type])
      return EINVAL;

    seen |= (1 << sadb_ext->sadb_ext_type);

    switch (sadb_ext->sadb_ext_type) {
      case SADB_EXT_SA:
      case SADB_X_EXT_SA2:
	{
	  struct sadb_sa *sadb_sa = (struct sadb_sa *)p;

	  if (i != sizeof(struct sadb_sa))
	    return EINVAL;

	  if (sadb_sa->sadb_sa_state > SADB_SASTATE_MAX)
	    return EINVAL;

	  if (sadb_sa->sadb_sa_state == SADB_SASTATE_DEAD)
	    return EINVAL;

	  if (sadb_sa->sadb_sa_encrypt > SADB_EALG_MAX)
	    return EINVAL;

	  if (sadb_sa->sadb_sa_auth > SADB_AALG_MAX)
	    return EINVAL;

	  if (sadb_sa->sadb_sa_replay > 32)
	    return EINVAL;
	}
	break;
      case SADB_X_EXT_PROTOCOL:
      case SADB_X_EXT_FLOW_TYPE:
	if (i != sizeof(struct sadb_protocol))
	    return EINVAL;
	break;
      case SADB_X_EXT_POLICY:
        if (i != sizeof(struct sadb_x_policy))
	  return EINVAL;
	break;
      case SADB_EXT_LIFETIME_CURRENT:
      case SADB_EXT_LIFETIME_HARD:
      case SADB_EXT_LIFETIME_SOFT:
	{
	  if (i != sizeof(struct sadb_lifetime))
	    return EINVAL;
a292 15
	break;
      case SADB_EXT_ADDRESS_SRC:
      case SADB_EXT_ADDRESS_DST:
      case SADB_X_EXT_SRC_MASK:
      case SADB_X_EXT_DST_MASK:
      case SADB_X_EXT_SRC_FLOW:
      case SADB_X_EXT_DST_FLOW:
      case SADB_X_EXT_DST2:
      case SADB_EXT_ADDRESS_PROXY:
	{
	  struct sadb_address *sadb_address = (struct sadb_address *)p;
	  struct sockaddr *sa = (struct sockaddr *)(p + sizeof(struct sadb_address));

	  if (i < sizeof(struct sadb_address) + sizeof(struct sockaddr))
	    return EINVAL;
d294 2
a295 2
	  if (sadb_address->sadb_address_reserved)
	    return EINVAL;
d297 3
a299 9
#if SALEN
	  if (sa->sa_len && (i != sizeof(struct sadb_address) + sa->sa_len))
	    return EINVAL;
#endif /* SALEN */

	  switch(sa->sa_family) {
	    case AF_INET:
	      if (sizeof(struct sadb_address) + sizeof(struct sockaddr_in)
		  != i)
d301 1
a301 19
#if SALEN
	      if (sa->sa_len != sizeof(struct sockaddr_in))
		return EINVAL;
#endif /* SALEN */

	      /* Only check the right pieces */
	      switch (sadb_ext->sadb_ext_type)
	      {
		  case SADB_X_EXT_SRC_MASK:
		  case SADB_X_EXT_DST_MASK:
		  case SADB_X_EXT_SRC_FLOW:
		  case SADB_X_EXT_DST_FLOW:
		      break;
		      
		  default:
		      if (((struct sockaddr_in *)sa)->sin_port)
			return EINVAL;
		      break;
	      }
d303 3
a305 13
	      {
		char zero[sizeof(((struct sockaddr_in *)sa)->sin_zero)];
		bzero(zero, sizeof(zero));

		if (bcmp(&((struct sockaddr_in *)sa)->sin_zero, zero,
			 sizeof(zero)))
		  return EINVAL;
	      }
	      break;
#if INET6
	    case AF_INET6:
	      if (i != sizeof(struct sadb_address) +
		  sizeof(struct sockaddr_in6) + 4)
d307 1
d309 2
a310 1
	      if (sa->sa_len != sizeof(struct sockaddr_in6))
d312 1
d314 2
a315 1
	      if (((struct sockaddr_in6 *)sa)->sin6_flowinfo)
a316 25

	      break;
#endif /* INET6 */
	    default:
	      return EINVAL;
	  }
	}
	break;
      case SADB_EXT_KEY_AUTH:
      case SADB_EXT_KEY_ENCRYPT:
	{
	  struct sadb_key *sadb_key = (struct sadb_key *)p;

	  if (i < sizeof(struct sadb_key))
	    return EINVAL;

	  if (!sadb_key->sadb_key_bits)
	    return EINVAL;

	  if (((sadb_key->sadb_key_bits + 63) / 64) * sizeof(uint64_t) !=
	      i - sizeof(struct sadb_key))
	    return EINVAL;

	  if (sadb_key->sadb_key_reserved)
	    return EINVAL;
a317 5
	break;
     case SADB_X_EXT_LOCAL_AUTH:
     case SADB_X_EXT_REMOTE_AUTH:
        {
	  struct sadb_x_cred *sadb_cred = (struct sadb_x_cred *)p;
d319 6
a324 8
	  if (i < sizeof(struct sadb_x_cred))
	    return EINVAL;

	  if (sadb_cred->sadb_x_cred_type > SADB_X_AUTHTYPE_MAX)
	    return EINVAL;

	  if (sadb_cred->sadb_x_cred_reserved)
	    return EINVAL;
a325 5
	break;
     case SADB_X_EXT_LOCAL_CREDENTIALS:
     case SADB_X_EXT_REMOTE_CREDENTIALS:
	{
          struct sadb_x_cred *sadb_cred = (struct sadb_x_cred *)p;
d327 3
a329 8
	  if (i < sizeof(struct sadb_x_cred))
	    return EINVAL;

	  if (sadb_cred->sadb_x_cred_type > SADB_X_CREDTYPE_MAX)
	    return EINVAL;

	  if (sadb_cred->sadb_x_cred_reserved)
	    return EINVAL;
a330 5
	break;
      case SADB_EXT_IDENTITY_SRC:
      case SADB_EXT_IDENTITY_DST:
	{
	  struct sadb_ident *sadb_ident = (struct sadb_ident *)p;
d332 1
a332 2
	  if (i < sizeof(struct sadb_ident))
	    return EINVAL;
d334 7
a340 2
	  if (sadb_ident->sadb_ident_type > SADB_IDENTTYPE_MAX)
	    return EINVAL;
d342 6
a347 2
	  if (sadb_ident->sadb_ident_reserved)
	    return EINVAL;
d349 5
a353 3
	  if (i > sizeof(struct sadb_ident)) {
	    char *c = (char *)(p + sizeof(struct sadb_ident));
	    int j;
d355 5
a359 2
	    if (*(char *)(p + i - 1))
	      return EINVAL;
d361 6
a366 2
	    j = ((strlen(c) + sizeof(uint64_t)) & ~(sizeof(uint64_t)-1)) +
		sizeof(struct sadb_ident);
d368 5
a372 8
	    if (i != j)
	      return EINVAL;
	  }
	}
	break;
      case SADB_EXT_SENSITIVITY:
	{
	  struct sadb_sens *sadb_sens = (struct sadb_sens *)p;
d374 1
a374 2
	  if (i < sizeof(struct sadb_sens))
	    return EINVAL;
d376 528
a903 4
	  if (i != (sadb_sens->sadb_sens_sens_len +
		    sadb_sens->sadb_sens_integ_len) * sizeof(uint64_t) +
	      sizeof(struct sadb_sens))
	    return EINVAL;
a904 10
	break;
      case SADB_EXT_PROPOSAL:
	{
	  struct sadb_prop *sadb_prop = (struct sadb_prop *)p;

	  if (i < sizeof(struct sadb_prop))
	    return EINVAL;

	  if (sadb_prop->sadb_prop_reserved)
	    return EINVAL;
d906 2
a907 11
	  if ((i - sizeof(struct sadb_prop)) % sizeof(struct sadb_comb))
	    return EINVAL;

	  {
	    struct sadb_comb *sadb_comb = (struct sadb_comb *)(p + sizeof(struct sadb_prop));
	    int j;

	    for (j = 0;
		 j < (i - sizeof(struct sadb_prop))/sizeof(struct sadb_comb);
		 j++) {
	      if (sadb_comb->sadb_comb_auth > SADB_AALG_MAX)
d909 1
d911 2
a912 2
	      if (sadb_comb->sadb_comb_encrypt > SADB_EALG_MAX)
		return EINVAL;
d914 1
a914 2
	      if (sadb_comb->sadb_comb_reserved)
		return EINVAL;
d916 5
a920 2
	    }
	  }
a921 6
        break;
      case SADB_EXT_SUPPORTED_AUTH:
      case SADB_EXT_SUPPORTED_ENCRYPT:
	{
	  struct sadb_supported *sadb_supported = (struct sadb_supported *)p;
	  int j;
d923 17
a939 23
	  if (i < sizeof(struct sadb_supported))
	    return EINVAL;

	  if (sadb_supported->sadb_supported_reserved)
	    return EINVAL;

	  {
	    struct sadb_alg *sadb_alg = (struct sadb_alg *)(p + sizeof(struct sadb_supported));
	    int max_alg;

	    max_alg = sadb_ext->sadb_ext_type == SADB_EXT_SUPPORTED_AUTH ?
		    SADB_AALG_MAX : SADB_EALG_MAX;

	    for (j = 0; j < sadb_supported->sadb_supported_len - 1; j++) {
	      if (sadb_alg->sadb_alg_id > max_alg)
		return EINVAL;

	      if (sadb_alg->sadb_alg_reserved)
		return EINVAL;

	      sadb_alg++;
	    }
	  }
a940 46
	break;
      case SADB_EXT_SPIRANGE:
	{
	  struct sadb_spirange *sadb_spirange = (struct sadb_spirange *)p;

	  if (i != sizeof(struct sadb_spirange))
	    return EINVAL;

	  if (sadb_spirange->sadb_spirange_min >
	      sadb_spirange->sadb_spirange_max)
	    return EINVAL;
	}
	break;
      default:
	  return EINVAL;
    }
  
    headers[sadb_ext->sadb_ext_type] = p;
    p += i;
    left -= i;
  }

  if (left)
    return EINVAL;

  {
    uint32_t required;

    required = sadb_exts_required_in[sadb_msg->sadb_msg_type];

    if ((seen & required) != required)
      return EINVAL;
  }

  switch(((struct sadb_msg *)headers[0])->sadb_msg_type) {
    case SADB_UPDATE:
      if (((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_state !=
	  SADB_SASTATE_MATURE)
	return EINVAL;
      break;
    case SADB_ADD:
      if (((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_state !=
	  SADB_SASTATE_MATURE)
	return EINVAL;
      break;
  }
d942 1
a942 1
  return 0;
@


1.25
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a70 1
#include <sys/types.h>
d72 1
a73 1
#include <sys/systm.h>
a74 3
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/socketvar.h>
a75 2
#include <net/route.h>
#include <netinet/in.h>
@


1.24
log
@Make our pfkeyv2.h more RFC2367 compliant.  Also fix some backwards
compatibility problems in isakmpd, at least 2.8 stable can compile current
isakmpd now.  angelos@@ ok
@
text
@d1 2
d4 38
a41 8
%%% copyright-nrl-97
This software is Copyright 1997-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
d43 27
a69 7
%%% copyright-cmetz-97
This software is Copyright 1997-1998 by Craig Metz, All Rights Reserved.
The Inner Net License Version 2 applies to this software.
You should have received a copy of the license with this software. If
you didn't get a copy, you may request one from <license@@inner.net>.

*/
@


1.23
log
@Import/export authentication information for SA.
@
text
@d317 1
a317 1
        if (i != sizeof(struct sadb_policy))
d426 1
a426 1
	  struct sadb_cred *sadb_cred = (struct sadb_cred *)p;
d428 1
a428 1
	  if (i < sizeof(struct sadb_cred))
d431 1
a431 1
	  if (sadb_cred->sadb_cred_type > SADB_AUTHTYPE_MAX)
d434 1
a434 1
	  if (sadb_cred->sadb_cred_reserved)
d441 1
a441 1
          struct sadb_cred *sadb_cred = (struct sadb_cred *)p;
d443 1
a443 1
	  if (i < sizeof(struct sadb_cred))
d446 1
a446 1
	  if (sadb_cred->sadb_cred_type > SADB_CREDTYPE_MAX)
d449 1
a449 1
	  if (sadb_cred->sadb_cred_reserved)
@


1.22
log
@Check the LOCAL_AUTH payload.
@
text
@d66 2
a67 1
#define BITMAP_X_CREDENTIALS           (BITMAP_X_LOCAL_CREDENTIALS | BITMAP_X_REMOTE_CREDENTIALS | BITMAP_X_LOCAL_AUTH)
d424 1
@


1.21
log
@Use the new M_* malloc types
@
text
@d63 4
a66 3
#define BITMAP_X_LOCAL_CREDENTIALS       (1 << SADB_X_EXT_LOCAL_CREDENTIALS)
#define BITMAP_X_REMOTE_CREDENTIALS       (1 << SADB_X_EXT_REMOTE_CREDENTIALS)
#define BITMAP_X_CREDENTIALS           (BITMAP_X_LOCAL_CREDENTIALS | BITMAP_X_REMOTE_CREDENTIALS)
d419 14
@


1.20
log
@Include NUL-termination in identity extension length computation
@
text
@d63 3
a65 3
#define BITMAP_X_SRC_CREDENTIALS       (1 << SADB_X_EXT_SRC_CREDENTIALS)
#define BITMAP_X_DST_CREDENTIALS       (1 << SADB_X_EXT_DST_CREDENTIALS)
#define BITMAP_X_CREDENTIALS           (BITMAP_X_SRC_CREDENTIALS | BITMAP_X_DST_CREDENTIALS)
d421 2
a422 2
     case SADB_X_EXT_SRC_CREDENTIALS:
     case SADB_X_EXT_DST_CREDENTIALS:
@


1.19
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d457 1
a457 1
	    j = ((strlen(c) + sizeof(uint64_t) - 1) & ~(sizeof(uint64_t)-1)) +
@


1.18
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d66 1
d75 1
a75 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS,
d77 1
a77 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS,
d147 1
a147 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS,
d149 1
a149 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS,
@


1.17
log
@Don't force sin6_port to be zero.
@
text
@d63 3
a65 1
#define BITMAP_X_CREDENTIALS           (1 << SADB_X_EXT_CREDENTIALS)
d420 2
a421 1
     case SADB_X_EXT_CREDENTIALS:
@


1.16
log
@Import/export credentials from TDB.
@
text
@a388 3
	      if (((struct sockaddr_in6 *)sa)->sin6_port)
		return EINVAL;

@


1.15
log
@sync with pfkey rfc.  you need to rebuild ipsecadm and isakmpd after this.
okay angelos@@
@
text
@d63 1
d72 1
a72 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY,
d74 1
a74 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY,
d144 1
a144 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY,
d146 1
a146 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY,
d418 14
@


1.14
log
@ASKPOLICY message; used by key management to inquire about policy
triggering an ACQUIRE.
@
text
@d46 2
a47 1
#define BITMAP_SUPPORTED               (1 << SADB_EXT_SUPPORTED)
d153 1
a153 1
  BITMAP_SUPPORTED,
d189 1
a189 1
  BITMAP_SUPPORTED,
d495 2
a496 1
      case SADB_EXT_SUPPORTED:
a506 5
	  if (i != ((sadb_supported->sadb_supported_nauth +
		     sadb_supported->sadb_supported_nencrypt) *
		    sizeof(struct sadb_alg)) + sizeof(struct sadb_supported))
	    return EINVAL;

d509 1
a509 3
	    for (j = 0; j < sadb_supported->sadb_supported_nauth; j++) {
	      if (sadb_alg->sadb_alg_type > SADB_AALG_MAX)
		return EINVAL;
d511 2
a512 2
	      if (sadb_alg->sadb_alg_reserved)
		return EINVAL;
d514 2
a515 4
	      sadb_alg++;
	    }
	    for (j = 0; j < sadb_supported->sadb_supported_nencrypt; j++) {
	      if (sadb_alg->sadb_alg_type > SADB_EALG_MAX)
@


1.13
log
@Don't use an SA payload for ADDFLOW/DELFLOW.
@
text
@d61 1
d78 1
a78 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK,
d95 2
d131 2
d150 1
a150 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK,
d167 2
d203 2
d308 4
@


1.12
log
@Correctly handle srcid/dstid.
@
text
@d89 1
a89 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
d91 1
a91 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_SA | BITMAP_ADDRESS_DST | BITMAP_X_FLOW_TYPE,
d157 1
a157 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
d159 1
a159 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_SA | BITMAP_ADDRESS_DST | BITMAP_X_FLOW_TYPE,
@


1.11
log
@Allow IDENTITY payloads in ADDFLOW messages.
@
text
@d89 1
a89 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST ,
d157 1
a157 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST ,
@


1.10
log
@SA bundles.
@
text
@d89 1
a89 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
d157 1
a157 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
@


1.9
log
@SPD-driven IPsec.
@
text
@d59 2
d92 2
d126 2
d160 2
d194 2
d272 1
d314 1
@


1.8
log
@Allow BITMAP_ADDRESS_DST in ADDFLOW messages.
@
text
@d30 1
a55 1
#define BITMAP_X_SA2                   (1 << SADB_X_EXT_SA2)
d58 1
a58 1
#define BITMAP_X_DST2                  (1 << SADB_X_EXT_DST2)
d75 1
a75 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL,
d87 1
a87 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW,
d89 1
a89 5
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_SA | BITMAP_ADDRESS_DST,
  /* X_GRPSPIS */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
  /* X_BINDSA */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL
d119 1
a119 1
  BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW,
d121 1
a121 5
  BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW,
  /* X_GRPSPIS */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
  /* X_BINDSA */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL
d139 1
a139 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL,
d151 1
a151 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW,
d153 1
a153 5
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_SA | BITMAP_ADDRESS_DST,
  /* X_GRPSPIS */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
  /* X_BINDSA */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL
d183 1
a183 1
  BITMAP_ADDRESS_DST | BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW,
d185 1
a185 5
  BITMAP_SA | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW,
  /* X_GRPSPIS */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
  /* X_BINDSA */
  BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL
a260 1
      case SADB_X_EXT_SA2:
d285 1
a298 1
      case SADB_X_EXT_DST2:
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@a29 1
#include <netinet/ip_ipsp.h>
d45 1
a45 2
#define BITMAP_SUPPORTED_AUTH          (1 << SADB_EXT_SUPPORTED_AUTH)
#define BITMAP_SUPPORTED_ENCRYPT       (1 << SADB_EXT_SUPPORTED_ENCRYPT)
d55 1
a57 2
#define BITMAP_X_FLOW_TYPE             (1 << SADB_X_EXT_FLOW_TYPE)
#define BITMAP_X_SA2                   (1 << SADB_X_EXT_SA2)
a58 5
#define BITMAP_X_POLICY                (1 << SADB_X_EXT_POLICY)
#define BITMAP_X_SRC_CREDENTIALS       (1 << SADB_X_EXT_SRC_CREDENTIALS)
#define BITMAP_X_DST_CREDENTIALS       (1 << SADB_X_EXT_DST_CREDENTIALS)
#define BITMAP_X_CREDENTIALS           (BITMAP_X_SRC_CREDENTIALS | BITMAP_X_DST_CREDENTIALS)
#define BITMAP_X_FLOW                  (BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW)
d67 1
a67 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
d69 1
a69 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
d87 1
a87 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
d89 1
a89 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
d92 2
a93 2
  /* X_ASKPOLICY */
  BITMAP_X_POLICY,
d123 1
a123 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
d125 1
a125 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
d128 2
a129 2
  /* X_ASKPOLICY */
  BITMAP_X_POLICY,
d139 1
a139 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
d141 1
a141 1
  BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
d149 1
a149 1
  BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT,
d159 1
a159 1
  BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
d161 1
a161 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
d164 2
a165 2
  /* X_ASKPOLICY */
  BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE | BITMAP_X_POLICY,
d185 1
a185 1
  BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT,
d195 1
a195 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
d197 1
a197 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
d200 2
a201 2
  /* X_REPPOLICY */
  BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE,
d277 1
a278 1
      case SADB_X_EXT_SA2:
a301 1
      case SADB_X_EXT_FLOW_TYPE:
a304 4
      case SADB_X_EXT_POLICY:
        if (i != sizeof(struct sadb_policy))
	  return EINVAL;
	break;
d315 1
a319 1
      case SADB_X_EXT_DST2:
d379 3
a410 15
     case SADB_X_EXT_SRC_CREDENTIALS:
     case SADB_X_EXT_DST_CREDENTIALS:
	{
          struct sadb_cred *sadb_cred = (struct sadb_cred *)p;

	  if (i < sizeof(struct sadb_cred))
	    return EINVAL;

	  if (sadb_cred->sadb_cred_type > SADB_CREDTYPE_MAX)
	    return EINVAL;

	  if (sadb_cred->sadb_cred_reserved)
	    return EINVAL;
	}
	break;
d486 1
a486 2
      case SADB_EXT_SUPPORTED_AUTH:
      case SADB_EXT_SUPPORTED_ENCRYPT:
d497 5
d504 3
a506 1
	    int max_alg;
d508 2
a509 2
	    max_alg = sadb_ext->sadb_ext_type == SADB_EXT_SUPPORTED_AUTH ?
		    SADB_AALG_MAX : SADB_EALG_MAX;
d511 4
a514 2
	    for (j = 0; j < sadb_supported->sadb_supported_len - 1; j++) {
	      if (sadb_alg->sadb_alg_id > max_alg)
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@a0 2
/*	$OpenBSD$	*/

d2 14
a15 38
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d17 1
a17 27
/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Craig Metz. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
d19 1
d21 1
a22 1
#include <sys/socket.h>
d24 3
d28 2
a32 8
extern int encdebug;

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

d63 3
a65 5
#define BITMAP_X_LOCAL_CREDENTIALS     (1 << SADB_X_EXT_LOCAL_CREDENTIALS)
#define BITMAP_X_REMOTE_CREDENTIALS    (1 << SADB_X_EXT_REMOTE_CREDENTIALS)
#define BITMAP_X_LOCAL_AUTH            (1 << SADB_X_EXT_LOCAL_AUTH)
#define BITMAP_X_REMOTE_AUTH           (1 << SADB_X_EXT_REMOTE_AUTH)
#define BITMAP_X_CREDENTIALS           (BITMAP_X_LOCAL_CREDENTIALS | BITMAP_X_REMOTE_CREDENTIALS | BITMAP_X_LOCAL_AUTH | BITMAP_X_REMOTE_AUTH)
d219 56
a274 4
	struct sadb_ext *sadb_ext;
	int i, left = len;
	uint32_t allow, seen = 1;
	struct sadb_msg *sadb_msg = (struct sadb_msg *) p;
d276 2
a277 1
	bzero(headers, (SADB_EXT_MAX + 1) * sizeof(void *));
d279 45
a323 3
	if (left < sizeof(struct sadb_msg)) {
		DPRINTF(("pfkeyv2_parsemessage: message too short\n"));
		return EINVAL;
d325 12
d338 2
a339 1
	headers[0] = p;
d341 15
a355 2
	if (sadb_msg->sadb_msg_len * sizeof(uint64_t) != left) {
		DPRINTF(("pfkeyv2_parsemessage: length not a multiple of 64\n"));
d357 1
a357 1
	}
d359 14
a372 2
	p += sizeof(struct sadb_msg);
	left -= sizeof(struct sadb_msg);
d374 13
a386 3
	if (sadb_msg->sadb_msg_reserved) {
		DPRINTF(("pfkeyv2_parsemessage: message header reserved "
		    "field set\n"));
a387 1
	}
d389 1
a389 3
	if (sadb_msg->sadb_msg_type > SADB_MAX) {
		DPRINTF(("pfkeyv2_parsemessage: message type > %d\n",
		    SADB_MAX));
a390 1
	}
d392 1
a392 2
	if (!sadb_msg->sadb_msg_type) {
		DPRINTF(("pfkeyv2_parsemessage: message type unset\n"));
d394 25
d420 5
d426 2
a427 4
	if (sadb_msg->sadb_msg_pid != curproc->p_pid) {
		DPRINTF(("pfkeyv2_parsemessage: bad PID value\n"));
		return EINVAL;
	}
d429 2
a430 7
	if (sadb_msg->sadb_msg_errno) {
		if (left) {
			DPRINTF(("pfkeyv2_parsemessage: too-large error message\n"));
			return EINVAL;
		}
		return 0;
	}
d432 2
a433 3
	if (sadb_msg->sadb_msg_type == SADB_X_PROMISC) {
		DPRINTF(("pfkeyv2_parsemessage: message type promiscuous\n"));
		return 0;
d435 5
d441 2
a442 1
	allow = sadb_exts_allowed_in[sadb_msg->sadb_msg_type];
d444 2
a445 7
	while (left > 0) {
		sadb_ext = (struct sadb_ext *)p;
		if (left < sizeof(struct sadb_ext)) {
			DPRINTF(("pfkeyv2_parsemessage: extension header too "
			    "short\n"));
			return EINVAL;
		}
d447 2
a448 6
		i = sadb_ext->sadb_ext_len * sizeof(uint64_t);
		if (left < i) {
			DPRINTF(("pfkeyv2_parsemessage: extension header "
			    "exceeds message length\n"));
			return EINVAL;
		}
d450 3
a452 5
		if (sadb_ext->sadb_ext_type > SADB_EXT_MAX) {
			DPRINTF(("pfkeyv2_parsemessage: unknown extension "
			    "header %d\n", sadb_ext->sadb_ext_type));
			return EINVAL;
		}
d454 2
a455 5
		if (!sadb_ext->sadb_ext_type) {
			DPRINTF(("pfkeyv2_parsemessage: unset extension "
			    "header\n"));
			return EINVAL;
		}
d457 2
a458 6
		if (!(allow & (1 << sadb_ext->sadb_ext_type))) {
			DPRINTF(("pfkeyv2_parsemessage: extension header %d "
			    "not permitted on message type %d\n",
			    sadb_ext->sadb_ext_type, sadb_msg->sadb_msg_type));
			return EINVAL;
		}
d460 8
a467 5
		if (headers[sadb_ext->sadb_ext_type]) {
			DPRINTF(("pfkeyv2_parsemessage: duplicate extension "
			    "header %d\n", sadb_ext->sadb_ext_type));
			return EINVAL;
		}
d469 2
a470 1
		seen |= (1 << sadb_ext->sadb_ext_type);
d472 4
a475 550
		switch (sadb_ext->sadb_ext_type) {
		case SADB_EXT_SA:
		case SADB_X_EXT_SA2:
		{
			struct sadb_sa *sadb_sa = (struct sadb_sa *)p;

			if (i != sizeof(struct sadb_sa)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for SA extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_sa->sadb_sa_state > SADB_SASTATE_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown SA "
				    "state %d in SA extension header %d\n",
				    sadb_sa->sadb_sa_state,
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_sa->sadb_sa_state == SADB_SASTATE_DEAD) {
				DPRINTF(("pfkeyv2_parsemessage: cannot set SA "
				    "state to dead, SA extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_sa->sadb_sa_encrypt > SADB_EALG_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "encryption algorithm %d in SA extension "
				    "header %d\n", sadb_sa->sadb_sa_encrypt,
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_sa->sadb_sa_auth > SADB_AALG_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "authentication algorithm %d in SA "
				    "extension header %d\n",
				    sadb_sa->sadb_sa_auth,
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_sa->sadb_sa_replay > 32) {
				DPRINTF(("pfkeyv2_parsemessage: unsupported "
				    "replay window size %d in SA extension "
				    "header %d\n", sadb_sa->sadb_sa_replay,
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}
		}
		break;
		case SADB_X_EXT_PROTOCOL:
		case SADB_X_EXT_FLOW_TYPE:
			if (i != sizeof(struct sadb_protocol)) {
				DPRINTF(("pfkeyv2_parsemessage: bad "
				    "PROTOCOL/FLOW header length in extension "
				    "header %d\n", sadb_ext->sadb_ext_type));
				return EINVAL;
			}
			break;
		case SADB_X_EXT_POLICY:
			if (i != sizeof(struct sadb_x_policy)) {
				DPRINTF(("pfkeyv2_parsemessage: bad POLICY "
				    "header length\n"));
				return EINVAL;
			}
			break;
		case SADB_EXT_LIFETIME_CURRENT:
		case SADB_EXT_LIFETIME_HARD:
		case SADB_EXT_LIFETIME_SOFT:
			if (i != sizeof(struct sadb_lifetime)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for LIFETIME extension header "
				    "%d\n", sadb_ext->sadb_ext_type));
				return EINVAL;
			}
			break;
		case SADB_EXT_ADDRESS_SRC:
		case SADB_EXT_ADDRESS_DST:
		case SADB_X_EXT_SRC_MASK:
		case SADB_X_EXT_DST_MASK:
		case SADB_X_EXT_SRC_FLOW:
		case SADB_X_EXT_DST_FLOW:
		case SADB_X_EXT_DST2:
		case SADB_EXT_ADDRESS_PROXY:
		{
			struct sadb_address *sadb_address =
			    (struct sadb_address *)p;
			struct sockaddr *sa = (struct sockaddr *)(p +
			    sizeof(struct sadb_address));

			if (i < sizeof(struct sadb_address) +
			    sizeof(struct sockaddr)) {
				DPRINTF(("pfkeyv2_parsemessage: bad ADDRESS "
				    "extension header %d length\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_address->sadb_address_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: ADDRESS "
				    "extension header %d reserved field set\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}
			if (sa->sa_len &&
			    (i != sizeof(struct sadb_address) +
			    PADUP(sa->sa_len))) {
				DPRINTF(("pfkeyv2_parsemessage: bad sockaddr "
				    "length field in ADDRESS extension "
				    "header %d\n", sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			switch(sa->sa_family) {
			case AF_INET:
				if (sizeof(struct sadb_address) +
				    PADUP(sizeof(struct sockaddr_in)) != i) {
					DPRINTF(("pfkeyv2_parsemessage: "
					    "invalid ADDRESS extension header "
					    "%d length\n",
					    sadb_ext->sadb_ext_type));
					return EINVAL;
				}

				if (sa->sa_len != sizeof(struct sockaddr_in)) {
					DPRINTF(("pfkeyv2_parsemessage: bad "
					    "sockaddr_in length in ADDRESS "
					    "extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return EINVAL;
				}

				/* Only check the right pieces */
				switch (sadb_ext->sadb_ext_type)
				{
				case SADB_X_EXT_SRC_MASK:
				case SADB_X_EXT_DST_MASK:
				case SADB_X_EXT_SRC_FLOW:
				case SADB_X_EXT_DST_FLOW:
					break;
		      
				default:
					if (((struct sockaddr_in *)sa)->sin_port) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": port field set in "
						    "sockaddr_in of ADDRESS "
						    "extension header %d\n",
						    sadb_ext->sadb_ext_type));
						return EINVAL;
					}
					break;
				}

				{
					char zero[sizeof(((struct sockaddr_in *)sa)->sin_zero)];
					bzero(zero, sizeof(zero));

					if (bcmp(&((struct sockaddr_in *)sa)->sin_zero, zero, sizeof(zero))) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": reserved sockaddr_in "
						    "field non-zero'ed in "
						    "ADDRESS extension header "
						    "%d\n",
						    sadb_ext->sadb_ext_type));
						return EINVAL;
					}
				}
				break;
#if INET6
			case AF_INET6:
				if (i != sizeof(struct sadb_address) +
				    PADUP(sizeof(struct sockaddr_in6))) {
					DPRINTF(("pfkeyv2_parsemessage: "
					    "invalid sockaddr_in6 length in "
					    "ADDRESS extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return EINVAL;
				}

				if (sa->sa_len !=
				    sizeof(struct sockaddr_in6)) {
					DPRINTF(("pfkeyv2_parsemessage: bad "
					    "sockaddr_in6 length in ADDRESS "
					    "extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return EINVAL;
				}

				if (((struct sockaddr_in6 *)sa)->sin6_flowinfo) {
					DPRINTF(("pfkeyv2_parsemessage: "
					    "flowinfo field set in "
					    "sockaddr_in6 of ADDRESS "
					    "extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return EINVAL;
				}

				/* Only check the right pieces */
				switch (sadb_ext->sadb_ext_type)
				{
				case SADB_X_EXT_SRC_MASK:
				case SADB_X_EXT_DST_MASK:
				case SADB_X_EXT_SRC_FLOW:
				case SADB_X_EXT_DST_FLOW:
					break;
		      
				default:
					if (((struct sockaddr_in6 *)sa)->sin6_port) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": port field set in "
						    "sockaddr_in6 of ADDRESS "
						    "extension header %d\n",
						    sadb_ext->sadb_ext_type));
						return EINVAL;
					}
					break;
				}
				break;
#endif /* INET6 */
			default:
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "address family %d in ADDRESS extension "
				    "header %d\n",
				    sa->sa_family, sadb_ext->sadb_ext_type));
				return EINVAL;
			}
		}
		break;
		case SADB_EXT_KEY_AUTH:
		case SADB_EXT_KEY_ENCRYPT:
		{
			struct sadb_key *sadb_key = (struct sadb_key *)p;

			if (i < sizeof(struct sadb_key)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length in KEY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (!sadb_key->sadb_key_bits) {
				DPRINTF(("pfkeyv2_parsemessage: key length "
				    "unset in KEY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (((sadb_key->sadb_key_bits + 63) / 64) * sizeof(uint64_t) != i - sizeof(struct sadb_key)) {
				DPRINTF(("pfkeyv2_parsemessage: invalid key "
				    "length in KEY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_key->sadb_key_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved field"
				    " set in KEY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}
		}
		break;
		case SADB_X_EXT_LOCAL_AUTH:
		case SADB_X_EXT_REMOTE_AUTH:
		{
			struct sadb_x_cred *sadb_cred =
			    (struct sadb_x_cred *)p;

			if (i < sizeof(struct sadb_x_cred)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for AUTH extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_cred->sadb_x_cred_type > SADB_X_AUTHTYPE_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown auth "
				    "type %d in AUTH extension header %d\n",
				    sadb_cred->sadb_x_cred_type, 
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_cred->sadb_x_cred_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved field"
				    " set in AUTH extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}
		}
		break;
		case SADB_X_EXT_LOCAL_CREDENTIALS:
		case SADB_X_EXT_REMOTE_CREDENTIALS:
		{
			struct sadb_x_cred *sadb_cred =
			    (struct sadb_x_cred *)p;

			if (i < sizeof(struct sadb_x_cred)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length of CREDENTIALS extension header "
				    "%d\n", sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_cred->sadb_x_cred_type > SADB_X_CREDTYPE_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "credential type %d in CREDENTIALS "
				    "extension header %d\n",
				    sadb_cred->sadb_x_cred_type,
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_cred->sadb_x_cred_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved "
				    "field set in CREDENTIALS extension "
				    "header %d\n", sadb_ext->sadb_ext_type));
				return EINVAL;
			}
		}
		break;
		case SADB_EXT_IDENTITY_SRC:
		case SADB_EXT_IDENTITY_DST:
		{
			struct sadb_ident *sadb_ident = (struct sadb_ident *)p;

			if (i < sizeof(struct sadb_ident)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length of IDENTITY extension header %d\n",
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_ident->sadb_ident_type > SADB_IDENTTYPE_MAX) {
				DPRINTF(("pfkeyv2_parsemessage: unknown "
				    "identity type %d in IDENTITY extension "
				    "header %d\n",
				    sadb_ident->sadb_ident_type,
				    sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_ident->sadb_ident_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved "
				    "field set in IDENTITY extension header "
				    "%d\n", sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (i > sizeof(struct sadb_ident)) {
				char *c =
				    (char *)(p + sizeof(struct sadb_ident));
				int j;

				if (*(char *)(p + i - 1)) {
					DPRINTF(("pfkeyv2_parsemessage: non "
					    "NUL-terminated identity in "
					    "IDENTITY extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return EINVAL;
				}

				j = ((strlen(c) + sizeof(uint64_t)) &
				    ~(sizeof(uint64_t)-1)) +
				    sizeof(struct sadb_ident);

				if (i != j) {
					DPRINTF(("pfkeyv2_parsemessage: actual"
					    " identity length does not match "
					    "expected length in identity "
					    "extension header %d\n",
					    sadb_ext->sadb_ext_type));
					return EINVAL;
				}
			}
		}
		break;
		case SADB_EXT_SENSITIVITY:
		{
			struct sadb_sens *sadb_sens = (struct sadb_sens *)p;

			if (i < sizeof(struct sadb_sens)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for SENSITIVITY extension "
				    "header\n"));
				return EINVAL;
			}

			if (i != (sadb_sens->sadb_sens_sens_len +
			    sadb_sens->sadb_sens_integ_len) *
			    sizeof(uint64_t) +
			    sizeof(struct sadb_sens)) {
				DPRINTF(("pfkeyv2_parsemessage: bad payload "
				    "length for SENSITIVITY extension "
				    "header\n"));
				return EINVAL;
			}
		}
		break;
		case SADB_EXT_PROPOSAL:
		{
			struct sadb_prop *sadb_prop = (struct sadb_prop *)p;

			if (i < sizeof(struct sadb_prop)) {
				DPRINTF(("pfkeyv2_parsemessage: bad PROPOSAL "
				    "header length\n"));
				return EINVAL;
			}

			if (sadb_prop->sadb_prop_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved field"
				    "set in PROPOSAL extension header\n"));
				return EINVAL;
			}

			if ((i - sizeof(struct sadb_prop)) %
			    sizeof(struct sadb_comb)) {
				DPRINTF(("pfkeyv2_parsemessage: bad proposal "
				    "length\n"));
				return EINVAL;
			}

			{
				struct sadb_comb *sadb_comb =
				    (struct sadb_comb *)(p +
					sizeof(struct sadb_prop));
				int j;

				for (j = 0;
				     j < (i - sizeof(struct sadb_prop))/sizeof(struct sadb_comb);
				     j++) {
					if (sadb_comb->sadb_comb_auth >
					    SADB_AALG_MAX) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": unknown authentication "
						    "algorithm %d in "
						    "PROPOSAL\n",
						    sadb_comb->sadb_comb_auth));
						return EINVAL;
					}

					if (sadb_comb->sadb_comb_encrypt >
					    SADB_EALG_MAX) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": unknown encryption "
						    "algorithm %d in "
						    "PROPOSAL\n",
						    sadb_comb->sadb_comb_encrypt));
						return EINVAL;
					}

					if (sadb_comb->sadb_comb_reserved) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": reserved field set in "
						    "COMB header\n"));
						return EINVAL;
					}
				}
			}
		}
		break;
		case SADB_EXT_SUPPORTED_AUTH:
		case SADB_EXT_SUPPORTED_ENCRYPT:
		{
			struct sadb_supported *sadb_supported =
			    (struct sadb_supported *)p;
			int j;

			if (i < sizeof(struct sadb_supported)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length for SUPPORTED extension header "
				    "%d\n", sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			if (sadb_supported->sadb_supported_reserved) {
				DPRINTF(("pfkeyv2_parsemessage: reserved "
				    "field set in SUPPORTED extension "
				    "header %d\n", sadb_ext->sadb_ext_type));
				return EINVAL;
			}

			{
				struct sadb_alg *sadb_alg =
				    (struct sadb_alg *)(p +
					sizeof(struct sadb_supported));
				int max_alg;

				max_alg = sadb_ext->sadb_ext_type == SADB_EXT_SUPPORTED_AUTH ?
				    SADB_AALG_MAX : SADB_EALG_MAX;

				for (j = 0; j < sadb_supported->sadb_supported_len - 1; j++) {
					if (sadb_alg->sadb_alg_id > max_alg) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": unknown algorithm %d "
						    "in SUPPORTED extension "
						    "header %d\n",
						    sadb_alg->sadb_alg_id,
						    sadb_ext->sadb_ext_type));
						return EINVAL;
					}

					if (sadb_alg->sadb_alg_reserved) {
						DPRINTF(("pfkeyv2_parsemessage"
						    ": reserved field set in "
						    "supported algorithms "
						    "header inside SUPPORTED "
						    "extension header %d\n",
						    sadb_ext->sadb_ext_type));
						return EINVAL;
					}

					sadb_alg++;
				}
			}
		}
		break;
		case SADB_EXT_SPIRANGE:
		{
			struct sadb_spirange *sadb_spirange =
			    (struct sadb_spirange *)p;

			if (i != sizeof(struct sadb_spirange)) {
				DPRINTF(("pfkeyv2_parsemessage: bad header "
				    "length of SPIRANGE extension header\n"));
				return EINVAL;
			}

			if (sadb_spirange->sadb_spirange_min >
			    sadb_spirange->sadb_spirange_max) {
				DPRINTF(("pfkeyv2_parsemessage: bad SPI "
				    "range\n"));
				return EINVAL;
			}
		}
		break;
		default:
			DPRINTF(("pfkeyv2_parsemessage: unknown extension "
			    "header type %d\n",
			    sadb_ext->sadb_ext_type));
			return EINVAL;
		}
  
		headers[sadb_ext->sadb_ext_type] = p;
		p += i;
		left -= i;
d477 7
d485 20
a504 2
	if (left) {
		DPRINTF(("pfkeyv2_parsemessage: message too long\n"));
d506 3
d510 16
d527 6
a532 2
	{
		uint32_t required;
d534 2
a535 1
		required = sadb_exts_required_in[sadb_msg->sadb_msg_type];
d537 3
a539 5
		if ((seen & required) != required) {
			DPRINTF(("pfkeyv2_parsemessage: required fields "
			    "missing\n"));
			return EINVAL;
		}
d541 4
d546 41
a586 18
	switch(((struct sadb_msg *)headers[0])->sadb_msg_type) {
	case SADB_UPDATE:
		if (((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_state !=
		    SADB_SASTATE_MATURE) {
			DPRINTF(("pfkeyv2_parsemessage: updating non-mature "
			    "SA prohibited\n"));
			return EINVAL;
		}
		break;
	case SADB_ADD:
		if (((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_state !=
		    SADB_SASTATE_MATURE) {
			DPRINTF(("pfkeyv2_parsemessage: adding non-mature "
			    "SA prohibited\n"));
			return EINVAL;
		}
		break;
	}
d588 1
a588 1
	return 0;
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_parsemessage.c,v 1.8.2.2 2001/07/04 10:54:16 niklas Exp $	*/
a122 1
#define BITMAP_X_SUPPORTED_COMP        (1 << SADB_X_EXT_SUPPORTED_COMP)
d213 1
a213 1
  BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
d249 1
a249 1
  BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
d742 2
a743 1
				j = PADUP(strlen(c) + 1) +
a842 1
		case SADB_X_EXT_SUPPORTED_COMP:
d869 1
a869 2
				    SADB_AALG_MAX : SADB_EXT_SUPPORTED_ENCRYPT ?
					SADB_EALG_MAX : SADB_X_CALG_MAX;
@


1.8.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d238 1
a238 1
  BITMAP_SA | BITMAP_ADDRESS_DST,
d240 1
a240 1
  BITMAP_SA | BITMAP_ADDRESS_DST,
d242 1
a242 1
  BITMAP_SA | BITMAP_ADDRESS_DST,
d246 1
a246 1
  BITMAP_SA | BITMAP_LIFETIME_CURRENT | BITMAP_ADDRESS_DST,
d252 1
a252 1
  BITMAP_SA | BITMAP_ADDRESS_DST,
@


1.8.2.5
log
@Sync the SMP branch with 3.3
@
text
@d122 1
a122 1
#define BITMAP_X_FLOW                  (BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE)
d127 32
a158 32
	/* RESERVED */
	~0,
	/* GETSPI */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SPIRANGE,
	/* UPDATE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
	/* ADD */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
	/* REGISTER */
	0,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST | BITMAP_X_FLOW,
	/* X_DELFLOW */
	BITMAP_X_FLOW,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
	/* X_ASKPOLICY */
	BITMAP_X_POLICY,
d163 32
a194 32
	/* RESERVED */
	0,
	/* GETSPI */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_SPIRANGE,
	/* UPDATE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* ADD */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	0,
	/* REGISTER */
	0,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
	/* X_ASKPOLICY */
	BITMAP_X_POLICY,
d199 32
a230 32
	/* RESERVED */
	~0,
	/* GETSPI */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* UPDATE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
	/* ADD */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY,
	/* ACQUIRE */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_IDENTITY | BITMAP_PROPOSAL | BITMAP_X_CREDENTIALS,
	/* REGISTER */
	BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
	/* EXPIRE */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS,
	/* FLUSH */
	0,
	/* DUMP */
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_ADDRESS_SRC | BITMAP_ADDRESS_DST | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE | BITMAP_IDENTITY_SRC | BITMAP_IDENTITY_DST,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
	/* X_ASKPOLICY */
	BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE | BITMAP_X_POLICY,
d235 32
a266 32
	/* RESERVED */
	0,
	/* GETSPI */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* UPDATE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* ADD */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* DELETE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* GET */
	BITMAP_SA | BITMAP_LIFETIME_CURRENT | BITMAP_ADDRESS_DST,
	/* ACQUIRE */
	0,
	/* REGISTER */
	BITMAP_SUPPORTED_AUTH | BITMAP_SUPPORTED_ENCRYPT | BITMAP_X_SUPPORTED_COMP,
	/* EXPIRE */
	BITMAP_SA | BITMAP_ADDRESS_DST,
	/* FLUSH */
	0,
	/* DUMP */
	0,
	/* X_PROMISC */
	0,
	/* X_ADDFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_DELFLOW */
	BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_FLOW_TYPE,
	/* X_GRPSPIS */
	BITMAP_SA | BITMAP_X_SA2 | BITMAP_X_DST2 | BITMAP_ADDRESS_DST | BITMAP_X_PROTOCOL,
	/* X_REPPOLICY */
	BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_FLOW_TYPE,
d285 1
a285 1
		return (EINVAL);
d292 1
a292 1
		return (EINVAL);
d301 1
a301 1
		return (EINVAL);
d307 1
a307 1
		return (EINVAL);
d312 1
a312 1
		return (EINVAL);
d317 1
a317 1
		return (EINVAL);
d323 1
a323 1
			return (EINVAL);
d325 1
a325 1
		return (0);
d330 1
a330 1
		return (0);
d340 1
a340 1
			return (EINVAL);
d347 1
a347 1
			return (EINVAL);
d353 1
a353 1
			return (EINVAL);
d359 1
a359 1
			return (EINVAL);
d366 1
a366 1
			return (EINVAL);
d372 1
a372 1
			return (EINVAL);
d387 1
a387 1
				return (EINVAL);
d395 1
a395 1
				return (EINVAL);
d402 1
a402 1
				return (EINVAL);
d410 1
a410 1
				return (EINVAL);
d419 1
a419 1
				return (EINVAL);
d427 1
a427 1
				return (EINVAL);
d437 1
a437 1
				return (EINVAL);
d444 1
a444 1
				return (EINVAL);
d454 1
a454 1
				return (EINVAL);
d476 1
a476 1
				return (EINVAL);
d483 1
a483 1
				return (EINVAL);
d491 1
a491 1
				return (EINVAL);
d494 1
a494 1
			switch (sa->sa_family) {
d502 1
a502 1
					return (EINVAL);
d510 1
a510 1
					return (EINVAL);
d521 1
a521 1

d529 1
a529 1
						return (EINVAL);
d545 1
a545 1
						return (EINVAL);
d557 1
a557 1
					return (EINVAL);
d566 1
a566 1
					return (EINVAL);
d575 1
a575 1
					return (EINVAL);
d586 1
a586 1

d594 1
a594 1
						return (EINVAL);
d605 1
a605 1
				return (EINVAL);
d618 1
a618 1
				return (EINVAL);
d625 1
a625 1
				return (EINVAL);
d632 1
a632 1
				return (EINVAL);
d639 1
a639 1
				return (EINVAL);
d653 1
a653 1
				return (EINVAL);
d659 1
a659 1
				    sadb_cred->sadb_x_cred_type,
d661 1
a661 1
				return (EINVAL);
d668 1
a668 1
				return (EINVAL);
d682 1
a682 1
				return (EINVAL);
d691 1
a691 1
				return (EINVAL);
d698 1
a698 1
				return (EINVAL);
d711 1
a711 1
				return (EINVAL);
d720 1
a720 1
				return (EINVAL);
d727 1
a727 1
				return (EINVAL);
d740 1
a740 1
					return (EINVAL);
d752 1
a752 1
					return (EINVAL);
d765 1
a765 1
				return (EINVAL);
d775 1
a775 1
				return (EINVAL);
d786 1
a786 1
				return (EINVAL);
d792 1
a792 1
				return (EINVAL);
d799 1
a799 1
				return (EINVAL);
d809 2
a810 3
				    j < (i - sizeof(struct sadb_prop))/
				    sizeof(struct sadb_comb);
				    j++) {
d818 1
a818 1
						return (EINVAL);
d828 1
a828 1
						return (EINVAL);
d835 1
a835 1
						return (EINVAL);
d853 1
a853 1
				return (EINVAL);
d860 1
a860 1
				return (EINVAL);
d869 1
a869 2
				max_alg = sadb_ext->sadb_ext_type ==
				    SADB_EXT_SUPPORTED_AUTH ?
d871 1
a871 1
				    SADB_EALG_MAX : SADB_X_CALG_MAX;
d873 1
a873 3
				for (j = 0;
				    j < sadb_supported->sadb_supported_len - 1;
				    j++) {
d881 1
a881 1
						return (EINVAL);
d891 1
a891 1
						return (EINVAL);
d907 1
a907 1
				return (EINVAL);
d914 1
a914 1
				return (EINVAL);
d922 1
a922 1
			return (EINVAL);
d924 1
a924 1

d932 1
a932 1
		return (EINVAL);
d943 1
a943 1
			return (EINVAL);
d947 1
a947 1
	switch (((struct sadb_msg *)headers[0])->sadb_msg_type) {
d953 1
a953 1
			return (EINVAL);
d961 1
a961 1
			return (EINVAL);
d966 1
a966 1
	return (0);
@


1.8.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a123 1
#define BITMAP_X_UDPENCAP              (1 << SADB_X_EXT_UDPENCAP)
d132 1
a132 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP,
d134 1
a134 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_KEY | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP,
d204 1
a204 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP,
d206 1
a206 1
	BITMAP_SA | BITMAP_LIFETIME | BITMAP_ADDRESS | BITMAP_IDENTITY | BITMAP_X_CREDENTIALS | BITMAP_X_FLOW | BITMAP_X_UDPENCAP,
a921 7
		case SADB_X_EXT_UDPENCAP:
			if (i != sizeof(struct sadb_x_udpencap)) {
				DPRINTF(("pfkeyv2_parsemessage: bad UDPENCAP "
				    "header length\n"));
				return (EINVAL);
			}
			break;
@


1.8.2.7
log
@Merge with the trunk
@
text
@a601 4
				if (sadb_msg->sadb_msg_satype ==
				    SADB_X_SATYPE_TCPSIGNATURE &&
				    sa->sa_family == 0)
					break;
@


1.7
log
@sockaddr_in6 is padded to 32 bytes.
@
text
@d89 1
a89 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_SA,
d161 1
a161 1
  BITMAP_X_SRC_MASK | BITMAP_X_DST_MASK | BITMAP_X_PROTOCOL | BITMAP_X_SRC_FLOW | BITMAP_X_DST_FLOW | BITMAP_SA,
@


1.6
log
@rename SADB_foo_X_bar to SADB_X_foo_bar
@
text
@d373 1
a373 1
		  sizeof(struct sockaddr_in6))
@


1.5
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d52 7
a58 7
#define BITMAP_X_SRC_MASK              (1 << SADB_EXT_X_SRC_MASK)
#define BITMAP_X_DST_MASK              (1 << SADB_EXT_X_DST_MASK)
#define BITMAP_X_PROTOCOL              (1 << SADB_EXT_X_PROTOCOL)
#define BITMAP_X_SA2                   (1 << SADB_EXT_X_SA2)
#define BITMAP_X_SRC_FLOW              (1 << SADB_EXT_X_SRC_FLOW)
#define BITMAP_X_DST_FLOW              (1 << SADB_EXT_X_DST_FLOW)
#define BITMAP_X_DST2                  (1 << SADB_EXT_X_DST2)
d277 1
a277 1
      case SADB_EXT_X_SA2:
d301 1
a301 1
      case SADB_EXT_X_PROTOCOL:
d315 5
a319 5
      case SADB_EXT_X_DST2:
      case SADB_EXT_X_SRC_MASK:
      case SADB_EXT_X_DST_MASK:
      case SADB_EXT_X_SRC_FLOW:
      case SADB_EXT_X_DST_FLOW:
d349 4
a352 4
		  case SADB_EXT_X_SRC_MASK:
		  case SADB_EXT_X_DST_MASK:
		  case SADB_EXT_X_SRC_FLOW:
		  case SADB_EXT_X_DST_FLOW:
@


1.4
log
@restrict replay window size to 32
@
text
@d91 2
d127 2
d163 2
d199 2
@


1.3
log
@Allow PF_KEY kernel message replies for X_ADDFLOW, X_DELFLOW, and X_GRPSPIS
@
text
@d288 3
@


1.2
log
@Removed osdep.h dependencies.
@
text
@d155 1
a155 1
  0,
d157 1
a157 1
  0,
d159 1
a159 1
  0
d189 1
a189 1
  0,
d191 1
a191 1
  0,
d193 1
a193 1
  0
@


1.1
log
@PF_KEY_V2, with local extensions for SPD management.
@
text
@d18 12
a29 1
#include <sys/osdep.h>
d230 1
a230 1
  if (sadb_msg->sadb_msg_pid != OSDEP_CURRENTPID)
@

