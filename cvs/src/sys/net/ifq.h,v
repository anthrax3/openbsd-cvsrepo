head	1.12;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5;
locks; strict;
comment	@ * @;


1.12
date	2017.05.03.03.41.09;	author dlg;	state Exp;
branches;
next	1.11;
commitid	lDPcZsasSu1dIT5m;

1.11
date	2017.05.03.03.14.32;	author dlg;	state Exp;
branches;
next	1.10;
commitid	U6vfhWmPzAgKAqe8;

1.10
date	2017.03.07.01.29.53;	author dlg;	state Exp;
branches;
next	1.9;
commitid	So70CRieBADFeXD4;

1.9
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.8;
commitid	6c6qq5OdS4VVnyVM;

1.8
date	2017.01.24.03.57.35;	author dlg;	state Exp;
branches;
next	1.7;
commitid	PERtGPXCvlLRRBr8;

1.7
date	2017.01.22.04.48.23;	author dlg;	state Exp;
branches;
next	1.6;
commitid	mGzVB6IJ6qMfPA8g;

1.6
date	2017.01.20.03.48.03;	author dlg;	state Exp;
branches;
next	1.5;
commitid	GEDLRXNPd1XbyAED;

1.5
date	2016.01.20.17.27.16;	author mikeb;	state Exp;
branches;
next	1.4;
commitid	Sg1vAXtCxQUdYwuz;

1.4
date	2015.12.29.12.35.43;	author dlg;	state Exp;
branches;
next	1.3;
commitid	jmjQ2HY9jy7XMY4d;

1.3
date	2015.12.10.03.05.17;	author dlg;	state Exp;
branches;
next	1.2;
commitid	5A4WNbDa8zPyqdwZ;

1.2
date	2015.12.09.03.22.39;	author dlg;	state Exp;
branches;
next	1.1;
commitid	ORE7f8VM8QK0ujAk;

1.1
date	2015.12.08.10.06.12;	author dlg;	state Exp;
branches;
next	;
commitid	VAQjlQNQBXJ725Km;


desc
@@


1.12
log
@update the stack doco to match reality.

i hadnt documented that api changes made to support multiple ifqueues
on a single ifnet.

a glaring omission is doco for if_attach_queues, but that should
go into a manpage for driver writers to read, not internal doco on
the stack.
@
text
@/*	$OpenBSD: ifq.h,v 1.11 2017/05/03 03:14:32 dlg Exp $ */

/*
 * Copyright (c) 2015 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _NET_IFQ_H_
#define _NET_IFQ_H_

struct ifnet;

struct ifq_ops;

struct ifqueue {
	struct ifnet		*ifq_if;
	union {
		void			*_ifq_softc;
		/*
		 * a rings sndq is found by looking up an array of pointers.
		 * by default we only have one sndq and the default drivers
		 * dont use ifq_softc, so we can borrow it for the map until
		 * we need to allocate a proper map.
		 */
		struct ifqueue		*_ifq_ifqs[1];
	} _ifq_ptr;
#define ifq_softc		 _ifq_ptr._ifq_softc
#define ifq_ifqs		 _ifq_ptr._ifq_ifqs

	/* mbuf handling */
	struct mutex		 ifq_mtx;
	const struct ifq_ops	*ifq_ops;
	void			*ifq_q;
	struct mbuf_list	 ifq_free;
	unsigned int		 ifq_len;
	unsigned int		 ifq_oactive;

	/* statistics */
	uint64_t		 ifq_packets;
	uint64_t		 ifq_bytes;
	uint64_t		 ifq_qdrops;
	uint64_t		 ifq_errors;
	uint64_t		 ifq_mcasts;

	/* work serialisation */
	struct mutex		 ifq_task_mtx;
	struct task_list	 ifq_task_list;
	void			*ifq_serializer;

	/* work to be serialised */
	struct task		 ifq_start;
	struct task		 ifq_restart;

	/* properties */
	unsigned int		 ifq_maxlen;
	unsigned int		 ifq_idx;
};

#ifdef _KERNEL

#define IFQ_MAXLEN		256

/*
 *
 * Interface Send Queues
 *
 * struct ifqueue sits between the network stack and a drivers
 * transmission of packets. The high level view is that when the stack
 * has finished generating a packet it hands it to a driver for
 * transmission. It does this by queueing the packet on an ifqueue and
 * notifying the driver to start transmission of the queued packets.
 *
 * A network device may have multiple contexts for the transmission
 * of packets, ie, independent transmit rings. An network device
 * represented by a struct ifnet may have multiple ifqueue structures,
 * each of which represents an independent context.
 *
 * struct ifqueue also provides the point where conditioning of
 * traffic (ie, priq and hfsc) is implemented, and provides some
 * infrastructure to assist in the implementation of network drivers.
 *
 * = ifq API
 *
 * The ifq API provides functions for three distinct consumers:
 *
 * 1. The network stack
 * 2. Traffic QoS/conditioning implementations
 * 3. Network drivers
 *
 * == Network Stack API
 *
 * The network stack is responsible for initialising and destroying
 * the ifqueue structures, changing the traffic conditioner on an
 * interface, enqueuing packets for transmission, and notifying
 * the driver to start transmission of a particular ifqueue.
 *
 * === ifq_init()
 *
 * During if_attach(), the network stack calls ifq_init to initialise
 * the ifqueue structure. By default it configures the priq traffic
 * conditioner.
 *
 * === ifq_destroy()
 *
 * The network stack calls ifq_destroy() during if_detach to tear down
 * the ifqueue structure. It frees the traffic conditioner state, and
 * frees any mbufs that were left queued.
 *
 * === ifq_attach()
 *
 * ifq_attach() is used to replace the current traffic conditioner on
 * the ifqueue. All the pending mbufs are removed from the previous
 * conditioner and requeued on the new.
 *
 * === ifq_idx()
 *
 * ifq_idx() selects a specific ifqueue from the current ifnet
 * structure for use in the transmission of the mbuf.
 *
 * === ifq_enqueue()
 *
 * ifq_enqueue() attempts to fit an mbuf onto the ifqueue. The
 * current traffic conditioner may drop a packet to make space on the
 * queue.
 *
 * === ifq_start()
 *
 * Once a packet has been successfully queued with ifq_enqueue(),
 * the network card is notified with a call to ifq_start().
 * Calls to ifq_start() run in the ifqueue serialisation context,
 * guaranteeing that only one instance of ifp->if_qstart() will be
 * running on behalf of a specific ifqueue in the system at any point
 * in time.
 *
 * == Traffic conditioners API
 *
 * The majority of interaction between struct ifqueue and a traffic
 * conditioner occurs via the callbacks a traffic conditioner provides
 * in an instance of struct ifq_ops.
 *
 * XXX document ifqop_*
 *
 * The ifqueue API implements the locking on behalf of the conditioning
 * implementations so conditioners only have to reject or keep mbufs.
 * If something needs to inspect a conditioners internals, the queue lock
 * needs to be taken to allow for a consistent or safe view. The queue
 * lock may be taken and released with ifq_q_enter() and ifq_q_leave().
 *
 * === ifq_q_enter()
 *
 * Code wishing to access a conditioners internals may take the queue
 * lock with ifq_q_enter(). The caller must pass a reference to the
 * conditioners ifq_ops structure so the infrastructure can ensure the
 * caller is able to understand the internals. ifq_q_enter() returns
 * a pointer to the conditions internal structures, or NULL if the
 * ifq_ops did not match the current conditioner.
 *
 * === ifq_q_leave()
 *
 * The queue lock acquired with ifq_q_enter() is released with
 * ifq_q_leave().
 *
 * === ifq_mfreem()
 *
 * A goal of the API is to avoid freeing an mbuf while mutexs are
 * held. Because the ifq API manages the lock on behalf of the backend
 * ifqops, the backend should not directly free mbufs. If a conditioner
 * backend needs to drop a packet during the handling of ifqop_deq_begin,
 * it may free it by calling ifq_mfreem(). This accounts for the drop,
 * and schedules the free of the mbuf outside the hold of ifq_mtx.
 *
 *
 * == Network Driver API
 *
 * The API used by network drivers is mostly documented in the
 * ifq_dequeue(9) manpage except for ifq_serialize(),
 * ifq_is_serialized(), and IFQ_ASSERT_SERIALIZED().
 *
 * === ifq_serialize()
 *
 * A driver may run arbitrary work in the ifqueue serialiser context
 * via ifq_serialize(). The work to be done is represented by a task
 * that has been prepared with task_set.
 *
 * The work will be run in series with any other work dispatched by
 * ifq_start(), ifq_restart(), or other ifq_serialize() calls.
 *
 * Because the work may be run on another CPU, the lifetime of the
 * task and the work it represents can extend beyond the end of the
 * call to ifq_serialize() that dispatched it.
 *
 * === ifq_is_serialized()
 *
 * This function returns whether the caller is currently within the
 * ifqueue serializer context.
 *
 * === IFQ_ASSERT_SERIALIZED()
 *
 * This macro will assert that the caller is currently within the
 * specified ifqueue serialiser context.
 *
 *
 * = ifqueue work serialisation
 *
 * ifqueues provide a mechanism to dispatch work to be run in a single
 * context. Work in this mechanism is represtented by task structures.
 *
 * The tasks are run in a context similar to a taskq serviced by a
 * single kernel thread, except the work is run immediately by the
 * first CPU that dispatches work. If a second CPU attempts to dispatch
 * additional tasks while the first is still running, it will be queued
 * to be run by the first CPU. The second CPU will return immediately.
 *
 * = MP Safe Network Drivers
 *
 * An MP safe network driver is one in which its start routine can be
 * called by the network stack without holding the big kernel lock.
 *
 * == Attach
 *
 * A driver advertises it's ability to run its start routine without
 * the kernel lock by setting the IFXF_MPSAFE flag in ifp->if_xflags
 * before calling if_attach(). Advertising an MPSAFE start routine
 * also implies that the driver understands that a network card can
 * have multiple rings or transmit queues, and therefore provides
 * if_qstart function (which takes an ifqueue pointer) instead of an
 * if_start function (which takes an ifnet pointer).
 *
 *	void	drv_start(struct ifqueue *);
 *
 *	void
 *	drv_attach()
 *	{
 *	...
 *		ifp->if_xflags = IFXF_MPSAFE;
 *		ifp->if_qstart = drv_start;
 *		if_attach(ifp);
 *	}
 *
 * The network stack will then call ifp->if_qstart via ifq_start()
 * to guarantee there is only one instance of that function running
 * in the system and to serialise it with other work the driver may
 * provide.
 *
 * == Initialise
 *
 * When the stack requests an interface be brought up (ie, drv_ioctl()
 * is called to handle SIOCSIFFLAGS with IFF_UP set in ifp->if_flags)
 * drivers should set IFF_RUNNING in ifp->if_flags and call
 * ifq_clr_oactive().
 *
 * == if_start
 *
 * ifq_start() checks that IFF_RUNNING is set in ifp->if_flags, that
 * ifq_is_oactive() does not return true, and that there are pending
 * packets to transmit via a call to ifq_len(). Therefore, drivers are
 * no longer responsible for doing this themselves.
 *
 * If a driver should not transmit packets while its link is down, use
 * ifq_purge() to flush pending packets from the transmit queue.
 *
 * Drivers for hardware should use the following pattern to transmit
 * packets:
 *
 *	void
 *	drv_start(struct ifqueue *ifq)
 *	{
 *		struct ifnet *ifp = ifq->ifq_if;
 *		struct drv_softc *sc = ifp->if_softc;
 *		struct mbuf *m;
 *		int kick = 0;
 *
 *		if (NO_LINK) {
 *			ifq_purge(ifq);
 *			return;
 *		}
 *
 *		for (;;) {
 *			if (NO_SPACE) {
 *				ifq_set_oactive(ifq);
 *				break;
 *			}
 *
 *			m = ifq_dequeue(ifq);
 *			if (m == NULL)
 *				break;
 *
 *			if (drv_encap(sc, m) != 0) { // map and fill ring
 *				m_freem(m);
 *				continue;
 *			}
 *
 *			bpf_mtap();
 *		}
 *
 *		drv_kick(sc); // notify hw of new descriptors on the ring
 *	 }
 *
 * == Transmission completion
 *
 * The following pattern should be used for transmit queue interrupt
 * processing:
 *
 *	void
 *	drv_txeof(struct ifqueue *ifq)
 *	{
 *		while (COMPLETED_PKTS) {
 *			// unmap packets, m_freem() the mbufs.
 *		}
 *
 *		if (ifq_is_oactive(ifq))
 *			ifq_restart(ifq);
 *	}
 *
 * == Stop
 *
 * Bringing an interface down (ie, IFF_UP was cleared in ifp->if_flags)
 * should clear IFF_RUNNING in ifp->if_flags, and guarantee the start
 * routine is not running before freeing any resources it uses:
 *
 *	void
 *	drv_down(struct drv_softc *sc)
 *	{
 *		struct ifnet *ifp = &sc->sc_if;
 *		struct ifqueue *ifq;
 *		int i;
 *
 *		CLR(ifp->if_flags, IFF_RUNNING);
 *		DISABLE_INTERRUPTS();
 *
 *		for (i = 0; i < sc->sc_num_queues; i++) {
 * 			ifq = ifp->if_ifqs[i];
 *			ifq_barrier(ifq);
 *		}
 *
 *		intr_barrier(sc->sc_ih);
 *
 *		FREE_RESOURCES();
 *
 *		for (i = 0; i < sc->sc_num_queues; i++) {
 * 			ifq = ifp->if_ifqs[i];
 *			ifq_clr_oactive(ifq);
 *		}
 *	}
 *
 */

struct ifq_ops {
	unsigned int		 (*ifqop_idx)(unsigned int,
				    const struct mbuf *);
	struct mbuf		*(*ifqop_enq)(struct ifqueue *, struct mbuf *);
	struct mbuf		*(*ifqop_deq_begin)(struct ifqueue *, void **);
	void			 (*ifqop_deq_commit)(struct ifqueue *,
				    struct mbuf *, void *);
	void			 (*ifqop_purge)(struct ifqueue *,
				    struct mbuf_list *);
	void			*(*ifqop_alloc)(unsigned int, void *);
	void			 (*ifqop_free)(unsigned int, void *);
};

/*
 * Interface send queues.
 */

void		 ifq_init(struct ifqueue *, struct ifnet *, unsigned int);
void		 ifq_attach(struct ifqueue *, const struct ifq_ops *, void *);
void		 ifq_destroy(struct ifqueue *);
int		 ifq_enqueue(struct ifqueue *, struct mbuf *);
struct mbuf	*ifq_deq_begin(struct ifqueue *);
void		 ifq_deq_commit(struct ifqueue *, struct mbuf *);
void		 ifq_deq_rollback(struct ifqueue *, struct mbuf *);
struct mbuf	*ifq_dequeue(struct ifqueue *);
void		 ifq_mfreem(struct ifqueue *, struct mbuf *);
unsigned int	 ifq_purge(struct ifqueue *);
void		*ifq_q_enter(struct ifqueue *, const struct ifq_ops *);
void		 ifq_q_leave(struct ifqueue *, void *);
void		 ifq_serialize(struct ifqueue *, struct task *);
int		 ifq_is_serialized(struct ifqueue *);
void		 ifq_barrier(struct ifqueue *);

#define	ifq_len(_ifq)			((_ifq)->ifq_len)
#define	ifq_empty(_ifq)			(ifq_len(_ifq) == 0)
#define	ifq_set_maxlen(_ifq, _l)	((_ifq)->ifq_maxlen = (_l))

static inline void
ifq_set_oactive(struct ifqueue *ifq)
{
	ifq->ifq_oactive = 1;
}

static inline void
ifq_clr_oactive(struct ifqueue *ifq)
{
	ifq->ifq_oactive = 0;
}

static inline unsigned int
ifq_is_oactive(struct ifqueue *ifq)
{
	return (ifq->ifq_oactive);
}

static inline void
ifq_start(struct ifqueue *ifq)
{
	ifq_serialize(ifq, &ifq->ifq_start);
}

static inline void
ifq_restart(struct ifqueue *ifq)
{
	ifq_serialize(ifq, &ifq->ifq_restart);
}

static inline unsigned int
ifq_idx(struct ifqueue *ifq, unsigned int nifqs, const struct mbuf *m)
{
	return ((*ifq->ifq_ops->ifqop_idx)(nifqs, m));
}

#define IFQ_ASSERT_SERIALIZED(_ifq)	KASSERT(ifq_is_serialized(_ifq))

extern const struct ifq_ops * const ifq_priq_ops;

#endif /* _KERNEL */

#endif /* _NET_IFQ_H_ */
@


1.11
log
@add ifq_mfreem() so ifq backends can free packets during dequeue.

a goal of the ifq api is to avoid freeing an mbuf while holding a
lock. to acheive this it allowed the backend enqueue operation to
return a single mbuf to be freed. however, mikeb@@ is working on a
backend that wants to free packets during dequeue. to support this,
ifq_mfreem queues a packet during dequeue for freeing at the end
of the ifq serialiser.

there's some doco in ifq.h about it.

requested by mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifq.h,v 1.10 2017/03/07 01:29:53 dlg Exp $ */
d84 5
d104 3
a106 3
 * the ifqueue structure, changing the traffic conditioner on an
 * interface queue, enqueuing packets for transmission, and notifying
 * the driver to start transmission.
d126 5
d140 5
a144 6
 * the network card is notified with a call to if_start(). If an
 * interface is marked with IFXF_MPSAFE in its if_xflags field,
 * if_start() calls ifq_start() to dispatch the interfaces start
 * routine. Calls to ifq_start() run in the ifqueue serialisation
 * context, guaranteeing that only one instance of ifp->if_start()
 * will be running in the system at any point in time.
d232 9
a240 2
 * A driver advertises it's ability to run its start routine by setting
 * the IFXF_MPSAFE flag in ifp->if_xflags before calling if_attach():
d242 13
a254 8
 *	ifp->if_xflags = IFXF_MPSAFE;
 *	ifp->if_start = drv_start;
 *	if_attach(ifp);
 *
 * The network stack will then wrap its calls to ifp->if_start with
 * ifq_start() to guarantee there is only one instance of that function
 * running in the system and to serialise it with other work the driver
 * may provide.
d277 1
a277 1
 *	drv_start(struct ifnet *ifp)
d279 1
d285 1
a285 1
 *			ifq_purge(&ifp->if_snd);
d291 1
a291 1
 *				ifq_set_oactive(&ifp->if_snd);
d295 1
a295 1
 *			m = ifq_dequeue(&ifp->if_snd);
d316 1
a316 1
 *	drv_txeof(struct drv_softc *sc)
a317 2
 *		struct ifnet *ifp = &sc->sc_if;
 *
d322 2
a323 2
 *		if (ifq_is_oactive(&ifp->if_snd))
 *			ifq_restart(&ifp->if_snd);
d336 2
d342 5
a346 1
 *		ifq_barrier(&ifp->if_snd);
d351 4
a354 1
 *		ifq_clr_oactive();
@


1.10
log
@deprecate ifq_enqueue_try, and let backends drop arbitrary mbufs.

mikeb@@ wants priq to be able to drop lower priority packets if the
current one is high. because ifq avoids freeing an mbuf while an
ifq mutex is held, he needs a way for a backend to return an arbitrary
mbuf to drop rather than signal that the current one needs to be
dropped.

this lets the backends return the mbuf to be dropped, which may or
may not be the current one.

to support this ifq_enqueue_try has to be dropped because it can
only signal about the current mbuf. nothing uses it (except
ifq_enqueue), so we can get rid of it. it wasnt even documented.

this diff includes some tweaks by mikeb@@ around the statistics
gathered in ifq_enqueue when an mbuf is dropped.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifq.h,v 1.9 2017/01/24 10:08:30 krw Exp $ */
d45 1
d165 9
d355 1
@


1.9
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifq.h,v 1.8 2017/01/24 03:57:35 dlg Exp $ */
d120 1
a120 1
 * === ifq_enqueue() and ifq_enqueue_try()
d122 3
a124 6
 * ifq_enqueue() and ifq_enqueue_try() attempt to fit an mbuf onto the
 * ifqueue. If the current traffic conditioner rejects the packet it
 * wont be queued and will be counted as a drop. ifq_enqueue() will
 * free the mbuf on the callers behalf if the packet is rejected.
 * ifq_enqueue_try() does not free the mbuf, allowing the caller to
 * reuse it.
d128 7
a134 8
 * Once a packet has been successfully queued with ifq_enqueue() or
 * ifq_enqueue_try(), the network card is notified with a call to
 * if_start(). If an interface is marked with IFXF_MPSAFE in its
 * if_xflags field, if_start() calls ifq_start() to dispatch the
 * interfaces start routine. Calls to ifq_start() run in the ifqueue
 * serialisation context, guaranteeing that only one instance of
 * ifp->if_start() will be running in the system at any point in time.
 *
d323 1
a323 1
	int			 (*ifqop_enq)(struct ifqueue *, struct mbuf *);
a339 1
int		 ifq_enqueue_try(struct ifqueue *, struct mbuf *);
@


1.8
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@d1 1
a1 1
/*	$OpenBSD: ifq.h,v 1.6 2017/01/20 03:48:03 dlg Exp $ */
d220 3
a222 3
 * 	ifp->if_xflags = IFXF_MPSAFE;
 * 	ifp->if_start = drv_start;
 * 	if_attach(ifp);
d249 26
a274 26
 * 	void
 * 	drv_start(struct ifnet *ifp)
 * 	{
 * 		struct drv_softc *sc = ifp->if_softc;
 * 		struct mbuf *m;
 * 		int kick = 0;
 *
 * 		if (NO_LINK) {
 * 			ifq_purge(&ifp->if_snd);
 * 			return;
 * 		}
 *
 * 		for (;;) {
 * 			if (NO_SPACE) {
 * 				ifq_set_oactive(&ifp->if_snd);
 * 				break;
 * 			}
 *
 * 			m = ifq_dequeue(&ifp->if_snd);
 * 			if (m == NULL)
 * 				break;
 *
 * 			if (drv_encap(sc, m) != 0) { // map and fill ring
 * 				m_freem(m);
 * 				continue;
 * 			}
d276 2
a277 2
 * 			bpf_mtap();
 * 		}
d279 2
a280 2
 *  		drv_kick(sc); // notify hw of new descriptors on the ring
 * 	 }
d287 12
a298 12
 * 	void
 * 	drv_txeof(struct drv_softc *sc)
 * 	{
 * 		struct ifnet *ifp = &sc->sc_if;
 *
 * 		while (COMPLETED_PKTS) {
 * 			// unmap packets, m_freem() the mbufs.
 * 		}
 *
 * 		if (ifq_is_oactive(&ifp->if_snd))
 * 			ifq_restart(&ifp->if_snd);
 * 	}
d306 4
a309 4
 * 	void
 * 	drv_down(struct drv_softc *sc)
 * 	{
 * 		struct ifnet *ifp = &sc->sc_if;
d311 2
a312 2
 * 		CLR(ifp->if_flags, IFF_RUNNING);
 * 		DISABLE_INTERRUPTS();
d314 2
a315 2
 * 		ifq_barrier(&ifp->if_snd);
 * 		intr_barrier(sc->sc_ih);
d317 1
a317 1
 * 		FREE_RESOURCES();
d319 2
a320 2
 * 		ifq_clr_oactive();
 * 	}
@


1.7
log
@white space fixes. no functional change.
@
text
@d28 12
d64 1
d66 1
d325 2
a326 2
	void			*(*ifqop_alloc)(void *);
	void			 (*ifqop_free)(void *);
d333 2
d341 1
a341 1
void		 ifq_init(struct ifqueue *, struct ifnet *);
d389 6
@


1.6
log
@keep output packet counters on the ifq structure.

these copy what is counted on the output path on the ifnet struct,
except ifq counts both packets and bytes when a packet is queued
instead of just the bytes.

all the counters are protected by the ifq mutex except for ifq_errors,
which can be updated safely from inside a start routine because the
ifq machinery serialises them.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifq.h,v 1.5 2016/01/20 17:27:16 mikeb Exp $ */
d314 1
a314 1
	struct mbuf 		*(*ifqop_deq_begin)(struct ifqueue *, void **);
d317 1
a317 1
	void	 		 (*ifqop_purge)(struct ifqueue *,
@


1.5
log
@dlg@@ took a pity on me and let me stay sane a bit longer by giving
me a chance to kill these glowing red trailing whitespace characters.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifq.h,v 1.4 2015/12/29 12:35:43 dlg Exp $ */
a30 1
	uint64_t		 ifq_drops;
d35 7
@


1.4
log
@store curcpu() in ifq_serializer so we can check it.

this in turn gives us ifq_is_serialized() and an IFQ_ASSERT_SERIALIZED()
macro.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifq.h,v 1.3 2015/12/10 03:05:17 dlg Exp $ */
d54 1
a54 1
 * 
d56 1
a56 1
 * 
d62 1
a62 1
 * 
d66 1
a66 1
 * 
d68 1
a68 1
 * 
d70 1
a70 1
 * 
d74 1
a74 1
 * 
d76 1
a76 1
 * 
d81 1
a81 1
 * 
d83 1
a83 1
 * 
d87 1
a87 1
 * 
d89 1
a89 1
 * 
d93 1
a93 1
 * 
d95 1
a95 1
 * 
d99 1
a99 1
 * 
d101 1
a101 1
 * 
d108 1
a108 1
 * 
d110 1
a110 1
 * 
d118 2
a119 2
 * 
 * 
d121 1
a121 1
 * 
d125 1
a125 1
 * 
d127 1
a127 1
 * 
d133 1
a133 1
 * 
d135 1
a135 1
 * 
d142 1
a142 1
 * 
d144 1
a144 1
 * 
d147 2
a148 2
 * 
 * 
d150 1
a150 1
 * 
d154 1
a154 1
 * 
d156 1
a156 1
 * 
d160 1
a160 1
 * 
d163 1
a163 1
 * 
d167 1
a167 1
 * 
d169 1
a169 1
 * 
d172 1
a172 1
 * 
d174 1
a174 1
 * 
d177 2
a178 2
 * 
 * 
d180 1
a180 1
 * 
d183 1
a183 1
 * 
d189 1
a189 1
 * 
d191 1
a191 1
 * 
d194 1
a194 1
 * 
d196 1
a196 1
 * 
d199 1
a199 1
 * 
d203 1
a203 1
 * 
d208 1
a208 1
 * 
d210 1
a210 1
 * 
d215 1
a215 1
 * 
d217 1
a217 1
 * 
d222 1
a222 1
 * 
d225 1
a225 1
 * 
d228 1
a228 1
 * 
d235 1
a235 1
 * 
d240 1
a240 1
 * 
d246 1
a246 1
 * 
d250 1
a250 1
 * 
d255 1
a255 1
 * 
d258 1
a258 1
 *  
d261 1
a261 1
 * 
d263 1
a263 1
 * 
d266 1
a266 1
 * 
d271 1
a271 1
 * 
d275 1
a275 1
 * 
d279 1
a279 1
 * 
d281 1
a281 1
 * 
d285 1
a285 1
 * 
d290 1
a290 1
 * 
d293 1
a293 1
 * 
d296 1
a296 1
 * 
d298 1
a298 1
 * 
d301 1
a301 1
 * 
@


1.3
log
@write down some stuff before it falls out of my head.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifq.h,v 1.2 2015/12/09 03:22:39 dlg Exp $ */
d40 1
a40 1
	unsigned int		 ifq_serializer;
d152 2
a153 1
 * ifq_dequeue(9) manpage except for ifq_serialize().
d168 10
d332 1
d368 2
@


1.2
log
@rework the if_start mpsafe serialisation so it can serialise arbitrary work

work is represented by struct task.

the start routine is now wrapped by a task which is serialised by the
infrastructure. if_start_barrier has been renamed to ifq_barrier and
is now implemented as a task that gets serialised with the start
routine.

this also adds an ifq_restart() function. it serialises a call to
ifq_clr_oactive and calls the start routine again. it exists to
avoid a race that kettenis@@ identified in between when a start
routine discovers theres no space left on a ring, and when it calls
ifq_set_oactive. if the txeof side of the driver empties the ring
and calls ifq_clr_oactive in between the above calls in start, the
queue will be marked oactive and the stack will never call the start
routine again.

by serialising the ifq_set_oactive call in the start routine and
ifq_clr_oactive calls we avoid that race.

tested on various nics
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d52 240
@


1.1
log
@split the interface send queue (struct ifqueue) implementation out.

the intention is to make it more clear what belongs to a transmit
queue and what belongs to an interface.

suggested by and ok mpi@@
@
text
@d27 3
d35 5
d41 4
a44 1
	unsigned int		 ifq_oactive;
d68 1
a68 1
void		 ifq_init(struct ifqueue *);
d80 2
d103 12
@

