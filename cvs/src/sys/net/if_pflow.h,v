head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.12
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.10
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.17
date	2017.05.31.13.05.43;	author visa;	state Exp;
branches;
next	1.16;
commitid	pJKq3Dbyl1Ylq4yM;

1.16
date	2017.05.27.21.06.06;	author benno;	state Exp;
branches;
next	1.15;
commitid	kvEy1EJdyezVx8JS;

1.15
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.14;
commitid	6c6qq5OdS4VVnyVM;

1.14
date	2015.10.03.10.44.23;	author florian;	state Exp;
branches;
next	1.13;
commitid	ZIIAgj3OLK4duGNy;

1.13
date	2015.07.20.23.15.54;	author florian;	state Exp;
branches;
next	1.12;
commitid	E5C8fGTRyuqmAfVd;

1.12
date	2014.08.13.09.46.23;	author blambert;	state Exp;
branches;
next	1.11;
commitid	dWK70fA38KC9bTHY;

1.11
date	2014.03.29.11.26.03;	author florian;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.20.10.46.53;	author benno;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.13.08.44.05;	author florian;	state Exp;
branches;
next	1.8;

1.8
date	2013.05.03.15.33.47;	author florian;	state Exp;
branches;
next	1.7;

1.7
date	2013.02.05.11.58.39;	author florian;	state Exp;
branches;
next	1.6;

1.6
date	2012.02.02.12.34.37;	author benno;	state Exp;
branches;
next	1.5;

1.5
date	2009.02.27.11.09.36;	author gollo;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.03.21.47.32;	author gollo;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.28.15.51.27;	author gollo;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.16.15.48.12;	author gollo;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.09.13.56.39;	author henning;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Use mbuf_queue to properly serialize access to pflow output queue.

Input from mpi@@, jmatthew@@; OK mpi@@, henning@@, benno@@
@
text
@/*	$OpenBSD: if_pflow.h,v 1.16 2017/05/27 21:06:06 benno Exp $	*/

/*
 * Copyright (c) 2008 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2008 Joerg Goltermann <jg@@osn.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _NET_IF_PFLOW_H_
#define _NET_IF_PFLOW_H_

#define PFLOW_ID_LEN	sizeof(u_int64_t)

#define PFLOW_MAXFLOWS 30
#define PFLOW_ENGINE_TYPE 42
#define PFLOW_ENGINE_ID 42
#define PFLOW_MAXBYTES 0xffffffff
#define PFLOW_TIMEOUT 30
#define PFLOW_TMPL_TIMEOUT 30 /* rfc 5101 10.3.6 (p.40) recommends 600 */

#define PFLOW_IPFIX_TMPL_SET_ID 2

/* RFC 5102 Information Element Identifiers */

#define PFIX_IE_octetDeltaCount			  1
#define PFIX_IE_packetDeltaCount		  2
#define PFIX_IE_protocolIdentifier		  4
#define PFIX_IE_ipClassOfService		  5
#define PFIX_IE_sourceTransportPort		  7
#define PFIX_IE_sourceIPv4Address		  8
#define PFIX_IE_ingressInterface		 10
#define PFIX_IE_destinationTransportPort	 11
#define PFIX_IE_destinationIPv4Address		 12
#define PFIX_IE_egressInterface			 14
#define PFIX_IE_flowEndSysUpTime		 21
#define PFIX_IE_flowStartSysUpTime		 22
#define PFIX_IE_sourceIPv6Address		 27
#define PFIX_IE_destinationIPv6Address		 28
#define PFIX_IE_flowStartMilliseconds		152
#define PFIX_IE_flowEndMilliseconds		153

struct pflow_flow {
	u_int32_t	src_ip;
	u_int32_t	dest_ip;
	u_int32_t	nexthop_ip;
	u_int16_t	if_index_in;
	u_int16_t	if_index_out;
	u_int32_t	flow_packets;
	u_int32_t	flow_octets;
	u_int32_t	flow_start;
	u_int32_t	flow_finish;
	u_int16_t	src_port;
	u_int16_t	dest_port;
	u_int8_t	pad1;
	u_int8_t	tcp_flags;
	u_int8_t	protocol;
	u_int8_t	tos;
	u_int16_t	src_as;
	u_int16_t	dest_as;
	u_int8_t	src_mask;
	u_int8_t	dest_mask;
	u_int16_t	pad2;
} __packed;

struct pflow_set_header {
	u_int16_t	set_id;
	u_int16_t	set_length; /* total length of the set,
				       in octets, including the set header */
} __packed;

#define PFLOW_SET_HDRLEN sizeof(struct pflow_set_header)

struct pflow_tmpl_hdr {
	u_int16_t	tmpl_id;
	u_int16_t	field_count;
} __packed;

struct pflow_tmpl_fspec {
	u_int16_t	field_id;
	u_int16_t	len;
} __packed;

/* update pflow_clone_create() when changing pflow_ipfix_tmpl_ipv4 */
struct pflow_ipfix_tmpl_ipv4 {
	struct pflow_tmpl_hdr	h;
	struct pflow_tmpl_fspec	src_ip;
	struct pflow_tmpl_fspec	dest_ip;
	struct pflow_tmpl_fspec	if_index_in;
	struct pflow_tmpl_fspec	if_index_out;
	struct pflow_tmpl_fspec	packets;
	struct pflow_tmpl_fspec	octets;
	struct pflow_tmpl_fspec	start;
	struct pflow_tmpl_fspec	finish;
	struct pflow_tmpl_fspec	src_port;
	struct pflow_tmpl_fspec	dest_port;
	struct pflow_tmpl_fspec	tos;
	struct pflow_tmpl_fspec	protocol;
#define PFLOW_IPFIX_TMPL_IPV4_FIELD_COUNT 12
#define PFLOW_IPFIX_TMPL_IPV4_ID 256
} __packed;

/* update pflow_clone_create() when changing pflow_ipfix_tmpl_v6 */
struct pflow_ipfix_tmpl_ipv6 {
	struct pflow_tmpl_hdr	h;
	struct pflow_tmpl_fspec	src_ip;
	struct pflow_tmpl_fspec	dest_ip;
	struct pflow_tmpl_fspec	if_index_in;
	struct pflow_tmpl_fspec	if_index_out;
	struct pflow_tmpl_fspec	packets;
	struct pflow_tmpl_fspec	octets;
	struct pflow_tmpl_fspec	start;
	struct pflow_tmpl_fspec	finish;
	struct pflow_tmpl_fspec	src_port;
	struct pflow_tmpl_fspec	dest_port;
	struct pflow_tmpl_fspec	tos;
	struct pflow_tmpl_fspec	protocol;
#define PFLOW_IPFIX_TMPL_IPV6_FIELD_COUNT 12
#define PFLOW_IPFIX_TMPL_IPV6_ID 257
} __packed;

struct pflow_ipfix_tmpl {
	struct pflow_set_header	set_header;
	struct pflow_ipfix_tmpl_ipv4	ipv4_tmpl;
	struct pflow_ipfix_tmpl_ipv6	ipv6_tmpl;
} __packed;

struct pflow_ipfix_flow4 {
	u_int32_t	src_ip;		/* sourceIPv4Address*/
	u_int32_t	dest_ip;	/* destinationIPv4Address */
	u_int32_t	if_index_in;	/* ingressInterface */
	u_int32_t	if_index_out;	/* egressInterface */
	u_int64_t	flow_packets;	/* packetDeltaCount */
	u_int64_t	flow_octets;	/* octetDeltaCount */
	int64_t		flow_start;	/* flowStartMilliseconds */
	int64_t		flow_finish;	/* flowEndMilliseconds */
	u_int16_t	src_port;	/* sourceTransportPort */
	u_int16_t	dest_port;	/* destinationTransportPort */
	u_int8_t	tos;		/* ipClassOfService */
	u_int8_t	protocol;	/* protocolIdentifier */
	/* XXX padding needed? */
} __packed;

struct pflow_ipfix_flow6 {
	struct in6_addr src_ip;		/* sourceIPv6Address */
	struct in6_addr dest_ip;	/* destinationIPv6Address */
	u_int32_t	if_index_in;	/* ingressInterface */
	u_int32_t	if_index_out;	/* egressInterface */
	u_int64_t	flow_packets;	/* packetDeltaCount */
	u_int64_t	flow_octets;	/* octetDeltaCount */
	int64_t		flow_start;	/* flowStartMilliseconds */
	int64_t		flow_finish;	/* flowEndMilliseconds */
	u_int16_t	src_port;	/* sourceTransportPort */
	u_int16_t	dest_port;	/* destinationTransportPort */
	u_int8_t	tos;		/* ipClassOfService */
	u_int8_t	protocol;	/* protocolIdentifier */
	/* XXX padding needed? */
} __packed;

#ifdef _KERNEL

struct pflow_softc {
	struct ifnet		 sc_if;
	struct ifnet		*sc_pflow_ifp;

	unsigned int		 sc_count;
	unsigned int		 sc_count4;
	unsigned int		 sc_count6;
	unsigned int		 sc_maxcount;
	unsigned int		 sc_maxcount4;
	unsigned int		 sc_maxcount6;
	u_int64_t		 sc_gcounter;
	u_int32_t		 sc_sequence;
	struct timeout		 sc_tmo;
	struct timeout		 sc_tmo6;
	struct timeout		 sc_tmo_tmpl;
	struct mbuf_queue	 sc_outputqueue;
	struct task		 sc_outputtask;
	struct socket		*so;
	struct mbuf		*send_nam;
	struct sockaddr		*sc_flowsrc;
	struct sockaddr		*sc_flowdst;
	u_char			 sc_send_templates;
	struct pflow_ipfix_tmpl	 sc_tmpl_ipfix;
	u_int8_t		 sc_version;
	struct mbuf		*sc_mbuf;	/* current cumulative mbuf */
	struct mbuf		*sc_mbuf6;	/* current cumulative mbuf */
	SLIST_ENTRY(pflow_softc) sc_next;
};

extern struct pflow_softc	*pflowif;

#endif /* _KERNEL */

struct pflow_header {
	u_int16_t	version;
	u_int16_t	count;
	u_int32_t	uptime_ms;
	u_int32_t	time_sec;
	u_int32_t	time_nanosec;
	u_int32_t	flow_sequence;
	u_int8_t	engine_type;
	u_int8_t	engine_id;
	u_int8_t	reserved1;
	u_int8_t	reserved2;
} __packed;

#define PFLOW_HDRLEN sizeof(struct pflow_header)

struct pflow_v10_header {
	u_int16_t	version;
	u_int16_t	length;
	u_int32_t	time_sec;
	u_int32_t	flow_sequence;
	u_int32_t	observation_dom;
} __packed;

#define PFLOW_IPFIX_HDRLEN sizeof(struct pflow_v10_header)

struct pflowstats {
	u_int64_t	pflow_flows;
	u_int64_t	pflow_packets;
	u_int64_t	pflow_onomem;
	u_int64_t	pflow_oerrors;
};

/* Supported flow protocols */
#define PFLOW_PROTO_5	5	/* original pflow */
#define PFLOW_PROTO_10	10	/* ipfix */
#define PFLOW_PROTO_MAX	11

#define PFLOW_PROTO_DEFAULT PFLOW_PROTO_5

struct pflow_protos {
	const char	*ppr_name;
	u_int8_t	 ppr_proto;
};

#define PFLOW_PROTOS {                                 \
		{ "5",	PFLOW_PROTO_5 },	       \
		{ "10",	PFLOW_PROTO_10 },	       \
}

/*
 * Configuration structure for SIOCSETPFLOW SIOCGETPFLOW
 */
struct pflowreq {
	struct sockaddr_storage	flowsrc;
	struct sockaddr_storage	flowdst;
	u_int16_t		addrmask;
	u_int8_t		version;
#define PFLOW_MASK_SRCIP	0x01
#define PFLOW_MASK_DSTIP	0x02
#define PFLOW_MASK_VERSION	0x04
};

#ifdef _KERNEL
int export_pflow(struct pf_state *);
int pflow_sysctl(int *, u_int,  void *, size_t *, void *, size_t);
#endif /* _KERNEL */

#endif /* _NET_IF_PFLOW_H_ */
@


1.16
log
@move sending of pflow packet into a task, seperated from the data
collection by a mbuf queue. with help from mpi@@
ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.15 2017/01/24 10:08:30 krw Exp $	*/
d187 1
a187 1
	struct mbuf_list	 sc_outputqueue;
@


1.15
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.14 2015/10/03 10:44:23 florian Exp $	*/
d187 2
@


1.14
log
@IPv6 transport for pflow data.
Input deraadt@@
Bug fix & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.13 2015/07/20 23:15:54 florian Exp $	*/
d115 1
a115 1
	struct pflow_tmpl_hdr 	h;
@


1.13
log
@Use the kernel socket interface (sosend(9) etc) instead of shoving
packets directly into the network stack with ip_output().
The locking is intentionally left as is and will be improved in
another commit.
Input / OK bluhm@@, OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.12 2014/08/13 09:46:23 blambert Exp $	*/
d189 2
a190 3
	struct in_addr		 sc_sender_ip;
	struct in_addr		 sc_receiver_ip;
	u_int16_t		 sc_receiver_port;
d256 2
a257 3
	struct in_addr		sender_ip;
	struct in_addr		receiver_ip;
	u_int16_t		receiver_port;
d262 1
a262 2
#define PFLOW_MASK_DSTPRT	0x04
#define PFLOW_MASK_VERSION	0x08
@


1.12
log
@Bring IPFIX sequence numbers in line with the RFC; original
diff from benno@@.

ok benno@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.11 2014/03/29 11:26:03 florian Exp $	*/
a183 1
	struct ip_moptions	 sc_imo;
d187 2
a189 1
	u_int16_t		 sc_sender_port;
@


1.11
log
@Kill pflowproto 9, it's unfixable post 2038, a better, standardized
option is pflowproto 10. Also it duplicates a lot of code from
pflowproto 10 and will get in the way in the future.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.10 2014/01/20 10:46:53 benno Exp $	*/
d183 1
@


1.10
log
@tedu unused declaration. ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.9 2013/08/13 08:44:05 florian Exp $	*/
a31 1
#define PFLOW_V9_TMPL_SET_ID 0
a88 1
/* field specifier rfc5101 sec 3.2, v9 uses the same format*/
a93 45
/* update pflow_clone_create() when changing pflow_v9_tmpl_ipv4 */
struct pflow_v9_tmpl_ipv4 {
	struct pflow_tmpl_hdr	h;
	struct pflow_tmpl_fspec	src_ip;
	struct pflow_tmpl_fspec	dest_ip;
	struct pflow_tmpl_fspec	if_index_in;
	struct pflow_tmpl_fspec	if_index_out;
	struct pflow_tmpl_fspec	packets;
	struct pflow_tmpl_fspec	octets;
	struct pflow_tmpl_fspec	start;
	struct pflow_tmpl_fspec	finish;
	struct pflow_tmpl_fspec	src_port;
	struct pflow_tmpl_fspec	dest_port;
	struct pflow_tmpl_fspec	tos;
	struct pflow_tmpl_fspec	protocol;
#define PFLOW_V9_TMPL_IPV4_FIELD_COUNT 12
#define PFLOW_V9_TMPL_IPV4_ID 256
} __packed;

/* update pflow_clone_create() when changing pflow_v9_tmpl_v6 */
struct pflow_v9_tmpl_ipv6 {
	struct pflow_tmpl_hdr 	h;
	struct pflow_tmpl_fspec	src_ip;
	struct pflow_tmpl_fspec	dest_ip;
	struct pflow_tmpl_fspec	if_index_in;
	struct pflow_tmpl_fspec	if_index_out;
	struct pflow_tmpl_fspec	packets;
	struct pflow_tmpl_fspec	octets;
	struct pflow_tmpl_fspec	start;
	struct pflow_tmpl_fspec	finish;
	struct pflow_tmpl_fspec	src_port;
	struct pflow_tmpl_fspec	dest_port;
	struct pflow_tmpl_fspec	tos;
	struct pflow_tmpl_fspec	protocol;
#define PFLOW_V9_TMPL_IPV6_FIELD_COUNT 12
#define PFLOW_V9_TMPL_IPV6_ID 257
} __packed;

struct pflow_v9_tmpl {
	struct pflow_set_header	set_header;
	struct pflow_v9_tmpl_ipv4	ipv4_tmpl;
	struct pflow_v9_tmpl_ipv6	ipv6_tmpl;
} __packed;


a137 32
struct pflow_v9_flow4 {
	u_int32_t	src_ip;		/* sourceIPv4Address*/
	u_int32_t	dest_ip;	/* destinationIPv4Address */
	u_int32_t	if_index_in;	/* ingressInterface */
	u_int32_t	if_index_out;	/* egressInterface */
	u_int64_t	flow_packets;	/* packetDeltaCount */
	u_int64_t	flow_octets;	/* octetDeltaCount */
	u_int32_t	flow_start;	/* flowStartSysUpTime */
	u_int32_t	flow_finish;	/* flowEndSysUpTime */
	u_int16_t	src_port;	/* sourceTransportPort */
	u_int16_t	dest_port;	/* destinationTransportPort */
	u_int8_t	tos;		/* ipClassOfService */
	u_int8_t	protocol;	/* protocolIdentifier */
	/* XXX padding needed? */
} __packed;

struct pflow_v9_flow6 {
	struct in6_addr src_ip;		/* sourceIPv6Address */
	struct in6_addr dest_ip;	/* destinationIPv6Address */
	u_int32_t	if_index_in;	/* ingressInterface */
	u_int32_t	if_index_out;	/* egressInterface */
	u_int64_t	flow_packets;	/* packetDeltaCount */
	u_int64_t	flow_octets;	/* octetDeltaCount */
	u_int32_t	flow_start;	/* flowStartSysUpTime */
	u_int32_t	flow_finish;	/* flowEndSysUpTime */
	u_int16_t	src_port;	/* sourceTransportPort */
	u_int16_t	dest_port;	/* destinationTransportPort */
	u_int8_t	tos;		/* ipClassOfService */
	u_int8_t	protocol;	/* protocolIdentifier */
	/* XXX padding needed? */
} __packed;

a191 1
	struct pflow_v9_tmpl	 sc_tmpl_v9;
a227 11
struct pflow_v9_header {
	u_int16_t	version;
	u_int16_t	count;
	u_int32_t	uptime_ms;
	u_int32_t	time_sec;
	u_int32_t	flow_sequence;
	u_int32_t	observation_dom;
} __packed;

#define PFLOW_V9_HDRLEN sizeof(struct pflow_v9_header)

a236 1
#define PFLOW_PROTO_9	9	/* version 9 */
a248 1
		{ "9",	PFLOW_PROTO_9 },	       \
@


1.9
log
@Split pflow version 9 and version 10 to be able to send 64 bit
time values for version 10.
While there mark places which will blow up in 2038.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.8 2013/05/03 15:33:47 florian Exp $	*/
a249 2

extern int pflow_ok;
@


1.8
log
@Export ingress/egress interface index in pflow(4).
Report that this is needed for some netflow collector and tests by
Chris Ivancic & Colin Ligertwood.

OK mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.7 2013/02/05 11:58:39 florian Exp $	*/
d33 1
a33 1
#define PFLOW_V10_TMPL_SET_ID 2
d51 2
a52 2
#define PFIX_IE_flowStartSeconds		150
#define PFIX_IE_flowEndSeconds			151
d96 2
a97 2
/* update pflow_clone_create() when changing pflow_tmpl_ipv4 */
struct pflow_tmpl_ipv4 {
d111 2
a112 2
#define PFLOW_TMPL_IPV4_FIELD_COUNT 12
#define PFLOW_TMPL_IPV4_ID 256
d115 2
a116 2
/* update pflow_clone_create() when changing pflow_tmpl_v6 */
struct pflow_tmpl_ipv6 {
d130 2
a131 2
#define PFLOW_TMPL_IPV6_FIELD_COUNT 12
#define PFLOW_TMPL_IPV6_ID 257
d134 1
a134 1
struct pflow_tmpl {
d136 2
a137 2
	struct pflow_tmpl_ipv4	ipv4_tmpl;
	struct pflow_tmpl_ipv6	ipv6_tmpl;
d140 46
a185 1
struct pflow_flow4 {
d201 33
a233 1
struct pflow_flow6 {
d240 2
a241 5
	u_int32_t	flow_start;	/*
					 * flowStartSysUpTime /
					 * flowStartSeconds
					 */
	u_int32_t	flow_finish;	/* flowEndSysUpTime / flowEndSeconds */
d273 2
a274 1
	struct pflow_tmpl	 sc_tmpl;
d308 1
a308 1
#define PFLOW_V10_HDRLEN sizeof(struct pflow_v10_header)
@


1.7
log
@netflow v10 omitted the sysUpTime flow set header field from
v9. Without it it's not possible to find out at what time a flow
started/ended with only flowStartSysUpTime/flowEndSysUpTime. Fix this
by using flowStartSeconds/flowEndSeconds for v10.
Problem reported by Chris Ivancic and Colin Ligertwood, analyzed by
benno@@
Tested by benno@@ against nprobe (which doesn't care that much one way
or the other)
Tested by Chris Ivancic against solarwinds collector.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.6 2012/02/02 12:34:37 benno Exp $	*/
d43 1
d46 1
d96 1
a96 1
/* update pflow_clone_create() when changing pflow_v10_tmpl_v4 */
d101 2
d111 1
a111 1
#define PFLOW_TMPL_IPV4_FIELD_COUNT 10
d115 1
a115 1
/* update pflow_clone_create() when changing pflow_v10_tmpl_v6 */
d120 2
d130 1
a130 1
#define PFLOW_TMPL_IPV6_FIELD_COUNT 10
d143 2
d159 2
@


1.6
log
@add netflow v9/ipfix support to pflow(4).
large parts written by Florian Obser (florian -at- narrans -dot- de).
feedback from sperreault@@ gollo@@ sthen@@
ok from gollo@@ dlg@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.5 2009/02/27 11:09:36 gollo Exp $	*/
d37 14
a50 12
#define PFIX_IE_octetDeltaCount			 1
#define PFIX_IE_packetDeltaCount		 2
#define PFIX_IE_protocolIdentifier		 4
#define PFIX_IE_ipClassOfService		 5
#define PFIX_IE_sourceTransportPort		 7
#define PFIX_IE_sourceIPv4Address		 8
#define PFIX_IE_destinationTransportPort	11
#define PFIX_IE_destinationIPv4Address		12
#define PFIX_IE_flowEndSysUpTime		21
#define PFIX_IE_flowStartSysUpTime		22
#define PFIX_IE_sourceIPv6Address		27
#define PFIX_IE_destinationIPv6Address		28
d153 5
a157 2
	u_int32_t	flow_start;	/* flowStartSysUpTime */
	u_int32_t	flow_finish;	/* flowEndSysUpTime */
@


1.5
log
@fix mbuf problems and simplify code, well spotted and input by
Alexander Sabourenkov. mbuf logic is based on claudio's recommendation

Tested by Alexander Sabourenkov

OK: henning@@, claudio@@
Theo: "In please..."
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.4 2009/01/03 21:47:32 gollo Exp $	*/
a25 1
#define PFLOW_VERSION 5
d30 19
d73 87
d169 2
d172 2
d177 2
d183 3
d187 1
d210 21
d238 19
d265 1
d269 1
@


1.4
log
@sync flow sequence ids on all used pflow interfaces.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.3 2008/10/28 15:51:27 gollo Exp $	*/
a58 4
union sc_flowp {
	struct	pflow_flow	*s;
};

a71 1
	union sc_flowp		 sc_flowp;
@


1.3
log
@add support for multiple pflow(4) interfaces

OK: claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.2 2008/09/16 15:48:12 gollo Exp $	*/
d69 1
a69 1
	u_int32_t		 sc_gcounter;
@


1.2
log
@netstat statistics for pflow(4) via pseudo family

ok cluadio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflow.h,v 1.1 2008/09/09 13:56:39 henning Exp $	*/
d78 1
@


1.1
log
@welcome pflow(4), a netflow v5 compatible flow export interface.
flows export data gathered from pf states.
initial implementation by Joerg Goltermann <jg@@osn.de>, guidance and many
changes by me. 'put it in' theo
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 1
@

