head	1.12;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11;
locks; strict;
comment	@ * @;


1.12
date	2017.08.11.21.24.19;	author mpi;	state Exp;
branches;
next	1.11;
commitid	qO4hXiGM2yDTtiTI;

1.11
date	2017.01.16.11.25.14;	author reyk;	state Exp;
branches;
next	1.10;
commitid	QY4ExQ9jhUwqC5OV;

1.10
date	2016.12.22.15.06.47;	author mikeb;	state Exp;
branches;
next	1.9;
commitid	ixbWpvVa1VPILucj;

1.9
date	2016.12.12.09.51.30;	author mpi;	state Exp;
branches;
next	1.8;
commitid	4shAe6LbqmAnsu7t;

1.8
date	2016.11.11.16.19.09;	author rzalamena;	state Exp;
branches;
next	1.7;
commitid	wZV2Rvj9O9E7qX2e;

1.7
date	2016.11.10.17.32.40;	author rzalamena;	state Exp;
branches;
next	1.6;
commitid	qAmxzKnJKYaOz2KN;

1.6
date	2016.11.09.12.26.55;	author rzalamena;	state Exp;
branches;
next	1.5;
commitid	BGWdOSuGhmeGyAiD;

1.5
date	2016.11.08.19.11.57;	author rzalamena;	state Exp;
branches;
next	1.4;
commitid	D6bMPLQQEHlAJyJZ;

1.4
date	2016.09.04.15.46.39;	author reyk;	state Exp;
branches;
next	1.3;
commitid	05wK3oqe2BKozGUg;

1.3
date	2016.09.04.08.26.48;	author yasuoka;	state Exp;
branches;
next	1.2;
commitid	0U5r3hA8a0EtLz1u;

1.2
date	2016.09.03.18.33.55;	author goda;	state Exp;
branches;
next	1.1;
commitid	COMhQfc4mApbrLWr;

1.1
date	2016.09.01.10.06.33;	author goda;	state Exp;
branches;
next	;
commitid	53X2QcUepPKjCjvt;


desc
@@


1.12
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@/*	$OpenBSD: switchctl.c,v 1.11 2017/01/16 11:25:14 reyk Exp $	*/

/*
 * Copyright (c) 2016 Kazuya GODA <goda@@openbsd.org>
 * Copyright (c) 2015, 2016 YASUOKA Masahiko <yasuoka@@openbsd.org>
 * Copyright (c) 2015, 2016 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/selinfo.h>
#include <sys/rwlock.h>
#include <sys/proc.h>

#include <net/if.h>
#include <net/rtable.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_switch.h>

extern struct rwlock	switch_ifs_lk;

/*
 * device part of switch(4)
 */
#include <sys/poll.h>
#include <sys/selinfo.h>
#include <sys/vnode.h>

struct switch_softc *switch_dev2sc(dev_t);
int	switchopen(dev_t, int, int, struct proc *);
int	switchread(dev_t, struct uio *, int);
int	switchwrite(dev_t, struct uio *, int);
int	switchioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	switchclose(dev_t, int, int, struct proc *);
int	switchpoll(dev_t, int, struct proc *);
int	switchkqfilter(dev_t, struct knote *);
void	filt_switch_rdetach(struct knote *);
int	filt_switch_read(struct knote *, long);
void	filt_switch_wdetach(struct knote *);
int	filt_switch_write(struct knote *, long);
int	switch_dev_output(struct switch_softc *, struct mbuf *);
void	switch_dev_wakeup(struct switch_softc *);

struct filterops switch_rd_filtops = {
	1, NULL, filt_switch_rdetach, filt_switch_read
};
struct filterops switch_wr_filtops = {
	1, NULL, filt_switch_wdetach, filt_switch_write
};

struct switch_softc *
switch_dev2sc(dev_t dev)
{
	struct switch_softc	*sc;

	rw_enter_read(&switch_ifs_lk);
	sc = switch_lookup(minor(dev));
	rw_exit_read(&switch_ifs_lk);

	return (sc);
}

int
switchopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct switch_softc	*sc;
	char			 name[IFNAMSIZ];
	int			 rv, s, error = 0;
	unsigned int		 rdomain = rtable_l2(p->p_p->ps_rtableid);

	if ((sc = switch_dev2sc(dev)) == NULL) {
		snprintf(name, sizeof(name), "switch%d", minor(dev));
		NET_LOCK();
		rv = if_clone_create(name, rdomain);
		NET_UNLOCK();
		if (rv != 0)
			return (rv);
		if ((sc = switch_dev2sc(dev)) == NULL)
			return (ENXIO);
	}

	rw_enter_write(&switch_ifs_lk);
	if (sc->sc_swdev != NULL) {
		error = EBUSY;
		goto failed;
	}

	if ((sc->sc_swdev = malloc(sizeof(struct switch_dev), M_DEVBUF,
	    M_DONTWAIT|M_ZERO)) == NULL ) {
		error = ENOBUFS;
		goto failed;
	}

	s = splnet();
	mq_init(&sc->sc_swdev->swdev_outq, 128, IPL_NET);

	sc->sc_swdev->swdev_output = switch_dev_output;
	if (sc->sc_capabilities & SWITCH_CAP_OFP)
		swofp_init(sc);

	splx(s);

 failed:
	rw_exit_write(&switch_ifs_lk);
	return (error);

}

int
switchread(dev_t dev, struct uio *uio, int ioflag)
{
	struct switch_softc	*sc;
	struct mbuf		*m;
	u_int			 len;
	int			 s, error = 0;

	sc = switch_dev2sc(dev);
	if (sc == NULL)
		return (ENXIO);

	if (sc->sc_swdev->swdev_lastm != NULL) {
		m = sc->sc_swdev->swdev_lastm;
		sc->sc_swdev->swdev_lastm = NULL;
		goto skip_dequeue;
	}

 dequeue_next:
	s = splnet();
	while ((m = mq_dequeue(&sc->sc_swdev->swdev_outq)) == NULL) {
		if (ISSET(ioflag, IO_NDELAY)) {
			error = EWOULDBLOCK;
			goto failed;
		}
		sc->sc_swdev->swdev_waiting = 1;
		error = tsleep(sc, (PZERO + 1)|PCATCH, "switchread", 0);
		if (error != 0)
			goto failed;
		/* sc might be deleted while sleeping */
		sc = switch_dev2sc(dev);
		if (sc == NULL) {
			error = ENXIO;
			goto failed;
		}
	}
	splx(s);

 skip_dequeue:
	while (uio->uio_resid > 0) {
		len = ulmin(uio->uio_resid, m->m_len);
		if ((error = uiomove(mtod(m, caddr_t), len, uio)) != 0) {
			/* Save it so user can recover from EFAULT. */
			sc->sc_swdev->swdev_lastm = m;
			return (error);
		}

		/* Handle partial reads. */
		if (uio->uio_resid == 0) {
			if (len < m->m_len)
				m_adj(m, len);
			else
				m = m_free(m);
			sc->sc_swdev->swdev_lastm = m;
			break;
		}

		/*
		 * After consuming data from this mbuf test if we
		 * have to dequeue a new chain.
		 */
		m = m_free(m);
		if (m == NULL)
			goto dequeue_next;
	}

	return (0);
failed:
	splx(s);
	return (error);
}

int
switchwrite(dev_t dev, struct uio *uio, int ioflag)
{
	struct switch_softc	*sc = NULL;
	struct mbuf		*m, *n, *mhead, *mtail = NULL;
	int			 s, error, trailing;
	size_t			 len;

	if (uio->uio_resid == 0)
		return (0);

	len = uio->uio_resid;

	sc = switch_dev2sc(dev);
	if (sc == NULL)
		return (ENXIO);

	if (sc->sc_swdev->swdev_inputm == NULL) {
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			return (ENOBUFS);
		if (len >= MHLEN) {
			MCLGETI(m, M_DONTWAIT, NULL, MIN(MAXMCLBYTES, len));
			if ((m->m_flags & M_EXT) == 0) {
				m_free(m);
				return (ENOBUFS);
			}
		}
		mhead = m;

		/* M_TRAILINGSPACE() uses this to calculate space. */
		m->m_len = 0;
	} else {
		/* Recover the mbuf from the last write and get its tail. */
		mhead = sc->sc_swdev->swdev_inputm;
		for (m = mhead; m->m_next != NULL; m = m->m_next)
			/* NOTHING */;

		sc->sc_swdev->swdev_inputm = NULL;
	}

	while (len) {
		trailing = ulmin(M_TRAILINGSPACE(m), len);
		if ((error = uiomove(mtod(m, caddr_t), trailing, uio)) != 0)
			goto save_return;

		len -= trailing;
		mhead->m_pkthdr.len += trailing;
		m->m_len += trailing;
		if (len == 0)
			break;

		MGET(n, M_DONTWAIT, MT_DATA);
		if (n == NULL) {
			error = ENOBUFS;
			goto save_return;
		}
		if (len >= MLEN) {
			MCLGETI(n, M_DONTWAIT, NULL, MIN(MAXMCLBYTES, len));
			if ((n->m_flags & M_EXT) == 0) {
				m_free(n);
				error = ENOBUFS;
				goto save_return;
			}
		}
		n->m_len = 0;

		m->m_next = n;
		m = n;
	}

	/* Loop until there is no more complete OFP packets. */
	while (ofp_split_mbuf(mhead, &mtail) == 0) {
		s = splnet();
		sc->sc_swdev->swdev_input(sc, mhead);
		splx(s);

		/* We wrote everything, just quit. */
		if (mtail == NULL)
			return (0);

		mhead = mtail;
	}

	/* Save the head, because ofp_split_mbuf failed. */
	sc->sc_swdev->swdev_inputm = mhead;

	return (0);

 save_return:
	/* Save it so user can recover from errors later. */
	sc->sc_swdev->swdev_inputm = mhead;
	return (error);
}

int
switchioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
{
	int			 error;

	switch (cmd) {
	case FIONBIO:
	case FIOASYNC:
	case FIONREAD:
		return (0);
	default:
		error = ENOTTY;
		break;
	}

	return (error);
}

int
switchclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct switch_softc	*sc;

	rw_enter_write(&switch_ifs_lk);
	sc = switch_lookup(minor(dev));
	if (sc != NULL && sc->sc_swdev != NULL) {
		m_freem(sc->sc_swdev->swdev_lastm);
		m_freem(sc->sc_swdev->swdev_inputm);
		mq_purge(&sc->sc_swdev->swdev_outq);
		free(sc->sc_swdev, M_DEVBUF, sizeof(struct switch_dev));
		sc->sc_swdev = NULL;
	}
	rw_exit_write(&switch_ifs_lk);

	return (0);
}

void
switch_dev_destroy(struct switch_softc *sc)
{
	int	 s;

	if (sc->sc_swdev == NULL)
		return;
	rw_enter_write(&switch_ifs_lk);
	if (sc->sc_swdev != NULL) {
		switch_dev_wakeup(sc);

		s = splhigh();
		klist_invalidate(&sc->sc_swdev->swdev_rsel.si_note);
		klist_invalidate(&sc->sc_swdev->swdev_wsel.si_note);
		splx(s);

		m_freem(sc->sc_swdev->swdev_lastm);
		m_freem(sc->sc_swdev->swdev_inputm);
		mq_purge(&sc->sc_swdev->swdev_outq);
		free(sc->sc_swdev, M_DEVBUF, sizeof(struct switch_dev));
		sc->sc_swdev = NULL;
	}
	rw_exit_write(&switch_ifs_lk);
}

int
switchpoll(dev_t dev, int events, struct proc *p)
{
	int			 revents = 0;
	struct switch_softc	*sc = switch_dev2sc(dev);

	if (sc == NULL)
		return (ENXIO);

	if (events & (POLLIN | POLLRDNORM)) {
		if (!mq_empty(&sc->sc_swdev->swdev_outq) ||
		    sc->sc_swdev->swdev_lastm != NULL)
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM))
		revents |= events & (POLLOUT | POLLWRNORM);
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &sc->sc_swdev->swdev_rsel);
	}

	return (revents);
}

int
switchkqfilter(dev_t dev, struct knote *kn)
{
	struct switch_softc	*sc = switch_dev2sc(dev);
	struct klist		*klist;

	if (sc == NULL)
		return (ENXIO);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sc->sc_swdev->swdev_rsel.si_note;
		kn->kn_fop = &switch_rd_filtops;
		break;
	case EVFILT_WRITE:
		klist = &sc->sc_swdev->swdev_wsel.si_note;
		kn->kn_fop = &switch_wr_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)sc;

	SLIST_INSERT_HEAD(klist, kn, kn_selnext);

	return (0);
}

void
filt_switch_rdetach(struct knote *kn)
{
	struct switch_softc	*sc = (struct switch_softc *)kn->kn_hook;
	struct klist		*klist = &sc->sc_swdev->swdev_rsel.si_note;

	if (ISSET(kn->kn_status, KN_DETACHED))
		return;

	SLIST_REMOVE(klist, kn, knote, kn_selnext);
}

int
filt_switch_read(struct knote *kn, long hint)
{
	struct switch_softc	*sc = (struct switch_softc *)kn->kn_hook;

	if (ISSET(kn->kn_status, KN_DETACHED)) {
		kn->kn_data = 0;
		return (1);
	}

	if (!mq_empty(&sc->sc_swdev->swdev_outq) ||
	    sc->sc_swdev->swdev_lastm != NULL) {
		kn->kn_data = mq_len(&sc->sc_swdev->swdev_outq) +
		    (sc->sc_swdev->swdev_lastm != NULL);
		return (1);
	}

	return (0);
}

void
filt_switch_wdetach(struct knote *kn)
{
	struct switch_softc	*sc = (struct switch_softc *)kn->kn_hook;
	struct klist		*klist = &sc->sc_swdev->swdev_wsel.si_note;

	if (ISSET(kn->kn_status, KN_DETACHED))
		return;

	SLIST_REMOVE(klist, kn, knote, kn_selnext);
}

int
filt_switch_write(struct knote *kn, long hint)
{
	/* Always writable */
	return (1);
}

int
switch_dev_output(struct switch_softc *sc, struct mbuf *m)
{
	if (mq_enqueue(&sc->sc_swdev->swdev_outq, m) != 0)
		return (-1);
	switch_dev_wakeup(sc);

	return (0);
}

void
switch_dev_wakeup(struct switch_softc *sc)
{
	if (sc->sc_swdev->swdev_waiting) {
		sc->sc_swdev->swdev_waiting = 0;
		wakeup((caddr_t)sc);
	}
	selwakeup(&sc->sc_swdev->swdev_rsel);
}
@


1.11
log
@Fix declaration: vsw_dev2sc has been renamed to switch_dev2sc.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.10 2016/12/22 15:06:47 mikeb Exp $	*/
d91 1
a91 1
		NET_LOCK(s);
d93 1
a93 1
		NET_UNLOCK(s);
@


1.10
log
@Grab the netlock when device is opened;  ok mpi, rzalamena
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.9 2016/12/12 09:51:30 mpi Exp $	*/
d47 1
a47 1
struct switch_softc *vsw_dev2sc(dev_t);
@


1.9
log
@Remove most of the splsoftnet() recursions related to cloned interfaces.

inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.8 2016/11/11 16:19:09 rzalamena Exp $	*/
d91 1
a91 1
		s = splsoftnet();
d93 1
a93 1
		splx(s);
@


1.8
log
@Remove mutexes protection from the switchctl as they don't seem to be
doing anything for us, and remove some whitespaces from the header that
can be found near the removed lines.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.7 2016/11/10 17:32:40 rzalamena Exp $	*/
d87 1
d91 4
a94 2
		if ((rv = if_clone_create(name,
		    rtable_l2(p->p_p->ps_rtableid))) != 0)
@


1.7
log
@Add support for partial writes in switchwrite so we can use multiple
write() to write one packet. With this we also get support for writing
multiple ofp packets with a single write.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.6 2016/11/09 12:26:55 rzalamena Exp $	*/
a380 1
	struct mutex		*mtx;
a387 1
		mtx = &sc->sc_swdev->swdev_rsel_mtx;
a391 1
		mtx = &sc->sc_swdev->swdev_wsel_mtx;
a400 1
	mtx_enter(mtx);
a401 1
	mtx_leave(mtx);
a414 1
	mtx_enter(&sc->sc_swdev->swdev_rsel_mtx);
a415 1
	mtx_leave(&sc->sc_swdev->swdev_rsel_mtx);
a446 1
	mtx_enter(&sc->sc_swdev->swdev_wsel_mtx);
a447 1
	mtx_leave(&sc->sc_swdev->swdev_wsel_mtx);
@


1.6
log
@Simplify the switchread loop and fix the case where only first mbuf in
the chain was being read. While here rename mbuf variable and remove
unused ones.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.5 2016/11/08 19:11:57 rzalamena Exp $	*/
d200 6
a205 3
	int			 s, error;
	u_int			 len;
	struct mbuf		*m;
a206 2
	if (uio->uio_resid == 0 || uio->uio_resid > MAXMCLBYTES)
		return (EMSGSIZE);
d209 7
a215 7
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);
	if (len >= MHLEN) {
		MCLGETI(m, M_DONTWAIT, NULL, len);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
d217 35
d253 12
d267 11
a277 4
	error = uiomove(mtod(m, caddr_t), len, uio);
	if (error) {
		m_freem(m);
		return (error);
a278 1
	m->m_pkthdr.len = m->m_len = len;
d280 4
a283 6
	sc = switch_dev2sc(dev);
	if (sc == NULL)
		return (ENXIO);
	s = splnet();
	error = sc->sc_swdev->swdev_input(sc, m);
	splx(s);
d285 3
d318 1
d345 1
@


1.5
log
@Teach switch(4) device read(2) operations to behave like a stream socket,
so the userland programs can use it without having to do any special
treatment (e.g. having to read() whole packets with just 1 call or lose it).
This also allows userland to read more than one ofp header/payload with one
syscall.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.4 2016/09/04 15:46:39 reyk Exp $	*/
d128 1
a128 1
	int			 error = 0, s, truncated;
d130 1
a130 1
	struct mbuf		*m0, *m;
d137 1
a137 1
		m0 = sc->sc_swdev->swdev_lastm;
d144 1
a144 1
	while ((m0 = mq_dequeue(&sc->sc_swdev->swdev_outq)) == NULL) {
d163 3
a165 4
	while (m0 != NULL && uio->uio_resid > 0 && error == 0) {
		len = ulmin(uio->uio_resid, m0->m_len);
		truncated = uio->uio_resid < m0->m_len;
		if ((error = uiomove(mtod(m0, caddr_t), len, uio)) != 0) {
d167 1
a167 1
			sc->sc_swdev->swdev_lastm = m0;
d171 8
a178 5
		/* If we didn't finish moving, then save it for later. */
		if (truncated) {
			m_adj(m0, len);
			sc->sc_swdev->swdev_lastm = m0;
			return (0);
d181 7
a187 2
		m = m_free(m0);
		m0 = m;
a188 1
	m_freem(m0);
d190 1
a190 5
	/* Keep reading if the user wants more. */
	if (uio->uio_resid > 0)
		goto dequeue_next;

	return (error);
@


1.4
log
@When auto-creating an interface when opening a /dev/{tun,tap,switch}
device, inherit the rdomain from the calling process.  This adds an
rdomain argument to if_clone_create().

OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.3 2016/09/04 08:26:48 yasuoka Exp $	*/
d128 1
a128 1
	int			 error = 0, s;
d136 7
d162 1
d165 14
a178 1
		error = uiomove(mtod(m0, caddr_t), len, uio);
d184 4
d260 1
d286 1
d304 3
a306 2
		if (!mq_empty(&sc->sc_swdev->swdev_outq))
				revents |= events & (POLLIN | POLLRDNORM);
d376 4
a379 2
	if (!mq_empty(&sc->sc_swdev->swdev_outq)) {
		kn->kn_data = mq_len(&sc->sc_swdev->swdev_outq);
@


1.3
log
@Do "goto failed" in case returning EAGAIN as well.

ok goda
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.2 2016/09/03 18:33:55 goda Exp $	*/
d28 1
d31 1
d90 2
a91 1
		if ((rv = if_clone_create(name)) != 0)
@


1.2
log
@Fixed missing null check in switchctl.c

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.1 2016/09/01 10:06:33 goda Exp $	*/
d136 2
a137 2
			splx(s);
			return (EWOULDBLOCK);
@


1.1
log
@Import switch(4), an in-kernel OpenFlow switch which can work alone.
switch(4) currently supports OpenFlow 1.3.5.
Currently, it's disabled by the kernel config.

With help from yasuoka@@ reyk@@ jsg@@.

ok deraadt@@ yasuoka@@ reyk@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d129 4
a133 1
	sc = switch_dev2sc(dev);
d141 7
a147 3
		if (error != 0) {
			splx(s);
			return (error);
d161 3
d196 3
a199 1
	sc = switch_dev2sc(dev);
a209 1
	/* struct switch_softc	*sc = switch_dev2sc(dev); */
d231 1
a231 1
	if (sc->sc_swdev != NULL) {
d270 3
d293 3
@

