head	1.296;
access;
symbols
	OPENBSD_6_1:1.294.0.4
	OPENBSD_6_1_BASE:1.294
	OPENBSD_6_0:1.280.0.4
	OPENBSD_6_0_BASE:1.280
	OPENBSD_5_9:1.275.0.2
	OPENBSD_5_9_BASE:1.275
	OPENBSD_5_8:1.257.0.4
	OPENBSD_5_8_BASE:1.257
	OPENBSD_5_7:1.232.0.2
	OPENBSD_5_7_BASE:1.232
	OPENBSD_5_6:1.226.0.4
	OPENBSD_5_6_BASE:1.226
	OPENBSD_5_5:1.221.0.4
	OPENBSD_5_5_BASE:1.221
	OPENBSD_5_4:1.211.0.2
	OPENBSD_5_4_BASE:1.211
	OPENBSD_5_3:1.205.0.2
	OPENBSD_5_3_BASE:1.205
	OPENBSD_5_2:1.194.0.2
	OPENBSD_5_2_BASE:1.194
	OPENBSD_5_1_BASE:1.193
	OPENBSD_5_1:1.193.0.4
	OPENBSD_5_0:1.193.0.2
	OPENBSD_5_0_BASE:1.193
	OPENBSD_4_9:1.188.0.2
	OPENBSD_4_9_BASE:1.188
	OPENBSD_4_8:1.182.0.2
	OPENBSD_4_8_BASE:1.182
	OPENBSD_4_7:1.177.0.2
	OPENBSD_4_7_BASE:1.177
	OPENBSD_4_6:1.174.0.6
	OPENBSD_4_6_BASE:1.174
	OPENBSD_4_5:1.174.0.2
	OPENBSD_4_5_BASE:1.174
	OPENBSD_4_4:1.170.0.2
	OPENBSD_4_4_BASE:1.170
	OPENBSD_4_3:1.166.0.2
	OPENBSD_4_3_BASE:1.166
	OPENBSD_4_2:1.164.0.2
	OPENBSD_4_2_BASE:1.164
	OPENBSD_4_1:1.157.0.2
	OPENBSD_4_1_BASE:1.157
	OPENBSD_4_0:1.152.0.2
	OPENBSD_4_0_BASE:1.152
	OPENBSD_3_9:1.149.0.2
	OPENBSD_3_9_BASE:1.149
	OPENBSD_3_8:1.145.0.2
	OPENBSD_3_8_BASE:1.145
	OPENBSD_3_7:1.141.0.2
	OPENBSD_3_7_BASE:1.141
	OPENBSD_3_6:1.137.0.2
	OPENBSD_3_6_BASE:1.137
	SMP_SYNC_A:1.134
	SMP_SYNC_B:1.134
	OPENBSD_3_5:1.131.0.2
	OPENBSD_3_5_BASE:1.131
	OPENBSD_3_4:1.124.0.2
	OPENBSD_3_4_BASE:1.124
	UBC_SYNC_A:1.115
	OPENBSD_3_3:1.113.0.2
	OPENBSD_3_3_BASE:1.113
	OPENBSD_3_2:1.102.0.2
	OPENBSD_3_2_BASE:1.102
	OPENBSD_3_1:1.88.0.2
	OPENBSD_3_1_BASE:1.88
	UBC_SYNC_B:1.103
	UBC:1.81.0.2
	UBC_BASE:1.81
	OPENBSD_3_0:1.76.0.2
	OPENBSD_3_0_BASE:1.76
	OPENBSD_2_9_BASE:1.54
	OPENBSD_2_9:1.54.0.2
	OPENBSD_2_8:1.39.0.2
	OPENBSD_2_8_BASE:1.39
	OPENBSD_2_7:1.29.0.2
	OPENBSD_2_7_BASE:1.29
	SMP:1.25.0.2
	SMP_BASE:1.25
	kame_19991208:1.21
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8;
locks; strict;
comment	@ * @;


1.296
date	2017.05.15.12.57.42;	author mpi;	state Exp;
branches;
next	1.295;
commitid	nxn5v3rwFptTNICO;

1.295
date	2017.05.12.22.43.21;	author bluhm;	state Exp;
branches;
next	1.294;
commitid	dXIpMXpsMEaubkIY;

1.294
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.293;
commitid	2R0NOjEDy2jGtnjL;

1.293
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.292;
commitid	6c6qq5OdS4VVnyVM;

1.292
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.291;
commitid	F6oNrr9LCLUSAxgA;

1.291
date	2017.01.11.08.47.48;	author mpi;	state Exp;
branches;
next	1.290;
commitid	AJ9PmR6uM0vXGXzV;

1.290
date	2016.12.19.15.49.28;	author mpi;	state Exp;
branches;
next	1.289;
commitid	tz5ZYZJiWE9NLW4O;

1.289
date	2016.11.21.08.27.59;	author reyk;	state Exp;
branches;
next	1.288;
commitid	UsdV174yqvwg4F18;

1.288
date	2016.11.14.03.51.53;	author dlg;	state Exp;
branches;
next	1.287;
commitid	Khqq96MLd95C1Z1s;

1.287
date	2016.10.03.15.53.09;	author rzalamena;	state Exp;
branches;
next	1.286;
commitid	YndFnwkgIc17u5L3;

1.286
date	2016.10.03.12.26.13;	author rzalamena;	state Exp;
branches;
next	1.285;
commitid	599KriAM2Xmcdmg8;

1.285
date	2016.09.29.11.37.44;	author reyk;	state Exp;
branches;
next	1.284;
commitid	TXqeFb76AWQD8eLy;

1.284
date	2016.09.03.13.46.57;	author reyk;	state Exp;
branches;
next	1.283;
commitid	3QjHFZLzmkdTcUlc;

1.283
date	2016.09.02.10.01.36;	author goda;	state Exp;
branches;
next	1.282;
commitid	CnmnHsRybZkqp1q2;

1.282
date	2016.09.01.10.06.33;	author goda;	state Exp;
branches;
next	1.281;
commitid	53X2QcUepPKjCjvt;

1.281
date	2016.08.31.08.03.20;	author mpi;	state Exp;
branches;
next	1.280;
commitid	CgwDN6jcMMoz1ge3;

1.280
date	2016.06.07.08.32.13;	author mpi;	state Exp;
branches;
next	1.279;
commitid	9YGAaS6EQsWvPxlL;

1.279
date	2016.05.30.12.56.16;	author mpi;	state Exp;
branches;
next	1.278;
commitid	w2c3aw3HqpCfD4Ru;

1.278
date	2016.04.12.06.20.30;	author mpi;	state Exp;
branches;
next	1.277;
commitid	Itzt9gWTLLzkrbM4;

1.277
date	2016.03.30.12.16.30;	author dlg;	state Exp;
branches;
next	1.276;
commitid	D3kbyUytad7mmOyW;

1.276
date	2016.03.08.09.09.43;	author sashan;	state Exp;
branches;
next	1.275;
commitid	yFxyjGvyf63iGBYp;

1.275
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.274;
commitid	ILbVM1M3uPNjwswz;

1.274
date	2015.12.04.10.32.42;	author mpi;	state Exp;
branches;
next	1.273;
commitid	pBOUSZHQDL31zMCT;

1.273
date	2015.12.02.08.04.12;	author mpi;	state Exp;
branches;
next	1.272;
commitid	0dNWJQTSbuoeq2UO;

1.272
date	2015.12.01.18.28.29;	author goda;	state Exp;
branches;
next	1.271;
commitid	6ZruJ8AlaPn1cF8H;

1.271
date	2015.12.01.14.49.04;	author goda;	state Exp;
branches;
next	1.270;
commitid	kvH9ljJuVWRQIf5W;

1.270
date	2015.11.07.12.42.19;	author mpi;	state Exp;
branches;
next	1.269;
commitid	3n9C29EcvMo1935D;

1.269
date	2015.11.07.12.37.18;	author mpi;	state Exp;
branches;
next	1.268;
commitid	pimjpVkDm7QHrGoX;

1.268
date	2015.10.12.10.03.25;	author reyk;	state Exp;
branches;
next	1.267;
commitid	72QrVtUd9Ypwyhgg;

1.267
date	2015.10.05.19.05.09;	author uebayasi;	state Exp;
branches;
next	1.266;
commitid	KaQeg2gqRFHdXmok;

1.266
date	2015.10.05.15.52.46;	author uebayasi;	state Exp;
branches;
next	1.265;
commitid	Jb3hy8KXZkqIykJt;

1.265
date	2015.09.29.10.11.40;	author deraadt;	state Exp;
branches;
next	1.264;
commitid	L3Bwt4zBOCs33Zbo;

1.264
date	2015.09.10.16.41.30;	author mikeb;	state Exp;
branches;
next	1.263;
commitid	Dj2db8t0KelqURhl;

1.263
date	2015.09.10.15.27.00;	author mpi;	state Exp;
branches;
next	1.262;
commitid	f2iSVWb7EB7R56va;

1.262
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.261;
commitid	JbEzJsyDrWqOW57C;

1.261
date	2015.09.09.12.50.08;	author mpi;	state Exp;
branches;
next	1.260;
commitid	3dyjGr1P4z63tEd8;

1.260
date	2015.08.26.09.40.31;	author mpi;	state Exp;
branches;
next	1.259;
commitid	RxLr6LsQrr3cFYMU;

1.259
date	2015.08.24.21.28.47;	author bluhm;	state Exp;
branches;
next	1.258;
commitid	FmknfKH1sTvQ2vzt;

1.258
date	2015.08.18.09.01.16;	author mpi;	state Exp;
branches;
next	1.257;
commitid	mgqCaY3zFk7ZApqm;

1.257
date	2015.07.20.22.54.29;	author mpi;	state Exp;
branches;
next	1.256;
commitid	kUJLGGhKrehg9sRa;

1.256
date	2015.07.20.22.16.41;	author rzalamena;	state Exp;
branches;
next	1.255;
commitid	yaHvJbufOxtjWSFd;

1.255
date	2015.07.17.18.05.59;	author mpi;	state Exp;
branches;
next	1.254;
commitid	urytYsjJJXbr5ECc;

1.254
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.253;
commitid	VGPlklxThaST7mIm;

1.253
date	2015.07.15.22.16.41;	author deraadt;	state Exp;
branches;
next	1.252;
commitid	ncpqEGjDtSFuLAgn;

1.252
date	2015.07.02.10.02.40;	author mpi;	state Exp;
branches;
next	1.251;
commitid	nKROsdKiADu5GTos;

1.251
date	2015.07.02.09.40.02;	author mpi;	state Exp;
branches;
next	1.250;
commitid	eKXa0TkOIth1tkBS;

1.250
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.249;
commitid	fE8TgA9vpwdUU5Wy;

1.249
date	2015.06.30.09.13.53;	author mpi;	state Exp;
branches;
next	1.248;
commitid	QALZZlzlQWtO847F;

1.248
date	2015.06.25.09.38.00;	author mpi;	state Exp;
branches;
next	1.247;
commitid	TfYAgG7iXwfMt3Ba;

1.247
date	2015.06.25.09.20.20;	author mpi;	state Exp;
branches;
next	1.246;
commitid	qTf6nSNIg5TdnuJD;

1.246
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.245;
commitid	MVWrtktB46JRxFWT;

1.245
date	2015.06.23.09.42.23;	author mpi;	state Exp;
branches;
next	1.244;
commitid	p9JxIlTsQMWvTdAT;

1.244
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.243;
commitid	h7z8lokZ0dFyuWpg;

1.243
date	2015.06.12.15.40.06;	author mpi;	state Exp;
branches;
next	1.242;
commitid	coEwu2NSN2XfPU4N;

1.242
date	2015.06.11.15.59.17;	author mikeb;	state Exp;
branches;
next	1.241;
commitid	m5XqNI2MUatfnThg;

1.241
date	2015.06.08.13.44.08;	author mpi;	state Exp;
branches;
next	1.240;
commitid	QBkAtlGdp82XwFPf;

1.240
date	2015.06.02.13.21.21;	author mpi;	state Exp;
branches;
next	1.239;
commitid	h9qOTGSdHykhCmn6;

1.239
date	2015.05.18.11.43.57;	author mpi;	state Exp;
branches;
next	1.238;
commitid	auGnzSz1eSWcs4wu;

1.238
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.237;
commitid	1aiWjheMGhmTuiHL;

1.237
date	2015.05.07.01.55.43;	author jsg;	state Exp;
branches;
next	1.236;
commitid	KhO2CJgSFKm4Q3Hj;

1.236
date	2015.05.04.10.24.08;	author mpi;	state Exp;
branches;
next	1.235;
commitid	pcqNjYq7eK2oXz3l;

1.235
date	2015.04.17.11.04.01;	author mikeb;	state Exp;
branches;
next	1.234;
commitid	6glXvFR7NxzCcdRd;

1.234
date	2015.04.13.08.52.51;	author mpi;	state Exp;
branches;
next	1.233;
commitid	eIjCB6UMjE3earTB;

1.233
date	2015.04.07.10.46.20;	author mpi;	state Exp;
branches;
next	1.232;
commitid	m3c6YErI0cVMQeYc;

1.232
date	2015.02.06.22.10.43;	author benno;	state Exp;
branches;
next	1.231;
commitid	PDEEvrfAGL8hPDjx;

1.231
date	2014.12.22.03.38.01;	author tedu;	state Exp;
branches;
next	1.230;
commitid	2s9cV5abDgo3vkqh;

1.230
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.229;
commitid	zhW8jJrfVCoAthrR;

1.229
date	2014.12.04.16.16.20;	author mikeb;	state Exp;
branches;
next	1.228;
commitid	XtUzRZLlJ4SNVBAX;

1.228
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.227;
commitid	Z1vcFtHO8wRH0yRt;

1.227
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.226;
commitid	ZqXwxwmeo3l29NOg;

1.226
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches
	1.226.4.1;
next	1.225;
commitid	DQakU8LLWV6Iwx84;

1.225
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.224;
commitid	B4dZSbxas1X1IpXI;

1.224
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.223;
commitid	Nnxg8ONtI4Ep9pUb;

1.223
date	2014.04.19.14.39.26;	author henning;	state Exp;
branches;
next	1.222;

1.222
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.221;

1.221
date	2014.01.24.18.54.58;	author henning;	state Exp;
branches;
next	1.220;

1.220
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.219;

1.219
date	2013.10.28.12.39.42;	author mpi;	state Exp;
branches;
next	1.218;

1.218
date	2013.10.17.16.27.40;	author bluhm;	state Exp;
branches;
next	1.217;

1.217
date	2013.10.13.12.09.53;	author reyk;	state Exp;
branches;
next	1.216;

1.216
date	2013.10.13.10.10.02;	author reyk;	state Exp;
branches;
next	1.215;

1.215
date	2013.10.12.11.55.45;	author henning;	state Exp;
branches;
next	1.214;

1.214
date	2013.08.21.13.53.48;	author mpi;	state Exp;
branches;
next	1.213;

1.213
date	2013.08.05.11.18.03;	author mikeb;	state Exp;
branches;
next	1.212;

1.212
date	2013.07.31.15.41.51;	author mikeb;	state Exp;
branches;
next	1.211;

1.211
date	2013.06.26.09.12.39;	author henning;	state Exp;
branches;
next	1.210;

1.210
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.209;

1.209
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.208;

1.208
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.207;

1.207
date	2013.03.26.13.19.25;	author mpi;	state Exp;
branches;
next	1.206;

1.206
date	2013.03.15.20.45.34;	author tedu;	state Exp;
branches;
next	1.205;

1.205
date	2013.01.23.13.28.36;	author camield;	state Exp;
branches;
next	1.204;

1.204
date	2012.12.22.13.20.32;	author camield;	state Exp;
branches;
next	1.203;

1.203
date	2012.12.07.23.52.09;	author weerd;	state Exp;
branches;
next	1.202;

1.202
date	2012.11.06.12.32.41;	author henning;	state Exp;
branches;
next	1.201;

1.201
date	2012.11.01.07.55.55;	author henning;	state Exp;
branches;
next	1.200;

1.200
date	2012.10.10.11.14.08;	author henning;	state Exp;
branches;
next	1.199;

1.199
date	2012.10.08.18.48.25;	author camield;	state Exp;
branches;
next	1.198;

1.198
date	2012.10.06.18.44.47;	author camield;	state Exp;
branches;
next	1.197;

1.197
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.196;

1.196
date	2012.09.20.14.10.18;	author mpf;	state Exp;
branches;
next	1.195;

1.195
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.194;

1.194
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.193;

1.193
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.192;

1.192
date	2011.05.16.20.06.28;	author henning;	state Exp;
branches;
next	1.191;

1.191
date	2011.04.10.20.09.21;	author claudio;	state Exp;
branches;
next	1.190;

1.190
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.189;

1.189
date	2011.04.04.13.55.54;	author henning;	state Exp;
branches;
next	1.188;

1.188
date	2010.11.04.23.07.15;	author weerd;	state Exp;
branches;
next	1.187;

1.187
date	2010.10.31.15.14.30;	author mpf;	state Exp;
branches;
next	1.186;

1.186
date	2010.10.28.19.00.57;	author mpf;	state Exp;
branches;
next	1.185;

1.185
date	2010.10.28.13.49.54;	author claudio;	state Exp;
branches;
next	1.184;

1.184
date	2010.09.28.08.13.11;	author blambert;	state Exp;
branches;
next	1.183;

1.183
date	2010.09.24.15.22.29;	author blambert;	state Exp;
branches;
next	1.182;

1.182
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.181;

1.181
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.180;

1.180
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.179;

1.179
date	2010.06.29.21.28.37;	author reyk;	state Exp;
branches;
next	1.178;

1.178
date	2010.06.03.16.15.00;	author naddy;	state Exp;
branches;
next	1.177;

1.177
date	2010.01.13.05.25.06;	author claudio;	state Exp;
branches;
next	1.176;

1.176
date	2009.11.22.12.33.25;	author deraadt;	state Exp;
branches;
next	1.175;

1.175
date	2009.11.09.03.16.05;	author deraadt;	state Exp;
branches;
next	1.174;

1.174
date	2009.01.06.21.23.18;	author claudio;	state Exp;
branches;
next	1.173;

1.173
date	2008.10.16.19.12.51;	author naddy;	state Exp;
branches;
next	1.172;

1.172
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.171;

1.171
date	2008.09.02.17.35.16;	author chl;	state Exp;
branches;
next	1.170;

1.170
date	2008.06.14.21.46.22;	author reyk;	state Exp;
branches;
next	1.169;

1.169
date	2008.05.21.21.12.07;	author mk;	state Exp;
branches;
next	1.168;

1.168
date	2008.05.07.13.45.35;	author dlg;	state Exp;
branches;
next	1.167;

1.167
date	2008.04.24.11.36.38;	author dlg;	state Exp;
branches;
next	1.166;

1.166
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.165;

1.165
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.164;

1.164
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.163;

1.163
date	2007.05.28.06.31.01;	author mcbride;	state Exp;
branches;
next	1.162;

1.162
date	2007.05.26.17.13.30;	author jason;	state Exp;
branches;
next	1.161;

1.161
date	2007.05.21.13.33.35;	author markus;	state Exp;
branches;
next	1.160;

1.160
date	2007.05.16.20.27.58;	author michele;	state Exp;
branches;
next	1.159;

1.159
date	2007.05.15.20.14.48;	author claudio;	state Exp;
branches;
next	1.158;

1.158
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.157;

1.157
date	2007.01.08.13.52.38;	author michele;	state Exp;
branches;
next	1.156;

1.156
date	2006.12.28.20.06.11;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2006.12.11.22.11.48;	author reyk;	state Exp;
branches;
next	1.154;

1.154
date	2006.12.03.13.41.19;	author reyk;	state Exp;
branches;
next	1.153;

1.153
date	2006.11.30.13.25.03;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2006.07.06.15.50.59;	author henning;	state Exp;
branches;
next	1.151;

1.151
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.150;

1.150
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.149;

1.149
date	2006.01.23.22.46.57;	author markus;	state Exp;
branches;
next	1.148;

1.148
date	2006.01.05.03.28.34;	author deraadt;	state Exp;
branches;
next	1.147;

1.147
date	2006.01.04.06.04.41;	author canacar;	state Exp;
branches;
next	1.146;

1.146
date	2005.10.09.19.44.22;	author reyk;	state Exp;
branches;
next	1.145;

1.145
date	2005.07.31.03.30.55;	author pascoe;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2005.06.16.11.10.47;	author markus;	state Exp;
branches;
next	1.143;

1.143
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.142;

1.142
date	2005.04.25.01.34.27;	author brad;	state Exp;
branches;
next	1.141;

1.141
date	2004.12.23.09.32.55;	author camield;	state Exp;
branches
	1.141.2.1;
next	1.140;

1.140
date	2004.12.19.03.25.36;	author mcbride;	state Exp;
branches;
next	1.139;

1.139
date	2004.12.17.12.42.02;	author pascoe;	state Exp;
branches;
next	1.138;

1.138
date	2004.10.09.19.55.28;	author brad;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.18.11.07.47;	author markus;	state Exp;
branches;
next	1.136;

1.136
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.135;

1.135
date	2004.06.21.19.26.01;	author mcbride;	state Exp;
branches;
next	1.134;

1.134
date	2004.05.04.18.03.58;	author canacar;	state Exp;
branches;
next	1.133;

1.133
date	2004.05.04.16.59.32;	author grange;	state Exp;
branches;
next	1.132;

1.132
date	2004.04.28.02.51.58;	author cedric;	state Exp;
branches;
next	1.131;

1.131
date	2004.02.10.20.20.01;	author itojun;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2004.02.02.19.56.23;	author cedric;	state Exp;
branches;
next	1.129;

1.129
date	2003.12.17.13.08.41;	author markus;	state Exp;
branches;
next	1.128;

1.128
date	2003.12.16.21.35.28;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2003.12.03.14.55.58;	author markus;	state Exp;
branches;
next	1.125;

1.125
date	2003.10.02.05.50.34;	author itojun;	state Exp;
branches;
next	1.124;

1.124
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches
	1.124.2.1;
next	1.123;

1.123
date	2003.07.28.00.58.08;	author itojun;	state Exp;
branches;
next	1.122;

1.122
date	2003.07.25.10.36.34;	author itojun;	state Exp;
branches;
next	1.121;

1.121
date	2003.06.30.19.09.25;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2003.06.30.10.51.09;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2003.06.25.09.41.18;	author henning;	state Exp;
branches;
next	1.118;

1.118
date	2003.06.02.18.42.56;	author jason;	state Exp;
branches;
next	1.117;

1.117
date	2003.05.30.21.15.41;	author henning;	state Exp;
branches;
next	1.116;

1.116
date	2003.05.30.20.08.34;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2003.03.31.22.59.47;	author millert;	state Exp;
branches;
next	1.113;

1.113
date	2003.03.11.16.06.25;	author markus;	state Exp;
branches
	1.113.2.1;
next	1.112;

1.112
date	2003.02.21.21.49.37;	author jason;	state Exp;
branches;
next	1.111;

1.111
date	2003.02.17.18.23.22;	author jason;	state Exp;
branches;
next	1.110;

1.110
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2003.01.07.17.47.21;	author jason;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.107;

1.107
date	2003.01.03.15.57.56;	author jason;	state Exp;
branches;
next	1.106;

1.106
date	2002.12.09.22.32.01;	author jason;	state Exp;
branches;
next	1.105;

1.105
date	2002.12.09.10.11.52;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2002.12.04.15.44.21;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2002.10.10.17.27.40;	author dhartmei;	state Exp;
branches;
next	1.102;

1.102
date	2002.08.07.18.44.39;	author jason;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2002.07.02.23.36.16;	author mickey;	state Exp;
branches;
next	1.100;

1.100
date	2002.07.01.22.24.44;	author jason;	state Exp;
branches;
next	1.99;

1.99
date	2002.06.30.13.04.35;	author itojun;	state Exp;
branches;
next	1.98;

1.98
date	2002.06.15.05.17.18;	author jason;	state Exp;
branches;
next	1.97;

1.97
date	2002.06.15.02.26.39;	author angelos;	state Exp;
branches;
next	1.96;

1.96
date	2002.06.11.04.27.11;	author art;	state Exp;
branches;
next	1.95;

1.95
date	2002.06.10.09.13.26;	author itojun;	state Exp;
branches;
next	1.94;

1.94
date	2002.06.09.20.30.45;	author jason;	state Exp;
branches;
next	1.93;

1.93
date	2002.06.08.23.15.58;	author jasoni;	state Exp;
branches;
next	1.92;

1.92
date	2002.06.08.23.04.53;	author jasoni;	state Exp;
branches;
next	1.91;

1.91
date	2002.06.07.18.29.43;	author jasoni;	state Exp;
branches;
next	1.90;

1.90
date	2002.05.31.20.58.25;	author itojun;	state Exp;
branches;
next	1.89;

1.89
date	2002.05.28.15.46.24;	author jasoni;	state Exp;
branches;
next	1.88;

1.88
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.87;

1.87
date	2002.03.18.10.31.25;	author jasoni;	state Exp;
branches;
next	1.86;

1.86
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.85;

1.85
date	2002.02.14.00.55.49;	author jason;	state Exp;
branches;
next	1.84;

1.84
date	2002.02.07.23.50.20;	author jason;	state Exp;
branches;
next	1.83;

1.83
date	2002.01.02.20.06.03;	author jason;	state Exp;
branches;
next	1.82;

1.82
date	2002.01.01.22.39.45;	author jason;	state Exp;
branches;
next	1.81;

1.81
date	2001.12.15.08.40.56;	author jason;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2001.12.13.04.59.53;	author jasoni;	state Exp;
branches;
next	1.79;

1.79
date	2001.12.10.05.46.57;	author jasoni;	state Exp;
branches;
next	1.78;

1.78
date	2001.12.08.18.07.57;	author jason;	state Exp;
branches;
next	1.77;

1.77
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches;
next	1.76;

1.76
date	2001.08.21.15.18.20;	author jason;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2001.08.12.00.09.29;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2001.07.27.22.31.47;	author jason;	state Exp;
branches;
next	1.73;

1.73
date	2001.07.25.04.59.33;	author jason;	state Exp;
branches;
next	1.72;

1.72
date	2001.07.25.03.43.41;	author jason;	state Exp;
branches;
next	1.71;

1.71
date	2001.07.17.20.34.51;	author provos;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.28.21.53.42;	author provos;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.27.06.26.43;	author angelos;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.27.06.07.39;	author kjc;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.26.18.17.53;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.25.05.04.43;	author kjell;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.24.22.34.05;	author fgsch;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.24.20.12.50;	author jason;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.23.07.08.51;	author angelos;	state Exp;
branches;
next	1.62;

1.62
date	2001.06.23.06.24.23;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2001.06.22.14.28.58;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.15.03.38.33;	author itojun;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.07.04.12.58;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.06.22.55.03;	author jasoni;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.01.00.28.25;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.30.02.12.24;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.11.04.56.15;	author jason;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.22.02.00.36;	author jason;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2001.03.19.23.58.38;	author jason;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.06.06.29.16;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.05.03.38.38;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.06.06.48.08;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2001.02.04.18.10.10;	author jason;	state Exp;
branches;
next	1.48;

1.48
date	2001.02.02.06.01.18;	author jason;	state Exp;
branches;
next	1.47;

1.47
date	2001.02.01.01.32.51;	author jason;	state Exp;
branches;
next	1.46;

1.46
date	2001.01.30.04.22.24;	author kjell;	state Exp;
branches;
next	1.45;

1.45
date	2001.01.17.04.47.18;	author fgsch;	state Exp;
branches;
next	1.44;

1.44
date	2000.12.30.22.56.23;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2000.12.12.03.41.22;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2000.11.10.05.24.58;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.07.05.38.53;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.06.01.40.28;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.18.18.48.21;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.18.16.30.28;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.18.04.31.14;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.09.17.01.10;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.26.23.16.37;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.22.19.00.21;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.20.05.50.16;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.16.21.43.04;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.02.00.36.42;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.25.00.30.27;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.10.13.34.54;	author jason;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2000.02.28.23.41.28;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.21.17.38.07;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.19.08.59.05;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.25.22.06.27;	author jason;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2000.01.15.20.02.36;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.15.05.02.46;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.10.22.18.29;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	99.11.04.05.13.14;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	99.10.27.03.41.48;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	99.10.26.03.40.17;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	99.09.30.02.10.18;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	99.09.03.12.47.12;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	99.09.01.21.38.48;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	99.08.20.04.53.17;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	99.08.08.02.42.58;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.07.24.19.11.13;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	99.06.30.00.00.29;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	99.06.03.21.52.02;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.05.24.23.09.10;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	99.03.19.22.47.33;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	99.03.19.02.46.54;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	99.03.12.02.40.43;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.03.05.22.09.18;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.03.05.21.10.52;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.04.44.44;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.02.27.21.19.27;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.17.01.31;	author jason;	state Exp;
branches;
next	;

1.25.2.1
date	2000.02.20.11.57.20;	author niklas;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2000.02.21.22.29.14;	author niklas;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2000.03.02.07.04.41;	author niklas;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2001.05.14.22.39.59;	author niklas;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2001.07.04.10.53.56;	author niklas;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.25.2.7;

1.25.2.7
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.25.2.8;

1.25.2.8
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.25.2.9;

1.25.2.9
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.25.2.10;

1.25.2.10
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.25.2.11;

1.25.2.11
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.25.2.12;

1.25.2.12
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.25.2.13;

1.25.2.13
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.25.2.14;

1.25.2.14
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.29.2.1
date	2000.05.27.20.17.12;	author jason;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2000.06.18.02.08.07;	author jason;	state Exp;
branches;
next	;

1.54.2.1
date	2001.08.21.21.30.56;	author jason;	state Exp;
branches;
next	;

1.76.2.1
date	2002.01.21.17.52.17;	author jason;	state Exp;
branches;
next	;

1.81.2.1
date	2002.01.31.22.55.43;	author niklas;	state Exp;
branches;
next	1.81.2.2;

1.81.2.2
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.81.2.3;

1.81.2.3
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.81.2.4;

1.81.2.4
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;

1.102.2.1
date	2002.11.04.14.33.50;	author jason;	state Exp;
branches;
next	;

1.113.2.1
date	2004.03.14.00.15.05;	author brad;	state Exp;
branches;
next	;

1.124.2.1
date	2004.03.14.00.13.42;	author brad;	state Exp;
branches;
next	1.124.2.2;

1.124.2.2
date	2004.08.25.21.45.52;	author brad;	state Exp;
branches;
next	;

1.131.2.1
date	2004.08.25.21.44.41;	author brad;	state Exp;
branches;
next	;

1.141.2.1
date	2006.01.26.20.43.21;	author brad;	state Exp;
branches;
next	;

1.145.2.1
date	2006.01.26.20.52.57;	author brad;	state Exp;
branches;
next	;

1.226.4.1
date	2015.01.03.00.32.02;	author brad;	state Exp;
branches;
next	;
commitid	u03HAMtv96SmNtXn;


desc
@@


1.296
log
@bridge_ioctl() doesn't need to call splnet().

All interface ioctl()s are executed with the NET_LOCK() held, which
protects all soft states of the network stack.  IPL_NET is only needed
in drivers dealing with hardware and by extension the wireless stack.
@
text
@/*	$OpenBSD: if_bridge.c,v 1.295 2017/05/12 22:43:21 bluhm Exp $	*/

/*
 * Copyright (c) 1999, 2000 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include "bpfilter.h"
#include "gif.h"
#include "pf.h"
#include "carp.h"
#include "vlan.h"
#include "mpw.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_llc.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/if_ether.h>
#include <netinet/ip_icmp.h>

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#include <net/if_enc.h>
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#define	BRIDGE_IN	PF_IN
#define	BRIDGE_OUT	PF_OUT
#else
#define	BRIDGE_IN	0
#define	BRIDGE_OUT	1
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

#include <net/if_bridge.h>

/*
 * Maximum number of addresses to cache
 */
#ifndef	BRIDGE_RTABLE_MAX
#define	BRIDGE_RTABLE_MAX	100
#endif

/*
 * Timeout (in seconds) for entries learned dynamically
 */
#ifndef	BRIDGE_RTABLE_TIMEOUT
#define	BRIDGE_RTABLE_TIMEOUT	240
#endif

void	bridgeattach(int);
int	bridge_ioctl(struct ifnet *, u_long, caddr_t);
void	bridge_ifdetach(void *);
void	bridge_spandetach(void *);
int	bridge_input(struct ifnet *, struct mbuf *, void *);
void	bridge_process(struct ifnet *, struct mbuf *);
void	bridgeintr_frame(struct bridge_softc *, struct ifnet *, struct mbuf *);
void	bridge_broadcast(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void	bridge_localbroadcast(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void	bridge_span(struct bridge_softc *, struct mbuf *);
void	bridge_stop(struct bridge_softc *);
void	bridge_init(struct bridge_softc *);
int	bridge_bifconf(struct bridge_softc *, struct ifbifconf *);
int bridge_blocknonip(struct ether_header *, struct mbuf *);
void	bridge_ifinput(struct ifnet *, struct mbuf *);
int	bridge_dummy_output(struct ifnet *, struct mbuf *, struct sockaddr *,
    struct rtentry *);
#ifdef IPSEC
int bridge_ipsec(struct bridge_softc *, struct ifnet *,
    struct ether_header *, int, struct llc *,
    int, int, int, struct mbuf *);
#endif
int     bridge_clone_create(struct if_clone *, int);
int	bridge_clone_destroy(struct ifnet *ifp);
int	bridge_delete(struct bridge_softc *, struct bridge_iflist *);

#define	ETHERADDR_IS_IP_MCAST(a) \
	/* struct etheraddr *a;	*/				\
	((a)->ether_addr_octet[0] == 0x01 &&			\
	 (a)->ether_addr_octet[1] == 0x00 &&			\
	 (a)->ether_addr_octet[2] == 0x5e)

struct niqueue bridgeintrq = NIQUEUE_INITIALIZER(1024, NETISR_BRIDGE);

struct if_clone bridge_cloner =
    IF_CLONE_INITIALIZER("bridge", bridge_clone_create, bridge_clone_destroy);

void
bridgeattach(int n)
{
	if_clone_attach(&bridge_cloner);
}

int
bridge_clone_create(struct if_clone *ifc, int unit)
{
	struct bridge_softc *sc;
	struct ifnet *ifp;
	int i;

	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!sc)
		return (ENOMEM);

	sc->sc_stp = bstp_create(&sc->sc_if);
	if (!sc->sc_stp) {
		free(sc, M_DEVBUF, sizeof *sc);
		return (ENOMEM);
	}

	sc->sc_brtmax = BRIDGE_RTABLE_MAX;
	sc->sc_brttimeout = BRIDGE_RTABLE_TIMEOUT;
	timeout_set(&sc->sc_brtimeout, bridge_rtage, sc);
	TAILQ_INIT(&sc->sc_iflist);
	TAILQ_INIT(&sc->sc_spanlist);
	for (i = 0; i < BRIDGE_RTABLE_SIZE; i++)
		LIST_INIT(&sc->sc_rts[i]);
	arc4random_buf(&sc->sc_hashkey, sizeof(sc->sc_hashkey));
	ifp = &sc->sc_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name,
	    unit);
	ifp->if_softc = sc;
	ifp->if_mtu = ETHERMTU;
	ifp->if_ioctl = bridge_ioctl;
	ifp->if_output = bridge_dummy_output;
	ifp->if_xflags = IFXF_CLONED;
	ifp->if_start = NULL;
	ifp->if_type = IFT_BRIDGE;
	ifp->if_hdrlen = ETHER_HDR_LEN;

	if_attach(ifp);
	if_alloc_sadl(ifp);

#if NBPFILTER > 0
	bpfattach(&sc->sc_if.if_bpf, ifp,
	    DLT_EN10MB, ETHER_HDR_LEN);
#endif

	if_ih_insert(ifp, ether_input, NULL);

	return (0);
}

int
bridge_dummy_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	m_freem(m);
	return (EAFNOSUPPORT);
}

int
bridge_clone_destroy(struct ifnet *ifp)
{
	struct bridge_softc *sc = ifp->if_softc;
	struct bridge_iflist *bif;

	bridge_stop(sc);
	bridge_rtflush(sc, IFBF_FLUSHALL);
	while ((bif = TAILQ_FIRST(&sc->sc_iflist)) != NULL)
		bridge_delete(sc, bif);
	while ((bif = TAILQ_FIRST(&sc->sc_spanlist)) != NULL)
		bridge_spandetach(bif);

	bstp_destroy(sc->sc_stp);

	/* Undo pseudo-driver changes. */
	if_deactivate(ifp);

	if_ih_remove(ifp, ether_input, NULL);

	KASSERT(SRPL_EMPTY_LOCKED(&ifp->if_inputs));

	if_detach(ifp);

	free(sc, M_DEVBUF, sizeof *sc);
	return (0);
}

int
bridge_delete(struct bridge_softc *sc, struct bridge_iflist *p)
{
	int error;

	if (p->bif_flags & IFBIF_STP)
		bstp_delete(p->bif_stp);

	p->ifp->if_bridgeport = NULL;
	error = ifpromisc(p->ifp, 0);
	hook_disestablish(p->ifp->if_detachhooks, p->bif_dhcookie);

	if_ih_remove(p->ifp, bridge_input, NULL);
	TAILQ_REMOVE(&sc->sc_iflist, p, next);
	bridge_rtdelete(sc, p->ifp, 0);
	bridge_flushrule(p);
	free(p, M_DEVBUF, sizeof *p);

	return (error);
}

int
bridge_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct bridge_softc *sc = (struct bridge_softc *)ifp->if_softc;
	struct ifbreq *req = (struct ifbreq *)data;
	struct ifbropreq *brop = (struct ifbropreq *)data;
	struct ifnet *ifs;
	struct bridge_iflist *p;
	struct bstp_port *bp;
	struct bstp_state *bs = sc->sc_stp;
	int error = 0;

	switch (cmd) {
	case SIOCBRDGADD:
	/* bridge(4) does not distinguish between routing/forwarding ports */
	case SIOCBRDGADDL:
		if ((error = suser(curproc, 0)) != 0)
			break;

		ifs = ifunit(req->ifbr_ifsname);
		if (ifs == NULL) {			/* no such interface */
			error = ENOENT;
			break;
		}
		if (ifs->if_bridgeport != NULL) {
			p = (struct bridge_iflist *)ifs->if_bridgeport;
			if (p->bridge_sc == sc)
				error = EEXIST;
			else
				error = EBUSY;
			break;
		}

		/* If it's in the span list, it can't be a member. */
		TAILQ_FOREACH(p, &sc->sc_spanlist, next)
			if (p->ifp == ifs)
				break;
		if (p != NULL) {
			error = EBUSY;
			break;
		}

		if (ifs->if_type == IFT_ETHER) {
			if ((ifs->if_flags & IFF_UP) == 0) {
				struct ifreq ifreq;

				/*
				 * Bring interface up long enough to set
				 * promiscuous flag, then shut it down again.
				 */
				strlcpy(ifreq.ifr_name, req->ifbr_ifsname,
				    IFNAMSIZ);
				ifs->if_flags |= IFF_UP;
				ifreq.ifr_flags = ifs->if_flags;
				error = (*ifs->if_ioctl)(ifs, SIOCSIFFLAGS,
				    (caddr_t)&ifreq);
				if (error != 0)
					break;

				error = ifpromisc(ifs, 1);
				if (error != 0)
					break;

				strlcpy(ifreq.ifr_name, req->ifbr_ifsname,
				    IFNAMSIZ);
				ifs->if_flags &= ~IFF_UP;
				ifreq.ifr_flags = ifs->if_flags;
				error = (*ifs->if_ioctl)(ifs, SIOCSIFFLAGS,
				    (caddr_t)&ifreq);
				if (error != 0) {
					ifpromisc(ifs, 0);
					break;
				}
			} else {
				error = ifpromisc(ifs, 1);
				if (error != 0)
					break;
			}
		}
#if NMPW > 0
		else if (ifs->if_type == IFT_MPLSTUNNEL) {
			/* Nothing needed */
		}
#endif /* NMPW */
		else {
			error = EINVAL;
			break;
		}

		p = malloc(sizeof(*p), M_DEVBUF, M_NOWAIT|M_ZERO);
		if (p == NULL) {
			if (ifs->if_type == IFT_ETHER)
				ifpromisc(ifs, 0);
			error = ENOMEM;
			break;
		}

		p->bridge_sc = sc;
		p->ifp = ifs;
		p->bif_flags = IFBIF_LEARNING | IFBIF_DISCOVER;
		SIMPLEQ_INIT(&p->bif_brlin);
		SIMPLEQ_INIT(&p->bif_brlout);
		ifs->if_bridgeport = (caddr_t)p;
		p->bif_dhcookie = hook_establish(ifs->if_detachhooks, 0,
		    bridge_ifdetach, ifs);
		if_ih_insert(p->ifp, bridge_input, NULL);
		TAILQ_INSERT_TAIL(&sc->sc_iflist, p, next);
		break;
	case SIOCBRDGDEL:
		if ((error = suser(curproc, 0)) != 0)
			break;
		ifs = ifunit(req->ifbr_ifsname);
		if (ifs == NULL) {
			error = ENOENT;
			break;
		}
		p = (struct bridge_iflist *)ifs->if_bridgeport;
		if (p == NULL || p->bridge_sc != sc) {
			error = ESRCH;
			break;
		}
		error = bridge_delete(sc, p);
		break;
	case SIOCBRDGIFS:
		error = bridge_bifconf(sc, (struct ifbifconf *)data);
		break;
	case SIOCBRDGADDS:
		if ((error = suser(curproc, 0)) != 0)
			break;
		ifs = ifunit(req->ifbr_ifsname);
		if (ifs == NULL) {			/* no such interface */
			error = ENOENT;
			break;
		}
		if (ifs->if_bridgeport != NULL) {
			error = EBUSY;
			break;
		}
		TAILQ_FOREACH(p, &sc->sc_spanlist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p != NULL) {
			error = EEXIST;
			break;
		}
		p = malloc(sizeof(*p), M_DEVBUF, M_NOWAIT|M_ZERO);
		if (p == NULL) {
			error = ENOMEM;
			break;
		}
		p->ifp = ifs;
		p->bif_flags = IFBIF_SPAN;
		p->bridge_sc = sc;
		p->bif_dhcookie = hook_establish(ifs->if_detachhooks, 0,
		    bridge_spandetach, p);
		SIMPLEQ_INIT(&p->bif_brlin);
		SIMPLEQ_INIT(&p->bif_brlout);
		TAILQ_INSERT_TAIL(&sc->sc_spanlist, p, next);
		break;
	case SIOCBRDGDELS:
		if ((error = suser(curproc, 0)) != 0)
			break;
		TAILQ_FOREACH(p, &sc->sc_spanlist, next) {
			if (strncmp(p->ifp->if_xname, req->ifbr_ifsname,
			    sizeof(p->ifp->if_xname)) == 0) {
				bridge_spandetach(p);
				break;
			}
		}
		if (p == NULL) {
			error = ENOENT;
			break;
		}
		break;
	case SIOCBRDGGIFFLGS:
		ifs = ifunit(req->ifbr_ifsname);
		if (ifs == NULL) {
			error = ENOENT;
			break;
		}
		p = (struct bridge_iflist *)ifs->if_bridgeport;
		if (p == NULL || p->bridge_sc != sc) {
			error = ESRCH;
			break;
		}
		req->ifbr_ifsflags = p->bif_flags;
		req->ifbr_portno = p->ifp->if_index & 0xfff;
		if (p->bif_flags & IFBIF_STP) {
			bp = p->bif_stp;
			req->ifbr_state = bstp_getstate(bs, bp);
			req->ifbr_priority = bp->bp_priority;
			req->ifbr_path_cost = bp->bp_path_cost;
			req->ifbr_proto = bp->bp_protover;
			req->ifbr_role = bp->bp_role;
			req->ifbr_stpflags = bp->bp_flags;
			req->ifbr_fwd_trans = bp->bp_forward_transitions;
			req->ifbr_desg_bridge = bp->bp_desg_pv.pv_dbridge_id;
			req->ifbr_desg_port = bp->bp_desg_pv.pv_dport_id;
			req->ifbr_root_bridge = bp->bp_desg_pv.pv_root_id;
			req->ifbr_root_cost = bp->bp_desg_pv.pv_cost;
			req->ifbr_root_port = bp->bp_desg_pv.pv_port_id;

			/* Copy STP state options as flags */
			if (bp->bp_operedge)
				req->ifbr_ifsflags |= IFBIF_BSTP_EDGE;
			if (bp->bp_flags & BSTP_PORT_AUTOEDGE)
				req->ifbr_ifsflags |= IFBIF_BSTP_AUTOEDGE;
			if (bp->bp_ptp_link)
				req->ifbr_ifsflags |= IFBIF_BSTP_PTP;
			if (bp->bp_flags & BSTP_PORT_AUTOPTP)
				req->ifbr_ifsflags |= IFBIF_BSTP_AUTOPTP;
		}
		break;
	case SIOCBRDGSIFFLGS:
		if ((error = suser(curproc, 0)) != 0)
			break;
		ifs = ifunit(req->ifbr_ifsname);
		if (ifs == NULL) {
			error = ENOENT;
			break;
		}
		p = (struct bridge_iflist *)ifs->if_bridgeport;
		if (p == NULL || p->bridge_sc != sc) {
			error = ESRCH;
			break;
		}
		if (req->ifbr_ifsflags & IFBIF_RO_MASK) {
			error = EINVAL;
			break;
		}
		if (req->ifbr_ifsflags & IFBIF_STP) {
			if ((p->bif_flags & IFBIF_STP) == 0) {
				/* Enable STP */
				if ((p->bif_stp = bstp_add(sc->sc_stp,
				    p->ifp)) == NULL) {
					error = ENOMEM;
					break;
				}
			} else {
				/* Update STP flags */
				bstp_ifsflags(p->bif_stp, req->ifbr_ifsflags);
			}
		} else if (p->bif_flags & IFBIF_STP) {
			bstp_delete(p->bif_stp);
			p->bif_stp = NULL;
		}
		p->bif_flags = req->ifbr_ifsflags;
		break;
	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == IFF_UP)
			bridge_init(sc);

		if ((ifp->if_flags & IFF_UP) == 0)
			bridge_stop(sc);

		break;
	case SIOCBRDGGPARAM:
		if ((bp = bs->bs_root_port) == NULL)
			brop->ifbop_root_port = 0;
		else
			brop->ifbop_root_port = bp->bp_ifp->if_index;
		brop->ifbop_maxage = bs->bs_bridge_max_age >> 8;
		brop->ifbop_hellotime = bs->bs_bridge_htime >> 8;
		brop->ifbop_fwddelay = bs->bs_bridge_fdelay >> 8;
		brop->ifbop_holdcount = bs->bs_txholdcount;
		brop->ifbop_priority = bs->bs_bridge_priority;
		brop->ifbop_protocol = bs->bs_protover;
		brop->ifbop_root_bridge = bs->bs_root_pv.pv_root_id;
		brop->ifbop_root_path_cost = bs->bs_root_pv.pv_cost;
		brop->ifbop_root_port = bs->bs_root_pv.pv_port_id;
		brop->ifbop_desg_bridge = bs->bs_root_pv.pv_dbridge_id;
		brop->ifbop_last_tc_time.tv_sec = bs->bs_last_tc_time.tv_sec;
		brop->ifbop_last_tc_time.tv_usec = bs->bs_last_tc_time.tv_usec;
		break;
	case SIOCBRDGRTS:
	case SIOCBRDGGCACHE:
	case SIOCBRDGGPRI:
	case SIOCBRDGGMA:
	case SIOCBRDGGHT:
	case SIOCBRDGGFD:
	case SIOCBRDGGTO:
	case SIOCBRDGGRL:
		break;
	case SIOCBRDGFLUSH:
	case SIOCBRDGSADDR:
	case SIOCBRDGDADDR:
	case SIOCBRDGSCACHE:
	case SIOCBRDGSTO:
	case SIOCBRDGARL:
	case SIOCBRDGFRL:
	case SIOCBRDGSPRI:
	case SIOCBRDGSFD:
	case SIOCBRDGSMA:
	case SIOCBRDGSHT:
	case SIOCBRDGSTXHC:
	case SIOCBRDGSPROTO:
	case SIOCBRDGSIFPRIO:
	case SIOCBRDGSIFCOST:
		error = suser(curproc, 0);
		break;
	default:
		error = ENOTTY;
		break;
	}

	if (!error)
		error = bridgectl_ioctl(ifp, cmd, data);

	if (!error)
		error = bstp_ioctl(ifp, cmd, data);

	return (error);
}

/* Detach an interface from a bridge.  */
void
bridge_ifdetach(void *arg)
{
	struct ifnet *ifp = (struct ifnet *)arg;
	struct bridge_softc *sc;
	struct bridge_iflist *bif;

	bif = (struct bridge_iflist *)ifp->if_bridgeport;
	sc = bif->bridge_sc;

	bridge_delete(sc, bif);
}

void
bridge_spandetach(void *arg)
{
	struct bridge_iflist *p = (struct bridge_iflist *)arg;
	struct bridge_softc *sc = p->bridge_sc;

	hook_disestablish(p->ifp->if_detachhooks, p->bif_dhcookie);
	TAILQ_REMOVE(&sc->sc_spanlist, p, next);
	free(p, M_DEVBUF, sizeof(*p));
}

int
bridge_bifconf(struct bridge_softc *sc, struct ifbifconf *bifc)
{
	struct bridge_iflist *p;
	struct bstp_port *bp;
	struct bstp_state *bs = sc->sc_stp;
	u_int32_t total = 0, i = 0;
	int error = 0;
	struct ifbreq *breq = NULL;

	TAILQ_FOREACH(p, &sc->sc_iflist, next)
		total++;

	TAILQ_FOREACH(p, &sc->sc_spanlist, next)
		total++;

	if (bifc->ifbic_len == 0) {
		i = total;
		goto done;
	}

	if ((breq = (struct ifbreq *)
	    malloc(sizeof(*breq), M_DEVBUF, M_NOWAIT)) == NULL)
		goto done;

	TAILQ_FOREACH(p, &sc->sc_iflist, next) {
		bzero(breq, sizeof(*breq));
		if (bifc->ifbic_len < sizeof(*breq))
			break;
		strlcpy(breq->ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(breq->ifbr_ifsname, p->ifp->if_xname, IFNAMSIZ);
		breq->ifbr_ifsflags = p->bif_flags;
		breq->ifbr_portno = p->ifp->if_index & 0xfff;
		if (p->bif_flags & IFBIF_STP) {
			bp = p->bif_stp;
			breq->ifbr_state = bstp_getstate(sc->sc_stp, bp);
			breq->ifbr_priority = bp->bp_priority;
			breq->ifbr_path_cost = bp->bp_path_cost;
			breq->ifbr_proto = bp->bp_protover;
			breq->ifbr_role = bp->bp_role;
			breq->ifbr_stpflags = bp->bp_flags;
			breq->ifbr_fwd_trans = bp->bp_forward_transitions;
			breq->ifbr_root_bridge = bs->bs_root_pv.pv_root_id;
			breq->ifbr_root_cost = bs->bs_root_pv.pv_cost;
			breq->ifbr_root_port = bs->bs_root_pv.pv_port_id;
			breq->ifbr_desg_bridge = bs->bs_root_pv.pv_dbridge_id;
			breq->ifbr_desg_port = bs->bs_root_pv.pv_dport_id;

			/* Copy STP state options as flags */
			if (bp->bp_operedge)
				breq->ifbr_ifsflags |= IFBIF_BSTP_EDGE;
			if (bp->bp_flags & BSTP_PORT_AUTOEDGE)
				breq->ifbr_ifsflags |= IFBIF_BSTP_AUTOEDGE;
			if (bp->bp_ptp_link)
				breq->ifbr_ifsflags |= IFBIF_BSTP_PTP;
			if (bp->bp_flags & BSTP_PORT_AUTOPTP)
				breq->ifbr_ifsflags |= IFBIF_BSTP_AUTOPTP;
		}
		error = copyout((caddr_t)breq,
		    (caddr_t)(bifc->ifbic_req + i), sizeof(*breq));
		if (error)
			goto done;
		i++;
		bifc->ifbic_len -= sizeof(*breq);
	}
	TAILQ_FOREACH(p, &sc->sc_spanlist, next) {
		bzero(breq, sizeof(*breq));
		if (bifc->ifbic_len < sizeof(*breq))
			break;
		strlcpy(breq->ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(breq->ifbr_ifsname, p->ifp->if_xname, IFNAMSIZ);
		breq->ifbr_ifsflags = p->bif_flags | IFBIF_SPAN;
		breq->ifbr_portno = p->ifp->if_index & 0xfff;
		error = copyout((caddr_t)breq,
		    (caddr_t)(bifc->ifbic_req + i), sizeof(*breq));
		if (error)
			goto done;
		i++;
		bifc->ifbic_len -= sizeof(*breq);
	}

done:
	if (breq != NULL)
		free(breq, M_DEVBUF, sizeof *breq);
	bifc->ifbic_len = i * sizeof(*breq);
	return (error);
}

void
bridge_init(struct bridge_softc *sc)
{
	struct ifnet *ifp = &sc->sc_if;

	if ((ifp->if_flags & IFF_RUNNING) == IFF_RUNNING)
		return;

	ifp->if_flags |= IFF_RUNNING;
	bstp_initialization(sc->sc_stp);

	if (sc->sc_brttimeout != 0)
		timeout_add_sec(&sc->sc_brtimeout, sc->sc_brttimeout);
}

/*
 * Stop the bridge and deallocate the routing table.
 */
void
bridge_stop(struct bridge_softc *sc)
{
	struct ifnet *ifp = &sc->sc_if;

	/*
	 * If we're not running, there's nothing to do.
	 */
	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	timeout_del(&sc->sc_brtimeout);

	bridge_rtflush(sc, IFBF_FLUSHDYN);

	ifp->if_flags &= ~IFF_RUNNING;
}

/*
 * Send output from the bridge.  The mbuf has the ethernet header
 * already attached.  We must enqueue or free the mbuf before exiting.
 */
int
bridge_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *sa,
    struct rtentry *rt)
{
	struct ether_header *eh;
	struct ifnet *dst_if = NULL;
	struct bridge_rtnode *dst_p = NULL;
	struct ether_addr *dst;
	struct bridge_softc *sc;
	struct bridge_tunneltag *brtag;
	int error;

	/* ifp must be a member interface of the bridge. */
	if (ifp->if_bridgeport == NULL) {
		m_freem(m);
		return (EINVAL);
	}
	sc = ((struct bridge_iflist *)ifp->if_bridgeport)->bridge_sc;

	if (m->m_len < sizeof(*eh)) {
		m = m_pullup(m, sizeof(*eh));
		if (m == NULL)
			return (ENOBUFS);
	}
	eh = mtod(m, struct ether_header *);
	dst = (struct ether_addr *)&eh->ether_dhost[0];

	/*
	 * If bridge is down, but original output interface is up,
	 * go ahead and send out that interface.  Otherwise the packet
	 * is dropped below.
	 */
	if ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {
		dst_if = ifp;
		goto sendunicast;
	}

#if NBPFILTER > 0
	if (sc->sc_if.if_bpf)
		bpf_mtap(sc->sc_if.if_bpf, m, BPF_DIRECTION_OUT);
#endif
	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;

	/*
	 * If the packet is a broadcast or we don't know a better way to
	 * get there, send to all interfaces.
	 */
	if ((dst_p = bridge_rtlookup(sc, dst)) != NULL)
		dst_if = dst_p->brt_if;
	if (dst_if == NULL || ETHER_IS_MULTICAST(eh->ether_dhost)) {
		struct bridge_iflist *p;
		struct mbuf *mc;
		int used = 0;

		bridge_span(sc, m);

		TAILQ_FOREACH(p, &sc->sc_iflist, next) {
			dst_if = p->ifp;
			if ((dst_if->if_flags & IFF_RUNNING) == 0)
				continue;

			/*
			 * If this is not the original output interface,
			 * and the interface is participating in spanning
			 * tree, make sure the port is in a state that
			 * allows forwarding.
			 */
			if (dst_if != ifp &&
			    (p->bif_flags & IFBIF_STP) &&
			    (p->bif_state == BSTP_IFSTATE_DISCARDING))
				continue;
#if NMPW > 0
			/*
			 * Split horizon: avoid broadcasting messages from
			 * wire to another wire.
			 */
			if (ifp->if_type == IFT_MPLSTUNNEL &&
			    dst_if->if_type == IFT_MPLSTUNNEL)
				continue;
#endif /* NMPW */
			if ((p->bif_flags & IFBIF_DISCOVER) == 0 &&
			    (m->m_flags & (M_BCAST | M_MCAST)) == 0)
				continue;

			if (TAILQ_NEXT(p, next) == NULL) {
				used = 1;
				mc = m;
			} else {
				mc = m_dup_pkt(m, ETHER_ALIGN, M_NOWAIT);
				if (mc == NULL) {
					sc->sc_if.if_oerrors++;
					continue;
				}
			}

			error = bridge_ifenqueue(sc, dst_if, mc);
			if (error)
				continue;
		}
		if (!used)
			m_freem(m);
		return (0);
	}

sendunicast:
	if ((dst_p != NULL) &&
	    (dst_p->brt_tunnel.brtag_peer.sa.sa_family != AF_UNSPEC) &&
	    ((brtag = bridge_tunneltag(m)) != NULL))
		bridge_copytag(&dst_p->brt_tunnel, brtag);

	bridge_span(sc, m);
	if ((dst_if->if_flags & IFF_RUNNING) == 0) {
		m_freem(m);
		return (ENETDOWN);
	}
	bridge_ifenqueue(sc, dst_if, m);
	return (0);
}

/*
 * Loop through each bridge interface and process their input queues.
 */
void
bridgeintr(void)
{
	struct mbuf_list ml;
	struct mbuf *m;
	struct ifnet *ifp;

	niq_delist(&bridgeintrq, &ml);
	if (ml_empty(&ml))
		return;

	while ((m = ml_dequeue(&ml)) != NULL) {

		ifp = if_get(m->m_pkthdr.ph_ifidx);
		if (ifp == NULL) {
			m_freem(m);
			continue;
		}

		bridge_process(ifp, m);

		if_put(ifp);
	}
}

/*
 * Process a single frame.  Frame must be freed or queued before returning.
 */
void
bridgeintr_frame(struct bridge_softc *sc, struct ifnet *src_if, struct mbuf *m)
{
	struct ifnet *dst_if;
	struct bridge_iflist *ifl;
	struct bridge_rtnode *dst_p;
	struct ether_addr *dst, *src;
	struct ether_header eh;
	int len;


	sc->sc_if.if_ipackets++;
	sc->sc_if.if_ibytes += m->m_pkthdr.len;

	ifl = (struct bridge_iflist *)src_if->if_bridgeport;
	KASSERT(ifl != NULL);

	if (m->m_pkthdr.len < sizeof(eh)) {
		m_freem(m);
		return;
	}
	m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&eh);
	dst = (struct ether_addr *)&eh.ether_dhost[0];
	src = (struct ether_addr *)&eh.ether_shost[0];

	/*
	 * If interface is learning, and if source address
	 * is not broadcast or multicast, record its address.
	 */
	if ((ifl->bif_flags & IFBIF_LEARNING) &&
	    (eh.ether_shost[0] & 1) == 0 &&
	    !(eh.ether_shost[0] == 0 && eh.ether_shost[1] == 0 &&
	    eh.ether_shost[2] == 0 && eh.ether_shost[3] == 0 &&
	    eh.ether_shost[4] == 0 && eh.ether_shost[5] == 0))
		bridge_rtupdate(sc, src, src_if, 0, IFBAF_DYNAMIC, m);

	if ((ifl->bif_flags & IFBIF_STP) &&
	    (ifl->bif_state == BSTP_IFSTATE_LEARNING)) {
		m_freem(m);
		return;
	}

	/*
	 * At this point, the port either doesn't participate in stp or
	 * it's in the forwarding state
	 */

	/*
	 * If packet is unicast, destined for someone on "this"
	 * side of the bridge, drop it.
	 */
	if (!ETHER_IS_MULTICAST(eh.ether_dhost)) {
		if ((dst_p = bridge_rtlookup(sc, dst)) != NULL)
			dst_if = dst_p->brt_if;
		else
			dst_if = NULL;
		if (dst_if == src_if) {
			m_freem(m);
			return;
		}
	} else {
		if (memcmp(etherbroadcastaddr, eh.ether_dhost,
		    sizeof(etherbroadcastaddr)) == 0)
			m->m_flags |= M_BCAST;
		else
			m->m_flags |= M_MCAST;
		dst_if = NULL;
	}

	/*
	 * Multicast packets get handled a little differently:
	 * If interface is:
	 *	-link0,-link1	(default) Forward all multicast
	 *			as broadcast.
	 *	-link0,link1	Drop non-IP multicast, forward
	 *			as broadcast IP multicast.
	 *	link0,-link1	Drop IP multicast, forward as
	 *			broadcast non-IP multicast.
	 *	link0,link1	Drop all multicast.
	 */
	if (m->m_flags & M_MCAST) {
		if ((sc->sc_if.if_flags &
		    (IFF_LINK0 | IFF_LINK1)) ==
		    (IFF_LINK0 | IFF_LINK1)) {
			m_freem(m);
			return;
		}
		if (sc->sc_if.if_flags & IFF_LINK0 &&
		    ETHERADDR_IS_IP_MCAST(dst)) {
			m_freem(m);
			return;
		}
		if (sc->sc_if.if_flags & IFF_LINK1 &&
		    !ETHERADDR_IS_IP_MCAST(dst)) {
			m_freem(m);
			return;
		}
	}

	if (ifl->bif_flags & IFBIF_BLOCKNONIP && bridge_blocknonip(&eh, m)) {
		m_freem(m);
		return;
	}

	if (bridge_filterrule(&ifl->bif_brlin, &eh, m) == BRL_ACTION_BLOCK) {
		m_freem(m);
		return;
	}
	m = bridge_ip(sc, BRIDGE_IN, src_if, &eh, m);
	if (m == NULL)
		return;
	/*
	 * If the packet is a multicast or broadcast OR if we don't
	 * know any better, forward it to all interfaces.
	 */
	if ((m->m_flags & (M_BCAST | M_MCAST)) || dst_if == NULL) {
		sc->sc_if.if_imcasts++;
		bridge_broadcast(sc, src_if, &eh, m);
		return;
	}

	/*
	 * At this point, we're dealing with a unicast frame going to a
	 * different interface
	 */
	if ((dst_if->if_flags & IFF_RUNNING) == 0) {
		m_freem(m);
		return;
	}
	ifl = (struct bridge_iflist *)dst_if->if_bridgeport;
	if ((ifl->bif_flags & IFBIF_STP) &&
	    (ifl->bif_state == BSTP_IFSTATE_DISCARDING)) {
		m_freem(m);
		return;
	}
	if (bridge_filterrule(&ifl->bif_brlout, &eh, m) == BRL_ACTION_BLOCK) {
		m_freem(m);
		return;
	}
	m = bridge_ip(sc, BRIDGE_OUT, dst_if, &eh, m);
	if (m == NULL)
		return;

	len = m->m_pkthdr.len;
#if NVLAN > 0
	if ((m->m_flags & M_VLANTAG) &&
	    (dst_if->if_capabilities & IFCAP_VLAN_HWTAGGING) == 0)
		len += ETHER_VLAN_ENCAP_LEN;
#endif
	if ((len - ETHER_HDR_LEN) > dst_if->if_mtu)
		bridge_fragment(sc, dst_if, &eh, m);
	else {
		bridge_ifenqueue(sc, dst_if, m);
	}
}

/*
 * Receive input from an interface.  Queue the packet for bridging if its
 * not for us, and schedule an interrupt.
 */
int
bridge_input(struct ifnet *ifp, struct mbuf *m, void *cookie)
{
	KASSERT(m->m_flags & M_PKTHDR);

	if (m->m_flags & M_PROTO1) {
		m->m_flags &= ~M_PROTO1;
		return (0);
	}

	niq_enqueue(&bridgeintrq, m);

	return (1);
}

void
bridge_process(struct ifnet *ifp, struct mbuf *m)
{
	struct bridge_softc *sc;
	struct bridge_iflist *ifl;
	struct bridge_iflist *srcifl;
	struct ether_header *eh;
	struct arpcom *ac;
	struct mbuf *mc;

	ifl = (struct bridge_iflist *)ifp->if_bridgeport;
	if (ifl == NULL)
		goto reenqueue;

	sc = ifl->bridge_sc;
	if ((sc->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		goto reenqueue;

#if NVLAN > 0
	/*
	 * If the underlying interface removed the VLAN header itself,
	 * add it back.
	 */
	if (ISSET(m->m_flags, M_VLANTAG)) {
		m = vlan_inject(m, ETHERTYPE_VLAN, m->m_pkthdr.ether_vtag);
		if (m == NULL)
			return;
	}
#endif

#if NBPFILTER > 0
	if (sc->sc_if.if_bpf)
		bpf_mtap_ether(sc->sc_if.if_bpf, m, BPF_DIRECTION_IN);
#endif

	bridge_span(sc, m);

	eh = mtod(m, struct ether_header *);
	if (ETHER_IS_MULTICAST(eh->ether_dhost)) {
		/*
		 * Reserved destination MAC addresses (01:80:C2:00:00:0x)
		 * should not be forwarded to bridge members according to
		 * section 7.12.6 of the 802.1D-2004 specification.  The
		 * STP destination address (as stored in bstp_etheraddr)
		 * is the first of these.
		 */
		if (bcmp(eh->ether_dhost, bstp_etheraddr, ETHER_ADDR_LEN - 1)
		    == 0) {
			if (eh->ether_dhost[ETHER_ADDR_LEN - 1] == 0) {
				/* STP traffic */
				if ((m = bstp_input(sc->sc_stp, ifl->bif_stp,
				    eh, m)) == NULL)
					return;
			} else if (eh->ether_dhost[ETHER_ADDR_LEN - 1] <= 0xf) {
				m_freem(m);
				return;
			}
		}

		/*
		 * No need to process frames for ifs in the discarding state
		 */
		if ((ifl->bif_flags & IFBIF_STP) &&
		    (ifl->bif_state == BSTP_IFSTATE_DISCARDING))
			goto reenqueue;

		mc = m_dup_pkt(m, ETHER_ALIGN, M_NOWAIT);
		if (mc == NULL)
			goto reenqueue;

		bridge_ifinput(ifp, mc);

		bridgeintr_frame(sc, ifp, m);
		return;
	}

	/*
	 * No need to queue frames for ifs in the discarding state
	 */
	if ((ifl->bif_flags & IFBIF_STP) &&
	    (ifl->bif_state == BSTP_IFSTATE_DISCARDING))
		goto reenqueue;

	/*
	 * Unicast, make sure it's not for us.
	 */
	srcifl = ifl;
	TAILQ_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp->if_type != IFT_ETHER)
			continue;
		ac = (struct arpcom *)ifl->ifp;
		if (bcmp(ac->ac_enaddr, eh->ether_dhost, ETHER_ADDR_LEN) == 0
#if NCARP > 0
		    || (ifl->ifp->if_carp && carp_ourether(ifl->ifp->if_carp,
			(u_int8_t *)&eh->ether_dhost) != NULL)
#endif
		    ) {
			if (srcifl->bif_flags & IFBIF_LEARNING)
				bridge_rtupdate(sc,
				    (struct ether_addr *)&eh->ether_shost,
				    ifp, 0, IFBAF_DYNAMIC, m);
			if (bridge_filterrule(&srcifl->bif_brlin, eh, m) ==
			    BRL_ACTION_BLOCK) {
				m_freem(m);
				return;
			}

			/* Count for the bridge */
			sc->sc_if.if_ipackets++;
			sc->sc_if.if_ibytes += m->m_pkthdr.len;

			bridge_ifinput(ifl->ifp, m);
			return;
		}
		if (bcmp(ac->ac_enaddr, eh->ether_shost, ETHER_ADDR_LEN) == 0
#if NCARP > 0
		    || (ifl->ifp->if_carp && carp_ourether(ifl->ifp->if_carp,
			(u_int8_t *)&eh->ether_shost) != NULL)
#endif
		    ) {
			m_freem(m);
			return;
		}
	}

	bridgeintr_frame(sc, ifp, m);
	return;

reenqueue:
	bridge_ifinput(ifp, m);
}

/*
 * Send a frame to all interfaces that are members of the bridge
 * (except the one it came in on).
 */
void
bridge_broadcast(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
{
	struct bridge_iflist *p;
	struct mbuf *mc;
	struct ifnet *dst_if;
	int len, used = 0;

	TAILQ_FOREACH(p, &sc->sc_iflist, next) {
		dst_if = p->ifp;

		if ((dst_if->if_flags & IFF_RUNNING) == 0)
			continue;

		if ((p->bif_flags & IFBIF_STP) &&
		    (p->bif_state == BSTP_IFSTATE_DISCARDING))
			continue;

		if ((p->bif_flags & IFBIF_DISCOVER) == 0 &&
		    (m->m_flags & (M_BCAST | M_MCAST)) == 0)
			continue;

		/* Drop non-IP frames if the appropriate flag is set. */
		if (p->bif_flags & IFBIF_BLOCKNONIP &&
		    bridge_blocknonip(eh, m))
			continue;

		if (bridge_filterrule(&p->bif_brlout, eh, m) == BRL_ACTION_BLOCK)
			continue;

		/*
		 * Don't retransmit out of the same interface where
		 * the packet was received from.
		 */
		if (dst_if->if_index == ifp->if_index)
			continue;

		bridge_localbroadcast(sc, dst_if, eh, m);

#if NMPW > 0
		/*
		 * Split horizon: avoid broadcasting messages from wire to
		 * another wire.
		 */
		if (ifp->if_type == IFT_MPLSTUNNEL &&
		    dst_if->if_type == IFT_MPLSTUNNEL)
			continue;
#endif /* NMPW */

		/* If last one, reuse the passed-in mbuf */
		if (TAILQ_NEXT(p, next) == NULL) {
			mc = m;
			used = 1;
		} else {
			mc = m_dup_pkt(m, ETHER_ALIGN, M_NOWAIT);
			if (mc == NULL) {
				sc->sc_if.if_oerrors++;
				continue;
			}
		}

		mc = bridge_ip(sc, BRIDGE_OUT, dst_if, eh, mc);
		if (mc == NULL)
			continue;

		len = mc->m_pkthdr.len;
#if NVLAN > 0
		if ((mc->m_flags & M_VLANTAG) &&
		    (dst_if->if_capabilities & IFCAP_VLAN_HWTAGGING) == 0)
			len += ETHER_VLAN_ENCAP_LEN;
#endif
		if ((len - ETHER_HDR_LEN) > dst_if->if_mtu)
			bridge_fragment(sc, dst_if, eh, mc);
		else {
			bridge_ifenqueue(sc, dst_if, mc);
		}
	}

	if (!used)
		m_freem(m);
}

void
bridge_localbroadcast(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
{
	struct mbuf *m1;
	u_int16_t etype;

	/*
	 * quick optimisation, don't send packets up the stack if no
	 * corresponding address has been specified.
	 */
	etype = ntohs(eh->ether_type);
	if (!(m->m_flags & M_VLANTAG) && etype == ETHERTYPE_IP) {
		struct ifaddr *ifa;
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family == AF_INET)
				break;
		}
		if (ifa == NULL)
			return;
	}

	m1 = m_dup_pkt(m, ETHER_ALIGN, M_NOWAIT);
	if (m1 == NULL) {
		sc->sc_if.if_oerrors++;
		return;
	}

#if NPF > 0
	pf_pkt_addr_changed(m1);
#endif	/* NPF */

	bridge_ifinput(ifp, m1);
}

void
bridge_span(struct bridge_softc *sc, struct mbuf *m)
{
	struct bridge_iflist *p;
	struct ifnet *ifp;
	struct mbuf *mc;
	int error;

	TAILQ_FOREACH(p, &sc->sc_spanlist, next) {
		ifp = p->ifp;

		if ((ifp->if_flags & IFF_RUNNING) == 0)
			continue;

		mc = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
		if (mc == NULL) {
			sc->sc_if.if_oerrors++;
			continue;
		}

		error = bridge_ifenqueue(sc, ifp, mc);
		if (error)
			continue;
	}
}

/*
 * Block non-ip frames:
 * Returns 0 if frame is ip, and 1 if it should be dropped.
 */
int
bridge_blocknonip(struct ether_header *eh, struct mbuf *m)
{
	struct llc llc;
	u_int16_t etype;

	if (m->m_pkthdr.len < ETHER_HDR_LEN)
		return (1);

#if NVLAN > 0
	if (m->m_flags & M_VLANTAG)
		return (1);
#endif

	etype = ntohs(eh->ether_type);
	switch (etype) {
	case ETHERTYPE_ARP:
	case ETHERTYPE_REVARP:
	case ETHERTYPE_IP:
	case ETHERTYPE_IPV6:
		return (0);
	}

	if (etype > ETHERMTU)
		return (1);

	if (m->m_pkthdr.len <
	    (ETHER_HDR_LEN + LLC_SNAPFRAMELEN))
		return (1);

	m_copydata(m, ETHER_HDR_LEN, LLC_SNAPFRAMELEN,
	    (caddr_t)&llc);

	etype = ntohs(llc.llc_snap.ether_type);
	if (llc.llc_dsap == LLC_SNAP_LSAP &&
	    llc.llc_ssap == LLC_SNAP_LSAP &&
	    llc.llc_control == LLC_UI &&
	    llc.llc_snap.org_code[0] == 0 &&
	    llc.llc_snap.org_code[1] == 0 &&
	    llc.llc_snap.org_code[2] == 0 &&
	    (etype == ETHERTYPE_ARP || etype == ETHERTYPE_REVARP ||
	    etype == ETHERTYPE_IP || etype == ETHERTYPE_IPV6)) {
		return (0);
	}

	return (1);
}

#ifdef IPSEC
int
bridge_ipsec(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, int hassnap, struct llc *llc,
    int dir, int af, int hlen, struct mbuf *m)
{
	union sockaddr_union dst;
	struct tdb *tdb;
	u_int32_t spi;
	u_int16_t cpi;
	int error, off;
	u_int8_t proto = 0;
	struct ip *ip;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif /* INET6 */
#if NPF > 0
	struct ifnet *encif;
#endif

	if (dir == BRIDGE_IN) {
		switch (af) {
		case AF_INET:
			if (m->m_pkthdr.len - hlen < 2 * sizeof(u_int32_t))
				break;

			ip = mtod(m, struct ip *);
			proto = ip->ip_p;
			off = offsetof(struct ip, ip_p);

			if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
			    proto != IPPROTO_IPCOMP)
				goto skiplookup;

			bzero(&dst, sizeof(union sockaddr_union));
			dst.sa.sa_family = AF_INET;
			dst.sin.sin_len = sizeof(struct sockaddr_in);
			m_copydata(m, offsetof(struct ip, ip_dst),
			    sizeof(struct in_addr),
			    (caddr_t)&dst.sin.sin_addr);

			break;
#ifdef INET6
		case AF_INET6:
			if (m->m_pkthdr.len - hlen < 2 * sizeof(u_int32_t))
				break;

			ip6 = mtod(m, struct ip6_hdr *);

			/* XXX We should chase down the header chain */
			proto = ip6->ip6_nxt;
			off = offsetof(struct ip6_hdr, ip6_nxt);

			if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
			    proto != IPPROTO_IPCOMP)
				goto skiplookup;

			bzero(&dst, sizeof(union sockaddr_union));
			dst.sa.sa_family = AF_INET6;
			dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
			m_copydata(m, offsetof(struct ip6_hdr, ip6_nxt),
			    sizeof(struct in6_addr),
			    (caddr_t)&dst.sin6.sin6_addr);

			break;
#endif /* INET6 */
		default:
			return (0);
		}

		switch (proto) {
		case IPPROTO_ESP:
			m_copydata(m, hlen, sizeof(u_int32_t), (caddr_t)&spi);
			break;
		case IPPROTO_AH:
			m_copydata(m, hlen + sizeof(u_int32_t),
			    sizeof(u_int32_t), (caddr_t)&spi);
			break;
		case IPPROTO_IPCOMP:
			m_copydata(m, hlen + sizeof(u_int16_t),
			    sizeof(u_int16_t), (caddr_t)&cpi);
			spi = ntohl(htons(cpi));
			break;
		}

		splsoftassert(IPL_SOFTNET);

		tdb = gettdb(ifp->if_rdomain, spi, &dst, proto);
		if (tdb != NULL && (tdb->tdb_flags & TDBF_INVALID) == 0 &&
		    tdb->tdb_xform != NULL) {
			if (tdb->tdb_first_use == 0) {
				tdb->tdb_first_use = time_second;
				if (tdb->tdb_flags & TDBF_FIRSTUSE)
					timeout_add_sec(&tdb->tdb_first_tmo,
					    tdb->tdb_exp_first_use);
				if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
					timeout_add_sec(&tdb->tdb_sfirst_tmo,
					    tdb->tdb_soft_first_use);
			}

			(*(tdb->tdb_xform->xf_input))(m, tdb, hlen, off);
			return (1);
		} else {
 skiplookup:
			/* XXX do an input policy lookup */
			return (0);
		}
	} else { /* Outgoing from the bridge. */
		tdb = ipsp_spd_lookup(m, af, hlen, &error,
		    IPSP_DIRECTION_OUT, NULL, NULL, 0);
		if (tdb != NULL) {
			/*
			 * We don't need to do loop detection, the
			 * bridge will do that for us.
			 */
#if NPF > 0
			if ((encif = enc_getif(tdb->tdb_rdomain,
			    tdb->tdb_tap)) == NULL ||
			    pf_test(af, dir, encif, &m) != PF_PASS) {
				m_freem(m);
				return (1);
			}
			if (m == NULL)
				return (1);
			else if (af == AF_INET)
				in_proto_cksum_out(m, encif);
#ifdef INET6
			else if (af == AF_INET6)
				in6_proto_cksum_out(m, encif);
#endif /* INET6 */
#endif /* NPF */

			ip = mtod(m, struct ip *);
			if ((af == AF_INET) &&
			    ip_mtudisc && (ip->ip_off & htons(IP_DF)) &&
			    tdb->tdb_mtu && ntohs(ip->ip_len) > tdb->tdb_mtu &&
			    tdb->tdb_mtutimeout > time_second)
				bridge_send_icmp_err(sc, ifp, eh, m,
				    hassnap, llc, tdb->tdb_mtu,
				    ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG);
			else
				error = ipsp_process_packet(m, tdb, af, 0);
			return (1);
		} else
			return (0);
	}

	return (0);
}
#endif /* IPSEC */

/*
 * Filter IP packets by peeking into the ethernet frame.  This violates
 * the ISO model, but allows us to act as a IP filter at the data link
 * layer.  As a result, most of this code will look familiar to those
 * who've read net/if_ethersubr.c and netinet/ip_input.c
 */
struct mbuf *
bridge_ip(struct bridge_softc *sc, int dir, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
{
	struct llc llc;
	int hassnap = 0;
	struct ip *ip;
	int hlen;
	u_int16_t etype;

#if NVLAN > 0
	if (m->m_flags & M_VLANTAG)
		return (m);
#endif

	etype = ntohs(eh->ether_type);

	if (etype != ETHERTYPE_IP && etype != ETHERTYPE_IPV6) {
		if (etype > ETHERMTU ||
		    m->m_pkthdr.len < (LLC_SNAPFRAMELEN +
		    ETHER_HDR_LEN))
			return (m);

		m_copydata(m, ETHER_HDR_LEN,
		    LLC_SNAPFRAMELEN, (caddr_t)&llc);

		if (llc.llc_dsap != LLC_SNAP_LSAP ||
		    llc.llc_ssap != LLC_SNAP_LSAP ||
		    llc.llc_control != LLC_UI ||
		    llc.llc_snap.org_code[0] ||
		    llc.llc_snap.org_code[1] ||
		    llc.llc_snap.org_code[2])
			return (m);

		etype = ntohs(llc.llc_snap.ether_type);
		if (etype != ETHERTYPE_IP && etype != ETHERTYPE_IPV6)
			return (m);
		hassnap = 1;
	}

	m_adj(m, ETHER_HDR_LEN);
	if (hassnap)
		m_adj(m, LLC_SNAPFRAMELEN);

	switch (etype) {

	case ETHERTYPE_IP:
		if (m->m_pkthdr.len < sizeof(struct ip))
			goto dropit;

		/* Copy minimal header, and drop invalids */
		if (m->m_len < sizeof(struct ip) &&
		    (m = m_pullup(m, sizeof(struct ip))) == NULL) {
			ipstat_inc(ips_toosmall);
			return (NULL);
		}
		ip = mtod(m, struct ip *);

		if (ip->ip_v != IPVERSION) {
			ipstat_inc(ips_badvers);
			goto dropit;
		}

		hlen = ip->ip_hl << 2;	/* get whole header length */
		if (hlen < sizeof(struct ip)) {
			ipstat_inc(ips_badhlen);
			goto dropit;
		}

		if (hlen > m->m_len) {
			if ((m = m_pullup(m, hlen)) == NULL) {
				ipstat_inc(ips_badhlen);
				return (NULL);
			}
			ip = mtod(m, struct ip *);
		}

		if ((m->m_pkthdr.csum_flags & M_IPV4_CSUM_IN_OK) == 0) {
			if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_IN_BAD) {
				ipstat_inc(ips_badsum);
				goto dropit;
			}

			ipstat_inc(ips_inswcsum);
			if (in_cksum(m, hlen) != 0) {
				ipstat_inc(ips_badsum);
				goto dropit;
			}
		}

		if (ntohs(ip->ip_len) < hlen)
			goto dropit;

		if (m->m_pkthdr.len < ntohs(ip->ip_len))
			goto dropit;
		if (m->m_pkthdr.len > ntohs(ip->ip_len)) {
			if (m->m_len == m->m_pkthdr.len) {
				m->m_len = ntohs(ip->ip_len);
				m->m_pkthdr.len = ntohs(ip->ip_len);
			} else
				m_adj(m, ntohs(ip->ip_len) - m->m_pkthdr.len);
		}

#ifdef IPSEC
		if ((sc->sc_if.if_flags & IFF_LINK2) == IFF_LINK2 &&
		    bridge_ipsec(sc, ifp, eh, hassnap, &llc,
		    dir, AF_INET, hlen, m))
			return (NULL);
#endif /* IPSEC */
#if NPF > 0
		/* Finally, we get to filter the packet! */
		if (pf_test(AF_INET, dir, ifp, &m) != PF_PASS)
			goto dropit;
		if (m == NULL)
			goto dropit;
#endif /* NPF > 0 */

		/* Rebuild the IP header */
		if (m->m_len < hlen && ((m = m_pullup(m, hlen)) == NULL))
			return (NULL);
		if (m->m_len < sizeof(struct ip))
			goto dropit;
		in_proto_cksum_out(m, ifp);
		ip = mtod(m, struct ip *);
		ip->ip_sum = 0;
		if (0 && (ifp->if_capabilities & IFCAP_CSUM_IPv4))
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_OUT;
		else {
			ipstat_inc(ips_outswcsum);
			ip->ip_sum = in_cksum(m, hlen);
		}

		break;

#ifdef INET6
	case ETHERTYPE_IPV6: {
		struct ip6_hdr *ip6;

		if (m->m_len < sizeof(struct ip6_hdr)) {
			if ((m = m_pullup(m, sizeof(struct ip6_hdr)))
			    == NULL) {
				ip6stat_inc(ip6s_toosmall);
				return (NULL);
			}
		}

		ip6 = mtod(m, struct ip6_hdr *);

		if ((ip6->ip6_vfc & IPV6_VERSION_MASK) != IPV6_VERSION) {
			ip6stat_inc(ip6s_badvers);
			goto dropit;
		}

#ifdef IPSEC
		hlen = sizeof(struct ip6_hdr);

		if ((sc->sc_if.if_flags & IFF_LINK2) == IFF_LINK2 &&
		    bridge_ipsec(sc, ifp, eh, hassnap, &llc,
		    dir, AF_INET6, hlen, m))
			return (NULL);
#endif /* IPSEC */

#if NPF > 0
		if (pf_test(AF_INET6, dir, ifp, &m) != PF_PASS)
			goto dropit;
		if (m == NULL)
			return (NULL);
#endif /* NPF > 0 */
		in6_proto_cksum_out(m, ifp);

		break;
	}
#endif /* INET6 */

	default:
		goto dropit;
		break;
	}

	/* Reattach SNAP header */
	if (hassnap) {
		M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
		if (m == NULL)
			goto dropit;
		bcopy(&llc, mtod(m, caddr_t), LLC_SNAPFRAMELEN);
	}

	/* Reattach ethernet header */
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
		goto dropit;
	bcopy(eh, mtod(m, caddr_t), sizeof(*eh));

	return (m);

dropit:
	m_freem(m);
	return (NULL);
}

void
bridge_fragment(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
{
	struct llc llc;
	struct mbuf *m0;
	int error = 0;
	int hassnap = 0;
	u_int16_t etype;
	struct ip *ip;

	etype = ntohs(eh->ether_type);
#if NVLAN > 0
	if ((m->m_flags & M_VLANTAG) || etype == ETHERTYPE_VLAN ||
	    etype == ETHERTYPE_QINQ) {
		int len = m->m_pkthdr.len;

		if (m->m_flags & M_VLANTAG)
			len += ETHER_VLAN_ENCAP_LEN;
		if ((ifp->if_capabilities & IFCAP_VLAN_MTU) &&
		    (len - sizeof(struct ether_vlan_header) <= ifp->if_mtu)) {
			bridge_ifenqueue(sc, ifp, m);
			return;
		}
		goto dropit;
	}
#endif
	if (etype != ETHERTYPE_IP) {
		if (etype > ETHERMTU ||
		    m->m_pkthdr.len < (LLC_SNAPFRAMELEN +
		    ETHER_HDR_LEN))
			goto dropit;

		m_copydata(m, ETHER_HDR_LEN,
		    LLC_SNAPFRAMELEN, (caddr_t)&llc);

		if (llc.llc_dsap != LLC_SNAP_LSAP ||
		    llc.llc_ssap != LLC_SNAP_LSAP ||
		    llc.llc_control != LLC_UI ||
		    llc.llc_snap.org_code[0] ||
		    llc.llc_snap.org_code[1] ||
		    llc.llc_snap.org_code[2] ||
		    llc.llc_snap.ether_type != htons(ETHERTYPE_IP))
			goto dropit;

		hassnap = 1;
	}

	m_adj(m, ETHER_HDR_LEN);
	if (hassnap)
		m_adj(m, LLC_SNAPFRAMELEN);

	if (m->m_len < sizeof(struct ip) &&
	    (m = m_pullup(m, sizeof(struct ip))) == NULL)
		goto dropit;
	ip = mtod(m, struct ip *);

	/* Respect IP_DF, return a ICMP_UNREACH_NEEDFRAG. */
	if (ip->ip_off & htons(IP_DF)) {
		bridge_send_icmp_err(sc, ifp, eh, m, hassnap, &llc,
		    ifp->if_mtu, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG);
		return;
	}

	error = ip_fragment(m, ifp, ifp->if_mtu);
	if (error) {
		m = NULL;
		goto dropit;
	}

	for (; m; m = m0) {
		m0 = m->m_nextpkt;
		m->m_nextpkt = NULL;
		if (error == 0) {
			if (hassnap) {
				M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
				if (m == NULL) {
					error = ENOBUFS;
					continue;
				}
				bcopy(&llc, mtod(m, caddr_t),
				    LLC_SNAPFRAMELEN);
			}
			M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
			if (m == NULL) {
				error = ENOBUFS;
				continue;
			}
			bcopy(eh, mtod(m, caddr_t), sizeof(*eh));
			error = bridge_ifenqueue(sc, ifp, m);
			if (error) {
				continue;
			}
		} else
			m_freem(m);
	}

	if (error == 0)
		ipstat_inc(ips_fragmented);

	return;
 dropit:
	m_freem(m);
}

int
bridge_ifenqueue(struct bridge_softc *sc, struct ifnet *ifp, struct mbuf *m)
{
	int error, len;

	/* Loop prevention. */
	m->m_flags |= M_PROTO1;

	len = m->m_pkthdr.len;

	error = if_enqueue(ifp, m);
	if (error) {
		sc->sc_if.if_oerrors++;
		return (error);
	}

	sc->sc_if.if_opackets++;
	sc->sc_if.if_obytes += len;

	return (0);
}

void
bridge_ifinput(struct ifnet *ifp, struct mbuf *m)
{
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();

	m->m_flags |= M_PROTO1;

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

void
bridge_send_icmp_err(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *n, int hassnap, struct llc *llc,
    int mtu, int type, int code)
{
	struct ip *ip;
	struct icmp *icp;
	struct in_addr t;
	struct mbuf *m, *n2;
	int hlen;
	u_int8_t ether_tmp[ETHER_ADDR_LEN];

	n2 = m_copym(n, 0, M_COPYALL, M_DONTWAIT);
	if (!n2) {
		m_freem(n);
		return;
	}
	m = icmp_do_error(n, type, code, 0, mtu);
	if (m == NULL) {
		m_freem(n2);
		return;
	}

	n = n2;

	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
	t = ip->ip_dst;
	ip->ip_dst = ip->ip_src;
	ip->ip_src = t;

	m->m_data += hlen;
	m->m_len -= hlen;
	icp = mtod(m, struct icmp *);
	icp->icmp_cksum = 0;
	icp->icmp_cksum = in_cksum(m, ntohs(ip->ip_len) - hlen);
	m->m_data -= hlen;
	m->m_len += hlen;

	ip->ip_v = IPVERSION;
	ip->ip_off &= htons(IP_DF);
	ip->ip_id = htons(ip_randomid());
	ip->ip_ttl = MAXTTL;
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, hlen);

	/* Swap ethernet addresses */
	bcopy(&eh->ether_dhost, &ether_tmp, sizeof(ether_tmp));
	bcopy(&eh->ether_shost, &eh->ether_dhost, sizeof(ether_tmp));
	bcopy(&ether_tmp, &eh->ether_shost, sizeof(ether_tmp));

	/* Reattach SNAP header */
	if (hassnap) {
		M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
		if (m == NULL)
			goto dropit;
		bcopy(llc, mtod(m, caddr_t), LLC_SNAPFRAMELEN);
	}

	/* Reattach ethernet header */
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
		goto dropit;
	bcopy(eh, mtod(m, caddr_t), sizeof(*eh));

	bridge_output(ifp, m, NULL, NULL);
	m_freem(n);
	return;

 dropit:
	m_freem(n);
}

struct bridge_tunneltag *
bridge_tunnel(struct mbuf *m)
{
	struct m_tag    *mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_TUNNEL, NULL)) == NULL)
		return (NULL);

	return ((struct bridge_tunneltag *)(mtag + 1));
}

struct bridge_tunneltag *
bridge_tunneltag(struct mbuf *m)
{
	struct m_tag	*mtag;

	if ((mtag = m_tag_find(m, PACKET_TAG_TUNNEL, NULL)) == NULL) {
		mtag = m_tag_get(PACKET_TAG_TUNNEL,
		    sizeof(struct bridge_tunneltag), M_NOWAIT);
		if (mtag == NULL)
			return (NULL);
		bzero(mtag + 1, sizeof(struct bridge_tunneltag));
		m_tag_prepend(m, mtag);
	}

	return ((struct bridge_tunneltag *)(mtag + 1));
}

void
bridge_tunneluntag(struct mbuf *m)
{
	struct m_tag    *mtag;
	if ((mtag = m_tag_find(m, PACKET_TAG_TUNNEL, NULL)) != NULL)
		m_tag_delete(m, mtag);
}

void
bridge_copyaddr(struct sockaddr *src, struct sockaddr *dst)
{
	if (src != NULL && src->sa_family != AF_UNSPEC)
		memcpy(dst, src, src->sa_len);
	else {
		dst->sa_family = AF_UNSPEC;
		dst->sa_len = 0;
	}
}

void
bridge_copytag(struct bridge_tunneltag *src, struct bridge_tunneltag *dst)
{
	if (src == NULL) {
		memset(dst, 0, sizeof(*dst));
	} else {
		bridge_copyaddr(&src->brtag_peer.sa, &dst->brtag_peer.sa);
		bridge_copyaddr(&src->brtag_local.sa, &dst->brtag_local.sa);
		dst->brtag_id = src->brtag_id;
	}
}
@


1.295
log
@Unify duplicate code from address family switch in bridge_ipsec().
Remove an if condition that cannot happen.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.294 2017/02/05 16:04:14 jca Exp $	*/
d269 1
a269 1
	int error = 0, s;
a270 1
	s = splnet();
a570 1
	splx(s);
@


1.294
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.293 2017/01/24 10:08:30 krw Exp $	*/
a1427 11
			if (ip->ip_p == IPPROTO_ESP)
				m_copydata(m, hlen, sizeof(u_int32_t),
				    (caddr_t)&spi);
			else if (ip->ip_p == IPPROTO_AH)
				m_copydata(m, hlen + sizeof(u_int32_t),
				    sizeof(u_int32_t), (caddr_t)&spi);
			else if (ip->ip_p == IPPROTO_IPCOMP) {
				m_copydata(m, hlen + sizeof(u_int16_t),
				    sizeof(u_int16_t), (caddr_t)&cpi);
				spi = ntohl(htons(cpi));
			}
a1450 11
			if (proto == IPPROTO_ESP)
				m_copydata(m, hlen, sizeof(u_int32_t),
				    (caddr_t)&spi);
			else if (proto == IPPROTO_AH)
				m_copydata(m, hlen + sizeof(u_int32_t),
				    sizeof(u_int32_t), (caddr_t)&spi);
			else if (proto == IPPROTO_IPCOMP) {
				m_copydata(m, hlen + sizeof(u_int16_t),
				    sizeof(u_int16_t), (caddr_t)&cpi);
				spi = ntohl(htons(cpi));
			}
d1457 14
a1470 2
		if (proto == 0)
			goto skiplookup;
@


1.293
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.292 2017/01/23 11:37:29 mpi Exp $	*/
d1695 1
a1695 1
				ip6stat.ip6s_toosmall++;
d1703 1
a1703 1
			ip6stat.ip6s_badvers++;
@


1.292
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.291 2017/01/11 08:47:48 mpi Exp $	*/
d741 1
a741 1
	/* ifp must be a member interface of the bridge. */ 
d1095 1
a1095 1
	 	 * Reserved destination MAC addresses (01:80:C2:00:00:0x)
d1100 1
a1100 1
	 	 */
d1119 1
a1119 1
	    		goto reenqueue;
d1123 1
a1123 1
	    		goto reenqueue;
d1136 1
a1136 1
	    	goto reenqueue;
d1979 1
a1979 1
	struct m_tag    	*mtag;
@


1.291
log
@No need for a splsoftnet()/splx() dance when the KERNEL_LOCK() is what
serialize access to bridge(4) data structures.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.290 2016/12/19 15:49:28 mpi Exp $	*/
d184 1
@


1.290
log
@Assert that IPL_SOFTNET is needed rather than calling splsoftnet()
recursively.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.289 2016/11/21 08:27:59 reyk Exp $	*/
d171 1
a171 1
	timeout_set(&sc->sc_brtimeout, bridge_timer, sc);
@


1.289
log
@bridge(4) does not distinguish between routing/forwarding ports, so
make "addlocal" an alias to "add" on bridge.  addlocal is handled
differently on switch(4).

OK yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.288 2016/11/14 03:51:53 dlg Exp $	*/
d1396 1
a1396 1
	int error, off, s;
d1481 1
a1481 1
		s = splsoftnet();
a1496 1
			splx(s);
a1498 1
			splx(s);
@


1.288
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the ipstat struct.

ipstat_inc(ips_foo) replaces ipstat.ips_foo++ for the actual updates.
ipstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the ipstat struct for now.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.287 2016/10/03 15:53:09 rzalamena Exp $	*/
d273 2
@


1.287
log
@Use detach hook to notify bridge(4) about span port removals.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.286 2016/10/03 12:26:13 rzalamena Exp $	*/
d1606 1
a1606 1
			ipstat.ips_toosmall++;
d1612 1
a1612 1
			ipstat.ips_badvers++;
d1618 1
a1618 1
			ipstat.ips_badhlen++;
d1624 1
a1624 1
				ipstat.ips_badhlen++;
d1632 1
a1632 1
				ipstat.ips_badsum++;
d1636 1
a1636 1
			ipstat.ips_inswcsum++;
d1638 1
a1638 1
				ipstat.ips_badsum++;
d1681 1
a1681 1
			ipstat.ips_outswcsum++;
d1851 1
a1851 1
		ipstat.ips_fragmented++;
@


1.286
log
@Use detach hook to notify bridge of interface removal instead of adding
code to if.c.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.285 2016/09/29 11:37:44 reyk Exp $	*/
d110 1
d219 2
a220 4
	while ((bif = TAILQ_FIRST(&sc->sc_spanlist)) != NULL) {
		TAILQ_REMOVE(&sc->sc_spanlist, bif, next);
		free(bif, M_DEVBUF, sizeof *bif);
	}
d410 3
d423 1
a423 2
				TAILQ_REMOVE(&sc->sc_spanlist, p, next);
				free(p, M_DEVBUF, sizeof *p);
d585 11
@


1.285
log
@Rename brtag_src/brtag_dst to brtag_peer/brtag_local to avoid
confusion about the tunnel endpoints when responding to the peer.

OK yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.284 2016/09/03 13:46:57 reyk Exp $	*/
d109 1
d248 1
d361 2
d574 1
a574 1
bridge_ifdetach(struct ifnet *ifp)
d576 1
@


1.284
log
@Add support for a multipoint-to-multipoint mode in vxlan(4).  In this
mode, vxlan(4) must be configured to accept any virtual network
identifier with "vnetid any" and added to a bridge(4) or switch(4).
This way the driver will dynamically learn the tunnel endpoints and
their vnetids for the responses and can be used to dynamically bridge
between VXLANs.  It is also being used in combination with switch(4)
and the OpenFlow tunnel classifiers.

With input from yasuoka@@ goda@@
OK deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.283 2016/09/02 10:01:36 goda Exp $	*/
d816 3
a818 8
	    (dst_p->brt_tunnel.brtag_dst.sa.sa_family != AF_UNSPEC) &&
	    ((brtag = bridge_tunneltag(m)) != NULL)) {
		memcpy(&brtag->brtag_src, &dst_p->brt_tunnel.brtag_src.sa,
		    dst_p->brt_tunnel.brtag_src.sa.sa_len);
		memcpy(&brtag->brtag_dst, &dst_p->brt_tunnel.brtag_dst.sa,
		    dst_p->brt_tunnel.brtag_dst.sa.sa_len);
		brtag->brtag_id = dst_p->brt_tunnel.brtag_id;
	}
d2000 2
a2001 2
		bridge_copyaddr(&src->brtag_src.sa, &dst->brtag_src.sa);
		bridge_copyaddr(&src->brtag_dst.sa, &dst->brtag_dst.sa);
@


1.283
log
@Add switch(4) support to ifconfig

ok deraadt@@ yasuoka@@ reyk@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.282 2016/09/01 10:06:33 goda Exp $	*/
d718 1
d815 9
a823 3
	if (dst_p != NULL && dst_p->brt_tunnel.sa.sa_family != AF_UNSPEC &&
	    (sa = bridge_tunneltag(m, dst_p->brt_tunnel.sa.sa_family)) != NULL)
		memcpy(sa, &dst_p->brt_tunnel.sa, dst_p->brt_tunnel.sa.sa_len);
d1952 1
a1952 1
struct sockaddr *
d1960 1
a1960 1
	return ((struct sockaddr *)(mtag + 1));
d1963 2
a1964 2
struct sockaddr *
bridge_tunneltag(struct mbuf *m, int af)
d1966 1
a1966 3
	struct m_tag    *mtag;
	size_t		 len;
	struct sockaddr	*sa;
d1968 3
a1970 15
	if ((mtag = m_tag_find(m, PACKET_TAG_TUNNEL, NULL)) != NULL) {
		sa = (struct sockaddr *)(mtag + 1);
		if (sa->sa_family != af) {
			m_tag_delete(m, mtag);
			mtag = NULL;
		}
	}
	if (mtag == NULL) {
		if (af == AF_INET)
			len = sizeof(struct sockaddr_in);
		else if (af == AF_INET6)
			len = sizeof(struct sockaddr_in6);
		else
			return (NULL);
		mtag = m_tag_get(PACKET_TAG_TUNNEL, len, M_NOWAIT);
d1973 1
a1973 4
		bzero(mtag + 1, len);
		sa = (struct sockaddr *)(mtag + 1);
		sa->sa_family = af;
		sa->sa_len = len;
d1977 1
a1977 1
	return ((struct sockaddr *)(mtag + 1));
d1993 1
a1993 1
	else
d1995 14
@


1.282
log
@Import switch(4), an in-kernel OpenFlow switch which can work alone.
switch(4) currently supports OpenFlow 1.3.5.
Currently, it's disabled by the kernel config.

With help from yasuoka@@ reyk@@ jsg@@.

ok deraadt@@ yasuoka@@ reyk@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.281 2016/08/31 08:03:20 mpi Exp $	*/
a119 1

a120 3
struct mbuf *bridge_ip(struct bridge_softc *, int, struct ifnet *,
    struct ether_header *, struct mbuf *m);
int	bridge_ifenqueue(struct bridge_softc *, struct ifnet *, struct mbuf *);
@


1.281
log
@Drop gif(4) support, etherip(4) is what you want now.

ok sthen@@, deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.280 2016/06/07 08:32:13 mpi Exp $	*/
a127 2
void	bridge_fragment(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
@


1.280
log
@Multicast packet are already duplicated in bridge_process() so
no need to loop another copy on the receiving interface.

Reported by and ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.279 2016/05/30 12:56:16 mpi Exp $	*/
a90 4
#if NGIF > 0
#include <net/if_gif.h>
#endif

a340 5
#if NGIF > 0
		else if (ifs->if_type == IFT_GIF) {
			/* Nothing needed */
		}
#endif /* NGIF */
a1108 13
#if NGIF > 0
		if (ifp->if_type == IFT_GIF) {
			TAILQ_FOREACH(ifl, &sc->sc_iflist, next) {
				if (ifl->ifp->if_type != IFT_ETHER)
					continue;

				bridge_ifinput(ifl->ifp, mc);
				break;
			}
			if (!ifl)
				m_freem(mc);
		} else
#endif /* NGIF */
a1852 13
#if NGIF > 0
	/* Packet needs etherip encapsulation. */
	if (ifp->if_type == IFT_GIF) {

		/* Count packets input into the gif from outside */
		ifp->if_ipackets++;
		ifp->if_ibytes += m->m_pkthdr.len;

		error = gif_encap(ifp, &m, AF_LINK);
		if (error)
			return (error);
	}
#endif /* NGIF */
@


1.279
log
@Insert a hack to deal with interfaces removing the VLAN header before
the packet has been feed to the pseudo-interfaces input handlers.

To fix that without introducing a layer violation we should be able to
disable HW-vlan on parent when in use with different pseudo-interfaces.

In the case of bridge(4) for example it makes no sense to let the interface
remove the VLAN header if the kernel has to add it back for every packet.

Fix issues reported by sebastia@@ and markus@@

From dlg@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.278 2016/04/12 06:20:30 mpi Exp $	*/
d1132 1
a1132 1
		
a1227 2
		bridge_localbroadcast(sc, dst_if, eh, m);

d1234 3
@


1.278
log
@Set bridge(4)'s if_output to a dummy function returning EAFNOSUPPORT as
it should not be used to output packets but we have to respect the ifp
driver API to some extend.

Prevent a panic found the hardway by espie@@.

ok claudio@@, mikeb@@, jsg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.277 2016/03/30 12:16:30 dlg Exp $	*/
d1065 12
@


1.277
log
@replace bridge_m_dup with m_dup_pkt.

less code for the same effect, which is ETHER_ALIGNed packets.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.276 2016/03/08 09:09:43 sashan Exp $	*/
d130 2
d191 1
a191 1
	ifp->if_output = NULL;
d207 8
@


1.276
log
@- bridge_localbroadcast() must call pf_pkt_addr_changed()
  (makes KASSERT() in pf_test() to go away)

Thanks to Mark and Mattieu for quick testing

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.275 2015/12/05 10:07:55 tedu Exp $	*/
a139 1
struct	mbuf *bridge_m_dup(struct mbuf *);
d802 1
a802 1
				mc = bridge_m_dup(m);
d1092 1
a1092 1
		mc = bridge_m_dup(m);
d1229 1
a1229 1
			mc = bridge_m_dup(m);
d1279 1
a1279 1
	m1 = bridge_m_dup(m);
a2022 33
}

/*
 * Specialized deep copy to ensure that the payload after the Ethernet
 * header is nicely aligned.
 */
struct mbuf *
bridge_m_dup(struct mbuf *m)
{
	struct mbuf *m1, *m2, *mx;

	m1 = m_copym2(m, 0, ETHER_HDR_LEN, M_DONTWAIT);
	if (m1 == NULL) {
		return (NULL);
	}
	m2 = m_copym2(m, ETHER_HDR_LEN, M_COPYALL, M_DONTWAIT);
	if (m2 == NULL) {
		m_freem(m1);
		return (NULL);
	}

	for (mx = m1; mx->m_next != NULL; mx = mx->m_next)
		/*EMPTY*/;
	mx->m_next = m2;

	if (m1->m_flags & M_PKTHDR) {
		int len = 0;
		for (mx = m1; mx != NULL; mx = mx->m_next)
			len += mx->m_len;
		m1->m_pkthdr.len = len;
	}

	return (m1);
@


1.275
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.274 2015/12/04 10:32:42 mpi Exp $	*/
d1285 4
@


1.274
log
@bridge(4) never outputs packets so set its if_output and if_start to NULL.

bridge_output() is used by the stack to duplicate a packet coming from a
bridge member to its other ports.

Confusion pointed by Momtchil Momtchev on misc@@

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.273 2015/12/02 08:04:12 mpi Exp $	*/
a152 1
/* ARGSUSED */
@


1.273
log
@Include cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.272 2015/12/01 18:28:29 goda Exp $	*/
a113 1
void	bridge_start(struct ifnet *);
d191 2
a192 2
	ifp->if_output = bridge_output;
	ifp->if_start = bridge_start;
a831 8
}

/*
 * Start output on the bridge.  This function should never be called.
 */
void
bridge_start(struct ifnet *ifp)
{
@


1.272
log
@Split functions in if_bridge.c into if_bridge.c bridgectl.c .

Splitting functions in if_bridge.c into if_bridge.c for the forwarding part
and bridgectl.c for the control part. It shouldn't have any functional change.

ok reyk@@ mpi@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.271 2015/12/01 14:49:04 goda Exp $	*/
a45 1
#include <sys/errno.h>
a46 2

#include <crypto/siphash.h>
@


1.271
log
@Fix bridge to forward broadcast/multicast frames from gif.

ok reyk@@ mpi@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.270 2015/11/07 12:42:19 mpi Exp $	*/
a44 1
#include <sys/timeout.h>
a128 10
void	bridge_timer(void *);
int	bridge_rtfind(struct bridge_softc *, struct ifbaconf *);
void	bridge_rtage(struct bridge_softc *);
int	bridge_rtdaddr(struct bridge_softc *, struct ether_addr *);
void	bridge_rtflush(struct bridge_softc *, int);
struct ifnet *bridge_rtupdate(struct bridge_softc *,
    struct ether_addr *, struct ifnet *ifp, int, u_int8_t, struct mbuf *);
struct bridge_rtnode *bridge_rtlookup(struct bridge_softc *,
    struct ether_addr *);
u_int32_t	bridge_hash(struct bridge_softc *, struct ether_addr *);
a129 6
int		bridge_addrule(struct bridge_iflist *,
    struct ifbrlreq *, int out);
void	bridge_flushrule(struct bridge_iflist *);
int	bridge_brlconf(struct bridge_softc *, struct ifbrlconf *);
u_int8_t bridge_filterrule(struct brl_head *, struct ether_header *,
    struct mbuf *);
a135 2
void	bridge_send_icmp_err(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *, int, struct llc *, int, int, int);
a143 1
void	bridge_copyaddr(struct sockaddr *, struct sockaddr *);
a267 3
	struct ifbareq *bareq = (struct ifbareq *)data;
	struct ifbrparam *bparam = (struct ifbrparam *)data;
	struct ifbrlreq *brlreq = (struct ifbrlreq *)data;
a511 58
	case SIOCBRDGRTS:
		error = bridge_rtfind(sc, (struct ifbaconf *)data);
		break;
	case SIOCBRDGFLUSH:
		if ((error = suser(curproc, 0)) != 0)
			break;

		bridge_rtflush(sc, req->ifbr_ifsflags);
		break;
	case SIOCBRDGSADDR:
		if ((error = suser(curproc, 0)) != 0)
			break;
		ifs = ifunit(bareq->ifba_ifsname);
		if (ifs == NULL) {			/* no such interface */
			error = ENOENT;
			break;
		}
		p = (struct bridge_iflist *)ifs->if_bridgeport;
		if (p == NULL || p->bridge_sc != sc) {
			error = ESRCH;
			break;
		}

		ifs = bridge_rtupdate(sc, &bareq->ifba_dst, ifs, 1,
		    bareq->ifba_flags, NULL);
		if (ifs == NULL)
			error = ENOMEM;
		break;
	case SIOCBRDGDADDR:
		if ((error = suser(curproc, 0)) != 0)
			break;
		error = bridge_rtdaddr(sc, &bareq->ifba_dst);
		break;
	case SIOCBRDGGCACHE:
		bparam->ifbrp_csize = sc->sc_brtmax;
		break;
	case SIOCBRDGSCACHE:
		if ((error = suser(curproc, 0)) != 0)
			break;
		sc->sc_brtmax = bparam->ifbrp_csize;
		break;
	case SIOCBRDGSTO:
		if ((error = suser(curproc, 0)) != 0)
			break;
		if (bparam->ifbrp_ctime < 0 ||
		    bparam->ifbrp_ctime > INT_MAX / hz) {
			error = EINVAL;
			break;
		}
		sc->sc_brttimeout = bparam->ifbrp_ctime;
		if (bparam->ifbrp_ctime != 0)
			timeout_add_sec(&sc->sc_brtimeout, sc->sc_brttimeout);
		else
			timeout_del(&sc->sc_brtimeout);
		break;
	case SIOCBRDGGTO:
		bparam->ifbrp_ctime = sc->sc_brttimeout;
		break;
a519 48
	case SIOCBRDGARL:
		if ((error = suser(curproc, 0)) != 0)
			break;
		ifs = ifunit(brlreq->ifbr_ifsname);
		if (ifs == NULL) {
			error = ENOENT;
			break;
		}
		p = (struct bridge_iflist *)ifs->if_bridgeport;
		if (p == NULL || p->bridge_sc != sc) {
			error = ESRCH;
			break;
		}
		if ((brlreq->ifbr_action != BRL_ACTION_BLOCK &&
		    brlreq->ifbr_action != BRL_ACTION_PASS) ||
		    (brlreq->ifbr_flags & (BRL_FLAG_IN|BRL_FLAG_OUT)) == 0) {
			error = EINVAL;
			break;
		}
		if (brlreq->ifbr_flags & BRL_FLAG_IN) {
			error = bridge_addrule(p, brlreq, 0);
			if (error)
				break;
		}
		if (brlreq->ifbr_flags & BRL_FLAG_OUT) {
			error = bridge_addrule(p, brlreq, 1);
			if (error)
				break;
		}
		break;
	case SIOCBRDGFRL:
		if ((error = suser(curproc, 0)) != 0)
			break;
		ifs = ifunit(brlreq->ifbr_ifsname);
		if (ifs == NULL) {
			error = ENOENT;
			break;
		}
		p = (struct bridge_iflist *)ifs->if_bridgeport;
		if (p == NULL || p->bridge_sc != sc) {
			error = ESRCH;
			break;
		}
		bridge_flushrule(p);
		break;
	case SIOCBRDGGRL:
		error = bridge_brlconf(sc, (struct ifbrlconf *)data);
		break;
d538 2
d544 2
d547 7
d570 3
a591 35
void
bridge_update(struct ifnet *ifp, struct ether_addr *ea, int delete)
{
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
	u_int8_t *addr;

	addr = (u_int8_t *)ea;

	bif = (struct bridge_iflist *)ifp->if_bridgeport;
	sc = bif->bridge_sc;

	/*
	 * Update the bridge interface if it is in
	 * the learning state.
	 */
	if ((bif->bif_flags & IFBIF_LEARNING) &&
	    (ETHER_IS_MULTICAST(addr) == 0) &&
	    !(addr[0] == 0 && addr[1] == 0 && addr[2] == 0 &&
	    addr[3] == 0 && addr[4] == 0 && addr[5] == 0)) {
		/* Care must be taken with spanning tree */
		if ((bif->bif_flags & IFBIF_STP) &&
		    (bif->bif_state == BSTP_IFSTATE_DISCARDING))
			return;

		/* Delete the address from the bridge */
		bridge_rtdaddr(sc, ea);

		if (!delete) {
			/* Update the bridge table */
			bridge_rtupdate(sc, ea, ifp, 0, IFBAF_DYNAMIC, NULL);
		}
	}
}

a679 80
int
bridge_brlconf(struct bridge_softc *sc, struct ifbrlconf *bc)
{
	struct ifnet *ifp;
	struct bridge_iflist *ifl;
	struct brl_node *n;
	struct ifbrlreq req;
	int error = 0;
	u_int32_t i = 0, total = 0;

	ifp = ifunit(bc->ifbrl_ifsname);
	if (ifp == NULL)
		return (ENOENT);
	ifl = (struct bridge_iflist *)ifp->if_bridgeport;
	if (ifl == NULL || ifl->bridge_sc != sc)
		return (ESRCH);

	SIMPLEQ_FOREACH(n, &ifl->bif_brlin, brl_next) {
		total++;
	}
	SIMPLEQ_FOREACH(n, &ifl->bif_brlout, brl_next) {
		total++;
	}

	if (bc->ifbrl_len == 0) {
		i = total;
		goto done;
	}

	SIMPLEQ_FOREACH(n, &ifl->bif_brlin, brl_next) {
		bzero(&req, sizeof req);
		if (bc->ifbrl_len < sizeof(req))
			goto done;
		strlcpy(req.ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(req.ifbr_ifsname, ifl->ifp->if_xname, IFNAMSIZ);
		req.ifbr_action = n->brl_action;
		req.ifbr_flags = n->brl_flags;
		req.ifbr_src = n->brl_src;
		req.ifbr_dst = n->brl_dst;
#if NPF > 0
		req.ifbr_tagname[0] = '\0';
		if (n->brl_tag)
			pf_tag2tagname(n->brl_tag, req.ifbr_tagname);
#endif
		error = copyout((caddr_t)&req,
		    (caddr_t)(bc->ifbrl_buf + (i * sizeof(req))), sizeof(req));
		if (error)
			goto done;
		i++;
		bc->ifbrl_len -= sizeof(req);
	}

	SIMPLEQ_FOREACH(n, &ifl->bif_brlout, brl_next) {
		bzero(&req, sizeof req);
		if (bc->ifbrl_len < sizeof(req))
			goto done;
		strlcpy(req.ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(req.ifbr_ifsname, ifl->ifp->if_xname, IFNAMSIZ);
		req.ifbr_action = n->brl_action;
		req.ifbr_flags = n->brl_flags;
		req.ifbr_src = n->brl_src;
		req.ifbr_dst = n->brl_dst;
#if NPF > 0
		req.ifbr_tagname[0] = '\0';
		if (n->brl_tag)
			pf_tag2tagname(n->brl_tag, req.ifbr_tagname);
#endif
		error = copyout((caddr_t)&req,
		    (caddr_t)(bc->ifbrl_buf + (i * sizeof(req))), sizeof(req));
		if (error)
			goto done;
		i++;
		bc->ifbrl_len -= sizeof(req);
	}

done:
	bc->ifbrl_len = i * sizeof(req);
	return (error);
}

a1327 339
struct ifnet *
bridge_rtupdate(struct bridge_softc *sc, struct ether_addr *ea,
    struct ifnet *ifp, int setflags, u_int8_t flags, struct mbuf *m)
{
	struct bridge_rtnode *p, *q;
	struct sockaddr *sa = NULL;
	u_int32_t h;
	int dir;

	if (m != NULL) {
		/* Check if the mbuf was tagged with a tunnel endpoint addr */
		sa = bridge_tunnel(m);
	}

	h = bridge_hash(sc, ea);
	p = LIST_FIRST(&sc->sc_rts[h]);
	if (p == NULL) {
		if (sc->sc_brtcnt >= sc->sc_brtmax)
			goto done;
		p = malloc(sizeof(*p), M_DEVBUF, M_NOWAIT);
		if (p == NULL)
			goto done;

		bcopy(ea, &p->brt_addr, sizeof(p->brt_addr));
		p->brt_if = ifp;
		p->brt_age = 1;
		bridge_copyaddr(sa, (struct sockaddr *)&p->brt_tunnel);

		if (setflags)
			p->brt_flags = flags;
		else
			p->brt_flags = IFBAF_DYNAMIC;

		LIST_INSERT_HEAD(&sc->sc_rts[h], p, brt_next);
		sc->sc_brtcnt++;
		goto want;
	}

	do {
		q = p;
		p = LIST_NEXT(p, brt_next);

		dir = memcmp(ea, &q->brt_addr, sizeof(q->brt_addr));
		if (dir == 0) {
			if (setflags) {
				q->brt_if = ifp;
				q->brt_flags = flags;
			} else if (!(q->brt_flags & IFBAF_STATIC))
				q->brt_if = ifp;

			if (q->brt_if == ifp)
				q->brt_age = 1;
			ifp = q->brt_if;
			bridge_copyaddr(sa,
			     (struct sockaddr *)&q->brt_tunnel);

			goto want;
		}

		if (dir > 0) {
			if (sc->sc_brtcnt >= sc->sc_brtmax)
				goto done;
			p = malloc(sizeof(*p), M_DEVBUF, M_NOWAIT);
			if (p == NULL)
				goto done;

			bcopy(ea, &p->brt_addr, sizeof(p->brt_addr));
			p->brt_if = ifp;
			p->brt_age = 1;
			bridge_copyaddr(sa,
			    (struct sockaddr *)&p->brt_tunnel);

			if (setflags)
				p->brt_flags = flags;
			else
				p->brt_flags = IFBAF_DYNAMIC;

			LIST_INSERT_BEFORE(q, p, brt_next);
			sc->sc_brtcnt++;
			goto want;
		}

		if (p == NULL) {
			if (sc->sc_brtcnt >= sc->sc_brtmax)
				goto done;
			p = malloc(sizeof(*p), M_DEVBUF, M_NOWAIT);
			if (p == NULL)
				goto done;

			bcopy(ea, &p->brt_addr, sizeof(p->brt_addr));
			p->brt_if = ifp;
			p->brt_age = 1;
			bridge_copyaddr(sa,
			    (struct sockaddr *)&p->brt_tunnel);

			if (setflags)
				p->brt_flags = flags;
			else
				p->brt_flags = IFBAF_DYNAMIC;
			LIST_INSERT_AFTER(q, p, brt_next);
			sc->sc_brtcnt++;
			goto want;
		}
	} while (p != NULL);

done:
	ifp = NULL;
want:
	return (ifp);
}

struct bridge_rtnode *
bridge_rtlookup(struct bridge_softc *sc, struct ether_addr *ea)
{
	struct bridge_rtnode *p;
	u_int32_t h;
	int dir;

	h = bridge_hash(sc, ea);
	LIST_FOREACH(p, &sc->sc_rts[h], brt_next) {
		dir = memcmp(ea, &p->brt_addr, sizeof(p->brt_addr));
		if (dir == 0)
			return (p);
		if (dir > 0)
			goto fail;
	}
fail:
	return (NULL);
}

u_int32_t
bridge_hash(struct bridge_softc *sc, struct ether_addr *addr)
{
	return SipHash24((SIPHASH_KEY *)sc->sc_hashkey, addr, ETHER_ADDR_LEN) &
	    BRIDGE_RTABLE_MASK;
}

void
bridge_timer(void *vsc)
{
	struct bridge_softc *sc = vsc;
	int s;

	s = splsoftnet();
	bridge_rtage(sc);
	splx(s);
}

/*
 * Perform an aging cycle
 */
void
bridge_rtage(struct bridge_softc *sc)
{
	struct bridge_rtnode *n, *p;
	int i;

	for (i = 0; i < BRIDGE_RTABLE_SIZE; i++) {
		n = LIST_FIRST(&sc->sc_rts[i]);
		while (n != NULL) {
			if ((n->brt_flags & IFBAF_TYPEMASK) == IFBAF_STATIC) {
				n->brt_age = !n->brt_age;
				if (n->brt_age)
					n->brt_age = 0;
				n = LIST_NEXT(n, brt_next);
			} else if (n->brt_age) {
				n->brt_age = 0;
				n = LIST_NEXT(n, brt_next);
			} else {
				p = LIST_NEXT(n, brt_next);
				LIST_REMOVE(n, brt_next);
				sc->sc_brtcnt--;
				free(n, M_DEVBUF, sizeof *n);
				n = p;
			}
		}
	}

	if (sc->sc_brttimeout != 0)
		timeout_add_sec(&sc->sc_brtimeout, sc->sc_brttimeout);
}

void
bridge_rtagenode(struct ifnet *ifp, int age)
{
	struct bridge_softc *sc;
	struct bridge_rtnode *n;
	int i;

	sc = ((struct bridge_iflist *)ifp->if_bridgeport)->bridge_sc;
	if (sc == NULL)
		return;

	/*
	 * If the age is zero then flush, otherwise set all the expiry times to
	 * age for the interface
	 */
	if (age == 0)
		bridge_rtdelete(sc, ifp, 1);
	else {
		for (i = 0; i < BRIDGE_RTABLE_SIZE; i++) {
			LIST_FOREACH(n, &sc->sc_rts[i], brt_next) {
				/* Cap the expiry time to 'age' */
				if (n->brt_if == ifp &&
				    n->brt_age > time_uptime + age &&
				    (n->brt_flags & IFBAF_TYPEMASK) == IFBAF_DYNAMIC)
					n->brt_age = time_uptime + age;
			}
		}
	}
}



/*
 * Remove all dynamic addresses from the cache
 */
void
bridge_rtflush(struct bridge_softc *sc, int full)
{
	int i;
	struct bridge_rtnode *p, *n;

	for (i = 0; i < BRIDGE_RTABLE_SIZE; i++) {
		n = LIST_FIRST(&sc->sc_rts[i]);
		while (n != NULL) {
			if (full ||
			    (n->brt_flags & IFBAF_TYPEMASK) == IFBAF_DYNAMIC) {
				p = LIST_NEXT(n, brt_next);
				LIST_REMOVE(n, brt_next);
				sc->sc_brtcnt--;
				free(n, M_DEVBUF, sizeof *n);
				n = p;
			} else
				n = LIST_NEXT(n, brt_next);
		}
	}
}

/*
 * Remove an address from the cache
 */
int
bridge_rtdaddr(struct bridge_softc *sc, struct ether_addr *ea)
{
	int h;
	struct bridge_rtnode *p;

	h = bridge_hash(sc, ea);
	LIST_FOREACH(p, &sc->sc_rts[h], brt_next) {
		if (bcmp(ea, &p->brt_addr, sizeof(p->brt_addr)) == 0) {
			LIST_REMOVE(p, brt_next);
			sc->sc_brtcnt--;
			free(p, M_DEVBUF, sizeof *p);
			return (0);
		}
	}

	return (ENOENT);
}
/*
 * Delete routes to a specific interface member.
 */
void
bridge_rtdelete(struct bridge_softc *sc, struct ifnet *ifp, int dynonly)
{
	int i;
	struct bridge_rtnode *n, *p;

	/*
	 * Loop through all of the hash buckets and traverse each
	 * chain looking for routes to this interface.
	 */
	for (i = 0; i < BRIDGE_RTABLE_SIZE; i++) {
		n = LIST_FIRST(&sc->sc_rts[i]);
		while (n != NULL) {
			if (n->brt_if != ifp) {
				/* Not ours */
				n = LIST_NEXT(n, brt_next);
				continue;
			}
			if (dynonly &&
			    (n->brt_flags & IFBAF_TYPEMASK) != IFBAF_DYNAMIC) {
				/* only deleting dynamics */
				n = LIST_NEXT(n, brt_next);
				continue;
			}
			p = LIST_NEXT(n, brt_next);
			LIST_REMOVE(n, brt_next);
			sc->sc_brtcnt--;
			free(n, M_DEVBUF, sizeof *n);
			n = p;
		}
	}
}

/*
 * Gather all of the routes for this interface.
 */
int
bridge_rtfind(struct bridge_softc *sc, struct ifbaconf *baconf)
{
	int i, error = 0, onlycnt = 0;
	u_int32_t cnt = 0;
	struct bridge_rtnode *n;
	struct ifbareq bareq;

	if (baconf->ifbac_len == 0)
		onlycnt = 1;

	for (i = 0, cnt = 0; i < BRIDGE_RTABLE_SIZE; i++) {
		LIST_FOREACH(n, &sc->sc_rts[i], brt_next) {
			if (!onlycnt) {
				if (baconf->ifbac_len < sizeof(struct ifbareq))
					goto done;
				bcopy(sc->sc_if.if_xname, bareq.ifba_name,
				    sizeof(bareq.ifba_name));
				bcopy(n->brt_if->if_xname, bareq.ifba_ifsname,
				    sizeof(bareq.ifba_ifsname));
				bcopy(&n->brt_addr, &bareq.ifba_dst,
				    sizeof(bareq.ifba_dst));
				bridge_copyaddr(&n->brt_tunnel.sa,
				    (struct sockaddr *)&bareq.ifba_dstsa);
				bareq.ifba_age = n->brt_age;
				bareq.ifba_flags = n->brt_flags;
				error = copyout((caddr_t)&bareq,
				    (caddr_t)(baconf->ifbac_req + cnt), sizeof(bareq));
				if (error)
					goto done;
				baconf->ifbac_len -= sizeof(struct ifbareq);
			}
			cnt++;
		}
	}
done:
	baconf->ifbac_len = cnt * sizeof(struct ifbareq);
	return (error);
}

a1379 90
u_int8_t
bridge_filterrule(struct brl_head *h, struct ether_header *eh, struct mbuf *m)
{
	struct brl_node *n;
	u_int8_t flags;

	SIMPLEQ_FOREACH(n, h, brl_next) {
		flags = n->brl_flags & (BRL_FLAG_SRCVALID|BRL_FLAG_DSTVALID);
		if (flags == 0)
			goto return_action;
		if (flags == (BRL_FLAG_SRCVALID|BRL_FLAG_DSTVALID)) {
			if (bcmp(eh->ether_shost, &n->brl_src, ETHER_ADDR_LEN))
				continue;
			if (bcmp(eh->ether_dhost, &n->brl_dst, ETHER_ADDR_LEN))
				continue;
			goto return_action;
		}
		if (flags == BRL_FLAG_SRCVALID) {
			if (bcmp(eh->ether_shost, &n->brl_src, ETHER_ADDR_LEN))
				continue;
			goto return_action;
		}
		if (flags == BRL_FLAG_DSTVALID) {
			if (bcmp(eh->ether_dhost, &n->brl_dst, ETHER_ADDR_LEN))
				continue;
			goto return_action;
		}
	}
	return (BRL_ACTION_PASS);

return_action:
#if NPF > 0
	pf_tag_packet(m, n->brl_tag, -1);
#endif
	return (n->brl_action);
}

int
bridge_addrule(struct bridge_iflist *bif, struct ifbrlreq *req, int out)
{
	struct brl_node *n;

	n = malloc(sizeof(*n), M_DEVBUF, M_NOWAIT);
	if (n == NULL)
		return (ENOMEM);
	bcopy(&req->ifbr_src, &n->brl_src, sizeof(struct ether_addr));
	bcopy(&req->ifbr_dst, &n->brl_dst, sizeof(struct ether_addr));
	n->brl_action = req->ifbr_action;
	n->brl_flags = req->ifbr_flags;
#if NPF > 0
	if (req->ifbr_tagname[0])
		n->brl_tag = pf_tagname2tag(req->ifbr_tagname, 1);
	else
		n->brl_tag = 0;
#endif
	if (out) {
		n->brl_flags &= ~BRL_FLAG_IN;
		n->brl_flags |= BRL_FLAG_OUT;
		SIMPLEQ_INSERT_TAIL(&bif->bif_brlout, n, brl_next);
	} else {
		n->brl_flags &= ~BRL_FLAG_OUT;
		n->brl_flags |= BRL_FLAG_IN;
		SIMPLEQ_INSERT_TAIL(&bif->bif_brlin, n, brl_next);
	}
	return (0);
}

void
bridge_flushrule(struct bridge_iflist *bif)
{
	struct brl_node *p;

	while (!SIMPLEQ_EMPTY(&bif->bif_brlin)) {
		p = SIMPLEQ_FIRST(&bif->bif_brlin);
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlin, brl_next);
#if NPF > 0
		pf_tag_unref(p->brl_tag);
#endif
		free(p, M_DEVBUF, sizeof *p);
	}
	while (!SIMPLEQ_EMPTY(&bif->bif_brlout)) {
		p = SIMPLEQ_FIRST(&bif->bif_brlout);
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlout, brl_next);
#if NPF > 0
		pf_tag_unref(p->brl_tag);
#endif
		free(p, M_DEVBUF, sizeof *p);
	}
}

a2066 1

@


1.270
log
@Use input handlers for bridge(4).

This allows more flexible configurations with vlan(4) and bridge(4) on
top of the same physical interface.  In particular it allows to not feed
VLAN tagget packets into a bridge(4).

Fix regression reported by Armin Wolfermann on bugs@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.269 2015/11/07 12:37:18 mpi Exp $	*/
a1339 1
		bridge_ifinput(ifp, mc);
d1346 2
a1347 2
				bridge_ifinput(ifl->ifp, m);
				return;
d1349 3
a1351 1
		}
d1353 2
@


1.269
log
@Don't try to be clever testing if a queue is full before calling
if_enqueue().  As pointed by dlg@@, IF_QFULL on works in the priq
case.

Prompted by a diff from uebayasi@@ to export ifi_oqdrops, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.268 2015/10/12 10:03:25 reyk Exp $	*/
d117 1
d274 1
d393 1
d1267 2
a1268 2
struct mbuf *
bridge_input(struct ifnet *ifp, struct mbuf *m)
d1270 6
a1275 2
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("bridge_input(): no HDR");
d1278 2
a1279 1
	return (NULL);
@


1.268
log
@Introduce bridge_ifinput() to handle some repeated logic before
if_input() and to have a counterpart for bridge_ifenqueue() that helps
to understand the traffic/code flow in bridge better.  The bridge
currently only puts a single packet on the input mbuf list, and
changing will need to undo part of this commit, but it still makes
sense to have a well-defined call for the ports receive path.
No functional change.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.267 2015/10/05 19:05:09 uebayasi Exp $	*/
a1030 5
			if (IF_QFULL(&dst_if->if_snd)) {
				IF_DROP(&dst_if->if_snd);
				sc->sc_if.if_oerrors++;
				continue;
			}
a1455 5
		if (IF_QFULL(&dst_if->if_snd)) {
			IF_DROP(&dst_if->if_snd);
			sc->sc_if.if_oerrors++;
			continue;
		}
a1533 6

		if (IF_QFULL(&ifp->if_snd)) {
			IF_DROP(&ifp->if_snd);
			sc->sc_if.if_oerrors++;
			continue;
		}
@


1.267
log
@Revert if_oqdrops accounting changes done in kernel, per request from mpi@@.

(Especially adding IF_DROP() after IFQ_ENQUEUE() was completely wrong because
IFQ_ENQUEUE() already does it.  Oops.)

After this revert, the situation becomes:

- if_snd.ifq_drops is incremented in either IFQ_ENQUEUE() or IF_DROP(), but
  it is not shown to userland, and

- if_data.ifi_oqdrops is shown to userland, but it is not incremented by
  anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d149 1
a1286 1
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
d1337 1
a1337 3
		mc->m_flags |= M_PROTO1;
		ml_enqueue(&ml, mc);
		if_input(ifp, &ml);
d1344 1
a1344 3
				m->m_flags |= M_PROTO1;
				ml_enqueue(&ml, m);
				if_input(ifl->ifp, &ml);
d1388 1
a1388 3
			m->m_flags |= M_PROTO1;
			ml_enqueue(&ml, m);
			if_input(ifl->ifp, &ml);
d1406 1
a1406 3
	m->m_flags |= M_PROTO1;
	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
a1503 1
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
d1527 2
a1528 3
	m1->m_flags |= M_PROTO1;
	ml_enqueue(&ml, m1);
	if_input(ifp, &ml);
d2551 11
@


1.266
log
@Don't count IF_DROP()'ed packets as if_oerrors too.

mpi@@ plans to clean-up IF_DROP()'s, but fix consistent use of it for now.

OK dlg@@
@
text
@d1032 1
d1471 1
d1557 1
@


1.265
log
@add sizes to some of the simpler free calls
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.264 2015/09/10 16:41:30 mikeb Exp $	*/
a1031 1
				sc->sc_if.if_oerrors++;
a1469 1
			sc->sc_if.if_oerrors++;
a1554 1
			sc->sc_if.if_oerrors++;
@


1.264
log
@pass a cookie argument to interface input handlers that can be used
to pass additional context or transient data with the similar life
time.

ok mpi, suggestions, hand holding and ok from dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.263 2015/09/10 15:27:00 mpi Exp $	*/
d195 1
a195 1
		free(sc, M_DEVBUF, 0);
d243 1
a243 1
		free(bif, M_DEVBUF, 0);
d257 1
a257 1
	free(sc, M_DEVBUF, 0);
d275 1
a275 1
	free(p, M_DEVBUF, 0);
d448 1
a448 1
				free(p, M_DEVBUF, 0);
d821 1
a821 1
		free(breq, M_DEVBUF, 0);
d1745 1
a1745 1
				free(n, M_DEVBUF, 0);
d1804 1
a1804 1
				free(n, M_DEVBUF, 0);
d1826 1
a1826 1
			free(p, M_DEVBUF, 0);
d1863 1
a1863 1
			free(n, M_DEVBUF, 0);
d2042 1
a2042 1
		free(p, M_DEVBUF, 0);
d2050 1
a2050 1
		free(p, M_DEVBUF, 0);
@


1.263
log
@Even the driver that should not be named needs if_put() after if_get().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.262 2015/09/10 13:32:19 dlg Exp $	*/
d226 1
a226 1
	if_ih_insert(ifp, ether_input);
d251 1
a251 1
	if_ih_remove(ifp, ether_input);
@


1.262
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.261 2015/09/09 12:50:08 mpi Exp $	*/
d118 1
a118 1
void	bridge_process(struct mbuf *);
d1085 1
d1091 12
a1102 2
	while ((m = ml_dequeue(&ml)) != NULL)
		bridge_process(m);
d1279 1
a1279 1
bridge_process(struct mbuf *m)
a1284 1
	struct ifnet *ifp;
a1287 6

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freem(m);
		return;
	}
@


1.261
log
@Kill a couple of if_get()s only needed to increment per-ifp IPv6 stats.

We do not export those per-ifp statistics and they will soon all die.

"We're putting inet6 on a diet" claudio@@

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.260 2015/08/26 09:40:31 mpi Exp $	*/
a185 1
	struct ifih *bridge_ifih;
a192 6
	bridge_ifih = malloc(sizeof(*bridge_ifih), M_DEVBUF, M_NOWAIT);
	if (bridge_ifih == NULL) {
		free(sc, M_DEVBUF, 0);
		return (ENOMEM);
	}

a194 1
		free(bridge_ifih, M_DEVBUF, sizeof(*bridge_ifih));
d226 1
a226 2
	bridge_ifih->ifih_input = ether_input;
	SLIST_INSERT_HEAD(&ifp->if_inputs, bridge_ifih, ifih_next);
a235 1
	struct ifih *bridge_ifih;
d251 1
a251 4
	bridge_ifih = SLIST_FIRST(&ifp->if_inputs);
	SLIST_REMOVE_HEAD(&ifp->if_inputs, ifih_next);

	KASSERT(SLIST_EMPTY(&ifp->if_inputs));
d253 1
a253 1
	free(bridge_ifih, M_DEVBUF, sizeof(*bridge_ifih));
@


1.260
log
@Use the specialized m_copym2() preserving the alignment of the payload
in bridge_localbroadcast() too.

This should fix another alignment issue kettenis@@ is seeing.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.259 2015/08/24 21:28:47 bluhm Exp $	*/
a2380 1
			struct ifnet *ifp;
a2381 3
			ifp = if_get(m->m_pkthdr.ph_ifidx);
			if (ifp != NULL)
				in6_ifstat_inc(ifp, ifs6_in_hdrerr);
@


1.259
log
@The bridge list is a relict, delete the remaining LIST_REMOVE.
This fixes a crash during ifconfig bridge0 destroy.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.258 2015/08/18 09:01:16 mpi Exp $	*/
d1540 1
a1540 1
	m1 = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
@


1.258
log
@Apply the logic used for "protocol" queues to bridge(4).  This allows
to defer the work currently done in bridge_input() and requiring the
KERNEL_LOCK to bridgeintr().

Tested by sthen@@

ok rzalamena@@, dlg@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.257 2015/07/20 22:54:29 mpi Exp $	*/
a245 1
	int s;
a254 4

	s = splnet();
	LIST_REMOVE(sc, sc_list);
	splx(s);
@


1.257
log
@Remove splassert(IPL_NET) from if_input().

if_input() has been designed to be able to safely handle a batch of
packets from physical drivers to the network stack.  Most of these
drivers have an interrupt routine executed at IPL_NET and the check
made sense during the conversion.  However we also want to re-enqueue
packets with if_input() from the network stack currently running at
IPL_SOFTNET.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.256 2015/07/20 22:16:41 rzalamena Exp $	*/
d118 2
a119 1
void	bridgeintr_frame(struct bridge_softc *, struct mbuf *);
d170 1
a170 1
LIST_HEAD(, bridge_softc) bridge_list;
a178 1
	LIST_INIT(&bridge_list);
d188 1
a188 1
	int i, s;
a224 2
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	IFQ_SET_READY(&ifp->if_snd);
a236 4
	s = splnet();
	LIST_INSERT_HEAD(&bridge_list, sc, sc_list);
	splx(s);

d1101 1
a1101 1
	struct bridge_softc *sc;
a1102 1
	int s;
d1104 6
a1109 10
	LIST_FOREACH(sc, &bridge_list, sc_list) {
		for (;;) {
			s = splnet();
			IF_DEQUEUE(&sc->sc_if.if_snd, m);
			splx(s);
			if (m == NULL)
				break;
			bridgeintr_frame(sc, m);
		}
	}
d1116 1
a1116 1
bridgeintr_frame(struct bridge_softc *sc, struct mbuf *m)
d1118 1
a1118 1
	struct ifnet *src_if, *dst_if;
a1124 10
	if ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {
		m_freem(m);
		return;
	}

	src_if = if_get(m->m_pkthdr.ph_ifidx);
	if (src_if == NULL) {
		m_freem(m);
		return;
	}
d1130 1
a1130 10
	if (ifl == NULL) {
		m_freem(m);
		return;
	}

	if ((ifl->bif_flags & IFBIF_STP) &&
	    (ifl->bif_state == BSTP_IFSTATE_DISCARDING)) {
		m_freem(m);
		return;
	}
d1278 10
d1292 1
a1295 1
	int s;
d1297 5
a1301 2
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("bridge_input(): no HDR");
d1305 1
a1305 1
		return (m);
d1309 1
a1309 1
		return (m);
d1333 1
a1333 1
					return (NULL);
d1336 1
a1336 1
				return (NULL);
d1341 1
a1341 1
		 * No need to queue frames for ifs in the discarding state
d1345 1
a1345 1
			return (m);
d1349 5
a1353 10
			return (m);
		s = splnet();
		if (IF_QFULL(&sc->sc_if.if_snd)) {
			m_freem(mc);
			splx(s);
			return (m);
		}
		IF_ENQUEUE(&sc->sc_if.if_snd, mc);
		splx(s);
		schednetisr(NETISR_BRIDGE);
d1363 1
a1363 1
				return (NULL);
d1367 2
a1368 1
		return (m);
d1376 1
a1376 1
		return (m);
d1399 1
a1399 1
				return (NULL);
d1409 1
a1409 1
			return (NULL);
d1418 1
a1418 1
			return (NULL);
d1421 8
a1428 10
	s = splnet();
	if (IF_QFULL(&sc->sc_if.if_snd)) {
		m_freem(m);
		splx(s);
		return (NULL);
	}
	IF_ENQUEUE(&sc->sc_if.if_snd, m);
	splx(s);
	schednetisr(NETISR_BRIDGE);
	return (NULL);
@


1.256
log
@Implemented MPLS pseudowire (mpw(4)) to be used with VPLS and VPWS.

ok mpi@@, claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.255 2015/07/17 18:05:59 mpi Exp $	*/
a1551 1
	int s;
a1574 1
	s = splnet();
a1575 1
	splx(s);
@


1.255
log
@Explicitly do EtherIP encapsulation in bridge_ifenqueue().

The way gif(4) and bridge(4) are plugged together is disgusting but at
least this makes the layer violation obvious.

Fix a regression introduced by the M_PROTO1 loop prevention cleaning
because gif(4) was abusing this flag to figure out if the packet was
coming from a bridge(4).

Thanks to goda@@ for finding this!

ok goda@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.254 2015/07/16 21:14:21 mpi Exp $	*/
d39 1
d390 5
d1041 9
a1049 1

d1497 9
a1505 1

@


1.254
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.253 2015/07/15 22:16:41 deraadt Exp $	*/
d94 4
d1362 1
d1374 1
d2565 4
d2570 1
a2570 1
#endif
@


1.253
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.252 2015/07/02 10:02:40 mpi Exp $	*/
d2196 1
a2196 2
			    pf_test(af, dir, encif,
			    &m, NULL) != PF_PASS) {
d2346 1
a2346 1
		if (pf_test(AF_INET, dir, ifp, &m, eh) != PF_PASS)
d2402 1
a2402 1
		if (pf_test(AF_INET6, dir, ifp, &m, eh) != PF_PASS)
@


1.252
log
@Unify the check for up & running between all pseudo-drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.251 2015/07/02 09:40:02 mpi Exp $	*/
d2436 1
a2436 2
	if (m != NULL)
		m_freem(m);
d2542 1
a2542 2
	if (m != NULL)
		m_freem(m);
@


1.251
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.250 2015/06/30 13:54:42 mpi Exp $	*/
d1307 1
a1307 1
	if ((sc->sc_if.if_flags & IFF_RUNNING) == 0)
@


1.250
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.249 2015/06/30 09:13:53 mpi Exp $	*/
d1288 1
a1288 1
bridge_input(struct mbuf *m)
a1289 1
	struct ifnet *ifp;
a1298 5
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	KASSERT(ifp != NULL);
	if (((ifp->if_flags & IFF_UP) == 0) || (ifp->if_bridgeport == NULL))
		return (m);

d1303 3
@


1.249
log
@Move the specialized m_copym2() preserving the alignment of the payload
after the Ethernet header in its own function and use it in bridge_input().

This should fix alignment issues kettenis@@ is seeing.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.248 2015/06/25 09:38:00 mpi Exp $	*/
d2569 1
a2569 1
	error = if_output(ifp, m);
@


1.248
log
@Properly deliver broadcast-like packets to the network stack.

In bridge(4) speak, broadcast-like packets are Ethernet Multicast
frames or Unicast for which the destination is unknown.

It makes sense to not retransmit broadcast-like packets on the interface
they were received but they still must be delivered to the network stack.

Problem reported by and ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.247 2015/06/25 09:20:20 mpi Exp $	*/
d156 1
d969 1
a969 1
	int error, len;
d1045 2
a1046 5
				struct mbuf *m1, *m2, *mx;

				m1 = m_copym2(m, 0, ETHER_HDR_LEN,
				    M_DONTWAIT);
				if (m1 == NULL) {
a1049 19
				m2 = m_copym2(m, ETHER_HDR_LEN,
				    M_COPYALL, M_DONTWAIT);
				if (m2 == NULL) {
					m_freem(m1);
					sc->sc_if.if_oerrors++;
					continue;
				}

				for (mx = m1; mx->m_next != NULL; mx = mx->m_next)
					/*EMPTY*/;
				mx->m_next = m2;

				if (m1->m_flags & M_PKTHDR) {
					len = 0;
					for (mx = m1; mx != NULL; mx = mx->m_next)
						len += mx->m_len;
					m1->m_pkthdr.len = len;
				}
				mc = m1;
d1349 1
a1349 1
		mc = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
d1492 2
a1493 5
			struct mbuf *m1, *m2, *mx;

			m1 = m_copym2(m, 0, ETHER_HDR_LEN,
			    M_DONTWAIT);
			if (m1 == NULL) {
a1496 20
			m2 = m_copym2(m, ETHER_HDR_LEN,
			    M_COPYALL, M_DONTWAIT);
			if (m2 == NULL) {
				m_freem(m1);
				sc->sc_if.if_oerrors++;
				continue;
			}

			for (mx = m1; mx->m_next != NULL; mx = mx->m_next)
				/*EMPTY*/;
			mx->m_next = m2;

			if (m1->m_flags & M_PKTHDR) {
				int len = 0;

				for (mx = m1; mx != NULL; mx = mx->m_next)
					len += mx->m_len;
				m1->m_pkthdr.len = len;
			}
			mc = m1;
d1557 1
a1557 1
bridge_span(struct bridge_softc *sc, struct mbuf *morig)
d1561 1
a1561 1
	struct mbuf *mc, *m;
a1563 7
	if (TAILQ_EMPTY(&sc->sc_spanlist))
		return;

	m = m_copym2(morig, 0, M_COPYALL, M_NOWAIT);
	if (m == NULL)
		return;

a1585 1
	m_freem(m);
d2715 34
@


1.247
log
@Move brige(4)'s output hook outside of ether_output().

This fix some weird bridge(4) configurations involving pseudo-drivers
stacked on top of interfaces in a bridge.

Also simplifies the loop prevention logic to match bridge's input path.
Instead of using a tag per port/bridge simply flag output mbufs to make
sure only one copy per bridge go through bridge_output().

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.246 2015/06/24 09:40:54 mpi Exp $	*/
a1471 4
		/*
		 * Don't retransmit out of the same interface where
		 * the packet was received from.
		 */
d1473 2
a1474 1
		if (dst_if->if_index == ifp->if_index)
a1484 9
		if ((dst_if->if_flags & IFF_RUNNING) == 0)
			continue;

		if (IF_QFULL(&dst_if->if_snd)) {
			IF_DROP(&dst_if->if_snd);
			sc->sc_if.if_oerrors++;
			continue;
		}

d1494 13
@


1.246
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.245 2015/06/23 09:42:23 mpi Exp $	*/
d2606 3
a2611 1
		m->m_flags |= M_PROTO1;
@


1.245
log
@Adapt bridge(4) to the new if_input() framework.

Move bridge_input() outside of ether_input() in order to duplicate packets
flowing through a bridge port before applying any transformation on mbufs.

This saves a various m_adj(9)/M_PREPEND(9) dances and remove the bridge(4)
hack from vlan(4).

Tested by mxb <mxb AT alumni DOT chalmers DOT se> and kettenis@@

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.244 2015/06/16 11:09:39 mpi Exp $	*/
a1389 1
				ifl->ifp->if_ipackets++;
a1433 1
			ifl->ifp->if_ipackets++;
a1596 1
	ifp->if_ipackets++;
@


1.244
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.243 2015/06/12 15:40:06 mpi Exp $	*/
a118 2
struct mbuf *bridge_dispatch(struct bridge_iflist *, struct ifnet *,
	     struct mbuf *);
d1199 1
a1199 1
	if ((m->m_flags & (M_BCAST | M_MCAST)) == 0) {
d1208 6
a1213 1
	} else
d1215 1
d1309 1
a1309 1
bridge_input(struct ifnet *ifp, struct ether_header *eh0, struct mbuf *m)
d1311 1
d1314 1
d1316 4
a1319 3
#if NVLAN > 0
	uint16_t etype = ntohs(eh0->ether_type);
#endif /* NVLAN > 0 */
d1321 3
a1323 4
	/*
	 * Make sure this interface is a bridge member.
	 */
	if (ifp == NULL || ifp->if_bridgeport == NULL || m == NULL)
a1328 2
	m->m_flags &= ~M_PROTO1;	/* Loop prevention */

a1333 6
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
		return (NULL);
	eh = mtod(m, struct ether_header *);
	memmove(eh, eh0, sizeof(*eh));

a1340 26
	m = bridge_dispatch(ifl, ifp, m);

#if NVLAN > 0
	if ((m != NULL) && ((m->m_flags & M_VLANTAG) ||
	    etype == ETHERTYPE_VLAN || etype == ETHERTYPE_QINQ)) {
		/* The bridge did not want the vlan frame either, drop it. */
		ifp->if_noproto++;
		m_freem(m);
		m = NULL;
	}
#endif /* NVLAN > 0 */

	return (m);
}

struct mbuf *
bridge_dispatch(struct bridge_iflist *ifl, struct ifnet *ifp, struct mbuf *m)
{
	struct bridge_softc *sc = ifl->bridge_sc;
	struct bridge_iflist *srcifl;
	struct ether_header *eh;
	struct arpcom *ac;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *mc;
	int s;

d1342 1
a1342 2

	if (m->m_flags & (M_BCAST | M_MCAST)) {
@


1.243
log
@Remove superfluous splnet() protection.

ok lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.242 2015/06/11 15:59:17 mikeb Exp $	*/
d1146 5
a1150 1
	src_if = m->m_pkthdr.rcvif;
d2471 1
d2473 3
a2475 1
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
@


1.242
log
@Move away from using hzto(9);  OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.241 2015/06/08 13:44:08 mpi Exp $	*/
d970 1
a970 1
	int s, error, len;
a1074 1
			s = splnet();
a1075 1
			splx(s);
a1093 1
	s = splnet();
a1094 1
	splx(s);
a1133 1
	int s, len;
d1139 1
a1291 1
		s = splnet();
a1292 1
		splx(s);
d1496 1
a1496 1
	int len, s, used = 0;
a1581 1
			s = splnet();
a1582 1
			splx(s);
d1633 1
a1633 1
	int s, error;
a1659 1
		s = splnet();
a1660 1
		splx(s);
d2526 1
a2526 1
	int s, error = 0;
a2540 1
			s = splnet();
a2541 1
			splx(s);
a2608 1
			s = splnet();
a2610 1
				splx(s);
a2612 1
			splx(s);
@


1.241
log
@Merge multiple copies of the code doing VLAN tag insertion back into
vlan_start().

ok sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.240 2015/06/02 13:21:21 mpi Exp $	*/
a2164 1
	struct timeval tv;
a2259 11

				tv.tv_usec = 0;

				/* Check for wrap-around. */
				if (tdb->tdb_exp_first_use + tdb->tdb_first_use
				    < tdb->tdb_first_use)
					tv.tv_sec = ((unsigned long)-1) / 2;
				else
					tv.tv_sec = tdb->tdb_exp_first_use +
					    tdb->tdb_first_use;

d2261 2
a2262 12
					timeout_add(&tdb->tdb_first_tmo,
					    hzto(&tv));

				/* Check for wrap-around. */
				if (tdb->tdb_first_use +
				    tdb->tdb_soft_first_use
				    < tdb->tdb_first_use)
					tv.tv_sec = ((unsigned long)-1) / 2;
				else
					tv.tv_sec = tdb->tdb_first_use +
					    tdb->tdb_soft_first_use;

d2264 2
a2265 2
					timeout_add(&tdb->tdb_sfirst_tmo,
					    hzto(&tv));
@


1.240
log
@Use if_input() instead of ether_input_mbuf().

ok jasper@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.239 2015/05/18 11:43:57 mpi Exp $	*/
a2662 5
#if NVLAN > 0
extern int vlan_output(struct ifnet *, struct mbuf *, struct sockaddr *,
    struct rtentry *);
#endif

a2675 39
	}
#endif
#if NVLAN > 0
	/*
	 * If the underlying interface cannot do VLAN tag insertion itself,
	 * create an encapsulation header.
	 */
	if (ifp->if_output == vlan_output) {
		struct ifvlan	*ifv = ifp->if_softc;
		struct ifnet	*p = ifv->ifv_p;
		u_int8_t        prio = m->m_pkthdr.pf.prio;

		/* IEEE 802.1p has prio 0 and 1 swapped */
		if (prio <= 1)
			prio = !prio;

		/* should we use the tx tagging hw offload at all? */
		if ((p->if_capabilities & IFCAP_VLAN_HWTAGGING) &&
		    (ifv->ifv_type == ETHERTYPE_VLAN)) {
			m->m_pkthdr.ether_vtag = ifv->ifv_tag +
			    (prio << EVL_PRIO_BITS);
			m->m_flags |= M_VLANTAG;
		} else {
			struct ether_vlan_header evh;

			m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&evh);
			evh.evl_proto = evh.evl_encap_proto;
			evh.evl_encap_proto = htons(ifv->ifv_type);
			evh.evl_tag = htons(ifv->ifv_tag +
			    (prio << EVL_PRIO_BITS));
			m_adj(m, ETHER_HDR_LEN);
			M_PREPEND(m, sizeof(evh), M_DONTWAIT);
			if (m == NULL) {
				sc->sc_if.if_oerrors++;
				return (ENOBUFS);
			}
			m_copyback(m, 0, sizeof(evh), &evh, M_NOWAIT);
			m->m_flags &= ~M_VLANTAG;
		}
@


1.239
log
@Do not change "rcvif" without goint through if_input() again otherwise
the handlers on the new interface won't be executed.

Tested by < mxb AT alumni.chalmers DOT se>

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.238 2015/05/15 10:15:13 mpi Exp $	*/
d1367 1
d1415 3
a1417 11
				if (ifl->ifp->if_type == IFT_ETHER)
					break;
			}
			if (ifl != NULL) {
				m->m_pkthdr.rcvif = ifl->ifp;
				m->m_pkthdr.ph_rtableid = ifl->ifp->if_rdomain;
#if NBPFILTER > 0
				if (ifl->ifp->if_bpf)
					bpf_mtap_ether(ifl->ifp->if_bpf, m,
					    BPF_DIRECTION_IN);
#endif
d1419 2
a1420 1
				ether_input_mbuf(ifl->ifp, m);
d1422 1
a1422 1
				m = NULL;
a1458 10
			/* Make sure the real incoming interface
			 * is aware */
#if NBPFILTER > 0
			if (ifl->ifp->if_bpf)
				bpf_mtap_ether(ifl->ifp->if_bpf, m,
				    BPF_DIRECTION_IN);
#endif
			/* Count for the interface we are going to */
			ifl->ifp->if_ipackets++;

a1462 2
			m->m_pkthdr.rcvif = ifl->ifp;
			m->m_pkthdr.ph_rtableid = ifl->ifp->if_rdomain;
d1464 3
a1466 1
			ether_input_mbuf(ifl->ifp, m);
d1602 1
d1605 1
a1626 3
	/* fixup header a bit */
	m1->m_pkthdr.rcvif = ifp;
	m1->m_pkthdr.ph_rtableid = ifp->if_rdomain;
d1628 4
a1631 8

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m1,
		    BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m1);
@


1.238
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.237 2015/05/07 01:55:43 jsg Exp $	*/
d1481 3
a1483 6
			if (ifp->if_type == IFT_GIF) {
				m->m_flags |= M_PROTO1;
				ether_input_mbuf(ifl->ifp, m);
				m = NULL;
			}
			return (m);
@


1.237
log
@fix indentation
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.236 2015/05/04 10:24:08 mpi Exp $	*/
a2695 1
	short mflags;
d2747 2
a2748 2
	mflags = m->m_flags;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d2753 1
a2755 4
	ifp->if_obytes += len;
	if (mflags & M_MCAST)
		ifp->if_omcasts++;
	if_start(ifp);
@


1.236
log
@Use ether_input() as default input packet handler and do the necessary
m_adj(9) to keep bridge(4) working while other pseudo-drivers are
converted to if_input().

Tested by mxb <mxb AT alumni DOT chalmers DOT se>, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.235 2015/04/17 11:04:01 mikeb Exp $	*/
d1680 5
a1684 5
			if (IF_QFULL(&ifp->if_snd)) {
				IF_DROP(&ifp->if_snd);
				sc->sc_if.if_oerrors++;
				continue;
			}
@


1.235
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.234 2015/04/13 08:52:51 mpi Exp $	*/
d118 1
a118 2
void	bridge_span(struct bridge_softc *, struct ether_header *,
    struct mbuf *);
d120 1
a120 1
    struct ether_header *, struct mbuf *);
d182 1
d190 6
d198 1
d232 3
d247 1
d264 11
d1015 1
a1015 1
		bridge_span(sc, NULL, m);
d1091 1
a1091 1
	bridge_span(sc, NULL, m);
d1307 1
a1307 1
bridge_input(struct ifnet *ifp, struct ether_header *eh, struct mbuf *m)
d1311 1
d1313 1
a1313 1
	uint16_t etype = ntohs(eh->ether_type);
d1332 6
d1340 1
a1340 2
		bpf_mtap_hdr(sc->sc_if.if_bpf, (caddr_t)eh,
		    ETHER_HDR_LEN, m, BPF_DIRECTION_IN, NULL);
d1343 1
a1343 1
	bridge_span(sc, eh, m);
d1345 1
a1345 1
	m = bridge_dispatch(ifl, ifp, eh, m);
d1361 1
a1361 2
bridge_dispatch(struct bridge_iflist *ifl, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
d1365 1
d1370 2
a1399 5
		/*
		 * make a copy of 'm' with 'eh' tacked on to the
		 * beginning.  Return 'm' for local processing
		 * and enqueue the copy.  Schedule netisr.
		 */
a1402 4
		M_PREPEND(mc, ETHER_HDR_LEN, M_DONTWAIT);
		if (mc == NULL)
			return (m);
		bcopy(eh, mtod(mc, caddr_t), ETHER_HDR_LEN);
d1422 1
a1422 1
					bpf_mtap(ifl->ifp->if_bpf, m,
d1426 1
a1426 1
				ether_input(m, eh);
d1469 2
a1470 2
				bpf_mtap_hdr(ifl->ifp->if_bpf, (caddr_t)eh,
				    ETHER_HDR_LEN, m, BPF_DIRECTION_IN, NULL);
d1477 1
a1477 1
			sc->sc_if.if_ibytes += ETHER_HDR_LEN + m->m_pkthdr.len;
d1483 1
a1483 1
				ether_input(m, eh);
a1497 4
	M_PREPEND(m, ETHER_HDR_LEN, M_DONTWAIT);
	if (m == NULL)
		return (NULL);
	bcopy(eh, mtod(m, caddr_t), ETHER_HDR_LEN);
d1655 1
a1655 1
	ether_input(m1, NULL);
d1660 1
a1660 2
bridge_span(struct bridge_softc *sc, struct ether_header *eh,
    struct mbuf *morig)
a1672 6
	if (eh != NULL) {
		M_PREPEND(m, ETHER_HDR_LEN, M_DONTWAIT);
		if (m == NULL)
			return;
		bcopy(eh, mtod(m, caddr_t), ETHER_HDR_LEN);
	}
@


1.234
log
@Move one "#ifdef NVLAN" chunk needed only if you're running bridge(4) on
to of vlan(4) from ether_input() to bridge_input().

One of the goal of the if_input() plumbing is to stop doing all possible
pseudo-drivers checks on every packets.  There's no reason that even if
you're not running a bridge(4) you've to run this code.

This change also will also makes it easier to convert vlan(4) to if_input().

Reviewed by Rafael Zalamena and mikeb@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.233 2015/04/07 10:46:20 mpi Exp $	*/
a153 1
#define ICMP_DEFLEN MHLEN
a948 3
#ifdef IPSEC
	struct m_tag *mtag;
#endif /* IPSEC */
a992 12
#ifdef IPSEC
		/*
		 * Don't send out the packet if IPsec is needed, and
		 * notify IPsec to do its own crypto for now.
		 */
		if ((mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED,
		    NULL)) != NULL) {
			ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
			m_freem(m);
			return (0);
		}
#endif /* IPSEC */
@


1.233
log
@Do not pass an `ifp' argument to interface input handlers since it
might be overwritten by pseudo-drivers.

ok dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.232 2015/02/06 22:10:43 benno Exp $	*/
d120 2
d1304 4
a1307 4
	int s;
	struct bridge_iflist *ifl, *srcifl;
	struct arpcom *ac;
	struct mbuf *mc;
d1332 25
@


1.232
log
@earlier rev 1.112 sys/net/if_vlan.c corrects the mapping of 802.1p
prio from the vlan header to our pf priority levels. This fixes the
mapping in the bridge code.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.231 2014/12/22 03:38:01 tedu Exp $	*/
d1394 1
a1394 1
				ether_input(ifl->ifp, eh, m);
d1451 1
a1451 1
				ether_input(ifl->ifp, eh, m);
d1627 1
a1627 1
	ether_input(ifp, NULL, m1);
@


1.231
log
@convert to using siphash
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.230 2014/12/19 17:14:39 tedu Exp $	*/
d2695 5
d2705 1
a2705 1
			    (m->m_pkthdr.pf.prio << EVL_PRIO_BITS);
d2714 1
a2714 1
			    (m->m_pkthdr.pf.prio << EVL_PRIO_BITS));
@


1.230
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.229 2014/12/04 16:16:20 mikeb Exp $	*/
d49 2
d202 1
a202 1
	sc->sc_hashkey = arc4random();
a1809 19
/*
 * The following hash function is adapted from 'Hash Functions' by Bob Jenkins
 * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).
 * "You may use this code any way you wish, private, educational, or
 *  commercial.  It's free."
 */
#define	mix(a,b,c) \
	do {						\
		a -= b; a -= c; a ^= (c >> 13);		\
		b -= c; b -= a; b ^= (a << 8);		\
		c -= a; c -= b; c ^= (b >> 13);		\
		a -= b; a -= c; a ^= (c >> 12);		\
		b -= c; b -= a; b ^= (a << 16);		\
		c -= a; c -= b; c ^= (b >> 5);		\
		a -= b; a -= c; a ^= (c >> 3);		\
		b -= c; b -= a; b ^= (a << 10);		\
		c -= a; c -= b; c ^= (b >> 15);		\
	} while (0)

d1813 2
a1814 11
	u_int32_t a = 0x9e3779b9, b = 0x9e3779b9, c = sc->sc_hashkey;

	b += addr->ether_addr_octet[5] << 8;
	b += addr->ether_addr_octet[4];
	a += addr->ether_addr_octet[3] << 24;
	a += addr->ether_addr_octet[2] << 16;
	a += addr->ether_addr_octet[1] << 8;
	a += addr->ether_addr_octet[0];

	mix(a, b, c);
	return (c & BRIDGE_RTABLE_MASK);
@


1.229
log
@Repair VLAN tagging in the bridge output path

Since bridge_output/bridge_ifenqueue replace ether_output that does
VLAN tagging and call into if_start directly we need to make sure
that tag has been set by the bridge.

 XXX  This abuses "if_output == vlan_output" check, but hopefully
 XXX  vlan(4) will use a distinct if_type someday and this code
 XXX  will be improved.

Discussed with henning and Rafael Zalamena, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.228 2014/11/18 02:37:31 tedu Exp $	*/
a53 1
#ifdef INET
a58 1
#endif
a143 1
#ifdef INET
a145 1
#endif
a1593 1
#ifdef INET
a1607 1
#endif
a2199 1
#ifdef INET
a2200 1
#endif /* INET */
a2209 1
#ifdef INET
a2240 1
#endif /* INET */
a2588 1
#ifdef INET
a2590 1
#endif
a2591 3
#ifndef INET
	goto dropit;
#else
a2686 1
#endif /* INET */
a2763 1
#ifdef INET
a2835 1
#endif
@


1.228
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.227 2014/09/08 06:24:13 jsg Exp $	*/
d2708 5
d2734 12
a2745 3
	if ((m->m_flags & M_VLANTAG) &&
	    (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING) == 0) {
		struct ether_vlan_header evh;
d2747 13
a2759 9
		m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&evh);
		evh.evl_proto = evh.evl_encap_proto;
		evh.evl_encap_proto = htons(ETHERTYPE_VLAN);
		evh.evl_tag = htons(m->m_pkthdr.ether_vtag);
		m_adj(m, ETHER_HDR_LEN);
		M_PREPEND(m, sizeof(evh), M_DONTWAIT);
		if (m == NULL) {
			sc->sc_if.if_oerrors++;
			return (ENOBUFS);
a2760 2
		m_copyback(m, 0, sizeof(evh), &evh, M_NOWAIT);
		m->m_flags &= ~M_VLANTAG;
@


1.227
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.226 2014/07/22 11:06:09 mpi Exp $	*/
a52 3

/* for arc4random() */
#include <dev/rndvar.h>
@


1.226
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.225 2014/07/12 18:44:22 tedu Exp $	*/
a51 1
#include <net/route.h>
@


1.226.4.1
log
@Repair VLAN tagging in the bridge output path

Since bridge_output/bridge_ifenqueue replace ether_output that does
VLAN tagging and call into if_start directly we need to make sure
that tag has been set by the bridge.

 XXX  This abuses "if_output == vlan_output" check, but hopefully
 XXX  vlan(4) will use a distinct if_type someday and this code
 XXX  will be improved.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.226 2014/07/22 11:06:09 mpi Exp $	*/
a2711 5
#if NVLAN > 0
extern int vlan_output(struct ifnet *, struct mbuf *, struct sockaddr *,
    struct rtentry *);
#endif

d2733 3
a2735 12
	if (ifp->if_output == vlan_output) {
		struct ifvlan	*ifv = ifp->if_softc;
		struct ifnet	*p = ifv->ifv_p;

		/* should we use the tx tagging hw offload at all? */
		if ((p->if_capabilities & IFCAP_VLAN_HWTAGGING) &&
		    (ifv->ifv_type == ETHERTYPE_VLAN)) {
			m->m_pkthdr.ether_vtag = ifv->ifv_tag +
			    (m->m_pkthdr.pf.prio << EVL_PRIO_BITS);
			m->m_flags |= M_VLANTAG;
		} else {
			struct ether_vlan_header evh;
d2737 9
a2745 13
			m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&evh);
			evh.evl_proto = evh.evl_encap_proto;
			evh.evl_encap_proto = htons(ifv->ifv_type);
			evh.evl_tag = htons(ifv->ifv_tag +
			    (m->m_pkthdr.pf.prio << EVL_PRIO_BITS));
			m_adj(m, ETHER_HDR_LEN);
			M_PREPEND(m, sizeof(evh), M_DONTWAIT);
			if (m == NULL) {
				sc->sc_if.if_oerrors++;
				return (ENOBUFS);
			}
			m_copyback(m, 0, sizeof(evh), &evh, M_NOWAIT);
			m->m_flags &= ~M_VLANTAG;
d2747 2
@


1.225
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.224 2014/07/09 09:30:49 henning Exp $	*/
a59 1
#include <netinet/in_systm.h>
@


1.224
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.222 2014/04/14 09:06:42 mpi Exp $	*/
d198 1
a198 1
		free(sc, M_DEVBUF);
d251 1
a251 1
		free(bif, M_DEVBUF);
d261 1
a261 1
	free(sc, M_DEVBUF);
d279 1
a279 1
	free(p, M_DEVBUF);
d447 1
a447 1
				free(p, M_DEVBUF);
d820 1
a820 1
		free(breq, M_DEVBUF);
d1889 1
a1889 1
				free(n, M_DEVBUF);
d1948 1
a1948 1
				free(n, M_DEVBUF);
d1970 1
a1970 1
			free(p, M_DEVBUF);
d2007 1
a2007 1
			free(n, M_DEVBUF);
d2186 1
a2186 1
		free(p, M_DEVBUF);
d2194 1
a2194 1
		free(p, M_DEVBUF);
@


1.223
log
@kill altq bits here as well
@
text
@d1333 1
a1333 1
		    ETHER_HDR_LEN, m, BPF_DIRECTION_IN);
d1444 2
a1445 4
				bpf_mtap_hdr(ifl->ifp->if_bpf,
				    (caddr_t)eh,
				    ETHER_HDR_LEN, m,
				    BPF_DIRECTION_IN);
@


1.222
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.221 2014/01/24 18:54:58 henning Exp $	*/
a1035 3
#ifdef ALTQ
			if (ALTQ_IS_ENABLED(&dst_if->if_snd) == 0)
#endif
a1523 3
#ifdef ALTQ
		if (ALTQ_IS_ENABLED(&dst_if->if_snd) == 0)
#endif
a1669 3
#ifdef ALTQ
		if (ALTQ_IS_ENABLED(&ifp->if_snd) == 0)
#endif
@


1.221
log
@clearing the _CSUM_IN_OK flags is now utterly pointless, was only done for
statistics sideeffects before. ok lteo naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.218 2013/10/17 16:27:40 bluhm Exp $	*/
d1397 1
a1397 1
				m->m_pkthdr.rdomain = ifl->ifp->if_rdomain;
d1460 1
a1460 1
			m->m_pkthdr.rdomain = ifl->ifp->if_rdomain;
d1635 1
a1635 1
	m1->m_pkthdr.rdomain = ifp->if_rdomain;
@


1.220
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d2493 1
a2493 3
		} else
			/* XXXHB20140123 */
			m->m_pkthdr.csum_flags &= ~M_IPV4_CSUM_IN_OK;
@


1.219
log
@Do not use the multicast macro IFP_TO_IA() to check if an interface has
a configured IPv4 address but iterates on its private list instead.

ok deraadt@@
@
text
@a2483 1
				ipstat.ips_inhwcsum++;
d2488 1
d2493 2
a2494 1
		} else {
a2495 2
			ipstat.ips_inhwcsum++;
		}
d2532 1
a2532 1
		if (0 && (ifp->if_capabilities & IFCAP_CSUM_IPv4)) {
d2534 2
a2535 2
			ipstat.ips_outhwcsum++;
		} else
d2537 1
@


1.218
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.217 2013/10/13 12:09:53 reyk Exp $	*/
a60 1
#include <netinet/in_var.h>
d1618 6
a1623 3
		struct in_ifaddr *ia;
		IFP_TO_IA(ifp, ia);
		if (!ia)
@


1.217
log
@Just use sockaddr_union instead of a handcrafted version and rename
bridge_tunnelupdate to a more generic name bridge_copyaddr.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.216 2013/10/13 10:10:02 reyk Exp $	*/
d74 1
@


1.216
log
@Import vxlan(4), the virtual extensible local area network tunnel
interface.  VXLAN is a UDP-based tunnelling protocol for overlaying
virtualized layer 2 networks over layer 3 networks. The implementation
is based on draft-mahalingam-dutt-dcops-vxlan-04 and has been tested
with other implementations in the wild.

put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.215 2013/10/12 11:55:45 henning Exp $	*/
d164 1
a164 1
void	bridge_tunnelupdate(struct sockaddr *, struct sockaddr *);
d1723 1
a1723 1
		bridge_tunnelupdate(sa, (struct sockaddr *)&p->brt_tunnel);
d1750 1
a1750 1
			bridge_tunnelupdate(sa,
d1766 1
a1766 1
			bridge_tunnelupdate(sa,
d1789 1
a1789 1
			bridge_tunnelupdate(sa,
d2046 2
a2047 6
				if (n->brt_tunnel.sa.sa_family != AF_UNSPEC)
					bcopy(&n->brt_tunnel.sa,
					    &bareq.ifba_dstsa,
					    n->brt_tunnel.sa.sa_len);
				else
					bareq.ifba_dstsa.ss_family = AF_UNSPEC;
d2908 1
a2908 1
bridge_tunnelupdate(struct sockaddr *sa, struct sockaddr *tunnel)
d2910 2
a2911 2
	if (sa != NULL && sa->sa_family != AF_UNSPEC)
		memcpy(tunnel, sa, sa->sa_len);
d2913 1
a2913 1
		tunnel->sa_family = AF_UNSPEC;
@


1.215
log
@give tagname2tag and its siblings an extra "create" parameter. if 1, it
behaves like before and creates the mapping if needed. if 0, lookup only.
looked over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.214 2013/08/21 13:53:48 mpi Exp $	*/
d134 3
a136 3
struct ifnet *	bridge_rtupdate(struct bridge_softc *,
    struct ether_addr *, struct ifnet *ifp, int, u_int8_t);
struct ifnet *	bridge_rtlookup(struct bridge_softc *,
d164 1
d554 1
a554 1
		    bareq->ifba_flags);
d732 1
a732 1
			bridge_rtupdate(sc, ea, ifp, 0, IFBAF_DYNAMIC);
d950 2
a951 1
	struct ifnet *dst_if;
d995 2
a996 1
	dst_if = bridge_rtlookup(sc, dst);
d1089 4
d1143 1
d1186 1
a1186 1
		bridge_rtupdate(sc, src, src_if, 0, IFBAF_DYNAMIC);
d1204 4
a1207 1
		dst_if = bridge_rtlookup(sc, dst);
d1436 1
a1436 1
				    ifp, 0, IFBAF_DYNAMIC);
d1699 1
a1699 1
    struct ifnet *ifp, int setflags, u_int8_t flags)
d1702 1
d1706 5
d1723 1
d1750 3
d1766 2
d1789 2
d1808 1
a1808 1
struct ifnet *
d1819 1
a1819 1
			return (p->brt_if);
d2046 6
d2857 62
@


1.214
log
@No need to include if_vlan_var.h twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.213 2013/08/05 11:18:03 mikeb Exp $	*/
d2140 1
a2140 1
		n->brl_tag = pf_tagname2tag(req->ifbr_tagname);
@


1.213
log
@sync the bridge_broadcast comment with reality
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.212 2013/07/31 15:41:51 mikeb Exp $	*/
a89 2

#include <net/if_vlan_var.h>
@


1.212
log
@Move bridge_broadcast and subsequently all IPsec SPD lookup code out
of the IPL_NET.  pf_test should be no longer called under IPL_NET as
well.  The problem became evident after the related issue was brought
up by David Hill <dhill at mindcry ! org>.

With input from and OK mpi.  Tested by David and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.211 2013/06/26 09:12:39 henning Exp $	*/
d1487 1
a1487 2
 * (except the one it came in on).  This code assumes that it is
 * running at splnet or higher.
@


1.211
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.210 2013/03/28 23:10:05 tedu Exp $	*/
a973 2
	s = splnet();

a1009 1
			splx(s);
d1076 1
d1078 1
a1083 1
		splx(s);
a1090 1
		splx(s);
d1093 1
a1253 1
		s = splnet();
a1254 1
		splx(s);
d1497 1
a1497 3
	int len, used = 0;

	splassert(IPL_NET);
d1586 1
d1588 1
d1644 1
a1644 1
	int error;
d1680 1
d1682 1
@


1.210
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.209 2013/03/28 16:55:27 deraadt Exp $	*/
a1015 9

		/* Catch packets that need TCP/UDP hardware checksumming */
		if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT ||
		    m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT) {
			m_freem(m);
			splx(s);
			return (0);
		}

d2347 6
d2505 1
d2551 1
@


1.209
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.208 2013/03/28 16:45:16 tedu Exp $	*/
d44 1
@


1.208
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.207 2013/03/26 13:19:25 mpi Exp $	*/
a46 1
#include <machine/cpu.h>
@


1.207
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.206 2013/03/15 20:45:34 tedu Exp $	*/
a40 1
#include <sys/proc.h>
@


1.206
log
@change LIST_END to literal NULL for clarity.
ok claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.205 2013/01/23 13:28:36 camield Exp $	*/
d222 1
a222 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.205
log
@
Change interface and span interface lists from LIST to TAILQ.

This way the configuration order is preserved.  Order matters
because MAC address are not unique: vlan interfaces can have
the same MAC as their parent.

Frames destined for the bridge itself are now delivered to
the first-configured interface that matches the MAC instead
of the last-configured.  This means that the bridge behavior
does not suddenly change anymore when adding a vlan interface.

ok henning reyk (a while ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.204 2012/12/22 13:20:32 camield Exp $	*/
d325 1
a325 1
		if (p != TAILQ_END(&sc->sc_spanlist)) {
d427 1
a427 1
		if (p != TAILQ_END(&sc->sc_spanlist)) {
d453 1
a453 1
		if (p == TAILQ_END(&sc->sc_spanlist)) {
d1056 1
a1056 1
			if (TAILQ_NEXT(p, next) == TAILQ_END(&sc->sc_iflist)) {
d1400 1
a1400 1
			if (ifl != TAILQ_END(&sc->sc_iflist)) {
d1555 1
a1555 1
		if (TAILQ_NEXT(p, next) == TAILQ_END(&sc->sc_iflist)) {
d1711 1
a1711 1
	if (p == LIST_END(&sc->sc_rts[h])) {
d1771 1
a1771 1
		if (p == LIST_END(&sc->sc_rts[h])) {
d1790 1
a1790 1
	} while (p != LIST_END(&sc->sc_rts[h]));
d1874 1
a1874 1
		while (n != LIST_END(&sc->sc_rts[i])) {
d1940 1
a1940 1
		while (n != LIST_END(&sc->sc_rts[i])) {
d1990 1
a1990 1
		while (n != LIST_END(&sc->sc_rts[i])) {
@


1.204
log
@Return EEXIST to 'add' when a port is already a bridge member.  This makes
reconfiguration with /etc/netstart silent again.  (noticed by deraadt)

And do the same for 'addspan'.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.203 2012/12/07 23:52:09 weerd Exp $	*/
d207 2
a208 2
	LIST_INIT(&sc->sc_iflist);
	LIST_INIT(&sc->sc_spanlist);
d249 1
a249 1
	while ((bif = LIST_FIRST(&sc->sc_iflist)) != NULL)
d251 2
a252 2
	while ((bif = LIST_FIRST(&sc->sc_spanlist)) != NULL) {
		LIST_REMOVE(bif, next);
d278 1
a278 1
	LIST_REMOVE(p, next);
d322 1
a322 1
		LIST_FOREACH(p, &sc->sc_spanlist, next)
d325 1
a325 2

		if (p != LIST_END(&sc->sc_spanlist)) {
d391 1
a391 1
		LIST_INSERT_HEAD(&sc->sc_iflist, p, next);
d423 1
a423 1
		LIST_FOREACH(p, &sc->sc_spanlist, next) {
d427 1
a427 1
		if (p != LIST_END(&sc->sc_spanlist)) {
d440 1
a440 1
		LIST_INSERT_HEAD(&sc->sc_spanlist, p, next);
d445 1
a445 1
		LIST_FOREACH(p, &sc->sc_spanlist, next) {
d448 1
a448 1
				LIST_REMOVE(p, next);
d453 1
a453 1
		if (p == LIST_END(&sc->sc_spanlist)) {
d749 1
a749 1
	LIST_FOREACH(p, &sc->sc_iflist, next)
d752 1
a752 1
	LIST_FOREACH(p, &sc->sc_spanlist, next)
d764 1
a764 1
	LIST_FOREACH(p, &sc->sc_iflist, next) {
d804 1
a804 1
	LIST_FOREACH(p, &sc->sc_spanlist, next) {
d1028 1
a1028 1
		LIST_FOREACH(p, &sc->sc_iflist, next) {
d1056 1
a1056 1
			if (LIST_NEXT(p, next) == LIST_END(&sc->sc_iflist)) {
d1396 1
a1396 1
			LIST_FOREACH(ifl, &sc->sc_iflist, next) {
d1400 1
a1400 1
			if (ifl != LIST_END(&sc->sc_iflist)) {
d1428 1
a1428 1
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
d1515 1
a1515 1
	LIST_FOREACH(p, &sc->sc_iflist, next) {
d1555 1
a1555 1
		if (LIST_NEXT(p, next) == LIST_END(&sc->sc_iflist)) {
d1660 1
a1660 1
	if (LIST_EMPTY(&sc->sc_spanlist))
d1673 1
a1673 1
	LIST_FOREACH(p, &sc->sc_spanlist, next) {
@


1.203
log
@Remove stray semicolon.  Fixes mbuf leak with devices sending BPDUs to
bridge(4) members that are not configured with stp.

Lots of debug help (and actual find) sthen@@

OK sthen@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.202 2012/11/06 12:32:41 henning Exp $	*/
d313 5
a317 1
			error = EBUSY;
d429 1
a429 1
			error = EBUSY;
@


1.202
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.201 2012/11/01 07:55:55 henning Exp $	*/
d1356 1
a1356 1
				    eh, m)) == NULL);
@


1.201
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.199 2012/10/08 18:48:25 camield Exp $	*/
a4 1
 * Copyright (c) 2003 - 2012 Henning Brauer <henning@@openbsd.org>
d1014 9
a2353 6
			else if (af == AF_INET)
				in_proto_cksum_out(m, encif);
#ifdef INET6
			else if (af == AF_INET6)
				in6_proto_cksum_out(m, encif);
#endif /* INET6 */
a2505 1
		in_proto_cksum_out(m, ifp);
a2550 1
		in6_proto_cksum_out(m, ifp);
@


1.200
log
@make bridge_rtflush and bridge_flushrule void functions, as they never
return anything but 0 anyways
From: "Michael W. Bombardieri" <mb at ii dot net>, ok camield
@
text
@d5 1
a1014 9

		/* Catch packets that need TCP/UDP hardware checksumming */
		if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT ||
		    m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT) {
			m_freem(m);
			splx(s);
			return (0);
		}

d2346 6
d2504 1
d2550 1
@


1.199
log
@Make carp_ourether() shorter and more generic.  Only a mac address
is really needed, instead of an ethernet header and selector.

ok mikeb henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.198 2012/10/06 18:44:47 camield Exp $	*/
d136 1
a136 1
int	bridge_rtflush(struct bridge_softc *, int);
d145 1
a145 1
int		bridge_flushrule(struct bridge_iflist *);
d536 1
a536 1
		error = bridge_rtflush(sc, req->ifbr_ifsflags);
d638 1
a638 1
		error = bridge_flushrule(p);
a733 1
	return;
d1929 1
a1929 1
int
a1948 2

	return (0);
d2168 1
a2168 1
int
a2188 1
	return (0);
@


1.198
log
@Remove bridge_rttrim().  It's only triggered in the unlikely event that the
routecache is full and the admin is making it smaller.  It then does a
lame attempt at shrinking the routecache, something that a flush or flushall
can do better.

ok henning beck
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.197 2012/10/05 17:17:04 camield Exp $	*/
d1433 1
a1433 1
			eh, 0) != NULL)
d1474 1
a1474 1
			eh, 1) != NULL)
@


1.197
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.196 2012/09/20 14:10:18 mpf Exp $	*/
a134 1
void	bridge_rttrim(struct bridge_softc *);
a568 1
		bridge_rttrim(sc);
a1847 40
}

/*
 * Trim the routing table so that we've got a number of routes
 * less than or equal to the maximum.
 */
void
bridge_rttrim(struct bridge_softc *sc)
{
	struct bridge_rtnode *n, *p;
	int i;

	/*
	 * Make sure we have to trim the address table
	 */
	if (sc->sc_brtcnt <= sc->sc_brtmax)
		return;

	/*
	 * Force an aging cycle, this might trim enough addresses.
	 */
	bridge_rtage(sc);

	if (sc->sc_brtcnt <= sc->sc_brtmax)
		return;

	for (i = 0; i < BRIDGE_RTABLE_SIZE; i++) {
		n = LIST_FIRST(&sc->sc_rts[i]);
		while (n != LIST_END(&sc->sc_rts[i])) {
			p = LIST_NEXT(n, brt_next);
			if ((n->brt_flags & IFBAF_TYPEMASK) == IFBAF_DYNAMIC) {
				LIST_REMOVE(n, brt_next);
				sc->sc_brtcnt--;
				free(n, M_DEVBUF);
				if (sc->sc_brtcnt <= sc->sc_brtmax)
					return;
			}
			n = p;
		}
	}
@


1.196
log
@Don't filter spanning tree BPDUs. Either process, or forward them.
Even though this violates IEEE 802.1D, we'd rather avoid bridging loops
by not getting in the way of STP.
OK henning, camield, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.195 2012/09/20 10:25:03 blambert Exp $	*/
d276 1
a276 1
	p->ifp->if_bridge = NULL;
d313 1
a313 5
		if (ifs->if_bridge == (caddr_t)sc) {
			error = EEXIST;
			break;
		}
		if (ifs->if_bridge != NULL) {
d383 1
d388 1
a388 1
		ifs->if_bridge = (caddr_t)sc;
d394 4
a397 7

		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (strncmp(p->ifp->if_xname, req->ifbr_ifsname,
			    sizeof(p->ifp->if_xname)) == 0) {
				error = bridge_delete(sc, p);
				break;
			}
d399 3
a401 2
		if (p == LIST_END(&sc->sc_iflist)) {
			error = ENOENT;
d404 1
d417 1
a417 5
		if (ifs->if_bridge == (caddr_t)sc) {
			error = EEXIST;
			break;
		}
		if (ifs->if_bridge != NULL) {
d462 2
a463 9
		if ((caddr_t)sc != ifs->if_bridge) {
			error = ESRCH;
			break;
		}
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p == LIST_END(&sc->sc_iflist)) {
d503 2
a504 9
		if ((caddr_t)sc != ifs->if_bridge) {
			error = ESRCH;
			break;
		}
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p == LIST_END(&sc->sc_iflist)) {
a541 1

d547 2
a548 3

		if (ifs->if_bridge == NULL ||
		    ifs->if_bridge != (caddr_t)sc) {
d605 2
a606 10
		if (ifs->if_bridge == NULL ||
		    ifs->if_bridge != (caddr_t)sc) {
			error = ESRCH;
			break;
		}
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p == LIST_END(&sc->sc_iflist)) {
d635 2
a636 10
		if (ifs->if_bridge == NULL ||
		    ifs->if_bridge != (caddr_t)sc) {
			error = ESRCH;
			break;
		}
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p == LIST_END(&sc->sc_iflist)) {
d694 1
a694 1
	struct bridge_softc *sc = (struct bridge_softc *)ifp->if_bridge;
d697 4
a700 5
	LIST_FOREACH(bif, &sc->sc_iflist, next)
		if (bif->ifp == ifp) {
			bridge_delete(sc, bif);
			break;
		}
d706 1
a706 1
	struct bridge_softc *sc = (struct bridge_softc *)ifp->if_bridge;
d712 15
a726 14
	LIST_FOREACH(bif, &sc->sc_iflist, next)
		if (bif->ifp == ifp) {
			/*
			 * Update the bridge interface if it is in
			 * the learning state.
			 */
			if ((bif->bif_flags & IFBIF_LEARNING) &&
			    (ETHER_IS_MULTICAST(addr) == 0) &&
			    !(addr[0] == 0 && addr[1] == 0 && addr[2] == 0 &&
			    addr[3] == 0 && addr[4] == 0 && addr[5] == 0)) {
				/* Care must be taken with spanning tree */
				if ((bif->bif_flags & IFBIF_STP) &&
				    (bif->bif_state == BSTP_IFSTATE_DISCARDING))
					return;
d728 2
a729 2
				/* Delete the address from the bridge */
				bridge_rtdaddr(sc, ea);
d731 3
a733 7
				if (!delete) {
					/* Update the bridge table */
					bridge_rtupdate(sc, ea, ifp, 0,
					    IFBAF_DYNAMIC);
				}
			}
			return;
d735 2
d840 2
a841 7
	if (ifp->if_bridge == NULL || ifp->if_bridge != (caddr_t)sc)
		return (ESRCH);
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp == ifp)
			break;
	}
	if (ifl == LIST_END(&sc->sc_iflist))
d961 1
a961 2
	sc = (struct bridge_softc *)ifp->if_bridge;
	if (sc == NULL) {
d965 1
d1163 2
a1164 5
	LIST_FOREACH(ifl, &sc->sc_iflist, next)
		if (ifl->ifp == src_if)
			break;

	if (ifl == LIST_END(&sc->sc_iflist)) {
d1280 1
a1280 8
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp == dst_if)
			break;
	}
	if (ifl == LIST_END(&sc->sc_iflist)) {
		m_freem(m);
		return;
	}
d1325 1
a1325 1
	if (ifp == NULL || ifp->if_bridge == NULL || m == NULL)
d1333 2
a1334 1
	sc = (struct bridge_softc *)ifp->if_bridge;
a1337 7
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp == ifp)
			break;
	}
	if (ifl == LIST_END(&sc->sc_iflist))
		return (m);

d1940 1
a1940 1
	struct bridge_softc *sc = (struct bridge_softc *)ifp->if_bridge;
d1944 1
@


1.195
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.194 2012/07/16 18:05:36 markus Exp $	*/
d1421 3
a1423 2
				bstp_input(sc->sc_stp, ifl->bif_stp, eh, m);
				return (NULL);
@


1.194
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.193 2011/07/04 06:54:49 claudio Exp $	*/
d2398 1
a2398 1
		s = spltdb();
@


1.193
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.192 2011/05/16 20:06:28 henning Exp $	*/
d2445 1
a2445 1
		    IPSP_DIRECTION_OUT, NULL, NULL);
@


1.192
log
@bring back r1.189, but keep doing the ip csum unconditionally for now until
the broadcast shortcut codepath is fixed. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.190 2011/04/05 18:01:21 henning Exp $	*/
d2452 6
a2457 23
			switch (af) {
#ifdef INET
			case AF_INET:
				if ((encif = enc_getif(tdb->tdb_rdomain,
				    tdb->tdb_tap)) == NULL ||
				    pf_test(dir, encif,
				    &m, NULL) != PF_PASS) {
					m_freem(m);
					return (1);
				}
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				if ((encif = enc_getif(tdb->tdb_rdomain,
				    tdb->tdb_tap)) == NULL ||
				    pf_test6(dir, encif,
				    &m, NULL) != PF_PASS) {
					m_freem(m);
					return (1);
				}
				break;
#endif /* INET6 */
d2602 1
a2602 1
		if (pf_test(dir, ifp, &m, eh) != PF_PASS)
d2653 1
a2653 1
		if (pf_test6(dir, ifp, &m, eh) != PF_PASS)
@


1.191
log
@Revert Rev. 1.189. The delayed ip checksum calculation causes problems
with broadcast packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.188 2010/11/04 23:07:15 weerd Exp $	*/
a70 1

d150 1
a150 2
#if NPF > 0
struct mbuf *bridge_filter(struct bridge_softc *, int, struct ifnet *,
a151 1
#endif
a1001 1
	struct arpcom *ac;
d1066 1
a1066 2
		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT ||
		    m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT ||
a1072 20
		/* check if packet is for local interface */
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp->if_type != IFT_ETHER)
				continue;
			ac = (struct arpcom *)p->ifp;
			dst_if = p->ifp;
			if (bcmp(ac->ac_enaddr, eh->ether_dhost,
			    ETHER_ADDR_LEN) == 0
#if NCARP > 0
			    || (dst_if->if_carp &&
			        carp_ourether(dst_if->if_carp, eh, 0) != NULL)
#endif
			    ) {
				bridge_localbroadcast(sc, dst_if, eh, m);
				m_freem(m);
				splx(s);
				return (0);
			}
		}

a1135 4
			/* bounce packets into alternate rdomains */
			if (ifp->if_rdomain != dst_if->if_rdomain)
				bridge_localbroadcast(sc, dst_if, eh, m);

d1307 1
a1307 2
#if NPF > 0
	m = bridge_filter(sc, BRIDGE_IN, src_if, &eh, m);
a1309 1
#endif
d1347 1
a1347 2
#if NPF > 0
	m = bridge_filter(sc, BRIDGE_OUT, dst_if, &eh, m);
a1349 1
#endif
d1500 4
a1508 4
			if (srcifl->bif_flags & IFBIF_LEARNING)
				bridge_rtupdate(sc,
				    (struct ether_addr *)&eh->ether_shost,
				    ifp, 0, IFBAF_DYNAMIC);
d1651 1
a1651 2
#if NPF > 0
		mc = bridge_filter(sc, BRIDGE_OUT, dst_if, eh, mc);
a1653 1
#endif
a2498 1
#if NPF > 0
d2506 1
a2506 1
bridge_filter(struct bridge_softc *sc, int dir, struct ifnet *ifp,
d2582 14
a2595 3
		if ((ip->ip_sum = in_cksum(m, hlen)) != 0) {
			ipstat.ips_badsum++;
			goto dropit;
d2617 1
a2617 1

d2623 1
d2632 5
a2636 1
		ip->ip_sum = in_cksum(m, hlen);
d2669 1
d2674 1
a2705 1
#endif /* NPF > 0 */
@


1.190
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.189 2011/04/04 13:55:54 henning Exp $	*/
d71 1
d151 2
a152 1
struct mbuf *bridge_ip(struct bridge_softc *, int, struct ifnet *,
d154 1
d1005 1
d1070 2
a1071 1
		if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT ||
d1078 20
d1161 4
d1336 2
a1337 1
	m = bridge_ip(sc, BRIDGE_IN, src_if, &eh, m);
d1340 1
d1378 2
a1379 1
	m = bridge_ip(sc, BRIDGE_OUT, dst_if, &eh, m);
d1382 1
a1532 4
			if (srcifl->bif_flags & IFBIF_LEARNING)
				bridge_rtupdate(sc,
				    (struct ether_addr *)&eh->ether_shost,
				    ifp, 0, IFBAF_DYNAMIC);
d1538 4
d1684 2
a1685 1
		mc = bridge_ip(sc, BRIDGE_OUT, dst_if, eh, mc);
d1688 1
d2534 1
d2542 1
a2542 1
bridge_ip(struct bridge_softc *sc, int dir, struct ifnet *ifp,
d2618 3
a2620 14
		if ((m->m_pkthdr.csum_flags & M_IPV4_CSUM_IN_OK) == 0) {
			if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_IN_BAD) {
				ipstat.ips_inhwcsum++;
				ipstat.ips_badsum++;
				goto dropit;
			}

			if (in_cksum(m, hlen) != 0) {
				ipstat.ips_badsum++;
				goto dropit;
			}
		} else {
			m->m_pkthdr.csum_flags &= ~M_IPV4_CSUM_IN_OK;
			ipstat.ips_inhwcsum++;
d2642 1
a2642 1
#if NPF > 0
a2647 1
#endif /* NPF > 0 */
d2656 1
a2656 5
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4)) {
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_OUT;
			ipstat.ips_outhwcsum++;
		} else
			ip->ip_sum = in_cksum(m, hlen);
a2688 1
#if NPF > 0
a2692 1
#endif /* NPF > 0 */
d2724 1
@


1.189
log
@all I wanted is to make the bridge behave like the real stack wrt the ip
chekcsum. turned out is always recalculates it as long as your kernel does
have pf compiled in, as in, always, since compilation of GENERIC without
pf explodes in about a hundred ways.
so rename bridge_filter -> bridge_ip and always compile it, pf or not,
just make the pf_test calls #if NPF, and sync the ip fuckery code with
ip_output. as a bonus this lets us use the checksum offloading to the NIC
if it is capable of that.
ok claudio dlg sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.188 2010/11/04 23:07:15 weerd Exp $	*/
d1066 2
a1067 2
		if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT ||
		    m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT) {
@


1.188
log
@Filter out reserved destination MAC addresses (01:80:C2:00:00:0x) as
per the 802.1D-2004 spec.  With lots of help and guidance (and some
nagging) from claudio.  Tested with net/ladvd port on i386 and amd64.

'be a man' claudio@@, ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.187 2010/10/31 15:14:30 mpf Exp $	*/
a70 1

d150 1
a150 2
#if NPF > 0
struct mbuf *bridge_filter(struct bridge_softc *, int, struct ifnet *,
a151 1
#endif
d1065 2
a1066 3
		/* Catch packets that need TCP/UDP/IP hardware checksumming */
		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT ||
		    m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT ||
d1307 1
a1307 2
#if NPF > 0
	m = bridge_filter(sc, BRIDGE_IN, src_if, &eh, m);
a1309 1
#endif
d1347 1
a1347 2
#if NPF > 0
	m = bridge_filter(sc, BRIDGE_OUT, dst_if, &eh, m);
a1349 1
#endif
d1651 1
a1651 2
#if NPF > 0
		mc = bridge_filter(sc, BRIDGE_OUT, dst_if, eh, mc);
a1653 1
#endif
a2498 1
#if NPF > 0
d2506 1
a2506 1
bridge_filter(struct bridge_softc *sc, int dir, struct ifnet *ifp,
d2582 14
a2595 3
		if ((ip->ip_sum = in_cksum(m, hlen)) != 0) {
			ipstat.ips_badsum++;
			goto dropit;
d2617 1
a2617 1

d2623 1
d2632 5
a2636 1
		ip->ip_sum = in_cksum(m, hlen);
d2669 1
d2674 1
a2705 1
#endif /* NPF > 0 */
@


1.187
log
@Remove unused bstp_list and bstp_attach.
OK blambert, claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.186 2010/10/28 19:00:57 mpf Exp $	*/
d1418 17
a1434 4
		/* Tap off 802.1D packets, they do not get forwarded */
		if (bcmp(eh->ether_dhost, bstp_etheraddr, ETHER_ADDR_LEN) == 0) {
			bstp_input(sc->sc_stp, ifl->bif_stp, eh, m);
			return (NULL);
@


1.186
log
@Fix a 'bstp still active' panic that happens if a stp enabled
interface is destroyed while in the bridge.  Fixed by using
bridge_delete() which includes the missing bstp_delete() call: Less
code and more consistency.  Also fix SIOCBRDGDEL to return an error
if an interface can not be found.
OK claudio, markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.185 2010/10/28 13:49:54 claudio Exp $	*/
a188 1
	bstp_attach(n);
@


1.185
log
@A function that only returns NULL should return void.
bstp_input() always consumes the packet so remove the mbuf handling
dance around it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.184 2010/09/28 08:13:11 blambert Exp $	*/
a405 1
				p = NULL;
d409 1
a409 1
		if (p != NULL && p == LIST_END(&sc->sc_iflist)) {
d743 1
a743 5
			LIST_REMOVE(bif, next);
			bridge_rtdelete(sc, ifp, 0);
			bridge_flushrule(bif);
			free(bif, M_DEVBUF);
			ifp->if_bridge = NULL;
@


1.184
log
@replace hand-rolled infinite loop with LIST_FOREACH

ok claudio@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.183 2010/09/24 15:22:29 blambert Exp $	*/
d1426 2
a1427 3
			m = bstp_input(sc->sc_stp, ifl->bif_stp, eh, m);
			if (m == NULL)
				return (NULL);
@


1.183
log
@avoid potential infinite loop

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.182 2010/07/09 16:58:06 reyk Exp $	*/
d2021 1
a2021 2
			n = LIST_FIRST(&sc->sc_rts[i]);
			while (n != LIST_END(&sc->sc_rts[i])) {
@


1.182
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.181 2010/07/02 02:40:16 blambert Exp $	*/
a1949 1
				n = p;
d1953 1
@


1.181
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.180 2010/07/01 02:09:45 reyk Exp $	*/
d2405 1
a2405 1
		tdb = gettdb(spi, &dst, proto);
d2460 1
a2460 1
				if ((encif = enc_getif(0,
d2471 1
a2471 1
				if ((encif = enc_getif(0,
@


1.180
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.179 2010/06/29 21:28:37 reyk Exp $	*/
d2848 1
a2848 1
		m_copyback(m, 0, sizeof(evh), &evh);
@


1.179
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.178 2010/06/03 16:15:00 naddy Exp $	*/
d2460 2
a2461 1
				if ((encif = enc_getif(0)) == NULL ||
d2471 2
a2472 1
				if ((encif = enc_getif(0)) == NULL ||
@


1.178
log
@Add support for 802.1ad-style QinQ nested VLANs.

QinQ-compliant svlan (service VLAN) interfaces are implemented as
a new cloner type, use Ethernet type 0x88a8, and have a dedicated
VLAN tag hash to avoid ID conflicts.  vlan(4) interfaces can be
stacked on top of svlan(4).

Originally from reyk@@, input from claudio@@ and deraadt@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.177 2010/01/13 05:25:06 claudio Exp $	*/
d2322 3
d2460 2
a2461 1
				if (pf_test(dir, &encif[0].sc_if,
d2470 2
a2471 1
				if (pf_test6(dir, &encif[0].sc_if,
@


1.177
log
@Preliminary rdomain support in bridge(4). Make sure that m->m_pkthdr.rdomain
is set whenever we changing the rcvif. It is still not possible to pass traffic
between two vether but works now form outside.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.176 2009/11/22 12:33:25 deraadt Exp $	*/
d2707 2
a2708 1
	if ((m->m_flags & M_VLANTAG) || etype == ETHERTYPE_VLAN) {
@


1.176
log
@Add a lot of bpf and counter manipulation to the bridge.  The bridge
sneaks packets on and off network interfaces in some cases without
calling the interrupt, start, or output functions, and thus must do
these tasks which the drivers cannot do.  The gif and vether are
rather special.  Someone should re-check gre.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.175 2009/11/09 03:16:05 deraadt Exp $	*/
d1466 1
d1529 1
a1701 2
	m_adj(m1, ETHER_HDR_LEN);

d1704 3
d1709 1
a1709 1
		bpf_mtap(ifp->if_bpf, m,
d1712 2
a1713 2
	m1->m_flags |= M_PROTO1;
	ether_input(ifp, eh, m1);
a2606 1
		m->m_pkthdr.rcvif = ifp;
@


1.175
log
@vether(4) is a virtual ethernet device driver which can be used
so that a bridge-etherip-tunnel host can join into the bridge itself.
It is ridiculous that this capability was missing from our network
stack portfolio, considering we have bgp and ospf daemons...
discussed at length with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.174 2009/01/06 21:23:18 claudio Exp $	*/
d1043 7
a1216 5
#if NBPFILTER > 0
	if (sc->sc_if.if_bpf)
		bpf_mtap(sc->sc_if.if_bpf, m, BPF_DIRECTION_IN);
#endif

d1415 6
d1465 6
a1471 1
				m->m_pkthdr.rcvif = ifl->ifp;
d1473 1
d1510 17
d1703 6
a1709 1
	m1->m_pkthdr.rcvif = ifp;
d1711 1
a2805 3
#if VETHER > 0
	extern void vetherstart(struct ifnet *);
#endif
d2811 1
a2811 6
	if (ifp->if_type == IFT_GIF)
		m->m_flags |= M_PROTO1;
#endif
#if VETHER > 0
	/* Indicate packets which are outbound */
	if (ifp->if_start == vetherstart)
d2813 5
@


1.174
log
@Send broadcast and multicast traffic not only out on all bridge interfaces but
also up into the network stack on all interfaces. Multicast addresses are
bound to interfaces and without this local sockets did not see packets that
entered the bridge on a different interface. This should help IPv6.
OK naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.173 2008/10/16 19:12:51 naddy Exp $	*/
d2769 3
d2778 5
@


1.173
log
@* Allow ether_input() and vlan_input() to handle incoming packets
  where the tag is stored in the mbuf header.
* Make bridge(4) handle interfaces with and without hardware tag
  support and forward packets inbetween.

Help and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.172 2008/09/10 14:01:23 blambert Exp $	*/
d125 2
d1583 2
d1641 34
@


1.172
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.171 2008/09/02 17:35:16 chl Exp $	*/
d38 1
d99 4
d1362 5
d1540 1
a1540 1
	int len = m->m_pkthdr.len, used = 0;
d1622 6
d2095 5
d2436 5
d2629 14
a2642 8
	if (etype == ETHERTYPE_VLAN &&
	    (ifp->if_capabilities & IFCAP_VLAN_MTU) &&
	    ((m->m_pkthdr.len - sizeof(struct ether_vlan_header)) <=
	    ifp->if_mtu)) {
		s = splnet();
		bridge_ifenqueue(sc, ifp, m);
		splx(s);
		return;
d2644 1
d2738 23
@


1.171
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.170 2008/06/14 21:46:22 reyk Exp $	*/
d604 1
a604 1
			timeout_add(&sc->sc_brtimeout, sc->sc_brttimeout * hz);
d968 1
a968 1
		timeout_add(&sc->sc_brtimeout, sc->sc_brttimeout * hz);
d1906 1
a1906 1
		timeout_add(&sc->sc_brtimeout, sc->sc_brttimeout * hz);
@


1.170
log
@add carppeer; an option to specify a different multicast address or
even the unicast address of the remote carp peer. this especially
helps when the multicast carp advertisements are causing problems in
the network (some crappy switches don't do well with multicast), there
are conflicts with VRRP, or the policy of the network does not allow
multicast (most Internet eXchange points didn't allow carped OpenBGP
routers because of the multicast advertisements).

discussed with many
ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.169 2008/05/21 21:12:07 mk Exp $	*/
d1002 1
a1002 1
	struct ether_addr *src, *dst;
a1022 1
	src = (struct ether_addr *)&eh->ether_shost[0];
d2592 1
a2592 1
	int s, len, error = 0;
a2672 1
			len = m->m_pkthdr.len;
@


1.169
log
@Only cancel (timeout_del()) the timeout if we're not going to delay it
(timeout_add()) anyway.

ok brad claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.168 2008/05/07 13:45:35 dlg Exp $	*/
d1473 1
a1473 1
			eh, IFT_ETHER, 0) != NULL)
d1496 1
a1496 1
			eh, IFT_ETHER, 1) != NULL)
@


1.168
log
@enable tx mitigation when putting packets on the wire by switching from
calls to ifp->if_start to if_start(). these are the obviously right cases
where we can do that, the less obvious ones may follow as theyre figured
out.

deraadt@@ said to go for it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.165 2007/09/15 16:43:51 henning Exp $	*/
a602 1
		timeout_del(&sc->sc_brtimeout);
d605 2
@


1.167
log
@the softnet intr handlers check if the input queue has packets on
it by reading the queues head pointer. if that pointer is not null
then it takes splnet and dequeues a packet for handling. this is
bad because the ifqueue head is modified at splnet and the sofnet
handlers read it without holding splnet.

this removes that check of the head pointer and simply checks if
the dequeue gave us a packet or not before proceeding.

found while reading mpls code.
discussed with norby@@ and henning@@

ok mcbride@@ henning@@
@
text
@d2719 1
a2719 2
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
@


1.166
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1173 1
a1173 1
		while (sc->sc_if.if_snd.ifq_head) {
@


1.165
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.164 2007/05/28 17:16:39 henning Exp $	*/
d716 1
a716 1
		error = EINVAL;
@


1.164
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.163 2007/05/28 06:31:01 mcbride Exp $	*/
d192 1
a192 1
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
a194 1
	bzero(sc, sizeof(*sc));
d376 1
a376 2
		p = (struct bridge_iflist *)malloc(
		    sizeof(struct bridge_iflist), M_DEVBUF, M_NOWAIT);
a382 1
		bzero(p, sizeof(struct bridge_iflist));
d435 1
a435 2
		p = (struct bridge_iflist *)malloc(
		    sizeof(struct bridge_iflist), M_DEVBUF, M_NOWAIT);
a439 1
		bzero(p, sizeof(struct bridge_iflist));
d1686 1
a1686 2
		p = (struct bridge_rtnode *)malloc(
		    sizeof(struct bridge_rtnode), M_DEVBUF, M_NOWAIT);
d1725 1
a1725 2
			p = (struct bridge_rtnode *)malloc(
			    sizeof(struct bridge_rtnode), M_DEVBUF, M_NOWAIT);
d1746 1
a1746 2
			p = (struct bridge_rtnode *)malloc(
			    sizeof(struct bridge_rtnode), M_DEVBUF, M_NOWAIT);
d2155 1
a2155 1
	n = (struct brl_node *)malloc(sizeof(struct brl_node), M_DEVBUF, M_NOWAIT);
@


1.163
log
@Users of arc4random() should include dev/rndvar.h directly.

ok dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.162 2007/05/26 17:13:30 jason Exp $	*/
d2153 1
a2153 1
	pf_tag_packet(m, NULL, n->brl_tag, -1);
@


1.162
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.161 2007/05/21 13:33:35 markus Exp $	*/
d54 3
@


1.161
log
@make bridge(4) mark packets with M_PROTO1 if gif(4) needs to use
etherip encapsulation; unbreaks remote ipsec bridges; ok claudio;
additional testing Renaud Allard
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.160 2007/05/16 20:27:58 michele Exp $	*/
a109 2

extern int ifqmaxlen;
@


1.160
log
@fix return values in bridge_output.

OK claudio@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.159 2007/05/15 20:14:48 claudio Exp $	*/
d2709 5
@


1.159
log
@Update the ifp of bridge cache entries if the entry is not static. This
makes carp(4) fail-over work over bridge(4). OK michele@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.158 2007/04/10 17:47:55 miod Exp $	*/
d1016 1
a1016 1
		return (0);
d1022 1
a1022 1
			return (0);
d1151 1
a1151 1
		return (0);
@


1.158
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.157 2007/01/08 13:52:38 michele Exp $	*/
d1718 2
a1719 1
			}
@


1.157
log
@discard packet and return if ifp is not a member of the bridge
this fix PR 5056

discussed with camield@@

OK camield@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.156 2006/12/28 20:06:11 deraadt Exp $	*/
d1240 1
a1240 1
	 * is not broadcast or multicast, record it's address.
@


1.156
log
@check if ifqueue has anything queued before doing the dance of
splnet/IF_DEQUEUE/splx; ok various people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.155 2006/12/11 22:11:48 reyk Exp $	*/
d1012 7
a1026 1
	sc = (struct bridge_softc *)ifp->if_bridge;
@


1.155
log
@refer to the RSTP point to point option as "PTP" instead of "P2P".
P2P is commonly used in relation to peer to peer networks, PTP is used
in various protocols for layer 2 point to point links (ie., full
duplex ethernet links).

note that the newly added brconfig commands [-]p2p and [-]autop2p will
change to [-]ptp and [-]autoptp.

suggested by Andrew Thompson (thompsa@@freebsd.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.154 2006/12/03 13:41:19 reyk Exp $	*/
d1171 1
a1171 1
		for (;;) {
@


1.154
log
@Add Rapid Spanning Tree Protocol support (802.1d-2004) based on work
by Andrew Thompson (thompsa@@freebsd.org). The local changes include
adoption to our bridge code, reduced stack usage and many other bits.
If stp is enabled, RSTP will now be used by default.

Thanks for help from Andrew.

This code has been in snaps for while now, commit encouraged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.153 2006/11/30 13:25:03 henning Exp $	*/
d506 4
a509 4
			if (bp->bp_p2p_link)
				req->ifbr_ifsflags |= IFBIF_BSTP_P2P;
			if (bp->bp_flags & BSTP_PORT_AUTOP2P)
				req->ifbr_ifsflags |= IFBIF_BSTP_AUTOP2P;
d839 4
a842 4
			if (bp->bp_p2p_link)
				breq->ifbr_ifsflags |= IFBIF_BSTP_P2P;
			if (bp->bp_flags & BSTP_PORT_AUTOP2P)
				breq->ifbr_ifsflags |= IFBIF_BSTP_AUTOP2P;
@


1.153
log
@no need for #if NPF > 0 inside #if NPF > 0
From: Genadijus Paleckis <lsd@@nnt.lt>
but the really bad description of the diff made this way more complicated
then needed. pls plz, when sending in diffs, describe properly what they
do and why!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.152 2006/07/06 15:50:59 henning Exp $	*/
a103 9
/* spanning tree defaults */
#define	BSTP_DEFAULT_MAX_AGE		(20 * 256)
#define	BSTP_DEFAULT_HELLO_TIME		(2 * 256)
#define	BSTP_DEFAULT_FORWARD_DELAY	(15 * 256)
#define	BSTP_DEFAULT_HOLD_TIME		(1 * 256)
#define	BSTP_DEFAULT_BRIDGE_PRIORITY	0x8000
#define	BSTP_DEFAULT_PORT_PRIORITY	0x80
#define	BSTP_DEFAULT_PATH_COST		55

d162 1
d181 1
d196 6
a203 5
	sc->sc_bridge_max_age = BSTP_DEFAULT_MAX_AGE;
	sc->sc_bridge_hello_time = BSTP_DEFAULT_HELLO_TIME;
	sc->sc_bridge_forward_delay= BSTP_DEFAULT_FORWARD_DELAY;
	sc->sc_bridge_priority = BSTP_DEFAULT_BRIDGE_PRIORITY;
	sc->sc_hold_time = BSTP_DEFAULT_HOLD_TIME;
d211 1
a211 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name, 
a218 1
	ifp->if_snd.ifq_maxlen = ifqmaxlen;
d220 3
d225 1
d230 1
d247 2
a248 8
	while ((bif = LIST_FIRST(&sc->sc_iflist)) != NULL) {
		/* XXX shared with ioctl and detach */
		/* XXX promisc disable? */
		LIST_REMOVE(bif, next);
		bridge_flushrule(bif);
		bif->ifp->if_bridge = NULL;
		free(bif, M_DEVBUF);
	}
d258 1
d266 19
a286 2
	struct proc *prc = curproc;		/* XXX */
	struct ifnet *ifs;
a288 1
	struct ifbaconf *baconf = (struct ifbaconf *)data;
a290 1
	struct ifbifconf *bifconf = (struct ifbifconf *)data;
d292 5
a296 2
	struct ifbrlconf *brlconf = (struct ifbrlconf *)data;
	struct ifreq ifreq;
a297 1
	struct bridge_iflist *p;
d302 1
a302 1
		if ((error = suser(prc, 0)) != 0)
d331 2
d376 1
a376 1
		p = (struct bridge_iflist *) malloc(
a387 2
		p->bif_priority = BSTP_DEFAULT_PORT_PRIORITY;
		p->bif_path_cost = BSTP_DEFAULT_PATH_COST;
d390 1
a391 1
		ifs->if_bridge = (caddr_t)sc;
d394 1
a394 1
		if ((error = suser(prc, 0)) != 0)
d400 2
a401 8
				p->ifp->if_bridge = NULL;

				error = ifpromisc(p->ifp, 0);

				LIST_REMOVE(p, next);
				bridge_rtdelete(sc, p->ifp, 0);
				bridge_flushrule(p);
				free(p, M_DEVBUF);
d405 1
a405 1
		if (p == LIST_END(&sc->sc_iflist)) {
d411 1
a411 1
		error = bridge_bifconf(sc, bifconf);
d414 1
a414 1
		if ((error = suser(prc, 0)) != 0)
d445 1
d451 1
a451 1
		if ((error = suser(prc, 0)) != 0)
d485 26
a510 4
		req->ifbr_state = p->bif_state;
		req->ifbr_priority = p->bif_priority;
		req->ifbr_path_cost = p->bif_path_cost;
		req->ifbr_portno = p->ifp->if_index & 0xff;
d513 1
a513 1
		if ((error = suser(prc, 0)) != 0)
d536 15
a550 4
		if ((req->ifbr_ifsflags & IFBIF_STP) &&
		    (ifs->if_type != IFT_ETHER)) {
			error = EINVAL;
			break;
a553 30
	case SIOCBRDGSIFPRIO:
	case SIOCBRDGSIFCOST:
		if ((error = suser(prc, 0)) != 0)
			break;
		ifs = ifunit(req->ifbr_ifsname);
		if (ifs == NULL) {
			error = ENOENT;
			break;
		}
		if ((caddr_t)sc != ifs->if_bridge) {
			error = ESRCH;
			break;
		}
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p == LIST_END(&sc->sc_iflist)) {
			error = ESRCH;
			break;
		}
		if (cmd == SIOCBRDGSIFPRIO)
			p->bif_priority = req->ifbr_priority;
		else {
			if (req->ifbr_path_cost < 1)
				error = EINVAL;
			else
				p->bif_path_cost = req->ifbr_path_cost;
		}
		break;
d555 1
a555 1
		error = bridge_rtfind(sc, baconf);
d558 1
a558 1
		if ((error = suser(prc, 0)) != 0)
d564 1
a564 1
		if ((error = suser(prc, 0)) != 0)
d585 1
a585 1
		if ((error = suser(prc, 0)) != 0)
d593 1
a593 1
		if ((error = suser(prc, 0)) != 0)
d599 1
a599 1
		if ((error = suser(prc, 0)) != 0)
d623 1
a623 1
		if ((error = suser(prc, 0)) != 0)
d661 1
a661 1
		if ((error = suser(prc, 0)) != 0)
d684 19
a702 1
		error = bridge_brlconf(sc, brlconf);
d713 5
a717 1
		error = suser(prc, 0);
d721 1
d770 1
a770 3
				    (bif->bif_state == BSTP_IFSTATE_BLOCKING ||
				    bif->bif_state == BSTP_IFSTATE_LISTENING ||
				    bif->bif_state == BSTP_IFSTATE_DISABLED))
d790 2
d794 1
a794 1
	struct ifbreq breq;
d807 4
d812 2
a813 2
		bzero(&breq, sizeof breq);
		if (bifc->ifbic_len < sizeof(breq))
d815 31
a845 9
		strlcpy(breq.ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(breq.ifbr_ifsname, p->ifp->if_xname, IFNAMSIZ);
		breq.ifbr_ifsflags = p->bif_flags;
		breq.ifbr_state = p->bif_state;
		breq.ifbr_priority = p->bif_priority;
		breq.ifbr_path_cost = p->bif_path_cost;
		breq.ifbr_portno = p->ifp->if_index & 0xff;
		error = copyout((caddr_t)&breq,
		    (caddr_t)(bifc->ifbic_req + i), sizeof(breq));
d849 1
a849 1
		bifc->ifbic_len -= sizeof(breq);
d852 2
a853 2
		bzero(&breq, sizeof breq);
		if (bifc->ifbic_len < sizeof(breq))
d855 6
a860 9
		strlcpy(breq.ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(breq.ifbr_ifsname, p->ifp->if_xname, IFNAMSIZ);
		breq.ifbr_ifsflags = p->bif_flags | IFBIF_SPAN;
		breq.ifbr_state = p->bif_state;
		breq.ifbr_priority = p->bif_priority;
		breq.ifbr_path_cost = p->bif_path_cost;
		breq.ifbr_portno = p->ifp->if_index & 0xff;
		error = copyout((caddr_t)&breq,
		    (caddr_t)(bifc->ifbic_req + i), sizeof(breq));
d864 1
a864 1
		bifc->ifbic_len -= sizeof(breq);
d868 3
a870 1
	bifc->ifbic_len = i * sizeof(breq);
d968 1
a968 1
	bstp_initialization(sc);
d1082 1
a1082 1
			    (p->bif_state != BSTP_IFSTATE_FORWARDING))
d1219 1
a1219 3
	    (ifl->bif_state == BSTP_IFSTATE_BLOCKING ||
	    ifl->bif_state == BSTP_IFSTATE_LISTENING ||
	    ifl->bif_state == BSTP_IFSTATE_DISABLED)) {
d1340 1
a1340 2
	    (ifl->bif_state == BSTP_IFSTATE_DISABLED ||
	    ifl->bif_state == BSTP_IFSTATE_BLOCKING)) {
d1404 1
a1404 1
			m = bstp_input(sc, ifp, eh, m);
d1410 1
a1410 2
		 * No need to queue frames for ifs in the blocking, disabled,
		 *  or listening state
d1413 1
a1413 3
		    ((ifl->bif_state == BSTP_IFSTATE_BLOCKING) ||
		    (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
		    (ifl->bif_state == BSTP_IFSTATE_DISABLED)))
d1453 1
a1453 2
	 * No need to queue frames for ifs in the blocking, disabled, or
	 * listening state
d1456 1
a1456 3
	    ((ifl->bif_state == BSTP_IFSTATE_BLOCKING) ||
	    (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
	    (ifl->bif_state == BSTP_IFSTATE_DISABLED)))
a1458 1

d1542 1
a1542 1
		    (p->bif_state != BSTP_IFSTATE_FORWARDING))
d1908 32
@


1.152
log
@argh, again i forgot a file. sorry
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.151 2006/03/25 22:41:47 djm Exp $	*/
a2423 1
#if NPF > 0
a2429 1
#endif /* NPF */
a2470 1
#if NPF > 0
a2474 1
#endif /* NPF */
@


1.151
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.150 2006/03/04 22:40:15 brad Exp $	*/
d2067 1
a2067 1
	pf_tag_packet(m, NULL, n->brl_tag);
@


1.150
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.149 2006/01/23 22:46:57 markus Exp $	*/
d1147 1
a1147 1
		bpf_mtap(sc->sc_if.if_bpf, m);
@


1.149
log
@support PMTU-Discovery for link2 ipsec bridges; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.148 2006/01/05 03:28:34 deraadt Exp $	*/
d966 1
a966 1
	s = splimp();
d1116 1
a1116 1
			s = splimp();
d1263 1
a1263 1
		s = splimp();
d1305 1
a1305 1
		s = splimp();
d1378 1
a1378 1
		s = splimp();
d1458 1
a1458 1
	s = splimp();
d2533 1
a2533 1
		s = splimp();
d2601 1
a2601 1
			s = splimp();
@


1.148
log
@bzero buffers after malloc, or clear string buffer before strlcpy'ing
into them, if you are gonna copy it out to userland
some ok dhartmei, some ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.147 2006/01/04 06:04:41 canacar Exp $	*/
d161 1
a161 1
    struct ether_header *, struct mbuf *, int, struct llc *, int, int);
d164 4
a167 1
int bridge_ipsec(int, int, int, struct mbuf *);
d2128 3
a2130 1
bridge_ipsec(int dir, int af, int hlen, struct mbuf *m)
d2300 11
a2310 1
			error = ipsp_process_packet(m, tdb, af, 0);
d2419 2
a2420 1
		    bridge_ipsec(dir, AF_INET, hlen, m))
d2468 2
a2469 1
		    bridge_ipsec(dir, AF_INET6, hlen, m))
d2571 1
a2571 1
		    ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG);
d2650 1
a2650 1
    int type, int code)
d2664 1
a2664 1
	m = icmp_do_error(n, type, code, 0, ifp->if_mtu);
@


1.147
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.146 2005/10/09 19:44:22 reyk Exp $	*/
d774 1
d792 1
d850 1
d873 1
@


1.146
log
@if the wireless hostap interface belongs to a bridge, learn the node's
address dynamically on this interface after successful association.
this could speed wireless roaming to openbsd accesspoints.

ok jason@@, jsg@@ can't see anything obectionable
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.145 2005/07/31 03:30:55 pascoe Exp $	*/
a262 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif  
@


1.145
log
@Change the API for icmp_do_error so that it takes the mtu directly, rather
than a pointer to struct ifnet containing it.

Saves a 448 byte stack allocation in ip_forward which previously faked up
a struct ifnet just for this purpose.

idea ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.144 2005/06/16 11:10:47 markus Exp $	*/
d715 39
@


1.145.2.1
log
@MFC:
Fix by deraadt@@

bzero buffers after malloc, or clear string buffer before strlcpy'ing
into them, if you are gonna copy it out to userland

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.145 2005/07/31 03:30:55 pascoe Exp $	*/
a737 1
		bzero(&breq, sizeof breq);
a754 1
		bzero(&breq, sizeof breq);
a811 1
		bzero(&req, sizeof req);
a833 1
		bzero(&req, sizeof req);
@


1.144
log
@no need for NVLAN; ok jason, brad, camiel
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.143 2005/04/25 17:55:51 brad Exp $	*/
d2607 1
a2607 1
	m = icmp_do_error(n, type, code, 0, ifp);
@


1.143
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.142 2005/04/25 01:34:27 brad Exp $	*/
a36 1
#include "vlan.h"
a88 1
#if NVLAN > 0
a89 1
#endif
a2471 1
#if NVLAN > 0
a2480 1
#endif
@


1.142
log
@Use ETHERTYPE_VLAN.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.141 2004/12/23 09:32:55 camield Exp $	*/
d963 3
a965 3
		if (m->m_pkthdr.csum & M_IPV4_CSUM_OUT ||
		    m->m_pkthdr.csum & M_TCPV4_CSUM_OUT ||
		    m->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
@


1.141
log
@Simplify hashtable (de)allocation by moving it into the clone functions.

ok mickey@@ henning@@, "looks good" markus@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.140 2004/12/19 03:25:36 mcbride Exp $	*/
d2476 1
a2476 1
	if (etype == ETHERTYPE_8021Q &&
@


1.141.2.1
log
@MFC:
Fix by deraadt@@

bzero buffers after malloc, or clear string buffer before strlcpy'ing
into them, if you are gonna copy it out to userland

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.141 2004/12/23 09:32:55 camield Exp $	*/
a740 1
		bzero(&breq, sizeof breq);
a757 1
		bzero(&breq, sizeof breq);
a814 1
		bzero(&req, sizeof req);
a836 1
		bzero(&req, sizeof req);
@


1.140
log
@Make it possible for carp to work on fddi and token ring again.

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.139 2004/12/17 12:42:02 pascoe Exp $	*/
a99 5
#ifndef	BRIDGE_RTABLE_SIZE
#define	BRIDGE_RTABLE_SIZE	1024
#endif
#define	BRIDGE_RTABLE_MASK	(BRIDGE_RTABLE_SIZE - 1)

d196 1
a196 1
	int s;
d213 3
d248 1
a252 1
		bridge_rtdelete(sc, bif->ifp, 0);
a866 1
	int i;
a870 11
	if (sc->sc_rts == NULL) {
		sc->sc_rts = (struct bridge_rthead *)malloc(
		    BRIDGE_RTABLE_SIZE * (sizeof(struct bridge_rthead)),
		    M_DEVBUF, M_NOWAIT);
		if (sc->sc_rts == NULL)
			return;
		for (i = 0; i < BRIDGE_RTABLE_SIZE; i++) {
			LIST_INIT(&sc->sc_rts[i]);
		}
		sc->sc_hashkey = arc4random();
	}
a1592 16
	if (sc->sc_rts == NULL) {
		if (setflags && flags == IFBAF_STATIC) {
			sc->sc_rts = (struct bridge_rthead *)malloc(
			    BRIDGE_RTABLE_SIZE *
			    (sizeof(struct bridge_rthead)),M_DEVBUF,M_NOWAIT);
			if (sc->sc_rts == NULL)
				goto done;

			for (h = 0; h < BRIDGE_RTABLE_SIZE; h++) {
				LIST_INIT(&sc->sc_rts[h]);
			}
			sc->sc_hashkey = arc4random();
		} else
			goto done;
	}

a1690 3
	if (sc->sc_rts == NULL)
		goto fail;

a1747 3
	if (sc->sc_rts == NULL)
		goto done;

d1752 1
a1752 1
		goto done;
d1760 1
a1760 1
		goto done;
d1772 1
a1772 1
					goto done;
a1775 7

done:
	if (sc->sc_rts != NULL && sc->sc_brtcnt == 0 &&
	    (sc->sc_if.if_flags & IFF_UP) == 0) {
		free(sc->sc_rts, M_DEVBUF);
		sc->sc_rts = NULL;
	}
a1797 3
	if (sc->sc_rts == NULL)
		return;

a1831 3
	if (sc->sc_rts == NULL)
		return (0);

a1846 5
	if (sc->sc_brtcnt == 0 && (sc->sc_if.if_flags & IFF_UP) == 0) {
		free(sc->sc_rts, M_DEVBUF);
		sc->sc_rts = NULL;
	}

a1858 3
	if (sc->sc_rts == NULL)
		return (ENOENT);

a1864 5
			if (sc->sc_brtcnt == 0 &&
			    (sc->sc_if.if_flags & IFF_UP) == 0) {
				free(sc->sc_rts, M_DEVBUF);
				sc->sc_rts = NULL;
			}
a1879 3
	if (sc->sc_rts == NULL)
		return;

a1904 4
	if (sc->sc_brtcnt == 0 && (sc->sc_if.if_flags & IFF_UP) == 0) {
		free(sc->sc_rts, M_DEVBUF);
		sc->sc_rts = NULL;
	}
a1916 3

	if (sc->sc_rts == NULL)
		goto done;
@


1.139
log
@Reorder code in the ethernet output path, and enhance unicast address
matching in the bridge receive path to make CARP operate correctly
on physical interfaces that are participating in a bridge.

ok mcbride@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.138 2004/10/09 19:55:28 brad Exp $	*/
d1398 1
a1398 1
			eh, 0) != NULL)
d1421 1
a1421 1
			eh, 1) != NULL)
@


1.138
log
@sizeof(struct ether_header) -> ETHER_HDR_LEN

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.137 2004/08/18 11:07:47 markus Exp $	*/
d38 1
d94 4
d1395 6
a1400 1
		if (bcmp(ac->ac_enaddr, eh->ether_dhost, ETHER_ADDR_LEN) == 0) {
d1418 6
a1423 1
		if (bcmp(ac->ac_enaddr, eh->ether_shost, ETHER_ADDR_LEN) == 0) {
@


1.137
log
@skip splx() for skiplookup; report Vafa D. Izadinia; ok henning, canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.136 2004/06/21 23:50:36 tholo Exp $	*/
d223 1
a223 1
	ifp->if_hdrlen = sizeof(struct ether_header);
d228 1
a228 1
	    DLT_EN10MB, sizeof(struct ether_header));
d1016 1
a1016 1
				m1 = m_copym2(m, 0, sizeof(struct ether_header),
d1022 1
a1022 1
				m2 = m_copym2(m, sizeof(struct ether_header),
d1143 1
a1143 1
	m_copydata(m, 0, sizeof(struct ether_header), (caddr_t)&eh);
d1271 1
a1271 1
	if ((len - sizeof(struct ether_header)) > dst_if->if_mtu)
d1343 1
a1343 1
		M_PREPEND(mc, sizeof(struct ether_header), M_DONTWAIT);
d1346 1
a1346 1
		bcopy(eh, mtod(mc, caddr_t), sizeof(struct ether_header));
d1413 1
a1413 1
	M_PREPEND(m, sizeof(struct ether_header), M_DONTWAIT);
d1416 1
a1416 1
	bcopy(eh, mtod(m, caddr_t), sizeof(struct ether_header));
d1489 1
a1489 1
			m1 = m_copym2(m, 0, sizeof(struct ether_header),
d1495 1
a1495 1
			m2 = m_copym2(m, sizeof(struct ether_header),
d1523 1
a1523 1
		if ((len - sizeof(struct ether_header)) > dst_if->if_mtu)
d1550 1
a1550 1
		M_PREPEND(m, sizeof(struct ether_header), M_DONTWAIT);
d1553 1
a1553 1
		bcopy(eh, mtod(m, caddr_t), sizeof(struct ether_header));
d2015 1
a2015 1
	if (m->m_pkthdr.len < sizeof(struct ether_header))
d2031 1
a2031 1
	    (sizeof(struct ether_header) + LLC_SNAPFRAMELEN))
d2034 1
a2034 1
	m_copydata(m, sizeof(struct ether_header), LLC_SNAPFRAMELEN,
d2347 1
a2347 1
		    sizeof(struct ether_header)))
d2350 1
a2350 1
		m_copydata(m, sizeof(struct ether_header),
d2367 1
a2367 1
	m_adj(m, sizeof(struct ether_header));
d2546 1
a2546 1
		    sizeof(struct ether_header)))
d2549 1
a2549 1
		m_copydata(m, sizeof(struct ether_header),
d2564 1
a2564 1
	m_adj(m, sizeof(struct ether_header));
@


1.136
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.135 2004/06/21 19:26:01 mcbride Exp $	*/
d2278 1
a2280 1
			splx(s);
@


1.135
log
@Get rid of pf_test_eh() wrapper.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.134 2004/05/04 18:03:58 canacar Exp $	*/
d2244 1
a2244 5
				int pri;

				pri = splhigh();
				tdb->tdb_first_use = time.tv_sec;
				splx(pri);
@


1.134
log
@Apply bridge filter rules to incoming packets destined to the local machine.
Allows tagging of the incoming packets, and a single interface bridge to
be actually useful for MAC level filtering/tagging.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.133 2004/05/04 16:59:32 grange Exp $	*/
d2300 1
a2300 1
				    &m) != PF_PASS) {
d2309 1
a2309 1
				    &m) != PF_PASS) {
d2435 1
a2435 1
		if (pf_test_eh(dir, ifp, &m, eh) != PF_PASS)
d2481 1
a2481 1
		if (pf_test6_eh(dir, ifp, &m, eh) != PF_PASS)
@


1.133
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.132 2004/04/28 02:51:58 cedric Exp $	*/
d1395 5
@


1.132
log
@make return-rst work on pure bridges. ok dhartmei@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.131 2004/02/10 20:20:01 itojun Exp $	*/
d2121 1
a2121 1
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlin, p, brl_next);
d2129 1
a2129 1
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlout, p, brl_next);
@


1.131
log
@plug mbuf leak (ip_fragment() always free mbuf on error).  tested by cedric,
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.130 2004/02/02 19:56:23 cedric Exp $	*/
d2430 1
a2430 1
		if (pf_test(dir, ifp, &m) != PF_PASS)
d2476 1
a2476 1
		if (pf_test6(dir, ifp, &m) != PF_PASS)
@


1.131.2.1
log
@MFC:
Fix by markus@@

skip splx() for skiplookup; report Vafa D. Izadinia

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.131 2004/02/10 20:20:01 itojun Exp $	*/
a2276 1
			splx(s);
d2279 1
@


1.130
log
@missing #if NPF > 0. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.129 2003/12/17 13:08:41 markus Exp $	*/
d2580 2
a2581 1
	if (error)
d2583 1
@


1.129
log
@start spanning tree on ifconfig up; from Marco Pfatschbacher; ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.128 2003/12/16 21:35:28 henning Exp $	*/
d2078 1
d2080 1
@


1.128
log
@when a bridge filter rule specifies both src and dst mac address, we do not
want to compare both against the packet's source address. works much
better when we compare the dst address to the packet's dst address.

ok camield@@ canacar@@ markus@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.127 2003/12/16 20:33:25 markus Exp $	*/
d881 1
@


1.127
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.126 2003/12/03 14:55:58 markus Exp $	*/
d2059 1
a2059 1
			if (bcmp(eh->ether_dhost, &n->brl_src, ETHER_ADDR_LEN))
@


1.126
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.125 2003/10/02 05:50:34 itojun Exp $	*/
d170 1
a170 1
void	bridge_clone_destroy(struct ifnet *ifp);
d237 1
a237 1
void
d269 1
@


1.125
log
@do not try to send incomplete fragments on ENOBUFS case
(behavior change from 4.4bsd).
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.124 2003/08/15 20:32:19 tedu Exp $	*/
a124 3
struct bridge_softc *bridgectl;
int nbridge;

d169 2
d178 6
d187 7
d196 1
a196 1
	int i;
d198 28
a225 29
	bridgectl = malloc(n * sizeof(*sc), M_DEVBUF, M_NOWAIT);
	if (!bridgectl)
		return;
	nbridge = n;
	bzero(bridgectl, n * sizeof(*sc));
	for (sc = bridgectl, i = 0; i < nbridge; i++, sc++) {

		sc->sc_brtmax = BRIDGE_RTABLE_MAX;
		sc->sc_brttimeout = BRIDGE_RTABLE_TIMEOUT;
		sc->sc_bridge_max_age = BSTP_DEFAULT_MAX_AGE;
		sc->sc_bridge_hello_time = BSTP_DEFAULT_HELLO_TIME;
		sc->sc_bridge_forward_delay= BSTP_DEFAULT_FORWARD_DELAY;
		sc->sc_bridge_priority = BSTP_DEFAULT_BRIDGE_PRIORITY;
		sc->sc_hold_time = BSTP_DEFAULT_HOLD_TIME;
		timeout_set(&sc->sc_brtimeout, bridge_timer, sc);
		LIST_INIT(&sc->sc_iflist);
		LIST_INIT(&sc->sc_spanlist);
		ifp = &sc->sc_if;
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "bridge%d", i);
		ifp->if_softc = sc;
		ifp->if_mtu = ETHERMTU;
		ifp->if_ioctl = bridge_ioctl;
		ifp->if_output = bridge_output;
		ifp->if_start = bridge_start;
		ifp->if_type = IFT_BRIDGE;
		ifp->if_snd.ifq_maxlen = ifqmaxlen;
		ifp->if_hdrlen = sizeof(struct ether_header);
		if_attach(ifp);
		if_alloc_sadl(ifp);
d227 2
a228 2
		bpfattach(&sc->sc_if.if_bpf, ifp,
		    DLT_EN10MB, sizeof(struct ether_header));
d230 27
d258 11
d1079 1
a1079 1
	int i, s;
d1081 1
a1081 2
	for (i = 0; i < nbridge; i++) {
		sc = &bridgectl[i];
@


1.124
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.123 2003/07/28 00:58:08 itojun Exp $	*/
d2528 1
a2528 1
	if (error == EMSGSIZE)
@


1.124.2.1
log
@MFC:
Fix by itojun@@

plug mbuf leak (ip_fragment() always free mbuf on error).

missing pieces from my previous commit.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.124 2003/08/15 20:32:19 tedu Exp $	*/
d2528 1
a2528 2
	if (error) {
		m = NULL;
a2529 1
	}
@


1.124.2.2
log
@MFC:
Fix by markus@@

skip splx() for skiplookup; report Vafa D. Izadinia

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.124.2.1 2004/03/14 00:13:42 brad Exp $	*/
a2224 1
			splx(s);
d2227 1
@


1.123
log
@typo.  from cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.122 2003/07/25 10:36:34 itojun Exp $	*/
d242 1
a242 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d334 1
a334 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d360 1
a360 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d396 1
a396 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d436 1
a436 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d468 1
a468 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d500 1
a500 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d506 1
a506 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d527 1
a527 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d535 1
a535 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d541 1
a541 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d565 1
a565 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d603 1
a603 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d637 1
a637 1
		error = suser(prc->p_ucred, &prc->p_acflag);
@


1.122
log
@do not flip ip_len/ip_off.  pechkin and henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.121 2003/06/30 19:09:25 henning Exp $	*/
d2637 1
a2637 1
	ip->ip_off &= ntohs(IP_DF);
@


1.121
log
@change that queue ID allocator so it always has the queues sorted by ID.
that allows us to get rid of the "tagid" global which stored the highest
tag ID in use.
when allocating a new ID scan the list for a free slot and only use
highest + 1 on failure instead of using highest + 1 from the beginning
scanning for a dup afterwards. this prevents ID space fragmentation better.

as a result this allows us do get rid of the pf_tag_purge() function
completely and let pf_tag_unref() remove an entry once the reference
counter reaches zero by itself.
after all it makes for easier code and is about 50% faster.

idea came up during a discussion on icb earlier today between cedric and
myself, which itself was particulary inspired by Darren Reed questioning the
need for pf_tag_purge on tech-net@@netbsd.

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.120 2003/06/30 10:51:09 henning Exp $	*/
a2261 8
#ifdef INET
			if (af == AF_INET) {
				ip = mtod(m, struct ip *);
				HTONS(ip->ip_len);
				HTONS(ip->ip_id);
				HTONS(ip->ip_off);
			}
#endif /* INET */
d2356 1
a2356 2
		NTOHS(ip->ip_len);
		if (ip->ip_len < hlen)
a2357 2
		NTOHS(ip->ip_id);
		NTOHS(ip->ip_off);
d2359 1
a2359 1
		if (m->m_pkthdr.len < ip->ip_len)
d2361 1
a2361 1
		if (m->m_pkthdr.len > ip->ip_len) {
d2363 2
a2364 2
				m->m_len = ip->ip_len;
				m->m_pkthdr.len = ip->ip_len;
d2366 1
a2366 1
				m_adj(m, ip->ip_len - m->m_pkthdr.len);
a2389 3
		HTONS(ip->ip_len);
		HTONS(ip->ip_id);
		HTONS(ip->ip_off);
a2518 2
	NTOHS(ip->ip_len);
	NTOHS(ip->ip_off);
d2521 1
a2521 1
	if (ip->ip_off & IP_DF) {
d2632 1
a2632 1
	icp->icmp_cksum = in_cksum(m, ip->ip_len - hlen);
d2637 1
a2637 1
	ip->ip_off &= IP_DF;
a2639 2
	HTONS(ip->ip_len);
	HTONS(ip->ip_off);
@


1.120
log
@missing pf_tag_purge()
cedric made me check
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.119 2003/06/25 09:41:18 henning Exp $	*/
a2082 3
#if NPF > 0
	pf_tag_purge();
#endif
@


1.119
log
@add a pf_tagname field to ifbrlreq and a pf_tag field to ifbrlnode.
on bridge rule load translate tagnames to pf tags using pf_tagname2tag etc
if packets match a bridge filter rule tag them using pf_tag_packet() with
the given tag
help dhartmei@@
ok deraadt@@ jason@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.118 2003/06/02 18:42:56 jason Exp $	*/
d2083 3
@


1.118
log
@nuke clause 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.117 2003/05/30 21:15:41 henning Exp $	*/
d156 2
a157 1
u_int8_t bridge_filterrule(struct brl_head *, struct ether_header *);
d770 5
d792 5
d1167 1
a1167 1
	if (bridge_filterrule(&ifl->bif_brlin, &eh) == BRL_ACTION_BLOCK) {
d1210 1
a1210 1
	if (bridge_filterrule(&ifl->bif_brlout, &eh) == BRL_ACTION_BLOCK) {
d1424 1
a1424 1
		if (bridge_filterrule(&p->bif_brlout, eh) == BRL_ACTION_BLOCK)
d1998 1
a1998 1
bridge_filterrule(struct brl_head *h, struct ether_header *eh)
d2006 1
a2006 1
			return (n->brl_action);
d2012 1
a2012 1
			return (n->brl_action);
d2017 1
a2017 1
			return (n->brl_action);
d2022 1
a2022 1
			return (n->brl_action);
d2026 4
d2044 6
d2070 3
d2078 3
@


1.117
log
@KNF & ANSI, jason agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.116 2003/05/30 20:08:34 henning Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.116
log
@o the timeout is int, not u_int32_t
o check timeout for negative values and overflow

ok tedu@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.115 2003/05/03 21:15:11 deraadt Exp $	*/
d184 1
a184 2
bridgeattach(n)
	int n;
d227 1
a227 4
bridge_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t	data;
d264 1
a264 1
		LIST_FOREACH(p, &sc->sc_spanlist, next) {
d267 1
a267 1
		}
d656 1
a656 2
bridge_ifdetach(ifp)
	struct ifnet *ifp;
d661 1
a661 1
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
a669 1
	}
d673 1
a673 3
bridge_bifconf(sc, bifc)
	struct bridge_softc *sc;
	struct ifbifconf *bifc;
d680 1
a680 1
	LIST_FOREACH(p, &sc->sc_iflist, next) {
d682 2
a683 2
	}
	LIST_FOREACH(p, &sc->sc_spanlist, next) {
d685 1
a685 1
	}
d732 1
a732 3
bridge_brlconf(sc, bc)
	struct bridge_softc *sc;
	struct ifbrlconf *bc;
d805 1
a805 2
bridge_init(sc)
	struct bridge_softc *sc;
d834 1
a834 2
bridge_stop(sc)
	struct bridge_softc *sc;
d856 2
a857 5
bridge_output(ifp, m, sa, rt)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr *sa;
	struct rtentry *rt;
d1012 1
a1012 2
bridge_start(ifp)
	struct ifnet *ifp;
d1043 1
a1043 3
bridgeintr_frame(sc, m)
	struct bridge_softc *sc;
	struct mbuf *m;
d1066 1
a1066 1
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
d1069 1
a1069 1
	}
d1229 1
a1229 4
bridge_input(ifp, eh, m)
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *m;
d1374 2
a1375 5
bridge_broadcast(sc, ifp, eh, m)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *m;
d1474 2
a1475 4
bridge_span(sc, eh, morig)
	struct bridge_softc *sc;
	struct ether_header *eh;
	struct mbuf *morig;
d1524 2
a1525 6
bridge_rtupdate(sc, ea, ifp, setflags, flags)
	struct bridge_softc *sc;
	struct ether_addr *ea;
	struct ifnet *ifp;
	int setflags;
	u_int8_t flags;
d1639 1
a1639 3
bridge_rtlookup(sc, ea)
	struct bridge_softc *sc;
	struct ether_addr *ea;
d1680 1
a1680 3
bridge_hash(sc, addr)
	struct bridge_softc *sc;
	struct ether_addr *addr;
d1700 1
a1700 2
bridge_rttrim(sc)
	struct bridge_softc *sc;
d1746 1
a1746 2
bridge_timer(vsc)
	void *vsc;
d1760 1
a1760 2
bridge_rtage(sc)
	struct bridge_softc *sc;
d1797 1
a1797 3
bridge_rtflush(sc, full)
	struct bridge_softc *sc;
	int full;
d1832 1
a1832 3
bridge_rtdaddr(sc, ea)
	struct bridge_softc *sc;
	struct ether_addr *ea;
d1861 1
a1861 4
bridge_rtdelete(sc, ifp, dynonly)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	int dynonly;
d1904 1
a1904 3
bridge_rtfind(sc, baconf)
	struct bridge_softc *sc;
	struct ifbaconf *baconf;
d1949 1
a1949 3
bridge_blocknonip(eh, m)
	struct ether_header *eh;
	struct mbuf *m;
d1992 1
a1992 3
bridge_filterrule(h, eh)
	struct brl_head *h;
	struct ether_header *eh;
d2023 1
a2023 4
bridge_addrule(bif, req, out)
	struct bridge_iflist *bif;
	struct ifbrlreq *req;
	int out;
d2047 1
a2047 2
bridge_flushrule(bif)
	struct bridge_iflist *bif;
d2066 1
a2066 3
bridge_ipsec(dir, af, hlen, m)
	int dir, af, hlen;
	struct mbuf *m;
d2266 2
a2267 6
bridge_filter(sc, dir, ifp, eh, m)
	struct bridge_softc *sc;
	int dir;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *m;
d2455 2
a2456 5
bridge_fragment(sc, ifp, eh, m)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *m;
d2567 1
a2567 4
bridge_ifenqueue(sc, ifp, m)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct mbuf *m;
d2592 3
a2594 9
bridge_send_icmp_err(sc, ifp, eh, n, hassnap, llc, type, code)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *n;
	int hassnap;
	struct llc *llc;
	int type;
	int code;
@


1.115
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.114 2003/03/31 22:59:47 millert Exp $	*/
d551 5
@


1.114
log
@Protect tdb access w/ spltdb; Patrick Latifi
Since bridgeintr_frame() is called at splsoftnet() this isn't a big
deal but should still be fixed.  jason@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.113 2003/03/11 16:06:25 markus Exp $	*/
d209 1
a209 1
		sprintf(ifp->if_xname, "bridge%d", i);
@


1.113
log
@forward 8021Q packets with vlan header if the destination interface has
IFCAP_VLAN_MTU capability.  allows forwarding of vlan traffic over
bridge(4) since these packets are larger then the mtu; ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.112 2003/02/21 21:49:37 jason Exp $	*/
d2124 1
a2124 1
	int error, off;
d2210 2
d2251 1
d2256 1
@


1.113.2.1
log
@MFC:
Fix by itojun@@

plug mbuf leak (ip_fragment() always free mbuf on error).

missing pieces from my previous commit.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.113 2003/03/11 16:06:25 markus Exp $	*/
d2576 1
a2576 2
	if (error) {
		m = NULL;
a2577 1
	}
@


1.112
log
@Plug two mbuf leak on error bugs, one from dhartmei one from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.111 2003/02/17 18:23:22 jason Exp $	*/
d42 1
d94 4
d2525 11
@


1.111
log
@enqueue the copy that was just made, not the original (probably fixes kernel/3097, waiting to hear).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.110 2003/02/16 21:30:13 deraadt Exp $	*/
d2651 2
a2652 1
	if (!n2)
d2654 1
d2656 2
a2657 1
	if (m == NULL)
d2659 1
@


1.110
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.109 2003/01/07 17:47:21 jason Exp $	*/
d1532 1
a1532 1
		error = bridge_ifenqueue(sc, ifp, m);
@


1.109
log
@apply the discover rule to bridge_output() as well
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.108 2003/01/07 09:00:33 kjc Exp $	*/
d1699 1
a1699 1
	} while(0)
d2525 1
a2525 1
		
d2528 1
a2528 1
		
d2537 1
a2537 1
		
d2540 1
a2540 1
	
d2593 1
a2593 1
	
d2596 1
a2596 1
	
d2598 1
a2598 1
#endif /* INET */	
d2632 1
a2632 1
void	
@


1.108
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.107 2003/01/03 15:57:56 jason Exp $	*/
d944 4
@


1.107
log
@Fix the unicast case call to bridge_rtupdate(), check that the -source-
interface is LEARNING not the destination.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.106 2002/12/09 22:32:01 jason Exp $	*/
a2607 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
d2611 1
a2611 5
#ifdef ALTQ
	if (ALTQ_IS_ENABLED(&ifp->if_snd))
		altq_etherclassify(&ifp->if_snd, m, &pktattr);
#endif
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
@


1.106
log
@NPF, not NFP (prevented outgoing bridge_ipsec() packets from being filtered); Darren Reed <avalon@@coombs.anu.edu.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.105 2002/12/09 10:11:52 markus Exp $	*/
d1240 1
a1240 1
	struct bridge_iflist *ifl;
d1336 1
d1342 1
a1342 1
			if (ifl->bif_flags & IFBIF_LEARNING)
@


1.105
log
@allow setting of ifcost with brconfig.  enables selection of preferred
port/path to root bridge among several LANs.   unlike ifpriority, which
allows you to select designated port if serveral interfaces belong
to the same LAN;  ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.104 2002/12/04 15:44:21 markus Exp $	*/
d2253 1
a2253 1
#if NFP > 0
@


1.104
log
@spanning tree: flush dynamic mac cache if interface goes to the
blocking or disabled state.  send packets only if interface is the
forwarding state; comment from netbsd; with and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.103 2002/10/10 17:27:40 dhartmei Exp $	*/
d435 1
d470 1
d490 8
a497 1
		p->bif_priority = req->ifbr_priority;
d697 1
d714 1
@


1.103
log
@Missing m_pullup() and mbuf corruption. This potentially caused

  panic: m_copym0: m == 0 and not COPYALL
    and/or
  panic: m_copydata: null muf

on bridges running pf with scrubbing enabled.

Bug report, test vector and confirmation by Jon Morby.
ok jason@@, jasoni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.102 2002/08/07 18:44:39 jason Exp $	*/
a143 1
void	bridge_rtdelete(struct bridge_softc *, struct ifnet *);
d348 1
a348 1
				bridge_rtdelete(sc, p->ifp);
d650 1
a650 1
			bridge_rtdelete(sc, ifp);
d923 12
d1392 1
a1392 2
		    (p->bif_state == BSTP_IFSTATE_BLOCKING ||
		    p->bif_state == BSTP_IFSTATE_DISABLED))
d1876 1
a1876 1
bridge_rtdelete(sc, ifp)
d1879 1
d1894 8
a1901 7
			if (n->brt_if == ifp) {		/* found one */
				p = LIST_NEXT(n, brt_next);
				LIST_REMOVE(n, brt_next);
				sc->sc_brtcnt--;
				free(n, M_DEVBUF);
				n = p;
			} else
d1903 7
d2549 1
a2549 1
		m->m_nextpkt = 0;
@


1.102
log
@consistently check byte order of ether_type; pointed out by dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.101 2002/07/02 23:36:16 mickey Exp $	*/
d2473 1
a2473 1
	struct mbuf *m0 = m;
d2510 3
d2528 1
a2528 1
	for (m = m0; m; m = m0) {
@


1.102.2.1
log
@Pull in patch from current:
Fix (dhartmei):
Missing m_pullup() and mbuf corruption. This potentially caused

panic: m_copym0: m == 0 and not COPYALL
and/or
panic: m_copydata: null muf

on bridges running pf with scrubbing enabled.

Bug report, test vector and confirmation by Jon Morby.
ok jason@@, jasoni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.102 2002/08/07 18:44:39 jason Exp $	*/
d2473 1
a2473 1
	struct mbuf *m0;
a2509 3
	if (m->m_len < sizeof(struct ip) &&
	    (m = m_pullup(m, sizeof(struct ip))) == NULL)
		goto dropit;
d2525 1
a2525 1
	for (; m; m = m0) {
@


1.101
log
@make it compile w/ ipsec and no pf ; smth that was left for homework
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.100 2002/07/01 22:24:44 jason Exp $	*/
d2289 1
a2289 1
		if (eh->ether_type > ETHERMTU ||
d2477 1
d2484 3
a2486 2
	if (eh->ether_type != htons(ETHERTYPE_IP)) {
		if (eh->ether_type > ETHERMTU ||
@


1.100
log
@Fix really long standing bug with fetching address cache entries:
handle ifbac_len == 0 as per the man page; Benny Holmgren <bigfoot@@astrakan.hig.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.99 2002/06/30 13:04:35 itojun Exp $	*/
d2265 1
a2265 1
#if NPF > 0 || defined(IPSEC)
@


1.99
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.98 2002/06/15 05:17:18 jason Exp $	*/
d1907 1
a1907 1
	int i, error = 0;
d1912 1
a1912 1
	if (sc->sc_rts == NULL || baconf->ifbac_len == 0)
d1915 3
d1920 17
a1936 14
			if (baconf->ifbac_len < sizeof(struct ifbareq))
				goto done;
			bcopy(sc->sc_if.if_xname, bareq.ifba_name,
			    sizeof(bareq.ifba_name));
			bcopy(n->brt_if->if_xname, bareq.ifba_ifsname,
			    sizeof(bareq.ifba_ifsname));
			bcopy(&n->brt_addr, &bareq.ifba_dst,
			    sizeof(bareq.ifba_dst));
			bareq.ifba_age = n->brt_age;
			bareq.ifba_flags = n->brt_flags;
			error = copyout((caddr_t)&bareq,
			    (caddr_t)(baconf->ifbac_req + cnt), sizeof(bareq));
			if (error)
				goto done;
a1937 1
			baconf->ifbac_len -= sizeof(struct ifbareq);
@


1.98
log
@unnecessary () on cast
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.97 2002/06/15 02:26:39 angelos Exp $	*/
d215 1
@


1.97
log
@Transparent IPsec processing on the bridge; for now works only with
static keys.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.96 2002/06/11 04:27:11 art Exp $	*/
d2107 1
a2107 1
			    (caddr_t)&(dst.sin.sin_addr));
d2142 1
a2142 1
			    (caddr_t)&(dst.sin6.sin6_addr));
@


1.96
log
@splassert(IPL_NET) where comment says that we should.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.95 2002/06/10 09:13:26 itojun Exp $	*/
d66 4
a70 1
#include <netinet/ip_icmp.h>
d169 3
d2067 193
a2259 1
#if NPF > 0
d2322 1
a2322 1
		
d2327 1
a2327 1
		
d2333 1
d2341 1
a2341 1
		
d2346 1
a2346 1
		
d2352 1
a2352 1
		
d2362 8
a2369 1
		
d2376 2
a2377 1
		
d2403 1
a2403 1
		
d2405 1
a2405 1
		
d2412 9
d2425 2
a2426 1
		
d2430 1
a2430 1
		
d2435 1
a2435 1
	
@


1.95
log
@prevent mbuf leak on icmp_do_error() failure.

NOTE: under 4.4BSD mbuf coding discipline, once you pass mbuf to a function
like f(m), you no longer have ownership of the mbuf.  the mbuf will always
be freed by the called function f().  by keeping the programming rule
you have less chance of memory leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.94 2002/06/09 20:30:45 jason Exp $	*/
d1361 2
@


1.94
log
@don't need device.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.93 2002/06/08 23:15:58 jasoni Exp $	*/
d2386 1
a2386 1
	struct mbuf *m;
d2390 3
d2396 2
@


1.93
log
@use consistent style in function declarations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.92 2002/06/08 23:04:53 jasoni Exp $	*/
a49 1
#include <sys/device.h>
@


1.92
log
@If a IP packet is too large for the outgoing interface and DF is set,
drop the packet and send a icmp needfrag.. blessed by jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.91 2002/06/07 18:29:43 jasoni Exp $	*/
d2242 5
a2246 2
bridge_fragment(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
d2341 4
a2344 1
bridge_ifenqueue(struct bridge_softc *sc, struct ifnet *ifp, struct mbuf *m)
@


1.91
log
@Move all duplicated enqueueing code into one function,
bridge_ifenqueu().
- ok jason@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.90 2002/05/31 20:58:25 itojun Exp $	*/
d68 1
d163 4
d2285 6
a2290 3
	/* Respect IP_DF */
	if (ip->ip_off & IP_DF)
		goto dropit;
d2365 74
@


1.90
log
@respect rmx_mtu (cached PMTUD result) on outbound.  deraadt/angelos ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.89 2002/05/28 15:46:24 jasoni Exp $	*/
d159 1
d161 1
a161 1
    struct altq_pktattr *, struct ether_header *, struct mbuf *);
a168 1

a847 2
	short mflags;
	ALTQ_DECL(struct altq_pktattr pktattr;)
d953 3
a955 9
			len = mc->m_pkthdr.len;
			mflags = mc->m_flags;
#ifdef ALTQ
			if (ALTQ_IS_ENABLED(&dst_if->if_snd))
				altq_etherclassify(&dst_if->if_snd, mc, &pktattr);
#endif
			IFQ_ENQUEUE(&dst_if->if_snd, mc, &pktattr, error);
			if (error) {
				sc->sc_if.if_oerrors++;
a956 8
			}
			sc->sc_if.if_opackets++;
			sc->sc_if.if_obytes += len;
			dst_if->if_obytes += len;
			if (mflags & M_MCAST)
				dst_if->if_omcasts++;
			if ((dst_if->if_flags & IFF_OACTIVE) == 0)
				(*dst_if->if_start)(dst_if);
d971 1
a971 19
	len = m->m_pkthdr.len;
	mflags = m->m_flags;
#ifdef ALTQ
	if (ALTQ_IS_ENABLED(&dst_if->if_snd))
		altq_etherclassify(&dst_if->if_snd, m, &pktattr);
#endif
	IFQ_ENQUEUE(&dst_if->if_snd, m, &pktattr, error);
	if (error) {
		sc->sc_if.if_oerrors++;
		splx(s);
		return (0);
	}
	sc->sc_if.if_opackets++;
	sc->sc_if.if_obytes += len;
	dst_if->if_obytes += len;
	if (mflags & M_MCAST)
		dst_if->if_omcasts++;
	if ((dst_if->if_flags & IFF_OACTIVE) == 0)
		(*dst_if->if_start)(dst_if);
d1016 1
a1016 1
	int s, error, len;
a1020 2
	short mflags;
	ALTQ_DECL(struct altq_pktattr pktattr;)
a1184 5
#ifdef ALTQ
	if (ALTQ_IS_ENABLED(&dst_if->if_snd))
		altq_etherclassify(&dst_if->if_snd, m, &pktattr);
#endif

d1187 1
a1187 1
		bridge_fragment(sc, dst_if, &pktattr, &eh, m);
a1188 1
		mflags = m->m_flags;
d1190 1
a1190 13
		IFQ_ENQUEUE(&dst_if->if_snd, m, &pktattr, error);
		if (error) {
			sc->sc_if.if_oerrors++;
			splx(s);
			return;
		}
		sc->sc_if.if_opackets++;
		sc->sc_if.if_obytes += len;
		dst_if->if_obytes += len;
		if (mflags & M_MCAST)
			dst_if->if_omcasts++;
		if ((dst_if->if_flags & IFF_OACTIVE) == 0)
			(*dst_if->if_start)(dst_if);
d1356 1
a1356 3
	int error, len = m->m_pkthdr.len, used = 0;
	short mflags = m->m_flags;
	ALTQ_DECL(struct altq_pktattr pktattr;)
a1436 4
#ifdef ALTQ
		if (ALTQ_IS_ENABLED(&dst_if->if_snd))
			altq_etherclassify(&dst_if->if_snd, mc, &pktattr);
#endif
d1438 1
a1438 1
			bridge_fragment(sc, dst_if, &pktattr, eh, mc);
d1440 1
a1440 12
			IFQ_ENQUEUE(&dst_if->if_snd, mc, &pktattr, error);
			if (error) {
				sc->sc_if.if_oerrors++;
				continue;
			}
			sc->sc_if.if_opackets++;
			sc->sc_if.if_obytes += len;
			dst_if->if_obytes += len;
			if (mflags & M_MCAST)
				dst_if->if_omcasts++;
			if ((dst_if->if_flags & IFF_OACTIVE) == 0)
				(*dst_if->if_start)(dst_if);
a1457 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
d1493 2
a1494 8
#ifdef ALTQ
		if (ALTQ_IS_ENABLED(&ifp->if_snd))
			altq_etherclassify(&ifp->if_snd, mc, &pktattr);
#endif

		IFQ_ENQUEUE(&ifp->if_snd, mc, &pktattr, error);
		if (error) {
			sc->sc_if.if_oerrors++;
a1495 8
		}
		sc->sc_if.if_opackets++;
		sc->sc_if.if_obytes += m->m_pkthdr.len;
		ifp->if_obytes += m->m_pkthdr.len;
		if (m->m_flags & M_MCAST)
			ifp->if_omcasts++;
		if ((ifp->if_flags & IFF_OACTIVE) == 0)
			(*ifp->if_start)(ifp);
d1915 1
a1915 1
		    	    (caddr_t)(baconf->ifbac_req + cnt), sizeof(bareq));
d2238 1
a2238 1
    struct altq_pktattr *pktattr, struct ether_header *eh, struct mbuf *m)
a2243 1
	short mflags = m->m_flags;
d2309 1
a2309 1
			IFQ_ENQUEUE(&ifp->if_snd, m, pktattr, error);
a2310 1
				sc->sc_if.if_oerrors++;
a2313 7
			sc->sc_if.if_opackets++;
			sc->sc_if.if_obytes += len;
			ifp->if_obytes += len;
			if (mflags & M_MCAST)
				ifp->if_omcasts++;
			if ((ifp->if_flags & IFF_OACTIVE) == 0)
				(*ifp->if_start)(ifp);
a2314 1
			
d2327 29
@


1.89
log
@refragment ip packets if too large for the outgoing interface
- ok jason@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.88 2002/04/08 17:49:42 jason Exp $	*/
d2371 1
a2371 1
	error = ip_fragment(m, ifp);
@


1.88
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.87 2002/03/18 10:31:25 jasoni Exp $	*/
d159 2
d1225 1
d1227 18
a1244 5
	mflags = m->m_flags;
	s = splimp();
	IFQ_ENQUEUE(&dst_if->if_snd, m, &pktattr, error);
	if (error) {
		sc->sc_if.if_oerrors++;
a1245 1
		return;
a1246 8
	sc->sc_if.if_opackets++;
	sc->sc_if.if_obytes += len;
	dst_if->if_obytes += len;
	if (mflags & M_MCAST)
		dst_if->if_omcasts++;
	if ((dst_if->if_flags & IFF_OACTIVE) == 0)
		(*dst_if->if_start)(dst_if);
	splx(s);
d1497 15
a1511 4
		IFQ_ENQUEUE(&dst_if->if_snd, mc, &pktattr, error);
		if (error) {
			sc->sc_if.if_oerrors++;
			continue;
a1512 7
		sc->sc_if.if_opackets++;
		sc->sc_if.if_obytes += len;
		dst_if->if_obytes += len;
		if (mflags & M_MCAST)
			dst_if->if_omcasts++;
		if ((dst_if->if_flags & IFF_OACTIVE) == 0)
			(*dst_if->if_start)(dst_if);
d2321 103
@


1.87
log
@filter ipv6 on the bridge.
- ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.86 2002/03/14 01:27:09 millert Exp $	*/
d32 5
@


1.86
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.85 2002/02/14 00:55:49 jason Exp $	*/
d67 5
d2144 1
d2146 3
a2148 1
	if (eh->ether_type != htons(ETHERTYPE_IP)) {
d2162 5
a2166 2
		    llc.llc_snap.org_code[2] ||
		    llc.llc_snap.ether_type != htons(ETHERTYPE_IP))
d2175 1
a2175 2
	if (m->m_pkthdr.len < sizeof(struct ip))
		goto dropit;
d2177 3
a2179 7
	/* Copy minimal header, and drop invalids */
	if (m->m_len < sizeof(struct ip) &&
	    (m = m_pullup(m, sizeof(struct ip))) == NULL) {
		ipstat.ips_toosmall++;
		return (NULL);
	}
	ip = mtod(m, struct ip *);
d2181 15
a2195 12
	if (ip->ip_v != IPVERSION) {
		ipstat.ips_badvers++;
		goto dropit;
	}

	hlen = ip->ip_hl << 2;	/* get whole header length */
	if (hlen < sizeof(struct ip)) {
		ipstat.ips_badhlen++;
		goto dropit;
	}
	if (hlen > m->m_len) {
		if ((m = m_pullup(m, hlen)) == NULL) {
d2197 40
d2238 2
a2239 1
		}
d2241 5
a2245 1
	}
d2247 1
a2247 4
	if ((ip->ip_sum = in_cksum(m, hlen)) != 0) {
		ipstat.ips_badsum++;
		goto dropit;
	}
d2249 19
a2267 5
	NTOHS(ip->ip_len);
	if (ip->ip_len < hlen)
		goto dropit;
	NTOHS(ip->ip_id);
	NTOHS(ip->ip_off);
d2269 10
a2278 1
	if (m->m_pkthdr.len < ip->ip_len)
d2280 1
a2280 6
	if (m->m_pkthdr.len > ip->ip_len) {
		if (m->m_len == m->m_pkthdr.len) {
			m->m_len = ip->ip_len;
			m->m_pkthdr.len = ip->ip_len;
		} else
			m_adj(m, ip->ip_len - m->m_pkthdr.len);
d2282 1
a2282 20

	/* Finally, we get to filter the packet! */
	m->m_pkthdr.rcvif = ifp;
	if (pf_test(dir, ifp, &m) != PF_PASS)
		goto dropit;
	if (m == NULL)
		goto dropit;

	/* Rebuild the IP header */
	if (m->m_len < hlen && ((m = m_pullup(m, hlen)) == NULL))
		return (NULL);
	if (m->m_len < sizeof(struct ip))
		goto dropit;
	ip = mtod(m, struct ip *);
	HTONS(ip->ip_len);
	HTONS(ip->ip_id);
	HTONS(ip->ip_off);
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, hlen);

@


1.85
log
@If helps to loop over the correct variable *sigh*
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.84 2002/02/07 23:50:20 jason Exp $	*/
d115 30
a144 30
void	bridgeattach __P((int));
int	bridge_ioctl __P((struct ifnet *, u_long, caddr_t));
void	bridge_start __P((struct ifnet *));
void	bridgeintr_frame __P((struct bridge_softc *, struct mbuf *));
void	bridge_broadcast __P((struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *));
void	bridge_span __P((struct bridge_softc *, struct ether_header *,
    struct mbuf *));
void	bridge_stop __P((struct bridge_softc *));
void	bridge_init __P((struct bridge_softc *));
int	bridge_bifconf __P((struct bridge_softc *, struct ifbifconf *));

void	bridge_timer __P((void *));
int	bridge_rtfind __P((struct bridge_softc *, struct ifbaconf *));
void	bridge_rtage __P((struct bridge_softc *));
void	bridge_rttrim __P((struct bridge_softc *));
void	bridge_rtdelete __P((struct bridge_softc *, struct ifnet *));
int	bridge_rtdaddr __P((struct bridge_softc *, struct ether_addr *));
int	bridge_rtflush __P((struct bridge_softc *, int));
struct ifnet *	bridge_rtupdate __P((struct bridge_softc *,
    struct ether_addr *, struct ifnet *ifp, int, u_int8_t));
struct ifnet *	bridge_rtlookup __P((struct bridge_softc *,
    struct ether_addr *));
u_int32_t	bridge_hash __P((struct bridge_softc *, struct ether_addr *));
int bridge_blocknonip __P((struct ether_header *, struct mbuf *));
int		bridge_addrule __P((struct bridge_iflist *,
    struct ifbrlreq *, int out));
int		bridge_flushrule __P((struct bridge_iflist *));
int	bridge_brlconf __P((struct bridge_softc *, struct ifbrlconf *));
u_int8_t bridge_filterrule __P((struct brl_head *, struct ether_header *));
d146 2
a147 2
struct mbuf *bridge_filter __P((struct bridge_softc *, int, struct ifnet *,
    struct ether_header *, struct mbuf *m));
@


1.84
log
@bridge_output() needs a forcibly aligned copy just like bridge_broadcast()
because of calls it makes to altq; thanks to art for testing and kjc for
pointing that I forgot this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.83 2002/01/02 20:06:03 jason Exp $	*/
d937 1
a937 1
					for (mx = m1; mx != NULL; mx = m->m_next)
d1512 1
a1512 1
	
@


1.83
log
@Don't forget to deallocate on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.82 2002/01/01 22:39:45 jason Exp $	*/
d915 12
a926 2
				mc = m_copym(m, 0, M_COPYALL, M_NOWAIT);
				if (mc == NULL) {
d930 12
@


1.82
log
@This is ugly: make a specialized deep copy in bridge_broadcast() that
ensures that the payload after the ethernet header is nicely aligned
(basically this is two copies, one for the ethernet header and one
for the payload) and glue the two copies together.  bridge_filter()
assumes it has been handed a nicely aligned packet.  This should
address pr#2248.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.81 2001/12/15 08:40:56 jason Exp $	*/
d1429 1
d1435 1
a1435 1
				;
@


1.81
log
@add support for creating span ports so that one can snoop a bridge
from another interface/machine/network.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.80 2001/12/13 04:59:53 jasoni Exp $	*/
d1418 11
a1428 2
			mc = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
			if (mc == NULL) {
d1432 13
@


1.81.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.83 2002/01/02 20:06:03 jason Exp $	*/
d1418 2
a1419 12
			struct mbuf *m1, *m2, *mx;

			m1 = m_copym2(m, 0, sizeof(struct ether_header),
			    M_DONTWAIT);
			if (m1 == NULL) {
				sc->sc_if.if_oerrors++;
				continue;
			}
			m2 = m_copym2(m, sizeof(struct ether_header),
			    M_COPYALL, M_DONTWAIT);
			if (m2 == NULL) {
				m_freem(m1);
a1422 13

			for (mx = m1; mx->m_next != NULL; mx = mx->m_next)
				/*EMPTY*/;
			mx->m_next = m2;

			if (m1->m_flags & M_PKTHDR) {
				int len = 0;

				for (mx = m1; mx != NULL; mx = mx->m_next)
					len += mx->m_len;
				m1->m_pkthdr.len = len;
			}
			mc = m1;
@


1.81.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.81.2.1 2002/01/31 22:55:43 niklas Exp $	*/
a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a62 1
#include <netinet/ip_icmp.h>
a66 5
#ifdef INET6
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

d115 30
a144 30
void	bridgeattach(int);
int	bridge_ioctl(struct ifnet *, u_long, caddr_t);
void	bridge_start(struct ifnet *);
void	bridgeintr_frame(struct bridge_softc *, struct mbuf *);
void	bridge_broadcast(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void	bridge_span(struct bridge_softc *, struct ether_header *,
    struct mbuf *);
void	bridge_stop(struct bridge_softc *);
void	bridge_init(struct bridge_softc *);
int	bridge_bifconf(struct bridge_softc *, struct ifbifconf *);

void	bridge_timer(void *);
int	bridge_rtfind(struct bridge_softc *, struct ifbaconf *);
void	bridge_rtage(struct bridge_softc *);
void	bridge_rttrim(struct bridge_softc *);
void	bridge_rtdelete(struct bridge_softc *, struct ifnet *);
int	bridge_rtdaddr(struct bridge_softc *, struct ether_addr *);
int	bridge_rtflush(struct bridge_softc *, int);
struct ifnet *	bridge_rtupdate(struct bridge_softc *,
    struct ether_addr *, struct ifnet *ifp, int, u_int8_t);
struct ifnet *	bridge_rtlookup(struct bridge_softc *,
    struct ether_addr *);
u_int32_t	bridge_hash(struct bridge_softc *, struct ether_addr *);
int bridge_blocknonip(struct ether_header *, struct mbuf *);
int		bridge_addrule(struct bridge_iflist *,
    struct ifbrlreq *, int out);
int		bridge_flushrule(struct bridge_iflist *);
int	bridge_brlconf(struct bridge_softc *, struct ifbrlconf *);
u_int8_t bridge_filterrule(struct brl_head *, struct ether_header *);
d146 2
a147 9
struct mbuf *bridge_filter(struct bridge_softc *, int, struct ifnet *,
    struct ether_header *, struct mbuf *m);
#endif
int	bridge_ifenqueue(struct bridge_softc *, struct ifnet *, struct mbuf *);
void	bridge_fragment(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
#ifdef INET
void	bridge_send_icmp_err(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *, int, struct llc *, int, int);
d156 1
d836 2
d915 2
a916 12
				struct mbuf *m1, *m2, *mx;

				m1 = m_copym2(m, 0, sizeof(struct ether_header),
				    M_DONTWAIT);
				if (m1 == NULL) {
					sc->sc_if.if_oerrors++;
					continue;
				}
				m2 = m_copym2(m, sizeof(struct ether_header),
				    M_COPYALL, M_DONTWAIT);
				if (m2 == NULL) {
					m_freem(m1);
a919 12

				for (mx = m1; mx->m_next != NULL; mx = mx->m_next)
					/*EMPTY*/;
				mx->m_next = m2;

				if (m1->m_flags & M_PKTHDR) {
					len = 0;
					for (mx = m1; mx != NULL; mx = mx->m_next)
						len += mx->m_len;
					m1->m_pkthdr.len = len;
				}
				mc = m1;
d921 9
a929 3

			error = bridge_ifenqueue(sc, dst_if, mc);
			if (error)
d931 8
d953 19
a971 1
	bridge_ifenqueue(sc, dst_if, m);
d1016 1
a1016 1
	int s, len;
d1021 2
d1187 4
d1192 5
a1196 5
	if ((len - sizeof(struct ether_header)) > dst_if->if_mtu)
		bridge_fragment(sc, dst_if, &eh, m);
	else {
		s = splimp();
		bridge_ifenqueue(sc, dst_if, m);
d1198 1
d1200 8
d1371 3
a1373 1
	int len = m->m_pkthdr.len, used = 0;
d1454 8
a1461 4
		if ((len - sizeof(struct ether_header)) > dst_if->if_mtu)
			bridge_fragment(sc, dst_if, eh, mc);
		else {
			bridge_ifenqueue(sc, dst_if, mc);
d1463 7
d1486 1
d1490 1
a1490 1

d1522 8
a1529 2
		error = bridge_ifenqueue(sc, ifp, m);
		if (error)
d1531 8
d1958 1
a1958 1
			    (caddr_t)(baconf->ifbac_req + cnt), sizeof(bareq));
a2116 1
	u_int16_t etype;
d2118 1
a2118 3
	etype = ntohs(eh->ether_type);

	if (etype != ETHERTYPE_IP && etype != ETHERTYPE_IPV6) {
d2132 2
a2133 5
		    llc.llc_snap.org_code[2])
			return (m);

		etype = ntohs(llc.llc_snap.ether_type);
		if (etype != ETHERTYPE_IP && etype != ETHERTYPE_IPV6)
d2142 10
a2151 1
	switch (etype) {
d2153 4
a2156 3
	case ETHERTYPE_IP:
		if (m->m_pkthdr.len < sizeof(struct ip))
			goto dropit;
d2158 8
a2165 4
		/* Copy minimal header, and drop invalids */
		if (m->m_len < sizeof(struct ip) &&
		    (m = m_pullup(m, sizeof(struct ip))) == NULL) {
			ipstat.ips_toosmall++;
a2168 101
		
		if (ip->ip_v != IPVERSION) {
			ipstat.ips_badvers++;
			goto dropit;
		}
		
		hlen = ip->ip_hl << 2;	/* get whole header length */
		if (hlen < sizeof(struct ip)) {
			ipstat.ips_badhlen++;
			goto dropit;
		}
		if (hlen > m->m_len) {
			if ((m = m_pullup(m, hlen)) == NULL) {
				ipstat.ips_badhlen++;
				return (NULL);
			}
			ip = mtod(m, struct ip *);
		}
		
		if ((ip->ip_sum = in_cksum(m, hlen)) != 0) {
			ipstat.ips_badsum++;
			goto dropit;
		}
		
		NTOHS(ip->ip_len);
		if (ip->ip_len < hlen)
			goto dropit;
		NTOHS(ip->ip_id);
		NTOHS(ip->ip_off);
		
		if (m->m_pkthdr.len < ip->ip_len)
			goto dropit;
		if (m->m_pkthdr.len > ip->ip_len) {
			if (m->m_len == m->m_pkthdr.len) {
				m->m_len = ip->ip_len;
				m->m_pkthdr.len = ip->ip_len;
			} else
				m_adj(m, ip->ip_len - m->m_pkthdr.len);
		}
		
		/* Finally, we get to filter the packet! */
		m->m_pkthdr.rcvif = ifp;
		if (pf_test(dir, ifp, &m) != PF_PASS)
			goto dropit;
		if (m == NULL)
			goto dropit;
		
		/* Rebuild the IP header */
		if (m->m_len < hlen && ((m = m_pullup(m, hlen)) == NULL))
			return (NULL);
		if (m->m_len < sizeof(struct ip))
			goto dropit;
		ip = mtod(m, struct ip *);
		HTONS(ip->ip_len);
		HTONS(ip->ip_id);
		HTONS(ip->ip_off);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, hlen);

		break;

#ifdef INET6
	case ETHERTYPE_IPV6: {
		struct ip6_hdr *ip6;

		if (m->m_len < sizeof(struct ip6_hdr)) {
			if ((m = m_pullup(m, sizeof(struct ip6_hdr)))
			    == NULL) {
				ip6stat.ip6s_toosmall++;
				return (NULL);
			}
		}
		
		ip6 = mtod(m, struct ip6_hdr *);
		
		if ((ip6->ip6_vfc & IPV6_VERSION_MASK) != IPV6_VERSION) {
			ip6stat.ip6s_badvers++;
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
			goto dropit;
		}

		if (pf_test6(dir, ifp, &m) != PF_PASS)
			goto dropit;
		if (m == NULL)
			return (NULL);
		
		break;
	}
#endif /* INET6 */
		
	default:
		goto dropit;
		break;
	}
	
	/* Reattach SNAP header */
	if (hassnap) {
		M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
		if (m == NULL)
			goto dropit;
		bcopy(&llc, mtod(m, caddr_t), LLC_SNAPFRAMELEN);
d2171 2
a2172 3
	/* Reattach ethernet header */
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
a2173 48
	bcopy(eh, mtod(m, caddr_t), sizeof(*eh));

	return (m);

dropit:
	if (m != NULL)
		m_freem(m);
	return (NULL);
}
#endif /* NPF > 0 */

void
bridge_fragment(sc, ifp, eh, m)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *m;
{
	struct llc llc;
	struct mbuf *m0 = m;
	int s, len, error = 0;
	int hassnap = 0;
#ifdef INET
	struct ip *ip;
#endif

#ifndef INET
	goto dropit;
#else
	if (eh->ether_type != htons(ETHERTYPE_IP)) {
		if (eh->ether_type > ETHERMTU ||
		    m->m_pkthdr.len < (LLC_SNAPFRAMELEN +
		    sizeof(struct ether_header)))
			goto dropit;
		
		m_copydata(m, sizeof(struct ether_header),
		    LLC_SNAPFRAMELEN, (caddr_t)&llc);
		
		if (llc.llc_dsap != LLC_SNAP_LSAP ||
		    llc.llc_ssap != LLC_SNAP_LSAP ||
		    llc.llc_control != LLC_UI ||
		    llc.llc_snap.org_code[0] ||
		    llc.llc_snap.org_code[1] ||
		    llc.llc_snap.org_code[2] ||
		    llc.llc_snap.ether_type != htons(ETHERTYPE_IP))
			goto dropit;
		
		hassnap = 1;
a2174 4
	
	m_adj(m, sizeof(struct ether_header));
	if (hassnap)
		m_adj(m, LLC_SNAPFRAMELEN);
a2175 1
	ip = mtod(m, struct ip *);
d2177 3
d2182 1
a2182 9
	/* Respect IP_DF, return a ICMP_UNREACH_NEEDFRAG. */
	if (ip->ip_off & IP_DF) {
		bridge_send_icmp_err(sc, ifp, eh, m, hassnap, &llc,
		    ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG);
		return;
	}

	error = ip_fragment(m, ifp, ifp->if_mtu);
	if (error == EMSGSIZE)
d2184 4
a2187 28

	for (m = m0; m; m = m0) {
		m0 = m->m_nextpkt;
		m->m_nextpkt = 0;
		if (error == 0) {
			if (hassnap) {
				M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
				if (m == NULL) {
					error = ENOBUFS;
					continue;
				}
				bcopy(&llc, mtod(m, caddr_t),
				    LLC_SNAPFRAMELEN);
			}
			M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
			if (m == NULL) {
				error = ENOBUFS;
				continue;
			}
			len = m->m_pkthdr.len;
			bcopy(eh, mtod(m, caddr_t), sizeof(*eh));
			s = splimp();
			error = bridge_ifenqueue(sc, ifp, m);
			if (error) {
				splx(s);
				continue;
			}
			splx(s);
d2189 1
a2189 1
			m_freem(m);
a2190 10
	
	if (error == 0)
		ipstat.ips_fragmented++;
	
	return;
#endif /* INET */	
 dropit:
	if (m != NULL)
		m_freem(m);
}
d2192 4
a2195 52
int
bridge_ifenqueue(sc, ifp, m)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct mbuf *m;
{
	int error, len;
	short mflags;
	ALTQ_DECL(struct altq_pktattr pktattr;)

	len = m->m_pkthdr.len;
	mflags = m->m_flags;
#ifdef ALTQ
	if (ALTQ_IS_ENABLED(&ifp->if_snd))
		altq_etherclassify(&ifp->if_snd, m, &pktattr);
#endif
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		sc->sc_if.if_oerrors++;
		return (error);
	}
	sc->sc_if.if_opackets++;
	sc->sc_if.if_obytes += len;
	ifp->if_obytes += len;
	if (mflags & M_MCAST)
		ifp->if_omcasts++;
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);

	return (0);
}

#ifdef INET
void	
bridge_send_icmp_err(sc, ifp, eh, n, hassnap, llc, type, code)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *n;
	int hassnap;
	struct llc *llc;
	int type;
	int code;
{
	struct ip *ip;
	struct icmp *icp;
	struct in_addr t;
	struct mbuf *m;
	int hlen;
	u_int8_t ether_tmp[ETHER_ADDR_LEN];

	m = icmp_do_error(n, type, code, 0, ifp);
d2197 1
a2197 1
		return;
d2199 5
a2204 17
	hlen = ip->ip_hl << 2;
	t = ip->ip_dst;
	ip->ip_dst = ip->ip_src;
	ip->ip_src = t;

	m->m_data += hlen;
	m->m_len -= hlen;
	icp = mtod(m, struct icmp *);
	icp->icmp_cksum = 0;
	icp->icmp_cksum = in_cksum(m, ip->ip_len - hlen);
	m->m_data -= hlen;
	m->m_len += hlen;

	ip->ip_v = IPVERSION;
	ip->ip_off &= IP_DF;
	ip->ip_id = htons(ip_randomid());
	ip->ip_ttl = MAXTTL;
d2206 1
a2210 5
	/* Swap ethernet addresses */
	bcopy(&eh->ether_dhost, &ether_tmp, sizeof(ether_tmp));
	bcopy(&eh->ether_shost, &eh->ether_dhost, sizeof(ether_tmp));
	bcopy(&ether_tmp, &eh->ether_shost, sizeof(ether_tmp));

d2216 1
a2216 1
		bcopy(llc, mtod(m, caddr_t), LLC_SNAPFRAMELEN);
d2225 1
a2225 3
	bridge_output(ifp, m, NULL, NULL);
	m_freem(n);
	return;
d2227 4
a2230 2
 dropit:
	m_freem(n);
d2232 1
a2232 1
#endif
@


1.81.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.81.2.2 2002/06/11 03:30:45 art Exp $	*/
d50 1
d67 1
a68 4
#endif

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
a166 3
#ifdef IPSEC
int bridge_ipsec(int, int, int, struct mbuf *);
#endif
a209 1
		if_alloc_sadl(ifp);
a1362 2
	splassert(IPL_NET);

d1899 1
a1899 1
	int i, error = 0, onlycnt = 0;
d1904 1
a1904 1
	if (sc->sc_rts == NULL)
a1906 3
	if (baconf->ifbac_len == 0)
		onlycnt = 1;

d1909 14
a1922 17
			if (!onlycnt) {
				if (baconf->ifbac_len < sizeof(struct ifbareq))
					goto done;
				bcopy(sc->sc_if.if_xname, bareq.ifba_name,
				    sizeof(bareq.ifba_name));
				bcopy(n->brt_if->if_xname, bareq.ifba_ifsname,
				    sizeof(bareq.ifba_ifsname));
				bcopy(&n->brt_addr, &bareq.ifba_dst,
				    sizeof(bareq.ifba_dst));
				bareq.ifba_age = n->brt_age;
				bareq.ifba_flags = n->brt_flags;
				error = copyout((caddr_t)&bareq,
				    (caddr_t)(baconf->ifbac_req + cnt), sizeof(bareq));
				if (error)
					goto done;
				baconf->ifbac_len -= sizeof(struct ifbareq);
			}
d1924 1
a2059 192
#ifdef IPSEC
int
bridge_ipsec(dir, af, hlen, m)
	int dir, af, hlen;
	struct mbuf *m;
{
	union sockaddr_union dst;
	struct timeval tv;
	struct tdb *tdb;
	u_int32_t spi;
	u_int16_t cpi;
	int error, off;
	u_int8_t proto = 0;
#ifdef INET
	struct ip *ip;
#endif /* INET */
#ifdef INET6
	struct ip6_hdr *ip6;
#endif /* INET6 */

	if (dir == BRIDGE_IN) {
		switch (af) {
#ifdef INET
		case AF_INET:
			if (m->m_pkthdr.len - hlen < 2 * sizeof(u_int32_t))
				break;

			ip = mtod(m, struct ip *);
			proto = ip->ip_p;
			off = offsetof(struct ip, ip_p);

			if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
			    proto != IPPROTO_IPCOMP)
				goto skiplookup;

			bzero(&dst, sizeof(union sockaddr_union));
			dst.sa.sa_family = AF_INET;
			dst.sin.sin_len = sizeof(struct sockaddr_in);
			m_copydata(m, offsetof(struct ip, ip_dst),
			    sizeof(struct in_addr),
			    (caddr_t)&dst.sin.sin_addr);

			if (ip->ip_p == IPPROTO_ESP)
				m_copydata(m, hlen, sizeof(u_int32_t),
				    (caddr_t)&spi);
			else if (ip->ip_p == IPPROTO_AH)
				m_copydata(m, hlen + sizeof(u_int32_t),
				    sizeof(u_int32_t), (caddr_t)&spi);
			else if (ip->ip_p == IPPROTO_IPCOMP) {
				m_copydata(m, hlen + sizeof(u_int16_t),
				    sizeof(u_int16_t), (caddr_t)&cpi);
				spi = ntohl(htons(cpi));
			}
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			if (m->m_pkthdr.len - hlen < 2 * sizeof(u_int32_t))
				break;

			ip6 = mtod(m, struct ip6_hdr *);

			/* XXX We should chase down the header chain */
			proto = ip6->ip6_nxt;
			off = offsetof(struct ip6_hdr, ip6_nxt);

			if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
			    proto != IPPROTO_IPCOMP)
				goto skiplookup;

			bzero(&dst, sizeof(union sockaddr_union));
			dst.sa.sa_family = AF_INET6;
			dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
			m_copydata(m, offsetof(struct ip6_hdr, ip6_nxt),
			    sizeof(struct in6_addr),
			    (caddr_t)&dst.sin6.sin6_addr);

			if (proto == IPPROTO_ESP)
				m_copydata(m, hlen, sizeof(u_int32_t),
				    (caddr_t)&spi);
			else if (proto == IPPROTO_AH)
				m_copydata(m, hlen + sizeof(u_int32_t),
				    sizeof(u_int32_t), (caddr_t)&spi);
			else if (proto == IPPROTO_IPCOMP) {
				m_copydata(m, hlen + sizeof(u_int16_t),
				    sizeof(u_int16_t), (caddr_t)&cpi);
				spi = ntohl(htons(cpi));
			}
			break;
#endif /* INET6 */
		default:
			return (0);
		}

		if (proto == 0)
			goto skiplookup;

		tdb = gettdb(spi, &dst, proto);
		if (tdb != NULL && (tdb->tdb_flags & TDBF_INVALID) == 0 &&
		    tdb->tdb_xform != NULL) {
			if (tdb->tdb_first_use == 0) {
				int pri;

				pri = splhigh();
				tdb->tdb_first_use = time.tv_sec;
				splx(pri);

				tv.tv_usec = 0;

				/* Check for wrap-around. */
				if (tdb->tdb_exp_first_use + tdb->tdb_first_use
				    < tdb->tdb_first_use)
					tv.tv_sec = ((unsigned long)-1) / 2;
				else
					tv.tv_sec = tdb->tdb_exp_first_use +
					    tdb->tdb_first_use;

				if (tdb->tdb_flags & TDBF_FIRSTUSE)
					timeout_add(&tdb->tdb_first_tmo,
					    hzto(&tv));

				/* Check for wrap-around. */
				if (tdb->tdb_first_use +
				    tdb->tdb_soft_first_use
				    < tdb->tdb_first_use)
					tv.tv_sec = ((unsigned long)-1) / 2;
				else
					tv.tv_sec = tdb->tdb_first_use +
					    tdb->tdb_soft_first_use;

				if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
					timeout_add(&tdb->tdb_sfirst_tmo,
					    hzto(&tv));
			}

			(*(tdb->tdb_xform->xf_input))(m, tdb, hlen, off);
			return (1);
		} else {
 skiplookup:
			/* XXX do an input policy lookup */
			return (0);
		}
	} else { /* Outgoing from the bridge. */
		tdb = ipsp_spd_lookup(m, af, hlen, &error,
		    IPSP_DIRECTION_OUT, NULL, NULL);
		if (tdb != NULL) {
			/*
			 * We don't need to do loop detection, the
			 * bridge will do that for us.
			 */
#if NFP > 0
			switch (af) {
#ifdef INET
			case AF_INET:
				if (pf_test(dir, &encif[0].sc_if,
				    &m) != PF_PASS) {
					m_freem(m);
					return (1);
				}
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				if (pf_test6(dir, &encif[0].sc_if,
				    &m) != PF_PASS) {
					m_freem(m);
					return (1);
				}
				break;
#endif /* INET6 */
			}
			if (m == NULL)
				return (1);
#endif /* NPF */
#ifdef INET
			if (af == AF_INET) {
				ip = mtod(m, struct ip *);
				HTONS(ip->ip_len);
				HTONS(ip->ip_id);
				HTONS(ip->ip_off);
			}
#endif /* INET */
			error = ipsp_process_packet(m, tdb, af, 0);
			return (1);
		} else
			return (0);
	}

	return (0);
}
#endif /* IPSEC */

d2084 1
a2084 1
		if (etype > ETHERMTU ||
d2123 1
a2123 1

d2128 1
a2128 1

a2133 1

d2141 1
a2141 1

d2146 1
a2146 1

d2152 1
a2152 1

d2162 1
a2162 8

#ifdef IPSEC
		if ((sc->sc_if.if_flags & IFF_LINK2) == IFF_LINK2 &&
		    bridge_ipsec(dir, AF_INET, hlen, m))
			return (NULL);
#endif /* IPSEC */

#if NPF > 0
d2169 1
a2169 2
#endif /* NPF */

d2195 1
a2195 1

d2197 1
a2197 1

a2203 9
#ifdef IPSEC
		hlen = sizeof(struct ip6_hdr);

		if ((sc->sc_if.if_flags & IFF_LINK2) == IFF_LINK2 &&
		    bridge_ipsec(dir, AF_INET6, hlen, m))
			return (NULL);
#endif /* IPSEC */

#if NPF > 0
d2208 1
a2208 2
#endif /* NPF */

d2212 1
a2212 1

d2217 1
a2217 1

d2249 1
a2249 1
	struct mbuf *m0;
a2252 1
	u_int16_t etype;
d2259 2
a2260 3
	etype = ntohs(eh->ether_type);
	if (etype != ETHERTYPE_IP) {
		if (etype > ETHERMTU ||
a2283 3
	if (m->m_len < sizeof(struct ip) &&
	    (m = m_pullup(m, sizeof(struct ip))) == NULL)
		goto dropit;
d2299 1
a2299 1
	for (; m; m = m0) {
d2387 1
a2387 1
	struct mbuf *m, *n2;
a2390 3
	n2 = m_copym(n, 0, M_COPYALL, M_DONTWAIT);
	if (!n2)
		return;
a2393 2

	n = n2;
@


1.81.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a41 1
#include "vlan.h"
a92 4
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

d144 1
d205 1
a205 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "bridge%d", i);
d349 1
a349 1
				bridge_rtdelete(sc, p->ifp, 0);
a435 1
		req->ifbr_path_cost = p->bif_path_cost;
a469 1
	case SIOCBRDGSIFCOST:
d489 1
a489 8
		if (cmd == SIOCBRDGSIFPRIO)
			p->bif_priority = req->ifbr_priority;
		else {
			if (req->ifbr_path_cost < 1)
				error = EINVAL;
			else
				p->bif_path_cost = req->ifbr_path_cost;
		}
d651 1
a651 1
			bridge_rtdelete(sc, ifp, 0);
a688 1
		breq.ifbr_path_cost = p->bif_path_cost;
a704 1
		breq.ifbr_path_cost = p->bif_path_cost;
a923 16

			/*
			 * If this is not the original output interface,
			 * and the interface is participating in spanning
			 * tree, make sure the port is in a state that
			 * allows forwarding.
			 */
			if (dst_if != ifp &&
			    (p->bif_flags & IFBIF_STP) &&
			    (p->bif_state != BSTP_IFSTATE_FORWARDING))
				continue;

			if ((p->bif_flags & IFBIF_DISCOVER) == 0 &&
			    (m->m_flags & (M_BCAST | M_MCAST)) == 0)
				continue;

d1218 1
a1218 1
	struct bridge_iflist *ifl, *srcifl;
a1313 1
	srcifl = ifl;
d1319 1
a1319 1
			if (srcifl->bif_flags & IFBIF_LEARNING)
d1381 2
a1382 1
		    (p->bif_state != BSTP_IFSTATE_FORWARDING))
d1506 1
a1506 1
		error = bridge_ifenqueue(sc, ifp, mc);
d1673 1
a1673 1
	} while (0)
d1866 1
a1866 1
bridge_rtdelete(sc, ifp, dynonly)
a1868 1
	int dynonly;
d1883 7
a1889 8
			if (n->brt_if != ifp) {
				/* Not ours */
				n = LIST_NEXT(n, brt_next);
				continue;
			}
			if (dynonly &&
			    (n->brt_flags & IFBAF_TYPEMASK) != IFBAF_DYNAMIC) {
				/* only deleting dynamics */
a1890 7
				continue;
			}
			p = LIST_NEXT(n, brt_next);
			LIST_REMOVE(n, brt_next);
			sc->sc_brtcnt--;
			free(n, M_DEVBUF);
			n = p;
d2084 1
a2084 1
	int error, off, s;
a2169 2
		s = spltdb();

a2208 1
			splx(s);
a2212 1
			splx(s);
d2223 1
a2223 1
#if NPF > 0
a2484 11
#if NVLAN > 0
	if (etype == ETHERTYPE_8021Q &&
	    (ifp->if_capabilities & IFCAP_VLAN_MTU) &&
	    ((m->m_pkthdr.len - sizeof(struct ether_vlan_header)) <=
	    ifp->if_mtu)) {
		s = splimp();
		bridge_ifenqueue(sc, ifp, m);
		splx(s);
		return;
	}
#endif
d2490 1
a2490 1

d2493 1
a2493 1

d2502 1
a2502 1

d2505 1
a2505 1

d2530 1
a2530 1
		m->m_nextpkt = NULL;
d2558 1
a2558 1

d2561 1
a2561 1

d2563 1
a2563 1
#endif /* INET */
d2577 1
d2581 5
a2585 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d2602 1
a2602 1
void
d2621 1
a2621 2
	if (!n2) {
		m_freem(n);
a2622 1
	}
d2624 1
a2624 2
	if (m == NULL) {
		m_freem(n2);
a2625 1
	}
@


1.80
log
@remove redundant #if NPF. ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.79 2001/12/10 05:46:57 jasoni Exp $	*/
d121 2
d181 1
d240 10
d340 52
d435 4
d650 3
d674 16
d897 2
d947 1
d1248 2
d1451 67
@


1.79
log
@update ip stats when dropping an ip packet
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.78 2001/12/08 18:07:57 jason Exp $	*/
a1929 3
#if NPF == 0
	return (m);
#else
a2047 1
#endif /* NPF == 0 */
d2049 1
a2049 1
#endif
@


1.78
log
@mflags and len were uninitialized in bridge_broadcast (source of some
accounting errors me thinks).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.77 2001/11/26 16:50:26 jasoni Exp $	*/
d60 1
d1967 2
a1968 1
	    (m = m_pullup(m, sizeof(struct ip))) == NULL)
d1970 1
d1973 2
a1974 1
	if (ip->ip_v != IPVERSION)
d1976 1
d1979 2
a1980 1
	if (hlen < sizeof(struct ip))
d1982 1
d1984 2
a1985 1
		if ((m = m_pullup(m, hlen)) == NULL)
d1987 1
d1991 2
a1992 1
	if ((ip->ip_sum = in_cksum(m, hlen)) != 0)
d1994 1
@


1.77
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.76 2001/08/21 15:18:20 jason Exp $	*/
d1277 2
a1278 2
	int error, len, used = 0;
	short mflags;
@


1.76
log
@cut/pasto in rule flushing code (using wrong list); base on patch from Henk van Lingen <henk@@vanlingen.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.75 2001/08/12 00:09:29 mickey Exp $	*/
d2004 2
@


1.76.2.1
log
@Pull in patches from current:
- This is ugly: make a specialized deep copy in bridge_broadcast() that
ensures that the payload after the ethernet header is nicely aligned
(basically this is two copies, one for the ethernet header and one
for the payload) and glue the two copies together.  bridge_filter()
assumes it has been handed a nicely aligned packet.  This should
address pr#2248.
- Don't forget to deallocate on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.76 2001/08/21 15:18:20 jason Exp $	*/
d1324 2
a1325 11
			struct mbuf *m1, *m2, *mx;

			m1 = m_copym2(m, 0, sizeof(struct ether_header),
			    M_DONTWAIT);
			if (m1 == NULL) {
				sc->sc_if.if_oerrors++;
				continue;
			}
			m2 = m_copym2(m, sizeof(struct ether_header),
			    M_COPYALL, M_DONTWAIT);
			if (m2 == NULL) {
a1328 13

			for (mx = m1; mx->m_next != NULL; mx = mx->m_next)
				;
			mx->m_next = m2;

			if (m1->m_flags & M_PKTHDR) {
				int len = 0;

				for (mx = m1; mx != NULL; mx = mx->m_next)
					len += mx->m_len;
				m1->m_pkthdr.len = len;
			}
			mc = m1;
@


1.75
log
@now, that kernel compiles, i can go get an ash tray somewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.74 2001/07/27 22:31:47 jason Exp $	*/
d1908 1
a1908 1
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlin, p, brl_next);
@


1.74
log
@PF_IN/PF_OUT aren't defined if NPF <= 0, deal with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.73 2001/07/25 04:59:33 jason Exp $	*/
d142 1
d145 1
a145 1

d1046 1
a1046 1

d1050 1
a1050 1

d1089 1
d1093 1
d1331 1
d1335 1
@


1.73
log
@Make sure pkthdr.rcvif is correct before calling pf_test()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.72 2001/07/25 03:43:41 jason Exp $	*/
d68 5
d1046 1
a1046 1
	m = bridge_filter(sc, PF_IN, src_if, &eh, m);
d1088 1
a1088 1
	m = bridge_filter(sc, PF_OUT, dst_if, &eh, m);
d1328 1
a1328 1
		mc = bridge_filter(sc, PF_OUT, dst_if, eh, mc);
@


1.72
log
@- unconditionalize call to bridge_input() (fewer #ifdef's and NPF>0 is default case anyway).
- add support for filtering on interface output (and call pf_test() appropriately)
What all this means: nonstateful and stateful PF filtering now works with the bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.71 2001/07/17 20:34:51 provos Exp $	*/
d1992 2
a1993 1
	if (pf_test(dir, m->m_pkthdr.rcvif, &m) != PF_PASS)
@


1.71
log
@split ip normalization out into a separate file, okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.70 2001/06/28 21:53:42 provos Exp $	*/
d137 3
a147 8
#if NPF > 0
/*
 * Filter hooks
 */
struct mbuf *bridge_filter __P((struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *m));
#endif

d1041 1
a1041 2
#if NPF > 0
	m = bridge_filter(sc, src_if, &eh, m);
a1043 1
#endif
d1083 4
d1323 4
d1912 1
a1912 1
bridge_filter(sc, ifp, eh, m)
d1914 1
d1919 3
d1992 1
a1992 1
	if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
d2027 1
@


1.70
log
@first stab at packet normalization.  includes full ip reassembly.
okay dhartmei@@, dugsong@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.69 2001/06/27 06:26:43 angelos Exp $	*/
a54 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d64 4
@


1.69
log
@IPFILTER->NPF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.68 2001/06/27 06:07:39 kjc Exp $	*/
d1987 1
a1987 1
	if (pf_test(PF_IN, m->m_pkthdr.rcvif, m) != PF_PASS)
@


1.68
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.67 2001/06/26 18:17:53 deraadt Exp $	*/
d1046 1
a1046 1
#if defined(INET) && defined(IPFILTER)
@


1.67
log
@no longer pass around **m
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.66 2001/06/25 05:04:43 kjell Exp $	*/
d745 3
a747 1
	int s;
d811 3
d829 11
a839 1

d841 4
a844 5
			sc->sc_if.if_obytes += mc->m_pkthdr.len;
			dst_if->if_obytes += mc->m_pkthdr.len;
			IF_ENQUEUE(&dst_if->if_snd, mc);
			if (mc->m_flags & M_MCAST)
				ifp->if_omcasts++;
d860 8
a867 2
	if (IF_QFULL(&dst_if->if_snd)) {
		IF_DROP(&dst_if->if_snd);
a868 1
		m_freem(m);
d873 3
a875 4
	sc->sc_if.if_obytes += m->m_pkthdr.len;
	dst_if->if_obytes += m->m_pkthdr.len;
	IF_ENQUEUE(&dst_if->if_snd, m);
	if (m->m_flags & M_MCAST)
d923 1
a923 1
	int s;
d928 2
d1090 6
d1097 2
a1098 2
	if (IF_QFULL(&dst_if->if_snd)) {
		IF_DROP(&dst_if->if_snd);
a1099 1
		m_freem(m);
d1104 3
a1106 4
	sc->sc_if.if_obytes += m->m_pkthdr.len;
	dst_if->if_obytes += m->m_pkthdr.len;
	IF_ENQUEUE(&dst_if->if_snd, m);
	if (m->m_flags & M_MCAST)
d1272 3
a1274 1
	int used = 0;
d1297 3
d1326 9
d1336 3
a1338 4
		sc->sc_if.if_obytes += mc->m_pkthdr.len;
		dst_if->if_obytes += m->m_pkthdr.len;
		IF_ENQUEUE(&dst_if->if_snd, mc);
		if (mc->m_flags & M_MCAST)
@


1.66
log
@PACKETFILTER -> NPF
remove IPF cruft. ok jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.65 2001/06/24 22:34:05 fgsch Exp $	*/
a1882 1
	struct mbuf *m1;
d1950 1
a1950 2
	m1 = m;
	if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m1) != PF_PASS)
a1951 1
	m = m1;
@


1.65
log
@Use ETHER_IS_MULTICAST macro; jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.64 2001/06/24 20:12:50 jason Exp $	*/
d36 1
d54 2
a55 1
#ifdef PACKETFILTER
a67 4
#ifdef IPFILTER
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#endif
d145 1
a145 1
#ifdef PACKETFILTER
d1866 1
a1866 1
#ifdef PACKETFILTER
@


1.64
log
@pf mods for bridge; not yet tested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.63 2001/06/23 07:08:51 angelos Exp $	*/
d779 1
a779 1
	if (dst_if == NULL || eh->ether_dhost[0] & 1) {
@


1.63
log
@UDP/IP/TCP packets that hit a bridge and need hardware checksumming
are simply dropped.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.62 2001/06/23 06:24:23 angelos Exp $	*/
d53 3
d147 1
a147 1
#if defined(INET) && defined(IPFILTER)
d1868 1
a1868 2
#if defined(INET) && defined(IPFILTER)

d1885 1
a1887 3
	if (fr_checkp == NULL)
		return (m);

d1953 4
a1956 4
	if (fr_checkp && (*fr_checkp)(ip, hlen, ifp, 0, &m))
		return (NULL);
	if (m == NULL)		/* in case of 'fastroute' */
		return (NULL);
@


1.62
log
@Remember to compute IP/TCP/UDP checksum if we're going to broadcast on
bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.61 2001/06/22 14:28:58 deraadt Exp $	*/
a787 1
			/* Notify IPsec */
d795 7
a801 14
		/* Catch packets that needs TCP/UDP/IP hardware checksumming */
		if (m->m_pkthdr.csum & M_IPV4_CSUM_OUT) {
			/* XXX Compute IP checksum */
			m->m_pkthdr.csum &= ~M_IPV4_CSUM_OUT; /* Clear */
		}

		if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT) {
			/* XXX Compute TCP checksum */
			m->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
		}

		if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
			/* XXX Compute UDP checksum */
			m->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
@


1.61
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.60 2001/06/15 03:38:33 itojun Exp $	*/
d795 16
@


1.60
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.59 2001/06/07 04:12:58 mickey Exp $	*/
d271 1
a271 1
		        /* Nothing needed */
d927 3
a929 3
	    ((ifl->bif_state == BSTP_IFSTATE_BLOCKING) ||
	     (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
	     (ifl->bif_state == BSTP_IFSTATE_DISABLED))) {
d948 3
a950 6
	    !(eh.ether_shost[0] == 0 &&
	      eh.ether_shost[1] == 0 &&
	      eh.ether_shost[2] == 0 &&
	      eh.ether_shost[3] == 0 &&
	      eh.ether_shost[4] == 0 &&
	      eh.ether_shost[5] == 0))
d1053 1
a1053 1
	     ifl->bif_state == BSTP_IFSTATE_BLOCKING)) {
d1132 2
a1133 2
		     (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
		     (ifl->bif_state == BSTP_IFSTATE_DISABLED)))
d1178 2
a1179 2
	     (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
	     (ifl->bif_state == BSTP_IFSTATE_DISABLED)))
d1252 1
a1252 1
		     p->bif_state == BSTP_IFSTATE_DISABLED))
d1770 2
a1771 4
	    (etype == ETHERTYPE_ARP ||
	     etype == ETHERTYPE_REVARP ||
	     etype == ETHERTYPE_IP ||
	     etype == ETHERTYPE_IPV6)) {
@


1.59
log
@use faster arc4random() instead of get_random_bytes(); jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.58 2001/06/06 22:55:03 jasoni Exp $	*/
a817 1
			dst_if->if_lastchange = time;
a845 1
	dst_if->if_lastchange = time;
a913 1
	sc->sc_if.if_lastchange = time;
a1073 1
	dst_if->if_lastchange = time;
a1293 1
		dst_if->if_lastchange = time;
@


1.58
log
@in bridge_filter(), pullup hlen, not sizeof(struct ip); ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.57 2001/06/01 00:28:25 angelos Exp $	*/
d699 1
a699 1
		get_random_bytes(&sc->sc_hashkey, sizeof(sc->sc_hashkey));
d1333 1
a1333 1
			get_random_bytes(&sc->sc_hashkey, sizeof(sc->sc_hashkey));
@


1.57
log
@Don't let packets that need IPsec crypto processing at the NIC be
bridge-broadcast; rather, turn off offloading for now. The IPsec stack
will do its own crypto for subsequent packets, which will be
broadcast. Once the bridge knows which interface to send packets for
that MAC to, if that interface supports IPsec offloading it'll turn it
back on.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.56 2001/05/30 02:12:24 deraadt Exp $	*/
d1930 1
a1930 1
		if ((m = m_pullup(m, sizeof(struct ip))) == NULL)
@


1.56
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.55 2001/05/11 04:56:15 jason Exp $	*/
d745 3
d781 15
d1275 5
a1292 6
		}

		if (p->bif_flags & IFBIF_BLOCKNONIP &&
		    bridge_blocknonip(eh, mc)) {
			m_freem(mc);
			continue;
@


1.55
log
@check for 'fastroute' condition (like ip_input) in bridge_filter() and
deal with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.54 2001/03/22 02:00:36 jason Exp $	*/
d144 1
a144 1
#if defined(INET) && (defined(IPFILTER) || defined(IPFILTER_LKM))
d1005 1
a1005 1
#if defined(INET) && (defined(IPFILTER) || defined(IPFILTER_LKM))
d1850 1
a1850 1
#if defined(INET) && (defined(IPFILTER) || defined(IPFILTER_LKM))
@


1.54
log
@strlcpy instead of strncpy + \0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.53 2001/03/19 23:58:38 jason Exp $	*/
d1939 2
@


1.54.2.1
log
@MFC:
- cut/pasto in rule flushing code (using wrong list); base on patch from Henk van Lingen <henk@@vanlingen.net>
- in bridge_filter(), pullup hlen, not sizeof(struct ip); ok jason@@
- check for 'fastroute' condition (like ip_input) in bridge_filter() and deal with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.54 2001/03/22 02:00:36 jason Exp $	*/
d1844 1
a1844 1
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlout, p, brl_next);
d1913 1
a1913 1
		if ((m = m_pullup(m, hlen)) == NULL)
a1938 2
		return (NULL);
	if (m == NULL)		/* in case of 'fastroute' */
@


1.53
log
@m_freem not m_free if we're dropping the packet because we're not in
the forwarding stp state
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.52 2001/03/06 06:29:16 angelos Exp $	*/
d240 2
a241 3
				strncpy(ifreq.ifr_name, req->ifbr_ifsname,
				    sizeof(ifreq.ifr_name) - 1);
				ifreq.ifr_name[sizeof(ifreq.ifr_name) - 1] = '\0';
d253 2
a254 3
				strncpy(ifreq.ifr_name, req->ifbr_ifsname,
				    sizeof(ifreq.ifr_name) - 1);
				ifreq.ifr_name[sizeof(ifreq.ifr_name) - 1] = '\0';
d586 2
a587 6
		strncpy(breq.ifbr_name, sc->sc_if.if_xname,
		    sizeof(breq.ifbr_name)-1);
		breq.ifbr_name[sizeof(breq.ifbr_name) - 1] = '\0';
		strncpy(breq.ifbr_ifsname, p->ifp->if_xname,
		    sizeof(breq.ifbr_ifsname)-1);
		breq.ifbr_ifsname[sizeof(breq.ifbr_ifsname) - 1] = '\0';
d644 2
a645 6
		strncpy(req.ifbr_name, sc->sc_if.if_xname,
		    sizeof(req.ifbr_name) - 1);
		req.ifbr_name[sizeof(req.ifbr_name) - 1] = '\0';
		strncpy(req.ifbr_ifsname, ifl->ifp->if_xname,
		    sizeof(req.ifbr_ifsname) - 1);
		req.ifbr_ifsname[sizeof(req.ifbr_ifsname) - 1] = '\0';
d661 2
a662 6
		strncpy(req.ifbr_name, sc->sc_if.if_xname,
		    sizeof(req.ifbr_name) - 1);
		req.ifbr_name[sizeof(req.ifbr_name) - 1] = '\0';
		strncpy(req.ifbr_ifsname, ifl->ifp->if_xname,
		    sizeof(req.ifbr_ifsname) - 1);
		req.ifbr_ifsname[sizeof(req.ifbr_ifsname) - 1] = '\0';
@


1.52
log
@Eeep, don't reset the checksum when checking it! Noticed by bugfix@@123.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.51 2001/03/05 03:38:38 angelos Exp $	*/
d1056 1
a1056 1
		m_free(m);
@


1.51
log
@Clear ip_sum before calculating IP checksum (closes PR 1667)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.50 2001/02/06 06:48:08 mickey Exp $	*/
a1931 1
	ip->ip_sum = 0;
@


1.50
log
@allow for configuring number of bridge ifaces in ukc; jason@@ ok and help
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.49 2001/02/04 18:10:10 jason Exp $	*/
d1932 1
d1965 1
@


1.49
log
@For unicast packets destined for the bridge machine itself, learn from the
SRC address (not the DST).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.48 2001/02/02 06:01:18 jason Exp $	*/
a33 1
#include "bridge.h"
a36 2
#if NBRIDGE > 0

d105 2
a106 1
struct bridge_softc bridgectl[NBRIDGE];
d153 2
a154 2
bridgeattach(unused)
	int unused;
d156 2
a158 1
	struct ifnet *ifp;
d160 6
a165 4
	for (i = 0; i < NBRIDGE; i++) {
		struct bridge_softc *sc;

		sc = &bridgectl[i];
d873 1
a873 1
	for (i = 0; i < NBRIDGE; i++) {
a1987 2

#endif  /* NBRIDGE */
@


1.48
log
@In the broadcast received on gif case, throw the packet up the stack if
we -found- an appropriate interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.47 2001/02/01 01:32:51 jason Exp $	*/
d1195 1
a1195 1
				    (struct ether_addr *)&eh->ether_dhost,
@


1.47
log
@packets received on gif's for local processing can't just fall down the
stack, they have to be pushed; when calling ether_input():
1 - unicast packets have the ifp of the matching interface
2 - bcast/mcast packets have the ifp of the first IFT_ETHER bridge member
based on discussion with angelos.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.46 2001/01/30 04:22:24 kjell Exp $	*/
d1164 1
a1164 1
			if (ifl == LIST_END(&sc->sc_iflist)) {
@


1.46
log
@change ip_compat.h to ip_fil_compat.h for clarity. Impending ipf merge
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.45 2001/01/17 04:47:18 fgsch Exp $	*/
d1107 2
d1159 12
d1198 5
@


1.45
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.44 2000/12/30 22:56:23 angelos Exp $	*/
d67 1
a67 1
#include <netinet/ip_compat.h>
@


1.44
log
@For bridged IPsec, use the gif* interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.43 2000/12/12 03:41:22 jason Exp $	*/
d67 1
a67 1
#include <netinet/ip_fil_compat.h>
@


1.43
log
@Add support for 802.1D spanning tree protocol.
NOTE: this requires recompiling brconfig with updated include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.42 2000/11/10 05:24:58 jason Exp $	*/
d36 1
a36 1
#include "enc.h"
d270 3
a272 7
#if NENC > 0
		else if (ifs->if_type == IFT_ENC) {
			/* Can't bind enc0 to a bridge */
			if (ifs->if_softc == &encif[0]) {
				error = EINVAL;
				break;
			}
d274 1
a274 1
#endif /* NENC */
a799 1

@


1.42
log
@it doesn't matter what kind of interface it is if the bridge_iflist allocation
fails..  it's still ENOMEM.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.41 2000/11/07 05:38:53 jason Exp $	*/
d86 2
a87 2
#ifndef BRIDGE_RTABLE_MAX
#define BRIDGE_RTABLE_MAX	100
d90 9
d102 2
a103 2
#ifndef BRIDGE_RTABLE_TIMEOUT
#define BRIDGE_RTABLE_TIMEOUT	240
a107 49
/*
 * Bridge filtering rules
 */
SIMPLEQ_HEAD(brl_head, brl_node);

struct brl_node {
	SIMPLEQ_ENTRY(brl_node)	brl_next;	/* next rule */
	struct ether_addr	brl_src;	/* source mac address */
	struct ether_addr	brl_dst;	/* destination mac address */
	u_int8_t		brl_action;	/* what to do with match */
	u_int8_t		brl_flags;	/* comparision flags */
};

/*
 * Bridge interface list
 */
struct bridge_iflist {
	LIST_ENTRY(bridge_iflist)	next;		/* next in list */
	struct brl_head			bif_brlin;	/* input rules */
	struct brl_head			bif_brlout;	/* output rules */
	struct				ifnet *ifp;	/* member interface */
	u_int32_t			bif_flags;	/* member flags */
};

/*
 * Bridge route node
 */
struct bridge_rtnode {
	LIST_ENTRY(bridge_rtnode)	brt_next;	/* next in list */
	struct				ifnet *brt_if;	/* destination ifs */
	u_int8_t			brt_flags;	/* address flags */
	u_int8_t			brt_age;	/* age counter */
	struct				ether_addr brt_addr;	/* dst addr */
};

/*
 * Software state for each bridge
 */
struct bridge_softc {
	struct				ifnet sc_if;	/* the interface */
	u_int32_t			sc_brtmax;	/* max # addresses */
	u_int32_t			sc_brtcnt;	/* current # addrs */
	u_int32_t			sc_brttimeout;	/* timeout ticks */
	u_int32_t			sc_hashkey;	/* hash key */
	struct timeout			sc_brtimeout;	/* timeout state */
	LIST_HEAD(, bridge_iflist)	sc_iflist;	/* interface list */
	LIST_HEAD(bridge_rthead, bridge_rtnode)	*sc_rts;/* hash table */
};

d168 5
d205 1
a205 1
	struct ifbcachereq *bcachereq = (struct ifbcachereq *)data;
a206 1
	struct ifbcachetoreq *bcacheto = (struct ifbcachetoreq *)data;
d213 1
a213 1
	s = splsoftnet();
d292 1
d296 2
d348 3
d372 5
d379 22
d437 1
a437 1
		bcachereq->ifbc_size = sc->sc_brtmax;
d442 1
a442 1
		sc->sc_brtmax = bcachereq->ifbc_size;
d448 1
a448 1
		sc->sc_brttimeout = bcacheto->ifbct_time;
d450 1
a450 1
		if (bcacheto->ifbct_time != 0)
d454 1
a454 1
		bcacheto->ifbct_time = sc->sc_brttimeout;
d528 11
d542 4
d598 3
d867 3
d891 1
a891 1
 * Loop through each bridge interface and process their input queues.
d929 8
d959 11
d1057 6
d1116 7
d1124 17
d1166 11
d1236 5
@


1.41
log
@- Since the actual frame processing takes place from softnet(), splhigh
is not needed (the only other two places that modify the state of the
bridge are bridge_ioctl() and bridge_rtage(), both of which can easily
be wrapped in splsoftnet).
- compute a random hashkey each time the bridge is brought up
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.40 2000/11/06 01:40:28 jason Exp $	*/
d322 3
a324 1
		if (p == NULL && ifs->if_type == IFT_ETHER) {
a325 1
			ifpromisc(ifs, 0);
@


1.40
log
@use the macros from queue.h more consistently
update if_omcasts and call IF_DROP when necessary
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.39 2000/10/18 18:48:21 jason Exp $	*/
d142 1
d160 1
d162 1
a162 1
void	bridge_rtage __P((void *));
d171 1
a171 1
u_int32_t	bridge_hash __P((struct ether_addr *));
d208 1
a208 1
		timeout_set(&sc->sc_brtimeout, bridge_rtage, sc);
d249 1
a249 1
	s = splimp();
d686 1
a686 1
	int i, s;
a690 1
	s = splhigh();
d695 1
a695 2
		if (sc->sc_rts == NULL) {
			splx(s);
a696 1
		}
d700 1
a702 1
	splx(s);
d1218 1
a1218 1
	int s, dir;
a1219 1
	s = splhigh();
a1224 1

d1228 1
a1228 1
			for (h = 0; h < BRIDGE_RTABLE_SIZE; h++)
d1230 2
d1236 1
a1236 1
	h = bridge_hash(ea);
a1323 1
	splx(s);
d1334 1
a1334 6
	int s, dir;

	/*
	 * Lock out everything else
	 */
	s = splhigh();
d1339 1
a1339 1
	h = bridge_hash(ea);
d1342 1
a1342 2
		if (dir == 0) {
			splx(s);
a1343 1
		}
a1347 1
	splx(s);
d1371 2
a1372 1
bridge_hash(addr)
d1375 1
a1375 1
	u_int32_t a = 0x9e3779b9, b = 0x9e3779b9, c = 0xdeadbeef;
d1397 1
a1397 1
	int s, i;
a1398 1
	s = splhigh();
a1410 1
	splx(s);
a1411 1
	s = splhigh();
d1437 1
d1439 9
d1455 2
a1456 2
bridge_rtage(vsc)
	void *vsc;
a1457 1
	struct bridge_softc *sc = (struct bridge_softc *)vsc;
d1459 1
a1459 1
	int s, i;
d1461 1
a1461 3
	s = splhigh();
	if (sc->sc_rts == NULL) {
		splx(s);
a1462 1
	}
a1483 1
	splx(s);
d1497 1
a1497 1
	int s, i;
a1499 1
	s = splhigh();
d1501 1
a1501 1
		goto done;
a1522 2
done:
	splx(s);
d1534 1
a1534 1
	int h, s;
a1536 1
	s = splhigh();
d1538 1
a1538 1
		goto done;
d1540 1
a1540 1
	h = bridge_hash(ea);
a1550 1
			splx(s);
a1554 2
done:
	splx(s);
d1565 1
a1565 1
	int i, s;
a1567 1
	s = splhigh();
d1569 1
a1569 1
		goto done;
a1591 3

done:
	splx(s);
d1602 1
a1602 1
	int i, s, error = 0;
a1606 2
	s = splhigh();

a1631 1
	splx(s);
@


1.39
log
@use IFT_BRIDGE
correctly update member interface obytes+lastchange; patch from camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.38 2000/10/18 16:30:28 jason Exp $	*/
d102 2
d117 2
a118 2
	SIMPLEQ_HEAD(, brl_node)	bif_brlin;	/* input rules */
	SIMPLEQ_HEAD(, brl_node)	bif_brlout;	/* output rules */
d175 1
a175 1
u_int8_t bridge_filterrule __P((struct brl_node *, struct ether_header *));
d337 1
a337 2
		p = LIST_FIRST(&sc->sc_iflist);
		while (p != NULL) {
a349 1
			p = LIST_NEXT(p, next);
d351 1
a351 1
		if (p == NULL) {
d369 3
a371 3
		p = LIST_FIRST(&sc->sc_iflist);
		while (p != NULL && p->ifp != ifs) {
			p = LIST_NEXT(p, next);
d373 1
a373 1
		if (p == NULL) {
d391 3
a393 3
		p = LIST_FIRST(&sc->sc_iflist);
		while (p != NULL && p->ifp != ifs) {
			p = LIST_NEXT(p, next);
d395 1
a395 1
		if (p == NULL) {
d477 3
a479 3
		p = LIST_FIRST(&sc->sc_iflist);
		while (p != NULL && p->ifp != ifs) {
			p = LIST_NEXT(p, next);
d481 1
a481 1
		if (p == NULL) {
d515 3
a517 3
		p = LIST_FIRST(&sc->sc_iflist);
		while (p != NULL && p->ifp != ifs) {
			p = LIST_NEXT(p, next);
d519 1
a519 1
		if (p == NULL) {
d540 1
a540 1
	struct bridge_softc *bsc = (struct bridge_softc *)ifp->if_bridge;
d543 1
a543 2
	for (bif = LIST_FIRST(&bsc->sc_iflist); bif;
	    bif = LIST_NEXT(bif, next))
d546 1
a546 1
			bridge_rtdelete(bsc, ifp);
d552 1
d561 1
a561 1
	u_int32_t total = 0, i;
d565 1
a565 2
	p = LIST_FIRST(&sc->sc_iflist);
	while (p != NULL) {
a566 1
		p = LIST_NEXT(p, next);
a567 1

d573 3
a575 3
	p = LIST_FIRST(&sc->sc_iflist);
	i = 0;
	while (p != NULL && bifc->ifbic_len >= sizeof(breq)) {
a586 1
		p = LIST_NEXT(p, next);
d590 1
d606 1
a606 1
	u_int32_t i, total = 0;
d613 5
a617 4
	ifl = LIST_FIRST(&sc->sc_iflist);
	while (ifl != NULL && ifl->ifp != ifp)
		ifl = LIST_NEXT(ifl, next);
	if (ifl == NULL)
d620 1
a620 2
	n = SIMPLEQ_FIRST(&ifl->bif_brlin);
	while (n != NULL) {
a621 1
		n = SIMPLEQ_NEXT(n, brl_next);
d623 1
a623 2
	n = SIMPLEQ_FIRST(&ifl->bif_brlout);
	while (n != NULL) {
a624 1
		n = SIMPLEQ_NEXT(n, brl_next);
d632 3
a634 3
	i = 0;
	n = SIMPLEQ_FIRST(&ifl->bif_brlin);
	while (n != NULL && bc->ifbrl_len >= sizeof(req)) {
a648 1
		n = SIMPLEQ_NEXT(n, brl_next);
d653 3
a655 2
	n = SIMPLEQ_FIRST(&ifl->bif_brlout);
	while (n != NULL && bc->ifbrl_len >= sizeof(req)) {
a669 1
		n = SIMPLEQ_NEXT(n, brl_next);
d780 3
a782 3
		for (p = LIST_FIRST(&sc->sc_iflist); p != NULL;
		     p = LIST_NEXT(p, next)) {
			if ((p->ifp->if_flags & IFF_RUNNING) == 0)
d784 2
a785 1
			if (IF_QFULL(&p->ifp->if_snd)) {
d790 1
a790 1
			if (LIST_NEXT(p, next) == NULL) {
d802 8
a809 6
			sc->sc_if.if_obytes += m->m_pkthdr.len;
			p->ifp->if_lastchange = time;
			p->ifp->if_obytes += m->m_pkthdr.len;
			IF_ENQUEUE(&p->ifp->if_snd, mc);
			if ((p->ifp->if_flags & IFF_OACTIVE) == 0)
				(*p->ifp->if_start)(p->ifp);
d824 1
d835 2
d902 3
a904 3
	ifl = LIST_FIRST(&sc->sc_iflist);
	while (ifl != NULL && ifl->ifp != src_if) {
		ifl = LIST_NEXT(ifl, next);
d906 1
a906 1
	if (ifl == NULL) {
d981 1
a981 3
	if (SIMPLEQ_FIRST(&ifl->bif_brlin) &&
	    bridge_filterrule(SIMPLEQ_FIRST(&ifl->bif_brlin), &eh) ==
	    BRL_ACTION_BLOCK) {
d1012 9
a1020 6
	ifl = LIST_FIRST(&sc->sc_iflist);
	while (ifl != NULL && ifl->ifp != dst_if)
		ifl = LIST_NEXT(ifl, next);
	if (SIMPLEQ_FIRST(&ifl->bif_brlout) &&
	    bridge_filterrule(SIMPLEQ_FIRST(&ifl->bif_brlout), &eh) ==
	    BRL_ACTION_BLOCK) {
d1026 1
d1037 2
d1101 1
a1101 1
	for (ifl = LIST_FIRST(&sc->sc_iflist);ifl; ifl = LIST_NEXT(ifl,next)) {
d1148 1
d1151 1
a1151 1
	for (p = LIST_FIRST(&sc->sc_iflist); p; p = LIST_NEXT(p, next)) {
d1156 2
a1157 1
		if (p->ifp->if_index == ifp->if_index)
d1164 1
a1164 1
		if ((p->ifp->if_flags & IFF_RUNNING) == 0)
d1167 2
a1168 1
		if (IF_QFULL(&p->ifp->if_snd)) {
d1173 1
a1173 3
		if (SIMPLEQ_FIRST(&p->bif_brlout) &&
		    bridge_filterrule(SIMPLEQ_FIRST(&p->bif_brlout), eh) ==
		    BRL_ACTION_BLOCK)
d1177 1
a1177 1
		if (LIST_NEXT(p, next) == NULL) {
d1196 7
a1202 6
		if ((eh->ether_shost[0] & 1) == 0)
			ifp->if_omcasts++;

		IF_ENQUEUE(&p->ifp->if_snd, mc);
		if ((p->ifp->if_flags & IFF_OACTIVE) == 0)
			(*p->ifp->if_start)(p->ifp);
d1239 1
a1239 1
	if (p == NULL) {
d1300 1
a1300 1
		if (p == NULL) {
d1320 1
a1320 1
	} while (p != NULL);
d1347 1
a1347 2
	p = LIST_FIRST(&sc->sc_rts[h]);
	while (p != NULL) {
a1354 1
		p = LIST_NEXT(p, brt_next);
d1430 1
a1430 1
		while (n != NULL) {
d1472 1
a1472 1
		while (n != NULL) {
d1513 1
a1513 1
		while (n != NULL) {
d1552 1
a1552 2
	p = LIST_FIRST(&sc->sc_rts[h]);
	while (p != NULL) {
a1564 1
		p = LIST_NEXT(p, brt_next);
d1592 1
a1592 1
		while (n != NULL) {
d1631 1
a1631 2
		n = LIST_FIRST(&sc->sc_rts[i]);
		while (n != NULL) {
a1645 1
			n = LIST_NEXT(n, brt_next);
d1708 2
a1709 2
bridge_filterrule(n, eh)
	struct brl_node *n;
d1712 1
d1715 1
a1715 1
	for (; n != NULL; n = SIMPLEQ_NEXT(n, brl_next)) {
d1771 1
a1771 1
	struct brl_node *p, *q;
d1773 2
a1774 3
	p = SIMPLEQ_FIRST(&bif->bif_brlin);
	while (p != NULL) {
		q = SIMPLEQ_NEXT(p, brl_next);
a1776 1
		p = q;
d1778 3
a1780 4
	p = SIMPLEQ_FIRST(&bif->bif_brlout);
	while (p != NULL) {
		q = SIMPLEQ_NEXT(p, brl_next);
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlout, p, brl_next);
a1781 1
		p = q;
@


1.38
log
@revamped llc handling using if_llc.h
removed unused structure
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.37 2000/10/18 04:31:14 jason Exp $	*/
d213 1
a213 1
		ifp->if_type = IFT_PROPVIRTUAL;
d809 2
d835 2
d1033 2
@


1.37
log
@get the bounds checking right for the data used in copyout() in several
ioctl calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.36 2000/10/09 17:01:10 jason Exp $	*/
a144 9
/* SNAP LLC header */
struct snap {
	u_int8_t dsap;
	u_int8_t ssap;
	u_int8_t control;
	u_int8_t org[3];
	u_int16_t type;
};

d1660 1
a1660 1
	struct snap snap;
d1679 1
a1679 1
	    (sizeof(struct ether_header) + sizeof(struct snap)))
d1682 2
a1683 2
	m_copydata(m, sizeof(struct ether_header), sizeof(struct snap),
	    (caddr_t)&snap);
d1685 7
a1691 4
	etype = ntohs(snap.type);
	if (snap.dsap == LLC_SNAP_LSAP && snap.ssap == LLC_SNAP_LSAP &&
	    snap.control == LLC_UI &&
	    snap.org[0] == 0 && snap.org[1] == 0 && snap.org[2] == 0 &&
a1786 8
 * Maximum sized IP header
 */
union maxip {
	struct ip ip;
	u_int32_t _padding[16];
};

/*
d1799 1
a1799 1
	struct snap snap;
d1809 1
a1809 1
		    m->m_pkthdr.len < (sizeof(struct snap) +
d1814 1
a1814 1
		    sizeof(struct snap), (caddr_t)&snap);
d1816 7
a1822 4
		if (snap.dsap != LLC_SNAP_LSAP || snap.ssap != LLC_SNAP_LSAP ||
		    snap.control != LLC_UI ||
		    snap.org[0] != 0 || snap.org[1] != 0 || snap.org[2] ||
		    snap.type != htons(ETHERTYPE_IP))
d1829 1
a1829 1
		m_adj(m, sizeof(struct snap));
d1888 1
a1888 1
		M_PREPEND(m, sizeof(snap), M_DONTWAIT);
d1891 1
a1891 1
		bcopy(&snap, mtod(m, caddr_t), sizeof(snap));
@


1.36
log
@uninitialized variable; spotted by Andrew Lunn <andrew.lunn@@ascom.ch>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.35 2000/06/26 23:16:37 art Exp $	*/
d587 1
a587 1
	while (p != NULL && bifc->ifbic_len > i * sizeof(breq)) {
d649 1
a649 1
	while (n != NULL && bc->ifbrl_len > i * sizeof(req)) {
d670 1
a670 1
	while (n != NULL && bc->ifbrl_len > i * sizeof(req)) {
d1635 1
a1635 2
			if (baconf->ifbac_len <
			    (cnt + 1) * sizeof(struct ifbareq))
d1651 1
@


1.35
log
@timeout is in seconds, not ticks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.34 2000/06/22 19:00:21 art Exp $	*/
d618 1
a618 1
	u_int32_t i, total;
@


1.34
log
@Convert to new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.33 2000/06/20 05:50:16 jason Exp $	*/
d460 1
a460 1
			timeout_add(&sc->sc_brtimeout, sc->sc_brttimeout);
@


1.33
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.32 2000/06/16 21:43:04 deraadt Exp $	*/
d140 1
d207 9
a215 4
		bridgectl[i].sc_brtmax = BRIDGE_RTABLE_MAX;
		bridgectl[i].sc_brttimeout = BRIDGE_RTABLE_TIMEOUT;
		LIST_INIT(&bridgectl[i].sc_iflist);
		ifp = &bridgectl[i].sc_if;
d217 1
a217 1
		ifp->if_softc = &bridgectl[i];
d227 1
a227 1
		bpfattach(&bridgectl[i].sc_if.if_bpf, ifp,
d458 1
a458 1
		untimeout(bridge_rtage, sc);
d460 1
a460 1
			timeout(bridge_rtage, sc, sc->sc_brttimeout);
d722 1
a722 1
		timeout(bridge_rtage, sc, sc->sc_brttimeout * hz);
d740 1
a740 1
	untimeout(bridge_rtage, sc);
d1493 1
a1493 1
		timeout(bridge_rtage, sc, sc->sc_brttimeout * hz);
@


1.32
log
@use memcmp() instead of bcmp(), memcmp is <,=,> but bcmp is =,!=
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.31 2000/06/02 00:36:42 jason Exp $	*/
d802 1
a802 2
			}
			else {
d1173 1
a1173 2
		}
		else {
d1225 1
a1225 2
		}
		else
d1472 1
a1472 2
			}
			else if (n->brt_age) {
d1475 1
a1475 2
			}
			else {
d1753 1
a1753 2
	}
	else {
@


1.31
log
@On input if the packet matches one of the member interface MAC addresses,
set the receiving interface to be that interface for further processing;
thanks to dorcula@@uncool.org for reporting and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.30 2000/05/25 00:30:27 jason Exp $	*/
d1260 1
a1260 1
		dir = bcmp(ea, &q->brt_addr, sizeof(q->brt_addr));
d1344 1
a1344 1
		dir = bcmp(ea, &p->brt_addr, sizeof(p->brt_addr));
@


1.30
log
@on packets incoming to the bridge machine itself, respect the
LEARNING flag on the receiving interface (ie. don't learn when you're
not supposed to).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.29 2000/04/10 13:34:54 jason Exp $	*/
d1105 1
@


1.29
log
@don't return directly from bridge_ioctl without splx() on invalid enc
interfaces; modified version of patch from Armin Wolfermann
<armin@@wolfermann.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.28 2000/02/28 23:41:28 jason Exp $	*/
d1096 6
a1101 6
	ifl = LIST_FIRST(&sc->sc_iflist);
	while (ifl != NULL) {
		if (ifl->ifp->if_type == IFT_ETHER) {
			ac = (struct arpcom *)ifl->ifp;
			if (bcmp(ac->ac_enaddr, eh->ether_dhost,
			    ETHER_ADDR_LEN) == 0) {
d1103 1
a1103 1
				    (struct ether_addr *)&eh->ether_dhost[0],
d1105 5
a1109 7
				return (m);
			}
			if (bcmp(ac->ac_enaddr, eh->ether_shost,
			    ETHER_ADDR_LEN) == 0) {
				m_freem(m);
				return (NULL);
			}
a1110 1
		ifl = LIST_NEXT(ifl, next);
d1166 1
a1166 1
		    BRL_ACTION_BLOCK) {
a1167 1
		}
@


1.29.2.1
log
@Pull in patch from current:
Errata:
It is possible to bypass the ``learning'' flag on an interface if frames
go directly to the machine acting as a bridge.
Fix:
on packets incoming to the bridge machine itself, respect the
LEARNING flag on the receiving interface (ie. don't learn when you're
not supposed to).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.30 2000/05/25 00:30:27 jason Exp $	*/
d1096 6
a1101 6
	for (ifl = LIST_FIRST(&sc->sc_iflist);ifl; ifl = LIST_NEXT(ifl,next)) {
		if (ifl->ifp->if_type != IFT_ETHER)
			continue;
		ac = (struct arpcom *)ifl->ifp;
		if (bcmp(ac->ac_enaddr, eh->ether_dhost, ETHER_ADDR_LEN) == 0) {
			if (ifl->bif_flags & IFBIF_LEARNING)
d1103 1
a1103 1
				    (struct ether_addr *)&eh->ether_dhost,
d1105 7
a1111 5
			return (m);
		}
		if (bcmp(ac->ac_enaddr, eh->ether_shost, ETHER_ADDR_LEN) == 0) {
			m_freem(m);
			return (NULL);
d1113 1
d1169 1
a1169 1
		    BRL_ACTION_BLOCK)
d1171 1
@


1.29.2.2
log
@Add bridge_memcmp() and use it for inequality comparisions.  This fixes
incorrect handling of MAC's that are hashed to the same location.
Fix for PR#1275 for the stable branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.29.2.1 2000/05/27 20:17:12 jason Exp $	*/
a1201 23
int	bridge_memcmp __P((const void *, const void *, size_t));

/*
 * bridge_memcmp is a hack because memcmp does not exist in
 * the 2.7 kernel tree, and the bridge needs memcmp's <, >, =
 * comparisons.
 */
int
bridge_memcmp(s1, s2, n)
	const void *s1, *s2;
	size_t n;
{
	if (n != 0) {
		register const unsigned char *p1 = s1, *p2 = s2;

		do {
			if (*p1++ != *p2++)
				return (*--p1 - *--p2);
		} while (--n != 0);
	}
	return (0);
}

d1259 1
a1259 1
		dir = bridge_memcmp(ea, &q->brt_addr, sizeof(q->brt_addr));
d1343 1
a1343 1
		dir = bridge_memcmp(ea, &p->brt_addr, sizeof(p->brt_addr));
@


1.28
log
@remove unneeded variable and clean
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.27 2000/02/21 17:38:07 jason Exp $	*/
d305 1
a306 1
#if NENC > 0
d308 5
a312 2
			if (ifs->if_softc == &encif[0])
				return EINVAL;
a313 1
		}
@


1.27
log
@Rework bridge_filter() so that it does not require a full packet copy
Allow for reusing the current mbuf (rather than a copy) for the last
	interface in the list in bridge_output().
Replace some pointer derefs with on the stack copies of the data.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.26 2000/02/19 08:59:05 niklas Exp $	*/
a1050 1
	struct ether_header *neh;
d1075 1
a1075 1
		M_PREPEND(mc, sizeof(*eh), M_DONTWAIT);
d1078 1
a1078 2
		neh = mtod(mc, struct ether_header *);
		bcopy(eh, neh, sizeof(struct ether_header));
d1113 1
a1113 1
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
d1116 1
a1116 2
	neh = mtod(m, struct ether_header *);
	bcopy(eh, neh, sizeof(struct ether_header));
@


1.26
log
@set interface fields to null when detaching substructures
in preparation for softc retainment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.25 2000/01/25 22:06:27 jason Exp $	*/
a96 7
/*
 * This really should be defined in if_llc.h but in case it isn't.
 */
#ifndef llc_snap
#define llc_snap        llc_un.type_snap
#endif

d144 7
a150 6
/*
 * Ethernet header and SNAP header
 */
struct ehllc {
	struct ether_header eh;
	struct llc llc;
d176 1
a176 1
struct mbuf *bridge_blocknonip __P((struct mbuf *));
d194 2
a195 4
#define	BRIDGE_FILTER_PASS	0
#define	BRIDGE_FILTER_DROP	1
int	bridge_filter __P((struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf **));
a753 2
	struct bridge_iflist *p;
	struct mbuf *mc;
d784 4
d789 1
a789 1
		    p = LIST_NEXT(p, next)) {
a791 1

d797 10
a806 4
			mc = m_copym(m, 0, M_COPYALL, M_NOWAIT);
			if (mc == NULL) {
				sc->sc_if.if_oerrors++;
				continue;
d815 2
a816 1
		m_freem(m);
d883 1
a883 1
	struct ether_header *eh;
d910 3
a912 4
	if (m->m_len < sizeof(*eh)) {
		m = m_pullup(m, sizeof(*eh));
		if (m == NULL)
			return;
d914 3
a916 3
	eh = mtod(m, struct ether_header *);
	dst = (struct ether_addr *)&eh->ether_dhost[0];
	src = (struct ether_addr *)&eh->ether_shost[0];
d923 7
a929 7
	    (eh->ether_shost[0] & 1) == 0 &&
	    !(eh->ether_shost[0] == 0 &&
	      eh->ether_shost[1] == 0 &&
	      eh->ether_shost[2] == 0 &&
	      eh->ether_shost[3] == 0 &&
	      eh->ether_shost[4] == 0 &&
	      eh->ether_shost[5] == 0))
d936 1
a936 1
	if (m->m_flags & (M_BCAST | M_MCAST)) {
d975 3
a977 7
	if (ifl->bif_flags & IFBIF_BLOCKNONIP) {
		m = bridge_blocknonip(m);
		if (m == NULL)
			return;
		eh = mtod(m, struct ether_header *);
		dst = (struct ether_addr *)&eh->ether_dhost[0];
		src = (struct ether_addr *)&eh->ether_shost[0];
d981 1
a981 1
	    bridge_filterrule(SIMPLEQ_FIRST(&ifl->bif_brlin), eh) ==
d988 2
a989 3
	if (bridge_filter(sc, src_if, eh, &m) == BRIDGE_FILTER_DROP) {
		if (m != NULL)
			m_freem(m);
a990 1
	}
d999 3
a1001 1
		bridge_broadcast(sc, src_if, eh, m);
d1017 1
a1017 1
	    bridge_filterrule(SIMPLEQ_FIRST(&ifl->bif_brlout), eh) ==
d1038 2
a1039 2
 * Receive input from an interface.  Rebroadcast if necessary to other
 * bridge members.
d1060 3
d1187 4
a1190 4
		if (p->bif_flags & IFBIF_BLOCKNONIP) {
			mc = bridge_blocknonip(mc);
			if (mc == NULL)
				continue;
d1663 7
a1669 2
struct mbuf *
bridge_blocknonip(m)
d1672 1
a1672 1
	struct ehllc *ehllc;
d1675 10
a1684 4
	if (m->m_len < sizeof(struct ehllc)) {
		m = m_pullup(m, sizeof(struct ehllc));
		if (m == NULL)
			return (m);
a1686 7
	ehllc = mtod(m, struct ehllc *);
	etype = ntohs(ehllc->eh.ether_type);

	if (etype == ETHERTYPE_ARP || etype == ETHERTYPE_REVARP ||
	    etype == ETHERTYPE_IP  || etype == ETHERTYPE_IPV6)
		return (m);

d1688 1
a1688 1
		goto notip;
d1690 16
a1705 7
	if (ehllc->llc.llc_control == LLC_UI &&
	    ehllc->llc.llc_dsap == LLC_SNAP_LSAP &&
	    ehllc->llc.llc_ssap == LLC_SNAP_LSAP) {
		etype = ntohs(ehllc->llc.llc_snap.ether_type);
		if (etype == ETHERTYPE_ARP || etype == ETHERTYPE_REVARP ||
		    etype == ETHERTYPE_IP  || etype == ETHERTYPE_IPV6)
			return (m);
d1708 1
a1708 3
notip:
	m_freem(m);
	return (NULL);
d1797 8
d1810 2
a1811 2
int
bridge_filter(sc, ifp, eh, np)
d1815 1
a1815 1
	struct mbuf **np;
d1817 2
a1818 2
	struct mbuf *m = *np;
	struct ehllc *ehllc;
d1820 1
a1820 2
	u_int16_t etype;
	int hlen, r, off = sizeof(struct ether_header);
d1823 7
a1829 1
		return (BRIDGE_FILTER_PASS);
d1831 2
a1832 6
	if (m->m_len < sizeof(struct ehllc)) {
		m = m_pullup(m, sizeof(struct ehllc));
		*np = m;
		if (m == NULL)
			return (BRIDGE_FILTER_DROP);
	}
d1834 6
a1839 15
	ehllc = mtod(m, struct ehllc *);
	etype = ntohs(ehllc->eh.ether_type);
	if (etype != ETHERTYPE_IP) {
		if (etype > ETHERMTU)	/* Can't be SNAP */
			return (BRIDGE_FILTER_PASS);

		if (ehllc->llc.llc_control != LLC_UI ||
		    ehllc->llc.llc_dsap != LLC_SNAP_LSAP ||
		    ehllc->llc.llc_ssap != LLC_SNAP_LSAP ||
		    ehllc->llc.llc_snap.org_code[0] != 0 ||
		    ehllc->llc.llc_snap.org_code[1] != 0 ||
		    ehllc->llc.llc_snap.org_code[2] != 0 ||
		    ntohs(ehllc->llc.llc_snap.ether_type) != ETHERTYPE_IP)
			return (BRIDGE_FILTER_PASS);
		off += 8;
d1842 3
a1844 11
	/*
	 * We need a full copy because we're going to be destructive
	 * to the packet before we pass it to the ip filter code.
	 * XXX This needs to be turned into a munge -> check ->
	 * XXX unmunge section, for now, we copy.
	 * XXX Copy at offset 0 so that the mbuf header is copied, too.
	 */
	m = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
	m_adj(m, off);
	if (m == NULL)
		return (BRIDGE_FILTER_DROP);
d1846 2
a1847 8
	/*
	 * Pull up the IP header
	 */
	if (m->m_len < sizeof(struct ip)) {
		m = m_pullup(m, sizeof(struct ip));
		if (m == NULL)
			return (BRIDGE_FILTER_DROP);
	}
d1849 4
a1852 3
	/*
	 * Examine the ip header, and drop invalid packets
	 */
a1853 4
	if (ip->ip_v != IPVERSION) {
		r = BRIDGE_FILTER_DROP;
		goto out;
	}
d1855 9
a1863 10
	hlen = ip->ip_hl << 2;		/* get whole header length */
	if (hlen < sizeof(struct ip)) {
		r = BRIDGE_FILTER_DROP;
		goto out;
	}
	if (hlen > m->m_len) {		/* pull up whole header */
		if ((m = m_pullup(m, hlen)) == 0) {
			r = BRIDGE_FILTER_DROP;
			goto out;
		}
d1866 3
a1868 4
	if ((ip->ip_sum = in_cksum(m, hlen)) != 0) {
		r = BRIDGE_FILTER_DROP;
		goto out;
	}
d1871 2
a1872 4
	if (ip->ip_len < hlen) {
		r = BRIDGE_FILTER_DROP;
		goto out;
	}
d1876 2
a1877 4
	if (m->m_pkthdr.len < ip->ip_len) {
		r = BRIDGE_FILTER_DROP;
		goto out;
	}
d1888 26
a1913 1
		return (BRIDGE_FILTER_DROP);
d1915 1
a1915 1
	r = BRIDGE_FILTER_PASS;
d1917 4
a1920 3
out:
	m_freem(m);
	return (r);
@


1.25
log
@add ethernet MAC filtering capability
also includes split of bridgeintr() with some optimizations for quicker
frame handling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.24 2000/01/15 20:02:36 angelos Exp $	*/
d559 1
@


1.25.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.26 2000/02/19 08:59:05 niklas Exp $	*/
a558 1
			ifp->if_bridge = NULL;
@


1.25.2.2
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.27 2000/02/21 17:38:07 jason Exp $	*/
d97 7
d151 6
a156 7
/* SNAP LLC header */
struct snap {
	u_int8_t dsap;
	u_int8_t ssap;
	u_int8_t control;
	u_int8_t org[3];
	u_int16_t type;
d182 1
a182 1
int bridge_blocknonip __P((struct ether_header *, struct mbuf *));
d200 4
a203 2
struct mbuf *bridge_filter __P((struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *m));
d762 2
a793 4
		struct bridge_iflist *p;
		struct mbuf *mc;
		int used = 0;

d795 1
a795 1
		     p = LIST_NEXT(p, next)) {
d798 1
d804 4
a807 10
			if (LIST_NEXT(p, next) == NULL) {
				used = 1;
				mc = m;
			}
			else {
				mc = m_copym(m, 0, M_COPYALL, M_NOWAIT);
				if (mc == NULL) {
					sc->sc_if.if_oerrors++;
					continue;
				}
d816 1
a816 2
		if (!used)
			m_freem(m);
d883 1
a883 1
	struct ether_header eh;
d910 4
a913 3
	if (m->m_pkthdr.len < sizeof(eh)) {
		m_freem(m);
		return;
d915 3
a917 3
	m_copydata(m, 0, sizeof(struct ether_header), (caddr_t)&eh);
	dst = (struct ether_addr *)&eh.ether_dhost[0];
	src = (struct ether_addr *)&eh.ether_shost[0];
d924 7
a930 7
	    (eh.ether_shost[0] & 1) == 0 &&
	    !(eh.ether_shost[0] == 0 &&
	      eh.ether_shost[1] == 0 &&
	      eh.ether_shost[2] == 0 &&
	      eh.ether_shost[3] == 0 &&
	      eh.ether_shost[4] == 0 &&
	      eh.ether_shost[5] == 0))
d937 1
a937 1
	if ((m->m_flags & (M_BCAST | M_MCAST)) == 0) {
d976 7
a982 3
	if (ifl->bif_flags & IFBIF_BLOCKNONIP && bridge_blocknonip(&eh, m)) {
		m_freem(m);
		return;
d986 1
a986 1
	    bridge_filterrule(SIMPLEQ_FIRST(&ifl->bif_brlin), &eh) ==
d993 3
a995 2
	m = bridge_filter(sc, src_if, &eh, m);
	if (m == NULL)
d997 1
d1006 1
a1006 3
		s = splimp();
		bridge_broadcast(sc, src_if, &eh, m);
		splx(s);
d1022 1
a1022 1
	    bridge_filterrule(SIMPLEQ_FIRST(&ifl->bif_brlout), &eh) ==
d1043 2
a1044 2
 * Receive input from an interface.  Queue the packet for bridging if its
 * not for us, and schedule an interrupt.
a1064 3
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("bridge_input(): no HDR");

d1189 4
a1192 4
		if (p->bif_flags & IFBIF_BLOCKNONIP &&
		    bridge_blocknonip(eh, mc)) {
			m_freem(mc);
			continue;
d1665 2
a1666 7
/*
 * Block non-ip frames:
 * Returns 0 if frame is ip, and 1 if it should be dropped.
 */
int
bridge_blocknonip(eh, m)
	struct ether_header *eh;
d1669 1
a1669 1
	struct snap snap;
d1672 8
a1679 2
	if (m->m_pkthdr.len < sizeof(struct ether_header))
		return (1);
d1681 3
a1683 8
	etype = ntohs(eh->ether_type);
	switch (etype) {
	case ETHERTYPE_ARP:
	case ETHERTYPE_REVARP:
	case ETHERTYPE_IP:
	case ETHERTYPE_IPV6:
		return (0);
	}
d1686 1
a1686 1
		return (1);
d1688 7
a1694 16
	if (m->m_pkthdr.len <
	    (sizeof(struct ether_header) + sizeof(struct snap)))
		return (1);

	m_copydata(m, sizeof(struct ether_header), sizeof(struct snap),
	    (caddr_t)&snap);

	etype = ntohs(snap.type);
	if (snap.dsap == LLC_SNAP_LSAP && snap.ssap == LLC_SNAP_LSAP &&
	    snap.control == LLC_UI &&
	    snap.org[0] == 0 && snap.org[1] == 0 && snap.org[2] == 0 &&
	    (etype == ETHERTYPE_ARP ||
	     etype == ETHERTYPE_REVARP ||
	     etype == ETHERTYPE_IP ||
	     etype == ETHERTYPE_IPV6)) {
		return (0);
d1697 3
a1699 1
	return (1);
a1787 8
 * Maximum sized IP header
 */
union maxip {
	struct ip ip;
	u_int32_t _padding[16];
};

/*
d1793 2
a1794 2
struct mbuf *
bridge_filter(sc, ifp, eh, m)
d1798 1
a1798 1
	struct mbuf *m;
d1800 2
a1801 2
	struct snap snap;
	int hassnap = 0;
d1803 2
a1804 1
	int hlen;
d1807 1
a1807 1
		return (m);
d1809 6
a1814 8
	if (eh->ether_type != htons(ETHERTYPE_IP)) {
		if (eh->ether_type > ETHERMTU ||
		    m->m_pkthdr.len < (sizeof(struct snap) +
		    sizeof(struct ether_header)))
			return (m);

		m_copydata(m, sizeof(struct ether_header),
		    sizeof(struct snap), (caddr_t)&snap);
d1816 15
a1830 6
		if (snap.dsap != LLC_SNAP_LSAP || snap.ssap != LLC_SNAP_LSAP ||
		    snap.control != LLC_UI ||
		    snap.org[0] != 0 || snap.org[1] != 0 || snap.org[2] ||
		    snap.type != htons(ETHERTYPE_IP))
			return (m);
		hassnap = 1;
d1833 11
a1843 3
	m_adj(m, sizeof(struct ether_header));
	if (hassnap)
		m_adj(m, sizeof(struct snap));
d1845 8
a1852 2
	if (m->m_pkthdr.len < sizeof(struct ip))
		goto dropit;
d1854 3
a1856 4
	/* Copy minimal header, and drop invalids */
	if (m->m_len < sizeof(struct ip) &&
	    (m = m_pullup(m, sizeof(struct ip))) == NULL)
		return (NULL);
d1858 4
d1863 10
a1872 9
	if (ip->ip_v != IPVERSION)
		goto dropit;

	hlen = ip->ip_hl << 2;	/* get whole header length */
	if (hlen < sizeof(struct ip))
		goto dropit;
	if (hlen > m->m_len) {
		if ((m = m_pullup(m, sizeof(struct ip))) == NULL)
			return (NULL);
d1875 4
a1878 3

	if ((ip->ip_sum = in_cksum(m, hlen)) != 0)
		goto dropit;
d1881 4
a1884 2
	if (ip->ip_len < hlen)
		goto dropit;
d1888 4
a1891 2
	if (m->m_pkthdr.len < ip->ip_len)
		goto dropit;
d1902 1
a1902 26
		return (NULL);

	/* Rebuild the IP header */
	if (m->m_len < hlen && ((m = m_pullup(m, hlen)) == NULL))
		return (NULL);
	if (m->m_len < sizeof(struct ip))
		goto dropit;
	ip = mtod(m, struct ip *);
	HTONS(ip->ip_len);
	HTONS(ip->ip_id);
	HTONS(ip->ip_off);
	ip->ip_sum = in_cksum(m, hlen);

	/* Reattach SNAP header */
	if (hassnap) {
		M_PREPEND(m, sizeof(snap), M_DONTWAIT);
		if (m == NULL)
			goto dropit;
		bcopy(&snap, mtod(m, caddr_t), sizeof(snap));
	}

	/* Reattach ethernet header */
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
		goto dropit;
	bcopy(eh, mtod(m, caddr_t), sizeof(*eh));
d1904 1
a1904 1
	return (m);
d1906 3
a1908 4
dropit:
	if (m != NULL)
		m_freem(m);
	return (NULL);
@


1.25.2.3
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1051 1
d1076 1
a1076 1
		M_PREPEND(mc, sizeof(struct ether_header), M_DONTWAIT);
d1079 2
a1080 1
		bcopy(eh, mtod(mc, caddr_t), sizeof(struct ether_header));
d1115 1
a1115 1
	M_PREPEND(m, sizeof(struct ether_header), M_DONTWAIT);
d1118 2
a1119 1
	bcopy(eh, mtod(m, caddr_t), sizeof(struct ether_header));
@


1.25.2.4
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.54 2001/03/22 02:00:36 jason Exp $	*/
d34 1
d36 3
a38 1
#include "gif.h"
d86 2
a87 2
#ifndef	BRIDGE_RTABLE_MAX
#define	BRIDGE_RTABLE_MAX	100
a89 9
/* spanning tree defaults */
#define	BSTP_DEFAULT_MAX_AGE		(20 * 256)
#define	BSTP_DEFAULT_HELLO_TIME		(2 * 256)
#define	BSTP_DEFAULT_FORWARD_DELAY	(15 * 256)
#define	BSTP_DEFAULT_HOLD_TIME		(1 * 256)
#define	BSTP_DEFAULT_BRIDGE_PRIORITY	0x8000
#define	BSTP_DEFAULT_PORT_PRIORITY	0x80
#define	BSTP_DEFAULT_PATH_COST		55

d93 2
a94 2
#ifndef	BRIDGE_RTABLE_TIMEOUT
#define	BRIDGE_RTABLE_TIMEOUT	240
d99 55
a153 2
struct bridge_softc *bridgectl;
int nbridge;
a164 1
void	bridge_timer __P((void *));
d166 1
a166 1
void	bridge_rtage __P((struct bridge_softc *));
d175 1
a175 1
u_int32_t	bridge_hash __P((struct bridge_softc *, struct ether_addr *));
d181 1
a181 1
u_int8_t bridge_filterrule __P((struct brl_head *, struct ether_header *));
d199 2
a200 2
bridgeattach(n)
	int n;
d202 1
a202 1
	struct bridge_softc *sc;
a203 1
	int i;
d205 5
a209 17
	bridgectl = malloc(n * sizeof(*sc), M_DEVBUF, M_NOWAIT);
	if (!bridgectl)
		return;
	nbridge = n;
	bzero(bridgectl, n * sizeof(*sc));
	for (sc = bridgectl, i = 0; i < nbridge; i++, sc++) {

		sc->sc_brtmax = BRIDGE_RTABLE_MAX;
		sc->sc_brttimeout = BRIDGE_RTABLE_TIMEOUT;
		sc->sc_bridge_max_age = BSTP_DEFAULT_MAX_AGE;
		sc->sc_bridge_hello_time = BSTP_DEFAULT_HELLO_TIME;
		sc->sc_bridge_forward_delay= BSTP_DEFAULT_FORWARD_DELAY;
		sc->sc_bridge_priority = BSTP_DEFAULT_BRIDGE_PRIORITY;
		sc->sc_hold_time = BSTP_DEFAULT_HOLD_TIME;
		timeout_set(&sc->sc_brtimeout, bridge_timer, sc);
		LIST_INIT(&sc->sc_iflist);
		ifp = &sc->sc_if;
d211 1
a211 1
		ifp->if_softc = sc;
d216 1
a216 1
		ifp->if_type = IFT_BRIDGE;
d221 1
a221 1
		bpfattach(&sc->sc_if.if_bpf, ifp,
d239 1
a239 1
	struct ifbrparam *bparam = (struct ifbrparam *)data;
d241 1
d248 1
a248 1
	s = splnet();
d274 3
a276 2
				strlcpy(ifreq.ifr_name, req->ifbr_ifsname,
				    IFNAMSIZ);
d288 3
a290 2
				strlcpy(ifreq.ifr_name, req->ifbr_ifsname,
				    IFNAMSIZ);
d305 6
a310 3
#if NGIF > 0
		else if (ifs->if_type == IFT_GIF) {
		        /* Nothing needed */
a311 1
#endif /* NGIF */
d319 1
a319 3
		if (p == NULL) {
			if (ifs->if_type == IFT_ETHER)
				ifpromisc(ifs, 0);
d321 1
a323 1
		bzero(p, sizeof(struct bridge_iflist));
a326 2
		p->bif_priority = BSTP_DEFAULT_PORT_PRIORITY;
		p->bif_path_cost = BSTP_DEFAULT_PATH_COST;
d336 2
a337 1
		LIST_FOREACH(p, &sc->sc_iflist, next) {
d350 1
d352 1
a352 1
		if (p == LIST_END(&sc->sc_iflist)) {
d370 3
a372 3
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
d374 1
a374 1
		if (p == LIST_END(&sc->sc_iflist)) {
a378 3
		req->ifbr_state = p->bif_state;
		req->ifbr_priority = p->bif_priority;
		req->ifbr_portno = p->ifp->if_index & 0xff;
d392 3
a394 3
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
d396 1
a396 1
		if (p == LIST_END(&sc->sc_iflist)) {
a399 5
		if ((req->ifbr_ifsflags & IFBIF_STP) &&
		    (ifs->if_type != IFT_ETHER)) {
			error = EINVAL;
			break;
		}
a401 22
	case SIOCBRDGSIFPRIO:
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
		ifs = ifunit(req->ifbr_ifsname);
		if (ifs == NULL) {
			error = ENOENT;
			break;
		}
		if ((caddr_t)sc != ifs->if_bridge) {
			error = ESRCH;
			break;
		}
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p == LIST_END(&sc->sc_iflist)) {
			error = ESRCH;
			break;
		}
		p->bif_priority = req->ifbr_priority;
		break;
d438 1
a438 1
		bparam->ifbrp_csize = sc->sc_brtmax;
d443 1
a443 1
		sc->sc_brtmax = bparam->ifbrp_csize;
d449 4
a452 4
		sc->sc_brttimeout = bparam->ifbrp_ctime;
		timeout_del(&sc->sc_brtimeout);
		if (bparam->ifbrp_ctime != 0)
			timeout_add(&sc->sc_brtimeout, sc->sc_brttimeout * hz);
d455 1
a455 1
		bparam->ifbrp_ctime = sc->sc_brttimeout;
d478 3
a480 3
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
d482 1
a482 1
		if (p == LIST_END(&sc->sc_iflist)) {
d516 3
a518 3
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
d520 1
a520 1
		if (p == LIST_END(&sc->sc_iflist)) {
a528 11
	case SIOCBRDGGPRI:
	case SIOCBRDGGMA:
	case SIOCBRDGGHT:
	case SIOCBRDGGFD:
		break;
	case SIOCBRDGSPRI:
	case SIOCBRDGSFD:
	case SIOCBRDGSMA:
	case SIOCBRDGSHT:
		error = suser(prc->p_ucred, &prc->p_acflag);
		break;
a531 4

	if (!error)
		error = bstp_ioctl(ifp, cmd, data);

d541 1
a541 1
	struct bridge_softc *sc = (struct bridge_softc *)ifp->if_bridge;
d544 2
a545 1
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
d548 1
a548 1
			bridge_rtdelete(sc, ifp);
a553 1
	}
d562 1
a562 1
	u_int32_t total = 0, i = 0;
d566 2
a567 1
	LIST_FOREACH(p, &sc->sc_iflist, next) {
d569 1
d571 1
d577 9
a585 5
	LIST_FOREACH(p, &sc->sc_iflist, next) {
		if (bifc->ifbic_len < sizeof(breq))
			break;
		strlcpy(breq.ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(breq.ifbr_ifsname, p->ifp->if_xname, IFNAMSIZ);
a586 3
		breq.ifbr_state = p->bif_state;
		breq.ifbr_priority = p->bif_priority;
		breq.ifbr_portno = p->ifp->if_index & 0xff;
d591 1
a594 1

d610 1
a610 1
	u_int32_t i = 0, total = 0;
d617 4
a620 5
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp == ifp)
			break;
	}
	if (ifl == LIST_END(&sc->sc_iflist))
d623 2
a624 1
	SIMPLEQ_FOREACH(n, &ifl->bif_brlin, brl_next) {
d626 1
d628 2
a629 1
	SIMPLEQ_FOREACH(n, &ifl->bif_brlout, brl_next) {
d631 1
d639 9
a647 5
	SIMPLEQ_FOREACH(n, &ifl->bif_brlin, brl_next) {
		if (bc->ifbrl_len < sizeof(req))
			goto done;
		strlcpy(req.ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(req.ifbr_ifsname, ifl->ifp->if_xname, IFNAMSIZ);
d656 1
d661 8
a668 5
	SIMPLEQ_FOREACH(n, &ifl->bif_brlout, brl_next) {
		if (bc->ifbrl_len < sizeof(req))
			goto done;
		strlcpy(req.ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(req.ifbr_ifsname, ifl->ifp->if_xname, IFNAMSIZ);
d677 1
d692 1
a692 1
	int i;
d697 1
d702 2
a703 1
		if (sc->sc_rts == NULL)
d705 1
a708 1
		get_random_bytes(&sc->sc_hashkey, sizeof(sc->sc_hashkey));
d711 1
d714 1
a714 1
		timeout_add(&sc->sc_brtimeout, sc->sc_brttimeout * hz);
d732 1
a732 1
	timeout_del(&sc->sc_brtimeout);
d788 3
a790 3
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			dst_if = p->ifp;
			if ((dst_if->if_flags & IFF_RUNNING) == 0)
d792 1
a792 2
			if (IF_QFULL(&dst_if->if_snd)) {
				IF_DROP(&dst_if->if_snd);
d796 2
a797 1
			if (LIST_NEXT(p, next) == LIST_END(&sc->sc_iflist)) {
d800 2
a801 1
			} else {
d810 4
a813 8
			sc->sc_if.if_obytes += mc->m_pkthdr.len;
			dst_if->if_lastchange = time;
			dst_if->if_obytes += mc->m_pkthdr.len;
			IF_ENQUEUE(&dst_if->if_snd, mc);
			if (mc->m_flags & M_MCAST)
				ifp->if_omcasts++;
			if ((dst_if->if_flags & IFF_OACTIVE) == 0)
				(*dst_if->if_start)(dst_if);
a827 1
		IF_DROP(&dst_if->if_snd);
a834 2
	dst_if->if_lastchange = time;
	dst_if->if_obytes += m->m_pkthdr.len;
a835 2
	if (m->m_flags & M_MCAST)
		dst_if->if_omcasts++;
a850 3
/*
 * Loop through each bridge interface and process their input queues.
 */
d858 1
a858 1
	for (i = 0; i < nbridge; i++) {
d872 1
a872 1
 * Process a single frame.  Frame must be freed or queued before returning.
d901 3
a903 3
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp == src_if)
			break;
d905 1
a905 9
	if (ifl == LIST_END(&sc->sc_iflist)) {
		m_freem(m);
		return;
	}

	if ((ifl->bif_flags & IFBIF_STP) &&
	    ((ifl->bif_state == BSTP_IFSTATE_BLOCKING) ||
	     (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
	     (ifl->bif_state == BSTP_IFSTATE_DISABLED))) {
a931 11
	if ((ifl->bif_flags & IFBIF_STP) &&
	    (ifl->bif_state == BSTP_IFSTATE_LEARNING)) {
		m_freem(m);
		return;
	}

	/*
	 * At this point, the port either doesn't participate in stp or
	 * it's in the forwarding state
	 */

d980 3
a982 1
	if (bridge_filterrule(&ifl->bif_brlin, &eh) == BRL_ACTION_BLOCK) {
d1013 6
a1018 15
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp == dst_if)
			break;
	}
	if (ifl == LIST_END(&sc->sc_iflist)) {
		m_freem(m);
		return;
	}
	if ((ifl->bif_flags & IFBIF_STP) &&
	    (ifl->bif_state == BSTP_IFSTATE_DISABLED ||
	     ifl->bif_state == BSTP_IFSTATE_BLOCKING)) {
		m_freem(m);
		return;
	}
	if (bridge_filterrule(&ifl->bif_brlout, &eh) == BRL_ACTION_BLOCK) {
a1023 1
		IF_DROP(&dst_if->if_snd);
a1030 2
	dst_if->if_lastchange = time;
	dst_if->if_obytes += m->m_pkthdr.len;
a1031 2
	if (m->m_flags & M_MCAST)
		dst_if->if_omcasts++;
a1061 2
	m->m_flags &= ~M_PROTO1;	/* Loop prevention */

a1065 7
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp == ifp)
			break;
	}
	if (ifl == LIST_END(&sc->sc_iflist))
		return (m);

a1066 17
		/* Tap off 802.1D packets, they do not get forwarded */
		if (bcmp(eh->ether_dhost, bstp_etheraddr, ETHER_ADDR_LEN) == 0) {
			m = bstp_input(sc, ifp, eh, m);
			if (m == NULL)
				return (NULL);
		}

		/*
		 * No need to queue frames for ifs in the blocking, disabled,
		 *  or listening state
		 */
		if ((ifl->bif_flags & IFBIF_STP) &&
		    ((ifl->bif_state == BSTP_IFSTATE_BLOCKING) ||
		     (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
		     (ifl->bif_state == BSTP_IFSTATE_DISABLED)))
			return (m);

a1087 12
		if (ifp->if_type == IFT_GIF) {
			LIST_FOREACH(ifl, &sc->sc_iflist, next) {
				if (ifl->ifp->if_type == IFT_ETHER)
					break;
			}
			if (ifl != LIST_END(&sc->sc_iflist)) {
				m->m_flags |= M_PROTO1;
				m->m_pkthdr.rcvif = ifl->ifp;
				ether_input(ifl->ifp, eh, m);
				m = NULL;
			}
		}
a1091 11
	 * No need to queue frames for ifs in the blocking, disabled, or
	 * listening state
	 */
	if ((ifl->bif_flags & IFBIF_STP) &&
	    ((ifl->bif_state == BSTP_IFSTATE_BLOCKING) ||
	     (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
	     (ifl->bif_state == BSTP_IFSTATE_DISABLED)))
		return (m);


	/*
d1094 6
a1099 6
	LIST_FOREACH(ifl, &sc->sc_iflist, next) {
		if (ifl->ifp->if_type != IFT_ETHER)
			continue;
		ac = (struct arpcom *)ifl->ifp;
		if (bcmp(ac->ac_enaddr, eh->ether_dhost, ETHER_ADDR_LEN) == 0) {
			if (ifl->bif_flags & IFBIF_LEARNING)
d1101 1
a1101 1
				    (struct ether_addr *)&eh->ether_shost,
d1103 6
a1108 5
			m->m_pkthdr.rcvif = ifl->ifp;
			if (ifp->if_type == IFT_GIF) {
				m->m_flags |= M_PROTO1;
				ether_input(ifl->ifp, eh, m);
				m = NULL;
a1109 5
			return (m);
		}
		if (bcmp(ac->ac_enaddr, eh->ether_shost, ETHER_ADDR_LEN) == 0) {
			m_freem(m);
			return (NULL);
d1111 1
a1142 1
	struct ifnet *dst_if;
d1145 1
a1145 1
	LIST_FOREACH(p, &sc->sc_iflist, next) {
d1150 1
a1150 7
		dst_if = p->ifp;
		if (dst_if->if_index == ifp->if_index)
			continue;

		if ((p->bif_flags & IFBIF_STP) &&
		    (p->bif_state == BSTP_IFSTATE_BLOCKING ||
		     p->bif_state == BSTP_IFSTATE_DISABLED))
d1157 1
a1157 1
		if ((dst_if->if_flags & IFF_RUNNING) == 0)
d1160 1
a1160 2
		if (IF_QFULL(&dst_if->if_snd)) {
			IF_DROP(&dst_if->if_snd);
d1165 3
a1167 1
		if (bridge_filterrule(&p->bif_brlout, eh) == BRL_ACTION_BLOCK)
d1169 1
d1172 1
a1172 1
		if (LIST_NEXT(p, next) == LIST_END(&sc->sc_iflist)) {
d1175 2
a1176 1
		} else {
d1192 6
a1197 7
		dst_if->if_obytes += m->m_pkthdr.len;
		dst_if->if_lastchange = time;
		IF_ENQUEUE(&dst_if->if_snd, mc);
		if (mc->m_flags & M_MCAST)
			dst_if->if_omcasts++;
		if ((dst_if->if_flags & IFF_OACTIVE) == 0)
			(*dst_if->if_start)(dst_if);
d1214 1
a1214 1
	int dir;
d1216 1
d1222 1
d1226 1
a1226 1
			for (h = 0; h < BRIDGE_RTABLE_SIZE; h++) {
d1228 2
a1229 3
			}
			get_random_bytes(&sc->sc_hashkey, sizeof(sc->sc_hashkey));
		} else
d1233 1
a1233 1
	h = bridge_hash(sc, ea);
d1235 1
a1235 1
	if (p == LIST_END(&sc->sc_rts[h])) {
d1261 1
a1261 1
		dir = memcmp(ea, &q->brt_addr, sizeof(q->brt_addr));
d1296 1
a1296 1
		if (p == LIST_END(&sc->sc_rts[h])) {
d1316 1
a1316 1
	} while (p != LIST_END(&sc->sc_rts[h]));
d1321 1
d1332 6
a1337 1
	int dir;
d1342 6
a1347 4
	h = bridge_hash(sc, ea);
	LIST_FOREACH(p, &sc->sc_rts[h], brt_next) {
		dir = memcmp(ea, &p->brt_addr, sizeof(p->brt_addr));
		if (dir == 0)
d1349 1
d1352 1
d1355 1
d1379 1
a1379 2
bridge_hash(sc, addr)
	struct bridge_softc *sc;
d1382 1
a1382 1
	u_int32_t a = 0x9e3779b9, b = 0x9e3779b9, c = sc->sc_hashkey;
d1404 1
a1404 1
	int i;
d1406 1
d1419 1
d1421 1
d1428 1
a1428 1
		while (n != LIST_END(&sc->sc_rts[i])) {
a1446 8
}

void
bridge_timer(vsc)
	void *vsc;
{
	struct bridge_softc *sc = vsc;
	int s;
a1447 2
	s = splsoftnet();
	bridge_rtage(sc);
d1455 2
a1456 2
bridge_rtage(sc)
	struct bridge_softc *sc;
d1458 1
d1460 1
a1460 1
	int i;
d1462 3
a1464 1
	if (sc->sc_rts == NULL)
d1466 1
d1470 1
a1470 1
		while (n != LIST_END(&sc->sc_rts[i])) {
d1476 2
a1477 1
			} else if (n->brt_age) {
d1480 2
a1481 1
			} else {
d1490 1
d1493 1
a1493 1
		timeout_add(&sc->sc_brtimeout, sc->sc_brttimeout * hz);
d1504 1
a1504 1
	int i;
d1507 1
d1509 1
a1509 1
		return (0);
d1513 1
a1513 1
		while (n != LIST_END(&sc->sc_rts[i])) {
d1531 2
d1544 1
a1544 1
	int h;
d1547 1
d1549 1
a1549 1
		return (ENOENT);
d1551 3
a1553 2
	h = bridge_hash(sc, ea);
	LIST_FOREACH(p, &sc->sc_rts[h], brt_next) {
d1563 1
d1566 1
d1569 2
d1581 1
a1581 1
	int i;
d1584 1
d1586 1
a1586 1
		return;
d1594 1
a1594 1
		while (n != LIST_END(&sc->sc_rts[i])) {
d1609 3
d1622 1
a1622 1
	int i, error = 0;
d1627 2
d1633 4
a1636 2
		LIST_FOREACH(n, &sc->sc_rts[i], brt_next) {
			if (baconf->ifbac_len < sizeof(struct ifbareq))
d1650 1
a1651 1
			baconf->ifbac_len -= sizeof(struct ifbareq);
d1656 1
d1669 1
a1669 1
	struct llc llc;
d1688 1
a1688 1
	    (sizeof(struct ether_header) + LLC_SNAPFRAMELEN))
d1691 2
a1692 2
	m_copydata(m, sizeof(struct ether_header), LLC_SNAPFRAMELEN,
	    (caddr_t)&llc);
d1694 4
a1697 7
	etype = ntohs(llc.llc_snap.ether_type);
	if (llc.llc_dsap == LLC_SNAP_LSAP &&
	    llc.llc_ssap == LLC_SNAP_LSAP &&
	    llc.llc_control == LLC_UI &&
	    llc.llc_snap.org_code[0] == 0 &&
	    llc.llc_snap.org_code[1] == 0 &&
	    llc.llc_snap.org_code[2] == 0 &&
d1709 2
a1710 2
bridge_filterrule(h, eh)
	struct brl_head *h;
a1712 1
	struct brl_node *n;
d1715 1
a1715 1
	SIMPLEQ_FOREACH(n, h, brl_next) {
d1759 2
a1760 1
	} else {
d1772 1
a1772 1
	struct brl_node *p;
d1774 3
a1776 2
	while (!SIMPLEQ_EMPTY(&bif->bif_brlin)) {
		p = SIMPLEQ_FIRST(&bif->bif_brlin);
d1779 1
d1781 4
a1784 3
	while (!SIMPLEQ_EMPTY(&bif->bif_brlout)) {
		p = SIMPLEQ_FIRST(&bif->bif_brlout);
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlin, p, brl_next);
d1786 1
d1794 8
d1814 1
a1814 1
	struct llc llc;
d1824 1
a1824 1
		    m->m_pkthdr.len < (LLC_SNAPFRAMELEN +
d1829 1
a1829 1
		    LLC_SNAPFRAMELEN, (caddr_t)&llc);
d1831 4
a1834 7
		if (llc.llc_dsap != LLC_SNAP_LSAP ||
		    llc.llc_ssap != LLC_SNAP_LSAP ||
		    llc.llc_control != LLC_UI ||
		    llc.llc_snap.org_code[0] ||
		    llc.llc_snap.org_code[1] ||
		    llc.llc_snap.org_code[2] ||
		    llc.llc_snap.ether_type != htons(ETHERTYPE_IP))
d1841 1
a1841 1
		m_adj(m, LLC_SNAPFRAMELEN);
a1895 1
	ip->ip_sum = 0;
d1900 1
a1900 1
		M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
d1903 1
a1903 1
		bcopy(&llc, mtod(m, caddr_t), LLC_SNAPFRAMELEN);
d1920 2
@


1.25.2.5
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.25.2.4 2001/05/14 22:39:59 niklas Exp $	*/
a35 1
#include "pf.h"
a53 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d63 4
d144 1
a144 1
#if NPF > 0
d271 1
a271 1
			/* Nothing needed */
d699 1
a699 1
		sc->sc_hashkey = arc4random();
d744 1
a744 6
	int s, error, len;
	short mflags;
	ALTQ_DECL(struct altq_pktattr pktattr;)
#ifdef IPSEC
	struct m_tag *mtag;
#endif /* IPSEC */
d773 1
a773 1
	if (dst_if == NULL || ETHER_IS_MULTICAST(eh->ether_dhost)) {
a777 23
#ifdef IPSEC
		/*
		 * Don't send out the packet if IPsec is needed, and
		 * notify IPsec to do its own crypto for now.
		 */
		if ((mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED,
		    NULL)) != NULL) {
			ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
			m_freem(m);
			splx(s);
			return (0);
		}
#endif /* IPSEC */

		/* Catch packets that need TCP/UDP/IP hardware checksumming */
		if (m->m_pkthdr.csum & M_IPV4_CSUM_OUT ||
		    m->m_pkthdr.csum & M_TCPV4_CSUM_OUT ||
		    m->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
			m_freem(m);
			splx(s);
			return (0);
		}

a781 3
#ifdef ALTQ
			if (ALTQ_IS_ENABLED(&dst_if->if_snd) == 0)
#endif
d797 1
a797 11
			len = mc->m_pkthdr.len;
			mflags = mc->m_flags;
#ifdef ALTQ
			if (ALTQ_IS_ENABLED(&dst_if->if_snd))
				altq_etherclassify(&dst_if->if_snd, mc, &pktattr);
#endif
			IFQ_ENQUEUE(&dst_if->if_snd, mc, &pktattr, error);
			if (error) {
				sc->sc_if.if_oerrors++;
				continue;
			}
d799 6
a804 4
			sc->sc_if.if_obytes += len;
			dst_if->if_obytes += len;
			if (mflags & M_MCAST)
				dst_if->if_omcasts++;
d820 2
a821 8
	len = m->m_pkthdr.len;
	mflags = m->m_flags;
#ifdef ALTQ
	if (ALTQ_IS_ENABLED(&dst_if->if_snd))
		altq_etherclassify(&dst_if->if_snd, m, &pktattr);
#endif
	IFQ_ENQUEUE(&dst_if->if_snd, m, &pktattr, error);
	if (error) {
d823 1
d828 5
a832 3
	sc->sc_if.if_obytes += len;
	dst_if->if_obytes += len;
	if (mflags & M_MCAST)
d880 1
a880 1
	int s, error, len;
a884 2
	short mflags;
	ALTQ_DECL(struct altq_pktattr pktattr;)
d898 1
d912 3
a914 3
	    (ifl->bif_state == BSTP_IFSTATE_BLOCKING ||
	    ifl->bif_state == BSTP_IFSTATE_LISTENING ||
	    ifl->bif_state == BSTP_IFSTATE_DISABLED)) {
d933 6
a938 3
	    !(eh.ether_shost[0] == 0 && eh.ether_shost[1] == 0 &&
	    eh.ether_shost[2] == 0 && eh.ether_shost[3] == 0 &&
	    eh.ether_shost[4] == 0 && eh.ether_shost[5] == 0))
d1005 1
a1005 1
#if NPF > 0
d1041 1
a1041 1
	    ifl->bif_state == BSTP_IFSTATE_BLOCKING)) {
a1048 6
#ifdef ALTQ
	if (ALTQ_IS_ENABLED(&dst_if->if_snd))
		altq_etherclassify(&dst_if->if_snd, m, &pktattr);
#endif
	len = m->m_pkthdr.len;
	mflags = m->m_flags;
d1050 2
a1051 2
	IFQ_ENQUEUE(&dst_if->if_snd, m, &pktattr, error);
	if (error) {
d1053 1
d1058 5
a1062 3
	sc->sc_if.if_obytes += len;
	dst_if->if_obytes += len;
	if (mflags & M_MCAST)
d1121 2
a1122 2
		    (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
		    (ifl->bif_state == BSTP_IFSTATE_DISABLED)))
d1167 2
a1168 2
	    (ifl->bif_state == BSTP_IFSTATE_LISTENING) ||
	    (ifl->bif_state == BSTP_IFSTATE_DISABLED)))
d1228 1
a1228 3
	int error, len, used = 0;
	short mflags;
	ALTQ_DECL(struct altq_pktattr pktattr;)
d1241 1
a1241 1
		    p->bif_state == BSTP_IFSTATE_DISABLED))
a1250 3
#ifdef ALTQ
		if (ALTQ_IS_ENABLED(&dst_if->if_snd) == 0)
#endif
a1256 5
		/* Drop non-IP frames if the appropriate flag is set. */
		if (p->bif_flags & IFBIF_BLOCKNONIP &&
		    bridge_blocknonip(eh, m))
			continue;

d1272 3
a1274 7
#ifdef ALTQ
		if (ALTQ_IS_ENABLED(&dst_if->if_snd))
			altq_etherclassify(&dst_if->if_snd, mc, &pktattr);
#endif
		IFQ_ENQUEUE(&dst_if->if_snd, mc, &pktattr, error);
		if (error) {
			sc->sc_if.if_oerrors++;
d1277 1
d1279 5
a1283 3
		sc->sc_if.if_obytes += len;
		dst_if->if_obytes += len;
		if (mflags & M_MCAST)
d1316 1
a1316 1
			sc->sc_hashkey = arc4random();
d1761 4
a1764 2
	    (etype == ETHERTYPE_ARP || etype == ETHERTYPE_REVARP ||
	    etype == ETHERTYPE_IP || etype == ETHERTYPE_IPV6)) {
d1850 2
a1851 1
#if NPF > 0
d1870 3
d1913 1
a1913 1
		if ((m = m_pullup(m, hlen)) == NULL)
d1938 2
a1939 2
	if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
		goto dropit;
@


1.25.2.6
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.25.2.5 2001/07/04 10:53:56 niklas Exp $	*/
d55 4
a69 9
#if NPF > 0
#include <net/pfvar.h>
#define	BRIDGE_IN	PF_IN
#define	BRIDGE_OUT	PF_OUT
#else
#define	BRIDGE_IN	0
#define	BRIDGE_OUT	1
#endif

a136 4
#if NPF > 0
struct mbuf *bridge_filter __P((struct bridge_softc *, int, struct ifnet *,
    struct ether_header *, struct mbuf *m));
#endif
d145 8
d1045 1
d1047 1
a1047 1
	m = bridge_filter(sc, BRIDGE_IN, src_if, &eh, m);
d1051 1
a1089 6
#if NPF > 0
	m = bridge_filter(sc, BRIDGE_OUT, dst_if, &eh, m);
	if (m == NULL)
		return;
#endif

a1325 6
#if NPF > 0
		mc = bridge_filter(sc, BRIDGE_OUT, dst_if, eh, mc);
		if (mc == NULL)
			continue;
#endif

d1897 1
a1897 1
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlout, p, brl_next);
d1911 1
a1911 1
bridge_filter(sc, dir, ifp, eh, m)
a1912 1
	int dir;
a1916 3
#if NPF == 0
	return (m);
#else
d1987 1
a1987 2
	m->m_pkthdr.rcvif = ifp;
	if (pf_test(dir, ifp, &m) != PF_PASS)
a2021 1
#endif /* NPF == 0 */
@


1.25.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2003 2
		goto dropit;
	if (m == NULL)
@


1.25.2.8
log
@Merge in trunk
@
text
@a59 1
#include <netinet/ip_var.h>
a119 2
void	bridge_span __P((struct bridge_softc *, struct ether_header *,
    struct mbuf *));
a177 1
		LIST_INIT(&sc->sc_spanlist);
a235 10
		/* If it's in the span list, it can't be a member. */
		LIST_FOREACH(p, &sc->sc_spanlist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p != LIST_END(&sc->sc_spanlist)) {
			error = EBUSY;
			break;
		}

a325 52
	case SIOCBRDGADDS:
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
		ifs = ifunit(req->ifbr_ifsname);
		if (ifs == NULL) {			/* no such interface */
			error = ENOENT;
			break;
		}
		if (ifs->if_bridge == (caddr_t)sc) {
			error = EEXIST;
			break;
		}
		if (ifs->if_bridge != NULL) {
			error = EBUSY;
			break;
		}
		LIST_FOREACH(p, &sc->sc_spanlist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p != LIST_END(&sc->sc_spanlist)) {
			error = EBUSY;
			break;
		}
		p = (struct bridge_iflist *)malloc(
		    sizeof(struct bridge_iflist), M_DEVBUF, M_NOWAIT);
		if (p == NULL) {
			error = ENOMEM;
			break;
		}
		bzero(p, sizeof(struct bridge_iflist));
		p->ifp = ifs;
		SIMPLEQ_INIT(&p->bif_brlin);
		SIMPLEQ_INIT(&p->bif_brlout);
		LIST_INSERT_HEAD(&sc->sc_spanlist, p, next);
		break;
	case SIOCBRDGDELS:
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
		LIST_FOREACH(p, &sc->sc_spanlist, next) {
			if (strncmp(p->ifp->if_xname, req->ifbr_ifsname,
			    sizeof(p->ifp->if_xname)) == 0) {
				LIST_REMOVE(p, next);
				free(p, M_DEVBUF);
				break;
			}
		}
		if (p == LIST_END(&sc->sc_spanlist)) {
			error = ENOENT;
			break;
		}
		break;
a368 4
		if (req->ifbr_ifsflags & IFBIF_RO_MASK) {
			error = EINVAL;
			break;
		}
a579 3
	LIST_FOREACH(p, &sc->sc_spanlist, next) {
		total++;
	}
a600 16
	LIST_FOREACH(p, &sc->sc_spanlist, next) {
		if (bifc->ifbic_len < sizeof(breq))
			break;
		strlcpy(breq.ifbr_name, sc->sc_if.if_xname, IFNAMSIZ);
		strlcpy(breq.ifbr_ifsname, p->ifp->if_xname, IFNAMSIZ);
		breq.ifbr_ifsflags = p->bif_flags | IFBIF_SPAN;
		breq.ifbr_state = p->bif_state;
		breq.ifbr_priority = p->bif_priority;
		breq.ifbr_portno = p->ifp->if_index & 0xff;
		error = copyout((caddr_t)&breq,
		    (caddr_t)(bifc->ifbic_req + i), sizeof(breq));
		if (error)
			goto done;
		i++;
		bifc->ifbic_len -= sizeof(breq);
	}
a807 2
		bridge_span(sc, NULL, m);

d824 2
a825 5
				struct mbuf *m1, *m2, *mx;

				m1 = m_copym2(m, 0, sizeof(struct ether_header),
				    M_DONTWAIT);
				if (m1 == NULL) {
a828 19
				m2 = m_copym2(m, sizeof(struct ether_header),
				    M_COPYALL, M_DONTWAIT);
				if (m2 == NULL) {
					m_freem(m1);
					sc->sc_if.if_oerrors++;
					continue;
				}

				for (mx = m1; mx->m_next != NULL; mx = mx->m_next)
					/*EMPTY*/;
				mx->m_next = m2;

				if (m1->m_flags & M_PKTHDR) {
					len = 0;
					for (mx = m1; mx != NULL; mx = mx->m_next)
						len += mx->m_len;
					m1->m_pkthdr.len = len;
				}
				mc = m1;
a855 1
	bridge_span(sc, NULL, m);
a1155 2
	bridge_span(sc, eh, m);

d1277 2
a1278 2
	int error, len = m->m_pkthdr.len, used = 0;
	short mflags = m->m_flags;
d1324 2
a1325 5
			struct mbuf *m1, *m2, *mx;

			m1 = m_copym2(m, 0, sizeof(struct ether_header),
			    M_DONTWAIT);
			if (m1 == NULL) {
a1328 20
			m2 = m_copym2(m, sizeof(struct ether_header),
			    M_COPYALL, M_DONTWAIT);
			if (m2 == NULL) {
				m_freem(m1);
				sc->sc_if.if_oerrors++;
				continue;
			}

			for (mx = m1; mx->m_next != NULL; mx = mx->m_next)
				/*EMPTY*/;
			mx->m_next = m2;

			if (m1->m_flags & M_PKTHDR) {
				int len = 0;

				for (mx = m1; mx != NULL; mx = mx->m_next)
					len += mx->m_len;
				m1->m_pkthdr.len = len;
			}
			mc = m1;
a1358 67
void
bridge_span(sc, eh, morig)
	struct bridge_softc *sc;
	struct ether_header *eh;
	struct mbuf *morig;
{
	struct bridge_iflist *p;
	struct ifnet *ifp;
	struct mbuf *mc, *m;
	int error;
	ALTQ_DECL(struct altq_pktattr pktattr;)

	if (LIST_EMPTY(&sc->sc_spanlist))
		return;

	m = m_copym2(morig, 0, M_COPYALL, M_NOWAIT);
	if (m == NULL)
		return;
	if (eh != NULL) {
		M_PREPEND(m, sizeof(struct ether_header), M_DONTWAIT);
		if (m == NULL)
			return;
		bcopy(eh, mtod(m, caddr_t), sizeof(struct ether_header));
	}

	LIST_FOREACH(p, &sc->sc_spanlist, next) {
		ifp = p->ifp;

		if ((ifp->if_flags & IFF_RUNNING) == 0)
			continue;

#ifdef ALTQ
		if (ALTQ_IS_ENABLED(&ifp->if_snd) == 0)
#endif
			if (IF_QFULL(&ifp->if_snd)) {
				IF_DROP(&ifp->if_snd);
				sc->sc_if.if_oerrors++;
				continue;
			}

		mc = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
		if (mc == NULL) {
			sc->sc_if.if_oerrors++;
			continue;
		}

#ifdef ALTQ
		if (ALTQ_IS_ENABLED(&ifp->if_snd))
			altq_etherclassify(&ifp->if_snd, mc, &pktattr);
#endif

		IFQ_ENQUEUE(&ifp->if_snd, mc, &pktattr, error);
		if (error) {
			sc->sc_if.if_oerrors++;
			continue;
		}
		sc->sc_if.if_opackets++;
		sc->sc_if.if_obytes += m->m_pkthdr.len;
		ifp->if_obytes += m->m_pkthdr.len;
		if (m->m_flags & M_MCAST)
			ifp->if_omcasts++;
		if ((ifp->if_flags & IFF_OACTIVE) == 0)
			(*ifp->if_start)(ifp);
	}
	m_freem(m);
}

d1929 3
d1966 1
a1966 2
	    (m = m_pullup(m, sizeof(struct ip))) == NULL) {
		ipstat.ips_toosmall++;
a1967 1
	}
d1970 1
a1970 2
	if (ip->ip_v != IPVERSION) {
		ipstat.ips_badvers++;
a1971 1
	}
d1974 1
a1974 2
	if (hlen < sizeof(struct ip)) {
		ipstat.ips_badhlen++;
a1975 1
	}
d1977 1
a1977 2
		if ((m = m_pullup(m, hlen)) == NULL) {
			ipstat.ips_badhlen++;
a1978 1
		}
d1982 1
a1982 2
	if ((ip->ip_sum = in_cksum(m, hlen)) != 0) {
		ipstat.ips_badsum++;
a1983 1
	}
d2040 1
d2042 1
a2042 1
#endif /* NPF > 0 */
@


1.25.2.9
log
@Merge in -current from roughly a week ago
@
text
@a66 5
#ifdef INET6
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

d115 30
a144 30
void	bridgeattach(int);
int	bridge_ioctl(struct ifnet *, u_long, caddr_t);
void	bridge_start(struct ifnet *);
void	bridgeintr_frame(struct bridge_softc *, struct mbuf *);
void	bridge_broadcast(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void	bridge_span(struct bridge_softc *, struct ether_header *,
    struct mbuf *);
void	bridge_stop(struct bridge_softc *);
void	bridge_init(struct bridge_softc *);
int	bridge_bifconf(struct bridge_softc *, struct ifbifconf *);

void	bridge_timer(void *);
int	bridge_rtfind(struct bridge_softc *, struct ifbaconf *);
void	bridge_rtage(struct bridge_softc *);
void	bridge_rttrim(struct bridge_softc *);
void	bridge_rtdelete(struct bridge_softc *, struct ifnet *);
int	bridge_rtdaddr(struct bridge_softc *, struct ether_addr *);
int	bridge_rtflush(struct bridge_softc *, int);
struct ifnet *	bridge_rtupdate(struct bridge_softc *,
    struct ether_addr *, struct ifnet *ifp, int, u_int8_t);
struct ifnet *	bridge_rtlookup(struct bridge_softc *,
    struct ether_addr *);
u_int32_t	bridge_hash(struct bridge_softc *, struct ether_addr *);
int bridge_blocknonip(struct ether_header *, struct mbuf *);
int		bridge_addrule(struct bridge_iflist *,
    struct ifbrlreq *, int out);
int		bridge_flushrule(struct bridge_iflist *);
int	bridge_brlconf(struct bridge_softc *, struct ifbrlconf *);
u_int8_t bridge_filterrule(struct brl_head *, struct ether_header *);
d146 2
a147 2
struct mbuf *bridge_filter(struct bridge_softc *, int, struct ifnet *,
    struct ether_header *, struct mbuf *m);
a2138 1
	u_int16_t etype;
d2140 1
a2140 3
	etype = ntohs(eh->ether_type);

	if (etype != ETHERTYPE_IP && etype != ETHERTYPE_IPV6) {
d2154 2
a2155 5
		    llc.llc_snap.org_code[2])
			return (m);

		etype = ntohs(llc.llc_snap.ether_type);
		if (etype != ETHERTYPE_IP && etype != ETHERTYPE_IPV6)
d2164 10
a2173 1
	switch (etype) {
d2175 4
a2178 3
	case ETHERTYPE_IP:
		if (m->m_pkthdr.len < sizeof(struct ip))
			goto dropit;
d2180 8
a2187 4
		/* Copy minimal header, and drop invalids */
		if (m->m_len < sizeof(struct ip) &&
		    (m = m_pullup(m, sizeof(struct ip))) == NULL) {
			ipstat.ips_toosmall++;
d2191 1
a2191 58
		
		if (ip->ip_v != IPVERSION) {
			ipstat.ips_badvers++;
			goto dropit;
		}
		
		hlen = ip->ip_hl << 2;	/* get whole header length */
		if (hlen < sizeof(struct ip)) {
			ipstat.ips_badhlen++;
			goto dropit;
		}
		if (hlen > m->m_len) {
			if ((m = m_pullup(m, hlen)) == NULL) {
				ipstat.ips_badhlen++;
				return (NULL);
			}
			ip = mtod(m, struct ip *);
		}
		
		if ((ip->ip_sum = in_cksum(m, hlen)) != 0) {
			ipstat.ips_badsum++;
			goto dropit;
		}
		
		NTOHS(ip->ip_len);
		if (ip->ip_len < hlen)
			goto dropit;
		NTOHS(ip->ip_id);
		NTOHS(ip->ip_off);
		
		if (m->m_pkthdr.len < ip->ip_len)
			goto dropit;
		if (m->m_pkthdr.len > ip->ip_len) {
			if (m->m_len == m->m_pkthdr.len) {
				m->m_len = ip->ip_len;
				m->m_pkthdr.len = ip->ip_len;
			} else
				m_adj(m, ip->ip_len - m->m_pkthdr.len);
		}
		
		/* Finally, we get to filter the packet! */
		m->m_pkthdr.rcvif = ifp;
		if (pf_test(dir, ifp, &m) != PF_PASS)
			goto dropit;
		if (m == NULL)
			goto dropit;
		
		/* Rebuild the IP header */
		if (m->m_len < hlen && ((m = m_pullup(m, hlen)) == NULL))
			return (NULL);
		if (m->m_len < sizeof(struct ip))
			goto dropit;
		ip = mtod(m, struct ip *);
		HTONS(ip->ip_len);
		HTONS(ip->ip_id);
		HTONS(ip->ip_off);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, hlen);
d2193 4
a2196 1
		break;
d2198 5
a2202 19
#ifdef INET6
	case ETHERTYPE_IPV6: {
		struct ip6_hdr *ip6;

		if (m->m_len < sizeof(struct ip6_hdr)) {
			if ((m = m_pullup(m, sizeof(struct ip6_hdr)))
			    == NULL) {
				ip6stat.ip6s_toosmall++;
				return (NULL);
			}
		}
		
		ip6 = mtod(m, struct ip6_hdr *);
		
		if ((ip6->ip6_vfc & IPV6_VERSION_MASK) != IPV6_VERSION) {
			ip6stat.ip6s_badvers++;
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
			goto dropit;
		}
d2204 8
a2211 6
		if (pf_test6(dir, ifp, &m) != PF_PASS)
			goto dropit;
		if (m == NULL)
			return (NULL);
		
		break;
d2213 12
a2224 3
#endif /* INET6 */
		
	default:
d2226 7
a2232 3
		break;
	}
	
@


1.25.2.10
log
@Sync the SMP branch with 3.3
@
text
@a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a36 1
#include "vlan.h"
d45 1
a61 4
#include <netinet/ip_icmp.h>
#endif

#ifdef IPSEC
a84 4
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

d136 1
a153 10
int	bridge_ifenqueue(struct bridge_softc *, struct ifnet *, struct mbuf *);
void	bridge_fragment(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
#ifdef INET
void	bridge_send_icmp_err(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *, int, struct llc *, int, int);
#endif
#ifdef IPSEC
int bridge_ipsec(int, int, int, struct mbuf *);
#endif
d161 1
a197 1
		if_alloc_sadl(ifp);
d331 1
a331 1
				bridge_rtdelete(sc, p->ifp, 0);
a417 1
		req->ifbr_path_cost = p->bif_path_cost;
a451 1
	case SIOCBRDGSIFCOST:
d471 1
a471 8
		if (cmd == SIOCBRDGSIFPRIO)
			p->bif_priority = req->ifbr_priority;
		else {
			if (req->ifbr_path_cost < 1)
				error = EINVAL;
			else
				p->bif_path_cost = req->ifbr_path_cost;
		}
d633 1
a633 1
			bridge_rtdelete(sc, ifp, 0);
a670 1
		breq.ifbr_path_cost = p->bif_path_cost;
a686 1
		breq.ifbr_path_cost = p->bif_path_cost;
d841 2
a907 16

			/*
			 * If this is not the original output interface,
			 * and the interface is participating in spanning
			 * tree, make sure the port is in a state that
			 * allows forwarding.
			 */
			if (dst_if != ifp &&
			    (p->bif_flags & IFBIF_STP) &&
			    (p->bif_state != BSTP_IFSTATE_FORWARDING))
				continue;

			if ((p->bif_flags & IFBIF_DISCOVER) == 0 &&
			    (m->m_flags & (M_BCAST | M_MCAST)) == 0)
				continue;

d948 9
a956 3

			error = bridge_ifenqueue(sc, dst_if, mc);
			if (error)
d958 8
d980 19
a998 1
	bridge_ifenqueue(sc, dst_if, m);
d1043 1
a1043 1
	int s, len;
d1048 2
d1214 4
d1219 5
a1223 5
	if ((len - sizeof(struct ether_header)) > dst_if->if_mtu)
		bridge_fragment(sc, dst_if, &eh, m);
	else {
		s = splimp();
		bridge_ifenqueue(sc, dst_if, m);
d1225 1
d1227 8
d1249 1
a1249 1
	struct bridge_iflist *ifl, *srcifl;
a1344 1
	srcifl = ifl;
d1350 1
a1350 1
			if (srcifl->bif_flags & IFBIF_LEARNING)
d1398 3
a1400 3
	int len = m->m_pkthdr.len, used = 0;

	splassert(IPL_NET);
d1412 2
a1413 1
		    (p->bif_state != BSTP_IFSTATE_FORWARDING))
d1481 8
a1488 4
		if ((len - sizeof(struct ether_header)) > dst_if->if_mtu)
			bridge_fragment(sc, dst_if, eh, mc);
		else {
			bridge_ifenqueue(sc, dst_if, mc);
d1490 7
d1513 1
d1549 8
a1556 2
		error = bridge_ifenqueue(sc, ifp, mc);
		if (error)
d1558 8
d1730 1
a1730 1
	} while (0)
d1923 1
a1923 1
bridge_rtdelete(sc, ifp, dynonly)
a1925 1
	int dynonly;
d1940 7
a1946 8
			if (n->brt_if != ifp) {
				/* Not ours */
				n = LIST_NEXT(n, brt_next);
				continue;
			}
			if (dynonly &&
			    (n->brt_flags & IFBAF_TYPEMASK) != IFBAF_DYNAMIC) {
				/* only deleting dynamics */
a1947 7
				continue;
			}
			p = LIST_NEXT(n, brt_next);
			LIST_REMOVE(n, brt_next);
			sc->sc_brtcnt--;
			free(n, M_DEVBUF);
			n = p;
d1964 1
a1964 1
	int i, error = 0, onlycnt = 0;
d1969 1
a1969 1
	if (sc->sc_rts == NULL)
a1971 3
	if (baconf->ifbac_len == 0)
		onlycnt = 1;

d1974 14
a1987 17
			if (!onlycnt) {
				if (baconf->ifbac_len < sizeof(struct ifbareq))
					goto done;
				bcopy(sc->sc_if.if_xname, bareq.ifba_name,
				    sizeof(bareq.ifba_name));
				bcopy(n->brt_if->if_xname, bareq.ifba_ifsname,
				    sizeof(bareq.ifba_ifsname));
				bcopy(&n->brt_addr, &bareq.ifba_dst,
				    sizeof(bareq.ifba_dst));
				bareq.ifba_age = n->brt_age;
				bareq.ifba_flags = n->brt_flags;
				error = copyout((caddr_t)&bareq,
				    (caddr_t)(baconf->ifbac_req + cnt), sizeof(bareq));
				if (error)
					goto done;
				baconf->ifbac_len -= sizeof(struct ifbareq);
			}
d1989 1
a2124 192
#ifdef IPSEC
int
bridge_ipsec(dir, af, hlen, m)
	int dir, af, hlen;
	struct mbuf *m;
{
	union sockaddr_union dst;
	struct timeval tv;
	struct tdb *tdb;
	u_int32_t spi;
	u_int16_t cpi;
	int error, off;
	u_int8_t proto = 0;
#ifdef INET
	struct ip *ip;
#endif /* INET */
#ifdef INET6
	struct ip6_hdr *ip6;
#endif /* INET6 */

	if (dir == BRIDGE_IN) {
		switch (af) {
#ifdef INET
		case AF_INET:
			if (m->m_pkthdr.len - hlen < 2 * sizeof(u_int32_t))
				break;

			ip = mtod(m, struct ip *);
			proto = ip->ip_p;
			off = offsetof(struct ip, ip_p);

			if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
			    proto != IPPROTO_IPCOMP)
				goto skiplookup;

			bzero(&dst, sizeof(union sockaddr_union));
			dst.sa.sa_family = AF_INET;
			dst.sin.sin_len = sizeof(struct sockaddr_in);
			m_copydata(m, offsetof(struct ip, ip_dst),
			    sizeof(struct in_addr),
			    (caddr_t)&dst.sin.sin_addr);

			if (ip->ip_p == IPPROTO_ESP)
				m_copydata(m, hlen, sizeof(u_int32_t),
				    (caddr_t)&spi);
			else if (ip->ip_p == IPPROTO_AH)
				m_copydata(m, hlen + sizeof(u_int32_t),
				    sizeof(u_int32_t), (caddr_t)&spi);
			else if (ip->ip_p == IPPROTO_IPCOMP) {
				m_copydata(m, hlen + sizeof(u_int16_t),
				    sizeof(u_int16_t), (caddr_t)&cpi);
				spi = ntohl(htons(cpi));
			}
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			if (m->m_pkthdr.len - hlen < 2 * sizeof(u_int32_t))
				break;

			ip6 = mtod(m, struct ip6_hdr *);

			/* XXX We should chase down the header chain */
			proto = ip6->ip6_nxt;
			off = offsetof(struct ip6_hdr, ip6_nxt);

			if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
			    proto != IPPROTO_IPCOMP)
				goto skiplookup;

			bzero(&dst, sizeof(union sockaddr_union));
			dst.sa.sa_family = AF_INET6;
			dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
			m_copydata(m, offsetof(struct ip6_hdr, ip6_nxt),
			    sizeof(struct in6_addr),
			    (caddr_t)&dst.sin6.sin6_addr);

			if (proto == IPPROTO_ESP)
				m_copydata(m, hlen, sizeof(u_int32_t),
				    (caddr_t)&spi);
			else if (proto == IPPROTO_AH)
				m_copydata(m, hlen + sizeof(u_int32_t),
				    sizeof(u_int32_t), (caddr_t)&spi);
			else if (proto == IPPROTO_IPCOMP) {
				m_copydata(m, hlen + sizeof(u_int16_t),
				    sizeof(u_int16_t), (caddr_t)&cpi);
				spi = ntohl(htons(cpi));
			}
			break;
#endif /* INET6 */
		default:
			return (0);
		}

		if (proto == 0)
			goto skiplookup;

		tdb = gettdb(spi, &dst, proto);
		if (tdb != NULL && (tdb->tdb_flags & TDBF_INVALID) == 0 &&
		    tdb->tdb_xform != NULL) {
			if (tdb->tdb_first_use == 0) {
				int pri;

				pri = splhigh();
				tdb->tdb_first_use = time.tv_sec;
				splx(pri);

				tv.tv_usec = 0;

				/* Check for wrap-around. */
				if (tdb->tdb_exp_first_use + tdb->tdb_first_use
				    < tdb->tdb_first_use)
					tv.tv_sec = ((unsigned long)-1) / 2;
				else
					tv.tv_sec = tdb->tdb_exp_first_use +
					    tdb->tdb_first_use;

				if (tdb->tdb_flags & TDBF_FIRSTUSE)
					timeout_add(&tdb->tdb_first_tmo,
					    hzto(&tv));

				/* Check for wrap-around. */
				if (tdb->tdb_first_use +
				    tdb->tdb_soft_first_use
				    < tdb->tdb_first_use)
					tv.tv_sec = ((unsigned long)-1) / 2;
				else
					tv.tv_sec = tdb->tdb_first_use +
					    tdb->tdb_soft_first_use;

				if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
					timeout_add(&tdb->tdb_sfirst_tmo,
					    hzto(&tv));
			}

			(*(tdb->tdb_xform->xf_input))(m, tdb, hlen, off);
			return (1);
		} else {
 skiplookup:
			/* XXX do an input policy lookup */
			return (0);
		}
	} else { /* Outgoing from the bridge. */
		tdb = ipsp_spd_lookup(m, af, hlen, &error,
		    IPSP_DIRECTION_OUT, NULL, NULL);
		if (tdb != NULL) {
			/*
			 * We don't need to do loop detection, the
			 * bridge will do that for us.
			 */
#if NPF > 0
			switch (af) {
#ifdef INET
			case AF_INET:
				if (pf_test(dir, &encif[0].sc_if,
				    &m) != PF_PASS) {
					m_freem(m);
					return (1);
				}
				break;
#endif /* INET */
#ifdef INET6
			case AF_INET6:
				if (pf_test6(dir, &encif[0].sc_if,
				    &m) != PF_PASS) {
					m_freem(m);
					return (1);
				}
				break;
#endif /* INET6 */
			}
			if (m == NULL)
				return (1);
#endif /* NPF */
#ifdef INET
			if (af == AF_INET) {
				ip = mtod(m, struct ip *);
				HTONS(ip->ip_len);
				HTONS(ip->ip_id);
				HTONS(ip->ip_off);
			}
#endif /* INET */
			error = ipsp_process_packet(m, tdb, af, 0);
			return (1);
		} else
			return (0);
	}

	return (0);
}
#endif /* IPSEC */

d2149 1
a2149 1
		if (etype > ETHERMTU ||
d2188 1
a2188 1

d2193 1
a2193 1

a2198 1

d2206 1
a2206 1

d2211 1
a2211 1

d2217 1
a2217 1

d2227 1
a2227 8

#ifdef IPSEC
		if ((sc->sc_if.if_flags & IFF_LINK2) == IFF_LINK2 &&
		    bridge_ipsec(dir, AF_INET, hlen, m))
			return (NULL);
#endif /* IPSEC */

#if NPF > 0
d2234 1
a2234 2
#endif /* NPF */

d2260 1
a2260 1

d2262 1
a2262 1

a2268 9
#ifdef IPSEC
		hlen = sizeof(struct ip6_hdr);

		if ((sc->sc_if.if_flags & IFF_LINK2) == IFF_LINK2 &&
		    bridge_ipsec(dir, AF_INET6, hlen, m))
			return (NULL);
#endif /* IPSEC */

#if NPF > 0
d2273 1
a2273 2
#endif /* NPF */

d2277 1
a2277 1

d2282 1
a2282 1

a2304 225

void
bridge_fragment(sc, ifp, eh, m)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *m;
{
	struct llc llc;
	struct mbuf *m0;
	int s, len, error = 0;
	int hassnap = 0;
#ifdef INET
	u_int16_t etype;
	struct ip *ip;
#endif

#ifndef INET
	goto dropit;
#else
	etype = ntohs(eh->ether_type);
#if NVLAN > 0
	if (etype == ETHERTYPE_8021Q &&
	    (ifp->if_capabilities & IFCAP_VLAN_MTU) &&
	    ((m->m_pkthdr.len - sizeof(struct ether_vlan_header)) <=
	    ifp->if_mtu)) {
		s = splimp();
		bridge_ifenqueue(sc, ifp, m);
		splx(s);
		return;
	}
#endif
	if (etype != ETHERTYPE_IP) {
		if (etype > ETHERMTU ||
		    m->m_pkthdr.len < (LLC_SNAPFRAMELEN +
		    sizeof(struct ether_header)))
			goto dropit;

		m_copydata(m, sizeof(struct ether_header),
		    LLC_SNAPFRAMELEN, (caddr_t)&llc);

		if (llc.llc_dsap != LLC_SNAP_LSAP ||
		    llc.llc_ssap != LLC_SNAP_LSAP ||
		    llc.llc_control != LLC_UI ||
		    llc.llc_snap.org_code[0] ||
		    llc.llc_snap.org_code[1] ||
		    llc.llc_snap.org_code[2] ||
		    llc.llc_snap.ether_type != htons(ETHERTYPE_IP))
			goto dropit;

		hassnap = 1;
	}

	m_adj(m, sizeof(struct ether_header));
	if (hassnap)
		m_adj(m, LLC_SNAPFRAMELEN);

	if (m->m_len < sizeof(struct ip) &&
	    (m = m_pullup(m, sizeof(struct ip))) == NULL)
		goto dropit;
	ip = mtod(m, struct ip *);
	NTOHS(ip->ip_len);
	NTOHS(ip->ip_off);

	/* Respect IP_DF, return a ICMP_UNREACH_NEEDFRAG. */
	if (ip->ip_off & IP_DF) {
		bridge_send_icmp_err(sc, ifp, eh, m, hassnap, &llc,
		    ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG);
		return;
	}

	error = ip_fragment(m, ifp, ifp->if_mtu);
	if (error == EMSGSIZE)
		goto dropit;

	for (; m; m = m0) {
		m0 = m->m_nextpkt;
		m->m_nextpkt = NULL;
		if (error == 0) {
			if (hassnap) {
				M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
				if (m == NULL) {
					error = ENOBUFS;
					continue;
				}
				bcopy(&llc, mtod(m, caddr_t),
				    LLC_SNAPFRAMELEN);
			}
			M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
			if (m == NULL) {
				error = ENOBUFS;
				continue;
			}
			len = m->m_pkthdr.len;
			bcopy(eh, mtod(m, caddr_t), sizeof(*eh));
			s = splimp();
			error = bridge_ifenqueue(sc, ifp, m);
			if (error) {
				splx(s);
				continue;
			}
			splx(s);
		} else
			m_freem(m);
	}

	if (error == 0)
		ipstat.ips_fragmented++;

	return;
#endif /* INET */
 dropit:
	if (m != NULL)
		m_freem(m);
}

int
bridge_ifenqueue(sc, ifp, m)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct mbuf *m;
{
	int error, len;
	short mflags;

	len = m->m_pkthdr.len;
	mflags = m->m_flags;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		sc->sc_if.if_oerrors++;
		return (error);
	}
	sc->sc_if.if_opackets++;
	sc->sc_if.if_obytes += len;
	ifp->if_obytes += len;
	if (mflags & M_MCAST)
		ifp->if_omcasts++;
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);

	return (0);
}

#ifdef INET
void
bridge_send_icmp_err(sc, ifp, eh, n, hassnap, llc, type, code)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *n;
	int hassnap;
	struct llc *llc;
	int type;
	int code;
{
	struct ip *ip;
	struct icmp *icp;
	struct in_addr t;
	struct mbuf *m, *n2;
	int hlen;
	u_int8_t ether_tmp[ETHER_ADDR_LEN];

	n2 = m_copym(n, 0, M_COPYALL, M_DONTWAIT);
	if (!n2) {
		m_freem(n);
		return;
	}
	m = icmp_do_error(n, type, code, 0, ifp);
	if (m == NULL) {
		m_freem(n2);
		return;
	}

	n = n2;

	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
	t = ip->ip_dst;
	ip->ip_dst = ip->ip_src;
	ip->ip_src = t;

	m->m_data += hlen;
	m->m_len -= hlen;
	icp = mtod(m, struct icmp *);
	icp->icmp_cksum = 0;
	icp->icmp_cksum = in_cksum(m, ip->ip_len - hlen);
	m->m_data -= hlen;
	m->m_len += hlen;

	ip->ip_v = IPVERSION;
	ip->ip_off &= IP_DF;
	ip->ip_id = htons(ip_randomid());
	ip->ip_ttl = MAXTTL;
	HTONS(ip->ip_len);
	HTONS(ip->ip_off);
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, hlen);

	/* Swap ethernet addresses */
	bcopy(&eh->ether_dhost, &ether_tmp, sizeof(ether_tmp));
	bcopy(&eh->ether_shost, &eh->ether_dhost, sizeof(ether_tmp));
	bcopy(&ether_tmp, &eh->ether_shost, sizeof(ether_tmp));

	/* Reattach SNAP header */
	if (hassnap) {
		M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
		if (m == NULL)
			goto dropit;
		bcopy(llc, mtod(m, caddr_t), LLC_SNAPFRAMELEN);
	}

	/* Reattach ethernet header */
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
		goto dropit;
	bcopy(eh, mtod(m, caddr_t), sizeof(*eh));

	bridge_output(ifp, m, NULL, NULL);
	m_freem(n);
	return;

 dropit:
	m_freem(n);
}
#endif
@


1.25.2.11
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.25.2.10 2003/03/28 00:41:28 niklas Exp $	*/
d209 1
a209 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "bridge%d", i);
d2124 1
a2124 1
	int error, off, s;
a2209 2
		s = spltdb();

a2248 1
			splx(s);
a2252 1
			splx(s);
@


1.25.2.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.25.2.11 2003/05/13 19:36:15 ho Exp $	*/
d15 5
d184 2
a185 1
bridgeattach(int n)
d228 4
a231 1
bridge_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
d268 1
a268 1
		LIST_FOREACH(p, &sc->sc_spanlist, next)
d271 1
a271 1

a550 5
		if (bparam->ifbrp_ctime < 0 ||
		    bparam->ifbrp_ctime > INT_MAX / hz) {
			error = EINVAL;
			break;
		}
d655 2
a656 1
bridge_ifdetach(struct ifnet *ifp)
d661 1
a661 1
	LIST_FOREACH(bif, &sc->sc_iflist, next)
d670 1
d674 3
a676 1
bridge_bifconf(struct bridge_softc *sc, struct ifbifconf *bifc)
d683 1
a683 1
	LIST_FOREACH(p, &sc->sc_iflist, next)
d685 2
a686 2

	LIST_FOREACH(p, &sc->sc_spanlist, next)
d688 1
a688 1

d735 3
a737 1
bridge_brlconf(struct bridge_softc *sc, struct ifbrlconf *bc)
d810 2
a811 1
bridge_init(struct bridge_softc *sc)
d840 2
a841 1
bridge_stop(struct bridge_softc *sc)
d863 5
a867 2
bridge_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *sa,
    struct rtentry *rt)
d1022 2
a1023 1
bridge_start(struct ifnet *ifp)
d1054 3
a1056 1
bridgeintr_frame(struct bridge_softc *sc, struct mbuf *m)
d1079 1
a1079 1
	LIST_FOREACH(ifl, &sc->sc_iflist, next)
d1082 1
a1082 1

d1242 4
a1245 1
bridge_input(struct ifnet *ifp, struct ether_header *eh, struct mbuf *m)
d1390 5
a1394 2
bridge_broadcast(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
d1493 4
a1496 2
bridge_span(struct bridge_softc *sc, struct ether_header *eh,
    struct mbuf *morig)
d1545 6
a1550 2
bridge_rtupdate(struct bridge_softc *sc, struct ether_addr *ea,
    struct ifnet *ifp, int setflags, u_int8_t flags)
d1664 3
a1666 1
bridge_rtlookup(struct bridge_softc *sc, struct ether_addr *ea)
d1707 3
a1709 1
bridge_hash(struct bridge_softc *sc, struct ether_addr *addr)
d1729 2
a1730 1
bridge_rttrim(struct bridge_softc *sc)
d1776 2
a1777 1
bridge_timer(void *vsc)
d1791 2
a1792 1
bridge_rtage(struct bridge_softc *sc)
d1829 3
a1831 1
bridge_rtflush(struct bridge_softc *sc, int full)
d1866 3
a1868 1
bridge_rtdaddr(struct bridge_softc *sc, struct ether_addr *ea)
d1897 4
a1900 1
bridge_rtdelete(struct bridge_softc *sc, struct ifnet *ifp, int dynonly)
d1943 3
a1945 1
bridge_rtfind(struct bridge_softc *sc, struct ifbaconf *baconf)
d1990 3
a1992 1
bridge_blocknonip(struct ether_header *eh, struct mbuf *m)
d2035 3
a2037 1
bridge_filterrule(struct brl_head *h, struct ether_header *eh)
d2068 4
a2071 1
bridge_addrule(struct bridge_iflist *bif, struct ifbrlreq *req, int out)
d2095 2
a2096 1
bridge_flushrule(struct bridge_iflist *bif)
d2115 3
a2117 1
bridge_ipsec(int dir, int af, int hlen, struct mbuf *m)
d2317 6
a2322 2
bridge_filter(struct bridge_softc *sc, int dir, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
d2510 5
a2514 2
bridge_fragment(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *m)
d2625 4
a2628 1
bridge_ifenqueue(struct bridge_softc *sc, struct ifnet *ifp, struct mbuf *m)
d2653 9
a2661 3
bridge_send_icmp_err(struct bridge_softc *sc, struct ifnet *ifp,
    struct ether_header *eh, struct mbuf *n, int hassnap, struct llc *llc,
    int type, int code)
@


1.25.2.13
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 3
d156 1
a156 2
u_int8_t bridge_filterrule(struct brl_head *, struct ether_header *,
    struct mbuf *);
a170 2
int     bridge_clone_create(struct if_clone *, int);
int	bridge_clone_destroy(struct ifnet *ifp);
a177 6
LIST_HEAD(, bridge_softc) bridge_list;

struct if_clone bridge_cloner =
    IF_CLONE_INITIALIZER("bridge", bridge_clone_create, bridge_clone_destroy);

/* ARGSUSED */
a180 7
	LIST_INIT(&bridge_list);
	if_clone_attach(&bridge_cloner);
}

int
bridge_clone_create(struct if_clone *ifc, int unit)
{
d183 1
a183 1
	int s;
d185 29
a213 28
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
	if (!sc)
		return (ENOMEM);
	bzero(sc, sizeof(*sc));

	sc->sc_brtmax = BRIDGE_RTABLE_MAX;
	sc->sc_brttimeout = BRIDGE_RTABLE_TIMEOUT;
	sc->sc_bridge_max_age = BSTP_DEFAULT_MAX_AGE;
	sc->sc_bridge_hello_time = BSTP_DEFAULT_HELLO_TIME;
	sc->sc_bridge_forward_delay= BSTP_DEFAULT_FORWARD_DELAY;
	sc->sc_bridge_priority = BSTP_DEFAULT_BRIDGE_PRIORITY;
	sc->sc_hold_time = BSTP_DEFAULT_HOLD_TIME;
	timeout_set(&sc->sc_brtimeout, bridge_timer, sc);
	LIST_INIT(&sc->sc_iflist);
	LIST_INIT(&sc->sc_spanlist);
	ifp = &sc->sc_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name, 
	    unit);
	ifp->if_softc = sc;
	ifp->if_mtu = ETHERMTU;
	ifp->if_ioctl = bridge_ioctl;
	ifp->if_output = bridge_output;
	ifp->if_start = bridge_start;
	ifp->if_type = IFT_BRIDGE;
	ifp->if_snd.ifq_maxlen = ifqmaxlen;
	ifp->if_hdrlen = sizeof(struct ether_header);
	if_attach(ifp);
	if_alloc_sadl(ifp);
d215 2
a216 2
	bpfattach(&sc->sc_if.if_bpf, ifp,
	    DLT_EN10MB, sizeof(struct ether_header));
a217 27
	s = splnet();
	LIST_INSERT_HEAD(&bridge_list, sc, sc_list);
	splx(s);

	return (0);
}

int
bridge_clone_destroy(struct ifnet *ifp)
{
	struct bridge_softc *sc = ifp->if_softc;
	struct bridge_iflist *bif;
	int s;

	bridge_stop(sc);
	while ((bif = LIST_FIRST(&sc->sc_iflist)) != NULL) {
		/* XXX shared with ioctl and detach */
		/* XXX promisc disable? */
		LIST_REMOVE(bif, next);
		bridge_rtdelete(sc, bif->ifp, 0);
		bridge_flushrule(bif);
		bif->ifp->if_bridge = NULL;
		free(bif, M_DEVBUF);
	}
	while ((bif = LIST_FIRST(&sc->sc_spanlist)) != NULL) {
		LIST_REMOVE(bif, next);
		free(bif, M_DEVBUF);
a218 12

	s = splnet();
	LIST_REMOVE(sc, sc_list);
	splx(s);

#if NBPFILTER > 0
	bpfdetach(ifp);
#endif  
	if_detach(ifp);

	free(sc, M_DEVBUF);
	return (0);
d241 1
a241 1
		if ((error = suser(prc, 0)) != 0)
d333 1
a333 1
		if ((error = suser(prc, 0)) != 0)
d359 1
a359 1
		if ((error = suser(prc, 0)) != 0)
d395 1
a395 1
		if ((error = suser(prc, 0)) != 0)
d435 1
a435 1
		if ((error = suser(prc, 0)) != 0)
d467 1
a467 1
		if ((error = suser(prc, 0)) != 0)
d499 1
a499 1
		if ((error = suser(prc, 0)) != 0)
d505 1
a505 1
		if ((error = suser(prc, 0)) != 0)
d526 1
a526 1
		if ((error = suser(prc, 0)) != 0)
d534 1
a534 1
		if ((error = suser(prc, 0)) != 0)
d540 1
a540 1
		if ((error = suser(prc, 0)) != 0)
d564 1
a564 1
		if ((error = suser(prc, 0)) != 0)
d602 1
a602 1
		if ((error = suser(prc, 0)) != 0)
d636 1
a636 1
		error = suser(prc, 0);
a768 5
#if NPF > 0
		req.ifbr_tagname[0] = '\0';
		if (n->brl_tag)
			pf_tag2tagname(n->brl_tag, req.ifbr_tagname);
#endif
a785 5
#if NPF > 0
		req.ifbr_tagname[0] = '\0';
		if (n->brl_tag)
			pf_tag2tagname(n->brl_tag, req.ifbr_tagname);
#endif
a819 1
	bstp_initialization(sc);
d1019 1
a1019 1
	int s;
d1021 2
a1022 1
	LIST_FOREACH(sc, &bridge_list, sc_list) {
d1156 1
a1156 1
	if (bridge_filterrule(&ifl->bif_brlin, &eh, m) == BRL_ACTION_BLOCK) {
d1199 1
a1199 1
	if (bridge_filterrule(&ifl->bif_brlout, &eh, m) == BRL_ACTION_BLOCK) {
d1413 1
a1413 1
		if (bridge_filterrule(&p->bif_brlout, eh, m) == BRL_ACTION_BLOCK)
d1987 1
a1987 1
bridge_filterrule(struct brl_head *h, struct ether_header *eh, struct mbuf *m)
d1995 1
a1995 1
			goto return_action;
d1999 1
a1999 1
			if (bcmp(eh->ether_dhost, &n->brl_dst, ETHER_ADDR_LEN))
d2001 1
a2001 1
			goto return_action;
d2006 1
a2006 1
			goto return_action;
d2011 1
a2011 1
			goto return_action;
a2014 6

return_action:
#if NPF > 0
	pf_tag_packet(m, NULL, n->brl_tag);
#endif
	return (n->brl_action);
a2028 6
#if NPF > 0
	if (req->ifbr_tagname[0])
		n->brl_tag = pf_tagname2tag(req->ifbr_tagname);
	else
		n->brl_tag = 0;
#endif
a2048 3
#if NPF > 0
		pf_tag_unref(p->brl_tag);
#endif
a2053 3
#if NPF > 0
		pf_tag_unref(p->brl_tag);
#endif
d2235 8
d2337 2
a2338 1
		if (ntohs(ip->ip_len) < hlen)
d2340 2
d2343 1
a2343 1
		if (m->m_pkthdr.len < ntohs(ip->ip_len))
d2345 1
a2345 1
		if (m->m_pkthdr.len > ntohs(ip->ip_len)) {
d2347 2
a2348 2
				m->m_len = ntohs(ip->ip_len);
				m->m_pkthdr.len = ntohs(ip->ip_len);
d2350 1
a2350 1
				m_adj(m, ntohs(ip->ip_len) - m->m_pkthdr.len);
d2374 3
d2506 2
d2510 1
a2510 1
	if (ip->ip_off & htons(IP_DF)) {
d2517 1
a2517 1
	if (error)
d2621 1
a2621 1
	icp->icmp_cksum = in_cksum(m, ntohs(ip->ip_len) - hlen);
d2626 1
a2626 1
	ip->ip_off &= htons(IP_DF);
d2629 2
@


1.25.2.14
log
@Merge with the trunk
@
text
@a1394 5
			if (bridge_filterrule(&srcifl->bif_brlin, eh, m) ==
			    BRL_ACTION_BLOCK) {
				m_freem(m);
				return (NULL);
			}
d2121 1
a2121 1
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlin, brl_next);
d2129 1
a2129 1
		SIMPLEQ_REMOVE_HEAD(&bif->bif_brlout, brl_next);
d2430 1
a2430 1
		if (pf_test_eh(dir, ifp, &m, eh) != PF_PASS)
d2476 1
a2476 1
		if (pf_test6_eh(dir, ifp, &m, eh) != PF_PASS)
d2580 1
a2580 2
	if (error) {
		m = NULL;
a2581 1
	}
@


1.24
log
@Don't allow enc0 to be added to a bridge, as it's used for all
non-bound SAs...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.23 2000/01/15 05:02:46 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Jason L. Wright (jason@@thought.net)
d107 11
d122 2
d164 1
d183 5
d195 1
d250 2
d335 2
d354 1
d473 64
d557 1
d607 87
a849 3
/*
 * Loop through each bridge interface and process their input queues.
 */
a852 1
	int i, s;
a853 4
	struct ifnet *bifp, *src_if, *dst_if;
	struct bridge_iflist *ifl;
	struct ether_addr *dst, *src;
	struct ether_header *eh;
d855 1
a858 1
		bifp = &sc->sc_if;
d861 1
a861 1
			IF_DEQUEUE(&bifp->if_snd, m);
d865 4
d870 20
a889 5
			src_if = m->m_pkthdr.rcvif;
			if ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {
				m_freem(m);
				continue;
			}
d892 2
a893 2
			if (sc->sc_if.if_bpf)
				bpf_mtap(sc->sc_if.if_bpf, m);
d896 48
a943 12
			sc->sc_if.if_lastchange = time;
			sc->sc_if.if_ipackets++;
			sc->sc_if.if_ibytes += m->m_pkthdr.len;

			ifl = LIST_FIRST(&sc->sc_iflist);
			while (ifl != NULL && ifl->ifp != src_if) {
				ifl = LIST_NEXT(ifl, next);
			}
			if (ifl == NULL) {
				m_freem(m);
				continue;
			}
d945 29
a973 33
			if (m->m_len < sizeof(*eh)) {
				m = m_pullup(m, sizeof(*eh));
				if (m == NULL)
					continue;
			}
			eh = mtod(m, struct ether_header *);
			dst = (struct ether_addr *)&eh->ether_dhost[0];
			src = (struct ether_addr *)&eh->ether_shost[0];

			/*
			 * If interface is learning, and if source address
			 * is not broadcast or multicast, record it's address.
	 		 */
			if ((ifl->bif_flags & IFBIF_LEARNING) &&
			    (eh->ether_shost[0] & 1) == 0 &&
			    !(eh->ether_shost[0] == 0 &&
			      eh->ether_shost[1] == 0 &&
			      eh->ether_shost[2] == 0 &&
			      eh->ether_shost[3] == 0 &&
			      eh->ether_shost[4] == 0 &&
			      eh->ether_shost[5] == 0))
				bridge_rtupdate(sc, src, src_if, 0, IFBAF_DYNAMIC);

			/*
			 * If packet is unicast, destined for someone on "this"
			 * side of the bridge, drop it.
			 */
			dst_if = bridge_rtlookup(sc, dst);
			if ((m->m_flags & (M_BCAST | M_MCAST)) == 0 &&
			    dst_if == src_if) {
				m_freem(m);
				continue;
			}
d975 8
a982 29
			/*
			 * Multicast packets get handled a little differently:
			 * If interface is:
			 *	-link0,-link1	(default) Forward all multicast
			 *			as broadcast.
			 *	-link0,link1	Drop non-IP multicast, forward
			 *			as broadcast IP multicast.
			 *	link0,-link1	Drop IP multicast, forward as
			 *			broadcast non-IP multicast.
			 *	link0,link1	Drop all multicast.
			 */
			if (m->m_flags & M_MCAST) {
				if ((sc->sc_if.if_flags &
				    (IFF_LINK0 | IFF_LINK1)) ==
				    (IFF_LINK0 | IFF_LINK1)) {
					m_freem(m);
					continue;
				}
				if (sc->sc_if.if_flags & IFF_LINK0 &&
				    ETHERADDR_IS_IP_MCAST(dst)) {
					m_freem(m);
					continue;
				}
				if (sc->sc_if.if_flags & IFF_LINK1 &&
				    !ETHERADDR_IS_IP_MCAST(dst)) {
					m_freem(m);
					continue;
				}
			}
d984 6
a989 8
			if (ifl->bif_flags & IFBIF_BLOCKNONIP) {
				m = bridge_blocknonip(m);
				if (m == NULL)
					continue;
				eh = mtod(m, struct ether_header *);
				dst = (struct ether_addr *)&eh->ether_dhost[0];
				src = (struct ether_addr *)&eh->ether_shost[0];
			}
d992 5
a996 6
			if (bridge_filter(sc, src_if, eh, &m) ==
			    BRIDGE_FILTER_DROP) {
				if (m != NULL)
					m_freem(m);
				continue;
			}
d999 9
a1007 9
			/*
			 * If the packet is a multicast or broadcast, then
			 * forward it to all interfaces.
			 */
			if (m->m_flags & (M_BCAST | M_MCAST)) {
				bifp->if_imcasts++;
				bridge_broadcast(sc, src_if, eh, m);
				continue;
			}
d1009 23
a1031 24
			if (dst_if != NULL) {
				if ((dst_if->if_flags & IFF_RUNNING) == 0) {
					m_freem(m);
					continue;
				}
				s = splimp();
				if (IF_QFULL(&dst_if->if_snd)) {
					sc->sc_if.if_oerrors++;
					m_freem(m);
					splx(s);
					continue;
				}
				sc->sc_if.if_opackets++;
				sc->sc_if.if_obytes += m->m_pkthdr.len;
				IF_ENQUEUE(&dst_if->if_snd, m);
				if ((dst_if->if_flags & IFF_OACTIVE) == 0)
					(*dst_if->if_start)(dst_if);
				splx(s);
				continue;
			}

			bridge_broadcast(sc, src_if, eh, m);
			dst_if = NULL;
		}
d1033 6
d1169 6
d1699 83
@


1.23
log
@Handle the SNAP encapsulated IP/Non-IP case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.22 2000/01/10 22:18:29 angelos Exp $	*/
d36 1
d63 3
d291 8
a298 1
		else if (ifs->if_type != IFT_ENC) {
@


1.22
log
@Implement the blocknonip flag
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.21 1999/11/04 05:13:14 jason Exp $	*/
d134 8
d164 1
d774 7
a780 7
			if ((ifl->bif_flags & IFBIF_BLOCKNONIP) &&
			    (eh->ether_type != htons(ETHERTYPE_IP)) &&
			    (eh->ether_type != htons(ETHERTYPE_IPV6)) &&
			    (eh->ether_type != htons(ETHERTYPE_ARP)) &&
			    (eh->ether_type != htons(ETHERTYPE_REVARP))) {
				m_freem(m);
				continue;
a948 7
		if ((p->bif_flags & IFBIF_BLOCKNONIP) &&
		    (eh->ether_type != htons(ETHERTYPE_IP)) &&
		    (eh->ether_type != htons(ETHERTYPE_IPV6)) &&
		    (eh->ether_type != htons(ETHERTYPE_ARP)) &&
		    (eh->ether_type != htons(ETHERTYPE_REVARP)))
			continue;

d970 6
d977 1
a977 1
		sc->sc_if.if_obytes += m->m_pkthdr.len;
d1446 37
a1483 5

struct ehllc {
	struct ether_header eh;
	struct llc llc;
};
@


1.21
log
@allow 'enc' interfaces to be bridge members
check to make sure rx'd packets aren't from any of our interfaces
fix some bogus comments
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.20 1999/10/27 03:41:48 jason Exp $	*/
d765 9
d938 7
@


1.20
log
@packets addressed "for us" should be entered into the bridge address cache.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.19 1999/10/26 03:40:17 jason Exp $	*/
d240 39
a278 1
		if (ifs->if_type != IFT_ETHER) {
a282 36
		if ((ifs->if_flags & IFF_UP) == 0) {
			/*
			 * Bring interface up long enough to set
			 * promiscuous flag, then shut it down again.
			 */
			strncpy(ifreq.ifr_name, req->ifbr_ifsname,
			    sizeof(ifreq.ifr_name) - 1);
			ifreq.ifr_name[sizeof(ifreq.ifr_name) - 1] = '\0';
			ifs->if_flags |= IFF_UP;
			ifreq.ifr_flags = ifs->if_flags;
			error = (*ifs->if_ioctl)(ifs, SIOCSIFFLAGS,
			    (caddr_t)&ifreq);
			if (error != 0)
				break;

			error = ifpromisc(ifs, 1);
			if (error != 0)
				break;

			strncpy(ifreq.ifr_name, req->ifbr_ifsname,
			    sizeof(ifreq.ifr_name) - 1);
			ifreq.ifr_name[sizeof(ifreq.ifr_name) - 1] = '\0';
			ifs->if_flags &= ~IFF_UP;
			ifreq.ifr_flags = ifs->if_flags;
			error = (*ifs->if_ioctl)(ifs, SIOCSIFFLAGS,
			    (caddr_t)&ifreq);
			if (error != 0) {
				ifpromisc(ifs, 0);
				break;
			}
		} else {
			error = ifpromisc(ifs, 1);
			if (error != 0)
				break;
		}

d285 1
a285 1
		if (p == NULL) {			/* list alloc failed */
d287 1
a287 1
			ifpromisc(ifs, 0);		/* decr promisc cnt */
d551 1
a551 1
 * already attached.  We must free the mbuf before exitting.
a562 1
	struct arpcom *ac = (struct arpcom *)ifp;
d592 1
a592 1
	 * get there.
a622 2
	bcopy(ac->ac_enaddr, src, ETHER_ADDR_LEN);

d839 2
a840 1
		/* make a copy of 'm' with 'eh' tacked on to the
d863 7
a869 3
	else {
		ifl = LIST_FIRST(&sc->sc_iflist);
		while (ifl != NULL) {
d878 5
a882 1
			ifl = LIST_NEXT(ifl, next);
d884 10
a893 12
		M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
		if (m == NULL)
			return (NULL);
		neh = mtod(m, struct ether_header *);
		bcopy(eh, neh, sizeof(struct ether_header));
		s = splimp();
		if (IF_QFULL(&sc->sc_if.if_snd)) {
			m_freem(m);
			splx(s);
			return (NULL);
		}
		IF_ENQUEUE(&sc->sc_if.if_snd, m);
a894 1
		schednetisr(NETISR_BRIDGE);
d897 4
@


1.19
log
@rewriting the header for packets originating from the bridge is
unncessary since we check for incoming frames destined to any
of the bridged interfaces.  Also change the full mbuf copy to a
referenced copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.18 1999/09/30 02:10:18 jason Exp $	*/
d868 4
a871 1
			    ETHER_ADDR_LEN) == 0)
d873 1
@


1.18
log
@simplify bridge_broadcast():
don't bother returning an mbuf just to free it
only free it if NOT used
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.17 1999/09/03 12:47:12 jason Exp $	*/
d591 1
a591 1
	 * get there, we must broadcast with header rewriting.
d605 1
a605 4
			/*
			 * Make a full copy of the packet (sigh)
			 */
			mc = m_copym2(m, 0, M_COPYALL, M_NOWAIT);
a608 21
			}

			/*
			 * If packet does not have a multicast or broadcast
			 * destination, rewrite the header to contain
			 * the current interface's address.
			 */
			if ((eh->ether_shost[0] & 1) == 0) {
				struct arpcom *cac = (struct arpcom *)p->ifp;
				struct ether_header *ceh;
				struct ether_addr *csrc;

				if (mc->m_len < sizeof(*ceh)) {
					mc = m_pullup(mc, sizeof(*ceh));
					if (mc == NULL)
						continue;
				}
				ceh = mtod(mc, struct ether_header *);
				csrc = (struct ether_addr *)
				    &ceh->ether_shost[0];
				bcopy(cac->ac_enaddr, csrc, ETHER_ADDR_LEN);
@


1.17
log
@Don't delete the cache on down/up transitions unless it's empty.  Instead
flush the dynamics.  Required other handling of the cache table to accomodate.
Modify SIOCBRDGFLUSH to handle flushall and flush dynamic requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.16 1999/09/01 21:38:48 jason Exp $	*/
d139 2
a140 2
struct mbuf *	bridge_broadcast __P((struct bridge_softc *sc,
    struct ifnet *, struct ether_header *, struct mbuf *));
d798 1
d801 1
a801 1
			 * forward it and pass it up to our higher layers.
d805 1
a805 3
				m = bridge_broadcast(sc, src_if, eh, m);
				if (m != NULL)
					m_freem(m);
d830 1
a830 1
			m = bridge_broadcast(sc, src_if, eh, m);
a831 2
			if (m != NULL)
				m_freem(m);
d919 1
a919 1
struct mbuf *
d927 2
a928 1
	struct mbuf *mc, *ret;
d953 1
a953 1
			ret = NULL;
a955 1
			ret = m;
d973 2
a974 1
	return (ret);
@


1.16
log
@o simpler handling of "forme" packets
o when ~IFF_UP, don't act like a bridge for output either
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.15 1999/08/20 04:53:17 jason Exp $	*/
d150 1
a150 1
int	bridge_rtflush __P((struct bridge_softc *));
a363 4
		if ((ifp->if_flags & IFF_RUNNING) == 0) {
			error = ENETDOWN;
			break;
		}
d370 1
a370 5
		if ((ifp->if_flags & IFF_RUNNING) == 0) {
			error = ENETDOWN;
			break;
		}
		error = bridge_rtflush(sc);
a395 4
		if ((ifp->if_flags & IFF_RUNNING) == 0) {
			error = ENETDOWN;
			break;
		}
a532 2
	struct bridge_rtnode *n, *p;
	int i, s;
d542 2
a543 19
	/*
	 * Free the routing table, if necessary.
	 */
	if (sc->sc_rts != NULL) {
		s = splhigh();
		for (i = 0; i < BRIDGE_RTABLE_SIZE; i++) {
			n = LIST_FIRST(&sc->sc_rts[i]);
			while (n != NULL) {
				p = LIST_NEXT(n, brt_next);
				LIST_REMOVE(n, brt_next);
				free(n, M_DEVBUF);
				sc->sc_brtcnt--;
				n = p;
			}
		}
		free(sc->sc_rts, M_DEVBUF);
		sc->sc_rts = NULL;
		splx(s);
	}
d992 15
a1006 2
	if (sc->sc_rts == NULL)
		goto done;
d1215 1
d1217 6
d1275 1
a1275 1
bridge_rtflush(sc)
d1277 1
d1283 2
a1284 4
	if (sc->sc_rts == NULL) {
		splx(s);
		return (ENETDOWN);
	}
d1289 2
a1290 1
			if ((n->brt_flags & IFBAF_TYPEMASK) == IFBAF_DYNAMIC) {
d1301 6
d1323 2
a1324 4
	if (sc->sc_rts == NULL) {
		splx(s);
		return (ENETDOWN);
	}
d1333 5
d1343 2
d1360 2
a1361 4
	if (sc->sc_rts == NULL) {
		splx(s);
		return;
	}
d1380 4
d1385 1
@


1.15
log
@uninitialized variable; art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.14 1999/08/08 02:42:58 niklas Exp $	*/
d611 10
d678 2
d875 1
a875 1
bridge_input(ifp, eh, m, forme)
a878 1
	int *forme;
d926 1
a926 2
			    ETHER_ADDR_LEN) == 0) {
				*forme = 1;
a927 1
			}
@


1.14
log
@Fix cases when wanting to communicate with the bridge'
s remote interfaces, both ARP and local delivery had bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.13 1999/08/08 00:43:00 niklas Exp $	*/
d469 1
a469 1
	u_int32_t total, i;
@


1.13
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.12 1999/07/24 19:11:13 jason Exp $	*/
d863 1
a863 1
bridge_input(ifp, eh, m)
d867 1
d916 1
@


1.12
log
@fix size calculation in SIOCBRDGRTS
code size reduction from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.11 1999/06/30 00:00:29 jason Exp $	*/
d443 18
@


1.11
log
@bpfattach bridge's and provide tap for queued packets
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.10 1999/06/03 21:52:02 espie Exp $	*/
d452 1
a452 1
	int error;
d462 2
a463 2
		bifc->ifbic_len = total * sizeof(struct ifbreq);
		return (0);
d468 1
a468 1
	while (p != NULL && bifc->ifbic_len > sizeof(breq)) {
d470 1
a470 1
		    sizeof(breq.ifbr_name));
d473 1
a473 1
		    sizeof(breq.ifbr_ifsname));
d478 2
a479 4
		if (error) {
			bifc->ifbic_len = i * sizeof(breq);
			return (error);
		}
d484 1
d486 1
a486 1
	return (0);
d994 2
a995 4
	if (sc->sc_rts == NULL) {
		splx(s);
		return (NULL);
	}
d1000 2
a1001 4
		if (sc->sc_brtcnt >= sc->sc_brtmax) {
			splx(s);
			return (NULL);
		}
d1004 2
a1005 4
		if (p == NULL) {
			splx(s);
			return (NULL);
		}
d1018 1
a1018 2
		splx(s);
		return (ifp);
d1034 2
a1035 2
			splx(s);
			return (q->brt_if);
d1039 2
a1040 4
			if (sc->sc_brtcnt >= sc->sc_brtmax) {
				splx(s);
				return (NULL);
			}
d1043 2
a1044 4
			if (p == NULL) {
				splx(s);
				return (NULL);
			}
d1057 1
a1057 2
			splx(s);
			return (ifp);
d1061 2
a1062 4
			if (sc->sc_brtcnt >= sc->sc_brtmax) {
				splx(s);
				return (NULL);
			}
d1065 2
a1066 4
			if (p == NULL) {
				splx(s);
				return (NULL);
			}
d1078 1
a1078 2
			splx(s);
			return (ifp);
d1082 3
d1086 1
a1086 1
	return (NULL);
d1103 2
a1104 4
	if (sc->sc_rts == NULL) {
		splx(s);
		return (NULL);
	}
d1114 2
a1115 6

		if (dir > 0) {
			splx(s);
			return (NULL);
		}

d1118 1
d1171 2
a1172 4
	if (sc->sc_rts == NULL) {
		splx(s);
		return;
	}
d1177 2
a1178 4
	if (sc->sc_brtcnt <= sc->sc_brtmax) {
		splx(s);
		return;
	}
d1187 2
a1188 4
	if (sc->sc_brtcnt <= sc->sc_brtmax) {
		splx(s);
		return;
	}
d1199 2
a1200 4
				if (sc->sc_brtcnt <= sc->sc_brtmax) {
					splx(s);
					return;
				}
d1204 1
d1365 2
a1366 2
	int i, s, error;
	u_int32_t cnt;
d1372 2
a1373 11
	if (sc->sc_rts == NULL) {
		baconf->ifbac_len = 0;
		splx(s);
		return (0);
	}

	if (baconf->ifbac_len == 0) {
		baconf->ifbac_len = sc->sc_brtcnt * sizeof(struct ifbareq);
		splx(s);
		return (0);
	}
d1378 3
a1380 6
			if (baconf->ifbac_len < sizeof(struct ifbareq)) {
				baconf->ifbac_len = cnt *
				    sizeof(struct ifbareq);
				splx(s);
				return (0);
			}
d1391 2
a1392 6
			if (error) {
				baconf->ifbac_len = cnt *
				    sizeof(struct ifbareq);
				splx(s);
				return (error);
			}
d1397 1
a1397 1

d1400 1
a1400 1
	return (0);
@


1.10
log
@Repair amiga builds (int schedules need some machine-specific macros)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.9 1999/05/24 23:09:10 jason Exp $	*/
d35 2
d68 4
d195 4
d709 5
@


1.9
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.8 1999/03/19 22:47:33 jason Exp $	*/
d46 1
@


1.8
log
@Add flag to allow some interfaces to not see packets with unknown destination.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.7 1999/03/19 02:46:54 jason Exp $	*/
d51 1
d122 1
a122 1
	u_int32_t			sc_brttimeout;	/* current # addrs */
d184 1
a184 1
		ifp->if_type  = IFT_PROPVIRTUAL;
d194 1
a194 1
	u_long	cmd;
d211 1
a211 1
	switch(cmd) {
a220 1

a224 1

a228 1

a252 1

d264 1
a264 2
		}
		else {
d459 2
a460 2
		    sizeof (breq.ifbr_name));
		breq.ifbr_name[sizeof(breq.ifbr_name)-1] = '\0';
d462 2
a463 2
		    sizeof (breq.ifbr_ifsname));
		breq.ifbr_ifsname[sizeof(breq.ifbr_ifsname)-1] = '\0';
d484 1
a484 2
	int i;
	int s;
a497 1

d670 156
d836 2
d839 2
a840 4
	struct ether_addr *dst, *src;
	struct ifnet *dst_if;
	struct bridge_iflist *ifl;
	int s;
d849 1
a849 5

	s = splimp();

	if ((sc->sc_if.if_flags & IFF_RUNNING) == 0) {
		splx(s);
a850 1
	}
d852 7
a858 62
	sc->sc_if.if_lastchange = time;
	sc->sc_if.if_ipackets++;
	sc->sc_if.if_ibytes += m->m_pkthdr.len;

	/*
	 * See if the destination of this frame matches the interface
	 * it came in on.  If so, we don't need to do anything.
	 */
	ac = (struct arpcom *)ifp;
	if (bcmp(ac->ac_enaddr, eh->ether_dhost, ETHER_ADDR_LEN) == 0) {
		splx(s);
		return (m);
	}

	dst = (struct ether_addr *)&eh->ether_dhost[0];
	src = (struct ether_addr *)&eh->ether_shost[0];

	ifl = LIST_FIRST(&sc->sc_iflist);
	while (ifl != NULL && ifl->ifp != ifp) {
		ifl = LIST_NEXT(ifl, next);
	}
	if (ifl == NULL) {
		splx(s);
		return (m);
	}

	/*
	 * If interface is learning, and if source address is not broadcast
	 * or multicast, record it's address.
	 */
	if ((ifl->bif_flags & IFBIF_LEARNING) &&
	    (eh->ether_shost[0] & 1) == 0 &&
	    !(eh->ether_shost[0] == 0 && eh->ether_shost[1] == 0 &&
	      eh->ether_shost[2] == 0 && eh->ether_shost[3] == 0 &&
	      eh->ether_shost[4] == 0 && eh->ether_shost[5] == 0))
		bridge_rtupdate(sc, src, ifp, 0, IFBAF_DYNAMIC);

	/*
	 * If packet is unicast, destined for someone on "this"
	 * side of the bridge, drop it.
	 */
	dst_if = bridge_rtlookup(sc, dst);
	if ((m->m_flags & (M_BCAST|M_MCAST)) == 0 && dst_if == ifp) {
		m_freem(m);
		splx(s);
		return (NULL);
	}

	/*
	 * Multicast packets get handled a little differently:
	 * If interface is:
	 *	-link0,-link1	(default) Forward all multicast as broadcast.
	 *	-link0,link1	Drop non-IP multicast, forward as broadcast
	 *				IP multicast.
	 *	link0,-link1	Drop IP multicast, forward as broadcast
	 *				non-IP multicast.
	 *	link0,link1	Drop all multicast.
	 */
	if (m->m_flags & M_MCAST) {
		if ((sc->sc_if.if_flags & (IFF_LINK0|IFF_LINK1)) ==
		    (IFF_LINK0|IFF_LINK1)) {
			splx(s);
d860 2
a861 4
		}
		if (sc->sc_if.if_flags & IFF_LINK0 &&
		    ETHERADDR_IS_IP_MCAST(dst)) {
			splx(s);
d863 5
a867 3
		}
		if (sc->sc_if.if_flags & IFF_LINK1 &&
		    !ETHERADDR_IS_IP_MCAST(dst)) {
d871 1
a871 34
	}

#if defined(INET) && (defined(IPFILTER) || defined(IPFILTER_LKM))
	/*
	 * Pass the packet to the ip filtering code and drop
	 * here if necessary.
	 */
	if (bridge_filter(sc, ifp, eh, &m) == BRIDGE_FILTER_DROP) {
		if (m == NULL || m->m_flags & (M_BCAST|M_MCAST)) {
			/*
			 * Broadcasts should be passed down if filtered
			 * by the bridge, so that they can be filtered
			 * by the interface itself.
			 */
			 splx(s);
			 return (m);
		}
		m_freem(m);
		splx(s);
		return (NULL);
	}
	if (m == NULL) {
		splx(s);
		return (NULL);
	}
#endif

	/*
	 * If the packet is a multicast or broadcast, then forward it
	 * and pass it up to our higher layers.
	 */
	if (m->m_flags & (M_BCAST|M_MCAST)) {
		ifp->if_imcasts++;
		m = bridge_broadcast(sc, ifp, eh, m);
d873 1
d876 12
a887 8

	/*
	 * If sucessful lookup, forward packet to that interface only.
	 */
	if (dst_if != NULL) {
		if ((dst_if->if_flags & IFF_RUNNING) == 0) {
			m_freem(m);
			splx(s);
d889 4
a892 4
		}

		if (IF_QFULL(&dst_if->if_snd)) {
			sc->sc_if.if_oerrors++;
d897 1
a897 15

		M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
		if (m == NULL) {
			sc->sc_if.if_oerrors++;
			return (NULL);
		}
		*mtod(m, struct ether_header *) = *eh;

		sc->sc_if.if_opackets++;
		sc->sc_if.if_obytes += m->m_pkthdr.len;

		IF_ENQUEUE(&dst_if->if_snd, m);
       		if ((dst_if->if_flags & IFF_OACTIVE) == 0)
			(*dst_if->if_start)(dst_if);

d899 1
a901 7

	/*
	 * Packet must be forwarded to all interfaces.
	 */
	m = bridge_broadcast(sc, ifp, eh, m);
	splx(s);
	return (m);
d917 1
a917 9
	struct mbuf *mc;

	/*
	 * Tack on ethernet header
	 */
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
		return (NULL);
	*mtod(m, struct ether_header *) = *eh;
d928 1
a928 1
		    (m->m_flags & (M_BCAST|M_MCAST)) == 0)
d939 12
a950 4
		mc = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
		if (mc == NULL) {
			sc->sc_if.if_oerrors++;
			continue;
d963 1
a963 2
	m_adj(m, sizeof(struct ether_header));
	return (m);
d1289 1
a1289 2
			}
			else
d1360 1
a1360 2
			}
			else
d1405 1
a1405 1
				sizeof(bareq.ifba_name));
d1431 6
d1451 1
a1451 1
	struct llc *llc;
d1454 1
a1454 1
	int hlen, r, off = 0;
d1459 9
a1467 1
	etype = ntohs(eh->ether_type);
d1472 7
a1478 15
		m = *np;
		if (m->m_len < 8) {
			m = m_pullup(m, 8);
			*np = m;
			if (m == NULL)
				return (BRIDGE_FILTER_DROP);
		}
		llc = mtod(m, struct llc *);
		if (llc->llc_control != LLC_UI ||
		    llc->llc_dsap != LLC_SNAP_LSAP ||
		    llc->llc_ssap != LLC_SNAP_LSAP ||
		    llc->llc_snap.org_code[0] != 0 ||
		    llc->llc_snap.org_code[1] != 0 ||
		    llc->llc_snap.org_code[2] != 0 ||
		    ntohs(llc->llc_snap.ether_type) != ETHERTYPE_IP)
d1480 1
a1480 1
		off = 8;
a1482 1

d1488 1
d1490 2
a1491 1
	m = m_copym2(m, off, M_COPYALL, M_NOWAIT);
d1512 1
a1517 1

d1546 1
a1546 2
		}
		else
d1550 2
a1551 7
	/*
	 * Finally, we get to filter the packet!  Pass through
	 * once with the bridge as the rcvif, and again with the
	 * real receiving interface as rcvif.
	 */
	m->m_pkthdr.rcvif = ifp;
	if (fr_checkp && (*fr_checkp)(ip, hlen, m->m_pkthdr.rcvif, 0, &m))
@


1.7
log
@Add the ability to mark an interface as "non-learning"
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.6 1999/03/12 02:40:43 jason Exp $	*/
d283 1
a283 1
		p->bif_flags = IFBIF_LEARNING;
d891 4
@


1.6
log
@big overhaul:
o SNAP encapsulated IP filtering
o static address cache entries
o address deletion from cache
o dynamic & full cache flush
o filter packets based on each interface, not on the bridge as a whole
o KNF nits
o allow addition of ~IFF_UP interfaces
o man page & user level fixes to match the above
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.5 1999/03/05 22:09:18 jason Exp $	*/
d283 1
d314 42
d689 1
d724 9
d734 2
a735 2
	 * If source address is not broadcast or multicast, record
	 * it's address.
d737 2
a738 1
	if ((eh->ether_shost[0] & 1) == 0 &&
@


1.5
log
@bump cache timeout up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.4 1999/03/05 21:10:52 jason Exp $	*/
d49 1
d85 7
d109 2
a110 1
	u_int32_t			brt_age;	/* age counter */
d141 2
d144 1
a144 1
    struct ether_addr *, struct ifnet *ifp));
d162 1
a162 1
    struct ether_header *, struct mbuf *));
d201 1
d205 2
a206 1
	int	error = 0, s;
d236 37
a272 3
		error = ifpromisc(ifs, 1);
		if (error != 0)
			break;
d320 40
d688 1
a688 1
		bridge_rtupdate(sc, src, ifp);
d734 2
a735 2
	if (bridge_filter(sc, ifp, eh, m) == BRIDGE_FILTER_DROP) {
		if (m->m_flags & (M_BCAST|M_MCAST)) {
d748 4
d868 1
a868 1
bridge_rtupdate(sc, ea, ifp)
d872 2
d892 2
a893 3
		p = (struct bridge_rtnode *)
				malloc(sizeof(struct bridge_rtnode),
				    M_DEVBUF, M_NOWAIT);
d902 6
d920 7
a926 2
			q->brt_if = ifp;
			q->brt_age = 1;
d928 1
a928 1
			return (ifp);
d936 2
a937 3
			p = (struct bridge_rtnode *)
					malloc(sizeof(struct bridge_rtnode),
					    M_DEVBUF, M_NOWAIT);
d946 6
d963 2
a964 3
			p = (struct bridge_rtnode *)
					malloc(sizeof(struct bridge_rtnode),
					    M_DEVBUF, M_NOWAIT);
d973 5
d1105 9
a1113 7
			LIST_REMOVE(n, brt_next);
			sc->sc_brtcnt--;
			free(n, M_DEVBUF);
			n = p;
			if (sc->sc_brtcnt <= sc->sc_brtmax) {
				splx(s);
				return;
d1140 7
a1146 1
			if (n->brt_age) {
d1166 67
d1307 4
a1310 2
			bcopy(n->brt_if->if_xname, bareq.ifba_name,
			    sizeof(bareq.ifba_name));
d1314 1
d1341 1
a1341 1
bridge_filter(sc, ifp, eh, n)
d1345 1
a1345 1
	struct mbuf *n;
d1347 2
a1348 1
	struct mbuf *m, *m0;
d1351 1
a1351 1
	int hlen, r;
a1355 3
	/*
	 * XXX TODO: Handle LSAP packets
	 */
d1357 23
a1379 2
	if (etype != ETHERTYPE_IP)
		return (BRIDGE_FILTER_PASS);
d1387 1
a1387 1
	m = m_copym2(n, 0, M_COPYALL, M_NOWAIT);
a1390 2
	m->m_pkthdr.rcvif = &sc->sc_if;

d1448 3
a1450 1
	 * Finally, we get to filter the packet!
d1452 2
a1453 2
	m0 = m;
	if (fr_checkp && (*fr_checkp)(ip, hlen, m->m_pkthdr.rcvif, 0, &m0))
d1455 1
a1455 1
	ip = mtod(m = m0, struct ip *);
@


1.4
log
@Make address cache expiration actually work and provide a knob
for adjusting the timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.3 1999/03/01 04:44:44 jason Exp $	*/
d81 1
a81 1
#define BRIDGE_RTABLE_TIMEOUT	30
@


1.3
log
@completely (almost) revamped ioctl's:
o new ioctls for getting/setting cache size (default == 100)
o changed SIOCBRDGRT -> SIOCBRDGRTS
o changed SIOCBRDGIDX -> SIOCBRDGIFS
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.2 1999/02/27 21:19:27 jason Exp $	*/
d77 7
a109 1
	u_int32_t			sc_brtageidx;	/* route age index */
d112 1
d163 1
d192 1
a198 3
		/*
		 * Only root can add interfaces.
		 */
a201 3
		/*
		 * Get pointer to ifnet structure for the named interface.
		 */
a207 3
		/*
		 * Check to see if this interface is already a member.
		 */
a212 3
		/*
		 * Make sure it's not a member of another bridge.
		 */
a217 3
		/*
		 * Make sure it is an ethernet interface.
		 */
a222 3
		/*
		 * Put interface into promiscuous mode.
		 */
a226 3
		/*
		 * Allocate list entry.
		 */
a234 4
		/*
		 * Add to interface list, and give the interface a pointer
		 * back to us.
		 */
a239 3
		/*
		 * Only root can delete interfaces.
		 */
a246 3
				/*
				 * Remove the pointer back to us.
				 */
a248 3
				/*
				 * Decrement promisc count
				 */
a250 5
				/*
				 * Finally, remove from list, delete
				 * routes from that interface, and reclaim
				 * memory.
				 */
d277 2
d282 11
a363 2
	sc->sc_brtageidx = 0;

d381 2
a382 1
	timeout(bridge_rtage, sc, 2 * hz);
a465 3
			/*
			 * Make sure interface is running.
			 */
a468 3
			/*
			 * Make sure there's room in the queue.
			 */
a492 3
				/*
				 * Pull up ethernet header.
				 */
a503 3
			/*
			 * Update stats, queue the packet, and start it.
			 */
a570 3
	/*
	 * See if we're running.
	 */
a677 3
		/*
		 * Make sure target interface is running.
		 */
a683 3
		/*
		 * Make sure the interface has room in its queue.
		 */
a690 3
		/*
		 * Prepend the ethernet header on to the buffer.
		 */
a697 3
		/*
		 * Update statistics.
		 */
a700 3
		/*
		 * Put it in the interface queue and start transmission.
		 */
a747 3
		/*
		 * Make sure target interface is actually running.
		 */
a750 3
		/*
		 * Make sure the interface has room in its queue.
		 */
a755 3
		/*
		 * Make a copy of the packet.
		 */
a761 3
		/*
		 * Update statistics
		 */
a766 3
		/*
		 * Put it in interface queue and start transmission.
		 */
a771 3
	/*
	 * Strip header back off
	 */
d1006 3
d1015 1
a1015 1
	int s;
d1023 14
a1036 22
	n = LIST_FIRST(&sc->sc_rts[sc->sc_brtageidx]);
	while (n != NULL) {
		if (n->brt_age) {
			n->brt_age = 0;
			n = LIST_NEXT(n, brt_next);
		}
		else {
			p = LIST_NEXT(n, brt_next);
#if 1
			printf("RTAGE(%s,%x:%x:%x:%x:%x:%x)\n",
				n->brt_if->if_xname,
				n->brt_addr.ether_addr_octet[0],
				n->brt_addr.ether_addr_octet[1],
				n->brt_addr.ether_addr_octet[2],
				n->brt_addr.ether_addr_octet[3],
				n->brt_addr.ether_addr_octet[4],
				n->brt_addr.ether_addr_octet[5]);
#endif
			LIST_REMOVE(n, brt_next);
			sc->sc_brtcnt--;
			free(n, M_DEVBUF);
			n = p;
a1038 1
	sc->sc_brtageidx = (sc->sc_brtageidx + 1) % BRIDGE_RTABLE_SIZE;
d1040 3
@


1.2
log
@rearrange strcutures to avoid bad padding; deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.c,v 1.1 1999/02/26 17:01:31 jason Exp $	*/
d70 7
d84 1
a84 1
	struct ifnet			*ifp;		/* member interface */
d93 1
a93 1
	struct ifnet			*brt_if;	/* destination ifs */
d95 1
a95 1
	struct ether_addr		brt_addr;	/* destination addr */
d102 1
a102 1
	struct ifnet			sc_if;		/* the interface */
d104 2
d119 1
d121 1
a121 1
int	bridge_rtfind __P((struct bridge_softc *, struct ifbrtreq *));
d123 1
d151 1
a151 1
	register int i;
d155 1
a156 1

a166 1

d181 4
a184 2
	struct ifbrtreq *brtreq = (struct ifbrtreq *)data;
	int	error = 0, s, i;
d199 1
a199 1
		ifs = ifunit(req->ifsname);
d264 1
a264 1
			if (strncmp(p->ifp->if_xname, req->ifsname,
d293 2
a294 21
	case SIOCBRDGIDX:
		/*
		 * Search through list looking for right element.
		 */
		i = 0;
		p = LIST_FIRST(&sc->sc_iflist);
		while (p != NULL && i < req->index) {
			i++;
			p = LIST_NEXT(p, next);
		}

		/*
		 * Make sure we didn't go off the end of the list.
		 */
		if (p == NULL || req->index != i) {
			error = ENOENT;
			break;
		}
		/* found it */
		strncpy(req->ifsname, p->ifp->if_xname, sizeof(req->ifsname)-1);
		req->ifsname[sizeof(req->ifsname)-1] = '\0';
d296 1
a296 1
	case SIOCBRDGRT:
d301 8
a308 1
		error = bridge_rtfind(sc, brtreq);
d325 45
d433 1
d861 4
d877 1
d895 4
d911 1
d917 4
d933 1
d1018 54
d1105 1
d1141 1
d1154 1
a1154 2
 * Find the route for a given index value in rq->index.
 * Returns 0 on success, otherwise an error value.
d1157 1
a1157 1
bridge_rtfind(sc, rq)
d1159 1
a1159 1
	struct ifbrtreq *rq;
d1161 1
a1161 1
	int i, s;
d1164 1
d1167 1
d1169 7
d1177 1
a1177 1
		return (ENOENT);
d1180 1
a1180 1
	for (cnt = 0, i = 0; i < BRIDGE_RTABLE_SIZE; i++) {
d1183 3
a1185 5
			if (cnt == rq->index) {
				bcopy(&n->brt_addr, &rq->dst, sizeof(rq->dst));
				bcopy(n->brt_if->if_xname, rq->ifsname,
				    IFNAMSIZ);
				rq->age = n->brt_age;
d1189 13
d1206 2
d1209 1
a1209 1
	return (ENOENT);
@


1.1
log
@Ethernet bridge/IP firewall driver.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 1
d78 1
a78 2
	u_int16_t			bif_flags;	/* member flags */
	LIST_ENTRY(bridge_iflist)	next;		/* next in list */
d85 1
d87 1
a88 2
	LIST_ENTRY(bridge_rtnode)	brt_next;	/* next in list */
	u_int16_t			brt_age;	/* age counter */
@

