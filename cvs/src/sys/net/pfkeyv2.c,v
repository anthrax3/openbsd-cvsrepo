head	1.154;
access;
symbols
	OPENBSD_6_1:1.153.0.4
	OPENBSD_6_1_BASE:1.153
	OPENBSD_6_0:1.146.0.6
	OPENBSD_6_0_BASE:1.146
	OPENBSD_5_9:1.146.0.2
	OPENBSD_5_9_BASE:1.146
	OPENBSD_5_8:1.145.0.4
	OPENBSD_5_8_BASE:1.145
	OPENBSD_5_7:1.138.0.2
	OPENBSD_5_7_BASE:1.138
	OPENBSD_5_6:1.133.0.4
	OPENBSD_5_6_BASE:1.133
	OPENBSD_5_5:1.132.0.4
	OPENBSD_5_5_BASE:1.132
	OPENBSD_5_4:1.130.0.2
	OPENBSD_5_4_BASE:1.130
	OPENBSD_5_3:1.129.0.2
	OPENBSD_5_3_BASE:1.129
	OPENBSD_5_2:1.125.0.2
	OPENBSD_5_2_BASE:1.125
	OPENBSD_5_1_BASE:1.124
	OPENBSD_5_1:1.124.0.6
	OPENBSD_5_0:1.124.0.4
	OPENBSD_5_0_BASE:1.124
	OPENBSD_4_9:1.124.0.2
	OPENBSD_4_9_BASE:1.124
	OPENBSD_4_8:1.121.0.2
	OPENBSD_4_8_BASE:1.121
	OPENBSD_4_7:1.119.0.6
	OPENBSD_4_7_BASE:1.119
	OPENBSD_4_6:1.119.0.8
	OPENBSD_4_6_BASE:1.119
	OPENBSD_4_5:1.119.0.4
	OPENBSD_4_5_BASE:1.119
	OPENBSD_4_4:1.119.0.2
	OPENBSD_4_4_BASE:1.119
	OPENBSD_4_3:1.118.0.2
	OPENBSD_4_3_BASE:1.118
	OPENBSD_4_2:1.115.0.2
	OPENBSD_4_2_BASE:1.115
	OPENBSD_4_1:1.114.0.2
	OPENBSD_4_1_BASE:1.114
	OPENBSD_4_0:1.111.0.2
	OPENBSD_4_0_BASE:1.111
	OPENBSD_3_9:1.109.0.2
	OPENBSD_3_9_BASE:1.109
	OPENBSD_3_8:1.108.0.2
	OPENBSD_3_8_BASE:1.108
	OPENBSD_3_7:1.100.0.2
	OPENBSD_3_7_BASE:1.100
	OPENBSD_3_6:1.92.0.2
	OPENBSD_3_6_BASE:1.92
	SMP_SYNC_A:1.90
	SMP_SYNC_B:1.90
	OPENBSD_3_5:1.90.0.2
	OPENBSD_3_5_BASE:1.90
	OPENBSD_3_4:1.89.0.2
	OPENBSD_3_4_BASE:1.89
	UBC_SYNC_A:1.87
	OPENBSD_3_3:1.87.0.2
	OPENBSD_3_3_BASE:1.87
	OPENBSD_3_2:1.84.0.2
	OPENBSD_3_2_BASE:1.84
	OPENBSD_3_1:1.81.0.2
	OPENBSD_3_1_BASE:1.81
	UBC_SYNC_B:1.84
	UBC:1.77.0.4
	UBC_BASE:1.77
	OPENBSD_3_0:1.77.0.2
	OPENBSD_3_0_BASE:1.77
	OPENBSD_2_9_BASE:1.58
	OPENBSD_2_9:1.58.0.2
	OPENBSD_2_8:1.48.0.2
	OPENBSD_2_8_BASE:1.48
	OPENBSD_2_7:1.36.0.2
	OPENBSD_2_7_BASE:1.36
	SMP:1.34.0.2
	SMP_BASE:1.34
	kame_19991208:1.28
	OPENBSD_2_6:1.26.0.2
	OPENBSD_2_6_BASE:1.26
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14;
locks; strict;
comment	@ * @;


1.154
date	2017.05.05.11.04.18;	author bluhm;	state Exp;
branches;
next	1.153;
commitid	e7lFBlOrOiuLgJ3F;

1.153
date	2017.02.28.16.46.27;	author bluhm;	state Exp;
branches;
next	1.152;
commitid	rmbXKt3efXwOBuCw;

1.152
date	2017.02.24.18.36.33;	author bluhm;	state Exp;
branches;
next	1.151;
commitid	d0wwMTGG3Nvu5quB;

1.151
date	2017.02.14.09.47.40;	author mpi;	state Exp;
branches;
next	1.150;
commitid	e0wtEMeLlZrhXa6I;

1.150
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.149;
commitid	6c6qq5OdS4VVnyVM;

1.149
date	2017.01.13.08.52.09;	author mpi;	state Exp;
branches;
next	1.148;
commitid	OhxRzTvnc9kLxnqM;

1.148
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.147;
commitid	RlO92XR575sygHqm;

1.147
date	2016.08.30.23.30.37;	author dlg;	state Exp;
branches;
next	1.146;
commitid	TZbD9qBLjLRD1OK2;

1.146
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.145;
commitid	CLwtYUTkBZ3FXV1w;

1.145
date	2015.07.17.18.31.08;	author blambert;	state Exp;
branches;
next	1.144;
commitid	WEUQfMsVq6mbe3cF;

1.144
date	2015.05.23.12.38.53;	author markus;	state Exp;
branches;
next	1.143;
commitid	Mgx7ewWJ5ueyVCxt;

1.143
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.142;
commitid	2c41FFL8044mZVko;

1.142
date	2015.04.16.19.18.10;	author markus;	state Exp;
branches;
next	1.141;
commitid	95HrEjJkuhjwwAbo;

1.141
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.140;
commitid	bQi1IVHgugweH5gs;

1.140
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.139;
commitid	aiRvgNOa4qke9vft;

1.139
date	2015.03.26.12.21.37;	author mikeb;	state Exp;
branches;
next	1.138;
commitid	GUv4gLlXi8Tx36WA;

1.138
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.137;
commitid	zhW8jJrfVCoAthrR;

1.137
date	2014.11.25.13.10.03;	author mpi;	state Exp;
branches;
next	1.136;
commitid	NGBbDDWXFXkKytPH;

1.136
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.135;
commitid	w0MRp28dmfD1ZzO8;

1.135
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.134;
commitid	6AYfDT0Lpez1LFQp;

1.134
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.133;
commitid	HQcmytntiCJTHORs;

1.133
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.132;
commitid	B4dZSbxas1X1IpXI;

1.132
date	2014.01.08.02.39.02;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2013.08.21.05.21.46;	author dlg;	state Exp;
branches;
next	1.130;

1.130
date	2013.03.09.16.51.30;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2013.02.26.00.28.29;	author sthen;	state Exp;
branches;
next	1.128;

1.128
date	2012.12.28.17.52.06;	author gsoares;	state Exp;
branches;
next	1.127;

1.127
date	2012.09.26.14.53.23;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.125;

1.125
date	2012.03.28.19.43.21;	author claudio;	state Exp;
branches;
next	1.124;

1.124
date	2011.01.12.18.49.21;	author mikeb;	state Exp;
branches;
next	1.123;

1.123
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.122;

1.122
date	2010.09.27.17.28.34;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.120;

1.120
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.119;

1.119
date	2008.05.09.15.48.15;	author claudio;	state Exp;
branches;
next	1.118;

1.118
date	2007.11.24.12.59.28;	author jmc;	state Exp;
branches;
next	1.117;

1.117
date	2007.09.13.21.00.14;	author hshoexer;	state Exp;
branches;
next	1.116;

1.116
date	2007.09.01.18.49.28;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2007.06.22.12.14.05;	author markus;	state Exp;
branches;
next	1.114;

1.114
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.113;

1.113
date	2007.01.18.20.00.19;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.111;

1.111
date	2006.06.16.16.49.39;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2006.05.06.17.43.47;	author mcbride;	state Exp;
branches;
next	1.109;

1.109
date	2005.12.06.14.25.21;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2005.06.01.11.22.07;	author hshoexer;	state Exp;
branches;
next	1.107;

1.107
date	2005.05.28.17.43.25;	author hshoexer;	state Exp;
branches;
next	1.106;

1.106
date	2005.05.27.17.58.47;	author ho;	state Exp;
branches;
next	1.105;

1.105
date	2005.05.27.15.29.55;	author hshoexer;	state Exp;
branches;
next	1.104;

1.104
date	2005.05.25.05.47.53;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2005.05.24.03.13.53;	author ho;	state Exp;
branches;
next	1.102;

1.102
date	2005.05.10.13.42.11;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2005.04.04.22.18.47;	author hshoexer;	state Exp;
branches;
next	1.100;

1.100
date	2005.01.13.10.08.14;	author hshoexer;	state Exp;
branches;
next	1.99;

1.99
date	2004.12.11.16.02.21;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2004.12.11.15.59.00;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2004.12.11.15.55.57;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2004.12.10.18.50.51;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2004.11.29.21.42.20;	author hshoexer;	state Exp;
branches;
next	1.94;

1.94
date	2004.11.26.18.02.22;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2004.11.19.10.11.52;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2004.08.10.16.17.05;	author ho;	state Exp;
branches
	1.92.2.1;
next	1.91;

1.91
date	2004.06.21.23.10.31;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2003.07.24.09.59.02;	author itojun;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2003.07.24.08.03.19;	author itojun;	state Exp;
branches;
next	1.87;

1.87
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2003.02.16.19.54.20;	author jason;	state Exp;
branches;
next	1.85;

1.85
date	2003.02.15.22.57.58;	author jason;	state Exp;
branches;
next	1.84;

1.84
date	2002.07.31.00.13.36;	author itojun;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.07.04.47.06;	author ho;	state Exp;
branches;
next	1.82;

1.82
date	2002.05.31.01.42.17;	author angelos;	state Exp;
branches;
next	1.81;

1.81
date	2002.03.03.21.47.00;	author angelos;	state Exp;
branches;
next	1.80;

1.80
date	2002.02.21.20.14.12;	author angelos;	state Exp;
branches;
next	1.79;

1.79
date	2002.01.23.01.33.07;	author art;	state Exp;
branches;
next	1.78;

1.78
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.77;

1.77
date	2001.08.05.11.03.07;	author angelos;	state Exp;
branches
	1.77.4.1;
next	1.76;

1.76
date	2001.08.05.11.02.03;	author angelos;	state Exp;
branches;
next	1.75;

1.75
date	2001.07.06.13.31.07;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2001.07.05.16.48.03;	author jjbg;	state Exp;
branches;
next	1.73;

1.73
date	2001.06.27.05.29.10;	author angelos;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.27.04.39.30;	author angelos;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.27.01.34.06;	author angelos;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.26.18.56.31;	author angelos;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.26.18.34.41;	author angelos;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.08.21.29.58;	author angelos;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.08.02.56.47;	author angelos;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.08.02.53.49;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.07.05.27.52;	author angelos;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.05.02.31.34;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.05.00.17.48;	author niklas;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.30.16.44.11;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.30.11.27.33;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2001.05.21.03.02.17;	author angelos;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.05.00.33.46;	author angelos;	state Exp;
branches;
next	1.58;

1.58
date	2001.03.28.20.03.01;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	2001.03.27.14.45.21;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2001.03.15.06.30.57;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.04.20.50.40;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2000.12.24.04.18.42;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2000.12.15.20.32.09;	author provos;	state Exp;
branches;
next	1.52;

1.52
date	2000.12.14.18.07.29;	author provos;	state Exp;
branches;
next	1.51;

1.51
date	2000.11.17.05.08.14;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2000.11.17.04.08.44;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2000.11.06.18.18.56;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2000.10.14.06.23.51;	author angelos;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2000.10.09.22.18.29;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.09.02.51.46;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2000.09.29.19.00.13;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.21.02.38.32;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2000.09.20.19.13.16;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2000.09.19.08.38.58;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2000.09.19.04.23.13;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.19.03.41.11;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2000.09.19.03.19.39;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2000.08.24.22.51.29;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2000.08.08.21.26.52;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2000.03.26.06.40.50;	author angelos;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2000.03.17.10.25.21;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2000.01.27.08.09.06;	author angelos;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.01.13.00.34.59;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.12.21.39.26;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.10.05.31.58;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.09.23.37.03;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.09.23.18.11;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.12.04.23.20.55;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	99.11.04.11.28.22;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	99.08.14.10.33.18;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	99.08.10.11.38.13;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	99.08.05.21.59.20;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	99.07.15.14.15.41;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.07.06.20.54.03;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	99.07.06.20.17.52;	author cmetz;	state Exp;
branches;
next	1.20;

1.20
date	99.07.02.23.37.33;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.06.01.23.43.42;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	99.05.31.18.57.31;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	99.05.23.12.37.45;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	99.05.16.21.48.28;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.05.14.23.36.15;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.04.11.19.41.35;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.04.09.22.46.14;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.03.31.01.20.07;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.03.27.21.04.18;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	99.03.24.17.00.43;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.03.05.00.58.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.03.04.21.20.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.03.04.21.13.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.03.04.20.30.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.03.02.22.00.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.03.02.18.29.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.02.25.03.50.43;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.02.25.02.48.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.02.24.22.36.03;	author angelos;	state Exp;
branches;
next	;

1.34.2.1
date	2000.03.24.09.09.33;	author niklas;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.05.14.22.40.03;	author niklas;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2001.07.04.10.54.15;	author niklas;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2004.02.19.10.57.22;	author niklas;	state Exp;
branches;
next	;

1.36.2.1
date	2000.09.01.13.50.31;	author jason;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2000.11.10.21.51.55;	author jason;	state Exp;
branches;
next	;

1.48.2.1
date	2000.11.10.21.48.41;	author jason;	state Exp;
branches;
next	;

1.77.4.1
date	2002.01.31.22.55.44;	author niklas;	state Exp;
branches;
next	1.77.4.2;

1.77.4.2
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.77.4.3;

1.77.4.3
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.77.4.4;

1.77.4.4
date	2003.05.19.22.29.54;	author tedu;	state Exp;
branches;
next	;

1.89.2.1
date	2004.12.14.13.22.02;	author markus;	state Exp;
branches;
next	;

1.90.2.1
date	2004.12.14.13.21.37;	author markus;	state Exp;
branches;
next	;

1.92.2.1
date	2004.12.14.13.21.06;	author markus;	state Exp;
branches;
next	;


desc
@@


1.154
log
@Expand SA_LEN(), there is no benefit for using the macro in the
kernel.  It was only used in IPsec sources.  No binary change
OK deraadt@@
@
text
@/* $OpenBSD: pfkeyv2.c,v 1.153 2017/02/28 16:46:27 bluhm Exp $ */

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Craig Metz. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "pf.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/pool.h>
#include <net/route.h>
#include <netinet/ip_ipsp.h>
#include <net/pfkeyv2.h>
#include <net/radix.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/ip_ipcomp.h>
#include <crypto/blf.h>

#if NPF > 0
#include <net/if.h>
#include <net/pfvar.h>
#endif

#define PFKEYV2_PROTOCOL 2

/* Static globals */
static struct pfkeyv2_socket *pfkeyv2_sockets = NULL;
static struct pfkey_version pfkeyv2_version;
static uint32_t pfkeyv2_seq = 1;
static int nregistered = 0;
static int npromisc = 0;

static const struct sadb_alg ealgs[] = {
	{ SADB_EALG_NULL, 0, 0, 0 },
	{ SADB_EALG_3DESCBC, 64, 192, 192 },
	{ SADB_X_EALG_BLF, 64, 40, BLF_MAXKEYLEN * 8},
	{ SADB_X_EALG_CAST, 64, 40, 128},
	{ SADB_X_EALG_AES, 128, 128, 256},
	{ SADB_X_EALG_AESCTR, 128, 128 + 32, 256 + 32}
};

static const struct sadb_alg aalgs[] = {
	{ SADB_AALG_SHA1HMAC, 0, 160, 160 },
	{ SADB_AALG_MD5HMAC, 0, 128, 128 },
	{ SADB_X_AALG_RIPEMD160HMAC, 0, 160, 160 },
	{ SADB_X_AALG_SHA2_256, 0, 256, 256 },
	{ SADB_X_AALG_SHA2_384, 0, 384, 384 },
	{ SADB_X_AALG_SHA2_512, 0, 512, 512 }
};

static const struct sadb_alg calgs[] = {
	{ SADB_X_CALG_DEFLATE, 0, 0, 0},
	{ SADB_X_CALG_LZS, 0, 0, 0}
};

extern uint64_t sadb_exts_allowed_out[SADB_MAX+1];
extern uint64_t sadb_exts_required_out[SADB_MAX+1];

extern struct pool ipsec_policy_pool;

extern struct radix_node_head **spd_tables;

/*
 * Wrapper around m_devget(); copy data from contiguous buffer to mbuf
 * chain.
 */
int
pfdatatopacket(void *data, int len, struct mbuf **packet)
{
	if (!(*packet = m_devget(data, len, 0)))
		return (ENOMEM);

	/* Make sure, all data gets zeroized on free */
	(*packet)->m_flags |= M_ZEROIZE;

	return (0);
}

/*
 * Create a new PF_KEYv2 socket.
 */
int
pfkeyv2_create(struct socket *socket)
{
	struct pfkeyv2_socket *pfkeyv2_socket;

	if (!(pfkeyv2_socket = malloc(sizeof(struct pfkeyv2_socket),
	    M_PFKEY, M_NOWAIT | M_ZERO)))
		return (ENOMEM);

	pfkeyv2_socket->next = pfkeyv2_sockets;
	pfkeyv2_socket->socket = socket;
	pfkeyv2_socket->pid = curproc->p_p->ps_pid;

	/*
	 * XXX we should get this from the socket instead but
	 * XXX rawcb doesn't store the rdomain like inpcb does.
	 */
	pfkeyv2_socket->rdomain = rtable_l2(curproc->p_p->ps_rtableid);

	pfkeyv2_sockets = pfkeyv2_socket;

	return (0);
}

/*
 * Close a PF_KEYv2 socket.
 */
int
pfkeyv2_release(struct socket *socket)
{
	struct pfkeyv2_socket **pp;

	for (pp = &pfkeyv2_sockets; *pp && ((*pp)->socket != socket);
	    pp = &((*pp)->next))
		/*EMPTY*/;

	if (*pp) {
		struct pfkeyv2_socket *pfkeyv2_socket;

		pfkeyv2_socket = *pp;
		*pp = (*pp)->next;

		if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_REGISTERED)
			nregistered--;

		if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
			npromisc--;

		free(pfkeyv2_socket, M_PFKEY, 0);
	}

	return (0);
}

/*
 * Send a PFKEYv2 message, possibly to many receivers, based on the
 * satype of the socket (which is set by the REGISTER message), and the
 * third argument.
 */
int
pfkeyv2_sendmessage(void **headers, int mode, struct socket *socket,
    u_int8_t satype, int count, u_int rdomain)
{
	int i, j, rval;
	void *p, *buffer = NULL;
	struct mbuf *packet;
	struct pfkeyv2_socket *s;
	struct sadb_msg *smsg;

	/* Find out how much space we'll need... */
	j = sizeof(struct sadb_msg);

	for (i = 1; i <= SADB_EXT_MAX; i++)
		if (headers[i])
			j += ((struct sadb_ext *)headers[i])->sadb_ext_len *
			    sizeof(uint64_t);

	/* ...and allocate it */
	if (!(buffer = malloc(j + sizeof(struct sadb_msg), M_PFKEY,
	    M_NOWAIT))) {
		rval = ENOMEM;
		goto ret;
	}

	p = buffer + sizeof(struct sadb_msg);
	bcopy(headers[0], p, sizeof(struct sadb_msg));
	((struct sadb_msg *) p)->sadb_msg_len = j / sizeof(uint64_t);
	p += sizeof(struct sadb_msg);

	/* Copy payloads in the packet */
	for (i = 1; i <= SADB_EXT_MAX; i++)
		if (headers[i]) {
			((struct sadb_ext *) headers[i])->sadb_ext_type = i;
			bcopy(headers[i], p, EXTLEN(headers[i]));
			p += EXTLEN(headers[i]);
		}

	if ((rval = pfdatatopacket(buffer + sizeof(struct sadb_msg),
	    j, &packet)) != 0)
		goto ret;

	switch (mode) {
	case PFKEYV2_SENDMESSAGE_UNICAST:
		/*
		 * Send message to the specified socket, plus all
		 * promiscuous listeners.
		 */
		pfkey_sendup(socket, packet, 0);

		/*
		 * Promiscuous messages contain the original message
		 * encapsulated in another sadb_msg header.
		 */
		bzero(buffer, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) buffer;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + j) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = 0;

		/* Copy to mbuf chain */
		if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
		    &packet)) != 0)
			goto ret;

		/*
		 * Search for promiscuous listeners, skipping the
		 * original destination.
		 */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
			    (s->socket != socket) &&
			    (s->rdomain == rdomain))
				pfkey_sendup(s->socket, packet, 1);

		m_freem(packet);
		break;

	case PFKEYV2_SENDMESSAGE_REGISTERED:
		/*
		 * Send the message to all registered sockets that match
		 * the specified satype (e.g., all IPSEC-ESP negotiators)
		 */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if ((s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED) &&
			    (s->rdomain == rdomain)) {
				if (!satype)    /* Just send to everyone registered */
					pfkey_sendup(s->socket, packet, 1);
				else {
					/* Check for specified satype */
					if ((1 << satype) & s->registration)
						pfkey_sendup(s->socket, packet, 1);
				}
			}

		/* Free last/original copy of the packet */
		m_freem(packet);

		/* Encapsulate the original message "inside" an sadb_msg header */
		bzero(buffer, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) buffer;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + j) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = 0;

		/* Convert to mbuf chain */
		if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
		    &packet)) != 0)
			goto ret;

		/* Send to all registered promiscuous listeners */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
			    !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED) &&
			    (s->rdomain == rdomain))
				pfkey_sendup(s->socket, packet, 1);

		m_freem(packet);
		break;

	case PFKEYV2_SENDMESSAGE_BROADCAST:
		/* Send message to all sockets */
		for (s = pfkeyv2_sockets; s; s = s->next) {
			if (s->rdomain == rdomain)
				pfkey_sendup(s->socket, packet, 1);
		}
		m_freem(packet);
		break;
	}

ret:
	if (buffer != NULL) {
		bzero(buffer, j + sizeof(struct sadb_msg));
		free(buffer, M_PFKEY, 0);
	}

	return (rval);
}

/*
 * Get SPD information for an ACQUIRE. We setup the message such that
 * the SRC/DST payloads are relative to us (regardless of whether the
 * SPD rule was for incoming or outgoing packets).
 */
int
pfkeyv2_policy(struct ipsec_acquire *ipa, void **headers, void **buffer)
{
	union sockaddr_union sunion;
	struct sadb_protocol *sp;
	int rval, i, dir;
	void *p;

	/* Find out how big a buffer we need */
	i = 4 * sizeof(struct sadb_address) + sizeof(struct sadb_protocol);
	bzero(&sunion, sizeof(union sockaddr_union));

	switch (ipa->ipa_info.sen_type) {
	case SENT_IP4:
		i += 4 * PADUP(sizeof(struct sockaddr_in));
		sunion.sa.sa_family = AF_INET;
		sunion.sa.sa_len = sizeof(struct sockaddr_in);
		dir = ipa->ipa_info.sen_direction;
		break;

#ifdef INET6
	case SENT_IP6:
		i += 4 * PADUP(sizeof(struct sockaddr_in6));
		sunion.sa.sa_family = AF_INET6;
		sunion.sa.sa_len = sizeof(struct sockaddr_in6);
		dir = ipa->ipa_info.sen_ip6_direction;
		break;
#endif /* INET6 */

	default:
		return (EINVAL);
	}

	if (!(p = malloc(i, M_PFKEY, M_NOWAIT | M_ZERO))) {
		rval = ENOMEM;
		goto ret;
	} else
		*buffer = p;

	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_SRC_FLOW] = p;
	else
		headers[SADB_X_EXT_DST_FLOW] = p;
	switch (sunion.sa.sa_family) {
	case AF_INET:
		sunion.sin.sin_addr = ipa->ipa_info.sen_ip_src;
		sunion.sin.sin_port = ipa->ipa_info.sen_sport;
		break;

#ifdef INET6
	case AF_INET6:
		sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_src;
		sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_sport;
		break;
#endif /* INET6 */
	}
	export_address(&p, &sunion.sa);

	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_SRC_MASK] = p;
	else
		headers[SADB_X_EXT_DST_MASK] = p;
	switch (sunion.sa.sa_family) {
	case AF_INET:
		sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_src;
		sunion.sin.sin_port = ipa->ipa_mask.sen_sport;
		break;

#ifdef INET6
	case AF_INET6:
		sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_src;
		sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_sport;
		break;
#endif /* INET6 */
	}
	export_address(&p, &sunion.sa);

	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_DST_FLOW] = p;
	else
		headers[SADB_X_EXT_SRC_FLOW] = p;
	switch (sunion.sa.sa_family) {
	case AF_INET:
		sunion.sin.sin_addr = ipa->ipa_info.sen_ip_dst;
		sunion.sin.sin_port = ipa->ipa_info.sen_dport;
		break;

#ifdef INET6
	case AF_INET6:
		sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_dst;
		sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_dport;
		break;
#endif /* INET6 */
	}
	export_address(&p, &sunion.sa);

	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_DST_MASK] = p;
	else
		headers[SADB_X_EXT_SRC_MASK] = p;
	switch (sunion.sa.sa_family) {
	case AF_INET:
		sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_dst;
		sunion.sin.sin_port = ipa->ipa_mask.sen_dport;
		break;

#ifdef INET6
	case AF_INET6:
		sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_dst;
		sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_dport;
		break;
#endif /* INET6 */
	}
	export_address(&p, &sunion.sa);

	headers[SADB_X_EXT_FLOW_TYPE] = p;
	sp = p;
	sp->sadb_protocol_len = sizeof(struct sadb_protocol) /
	    sizeof(u_int64_t);
	switch (sunion.sa.sa_family) {
	case AF_INET:
		if (ipa->ipa_mask.sen_proto)
			sp->sadb_protocol_proto = ipa->ipa_info.sen_proto;
		sp->sadb_protocol_direction = ipa->ipa_info.sen_direction;
		break;

#ifdef INET6
	case AF_INET6:
		if (ipa->ipa_mask.sen_ip6_proto)
			sp->sadb_protocol_proto = ipa->ipa_info.sen_ip6_proto;
		sp->sadb_protocol_direction = ipa->ipa_info.sen_ip6_direction;
		break;
#endif /* INET6 */
	}

	rval = 0;

ret:
	return (rval);
}

/*
 * Get all the information contained in an SA to a PFKEYV2 message.
 */
int
pfkeyv2_get(struct tdb *sa, void **headers, void **buffer, int *lenp)
{
	int rval, i;
	void *p;

	/* Find how much space we need */
	i = sizeof(struct sadb_sa) + sizeof(struct sadb_lifetime);

	if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
	    sa->tdb_soft_timeout || sa->tdb_soft_first_use)
		i += sizeof(struct sadb_lifetime);

	if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
	    sa->tdb_exp_timeout || sa->tdb_exp_first_use)
		i += sizeof(struct sadb_lifetime);

	if (sa->tdb_last_used)
		i += sizeof(struct sadb_lifetime);

	i += sizeof(struct sadb_address) + PADUP(sa->tdb_src.sa.sa_len);
	i += sizeof(struct sadb_address) + PADUP(sa->tdb_dst.sa.sa_len);

	if (sa->tdb_ids) {
		i += sizeof(struct sadb_ident) + PADUP(sa->tdb_ids->id_local->len);
		i += sizeof(struct sadb_ident) + PADUP(sa->tdb_ids->id_remote->len);
	}

	if (sa->tdb_amxkey)
		i += sizeof(struct sadb_key) + PADUP(sa->tdb_amxkeylen);

	if (sa->tdb_emxkey)
		i += sizeof(struct sadb_key) + PADUP(sa->tdb_emxkeylen);

	if (sa->tdb_filter.sen_type) {
		i += 2 * sizeof(struct sadb_protocol);

		/* We'll need four of them: src, src mask, dst, dst mask. */
		switch (sa->tdb_filter.sen_type) {
		case SENT_IP4:
			i += 4 * PADUP(sizeof(struct sockaddr_in));
			i += 4 * sizeof(struct sadb_address);
			break;
#ifdef INET6
		case SENT_IP6:
			i += 4 * PADUP(sizeof(struct sockaddr_in6));
			i += 4 * sizeof(struct sadb_address);
			break;
#endif /* INET6 */
		default:
			rval = EINVAL;
			goto ret;
		}
	}

	if (sa->tdb_onext) {
		i += sizeof(struct sadb_sa);
		i += sizeof(struct sadb_address) +
		    PADUP(sa->tdb_onext->tdb_dst.sa.sa_len);
		i += sizeof(struct sadb_protocol);
	}

	if (sa->tdb_udpencap_port)
		i += sizeof(struct sadb_x_udpencap);

#if NPF > 0
	if (sa->tdb_tag)
		i += sizeof(struct sadb_x_tag) + PADUP(PF_TAG_NAME_SIZE);
	if (sa->tdb_tap)
		i += sizeof(struct sadb_x_tap);
#endif

	if (lenp)
		*lenp = i;

	if (buffer == NULL) {
		rval = 0;
		goto ret;
	}

	if (!(p = malloc(i, M_PFKEY, M_NOWAIT | M_ZERO))) {
		rval = ENOMEM;
		goto ret;
	} else
		*buffer = p;

	headers[SADB_EXT_SA] = p;

	export_sa(&p, sa);  /* Export SA information (mostly flags) */

	/* Export lifetimes where applicable */
	headers[SADB_EXT_LIFETIME_CURRENT] = p;
	export_lifetime(&p, sa, PFKEYV2_LIFETIME_CURRENT);

	if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
	    sa->tdb_soft_first_use || sa->tdb_soft_timeout) {
		headers[SADB_EXT_LIFETIME_SOFT] = p;
		export_lifetime(&p, sa, PFKEYV2_LIFETIME_SOFT);
	}

	if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
	    sa->tdb_exp_first_use || sa->tdb_exp_timeout) {
		headers[SADB_EXT_LIFETIME_HARD] = p;
		export_lifetime(&p, sa, PFKEYV2_LIFETIME_HARD);
	}

	if (sa->tdb_last_used) {
		headers[SADB_X_EXT_LIFETIME_LASTUSE] = p;
		export_lifetime(&p, sa, PFKEYV2_LIFETIME_LASTUSE);
	}

	/* Export TDB source address */
	headers[SADB_EXT_ADDRESS_SRC] = p;
	export_address(&p, &sa->tdb_src.sa);

	/* Export TDB destination address */
	headers[SADB_EXT_ADDRESS_DST] = p;
	export_address(&p, &sa->tdb_dst.sa);

	/* Export source/destination identities, if present */
	if (sa->tdb_ids)
		export_identities(&p, sa->tdb_ids, sa->tdb_ids_swapped, headers);

	/* Export authentication key, if present */
	if (sa->tdb_amxkey) {
		headers[SADB_EXT_KEY_AUTH] = p;
		export_key(&p, sa, PFKEYV2_AUTHENTICATION_KEY);
	}

	/* Export encryption key, if present */
	if (sa->tdb_emxkey) {
		headers[SADB_EXT_KEY_ENCRYPT] = p;
		export_key(&p, sa, PFKEYV2_ENCRYPTION_KEY);
	}

	/* Export flow/filter, if present */
	if (sa->tdb_filter.sen_type)
		export_flow(&p, IPSP_IPSEC_USE, &sa->tdb_filter,
		    &sa->tdb_filtermask, headers);

	if (sa->tdb_onext) {
		headers[SADB_X_EXT_SA2] = p;
		export_sa(&p, sa->tdb_onext);
		headers[SADB_X_EXT_DST2] = p;
		export_address(&p, &sa->tdb_onext->tdb_dst.sa);
		headers[SADB_X_EXT_SATYPE2] = p;
		export_satype(&p, sa->tdb_onext);
	}

	/* Export UDP encapsulation port, if present */
	if (sa->tdb_udpencap_port) {
		headers[SADB_X_EXT_UDPENCAP] = p;
		export_udpencap(&p, sa);
	}

#if NPF > 0
	/* Export tag information, if present */
	if (sa->tdb_tag) {
		headers[SADB_X_EXT_TAG] = p;
		export_tag(&p, sa);
	}

	/* Export tap enc(4) device information, if present */
	if (sa->tdb_tap) {
		headers[SADB_X_EXT_TAP] = p;
		export_tap(&p, sa);
	}
#endif

	rval = 0;

 ret:
	return (rval);
}

/*
 * Dump a TDB.
 */
int
pfkeyv2_dump_walker(struct tdb *sa, void *state, int last)
{
	struct dump_state *dump_state = (struct dump_state *) state;
	void *headers[SADB_EXT_MAX+1], *buffer;
	int rval;

	/* If not satype was specified, dump all TDBs */
	if (!dump_state->sadb_msg->sadb_msg_satype ||
	    (sa->tdb_satype == dump_state->sadb_msg->sadb_msg_satype)) {
		bzero(headers, sizeof(headers));
		headers[0] = (void *) dump_state->sadb_msg;

		/* Get the information from the TDB to a PFKEYv2 message */
		if ((rval = pfkeyv2_get(sa, headers, &buffer, NULL)) != 0)
			return (rval);

		if (last)
			((struct sadb_msg *)headers[0])->sadb_msg_seq = 0;

		/* Send the message to the specified socket */
		rval = pfkeyv2_sendmessage(headers,
		    PFKEYV2_SENDMESSAGE_UNICAST, dump_state->socket, 0, 0,
		    sa->tdb_rdomain);

		free(buffer, M_PFKEY, 0);
		if (rval)
			return (rval);
	}

	return (0);
}

/*
 * Delete an SA.
 */
int
pfkeyv2_flush_walker(struct tdb *sa, void *satype_vp, int last)
{
	if (!(*((u_int8_t *) satype_vp)) ||
	    sa->tdb_satype == *((u_int8_t *) satype_vp))
		tdb_delete(sa);
	return (0);
}

/*
 * Convert between SATYPEs and IPsec protocols, taking into consideration
 * sysctl variables enabling/disabling ESP/AH and the presence of the old
 * IPsec transforms.
 */
int
pfkeyv2_get_proto_alg(u_int8_t satype, u_int8_t *sproto, int *alg)
{
	switch (satype) {
#ifdef IPSEC
	case SADB_SATYPE_AH:
		if (!ah_enable)
			return (EOPNOTSUPP);

		*sproto = IPPROTO_AH;

		if(alg != NULL)
			*alg = satype = XF_AH;

		break;

	case SADB_SATYPE_ESP:
		if (!esp_enable)
			return (EOPNOTSUPP);

		*sproto = IPPROTO_ESP;

		if(alg != NULL)
			*alg = satype = XF_ESP;

		break;

	case SADB_X_SATYPE_IPIP:
		*sproto = IPPROTO_IPIP;

		if (alg != NULL)
			*alg = XF_IP4;

		break;

	case SADB_X_SATYPE_IPCOMP:
		if (!ipcomp_enable)
			return (EOPNOTSUPP);

		*sproto = IPPROTO_IPCOMP;

		if(alg != NULL)
			*alg = satype = XF_IPCOMP;

		break;
#endif /* IPSEC */
#ifdef TCP_SIGNATURE
	case SADB_X_SATYPE_TCPSIGNATURE:
		*sproto = IPPROTO_TCP;

		if (alg != NULL)
			*alg = XF_TCPSIGNATURE;

		break;
#endif /* TCP_SIGNATURE */

	default: /* Nothing else supported */
		return (EOPNOTSUPP);
	}

	return (0);
}

/*
 * Handle all messages from userland to kernel.
 */
int
pfkeyv2_send(struct socket *socket, void *message, int len)
{
	int i, j, rval = 0, mode = PFKEYV2_SENDMESSAGE_BROADCAST;
	int delflag = 0;
	struct sockaddr_encap encapdst, encapnetmask;
	struct ipsec_policy *ipo, *tmpipo;
	struct ipsec_acquire *ipa;
	struct radix_node_head *rnh;
	struct radix_node *rn = NULL;

	struct pfkeyv2_socket *pfkeyv2_socket, *so = NULL;

	void *freeme = NULL, *bckptr = NULL;
	void *headers[SADB_EXT_MAX + 1];

	union sockaddr_union *sunionp;

	struct tdb *sa1 = NULL, *sa2 = NULL;

	struct sadb_msg *smsg;
	struct sadb_spirange *sprng;
	struct sadb_sa *ssa;
	struct sadb_supported *ssup;
	struct sadb_ident *sid, *did;

	u_int rdomain;

	splsoftassert(IPL_SOFTNET);

	/* Verify that we received this over a legitimate pfkeyv2 socket */
	bzero(headers, sizeof(headers));

	for (pfkeyv2_socket = pfkeyv2_sockets; pfkeyv2_socket;
	    pfkeyv2_socket = pfkeyv2_socket->next)
		if (pfkeyv2_socket->socket == socket)
			break;

	if (!pfkeyv2_socket) {
		rval = EINVAL;
		goto ret;
	}

	rdomain = pfkeyv2_socket->rdomain;

	/* If we have any promiscuous listeners, send them a copy of the message */
	if (npromisc) {
		struct mbuf *packet;

		if (!(freeme = malloc(sizeof(struct sadb_msg) + len, M_PFKEY,
		    M_NOWAIT))) {
			rval = ENOMEM;
			goto ret;
		}

		/* Initialize encapsulating header */
		bzero(freeme, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) freeme;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + len) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = curproc->p_p->ps_pid;

		bcopy(message, freeme + sizeof(struct sadb_msg), len);

		/* Convert to mbuf chain */
		if ((rval = pfdatatopacket(freeme,
		    sizeof(struct sadb_msg) + len, &packet)) != 0)
			goto ret;

		/* Send to all promiscuous listeners */
		for (so = pfkeyv2_sockets; so; so = so->next) {
			if ((so->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
			    (so->rdomain == rdomain))
				pfkey_sendup(so->socket, packet, 1);
		}

		m_freem(packet);

		/* Paranoid */
		explicit_bzero(freeme, sizeof(struct sadb_msg) + len);
		free(freeme, M_PFKEY, 0);
		freeme = NULL;
	}

	/* Validate message format */
	if ((rval = pfkeyv2_parsemessage(message, len, headers)) != 0)
		goto ret;

	smsg = (struct sadb_msg *) headers[0];
	switch (smsg->sadb_msg_type) {
	case SADB_GETSPI:  /* Reserve an SPI */
		sa1 = malloc(sizeof (*sa1), M_PFKEY, M_NOWAIT | M_ZERO);
		if (sa1 == NULL) {
			rval = ENOMEM;
			goto ret;
		}

		sa1->tdb_satype = smsg->sadb_msg_satype;
		if ((rval = pfkeyv2_get_proto_alg(sa1->tdb_satype,
		    &sa1->tdb_sproto, 0)))
			goto ret;

		import_address(&sa1->tdb_src.sa, headers[SADB_EXT_ADDRESS_SRC]);
		import_address(&sa1->tdb_dst.sa, headers[SADB_EXT_ADDRESS_DST]);

		/* Find an unused SA identifier */
		sprng = (struct sadb_spirange *) headers[SADB_EXT_SPIRANGE];
		sa1->tdb_spi = reserve_spi(rdomain,
		    sprng->sadb_spirange_min, sprng->sadb_spirange_max,
		    &sa1->tdb_src, &sa1->tdb_dst, sa1->tdb_sproto, &rval);
		if (sa1->tdb_spi == 0)
			goto ret;

		/* Send a message back telling what the SA (the SPI really) is */
		if (!(freeme = malloc(sizeof(struct sadb_sa), M_PFKEY,
		    M_NOWAIT | M_ZERO))) {
			rval = ENOMEM;
			goto ret;
		}

		headers[SADB_EXT_SPIRANGE] = NULL;
		headers[SADB_EXT_SA] = freeme;
		bckptr = freeme;

		/* We really only care about the SPI, but we'll export the SA */
		export_sa((void **) &bckptr, sa1);
		break;

	case SADB_UPDATE:
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		/* Either all or none of the flow must be included */
		if ((headers[SADB_X_EXT_SRC_FLOW] ||
		    headers[SADB_X_EXT_PROTOCOL] ||
		    headers[SADB_X_EXT_FLOW_TYPE] ||
		    headers[SADB_X_EXT_DST_FLOW] ||
		    headers[SADB_X_EXT_SRC_MASK] ||
		    headers[SADB_X_EXT_DST_MASK]) &&
		    !(headers[SADB_X_EXT_SRC_FLOW] &&
		    headers[SADB_X_EXT_PROTOCOL] &&
		    headers[SADB_X_EXT_FLOW_TYPE] &&
		    headers[SADB_X_EXT_DST_FLOW] &&
		    headers[SADB_X_EXT_SRC_MASK] &&
		    headers[SADB_X_EXT_DST_MASK])) {
			rval = EINVAL;
			goto ret;
		}
#ifdef IPSEC
		/* UDP encap has to be enabled and is only supported for ESP */
		if (headers[SADB_X_EXT_UDPENCAP] &&
		    (!udpencap_enable ||
		    smsg->sadb_msg_satype != SADB_SATYPE_ESP)) {
			rval = EINVAL;
			goto ret;
		}
#endif /* IPSEC */

		/* Find TDB */
		sa2 = gettdb(rdomain, ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));

		/* If there's no such SA, we're done */
		if (sa2 == NULL) {
			rval = ESRCH;
			goto ret;
		}

		/* If this is a reserved SA */
		if (sa2->tdb_flags & TDBF_INVALID) {
			struct tdb *newsa;
			struct ipsecinit ii;
			int alg;

			/* Create new TDB */
			freeme = tdb_alloc(rdomain);
			bzero(&ii, sizeof(struct ipsecinit));

			newsa = (struct tdb *) freeme;
			newsa->tdb_satype = smsg->sadb_msg_satype;

			if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
			    &newsa->tdb_sproto, &alg))) {
				tdb_free(freeme);
				freeme = NULL;
				goto ret;
			}

			/* Initialize SA */
			import_sa(newsa, headers[SADB_EXT_SA], &ii);
			import_address(&newsa->tdb_src.sa,
			    headers[SADB_EXT_ADDRESS_SRC]);
			import_address(&newsa->tdb_dst.sa,
			    headers[SADB_EXT_ADDRESS_DST]);
			import_lifetime(newsa,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);
			import_key(&ii, headers[SADB_EXT_KEY_AUTH],
			    PFKEYV2_AUTHENTICATION_KEY);
			import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT],
			    PFKEYV2_ENCRYPTION_KEY);
			newsa->tdb_ids_swapped = 1; /* only on TDB_UPDATE */
			import_identities(&newsa->tdb_ids,
			    newsa->tdb_ids_swapped,
			    headers[SADB_EXT_IDENTITY_SRC],
			    headers[SADB_EXT_IDENTITY_DST]);
			import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
			    headers[SADB_X_EXT_SRC_FLOW],
			    headers[SADB_X_EXT_SRC_MASK],
			    headers[SADB_X_EXT_DST_FLOW],
			    headers[SADB_X_EXT_DST_MASK],
			    headers[SADB_X_EXT_PROTOCOL],
			    headers[SADB_X_EXT_FLOW_TYPE]);
			import_udpencap(newsa, headers[SADB_X_EXT_UDPENCAP]);
#if NPF > 0
			import_tag(newsa, headers[SADB_X_EXT_TAG]);
			import_tap(newsa, headers[SADB_X_EXT_TAP]);
#endif

			/* Exclude sensitive data from reply message. */
			headers[SADB_EXT_KEY_AUTH] = NULL;
			headers[SADB_EXT_KEY_ENCRYPT] = NULL;
			headers[SADB_X_EXT_LOCAL_AUTH] = NULL;
			headers[SADB_X_EXT_REMOTE_AUTH] = NULL;

			newsa->tdb_seq = smsg->sadb_msg_seq;

			rval = tdb_init(newsa, alg, &ii);
			if (rval) {
				rval = EINVAL;
				tdb_free(freeme);
				freeme = NULL;
				goto ret;
			}

			newsa->tdb_cur_allocations = sa2->tdb_cur_allocations;

			/* Delete old version of the SA, insert new one */
			tdb_delete(sa2);
			puttdb((struct tdb *) freeme);
			sa2 = freeme = NULL;
		} else {
			/*
			 * The SA is already initialized, so we're only allowed to
			 * change lifetimes and some other information; we're
			 * not allowed to change keys, addresses or identities.
			 */
			if (headers[SADB_EXT_KEY_AUTH] ||
			    headers[SADB_EXT_KEY_ENCRYPT] ||
			    headers[SADB_EXT_IDENTITY_SRC] ||
			    headers[SADB_EXT_IDENTITY_DST] ||
			    headers[SADB_EXT_SENSITIVITY]) {
				rval = EINVAL;
				goto ret;
			}

			import_sa(sa2, headers[SADB_EXT_SA], NULL);
			import_lifetime(sa2,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(sa2, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(sa2, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);
			import_udpencap(sa2, headers[SADB_X_EXT_UDPENCAP]);
#if NPF > 0
			import_tag(sa2, headers[SADB_X_EXT_TAG]);
			import_tap(sa2, headers[SADB_X_EXT_TAP]);
#endif
		}

		break;
	case SADB_ADD:
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		/* Either all or none of the flow must be included */
		if ((headers[SADB_X_EXT_SRC_FLOW] ||
		    headers[SADB_X_EXT_PROTOCOL] ||
		    headers[SADB_X_EXT_FLOW_TYPE] ||
		    headers[SADB_X_EXT_DST_FLOW] ||
		    headers[SADB_X_EXT_SRC_MASK] ||
		    headers[SADB_X_EXT_DST_MASK]) &&
		    !(headers[SADB_X_EXT_SRC_FLOW] &&
		    headers[SADB_X_EXT_PROTOCOL] &&
		    headers[SADB_X_EXT_FLOW_TYPE] &&
		    headers[SADB_X_EXT_DST_FLOW] &&
		    headers[SADB_X_EXT_SRC_MASK] &&
		    headers[SADB_X_EXT_DST_MASK])) {
			rval = EINVAL;
			goto ret;
		}
#ifdef IPSEC
		/* UDP encap has to be enabled and is only supported for ESP */
		if (headers[SADB_X_EXT_UDPENCAP] &&
		    (!udpencap_enable ||
		    smsg->sadb_msg_satype != SADB_SATYPE_ESP)) {
			rval = EINVAL;
			goto ret;
		}
#endif /* IPSEC */

		sa2 = gettdb(rdomain, ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));

		/* We can't add an existing SA! */
		if (sa2 != NULL) {
			rval = EEXIST;
			goto ret;
		}

		/* We can only add "mature" SAs */
		if (ssa->sadb_sa_state != SADB_SASTATE_MATURE) {
			rval = EINVAL;
			goto ret;
		}

		/* Allocate and initialize new TDB */
		freeme = tdb_alloc(rdomain);

		{
			struct tdb *newsa = (struct tdb *) freeme;
			struct ipsecinit ii;
			int alg;

			bzero(&ii, sizeof(struct ipsecinit));

			newsa->tdb_satype = smsg->sadb_msg_satype;
			if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
			    &newsa->tdb_sproto, &alg))) {
				tdb_free(freeme);
				freeme = NULL;
				goto ret;
			}

			import_sa(newsa, headers[SADB_EXT_SA], &ii);
			import_address(&newsa->tdb_src.sa,
			    headers[SADB_EXT_ADDRESS_SRC]);
			import_address(&newsa->tdb_dst.sa,
			    headers[SADB_EXT_ADDRESS_DST]);

			import_lifetime(newsa,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);

			import_key(&ii, headers[SADB_EXT_KEY_AUTH],
			    PFKEYV2_AUTHENTICATION_KEY);
			import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT],
			    PFKEYV2_ENCRYPTION_KEY);

			import_identities(&newsa->tdb_ids,
			    newsa->tdb_ids_swapped,
			    headers[SADB_EXT_IDENTITY_SRC],
			    headers[SADB_EXT_IDENTITY_DST]);

			import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
			    headers[SADB_X_EXT_SRC_FLOW],
			    headers[SADB_X_EXT_SRC_MASK],
			    headers[SADB_X_EXT_DST_FLOW],
			    headers[SADB_X_EXT_DST_MASK],
			    headers[SADB_X_EXT_PROTOCOL],
			    headers[SADB_X_EXT_FLOW_TYPE]);
			import_udpencap(newsa, headers[SADB_X_EXT_UDPENCAP]);
#if NPF > 0
			import_tag(newsa, headers[SADB_X_EXT_TAG]);
			import_tap(newsa, headers[SADB_X_EXT_TAP]);
#endif

			/* Exclude sensitive data from reply message. */
			headers[SADB_EXT_KEY_AUTH] = NULL;
			headers[SADB_EXT_KEY_ENCRYPT] = NULL;
			headers[SADB_X_EXT_LOCAL_AUTH] = NULL;
			headers[SADB_X_EXT_REMOTE_AUTH] = NULL;

			newsa->tdb_seq = smsg->sadb_msg_seq;

			rval = tdb_init(newsa, alg, &ii);
			if (rval) {
				rval = EINVAL;
				tdb_free(freeme);
				freeme = NULL;
				goto ret;
			}
		}

		/* Add TDB in table */
		puttdb((struct tdb *) freeme);

		freeme = NULL;
		break;

	case SADB_DELETE:
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp =
		    (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
			sizeof(struct sadb_address));

		sa2 = gettdb(rdomain, ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (sa2 == NULL) {
			rval = ESRCH;
			goto ret;
		}

		tdb_delete(sa2);

		sa2 = NULL;
		break;

	case SADB_X_ASKPOLICY:
		/* Get the relevant policy */
		ipa = ipsec_get_acquire(((struct sadb_x_policy *) headers[SADB_X_EXT_POLICY])->sadb_x_policy_seq);
		if (ipa == NULL) {
			rval = ESRCH;
			goto ret;
		}

		rval = pfkeyv2_policy(ipa, headers, &freeme);
		if (rval)
			mode = PFKEYV2_SENDMESSAGE_UNICAST;

		break;

	case SADB_GET:
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp =
		    (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
			sizeof(struct sadb_address));

		sa2 = gettdb(rdomain, ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (sa2 == NULL) {
			rval = ESRCH;
			goto ret;
		}

		rval = pfkeyv2_get(sa2, headers, &freeme, NULL);
		if (rval)
			mode = PFKEYV2_SENDMESSAGE_UNICAST;

		break;

	case SADB_REGISTER:
		if (!(pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_REGISTERED)) {
			pfkeyv2_socket->flags |= PFKEYV2_SOCKETFLAGS_REGISTERED;
			nregistered++;
		}

		i = sizeof(struct sadb_supported) + sizeof(ealgs);

		if (!(freeme = malloc(i, M_PFKEY, M_NOWAIT | M_ZERO))) {
			rval = ENOMEM;
			goto ret;
		}

		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);

		{
			void *p = freeme + sizeof(struct sadb_supported);

			bcopy(&ealgs[0], p, sizeof(ealgs));
		}

		headers[SADB_EXT_SUPPORTED_ENCRYPT] = freeme;

		i = sizeof(struct sadb_supported) + sizeof(aalgs);

		if (!(freeme = malloc(i, M_PFKEY, M_NOWAIT | M_ZERO))) {
			rval = ENOMEM;
			goto ret;
		}

		/* Keep track what this socket has registered for */
		pfkeyv2_socket->registration |= (1 << ((struct sadb_msg *)message)->sadb_msg_satype);

		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);

		{
			void *p = freeme + sizeof(struct sadb_supported);

			bcopy(&aalgs[0], p, sizeof(aalgs));
		}

		headers[SADB_EXT_SUPPORTED_AUTH] = freeme;

		i = sizeof(struct sadb_supported) + sizeof(calgs);

		if (!(freeme = malloc(i, M_PFKEY, M_NOWAIT | M_ZERO))) {
			rval = ENOMEM;
			goto ret;
		}

		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);

		{
			void *p = freeme + sizeof(struct sadb_supported);

			bcopy(&calgs[0], p, sizeof(calgs));
		}

		headers[SADB_X_EXT_SUPPORTED_COMP] = freeme;

		break;

	case SADB_ACQUIRE:
	case SADB_EXPIRE:
		/* Nothing to handle */
		rval = 0;
		break;

	case SADB_FLUSH:
		rval = 0;

		switch (smsg->sadb_msg_satype) {
		case SADB_SATYPE_UNSPEC:
			for (ipo = TAILQ_FIRST(&ipsec_policy_head);
			    ipo != NULL; ipo = tmpipo) {
				tmpipo = TAILQ_NEXT(ipo, ipo_list);
				if (ipo->ipo_rdomain == rdomain)
					ipsec_delete_policy(ipo);
			}
			/* FALLTHROUGH */
		case SADB_SATYPE_AH:
		case SADB_SATYPE_ESP:
		case SADB_X_SATYPE_IPIP:
		case SADB_X_SATYPE_IPCOMP:
#ifdef TCP_SIGNATURE
		case SADB_X_SATYPE_TCPSIGNATURE:
#endif /* TCP_SIGNATURE */
			tdb_walk(rdomain, pfkeyv2_flush_walker,
			    (u_int8_t *) &(smsg->sadb_msg_satype));

			break;

		default:
			rval = EINVAL; /* Unknown/unsupported type */
		}

		break;

	case SADB_DUMP:
	{
		struct dump_state dump_state;
		dump_state.sadb_msg = (struct sadb_msg *) headers[0];
		dump_state.socket = socket;

		rval = tdb_walk(rdomain, pfkeyv2_dump_walker, &dump_state);
		if (!rval)
			goto realret;

		if ((rval == ENOMEM) || (rval == ENOBUFS))
			rval = 0;
	}
	break;

	case SADB_X_GRPSPIS:
	{
		struct tdb *tdb1, *tdb2, *tdb3;
		struct sadb_protocol *sa_proto;

		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		tdb1 = gettdb(rdomain, ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (tdb1 == NULL) {
			rval = ESRCH;
			goto ret;
		}

		ssa = (struct sadb_sa *) headers[SADB_X_EXT_SA2];
		sunionp = (union sockaddr_union *) (headers[SADB_X_EXT_DST2] +
		    sizeof(struct sadb_address));
		sa_proto = (struct sadb_protocol *) headers[SADB_X_EXT_SATYPE2];

		tdb2 = gettdb(rdomain, ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(sa_proto->sadb_protocol_proto));
		if (tdb2 == NULL) {
			rval = ESRCH;
			goto ret;
		}

		/* Detect cycles */
		for (tdb3 = tdb2; tdb3; tdb3 = tdb3->tdb_onext)
			if (tdb3 == tdb1) {
				rval = ESRCH;
				goto ret;
			}

		/* Maintenance */
		if ((tdb1->tdb_onext) &&
		    (tdb1->tdb_onext->tdb_inext == tdb1))
			tdb1->tdb_onext->tdb_inext = NULL;

		if ((tdb2->tdb_inext) &&
		    (tdb2->tdb_inext->tdb_onext == tdb2))
			tdb2->tdb_inext->tdb_onext = NULL;

		/* Link them */
		tdb1->tdb_onext = tdb2;
		tdb2->tdb_inext = tdb1;
	}
	break;

	case SADB_X_DELFLOW:
		delflag = 1;
		/*FALLTHROUGH*/
	case SADB_X_ADDFLOW:
	{
		struct sadb_protocol *sab;
		union sockaddr_union *ssrc;
		int exists = 0;

		if ((rnh = spd_table_add(rdomain)) == NULL) {
			rval = ENOMEM;
			goto ret;
		}

		sab = (struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE];

		if ((sab->sadb_protocol_direction != IPSP_DIRECTION_IN) &&
		    (sab->sadb_protocol_direction != IPSP_DIRECTION_OUT)) {
			rval = EINVAL;
			goto ret;
		}

		/* If the security protocol wasn't specified, pretend it was ESP */
		if (smsg->sadb_msg_satype == 0)
			smsg->sadb_msg_satype = SADB_SATYPE_ESP;

		if (headers[SADB_EXT_ADDRESS_DST])
			sunionp = (union sockaddr_union *)
			    (headers[SADB_EXT_ADDRESS_DST] +
				sizeof(struct sadb_address));
		else
			sunionp = NULL;

		if (headers[SADB_EXT_ADDRESS_SRC])
			ssrc = (union sockaddr_union *)
			    (headers[SADB_EXT_ADDRESS_SRC] +
				sizeof(struct sadb_address));
		else
			ssrc = NULL;

		import_flow(&encapdst, &encapnetmask,
		    headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		    headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		    headers[SADB_X_EXT_PROTOCOL], headers[SADB_X_EXT_FLOW_TYPE]);

		/* Determine whether the exact same SPD entry already exists. */
		if ((rn = rn_match(&encapdst, rnh)) != NULL) {
			ipo = (struct ipsec_policy *)rn;

			/* Verify that the entry is identical */
			if (bcmp(&ipo->ipo_addr, &encapdst,
				sizeof(struct sockaddr_encap)) ||
			    bcmp(&ipo->ipo_mask, &encapnetmask,
				sizeof(struct sockaddr_encap)))
				ipo = NULL; /* Fall through */
			else
				exists = 1;
		} else
			ipo = NULL;

		/*
		 * If the existing policy is static, only delete or update
		 * it if the new one is also static.
		 */
		if (exists && (ipo->ipo_flags & IPSP_POLICY_STATIC)) {
			if (!(sab->sadb_protocol_flags &
				SADB_X_POLICYFLAGS_POLICY)) {
				goto ret;
			}
		}

		/* Delete ? */
		if (delflag) {
			if (exists) {
				rval = ipsec_delete_policy(ipo);
				goto ret;
			}

			/* If we were asked to delete something non-existent, error. */
			rval = ESRCH;
			break;
		}

		if (!exists) {
			if (ipsec_policy_pool_initialized == 0) {
				ipsec_policy_pool_initialized = 1;
				pool_init(&ipsec_policy_pool,
				    sizeof(struct ipsec_policy), 0,
				    IPL_NONE, 0, "ipsec policy", NULL);
			}

			/* Allocate policy entry */
			ipo = pool_get(&ipsec_policy_pool, PR_NOWAIT|PR_ZERO);
			if (ipo == NULL) {
				rval = ENOMEM;
				goto ret;
			}
		}

		switch (sab->sadb_protocol_proto) {
		case SADB_X_FLOW_TYPE_USE:
			ipo->ipo_type = IPSP_IPSEC_USE;
			break;

		case SADB_X_FLOW_TYPE_ACQUIRE:
			ipo->ipo_type = IPSP_IPSEC_ACQUIRE;
			break;

		case SADB_X_FLOW_TYPE_REQUIRE:
			ipo->ipo_type = IPSP_IPSEC_REQUIRE;
			break;

		case SADB_X_FLOW_TYPE_DENY:
			ipo->ipo_type = IPSP_DENY;
			break;

		case SADB_X_FLOW_TYPE_BYPASS:
			ipo->ipo_type = IPSP_PERMIT;
			break;

		case SADB_X_FLOW_TYPE_DONTACQ:
			ipo->ipo_type = IPSP_IPSEC_DONTACQ;
			break;

		default:
			if (!exists)
				pool_put(&ipsec_policy_pool, ipo);
			else
				ipsec_delete_policy(ipo);

			rval = EINVAL;
			goto ret;
		}

		if (sab->sadb_protocol_flags & SADB_X_POLICYFLAGS_POLICY)
			ipo->ipo_flags |= IPSP_POLICY_STATIC;

		if (sunionp)
			bcopy(sunionp, &ipo->ipo_dst,
			    sizeof(union sockaddr_union));
		else
			bzero(&ipo->ipo_dst, sizeof(union sockaddr_union));

		if (ssrc)
			bcopy(ssrc, &ipo->ipo_src,
			    sizeof(union sockaddr_union));
		else
			bzero(&ipo->ipo_src, sizeof(union sockaddr_union));

		ipo->ipo_sproto = SADB_X_GETSPROTO(smsg->sadb_msg_satype);

		if (ipo->ipo_ids) {
			ipsp_ids_free(ipo->ipo_ids);
			ipo->ipo_ids = NULL;
		}

		if ((sid = headers[SADB_EXT_IDENTITY_SRC]) != NULL &&
		    (did = headers[SADB_EXT_IDENTITY_DST]) != NULL) {
			import_identities(&ipo->ipo_ids, 0, sid, did);
			if (ipo->ipo_ids == NULL) {
				if (exists)
					ipsec_delete_policy(ipo);
				else
					pool_put(&ipsec_policy_pool, ipo);
				rval = ENOBUFS;
				goto ret;
			}
		}

		/* Flow type */
		if (!exists) {
			/* Initialize policy entry */
			bcopy(&encapdst, &ipo->ipo_addr,
			    sizeof(struct sockaddr_encap));
			bcopy(&encapnetmask, &ipo->ipo_mask,
			    sizeof(struct sockaddr_encap));

			TAILQ_INIT(&ipo->ipo_acquires);
			ipo->ipo_rdomain = rdomain;
			ipo->ipo_ref_count = 1;

			/* Add SPD entry */
			if ((rnh = spd_table_get(rdomain)) == NULL ||
			    (rn = rn_addroute((caddr_t)&ipo->ipo_addr,
				(caddr_t)&ipo->ipo_mask, rnh,
				ipo->ipo_nodes, 0)) == NULL) {
				/* Remove from linked list of policies on TDB */
				if (ipo->ipo_tdb)
					TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head,
					    ipo, ipo_tdb_next);

				if (ipo->ipo_ids)
					ipsp_ids_free(ipo->ipo_ids);
				pool_put(&ipsec_policy_pool, ipo);

				goto ret;
			}
			TAILQ_INSERT_HEAD(&ipsec_policy_head, ipo, ipo_list);
			ipsec_in_use++;
		} else {
			ipo->ipo_last_searched = ipo->ipo_flags = 0;
		}
	}
	break;

	case SADB_X_PROMISC:
		if (len >= 2 * sizeof(struct sadb_msg)) {
			struct mbuf *packet;

			if ((rval = pfdatatopacket(message, len, &packet)) != 0)
				goto ret;

			for (so = pfkeyv2_sockets; so; so = so->next)
				if ((so != pfkeyv2_socket) &&
				    (so->rdomain == rdomain) &&
				    (!smsg->sadb_msg_seq ||
				    (smsg->sadb_msg_seq == pfkeyv2_socket->pid)))
					pfkey_sendup(so->socket, packet, 1);

			m_freem(packet);
		} else {
			if (len != sizeof(struct sadb_msg)) {
				rval = EINVAL;
				goto ret;
			}

			i = (pfkeyv2_socket->flags &
			    PFKEYV2_SOCKETFLAGS_PROMISC) ? 1 : 0;
			j = smsg->sadb_msg_satype ? 1 : 0;

			if (i ^ j) {
				if (j) {
					pfkeyv2_socket->flags |=
					    PFKEYV2_SOCKETFLAGS_PROMISC;
					npromisc++;
				} else {
					pfkeyv2_socket->flags &=
					    ~PFKEYV2_SOCKETFLAGS_PROMISC;
					npromisc--;
				}
			}
		}

		break;

	default:
		rval = EINVAL;
		goto ret;
	}

ret:
	if (rval) {
		if ((rval == EINVAL) || (rval == ENOMEM) || (rval == ENOBUFS))
			goto realret;

		for (i = 1; i <= SADB_EXT_MAX; i++)
			headers[i] = NULL;

		smsg->sadb_msg_errno = abs(rval);
	} else {
		uint64_t seen = 0LL;

		for (i = 1; i <= SADB_EXT_MAX; i++)
			if (headers[i])
				seen |= (1LL << i);

		if ((seen & sadb_exts_allowed_out[smsg->sadb_msg_type])
		    != seen)
			goto realret;

		if ((seen & sadb_exts_required_out[smsg->sadb_msg_type]) !=
		    sadb_exts_required_out[smsg->sadb_msg_type])
			goto realret;
	}

	rval = pfkeyv2_sendmessage(headers, mode, socket, 0, 0, rdomain);

realret:
	if (freeme)
		free(freeme, M_PFKEY, 0);

	explicit_bzero(message, len);
	free(message, M_PFKEY, 0);

	if (sa1)
		free(sa1, M_PFKEY, 0);

	return (rval);
}

/*
 * Send an ACQUIRE message to key management, to get a new SA.
 */
int
pfkeyv2_acquire(struct ipsec_policy *ipo, union sockaddr_union *gw,
    union sockaddr_union *laddr, u_int32_t *seq, struct sockaddr_encap *ddst)
{
	void *p, *headers[SADB_EXT_MAX + 1], *buffer = NULL;
	struct sadb_comb *sadb_comb;
	struct sadb_address *sadd;
	struct sadb_prop *sa_prop;
	struct sadb_msg *smsg;
	int rval = 0;
	int i, j;

	*seq = pfkeyv2_seq++;

	if (!nregistered) {
		rval = ESRCH;
		goto ret;
	}

	/* How large a buffer do we need... XXX we only do one proposal for now */
	i = sizeof(struct sadb_msg) +
	    (laddr == NULL ? 0 : sizeof(struct sadb_address) +
		PADUP(ipo->ipo_src.sa.sa_len)) +
	    sizeof(struct sadb_address) + PADUP(gw->sa.sa_len) +
	    sizeof(struct sadb_prop) + 1 * sizeof(struct sadb_comb);

	if (ipo->ipo_ids) {
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_ids->id_local->len);
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_ids->id_remote->len);
	}

	/* Allocate */
	if (!(p = malloc(i, M_PFKEY, M_NOWAIT | M_ZERO))) {
		rval = ENOMEM;
		goto ret;
	}

	bzero(headers, sizeof(headers));

	buffer = p;

	headers[0] = p;
	p += sizeof(struct sadb_msg);

	smsg = (struct sadb_msg *) headers[0];
	smsg->sadb_msg_version = PF_KEY_V2;
	smsg->sadb_msg_type = SADB_ACQUIRE;
	smsg->sadb_msg_len = i / sizeof(uint64_t);
	smsg->sadb_msg_seq = *seq;

	if (ipo->ipo_sproto == IPPROTO_ESP)
		smsg->sadb_msg_satype = SADB_SATYPE_ESP;
	else if (ipo->ipo_sproto == IPPROTO_AH)
		smsg->sadb_msg_satype = SADB_SATYPE_AH;
	else if (ipo->ipo_sproto == IPPROTO_IPCOMP)
		smsg->sadb_msg_satype = SADB_X_SATYPE_IPCOMP;

	if (laddr) {
		headers[SADB_EXT_ADDRESS_SRC] = p;
		p += sizeof(struct sadb_address) + PADUP(laddr->sa.sa_len);
		sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_SRC];
		sadd->sadb_address_len = (sizeof(struct sadb_address) +
		    laddr->sa.sa_len + sizeof(uint64_t) - 1) /
		    sizeof(uint64_t);
		bcopy(laddr, headers[SADB_EXT_ADDRESS_SRC] +
		    sizeof(struct sadb_address), laddr->sa.sa_len);
	}

	headers[SADB_EXT_ADDRESS_DST] = p;
	p += sizeof(struct sadb_address) + PADUP(gw->sa.sa_len);
	sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_DST];
	sadd->sadb_address_len = (sizeof(struct sadb_address) +
	    gw->sa.sa_len + sizeof(uint64_t) - 1) / sizeof(uint64_t);
	bcopy(gw, headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address),
	    gw->sa.sa_len);

	if (ipo->ipo_ids)
		export_identities(&p, ipo->ipo_ids, 0, headers);

	headers[SADB_EXT_PROPOSAL] = p;
	p += sizeof(struct sadb_prop);
	sa_prop = (struct sadb_prop *) headers[SADB_EXT_PROPOSAL];
	sa_prop->sadb_prop_num = 1; /* XXX One proposal only */
	sa_prop->sadb_prop_len = (sizeof(struct sadb_prop) +
	    (sizeof(struct sadb_comb) * sa_prop->sadb_prop_num)) /
	    sizeof(uint64_t);

	sadb_comb = p;

	/* XXX Should actually ask the crypto layer what's supported */
	for (j = 0; j < sa_prop->sadb_prop_num; j++) {
		sadb_comb->sadb_comb_flags = 0;

		if (ipsec_require_pfs)
			sadb_comb->sadb_comb_flags |= SADB_SAFLAGS_PFS;

		/* Set the encryption algorithm */
		if (ipo->ipo_sproto == IPPROTO_ESP) {
			if (!strncasecmp(ipsec_def_enc, "aes",
			    sizeof("aes"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_AES;
				sadb_comb->sadb_comb_encrypt_minbits = 128;
				sadb_comb->sadb_comb_encrypt_maxbits = 256;
			} else if (!strncasecmp(ipsec_def_enc, "aesctr",
			    sizeof("aesctr"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_AESCTR;
				sadb_comb->sadb_comb_encrypt_minbits = 128+32;
				sadb_comb->sadb_comb_encrypt_maxbits = 256+32;
			} else if (!strncasecmp(ipsec_def_enc, "3des",
			    sizeof("3des"))) {
				sadb_comb->sadb_comb_encrypt = SADB_EALG_3DESCBC;
				sadb_comb->sadb_comb_encrypt_minbits = 192;
				sadb_comb->sadb_comb_encrypt_maxbits = 192;
			} else if (!strncasecmp(ipsec_def_enc, "blowfish",
			    sizeof("blowfish"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
				sadb_comb->sadb_comb_encrypt_minbits = 40;
				sadb_comb->sadb_comb_encrypt_maxbits = BLF_MAXKEYLEN * 8;
			} else if (!strncasecmp(ipsec_def_enc, "cast128",
			    sizeof("cast128"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
				sadb_comb->sadb_comb_encrypt_minbits = 40;
				sadb_comb->sadb_comb_encrypt_maxbits = 128;
			}
		} else if (ipo->ipo_sproto == IPPROTO_IPCOMP) {
			/* Set the compression algorithm */
			if (!strncasecmp(ipsec_def_comp, "deflate",
			    sizeof("deflate"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_CALG_DEFLATE;
				sadb_comb->sadb_comb_encrypt_minbits = 0;
				sadb_comb->sadb_comb_encrypt_maxbits = 0;
			} else if (!strncasecmp(ipsec_def_comp, "lzs",
			    sizeof("lzs"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_CALG_LZS;
				sadb_comb->sadb_comb_encrypt_minbits = 0;
				sadb_comb->sadb_comb_encrypt_maxbits = 0;
			}
		}

		/* Set the authentication algorithm */
		if (!strncasecmp(ipsec_def_auth, "hmac-sha1",
		    sizeof("hmac-sha1"))) {
			sadb_comb->sadb_comb_auth = SADB_AALG_SHA1HMAC;
			sadb_comb->sadb_comb_auth_minbits = 160;
			sadb_comb->sadb_comb_auth_maxbits = 160;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
		    sizeof("hmac_ripemd160"))) {
			sadb_comb->sadb_comb_auth = SADB_X_AALG_RIPEMD160HMAC;
			sadb_comb->sadb_comb_auth_minbits = 160;
			sadb_comb->sadb_comb_auth_maxbits = 160;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-md5",
		    sizeof("hmac-md5"))) {
			sadb_comb->sadb_comb_auth = SADB_AALG_MD5HMAC;
			sadb_comb->sadb_comb_auth_minbits = 128;
			sadb_comb->sadb_comb_auth_maxbits = 128;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-sha2-256",
		    sizeof("hmac-sha2-256"))) {
			sadb_comb->sadb_comb_auth = SADB_X_AALG_SHA2_256;
			sadb_comb->sadb_comb_auth_minbits = 256;
			sadb_comb->sadb_comb_auth_maxbits = 256;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-sha2-384",
		    sizeof("hmac-sha2-384"))) {
			sadb_comb->sadb_comb_auth = SADB_X_AALG_SHA2_384;
			sadb_comb->sadb_comb_auth_minbits = 384;
			sadb_comb->sadb_comb_auth_maxbits = 384;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-sha2-512",
		    sizeof("hmac-sha2-512"))) {
			sadb_comb->sadb_comb_auth = SADB_X_AALG_SHA2_512;
			sadb_comb->sadb_comb_auth_minbits = 512;
			sadb_comb->sadb_comb_auth_maxbits = 512;
		}

		sadb_comb->sadb_comb_soft_allocations = ipsec_soft_allocations;
		sadb_comb->sadb_comb_hard_allocations = ipsec_exp_allocations;

		sadb_comb->sadb_comb_soft_bytes = ipsec_soft_bytes;
		sadb_comb->sadb_comb_hard_bytes = ipsec_exp_bytes;

		sadb_comb->sadb_comb_soft_addtime = ipsec_soft_timeout;
		sadb_comb->sadb_comb_hard_addtime = ipsec_exp_timeout;

		sadb_comb->sadb_comb_soft_usetime = ipsec_soft_first_use;
		sadb_comb->sadb_comb_hard_usetime = ipsec_exp_first_use;
		sadb_comb++;
	}

	/* Send the ACQUIRE message to all compliant registered listeners. */
	if ((rval = pfkeyv2_sendmessage(headers,
	    PFKEYV2_SENDMESSAGE_REGISTERED, NULL, smsg->sadb_msg_satype, 0,
	    ipo->ipo_rdomain)) != 0)
		goto ret;

	rval = 0;
ret:
	if (buffer != NULL) {
		bzero(buffer, i);
		free(buffer, M_PFKEY, 0);
	}

	return (rval);
}

/*
 * Notify key management that an expiration went off. The second argument
 * specifies the type of expiration (soft or hard).
 */
int
pfkeyv2_expire(struct tdb *sa, u_int16_t type)
{
	void *p, *headers[SADB_EXT_MAX+1], *buffer = NULL;
	struct sadb_msg *smsg;
	int rval = 0;
	int i;

	switch (sa->tdb_sproto) {
	case IPPROTO_AH:
	case IPPROTO_ESP:
	case IPPROTO_IPIP:
	case IPPROTO_IPCOMP:
#ifdef TCP_SIGNATURE
	case IPPROTO_TCP:
#endif /* TCP_SIGNATURE */
		break;

	default:
		rval = EOPNOTSUPP;
		goto ret;
	}

	i = sizeof(struct sadb_msg) + sizeof(struct sadb_sa) +
	    2 * sizeof(struct sadb_lifetime) +
	    sizeof(struct sadb_address) + PADUP(sa->tdb_src.sa.sa_len) +
	    sizeof(struct sadb_address) + PADUP(sa->tdb_dst.sa.sa_len);

	if (!(p = malloc(i, M_PFKEY, M_NOWAIT | M_ZERO))) {
		rval = ENOMEM;
		goto ret;
	}

	bzero(headers, sizeof(headers));

	buffer = p;

	headers[0] = p;
	p += sizeof(struct sadb_msg);

	smsg = (struct sadb_msg *) headers[0];
	smsg->sadb_msg_version = PF_KEY_V2;
	smsg->sadb_msg_type = SADB_EXPIRE;
	smsg->sadb_msg_satype = sa->tdb_satype;
	smsg->sadb_msg_len = i / sizeof(uint64_t);
	smsg->sadb_msg_seq = pfkeyv2_seq++;

	headers[SADB_EXT_SA] = p;
	export_sa(&p, sa);

	headers[SADB_EXT_LIFETIME_CURRENT] = p;
	export_lifetime(&p, sa, 2);

	headers[type] = p;
	export_lifetime(&p, sa, type == SADB_EXT_LIFETIME_SOFT ?
	    PFKEYV2_LIFETIME_SOFT : PFKEYV2_LIFETIME_HARD);

	headers[SADB_EXT_ADDRESS_SRC] = p;
	export_address(&p, &sa->tdb_src.sa);

	headers[SADB_EXT_ADDRESS_DST] = p;
	export_address(&p, &sa->tdb_dst.sa);

	if ((rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_BROADCAST,
	    NULL, 0, 0, sa->tdb_rdomain)) != 0)
		goto ret;

	rval = 0;

 ret:
	if (buffer != NULL) {
		bzero(buffer, i);
		free(buffer, M_PFKEY, 0);
	}

	return (rval);
}

struct pfkeyv2_sysctl_walk {
	void		*w_where;
	size_t		 w_len;
	int		 w_op;
	u_int8_t	 w_satype;
};

int
pfkeyv2_sysctl_walker(struct tdb *sa, void *arg, int last)
{
	struct pfkeyv2_sysctl_walk *w = (struct pfkeyv2_sysctl_walk *)arg;
	void *buffer = NULL;
	int error = 0;
	int buflen, i;

	if (w->w_satype != SADB_SATYPE_UNSPEC &&
	    w->w_satype != sa->tdb_satype)
		return (0);

	if (w->w_where) {
		void *headers[SADB_EXT_MAX+1];
		struct sadb_msg msg;

		bzero(headers, sizeof(headers));
		if ((error = pfkeyv2_get(sa, headers, &buffer, &buflen)) != 0)
			goto done;
		if (w->w_len < sizeof(msg) + buflen) {
			error = ENOMEM;
			goto done;
		}
		/* prepend header */
		bzero(&msg, sizeof(msg));
		msg.sadb_msg_version = PF_KEY_V2;
		msg.sadb_msg_satype = sa->tdb_satype;
		msg.sadb_msg_type = SADB_DUMP;
		msg.sadb_msg_len = (sizeof(msg) + buflen) / sizeof(uint64_t);
		if ((error = copyout(&msg, w->w_where, sizeof(msg))) != 0)
			goto done;
		w->w_where += sizeof(msg);
		w->w_len -= sizeof(msg);
		/* set extension type */
		for (i = 1; i <= SADB_EXT_MAX; i++)
			if (headers[i])
				((struct sadb_ext *)
				    headers[i])->sadb_ext_type = i;
		if ((error = copyout(buffer, w->w_where, buflen)) != 0)
			goto done;
		w->w_where += buflen;
		w->w_len -= buflen;
	} else {
		if ((error = pfkeyv2_get(sa, NULL, NULL, &buflen)) != 0)
			return (error);
		w->w_len += buflen;
		w->w_len += sizeof(struct sadb_msg);
	}

done:
	if (buffer)
		free(buffer, M_PFKEY, 0);
	return (error);
}

int
pfkeyv2_dump_policy(struct ipsec_policy *ipo, void **headers, void **buffer,
    int *lenp)
{
	int i, rval, perm;
	void *p;

	/* Find how much space we need. */
	i = 2 * sizeof(struct sadb_protocol);

	/* We'll need four of them: src, src mask, dst, dst mask. */
	switch (ipo->ipo_addr.sen_type) {
	case SENT_IP4:
		i += 4 * PADUP(sizeof(struct sockaddr_in));
		i += 4 * sizeof(struct sadb_address);
		break;
#ifdef INET6
	case SENT_IP6:
		i += 4 * PADUP(sizeof(struct sockaddr_in6));
		i += 4 * sizeof(struct sadb_address);
		break;
#endif /* INET6 */
	default:
		return (EINVAL);
	}

	/* Local address, might be zeroed. */
	switch (ipo->ipo_src.sa.sa_family) {
	case 0:
		break;
	case AF_INET:
		i += PADUP(sizeof(struct sockaddr_in));
		i += sizeof(struct sadb_address);
		break;
#ifdef INET6
	case AF_INET6:
		i += PADUP(sizeof(struct sockaddr_in6));
		i += sizeof(struct sadb_address);
		break;
#endif /* INET6 */
	default:
		return (EINVAL);
	}

	/* Remote address, might be zeroed. XXX ??? */
	switch (ipo->ipo_dst.sa.sa_family) {
	case 0:
		break;
	case AF_INET:
		i += PADUP(sizeof(struct sockaddr_in));
		i += sizeof(struct sadb_address);
		break;
#ifdef INET6
	case AF_INET6:
		i += PADUP(sizeof(struct sockaddr_in6));
		i += sizeof(struct sadb_address);
		break;
#endif /* INET6 */
	default:
		return (EINVAL);
	}

	if (ipo->ipo_ids) {
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_ids->id_local->len);
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_ids->id_remote->len);
	}

	if (lenp)
		*lenp = i;

	if (buffer == NULL) {
		rval = 0;
		goto ret;
	}

	if (!(p = malloc(i, M_PFKEY, M_NOWAIT | M_ZERO))) {
		rval = ENOMEM;
		goto ret;
	} else
		*buffer = p;

	/* Local address. */
	if (ipo->ipo_src.sa.sa_family) {
		headers[SADB_EXT_ADDRESS_SRC] = p;
		export_address(&p, &ipo->ipo_src.sa);
	}

	/* Remote address. */
	if (ipo->ipo_dst.sa.sa_family) {
		headers[SADB_EXT_ADDRESS_DST] = p;
		export_address(&p, &ipo->ipo_dst.sa);
	}

	/* Get actual flow. */
	export_flow(&p, ipo->ipo_type, &ipo->ipo_addr, &ipo->ipo_mask,
	    headers);

	/* Add ids only when we are root. */
	perm = suser(curproc, 0);
	if (perm == 0 && ipo->ipo_ids)
		export_identities(&p, ipo->ipo_ids, 0, headers);

	rval = 0;
ret:
	return (rval);
}

int
pfkeyv2_ipo_walk(u_int rdomain, int (*walker)(struct ipsec_policy *, void *),
    void *arg)
{
	int rval = 0;
	struct ipsec_policy *ipo;

	splsoftassert(IPL_SOFTNET);

	TAILQ_FOREACH(ipo, &ipsec_policy_head, ipo_list) {
		if (ipo->ipo_rdomain != rdomain)
			continue;
		rval = walker(ipo, (void *)arg);
	}
	return (rval);
}

int
pfkeyv2_sysctl_policydumper(struct ipsec_policy *ipo, void *arg)
{
	struct pfkeyv2_sysctl_walk *w = (struct pfkeyv2_sysctl_walk *)arg;
	void *buffer = 0;
	int i, buflen, error = 0;

	if (w->w_where) {
		void *headers[SADB_EXT_MAX + 1];
		struct sadb_msg msg;

		bzero(headers, sizeof(headers));
		if ((error = pfkeyv2_dump_policy(ipo, headers, &buffer,
		    &buflen)) != 0)
			goto done;
		if (w->w_len < buflen) {
			error = ENOMEM;
			goto done;
		}
		/* prepend header */
		bzero(&msg, sizeof(msg));
		msg.sadb_msg_version = PF_KEY_V2;
		if (ipo->ipo_sproto == IPPROTO_ESP)
			msg.sadb_msg_satype = SADB_SATYPE_ESP;
		else if (ipo->ipo_sproto == IPPROTO_AH)
			msg.sadb_msg_satype = SADB_SATYPE_AH;
		else if (ipo->ipo_sproto == IPPROTO_IPCOMP)
			msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		else if (ipo->ipo_sproto == IPPROTO_IPIP)
			msg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
		msg.sadb_msg_type = SADB_X_SPDDUMP;
		msg.sadb_msg_len = (sizeof(msg) + buflen) / sizeof(uint64_t);
		if ((error = copyout(&msg, w->w_where, sizeof(msg))) != 0)
			goto done;
		w->w_where += sizeof(msg);
		w->w_len -= sizeof(msg);
		/* set extension type */
		for (i = 1; i < SADB_EXT_MAX; i++)
			if (headers[i])
				((struct sadb_ext *)
				    headers[i])->sadb_ext_type = i;
		if ((error = copyout(buffer, w->w_where, buflen)) != 0)
			goto done;
		w->w_where += buflen;
		w->w_len -= buflen;
	} else {
		if ((error = pfkeyv2_dump_policy(ipo, NULL, NULL,
		    &buflen)) != 0)
			goto done;
		w->w_len += buflen;
		w->w_len += sizeof(struct sadb_msg);
	}

done:
	if (buffer)
		free(buffer, M_PFKEY, 0);
	return (error);
}

int
pfkeyv2_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *new, size_t newlen)
{
	struct pfkeyv2_sysctl_walk w;
	int error = EINVAL;
	u_int rdomain;

	splsoftassert(IPL_SOFTNET);

	if (new)
		return (EPERM);
	if (namelen < 1)
		return (EINVAL);
	w.w_op = name[0];
	w.w_satype = name[1];
	w.w_where = oldp;
	w.w_len = oldp ? *oldlenp : 0;

	rdomain = rtable_l2(curproc->p_p->ps_rtableid);

	switch(w.w_op) {
	case NET_KEY_SADB_DUMP:
		if ((error = suser(curproc, 0)) != 0)
			return (error);
		error = tdb_walk(rdomain, pfkeyv2_sysctl_walker, &w);
		if (oldp)
			*oldlenp = w.w_where - oldp;
		else
			*oldlenp = w.w_len;
		break;

	case NET_KEY_SPD_DUMP:
		error = pfkeyv2_ipo_walk(rdomain,
		    pfkeyv2_sysctl_policydumper, &w);
		if (oldp)
			*oldlenp = w.w_where - oldp;
		else
			*oldlenp = w.w_len;
		break;
	}

	return (error);
}

int
pfkeyv2_init(void)
{
	int rval;

	bzero(&pfkeyv2_version, sizeof(struct pfkey_version));
	pfkeyv2_version.protocol = PFKEYV2_PROTOCOL;
	pfkeyv2_version.create = &pfkeyv2_create;
	pfkeyv2_version.release = &pfkeyv2_release;
	pfkeyv2_version.send = &pfkeyv2_send;
	pfkeyv2_version.sysctl = &pfkeyv2_sysctl;

	rval = pfkey_register(&pfkeyv2_version);
	return (rval);
}

int
pfkeyv2_cleanup(void)
{
	pfkey_unregister(&pfkeyv2_version);
	return (0);
}
@


1.153
log
@Depending on the addresses, ipsecctl(8) automatically groups sa
bundles together.  Extend the kernel interface to export the bundle
information to userland.  Then ipsecctl -ss -v can show the internal
relations.  Unfortunately the header SADB_X_EXT_PROTOCOL was reused
by SADB_X_GRPSPIS, so it cannot be used to transfer the second sa
type with sysctl.  Introduce a new SADB_X_EXT_SATYPE2 and use it
consistently.
OK hshoexer@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.152 2017/02/24 18:36:33 bluhm Exp $ */
d524 2
a525 2
	i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa));
	i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
d562 1
a562 1
		    PADUP(SA_LEN(&sa->tdb_onext->tdb_dst.sa));
d1733 2
a1734 2
		PADUP(SA_LEN(&ipo->ipo_src.sa))) +
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa)) +
d1770 1
a1770 1
		p += sizeof(struct sadb_address) + PADUP(SA_LEN(&laddr->sa));
d1773 1
a1773 1
		    SA_LEN(&laddr->sa) + sizeof(uint64_t) - 1) /
d1776 1
a1776 1
		    sizeof(struct sadb_address), SA_LEN(&laddr->sa));
d1780 1
a1780 1
	p += sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa));
d1783 1
a1783 1
	    SA_LEN(&gw->sa) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
d1785 1
a1785 1
	    SA_LEN(&gw->sa));
d1942 2
a1943 2
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa)) +
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
@


1.152
log
@Avoid some casts by using the sa field of union sockaddr_union.
OK millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.151 2017/02/14 09:47:40 mpi Exp $ */
d559 7
d644 9
d1387 1
a1387 1
		sa_proto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL]);
@


1.151
log
@Replace two recursive splsoftnet()/splx() dances with a splsoftassert().

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.150 2017/01/24 10:08:30 krw Exp $ */
d416 1
a416 1
	export_address(&p, (struct sockaddr *) &sunion);
d435 1
a435 1
	export_address(&p, (struct sockaddr *) &sunion);
d454 1
a454 1
	export_address(&p, (struct sockaddr *) &sunion);
d473 1
a473 1
	export_address(&p, (struct sockaddr *) &sunion);
d610 1
a610 1
	export_address(&p, (struct sockaddr *) &sa->tdb_src);
d614 1
a614 1
	export_address(&p, (struct sockaddr *) &sa->tdb_dst);
d886 2
a887 4
		import_address((struct sockaddr *) &sa1->tdb_src,
		    headers[SADB_EXT_ADDRESS_SRC]);
		import_address((struct sockaddr *) &sa1->tdb_dst,
		    headers[SADB_EXT_ADDRESS_DST]);
d975 1
a975 1
			import_address((struct sockaddr *) &newsa->tdb_src,
d977 1
a977 1
			import_address((struct sockaddr *) &newsa->tdb_dst,
d1126 1
a1126 1
			import_address((struct sockaddr *) &newsa->tdb_src,
d1128 1
a1128 1
			import_address((struct sockaddr *) &newsa->tdb_dst,
d1959 1
a1959 1
	export_address(&p, (struct sockaddr *) &sa->tdb_src);
d1962 1
a1962 1
	export_address(&p, (struct sockaddr *) &sa->tdb_dst);
d2125 1
a2125 1
		export_address(&p, (struct sockaddr *)&ipo->ipo_src);
d2131 1
a2131 1
		export_address(&p, (struct sockaddr *)&ipo->ipo_dst);
@


1.150
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.149 2017/01/13 08:52:09 mpi Exp $ */
d2231 1
a2231 1
	int s, error = EINVAL;
d2234 2
a2250 1
		s = splsoftnet();
a2251 1
		splx(s);
a2258 1
		s = splsoftnet();
a2260 1
		splx(s);
@


1.149
log
@Remove recursive splsoftnet() but use splsoftassert() instead.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.148 2016/09/15 02:00:18 dlg Exp $ */
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d17 4
a20 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d24 1
a24 1
 * 
d36 1
a36 1
 * 
d2129 1
a2129 1
	
@


1.148
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.147 2016/08/30 23:30:37 dlg Exp $ */
d786 1
a786 1
	int delflag = 0, s;
d810 2
a944 2
		s = splsoftnet();

d952 1
a952 1
			goto splxret;
d972 1
a972 1
				goto splxret;
d1023 1
a1023 1
				goto splxret;
d1044 1
a1044 1
				goto splxret;
a1061 1
		splx(s);
a1093 2
		s = splsoftnet();

d1100 1
a1100 1
			goto splxret;
d1106 1
a1106 1
			goto splxret;
d1124 1
a1124 1
				goto splxret;
d1177 1
a1177 1
				goto splxret;
a1183 2
		splx(s);

a1191 1
		s = splsoftnet();
d1197 1
a1197 1
			goto splxret;
a1201 2
		splx(s);

a1224 2
		s = splsoftnet();

d1229 1
a1229 1
			goto splxret;
a1235 2
		splx(s);

a1313 2
			s = splsoftnet();

a1319 1
			splx(s);
a1327 2
			s = splsoftnet();

a1330 1
			splx(s);
a1344 1
		s = splsoftnet();
a1345 2
		splx(s);

a1362 2
		s = splsoftnet();

d1367 1
a1367 1
			goto splxret;
d1379 1
a1379 1
			goto splxret;
d1386 1
a1386 1
				goto splxret;
a1400 2

		splx(s);
a1449 1
		s = splsoftnet();
a1470 1
				splx(s);
a1478 1
				splx(s);
a1482 1
			splx(s);
a1497 1
				splx(s);
a1533 1
			splx(s);
a1567 1
				splx(s);
a1598 1
				splx(s);
a1605 2

		splx(s);
a1645 1
	
a1691 4

splxret:
	splx(s);
	goto ret;
a2149 3
/*
 * Caller is responsible for setting at least splsoftnet().
 */
d2156 2
@


1.147
log
@pool_setipl

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.146 2015/12/09 21:41:50 naddy Exp $ */
d1520 2
a1521 3
				    sizeof(struct ipsec_policy), 0, 0, 0,
				    "ipsec policy", NULL);
				pool_setipl(&ipsec_policy_pool, IPL_NONE);
@


1.146
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.145 2015/07/17 18:31:08 blambert Exp $ */
d1522 1
@


1.145
log
@manage spd entries by using the radix api directly instead of
reaching around through the routing table

original diff by myself, much improved by mikeb@@ and mpi@@

ok and testing mikeb@@ mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.144 2015/05/23 12:38:53 markus Exp $ */
a105 1
	{ SADB_EALG_DESCBC, 64, 64, 64 },
a1849 5
			} else if (!strncasecmp(ipsec_def_enc, "des",
			    sizeof("des"))) {
				sadb_comb->sadb_comb_encrypt = SADB_EALG_DESCBC;
				sadb_comb->sadb_comb_encrypt_minbits = 64;
				sadb_comb->sadb_comb_encrypt_maxbits = 64;
@


1.144
log
@introduce ipsec-id bundles and use them for ipsecflowinfo,
fixes rekeying for l2tp/ipsec against multiple windows clients
and saves memory (for many SAs to same peers); feedback and ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.143 2015/04/16 19:24:13 markus Exp $ */
d84 1
a95 1
#define GETSPI_TRIES 10
d133 2
d788 1
a788 1
	struct sockaddr_encap encapdst, encapnetmask, encapgw;
d791 2
a1436 1
		struct rtentry *rt;
d1439 5
a1475 2
		bzero(&encapgw, sizeof(struct sockaddr_encap));

d1477 2
a1478 5
		rt = rtalloc((struct sockaddr *)&encapdst, RT_REPORT|RT_RESOLVE,
		    rdomain);
		if (rt != NULL) {
			ipo = ((struct sockaddr_encap *)rt->rt_gateway)->sen_ipsp;
			rtfree(rt);
d1526 1
a1526 1
			ipo = pool_get(&ipsec_policy_pool, PR_NOWAIT);
a1531 18

			bzero(ipo, sizeof(struct ipsec_policy));
			ipo->ipo_ref_count = 1;
			TAILQ_INIT(&ipo->ipo_acquires);

			/* Finish initialization of SPD entry */
			encapgw.sen_len = SENT_LEN;
			encapgw.sen_family = PF_KEY;
			encapgw.sen_type = SENT_IPSP;
			encapgw.sen_ipsp = ipo;

			/* Initialize policy entry */
			bcopy(&encapdst, &ipo->ipo_addr,
			    sizeof(struct sockaddr_encap));
			bcopy(&encapnetmask, &ipo->ipo_mask,
			    sizeof(struct sockaddr_encap));

			ipo->ipo_rdomain = rdomain;
d1534 1
a1534 1
		switch (((struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE])->sadb_protocol_proto) {
d1608 10
d1619 4
a1622 11
			struct rt_addrinfo info;

			bzero(&info, sizeof(info));
			info.rti_info[RTAX_DST] = (struct sockaddr *)&encapdst;
			info.rti_info[RTAX_GATEWAY] =
			    (struct sockaddr *)&encapgw;
			info.rti_info[RTAX_NETMASK] =
			    (struct sockaddr *)&encapnetmask;
			info.rti_flags = RTF_UP | RTF_GATEWAY | RTF_STATIC;
			if ((rval = rtrequest1(RTM_ADD, &info, RTP_DEFAULT,
			    NULL, rdomain)) != 0) {
a1634 1

@


1.143
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.142 2015/04/16 19:18:10 markus Exp $ */
d526 4
a529 5
	if (sa->tdb_srcid)
		i += sizeof(struct sadb_ident) + PADUP(sa->tdb_srcid->ref_len);

	if (sa->tdb_dstid)
		i += sizeof(struct sadb_ident) + PADUP(sa->tdb_dstid->ref_len);
d615 3
a617 11
	/* Export source identity, if present */
	if (sa->tdb_srcid) {
		headers[SADB_EXT_IDENTITY_SRC] = p;
		export_identity(&p, &sa->tdb_srcid);
	}

	/* Export destination identity, if present */
	if (sa->tdb_dstid) {
		headers[SADB_EXT_IDENTITY_DST] = p;
		export_identity(&p, &sa->tdb_dstid);
	}
d803 1
a803 1
	struct sadb_ident *sid;
d989 4
a992 3
			import_identity(&newsa->tdb_srcid,
			    headers[SADB_EXT_IDENTITY_SRC]);
			import_identity(&newsa->tdb_dstid,
d1146 3
a1148 3
			import_identity(&newsa->tdb_srcid,
			    headers[SADB_EXT_IDENTITY_SRC]);
			import_identity(&newsa->tdb_dstid,
d1602 3
a1604 8
		if (ipo->ipo_srcid) {
			ipsp_reffree(ipo->ipo_srcid);
			ipo->ipo_srcid = NULL;
		}

		if (ipo->ipo_dstid) {
			ipsp_reffree(ipo->ipo_dstid);
			ipo->ipo_dstid = NULL;
d1607 4
a1610 3
		if ((sid = headers[SADB_EXT_IDENTITY_SRC]) != NULL) {
			import_identity(&ipo->ipo_srcid, sid);
			if (ipo->ipo_srcid == NULL) {
a1620 17
		if ((sid = headers[SADB_EXT_IDENTITY_DST]) != NULL) {
			import_identity(&ipo->ipo_dstid, sid);
			if (ipo->ipo_dstid == NULL) {
				if (exists)
					ipsec_delete_policy(ipo);
				else {
					if (ipo->ipo_dstid)
						ipsp_reffree(ipo->ipo_dstid);
					pool_put(&ipsec_policy_pool, ipo);
				}

				splx(s);
				rval = ENOBUFS;
				goto ret;
			}
		}

d1640 2
a1641 4
				if (ipo->ipo_srcid)
					ipsp_reffree(ipo->ipo_srcid);
				if (ipo->ipo_dstid)
					ipsp_reffree(ipo->ipo_dstid);
d1777 4
a1780 5
	if (ipo->ipo_srcid)
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);

	if (ipo->ipo_dstid)
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
d1827 2
a1828 9
	if (ipo->ipo_srcid) {
		headers[SADB_EXT_IDENTITY_SRC] = p;
		export_identity(&p, &ipo->ipo_srcid);
	}

	if (ipo->ipo_dstid) {
		headers[SADB_EXT_IDENTITY_DST] = p;
		export_identity(&p, &ipo->ipo_dstid);
	}
d2164 4
a2167 4
	if (ipo->ipo_srcid)
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
	if (ipo->ipo_dstid)
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
d2201 2
a2202 8
	if (perm == 0 && ipo->ipo_srcid) {
		headers[SADB_EXT_IDENTITY_SRC] = p;
		export_identity(&p, &ipo->ipo_srcid);
	}
	if (perm == 0 && ipo->ipo_dstid) {
		headers[SADB_EXT_IDENTITY_DST] = p;
		export_identity(&p, &ipo->ipo_dstid);
	}
@


1.142
log
@change {import,export}_identity so it can be used for policies; ok mikeb
(fixes sadb_ident_type conversion for policies)
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.141 2015/04/14 12:22:15 mikeb Exp $ */
a1332 4
			/*
			 * Go through the list of policies, delete those that
			 * are not socket-attached.
			 */
d1336 1
a1336 2
				if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET) &&
				    ipo->ipo_rdomain == rdomain)
a2277 4

	/* Do not dump policies attached to a socket. */
	if (ipo->ipo_flags & IPSP_POLICY_SOCKET)
		return (0);
@


1.141
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.140 2015/04/13 08:45:48 mpi Exp $ */
d619 1
a619 1
		export_identity(&p, sa, PFKEYV2_IDENTITY_SRC);
d625 1
a625 1
		export_identity(&p, sa, PFKEYV2_IDENTITY_DST);
d998 4
a1001 4
			import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC],
			    PFKEYV2_IDENTITY_SRC);
			import_identity(newsa, headers[SADB_EXT_IDENTITY_DST],
			    PFKEYV2_IDENTITY_DST);
d1154 4
a1157 4
			import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC],
			    PFKEYV2_IDENTITY_SRC);
			import_identity(newsa, headers[SADB_EXT_IDENTITY_DST],
			    PFKEYV2_IDENTITY_DST);
d1626 1
a1626 5
			int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
			    sizeof(struct sadb_ident);

			ipo->ipo_srcid = malloc(clen + sizeof(struct ipsec_ref),
			    M_CREDENTIALS, M_NOWAIT);
a1635 5
			ipo->ipo_srcid->ref_type = sid->sadb_ident_type;
			ipo->ipo_srcid->ref_len = clen;
			ipo->ipo_srcid->ref_count = 1;
			ipo->ipo_srcid->ref_malloctype = M_CREDENTIALS;
			bcopy(sid + 1, ipo->ipo_srcid + 1, ipo->ipo_srcid->ref_len);
d1639 1
a1639 5
			int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
			    sizeof(struct sadb_ident);

			ipo->ipo_dstid = malloc(clen + sizeof(struct ipsec_ref),
			    M_CREDENTIALS, M_NOWAIT);
a1652 6
			ipo->ipo_dstid->ref_type = sid->sadb_ident_type;
			ipo->ipo_dstid->ref_len = clen;
			ipo->ipo_dstid->ref_count = 1;
			ipo->ipo_dstid->ref_malloctype = M_CREDENTIALS;
			bcopy(sid + 1, ipo->ipo_dstid + 1,
			    ipo->ipo_dstid->ref_len);
a1791 1
	struct sadb_ident *srcid, *dstid;
d1866 1
a1866 7
		p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
		srcid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_SRC];
		srcid->sadb_ident_len = (sizeof(struct sadb_ident) +
		    PADUP(ipo->ipo_srcid->ref_len)) / sizeof(u_int64_t);
		srcid->sadb_ident_type = ipo->ipo_srcid->ref_type;
		bcopy(ipo->ipo_srcid + 1, headers[SADB_EXT_IDENTITY_SRC] +
		    sizeof(struct sadb_ident), ipo->ipo_srcid->ref_len);
d1871 1
a1871 7
		p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
		dstid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_DST];
		dstid->sadb_ident_len = (sizeof(struct sadb_ident) +
		    PADUP(ipo->ipo_dstid->ref_len)) / sizeof(u_int64_t);
		dstid->sadb_ident_type = ipo->ipo_dstid->ref_type;
		bcopy(ipo->ipo_dstid + 1, headers[SADB_EXT_IDENTITY_DST] +
		    sizeof(struct sadb_ident), ipo->ipo_dstid->ref_len);
a2149 1
	struct sadb_ident *ident;
d2247 1
a2247 7
		p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
		ident = (struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC];
		ident->sadb_ident_len = (sizeof(struct sadb_ident) +
		    PADUP(ipo->ipo_srcid->ref_len)) / sizeof(uint64_t);
		ident->sadb_ident_type = ipo->ipo_srcid->ref_type;
		bcopy(ipo->ipo_srcid + 1, headers[SADB_EXT_IDENTITY_SRC] +
		    sizeof(struct sadb_ident), ipo->ipo_srcid->ref_len);
d2251 1
a2251 7
		p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
		ident = (struct sadb_ident *)headers[SADB_EXT_IDENTITY_DST];
		ident->sadb_ident_len = (sizeof(struct sadb_ident) +
		    PADUP(ipo->ipo_dstid->ref_len)) / sizeof(uint64_t);
		ident->sadb_ident_type = ipo->ipo_dstid->ref_type;
		bcopy(ipo->ipo_dstid + 1, headers[SADB_EXT_IDENTITY_DST] +
		    sizeof(struct sadb_ident), ipo->ipo_dstid->ref_len);
@


1.140
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.139 2015/03/26 12:21:37 mikeb Exp $ */
a531 12
	if (sa->tdb_local_cred)
		i += sizeof(struct sadb_x_cred) + PADUP(sa->tdb_local_cred->ref_len);

	if (sa->tdb_remote_cred)
		i += sizeof(struct sadb_x_cred) + PADUP(sa->tdb_remote_cred->ref_len);

	if (sa->tdb_local_auth)
		i += sizeof(struct sadb_x_cred) + PADUP(sa->tdb_local_auth->ref_len);

	if (sa->tdb_remote_auth)
		i += sizeof(struct sadb_x_cred) + PADUP(sa->tdb_remote_auth->ref_len);

a627 22
	/* Export credentials, if present */
	if (sa->tdb_local_cred) {
		headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
		export_credentials(&p, sa, PFKEYV2_CRED_LOCAL);
	}

	if (sa->tdb_remote_cred) {
		headers[SADB_X_EXT_REMOTE_CREDENTIALS] = p;
		export_credentials(&p, sa, PFKEYV2_CRED_REMOTE);
	}

	/* Export authentication information, if present */
	if (sa->tdb_local_auth) {
		headers[SADB_X_EXT_LOCAL_AUTH] = p;
		export_auth(&p, sa, PFKEYV2_AUTH_LOCAL);
	}

	if (sa->tdb_remote_auth) {
		headers[SADB_X_EXT_REMOTE_AUTH] = p;
		export_auth(&p, sa, PFKEYV2_AUTH_REMOTE);
	}

a1001 10
			import_credentials(newsa,
			    headers[SADB_X_EXT_LOCAL_CREDENTIALS],
			    PFKEYV2_CRED_LOCAL);
			import_credentials(newsa,
			    headers[SADB_X_EXT_REMOTE_CREDENTIALS],
			    PFKEYV2_CRED_REMOTE);
			import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
			    PFKEYV2_AUTH_LOCAL);
			import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
			    PFKEYV2_AUTH_REMOTE);
a1158 10
			import_credentials(newsa,
			    headers[SADB_X_EXT_LOCAL_CREDENTIALS],
			    PFKEYV2_CRED_LOCAL);
			import_credentials(newsa,
			    headers[SADB_X_EXT_REMOTE_CREDENTIALS],
			    PFKEYV2_CRED_REMOTE);
			import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
			    PFKEYV2_AUTH_LOCAL);
			import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
			    PFKEYV2_AUTH_REMOTE);
a1811 1
	struct sadb_x_cred *lcred, *lauth;
a1838 6
	if (ipo->ipo_local_cred)
		i += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);

	if (ipo->ipo_local_auth)
		i += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);

a1903 37
	}

	if (ipo->ipo_local_cred) {
		headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
		p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);
		lcred = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_CREDENTIALS];
		lcred->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
		    PADUP(ipo->ipo_local_cred->ref_len)) / sizeof(u_int64_t);
		switch (ipo->ipo_local_cred->ref_type) {
		case IPSP_CRED_KEYNOTE:
			lcred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
			break;
		case IPSP_CRED_X509:
			lcred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
			break;
		}
		bcopy(ipo->ipo_local_cred + 1, headers[SADB_X_EXT_LOCAL_CREDENTIALS] +
		    sizeof(struct sadb_x_cred), ipo->ipo_local_cred->ref_len);
	}

	if (ipo->ipo_local_auth) {
		headers[SADB_X_EXT_LOCAL_AUTH] = p;
		p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);
		lauth = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_AUTH];
		lauth->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
		    PADUP(ipo->ipo_local_auth->ref_len)) / sizeof(u_int64_t);
		switch (ipo->ipo_local_auth->ref_type) {
		case IPSP_AUTH_PASSPHRASE:
			lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_PASSPHRASE;
			break;
		case IPSP_AUTH_RSA:
			lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
			break;
		}

		bcopy(ipo->ipo_local_auth + 1, headers[SADB_X_EXT_LOCAL_AUTH] +
		    sizeof(struct sadb_x_cred), ipo->ipo_local_auth->ref_len);
@


1.139
log
@Remove bits of unfinished IPsec proxy support.  DNS' KX records, anyone?
ok markus, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.138 2014/12/19 17:14:40 tedu Exp $ */
d140 1
a140 1
	if (!(*packet = m_devget(data, len, 0, NULL)))
@


1.138
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.137 2014/11/25 13:10:03 mpi Exp $ */
a525 3
	if (sa->tdb_proxy.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_proxy.sa));

a627 6
	/* Export TDB proxy address, if present */
	if (SA_LEN(&sa->tdb_proxy.sa)) {
		headers[SADB_EXT_ADDRESS_PROXY] = p;
		export_address(&p, (struct sockaddr *) &sa->tdb_proxy);
	}

a1020 2
			import_address((struct sockaddr *) &newsa->tdb_proxy,
			    headers[SADB_EXT_ADDRESS_PROXY]);
d1087 1
a1087 2
			if (headers[SADB_EXT_ADDRESS_PROXY] ||
			    headers[SADB_EXT_KEY_AUTH] ||
a1183 2
			import_address((struct sockaddr *) &newsa->tdb_proxy,
			    headers[SADB_EXT_ADDRESS_PROXY]);
@


1.137
log
@The proliferation of "struct route" in all its flavors didn't make
any good to our network stack.

The most visible effect is the maze of #ifdef's and casts.  But the
real problem is the very fragile way of checking if a (cached) route
entry is still valid or not.  What should we do if the route jumped
to another ifaddr or if its gateway has been changed?

This change start the dance of "struct route" & friends removal by
sending the completly useless "struct route_enc" to the bucket.

Tweak & ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.136 2014/11/01 21:40:38 mpi Exp $ */
a371 1
#ifdef INET
a377 1
#endif /* INET */
a402 1
#ifdef INET
a406 1
#endif /* INET */
a421 1
#ifdef INET
a425 1
#endif /* INET */
a440 1
#ifdef INET
a444 1
#endif /* INET */
a459 1
#ifdef INET
a463 1
#endif /* INET */
a478 1
#ifdef INET
a483 1
#endif /* INET */
a557 1
#ifdef INET
a561 1
#endif /* INET */
a2302 1
#ifdef INET
a2306 1
#endif /* INET */
a2320 1
#ifdef INET
a2324 1
#endif /* INET */
a2338 1
#ifdef INET
a2342 1
#endif /* INET */
@


1.136
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.135 2014/10/14 09:52:26 mpi Exp $ */
d1528 1
a1528 1
		struct route_enc re;
a1563 2
		bzero(&re, sizeof(struct route_enc));
		bcopy(&encapdst, &re.re_dst, sizeof(struct sockaddr_encap));
d1566 5
a1570 9

		/* Set the rdomain that was obtained from the socket */
		re.re_tableid = rdomain;

		re.re_rt = rtalloc((struct sockaddr *)&re.re_dst,
		    RT_REPORT|RT_RESOLVE, re.re_tableid);
		if (re.re_rt != NULL) {
			ipo = ((struct sockaddr_encap *) re.re_rt->rt_gateway)->sen_ipsp;
			rtfree(re.re_rt);
@


1.135
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.134 2014/09/27 12:26:16 mpi Exp $ */
d1572 2
a1573 2
		re.re_rt = rtalloc1((struct sockaddr *)&re.re_dst, RT_REPORT,
		    re.re_tableid);
@


1.134
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.133 2014/07/12 18:44:22 tedu Exp $ */
d1576 1
a1576 1
			RTFREE(re.re_rt);
@


1.133
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.132 2014/01/08 02:39:02 deraadt Exp $ */
d1572 2
a1573 1
		rtalloc((struct route *) &re);
@


1.132
log
@Perform manual malloc/free of a large object in pfkeyv2_send() to
reduce stack space requirements.
ok mikeb mpi
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.131 2013/08/21 05:21:46 dlg Exp $ */
d200 1
a200 1
		free(pfkeyv2_socket, M_PFKEY);
d348 1
a348 1
		free(buffer, M_PFKEY);
d756 1
a756 1
		free(buffer, M_PFKEY);
d925 1
a925 1
		free(freeme, M_PFKEY);
d1875 1
a1875 1
		free(freeme, M_PFKEY);
d1878 1
a1878 1
	free(message, M_PFKEY);
d1881 1
a1881 1
		free(sa1, M_PFKEY);
d2159 1
a2159 1
		free(buffer, M_PFKEY);
d2241 1
a2241 1
		free(buffer, M_PFKEY);
d2305 1
a2305 1
		free(buffer, M_PFKEY);
d2518 1
a2518 1
		free(buffer, M_PFKEY);
@


1.131
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.130 2013/03/09 16:51:30 deraadt Exp $ */
d863 1
a863 1
	struct tdb sa, *sa2 = NULL;
d936 5
a940 1
		bzero(&sa, sizeof(struct tdb));
d942 3
a944 3
		sa.tdb_satype = smsg->sadb_msg_satype;
		if ((rval = pfkeyv2_get_proto_alg(sa.tdb_satype,
		    &sa.tdb_sproto, 0)))
d947 1
a947 1
		import_address((struct sockaddr *) &sa.tdb_src,
d949 1
a949 1
		import_address((struct sockaddr *) &sa.tdb_dst,
d954 1
a954 1
		sa.tdb_spi = reserve_spi(rdomain,
d956 2
a957 2
		    &sa.tdb_src, &sa.tdb_dst, sa.tdb_sproto, &rval);
		if (sa.tdb_spi == 0)
d972 1
a972 1
		export_sa((void **) &bckptr, &sa);
d1879 3
@


1.130
log
@re-arrange the pre-accounting of the objects in the buffer so it
is clearer; ok sthen
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.128 2012/12/28 17:52:06 gsoares Exp $ */
d140 1
a140 1
	if (!(*packet = m_devget(data, len, 0, NULL, NULL)))
@


1.129
log
@Reserve space for source and destination addresses unconditionally rather
than checking if they're zero - export_address() is always called for these.
Fixes memory corruption when doing ipsecctl -ssa with md5sig. Debugging
hints from deraadt@@, ok kettenis@@ deraadt@@
@
text
@d542 1
a542 1
		i += PADUP(sa->tdb_srcid->ref_len) + sizeof(struct sadb_ident);
d545 1
a545 1
		i += PADUP(sa->tdb_dstid->ref_len) + sizeof(struct sadb_ident);
d548 1
a548 1
		i += PADUP(sa->tdb_local_cred->ref_len) + sizeof(struct sadb_x_cred);
d551 1
a551 1
		i += PADUP(sa->tdb_remote_cred->ref_len) + sizeof(struct sadb_x_cred);
d554 1
a554 1
		i += PADUP(sa->tdb_local_auth->ref_len) + sizeof(struct sadb_x_cred);
d557 1
a557 1
		i += PADUP(sa->tdb_remote_auth->ref_len) + sizeof(struct sadb_x_cred);
d560 1
a560 1
		i+= PADUP(sa->tdb_amxkeylen) + sizeof(struct sadb_key);
d563 1
a563 1
		i+= PADUP(sa->tdb_emxkeylen) + sizeof(struct sadb_key);
d589 1
a589 1
		i+= sizeof(struct sadb_x_udpencap);
d593 1
a593 1
		i+= PADUP(PF_TAG_NAME_SIZE) + sizeof(struct sadb_x_tag);
d595 1
a595 1
		i+= sizeof(struct sadb_x_tap);
@


1.128
log
@change the malloc(9) flags from M_DONTWAIT to M_NOWAIT; OK millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.127 2012/09/26 14:53:23 markus Exp $ */
d535 2
a536 5
	if (sa->tdb_src.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa));

	if (sa->tdb_dst.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
@


1.127
log
@add M_ZEROIZE as an mbuf flag, so copied PFKEY messages (with embedded keys)
are cleared as well; from hshoexer@@, feedback and ok bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.126 2012/09/20 10:25:03 blambert Exp $ */
d158 1
a158 1
	    M_PFKEY, M_DONTWAIT | M_ZERO)))
d231 1
a231 1
	    M_DONTWAIT))) {
d394 1
a394 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT | M_ZERO))) {
d609 1
a609 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT | M_ZERO))) {
d896 1
a896 1
		    M_DONTWAIT))) {
d961 1
a961 1
		    M_DONTWAIT | M_ZERO))) {
d1344 1
a1344 1
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT | M_ZERO))) {
d1362 1
a1362 1
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT | M_ZERO))) {
d1383 1
a1383 1
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT | M_ZERO))) {
d1716 1
a1716 1
			    M_CREDENTIALS, M_DONTWAIT);
d1738 1
a1738 1
			    M_CREDENTIALS, M_DONTWAIT);
d1930 1
a1930 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT | M_ZERO))) {
d2193 1
a2193 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT | M_ZERO))) {
d2387 1
a2387 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT | M_ZERO))) {
@


1.126
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.125 2012/03/28 19:43:21 claudio Exp $ */
d142 4
a287 2
		/* Done, let's be a bit paranoid */
		m_zero(packet);
a923 2
		/* Paranoid */
		m_zero(packet);
d926 2
a927 2
		/* Even more paranoid */
		bzero(freeme, sizeof(struct sadb_msg) + len);
d1083 1
d1253 1
d1876 1
@


1.125
log
@pfkey needs some p_p->ps_pid too. OK deraadt@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.124 2011/01/12 18:49:21 mikeb Exp $ */
d1005 1
a1005 1
		s = spltdb();
d1168 1
a1168 1
		s = spltdb();
d1281 1
a1281 1
		s = spltdb();
d1317 1
a1317 1
		s = spltdb();
d1410 1
a1410 1
			s = spltdb();
d1432 1
a1432 1
			s = spltdb();
d1452 1
a1452 1
		s = spltdb();
d1473 1
a1473 1
		s = spltdb();
d1564 1
a1564 1
		s = spltdb();
d2435 1
a2435 1
 * Caller is responsible for setting at least spltdb().
d2538 1
a2538 1
		s = spltdb();
d2548 1
a2548 1
		s = spltdb();
@


1.124
log
@Never include SADB_X_EXT_REMOTE_AUTH (which is either a
passphrase or an RSA key) in the reply message.  There's
nothing that justifies this behavior and PF_KEY RFC prefers
to exclude keys and other sensitive material from replies.

Discussed with reyk, no objections from deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.123 2010/10/06 22:19:20 mikeb Exp $ */
d159 1
a159 1
	pfkeyv2_socket->pid = curproc->p_pid;
d906 1
a906 1
		smsg->sadb_msg_seq = curproc->p_pid;
@


1.123
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.122 2010/09/27 17:28:34 deraadt Exp $ */
d1086 1
d1255 1
@


1.122
log
@a pool_get() assuming that PR_NOWAIT is 0 (not anymore!); run into by naddy
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.121 2010/07/09 16:58:06 reyk Exp $ */
a109 1
	{ SADB_X_EALG_SKIPJACK, 64, 80, 80},
a2071 5
			} else if (!strncasecmp(ipsec_def_enc, "skipjack",
			    sizeof("skipjack"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_SKIPJACK;
				sadb_comb->sadb_comb_encrypt_minbits = 80;
				sadb_comb->sadb_comb_encrypt_maxbits = 80;
@


1.121
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.120 2010/07/01 02:09:45 reyk Exp $ */
d1619 1
a1619 1
			ipo = pool_get(&ipsec_policy_pool, 0);
@


1.120
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.118 2007/11/24 12:59:28 jmc Exp $ */
d162 6
d210 1
a210 1
    u_int8_t satype, int count)
d281 2
a282 1
			    (s->socket != socket))
d296 2
a297 1
			if (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED) {
d327 2
a328 1
			    !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
d336 4
a339 3
		for (s = pfkeyv2_sockets; s; s = s->next)
			pfkey_sendup(s->socket, packet, 1);

d755 2
a756 1
		    PFKEYV2_SENDMESSAGE_UNICAST, dump_state->socket, 0, 0);
d873 2
d888 2
d917 3
a919 2
		for (so = pfkeyv2_sockets; so; so = so->next)
			if (so->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
d921 1
d954 3
a956 3
		sa.tdb_spi = reserve_spi(sprng->sadb_spirange_min,
		    sprng->sadb_spirange_max, &sa.tdb_src, &sa.tdb_dst,
		    sa.tdb_sproto, &rval);
d1009 1
a1009 1
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
d1025 1
a1025 1
			freeme = tdb_alloc();
d1170 1
a1170 1
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
d1186 1
a1186 1
		freeme = tdb_alloc();
d1282 1
a1282 1
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
d1318 1
a1318 1
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
d1418 2
a1419 1
				if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
d1433 1
a1433 1
			tdb_walk(pfkeyv2_flush_walker,
d1452 1
a1452 1
		rval = tdb_walk(pfkeyv2_dump_walker, &dump_state);
d1474 1
a1474 1
		tdb1 = gettdb(ssa->sadb_sa_spi, sunionp,
d1486 1
a1486 1
		tdb2 = gettdb(ssa->sadb_sa_spi, sunionp,
d1565 3
d1641 2
d1770 1
a1770 1
			    NULL, 0)) != 0) {
d1805 1
d1867 1
a1867 1
	rval = pfkeyv2_sendmessage(headers, mode, socket, 0, 0);
d2148 2
a2149 2
	    PFKEYV2_SENDMESSAGE_REGISTERED, NULL, smsg->sadb_msg_satype, 0))
	    != 0)
d2230 1
a2230 1
	    NULL, 0, 0)) != 0)
d2442 2
a2443 1
pfkeyv2_ipo_walk(int (*walker)(struct ipsec_policy *, void *), void *arg)
d2448 3
a2450 1
	TAILQ_FOREACH(ipo, &ipsec_policy_head, ipo_list)
d2452 1
d2525 1
d2536 2
d2543 1
a2543 1
		error = tdb_walk(pfkeyv2_sysctl_walker, &w);
d2553 2
a2554 1
		error = pfkeyv2_ipo_walk(pfkeyv2_sysctl_policydumper, &w);
@


1.119
log
@replace rtrequest() with corresponding rtrequest1() replacement.
OK henning@@
@
text
@d586 2
d706 6
d1064 1
d1114 1
d1232 1
@


1.118
log
@some spelling fixes from Martynas Venckus
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.117 2007/09/13 21:00:14 hshoexer Exp $ */
d1726 11
a1736 6
			if ((rval = rtrequest(RTM_ADD,
				 (struct sockaddr *) &encapdst,
				 (struct sockaddr *) &encapgw,
				 (struct sockaddr *) &encapnetmask,
				 RTF_UP | RTF_GATEWAY | RTF_STATIC,
				 (struct rtentry **) 0, 0)) != 0) {
@


1.117
log
@Convert MALLOC/FREE to malloc/free and use M_ZERO where applicable.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.116 2007/09/01 18:49:28 henning Exp $ */
d1572 1
a1572 1
			/* If we were asked to delete something non-existant, error. */
@


1.116
log
@since the
MGET* macros were changed to function calls, there wasn't any
need for the pool declarations and the inclusion of pool.h
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.115 2007/06/22 12:14:05 markus Exp $ */
d155 1
a155 1
	    M_PFKEY, M_DONTWAIT)))
a157 1
	bzero(pfkeyv2_socket, sizeof(struct pfkeyv2_socket));
d383 1
a383 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
d386 1
a386 1
	} else {
a387 2
		bzero(p, i);
	}
d596 1
a596 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
d599 1
a599 1
	} else {
a600 2
		bzero(p, i);
	}
d937 1
a937 1
		    M_DONTWAIT))) {
a941 1
		bzero(freeme, sizeof(struct sadb_sa));
d1313 1
a1313 1
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
a1317 2
		bzero(freeme, i);

d1331 1
a1331 1
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
a1338 2
		bzero(freeme, i);

d1352 1
a1352 1
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
a1356 2
		bzero(freeme, i);

d1678 2
a1679 2
			MALLOC(ipo->ipo_srcid, struct ipsec_ref *, clen +
			    sizeof(struct ipsec_ref), M_CREDENTIALS, M_DONTWAIT);
d1700 1
a1700 2
			MALLOC(ipo->ipo_dstid, struct ipsec_ref *,
			    clen + sizeof(struct ipsec_ref),
d1886 1
a1886 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
a1893 1
	bzero(p, i);
d2154 1
a2154 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
a2161 1
	bzero(p, i);
d2348 1
a2348 1
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
d2351 1
a2351 1
	} else {
a2352 2
		bzero(p, i);
	}
@


1.115
log
@export the flow/filter information attached to the SA, too; ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.114 2007/02/14 00:53:48 jsg Exp $ */
d80 1
@


1.114
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.113 2007/01/18 20:00:19 henning Exp $ */
d559 23
d690 5
@


1.113
log
@allow kernels with TCP_SIGNATURE (aka tcp md5sig), but without IPSEC to
compile and work. need to register pfkey whenever tcp md5 or ipsec is
defined, and the various ipsec encapsulations only if ipsec is defined.
ok theo
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.112 2006/11/24 13:52:14 reyk Exp $ */
d1377 1
a1377 1
			/* Fall through */
@


1.112
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.111 2006/06/16 16:49:39 henning Exp $ */
d744 1
d785 1
a785 1

d948 1
d956 1
d1108 1
d1116 1
@


1.111
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.110 2006/05/06 17:43:47 mcbride Exp $ */
d71 2
d88 5
d562 5
d674 8
d1028 3
d1077 3
d1192 3
@


1.110
log
@Fix bracketing messed up in KNF commit 1.86, allows sasyncd to reliably
set up pfkey promiscuous mode.

Diff from Nathanael <list-openbsd-tech at polymorpheus dot com>
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.109 2005/12/06 14:25:21 markus Exp $ */
d1681 1
a1681 1
				 (struct rtentry **) 0)) != 0) {
@


1.109
log
@export ipip flows, too; ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.108 2005/06/01 11:22:07 hshoexer Exp $ */
d1736 4
a1740 4
			} else {
				pfkeyv2_socket->flags &=
				    ~PFKEYV2_SOCKETFLAGS_PROMISC;
				npromisc--;
@


1.108
log
@when dumping policies, skip those attached to a socket.

ok ho
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.107 2005/05/28 17:43:25 hshoexer Exp $ */
d2398 2
@


1.107
log
@Only protect IDs by suser()

ok ho
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.106 2005/05/27 17:58:47 ho Exp $ */
d2372 4
@


1.106
log
@Must convert back from IPPROTO_x to SADB_SATYPE_x. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.105 2005/05/27 15:29:55 hshoexer Exp $ */
d2223 1
a2223 1
	int i, rval;
d2324 3
a2326 2
	/* Add ids. */
	if (ipo->ipo_srcid) {
d2336 1
a2336 2

	if (ipo->ipo_dstid) {
a2347 1

a2452 2
		if ((error = suser(curproc, 0)) != 0)
			return (error);
@


1.105
log
@Use export_flow() to wrap policies retrieved via sysctl in pfkey message

ok ho markus
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.104 2005/05/25 05:47:53 markus Exp $ */
d2389 6
a2394 1
		msg.sadb_msg_satype = ipo->ipo_sproto;
@


1.104
log
@AESCTR support for ESP (RFC 3686); ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.103 2005/05/24 03:13:53 ho Exp $ */
d2219 150
a2368 1
pfkeyv2_sysctl_dump(void *arg)
d2371 6
a2376 2
	struct ipsec_policy *ipo;
	int error = 0;
d2378 33
a2410 13
	TAILQ_FOREACH(ipo, &ipsec_policy_head, ipo_list) {
		if (w->w_where) {
			if (w->w_len < sizeof(struct ipsec_policy)) {
				error = ENOMEM;
				goto done;
			}
			if ((error = copyout(ipo, w->w_where,
			    sizeof(struct ipsec_policy))) != 0)
				goto done;
			w->w_where += sizeof(struct ipsec_policy);
			w->w_len -= sizeof(struct ipsec_policy);
		} else
			w->w_len += sizeof(struct ipsec_policy);
d2414 2
a2434 1
	s = spltdb();
d2437 1
a2437 2
		if ((error = suser(curproc, 0)) != 0) {
			splx(s);
d2439 1
a2439 1
		}
d2441 1
d2449 5
a2453 1
		error = pfkeyv2_sysctl_dump(&w);
a2459 1
	splx(s);
@


1.103
log
@Make sure all fields in the SADB_DUMP header are zeroed properly. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.102 2005/05/10 13:42:11 markus Exp $ */
d103 2
a104 1
	{ SADB_X_EALG_AES, 128, 64, 256}
d1962 1
a1962 1
				sadb_comb->sadb_comb_encrypt_minbits = 64;
d1964 5
@


1.102
log
@support NULL encryption for ESP; ok hshoexer, ho
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.101 2005/04/04 22:18:47 hshoexer Exp $ */
d2181 1
a2182 2
		msg.sadb_msg_pid = 0;
		msg.sadb_msg_seq = 0;
@


1.101
log
@Add sysctl for dumping the SPD
ok deraadt, ok markus some time ago
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.100 2005/01/13 10:08:14 hshoexer Exp $ */
d97 1
@


1.100
log
@protect pfkeyv2_dump_walker with spltdb().  Noticed by mpech@@, thanks!

ok ho@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.99 2004/12/11 16:02:21 markus Exp $ */
d2213 26
d2254 1
d2257 2
a2258 1
		if ((error = suser(curproc, 0)) != 0)
d2260 1
a2260 1
		s = spltdb();
a2261 1
		splx(s);
d2266 9
d2276 2
@


1.99
log
@SADB_X_EXT_LIFETIME_LASTUSE is always defined
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.98 2004/12/11 15:59:00 markus Exp $ */
d1369 5
a1373 1
		if (!(rval = tdb_walk(pfkeyv2_dump_walker, &dump_state)))
@


1.98
log
@pass out the correct lifetime type on expire
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.97 2004/12/11 15:55:57 markus Exp $ */
a513 1
#if defined (SADB_X_EXT_LIFETIME_LASTUSE)
a515 1
#endif
a588 1
#if defined (SADB_X_EXT_LIFETIME_LASTUSE)
a592 1
#endif
@


1.97
log
@count SADB_REGISTER only once per socket
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.96 2004/12/10 18:50:51 markus Exp $ */
d2125 2
a2126 3
	type = (SADB_EXT_LIFETIME_SOFT ? PFKEYV2_LIFETIME_SOFT :
	    PFKEYV2_LIFETIME_HARD);
	export_lifetime(&p, sa, type);
@


1.96
log
@fix ipsec crash from pr 4025, Stefan Miltchev; ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.95 2004/11/29 21:42:20 hshoexer Exp $ */
d1251 4
a1254 2
		pfkeyv2_socket->flags |= PFKEYV2_SOCKETFLAGS_REGISTERED;
		nregistered++;
@


1.95
log
@tiny knf, no binary change.

ok otto jsg henning pat markus deraadt fgs
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.94 2004/11/26 18:02:22 markus Exp $ */
d1825 5
d2048 1
a2048 1
    /* Send the ACQUIRE message to all compliant registered listeners. */
@


1.94
log
@implement net.key.v2.sadb_dump.{unspec,esp,ah,...} sysctl subtree
and use sysctl for 'ipsecadm show'; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.93 2004/11/19 10:11:52 hshoexer Exp $ */
d129 2
a130 1
pfdatatopacket(void *data, int len, struct mbuf **packet) {
d140 2
a141 1
pfkeyv2_create(struct socket *socket) {
d1793 1
a1793 2
		union sockaddr_union *laddr, u_int32_t *seq,
		struct sockaddr_encap *ddst)
@


1.93
log
@Plug memory leak.  Found by pat@@.  Thanks!

ok myself markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.92 2004/08/10 16:17:05 ho Exp $ */
d496 1
a496 1
pfkeyv2_get(struct tdb *sa, void **headers, void **buffer)
d553 8
d685 1
a685 1
		if ((rval = pfkeyv2_get(sa, headers, &buffer)) != 0)
d1240 1
a1240 1
		rval = pfkeyv2_get(sa2, headers, &freeme);
d2142 94
d2246 1
@


1.92
log
@Add SADB_X_EXT_LIFETIME_LASTUSE for use with isakmpd/DPD, adding this
extends the bitmap to 64bits. Also repair SADB_GET. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.91 2004/06/21 23:10:31 markus Exp $ */
d953 3
a955 1
			    &newsa->tdb_sproto, &alg)))
d957 1
d1010 1
a1010 1
				tdb_delete(freeme);
d1108 3
a1110 1
			    &newsa->tdb_sproto, &alg)))
d1112 1
d1168 1
a1168 1
				tdb_delete(freeme);
@


1.92.2.1
log
@MFC rev 1.96, fix for ipsec crash from pr 4025
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.92 2004/08/10 16:17:05 ho Exp $ */
a1809 5
	if (ipo->ipo_local_cred)
		i += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);

	if (ipo->ipo_local_auth)
		i += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);
@


1.91
log
@don't accept SADB_X_EXT_UDPENCAP if encapsulation is disabled; ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.90 2003/12/02 23:16:29 markus Exp $ */
d119 2
a120 2
extern uint32_t sadb_exts_allowed_out[SADB_MAX+1];
extern uint32_t sadb_exts_required_out[SADB_MAX+1];
d512 5
d581 7
d996 1
a996 2
			import_udpencap(newsa,
			    headers[SADB_X_EXT_UDPENCAP]);
d1042 1
a1042 2
			import_udpencap(sa2,
			    headers[SADB_X_EXT_UDPENCAP]);
d1151 1
a1151 2
			import_udpencap(newsa,
			    headers[SADB_X_EXT_UDPENCAP]);
d1178 3
a1180 2
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));
d1213 4
a1216 2
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));
d1742 1
a1742 1
		uint32_t seen = 0;
d1746 1
a1746 1
				seen |= (1 << i);
@


1.90
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.89 2003/07/24 09:59:02 itojun Exp $ */
d907 4
a910 3
		/* UDP encapsulation is only supported for ESP */
		if (smsg->sadb_msg_satype != SADB_SATYPE_ESP &&
		    headers[SADB_X_EXT_UDPENCAP]) {
d1058 4
a1061 3
		/* UDP encapsulation is only supported for ESP */
		if (smsg->sadb_msg_satype != SADB_SATYPE_ESP &&
		    headers[SADB_X_EXT_UDPENCAP]) {
@


1.90.2.1
log
@MFC rev 1.96, fix for ipsec crash from pr 4025
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.90 2003/12/02 23:16:29 markus Exp $ */
a1795 5
	if (ipo->ipo_local_cred)
		i += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);

	if (ipo->ipo_local_auth)
		i += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);
@


1.89
log
@conform to RFC2367 on SADB_xx naming (local name must be prefixed with
SADB_X_xx)
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.88 2003/07/24 08:03:19 itojun Exp $ */
d545 3
d636 6
d907 6
d983 2
d1030 2
d1057 6
d1139 2
@


1.89.2.1
log
@MFC rev 1.96, fix for ipsec crash from pr 4025
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.89 2003/07/24 09:59:02 itojun Exp $ */
a1768 2
	if (ipo->ipo_local_cred)
		i += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);
a1769 3
	if (ipo->ipo_local_auth)
		i += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);
 
@


1.88
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.87 2003/02/16 21:30:13 deraadt Exp $ */
d108 4
a111 4
	{ SADB_AALG_RIPEMD160HMAC, 0, 160, 160 },
	{ SADB_AALG_SHA2_256, 0, 256, 256 },
	{ SADB_AALG_SHA2_384, 0, 384, 384 },
	{ SADB_AALG_SHA2_512, 0, 512, 512 }
d1948 1
a1948 1
			sadb_comb->sadb_comb_auth = SADB_AALG_RIPEMD160HMAC;
d1958 1
a1958 1
			sadb_comb->sadb_comb_auth = SADB_AALG_SHA2_256;
d1963 1
a1963 1
			sadb_comb->sadb_comb_auth = SADB_AALG_SHA2_384;
d1968 1
a1968 1
			sadb_comb->sadb_comb_auth = SADB_AALG_SHA2_512;
@


1.87
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.86 2003/02/16 19:54:20 jason Exp $ */
d102 1
a102 1
	{ SADB_X_EALG_AES, 128, 64, 256},
d108 4
a111 1
	{ SADB_AALG_RIPEMD160HMAC, 0, 160, 160 }
d116 1
a116 1
	{ SADB_X_CALG_LZS, 0, 0, 0},
d1956 15
@


1.86
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.85 2003/02/15 22:57:58 jason Exp $ */
d230 89
a318 89
    switch(mode) {
    case PFKEYV2_SENDMESSAGE_UNICAST:
	    /*
	     * Send message to the specified socket, plus all
	     * promiscuous listeners.
	     */
	    pfkey_sendup(socket, packet, 0);

	    /*
	     * Promiscuous messages contain the original message
	     * encapsulated in another sadb_msg header.
	     */
	    bzero(buffer, sizeof(struct sadb_msg));
	    smsg = (struct sadb_msg *) buffer;
	    smsg->sadb_msg_version = PF_KEY_V2;
	    smsg->sadb_msg_type = SADB_X_PROMISC;
	    smsg->sadb_msg_len = (sizeof(struct sadb_msg) + j) /
		sizeof(uint64_t);
	    smsg->sadb_msg_seq = 0;

	    /* Copy to mbuf chain */
	    if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
	        &packet)) != 0)
		    goto ret;

	    /*
	     * Search for promiscuous listeners, skipping the
	     * original destination.
	     */
	    for (s = pfkeyv2_sockets; s; s = s->next)
		    if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
			(s->socket != socket))
			    pfkey_sendup(s->socket, packet, 1);

	    /* Done, let's be a bit paranoid */
	    m_zero(packet);
	    m_freem(packet);
	    break;

    case PFKEYV2_SENDMESSAGE_REGISTERED:
	    /*
	     * Send the message to all registered sockets that match
	     * the specified satype (e.g., all IPSEC-ESP negotiators)
	     */
	    for (s = pfkeyv2_sockets; s; s = s->next)
		    if (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED) {
			    if (!satype)    /* Just send to everyone registered */
				    pfkey_sendup(s->socket, packet, 1);
			    else {
				    /* Check for specified satype */
				    if ((1 << satype) & s->registration)
					    pfkey_sendup(s->socket, packet, 1);
			    }
		    }

	    /* Free last/original copy of the packet */
	    m_freem(packet);

	    /* Encapsulate the original message "inside" an sadb_msg header */
	    bzero(buffer, sizeof(struct sadb_msg));
	    smsg = (struct sadb_msg *) buffer;
	    smsg->sadb_msg_version = PF_KEY_V2;
	    smsg->sadb_msg_type = SADB_X_PROMISC;
	    smsg->sadb_msg_len = (sizeof(struct sadb_msg) + j) /
		sizeof(uint64_t);
	    smsg->sadb_msg_seq = 0;

	    /* Convert to mbuf chain */
	    if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
	        &packet)) != 0)
		    goto ret;

	    /* Send to all registered promiscuous listeners */
	    for (s = pfkeyv2_sockets; s; s = s->next)
		    if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
		        !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
			    pfkey_sendup(s->socket, packet, 1);

	    m_freem(packet);
	    break;

    case PFKEYV2_SENDMESSAGE_BROADCAST:
	    /* Send message to all sockets */
	    for (s = pfkeyv2_sockets; s; s = s->next)
		    pfkey_sendup(s->socket, packet, 1);

	    m_freem(packet);
	    break;
    }
d321 4
a324 4
    if (buffer != NULL) {
	    bzero(buffer, j + sizeof(struct sadb_msg));
	    free(buffer, M_PFKEY);
    }
d326 1
a326 1
    return (rval);
d836 1
a836 1
	switch(smsg->sadb_msg_type) {
d881 11
a891 11
		     headers[SADB_X_EXT_PROTOCOL] ||
		     headers[SADB_X_EXT_FLOW_TYPE] ||
		     headers[SADB_X_EXT_DST_FLOW] ||
		     headers[SADB_X_EXT_SRC_MASK] ||
		     headers[SADB_X_EXT_DST_MASK]) &&
		   !(headers[SADB_X_EXT_SRC_FLOW] &&
		     headers[SADB_X_EXT_PROTOCOL] &&
		     headers[SADB_X_EXT_FLOW_TYPE] &&
		     headers[SADB_X_EXT_DST_FLOW] &&
		     headers[SADB_X_EXT_SRC_MASK] &&
		     headers[SADB_X_EXT_DST_MASK])) {
d1021 5
a1025 5
		     headers[SADB_X_EXT_PROTOCOL] ||
		     headers[SADB_X_EXT_FLOW_TYPE] ||
		     headers[SADB_X_EXT_DST_FLOW] ||
		     headers[SADB_X_EXT_SRC_MASK] ||
		     headers[SADB_X_EXT_DST_MASK]) &&
d1027 5
a1031 5
		     headers[SADB_X_EXT_PROTOCOL] &&
		     headers[SADB_X_EXT_FLOW_TYPE] &&
		     headers[SADB_X_EXT_DST_FLOW] &&
		     headers[SADB_X_EXT_SRC_MASK] &&
		     headers[SADB_X_EXT_DST_MASK])) {
d1268 1
a1268 1
		switch(smsg->sadb_msg_satype) {
@


1.85
log
@skeleton support for LZS compression
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.84 2002/07/31 00:13:36 itojun Exp $ */
d96 7
a102 8
static struct sadb_alg ealgs[] =
{
    { SADB_EALG_DESCBC, 64, 64, 64 },
    { SADB_EALG_3DESCBC, 64, 192, 192 },
    { SADB_X_EALG_BLF, 64, 40, BLF_MAXKEYLEN * 8},
    { SADB_X_EALG_CAST, 64, 40, 128},
    { SADB_X_EALG_SKIPJACK, 64, 80, 80},
    { SADB_X_EALG_AES, 128, 64, 256},
d105 4
a108 5
static struct sadb_alg aalgs[] =
{
    { SADB_AALG_SHA1HMAC, 0, 160, 160 },
    { SADB_AALG_MD5HMAC, 0, 128, 128 },
    { SADB_AALG_RIPEMD160HMAC, 0, 160, 160 }
d111 3
a113 4
static struct sadb_alg calgs[] =
{
    { SADB_X_CALG_DEFLATE, 0, 0, 0},
    { SADB_X_CALG_LZS, 0, 0, 0},
d126 4
a129 6
pfdatatopacket(void *data, int len, struct mbuf **packet)
{
    if (!(*packet = m_devget(data, len, 0, NULL, NULL)))
      return ENOMEM;

    return 0;
d136 2
a137 3
pfkeyv2_create(struct socket *socket)
{
    struct pfkeyv2_socket *pfkeyv2_socket;
d139 8
a146 3
    if (!(pfkeyv2_socket = malloc(sizeof(struct pfkeyv2_socket), M_PFKEY,
				  M_DONTWAIT)))
      return ENOMEM;
d148 1
a148 4
    bzero(pfkeyv2_socket, sizeof(struct pfkeyv2_socket));
    pfkeyv2_socket->next = pfkeyv2_sockets;
    pfkeyv2_socket->socket = socket;
    pfkeyv2_socket->pid = curproc->p_pid;
d150 1
a150 3
    pfkeyv2_sockets = pfkeyv2_socket;

    return 0;
d159 1
a159 1
    struct pfkeyv2_socket **pp;
d161 3
a163 4
    for (pp = &pfkeyv2_sockets;
	 *pp && ((*pp)->socket != socket);
	 pp = &((*pp)->next))
      ;
d165 2
a166 3
    if (*pp)
    {
	struct pfkeyv2_socket *pfkeyv2_socket;
d168 2
a169 2
	pfkeyv2_socket = *pp;
	*pp = (*pp)->next;
d171 2
a172 2
	if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_REGISTERED)
	  nregistered--;
d174 2
a175 2
	if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
	  npromisc--;
d177 2
a178 2
	free(pfkeyv2_socket, M_PFKEY);
    }
d180 1
a180 1
    return 0;
d190 1
a190 1
		    u_int8_t satype, int count)
d192 37
a228 19
    int i, j, rval;
    void *p, *buffer = NULL;
    struct mbuf *packet;
    struct pfkeyv2_socket *s;
    struct sadb_msg *smsg;

    /* Find out how much space we'll need... */
    j = sizeof(struct sadb_msg);

    for (i = 1; i <= SADB_EXT_MAX; i++)
      if (headers[i])
	j += ((struct sadb_ext *)headers[i])->sadb_ext_len * sizeof(uint64_t);

    /* ...and allocate it */
    if (!(buffer = malloc(j + sizeof(struct sadb_msg), M_PFKEY, M_DONTWAIT)))
    {
	rval = ENOMEM;
	goto ret;
    }
d230 2
a231 21
    p = buffer + sizeof(struct sadb_msg);
    bcopy(headers[0], p, sizeof(struct sadb_msg));
    ((struct sadb_msg *) p)->sadb_msg_len = j / sizeof(uint64_t);
    p += sizeof(struct sadb_msg);

    /* Copy payloads in the packet */
    for (i = 1; i <= SADB_EXT_MAX; i++)
      if (headers[i])
      {
	  ((struct sadb_ext *) headers[i])->sadb_ext_type = i;
	  bcopy(headers[i], p, EXTLEN(headers[i]));
	  p += EXTLEN(headers[i]);
      }

    if ((rval = pfdatatopacket(buffer + sizeof(struct sadb_msg),
			       j, &packet)) != 0)
      goto ret;

    switch(mode)
    {
	case PFKEYV2_SENDMESSAGE_UNICAST:
d247 1
a247 1
				 sizeof(uint64_t);
d252 2
a253 2
				       &packet)) != 0)
	      goto ret;
d260 3
a262 3
	      if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
		  (s->socket != socket))
		pfkey_sendup(s->socket, packet, 1);
d269 1
a269 1
	case PFKEYV2_SENDMESSAGE_REGISTERED:
d275 9
a283 11
	      if (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED)
	      {
		  if (!satype)    /* Just send to everyone registered */
		    pfkey_sendup(s->socket, packet, 1);
		  else
		  {
		       /* Check for specified satype */
		      if ((1 << satype) & s->registration)
		          pfkey_sendup(s->socket, packet, 1);
		  }
	      }
d294 1
a294 1
				 sizeof(uint64_t);
d299 2
a300 2
				       &packet)) != 0)
	      goto ret;
d304 3
a306 3
	      if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
		  !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
		pfkey_sendup(s->socket, packet, 1);
d311 1
a311 1
	case PFKEYV2_SENDMESSAGE_BROADCAST:
d314 1
a314 1
	      pfkey_sendup(s->socket, packet, 1);
d320 4
a323 5
 ret:
    if (buffer != NULL)
    {
	bzero(buffer, j + sizeof(struct sadb_msg));
	free(buffer, M_PFKEY);
d326 1
a326 1
    return rval;
d337 8
a344 8
    union sockaddr_union sunion;
    struct sadb_protocol *sp;
    int rval, i, dir;
    void *p;

    /* Find out how big a buffer we need */
    i = 4 * sizeof(struct sadb_address) + sizeof(struct sadb_protocol);
    bzero(&sunion, sizeof(union sockaddr_union));
d346 1
a346 2
    switch (ipa->ipa_info.sen_type)
    {
d349 5
a353 5
	    i += 4 * PADUP(sizeof(struct sockaddr_in));
	    sunion.sa.sa_family = AF_INET;
	    sunion.sa.sa_len = sizeof(struct sockaddr_in);
	    dir = ipa->ipa_info.sen_direction;
	    break;
d358 5
a362 5
	    i += 4 * PADUP(sizeof(struct sockaddr_in6));
	    sunion.sa.sa_family = AF_INET6;
	    sunion.sa.sa_len = sizeof(struct sockaddr_in6);
	    dir = ipa->ipa_info.sen_ip6_direction;
	    break;
d366 2
a367 2
	    return EINVAL;
    }
d369 7
a375 10
    if (!(p = malloc(i, M_PFKEY, M_DONTWAIT)))
    {
	rval = ENOMEM;
	goto ret;
    }
    else
    {
	*buffer = p;
	bzero(p, i);
    }
d377 5
a381 6
    if (dir == IPSP_DIRECTION_OUT)
      headers[SADB_X_EXT_SRC_FLOW] = p;
    else
      headers[SADB_X_EXT_DST_FLOW] = p;
    switch (sunion.sa.sa_family)
    {
d384 3
a386 3
	    sunion.sin.sin_addr = ipa->ipa_info.sen_ip_src;
	    sunion.sin.sin_port = ipa->ipa_info.sen_sport;
	    break;
d391 3
a393 3
	    sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_src;
	    sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_sport;
	    break;
d395 2
a396 2
    }
    export_address(&p, (struct sockaddr *) &sunion);
d398 5
a402 6
    if (dir == IPSP_DIRECTION_OUT)
      headers[SADB_X_EXT_SRC_MASK] = p;
    else
      headers[SADB_X_EXT_DST_MASK] = p;
    switch (sunion.sa.sa_family)
    {
d405 3
a407 3
	    sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_src;
	    sunion.sin.sin_port = ipa->ipa_mask.sen_sport;
	    break;
d412 3
a414 3
	    sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_src;
	    sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_sport;
	    break;
d416 2
a417 2
    }
    export_address(&p, (struct sockaddr *) &sunion);
d419 5
a423 6
    if (dir == IPSP_DIRECTION_OUT)
      headers[SADB_X_EXT_DST_FLOW] = p;
    else
      headers[SADB_X_EXT_SRC_FLOW] = p;
    switch (sunion.sa.sa_family)
    {
d426 3
a428 3
	    sunion.sin.sin_addr = ipa->ipa_info.sen_ip_dst;
	    sunion.sin.sin_port = ipa->ipa_info.sen_dport;
	    break;
d433 3
a435 3
	    sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_dst;
	    sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_dport;
	    break;
d437 2
a438 2
    }
    export_address(&p, (struct sockaddr *) &sunion);
d440 5
a444 6
    if (dir == IPSP_DIRECTION_OUT)
      headers[SADB_X_EXT_DST_MASK] = p;
    else
      headers[SADB_X_EXT_SRC_MASK] = p;
    switch (sunion.sa.sa_family)
    {
d447 3
a449 3
	    sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_dst;
	    sunion.sin.sin_port = ipa->ipa_mask.sen_dport;
	    break;
d454 3
a456 3
	    sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_dst;
	    sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_dport;
	    break;
d458 2
a459 2
    }
    export_address(&p, (struct sockaddr *) &sunion);
d461 5
a465 5
    headers[SADB_X_EXT_FLOW_TYPE] = p;
    sp = p;
    sp->sadb_protocol_len = sizeof(struct sadb_protocol) / sizeof(u_int64_t);
    switch (sunion.sa.sa_family)
    {
d468 4
a471 4
	    if (ipa->ipa_mask.sen_proto)
	      sp->sadb_protocol_proto = ipa->ipa_info.sen_proto;
	    sp->sadb_protocol_direction = ipa->ipa_info.sen_direction;
	    break;
d476 4
a479 4
	    if (ipa->ipa_mask.sen_ip6_proto)
	      sp->sadb_protocol_proto = ipa->ipa_info.sen_ip6_proto;
	    sp->sadb_protocol_direction = ipa->ipa_info.sen_ip6_direction;
	    break;
d481 1
a481 1
    }
d483 1
a483 1
    rval = 0;
d485 2
a486 2
 ret:
    return rval;
d495 2
a496 2
    int rval, i;
    void *p;
d498 2
a499 2
    /* Find how much space we need */
    i = sizeof(struct sadb_sa) + sizeof(struct sadb_lifetime);
d501 3
a503 3
    if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
	sa->tdb_soft_timeout || sa->tdb_soft_first_use)
      i += sizeof(struct sadb_lifetime);
d505 3
a507 3
    if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
	sa->tdb_exp_timeout || sa->tdb_exp_first_use)
      i += sizeof(struct sadb_lifetime);
d509 2
a510 2
    if (sa->tdb_src.sa.sa_family)
      i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa));
d512 2
a513 2
    if (sa->tdb_dst.sa.sa_family)
      i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
d515 2
a516 2
    if (sa->tdb_proxy.sa.sa_family)
      i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_proxy.sa));
d518 2
a519 2
    if (sa->tdb_srcid)
      i += PADUP(sa->tdb_srcid->ref_len) + sizeof(struct sadb_ident);
d521 2
a522 2
    if (sa->tdb_dstid)
      i += PADUP(sa->tdb_dstid->ref_len) + sizeof(struct sadb_ident);
d524 2
a525 2
    if (sa->tdb_local_cred)
      i += PADUP(sa->tdb_local_cred->ref_len) + sizeof(struct sadb_x_cred);
d527 2
a528 2
    if (sa->tdb_remote_cred)
      i += PADUP(sa->tdb_remote_cred->ref_len) + sizeof(struct sadb_x_cred);
d530 2
a531 2
    if (sa->tdb_local_auth)
      i += PADUP(sa->tdb_local_auth->ref_len) + sizeof(struct sadb_x_cred);
d533 2
a534 2
    if (sa->tdb_remote_auth)
      i += PADUP(sa->tdb_remote_auth->ref_len) + sizeof(struct sadb_x_cred);
d536 2
a537 2
    if (sa->tdb_amxkey)
	    i+= PADUP(sa->tdb_amxkeylen) + sizeof(struct sadb_key);
d539 2
a540 2
    if (sa->tdb_emxkey)
	    i+= PADUP(sa->tdb_emxkeylen) + sizeof(struct sadb_key);
d542 7
a548 10
    if (!(p = malloc(i, M_PFKEY, M_DONTWAIT)))
    {
	rval = ENOMEM;
	goto ret;
    }
    else
    {
	*buffer = p;
	bzero(p, i);
    }
d550 1
a550 1
    headers[SADB_EXT_SA] = p;
d552 1
a552 1
    export_sa(&p, sa);  /* Export SA information (mostly flags) */
d554 9
a562 10
    /* Export lifetimes where applicable */
    headers[SADB_EXT_LIFETIME_CURRENT] = p;
    export_lifetime(&p, sa, PFKEYV2_LIFETIME_CURRENT);

    if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
	sa->tdb_soft_first_use || sa->tdb_soft_timeout)
    {
	headers[SADB_EXT_LIFETIME_SOFT] = p;
	export_lifetime(&p, sa, PFKEYV2_LIFETIME_SOFT);
    }
d564 5
a568 6
    if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
	sa->tdb_exp_first_use || sa->tdb_exp_timeout)
    {
	headers[SADB_EXT_LIFETIME_HARD] = p;
	export_lifetime(&p, sa, PFKEYV2_LIFETIME_HARD);
    }
d570 13
a582 14
    /* Export TDB source address */
    headers[SADB_EXT_ADDRESS_SRC] = p;
    export_address(&p, (struct sockaddr *) &sa->tdb_src);

    /* Export TDB destination address */
    headers[SADB_EXT_ADDRESS_DST] = p;
    export_address(&p, (struct sockaddr *) &sa->tdb_dst);

    /* Export TDB proxy address, if present */
    if (SA_LEN(&sa->tdb_proxy.sa))
    {
	headers[SADB_EXT_ADDRESS_PROXY] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_proxy);
    }
d584 5
a588 6
    /* Export source identity, if present */
    if (sa->tdb_srcid)
    {
	headers[SADB_EXT_IDENTITY_SRC] = p;
	export_identity(&p, sa, PFKEYV2_IDENTITY_SRC);
    }
d590 5
a594 6
    /* Export destination identity, if present */
    if (sa->tdb_dstid)
    {
	headers[SADB_EXT_IDENTITY_DST] = p;
	export_identity(&p, sa, PFKEYV2_IDENTITY_DST);
    }
d596 5
a600 6
    /* Export credentials, if present */
    if (sa->tdb_local_cred)
    {
	headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
	export_credentials(&p, sa, PFKEYV2_CRED_LOCAL);
    }
d602 4
a605 5
    if (sa->tdb_remote_cred)
    {
	headers[SADB_X_EXT_REMOTE_CREDENTIALS] = p;
	export_credentials(&p, sa, PFKEYV2_CRED_REMOTE);
    }
d607 5
a611 6
    /* Export authentication information, if present */
    if (sa->tdb_local_auth)
    {
	headers[SADB_X_EXT_LOCAL_AUTH] = p;
	export_auth(&p, sa, PFKEYV2_AUTH_LOCAL);
    }
d613 4
a616 5
    if (sa->tdb_remote_auth)
    {
	headers[SADB_X_EXT_REMOTE_AUTH] = p;
	export_auth(&p, sa, PFKEYV2_AUTH_REMOTE);
    }
d618 5
a622 6
    /* Export authentication key, if present */
    if (sa->tdb_amxkey)
    {
	headers[SADB_EXT_KEY_AUTH] = p;
	export_key(&p, sa, PFKEYV2_AUTHENTICATION_KEY);
    }
d624 5
a628 6
    /* Export encryption key, if present */
    if (sa->tdb_emxkey)
    {
	headers[SADB_EXT_KEY_ENCRYPT] = p;
	export_key(&p, sa, PFKEYV2_ENCRYPTION_KEY);
    }
d630 1
a630 1
    rval = 0;
d633 1
a633 1
    return rval;
d642 20
a661 10
    struct dump_state *dump_state = (struct dump_state *) state;
    void *headers[SADB_EXT_MAX+1], *buffer;
    int rval;

    /* If not satype was specified, dump all TDBs */
    if (!dump_state->sadb_msg->sadb_msg_satype ||
	(sa->tdb_satype == dump_state->sadb_msg->sadb_msg_satype))
    {
	bzero(headers, sizeof(headers));
	headers[0] = (void *) dump_state->sadb_msg;
d663 4
a666 15
	/* Get the information from the TDB to a PFKEYv2 message */
	if ((rval = pfkeyv2_get(sa, headers, &buffer)) != 0)
	  return rval;

	if (last)
	  ((struct sadb_msg *)headers[0])->sadb_msg_seq = 0;

	/* Send the message to the specified socket */
	rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_UNICAST,
				   dump_state->socket, 0, 0);

	free(buffer, M_PFKEY);
	if (rval)
	  return rval;
    }
d668 1
a668 1
    return 0;
d677 4
a680 5
    if (!(*((u_int8_t *) satype_vp)) ||
	sa->tdb_satype == *((u_int8_t *) satype_vp))
      tdb_delete(sa);

    return 0;
d691 1
a691 2
    switch (satype)
    {
d693 2
a694 2
	    if (!ah_enable)
	      return EOPNOTSUPP;
d696 1
a696 1
	    *sproto = IPPROTO_AH;
d698 2
a699 2
	    if(alg != NULL)
	      *alg = satype = XF_AH;
d701 1
a701 1
	    break;
d704 2
a705 2
	    if (!esp_enable)
	      return EOPNOTSUPP;
d707 1
a707 1
	    *sproto = IPPROTO_ESP;
d709 2
a710 2
	    if(alg != NULL)
	      *alg = satype = XF_ESP;
d712 1
a712 1
	    break;
d715 1
a715 1
	    *sproto = IPPROTO_IPIP;
d717 2
a718 2
	    if (alg != NULL)
	      *alg = XF_IP4;
d720 1
a720 1
	    break;
d723 2
a724 2
	    if (!ipcomp_enable)
		return EOPNOTSUPP;
d726 1
a726 1
	    *sproto = IPPROTO_IPCOMP;
d728 2
a729 2
	    if(alg != NULL)
		*alg = satype = XF_IPCOMP;
d731 1
a731 1
	    break;
d735 1
a735 1
	    *sproto = IPPROTO_TCP;
d737 2
a738 2
	    if (alg != NULL)
	      *alg = XF_TCPSIGNATURE;
d740 1
a740 1
	    break;
d744 2
a745 2
	    return EOPNOTSUPP;
    }
d747 1
a747 1
    return 0;
d756 5
a760 4
    int i, j, rval = 0, mode = PFKEYV2_SENDMESSAGE_BROADCAST, delflag = 0, s;
    struct sockaddr_encap encapdst, encapnetmask, encapgw;
    struct ipsec_policy *ipo, *tmpipo;
    struct ipsec_acquire *ipa;
d762 1
a762 1
    struct pfkeyv2_socket *pfkeyv2_socket, *so = NULL;
d764 2
a765 2
    void *freeme = NULL, *bckptr = NULL;
    void *headers[SADB_EXT_MAX + 1];
d767 1
a767 1
    union sockaddr_union *sunionp;
d769 1
a769 1
    struct tdb sa, *sa2 = NULL;
d771 5
a775 5
    struct sadb_msg *smsg;
    struct sadb_spirange *sprng;
    struct sadb_sa *ssa;
    struct sadb_supported *ssup;
    struct sadb_ident *sid;
d777 2
a778 2
    /* Verify that we received this over a legitimate pfkeyv2 socket */
    bzero(headers, sizeof(headers));
d780 4
a783 5
    for (pfkeyv2_socket = pfkeyv2_sockets;
	 pfkeyv2_socket;
	 pfkeyv2_socket = pfkeyv2_socket->next)
      if (pfkeyv2_socket->socket == socket)
	break;
d785 4
a788 5
    if (!pfkeyv2_socket)
    {
	rval = EINVAL;
	goto ret;
    }
d790 3
a792 4
    /* If we have any promiscuous listeners, send them a copy of the message */
    if (npromisc)
    {
	struct mbuf *packet;
d794 5
a798 6
	if (!(freeme = malloc(sizeof(struct sadb_msg) + len, M_PFKEY,
			      M_DONTWAIT)))
	{
	    rval = ENOMEM;
	    goto ret;
	}
d800 15
a814 30
	/* Initialize encapsulating header */
	bzero(freeme, sizeof(struct sadb_msg));
	smsg = (struct sadb_msg *) freeme;
	smsg->sadb_msg_version = PF_KEY_V2;
	smsg->sadb_msg_type = SADB_X_PROMISC;
	smsg->sadb_msg_len = (sizeof(struct sadb_msg) + len) /
			     sizeof(uint64_t);
	smsg->sadb_msg_seq = curproc->p_pid;

	bcopy(message, freeme + sizeof(struct sadb_msg), len);

	/* Convert to mbuf chain */
	if ((rval = pfdatatopacket(freeme, sizeof(struct sadb_msg) + len,
				   &packet)) != 0)
	  goto ret;

	/* Send to all promiscuous listeners */
	for (so = pfkeyv2_sockets; so; so = so->next)
	  if (so->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
	    pfkey_sendup(so->socket, packet, 1);

	/* Paranoid */
	m_zero(packet);
	m_freem(packet);

	/* Even more paranoid */
	bzero(freeme, sizeof(struct sadb_msg) + len);
	free(freeme, M_PFKEY);
	freeme = NULL;
    }
d816 4
a819 9
    /* Validate message format */
    if ((rval = pfkeyv2_parsemessage(message, len, headers)) != 0)
      goto ret;

    smsg = (struct sadb_msg *) headers[0];
    switch(smsg->sadb_msg_type)
    {
	case SADB_GETSPI:  /* Reserve an SPI */
	    bzero(&sa, sizeof(struct tdb));
d821 3
a823 26
	    sa.tdb_satype = smsg->sadb_msg_satype;
	    if ((rval = pfkeyv2_get_proto_alg(sa.tdb_satype,
					      &sa.tdb_sproto, 0)))
	      goto ret;

	    import_address((struct sockaddr *) &sa.tdb_src,
			   headers[SADB_EXT_ADDRESS_SRC]);
	    import_address((struct sockaddr *) &sa.tdb_dst,
			   headers[SADB_EXT_ADDRESS_DST]);

	    /* Find an unused SA identifier */
	    sprng = (struct sadb_spirange *) headers[SADB_EXT_SPIRANGE];
	    sa.tdb_spi = reserve_spi(sprng->sadb_spirange_min,
				     sprng->sadb_spirange_max,
				     &sa.tdb_src, &sa.tdb_dst,
				     sa.tdb_sproto, &rval);
	    if (sa.tdb_spi == 0)
	      goto ret;

	    /* Send a message back telling what the SA (the SPI really) is */
	    if (!(freeme = malloc(sizeof(struct sadb_sa), M_PFKEY,
				  M_DONTWAIT)))
	    {
		rval = ENOMEM;
		goto ret;
	    }
d825 5
a829 4
	    bzero(freeme, sizeof(struct sadb_sa));
	    headers[SADB_EXT_SPIRANGE] = NULL;
	    headers[SADB_EXT_SA] = freeme;
	    bckptr = freeme;
d831 3
a833 3
	    /* We really only care about the SPI, but we'll export the SA */
	    export_sa((void **) &bckptr, &sa);
	    break;
d835 4
a838 22
	case SADB_UPDATE:
	    ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));

	    /* Either all or none of the flow must be included */
	    if ((headers[SADB_X_EXT_SRC_FLOW] ||
		headers[SADB_X_EXT_PROTOCOL] ||
		headers[SADB_X_EXT_FLOW_TYPE] ||
		headers[SADB_X_EXT_DST_FLOW] ||
		headers[SADB_X_EXT_SRC_MASK] ||
		headers[SADB_X_EXT_DST_MASK]) &&
		!(headers[SADB_X_EXT_SRC_FLOW] &&
		headers[SADB_X_EXT_PROTOCOL] &&
		headers[SADB_X_EXT_FLOW_TYPE] &&
		headers[SADB_X_EXT_DST_FLOW] &&
		headers[SADB_X_EXT_SRC_MASK] &&
		headers[SADB_X_EXT_DST_MASK]))
	    {
		rval = EINVAL;
		goto ret;
	    }
d840 24
a863 1
	    s = spltdb();
d865 4
a868 3
	    /* Find TDB */
	    sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
			 SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d870 3
a872 6
	    /* If there's no such SA, we're done */
	    if (sa2 == NULL)
	    {
		rval = ESRCH;
		goto splxret;
	    }
d874 21
a894 6
	    /* If this is a reserved SA */
	    if (sa2->tdb_flags & TDBF_INVALID)
	    {
		struct tdb *newsa;
		struct ipsecinit ii;
		int alg;
d896 1
a896 3
		/* Create new TDB */
		freeme = tdb_alloc();
		bzero(&ii, sizeof(struct ipsecinit));
d898 9
a906 2
		newsa = (struct tdb *) freeme;
		newsa->tdb_satype = smsg->sadb_msg_satype;
d908 47
a954 33
		if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
						  &newsa->tdb_sproto, &alg)))
		  goto splxret;

		/* Initialize SA */
		import_sa(newsa, headers[SADB_EXT_SA], &ii);
		import_address((struct sockaddr *) &newsa->tdb_src,
			       headers[SADB_EXT_ADDRESS_SRC]);
		import_address((struct sockaddr *) &newsa->tdb_dst,
			       headers[SADB_EXT_ADDRESS_DST]);
		import_address((struct sockaddr *) &newsa->tdb_proxy,
			       headers[SADB_EXT_ADDRESS_PROXY]);
		import_lifetime(newsa, headers[SADB_EXT_LIFETIME_CURRENT],
				PFKEYV2_LIFETIME_CURRENT);
		import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT],
				PFKEYV2_LIFETIME_SOFT);
		import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD],
				PFKEYV2_LIFETIME_HARD);
		import_key(&ii, headers[SADB_EXT_KEY_AUTH],
			   PFKEYV2_AUTHENTICATION_KEY);
		import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT],
			   PFKEYV2_ENCRYPTION_KEY);
		import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC],
				PFKEYV2_IDENTITY_SRC);
		import_identity(newsa, headers[SADB_EXT_IDENTITY_DST],
				PFKEYV2_IDENTITY_DST);
		import_credentials(newsa,
				   headers[SADB_X_EXT_LOCAL_CREDENTIALS],
				   PFKEYV2_CRED_LOCAL);
		import_credentials(newsa,
				   headers[SADB_X_EXT_REMOTE_CREDENTIALS],
				   PFKEYV2_CRED_REMOTE);
		import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
d956 1
a956 1
		import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
d958 52
a1009 19
		import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
		    headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		    headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		    headers[SADB_X_EXT_PROTOCOL],
		    headers[SADB_X_EXT_FLOW_TYPE]);

		headers[SADB_EXT_KEY_AUTH] = NULL;
		headers[SADB_EXT_KEY_ENCRYPT] = NULL;
		headers[SADB_X_EXT_LOCAL_AUTH] = NULL;

		newsa->tdb_seq = smsg->sadb_msg_seq;

		rval = tdb_init(newsa, alg, &ii);
		if (rval)
		{
		    rval = EINVAL;
		    tdb_delete(freeme);
		    freeme = NULL;
		    goto splxret;
d1012 22
a1033 23
		newsa->tdb_cur_allocations = sa2->tdb_cur_allocations;

		/* Delete old version of the SA, insert new one */
		tdb_delete(sa2);
		puttdb((struct tdb *) freeme);
		sa2 = freeme = NULL;
	    }
	    else
	    {
		/*
		 * The SA is already initialized, so we're only allowed to
		 * change lifetimes and some other information; we're
		 * not allowed to change keys, addresses or identities.
		 */
		if (headers[SADB_EXT_ADDRESS_PROXY] ||
		    headers[SADB_EXT_KEY_AUTH] ||
		    headers[SADB_EXT_KEY_ENCRYPT] ||
		    headers[SADB_EXT_IDENTITY_SRC] ||
		    headers[SADB_EXT_IDENTITY_DST] ||
		    headers[SADB_EXT_SENSITIVITY])
		{
		    rval = EINVAL;
		    goto splxret;
d1036 1
a1036 8
		import_sa(sa2, headers[SADB_EXT_SA], NULL);
		import_lifetime(sa2, headers[SADB_EXT_LIFETIME_CURRENT],
				PFKEYV2_LIFETIME_CURRENT);
		import_lifetime(sa2, headers[SADB_EXT_LIFETIME_SOFT],
				PFKEYV2_LIFETIME_SOFT);
		import_lifetime(sa2, headers[SADB_EXT_LIFETIME_HARD],
				PFKEYV2_LIFETIME_HARD);
	    }
d1038 2
a1039 24
	    splx(s);
	    break;
	case SADB_ADD:
	    ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));

	    /* Either all or none of the flow must be included */
	    if ((headers[SADB_X_EXT_SRC_FLOW] ||
		headers[SADB_X_EXT_PROTOCOL] ||
		headers[SADB_X_EXT_FLOW_TYPE] ||
		headers[SADB_X_EXT_DST_FLOW] ||
		headers[SADB_X_EXT_SRC_MASK] ||
		headers[SADB_X_EXT_DST_MASK]) &&
		!(headers[SADB_X_EXT_SRC_FLOW] &&
		headers[SADB_X_EXT_PROTOCOL] &&
		headers[SADB_X_EXT_FLOW_TYPE] &&
		headers[SADB_X_EXT_DST_FLOW] &&
		headers[SADB_X_EXT_SRC_MASK] &&
		headers[SADB_X_EXT_DST_MASK]))
	    {
		rval = EINVAL;
		goto ret;
	    }
d1041 5
a1045 1
	    s = spltdb();
d1047 5
a1051 2
	    sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
			 SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d1053 2
a1054 13
	    /* We can't add an existing SA! */
	    if (sa2 != NULL)
	    {
		rval = EEXIST;
		goto splxret;
	    }

	    /* We can only add "mature" SAs */
	    if (ssa->sadb_sa_state != SADB_SASTATE_MATURE)
	    {
		rval = EINVAL;
		goto splxret;
	    }
d1056 45
a1100 47
	    /* Allocate and initialize new TDB */
	    freeme = tdb_alloc();

	    {
		struct tdb *newsa = (struct tdb *) freeme;
		struct ipsecinit ii;
		int alg;

		bzero(&ii, sizeof(struct ipsecinit));

		newsa->tdb_satype = smsg->sadb_msg_satype;
		if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
						  &newsa->tdb_sproto, &alg)))
		  goto splxret;

		import_sa(newsa, headers[SADB_EXT_SA], &ii);
		import_address((struct sockaddr *) &newsa->tdb_src,
			       headers[SADB_EXT_ADDRESS_SRC]);
		import_address((struct sockaddr *) &newsa->tdb_dst,
			       headers[SADB_EXT_ADDRESS_DST]);
		import_address((struct sockaddr *) &newsa->tdb_proxy,
			       headers[SADB_EXT_ADDRESS_PROXY]);

		import_lifetime(newsa, headers[SADB_EXT_LIFETIME_CURRENT],
				PFKEYV2_LIFETIME_CURRENT);
		import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT],
				PFKEYV2_LIFETIME_SOFT);
		import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD],
				PFKEYV2_LIFETIME_HARD);

		import_key(&ii, headers[SADB_EXT_KEY_AUTH],
			   PFKEYV2_AUTHENTICATION_KEY);
		import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT],
			   PFKEYV2_ENCRYPTION_KEY);

		import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC],
				PFKEYV2_IDENTITY_SRC);
		import_identity(newsa, headers[SADB_EXT_IDENTITY_DST],
				PFKEYV2_IDENTITY_DST);

		import_credentials(newsa,
				   headers[SADB_X_EXT_LOCAL_CREDENTIALS],
				   PFKEYV2_CRED_LOCAL);
		import_credentials(newsa,
				   headers[SADB_X_EXT_REMOTE_CREDENTIALS],
				   PFKEYV2_CRED_REMOTE);
		import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
d1102 1
a1102 1
		import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
d1104 21
a1124 19
		import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
		    headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		    headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		    headers[SADB_X_EXT_PROTOCOL],
		    headers[SADB_X_EXT_FLOW_TYPE]);

		headers[SADB_EXT_KEY_AUTH] = NULL;
		headers[SADB_EXT_KEY_ENCRYPT] = NULL;
		headers[SADB_X_EXT_LOCAL_AUTH] = NULL;

		newsa->tdb_seq = smsg->sadb_msg_seq;

		rval = tdb_init(newsa, alg, &ii);
		if (rval)
		{
		    rval = EINVAL;
		    tdb_delete(freeme);
		    freeme = NULL;
		    goto splxret;
a1125 1
	    }
d1127 2
a1128 2
	     /* Add TDB in table */
	     puttdb((struct tdb *) freeme);
d1130 1
a1130 1
	     splx(s);
d1132 2
a1133 2
	     freeme = NULL;
	     break;
d1136 11
a1146 12
	    ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));
	    s = spltdb();

	    sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
			 SADB_X_GETSPROTO(smsg->sadb_msg_satype));
	    if (sa2 == NULL)
	    {
		rval = ESRCH;
		goto splxret;
	    }
d1148 1
a1148 1
	    tdb_delete(sa2);
d1150 1
a1150 1
	    splx(s);
d1152 2
a1153 2
	    sa2 = NULL;
	    break;
d1156 6
a1161 7
	    /* Get the relevant policy */
	    ipa = ipsec_get_acquire(((struct sadb_x_policy *) headers[SADB_X_EXT_POLICY])->sadb_x_policy_seq);
	    if (ipa == NULL)
	    {
		rval = ESRCH;
		goto ret;
	    }
d1163 3
a1165 3
	    rval = pfkeyv2_policy(ipa, headers, &freeme);
	    if (rval)
	      mode = PFKEYV2_SENDMESSAGE_UNICAST;
d1167 1
a1167 1
	    break;
d1170 11
a1180 12
	    ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));
	    s = spltdb();

	    sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
			 SADB_X_GETSPROTO(smsg->sadb_msg_satype));
	    if (sa2 == NULL)
	    {
		rval = ESRCH;
		goto splxret;
	    }
d1182 3
a1184 3
	    rval = pfkeyv2_get(sa2, headers, &freeme);
	    if (rval)
	      mode = PFKEYV2_SENDMESSAGE_UNICAST;
d1186 1
a1186 1
	    splx(s);
d1188 1
a1188 1
	    break;
d1191 2
a1192 2
	    pfkeyv2_socket->flags |= PFKEYV2_SOCKETFLAGS_REGISTERED;
	    nregistered++;
d1194 1
a1194 1
	    i = sizeof(struct sadb_supported) + sizeof(ealgs);
d1196 4
a1199 5
	    if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT)))
	    {
		rval = ENOMEM;
		goto ret;
	    }
d1201 1
a1201 1
	    bzero(freeme, i);
d1203 2
a1204 2
	    ssup = (struct sadb_supported *) freeme;
	    ssup->sadb_supported_len = i / sizeof(uint64_t);
d1206 2
a1207 2
	    {
		void *p = freeme + sizeof(struct sadb_supported);
d1209 2
a1210 2
		bcopy(&ealgs[0], p, sizeof(ealgs));
	    }
d1212 1
a1212 1
	    headers[SADB_EXT_SUPPORTED_ENCRYPT] = freeme;
d1214 1
a1214 1
	    i = sizeof(struct sadb_supported) + sizeof(aalgs);
d1216 4
a1219 5
	    if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT)))
	    {
		rval = ENOMEM;
		goto ret;
	    }
d1221 2
a1222 2
	    /* Keep track what this socket has registered for */
	    pfkeyv2_socket->registration |= (1 << ((struct sadb_msg *)message)->sadb_msg_satype);
d1224 1
a1224 1
	    bzero(freeme, i);
d1226 2
a1227 2
	    ssup = (struct sadb_supported *) freeme;
	    ssup->sadb_supported_len = i / sizeof(uint64_t);
d1229 2
a1230 2
	    {
		void *p = freeme + sizeof(struct sadb_supported);
d1232 2
a1233 2
		bcopy(&aalgs[0], p, sizeof(aalgs));
	    }
d1235 1
a1235 1
	    headers[SADB_EXT_SUPPORTED_AUTH] = freeme;
d1237 1
a1237 1
	    i = sizeof(struct sadb_supported) + sizeof(calgs);
d1239 4
a1242 5
	    if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT)))
	    {
		rval = ENOMEM;
		goto ret;
	    }
d1244 1
a1244 1
	    bzero(freeme, i);
d1246 2
a1247 2
	    ssup = (struct sadb_supported *) freeme;
	    ssup->sadb_supported_len = i / sizeof(uint64_t);
d1249 2
a1250 2
	    {
		void *p = freeme + sizeof(struct sadb_supported);
d1252 2
a1253 2
		bcopy(&calgs[0], p, sizeof(calgs));
	    }
d1255 1
a1255 1
	    headers[SADB_X_EXT_SUPPORTED_COMP] = freeme;
d1257 1
a1257 1
	    break;
d1261 3
a1263 3
	    /* Nothing to handle */
	    rval = 0;
	    break;
d1266 1
a1266 1
	    rval = 0;
d1268 1
a1268 2
	    switch(smsg->sadb_msg_satype)
	    {
d1270 1
a1270 1
		    s = spltdb();
d1272 12
a1283 14
		    /*
		     * Go through the list of policies, delete those that
		     * are not socket-attached.
		     */
		    for (ipo = TAILQ_FIRST(&ipsec_policy_head);
			 ipo != NULL;
			 ipo = tmpipo)
		    {
			tmpipo = TAILQ_NEXT(ipo, ipo_list);
			if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
			  ipsec_delete_policy(ipo);
		    }
		    splx(s);
		    /* Fall through */
d1291 1
a1291 1
		    s = spltdb();
d1293 2
a1294 2
		    tdb_walk(pfkeyv2_flush_walker,
			     (u_int8_t *) &(smsg->sadb_msg_satype));
d1296 2
a1297 2
		    splx(s);
		    break;
d1300 2
a1301 2
		    rval = EINVAL; /* Unknown/unsupported type */
	    }
d1303 1
a1303 1
	    break;
d1307 3
a1309 3
	    struct dump_state dump_state;
	    dump_state.sadb_msg = (struct sadb_msg *) headers[0];
	    dump_state.socket = socket;
d1311 2
a1312 2
	    if (!(rval = tdb_walk(pfkeyv2_dump_walker, &dump_state)))
	      goto realret;
d1314 2
a1315 2
	    if ((rval == ENOMEM) || (rval == ENOBUFS))
	      rval = 0;
d1317 1
a1317 2

	 break;
d1321 2
a1322 2
	    struct tdb *tdb1, *tdb2, *tdb3;
	    struct sadb_protocol *sa_proto;
d1324 12
a1335 13
	    ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));

	    s = spltdb();

	    tdb1 = gettdb(ssa->sadb_sa_spi, sunionp,
			  SADB_X_GETSPROTO(smsg->sadb_msg_satype));
	    if (tdb1 == NULL)
	    {
		rval = ESRCH;
		goto splxret;
	    }
d1337 11
a1347 12
	    ssa = (struct sadb_sa *) headers[SADB_X_EXT_SA2];
	    sunionp = (union sockaddr_union *) (headers[SADB_X_EXT_DST2] +
						sizeof(struct sadb_address));
	    sa_proto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL]);

	    tdb2 = gettdb(ssa->sadb_sa_spi, sunionp,
			  SADB_X_GETSPROTO(sa_proto->sadb_protocol_proto));
	    if (tdb2 == NULL)
	    {
		rval = ESRCH;
		goto splxret;
	    }
d1349 19
a1367 20
	    /* Detect cycles */
	    for (tdb3 = tdb2; tdb3; tdb3 = tdb3->tdb_onext)
	      if (tdb3 == tdb1)
	      {
		  rval = ESRCH;
		  goto splxret;
	      }

	    /* Maintenance */
	    if ((tdb1->tdb_onext) &&
		(tdb1->tdb_onext->tdb_inext == tdb1))
	      tdb1->tdb_onext->tdb_inext = NULL;

	    if ((tdb2->tdb_inext) &&
		(tdb2->tdb_inext->tdb_onext == tdb2))
	      tdb2->tdb_inext->tdb_onext = NULL;

	    /* Link them */
	    tdb1->tdb_onext = tdb2;
	    tdb2->tdb_inext = tdb1;
d1369 1
a1369 1
	    splx(s);
d1371 1
a1371 1
	 break;
d1374 2
a1375 2
	    delflag = 1;   /* fall through */

d1378 12
a1389 13
	    struct sadb_protocol *sab;
	    union sockaddr_union *ssrc;
	    struct route_enc re;
	    int exists = 0;

	    sab = (struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE];

            if ((sab->sadb_protocol_direction != IPSP_DIRECTION_IN) &&
                (sab->sadb_protocol_direction != IPSP_DIRECTION_OUT))
            {
		rval = EINVAL;
		goto ret;
            }
d1391 8
a1398 42
            /* If the security protocol wasn't specified, pretend it was ESP */
            if (smsg->sadb_msg_satype == 0)
              smsg->sadb_msg_satype = SADB_SATYPE_ESP;

	    if (headers[SADB_EXT_ADDRESS_DST])
	      sunionp = (union sockaddr_union *)
			(headers[SADB_EXT_ADDRESS_DST] +
			 sizeof(struct sadb_address));
	    else
	      sunionp = NULL;

	    if (headers[SADB_EXT_ADDRESS_SRC])
	      ssrc = (union sockaddr_union *)
		     (headers[SADB_EXT_ADDRESS_SRC] +
		      sizeof(struct sadb_address));
	    else
	      ssrc = NULL;

	    import_flow(&encapdst, &encapnetmask,
		headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		headers[SADB_X_EXT_PROTOCOL], headers[SADB_X_EXT_FLOW_TYPE]);

	    /* Determine whether the exact same SPD entry already exists. */
	    bzero(&encapgw, sizeof(struct sockaddr_encap));
            bzero(&re, sizeof(struct route_enc));
	    bcopy(&encapdst, &re.re_dst, sizeof(struct sockaddr_encap));

	    s = spltdb();

	    rtalloc((struct route *) &re);
	    if (re.re_rt != NULL)
	    {
		ipo = ((struct sockaddr_encap *) re.re_rt->rt_gateway)->sen_ipsp;
		RTFREE(re.re_rt);

		/* Verify that the entry is identical */
		if (bcmp(&ipo->ipo_addr, &encapdst,
			 sizeof(struct sockaddr_encap)) ||
		    bcmp(&ipo->ipo_mask, &encapnetmask,
			 sizeof(struct sockaddr_encap)))
		  ipo = NULL; /* Fall through */
d1400 1
a1400 4
		  exists = 1;
	    }
            else
              ipo = NULL;
d1402 6
a1407 12
	    /*
	     * If the existing policy is static, only delete or update
	     * it if the new one is also static.
	     */
	    if (exists && (ipo->ipo_flags & IPSP_POLICY_STATIC))
	    {
		if (!(sab->sadb_protocol_flags & SADB_X_POLICYFLAGS_POLICY))
		{
		    splx(s);
		    goto ret;
		}
	    }
d1409 4
a1412 9
	    /* Delete ? */
	    if (delflag)
	    {
		if (exists)
		{
		    rval = ipsec_delete_policy(ipo);
		    splx(s);
		    goto ret;
		}
d1414 22
a1435 5
		/* If we were asked to delete something non-existant, error. */
		splx(s);
		rval = ESRCH;
		break;
	    }
d1437 10
a1446 7
	    if (!exists)
	    {
		if (ipsec_policy_pool_initialized == 0)
		{
		    ipsec_policy_pool_initialized = 1;
		    pool_init(&ipsec_policy_pool, sizeof(struct ipsec_policy),
			      0, 0, 0, "ipsec policy", NULL);
d1449 12
a1460 7
		/* Allocate policy entry */
		ipo = pool_get(&ipsec_policy_pool, 0);
		if (ipo == NULL)
		{
		    splx(s);
		    rval = ENOMEM;
		    goto ret;
d1463 32
a1494 16
		bzero(ipo, sizeof(struct ipsec_policy));
		ipo->ipo_ref_count = 1;
		TAILQ_INIT(&ipo->ipo_acquires);

		/* Finish initialization of SPD entry */
		encapgw.sen_len = SENT_LEN;
		encapgw.sen_family = PF_KEY;
		encapgw.sen_type = SENT_IPSP;
		encapgw.sen_ipsp = ipo;

		/* Initialize policy entry */
		bcopy(&encapdst, &ipo->ipo_addr,
		      sizeof(struct sockaddr_encap));
		bcopy(&encapnetmask, &ipo->ipo_mask,
		      sizeof(struct sockaddr_encap));
	    }
d1496 1
a1496 2
	    switch (((struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE])->sadb_protocol_proto)
	    {
d1498 2
a1499 2
		    ipo->ipo_type = IPSP_IPSEC_USE;
		    break;
d1502 2
a1503 2
		    ipo->ipo_type = IPSP_IPSEC_ACQUIRE;
		    break;
d1506 2
a1507 2
		    ipo->ipo_type = IPSP_IPSEC_REQUIRE;
		    break;
d1510 2
a1511 2
		    ipo->ipo_type = IPSP_DENY;
		    break;
d1514 2
a1515 2
		    ipo->ipo_type = IPSP_PERMIT;
		    break;
d1518 2
a1519 2
		    ipo->ipo_type = IPSP_IPSEC_DONTACQ;
		    break;
d1522 12
a1533 4
                    if (!exists)
		      pool_put(&ipsec_policy_pool, ipo);
                    else
		      ipsec_delete_policy(ipo);
d1535 11
a1545 4
		    splx(s);
		    rval = EINVAL;
		    goto ret;
	    }
d1547 1
a1547 2
	    if (sab->sadb_protocol_flags & SADB_X_POLICYFLAGS_POLICY)
	      ipo->ipo_flags |= IPSP_POLICY_STATIC;
d1549 3
a1551 40
            if (sunionp)
	      bcopy(sunionp, &ipo->ipo_dst, sizeof(union sockaddr_union));
            else
	      bzero(&ipo->ipo_dst, sizeof(union sockaddr_union));

	    if (ssrc)
	      bcopy(ssrc, &ipo->ipo_src, sizeof(union sockaddr_union));
	    else
	      bzero(&ipo->ipo_src, sizeof(union sockaddr_union));

	    ipo->ipo_sproto = SADB_X_GETSPROTO(smsg->sadb_msg_satype);

	    if (ipo->ipo_srcid)
	    {
	        ipsp_reffree(ipo->ipo_srcid);
		ipo->ipo_srcid = NULL;
	    }

	    if (ipo->ipo_dstid)
	    {
		ipsp_reffree(ipo->ipo_dstid);
		ipo->ipo_dstid = NULL;
	    }

	    if ((sid = headers[SADB_EXT_IDENTITY_SRC]) != NULL)
	    {
	        int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
		  sizeof(struct sadb_ident);

		MALLOC(ipo->ipo_srcid, struct ipsec_ref *, clen +
		       sizeof(struct ipsec_ref), M_CREDENTIALS, M_DONTWAIT);
		if (ipo->ipo_srcid == NULL)
		{
		    if (exists)
		      ipsec_delete_policy(ipo);
		    else
		      pool_put(&ipsec_policy_pool, ipo);
		    splx(s);
		    rval = ENOBUFS;
		    goto ret;
a1552 24
		ipo->ipo_srcid->ref_type = sid->sadb_ident_type;
		ipo->ipo_srcid->ref_len = clen;
		ipo->ipo_srcid->ref_count = 1;
		ipo->ipo_srcid->ref_malloctype = M_CREDENTIALS;
		bcopy(sid + 1, ipo->ipo_srcid + 1, ipo->ipo_srcid->ref_len);
	    }

	    if ((sid = headers[SADB_EXT_IDENTITY_DST]) != NULL)
	    {
	        int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
		  sizeof(struct sadb_ident);

		MALLOC(ipo->ipo_dstid, struct ipsec_ref *, clen +
		       sizeof(struct ipsec_ref), M_CREDENTIALS, M_DONTWAIT);
		if (ipo->ipo_dstid == NULL)
		{
		    if (exists)
		      ipsec_delete_policy(ipo);
		    else
		    {
			if (ipo->ipo_dstid)
			  ipsp_reffree(ipo->ipo_dstid);
			pool_put(&ipsec_policy_pool, ipo);
		    }
d1554 3
a1556 3
		    splx(s);
		    rval = ENOBUFS;
		    goto ret;
a1557 27
		ipo->ipo_dstid->ref_type = sid->sadb_ident_type;
		ipo->ipo_dstid->ref_len = clen;
		ipo->ipo_dstid->ref_count = 1;
		ipo->ipo_dstid->ref_malloctype = M_CREDENTIALS;
		bcopy(sid + 1, ipo->ipo_dstid + 1, ipo->ipo_dstid->ref_len);
	    }

	    /* Flow type */
	    if (!exists)
	    {
		/* Add SPD entry */
		if ((rval = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				      (struct sockaddr *) &encapgw,
				      (struct sockaddr *) &encapnetmask,
				      RTF_UP | RTF_GATEWAY | RTF_STATIC,
				      (struct rtentry **) 0)) != 0)
		{
		    /* Remove from linked list of policies on TDB */
		    if (ipo->ipo_tdb)
		      TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
				   ipo_tdb_next);

		    if (ipo->ipo_srcid)
		      ipsp_reffree(ipo->ipo_srcid);
		    if (ipo->ipo_dstid)
		      ipsp_reffree(ipo->ipo_dstid);
		    pool_put(&ipsec_policy_pool, ipo);
d1559 20
a1578 2
		    splx(s);
		    goto ret;
d1581 27
a1607 11
		TAILQ_INSERT_HEAD(&ipsec_policy_head, ipo, ipo_list);
		ipsec_in_use++;
	    }
	    else
	    {
		ipo->ipo_last_searched = ipo->ipo_flags = 0;
	    }

	    splx(s);
	 }
	 break;
d1609 29
a1637 4
	case SADB_X_PROMISC:
	    if (len >= 2 * sizeof(struct sadb_msg))
	    {
		struct mbuf *packet;
d1639 3
a1641 2
		if ((rval = pfdatatopacket(message, len, &packet)) != 0)
		  goto ret;
d1643 3
a1645 15
		for (so = pfkeyv2_sockets; so; so = so->next)
		  if ((so != pfkeyv2_socket) &&
		      (!smsg->sadb_msg_seq ||
		       (smsg->sadb_msg_seq == pfkeyv2_socket->pid)))
		    pfkey_sendup(so->socket, packet, 1);

		m_freem(packet);
	    }
	    else
	    {
		if (len != sizeof(struct sadb_msg))
		{
		    rval = EINVAL;
		    goto ret;
		}
d1647 2
a1648 3
		i = (pfkeyv2_socket->flags &
		     PFKEYV2_SOCKETFLAGS_PROMISC) ? 1 : 0;
		j = smsg->sadb_msg_satype ? 1 : 0;
d1650 28
a1677 12
		if (i ^ j)
		{
		    if (j)
		    {
			pfkeyv2_socket->flags |= PFKEYV2_SOCKETFLAGS_PROMISC;
			npromisc++;
		    }
		    else
		    {
			pfkeyv2_socket->flags &= ~PFKEYV2_SOCKETFLAGS_PROMISC;
			npromisc--;
		    }
d1679 1
a1679 1
	    }
d1681 1
a1681 1
	    break;
d1684 3
a1686 3
	    rval = EINVAL;
	    goto ret;
    }
d1689 23
a1711 13
    if (rval)
    {
	if ((rval == EINVAL) || (rval == ENOMEM) || (rval == ENOBUFS))
	  goto realret;

	for (i = 1; i <= SADB_EXT_MAX; i++)
	  headers[i] = NULL;

	smsg->sadb_msg_errno = abs(rval);
    }
    else
    {
	uint32_t seen = 0;
d1713 1
a1713 13
	for (i = 1; i <= SADB_EXT_MAX; i++)
	  if (headers[i])
	    seen |= (1 << i);

	if ((seen & sadb_exts_allowed_out[smsg->sadb_msg_type]) != seen)
	  goto realret;

	if ((seen & sadb_exts_required_out[smsg->sadb_msg_type]) !=
	    sadb_exts_required_out[smsg->sadb_msg_type])
	  goto realret;
    }

    rval = pfkeyv2_sendmessage(headers, mode, socket, 0, 0);
d1716 2
a1717 2
    if (freeme)
      free(freeme, M_PFKEY);
d1719 1
a1719 1
    free(message, M_PFKEY);
d1721 1
a1721 1
    return rval;
d1724 2
a1725 2
    splx(s);
    goto ret;
d1736 36
a1771 17
    void *p, *headers[SADB_EXT_MAX + 1], *buffer = NULL;
    struct sadb_ident *srcid, *dstid;
    struct sadb_x_cred *lcred, *lauth;
    struct sadb_comb *sadb_comb;
    struct sadb_address *sadd;
    struct sadb_prop *sa_prop;
    struct sadb_msg *smsg;
    int rval = 0;
    int i, j;

    *seq = pfkeyv2_seq++;

    if (!nregistered)
    {
	rval = ESRCH;
	goto ret;
    }
d1773 1
a1773 20
    /* How large a buffer do we need... XXX we only do one proposal for now */
    i = sizeof(struct sadb_msg) +
        (laddr == NULL ? 0 : sizeof(struct sadb_address) +
                             PADUP(SA_LEN(&ipo->ipo_src.sa))) +
        sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa)) +
        sizeof(struct sadb_prop) + 1 * sizeof(struct sadb_comb);

    if (ipo->ipo_srcid)
      i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);

    if (ipo->ipo_dstid)
      i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);


    /* Allocate */
    if (!(p = malloc(i, M_PFKEY, M_DONTWAIT)))
    {
	rval = ENOMEM;
	goto ret;
    }
d1775 2
a1776 1
    bzero(headers, sizeof(headers));
d1778 2
a1779 2
    buffer = p;
    bzero(p, i);
d1781 5
a1785 2
    headers[0] = p;
    p += sizeof(struct sadb_msg);
d1787 6
a1792 25
    smsg = (struct sadb_msg *) headers[0];
    smsg->sadb_msg_version = PF_KEY_V2;
    smsg->sadb_msg_type = SADB_ACQUIRE;
    smsg->sadb_msg_len = i / sizeof(uint64_t);
    smsg->sadb_msg_seq = *seq;

    if (ipo->ipo_sproto == IPPROTO_ESP)
      smsg->sadb_msg_satype = SADB_SATYPE_ESP;
    else if (ipo->ipo_sproto == IPPROTO_AH)
      smsg->sadb_msg_satype = SADB_SATYPE_AH;
    else if (ipo->ipo_sproto == IPPROTO_IPCOMP)
      smsg->sadb_msg_satype = SADB_X_SATYPE_IPCOMP;

    if (laddr)
    {
        headers[SADB_EXT_ADDRESS_SRC] = p;
        p += sizeof(struct sadb_address) + PADUP(SA_LEN(&laddr->sa));
        sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_SRC];
        sadd->sadb_address_len = (sizeof(struct sadb_address) +
			         SA_LEN(&laddr->sa) +
			         sizeof(uint64_t) - 1) / sizeof(uint64_t);
        bcopy(laddr,
	      headers[SADB_EXT_ADDRESS_SRC] + sizeof(struct sadb_address),
	      SA_LEN(&laddr->sa));
    }
d1794 10
a1803 21
    headers[SADB_EXT_ADDRESS_DST] = p;
    p += sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa));
    sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_DST];
    sadd->sadb_address_len = (sizeof(struct sadb_address) +
			      SA_LEN(&gw->sa) +
			      sizeof(uint64_t) - 1) / sizeof(uint64_t);
    bcopy(gw, headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address),
	  SA_LEN(&gw->sa));

    if (ipo->ipo_srcid)
    {
	headers[SADB_EXT_IDENTITY_SRC] = p;
	p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
	srcid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_SRC];
	srcid->sadb_ident_len = (sizeof(struct sadb_ident) +
				 PADUP(ipo->ipo_srcid->ref_len)) /
				sizeof(u_int64_t);
	srcid->sadb_ident_type = ipo->ipo_srcid->ref_type;
	bcopy(ipo->ipo_srcid + 1, headers[SADB_EXT_IDENTITY_SRC] +
	      sizeof(struct sadb_ident), ipo->ipo_srcid->ref_len);
    }
d1805 18
a1822 12
    if (ipo->ipo_dstid)
    {
	headers[SADB_EXT_IDENTITY_DST] = p;
	p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
	dstid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_DST];
	dstid->sadb_ident_len = (sizeof(struct sadb_ident) +
				 PADUP(ipo->ipo_dstid->ref_len)) /
				sizeof(u_int64_t);
	dstid->sadb_ident_type = ipo->ipo_dstid->ref_type;
	bcopy(ipo->ipo_dstid + 1, headers[SADB_EXT_IDENTITY_DST] +
	      sizeof(struct sadb_ident), ipo->ipo_dstid->ref_len);
    }
d1824 9
a1832 16
    if (ipo->ipo_local_cred)
    {
	headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
	p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);
	lcred = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_CREDENTIALS];
	lcred->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
				 PADUP(ipo->ipo_local_cred->ref_len)) /
				sizeof(u_int64_t);
	switch (ipo->ipo_local_cred->ref_type)
	{
	case IPSP_CRED_KEYNOTE:
	    lcred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
	    break;
	case IPSP_CRED_X509:
	    lcred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
	    break;
a1833 3
	bcopy(ipo->ipo_local_cred + 1, headers[SADB_X_EXT_LOCAL_CREDENTIALS] +
	      sizeof(struct sadb_x_cred), ipo->ipo_local_cred->ref_len);
    }
d1835 16
a1850 16
    if (ipo->ipo_local_auth)
    {
	headers[SADB_X_EXT_LOCAL_AUTH] = p;
	p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);
	lauth = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_AUTH];
	lauth->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
				 PADUP(ipo->ipo_local_auth->ref_len)) /
				sizeof(u_int64_t);
	switch (ipo->ipo_local_auth->ref_type)
	{
	case IPSP_AUTH_PASSPHRASE:
	    lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_PASSPHRASE;
	    break;
	case IPSP_AUTH_RSA:
	    lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
	    break;
d1853 14
a1866 3
	bcopy(ipo->ipo_local_auth + 1, headers[SADB_X_EXT_LOCAL_AUTH] +
	      sizeof(struct sadb_x_cred), ipo->ipo_local_auth->ref_len);
    }
d1868 3
a1870 14
    headers[SADB_EXT_PROPOSAL] = p;
    p += sizeof(struct sadb_prop);
    sa_prop = (struct sadb_prop *) headers[SADB_EXT_PROPOSAL];
    sa_prop->sadb_prop_num = 1; /* XXX One proposal only */
    sa_prop->sadb_prop_len = (sizeof(struct sadb_prop) +
			      (sizeof(struct sadb_comb) *
			       sa_prop->sadb_prop_num)) / sizeof(uint64_t);

    sadb_comb = p;

    /* XXX Should actually ask the crypto layer what's supported */
    for (j = 0; j < sa_prop->sadb_prop_num; j++)
    {
	sadb_comb->sadb_comb_flags = 0;
d1872 64
a1935 2
	if (ipsec_require_pfs)
	  sadb_comb->sadb_comb_flags |= SADB_SAFLAGS_PFS;
d1937 16
a1952 22
	/* Set the encryption algorithm */
	if (ipo->ipo_sproto == IPPROTO_ESP)
	{
	    if (!strncasecmp(ipsec_def_enc, "aes", sizeof("aes")))
	    {
		sadb_comb->sadb_comb_encrypt = SADB_X_EALG_AES;
		sadb_comb->sadb_comb_encrypt_minbits = 64;
		sadb_comb->sadb_comb_encrypt_maxbits = 256;
	    }
	    else
	      if (!strncasecmp(ipsec_def_enc, "3des", sizeof("3des")))
	      {
		  sadb_comb->sadb_comb_encrypt = SADB_EALG_3DESCBC;
		  sadb_comb->sadb_comb_encrypt_minbits = 192;
		  sadb_comb->sadb_comb_encrypt_maxbits = 192;
	      }
	      else
		if (!strncasecmp(ipsec_def_enc, "des", sizeof("des")))
		{
		    sadb_comb->sadb_comb_encrypt = SADB_EALG_DESCBC;
		    sadb_comb->sadb_comb_encrypt_minbits = 64;
		    sadb_comb->sadb_comb_encrypt_maxbits = 64;
a1953 25
		else
		  if (!strncasecmp(ipsec_def_enc, "blowfish",
				   sizeof("blowfish")))
		  {
		      sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
		      sadb_comb->sadb_comb_encrypt_minbits = 40;
		      sadb_comb->sadb_comb_encrypt_maxbits = BLF_MAXKEYLEN * 8;
		  }
		  else
		    if (!strncasecmp(ipsec_def_enc, "skipjack",
				     sizeof("skipjack")))
		    {
			sadb_comb->sadb_comb_encrypt = SADB_X_EALG_SKIPJACK;
			sadb_comb->sadb_comb_encrypt_minbits = 80;
			sadb_comb->sadb_comb_encrypt_maxbits = 80;
		    }
		    else
		      if (!strncasecmp(ipsec_def_enc, "cast128",
				       sizeof("cast128")))
		      {
			  sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
			  sadb_comb->sadb_comb_encrypt_minbits = 40;
			  sadb_comb->sadb_comb_encrypt_maxbits = 128;
		      }
	}
d1955 8
a1962 13
	else if (ipo->ipo_sproto == IPPROTO_IPCOMP)
	{
	    /* Set the compression algorithm */
            if (!strncasecmp(ipsec_def_comp, "deflate", sizeof("deflate"))) {
                sadb_comb->sadb_comb_encrypt = SADB_X_CALG_DEFLATE;
                sadb_comb->sadb_comb_encrypt_minbits = 0;
                sadb_comb->sadb_comb_encrypt_maxbits = 0;
            } else if (!strncasecmp(ipsec_def_comp, "lzs", sizeof("lzs"))) {
                sadb_comb->sadb_comb_encrypt = SADB_X_CALG_LZS;
                sadb_comb->sadb_comb_encrypt_minbits = 0;
                sadb_comb->sadb_comb_encrypt_maxbits = 0;
            }
        }
d1964 3
a1966 6
	/* Set the authentication algorithm */
	if (!strncasecmp(ipsec_def_auth, "hmac-sha1", sizeof("hmac-sha1")))
	{
	    sadb_comb->sadb_comb_auth = SADB_AALG_SHA1HMAC;
	    sadb_comb->sadb_comb_auth_minbits = 160;
	    sadb_comb->sadb_comb_auth_maxbits = 160;
a1967 29
	else
	  if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
			   sizeof("hmac_ripemd160")))
	  {
	      sadb_comb->sadb_comb_auth = SADB_AALG_RIPEMD160HMAC;
	      sadb_comb->sadb_comb_auth_minbits = 160;
	      sadb_comb->sadb_comb_auth_maxbits = 160;
	  }
	  else
	    if (!strncasecmp(ipsec_def_auth, "hmac-md5", sizeof("hmac-md5")))
	    {
		sadb_comb->sadb_comb_auth = SADB_AALG_MD5HMAC;
		sadb_comb->sadb_comb_auth_minbits = 128;
		sadb_comb->sadb_comb_auth_maxbits = 128;
	    }

	sadb_comb->sadb_comb_soft_allocations = ipsec_soft_allocations;
	sadb_comb->sadb_comb_hard_allocations = ipsec_exp_allocations;

	sadb_comb->sadb_comb_soft_bytes = ipsec_soft_bytes;
	sadb_comb->sadb_comb_hard_bytes = ipsec_exp_bytes;

	sadb_comb->sadb_comb_soft_addtime = ipsec_soft_timeout;
	sadb_comb->sadb_comb_hard_addtime = ipsec_exp_timeout;

	sadb_comb->sadb_comb_soft_usetime = ipsec_soft_first_use;
	sadb_comb->sadb_comb_hard_usetime = ipsec_exp_first_use;
	sadb_comb++;
    }
d1970 4
a1973 3
    if ((rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_REGISTERED,
				    NULL, smsg->sadb_msg_satype, 0)) != 0)
      goto ret;
d1975 1
a1975 1
    rval = 0;
d1977 4
a1980 5
     if (buffer != NULL)
     {
	 bzero(buffer, i);
	 free(buffer, M_PFKEY);
     }
d1982 1
a1982 1
     return rval;
d1992 4
a1995 4
    void *p, *headers[SADB_EXT_MAX+1], *buffer = NULL;
    struct sadb_msg *smsg;
    int rval = 0;
    int i;
d1997 1
a1997 2
    switch (sa->tdb_sproto)
    {
d2005 1
a2005 1
	    break;
d2008 3
a2010 3
	    rval = EOPNOTSUPP;
	    goto ret;
    }
d2012 4
a2015 10
    i = sizeof(struct sadb_msg) + sizeof(struct sadb_sa) +
	2 * sizeof(struct sadb_lifetime) +
	sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa)) +
	sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));

    if (!(p = malloc(i, M_PFKEY, M_DONTWAIT)))
    {
	rval = ENOMEM;
	goto ret;
    }
d2017 4
a2020 1
    bzero(headers, sizeof(headers));
d2022 1
a2022 2
    buffer = p;
    bzero(p, i);
d2024 2
a2025 2
    headers[0] = p;
    p += sizeof(struct sadb_msg);
d2027 2
a2028 6
    smsg = (struct sadb_msg *) headers[0];
    smsg->sadb_msg_version = PF_KEY_V2;
    smsg->sadb_msg_type = SADB_EXPIRE;
    smsg->sadb_msg_satype = sa->tdb_satype;
    smsg->sadb_msg_len = i / sizeof(uint64_t);
    smsg->sadb_msg_seq = pfkeyv2_seq++;
d2030 17
a2046 2
    headers[SADB_EXT_SA] = p;
    export_sa(&p, sa);
d2048 2
a2049 2
    headers[SADB_EXT_LIFETIME_CURRENT] = p;
    export_lifetime(&p, sa, 2);
d2051 2
a2052 4
    headers[type] = p;
    type = (SADB_EXT_LIFETIME_SOFT ? PFKEYV2_LIFETIME_SOFT :
	                             PFKEYV2_LIFETIME_HARD);
    export_lifetime(&p, sa, type);
d2054 3
a2056 2
    headers[SADB_EXT_ADDRESS_SRC] = p;
    export_address(&p, (struct sockaddr *) &sa->tdb_src);
d2058 1
a2058 2
    headers[SADB_EXT_ADDRESS_DST] = p;
    export_address(&p, (struct sockaddr *) &sa->tdb_dst);
d2060 5
a2064 12
    if ((rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_BROADCAST,
				    NULL, 0, 0)) != 0)
      goto ret;

    rval = 0;

ret:
    if (buffer != NULL)
    {
	bzero(buffer, i);
	free(buffer, M_PFKEY);
    }
d2066 1
a2066 1
    return rval;
d2072 1
a2072 1
    int rval;
d2074 5
a2078 5
    bzero(&pfkeyv2_version, sizeof(struct pfkey_version));
    pfkeyv2_version.protocol = PFKEYV2_PROTOCOL;
    pfkeyv2_version.create = &pfkeyv2_create;
    pfkeyv2_version.release = &pfkeyv2_release;
    pfkeyv2_version.send = &pfkeyv2_send;
d2080 2
a2081 2
    rval = pfkey_register(&pfkeyv2_version);
    return rval;
d2087 2
a2088 2
    pfkey_unregister(&pfkeyv2_version);
    return 0;
@


1.84
log
@fix potential NULL pointer deref.  From: tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.83 2002/06/07 04:47:06 ho Exp $ */
d116 1
d2039 1
a2039 2
            if (!strncasecmp(ipsec_def_comp, "deflate", sizeof("deflate")))
            {
d2041 4
@


1.83
log
@Add flow type arg to import_flow()
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.82 2002/05/31 01:42:17 angelos Exp $ */
a1633 5
		ipo->ipo_srcid->ref_type = sid->sadb_ident_type;
		ipo->ipo_srcid->ref_len = clen;
		ipo->ipo_srcid->ref_count = 1;
		ipo->ipo_srcid->ref_malloctype = M_CREDENTIALS;

d1644 4
a1647 1

a1657 5
		ipo->ipo_dstid->ref_type = sid->sadb_ident_type;
		ipo->ipo_dstid->ref_len = clen;
		ipo->ipo_dstid->ref_count = 1;
		ipo->ipo_dstid->ref_malloctype = M_CREDENTIALS;

d1673 4
a1676 1

@


1.82
log
@Pass authentication information (if available) in ACQUIRE message.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.81 2002/03/03 21:47:00 angelos Exp $ */
d924 1
d930 1
d1005 2
a1006 1
		    headers[SADB_X_EXT_PROTOCOL]);
d1067 1
d1073 1
d1154 2
a1155 1
		    headers[SADB_X_EXT_PROTOCOL]);
d1472 1
a1472 1
		headers[SADB_X_EXT_PROTOCOL]);
@


1.81
log
@Fix crashes associated with SADB_GET/SADB_DUMP --- memory was not
allocated on outgoing message for encryption/authentication keys ---
from umaraghunath@@hotmail.com
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.80 2002/02/21 20:14:12 angelos Exp $ */
d794 1
a794 1
    struct ipsec_policy *ipo;
d920 17
d1000 5
a1055 1

d1061 16
d1146 5
d1318 13
a1330 2
		    while ((ipo = TAILQ_FIRST(&ipsec_policy_head)) != NULL)
		      ipsec_delete_policy(ipo);
a1430 1
	    union sockaddr_union *src, *dst, *srcmask, *dstmask, *ssrc;
d1432 1
a1433 1
	    u_int8_t transproto = 0;
d1463 4
a1466 8
	    src = (union sockaddr_union *) (headers[SADB_X_EXT_SRC_FLOW] +
					    sizeof(struct sadb_address));
	    dst = (union sockaddr_union *) (headers[SADB_X_EXT_DST_FLOW] +
					    sizeof(struct sadb_address));
	    srcmask = (union sockaddr_union *) (headers[SADB_X_EXT_SRC_MASK] +
						sizeof(struct sadb_address));
	    dstmask = (union sockaddr_union *) (headers[SADB_X_EXT_DST_MASK] +
						sizeof(struct sadb_address));
d1468 1
a1468 14
	    /*
	     * Check that all the address families match. We know they are
	     * valid and supported because pfkeyv2_parsemessage() checked that.
	     */
	    if ((src->sa.sa_family != dst->sa.sa_family) ||
		(src->sa.sa_family != srcmask->sa.sa_family) ||
		(src->sa.sa_family != dstmask->sa.sa_family))
	    {
		rval = EINVAL;
		goto ret;
	    }

	    bzero(&encapdst, sizeof(struct sockaddr_encap));
	    bzero(&encapnetmask, sizeof(struct sockaddr_encap));
a1469 59

	    /* Transport protocol specified ? */
	    if (headers[SADB_X_EXT_PROTOCOL])
	      transproto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL])->sadb_protocol_proto;

	    /* Generic netmask handling, works for IPv4 and IPv6 */
	    rt_maskedcopy(&src->sa, &src->sa, &srcmask->sa);
	    rt_maskedcopy(&dst->sa, &dst->sa, &dstmask->sa);

	    /* Setup the encap fields */
	    encapdst.sen_family = encapnetmask.sen_family = PF_KEY;
	    encapdst.sen_len = encapnetmask.sen_len = SENT_LEN;

	    switch (src->sa.sa_family)
	    {
#ifdef INET
		case AF_INET:
		    encapdst.sen_type = SENT_IP4;
		    encapdst.sen_direction = sab->sadb_protocol_direction;
		    encapdst.sen_ip_src = src->sin.sin_addr;
		    encapdst.sen_ip_dst = dst->sin.sin_addr;
		    encapdst.sen_proto = transproto;
		    encapdst.sen_sport = src->sin.sin_port;
		    encapdst.sen_dport = dst->sin.sin_port;

		    encapnetmask.sen_type = SENT_IP4;
		    encapnetmask.sen_direction = 0xff;
		    encapnetmask.sen_ip_src = srcmask->sin.sin_addr;
		    encapnetmask.sen_ip_dst = dstmask->sin.sin_addr;
                    encapnetmask.sen_sport = srcmask->sin.sin_port;
                    encapnetmask.sen_dport = dstmask->sin.sin_port;
                    if (transproto)
                      encapnetmask.sen_proto = 0xff;
		    break;
#endif /* INET */

#ifdef INET6
		case AF_INET6:
		    encapdst.sen_type = SENT_IP6;
		    encapdst.sen_ip6_direction = sab->sadb_protocol_direction;
		    encapdst.sen_ip6_src = src->sin6.sin6_addr;
		    encapdst.sen_ip6_dst = dst->sin6.sin6_addr;
		    encapdst.sen_ip6_proto = transproto;
		    encapdst.sen_ip6_sport = src->sin6.sin6_port;
		    encapdst.sen_ip6_dport = dst->sin6.sin6_port;

		    encapnetmask.sen_type = SENT_IP6;
		    encapnetmask.sen_ip6_direction = 0xff;
		    encapnetmask.sen_ip6_src = srcmask->sin6.sin6_addr;
		    encapnetmask.sen_ip6_dst = dstmask->sin6.sin6_addr;
                    encapnetmask.sen_ip6_sport = srcmask->sin6.sin6_port;
                    encapnetmask.sen_ip6_dport = dstmask->sin6.sin6_port;
                    if (transproto)
                      encapnetmask.sen_ip6_proto = 0xff;
		    break;
#endif /* INET6 */
	    }

	    /* Determine whether the exact same SPD entry already exists. */
d1516 1
a1516 1
		/* If we were asked to delete something non-existant, error */
d1541 1
d1585 1
a1585 1
			pool_put(&ipsec_policy_pool, ipo);
d1600 1
a1600 5
            {
		bzero(&ipo->ipo_dst, sizeof(union sockaddr_union));
                ipo->ipo_dst.sa.sa_family = src->sa.sa_family;
                ipo->ipo_dst.sa.sa_len = src->sa.sa_len;
            }
d1605 1
a1605 5
	    {
		bzero(&ipo->ipo_src, sizeof(union sockaddr_union));
		ipo->ipo_src.sa.sa_family = src->sa.sa_family;
		ipo->ipo_src.sa.sa_len = src->sa.sa_len;
	    }
d1608 1
d1817 1
d1846 1
d1921 43
@


1.80
log
@Correctly initialize the compression case.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.79 2002/01/23 01:33:07 art Exp $ */
d554 6
@


1.79
log
@It looks like there has been one crack smoking and a few cut and pastes.
PR_FREEHEADER should not be set in pool_init by the caller. It shouldn't
be set in pool_init at all. Besides, it's going away soon anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.78 2002/01/23 00:39:48 art Exp $ */
d2018 2
a2019 2
                sadb_comb->sadb_comb_encrypt = 0;
                sadb_comb->sadb_comb_encrypt = 0;
@


1.78
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.77 2001/08/05 11:03:07 angelos Exp $ */
d1546 1
a1546 1
			      0, 0, PR_FREEHEADER, "ipsec policy", NULL);
@


1.77
log
@Actually, move the check inside the switch.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.76 2001/08/05 11:02:03 angelos Exp $ */
d1546 1
a1546 2
			      0, 0, PR_FREEHEADER, "ipsec policy", 0, NULL,
			      NULL, M_IPSEC_POLICY);
@


1.77.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.79 2002/01/23 01:33:07 art Exp $ */
d1546 2
a1547 1
			      0, 0, 0, "ipsec policy", NULL);
@


1.77.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.77.4.1 2002/01/31 22:55:44 niklas Exp $ */
a554 6
    if (sa->tdb_amxkey)
	    i+= PADUP(sa->tdb_amxkeylen) + sizeof(struct sadb_key);

    if (sa->tdb_emxkey)
	    i+= PADUP(sa->tdb_emxkeylen) + sizeof(struct sadb_key);

d788 1
a788 1
    struct ipsec_policy *ipo, *tmpipo;
a913 19

	    /* Either all or none of the flow must be included */
	    if ((headers[SADB_X_EXT_SRC_FLOW] ||
		headers[SADB_X_EXT_PROTOCOL] ||
		headers[SADB_X_EXT_FLOW_TYPE] ||
		headers[SADB_X_EXT_DST_FLOW] ||
		headers[SADB_X_EXT_SRC_MASK] ||
		headers[SADB_X_EXT_DST_MASK]) &&
		!(headers[SADB_X_EXT_SRC_FLOW] &&
		headers[SADB_X_EXT_PROTOCOL] &&
		headers[SADB_X_EXT_FLOW_TYPE] &&
		headers[SADB_X_EXT_DST_FLOW] &&
		headers[SADB_X_EXT_SRC_MASK] &&
		headers[SADB_X_EXT_DST_MASK]))
	    {
		rval = EINVAL;
		goto ret;
	    }

a976 6
		import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
		    headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		    headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		    headers[SADB_X_EXT_PROTOCOL],
		    headers[SADB_X_EXT_FLOW_TYPE]);

d1028 1
a1033 18
	    /* Either all or none of the flow must be included */
	    if ((headers[SADB_X_EXT_SRC_FLOW] ||
		headers[SADB_X_EXT_PROTOCOL] ||
		headers[SADB_X_EXT_FLOW_TYPE] ||
		headers[SADB_X_EXT_DST_FLOW] ||
		headers[SADB_X_EXT_SRC_MASK] ||
		headers[SADB_X_EXT_DST_MASK]) &&
		!(headers[SADB_X_EXT_SRC_FLOW] &&
		headers[SADB_X_EXT_PROTOCOL] &&
		headers[SADB_X_EXT_FLOW_TYPE] &&
		headers[SADB_X_EXT_DST_FLOW] &&
		headers[SADB_X_EXT_SRC_MASK] &&
		headers[SADB_X_EXT_DST_MASK]))
	    {
		rval = EINVAL;
		goto ret;
	    }

a1102 6
		import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
		    headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		    headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		    headers[SADB_X_EXT_PROTOCOL],
		    headers[SADB_X_EXT_FLOW_TYPE]);

d1270 2
a1271 13

		    /*
		     * Go through the list of policies, delete those that
		     * are not socket-attached.
		     */
		    for (ipo = TAILQ_FIRST(&ipsec_policy_head);
			 ipo != NULL;
			 ipo = tmpipo)
		    {
			tmpipo = TAILQ_NEXT(ipo, ipo_list);
			if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
			  ipsec_delete_policy(ipo);
		    }
d1372 1
a1373 1
	    union sockaddr_union *ssrc;
d1375 1
d1405 81
a1485 4
	    import_flow(&encapdst, &encapnetmask,
		headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		headers[SADB_X_EXT_PROTOCOL], headers[SADB_X_EXT_FLOW_TYPE]);
a1487 1
	    bzero(&encapgw, sizeof(struct sockaddr_encap));
d1534 1
a1534 1
		/* If we were asked to delete something non-existant, error. */
a1558 1
		ipo->ipo_ref_count = 1;
d1602 1
a1602 1
		      pool_put(&ipsec_policy_pool, ipo);
d1617 5
a1621 1
	      bzero(&ipo->ipo_dst, sizeof(union sockaddr_union));
d1626 5
a1630 1
	      bzero(&ipo->ipo_src, sizeof(union sockaddr_union));
a1632 1

a1840 1
    struct sadb_x_cred *lcred, *lauth;
a1868 1

a1944 43
    if (ipo->ipo_local_cred)
    {
	headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
	p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);
	lcred = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_CREDENTIALS];
	lcred->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
				 PADUP(ipo->ipo_local_cred->ref_len)) /
				sizeof(u_int64_t);
	switch (ipo->ipo_local_cred->ref_type)
	{
	case IPSP_CRED_KEYNOTE:
	    lcred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
	    break;
	case IPSP_CRED_X509:
	    lcred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
	    break;
	}
	bcopy(ipo->ipo_local_cred + 1, headers[SADB_X_EXT_LOCAL_CREDENTIALS] +
	      sizeof(struct sadb_x_cred), ipo->ipo_local_cred->ref_len);
    }

    if (ipo->ipo_local_auth)
    {
	headers[SADB_X_EXT_LOCAL_AUTH] = p;
	p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);
	lauth = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_AUTH];
	lauth->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
				 PADUP(ipo->ipo_local_auth->ref_len)) /
				sizeof(u_int64_t);
	switch (ipo->ipo_local_auth->ref_type)
	{
	case IPSP_AUTH_PASSPHRASE:
	    lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_PASSPHRASE;
	    break;
	case IPSP_AUTH_RSA:
	    lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
	    break;
	}

	bcopy(ipo->ipo_local_auth + 1, headers[SADB_X_EXT_LOCAL_AUTH] +
	      sizeof(struct sadb_x_cred), ipo->ipo_local_auth->ref_len);
    }

d2018 2
a2019 2
                sadb_comb->sadb_comb_encrypt_minbits = 0;
                sadb_comb->sadb_comb_encrypt_maxbits = 0;
@


1.77.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.77.4.2 2002/06/11 03:30:46 art Exp $ */
d1634 5
d1649 1
a1649 4
		ipo->ipo_srcid->ref_type = sid->sadb_ident_type;
		ipo->ipo_srcid->ref_len = clen;
		ipo->ipo_srcid->ref_count = 1;
		ipo->ipo_srcid->ref_malloctype = M_CREDENTIALS;
d1660 5
d1680 1
a1680 4
		ipo->ipo_dstid->ref_type = sid->sadb_ident_type;
		ipo->ipo_dstid->ref_len = clen;
		ipo->ipo_dstid->ref_count = 1;
		ipo->ipo_dstid->ref_malloctype = M_CREDENTIALS;
@


1.77.4.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d96 8
a103 7
static const struct sadb_alg ealgs[] = {
	{ SADB_EALG_DESCBC, 64, 64, 64 },
	{ SADB_EALG_3DESCBC, 64, 192, 192 },
	{ SADB_X_EALG_BLF, 64, 40, BLF_MAXKEYLEN * 8},
	{ SADB_X_EALG_CAST, 64, 40, 128},
	{ SADB_X_EALG_SKIPJACK, 64, 80, 80},
	{ SADB_X_EALG_AES, 128, 64, 256},
d106 5
a110 4
static const struct sadb_alg aalgs[] = {
	{ SADB_AALG_SHA1HMAC, 0, 160, 160 },
	{ SADB_AALG_MD5HMAC, 0, 128, 128 },
	{ SADB_AALG_RIPEMD160HMAC, 0, 160, 160 }
d113 3
a115 3
static const struct sadb_alg calgs[] = {
	{ SADB_X_CALG_DEFLATE, 0, 0, 0},
	{ SADB_X_CALG_LZS, 0, 0, 0},
d128 6
a133 4
pfdatatopacket(void *data, int len, struct mbuf **packet) {
	if (!(*packet = m_devget(data, len, 0, NULL, NULL)))
		return (ENOMEM);
	return (0);
d140 7
a146 2
pfkeyv2_create(struct socket *socket) {
	struct pfkeyv2_socket *pfkeyv2_socket;
d148 4
a151 8
	if (!(pfkeyv2_socket = malloc(sizeof(struct pfkeyv2_socket),
	    M_PFKEY, M_DONTWAIT)))
		return (ENOMEM);

	bzero(pfkeyv2_socket, sizeof(struct pfkeyv2_socket));
	pfkeyv2_socket->next = pfkeyv2_sockets;
	pfkeyv2_socket->socket = socket;
	pfkeyv2_socket->pid = curproc->p_pid;
d153 1
a153 1
	pfkeyv2_sockets = pfkeyv2_socket;
d155 1
a155 1
	return (0);
d164 1
a164 1
	struct pfkeyv2_socket **pp;
d166 4
a169 3
	for (pp = &pfkeyv2_sockets; *pp && ((*pp)->socket != socket);
	    pp = &((*pp)->next))
		/*EMPTY*/;
d171 3
a173 2
	if (*pp) {
		struct pfkeyv2_socket *pfkeyv2_socket;
d175 2
a176 2
		pfkeyv2_socket = *pp;
		*pp = (*pp)->next;
d178 2
a179 2
		if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_REGISTERED)
			nregistered--;
d181 2
a182 2
		if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
			npromisc--;
d184 2
a185 2
		free(pfkeyv2_socket, M_PFKEY);
	}
d187 1
a187 1
	return (0);
d197 1
a197 1
    u_int8_t satype, int count)
d199 19
a217 8
	int i, j, rval;
	void *p, *buffer = NULL;
	struct mbuf *packet;
	struct pfkeyv2_socket *s;
	struct sadb_msg *smsg;

	/* Find out how much space we'll need... */
	j = sizeof(struct sadb_msg);
d219 17
a235 24
	for (i = 1; i <= SADB_EXT_MAX; i++)
		if (headers[i])
			j += ((struct sadb_ext *)headers[i])->sadb_ext_len *
			    sizeof(uint64_t);

	/* ...and allocate it */
	if (!(buffer = malloc(j + sizeof(struct sadb_msg), M_PFKEY,
	    M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	}

	p = buffer + sizeof(struct sadb_msg);
	bcopy(headers[0], p, sizeof(struct sadb_msg));
	((struct sadb_msg *) p)->sadb_msg_len = j / sizeof(uint64_t);
	p += sizeof(struct sadb_msg);

	/* Copy payloads in the packet */
	for (i = 1; i <= SADB_EXT_MAX; i++)
		if (headers[i]) {
			((struct sadb_ext *) headers[i])->sadb_ext_type = i;
			bcopy(headers[i], p, EXTLEN(headers[i]));
			p += EXTLEN(headers[i]);
		}
d237 2
a238 5
	if ((rval = pfdatatopacket(buffer + sizeof(struct sadb_msg),
	    j, &packet)) != 0)
		goto ret;

	switch (mode) {
d240 36
a275 36
		/*
		 * Send message to the specified socket, plus all
		 * promiscuous listeners.
		 */
		pfkey_sendup(socket, packet, 0);

		/*
		 * Promiscuous messages contain the original message
		 * encapsulated in another sadb_msg header.
		 */
		bzero(buffer, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) buffer;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + j) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = 0;

		/* Copy to mbuf chain */
		if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
		    &packet)) != 0)
			goto ret;

		/*
		 * Search for promiscuous listeners, skipping the
		 * original destination.
		 */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
			    (s->socket != socket))
				pfkey_sendup(s->socket, packet, 1);

		/* Done, let's be a bit paranoid */
		m_zero(packet);
		m_freem(packet);
		break;
d278 39
a316 17
		/*
		 * Send the message to all registered sockets that match
		 * the specified satype (e.g., all IPSEC-ESP negotiators)
		 */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED) {
				if (!satype)    /* Just send to everyone registered */
					pfkey_sendup(s->socket, packet, 1);
				else {
					/* Check for specified satype */
					if ((1 << satype) & s->registration)
						pfkey_sendup(s->socket, packet, 1);
				}
			}

		/* Free last/original copy of the packet */
		m_freem(packet);
d318 2
a319 22
		/* Encapsulate the original message "inside" an sadb_msg header */
		bzero(buffer, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) buffer;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + j) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = 0;

		/* Convert to mbuf chain */
		if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
		    &packet)) != 0)
			goto ret;

		/* Send to all registered promiscuous listeners */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
			    !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
				pfkey_sendup(s->socket, packet, 1);

		m_freem(packet);
		break;
d322 7
a328 3
		/* Send message to all sockets */
		for (s = pfkeyv2_sockets; s; s = s->next)
			pfkey_sendup(s->socket, packet, 1);
d330 6
a335 9
		m_freem(packet);
		break;
	}

ret:
	if (buffer != NULL) {
		bzero(buffer, j + sizeof(struct sadb_msg));
		free(buffer, M_PFKEY);
	}
d337 1
a337 1
	return (rval);
d348 8
a355 8
	union sockaddr_union sunion;
	struct sadb_protocol *sp;
	int rval, i, dir;
	void *p;

	/* Find out how big a buffer we need */
	i = 4 * sizeof(struct sadb_address) + sizeof(struct sadb_protocol);
	bzero(&sunion, sizeof(union sockaddr_union));
d357 2
a358 1
	switch (ipa->ipa_info.sen_type) {
d361 5
a365 5
		i += 4 * PADUP(sizeof(struct sockaddr_in));
		sunion.sa.sa_family = AF_INET;
		sunion.sa.sa_len = sizeof(struct sockaddr_in);
		dir = ipa->ipa_info.sen_direction;
		break;
d370 5
a374 5
		i += 4 * PADUP(sizeof(struct sockaddr_in6));
		sunion.sa.sa_family = AF_INET6;
		sunion.sa.sa_len = sizeof(struct sockaddr_in6);
		dir = ipa->ipa_info.sen_ip6_direction;
		break;
d378 2
a379 2
		return (EINVAL);
	}
d381 10
a390 7
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	} else {
		*buffer = p;
		bzero(p, i);
	}
d392 6
a397 5
	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_SRC_FLOW] = p;
	else
		headers[SADB_X_EXT_DST_FLOW] = p;
	switch (sunion.sa.sa_family) {
d400 3
a402 3
		sunion.sin.sin_addr = ipa->ipa_info.sen_ip_src;
		sunion.sin.sin_port = ipa->ipa_info.sen_sport;
		break;
d407 3
a409 3
		sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_src;
		sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_sport;
		break;
d411 2
a412 2
	}
	export_address(&p, (struct sockaddr *) &sunion);
d414 6
a419 5
	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_SRC_MASK] = p;
	else
		headers[SADB_X_EXT_DST_MASK] = p;
	switch (sunion.sa.sa_family) {
d422 3
a424 3
		sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_src;
		sunion.sin.sin_port = ipa->ipa_mask.sen_sport;
		break;
d429 3
a431 3
		sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_src;
		sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_sport;
		break;
d433 2
a434 2
	}
	export_address(&p, (struct sockaddr *) &sunion);
d436 6
a441 5
	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_DST_FLOW] = p;
	else
		headers[SADB_X_EXT_SRC_FLOW] = p;
	switch (sunion.sa.sa_family) {
d444 3
a446 3
		sunion.sin.sin_addr = ipa->ipa_info.sen_ip_dst;
		sunion.sin.sin_port = ipa->ipa_info.sen_dport;
		break;
d451 3
a453 3
		sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_dst;
		sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_dport;
		break;
d455 2
a456 2
	}
	export_address(&p, (struct sockaddr *) &sunion);
d458 6
a463 5
	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_DST_MASK] = p;
	else
		headers[SADB_X_EXT_SRC_MASK] = p;
	switch (sunion.sa.sa_family) {
d466 3
a468 3
		sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_dst;
		sunion.sin.sin_port = ipa->ipa_mask.sen_dport;
		break;
d473 3
a475 3
		sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_dst;
		sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_dport;
		break;
d477 2
a478 2
	}
	export_address(&p, (struct sockaddr *) &sunion);
d480 5
a484 5
	headers[SADB_X_EXT_FLOW_TYPE] = p;
	sp = p;
	sp->sadb_protocol_len = sizeof(struct sadb_protocol) /
	    sizeof(u_int64_t);
	switch (sunion.sa.sa_family) {
d487 4
a490 4
		if (ipa->ipa_mask.sen_proto)
			sp->sadb_protocol_proto = ipa->ipa_info.sen_proto;
		sp->sadb_protocol_direction = ipa->ipa_info.sen_direction;
		break;
d495 4
a498 4
		if (ipa->ipa_mask.sen_ip6_proto)
			sp->sadb_protocol_proto = ipa->ipa_info.sen_ip6_proto;
		sp->sadb_protocol_direction = ipa->ipa_info.sen_ip6_direction;
		break;
d500 1
a500 1
	}
d502 1
a502 1
	rval = 0;
d504 2
a505 2
ret:
	return (rval);
d514 2
a515 2
	int rval, i;
	void *p;
d517 2
a518 2
	/* Find how much space we need */
	i = sizeof(struct sadb_sa) + sizeof(struct sadb_lifetime);
d520 3
a522 3
	if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
	    sa->tdb_soft_timeout || sa->tdb_soft_first_use)
		i += sizeof(struct sadb_lifetime);
d524 3
a526 3
	if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
	    sa->tdb_exp_timeout || sa->tdb_exp_first_use)
		i += sizeof(struct sadb_lifetime);
d528 2
a529 2
	if (sa->tdb_src.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa));
d531 2
a532 2
	if (sa->tdb_dst.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
d534 2
a535 2
	if (sa->tdb_proxy.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_proxy.sa));
d537 2
a538 2
	if (sa->tdb_srcid)
		i += PADUP(sa->tdb_srcid->ref_len) + sizeof(struct sadb_ident);
d540 2
a541 2
	if (sa->tdb_dstid)
		i += PADUP(sa->tdb_dstid->ref_len) + sizeof(struct sadb_ident);
d543 2
a544 2
	if (sa->tdb_local_cred)
		i += PADUP(sa->tdb_local_cred->ref_len) + sizeof(struct sadb_x_cred);
d546 2
a547 2
	if (sa->tdb_remote_cred)
		i += PADUP(sa->tdb_remote_cred->ref_len) + sizeof(struct sadb_x_cred);
d549 2
a550 2
	if (sa->tdb_local_auth)
		i += PADUP(sa->tdb_local_auth->ref_len) + sizeof(struct sadb_x_cred);
d552 2
a553 2
	if (sa->tdb_remote_auth)
		i += PADUP(sa->tdb_remote_auth->ref_len) + sizeof(struct sadb_x_cred);
d555 2
a556 2
	if (sa->tdb_amxkey)
		i+= PADUP(sa->tdb_amxkeylen) + sizeof(struct sadb_key);
d558 2
a559 2
	if (sa->tdb_emxkey)
		i+= PADUP(sa->tdb_emxkeylen) + sizeof(struct sadb_key);
d561 10
a570 7
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	} else {
		*buffer = p;
		bzero(p, i);
	}
d572 1
a572 1
	headers[SADB_EXT_SA] = p;
d574 1
a574 1
	export_sa(&p, sa);  /* Export SA information (mostly flags) */
d576 86
a661 9
	/* Export lifetimes where applicable */
	headers[SADB_EXT_LIFETIME_CURRENT] = p;
	export_lifetime(&p, sa, PFKEYV2_LIFETIME_CURRENT);

	if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
	    sa->tdb_soft_first_use || sa->tdb_soft_timeout) {
		headers[SADB_EXT_LIFETIME_SOFT] = p;
		export_lifetime(&p, sa, PFKEYV2_LIFETIME_SOFT);
	}
d663 1
a663 67
	if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
	    sa->tdb_exp_first_use || sa->tdb_exp_timeout) {
		headers[SADB_EXT_LIFETIME_HARD] = p;
		export_lifetime(&p, sa, PFKEYV2_LIFETIME_HARD);
	}

	/* Export TDB source address */
	headers[SADB_EXT_ADDRESS_SRC] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_src);

	/* Export TDB destination address */
	headers[SADB_EXT_ADDRESS_DST] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_dst);

	/* Export TDB proxy address, if present */
	if (SA_LEN(&sa->tdb_proxy.sa)) {
		headers[SADB_EXT_ADDRESS_PROXY] = p;
		export_address(&p, (struct sockaddr *) &sa->tdb_proxy);
	}

	/* Export source identity, if present */
	if (sa->tdb_srcid) {
		headers[SADB_EXT_IDENTITY_SRC] = p;
		export_identity(&p, sa, PFKEYV2_IDENTITY_SRC);
	}

	/* Export destination identity, if present */
	if (sa->tdb_dstid) {
		headers[SADB_EXT_IDENTITY_DST] = p;
		export_identity(&p, sa, PFKEYV2_IDENTITY_DST);
	}

	/* Export credentials, if present */
	if (sa->tdb_local_cred) {
		headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
		export_credentials(&p, sa, PFKEYV2_CRED_LOCAL);
	}

	if (sa->tdb_remote_cred) {
		headers[SADB_X_EXT_REMOTE_CREDENTIALS] = p;
		export_credentials(&p, sa, PFKEYV2_CRED_REMOTE);
	}

	/* Export authentication information, if present */
	if (sa->tdb_local_auth) {
		headers[SADB_X_EXT_LOCAL_AUTH] = p;
		export_auth(&p, sa, PFKEYV2_AUTH_LOCAL);
	}

	if (sa->tdb_remote_auth) {
		headers[SADB_X_EXT_REMOTE_AUTH] = p;
		export_auth(&p, sa, PFKEYV2_AUTH_REMOTE);
	}

	/* Export authentication key, if present */
	if (sa->tdb_amxkey) {
		headers[SADB_EXT_KEY_AUTH] = p;
		export_key(&p, sa, PFKEYV2_AUTHENTICATION_KEY);
	}

	/* Export encryption key, if present */
	if (sa->tdb_emxkey) {
		headers[SADB_EXT_KEY_ENCRYPT] = p;
		export_key(&p, sa, PFKEYV2_ENCRYPTION_KEY);
	}

	rval = 0;
d666 1
a666 1
	return (rval);
d675 21
a695 20
	struct dump_state *dump_state = (struct dump_state *) state;
	void *headers[SADB_EXT_MAX+1], *buffer;
	int rval;

	/* If not satype was specified, dump all TDBs */
	if (!dump_state->sadb_msg->sadb_msg_satype ||
	    (sa->tdb_satype == dump_state->sadb_msg->sadb_msg_satype)) {
		bzero(headers, sizeof(headers));
		headers[0] = (void *) dump_state->sadb_msg;

		/* Get the information from the TDB to a PFKEYv2 message */
		if ((rval = pfkeyv2_get(sa, headers, &buffer)) != 0)
			return (rval);

		if (last)
			((struct sadb_msg *)headers[0])->sadb_msg_seq = 0;

		/* Send the message to the specified socket */
		rval = pfkeyv2_sendmessage(headers,
		    PFKEYV2_SENDMESSAGE_UNICAST, dump_state->socket, 0, 0);
d697 4
a700 4
		free(buffer, M_PFKEY);
		if (rval)
			return (rval);
	}
d702 1
a702 1
	return (0);
d711 5
a715 4
	if (!(*((u_int8_t *) satype_vp)) ||
	    sa->tdb_satype == *((u_int8_t *) satype_vp))
		tdb_delete(sa);
	return (0);
d726 2
a727 1
	switch (satype) {
d729 2
a730 2
		if (!ah_enable)
			return (EOPNOTSUPP);
d732 1
a732 1
		*sproto = IPPROTO_AH;
d734 2
a735 2
		if(alg != NULL)
			*alg = satype = XF_AH;
d737 1
a737 1
		break;
d740 2
a741 2
		if (!esp_enable)
			return (EOPNOTSUPP);
d743 1
a743 1
		*sproto = IPPROTO_ESP;
d745 2
a746 2
		if(alg != NULL)
			*alg = satype = XF_ESP;
d748 1
a748 1
		break;
d751 1
a751 1
		*sproto = IPPROTO_IPIP;
d753 2
a754 2
		if (alg != NULL)
			*alg = XF_IP4;
d756 1
a756 1
		break;
d759 2
a760 2
		if (!ipcomp_enable)
			return (EOPNOTSUPP);
d762 1
a762 1
		*sproto = IPPROTO_IPCOMP;
d764 2
a765 2
		if(alg != NULL)
			*alg = satype = XF_IPCOMP;
d767 1
a767 1
		break;
d771 1
a771 1
		*sproto = IPPROTO_TCP;
d773 2
a774 2
		if (alg != NULL)
			*alg = XF_TCPSIGNATURE;
d776 1
a776 1
		break;
d780 2
a781 2
		return (EOPNOTSUPP);
	}
d783 1
a783 1
	return (0);
d792 4
a795 5
	int i, j, rval = 0, mode = PFKEYV2_SENDMESSAGE_BROADCAST;
	int delflag = 0, s;
	struct sockaddr_encap encapdst, encapnetmask, encapgw;
	struct ipsec_policy *ipo, *tmpipo;
	struct ipsec_acquire *ipa;
d797 1
a797 1
	struct pfkeyv2_socket *pfkeyv2_socket, *so = NULL;
d799 2
a800 2
	void *freeme = NULL, *bckptr = NULL;
	void *headers[SADB_EXT_MAX + 1];
d802 1
a802 1
	union sockaddr_union *sunionp;
d804 1
a804 1
	struct tdb sa, *sa2 = NULL;
d806 5
a810 5
	struct sadb_msg *smsg;
	struct sadb_spirange *sprng;
	struct sadb_sa *ssa;
	struct sadb_supported *ssup;
	struct sadb_ident *sid;
d812 26
a837 2
	/* Verify that we received this over a legitimate pfkeyv2 socket */
	bzero(headers, sizeof(headers));
d839 40
a878 4
	for (pfkeyv2_socket = pfkeyv2_sockets; pfkeyv2_socket;
	    pfkeyv2_socket = pfkeyv2_socket->next)
		if (pfkeyv2_socket->socket == socket)
			break;
d880 24
a903 2
	if (!pfkeyv2_socket) {
		rval = EINVAL;
d905 1
a905 1
	}
d907 8
a914 3
	/* If we have any promiscuous listeners, send them a copy of the message */
	if (npromisc) {
		struct mbuf *packet;
d916 22
a937 5
		if (!(freeme = malloc(sizeof(struct sadb_msg) + len, M_PFKEY,
		    M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d939 1
a939 15
		/* Initialize encapsulating header */
		bzero(freeme, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) freeme;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + len) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = curproc->p_pid;

		bcopy(message, freeme + sizeof(struct sadb_msg), len);

		/* Convert to mbuf chain */
		if ((rval = pfdatatopacket(freeme,
		    sizeof(struct sadb_msg) + len, &packet)) != 0)
			goto ret;
d941 3
a943 4
		/* Send to all promiscuous listeners */
		for (so = pfkeyv2_sockets; so; so = so->next)
			if (so->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
				pfkey_sendup(so->socket, packet, 1);
d945 6
a950 3
		/* Paranoid */
		m_zero(packet);
		m_freem(packet);
d952 6
a957 5
		/* Even more paranoid */
		bzero(freeme, sizeof(struct sadb_msg) + len);
		free(freeme, M_PFKEY);
		freeme = NULL;
	}
d959 3
a961 3
	/* Validate message format */
	if ((rval = pfkeyv2_parsemessage(message, len, headers)) != 0)
		goto ret;
d963 2
a964 4
	smsg = (struct sadb_msg *) headers[0];
	switch (smsg->sadb_msg_type) {
	case SADB_GETSPI:  /* Reserve an SPI */
		bzero(&sa, sizeof(struct tdb));
d966 41
a1006 24
		sa.tdb_satype = smsg->sadb_msg_satype;
		if ((rval = pfkeyv2_get_proto_alg(sa.tdb_satype,
		    &sa.tdb_sproto, 0)))
			goto ret;

		import_address((struct sockaddr *) &sa.tdb_src,
		    headers[SADB_EXT_ADDRESS_SRC]);
		import_address((struct sockaddr *) &sa.tdb_dst,
		    headers[SADB_EXT_ADDRESS_DST]);

		/* Find an unused SA identifier */
		sprng = (struct sadb_spirange *) headers[SADB_EXT_SPIRANGE];
		sa.tdb_spi = reserve_spi(sprng->sadb_spirange_min,
		    sprng->sadb_spirange_max, &sa.tdb_src, &sa.tdb_dst,
		    sa.tdb_sproto, &rval);
		if (sa.tdb_spi == 0)
			goto ret;

		/* Send a message back telling what the SA (the SPI really) is */
		if (!(freeme = malloc(sizeof(struct sadb_sa), M_PFKEY,
		    M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d1008 3
a1010 4
		bzero(freeme, sizeof(struct sadb_sa));
		headers[SADB_EXT_SPIRANGE] = NULL;
		headers[SADB_EXT_SA] = freeme;
		bckptr = freeme;
d1012 1
a1012 3
		/* We really only care about the SPI, but we'll export the SA */
		export_sa((void **) &bckptr, &sa);
		break;
d1014 7
a1020 20
	case SADB_UPDATE:
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		/* Either all or none of the flow must be included */
		if ((headers[SADB_X_EXT_SRC_FLOW] ||
		    headers[SADB_X_EXT_PROTOCOL] ||
		    headers[SADB_X_EXT_FLOW_TYPE] ||
		    headers[SADB_X_EXT_DST_FLOW] ||
		    headers[SADB_X_EXT_SRC_MASK] ||
		    headers[SADB_X_EXT_DST_MASK]) &&
		    !(headers[SADB_X_EXT_SRC_FLOW] &&
		    headers[SADB_X_EXT_PROTOCOL] &&
		    headers[SADB_X_EXT_FLOW_TYPE] &&
		    headers[SADB_X_EXT_DST_FLOW] &&
		    headers[SADB_X_EXT_SRC_MASK] &&
		    headers[SADB_X_EXT_DST_MASK])) {
			rval = EINVAL;
			goto ret;
d1023 1
a1023 1
		s = spltdb();
d1025 21
a1045 8
		/* Find TDB */
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));

		/* If there's no such SA, we're done */
		if (sa2 == NULL) {
			rval = ESRCH;
			goto splxret;
d1048 8
a1055 103
		/* If this is a reserved SA */
		if (sa2->tdb_flags & TDBF_INVALID) {
			struct tdb *newsa;
			struct ipsecinit ii;
			int alg;

			/* Create new TDB */
			freeme = tdb_alloc();
			bzero(&ii, sizeof(struct ipsecinit));

			newsa = (struct tdb *) freeme;
			newsa->tdb_satype = smsg->sadb_msg_satype;

			if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
			    &newsa->tdb_sproto, &alg)))
				goto splxret;

			/* Initialize SA */
			import_sa(newsa, headers[SADB_EXT_SA], &ii);
			import_address((struct sockaddr *) &newsa->tdb_src,
			    headers[SADB_EXT_ADDRESS_SRC]);
			import_address((struct sockaddr *) &newsa->tdb_dst,
			    headers[SADB_EXT_ADDRESS_DST]);
			import_address((struct sockaddr *) &newsa->tdb_proxy,
			    headers[SADB_EXT_ADDRESS_PROXY]);
			import_lifetime(newsa,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);
			import_key(&ii, headers[SADB_EXT_KEY_AUTH],
			    PFKEYV2_AUTHENTICATION_KEY);
			import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT],
			    PFKEYV2_ENCRYPTION_KEY);
			import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC],
			    PFKEYV2_IDENTITY_SRC);
			import_identity(newsa, headers[SADB_EXT_IDENTITY_DST],
			    PFKEYV2_IDENTITY_DST);
			import_credentials(newsa,
			    headers[SADB_X_EXT_LOCAL_CREDENTIALS],
			    PFKEYV2_CRED_LOCAL);
			import_credentials(newsa,
			    headers[SADB_X_EXT_REMOTE_CREDENTIALS],
			    PFKEYV2_CRED_REMOTE);
			import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
			    PFKEYV2_AUTH_LOCAL);
			import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
			    PFKEYV2_AUTH_REMOTE);
			import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
			    headers[SADB_X_EXT_SRC_FLOW],
			    headers[SADB_X_EXT_SRC_MASK],
			    headers[SADB_X_EXT_DST_FLOW],
			    headers[SADB_X_EXT_DST_MASK],
			    headers[SADB_X_EXT_PROTOCOL],
			    headers[SADB_X_EXT_FLOW_TYPE]);

			headers[SADB_EXT_KEY_AUTH] = NULL;
			headers[SADB_EXT_KEY_ENCRYPT] = NULL;
			headers[SADB_X_EXT_LOCAL_AUTH] = NULL;

			newsa->tdb_seq = smsg->sadb_msg_seq;

			rval = tdb_init(newsa, alg, &ii);
			if (rval) {
				rval = EINVAL;
				tdb_delete(freeme);
				freeme = NULL;
				goto splxret;
			}

			newsa->tdb_cur_allocations = sa2->tdb_cur_allocations;

			/* Delete old version of the SA, insert new one */
			tdb_delete(sa2);
			puttdb((struct tdb *) freeme);
			sa2 = freeme = NULL;
		} else {
			/*
			 * The SA is already initialized, so we're only allowed to
			 * change lifetimes and some other information; we're
			 * not allowed to change keys, addresses or identities.
			 */
			if (headers[SADB_EXT_ADDRESS_PROXY] ||
			    headers[SADB_EXT_KEY_AUTH] ||
			    headers[SADB_EXT_KEY_ENCRYPT] ||
			    headers[SADB_EXT_IDENTITY_SRC] ||
			    headers[SADB_EXT_IDENTITY_DST] ||
			    headers[SADB_EXT_SENSITIVITY]) {
				rval = EINVAL;
				goto splxret;
			}

			import_sa(sa2, headers[SADB_EXT_SA], NULL);
			import_lifetime(sa2,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(sa2, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(sa2, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);
		}
d1057 2
a1058 2
		splx(s);
		break;
d1060 26
a1085 20
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		/* Either all or none of the flow must be included */
		if ((headers[SADB_X_EXT_SRC_FLOW] ||
		    headers[SADB_X_EXT_PROTOCOL] ||
		    headers[SADB_X_EXT_FLOW_TYPE] ||
		    headers[SADB_X_EXT_DST_FLOW] ||
		    headers[SADB_X_EXT_SRC_MASK] ||
		    headers[SADB_X_EXT_DST_MASK]) &&
		    !(headers[SADB_X_EXT_SRC_FLOW] &&
		    headers[SADB_X_EXT_PROTOCOL] &&
		    headers[SADB_X_EXT_FLOW_TYPE] &&
		    headers[SADB_X_EXT_DST_FLOW] &&
		    headers[SADB_X_EXT_SRC_MASK] &&
		    headers[SADB_X_EXT_DST_MASK])) {
			rval = EINVAL;
			goto ret;
		}
d1087 13
a1099 1
		s = spltdb();
d1101 2
a1102 2
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d1104 52
a1155 5
		/* We can't add an existing SA! */
		if (sa2 != NULL) {
			rval = EEXIST;
			goto splxret;
		}
d1157 3
a1159 5
		/* We can only add "mature" SAs */
		if (ssa->sadb_sa_state != SADB_SASTATE_MATURE) {
			rval = EINVAL;
			goto splxret;
		}
d1161 1
a1161 2
		/* Allocate and initialize new TDB */
		freeme = tdb_alloc();
d1163 2
d1166 4
a1169 68
			struct tdb *newsa = (struct tdb *) freeme;
			struct ipsecinit ii;
			int alg;

			bzero(&ii, sizeof(struct ipsecinit));

			newsa->tdb_satype = smsg->sadb_msg_satype;
			if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
			    &newsa->tdb_sproto, &alg)))
				goto splxret;

			import_sa(newsa, headers[SADB_EXT_SA], &ii);
			import_address((struct sockaddr *) &newsa->tdb_src,
			    headers[SADB_EXT_ADDRESS_SRC]);
			import_address((struct sockaddr *) &newsa->tdb_dst,
			    headers[SADB_EXT_ADDRESS_DST]);
			import_address((struct sockaddr *) &newsa->tdb_proxy,
			    headers[SADB_EXT_ADDRESS_PROXY]);

			import_lifetime(newsa,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);

			import_key(&ii, headers[SADB_EXT_KEY_AUTH],
			    PFKEYV2_AUTHENTICATION_KEY);
			import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT],
			    PFKEYV2_ENCRYPTION_KEY);

			import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC],
			    PFKEYV2_IDENTITY_SRC);
			import_identity(newsa, headers[SADB_EXT_IDENTITY_DST],
			    PFKEYV2_IDENTITY_DST);

			import_credentials(newsa,
			    headers[SADB_X_EXT_LOCAL_CREDENTIALS],
			    PFKEYV2_CRED_LOCAL);
			import_credentials(newsa,
			    headers[SADB_X_EXT_REMOTE_CREDENTIALS],
			    PFKEYV2_CRED_REMOTE);
			import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
			    PFKEYV2_AUTH_LOCAL);
			import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
			    PFKEYV2_AUTH_REMOTE);
			import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
			    headers[SADB_X_EXT_SRC_FLOW],
			    headers[SADB_X_EXT_SRC_MASK],
			    headers[SADB_X_EXT_DST_FLOW],
			    headers[SADB_X_EXT_DST_MASK],
			    headers[SADB_X_EXT_PROTOCOL],
			    headers[SADB_X_EXT_FLOW_TYPE]);

			headers[SADB_EXT_KEY_AUTH] = NULL;
			headers[SADB_EXT_KEY_ENCRYPT] = NULL;
			headers[SADB_X_EXT_LOCAL_AUTH] = NULL;

			newsa->tdb_seq = smsg->sadb_msg_seq;

			rval = tdb_init(newsa, alg, &ii);
			if (rval) {
				rval = EINVAL;
				tdb_delete(freeme);
				freeme = NULL;
				goto splxret;
			}
d1171 1
d1173 2
a1174 2
		/* Add TDB in table */
		puttdb((struct tdb *) freeme);
d1176 1
a1176 1
		splx(s);
d1178 2
a1179 2
		freeme = NULL;
		break;
d1182 12
a1193 11
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));
		s = spltdb();

		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (sa2 == NULL) {
			rval = ESRCH;
			goto splxret;
		}
d1195 1
a1195 1
		tdb_delete(sa2);
d1197 1
a1197 1
		splx(s);
d1199 2
a1200 2
		sa2 = NULL;
		break;
d1203 7
a1209 6
		/* Get the relevant policy */
		ipa = ipsec_get_acquire(((struct sadb_x_policy *) headers[SADB_X_EXT_POLICY])->sadb_x_policy_seq);
		if (ipa == NULL) {
			rval = ESRCH;
			goto ret;
		}
d1211 3
a1213 3
		rval = pfkeyv2_policy(ipa, headers, &freeme);
		if (rval)
			mode = PFKEYV2_SENDMESSAGE_UNICAST;
d1215 1
a1215 1
		break;
d1218 12
a1229 11
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));
		s = spltdb();

		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (sa2 == NULL) {
			rval = ESRCH;
			goto splxret;
		}
d1231 3
a1233 3
		rval = pfkeyv2_get(sa2, headers, &freeme);
		if (rval)
			mode = PFKEYV2_SENDMESSAGE_UNICAST;
d1235 1
a1235 1
		splx(s);
d1237 1
a1237 1
		break;
d1240 2
a1241 2
		pfkeyv2_socket->flags |= PFKEYV2_SOCKETFLAGS_REGISTERED;
		nregistered++;
d1243 1
a1243 1
		i = sizeof(struct sadb_supported) + sizeof(ealgs);
d1245 5
a1249 4
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d1251 1
a1251 1
		bzero(freeme, i);
d1253 2
a1254 2
		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);
d1256 2
a1257 2
		{
			void *p = freeme + sizeof(struct sadb_supported);
d1259 2
a1260 2
			bcopy(&ealgs[0], p, sizeof(ealgs));
		}
d1262 1
a1262 1
		headers[SADB_EXT_SUPPORTED_ENCRYPT] = freeme;
d1264 1
a1264 1
		i = sizeof(struct sadb_supported) + sizeof(aalgs);
d1266 5
a1270 4
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d1272 2
a1273 2
		/* Keep track what this socket has registered for */
		pfkeyv2_socket->registration |= (1 << ((struct sadb_msg *)message)->sadb_msg_satype);
d1275 1
a1275 1
		bzero(freeme, i);
d1277 2
a1278 2
		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);
d1280 2
a1281 2
		{
			void *p = freeme + sizeof(struct sadb_supported);
d1283 2
a1284 2
			bcopy(&aalgs[0], p, sizeof(aalgs));
		}
d1286 1
a1286 1
		headers[SADB_EXT_SUPPORTED_AUTH] = freeme;
d1288 1
a1288 1
		i = sizeof(struct sadb_supported) + sizeof(calgs);
d1290 5
a1294 4
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d1296 1
a1296 1
		bzero(freeme, i);
d1298 2
a1299 2
		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);
d1301 2
a1302 2
		{
			void *p = freeme + sizeof(struct sadb_supported);
d1304 2
a1305 2
			bcopy(&calgs[0], p, sizeof(calgs));
		}
d1307 1
a1307 1
		headers[SADB_X_EXT_SUPPORTED_COMP] = freeme;
d1309 1
a1309 1
		break;
d1313 3
a1315 3
		/* Nothing to handle */
		rval = 0;
		break;
d1318 1
a1318 1
		rval = 0;
d1320 2
a1321 1
		switch (smsg->sadb_msg_satype) {
d1323 1
a1323 1
			s = spltdb();
d1325 14
a1338 12
			/*
			 * Go through the list of policies, delete those that
			 * are not socket-attached.
			 */
			for (ipo = TAILQ_FIRST(&ipsec_policy_head);
			    ipo != NULL; ipo = tmpipo) {
				tmpipo = TAILQ_NEXT(ipo, ipo_list);
				if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
					ipsec_delete_policy(ipo);
			}
			splx(s);
			/* Fall through */
d1346 1
a1346 1
			s = spltdb();
d1348 2
a1349 2
			tdb_walk(pfkeyv2_flush_walker,
			    (u_int8_t *) &(smsg->sadb_msg_satype));
d1351 2
a1352 2
			splx(s);
			break;
d1355 2
a1356 2
			rval = EINVAL; /* Unknown/unsupported type */
		}
d1358 1
a1358 1
		break;
d1362 3
a1364 3
		struct dump_state dump_state;
		dump_state.sadb_msg = (struct sadb_msg *) headers[0];
		dump_state.socket = socket;
d1366 2
a1367 2
		if (!(rval = tdb_walk(pfkeyv2_dump_walker, &dump_state)))
			goto realret;
d1369 2
a1370 2
		if ((rval == ENOMEM) || (rval == ENOBUFS))
			rval = 0;
d1372 2
a1373 1
	break;
d1377 2
a1378 2
		struct tdb *tdb1, *tdb2, *tdb3;
		struct sadb_protocol *sa_proto;
d1380 13
a1392 12
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		s = spltdb();

		tdb1 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (tdb1 == NULL) {
			rval = ESRCH;
			goto splxret;
		}
d1394 12
a1405 11
		ssa = (struct sadb_sa *) headers[SADB_X_EXT_SA2];
		sunionp = (union sockaddr_union *) (headers[SADB_X_EXT_DST2] +
		    sizeof(struct sadb_address));
		sa_proto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL]);

		tdb2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(sa_proto->sadb_protocol_proto));
		if (tdb2 == NULL) {
			rval = ESRCH;
			goto splxret;
		}
d1407 20
a1426 19
		/* Detect cycles */
		for (tdb3 = tdb2; tdb3; tdb3 = tdb3->tdb_onext)
			if (tdb3 == tdb1) {
				rval = ESRCH;
				goto splxret;
			}

		/* Maintenance */
		if ((tdb1->tdb_onext) &&
		    (tdb1->tdb_onext->tdb_inext == tdb1))
			tdb1->tdb_onext->tdb_inext = NULL;

		if ((tdb2->tdb_inext) &&
		    (tdb2->tdb_inext->tdb_onext == tdb2))
			tdb2->tdb_inext->tdb_onext = NULL;

		/* Link them */
		tdb1->tdb_onext = tdb2;
		tdb2->tdb_inext = tdb1;
d1428 1
a1428 1
		splx(s);
d1430 1
a1430 1
	break;
d1433 2
a1434 2
		delflag = 1;
		/*FALLTHROUGH*/
d1437 13
a1449 12
		struct sadb_protocol *sab;
		union sockaddr_union *ssrc;
		struct route_enc re;
		int exists = 0;

		sab = (struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE];

		if ((sab->sadb_protocol_direction != IPSP_DIRECTION_IN) &&
		    (sab->sadb_protocol_direction != IPSP_DIRECTION_OUT)) {
			rval = EINVAL;
			goto ret;
		}
d1451 42
a1492 8
		/* If the security protocol wasn't specified, pretend it was ESP */
		if (smsg->sadb_msg_satype == 0)
			smsg->sadb_msg_satype = SADB_SATYPE_ESP;

		if (headers[SADB_EXT_ADDRESS_DST])
			sunionp = (union sockaddr_union *)
			    (headers[SADB_EXT_ADDRESS_DST] +
				sizeof(struct sadb_address));
d1494 17
a1510 1
			sunionp = NULL;
d1512 9
a1520 6
		if (headers[SADB_EXT_ADDRESS_SRC])
			ssrc = (union sockaddr_union *)
			    (headers[SADB_EXT_ADDRESS_SRC] +
				sizeof(struct sadb_address));
		else
			ssrc = NULL;
d1522 5
a1526 4
		import_flow(&encapdst, &encapnetmask,
		    headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		    headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		    headers[SADB_X_EXT_PROTOCOL], headers[SADB_X_EXT_FLOW_TYPE]);
d1528 7
a1534 33
		/* Determine whether the exact same SPD entry already exists. */
		bzero(&encapgw, sizeof(struct sockaddr_encap));
		bzero(&re, sizeof(struct route_enc));
		bcopy(&encapdst, &re.re_dst, sizeof(struct sockaddr_encap));

		s = spltdb();

		rtalloc((struct route *) &re);
		if (re.re_rt != NULL) {
			ipo = ((struct sockaddr_encap *) re.re_rt->rt_gateway)->sen_ipsp;
			RTFREE(re.re_rt);

			/* Verify that the entry is identical */
			if (bcmp(&ipo->ipo_addr, &encapdst,
				sizeof(struct sockaddr_encap)) ||
			    bcmp(&ipo->ipo_mask, &encapnetmask,
				sizeof(struct sockaddr_encap)))
				ipo = NULL; /* Fall through */
			else
				exists = 1;
		} else
			ipo = NULL;

		/*
		 * If the existing policy is static, only delete or update
		 * it if the new one is also static.
		 */
		if (exists && (ipo->ipo_flags & IPSP_POLICY_STATIC)) {
			if (!(sab->sadb_protocol_flags &
				SADB_X_POLICYFLAGS_POLICY)) {
				splx(s);
				goto ret;
			}
d1537 25
a1561 46
		/* Delete ? */
		if (delflag) {
			if (exists) {
				rval = ipsec_delete_policy(ipo);
				splx(s);
				goto ret;
			}

			/* If we were asked to delete something non-existant, error. */
			splx(s);
			rval = ESRCH;
			break;
		}

		if (!exists) {
			if (ipsec_policy_pool_initialized == 0) {
				ipsec_policy_pool_initialized = 1;
				pool_init(&ipsec_policy_pool,
				    sizeof(struct ipsec_policy), 0, 0, 0,
				    "ipsec policy", NULL);
			}

			/* Allocate policy entry */
			ipo = pool_get(&ipsec_policy_pool, 0);
			if (ipo == NULL) {
				splx(s);
				rval = ENOMEM;
				goto ret;
			}

			bzero(ipo, sizeof(struct ipsec_policy));
			ipo->ipo_ref_count = 1;
			TAILQ_INIT(&ipo->ipo_acquires);

			/* Finish initialization of SPD entry */
			encapgw.sen_len = SENT_LEN;
			encapgw.sen_family = PF_KEY;
			encapgw.sen_type = SENT_IPSP;
			encapgw.sen_ipsp = ipo;

			/* Initialize policy entry */
			bcopy(&encapdst, &ipo->ipo_addr,
			    sizeof(struct sockaddr_encap));
			bcopy(&encapnetmask, &ipo->ipo_mask,
			    sizeof(struct sockaddr_encap));
		}
d1563 2
a1564 1
		switch (((struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE])->sadb_protocol_proto) {
d1566 2
a1567 2
			ipo->ipo_type = IPSP_IPSEC_USE;
			break;
d1570 2
a1571 2
			ipo->ipo_type = IPSP_IPSEC_ACQUIRE;
			break;
d1574 2
a1575 2
			ipo->ipo_type = IPSP_IPSEC_REQUIRE;
			break;
d1578 2
a1579 2
			ipo->ipo_type = IPSP_DENY;
			break;
d1582 2
a1583 2
			ipo->ipo_type = IPSP_PERMIT;
			break;
d1586 2
a1587 2
			ipo->ipo_type = IPSP_IPSEC_DONTACQ;
			break;
d1590 126
a1715 9
			if (!exists)
				pool_put(&ipsec_policy_pool, ipo);
			else
				ipsec_delete_policy(ipo);

			splx(s);
			rval = EINVAL;
			goto ret;
		}
d1717 4
a1720 2
		if (sab->sadb_protocol_flags & SADB_X_POLICYFLAGS_POLICY)
			ipo->ipo_flags |= IPSP_POLICY_STATIC;
d1722 2
a1723 5
		if (sunionp)
			bcopy(sunionp, &ipo->ipo_dst,
			    sizeof(union sockaddr_union));
		else
			bzero(&ipo->ipo_dst, sizeof(union sockaddr_union));
d1725 5
a1729 5
		if (ssrc)
			bcopy(ssrc, &ipo->ipo_src,
			    sizeof(union sockaddr_union));
		else
			bzero(&ipo->ipo_src, sizeof(union sockaddr_union));
d1731 8
a1738 5
		ipo->ipo_sproto = SADB_X_GETSPROTO(smsg->sadb_msg_satype);

		if (ipo->ipo_srcid) {
			ipsp_reffree(ipo->ipo_srcid);
			ipo->ipo_srcid = NULL;
d1741 3
a1743 4
		if (ipo->ipo_dstid) {
			ipsp_reffree(ipo->ipo_dstid);
			ipo->ipo_dstid = NULL;
		}
d1745 12
a1756 20
		if ((sid = headers[SADB_EXT_IDENTITY_SRC]) != NULL) {
			int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
			    sizeof(struct sadb_ident);

			MALLOC(ipo->ipo_srcid, struct ipsec_ref *, clen +
			    sizeof(struct ipsec_ref), M_CREDENTIALS, M_DONTWAIT);
			if (ipo->ipo_srcid == NULL) {
				if (exists)
					ipsec_delete_policy(ipo);
				else
					pool_put(&ipsec_policy_pool, ipo);
				splx(s);
				rval = ENOBUFS;
				goto ret;
			}
			ipo->ipo_srcid->ref_type = sid->sadb_ident_type;
			ipo->ipo_srcid->ref_len = clen;
			ipo->ipo_srcid->ref_count = 1;
			ipo->ipo_srcid->ref_malloctype = M_CREDENTIALS;
			bcopy(sid + 1, ipo->ipo_srcid + 1, ipo->ipo_srcid->ref_len);
d1758 1
d1760 1
a1760 27
		if ((sid = headers[SADB_EXT_IDENTITY_DST]) != NULL) {
			int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
			    sizeof(struct sadb_ident);

			MALLOC(ipo->ipo_dstid, struct ipsec_ref *,
			    clen + sizeof(struct ipsec_ref),
			    M_CREDENTIALS, M_DONTWAIT);
			if (ipo->ipo_dstid == NULL) {
				if (exists)
					ipsec_delete_policy(ipo);
				else {
					if (ipo->ipo_dstid)
						ipsp_reffree(ipo->ipo_dstid);
					pool_put(&ipsec_policy_pool, ipo);
				}

				splx(s);
				rval = ENOBUFS;
				goto ret;
			}
			ipo->ipo_dstid->ref_type = sid->sadb_ident_type;
			ipo->ipo_dstid->ref_len = clen;
			ipo->ipo_dstid->ref_count = 1;
			ipo->ipo_dstid->ref_malloctype = M_CREDENTIALS;
			bcopy(sid + 1, ipo->ipo_dstid + 1,
			    ipo->ipo_dstid->ref_len);
		}
d1762 4
a1765 29
		/* Flow type */
		if (!exists) {
			/* Add SPD entry */
			if ((rval = rtrequest(RTM_ADD,
				 (struct sockaddr *) &encapdst,
				 (struct sockaddr *) &encapgw,
				 (struct sockaddr *) &encapnetmask,
				 RTF_UP | RTF_GATEWAY | RTF_STATIC,
				 (struct rtentry **) 0)) != 0) {
				/* Remove from linked list of policies on TDB */
				if (ipo->ipo_tdb)
					TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head,
					    ipo, ipo_tdb_next);

				if (ipo->ipo_srcid)
					ipsp_reffree(ipo->ipo_srcid);
				if (ipo->ipo_dstid)
					ipsp_reffree(ipo->ipo_dstid);
				pool_put(&ipsec_policy_pool, ipo);

				splx(s);
				goto ret;
			}

			TAILQ_INSERT_HEAD(&ipsec_policy_head, ipo, ipo_list);
			ipsec_in_use++;
		} else {
			ipo->ipo_last_searched = ipo->ipo_flags = 0;
		}
d1767 5
a1771 3
		splx(s);
	}
	break;
d1773 2
a1774 3
	case SADB_X_PROMISC:
		if (len >= 2 * sizeof(struct sadb_msg)) {
			struct mbuf *packet;
d1776 5
a1780 2
			if ((rval = pfdatatopacket(message, len, &packet)) != 0)
				goto ret;
d1782 3
a1784 30
			for (so = pfkeyv2_sockets; so; so = so->next)
				if ((so != pfkeyv2_socket) &&
				    (!smsg->sadb_msg_seq ||
				    (smsg->sadb_msg_seq == pfkeyv2_socket->pid)))
					pfkey_sendup(so->socket, packet, 1);

			m_freem(packet);
		} else {
			if (len != sizeof(struct sadb_msg)) {
				rval = EINVAL;
				goto ret;
			}

			i = (pfkeyv2_socket->flags &
			    PFKEYV2_SOCKETFLAGS_PROMISC) ? 1 : 0;
			j = smsg->sadb_msg_satype ? 1 : 0;

			if (i ^ j) {
				if (j) {
					pfkeyv2_socket->flags |=
					    PFKEYV2_SOCKETFLAGS_PROMISC;
					npromisc++;
				}
			} else {
				pfkeyv2_socket->flags &=
				    ~PFKEYV2_SOCKETFLAGS_PROMISC;
				npromisc--;
			}
		}
	
d1786 2
a1787 1
		break;
d1789 4
a1792 4
	default:
		rval = EINVAL;
		goto ret;
	}
d1794 1
a1794 26
ret:
	if (rval) {
		if ((rval == EINVAL) || (rval == ENOMEM) || (rval == ENOBUFS))
			goto realret;

		for (i = 1; i <= SADB_EXT_MAX; i++)
			headers[i] = NULL;

		smsg->sadb_msg_errno = abs(rval);
	} else {
		uint32_t seen = 0;

		for (i = 1; i <= SADB_EXT_MAX; i++)
			if (headers[i])
				seen |= (1 << i);

		if ((seen & sadb_exts_allowed_out[smsg->sadb_msg_type])
		    != seen)
			goto realret;

		if ((seen & sadb_exts_required_out[smsg->sadb_msg_type]) !=
		    sadb_exts_required_out[smsg->sadb_msg_type])
			goto realret;
	}

	rval = pfkeyv2_sendmessage(headers, mode, socket, 0, 0);
d1797 2
a1798 2
	if (freeme)
		free(freeme, M_PFKEY);
d1800 1
a1800 1
	free(message, M_PFKEY);
d1802 1
a1802 1
	return (rval);
d1805 2
a1806 2
	splx(s);
	goto ret;
d1817 17
a1833 9
	void *p, *headers[SADB_EXT_MAX + 1], *buffer = NULL;
	struct sadb_ident *srcid, *dstid;
	struct sadb_x_cred *lcred, *lauth;
	struct sadb_comb *sadb_comb;
	struct sadb_address *sadd;
	struct sadb_prop *sa_prop;
	struct sadb_msg *smsg;
	int rval = 0;
	int i, j;
d1835 20
a1854 1
	*seq = pfkeyv2_seq++;
d1856 1
a1856 4
	if (!nregistered) {
		rval = ESRCH;
		goto ret;
	}
d1858 2
a1859 12
	/* How large a buffer do we need... XXX we only do one proposal for now */
	i = sizeof(struct sadb_msg) +
	    (laddr == NULL ? 0 : sizeof(struct sadb_address) +
		PADUP(SA_LEN(&ipo->ipo_src.sa))) +
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa)) +
	    sizeof(struct sadb_prop) + 1 * sizeof(struct sadb_comb);

	if (ipo->ipo_srcid)
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);

	if (ipo->ipo_dstid)
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
d1861 121
d1983 2
a1984 19
	/* Allocate */
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	}

	bzero(headers, sizeof(headers));

	buffer = p;
	bzero(p, i);

	headers[0] = p;
	p += sizeof(struct sadb_msg);

	smsg = (struct sadb_msg *) headers[0];
	smsg->sadb_msg_version = PF_KEY_V2;
	smsg->sadb_msg_type = SADB_ACQUIRE;
	smsg->sadb_msg_len = i / sizeof(uint64_t);
	smsg->sadb_msg_seq = *seq;
d1986 1
d1988 20
a2007 60
		smsg->sadb_msg_satype = SADB_SATYPE_ESP;
	else if (ipo->ipo_sproto == IPPROTO_AH)
		smsg->sadb_msg_satype = SADB_SATYPE_AH;
	else if (ipo->ipo_sproto == IPPROTO_IPCOMP)
		smsg->sadb_msg_satype = SADB_X_SATYPE_IPCOMP;

	if (laddr) {
		headers[SADB_EXT_ADDRESS_SRC] = p;
		p += sizeof(struct sadb_address) + PADUP(SA_LEN(&laddr->sa));
		sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_SRC];
		sadd->sadb_address_len = (sizeof(struct sadb_address) +
		    SA_LEN(&laddr->sa) + sizeof(uint64_t) - 1) /
		    sizeof(uint64_t);
		bcopy(laddr, headers[SADB_EXT_ADDRESS_SRC] +
		    sizeof(struct sadb_address), SA_LEN(&laddr->sa));
	}

	headers[SADB_EXT_ADDRESS_DST] = p;
	p += sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa));
	sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_DST];
	sadd->sadb_address_len = (sizeof(struct sadb_address) +
	    SA_LEN(&gw->sa) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
	bcopy(gw, headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address),
	    SA_LEN(&gw->sa));

	if (ipo->ipo_srcid) {
		headers[SADB_EXT_IDENTITY_SRC] = p;
		p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
		srcid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_SRC];
		srcid->sadb_ident_len = (sizeof(struct sadb_ident) +
		    PADUP(ipo->ipo_srcid->ref_len)) / sizeof(u_int64_t);
		srcid->sadb_ident_type = ipo->ipo_srcid->ref_type;
		bcopy(ipo->ipo_srcid + 1, headers[SADB_EXT_IDENTITY_SRC] +
		    sizeof(struct sadb_ident), ipo->ipo_srcid->ref_len);
	}

	if (ipo->ipo_dstid) {
		headers[SADB_EXT_IDENTITY_DST] = p;
		p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
		dstid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_DST];
		dstid->sadb_ident_len = (sizeof(struct sadb_ident) +
		    PADUP(ipo->ipo_dstid->ref_len)) / sizeof(u_int64_t);
		dstid->sadb_ident_type = ipo->ipo_dstid->ref_type;
		bcopy(ipo->ipo_dstid + 1, headers[SADB_EXT_IDENTITY_DST] +
		    sizeof(struct sadb_ident), ipo->ipo_dstid->ref_len);
	}

	if (ipo->ipo_local_cred) {
		headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
		p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);
		lcred = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_CREDENTIALS];
		lcred->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
		    PADUP(ipo->ipo_local_cred->ref_len)) / sizeof(u_int64_t);
		switch (ipo->ipo_local_cred->ref_type) {
		case IPSP_CRED_KEYNOTE:
			lcred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
			break;
		case IPSP_CRED_X509:
			lcred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
			break;
d2009 24
a2032 2
		bcopy(ipo->ipo_local_cred + 1, headers[SADB_X_EXT_LOCAL_CREDENTIALS] +
		    sizeof(struct sadb_x_cred), ipo->ipo_local_cred->ref_len);
d2035 10
a2044 14
	if (ipo->ipo_local_auth) {
		headers[SADB_X_EXT_LOCAL_AUTH] = p;
		p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);
		lauth = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_AUTH];
		lauth->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
		    PADUP(ipo->ipo_local_auth->ref_len)) / sizeof(u_int64_t);
		switch (ipo->ipo_local_auth->ref_type) {
		case IPSP_AUTH_PASSPHRASE:
			lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_PASSPHRASE;
			break;
		case IPSP_AUTH_RSA:
			lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
			break;
		}
d2046 6
a2051 99
		bcopy(ipo->ipo_local_auth + 1, headers[SADB_X_EXT_LOCAL_AUTH] +
		    sizeof(struct sadb_x_cred), ipo->ipo_local_auth->ref_len);
	}

	headers[SADB_EXT_PROPOSAL] = p;
	p += sizeof(struct sadb_prop);
	sa_prop = (struct sadb_prop *) headers[SADB_EXT_PROPOSAL];
	sa_prop->sadb_prop_num = 1; /* XXX One proposal only */
	sa_prop->sadb_prop_len = (sizeof(struct sadb_prop) +
	    (sizeof(struct sadb_comb) * sa_prop->sadb_prop_num)) /
	    sizeof(uint64_t);

	sadb_comb = p;

	/* XXX Should actually ask the crypto layer what's supported */
	for (j = 0; j < sa_prop->sadb_prop_num; j++) {
		sadb_comb->sadb_comb_flags = 0;

		if (ipsec_require_pfs)
			sadb_comb->sadb_comb_flags |= SADB_SAFLAGS_PFS;

		/* Set the encryption algorithm */
		if (ipo->ipo_sproto == IPPROTO_ESP) {
			if (!strncasecmp(ipsec_def_enc, "aes",
			    sizeof("aes"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_AES;
				sadb_comb->sadb_comb_encrypt_minbits = 64;
				sadb_comb->sadb_comb_encrypt_maxbits = 256;
			} else if (!strncasecmp(ipsec_def_enc, "3des",
			    sizeof("3des"))) {
				sadb_comb->sadb_comb_encrypt = SADB_EALG_3DESCBC;
				sadb_comb->sadb_comb_encrypt_minbits = 192;
				sadb_comb->sadb_comb_encrypt_maxbits = 192;
			} else if (!strncasecmp(ipsec_def_enc, "des",
			    sizeof("des"))) {
				sadb_comb->sadb_comb_encrypt = SADB_EALG_DESCBC;
				sadb_comb->sadb_comb_encrypt_minbits = 64;
				sadb_comb->sadb_comb_encrypt_maxbits = 64;
			} else if (!strncasecmp(ipsec_def_enc, "blowfish",
			    sizeof("blowfish"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
				sadb_comb->sadb_comb_encrypt_minbits = 40;
				sadb_comb->sadb_comb_encrypt_maxbits = BLF_MAXKEYLEN * 8;
			} else if (!strncasecmp(ipsec_def_enc, "skipjack",
			    sizeof("skipjack"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_SKIPJACK;
				sadb_comb->sadb_comb_encrypt_minbits = 80;
				sadb_comb->sadb_comb_encrypt_maxbits = 80;
			} else if (!strncasecmp(ipsec_def_enc, "cast128",
			    sizeof("cast128"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
				sadb_comb->sadb_comb_encrypt_minbits = 40;
				sadb_comb->sadb_comb_encrypt_maxbits = 128;
			}
		} else if (ipo->ipo_sproto == IPPROTO_IPCOMP) {
			/* Set the compression algorithm */
			if (!strncasecmp(ipsec_def_comp, "deflate",
			    sizeof("deflate"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_CALG_DEFLATE;
				sadb_comb->sadb_comb_encrypt_minbits = 0;
				sadb_comb->sadb_comb_encrypt_maxbits = 0;
			} else if (!strncasecmp(ipsec_def_comp, "lzs",
			    sizeof("lzs"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_CALG_LZS;
				sadb_comb->sadb_comb_encrypt_minbits = 0;
				sadb_comb->sadb_comb_encrypt_maxbits = 0;
			}
		}

		/* Set the authentication algorithm */
		if (!strncasecmp(ipsec_def_auth, "hmac-sha1",
		    sizeof("hmac-sha1"))) {
			sadb_comb->sadb_comb_auth = SADB_AALG_SHA1HMAC;
			sadb_comb->sadb_comb_auth_minbits = 160;
			sadb_comb->sadb_comb_auth_maxbits = 160;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
		    sizeof("hmac_ripemd160"))) {
			sadb_comb->sadb_comb_auth = SADB_AALG_RIPEMD160HMAC;
			sadb_comb->sadb_comb_auth_minbits = 160;
			sadb_comb->sadb_comb_auth_maxbits = 160;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-md5",
		    sizeof("hmac-md5"))) {
			sadb_comb->sadb_comb_auth = SADB_AALG_MD5HMAC;
			sadb_comb->sadb_comb_auth_minbits = 128;
			sadb_comb->sadb_comb_auth_maxbits = 128;
		}

		sadb_comb->sadb_comb_soft_allocations = ipsec_soft_allocations;
		sadb_comb->sadb_comb_hard_allocations = ipsec_exp_allocations;

		sadb_comb->sadb_comb_soft_bytes = ipsec_soft_bytes;
		sadb_comb->sadb_comb_hard_bytes = ipsec_exp_bytes;

		sadb_comb->sadb_comb_soft_addtime = ipsec_soft_timeout;
		sadb_comb->sadb_comb_hard_addtime = ipsec_exp_timeout;

		sadb_comb->sadb_comb_soft_usetime = ipsec_soft_first_use;
		sadb_comb->sadb_comb_hard_usetime = ipsec_exp_first_use;
		sadb_comb++;
d2053 29
d2084 3
a2086 4
	if ((rval = pfkeyv2_sendmessage(headers,
	    PFKEYV2_SENDMESSAGE_REGISTERED, NULL, smsg->sadb_msg_satype, 0))
	    != 0)
		goto ret;
d2088 1
a2088 1
	rval = 0;
d2090 5
a2094 4
	if (buffer != NULL) {
		bzero(buffer, i);
		free(buffer, M_PFKEY);
	}
d2096 1
a2096 1
	return (rval);
d2106 4
a2109 4
	void *p, *headers[SADB_EXT_MAX+1], *buffer = NULL;
	struct sadb_msg *smsg;
	int rval = 0;
	int i;
d2111 2
a2112 1
	switch (sa->tdb_sproto) {
d2120 1
a2120 1
		break;
d2123 16
a2138 3
		rval = EOPNOTSUPP;
		goto ret;
	}
d2140 2
a2141 4
	i = sizeof(struct sadb_msg) + sizeof(struct sadb_sa) +
	    2 * sizeof(struct sadb_lifetime) +
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa)) +
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
d2143 2
a2144 4
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	}
d2146 6
a2151 1
	bzero(headers, sizeof(headers));
d2153 2
a2154 2
	buffer = p;
	bzero(p, i);
d2156 2
a2157 2
	headers[0] = p;
	p += sizeof(struct sadb_msg);
d2159 4
a2162 17
	smsg = (struct sadb_msg *) headers[0];
	smsg->sadb_msg_version = PF_KEY_V2;
	smsg->sadb_msg_type = SADB_EXPIRE;
	smsg->sadb_msg_satype = sa->tdb_satype;
	smsg->sadb_msg_len = i / sizeof(uint64_t);
	smsg->sadb_msg_seq = pfkeyv2_seq++;

	headers[SADB_EXT_SA] = p;
	export_sa(&p, sa);

	headers[SADB_EXT_LIFETIME_CURRENT] = p;
	export_lifetime(&p, sa, 2);

	headers[type] = p;
	type = (SADB_EXT_LIFETIME_SOFT ? PFKEYV2_LIFETIME_SOFT :
	    PFKEYV2_LIFETIME_HARD);
	export_lifetime(&p, sa, type);
d2164 2
a2165 2
	headers[SADB_EXT_ADDRESS_SRC] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_src);
d2167 2
a2168 2
	headers[SADB_EXT_ADDRESS_DST] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_dst);
d2170 3
a2172 3
	if ((rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_BROADCAST,
	    NULL, 0, 0)) != 0)
		goto ret;
d2174 1
a2174 1
	rval = 0;
d2176 6
a2181 5
 ret:
	if (buffer != NULL) {
		bzero(buffer, i);
		free(buffer, M_PFKEY);
	}
d2183 1
a2183 1
	return (rval);
d2189 1
a2189 1
	int rval;
d2191 5
a2195 5
	bzero(&pfkeyv2_version, sizeof(struct pfkey_version));
	pfkeyv2_version.protocol = PFKEYV2_PROTOCOL;
	pfkeyv2_version.create = &pfkeyv2_create;
	pfkeyv2_version.release = &pfkeyv2_release;
	pfkeyv2_version.send = &pfkeyv2_send;
d2197 2
a2198 2
	rval = pfkey_register(&pfkeyv2_version);
	return (rval);
d2204 2
a2205 2
	pfkey_unregister(&pfkeyv2_version);
	return (0);
@


1.76
log
@Only flush the policies if the message type is UNSPEC.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.75 2001/07/06 13:31:07 ho Exp $ */
a1265 8
	    if (smsg->sadb_msg_satype == SADB_SATYPE_UNSPEC)
	    {
		s = spltdb();
		while ((ipo = TAILQ_FIRST(&ipsec_policy_head)) != NULL)
		  ipsec_delete_policy(ipo);
		splx(s);
	    }

d1269 5
@


1.75
log
@Indentation.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.74 2001/07/05 16:48:03 jjbg Exp $ */
d1266 7
a1272 4
            s = spltdb();
            while ((ipo = TAILQ_FIRST(&ipsec_policy_head)) != NULL)
              ipsec_delete_policy(ipo);
            splx(s);
@


1.74
log
@IPComp. angelos@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.73 2001/06/27 05:29:10 angelos Exp $ */
d752 3
a754 3
	    case SADB_X_SATYPE_IPCOMP:
		if (!ipcomp_enable)
		    return EOPNOTSUPP;
d756 1
a756 1
		*sproto = IPPROTO_IPCOMP;
d758 2
a759 2
		if(alg != NULL)
		    *alg = satype = XF_IPCOMP;
d761 1
a761 1
		break;
d1277 1
a1277 1
	    case SADB_X_SATYPE_IPCOMP:
d2094 1
a2094 1
    case IPPROTO_IPCOMP:
@


1.73
log
@Don't bzero() after doing a TAILQ_INIT()...
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.72 2001/06/27 04:39:30 angelos Exp $ */
d83 1
d113 5
d752 11
d1234 21
d1277 1
d1893 1
a1893 1
    else
d1895 2
d2013 11
d2094 1
@


1.72
log
@Initialize acquire state list in newly allocated policy.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.71 2001/06/27 01:34:06 angelos Exp $ */
d1520 1
a1521 2

		bzero(ipo, sizeof(struct ipsec_policy));
@


1.71
log
@Don't cache packets that hit policies -- we'll do that at the PCB for
local packets.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.70 2001/06/26 18:56:31 angelos Exp $ */
d1519 2
@


1.70
log
@Use pool(9) for IPsec policy structures.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.69 2001/06/26 18:34:41 angelos Exp $ */
d872 1
a872 1
				     sa.tdb_sproto, &rval, smsg->sadb_msg_seq);
d964 2
d1089 2
@


1.69
log
@Keep the PFKEY sequence number at the TDB, plus a little bit of KNF
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.68 2001/06/08 21:29:58 angelos Exp $ */
d115 2
d1499 8
d1508 1
a1508 2
		MALLOC(ipo, struct ipsec_policy *, sizeof(struct ipsec_policy),
		       M_IPSEC_POLICY, M_NOWAIT);
d1559 1
a1559 1
		      FREE(ipo, M_IPSEC_POLICY);
d1619 1
a1619 1
		      FREE(ipo, M_IPSEC_POLICY);
d1648 1
a1648 1
			FREE(ipo, M_IPSEC_POLICY);
d1678 1
a1678 1
		    FREE(ipo, M_IPSEC_POLICY); /* Free policy entry */
@


1.68
log
@Only delete/modify flows with the IPSP_POLICY_STATIC flag if the appropriate
flag is set in the protocol message.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.67 2001/06/08 02:56:47 angelos Exp $ */
d870 1
a870 1
				     sa.tdb_sproto, &rval);
@


1.67
log
@Trim some unnecessary includes.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.66 2001/06/08 02:53:49 angelos Exp $ */
d1328 1
a1330 1
	    u_int8_t direction;
d1333 4
a1336 3
	    direction = (((struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE])->sadb_protocol_direction);
            if ((direction != IPSP_DIRECTION_IN) &&
                (direction != IPSP_DIRECTION_OUT))
d1402 1
a1402 1
		    encapdst.sen_direction = direction;
d1423 1
a1423 1
		    encapdst.sen_ip6_direction = direction;
d1445 3
a1448 1

d1466 13
a1483 1
		    s = spltdb();
d1490 1
d1502 1
d1552 1
a1552 5
		    {
			s = spltdb();
			ipsec_delete_policy(ipo);
			splx(s);
		    }
d1554 1
d1559 3
d1595 3
a1597 1
	        int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) - sizeof(struct sadb_ident);
d1608 1
a1608 5
		    {
			s = spltdb();
			ipsec_delete_policy(ipo);
			splx(s);
		    }
d1611 1
d1621 2
a1622 1
	        int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) - sizeof(struct sadb_ident);
d1634 1
a1634 5
		    {
			s = spltdb();
			ipsec_delete_policy(ipo);
			splx(s);
		    }
d1642 1
d1662 2
a1663 6
		    {
			s = spltdb();
			TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
				     ipo_tdb_next);
			splx(s);
		    }
d1670 2
a1674 1
		s = spltdb();
a1675 2
		splx(s);

d1682 3
a1684 1
         }
@


1.66
log
@Fork out some of the code in pfkeyv2.c to pfkeyv2_convert.c, to make
the former more managable/readable (an almost impossible task).
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.65 2001/06/07 05:27:52 angelos Exp $ */
a76 2
#include <sys/malloc.h>
#include <sys/socketvar.h>
a78 1
#include <netinet/in.h>
a83 2
#include <crypto/crypto.h>
#include <crypto/xform.h>
@


1.65
log
@On a pfkeyv2_get(), allocate enough room for the extra stuff we store
in the SA.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.64 2001/06/05 02:31:34 deraadt Exp $ */
a116 28
void export_address(void **, struct sockaddr *);
void export_identity(void **, struct tdb *, int);
void export_lifetime(void **, struct tdb *, int);
void export_credentials(void **, struct tdb *, int);
void export_sa(void **, struct tdb *);
void export_key(void **, struct tdb *, int);
void export_auth(void **, struct tdb *, int);

void import_auth(struct tdb *, struct sadb_x_cred *, int);
void import_address(struct sockaddr *, struct sadb_address *);
void import_identity(struct tdb *, struct sadb_ident *, int);
void import_key(struct ipsecinit *, struct sadb_key *, int);
void import_lifetime(struct tdb *, struct sadb_lifetime *, int);
void import_credentials(struct tdb *, struct sadb_x_cred *, int);
void import_sa(struct tdb *, struct sadb_sa *, struct ipsecinit *);

int pfkeyv2_create(struct socket *);
int pfkeyv2_get(struct tdb *, void **, void **);
int pfkeyv2_policy(struct ipsec_acquire *, void **, void **);
int pfkeyv2_release(struct socket *);
int pfkeyv2_send(struct socket *, void *, int);
int pfkeyv2_sendmessage(void **, int, struct socket *, u_int8_t, int);
int pfkeyv2_dump_walker(struct tdb *, void *, int);
int pfkeyv2_flush_walker(struct tdb *, void *, int);
int pfkeyv2_get_proto_alg(u_int8_t, u_int8_t *, int *);

int pfdatatopacket(void *, int, struct mbuf **);

a119 3
#define EXTLEN(x) (((struct sadb_ext *)(x))->sadb_ext_len * sizeof(uint64_t))
#define PADUP(x) (((x) + sizeof(uint64_t) - 1) & ~(sizeof(uint64_t) - 1))

a184 579
}

/*
 * (Partly) Initialize a TDB based on an SADB_SA payload. Other parts
 * of the TDB will be initialized by other import routines, and tdb_init().
 */
void
import_sa(struct tdb *tdb, struct sadb_sa *sadb_sa, struct ipsecinit *ii)
{
    if (!sadb_sa)
      return;

    if (ii)
    {
	ii->ii_encalg = sadb_sa->sadb_sa_encrypt;
	ii->ii_authalg = sadb_sa->sadb_sa_auth;

	tdb->tdb_spi = sadb_sa->sadb_sa_spi;
	tdb->tdb_wnd = sadb_sa->sadb_sa_replay;

	if (sadb_sa->sadb_sa_flags & SADB_SAFLAGS_PFS)
	  tdb->tdb_flags |= TDBF_PFS;

	if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_HALFIV)
	  tdb->tdb_flags |= TDBF_HALFIV;

	if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_TUNNEL)
	  tdb->tdb_flags |= TDBF_TUNNELING;

	if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_RANDOMPADDING)
	  tdb->tdb_flags |= TDBF_RANDOMPADDING;

	if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_NOREPLAY)
	  tdb->tdb_flags |= TDBF_NOREPLAY;
    }

    if (sadb_sa->sadb_sa_state != SADB_SASTATE_MATURE)
      tdb->tdb_flags |= TDBF_INVALID;
}

/*
 * Export some of the information on a TDB.
 */
void
export_sa(void **p, struct tdb *tdb)
{
    struct sadb_sa *sadb_sa = (struct sadb_sa *) *p;

    sadb_sa->sadb_sa_len = sizeof(struct sadb_sa) / sizeof(uint64_t);

    sadb_sa->sadb_sa_spi = tdb->tdb_spi;
    sadb_sa->sadb_sa_replay = tdb->tdb_wnd;

    if (tdb->tdb_flags & TDBF_INVALID)
      sadb_sa->sadb_sa_state = SADB_SASTATE_LARVAL;

    if (tdb->tdb_authalgxform)
    {
	switch (tdb->tdb_authalgxform->type)
	{
	    case CRYPTO_MD5_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_MD5HMAC;
		break;

	    case CRYPTO_SHA1_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_SHA1HMAC;
		break;

	    case CRYPTO_RIPEMD160_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
		break;

	    case CRYPTO_MD5_KPDK:
		sadb_sa->sadb_sa_auth = SADB_X_AALG_MD5;
		break;

	    case CRYPTO_SHA1_KPDK:
		sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA1;
		break;
	}
    }

    if (tdb->tdb_encalgxform)
    {
	switch (tdb->tdb_encalgxform->type)
	{
	    case CRYPTO_DES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_EALG_DESCBC;
		break;

	    case CRYPTO_3DES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_EALG_3DESCBC;
		break;

	    case CRYPTO_AES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_AES;
		break;

	    case CRYPTO_CAST_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_CAST;
		break;

	    case CRYPTO_BLF_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_BLF;
		break;

	    case CRYPTO_SKIPJACK_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_SKIPJACK;
		break;
	}
    }

    if (tdb->tdb_flags & TDBF_PFS)
      sadb_sa->sadb_sa_flags |= SADB_SAFLAGS_PFS;

    /* Only relevant for the "old" IPsec transforms */
    if (tdb->tdb_flags & TDBF_HALFIV)
      sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;

    if (tdb->tdb_flags & TDBF_TUNNELING)
      sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;

    if (tdb->tdb_flags & TDBF_RANDOMPADDING)
      sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_RANDOMPADDING;

    if (tdb->tdb_flags & TDBF_NOREPLAY)
      sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;

    *p += sizeof(struct sadb_sa);
}

/*
 * Initialize expirations and counters based on lifetime payload.
 */
void
import_lifetime(struct tdb *tdb, struct sadb_lifetime *sadb_lifetime, int type)
{
    if (!sadb_lifetime)
      return;

    switch (type)
    {
	case PFKEYV2_LIFETIME_HARD:
	    if ((tdb->tdb_exp_allocations =
		 sadb_lifetime->sadb_lifetime_allocations) != 0)
	      tdb->tdb_flags |= TDBF_ALLOCATIONS;
	    else
	      tdb->tdb_flags &= ~TDBF_ALLOCATIONS;

	    if ((tdb->tdb_exp_bytes = sadb_lifetime->sadb_lifetime_bytes) != 0)
	      tdb->tdb_flags |= TDBF_BYTES;
	    else
	      tdb->tdb_flags &= ~TDBF_BYTES;

	    if ((tdb->tdb_exp_timeout =
		 sadb_lifetime->sadb_lifetime_addtime) != 0)
	    {
		tdb->tdb_flags |= TDBF_TIMER;
		timeout_add(&tdb->tdb_timer_tmo, hz * tdb->tdb_exp_timeout);
	    } else
	        tdb->tdb_flags &= ~TDBF_TIMER;

	    if ((tdb->tdb_exp_first_use =
		 sadb_lifetime->sadb_lifetime_usetime) != 0)
	    {
	        tdb->tdb_flags |= TDBF_FIRSTUSE;
	        timeout_add(&tdb->tdb_first_tmo, hz * tdb->tdb_exp_first_use);
	    }
	    else
	        tdb->tdb_flags &= ~TDBF_FIRSTUSE;
	    break;

	case PFKEYV2_LIFETIME_SOFT:
	    if ((tdb->tdb_soft_allocations =
		 sadb_lifetime->sadb_lifetime_allocations) != 0)
	      tdb->tdb_flags |= TDBF_SOFT_ALLOCATIONS;
	    else
	      tdb->tdb_flags &= ~TDBF_SOFT_ALLOCATIONS;

	    if ((tdb->tdb_soft_bytes =
		 sadb_lifetime->sadb_lifetime_bytes) != 0)
	      tdb->tdb_flags |= TDBF_SOFT_BYTES;
	    else
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;

	    if ((tdb->tdb_soft_timeout =
		 sadb_lifetime->sadb_lifetime_addtime) != 0)
	    {
		tdb->tdb_flags |= TDBF_SOFT_TIMER;
		timeout_add(&tdb->tdb_stimer_tmo, hz * tdb->tdb_soft_timeout);
	    }
	    else
	      tdb->tdb_flags &= ~TDBF_SOFT_TIMER;

	    if ((tdb->tdb_soft_first_use =
		 sadb_lifetime->sadb_lifetime_usetime) != 0)
	    {
	        tdb->tdb_flags |= TDBF_SOFT_FIRSTUSE;
	        timeout_add(&tdb->tdb_sfirst_tmo, hz * tdb->tdb_soft_first_use);
	    }
	    else
	        tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
	    break;

	case PFKEYV2_LIFETIME_CURRENT:  /* Nothing fancy here */
	    tdb->tdb_cur_allocations =
				      sadb_lifetime->sadb_lifetime_allocations;
	    tdb->tdb_cur_bytes = sadb_lifetime->sadb_lifetime_bytes;
	    tdb->tdb_established = sadb_lifetime->sadb_lifetime_addtime;
	    tdb->tdb_first_use = sadb_lifetime->sadb_lifetime_usetime;
    }
}

/*
 * Export TDB expiration information.
 */
void
export_lifetime(void **p, struct tdb *tdb, int type)
{
    struct sadb_lifetime *sadb_lifetime = (struct sadb_lifetime *) *p;

    sadb_lifetime->sadb_lifetime_len = sizeof(struct sadb_lifetime) /
				       sizeof(uint64_t);

    switch (type)
    {
	case PFKEYV2_LIFETIME_HARD:
	    if (tdb->tdb_flags & TDBF_ALLOCATIONS)
	      sadb_lifetime->sadb_lifetime_allocations =
						     tdb->tdb_exp_allocations;

	    if (tdb->tdb_flags & TDBF_BYTES)
	      sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_exp_bytes;

	    if (tdb->tdb_flags & TDBF_TIMER)
	      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_exp_timeout;

	    if (tdb->tdb_flags & TDBF_FIRSTUSE)
	      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_exp_first_use;
	    break;

	case PFKEYV2_LIFETIME_SOFT:
	    if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS)
	      sadb_lifetime->sadb_lifetime_allocations =
						    tdb->tdb_soft_allocations;

	    if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	      sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_soft_bytes;

	    if (tdb->tdb_flags & TDBF_SOFT_TIMER)
	      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_soft_timeout;

	    if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
	      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_soft_first_use;
	    break;

	case PFKEYV2_LIFETIME_CURRENT:
	    sadb_lifetime->sadb_lifetime_allocations =
						      tdb->tdb_cur_allocations;
	    sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_cur_bytes;
	    sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_established;
	    sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_first_use;
	    break;
    }

    *p += sizeof(struct sadb_lifetime);
}

/*
 * Copy an SADB_ADDRESS payload to a struct sockaddr.
 */
void
import_address(struct sockaddr *sa, struct sadb_address *sadb_address)
{
    int salen;
    struct sockaddr *ssa = (struct sockaddr *)((void *) sadb_address +
					       sizeof(struct sadb_address));

    if (!sadb_address)
      return;

    if (ssa->sa_len)
      salen = ssa->sa_len;
    else
      switch(ssa->sa_family)
      {
#ifdef INET
	  case AF_INET:
	      salen = sizeof(struct sockaddr_in);
	      break;
#endif /* INET */

#if INET6
	  case AF_INET6:
	      salen = sizeof(struct sockaddr_in6);
	      break;
#endif /* INET6 */

	  default:
	      return;
    }

    bcopy(ssa, sa, salen);
    sa->sa_len = salen;
}

/*
 * Export a struct sockaddr as an SADB_ADDRESS payload.
 */
void
export_address(void **p, struct sockaddr *sa)
{
    struct sadb_address *sadb_address = (struct sadb_address *) *p;

    sadb_address->sadb_address_len = (sizeof(struct sadb_address) +
				      PADUP(SA_LEN(sa))) / sizeof(uint64_t);

    *p += sizeof(struct sadb_address);
    bcopy(sa, *p, SA_LEN(sa));
    ((struct sockaddr *) *p)->sa_family = sa->sa_family;
    *p += PADUP(SA_LEN(sa));
}

/*
 * Import authentication information into the TDB.
 */
void
import_auth(struct tdb *tdb, struct sadb_x_cred *sadb_auth, int dstauth)
{
    struct ipsec_ref **ipr;

    if (!sadb_auth)
      return;

    if (dstauth == PFKEYV2_AUTH_REMOTE)
      ipr = &tdb->tdb_remote_auth;
    else
      ipr = &tdb->tdb_local_auth;

    MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_auth) -
	   sizeof(struct sadb_x_cred) + sizeof(struct ipsec_ref),
	   M_CREDENTIALS, M_WAITOK);
    (*ipr)->ref_len = EXTLEN(sadb_auth) - sizeof(struct sadb_x_cred);
    switch (sadb_auth->sadb_x_cred_type)
    {
	case SADB_X_AUTHTYPE_PASSPHRASE:
	    (*ipr)->ref_type = IPSP_AUTH_PASSPHRASE;
	    break;
	case SADB_X_AUTHTYPE_RSA:
	    (*ipr)->ref_type = IPSP_AUTH_RSA;
	    break;
	default:
	    FREE(*ipr, M_CREDENTIALS);
	    *ipr = NULL;
	    return;
    }
    (*ipr)->ref_count = 1;
    (*ipr)->ref_malloctype = M_CREDENTIALS;
    bcopy((void *) sadb_auth + sizeof(struct sadb_x_cred),
	  (*ipr) + 1, (*ipr)->ref_len);
}

/*
 * Import a set of credentials into the TDB.
 */
void
import_credentials(struct tdb *tdb, struct sadb_x_cred *sadb_cred, int dstcred)
{
    struct ipsec_ref **ipr;

    if (!sadb_cred)
      return;

    if (dstcred == PFKEYV2_CRED_REMOTE)
      ipr = &tdb->tdb_remote_cred;
    else
      ipr = &tdb->tdb_local_cred;

    MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_cred) -
	   sizeof(struct sadb_x_cred) + sizeof(struct ipsec_ref),
	   M_CREDENTIALS, M_WAITOK);
    (*ipr)->ref_len = EXTLEN(sadb_cred) - sizeof(struct sadb_x_cred);
    switch (sadb_cred->sadb_x_cred_type)
    {
	case SADB_X_CREDTYPE_X509:
	    (*ipr)->ref_type = IPSP_CRED_X509;
	    break;
	case SADB_X_CREDTYPE_KEYNOTE:
	    (*ipr)->ref_type = IPSP_CRED_KEYNOTE;
	    break;
	default:
	    FREE(*ipr, M_CREDENTIALS);
	    *ipr = NULL;
	    return;
    }
    (*ipr)->ref_count = 1;
    (*ipr)->ref_malloctype = M_CREDENTIALS;
    bcopy((void *) sadb_cred + sizeof(struct sadb_x_cred),
	  (*ipr) + 1, (*ipr)->ref_len);
}

/*
 * Import an identity payload into the TDB.
 */
void
import_identity(struct tdb *tdb, struct sadb_ident *sadb_ident, int type)
{
    struct ipsec_ref **ipr;

    if (!sadb_ident)
      return;

    if (type == PFKEYV2_IDENTITY_SRC)
      ipr = &tdb->tdb_srcid;
    else
      ipr = &tdb->tdb_dstid;

    MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_ident) -
	   sizeof(struct sadb_ident) + sizeof(struct ipsec_ref), M_CREDENTIALS,
	   M_WAITOK);
    (*ipr)->ref_len = EXTLEN(sadb_ident) - sizeof(struct sadb_ident);
    switch (sadb_ident->sadb_ident_type)
    {
	case SADB_IDENTTYPE_PREFIX:
	    (*ipr)->ref_type = IPSP_IDENTITY_PREFIX;
	    break;
	case SADB_IDENTTYPE_FQDN:
	    (*ipr)->ref_type = IPSP_IDENTITY_FQDN;
	    break;
	case SADB_IDENTTYPE_USERFQDN:
	    (*ipr)->ref_type = IPSP_IDENTITY_USERFQDN;
	    break;
	case SADB_X_IDENTTYPE_CONNECTION:
	    (*ipr)->ref_type = IPSP_IDENTITY_CONNECTION;
	    break;
	default:
	    FREE(*ipr, M_CREDENTIALS);
	    *ipr = NULL;
	    return;
    }
    (*ipr)->ref_count = 1;
    (*ipr)->ref_malloctype = M_CREDENTIALS;
    bcopy((void *) sadb_ident + sizeof(struct sadb_ident), (*ipr) + 1,
	  (*ipr)->ref_len);
}

void
export_credentials(void **p, struct tdb *tdb, int dstcred)
{
    struct ipsec_ref **ipr;
    struct sadb_x_cred *sadb_cred = (struct sadb_x_cred *) *p;

    if (dstcred == PFKEYV2_CRED_REMOTE)
      ipr = &tdb->tdb_remote_cred;
    else
      ipr = &tdb->tdb_local_cred;

    sadb_cred->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
				  PADUP((*ipr)->ref_len)) / sizeof(uint64_t);

    switch ((*ipr)->ref_type)
    {
	case IPSP_CRED_KEYNOTE:
	    sadb_cred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
	    break;
	case IPSP_CRED_X509:
	    sadb_cred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
	    break;
    }
    *p += sizeof(struct sadb_x_cred);
    bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
    *p += PADUP((*ipr)->ref_len);
}

void
export_auth(void **p, struct tdb *tdb, int dstauth)
{
    struct ipsec_ref **ipr;
    struct sadb_x_cred *sadb_auth = (struct sadb_x_cred *) *p;

    if (dstauth == PFKEYV2_AUTH_REMOTE)
      ipr = &tdb->tdb_remote_auth;
    else
      ipr = &tdb->tdb_local_auth;

    sadb_auth->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
				  PADUP((*ipr)->ref_len)) / sizeof(uint64_t);

    switch ((*ipr)->ref_type)
    {
	case IPSP_CRED_KEYNOTE:
	    sadb_auth->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
	    break;
	case IPSP_CRED_X509:
	    sadb_auth->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
	    break;
    }
    *p += sizeof(struct sadb_x_cred);
    bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
    *p += PADUP((*ipr)->ref_len);
}

void
export_identity(void **p, struct tdb *tdb, int type)
{
    struct ipsec_ref **ipr;
    struct sadb_ident *sadb_ident = (struct sadb_ident *) *p;

    if (type == PFKEYV2_IDENTITY_SRC)
      ipr = &tdb->tdb_srcid;
    else
      ipr = &tdb->tdb_dstid;

    sadb_ident->sadb_ident_len = (sizeof(struct sadb_ident) +
				  PADUP((*ipr)->ref_len)) / sizeof(uint64_t);
    switch ((*ipr)->ref_type)
    {
	case IPSP_IDENTITY_PREFIX:
	    sadb_ident->sadb_ident_type = SADB_IDENTTYPE_PREFIX;
	    break;
	case IPSP_IDENTITY_FQDN:
	    sadb_ident->sadb_ident_type = SADB_IDENTTYPE_FQDN;
	    break;
	case IPSP_IDENTITY_USERFQDN:
	    sadb_ident->sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
	    break;
	case IPSP_IDENTITY_CONNECTION:
	    sadb_ident->sadb_ident_type = SADB_X_IDENTTYPE_CONNECTION;
	    break;
    }
    *p += sizeof(struct sadb_ident);
    bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
    *p += PADUP((*ipr)->ref_len);
}

/* ... */
void
import_key(struct ipsecinit *ii, struct sadb_key *sadb_key, int type)
{
    if (!sadb_key)
      return;

    if (type == PFKEYV2_ENCRYPTION_KEY)
    { /* Encryption key */
	ii->ii_enckeylen = sadb_key->sadb_key_bits / 8;
	ii->ii_enckey = (void *)sadb_key + sizeof(struct sadb_key);
    }
    else
    {
	ii->ii_authkeylen = sadb_key->sadb_key_bits / 8;
	ii->ii_authkey = (void *)sadb_key + sizeof(struct sadb_key);
    }
}

void
export_key(void **p, struct tdb *tdb, int type)
{
    struct sadb_key *sadb_key = (struct sadb_key *) *p;

    if (type == PFKEYV2_ENCRYPTION_KEY)
    {
	sadb_key->sadb_key_len = (sizeof(struct sadb_key) +
				  PADUP(tdb->tdb_emxkeylen)) /
				 sizeof(uint64_t);
	sadb_key->sadb_key_bits = tdb->tdb_emxkeylen * 8;
	*p += sizeof(struct sadb_key);
	bcopy(tdb->tdb_emxkey, *p, tdb->tdb_emxkeylen);
	*p += PADUP(tdb->tdb_emxkeylen);
    }
    else
    {
	sadb_key->sadb_key_len = (sizeof(struct sadb_key) +
				  PADUP(tdb->tdb_amxkeylen)) /
				 sizeof(uint64_t);
	sadb_key->sadb_key_bits = tdb->tdb_amxkeylen * 8;
	*p += sizeof(struct sadb_key);
	bcopy(tdb->tdb_amxkey, *p, tdb->tdb_amxkeylen);
	*p += PADUP(tdb->tdb_amxkeylen);
    }
@


1.64
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.63 2001/06/05 00:17:48 niklas Exp $ */
d1149 12
@


1.63
log
@Make our pfkeyv2.h more RFC2367 compliant.  Also fix some backwards
compatibility problems in isakmpd, at least 2.8 stable can compile current
isakmpd now.  angelos@@ ok
@
text
@d1 2
a2 1
/* $OpenBSD: pfkeyv2.c,v 1.62 2001/05/30 16:44:11 angelos Exp $ */
d4 38
a41 8
%%% copyright-nrl-97
This software is Copyright 1997-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
d43 27
a69 7
%%% copyright-cmetz-97
This software is Copyright 1997-1998 by Craig Metz, All Rights Reserved.
The Inner Net License Version 2 applies to this software.
You should have received a copy of the license with this software. If
you didn't get a copy, you may request one from <license@@inner.net>.

*/
@


1.62
log
@MBOX->USERFQDN, noticed by markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.61 2001/05/30 11:27:33 angelos Exp $ */
d74 1
a74 1
void import_auth(struct tdb *, struct sadb_cred *, int);
d79 1
a79 1
void import_credentials(struct tdb *, struct sadb_cred *, int);
d492 1
a492 1
import_auth(struct tdb *tdb, struct sadb_cred *sadb_auth, int dstauth)
d505 1
a505 1
	   sizeof(struct sadb_cred) + sizeof(struct ipsec_ref),
d507 2
a508 2
    (*ipr)->ref_len = EXTLEN(sadb_auth) - sizeof(struct sadb_cred);
    switch (sadb_auth->sadb_cred_type)
d510 1
a510 1
	case SADB_AUTHTYPE_PASSPHRASE:
d513 1
a513 1
	case SADB_AUTHTYPE_RSA:
d523 1
a523 1
    bcopy((void *) sadb_auth + sizeof(struct sadb_cred),
d531 1
a531 1
import_credentials(struct tdb *tdb, struct sadb_cred *sadb_cred, int dstcred)
d544 1
a544 1
	   sizeof(struct sadb_cred) + sizeof(struct ipsec_ref),
d546 2
a547 2
    (*ipr)->ref_len = EXTLEN(sadb_cred) - sizeof(struct sadb_cred);
    switch (sadb_cred->sadb_cred_type)
d549 1
a549 1
	case SADB_CREDTYPE_X509:
d552 1
a552 1
	case SADB_CREDTYPE_KEYNOTE:
d562 1
a562 1
    bcopy((void *) sadb_cred + sizeof(struct sadb_cred),
d597 1
a597 1
	case SADB_IDENTTYPE_CONNECTION:
d615 1
a615 1
    struct sadb_cred *sadb_cred = (struct sadb_cred *) *p;
d622 2
a623 2
    sadb_cred->sadb_cred_len = (sizeof(struct sadb_cred) +
				PADUP((*ipr)->ref_len)) / sizeof(uint64_t);
d628 1
a628 1
	    sadb_cred->sadb_cred_type = SADB_CREDTYPE_KEYNOTE;
d631 1
a631 1
	    sadb_cred->sadb_cred_type = SADB_CREDTYPE_X509;
d634 1
a634 1
    *p += sizeof(struct sadb_cred);
d643 1
a643 1
    struct sadb_cred *sadb_auth = (struct sadb_cred *) *p;
d650 2
a651 2
    sadb_auth->sadb_cred_len = (sizeof(struct sadb_cred) +
				PADUP((*ipr)->ref_len)) / sizeof(uint64_t);
d656 1
a656 1
	    sadb_auth->sadb_cred_type = SADB_CREDTYPE_KEYNOTE;
d659 1
a659 1
	    sadb_auth->sadb_cred_type = SADB_CREDTYPE_X509;
d662 1
a662 1
    *p += sizeof(struct sadb_cred);
d692 1
a692 1
	    sadb_ident->sadb_ident_type = SADB_IDENTTYPE_CONNECTION;
d1451 1
a1451 1
			 SADB_GETSPROTO(smsg->sadb_msg_satype));
d1568 1
a1568 1
			 SADB_GETSPROTO(smsg->sadb_msg_satype));
d1663 1
a1663 1
			 SADB_GETSPROTO(smsg->sadb_msg_satype));
d1679 1
a1679 1
	    ipa = ipsec_get_acquire(((struct sadb_policy *) headers[SADB_X_EXT_POLICY])->sadb_policy_seq);
d1699 1
a1699 1
			 SADB_GETSPROTO(smsg->sadb_msg_satype));
d1829 1
a1829 1
			  SADB_GETSPROTO(smsg->sadb_msg_satype));
d1842 1
a1842 1
			  SADB_GETSPROTO(sa_proto->sadb_protocol_proto));
d2059 1
a2059 1
		case FLOW_X_TYPE_USE:
d2063 1
a2063 1
		case FLOW_X_TYPE_ACQUIRE:
d2067 1
a2067 1
		case FLOW_X_TYPE_REQUIRE:
d2071 1
a2071 1
		case FLOW_X_TYPE_DENY:
d2075 1
a2075 1
		case FLOW_X_TYPE_BYPASS:
d2079 1
a2079 1
		case FLOW_X_TYPE_DONTACQ:
d2115 1
a2115 1
	    ipo->ipo_sproto = SADB_GETSPROTO(smsg->sadb_msg_satype);
@


1.61
log
@Import/export authentication information for SA.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.60 2001/05/21 03:02:17 angelos Exp $ */
d594 2
a595 2
	case SADB_IDENTTYPE_MBOX:
	    (*ipr)->ref_type = IPSP_IDENTITY_MBOX;
d688 2
a689 2
	case IPSP_IDENTITY_MBOX:
	    sadb_ident->sadb_ident_type = SADB_IDENTTYPE_MBOX;
@


1.60
log
@Use a reference-counted structure for IPsec IDs and credentials, so we
can cheaply keep copies of them at the PCB. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.59 2001/05/05 00:33:46 angelos Exp $ */
d72 1
d74 1
d489 39
d538 1
a538 1
    if (dstcred)
d547 13
a559 1
    (*ipr)->ref_type = sadb_cred->sadb_cred_type;
d586 19
a604 1
    (*ipr)->ref_type = sadb_ident->sadb_ident_type;
d617 1
a617 1
    if (dstcred)
d624 38
a661 1
    sadb_cred->sadb_cred_type = (*ipr)->ref_type;
d680 15
a694 1
    sadb_ident->sadb_ident_type = (*ipr)->ref_type;
d1165 1
a1165 1
	export_credentials(&p, sa, 0);
d1171 14
a1184 1
	export_credentials(&p, sa, 1);
d1501 2
a1502 1
				   headers[SADB_X_EXT_LOCAL_CREDENTIALS], 0);
d1504 6
a1509 2
				   headers[SADB_X_EXT_REMOTE_CREDENTIALS], 1);

d1512 1
d1625 2
a1626 1
				   headers[SADB_X_EXT_LOCAL_CREDENTIALS], 0);
d1628 6
a1633 2
				   headers[SADB_X_EXT_REMOTE_CREDENTIALS], 1);

d1636 1
@


1.59
log
@Use the new M_* malloc types
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.58 2001/03/28 20:03:01 angelos Exp $ */
d492 2
d498 1
a498 9
    {
	tdb->tdb_remote_cred_len = EXTLEN(sadb_cred) -
				   sizeof(struct sadb_cred);
	tdb->tdb_remote_cred_type = sadb_cred->sadb_cred_type;
	MALLOC(tdb->tdb_remote_cred, caddr_t, tdb->tdb_remote_cred_len,
	       M_CREDENTIALS, M_WAITOK);
	bcopy((void *) sadb_cred + sizeof(struct sadb_cred),
	      tdb->tdb_remote_cred, tdb->tdb_remote_cred_len);
    }
d500 11
a510 8
    {
	tdb->tdb_local_cred_len = EXTLEN(sadb_cred) - sizeof(struct sadb_cred);
	tdb->tdb_local_cred_type = sadb_cred->sadb_cred_type;
	MALLOC(tdb->tdb_local_cred, caddr_t, tdb->tdb_local_cred_len,
	       M_CREDENTIALS, M_WAITOK);
	bcopy((void *) sadb_cred + sizeof(struct sadb_cred),
	      tdb->tdb_local_cred, tdb->tdb_local_cred_len);
    }
d519 2
d525 1
a525 9
    {
	tdb->tdb_srcid_len = EXTLEN(sadb_ident) -
			     sizeof(struct sadb_ident);
	tdb->tdb_srcid_type = sadb_ident->sadb_ident_type;
	MALLOC(tdb->tdb_srcid, u_int8_t *, tdb->tdb_srcid_len, M_CREDENTIALS,
	       M_WAITOK);
	bcopy((void *) sadb_ident + sizeof(struct sadb_ident),
	      tdb->tdb_srcid, tdb->tdb_srcid_len);
    }
d527 11
a537 9
    {
	tdb->tdb_dstid_len = EXTLEN(sadb_ident) -
			     sizeof(struct sadb_ident);
	tdb->tdb_dstid_type = sadb_ident->sadb_ident_type;
	MALLOC(tdb->tdb_dstid, u_int8_t *, tdb->tdb_dstid_len, M_CREDENTIALS,
	       M_WAITOK);
	bcopy((void *) sadb_ident + sizeof(struct sadb_ident),
	      tdb->tdb_dstid, tdb->tdb_dstid_len);
    }
d543 1
d547 1
a547 9
    {
	sadb_cred->sadb_cred_len = (sizeof(struct sadb_cred) +
				    PADUP(tdb->tdb_remote_cred_len)) /
				   sizeof(uint64_t);
	sadb_cred->sadb_cred_type = tdb->tdb_remote_cred_type;
	*p += sizeof(struct sadb_cred);
	bcopy(tdb->tdb_remote_cred, *p, tdb->tdb_remote_cred_len);
	*p += PADUP(tdb->tdb_remote_cred_len);
    }
d549 8
a556 9
    {
	sadb_cred->sadb_cred_len = (sizeof(struct sadb_cred) +
				    PADUP(tdb->tdb_local_cred_len)) /
				   sizeof(uint64_t);
	sadb_cred->sadb_cred_type = tdb->tdb_local_cred_type;
	*p += sizeof(struct sadb_cred);
	bcopy(tdb->tdb_local_cred, *p, tdb->tdb_local_cred_len);
	*p += PADUP(tdb->tdb_local_cred_len);
    }
d562 1
d566 1
a566 9
    {
	sadb_ident->sadb_ident_len = (sizeof(struct sadb_ident) +
				      PADUP(tdb->tdb_srcid_len)) /
				     sizeof(uint64_t);
	sadb_ident->sadb_ident_type = tdb->tdb_srcid_type;
	*p += sizeof(struct sadb_ident);
	bcopy(tdb->tdb_srcid, *p, tdb->tdb_srcid_len);
	*p += PADUP(tdb->tdb_srcid_len);
    }
d568 8
a575 9
    {
	sadb_ident->sadb_ident_len = (sizeof(struct sadb_ident) +
				      PADUP(tdb->tdb_dstid_len)) /
				     sizeof(uint64_t);
	sadb_ident->sadb_ident_type = tdb->tdb_dstid_type;
	*p += sizeof(struct sadb_ident);
	bcopy(tdb->tdb_dstid, *p, tdb->tdb_dstid_len);
	*p += PADUP(tdb->tdb_dstid_len);
    }
d971 2
a972 2
    if (sa->tdb_srcid_len)
      i += PADUP(sa->tdb_srcid_len) + sizeof(struct sadb_ident);
d974 2
a975 2
    if (sa->tdb_dstid_len)
      i += PADUP(sa->tdb_dstid_len) + sizeof(struct sadb_ident);
d1026 1
a1026 1
    if (sa->tdb_srcid_len)
d1033 1
a1033 1
    if (sa->tdb_dstid_len)
d1971 1
a1971 1
		FREE(ipo->ipo_srcid, M_CREDENTIALS);
d1977 1
a1977 1
		FREE(ipo->ipo_dstid, M_CREDENTIALS);
d1983 7
a1989 2
		ipo->ipo_srcid_type = sid->sadb_ident_type;
		ipo->ipo_srcid_len = (sid->sadb_ident_len * sizeof(u_int64_t)) - sizeof(struct sadb_ident);
a1990 2
		MALLOC(ipo->ipo_srcid, u_int8_t *, ipo->ipo_srcid_len,
		       M_CREDENTIALS, M_DONTWAIT);
d2005 1
a2005 1
		bcopy(sid + 1, ipo->ipo_srcid, ipo->ipo_srcid_len);
d2010 8
a2017 3
		ipo->ipo_dstid_type = sid->sadb_ident_type;
		ipo->ipo_dstid_len = (sid->sadb_ident_len * sizeof(u_int64_t)) -
				     sizeof(struct sadb_ident);
a2018 2
		MALLOC(ipo->ipo_dstid, u_int8_t *, ipo->ipo_dstid_len,
		       M_CREDENTIALS, M_DONTWAIT);
d2030 1
a2030 1
			  FREE(ipo->ipo_dstid, M_CREDENTIALS);
d2038 1
a2038 1
		bcopy(sid + 1, ipo->ipo_dstid, ipo->ipo_dstid_len);
d2061 1
a2061 1
		      FREE(ipo->ipo_srcid, M_CREDENTIALS);
d2063 1
a2063 1
		      FREE(ipo->ipo_dstid, M_CREDENTIALS);
d2206 1
a2206 1
      i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid_len);
d2209 1
a2209 1
      i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid_len);
d2262 1
a2262 1
	p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid_len);
d2265 1
a2265 1
				 PADUP(ipo->ipo_srcid_len)) /
d2267 3
a2269 3
	srcid->sadb_ident_type = ipo->ipo_srcid_type;
	bcopy(ipo->ipo_srcid, headers[SADB_EXT_IDENTITY_SRC] +
	      sizeof(struct sadb_ident), ipo->ipo_srcid_len);
d2275 1
a2275 1
	p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid_len);
d2278 1
a2278 1
				 PADUP(ipo->ipo_dstid_len)) /
d2280 3
a2282 3
	dstid->sadb_ident_type = ipo->ipo_dstid_type;
	bcopy(ipo->ipo_dstid, headers[SADB_EXT_IDENTITY_DST] +
	      sizeof(struct sadb_ident), ipo->ipo_dstid_len);
@


1.58
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.57 2001/03/27 14:45:21 art Exp $ */
d497 5
a501 4
	tdb->tdb_dst_cred_len = EXTLEN(sadb_cred) - sizeof(struct sadb_cred);
	tdb->tdb_dst_cred_type = sadb_cred->sadb_cred_type;
	MALLOC(tdb->tdb_dst_credentials, caddr_t, tdb->tdb_dst_cred_len,
	       M_XDATA, M_WAITOK);
d503 1
a503 1
	      tdb->tdb_dst_credentials, tdb->tdb_dst_cred_len);
d507 4
a510 4
	tdb->tdb_src_cred_len = EXTLEN(sadb_cred) - sizeof(struct sadb_cred);
	tdb->tdb_src_cred_type = sadb_cred->sadb_cred_type;
	MALLOC(tdb->tdb_src_credentials, caddr_t, tdb->tdb_src_cred_len,
	       M_XDATA, M_WAITOK);
d512 1
a512 1
	      tdb->tdb_src_credentials, tdb->tdb_src_cred_len);
d530 1
a530 1
	MALLOC(tdb->tdb_srcid, u_int8_t *, tdb->tdb_srcid_len, M_XDATA,
d540 1
a540 1
	MALLOC(tdb->tdb_dstid, u_int8_t *, tdb->tdb_dstid_len, M_XDATA,
d555 1
a555 1
				    PADUP(tdb->tdb_dst_cred_len)) /
d557 1
a557 1
	sadb_cred->sadb_cred_type = tdb->tdb_dst_cred_type;
d559 2
a560 2
	bcopy(tdb->tdb_dst_credentials, *p, tdb->tdb_dst_cred_len);
	*p += PADUP(tdb->tdb_dst_cred_len);
d565 1
a565 1
				    PADUP(tdb->tdb_src_cred_len)) /
d567 1
a567 1
	sadb_cred->sadb_cred_type = tdb->tdb_src_cred_type;
d569 2
a570 2
	bcopy(tdb->tdb_src_credentials, *p, tdb->tdb_src_cred_len);
	*p += PADUP(tdb->tdb_src_cred_len);
d1063 1
a1063 1
    if (sa->tdb_src_credentials)
d1065 1
a1065 1
	headers[SADB_X_EXT_SRC_CREDENTIALS] = p;
d1069 1
a1069 1
    if (sa->tdb_dst_credentials)
d1071 1
a1071 1
	headers[SADB_X_EXT_DST_CREDENTIALS] = p;
d1388 4
a1391 4
		import_credentials(newsa, headers[SADB_X_EXT_SRC_CREDENTIALS],
				   0);
		import_credentials(newsa, headers[SADB_X_EXT_DST_CREDENTIALS],
				   1);
d1506 4
a1509 4
		import_credentials(newsa, headers[SADB_X_EXT_SRC_CREDENTIALS],
				   0);
		import_credentials(newsa, headers[SADB_X_EXT_DST_CREDENTIALS],
				   1);
d1911 1
a1911 1
		       M_TDB, M_NOWAIT);
d1961 1
a1961 1
		      FREE(ipo, M_TDB);
d1994 1
a1994 1
		FREE(ipo->ipo_srcid, M_TEMP);
d2000 1
a2000 1
		FREE(ipo->ipo_dstid, M_TEMP);
d2010 1
a2010 1
		       M_TEMP, M_DONTWAIT);
d2020 1
a2020 1
		      FREE(ipo, M_TDB);
d2035 1
a2035 1
		       M_TEMP, M_DONTWAIT);
d2047 2
a2048 2
			  FREE(ipo->ipo_dstid, M_TEMP);
			FREE(ipo, M_TDB);
d2078 1
a2078 1
		      FREE(ipo->ipo_srcid, M_TEMP);
d2080 2
a2081 2
		      FREE(ipo->ipo_dstid, M_TEMP);
		    FREE(ipo, M_TDB); /* Free policy entry */
@


1.57
log
@Fix a problem with how TDB timeouts were used in pfkeyv2.
When we allocated a tdb we did a timeout_add before a timeout_set.
This was a problem in itself, but it shouldn't hurt too much.
What did hurt was that we did a timeout_set after the timeout_add,
timeout_set marked the timeout as not being on the timeout list and if we
did a timeout_del (or timeout_add) later (before the timeout fired) we
ended up with a chunk of freed memory on the timeout queue or maybe
even dangling pointers (or a circular list).

This should probably cure the timeout queue corruption some people were
seeing lately.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.56 2001/03/15 06:30:57 mickey Exp $ */
d69 1
a69 1
void export_credentials(void **, struct tdb *);
d77 1
a77 1
void import_credentials(struct tdb *, struct sadb_cred *);
d490 1
a490 1
import_credentials(struct tdb *tdb, struct sadb_cred *sadb_cred)
d495 18
a512 6
    tdb->tdb_cred_len = EXTLEN(sadb_cred) - sizeof(struct sadb_cred);
    tdb->tdb_cred_type = sadb_cred->sadb_cred_type;
    MALLOC(tdb->tdb_credentials, caddr_t, tdb->tdb_cred_len, M_XDATA,
	   M_WAITOK);
    bcopy((void *) sadb_cred + sizeof(struct sadb_cred),
	  tdb->tdb_credentials, tdb->tdb_cred_len);
d547 1
a547 1
export_credentials(void **p, struct tdb *tdb)
d551 20
a570 7
    sadb_cred->sadb_cred_len = (sizeof(struct sadb_cred) +
				PADUP(tdb->tdb_cred_len)) /
			       sizeof(uint64_t);
    sadb_cred->sadb_cred_type = tdb->tdb_cred_type;
    *p += sizeof(struct sadb_cred);
    bcopy(tdb->tdb_credentials, *p, tdb->tdb_cred_len);
    *p += PADUP(tdb->tdb_cred_len);
d1062 7
a1068 1
    if (sa->tdb_credentials)
d1070 2
a1071 2
	headers[SADB_X_EXT_CREDENTIALS] = p;
	export_credentials(&p, sa);
d1387 4
a1390 1
		import_credentials(newsa, headers[SADB_X_EXT_CREDENTIALS]);
d1505 4
a1508 1
		import_credentials(newsa, headers[SADB_X_EXT_CREDENTIALS]);
@


1.56
log
@convert SA expirations to the new timeouts.
simplifies expirations handling a lot.
tdb_exp_timeout and tdb_soft_timeout are made
consistant throughout the code to be a relative time offsets,
just like first_use timeouts.
tested on singlehost isakmpd setup.
lots of dangling spaces and tabs removed.
angelos@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.55 2001/03/04 20:50:40 angelos Exp $ */
d1324 1
a1324 3
		MALLOC(freeme, struct tdb *, sizeof(struct tdb),
		       M_TDB, M_WAITOK);
		bzero(freeme, sizeof(struct tdb));
d1432 1
a1432 2
	    MALLOC(freeme, struct tdb *, sizeof(struct tdb), M_TDB, M_WAITOK);
	    bzero(freeme, sizeof(struct tdb));
@


1.55
log
@Import/export credentials from TDB.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.54 2000/12/24 04:18:42 angelos Exp $ */
d215 1
a215 1
  
d311 1
a311 1
      
d316 1
a316 1
      
d321 4
a324 5
		tdb->tdb_exp_timeout += time.tv_sec;
	    }
	    else
	      tdb->tdb_flags &= ~TDBF_TIMER;
      
d327 4
a330 1
	      tdb->tdb_flags |= TDBF_FIRSTUSE;
d332 1
a332 1
	      tdb->tdb_flags &= ~TDBF_FIRSTUSE;
d334 1
a334 1
      
d341 1
a341 1
      
d347 1
a347 1
      
d352 1
a352 1
		tdb->tdb_soft_timeout += time.tv_sec;
d356 1
a356 1
      
d359 4
a362 1
	      tdb->tdb_flags |= TDBF_SOFT_FIRSTUSE;
d364 1
a364 1
	      tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
d366 1
a366 1
      
a373 3

    /* Setup/update our position in the expiration queue.  */
    tdb_expiration(tdb, TDBEXP_TIMEOUT);
d398 1
a398 2
	      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_exp_timeout -
						     tdb->tdb_established;
d401 1
a401 2
	      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_exp_first_use -
						     tdb->tdb_first_use;
d413 1
a413 2
	      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_soft_timeout -
						     tdb->tdb_established;
d416 1
a416 2
	      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_soft_first_use -
						     tdb->tdb_first_use;
d418 1
a418 1
      
d581 1
a581 1
        
d694 1
a694 1
	    /* 
d1102 1
a1102 1
int 
d1107 1
a1107 1
      tdb_delete(sa, 0);
d1139 1
a1139 1
	    if(alg != NULL) 
d1256 1
a1256 1
 
d1332 1
a1332 1
		if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype, 
d1367 1
a1367 1
		    tdb_delete(freeme, TDBEXP_TIMEOUT);
d1375 1
a1375 1
		tdb_delete(sa2, TDBEXP_TIMEOUT);
d1445 1
a1445 1
		if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype, 
d1483 1
a1483 1
		    tdb_delete(freeme, TDBEXP_TIMEOUT);
d1510 2
a1511 2
      
	    tdb_delete(sa2, TDBEXP_TIMEOUT);
d1546 1
a1546 1
      
d1566 1
a1566 1
      
d1590 1
a1590 1
      
d1622 1
a1622 1
		case SADB_SATYPE_UNSPEC:  
d1631 1
a1631 1
		    tdb_walk(pfkeyv2_flush_walker, 
d1714 1
a1714 1
	 
d1717 1
a1717 1
	
d2062 1
a2062 1
	
d2356 1
a2356 1
	
@


1.54
log
@Set sequence number to zero for last message in SADB_DUMP, close pr 1583.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.53 2000/12/15 20:32:09 provos Exp $ */
d69 1
d77 1
d489 17
d537 14
d1038 7
d1360 1
d1475 2
@


1.53
log
@send messages to all registered listeners.  makes multiple keying daemons
work.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.52 2000/12/14 18:07:29 provos Exp $ */
d84 2
a85 2
int pfkeyv2_dump_walker(struct tdb *, void *);
int pfkeyv2_flush_walker(struct tdb *, void *);
d1029 1
a1029 1
pfkeyv2_dump_walker(struct tdb *sa, void *state)
d1046 3
d1065 1
a1065 1
pfkeyv2_flush_walker(struct tdb *sa, void *satype_vp)
@


1.52
log
@sync with pfkey rfc.  you need to rebuild ipsecadm and isakmpd after this.
okay angelos@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.51 2000/11/17 05:08:14 angelos Exp $ */
a690 1
		      {   /* Done */
a691 2
		          break;
		      }
@


1.51
log
@Missed this, from the previous commit.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.50 2000/11/17 04:08:44 angelos Exp $ */
d1518 1
a1518 1
	    i = sizeof(struct sadb_supported) + sizeof(ealgs) + sizeof(aalgs);
d1526 21
a1553 4
	    ssup->sadb_supported_nauth = sizeof(aalgs) /
					 sizeof(struct sadb_alg);
	    ssup->sadb_supported_nencrypt = sizeof(ealgs) /
					    sizeof(struct sadb_alg);
a1558 2
		p += sizeof(aalgs);
		bcopy(&ealgs[0], p, sizeof(ealgs));
d1561 3
a1563 2
	     headers[SADB_EXT_SUPPORTED] = freeme;
	     break;
@


1.50
log
@*HMAC96->*HMAC

Also, sync with IANA -- closes PR 1508.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.49 2000/11/06 18:18:56 angelos Exp $ */
d63 1
a63 1
    { SADB_X_AALG_RIPEMD160HMAC, 0, 160, 160 }
d230 1
a230 1
		sadb_sa->sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
d2288 1
a2288 1
	      sadb_comb->sadb_comb_auth = SADB_X_AALG_RIPEMD160HMAC;
@


1.49
log
@Send the message to registered promiscuous listeners.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.48 2000/10/14 06:23:51 angelos Exp $ */
d61 3
a63 3
    { SADB_AALG_SHA1HMAC96, 0, 160, 160 },
    { SADB_AALG_MD5HMAC96, 0, 128, 128 },
    { SADB_X_AALG_RIPEMD160HMAC96, 0, 160, 160 }
d221 2
a222 2
	    case CRYPTO_MD5_HMAC96:
		sadb_sa->sadb_sa_auth = SADB_AALG_MD5HMAC96;
d225 2
a226 2
	    case CRYPTO_SHA1_HMAC96:
		sadb_sa->sadb_sa_auth = SADB_AALG_SHA1HMAC96;
d229 2
a230 2
	    case CRYPTO_RIPEMD160_HMAC96:
		sadb_sa->sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC96;
d2280 1
a2280 1
	    sadb_comb->sadb_comb_auth = SADB_AALG_SHA1HMAC96;
d2288 1
a2288 1
	      sadb_comb->sadb_comb_auth = SADB_X_AALG_RIPEMD160HMAC96;
d2295 1
a2295 1
		sadb_comb->sadb_comb_auth = SADB_AALG_MD5HMAC96;
@


1.48
log
@ASKPOLICY message; used by key management to inquire about policy
triggering an ACQUIRE.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.47 2000/10/09 22:18:29 angelos Exp $ */
d718 1
a718 1
		  (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
@


1.48.2.1
log
@Pull in patch from current:
Fix (angelos):
Send the message to registered promiscuous listeners.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.48 2000/10/14 06:23:51 angelos Exp $ */
d718 1
a718 1
		  !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
@


1.47
log
@AES.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.46 2000/10/09 02:51:46 angelos Exp $ */
d80 1
d744 168
d1140 1
d1477 15
d2103 2
a2104 1
		union sockaddr_union *laddr)
d2115 2
d2155 1
a2155 1
    smsg->sadb_msg_seq = pfkeyv2_seq++;
a2312 2

    /* XXX How to externalize the policy itself ? */
@


1.46
log
@Properly cleanup IDs when resetting policy.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.45 2000/09/29 19:00:13 angelos Exp $ */
d56 1
d254 4
d2043 1
a2043 1
	    if (!strncasecmp(ipsec_def_enc, "3des", sizeof("3des")))
d2045 3
a2047 3
		sadb_comb->sadb_comb_encrypt = SADB_EALG_3DESCBC;
		sadb_comb->sadb_comb_encrypt_minbits = 192;
		sadb_comb->sadb_comb_encrypt_maxbits = 192;
d2050 1
a2050 1
	      if (!strncasecmp(ipsec_def_enc, "des", sizeof("des")))
d2052 3
a2054 3
		  sadb_comb->sadb_comb_encrypt = SADB_EALG_DESCBC;
		  sadb_comb->sadb_comb_encrypt_minbits = 64;
		  sadb_comb->sadb_comb_encrypt_maxbits = 64;
d2057 1
a2057 2
		if (!strncasecmp(ipsec_def_enc, "blowfish",
				 sizeof("blowfish")))
d2059 3
a2061 3
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
		    sadb_comb->sadb_comb_encrypt_minbits = 40;
		    sadb_comb->sadb_comb_encrypt_maxbits = BLF_MAXKEYLEN * 8;
d2064 2
a2065 2
		  if (!strncasecmp(ipsec_def_enc, "skipjack",
				   sizeof("skipjack")))
d2067 3
a2069 3
		      sadb_comb->sadb_comb_encrypt = SADB_X_EALG_SKIPJACK;
		      sadb_comb->sadb_comb_encrypt_minbits = 80;
		      sadb_comb->sadb_comb_encrypt_maxbits = 80;
d2072 2
a2073 2
		    if (!strncasecmp(ipsec_def_enc, "cast128",
				     sizeof("cast128")))
d2075 3
a2077 3
			sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
			sadb_comb->sadb_comb_encrypt_minbits = 40;
			sadb_comb->sadb_comb_encrypt_maxbits = 128;
d2079 8
@


1.45
log
@Don't use an SA payload for ADDFLOW/DELFLOW.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.44 2000/09/21 02:38:32 angelos Exp $ */
d1711 5
a1715 1
	      FREE(ipo->ipo_srcid, M_TEMP);
d1717 4
a1720 1
	      FREE(ipo->ipo_dstid, M_TEMP);
d1725 1
a1725 2
		ipo->ipo_srcid_len = (sid->sadb_ident_len * sizeof(u_int64_t)) -
				     sizeof(struct sadb_ident);
@


1.44
log
@Correctly handle srcid/dstid.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.43 2000/09/20 19:13:16 angelos Exp $ */
a1477 1
	    struct tdb *ktdb = NULL;
a1486 2
	    ssa = (struct sadb_sa *) headers[SADB_EXT_SA];

a1648 33
	    }

	    /*
	     * A direct "hint" was provided, try to locate TDB. If we
	     * don't find it, return an error, since it was expected
	     * that we'd be able to find the TDB. Be careful with any
	     * previously pointed to TDB.
	     */
	    if (ssa && ssa->sadb_sa_spi && sunionp)
	    {
		ktdb = ipo->ipo_tdb; /* Hold for now */

		s = spltdb();
		ipo->ipo_tdb = gettdb(ssa->sadb_sa_spi, sunionp,
				      SADB_GETSPROTO(smsg->sadb_msg_satype));
		if (ipo->ipo_tdb == NULL)
		{
                    if (!exists)
                      FREE(ipo, M_TDB);
                    else
		      ipsec_delete_policy(ipo);
		    rval = ESRCH;
		    goto splxret;
		}
		else
		{
                    if (ktdb)
		      TAILQ_REMOVE(&ktdb->tdb_policy_head, ipo, ipo_tdb_next);
		    TAILQ_INSERT_HEAD(&ipo->ipo_tdb->tdb_policy_head, ipo,
				      ipo_tdb_next);
		}

		splx(s);
@


1.43
log
@Add IDENTITY payloads to flow establishment (and cleanup accordingly)
-- this will address one of itojun's question on how are IDs for IKE
to be determined (need to add support for this to ipsecadm).
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.42 2000/09/19 08:38:58 angelos Exp $ */
d1753 4
d1773 1
a1773 7
		ipo->ipo_srcid_type = sid->sadb_ident_type;
		ipo->ipo_srcid_len = sid->sadb_ident_len -
				     sizeof(struct sadb_ident);

		bcopy(headers[SADB_EXT_IDENTITY_SRC] +
		      sizeof(struct sadb_ident), ipo->ipo_srcid,
		      ipo->ipo_srcid_len);
d1778 4
d1794 2
a1795 2
			if (ipo->ipo_srcid)
			  FREE(ipo->ipo_srcid, M_TEMP);
d1803 1
a1803 7
		ipo->ipo_dstid_type = sid->sadb_ident_type;
		ipo->ipo_dstid_len = sid->sadb_ident_len -
				     sizeof(struct sadb_ident);

		bcopy(headers[SADB_EXT_IDENTITY_SRC] +
		      sizeof(struct sadb_ident), ipo->ipo_dstid,
		      ipo->ipo_dstid_len);
@


1.42
log
@SA bundles.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.41 2000/09/19 04:23:13 angelos Exp $ */
d980 1
d1672 1
a1672 1
		      ipo->ipo_tdb = ktdb; /* Reset */
d1717 5
a1721 9
                    {
                        if (ipo->ipo_tdb)
		          TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
                                       ipo_tdb_next);
                        if (ktdb)
		          TAILQ_INSERT_HEAD(&ktdb->tdb_policy_head,
                                            ipo, ipo_tdb_next);
                        ipo->ipo_tdb = ktdb;
                    }
d1746 63
d1829 4
d1950 1
d1971 6
d2024 26
@


1.41
log
@Still more careful with cleaning up.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.40 2000/09/19 03:41:11 angelos Exp $ */
d1410 57
a1466 1
	
@


1.40
log
@Better cleanup on invalid ADDFLOW message.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.39 2000/09/19 03:19:39 angelos Exp $ */
d1421 1
a1421 1
	    struct tdb *ktdb;
d1614 2
a1615 1
		    ipo->ipo_tdb = ktdb; /* Reset */
d1659 11
@


1.39
log
@SPD-driven IPsec.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.38 2000/08/24 22:51:29 fgsch Exp $ */
d1612 2
a1628 21
            if (sunionp)
	      bcopy(sunionp, &ipo->ipo_dst, sizeof(union sockaddr_union));
            else
            {
		bzero(&ipo->ipo_dst, sizeof(union sockaddr_union));
                ipo->ipo_dst.sa.sa_family = src->sa.sa_family;
                ipo->ipo_dst.sa.sa_len = src->sa.sa_len;
            }

	    if (ssrc)
	      bcopy(ssrc, &ipo->ipo_src, sizeof(union sockaddr_union));
	    else
	    {
		bzero(&ipo->ipo_src, sizeof(union sockaddr_union));
		ipo->ipo_src.sa.sa_family = src->sa.sa_family;
		ipo->ipo_src.sa.sa_len = src->sa.sa_len;
	    }

	    ipo->ipo_sproto = SADB_GETSPROTO(smsg->sadb_msg_satype);

	    /* Flow type */
d1656 2
a1657 1
		    FREE(ipo, M_TDB);
d1662 21
@


1.38
log
@Fix a problem when deleting a flow via -delete. This only affects flows
using -transport; found by riq@@core-sdi.com, fix by angelos@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.37 2000/08/08 21:26:52 angelos Exp $ */
d31 1
a32 1
#include <netinet/ip_ipsp.h>
d53 3
a55 3
    { SADB_X_EALG_BLF, 64, 5, BLF_MAXKEYLEN},
    { SADB_X_EALG_CAST, 64, 5, 16},
    { SADB_X_EALG_SKIPJACK, 64, 10, 10},
d69 1
d496 1
a496 1
	bcopy((void *)sadb_ident + sizeof(struct sadb_ident),
d506 1
a506 1
	bcopy((void *)sadb_ident + sizeof(struct sadb_ident),
d557 27
d685 4
a688 5
			if (count-- == 0)
			{     /* Done */
			    pfkey_sendup(s->socket, packet, 1);
			    break;
			}
d834 13
a846 1
    /* XXX Export keys ? */
d895 1
a895 1
      tdb_delete(sa, 0, 0);
d916 1
a916 1
	    if(alg != NULL) 
d964 2
a974 1
    struct flow *flow = NULL;
d1152 1
a1152 1
		    tdb_delete(freeme, 0, TDBEXP_TIMEOUT);
a1158 18
		/* Copy outgoing flows and ACL */
		newsa->tdb_flow = sa2->tdb_flow;
		newsa->tdb_access = sa2->tdb_access;

		/* Fix flow backpointers to the TDB */
		for (flow = newsa->tdb_flow;
		     flow != NULL;
		     flow = flow->flow_next)
		  flow->flow_sa = newsa;

		for (flow = newsa->tdb_access;
		     flow != NULL;
		     flow = flow->flow_next)
		  flow->flow_sa = newsa;

		sa2->tdb_access = NULL;
		sa2->tdb_flow = NULL;

d1160 1
a1160 1
		tdb_delete(sa2, 0, TDBEXP_TIMEOUT);
d1266 1
a1266 1
		    tdb_delete(freeme, 0, TDBEXP_TIMEOUT);
d1294 1
a1294 2
	    tdb_delete(sa2, ssa->sadb_sa_flags & SADB_X_SAFLAGS_CHAINDEL,
		       TDBEXP_TIMEOUT);
d1367 5
a1374 19
		case SADB_X_SATYPE_BYPASS:
		{
		    union sockaddr_union dst;
		    /* XXX IPv4 dependency -- does it matter though ? */
		    dst.sin.sin_family = AF_INET;
		    dst.sin.sin_len = sizeof(struct sockaddr_in);
		    dst.sin.sin_addr.s_addr = INADDR_ANY;

		    s = spltdb();

		    sa2 = gettdb(SPI_LOCAL_USE, &dst, IPPROTO_IP);
		    if (sa2 != NULL)
		      tdb_delete(sa2, 0, 0);

		    if (smsg->sadb_msg_satype == SADB_X_SATYPE_BYPASS)
		      break;
		    /* for SADB_SATYPE_UNSPEC, fall through */
		}

d1385 2
a1392 3
	    if (rval == 0)
	      goto splxret;

d1416 15
a1430 6
	    struct sockaddr_encap encapdst, encapgw, encapnetmask;
	    struct flow *flow2 = NULL, *old_flow = NULL, *old_flow2 = NULL;
	    union sockaddr_union *src, *dst, *srcmask, *dstmask;
	    u_int8_t sproto = 0, replace, ingress ;
	    struct rtentry *rt;
	
d1433 4
d1444 6
a1449 12
	    /*
	     * SADB_X_SAFLAGS_REPLACEFLOW set means we should remove any
	     * potentially conflicting egress flow while we are adding this
	     * new one.
	     */
	    replace = ssa->sadb_sa_flags &  SADB_X_SAFLAGS_REPLACEFLOW;
	    ingress = ssa->sadb_sa_flags & SADB_X_SAFLAGS_INGRESS_FLOW;
	    if ((replace && delflag) || (replace && ingress))
	    {
		rval = EINVAL;
		goto ret;
	    }
d1469 1
a1469 1
		goto splxret;
d1475 2
a1476 1
	
d1478 1
a1478 3
	      sproto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL])->sadb_protocol_proto;
	    else
	      sproto = 0;
d1484 3
a1486 1
	    s = spltdb();
d1488 1
a1488 78
	    if (!delflag || ingress)
	    {
		if ((ssa == NULL) || (sunionp == NULL))
		{
		    rval = EINVAL;
		    goto splxret;
		}

		/* Find the relevant SA */
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
			     SADB_GETSPROTO(smsg->sadb_msg_satype));

		if (sa2 == NULL)
		{
		    rval = ESRCH;
		    goto splxret;
		}
	    }

	    /* For non-ingress flows... */
	    if (!ingress)
	    {
		/*
		 * ...if the requested flow already exists and we aren't
		 * asked to replace or delete it, or if it doesn't exist
		 * and we're asked to delete it, fail.
		 */
		flow = find_global_flow(src, srcmask, dst, dstmask, sproto);
		if (!replace &&
		    ((delflag && (flow == NULL)) ||
		     (!delflag && (flow != NULL))))
		{
		    rval = delflag ? ESRCH : EEXIST;
		    goto splxret;
		}
	    }

	    /* If we're not deleting a flow, add in the TDB */
	    if (!delflag)
	    {
		if (replace)
		  old_flow = flow;

		flow = get_flow();
		bcopy(src, &flow->flow_src, src->sa.sa_len);
		bcopy(dst, &flow->flow_dst, dst->sa.sa_len);
		bcopy(srcmask, &flow->flow_srcmask, srcmask->sa.sa_len);
		bcopy(dstmask, &flow->flow_dstmask, dstmask->sa.sa_len);
		flow->flow_proto = sproto;
		put_flow(flow, sa2, ingress);

		/* If this is an ACL entry, we're done */
		if (ingress)
		{
		    splx(s);
		    break;
		}
	    }
	    else
	      if (ingress)
	      {
		  /* If we're deleting an ingress flow... */
		  flow = find_flow(src, srcmask, dst, dstmask, sproto,
				   sa2, FLOW_INGRESS);
		  if (flow == NULL)
		  {
		      rval = ESRCH;
		      goto splxret;
		  }

		  delete_flow(flow, sa2, FLOW_INGRESS);
		  splx(s);
		  break;
	      }

	    /* Setup the encap fields */
	    encapdst.sen_family = PF_KEY;
	    switch (flow->flow_src.sa.sa_family)
a1491 1
		    encapdst.sen_len = SENT_IP4_LEN;
d1493 6
a1498 5
		    encapdst.sen_ip_src = flow->flow_src.sin.sin_addr;
		    encapdst.sen_ip_dst = flow->flow_dst.sin.sin_addr;
		    encapdst.sen_proto = flow->flow_proto;
		    encapdst.sen_sport = flow->flow_src.sin.sin_port;
		    encapdst.sen_dport = flow->flow_dst.sin.sin_port;
a1499 2
		    encapnetmask.sen_len = SENT_IP4_LEN;
		    encapnetmask.sen_family = PF_KEY;
d1501 7
a1507 12
		    encapnetmask.sen_ip_src = flow->flow_srcmask.sin.sin_addr;
		    encapnetmask.sen_ip_dst = flow->flow_dstmask.sin.sin_addr;
	  	    if (flow->flow_proto)
		    {
		        encapnetmask.sen_proto = 0xff;

		        if (flow->flow_src.sin.sin_port)
		          encapnetmask.sen_sport = 0xffff;

		        if (flow->flow_dst.sin.sin_port)
		          encapnetmask.sen_dport = 0xffff;
		    }
a1512 1
		    encapdst.sen_len = SENT_IP6_LEN;
d1514 6
a1519 5
		    encapdst.sen_ip6_src = flow->flow_src.sin6.sin6_addr;
		    encapdst.sen_ip6_dst = flow->flow_dst.sin6.sin6_addr;
		    encapdst.sen_ip6_proto = flow->flow_proto;
		    encapdst.sen_ip6_sport = flow->flow_src.sin6.sin6_port;
		    encapdst.sen_ip6_dport = flow->flow_dst.sin6.sin6_port;
a1520 2
		    encapnetmask.sen_len = SENT_IP6_LEN;
		    encapnetmask.sen_family = PF_KEY;
d1522 7
a1528 14
		    encapnetmask.sen_ip6_src =
					     flow->flow_srcmask.sin6.sin6_addr;
		    encapnetmask.sen_ip6_dst =
					     flow->flow_dstmask.sin6.sin6_addr;
		    if (flow->flow_proto)
		    {
		        encapnetmask.sen_ip6_proto = 0xff;

		        if (flow->flow_src.sin6.sin6_port)
		          encapnetmask.sen_ip6_sport = 0xffff;

		        if (flow->flow_dst.sin6.sin6_port)
		          encapnetmask.sen_ip6_dport = 0xffff;
		    }
d1533 18
a1550 37
	    if (!delflag)
	    {
		switch (sa2->tdb_dst.sa.sa_family)
		{
#ifdef INET
		    case AF_INET:
			encapgw.sen_len = SENT_IPSP_LEN;
			encapgw.sen_family = PF_KEY;
			encapgw.sen_type = SENT_IPSP;
			encapgw.sen_ipsp_dst = sa2->tdb_dst.sin.sin_addr;
			encapgw.sen_ipsp_spi = sa2->tdb_spi;
			encapgw.sen_ipsp_sproto = sa2->tdb_sproto;

			break;
#endif /* INET */

#if INET6
		    case AF_INET6:
			encapgw.sen_len = SENT_IPSP6_LEN;
			encapgw.sen_family = PF_KEY;
			encapgw.sen_type = SENT_IPSP6;
			encapgw.sen_ipsp6_dst = sa2->tdb_dst.sin6.sin6_addr;
			encapgw.sen_ipsp6_spi = sa2->tdb_spi;
			encapgw.sen_ipsp6_sproto = sa2->tdb_sproto;

			break;
#endif /* INET6 */

		    default:
			/* 
			 * This shouldn't ever happen really, as SAs
			 * should be checked at establishment time. 
			 */
			rval = EPFNOSUPPORT;
			delete_flow(flow, flow->flow_sa, FLOW_EGRESS);
			goto splxret;
		}
d1552 2
d1555 1
a1555 1
	    /* Add the entry in the routing table */
d1558 1
a1558 16
		rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
			  (struct sockaddr *) 0,
			  (struct sockaddr *) &encapnetmask,
			  0, (struct rtentry **) 0);

		delete_flow(flow, flow->flow_sa, FLOW_EGRESS);
	    }
	    else if (!replace)
	    {
		rval = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				 (struct sockaddr *) &encapgw,
				 (struct sockaddr *) &encapnetmask,
				 RTF_UP | RTF_GATEWAY | RTF_STATIC,
				 (struct rtentry **) 0);
	    
		if (rval)
d1560 4
a1563 6
		    delete_flow(flow, sa2, FLOW_EGRESS);

		    if (flow2)
		      delete_flow(flow2, sa2, FLOW_EGRESS);

		    goto splxret;
d1566 3
a1568 1
		sa2->tdb_cur_allocations++;
d1570 2
a1571 1
	    else
d1573 4
a1576 3
		rt = (struct rtentry *) rn_lookup(&encapdst, &encapnetmask, 
						  rt_tables[PF_KEY]);
		if (rt == NULL)
d1578 2
a1579 15
		    rval = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				     (struct sockaddr *) &encapgw,
				     (struct sockaddr *) &encapnetmask,
				     RTF_UP | RTF_GATEWAY | RTF_STATIC,
				     (struct rtentry **) 0);

		    if (rval)
		    {
			delete_flow(flow, sa2, FLOW_EGRESS);

			if (flow2)
			  delete_flow(flow2, sa2, FLOW_EGRESS);

			goto splxret;
		    }
a1580 8
		else if (rt_setgate(rt, rt_key(rt),
				    (struct sockaddr *) &encapgw))
		{
		    rval = ENOMEM;
		    delete_flow(flow, sa2, FLOW_EGRESS);

		    if (flow2)
		      delete_flow(flow2, sa2, FLOW_EGRESS);
d1582 1
a1582 2
		    goto splxret;
		}
d1584 11
a1594 1
		sa2->tdb_cur_allocations++;
d1597 7
a1603 1
	    if (replace)
d1605 1
a1605 2
		if (old_flow != NULL)
		  delete_flow(old_flow, old_flow->flow_sa, FLOW_EGRESS);
d1607 10
a1616 9
		if (old_flow2 != NULL)
		  delete_flow(old_flow2, old_flow2->flow_sa, FLOW_EGRESS);
	    }

	    /* If we are adding flows, check for allocation expirations */
	    if (!delflag && !(replace && old_flow != NULL))
	    {
		if ((sa2->tdb_flags & TDBF_ALLOCATIONS) &&
		    (sa2->tdb_cur_allocations >= sa2->tdb_exp_allocations))
d1618 4
a1621 2
		    pfkeyv2_expire(sa2, SADB_EXT_LIFETIME_HARD);
		    tdb_delete(sa2, 0, TDBEXP_TIMEOUT);
d1623 2
a1624 7
		else 
		  if ((sa2->tdb_flags & TDBF_SOFT_ALLOCATIONS) &&
		      (sa2->tdb_cur_allocations >= sa2->tdb_soft_allocations))
		  {
		      pfkeyv2_expire(sa2, SADB_EXT_LIFETIME_SOFT);
		      sa2->tdb_flags &= ~TDBF_SOFT_ALLOCATIONS;
		  }
a1625 1
	}
d1627 8
a1634 7
	 splx(s);
	 break;
	
	case SADB_X_GRPSPIS:
	{
	    struct tdb *tdb1, *tdb2, *tdb3;
	    struct sadb_protocol *sa_proto;
d1636 3
a1638 9
	    ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));

	    s = spltdb();

	    tdb1 = gettdb(ssa->sadb_sa_spi, sunionp,
		      SADB_GETSPROTO(smsg->sadb_msg_satype));
	    if (tdb1 == NULL)
d1640 3
a1642 2
		rval = ESRCH;
		goto splxret;
d1645 1
a1645 4
	    ssa = (struct sadb_sa *) headers[SADB_X_EXT_SA2];
	    sunionp = (union sockaddr_union *) (headers[SADB_X_EXT_DST2] +
						sizeof(struct sadb_address));
	    sa_proto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL]);
d1647 2
a1648 3
	    tdb2 = gettdb(ssa->sadb_sa_spi, sunionp,
			  SADB_GETSPROTO(sa_proto->sadb_protocol_proto));
	    if (tdb2 == NULL)
d1650 3
a1652 3
		rval = ESRCH;
		goto splxret;
	    }
d1654 3
a1656 7
	    /* Detect cycles */
	    for (tdb3 = tdb2; tdb3; tdb3 = tdb3->tdb_onext)
	      if (tdb3 == tdb1)
	      {
		  rval = ESRCH;
		  goto splxret;
	      }
d1658 3
a1660 12
	    /* Maintenance */
	    if ((tdb1->tdb_onext) &&
		(tdb1->tdb_onext->tdb_inext == tdb1))
	      tdb1->tdb_onext->tdb_inext = NULL;

	    if ((tdb2->tdb_inext) &&
		(tdb2->tdb_inext->tdb_onext == tdb2))
	      tdb2->tdb_inext->tdb_onext = NULL;

	    /* Link them */
	    tdb1->tdb_onext = tdb2;
	    tdb2->tdb_inext = tdb1;
d1662 3
a1664 2
	    splx(s);
	}
d1666 3
a1668 6
	 break;
	
	case SADB_X_BINDSA:
	{
	    struct tdb *tdb1, *tdb2;
	    struct sadb_protocol *sa_proto;
d1670 3
a1672 3
	    ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));
d1674 5
a1678 1
	    s = spltdb();
d1680 1
a1680 3
	    tdb1 = gettdb(ssa->sadb_sa_spi, sunionp,
			  SADB_GETSPROTO(smsg->sadb_msg_satype));
	    if (tdb1 == NULL)
d1682 15
a1696 3
		rval = ESRCH;
		goto splxret;
	    }
d1698 3
a1700 6
	    if (TAILQ_FIRST(&tdb1->tdb_bind_in))
	    {
		/* Incoming SA has not list of referencing incoming SAs */
		rval = EINVAL;
		goto splxret;
	    }
d1702 3
a1704 4
	    ssa = (struct sadb_sa *) headers[SADB_X_EXT_SA2];
	    sunionp = (union sockaddr_union *) (headers[SADB_X_EXT_DST2] +
						sizeof(struct sadb_address));
	    sa_proto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL]);
d1706 1
a1706 6
	    tdb2 = gettdb(ssa->sadb_sa_spi, sunionp,
			  SADB_GETSPROTO(sa_proto->sadb_protocol_proto));
	    if (tdb2 == NULL)
	    {
		rval = ESRCH;
		goto splxret;
d1708 1
a1708 2

	    if (tdb2->tdb_bind_out)
d1710 1
a1710 3
		/* Outgoing SA has no pointer to an outgoing SA */
		rval = EINVAL;
		goto splxret;
d1712 1
a1712 13

	    /* Maintenance */
	    if (tdb1->tdb_bind_out)
	      TAILQ_REMOVE(&tdb1->tdb_bind_out->tdb_bind_in, tdb1,
			   tdb_bind_in_next);

	    /* Link them */
	    tdb1->tdb_bind_out = tdb2;
	    TAILQ_INSERT_TAIL(&tdb2->tdb_bind_in, tdb1, tdb_bind_in_next);

	    splx(s);
	}

d1811 2
a1812 1
pfkeyv2_acquire(struct tdb *tdb, int rekey)
d1814 2
a1815 1
    void *p, *headers[SADB_EXT_MAX+1], *buffer = NULL;
d1817 1
a1818 3
    struct sadb_ident *sa_ident;
    struct sadb_prop *sa_prop;
    struct sadb_comb *sadb_comb;
d1829 5
a1833 8
    i = sizeof(struct sadb_msg) + sizeof(struct sadb_address) +
	PADUP(SA_LEN(&tdb->tdb_src.sa)) + sizeof(struct sadb_address) +
	PADUP(SA_LEN(&tdb->tdb_dst.sa)) + sizeof(struct sadb_prop) +
	1 * sizeof(struct sadb_comb) +
	2 * sizeof(struct sadb_ident);

    if (rekey)
      i += PADUP(tdb->tdb_srcid_len) + PADUP(tdb->tdb_dstid_len);
a1854 1
    smsg->sadb_msg_satype = tdb->tdb_satype;
d1856 17
a1872 9
    headers[SADB_EXT_ADDRESS_SRC] = p;
    p += sizeof(struct sadb_address) + PADUP(SA_LEN(&tdb->tdb_src.sa));
    sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_SRC];
    sadd->sadb_address_len = (sizeof(struct sadb_address) +
			     SA_LEN(&tdb->tdb_src.sa) +
			     sizeof(uint64_t) - 1) / sizeof(uint64_t);
    bcopy(&tdb->tdb_src,
	  headers[SADB_EXT_ADDRESS_SRC] + sizeof(struct sadb_address),
	  SA_LEN(&tdb->tdb_src.sa));
d1875 1
a1875 1
    p += sizeof(struct sadb_address) + PADUP(SA_LEN(&tdb->tdb_dst.sa));
d1878 1
a1878 1
			      SA_LEN(&tdb->tdb_dst.sa) +
d1880 2
a1881 41
    bcopy(&tdb->tdb_dst,
	  headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address),
	  SA_LEN(&tdb->tdb_dst.sa));

    headers[SADB_EXT_IDENTITY_SRC] = p;
    p += sizeof(struct sadb_ident);
    sa_ident = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_SRC];
    sa_ident->sadb_ident_type = tdb->tdb_srcid_type;

    /* XXX some day we'll have to deal with real ident_ids for users */
    sa_ident->sadb_ident_id = 0;

    if (rekey)
    {
	sa_ident->sadb_ident_len = (sizeof(struct sadb_ident) +
				    PADUP(tdb->tdb_srcid_len)) /
				   sizeof(uint64_t);
	bcopy(tdb->tdb_srcid, p, tdb->tdb_srcid_len);
	p += PADUP(tdb->tdb_srcid_len);
    }
    else
      sa_ident->sadb_ident_len = sizeof(struct sadb_ident) / sizeof(uint64_t);

    headers[SADB_EXT_IDENTITY_DST] = p;
    p += sizeof(struct sadb_ident);
    sa_ident = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_DST];
    sa_ident->sadb_ident_type = tdb->tdb_dstid_type;

    /* XXX some day we'll have to deal with real ident_ids for users */
    sa_ident->sadb_ident_id = 0;

    if (rekey)
    {
	sa_ident->sadb_ident_len = (sizeof(struct sadb_ident) +
				    PADUP(tdb->tdb_dstid_len)) /
				   sizeof(uint64_t);
	bcopy(tdb->tdb_dstid, p, tdb->tdb_dstid_len);
	p += PADUP(tdb->tdb_dstid_len);
    }
    else
      sa_ident->sadb_ident_len = sizeof(struct sadb_ident) / sizeof(uint64_t);
d1886 1
a1886 1
    sa_prop->sadb_prop_num = 1; /* XXX Only 1 proposal supported for now */
d1893 1
d1898 1
a1898 1
	if (tdb->tdb_flags & TDBF_PFS)
d1901 2
a1902 7
	if (tdb->tdb_flags & TDBF_HALFIV)
	  sadb_comb->sadb_comb_flags |= SADB_X_SAFLAGS_HALFIV;

	if (tdb->tdb_flags & TDBF_TUNNELING)
	  sadb_comb->sadb_comb_flags |= SADB_X_SAFLAGS_TUNNEL;

	if (tdb->tdb_authalgxform)
d1904 1
a1904 1
	    switch (tdb->tdb_authalgxform->type)
d1906 3
a1908 19
		case CRYPTO_MD5_HMAC96:
		    sadb_comb->sadb_comb_auth = SADB_AALG_MD5HMAC96;
		    break;

		case CRYPTO_SHA1_HMAC96:
		    sadb_comb->sadb_comb_auth = SADB_AALG_SHA1HMAC96;
		    break;

		case CRYPTO_RIPEMD160_HMAC96:
		    sadb_comb->sadb_comb_auth = SADB_X_AALG_RIPEMD160HMAC96;
		    break;

		case CRYPTO_MD5_KPDK:
		    sadb_comb->sadb_comb_auth = SADB_X_AALG_MD5;
		    break;

		case CRYPTO_SHA1_KPDK:
		    sadb_comb->sadb_comb_auth = SADB_X_AALG_SHA1;
		    break;
d1910 31
a1940 11

	    sadb_comb->sadb_comb_auth_minbits =
					   tdb->tdb_authalgxform->keysize * 8;
	    sadb_comb->sadb_comb_auth_maxbits =
					   tdb->tdb_authalgxform->keysize * 8;
	}
	else
	{
	    sadb_comb->sadb_comb_auth = 0;
	    sadb_comb->sadb_comb_auth_minbits = 0;
	    sadb_comb->sadb_comb_auth_maxbits = 0;
d1943 2
a1944 1
	if (tdb->tdb_encalgxform)
d1946 3
a1948 27
	    switch (tdb->tdb_encalgxform->type)
	    {
		case CRYPTO_DES_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_EALG_DESCBC;
		    break;

		case CRYPTO_3DES_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_EALG_3DESCBC;
		    break;

		case CRYPTO_CAST_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
		    break;

		case CRYPTO_BLF_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
		    break;

		case CRYPTO_SKIPJACK_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_SKIPJACK;
		    break;
	    }

	    sadb_comb->sadb_comb_encrypt_minbits =
					     tdb->tdb_encalgxform->minkey * 8;
	    sadb_comb->sadb_comb_encrypt_maxbits =
					     tdb->tdb_encalgxform->maxkey * 8;
d1951 17
a1967 8
	{
	    sadb_comb->sadb_comb_encrypt = 0;
	    sadb_comb->sadb_comb_encrypt_minbits = 0;
	    sadb_comb->sadb_comb_encrypt_maxbits = 0;
	}

	sadb_comb->sadb_comb_soft_allocations = tdb->tdb_soft_allocations;
	sadb_comb->sadb_comb_hard_allocations = tdb->tdb_exp_allocations;
d1969 2
a1970 2
	sadb_comb->sadb_comb_soft_bytes = tdb->tdb_soft_bytes;
	sadb_comb->sadb_comb_hard_bytes = tdb->tdb_exp_bytes;
d1972 2
a1973 2
	sadb_comb->sadb_comb_soft_addtime = tdb->tdb_soft_timeout;
	sadb_comb->sadb_comb_hard_addtime = tdb->tdb_exp_timeout;
d1975 2
a1976 2
	sadb_comb->sadb_comb_soft_usetime = tdb->tdb_soft_first_use;
	sadb_comb->sadb_comb_hard_usetime = tdb->tdb_exp_first_use;
d1980 3
a1982 5
    /*
     * Send the ACQUIRE message to all compliant registered listeners.
     * XXX We only send it to the first compliant registered
     * listener (as specified by the last argument)
     */
d1984 1
a1984 1
				    NULL, smsg->sadb_msg_satype, 1)) != 0)
a1987 1

@


1.37
log
@Big oops -- lucky us BLF and CAST are not used by anyone else (on the
other hand, the problem would have been noticed much earlier) --
noticed by bugfix@@163.net
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.36 2000/03/26 06:40:50 angelos Exp $ */
d1568 10
d1598 10
a1624 10
			if (flow->flow_proto)
			{
			    encapnetmask.sen_proto = 0xff;

			    if (flow->flow_src.sin.sin_port)
			      encapnetmask.sen_sport = 0xffff;

			    if (flow->flow_dst.sin.sin_port)
			      encapnetmask.sen_dport = 0xffff;
			}
a1636 10
			if (flow->flow_proto)
			{
			    encapnetmask.sen_ip6_proto = 0xff;

			    if (flow->flow_src.sin6.sin6_port)
			      encapnetmask.sen_ip6_sport = 0xffff;

			    if (flow->flow_dst.sin6.sin6_port)
			      encapnetmask.sen_ip6_dport = 0xffff;
			}
@


1.36
log
@Add RCS ID.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d253 1
a253 1
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_BLF;
d257 1
a257 1
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_CAST;
d2143 1
a2143 1
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
d2147 1
a2147 1
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
@


1.36.2.1
log
@Pull in two patches from current:
Fix (angelos,fgsch):
-- Fix a problem when deleting a flow via -delete. This only affects flows
using -transport; found by riq@@core-sdi.com, fix by angelos@@.
-- Big oops -- lucky us BLF and CAST are not used by anyone else (on the
other hand, the problem would have been noticed much earlier) --
noticed by bugfix@@163.net
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.36 2000/03/26 06:40:50 angelos Exp $ */
d253 1
a253 1
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_CAST;
d257 1
a257 1
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_BLF;
a1567 10
	  	    if (flow->flow_proto)
		    {
		        encapnetmask.sen_proto = 0xff;

		        if (flow->flow_src.sin.sin_port)
		          encapnetmask.sen_sport = 0xffff;

		        if (flow->flow_dst.sin.sin_port)
		          encapnetmask.sen_dport = 0xffff;
		    }
a1587 10
		    if (flow->flow_proto)
		    {
		        encapnetmask.sen_ip6_proto = 0xff;

		        if (flow->flow_src.sin6.sin6_port)
		          encapnetmask.sen_ip6_sport = 0xffff;

		        if (flow->flow_dst.sin6.sin6_port)
		          encapnetmask.sen_ip6_dport = 0xffff;
		    }
d1605 10
d1627 10
d2143 1
a2143 1
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
d2147 1
a2147 1
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
@


1.36.2.2
log
@Pull in patch from current:
Fix (angelos):
Send the message to registered promiscuous listeners.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.36.2.1 2000/09/01 13:50:31 jason Exp $ */
d685 1
a685 1
		  !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
@


1.35
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
@


1.34
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@d34 3
d214 24
a237 1
      sadb_sa->sadb_sa_auth = tdb->tdb_authalgxform->type;
d240 24
a263 1
      sadb_sa->sadb_sa_encrypt = tdb->tdb_encalgxform->type;
d2094 23
a2116 1
	    sadb_comb->sadb_comb_auth = tdb->tdb_authalgxform->type;
d2131 23
a2153 1
	    sadb_comb->sadb_comb_encrypt = tdb->tdb_encalgxform->type;
@


1.34.2.1
log
@Sync with -current
@
text
@a33 3
#include <crypto/blf.h>
#include <crypto/crypto.h>
#include <crypto/xform.h>
d211 1
a211 24
    {
	switch (tdb->tdb_authalgxform->type)
	{
	    case CRYPTO_MD5_HMAC96:
		sadb_sa->sadb_sa_auth = SADB_AALG_MD5HMAC96;
		break;

	    case CRYPTO_SHA1_HMAC96:
		sadb_sa->sadb_sa_auth = SADB_AALG_SHA1HMAC96;
		break;

	    case CRYPTO_RIPEMD160_HMAC96:
		sadb_sa->sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC96;
		break;

	    case CRYPTO_MD5_KPDK:
		sadb_sa->sadb_sa_auth = SADB_X_AALG_MD5;
		break;

	    case CRYPTO_SHA1_KPDK:
		sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA1;
		break;
	}
    }
d214 1
a214 24
    {
	switch (tdb->tdb_encalgxform->type)
	{
	    case CRYPTO_DES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_EALG_DESCBC;
		break;

	    case CRYPTO_3DES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_EALG_3DESCBC;
		break;

	    case CRYPTO_CAST_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_BLF;
		break;

	    case CRYPTO_BLF_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_CAST;
		break;

	    case CRYPTO_SKIPJACK_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_SKIPJACK;
		break;
	}
    }
d2045 1
a2045 23
	    switch (tdb->tdb_authalgxform->type)
	    {
		case CRYPTO_MD5_HMAC96:
		    sadb_comb->sadb_comb_auth = SADB_AALG_MD5HMAC96;
		    break;

		case CRYPTO_SHA1_HMAC96:
		    sadb_comb->sadb_comb_auth = SADB_AALG_SHA1HMAC96;
		    break;

		case CRYPTO_RIPEMD160_HMAC96:
		    sadb_comb->sadb_comb_auth = SADB_X_AALG_RIPEMD160HMAC96;
		    break;

		case CRYPTO_MD5_KPDK:
		    sadb_comb->sadb_comb_auth = SADB_X_AALG_MD5;
		    break;

		case CRYPTO_SHA1_KPDK:
		    sadb_comb->sadb_comb_auth = SADB_X_AALG_SHA1;
		    break;
	    }

d2060 1
a2060 23
	    switch (tdb->tdb_encalgxform->type)
	    {
		case CRYPTO_DES_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_EALG_DESCBC;
		    break;

		case CRYPTO_3DES_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_EALG_3DESCBC;
		    break;

		case CRYPTO_CAST_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
		    break;

		case CRYPTO_BLF_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
		    break;

		case CRYPTO_SKIPJACK_CBC:
		    sadb_comb->sadb_comb_encrypt = SADB_X_EALG_SKIPJACK;
		    break;
	    }

@


1.34.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 1
/* $OpenBSD: pfkeyv2.c,v 1.58 2001/03/28 20:03:01 angelos Exp $ */
d30 1
a31 1
#include <net/pfkeyv2.h>
d52 3
a54 4
    { SADB_X_EALG_BLF, 64, 40, BLF_MAXKEYLEN * 8},
    { SADB_X_EALG_CAST, 64, 40, 128},
    { SADB_X_EALG_SKIPJACK, 64, 80, 80},
    { SADB_X_EALG_AES, 128, 64, 256},
d59 3
a61 3
    { SADB_AALG_SHA1HMAC, 0, 160, 160 },
    { SADB_AALG_MD5HMAC, 0, 128, 128 },
    { SADB_AALG_RIPEMD160HMAC, 0, 160, 160 }
a66 1
void export_credentials(void **, struct tdb *, int);
a67 1
void export_key(void **, struct tdb *, int);
a72 1
void import_credentials(struct tdb *, struct sadb_cred *, int);
a76 1
int pfkeyv2_policy(struct ipsec_acquire *, void **, void **);
d80 2
a81 2
int pfkeyv2_dump_walker(struct tdb *, void *, int);
int pfkeyv2_flush_walker(struct tdb *, void *, int);
d209 1
a209 1

d217 2
a218 2
	    case CRYPTO_MD5_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_MD5HMAC;
d221 2
a222 2
	    case CRYPTO_SHA1_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_SHA1HMAC;
d225 2
a226 2
	    case CRYPTO_RIPEMD160_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
a250 4
	    case CRYPTO_AES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_AES;
		break;

d252 1
a252 1
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_CAST;
d256 1
a256 1
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_BLF;
d301 1
a301 1

d306 1
a306 1

d311 5
a315 4
		timeout_add(&tdb->tdb_timer_tmo, hz * tdb->tdb_exp_timeout);
	    } else
	        tdb->tdb_flags &= ~TDBF_TIMER;

d318 1
a318 4
	    {
	        tdb->tdb_flags |= TDBF_FIRSTUSE;
	        timeout_add(&tdb->tdb_first_tmo, hz * tdb->tdb_exp_first_use);
	    }
d320 1
a320 1
	        tdb->tdb_flags &= ~TDBF_FIRSTUSE;
d322 1
a322 1

d329 1
a329 1

d335 1
a335 1

d340 1
a340 1
		timeout_add(&tdb->tdb_stimer_tmo, hz * tdb->tdb_soft_timeout);
d344 1
a344 1

d347 1
a347 4
	    {
	        tdb->tdb_flags |= TDBF_SOFT_FIRSTUSE;
	        timeout_add(&tdb->tdb_sfirst_tmo, hz * tdb->tdb_soft_first_use);
	    }
d349 1
a349 1
	        tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
d351 1
a351 1

d359 3
d386 2
a387 1
	      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_exp_timeout;
d390 2
a391 1
	      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_exp_first_use;
d403 2
a404 1
	      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_soft_timeout;
d407 2
a408 1
	      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_soft_first_use;
d410 1
a410 1

a478 29
 * Import a set of credentials into the TDB.
 */
void
import_credentials(struct tdb *tdb, struct sadb_cred *sadb_cred, int dstcred)
{
    if (!sadb_cred)
      return;

    if (dstcred)
    {
	tdb->tdb_dst_cred_len = EXTLEN(sadb_cred) - sizeof(struct sadb_cred);
	tdb->tdb_dst_cred_type = sadb_cred->sadb_cred_type;
	MALLOC(tdb->tdb_dst_credentials, caddr_t, tdb->tdb_dst_cred_len,
	       M_XDATA, M_WAITOK);
	bcopy((void *) sadb_cred + sizeof(struct sadb_cred),
	      tdb->tdb_dst_credentials, tdb->tdb_dst_cred_len);
    }
    else
    {
	tdb->tdb_src_cred_len = EXTLEN(sadb_cred) - sizeof(struct sadb_cred);
	tdb->tdb_src_cred_type = sadb_cred->sadb_cred_type;
	MALLOC(tdb->tdb_src_credentials, caddr_t, tdb->tdb_src_cred_len,
	       M_XDATA, M_WAITOK);
	bcopy((void *) sadb_cred + sizeof(struct sadb_cred),
	      tdb->tdb_src_credentials, tdb->tdb_src_cred_len);
    }
}

/*
d494 1
a494 1
	bcopy((void *) sadb_ident + sizeof(struct sadb_ident),
d504 1
a504 1
	bcopy((void *) sadb_ident + sizeof(struct sadb_ident),
a509 27
export_credentials(void **p, struct tdb *tdb, int dstcred)
{
    struct sadb_cred *sadb_cred = (struct sadb_cred *) *p;

    if (dstcred)
    {
	sadb_cred->sadb_cred_len = (sizeof(struct sadb_cred) +
				    PADUP(tdb->tdb_dst_cred_len)) /
				   sizeof(uint64_t);
	sadb_cred->sadb_cred_type = tdb->tdb_dst_cred_type;
	*p += sizeof(struct sadb_cred);
	bcopy(tdb->tdb_dst_credentials, *p, tdb->tdb_dst_cred_len);
	*p += PADUP(tdb->tdb_dst_cred_len);
    }
    else
    {
	sadb_cred->sadb_cred_len = (sizeof(struct sadb_cred) +
				    PADUP(tdb->tdb_src_cred_len)) /
				   sizeof(uint64_t);
	sadb_cred->sadb_cred_type = tdb->tdb_src_cred_type;
	*p += sizeof(struct sadb_cred);
	bcopy(tdb->tdb_src_credentials, *p, tdb->tdb_src_cred_len);
	*p += PADUP(tdb->tdb_src_cred_len);
    }
}

void
d542 1
a542 1

a554 27
void
export_key(void **p, struct tdb *tdb, int type)
{
    struct sadb_key *sadb_key = (struct sadb_key *) *p;

    if (type == PFKEYV2_ENCRYPTION_KEY)
    {
	sadb_key->sadb_key_len = (sizeof(struct sadb_key) +
				  PADUP(tdb->tdb_emxkeylen)) /
				 sizeof(uint64_t);
	sadb_key->sadb_key_bits = tdb->tdb_emxkeylen * 8;
	*p += sizeof(struct sadb_key);
	bcopy(tdb->tdb_emxkey, *p, tdb->tdb_emxkeylen);
	*p += PADUP(tdb->tdb_emxkeylen);
    }
    else
    {
	sadb_key->sadb_key_len = (sizeof(struct sadb_key) +
				  PADUP(tdb->tdb_amxkeylen)) /
				 sizeof(uint64_t);
	sadb_key->sadb_key_bits = tdb->tdb_amxkeylen * 8;
	*p += sizeof(struct sadb_key);
	bcopy(tdb->tdb_amxkey, *p, tdb->tdb_amxkeylen);
	*p += PADUP(tdb->tdb_amxkeylen);
    }
}

d628 1
a628 1
	    /*
d656 5
a660 1
		          pfkey_sendup(s->socket, packet, 1);
d684 1
a684 1
		  !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
a709 168
 * Get SPD information for an ACQUIRE. We setup the message such that
 * the SRC/DST payloads are relative to us (regardless of whether the
 * SPD rule was for incoming or outgoing packets).
 */
int
pfkeyv2_policy(struct ipsec_acquire *ipa, void **headers, void **buffer)
{
    union sockaddr_union sunion;
    struct sadb_protocol *sp;
    int rval, i, dir;
    void *p;

    /* Find out how big a buffer we need */
    i = 4 * sizeof(struct sadb_address) + sizeof(struct sadb_protocol);
    bzero(&sunion, sizeof(union sockaddr_union));

    switch (ipa->ipa_info.sen_type)
    {
#ifdef INET
	case SENT_IP4:
	    i += 4 * PADUP(sizeof(struct sockaddr_in));
	    sunion.sa.sa_family = AF_INET;
	    sunion.sa.sa_len = sizeof(struct sockaddr_in);
	    dir = ipa->ipa_info.sen_direction;
	    break;
#endif /* INET */

#ifdef INET6
	case SENT_IP6:
	    i += 4 * PADUP(sizeof(struct sockaddr_in6));
	    sunion.sa.sa_family = AF_INET6;
	    sunion.sa.sa_len = sizeof(struct sockaddr_in6);
	    dir = ipa->ipa_info.sen_ip6_direction;
	    break;
#endif /* INET6 */

	default:
	    return EINVAL;
    }

    if (!(p = malloc(i, M_PFKEY, M_DONTWAIT)))
    {
	rval = ENOMEM;
	goto ret;
    }
    else
    {
	*buffer = p;
	bzero(p, i);
    }

    if (dir == IPSP_DIRECTION_OUT)
      headers[SADB_X_EXT_SRC_FLOW] = p;
    else
      headers[SADB_X_EXT_DST_FLOW] = p;
    switch (sunion.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    sunion.sin.sin_addr = ipa->ipa_info.sen_ip_src;
	    sunion.sin.sin_port = ipa->ipa_info.sen_sport;
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_src;
	    sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_sport;
	    break;
#endif /* INET6 */
    }
    export_address(&p, (struct sockaddr *) &sunion);

    if (dir == IPSP_DIRECTION_OUT)
      headers[SADB_X_EXT_SRC_MASK] = p;
    else
      headers[SADB_X_EXT_DST_MASK] = p;
    switch (sunion.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_src;
	    sunion.sin.sin_port = ipa->ipa_mask.sen_sport;
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_src;
	    sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_sport;
	    break;
#endif /* INET6 */
    }
    export_address(&p, (struct sockaddr *) &sunion);

    if (dir == IPSP_DIRECTION_OUT)
      headers[SADB_X_EXT_DST_FLOW] = p;
    else
      headers[SADB_X_EXT_SRC_FLOW] = p;
    switch (sunion.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    sunion.sin.sin_addr = ipa->ipa_info.sen_ip_dst;
	    sunion.sin.sin_port = ipa->ipa_info.sen_dport;
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_dst;
	    sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_dport;
	    break;
#endif /* INET6 */
    }
    export_address(&p, (struct sockaddr *) &sunion);

    if (dir == IPSP_DIRECTION_OUT)
      headers[SADB_X_EXT_DST_MASK] = p;
    else
      headers[SADB_X_EXT_SRC_MASK] = p;
    switch (sunion.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_dst;
	    sunion.sin.sin_port = ipa->ipa_mask.sen_dport;
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_dst;
	    sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_dport;
	    break;
#endif /* INET6 */
    }
    export_address(&p, (struct sockaddr *) &sunion);

    headers[SADB_X_EXT_FLOW_TYPE] = p;
    sp = p;
    sp->sadb_protocol_len = sizeof(struct sadb_protocol) / sizeof(u_int64_t);
    switch (sunion.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    if (ipa->ipa_mask.sen_proto)
	      sp->sadb_protocol_proto = ipa->ipa_info.sen_proto;
	    sp->sadb_protocol_direction = ipa->ipa_info.sen_direction;
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    if (ipa->ipa_mask.sen_ip6_proto)
	      sp->sadb_protocol_proto = ipa->ipa_info.sen_ip6_proto;
	    sp->sadb_protocol_direction = ipa->ipa_info.sen_ip6_direction;
	    break;
#endif /* INET6 */
    }

    rval = 0;

 ret:
    return rval;
}

/*
d806 1
a806 26
    /* Export credentials, if present */
    if (sa->tdb_src_credentials)
    {
	headers[SADB_X_EXT_SRC_CREDENTIALS] = p;
	export_credentials(&p, sa, 0);
    }

    if (sa->tdb_dst_credentials)
    {
	headers[SADB_X_EXT_DST_CREDENTIALS] = p;
	export_credentials(&p, sa, 1);
    }

    /* Export authentication key, if present */
    if (sa->tdb_amxkey)
    {
	headers[SADB_EXT_KEY_AUTH] = p;
	export_key(&p, sa, PFKEYV2_AUTHENTICATION_KEY);
    }

    /* Export encryption key, if present */
    if (sa->tdb_emxkey)
    {
	headers[SADB_EXT_KEY_ENCRYPT] = p;
	export_key(&p, sa, PFKEYV2_ENCRYPTION_KEY);
    }
d818 1
a818 1
pfkeyv2_dump_walker(struct tdb *sa, void *state, int last)
a834 3
	if (last)
	  ((struct sadb_msg *)headers[0])->sadb_msg_seq = 0;

d850 2
a851 2
int
pfkeyv2_flush_walker(struct tdb *sa, void *satype_vp, int last)
d855 1
a855 1
      tdb_delete(sa);
d876 1
a876 1
	    if(alg != NULL)
d887 1
a887 1
	    if(alg != NULL)
a923 3
    struct sockaddr_encap encapdst, encapnetmask, encapgw;
    struct ipsec_policy *ipo;
    struct ipsec_acquire *ipa;
d933 1
a938 1
    struct sadb_ident *sid;
d1001 1
a1001 1

d1069 3
a1071 1
		freeme = tdb_alloc();
d1077 1
a1077 1
		if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
a1102 4
		import_credentials(newsa, headers[SADB_X_EXT_SRC_CREDENTIALS],
				   0);
		import_credentials(newsa, headers[SADB_X_EXT_DST_CREDENTIALS],
				   1);
d1111 1
a1111 1
		    tdb_delete(freeme);
d1118 18
d1137 1
a1137 1
		tdb_delete(sa2);
d1196 2
a1197 1
	    freeme = tdb_alloc();
d1207 1
a1207 1
		if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
a1235 5
		import_credentials(newsa, headers[SADB_X_EXT_SRC_CREDENTIALS],
				   0);
		import_credentials(newsa, headers[SADB_X_EXT_DST_CREDENTIALS],
				   1);

d1243 1
a1243 1
		    tdb_delete(freeme);
d1270 3
a1272 2

	    tdb_delete(sa2);
a1278 15
	case SADB_X_ASKPOLICY:
	    /* Get the relevant policy */
	    ipa = ipsec_get_acquire(((struct sadb_policy *) headers[SADB_X_EXT_POLICY])->sadb_policy_seq);
	    if (ipa == NULL)
	    {
		rval = ESRCH;
		goto ret;
	    }

	    rval = pfkeyv2_policy(ipa, headers, &freeme);
	    if (rval)
	      mode = PFKEYV2_SENDMESSAGE_UNICAST;

	    break;

d1292 1
a1292 1

d1305 1
a1305 22
	    i = sizeof(struct sadb_supported) + sizeof(ealgs);

	    if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT)))
	    {
		rval = ENOMEM;
		goto ret;
	    }

	    bzero(freeme, i);

	    ssup = (struct sadb_supported *) freeme;
	    ssup->sadb_supported_len = i / sizeof(uint64_t);

	    {
		void *p = freeme + sizeof(struct sadb_supported);

		bcopy(&ealgs[0], p, sizeof(ealgs));
	    }

	    headers[SADB_EXT_SUPPORTED_ENCRYPT] = freeme;

	    i = sizeof(struct sadb_supported) + sizeof(aalgs);
d1312 1
a1312 1

d1315 1
a1315 1

d1320 4
d1329 2
d1333 2
a1334 3
	    headers[SADB_EXT_SUPPORTED_AUTH] = freeme;

	    break;
a1344 5
            s = spltdb();
            while ((ipo = TAILQ_FIRST(&ipsec_policy_head)) != NULL)
              ipsec_delete_policy(ipo);
            splx(s);

d1347 20
a1366 1
		case SADB_SATYPE_UNSPEC:
d1375 1
a1375 1
		    tdb_walk(pfkeyv2_flush_walker,
a1376 2

		    splx(s);
d1383 3
d1403 5
a1407 1
	case SADB_X_GRPSPIS:
d1409 6
a1414 3
	    struct tdb *tdb1, *tdb2, *tdb3;
	    struct sadb_protocol *sa_proto;

a1415 2
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));
d1417 6
a1422 1
	    s = spltdb();
d1424 8
a1431 3
	    tdb1 = gettdb(ssa->sadb_sa_spi, sunionp,
			  SADB_GETSPROTO(smsg->sadb_msg_satype));
	    if (tdb1 == NULL)
d1433 2
a1434 2
		rval = ESRCH;
		goto splxret;
d1437 7
a1443 2
	    ssa = (struct sadb_sa *) headers[SADB_X_EXT_SA2];
	    sunionp = (union sockaddr_union *) (headers[SADB_X_EXT_DST2] +
a1444 1
	    sa_proto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL]);
d1446 2
a1447 81
	    tdb2 = gettdb(ssa->sadb_sa_spi, sunionp,
			  SADB_GETSPROTO(sa_proto->sadb_protocol_proto));
	    if (tdb2 == NULL)
	    {
		rval = ESRCH;
		goto splxret;
	    }

	    /* Detect cycles */
	    for (tdb3 = tdb2; tdb3; tdb3 = tdb3->tdb_onext)
	      if (tdb3 == tdb1)
	      {
		  rval = ESRCH;
		  goto splxret;
	      }

	    /* Maintenance */
	    if ((tdb1->tdb_onext) &&
		(tdb1->tdb_onext->tdb_inext == tdb1))
	      tdb1->tdb_onext->tdb_inext = NULL;

	    if ((tdb2->tdb_inext) &&
		(tdb2->tdb_inext->tdb_onext == tdb2))
	      tdb2->tdb_inext->tdb_onext = NULL;

	    /* Link them */
	    tdb1->tdb_onext = tdb2;
	    tdb2->tdb_inext = tdb1;

	    splx(s);
	}
	 break;

	case SADB_X_DELFLOW:
	    delflag = 1;   /* fall through */

	case SADB_X_ADDFLOW:
	{
	    union sockaddr_union *src, *dst, *srcmask, *dstmask, *ssrc;
	    struct route_enc re;
	    u_int8_t transproto = 0;
	    u_int8_t direction;
	    int exists = 0;

	    direction = (((struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE])->sadb_protocol_direction);
            if ((direction != IPSP_DIRECTION_IN) &&
                (direction != IPSP_DIRECTION_OUT))
            {
		rval = EINVAL;
		goto ret;
            }

            /* If the security protocol wasn't specified, pretend it was ESP */
            if (smsg->sadb_msg_satype == 0)
              smsg->sadb_msg_satype = SADB_SATYPE_ESP;

	    if (headers[SADB_EXT_ADDRESS_DST])
	      sunionp = (union sockaddr_union *)
			(headers[SADB_EXT_ADDRESS_DST] +
			 sizeof(struct sadb_address));
	    else
	      sunionp = NULL;

	    if (headers[SADB_EXT_ADDRESS_SRC])
	      ssrc = (union sockaddr_union *)
		     (headers[SADB_EXT_ADDRESS_SRC] +
		      sizeof(struct sadb_address));
	    else
	      ssrc = NULL;

	    src = (union sockaddr_union *) (headers[SADB_X_EXT_SRC_FLOW] +
					    sizeof(struct sadb_address));
	    dst = (union sockaddr_union *) (headers[SADB_X_EXT_DST_FLOW] +
					    sizeof(struct sadb_address));
	    srcmask = (union sockaddr_union *) (headers[SADB_X_EXT_SRC_MASK] +
						sizeof(struct sadb_address));
	    dstmask = (union sockaddr_union *) (headers[SADB_X_EXT_DST_MASK] +
						sizeof(struct sadb_address));

	    /*
	     * Check that all the address families match. We know they are
d1455 1
a1455 1
		goto ret;
d1461 1
a1461 2

	    /* Transport protocol specified ? */
d1463 3
a1465 1
	      transproto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL])->sadb_protocol_proto;
d1471 77
d1549 2
a1550 4
	    encapdst.sen_family = encapnetmask.sen_family = PF_KEY;
	    encapdst.sen_len = encapnetmask.sen_len = SENT_LEN;

	    switch (src->sa.sa_family)
d1554 1
d1556 5
a1560 6
		    encapdst.sen_direction = direction;
		    encapdst.sen_ip_src = src->sin.sin_addr;
		    encapdst.sen_ip_dst = dst->sin.sin_addr;
		    encapdst.sen_proto = transproto;
		    encapdst.sen_sport = src->sin.sin_port;
		    encapdst.sen_dport = dst->sin.sin_port;
d1562 2
d1565 2
a1566 7
		    encapnetmask.sen_direction = 0xff;
		    encapnetmask.sen_ip_src = srcmask->sin.sin_addr;
		    encapnetmask.sen_ip_dst = dstmask->sin.sin_addr;
                    encapnetmask.sen_sport = srcmask->sin.sin_port;
                    encapnetmask.sen_dport = dstmask->sin.sin_port;
                    if (transproto)
                      encapnetmask.sen_proto = 0xff;
d1572 1
d1574 5
a1578 6
		    encapdst.sen_ip6_direction = direction;
		    encapdst.sen_ip6_src = src->sin6.sin6_addr;
		    encapdst.sen_ip6_dst = dst->sin6.sin6_addr;
		    encapdst.sen_ip6_proto = transproto;
		    encapdst.sen_ip6_sport = src->sin6.sin6_port;
		    encapdst.sen_ip6_dport = dst->sin6.sin6_port;
d1580 2
d1583 4
a1586 7
		    encapnetmask.sen_ip6_direction = 0xff;
		    encapnetmask.sen_ip6_src = srcmask->sin6.sin6_addr;
		    encapnetmask.sen_ip6_dst = dstmask->sin6.sin6_addr;
                    encapnetmask.sen_ip6_sport = srcmask->sin6.sin6_port;
                    encapnetmask.sen_ip6_dport = dstmask->sin6.sin6_port;
                    if (transproto)
                      encapnetmask.sen_ip6_proto = 0xff;
d1591 57
a1647 18
	    /* Determine whether the exact same SPD entry already exists. */
            bzero(&re, sizeof(struct route_enc));
	    bcopy(&encapdst, &re.re_dst, sizeof(struct sockaddr_encap));
	    rtalloc((struct route *) &re);

	    if (re.re_rt != NULL)
	    {
		ipo = ((struct sockaddr_encap *) re.re_rt->rt_gateway)->sen_ipsp;
		RTFREE(re.re_rt);

		/* Verify that the entry is identical */
		if (bcmp(&ipo->ipo_addr, &encapdst,
			 sizeof(struct sockaddr_encap)) ||
		    bcmp(&ipo->ipo_mask, &encapnetmask,
			 sizeof(struct sockaddr_encap)))
		  ipo = NULL; /* Fall through */
		else
		  exists = 1;
a1648 2
            else
              ipo = NULL;
d1650 1
a1650 1
	    /* Delete ? */
d1653 16
a1668 1
		if (exists)
d1670 6
a1675 4
		    s = spltdb();
		    rval = ipsec_delete_policy(ipo);
		    splx(s);
		    goto ret;
d1678 1
a1678 3
		/* If we were asked to delete something non-existant, error */
		rval = ESRCH;
		break;
d1680 15
d1696 8
a1703 6
	    if (!exists)
	    {
		/* Allocate policy entry */
		MALLOC(ipo, struct ipsec_policy *, sizeof(struct ipsec_policy),
		       M_TDB, M_NOWAIT);
		if (ipo == NULL)
d1706 1
a1706 2
		    goto ret;
		}
d1708 2
a1709 1
		bzero(ipo, sizeof(struct ipsec_policy));
d1711 2
a1712 5
		/* Finish initialization of SPD entry */
		encapgw.sen_len = SENT_LEN;
		encapgw.sen_family = PF_KEY;
		encapgw.sen_type = SENT_IPSP;
		encapgw.sen_ipsp = ipo;
d1714 1
a1714 5
		/* Initialize policy entry */
		bcopy(&encapdst, &ipo->ipo_addr,
		      sizeof(struct sockaddr_encap));
		bcopy(&encapnetmask, &ipo->ipo_mask,
		      sizeof(struct sockaddr_encap));
d1717 1
a1717 1
	    switch (((struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE])->sadb_protocol_proto)
d1719 2
a1720 3
		case FLOW_X_TYPE_USE:
		    ipo->ipo_type = IPSP_IPSEC_USE;
		    break;
d1722 3
a1724 3
		case FLOW_X_TYPE_ACQUIRE:
		    ipo->ipo_type = IPSP_IPSEC_ACQUIRE;
		    break;
d1726 18
a1743 3
		case FLOW_X_TYPE_REQUIRE:
		    ipo->ipo_type = IPSP_IPSEC_REQUIRE;
		    break;
d1745 7
a1751 3
		case FLOW_X_TYPE_DENY:
		    ipo->ipo_type = IPSP_DENY;
		    break;
d1753 3
a1755 3
		case FLOW_X_TYPE_BYPASS:
		    ipo->ipo_type = IPSP_PERMIT;
		    break;
d1757 1
a1757 3
		case FLOW_X_TYPE_DONTACQ:
		    ipo->ipo_type = IPSP_IPSEC_DONTACQ;
		    break;
d1759 6
a1764 12
		default:
                    if (!exists)
		      FREE(ipo, M_TDB);
                    else
		    {
			s = spltdb();
			ipsec_delete_policy(ipo);
			splx(s);
		    }

		    rval = EINVAL;
		    goto ret;
d1767 4
a1770 8
            if (sunionp)
	      bcopy(sunionp, &ipo->ipo_dst, sizeof(union sockaddr_union));
            else
            {
		bzero(&ipo->ipo_dst, sizeof(union sockaddr_union));
                ipo->ipo_dst.sa.sa_family = src->sa.sa_family;
                ipo->ipo_dst.sa.sa_len = src->sa.sa_len;
            }
d1772 3
a1774 3
	    if (ssrc)
	      bcopy(ssrc, &ipo->ipo_src, sizeof(union sockaddr_union));
	    else
d1776 2
a1777 3
		bzero(&ipo->ipo_src, sizeof(union sockaddr_union));
		ipo->ipo_src.sa.sa_family = src->sa.sa_family;
		ipo->ipo_src.sa.sa_len = src->sa.sa_len;
d1780 7
a1786 6
	    ipo->ipo_sproto = SADB_GETSPROTO(smsg->sadb_msg_satype);
	    if (ipo->ipo_srcid)
	    {
		FREE(ipo->ipo_srcid, M_TEMP);
		ipo->ipo_srcid = NULL;
	    }
d1788 4
a1791 5
	    if (ipo->ipo_dstid)
	    {
		FREE(ipo->ipo_dstid, M_TEMP);
		ipo->ipo_dstid = NULL;
	    }
d1793 3
a1795 4
	    if ((sid = headers[SADB_EXT_IDENTITY_SRC]) != NULL)
	    {
		ipo->ipo_srcid_type = sid->sadb_ident_type;
		ipo->ipo_srcid_len = (sid->sadb_ident_len * sizeof(u_int64_t)) - sizeof(struct sadb_ident);
d1797 3
a1799 15
		MALLOC(ipo->ipo_srcid, u_int8_t *, ipo->ipo_srcid_len,
		       M_TEMP, M_DONTWAIT);
		if (ipo->ipo_srcid == NULL)
		{
		    if (exists)
		    {
			s = spltdb();
			ipsec_delete_policy(ipo);
			splx(s);
		    }
		    else
		      FREE(ipo, M_TDB);
		    rval = ENOBUFS;
		    goto ret;
		}
d1801 2
a1802 2
		bcopy(sid + 1, ipo->ipo_srcid, ipo->ipo_srcid_len);
	    }
d1804 6
a1809 5
	    if ((sid = headers[SADB_EXT_IDENTITY_DST]) != NULL)
	    {
		ipo->ipo_dstid_type = sid->sadb_ident_type;
		ipo->ipo_dstid_len = (sid->sadb_ident_len * sizeof(u_int64_t)) -
				     sizeof(struct sadb_ident);
d1811 3
a1813 16
		MALLOC(ipo->ipo_dstid, u_int8_t *, ipo->ipo_dstid_len,
		       M_TEMP, M_DONTWAIT);
		if (ipo->ipo_dstid == NULL)
		{
		    if (exists)
		    {
			s = spltdb();
			ipsec_delete_policy(ipo);
			splx(s);
		    }
		    else
		    {
			if (ipo->ipo_dstid)
			  FREE(ipo->ipo_dstid, M_TEMP);
			FREE(ipo, M_TDB);
		    }
d1815 1
a1815 3
		    rval = ENOBUFS;
		    goto ret;
		}
d1817 6
a1822 1
		bcopy(sid + 1, ipo->ipo_dstid, ipo->ipo_dstid_len);
d1825 1
a1825 2
	    /* Flow type */
	    if (!exists)
d1827 4
a1830 15
		/* Add SPD entry */
		if ((rval = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				      (struct sockaddr *) &encapgw,
				      (struct sockaddr *) &encapnetmask,
				      RTF_UP | RTF_GATEWAY | RTF_STATIC,
				      (struct rtentry **) 0)) != 0)
		{
		    /* Remove from linked list of policies on TDB */
		    if (ipo->ipo_tdb)
		    {
			s = spltdb();
			TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
				     ipo_tdb_next);
			splx(s);
		    }
d1832 4
a1835 7
		    if (ipo->ipo_srcid)
		      FREE(ipo->ipo_srcid, M_TEMP);
		    if (ipo->ipo_dstid)
		      FREE(ipo->ipo_dstid, M_TEMP);
		    FREE(ipo, M_TDB); /* Free policy entry */
		    goto ret;
		}
d1837 7
a1843 3
		s = spltdb();
		TAILQ_INSERT_HEAD(&ipsec_policy_head, ipo, ipo_list);
		splx(s);
d1845 1
a1845 3
		ipsec_in_use++;
	    }
	    else
d1847 3
a1849 1
		ipo->ipo_last_searched = ipo->ipo_flags = 0;
d1851 13
a1863 1
         }
d1865 1
a1865 1

d1962 1
a1962 3
pfkeyv2_acquire(struct ipsec_policy *ipo, union sockaddr_union *gw,
		union sockaddr_union *laddr, u_int32_t *seq,
		struct sockaddr_encap *ddst)
d1964 1
a1964 3
    void *p, *headers[SADB_EXT_MAX + 1], *buffer = NULL;
    struct sadb_ident *srcid, *dstid;
    struct sadb_comb *sadb_comb;
d1966 2
d1969 1
a1969 1
    struct sadb_msg *smsg;
a1972 2
    *seq = pfkeyv2_seq++;

d1980 5
a1984 8
    i = sizeof(struct sadb_msg) +
        (laddr == NULL ? 0 : sizeof(struct sadb_address) +
                             PADUP(SA_LEN(&ipo->ipo_src.sa))) +
        sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa)) +
        sizeof(struct sadb_prop) + 1 * sizeof(struct sadb_comb);

    if (ipo->ipo_srcid)
      i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid_len);
d1986 2
a1987 2
    if (ipo->ipo_dstid)
      i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid_len);
d2008 2
a2009 1
    smsg->sadb_msg_seq = *seq;
d2011 9
a2019 17
    if (ipo->ipo_sproto == IPPROTO_ESP)
      smsg->sadb_msg_satype = SADB_SATYPE_ESP;
    else
      smsg->sadb_msg_satype = SADB_SATYPE_AH;

    if (laddr)
    {
        headers[SADB_EXT_ADDRESS_SRC] = p;
        p += sizeof(struct sadb_address) + PADUP(SA_LEN(&laddr->sa));
        sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_SRC];
        sadd->sadb_address_len = (sizeof(struct sadb_address) +
			         SA_LEN(&laddr->sa) +
			         sizeof(uint64_t) - 1) / sizeof(uint64_t);
        bcopy(laddr,
	      headers[SADB_EXT_ADDRESS_SRC] + sizeof(struct sadb_address),
	      SA_LEN(&laddr->sa));
    }
d2022 1
a2022 1
    p += sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa));
d2025 1
a2025 1
			      SA_LEN(&gw->sa) +
d2027 8
a2034 2
    bcopy(gw, headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address),
	  SA_LEN(&gw->sa));
d2036 4
a2039 1
    if (ipo->ipo_srcid)
d2041 5
a2045 9
	headers[SADB_EXT_IDENTITY_SRC] = p;
	p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid_len);
	srcid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_SRC];
	srcid->sadb_ident_len = (sizeof(struct sadb_ident) +
				 PADUP(ipo->ipo_srcid_len)) /
				sizeof(u_int64_t);
	srcid->sadb_ident_type = ipo->ipo_srcid_type;
	bcopy(ipo->ipo_srcid, headers[SADB_EXT_IDENTITY_SRC] +
	      sizeof(struct sadb_ident), ipo->ipo_srcid_len);
d2047 7
d2055 4
a2058 1
    if (ipo->ipo_dstid)
d2060 5
a2064 9
	headers[SADB_EXT_IDENTITY_DST] = p;
	p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid_len);
	dstid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_DST];
	dstid->sadb_ident_len = (sizeof(struct sadb_ident) +
				 PADUP(ipo->ipo_dstid_len)) /
				sizeof(u_int64_t);
	dstid->sadb_ident_type = ipo->ipo_dstid_type;
	bcopy(ipo->ipo_dstid, headers[SADB_EXT_IDENTITY_DST] +
	      sizeof(struct sadb_ident), ipo->ipo_dstid_len);
d2066 2
d2072 1
a2072 1
    sa_prop->sadb_prop_num = 1; /* XXX One proposal only */
a2078 1
    /* XXX Should actually ask the crypto layer what's supported */
d2083 1
a2083 1
	if (ipsec_require_pfs)
d2086 7
a2092 2
	/* Set the encryption algorithm */
	if (ipo->ipo_sproto == IPPROTO_ESP)
d2094 1
a2094 1
	    if (!strncasecmp(ipsec_def_enc, "aes", sizeof("aes")))
d2096 19
a2114 3
		sadb_comb->sadb_comb_encrypt = SADB_X_EALG_AES;
		sadb_comb->sadb_comb_encrypt_minbits = 64;
		sadb_comb->sadb_comb_encrypt_maxbits = 256;
d2116 11
a2126 38
	    else
	      if (!strncasecmp(ipsec_def_enc, "3des", sizeof("3des")))
	      {
		  sadb_comb->sadb_comb_encrypt = SADB_EALG_3DESCBC;
		  sadb_comb->sadb_comb_encrypt_minbits = 192;
		  sadb_comb->sadb_comb_encrypt_maxbits = 192;
	      }
	      else
		if (!strncasecmp(ipsec_def_enc, "des", sizeof("des")))
		{
		    sadb_comb->sadb_comb_encrypt = SADB_EALG_DESCBC;
		    sadb_comb->sadb_comb_encrypt_minbits = 64;
		    sadb_comb->sadb_comb_encrypt_maxbits = 64;
		}
		else
		  if (!strncasecmp(ipsec_def_enc, "blowfish",
				   sizeof("blowfish")))
		  {
		      sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
		      sadb_comb->sadb_comb_encrypt_minbits = 40;
		      sadb_comb->sadb_comb_encrypt_maxbits = BLF_MAXKEYLEN * 8;
		  }
		  else
		    if (!strncasecmp(ipsec_def_enc, "skipjack",
				     sizeof("skipjack")))
		    {
			sadb_comb->sadb_comb_encrypt = SADB_X_EALG_SKIPJACK;
			sadb_comb->sadb_comb_encrypt_minbits = 80;
			sadb_comb->sadb_comb_encrypt_maxbits = 80;
		    }
		    else
		      if (!strncasecmp(ipsec_def_enc, "cast128",
				       sizeof("cast128")))
		      {
			  sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
			  sadb_comb->sadb_comb_encrypt_minbits = 40;
			  sadb_comb->sadb_comb_encrypt_maxbits = 128;
		      }
d2129 1
a2129 2
	/* Set the authentication algorithm */
	if (!strncasecmp(ipsec_def_auth, "hmac-sha1", sizeof("hmac-sha1")))
d2131 27
a2157 3
	    sadb_comb->sadb_comb_auth = SADB_AALG_SHA1HMAC;
	    sadb_comb->sadb_comb_auth_minbits = 160;
	    sadb_comb->sadb_comb_auth_maxbits = 160;
d2160 5
a2164 17
	  if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
			   sizeof("hmac_ripemd160")))
	  {
	      sadb_comb->sadb_comb_auth = SADB_AALG_RIPEMD160HMAC;
	      sadb_comb->sadb_comb_auth_minbits = 160;
	      sadb_comb->sadb_comb_auth_maxbits = 160;
	  }
	  else
	    if (!strncasecmp(ipsec_def_auth, "hmac-md5", sizeof("hmac-md5")))
	    {
		sadb_comb->sadb_comb_auth = SADB_AALG_MD5HMAC;
		sadb_comb->sadb_comb_auth_minbits = 128;
		sadb_comb->sadb_comb_auth_maxbits = 128;
	    }

	sadb_comb->sadb_comb_soft_allocations = ipsec_soft_allocations;
	sadb_comb->sadb_comb_hard_allocations = ipsec_exp_allocations;
d2166 2
a2167 2
	sadb_comb->sadb_comb_soft_bytes = ipsec_soft_bytes;
	sadb_comb->sadb_comb_hard_bytes = ipsec_exp_bytes;
d2169 2
a2170 2
	sadb_comb->sadb_comb_soft_addtime = ipsec_soft_timeout;
	sadb_comb->sadb_comb_hard_addtime = ipsec_exp_timeout;
d2172 5
a2176 2
	sadb_comb->sadb_comb_soft_usetime = ipsec_soft_first_use;
	sadb_comb->sadb_comb_hard_usetime = ipsec_exp_first_use;
d2180 5
a2184 1
    /* Send the ACQUIRE message to all compliant registered listeners. */
d2186 1
a2186 1
				    NULL, smsg->sadb_msg_satype, 0)) != 0)
d2190 1
@


1.34.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 2
/* $OpenBSD$ */

d3 14
a16 38
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d18 1
a18 27
/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Craig Metz. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
d26 2
d30 1
d36 2
d66 26
d95 2
a96 1
extern struct pool ipsec_policy_pool;
d166 481
d993 2
a994 11
    if (sa->tdb_srcid)
      i += PADUP(sa->tdb_srcid->ref_len) + sizeof(struct sadb_ident);

    if (sa->tdb_dstid)
      i += PADUP(sa->tdb_dstid->ref_len) + sizeof(struct sadb_ident);

    if (sa->tdb_local_cred)
      i += PADUP(sa->tdb_local_cred->ref_len) + sizeof(struct sadb_x_cred);

    if (sa->tdb_remote_cred)
      i += PADUP(sa->tdb_remote_cred->ref_len) + sizeof(struct sadb_x_cred);
d996 2
a997 5
    if (sa->tdb_local_auth)
      i += PADUP(sa->tdb_local_auth->ref_len) + sizeof(struct sadb_x_cred);

    if (sa->tdb_remote_auth)
      i += PADUP(sa->tdb_remote_auth->ref_len) + sizeof(struct sadb_x_cred);
d1048 1
a1048 1
    if (sa->tdb_srcid)
d1055 1
a1055 1
    if (sa->tdb_dstid)
d1062 1
a1062 7
    if (sa->tdb_local_cred)
    {
	headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
	export_credentials(&p, sa, PFKEYV2_CRED_LOCAL);
    }

    if (sa->tdb_remote_cred)
d1064 2
a1065 2
	headers[SADB_X_EXT_REMOTE_CREDENTIALS] = p;
	export_credentials(&p, sa, PFKEYV2_CRED_REMOTE);
d1068 1
a1068 2
    /* Export authentication information, if present */
    if (sa->tdb_local_auth)
d1070 2
a1071 8
	headers[SADB_X_EXT_LOCAL_AUTH] = p;
	export_auth(&p, sa, PFKEYV2_AUTH_LOCAL);
    }

    if (sa->tdb_remote_auth)
    {
	headers[SADB_X_EXT_REMOTE_AUTH] = p;
	export_auth(&p, sa, PFKEYV2_AUTH_REMOTE);
d1338 1
a1338 1
			 SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d1387 5
a1391 10
		import_credentials(newsa,
				   headers[SADB_X_EXT_LOCAL_CREDENTIALS],
				   PFKEYV2_CRED_LOCAL);
		import_credentials(newsa,
				   headers[SADB_X_EXT_REMOTE_CREDENTIALS],
				   PFKEYV2_CRED_REMOTE);
		import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
			    PFKEYV2_AUTH_LOCAL);
		import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
			    PFKEYV2_AUTH_REMOTE);
a1393 3
		headers[SADB_X_EXT_LOCAL_AUTH] = NULL;

		newsa->tdb_seq = smsg->sadb_msg_seq;
d1449 1
a1449 1
			 SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d1505 5
a1509 10
		import_credentials(newsa,
				   headers[SADB_X_EXT_LOCAL_CREDENTIALS],
				   PFKEYV2_CRED_LOCAL);
		import_credentials(newsa,
				   headers[SADB_X_EXT_REMOTE_CREDENTIALS],
				   PFKEYV2_CRED_REMOTE);
		import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
			    PFKEYV2_AUTH_LOCAL);
		import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
			    PFKEYV2_AUTH_REMOTE);
a1511 3
		headers[SADB_X_EXT_LOCAL_AUTH] = NULL;

		newsa->tdb_seq = smsg->sadb_msg_seq;
d1538 1
a1538 1
			 SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d1554 1
a1554 1
	    ipa = ipsec_get_acquire(((struct sadb_x_policy *) headers[SADB_X_EXT_POLICY])->sadb_x_policy_seq);
d1574 1
a1574 1
			 SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d1704 1
a1704 1
			  SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d1717 1
a1717 1
			  SADB_X_GETSPROTO(sa_proto->sadb_protocol_proto));
a1754 1
	    struct sadb_protocol *sab;
d1757 1
d1760 3
a1762 4
	    sab = (struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE];

            if ((sab->sadb_protocol_direction != IPSP_DIRECTION_IN) &&
                (sab->sadb_protocol_direction != IPSP_DIRECTION_OUT))
d1828 1
a1828 1
		    encapdst.sen_direction = sab->sadb_protocol_direction;
d1849 1
a1849 1
		    encapdst.sen_ip6_direction = sab->sadb_protocol_direction;
d1871 1
a1872 3
	    s = spltdb();

	    rtalloc((struct route *) &re);
a1889 13
	    /*
	     * If the existing policy is static, only delete or update
	     * it if the new one is also static.
	     */
	    if (exists && (ipo->ipo_flags & IPSP_POLICY_STATIC))
	    {
		if (!(sab->sadb_protocol_flags & SADB_X_POLICYFLAGS_POLICY))
		{
		    splx(s);
		    goto ret;
		}
	    }

d1895 1
a1901 1
		splx(s);
a1907 8
		if (ipsec_policy_pool_initialized == 0)
		{
		    ipsec_policy_pool_initialized = 1;
		    pool_init(&ipsec_policy_pool, sizeof(struct ipsec_policy),
			      0, 0, PR_FREEHEADER, "ipsec policy", 0, NULL,
			      NULL, M_IPSEC_POLICY);
		}

d1909 2
a1910 1
		ipo = pool_get(&ipsec_policy_pool, 0);
a1912 1
		    splx(s);
a1917 1
		TAILQ_INIT(&ipo->ipo_acquires);
d1934 1
a1934 1
		case SADB_X_FLOW_TYPE_USE:
d1938 1
a1938 1
		case SADB_X_FLOW_TYPE_ACQUIRE:
d1942 1
a1942 1
		case SADB_X_FLOW_TYPE_REQUIRE:
d1946 1
a1946 1
		case SADB_X_FLOW_TYPE_DENY:
d1950 1
a1950 1
		case SADB_X_FLOW_TYPE_BYPASS:
d1954 1
a1954 1
		case SADB_X_FLOW_TYPE_DONTACQ:
d1960 1
a1960 1
			pool_put(&ipsec_policy_pool, ipo);
d1962 5
a1966 1
		      ipsec_delete_policy(ipo);
a1967 1
		    splx(s);
a1971 3
	    if (sab->sadb_protocol_flags & SADB_X_POLICYFLAGS_POLICY)
	      ipo->ipo_flags |= IPSP_POLICY_STATIC;

d1990 1
a1990 1
	    ipo->ipo_sproto = SADB_X_GETSPROTO(smsg->sadb_msg_satype);
d1993 1
a1993 1
	        ipsp_reffree(ipo->ipo_srcid);
d1999 1
a1999 1
		ipsp_reffree(ipo->ipo_dstid);
d2005 2
a2006 9
	        int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
		  sizeof(struct sadb_ident);

		MALLOC(ipo->ipo_srcid, struct ipsec_ref *, clen +
		       sizeof(struct ipsec_ref), M_CREDENTIALS, M_DONTWAIT);
		ipo->ipo_srcid->ref_type = sid->sadb_ident_type;
		ipo->ipo_srcid->ref_len = clen;
		ipo->ipo_srcid->ref_count = 1;
		ipo->ipo_srcid->ref_malloctype = M_CREDENTIALS;
d2008 2
d2013 5
a2017 1
		      ipsec_delete_policy(ipo);
d2019 1
a2019 2
		      pool_put(&ipsec_policy_pool, ipo);
		    splx(s);
d2024 1
a2024 1
		bcopy(sid + 1, ipo->ipo_srcid + 1, ipo->ipo_srcid->ref_len);
d2029 3
a2031 9
	        int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
		  sizeof(struct sadb_ident);

		MALLOC(ipo->ipo_dstid, struct ipsec_ref *, clen +
		       sizeof(struct ipsec_ref), M_CREDENTIALS, M_DONTWAIT);
		ipo->ipo_dstid->ref_type = sid->sadb_ident_type;
		ipo->ipo_dstid->ref_len = clen;
		ipo->ipo_dstid->ref_count = 1;
		ipo->ipo_dstid->ref_malloctype = M_CREDENTIALS;
d2033 2
d2038 5
a2042 1
		      ipsec_delete_policy(ipo);
d2046 2
a2047 2
			  ipsp_reffree(ipo->ipo_dstid);
			pool_put(&ipsec_policy_pool, ipo);
a2049 1
		    splx(s);
d2054 1
a2054 1
		bcopy(sid + 1, ipo->ipo_dstid + 1, ipo->ipo_dstid->ref_len);
d2069 6
a2074 2
		      TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
				   ipo_tdb_next);
d2077 1
a2077 1
		      ipsp_reffree(ipo->ipo_srcid);
d2079 2
a2080 4
		      ipsp_reffree(ipo->ipo_dstid);
		    pool_put(&ipsec_policy_pool, ipo);

		    splx(s);
d2084 1
d2086 2
d2094 1
a2094 3

	    splx(s);
	 }
d2222 1
a2222 1
      i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
d2225 1
a2225 1
      i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
d2278 1
a2278 1
	p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
d2281 1
a2281 1
				 PADUP(ipo->ipo_srcid->ref_len)) /
d2283 3
a2285 3
	srcid->sadb_ident_type = ipo->ipo_srcid->ref_type;
	bcopy(ipo->ipo_srcid + 1, headers[SADB_EXT_IDENTITY_SRC] +
	      sizeof(struct sadb_ident), ipo->ipo_srcid->ref_len);
d2291 1
a2291 1
	p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
d2294 1
a2294 1
				 PADUP(ipo->ipo_dstid->ref_len)) /
d2296 3
a2298 3
	dstid->sadb_ident_type = ipo->ipo_dstid->ref_type;
	bcopy(ipo->ipo_dstid + 1, headers[SADB_EXT_IDENTITY_DST] +
	      sizeof(struct sadb_ident), ipo->ipo_dstid->ref_len);
@


1.34.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.c,v 1.34.2.3 2001/07/04 10:54:15 niklas Exp $ */
a82 1
#include <netinet/ip_ipcomp.h>
a111 5
static struct sadb_alg calgs[] =
{
    { SADB_X_CALG_DEFLATE, 0, 0, 0},
};

a745 11
	case SADB_X_SATYPE_IPCOMP:
	    if (!ipcomp_enable)
		return EOPNOTSUPP;

	    *sproto = IPPROTO_IPCOMP;

	    if(alg != NULL)
		*alg = satype = XF_IPCOMP;

	    break;

a1216 21
	    i = sizeof(struct sadb_supported) + sizeof(calgs);

	    if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT)))
	    {
		rval = ENOMEM;
		goto ret;
	    }

	    bzero(freeme, i);

	    ssup = (struct sadb_supported *) freeme;
	    ssup->sadb_supported_len = i / sizeof(uint64_t);

	    {
		void *p = freeme + sizeof(struct sadb_supported);

		bcopy(&calgs[0], p, sizeof(calgs));
	    }

	    headers[SADB_X_EXT_SUPPORTED_COMP] = freeme;

d1228 5
a1235 5
		    s = spltdb();
		    while ((ipo = TAILQ_FIRST(&ipsec_policy_head)) != NULL)
		      ipsec_delete_policy(ipo);
		    splx(s);
		    /* Fall through */
a1238 1
		case SADB_X_SATYPE_IPCOMP:
d1854 1
a1854 1
    else if (ipo->ipo_sproto == IPPROTO_AH)
a1855 2
    else if (ipo->ipo_sproto == IPPROTO_IPCOMP)
      smsg->sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
a1971 11
	else if (ipo->ipo_sproto == IPPROTO_IPCOMP)
	{
	    /* Set the compression algorithm */
            if (!strncasecmp(ipsec_def_comp, "deflate", sizeof("deflate")))
            {
                sadb_comb->sadb_comb_encrypt = SADB_X_CALG_DEFLATE;
                sadb_comb->sadb_comb_encrypt = 0;
                sadb_comb->sadb_comb_encrypt = 0;
            }
        }

a2041 1
	case IPPROTO_IPCOMP:
@


1.34.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a554 6
    if (sa->tdb_amxkey)
	    i+= PADUP(sa->tdb_amxkeylen) + sizeof(struct sadb_key);

    if (sa->tdb_emxkey)
	    i+= PADUP(sa->tdb_emxkeylen) + sizeof(struct sadb_key);

d1546 2
a1547 1
			      0, 0, 0, "ipsec policy", NULL);
d2019 2
a2020 2
                sadb_comb->sadb_comb_encrypt_minbits = 0;
                sadb_comb->sadb_comb_encrypt_maxbits = 0;
@


1.34.2.6
log
@Sync the SMP branch with 3.3
@
text
@d96 8
a103 7
static const struct sadb_alg ealgs[] = {
	{ SADB_EALG_DESCBC, 64, 64, 64 },
	{ SADB_EALG_3DESCBC, 64, 192, 192 },
	{ SADB_X_EALG_BLF, 64, 40, BLF_MAXKEYLEN * 8},
	{ SADB_X_EALG_CAST, 64, 40, 128},
	{ SADB_X_EALG_SKIPJACK, 64, 80, 80},
	{ SADB_X_EALG_AES, 128, 64, 256},
d106 5
a110 4
static const struct sadb_alg aalgs[] = {
	{ SADB_AALG_SHA1HMAC, 0, 160, 160 },
	{ SADB_AALG_MD5HMAC, 0, 128, 128 },
	{ SADB_AALG_RIPEMD160HMAC, 0, 160, 160 }
d113 3
a115 3
static const struct sadb_alg calgs[] = {
	{ SADB_X_CALG_DEFLATE, 0, 0, 0},
	{ SADB_X_CALG_LZS, 0, 0, 0},
d128 6
a133 4
pfdatatopacket(void *data, int len, struct mbuf **packet) {
	if (!(*packet = m_devget(data, len, 0, NULL, NULL)))
		return (ENOMEM);
	return (0);
d140 7
a146 2
pfkeyv2_create(struct socket *socket) {
	struct pfkeyv2_socket *pfkeyv2_socket;
d148 4
a151 8
	if (!(pfkeyv2_socket = malloc(sizeof(struct pfkeyv2_socket),
	    M_PFKEY, M_DONTWAIT)))
		return (ENOMEM);

	bzero(pfkeyv2_socket, sizeof(struct pfkeyv2_socket));
	pfkeyv2_socket->next = pfkeyv2_sockets;
	pfkeyv2_socket->socket = socket;
	pfkeyv2_socket->pid = curproc->p_pid;
d153 1
a153 1
	pfkeyv2_sockets = pfkeyv2_socket;
d155 1
a155 1
	return (0);
d164 1
a164 1
	struct pfkeyv2_socket **pp;
d166 4
a169 3
	for (pp = &pfkeyv2_sockets; *pp && ((*pp)->socket != socket);
	    pp = &((*pp)->next))
		/*EMPTY*/;
d171 3
a173 2
	if (*pp) {
		struct pfkeyv2_socket *pfkeyv2_socket;
d175 2
a176 2
		pfkeyv2_socket = *pp;
		*pp = (*pp)->next;
d178 2
a179 2
		if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_REGISTERED)
			nregistered--;
d181 2
a182 2
		if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
			npromisc--;
d184 2
a185 2
		free(pfkeyv2_socket, M_PFKEY);
	}
d187 1
a187 1
	return (0);
d197 1
a197 1
    u_int8_t satype, int count)
d199 19
a217 33
	int i, j, rval;
	void *p, *buffer = NULL;
	struct mbuf *packet;
	struct pfkeyv2_socket *s;
	struct sadb_msg *smsg;

	/* Find out how much space we'll need... */
	j = sizeof(struct sadb_msg);

	for (i = 1; i <= SADB_EXT_MAX; i++)
		if (headers[i])
			j += ((struct sadb_ext *)headers[i])->sadb_ext_len *
			    sizeof(uint64_t);

	/* ...and allocate it */
	if (!(buffer = malloc(j + sizeof(struct sadb_msg), M_PFKEY,
	    M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	}

	p = buffer + sizeof(struct sadb_msg);
	bcopy(headers[0], p, sizeof(struct sadb_msg));
	((struct sadb_msg *) p)->sadb_msg_len = j / sizeof(uint64_t);
	p += sizeof(struct sadb_msg);

	/* Copy payloads in the packet */
	for (i = 1; i <= SADB_EXT_MAX; i++)
		if (headers[i]) {
			((struct sadb_ext *) headers[i])->sadb_ext_type = i;
			bcopy(headers[i], p, EXTLEN(headers[i]));
			p += EXTLEN(headers[i]);
		}
d219 17
a235 3
	if ((rval = pfdatatopacket(buffer + sizeof(struct sadb_msg),
	    j, &packet)) != 0)
		goto ret;
d237 2
a238 1
	switch (mode) {
d240 36
a275 36
		/*
		 * Send message to the specified socket, plus all
		 * promiscuous listeners.
		 */
		pfkey_sendup(socket, packet, 0);

		/*
		 * Promiscuous messages contain the original message
		 * encapsulated in another sadb_msg header.
		 */
		bzero(buffer, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) buffer;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + j) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = 0;

		/* Copy to mbuf chain */
		if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
		    &packet)) != 0)
			goto ret;

		/*
		 * Search for promiscuous listeners, skipping the
		 * original destination.
		 */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
			    (s->socket != socket))
				pfkey_sendup(s->socket, packet, 1);

		/* Done, let's be a bit paranoid */
		m_zero(packet);
		m_freem(packet);
		break;
d278 39
a316 14
		/*
		 * Send the message to all registered sockets that match
		 * the specified satype (e.g., all IPSEC-ESP negotiators)
		 */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED) {
				if (!satype)    /* Just send to everyone registered */
					pfkey_sendup(s->socket, packet, 1);
				else {
					/* Check for specified satype */
					if ((1 << satype) & s->registration)
						pfkey_sendup(s->socket, packet, 1);
				}
			}
d318 2
a319 25
		/* Free last/original copy of the packet */
		m_freem(packet);

		/* Encapsulate the original message "inside" an sadb_msg header */
		bzero(buffer, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) buffer;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + j) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = 0;

		/* Convert to mbuf chain */
		if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
		    &packet)) != 0)
			goto ret;

		/* Send to all registered promiscuous listeners */
		for (s = pfkeyv2_sockets; s; s = s->next)
			if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
			    !(s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
				pfkey_sendup(s->socket, packet, 1);

		m_freem(packet);
		break;
d322 7
a328 3
		/* Send message to all sockets */
		for (s = pfkeyv2_sockets; s; s = s->next)
			pfkey_sendup(s->socket, packet, 1);
d330 6
a335 3
		m_freem(packet);
		break;
	}
d337 1
a337 7
ret:
	if (buffer != NULL) {
		bzero(buffer, j + sizeof(struct sadb_msg));
		free(buffer, M_PFKEY);
	}

	return (rval);
d348 8
a355 8
	union sockaddr_union sunion;
	struct sadb_protocol *sp;
	int rval, i, dir;
	void *p;

	/* Find out how big a buffer we need */
	i = 4 * sizeof(struct sadb_address) + sizeof(struct sadb_protocol);
	bzero(&sunion, sizeof(union sockaddr_union));
d357 2
a358 1
	switch (ipa->ipa_info.sen_type) {
d361 5
a365 5
		i += 4 * PADUP(sizeof(struct sockaddr_in));
		sunion.sa.sa_family = AF_INET;
		sunion.sa.sa_len = sizeof(struct sockaddr_in);
		dir = ipa->ipa_info.sen_direction;
		break;
d370 5
a374 5
		i += 4 * PADUP(sizeof(struct sockaddr_in6));
		sunion.sa.sa_family = AF_INET6;
		sunion.sa.sa_len = sizeof(struct sockaddr_in6);
		dir = ipa->ipa_info.sen_ip6_direction;
		break;
d378 2
a379 2
		return (EINVAL);
	}
d381 10
a390 7
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	} else {
		*buffer = p;
		bzero(p, i);
	}
d392 6
a397 5
	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_SRC_FLOW] = p;
	else
		headers[SADB_X_EXT_DST_FLOW] = p;
	switch (sunion.sa.sa_family) {
d400 3
a402 3
		sunion.sin.sin_addr = ipa->ipa_info.sen_ip_src;
		sunion.sin.sin_port = ipa->ipa_info.sen_sport;
		break;
d407 3
a409 3
		sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_src;
		sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_sport;
		break;
d411 2
a412 2
	}
	export_address(&p, (struct sockaddr *) &sunion);
d414 6
a419 5
	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_SRC_MASK] = p;
	else
		headers[SADB_X_EXT_DST_MASK] = p;
	switch (sunion.sa.sa_family) {
d422 3
a424 3
		sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_src;
		sunion.sin.sin_port = ipa->ipa_mask.sen_sport;
		break;
d429 3
a431 3
		sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_src;
		sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_sport;
		break;
d433 2
a434 2
	}
	export_address(&p, (struct sockaddr *) &sunion);
d436 6
a441 5
	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_DST_FLOW] = p;
	else
		headers[SADB_X_EXT_SRC_FLOW] = p;
	switch (sunion.sa.sa_family) {
d444 3
a446 3
		sunion.sin.sin_addr = ipa->ipa_info.sen_ip_dst;
		sunion.sin.sin_port = ipa->ipa_info.sen_dport;
		break;
d451 3
a453 3
		sunion.sin6.sin6_addr = ipa->ipa_info.sen_ip6_dst;
		sunion.sin6.sin6_port = ipa->ipa_info.sen_ip6_dport;
		break;
d455 2
a456 2
	}
	export_address(&p, (struct sockaddr *) &sunion);
d458 6
a463 5
	if (dir == IPSP_DIRECTION_OUT)
		headers[SADB_X_EXT_DST_MASK] = p;
	else
		headers[SADB_X_EXT_SRC_MASK] = p;
	switch (sunion.sa.sa_family) {
d466 3
a468 3
		sunion.sin.sin_addr = ipa->ipa_mask.sen_ip_dst;
		sunion.sin.sin_port = ipa->ipa_mask.sen_dport;
		break;
d473 3
a475 3
		sunion.sin6.sin6_addr = ipa->ipa_mask.sen_ip6_dst;
		sunion.sin6.sin6_port = ipa->ipa_mask.sen_ip6_dport;
		break;
d477 2
a478 2
	}
	export_address(&p, (struct sockaddr *) &sunion);
d480 5
a484 5
	headers[SADB_X_EXT_FLOW_TYPE] = p;
	sp = p;
	sp->sadb_protocol_len = sizeof(struct sadb_protocol) /
	    sizeof(u_int64_t);
	switch (sunion.sa.sa_family) {
d487 4
a490 4
		if (ipa->ipa_mask.sen_proto)
			sp->sadb_protocol_proto = ipa->ipa_info.sen_proto;
		sp->sadb_protocol_direction = ipa->ipa_info.sen_direction;
		break;
d495 4
a498 4
		if (ipa->ipa_mask.sen_ip6_proto)
			sp->sadb_protocol_proto = ipa->ipa_info.sen_ip6_proto;
		sp->sadb_protocol_direction = ipa->ipa_info.sen_ip6_direction;
		break;
d500 1
a500 1
	}
d502 1
a502 1
	rval = 0;
d504 2
a505 2
ret:
	return (rval);
d514 2
a515 2
	int rval, i;
	void *p;
d517 2
a518 2
	/* Find how much space we need */
	i = sizeof(struct sadb_sa) + sizeof(struct sadb_lifetime);
d520 3
a522 3
	if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
	    sa->tdb_soft_timeout || sa->tdb_soft_first_use)
		i += sizeof(struct sadb_lifetime);
d524 3
a526 3
	if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
	    sa->tdb_exp_timeout || sa->tdb_exp_first_use)
		i += sizeof(struct sadb_lifetime);
d528 2
a529 2
	if (sa->tdb_src.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa));
d531 2
a532 2
	if (sa->tdb_dst.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
d534 2
a535 2
	if (sa->tdb_proxy.sa.sa_family)
		i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_proxy.sa));
d537 2
a538 2
	if (sa->tdb_srcid)
		i += PADUP(sa->tdb_srcid->ref_len) + sizeof(struct sadb_ident);
d540 2
a541 2
	if (sa->tdb_dstid)
		i += PADUP(sa->tdb_dstid->ref_len) + sizeof(struct sadb_ident);
d543 2
a544 2
	if (sa->tdb_local_cred)
		i += PADUP(sa->tdb_local_cred->ref_len) + sizeof(struct sadb_x_cred);
d546 2
a547 2
	if (sa->tdb_remote_cred)
		i += PADUP(sa->tdb_remote_cred->ref_len) + sizeof(struct sadb_x_cred);
d549 2
a550 2
	if (sa->tdb_local_auth)
		i += PADUP(sa->tdb_local_auth->ref_len) + sizeof(struct sadb_x_cred);
d552 2
a553 2
	if (sa->tdb_remote_auth)
		i += PADUP(sa->tdb_remote_auth->ref_len) + sizeof(struct sadb_x_cred);
d555 2
a556 2
	if (sa->tdb_amxkey)
		i+= PADUP(sa->tdb_amxkeylen) + sizeof(struct sadb_key);
d558 2
a559 2
	if (sa->tdb_emxkey)
		i+= PADUP(sa->tdb_emxkeylen) + sizeof(struct sadb_key);
d561 10
a570 7
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	} else {
		*buffer = p;
		bzero(p, i);
	}
d572 1
a572 1
	headers[SADB_EXT_SA] = p;
d574 1
a574 1
	export_sa(&p, sa);  /* Export SA information (mostly flags) */
d576 86
a661 75
	/* Export lifetimes where applicable */
	headers[SADB_EXT_LIFETIME_CURRENT] = p;
	export_lifetime(&p, sa, PFKEYV2_LIFETIME_CURRENT);

	if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
	    sa->tdb_soft_first_use || sa->tdb_soft_timeout) {
		headers[SADB_EXT_LIFETIME_SOFT] = p;
		export_lifetime(&p, sa, PFKEYV2_LIFETIME_SOFT);
	}

	if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
	    sa->tdb_exp_first_use || sa->tdb_exp_timeout) {
		headers[SADB_EXT_LIFETIME_HARD] = p;
		export_lifetime(&p, sa, PFKEYV2_LIFETIME_HARD);
	}

	/* Export TDB source address */
	headers[SADB_EXT_ADDRESS_SRC] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_src);

	/* Export TDB destination address */
	headers[SADB_EXT_ADDRESS_DST] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_dst);

	/* Export TDB proxy address, if present */
	if (SA_LEN(&sa->tdb_proxy.sa)) {
		headers[SADB_EXT_ADDRESS_PROXY] = p;
		export_address(&p, (struct sockaddr *) &sa->tdb_proxy);
	}

	/* Export source identity, if present */
	if (sa->tdb_srcid) {
		headers[SADB_EXT_IDENTITY_SRC] = p;
		export_identity(&p, sa, PFKEYV2_IDENTITY_SRC);
	}

	/* Export destination identity, if present */
	if (sa->tdb_dstid) {
		headers[SADB_EXT_IDENTITY_DST] = p;
		export_identity(&p, sa, PFKEYV2_IDENTITY_DST);
	}

	/* Export credentials, if present */
	if (sa->tdb_local_cred) {
		headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
		export_credentials(&p, sa, PFKEYV2_CRED_LOCAL);
	}

	if (sa->tdb_remote_cred) {
		headers[SADB_X_EXT_REMOTE_CREDENTIALS] = p;
		export_credentials(&p, sa, PFKEYV2_CRED_REMOTE);
	}

	/* Export authentication information, if present */
	if (sa->tdb_local_auth) {
		headers[SADB_X_EXT_LOCAL_AUTH] = p;
		export_auth(&p, sa, PFKEYV2_AUTH_LOCAL);
	}

	if (sa->tdb_remote_auth) {
		headers[SADB_X_EXT_REMOTE_AUTH] = p;
		export_auth(&p, sa, PFKEYV2_AUTH_REMOTE);
	}

	/* Export authentication key, if present */
	if (sa->tdb_amxkey) {
		headers[SADB_EXT_KEY_AUTH] = p;
		export_key(&p, sa, PFKEYV2_AUTHENTICATION_KEY);
	}

	/* Export encryption key, if present */
	if (sa->tdb_emxkey) {
		headers[SADB_EXT_KEY_ENCRYPT] = p;
		export_key(&p, sa, PFKEYV2_ENCRYPTION_KEY);
	}
d663 1
a663 1
	rval = 0;
d666 1
a666 1
	return (rval);
d675 17
a691 20
	struct dump_state *dump_state = (struct dump_state *) state;
	void *headers[SADB_EXT_MAX+1], *buffer;
	int rval;

	/* If not satype was specified, dump all TDBs */
	if (!dump_state->sadb_msg->sadb_msg_satype ||
	    (sa->tdb_satype == dump_state->sadb_msg->sadb_msg_satype)) {
		bzero(headers, sizeof(headers));
		headers[0] = (void *) dump_state->sadb_msg;

		/* Get the information from the TDB to a PFKEYv2 message */
		if ((rval = pfkeyv2_get(sa, headers, &buffer)) != 0)
			return (rval);

		if (last)
			((struct sadb_msg *)headers[0])->sadb_msg_seq = 0;

		/* Send the message to the specified socket */
		rval = pfkeyv2_sendmessage(headers,
		    PFKEYV2_SENDMESSAGE_UNICAST, dump_state->socket, 0, 0);
d693 8
a700 4
		free(buffer, M_PFKEY);
		if (rval)
			return (rval);
	}
d702 1
a702 1
	return (0);
d711 5
a715 4
	if (!(*((u_int8_t *) satype_vp)) ||
	    sa->tdb_satype == *((u_int8_t *) satype_vp))
		tdb_delete(sa);
	return (0);
d726 2
a727 1
	switch (satype) {
d729 2
a730 2
		if (!ah_enable)
			return (EOPNOTSUPP);
d732 1
a732 1
		*sproto = IPPROTO_AH;
d734 2
a735 2
		if(alg != NULL)
			*alg = satype = XF_AH;
d737 1
a737 1
		break;
d740 2
a741 2
		if (!esp_enable)
			return (EOPNOTSUPP);
d743 1
a743 1
		*sproto = IPPROTO_ESP;
d745 2
a746 2
		if(alg != NULL)
			*alg = satype = XF_ESP;
d748 1
a748 1
		break;
d751 1
a751 1
		*sproto = IPPROTO_IPIP;
d753 2
a754 2
		if (alg != NULL)
			*alg = XF_IP4;
d756 1
a756 1
		break;
d759 2
a760 2
		if (!ipcomp_enable)
			return (EOPNOTSUPP);
d762 1
a762 1
		*sproto = IPPROTO_IPCOMP;
d764 2
a765 2
		if(alg != NULL)
			*alg = satype = XF_IPCOMP;
d767 1
a767 1
		break;
d771 1
a771 1
		*sproto = IPPROTO_TCP;
d773 2
a774 2
		if (alg != NULL)
			*alg = XF_TCPSIGNATURE;
d776 1
a776 1
		break;
d780 2
a781 2
		return (EOPNOTSUPP);
	}
d783 1
a783 1
	return (0);
d792 4
a795 5
	int i, j, rval = 0, mode = PFKEYV2_SENDMESSAGE_BROADCAST;
	int delflag = 0, s;
	struct sockaddr_encap encapdst, encapnetmask, encapgw;
	struct ipsec_policy *ipo, *tmpipo;
	struct ipsec_acquire *ipa;
d797 1
a797 1
	struct pfkeyv2_socket *pfkeyv2_socket, *so = NULL;
d799 2
a800 2
	void *freeme = NULL, *bckptr = NULL;
	void *headers[SADB_EXT_MAX + 1];
d802 1
a802 1
	union sockaddr_union *sunionp;
d804 1
a804 1
	struct tdb sa, *sa2 = NULL;
d806 5
a810 5
	struct sadb_msg *smsg;
	struct sadb_spirange *sprng;
	struct sadb_sa *ssa;
	struct sadb_supported *ssup;
	struct sadb_ident *sid;
d812 2
a813 2
	/* Verify that we received this over a legitimate pfkeyv2 socket */
	bzero(headers, sizeof(headers));
d815 5
a819 4
	for (pfkeyv2_socket = pfkeyv2_sockets; pfkeyv2_socket;
	    pfkeyv2_socket = pfkeyv2_socket->next)
		if (pfkeyv2_socket->socket == socket)
			break;
d821 5
a825 4
	if (!pfkeyv2_socket) {
		rval = EINVAL;
		goto ret;
	}
d827 4
a830 3
	/* If we have any promiscuous listeners, send them a copy of the message */
	if (npromisc) {
		struct mbuf *packet;
d832 6
a837 5
		if (!(freeme = malloc(sizeof(struct sadb_msg) + len, M_PFKEY,
		    M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d839 40
a878 15
		/* Initialize encapsulating header */
		bzero(freeme, sizeof(struct sadb_msg));
		smsg = (struct sadb_msg *) freeme;
		smsg->sadb_msg_version = PF_KEY_V2;
		smsg->sadb_msg_type = SADB_X_PROMISC;
		smsg->sadb_msg_len = (sizeof(struct sadb_msg) + len) /
		    sizeof(uint64_t);
		smsg->sadb_msg_seq = curproc->p_pid;

		bcopy(message, freeme + sizeof(struct sadb_msg), len);

		/* Convert to mbuf chain */
		if ((rval = pfdatatopacket(freeme,
		    sizeof(struct sadb_msg) + len, &packet)) != 0)
			goto ret;
d880 26
a905 4
		/* Send to all promiscuous listeners */
		for (so = pfkeyv2_sockets; so; so = so->next)
			if (so->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
				pfkey_sendup(so->socket, packet, 1);
d907 8
a914 3
		/* Paranoid */
		m_zero(packet);
		m_freem(packet);
d916 16
a931 5
		/* Even more paranoid */
		bzero(freeme, sizeof(struct sadb_msg) + len);
		free(freeme, M_PFKEY);
		freeme = NULL;
	}
d933 6
a938 3
	/* Validate message format */
	if ((rval = pfkeyv2_parsemessage(message, len, headers)) != 0)
		goto ret;
d940 3
a942 4
	smsg = (struct sadb_msg *) headers[0];
	switch (smsg->sadb_msg_type) {
	case SADB_GETSPI:  /* Reserve an SPI */
		bzero(&sa, sizeof(struct tdb));
d944 2
a945 24
		sa.tdb_satype = smsg->sadb_msg_satype;
		if ((rval = pfkeyv2_get_proto_alg(sa.tdb_satype,
		    &sa.tdb_sproto, 0)))
			goto ret;

		import_address((struct sockaddr *) &sa.tdb_src,
		    headers[SADB_EXT_ADDRESS_SRC]);
		import_address((struct sockaddr *) &sa.tdb_dst,
		    headers[SADB_EXT_ADDRESS_DST]);

		/* Find an unused SA identifier */
		sprng = (struct sadb_spirange *) headers[SADB_EXT_SPIRANGE];
		sa.tdb_spi = reserve_spi(sprng->sadb_spirange_min,
		    sprng->sadb_spirange_max, &sa.tdb_src, &sa.tdb_dst,
		    sa.tdb_sproto, &rval);
		if (sa.tdb_spi == 0)
			goto ret;

		/* Send a message back telling what the SA (the SPI really) is */
		if (!(freeme = malloc(sizeof(struct sadb_sa), M_PFKEY,
		    M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d947 39
a985 4
		bzero(freeme, sizeof(struct sadb_sa));
		headers[SADB_EXT_SPIRANGE] = NULL;
		headers[SADB_EXT_SA] = freeme;
		bckptr = freeme;
d987 1
a987 3
		/* We really only care about the SPI, but we'll export the SA */
		export_sa((void **) &bckptr, &sa);
		break;
d989 7
a995 20
	case SADB_UPDATE:
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		/* Either all or none of the flow must be included */
		if ((headers[SADB_X_EXT_SRC_FLOW] ||
		    headers[SADB_X_EXT_PROTOCOL] ||
		    headers[SADB_X_EXT_FLOW_TYPE] ||
		    headers[SADB_X_EXT_DST_FLOW] ||
		    headers[SADB_X_EXT_SRC_MASK] ||
		    headers[SADB_X_EXT_DST_MASK]) &&
		    !(headers[SADB_X_EXT_SRC_FLOW] &&
		    headers[SADB_X_EXT_PROTOCOL] &&
		    headers[SADB_X_EXT_FLOW_TYPE] &&
		    headers[SADB_X_EXT_DST_FLOW] &&
		    headers[SADB_X_EXT_SRC_MASK] &&
		    headers[SADB_X_EXT_DST_MASK])) {
			rval = EINVAL;
			goto ret;
d998 1
a998 1
		s = spltdb();
d1000 21
a1020 8
		/* Find TDB */
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));

		/* If there's no such SA, we're done */
		if (sa2 == NULL) {
			rval = ESRCH;
			goto splxret;
d1023 11
a1033 103
		/* If this is a reserved SA */
		if (sa2->tdb_flags & TDBF_INVALID) {
			struct tdb *newsa;
			struct ipsecinit ii;
			int alg;

			/* Create new TDB */
			freeme = tdb_alloc();
			bzero(&ii, sizeof(struct ipsecinit));

			newsa = (struct tdb *) freeme;
			newsa->tdb_satype = smsg->sadb_msg_satype;

			if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
			    &newsa->tdb_sproto, &alg)))
				goto splxret;

			/* Initialize SA */
			import_sa(newsa, headers[SADB_EXT_SA], &ii);
			import_address((struct sockaddr *) &newsa->tdb_src,
			    headers[SADB_EXT_ADDRESS_SRC]);
			import_address((struct sockaddr *) &newsa->tdb_dst,
			    headers[SADB_EXT_ADDRESS_DST]);
			import_address((struct sockaddr *) &newsa->tdb_proxy,
			    headers[SADB_EXT_ADDRESS_PROXY]);
			import_lifetime(newsa,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);
			import_key(&ii, headers[SADB_EXT_KEY_AUTH],
			    PFKEYV2_AUTHENTICATION_KEY);
			import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT],
			    PFKEYV2_ENCRYPTION_KEY);
			import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC],
			    PFKEYV2_IDENTITY_SRC);
			import_identity(newsa, headers[SADB_EXT_IDENTITY_DST],
			    PFKEYV2_IDENTITY_DST);
			import_credentials(newsa,
			    headers[SADB_X_EXT_LOCAL_CREDENTIALS],
			    PFKEYV2_CRED_LOCAL);
			import_credentials(newsa,
			    headers[SADB_X_EXT_REMOTE_CREDENTIALS],
			    PFKEYV2_CRED_REMOTE);
			import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
			    PFKEYV2_AUTH_LOCAL);
			import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
			    PFKEYV2_AUTH_REMOTE);
			import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
			    headers[SADB_X_EXT_SRC_FLOW],
			    headers[SADB_X_EXT_SRC_MASK],
			    headers[SADB_X_EXT_DST_FLOW],
			    headers[SADB_X_EXT_DST_MASK],
			    headers[SADB_X_EXT_PROTOCOL],
			    headers[SADB_X_EXT_FLOW_TYPE]);

			headers[SADB_EXT_KEY_AUTH] = NULL;
			headers[SADB_EXT_KEY_ENCRYPT] = NULL;
			headers[SADB_X_EXT_LOCAL_AUTH] = NULL;

			newsa->tdb_seq = smsg->sadb_msg_seq;

			rval = tdb_init(newsa, alg, &ii);
			if (rval) {
				rval = EINVAL;
				tdb_delete(freeme);
				freeme = NULL;
				goto splxret;
			}

			newsa->tdb_cur_allocations = sa2->tdb_cur_allocations;

			/* Delete old version of the SA, insert new one */
			tdb_delete(sa2);
			puttdb((struct tdb *) freeme);
			sa2 = freeme = NULL;
		} else {
			/*
			 * The SA is already initialized, so we're only allowed to
			 * change lifetimes and some other information; we're
			 * not allowed to change keys, addresses or identities.
			 */
			if (headers[SADB_EXT_ADDRESS_PROXY] ||
			    headers[SADB_EXT_KEY_AUTH] ||
			    headers[SADB_EXT_KEY_ENCRYPT] ||
			    headers[SADB_EXT_IDENTITY_SRC] ||
			    headers[SADB_EXT_IDENTITY_DST] ||
			    headers[SADB_EXT_SENSITIVITY]) {
				rval = EINVAL;
				goto splxret;
			}

			import_sa(sa2, headers[SADB_EXT_SA], NULL);
			import_lifetime(sa2,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(sa2, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(sa2, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);
		}
a1034 2
		splx(s);
		break;
d1036 22
a1057 20
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		/* Either all or none of the flow must be included */
		if ((headers[SADB_X_EXT_SRC_FLOW] ||
		    headers[SADB_X_EXT_PROTOCOL] ||
		    headers[SADB_X_EXT_FLOW_TYPE] ||
		    headers[SADB_X_EXT_DST_FLOW] ||
		    headers[SADB_X_EXT_SRC_MASK] ||
		    headers[SADB_X_EXT_DST_MASK]) &&
		    !(headers[SADB_X_EXT_SRC_FLOW] &&
		    headers[SADB_X_EXT_PROTOCOL] &&
		    headers[SADB_X_EXT_FLOW_TYPE] &&
		    headers[SADB_X_EXT_DST_FLOW] &&
		    headers[SADB_X_EXT_SRC_MASK] &&
		    headers[SADB_X_EXT_DST_MASK])) {
			rval = EINVAL;
			goto ret;
		}
d1059 2
a1060 1
		s = spltdb();
d1062 50
a1111 2
		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
d1113 1
a1113 14
		/* We can't add an existing SA! */
		if (sa2 != NULL) {
			rval = EEXIST;
			goto splxret;
		}

		/* We can only add "mature" SAs */
		if (ssa->sadb_sa_state != SADB_SASTATE_MATURE) {
			rval = EINVAL;
			goto splxret;
		}

		/* Allocate and initialize new TDB */
		freeme = tdb_alloc();
d1115 2
d1118 4
a1121 68
			struct tdb *newsa = (struct tdb *) freeme;
			struct ipsecinit ii;
			int alg;

			bzero(&ii, sizeof(struct ipsecinit));

			newsa->tdb_satype = smsg->sadb_msg_satype;
			if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype,
			    &newsa->tdb_sproto, &alg)))
				goto splxret;

			import_sa(newsa, headers[SADB_EXT_SA], &ii);
			import_address((struct sockaddr *) &newsa->tdb_src,
			    headers[SADB_EXT_ADDRESS_SRC]);
			import_address((struct sockaddr *) &newsa->tdb_dst,
			    headers[SADB_EXT_ADDRESS_DST]);
			import_address((struct sockaddr *) &newsa->tdb_proxy,
			    headers[SADB_EXT_ADDRESS_PROXY]);

			import_lifetime(newsa,
			    headers[SADB_EXT_LIFETIME_CURRENT],
			    PFKEYV2_LIFETIME_CURRENT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT],
			    PFKEYV2_LIFETIME_SOFT);
			import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD],
			    PFKEYV2_LIFETIME_HARD);

			import_key(&ii, headers[SADB_EXT_KEY_AUTH],
			    PFKEYV2_AUTHENTICATION_KEY);
			import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT],
			    PFKEYV2_ENCRYPTION_KEY);

			import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC],
			    PFKEYV2_IDENTITY_SRC);
			import_identity(newsa, headers[SADB_EXT_IDENTITY_DST],
			    PFKEYV2_IDENTITY_DST);

			import_credentials(newsa,
			    headers[SADB_X_EXT_LOCAL_CREDENTIALS],
			    PFKEYV2_CRED_LOCAL);
			import_credentials(newsa,
			    headers[SADB_X_EXT_REMOTE_CREDENTIALS],
			    PFKEYV2_CRED_REMOTE);
			import_auth(newsa, headers[SADB_X_EXT_LOCAL_AUTH],
			    PFKEYV2_AUTH_LOCAL);
			import_auth(newsa, headers[SADB_X_EXT_REMOTE_AUTH],
			    PFKEYV2_AUTH_REMOTE);
			import_flow(&newsa->tdb_filter, &newsa->tdb_filtermask,
			    headers[SADB_X_EXT_SRC_FLOW],
			    headers[SADB_X_EXT_SRC_MASK],
			    headers[SADB_X_EXT_DST_FLOW],
			    headers[SADB_X_EXT_DST_MASK],
			    headers[SADB_X_EXT_PROTOCOL],
			    headers[SADB_X_EXT_FLOW_TYPE]);

			headers[SADB_EXT_KEY_AUTH] = NULL;
			headers[SADB_EXT_KEY_ENCRYPT] = NULL;
			headers[SADB_X_EXT_LOCAL_AUTH] = NULL;

			newsa->tdb_seq = smsg->sadb_msg_seq;

			rval = tdb_init(newsa, alg, &ii);
			if (rval) {
				rval = EINVAL;
				tdb_delete(freeme);
				freeme = NULL;
				goto splxret;
			}
d1123 1
d1125 2
a1126 2
		/* Add TDB in table */
		puttdb((struct tdb *) freeme);
d1128 1
a1128 1
		splx(s);
d1130 2
a1131 2
		freeme = NULL;
		break;
d1134 12
a1145 11
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));
		s = spltdb();

		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (sa2 == NULL) {
			rval = ESRCH;
			goto splxret;
		}
d1147 1
a1147 1
		tdb_delete(sa2);
d1149 1
a1149 1
		splx(s);
d1151 2
a1152 2
		sa2 = NULL;
		break;
d1155 7
a1161 6
		/* Get the relevant policy */
		ipa = ipsec_get_acquire(((struct sadb_x_policy *) headers[SADB_X_EXT_POLICY])->sadb_x_policy_seq);
		if (ipa == NULL) {
			rval = ESRCH;
			goto ret;
		}
d1163 3
a1165 3
		rval = pfkeyv2_policy(ipa, headers, &freeme);
		if (rval)
			mode = PFKEYV2_SENDMESSAGE_UNICAST;
d1167 1
a1167 1
		break;
d1170 12
a1181 11
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));
		s = spltdb();

		sa2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (sa2 == NULL) {
			rval = ESRCH;
			goto splxret;
		}
d1183 3
a1185 3
		rval = pfkeyv2_get(sa2, headers, &freeme);
		if (rval)
			mode = PFKEYV2_SENDMESSAGE_UNICAST;
d1187 1
a1187 1
		splx(s);
d1189 1
a1189 1
		break;
d1192 2
a1193 2
		pfkeyv2_socket->flags |= PFKEYV2_SOCKETFLAGS_REGISTERED;
		nregistered++;
d1195 1
a1195 1
		i = sizeof(struct sadb_supported) + sizeof(ealgs);
d1197 5
a1201 4
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d1203 1
a1203 1
		bzero(freeme, i);
d1205 2
a1206 2
		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);
d1208 2
a1209 2
		{
			void *p = freeme + sizeof(struct sadb_supported);
d1211 2
a1212 2
			bcopy(&ealgs[0], p, sizeof(ealgs));
		}
d1214 1
a1214 1
		headers[SADB_EXT_SUPPORTED_ENCRYPT] = freeme;
d1216 1
a1216 1
		i = sizeof(struct sadb_supported) + sizeof(aalgs);
d1218 5
a1222 4
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d1224 2
a1225 2
		/* Keep track what this socket has registered for */
		pfkeyv2_socket->registration |= (1 << ((struct sadb_msg *)message)->sadb_msg_satype);
d1227 1
a1227 1
		bzero(freeme, i);
d1229 2
a1230 2
		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);
d1232 2
a1233 2
		{
			void *p = freeme + sizeof(struct sadb_supported);
d1235 2
a1236 2
			bcopy(&aalgs[0], p, sizeof(aalgs));
		}
d1238 1
a1238 1
		headers[SADB_EXT_SUPPORTED_AUTH] = freeme;
d1240 1
a1240 1
		i = sizeof(struct sadb_supported) + sizeof(calgs);
d1242 5
a1246 4
		if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
			rval = ENOMEM;
			goto ret;
		}
d1248 1
a1248 1
		bzero(freeme, i);
d1250 2
a1251 2
		ssup = (struct sadb_supported *) freeme;
		ssup->sadb_supported_len = i / sizeof(uint64_t);
d1253 2
a1254 2
		{
			void *p = freeme + sizeof(struct sadb_supported);
d1256 2
a1257 2
			bcopy(&calgs[0], p, sizeof(calgs));
		}
d1259 1
a1259 1
		headers[SADB_X_EXT_SUPPORTED_COMP] = freeme;
d1261 1
a1261 1
		break;
d1265 3
a1267 3
		/* Nothing to handle */
		rval = 0;
		break;
d1270 1
a1270 1
		rval = 0;
d1272 2
a1273 1
		switch (smsg->sadb_msg_satype) {
d1275 5
a1279 14
			s = spltdb();

			/*
			 * Go through the list of policies, delete those that
			 * are not socket-attached.
			 */
			for (ipo = TAILQ_FIRST(&ipsec_policy_head);
			    ipo != NULL; ipo = tmpipo) {
				tmpipo = TAILQ_NEXT(ipo, ipo_list);
				if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
					ipsec_delete_policy(ipo);
			}
			splx(s);
			/* Fall through */
d1287 1
a1287 1
			s = spltdb();
d1289 2
a1290 2
			tdb_walk(pfkeyv2_flush_walker,
			    (u_int8_t *) &(smsg->sadb_msg_satype));
d1292 2
a1293 2
			splx(s);
			break;
d1296 2
a1297 2
			rval = EINVAL; /* Unknown/unsupported type */
		}
d1299 1
a1299 1
		break;
d1303 3
a1305 3
		struct dump_state dump_state;
		dump_state.sadb_msg = (struct sadb_msg *) headers[0];
		dump_state.socket = socket;
d1307 2
a1308 2
		if (!(rval = tdb_walk(pfkeyv2_dump_walker, &dump_state)))
			goto realret;
d1310 2
a1311 2
		if ((rval == ENOMEM) || (rval == ENOBUFS))
			rval = 0;
d1313 2
a1314 1
	break;
d1318 2
a1319 2
		struct tdb *tdb1, *tdb2, *tdb3;
		struct sadb_protocol *sa_proto;
d1321 13
a1333 12
		ssa = (struct sadb_sa *) headers[SADB_EXT_SA];
		sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
		    sizeof(struct sadb_address));

		s = spltdb();

		tdb1 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(smsg->sadb_msg_satype));
		if (tdb1 == NULL) {
			rval = ESRCH;
			goto splxret;
		}
d1335 12
a1346 11
		ssa = (struct sadb_sa *) headers[SADB_X_EXT_SA2];
		sunionp = (union sockaddr_union *) (headers[SADB_X_EXT_DST2] +
		    sizeof(struct sadb_address));
		sa_proto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL]);

		tdb2 = gettdb(ssa->sadb_sa_spi, sunionp,
		    SADB_X_GETSPROTO(sa_proto->sadb_protocol_proto));
		if (tdb2 == NULL) {
			rval = ESRCH;
			goto splxret;
		}
d1348 20
a1367 19
		/* Detect cycles */
		for (tdb3 = tdb2; tdb3; tdb3 = tdb3->tdb_onext)
			if (tdb3 == tdb1) {
				rval = ESRCH;
				goto splxret;
			}

		/* Maintenance */
		if ((tdb1->tdb_onext) &&
		    (tdb1->tdb_onext->tdb_inext == tdb1))
			tdb1->tdb_onext->tdb_inext = NULL;

		if ((tdb2->tdb_inext) &&
		    (tdb2->tdb_inext->tdb_onext == tdb2))
			tdb2->tdb_inext->tdb_onext = NULL;

		/* Link them */
		tdb1->tdb_onext = tdb2;
		tdb2->tdb_inext = tdb1;
d1369 1
a1369 1
		splx(s);
d1371 1
a1371 1
	break;
d1374 2
a1375 2
		delflag = 1;
		/*FALLTHROUGH*/
d1378 53
a1430 12
		struct sadb_protocol *sab;
		union sockaddr_union *ssrc;
		struct route_enc re;
		int exists = 0;

		sab = (struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE];

		if ((sab->sadb_protocol_direction != IPSP_DIRECTION_IN) &&
		    (sab->sadb_protocol_direction != IPSP_DIRECTION_OUT)) {
			rval = EINVAL;
			goto ret;
		}
d1432 15
a1446 10
		/* If the security protocol wasn't specified, pretend it was ESP */
		if (smsg->sadb_msg_satype == 0)
			smsg->sadb_msg_satype = SADB_SATYPE_ESP;

		if (headers[SADB_EXT_ADDRESS_DST])
			sunionp = (union sockaddr_union *)
			    (headers[SADB_EXT_ADDRESS_DST] +
				sizeof(struct sadb_address));
		else
			sunionp = NULL;
d1448 22
a1469 6
		if (headers[SADB_EXT_ADDRESS_SRC])
			ssrc = (union sockaddr_union *)
			    (headers[SADB_EXT_ADDRESS_SRC] +
				sizeof(struct sadb_address));
		else
			ssrc = NULL;
d1471 21
a1491 27
		import_flow(&encapdst, &encapnetmask,
		    headers[SADB_X_EXT_SRC_FLOW], headers[SADB_X_EXT_SRC_MASK],
		    headers[SADB_X_EXT_DST_FLOW], headers[SADB_X_EXT_DST_MASK],
		    headers[SADB_X_EXT_PROTOCOL], headers[SADB_X_EXT_FLOW_TYPE]);

		/* Determine whether the exact same SPD entry already exists. */
		bzero(&encapgw, sizeof(struct sockaddr_encap));
		bzero(&re, sizeof(struct route_enc));
		bcopy(&encapdst, &re.re_dst, sizeof(struct sockaddr_encap));

		s = spltdb();

		rtalloc((struct route *) &re);
		if (re.re_rt != NULL) {
			ipo = ((struct sockaddr_encap *) re.re_rt->rt_gateway)->sen_ipsp;
			RTFREE(re.re_rt);

			/* Verify that the entry is identical */
			if (bcmp(&ipo->ipo_addr, &encapdst,
				sizeof(struct sockaddr_encap)) ||
			    bcmp(&ipo->ipo_mask, &encapnetmask,
				sizeof(struct sockaddr_encap)))
				ipo = NULL; /* Fall through */
			else
				exists = 1;
		} else
			ipo = NULL;
d1493 34
a1526 10
		/*
		 * If the existing policy is static, only delete or update
		 * it if the new one is also static.
		 */
		if (exists && (ipo->ipo_flags & IPSP_POLICY_STATIC)) {
			if (!(sab->sadb_protocol_flags &
				SADB_X_POLICYFLAGS_POLICY)) {
				splx(s);
				goto ret;
			}
d1528 1
d1530 8
a1537 12
		/* Delete ? */
		if (delflag) {
			if (exists) {
				rval = ipsec_delete_policy(ipo);
				splx(s);
				goto ret;
			}

			/* If we were asked to delete something non-existant, error. */
			splx(s);
			rval = ESRCH;
			break;
d1540 13
a1552 31
		if (!exists) {
			if (ipsec_policy_pool_initialized == 0) {
				ipsec_policy_pool_initialized = 1;
				pool_init(&ipsec_policy_pool,
				    sizeof(struct ipsec_policy), 0, 0, 0,
				    "ipsec policy", NULL);
			}

			/* Allocate policy entry */
			ipo = pool_get(&ipsec_policy_pool, 0);
			if (ipo == NULL) {
				splx(s);
				rval = ENOMEM;
				goto ret;
			}

			bzero(ipo, sizeof(struct ipsec_policy));
			ipo->ipo_ref_count = 1;
			TAILQ_INIT(&ipo->ipo_acquires);

			/* Finish initialization of SPD entry */
			encapgw.sen_len = SENT_LEN;
			encapgw.sen_family = PF_KEY;
			encapgw.sen_type = SENT_IPSP;
			encapgw.sen_ipsp = ipo;

			/* Initialize policy entry */
			bcopy(&encapdst, &ipo->ipo_addr,
			    sizeof(struct sockaddr_encap));
			bcopy(&encapnetmask, &ipo->ipo_mask,
			    sizeof(struct sockaddr_encap));
d1555 27
a1581 1
		switch (((struct sadb_protocol *) headers[SADB_X_EXT_FLOW_TYPE])->sadb_protocol_proto) {
d1583 2
a1584 2
			ipo->ipo_type = IPSP_IPSEC_USE;
			break;
d1587 2
a1588 2
			ipo->ipo_type = IPSP_IPSEC_ACQUIRE;
			break;
d1591 2
a1592 2
			ipo->ipo_type = IPSP_IPSEC_REQUIRE;
			break;
d1595 2
a1596 2
			ipo->ipo_type = IPSP_DENY;
			break;
d1599 2
a1600 2
			ipo->ipo_type = IPSP_PERMIT;
			break;
d1603 2
a1604 2
			ipo->ipo_type = IPSP_IPSEC_DONTACQ;
			break;
d1607 55
a1661 9
			if (!exists)
				pool_put(&ipsec_policy_pool, ipo);
			else
				ipsec_delete_policy(ipo);

			splx(s);
			rval = EINVAL;
			goto ret;
		}
d1663 25
a1687 2
		if (sab->sadb_protocol_flags & SADB_X_POLICYFLAGS_POLICY)
			ipo->ipo_flags |= IPSP_POLICY_STATIC;
d1689 55
a1743 5
		if (sunionp)
			bcopy(sunionp, &ipo->ipo_dst,
			    sizeof(union sockaddr_union));
		else
			bzero(&ipo->ipo_dst, sizeof(union sockaddr_union));
d1745 4
a1748 5
		if (ssrc)
			bcopy(ssrc, &ipo->ipo_src,
			    sizeof(union sockaddr_union));
		else
			bzero(&ipo->ipo_src, sizeof(union sockaddr_union));
d1750 2
a1751 1
		ipo->ipo_sproto = SADB_X_GETSPROTO(smsg->sadb_msg_satype);
d1753 5
a1757 4
		if (ipo->ipo_srcid) {
			ipsp_reffree(ipo->ipo_srcid);
			ipo->ipo_srcid = NULL;
		}
d1759 8
a1766 3
		if (ipo->ipo_dstid) {
			ipsp_reffree(ipo->ipo_dstid);
			ipo->ipo_dstid = NULL;
d1769 3
a1771 21
		if ((sid = headers[SADB_EXT_IDENTITY_SRC]) != NULL) {
			int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
			    sizeof(struct sadb_ident);

			MALLOC(ipo->ipo_srcid, struct ipsec_ref *, clen +
			    sizeof(struct ipsec_ref), M_CREDENTIALS, M_DONTWAIT);
			if (ipo->ipo_srcid == NULL) {
				if (exists)
					ipsec_delete_policy(ipo);
				else
					pool_put(&ipsec_policy_pool, ipo);
				splx(s);
				rval = ENOBUFS;
				goto ret;
			}
			ipo->ipo_srcid->ref_type = sid->sadb_ident_type;
			ipo->ipo_srcid->ref_len = clen;
			ipo->ipo_srcid->ref_count = 1;
			ipo->ipo_srcid->ref_malloctype = M_CREDENTIALS;
			bcopy(sid + 1, ipo->ipo_srcid + 1, ipo->ipo_srcid->ref_len);
		}
d1773 12
a1784 26
		if ((sid = headers[SADB_EXT_IDENTITY_DST]) != NULL) {
			int clen =  (sid->sadb_ident_len * sizeof(u_int64_t)) -
			    sizeof(struct sadb_ident);

			MALLOC(ipo->ipo_dstid, struct ipsec_ref *,
			    clen + sizeof(struct ipsec_ref),
			    M_CREDENTIALS, M_DONTWAIT);
			if (ipo->ipo_dstid == NULL) {
				if (exists)
					ipsec_delete_policy(ipo);
				else {
					if (ipo->ipo_dstid)
						ipsp_reffree(ipo->ipo_dstid);
					pool_put(&ipsec_policy_pool, ipo);
				}

				splx(s);
				rval = ENOBUFS;
				goto ret;
			}
			ipo->ipo_dstid->ref_type = sid->sadb_ident_type;
			ipo->ipo_dstid->ref_len = clen;
			ipo->ipo_dstid->ref_count = 1;
			ipo->ipo_dstid->ref_malloctype = M_CREDENTIALS;
			bcopy(sid + 1, ipo->ipo_dstid + 1,
			    ipo->ipo_dstid->ref_len);
d1786 1
d1788 1
a1788 29
		/* Flow type */
		if (!exists) {
			/* Add SPD entry */
			if ((rval = rtrequest(RTM_ADD,
				 (struct sockaddr *) &encapdst,
				 (struct sockaddr *) &encapgw,
				 (struct sockaddr *) &encapnetmask,
				 RTF_UP | RTF_GATEWAY | RTF_STATIC,
				 (struct rtentry **) 0)) != 0) {
				/* Remove from linked list of policies on TDB */
				if (ipo->ipo_tdb)
					TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head,
					    ipo, ipo_tdb_next);

				if (ipo->ipo_srcid)
					ipsp_reffree(ipo->ipo_srcid);
				if (ipo->ipo_dstid)
					ipsp_reffree(ipo->ipo_dstid);
				pool_put(&ipsec_policy_pool, ipo);

				splx(s);
				goto ret;
			}

			TAILQ_INSERT_HEAD(&ipsec_policy_head, ipo, ipo_list);
			ipsec_in_use++;
		} else {
			ipo->ipo_last_searched = ipo->ipo_flags = 0;
		}
d1790 4
a1793 3
		splx(s);
	}
	break;
d1795 5
a1799 3
	case SADB_X_PROMISC:
		if (len >= 2 * sizeof(struct sadb_msg)) {
			struct mbuf *packet;
d1801 2
a1802 2
			if ((rval = pfdatatopacket(message, len, &packet)) != 0)
				goto ret;
d1804 5
a1808 30
			for (so = pfkeyv2_sockets; so; so = so->next)
				if ((so != pfkeyv2_socket) &&
				    (!smsg->sadb_msg_seq ||
				    (smsg->sadb_msg_seq == pfkeyv2_socket->pid)))
					pfkey_sendup(so->socket, packet, 1);

			m_freem(packet);
		} else {
			if (len != sizeof(struct sadb_msg)) {
				rval = EINVAL;
				goto ret;
			}

			i = (pfkeyv2_socket->flags &
			    PFKEYV2_SOCKETFLAGS_PROMISC) ? 1 : 0;
			j = smsg->sadb_msg_satype ? 1 : 0;

			if (i ^ j) {
				if (j) {
					pfkeyv2_socket->flags |=
					    PFKEYV2_SOCKETFLAGS_PROMISC;
					npromisc++;
				}
			} else {
				pfkeyv2_socket->flags &=
				    ~PFKEYV2_SOCKETFLAGS_PROMISC;
				npromisc--;
			}
		}
	
d1810 3
a1812 1
		break;
d1814 2
a1815 4
	default:
		rval = EINVAL;
		goto ret;
	}
d1817 4
a1820 24
ret:
	if (rval) {
		if ((rval == EINVAL) || (rval == ENOMEM) || (rval == ENOBUFS))
			goto realret;

		for (i = 1; i <= SADB_EXT_MAX; i++)
			headers[i] = NULL;

		smsg->sadb_msg_errno = abs(rval);
	} else {
		uint32_t seen = 0;

		for (i = 1; i <= SADB_EXT_MAX; i++)
			if (headers[i])
				seen |= (1 << i);

		if ((seen & sadb_exts_allowed_out[smsg->sadb_msg_type])
		    != seen)
			goto realret;

		if ((seen & sadb_exts_required_out[smsg->sadb_msg_type]) !=
		    sadb_exts_required_out[smsg->sadb_msg_type])
			goto realret;
	}
d1822 1
a1822 1
	rval = pfkeyv2_sendmessage(headers, mode, socket, 0, 0);
d1825 2
a1826 2
	if (freeme)
		free(freeme, M_PFKEY);
d1828 1
a1828 1
	free(message, M_PFKEY);
d1830 1
a1830 1
	return (rval);
d1833 2
a1834 2
	splx(s);
	goto ret;
d1845 16
a1860 9
	void *p, *headers[SADB_EXT_MAX + 1], *buffer = NULL;
	struct sadb_ident *srcid, *dstid;
	struct sadb_x_cred *lcred, *lauth;
	struct sadb_comb *sadb_comb;
	struct sadb_address *sadd;
	struct sadb_prop *sa_prop;
	struct sadb_msg *smsg;
	int rval = 0;
	int i, j;
d1862 19
a1880 1
	*seq = pfkeyv2_seq++;
d1882 1
a1882 4
	if (!nregistered) {
		rval = ESRCH;
		goto ret;
	}
d1884 2
a1885 9
	/* How large a buffer do we need... XXX we only do one proposal for now */
	i = sizeof(struct sadb_msg) +
	    (laddr == NULL ? 0 : sizeof(struct sadb_address) +
		PADUP(SA_LEN(&ipo->ipo_src.sa))) +
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa)) +
	    sizeof(struct sadb_prop) + 1 * sizeof(struct sadb_comb);

	if (ipo->ipo_srcid)
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
d1887 78
a1964 2
	if (ipo->ipo_dstid)
		i += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
d1966 2
d1969 1
a1969 20
	/* Allocate */
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	}

	bzero(headers, sizeof(headers));

	buffer = p;
	bzero(p, i);

	headers[0] = p;
	p += sizeof(struct sadb_msg);

	smsg = (struct sadb_msg *) headers[0];
	smsg->sadb_msg_version = PF_KEY_V2;
	smsg->sadb_msg_type = SADB_ACQUIRE;
	smsg->sadb_msg_len = i / sizeof(uint64_t);
	smsg->sadb_msg_seq = *seq;

d1971 20
a1990 60
		smsg->sadb_msg_satype = SADB_SATYPE_ESP;
	else if (ipo->ipo_sproto == IPPROTO_AH)
		smsg->sadb_msg_satype = SADB_SATYPE_AH;
	else if (ipo->ipo_sproto == IPPROTO_IPCOMP)
		smsg->sadb_msg_satype = SADB_X_SATYPE_IPCOMP;

	if (laddr) {
		headers[SADB_EXT_ADDRESS_SRC] = p;
		p += sizeof(struct sadb_address) + PADUP(SA_LEN(&laddr->sa));
		sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_SRC];
		sadd->sadb_address_len = (sizeof(struct sadb_address) +
		    SA_LEN(&laddr->sa) + sizeof(uint64_t) - 1) /
		    sizeof(uint64_t);
		bcopy(laddr, headers[SADB_EXT_ADDRESS_SRC] +
		    sizeof(struct sadb_address), SA_LEN(&laddr->sa));
	}

	headers[SADB_EXT_ADDRESS_DST] = p;
	p += sizeof(struct sadb_address) + PADUP(SA_LEN(&gw->sa));
	sadd = (struct sadb_address *) headers[SADB_EXT_ADDRESS_DST];
	sadd->sadb_address_len = (sizeof(struct sadb_address) +
	    SA_LEN(&gw->sa) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
	bcopy(gw, headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address),
	    SA_LEN(&gw->sa));

	if (ipo->ipo_srcid) {
		headers[SADB_EXT_IDENTITY_SRC] = p;
		p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_srcid->ref_len);
		srcid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_SRC];
		srcid->sadb_ident_len = (sizeof(struct sadb_ident) +
		    PADUP(ipo->ipo_srcid->ref_len)) / sizeof(u_int64_t);
		srcid->sadb_ident_type = ipo->ipo_srcid->ref_type;
		bcopy(ipo->ipo_srcid + 1, headers[SADB_EXT_IDENTITY_SRC] +
		    sizeof(struct sadb_ident), ipo->ipo_srcid->ref_len);
	}

	if (ipo->ipo_dstid) {
		headers[SADB_EXT_IDENTITY_DST] = p;
		p += sizeof(struct sadb_ident) + PADUP(ipo->ipo_dstid->ref_len);
		dstid = (struct sadb_ident *) headers[SADB_EXT_IDENTITY_DST];
		dstid->sadb_ident_len = (sizeof(struct sadb_ident) +
		    PADUP(ipo->ipo_dstid->ref_len)) / sizeof(u_int64_t);
		dstid->sadb_ident_type = ipo->ipo_dstid->ref_type;
		bcopy(ipo->ipo_dstid + 1, headers[SADB_EXT_IDENTITY_DST] +
		    sizeof(struct sadb_ident), ipo->ipo_dstid->ref_len);
	}

	if (ipo->ipo_local_cred) {
		headers[SADB_X_EXT_LOCAL_CREDENTIALS] = p;
		p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_cred->ref_len);
		lcred = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_CREDENTIALS];
		lcred->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
		    PADUP(ipo->ipo_local_cred->ref_len)) / sizeof(u_int64_t);
		switch (ipo->ipo_local_cred->ref_type) {
		case IPSP_CRED_KEYNOTE:
			lcred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
			break;
		case IPSP_CRED_X509:
			lcred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
			break;
d1992 24
a2015 2
		bcopy(ipo->ipo_local_cred + 1, headers[SADB_X_EXT_LOCAL_CREDENTIALS] +
		    sizeof(struct sadb_x_cred), ipo->ipo_local_cred->ref_len);
d2018 10
a2027 14
	if (ipo->ipo_local_auth) {
		headers[SADB_X_EXT_LOCAL_AUTH] = p;
		p += sizeof(struct sadb_x_cred) + PADUP(ipo->ipo_local_auth->ref_len);
		lauth = (struct sadb_x_cred *) headers[SADB_X_EXT_LOCAL_AUTH];
		lauth->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
		    PADUP(ipo->ipo_local_auth->ref_len)) / sizeof(u_int64_t);
		switch (ipo->ipo_local_auth->ref_type) {
		case IPSP_AUTH_PASSPHRASE:
			lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_PASSPHRASE;
			break;
		case IPSP_AUTH_RSA:
			lauth->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
			break;
		}
d2029 6
a2034 99
		bcopy(ipo->ipo_local_auth + 1, headers[SADB_X_EXT_LOCAL_AUTH] +
		    sizeof(struct sadb_x_cred), ipo->ipo_local_auth->ref_len);
	}

	headers[SADB_EXT_PROPOSAL] = p;
	p += sizeof(struct sadb_prop);
	sa_prop = (struct sadb_prop *) headers[SADB_EXT_PROPOSAL];
	sa_prop->sadb_prop_num = 1; /* XXX One proposal only */
	sa_prop->sadb_prop_len = (sizeof(struct sadb_prop) +
	    (sizeof(struct sadb_comb) * sa_prop->sadb_prop_num)) /
	    sizeof(uint64_t);

	sadb_comb = p;

	/* XXX Should actually ask the crypto layer what's supported */
	for (j = 0; j < sa_prop->sadb_prop_num; j++) {
		sadb_comb->sadb_comb_flags = 0;

		if (ipsec_require_pfs)
			sadb_comb->sadb_comb_flags |= SADB_SAFLAGS_PFS;

		/* Set the encryption algorithm */
		if (ipo->ipo_sproto == IPPROTO_ESP) {
			if (!strncasecmp(ipsec_def_enc, "aes",
			    sizeof("aes"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_AES;
				sadb_comb->sadb_comb_encrypt_minbits = 64;
				sadb_comb->sadb_comb_encrypt_maxbits = 256;
			} else if (!strncasecmp(ipsec_def_enc, "3des",
			    sizeof("3des"))) {
				sadb_comb->sadb_comb_encrypt = SADB_EALG_3DESCBC;
				sadb_comb->sadb_comb_encrypt_minbits = 192;
				sadb_comb->sadb_comb_encrypt_maxbits = 192;
			} else if (!strncasecmp(ipsec_def_enc, "des",
			    sizeof("des"))) {
				sadb_comb->sadb_comb_encrypt = SADB_EALG_DESCBC;
				sadb_comb->sadb_comb_encrypt_minbits = 64;
				sadb_comb->sadb_comb_encrypt_maxbits = 64;
			} else if (!strncasecmp(ipsec_def_enc, "blowfish",
			    sizeof("blowfish"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_BLF;
				sadb_comb->sadb_comb_encrypt_minbits = 40;
				sadb_comb->sadb_comb_encrypt_maxbits = BLF_MAXKEYLEN * 8;
			} else if (!strncasecmp(ipsec_def_enc, "skipjack",
			    sizeof("skipjack"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_SKIPJACK;
				sadb_comb->sadb_comb_encrypt_minbits = 80;
				sadb_comb->sadb_comb_encrypt_maxbits = 80;
			} else if (!strncasecmp(ipsec_def_enc, "cast128",
			    sizeof("cast128"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_EALG_CAST;
				sadb_comb->sadb_comb_encrypt_minbits = 40;
				sadb_comb->sadb_comb_encrypt_maxbits = 128;
			}
		} else if (ipo->ipo_sproto == IPPROTO_IPCOMP) {
			/* Set the compression algorithm */
			if (!strncasecmp(ipsec_def_comp, "deflate",
			    sizeof("deflate"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_CALG_DEFLATE;
				sadb_comb->sadb_comb_encrypt_minbits = 0;
				sadb_comb->sadb_comb_encrypt_maxbits = 0;
			} else if (!strncasecmp(ipsec_def_comp, "lzs",
			    sizeof("lzs"))) {
				sadb_comb->sadb_comb_encrypt = SADB_X_CALG_LZS;
				sadb_comb->sadb_comb_encrypt_minbits = 0;
				sadb_comb->sadb_comb_encrypt_maxbits = 0;
			}
		}

		/* Set the authentication algorithm */
		if (!strncasecmp(ipsec_def_auth, "hmac-sha1",
		    sizeof("hmac-sha1"))) {
			sadb_comb->sadb_comb_auth = SADB_AALG_SHA1HMAC;
			sadb_comb->sadb_comb_auth_minbits = 160;
			sadb_comb->sadb_comb_auth_maxbits = 160;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
		    sizeof("hmac_ripemd160"))) {
			sadb_comb->sadb_comb_auth = SADB_AALG_RIPEMD160HMAC;
			sadb_comb->sadb_comb_auth_minbits = 160;
			sadb_comb->sadb_comb_auth_maxbits = 160;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-md5",
		    sizeof("hmac-md5"))) {
			sadb_comb->sadb_comb_auth = SADB_AALG_MD5HMAC;
			sadb_comb->sadb_comb_auth_minbits = 128;
			sadb_comb->sadb_comb_auth_maxbits = 128;
		}

		sadb_comb->sadb_comb_soft_allocations = ipsec_soft_allocations;
		sadb_comb->sadb_comb_hard_allocations = ipsec_exp_allocations;

		sadb_comb->sadb_comb_soft_bytes = ipsec_soft_bytes;
		sadb_comb->sadb_comb_hard_bytes = ipsec_exp_bytes;

		sadb_comb->sadb_comb_soft_addtime = ipsec_soft_timeout;
		sadb_comb->sadb_comb_hard_addtime = ipsec_exp_timeout;

		sadb_comb->sadb_comb_soft_usetime = ipsec_soft_first_use;
		sadb_comb->sadb_comb_hard_usetime = ipsec_exp_first_use;
		sadb_comb++;
d2036 29
d2067 3
a2069 4
	if ((rval = pfkeyv2_sendmessage(headers,
	    PFKEYV2_SENDMESSAGE_REGISTERED, NULL, smsg->sadb_msg_satype, 0))
	    != 0)
		goto ret;
d2071 1
a2071 1
	rval = 0;
d2073 5
a2077 4
	if (buffer != NULL) {
		bzero(buffer, i);
		free(buffer, M_PFKEY);
	}
d2079 1
a2079 1
	return (rval);
d2089 4
a2092 4
	void *p, *headers[SADB_EXT_MAX+1], *buffer = NULL;
	struct sadb_msg *smsg;
	int rval = 0;
	int i;
d2094 2
a2095 1
	switch (sa->tdb_sproto) {
d2103 1
a2103 1
		break;
d2106 16
a2121 3
		rval = EOPNOTSUPP;
		goto ret;
	}
d2123 2
a2124 4
	i = sizeof(struct sadb_msg) + sizeof(struct sadb_sa) +
	    2 * sizeof(struct sadb_lifetime) +
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa)) +
	    sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
d2126 2
a2127 4
	if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
		rval = ENOMEM;
		goto ret;
	}
d2129 6
a2134 1
	bzero(headers, sizeof(headers));
d2136 2
a2137 2
	buffer = p;
	bzero(p, i);
d2139 2
a2140 2
	headers[0] = p;
	p += sizeof(struct sadb_msg);
d2142 4
a2145 17
	smsg = (struct sadb_msg *) headers[0];
	smsg->sadb_msg_version = PF_KEY_V2;
	smsg->sadb_msg_type = SADB_EXPIRE;
	smsg->sadb_msg_satype = sa->tdb_satype;
	smsg->sadb_msg_len = i / sizeof(uint64_t);
	smsg->sadb_msg_seq = pfkeyv2_seq++;

	headers[SADB_EXT_SA] = p;
	export_sa(&p, sa);

	headers[SADB_EXT_LIFETIME_CURRENT] = p;
	export_lifetime(&p, sa, 2);

	headers[type] = p;
	type = (SADB_EXT_LIFETIME_SOFT ? PFKEYV2_LIFETIME_SOFT :
	    PFKEYV2_LIFETIME_HARD);
	export_lifetime(&p, sa, type);
d2147 2
a2148 2
	headers[SADB_EXT_ADDRESS_SRC] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_src);
d2150 2
a2151 2
	headers[SADB_EXT_ADDRESS_DST] = p;
	export_address(&p, (struct sockaddr *) &sa->tdb_dst);
d2153 3
a2155 3
	if ((rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_BROADCAST,
	    NULL, 0, 0)) != 0)
		goto ret;
d2157 1
a2157 1
	rval = 0;
d2159 6
a2164 5
 ret:
	if (buffer != NULL) {
		bzero(buffer, i);
		free(buffer, M_PFKEY);
	}
d2166 1
a2166 1
	return (rval);
d2172 1
a2172 1
	int rval;
d2174 5
a2178 5
	bzero(&pfkeyv2_version, sizeof(struct pfkey_version));
	pfkeyv2_version.protocol = PFKEYV2_PROTOCOL;
	pfkeyv2_version.create = &pfkeyv2_create;
	pfkeyv2_version.release = &pfkeyv2_release;
	pfkeyv2_version.send = &pfkeyv2_send;
d2180 2
a2181 2
	rval = pfkey_register(&pfkeyv2_version);
	return (rval);
d2187 2
a2188 2
	pfkey_unregister(&pfkeyv2_version);
	return (0);
@


1.34.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d102 1
a102 1
	{ SADB_X_EALG_AES, 128, 64, 256}
d108 1
a108 4
	{ SADB_X_AALG_RIPEMD160HMAC, 0, 160, 160 },
	{ SADB_X_AALG_SHA2_256, 0, 256, 256 },
	{ SADB_X_AALG_SHA2_384, 0, 384, 384 },
	{ SADB_X_AALG_SHA2_512, 0, 512, 512 }
d113 1
a113 1
	{ SADB_X_CALG_LZS, 0, 0, 0}
a541 3
	if (sa->tdb_udpencap_port)
		i+= sizeof(struct sadb_x_udpencap);

a629 6
	/* Export UDP encapsulation port, if present */
	if (sa->tdb_udpencap_port) {
		headers[SADB_X_EXT_UDPENCAP] = p;
		export_udpencap(&p, sa);
	}

a894 6
		/* UDP encapsulation is only supported for ESP */
		if (smsg->sadb_msg_satype != SADB_SATYPE_ESP &&
		    headers[SADB_X_EXT_UDPENCAP]) {
			rval = EINVAL;
			goto ret;
		}
a964 2
			import_udpencap(newsa,
			    headers[SADB_X_EXT_UDPENCAP]);
a1009 2
			import_udpencap(sa2,
			    headers[SADB_X_EXT_UDPENCAP]);
a1034 6
		/* UDP encapsulation is only supported for ESP */
		if (smsg->sadb_msg_satype != SADB_SATYPE_ESP &&
		    headers[SADB_X_EXT_UDPENCAP]) {
			rval = EINVAL;
			goto ret;
		}
a1110 2
			import_udpencap(newsa,
			    headers[SADB_X_EXT_UDPENCAP]);
d1945 1
a1945 1
			sadb_comb->sadb_comb_auth = SADB_X_AALG_RIPEMD160HMAC;
a1952 15
		} else if (!strncasecmp(ipsec_def_auth, "hmac-sha2-256",
		    sizeof("hmac-sha2-256"))) {
			sadb_comb->sadb_comb_auth = SADB_X_AALG_SHA2_256;
			sadb_comb->sadb_comb_auth_minbits = 256;
			sadb_comb->sadb_comb_auth_maxbits = 256;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-sha2-384",
		    sizeof("hmac-sha2-384"))) {
			sadb_comb->sadb_comb_auth = SADB_X_AALG_SHA2_384;
			sadb_comb->sadb_comb_auth_minbits = 384;
			sadb_comb->sadb_comb_auth_maxbits = 384;
		} else if (!strncasecmp(ipsec_def_auth, "hmac-sha2-512",
		    sizeof("hmac-sha2-512"))) {
			sadb_comb->sadb_comb_auth = SADB_X_AALG_SHA2_512;
			sadb_comb->sadb_comb_auth_minbits = 512;
			sadb_comb->sadb_comb_auth_maxbits = 512;
@


1.33
log
@Ingress flow support.
@
text
@d182 6
d226 6
a821 1
	case SADB_X_SATYPE_AH_OLD:
d828 1
a828 1
	      *alg = satype == SADB_SATYPE_AH ? XF_NEW_AH : XF_OLD_AH;
a832 1
	case SADB_X_SATYPE_ESP_OLD:
d839 1
a839 1
	      *alg = satype == SADB_SATYPE_ESP ? XF_NEW_ESP : XF_OLD_ESP;
a1319 2
		case SADB_X_SATYPE_AH_OLD:
		case SADB_X_SATYPE_ESP_OLD:
d1367 7
a1373 2
	    sunionp = (union sockaddr_union *) (headers[SADB_EXT_ADDRESS_DST] +
						sizeof(struct sadb_address));
d1426 6
d1485 2
a1486 2
		  /* If we're deleting a flow... */
		  flow = find_flow(src, dst, srcmask, dstmask, sproto,
d1503 1
d1519 1
d1521 1
a1521 1
#if INET6
d1546 1
d1566 1
@


1.32
log
@Major style cleanup for pfkeyv2.c
@
text
@d1355 1
a1355 1
	    u_int8_t sproto = 0, replace;
d1364 2
a1365 1
	     * potentially conflicting flow while we are adding this new one.
d1368 2
a1369 1
	    if (replace && delflag) 
d1411 1
a1411 1
	    if (!delflag)
d1424 2
a1425 4

	    flow = find_global_flow(src, srcmask, dst, dstmask, sproto);
	    if (!replace &&
		((delflag && (flow == NULL)) || (!delflag && (flow != NULL))))
d1427 13
a1439 2
		rval = delflag ? ESRCH : EEXIST;
		goto splxret;
d1442 1
d1454 8
a1461 1
		put_flow(flow, sa2);
d1463 16
d1573 1
a1573 1
			delete_flow(flow, flow->flow_sa);
d1586 1
a1586 1
		delete_flow(flow, flow->flow_sa);
d1598 1
a1598 1
		    delete_flow(flow, sa2);
d1601 1
a1601 1
		      delete_flow(flow2, sa2);
d1622 1
a1622 1
			delete_flow(flow, sa2);
d1625 1
a1625 1
			  delete_flow(flow2, sa2);
d1634 1
a1634 1
		    delete_flow(flow, sa2);
d1637 1
a1637 1
		      delete_flow(flow2, sa2);
d1648 1
a1648 1
		  delete_flow(old_flow, old_flow->flow_sa);
d1651 1
a1651 1
		  delete_flow(old_flow2, old_flow2->flow_sa);
@


1.31
log
@Remove unnecessary function prototype.
@
text
@d38 2
a39 7
struct pfkey_version {
  int protocol;
  int (*create)(struct socket *socket);
  int (*release)(struct socket *socket);
  int (*send)(struct socket *socket, void *message, int len);
};

a40 18

#define PFKEYV2_SOCKETFLAGS_REGISTERED 1
#define PFKEYV2_SOCKETFLAGS_PROMISC    2

#define PFKEYV2_SENDMESSAGE_UNICAST    1
#define PFKEYV2_SENDMESSAGE_REGISTERED 2
#define PFKEYV2_SENDMESSAGE_BROADCAST  3

struct pfkeyv2_socket {
    struct pfkeyv2_socket *next;
    struct socket *socket;
    int flags;
    uint32_t pid;
    uint32_t registration;    /* Increase size if SATYPE_MAX > 31 */
};

static struct pfkeyv2_socket *pfkeyv2_sockets = NULL;

a41 1

d45 2
a46 1
static struct sadb_alg ealgs[] = {
d54 5
a58 4
static struct sadb_alg aalgs[] = {
{ SADB_AALG_SHA1HMAC96, 0, 160, 160 },
{ SADB_AALG_MD5HMAC96, 0, 128, 128 },
{ SADB_X_AALG_RIPEMD160HMAC96, 0, 160, 160 }
a60 4
extern int pfkey_register(struct pfkey_version *version);
int pfkey_unregister(struct pfkey_version *version);
int pfkey_sendup(struct socket *socket, struct mbuf *packet, int more);

d65 1
d71 1
a71 1
int pfdatatopacket(void *, int, struct mbuf **);
d81 5
d89 4
d96 2
a97 2
  if (!(*packet = m_devget(data, len, 0, NULL, NULL)))
    return ENOMEM;
d99 1
a99 1
  return 0;
d102 3
d108 1
a108 1
  struct pfkeyv2_socket *pfkeyv2_socket;
d110 3
a112 3
  if (!(pfkeyv2_socket = malloc(sizeof(struct pfkeyv2_socket), M_PFKEY,
				M_DONTWAIT)))
    return ENOMEM;
d114 4
a117 4
  bzero(pfkeyv2_socket, sizeof(struct pfkeyv2_socket));
  pfkeyv2_socket->next = pfkeyv2_sockets;
  pfkeyv2_socket->socket = socket;
  pfkeyv2_socket->pid = curproc->p_pid;
d119 1
a119 1
  pfkeyv2_sockets = pfkeyv2_socket;
d121 1
a121 1
  return 0;
d124 3
d130 1
a130 1
  struct pfkeyv2_socket **pp;
d132 4
a135 4
  for (pp = &pfkeyv2_sockets;
       *pp && ((*pp)->socket != socket);
       pp = &((*pp)->next))
    ;
d137 3
a139 2
  if (*pp) {
    struct pfkeyv2_socket *pfkeyv2_socket;
d141 2
a142 2
    pfkeyv2_socket = *pp;
    *pp = (*pp)->next;
d144 2
a145 2
    if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_REGISTERED)
      nregistered--;
d147 2
a148 2
    if (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
      npromisc--;
d150 2
a151 2
    free(pfkeyv2_socket, M_PFKEY);
  }
d153 1
a153 1
  return 0;
d156 4
d163 2
a164 2
  if (!sadb_sa)
    return;
d166 4
a169 4
  if (ii)
  {
      ii->ii_encalg = sadb_sa->sadb_sa_encrypt;
      ii->ii_authalg = sadb_sa->sadb_sa_auth;
d171 2
a172 2
      tdb->tdb_spi = sadb_sa->sadb_sa_spi;
      tdb->tdb_wnd = sadb_sa->sadb_sa_replay;
d174 2
a175 2
      if (sadb_sa->sadb_sa_flags & SADB_SAFLAGS_PFS)
	tdb->tdb_flags |= TDBF_PFS;
d177 2
a178 2
      if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_HALFIV)
	tdb->tdb_flags |= TDBF_HALFIV;
d180 3
a182 3
      if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_TUNNEL)
	tdb->tdb_flags |= TDBF_TUNNELING;
  }
d184 2
a185 2
  if (sadb_sa->sadb_sa_state != SADB_SASTATE_MATURE)
    tdb->tdb_flags |= TDBF_INVALID;
d188 3
d194 1
a194 1
  struct sadb_sa *sadb_sa = (struct sadb_sa *)*p;
d196 1
a196 1
  sadb_sa->sadb_sa_len = sizeof(struct sadb_sa) / sizeof(uint64_t);
d198 2
a199 2
  sadb_sa->sadb_sa_spi = tdb->tdb_spi;
  sadb_sa->sadb_sa_replay = tdb->tdb_wnd;
d201 5
a205 2
  if (tdb->tdb_flags & TDBF_INVALID)
    sadb_sa->sadb_sa_state = SADB_SASTATE_LARVAL;
d207 2
a208 2
  if (tdb->tdb_authalgxform)
    sadb_sa->sadb_sa_auth = tdb->tdb_authalgxform->type;
d210 2
a211 2
  if (tdb->tdb_encalgxform)
    sadb_sa->sadb_sa_encrypt = tdb->tdb_encalgxform->type;
d213 3
a215 2
  if (tdb->tdb_flags & TDBF_PFS)
    sadb_sa->sadb_sa_flags |= SADB_SAFLAGS_PFS;
d217 2
a218 5
  if (tdb->tdb_flags & TDBF_HALFIV)
    sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;
  
  if (tdb->tdb_flags & TDBF_TUNNELING)
    sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
d220 1
a220 1
  *p += sizeof(struct sadb_sa);
d223 3
d229 2
a230 2
  if (!sadb_lifetime)
    return;
d232 8
a239 7
  switch (type) {
    case 0:
      if ((tdb->tdb_exp_allocations =
	   sadb_lifetime->sadb_lifetime_allocations) != 0)
	tdb->tdb_flags |= TDBF_ALLOCATIONS;
      else
	tdb->tdb_flags &= ~TDBF_ALLOCATIONS;
d241 4
a244 4
      if ((tdb->tdb_exp_bytes = sadb_lifetime->sadb_lifetime_bytes) != 0)
	tdb->tdb_flags |= TDBF_BYTES;
      else
	tdb->tdb_flags &= ~TDBF_BYTES;
d246 8
a253 6
      if ((tdb->tdb_exp_timeout = sadb_lifetime->sadb_lifetime_addtime) != 0) {
	  tdb->tdb_flags |= TDBF_TIMER;
	  tdb->tdb_exp_timeout += time.tv_sec;
      }
      else
	tdb->tdb_flags &= ~TDBF_TIMER;
d255 6
a260 5
      if ((tdb->tdb_exp_first_use = sadb_lifetime->sadb_lifetime_usetime) != 0)
	tdb->tdb_flags |= TDBF_FIRSTUSE;
      else
	tdb->tdb_flags &= ~TDBF_FIRSTUSE;
      break;
d262 6
a267 6
    case 1:
      if ((tdb->tdb_soft_allocations =
	   sadb_lifetime->sadb_lifetime_allocations) != 0)
	tdb->tdb_flags |= TDBF_SOFT_ALLOCATIONS;
      else
	tdb->tdb_flags &= ~TDBF_SOFT_ALLOCATIONS;
d269 5
a273 4
      if ((tdb->tdb_soft_bytes = sadb_lifetime->sadb_lifetime_bytes) != 0)
	tdb->tdb_flags |= TDBF_SOFT_BYTES;
      else
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
d275 8
a282 7
      if ((tdb->tdb_soft_timeout =
	   sadb_lifetime->sadb_lifetime_addtime) != 0) {
	  tdb->tdb_flags |= TDBF_SOFT_TIMER;
	  tdb->tdb_soft_timeout += time.tv_sec;
      }
      else
	tdb->tdb_flags &= ~TDBF_SOFT_TIMER;
d284 6
a289 6
      if ((tdb->tdb_soft_first_use =
	   sadb_lifetime->sadb_lifetime_usetime) != 0)
	tdb->tdb_flags |= TDBF_SOFT_FIRSTUSE;
      else
	tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
      break;
d291 7
a297 6
    case 2:  /* Nothing fancy here */
	tdb->tdb_cur_allocations = sadb_lifetime->sadb_lifetime_allocations;
	tdb->tdb_cur_bytes = sadb_lifetime->sadb_lifetime_bytes;
	tdb->tdb_established = sadb_lifetime->sadb_lifetime_addtime;
	tdb->tdb_first_use = sadb_lifetime->sadb_lifetime_usetime;
  }
d299 2
a300 2
  /* Setup/update our position in the expiration queue.  */
  tdb_expiration(tdb, TDBEXP_TIMEOUT);
d303 3
d309 1
a309 1
  struct sadb_lifetime *sadb_lifetime = (struct sadb_lifetime *)*p;
d311 2
a312 2
  sadb_lifetime->sadb_lifetime_len = sizeof(struct sadb_lifetime) /
				     sizeof(uint64_t);
d314 35
a348 32
  switch (type) {
    case 0:
      if (tdb->tdb_flags & TDBF_ALLOCATIONS)
	sadb_lifetime->sadb_lifetime_allocations = tdb->tdb_exp_allocations;

      if (tdb->tdb_flags & TDBF_BYTES)
	sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_exp_bytes;

      if (tdb->tdb_flags & TDBF_TIMER)
	sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_exp_timeout -
					       tdb->tdb_established;

      if (tdb->tdb_flags & TDBF_FIRSTUSE)
	sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_exp_first_use -
					       tdb->tdb_first_use;
      break;

    case 1:
      if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS)
	sadb_lifetime->sadb_lifetime_allocations = tdb->tdb_soft_allocations;

      if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_soft_bytes;

      if (tdb->tdb_flags & TDBF_SOFT_TIMER)
	sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_soft_timeout -
					       tdb->tdb_established;

      if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
	sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_soft_first_use -
					       tdb->tdb_first_use;
      break;
d350 8
a357 7
    case 2:
      sadb_lifetime->sadb_lifetime_allocations = tdb->tdb_cur_allocations;
      sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_cur_bytes;
      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_established;
      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_first_use;
      break;
  }
d359 1
a359 1
  *p += sizeof(struct sadb_lifetime);
d362 3
d368 18
a385 14
  int salen;
  struct sockaddr *ssa = (struct sockaddr *)((void *) sadb_address +
					     sizeof(struct sadb_address));

  if (!sadb_address)
    return;

  if (ssa->sa_len)
    salen = ssa->sa_len;
  else
    switch(ssa->sa_family) {
      case AF_INET:
        salen = sizeof(struct sockaddr_in);
	break;
d387 3
a389 3
      case AF_INET6:
        salen = sizeof(struct sockaddr_in6);
	break;
d391 3
a393 2
      default:
	return;
d396 2
a397 2
  bcopy(ssa, sa, salen);
  sa->sa_len = salen;
d400 3
d406 1
a406 1
  struct sadb_address *sadb_address = (struct sadb_address *)*p;
d408 2
a409 2
  sadb_address->sadb_address_len = (sizeof(struct sadb_address) +
				    PADUP(SA_LEN(sa))) / sizeof(uint64_t);
d411 4
a414 4
  *p += sizeof(struct sadb_address);
  bcopy(sa, *p, SA_LEN(sa));
  ((struct sockaddr *)*p)->sa_family = sa->sa_family;
  *p += PADUP(SA_LEN(sa));
d417 3
d423 2
a424 2
  if (!sadb_ident)
    return;
d426 20
a445 17
  if (type == 0) {
      tdb->tdb_srcid_len = EXTLEN(sadb_ident) -
				   sizeof(struct sadb_ident);
      tdb->tdb_srcid_type = sadb_ident->sadb_ident_type;
      MALLOC(tdb->tdb_srcid, u_int8_t *, tdb->tdb_srcid_len, M_XDATA,
	     M_WAITOK);
      bcopy((void *)sadb_ident + sizeof(struct sadb_ident),
	    tdb->tdb_srcid, tdb->tdb_srcid_len);
  } else {
      tdb->tdb_dstid_len = EXTLEN(sadb_ident) -
				   sizeof(struct sadb_ident);
      tdb->tdb_dstid_type = sadb_ident->sadb_ident_type;
      MALLOC(tdb->tdb_dstid, u_int8_t *, tdb->tdb_dstid_len, M_XDATA,
	     M_WAITOK);
      bcopy((void *)sadb_ident + sizeof(struct sadb_ident),
	    tdb->tdb_dstid, tdb->tdb_dstid_len);
  }
d451 1
a451 1
  struct sadb_ident *sadb_ident = (struct sadb_ident *)*p;
d453 20
a472 13
  if (type == 0) {
      sadb_ident->sadb_ident_len = (sizeof(struct sadb_ident) + PADUP(tdb->tdb_srcid_len)) / sizeof(uint64_t);
      sadb_ident->sadb_ident_type = tdb->tdb_srcid_type;
      *p += sizeof(struct sadb_ident);
      bcopy(tdb->tdb_srcid, *p, tdb->tdb_srcid_len);
      *p += PADUP(tdb->tdb_srcid_len);
  } else {
      sadb_ident->sadb_ident_len = (sizeof(struct sadb_ident) + PADUP(tdb->tdb_dstid_len)) / sizeof(uint64_t);
      sadb_ident->sadb_ident_type = tdb->tdb_dstid_type;
      *p += sizeof(struct sadb_ident);
      bcopy(tdb->tdb_dstid, *p, tdb->tdb_dstid_len);
      *p += PADUP(tdb->tdb_dstid_len);
  }
d475 1
d479 2
a480 2
  if (!sadb_key)
    return;
d482 10
a491 7
  if (type == 0) { /* Encryption key */
      ii->ii_enckeylen = sadb_key->sadb_key_bits / 8;
      ii->ii_enckey = (void *)sadb_key + sizeof(struct sadb_key);
  } else {
      ii->ii_authkeylen = sadb_key->sadb_key_bits / 8;
      ii->ii_authkey = (void *)sadb_key + sizeof(struct sadb_key);
  }
d494 5
d503 8
a510 10
  int i, j, rval;
  void *p, *buffer = NULL;
  struct mbuf *packet;
  struct pfkeyv2_socket *s;

  j = sizeof(struct sadb_msg);

  for (i = 1; i <= SADB_EXT_MAX; i++)
    if (headers[i])
      j += ((struct sadb_ext *)headers[i])->sadb_ext_len * sizeof(uint64_t);
d512 3
a514 4
  if (!(buffer = malloc(j + sizeof(struct sadb_msg), M_PFKEY, M_DONTWAIT))) {
    rval = ENOMEM;
    goto ret;
  }
d516 5
a520 10
  p = buffer + sizeof(struct sadb_msg);
  bcopy(headers[0], p, sizeof(struct sadb_msg));
  ((struct sadb_msg *)p)->sadb_msg_len = j / sizeof(uint64_t);
  p += sizeof(struct sadb_msg);

  for (i = 1; i <= SADB_EXT_MAX; i++)
    if (headers[i]) {
      ((struct sadb_ext *)headers[i])->sadb_ext_type = i;
      bcopy(headers[i], p, EXTLEN(headers[i]));
      p += EXTLEN(headers[i]);
d523 4
a526 3
  if ((rval = pfdatatopacket(buffer + sizeof(struct sadb_msg),
			     j, &packet)) != 0)
    goto ret;
d528 8
a535 10
  switch(mode) {
    case PFKEYV2_SENDMESSAGE_UNICAST:
      pfkey_sendup(socket, packet, 0);
    
      bzero(buffer, sizeof(struct sadb_msg));
      ((struct sadb_msg *)buffer)->sadb_msg_version = PF_KEY_V2;
      ((struct sadb_msg *)buffer)->sadb_msg_type = SADB_X_PROMISC;
      ((struct sadb_msg *)buffer)->sadb_msg_len =
			     (sizeof(struct sadb_msg) + j) / sizeof(uint64_t);
      ((struct sadb_msg *)buffer)->sadb_msg_seq = 0;
d537 3
a539 3
      if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
				 &packet)) != 0)
	goto ret;
d541 59
a599 18
      for (s = pfkeyv2_sockets; s; s = s->next)
	if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) && (s->socket != socket))
	  pfkey_sendup(s->socket, packet, 1);

      m_zero(packet);
      m_freem(packet);
      break;

    case PFKEYV2_SENDMESSAGE_REGISTERED:
      for (s = pfkeyv2_sockets; s; s = s->next)
	if (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED) {
	    if (!satype)    /* Just send to everyone registered */
	      pfkey_sendup(s->socket, packet, 1);
	    else {
		if ((1 << satype) & s->registration) /* specified SATYPE */
		  if (count-- == 0) {     /* Done */
		      pfkey_sendup(s->socket, packet, 1);
		      break;
d601 4
a604 4
	    }
	}
      
      m_freem(packet);
d606 27
a632 6
      bzero(buffer, sizeof(struct sadb_msg));
      ((struct sadb_msg *)buffer)->sadb_msg_version = PF_KEY_V2;
      ((struct sadb_msg *)buffer)->sadb_msg_type = SADB_X_PROMISC;
      ((struct sadb_msg *)buffer)->sadb_msg_len =
			     (sizeof(struct sadb_msg) + j) / sizeof(uint64_t);
      ((struct sadb_msg *)buffer)->sadb_msg_seq = 0;
d634 3
a636 3
      if ((rval = pfdatatopacket(buffer, sizeof(struct sadb_msg) + j,
				 &packet)) != 0)
	goto ret;
d638 6
a643 15
      for (s = pfkeyv2_sockets; s; s = s->next)
	if ((s->flags & PFKEYV2_SOCKETFLAGS_PROMISC) &&
	    (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED))
	  pfkey_sendup(s->socket, packet, 1);

      m_freem(packet);
      break;

    case PFKEYV2_SENDMESSAGE_BROADCAST:
      for (s = pfkeyv2_sockets; s; s = s->next)
	pfkey_sendup(s->socket, packet, 1);

      m_freem(packet);
      break;
  }
d645 1
a645 6
ret:
  if (buffer != NULL) {
    bzero(buffer, j + sizeof(struct sadb_msg));
    free(buffer, M_PFKEY);
  }
  return rval;
d648 3
a650 3
extern uint32_t sadb_exts_allowed_out[SADB_MAX+1];
extern uint32_t sadb_exts_required_out[SADB_MAX+1];

d654 9
a662 2
  int rval, i;
  void *p;
d664 3
a666 1
  i = sizeof(struct sadb_sa) + sizeof(struct sadb_lifetime);
d668 2
a669 3
  if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
      sa->tdb_soft_timeout || sa->tdb_soft_first_use)
    i += sizeof(struct sadb_lifetime);
d671 2
a672 3
  if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
      sa->tdb_exp_timeout || sa->tdb_exp_first_use)
    i += sizeof(struct sadb_lifetime);
d674 2
a675 2
  if (sa->tdb_src.sa.sa_family)
    i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa));
d677 16
a692 2
  if (sa->tdb_dst.sa.sa_family)
    i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
d694 1
a694 2
  if (sa->tdb_proxy.sa.sa_family)
    i += sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_proxy.sa));
d696 1
a696 2
  if (sa->tdb_srcid_len)
    i += PADUP(sa->tdb_srcid_len) + sizeof(struct sadb_ident);
d698 3
a700 2
  if (sa->tdb_dstid_len)
    i += PADUP(sa->tdb_dstid_len) + sizeof(struct sadb_ident);
d702 6
a707 4
  if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
    rval = ENOMEM;
    goto ret;
  }
d709 6
a714 1
  *buffer = p;
d716 7
a722 4
  bzero(p, i);
  
  headers[SADB_EXT_SA] = p;
  export_sa(&p, sa);
d724 6
a729 2
  headers[SADB_EXT_LIFETIME_CURRENT] = p;
  export_lifetime(&p, sa, 2);
d731 6
a736 22
  if (sa->tdb_soft_allocations || sa->tdb_soft_bytes ||
      sa->tdb_soft_first_use || sa->tdb_soft_timeout) {
    headers[SADB_EXT_LIFETIME_SOFT] = p;
    export_lifetime(&p, sa, 1);
  }

  if (sa->tdb_exp_allocations || sa->tdb_exp_bytes ||
      sa->tdb_exp_first_use || sa->tdb_exp_timeout) {
    headers[SADB_EXT_LIFETIME_HARD] = p;
    export_lifetime(&p, sa, 0);
  }

  headers[SADB_EXT_ADDRESS_SRC] = p;
  export_address(&p, (struct sockaddr *)&sa->tdb_src);

  headers[SADB_EXT_ADDRESS_DST] = p;
  export_address(&p, (struct sockaddr *)&sa->tdb_dst);

  if (SA_LEN(&sa->tdb_proxy.sa)) {
    headers[SADB_EXT_ADDRESS_PROXY] = p;
    export_address(&p, (struct sockaddr *)&sa->tdb_proxy);
  }
d738 6
a743 4
  if (sa->tdb_srcid_len) {
    headers[SADB_EXT_IDENTITY_SRC] = p;
    export_identity(&p, sa, 0);
  }
d745 1
a745 4
  if (sa->tdb_dstid_len) {
    headers[SADB_EXT_IDENTITY_DST] = p;
    export_identity(&p, sa, 1);
  }
d747 1
a747 1
  rval = 0;
d749 2
a750 2
ret:
  return rval;
d753 3
a755 5
struct dump_state {
  struct sadb_msg *sadb_msg;
  struct socket *socket;
};

d759 10
a768 3
  struct dump_state *dump_state = (struct dump_state *)state;
  void *headers[SADB_EXT_MAX+1], *buffer;
  int rval;
d770 12
a781 12
  if (!dump_state->sadb_msg->sadb_msg_satype ||
      (sa->tdb_satype == dump_state->sadb_msg->sadb_msg_satype)) {
    bzero(headers, sizeof(headers));
    headers[0] = (void *)dump_state->sadb_msg;
    if ((rval = pfkeyv2_get(sa, headers, &buffer)) != 0)
      return rval;
    rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_UNICAST,
			       dump_state->socket, 0, 0);
    free(buffer, M_PFKEY);
    if (rval)
      return rval;
  }
d783 1
a783 1
  return 0;
d786 3
d792 5
a796 4
  if (!(*((u_int8_t *)satype_vp)) ||
      sa->tdb_satype == *((u_int8_t *)satype_vp))
    tdb_delete(sa, 0, 0);
  return 0;
d799 5
d807 33
a839 24
  switch (satype) {
    case SADB_SATYPE_AH:
    case SADB_X_SATYPE_AH_OLD:
      if (!ah_enable)
	return EOPNOTSUPP;
      *sproto = IPPROTO_AH;
      if(alg != NULL) 
	*alg = satype == SADB_SATYPE_AH ? XF_NEW_AH : XF_OLD_AH;
      break;

    case SADB_SATYPE_ESP:
    case SADB_X_SATYPE_ESP_OLD:
      if (!esp_enable)
	return EOPNOTSUPP;
      *sproto = IPPROTO_ESP;
      if(alg != NULL) 
	*alg = satype == SADB_SATYPE_ESP ? XF_NEW_ESP : XF_OLD_ESP;
      break;

    case SADB_X_SATYPE_IPIP:
      *sproto = IPPROTO_IPIP;
      if (alg != NULL)
	*alg = XF_IP4;
      break;
d842 7
a848 5
    case SADB_X_SATYPE_TCPSIGNATURE:
      *sproto = IPPROTO_TCP;
      if (alg != NULL)
	*alg = XF_TCPSIGNATURE;
      break;
d851 5
a855 4
   default: /* Nothing else supported */
     return EOPNOTSUPP;
  }
  return 0;
d858 3
d864 1
a864 6
  void *headers[SADB_EXT_MAX + 1];
  int i, j, rval = 0, mode = PFKEYV2_SENDMESSAGE_BROADCAST, delflag = 0, s;
  struct pfkeyv2_socket *pfkeyv2_socket, *so = NULL;
  void *freeme = NULL, *bckptr = NULL;
  struct tdb sa, *sa2 = NULL;
  struct flow *flow = NULL;
d866 6
a871 7
  bzero(headers, sizeof(headers));
  
  for (pfkeyv2_socket = pfkeyv2_sockets;
       pfkeyv2_socket;
       pfkeyv2_socket = pfkeyv2_socket->next)
    if (pfkeyv2_socket->socket == socket)
      break;
d873 2
a874 4
  if (!pfkeyv2_socket) {
    rval = EINVAL;
    goto ret;
  }
d876 4
a879 2
  if (npromisc) {
    struct mbuf *packet;
d881 2
a882 5
    if (!(freeme = malloc(sizeof(struct sadb_msg) + len, M_PFKEY,
			  M_DONTWAIT))) {
      rval = ENOMEM;
      goto ret;
    }
d884 5
a888 6
    bzero(freeme, sizeof(struct sadb_msg));
    ((struct sadb_msg *)freeme)->sadb_msg_version = PF_KEY_V2;
    ((struct sadb_msg *)freeme)->sadb_msg_type = SADB_X_PROMISC;
    ((struct sadb_msg *)freeme)->sadb_msg_len =
			   (sizeof(struct sadb_msg) + len) / sizeof(uint64_t);
    ((struct sadb_msg *)freeme)->sadb_msg_seq = curproc->p_pid;
d890 5
a894 1
    bcopy(message, freeme + sizeof(struct sadb_msg), len);
d896 4
a899 3
    if ((rval = pfdatatopacket(freeme, sizeof(struct sadb_msg) + len,
			       &packet)) != 0)
      goto ret;
d901 6
a906 11
    for (so = pfkeyv2_sockets; so; so = so->next)
      if (so->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
	pfkey_sendup(so->socket, packet, 1);

    m_zero(packet);
    m_freem(packet);

    bzero(freeme, sizeof(struct sadb_msg) + len);
    free(freeme, M_PFKEY);
    freeme = NULL;
  }
d908 15
a922 2
  if ((rval = pfkeyv2_parsemessage(message, len, headers)) != 0)
    goto ret;
d924 4
a927 3
  switch(((struct sadb_msg *)headers[0])->sadb_msg_type) {
    case SADB_GETSPI:
      bzero(&sa, sizeof(struct tdb));
d929 3
a931 3
      sa.tdb_satype = ((struct sadb_msg *)headers[0])->sadb_msg_satype;
      if ((rval = pfkeyv2_get_proto_alg(sa.tdb_satype, &sa.tdb_sproto, 0)))
	goto ret;
d933 5
a937 4
      import_address((struct sockaddr *)&sa.tdb_src,
		     headers[SADB_EXT_ADDRESS_SRC]);
      import_address((struct sockaddr *)&sa.tdb_dst,
		     headers[SADB_EXT_ADDRESS_DST]);
d939 9
a947 3
      sa.tdb_spi = reserve_spi(((struct sadb_spirange *)headers[SADB_EXT_SPIRANGE])->sadb_spirange_min, ((struct sadb_spirange *)headers[SADB_EXT_SPIRANGE])->sadb_spirange_max, &sa.tdb_src, &sa.tdb_dst, sa.tdb_sproto, &rval);
      if (sa.tdb_spi == 0)
	goto ret;
d949 26
a974 4
      if (!(freeme = malloc(sizeof(struct sadb_sa), M_PFKEY, M_DONTWAIT))) {
	rval = ENOMEM;
	goto ret;
      }
d976 18
a993 78
      bzero(freeme, sizeof(struct sadb_sa));
      headers[SADB_EXT_SPIRANGE] = NULL;
      headers[SADB_EXT_SA] = freeme;
      bckptr = freeme;
      export_sa((void **) &bckptr, &sa);
      break;

    case SADB_UPDATE:
      s = spltdb();
      sa2 = gettdb(((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_spi,
		   (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
					    sizeof(struct sadb_address)),
		   SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
      if (sa2 == NULL) {
	rval = ESRCH;
	goto splxret;
      }
      
      if (sa2->tdb_flags & TDBF_INVALID) {
	struct tdb *newsa;
	struct ipsecinit ii;
	int alg;

	MALLOC(freeme, struct tdb *, sizeof(struct tdb), M_TDB, M_WAITOK);
	bzero(freeme, sizeof(struct tdb));
	newsa = (struct tdb *)freeme;
	bzero(&ii, sizeof(struct ipsecinit));

	newsa->tdb_satype = ((struct sadb_msg *)headers[0])->sadb_msg_satype;
	if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype, 
					  &newsa->tdb_sproto, &alg)))
	  goto splxret;
	  
	import_sa(newsa, headers[SADB_EXT_SA], &ii);
	import_address((struct sockaddr *)&newsa->tdb_src,
		       headers[SADB_EXT_ADDRESS_SRC]);
	import_address((struct sockaddr *)&newsa->tdb_dst,
		       headers[SADB_EXT_ADDRESS_DST]);
	import_address((struct sockaddr *)&newsa->tdb_proxy,
		       headers[SADB_EXT_ADDRESS_PROXY]);

	import_lifetime(newsa, headers[SADB_EXT_LIFETIME_CURRENT], 2);
	import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT], 1);
	import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD], 0);
	import_key(&ii, headers[SADB_EXT_KEY_AUTH], 1);
	import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT], 0);
	import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC], 0);
	import_identity(newsa, headers[SADB_EXT_IDENTITY_DST], 1);

	headers[SADB_EXT_KEY_AUTH] = NULL;
	headers[SADB_EXT_KEY_ENCRYPT] = NULL;

	rval = tdb_init(newsa, alg, &ii);
	if (rval) {
	  rval = EINVAL;
	  tdb_delete(freeme, 0, TDBEXP_TIMEOUT);
	  freeme = NULL;
	  goto splxret;
	}
	newsa->tdb_flow = sa2->tdb_flow;
	newsa->tdb_cur_allocations = sa2->tdb_cur_allocations;
	for (flow = newsa->tdb_flow; flow != NULL; flow = flow->flow_next)
	  flow->flow_sa = newsa;
	sa2->tdb_flow = NULL;

	tdb_delete(sa2, 0, TDBEXP_TIMEOUT);
	puttdb((struct tdb *) freeme);
	sa2 = freeme = NULL;
      } else {
	if (headers[SADB_EXT_ADDRESS_PROXY] ||
	    headers[SADB_EXT_KEY_AUTH] ||
	    headers[SADB_EXT_KEY_ENCRYPT] ||
	    headers[SADB_EXT_IDENTITY_SRC] ||
	    headers[SADB_EXT_IDENTITY_DST] ||
	    headers[SADB_EXT_SENSITIVITY]) {
	  rval = EINVAL;
	  goto splxret;
	}
d995 6
a1000 7
	import_sa(sa2, headers[SADB_EXT_SA], NULL);
	import_lifetime(sa2, headers[SADB_EXT_LIFETIME_CURRENT], 2);
	import_lifetime(sa2, headers[SADB_EXT_LIFETIME_SOFT], 1);
	import_lifetime(sa2, headers[SADB_EXT_LIFETIME_HARD], 0);
      }
      splx(s);
      break;
d1002 42
a1043 15
    case SADB_ADD:
      s = spltdb();
      sa2 = gettdb(((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_spi,
		   (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
					    sizeof(struct sadb_address)),
		   SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
      if (sa2 != NULL) {
	rval = EEXIST;
	goto splxret;
      }
      if (((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_state !=
	  SADB_SASTATE_MATURE) {
	rval = EINVAL;
	goto splxret;
      }
d1045 2
a1046 2
      MALLOC(freeme, struct tdb *, sizeof(struct tdb), M_TDB, M_WAITOK);
      bzero(freeme, sizeof(struct tdb));
d1048 8
a1055 39
      {
	struct tdb *newsa = (struct tdb *) freeme;
	struct ipsecinit ii;
	int alg;

	bzero(&ii, sizeof(struct ipsecinit));

	newsa->tdb_satype = ((struct sadb_msg *)headers[0])->sadb_msg_satype;
	if ((rval = pfkeyv2_get_proto_alg(newsa->tdb_satype, 
					   &newsa->tdb_sproto, &alg)))
	  goto splxret;

	import_sa(newsa, headers[SADB_EXT_SA], &ii);
	import_address((struct sockaddr *)&newsa->tdb_src,
		       headers[SADB_EXT_ADDRESS_SRC]);
	import_address((struct sockaddr *)&newsa->tdb_dst,
		       headers[SADB_EXT_ADDRESS_DST]);
	import_address((struct sockaddr *)&newsa->tdb_proxy,
		       headers[SADB_EXT_ADDRESS_PROXY]);

	import_lifetime(newsa, headers[SADB_EXT_LIFETIME_CURRENT], 2);
	import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT], 1);
	import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD], 0);
	import_key(&ii, headers[SADB_EXT_KEY_AUTH], 1);
	import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT], 0);
	import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC], 0);
	import_identity(newsa, headers[SADB_EXT_IDENTITY_DST], 1);

	headers[SADB_EXT_KEY_AUTH] = NULL;
	headers[SADB_EXT_KEY_ENCRYPT] = NULL;

	rval = tdb_init(newsa, alg, &ii);
	if (rval) {
	  rval = EINVAL;
	  tdb_delete(freeme, 0, TDBEXP_TIMEOUT);
	  freeme = NULL;
	  goto splxret;
	}
      }
d1057 1
a1057 41
      puttdb((struct tdb *)freeme);
      splx(s);
      freeme = NULL;
      break;

    case SADB_DELETE:
      s = spltdb();
      sa2 = gettdb(((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_spi,
		   (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
					    sizeof(struct sadb_address)),
		   SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
      if (sa2 == NULL) {
	rval = ESRCH;
	goto splxret;
      }
      
      tdb_delete(sa2, ((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_flags & SADB_X_SAFLAGS_CHAINDEL, TDBEXP_TIMEOUT);
      splx(s);
      sa2 = NULL;
      break;

    case SADB_GET:
      s = spltdb();
      sa2 = gettdb(((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_spi,
		   (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
					    sizeof(struct sadb_address)),
		   SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
      if (sa2 == NULL) {
	rval = ESRCH;
	goto splxret;
      }
      
      rval = pfkeyv2_get(sa2, headers, &freeme);
      if (rval)
	mode = PFKEYV2_SENDMESSAGE_UNICAST;
      splx(s);
      break;

    case SADB_REGISTER:
      pfkeyv2_socket->flags |= PFKEYV2_SOCKETFLAGS_REGISTERED;
      nregistered++;
d1059 14
a1072 1
      i = sizeof(struct sadb_supported) + sizeof(ealgs) + sizeof(aalgs);
d1074 2
a1075 9
      if (!(freeme = malloc(i, M_PFKEY, M_DONTWAIT))) {
	rval = ENOMEM;
	goto ret;
      }
      
      /* Keep track what this socket has registered for */
      pfkeyv2_socket->registration |= (1 << ((struct sadb_msg *)message)->sadb_msg_satype);
      
      bzero(freeme, i);
d1077 22
a1098 6
      ((struct sadb_supported *)freeme)->sadb_supported_len =
							 i / sizeof(uint64_t);
      ((struct sadb_supported *)freeme)->sadb_supported_nauth =
				      sizeof(aalgs) / sizeof(struct sadb_alg);
      ((struct sadb_supported *)freeme)->sadb_supported_nencrypt =
				      sizeof(ealgs) / sizeof(struct sadb_alg);
d1100 8
a1107 2
      {
	void *p = freeme + sizeof(struct sadb_supported);
d1109 2
a1110 4
	bcopy(&aalgs[0], p, sizeof(aalgs));
	p += sizeof(aalgs);
	bcopy(&ealgs[0], p, sizeof(ealgs));
      }
d1112 4
a1115 2
      headers[SADB_EXT_SUPPORTED] = freeme;
      break;
d1117 1
a1117 32
    case SADB_ACQUIRE:
      rval = 0;
      break;

    case SADB_EXPIRE:
      rval = 0;
      break;

    case SADB_FLUSH:
    {
      union sockaddr_union dst;
      rval = 0;
      switch(((struct sadb_msg *)headers[0])->sadb_msg_satype)
      {
      case SADB_SATYPE_UNSPEC:  
      case SADB_SATYPE_AH:
      case SADB_SATYPE_ESP:
      case SADB_X_SATYPE_AH_OLD:
      case SADB_X_SATYPE_ESP_OLD:
      case SADB_X_SATYPE_IPIP:
#ifdef TCP_SIGNATURE
      case SADB_X_SATYPE_TCPSIGNATURE:
#endif /* TCP_SIGNATURE */
          s = spltdb();
          tdb_walk(pfkeyv2_flush_walker, 
		   (u_int8_t *)&(((struct sadb_msg *)headers[0])->sadb_msg_satype));
	  break;
      case SADB_X_SATYPE_BYPASS:
	  break;
      default:
          rval = EINVAL; /* Unknown/unsupported type */
      }
d1119 2
a1120 14
      switch(((struct sadb_msg *)headers[0])->sadb_msg_satype)
      {
      case SADB_SATYPE_UNSPEC:  
      case SADB_X_SATYPE_BYPASS:
	  /* XXX IPv4 dependency -- does it matter though ? */
	  dst.sin.sin_family = AF_INET;
	  dst.sin.sin_len = sizeof(struct sockaddr_in);
	  dst.sin.sin_addr.s_addr = INADDR_ANY;
	  s = spltdb();
	  sa2 = gettdb(SPI_LOCAL_USE, &dst, IPPROTO_IP);
	  if (sa2 != NULL)
	      tdb_delete(sa2, 0, 0);
      default:
      }
d1122 6
a1127 4
      if (rval == 0)
	  goto splxret;
      break;
    }
d1129 6
a1134 8
    case SADB_DUMP:
      {
        struct dump_state dump_state;
        dump_state.sadb_msg = (struct sadb_msg *)headers[0];
        dump_state.socket = socket;
	
        if (!(rval = tdb_walk(pfkeyv2_dump_walker, &dump_state)))
	  goto realret;
d1136 3
a1138 4
	if ((rval == ENOMEM) || (rval == ENOBUFS))
	  rval = 0;
      }
      break;
d1140 36
a1175 23
	
    case SADB_X_DELFLOW:
	delflag = 1;   /* fall through */
	
    case SADB_X_ADDFLOW: /* XXX This is highly INET dependent */
    {
	struct sockaddr_encap encapdst, encapgw, encapnetmask;
	struct flow *flow2 = NULL, *old_flow = NULL, *old_flow2 = NULL;
	union sockaddr_union *src, *dst, *srcmask, *dstmask;
	u_int8_t sproto = 0, replace;
	struct rtentry *rt;
	
	/*
	 * SADB_X_SAFLAGS_REPLACEFLOW set means we should remove any
	 * potentially conflicting flow while we are adding this new one.
	 */
	replace = ((struct sadb_sa *) headers[SADB_EXT_SA])->sadb_sa_flags & 
	          SADB_X_SAFLAGS_REPLACEFLOW;
	if (replace && delflag) 
	{
	    rval = EINVAL;
	    goto ret;
	}
d1177 2
a1178 16
	src = (union sockaddr_union *) (headers[SADB_X_EXT_SRC_FLOW] + sizeof(struct sadb_address));
	dst = (union sockaddr_union *) (headers[SADB_X_EXT_DST_FLOW] + sizeof(struct sadb_address));
	srcmask = (union sockaddr_union *) (headers[SADB_X_EXT_SRC_MASK] + sizeof(struct sadb_address));
	dstmask = (union sockaddr_union *) (headers[SADB_X_EXT_DST_MASK] + sizeof(struct sadb_address));

	/*
	 * Check that all the address families match. We know they are
	 * valid and supported because pfkeyv2_parsemessage() checked that.
	 */
	if ((src->sa.sa_family != dst->sa.sa_family) ||
	    (src->sa.sa_family != srcmask->sa.sa_family) ||
	    (src->sa.sa_family != dstmask->sa.sa_family))
	{
	    rval = EINVAL;
	    goto splxret;
	}
d1180 9
a1188 8
	bzero(&encapdst, sizeof(struct sockaddr_encap));
	bzero(&encapnetmask, sizeof(struct sockaddr_encap));
	bzero(&encapgw, sizeof(struct sockaddr_encap));
	
	if (headers[SADB_X_EXT_PROTOCOL])
	  sproto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL])->sadb_protocol_proto;
	else
	  sproto = 0;
d1190 2
a1191 3
	/* Generic netmask handling, works for IPv4 and IPv6 */
	rt_maskedcopy(&src->sa, &src->sa, &srcmask->sa);
	rt_maskedcopy(&dst->sa, &dst->sa, &dstmask->sa);
d1193 1
a1193 1
	s = spltdb();
d1195 2
a1196 4
	if (!delflag)
	{
	    /* Find the relevant SA */
	    sa2 = gettdb(((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_spi, (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address)), SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
d1198 10
a1207 1
	    if (sa2 == NULL) {
d1211 3
a1213 1
	}
d1215 1
d1217 2
a1218 7
	flow = find_global_flow(src, srcmask, dst, dstmask, sproto);
	if (!replace &&
	    ((delflag && (flow == NULL)) || (!delflag && (flow != NULL))))
	{
	    rval = delflag ? ESRCH : EEXIST;
	    goto splxret;
	}
d1220 112
a1331 1
	if (!delflag)
d1333 9
a1341 9
	    if (replace)
	      old_flow = flow;
	    flow = get_flow();
	    bcopy(src, &flow->flow_src, src->sa.sa_len);
	    bcopy(dst, &flow->flow_dst, dst->sa.sa_len);
	    bcopy(srcmask, &flow->flow_srcmask, srcmask->sa.sa_len);
	    bcopy(dstmask, &flow->flow_dstmask, dstmask->sa.sa_len);
	    flow->flow_proto = sproto;
	    put_flow(flow, sa2);
d1343 3
d1347 4
a1350 3
	/* Setup the encap fields */
	encapdst.sen_family = PF_KEY;
	switch (flow->flow_src.sa.sa_family)
d1352 20
a1371 15
	    case AF_INET:
		encapdst.sen_len = SENT_IP4_LEN;
		encapdst.sen_type = SENT_IP4;
		encapdst.sen_ip_src = flow->flow_src.sin.sin_addr;
		encapdst.sen_ip_dst = flow->flow_dst.sin.sin_addr;
		encapdst.sen_proto = flow->flow_proto;
		encapdst.sen_sport = flow->flow_src.sin.sin_port;
		encapdst.sen_dport = flow->flow_dst.sin.sin_port;

		encapnetmask.sen_len = SENT_IP4_LEN;
		encapnetmask.sen_family = PF_KEY;
		encapnetmask.sen_type = SENT_IP4;
		encapnetmask.sen_ip_src = flow->flow_srcmask.sin.sin_addr;
		encapnetmask.sen_ip_dst = flow->flow_dstmask.sin.sin_addr;
		break;
d1373 71
a1443 18
#if INET6
	    case AF_INET6:
		encapdst.sen_len = SENT_IP6_LEN;
		encapdst.sen_type = SENT_IP6;
		encapdst.sen_ip6_src = flow->flow_src.sin6.sin6_addr;
		encapdst.sen_ip6_dst = flow->flow_dst.sin6.sin6_addr;
		encapdst.sen_ip6_proto = flow->flow_proto;
		encapdst.sen_ip6_sport = flow->flow_src.sin6.sin6_port;
		encapdst.sen_ip6_dport = flow->flow_dst.sin6.sin6_port;

		encapnetmask.sen_len = SENT_IP6_LEN;
		encapnetmask.sen_family = PF_KEY;
		encapnetmask.sen_type = SENT_IP6;
		encapnetmask.sen_ip6_src = flow->flow_srcmask.sin6.sin6_addr;
		encapnetmask.sen_ip6_dst = flow->flow_dstmask.sin6.sin6_addr;
		break;
#endif /* INET6 */
	}
d1445 3
a1447 3
	if (!delflag)
	{
	    switch (sa2->tdb_dst.sa.sa_family)
d1450 13
a1462 15
		    encapgw.sen_len = SENT_IPSP_LEN;
		    encapgw.sen_family = PF_KEY;
		    encapgw.sen_type = SENT_IPSP;
		    encapgw.sen_ipsp_dst = sa2->tdb_dst.sin.sin_addr;
		    encapgw.sen_ipsp_spi = sa2->tdb_spi;
		    encapgw.sen_ipsp_sproto = sa2->tdb_sproto;

		    if (flow->flow_proto)
		    {
			encapnetmask.sen_proto = 0xff;
			if (flow->flow_src.sin.sin_port)
			  encapnetmask.sen_sport = 0xffff;
			if (flow->flow_dst.sin.sin_port)
			  encapnetmask.sen_dport = 0xffff;
		    }
d1467 42
a1508 6
		    encapgw.sen_len = SENT_IPSP6_LEN;
		    encapgw.sen_family = PF_KEY;
		    encapgw.sen_type = SENT_IPSP6;
		    encapgw.sen_ipsp6_dst = sa2->tdb_dst.sin6.sin6_addr;
		    encapgw.sen_ipsp6_spi = sa2->tdb_spi;
		    encapgw.sen_ipsp6_sproto = sa2->tdb_sproto;
d1510 20
a1529 9
		    if (flow->flow_proto)
		    {
			encapnetmask.sen_ip6_proto = 0xff;
			if (flow->flow_src.sin6.sin6_port)
			  encapnetmask.sen_ip6_sport = 0xffff;
			if (flow->flow_dst.sin6.sin6_port)
			  encapnetmask.sen_ip6_dport = 0xffff;
		    }
		    break;
d1532 9
a1540 8
		default:
		    /* 
		     * This shouldn't ever happen really, as SAs
		     * should be checked at establishment time. 
		     */
		    rval = EPFNOSUPPORT;
		    delete_flow(flow, flow->flow_sa);
		    goto splxret;
a1541 1
	}
d1543 7
a1549 7
	/* Add the entry in the routing table */
	if (delflag)
	{
	    rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
		      (struct sockaddr *) 0,
		      (struct sockaddr *) &encapnetmask,
		      0, (struct rtentry **) 0);
d1551 1
a1551 16
	    delete_flow(flow, flow->flow_sa);
	}
	else if (!replace)
	{
	    rval = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
			     (struct sockaddr *) &encapgw,
			     (struct sockaddr *) &encapnetmask,
			     RTF_UP | RTF_GATEWAY | RTF_STATIC,
			     (struct rtentry **) 0);
	    
	    if (rval)
	    {
	      	delete_flow(flow, sa2);
		if (flow2)
		  delete_flow(flow2, sa2);
		goto splxret;
d1553 1
a1553 8

	    sa2->tdb_cur_allocations++;
	}
	else
	{
	    rt = (struct rtentry *) rn_lookup(&encapdst, &encapnetmask, 
					      rt_tables[PF_KEY]);
	    if (rt == NULL)
d1560 7
d1568 29
a1596 1
		if (rval)
d1598 1
d1600 1
d1603 1
d1606 2
d1609 2
a1610 1
	    else if (rt_setgate(rt, rt_key(rt), (struct sockaddr *) &encapgw))
d1612 5
a1616 5
	        rval = ENOMEM;
		delete_flow(flow, sa2);
		if (flow2)
		  delete_flow(flow2, sa2);
		goto splxret;
d1619 17
a1635 1
	    sa2->tdb_cur_allocations++;
d1638 4
a1641 1
	if (replace)
d1643 16
a1658 5
	    if (old_flow != NULL)
	      delete_flow(old_flow, old_flow->flow_sa);
	    if (old_flow2 != NULL)
	      delete_flow(old_flow2, old_flow2->flow_sa);
	}
d1660 12
a1671 5
	/* If we are adding flows, check for allocation expirations */
	if (!delflag && !(replace && old_flow != NULL)) {
	    if ((sa2->tdb_flags & TDBF_ALLOCATIONS) &&
		(sa2->tdb_cur_allocations > sa2->tdb_exp_allocations)) {
		/* XXX expiration notification */
d1673 6
a1678 6
		tdb_delete(sa2, 0, TDBEXP_TIMEOUT);
	    } else 
	      if ((sa2->tdb_flags & TDBF_SOFT_ALLOCATIONS) &&
		  (sa2->tdb_cur_allocations > sa2->tdb_soft_allocations)) {
		  /* XXX expiration notification */
		  sa2->tdb_flags &= ~TDBF_SOFT_ALLOCATIONS;
d1680 15
d1696 2
a1697 3
    }
    splx(s);
    break;
d1699 25
a1723 3
    case SADB_X_GRPSPIS:
    {
	struct tdb *tdb1, *tdb2, *tdb3;
d1725 12
a1736 9
	s = spltdb();
	tdb1 = gettdb(((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_spi,
		      (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
					       sizeof(struct sadb_address)),
		      SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
	if (tdb1 == NULL) {
	    rval = ESRCH;
	    goto splxret;
	}
d1738 6
a1743 9
	tdb2 = gettdb(((struct sadb_sa *)headers[SADB_X_EXT_SA2])->sadb_sa_spi,
		      (union sockaddr_union *)(headers[SADB_X_EXT_DST2] +
					       sizeof(struct sadb_address)),
		      SADB_GETSPROTO(((struct sadb_protocol *)headers[SADB_X_EXT_PROTOCOL])->sadb_protocol_proto));

	if (tdb2 == NULL) {
	    rval = ESRCH;
	    goto splxret;
	}
d1745 4
a1748 7
	/* Detect cycles */
	for (tdb3 = tdb2; tdb3; tdb3 = tdb3->tdb_onext)
	  if (tdb3 == tdb1)
	  {
	      rval = ESRCH;
	      goto splxret;
	  }
d1750 3
a1752 19
	/* Maintenance */
	if ((tdb1->tdb_onext) &&
	    (tdb1->tdb_onext->tdb_inext == tdb1))
	  tdb1->tdb_onext->tdb_inext = NULL;

	if ((tdb2->tdb_inext) &&
	    (tdb2->tdb_inext->tdb_onext == tdb2))
	  tdb2->tdb_inext->tdb_onext = NULL;

	/* Link them */
	tdb1->tdb_onext = tdb2;
	tdb2->tdb_inext = tdb1;
	splx(s);   
    }
    break;
	
    case SADB_X_BINDSA:
    {
	struct tdb *tdb1, *tdb2;
d1754 1
a1754 8
	s = spltdb();
	tdb1 = gettdb(((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_spi,
		     (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
					      sizeof(struct sadb_address)),
		     SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
	if (tdb1 == NULL) {
	    rval = ESRCH;
	    goto splxret;
d1757 6
a1762 5
	if (TAILQ_FIRST(&tdb1->tdb_bind_in)) {
	    /* Incoming SA has not list of referencing incoming SAs */
	    rval = EINVAL;
	    goto splxret;
	}
d1764 2
a1765 9
	tdb2 = gettdb(((struct sadb_sa *)headers[SADB_X_EXT_SA2])->sadb_sa_spi,
		     (union sockaddr_union *)(headers[SADB_X_EXT_DST2] +
					      sizeof(struct sadb_address)),
		     SADB_GETSPROTO(((struct sadb_protocol *)headers[SADB_X_EXT_PROTOCOL])->sadb_protocol_proto));

	if (tdb2 == NULL) {
	    rval = ESRCH;
	    goto splxret;
	}
d1767 5
a1771 5
	if (tdb2->tdb_bind_out) {
	    /* Outgoing SA has no pointer to an outgoing SA */
	    rval = EINVAL;
	    goto splxret;
	}
d1773 9
a1781 15
	/* Maintenance */
	if (tdb1->tdb_bind_out)
	    TAILQ_REMOVE(&tdb1->tdb_bind_out->tdb_bind_in, tdb1,
			 tdb_bind_in_next);

	/* Link them */
	tdb1->tdb_bind_out = tdb2;
	TAILQ_INSERT_TAIL(&tdb2->tdb_bind_in, tdb1, tdb_bind_in_next);
    }
    splx(s);
    break;
	
    case SADB_X_PROMISC:
      if (len >= 2 * sizeof(struct sadb_msg)) {
	struct mbuf *packet;
d1783 3
a1785 2
	if ((rval = pfdatatopacket(message, len, &packet)) != 0)
	  goto ret;
d1787 14
a1800 6
	for (so = pfkeyv2_sockets; so; so = so->next)
	  if ((so != pfkeyv2_socket) &&
	      (!((struct sadb_msg *)headers[0])->sadb_msg_seq ||
	       (((struct sadb_msg *)headers[0])->sadb_msg_seq ==
		pfkeyv2_socket->pid)))
	    pfkey_sendup(so->socket, packet, 1);
d1802 1
a1802 6
	m_freem(packet);
      } else {
	if (len != sizeof(struct sadb_msg)) {
	  rval = EINVAL;
	  goto ret;
	}
d1804 4
a1807 18
	i = (pfkeyv2_socket->flags & PFKEYV2_SOCKETFLAGS_PROMISC) ? 1 : 0;
	j = ((struct sadb_msg *)headers[0])->sadb_msg_satype ? 1 : 0;
	
	if (i ^ j) {
	  if (j) {
	    pfkeyv2_socket->flags |= PFKEYV2_SOCKETFLAGS_PROMISC;
	    npromisc++;
	  } else {
	    pfkeyv2_socket->flags &= ~PFKEYV2_SOCKETFLAGS_PROMISC;
	    npromisc--;
	  }
	}
      }
      break;
    default:
      rval = EINVAL;
      goto ret;
  }
d1810 13
a1822 9
  if (rval) {
    if ((rval == EINVAL) || (rval == ENOMEM) ||
	(rval == ENOBUFS))
      goto realret;
    for (i = 1; i <= SADB_EXT_MAX; i++)
      headers[i] = NULL;
    ((struct sadb_msg *)headers[0])->sadb_msg_errno = abs(rval);
  } else {
    uint32_t seen = 0;
d1824 3
a1826 3
    for (i = 1; i <= SADB_EXT_MAX; i++)
      if (headers[i])
	seen |= (1 << i);
d1828 2
a1829 3
      if ((seen & sadb_exts_allowed_out[((struct sadb_msg *)headers[0])->sadb_msg_type]) != seen) {
        goto realret;
      }
d1831 4
a1834 4
      if ((seen & sadb_exts_required_out[((struct sadb_msg *)headers[0])->sadb_msg_type]) != sadb_exts_required_out[((struct sadb_msg *)headers[0])->sadb_msg_type]) {
        goto realret;
      }
  }
d1836 1
a1836 1
  rval = pfkeyv2_sendmessage(headers, mode, socket, 0, 0);
d1839 10
a1848 9
  if (freeme)
    free(freeme, M_PFKEY);
  free(message, M_PFKEY);

  return rval;

 splxret:
  splx(s);
  goto ret;
d1851 3
d1857 31
a1887 3
  int rval = 0;
  int i, j;
  void *p, *headers[SADB_EXT_MAX+1], *buffer = NULL;
d1889 72
a1960 4
  if (!nregistered) {
    rval = ESRCH;
    goto ret;
  }
d1962 7
a1968 16
  /* How large a buffer do we need... */
  i = sizeof(struct sadb_msg) + sizeof(struct sadb_address) +
      PADUP(SA_LEN(&tdb->tdb_src.sa)) + sizeof(struct sadb_address) +
      PADUP(SA_LEN(&tdb->tdb_dst.sa)) + sizeof(struct sadb_prop) +
      1 * sizeof(struct sadb_comb) +  /* XXX We only do one proposal for now */
      2 * sizeof(struct sadb_ident);

  if (rekey)
    i += PADUP(tdb->tdb_srcid_len) +
         PADUP(tdb->tdb_dstid_len);

  /* Allocate */
  if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
    rval = ENOMEM;
    goto ret;
  }
d1970 1
a1970 1
  bzero(headers, sizeof(headers));
d1972 3
a1974 2
  buffer = p;
  bzero(p, i);
d1976 2
a1977 60
  headers[0] = p;
  p += sizeof(struct sadb_msg);
  ((struct sadb_msg *)headers[0])->sadb_msg_version = PF_KEY_V2;
  ((struct sadb_msg *)headers[0])->sadb_msg_type    = SADB_ACQUIRE;
  ((struct sadb_msg *)headers[0])->sadb_msg_len     = i / sizeof(uint64_t);
  ((struct sadb_msg *)headers[0])->sadb_msg_seq     = pfkeyv2_seq++;
  ((struct sadb_msg *)headers[0])->sadb_msg_satype  = tdb->tdb_satype;

  headers[SADB_EXT_ADDRESS_SRC] = p;
  p += sizeof(struct sadb_address) + PADUP(SA_LEN(&tdb->tdb_src.sa));
  ((struct sadb_address *)headers[SADB_EXT_ADDRESS_SRC])->sadb_address_len = (sizeof(struct sadb_address) + SA_LEN(&tdb->tdb_src.sa) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
  bcopy(&tdb->tdb_src, headers[SADB_EXT_ADDRESS_SRC] + sizeof(struct sadb_address), SA_LEN(&tdb->tdb_src.sa));

  headers[SADB_EXT_ADDRESS_DST] = p;
  p += sizeof(struct sadb_address) + PADUP(SA_LEN(&tdb->tdb_dst.sa));
  ((struct sadb_address *)headers[SADB_EXT_ADDRESS_DST])->sadb_address_len = (sizeof(struct sadb_address) + SA_LEN(&tdb->tdb_dst.sa) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
  bcopy(&tdb->tdb_dst, headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address), SA_LEN(&tdb->tdb_dst.sa));

  headers[SADB_EXT_IDENTITY_SRC] = p;
  p += sizeof(struct sadb_ident);
  ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_type = tdb->tdb_srcid_type;

  /* XXX some day we'll have to deal with real ident_ids for users */
  ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_id = 0;

  if (rekey) {
    ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_len = (sizeof(struct sadb_ident) + PADUP(tdb->tdb_srcid_len)) / sizeof(uint64_t);
    bcopy(tdb->tdb_srcid, p, tdb->tdb_srcid_len);
    p += PADUP(tdb->tdb_srcid_len);
  } else
    ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_len = (sizeof(struct sadb_ident)) / sizeof(uint64_t);

  headers[SADB_EXT_IDENTITY_DST] = p;
  p += sizeof(struct sadb_ident);
  ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_DST])->sadb_ident_type = tdb->tdb_dstid_type;

  /* XXX some day we'll have to deal with real ident_ids for users */
  ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_DST])->sadb_ident_id = 0;

  if (rekey) {
    ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_DST])->sadb_ident_len = (sizeof(struct sadb_ident) + PADUP(tdb->tdb_dstid_len)) / sizeof(uint64_t);
    bcopy(tdb->tdb_dstid, p, tdb->tdb_dstid_len);
    p += PADUP(tdb->tdb_dstid_len);
  } else
    ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_DST])->sadb_ident_len = (sizeof(struct sadb_ident)) / sizeof(uint64_t);

  headers[SADB_EXT_PROPOSAL] = p;
  p += sizeof(struct sadb_prop);
  ((struct sadb_prop *)headers[SADB_EXT_PROPOSAL])->sadb_prop_len = (sizeof(struct sadb_prop) + sizeof(struct sadb_comb) * 1) / sizeof(uint64_t); /* XXX 1 proposal only */
  ((struct sadb_prop *)headers[SADB_EXT_PROPOSAL])->sadb_prop_num = 1; /* XXX 1 proposal only */

  {
    struct sadb_comb *sadb_comb = p;

    /* XXX 1 proposal only */
    for (j = 0; j < 1; j++) {
      sadb_comb->sadb_comb_flags = 0;

      if (tdb->tdb_flags & TDBF_PFS)
        sadb_comb->sadb_comb_flags |= SADB_SAFLAGS_PFS;
d1979 2
a1980 2
      if (tdb->tdb_flags & TDBF_HALFIV)
        sadb_comb->sadb_comb_flags |= SADB_X_SAFLAGS_HALFIV;
d1982 2
a1983 2
      if (tdb->tdb_flags & TDBF_TUNNELING)
        sadb_comb->sadb_comb_flags |= SADB_X_SAFLAGS_TUNNEL;
d1985 14
a1998 12
      if (tdb->tdb_authalgxform)
      {
          sadb_comb->sadb_comb_auth = tdb->tdb_authalgxform->type;
          sadb_comb->sadb_comb_auth_minbits = tdb->tdb_authalgxform->keysize * 8;
          sadb_comb->sadb_comb_auth_maxbits = tdb->tdb_authalgxform->keysize * 8;
      }
      else
      {
          sadb_comb->sadb_comb_auth = 0;
          sadb_comb->sadb_comb_auth_minbits = 0;
          sadb_comb->sadb_comb_auth_maxbits = 0;
      }
d2000 14
a2013 12
      if (tdb->tdb_encalgxform)
      {
          sadb_comb->sadb_comb_encrypt = tdb->tdb_encalgxform->type;
          sadb_comb->sadb_comb_encrypt_minbits = tdb->tdb_encalgxform->minkey * 8;
          sadb_comb->sadb_comb_encrypt_maxbits = tdb->tdb_encalgxform->maxkey * 8;
      }
      else
      {
          sadb_comb->sadb_comb_encrypt = 0;
          sadb_comb->sadb_comb_encrypt_minbits = 0;
          sadb_comb->sadb_comb_encrypt_maxbits = 0;
      }
d2015 2
a2016 2
      sadb_comb->sadb_comb_soft_allocations = tdb->tdb_soft_allocations;
      sadb_comb->sadb_comb_hard_allocations = tdb->tdb_exp_allocations;
d2018 2
a2019 2
      sadb_comb->sadb_comb_soft_bytes = tdb->tdb_soft_bytes;
      sadb_comb->sadb_comb_hard_bytes = tdb->tdb_exp_bytes;
d2021 2
a2022 2
      sadb_comb->sadb_comb_soft_addtime = tdb->tdb_soft_timeout;
      sadb_comb->sadb_comb_hard_addtime = tdb->tdb_exp_timeout;
d2024 3
a2026 3
      sadb_comb->sadb_comb_soft_usetime = tdb->tdb_soft_first_use;
      sadb_comb->sadb_comb_hard_usetime = tdb->tdb_exp_first_use;
      sadb_comb++;
a2027 1
  }
d2029 8
a2036 3
  if ((rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_REGISTERED,
				  NULL, ((struct sadb_msg *)headers[0])->sadb_msg_satype, 1))!= 0)  /* XXX notice count of 1 as last arg -- is that right ? */
    goto ret;
d2038 1
a2038 1
  rval = 0;
d2041 7
a2047 5
  if (buffer != NULL) {
    bzero(buffer, i);
    free(buffer, M_PFKEY);
  }
  return rval;
d2050 4
d2057 10
a2066 8
  int rval = 0;
  int i;
  void *p, *headers[SADB_EXT_MAX+1], *buffer = NULL;

  switch (sa->tdb_sproto) {
    case IPPROTO_AH:
    case IPPROTO_ESP:
    case IPPROTO_IPIP:
d2068 1
a2068 1
    case IPPROTO_TCP:
d2070 1
a2070 5
      break;
    default:
      rval = EOPNOTSUPP;
      goto ret;
  }
d2072 4
a2075 4
  i = sizeof(struct sadb_msg) + sizeof(struct sadb_sa) +
      2 * sizeof(struct sadb_lifetime) +
      sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_src.sa)) +
      sizeof(struct sadb_address) + PADUP(SA_LEN(&sa->tdb_dst.sa));
d2077 4
a2080 4
  if (!(p = malloc(i, M_PFKEY, M_DONTWAIT))) {
    rval = ENOMEM;
    goto ret;
  }
d2082 5
a2086 1
  bzero(headers, sizeof(headers));
d2088 1
a2088 2
  buffer = p;
  bzero(p, i);
d2090 2
a2091 7
  headers[0] = p;
  p += sizeof(struct sadb_msg);
  ((struct sadb_msg *)headers[0])->sadb_msg_version = PF_KEY_V2;
  ((struct sadb_msg *)headers[0])->sadb_msg_type    = SADB_EXPIRE;
  ((struct sadb_msg *)headers[0])->sadb_msg_satype  = sa->tdb_satype;
  ((struct sadb_msg *)headers[0])->sadb_msg_len     = i / sizeof(uint64_t);
  ((struct sadb_msg *)headers[0])->sadb_msg_seq     = pfkeyv2_seq++;
d2093 2
a2094 2
  headers[SADB_EXT_SA] = p;
  export_sa(&p, sa);
d2096 17
a2112 2
  headers[SADB_EXT_LIFETIME_CURRENT] = p;
  export_lifetime(&p, sa, 2);
d2114 2
a2115 2
  headers[type] = p;
  export_lifetime(&p, sa, type == SADB_EXT_LIFETIME_SOFT ? 1 : 0);
d2117 2
a2118 2
  headers[SADB_EXT_ADDRESS_SRC] = p;
  export_address(&p, (struct sockaddr *)&sa->tdb_src);
d2120 3
a2122 2
  headers[SADB_EXT_ADDRESS_DST] = p;
  export_address(&p, (struct sockaddr *)&sa->tdb_dst);
d2124 1
a2124 3
  if ((rval = pfkeyv2_sendmessage(headers, PFKEYV2_SENDMESSAGE_BROADCAST,
				  NULL, 0, 0))!= 0)
    goto ret;
d2126 6
a2131 1
  rval = 0;
d2133 1
a2133 6
ret:
  if (buffer != NULL) {
    bzero(buffer, i);
    free(buffer, M_PFKEY);
  }
  return rval;
d2139 1
a2139 1
  int rval;
d2141 5
a2145 5
  bzero(&pfkeyv2_version, sizeof(struct pfkey_version));
  pfkeyv2_version.protocol = PFKEYV2_PROTOCOL;
  pfkeyv2_version.create   = &pfkeyv2_create;
  pfkeyv2_version.release  = &pfkeyv2_release;
  pfkeyv2_version.send     = &pfkeyv2_send;
d2147 2
a2148 2
  rval = pfkey_register(&pfkeyv2_version);
  return rval;
d2154 2
a2155 2
  pfkey_unregister(&pfkeyv2_version);
  return 0;
@


1.30
log
@Use rt_maskedcopy() instead of handling netmasks manually.
@
text
@a96 1
int pfkeyv2_acquire(struct tdb *, int);
@


1.29
log
@Proper netmask handling.
@
text
@a1105 1
	int lp;
d1146 2
a1147 7
	for (lp = 0;
	     lp < src->sa.sa_len - (sizeof(u_int8_t) + sizeof(sa_family_t);
	     lp++)
	{
	    src->sa.sa_data[lp] &= srcmask->sa.sa_data[lp];
	    dst->sa.sa_data[lp] &= dstmask->sa.sa_data[lp];
	}
@


1.28
log
@IPv6 address support, get rid of the LOCALFLOW flag
@
text
@d1147 3
a1149 1
	for (lp = 0; lp < src->sa.sa_len; lp++)
@


1.27
log
@Bypass flows can be flushed.
(btw, all IPsec bypass flow and gettdb()/spltdb() stuff ok niklas@@, angelos@@)
@
text
@d1065 1
d1104 1
a1104 2
	union sockaddr_union alts, altm;
	u_int8_t sproto = 0, local = 0, replace;
d1106 2
a1107 1

d1112 1
a1112 1
	replace = ((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_flags & 
d1114 2
a1115 1
	if (replace && delflag) {
d1120 33
d1154 1
d1157 1
a1165 20
	local = ((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_flags & 
		SADB_X_SAFLAGS_LOCALFLOW;
	bzero(&encapdst, sizeof(struct sockaddr_encap));
	bzero(&encapnetmask, sizeof(struct sockaddr_encap));
	bzero(&encapgw, sizeof(struct sockaddr_encap));
	bzero(&alts, sizeof(alts));
	bzero(&altm, sizeof(altm));
	
	src = (union sockaddr_union *) (headers[SADB_X_EXT_SRC_FLOW] + sizeof(struct sadb_address));
	dst = (union sockaddr_union *) (headers[SADB_X_EXT_DST_FLOW] + sizeof(struct sadb_address));
	srcmask = (union sockaddr_union *) (headers[SADB_X_EXT_SRC_MASK] + sizeof(struct sadb_address));
	dstmask = (union sockaddr_union *) (headers[SADB_X_EXT_DST_MASK] + sizeof(struct sadb_address));

	if (headers[SADB_X_EXT_PROTOCOL])
	  sproto = ((struct sadb_protocol *) headers[SADB_X_EXT_PROTOCOL])->sadb_protocol_proto;
	else
	  sproto = 0;
	
	src->sin.sin_addr.s_addr &= srcmask->sin.sin_addr.s_addr;
	dst->sin.sin_addr.s_addr &= dstmask->sin.sin_addr.s_addr;
a1174 18
	/* Check for 0.0.0.0/255.255.255.255 if the flow is local */
	if (local)
	{
	    alts.sin.sin_family = altm.sin.sin_family = AF_INET;
	    alts.sin.sin_len = altm.sin.sin_len = sizeof(struct sockaddr_in);
	    alts.sin.sin_addr.s_addr = INADDR_ANY;
	    altm.sin.sin_addr.s_addr = INADDR_BROADCAST;

	    flow2 = find_global_flow(&alts, &altm, dst, dstmask, sproto);
	    if (!replace &&
		((delflag && (flow2 == NULL)) ||
		 (!delflag && (flow2 != NULL))))
	    {
		rval = delflag ? ESRCH : EEXIST;
		goto splxret;
	    }
	}

a1185 13

	    if (local)
	    {
		if (replace)
		  old_flow2 = flow2;
		flow2 = get_flow();
		bcopy(&alts, &flow2->flow_src, alts.sa.sa_len);
		bcopy(dst, &flow2->flow_dst, dst->sa.sa_len);
		bcopy(&altm, &flow2->flow_srcmask, altm.sa.sa_len);
		bcopy(dstmask, &flow2->flow_dstmask, dstmask->sa.sa_len);
		flow2->flow_proto = sproto;
		put_flow(flow2, sa2);
	    }
a1188 1
	encapdst.sen_len = SENT_IP4_LEN;
d1190 36
a1225 6
	encapdst.sen_type = SENT_IP4;
	encapdst.sen_ip_src = flow->flow_src.sin.sin_addr;
	encapdst.sen_ip_dst = flow->flow_dst.sin.sin_addr;
	encapdst.sen_proto = flow->flow_proto;
	encapdst.sen_sport = flow->flow_src.sin.sin_port;
	encapdst.sen_dport = flow->flow_dst.sin.sin_port;
d1229 49
a1277 6
	    encapgw.sen_len = SENT_IPSP_LEN;
	    encapgw.sen_family = PF_KEY;
	    encapgw.sen_type = SENT_IPSP;
	    encapgw.sen_ipsp_dst = sa2->tdb_dst.sin.sin_addr;
	    encapgw.sen_ipsp_spi = sa2->tdb_spi;
	    encapgw.sen_ipsp_sproto = sa2->tdb_sproto;
a1278 6
	
	encapnetmask.sen_len = SENT_IP4_LEN;
	encapnetmask.sen_family = PF_KEY;
	encapnetmask.sen_type = SENT_IP4;
	encapnetmask.sen_ip_src = flow->flow_srcmask.sin.sin_addr;
	encapnetmask.sen_ip_dst = flow->flow_dstmask.sin.sin_addr;
a1279 10
	if (flow->flow_proto)
	{
	    encapnetmask.sen_proto = 0xff;
	    
	    if (flow->flow_src.sin.sin_port)
	      encapnetmask.sen_sport = 0xffff;
	    
	    if (flow->flow_dst.sin.sin_port)
	      encapnetmask.sen_dport = 0xffff;
	}
a1337 86
	}

	/* If this is a "local" packet flow */
	if (local)
	{
	    encapdst.sen_ip_src.s_addr = INADDR_ANY;
	    encapnetmask.sen_ip_src.s_addr = INADDR_BROADCAST;

	    if (delflag)
	    {
		rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
			  (struct sockaddr *) 0,
			  (struct sockaddr *) &encapnetmask, 0,
			  (struct rtentry **) 0);

		delete_flow(flow2, flow2->flow_sa);
	    }
	    else if (!replace)
	    {
		rval = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				 (struct sockaddr *) &encapgw,
				 (struct sockaddr *) &encapnetmask,
				 RTF_UP | RTF_GATEWAY | RTF_STATIC,
				 (struct rtentry **) 0);
	    
		if (rval)
		{
		    /* Delete the first entry inserted */
		    encapdst.sen_ip_src = flow->flow_src.sin.sin_addr;
		    encapnetmask.sen_ip_src = flow->flow_srcmask.sin.sin_addr;
		
		    rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
			      (struct sockaddr *) 0,
			      (struct sockaddr *) &encapnetmask, 0,
			      (struct rtentry **) 0);
		
		    delete_flow(flow, sa2);
		    delete_flow(flow2, sa2);
		    goto splxret;
		}

		sa2->tdb_cur_allocations++;
	    }
	    else
	    {
	        rt = (struct rtentry *) rn_lookup(&encapdst, &encapnetmask, 
						  rt_tables[PF_KEY]);
		if (rt == NULL)
		{
		    rval = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				     (struct sockaddr *) &encapgw,
				     (struct sockaddr *) &encapnetmask,
				     RTF_UP | RTF_GATEWAY | RTF_STATIC,
				     (struct rtentry **) 0);

		    if (rval)
		    {
			/*
			 * XXX We really should try to restore the non-local
			 * route if we need to abort here but that is getting
			 * very hairy.  Currently we do half the change and
			 * return an error, which is not optimal.
			 */

			if (old_flow)
			  delete_flow(old_flow, old_flow->flow_sa);
			delete_flow(flow2, sa2);
			goto splxret;
		    }
		}
		else if (rt_setgate(rt, rt_key(rt),
				    (struct sockaddr *) &encapgw))
		{
		    /*
		     * XXX See above regarding the cleaning of the
		     * non-local route.
		     */
		    rval = ENOMEM;
		    if (old_flow)
		      delete_flow(old_flow, old_flow->flow_sa);
		    delete_flow(flow2, sa2);
		    goto splxret;
		}

		sa2->tdb_cur_allocations++;
	    }
@


1.26
log
@Typo fix.
@
text
@d1038 1
d1054 3
a1056 1
          goto splxret;
d1060 17
d1258 1
a1258 1
		delete_flow(flow, sa2);
@


1.25
log
@Support SADB_DUMP. Misc code cleanup. angelos@@ ok.
@
text
@d924 1
a924 1
	if ((rval == pfkeyv2_get_proto_alg(newsa->tdb_satype, 
@


1.24
log
@Add SADB_FLUSH logic (tdb flushing).
@
text
@d103 1
d105 1
a653 1
#if 0 /* XXX Need to add a tdb_walk routine for this to work */
a675 1
#endif /* 0 */
d678 1
a678 1
pfkeyv2_flush_walker(struct tdb *sa, void *xf_type_vp)
d680 2
a681 2
  if (!(*((u_short *)xf_type_vp)) || 
      sa->tdb_xform->xf_type == *((u_short *)xf_type_vp))
d687 42
d792 3
a794 16
      switch (((struct sadb_msg *)headers[0])->sadb_msg_satype) {
	case SADB_SATYPE_AH:
	  if (!ah_enable) {
	    rval = EOPNOTSUPP;
	    goto ret;
	  }
	  sa.tdb_sproto = IPPROTO_AH;
	  break;
	    
	case SADB_SATYPE_ESP:
	  if (!esp_enable) {
	    rval = EOPNOTSUPP;
	    goto ret;
	  }
	  sa.tdb_sproto = IPPROTO_ESP;
	  break;
a795 31
	case SADB_X_SATYPE_AH_OLD:
	  if (!ah_enable) {
	    rval = EOPNOTSUPP;
	    goto ret;
	  }
	  sa.tdb_sproto = IPPROTO_AH;
	  break;
	    
	case SADB_X_SATYPE_ESP_OLD:
	  if (!esp_enable) {
	    rval = EOPNOTSUPP;
	    goto ret;
	  }
	  sa.tdb_sproto = IPPROTO_ESP;
	  break;

	case SADB_X_SATYPE_IPIP:
	  sa.tdb_sproto = IPPROTO_IPIP;
	  break;

#ifdef TCP_SIGNATURE
	case SADB_X_SATYPE_TCPSIGNATURE:
	  sa.tdb_sproto = IPPROTO_TCP;
	  break;
#endif /* TCP_SIGNATURE */

	default: /* Nothing else supported */
	  rval = EOPNOTSUPP;
	  goto ret;
      }
      
a836 41
	switch (((struct sadb_msg *)headers[0])->sadb_msg_satype) {
	  case SADB_SATYPE_AH:
	    if (!ah_enable) {
	      rval = EOPNOTSUPP;
	      goto splxret;
	    }
	    newsa->tdb_sproto = IPPROTO_AH;
	    alg = XF_NEW_AH;
	    break;
	    
	  case SADB_SATYPE_ESP:
	    if (!esp_enable) {
	      rval = EOPNOTSUPP;
	      goto splxret;
	    }
	    newsa->tdb_sproto = IPPROTO_ESP;
	    alg = XF_NEW_ESP;
	    break;

	  case SADB_X_SATYPE_AH_OLD:
	    if (!ah_enable) {
	      rval = EOPNOTSUPP;
	      goto splxret;
	    }
	    newsa->tdb_sproto = IPPROTO_AH;
	    alg = XF_OLD_AH;
	    break;

	  case SADB_X_SATYPE_ESP_OLD:
	    if (!esp_enable) {
	      rval = EOPNOTSUPP;
	      goto splxret;
	    }
	    newsa->tdb_sproto = IPPROTO_ESP;
	    alg = XF_OLD_ESP;
	    break;

	  case SADB_X_SATYPE_IPIP:
	    newsa->tdb_sproto = IPPROTO_IPIP;
	    alg = XF_IP4;
	    break;
d838 4
a841 11
#ifdef TCP_SIGNATURE
	  case SADB_X_SATYPE_TCPSIGNATURE:
	    newsa->tdb_sproto = IPPROTO_TCP;
	    alg = XF_TCPSIGNATURE;
	    break;
#endif /* TCP_SIGNATURE */
		  
	  default: /* Nothing else supported */
	    rval = EOPNOTSUPP;
	    goto splxret;
	}
a921 41
	switch (((struct sadb_msg *)headers[0])->sadb_msg_satype) {
	  case SADB_SATYPE_AH:
	    if (!ah_enable) {
	      rval = EOPNOTSUPP;
	      goto splxret;
	    }
	    newsa->tdb_sproto = IPPROTO_AH;
	    alg = XF_NEW_AH;
	    break;
	    
	  case SADB_SATYPE_ESP:
	    if (!esp_enable) {
	      rval = EOPNOTSUPP;
	      goto splxret;
	    }
	    newsa->tdb_sproto = IPPROTO_ESP;
	    alg = XF_NEW_ESP;
	    break;

	  case SADB_X_SATYPE_AH_OLD:
	    if (!ah_enable) {
	      rval = EOPNOTSUPP;
	      goto splxret;
	    }
	    newsa->tdb_sproto = IPPROTO_AH;
	    alg = XF_OLD_AH;
	    break;
  
	  case SADB_X_SATYPE_ESP_OLD:
	    if (!esp_enable) {
	      rval = EOPNOTSUPP;
	      goto splxret;
	    }
	    newsa->tdb_sproto = IPPROTO_ESP;
	    alg = XF_OLD_ESP;
	    break;

	  case SADB_X_SATYPE_IPIP:
	    newsa->tdb_sproto = IPPROTO_IPIP;
	    alg = XF_IP4;
	    break;
d923 4
a926 11
#ifdef TCP_SIGNATURE
	  case SADB_X_SATYPE_TCPSIGNATURE:
	    newsa->tdb_sproto = IPPROTO_TCP;
	    alg = XF_TCPSIGNATURE;
	    break;
#endif /* TCP_SIGNATURE */

	  default: /* Nothing else supported */
	    rval = EOPNOTSUPP;
	    goto splxret;
	}
a1041 2
          i = 0; 
          break;
a1042 2
          i = XF_NEW_AH; 
          break;
a1043 2
          i = XF_NEW_ESP; 
          break;
a1044 2
          i = XF_OLD_AH; 
          break;
a1045 2
          i = XF_OLD_ESP; 
          break;
d1047 1
a1047 3
          i = XF_IP4; 
          break; 
#if 0  /* Not yet */
d1049 5
a1053 3
          i = XF_TCPSIGNATURE; 
          break;
#endif
a1056 7
      
      if (!rval)
      {
          s = spltdb();
          tdb_walk(pfkeyv2_flush_walker, (u_short *)&i);
          goto splxret;
      }
a1065 1
#if 0 /* notyet */
a1067 1
#endif
d1604 1
a1604 22

  j = tdb->tdb_xform->xf_type;
  switch (j)
  {
      case XF_OLD_AH:
	 j = SADB_X_SATYPE_AH_OLD;
	 break;

      case XF_OLD_ESP:
	 j = SADB_X_SATYPE_ESP_OLD;
	 break;

      case XF_NEW_AH:
	 j = SADB_SATYPE_AH;
	 break;

      case XF_NEW_ESP:
	 j = SADB_SATYPE_ESP;
	 break;
  }

  ((struct sadb_msg *)headers[0])->sadb_msg_satype  = j;
a1724 1
  u_int8_t satype;
a1728 2
      satype = sa->tdb_xform->xf_type == XF_OLD_AH ? SADB_X_SATYPE_AH_OLD : SADB_SATYPE_AH;
      break;
a1729 2
      satype = sa->tdb_xform->xf_type == XF_OLD_ESP ? SADB_X_SATYPE_ESP_OLD : SADB_SATYPE_ESP;
      break;
a1730 2
      satype = SADB_X_SATYPE_IPIP;
      break;
a1732 2
       satype = SADB_X_SATYPE_TCPSIGNATURE;
       break;
d1734 1
d1759 1
a1759 1
  ((struct sadb_msg *)headers[0])->sadb_msg_satype  = satype;
@


1.23
log
@From angelos@@, edits by me, demand keying for PF_KEY
@
text
@d103 1
d677 9
d1135 1
a1135 1
/* XXX netsec_sadb_flush(((struct sadb_msg *)headers[0])->sadb_msg_satype); */
d1137 35
d1173 1
d1181 2
a1182 2
/** XXX
        if (!(rval = netsec_sadb_walk(pfkeyv2_dump_walker, &dump_state, 1)))
d1184 2
a1185 1
*/
@


1.22
log
@ipsec_in_use could get out of sync. (Also niklas@@. angelos@@ ok)
@
text
@d97 1
a97 1
int pfkeyv2_acquire(void *);
d1635 1
a1635 1
pfkeyv2_acquire(void *os)
a1636 1
#if 0
d1646 1
d1648 3
a1650 3
      PADUP(SA_LEN(&os->src.sa)) + sizeof(struct sadb_address) +
      PADUP(SA_LEN(&os->dst.sa)) + sizeof(struct sadb_prop) +
      os->nproposals * sizeof(struct sadb_comb) +
d1653 3
a1655 3
  if (os->rekeysa)
    i += PADUP(os->rekeysa->srcident.bytes) +
	 PADUP(os->rekeysa->dstident.bytes);
d1657 1
a1671 1
  ((struct sadb_msg *)headers[0])->sadb_msg_satype  = os->satype;
d1675 22
d1698 3
a1700 4
  p += sizeof(struct sadb_address) + PADUP(SA_LEN(&os->src.sa));
  ((struct sadb_address *)headers[SADB_EXT_ADDRESS_SRC])->sadb_address_len = (sizeof(struct sadb_address) + SA_LEN(&os->src.sa) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
  bcopy(&os->src, headers[SADB_EXT_ADDRESS_SRC] + sizeof(struct sadb_address),
	SA_LEN(&os->src.sa));
d1703 3
a1705 4
  p += sizeof(struct sadb_address) + PADUP(SA_LEN(&os->dst.sa));
  ((struct sadb_address *)headers[SADB_EXT_ADDRESS_DST])->sadb_address_len = (sizeof(struct sadb_address) + SA_LEN(&os->dst.sa) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
  bcopy(&os->dst, headers[SADB_EXT_ADDRESS_DST] + sizeof(struct sadb_address),
	SA_LEN(&os->dst.sa));
d1709 9
a1717 6
  ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_type = os->srcidenttype;
  ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_id = os->srcidentid;
  if (os->rekeysa) {
    ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_len = (sizeof(struct sadb_ident) + PADUP(os->rekeysa->srcident.bytes)) / sizeof(uint64_t);
    bcopy(os->rekeysa->srcident.data, p, os->rekeysa->srcident.bytes);
    p += PADUP(os->rekeysa->srcident.bytes);
d1723 9
a1731 6
  ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_type = os->dstidenttype;
  ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_SRC])->sadb_ident_id = os->dstidentid;
  if (os->rekeysa) {
    ((struct sadb_ident *)headers[SADB_EXT_IDENTITY_DST])->sadb_ident_len = (sizeof(struct sadb_ident) + PADUP(os->rekeysa->dstident.bytes)) / sizeof(uint64_t);
    bcopy(os->rekeysa->dstident.data, p, os->rekeysa->dstident.bytes);
    p += PADUP(os->rekeysa->srcident.bytes);
d1737 2
a1738 2
  ((struct sadb_prop *)headers[SADB_EXT_PROPOSAL])->sadb_prop_len = (sizeof(struct sadb_prop) + sizeof(struct sadb_comb) * os->nproposals) / sizeof(uint64_t);
  ((struct sadb_prop *)headers[SADB_EXT_PROPOSAL])->sadb_prop_num = os->nproposals;
a1741 1
    struct netsec_sadb_proposal *proposal = os->proposals;
d1743 50
a1792 16
    for (j = 0; j < os->nproposals; j++) {
      sadb_comb->sadb_comb_auth = proposal->auth;
      sadb_comb->sadb_comb_encrypt = proposal->encrypt;
      sadb_comb->sadb_comb_flags = proposal->flags;
      sadb_comb->sadb_comb_auth_minbits = proposal->auth_minbits;
      sadb_comb->sadb_comb_auth_maxbits = proposal->auth_maxbits;
      sadb_comb->sadb_comb_encrypt_minbits = proposal->encrypt_minbits;
      sadb_comb->sadb_comb_encrypt_maxbits = proposal->encrypt_maxbits;
      sadb_comb->sadb_comb_soft_allocations = proposal->soft.allocations;
      sadb_comb->sadb_comb_hard_allocations = proposal->hard.allocations;
      sadb_comb->sadb_comb_soft_bytes = proposal->soft.bytes;
      sadb_comb->sadb_comb_hard_bytes = proposal->hard.bytes;
      sadb_comb->sadb_comb_soft_addtime = proposal->soft.addtime;
      sadb_comb->sadb_comb_hard_addtime = proposal->hard.addtime;
      sadb_comb->sadb_comb_soft_usetime = proposal->soft.usetime;
      sadb_comb->sadb_comb_hard_usetime = proposal->hard.usetime;
a1793 1
      proposal++;
d1798 1
a1798 1
				  NULL, os->satype, count))!= 0)
a1808 2
#endif
  return 0;
@


1.21
log
@Added support for TCP MD5 option (RFC 2385).
@
text
@a1296 1
	    ipsec_in_use--;
a1313 1
	    ipsec_in_use++;
a1334 1
		ipsec_in_use++;
a1361 1
		ipsec_in_use--;
a1383 1
		    ipsec_in_use--;
a1386 1
		ipsec_in_use++;
a1414 1
	            ipsec_in_use++;
@


1.20
log
@rename SADB_foo_X_bar to SADB_X_foo_bar
@
text
@d777 6
d870 7
d1004 7
d1780 5
@


1.19
log
@Introduce M_PFKEY kmem type, and use it. (angelos@@ ok)
@
text
@d72 3
a74 3
    { SADB_EALG_X_BLF, 64, 5, BLF_MAXKEYLEN},
    { SADB_EALG_X_CAST, 64, 5, 16},
    { SADB_EALG_X_SKIPJACK, 64, 10, 10},
d80 1
a80 1
{ SADB_AALG_X_RIPEMD160HMAC96, 0, 160, 160 }
d180 1
a180 1
      if (sadb_sa->sadb_sa_flags & SADB_SAFLAGS_X_HALFIV)
d183 1
a183 1
      if (sadb_sa->sadb_sa_flags & SADB_SAFLAGS_X_TUNNEL)
d214 1
a214 1
    sadb_sa->sadb_sa_flags |= SADB_SAFLAGS_X_HALFIV;
d217 1
a217 1
    sadb_sa->sadb_sa_flags |= SADB_SAFLAGS_X_TUNNEL;
d757 1
a757 1
	case SADB_SATYPE_X_AH_OLD:
d765 1
a765 1
	case SADB_SATYPE_X_ESP_OLD:
d773 1
a773 1
	case SADB_SATYPE_X_IPIP:
d842 1
a842 1
	  case SADB_SATYPE_X_AH_OLD:
d851 1
a851 1
	  case SADB_SATYPE_X_ESP_OLD:
d860 1
a860 1
	  case SADB_SATYPE_X_IPIP:
d968 1
a968 1
	  case SADB_SATYPE_X_AH_OLD:
d977 1
a977 1
	  case SADB_SATYPE_X_ESP_OLD:
d986 1
a986 1
	  case SADB_SATYPE_X_IPIP:
d1040 1
a1040 1
      tdb_delete(sa2, ((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_flags & SADB_SAFLAGS_X_CHAINDEL, TDBEXP_TIMEOUT);
d1138 1
a1138 1
	 * SADB_SAFLAGS_X_REPLACEFLOW set means we should remove any
d1142 1
a1142 1
	          SADB_SAFLAGS_X_REPLACEFLOW;
d1160 1
a1160 1
		SADB_SAFLAGS_X_LOCALFLOW;
d1167 4
a1170 4
	src = (union sockaddr_union *) (headers[SADB_EXT_X_SRC_FLOW] + sizeof(struct sadb_address));
	dst = (union sockaddr_union *) (headers[SADB_EXT_X_DST_FLOW] + sizeof(struct sadb_address));
	srcmask = (union sockaddr_union *) (headers[SADB_EXT_X_SRC_MASK] + sizeof(struct sadb_address));
	dstmask = (union sockaddr_union *) (headers[SADB_EXT_X_DST_MASK] + sizeof(struct sadb_address));
d1172 2
a1173 2
	if (headers[SADB_EXT_X_PROTOCOL])
	  sproto = ((struct sadb_protocol *) headers[SADB_EXT_X_PROTOCOL])->sadb_protocol_proto;
d1461 2
a1462 2
	tdb2 = gettdb(((struct sadb_sa *)headers[SADB_EXT_X_SA2])->sadb_sa_spi,
		      (union sockaddr_union *)(headers[SADB_EXT_X_DST2] +
d1464 1
a1464 1
		      SADB_GETSPROTO(((struct sadb_protocol *)headers[SADB_EXT_X_PROTOCOL])->sadb_protocol_proto));
d1515 2
a1516 2
	tdb2 = gettdb(((struct sadb_sa *)headers[SADB_EXT_X_SA2])->sadb_sa_spi,
		     (union sockaddr_union *)(headers[SADB_EXT_X_DST2] +
d1518 1
a1518 1
		     SADB_GETSPROTO(((struct sadb_protocol *)headers[SADB_EXT_X_PROTOCOL])->sadb_protocol_proto));
d1752 1
a1752 1
      satype = sa->tdb_xform->xf_type == XF_OLD_AH ? SADB_SATYPE_X_AH_OLD : SADB_SATYPE_AH;
d1755 1
a1755 1
      satype = sa->tdb_xform->xf_type == XF_OLD_ESP ? SADB_SATYPE_X_ESP_OLD : SADB_SATYPE_ESP;
d1758 1
a1758 1
      satype = SADB_SATYPE_X_IPIP;
@


1.18
log
@Fix M_TEMP memory leak in pfkeyv2_expire()
(likewise future pfkeyv2_acquire())
@
text
@d121 1
a121 1
  if (!(pfkeyv2_socket = malloc(sizeof(struct pfkeyv2_socket), M_TEMP,
d157 1
a157 1
    free(pfkeyv2_socket, M_TEMP);
d463 1
a463 1
  if (!(buffer = malloc(j + sizeof(struct sadb_msg), M_TEMP, M_DONTWAIT))) {
d553 1
a553 1
    free(buffer, M_TEMP);
d592 1
a592 1
  if (!(p = malloc(i, M_TEMP, M_DONTWAIT))) {
d667 1
a667 1
    free(buffer, M_TEMP);
d702 1
a702 1
    if (!(freeme = malloc(sizeof(struct sadb_msg) + len, M_TEMP,
d729 1
a729 1
    free(freeme, M_TEMP);
d791 1
a791 1
      if (!(freeme = malloc(sizeof(struct sadb_sa), M_TEMP, M_DONTWAIT))) {
d1068 1
a1068 1
      if (!(freeme = malloc(i, M_TEMP, M_DONTWAIT))) {
d1611 2
a1612 2
    free(freeme, M_TEMP);
  free(message, M_TEMP);
d1644 1
a1644 1
  if (!(p = malloc(i, M_TEMP, M_DONTWAIT))) {
d1735 1
a1735 1
    free(buffer, M_TEMP);
d1770 1
a1770 1
  if (!(p = malloc(i, M_TEMP, M_DONTWAIT))) {
d1812 1
a1812 1
    free(buffer, M_TEMP);
@


1.17
log
@Avoid bzero + free after failed malloc(). From niklas@@
@
text
@d1627 1
a1627 1
  void *p, *headers[SADB_EXT_MAX+1], *buffer;
d1733 4
d1748 1
a1748 1
  void *p, *headers[SADB_EXT_MAX+1], *buffer;
d1810 4
@


1.16
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d551 4
a554 2
  bzero(buffer, j + sizeof(struct sadb_msg));
  free(buffer, M_TEMP);
@


1.15
log
@A new scalable IPsec SA expiration model.
@
text
@d289 1
a289 1
  tdb_expiration(tdb, 0);
d678 2
a679 2
  int i, j, rval = 0, mode = PFKEYV2_SENDMESSAGE_BROADCAST, delflag = 0;
  struct pfkeyv2_socket *pfkeyv2_socket, *s = NULL;
d719 3
a721 3
    for (s = pfkeyv2_sockets; s; s = s->next)
      if (s->flags & PFKEYV2_SOCKETFLAGS_PROMISC)
	pfkey_sendup(s->socket, packet, 1);
d740 6
a745 6
	    if (!ah_enable) {
		rval = EOPNOTSUPP;
		goto ret;
	    }
	    sa.tdb_sproto = IPPROTO_AH;
	    break;
d748 6
a753 6
	    if (!esp_enable) {
		rval = EOPNOTSUPP;
		goto ret;
	    }
	    sa.tdb_sproto = IPPROTO_ESP;
	    break;
d756 6
a761 6
	    if (!ah_enable) {
		rval = EOPNOTSUPP;
		goto ret;
	    }
	    sa.tdb_sproto = IPPROTO_AH;
	    break;
d764 6
a769 6
	    if (!esp_enable) {
		rval = EOPNOTSUPP;
		goto ret;
	    }
	    sa.tdb_sproto = IPPROTO_ESP;
	    break;
d772 2
a773 2
	    sa.tdb_sproto = IPPROTO_IPIP;
	    break;
d776 2
a777 2
	    rval = EOPNOTSUPP;
	    goto ret;
d802 1
d809 1
a809 1
	goto ret;
d813 4
d819 38
d858 4
a861 47
	{
	  struct tdb *newsa = (struct tdb *)freeme;
	  struct ipsecinit ii;
	  int alg;

	  bzero(&ii, sizeof(struct ipsecinit));
	  switch (((struct sadb_msg *)headers[0])->sadb_msg_satype) {
	      case SADB_SATYPE_AH:
		  if (!ah_enable) {
		      rval = EOPNOTSUPP;
		      goto ret;
		  }
		  newsa->tdb_sproto = IPPROTO_AH;
		  alg = XF_NEW_AH;
		  break;
	    
	      case SADB_SATYPE_ESP:
		  if (!esp_enable) {
		      rval = EOPNOTSUPP;
		      goto ret;
		  }
		  newsa->tdb_sproto = IPPROTO_ESP;
		  alg = XF_NEW_ESP;
		  break;

	      case SADB_SATYPE_X_AH_OLD:
		  if (!ah_enable) {
		      rval = EOPNOTSUPP;
		      goto ret;
		  }
		  newsa->tdb_sproto = IPPROTO_AH;
		  alg = XF_OLD_AH;
		  break;
	    
	      case SADB_SATYPE_X_ESP_OLD:
		  if (!esp_enable) {
		      rval = EOPNOTSUPP;
		      goto ret;
		  }
		  newsa->tdb_sproto = IPPROTO_ESP;
		  alg = XF_OLD_ESP;
		  break;

	      case SADB_SATYPE_X_IPIP:
		  newsa->tdb_sproto = IPPROTO_IPIP;
		  alg = XF_IP4;
		  break;
d863 4
a866 4
	      default: /* Nothing else supported */
		  rval = EOPNOTSUPP;
		  goto ret;
	  }
d868 7
a874 15
	  import_sa(newsa, headers[SADB_EXT_SA], &ii);
	  import_address((struct sockaddr *)&newsa->tdb_src,
			 headers[SADB_EXT_ADDRESS_SRC]);
	  import_address((struct sockaddr *)&newsa->tdb_dst,
			 headers[SADB_EXT_ADDRESS_DST]);
	  import_address((struct sockaddr *)&newsa->tdb_proxy,
			 headers[SADB_EXT_ADDRESS_PROXY]);

	  import_lifetime(newsa, headers[SADB_EXT_LIFETIME_CURRENT], 2);
	  import_lifetime(newsa, headers[SADB_EXT_LIFETIME_SOFT], 1);
	  import_lifetime(newsa, headers[SADB_EXT_LIFETIME_HARD], 0);
	  import_key(&ii, headers[SADB_EXT_KEY_AUTH], 1);
	  import_key(&ii, headers[SADB_EXT_KEY_ENCRYPT], 0);
	  import_identity(newsa, headers[SADB_EXT_IDENTITY_SRC], 0);
	  import_identity(newsa, headers[SADB_EXT_IDENTITY_DST], 1);
d876 10
a885 2
	  headers[SADB_EXT_KEY_AUTH] = NULL;
	  headers[SADB_EXT_KEY_ENCRYPT] = NULL;
d887 6
a892 12
	  rval = tdb_init(newsa, alg, &ii);
	  if (rval) {
	    rval = EINVAL;
	    tdb_delete(freeme, 0);
	    freeme = NULL;
	    goto ret;
	  }
	  newsa->tdb_flow = sa2->tdb_flow;
	  newsa->tdb_cur_allocations = sa2->tdb_cur_allocations;
	  for (flow = newsa->tdb_flow; flow != NULL; flow = flow->flow_next)
	    flow->flow_sa = newsa;
	  sa2->tdb_flow = NULL;
d894 9
a902 4

	 tdb_delete(sa2, 0);
	 puttdb((struct tdb *) freeme);
	 sa2 = freeme = NULL;
d904 9
a912 9
	  if (headers[SADB_EXT_ADDRESS_PROXY] ||
	      headers[SADB_EXT_KEY_AUTH] ||
	      headers[SADB_EXT_KEY_ENCRYPT] ||
	      headers[SADB_EXT_IDENTITY_SRC] ||
	      headers[SADB_EXT_IDENTITY_DST] ||
	      headers[SADB_EXT_SENSITIVITY]) {
	    rval = EINVAL;
	    goto ret;
	  }
d914 4
a917 4
	  import_sa(sa2, headers[SADB_EXT_SA], NULL);
	  import_lifetime(sa2, headers[SADB_EXT_LIFETIME_CURRENT], 2);
	  import_lifetime(sa2, headers[SADB_EXT_LIFETIME_SOFT], 1);
	  import_lifetime(sa2, headers[SADB_EXT_LIFETIME_HARD], 0);
d919 1
d923 1
d930 1
a930 1
	goto ret;
d935 1
a935 1
	goto ret;
d948 8
a955 8
	    case SADB_SATYPE_AH:
		if (!ah_enable) {
		    rval = EOPNOTSUPP;
		    goto ret;
		}
		newsa->tdb_sproto = IPPROTO_AH;
		alg = XF_NEW_AH;
		break;
d957 35
a991 35
	    case SADB_SATYPE_ESP:
		if (!esp_enable) {
		    rval = EOPNOTSUPP;
		    goto ret;
		}
		newsa->tdb_sproto = IPPROTO_ESP;
		alg = XF_NEW_ESP;
		break;
		
	    case SADB_SATYPE_X_AH_OLD:
		if (!ah_enable) {
		    rval = EOPNOTSUPP;
		    goto ret;
		}
		newsa->tdb_sproto = IPPROTO_AH;
		alg = XF_OLD_AH;
		break;
	    
	    case SADB_SATYPE_X_ESP_OLD:
		if (!esp_enable) {
		    rval = EOPNOTSUPP;
		    goto ret;
		}
		newsa->tdb_sproto = IPPROTO_ESP;
		alg = XF_OLD_ESP;
		break;

	    case SADB_SATYPE_X_IPIP:
		newsa->tdb_sproto = IPPROTO_IPIP;
		alg = XF_IP4;
		break;

	    default: /* Nothing else supported */
		rval = EOPNOTSUPP;
		goto ret;
d1016 1
a1016 1
	  tdb_delete(freeme, 0);
d1018 1
a1018 1
	  goto ret;
d1023 1
d1028 9
a1036 8
	sa2 = gettdb(((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_spi,
		     (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
					      sizeof(struct sadb_address)),
		     SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
	if (sa2 == NULL) {
	    rval = ESRCH;
	    goto ret;
	}
d1038 4
a1041 3
	tdb_delete(sa2, ((struct sadb_sa *)headers[SADB_EXT_SA])->sadb_sa_flags & SADB_SAFLAGS_X_CHAINDEL);
	sa2 = NULL;
	break;
d1044 1
d1051 1
a1051 1
	goto ret;
d1057 1
d1146 1
d1153 1
a1153 1
		goto ret;
d1183 1
a1183 1
	    goto ret;
d1200 1
a1200 1
		goto ret;
d1290 1
a1290 1
		goto ret;
d1313 1
a1313 1
		    goto ret;
d1323 1
a1323 1
		goto ret;
d1367 1
a1367 1
		    goto ret;
d1397 1
a1397 1
			goto ret;
d1412 1
a1412 1
		    goto ret;
d1433 1
a1433 2
		tdb_delete(sa2, 0);
		break;
d1442 2
a1443 2

     break;
d1448 2
a1449 1
	
d1451 3
a1453 3
		     (union sockaddr_union *)(headers[SADB_EXT_ADDRESS_DST] +
					      sizeof(struct sadb_address)),
		     SADB_GETSPROTO(((struct sadb_msg *)headers[0])->sadb_msg_satype));
d1456 1
a1456 1
	    goto ret;
d1460 3
a1462 3
		     (union sockaddr_union *)(headers[SADB_EXT_X_DST2] +
					      sizeof(struct sadb_address)),
		     SADB_GETSPROTO(((struct sadb_protocol *)headers[SADB_EXT_X_PROTOCOL])->sadb_protocol_proto));
d1466 1
a1466 1
	    goto ret;
d1474 1
a1474 1
	      goto ret;
d1489 1
d1491 1
a1491 2
       
	break;
d1496 2
a1497 1
	
d1504 1
a1504 1
	    goto ret;
d1510 1
a1510 1
	    goto ret;
d1520 1
a1520 1
	    goto ret;
d1526 1
a1526 1
	    goto ret;
d1538 2
a1539 2
       
	break;
d1548 2
a1549 2
	for (s = pfkeyv2_sockets; s; s = s->next)
	  if ((s != pfkeyv2_socket) &&
d1553 1
a1553 1
	    pfkey_sendup(s->socket, packet, 1);
d1613 4
@


1.14
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@a224 2
  struct expiration *exp;
    
a243 6
	  exp = get_expiration();
	  bcopy(&tdb->tdb_dst, &exp->exp_dst, SA_LEN(&tdb->tdb_dst.sa));
	  exp->exp_spi = tdb->tdb_spi;
	  exp->exp_sproto = tdb->tdb_sproto;
	  exp->exp_timeout = tdb->tdb_exp_timeout;
	  put_expiration(exp);
a269 6
	  exp = get_expiration();
	  bcopy(&tdb->tdb_dst, &exp->exp_dst, SA_LEN(&tdb->tdb_dst.sa));
	  exp->exp_spi = tdb->tdb_spi;
	  exp->exp_sproto = tdb->tdb_sproto;
	  exp->exp_timeout = tdb->tdb_soft_timeout;
	  put_expiration(exp);
d287 3
@


1.13
log
@when the REPLACE flag was used, but no former flows was there, we did not
increment the IPSEC use counter, potentially missing IPSEC processing on
output.
@
text
@d32 2
d751 4
d759 4
d767 4
d775 4
d834 4
d843 4
d852 4
d861 4
d959 4
d968 4
d977 4
d986 4
@


1.12
log
@Implement SADB_SAFLAGS_X_REPLACEFLOW
@
text
@d1269 1
d1353 1
@


1.11
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d691 1
d871 5
a907 1

d1084 1
a1084 1
	struct flow *flow = NULL, *flow2 = NULL;
d1087 13
a1099 1
	u_int8_t sproto = 0, local = 0;
d1133 2
a1134 2
	if ((delflag && (flow == NULL)) ||
	    (!delflag && (flow != NULL)))
d1149 3
a1151 2
	    if ((delflag && (flow2 == NULL)) ||
		(!delflag && (flow2 != NULL)))
d1160 2
d1172 2
a1219 1
	
d1231 1
a1231 1
	else
d1250 32
a1281 1
	
d1298 1
a1298 1
	    else
d1326 51
d1380 1
a1380 1
	if (!delflag) {
@


1.10
log
@Implement lifetime expiration notifications.  Fix some typos.  Remove statics.
@
text
@d1342 47
@


1.9
log
@update allocation statistics
@
text
@a61 1
#if 0 /* XXX */
a62 1
#endif 
d84 11
a94 1
int pfkeyv2_parsemessage(void *p, int len, void **headers);
d96 5
a100 3
int pfkeyv2_init(void);
int pfkeyv2_cleanup(void);
int pfkeyv2_expire(struct tdb *);
d105 1
a105 1
static int
d114 1
a114 1
static int
d133 1
a133 1
static int
d161 1
a161 1
static void
d189 1
a189 1
static void 
d220 1
a220 1
static void
d301 1
a301 1
static void
d353 1
a353 1
static void
d383 1
a383 1
static void
d397 1
a397 1
static void
d422 1
a422 1
static void
d442 1
a442 1
static void
d457 1
a457 1
static int
d568 1
a568 1
static int
d659 1
a659 1
static int
d683 1
a683 1
static int
d1534 1
a1534 1
pfkeyv2_expire(struct tdb *sa)
d1536 66
a1601 2
  /* XXX missing */
  return 0;
@


1.8
log
@remove unnecessary malloc checks when using WAITOK
@
text
@d1217 1
d1262 1
d1264 16
@


1.7
log
@clear key headers earlier
@
text
@a794 5
	if (freeme == NULL) {
	    rval = ENOMEM;
	    goto ret;
	} 

a899 5
      if (freeme == NULL) {
	  rval = ENOMEM;
	  goto ret;
      } 

@


1.6
log
@more paranoid maintenance
@
text
@d855 3
a866 3
	 headers[SADB_EXT_KEY_AUTH] = NULL;
	 headers[SADB_EXT_KEY_ENCRYPT] = NULL;

d965 3
a975 3

      headers[SADB_EXT_KEY_AUTH] = NULL;
      headers[SADB_EXT_KEY_ENCRYPT] = NULL;
@


1.5
log
@keep track of SATYPE registrations per PFKEY socket
@
text
@d1304 1
a1304 1
	      rval = EINVAL;
d1312 4
@


1.4
log
@ESRCH, not EEXIST; markus.friedl@@informatik.uni-erlangen.de
@
text
@d53 5
a57 4
  struct pfkeyv2_socket *next;
  struct socket *socket;
  int flags;
  uint32_t pid;
d70 5
a74 5
{ SADB_EALG_DESCBC, 64, 64, 64 },
{ SADB_EALG_3DESCBC, 64, 192, 192 },
{ SADB_EALG_X_BLF, 64, 5, BLF_MAXKEYLEN},
{ SADB_EALG_X_CAST, 64, 5, 16},
{ SADB_EALG_X_SKIPJACK, 64, 10, 10},
d448 2
a449 1
pfkeyv2_sendmessage(void **headers, int mode, struct socket *socket)
d508 12
a519 3
	if (s->flags & PFKEYV2_SOCKETFLAGS_REGISTERED)
	  pfkey_sendup(s->socket, packet, 1);
    
d663 1
a663 1
			       dump_state->socket);
d1020 4
a1023 1

d1384 1
a1384 1
  rval = pfkeyv2_sendmessage(headers, mode, socket);
d1500 1
a1500 1
				  NULL))!= 0)
@


1.3
log
@Possible cause of responses not going back to userland.
@
text
@d778 1
a778 1
	rval = EEXIST;
d976 1
a976 1
	    rval = EEXIST;
d990 1
a990 1
	rval = EEXIST;
d1075 1
a1075 1
		rval = EEXIST;
d1105 1
a1105 1
	    rval = EEXIST;
d1121 1
a1121 1
		rval = EEXIST;
d1272 1
a1272 1
	    rval = EEXIST;
d1282 1
a1282 1
	    rval = EEXIST;
@


1.2
log
@Removed osdep.h dependencies.
@
text
@d1347 1
a1347 1
  if (rval < 0) {
d1353 1
a1353 1
    ((struct sadb_msg *)headers[0])->sadb_msg_errno = -rval;
@


1.1
log
@PF_KEY_V2, with local extensions for SPD management.
@
text
@d18 12
a29 1
#include <sys/osdep.h>
d38 3
a40 3
  int (*create)(OSDEP_SOCKET *socket);
  int (*release)(OSDEP_SOCKET *socket);
  int (*send)(OSDEP_SOCKET *socket, void *message, int len);
d54 1
a54 1
  OSDEP_SOCKET *socket;
d84 1
a84 1
int pfkey_sendup(OSDEP_SOCKET *socket, OSDEP_PACKET *packet, int more);
d95 10
a104 1
pfkeyv2_create(OSDEP_SOCKET *socket)
d108 3
a110 2
  if (!(pfkeyv2_socket = OSDEP_MALLOC(sizeof(struct pfkeyv2_socket))))
    return OSDEP_ERROR(ENOMEM);
d115 1
a115 1
  pfkeyv2_socket->pid = OSDEP_CURRENTPID;
d123 1
a123 1
pfkeyv2_release(OSDEP_SOCKET *socket)
d144 1
a144 1
    OSDEP_FREE(pfkeyv2_socket);
a380 1

a381 2

#if !OSDEP_SALEN
a382 2
#endif /* !OSDEP_SALEN */

d447 1
a447 1
pfkeyv2_sendmessage(void **headers, int mode, OSDEP_SOCKET *socket)
d451 1
a451 1
  OSDEP_PACKET *packet;
d460 2
a461 2
  if (!(buffer = OSDEP_MALLOC(j + sizeof(struct sadb_msg)))) {
    rval = OSDEP_ERROR(ENOMEM);
d477 2
a478 2
  if ((rval = OSDEP_DATATOPACKET(buffer + sizeof(struct sadb_msg),
				 j, &packet)) != 0)
d492 2
a493 2
      if ((rval = OSDEP_DATATOPACKET(buffer, sizeof(struct sadb_msg) + j,
				    &packet)) != 0)
d500 2
a501 2
      OSDEP_ZEROPACKET(packet);
      OSDEP_FREEPACKET(packet);
d509 1
a509 1
      OSDEP_FREEPACKET(packet);
d518 2
a519 2
      if ((rval = OSDEP_DATATOPACKET(buffer, sizeof(struct sadb_msg) + j,
				     &packet)) != 0)
d527 1
a527 1
      OSDEP_FREEPACKET(packet);
d534 1
a534 1
      OSDEP_FREEPACKET(packet);
d540 1
a540 1
  OSDEP_FREE(buffer);
d578 2
a579 2
  if (!(p = OSDEP_MALLOC(i))) {
    rval = OSDEP_ERROR(ENOMEM);
d634 1
a634 1
  OSDEP_SOCKET *socket;
d653 1
a653 1
    OSDEP_FREE(buffer);
d663 1
a663 1
pfkeyv2_send(OSDEP_SOCKET *socket, void *message, int len)
d680 1
a680 1
    rval = OSDEP_ERROR(EINVAL);
d685 1
a685 1
    OSDEP_PACKET *packet;
d687 3
a689 2
    if (!(freeme = OSDEP_MALLOC(sizeof(struct sadb_msg) + len))) {
      rval = OSDEP_ERROR(ENOMEM);
d698 1
a698 1
    ((struct sadb_msg *)freeme)->sadb_msg_seq = OSDEP_CURRENTPID;
d702 2
a703 2
    if ((rval = OSDEP_DATATOPACKET(freeme, sizeof(struct sadb_msg) + len,
				   &packet)) != 0)
d710 2
a711 2
    OSDEP_ZEROPACKET(packet);
    OSDEP_FREEPACKET(packet);
d714 1
a714 1
    OSDEP_FREE(freeme);
d760 2
a761 2
      if (!(freeme = OSDEP_MALLOC(sizeof(struct sadb_sa)))) {
	rval = OSDEP_ERROR(ENOMEM);
d846 1
a846 1
	    rval = OSDEP_ERROR(EINVAL);
d866 1
a866 1
	    rval = OSDEP_ERROR(EINVAL);
d889 1
a889 1
	rval = OSDEP_ERROR(EINVAL);
d956 1
a956 1
	  rval = OSDEP_ERROR(EINVAL);
d1005 2
a1006 2
      if (!(freeme = OSDEP_MALLOC(i))) {
	rval = OSDEP_ERROR(ENOMEM);
d1053 1
a1053 1
	if ((rval == OSDEP_ERROR(ENOMEM)) || (rval == OSDEP_ERROR(ENOBUFS)))
d1308 1
a1308 1
	OSDEP_PACKET *packet;
d1310 1
a1310 1
	if ((rval = OSDEP_DATATOPACKET(message, len, &packet)) != 0)
d1320 1
a1320 1
	OSDEP_FREEPACKET(packet);
d1323 1
a1323 1
	  rval = OSDEP_ERROR(EINVAL);
d1342 1
a1342 1
      rval = OSDEP_ERROR(EINVAL);
d1348 2
a1349 2
    if ((rval == OSDEP_ERROR(EINVAL)) || (rval == OSDEP_ERROR(ENOMEM)) ||
	(rval == OSDEP_ERROR(ENOBUFS)))
d1374 2
a1375 2
    OSDEP_FREE(freeme);
  OSDEP_FREE(message);
d1389 1
a1389 1
    rval = OSDEP_ERROR(ESRCH);
d1403 2
a1404 2
  if (!(p = OSDEP_MALLOC(i))) {
    rval = OSDEP_ERROR(ENOMEM);
@

