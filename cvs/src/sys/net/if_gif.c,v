head	1.99;
access;
symbols
	OPENBSD_6_2:1.99.0.4
	OPENBSD_6_2_BASE:1.99
	OPENBSD_6_1:1.91.0.4
	OPENBSD_6_1_BASE:1.91
	OPENBSD_6_0:1.85.0.4
	OPENBSD_6_0_BASE:1.85
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.77.0.4
	OPENBSD_5_8_BASE:1.77
	OPENBSD_5_7:1.72.0.2
	OPENBSD_5_7_BASE:1.72
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.59.0.2
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.57.0.2
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.8
	OPENBSD_5_0:1.55.0.6
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.55.0.4
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.51.0.6
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.31.0.6
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.31.0.4
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.25
	UBC:1.20.0.4
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.99
date	2017.08.11.21.24.19;	author mpi;	state Exp;
branches;
next	1.98;
commitid	qO4hXiGM2yDTtiTI;

1.98
date	2017.06.20.11.12.13;	author bluhm;	state Exp;
branches;
next	1.97;
commitid	hmkIwC7Ma691pjPM;

1.97
date	2017.06.19.17.58.49;	author bluhm;	state Exp;
branches;
next	1.96;
commitid	o1URxEJIRKTXxlGk;

1.96
date	2017.05.18.10.56.45;	author bluhm;	state Exp;
branches;
next	1.95;
commitid	end8oXU4pM3sNkRR;

1.95
date	2017.05.17.09.00.08;	author mpi;	state Exp;
branches;
next	1.94;
commitid	EjhZ35GJNRnpMcW8;

1.94
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.93;
commitid	Gef6NNDxonzfVaq2;

1.93
date	2017.04.14.20.50.35;	author bluhm;	state Exp;
branches;
next	1.92;
commitid	Qw2ML7N2AtiQ0XM9;

1.92
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.91;
commitid	00hB28wQPwG5Ysk0;

1.91
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.90;
commitid	3e3CkrbYekyVOcxy;

1.90
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.89;
commitid	pVtptbHA3yk4jSpN;

1.89
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.88;
commitid	F6oNrr9LCLUSAxgA;

1.88
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.87;
commitid	VyLWTsbepAOk7VQM;

1.87
date	2016.12.13.06.51.11;	author dlg;	state Exp;
branches;
next	1.86;
commitid	OT2zwp1xv8iSCwtY;

1.86
date	2016.09.13.07.48.45;	author mpi;	state Exp;
branches;
next	1.85;
commitid	htd0vDBbyrbnv5j5;

1.85
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.84;
commitid	Xo6g1xk26RWDGcjJ;

1.84
date	2016.01.14.09.20.31;	author mpi;	state Exp;
branches;
next	1.83;
commitid	mmanJIPww2fqlSXb;

1.83
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.82;
commitid	ILbVM1M3uPNjwswz;

1.82
date	2015.11.20.05.29.53;	author dlg;	state Exp;
branches;
next	1.81;
commitid	H5T87qmt0eZJrdGK;

1.81
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.80;
commitid	G2nTzngqgXpQqcJB;

1.80
date	2015.09.28.08.32.05;	author mpi;	state Exp;
branches;
next	1.79;
commitid	MCjArMsyMPhqxF1g;

1.79
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.78;
commitid	Cr0DVA7exR1t2zXg;

1.78
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.77;
commitid	RRi5waWu1LaKRicG;

1.77
date	2015.07.17.18.05.59;	author mpi;	state Exp;
branches;
next	1.76;
commitid	urytYsjJJXbr5ECc;

1.76
date	2015.07.16.21.21.49;	author mpi;	state Exp;
branches;
next	1.75;
commitid	4zKIc1SAiSgHAnwL;

1.75
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.74;
commitid	fE8TgA9vpwdUU5Wy;

1.74
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.73;
commitid	1aiWjheMGhmTuiHL;

1.73
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.72;
commitid	p4LJxGKbi0BU2cG6;

1.72
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.71;
commitid	zhW8jJrfVCoAthrR;

1.71
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.70;
commitid	t9FBKDfc4VDxpEy2;

1.70
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	mdGXHklUZmESVFlY;

1.69
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.68;
commitid	DQakU8LLWV6Iwx84;

1.68
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.67;
commitid	B4dZSbxas1X1IpXI;

1.67
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2014.04.21.12.22.25;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2013.10.19.14.46.30;	author mpi;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.17.16.27.40;	author bluhm;	state Exp;
branches;
next	1.62;

1.62
date	2013.06.17.18.19.44;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2013.06.16.20.45.51;	author bluhm;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.26.13.19.25;	author mpi;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.17.00.48.04;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.57;

1.57
date	2012.05.12.12.58.16;	author mpf;	state Exp;
branches;
next	1.56;

1.56
date	2012.04.14.09.39.46;	author yasuoka;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.11.09.36.07;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.22.12.33.25;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.21.14.08.14;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.24.14.55.53;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.28.16.14.39;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2008.05.07.13.45.35;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2008.04.26.01.24.01;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.26.17.13.30;	author jason;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.21.13.33.35;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.19.09.28.40;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.18.08.18.22;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.22.15.31.44;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.10.15.34.22;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.08.18.09.24;	author michele;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.28.20.06.11;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.16.07.58.43;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.11.03.58.37;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.03.14.51.05;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.20.01.34.26;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.10.17.33.28;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.09.06.05.04;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.20.22.29.57;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.27.15.48.38;	author itojun;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.06.25.06.33.48;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.15.03.38.34;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.09.06.27.08;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.09.06.23.06;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.04.23.55.57;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.20.13.50.53;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.20.10.33.28;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.06.03.26.10;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.31.22.32.28;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.31.17.21.50;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.30.21.52.50;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.07.04.05.37;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.17.06.29.27;	author itojun;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.01.17.05.42.39;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.12.06.40.45;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.10.22.40.16;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.09.19.23.49;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.07.19.28.48;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.40.00;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.54.01;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.99
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@/*	$OpenBSD: if_gif.c,v 1.98 2017/06/20 11:12:13 bluhm Exp $	*/
/*	$KAME: if_gif.c,v 1.43 2001/02/20 08:51:07 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_ether.h>
#include <netinet/ip_var.h>
#include <netinet/ip_ipip.h>
#include <netinet/ip_ipsp.h>

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif /* INET6 */

#include <net/if_gif.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#ifdef MPLS
#include <netinet/ip_ether.h>
#endif

#include "pf.h"
#if NPF > 0
#include <net/pfvar.h>
#endif

#define GIF_MTU		(1280)	/* Default MTU */
#define GIF_MTU_MIN	(1280)	/* Minimum MTU */
#define GIF_MTU_MAX	(8192)	/* Maximum MTU */

void	gifattach(int);
int	gif_clone_create(struct if_clone *, int);
int	gif_clone_destroy(struct ifnet *);
int	gif_checkloop(struct ifnet *, struct mbuf *);
void	gif_start(struct ifnet *);
int	gif_ioctl(struct ifnet *, u_long, caddr_t);
int	gif_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);

int	in_gif_output(struct ifnet *, int, struct mbuf **);
int	in6_gif_output(struct ifnet *, int, struct mbuf **);

/*
 * gif global variable definitions
 */
struct gif_softc_head gif_softc_list;
struct if_clone gif_cloner =
    IF_CLONE_INITIALIZER("gif", gif_clone_create, gif_clone_destroy);

void
gifattach(int count)
{
	LIST_INIT(&gif_softc_list);
	if_clone_attach(&gif_cloner);
}

int
gif_clone_create(struct if_clone *ifc, int unit)
{
	struct gif_softc *sc;

	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!sc)
		return (ENOMEM);

	snprintf(sc->gif_if.if_xname, sizeof sc->gif_if.if_xname,
	     "%s%d", ifc->ifc_name, unit);
	sc->gif_if.if_mtu    = GIF_MTU;
	sc->gif_if.if_flags  = IFF_POINTOPOINT | IFF_MULTICAST;
	sc->gif_if.if_xflags = IFXF_CLONED;
	sc->gif_if.if_ioctl  = gif_ioctl;
	sc->gif_if.if_start  = gif_start;
	sc->gif_if.if_output = gif_output;
	sc->gif_if.if_rtrequest = p2p_rtrequest;
	sc->gif_if.if_type   = IFT_GIF;
	IFQ_SET_MAXLEN(&sc->gif_if.if_snd, IFQ_MAXLEN);
	sc->gif_if.if_softc = sc;
	if_attach(&sc->gif_if);
	if_alloc_sadl(&sc->gif_if);

#if NBPFILTER > 0
	bpfattach(&sc->gif_if.if_bpf, &sc->gif_if, DLT_LOOP, sizeof(u_int32_t));
#endif
	NET_LOCK();
	LIST_INSERT_HEAD(&gif_softc_list, sc, gif_list);
	NET_UNLOCK();

	return (0);
}

int
gif_clone_destroy(struct ifnet *ifp)
{
	struct gif_softc *sc = ifp->if_softc;

	NET_LOCK();
	LIST_REMOVE(sc, gif_list);
	NET_UNLOCK();

	if_detach(ifp);

	if (sc->gif_psrc)
		free((caddr_t)sc->gif_psrc, M_IFADDR, 0);
	sc->gif_psrc = NULL;
	if (sc->gif_pdst)
		free((caddr_t)sc->gif_pdst, M_IFADDR, 0);
	sc->gif_pdst = NULL;
	free(sc, M_DEVBUF, sizeof(*sc));
	return (0);
}

void
gif_start(struct ifnet *ifp)
{
	struct gif_softc *sc = (struct gif_softc*)ifp;
	struct mbuf *m;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

		/* is interface up and usable? */
		if (!(ifp->if_flags & IFF_UP) ||
		    sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
		    sc->gif_psrc->sa_family != sc->gif_pdst->sa_family) {
			m_freem(m);
			continue;
		}

#if NBPFILTER > 0
		if (ifp->if_bpf) {
			int offset;
			sa_family_t family;
			u_int8_t proto;

			/* must decapsulate outer header for bpf */
			switch (sc->gif_psrc->sa_family) {
			case AF_INET:
				offset = sizeof(struct ip);
				proto = mtod(m, struct ip *)->ip_p;
				break;
#ifdef INET6
			case AF_INET6:
				offset = sizeof(struct ip6_hdr);
				proto = mtod(m, struct ip6_hdr *)->ip6_nxt;
				break;
#endif
			default:
				proto = 0;
				break;
			}
			switch (proto) {
			case IPPROTO_IPV4:
				family = AF_INET;
				break;
			case IPPROTO_IPV6:
				family = AF_INET6;
				break;
			case IPPROTO_ETHERIP:
				family = AF_LINK;
				offset += sizeof(struct etherip_header);
				break;
			case IPPROTO_MPLS:
				family = AF_MPLS;
				break;
			default:
				offset = 0;
				family = sc->gif_psrc->sa_family;
				break;
			}
			m->m_data += offset;
			m->m_len -= offset;
			m->m_pkthdr.len -= offset;
			bpf_mtap_af(ifp->if_bpf, family, m, BPF_DIRECTION_OUT);
			m->m_data -= offset;
			m->m_len += offset;
			m->m_pkthdr.len += offset;
		}
#endif

		/* XXX we should cache the outgoing route */

		switch (sc->gif_psrc->sa_family) {
		case AF_INET:
			ip_output(m, NULL, NULL, 0, NULL, NULL, 0);
			break;
#ifdef INET6
		case AF_INET6:
			/*
			 * force fragmentation to minimum MTU, to avoid path
			 * MTU discovery. It is too painful to ask for resend
			 * of inner packet, to achieve path MTU discovery for
			 * encapsulated packets.
			 */
			ip6_output(m, 0, NULL, IPV6_MINMTU, 0, NULL);
			break;
#endif
		default:
			m_freem(m);
			break;
		}
	}
}

int
gif_encap(struct ifnet *ifp, struct mbuf **mp, sa_family_t af)
{
	struct gif_softc *sc = (struct gif_softc*)ifp;
	int error = 0;
	/*
	 * Remove multicast and broadcast flags or encapsulated packet
	 * ends up as multicast or broadcast packet.
	 */
	(*mp)->m_flags &= ~(M_BCAST|M_MCAST);

	/*
	 * Encapsulate packet. Add IP or IP6 header depending on tunnel AF.
	 */
	switch (sc->gif_psrc->sa_family) {
	case AF_INET:
		error = in_gif_output(ifp, af, mp);
		break;
#ifdef INET6
	case AF_INET6:
		error = in6_gif_output(ifp, af, mp);
		break;
#endif
	default:
		m_freemp(mp);
		error = EAFNOSUPPORT;
		break;
	}

	if (error)
		return (error);

	error = gif_checkloop(ifp, *mp);
	return (error);
}

int
gif_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	struct gif_softc *sc = (struct gif_softc*)ifp;
	int error = 0;

	if (!(ifp->if_flags & IFF_UP) ||
	    sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
	    sc->gif_psrc->sa_family != sc->gif_pdst->sa_family) {
		m_freem(m);
		error = ENETDOWN;
		goto end;
	}

	error = gif_encap(ifp, &m, dst->sa_family);
	if (error)
		goto end;

	error = if_enqueue(ifp, m);

end:
	if (error)
		ifp->if_oerrors++;
	return (error);
}

int
gif_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct gif_softc *sc  = (struct gif_softc*)ifp;
	struct ifreq     *ifr = (struct ifreq *)data;
	int error = 0, size;
	struct sockaddr *dst, *src;
	struct sockaddr *sa;
	struct gif_softc *sc2;

	switch (cmd) {
	case SIOCSIFADDR:
		break;

	case SIOCSIFDSTADDR:
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCSIFPHYADDR:
#ifdef INET6
	case SIOCSIFPHYADDR_IN6:
#endif /* INET6 */
	case SIOCSLIFPHYADDR:
		switch (cmd) {
		case SIOCSIFPHYADDR:
			src = sintosa(
				&(((struct in_aliasreq *)data)->ifra_addr));
			dst = sintosa(
				&(((struct in_aliasreq *)data)->ifra_dstaddr));
			break;
#ifdef INET6
		case SIOCSIFPHYADDR_IN6:
			src = sin6tosa(
				&(((struct in6_aliasreq *)data)->ifra_addr));
			dst = sin6tosa(
				&(((struct in6_aliasreq *)data)->ifra_dstaddr));
			break;
#endif
		case SIOCSLIFPHYADDR:
			src = sstosa(&(((struct if_laddrreq *)data)->addr));
			dst = sstosa(&(((struct if_laddrreq *)data)->dstaddr));
			break;
		default:
			return (EINVAL);
		}

		/* sa_family must be equal */
		if (src->sa_family != dst->sa_family)
			return (EINVAL);

		/* validate sa_len */
		switch (src->sa_family) {
		case AF_INET:
			if (src->sa_len != sizeof(struct sockaddr_in))
				return (EINVAL);
			break;
#ifdef INET6
		case AF_INET6:
			if (src->sa_len != sizeof(struct sockaddr_in6))
				return (EINVAL);
			break;
#endif
		default:
			return (EAFNOSUPPORT);
		}
		switch (dst->sa_family) {
		case AF_INET:
			if (dst->sa_len != sizeof(struct sockaddr_in))
				return (EINVAL);
			break;
#ifdef INET6
		case AF_INET6:
			if (dst->sa_len != sizeof(struct sockaddr_in6))
				return (EINVAL);
			break;
#endif
		default:
			return (EAFNOSUPPORT);
		}

		/* check sa_family looks sane for the cmd */
		switch (cmd) {
		case SIOCSIFPHYADDR:
			if (src->sa_family == AF_INET)
				break;
			return (EAFNOSUPPORT);
#ifdef INET6
		case SIOCSIFPHYADDR_IN6:
			if (src->sa_family == AF_INET6)
				break;
			return (EAFNOSUPPORT);
#endif /* INET6 */
		case SIOCSLIFPHYADDR:
			/* checks done in the above */
			break;
		}

		LIST_FOREACH(sc2, &gif_softc_list, gif_list) {
			if (sc2 == sc)
				continue;
			if (!sc2->gif_pdst || !sc2->gif_psrc)
				continue;
			if (sc2->gif_pdst->sa_family != dst->sa_family ||
			    sc2->gif_pdst->sa_len != dst->sa_len ||
			    sc2->gif_psrc->sa_family != src->sa_family ||
			    sc2->gif_psrc->sa_len != src->sa_len)
				continue;
			/* can't configure same pair of address onto two gifs */
			if (bcmp(sc2->gif_pdst, dst, dst->sa_len) == 0 &&
			    bcmp(sc2->gif_psrc, src, src->sa_len) == 0) {
				error = EADDRNOTAVAIL;
				goto bad;
			}

			/* can't configure multiple multi-dest interfaces */
#define multidest(x) \
	(satosin(x)->sin_addr.s_addr == INADDR_ANY)
#ifdef INET6
#define multidest6(x) \
	(IN6_IS_ADDR_UNSPECIFIED(&satosin6(x)->sin6_addr))
#endif
			if (dst->sa_family == AF_INET &&
			    multidest(dst) && multidest(sc2->gif_pdst)) {
				error = EADDRNOTAVAIL;
				goto bad;
			}
#ifdef INET6
			if (dst->sa_family == AF_INET6 &&
			    multidest6(dst) && multidest6(sc2->gif_pdst)) {
				error = EADDRNOTAVAIL;
				goto bad;
			}
#endif
		}

		if (sc->gif_psrc)
			free((caddr_t)sc->gif_psrc, M_IFADDR, 0);
		sa = malloc(src->sa_len, M_IFADDR, M_WAITOK);
		bcopy((caddr_t)src, (caddr_t)sa, src->sa_len);
		sc->gif_psrc = sa;

		if (sc->gif_pdst)
			free((caddr_t)sc->gif_pdst, M_IFADDR, 0);
		sa = malloc(dst->sa_len, M_IFADDR, M_WAITOK);
		bcopy((caddr_t)dst, (caddr_t)sa, dst->sa_len);
		sc->gif_pdst = sa;

		ifp->if_flags |= IFF_RUNNING;
		if_up(ifp);		/* send up RTM_IFINFO */

		error = 0;
		break;

#ifdef SIOCDIFPHYADDR
	case SIOCDIFPHYADDR:
		if (sc->gif_psrc) {
			free((caddr_t)sc->gif_psrc, M_IFADDR, 0);
			sc->gif_psrc = NULL;
		}
		if (sc->gif_pdst) {
			free((caddr_t)sc->gif_pdst, M_IFADDR, 0);
			sc->gif_pdst = NULL;
		}
		/* change the IFF_{UP, RUNNING} flag as well? */
		break;
#endif

	case SIOCGIFPSRCADDR:
#ifdef INET6
	case SIOCGIFPSRCADDR_IN6:
#endif /* INET6 */
		if (sc->gif_psrc == NULL) {
			error = EADDRNOTAVAIL;
			goto bad;
		}
		src = sc->gif_psrc;
		switch (cmd) {
		case SIOCGIFPSRCADDR:
			dst = &ifr->ifr_addr;
			size = sizeof(ifr->ifr_addr);
			break;
#ifdef INET6
		case SIOCGIFPSRCADDR_IN6:
			dst = sin6tosa(
				&(((struct in6_ifreq *)data)->ifr_addr));
			size = sizeof(((struct in6_ifreq *)data)->ifr_addr);
			break;
#endif /* INET6 */
		default:
			error = EADDRNOTAVAIL;
			goto bad;
		}
		if (src->sa_len > size)
			return (EINVAL);
		bcopy((caddr_t)src, (caddr_t)dst, src->sa_len);
		break;

	case SIOCGIFPDSTADDR:
#ifdef INET6
	case SIOCGIFPDSTADDR_IN6:
#endif /* INET6 */
		if (sc->gif_pdst == NULL) {
			error = EADDRNOTAVAIL;
			goto bad;
		}
		src = sc->gif_pdst;
		switch (cmd) {
		case SIOCGIFPDSTADDR:
			dst = &ifr->ifr_addr;
			size = sizeof(ifr->ifr_addr);
			break;
#ifdef INET6
		case SIOCGIFPDSTADDR_IN6:
			dst = sin6tosa(&(((struct in6_ifreq *)data)->ifr_addr));
			size = sizeof(((struct in6_ifreq *)data)->ifr_addr);
			break;
#endif /* INET6 */
		default:
			error = EADDRNOTAVAIL;
			goto bad;
		}
		if (src->sa_len > size)
			return (EINVAL);
		bcopy((caddr_t)src, (caddr_t)dst, src->sa_len);
		break;

	case SIOCGLIFPHYADDR:
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL) {
			error = EADDRNOTAVAIL;
			goto bad;
		}

		/* copy src */
		src = sc->gif_psrc;
		dst = sstosa(&(((struct if_laddrreq *)data)->addr));
		size = sizeof(((struct if_laddrreq *)data)->addr);
		if (src->sa_len > size)
			return (EINVAL);
		bcopy((caddr_t)src, (caddr_t)dst, src->sa_len);

		/* copy dst */
		src = sc->gif_pdst;
		dst = sstosa(&(((struct if_laddrreq *)data)->dstaddr));
		size = sizeof(((struct if_laddrreq *)data)->dstaddr);
		if (src->sa_len > size)
			return (EINVAL);
		bcopy((caddr_t)src, (caddr_t)dst, src->sa_len);
		break;

	case SIOCSIFFLAGS:
		/* if_ioctl() takes care of it */
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu < GIF_MTU_MIN || ifr->ifr_mtu > GIF_MTU_MAX)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

	case SIOCSLIFPHYRTABLE:
		if (ifr->ifr_rdomainid < 0 ||
		    ifr->ifr_rdomainid > RT_TABLEID_MAX ||
		    !rtable_exists(ifr->ifr_rdomainid)) {
			error = EINVAL;
			break;
		}
		sc->gif_rtableid = ifr->ifr_rdomainid;
		break;
	case SIOCGLIFPHYRTABLE:
		ifr->ifr_rdomainid = sc->gif_rtableid;
		break;
	default:
		error = ENOTTY;
		break;
	}
 bad:
	return (error);
}

int
gif_checkloop(struct ifnet *ifp, struct mbuf *m)
{
	struct m_tag *mtag;

	/*
	 * gif may cause infinite recursion calls when misconfigured.
	 * We'll prevent this by detecting loops.
	 */
	for (mtag = m_tag_find(m, PACKET_TAG_GIF, NULL); mtag;
	    mtag = m_tag_find(m, PACKET_TAG_GIF, mtag)) {
		if (*(struct ifnet **)(mtag + 1) == ifp) {
			log(LOG_NOTICE, "gif_output: "
			    "recursively called too many times\n");
			m_freem(m);
			return ENETUNREACH;
		}
	}

	mtag = m_tag_get(PACKET_TAG_GIF, sizeof(struct ifnet *), M_NOWAIT);
	if (mtag == NULL) {
		m_freem(m);
		return ENOMEM;
	}
	*(struct ifnet **)(mtag + 1) = ifp;
	m_tag_prepend(m, mtag);
	return 0;
}

int
in_gif_output(struct ifnet *ifp, int family, struct mbuf **m0)
{
	struct gif_softc *sc = (struct gif_softc*)ifp;
	struct sockaddr_in *sin_src = satosin(sc->gif_psrc);
	struct sockaddr_in *sin_dst = satosin(sc->gif_pdst);
	struct tdb tdb;
	struct xformsw xfs;
	int error;
	struct mbuf *m = *m0;

	if (sin_src == NULL || sin_dst == NULL ||
	    sin_src->sin_family != AF_INET ||
	    sin_dst->sin_family != AF_INET) {
		m_freem(m);
		return EAFNOSUPPORT;
	}

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.ph_rtableid),
		    family);
	}
#endif

	/* setup dummy tdb.  it highly depends on ipip_output() code. */
	bzero(&tdb, sizeof(tdb));
	bzero(&xfs, sizeof(xfs));
	tdb.tdb_src.sin.sin_family = AF_INET;
	tdb.tdb_src.sin.sin_len = sizeof(struct sockaddr_in);
	tdb.tdb_src.sin.sin_addr = sin_src->sin_addr;
	tdb.tdb_dst.sin.sin_family = AF_INET;
	tdb.tdb_dst.sin.sin_len = sizeof(struct sockaddr_in);
	tdb.tdb_dst.sin.sin_addr = sin_dst->sin_addr;
	tdb.tdb_xform = &xfs;
	xfs.xf_type = -1;	/* not XF_IP4 */

	switch (family) {
	case AF_INET:
		break;
#ifdef INET6
	case AF_INET6:
		break;
#endif
#if MPLS
	case AF_MPLS:
		break;
#endif
	default:
#ifdef DEBUG
	        printf("%s: warning: unknown family %d passed\n", __func__,
			family);
#endif
		m_freem(m);
		return EAFNOSUPPORT;
	}

	/* encapsulate into IPv4 packet */
	*m0 = NULL;
#ifdef MPLS
	if (family == AF_MPLS)
		error = etherip_output(m, &tdb, m0, IPPROTO_MPLS);
	else
#endif
	error = ipip_output(m, &tdb, m0, 0, 0);
	if (error)
		return error;
	else if (*m0 == NULL)
		return EFAULT;

	m = *m0;

	m->m_pkthdr.ph_rtableid = sc->gif_rtableid;
#if NPF > 0
	pf_pkt_addr_changed(m);
#endif
	return 0;
}

int
in_gif_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct mbuf *m = *mp;
	struct gif_softc *sc;
	struct ifnet *gifp = NULL;
	struct ip *ip;

	/* IP-in-IP header is caused by tunnel mode, so skip gif lookup */
	if (m->m_flags & M_TUNNEL) {
		m->m_flags &= ~M_TUNNEL;
		goto inject;
	}

	ip = mtod(m, struct ip *);

	/* this code will be soon improved. */
	LIST_FOREACH(sc, &gif_softc_list, gif_list) {
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
		    sc->gif_psrc->sa_family != AF_INET ||
		    sc->gif_pdst->sa_family != AF_INET ||
		    rtable_l2(sc->gif_rtableid) !=
		    rtable_l2(m->m_pkthdr.ph_rtableid)) {
			continue;
		}

		if ((sc->gif_if.if_flags & IFF_UP) == 0)
			continue;

		if (in_hosteq(satosin(sc->gif_psrc)->sin_addr, ip->ip_dst) &&
		    in_hosteq(satosin(sc->gif_pdst)->sin_addr, ip->ip_src)) {
			gifp = &sc->gif_if;
			break;
		}
	}

	if (gifp) {
		m->m_pkthdr.ph_ifidx = gifp->if_index;
		m->m_pkthdr.ph_rtableid = gifp->if_rdomain;
		gifp->if_ipackets++;
		gifp->if_ibytes += m->m_pkthdr.len;
		/* We have a configured GIF */
		return ipip_input_if(mp, offp, proto, af, gifp);
	}

inject:
	/* No GIF interface was configured */
	return ipip_input(mp, offp, proto, af);
}

#ifdef INET6
int
in6_gif_output(struct ifnet *ifp, int family, struct mbuf **m0)
{
	struct gif_softc *sc = (struct gif_softc*)ifp;
	struct sockaddr_in6 *sin6_src = satosin6(sc->gif_psrc);
	struct sockaddr_in6 *sin6_dst = satosin6(sc->gif_pdst);
	struct tdb tdb;
	struct xformsw xfs;
	int error;
	struct mbuf *m = *m0;

	if (sin6_src == NULL || sin6_dst == NULL ||
	    sin6_src->sin6_family != AF_INET6 ||
	    sin6_dst->sin6_family != AF_INET6) {
		m_freem(m);
		return EAFNOSUPPORT;
	}

	/* setup dummy tdb.  it highly depends on ipip_output() code. */
	bzero(&tdb, sizeof(tdb));
	bzero(&xfs, sizeof(xfs));
	tdb.tdb_src.sin6.sin6_family = AF_INET6;
	tdb.tdb_src.sin6.sin6_len = sizeof(struct sockaddr_in6);
	tdb.tdb_src.sin6.sin6_addr = sin6_src->sin6_addr;
	tdb.tdb_src.sin6.sin6_scope_id = sin6_src->sin6_scope_id;
	tdb.tdb_dst.sin6.sin6_family = AF_INET6;
	tdb.tdb_dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
	tdb.tdb_dst.sin6.sin6_addr = sin6_dst->sin6_addr;
	tdb.tdb_src.sin6.sin6_scope_id = sin6_dst->sin6_scope_id;
	tdb.tdb_xform = &xfs;
	xfs.xf_type = -1;	/* not XF_IP4 */

	switch (family) {
	case AF_INET:
		break;
#ifdef INET6
	case AF_INET6:
		break;
#endif
#ifdef MPLS
	case AF_MPLS:
		break;
#endif
	default:
#ifdef DEBUG
		printf("%s: warning: unknown family %d passed\n", __func__,
			family);
#endif
		m_freem(m);
		return EAFNOSUPPORT;
	}

	/* encapsulate into IPv6 packet */
	*m0 = NULL;
#if MPLS
	if (family == AF_MPLS)
		error = etherip_output(m, &tdb, m0, IPPROTO_MPLS);
	else
#endif
	error = ipip_output(m, &tdb, m0, 0, 0);
	if (error)
	        return error;
	else if (*m0 == NULL)
	        return EFAULT;

	m = *m0;

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif
	return 0;
}

int in6_gif_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct mbuf *m = *mp;
	struct gif_softc *sc;
	struct ifnet *gifp = NULL;
	struct ip6_hdr *ip6;
	struct sockaddr_in6 src, dst;
	struct sockaddr_in6 *psrc, *pdst;

	/* XXX What if we run transport-mode IPsec to protect gif tunnel ? */
	if (m->m_flags & (M_AUTH | M_CONF))
	        goto inject;

	ip6 = mtod(m, struct ip6_hdr *);
	in6_recoverscope(&src, &ip6->ip6_src);
	in6_recoverscope(&dst, &ip6->ip6_dst);

	LIST_FOREACH(sc, &gif_softc_list, gif_list) {
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
		    sc->gif_psrc->sa_family != AF_INET6 ||
		    sc->gif_pdst->sa_family != AF_INET6) {
			continue;
		}

		if ((sc->gif_if.if_flags & IFF_UP) == 0)
			continue;

		psrc = satosin6(sc->gif_psrc);
		pdst = satosin6(sc->gif_pdst);

		if (IN6_ARE_ADDR_EQUAL(&psrc->sin6_addr, &dst.sin6_addr) &&
		    psrc->sin6_scope_id == dst.sin6_scope_id &&
		    IN6_ARE_ADDR_EQUAL(&pdst->sin6_addr, &src.sin6_addr) &&
		    pdst->sin6_scope_id == src.sin6_scope_id) {
			gifp = &sc->gif_if;
			break;
		}
	}

	if (gifp) {
	        m->m_pkthdr.ph_ifidx = gifp->if_index;
		gifp->if_ipackets++;
		gifp->if_ibytes += m->m_pkthdr.len;
		return ipip_input_if(mp, offp, proto, af, gifp);
	}

inject:
	/* No GIF tunnel configured */
	return ipip_input(mp, offp, proto, af);
}
#endif /* INET6 */
@


1.98
log
@Do not use the interface pointer after if_put().  Rename ipip_input_gif()
to ipip_input_if() and always pass the ifp.  Only dump the packet
to bpf if we are called with a gif(4) interface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.97 2017/06/19 17:58:49 bluhm Exp $	*/
a108 1
	int s;
d132 1
a132 1
	NET_LOCK(s);
d134 1
a134 1
	NET_UNLOCK(s);
a142 1
	int s;
d144 1
a144 1
	NET_LOCK(s);
d146 1
a146 1
	NET_UNLOCK(s);
@


1.97
log
@When dealing with mbuf pointers passed down as function parameters,
bugs could easily result in use-after-free or double free.  Introduce
m_freemp() which automatically resets the pointer before freeing
it.  So we have less dangling pointers in the kernel.
OK krw@@ mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.96 2017/05/18 10:56:45 bluhm Exp $	*/
d754 1
a754 1
		return ipip_input_gif(mp, offp, proto, af, gifp);
d879 1
a879 1
		return ipip_input_gif(mp, offp, proto, af, gifp);
@


1.96
log
@The function name ip4_input() is confusing as it also handles IPv6
packets.  This is the IP in IP protocol input function, so call it
ipip_input().  Rename the existing ipip_input() to ipip_input_gif()
as it is the input function used by the gif interface.  Pass the
address family to make it consistent with pr_input.  Use __func__
in debug print and panic messages.  Move all ipip prototypes to the
ip_ipip.h header file.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.95 2017/05/17 09:00:08 mpi Exp $	*/
d280 1
a280 1
		m_freem(*mp);
@


1.95
log
@Protect the global list of interfaces with the NET_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.94 2017/05/04 15:00:24 bluhm Exp $	*/
d50 1
d754 1
a754 1
		return ipip_input(mp, offp, gifp, proto);
d759 1
a759 1
	return ip4_input(mp, offp, proto, af);
d879 1
a879 1
		return ipip_input(mp, offp, gifp, proto);
d884 1
a884 1
	return ip4_input(mp, offp, proto, af);
@


1.94
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.93 2017/04/14 20:50:35 bluhm Exp $	*/
d132 1
a132 1
	s = splnet();
d134 1
a134 1
	splx(s);
d145 1
a145 1
	s = splnet();
d147 1
a147 1
	splx(s);
a325 1
	int s;
a467 1
		s = splnet();
a469 1
		splx(s);
@


1.93
log
@Remove unused define satoin6().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.92 2017/04/14 20:46:31 bluhm Exp $	*/
d361 2
a362 4
			src = (struct sockaddr *)
				&(((struct if_laddrreq *)data)->addr);
			dst = (struct sockaddr *)
				&(((struct if_laddrreq *)data)->dstaddr);
d558 1
a558 2
		dst = (struct sockaddr *)
			&(((struct if_laddrreq *)data)->addr);
d566 1
a566 2
		dst = (struct sockaddr *)
			&(((struct if_laddrreq *)data)->dstaddr);
@


1.92
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.91 2017/01/29 19:58:47 bluhm Exp $	*/
a858 1
#define satoin6(sa)	(satosin6(sa)->sin6_addr)
@


1.91
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.90 2017/01/25 17:34:31 bluhm Exp $	*/
d719 1
a719 1
in_gif_input(struct mbuf **mp, int *offp, int proto)
d765 1
a765 1
	return ip4_input(mp, offp, proto);
d842 1
a842 1
int in6_gif_input(struct mbuf **mp, int *offp, int proto)
d891 1
a891 1
	return ip4_input(mp, offp, proto);
@


1.90
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.89 2017/01/23 11:37:29 mpi Exp $	*/
d718 2
a719 2
void
in_gif_input(struct mbuf *m, int off, int proto)
d721 1
d760 1
a760 2
		ipip_input(m, off, gifp, ip->ip_p);
		return;
d764 2
a765 2
	ip4_input(m, off, proto); /* No GIF interface was configured */
	return;
d886 1
a886 2
		ipip_input(m, *offp, gifp, proto);
		return IPPROTO_DONE;
d891 1
a891 2
	ip4_input6(&m, offp, proto);
	return IPPROTO_DONE;
@


1.89
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.88 2017/01/22 10:17:39 dlg Exp $	*/
d719 1
a719 1
in_gif_input(struct mbuf *m, ...)
a720 1
	int off;
a723 5
	va_list ap;

	va_start(ap, m);
	off = va_arg(ap, int);
	va_end(ap);
d764 1
a764 1
	ip4_input(m, off); /* No GIF interface was configured */
@


1.88
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.87 2016/12/13 06:51:11 dlg Exp $	*/
d118 1
@


1.87
log
@make v6 tunnel address handling consider ipv6 scope.

an earlier version of this diff was ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.86 2016/09/13 07:48:45 mpi Exp $	*/
a228 1
		ifp->if_opackets++;
@


1.86
log
@Retire bridge(4) support.

ok claudio@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.85 2016/04/13 11:41:15 mpi Exp $	*/
d799 1
d803 1
d854 2
d862 2
d876 7
a882 2
		if (IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_psrc), &ip6->ip6_dst) &&
		    IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_pdst), &ip6->ip6_src)) {
@


1.85
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.84 2016/01/14 09:20:31 mpi Exp $	*/
d65 1
a65 2
#include "bridge.h"
#if NBRIDGE > 0 || defined(MPLS)
a682 4
#if NBRIDGE > 0
	case AF_LINK:
		break;
#endif
a697 5
#if NBRIDGE > 0
	if (family == AF_LINK)
		error = etherip_output(m, &tdb, m0, IPPROTO_ETHERIP);
	else
#endif /* NBRIDGE */
a811 4
#if NBRIDGE > 0
	case AF_LINK:
		break;
#endif
a826 5
#if NBRIDGE > 0
	if (family == AF_LINK)
		error = etherip_output(m, &tdb, m0, IPPROTO_ETHERIP);
	else
#endif /* NBRIDGE */
@


1.84
log
@No need for a splnet() dance around IFQ_DEQUEUE() anymore.

From David Hill, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.83 2015/12/05 10:07:55 tedu Exp $	*/
a124 1
	IFQ_SET_READY(&sc->gif_if.if_snd);
@


1.83
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.82 2015/11/20 05:29:53 dlg Exp $	*/
a166 1
	int s;
d168 1
a168 2
	while (1) {
		s = splnet();
a169 2
		splx(s);

@


1.82
log
@dont check for OACTIVE

only a driver sets or clears this flag. gif never sets it, so it
wont be set when it checks it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.81 2015/10/25 11:58:11 mpi Exp $	*/
a97 1
/* ARGSUSED */
@


1.81
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.80 2015/09/28 08:32:05 mpi Exp $	*/
d179 1
a179 1
		if ((ifp->if_flags & (IFF_OACTIVE | IFF_UP)) != IFF_UP ||
@


1.80
log
@Merge gif(4)'s tentacles in a single file.

Tested by <mxb AT alumni DOT chalmers DOT se>.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.79 2015/09/11 08:17:06 claudio Exp $	*/
d123 1
a329 1
	struct ifaddr	 *ifa = (struct ifaddr *)data;
a337 1
		ifa->ifa_rtrequest = p2p_rtrequest;
@


1.79
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.78 2015/09/01 21:24:04 bluhm Exp $	*/
a43 1
#include <net/bpf.h>
a46 1
#include <netinet/in_gif.h>
d50 1
a55 1
#include <netinet6/in6_gif.h>
d61 4
d66 8
d88 3
d644 273
@


1.78
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.77 2015/07/17 18:05:59 mpi Exp $	*/
d238 1
a238 1
			ip6_output(m, 0, NULL, IPV6_MINMTU, 0, NULL, NULL);
@


1.77
log
@Explicitly do EtherIP encapsulation in bridge_ifenqueue().

The way gif(4) and bridge(4) are plugged together is disgusting but at
least this makes the layer violation obvious.

Fix a regression introduced by the M_PROTO1 loop prevention cleaning
because gif(4) was abusing this flag to figure out if the packet was
coming from a bridge(4).

Thanks to goda@@ for finding this!

ok goda@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.76 2015/07/16 21:21:49 mpi Exp $	*/
d342 4
a345 4
			src = (struct sockaddr *)
				&(((struct in_aliasreq *)data)->ifra_addr);
			dst = (struct sockaddr *)
				&(((struct in_aliasreq *)data)->ifra_dstaddr);
d349 4
a352 4
			src = (struct sockaddr *)
				&(((struct in6_aliasreq *)data)->ifra_addr);
			dst = (struct sockaddr *)
				&(((struct in6_aliasreq *)data)->ifra_dstaddr);
d435 1
a435 1
	(((struct sockaddr_in *)(x))->sin_addr.s_addr == INADDR_ANY)
d438 1
a438 1
	(IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)(x))->sin6_addr))
d504 2
a505 2
			dst = (struct sockaddr *)
				&(((struct in6_ifreq *)data)->ifr_addr);
d534 1
a534 2
			dst = (struct sockaddr *)
				&(((struct in6_ifreq *)data)->ifr_addr);
@


1.76
log
@Keep private definitions private.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.75 2015/06/30 13:54:42 mpi Exp $	*/
a171 33
		/*
		 * Check if the packet is coming via bridge and needs
		 * etherip encapsulation or not. bridge(4) directly calls
		 * the start function and bypasses the if_output function
		 * so we need to do the encap here.
		 */
		if (ifp->if_bridgeport && (m->m_flags & M_PROTO1)) {
			int error = 0;
			/*
			 * Remove multicast and broadcast flags or encapsulated
			 * packet ends up as multicast or broadcast packet.
			 */
			m->m_flags &= ~(M_BCAST|M_MCAST);
			switch (sc->gif_psrc->sa_family) {
			case AF_INET:
				error = in_gif_output(ifp, AF_LINK, &m);
				break;
#ifdef INET6
			case AF_INET6:
				error = in6_gif_output(ifp, AF_LINK, &m);
				break;
#endif
			default:
				error = EAFNOSUPPORT;
				m_freem(m);
				break;
			}
			if (error)
				continue;
			if (gif_checkloop(ifp, m))
				continue;
		}

d249 1
a249 2
gif_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
a252 9

	if (!(ifp->if_flags & IFF_UP) ||
	    sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
	    sc->gif_psrc->sa_family != sc->gif_pdst->sa_family) {
		m_freem(m);
		error = ENETDOWN;
		goto end;
	}

d257 1
a257 1
	m->m_flags &= ~(M_BCAST|M_MCAST);
d264 1
a264 1
		error = in_gif_output(ifp, dst->sa_family, &m);
d268 1
a268 1
		error = in6_gif_output(ifp, dst->sa_family, &m);
d272 1
a272 1
		m_freem(m);
d278 18
d297 1
d299 2
a300 1
	if ((error = gif_checkloop(ifp, m)))
@


1.75
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.74 2015/05/15 10:15:13 mpi Exp $	*/
d65 4
d73 4
@


1.74
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.73 2015/03/14 03:38:51 jsg Exp $	*/
d318 1
a318 1
	error = if_output(ifp, m);
@


1.73
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.72 2014/12/19 17:14:39 tedu Exp $	*/
a278 1
	int s;
d318 1
a318 13
	/*
	 * Queue message on interface, and start output.
	 */
	s = splnet();
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		/* mbuf is already freed */
		splx(s);
		goto end;
	}
	ifp->if_obytes += m->m_pkthdr.len;
	if_start(ifp);
	splx(s);
@


1.72
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.71 2014/12/05 15:50:04 mpi Exp $	*/
a34 1
#include <sys/kernel.h>
@


1.71
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.70 2014/11/23 07:39:02 deraadt Exp $	*/
a46 1
#ifdef	INET
a52 1
#endif	/* INET */
a54 3
#ifndef INET
#include <netinet/in.h>
#endif
a178 1
#ifdef INET
a181 1
#endif
a205 1
#ifdef INET
a209 1
#endif
a252 1
#ifdef INET
a255 1
#endif
a299 1
#ifdef INET
a302 1
#endif
a369 1
#ifdef INET
a375 1
#endif
a399 1
#ifdef INET
a403 1
#endif
a413 1
#ifdef INET
a417 1
#endif
a526 1
#ifdef INET
a530 1
#endif /* INET */
a556 1
#ifdef INET
a560 1
#endif /* INET */
@


1.70
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.69 2014/07/22 11:06:09 mpi Exp $	*/
d42 1
@


1.69
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.68 2014/07/12 18:44:22 tedu Exp $	*/
d142 1
a142 1
	free(sc, M_DEVBUF, 0);
@


1.68
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.67 2014/05/05 11:44:33 mpi Exp $	*/
a47 1
#include <netinet/in_systm.h>
@


1.67
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.66 2014/04/21 12:22:25 henning Exp $	*/
d138 1
a138 1
		free((caddr_t)sc->gif_psrc, M_IFADDR);
d141 1
a141 1
		free((caddr_t)sc->gif_pdst, M_IFADDR);
d143 1
a143 1
	free(sc, M_DEVBUF);
d503 1
a503 1
			free((caddr_t)sc->gif_psrc, M_IFADDR);
d509 1
a509 1
			free((caddr_t)sc->gif_pdst, M_IFADDR);
d525 1
a525 1
			free((caddr_t)sc->gif_psrc, M_IFADDR);
d529 1
a529 1
			free((caddr_t)sc->gif_pdst, M_IFADDR);
@


1.66
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.65 2014/04/21 11:10:54 henning Exp $	*/
d357 2
a358 1
	struct ifreq     *ifr = (struct ifreq*)data;
d367 1
@


1.65
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.63 2013/10/17 16:27:40 bluhm Exp $	*/
d264 1
a264 1
			ip_output(m, NULL, NULL, 0, NULL, NULL);
@


1.64
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d264 1
a264 2
			ip_output(m, (void *)NULL, (void *)NULL, 0,
			    (void *)NULL, (void *)NULL);
d275 1
a275 2
			ip6_output(m, 0, NULL, IPV6_MINMTU, 0, NULL,
			     NULL);
@


1.63
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.62 2013/06/17 18:19:44 bluhm Exp $	*/
a374 13
		switch (ifr->ifr_addr.sa_family) {
#ifdef INET
		case AF_INET:	/* IP supports Multicast */
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:	/* IP6 supports Multicast */
			break;
#endif /* INET6 */
		default:  /* Other protocols doesn't support Multicast */
			error = EAFNOSUPPORT;
			break;
		}
@


1.62
log
@Instead of bcopy() and bcmp() a single pointer in an mbuf tag,
assign with = and compare with == .  This way the compiler will
check deeper wether the cast is correct.  Alignment is fine,
tested on sparc64.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.61 2013/06/16 20:45:51 bluhm Exp $	*/
d60 1
@


1.61
log
@Remove variable sa_family_t family in gif_start() and gif_output().
No functional change.  From David Hill; OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.60 2013/03/26 13:19:25 mpi Exp $	*/
d679 1
a679 2
		if (!bcmp((caddr_t)(mtag + 1), &ifp,
		    sizeof(struct ifnet *))) {
d687 1
a687 1
	mtag = m_tag_get(PACKET_TAG_GIF, sizeof(caddr_t), M_NOWAIT);
d692 1
a692 1
	bcopy(&ifp, mtag + 1, sizeof(caddr_t));
@


1.60
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.59 2013/01/17 00:48:04 henning Exp $	*/
a151 1
	sa_family_t family;
a168 3
		/* get tunnel address family */
		family = sc->gif_psrc->sa_family;

a292 1
	sa_family_t family = dst->sa_family;
d314 1
a314 1
		error = in_gif_output(ifp, family, &m);
d319 1
a319 1
		error = in6_gif_output(ifp, family, &m);
@


1.59
log
@first or second coming, commie or not commie, one m in coming is sufficient
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.57 2012/05/12 12:58:16 mpf Exp $	*/
d108 1
a108 1
	IFQ_SET_MAXLEN(&sc->gif_if.if_snd, ifqmaxlen);
@


1.58
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d174 1
a174 1
		 * Check if the packet is comming via bridge and needs
@


1.57
log
@Fix tcpdump for etherip packets.
bpf_mtap() needs to be called without the etherip_header.
Idea to use a forward declaration for struct tdb by claudio.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.56 2012/04/14 09:39:46 yasuoka Exp $	*/
d179 1
a179 1
		if (ifp->if_bridge && (m->m_flags & M_PROTO1)) {
@


1.56
log
@Use DLT_LOOP for all tunneling interfaces.
Byte order adjustment for bpf was hidden behind bpf_mtap_af() and
sizeof(u_int32_t) is used for length of the bpf header.

tested by sebastia and mxb at alumni.chalmers.se.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.55 2010/07/03 04:44:51 guenther Exp $	*/
d52 1
d241 1
@


1.55
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.54 2010/05/11 09:36:07 claudio Exp $	*/
d114 1
a114 2
	bpfattach(&sc->gif_if.if_bpf, &sc->gif_if, DLT_NULL,
	    sizeof(u_int));
@


1.54
log
@Massiv cleanup of the gif(4) mess. Move encapsulation into gif_output()
where it is not necessary to guess protocols by looking at the first nibble.
in_gif_output() will encapsulate the packet but not send it. Because of
etherip support and the way the bridge works a minimal hack is needed in
gif_start() to ensure that the bridged packets are encapsulated as well.
This actually started with the idea to add MPLS support but that turned out
to be not as simple as in the gre(4) case.
Tested by myself (IP, IPv6, etherip, MPLS), sthen@@ (IP, IPv6), naddy (IPv6)
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.53 2009/11/22 12:33:25 deraadt Exp $	*/
d652 1
a652 1
	case SIOCSLIFPHYRTABLEID:
d661 1
a661 1
	case SIOCGLIFPHYRTABLEID:
@


1.53
log
@Add a lot of bpf and counter manipulation to the bridge.  The bridge
sneaks packets on and off network interfaces in some cases without
calling the interrupt, start, or output functions, and thus must do
these tasks which the drivers cannot do.  The gif and vether are
rather special.  Someone should re-check gre.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.52 2009/11/21 14:08:14 claudio Exp $	*/
d52 1
d60 1
d72 1
a150 2
	struct m_tag *mtag;
	int family;
d152 1
a152 15
	u_int8_t tp;

	/* is interface up and running? */
	if ((ifp->if_flags & (IFF_OACTIVE | IFF_UP)) != IFF_UP ||
	    sc->gif_psrc == NULL || sc->gif_pdst == NULL)
		return;

	/* are the tunnel endpoints valid? */
#ifdef INET
	if (sc->gif_psrc->sa_family != AF_INET)
#endif
#ifdef INET6
		if (sc->gif_psrc->sa_family != AF_INET6)
#endif
			return;
d162 11
d174 4
a177 2
		 * gif may cause infinite recursion calls when misconfigured.
		 * We'll prevent this by detecting loops.
d179 20
a198 7
		for (mtag = m_tag_find(m, PACKET_TAG_GIF, NULL); mtag;
		    mtag = m_tag_find(m, PACKET_TAG_GIF, mtag)) {
			if (!bcmp((caddr_t)(mtag + 1), &ifp,
			    sizeof(struct ifnet *))) {
				IF_DROP(&ifp->if_snd);
				log(LOG_NOTICE, "gif_output: "
				    "recursively called too many times\n");
d202 4
a206 2
		if (mtag)
			continue;
d208 5
a212 7
		mtag = m_tag_get(PACKET_TAG_GIF, sizeof(caddr_t), M_NOWAIT);
		if (mtag == NULL) {
			m_freem(m);
			break;
		}
		bcopy(&ifp, mtag + 1, sizeof(caddr_t));
		m_tag_prepend(m, mtag);
d214 2
a215 10
		/*
		 * Remove multicast and broadcast flags or encapsulated packet
		 * ends up as multicast or broadcast packet.
		 */
		m->m_flags &= ~(M_BCAST|M_MCAST);

		/* extract address family */
		family = AF_UNSPEC;
		tp = *mtod(m, u_int8_t *);
		tp = (tp >> 4) & 0xff;  /* Get the IP version number. */
d217 4
a220 2
		if (tp == IPVERSION)
			family = AF_INET;
d223 4
a226 2
		if (tp == (IPV6_VERSION >> 4))
			family = AF_INET6;
d228 29
a256 9

#if NBRIDGE > 0
		/*
		 * Check if the packet is comming via bridge and needs
		 * etherip encapsulation or not.
		 */
		if (ifp->if_bridge && (m->m_flags & M_PROTO1)) {
			m->m_flags &= ~M_PROTO1;
			family = AF_LINK;
d259 1
d261 1
a261 5
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_af(ifp->if_bpf, family, m, BPF_DIRECTION_OUT);
#endif
		ifp->if_opackets++;
d266 2
a267 1
			in_gif_output(ifp, family, m);
d272 8
a279 1
			in6_gif_output(ifp, family, m);
d296 1
d299 2
a300 1
	    sc->gif_psrc == NULL || sc->gif_pdst == NULL) {
d306 9
d318 1
d323 1
d328 8
a335 1
		error = ENETDOWN;
a336 1
	}
a337 1
	s = splnet();
d339 1
a339 2
	 * Queue message on interface, and start output if interface
	 * not yet active.
d341 1
d346 1
a346 1
		return (error);
a350 1
	return (error);
d670 30
@


1.52
log
@Add a way to bind the tunnel endpoint of a gif/gre interface into a
different rdomain than the default one. This allows to do MPLS VPNs
without the MPLS madness.  OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.51 2008/11/24 14:55:53 claudio Exp $	*/
a235 1
		ifp->if_obytes += m->m_pkthdr.len;
d296 1
@


1.51
log
@Remove the IFF_OACTIVE dance in gif_start this is not needed because start
functions will never ever be called in parallel. dlg@@ concured
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.50 2008/09/28 16:14:39 jsing Exp $	*/
d601 12
@


1.50
log
@Ansify function declarations for gif(4).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.47 2007/12/20 02:53:02 brad Exp $	*/
a166 4
	s = splnet();
	ifp->if_flags |= IFF_OACTIVE;
	splx(s);

a253 2

	ifp->if_flags &= ~IFF_OACTIVE;
@


1.49
log
@enable tx mitigation when putting packets on the wire by switching from
calls to ifp->if_start to if_start(). these are the obviously right cases
where we can do that, the less obvious ones may follow as theyre figured
out.

deraadt@@ said to go for it
@
text
@d80 1
a80 2
gifattach(count)
	int count;
d87 1
a87 3
gif_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
d122 1
a122 2
gif_clone_destroy(ifp)
	struct ifnet *ifp;
d144 1
a144 2
gif_start(ifp)
	struct ifnet *ifp;
d263 2
a264 5
gif_output(ifp, m, dst, rt)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr *dst;
	struct rtentry *rt;	/* added in net2 */
d314 1
a314 4
gif_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
@


1.48
log
@Typo, paket -> packet.
@
text
@d311 1
a311 2
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
@


1.47
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.46 2007/09/15 16:43:51 henning Exp $	*/
d211 1
a211 1
		 * remove multicast and broadcast flags or encapsulated paket
@


1.46
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.45 2007/05/26 17:13:30 jason Exp $	*/
d620 1
a620 1
		error = EINVAL;
@


1.45
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.44 2007/05/21 13:33:35 markus Exp $	*/
d95 1
a95 1
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
a97 1
	bzero(sc, sizeof(*sc));
d487 1
a487 1
		sa = (struct sockaddr *)malloc(src->sa_len, M_IFADDR, M_WAITOK);
d493 1
a493 1
		sa = (struct sockaddr *)malloc(dst->sa_len, M_IFADDR, M_WAITOK);
@


1.44
log
@make bridge(4) mark packets with M_PROTO1 if gif(4) needs to use
etherip encapsulation; unbreaks remote ipsec bridges; ok claudio;
additional testing Renaud Allard
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.43 2007/04/19 09:28:40 claudio Exp $	*/
a65 2

extern int ifqmaxlen;
@


1.43
log
@Cleanup spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.42 2007/04/18 08:18:22 claudio Exp $	*/
d220 1
d237 4
a240 10
		if (ifp->if_bridge)
			for (mtag = m_tag_find(m, PACKET_TAG_BRIDGE, NULL);
			    mtag;
			    mtag = m_tag_find(m, PACKET_TAG_BRIDGE, mtag)) {
				if (!bcmp(&ifp->if_bridge, mtag + 1,
				    sizeof(caddr_t))) {
					family = AF_LINK;
					break;
				}
			}
@


1.42
log
@Break out of the mtag check loop when a hit was found else we end up in a
double free. Found and tested by Stefan Schmieta. OK markus@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.41 2007/02/22 15:31:44 claudio Exp $	*/
d118 1
a118 1
		  sizeof(u_int));
d152 1
a152 1
        struct ifnet *ifp;
d155 1
a155 1
        struct mbuf *m;
d180 1
a180 1
	        s = splnet();
d303 1
a303 1
		m_freem(m);		
d324 1
a324 1
  end:
d343 1
a343 1
		
d347 1
a347 1
		
d526 1
a526 1
			
d558 1
a558 1
			
@


1.41
log
@Make gif(4) altq aware. This simplifies setting up traffic shaping on gif(4)
tunnels.
Additional testing by Marc Winiger. OK kjc@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.40 2007/02/10 15:34:22 claudio Exp $	*/
d199 1
a199 1
				continue;
d202 2
@


1.40
log
@Cleanup, kill dead code and unused arguments. Mostly stuff that is computed
and passed around but never used. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.39 2007/01/08 18:09:24 michele Exp $	*/
d48 1
d51 1
d58 1
d110 2
a111 1
	sc->gif_if.if_snd.ifq_maxlen = ifqmaxlen;
d154 1
a154 4
#if NBRIDGE > 0
        struct sockaddr dst;
#endif /* NBRIDGE */

d156 2
d159 1
d161 13
a173 2
#if NBRIDGE > 0
	bzero(&dst, sizeof(dst));
d175 3
a177 7
	/*
	 * XXX The assumption here is that only the ethernet bridge
	 * uses the start routine of this interface, and it's thus
	 * safe to do this.
	 */
	dst.sa_family = AF_LINK;
#endif /* NBRIDGE */
d179 1
a179 1
	while (ifp->if_snd.ifq_head) {
d181 1
a181 1
		IF_DEQUEUE(&ifp->if_snd, m);
d185 43
a227 1
			return;
d230 35
a264 2
		/* Sanity check -- interface should be member of a bridge */
		if (ifp->if_bridge == NULL)
d266 2
a267 5
		else
			gif_output(ifp, m, &dst, NULL);
#else
		m_freem(m);
#endif /* NBRIDGE */
d269 2
d282 1
a282 1
	struct m_tag *mtag;
a290 35
	/*
	 * gif may cause infinite recursion calls when misconfigured.
	 * We'll prevent this by detecting loops.
	 */
	for (mtag = m_tag_find(m, PACKET_TAG_GIF, NULL); mtag;
	     mtag = m_tag_find(m, PACKET_TAG_GIF, mtag)) {
		if (!bcmp((caddr_t)(mtag + 1), &ifp, sizeof(struct ifnet *))) {
			IF_DROP(&ifp->if_snd);
			log(LOG_NOTICE,
			    "gif_output: recursively called too many times\n");
			m_freem(m);
			error = EIO;	/* is there better errno? */
			goto end;
		}
	}

	mtag = m_tag_get(PACKET_TAG_GIF, sizeof(struct ifnet *), M_NOWAIT);
	if (mtag == NULL) {
		IF_DROP(&ifp->if_snd);
		m_freem(m);
		error = ENOMEM;
		goto end;
	}
	bcopy(&ifp, (caddr_t)(mtag + 1), sizeof(struct ifnet *));
	m_tag_prepend(m, mtag);

	m->m_flags &= ~(M_BCAST|M_MCAST);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m, BPF_DIRECTION_OUT);
#endif
	ifp->if_opackets++;	
	ifp->if_obytes += m->m_pkthdr.len;

a293 1
		error = in_gif_output(ifp, dst->sa_family, m);
a297 1
		error = in6_gif_output(ifp, dst->sa_family, m);
d303 13
a315 1
		break;
d317 4
@


1.39
log
@add round brackets around return values
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.38 2006/12/28 20:06:11 deraadt Exp $	*/
d244 1
a244 1
		error = in_gif_output(ifp, dst->sa_family, m, rt);
d249 1
a249 1
		error = in6_gif_output(ifp, dst->sa_family, m, rt);
@


1.38
log
@check if ifqueue has anything queued before doing the dance of
splnet/IF_DEQUEUE/splx; ok various people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.37 2006/11/16 07:58:43 itojun Exp $	*/
d261 1
a261 1
	return error;
d331 1
a331 1
			return EINVAL;
d336 1
a336 1
			return EINVAL;
d343 1
a343 1
				return EINVAL;
d349 1
a349 1
				return EINVAL;
d353 1
a353 1
			return EAFNOSUPPORT;
d359 1
a359 1
				return EINVAL;
d365 1
a365 1
				return EINVAL;
d369 1
a369 1
			return EAFNOSUPPORT;
d377 1
a377 1
			return EAFNOSUPPORT;
d382 1
a382 1
			return EAFNOSUPPORT;
d489 1
a489 1
			return EINVAL;
d521 1
a521 1
			return EINVAL;
d537 1
a537 1
			return EINVAL;
d546 1
a546 1
			return EINVAL;
d566 1
a566 1
	return error;
@


1.37
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.36 2006/03/25 22:41:47 djm Exp $	*/
d168 1
a168 1
	for (;;) {
d173 2
a174 1
		if (m == NULL) return;
@


1.36
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.35 2006/03/11 03:58:37 brad Exp $	*/
d177 4
a180 2
		if (ifp->if_bridge == NULL) m_freem(m);
		else gif_output(ifp, m, &dst, NULL);
@


1.35
log
@Check against GIF_MTU_MIN/GIF_MTU_MAX for the min/max MTU size.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.34 2006/03/04 22:40:15 brad Exp $	*/
d233 1
a233 1
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m);
@


1.34
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.33 2006/01/04 06:04:42 canacar Exp $	*/
d551 6
a556 3
        case SIOCSIFMTU:
                ifp->if_mtu = ((struct ifreq *)data)->ifr_mtu;
                break;
@


1.33
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.32 2005/07/31 03:52:18 pascoe Exp $	*/
d169 1
a169 1
	        s = splimp();
@


1.32
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.31 2003/12/16 20:33:25 markus Exp $	*/
a133 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.31
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.30 2003/12/10 07:22:42 itojun Exp $	*/
d235 2
a236 18
	if (ifp->if_bpf) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer a to it).
		 */
		struct mbuf m0;
		u_int32_t af = dst->sa_family;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *)&af;
		
		bpf_mtap(ifp->if_bpf, &m0);
	}
@


1.30
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.29 2003/12/03 14:51:05 markus Exp $	*/
d67 2
a68 2
int     gif_clone_create(struct if_clone *, int);
void    gif_clone_destroy(struct ifnet *);
d123 1
a123 1
void
d146 1
@


1.29
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.28 2003/05/03 21:15:11 deraadt Exp $	*/
d194 1
a194 1
	register struct gif_softc *sc = (struct gif_softc*)ifp;
@


1.28
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.27 2003/05/03 01:43:07 itojun Exp $	*/
d66 3
a68 2
int ngif;
void gifattach(int);
d73 3
a75 1
struct gif_softc *gif_softc = 0;
d77 1
d79 2
a80 2
gifattach(n)
	int n;
d82 37
a118 2
	register struct gif_softc *sc;
	register int i;
d120 13
a132 17
	ngif = n;
	gif_softc = sc = malloc (ngif * sizeof(struct gif_softc),
	    M_DEVBUF, M_WAIT);
	bzero(sc, ngif * sizeof(struct gif_softc));
	for (i = 0; i < ngif; sc++, i++) {
		snprintf(sc->gif_if.if_xname, sizeof sc->gif_if.if_xname,
		    "gif%d", i);
		sc->gif_if.if_mtu    = GIF_MTU;
		sc->gif_if.if_flags  = IFF_POINTOPOINT | IFF_MULTICAST;
		sc->gif_if.if_ioctl  = gif_ioctl;
		sc->gif_if.if_start = gif_start;
		sc->gif_if.if_output = gif_output;
		sc->gif_if.if_type   = IFT_GIF;
		sc->gif_if.if_snd.ifq_maxlen = ifqmaxlen;
		sc->gif_if.if_softc = sc;
		if_attach(&sc->gif_if);
		if_alloc_sadl(&sc->gif_if);
d135 1
a135 2
		bpfattach(&sc->gif_if.if_bpf, &sc->gif_if, DLT_NULL,
			  sizeof(u_int));
d137 9
a145 1
	}
a289 1
	int i;
d404 1
a404 2
		for (i = 0; i < ngif; i++) {
			sc2 = gif_softc + i;
@


1.27
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.26 2003/01/20 01:34:26 itojun Exp $	*/
d86 2
a87 1
		sprintf(sc->gif_if.if_xname, "gif%d", i);
@


1.26
log
@just for safety.  from http://templeofhate.com/tglaser/pub/obsd.diff
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.25 2002/06/30 13:04:36 itojun Exp $	*/
d202 1
@


1.25
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.24 2002/06/10 17:33:28 itojun Exp $	*/
d301 3
@


1.24
log
@easy error checks first.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.23 2002/06/09 06:05:04 itojun Exp $	*/
d96 1
@


1.23
log
@no need to log() on outgoing packet on !IFF_UP case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.22 2002/05/20 22:29:57 art Exp $	*/
d154 7
a187 6
	if (!(ifp->if_flags & IFF_UP) ||
	    sc->gif_psrc == NULL || sc->gif_pdst == NULL) {
		m_freem(m);
		error = ENETDOWN;
		goto end;
	}
d225 1
d229 2
a230 1
	if (error) ifp->if_oerrors++;
@


1.22
log
@Allow SIOCSIFMTU on gif interfaces.
From Mattias Amnefelt mattiasa at e.kth.se.
niels@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.21 2002/03/14 01:27:09 millert Exp $	*/
a182 3
		log(LOG_NOTICE,
		    "gif_output: attempt to use unconfigured interface %s\n",
		    ifp->if_xname);
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.20 2001/07/27 15:48:38 itojun Exp $	*/
d522 4
@


1.20
log
@variable name "gif" is way too generic - use "gif_softc".  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.19 2001/06/25 06:33:48 angelos Exp $	*/
d67 1
a67 1
void gifattach __P((int));
@


1.20.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.20 2001/07/27 15:48:38 itojun Exp $	*/
d67 1
a67 1
void gifattach(int);
d183 3
a521 4

        case SIOCSIFMTU:
                ifp->if_mtu = ((struct ifreq *)data)->ifr_mtu;
                break;
@


1.20.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.20.4.1 2002/06/11 03:30:45 art Exp $	*/
a95 1
		if_alloc_sadl(&sc->gif_if);
a153 7
	if (!(ifp->if_flags & IFF_UP) ||
	    sc->gif_psrc == NULL || sc->gif_pdst == NULL) {
		m_freem(m);
		error = ENETDOWN;
		goto end;
	}

d181 6
a223 1
		break;
d227 1
a227 2
	if (error)
		ifp->if_oerrors++;
@


1.20.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
a86 2
		snprintf(sc->gif_if.if_xname, sizeof sc->gif_if.if_xname,
		    "gif%d", i);
a201 1
		m0.m_flags = 0;
a300 3
			break;
		default:
			return EINVAL;
@


1.19
log
@Detect loops, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.18 2001/06/15 03:38:34 itojun Exp $	*/
d72 1
a72 1
struct gif_softc *gif = 0;
d82 2
a83 1
	gif = sc = malloc (ngif * sizeof(struct gif_softc), M_DEVBUF, M_WAIT);
d358 1
a358 1
			sc2 = gif + i;
@


1.18
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.17 2001/06/09 06:27:08 angelos Exp $	*/
d151 1
a151 2
	static int called = 0;	/* XXX: MUTEX */
	int calllimit = 3;	/* XXX: adhoc */
d155 1
a155 4
	 * We'll prevent this by introducing upper limit.
	 * XXX: this mechanism may introduce another problem about
	 *      mutual exclusion of the variable CALLED, especially if we
	 *      use kernel thread.
d157 15
a171 4
	if (++called >= calllimit) {
		log(LOG_NOTICE,
		    "gif_output: recursively called too many times(%d)\n",
		    called);
d173 1
a173 1
		error = EIO;	/* is there better errno? */
d176 2
a228 1
	called = 0;		/* reset recursion counter */
@


1.17
log
@Include cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.16 2001/06/09 06:23:06 angelos Exp $	*/
a168 2

	ifp->if_lastchange = time;	
@


1.16
log
@These don't need net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.15 2001/06/04 23:55:57 itojun Exp $	*/
a38 3
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/time.h>
a39 1
#include <machine/cpu.h>
a42 1
#include <net/netisr.h>
a47 1
#include <netinet/in_systm.h>
a48 1
#include <netinet/ip.h>
a55 3
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
@


1.15
log
@if_up() requires splnet().  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.14 2001/02/20 13:50:53 itojun Exp $	*/
a72 2

#include <net/net_osdep.h>
@


1.14
log
@provide SIOC[SG]LIFPHYADDR, which greatly simplify userland manipulation.
sync with kame.  old ioctls are kept but not really recommended.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.13 2001/02/20 10:33:28 itojun Exp $	*/
d251 1
d413 2
a414 1
		ifp->if_flags |= (IFF_UP | IFF_RUNNING);
d416 1
@


1.13
log
@use u_int32_t, not u_int, for DLT_NULL encapsulation.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: if_gif.c,v 1.12 2001/02/06 03:26:10 mickey Exp $	*/
/*	$KAME: if_gif.c,v 1.32 2000/10/07 03:20:55 itojun Exp $	*/
a32 5
/*
 * gif.c
 */


d248 4
a251 1
	struct sockaddr *sa, *dst, *src;
d281 1
a288 25
			if (src->sa_len != sizeof(struct sockaddr_in) ||
			    dst->sa_len != sizeof(struct sockaddr_in))
				return EINVAL;
			if (src->sa_family != AF_INET ||
			    dst->sa_family != AF_INET)
				return EAFNOSUPPORT;

			/* only one gif can have dst = INADDR_ANY */
#define satosaddr(sa) (((struct sockaddr_in *)(sa))->sin_addr.s_addr)

			if (satosaddr(dst) == INADDR_ANY) {
				int i;
				struct gif_softc *sc2;

			  	for (i = 0, sc2 = gif; i < ngif; i++, sc2++) {
					if (sc2 == sc) continue;
					if (sc2->gif_pdst &&
					    satosaddr(sc2->gif_pdst)
						== INADDR_ANY) {
					    error = EADDRNOTAVAIL;
					    goto bad;
					}
				}
			}
			size = sizeof(struct sockaddr_in);
d290 1
a290 1
#endif /* INET */
d297 40
a336 2
			if (src->sa_len != sizeof(struct sockaddr_in6) ||
			    dst->sa_len != sizeof(struct sockaddr_in6))
a337 23
			if (src->sa_family != AF_INET6 ||
			    dst->sa_family != AF_INET6)
				return EAFNOSUPPORT;

			/* only one gif can have dst = in6addr_any */
#define satoin6(sa) (&((struct sockaddr_in6 *)(sa))->sin6_addr)

			if (IN6_IS_ADDR_UNSPECIFIED(satoin6(dst))) {
				int i;
				struct gif_softc *sc2;

			  	for (i = 0, sc2 = gif; i < ngif; i++, sc2++) {
					if (sc2 == sc) continue;
					if (sc2->gif_pdst &&
					    IN6_IS_ADDR_UNSPECIFIED(
						satoin6(sc2->gif_pdst)
								    )) {
					    error = EADDRNOTAVAIL;
					    goto bad;
					}
				}
			}
			size = sizeof(struct sockaddr_in6);
d339 16
d356 2
a357 3
		default:
			error = EPROTOTYPE;
			goto bad;
d360 41
a400 1
		if (sc->gif_psrc != NULL)
d402 5
a406 1
		if (sc->gif_pdst != NULL)
d408 3
d412 1
a412 11
		sa = (struct sockaddr *)malloc(size, M_IFADDR, M_WAITOK);
		bzero((caddr_t)sa, size);
		bcopy((caddr_t)src, (caddr_t)sa, size);
		sc->gif_psrc = sa;
		
		sa = (struct sockaddr *)malloc(size, M_IFADDR, M_WAITOK);
		bzero((caddr_t)sa, size);
		bcopy((caddr_t)dst, (caddr_t)sa, size);
		sc->gif_pdst = sa;
		
		ifp->if_flags |= IFF_UP | IFF_RUNNING;
d417 14
d491 25
@


1.12
log
@allow configuring gif ifaces; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.11 2000/12/31 22:32:28 angelos Exp $	*/
d210 1
a210 1
		u_int af = dst->sa_family;
@


1.11
log
@ifdef -> if
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.10 2000/12/31 17:21:50 angelos Exp $	*/
a75 1
#include "gif.h"
d83 1
a83 2
#if NGIF > 0

a88 1
int ngif = NGIF;		/* number of interfaces */
d92 2
a93 2
gifattach(dummy)
	int dummy;
d98 1
a451 1
#endif /*NGIF > 0*/
@


1.10
log
@Fix non-INET6 case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.9 2000/12/30 21:52:50 angelos Exp $	*/
d126 1
a126 1
#ifdef NBRIDGE > 0
@


1.9
log
@Define gif_start(), which uses gif_output() with an AF_LINK sockaddr
(to be used by the bridge)

Also, mark the interface RUNNING as well as UP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.8 2000/10/07 04:05:37 itojun Exp $	*/
d126 1
d128 2
d156 1
a156 1
		m_freem(m)
@


1.8
log
@on SIOC*IFPHY*, validate args more correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.7 2000/01/17 06:29:27 itojun Exp $	*/
d78 1
d82 2
d108 1
d111 2
d122 36
d191 3
d370 1
a370 1
		ifp->if_flags |= IFF_UP;
@


1.7
log
@don't need IFF_RUNNING for gif, as no resource is allocated for
interface operation.
@
text
@d1 2
a2 1
/*	$OpenBSD: if_gif.c,v 1.6 2000/01/17 05:42:39 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d237 1
a237 1
		switch (ifr->ifr_addr.sa_family) {
d239 1
a239 1
		case AF_INET:
d244 6
d272 1
a272 1
		case AF_INET6:
d277 6
d328 1
d340 1
a340 1
		switch (sc->gif_psrc->sa_family) {
d342 1
a342 1
		case AF_INET:
d344 1
a344 1
			size = sizeof(struct sockaddr_in);
d348 1
a348 1
		case AF_INET6:
d351 1
a351 1
			size = sizeof(struct sockaddr_in6);
d358 3
a360 1
		bcopy((caddr_t)src, (caddr_t)dst, size);
d372 1
a372 1
		switch (sc->gif_pdst->sa_family) {
d374 1
a374 1
		case AF_INET:
d376 1
a376 1
			size = sizeof(struct sockaddr_in);
d380 1
a380 1
		case AF_INET6:
d383 1
a383 1
			size = sizeof(struct sockaddr_in6);
d390 3
a392 1
		bcopy((caddr_t)src, (caddr_t)dst, size);
d396 1
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: if_gif.c,v 1.14 2001/02/20 13:50:53 itojun Exp $	*/
/*	$KAME: if_gif.c,v 1.43 2001/02/20 08:51:07 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d32 5
d75 1
a76 1
#include "bridge.h"
d80 1
a80 1
extern int ifqmaxlen;
a81 1
int ngif;
d87 1
d91 2
a92 2
gifattach(n)
	int n;
a96 1
	ngif = n;
a103 1
		sc->gif_if.if_start = gif_start;
a105 2
		sc->gif_if.if_snd.ifq_maxlen = ifqmaxlen;
		sc->gif_if.if_softc = sc;
a114 39
void
gif_start(ifp)
        struct ifnet *ifp;
{
#if NBRIDGE > 0
        struct sockaddr dst;
#endif /* NBRIDGE */

        struct mbuf *m;
	int s;

#if NBRIDGE > 0
	bzero(&dst, sizeof(dst));

	/*
	 * XXX The assumption here is that only the ethernet bridge
	 * uses the start routine of this interface, and it's thus
	 * safe to do this.
	 */
	dst.sa_family = AF_LINK;
#endif /* NBRIDGE */

	for (;;) {
	        s = splimp();
		IF_DEQUEUE(&ifp->if_snd, m);
		splx(s);

		if (m == NULL) return;

#if NBRIDGE > 0
		/* Sanity check -- interface should be member of a bridge */
		if (ifp->if_bridge == NULL) m_freem(m);
		else gif_output(ifp, m, &dst, NULL);
#else
		m_freem(m);
#endif /* NBRIDGE */
	}
}

a147 3
		log(LOG_NOTICE,
		    "gif_output: attempt to use unconfigured interface %s\n",
		    ifp->if_xname);
d163 1
a163 1
		u_int32_t af = dst->sa_family;
d206 1
a206 4
	struct sockaddr *dst, *src;
	struct sockaddr *sa;
	int i;
	struct gif_softc *sc2;
d236 1
a236 2
	case SIOCSLIFPHYADDR:
		switch (cmd) {
d238 1
a238 1
		case SIOCSIFPHYADDR:
d243 19
d263 1
a263 1
#endif
d265 1
a265 1
		case SIOCSIFPHYADDR_IN6:
a269 8
			break;
#endif
		case SIOCSLIFPHYADDR:
			src = (struct sockaddr *)
				&(((struct if_laddrreq *)data)->addr);
			dst = (struct sockaddr *)
				&(((struct if_laddrreq *)data)->dstaddr);
		}
d271 2
a272 3
		/* sa_family must be equal */
		if (src->sa_family != dst->sa_family)
			return EINVAL;
d274 16
a289 6
		/* validate sa_len */
		switch (src->sa_family) {
#ifdef INET
		case AF_INET:
			if (src->sa_len != sizeof(struct sockaddr_in))
				return EINVAL;
d291 1
a291 7
#endif
#ifdef INET6
		case AF_INET6:
			if (src->sa_len != sizeof(struct sockaddr_in6))
				return EINVAL;
			break;
#endif
d293 2
a294 13
			return EAFNOSUPPORT;
		}
		switch (dst->sa_family) {
#ifdef INET
		case AF_INET:
			if (dst->sa_len != sizeof(struct sockaddr_in))
				return EINVAL;
			break;
#endif
#ifdef INET6
		case AF_INET6:
			if (dst->sa_len != sizeof(struct sockaddr_in6))
				return EINVAL;
a295 3
#endif
		default:
			return EAFNOSUPPORT;
d297 4
d302 3
a304 60
		/* check sa_family looks sane for the cmd */
		switch (cmd) {
		case SIOCSIFPHYADDR:
			if (src->sa_family == AF_INET)
				break;
			return EAFNOSUPPORT;
#ifdef INET6
		case SIOCSIFPHYADDR_IN6:
			if (src->sa_family == AF_INET6)
				break;
			return EAFNOSUPPORT;
#endif /* INET6 */
		case SIOCSLIFPHYADDR:
			/* checks done in the above */
			break;
		}

		for (i = 0; i < ngif; i++) {
			sc2 = gif + i;
			if (sc2 == sc)
				continue;
			if (!sc2->gif_pdst || !sc2->gif_psrc)
				continue;
			if (sc2->gif_pdst->sa_family != dst->sa_family ||
			    sc2->gif_pdst->sa_len != dst->sa_len ||
			    sc2->gif_psrc->sa_family != src->sa_family ||
			    sc2->gif_psrc->sa_len != src->sa_len)
				continue;
			/* can't configure same pair of address onto two gifs */
			if (bcmp(sc2->gif_pdst, dst, dst->sa_len) == 0 &&
			    bcmp(sc2->gif_psrc, src, src->sa_len) == 0) {
				error = EADDRNOTAVAIL;
				goto bad;
			}

			/* can't configure multiple multi-dest interfaces */
#define multidest(x) \
	(((struct sockaddr_in *)(x))->sin_addr.s_addr == INADDR_ANY)
#ifdef INET6
#define multidest6(x) \
	(IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)(x))->sin6_addr))
#endif
			if (dst->sa_family == AF_INET &&
			    multidest(dst) && multidest(sc2->gif_pdst)) {
				error = EADDRNOTAVAIL;
				goto bad;
			}
#ifdef INET6
			if (dst->sa_family == AF_INET6 &&
			    multidest6(dst) && multidest6(sc2->gif_pdst)) {
				error = EADDRNOTAVAIL;
				goto bad;
			}
#endif
		}

		if (sc->gif_psrc)
			free((caddr_t)sc->gif_psrc, M_IFADDR);
		sa = (struct sockaddr *)malloc(src->sa_len, M_IFADDR, M_WAITOK);
		bcopy((caddr_t)src, (caddr_t)sa, src->sa_len);
d306 4
a309 5

		if (sc->gif_pdst)
			free((caddr_t)sc->gif_pdst, M_IFADDR);
		sa = (struct sockaddr *)malloc(dst->sa_len, M_IFADDR, M_WAITOK);
		bcopy((caddr_t)dst, (caddr_t)sa, dst->sa_len);
d311 2
a312 2

		ifp->if_flags |= (IFF_UP | IFF_RUNNING);
a314 14
		error = 0;
		break;

#ifdef SIOCDIFPHYADDR
	case SIOCDIFPHYADDR:
		if (sc->gif_psrc) {
			free((caddr_t)sc->gif_psrc, M_IFADDR);
			sc->gif_psrc = NULL;
		}
		if (sc->gif_pdst) {
			free((caddr_t)sc->gif_pdst, M_IFADDR);
			sc->gif_pdst = NULL;
		}
		/* change the IFF_{UP, RUNNING} flag as well? */
a315 1
#endif
d326 1
a326 1
		switch (cmd) {
d328 1
a328 1
		case SIOCGIFPSRCADDR:
d330 1
a330 1
			size = sizeof(ifr->ifr_addr);
d334 1
a334 1
		case SIOCGIFPSRCADDR_IN6:
d337 1
a337 1
			size = sizeof(((struct in6_ifreq *)data)->ifr_addr);
d344 1
a344 3
		if (src->sa_len > size)
			return EINVAL;
		bcopy((caddr_t)src, (caddr_t)dst, src->sa_len);
d356 1
a356 1
		switch (cmd) {
d358 1
a358 1
		case SIOCGIFPDSTADDR:
d360 1
a360 1
			size = sizeof(ifr->ifr_addr);
d364 1
a364 1
		case SIOCGIFPDSTADDR_IN6:
d367 1
a367 1
			size = sizeof(((struct in6_ifreq *)data)->ifr_addr);
d374 1
a374 28
		if (src->sa_len > size)
			return EINVAL;
		bcopy((caddr_t)src, (caddr_t)dst, src->sa_len);
		break;

	case SIOCGLIFPHYADDR:
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL) {
			error = EADDRNOTAVAIL;
			goto bad;
		}

		/* copy src */
		src = sc->gif_psrc;
		dst = (struct sockaddr *)
			&(((struct if_laddrreq *)data)->addr);
		size = sizeof(((struct if_laddrreq *)data)->addr);
		if (src->sa_len > size)
			return EINVAL;
		bcopy((caddr_t)src, (caddr_t)dst, src->sa_len);

		/* copy dst */
		src = sc->gif_pdst;
		dst = (struct sockaddr *)
			&(((struct if_laddrreq *)data)->dstaddr);
		size = sizeof(((struct if_laddrreq *)data)->dstaddr);
		if (src->sa_len > size)
			return EINVAL;
		bcopy((caddr_t)src, (caddr_t)dst, src->sa_len);
a377 1
		/* if_ioctl() takes care of it */
d387 1
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.7.2.1 2001/05/14 22:40:00 niklas Exp $	*/
d39 3
d43 1
d47 1
d53 1
d55 1
d63 3
d74 2
d163 2
a164 1
	struct m_tag *mtag;
d168 4
a171 1
	 * We'll prevent this by detecting loops.
d173 4
a176 15
	for (mtag = m_tag_find(m, PACKET_TAG_GIF, NULL); mtag;
	     mtag = m_tag_find(m, PACKET_TAG_GIF, mtag)) {
		if (!bcmp((caddr_t)(mtag + 1), &ifp, sizeof(struct ifnet *))) {
			IF_DROP(&ifp->if_snd);
			log(LOG_NOTICE,
			    "gif_output: recursively called too many times\n");
			m_freem(m);
			error = EIO;	/* is there better errno? */
			goto end;
		}
	}

	mtag = m_tag_get(PACKET_TAG_GIF, sizeof(struct ifnet *), M_NOWAIT);
	if (mtag == NULL) {
		IF_DROP(&ifp->if_snd);
d178 1
a178 1
		error = ENOMEM;
d181 2
a182 2
	bcopy(&ifp, (caddr_t)(mtag + 1), sizeof(struct ifnet *));
	m_tag_prepend(m, mtag);
d234 1
a250 1
	int s;
d412 1
a412 2
		s = splnet();
		ifp->if_flags |= IFF_RUNNING;
a413 1
		splx(s);
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.7.2.2 2001/07/04 10:54:01 niklas Exp $	*/
d72 1
a72 1
struct gif_softc *gif_softc = 0;
d82 1
a82 2
	gif_softc = sc = malloc (ngif * sizeof(struct gif_softc),
	    M_DEVBUF, M_WAIT);
d357 1
a357 1
			sc2 = gif_softc + i;
@


1.7.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
void gifattach(int);
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@a95 1
		if_alloc_sadl(&sc->gif_if);
a153 7
	if (!(ifp->if_flags & IFF_UP) ||
	    sc->gif_psrc == NULL || sc->gif_pdst == NULL) {
		m_freem(m);
		error = ENETDOWN;
		goto end;
	}

d181 9
a226 1
		break;
d230 1
a230 2
	if (error)
		ifp->if_oerrors++;
a299 3
			break;
		default:
			return EINVAL;
a521 4

        case SIOCSIFMTU:
                ifp->if_mtu = ((struct ifreq *)data)->ifr_mtu;
                break;
@


1.7.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.7.2.5 2003/03/28 00:41:28 niklas Exp $	*/
d86 1
a86 2
		snprintf(sc->gif_if.if_xname, sizeof sc->gif_if.if_xname,
		    "gif%d", i);
a201 1
		m0.m_flags = 0;
@


1.7.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
a67 3
void	gifattach(int);
int	gif_clone_create(struct if_clone *, int);
int	gif_clone_destroy(struct ifnet *);
d72 1
a72 3
struct gif_softc_head gif_softc_list;
struct if_clone gif_cloner =
    IF_CLONE_INITIALIZER("gif", gif_clone_create, gif_clone_destroy);
a73 1
/* ARGSUSED */
d75 2
a76 2
gifattach(count)
	int count;
d78 2
a79 11
	LIST_INIT(&gif_softc_list);
	if_clone_attach(&gif_cloner);
}

int
gif_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
{
	struct gif_softc *sc;
	int s;
d81 17
a97 17
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
	if (!sc)
		return (ENOMEM);
	bzero(sc, sizeof(*sc));

	snprintf(sc->gif_if.if_xname, sizeof sc->gif_if.if_xname,
	     "%s%d", ifc->ifc_name, unit);
	sc->gif_if.if_mtu    = GIF_MTU;
	sc->gif_if.if_flags  = IFF_POINTOPOINT | IFF_MULTICAST;
	sc->gif_if.if_ioctl  = gif_ioctl;
	sc->gif_if.if_start  = gif_start;
	sc->gif_if.if_output = gif_output;
	sc->gif_if.if_type   = IFT_GIF;
	sc->gif_if.if_snd.ifq_maxlen = ifqmaxlen;
	sc->gif_if.if_softc = sc;
	if_attach(&sc->gif_if);
	if_alloc_sadl(&sc->gif_if);
d100 2
a101 2
	bpfattach(&sc->gif_if.if_bpf, &sc->gif_if, DLT_NULL,
		  sizeof(u_int));
d103 1
a103 31
	s = splnet();
	LIST_INSERT_HEAD(&gif_softc_list, sc, gif_list);
	splx(s);

	return (0);
}

int
gif_clone_destroy(ifp)
	struct ifnet *ifp;
{
	struct gif_softc *sc = ifp->if_softc;
	int s;

	s = splnet();
	LIST_REMOVE(sc, gif_list);
	splx(s);

#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
	if_detach(ifp);

	if (sc->gif_psrc)
		free((caddr_t)sc->gif_psrc, M_IFADDR);
	sc->gif_psrc = NULL;
	if (sc->gif_pdst)
		free((caddr_t)sc->gif_pdst, M_IFADDR);
	sc->gif_pdst = NULL;
	free(sc, M_DEVBUF);
	return (0);
d152 1
a152 1
	struct gif_softc *sc = (struct gif_softc*)ifp;
d248 1
d363 2
a364 1
		LIST_FOREACH(sc2, &gif_softc_list, gif_list) {
@


1.6
log
@remove IFF_RUNNING if it becomes !IFF_UP.
pointed out by: deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.5 2000/01/12 06:40:45 angelos Exp $	*/
d312 1
a312 1
		ifp->if_flags |= (IFF_UP|IFF_RUNNING);
a377 5
		/* sync "running" with "up" */
		if (ifp->if_flags & IFF_UP)
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
@


1.5
log
@Remove gif_input() -- not needed anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.4 2000/01/10 22:40:16 angelos Exp $	*/
d378 5
@


1.4
log
@Typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.3 2000/01/09 19:23:49 angelos Exp $	*/
a195 87

void
gif_input(m, af, gifp)
	struct mbuf *m;
	int af;
	struct ifnet *gifp;
{
	int s, isr;
	register struct ifqueue *ifq = 0;

	if (gifp == NULL) {
		/* just in case */
		m_freem(m);
		return;
	}

	if (m->m_pkthdr.rcvif)
		m->m_pkthdr.rcvif = gifp;
	
#if NBPFILTER > 0
	if (gifp->if_bpf) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer a to it).
		 */
		struct mbuf m0;
		u_int af = AF_INET6;
		
		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *) &af;
		
		bpf_mtap(gifp->if_bpf, &m0);
	}
#endif /*NBPFILTER > 0*/

	/*
	 * Put the packet to the network layer input queue according to the
	 * specified address family.
	 * Note: older versions of gif_input directly called network layer
	 * input functions, e.g. ip6_input, here. We changed the policy to
	 * prevent too many recursive calls of such input functions, which
	 * might cause kernel panic. But the change may introduce another
	 * problem; if the input queue is full, packets are discarded.
	 * We believed it rarely occurs and changed the policy. If we find
	 * it occurs more times than we thought, we may change the policy
	 * again.
	 */
	switch (af) {
#ifdef INET
	case AF_INET:
		ifq = &ipintrq;
		isr = NETISR_IP;
		break;
#endif
#ifdef INET6
	case AF_INET6:
		ifq = &ip6intrq;
		isr = NETISR_IPV6;
		break;
#endif
	default:
		m_freem(m);
		return;
	}

	s = splimp();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);	/* update statistics */
		m_freem(m);
		splx(s);
		return;
	}
	IF_ENQUEUE(ifq, m);

	/* We need schednetisr since the address family may change */
	schednetisr(isr);
	gifp->if_ipackets++;
	gifp->if_ibytes += m->m_pkthdr.len;
	splx(s);

	return;
}
	
@


1.3
log
@Reduce calllimit from 10 to 3; this should avoid running out of stack
when misconfiguring (jinmei@@isl.rdc.toshiba.co.jp)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.2 2000/01/07 19:28:48 angelos Exp $	*/
d107 1
d229 1
a229 1
		m0.m_data = (char *)&af;
d273 2
a274 1
	/* we need schednetisr since the address family may change */
@


1.2
log
@Cleanup ifdefs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gif.c,v 1.1 1999/12/08 06:50:18 itojun Exp $	*/
d124 1
a124 1
	int calllimit = 10;	/* XXX: adhoc */
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 3
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#endif
a39 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include <sys/malloc.h>
#endif
a43 3
#if defined(__FreeBSD__) || __FreeBSD__ >= 3
/*nothing*/
#else
a44 1
#endif
a81 3
#ifdef __FreeBSD__
void gifattach __P((void *));
#else
a82 1
#endif
a91 3
#ifdef __FreeBSD__
	void *dummy;
#else
a92 1
#endif
a99 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a100 4
#else
		sc->gif_if.if_name = "gif";
		sc->gif_if.if_unit = i;
#endif
d108 2
a109 5
#ifdef HAVE_OLD_BPF
		bpfattach(&sc->gif_if, DLT_NULL, sizeof(u_int));
#else
		bpfattach(&sc->gif_if.if_bpf, &sc->gif_if, DLT_NULL, sizeof(u_int));
#endif
a113 4
#ifdef __FreeBSD__
PSEUDO_SET(gifattach, if_gif);
#endif

a141 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	getmicrotime(&ifp->if_lastchange);
#else
d143 1
a143 1
#endif
a145 3
#if 0	    
	    sc->gif_flags & GIFF_INUSE ||
#endif
a167 3
#ifdef HAVE_OLD_BPF
		bpf_mtap(ifp, &m0);
#else
a168 1
#endif
a172 4
#if 0
	s = splnet();
	sc->gif_flags |= GIFF_INUSE;
#endif
a188 4
#if 0
	sc->gif_flags &= ~GIFF_INUSE;
	splx(s);
#endif
a229 3
#ifdef HAVE_OLD_BPF
		bpf_mtap(gifp, &m0);
#else
a230 1
#endif
a284 3
#if defined(__FreeBSD__) && __FreeBSD__ < 3
	int cmd;
#else
a285 1
#endif
a301 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a314 1
#endif /*not FreeBSD3*/
a315 22

#ifdef	SIOCSIFMTU /* xxx */
#ifndef __OpenBSD__
	case SIOCGIFMTU:
		break;
	case SIOCSIFMTU:
		{
#ifdef __bsdi__
			short mtu;
			mtu = *(short *)ifr->ifr_data;
#else
			u_long mtu;
			mtu = ifr->ifr_mtu;
#endif
			if (mtu < GIF_MTU_MIN || mtu > GIF_MTU_MAX) {
				return (EINVAL);
			}
			ifp->if_mtu = mtu;
		}
		break;
#endif
#endif /* SIOCSIFMTU */
@

