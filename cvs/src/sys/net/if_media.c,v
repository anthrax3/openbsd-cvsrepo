head	1.30;
access;
symbols
	OPENBSD_6_0:1.29.0.6
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.20.0.22
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.20
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.18
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.16
	OPENBSD_5_0:1.20.0.14
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.12
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.10
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.16.0.10
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.8
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.6
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.6
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.30
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.29;
commitid	6c6qq5OdS4VVnyVM;

1.29
date	2015.10.17.20.41.41;	author stsp;	state Exp;
branches;
next	1.28;
commitid	xe5JTxN9LuYw101k;

1.28
date	2015.09.29.10.11.40;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	L3Bwt4zBOCs33Zbo;

1.27
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.26;
commitid	6vhYvh5CxZAHMnsN;

1.26
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.25;
commitid	p4LJxGKbi0BU2cG6;

1.25
date	2015.01.21.23.06.10;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	y8qNyiVGFlQ6rmEA;

1.24
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.23;
commitid	zM5ckwX4kwwmipG0;

1.23
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.22;
commitid	B4dZSbxas1X1IpXI;

1.22
date	2014.01.19.13.47.03;	author pelikan;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.19.05.19.27;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.19.08.45.54;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.17.17.34.22;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.28.02.15.15;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.09.21.23.45;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.05.01.48.49;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.03.03.28.23;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.20.01.19.17;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.15.23.18.55;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2003.10.20.18.21.01;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.28.15.09.41;	author art;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2000.08.26.20.04.16;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.21.23.18.13;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.26.01.16.30;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.08.05.28.38;	author jason;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	98.09.03.06.24.20;	author jason;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.02.07.04.41;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.03.24.09.09.32;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.05.14.22.40.01;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	;

1.6.6.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	;

1.10.2.1
date	2005.02.20.01.58.52;	author brad;	state Exp;
branches;
next	;

1.10.4.1
date	2005.02.20.01.54.07;	author brad;	state Exp;
branches;
next	;


desc
@@


1.30
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: if_media.c,v 1.29 2015/10/17 20:41:41 stsp Exp $	*/
/*	$NetBSD: if_media.c,v 1.10 2000/03/13 23:52:39 soren Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997
 *	Jonathan Stone and Jason R. Thorpe.  All rights reserved.
 *
 * This software is derived from information provided by Matt Thomas.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jonathan Stone
 *	and Jason R. Thorpe for the NetBSD Project.
 * 4. The names of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * BSD/OS-compatible network interface media selection.
 *
 * Where it is safe to do so, this code strays slightly from the BSD/OS
 * design.  Software which uses the API (device drivers, basically)
 * shouldn't notice any difference.
 *
 * Many thanks to Matt Thomas for providing the information necessary
 * to implement this interface.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/malloc.h>

#include <net/if.h>
#ifdef IFMEDIA_DEBUG
#include <net/if_var.h>
#endif
#include <net/if_media.h>
#include <net/netisr.h>

/*
 * Compile-time options:
 * IFMEDIA_DEBUG:
 *	turn on implementation-level debug printfs.
 *	Useful for debugging newly-ported  drivers.
 */

#ifdef IFMEDIA_DEBUG
int	ifmedia_debug = 0;
static	void ifmedia_printword(uint64_t);
#endif

/*
 * Initialize if_media struct for a specific interface instance.
 */
void
ifmedia_init(struct ifmedia *ifm, uint64_t dontcare_mask,
    ifm_change_cb_t change_callback, ifm_stat_cb_t status_callback)
{
	TAILQ_INIT(&ifm->ifm_list);
	ifm->ifm_cur = NULL;
	ifm->ifm_media = 0;
	ifm->ifm_mask = dontcare_mask;		/* IF don't-care bits */
	ifm->ifm_change = change_callback;
	ifm->ifm_status = status_callback;
}

/*
 * Add a media configuration to the list of supported media
 * for a specific interface instance.
 */
void
ifmedia_add(struct ifmedia *ifm, uint64_t mword, int data, void *aux)
{
	struct ifmedia_entry *entry;

#ifdef IFMEDIA_DEBUG
	if (ifmedia_debug) {
		if (ifm == NULL) {
			printf("ifmedia_add: null ifm\n");
			return;
		}
		printf("Adding entry for ");
		ifmedia_printword(mword);
	}
#endif

	entry = malloc(sizeof(*entry), M_IFADDR, M_NOWAIT);
	if (entry == NULL)
		panic("ifmedia_add: can't malloc entry");

	entry->ifm_media = mword;
	entry->ifm_data = data;
	entry->ifm_aux = aux;

	TAILQ_INSERT_TAIL(&ifm->ifm_list, entry, ifm_list);
}

/*
 * Add an array of media configurations to the list of
 * supported media for a specific interface instance.
 */
void
ifmedia_list_add(struct ifmedia *ifm, struct ifmedia_entry *lp, int count)
{
	int i;

	for (i = 0; i < count; i++)
		ifmedia_add(ifm, lp[i].ifm_media, lp[i].ifm_data,
		    lp[i].ifm_aux);
}

/*
 * Set the default active media.
 *
 * Called by device-specific code which is assumed to have already
 * selected the default media in hardware.  We do _not_ call the
 * media-change callback.
 */
void
ifmedia_set(struct ifmedia *ifm, uint64_t target)
{
	struct ifmedia_entry *match;

	match = ifmedia_match(ifm, target, ifm->ifm_mask);

	/*
	 * If we didn't find the requested media, then we try to fall
	 * back to target-type (IFM_ETHER, e.g.) | IFM_NONE.  If that's
	 * not on the list, then we add it and set the media to it.
	 *
	 * Since ifmedia_set is almost always called with IFM_AUTO or
	 * with a known-good media, this really should only occur if we:
	 *
	 * a) didn't find any PHYs, or
	 * b) didn't find an autoselect option on the PHY when the
	 *    parent ethernet driver expected to.
	 *
	 * In either case, it makes sense to select no media.
	 */
	if (match == NULL) {
		printf("ifmedia_set: no match for 0x%llx/0x%llx\n",
		    target, ~ifm->ifm_mask);
		target = (target & IFM_NMASK) | IFM_NONE;
		match = ifmedia_match(ifm, target, ifm->ifm_mask);
		if (match == NULL) {
			ifmedia_add(ifm, target, 0, NULL);
			match = ifmedia_match(ifm, target, ifm->ifm_mask);
			if (match == NULL)
				panic("ifmedia_set failed");
		}
	}
	ifm->ifm_cur = match;

#ifdef IFMEDIA_DEBUG
	if (ifmedia_debug) {
		printf("ifmedia_set: target ");
		ifmedia_printword(target);
		printf("ifmedia_set: setting to ");
		ifmedia_printword(ifm->ifm_cur->ifm_media);
	}
#endif
}

/*
 * Device-independent media ioctl support function.
 */
int
ifmedia_ioctl(struct ifnet *ifp, struct ifreq *ifr, struct ifmedia *ifm,
    u_long cmd)
{
	struct ifmedia_entry *match;
	int error = 0;

	if (ifp == NULL || ifr == NULL || ifm == NULL)
		return (EINVAL);

	switch (cmd) {

	/*
	 * Set the current media.
	 */
	case SIOCSIFMEDIA:
	{
		struct ifmedia_entry *oldentry;
		uint64_t oldmedia;
		uint64_t newmedia = ifr->ifr_media;

		match = ifmedia_match(ifm, newmedia, ifm->ifm_mask);
		if (match == NULL) {
#ifdef IFMEDIA_DEBUG
			if (ifmedia_debug) {
				printf("ifmedia_ioctl: no media found for 0x%llx\n",
				    newmedia);
			}
#endif
			return (EINVAL);
		}

		/*
		 * If no change, we're done.
		 * XXX Automedia may involve software intervention.
		 *     Keep going in case the connected media changed.
		 *     Similarly, if best match changed (kernel debugger?).
		 */
		if ((IFM_SUBTYPE(newmedia) != IFM_AUTO) &&
		    (newmedia == ifm->ifm_media) &&
		    (match == ifm->ifm_cur))
			return (0);

		/*
		 * We found a match, now make the driver switch to it.
		 * Make sure to preserve our old media type in case the
		 * driver can't switch.
		 */
#ifdef IFMEDIA_DEBUG
		if (ifmedia_debug) {
			printf("ifmedia_ioctl: switching %s to ",
			    ifp->if_xname);
			ifmedia_printword(match->ifm_media);
		}
#endif
		oldentry = ifm->ifm_cur;
		oldmedia = ifm->ifm_media;
		ifm->ifm_cur = match;
		ifm->ifm_media = newmedia;
		error = (*ifm->ifm_change)(ifp);
		if (error) {
			ifm->ifm_cur = oldentry;
			ifm->ifm_media = oldmedia;
		}
		break;
	}

	/*
	 * Get list of available media and current media on interface.
	 */
	case  SIOCGIFMEDIA:
	{
		struct ifmediareq *ifmr = (struct ifmediareq *) ifr;
		struct ifmedia_entry *ep;
		size_t nwords;

		if (ifmr->ifm_count < 0)
			return (EINVAL);

		ifmr->ifm_active = ifmr->ifm_current = ifm->ifm_cur ?
		    ifm->ifm_cur->ifm_media : IFM_NONE;
		ifmr->ifm_mask = ifm->ifm_mask;
		ifmr->ifm_status = 0;
		(*ifm->ifm_status)(ifp, ifmr);

		/*
		 * Count them so we know a-priori how much is the max we'll
		 * need.
		 */
		ep = TAILQ_FIRST(&ifm->ifm_list);
		for (nwords = 0; ep != NULL; ep = TAILQ_NEXT(ep, ifm_list))
			nwords++;

		if (ifmr->ifm_count != 0) {
			size_t minwords, ksiz;
			uint64_t *kptr;

			minwords = nwords > (size_t)ifmr->ifm_count ?
			    (size_t)ifmr->ifm_count : nwords;
			kptr = mallocarray(nwords, sizeof(*kptr), M_TEMP,
			    M_WAITOK | M_ZERO);
			ksiz = nwords * sizeof(*kptr);
			/*
			 * Get the media words from the interface's list.
			 */
			ep = TAILQ_FIRST(&ifm->ifm_list);
			for (nwords = 0; ep != NULL && nwords < minwords;
			    ep = TAILQ_NEXT(ep, ifm_list))
				kptr[nwords++] = ep->ifm_media;
			if (ep == NULL)
				error = copyout(kptr, ifmr->ifm_ulist,
				    nwords * sizeof(*kptr));
			else
				error = E2BIG;
			free(kptr, M_TEMP, ksiz);
		}
		ifmr->ifm_count = nwords;
		break;
	}

	default:
		return (ENOTTY);
	}

	return (error);
}

/*
 * Find media entry matching a given ifm word.
 */
struct ifmedia_entry *
ifmedia_match(struct ifmedia *ifm, uint64_t target, uint64_t mask)
{
	struct ifmedia_entry *match, *next;

	match = NULL;
	mask = ~mask;

	TAILQ_FOREACH(next, &ifm->ifm_list, ifm_list) {
		if ((next->ifm_media & mask) == (target & mask)) {
			if (match) {
#if defined(IFMEDIA_DEBUG) || defined(DIAGNOSTIC)
				printf("ifmedia_match: multiple match for "
				    "0x%llx/0x%llx, selected instance %lld\n",
				    target, mask, IFM_INST(match->ifm_media));
#endif
				break;
			}
			match = next;
		}
	}

	return (match);
}

/*
 * Delete all media for a given instance.
 */
void
ifmedia_delete_instance(struct ifmedia *ifm, uint64_t inst)
{
	struct ifmedia_entry *ife, *nife;

	TAILQ_FOREACH_SAFE(ife, &ifm->ifm_list, ifm_list, nife) {
		if (inst == IFM_INST_ANY ||
		    inst == IFM_INST(ife->ifm_media)) {
			TAILQ_REMOVE(&ifm->ifm_list, ife, ifm_list);
			free(ife, M_IFADDR, sizeof *ife);
		}
	}
}

/*
 * Compute the interface `baudrate' from the media, for the interface
 * metrics (used by routing daemons).
 */
struct ifmedia_baudrate ifmedia_baudrate_descriptions[] =
    IFM_BAUDRATE_DESCRIPTIONS;

uint64_t
ifmedia_baudrate(uint64_t mword)
{
	int i;

	for (i = 0; ifmedia_baudrate_descriptions[i].ifmb_word != 0; i++) {
		if ((mword & (IFM_NMASK|IFM_TMASK)) ==
		    ifmedia_baudrate_descriptions[i].ifmb_word)
			return (ifmedia_baudrate_descriptions[i].ifmb_baudrate);
	}

	/* Not known. */
	return (0);
}

#ifdef IFMEDIA_DEBUG

struct ifmedia_description ifm_type_descriptions[] =
    IFM_TYPE_DESCRIPTIONS;

struct ifmedia_description ifm_subtype_descriptions[] =
    IFM_SUBTYPE_DESCRIPTIONS;

struct ifmedia_description ifm_option_descriptions[] =
    IFM_OPTION_DESCRIPTIONS;

/*
 * print a media word.
 */
static void
ifmedia_printword(uint64_t ifmw)
{
	struct ifmedia_description *desc;
	uint64_t seen_option = 0;

	/* Print the top-level interface type. */
	for (desc = ifm_type_descriptions; desc->ifmt_string != NULL;
	     desc++) {
		if (IFM_TYPE(ifmw) == desc->ifmt_word)
			break;
	}
	if (desc->ifmt_string == NULL)
		printf("<unknown type> ");
	else
		printf("%s ", desc->ifmt_string);

	/* Print the subtype. */
	for (desc = ifm_subtype_descriptions; desc->ifmt_string != NULL;
	     desc++) {
		if (IFM_TYPE_MATCH(desc->ifmt_word, ifmw) &&
		    IFM_SUBTYPE(desc->ifmt_word) == IFM_SUBTYPE(ifmw))
			break;
	}
	if (desc->ifmt_string == NULL)
		printf("<unknown subtype>");
	else
		printf("%s", desc->ifmt_string);

	/* Print any options. */
	for (desc = ifm_option_descriptions; desc->ifmt_string != NULL;
	     desc++) {
		if (IFM_TYPE_MATCH(desc->ifmt_word, ifmw) &&
		    (ifmw & desc->ifmt_word) != 0 &&
		    (seen_option & IFM_OPTIONS(desc->ifmt_word)) == 0) {
			if (seen_option == 0)
				printf(" <");
			printf("%s%s", seen_option ? "," : "",
			    desc->ifmt_string);
			seen_option |= IFM_OPTIONS(desc->ifmt_word);
		}
	}
	printf("%s\n", seen_option ? ">" : "");
}

#endif /* IFMEDIA_DEBUG */
@


1.29
log
@Fix build with IFMEDIA_DEBUG defined; ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.28 2015/09/29 10:11:40 deraadt Exp $	*/
d97 1
a97 1
 * 	Useful for debugging newly-ported  drivers.
d166 1
a166 1
 * Set the default active media. 
d290 1
a290 1
	case  SIOCGIFMEDIA: 
@


1.28
log
@add sizes to some of the simpler free calls
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.27 2015/09/11 13:02:28 stsp Exp $	*/
d87 3
d245 1
a245 1
				printf("ifmedia_ioctl: no media found for 0x%x\n",
@


1.27
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.26 2015/03/14 03:38:51 jsg Exp $	*/
d311 1
a311 1
			size_t minwords;
d318 1
d331 1
a331 1
			free(kptr, M_TEMP, 0);
d384 1
a384 1
			free(ife, M_IFADDR, 0);
@


1.26
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.25 2015/01/21 23:06:10 deraadt Exp $	*/
d99 1
a99 1
static	void ifmedia_printword(int);
d106 1
a106 1
ifmedia_init(struct ifmedia *ifm, int dontcare_mask,
d122 1
a122 1
ifmedia_add(struct ifmedia *ifm, int mword, int data, void *aux)
d170 1
a170 1
ifmedia_set(struct ifmedia *ifm, int target)
d191 1
a191 1
		printf("ifmedia_set: no match for 0x%x/0x%x\n",
a221 1
	struct ifmediareq *ifmr = (struct ifmediareq *) ifr;
d232 1
a232 1
	case  SIOCSIFMEDIA:
d235 2
a236 2
		u_int oldmedia;
		u_int newmedia = ifr->ifr_media;
d289 1
d312 1
a312 1
			int *kptr;
d316 1
a316 1
			kptr = mallocarray(nwords, sizeof(int), M_TEMP,
d327 1
a327 1
				    nwords * sizeof(int));
d347 1
a347 1
ifmedia_match(struct ifmedia *ifm, u_int target, u_int mask)
d359 1
a359 1
				    "0x%x/0x%x, selected instance %d\n",
d375 1
a375 1
ifmedia_delete_instance(struct ifmedia *ifm, u_int inst)
d395 2
a396 2
u_int64_t
ifmedia_baudrate(int mword)
d425 1
a425 1
ifmedia_printword(int ifmw)
d428 1
a428 1
	int seen_option = 0;
@


1.25
log
@if_media.c needs net/if_var.h. This fixes the build with IFMEDIA_DEBUG.
from Fabian Raetz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.24 2014/12/09 07:05:06 doug Exp $	*/
a86 1
#include <net/if_var.h>
@


1.24
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.23 2014/07/12 18:44:22 tedu Exp $	*/
d87 1
@


1.23
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.22 2014/01/19 13:47:03 pelikan Exp $	*/
d316 1
a316 1
			kptr = malloc(nwords * sizeof(int), M_TEMP,
@


1.22
log
@Prettify;  remove useless cast, reformat, fix TAILQ_FOREACH's.

No functional change.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.21 2014/01/19 05:19:27 deraadt Exp $	*/
d330 1
a330 1
			free(kptr, M_TEMP);
d383 1
a383 1
			free(ife, M_IFADDR);
@


1.21
log
@Count the number of media words required only once.  If the media words
change during M_WAITOK (note: no driver does this at the moment), then
be careful to not copyout a truncated media word list, but return E2BIG.
ok mikeb guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.20 2008/06/26 05:42:20 ray Exp $	*/
d311 7
a317 4
			size_t minwords = nwords > (size_t)ifmr->ifm_count 
			    ? (size_t)ifmr->ifm_count : nwords;
			int *kptr = (int *)malloc(nwords * sizeof(int),
			    M_TEMP, M_WAITOK | M_ZERO);
d354 1
a354 2
	for (next = TAILQ_FIRST(&ifm->ifm_list); next != NULL;
	     next = TAILQ_NEXT(next, ifm_list)) {
d379 1
a379 3
	for (ife = TAILQ_FIRST(&ifm->ifm_list); ife != NULL;
	     ife = nife) {
		nife = TAILQ_NEXT(ife, ifm_list);
@


1.20
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.19 2007/12/20 02:53:02 brad Exp $	*/
d293 1
a293 1
		if(ifmr->ifm_count < 0)
a310 1
			size_t count;
d313 2
a314 2
			int *kptr = (int *)malloc(minwords * sizeof(int),
 			    M_TEMP, M_WAITOK);
d319 8
a326 8
			for (count = 0; ep != NULL && count < minwords;
			    ep = TAILQ_NEXT(ep, ifm_list), count++)
				kptr[count] = ep->ifm_media;

			error = copyout(kptr, ifmr->ifm_ulist,
			    minwords * sizeof(int));
			if (error == 0 && ep != NULL)
				error = E2BIG;	/* oops! */
@


1.19
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.18 2007/09/19 08:45:54 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.18
log
@tidy up a little.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.17 2007/09/17 17:34:22 brad Exp $	*/
d342 1
a342 1
		return (EINVAL);
@


1.17
log
@- Use a 64-bit int for the baudrate within the ifmedia_baudrate struct and
return a 64-bit int for ifmedia_baudrate().
- Fix consumers of ifmedia_baudrate() to deal with the change.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.16 2005/07/28 02:15:15 brad Exp $	*/
d205 1
a205 1
			if (match == NULL) {
a206 1
			}
d250 1
a250 2
				printf(
				    "ifmedia_ioctl: no media found for 0x%x\n", 
d266 1
a266 1
			return 0;
d320 1
a320 2
			    ? (size_t)ifmr->ifm_count
			    : nwords;
d374 1
a374 1
	return match;
@


1.16
log
@rev 1.18

when there are multiple matches for the requested media, select the
first matching instance rather than the last one.

From chs NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.15 2005/07/09 21:23:45 brad Exp $	*/
d406 1
a406 1
int
@


1.15
log
@ANSI protos
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.14 2005/07/05 01:48:49 brad Exp $	*/
d365 1
a366 1
			if (match) {
d368 4
a371 1
				    "0x%x/0x%x\n", target, mask);
a372 1
#endif
@


1.14
log
@- prototype must not have variable name.

From itojun NetBSD

- Fix signed/unsigned comparison warnings.
- Make ifm_data unsigned.
- Make media and mask unsigned.

From thorpej NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.13 2005/07/03 03:28:23 brad Exp $	*/
d113 2
a114 5
ifmedia_init(ifm, dontcare_mask, change_callback, status_callback)
	struct ifmedia *ifm;
	int dontcare_mask;
	ifm_change_cb_t change_callback;
	ifm_stat_cb_t status_callback;
a115 1

d129 1
a129 5
ifmedia_add(ifm, mword, data, aux)
	struct ifmedia *ifm;
	int mword;
	int data;
	void *aux;
d160 1
a160 4
ifmedia_list_add(ifm, lp, count)
	struct ifmedia *ifm;
	struct ifmedia_entry *lp;
	int count;
d177 1
a177 3
ifmedia_set(ifm, target)
	struct ifmedia *ifm; 
	int target;
d226 2
a227 5
ifmedia_ioctl(ifp, ifr, ifm, cmd)
	struct ifnet *ifp;
	struct ifreq *ifr;
	struct ifmedia *ifm;
	u_long cmd;
d355 1
a355 4
ifmedia_match(ifm, target, mask)
	struct ifmedia *ifm; 
	u_int target;
	u_int mask;
d382 1
a382 3
ifmedia_delete_instance(ifm, inst)
	struct ifmedia *ifm;
	u_int inst;
d405 1
a405 2
ifmedia_baudrate(mword)
	int mword;
d434 1
a434 2
ifmedia_printword(ifmw)
	int ifmw;
@


1.13
log
@rev 1.13

when changing to an unsupported media type, return EINVAL instead of
ENXIO.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.12 2005/02/20 01:19:17 brad Exp $	*/
d260 2
a261 2
		int oldmedia;
		int newmedia = ifr->ifr_media;
d373 2
a374 2
	int target;
	int mask;
d403 1
a403 1
	int inst;
@


1.12
log
@ifmedia_set() should not panic, nor can it really fail.  So if there is
some problem setting the media to the requested value (usually IFM_AUTO),
we now force the media selection to IFM_NONE.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.11 2005/02/15 23:18:55 brad Exp $	*/
d272 1
a272 1
			return (ENXIO);
@


1.11
log
@rev 1.19

Avoid DoS attack by setting ifm->ifm_media to a high number and running the
kernel out of memory.

From NetBSD

Fixes panic mentioned in PR 4088.

ok krw@@ mcbride@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.10 2003/12/10 07:22:42 itojun Exp $	*/
a190 1

d196 14
d213 9
a221 1
		panic("ifmedia_set");
@


1.10
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.9 2003/10/20 18:21:01 jason Exp $	*/
d226 1
a226 1
	int error = 0, sticky;
d295 1
a295 1
		int *kptr, count;
d297 2
a298 1
		kptr = NULL;		/* XXX gcc */
d306 4
a309 1
		count = 0;
d311 2
d315 6
a320 3
			kptr = (int *)malloc(ifmr->ifm_count * sizeof(int),
			    M_TEMP, M_WAITOK);

d324 2
a325 1
			for (; ep != NULL && count < ifmr->ifm_count;
d329 3
a331 1
			if (ep != NULL)
d333 1
d335 1
a335 30

		/*
		 * If there are more interfaces on the list, count
		 * them.  This allows the caller to set ifmr->ifm_count
		 * to 0 on the first call to know how much space to
		 * callocate.
		 */
		for (; ep != NULL; ep = TAILQ_NEXT(ep, ifm_list))
			count++;

		/*
		 * We do the copyout on E2BIG, because that's
		 * just our way of telling userland that there
		 * are more.  This is the behavior I've observed
		 * under BSD/OS 3.0
		 */
		sticky = error;
		if ((error == 0 || error == E2BIG) && ifmr->ifm_count != 0) {
			error = copyout((caddr_t)kptr,
			    (caddr_t)ifmr->ifm_ulist,
			    ifmr->ifm_count * sizeof(int));
		}

		if (error == 0)
			error = sticky;

		if (ifmr->ifm_count != 0)
			free(kptr, M_TEMP);

		ifmr->ifm_count = count;
@


1.10.2.1
log
@MFC:
Fix by brad@@

rev 1.19

Avoid DoS attack by setting ifm->ifm_media to a high number and running the
kernel out of memory.

From NetBSD

Fixes panic mentioned in PR 4088.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.10 2003/12/10 07:22:42 itojun Exp $	*/
d226 1
a226 1
	int error = 0;
d295 1
a295 1
		size_t nwords;
d297 1
a297 2
		if(ifmr->ifm_count < 0)
			return (EINVAL);
d305 1
a305 4
		/*
		 * Count them so we know a-priori how much is the max we'll
		 * need.
		 */
a306 2
		for (nwords = 0; ep != NULL; ep = TAILQ_NEXT(ep, ifm_list))
			nwords++;
d309 3
a311 6
			size_t count;
			size_t minwords = nwords > (size_t)ifmr->ifm_count 
			    ? (size_t)ifmr->ifm_count
			    : nwords;
			int *kptr = (int *)malloc(minwords * sizeof(int),
 			    M_TEMP, M_WAITOK);
d315 1
a315 2
			ep = TAILQ_FIRST(&ifm->ifm_list);
			for (count = 0; ep != NULL && count < minwords;
d319 1
a319 3
			error = copyout(kptr, ifmr->ifm_ulist,
			    minwords * sizeof(int));
			if (error == 0 && ep != NULL)
d321 28
d350 2
a351 2
		}
		ifmr->ifm_count = nwords;
@


1.10.4.1
log
@MFC:
Fix by brad@@

rev 1.19

Avoid DoS attack by setting ifm->ifm_media to a high number and running the
kernel out of memory.

From NetBSD

Fixes panic mentioned in PR 4088.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.10 2003/12/10 07:22:42 itojun Exp $	*/
d226 1
a226 1
	int error = 0;
d295 1
a295 1
		size_t nwords;
d297 1
a297 2
		if(ifmr->ifm_count < 0)
			return (EINVAL);
d305 1
a305 4
		/*
		 * Count them so we know a-priori how much is the max we'll
		 * need.
		 */
a306 2
		for (nwords = 0; ep != NULL; ep = TAILQ_NEXT(ep, ifm_list))
			nwords++;
d309 3
a311 6
			size_t count;
			size_t minwords = nwords > (size_t)ifmr->ifm_count 
			    ? (size_t)ifmr->ifm_count
			    : nwords;
			int *kptr = (int *)malloc(minwords * sizeof(int),
 			    M_TEMP, M_WAITOK);
d315 1
a315 2
			ep = TAILQ_FIRST(&ifm->ifm_list);
			for (count = 0; ep != NULL && count < minwords;
d319 1
a319 3
			error = copyout(kptr, ifmr->ifm_ulist,
			    minwords * sizeof(int));
			if (error == 0 && ep != NULL)
d321 28
d350 2
a351 2
		}
		ifmr->ifm_count = nwords;
@


1.9
log
@tyop
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.8 2002/09/11 05:38:47 itojun Exp $	*/
d139 1
a139 1
	register struct ifmedia_entry *entry;
@


1.8
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.7 2002/03/14 01:27:09 millert Exp $	*/
d256 1
a256 1
		 * XXX Automedia may invole software intervention.
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.6 2000/11/28 15:09:41 art Exp $	*/
d229 1
a229 1
		return(EINVAL);
@


1.6
log
@Free the same type we malloced with.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.5 2000/08/26 20:04:16 nate Exp $	*/
d106 1
a106 1
static	void ifmedia_printword __P((int));
@


1.6.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.6 2000/11/28 15:09:41 art Exp $	*/
d106 1
a106 1
static	void ifmedia_printword(int);
@


1.6.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.6.6.1 2002/06/11 03:30:45 art Exp $	*/
d229 1
a229 1
		return (EINVAL);
@


1.5
log
@sync mii code with netbsd
adds detach functionality for phys
some code cleanup

Nobody really had time to test all of this out, but theo said commit anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.4 2000/03/21 23:18:13 mickey Exp $	*/
d408 1
a408 1
			free(ife, M_DEVBUF);
@


1.4
log
@small knits in .c, more media definitions from netbsd in .h
@
text
@d1 2
a2 2
/*	$OpenBSD: if_media.c,v 1.3 2000/02/26 01:16:30 mickey Exp $	*/
/*	$NetBSD: if_media.c,v 1.7 1999/11/03 23:06:35 thorpej Exp $	*/
d120 1
a120 1
	LIST_INIT(&ifm->ifm_list);
d160 1
a160 1
	LIST_INSERT_HEAD(&ifm->ifm_list, entry, ifm_list);
d306 1
a306 1
		ep = LIST_FIRST(&ifm->ifm_list);
d316 1
a316 1
			    ep = LIST_NEXT(ep, ifm_list), count++)
d329 1
a329 1
		for (; ep != NULL; ep = LIST_NEXT(ep, ifm_list))
d376 2
a377 2
	for (next = LIST_FIRST(&ifm->ifm_list); next != NULL;
	    next = LIST_NEXT(next, ifm_list)) {
d402 1
a402 1
	for (ife = LIST_FIRST(&ifm->ifm_list); ife != NULL;
d404 1
a404 2
		
		nife = LIST_NEXT(ife, ifm_list);
d407 1
a407 1
			LIST_REMOVE(ife, ifm_list);
d411 23
@


1.3
log
@use LIST_* macros where appropriate instead of using LIST* internals.
From netbsd
add 802.11 media types and options
add ifmedia_delete_instance() to be used in *detach() routines.
a few minor knits.
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.c,v 1.2 2000/01/08 05:28:38 jason Exp $	*/
d257 1
a257 1
		 *     Keep going in case the the connected media changed.
d329 1
a329 1
		for (; ep != NULL; ep = ep->ifm_list.le_next)
@


1.2
log
@expose ifmedia_match
@
text
@d1 2
a2 2
/*	$OpenBSD: if_media.c,v 1.1 1998/09/03 06:24:20 jason Exp $	*/
/*	$NetBSD: if_media.c,v 1.3 1998/08/30 07:39:39 enami Exp $	*/
d306 1
a306 1
		ep = ifm->ifm_list.lh_first;
d316 1
a316 1
			    ep = ep->ifm_list.le_next, count++)
a363 1
 *
d376 2
a377 2
	for (next = ifm->ifm_list.lh_first; next != NULL;
	    next = next->ifm_list.le_next) {
d390 22
@


1.2.2.1
log
@Sync with -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: if_media.c,v 1.7 1999/11/03 23:06:35 thorpej Exp $	*/
d306 1
a306 1
		ep = LIST_FIRST(&ifm->ifm_list);
d316 1
a316 1
			    ep = LIST_NEXT(ep, ifm_list), count++)
d364 1
d377 2
a378 2
	for (next = LIST_FIRST(&ifm->ifm_list); next != NULL;
	    next = LIST_NEXT(next, ifm_list)) {
a390 22
}

/*
 * Delete all media for a given instance.
 */
void
ifmedia_delete_instance(ifm, inst)
	struct ifmedia *ifm;
	int inst;
{
	struct ifmedia_entry *ife, *nife;

	for (ife = LIST_FIRST(&ifm->ifm_list); ife != NULL;
	     ife = nife) {
		
		nife = LIST_NEXT(ife, ifm_list);
		if (inst == IFM_INST_ANY ||
		    inst == IFM_INST(ife->ifm_media)) {
			LIST_REMOVE(ife, ifm_list);
			free(ife, M_DEVBUF);
		}
	}
@


1.2.2.2
log
@Sync with -current
@
text
@d257 1
a257 1
		 *     Keep going in case the connected media changed.
d329 1
a329 1
		for (; ep != NULL; ep = LIST_NEXT(ep, ifm_list))
@


1.2.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: if_media.c,v 1.6 2000/11/28 15:09:41 art Exp $	*/
/*	$NetBSD: if_media.c,v 1.10 2000/03/13 23:52:39 soren Exp $	*/
d120 1
a120 1
	TAILQ_INIT(&ifm->ifm_list);
d160 1
a160 1
	TAILQ_INSERT_TAIL(&ifm->ifm_list, entry, ifm_list);
d306 1
a306 1
		ep = TAILQ_FIRST(&ifm->ifm_list);
d316 1
a316 1
			    ep = TAILQ_NEXT(ep, ifm_list), count++)
d329 1
a329 1
		for (; ep != NULL; ep = TAILQ_NEXT(ep, ifm_list))
d376 2
a377 2
	for (next = TAILQ_FIRST(&ifm->ifm_list); next != NULL;
	     next = TAILQ_NEXT(next, ifm_list)) {
d402 1
a402 1
	for (ife = TAILQ_FIRST(&ifm->ifm_list); ife != NULL;
d404 2
a405 1
		nife = TAILQ_NEXT(ife, ifm_list);
d408 2
a409 2
			TAILQ_REMOVE(&ifm->ifm_list, ife, ifm_list);
			free(ife, M_IFADDR);
a411 23
}

/*
 * Compute the interface `baudrate' from the media, for the interface
 * metrics (used by routing daemons).
 */
struct ifmedia_baudrate ifmedia_baudrate_descriptions[] =
    IFM_BAUDRATE_DESCRIPTIONS;

int
ifmedia_baudrate(mword)
	int mword;
{
	int i;

	for (i = 0; ifmedia_baudrate_descriptions[i].ifmb_word != 0; i++) {
		if ((mword & (IFM_NMASK|IFM_TMASK)) ==
		    ifmedia_baudrate_descriptions[i].ifmb_word)
			return (ifmedia_baudrate_descriptions[i].ifmb_baudrate);
	}

	/* Not known. */
	return (0);
@


1.2.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 1
a106 1
static	void ifmedia_printword(int);
@


1.2.2.5
log
@Sync the SMP branch with 3.3
@
text
@d229 1
a229 1
		return (EINVAL);
@


1.2.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d139 1
a139 1
	struct ifmedia_entry *entry;
d256 1
a256 1
		 * XXX Automedia may involve software intervention.
@


1.1
log
@o OpenBSD gets if_media support (from NetBSD)
o rework/simplify if_xl to use it
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a102 3

struct ifmedia_entry *ifmedia_match __P((struct ifmedia *ifm,
    int flags, int mask));
@

