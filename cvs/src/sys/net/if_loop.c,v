head	1.80;
access;
symbols
	OPENBSD_6_1:1.80.0.4
	OPENBSD_6_1_BASE:1.80
	OPENBSD_6_0:1.76.0.4
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.75.0.2
	OPENBSD_5_9_BASE:1.75
	OPENBSD_5_8:1.70.0.4
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.57.0.4
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.47.0.4
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.47.0.2
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.4
	OPENBSD_5_0:1.46.0.2
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.44.0.12
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.10
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.6
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.8
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.4
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.40.0.4
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.33.0.4
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.32
	SMP_SYNC_B:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.25
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.12
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.80
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.79;
commitid	6c6qq5OdS4VVnyVM;

1.79
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.78;
commitid	F6oNrr9LCLUSAxgA;

1.78
date	2017.01.19.23.16.47;	author mpi;	state Exp;
branches;
next	1.77;
commitid	4qh8cQDJKV33pfUQ;

1.77
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.76;
commitid	to0Je2i4V2FtpmS1;

1.76
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.75;
commitid	Xo6g1xk26RWDGcjJ;

1.75
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.74;
commitid	ILbVM1M3uPNjwswz;

1.74
date	2015.11.27.15.00.12;	author mpi;	state Exp;
branches;
next	1.73;
commitid	BSd6UzglLbwb3sy0;

1.73
date	2015.11.11.10.23.23;	author mpi;	state Exp;
branches;
next	1.72;
commitid	HAbRB9Scbg3IhXig;

1.72
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.71;
commitid	G2nTzngqgXpQqcJB;

1.71
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.70;
commitid	LU3jSOpFfLxcllFL;

1.70
date	2015.07.29.00.04.03;	author rzalamena;	state Exp;
branches;
next	1.69;
commitid	9x7oePEcDKgC05vn;

1.69
date	2015.07.21.02.46.54;	author mpi;	state Exp;
branches;
next	1.68;
commitid	Zuf0grnslIJbpXnm;

1.68
date	2015.07.20.22.54.29;	author mpi;	state Exp;
branches;
next	1.67;
commitid	kUJLGGhKrehg9sRa;

1.67
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.66;
commitid	t2fhFUpUuj89g4Sj;

1.66
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.65;
commitid	h7z8lokZ0dFyuWpg;

1.65
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.64;
commitid	c7ei8kPelCOOwHXy;

1.64
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.63;
commitid	p4LJxGKbi0BU2cG6;

1.63
date	2015.01.27.10.20.31;	author mpi;	state Exp;
branches;
next	1.62;
commitid	vdmtuQlHoTNvVCgQ;

1.62
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.61;
commitid	zhW8jJrfVCoAthrR;

1.61
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.60;
commitid	t9FBKDfc4VDxpEy2;

1.60
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	mdGXHklUZmESVFlY;

1.59
date	2014.10.14.13.04.04;	author mpi;	state Exp;
branches;
next	1.58;
commitid	3WuaXJ7Brd2ZW3bQ;

1.58
date	2014.10.07.08.47.28;	author mpi;	state Exp;
branches;
next	1.57;
commitid	YwQD6dPTFjvxMtlw;

1.57
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.56;
commitid	DQakU8LLWV6Iwx84;

1.56
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.55;
commitid	B4dZSbxas1X1IpXI;

1.55
date	2014.05.14.19.08.33;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2014.04.19.11.01.37;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.10.19.14.46.30;	author mpi;	state Exp;
branches;
next	1.50;

1.50
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.10.13.15.48;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.14.09.39.47;	author yasuoka;	state Exp;
branches;
next	1.46;

1.46
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2011.07.04.19.24.05;	author sthen;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.07.12.58.54;	author norby;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.06.10.04.36;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.02.13.42.05;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.12.06.23.43;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.08.06.35.04;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.16.15.01.09;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.03.14.53.04;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.02.20.56.14;	author dugsong;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.18.23.07.49;	author deraadt;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.07.04.23.14.54;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.27.06.07.42;	author kjc;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.15.03.38.34;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.06.03.34.59;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.06.00.22.21;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.19.06.37.36;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.18.06.24.45;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.07.06.09.08;	author itojun;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	99.01.08.00.56.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.06.26.09.14.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.06.04.23.11.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.12.31.04.33.38;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.23.03.46.01;	author denny;	state Exp;
branches;
next	1.6;

1.6
date	96.06.29.18.54.11;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.10.12.31.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.28.14.37.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.04.24.06.26.46;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.07.42.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2001.05.14.22.40.01;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.07.04.10.54.03;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.13.2.9;

1.13.2.9
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.01.31.22.55.43;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.80
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: if_loop.c,v 1.79 2017/01/23 11:37:29 mpi Exp $	*/
/*	$NetBSD: if_loop.c,v 1.15 1996/05/07 02:40:33 thorpej Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_loop.c	8.1 (Berkeley) 6/10/93
 */

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

/*
 * Loopback interface driver for protocol testing and timing.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/time.h>


#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/rtable.h>
#include <net/route.h>

#include <netinet/in.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif

#ifdef MPLS
#include <netmpls/mpls.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#define	LOMTU	32768

int	loioctl(struct ifnet *, u_long, caddr_t);
void	loopattach(int);
void	lortrequest(struct ifnet *, int, struct rtentry *);
int	looutput(struct ifnet *,
	    struct mbuf *, struct sockaddr *, struct rtentry *);

int	loop_clone_create(struct if_clone *, int);
int	loop_clone_destroy(struct ifnet *);

struct if_clone loop_cloner =
    IF_CLONE_INITIALIZER("lo", loop_clone_create, loop_clone_destroy);

void
loopattach(int n)
{
	if (loop_clone_create(&loop_cloner, 0))
		panic("unable to create lo0");

	if_clone_attach(&loop_cloner);
}

int
loop_clone_create(struct if_clone *ifc, int unit)
{
	struct ifnet *ifp;

	ifp = malloc(sizeof(*ifp), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (ifp == NULL)
		return (ENOMEM);

	snprintf(ifp->if_xname, sizeof ifp->if_xname, "lo%d", unit);
	ifp->if_softc = NULL;
	ifp->if_mtu = LOMTU;
	ifp->if_flags = IFF_LOOPBACK | IFF_MULTICAST;
	ifp->if_xflags = IFXF_CLONED;
	ifp->if_rtrequest = lortrequest;
	ifp->if_ioctl = loioctl;
	ifp->if_output = looutput;
	ifp->if_type = IFT_LOOP;
	ifp->if_hdrlen = sizeof(u_int32_t);
	ifp->if_addrlen = 0;
	if (unit == 0) {
		if_attachhead(ifp);
		if_addgroup(ifp, ifc->ifc_name);
		rtable_l2set(0, 0, ifp->if_index);
	} else
		if_attach(ifp);
	if_alloc_sadl(ifp);
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
#endif
	return (0);
}

int
loop_clone_destroy(struct ifnet *ifp)
{
	if (ifp->if_index == rtable_loindex(ifp->if_rdomain))
		return (EPERM);

	if_detach(ifp);

	free(ifp, M_DEVBUF, sizeof(*ifp));
	return (0);
}

int
looutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("looutput: no header mbuf");

	if (rt && rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE)) {
		m_freem(m);
		return (rt->rt_flags & RTF_BLACKHOLE ? 0 :
			rt->rt_flags & RTF_HOST ? EHOSTUNREACH : ENETUNREACH);
	}

	return (if_input_local(ifp, m, dst->sa_family));
}

void
lortrequest(struct ifnet *ifp, int cmd, struct rtentry *rt)
{
	if (rt && rt->rt_rmx.rmx_mtu == 0)
		rt->rt_rmx.rmx_mtu = LOMTU;
}

/*
 * Process an ioctl request.
 */
int
loioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ifreq *ifr;
	int error = 0;

	switch (cmd) {
	case SIOCSIFFLAGS:
		break;

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_RUNNING;
		if_up(ifp);		/* send up RTM_IFINFO */
		/*
		 * Everything else is done at a higher level.
		 */
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCSIFMTU:
		ifr = (struct ifreq *)data;
		ifp->if_mtu = ifr->ifr_mtu;
		break;

	default:
		error = ENOTTY;
	}
	return (error);
}
@


1.79
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.78 2017/01/19 23:16:47 mpi Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d66 1
a66 1
 * 
d70 1
a70 1
 * 
d78 4
a81 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d85 1
a85 1
 * 
d97 1
a97 1
 * 
@


1.78
log
@Do not return an error code for SIOCSIFFLAGS.

This synchronize lo(4) with other pseudo-driver and fix a regression
introduced by the refactoring of the UP/DOWN logic in if.c

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.77 2016/11/14 10:32:46 mpi Exp $	*/
d177 1
@


1.77
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.76 2016/04/13 11:41:15 mpi Exp $	*/
d241 2
@


1.76
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.75 2015/12/05 10:07:55 tedu Exp $	*/
d124 1
d186 1
a186 1
		lo0ifidx = ifp->if_index;
d199 1
a199 1
	if (ifp->if_index == lo0ifidx)
@


1.75
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.74 2015/11/27 15:00:12 mpi Exp $	*/
a181 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.74
log
@Keep lo(4) definitions inside if_loop.c
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.73 2015/11/11 10:23:23 mpi Exp $	*/
a153 1
/* ARGSUSED */
a223 1
/* ARGSUSED */
a233 1
/* ARGSUSED */
@


1.73
log
@Store the index of the lo0 interface instead of a pointer to its
descriptor.

Allow to get rid of two if_ref() in the output paths.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.72 2015/10/25 11:58:11 mpi Exp $	*/
d141 6
@


1.72
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.71 2015/09/12 13:34:12 mpi Exp $	*/
a178 1
		lo0ifp = ifp;
d180 2
a181 1
		if_addgroup(lo0ifp, ifc->ifc_name);
d194 1
a194 1
	if (ifp == lo0ifp)
@


1.71
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.70 2015/07/29 00:04:03 rzalamena Exp $	*/
d171 1
d221 1
a221 1
lortrequest(int cmd, struct rtentry *rt)
a233 1
	struct ifaddr *ifa;
a241 4

		ifa = (struct ifaddr *)data;
		if (ifa != 0)
			ifa->ifa_rtrequest = lortrequest;
@


1.70
log
@Don't use mpls_input() as input handler anymore and instead call it
directly. Also protect non mp-safe functions while at it.

ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.69 2015/07/21 02:46:54 mpi Exp $	*/
a205 2
	struct niqueue *ifq = NULL;

a207 10
#if NBPFILTER > 0
	/*
	 * only send packets to bpf if they are real loopback packets;
	 * looutput() is also called for SIMPLEX interfaces to duplicate
	 * packets for local use. But don't dup them to bpf.
	 */
	if (ifp->if_bpf && (ifp->if_flags & IFF_LOOPBACK))
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m, BPF_DIRECTION_OUT);
#endif
	m->m_pkthdr.ph_ifidx = ifp->if_index;
d215 1
a215 33
	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;
	switch (dst->sa_family) {

	case AF_INET:
		ifq = &ipintrq;
		break;
#ifdef INET6
	case AF_INET6:
		ifq = &ip6intrq;
		break;
#endif /* INET6 */
#ifdef MPLS
	case AF_MPLS:
		ifp->if_ipackets++;
		ifp->if_ibytes += m->m_pkthdr.len;
		mpls_input(ifp, m);
		return (0);
#endif /* MPLS */
	default:
		printf("%s: can't handle af%d\n", ifp->if_xname,
			dst->sa_family);
		m_freem(m);
		return (EAFNOSUPPORT);
	}

	if (niq_enqueue(ifq, m) != 0)
		return (ENOBUFS);

	ifp->if_ipackets++;
	ifp->if_ibytes += m->m_pkthdr.len;

	return (0);
@


1.69
log
@Put the mbuf_list inside "#ifdef MPLS".

reported by rpe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.68 2015/07/20 22:54:29 mpi Exp $	*/
a206 3
#ifdef MPLS
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
#endif /* MPLS */
d241 3
a243 7
		if ((ifp->if_xflags & IFXF_MPLS) == 0) {
			m_freem(m);
			return (EINVAL);
		}

		ml_enqueue(&ml, m);
		if_input(ifp, &ml);
@


1.68
log
@Remove splassert(IPL_NET) from if_input().

if_input() has been designed to be able to safely handle a batch of
packets from physical drivers to the network stack.  Most of these
drivers have an interrupt routine executed at IPL_NET and the check
made sense during the conversion.  However we also want to re-enqueue
packets with if_input() from the network stack currently running at
IPL_SOFTNET.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.67 2015/07/20 21:16:39 rzalamena Exp $	*/
d207 1
d209 1
@


1.67
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.66 2015/06/16 11:09:39 mpi Exp $	*/
a207 1
	int s;
a247 2

		s = splnet();
a248 1
		splx(s);
@


1.66
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.65 2015/04/10 13:58:20 dlg Exp $	*/
d207 2
d243 11
a253 2
		ifq = &mplsintrq;
		break;
@


1.65
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.64 2015/03/14 03:38:51 jsg Exp $	*/
d219 1
a219 1
	m->m_pkthdr.rcvif = ifp;
@


1.64
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.63 2015/01/27 10:20:31 mpi Exp $	*/
d206 1
a206 2
	int s, isr;
	struct ifqueue *ifq = 0;
a232 1
		isr = NETISR_IP;
a236 1
		isr = NETISR_IPV6;
a241 1
		isr = NETISR_MPLS;
d250 2
a251 5
	s = splnet();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
		splx(s);
d253 1
a253 3
	}
	IF_ENQUEUE(ifq, m);
	schednetisr(isr);
d256 1
a256 1
	splx(s);
@


1.63
log
@Do not overwrite user-specified MTU.

Allow to use different size than the default of 32K.

ok henning@@, stsp@@, florian@@, benno@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.62 2014/12/19 17:14:39 tedu Exp $	*/
a126 1
#include <netinet/ip.h>
@


1.62
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.61 2014/12/05 15:50:04 mpi Exp $	*/
d274 1
a274 1
	if (rt)
@


1.61
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.60 2014/11/23 07:39:02 deraadt Exp $	*/
a125 1
#ifdef	INET
a127 1
#endif
a129 3
#ifndef INET
#include <netinet/in.h>
#endif
a232 1
#ifdef INET
a236 1
#endif
@


1.60
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.59 2014/10/14 13:04:04 mpi Exp $	*/
d121 1
@


1.59
log
@Document that lo0 must be present on your system by panic(9)ing if we
cannot create it.

Suggested by and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.58 2014/10/07 08:47:28 mpi Exp $	*/
d203 1
a203 1
	free(ifp, M_DEVBUF, 0);
@


1.58
log
@Do not protect the SIOCSIFADDR call by splnet().  Drivers already
raise it inside their ioctl handler (except for carp(4), what else?).

In general, global structures manipulated in the softnet codepath only
require a splsoftnet() protection when they are modified in process
(ioctl) context.

Also put some IPL_SOFNET asserts in functions accessing global structures.

Previous version diff ok mikeb@@, with inputs from and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.57 2014/07/22 11:06:09 mpi Exp $	*/
d157 3
a159 1
	(void) loop_clone_create(&loop_cloner, 0);
@


1.57
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.56 2014/07/12 18:44:22 tedu Exp $	*/
d291 1
a291 1
	int s, error = 0;
a295 1
		s = splnet();
a297 1
		splx(s);
@


1.56
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.55 2014/05/14 19:08:33 claudio Exp $	*/
a126 1
#include <netinet/in_systm.h>
@


1.55
log
@There is no reason why one needs to have a lo(4) MTU that is arch specific.
Also making the size 32k + some extra is not very helpful since we don't
do something like zerocopy or sendfile. Just go back to 32768 and we can
bikeshed over the right value later on once we have features that benefit
from it. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.54 2014/04/19 11:01:37 henning Exp $	*/
d202 1
a202 1
	free(ifp, M_DEVBUF);
@


1.54
log
@       /*
        * altq for loop is just for debugging.
        * only used when called for loop interface (not for
        * a simplex interface).
        */
bye bye!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.52 2013/10/23 15:12:42 mpi Exp $	*/
d146 1
a146 5
#if defined(LARGE_LOMTU)
#define LOMTU	(131072 +  MHLEN + MLEN)
#else
#define	LOMTU	(32768 +  MHLEN + MLEN)
#endif
@


1.53
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@a150 4
  
#ifdef ALTQ
static void lo_altqstart(struct ifnet *);
#endif
a184 3
#ifdef ALTQ
	ifp->if_start = lo_altqstart;
#endif
a237 24
#ifdef ALTQ
	/*
	 * altq for loop is just for debugging.
	 * only used when called for loop interface (not for
	 * a simplex interface).
	 */
	if ((ALTQ_IS_ENABLED(&ifp->if_snd) || TBR_IS_ENABLED(&ifp->if_snd))
	    && ifp->if_start == lo_altqstart) {
		int32_t *afp;
	        int error;

		M_PREPEND(m, sizeof(int32_t), M_DONTWAIT);
		if (m == 0)
			return (ENOBUFS);
		afp = mtod(m, int32_t *);
		*afp = (int32_t)dst->sa_family;

	        s = splnet();
		IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
		(*ifp->if_start)(ifp);
		splx(s);
		return (error);
	}
#endif /* ALTQ */
a277 62

#ifdef ALTQ
static void
lo_altqstart(struct ifnet *ifp)
{
	struct ifqueue *ifq;
	struct mbuf *m;
	int32_t af, *afp;
	int s, isr;
	
	while (1) {
		s = splnet();
		IFQ_DEQUEUE(&ifp->if_snd, m);
		splx(s);
		if (m == NULL)
			return;

		afp = mtod(m, int32_t *);
		af = *afp;
		m_adj(m, sizeof(int32_t));

		switch (af) {
#ifdef INET
		case AF_INET:
			ifq = &ipintrq;
			isr = NETISR_IP;
			break;
#endif
#ifdef INET6
		case AF_INET6:
			m->m_flags |= M_LOOP;
			ifq = &ip6intrq;
			isr = NETISR_IPV6;
			break;
#endif
#ifdef MPLS
		case AF_MPLS:
			ifq = &mplsintrq;
			isr = NETISR_MPLS;
			break;
#endif
		default:
			printf("lo_altqstart: can't handle af%d\n", af);
			m_freem(m);
			return;
		}

		s = splnet();
		if (IF_QFULL(ifq)) {
			IF_DROP(ifq);
			m_freem(m);
			splx(s);
			return;
		}
		IF_ENQUEUE(ifq, m);
		schednetisr(isr);
		ifp->if_ipackets++;
		ifp->if_ibytes += m->m_pkthdr.len;
		splx(s);
	}
}
#endif /* ALTQ */
@


1.52
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.51 2013/10/19 14:46:30 mpi Exp $	*/
a134 1
#include <netinet6/in6_var.h>
@


1.51
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.50 2013/08/28 06:58:57 mpi Exp $	*/
a127 1
#include <netinet/in_var.h>
@


1.50
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.49 2013/03/28 16:55:27 deraadt Exp $	*/
a410 20
		ifr = (struct ifreq *)data;
		if (ifr == 0) {
			error = EAFNOSUPPORT;		/* XXX */
			break;
		}
		switch (ifr->ifr_addr.sa_family) {

#ifdef INET
		case AF_INET:
			break;
#endif
#ifdef INET6
		case AF_INET6:
			break;
#endif /* INET6 */

		default:
			error = EAFNOSUPPORT;
			break;
		}
@


1.49
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.48 2013/03/10 13:15:48 claudio Exp $	*/
d376 1
a376 1
lortrequest(int cmd, struct rtentry *rt, struct rt_addrinfo *info)
@


1.48
log
@Switch to ANSI C prototypes. Diff by somebody else which I no longer remember.
No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.47 2012/04/14 09:39:47 yasuoka Exp $	*/
a118 1
#include <machine/cpu.h>
@


1.47
log
@Use DLT_LOOP for all tunneling interfaces.
Byte order adjustment for bpf was hidden behind bpf_mtap_af() and
sizeof(u_int32_t) is used for length of the bpf header.

tested by sebastia and mxb at alumni.chalmers.se.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.46 2011/07/09 00:47:18 henning Exp $	*/
d167 1
a167 2
loopattach(n)
	int n;
d174 1
a174 3
loop_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
d209 1
a209 2
loop_clone_destroy(ifp)
	struct ifnet *ifp;
d221 2
a222 5
looutput(ifp, m, dst, rt)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr *dst;
	struct rtentry *rt;
d315 1
a315 2
lo_altqstart(ifp)
	struct ifnet *ifp;
d377 1
a377 4
lortrequest(cmd, rt, info)
	int cmd;
	struct rtentry *rt;
	struct rt_addrinfo *info;
a378 1

d388 1
a388 4
loioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
@


1.46
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.45 2011/07/04 19:24:05 sthen Exp $	*/
d243 1
a243 2
		bpf_mtap_af(ifp->if_bpf, htonl(dst->sa_family), m,
		    BPF_DIRECTION_OUT);
@


1.45
log
@make sure RTM_IFINFO is sent when lo(4) handles SIOCSIFADDR; without this
ospfd doesn't notice an interface added at runtime unless you ifconfig down+up.
ok phessler@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.44 2008/05/07 12:58:54 norby Exp $	*/
a140 6
#ifdef NETATALK
#include <netinet/if_ether.h>
#include <netatalk/at.h>
#include <netatalk/at_var.h>
#endif

a293 6
#ifdef NETATALK
	case AF_APPLETALK:
		ifq = &atintrq2;
		isr = NETISR_ATALK;
		break;
#endif /* NETATALK */
a361 6
#ifdef NETATALK
		case AF_APPLETALK:
			ifq = &atintrq2;
			isr = NETISR_ATALK;
			break;
#endif /* NETATALK */
@


1.44
log
@Add MPLS support to loopback.

Makes it possible to do evil tricks locally.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.43 2007/12/20 02:53:02 brad Exp $	*/
d426 1
a426 1
	int error = 0;
d431 5
a435 1
		ifp->if_flags |= IFF_UP | IFF_RUNNING;
@


1.43
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.42 2007/09/15 16:43:51 henning Exp $	*/
d147 4
d306 6
d366 6
@


1.42
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.41 2007/06/06 10:04:36 henning Exp $	*/
d454 1
a454 1
		error = EINVAL;
@


1.41
log
@remove remaining IPX hooks. all inside #ifdef IPX, so no actual change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.40 2006/03/25 22:41:47 djm Exp $	*/
d183 1
a183 1
	MALLOC(ifp, struct ifnet *, sizeof(*ifp), M_DEVBUF, M_NOWAIT);
a185 1
	bzero(ifp, sizeof(struct ifnet));
@


1.40
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.39 2006/03/04 22:40:15 brad Exp $	*/
a140 5
#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

a296 6
#ifdef IPX
	case AF_IPX:
		ifq = &ipxintrq;
		isr = NETISR_IPX;
		break;
#endif
a356 6
			break;
#endif
#ifdef IPX
		case AF_IPX:
			ifq = &ipxintrq;
			isr = NETISR_IPX;
@


1.39
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.38 2006/01/04 06:04:42 canacar Exp $	*/
d251 2
a252 1
		bpf_mtap_af(ifp->if_bpf, htonl(dst->sa_family), m);
@


1.38
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.37 2005/08/02 13:42:05 markus Exp $	*/
d280 1
a280 1
	        s = splimp();
d319 1
a319 1
	s = splimp();
d345 1
a345 1
		s = splimp();
d387 1
a387 1
		s = splimp();
@


1.37
log
@pass the AF in network byte order to bpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.36 2005/07/31 03:52:18 pascoe Exp $	*/
a225 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.36
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.35 2005/06/12 06:23:43 henning Exp $	*/
d254 1
a254 1
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m);
@


1.35
log
@lo0 is special, attaches early an different than the other loopback interfaces
needs special treatment to join the lo group, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.34 2005/06/08 06:35:04 henning Exp $	*/
d253 2
a254 18
	if (ifp->if_bpf && (ifp->if_flags&IFF_LOOPBACK)) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer to it).
		 */
		struct mbuf m0;
		u_int32_t af = htonl(dst->sa_family);

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = sizeof(af);
		m0.m_data = (char *)&af;

		bpf_mtap(ifp->if_bpf, &m0);
	}
@


1.34
log
@no more netns handling for the various tunnel devices and loopback
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.33 2004/07/16 15:01:09 henning Exp $	*/
d209 1
@


1.33
log
@remove netiso shitz, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.32 2003/12/16 20:33:25 markus Exp $	*/
a140 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a318 6
#ifdef NS
	case AF_NS:
		ifq = &nsintrq;
		isr = NETISR_NS;
		break;
#endif
a390 6
			break;
#endif
#ifdef NS
		case AF_NS:
			ifq = &nsintrq;
			isr = NETISR_NS;
@


1.32
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.31 2003/12/10 07:22:42 itojun Exp $	*/
a150 5
#ifdef ISO
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#endif

a335 6
#ifdef ISO
	case AF_ISO:
		ifq = &clnlintrq;
		isr = NETISR_ISO;
		break;
#endif
a409 6
#ifdef ISO
		case AF_ISO:
			ifq = &clnlintrq;
			isr = NETISR_ISO;
			break;
#endif
d469 1
a469 1
		if (ifa != 0 /*&& ifa->ifa_addr->sa_family == AF_ISO*/)
@


1.31
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.30 2003/12/03 14:53:04 markus Exp $	*/
d177 1
a177 1
void	loop_clone_destroy(struct ifnet *);
d228 1
a228 1
void
d233 1
a233 1
		return;			/* XXX silently fail for lo0 */
d241 1
@


1.30
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.29 2003/06/02 23:28:12 millert Exp $	*/
d246 1
a246 1
	register struct mbuf *m;
d248 1
a248 1
	register struct rtentry *rt;
d251 1
a251 1
	register struct ifqueue *ifq = 0;
d472 1
a472 1
	register struct ifnet *ifp;
d476 3
a478 3
	register struct ifaddr *ifa;
	register struct ifreq *ifr;
	register int error = 0;
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.28 2003/05/03 21:15:11 deraadt Exp $	*/
d176 7
d187 10
a196 2
	register int i;
	register struct ifnet *ifp;
d198 15
a212 17
	for (i = n; i--; ) {
		MALLOC(ifp, struct ifnet *, sizeof(*ifp), M_DEVBUF, M_NOWAIT);
		if (ifp == NULL)
			return;
		bzero(ifp, sizeof(struct ifnet));
		if (i == 0)
			lo0ifp = ifp;
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "lo%d", i);
		ifp->if_softc = NULL;
		ifp->if_mtu = LOMTU;
		ifp->if_flags = IFF_LOOPBACK | IFF_MULTICAST;
		ifp->if_ioctl = loioctl;
		ifp->if_output = looutput;
		ifp->if_type = IFT_LOOP;
		ifp->if_hdrlen = sizeof(u_int32_t);
		ifp->if_addrlen = 0;
		IFQ_SET_READY(&ifp->if_snd);
d214 1
a214 1
		ifp->if_start = lo_altqstart;
d216 2
d219 16
a234 1
		if_alloc_sadl(ifp);
d236 1
a236 1
		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d238 3
a240 1
	}
@


1.28
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.27 2003/05/03 01:43:07 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.27
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.26 2003/01/07 09:00:33 kjc Exp $	*/
d194 1
a194 1
		sprintf(ifp->if_xname, "lo%d", i);
@


1.26
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.25 2002/09/11 05:38:47 itojun Exp $	*/
d244 1
@


1.25
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.24 2002/06/30 13:04:36 itojun Exp $	*/
a268 1
		struct altq_pktattr pktattr;
a271 6
		/*
		 * if the queueing discipline needs packet classification,
		 * do it before prepending link headers.
		 */
		IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d279 1
a279 1
		IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
@


1.24
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.23 2002/03/14 01:27:09 millert Exp $	*/
d281 1
a281 1
			return(ENOBUFS);
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.22 2002/01/02 20:56:14 dugsong Exp $	*/
d208 1
@


1.22
log
@allow for setting of the loopback MTU, set IFF_RUNNING on address configuration
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.21 2001/12/18 23:07:49 deraadt Exp $	*/
d177 1
a177 1
static void lo_altqstart __P((struct ifnet *));
@


1.21
log
@NRL license cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.20 2001/07/04 23:14:54 espie Exp $	*/
d460 1
a460 1
		ifp->if_flags |= IFF_UP;
d491 5
@


1.21.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.22 2002/01/02 20:56:14 dugsong Exp $	*/
d460 1
a460 1
		ifp->if_flags |= IFF_UP | IFF_RUNNING;
a490 5
		break;

	case SIOCSIFMTU:
		ifr = (struct ifreq *)data;
		ifp->if_mtu = ifr->ifr_mtu;
@


1.21.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.21.2.1 2002/01/31 22:55:43 niklas Exp $	*/
d177 1
a177 1
static void lo_altqstart(struct ifnet *);
@


1.21.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.21.2.2 2002/06/11 03:30:45 art Exp $	*/
a207 1
		if_alloc_sadl(ifp);
d280 1
a280 1
			return (ENOBUFS);
@


1.21.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d194 1
a194 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "lo%d", i);
a243 1
		m0.m_flags = 0;
d269 1
d273 6
d286 1
a286 1
		IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
@


1.20
log
@Make preprocessor happier, don't give it untasty tokens at end of input.
Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.19 2001/06/27 06:07:42 kjc Exp $	*/
d69 38
a106 10
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.19
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.18 2001/06/15 03:38:34 itojun Exp $	*/
d300 1
a300 1
#endif NETATALK
d380 1
a380 1
#endif NETATALK
@


1.18
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.17 2001/02/06 03:34:59 mickey Exp $	*/
d148 4
d175 4
d232 31
d321 81
@


1.17
log
@forgot to bzero() malloced memory
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.16 2001/02/06 00:22:21 mickey Exp $	*/
a189 1
	ifp->if_lastchange = time;
@


1.16
log
@allow changing number of loopbacks in ukc.
change rest of the code to use lo0ifp pointing
to the corresponding struct ifnet.
itojun@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.15 2001/01/19 06:37:36 itojun Exp $	*/
d159 1
@


1.15
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.14 2000/06/18 06:24:45 itojun Exp $	*/
a84 1
#include "loop.h"
a147 2
struct	ifnet loif[NLOOP];

d155 6
a160 2
	for (i = NLOOP; i--; ) {
		ifp = &loif[i];
@


1.14
log
@move m_pullup2() equivalent for KAME requirement into ip6_input().
it was in looutput() to make KAME ipsec4 happy.
however, since we don't have KAME ipsec4 in openbsd, we don't need it
in looutput().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.13 2000/02/07 06:09:08 itojun Exp $	*/
d284 1
a284 1
lortrequest(cmd, rt, sa)
d287 1
a287 1
	struct sockaddr *sa;
@


1.13
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.12 1999/12/08 06:50:18 itojun Exp $	*/
a219 48

#ifndef PULLDOWN_TEST
	/*
	 * KAME requires that the packet to be contiguous on the
	 * mbuf.  We need to make that sure.
	 * this kind of code should be avoided.
	 * XXX other conditions to avoid running this part?
	 */
	if (m && m->m_next != NULL) {
		struct mbuf *n;

		MGETHDR(n, M_DONTWAIT, MT_HEADER);
		if (n) {
			MCLGET(n, M_DONTWAIT);
			if ((n->m_flags & M_EXT) == 0) {
				m_free(n);
				n = NULL;
			}
		}
		if (!n) {
			printf("looutput: mbuf allocation failed\n");
			m_freem(m);
			return ENOBUFS;
		}

		n->m_pkthdr.rcvif = m->m_pkthdr.rcvif;
		n->m_pkthdr.len = m->m_pkthdr.len;
		if (m->m_pkthdr.len <= MCLBYTES) {
			m_copydata(m, 0, m->m_pkthdr.len, mtod(n, caddr_t));
			n->m_len = m->m_pkthdr.len;
			m_freem(m);
		} else {
			m_copydata(m, 0, MCLBYTES, mtod(n, caddr_t));
			m_adj(m, MCLBYTES);
			n->m_len = MCLBYTES;
			n->m_next = m;
			m->m_flags &= ~M_PKTHDR;
		}
		m = n;
	}
#if 0
	if (m && m->m_next != NULL) {
		printf("loop: not contiguous...\n");
		m_freem(m);
		return ENOBUFS;
	}
#endif
#endif
@


1.13.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.17 2001/02/06 03:34:59 mickey Exp $	*/
d85 1
d149 2
d158 2
a159 7
	for (i = n; i--; ) {
		MALLOC(ifp, struct ifnet *, sizeof(*ifp), M_DEVBUF, M_NOWAIT);
		if (ifp == NULL)
			return;
		bzero(ifp, sizeof(struct ifnet));
		if (i == 0)
			lo0ifp = ifp;
d221 48
d332 1
a332 1
lortrequest(cmd, rt, info)
d335 1
a335 1
	struct rt_addrinfo *info;
@


1.13.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.13.2.1 2001/05/14 22:40:01 niklas Exp $	*/
a147 4
#ifdef ALTQ
static void lo_altqstart __P((struct ifnet *));
#endif

a170 4
		IFQ_SET_READY(&ifp->if_snd);
#ifdef ALTQ
		ifp->if_start = lo_altqstart;
#endif
d190 1
a224 31
#ifdef ALTQ
	/*
	 * altq for loop is just for debugging.
	 * only used when called for loop interface (not for
	 * a simplex interface).
	 */
	if ((ALTQ_IS_ENABLED(&ifp->if_snd) || TBR_IS_ENABLED(&ifp->if_snd))
	    && ifp->if_start == lo_altqstart) {
		struct altq_pktattr pktattr;
		int32_t *afp;
	        int error;

		/*
		 * if the queueing discipline needs packet classification,
		 * do it before prepending link headers.
		 */
		IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

		M_PREPEND(m, sizeof(int32_t), M_DONTWAIT);
		if (m == 0)
			return(ENOBUFS);
		afp = mtod(m, int32_t *);
		*afp = (int32_t)dst->sa_family;

	        s = splimp();
		IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
		(*ifp->if_start)(ifp);
		splx(s);
		return (error);
	}
#endif /* ALTQ */
a282 81

#ifdef ALTQ
static void
lo_altqstart(ifp)
	struct ifnet *ifp;
{
	struct ifqueue *ifq;
	struct mbuf *m;
	int32_t af, *afp;
	int s, isr;
	
	while (1) {
		s = splimp();
		IFQ_DEQUEUE(&ifp->if_snd, m);
		splx(s);
		if (m == NULL)
			return;

		afp = mtod(m, int32_t *);
		af = *afp;
		m_adj(m, sizeof(int32_t));

		switch (af) {
#ifdef INET
		case AF_INET:
			ifq = &ipintrq;
			isr = NETISR_IP;
			break;
#endif
#ifdef INET6
		case AF_INET6:
			m->m_flags |= M_LOOP;
			ifq = &ip6intrq;
			isr = NETISR_IPV6;
			break;
#endif
#ifdef IPX
		case AF_IPX:
			ifq = &ipxintrq;
			isr = NETISR_IPX;
			break;
#endif
#ifdef NS
		case AF_NS:
			ifq = &nsintrq;
			isr = NETISR_NS;
			break;
#endif
#ifdef ISO
		case AF_ISO:
			ifq = &clnlintrq;
			isr = NETISR_ISO;
			break;
#endif
#ifdef NETATALK
		case AF_APPLETALK:
			ifq = &atintrq2;
			isr = NETISR_ATALK;
			break;
#endif NETATALK
		default:
			printf("lo_altqstart: can't handle af%d\n", af);
			m_freem(m);
			return;
		}

		s = splimp();
		if (IF_QFULL(ifq)) {
			IF_DROP(ifq);
			m_freem(m);
			splx(s);
			return;
		}
		IF_ENQUEUE(ifq, m);
		schednetisr(isr);
		ifp->if_ipackets++;
		ifp->if_ibytes += m->m_pkthdr.len;
		splx(s);
	}
}
#endif /* ALTQ */
@


1.13.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.13.2.2 2001/07/04 10:54:03 niklas Exp $	*/
d300 1
a300 1
#endif /* NETATALK */
d380 1
a380 1
#endif /* NETATALK */
@


1.13.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 10
a78 38
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d432 1
a432 1
		ifp->if_flags |= IFF_UP | IFF_RUNNING;
a462 5
		break;

	case SIOCSIFMTU:
		ifr = (struct ifreq *)data;
		ifp->if_mtu = ifr->ifr_mtu;
@


1.13.2.5
log
@Merge in -current from roughly a week ago
@
text
@d177 1
a177 1
static void lo_altqstart(struct ifnet *);
@


1.13.2.6
log
@Sync the SMP branch with 3.3
@
text
@a207 1
		if_alloc_sadl(ifp);
d268 1
d272 6
d280 1
a280 1
			return (ENOBUFS);
d285 1
a285 1
		IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
@


1.13.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.13.2.6 2003/03/28 00:41:28 niklas Exp $	*/
d194 1
a194 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "lo%d", i);
a243 1
		m0.m_flags = 0;
@


1.13.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.13.2.7 2003/05/13 19:36:15 ho Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.13.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a175 7
int	loop_clone_create(struct if_clone *, int);
int	loop_clone_destroy(struct ifnet *);

struct if_clone loop_cloner =
    IF_CLONE_INITIALIZER("lo", loop_clone_create, loop_clone_destroy);

/* ARGSUSED */
d180 2
a181 3
	(void) loop_clone_create(&loop_cloner, 0);
	if_clone_attach(&loop_cloner);
}
d183 17
a199 22
int
loop_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
{
	struct ifnet *ifp;

	MALLOC(ifp, struct ifnet *, sizeof(*ifp), M_DEVBUF, M_NOWAIT);
	if (ifp == NULL)
		return (ENOMEM);
	bzero(ifp, sizeof(struct ifnet));

	snprintf(ifp->if_xname, sizeof ifp->if_xname, "lo%d", unit);
	ifp->if_softc = NULL;
	ifp->if_mtu = LOMTU;
	ifp->if_flags = IFF_LOOPBACK | IFF_MULTICAST;
	ifp->if_ioctl = loioctl;
	ifp->if_output = looutput;
	ifp->if_type = IFT_LOOP;
	ifp->if_hdrlen = sizeof(u_int32_t);
	ifp->if_addrlen = 0;
	IFQ_SET_READY(&ifp->if_snd);
d201 1
a201 1
	ifp->if_start = lo_altqstart;
a202 2
	if (unit == 0) {
		lo0ifp = ifp;
d204 1
a204 3
	} else
		if_attach(ifp);
	if_alloc_sadl(ifp);
d206 1
a206 1
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d208 1
a208 17
	return (0);
}

int
loop_clone_destroy(ifp)
	struct ifnet *ifp;
{
	if (ifp == lo0ifp)
		return (EPERM);

#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
	if_detach(ifp);

	free(ifp, M_DEVBUF);
	return (0);
d214 1
a214 1
	struct mbuf *m;
d216 1
a216 1
	struct rtentry *rt;
d219 1
a219 1
	struct ifqueue *ifq = 0;
d440 1
a440 1
	struct ifnet *ifp;
d444 3
a446 3
	struct ifaddr *ifa;
	struct ifreq *ifr;
	int error = 0;
@


1.12
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.11 1999/01/08 00:56:45 deraadt Exp $	*/
d115 1
a115 1
#include <netinet6/ip6.h>
@


1.11
log
@inet6 support; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.10 1998/06/26 09:14:37 deraadt Exp $	*/
d5 29
d110 8
d143 6
a148 7
#ifdef INET6
#include <netinet6/in6.h>
#include <netinet6/in6_var.h>
#endif /* INET6 */

#define	LOMTU	(32768)

d220 49
d281 1
a281 1
		ifq = &ipv6intrq;
d361 1
a361 1
		if (ifa != 0 && ifa->ifa_addr->sa_family == AF_ISO)
a380 1

@


1.10
log
@convert DLT_LOOP header to network-order u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.9 1998/06/04 23:11:38 deraadt Exp $	*/
d40 12
d106 5
d194 6
d296 5
@


1.9
log
@add DLT_LOOP support; 4-byte header indicates proto; cstone@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.8 1997/12/31 04:33:38 mickey Exp $	*/
d114 1
a114 1
		ifp->if_hdrlen = 4;
d118 1
a118 1
		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int));
d151 1
a151 1
		u_int af = dst->sa_family;
d154 1
a154 1
		m0.m_len = 4;
@


1.8
log
@make the loopback interfaces ordered in the iface list, so they show up in netstat much better; this particular case showed up with more than one loopback configured in the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.7 1997/07/23 03:46:01 denny Exp $	*/
d114 1
a114 1
		ifp->if_hdrlen = 0;
d118 1
a118 1
		bpfattach(&ifp->if_bpf, ifp, DLT_NULL, sizeof(u_int));
@


1.7
log
@AppleTalk support based on netatalk-1.4a2 and FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.6 1996/06/29 18:54:11 deraadt Exp $	*/
d105 1
a105 1
	for (i = 0; i < NLOOP; i++) {
@


1.6
log
@provide if_attachhead(), and make if_loop use it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_loop.c,v 1.5 1996/05/10 12:31:09 deraadt Exp $	*/
d84 6
d195 6
@


1.5
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d110 1
a110 1
		if_attach(ifp);
@


1.4
log
@IPX additions and fixes.
ether -- missed the input for IPX.
fddi -- just added.
ppp -- field codes added.
loop -- minor fix.
@
text
@d2 1
a2 1
/*	$NetBSD: if_loop.c,v 1.14 1995/07/23 16:33:08 mycroft Exp $	*/
d101 2
a102 2
		ifp->if_unit = i;
		ifp->if_name = "lo";
d190 1
a190 1
		printf("lo%d: can't handle af%d\n", ifp->if_unit,
@


1.3
log
@Add IPX support.
@
text
@d1 1
@


1.2
log
@do not forward garbled SIMPLEX-generated packets to bpf; from Jean-Luc.Richier@@imag.fr; netbsd pr#1693
@
text
@d73 5
d174 6
@


1.1
log
@Initial revision
@
text
@d125 6
a130 1
	if (ifp->if_bpf) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
