head	1.492;
access;
symbols
	OPENBSD_6_1:1.492.0.2
	OPENBSD_6_1_BASE:1.492
	OPENBSD_6_0:1.436.0.4
	OPENBSD_6_0_BASE:1.436
	OPENBSD_5_9:1.425.0.2
	OPENBSD_5_9_BASE:1.425
	OPENBSD_5_8:1.357.0.2
	OPENBSD_5_8_BASE:1.357
	OPENBSD_5_7:1.320.0.2
	OPENBSD_5_7_BASE:1.320
	OPENBSD_5_6:1.297.0.4
	OPENBSD_5_6_BASE:1.297
	OPENBSD_5_5:1.280.0.4
	OPENBSD_5_5_BASE:1.280
	OPENBSD_5_4:1.261.0.2
	OPENBSD_5_4_BASE:1.261
	OPENBSD_5_3:1.248.0.2
	OPENBSD_5_3_BASE:1.248
	OPENBSD_5_2:1.241.0.4
	OPENBSD_5_2_BASE:1.241
	OPENBSD_5_1_BASE:1.241
	OPENBSD_5_1:1.241.0.2
	OPENBSD_5_0:1.239.0.2
	OPENBSD_5_0_BASE:1.239
	OPENBSD_4_9:1.233.0.2
	OPENBSD_4_9_BASE:1.233
	OPENBSD_4_8:1.219.0.2
	OPENBSD_4_8_BASE:1.219
	OPENBSD_4_7:1.211.0.2
	OPENBSD_4_7_BASE:1.211
	OPENBSD_4_6:1.196.0.4
	OPENBSD_4_6_BASE:1.196
	OPENBSD_4_5:1.188.0.2
	OPENBSD_4_5_BASE:1.188
	OPENBSD_4_4:1.173.0.2
	OPENBSD_4_4_BASE:1.173
	OPENBSD_4_3:1.168.0.2
	OPENBSD_4_3_BASE:1.168
	OPENBSD_4_2:1.165.0.2
	OPENBSD_4_2_BASE:1.165
	OPENBSD_4_1:1.155.0.2
	OPENBSD_4_1_BASE:1.155
	OPENBSD_4_0:1.149.0.2
	OPENBSD_4_0_BASE:1.149
	OPENBSD_3_9:1.143.0.2
	OPENBSD_3_9_BASE:1.143
	OPENBSD_3_8:1.137.0.2
	OPENBSD_3_8_BASE:1.137
	OPENBSD_3_7:1.104.0.2
	OPENBSD_3_7_BASE:1.104
	OPENBSD_3_6:1.90.0.2
	OPENBSD_3_6_BASE:1.90
	SMP_SYNC_A:1.88
	SMP_SYNC_B:1.88
	OPENBSD_3_5:1.84.0.2
	OPENBSD_3_5_BASE:1.84
	OPENBSD_3_4:1.70.0.2
	OPENBSD_3_4_BASE:1.70
	UBC_SYNC_A:1.65
	OPENBSD_3_3:1.64.0.4
	OPENBSD_3_3_BASE:1.64
	OPENBSD_3_2:1.64.0.2
	OPENBSD_3_2_BASE:1.64
	OPENBSD_3_1:1.51.0.2
	OPENBSD_3_1_BASE:1.51
	UBC_SYNC_B:1.64
	UBC:1.50.0.2
	UBC_BASE:1.50
	OPENBSD_3_0:1.49.0.2
	OPENBSD_3_0_BASE:1.49
	OPENBSD_2_9_BASE:1.43
	OPENBSD_2_9:1.43.0.2
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	SMP:1.27.0.2
	SMP_BASE:1.27
	kame_19991208:1.25
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.18.0.4
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.12.0.4
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.492
date	2017.03.22.12.45.22;	author mikeb;	state Exp;
branches;
next	1.491;
commitid	Z0wCesL8asxhSVnG;

1.491
date	2017.03.17.17.19.16;	author mpi;	state Exp;
branches;
next	1.490;
commitid	CxqvXOMqotM60GAI;

1.490
date	2017.03.08.09.19.45;	author mpi;	state Exp;
branches;
next	1.489;
commitid	4cykCW25TYiTisOK;

1.489
date	2017.03.06.08.56.39;	author mpi;	state Exp;
branches;
next	1.488;
commitid	aDXuIkVsOPuafbD0;

1.488
date	2017.02.28.15.35.02;	author yasuoka;	state Exp;
branches;
next	1.487;
commitid	yef8HK0EHF3ARYBI;

1.487
date	2017.02.16.10.15.12;	author mpi;	state Exp;
branches;
next	1.486;
commitid	NChVcK48FdZeU9j9;

1.486
date	2017.02.07.10.08.21;	author mpi;	state Exp;
branches;
next	1.485;
commitid	gzLIBtF3UIhyOxtA;

1.485
date	2017.02.01.02.02.01;	author jsg;	state Exp;
branches;
next	1.484;
commitid	ynTE1fPCuRL445bP;

1.484
date	2017.02.01.01.25.19;	author jsg;	state Exp;
branches;
next	1.483;
commitid	u9lr7W7km2DNwrwI;

1.483
date	2017.01.31.12.16.20;	author mpi;	state Exp;
branches;
next	1.482;
commitid	iS7YuY5nvwVZYxyO;

1.482
date	2017.01.25.21.59.41;	author mpi;	state Exp;
branches;
next	1.481;
commitid	ItvKRgru62mnNdnN;

1.481
date	2017.01.25.06.15.50;	author mpi;	state Exp;
branches;
next	1.480;
commitid	X7Hk1efefaYrWlw3;

1.480
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.479;
commitid	6c6qq5OdS4VVnyVM;

1.479
date	2017.01.24.03.57.35;	author dlg;	state Exp;
branches;
next	1.478;
commitid	PERtGPXCvlLRRBr8;

1.478
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.477;
commitid	F6oNrr9LCLUSAxgA;

1.477
date	2017.01.23.07.27.21;	author dlg;	state Exp;
branches;
next	1.476;
commitid	GMRaunaipkxtJbHJ;

1.476
date	2017.01.23.01.26.09;	author dlg;	state Exp;
branches;
next	1.475;
commitid	3JbnbVjcNixwggnm;

1.475
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.474;
commitid	VyLWTsbepAOk7VQM;

1.474
date	2017.01.12.09.07.46;	author mpi;	state Exp;
branches;
next	1.473;
commitid	j1npQb4ryks9jUEW;

1.473
date	2017.01.04.03.56.15;	author dlg;	state Exp;
branches;
next	1.472;
commitid	ooWeqIeufHP1kBk7;

1.472
date	2017.01.04.03.42.33;	author dlg;	state Exp;
branches;
next	1.471;
commitid	FEXLiMsVlkjt3Z4H;

1.471
date	2017.01.04.03.12.54;	author dlg;	state Exp;
branches;
next	1.470;
commitid	YDXu7tzPANAc8XS9;

1.470
date	2017.01.03.13.11.55;	author mpi;	state Exp;
branches;
next	1.469;
commitid	L1xnxhLb3qI0bg9D;

1.469
date	2016.12.29.12.12.43;	author mpi;	state Exp;
branches;
next	1.468;
commitid	RhxGXGNe4WuNtTZs;

1.468
date	2016.12.21.10.22.14;	author jca;	state Exp;
branches;
next	1.467;
commitid	BMJVI5ycH2LiATpJ;

1.467
date	2016.12.20.19.34.56;	author mikeb;	state Exp;
branches;
next	1.466;
commitid	bijPPl14M7UzxUQI;

1.466
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.465;
commitid	QqHqT2WhCBWqYgGJ;

1.465
date	2016.12.12.09.51.30;	author mpi;	state Exp;
branches;
next	1.464;
commitid	4shAe6LbqmAnsu7t;

1.464
date	2016.12.02.18.32.38;	author vgross;	state Exp;
branches;
next	1.463;
commitid	VcueUoF2Nieb9tY2;

1.463
date	2016.11.28.11.18.02;	author mpi;	state Exp;
branches;
next	1.462;
commitid	Xo2oemed3z2JPqDo;

1.462
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.461;
commitid	wuzpseLx3Ntn9R7b;

1.461
date	2016.11.14.10.52.04;	author mpi;	state Exp;
branches;
next	1.460;
commitid	oNgLwGk7fGVGEJyj;

1.460
date	2016.11.14.10.44.17;	author mpi;	state Exp;
branches;
next	1.459;
commitid	DG25GNh6epXrrniG;

1.459
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.458;
commitid	to0Je2i4V2FtpmS1;

1.458
date	2016.11.08.10.47.10;	author mpi;	state Exp;
branches;
next	1.457;
commitid	WzpNxbZNf3xLAkyy;

1.457
date	2016.11.08.10.46.04;	author mpi;	state Exp;
branches;
next	1.456;
commitid	FX5giWCmMTBWXuF5;

1.456
date	2016.10.19.02.05.49;	author yasuoka;	state Exp;
branches;
next	1.455;
commitid	az4Ba8hpn6YqTGDZ;

1.455
date	2016.10.16.21.45.17;	author bluhm;	state Exp;
branches;
next	1.454;
commitid	itY5vXUsgqpsSOah;

1.454
date	2016.10.09.20.05.10;	author claudio;	state Exp;
branches;
next	1.453;
commitid	hDsgJzdcdno3IL2T;

1.453
date	2016.10.07.08.18.22;	author rzalamena;	state Exp;
branches;
next	1.452;
commitid	sHnaKh8RqSkdcMme;

1.452
date	2016.10.03.12.26.13;	author rzalamena;	state Exp;
branches;
next	1.451;
commitid	599KriAM2Xmcdmg8;

1.451
date	2016.09.28.08.31.42;	author rzalamena;	state Exp;
branches;
next	1.450;
commitid	UFCoC28Bk9GnT56y;

1.450
date	2016.09.22.14.50.11;	author mpi;	state Exp;
branches;
next	1.449;
commitid	vcpuxupo0DIetPE8;

1.449
date	2016.09.20.16.14.43;	author mikeb;	state Exp;
branches;
next	1.448;
commitid	6S8D1cUe4bTXUt72;

1.448
date	2016.09.13.08.15.01;	author mpi;	state Exp;
branches;
next	1.447;
commitid	tOYxekVclvAdvPpV;

1.447
date	2016.09.08.09.13.10;	author mpi;	state Exp;
branches;
next	1.446;
commitid	84Ly77PoNnlYRmww;

1.446
date	2016.09.07.09.36.49;	author mpi;	state Exp;
branches;
next	1.445;
commitid	maggOul7Gx8kGBXs;

1.445
date	2016.09.05.13.09.32;	author claudio;	state Exp;
branches;
next	1.444;
commitid	3EfrP9kNwKUKHDfx;

1.444
date	2016.09.04.17.14.58;	author mpi;	state Exp;
branches;
next	1.443;
commitid	NnJk0pJ0tMDMwhKD;

1.443
date	2016.09.04.15.46.39;	author reyk;	state Exp;
branches;
next	1.442;
commitid	05wK3oqe2BKozGUg;

1.442
date	2016.09.04.15.10.59;	author reyk;	state Exp;
branches;
next	1.441;
commitid	WiybL9FZDMpyujgS;

1.441
date	2016.09.04.10.32.01;	author mpi;	state Exp;
branches;
next	1.440;
commitid	0JNLzz71W0Jm1WWQ;

1.440
date	2016.09.03.10.05.19;	author mpi;	state Exp;
branches;
next	1.439;
commitid	bGMGuBZUh1ea3Sm7;

1.439
date	2016.09.03.09.55.44;	author mpi;	state Exp;
branches;
next	1.438;
commitid	cql4kpEcloSl2LWa;

1.438
date	2016.09.01.10.06.33;	author goda;	state Exp;
branches;
next	1.437;
commitid	53X2QcUepPKjCjvt;

1.437
date	2016.08.11.00.58.22;	author dlg;	state Exp;
branches;
next	1.436;
commitid	xDArYHjOuHkmSeh9;

1.436
date	2016.07.13.16.45.19;	author mpi;	state Exp;
branches;
next	1.435;
commitid	rLX7PMZ4auGYbwG0;

1.435
date	2016.07.12.09.33.13;	author mpi;	state Exp;
branches;
next	1.434;
commitid	bGHAD4QJZHhDusKV;

1.434
date	2016.06.10.20.33.29;	author vgross;	state Exp;
branches;
next	1.433;
commitid	qJaxh4rw41tBg4CK;

1.433
date	2016.05.18.03.46.03;	author dlg;	state Exp;
branches;
next	1.432;
commitid	q5zkugIMulsP5tHa;

1.432
date	2016.05.10.06.37.15;	author dlg;	state Exp;
branches;
next	1.431;
commitid	SOBlB2bxzuD6MSBb;

1.431
date	2016.05.08.08.58.27;	author mpi;	state Exp;
branches;
next	1.430;
commitid	pArtkT7PnntgUthT;

1.430
date	2016.05.03.14.52.39;	author mpi;	state Exp;
branches;
next	1.429;
commitid	dxC8XEETMDhMlqh6;

1.429
date	2016.03.16.12.08.09;	author dlg;	state Exp;
branches;
next	1.428;
commitid	P5mxvK8s2Jg41p1M;

1.428
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.427;
commitid	Z6e4eqr6FuYFPnlL;

1.427
date	2016.03.02.00.00.16;	author dlg;	state Exp;
branches;
next	1.426;
commitid	7U01XYSlRSFgd0i5;

1.426
date	2016.02.28.15.46.19;	author naddy;	state Exp;
branches;
next	1.425;
commitid	iOuZImHZRAr7Hvd6;

1.425
date	2015.12.09.03.22.39;	author dlg;	state Exp;
branches;
next	1.424;
commitid	ORE7f8VM8QK0ujAk;

1.424
date	2015.12.08.10.18.56;	author mpi;	state Exp;
branches;
next	1.423;
commitid	5ENDJ1ratq2KSOib;

1.423
date	2015.12.08.10.06.12;	author dlg;	state Exp;
branches;
next	1.422;
commitid	VAQjlQNQBXJ725Km;

1.422
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.421;
commitid	ILbVM1M3uPNjwswz;

1.421
date	2015.12.04.11.50.01;	author mpi;	state Exp;
branches;
next	1.420;
commitid	X90fzIebVJrChMdf;

1.420
date	2015.12.03.16.27.32;	author mpi;	state Exp;
branches;
next	1.419;
commitid	wK6td35Fr7xdNzh3;

1.419
date	2015.12.03.14.55.17;	author vgross;	state Exp;
branches;
next	1.418;
commitid	DukW6jeSHPpp8ZFD;

1.418
date	2015.12.03.12.22.51;	author dlg;	state Exp;
branches;
next	1.417;
commitid	Xu3de8VDlKImDsXf;

1.417
date	2015.12.02.16.35.52;	author bluhm;	state Exp;
branches;
next	1.416;
commitid	i3XNpYhaQ8QndxLo;

1.416
date	2015.12.02.08.47.00;	author claudio;	state Exp;
branches;
next	1.415;
commitid	bBZq0t5zueGnkAtX;

1.415
date	2015.12.01.16.57.34;	author vgross;	state Exp;
branches;
next	1.414;
commitid	0jBupYBt7k2alEc4;

1.414
date	2015.11.27.11.52.44;	author mpi;	state Exp;
branches;
next	1.413;
commitid	b6yEC4HO3KJwk5bP;

1.413
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.412;
commitid	B0kwmVGiD5DVx4kv;

1.412
date	2015.11.21.01.08.49;	author dlg;	state Exp;
branches;
next	1.411;
commitid	NZSRW1Bv4cWMAzsm;

1.411
date	2015.11.20.12.27.42;	author mpi;	state Exp;
branches;
next	1.410;
commitid	3FP0bC2PMwNhAj60;

1.410
date	2015.11.20.11.15.07;	author dlg;	state Exp;
branches;
next	1.409;
commitid	DSo9cWHeceL3peeU;

1.409
date	2015.11.20.10.40.00;	author sthen;	state Exp;
branches;
next	1.408;
commitid	cEOOJNpETwLpvy1X;

1.408
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.407;
commitid	eYnPulzvLjDImPCa;

1.407
date	2015.11.18.13.58.02;	author mpi;	state Exp;
branches;
next	1.406;
commitid	uGqqOfOdbFUfC7aN;

1.406
date	2015.11.13.10.18.04;	author mpi;	state Exp;
branches;
next	1.405;
commitid	Ix3hlCTAP8RCy3Dw;

1.405
date	2015.11.11.10.23.23;	author mpi;	state Exp;
branches;
next	1.404;
commitid	HAbRB9Scbg3IhXig;

1.404
date	2015.11.07.12.42.19;	author mpi;	state Exp;
branches;
next	1.403;
commitid	3n9C29EcvMo1935D;

1.403
date	2015.11.06.17.55.55;	author mpi;	state Exp;
branches;
next	1.402;
commitid	rF3eCQCnoqyAKLl5;

1.402
date	2015.11.03.12.25.37;	author mpi;	state Exp;
branches;
next	1.401;
commitid	VW1I3YvD99VyOhRm;

1.401
date	2015.11.02.14.40.09;	author mpi;	state Exp;
branches;
next	1.400;
commitid	RcfM7kXINWo9mOSk;

1.400
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.399;
commitid	Ajb0hNGeCqGFHjjg;

1.399
date	2015.10.27.10.52.17;	author mpi;	state Exp;
branches;
next	1.398;
commitid	pUxjPEbAeKZSbuEi;

1.398
date	2015.10.25.21.58.04;	author deraadt;	state Exp;
branches;
next	1.397;
commitid	zIFdhqhVdzBRCSDm;

1.397
date	2015.10.25.13.52.45;	author mpi;	state Exp;
branches;
next	1.396;
commitid	4GpeYGglRwikDuJo;

1.396
date	2015.10.25.12.05.40;	author mpi;	state Exp;
branches;
next	1.395;
commitid	iXTa9MhdGfWGiTE6;

1.395
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.394;
commitid	G2nTzngqgXpQqcJB;

1.394
date	2015.10.24.10.52.05;	author reyk;	state Exp;
branches;
next	1.393;
commitid	PvSfHvj4AhI0uuuE;

1.393
date	2015.10.22.17.48.34;	author mpi;	state Exp;
branches;
next	1.392;
commitid	ToMJCJHoIWfUEPhu;

1.392
date	2015.10.22.16.44.54;	author mpi;	state Exp;
branches;
next	1.391;
commitid	jjvpHaNPWhqZPQGN;

1.391
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.390;
commitid	tp9bS9eCrwvRYjyO;

1.390
date	2015.10.22.10.46.26;	author mpi;	state Exp;
branches;
next	1.389;
commitid	OYvtLhWPHMjghKJk;

1.389
date	2015.10.12.13.17.58;	author dlg;	state Exp;
branches;
next	1.388;
commitid	jErEkfao8orfupjn;

1.388
date	2015.10.12.11.32.39;	author mpi;	state Exp;
branches;
next	1.387;
commitid	lZXo64tHFWipr7pT;

1.387
date	2015.10.12.10.49.40;	author dlg;	state Exp;
branches;
next	1.386;
commitid	dyvAr3xcUlJEXl4j;

1.386
date	2015.10.08.09.51.00;	author mpi;	state Exp;
branches;
next	1.385;
commitid	MGnToeZiq17iEMUe;

1.385
date	2015.10.05.19.05.09;	author uebayasi;	state Exp;
branches;
next	1.384;
commitid	KaQeg2gqRFHdXmok;

1.384
date	2015.10.05.15.57.27;	author uebayasi;	state Exp;
branches;
next	1.383;
commitid	6akt7VG8aLhHdJOU;

1.383
date	2015.10.05.15.39.01;	author uebayasi;	state Exp;
branches;
next	1.382;
commitid	WiJK83TPWMDW4G9S;

1.382
date	2015.09.30.11.33.51;	author dlg;	state Exp;
branches;
next	1.381;
commitid	d4upogI9re630Rga;

1.381
date	2015.09.27.16.50.03;	author stsp;	state Exp;
branches;
next	1.380;
commitid	Z03sNcTWKzvxcY9M;

1.380
date	2015.09.13.18.15.03;	author mpi;	state Exp;
branches;
next	1.379;
commitid	rJwZloxOcuZVmAkt;

1.379
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.378;
commitid	zZXiESHR0g5lNO0l;

1.378
date	2015.09.13.10.33.34;	author dlg;	state Exp;
branches;
next	1.377;
commitid	anqkC97EMPFGTrzY;

1.377
date	2015.09.13.09.58.03;	author kettenis;	state Exp;
branches;
next	1.376;
commitid	yv8xOji6j7Idb0Wm;

1.376
date	2015.09.12.20.26.06;	author mpi;	state Exp;
branches;
next	1.375;
commitid	UM7jfgLT8vWQUBm1;

1.375
date	2015.09.12.19.36.37;	author dlg;	state Exp;
branches;
next	1.374;
commitid	7l8qh8GXJTFWhxnD;

1.374
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.373;
commitid	LU3jSOpFfLxcllFL;

1.373
date	2015.09.11.16.58.00;	author mpi;	state Exp;
branches;
next	1.372;
commitid	aN3TroyZ9FVMndjv;

1.372
date	2015.09.11.09.15.56;	author dlg;	state Exp;
branches;
next	1.371;
commitid	Sc0M6RCDQ2hoJmVa;

1.371
date	2015.09.11.09.00.40;	author mpi;	state Exp;
branches;
next	1.370;
commitid	yPlE18jDnG7pU6wv;

1.370
date	2015.09.11.08.54.54;	author dlg;	state Exp;
branches;
next	1.369;
commitid	UjQQOvIFpMaSS5DS;

1.369
date	2015.09.10.18.11.05;	author dlg;	state Exp;
branches;
next	1.368;
commitid	g4iEvaKg78JqEZnW;

1.368
date	2015.09.10.16.41.30;	author mikeb;	state Exp;
branches;
next	1.367;
commitid	Dj2db8t0KelqURhl;

1.367
date	2015.09.10.14.06.43;	author dlg;	state Exp;
branches;
next	1.366;
commitid	SEqSARvBhlVp7H6M;

1.366
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.365;
commitid	JbEzJsyDrWqOW57C;

1.365
date	2015.09.10.06.00.37;	author dlg;	state Exp;
branches;
next	1.364;
commitid	pVTOMwev1CIYembV;

1.364
date	2015.09.09.16.01.10;	author dlg;	state Exp;
branches;
next	1.363;
commitid	K9CHsxd7Pm2AnGZf;

1.363
date	2015.09.01.04.56.55;	author dlg;	state Exp;
branches;
next	1.362;
commitid	Ut9HW2ADfQVVYvvI;

1.362
date	2015.08.30.10.39.16;	author mpi;	state Exp;
branches;
next	1.361;
commitid	avqdJydG8T8nvZhe;

1.361
date	2015.08.23.10.01.27;	author dlg;	state Exp;
branches;
next	1.360;
commitid	Vw5REHGES44JVlrI;

1.360
date	2015.08.18.08.48.36;	author mpi;	state Exp;
branches;
next	1.359;
commitid	wPy6rlOFqOcnyi3J;

1.359
date	2015.08.16.12.19.06;	author dlg;	state Exp;
branches;
next	1.358;
commitid	cLxNv7UAti3IL3sz;

1.358
date	2015.08.16.11.28.31;	author dlg;	state Exp;
branches;
next	1.357;
commitid	oSkBUHgUQqtaD8wU;

1.357
date	2015.08.13.07.19.58;	author mpi;	state Exp;
branches;
next	1.356;
commitid	GCkv70jAGN9x1uYY;

1.356
date	2015.07.29.00.04.03;	author rzalamena;	state Exp;
branches;
next	1.355;
commitid	9x7oePEcDKgC05vn;

1.355
date	2015.07.21.04.21.50;	author jca;	state Exp;
branches;
next	1.354;
commitid	Fb11VmEUGpHAP85A;

1.354
date	2015.07.20.22.54.29;	author mpi;	state Exp;
branches;
next	1.353;
commitid	kUJLGGhKrehg9sRa;

1.353
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.352;
commitid	t2fhFUpUuj89g4Sj;

1.352
date	2015.07.18.16.10.03;	author mpi;	state Exp;
branches;
next	1.351;
commitid	Sl1WPvv0PIS5U5VK;

1.351
date	2015.07.18.15.51.16;	author mpi;	state Exp;
branches;
next	1.350;
commitid	lwQKRpFyNEr7kjoF;

1.350
date	2015.07.16.15.31.35;	author mpi;	state Exp;
branches;
next	1.349;
commitid	syrAtzfOhwI3Ygjb;

1.349
date	2015.07.02.15.16.57;	author mpi;	state Exp;
branches;
next	1.348;
commitid	NmSSHdQB6wwXPBPP;

1.348
date	2015.07.02.09.40.02;	author mpi;	state Exp;
branches;
next	1.347;
commitid	eKXa0TkOIth1tkBS;

1.347
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.346;
commitid	fE8TgA9vpwdUU5Wy;

1.346
date	2015.06.29.10.32.29;	author dlg;	state Exp;
branches;
next	1.345;
commitid	rqyNfIORa1UIJQnb;

1.345
date	2015.06.25.09.20.20;	author mpi;	state Exp;
branches;
next	1.344;
commitid	qTf6nSNIg5TdnuJD;

1.344
date	2015.06.25.09.10.15;	author mpi;	state Exp;
branches;
next	1.343;
commitid	YVZmr3fTlWxhsbkr;

1.343
date	2015.06.24.09.56.51;	author mpi;	state Exp;
branches;
next	1.342;
commitid	593ZlqbgdX2pDqnC;

1.342
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.341;
commitid	MVWrtktB46JRxFWT;

1.341
date	2015.06.23.09.42.23;	author mpi;	state Exp;
branches;
next	1.340;
commitid	p9JxIlTsQMWvTdAT;

1.340
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.339;
commitid	h7z8lokZ0dFyuWpg;

1.339
date	2015.06.09.14.57.30;	author mpi;	state Exp;
branches;
next	1.338;
commitid	bYQPWW0FBnnUtxvG;

1.338
date	2015.06.07.12.02.28;	author jsg;	state Exp;
branches;
next	1.337;
commitid	st7eUqjf7vKTD48M;

1.337
date	2015.06.03.22.01.07;	author mikeb;	state Exp;
branches;
next	1.336;
commitid	NOSw6KKodXTR8bqw;

1.336
date	2015.06.02.13.23.55;	author mpi;	state Exp;
branches;
next	1.335;
commitid	XBDvq1RY2L1Yg3J3;

1.335
date	2015.05.26.11.39.07;	author mpi;	state Exp;
branches;
next	1.334;
commitid	VJjEISzzvhOYKF2A;

1.334
date	2015.05.26.11.36.26;	author dlg;	state Exp;
branches;
next	1.333;
commitid	XIDnUp3itFSZuopj;

1.333
date	2015.05.20.08.28.54;	author mpi;	state Exp;
branches;
next	1.332;
commitid	fTNkviHPk3FLJmC5;

1.332
date	2015.05.19.11.09.24;	author mpi;	state Exp;
branches;
next	1.331;
commitid	i7YRRkkCxLwyGmml;

1.331
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.330;
commitid	1aiWjheMGhmTuiHL;

1.330
date	2015.04.23.09.45.24;	author dlg;	state Exp;
branches;
next	1.329;
commitid	BpkIGymqTMK3ZEHF;

1.329
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.328;
commitid	c7ei8kPelCOOwHXy;

1.328
date	2015.04.10.08.48.24;	author mpi;	state Exp;
branches;
next	1.327;
commitid	izQrYBwx0zII1gXv;

1.327
date	2015.04.07.10.46.20;	author mpi;	state Exp;
branches;
next	1.326;
commitid	m3c6YErI0cVMQeYc;

1.326
date	2015.04.02.09.46.01;	author kettenis;	state Exp;
branches;
next	1.325;
commitid	5VsHL0t0kZjvsR2g;

1.325
date	2015.04.01.04.00.55;	author dlg;	state Exp;
branches;
next	1.324;
commitid	CU8KSAkGLLJrGHM7;

1.324
date	2015.03.29.01.05.02;	author dlg;	state Exp;
branches;
next	1.323;
commitid	syYjLHm5RzPuomAD;

1.323
date	2015.03.25.11.49.02;	author dlg;	state Exp;
branches;
next	1.322;
commitid	aTZxHMVtTVBgDDyD;

1.322
date	2015.03.18.12.23.15;	author dlg;	state Exp;
branches;
next	1.321;
commitid	veRr3qZI7HBatTwk;

1.321
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.320;
commitid	p4LJxGKbi0BU2cG6;

1.320
date	2015.03.03.07.54.32;	author brad;	state Exp;
branches;
next	1.319;
commitid	XOowedyrkVZGPW7M;

1.319
date	2015.02.09.03.09.57;	author dlg;	state Exp;
branches;
next	1.318;
commitid	fE9MPAUoNdw8sZYO;

1.318
date	2015.02.09.00.21.58;	author dlg;	state Exp;
branches;
next	1.317;
commitid	APj0QFdmnmGzZark;

1.317
date	2015.02.08.06.00.52;	author mpi;	state Exp;
branches;
next	1.316;
commitid	LWJ12V7CpWdalkDf;

1.316
date	2015.02.05.10.28.50;	author henning;	state Exp;
branches;
next	1.315;
commitid	TJYvWJ0xx6KGBaEc;

1.315
date	2015.01.27.10.31.19;	author mpi;	state Exp;
branches;
next	1.314;
commitid	5QOPq50YTGxsLtYH;

1.314
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.313;
commitid	MyKPm9Q3dQu92BiX;

1.313
date	2015.01.21.02.23.14;	author guenther;	state Exp;
branches;
next	1.312;
commitid	z0tt692wWLCZ7FbG;

1.312
date	2015.01.14.00.37.19;	author bluhm;	state Exp;
branches;
next	1.311;
commitid	WjHrn3jnezGLdK7X;

1.311
date	2015.01.10.11.43.37;	author mpi;	state Exp;
branches;
next	1.310;
commitid	wic8NM5ErVdwMnNC;

1.310
date	2015.01.06.21.26.46;	author stsp;	state Exp;
branches;
next	1.309;
commitid	jH0HZyR3DaPVl7Rm;

1.309
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.308;
commitid	zhW8jJrfVCoAthrR;

1.308
date	2014.12.18.15.29.30;	author krw;	state Exp;
branches;
next	1.307;
commitid	IHhdyKKaQ2noLfVl;

1.307
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.306;
commitid	Vq8oSnWLkf7dyy0N;

1.306
date	2014.12.08.10.46.14;	author mpi;	state Exp;
branches;
next	1.305;
commitid	ExaN0TCQ4X0c1lo6;

1.305
date	2014.12.01.15.06.54;	author mikeb;	state Exp;
branches;
next	1.304;
commitid	oohxazEA8Jchx2XI;

1.304
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.303;
commitid	mdGXHklUZmESVFlY;

1.303
date	2014.11.03.11.02.08;	author mpi;	state Exp;
branches;
next	1.302;
commitid	O0BO9I0Du13IOru3;

1.302
date	2014.10.08.12.37.57;	author mpi;	state Exp;
branches;
next	1.301;
commitid	h1cd9oCe5uRQO6my;

1.301
date	2014.09.30.08.27.57;	author mpi;	state Exp;
branches;
next	1.300;
commitid	VSf5u5dqa550s4de;

1.300
date	2014.08.25.14.00.34;	author florian;	state Exp;
branches;
next	1.299;
commitid	fUNtd3qRJAn6fam0;

1.299
date	2014.08.14.11.38.14;	author mikeb;	state Exp;
branches;
next	1.298;
commitid	AXxPGq02qqIqEwV8;

1.298
date	2014.08.11.13.51.07;	author mpi;	state Exp;
branches;
next	1.297;
commitid	a2PeiXPSryHFEtwq;

1.297
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.296;
commitid	B4dZSbxas1X1IpXI;

1.296
date	2014.07.12.16.10.04;	author henning;	state Exp;
branches;
next	1.295;
commitid	viBFNpQ0tmlW886b;

1.295
date	2014.07.11.21.54.38;	author tedu;	state Exp;
branches;
next	1.294;
commitid	0n9cIGBISFAEt4b1;

1.294
date	2014.07.08.07.10.12;	author dlg;	state Exp;
branches;
next	1.293;
commitid	LjJqbuphCuSi7amX;

1.293
date	2014.07.08.04.02.14;	author dlg;	state Exp;
branches;
next	1.292;
commitid	1jRrZP5Li2zmiVEq;

1.292
date	2014.06.26.13.08.25;	author mpi;	state Exp;
branches;
next	1.291;
commitid	8i8VaO1EEFXK0ftu;

1.291
date	2014.06.23.18.51.15;	author henning;	state Exp;
branches;
next	1.290;
commitid	SQAhA0BfLgxAmXM6;

1.290
date	2014.06.07.11.04.14;	author henning;	state Exp;
branches;
next	1.289;
commitid	3AS3WOjnaTtfOf9y;

1.289
date	2014.05.16.08.21.54;	author mpi;	state Exp;
branches;
next	1.288;

1.288
date	2014.05.13.14.33.25;	author claudio;	state Exp;
branches;
next	1.287;

1.287
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.286;

1.286
date	2014.04.22.12.35.00;	author mpi;	state Exp;
branches;
next	1.285;

1.285
date	2014.04.20.11.25.18;	author claudio;	state Exp;
branches;
next	1.284;

1.284
date	2014.04.19.12.27.59;	author henning;	state Exp;
branches;
next	1.283;

1.283
date	2014.04.10.13.47.21;	author mpi;	state Exp;
branches;
next	1.282;

1.282
date	2014.03.20.13.19.06;	author mpi;	state Exp;
branches;
next	1.281;

1.281
date	2014.03.19.13.49.12;	author mpi;	state Exp;
branches;
next	1.280;

1.280
date	2014.02.04.01.04.03;	author tedu;	state Exp;
branches;
next	1.279;

1.279
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.278;

1.278
date	2013.11.27.08.34.40;	author mpi;	state Exp;
branches;
next	1.277;

1.277
date	2013.11.19.09.00.43;	author mpi;	state Exp;
branches;
next	1.276;

1.276
date	2013.11.18.09.16.30;	author mpi;	state Exp;
branches;
next	1.275;

1.275
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.274;

1.274
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.273;

1.273
date	2013.10.21.08.44.13;	author phessler;	state Exp;
branches;
next	1.272;

1.272
date	2013.10.20.13.21.56;	author claudio;	state Exp;
branches;
next	1.271;

1.271
date	2013.10.19.14.54.18;	author mikeb;	state Exp;
branches;
next	1.270;

1.270
date	2013.10.19.14.05.14;	author reyk;	state Exp;
branches;
next	1.269;

1.269
date	2013.10.19.11.11.24;	author mpi;	state Exp;
branches;
next	1.268;

1.268
date	2013.10.17.16.27.40;	author bluhm;	state Exp;
branches;
next	1.267;

1.267
date	2013.10.09.09.33.42;	author mpi;	state Exp;
branches;
next	1.266;

1.266
date	2013.09.17.13.34.17;	author mpi;	state Exp;
branches;
next	1.265;

1.265
date	2013.09.12.09.52.46;	author mpi;	state Exp;
branches;
next	1.264;

1.264
date	2013.08.28.07.38.50;	author mpi;	state Exp;
branches;
next	1.263;

1.263
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.262;

1.262
date	2013.08.20.09.14.22;	author mpi;	state Exp;
branches;
next	1.261;

1.261
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.260;

1.260
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.259;

1.259
date	2013.06.18.22.42.56;	author uebayasi;	state Exp;
branches;
next	1.258;

1.258
date	2013.04.02.08.54.37;	author mpi;	state Exp;
branches;
next	1.257;

1.257
date	2013.03.29.12.20.34;	author bluhm;	state Exp;
branches;
next	1.256;

1.256
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.255;

1.255
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.254;

1.254
date	2013.03.28.12.06.55;	author mpi;	state Exp;
branches;
next	1.253;

1.253
date	2013.03.26.13.19.25;	author mpi;	state Exp;
branches;
next	1.252;

1.252
date	2013.03.20.10.34.12;	author mpi;	state Exp;
branches;
next	1.251;

1.251
date	2013.03.15.20.45.34;	author tedu;	state Exp;
branches;
next	1.250;

1.250
date	2013.03.07.09.40.19;	author mpi;	state Exp;
branches;
next	1.249;

1.249
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.248;

1.248
date	2012.11.23.20.12.03;	author sthen;	state Exp;
branches;
next	1.247;

1.247
date	2012.10.23.17.41.00;	author claudio;	state Exp;
branches;
next	1.246;

1.246
date	2012.10.18.00.36.21;	author deraadt;	state Exp;
branches;
next	1.245;

1.245
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.244;

1.244
date	2012.09.19.16.14.01;	author blambert;	state Exp;
branches;
next	1.243;

1.243
date	2012.09.19.12.35.07;	author blambert;	state Exp;
branches;
next	1.242;

1.242
date	2012.09.18.08.16.33;	author blambert;	state Exp;
branches;
next	1.241;

1.241
date	2012.01.03.23.41.51;	author bluhm;	state Exp;
branches;
next	1.240;

1.240
date	2011.10.24.17.51.31;	author camield;	state Exp;
branches;
next	1.239;

1.239
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.238;

1.238
date	2011.07.08.18.48.51;	author henning;	state Exp;
branches;
next	1.237;

1.237
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.236;

1.236
date	2011.07.05.00.58.27;	author henning;	state Exp;
branches;
next	1.235;

1.235
date	2011.07.04.22.53.53;	author tedu;	state Exp;
branches;
next	1.234;

1.234
date	2011.03.13.15.31.41;	author stsp;	state Exp;
branches;
next	1.233;

1.233
date	2011.01.25.05.44.05;	author tedu;	state Exp;
branches;
next	1.232;

1.232
date	2011.01.18.19.10.25;	author bluhm;	state Exp;
branches;
next	1.231;

1.231
date	2010.11.29.19.38.59;	author miod;	state Exp;
branches;
next	1.230;

1.230
date	2010.11.17.19.43.23;	author henning;	state Exp;
branches;
next	1.229;

1.229
date	2010.11.17.19.40.55;	author henning;	state Exp;
branches;
next	1.228;

1.228
date	2010.11.17.19.34.49;	author henning;	state Exp;
branches;
next	1.227;

1.227
date	2010.11.17.18.51.57;	author henning;	state Exp;
branches;
next	1.226;

1.226
date	2010.10.25.11.33.06;	author blambert;	state Exp;
branches;
next	1.225;

1.225
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.224;

1.224
date	2010.08.25.14.07.24;	author claudio;	state Exp;
branches;
next	1.223;

1.223
date	2010.08.25.13.57.07;	author claudio;	state Exp;
branches;
next	1.222;

1.222
date	2010.08.25.13.06.09;	author claudio;	state Exp;
branches;
next	1.221;

1.221
date	2010.08.24.16.13.32;	author claudio;	state Exp;
branches;
next	1.220;

1.220
date	2010.08.24.16.00.16;	author claudio;	state Exp;
branches;
next	1.219;

1.219
date	2010.07.31.20.48.32;	author blambert;	state Exp;
branches;
next	1.218;

1.218
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.217;

1.217
date	2010.06.29.21.28.37;	author reyk;	state Exp;
branches;
next	1.216;

1.216
date	2010.05.28.12.09.09;	author claudio;	state Exp;
branches;
next	1.215;

1.215
date	2010.05.08.11.07.20;	author stsp;	state Exp;
branches;
next	1.214;

1.214
date	2010.04.25.17.38.53;	author mpf;	state Exp;
branches;
next	1.213;

1.213
date	2010.04.17.18.31.41;	author stsp;	state Exp;
branches;
next	1.212;

1.212
date	2010.04.17.17.46.32;	author deraadt;	state Exp;
branches;
next	1.211;

1.211
date	2010.03.08.21.00.27;	author henning;	state Exp;
branches;
next	1.210;

1.210
date	2010.03.08.20.52.52;	author henning;	state Exp;
branches;
next	1.209;

1.209
date	2010.03.08.20.29.41;	author henning;	state Exp;
branches;
next	1.208;

1.208
date	2010.03.05.13.52.23;	author henning;	state Exp;
branches;
next	1.207;

1.207
date	2010.01.13.02.29.51;	author henning;	state Exp;
branches;
next	1.206;

1.206
date	2010.01.13.02.26.49;	author henning;	state Exp;
branches;
next	1.205;

1.205
date	2010.01.13.02.13.12;	author henning;	state Exp;
branches;
next	1.204;

1.204
date	2010.01.12.04.05.47;	author deraadt;	state Exp;
branches;
next	1.203;

1.203
date	2010.01.08.19.21.19;	author stsp;	state Exp;
branches;
next	1.202;

1.202
date	2009.12.13.09.41.04;	author jsing;	state Exp;
branches;
next	1.201;

1.201
date	2009.11.21.14.08.14;	author claudio;	state Exp;
branches;
next	1.200;

1.200
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.199;

1.199
date	2009.08.12.15.58.20;	author henning;	state Exp;
branches;
next	1.198;

1.198
date	2009.08.10.11.22.10;	author deraadt;	state Exp;
branches;
next	1.197;

1.197
date	2009.07.09.06.40.20;	author blambert;	state Exp;
branches;
next	1.196;

1.196
date	2009.06.06.12.31.17;	author rainer;	state Exp;
branches;
next	1.195;

1.195
date	2009.06.05.03.10.28;	author halex;	state Exp;
branches;
next	1.194;

1.194
date	2009.06.05.00.05.21;	author claudio;	state Exp;
branches;
next	1.193;

1.193
date	2009.06.04.19.07.21;	author henning;	state Exp;
branches;
next	1.192;

1.192
date	2009.06.01.17.49.11;	author claudio;	state Exp;
branches;
next	1.191;

1.191
date	2009.05.31.20.22.18;	author blambert;	state Exp;
branches;
next	1.190;

1.190
date	2009.05.31.04.07.03;	author claudio;	state Exp;
branches;
next	1.189;

1.189
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.188;

1.188
date	2009.02.24.21.14.12;	author claudio;	state Exp;
branches;
next	1.187;

1.187
date	2009.01.31.21.23.34;	author grange;	state Exp;
branches;
next	1.186;

1.186
date	2009.01.09.04.41.02;	author david;	state Exp;
branches;
next	1.185;

1.185
date	2008.12.12.22.07.33;	author claudio;	state Exp;
branches;
next	1.184;

1.184
date	2008.12.11.16.45.45;	author deraadt;	state Exp;
branches;
next	1.183;

1.183
date	2008.11.26.19.07.33;	author deraadt;	state Exp;
branches;
next	1.182;

1.182
date	2008.11.26.17.36.23;	author dlg;	state Exp;
branches;
next	1.181;

1.181
date	2008.11.25.16.32.41;	author dlg;	state Exp;
branches;
next	1.180;

1.180
date	2008.11.25.15.43.32;	author dlg;	state Exp;
branches;
next	1.179;

1.179
date	2008.11.25.12.47.00;	author deraadt;	state Exp;
branches;
next	1.178;

1.178
date	2008.11.25.12.07.55;	author claudio;	state Exp;
branches;
next	1.177;

1.177
date	2008.11.24.12.57.37;	author dlg;	state Exp;
branches;
next	1.176;

1.176
date	2008.11.24.12.53.53;	author claudio;	state Exp;
branches;
next	1.175;

1.175
date	2008.11.21.18.01.30;	author claudio;	state Exp;
branches;
next	1.174;

1.174
date	2008.11.10.18.08.42;	author claudio;	state Exp;
branches;
next	1.173;

1.173
date	2008.06.12.16.15.05;	author claudio;	state Exp;
branches
	1.173.2.1;
next	1.172;

1.172
date	2008.06.08.20.27.23;	author claudio;	state Exp;
branches;
next	1.171;

1.171
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.170;

1.170
date	2008.05.07.05.51.12;	author mpf;	state Exp;
branches;
next	1.169;

1.169
date	2008.04.10.23.15.45;	author dlg;	state Exp;
branches;
next	1.168;

1.168
date	2008.01.05.19.08.19;	author henning;	state Exp;
branches;
next	1.167;

1.167
date	2008.01.05.07.26.04;	author deraadt;	state Exp;
branches;
next	1.166;

1.166
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.165;

1.165
date	2007.07.06.14.00.59;	author naddy;	state Exp;
branches
	1.165.2.1;
next	1.164;

1.164
date	2007.07.04.12.15.53;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2007.06.17.21.01.32;	author henning;	state Exp;
branches;
next	1.162;

1.162
date	2007.06.14.18.31.49;	author reyk;	state Exp;
branches;
next	1.161;

1.161
date	2007.06.08.09.31.38;	author henning;	state Exp;
branches;
next	1.160;

1.160
date	2007.06.06.10.04.36;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2007.05.29.02.21.18;	author claudio;	state Exp;
branches;
next	1.158;

1.158
date	2007.05.28.08.48.15;	author mcbride;	state Exp;
branches;
next	1.157;

1.157
date	2007.03.25.18.26.23;	author mpf;	state Exp;
branches;
next	1.156;

1.156
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.155;

1.155
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.154;

1.154
date	2007.02.12.22.36.47;	author mpf;	state Exp;
branches;
next	1.153;

1.153
date	2006.12.03.13.41.19;	author reyk;	state Exp;
branches;
next	1.152;

1.152
date	2006.11.24.20.57.46;	author canacar;	state Exp;
branches;
next	1.151;

1.151
date	2006.11.16.13.09.27;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2006.10.21.14.02.11;	author henning;	state Exp;
branches;
next	1.149;

1.149
date	2006.08.29.17.19.43;	author henning;	state Exp;
branches
	1.149.2.1;
next	1.148;

1.148
date	2006.07.18.09.23.43;	author mickey;	state Exp;
branches;
next	1.147;

1.147
date	2006.06.02.19.53.12;	author mpf;	state Exp;
branches;
next	1.146;

1.146
date	2006.03.22.14.37.44;	author henning;	state Exp;
branches;
next	1.145;

1.145
date	2006.03.20.10.03.49;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.143;

1.143
date	2006.02.09.00.05.55;	author reyk;	state Exp;
branches
	1.143.2.1;
next	1.142;

1.142
date	2006.01.05.03.28.34;	author deraadt;	state Exp;
branches;
next	1.141;

1.141
date	2005.12.22.23.55.18;	author canacar;	state Exp;
branches;
next	1.140;

1.140
date	2005.11.29.02.59.42;	author jolan;	state Exp;
branches;
next	1.139;

1.139
date	2005.11.27.16.22.45;	author henning;	state Exp;
branches;
next	1.138;

1.138
date	2005.11.25.13.45.02;	author henning;	state Exp;
branches;
next	1.137;

1.137
date	2005.07.04.09.52.33;	author henning;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2005.06.23.14.30.40;	author mickey;	state Exp;
branches;
next	1.135;

1.135
date	2005.06.14.04.00.38;	author henning;	state Exp;
branches;
next	1.134;

1.134
date	2005.06.13.21.02.21;	author henning;	state Exp;
branches;
next	1.133;

1.133
date	2005.06.12.00.41.33;	author henning;	state Exp;
branches;
next	1.132;

1.132
date	2005.06.08.07.36.50;	author henning;	state Exp;
branches;
next	1.131;

1.131
date	2005.06.08.06.58.11;	author henning;	state Exp;
branches;
next	1.130;

1.130
date	2005.06.08.00.14.45;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2005.06.08.00.13.19;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2005.06.07.18.21.44;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2005.06.07.02.45.11;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2005.06.06.03.44.21;	author henning;	state Exp;
branches;
next	1.125;

1.125
date	2005.06.06.03.05.05;	author henning;	state Exp;
branches;
next	1.124;

1.124
date	2005.06.05.20.49.25;	author henning;	state Exp;
branches;
next	1.123;

1.123
date	2005.05.26.04.07.45;	author henning;	state Exp;
branches;
next	1.122;

1.122
date	2005.05.26.03.44.27;	author henning;	state Exp;
branches;
next	1.121;

1.121
date	2005.05.26.03.13.41;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2005.05.26.03.11.59;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2005.05.25.06.50.05;	author henning;	state Exp;
branches;
next	1.118;

1.118
date	2005.05.24.06.48.49;	author reyk;	state Exp;
branches;
next	1.117;

1.117
date	2005.05.24.04.20.25;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2005.05.24.02.49.34;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2005.05.24.02.45.17;	author reyk;	state Exp;
branches;
next	1.114;

1.114
date	2005.05.24.02.26.04;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2005.05.22.21.06.02;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2005.05.22.18.23.04;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2005.05.21.21.24.38;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2005.05.21.21.03.57;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2005.05.09.08.08.47;	author mpf;	state Exp;
branches;
next	1.108;

1.108
date	2005.04.28.10.38.55;	author pascoe;	state Exp;
branches;
next	1.107;

1.107
date	2005.04.20.23.00.41;	author mpf;	state Exp;
branches;
next	1.106;

1.106
date	2005.04.05.12.19.37;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2005.03.30.02.55.36;	author tedu;	state Exp;
branches;
next	1.104;

1.104
date	2005.02.07.15.00.16;	author mcbride;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2005.01.18.22.10.10;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2005.01.14.12.04.02;	author grange;	state Exp;
branches;
next	1.101;

1.101
date	2005.01.14.11.49.01;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2004.12.20.07.24.38;	author pascoe;	state Exp;
branches;
next	1.99;

1.99
date	2004.12.08.07.02.16;	author mcbride;	state Exp;
branches;
next	1.98;

1.98
date	2004.12.08.06.57.55;	author mcbride;	state Exp;
branches;
next	1.97;

1.97
date	2004.12.07.20.38.46;	author mcbride;	state Exp;
branches;
next	1.96;

1.96
date	2004.12.07.19.26.46;	author mcbride;	state Exp;
branches;
next	1.95;

1.95
date	2004.12.04.16.16.45;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2004.12.03.17.31.03;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2004.10.14.21.28.15;	author mickey;	state Exp;
branches;
next	1.92;

1.92
date	2004.10.11.10.13.49;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2004.09.15.17.46.44;	author grange;	state Exp;
branches;
next	1.90;

1.90
date	2004.06.26.17.36.32;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2004.06.25.18.24.23;	author pb;	state Exp;
branches;
next	1.88;

1.88
date	2004.05.29.17.54.45;	author jcs;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.28.01.20.29;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2004.04.28.00.28.43;	author mcbride;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.17.00.09.01;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2004.02.28.09.14.10;	author mcbride;	state Exp;
branches;
next	1.83;

1.83
date	2004.02.08.19.46.10;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2004.01.15.10.47.55;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2004.01.09.10.44.32;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2003.12.31.11.18.25;	author cedric;	state Exp;
branches;
next	1.79;

1.79
date	2003.12.16.20.33.24;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.77;

1.77
date	2003.12.10.03.30.21;	author itojun;	state Exp;
branches;
next	1.76;

1.76
date	2003.12.08.09.09.03;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2003.12.03.13.27.36;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2003.12.03.11.01.43;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2003.11.06.21.09.34;	author mickey;	state Exp;
branches;
next	1.72;

1.72
date	2003.10.17.21.04.58;	author mcbride;	state Exp;
branches;
next	1.71;

1.71
date	2003.10.01.05.06.06;	author itojun;	state Exp;
branches;
next	1.70;

1.70
date	2003.08.27.00.33.34;	author henric;	state Exp;
branches;
next	1.69;

1.69
date	2003.08.25.08.18.54;	author fgsch;	state Exp;
branches;
next	1.68;

1.68
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2003.07.23.22.48.00;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2003.05.12.00.48.52;	author jason;	state Exp;
branches;
next	1.64;

1.64
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.30.13.04.35;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.11.04.26.17;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.08.12.02.09;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.08.11.53.29;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.30.05.07.17;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.29.02.51.37;	author itojun;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.27.13.42.16;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2002.05.27.02.59.40;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.24.16.42.59;	author dhartmei;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.24.00.51.51;	author dhartmei;	state Exp;
branches;
next	1.51;

1.51
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2001.12.09.12.57.26;	author jason;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2001.06.29.22.46.05;	author fgsch;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.27.05.50.06;	author kjc;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.22.14.28.58;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.15.03.38.33;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.08.04.19.25;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.30.02.12.24;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.20.13.50.53;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.13.19.49.32;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.30.04.22.24;	author kjell;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.19.06.37.36;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.17.04.47.18;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.07.03.43.16;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.05.02.12.51;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.04.23.17.27;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.20.06.49.04;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.18.00.14.27;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.17.20.36.36;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.17.20.30.34;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.05.07.58.15;	author itojun;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.03.22.11.28.42;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2000.03.21.23.31.26;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2000.03.12.03.54.43;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.02.05.28.24;	author deraadt;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	99.12.18.22.03.43;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	99.11.20.18.51.58;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	99.11.09.17.49.01;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	99.10.27.16.36.25;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.08.08.14.59.02;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.07.04.20.39.28;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.08.05.19.51.06;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.08.04.20.57.19;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.03.25.07.37.29;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.12.31.04.09.32;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.07.11.23.43.00;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.07.11.23.37.52;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	96.08.03.17.50.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.07.02.06.52.05;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.06.29.18.54.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.10.12.31.07;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.09.11.10.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.28.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.14.08.35.35;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.03.05.02.29.37;	author dm;	state Exp;
branches;
next	1.4;

1.4
date	96.03.03.21.07.04;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.04.20.48.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.03.20.06.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches;
next	;

1.27.2.1
date	2000.03.24.09.09.31;	author niklas;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2001.05.14.22.39.59;	author niklas;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2001.07.04.10.53.53;	author niklas;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.27.2.5;

1.27.2.5
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.27.2.6;

1.27.2.6
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.27.2.7;

1.27.2.7
date	2003.05.13.19.36.14;	author ho;	state Exp;
branches;
next	1.27.2.8;

1.27.2.8
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.27.2.9;

1.27.2.9
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.27.2.10;

1.27.2.10
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.31.2.1
date	2000.10.21.05.41.41;	author jason;	state Exp;
branches;
next	;

1.50.2.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.50.2.3;

1.50.2.3
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;

1.104.2.1
date	2006.01.26.20.43.21;	author brad;	state Exp;
branches;
next	;

1.137.2.1
date	2006.01.26.20.52.57;	author brad;	state Exp;
branches;
next	;

1.143.2.1
date	2007.03.28.19.47.57;	author henning;	state Exp;
branches;
next	;

1.149.2.1
date	2007.03.28.19.45.48;	author henning;	state Exp;
branches;
next	;

1.165.2.1
date	2008.01.11.12.41.26;	author henning;	state Exp;
branches;
next	;

1.173.2.1
date	2008.11.14.02.21.15;	author brad;	state Exp;
branches;
next	;


desc
@@


1.492
log
@Replace an expensive microtime call with a getmicrotime for if_lastchange
reducing its resolution to 10ms.

ok florian, mpi
@
text
@/*	$OpenBSD: if.c,v 1.491 2017/03/17 17:19:16 mpi Exp $	*/
/*	$NetBSD: if.c,v 1.35 1996/05/07 05:26:04 thorpej Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if.c	8.3 (Berkeley) 1/4/94
 */

#include "bpfilter.h"
#include "bridge.h"
#include "carp.h"
#include "ether.h"
#include "pf.h"
#include "pfsync.h"
#include "ppp.h"
#include "pppoe.h"
#include "switch.h"
#include "trunk.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/timeout.h>
#include <sys/protosw.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/domain.h>
#include <sys/sysctl.h>
#include <sys/task.h>
#include <sys/atomic.h>
#include <sys/proc.h>

#include <dev/rndvar.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/igmp.h>
#ifdef MROUTING
#include <netinet/ip_mroute.h>
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet6/in6_ifattach.h>
#include <netinet6/nd6.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

#ifdef MPLS
#include <netmpls/mpls.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#if NBRIDGE > 0
#include <net/if_bridge.h>
#endif

#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#endif

void	if_attachsetup(struct ifnet *);
void	if_attachdomain(struct ifnet *);
void	if_attach_common(struct ifnet *);
int	if_setrdomain(struct ifnet *, int);
void	if_slowtimo(void *);

void	if_detached_qstart(struct ifqueue *);
int	if_detached_ioctl(struct ifnet *, u_long, caddr_t);

int	if_getgroup(caddr_t, struct ifnet *);
int	if_getgroupmembers(caddr_t);
int	if_getgroupattribs(caddr_t);
int	if_setgroupattribs(caddr_t);

void	if_linkstate(struct ifnet *);
void	if_linkstate_task(void *);

int	if_clone_list(struct if_clonereq *);
struct if_clone	*if_clone_lookup(const char *, int *);

int	if_group_egress_build(void);

void	if_watchdog_task(void *);

void	if_input_process(void *);
void	if_netisr(void *);

#ifdef DDB
void	ifa_print_all(void);
#endif

void	if_qstart_compat(struct ifqueue *);

/*
 * interface index map
 *
 * the kernel maintains a mapping of interface indexes to struct ifnet
 * pointers.
 *
 * the map is an array of struct ifnet pointers prefixed by an if_map
 * structure. the if_map structure stores the length of its array.
 *
 * as interfaces are attached to the system, the map is grown on demand
 * up to USHRT_MAX entries.
 *
 * interface index 0 is reserved and represents no interface. this
 * supports the use of the interface index as the scope for IPv6 link
 * local addresses, where scope 0 means no scope has been specified.
 * it also supports the use of interface index as the unique identifier
 * for network interfaces in SNMP applications as per RFC2863. therefore
 * if_get(0) returns NULL.
 */

void if_ifp_dtor(void *, void *);
void if_map_dtor(void *, void *);
struct ifnet *if_ref(struct ifnet *);

/*
 * struct if_map
 *
 * bounded array of ifnet srp pointers used to fetch references of live
 * interfaces with if_get().
 */

struct if_map {
	unsigned long		 limit;
	/* followed by limit ifnet srp pointers */
};

/*
 * struct if_idxmap
 *
 * infrastructure to manage updates and accesses to the current if_map.
 */

struct if_idxmap {
	unsigned int		 serial;
	unsigned int		 count;
	struct srp		 map;
};

void	if_idxmap_init(unsigned int);
void	if_idxmap_insert(struct ifnet *);
void	if_idxmap_remove(struct ifnet *);

TAILQ_HEAD(, ifg_group) ifg_head = TAILQ_HEAD_INITIALIZER(ifg_head);
LIST_HEAD(, if_clone) if_cloners = LIST_HEAD_INITIALIZER(if_cloners);
int if_cloners_count;

struct timeout net_tick_to;
void	net_tick(void *);
int	net_livelocked(void);
int	ifq_congestion;

int		 netisr;
struct taskq	*softnettq;

struct task if_input_task_locked = TASK_INITIALIZER(if_netisr, NULL);

/*
 * Network interface utility routines.
 */
void
ifinit(void)
{
	/*
	 * most machines boot with 4 or 5 interfaces, so size the initial map
	 * to accomodate this
	 */
	if_idxmap_init(8);

	timeout_set(&net_tick_to, net_tick, &net_tick_to);

	softnettq = taskq_create("softnet", 1, IPL_NET, TASKQ_MPSAFE);
	if (softnettq == NULL)
		panic("unable to create softnet taskq");

	net_tick(&net_tick_to);
}

static struct if_idxmap if_idxmap = {
	0,
	0,
	SRP_INITIALIZER()
};

struct srp_gc if_ifp_gc = SRP_GC_INITIALIZER(if_ifp_dtor, NULL);
struct srp_gc if_map_gc = SRP_GC_INITIALIZER(if_map_dtor, NULL);

struct ifnet_head ifnet = TAILQ_HEAD_INITIALIZER(ifnet);

void
if_idxmap_init(unsigned int limit)
{
	struct if_map *if_map;
	struct srp *map;
	unsigned int i;

	if_idxmap.serial = 1; /* skip ifidx 0 so it can return NULL */

	if_map = malloc(sizeof(*if_map) + limit * sizeof(*map),
	    M_IFADDR, M_WAITOK);

	if_map->limit = limit;
	map = (struct srp *)(if_map + 1);
	for (i = 0; i < limit; i++)
		srp_init(&map[i]);

	/* this is called early so there's nothing to race with */
	srp_update_locked(&if_map_gc, &if_idxmap.map, if_map);
}

void
if_idxmap_insert(struct ifnet *ifp)
{
	struct if_map *if_map;
	struct srp *map;
	unsigned int index, i;

	refcnt_init(&ifp->if_refcnt);

	/* the kernel lock guarantees serialised modifications to if_idxmap */
	KERNEL_ASSERT_LOCKED();

	if (++if_idxmap.count > USHRT_MAX)
		panic("too many interfaces");

	if_map = srp_get_locked(&if_idxmap.map);
	map = (struct srp *)(if_map + 1);

	index = if_idxmap.serial++ & USHRT_MAX;

	if (index >= if_map->limit) {
		struct if_map *nif_map;
		struct srp *nmap;
		unsigned int nlimit;
		struct ifnet *nifp;

		nlimit = if_map->limit * 2;
		nif_map = malloc(sizeof(*nif_map) + nlimit * sizeof(*nmap),
		    M_IFADDR, M_WAITOK);
		nmap = (struct srp *)(nif_map + 1);

		nif_map->limit = nlimit;
		for (i = 0; i < if_map->limit; i++) {
			srp_init(&nmap[i]);
			nifp = srp_get_locked(&map[i]);
			if (nifp != NULL) {
				srp_update_locked(&if_ifp_gc, &nmap[i],
				    if_ref(nifp));
			}
		}

		while (i < nlimit) {
			srp_init(&nmap[i]);
			i++;
		}

		srp_update_locked(&if_map_gc, &if_idxmap.map, nif_map);
		if_map = nif_map;
		map = nmap;
	}

	/* pick the next free index */
	for (i = 0; i < USHRT_MAX; i++) {
		if (index != 0 && srp_get_locked(&map[index]) == NULL)
			break;

		index = if_idxmap.serial++ & USHRT_MAX;
	}

	/* commit */
	ifp->if_index = index;
	srp_update_locked(&if_ifp_gc, &map[index], if_ref(ifp));
}

void
if_idxmap_remove(struct ifnet *ifp)
{
	struct if_map *if_map;
	struct srp *map;
	unsigned int index;

	index = ifp->if_index;

	/* the kernel lock guarantees serialised modifications to if_idxmap */
	KERNEL_ASSERT_LOCKED();

	if_map = srp_get_locked(&if_idxmap.map);
	KASSERT(index < if_map->limit);

	map = (struct srp *)(if_map + 1);
	KASSERT(ifp == (struct ifnet *)srp_get_locked(&map[index]));

	srp_update_locked(&if_ifp_gc, &map[index], NULL);
	if_idxmap.count--;
	/* end of if_idxmap modifications */

	/* sleep until the last reference is released */
	refcnt_finalize(&ifp->if_refcnt, "ifidxrm");
}

void
if_ifp_dtor(void *null, void *ifp)
{
	if_put(ifp);
}

void
if_map_dtor(void *null, void *m)
{
	struct if_map *if_map = m;
	struct srp *map = (struct srp *)(if_map + 1);
	unsigned int i;

	/*
	 * dont need to serialize the use of update_locked since this is
	 * the last reference to this map. there's nothing to race against.
	 */
	for (i = 0; i < if_map->limit; i++)
		srp_update_locked(&if_ifp_gc, &map[i], NULL);

	free(if_map, M_IFADDR, sizeof(*if_map) + if_map->limit * sizeof(*map));
}

/*
 * Attach an interface to the
 * list of "active" interfaces.
 */
void
if_attachsetup(struct ifnet *ifp)
{
	unsigned long ifidx;

	splsoftassert(IPL_SOFTNET);

	TAILQ_INIT(&ifp->if_groups);

	if_addgroup(ifp, IFG_ALL);

	if_attachdomain(ifp);
#if NPF > 0
	pfi_attach_ifnet(ifp);
#endif

	timeout_set(ifp->if_slowtimo, if_slowtimo, ifp);
	if_slowtimo(ifp);

	if_idxmap_insert(ifp);
	KASSERT(if_get(0) == NULL);

	ifidx = ifp->if_index;

	mq_init(&ifp->if_inputqueue, 8192, IPL_NET);
	task_set(ifp->if_inputtask, if_input_process, (void *)ifidx);
	task_set(ifp->if_watchdogtask, if_watchdog_task, (void *)ifidx);
	task_set(ifp->if_linkstatetask, if_linkstate_task, (void *)ifidx);

	/* Announce the interface. */
	rtm_ifannounce(ifp, IFAN_ARRIVAL);
}

/*
 * Allocate the link level name for the specified interface.  This
 * is an attachment helper.  It must be called after ifp->if_addrlen
 * is initialized, which may not be the case when if_attach() is
 * called.
 */
void
if_alloc_sadl(struct ifnet *ifp)
{
	unsigned int socksize;
	int namelen, masklen;
	struct sockaddr_dl *sdl;

	/*
	 * If the interface already has a link name, release it
	 * now.  This is useful for interfaces that can change
	 * link types, and thus switch link names often.
	 */
	if (ifp->if_sadl != NULL)
		if_free_sadl(ifp);

	namelen = strlen(ifp->if_xname);
	masklen = offsetof(struct sockaddr_dl, sdl_data[0]) + namelen;
	socksize = masklen + ifp->if_addrlen;
#define ROUNDUP(a) (1 + (((a) - 1) | (sizeof(long) - 1)))
	if (socksize < sizeof(*sdl))
		socksize = sizeof(*sdl);
	socksize = ROUNDUP(socksize);
	sdl = malloc(socksize, M_IFADDR, M_WAITOK|M_ZERO);
	sdl->sdl_len = socksize;
	sdl->sdl_family = AF_LINK;
	bcopy(ifp->if_xname, sdl->sdl_data, namelen);
	sdl->sdl_nlen = namelen;
	sdl->sdl_alen = ifp->if_addrlen;
	sdl->sdl_index = ifp->if_index;
	sdl->sdl_type = ifp->if_type;
	ifp->if_sadl = sdl;
}

/*
 * Free the link level name for the specified interface.  This is
 * a detach helper.  This is called from if_detach() or from
 * link layer type specific detach functions.
 */
void
if_free_sadl(struct ifnet *ifp)
{
	free(ifp->if_sadl, M_IFADDR, 0);
	ifp->if_sadl = NULL;
}

void
if_attachdomain(struct ifnet *ifp)
{
	struct domain *dp;
	int i, s;

	s = splnet();

	/* address family dependent data region */
	bzero(ifp->if_afdata, sizeof(ifp->if_afdata));
	for (i = 0; (dp = domains[i]) != NULL; i++) {
		if (dp->dom_ifattach)
			ifp->if_afdata[dp->dom_family] =
			    (*dp->dom_ifattach)(ifp);
	}

	splx(s);
}

void
if_attachhead(struct ifnet *ifp)
{
	int s;

	if_attach_common(ifp);
	NET_LOCK(s);
	TAILQ_INSERT_HEAD(&ifnet, ifp, if_list);
	if_attachsetup(ifp);
	NET_UNLOCK(s);
}

void
if_attach(struct ifnet *ifp)
{
	int s;

	if_attach_common(ifp);
	NET_LOCK(s);
	TAILQ_INSERT_TAIL(&ifnet, ifp, if_list);
	if_attachsetup(ifp);
	NET_UNLOCK(s);
}

void
if_attach_queues(struct ifnet *ifp, unsigned int nqs)
{
	struct ifqueue **map;
	struct ifqueue *ifq;
	int i;

	KASSERT(ifp->if_ifqs == ifp->if_snd.ifq_ifqs);
	KASSERT(nqs != 0);

	map = mallocarray(sizeof(*map), nqs, M_DEVBUF, M_WAITOK);

	ifp->if_snd.ifq_softc = NULL;
	map[0] = &ifp->if_snd;

	for (i = 1; i < nqs; i++) {
		ifq = malloc(sizeof(*ifq), M_DEVBUF, M_WAITOK|M_ZERO);
		ifq_set_maxlen(ifq, ifp->if_snd.ifq_maxlen);
		ifq_init(ifq, ifp, i);
		map[i] = ifq;
	}

	ifp->if_ifqs = map;
	ifp->if_nifqs = nqs;
}

void
if_attach_common(struct ifnet *ifp)
{
	TAILQ_INIT(&ifp->if_addrlist);
	TAILQ_INIT(&ifp->if_maddrlist);

	if (!ISSET(ifp->if_xflags, IFXF_MPSAFE)) {
		KASSERTMSG(ifp->if_qstart == NULL,
		    "%s: if_qstart set without MPSAFE set", ifp->if_xname);
		ifp->if_qstart = if_qstart_compat;
	} else {
		KASSERTMSG(ifp->if_start == NULL,
		    "%s: if_start set with MPSAFE set", ifp->if_xname);
		KASSERTMSG(ifp->if_qstart != NULL,
		    "%s: if_qstart not set with MPSAFE set", ifp->if_xname);
	}

	ifq_init(&ifp->if_snd, ifp, 0);

	ifp->if_snd.ifq_ifqs[0] = &ifp->if_snd;
	ifp->if_ifqs = ifp->if_snd.ifq_ifqs;
	ifp->if_nifqs = 1;

	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks),
	    M_TEMP, M_WAITOK);
	TAILQ_INIT(ifp->if_addrhooks);
	ifp->if_linkstatehooks = malloc(sizeof(*ifp->if_linkstatehooks),
	    M_TEMP, M_WAITOK);
	TAILQ_INIT(ifp->if_linkstatehooks);
	ifp->if_detachhooks = malloc(sizeof(*ifp->if_detachhooks),
	    M_TEMP, M_WAITOK);
	TAILQ_INIT(ifp->if_detachhooks);

	if (ifp->if_rtrequest == NULL)
		ifp->if_rtrequest = if_rtrequest_dummy;
	ifp->if_slowtimo = malloc(sizeof(*ifp->if_slowtimo), M_TEMP,
	    M_WAITOK|M_ZERO);
	ifp->if_watchdogtask = malloc(sizeof(*ifp->if_watchdogtask),
	    M_TEMP, M_WAITOK|M_ZERO);
	ifp->if_linkstatetask = malloc(sizeof(*ifp->if_linkstatetask),
	    M_TEMP, M_WAITOK|M_ZERO);
	ifp->if_inputtask = malloc(sizeof(*ifp->if_inputtask),
	    M_TEMP, M_WAITOK|M_ZERO);
	ifp->if_llprio = IFQ_DEFPRIO;

	SRPL_INIT(&ifp->if_inputs);
}

void
if_attach_ifq(struct ifnet *ifp, const struct ifq_ops *newops, void *args)
{
	/*
	 * only switch the ifq_ops on the first ifq on an interface.
	 *
	 * the only ifq_ops we provide priq and hfsc, and hfsc only
	 * works on a single ifq. because the code uses the ifq_ops
	 * on the first ifq (if_snd) to select a queue for an mbuf,
	 * by switching only the first one we change both the algorithm
	 * and force the routing of all new packets to it.
	 */
	ifq_attach(&ifp->if_snd, newops, args);
}

void
if_start(struct ifnet *ifp)
{
	KASSERT(ifp->if_qstart == if_qstart_compat);
	if_qstart_compat(&ifp->if_snd);
}
void
if_qstart_compat(struct ifqueue *ifq)
{
	struct ifnet *ifp = ifq->ifq_if;
	int s;

	/*
	 * the stack assumes that an interface can have multiple
	 * transmit rings, but a lot of drivers are still written
	 * so that interfaces and send rings have a 1:1 mapping.
	 * this provides compatability between the stack and the older
	 * drivers by translating from the only queue they have
	 * (ifp->if_snd) back to the interface and calling if_start.
 	 */

	KERNEL_LOCK();
	s = splnet();
	(*ifp->if_start)(ifp);
	splx(s);
	KERNEL_UNLOCK();
}

int
if_enqueue(struct ifnet *ifp, struct mbuf *m)
{
	unsigned int idx;
	struct ifqueue *ifq;
	int error;

#if NBRIDGE > 0
	if (ifp->if_bridgeport && (m->m_flags & M_PROTO1) == 0) {
		KERNEL_LOCK();
		error = bridge_output(ifp, m, NULL, NULL);
		KERNEL_UNLOCK();
		return (error);
	}
#endif

#if NPF > 0
	pf_pkt_unlink_state_key(m);
#endif	/* NPF > 0 */

	/*
	 * use the operations on the first ifq to pick which of the array
	 * gets this mbuf.
	 */
	idx = ifq_idx(&ifp->if_snd, ifp->if_nifqs, m);
	ifq = ifp->if_ifqs[idx];

	error = ifq_enqueue(ifq, m);
	if (error)
		return (error);

	ifq_start(ifq);

	return (0);
}

void
if_input(struct ifnet *ifp, struct mbuf_list *ml)
{
	struct mbuf *m;
	size_t ibytes = 0;
#if NBPFILTER > 0
	caddr_t if_bpf;
#endif

	if (ml_empty(ml))
		return;

	MBUF_LIST_FOREACH(ml, m) {
		m->m_pkthdr.ph_ifidx = ifp->if_index;
		m->m_pkthdr.ph_rtableid = ifp->if_rdomain;
		ibytes += m->m_pkthdr.len;
	}

	ifp->if_ipackets += ml_len(ml);
	ifp->if_ibytes += ibytes;

#if NBPFILTER > 0
	if_bpf = ifp->if_bpf;
	if (if_bpf) {
		struct mbuf_list ml0;

		ml_init(&ml0);
		ml_enlist(&ml0, ml);
		ml_init(ml);

		while ((m = ml_dequeue(&ml0)) != NULL) {
			if (bpf_mtap_ether(if_bpf, m, BPF_DIRECTION_IN))
				m_freem(m);
			else
				ml_enqueue(ml, m);
		}

		if (ml_empty(ml))
			return;
	}
#endif

	if (mq_enlist(&ifp->if_inputqueue, ml) == 0)
		task_add(softnettq, ifp->if_inputtask);
}

int
if_input_local(struct ifnet *ifp, struct mbuf *m, sa_family_t af)
{
	struct niqueue *ifq = NULL;

#if NBPFILTER > 0
	/*
	 * Only send packets to bpf if they are destinated to local
	 * addresses.
	 *
	 * if_input_local() is also called for SIMPLEX interfaces to
	 * duplicate packets for local use.  But don't dup them to bpf.
	 */
	if (ifp->if_flags & IFF_LOOPBACK) {
		caddr_t if_bpf = ifp->if_bpf;

		if (if_bpf)
			bpf_mtap_af(if_bpf, af, m, BPF_DIRECTION_OUT);
	}
#endif
	m_resethdr(m);
	m->m_pkthdr.ph_ifidx = ifp->if_index;
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;

	switch (af) {
	case AF_INET:
		ifq = &ipintrq;
		break;
#ifdef INET6
	case AF_INET6:
		ifq = &ip6intrq;
		break;
#endif /* INET6 */
#ifdef MPLS
	case AF_MPLS:
		ifp->if_ipackets++;
		ifp->if_ibytes += m->m_pkthdr.len;
		mpls_input(m);
		return (0);
#endif /* MPLS */
	default:
		printf("%s: can't handle af%d\n", ifp->if_xname, af);
		m_freem(m);
		return (EAFNOSUPPORT);
	}

	if (niq_enqueue(ifq, m) != 0)
		return (ENOBUFS);

	ifp->if_ipackets++;
	ifp->if_ibytes += m->m_pkthdr.len;

	return (0);
}

struct ifih {
	SRPL_ENTRY(ifih)	  ifih_next;
	int			(*ifih_input)(struct ifnet *, struct mbuf *,
				      void *);
	void			 *ifih_cookie;
	int			  ifih_refcnt;
	struct refcnt		  ifih_srpcnt;
};

void	if_ih_ref(void *, void *);
void	if_ih_unref(void *, void *);

struct srpl_rc ifih_rc = SRPL_RC_INITIALIZER(if_ih_ref, if_ih_unref, NULL);

void
if_ih_insert(struct ifnet *ifp, int (*input)(struct ifnet *, struct mbuf *,
    void *), void *cookie)
{
	struct ifih *ifih;

	/* the kernel lock guarantees serialised modifications to if_inputs */
	KERNEL_ASSERT_LOCKED();

	SRPL_FOREACH_LOCKED(ifih, &ifp->if_inputs, ifih_next) {
		if (ifih->ifih_input == input && ifih->ifih_cookie == cookie) {
			ifih->ifih_refcnt++;
			break;
		}
	}

	if (ifih == NULL) {
		ifih = malloc(sizeof(*ifih), M_DEVBUF, M_WAITOK);

		ifih->ifih_input = input;
		ifih->ifih_cookie = cookie;
		ifih->ifih_refcnt = 1;
		refcnt_init(&ifih->ifih_srpcnt);
		SRPL_INSERT_HEAD_LOCKED(&ifih_rc, &ifp->if_inputs,
		    ifih, ifih_next);
	}
}

void
if_ih_ref(void *null, void *i)
{
	struct ifih *ifih = i;

	refcnt_take(&ifih->ifih_srpcnt);
}

void
if_ih_unref(void *null, void *i)
{
	struct ifih *ifih = i;

	refcnt_rele_wake(&ifih->ifih_srpcnt);
}

void
if_ih_remove(struct ifnet *ifp, int (*input)(struct ifnet *, struct mbuf *,
    void *), void *cookie)
{
	struct ifih *ifih;

	/* the kernel lock guarantees serialised modifications to if_inputs */
	KERNEL_ASSERT_LOCKED();

	SRPL_FOREACH_LOCKED(ifih, &ifp->if_inputs, ifih_next) {
		if (ifih->ifih_input == input && ifih->ifih_cookie == cookie)
			break;
	}

	KASSERT(ifih != NULL);

	if (--ifih->ifih_refcnt == 0) {
		SRPL_REMOVE_LOCKED(&ifih_rc, &ifp->if_inputs, ifih,
		    ifih, ifih_next);

		refcnt_finalize(&ifih->ifih_srpcnt, "ifihrm");
		free(ifih, M_DEVBUF, sizeof(*ifih));
	}
}

void
if_input_process(void *xifidx)
{
	unsigned int ifidx = (unsigned long)xifidx;
	struct mbuf_list ml;
	struct mbuf *m;
	struct ifnet *ifp;
	struct ifih *ifih;
	struct srp_ref sr;
	int s;

	ifp = if_get(ifidx);
	if (ifp == NULL)
		return;

	mq_delist(&ifp->if_inputqueue, &ml);
	if (ml_empty(&ml))
		goto out;

	if (!ISSET(ifp->if_xflags, IFXF_CLONED))
		add_net_randomness(ml_len(&ml));

	s = splnet();
	while ((m = ml_dequeue(&ml)) != NULL) {
		/*
		 * Pass this mbuf to all input handlers of its
		 * interface until it is consumed.
		 */
		SRPL_FOREACH(ifih, &sr, &ifp->if_inputs, ifih_next) {
			if ((*ifih->ifih_input)(ifp, m, ifih->ifih_cookie))
				break;
		}
		SRPL_LEAVE(&sr);

		if (ifih == NULL)
			m_freem(m);
	}
	splx(s);

out:
	if_put(ifp);
}

void
if_netisr(void *unused)
{
	int n, t = 0;
	int s;

	KERNEL_LOCK();
	NET_LOCK(s);

	while ((n = netisr) != 0) {
		/* Like sched_pause() but with a rwlock dance. */
		if (curcpu()->ci_schedstate.spc_schedflags & SPCF_SHOULDYIELD) {
			NET_UNLOCK(s);
			yield();
			NET_LOCK(s);
		}

		atomic_clearbits_int(&netisr, n);

#if NETHER > 0
		if (n & (1 << NETISR_ARP))
			arpintr();
#endif
		if (n & (1 << NETISR_IP))
			ipintr();
#ifdef INET6
		if (n & (1 << NETISR_IPV6))
			ip6intr();
#endif
#if NPPP > 0
		if (n & (1 << NETISR_PPP))
			pppintr();
#endif
#if NBRIDGE > 0
		if (n & (1 << NETISR_BRIDGE))
			bridgeintr();
#endif
#if NSWITCH > 0
		if (n & (1 << NETISR_SWITCH))
			switchintr();
#endif
#if NPPPOE > 0
		if (n & (1 << NETISR_PPPOE))
			pppoeintr();
#endif
		t |= n;
	}

#if NPFSYNC > 0
	if (t & (1 << NETISR_PFSYNC))
		pfsyncintr();
#endif

	NET_UNLOCK(s);
	KERNEL_UNLOCK();
}

void
if_deactivate(struct ifnet *ifp)
{
	int s;

	s = splnet();

	/*
	 * Call detach hooks from head to tail.  To make sure detach
	 * hooks are executed in the reverse order they were added, all
	 * the hooks have to be added to the head!
	 */
	dohooks(ifp->if_detachhooks, HOOK_REMOVE | HOOK_FREE);

#if NCARP > 0
	/* Remove the interface from any carp group it is a part of.  */
	if (ifp->if_carp && ifp->if_type != IFT_CARP)
		carp_ifdetach(ifp);
#endif

	splx(s);
}

/*
 * Detach an interface from everything in the kernel.  Also deallocate
 * private resources.
 */
void
if_detach(struct ifnet *ifp)
{
	struct ifaddr *ifa;
	struct ifg_list *ifg;
	struct domain *dp;
	int i, s, s2;

	/* Undo pseudo-driver changes. */
	if_deactivate(ifp);

	ifq_clr_oactive(&ifp->if_snd);

	NET_LOCK(s);
	s2 = splnet();
	/* Other CPUs must not have a reference before we start destroying. */
	if_idxmap_remove(ifp);

	ifp->if_qstart = if_detached_qstart;
	ifp->if_ioctl = if_detached_ioctl;
	ifp->if_watchdog = NULL;

	/* Remove the input task */
	task_del(softnettq, ifp->if_inputtask);
	mq_purge(&ifp->if_inputqueue);

	/* Remove the watchdog timeout & task */
	timeout_del(ifp->if_slowtimo);
	task_del(systq, ifp->if_watchdogtask);

	/* Remove the link state task */
	task_del(systq, ifp->if_linkstatetask);

#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
	rti_delete(ifp);
#if NETHER > 0 && defined(NFSCLIENT)
	if (ifp->if_index == revarp_ifidx)
		revarp_ifidx = 0;
#endif
#ifdef MROUTING
	vif_delete(ifp);
#endif
	in_ifdetach(ifp);
#ifdef INET6
	in6_ifdetach(ifp);
#endif
#if NPF > 0
	pfi_detach_ifnet(ifp);
#endif

	/* Remove the interface from the list of all interfaces.  */
	TAILQ_REMOVE(&ifnet, ifp, if_list);

	while ((ifg = TAILQ_FIRST(&ifp->if_groups)) != NULL)
		if_delgroup(ifp, ifg->ifgl_group->ifg_group);

	if_free_sadl(ifp);

	/* We should not have any address left at this point. */
	if (!TAILQ_EMPTY(&ifp->if_addrlist)) {
#ifdef DIAGNOSTIC
		printf("%s: address list non empty\n", ifp->if_xname);
#endif
		while ((ifa = TAILQ_FIRST(&ifp->if_addrlist)) != NULL) {
			ifa_del(ifp, ifa);
			ifa->ifa_ifp = NULL;
			ifafree(ifa);
		}
	}

	free(ifp->if_addrhooks, M_TEMP, 0);
	free(ifp->if_linkstatehooks, M_TEMP, 0);
	free(ifp->if_detachhooks, M_TEMP, 0);

	free(ifp->if_slowtimo, M_TEMP, sizeof(*ifp->if_slowtimo));
	free(ifp->if_watchdogtask, M_TEMP, sizeof(*ifp->if_watchdogtask));
	free(ifp->if_linkstatetask, M_TEMP, sizeof(*ifp->if_linkstatetask));
	free(ifp->if_inputtask, M_TEMP, sizeof(*ifp->if_inputtask));

	for (i = 0; (dp = domains[i]) != NULL; i++) {
		if (dp->dom_ifdetach && ifp->if_afdata[dp->dom_family])
			(*dp->dom_ifdetach)(ifp,
			    ifp->if_afdata[dp->dom_family]);
	}

	/* Announce that the interface is gone. */
	rtm_ifannounce(ifp, IFAN_DEPARTURE);
	splx(s2);
	NET_UNLOCK(s);

	for (i = 0; i < ifp->if_nifqs; i++)
		ifq_destroy(ifp->if_ifqs[i]);
	if (ifp->if_ifqs != ifp->if_snd.ifq_ifqs) {
		for (i = 1; i < ifp->if_nifqs; i++) {
			free(ifp->if_ifqs[i], M_DEVBUF,
			    sizeof(struct ifqueue));
		}
		free(ifp->if_ifqs, M_DEVBUF,
		    sizeof(struct ifqueue *) * ifp->if_nifqs);
	}
}

/*
 * Returns true if ``ifp0'' is connected to the interface with index ``ifidx''.
 */
int
if_isconnected(const struct ifnet *ifp0, unsigned int ifidx)
{
	struct ifnet *ifp;
	int connected = 0;

	ifp = if_get(ifidx);
	if (ifp == NULL)
		return (0);

	if (ifp0->if_index == ifp->if_index)
		connected = 1;

#if NBRIDGE > 0
	if (SAME_BRIDGE(ifp0->if_bridgeport, ifp->if_bridgeport))
		connected = 1;
#endif
#if NCARP > 0
	if ((ifp0->if_type == IFT_CARP && ifp0->if_carpdev == ifp) ||
	    (ifp->if_type == IFT_CARP && ifp->if_carpdev == ifp0))
		connected = 1;
#endif

	if_put(ifp);
	return (connected);
}

/*
 * Create a clone network interface.
 */
int
if_clone_create(const char *name, int rdomain)
{
	struct if_clone *ifc;
	struct ifnet *ifp;
	int unit, ret;

	splsoftassert(IPL_SOFTNET);

	ifc = if_clone_lookup(name, &unit);
	if (ifc == NULL)
		return (EINVAL);

	if (ifunit(name) != NULL)
		return (EEXIST);

	ret = (*ifc->ifc_create)(ifc, unit);

	if (ret != 0 || (ifp = ifunit(name)) == NULL)
		return (ret);

	if_addgroup(ifp, ifc->ifc_name);
	if (rdomain != 0)
		if_setrdomain(ifp, rdomain);

	return (ret);
}

/*
 * Destroy a clone network interface.
 */
int
if_clone_destroy(const char *name)
{
	struct if_clone *ifc;
	struct ifnet *ifp;
	int ret;

	splsoftassert(IPL_SOFTNET);

	ifc = if_clone_lookup(name, NULL);
	if (ifc == NULL)
		return (EINVAL);

	ifp = ifunit(name);
	if (ifp == NULL)
		return (ENXIO);

	if (ifc->ifc_destroy == NULL)
		return (EOPNOTSUPP);

	if (ifp->if_flags & IFF_UP) {
		int s;
		s = splnet();
		if_down(ifp);
		splx(s);
	}

	ret = (*ifc->ifc_destroy)(ifp);

	return (ret);
}

/*
 * Look up a network interface cloner.
 */
struct if_clone *
if_clone_lookup(const char *name, int *unitp)
{
	struct if_clone *ifc;
	const char *cp;
	int unit;

	/* separate interface name from unit */
	for (cp = name;
	    cp - name < IFNAMSIZ && *cp && (*cp < '0' || *cp > '9');
	    cp++)
		continue;

	if (cp == name || cp - name == IFNAMSIZ || !*cp)
		return (NULL);	/* No name or unit number */

	if (cp - name < IFNAMSIZ-1 && *cp == '0' && cp[1] != '\0')
		return (NULL);	/* unit number 0 padded */

	LIST_FOREACH(ifc, &if_cloners, ifc_list) {
		if (strlen(ifc->ifc_name) == cp - name &&
		    !strncmp(name, ifc->ifc_name, cp - name))
			break;
	}

	if (ifc == NULL)
		return (NULL);

	unit = 0;
	while (cp - name < IFNAMSIZ && *cp) {
		if (*cp < '0' || *cp > '9' ||
		    unit > (INT_MAX - (*cp - '0')) / 10) {
			/* Bogus unit number. */
			return (NULL);
		}
		unit = (unit * 10) + (*cp++ - '0');
	}

	if (unitp != NULL)
		*unitp = unit;
	return (ifc);
}

/*
 * Register a network interface cloner.
 */
void
if_clone_attach(struct if_clone *ifc)
{
	LIST_INSERT_HEAD(&if_cloners, ifc, ifc_list);
	if_cloners_count++;
}

/*
 * Unregister a network interface cloner.
 */
void
if_clone_detach(struct if_clone *ifc)
{

	LIST_REMOVE(ifc, ifc_list);
	if_cloners_count--;
}

/*
 * Provide list of interface cloners to userspace.
 */
int
if_clone_list(struct if_clonereq *ifcr)
{
	char outbuf[IFNAMSIZ], *dst;
	struct if_clone *ifc;
	int count, error = 0;

	ifcr->ifcr_total = if_cloners_count;
	if ((dst = ifcr->ifcr_buffer) == NULL) {
		/* Just asking how many there are. */
		return (0);
	}

	if (ifcr->ifcr_count < 0)
		return (EINVAL);

	count = (if_cloners_count < ifcr->ifcr_count) ?
	    if_cloners_count : ifcr->ifcr_count;

	LIST_FOREACH(ifc, &if_cloners, ifc_list) {
		if (count == 0)
			break;
		bzero(outbuf, sizeof outbuf);
		strlcpy(outbuf, ifc->ifc_name, IFNAMSIZ);
		error = copyout(outbuf, dst, IFNAMSIZ);
		if (error)
			break;
		count--;
		dst += IFNAMSIZ;
	}

	return (error);
}

/*
 * set queue congestion marker
 */
void
if_congestion(void)
{
	extern int ticks;

	ifq_congestion = ticks;
}

int
if_congested(void)
{
	extern int ticks;
	int diff;

	diff = ticks - ifq_congestion;
	if (diff < 0) {
		ifq_congestion = ticks - hz;
		return (0);
	}

	return (diff <= (hz / 100));
}

#define	equal(a1, a2)	\
	(bcmp((caddr_t)(a1), (caddr_t)(a2),	\
	((struct sockaddr *)(a1))->sa_len) == 0)

/*
 * Locate an interface based on a complete address.
 */
struct ifaddr *
ifa_ifwithaddr(struct sockaddr *addr, u_int rtableid)
{
	struct ifnet *ifp;
	struct ifaddr *ifa;
	u_int rdomain;

	KERNEL_ASSERT_LOCKED();
	rdomain = rtable_l2(rtableid);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rdomain)
			continue;

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != addr->sa_family)
				continue;

			if (equal(addr, ifa->ifa_addr))
				return (ifa);
		}
	}
	return (NULL);
}

/*
 * Locate the point to point interface with a given destination address.
 */
struct ifaddr *
ifa_ifwithdstaddr(struct sockaddr *addr, u_int rdomain)
{
	struct ifnet *ifp;
	struct ifaddr *ifa;

	KERNEL_ASSERT_LOCKED();
	rdomain = rtable_l2(rdomain);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rdomain)
			continue;
		if (ifp->if_flags & IFF_POINTOPOINT)
			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
				if (ifa->ifa_addr->sa_family !=
				    addr->sa_family || ifa->ifa_dstaddr == NULL)
					continue;
				if (equal(addr, ifa->ifa_dstaddr))
					return (ifa);
			}
	}
	return (NULL);
}

/*
 * Find an interface address specific to an interface best matching
 * a given address.
 */
struct ifaddr *
ifaof_ifpforaddr(struct sockaddr *addr, struct ifnet *ifp)
{
	struct ifaddr *ifa;
	char *cp, *cp2, *cp3;
	char *cplim;
	struct ifaddr *ifa_maybe = NULL;
	u_int af = addr->sa_family;

	if (af >= AF_MAX)
		return (NULL);
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != af)
			continue;
		if (ifa_maybe == NULL)
			ifa_maybe = ifa;
		if (ifa->ifa_netmask == 0 || ifp->if_flags & IFF_POINTOPOINT) {
			if (equal(addr, ifa->ifa_addr) ||
			    (ifa->ifa_dstaddr && equal(addr, ifa->ifa_dstaddr)))
				return (ifa);
			continue;
		}
		cp = addr->sa_data;
		cp2 = ifa->ifa_addr->sa_data;
		cp3 = ifa->ifa_netmask->sa_data;
		cplim = ifa->ifa_netmask->sa_len + (char *)ifa->ifa_netmask;
		for (; cp3 < cplim; cp3++)
			if ((*cp++ ^ *cp2++) & *cp3)
				break;
		if (cp3 == cplim)
			return (ifa);
	}
	return (ifa_maybe);
}

void
if_rtrequest_dummy(struct ifnet *ifp, int req, struct rtentry *rt)
{
}

/*
 * Default action when installing a local route on a point-to-point
 * interface.
 */
void
p2p_rtrequest(struct ifnet *ifp, int req, struct rtentry *rt)
{
	struct ifnet *lo0ifp;
	struct ifaddr *ifa, *lo0ifa;

	switch (req) {
	case RTM_ADD:
		if (!ISSET(rt->rt_flags, RTF_LOCAL))
			break;

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (memcmp(rt_key(rt), ifa->ifa_addr,
			    rt_key(rt)->sa_len) == 0)
				break;
		}

		if (ifa == NULL)
			break;

		KASSERT(ifa == rt->rt_ifa);

		lo0ifp = if_get(rtable_loindex(ifp->if_rdomain));
		KASSERT(lo0ifp != NULL);
		TAILQ_FOREACH(lo0ifa, &lo0ifp->if_addrlist, ifa_list) {
			if (lo0ifa->ifa_addr->sa_family ==
			    ifa->ifa_addr->sa_family)
				break;
		}
		if_put(lo0ifp);

		if (lo0ifa == NULL)
			break;

		rt->rt_flags &= ~RTF_LLINFO;
		break;
	case RTM_DELETE:
	case RTM_RESOLVE:
	default:
		break;
	}
}


/*
 * Bring down all interfaces
 */
void
if_downall(void)
{
	struct ifreq ifrq;	/* XXX only partly built */
	struct ifnet *ifp;
	int s;

	NET_LOCK(s);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if ((ifp->if_flags & IFF_UP) == 0)
			continue;
		if_down(ifp);
		if (ifp->if_ioctl) {
			ifrq.ifr_flags = ifp->if_flags;
			(void) (*ifp->if_ioctl)(ifp, SIOCSIFFLAGS,
			    (caddr_t)&ifrq);
		}
	}
	NET_UNLOCK(s);
}

/*
 * Mark an interface down and notify protocols of
 * the transition.
 */
void
if_down(struct ifnet *ifp)
{
	struct ifaddr *ifa;

	splsoftassert(IPL_SOFTNET);

	ifp->if_flags &= ~IFF_UP;
	getmicrotime(&ifp->if_lastchange);
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		pfctlinput(PRC_IFDOWN, ifa->ifa_addr);
	}
	IFQ_PURGE(&ifp->if_snd);

	if_linkstate(ifp);
}

/*
 * Mark an interface up and notify protocols of
 * the transition.
 */
void
if_up(struct ifnet *ifp)
{
	splsoftassert(IPL_SOFTNET);

	ifp->if_flags |= IFF_UP;
	getmicrotime(&ifp->if_lastchange);

#ifdef INET6
	/* Userland expects the kernel to set ::1 on default lo(4). */
	if (ifp->if_index == rtable_loindex(ifp->if_rdomain))
		in6_ifattach(ifp);
#endif

	if_linkstate(ifp);
}

/*
 * Notify userland, the routing table and hooks owner of
 * a link-state transition.
 */
void
if_linkstate_task(void *xifidx)
{
	unsigned int ifidx = (unsigned long)xifidx;
	struct ifnet *ifp;
	int s;

	ifp = if_get(ifidx);
	if (ifp == NULL)
		return;

	NET_LOCK(s);
	if_linkstate(ifp);
	NET_UNLOCK(s);

	if_put(ifp);
}

void
if_linkstate(struct ifnet *ifp)
{
	NET_ASSERT_LOCKED();

	rtm_ifchg(ifp);
#ifndef SMALL_KERNEL
	rt_if_track(ifp);
#endif
	dohooks(ifp->if_linkstatehooks, 0);
}

/*
 * Schedule a link state change task.
 */
void
if_link_state_change(struct ifnet *ifp)
{
	task_add(systq, ifp->if_linkstatetask);
}

/*
 * Handle interface watchdog timer routine.  Called
 * from softclock, we decrement timer (if set) and
 * call the appropriate interface routine on expiration.
 */
void
if_slowtimo(void *arg)
{
	struct ifnet *ifp = arg;
	int s = splnet();

	if (ifp->if_watchdog) {
		if (ifp->if_timer > 0 && --ifp->if_timer == 0)
			task_add(systq, ifp->if_watchdogtask);
		timeout_add(ifp->if_slowtimo, hz / IFNET_SLOWHZ);
	}
	splx(s);
}

void
if_watchdog_task(void *xifidx)
{
	unsigned int ifidx = (unsigned long)xifidx;
	struct ifnet *ifp;
	int s;

	ifp = if_get(ifidx);
	if (ifp == NULL)
		return;

	s = splnet();
	if (ifp->if_watchdog)
		(*ifp->if_watchdog)(ifp);
	splx(s);

	if_put(ifp);
}

/*
 * Map interface name to interface structure pointer.
 */
struct ifnet *
ifunit(const char *name)
{
	struct ifnet *ifp;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (strcmp(ifp->if_xname, name) == 0)
			return (ifp);
	}
	return (NULL);
}

/*
 * Map interface index to interface structure pointer.
 */
struct ifnet *
if_get(unsigned int index)
{
	struct srp_ref sr;
	struct if_map *if_map;
	struct srp *map;
	struct ifnet *ifp = NULL;

	if_map = srp_enter(&sr, &if_idxmap.map);
	if (index < if_map->limit) {
		map = (struct srp *)(if_map + 1);

		ifp = srp_follow(&sr, &map[index]);
		if (ifp != NULL) {
			KASSERT(ifp->if_index == index);
			if_ref(ifp);
		}
	}
	srp_leave(&sr);

	return (ifp);
}

struct ifnet *
if_ref(struct ifnet *ifp)
{
	refcnt_take(&ifp->if_refcnt);

	return (ifp);
}

void
if_put(struct ifnet *ifp)
{
	if (ifp == NULL)
		return;

	refcnt_rele_wake(&ifp->if_refcnt);
}

int
if_setlladdr(struct ifnet *ifp, const uint8_t *lladdr)
{
	if (ifp->if_sadl == NULL)
		return (EINVAL);

	memcpy(((struct arpcom *)ifp)->ac_enaddr, lladdr, ETHER_ADDR_LEN);
	memcpy(LLADDR(ifp->if_sadl), lladdr, ETHER_ADDR_LEN);

	return (0);
}

int
if_setrdomain(struct ifnet *ifp, int rdomain)
{
	struct ifreq ifr;
	int error, up = 0, s;

	if (rdomain < 0 || rdomain > RT_TABLEID_MAX)
		return (EINVAL);

	/*
	 * Create the routing table if it does not exist, including its
	 * loopback interface with unit == rdomain.
	 */
	if (!rtable_exists(rdomain)) {
		struct ifnet *loifp;
		char loifname[IFNAMSIZ];
		unsigned int unit = rdomain;

		snprintf(loifname, sizeof(loifname), "lo%u", unit);
		error = if_clone_create(loifname, 0);

		if ((loifp = ifunit(loifname)) == NULL)
			return (ENXIO);

		/* Do not error out if creating the default lo(4) interface */
		if (error && (ifp != loifp || error != EEXIST))
			return (error);

		if ((error = rtable_add(rdomain)) == 0)
			rtable_l2set(rdomain, rdomain, loifp->if_index);
		if (error) {
			if_clone_destroy(loifname);
			return (error);
		}

		loifp->if_rdomain = rdomain;
	}

	/* make sure that the routing table is a real rdomain */
	if (rdomain != rtable_l2(rdomain))
		return (EINVAL);

	/* remove all routing entries when switching domains */
	/* XXX this is a bit ugly */
	if (rdomain != ifp->if_rdomain) {
		s = splnet();
		/*
		 * We are tearing down the world.
		 * Take down the IF so:
		 * 1. everything that cares gets a message
		 * 2. the automagic IPv6 bits are recreated
		 */
		if (ifp->if_flags & IFF_UP) {
			up = 1;
			if_down(ifp);
		}
		rti_delete(ifp);
#ifdef MROUTING
		vif_delete(ifp);
#endif
		in_ifdetach(ifp);
#ifdef INET6
		in6_ifdetach(ifp);
#endif
		splx(s);
	}

	/* Let devices like enc(4) or mpe(4) know about the change */
	ifr.ifr_rdomainid = rdomain;
	if ((error = (*ifp->if_ioctl)(ifp, SIOCSIFRDOMAIN,
	    (caddr_t)&ifr)) != ENOTTY)
		return (error);
	error = 0;

	/* Add interface to the specified rdomain */
	ifp->if_rdomain = rdomain;

	/* If we took down the IF, bring it back */
	if (up) {
		s = splnet();
		if_up(ifp);
		splx(s);
	}

	return (0);
}

/*
 * Interface ioctls.
 */
int
ifioctl(struct socket *so, u_long cmd, caddr_t data, struct proc *p)
{
	struct ifnet *ifp;
	struct ifreq *ifr;
	struct sockaddr_dl *sdl;
	struct ifgroupreq *ifgr;
	struct if_afreq *ifar;
	char ifdescrbuf[IFDESCRSIZE];
	char ifrtlabelbuf[RTLABEL_LEN];
	int s, error = 0;
	size_t bytesdone;
	short oif_flags;
	const char *label;

	switch (cmd) {

	case SIOCGIFCONF:
		return (ifconf(cmd, data));
	}
	ifr = (struct ifreq *)data;

	switch (cmd) {
	case SIOCIFCREATE:
	case SIOCIFDESTROY:
		if ((error = suser(p, 0)) != 0)
			return (error);
		return ((cmd == SIOCIFCREATE) ?
		    if_clone_create(ifr->ifr_name, 0) :
		    if_clone_destroy(ifr->ifr_name));
	case SIOCIFGCLONERS:
		return (if_clone_list((struct if_clonereq *)data));
	case SIOCGIFGMEMB:
		return (if_getgroupmembers(data));
	case SIOCGIFGATTR:
		return (if_getgroupattribs(data));
	case SIOCSIFGATTR:
		if ((error = suser(p, 0)) != 0)
			return (error);
		return (if_setgroupattribs(data));
	case SIOCIFAFATTACH:
	case SIOCIFAFDETACH:
		if ((error = suser(p, 0)) != 0)
			return (error);
		ifar = (struct if_afreq *)data;
		if ((ifp = ifunit(ifar->ifar_name)) == NULL)
			return (ENXIO);
		switch (ifar->ifar_af) {
		case AF_INET:
			/* attach is a noop for AF_INET */
			if (cmd == SIOCIFAFDETACH)
				in_ifdetach(ifp);
			return (0);
#ifdef INET6
		case AF_INET6:
			if (cmd == SIOCIFAFATTACH)
				error = in6_ifattach(ifp);
			else
				in6_ifdetach(ifp);
			return (error);
#endif /* INET6 */
		default:
			return (EAFNOSUPPORT);
		}
	}

	ifp = ifunit(ifr->ifr_name);
	if (ifp == 0)
		return (ENXIO);
	oif_flags = ifp->if_flags;
	switch (cmd) {

	case SIOCGIFFLAGS:
		ifr->ifr_flags = ifp->if_flags;
		if (ifq_is_oactive(&ifp->if_snd))
			ifr->ifr_flags |= IFF_OACTIVE;
		break;

	case SIOCGIFXFLAGS:
		ifr->ifr_flags = ifp->if_xflags & ~(IFXF_MPSAFE|IFXF_CLONED);
		break;

	case SIOCGIFMETRIC:
		ifr->ifr_metric = ifp->if_metric;
		break;

	case SIOCGIFMTU:
		ifr->ifr_mtu = ifp->if_mtu;
		break;

	case SIOCGIFHARDMTU:
		ifr->ifr_hardmtu = ifp->if_hardmtu;
		break;

	case SIOCGIFDATA: {
		struct if_data ifdata;
		if_getdata(ifp, &ifdata);
		error = copyout(&ifdata, ifr->ifr_data, sizeof(ifdata));
		break;
	}

	case SIOCSIFFLAGS:
		if ((error = suser(p, 0)) != 0)
			return (error);

		ifp->if_flags = (ifp->if_flags & IFF_CANTCHANGE) |
			(ifr->ifr_flags & ~IFF_CANTCHANGE);

		if (ifp->if_ioctl != NULL) {
			error = (*ifp->if_ioctl)(ifp, cmd, data);
			if (error != 0) {
				ifp->if_flags = oif_flags;
				break;
			}
		}

		if (ISSET(oif_flags ^ ifp->if_flags, IFF_UP)) {
			s = splnet();
			if (ISSET(ifp->if_flags, IFF_UP))
				if_up(ifp);
			else
				if_down(ifp);
			splx(s);
		}
		break;

	case SIOCSIFXFLAGS:
		if ((error = suser(p, 0)) != 0)
			return (error);

#ifdef INET6
		if (ISSET(ifr->ifr_flags, IFXF_AUTOCONF6)) {
			error = in6_ifattach(ifp);
			if (error != 0)
				return (error);
		}

		if ((ifr->ifr_flags & IFXF_AUTOCONF6) &&
		    !(ifp->if_xflags & IFXF_AUTOCONF6)) {
			nd6_rs_attach(ifp);
		}

		if ((ifp->if_xflags & IFXF_AUTOCONF6) &&
		    !(ifr->ifr_flags & IFXF_AUTOCONF6)) {
			nd6_rs_detach(ifp);
		}
#endif	/* INET6 */

#ifdef MPLS
		if (ISSET(ifr->ifr_flags, IFXF_MPLS) &&
		    !ISSET(ifp->if_xflags, IFXF_MPLS)) {
			s = splnet();
			ifp->if_xflags |= IFXF_MPLS;
			ifp->if_ll_output = ifp->if_output;
			ifp->if_output = mpls_output;
			splx(s);
		}
		if (ISSET(ifp->if_xflags, IFXF_MPLS) &&
		    !ISSET(ifr->ifr_flags, IFXF_MPLS)) {
			s = splnet();
			ifp->if_xflags &= ~IFXF_MPLS;
			ifp->if_output = ifp->if_ll_output;
			ifp->if_ll_output = NULL;
			splx(s);
		}
#endif	/* MPLS */

#ifndef SMALL_KERNEL
		if (ifp->if_capabilities & IFCAP_WOL) {
			if (ISSET(ifr->ifr_flags, IFXF_WOL) &&
			    !ISSET(ifp->if_xflags, IFXF_WOL)) {
				s = splnet();
				ifp->if_xflags |= IFXF_WOL;
				error = ifp->if_wol(ifp, 1);
				splx(s);
				if (error)
					return (error);
			}
			if (ISSET(ifp->if_xflags, IFXF_WOL) &&
			    !ISSET(ifr->ifr_flags, IFXF_WOL)) {
				s = splnet();
				ifp->if_xflags &= ~IFXF_WOL;
				error = ifp->if_wol(ifp, 0);
				splx(s);
				if (error)
					return (error);
			}
		} else if (ISSET(ifr->ifr_flags, IFXF_WOL)) {
			ifr->ifr_flags &= ~IFXF_WOL;
			error = ENOTSUP;
		}
#endif

		ifp->if_xflags = (ifp->if_xflags & IFXF_CANTCHANGE) |
			(ifr->ifr_flags & ~IFXF_CANTCHANGE);
		rtm_ifchg(ifp);
		break;

	case SIOCSIFMETRIC:
		if ((error = suser(p, 0)) != 0)
			return (error);
		ifp->if_metric = ifr->ifr_metric;
		break;

	case SIOCSIFMTU:
		if ((error = suser(p, 0)) != 0)
			return (error);
		if (ifp->if_ioctl == NULL)
			return (EOPNOTSUPP);
		error = (*ifp->if_ioctl)(ifp, cmd, data);
		if (!error)
			rtm_ifchg(ifp);
		break;

	case SIOCSIFPHYADDR:
	case SIOCDIFPHYADDR:
#ifdef INET6
	case SIOCSIFPHYADDR_IN6:
#endif
	case SIOCSLIFPHYADDR:
	case SIOCSLIFPHYRTABLE:
	case SIOCSLIFPHYTTL:
	case SIOCADDMULTI:
	case SIOCDELMULTI:
	case SIOCSIFMEDIA:
	case SIOCSVNETID:
	case SIOCSIFPAIR:
	case SIOCSIFPARENT:
	case SIOCDIFPARENT:
		if ((error = suser(p, 0)) != 0)
			return (error);
		/* FALLTHROUGH */
	case SIOCGIFPSRCADDR:
	case SIOCGIFPDSTADDR:
	case SIOCGLIFPHYADDR:
	case SIOCGLIFPHYRTABLE:
	case SIOCGLIFPHYTTL:
	case SIOCGIFMEDIA:
	case SIOCGVNETID:
	case SIOCGIFPAIR:
	case SIOCGIFPARENT:
		if (ifp->if_ioctl == 0)
			return (EOPNOTSUPP);
		error = (*ifp->if_ioctl)(ifp, cmd, data);
		break;

	case SIOCGIFDESCR:
		strlcpy(ifdescrbuf, ifp->if_description, IFDESCRSIZE);
		error = copyoutstr(ifdescrbuf, ifr->ifr_data, IFDESCRSIZE,
		    &bytesdone);
		break;

	case SIOCSIFDESCR:
		if ((error = suser(p, 0)) != 0)
			return (error);
		error = copyinstr(ifr->ifr_data, ifdescrbuf,
		    IFDESCRSIZE, &bytesdone);
		if (error == 0) {
			(void)memset(ifp->if_description, 0, IFDESCRSIZE);
			strlcpy(ifp->if_description, ifdescrbuf, IFDESCRSIZE);
		}
		break;

	case SIOCGIFRTLABEL:
		if (ifp->if_rtlabelid &&
		    (label = rtlabel_id2name(ifp->if_rtlabelid)) != NULL) {
			strlcpy(ifrtlabelbuf, label, RTLABEL_LEN);
			error = copyoutstr(ifrtlabelbuf, ifr->ifr_data,
			    RTLABEL_LEN, &bytesdone);
		} else
			error = ENOENT;
		break;

	case SIOCSIFRTLABEL:
		if ((error = suser(p, 0)) != 0)
			return (error);
		error = copyinstr(ifr->ifr_data, ifrtlabelbuf,
		    RTLABEL_LEN, &bytesdone);
		if (error == 0) {
			rtlabel_unref(ifp->if_rtlabelid);
			ifp->if_rtlabelid = rtlabel_name2id(ifrtlabelbuf);
		}
		break;

	case SIOCGIFPRIORITY:
		ifr->ifr_metric = ifp->if_priority;
		break;

	case SIOCSIFPRIORITY:
		if ((error = suser(p, 0)) != 0)
			return (error);
		if (ifr->ifr_metric < 0 || ifr->ifr_metric > 15)
			return (EINVAL);
		ifp->if_priority = ifr->ifr_metric;
		break;

	case SIOCGIFRDOMAIN:
		ifr->ifr_rdomainid = ifp->if_rdomain;
		break;

	case SIOCSIFRDOMAIN:
		if ((error = suser(p, 0)) != 0)
			return (error);
		if ((error = if_setrdomain(ifp, ifr->ifr_rdomainid)) != 0)
			return (error);
		break;

	case SIOCAIFGROUP:
		if ((error = suser(p, 0)))
			return (error);
		ifgr = (struct ifgroupreq *)data;
		if ((error = if_addgroup(ifp, ifgr->ifgr_group)))
			return (error);
		(*ifp->if_ioctl)(ifp, cmd, data); /* XXX error check */
		break;

	case SIOCGIFGROUP:
		if ((error = if_getgroup(data, ifp)))
			return (error);
		break;

	case SIOCDIFGROUP:
		if ((error = suser(p, 0)))
			return (error);
		(*ifp->if_ioctl)(ifp, cmd, data); /* XXX error check */
		ifgr = (struct ifgroupreq *)data;
		if ((error = if_delgroup(ifp, ifgr->ifgr_group)))
			return (error);
		break;

	case SIOCSIFLLADDR:
		if ((error = suser(p, 0)))
			return (error);
		sdl = ifp->if_sadl;
		if (sdl == NULL)
			return (EINVAL);
		if (ifr->ifr_addr.sa_len != ETHER_ADDR_LEN)
			return (EINVAL);
		if (ETHER_IS_MULTICAST(ifr->ifr_addr.sa_data))
			return (EINVAL);
		switch (ifp->if_type) {
		case IFT_ETHER:
		case IFT_CARP:
		case IFT_XETHER:
		case IFT_ISO88025:
			if_setlladdr(ifp, ifr->ifr_addr.sa_data);
			error = (*ifp->if_ioctl)(ifp, cmd, data);
			if (error == ENOTTY)
				error = 0;
			break;
		default:
			return (ENODEV);
		}

		ifnewlladdr(ifp);
		break;

	case SIOCGIFLLPRIO:
		ifr->ifr_llprio = ifp->if_llprio;
		break;

	case SIOCSIFLLPRIO:
		if ((error = suser(p, 0)))
			return (error);
		if (ifr->ifr_llprio > UCHAR_MAX)
			return (EINVAL);
		ifp->if_llprio = ifr->ifr_llprio;
		break;

	default:
		if (so->so_proto == 0)
			return (EOPNOTSUPP);
		error = ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
			(struct mbuf *) cmd, (struct mbuf *) data,
			(struct mbuf *) ifp, p));
		break;
	}

	if (((oif_flags ^ ifp->if_flags) & IFF_UP) != 0)
		getmicrotime(&ifp->if_lastchange);

	return (error);
}

/*
 * Return interface configuration
 * of system.  List may be used
 * in later ioctl's (above) to get
 * other information.
 */
int
ifconf(u_long cmd, caddr_t data)
{
	struct ifconf *ifc = (struct ifconf *)data;
	struct ifnet *ifp;
	struct ifaddr *ifa;
	struct ifreq ifr, *ifrp;
	int space = ifc->ifc_len, error = 0;

	/* If ifc->ifc_len is 0, fill it in with the needed size and return. */
	if (space == 0) {
		TAILQ_FOREACH(ifp, &ifnet, if_list) {
			struct sockaddr *sa;

			if (TAILQ_EMPTY(&ifp->if_addrlist))
				space += sizeof (ifr);
			else
				TAILQ_FOREACH(ifa,
				    &ifp->if_addrlist, ifa_list) {
					sa = ifa->ifa_addr;
					if (sa->sa_len > sizeof(*sa))
						space += sa->sa_len -
						    sizeof(*sa);
					space += sizeof(ifr);
				}
		}
		ifc->ifc_len = space;
		return (0);
	}

	ifrp = ifc->ifc_req;
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (space < sizeof(ifr))
			break;
		bcopy(ifp->if_xname, ifr.ifr_name, IFNAMSIZ);
		if (TAILQ_EMPTY(&ifp->if_addrlist)) {
			bzero((caddr_t)&ifr.ifr_addr, sizeof(ifr.ifr_addr));
			error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
			    sizeof(ifr));
			if (error)
				break;
			space -= sizeof (ifr), ifrp++;
		} else
			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
				struct sockaddr *sa = ifa->ifa_addr;

				if (space < sizeof(ifr))
					break;
				if (sa->sa_len <= sizeof(*sa)) {
					ifr.ifr_addr = *sa;
					error = copyout((caddr_t)&ifr,
					    (caddr_t)ifrp, sizeof (ifr));
					ifrp++;
				} else {
					space -= sa->sa_len - sizeof(*sa);
					if (space < sizeof (ifr))
						break;
					error = copyout((caddr_t)&ifr,
					    (caddr_t)ifrp,
					    sizeof(ifr.ifr_name));
					if (error == 0)
						error = copyout((caddr_t)sa,
						    (caddr_t)&ifrp->ifr_addr,
						    sa->sa_len);
					ifrp = (struct ifreq *)(sa->sa_len +
					    (caddr_t)&ifrp->ifr_addr);
				}
				if (error)
					break;
				space -= sizeof (ifr);
			}
	}
	ifc->ifc_len -= space;
	return (error);
}

void
if_getdata(struct ifnet *ifp, struct if_data *data)
{
	unsigned int i;
	struct ifqueue *ifq;
	uint64_t opackets = 0;
	uint64_t obytes = 0;
	uint64_t omcasts = 0;
	uint64_t oqdrops = 0;

	for (i = 0; i < ifp->if_nifqs; i++) {
		ifq = ifp->if_ifqs[i];

		mtx_enter(&ifq->ifq_mtx);
		opackets += ifq->ifq_packets;
		obytes += ifq->ifq_bytes;
		oqdrops += ifq->ifq_qdrops;
		omcasts += ifq->ifq_mcasts;
		mtx_leave(&ifq->ifq_mtx);
		/* ifq->ifq_errors */
	}

	*data = ifp->if_data;
	data->ifi_opackets += opackets;
	data->ifi_obytes += obytes;
	data->ifi_oqdrops += oqdrops;
	data->ifi_omcasts += omcasts;
	/* ifp->if_data.ifi_oerrors */
}

/*
 * Dummy functions replaced in ifnet during detach (if protocols decide to
 * fiddle with the if during detach.
 */
void
if_detached_qstart(struct ifqueue *ifq)
{
	ifq_purge(ifq);
}

int
if_detached_ioctl(struct ifnet *ifp, u_long a, caddr_t b)
{
	return ENODEV;
}

/*
 * Create interface group without members
 */
struct ifg_group *
if_creategroup(const char *groupname)
{
	struct ifg_group	*ifg;

	if ((ifg = malloc(sizeof(*ifg), M_TEMP, M_NOWAIT)) == NULL)
		return (NULL);

	strlcpy(ifg->ifg_group, groupname, sizeof(ifg->ifg_group));
	ifg->ifg_refcnt = 0;
	ifg->ifg_carp_demoted = 0;
	TAILQ_INIT(&ifg->ifg_members);
#if NPF > 0
	pfi_attach_ifgroup(ifg);
#endif
	TAILQ_INSERT_TAIL(&ifg_head, ifg, ifg_next);

	return (ifg);
}

/*
 * Add a group to an interface
 */
int
if_addgroup(struct ifnet *ifp, const char *groupname)
{
	struct ifg_list		*ifgl;
	struct ifg_group	*ifg = NULL;
	struct ifg_member	*ifgm;

	if (groupname[0] && groupname[strlen(groupname) - 1] >= '0' &&
	    groupname[strlen(groupname) - 1] <= '9')
		return (EINVAL);

	TAILQ_FOREACH(ifgl, &ifp->if_groups, ifgl_next)
		if (!strcmp(ifgl->ifgl_group->ifg_group, groupname))
			return (EEXIST);

	if ((ifgl = malloc(sizeof(*ifgl), M_TEMP, M_NOWAIT)) == NULL)
		return (ENOMEM);

	if ((ifgm = malloc(sizeof(*ifgm), M_TEMP, M_NOWAIT)) == NULL) {
		free(ifgl, M_TEMP, sizeof(*ifgl));
		return (ENOMEM);
	}

	TAILQ_FOREACH(ifg, &ifg_head, ifg_next)
		if (!strcmp(ifg->ifg_group, groupname))
			break;

	if (ifg == NULL && (ifg = if_creategroup(groupname)) == NULL) {
		free(ifgl, M_TEMP, sizeof(*ifgl));
		free(ifgm, M_TEMP, sizeof(*ifgm));
		return (ENOMEM);
	}

	ifg->ifg_refcnt++;
	ifgl->ifgl_group = ifg;
	ifgm->ifgm_ifp = ifp;

	TAILQ_INSERT_TAIL(&ifg->ifg_members, ifgm, ifgm_next);
	TAILQ_INSERT_TAIL(&ifp->if_groups, ifgl, ifgl_next);

#if NPF > 0
	pfi_group_change(groupname);
#endif

	return (0);
}

/*
 * Remove a group from an interface
 */
int
if_delgroup(struct ifnet *ifp, const char *groupname)
{
	struct ifg_list		*ifgl;
	struct ifg_member	*ifgm;

	TAILQ_FOREACH(ifgl, &ifp->if_groups, ifgl_next)
		if (!strcmp(ifgl->ifgl_group->ifg_group, groupname))
			break;
	if (ifgl == NULL)
		return (ENOENT);

	TAILQ_REMOVE(&ifp->if_groups, ifgl, ifgl_next);

	TAILQ_FOREACH(ifgm, &ifgl->ifgl_group->ifg_members, ifgm_next)
		if (ifgm->ifgm_ifp == ifp)
			break;

	if (ifgm != NULL) {
		TAILQ_REMOVE(&ifgl->ifgl_group->ifg_members, ifgm, ifgm_next);
		free(ifgm, M_TEMP, sizeof(*ifgm));
	}

	if (--ifgl->ifgl_group->ifg_refcnt == 0) {
		TAILQ_REMOVE(&ifg_head, ifgl->ifgl_group, ifg_next);
#if NPF > 0
		pfi_detach_ifgroup(ifgl->ifgl_group);
#endif
		free(ifgl->ifgl_group, M_TEMP, 0);
	}

	free(ifgl, M_TEMP, sizeof(*ifgl));

#if NPF > 0
	pfi_group_change(groupname);
#endif

	return (0);
}

/*
 * Stores all groups from an interface in memory pointed
 * to by data
 */
int
if_getgroup(caddr_t data, struct ifnet *ifp)
{
	int			 len, error;
	struct ifg_list		*ifgl;
	struct ifg_req		 ifgrq, *ifgp;
	struct ifgroupreq	*ifgr = (struct ifgroupreq *)data;

	if (ifgr->ifgr_len == 0) {
		TAILQ_FOREACH(ifgl, &ifp->if_groups, ifgl_next)
			ifgr->ifgr_len += sizeof(struct ifg_req);
		return (0);
	}

	len = ifgr->ifgr_len;
	ifgp = ifgr->ifgr_groups;
	TAILQ_FOREACH(ifgl, &ifp->if_groups, ifgl_next) {
		if (len < sizeof(ifgrq))
			return (EINVAL);
		bzero(&ifgrq, sizeof ifgrq);
		strlcpy(ifgrq.ifgrq_group, ifgl->ifgl_group->ifg_group,
		    sizeof(ifgrq.ifgrq_group));
		if ((error = copyout((caddr_t)&ifgrq, (caddr_t)ifgp,
		    sizeof(struct ifg_req))))
			return (error);
		len -= sizeof(ifgrq);
		ifgp++;
	}

	return (0);
}

/*
 * Stores all members of a group in memory pointed to by data
 */
int
if_getgroupmembers(caddr_t data)
{
	struct ifgroupreq	*ifgr = (struct ifgroupreq *)data;
	struct ifg_group	*ifg;
	struct ifg_member	*ifgm;
	struct ifg_req		 ifgrq, *ifgp;
	int			 len, error;

	TAILQ_FOREACH(ifg, &ifg_head, ifg_next)
		if (!strcmp(ifg->ifg_group, ifgr->ifgr_name))
			break;
	if (ifg == NULL)
		return (ENOENT);

	if (ifgr->ifgr_len == 0) {
		TAILQ_FOREACH(ifgm, &ifg->ifg_members, ifgm_next)
			ifgr->ifgr_len += sizeof(ifgrq);
		return (0);
	}

	len = ifgr->ifgr_len;
	ifgp = ifgr->ifgr_groups;
	TAILQ_FOREACH(ifgm, &ifg->ifg_members, ifgm_next) {
		if (len < sizeof(ifgrq))
			return (EINVAL);
		bzero(&ifgrq, sizeof ifgrq);
		strlcpy(ifgrq.ifgrq_member, ifgm->ifgm_ifp->if_xname,
		    sizeof(ifgrq.ifgrq_member));
		if ((error = copyout((caddr_t)&ifgrq, (caddr_t)ifgp,
		    sizeof(struct ifg_req))))
			return (error);
		len -= sizeof(ifgrq);
		ifgp++;
	}

	return (0);
}

int
if_getgroupattribs(caddr_t data)
{
	struct ifgroupreq	*ifgr = (struct ifgroupreq *)data;
	struct ifg_group	*ifg;

	TAILQ_FOREACH(ifg, &ifg_head, ifg_next)
		if (!strcmp(ifg->ifg_group, ifgr->ifgr_name))
			break;
	if (ifg == NULL)
		return (ENOENT);

	ifgr->ifgr_attrib.ifg_carp_demoted = ifg->ifg_carp_demoted;

	return (0);
}

int
if_setgroupattribs(caddr_t data)
{
	struct ifgroupreq	*ifgr = (struct ifgroupreq *)data;
	struct ifg_group	*ifg;
	struct ifg_member	*ifgm;
	int			 demote;

	TAILQ_FOREACH(ifg, &ifg_head, ifg_next)
		if (!strcmp(ifg->ifg_group, ifgr->ifgr_name))
			break;
	if (ifg == NULL)
		return (ENOENT);

	demote = ifgr->ifgr_attrib.ifg_carp_demoted;
	if (demote + ifg->ifg_carp_demoted > 0xff ||
	    demote + ifg->ifg_carp_demoted < 0)
		return (EINVAL);

	ifg->ifg_carp_demoted += demote;

	TAILQ_FOREACH(ifgm, &ifg->ifg_members, ifgm_next)
		if (ifgm->ifgm_ifp->if_ioctl)
			ifgm->ifgm_ifp->if_ioctl(ifgm->ifgm_ifp,
			    SIOCSIFGATTR, data);
	return (0);
}

void
if_group_routechange(struct sockaddr *dst, struct sockaddr *mask)
{
	switch (dst->sa_family) {
	case AF_INET:
		if (satosin(dst)->sin_addr.s_addr == INADDR_ANY &&
		    mask && (mask->sa_len == 0 ||
		    satosin(mask)->sin_addr.s_addr == INADDR_ANY))
			if_group_egress_build();
		break;
#ifdef INET6
	case AF_INET6:
		if (IN6_ARE_ADDR_EQUAL(&(satosin6(dst))->sin6_addr,
		    &in6addr_any) && mask && (mask->sa_len == 0 ||
		    IN6_ARE_ADDR_EQUAL(&(satosin6(mask))->sin6_addr,
		    &in6addr_any)))
			if_group_egress_build();
		break;
#endif
	}
}

int
if_group_egress_build(void)
{
	struct ifnet		*ifp;
	struct ifg_group	*ifg;
	struct ifg_member	*ifgm, *next;
	struct sockaddr_in	 sa_in;
#ifdef INET6
	struct sockaddr_in6	 sa_in6;
#endif
	struct rtentry		*rt;

	TAILQ_FOREACH(ifg, &ifg_head, ifg_next)
		if (!strcmp(ifg->ifg_group, IFG_EGRESS))
			break;

	if (ifg != NULL)
		TAILQ_FOREACH_SAFE(ifgm, &ifg->ifg_members, ifgm_next, next)
			if_delgroup(ifgm->ifgm_ifp, IFG_EGRESS);

	bzero(&sa_in, sizeof(sa_in));
	sa_in.sin_len = sizeof(sa_in);
	sa_in.sin_family = AF_INET;
	rt = rtable_lookup(0, sintosa(&sa_in), sintosa(&sa_in), NULL, RTP_ANY);
	while (rt != NULL) {
		ifp = if_get(rt->rt_ifidx);
		if (ifp != NULL) {
			if_addgroup(ifp, IFG_EGRESS);
			if_put(ifp);
		}
		rt = rtable_iterate(rt);
	}

#ifdef INET6
	bcopy(&sa6_any, &sa_in6, sizeof(sa_in6));
	rt = rtable_lookup(0, sin6tosa(&sa_in6), sin6tosa(&sa_in6), NULL,
	    RTP_ANY);
	while (rt != NULL) {
		ifp = if_get(rt->rt_ifidx);
		if (ifp != NULL) {
			if_addgroup(ifp, IFG_EGRESS);
			if_put(ifp);
		}
		rt = rtable_iterate(rt);
	}
#endif /* INET6 */

	return (0);
}

/*
 * Set/clear promiscuous mode on interface ifp based on the truth value
 * of pswitch.  The calls are reference counted so that only the first
 * "on" request actually has an effect, as does the final "off" request.
 * Results are undefined if the "off" and "on" requests are not matched.
 */
int
ifpromisc(struct ifnet *ifp, int pswitch)
{
	struct ifreq ifr;

	if (pswitch) {
		/*
		 * If the device is not configured up, we cannot put it in
		 * promiscuous mode.
		 */
		if ((ifp->if_flags & IFF_UP) == 0)
			return (ENETDOWN);
		if (ifp->if_pcount++ != 0)
			return (0);
		ifp->if_flags |= IFF_PROMISC;
	} else {
		if (--ifp->if_pcount > 0)
			return (0);
		ifp->if_flags &= ~IFF_PROMISC;
		/*
		 * If the device is not configured up, we should not need to
		 * turn off promiscuous mode (device should have turned it
		 * off when interface went down; and will look at IFF_PROMISC
		 * again next time interface comes up).
		 */
		if ((ifp->if_flags & IFF_UP) == 0)
			return (0);
	}
	ifr.ifr_flags = ifp->if_flags;
	return ((*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifr));
}

int
sysctl_mq(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen, struct mbuf_queue *mq)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IFQCTL_LEN:
		return (sysctl_rdint(oldp, oldlenp, newp, mq_len(mq)));
	case IFQCTL_MAXLEN:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &mq->mq_maxlen)); /* XXX directly accessing maxlen */
	case IFQCTL_DROPS:
		return (sysctl_rdint(oldp, oldlenp, newp, mq_drops(mq)));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

void
ifa_add(struct ifnet *ifp, struct ifaddr *ifa)
{
	TAILQ_INSERT_TAIL(&ifp->if_addrlist, ifa, ifa_list);
}

void
ifa_del(struct ifnet *ifp, struct ifaddr *ifa)
{
	TAILQ_REMOVE(&ifp->if_addrlist, ifa, ifa_list);
}

void
ifa_update_broadaddr(struct ifnet *ifp, struct ifaddr *ifa, struct sockaddr *sa)
{
	if (ifa->ifa_broadaddr->sa_len != sa->sa_len)
		panic("ifa_update_broadaddr does not support dynamic length");
	bcopy(sa, ifa->ifa_broadaddr, sa->sa_len);
}

#ifdef DDB
/* debug function, can be called from ddb> */
void
ifa_print_all(void)
{
	struct ifnet *ifp;
	struct ifaddr *ifa;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			char addr[INET6_ADDRSTRLEN];

			switch (ifa->ifa_addr->sa_family) {
			case AF_INET:
				printf("%s", inet_ntop(AF_INET,
				    &satosin(ifa->ifa_addr)->sin_addr,
				    addr, sizeof(addr)));
				break;
#ifdef INET6
			case AF_INET6:
				printf("%s", inet_ntop(AF_INET6,
				    &(satosin6(ifa->ifa_addr))->sin6_addr,
				    addr, sizeof(addr)));
				break;
#endif
			}
			printf(" on %s\n", ifp->if_xname);
		}
	}
}
#endif /* DDB */

void
ifnewlladdr(struct ifnet *ifp)
{
#ifdef INET6
	struct ifaddr *ifa;
#endif
	struct ifreq ifrq;
	short up;
	int s;

	s = splnet();
	up = ifp->if_flags & IFF_UP;

	if (up) {
		/* go down for a moment... */
		ifp->if_flags &= ~IFF_UP;
		ifrq.ifr_flags = ifp->if_flags;
		(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifrq);
	}

	ifp->if_flags |= IFF_UP;
	ifrq.ifr_flags = ifp->if_flags;
	(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifrq);

#ifdef INET6
	/*
	 * Update the link-local address.  Don't do it if we're
	 * a router to avoid confusing hosts on the network.
	 */
	if (!ip6_forwarding) {
		ifa = &in6ifa_ifpforlinklocal(ifp, 0)->ia_ifa;
		if (ifa) {
			in6_purgeaddr(ifa);
			dohooks(ifp->if_addrhooks, 0);
			in6_ifattach(ifp);
		}
	}
#endif
	if (!up) {
		/* go back down */
		ifp->if_flags &= ~IFF_UP;
		ifrq.ifr_flags = ifp->if_flags;
		(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifrq);
	}
	splx(s);
}

int net_ticks;
u_int net_livelocks;

void
net_tick(void *null)
{
	extern int ticks;

	if (ticks - net_ticks > 1)
		net_livelocks++;

	net_ticks = ticks;

	timeout_add(&net_tick_to, 1);
}

int
net_livelocked(void)
{
	extern int ticks;

	return (ticks - net_ticks > 1);
}

void
if_rxr_init(struct if_rxring *rxr, u_int lwm, u_int hwm)
{
	extern int ticks;

	memset(rxr, 0, sizeof(*rxr));

	rxr->rxr_adjusted = ticks;
	rxr->rxr_cwm = rxr->rxr_lwm = lwm;
	rxr->rxr_hwm = hwm;
}

static inline void
if_rxr_adjust_cwm(struct if_rxring *rxr)
{
	extern int ticks;

	if (net_livelocked()) {
		if (rxr->rxr_cwm > rxr->rxr_lwm)
			rxr->rxr_cwm--;
		else
			return;
	} else if (rxr->rxr_alive >= rxr->rxr_lwm)
		return;
	else if (rxr->rxr_cwm < rxr->rxr_hwm)
		rxr->rxr_cwm++;

	rxr->rxr_adjusted = ticks;
}

u_int
if_rxr_get(struct if_rxring *rxr, u_int max)
{
	extern int ticks;
	u_int diff;

	if (ticks - rxr->rxr_adjusted >= 1) {
		/* we're free to try for an adjustment */
		if_rxr_adjust_cwm(rxr);
	}

	if (rxr->rxr_alive >= rxr->rxr_cwm)
		return (0);

	diff = min(rxr->rxr_cwm - rxr->rxr_alive, max);
	rxr->rxr_alive += diff;

	return (diff);
}

int
if_rxr_info_ioctl(struct if_rxrinfo *uifri, u_int t, struct if_rxring_info *e)
{
	struct if_rxrinfo kifri;
	int error;
	u_int n;

	error = copyin(uifri, &kifri, sizeof(kifri));
	if (error)
		return (error);

	n = min(t, kifri.ifri_total);
	kifri.ifri_total = t;

	if (n > 0) {
		error = copyout(e, kifri.ifri_entries, sizeof(*e) * n);
		if (error)
			return (error);
	}

	return (copyout(&kifri, uifri, sizeof(kifri)));
}

int
if_rxr_ioctl(struct if_rxrinfo *ifri, const char *name, u_int size,
    struct if_rxring *rxr)
{
	struct if_rxring_info ifr;

	memset(&ifr, 0, sizeof(ifr));

	if (name != NULL)
		strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));

	ifr.ifr_size = size;
	ifr.ifr_info = *rxr;

	return (if_rxr_info_ioctl(ifri, 1, &ifr));
}

/*
 * Network stack input queues.
 */

void
niq_init(struct niqueue *niq, u_int maxlen, u_int isr)
{
	mq_init(&niq->ni_q, maxlen, IPL_NET);
	niq->ni_isr = isr;
}

int
niq_enqueue(struct niqueue *niq, struct mbuf *m)
{
	int rv;

	rv = mq_enqueue(&niq->ni_q, m);
	if (rv == 0)
		schednetisr(niq->ni_isr);
	else
		if_congestion();

	return (rv);
}

int
niq_enlist(struct niqueue *niq, struct mbuf_list *ml)
{
	int rv;

	rv = mq_enlist(&niq->ni_q, ml);
	if (rv == 0)
		schednetisr(niq->ni_isr);
	else
		if_congestion();

	return (rv);
}

__dead void
unhandled_af(int af)
{
	panic("unhandled af %d", af);
}
@


1.491
log
@Revert the NET_LOCK() and bring back pf's contention lock for release.

For the moment the NET_LOCK() is always taken by threads running under
KERNEL_LOCK().  That means it doesn't buy us anything except a possible
deadlock that we did not spot.  So make sure this doesn't happen, we'll
have plenty of time in the next release cycle to stress test it.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.490 2017/03/08 09:19:45 mpi Exp $	*/
d1511 1
a1511 1
	microtime(&ifp->if_lastchange);
d1530 1
a1530 1
	microtime(&ifp->if_lastchange);
d2161 1
a2161 1
		microtime(&ifp->if_lastchange);
@


1.490
log
@Do not unset IFF_UP twice.

ok stsp@@, claudio@@, mikeb@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.489 2017/03/06 08:56:39 mpi Exp $	*/
a232 6
 * Serialize socket operations to ensure no new sleeping points
 * are introduced in IP output paths.
 */
struct rwlock netlock = RWLOCK_INITIALIZER("netlock");

/*
a1148 2
	/* XXXSMP breaks atomicity */
	rw_exit_write(&netlock);
a1149 1
	rw_enter_write(&netlock);
a1190 2
	/* XXXSMP breaks atomicity */
	rw_exit_write(&netlock);
a1191 1
	rw_enter_write(&netlock);
@


1.489
log
@Prefix functions dealing with routing messages with 'rtm_' and keep
them all in net/rtsock.c.

This allows to easily spot which functions are doing a copyout(9)
when dealing with the routing midlayer.

ok phessler@@, bluhm@@, dhill@@, krw@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.488 2017/02/28 15:35:02 yasuoka Exp $	*/
a1501 2
		ifp->if_flags &= ~IFF_UP;

@


1.488
log
@Don't change the up status of the interface when changing its rdomain.
Diff from nagasaka@@iij.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.487 2017/02/16 10:15:12 mpi Exp $	*/
d438 1
a438 1
	rt_ifannouncemsg(ifp, IFAN_ARRIVAL);
d1090 1
a1090 1
	rt_ifannouncemsg(ifp, IFAN_DEPARTURE);
d1582 1
a1582 1
	rt_ifmsg(ifp);
d1991 1
a1991 1
		rt_ifmsg(ifp);
d2007 1
a2007 1
			rt_ifmsg(ifp);
@


1.487
log
@Revert "Release the NET_LOCK() before entering per-driver ioctl() routine".

This is most likely to be the cause of the deadlock seen by port builders
since it's the only changed that happened after a2k17.

Instead bring back pirofti@@ original hack to release the NET_LOCK() inside
iwm(4) and iwn(4).

This fixes some splassert reported by bluhm@@

Deadlock reported by naddy@@ and rpe@@ and ajacoutot@@ confirmed the deadlock
has been introduced post a2k17.

Tested by and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.486 2017/02/07 10:08:21 mpi Exp $	*/
d1710 1
a1710 1
	int error;
a1750 2
		int s;

d1758 2
a1759 1
		if (ifp->if_flags & IFF_UP)
d1761 1
d1782 7
@


1.486
log
@Release the NET_LOCK() before entering per-driver ioctl() routine.

This prevents a deadlock with the X server and some wireless drivers.
The real fix is to take unix domain socket code out of the NET_LOCK().

Issue reported by pirofti@@ and ajacoutot@@

ok tb@@, stsp@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.485 2017/02/01 02:02:01 jsg Exp $	*/
a2031 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a2032 1
		rw_enter_write(&netlock);
@


1.485
log
@Take if_attach_common() out from under netlock as it does a bunch
of sleeping mallocs to initialise a new ifp.  The ifp is later
added to the global list with the lock held.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.484 2017/02/01 01:25:19 jsg Exp $	*/
d2032 2
d2035 1
@


1.484
log
@Switch from splsoftnet to taking the netlock in if_attachhead().
The same change was made to if_attach() in rev 1.467.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.483 2017/01/31 12:16:20 mpi Exp $	*/
d516 1
a517 1
	if_attach_common(ifp);
d528 1
a529 1
	if_attach_common(ifp);
@


1.483
log
@Remove the inifioctl hack, checking for an unheld NET_LOCK() in
tsleep(9) & friends seem to only produce false positives and cannot
be easily disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.481 2017/01/25 06:15:50 mpi Exp $	*/
d516 1
a516 1
	s = splsoftnet();
d520 1
a520 1
	splx(s);
@


1.482
log
@Introduce a hack to remove false-positives when looking for memory
allocation that can sleep while holding the NET_LOCK().

To be removed once we're confident the remaining code paths are safe.

Discussed with deraadt@@
@
text
@a236 4
#if 1
/* tsleep() is ok if inside ifioctl(). */
int inifioctl;
#endif
@


1.481
log
@Enable the NET_LOCK(), take 2.

Recursions are currently known and marked a XXXSMP.

Please report any assert to bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.480 2017/01/24 10:08:30 krw Exp $	*/
d237 4
@


1.480
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.479 2017/01/24 03:57:35 dlg Exp $	*/
d233 6
d1155 2
d1158 1
d1200 2
d1203 1
@


1.479
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.478 2017/01/23 11:37:29 mpi Exp $	*/
d1123 1
a1123 1
	    	connected = 1;
@


1.478
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.477 2017/01/23 07:27:21 dlg Exp $	*/
d139 1
a139 1
void	if_detached_start(struct ifnet *);
d164 1
a164 1
void	if_start_locked(struct ifnet *);
d530 26
d561 16
a576 1
	ifq_init(&ifp->if_snd, ifp);
d604 15
d621 2
a622 4
	if (ISSET(ifp->if_xflags, IFXF_MPSAFE))
		ifq_start(&ifp->if_snd);
	else
		if_start_locked(ifp);
a623 1

d625 1
a625 1
if_start_locked(struct ifnet *ifp)
d627 1
d630 9
d641 1
a641 1
	ifp->if_start(ifp);
d649 3
a651 1
	int error = 0;
d667 2
a668 2
	 * Queue message on interface, and start output if interface
	 * not yet active.
d670 4
a673 1
	IFQ_ENQUEUE(&ifp->if_snd, m, error);
d677 1
a677 1
	if_start(ifp);
d1014 1
a1014 1
	ifp->if_start = if_detached_start;
d1088 10
a1097 1
	ifq_destroy(&ifp->if_snd);
d2246 1
d2253 2
a2254 1
	ifq = &ifp->if_snd;
d2256 8
a2263 7
	mtx_enter(&ifq->ifq_mtx);
	opackets += ifq->ifq_packets;
	obytes += ifq->ifq_bytes;
	oqdrops += ifq->ifq_qdrops;
	omcasts += ifq->ifq_mcasts;
	/* ifq->ifq_errors */
	mtx_leave(&ifq->ifq_mtx);
d2278 1
a2278 1
if_detached_start(struct ifnet *ifp)
d2280 1
a2280 1
	IFQ_PURGE(&ifp->if_snd);
@


1.477
log
@i botched the copyout to ifr->ifr_data in SIOCGIFDATA.

this lets pflogd run again.

rename if_data() to if_getdata() while here to make grepping for
things less noisy.

reported by jsg@@
worked through with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.476 2017/01/23 01:26:09 dlg Exp $	*/
d820 2
a821 1
	add_net_randomness(ml_len(&ml));
d1779 1
a1779 1
		ifr->ifr_flags = ifp->if_xflags & ~IFXF_MPSAFE;
@


1.476
log
@merge the ifnet and ifqueue stats together when userland wants them.

a new if_data() function takes a pointer to ifnet and merges its
if_data and ifq statistics. it takes the ifq mutex around the reads
of the ifq stats so they get a consistent copy.

the ifnet and ifq stats are merged because some parts of the stack
still update the ifnet counters.

ok visa@@ (on an earlier diff) mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.475 2017/01/22 10:17:39 dlg Exp $	*/
d1795 2
a1796 2
		if_data(ifp, &ifdata);
		error = copyout(&ifdata, &ifr->ifr_data, sizeof(ifdata));
d2166 1
a2166 1
if_data(struct ifnet *ifp, struct if_data *data)
@


1.475
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.474 2017/01/12 09:07:46 mpi Exp $	*/
d586 1
a586 2
	int length, error = 0;
	unsigned short mflags;
a596 3
	length = m->m_pkthdr.len;
	mflags = m->m_flags;

a608 5
	ifp->if_opackets++;
	ifp->if_obytes += length;
	if (mflags & M_MCAST)
		ifp->if_omcasts++;

d1793 4
a1796 3
	case SIOCGIFDATA:
		error = copyout((caddr_t)&ifp->if_data, ifr->ifr_data,
		    sizeof(ifp->if_data));
d1798 1
d2163 27
@


1.474
log
@Unlink PF state keys before passing mbufs to drivers.

Network drivers shouldn't have to deal with PF data structures.  This change
prevent m_free(9) called from an interrupt handler at IPL_NET to mess with
pf(4) internals.

Prevent an splassert reported by Mark Patruck.

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.473 2017/01/04 03:56:15 dlg Exp $	*/
d613 1
@


1.473
log
@dont assume setting IFF_UP will succeed.

run a drivers ioctl handler and check if it worked before calling
if_up or if_down to report the change. propagate that error up to
userland so ifconfig can report what happened.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.472 2017/01/04 03:42:33 dlg Exp $	*/
d600 4
@


1.472
log
@shuffle the last change slightly.

only check ml_empty the second time if bpf was run and may have
filtered the list.

only call task_add if mq_enlist worked.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.471 2017/01/04 03:12:54 dlg Exp $	*/
d1805 10
a1814 4
		if (ifp->if_flags & IFF_UP && (ifr->ifr_flags & IFF_UP) == 0) {
			s = splnet();
			if_down(ifp);
			splx(s);
d1816 2
a1817 1
		if (ifr->ifr_flags & IFF_UP && (ifp->if_flags & IFF_UP) == 0) {
d1819 4
a1822 1
			if_up(ifp);
a1824 4
		ifp->if_flags = (ifp->if_flags & IFF_CANTCHANGE) |
			(ifr->ifr_flags & ~IFF_CANTCHANGE);
		if (ifp->if_ioctl)
			(void) (*ifp->if_ioctl)(ifp, cmd, data);
@


1.471
log
@make if_input return early if the mbuf list is empty.

this saves doing wakeups of the softnet thread.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.470 2017/01/03 13:11:55 mpi Exp $	*/
d654 3
a657 3

	if (ml_empty(ml))
		return;
d660 2
a661 2
	mq_enlist(&ifp->if_inputqueue, ml);
	task_add(softnettq, ifp->if_inputtask);
@


1.470
log
@Do not trash the original SPL level.

Pointed out by and ok jsg@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.469 2016/12/29 12:12:43 mpi Exp $	*/
d627 3
d655 3
@


1.469
log
@Change NET_LOCK()/NET_UNLOCK() to be simple wrappers around
splsoftnet()/splx() until the known issues are fixed.

In other words, stop using a rwlock since it creates a deadlock when
chrome is used.

Issue reported by Dimitris Papastamos and kettenis@@

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.468 2016/12/21 10:22:14 jca Exp $	*/
d931 1
a931 1
	int i, s;
d939 1
a939 1
	s = splnet();
d1014 1
a1014 1
	splx(s);
@


1.468
log
@Generate an IFINFO message when changing the MTU of an interface.

Helps route(4) listeners to refresh their knowledge of the MTU of
interfaces.  Prompted by a diff for ospfd(8) by Remi Locherer, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.467 2016/12/20 19:34:56 mikeb Exp $	*/
a231 6

/*
 * Serialize socket operations to ensure no new sleeping points
 * are introduced in IP output paths.
 */
struct rwlock netlock = RWLOCK_INITIALIZER("netlock");
a1068 2
	/* XXXSMP breaks atomicity */
	rw_exit_write(&netlock);
a1069 1
	rw_enter_write(&netlock);
a1110 2
	/* XXXSMP breaks atomicity */
	rw_exit_write(&netlock);
a1111 1
	rw_enter_write(&netlock);
@


1.467
log
@Grab the netlock during interface attach and detach.

With help from and OK mpi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.466 2016/12/19 08:36:49 mpi Exp $	*/
d1911 2
@


1.466
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.465 2016/12/12 09:51:30 mpi Exp $	*/
d528 1
a528 1
	s = splsoftnet();
d532 1
a532 1
	splx(s);
d944 1
d1021 1
d1075 2
d1078 1
d1098 1
d1120 6
a1125 1
	return ((*ifc->ifc_destroy)(ifp));
@


1.465
log
@Remove most of the splsoftnet() recursions related to cloned interfaces.

inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.464 2016/12/02 18:32:38 vgross Exp $	*/
d164 1
a164 1
void	if_start_locked(struct ifnet *ifp);
d232 6
d854 1
a854 1
	s = splsoftnet();
d857 6
a862 1
		sched_pause();
d900 1
a900 1
	splx(s);
d1406 1
a1406 1
	s = splnet();
d1419 1
a1419 1
	splx(s);
d1479 1
a1479 1
	s = splsoftnet();
d1481 1
a1481 1
	splx(s);
d1489 1
a1489 1
	splsoftassert(IPL_SOFTNET);
@


1.464
log
@Clean up leftovers from r1.442.

Local var 'up' is never set in ifioctl().

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.463 2016/11/28 11:18:02 mpi Exp $	*/
d136 2
d407 2
d508 3
d514 1
d520 3
d526 1
d1051 3
a1053 1
	int unit, ret, s;
a1061 1
	s = splsoftnet();
a1062 1
	splx(s);
d1082 2
a1083 1
	int error, s;
d1097 1
d1103 1
a1103 4
	s = splsoftnet();
	error = (*ifc->ifc_destroy)(ifp);
	splx(s);
	return (error);
d1608 1
a1608 1
	int s, error;
a1631 2

		s = splsoftnet();
a1633 1
		splx(s);
d1649 2
@


1.463
log
@Remove simple recursive splsoftnet() calls inside ifioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.462 2016/11/21 09:09:06 mpi Exp $	*/
a1690 1
	short up = 0;
a2047 6
	/* If we took down the IF, bring it back */
	if (up) {
		s = splnet();
		if_up(ifp);
		splx(s);
	}
@


1.462
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.461 2016/11/14 10:52:04 mpi Exp $	*/
d1728 1
a1728 2
			if (cmd == SIOCIFAFDETACH) {
				s = splsoftnet();
a1729 2
				splx(s);
			}
a1732 1
			s = splsoftnet();
a1736 1
			splx(s);
a1801 1
			s = splsoftnet();
a1802 1
			splx(s);
a1864 1
		s = splsoftnet();
a1865 1
		splx(s);
a2039 1
		s = splsoftnet();
a2042 1
		splx(s);
@


1.461
log
@Automatically set ::1 on all default lo(4) interfaces.

Prodded by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.460 2016/11/14 10:44:17 mpi Exp $	*/
d2049 1
d2053 1
@


1.460
log
@It should be possible to create the default loopback interface.

Make rdomain's default loopback test pass again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.459 2016/11/14 10:32:46 mpi Exp $	*/
d1434 2
a1435 2
	/* Userland expects the kernel to set ::1 on lo0. */
	if (ifp->if_index == rtable_loindex(0))
@


1.459
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.458 2016/11/08 10:47:10 mpi Exp $	*/
d1612 1
a1612 2
		if ((error = if_clone_create(loifname, 0)))
			return (error);
d1616 5
@


1.458
log
@No longer need radix.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.457 2016/11/08 10:46:04 mpi Exp $	*/
a260 1
unsigned int lo0ifidx;
d1352 1
a1352 6
		/*
		 * XXX Since lo0 is in the default rdomain we should not
		 * (ab)use it for any route related to an interface of a
		 * different rdomain.
		 */
		lo0ifp = if_get(lo0ifidx);
d1435 1
a1435 1
	if (ifp->if_index == lo0ifidx)
d1602 4
a1605 1
	/* make sure that the routing table exists */
d1607 11
d1620 1
a1620 1
			rtable_l2set(rdomain, rdomain);
d1622 2
a1623 1
		if (error)
d1625 3
@


1.457
log
@RIP ifa_ifwithnet()

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.456 2016/10/19 02:05:49 yasuoka Exp $	*/
a95 1
#include <net/radix.h>	/* for rn_refines */
@


1.456
log
@Remove the if_input task from the correct taskq.

ok bluhm henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.455 2016/10/16 21:45:17 bluhm Exp $	*/
a1281 41
}

/*
 * Find an interface on a specific network.  If many, choice
 * is most specific found.
 */
struct ifaddr *
ifa_ifwithnet(struct sockaddr *sa, u_int rtableid)
{
	struct ifnet *ifp;
	struct ifaddr *ifa, *ifa_maybe = NULL;
	char *cplim, *addr_data = sa->sa_data;
	u_int rdomain;

	KERNEL_ASSERT_LOCKED();
	rdomain = rtable_l2(rtableid);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rdomain)
			continue;
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			char *cp, *cp2, *cp3;

			if (ifa->ifa_addr->sa_family != sa->sa_family ||
			    ifa->ifa_netmask == 0)
				next: continue;
			cp = addr_data;
			cp2 = ifa->ifa_addr->sa_data;
			cp3 = ifa->ifa_netmask->sa_data;
			cplim = (char *)ifa->ifa_netmask +
				ifa->ifa_netmask->sa_len;
			while (cp3 < cplim)
				if ((*cp++ ^ *cp2++) & *cp3++)
				    /* want to continue for() loop */
					goto next;
			if (ifa_maybe == 0 ||
			    rn_refines((caddr_t)ifa->ifa_netmask,
			    (caddr_t)ifa_maybe->ifa_netmask))
				ifa_maybe = ifa;
		}
	}
	return (ifa_maybe);
@


1.455
log
@m_resethdr() clears information attached to a mbuf that has been
accumulated during processing, especially pf(4) data is removed.
When a packet is reinserted to local input processing, we have to
start from scratch with a clean mbuf header.  Also the packet has
to be in the routing doamin of the interface where it is inserted.
Incoming packet with stale inp pointer seen by patrick@@ on lo(4);
OK sashan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.454 2016/10/09 20:05:10 claudio Exp $	*/
d932 1
a932 1
	task_del(systq, ifp->if_inputtask);
@


1.454
log
@This needs radix.h because it uses rn_refines().
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.453 2016/10/07 08:18:22 rzalamena Exp $	*/
d668 1
d670 1
@


1.453
log
@Use detach hook to notify switch(4) about interface removals instead of
adding code to if.c.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.452 2016/10/03 12:26:13 rzalamena Exp $	*/
d96 1
@


1.452
log
@Use detach hook to notify bridge of interface removal instead of adding
code to if.c.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.451 2016/09/28 08:31:42 rzalamena Exp $	*/
a132 4
#if NSWITCH > 0
#include <net/if_switch.h>
#endif

a892 5

#if NSWITCH > 0
	if (ifp->if_switchport)
		switch_port_detach(ifp);
#endif
@


1.451
log
@Fix a kernel panic that happened when destroying interfaces attached to
the switch(4) without prior removal.

ok reyk@@, goda@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.450 2016/09/22 14:50:11 mpi Exp $	*/
a896 6

#if NBRIDGE > 0
	/* Remove the interface from any bridge it is part of.  */
	if (ifp->if_bridgeport)
		bridge_ifdetach(ifp);
#endif
@


1.450
log
@Raise spl level to IPL_SOFTNET before calling rt_ifmsg().

From dhill@@, found the hardway by semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.449 2016/09/20 16:14:43 mikeb Exp $	*/
d133 4
d902 5
@


1.449
log
@Create and destroy cloneable interfaces under splsoftnet

With and ok mpi, tested by David Hill and tb@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.448 2016/09/13 08:15:01 mpi Exp $	*/
d1901 1
d1903 1
@


1.448
log
@Split if_linkstate_task() in two to avoid SPL recursion when the
linkstate is changed from if_up() & if_down().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.447 2016/09/08 09:13:10 mpi Exp $	*/
d1044 1
a1044 1
	int unit, ret;
d1053 5
a1057 2
	if ((ret = (*ifc->ifc_create)(ifc, unit)) != 0 ||
	    (ifp = ifunit(name)) == NULL)
d1075 1
a1075 1
	int s;
d1094 4
a1097 1
	return ((*ifc->ifc_destroy)(ifp));
@


1.447
log
@Replace two if/do/while dances by while loops.

Requested by and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.446 2016/09/07 09:36:49 mpi Exp $	*/
d145 1
a1451 1
	unsigned long ifidx = ifp->if_index;
d1463 1
a1463 1
	if_linkstate_task((void *)ifidx);
a1472 1
	unsigned long ifidx = ifp->if_index;
d1484 1
a1484 1
	if_linkstate_task((void *)ifidx);
d1503 11
a1518 3
	splx(s);

	if_put(ifp);
@


1.446
log
@Rename rtable_mpath_next() into rtable_iterate() and make it do a proper
reference count.

rtable_iterate() frees the passed ``rt'' and returns the next one on the
multipath list or NULL if there's none.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.445 2016/09/05 13:09:32 claudio Exp $	*/
d2464 7
a2470 9
	if (rt != NULL) {
		do {
			ifp = if_get(rt->rt_ifidx);
			if (ifp != NULL) {
				if_addgroup(ifp, IFG_EGRESS);
				if_put(ifp);
			}
			rt = rtable_iterate(rt);
		} while (rt != NULL);
d2477 7
a2483 9
	if (rt != NULL) {
		do {
			ifp = if_get(rt->rt_ifidx);
			if (ifp != NULL) {
				if_addgroup(ifp, IFG_EGRESS);
				if_put(ifp);
			}
			rt = rtable_iterate(rt);
		} while (rt != NULL);
@


1.445
log
@Rename if_linkstate() to if_linkstate_task() and make sure that all callers
pass the ifindex to that function and not the ifp. This fixes the missing
link state change messages on if_up and if_down. This is a fix for Rev 1.444
which introduced this problem.
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.444 2016/09/04 17:14:58 mpi Exp $	*/
d2450 1
a2450 1
	struct rtentry		*rt0, *rt;
d2463 2
a2464 3
	rt0 = rtable_lookup(0, sintosa(&sa_in), sintosa(&sa_in), NULL, RTP_ANY);
	if (rt0 != NULL) {
		rt = rt0;
d2471 1
a2471 5
#ifndef SMALL_KERNEL
			rt = rtable_mpath_next(rt);
#else
			rt = NULL;
#endif
a2473 1
	rtfree(rt0);
d2477 1
a2477 1
	rt0 = rtable_lookup(0, sin6tosa(&sa_in6), sin6tosa(&sa_in6), NULL,
d2479 1
a2479 2
	if (rt0 != NULL) {
		rt = rt0;
d2486 1
a2486 5
#ifndef SMALL_KERNEL
			rt = rtable_mpath_next(rt);
#else
			rt = NULL;
#endif
a2488 1
	rtfree(rt0);
@


1.444
log
@Prevent a race between a thread detaching an interface and the watchdog
or linkstate task sleeping.

Pass an index to the task and use if_get(9) if the ifp is still alive.

Found the hardway by awolk@@.

ok claudio@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.443 2016/09/04 15:46:39 reyk Exp $	*/
d145 1
a145 1
void	if_linkstate(void *);
d425 1
a425 1
	task_set(ifp->if_linkstatetask, if_linkstate, (void *)ifidx);
d1451 1
d1463 1
a1463 1
	if_linkstate(ifp);
d1473 1
d1485 1
a1485 1
	if_linkstate(ifp);
d1493 1
a1493 1
if_linkstate(void *xifidx)
@


1.443
log
@When auto-creating an interface when opening a /dev/{tun,tap,switch}
device, inherit the rdomain from the calling process.  This adds an
rdomain argument to if_clone_create().

OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.442 2016/09/04 15:10:59 reyk Exp $	*/
d403 2
a413 1
	task_set(ifp->if_watchdogtask, if_watchdog_task, ifp);
a416 2
	task_set(ifp->if_linkstatetask, if_linkstate, ifp);

d420 2
d423 3
a425 2
	task_set(ifp->if_inputtask, if_input_process,
	    (void *)(unsigned long)ifp->if_index);
d1491 1
a1491 1
if_linkstate(void *xifp)
d1493 2
a1494 1
	struct ifnet *ifp = xifp;
d1497 4
d1508 2
d1541 1
a1541 1
if_watchdog_task(void *arg)
d1543 2
a1544 1
	struct ifnet *ifp = arg;
d1547 4
d1555 2
@


1.442
log
@Move code to change the rdomain of an interface from the ioctl switch case
to a new function if_setrdomain().

OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.441 2016/09/04 10:32:01 mpi Exp $	*/
d1037 1
a1037 1
if_clone_create(const char *name)
d1050 7
a1056 3
	if ((ret = (*ifc->ifc_create)(ifc, unit)) == 0 &&
	    (ifp = ifunit(name)) != NULL)
		if_addgroup(ifp, ifc->ifc_name);
d1704 1
a1704 1
		    if_clone_create(ifr->ifr_name) :
@


1.441
log
@Purge routes attached to an address when this address is removed.

This is done to stop using stale ifa attached to routes, which is
the easiest way to make rtisvalid(9) MP-safe.

sthen@@ and henning@@ like it, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.440 2016/09/03 10:05:19 mpi Exp $	*/
d1609 59
d1972 1
a1972 45
		if (ifr->ifr_rdomainid < 0 ||
		    ifr->ifr_rdomainid > RT_TABLEID_MAX)
			return (EINVAL);

		/* make sure that the routing table exists */
		if (!rtable_exists(ifr->ifr_rdomainid)) {
			s = splsoftnet();
			if ((error = rtable_add(ifr->ifr_rdomainid)) == 0)
				rtable_l2set(ifr->ifr_rdomainid, ifr->ifr_rdomainid);
			splx(s);
			if (error)
				return (error);
		}

		/* make sure that the routing table is a real rdomain */
		if (ifr->ifr_rdomainid != rtable_l2(ifr->ifr_rdomainid))
			return (EINVAL);

		/* remove all routing entries when switching domains */
		/* XXX hell this is ugly */
		if (ifr->ifr_rdomainid != ifp->if_rdomain) {
			s = splnet();
			if (ifp->if_flags & IFF_UP)
				up = 1;
			/*
			 * We are tearing down the world.
			 * Take down the IF so:
			 * 1. everything that cares gets a message
			 * 2. the automagic IPv6 bits are recreated
			 */
			if (up)
				if_down(ifp);
			rti_delete(ifp);
#ifdef MROUTING
			vif_delete(ifp);
#endif
			in_ifdetach(ifp);
#ifdef INET6
			in6_ifdetach(ifp);
#endif
			splx(s);
		}

		/* Let devices like enc(4) or mpe(4) know about the change */
		if ((error = (*ifp->if_ioctl)(ifp, cmd, data)) != ENOTTY)
a1973 4
		error = 0;

		/* Add interface to the specified rdomain */
		ifp->if_rdomain = ifr->ifr_rdomainid;
@


1.440
log
@Remove routes added by the kernel before userland ones.

This is a correctness change that will allow us to check that
nothing happend with kernel added routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.439 2016/09/03 09:55:44 mpi Exp $	*/
a956 1
	rt_if_remove(ifp);
a1952 1
			rt_if_remove(ifp);
@


1.439
log
@Use per-ifp tasks to process incoming packets.

Reduce the number of if_get/if_put from one per packet to one per ring
since we now know that all the packets are coming from the same interface.

Improve forwarding performances by 10Kpps in Hrvoje Popovski's test setup.

ok bluhm@@, henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.438 2016/09/01 10:06:33 goda Exp $	*/
a944 1
	rt_if_remove(ifp);
d957 1
a1945 1
			rt_if_remove(ifp);
d1950 1
d1954 1
a1954 1
			in_ifdetach(ifp);
@


1.438
log
@Import switch(4), an in-kernel OpenFlow switch which can work alone.
switch(4) currently supports OpenFlow 1.3.5.
Currently, it's disabled by the kernel config.

With help from yasuoka@@ reyk@@ jsg@@.

ok deraadt@@ yasuoka@@ reyk@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.437 2016/08/11 00:58:22 dlg Exp $	*/
a226 2
struct mbuf_queue if_input_queue = MBUF_QUEUE_INITIALIZER(8192, IPL_NET);
struct task if_input_task = TASK_INITIALIZER(if_input_process, &if_input_queue);
d421 4
d541 2
d640 2
a641 2
	mq_enlist(&if_input_queue, ml);
	task_add(softnettq, &if_input_task);
d784 1
a784 1
if_input_process(void *xmq)
d786 1
a786 1
	struct mbuf_queue *mq = xmq;
d794 5
a798 1
	mq_delist(mq, &ml);
d800 1
a800 1
		return;
a805 6
		ifp = if_get(m->m_pkthdr.ph_ifidx);
		if (ifp == NULL) {
			m_freem(m);
			continue;
		}

a817 2

		if_put(ifp);
d820 3
d931 4
d989 1
@


1.437
log
@take TASKQ_CANTSLEEP way from the softnet taskq.

the big reason for this is to let us use rw locks in the network
stack, which is how at least two major efforts outside the tree
have approached making pf mpsafe.

this was discussed at length at n2k16. there was general agreement
that this is necessary for us to move smp work forward in the stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.436 2016/07/13 16:45:19 mpi Exp $	*/
d72 1
d853 4
@


1.436
log
@Move ARP processing back to the KERNEL_LOCK()ed task until the race
triggered by updating a cached, but removed from the table, entry is
properly fixed.

Diff from dlg@@, prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.435 2016/07/12 09:33:13 mpi Exp $	*/
d244 1
a244 2
	softnettq = taskq_create("softnet", 1, IPL_NET,
	    TASKQ_MPSAFE | TASKQ_CANTSLEEP);
@


1.435
log
@Directly drop packets filtered by bpf(4) instead of going through the
input handlers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.434 2016/06/10 20:33:29 vgross Exp $	*/
d836 4
@


1.434
log
@Add the "llprio" field to struct ifnet, and the corresponding keyword
to ifconfig.

"llprio" allows one to set the priority of packets that do not go through
pf(4), as the case is for arp(4) or bpf(4).

ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.433 2016/05/18 03:46:03 dlg Exp $	*/
d621 12
a632 3
		MBUF_LIST_FOREACH(ml, m)
			if (bpf_mtap_ether(if_bpf, m, BPF_DIRECTION_IN) != 0)
				m->m_flags |= M_FILDROP;
@


1.433
log
@rework the srp api so it takes an srp_ref struct that the caller provides.

the srp_ref struct is used to track the location of the callers
hazard pointer so later calls to srp_follow and srp_enter already
know what to clear. this in turn means most of the caveats around
using srps go away. specifically, you can now:

- switch cpus while holding an srp ref
  - ie, you can sleep while holding an srp ref
- you can take and release srp refs in any order

the original intent was to simplify use of the api when dealing
with complicated data structures. the caller now no longer has to
track the location of the srp a value was fetched from, the srp_ref
effectively does that for you.

srp lists have been refactored to use srp_refs instead of srpl_iter
structs.

this is in preparation of using srps inside the ART code. ART is a
complicated data structure, and lookups require overlapping holds
of srp references.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.432 2016/05/10 06:37:15 dlg Exp $	*/
d539 1
d1990 12
@


1.432
log
@make bpf_mtap callers set the M_FILDROP flag if they care about it.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.431 2016/05/08 08:58:27 mpi Exp $	*/
d777 1
a777 1
	struct srpl_iter i;
d798 1
a798 1
		SRPL_FOREACH(ifih, &ifp->if_inputs, &i, ifih_next) {
d802 1
a802 1
		SRPL_LEAVE(&i, ifih);
d1535 1
d1540 1
a1540 1
	if_map = srp_enter(&if_idxmap.map);
d1544 1
a1544 1
		ifp = srp_follow(&if_idxmap.map, if_map, &map[index]);
d1549 2
a1550 3
		srp_leave(&map[index], ifp);
	} else
		srp_leave(&if_idxmap.map, if_map);
@


1.431
log
@Do not export the IFXF_MPSAFE flag to userland, it is a kernel-only
hint.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.430 2016/05/03 14:52:39 mpi Exp $	*/
d621 2
a622 1
			bpf_mtap_ether(if_bpf, m, BPF_DIRECTION_IN);
@


1.430
log
@Stop using a soft-interrupt context to process incoming network packets.

Use a new task that runs holding the KERNEL_LOCK to execute mp-unsafe
code.  Our current goal is to progressively move input functions to the
unlocked task.

This gives a small performance boost confirmed by Hrvoje Popovski's
IPv4 forwarding measurement:

before:					after:

send           receive			send           receive
400kpps        400kpps                  400kpps        400kpps
500kpps        500kpps                  500kpps        500kpps
600kpps        600kpps                  600kpps        600kpps
650kpps        650kpps                  650kpps        640kpps
700kpps        700kpps                  700kpps        700kpps
720kpps        640kpps                  720kpps        710kpps
800kpps        640kpps                  800kpps        650kpps
1.4Mpps        570kpps                  1.4Mpps        590kpps
14Mpps         570kpps                  14Mpps         590kpps


ok kettenis@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.429 2016/03/16 12:08:09 dlg Exp $	*/
d1671 1
a1671 1
		ifr->ifr_flags = ifp->if_xflags;
@


1.429
log
@if ticks diverge from ifq_congestion too far the diff will go negative

detect this and bump ifq_congestion forward rather than claim the
system is congested for a long period of time.

ok mpi@@ henning@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.428 2016/03/07 18:44:00 naddy Exp $	*/
d67 1
d69 3
a72 1
#include "ether.h"
d154 1
d223 6
a228 1
struct taskq *softnettq;
a231 3
 *
 * Routines with ifa_ifwith* names take sockaddr *'s as
 * parameters.
a598 3
struct mbuf_queue if_input_queue = MBUF_QUEUE_INITIALIZER(8192, IPL_NET);
struct task if_input_task = TASK_INITIALIZER(if_input_process, &if_input_queue);

d809 44
@


1.428
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.427 2016/03/02 00:00:16 dlg Exp $	*/
d1133 1
d1135 7
a1141 1
	return (ticks - ifq_congestion <= (hz / 100));
@


1.427
log
@provide generic ioctls for managing an interfaces parent

in the future this will subsume the individual vlandev, carpdev,
pppoedev, foodev options for things like vlan, carp, pppoe, etc.

inspired by vnetid

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.426 2016/02/28 15:46:19 naddy Exp $	*/
d228 1
a228 1
ifinit()
d2558 1
a2558 1
net_livelocked()
@


1.426
log
@Support for running Linux binaries under emulation is going away.

Remove "option COMPAT_LINUX" and everything directly tied to it from the
kernel and the corresponding man page documentation.

ok visa@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.425 2015/12/09 03:22:39 dlg Exp $	*/
d1757 2
d1770 1
@


1.425
log
@rework the if_start mpsafe serialisation so it can serialise arbitrary work

work is represented by struct task.

the start routine is now wrapped by a task which is serialised by the
infrastructure. if_start_barrier has been renamed to ifq_barrier and
is now implemented as a task that gets serialised with the start
routine.

this also adds an ifq_restart() function. it serialises a call to
ifq_clr_oactive and calls the start routine again. it exists to
avoid a race that kettenis@@ identified in between when a start
routine discovers theres no space left on a ring, and when it calls
ifq_set_oactive. if the txeof side of the driver empties the ring
and calls ifq_clr_oactive in between the above calls in start, the
queue will be marked oactive and the stack will never call the start
routine again.

by serialising the ifq_set_oactive call in the start routine and
ifq_clr_oactive calls we avoid that race.

tested on various nics
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.424 2015/12/08 10:18:56 mpi Exp $	*/
a1550 3
#ifdef COMPAT_LINUX
	case OSIOCGIFCONF:
#endif
a1979 3
#ifdef COMPAT_LINUX
					if (cmd != OSIOCGIFCONF)
#endif
a2007 10
#ifdef COMPAT_LINUX
				if (cmd == OSIOCGIFCONF) {
					ifr.ifr_addr = *sa;
					*(u_int16_t *)&ifr.ifr_addr =
					    sa->sa_family;
					error = copyout((caddr_t)&ifr,
					    (caddr_t)ifrp, sizeof (ifr));
					ifrp++;
				} else
#endif
@


1.424
log
@Kill unused iftxlist.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.423 2015/12/08 10:06:12 dlg Exp $	*/
a155 1
void	if_start_mpsafe(struct ifnet *ifp);
d513 1
a513 1
	ifq_init(&ifp->if_snd);
d541 1
a541 1
		if_start_mpsafe(ifp);
@


1.423
log
@split the interface send queue (struct ifqueue) implementation out.

the intention is to make it more clear what belongs to a transmit
queue and what belongs to an interface.

suggested by and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.422 2015/12/05 10:07:55 tedu Exp $	*/
a256 1
struct ifnet_head iftxlist = TAILQ_HEAD_INITIALIZER(iftxlist);
@


1.422
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.421 2015/12/04 11:50:01 mpi Exp $	*/
a559 62
static inline unsigned int
ifq_enter(struct ifqueue *ifq)
{
	return (atomic_inc_int_nv(&ifq->ifq_serializer) == 1);
}

static inline unsigned int
ifq_leave(struct ifqueue *ifq)
{
	if (atomic_cas_uint(&ifq->ifq_serializer, 1, 0) == 1)
		return (1);

	ifq->ifq_serializer = 1;

	return (0);
}

void
if_start_mpsafe(struct ifnet *ifp)
{
	struct ifqueue *ifq = &ifp->if_snd;

	if (!ifq_enter(ifq))
		return;

	do {
		if (__predict_false(!ISSET(ifp->if_flags, IFF_RUNNING))) {
			ifq->ifq_serializer = 0;
			wakeup_one(&ifq->ifq_serializer);
			return;
		}

		if (ifq_empty(ifq) || ifq_is_oactive(ifq))
			continue;

		ifp->if_start(ifp);

	} while (!ifq_leave(ifq));
}

void
if_start_barrier(struct ifnet *ifp)
{
	struct sleep_state sls;
	struct ifqueue *ifq = &ifp->if_snd;

	/* this should only be called from converted drivers */
	KASSERT(ISSET(ifp->if_xflags, IFXF_MPSAFE));

	/* drivers should only call this on the way down */
	KASSERT(!ISSET(ifp->if_flags, IFF_RUNNING));

	if (ifq->ifq_serializer == 0)
		return;

	if_start_mpsafe(ifp); /* spin the wheel to guarantee a wakeup */
	do {
		sleep_setup(&sls, &ifq->ifq_serializer, PWAIT, "ifbar");
		sleep_finish(&sls, ifq->ifq_serializer != 0);
	} while (ifq->ifq_serializer != 0);
}

a2706 305
}

/*
 * send queues.
 */

void		*priq_alloc(void *);
void		 priq_free(void *);
int		 priq_enq(struct ifqueue *, struct mbuf *);
struct mbuf	*priq_deq_begin(struct ifqueue *, void **);
void		 priq_deq_commit(struct ifqueue *, struct mbuf *, void *);
void		 priq_purge(struct ifqueue *, struct mbuf_list *);

const struct ifq_ops priq_ops = {
	priq_alloc,
	priq_free,
	priq_enq,
	priq_deq_begin,
	priq_deq_commit,
	priq_purge,
};

const struct ifq_ops * const ifq_priq_ops = &priq_ops;

struct priq_list {
	struct mbuf		*head;
	struct mbuf		*tail;
};

struct priq {
	struct priq_list	 pq_lists[IFQ_NQUEUES];
};

void *
priq_alloc(void *null)
{
	return (malloc(sizeof(struct priq), M_DEVBUF, M_WAITOK | M_ZERO));
}

void
priq_free(void *pq)
{
	free(pq, M_DEVBUF, sizeof(struct priq));
}

int
priq_enq(struct ifqueue *ifq, struct mbuf *m)
{
	struct priq *pq;
	struct priq_list *pl;

	if (ifq_len(ifq) >= ifq->ifq_maxlen)
		return (ENOBUFS);

	pq = ifq->ifq_q;
	KASSERT(m->m_pkthdr.pf.prio <= IFQ_MAXPRIO);
	pl = &pq->pq_lists[m->m_pkthdr.pf.prio];

	m->m_nextpkt = NULL;
	if (pl->tail == NULL)
		pl->head = m;
	else
		pl->tail->m_nextpkt = m;
	pl->tail = m;

	return (0);
}

struct mbuf *
priq_deq_begin(struct ifqueue *ifq, void **cookiep)
{
	struct priq *pq = ifq->ifq_q;
	struct priq_list *pl;
	unsigned int prio = nitems(pq->pq_lists);
	struct mbuf *m;

	do {
		pl = &pq->pq_lists[--prio];
		m = pl->head;
		if (m != NULL) {
			*cookiep = pl;
			return (m);
		}
	} while (prio > 0);

	return (NULL);
}

void
priq_deq_commit(struct ifqueue *ifq, struct mbuf *m, void *cookie)
{
	struct priq_list *pl = cookie;

	KASSERT(pl->head == m);

	pl->head = m->m_nextpkt;
	m->m_nextpkt = NULL;

	if (pl->head == NULL)
		pl->tail = NULL;
}

void
priq_purge(struct ifqueue *ifq, struct mbuf_list *ml)
{
	struct priq *pq = ifq->ifq_q;
	struct priq_list *pl;
	unsigned int prio = nitems(pq->pq_lists);
	struct mbuf *m, *n;

	do {
		pl = &pq->pq_lists[--prio];

		for (m = pl->head; m != NULL; m = n) {
			n = m->m_nextpkt;
			ml_enqueue(ml, m);
		}

		pl->head = pl->tail = NULL;
	} while (prio > 0);
}

int
ifq_enqueue_try(struct ifqueue *ifq, struct mbuf *m)
{
	int rv;

	mtx_enter(&ifq->ifq_mtx);
	rv = ifq->ifq_ops->ifqop_enq(ifq, m);
	if (rv == 0)
		ifq->ifq_len++;
	else
		ifq->ifq_drops++;
	mtx_leave(&ifq->ifq_mtx);

	return (rv);
}

int
ifq_enqueue(struct ifqueue *ifq, struct mbuf *m)
{
	int err;

	err = ifq_enqueue_try(ifq, m);
	if (err != 0)
		m_freem(m);

	return (err);
}

struct mbuf *
ifq_deq_begin(struct ifqueue *ifq)
{
	struct mbuf *m = NULL;
	void *cookie;

	mtx_enter(&ifq->ifq_mtx);
	if (ifq->ifq_len == 0 ||
	    (m = ifq->ifq_ops->ifqop_deq_begin(ifq, &cookie)) == NULL) {
		mtx_leave(&ifq->ifq_mtx);
		return (NULL);
	}

	m->m_pkthdr.ph_cookie = cookie;

	return (m);
}

void
ifq_deq_commit(struct ifqueue *ifq, struct mbuf *m)
{
	void *cookie;

	KASSERT(m != NULL);
	cookie = m->m_pkthdr.ph_cookie;

	ifq->ifq_ops->ifqop_deq_commit(ifq, m, cookie);
	ifq->ifq_len--;
	mtx_leave(&ifq->ifq_mtx);
}

void
ifq_deq_rollback(struct ifqueue *ifq, struct mbuf *m)
{
	KASSERT(m != NULL);

	mtx_leave(&ifq->ifq_mtx);
}

struct mbuf *
ifq_dequeue(struct ifqueue *ifq)
{
	struct mbuf *m;

	m = ifq_deq_begin(ifq);
	if (m == NULL)
		return (NULL);

	ifq_deq_commit(ifq, m);

	return (m);
}

unsigned int
ifq_purge(struct ifqueue *ifq)
{
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	unsigned int rv;

	mtx_enter(&ifq->ifq_mtx);
	ifq->ifq_ops->ifqop_purge(ifq, &ml);
	rv = ifq->ifq_len;
	ifq->ifq_len = 0;
	ifq->ifq_drops += rv;
	mtx_leave(&ifq->ifq_mtx);

	KASSERT(rv == ml_len(&ml));

	ml_purge(&ml);

	return (rv);
}

void
ifq_init(struct ifqueue *ifq)
{
	mtx_init(&ifq->ifq_mtx, IPL_NET);
	ifq->ifq_drops = 0;

	/* default to priq */
	ifq->ifq_ops = &priq_ops;
	ifq->ifq_q = priq_ops.ifqop_alloc(NULL);

	ifq->ifq_serializer = 0;
	ifq->ifq_len = 0;

	if (ifq->ifq_maxlen == 0)
		ifq_set_maxlen(ifq, IFQ_MAXLEN);
}

void
ifq_attach(struct ifqueue *ifq, const struct ifq_ops *newops, void *opsarg)
{
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf_list free_ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	const struct ifq_ops *oldops;
	void *newq, *oldq;

	newq = newops->ifqop_alloc(opsarg);

	mtx_enter(&ifq->ifq_mtx);
	ifq->ifq_ops->ifqop_purge(ifq, &ml);
	ifq->ifq_len = 0;

	oldops = ifq->ifq_ops;
	oldq = ifq->ifq_q;

	ifq->ifq_ops = newops;
	ifq->ifq_q = newq;

	while ((m = ml_dequeue(&ml)) != NULL) {
		if (ifq->ifq_ops->ifqop_enq(ifq, m) != 0) {
			ifq->ifq_drops++;
			ml_enqueue(&free_ml, m);
		} else
			ifq->ifq_len++;
	}
	mtx_leave(&ifq->ifq_mtx);

	oldops->ifqop_free(oldq);

	ml_purge(&free_ml);
}

void *
ifq_q_enter(struct ifqueue *ifq, const struct ifq_ops *ops)
{
	mtx_enter(&ifq->ifq_mtx);
	if (ifq->ifq_ops == ops)
		return (ifq->ifq_q);

	mtx_leave(&ifq->ifq_mtx);

	return (NULL);
}

void
ifq_q_leave(struct ifqueue *ifq, void *q)
{
	KASSERT(q == ifq->ifq_q);
	mtx_leave(&ifq->ifq_mtx);
}

void
ifq_destroy(struct ifqueue *ifq)
{
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();

	/* don't need to lock because this is the last use of the ifq */

	ifq->ifq_ops->ifqop_purge(ifq, &ml);
	ifq->ifq_ops->ifqop_free(ifq->ifq_q);

	ml_purge(&ml);
@


1.421
log
@Grab the KERNEL_LOCK() around bridge_output().

It is now safe to call if_enqueue() without holding the KERNEL_LOCK()
even on an interface part of a bridge(4).

ok dlg@@, henning@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.420 2015/12/03 16:27:32 mpi Exp $	*/
a1234 1
/*ARGSUSED*/
a2026 1
/*ARGSUSED*/
@


1.420
log
@Use SRPL_HEAD() and SRPL_ENTRY() to be consistent with and allow to
fallback to a SLIST.

ok dlg@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.419 2015/12/03 14:55:17 vgross Exp $	*/
d629 6
a634 2
	if (ifp->if_bridgeport && (m->m_flags & M_PROTO1) == 0)
		return (bridge_output(ifp, m, NULL, NULL));
@


1.419
log
@Remove broadcast matching from ifa_ifwithaddr(), use in_broadcast() where
required.

ok bluhm@@ mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.418 2015/12/03 12:22:51 dlg Exp $	*/
d743 1
a743 1
	struct srpl_entry	  ifih_next;
@


1.418
log
@rework if_start to allow nics to provide an mpsafe start routine.

existing start routines will still be called under the kernel lock
and at IPL_NET.

mpsafe start routines will be serialised so only one instance of
each interfaces function will be running in the kernel at any point
in time. this guarantees packets will be dequeued in order, and the
start routines dont have to lock against themselves because if_start
does it for them.

the code to do that is based on the scsi runqueue code.

this also provides an if_start_barrier() function that should wait
until any currently running instances of if_start have finished.

a driver can opt in to the mpsafe if_start call by doing the following:

1. setting ifp->if_xflags = IFXF_MPSAFE
2. only calling if_start() instead of its own start routine
3. clearing IFF_RUNNING before calling if_start_barrier() on its way down
4. only using IFQ_DEQUEUE (not ifq_deq_begin/commit/rollback)

to simplify the implementation the tx mitigation code has been removed.

tested by several
ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.417 2015/12/02 16:35:52 bluhm Exp $	*/
a1221 7
				return (ifa);

			/* IPv6 doesn't have broadcast */
			if ((ifp->if_flags & IFF_BROADCAST) &&
			    ifa->ifa_broadaddr &&
			    ifa->ifa_broadaddr->sa_len != 0 &&
			    equal(ifa->ifa_broadaddr, addr))
@


1.417
log
@When destroying an interface, we have to wait until all references
are not used anymore.  This has to be done before any interface
fields become invalid.
As the route delete request cannot call if_get() anymore, pass down
the interface.  Split rtrequest_delete() into a separate function
that may take an existing inteface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.416 2015/12/02 08:47:00 claudio Exp $	*/
d84 1
d156 3
d542 29
d572 1
a572 1
	splassert(IPL_NET);
d574 16
a589 5
	if (ifq_len(&ifp->if_snd) >= min(8, ifp->if_snd.ifq_maxlen) &&
	    !ifq_is_oactive(&ifp->if_snd)) {
		if (ISSET(ifp->if_xflags, IFXF_TXREADY)) {
			TAILQ_REMOVE(&iftxlist, ifp, if_txlist);
			CLR(ifp->if_xflags, IFXF_TXREADY);
d591 4
d596 17
a613 1
	}
d615 5
a619 5
	if (!ISSET(ifp->if_xflags, IFXF_TXREADY)) {
		SET(ifp->if_xflags, IFXF_TXREADY);
		TAILQ_INSERT_TAIL(&iftxlist, ifp, if_txlist);
		schednetisr(NETISR_TX);
	}
d625 1
a625 1
	int s, length, error = 0;
a635 2
	s = splnet();

d641 1
a641 2
	if (error) {
		splx(s);
a642 1
	}
a649 2
	splx(s);

a868 15
nettxintr(void)
{
	struct ifnet *ifp;
	int s;

	s = splnet();
	while ((ifp = TAILQ_FIRST(&iftxlist)) != NULL) {
		TAILQ_REMOVE(&iftxlist, ifp, if_txlist);
		CLR(ifp->if_xflags, IFXF_TXREADY);
		ifp->if_start(ifp);
	}
	splx(s);
}

void
a950 2
	if (ISSET(ifp->if_xflags, IFXF_TXREADY))
		TAILQ_REMOVE(&iftxlist, ifp, if_txlist);
@


1.416
log
@Rework the MPLS handling. Remove the lookup loops since nothing is using
them and they make everything so much harder with no gain. Remove the
ifp argument from mpls_input since it is not needed. On the input side
the lookup side is modified a bit when it comes to BOS handling.
Tested in a L3VPN setup with ldpd and bgpd. Commiting now so we can move
on with cleaning up rt_ifp usage. If this breaks L2VPN I will fix it once
reported. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.415 2015/12/01 16:57:34 vgross Exp $	*/
d872 3
a943 2

	if_idxmap_remove(ifp);
@


1.415
log
@Iterating on &ifnet should only be done with the KERNEL_LOCK held.

With input and ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.414 2015/11/27 11:52:44 mpi Exp $	*/
d666 1
a666 1
		mpls_input(ifp, m);
@


1.414
log
@Protect the growth of the routing table arrays used by rtable_get()
with SRPs.

This is a simplified version of the dynamically sizeable array of
pointers used by if_get() because routing table heads are never
freed.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.413 2015/11/25 03:10:00 dlg Exp $	*/
d1169 1
d1203 1
d1232 1
@


1.413
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.412 2015/11/21 01:08:49 dlg Exp $	*/
d381 1
a381 1
	 * dont need the kernel lock to use update_locked since this is
@


1.412
log
@simplify ifq_deq_rollback by only having it unlock.

hfsc needed a rollback ifqop to requeue the mbuf because it used
ml_dequeue in the begin op. now it uses MBUF_LIST_FIRST to get a
ref to the first mbuf in deq_begin.

now the disciplines dont need a rollback op, so ifq_deq_rollback
can be simplified to just releasing the mutex.

based on a discussion with kenjiro cho
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.411 2015/11/20 12:27:42 mpi Exp $	*/
d542 1
a542 1
	    !ISSET(ifp->if_flags, IFF_OACTIVE)) {
d869 2
a871 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1638 2
@


1.411
log
@Keep if_ref() private, if_get() is what you want to use before if_put().

The thread detaching an interface will sleep until all references to this
interface have been released.  So we decided to only keep references for
a short period of time.

Keeping if_ref() private will hopefully help preserve this goal as long
as it makes sense.

Calling if_get()/if_put() in the same function also allows us to make
use of static analysis tools (thanks jsg@@!) to catch our errors.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.410 2015/11/20 11:15:07 dlg Exp $	*/
a2736 1
void		 priq_deq_rollback(struct ifqueue *, struct mbuf *, void *);
a2744 1
	priq_deq_rollback,
a2828 10
priq_deq_rollback(struct ifqueue *ifq, struct mbuf *m, void *cookie)
{
#ifdef DIAGNOSTIC
	struct priq_list *pl = cookie;

	KASSERT(pl->head == m);
#endif
}

void
a2909 2
	void *cookie;

a2910 1
	cookie = m->m_pkthdr.ph_cookie;
a2911 1
	ifq->ifq_ops->ifqop_deq_rollback(ifq, m, cookie);
@


1.410
log
@i made a mistake. rename ifq_enq and ifq_deq to ifq_enqueue and ifq_dequeue

fixing it now before i regret it more.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.409 2015/11/20 10:40:00 sthen Exp $	*/
d177 1
@


1.409
log
@fix prio KASSERT, it should be <= not <.  ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.408 2015/11/20 03:35:23 dlg Exp $	*/
d2876 1
a2876 1
ifq_enq(struct ifqueue *ifq, struct mbuf *m)
d2931 1
a2931 1
ifq_deq(struct ifqueue *ifq)
@


1.408
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.407 2015/11/18 13:58:02 mpi Exp $	*/
d2782 1
a2782 1
	KASSERT(m->m_pkthdr.pf.prio < IFQ_MAXPRIO);
@


1.407
log
@Factorize the bits to check if a L2 route is connected, wether it is
attached to a carp(4) or bridge(4) member, to not dereference rt_ifp
directly.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.406 2015/11/13 10:18:04 mpi Exp $	*/
a399 3
	if (ifp->if_snd.ifq_maxlen == 0)
		IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

d510 2
d540 1
a540 1
	if (ifp->if_snd.ifq_len >= min(8, ifp->if_snd.ifq_maxlen) &&
a784 2
		sched_pause();

d942 2
d2725 321
@


1.406
log
@Sore the index of the interface used for revarp instead of a pointer to
its descriptor.  Get rid of a if_ref().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.405 2015/11/11 10:23:23 mpi Exp $	*/
d945 30
@


1.405
log
@Store the index of the lo0 interface instead of a pointer to its
descriptor.

Allow to get rid of two if_ref() in the output paths.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.404 2015/11/07 12:42:19 mpi Exp $	*/
d890 2
a891 2
	if (ifp == revarp_ifp)
		revarp_ifp = NULL;
@


1.404
log
@Use input handlers for bridge(4).

This allows more flexible configurations with vlan(4) and bridge(4) on
top of the same physical interface.  In particular it allows to not feed
VLAN tagget packets into a bridge(4).

Fix regression reported by Armin Wolfermann on bugs@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.403 2015/11/06 17:55:55 mpi Exp $	*/
d253 1
a253 1
struct ifnet *lo0ifp;
d1278 1
d1283 1
a1283 1
		if ((rt->rt_flags & RTF_LOCAL) == 0)
d1302 3
a1304 1
		TAILQ_FOREACH(lo0ifa, &lo0ifp->if_addrlist, ifa_list)
d1308 2
d1385 1
a1385 1
	if (ifp == lo0ifp)
@


1.403
log
@Rename rt_mpath_next() into rtable_mpath_next() and provide an
implementation for ART based on the singly-linked list of route
entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.402 2015/11/03 12:25:37 mpi Exp $	*/
a792 11

#if NBRIDGE > 0
		if (ifp->if_bridgeport && (m->m_flags & M_PROTO1) == 0) {
			m = bridge_input(ifp, m);
			if (m == NULL) {
				if_put(ifp);
				continue;
			}
		}
		m->m_flags &= ~M_PROTO1;	/* Loop prevention */
#endif
@


1.402
log
@Do not clear M_PROTO1 flag before calling if_start() because pseudo-
drivers, like vlan(4), call if_enqueue() in their *start function.

Prevent an infinite recursion reported by Armin Wolfermann on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.401 2015/11/02 14:40:09 mpi Exp $	*/
d2359 1
a2359 1
			rt = rt_mpath_next(rt);
d2380 1
a2380 1
			rt = rt_mpath_next(rt);
@


1.401
log
@Merge rtable_mpath_match() into rtable_lookup().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.400 2015/10/28 12:14:25 florian Exp $	*/
a566 1
	m->m_flags &= ~M_PROTO1;	/* Loop prevention */
@


1.400
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.399 2015/10/27 10:52:17 mpi Exp $	*/
d2350 1
a2350 1
	rt0 = rtable_lookup(0, sintosa(&sa_in), sintosa(&sa_in));
d2370 2
a2371 1
	rt0 = rtable_lookup(0, sin6tosa(&sa_in6), sin6tosa(&sa_in6));
@


1.399
log
@Use rt_ifidx rather than rt_ifp.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.398 2015/10/25 21:58:04 deraadt Exp $	*/
a1736 5
	{
#ifdef INET6
		int oldmtu = ifp->if_mtu;
#endif

a1741 8

		/*
		 * If the link MTU changed, do network layer specific procedure.
		 */
#ifdef INET6
		if (ifp->if_mtu != oldmtu)
			nd6_setmtu(ifp);
#endif
a1742 1
	}
@


1.398
log
@unbreak tree for ramdisks without INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.397 2015/10/25 13:52:45 mpi Exp $	*/
d2344 1
d2368 5
a2372 2
			if (rt->rt_ifp)
				if_addgroup(rt->rt_ifp, IFG_EGRESS);
d2388 5
a2392 2
			if (rt->rt_ifp)
				if_addgroup(rt->rt_ifp, IFG_EGRESS);
@


1.397
log
@Do not overwrite if_rtrequest() if the driver specified it *before*
calling if_attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.396 2015/10/25 12:05:40 mpi Exp $	*/
d2514 1
d2516 1
@


1.396
log
@arp_ifinit() is no longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.395 2015/10/25 11:58:11 mpi Exp $	*/
d523 2
a524 1
	ifp->if_rtrequest = if_rtrequest_dummy;
@


1.395
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.394 2015/10/24 10:52:05 reyk Exp $	*/
a2531 5
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr != NULL &&
		    ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit((struct arpcom *)ifp, ifa);
	}
@


1.394
log
@Add pair(4), a vether-based virtual Ethernet driver to interconnect
rdomains and bridges on the local system.  This can be used to route
through local rdomains, to create L2 devices (like trunks) between
them, and many other things.

Discussed with many, with input from mpi@@
OK sthen@@ phessler@@ yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.393 2015/10/22 17:48:34 mpi Exp $	*/
d523 1
d1277 5
d1287 1
a1287 1
p2p_rtrequest(int req, struct rtentry *rt)
a1288 1
	struct ifnet *ifp = rt->rt_ifp;
@


1.393
log
@Kill link_rtrequest(), introduce in 1990 to "fix" the result
of rt_getifa() when adding link level route from outside the
kernel.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.392 2015/10/22 16:44:54 mpi Exp $	*/
d1764 1
d1775 1
@


1.392
log
@Make sure that the address matching the key (destination) of a route
entry is attached to this entry.

ok phessler@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.391 2015/10/22 15:37:47 bluhm Exp $	*/
a1273 24
}

/*
 * Default action when installing a route with a Link Level gateway.
 * Lookup an appropriate real ifa to point to.
 * This should be moved to /sys/net/link.c eventually.
 */
void
link_rtrequest(int cmd, struct rtentry *rt)
{
	struct ifaddr *ifa;
	struct sockaddr *dst;
	struct ifnet *ifp;

	if (cmd != RTM_ADD || ((ifa = rt->rt_ifa) == 0) ||
	    ((ifp = ifa->ifa_ifp) == 0) || ((dst = rt_key(rt)) == 0))
		return;
	if ((ifa = ifaof_ifpforaddr(dst, ifp)) != NULL) {
		ifa->ifa_refcnt++;
		ifafree(rt->rt_ifa);
		rt->rt_ifa = ifa;
		if (ifa->ifa_rtrequest && ifa->ifa_rtrequest != link_rtrequest)
			ifa->ifa_rtrequest(cmd, rt);
	}
@


1.391
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.390 2015/10/22 10:46:26 mpi Exp $	*/
d1324 2
a1339 11

		/*
		 * make sure to set rt->rt_ifa to the interface
		 * address we are using, otherwise we will have trouble
		 * with source address selection.
		 */
		if (ifa != rt->rt_ifa) {
			ifafree(rt->rt_ifa);
			ifa->ifa_refcnt++;
			rt->rt_ifa = ifa;
		}
@


1.390
log
@Do not dereference ``ifa_ifp'' when we already have an ``ifp'' pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.389 2015/10/12 13:17:58 dlg Exp $	*/
d1948 1
a1948 1
		sdl = (struct sockaddr_dl *)ifp->if_sadl;
@


1.389
log
@the pattr argument to IFQ_ENQUEUE is unused, so let's get rid of it.

also the comment above IFQ_ENQUEUE that says the pattr argument is unused.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.388 2015/10/12 11:32:39 mpi Exp $	*/
d2530 1
a2530 1
			printf(" on %s\n", ifa->ifa_ifp->if_xname);
@


1.388
log
@Unify link state change notification.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.387 2015/10/12 10:49:40 dlg Exp $	*/
d577 1
a577 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
@


1.387
log
@protect SIOCSLIFPHYTTL, SIOCSVNETID so only root can call them, and
return EPNOTSUPP for SIOCGLIFPHYTTL and SIOCGVNETID. all so drivers
dont have to do these checks themselves.

ok mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.386 2015/10/08 09:51:00 mpi Exp $	*/
d140 2
a147 1
void	if_link_state_change_task(void *);
d412 1
a412 1
	task_set(ifp->if_linkstatetask, if_link_state_change_task, ifp);
a1386 1
 * NOTE: must be called at splsoftnet or equivalent.
d1401 2
a1402 12
#if NCARP > 0
	if (ifp->if_carp)
		carp_carpdev_state(ifp);
#endif
#if NBRIDGE > 0
	if (ifp->if_bridgeport)
		bstp_ifstate(ifp);
#endif
	rt_ifmsg(ifp);
#ifndef SMALL_KERNEL
	rt_if_track(ifp);
#endif
a1407 1
 * NOTE: must be called at splsoftnet or equivalent.
d1416 1
a1416 9
#if NCARP > 0
	if (ifp->if_carp)
		carp_carpdev_state(ifp);
#endif
#if NBRIDGE > 0
	if (ifp->if_bridgeport)
		bstp_ifstate(ifp);
#endif
	rt_ifmsg(ifp);
a1421 4
#ifndef SMALL_KERNEL
	rt_if_track(ifp);
#endif
}
d1423 1
a1423 8
/*
 * Schedule a link state change task.
 */
void
if_link_state_change(struct ifnet *ifp)
{
	/* put the routing table update task on systq */
	task_add(systq, ifp->if_linkstatetask);
d1427 2
a1428 1
 * Process a link state change.
d1431 1
a1431 1
if_link_state_change_task(void *arg)
d1433 1
a1433 1
	struct ifnet *ifp = arg;
d1443 9
@


1.386
log
@Unlock the softnet task.

ok dlg@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.385 2015/10/05 19:05:09 uebayasi Exp $	*/
d1812 1
d1816 1
d1824 1
d1826 1
@


1.385
log
@Revert if_oqdrops accounting changes done in kernel, per request from mpi@@.

(Especially adding IF_DROP() after IFQ_ENQUEUE() was completely wrong because
IFQ_ENQUEUE() already does it.  Oops.)

After this revert, the situation becomes:

- if_snd.ifq_drops is incremented in either IFQ_ENQUEUE() or IF_DROP(), but
  it is not shown to userland, and

- if_data.ifi_oqdrops is shown to userland, but it is not incremented by
  anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a781 1
	KERNEL_LOCK();
a818 1
	KERNEL_UNLOCK();
@


1.384
log
@Count IFQ_ENQUEUE() failure as output drop.

mpi@@ prefers checking IFQ_ENQUEUE() error, and this matches that.

OK dlg@@
@
text
@a544 2
		ifp->if_oqdrops += ifp->if_snd.ifq_drops;
		ifp->if_snd.ifq_drops = 0;
a577 1
		IF_DROP(&ifp->if_snd);
@


1.383
log
@Accumulate ifq_drops into if_oqdrops if if_start().

mpi@@ questioned usefulness of if_snd.ifq_drops, but this is what exists now.
This area is going to be readily polished.

OK dlg@@
@
text
@d580 1
@


1.382
log
@sleep until all references to an interface have been released during detach.

this is done by moving to the refcnt api and using refcnt_finalize.

tested by Hrjove Popovski
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.381 2015/09/27 16:50:03 stsp Exp $	*/
d545 2
@


1.381
log
@Add if_setlladdr(), factored out from ifioctl(). Will be used by iwm(4) soon.
With suggestions from tedu@@ and guenther@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.380 2015/09/13 18:15:03 mpi Exp $	*/
d282 1
a282 5
	/*
	 * give the ifp an initial refcnt of 1 to ensure it will not
	 * be freed until if_idxmap_remove returns.
	 */
	ifp->if_refcnt = 1;
d344 1
a344 1
	unsigned int index, r;
d361 2
a362 4
	/* release the initial ifp refcnt */
	r = atomic_dec_int_nv(&ifp->if_refcnt);
	if (r != 0)
		printf("%s: refcnt %u\n", ifp->if_xname, r);
d1551 1
a1551 1
	atomic_inc_int(&ifp->if_refcnt);
d1562 1
a1562 1
	atomic_dec_int(&ifp->if_refcnt);
@


1.380
log
@Fix double rtfree(9) in non-INET6 kernel.

With and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.379 2015/09/13 17:53:44 mpi Exp $	*/
d1571 12
d1984 1
a1984 5
			bcopy((caddr_t)ifr->ifr_addr.sa_data,
			    (caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			    ETHER_ADDR_LEN);
			bcopy((caddr_t)ifr->ifr_addr.sa_data,
			    LLADDR(sdl), ETHER_ADDR_LEN);
@


1.379
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.378 2015/09/13 10:33:34 dlg Exp $	*/
a2433 1
#endif
d2435 1
@


1.378
log
@replace hand rolled refcounts and sleep_setup/finish with refcnts and
refcnt_finalize.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.377 2015/09/13 09:58:03 kettenis Exp $	*/
a685 10
}

int
if_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	if (rt != NULL && ISSET(rt->rt_flags, RTF_LOCAL))
		return (if_input_local(lo0ifp, m, dst->sa_family));

	return (ifp->if_output(ifp, m, dst, rt));
@


1.377
log
@Run the interface watchdog timer routine as a task such that we have process
context.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.376 2015/09/12 20:26:06 mpi Exp $	*/
a82 1
#include <sys/proc.h>
d704 1
a704 1
	int			  ifih_srpcnt;
d734 1
a734 1
		ifih->ifih_srpcnt = 0;
d745 1
a745 1
	atomic_inc_int(&ifih->ifih_srpcnt);
d753 1
a753 2
	if (atomic_dec_int_nv(&ifih->ifih_srpcnt) == 0)
		wakeup_one(&ifih->ifih_srpcnt);
a759 1
	struct sleep_state sls;
a760 1
	int refs;
d776 1
a776 7
		refs = ifih->ifih_srpcnt;
		while (refs) {
			sleep_setup(&sls, &ifih->ifih_srpcnt, PWAIT, "ifihrm");
			refs = ifih->ifih_srpcnt;
			sleep_finish(&sls, refs);
		}

@


1.376
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.375 2015/09/12 19:36:37 dlg Exp $	*/
d146 1
d414 1
d531 2
d914 1
a914 1
	/* Remove the watchdog timeout */
d916 1
d968 1
d1515 1
a1515 1
			(*ifp->if_watchdog)(ifp);
d1518 12
@


1.375
log
@introduce SRPs to the interface index maps to make if_get() mpsafe.

each index in the ifidx map is now an SRP that points at each
interfaces struct ifnet.

because the map needs to be grown at run time as interfaces are
added to the system, we now use an SRP to gain access to the map.

if_get enters the idx map and follows it to the ifnet pointer. if
an interface exists at that index it gets adds a refcount before
leaving the ifp SRP.

modifications to the map pointer and the interface pointers are
serialised by the kernel lock.

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.374 2015/09/12 13:34:12 mpi Exp $	*/
d685 10
a1357 1
		rt->rt_ifp = lo0ifp;
@


1.374
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.373 2015/09/11 16:58:00 mpi Exp $	*/
d174 10
d186 1
a186 1
	/* followed by limit ifnet * pointers */
d189 6
d198 1
a198 1
	struct if_map		*map;
d201 1
a201 1
void	if_idxmap_init(void);
d225 5
a229 1
	if_idxmap_init();
d244 1
a244 1
	NULL
d247 3
d255 1
a255 1
if_idxmap_init(void)
d257 4
d262 11
a272 3
	if_idxmap.map = malloc(sizeof(*if_idxmap.map) +
	    8 * sizeof(struct ifnet *), M_IFADDR, M_WAITOK | M_ZERO);
	if_idxmap.map->limit = 8;
d279 1
a279 1
	struct ifnet **map;
d294 2
a295 2
	if_map = if_idxmap.map;
	map = (struct ifnet **)(if_map + 1);
d301 1
a301 1
		struct ifnet **nmap;
d303 1
d308 1
a308 1
		nmap = (struct ifnet **)(nif_map + 1);
d311 8
a318 2
		for (i = 0; i < if_map->limit; i++)
			nmap[i] = map[i];
d321 1
a321 1
			nmap[i] = NULL;
d325 1
a325 3
		if_idxmap.map = nif_map;
		free(if_map, M_IFADDR, sizeof(*nif_map) +
		    if_map->limit * sizeof(*map));
d332 1
a332 1
		if (index != 0 && map[index] == NULL)
d340 1
a340 1
	map[index] = if_ref(ifp);
d347 1
a347 1
	struct ifnet **map;
d350 1
a350 1
	index = ifp->if_index & USHRT_MAX;
d355 2
a356 3
	if_map = if_idxmap.map;
	map = (struct ifnet **)(if_map + 1);
	KASSERT(ifp == map[index]);
d358 4
a361 2
	map[index] = NULL;
	if_put(ifp);
d371 23
d1527 2
a1528 2
	struct if_map *if_map = if_idxmap.map;
	struct ifnet **map = (struct ifnet **)(if_map + 1);
d1531 1
d1533 3
a1535 1
		ifp = map[index];
d1540 3
a1542 1
	}
@


1.373
log
@Introduce rtref(9) use it in rtable_lookup() before returning a route
entry.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.372 2015/09/11 09:15:56 dlg Exp $	*/
d563 56
@


1.372
log
@remove some more trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.371 2015/09/11 09:00:40 mpi Exp $	*/
d2259 1
a2259 1
	struct rtentry		*rt;
d2272 3
a2274 2
	rt = rtable_lookup(0, sintosa(&sa_in), sintosa(&sa_in));
	if (rt != NULL) {
d2285 1
d2289 3
a2291 2
	rt = rtable_lookup(0, sin6tosa(&sa_in6), sin6tosa(&sa_in6));
	if (rt != NULL) {
d2303 1
@


1.371
log
@whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.370 2015/09/11 08:54:54 dlg Exp $	*/
d791 1
a791 1
#if NETHER > 0 && defined(NFSCLIENT) 
d1596 1
a1596 1
			ifp->if_ll_output = ifp->if_output; 
d1604 1
a1604 1
			ifp->if_output = ifp->if_ll_output; 
@


1.370
log
@iterate over the new half of the if idx map rather than loop on the one
entry forever.

this will fix hangs when you have more than 7 interfaces.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.369 2015/09/10 18:11:05 dlg Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d162 1
a162 1
 * 
d165 1
a165 1
 * 
d172 1
a172 1
 */ 
d294 1
a294 1
		
@


1.369
log
@rework how we store and manage the interface index to ifp map in preparation of using SRPs as a backend for if_get.

this also tries to document how things work and what if index 0 is for.

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.368 2015/09/10 16:41:30 mikeb Exp $	*/
d278 1
a278 1
		while (i < nlimit)
d280 2
@


1.368
log
@pass a cookie argument to interface input handlers that can be used
to pass additional context or transient data with the similar life
time.

ok mpi, suggestions, hand holding and ok from dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.367 2015/09/10 14:06:43 dlg Exp $	*/
d154 35
d209 2
d221 6
a226 3
static unsigned int if_index = 0;
static unsigned int if_indexlim = 0;
struct ifnet **ifindex2ifnet = NULL;
a230 4
/*
 * Attach an interface to the
 * list of "active" interfaces.
 */
d232 10
a241 1
if_attachsetup(struct ifnet *ifp)
d243 3
a245 1
	int wrapped = 0;
d248 2
a249 1
	 * Always increment the index to avoid races.
d251 4
a254 1
	if_index++;
d256 24
a279 23
	/*
	 * If we hit USHRT_MAX, we skip back to 1 since there are a
	 * number of places where the value of ifp->if_index or
	 * if_index itself is compared to or stored in an unsigned
	 * short.  By jumping back, we won't botch those assignments
	 * or comparisons.
	 */
	if (if_index == USHRT_MAX) {
		if_index = 1;
		wrapped++;
	}

	while (if_index < if_indexlim && ifindex2ifnet[if_index] != NULL) {
		if_index++;

		if (if_index == USHRT_MAX) {
			/*
			 * If we have to jump back to 1 twice without
			 * finding an empty slot then there are too many
			 * interfaces.
			 */
			if (wrapped)
				panic("too many interfaces");
d281 5
a285 3
			if_index = 1;
			wrapped++;
		}
a286 1
	ifp->if_index = if_index;
d288 6
a293 24
	/*
	 * We have some arrays that should be indexed by if_index.
	 * since if_index will grow dynamically, they should grow too.
	 *	struct ifnet **ifindex2ifnet
	 */
	if (ifindex2ifnet == NULL || if_index >= if_indexlim) {
		size_t m, n, oldlim;
		caddr_t q;

		oldlim = if_indexlim;
		if (if_indexlim == 0)
			if_indexlim = 8;
		while (if_index >= if_indexlim)
			if_indexlim <<= 1;

		/* grow ifindex2ifnet */
		m = oldlim * sizeof(struct ifnet *);
		n = if_indexlim * sizeof(struct ifnet *);
		q = (caddr_t)malloc(n, M_IFADDR, M_WAITOK|M_ZERO);
		if (ifindex2ifnet) {
			bcopy((caddr_t)ifindex2ifnet, q, m);
			free((caddr_t)ifindex2ifnet, M_IFADDR, 0);
		}
		ifindex2ifnet = (struct ifnet **)q;
d296 39
a338 3
	ifp->if_refcnt = 0;
	ifindex2ifnet[if_index] = if_ref(ifp);

d352 3
d842 1
a842 2
	ifindex2ifnet[ifp->if_index] = NULL;
	if_put(ifp);
d1405 2
d1409 4
a1412 3
	if (index < if_indexlim) {
		ifp = ifindex2ifnet[index];
		if (ifp != NULL)
d1414 1
@


1.367
log
@if_put after if_get in if_input_process
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.366 2015/09/10 13:32:19 dlg Exp $	*/
d491 3
a493 1
	int			(*ifih_input)(struct ifnet *, struct mbuf *);
d504 2
a505 1
if_ih_insert(struct ifnet *ifp, int (*input)(struct ifnet *, struct mbuf *))
d513 1
a513 1
		if (ifih->ifih_input == input) {
d523 1
d549 2
a550 1
if_ih_remove(struct ifnet *ifp, int (*input)(struct ifnet *, struct mbuf *))
d560 1
a560 1
		if (ifih->ifih_input == input)
d625 1
a625 1
			if ((*ifih->ifih_input)(ifp, m))
@


1.366
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.365 2015/09/10 06:00:37 dlg Exp $	*/
d607 2
a608 1
			if (m == NULL)
d610 1
d627 2
@


1.365
log
@only try and reference an ifp in if_get if we actually find one in
the map.

avoids a NULL deref jsg@@ found
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.364 2015/09/09 16:01:10 dlg Exp $	*/
d83 1
d392 1
a392 1
	SLIST_INIT(&ifp->if_inputs);
d489 87
d584 1
d617 1
a617 1
		SLIST_FOREACH(ifih, &ifp->if_inputs, ifih_next) {
d621 2
@


1.364
log
@introduce reference counts for interfaces (ie, struct ifnet *ifp).

if_get can get a reference to an ifp, but it never releases that
reference. this provides an if_put function that can be used to
decrement the refcount.

we cannot come up with a scheme for letting the network stack run on
one (or many) cpus while ioctls are pulling interfaces down on another
cpu without refcounts for the interfaces.

if_put is going in now so we can go through the stack and put the
necessary calls to it in, and then we'll backfill this implementation
to actually check the refcounts when the interface detaches.

ok mpi@@ mikeb@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.363 2015/09/01 04:56:55 dlg Exp $	*/
d1234 1
a1234 1
	if (index < if_indexlim)
d1236 3
d1240 1
a1240 1
	return (if_ref(ifp));
@


1.363
log
@dont need the kernel lock for mpsafe bpfs (again)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.362 2015/08/30 10:39:16 mpi Exp $	*/
d83 1
d264 2
a265 1
	ifindex2ifnet[if_index] = ifp;
d669 1
d1237 8
d1246 9
@


1.362
log
@Use a global table for domains instead of building a list at run time.

As a side effect there's no need to run if_attachdomain() after the
list of domains has been built.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.361 2015/08/23 10:01:27 dlg Exp $	*/
a476 1
		KERNEL_LOCK();
a478 1
		KERNEL_UNLOCK();
@


1.361
log
@bpf+srp is blowing up, so its being backed out. bpf will need the big lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.358 2015/08/16 11:28:31 dlg Exp $	*/
d128 1
a128 1
void	if_attachdomain1(struct ifnet *);
d268 1
a268 2
	if (domains)
		if_attachdomain1(ifp);
d334 1
a334 13
if_attachdomain()
{
	struct ifnet *ifp;
	int s;

	s = splnet();
	TAILQ_FOREACH(ifp, &ifnet, if_list)
		if_attachdomain1(ifp);
	splx(s);
}

void
if_attachdomain1(struct ifnet *ifp)
d337 1
a337 1
	int s;
d343 1
a343 1
	for (dp = domains; dp; dp = dp->dom_next) {
d593 1
a593 1
	int s;
d659 1
a659 1
	for (dp = domains; dp; dp = dp->dom_next) {
@


1.360
log
@Check the error value returned by in6_ifattach().

Prodded by and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.359 2015/08/16 12:19:06 dlg Exp $	*/
d490 1
d493 1
@


1.359
log
@dont need the biglock to call bpf now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.358 2015/08/16 11:28:31 dlg Exp $	*/
d1317 1
a1317 1
				in6_ifattach(ifp);
d1321 1
a1321 1
			return (0);
d1385 1
a1385 1
			in6_ifattach(ifp);
d1387 2
@


1.358
log
@avoid a toctou problem in if_input in the bpf handling.

load ifp->if_bpf into a local variable, test that, and pass it to bpf.
this is instead of instead of assuming ifp->if_bpf wont change between
checking it and passing it to bpf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.357 2015/08/13 07:19:58 mpi Exp $	*/
a489 1
		KERNEL_LOCK();
a491 1
		KERNEL_UNLOCK();
@


1.357
log
@If no handler consumed a mbuf, free it.  This also apply if an interface
does not have any registered handler.

Plug a mbuf leak found by sthen@@ with gif(4) in a bridge.

ok sthen@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.356 2015/07/29 00:04:03 rzalamena Exp $	*/
d474 3
d488 2
a489 1
	if (ifp->if_bpf) {
d492 1
a492 1
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
@


1.356
log
@Don't use mpls_input() as input handler anymore and instead call it
directly. Also protect non mp-safe functions while at it.

ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.355 2015/07/21 04:21:50 jca Exp $	*/
d541 2
@


1.355
log
@No more AF_LINK addresses on the per-ifp address lists.  ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.354 2015/07/20 22:54:29 mpi Exp $	*/
a632 3
#ifdef MPLS
	mpls_uninstall_handler(ifp);
#endif /* MPLS */
a1399 5
			if (mpls_install_handler(ifp) != 0) {
				splx(s);
				return (ENOMEM);
			}

a1410 1
			mpls_uninstall_handler(ifp);
@


1.354
log
@Remove splassert(IPL_NET) from if_input().

if_input() has been designed to be able to safely handle a batch of
packets from physical drivers to the network stack.  Most of these
drivers have an interrupt routine executed at IPL_NET and the check
made sense during the conversion.  However we also want to re-enqueue
packets with if_input() from the network stack currently running at
IPL_SOFTNET.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.353 2015/07/20 21:16:39 rzalamena Exp $	*/
a2222 4
			case AF_LINK:
				printf("%s",
				    ether_sprintf(ifa->ifa_addr->sa_data));
				break;
@


1.353
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.352 2015/07/18 16:10:03 mpi Exp $	*/
a473 2

	splassert(IPL_NET);
@


1.352
log
@There's no longer a need to force carp(4) interfaces to be the last ones
in the &ifnet list of interfaces.

carp(4) is slowly becoming less special.  Should keep the carp interfaces
in the correct order in ifconfig output as reported by Johan Huldtgren.

ok florian@@, claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.351 2015/07/18 15:51:16 mpi Exp $	*/
d635 3
a637 1

d1405 5
d1421 1
@


1.351
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.350 2015/07/16 15:31:35 mpi Exp $	*/
a375 4
#if NCARP > 0
	struct ifnet *before = NULL;
#endif

a376 11

#if NCARP > 0
	if (ifp->if_type != IFT_CARP)
		TAILQ_FOREACH(before, &ifnet, if_list)
			if (before->if_type == IFT_CARP)
				break;
	if (before == NULL)
		TAILQ_INSERT_TAIL(&ifnet, ifp, if_list);
	else
		TAILQ_INSERT_BEFORE(before, ifp, if_list);
#else
a377 1
#endif
@


1.350
log
@Properly layer Router Solicitation code.

Tweak and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.349 2015/07/02 15:16:57 mpi Exp $	*/
d2096 2
a2097 1
	if ((rt = rt_lookup(sintosa(&sa_in), sintosa(&sa_in), 0)) != NULL) {
d2111 2
a2112 1
	if ((rt = rt_lookup(sin6tosa(&sa_in6), sin6tosa(&sa_in6), 0)) != NULL) {
d2242 1
a2242 1
#endif /* SMALL_KERNEL */
@


1.349
log
@Move back rdomain's check into ether_output() otherwise it triggers
if a pseudo-interface is on a different rdomain than its parent.

Sorry for the inconvenience, I hope you'll fly again with us.

Regression reported by and ok semarie@@, ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.348 2015/07/02 09:40:02 mpi Exp $	*/
d1406 1
a1406 6
			nd6_rs_timeout_count++;
			RS_LHCOOKIE(ifp) = hook_establish(
			    ifp->if_linkstatehooks, 1, nd6_rs_dev_state, ifp);
			if (!timeout_pending(&nd6_rs_output_timer))
				nd6_rs_output_set_timo(
				    ND6_RS_OUTPUT_QUICK_INTERVAL);
d1411 1
a1411 5
			hook_disestablish(ifp->if_linkstatehooks,
			    RS_LHCOOKIE(ifp));
			nd6_rs_timeout_count--;
			if (nd6_rs_timeout_count == 0)
				timeout_del(&nd6_rs_output_timer);
@


1.348
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.347 2015/06/30 13:54:42 mpi Exp $	*/
a448 8

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d\n", ifp->if_xname, ifp->if_rdomain,
		    rtable_l2(m->m_pkthdr.ph_rtableid));
	}
#endif
@


1.347
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.346 2015/06/29 10:32:29 dlg Exp $	*/
d552 1
a552 1
			m = bridge_input(m);
d564 1
a564 1
			if ((*ifih->ifih_input)(m))
@


1.346
log
@count if_ibytes in if_input like we do for if_ipackets.

tweaks and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.345 2015/06/25 09:20:20 mpi Exp $	*/
d445 1
a445 1
if_output(struct ifnet *ifp, struct mbuf *m)
@


1.345
log
@Move brige(4)'s output hook outside of ether_output().

This fix some weird bridge(4) configurations involving pseudo-drivers
stacked on top of interfaces in a bridge.

Also simplifies the loop prevention logic to match bridge's input path.
Instead of using a tag per port/bridge simply flag output mbufs to make
sure only one copy per bridge go through bridge_output().

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.344 2015/06/25 09:10:15 mpi Exp $	*/
d497 1
a500 2
	ifp->if_ipackets += ml_len(ml);

d504 1
d506 3
@


1.344
log
@Check for correct rdomain in if_output() rather than in ether_output().

Not all drivers make use of ether_output() and there's no real reason to
call it when no ARP resolution is needed.  But in this case we still want
to make sure we're sending packets in the correct rdomain.

ok bluhm@@, claudio@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.343 2015/06/24 09:56:51 mpi Exp $	*/
d456 6
@


1.343
log
@Stop garbgage collecting mbufs from the ARP, IPv4 and IPv6 queues when
an interface is destroyed or removed.

Since the introduction of ph_ifidx, as soon as a mbuf with an invalid
interface index is dequeued it will be freed.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.342 2015/06/24 09:40:54 mpi Exp $	*/
d449 8
@


1.342
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.341 2015/06/23 09:42:23 mpi Exp $	*/
a130 2
int	if_detach_filter(void *, const struct mbuf *);
void	if_detach_queues(struct ifnet *, struct niqueue *);
a646 17
	/*
	 * remove packets came from ifp, from software interrupt queues.
	 * net/netisr_dispatch.h is not usable, as some of them use
	 * strange queue names.
	 */
#define IF_DETACH_QUEUES(x) \
do { \
	extern struct niqueue x; \
	if_detach_queues(ifp, & x); \
} while (0)
	IF_DETACH_QUEUES(arpintrq);
	IF_DETACH_QUEUES(ipintrq);
#ifdef INET6
	IF_DETACH_QUEUES(ip6intrq);
#endif
#undef IF_DETACH_QUEUES

a686 28
}

int
if_detach_filter(void *ctx, const struct mbuf *m)
{
	struct ifnet *ifp = ctx;

#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		return (0);
#endif

	return (m->m_pkthdr.ph_ifidx == ifp->if_index);
}

void
if_detach_queues(struct ifnet *ifp, struct niqueue *niq)
{
	struct mbuf *m0, *m;

	m0 = niq_filter(niq, if_detach_filter, ifp);
	while (m0 != NULL) {
		m = m0;
		m0 = m->m_nextpkt;

		m->m_nextpkt = NULL;
		m_freem(m);
	}
@


1.341
log
@Adapt bridge(4) to the new if_input() framework.

Move bridge_input() outside of ether_input() in order to duplicate packets
flowing through a bridge port before applying any transformation on mbufs.

This saves a various m_adj(9)/M_PREPEND(9) dances and remove the bridge(4)
hack from vlan(4).

Tested by mxb <mxb AT alumni DOT chalmers DOT se> and kettenis@@

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.340 2015/06/16 11:09:39 mpi Exp $	*/
d487 2
@


1.340
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.339 2015/06/09 14:57:30 mpi Exp $	*/
d532 9
@


1.339
log
@Remove the hack to check if the received pointer has changed in an ifih
now that all drivers and pseudo-drivers are using if_input().

if_input() is reentrant and is now the only place where we set `rcvif'.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.338 2015/06/07 12:02:28 jsg Exp $	*/
d489 1
a489 1
		m->m_pkthdr.rcvif = ifp;
d527 6
a536 1
		ifp = m->m_pkthdr.rcvif;
d707 1
a707 1
	return (m->m_pkthdr.rcvif == ifp);
@


1.338
log
@Introduce unhandled_af() for cases where code conditionally does
something based on an address family and later assumes one of the paths
was taken.  This was initially just calls to panic until guenther
suggested a function to reduce the amount of strings needed.

This reduces the amount of noise with static analysers and acts
as a sanity check.

ok guenther@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.337 2015/06/03 22:01:07 mikeb Exp $	*/
d526 1
a526 1
again:
a534 4

			/* Pseudo-drivers might be stacked. */
			if (ifp != m->m_pkthdr.rcvif)
				goto again;
@


1.337
log
@Adjust yielding condition slightly in the if_input_process thread.

ok mpi, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.336 2015/06/02 13:23:55 mpi Exp $	*/
d2478 6
@


1.336
log
@RIP ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.335 2015/05/26 11:39:07 mpi Exp $	*/
a513 1
	int mit = 0;
d525 1
a525 3
		if ((++mit & 0x1f) == 0)
			yield();

@


1.335
log
@Now that the Ethernet header is always passed as part of the mbuf, kill
the second (unused) argument of the input packet handlers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.334 2015/05/26 11:36:26 dlg Exp $	*/
a502 7
	task_add(softnettq, &if_input_task);
}

void
ether_input_mbuf(struct ifnet *ifp, struct mbuf *m)
{
	mq_enqueue(&if_input_queue, m);
@


1.334
log
@move add_net_randomness from ether_input to the if_input task.

change it from feeding the ethertype of the packet (which is almost
certainly an ip packet or vlan packet, so not that variable) to the
number of packets about to be processed.

ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.333 2015/05/20 08:28:54 mpi Exp $	*/
d543 1
a543 1
			if ((*ifih->ifih_input)(m, NULL))
@


1.333
log
@Do not increment if_opackets in if_output().  It might make sense to do
that later but all drivers should be adapated.

Should fix a double output packet accounting, reported by Hrvoje Popovski.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.332 2015/05/19 11:09:24 mpi Exp $	*/
d84 2
d527 2
@


1.332
log
@Take vlan(4) out of ether_input().

To keep the list of input handlers short, multiple vlans share the
same ifih.

if_input_process() now looks if the interface of a mbuf changed to
make sure the corresponding handlers are executed.  This is a hack
and will be improved later.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.331 2015/05/15 10:15:13 mpi Exp $	*/
a468 1
	ifp->if_opackets++;
@


1.331
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.330 2015/04/23 09:45:24 dlg Exp $	*/
d533 5
d542 4
@


1.330
log
@replace the use of struct ifqueue in pipex with mbuf_queues.

this has a slight semantic change. previously pipex would only
process up to 128 packets on the input and output queues at a time
and would reschedule the softint if there were any left. now it
mq_delists the current set of pending packets and only processes
them. if anything is added to the queues later they'll cause the
softint to run again.

this in turn lets us deprecate sysctl_ifq since nothing uses it
anymore. because niqueues are mostly wrappers around mbuf_queues,
we can provide sysctl_mq and just #define sysctl_niq to it.

pipex bits are ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.329 2015/04/10 13:58:20 dlg Exp $	*/
d442 33
@


1.329
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.328 2015/04/10 08:48:24 mpi Exp $	*/
d2165 2
a2166 2
sysctl_ifq(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen, struct ifqueue *ifq)
d2174 1
a2174 1
		return (sysctl_rdint(oldp, oldlenp, newp, ifq->ifq_len));
d2177 1
a2177 1
		    &ifq->ifq_maxlen));
d2179 1
a2179 23
		return (sysctl_rdint(oldp, oldlenp, newp, ifq->ifq_drops));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

int
sysctl_niq(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen, struct niqueue *niq)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IFQCTL_LEN:
		return (sysctl_rdint(oldp, oldlenp, newp, niq_len(niq)));
	case IFQCTL_MAXLEN:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &niq->ni_q.mq_maxlen)); /* XXX */
	case IFQCTL_DROPS:
		return (sysctl_rdint(oldp, oldlenp, newp, niq_drops(niq)));
@


1.328
log
@Run detach hook and similar before cleaning up any other resource when
an interface is destroyed/removed.  This way we can ensure pseudo-driver
changes done after attaching an interface are undone before detaching it.

Note: it is safe to call if_deactivate() multiple times as the interface
should not have any attached pseudo-interface after the first call.

ok deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.327 2015/04/07 10:46:20 mpi Exp $	*/
d129 2
a130 1
void	if_detach_queues(struct ifnet *, struct ifqueue *);
d609 1
a609 1
	extern struct ifqueue x; \
d661 13
d675 1
a675 1
if_detach_queues(struct ifnet *ifp, struct ifqueue *q)
d677 6
a682 2
	struct mbuf *m, *prev = NULL, *next;
	int prio;
d684 2
a685 26
	for (prio = 0; prio <= IFQ_MAXPRIO; prio++) {
		for (m = q->ifq_q[prio].head; m; m = next) {
			next = m->m_nextpkt;
#ifdef DIAGNOSTIC
			if ((m->m_flags & M_PKTHDR) == 0) {
				prev = m;
				continue;
			}
#endif
			if (m->m_pkthdr.rcvif != ifp) {
				prev = m;
				continue;
			}

			if (prev)
				prev->m_nextpkt = m->m_nextpkt;
			else
				q->ifq_q[prio].head = m->m_nextpkt;
			if (q->ifq_q[prio].tail == m)
				q->ifq_q[prio].tail = prev;
			q->ifq_len--;

			m->m_nextpkt = NULL;
			m_freem(m);
			IF_DROP(q);
		}
@


1.327
log
@Do not pass an `ifp' argument to interface input handlers since it
might be overwritten by pseudo-drivers.

ok dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.326 2015/04/02 09:46:01 kettenis Exp $	*/
a523 4
/*
 * Detach an interface from everything in the kernel.  Also deallocate
 * private resources.
 */
d525 1
a525 1
if_detach(struct ifnet *ifp)
d527 1
a527 4
	struct ifaddr *ifa;
	struct ifg_list *ifg;
	int s = splnet();
	struct domain *dp;
d529 1
a529 4
	ifp->if_flags &= ~IFF_OACTIVE;
	ifp->if_start = if_detached_start;
	ifp->if_ioctl = if_detached_ioctl;
	ifp->if_watchdog = NULL;
a537 6
	/* Remove the watchdog timeout */
	timeout_del(ifp->if_slowtimo);

	/* Remove the link state task */
	task_del(systq, ifp->if_linkstatetask);

d549 30
@


1.326
log
@Grab the kernel lock around the bpf_mtap_ether() call in if_input().  This
allows drivers to start calling if_input() without holding the kernel lock
while others work on make the bpf code mpsafe.

ok dlg@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.325 2015/04/01 04:00:55 dlg Exp $	*/
d501 1
a501 1
			if ((*ifih->ifih_input)(ifp, NULL, m))
@


1.325
log
@create a taskq for network tasks to run in. cut ether_input_mbuf
and if_input up so the work ether_input does gets run on the task
instead of directly from hardware receive handlers.

this is a step toward letting hardware drivers run without biglock
by shoving the work the stack does which needs that lock sideways.

general agreement at s2k15
ok mpi@@ kettenis@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.324 2015/03/29 01:05:02 dlg Exp $	*/
d460 1
d463 1
@


1.324
log
@if_detached start dequeues mbufs on the start list and immediately
frees them. IFQ_PURGE does that too, so let's reuse it here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.323 2015/03/25 11:49:02 dlg Exp $	*/
d145 2
d160 2
d173 5
d443 3
a449 1
	struct ifih *ifih;
d453 1
a453 1
	while ((m = ml_dequeue(ml)) != NULL) {
d456 1
d459 2
a460 1
		if (ifp->if_bpf)
d462 1
d465 33
d503 2
@


1.323
log
@introduce code for network input queues. these are to replace the
use of struct ifqueue for things handled by softnet. they instead
use an mbuf_queue (yay mpsafe) and wrap up the schednetisr and
if_congestion handling.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.322 2015/03/18 12:23:15 dlg Exp $	*/
d1745 1
a1745 9
	struct mbuf *m;

	while (1) {
		IF_DEQUEUE(&ifp->if_snd, m);

		if (m == NULL)
			return;
		m_freem(m);
	}
@


1.322
log
@remove the congestion handling from struct ifqueue.

its only used for the ip and ip6 network stack input queues, so it
seems unfair that every instance of ifqueue has to carry a pointer
around for this specific use case.

this moves the congestion marker to a kernel global. if we detect
that we're congested, we assume the whole system is busy and punish
all input queues.

marking a system as congested is done by setting the global to the
current value of ticks. as the system moves away from that value,
it moves away from being congested until the comparison fails.

written at s2k15
ok henning@@ beck@@ bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.321 2015/03/14 03:38:51 jsg Exp $	*/
d2135 22
d2375 39
@


1.321
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.320 2015/03/03 07:54:32 brad Exp $	*/
a140 1
void	if_congestion_clear(void *);
d156 1
d789 1
a789 1
 * set queue congestion marker and register timeout to clear it
d792 1
a792 1
if_congestion(struct ifqueue *ifq)
d794 1
a794 3
	/* Not currently needed, all callers check this */
	if (ifq->ifq_congestion)
		return;
d796 1
a796 5
	ifq->ifq_congestion = malloc(sizeof(struct timeout), M_TEMP, M_NOWAIT);
	if (ifq->ifq_congestion == NULL)
		return;
	timeout_set(ifq->ifq_congestion, if_congestion_clear, ifq);
	timeout_add(ifq->ifq_congestion, hz / 100);
d799 2
a800 5
/*
 * clear the congestion flag
 */
void
if_congestion_clear(void *arg)
d802 1
a802 2
	struct ifqueue *ifq = arg;
	struct timeout *to = ifq->ifq_congestion;
d804 1
a804 2
	ifq->ifq_congestion = NULL;
	free(to, M_TEMP, sizeof(*to));
@


1.320
log
@Fix a regression introduced when switching from rtsold to the kernel for
router solicitations. Send the router soliciation right away instead of
having a 60 second window between enabling SLAAC on the interface and the
router solicitation being sent.

ok florian@@ stsp@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.319 2015/02/09 03:09:57 dlg Exp $	*/
a85 1
#include <net/if_media.h>
@


1.319
log
@tweak the new if_input function so it takes an mbuf_list instead
of a single mbuf. this forces us to batch work between the hardware
rx handlers and the stack.

this includes a converstion of bge from ether_input to if_input.

ok claudio@@ pelikan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.318 2015/02/09 00:21:58 dlg Exp $	*/
d1354 2
a1355 1
				nd6_rs_output_set_timo(nd6_rs_output_timeout);
@


1.318
log
@move the init of the if_input from ether_ifattach to if_attach.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.317 2015/02/08 06:00:52 mpi Exp $	*/
d436 1
a436 1
if_input(struct ifnet *ifp, struct mbuf *m)
d438 1
d443 3
a445 2
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;
d448 2
a449 2
	if (ifp->if_bpf)
		bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
d452 4
a455 3
	SLIST_FOREACH(ifih, &ifp->if_inputs, ifih_next) {
		if ((*ifih->ifih_input)(ifp, NULL, m))
			break;
@


1.317
log
@Introduce if_input() a function to pass packets dequeued from a
recieving ring to the stack.

if_input() is at the moment a drop-in replacement for ether_input_mbuf()
but will let us stack pseudo-driver in a nice way in order to no longer
call ether_input() recursively.

ok pelikan@@, reyk@@, blambert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.316 2015/02/05 10:28:50 henning Exp $	*/
d408 2
@


1.316
log
@implement SIOCIFAFATTACH and SIOCIFAFDETACH for AF_INET
SIOCIFAFATTACH is a noop
SIOCIFAFDETACH calls in_ifdetach(), thus removing all AF_INET addresses
ok phessler theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.314 2015/01/27 03:17:36 dlg Exp $	*/
d430 21
@


1.315
log
@Ensure that link-local addresses are correctly configured on loopback
interfaces.

When the kernel automagically configures IPv6 addresses on loopback
interfaces, start by assigning a link-local address and then try to
assign "::1".

Only the first configured loopback interface per rdomain can have the
"::1" address.  But even if other loopback interfaces failed to get
this address, because it is already taken, give them a chance to have
a link-local address.

While here change in6_ifattach() to return an error value and remove
duplicated code.

Fix a regression introduced by the NOINET6 flag removal.

ok henning@@, stsp@@, florian@@, benno@@
@
text
@d1238 8
@


1.314
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.313 2015/01/21 02:23:14 guenther Exp $	*/
d1241 3
a1243 4
			if (cmd == SIOCIFAFATTACH) {
				if (in6ifa_ifpforlinklocal(ifp, 0) == NULL)
					in6_ifattach(ifp);
			} else
d1309 3
a1311 5
			if (in6ifa_ifpforlinklocal(ifp, 0) == NULL) {
				s = splsoftnet();
				in6_ifattach(ifp);
				splx(s);
			}
a1313 3
		if (ifr->ifr_flags & IFXF_AUTOCONF6)
			nd6_rs_output_set_timo(ND6_RS_OUTPUT_QUICK_INTERVAL);

d2196 4
a2199 2
	/* Update the link-local address. Don't do it if we're
	 * a router to avoid confusing hosts on the network. */
d2205 1
a2205 6
			in6_ifattach_linklocal(ifp, NULL);
			if (in6if_do_dad(ifp)) {
				ifa = &in6ifa_ifpforlinklocal(ifp, 0)->ia_ifa;
				if (ifa)
					nd6_dad_start(ifa, NULL);
			}
@


1.313
log
@Delete option COMPAT_43: support for pre-sa_len binaries has been obsolete
for a couple decades.  Keep the OSIOCGIFCONF ioctl to support COMPAT_LINUX
but move the rest of the Linux-specific ioctl() handling into linux_socket.c
This lets struct osockaddr finally move from sys/socket.h to protocols/talkd.h

ok krw@@ deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.312 2015/01/14 00:37:19 bluhm Exp $	*/
d145 1
a145 1
void	if_link_state_change_task(void *, void *);
d268 1
a268 2
	task_set(ifp->if_linkstatetask, if_link_state_change_task,
	    ifp, NULL);
d1121 1
a1121 1
if_link_state_change_task(void *arg, void *unused)
@


1.312
log
@It is sufficient to protect in6_ifattach() with splsoftnet().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.311 2015/01/10 11:43:37 mpi Exp $	*/
d1206 1
d1208 1
a1607 1
#if !defined(COMPAT_43) && !defined(COMPAT_LINUX)
a1610 51
#else
	    {
		u_long ocmd = cmd;

		switch (cmd) {

		case SIOCSIFADDR:
		case SIOCSIFDSTADDR:
		case SIOCSIFBRDADDR:
		case SIOCSIFNETMASK:
#if BYTE_ORDER != BIG_ENDIAN
			if (ifr->ifr_addr.sa_family == 0 &&
			    ifr->ifr_addr.sa_len < 16) {
				ifr->ifr_addr.sa_family = ifr->ifr_addr.sa_len;
				ifr->ifr_addr.sa_len = 16;
			}
#else
			if (ifr->ifr_addr.sa_len == 0)
				ifr->ifr_addr.sa_len = 16;
#endif
			break;

		case OSIOCGIFADDR:
			cmd = SIOCGIFADDR;
			break;

		case OSIOCGIFDSTADDR:
			cmd = SIOCGIFDSTADDR;
			break;

		case OSIOCGIFBRDADDR:
			cmd = SIOCGIFBRDADDR;
			break;

		case OSIOCGIFNETMASK:
			cmd = SIOCGIFNETMASK;
		}
		error = ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
		    (struct mbuf *) cmd, (struct mbuf *) data,
		    (struct mbuf *) ifp, p));
		switch (ocmd) {

		case OSIOCGIFADDR:
		case OSIOCGIFDSTADDR:
		case OSIOCGIFBRDADDR:
		case OSIOCGIFNETMASK:
			*(u_int16_t *)&ifr->ifr_addr = ifr->ifr_addr.sa_family;
		}

	    }
#endif
d1653 1
a1653 1
#if defined(COMPAT_43) || defined(COMPAT_LINUX)
d1684 1
a1684 1
#if defined(COMPAT_43) || defined(COMPAT_LINUX)
a1685 2
					struct osockaddr *osa =
					    (struct osockaddr *)&ifr.ifr_addr;
d1687 2
a1688 1
					osa->sa_family = sa->sa_family;
@


1.311
log
@Correct some comments and merge in6_if_up() into in6_ifattach() to
reflect that IPv6 link-local addresses are no longer automagically
configured the first time an interface is brought up.

ok henning@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.310 2015/01/06 21:26:46 stsp Exp $	*/
d1310 1
a1310 1
				s = splnet();
@


1.310
log
@Remove the NOINET6 interface flag, a left-over from the times when IPv6
was enabled by default. Add AFATTACH/AFDETACH ioctls which enable/disable
an address family for an interface (currently used for IPv6 only).

New kernel needs new ifconfig for IPv6 configuration (address assignment
still works with old ifconfig making this easy to cross over).

Committing on behalf of henning@@ who is currently lebensmittelvergiftet.
ok stsp, benno, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.309 2014/12/19 17:14:39 tedu Exp $	*/
d1099 3
a1101 2
	if (ifp == lo0ifp)	/* lo0 is special - needs ::1 */
		in6_if_up(ifp);
d1242 1
a1242 1
					in6_if_up(ifp);
d1311 1
a1311 1
				in6_if_up(ifp);
@


1.309
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.308 2014/12/18 15:29:30 krw Exp $	*/
a385 4
#ifdef INET6
	ifp->if_xflags |= IFXF_NOINET6;
#endif

d1099 1
a1099 1
	if (!(ifp->if_xflags & IFXF_NOINET6))
a1101 1

d1193 1
d1228 22
d1307 2
a1308 11
		if (ifr->ifr_flags & IFXF_NOINET6 &&
		    !(ifp->if_xflags & IFXF_NOINET6)) {
			s = splnet();
			in6_ifdetach(ifp);
			splx(s);
		}
		if (ifp->if_xflags & IFXF_NOINET6 &&
		    !(ifr->ifr_flags & IFXF_NOINET6)) {
			ifp->if_xflags &= ~IFXF_NOINET6;
			if (ifp->if_flags & IFF_UP) {
				/* configure link-local address */
d1326 1
d1335 1
a1335 1
#endif
d1354 1
a1354 1
#endif
d1663 1
a1663 1
	if (((oif_flags ^ ifp->if_flags) & IFF_UP) != 0) {
d1665 1
a1665 9
#ifdef INET6
		if (!(ifp->if_xflags & IFXF_NOINET6) &&
		    (ifp->if_flags & IFF_UP) != 0) {
			s = splnet();
			in6_if_up(ifp);
			splx(s);
		}
#endif
	}
d2255 1
a2255 1
	if (!(ifp->if_xflags & IFXF_NOINET6) && !ip6_forwarding) {
@


1.308
log
@Change the link state change routing message generation to a taskq.
One less workq to worry about.

Tweaks from many. ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.307 2014/12/17 09:45:59 mpi Exp $	*/
a90 1
#ifdef INET
a96 1
#endif
a98 3
#ifndef INET
#include <netinet/in.h>
#endif
a498 1
#ifdef INET
a506 2
#endif
#ifdef INET
a507 1
#endif
a525 1
#ifdef INET
a527 1
#endif
a1517 1
#ifdef INET
a1521 1
#endif
a1524 1
#ifdef INET
a1525 1
#endif
@


1.307
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.306 2014/12/08 10:46:14 mpi Exp $	*/
d82 1
a82 1
#include <sys/workq.h>
d273 3
d416 2
d485 3
d571 1
d1129 2
a1130 3
	/* try to put the routing table update task on syswq */
	workq_add_task(NULL, 0, if_link_state_change_task,
	    (void *)((unsigned long)ifp->if_index), NULL);
d1139 1
a1139 2
	unsigned int index = (unsigned long)arg;
	struct ifnet *ifp;
d1143 1
a1143 2
	if ((ifp = if_get(index)) != NULL) {
		rt_ifmsg(ifp);
d1145 1
a1145 1
		rt_if_track(ifp);
d1147 1
a1147 2
		dohooks(ifp->if_linkstatehooks, 0);
	}
@


1.306
log
@There's no good reason to keep into "struct ifnet" a pointer that's only
used by enc(4) devices to attach their routes.

ok sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.305 2014/12/01 15:06:54 mikeb Exp $	*/
a534 5

	/*
	 * XXX transient ifp refs?  inpcb.ip_moptions.imo_multicast_ifp?
	 * Other network stacks than INET?
	 */
@


1.305
log
@Make every interface with a watchdog register it's own slow timeout

This removes the system wide if_slowtimo timeout and lets every
interface with a valid if_watchdog method register it's own in
order to get rid of the ifnet loop in the softclock context and
avoid further complications with concurrent access to the ifnet
list.

ok deraadt, input and ok mpi, looked at by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.304 2014/11/23 07:39:02 deraadt Exp $	*/
d286 1
a286 1
	unsigned int socksize, ifasize;
a288 1
	struct ifaddr *ifa;
d305 1
a305 3
	ifasize = sizeof(*ifa) + socksize;
	ifa = malloc(ifasize, M_IFADDR, M_WAITOK|M_ZERO);
	sdl = (struct sockaddr_dl *)(ifa + 1);
a312 4
	ifp->if_lladdr = ifa;
	ifa->ifa_ifp = ifp;
	ifa->ifa_rtrequest = link_rtrequest;
	ifa->ifa_addr = (struct sockaddr *)sdl;
a313 1
	ifa->ifa_netmask = NULL;
d324 1
a324 11
	struct ifaddr *ifa;
	int s;

	ifa = ifp->if_lladdr;
	if (ifa == NULL)
		return;

	s = splnet();
	rt_ifa_del(ifa, 0, ifa->ifa_addr);
	ifafree(ifp->if_lladdr);
	ifp->if_lladdr = NULL;
a325 1
	splx(s);
a1206 1
	struct ifaddr *ifa;
d1579 1
a1579 4
		ifa = ifp->if_lladdr;
		if (ifa == NULL)
			return (EINVAL);
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
@


1.304
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.303 2014/11/03 11:02:08 mpi Exp $	*/
a137 1
void	if_detached_watchdog(struct ifnet *);
a172 3
	static struct timeout if_slowtim;

	timeout_set(&if_slowtim, if_slowtimo, &if_slowtim);
a174 1
	if_slowtimo(&if_slowtim);
d270 3
d429 3
d487 1
a487 1
	ifp->if_watchdog = if_detached_watchdog;
d496 3
d586 2
d1171 2
a1172 2
 * Handle interface watchdog timer routines.  Called
 * from softclock, we decrement timers (if set) and
d1178 1
a1178 2
	struct timeout *to = (struct timeout *)arg;
	struct ifnet *ifp;
d1181 2
a1182 4
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_timer == 0 || --ifp->if_timer)
			continue;
		if (ifp->if_watchdog)
d1184 1
a1186 1
	timeout_add(to, hz / IFNET_SLOWHZ);
a1829 6
}

void
if_detached_watchdog(struct ifnet *ifp)
{
	/* nothing */
@


1.303
log
@Do no change the gateway of local routes for p2p interfaces.

This change was defeating the code in rtrequest1(9) checking for route
entries with the same dst/gw when the same IP address was configured on
multiple interfaces.

As a result, multiple local routes were created for the same address and
marked as multipath.  But changing their gateway to 127.0.0.1 would make
them similar and impossible to remove.  This would leaves entries with a
stall ifa pointer as soon as the address was removed.

Prevent a panic reported by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.302 2014/10/08 12:37:57 mpi Exp $	*/
d815 1
a815 1
	free(to, M_TEMP, 0);
d1880 1
a1880 1
		free(ifgl, M_TEMP, 0);
d1889 2
a1890 2
		free(ifgl, M_TEMP, 0);
		free(ifgm, M_TEMP, 0);
d1931 1
a1931 1
		free(ifgm, M_TEMP, 0);
d1942 1
a1942 1
	free(ifgl, M_TEMP, 0);
@


1.302
log
@Tedu the RB-tree of addresses, thanks for all the fish!

ok henning@@, dlg@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.301 2014/09/30 08:27:57 mpi Exp $	*/
a1020 1
		rt_setgate(rt, rt_key(rt), lo0ifa->ifa_addr, ifp->if_rdomain);
@


1.301
log
@Stop using the RB-tree in ifa_ifwithaddr() and make it lookup over
all the per-interface lists of addresses.

Teaks and ok bluhm@@, ok kspillner@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.300 2014/08/25 14:00:34 florian Exp $	*/
a73 1
#include <sys/pool.h>
a76 1
#include <sys/tree.h>
d153 2
a154 13
struct ifaddr_item {
	RB_ENTRY(ifaddr_item)	 ifai_entry;
	struct sockaddr		*ifai_addr;
	struct ifaddr		*ifai_ifa;
	struct ifaddr_item	*ifai_next;
	u_int			 ifai_rdomain;
};

int	ifai_cmp(struct ifaddr_item *,  struct ifaddr_item *);
void	ifa_item_insert(struct sockaddr *, struct ifaddr *, struct ifnet *);
void	ifa_item_remove(struct sockaddr *, struct ifaddr *, struct ifnet *);
#ifndef SMALL_KERNEL
void	ifa_print_rb(void);
a156 4
RB_HEAD(ifaddr_items, ifaddr_item) ifaddr_items = RB_INITIALIZER(&ifaddr_items);
RB_PROTOTYPE(ifaddr_items, ifaddr_item, ifai_entry, ifai_cmp);
RB_GENERATE(ifaddr_items, ifaddr_item, ifai_entry, ifai_cmp);

a160 2
struct pool ifaddr_item_pl;

a175 3
	pool_init(&ifaddr_item_pl, sizeof(struct ifaddr_item), 0, 0, 0,
	    "ifaddritem", NULL);

a2212 3
	ifa_item_insert(ifa->ifa_addr, ifa, ifp);
	if (ifp->if_flags & IFF_BROADCAST && ifa->ifa_broadaddr)
		ifa_item_insert(ifa->ifa_broadaddr, ifa, ifp);
a2218 3
	ifa_item_remove(ifa->ifa_addr, ifa, ifp);
	if (ifp->if_flags & IFF_BROADCAST && ifa->ifa_broadaddr)
		ifa_item_remove(ifa->ifa_broadaddr, ifa, ifp);
a2223 1
	ifa_item_remove(ifa->ifa_broadaddr, ifa, ifp);
a2226 10
	ifa_item_insert(ifa->ifa_broadaddr, ifa, ifp);
}

int
ifai_cmp(struct ifaddr_item *a, struct ifaddr_item *b)
{
	if (a->ifai_rdomain != b->ifai_rdomain)
		return (a->ifai_rdomain - b->ifai_rdomain);
	/* safe even with a's sa_len > b's because memcmp aborts early */
	return (memcmp(a->ifai_addr, b->ifai_addr, a->ifai_addr->sa_len));
d2229 2
d2232 1
a2232 1
ifa_item_insert(struct sockaddr *sa, struct ifaddr *ifa, struct ifnet *ifp)
d2234 2
a2235 1
	struct ifaddr_item	*ifai, *p;
d2237 2
a2238 51
	ifai = pool_get(&ifaddr_item_pl, PR_WAITOK);
	ifai->ifai_addr = sa;
	ifai->ifai_ifa = ifa;
	ifai->ifai_rdomain = ifp->if_rdomain;
	ifai->ifai_next = NULL;
	if ((p = RB_INSERT(ifaddr_items, &ifaddr_items, ifai)) != NULL) {
		if (sa->sa_family == AF_LINK) {
			RB_REMOVE(ifaddr_items, &ifaddr_items, p);
			ifai->ifai_next = p;
			RB_INSERT(ifaddr_items, &ifaddr_items, ifai);
		} else {
			while(p->ifai_next)
				p = p->ifai_next;
			p->ifai_next = ifai;
		}
	}
}

void
ifa_item_remove(struct sockaddr *sa, struct ifaddr *ifa, struct ifnet *ifp)
{
	struct ifaddr_item	*ifai, *ifai_first, *ifai_last, key;

	bzero(&key, sizeof(key));
	key.ifai_addr = sa;
	key.ifai_rdomain = ifp->if_rdomain;
	ifai_first = RB_FIND(ifaddr_items, &ifaddr_items, &key);
	for (ifai = ifai_first; ifai; ifai = ifai->ifai_next) {
		if (ifai->ifai_ifa == ifa)
			break;
		ifai_last = ifai;
	}
	if (!ifai)
		return;
	if (ifai == ifai_first) {
		RB_REMOVE(ifaddr_items, &ifaddr_items, ifai);
		if (ifai->ifai_next)
			RB_INSERT(ifaddr_items, &ifaddr_items, ifai->ifai_next);
	} else
		ifai_last->ifai_next = ifai->ifai_next;
	pool_put(&ifaddr_item_pl, ifai);
}

#ifndef SMALL_KERNEL
/* debug function, can be called from ddb> */
void
ifa_print_rb(void)
{
	struct ifaddr_item *ifai, *p;
	RB_FOREACH(p, ifaddr_items, &ifaddr_items) {
		for (ifai = p; ifai; ifai = ifai->ifai_next) {
d2241 1
a2241 1
			switch (ifai->ifai_addr->sa_family) {
d2244 1
a2244 1
				    &satosin(ifai->ifai_addr)->sin_addr,
d2250 1
a2250 1
				    &(satosin6(ifai->ifai_addr))->sin6_addr,
d2256 1
a2256 1
				    ether_sprintf(ifai->ifai_addr->sa_data));
d2259 1
a2259 1
			printf(" on %s\n", ifai->ifai_ifa->ifa_ifp->if_xname);
@


1.300
log
@Move sending of router solicitations to the kernel; receiving and
processing of router advertisements was already in the kernel.
With this rtsol{,d}(8) is no longer necessary.

The kernel starts sending solicitations with
# ifconfig $IF inet6 autoconf
or
inet6 autoconf
in /etc/hostname.$IF.

input stsp@@
much help & OK mpi@@
tweaks & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.299 2014/08/14 11:38:14 mikeb Exp $	*/
d840 4
a846 1
/*ARGSUSED*/
d850 15
a864 1
	struct ifaddr_item *ifai, key;
d866 8
a873 7
	bzero(&key, sizeof(key));
	key.ifai_addr = addr;
	key.ifai_rdomain = rtable_l2(rtableid);

	ifai = RB_FIND(ifaddr_items, &ifaddr_items, &key);
	if (ifai)
		return (ifai->ifai_ifa);
a875 4

#define	equal(a1, a2)	\
	(bcmp((caddr_t)(a1), (caddr_t)(a2),	\
	((struct sockaddr *)(a1))->sa_len) == 0)
@


1.299
log
@Compare number of allocated clusters with a low watermark, not
a magic number 4 since sometimes we can't fit a single packet
(jumbo frame) into 4 clusters.

OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.298 2014/08/11 13:51:07 mpi Exp $	*/
d1341 20
@


1.298
log
@Use the RTF_LOCAL flag instead of abusing the RTF_LLINFO flag when
adding local route entries.

This hack made sense when we didn't have the RTF_LOCAL flag, but since
some months it is set on every local route.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.297 2014/07/12 18:44:22 tedu Exp $	*/
d2415 1
a2415 1
	} else if (rxr->rxr_alive > 4)
@


1.297
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.296 2014/07/12 16:10:04 henning Exp $	*/
d1004 1
a1004 6
		/*
		 * XXX Here we abuse RTF_LLINFO to add a route to
		 * loopback.  We do that to always have a route
		 * pointing to our address.
		 */
		if ((rt->rt_flags & RTF_LLINFO) == 0)
@


1.296
log
@/* this has no effect on IP, and will kill all ISO connections XXX */
farewell, then. has been #ifdef notyet for the last 19 years
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.294 2014/07/08 07:10:12 dlg Exp $	*/
d277 1
a277 1
			free((caddr_t)ifindex2ifnet, M_IFADDR);
d600 3
a602 3
	free(ifp->if_addrhooks, M_TEMP);
	free(ifp->if_linkstatehooks, M_TEMP);
	free(ifp->if_detachhooks, M_TEMP);
d837 1
a837 1
	free(to, M_TEMP);
d1874 1
a1874 1
		free(ifgl, M_TEMP);
d1883 2
a1884 2
		free(ifgl, M_TEMP);
		free(ifgm, M_TEMP);
d1925 1
a1925 1
		free(ifgm, M_TEMP);
d1933 1
a1933 1
		free(ifgl->ifgl_group, M_TEMP);
d1936 1
a1936 1
	free(ifgl, M_TEMP);
@


1.295
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@a1122 4
#ifdef notyet
	struct ifaddr *ifa;
#endif

a1126 6
#ifdef notyet
	/* this has no effect on IP, and will kill all ISO connections XXX */
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		pfctlinput(PRC_IFUP, ifa->ifa_addr);
	}
#endif
@


1.294
log
@pull the rx ring accounting out of the mbuf layer now that its all done
via if_rxring things. this effectively deprecates the third argument
for MCLGETI and m_clget and makes the mbuf layer no longer care about
interfaces and simplifies the allocation paths.

the timeout used to measure livelock has been moved to net/if.c.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.293 2014/07/08 04:02:14 dlg Exp $	*/
a63 1
#include "bluetooth.h"
@


1.293
log
@introduce the if_rxr api. it is intended to pull the rx ring accounting
out of the mbuf layer, and break the assumption that an interface will
only have a single ring per mbuf cluster size.

mpi@@ is ok with moving this forward
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.292 2014/06/26 13:08:25 mpi Exp $	*/
d181 2
d200 1
d203 1
a435 2
	m_clinitifp(ifp);

a1154 2

	m_clinitifp(ifp);
d2385 16
a2404 1
	extern int m_clticks;
d2406 1
a2406 1
	return (ticks - m_clticks > 1);
@


1.292
log
@Calling in{6,}_purgeaddr() is not enough to remove an address from
an interface.  Two other operations are performed when issuing a
SIOCDIFADDR{_IN6,} ioctl: call the address hook and the per-driver
ioctl function.

Since carp(4) relies on an address hook to recalculate its hash, make
sure to call this hook when IFXF_NOINET6 is set or when the rdomain is
changed.

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.291 2014/06/23 18:51:15 henning Exp $	*/
d181 2
d2383 99
@


1.291
log
@turn of IPv6 for new interfaces by default. this really just means there
is no link-local address assigned by default, which - by default, since
INET6 is in the GENERIC kernels - makes the machine and services on it
reachable. No such thing in IPv4 land.
since assigning an inet6 address manually or running rtsol(d) etc resets the
NOINET6 flag and causes the link-local to be assigned, this really is a noop
for all inet6 users with the exception of those ONLY using the default
link-local address. These needs to run "ifconfig <if> inet6 eui64" or put
the equivalent in hostname.if.
discussed at length with many, ok at least by krw todd benno sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.288 2014/05/13 14:33:25 claudio Exp $	*/
d2364 1
@


1.290
log
@g/c unused IFT_L2VLAN, ok reyk bluhm
the #define stays since it's userland visible and who knows what uses it
@
text
@d426 3
@


1.289
log
@Do not put any link-layer address on the per-ifp lists or on the RB-
Tree.

Since interfaces only support one link-layer address accessible via the
if_sadl member, there's no need to have it elsewhere.  This improves
various address lookups because the first element of the list, the link-
layer address, won't necessarily be discarded.

Finally remove the empty netmask associated to every link-layer address.
This hack was needed to (ab)use the address & netmask comparison code to
do a strcmp() on the interface name embedded in the sdl_data field.

ok henning@@, claudio@@
@
text
@a1610 1
		case IFT_L2VLAN:
@


1.288
log
@While Rev 1.285 fixed a RB tree corruption it caused a TAILQ corruption
in the case where the rdomain was not switched. Make sure ifa_add() is
only called if ifa_del() was called previously. Hopefully we got all the
corruption fixed.
With and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.287 2014/05/05 11:44:33 mpi Exp $	*/
d325 1
a325 1
	ifasize = sizeof(*ifa) + 2 * socksize;
d340 1
a340 6
	sdl = (struct sockaddr_dl *)(socksize + (caddr_t)sdl);
	ifa->ifa_netmask = (struct sockaddr *)sdl;
	sdl->sdl_len = masklen;
	while (namelen != 0)
		sdl->sdl_data[--namelen] = 0xff;
	ifa_add(ifp, ifa);
a359 1
	ifa_del(ifp, ifa);
d1248 1
a1248 1
	int s, error = 0, needsadd;
a1532 1
		needsadd = 0;
a1557 6
			/*
			 * Remove sadl from ifa RB tree because rdomain is part
			 * of the lookup key and re-add it after the switch.
			 */
			ifa_del(ifp, ifp->if_lladdr);
			needsadd = 1;
a1567 4

		/* re-add sadl to the ifa RB tree in new rdomain */
		if (needsadd)
			ifa_add(ifp, ifp->if_lladdr);
d2212 1
a2212 4
	if (ifa->ifa_addr->sa_family == AF_LINK)
		TAILQ_INSERT_HEAD(&ifp->if_addrlist, ifa, ifa_list);
	else
		TAILQ_INSERT_TAIL(&ifp->if_addrlist, ifa, ifa_list);
@


1.287
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.286 2014/04/22 12:35:00 mpi Exp $	*/
d1254 1
a1254 1
	int s, error = 0;
d1539 1
d1570 1
d1583 2
a1584 1
		ifa_add(ifp, ifp->if_lladdr);
@


1.286
log
@ifa_ifwithroute() is the only magic place where an AF_LINK sockaddr
can be given to ifa_ifwithnet().

Handle this specific case directly and let ifa_ifwithnet() do only
one thing:  iterate on all the addresses of all the interfaces in a
given routing domain to return the most specific matching address.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.285 2014/04/20 11:25:18 claudio Exp $	*/
d991 65
@


1.285
log
@When switching rdomains the sadl needs to be removed and re-added from the
RB lookup tree because the rdomain id is part of the lookup key.
Without this the RB tree gets corrupted and in the worst case a use after
free can happen when the interface is destroyed.
Why the sadl addresses are added to the tree in the first place is something
to reconsider.
OK henning@@, mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.284 2014/04/19 12:27:59 henning Exp $	*/
d894 1
a894 1
ifa_ifwithnet(struct sockaddr *addr, u_int rdomain)
d897 3
a899 4
	struct ifaddr *ifa;
	struct ifaddr *ifa_maybe = 0;
	u_int af = addr->sa_family;
	char *addr_data = addr->sa_data, *cplim;
d901 1
a901 6
	rdomain = rtable_l2(rdomain);
	if (af == AF_LINK) {
		struct sockaddr_dl *sdl = (struct sockaddr_dl *)addr;
		if (sdl->sdl_index && (ifp = if_get(sdl->sdl_index)) != NULL)
			return (ifp->if_lladdr);
	}
d908 1
a908 1
			if (ifa->ifa_addr->sa_family != af ||
@


1.284
log
@remove the altq enable/attach and disable/detach bits
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.282 2014/03/20 13:19:06 mpi Exp $	*/
d1505 5
d1520 3
@


1.283
log
@Retire rtinit() an use rt_ifa_add(9) and rt_ifa_del(9) to manage
connected routes to prefixes/hosts.

Since the introduction of rt_ifa_addloop(9) and rt_ifa_delloop(9),
rtinit() was just a wrapper, so use the underlying functions
directly and document them.

Inputs from and ok mikeb@@, manpage tweaks from jmc@@
@
text
@a284 7
#ifdef ALTQ
	ifp->if_snd.altq_type = 0;
	ifp->if_snd.altq_disc = NULL;
	ifp->if_snd.altq_flags &= ALTQF_CANTCHANGE;
	ifp->if_snd.altq_tbr  = NULL;
	ifp->if_snd.altq_ifp  = ifp;
#endif
a530 6
#endif
#ifdef ALTQ
	if (ALTQ_IS_ENABLED(&ifp->if_snd))
		altq_disable(&ifp->if_snd);
	if (ALTQ_IS_ATTACHED(&ifp->if_snd))
		altq_detach(&ifp->if_snd);
@


1.282
log
@Do not pull <sys/tree.h> unconditionally in <net/if.h>, only the address
tree and the 80211 nodes need it.

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.281 2014/03/19 13:49:12 mpi Exp $	*/
d371 1
a371 1
	rtinit(ifa, RTM_DELETE, 0);
@


1.281
log
@Since in{,6}_ifdetach() take care of removing the IPv4/6 addresses
from the per-ifp list when an interface is destroyed/removed the
only address left on the list at this point is the link-layer one.

So remove the custom loop and its associated hack for the link-layer
address and simply call if_free_sadl().

As a side effect, this should fix any scenario where if_alloc_sadl()
is called multiple time since the first link-layer address allocated
was never removed from the per-ifp list.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.280 2014/02/04 01:04:03 tedu Exp $	*/
d79 1
d156 8
d170 1
@


1.280
log
@reduce the length of some pool names. ok deraadt guenther mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.279 2013/11/28 10:16:44 mpi Exp $	*/
a361 1
#if 0
d363 1
a364 1
#endif
a365 1

a492 2
 * XXX So far only the INET protocol family has been looked over
 * wrt resource usage that needs to be decoupled.
a585 13
	/*
	 * Deallocate private resources.
	 */
	while ((ifa = TAILQ_FIRST(&ifp->if_addrlist)) != NULL) {
		ifa_del(ifp, ifa);
		/* XXX if_free_sadl needs this */
		if (ifa == ifp->if_lladdr)
			continue;

		ifa->ifa_ifp = NULL;
		ifafree(ifa);
	}

d591 11
a601 3
	ifp->if_lladdr->ifa_ifp = NULL;
	ifafree(ifp->if_lladdr);
	ifp->if_lladdr = NULL;
@


1.279
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.278 2013/11/27 08:34:40 mpi Exp $	*/
d183 1
a183 1
	    "ifaddritempl", NULL);
@


1.278
log
@Let's call a rtableid a rtableid.

ok mikeb@@, henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.277 2013/11/19 09:00:43 mpi Exp $	*/
d440 2
a442 1
	TAILQ_INIT(&ifp->if_addrlist);
@


1.277
log
@Remove some FDDI/ATM leftovers.

ok mikeb@@, henning@@, deraadt@@, brad@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.276 2013/11/18 09:16:30 mpi Exp $	*/
d856 1
a856 1
ifa_ifwithaddr(struct sockaddr *addr, u_int rdomain)
d862 1
a862 1
	key.ifai_rdomain = rtable_l2(rdomain);
d867 1
a867 1
	return (NULL);	
@


1.276
log
@Convert trunk(4) to use a detachhook, discussed at b2k13 with many.

While here add a comment explaining detach hooks' order of execution when
destroying/detaching an interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.275 2013/11/11 09:15:34 mpi Exp $	*/
a1566 1
		case IFT_FDDI:
@


1.275
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.274 2013/10/23 15:12:42 mpi Exp $	*/
a120 4
#if NTRUNK > 0
#include <net/if_trunk.h>
#endif

d510 5
a514 1
	/* Call detach hooks, ie. to remove vlan interfaces */
a515 5

#if NTRUNK > 0
	if (ifp->if_type == IFT_IEEE8023ADLAG)
		trunk_port_ifdetach(ifp);
#endif
@


1.274
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.273 2013/10/21 08:44:13 phessler Exp $	*/
d2269 2
d2273 3
a2275 2
				printf("%s", inet_ntoa((satosin(
				    ifai->ifai_addr))->sin_addr));
d2279 3
a2281 2
				printf("%s", ip6_sprintf(&(satosin6(
				    ifai->ifai_addr))->sin6_addr));
@


1.273
log
@Enable IPv6 routing domain support

Started by claudio@@ for IPv4, lots of heavy work by sperreault@@

My part started at s2k11, continued at n2k12, g2k12, c2k12 and n2k13.

Lots of help and hints from claudio and bluhm

OK claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.272 2013/10/20 13:21:56 claudio Exp $	*/
a94 1
#include <netinet/in_var.h>
@


1.272
log
@rt_mpath_next() was always called with 0 in the last argument. So drop it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.271 2013/10/19 14:54:18 mikeb Exp $	*/
d1216 1
d1499 10
a1517 1
			ifp->if_xflags |= IFXF_NOINET6;
d1664 6
@


1.271
log
@in order to make our life a tad easier and prevent rogue accesses
to the routing table from the hardware interrupt context defer the
if_link_state_change to the process context.

a token (an interface index) is passed to the workq in order to
make sure that if the interface would be gone by the time syswq
goes around to run the task it would just fall through.

ok henning, mpi, deraadt, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.270 2013/10/19 14:05:14 reyk Exp $	*/
d2073 1
a2073 1
			rt = rt_mpath_next(rt, 0);
d2087 1
a2087 1
			rt = rt_mpath_next(rt, 0);
@


1.270
log
@Bring back the if_detachhook.  We're going to have more users now.

ok mpi@@ henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.269 2013/10/19 11:11:24 mpi Exp $	*/
d84 1
d158 2
d1117 11
a1128 1
 * NOTE: must be called at splsoftnet or equivalent.
d1131 1
a1131 1
if_link_state_change(struct ifnet *ifp)
d1133 7
a1139 1
	rt_ifmsg(ifp);
d1141 1
a1141 1
	rt_if_track(ifp);
d1143 3
a1145 1
	dohooks(ifp->if_linkstatehooks, 0);
@


1.269
log
@When we attach an interface, do not try to reuse the last index to
limit the possible races related to unscheduled task, or anything
else, relying on an unique index.

I say "limit" here because a race can still occurs if you run out
of indexes and jump back to 1.  A generation number can be added
later to avoid this problem.

ok deraadt@@, claudio@@, krw@@, mikeb@@, "I can live with it" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.268 2013/10/17 16:27:40 bluhm Exp $	*/
a67 1
#include "ether.h"
d70 1
a70 1
#include "vlan.h"
a136 4
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

a290 4
#if NVLAN > 0
	LIST_INIT(&ifp->if_vlist);
#endif

d450 3
d512 2
a513 4
#if NVLAN > 0
	if (!LIST_EMPTY(&ifp->if_vlist))
		vlan_ifdetach(ifp);
#endif
d616 1
@


1.268
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.267 2013/10/09 09:33:42 mpi Exp $	*/
d213 13
a225 1
	if (ifindex2ifnet == 0)
d227 7
a233 4
	else {
		while (if_index < if_indexlim &&
		    ifindex2ifnet[if_index] != NULL) {
			if_index++;
d235 3
a237 6
			 * If we hit USHRT_MAX, we skip back to 1 since
			 * there are a number of places where the value
			 * of ifp->if_index or if_index itself is compared
			 * to or stored in an unsigned short.  By
			 * jumping back, we won't botch those assignments
			 * or comparisons.
d239 5
a243 11
			if (if_index == USHRT_MAX) {
				if_index = 1;
				/*
				 * However, if we have to jump back to 1
				 * *twice* without finding an empty
				 * slot in ifindex2ifnet[], then there
				 * there are too many (>65535) interfaces.
				 */
				if (wrapped++)
					panic("too many interfaces");
			}
@


1.267
log
@Introduce in_ifdetach() a function to remove all the IPv4 addresses
of an interface, named after its IPv6 equivalent.

Make use of it instead of removing addresses by hand when detaching
or destroying an interface.  As a bonus, multicast records linked
to the just divorced^Wdetached interface are no longer leaked.

No objection from the gang, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.266 2013/09/17 13:34:17 mpi Exp $	*/
d107 1
@


1.266
log
@Change vlan(4) detach procedure to not use a hook but a list of vlans
on the parent interface.  This is similar to what bridge(4), trunk(4)
or carp(4) are doing and allows us to get rid of the detachhook.

ok reyk@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.265 2013/09/12 09:52:46 mpi Exp $	*/
d553 3
a597 4
#ifdef INET
		if (ifa->ifa_addr->sa_family == AF_INET)
			TAILQ_REMOVE(&in_ifaddr, ifatoia(ifa), ia_list);
#endif
d1186 1
a1186 1
	struct ifaddr *ifa, *nifa;
d1489 1
a1489 11
			TAILQ_FOREACH_SAFE(ifa, &ifp->if_addrlist, ifa_list,
			    nifa) {
				/* only remove AF_INET */
				if (ifa->ifa_addr->sa_family != AF_INET)
					continue;

				TAILQ_REMOVE(&in_ifaddr, ifatoia(ifa), ia_list);
				ifa_del(ifp, ifa);
				ifa->ifa_ifp = NULL;
				ifafree(ifa);
			}
@


1.265
log
@Revert previous diff to always increment the interface index, tun_switch()
depends on this feature, discussed with claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.263 2013/08/28 06:58:57 mpi Exp $	*/
d68 1
d71 1
a71 1
#include "ether.h"
d137 4
d289 4
a451 3
	ifp->if_detachhooks = malloc(sizeof(*ifp->if_detachhooks),
	    M_TEMP, M_WAITOK);
	TAILQ_INIT(ifp->if_detachhooks);
d511 4
a514 2
	/* Call detach hooks, ie. to remove vlan interfaces */
	dohooks(ifp->if_detachhooks, HOOK_REMOVE | HOOK_FREE);
a617 1
	free(ifp->if_detachhooks, M_TEMP);
@


1.264
log
@When we attach an interface, do not try to reuse the last index to limit
the possible races related to unscheduled task relying on an unique index.

I say "limit" here because a race can still occurs if you run out of
indexes and jump back to 1.

ok krw@@, mikeb@@
@
text
@d207 1
a207 13
	/*
	 * Always increment the index to avoid races.
	 */
	if_index++;

	/*
	 * If we hit USHRT_MAX, we skip back to 1 since there are a
	 * number of places where the value of ifp->if_index or
	 * if_index itself is compared to or stored in an unsigned
	 * short.  By jumping back, we won't botch those assignments
	 * or comparisons.
	 */
	if (if_index == USHRT_MAX) {
d209 4
a212 7
		wrapped++;
	}

	while (if_index < if_indexlim && ifindex2ifnet[if_index] != NULL) {
		if_index++;

		if (if_index == USHRT_MAX) {
d214 6
a219 3
			 * If we have to jump back to 1 twice without
			 * finding an empty slot then there are too many
			 * interfaces.
d221 11
a231 5
			if (wrapped)
				panic("too many interfaces");

			if_index = 1;
			wrapped++;
@


1.263
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.262 2013/08/20 09:14:22 mpi Exp $	*/
d207 13
a219 1
	if (ifindex2ifnet == 0)
d221 7
a227 4
	else {
		while (if_index < if_indexlim &&
		    ifindex2ifnet[if_index] != NULL) {
			if_index++;
d229 3
a231 6
			 * If we hit USHRT_MAX, we skip back to 1 since
			 * there are a number of places where the value
			 * of ifp->if_index or if_index itself is compared
			 * to or stored in an unsigned short.  By
			 * jumping back, we won't botch those assignments
			 * or comparisons.
d233 5
a237 11
			if (if_index == USHRT_MAX) {
				if_index = 1;
				/*
				 * However, if we have to jump back to 1
				 * *twice* without finding an empty
				 * slot in ifindex2ifnet[], then there
				 * there are too many (>65535) interfaces.
				 */
				if (wrapped++)
					panic("too many interfaces");
			}
@


1.262
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.261 2013/06/20 12:03:40 mpi Exp $	*/
d988 1
a988 1
link_rtrequest(int cmd, struct rtentry *rt, struct rt_addrinfo *info)
d1002 1
a1002 1
			ifa->ifa_rtrequest(cmd, rt, info);
@


1.261
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.260 2013/06/20 09:38:24 mpi Exp $	*/
a568 3
#endif
#ifdef NATM
	IF_DETACH_QUEUES(natmintrq);
@


1.260
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.259 2013/06/18 22:42:56 uebayasi Exp $	*/
d435 1
d437 9
a445 3
	TAILQ_INIT(&ifp->if_addrhooks);
	TAILQ_INIT(&ifp->if_linkstatehooks);
	TAILQ_INIT(&ifp->if_detachhooks);
d506 1
a506 1
	dohooks(&ifp->if_detachhooks, HOOK_REMOVE | HOOK_FREE);
d611 4
d1121 1
a1121 1
	dohooks(&ifp->if_linkstatehooks, 0);
@


1.259
log
@Use malloc(M_WAITOK) in if_attach_common(), because this function must
succeed, and it's always called in sleepable context.

OK mikeb@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a434 1

d436 3
a438 9
	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks),
	    M_TEMP, M_WAITOK);
	TAILQ_INIT(ifp->if_addrhooks);
	ifp->if_linkstatehooks = malloc(sizeof(*ifp->if_linkstatehooks),
	    M_TEMP, M_WAITOK);
	TAILQ_INIT(ifp->if_linkstatehooks);
	ifp->if_detachhooks = malloc(sizeof(*ifp->if_detachhooks),
	    M_TEMP, M_WAITOK);
	TAILQ_INIT(ifp->if_detachhooks);
d499 1
a499 1
	dohooks(ifp->if_detachhooks, HOOK_REMOVE | HOOK_FREE);
a603 4
	free(ifp->if_addrhooks, M_TEMP);
	free(ifp->if_linkstatehooks, M_TEMP);
	free(ifp->if_detachhooks, M_TEMP);

d1110 1
a1110 1
	dohooks(ifp->if_linkstatehooks, 0);
@


1.258
log
@Instead of storing the link-level address of every interface in a global
array indexed by interface numbers, add a new field to the interface
descriptor pointing to it.

claudio@@ and todd@@ like it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.257 2013/03/29 12:20:34 bluhm Exp $	*/
d438 1
a438 3
	    M_TEMP, M_NOWAIT);
	if (ifp->if_addrhooks == NULL)
		panic("if_attach_common: malloc");
d441 1
a441 3
	    M_TEMP, M_NOWAIT);
	if (ifp->if_linkstatehooks == NULL)
		panic("if_attach_common: malloc");
d444 1
a444 3
	    M_TEMP, M_NOWAIT);
	if (ifp->if_detachhooks == NULL)
		panic("if_attach_common: malloc");
@


1.257
log
@Replace hand-crafted loops in if.c with the FOREACH macro.
OK tedu@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.256 2013/03/28 23:10:05 tedu Exp $	*/
a192 1
struct ifaddr **ifnet_addrs = NULL;
a238 1
	 *	struct ifaddr **ifnet_addrs
d241 1
a241 1
	if (ifnet_addrs == 0 || ifindex2ifnet == 0 || if_index >= if_indexlim) {
a250 10
		/* grow ifnet_addrs */
		m = oldlim * sizeof(struct ifaddr *);
		n = if_indexlim * sizeof(struct ifaddr *);
		q = (caddr_t)malloc(n, M_IFADDR, M_WAITOK|M_ZERO);
		if (ifnet_addrs) {
			bcopy((caddr_t)ifnet_addrs, q, m);
			free((caddr_t)ifnet_addrs, M_IFADDR);
		}
		ifnet_addrs = (struct ifaddr **)q;

d327 1
a327 1
	ifnet_addrs[ifp->if_index] = ifa;
d351 1
a351 1
	ifa = ifnet_addrs[ifp->if_index];
d359 1
a359 1
	ifnet_addrs[ifp->if_index] = NULL;
d601 1
a601 1
		if (ifa == ifnet_addrs[ifp->if_index])
d613 3
a615 3
	ifnet_addrs[ifp->if_index]->ifa_ifp = NULL;
	ifafree(ifnet_addrs[ifp->if_index]);
	ifnet_addrs[ifp->if_index] = NULL;
d922 2
a923 2
		if (sdl->sdl_index && if_get(sdl->sdl_index))
			return (ifnet_addrs[sdl->sdl_index]);
d1542 1
a1542 1
		ifa = ifnet_addrs[ifp->if_index];
@


1.256
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.255 2013/03/28 16:45:16 tedu Exp $	*/
d385 1
a385 1
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
d620 1
a620 2
	for (ifg = TAILQ_FIRST(&ifp->if_groups); ifg;
	    ifg = TAILQ_FIRST(&ifp->if_groups))
d824 3
a826 2
	for (ifc = LIST_FIRST(&if_cloners); ifc != NULL && count != 0;
	    ifc = LIST_NEXT(ifc, ifc_list), count--, dst += IFNAMSIZ) {
d832 2
d1038 1
a1038 1
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list)) {
d1504 2
a1505 4
			for (ifa = TAILQ_FIRST(&ifp->if_addrlist); ifa != NULL;
			    ifa = nifa) {
				nifa = TAILQ_NEXT(ifa, ifa_list);

d1703 3
a1705 2
	for (ifp = TAILQ_FIRST(&ifnet); space >= sizeof(ifr) &&
	    ifp != NULL; ifp = TAILQ_NEXT(ifp, if_list)) {
d1715 1
a1715 4
			for (ifa = TAILQ_FIRST(&ifp->if_addrlist);
			    space >= sizeof (ifr) &&
			    ifa != NULL;
			    ifa = TAILQ_NEXT(ifa, ifa_list)) {
d1717 3
d2066 1
a2066 2
		for (ifgm = TAILQ_FIRST(&ifg->ifg_members); ifgm; ifgm = next) {
			next = TAILQ_NEXT(ifgm, ifgm_next);
a2067 1
		}
@


1.255
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.254 2013/03/28 12:06:55 mpi Exp $	*/
d78 1
@


1.254
log
@Replace some casts to struct in_ifaddr pointer by ifatoia() or NULL.

ok millert@@, haesbaert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.253 2013/03/26 13:19:25 mpi Exp $	*/
a75 1
#include <sys/proc.h>
@


1.253
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.252 2013/03/20 10:34:12 mpi Exp $	*/
d610 1
a610 2
			TAILQ_REMOVE(&in_ifaddr, (struct in_ifaddr *)ifa,
			    ia_list);
d1510 1
a1510 2
				TAILQ_REMOVE(&in_ifaddr,
				    (struct in_ifaddr *)ifa, ia_list);
@


1.252
log
@Introduce if_get() to retrieve an interface descriptor pointer given
an interface index and replace all the redondant checks and accesses
to a global array by a call to this function.

With imputs from and ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.251 2013/03/15 20:45:34 tedu Exp $	*/
a139 2
int	ifqmaxlen = IFQ_MAXLEN;

d281 1
a281 1
		IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.251
log
@change LIST_END to literal NULL for clarity.
ok claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.250 2013/03/07 09:40:19 mpi Exp $	*/
d193 2
a194 2
static int if_index = 0;
int if_indexlim = 0;
d935 1
a935 2
		if (sdl->sdl_index && sdl->sdl_index < if_indexlim &&
		    ifindex2ifnet[sdl->sdl_index])
d1166 1
a1166 2
 * Map interface name to
 * interface structure pointer.
d1178 14
@


1.250
log
@Remove unused ifa_ifwithaf() function.

ok mikeb@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.249 2013/03/07 09:03:16 mpi Exp $	*/
d1696 1
a1696 1
	    ifp != TAILQ_END(&ifnet); ifp = TAILQ_NEXT(ifp, if_list)) {
d1708 1
a1708 1
			    ifa != TAILQ_END(&ifp->if_addrlist);
@


1.249
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.248 2012/11/23 20:12:03 sthen Exp $	*/
a963 21
}

/*
 * Find an interface using a specific address family
 */
struct ifaddr *
ifa_ifwithaf(int af, u_int rdomain)
{
	struct ifnet *ifp;
	struct ifaddr *ifa;

	rdomain = rtable_l2(rdomain);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rdomain)
			continue;
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family == af)
				return (ifa);
		}
	}
	return (NULL);
@


1.248
log
@Add SIOCGIFHARDMTU to allow retrieving the driver's maximum supported MTU
looks fine reyk@@ ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.247 2012/10/23 17:41:00 claudio Exp $	*/
d620 1
a620 1
		IFAFREE(ifa);
d630 1
a630 1
	IFAFREE(ifnet_addrs[ifp->if_index]);
d1043 1
a1043 1
		IFAFREE(rt->rt_ifa);
d1526 1
a1526 1
				IFAFREE(ifa);
@


1.247
log
@Only clear the revarp_ifp if the ifp pointing to it is detached.
Since the ifp is not detached in the SIOCSIFRDOMAIN case remove the
clear there. With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.246 2012/10/18 00:36:21 deraadt Exp $	*/
d1269 4
@


1.246
log
@Move revarp code into #ifdef NFSCLIENT; saving space on some media.
Resurrect the rather silly "unplug my network device while I am
doing nfs diskless revarp" safety code which was disabled due to
a missing "ether.h" include, found by jsg
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.245 2012/10/05 17:17:04 camield Exp $	*/
d558 2
a559 1
	revarp_ifp = NULL;
a1500 3
#if NETHER > 0 && defined(NFSCLIENT) 
			revarp_ifp = NULL;
#endif
@


1.245
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.244 2012/09/19 16:14:01 blambert Exp $	*/
d70 1
d557 2
a558 2
#if NETHER > 0
	myip_ifp = NULL;
d1500 2
a1501 2
#if NETHER > 0
			myip_ifp = NULL;
@


1.244
log
@Make rt_lookup return a pointer to an rtentry struct instead of
to a radix_node struct.

The radix tree pushdown continues.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.243 2012/09/19 12:35:07 blambert Exp $	*/
d534 1
a534 1
	if (ifp->if_bridge)
d1097 1
a1097 1
	if (ifp->if_bridge)
d1133 1
a1133 1
	if (ifp->if_bridge)
@


1.243
log
@More radix internals pushdown; place rn_mpath_next, which accepts and
returns radix_node pointers, inside a new rt_mpath_next, which accepts
and returns rtentry pointers, and start using that instead.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.242 2012/09/18 08:16:33 blambert Exp $	*/
d2083 1
a2083 2
	rt = (struct rtentry *)rt_lookup(sintosa(&sa_in), sintosa(&sa_in), 0);
	if (rt) {
d2097 1
a2097 2
	rt = (struct rtentry *)rt_lookup(sin6tosa(&sa_in6), sin6tosa(&sa_in6), 0);
	if (rt) {
@


1.242
log
@Wrap rtable_add() and rtable_l2set() calls inside ifioctl() inside softnet,
as functions that modify routing information shouldn't be interruptable by
network traffic.

Also make sure that both of those functions assert that they are called
at softnet. I'm reasonably sure that there shouldn't be any, but if there
is any codepath that was missed, we're going to be here for another 4 days
to deal with any fallout.

While here, move the multitude of "int s" declarations inside ifioctl to
the beginning of the function.

okay claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.241 2012/01/03 23:41:51 bluhm Exp $	*/
a2067 1
	struct radix_node	*rn;
d2083 2
a2084 1
	if ((rn = rt_lookup(sintosa(&sa_in), sintosa(&sa_in), 0)) != NULL) {
a2085 1
			rt = (struct rtentry *)rn;
d2089 1
a2089 1
			rn = rn_mpath_next(rn, 0);
d2091 1
a2091 1
			rn = NULL;
d2093 1
a2093 1
		} while (rn != NULL);
d2098 2
a2099 1
	if ((rn = rt_lookup(sin6tosa(&sa_in6), sin6tosa(&sa_in6), 0)) != NULL) {
a2100 1
			rt = (struct rtentry *)rn;
d2104 1
a2104 1
			rn = rn_mpath_next(rn, 0);
d2106 1
a2106 1
			rn = NULL;
d2108 1
a2108 1
		} while (rn != NULL);
@


1.241
log
@To access the ifaddr of an in_ifaddr or in6_ifaddr struct, it is
cleaner to access the first member via ia_ifa instead of casting.
No binary change.
ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.240 2011/10/24 17:51:31 camield Exp $	*/
d1214 1
a1214 1
	int error = 0;
d1278 1
a1278 1
			int s = splnet();
d1283 1
a1283 1
			int s = splnet();
d1300 1
a1300 1
			int s = splnet();
d1309 1
a1309 1
				int s = splnet();
d1319 1
a1319 1
			int s = splnet();
d1327 1
a1327 1
			int s = splnet();
d1339 1
a1339 1
				int s = splnet();
d1348 1
a1348 1
				int s = splnet();
d1480 5
a1484 1
			if ((error = rtable_add(ifr->ifr_rdomainid)) != 0)
a1485 1
			rtable_l2set(ifr->ifr_rdomainid, ifr->ifr_rdomainid);
d1495 1
a1495 1
			int s = splnet();
d1663 1
a1663 1
			int s = splnet();
@


1.240
log
@Don't detach interface from group in if_clone_destroy(),
if_detach() handles this ok.  carpdetach() can now lower the demote
count on the carp group correctly.

ok henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.239 2011/07/09 00:47:18 henning Exp $	*/
d2322 1
a2322 1
		ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp, 0);
d2327 1
a2327 2
				ifa = (struct ifaddr *)
				    in6ifa_ifpforlinklocal(ifp, 0);
@


1.239
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.238 2011/07/08 18:48:51 henning Exp $	*/
d715 1
a715 1
	int s, ret;
d734 1
a734 6
	if_delgroup(ifp, ifc->ifc_name);

	if ((ret = (*ifc->ifc_destroy)(ifp)) != 0)
		if_addgroup(ifp, ifc->ifc_name);

	return (ret);
@


1.238
log
@new priority queueing implementation, extremely low overhead, thus fast.
unconditional, always on. 8 priority levels, as every better switch, the
vlan header etc etc. ok ryan mpf sthen, pea tested as well
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.237 2011/07/06 02:42:28 henning Exp $	*/
a586 4
#endif
#ifdef NETATALK
	IF_DETACH_QUEUES(atintrq1);
	IF_DETACH_QUEUES(atintrq2);
@


1.237
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.236 2011/07/05 00:58:27 henning Exp $	*/
d655 2
a656 1
	struct mbuf *m, *prev, *next;
d658 3
a660 3
	prev = NULL;
	for (m = q->ifq_head; m; m = next) {
		next = m->m_nextpkt;
d662 4
a665 4
		if ((m->m_flags & M_PKTHDR) == 0) {
			prev = m;
			continue;
		}
d667 16
a682 3
		if (m->m_pkthdr.rcvif != ifp) {
			prev = m;
			continue;
a683 12

		if (prev)
			prev->m_nextpkt = m->m_nextpkt;
		else
			q->ifq_head = m->m_nextpkt;
		if (q->ifq_tail == m)
			q->ifq_tail = prev;
		q->ifq_len--;

		m->m_nextpkt = NULL;
		m_freem(m);
		IF_DROP(q);
@


1.236
log
@now of course I only noticed if_qflush is completely unused after
adjusting it to the new world order in my tree... remove it, ok ryan claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.235 2011/07/04 22:53:53 tedu Exp $	*/
d282 1
a282 1
		ifp->if_snd.ifq_maxlen = ifqmaxlen;
@


1.235
log
@remove compat_svr4 support.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.234 2011/03/13 15:31:41 stsp Exp $	*/
a1167 18
}

/*
 * Flush an interface queue.
 */
void
if_qflush(struct ifqueue *ifq)
{
	struct mbuf *m, *n;

	n = ifq->ifq_head;
	while ((m = n) != NULL) {
		n = m->m_act;
		m_freem(m);
	}
	ifq->ifq_head = 0;
	ifq->ifq_tail = 0;
	ifq->ifq_len = 0;
@


1.234
log
@Add a way to enable/disable Wake On LAN with ifconfig.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.233 2011/01/25 05:44:05 tedu Exp $	*/
d1622 1
a1622 1
#if !defined(COMPAT_43) && !defined(COMPAT_LINUX) && !defined(COMPAT_SVR4)
d1721 1
a1721 1
#if defined(COMPAT_43) || defined(COMPAT_LINUX) || defined(COMPAT_SVR4)
d1751 1
a1751 1
#if defined(COMPAT_43) || defined(COMPAT_LINUX) || defined(COMPAT_SVR4)
@


1.233
log
@pool is properly spelled pl.  makes this one fit in netstat column.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.232 2011/01/18 19:10:25 bluhm Exp $	*/
d1360 25
@


1.232
log
@When changing the ifa_broadaddr broadcast address, ifa_update_broadaddr()
copied the pointer to the sockaddr instead of the content of
sockaddr_in.  As the source of the data resides on the stack, the
pointer got invalid later and the kernel crashed.  As only addresses
with fixed size are used, sa_len bytes of the sockaddr can be
coppied.
ok krw@@ markus@@ mpf@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.231 2010/11/29 19:38:59 miod Exp $	*/
d185 1
a185 1
	    "ifaddritempool", NULL);
@


1.231
log
@Let ifa_print_rb() build on INET6-free kernels. Repairs RAMDISK on a few
platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.230 2010/11/17 19:43:23 henning Exp $	*/
d2198 3
a2200 1
	ifa->ifa_broadaddr = sa;
@


1.230
log
@make ifa_ifwithaddr use the RB tree for lookups instead of nested list
walking. make the function shorter, easier and faster with many addresses
while still being at least as fast as the old one with a common "on real IP"
setup. tested by many, ok claudio sthen dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.229 2010/11/17 19:40:55 henning Exp $	*/
d2272 1
d2277 1
@


1.229
log
@add ifa_print_rb(), dumps the RB tree to the console, can be called from
ddb>, ok claudio dlg krw sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.228 2010/11/17 19:34:49 henning Exp $	*/
d882 11
a892 2
	struct ifnet *ifp;
	struct ifaddr *ifa;
a896 19

	rdomain = rtable_l2(rdomain);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
	    if (ifp->if_rdomain != rdomain)
		continue;
	    TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != addr->sa_family)
			continue;
		if (equal(addr, ifa->ifa_addr))
			return (ifa);
		if ((ifp->if_flags & IFF_BROADCAST) && ifa->ifa_broadaddr &&
		    /* IP6 doesn't have broadcast */
		    ifa->ifa_broadaddr->sa_len != 0 &&
		    equal(ifa->ifa_broadaddr, addr))
			return (ifa);
	    }
	}
	return (NULL);
}
@


1.228
log
@maintain an RB tree of ifaddrs in the system (addresses and broadcast addrs,
the latter is also the dest addr on P2P interfaces) for faster lookups in
the future. walking the linked list of all interfaces in the system to walk
the linked list of addresses on each of them isn't particularily fast,
especially with many interfaces and addresses.
written at n2k10 in australia in january, but had to be backed
out. the offenders have been fixed:
-ipvshit rtsol code calling these functions in interrupt context
(surprised this hasn't caused more havoc)
-various places in the stack added empty ifaddr structs, filling them in later
-sloppy recycling of ifaddrs in some places
finished at j2k10 in japan in september
tested by many, ok sthen krw dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.227 2010/11/17 18:51:57 henning Exp $	*/
d160 3
d2268 28
@


1.227
log
@introduce ifa_update_broadaddr to update an ifaddr's broadcast address,
trivial for the moment, more needed soon
tested by many as part of a larger diff, ok sthen claudio dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.226 2010/10/25 11:33:06 blambert Exp $	*/
d2187 3
d2196 3
d2204 1
d2206 1
@


1.226
log
@move to static initializers for the ifnet/ifg_head TAILQ's
fixes a race-based kernel crash under rare circumstances

reported and fix tested by chefren att pi daht net

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.225 2010/08/27 17:08:01 jsg Exp $	*/
d2193 6
@


1.225
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.224 2010/08/25 14:07:24 claudio Exp $	*/
d164 1
a164 1
TAILQ_HEAD(, ifg_group) ifg_head;
d193 1
a193 1
struct ifnet_head ifnet;
a445 4
	if (if_index == 0) {
		TAILQ_INIT(&ifnet);
		TAILQ_INIT(&ifg_head);
	}
@


1.224
log
@Let rtable_add() return usefull errnos so that the ioctl handler and the
rtsock code can return a more reasonable error to the user.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.223 2010/08/25 13:57:07 claudio Exp $	*/
a143 1
int	if_detached_init(struct ifnet *);
a522 1
	ifp->if_init = if_detached_init;
a1797 6
}

int
if_detached_init(struct ifnet *ifp)
{
	return (ENXIO);
@


1.223
log
@Move the iface specific ioctl call for SIOCSIFRDOMAIN further down so that
all the magic cleanup happens before. This is needed because mpe(4) needs
to add a route which would be removed by the cleanup code.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.222 2010/08/25 13:06:09 claudio Exp $	*/
d1491 11
d1539 1
a1539 1
		/* Let devices like enc(4) enforce the rdomain */
d1545 1
a1545 1
		rtable_addif(ifp, ifr->ifr_rdomainid);
@


1.222
log
@When setting a rdomain also force -inet6 aka IFXF_NOINET6 on the interface
since IPv6 is not rdomain aware and freaks out about it.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.221 2010/08/24 16:13:32 claudio Exp $	*/
a1490 5
		/* Let devices like enc(4) enforce the rdomain */
		if ((error = (*ifp->if_ioctl)(ifp, cmd, data)) != ENOTTY)
			return (error);
		error = 0;

d1527 5
@


1.221
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.220 2010/08/24 16:00:16 claudio Exp $	*/
d1512 1
@


1.220
log
@Add a splnet() around a block that needs it for sure. Maybe more in
SIOCSIFRDOMAIN should be protected but this is by far the biggest
offender. The same codepath in if_detach() runs at splnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.219 2010/07/31 20:48:32 blambert Exp $	*/
d1326 1
a1326 1
			(ifr->ifr_flags &~ IFF_CANTCHANGE);
d1375 1
a1375 1
			(ifr->ifr_flags &~ IFXF_CANTCHANGE);
@


1.219
log
@another pair of files which relied on mbuf.h for pool.h; should be the last,
as the kernel now compiles w/o ``#include <sys/pool.h>'' in mbuf.h; removing
that line, though, is for another day, as a userland program (systat, IIRC)
fails to build without it there.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.218 2010/07/03 04:44:51 guenther Exp $	*/
d1499 1
d1529 1
@


1.218
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.217 2010/06/29 21:28:37 reyk Exp $	*/
d74 1
@


1.217
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.215 2010/05/08 11:07:20 stsp Exp $	*/
d1412 1
a1412 1
	case SIOCSLIFPHYRTABLEID:
d1422 1
a1422 1
	case SIOCGLIFPHYRTABLEID:
d1479 1
a1479 1
	case SIOCGIFRTABLEID:
d1483 1
a1483 1
	case SIOCSIFRTABLEID:
@


1.216
log
@Rework the way we handle MPLS in the kernel. Instead of fumbling MPLS into
ether_output() and later on other L2 output functions use a trick and over-
load the ifp->if_output() function pointer on MPLS enabled interfaces to
go through mpls_output() which will then call the link level output function.
By setting IFXF_MPLS on an interface the output pointers are switched.
This now allows to cleanup the MPLS input and output pathes and fix mpe(4)
so that the MPLS code now actually works for both P and PE systems.
Tested by myself and michele
(A custom kernel with MPLS and mpe enabled is still needed).
@
text
@d1489 6
d1529 2
a1530 11
		/* make sure that the routing table exists */
		if (!rtable_exists(ifr->ifr_rdomainid)) {
			if (rtable_add(ifr->ifr_rdomainid) == -1)
				panic("rtinit: rtable_add");
		}
		if (ifr->ifr_rdomainid != rtable_l2(ifr->ifr_rdomainid)) {
			/* XXX we should probably flush the table */
			rtable_l2set(ifr->ifr_rdomainid, ifr->ifr_rdomainid);
		}

		ifp->if_rdomain = ifr->ifr_rdomainid;
@


1.215
log
@While handling SIOCSIFLLADDR, after adjusting the MAC of the interface,
call the interface-specific ioctl handler as well in case the driver
needs to do something special. E.g. if_trunk expects this in order to
update MAC addresses of its trunk ports.

If you now see "Inappropriate ioctl for device" errors after running
"ifconfig $if lladdr random" please let me know. Most likely the ioctl
handler of the driver needs fixing.

ok claudio@@, "I only count half an ok for networking" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.214 2010/04/25 17:38:53 mpf Exp $	*/
d110 4
d1352 20
@


1.214
log
@Properly adjust group demotion counters when groups are added or
removed.  Extend carp demote logging to also show the reason for
the demote.  Return EINVAL instead of ERANGE if a carpdemote request
is out range.  Requested from otto.
OK mcbride, henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.213 2010/04/17 18:31:41 stsp Exp $	*/
d1560 3
@


1.213
log
@When the MAC address changes, change the IPv6 link local address
accordingly if one is configured and we're not a router.
Else IPv6 will leak the old MAC address after "ifconfig $if lladdr random".
Based on an initial diff and idea from Theo.

OK deraadt, "makes sense" and help by naddy, silent agreement by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.212 2010/04/17 17:46:32 deraadt Exp $	*/
a1514 1
		(*ifp->if_ioctl)(ifp, cmd, data); /* XXX error check */
d1518 1
d2003 1
a2003 1
		return (ERANGE);
@


1.212
log
@split SIOCSIFLLADDR code out into an ifnewlladr() function
ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.211 2010/03/08 21:00:27 henning Exp $	*/
d2252 17
@


1.211
log
@argh, in del too, simultaneously spotted by kettenis and me
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.210 2010/03/08 20:52:52 henning Exp $	*/
d106 2
d1564 2
a1565 16
		if (ifp->if_flags & IFF_UP) {
			struct ifreq ifrq;
			int s = splnet();
			ifp->if_flags &= ~IFF_UP;
			ifrq.ifr_flags = ifp->if_flags;
			(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifrq);
			ifp->if_flags |= IFF_UP;
			ifrq.ifr_flags = ifp->if_flags;
			(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifrq);
			splx(s);
			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
				if (ifa->ifa_addr != NULL &&
				    ifa->ifa_addr->sa_family == AF_INET)
					arp_ifinit((struct arpcom *)ifp, ifa);
			}
		}
d2223 36
@


1.210
log
@aye, broadcast addr too. spotted by kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.209 2010/03/08 20:29:41 henning Exp $	*/
a2177 2
	if (ifp->if_flags & IFF_BROADCAST && ifa->ifa_broadaddr)
		ifa_item_remove(ifa->ifa_broadaddr, ifa, ifp);
@


1.209
log
@don't call ifa_item_add/del in ifa_add/del, so the ifa RB tree doesn't
get used at all. turns out this needs more work - after release.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.208 2010/03/05 13:52:23 henning Exp $	*/
a2171 2
	if (ifp->if_flags & IFF_BROADCAST && ifa->ifa_broadaddr)
		ifa_item_insert(ifa->ifa_broadaddr, ifa, ifp);
@


1.208
log
@in ifa_ifwithaddr, do not use the shiny new RB tree, there is a
balancing issue from wrong order of operations (change after insert is
illegal with RB). and apparently there are cases left. to be revisited
after release
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.206 2010/01/13 02:26:49 henning Exp $	*/
a2171 1
	ifa_item_insert(ifa->ifa_addr, ifa, ifp);
a2179 1
	ifa_item_remove(ifa->ifa_addr, ifa, ifp);
@


1.207
log
@make ifa_ifwithaddr use the shiny new ifaddr RB tree instead of traversing
the list of all interfaces and traversing the list of all addresses on each
interface.
if bugs show up with addressing this is the #1 backout candidate, something
i missed might fuck with ifaddrs behind our back, although i looked &
tested hard. 10x to naddy for inet6 testing.
ok theo ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.205 2010/01/13 02:13:12 henning Exp $	*/
d878 2
a879 11
	struct ifaddr_item *ifai, key;

	bzero(&key, sizeof(key));
	key.ifai_addr = addr;
	key.ifai_rdomain = rtable_l2(rdomain);

	ifai = RB_FIND(ifaddr_items, &ifaddr_items, &key);
	if (ifai)
		return (ifai->ifai_ifa);
	return (NULL);
}
d884 19
@


1.206
log
@maintain a global RB tree of all local addresses in the system. this
includes AF_LINK addresses (aka mac addresses in the ethernet case). for
inet this also includes the broadcast addresses.
depends on ifinit() called earlier so we have a chance to pool_init before
autoconf assigns the AF_LINK addresses, the v6 fix, and the ifa_add/del
abstraction i just committed.
this is a change in semantics, it is now illegal to change the actual
address in an ifaddr struct because then the RB tree becomes unbalanced.
nothing using this tree yet.
ok theo ryan dlg
@
text
@d878 11
a888 2
	struct ifnet *ifp;
	struct ifaddr *ifa;
a892 19

	rdomain = rtable_l2(rdomain);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
	    if (ifp->if_rdomain != rdomain)
		continue;
	    TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != addr->sa_family)
			continue;
		if (equal(addr, ifa->ifa_addr))
			return (ifa);
		if ((ifp->if_flags & IFF_BROADCAST) && ifa->ifa_broadaddr &&
		    /* IP6 doesn't have broadcast */
		    ifa->ifa_broadaddr->sa_len != 0 &&
		    equal(ifa->ifa_broadaddr, addr))
			return (ifa);
	    }
	}
	return (NULL);
}
@


1.205
log
@instead of fiddling with the per-interface address lists directly in
many places create a proper API (ifa_add / ifa_del) and use it.
ok theo ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.204 2010/01/12 04:05:47 deraadt Exp $	*/
d151 7
d162 2
d175 3
d903 1
d2172 3
d2181 35
d2218 24
@


1.204
log
@Move initialization of the MCLGETI ticker to mbinit(), instead of ifinit()
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.203 2010/01/08 19:21:19 stsp Exp $	*/
a321 1
	TAILQ_INSERT_HEAD(&ifp->if_addrlist, ifa, ifa_list);
d329 1
d350 1
a350 1
	TAILQ_REMOVE(&ifp->if_addrlist, ifa, ifa_list);
d595 1
a595 1
		TAILQ_REMOVE(&ifp->if_addrlist, ifa, ifa_list);
d1477 1
a1477 1
				TAILQ_REMOVE(&ifp->if_addrlist, ifa, ifa_list);
d2151 16
@


1.203
log
@During "ifconfig $if -inet6" remove v6 addresses even if the
interface is marked down, and wrap interface detach/attach in splnet().

ok henning@@ todd@@, "I like the idea" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.202 2009/12/13 09:41:04 jsing Exp $	*/
a154 18
struct timeout m_cltick_tmo;
int m_clticks;

/*
 * Record when the last timeout has been run.  If the delta is
 * too high, m_cldrop() will notice and decrease the interface
 * high water marks.
 */
static void
m_cltick(void *arg)
{
	extern int ticks;
	extern void m_cltick(void *);

	m_clticks = ticks;
	timeout_add(&m_cltick_tmo, 1);
}

a168 3

	timeout_set(&m_cltick_tmo, m_cltick, NULL);
	m_cltick(NULL);
@


1.202
log
@Ensure that if_start() is called at IPL_NET.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.200 2009/11/03 10:59:04 claudio Exp $	*/
d1337 3
a1339 3
		/* when IFXF_NOINET6 gets changed, detach/attach */
		if (ifp->if_flags & IFF_UP && ifr->ifr_flags & IFXF_NOINET6 &&
		    !(ifp->if_xflags & IFXF_NOINET6))
d1341 3
a1343 1
		if (ifp->if_flags & IFF_UP && ifp->if_xflags & IFXF_NOINET6 &&
d1346 6
a1351 1
			in6_if_up(ifp);
@


1.201
log
@Add a way to bind the tunnel endpoint of a gif/gre interface into a
different rdomain than the default one. This allows to do MPLS VPNs
without the MPLS madness.  OK deraadt@@, henning@@
@
text
@d474 3
@


1.200
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.199 2009/08/12 15:58:20 henning Exp $	*/
d1384 1
d1394 1
@


1.199
log
@dlg deferred calling interfaces' if_start routine so we call them less,
which does pay out, performance wise. one of the conditions to call the
interfaces' if_start routine immediately was "send queue is full".
on a very busy (hammered) machine this will itroduce too much latency
since we spend almost all cpu time in interrupt handlers and softnet,
so the softint actually doing the if_start gets called to seldom and
the queue full check is what triggers the actual transmit.
change the logic to call if's if_start routing immediately when there are
at least 8 packets (or in case if maxlen being smaller than 8, maxlen)
8 chose because it shows best performance in my test setup here.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.198 2009/08/10 11:22:10 deraadt Exp $	*/
d890 2
d919 1
d948 1
d991 1
d1497 4
@


1.198
log
@At sys_reboot time, bring all the interfaces down so that their xxstop
functions are called, which will turn off DMA.  Receiving packets into
your memory after a system reboot is pretty nasty.  This will also mean
that the shutdown hooks can go; this solution is smaller.
ok henning miod dlg kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.197 2009/07/09 06:40:20 blambert Exp $	*/
d474 2
a475 1
	if (IF_QFULL(&ifp->if_snd) && !ISSET(ifp->if_flags, IFF_OACTIVE)) {
@


1.197
log
@unsigned -> unsigned int

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.196 2009/06/06 12:31:17 rainer Exp $	*/
d1058 26
@


1.196
log
@when xflags got changed, tell the userland by routing sockets

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.195 2009/06/05 03:10:28 halex Exp $	*/
d310 1
a310 1
	unsigned socksize, ifasize;
@


1.195
log
@Add missing #ifdef INET6 ... #endif

Makes non-IPv6 kernels build again

blame and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.194 2009/06/05 00:05:21 claudio Exp $	*/
d1315 1
@


1.194
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.193 2009/06/04 19:07:21 henning Exp $	*/
d1301 1
d1311 1
@


1.193
log
@allow IPvShit to be turned off completely per-interface.
ifconfig em0 -inet6
deletes all v6 addresses including link-local and prevents new ones from
being added.
ifconfig em0 inet6 <addr>
re-enables v6, brings the link local back and adds optional <addr>
ok theo reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.192 2009/06/01 17:49:11 claudio Exp $	*/
d881 1
a881 1
ifa_ifwithaddr(struct sockaddr *addr)
d890 2
d911 1
a911 1
ifa_ifwithdstaddr(struct sockaddr *addr)
d917 10
a926 8
	    if (ifp->if_flags & IFF_POINTOPOINT)
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != addr->sa_family ||
			    ifa->ifa_dstaddr == NULL)
				continue;
			if (equal(addr, ifa->ifa_dstaddr))
				return (ifa);
		}
d936 1
a936 1
ifa_ifwithnet(struct sockaddr *addr)
d951 2
d981 1
a981 1
ifa_ifwithaf(int af)
d987 2
d1213 1
a1213 1
	struct ifaddr *ifa;
d1412 53
@


1.192
log
@There is no need to use a variable just for sizeof(). Garbage collect ifa.
No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.191 2009/05/31 20:22:18 blambert Exp $	*/
d1116 2
a1117 1
	in6_if_up(ifp);
d1253 4
d1289 18
d1540 2
a1541 1
		if ((ifp->if_flags & IFF_UP) != 0) {
@


1.191
log
@Consolidate common code for interface attachment into single function
to save some space in the kernel. Although there are deeper issues with
interface attachment, this diff was not meant to address those, just to
shave some space ;)

ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.190 2009/05/31 04:07:03 claudio Exp $	*/
a206 1
	struct ifaddr *ifa;
d255 2
a256 2
		m = oldlim * sizeof(ifa);
		n = if_indexlim * sizeof(ifa);
@


1.190
log
@Reenable interface state tracking now that I found and fixed the cause of
the rtfree panic seen by some people.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.189 2009/03/15 19:40:41 miod Exp $	*/
d130 1
d414 1
a414 20
	if (if_index == 0) {
		TAILQ_INIT(&ifnet);
		TAILQ_INIT(&ifg_head);
	}
	TAILQ_INIT(&ifp->if_addrlist);
	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks),
	    M_TEMP, M_NOWAIT);
	if (ifp->if_addrhooks == NULL)
		panic("if_attachhead: malloc");
	TAILQ_INIT(ifp->if_addrhooks);
	ifp->if_linkstatehooks = malloc(sizeof(*ifp->if_linkstatehooks),
	    M_TEMP, M_NOWAIT);
	if (ifp->if_linkstatehooks == NULL)
		panic("if_attachhead: malloc");
	TAILQ_INIT(ifp->if_linkstatehooks);
	ifp->if_detachhooks = malloc(sizeof(*ifp->if_detachhooks),
	    M_TEMP, M_NOWAIT);
	if (ifp->if_detachhooks == NULL)
		panic("if_attachhead: malloc");
	TAILQ_INIT(ifp->if_detachhooks);
d426 24
d458 1
a458 1
		panic("if_attach: malloc");
d463 1
a463 1
		panic("if_attach: malloc");
d468 1
a468 1
		panic("if_attach: malloc");
a469 17

#if NCARP > 0
	if (ifp->if_type != IFT_CARP)
		TAILQ_FOREACH(before, &ifnet, if_list)
			if (before->if_type == IFT_CARP)
				break;
	if (before == NULL)
		TAILQ_INSERT_TAIL(&ifnet, ifp, if_list);
	else
		TAILQ_INSERT_BEFORE(before, ifp, if_list);
#else
	TAILQ_INSERT_TAIL(&ifnet, ifp, if_list);
#endif

	m_clinitifp(ifp);

	if_attachsetup(ifp);
@


1.189
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.188 2009/02/24 21:14:12 claudio Exp $	*/
a1090 1
#if 0
a1093 1
#endif
a1130 1
#if 0
a1133 1
#endif
a1145 1
#if 0
a1147 1
#endif
@


1.188
log
@Disable rt_if_track() for now. This causes the rtfree panic seen in PR6043
and I'm currently unable to find the cause of this. Time is running out so
workaround it for now.  OK deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.187 2009/01/31 21:23:34 grange Exp $	*/
d1074 1
a1074 1
	splassert(IPL_SOFTNET);
d1110 1
a1110 1
	splassert(IPL_SOFTNET);
@


1.187
log
@No need to invent another _offset, just use the one from param.h.
As a bonus it eliminates casting from pointer to int.

ok miod@@ tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.186 2009/01/09 04:41:02 david Exp $	*/
d1091 1
d1095 1
d1133 1
d1137 1
d1150 1
d1153 1
@


1.186
log
@fix egress group matching for IPv6; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.185 2008/12/12 22:07:33 claudio Exp $	*/
d324 1
a324 2
#define _offsetof(t, m) ((int)((caddr_t)&((t *)0)->m))
	masklen = _offsetof(struct sockaddr_dl, sdl_data[0]) + namelen;
@


1.185
log
@Introduce a if_priority that will be added to RTP_STATIC when routes are
added without an expilict priority. This allows to specify less prefered
interfaces that will only take over if the primary interface loses link.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.184 2008/12/11 16:45:45 deraadt Exp $	*/
d1924 1
a1924 1
		    &in6addr_any) && mask &&
d1926 1
a1926 1
		    &in6addr_any))
@


1.184
log
@export per-interface mbuf cluster pool use statistics out to userland
inside if_data, so that netstat(1) and systat(1) can see them
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.183 2008/11/26 19:07:33 deraadt Exp $	*/
d1382 12
@


1.183
log
@Avoid network livelock.

Use a 1 tick timeout() to determine if the kernel even manages to get
below softclock (from an old diff by mpf).  If our timeout comes late,
reduce the high water marks (to half) for all network interfaces, thus
starving them of future packet allocations for their RX rings.  For a
few ticks longer, also block the high water marks from rising even if
RX ring empty conditions would prod us to do so.

Cards may start dropping some packets off the end of their smaller RX
rings, but we were not able to do the work required in any case.  With
less interrupt time and mbuf movement, the system finds time to make
progress at the network queues.  Userland even gets to run.

A x40 tuned to 600MHz shows no real reduction in performance.  But a
soekris has a working console now.

ok dlg claudio, and art liked it too
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.182 2008/11/26 17:36:23 dlg Exp $	*/
a149 2
void	m_clinitifp(struct ifnet *);

d154 1
a155 1
struct timeout m_cltick_tmo;
d166 1
a2035 93
}

void
m_clinitifp(struct ifnet *ifp)
{
	extern u_int mclsizes[];
	int i;

	/* Initialize high water marks for use of cluster pools */
	for (i = 0; i < MCLPOOLS; i++) {
		ifp->if_mclstat.mclpool[i].mcl_hwm = MAX(4,
		    ifp->if_mclstat.mclpool[i].mcl_lwm);
		ifp->if_mclstat.mclpool[i].mcl_size = mclsizes[i];
	}
}

void
m_clsetlwm(struct ifnet *ifp, u_int pktlen, u_int lwm)
{
	extern u_int mclsizes[];
	int i;

	for (i = 0; i < MCLPOOLS; i++) {
                if (pktlen <= mclsizes[i])
			break;
        }
	if (i >= MCLPOOLS)
		return;

	ifp->if_mclstat.mclpool[i].mcl_lwm = lwm;
}

int
m_cldrop(struct ifnet *ifp, int pi)
{
	static int livelock, liveticks;
	struct mclstat *mcls;
	extern int ticks;
	int i;

	if (livelock == 0 && ticks - m_clticks > 2) {
		struct ifnet *aifp;

		/*
		 * Timeout did not run, so we are in some kind of livelock.
		 * Decrease the cluster allocation high water marks on all
		 * interfaces and prevent them from growth for the very near
		 * future.
		 */
		livelock = 1;
		liveticks = ticks;
		TAILQ_FOREACH(aifp, &ifnet, if_list) {
			mcls = &aifp->if_mclstat;
			for (i = 0; i < nitems(mcls->mclpool); i++)
				mcls->mclpool[i].mcl_hwm =
				    max(mcls->mclpool[i].mcl_hwm / 2,
				    mcls->mclpool[i].mcl_lwm);
		}
	} else if (livelock && ticks - liveticks > 5)
		livelock = 0;	/* Let the high water marks grow again */

	mcls = &ifp->if_mclstat;
	if (mcls->mclpool[pi].mcl_alive <= 2 &&
	    mcls->mclpool[pi].mcl_hwm < 32768 &&
	    ISSET(ifp->if_flags, IFF_RUNNING) && livelock == 0) {
		/* About to run out, so increase the watermark */
		mcls->mclpool[pi].mcl_hwm++;
	} else if (mcls->mclpool[pi].mcl_alive >= mcls->mclpool[pi].mcl_hwm)
		return (1);		/* No more packets given */

	return (0);
}

void
m_clcount(struct ifnet *ifp, int pi)
{
	ifp->if_mclstat.mclpool[pi].mcl_alive++;
}

void
m_cluncount(struct mbuf *m, int all)
{
	struct mbuf_ext *me;

	do {
		me = &m->m_ext;
		if (((m->m_flags & (M_EXT|M_CLUSTER)) != (M_EXT|M_CLUSTER)) ||
		    (me->ext_ifp == NULL))
			continue;

		me->ext_ifp->if_mclstat.mclpool[me->ext_backend].mcl_alive--;
		me->ext_ifp = NULL;
	} while (all && (m = m->m_next));
@


1.182
log
@provide m_clsetlwm, an interface for an interface to raise its low
watermark for mbuf cluster allocations.

this is necessary for things like bge which cannot cope with less than a
certain number of pkts on the ring.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.181 2008/11/25 16:32:41 dlg Exp $	*/
d156 17
d187 3
d2072 25
a2096 1
	struct mclstat *mcls = &ifp->if_mclstat;
d2098 1
d2101 1
a2101 1
	    ISSET(ifp->if_flags, IFF_RUNNING)) {
@


1.181
log
@expect if_flags to have IFF_RUNNING rather than IFF_UP before modifying
the per ifp cluster allocator. should prevent the hwm being raised
innapropriately when a driver fills its rx ring for the first time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.180 2008/11/25 15:43:32 dlg Exp $	*/
d2027 2
a2028 1
		ifp->if_mclstat.mclpool[i].mcl_hwm = 4;
d2031 16
@


1.180
log
@art says he doesnt suck anymore, so enable the really big cluster
allocators again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.179 2008/11/25 12:47:00 deraadt Exp $	*/
d2039 1
a2039 1
	    ISSET(ifp->if_flags, IFF_UP)) {
@


1.179
log
@Factor increases are not needed, +1 appears to work as well.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.178 2008/11/25 12:07:55 claudio Exp $	*/
d2022 1
a2022 1
	extern u_short mclsizes[];
@


1.178
log
@m_cluncount() needs to walk the mbuf chain to correctly uncount all clusters
but don't do that in m_free() as that will cause a double loop behaviour when
called via m_freem().
OK dlg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.177 2008/11/24 12:57:37 dlg Exp $	*/
d2022 1
a2022 1
	extern struct mclsizes mclsizes[];
d2026 4
a2029 2
	for (i = 0; i < MCLPOOLS; i++)
		ifp->if_mclstat.mclpool[i].mcl_hwm = mclsizes[i].hwm;
a2035 1
	extern struct mclsizes mclsizes[];
d2037 3
a2039 1
	if (mcls->mclpool[pi].mcl_alive <= 2 && ISSET(ifp->if_flags, IFF_UP)) {
d2041 1
a2041 2
		mcls->mclpool[pi].mcl_hwm +=
		    mcls->mclpool[pi].mcl_hwm / mclsizes[pi].factor;
@


1.177
log
@add several backend pools to allocate mbufs clusters of various sizes out
of. currently limited to MCLBYTES (2048 bytes) and 4096 bytes until pools
can allocate objects of sizes greater than PAGESIZE.

this allows drivers to ask for "jumbo" packets to fill rx rings with.

the second half of this change is per interface mbuf cluster allocator
statistics. drivers can use the new interface (MCLGETI), which will use
these stats to selectively fail allocations based on demand for mbufs. if
the driver isnt rapidly consuming rx mbufs, we dont allow it to allocate
many to put on its rx ring.

drivers require modifications to take advantage of both the new allocation
semantic and large clusters.

this was written and developed with deraadt@@ over the last two days
ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.176 2008/11/24 12:53:53 claudio Exp $	*/
d2053 1
a2053 1
m_cluncount(struct mbuf *m)
d2055 1
a2055 1
	struct mbuf_ext *me = &m->m_ext;
d2057 5
a2061 3
	if (((m->m_flags & (M_EXT|M_CLUSTER)) != (M_EXT|M_CLUSTER)) ||
	    (me->ext_ifp == NULL))
		return;
d2063 3
a2065 2
	me->ext_ifp->if_mclstat.mclpool[me->ext_backend].mcl_alive--;
	me->ext_ifp = NULL;
@


1.176
log
@Implement link-state tracking on the routing table. Routes to interfaces
which are considered down will no be marked ~RTF_UP and so multipath routing
will start to work as expected and not pump 50% of the traffic to nirvana.
Most of the magic happens in rn_mpath_reprio() which fiddles with the
routing table internals. The rest is more straight forward.
get it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.175 2008/11/21 18:01:30 claudio Exp $	*/
d150 2
d460 2
d1112 1
d1116 2
d2017 46
@


1.175
log
@Change rn_mpath_next() to be able to walk over the full multipath list
not only over routes of the same prio. This makes it possible to modify
rt_mpath_matchgate() so that if only gateway is specified without a specific
priority it will scan the full list and not only the first routes.
This is also needed for upcoming link state tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.174 2008/11/10 18:08:42 claudio Exp $	*/
d1069 3
d1108 3
d1121 3
@


1.174
log
@Clear ifindex2ifnet[] in if_detach() this is needed because link local
addressing in IPv6 likes to do ifp = ifindex2ifnet[ifindex] without properly
checking if the ifindex is valid. As a side-effect this solves parts of
PR 5981. Debugged by jsing@@. OK jsing@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.173 2008/06/12 16:15:05 claudio Exp $	*/
d1917 1
a1917 1
			rn = rn_mpath_next(rn);
d1932 1
a1932 1
			rn = rn_mpath_next(rn);
@


1.173
log
@Fix the egress group matching for IPv4. There are to ways to define a /0
network mask. For some reasons some parts set sa->sa_len to 0 to specify
a /0 netmask so check fot that too. tested by david@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.172 2008/06/08 20:27:23 claudio Exp $	*/
d639 1
@


1.173.2.1
log
@Clear ifindex2ifnet[] in if_detach() this is needed because link local
addressing in IPv6 likes to do ifp = ifindex2ifnet[ifindex] without properly
checking if the ifindex is valid. As a side-effect this solves parts of
PR 5981.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.173 2008/06/12 16:15:05 claudio Exp $	*/
a638 1
	ifindex2ifnet[ifp->if_index] = NULL;
@


1.172
log
@The default route is 0.0.0.0/0 so it is necessary to check the mask as well.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.171 2008/05/23 15:51:12 thib Exp $	*/
d1869 2
a1870 1
		    satosin(mask)->sin_addr.s_addr == INADDR_ANY)
d1876 2
a1877 2
		    &in6addr_any) &&
		    mask && IN6_ARE_ADDR_EQUAL(&(satosin6(mask))->sin6_addr,
@


1.171
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.170 2008/05/07 05:51:12 mpf Exp $	*/
d1868 2
a1869 1
		if (satosin(dst)->sin_addr.s_addr == INADDR_ANY)
@


1.170
log
@Prevent virtual interfaces from adding to the random pool.
Also move the sampling into ether_input() where it can happen
at the interrupt and not within splnet() processing, which might
be less random. Discussed with mickey.
OK markus@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.169 2008/04/10 23:15:45 dlg Exp $	*/
d1424 1
a1424 1
			(struct mbuf *) ifp));
d1464 1
a1464 1
		    (struct mbuf *) ifp));
@


1.169
log
@introduce mitigation for the calling of an interfaces start routine.

decent drivers prefer to have a lot of packets on the send queue so they
can queue a lot of them up on the tx ring and then post them all in one
big chunk. unfortunately our stack queues one packet onto the send queue
and then calls the start handler immediately.

this mitigates against that queue, send, queue, send behaviour by trying to
call the start routine only once per softnet. now its queue, queue, queue,
send.

this is the result of a lot of discussion with claudio@@
tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.167 2008/01/05 07:26:04 deraadt Exp $	*/
a89 2
#include <dev/rndvar.h>

a1997 6
}

void
netrndintr(void)
{
	add_net_randomness(0);
@


1.168
log
@make sure all callers of rtlabel_id2name check for a null return value.
all the original ones did, the recently added ones for labels per interface
didn't. no cookie for reyk ;(
ok deraadt
@
text
@d177 1
d463 34
d597 2
@


1.167
log
@rtlabel_id2name() can return NULL if there is no route label..
from chris@@nmedia.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.166 2007/09/15 16:43:51 henning Exp $	*/
d1293 2
a1294 2
		if (ifp->if_rtlabelid) {
			label = rtlabel_id2name(ifp->if_rtlabelid);
@


1.166
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.165 2007/07/06 14:00:59 naddy Exp $	*/
d1293 7
a1299 4
		label = rtlabel_id2name(ifp->if_rtlabelid);
		strlcpy(ifrtlabelbuf, label, RTLABEL_LEN);
		error = copyoutstr(ifrtlabelbuf, ifr->ifr_data, RTLABEL_LEN,
		    &bytesdone);
@


1.165
log
@btintrq has been removed from bt_input.c, don't reference it here.
Makes bluetooth build again.  ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.164 2007/07/04 12:15:53 claudio Exp $	*/
d237 1
a237 2
		q = (caddr_t)malloc(n, M_IFADDR, M_WAITOK);
		bzero(q, n);
d247 1
a247 2
		q = (caddr_t)malloc(n, M_IFADDR, M_WAITOK);
		bzero(q, n);
d312 1
a312 2
	ifa = (struct ifaddr *)malloc(ifasize, M_IFADDR, M_WAITOK);
	bzero((caddr_t)ifa, ifasize);
d1592 1
a1592 1
	struct ifg_group	*ifg = NULL;
d1594 1
a1594 2
	if ((ifg = (struct ifg_group *)malloc(sizeof(struct ifg_group),
	    M_TEMP, M_NOWAIT)) == NULL)
d1627 1
a1627 2
	if ((ifgl = (struct ifg_list *)malloc(sizeof(struct ifg_list), M_TEMP,
	    M_NOWAIT)) == NULL)
d1630 1
a1630 2
	if ((ifgm = (struct ifg_member *)malloc(sizeof(struct ifg_member),
	    M_TEMP, M_NOWAIT)) == NULL) {
@


1.165.2.1
log
@MFC, initial fix by Chris Cappucino, more complete fix by me:
make sure users of rtlabel_id2name() can deal with no label present,
by not calling it when the label id is 0 (initial fix) and also checking
for rtlabel_id2name() returning NULL (complete fix). original rtlabel code
had that all right, the newer rtlabel bound to an interface code not.
impact: local users can cause a kernel panic by using the SIOCGIFRTLABEL
ioctl on interfaces with no route label assigned.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.165 2007/07/06 14:00:59 naddy Exp $	*/
d1296 4
a1299 7
		if (ifp->if_rtlabelid &&
		    (label = rtlabel_id2name(ifp->if_rtlabelid)) != NULL) {
			strlcpy(ifrtlabelbuf, label, RTLABEL_LEN);
			error = copyoutstr(ifrtlabelbuf, ifr->ifr_data,
			    RTLABEL_LEN, &bytesdone);
		} else
			error = ENOENT;
@


1.164
log
@Fix a use after free crash in in_delmulti(). If a interface is detached
before it is removed from the multicast group in_delmulti() will try to
access the no longer available ifp.
We invalidate the ifa_ifp back pointer in the ifa in if_detach() now and use
the ifa_ifp in in_delmulti() instead of the internal inm_ifp. By doing it
this way we know if the interface was removed.
This fixes a kernel panic triggered by ospfd and gif(4) tunnels.
looks good henning@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.163 2007/06/17 21:01:32 henning Exp $	*/
a554 3
#endif
#if NBLUETOOTH > 0
	IF_DETACH_QUEUES(btintrq);
@


1.163
log
@add back missing bcopy & break, got lost when removing arcnet.
spotted by Mike Belopuhov <mkb@@crypt.org.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.162 2007/06/14 18:31:49 reyk Exp $	*/
d583 1
d593 1
@


1.162
log
@Add a new "rtlabel" option to ifconfig. It allows to specify a route label
which will be used for new interface routes. For example,
	ifconfig em0 10.1.1.0 255.255.255.0 rtlabel RING_1
will set the new interface address and attach the route label RING_1 to
the corresponding route.

manpage bits from jmc@@
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.161 2007/06/08 09:31:38 henning Exp $	*/
d1360 3
a1362 1
			/* FALLTHROUGH */
@


1.161
log
@kill arcnet leftovers, some pt out by Mike Belopuhov <mkb@@crypt.org.ru>,
some I found afterwards, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.160 2007/06/06 10:04:36 henning Exp $	*/
d1154 1
d1158 1
d1293 18
@


1.160
log
@remove remaining IPX hooks. all inside #ifdef IPX, so no actual change
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.159 2007/05/29 02:21:18 claudio Exp $	*/
a1340 4
		case IFT_ARCNET:
			bcopy((caddr_t)ifr->ifr_addr.sa_data,
			    LLADDR(sdl), ETHER_ADDR_LEN);
			break;
@


1.159
log
@Spaces, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.158 2007/05/28 08:48:15 mcbride Exp $	*/
a547 3
#endif
#ifdef IPX
	IF_DETACH_QUEUES(ipxintrq);
@


1.158
log
@Only call add_net_randomness() once per interrupt instead of once per packet.   If multiple packets come in on a single interrupt the times mixed into
the randomness pool will be identical or predictably close anyways, and
nanotime() is expensive.

ok toby jason miod claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.157 2007/03/25 18:26:23 mpf Exp $	*/
d796 1
a796 1
	     ifc = LIST_NEXT(ifc, ifc_list), count--, dst += IFNAMSIZ) {
d1321 10
a1330 10
	        if ((error = suser(p, 0)))
	                return (error);
	        ifa = ifnet_addrs[ifp->if_index];
	        if (ifa == NULL)
	                return (EINVAL);
	        sdl = (struct sockaddr_dl *)ifa->ifa_addr;
	        if (sdl == NULL)
	                return (EINVAL);
	        if (ifr->ifr_addr.sa_len != ETHER_ADDR_LEN)
	                return (EINVAL);
d1333 1
a1333 1
	        switch (ifp->if_type) {
d1340 3
a1342 3
	                bcopy((caddr_t)ifr->ifr_addr.sa_data,
			      (caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			      ETHER_ADDR_LEN);
d1345 2
a1346 2
                        bcopy((caddr_t)ifr->ifr_addr.sa_data,
			      LLADDR(sdl), ETHER_ADDR_LEN);
d1349 1
a1349 1
	                return (ENODEV);
d1353 1
a1353 1
		        int s = splnet();
d1362 1
a1362 1
			        if (ifa->ifa_addr != NULL &&
d1364 1
a1364 1
				        arp_ifinit((struct arpcom *)ifp, ifa);
d1939 1
a1939 1
 
@


1.157
log
@Synchronise carp advertisements on group demotion.
This reduces group failover time to a few milliseconds.
Diff from Nathanael.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.156 2007/03/18 23:23:17 mpf Exp $	*/
d88 3
d1952 6
@


1.156
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.155 2007/02/14 00:53:48 jsg Exp $	*/
d1791 1
d1807 4
@


1.155
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.154 2007/02/12 22:36:47 mpf Exp $	*/
d1332 1
@


1.154
log
@Don't pass random flags to SIOIFFLAGS when changing the lladdr.
OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.153 2006/12/03 13:41:19 reyk Exp $	*/
d1339 1
a1339 1
			/* fall through */
@


1.153
log
@Add Rapid Spanning Tree Protocol support (802.1d-2004) based on work
by Andrew Thompson (thompsa@@freebsd.org). The local changes include
adoption to our bridge code, reduced stack usage and many other bits.
If stp is enabled, RSTP will now be used by default.

Thanks for help from Andrew.

This code has been in snaps for while now, commit encouraged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.152 2006/11/24 20:57:46 canacar Exp $	*/
d1348 1
d1351 2
a1352 1
			(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifr);
d1354 2
a1355 1
			(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifr);
@


1.152
log
@Check the reference count for interface addresses when detaching
an interface. Fixes a double free panic.
ok claudio@@, looks fine henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.151 2006/11/16 13:09:27 henning Exp $	*/
d1032 4
d1064 4
@


1.151
log
@introduce if_creategroup() to create an empty interface group.
code factored out from if_addgroup(), previously a group always had to have
members. ok mpf mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.150 2006/10/21 14:02:11 henning Exp $	*/
a570 1
	 * XXX should consult refcnt and use IFAFREE
d572 1
a572 2
	for (ifa = TAILQ_FIRST(&ifp->if_addrlist); ifa;
	    ifa = TAILQ_FIRST(&ifp->if_addrlist)) {
d583 1
a583 1
		free(ifa, M_IFADDR);
d592 1
a592 1
	free(ifnet_addrs[ifp->if_index], M_IFADDR);
d1002 1
a1004 1
		ifa->ifa_refcnt++;
@


1.150
log
@the create and destroy functions for clonable interfaces return 0 on
success, not -1 on error. fix check in 2 cases. ok mpf mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.149 2006/08/29 17:19:43 henning Exp $	*/
d1563 24
d1618 4
a1621 15
	if (ifg == NULL) {
		if ((ifg = (struct ifg_group *)malloc(sizeof(struct ifg_group),
		    M_TEMP, M_NOWAIT)) == NULL) {
			free(ifgl, M_TEMP);
			free(ifgm, M_TEMP);
			return (ENOMEM);
		}
		strlcpy(ifg->ifg_group, groupname, sizeof(ifg->ifg_group));
		ifg->ifg_refcnt = 0;
		ifg->ifg_carp_demoted = 0;
		TAILQ_INIT(&ifg->ifg_members);
#if NPF > 0
		pfi_attach_ifgroup(ifg);
#endif
		TAILQ_INSERT_TAIL(&ifg_head, ifg, ifg_next);
@


1.149
log
@allow the carp demotion counter to be changed by arbitary values as long
as the resulting demotion counter value is in range. previously, we only
allowed +/- 1. ok mpf mcbride deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.148 2006/07/18 09:23:43 mickey Exp $	*/
d663 1
a663 1
	if ((ret = (*ifc->ifc_create)(ifc, unit)) != -1 &&
d699 1
a699 1
	if ((ret = (*ifc->ifc_destroy)(ifp)) == -1)
@


1.149.2.1
log
@MFC: fix by canacar
Check the reference count for interface addresses when detaching
an interface. Fixes a double free panic.
ok claudio@@, looks fine henning@@

ok deraadt ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.152 2006/11/24 20:57:46 canacar Exp $	*/
d571 1
d573 2
a574 1
	while ((ifa = TAILQ_FIRST(&ifp->if_addrlist)) != NULL) {
d585 1
a585 1
		IFAFREE(ifa);
d594 1
a594 1
	IFAFREE(ifnet_addrs[ifp->if_index]);
a1003 1
		ifa->ifa_refcnt++;
d1006 1
@


1.148
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.147 2006/06/02 19:53:12 mpf Exp $	*/
d1777 3
a1779 2
	if (demote > 1 || demote < -1)
		return (E2BIG);
d1781 1
a1781 4
	if (demote + ifg->ifg_carp_demoted >= 0)
		ifg->ifg_carp_demoted += demote;
	else
		ifg->ifg_carp_demoted = 0;
@


1.147
log
@Introduce attributes to interface groups.
As a first user, move the global carp(4) demotion counter
into the interface group. Thus we have the possibility
to define which carp interfaces are demoted together.

Put the demotion counter into the reserved field of the carp header.
With this, we can have carp act smarter if multiple errors occur.
It now always takes over other carp peers, that are advertising
with a higher demote count.  As a side effect, we can also have
group failovers without the need of running in preempt mode.
The protocol change does not break compability with older
implementations.

Collaborative work with mcbride@@

OK mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.146 2006/03/22 14:37:44 henning Exp $	*/
d218 1
a218 1
	 *	struct ifadd **ifnet_addrs
@


1.146
log
@prevent anything outside rote.c from accessing the routing table heads
directly. rather provide a rt_lookup function for regular lookups,
and a rt_gettable for those that need access to the head for some reason.
the latter cases should be revisted later probably so that nothing outside
the routing core code accesses the heads at all...
tested claudio jolan me, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.145 2006/03/20 10:03:49 henning Exp $	*/
d140 2
d1172 6
d1291 1
d1305 1
d1603 1
d1742 42
@


1.145
log
@introduce rt_if_remove which takes care of routing table updates for an
interface that is removed. use that from if.c and if_tun.c instead of
re-implementing in the latter case. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.144 2006/03/04 22:40:15 brad Exp $	*/
a1763 1
	struct radix_node_head	*rnh;
a1776 3
	if ((rnh = rt_tables[AF_INET]) == NULL)
		return (-1);

d1780 1
a1780 1
	if ((rn = rnh->rnh_lookup(&sa_in, &sa_in, rnh))) {
d1786 3
a1788 3
			if (rn_mpath_capable(rnh))
				rn = rn_mpath_next(rn);
			else
a1789 1
				rn = NULL;
a1793 3
	if ((rnh = rt_tables[AF_INET6]) == NULL)
		return (-1);

d1795 1
a1795 1
	if ((rn = rnh->rnh_lookup(&sa_in6, &sa_in6, rnh))) {
d1801 3
a1803 3
			if (rn_mpath_capable(rnh))
				rn = rn_mpath_next(rn);
			else
a1804 1
				rn = NULL;
@


1.144
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.143 2006/02/09 00:05:55 reyk Exp $	*/
a128 1
int	if_detach_rtdelete(struct radix_node *, void *);
a460 31
 * Delete a route if it has a specific interface for output.
 * This function complies to the rn_walktree callback API.
 *
 * Note that deleting a RTF_CLONING route can trigger the
 * deletion of more entries, so we need to cancel the walk
 * and return EAGAIN.  The caller should restart the walk
 * as long as EAGAIN is returned.
 */
int
if_detach_rtdelete(struct radix_node *rn, void *vifp)
{
	struct ifnet *ifp = vifp;
	struct rtentry *rt = (struct rtentry *)rn;

	if (rt->rt_ifp == ifp) {
		int cloning = (rt->rt_flags & RTF_CLONING);

		if (rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
		    rt_mask(rt), 0, NULL) == 0 && cloning)
			return (EAGAIN);
	}

	/*
	 * XXX There should be no need to check for rt_ifa belonging to this
	 * interface, because then rt_ifp is set, right?
	 */

	return (0);
}

/*
d471 1
a471 2
	int i, s = splnet();
	struct radix_node_head *rnh;
d509 1
a509 13

	/*
	 * Find and remove all routes which is using this interface.
	 * XXX Factor out into a route.c function?
	 */
	for (i = 1; i <= AF_MAX; i++) {
		rnh = rt_tables[i];
		if (rnh)
			while ((*rnh->rnh_walktree)(rnh,
			    if_detach_rtdelete, ifp) == EAGAIN)
				;
	}

@


1.143
log
@add an interface detach hook and use it with the vlan(4) driver. this
fixes a possible crash if the parent interface has been destroyed
(like vlan on trunk) before destroying the vlan interface.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.142 2006/01/05 03:28:34 deraadt Exp $	*/
d503 1
a503 1
	int i, s = splimp();
d735 1
a735 1
		s = splimp();
d1151 1
a1151 1
	int s = splimp();
d1244 1
a1244 1
			int s = splimp();
d1249 1
a1249 1
			int s = splimp();
d1377 1
a1377 1
		        int s = splimp();
@


1.143.2.1
log
@MFC: fix by canacar
Check the reference count for interface addresses when detaching
an interface. Fixes a double free panic.
ok claudio@@, looks fine henning@@

ok deraadt ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.152 2006/11/24 20:57:46 canacar Exp $	*/
d614 1
d616 2
a617 1
	while ((ifa = TAILQ_FIRST(&ifp->if_addrlist)) != NULL) {
d628 1
a628 1
		IFAFREE(ifa);
d637 1
a637 1
	IFAFREE(ifnet_addrs[ifp->if_index]);
a1046 1
		ifa->ifa_refcnt++;
d1049 1
@


1.142
log
@bzero buffers after malloc, or clear string buffer before strlcpy'ing
into them, if you are gonna copy it out to userland
some ok dhartmei, some ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.141 2005/12/22 23:55:18 canacar Exp $	*/
d408 5
d439 5
d513 3
d642 1
@


1.141
log
@Do not check ifp->if_bpf before detaching from bpf. It is only a signal
to the driver that there is a listener. Somehow I assumed that it was
a handle, and was trying to figure out why it was becoming zero.
Corrected by and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.140 2005/11/29 02:59:42 jolan Exp $	*/
d825 1
d1711 1
d1753 1
@


1.140
log
@something in the eurobsdcon route-a-thon broke my simple home network
router so back out the routing stuff to pre-eurobsdcon where my machine
doesn't crash immediately.

i am happy to test diffs and report success/failures but i am not happy
to have instantaneous crashes when i reboot with a new kernel that was
compiled from pristine sources.

if you are going to be an elitist asshole then you could at least make
sure your code works.

ok and "be crass towards them" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.137 2005/07/04 09:52:33 henning Exp $	*/
d521 1
a521 3
	/* If there is a bpf device attached, detach from it.  */
	if (ifp->if_bpf)
		bpfdetach(ifp);
@


1.139
log
@don't let anything outside route.c access the routing table heads directly,
but go through a provided wrapper.
also provide rt_lookup() instead of doing the lookup manually in many places.
ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.138 2005/11/25 13:45:02 henning Exp $	*/
d129 1
d452 31
d493 2
a494 1
	int s;
a496 2
	s = splimp();

d532 11
a542 1
	rt_if_remove(ifp);
d1794 1
d1808 3
d1814 1
a1814 1
	if ((rn = rt_lookup(sintosa(&sa_in), sintosa(&sa_in), 0)) != NULL) {
d1820 3
a1822 3
			rn = rn_mpath_next(rn);
#else
			rn = NULL;
d1824 1
d1829 3
d1833 1
a1833 1
	if ((rn = rt_lookup(sin6tosa(&sa_in6), sin6tosa(&sa_in6), 0)) != NULL) {
d1839 3
a1841 3
			rn = rn_mpath_next(rn);
#else
			rn = NULL;
d1843 1
@


1.138
log
@move the code to delete routes having a specific interface as output
when the interface is deleted to a function in route.c, and replace
the copies of that code by calls to that function
from basel almost-hackathon
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.137 2005/07/04 09:52:33 henning Exp $	*/
a1752 1
	struct radix_node_head	*rnh;
a1765 3
	if ((rnh = rt_tables[AF_INET]) == NULL)
		return (-1);

d1769 1
a1769 1
	if ((rn = rnh->rnh_lookup(&sa_in, &sa_in, rnh))) {
d1775 3
a1777 3
			if (rn_mpath_capable(rnh))
				rn = rn_mpath_next(rn);
			else
a1778 1
				rn = NULL;
a1782 3
	if ((rnh = rt_tables[AF_INET6]) == NULL)
		return (-1);

d1784 1
a1784 1
	if ((rn = rnh->rnh_lookup(&sa_in6, &sa_in6, rnh))) {
d1790 3
a1792 3
			if (rn_mpath_capable(rnh))
				rn = rn_mpath_next(rn);
			else
a1793 1
				rn = NULL;
@


1.137
log
@in if_group_routechange(), when checking wether a default route was changed
to trigger an if_group_egress_build() call, stop looking at the mask in the
v4 case, at least until I figured out why we sometimes see masks full of
crap.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.136 2005/06/23 14:30:40 mickey Exp $	*/
a128 1
int	if_detach_rtdelete(struct radix_node *, void *);
a450 31
 * Delete a route if it has a specific interface for output.
 * This function complies to the rn_walktree callback API.
 *
 * Note that deleting a RTF_CLONING route can trigger the
 * deletion of more entries, so we need to cancel the walk
 * and return EAGAIN.  The caller should restart the walk
 * as long as EAGAIN is returned.
 */
int
if_detach_rtdelete(struct radix_node *rn, void *vifp)
{
	struct ifnet *ifp = vifp;
	struct rtentry *rt = (struct rtentry *)rn;

	if (rt->rt_ifp == ifp) {
		int cloning = (rt->rt_flags & RTF_CLONING);

		if (rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
		    rt_mask(rt), 0, NULL) == 0 && cloning)
			return (EAGAIN);
	}

	/*
	 * XXX There should be no need to check for rt_ifa belonging to this
	 * interface, because then rt_ifp is set, right?
	 */

	return (0);
}

/*
d461 1
a461 2
	int i, s = splimp();
	struct radix_node_head *rnh;
d464 2
d501 1
a501 11
	/*
	 * Find and remove all routes which is using this interface.
	 * XXX Factor out into a route.c function?
	 */
	for (i = 1; i <= AF_MAX; i++) {
		rnh = rt_tables[i];
		if (rnh)
			while ((*rnh->rnh_walktree)(rnh,
			    if_detach_rtdelete, ifp) == EAGAIN)
				;
	}
@


1.137.2.1
log
@MFC:
Fix by deraadt@@

bzero buffers after malloc, or clear string buffer before strlcpy'ing
into them, if you are gonna copy it out to userland

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.137 2005/07/04 09:52:33 henning Exp $	*/
a826 1
		bzero(outbuf, sizeof outbuf);
a1711 1
		bzero(&ifgrq, sizeof ifgrq);
a1752 1
		bzero(&ifgrq, sizeof ifgrq);
@


1.136
log
@update if_lastchange for evey IFF_UP change not only SIOCSIFFLAGS; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.135 2005/06/14 04:00:38 henning Exp $	*/
d1770 1
a1770 2
		if (satosin(dst)->sin_addr.s_addr == INADDR_ANY &&
		    mask && satosin(mask)->sin_addr.s_addr == INADDR_ANY)
@


1.135
log
@rename function and define to reflect the external -> egress name change
so it is clear what it is all about
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.134 2005/06/13 21:02:21 henning Exp $	*/
d1440 1
@


1.134
log
@check wether mask is NULL in if_group_routechange before dereferencing
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.133 2005/06/12 00:41:33 henning Exp $	*/
d146 1
a146 1
int	if_group_ext_build(void);
d1771 1
a1771 1
			if_group_ext_build();
d1779 1
a1779 1
			if_group_ext_build();
d1786 1
a1786 1
if_group_ext_build(void)
d1799 1
a1799 1
		if (!strcmp(ifg->ifg_group, IFG_EXTERNAL))
d1805 1
a1805 1
			if_delgroup(ifgm->ifgm_ifp, IFG_EXTERNAL);
d1818 1
a1818 1
				if_addgroup(rt->rt_ifp, IFG_EXTERNAL);
d1837 1
a1837 1
				if_addgroup(rt->rt_ifp, IFG_EXTERNAL);
@


1.133
log
@add SIOCGIFGMEMB ioctl, returns a list of all interfaces who are member of
the given group, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.132 2005/06/08 07:36:50 henning Exp $	*/
d1770 1
a1770 1
		    satosin(mask)->sin_addr.s_addr == INADDR_ANY)
d1777 1
a1777 1
		    IN6_ARE_ADDR_EQUAL(&(satosin6(mask))->sin6_addr,
@


1.132
log
@if a cloned interface's destroy function fails, re-join the interface class
group, spotted by and ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.131 2005/06/08 06:58:11 henning Exp $	*/
d139 3
d1200 2
d1713 41
@


1.131
log
@kill NS and DECNET bits
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.130 2005/06/08 00:14:45 deraadt Exp $	*/
d706 1
a706 1
	int s;
d727 4
a730 1
	return ((*ifc->ifc_destroy)(ifp));
@


1.130
log
@more inet6 stuff that got exposed
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.129 2005/06/08 00:13:19 deraadt Exp $	*/
a577 3
#ifdef NS
	IF_DETACH_QUEUES(nsintrq);
#endif
a583 3
#endif
#ifdef DECNET
	IF_DETACH_QUEUES(decnetintrq);
@


1.129
log
@handle ramdisks, and kernels without inet6; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.128 2005/06/07 18:21:44 henning Exp $	*/
d1730 1
d1738 1
@


1.128
log
@introduce a default "external" interface group, containing the interface(s)
the the default route(s) point to.
handles IPv4 and IPv6 as well as multipath routes.
follows default route changes, of course.
eases writing pf rulesets especially on laptops etc. that use different
interfaces depending on the environment (wired, wireless, ...)
ok theo ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.127 2005/06/07 02:45:11 henning Exp $	*/
d1746 1
d1748 1
d1774 1
d1778 1
d1793 1
d1797 1
@


1.127
log
@do not handle CCITT any longer
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.126 2005/06/06 03:44:21 henning Exp $	*/
d143 1
d1721 78
@


1.126
log
@use a define instead of hardcoding "all" in 3 places
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.125 2005/06/06 03:05:05 henning Exp $	*/
a582 3
#endif
#ifdef CCITT
	IF_DETACH_QUEUES(llcintrq);
@


1.125
log
@make cloned interfaces join an interface class group (carp for carpX, tun
for tunX etc) in if_clone_create and leave it in if_clone_destroy, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.123 2005/05/26 04:07:45 henning Exp $	*/
d251 1
a251 1
	if_addgroup(ifp, "all");
@


1.124
log
@const'ify the char *groupname param to if_addgroup and if_delgroup
@
text
@d689 2
a690 1
	int unit;
d699 5
a703 1
	return ((*ifc->ifc_create)(ifc, unit));
d732 2
@


1.123
log
@deny groupnames ending in digits in if_addgroup, frantzen ok
(this has been on my todo, mike beat me to it with the check in ifconfig, but
we want it here too)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.121 2005/05/26 03:13:41 henning Exp $	*/
d1580 1
a1580 1
if_addgroup(struct ifnet *ifp, char *groupname)
d1642 1
a1642 1
if_delgroup(struct ifnet *ifp, char *groupname)
@


1.122
log
@oups another unused var
@
text
@d1586 4
@


1.121
log
@unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.120 2005/05/26 03:11:59 henning Exp $	*/
a178 1
	int n;
@


1.120
log
@remove the interface family group (i. e. "em" for "em0")
I foudn this stupid from the beginning on :)
talked about and agreed with ryan and theo on the hike
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.119 2005/05/25 06:50:05 henning Exp $	*/
a180 1
	char ifgroup[IFNAMSIZ];
@


1.119
log
@when an interface joins or leaves a group call back into pf so it can
update the internal tables used for (ifgroup) notation
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.118 2005/05/24 06:48:49 reyk Exp $	*/
a252 5
	/* add the interface family group */
	for (n = 0; ifp->if_xname[n] < '0' || ifp->if_xname[n] > '9'; n++)
		continue;
	strlcpy(ifgroup, ifp->if_xname, n + 1);
	if_addgroup(ifp, ifgroup);
@


1.118
log
@include trunk.h to get the NTRUNK value

ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.117 2005/05/24 04:20:25 markus Exp $	*/
d1634 4
d1676 4
@


1.117
log
@add net.inet.ip.ifq for monitoring and changing ifqueue; similar to netbsd
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.116 2005/05/24 02:49:34 henning Exp $	*/
d69 1
d85 1
@


1.116
log
@actually delete the interface from the member list when it leaves the group
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.115 2005/05/24 02:45:17 reyk Exp $	*/
d80 1
d1746 22
@


1.115
log
@initial import of a trunking (link aggregation and link failover)
implementation. it currently supports round robin mode with link state
checking, additional modes will be added later.

ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.114 2005/05/24 02:26:04 henning Exp $	*/
d1641 1
d1650 9
@


1.114
log
@keep a list of member interfaces in ifg_group
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.113 2005/05/22 21:06:02 henning Exp $	*/
d108 4
d502 5
@


1.113
log
@missing #if NPF > 0 around ifgroups attachments
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.112 2005/05/22 18:23:04 henning Exp $	*/
d1579 1
d1589 6
d1603 1
d1608 1
d1617 1
d1619 1
@


1.112
log
@allow pf to match on interface groups
pass on mygroup ...
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.111 2005/05/21 21:24:38 henning Exp $	*/
d1600 1
d1602 1
d1632 1
d1634 1
@


1.111
log
@make every interface join a group called "all", mcbride ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.110 2005/05/21 21:03:57 henning Exp $	*/
d1600 1
d1630 1
@


1.110
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.109 2005/05/09 08:08:47 mpf Exp $	*/
d251 1
@


1.109
log
@ansify. no binary change.
OK henning, krw, brad, moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.108 2005/04/28 10:38:55 pascoe Exp $	*/
a778 3
#if NPF > 0
	pfi_attach_clone(ifc);
#endif
@


1.108
log
@Don't detach interface from pf's perspective until after IPv6 is done with it.

ok dlg@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.107 2005/04/20 23:00:41 mpf Exp $	*/
d169 1
a169 2
if_attachsetup(ifp)
	struct ifnet *ifp;
d281 1
a281 2
if_alloc_sadl(ifp)
	struct ifnet *ifp;
d334 1
a334 2
if_free_sadl(ifp)
	struct ifnet *ifp;
d367 1
a367 2
if_attachdomain1(ifp)
	struct ifnet *ifp;
d386 1
a386 2
if_attachhead(ifp)
	struct ifnet *ifp;
d408 1
a408 2
if_attach(ifp)
	struct ifnet *ifp;
d456 1
a456 3
if_detach_rtdelete(rn, vifp)
	struct radix_node *rn;
	void *vifp;
d484 1
a484 2
if_detach(ifp)
	struct ifnet *ifp;
d644 1
a644 3
if_detach_queues(ifp, q)
	struct ifnet *ifp;
	struct ifqueue *q;
d680 1
a680 2
if_clone_create(name)
	const char *name;
d699 1
a699 2
if_clone_destroy(name)
	const char *name;
d729 1
a729 3
if_clone_lookup(name, unitp)
	const char *name;
	int *unitp;
d775 1
a775 2
if_clone_attach(ifc)
	struct if_clone *ifc;
d788 1
a788 2
if_clone_detach(ifc)
	struct if_clone *ifc;
d799 1
a799 2
if_clone_list(ifcr)
	struct if_clonereq *ifcr;
d863 1
a863 2
ifa_ifwithaddr(addr)
	struct sockaddr *addr;
d891 1
a891 2
ifa_ifwithdstaddr(addr)
	struct sockaddr *addr;
d914 1
a914 2
ifa_ifwithnet(addr)
	struct sockaddr *addr;
d957 1
a957 2
ifa_ifwithaf(af)
	int af;
d976 1
a976 3
ifaof_ifpforaddr(addr, ifp)
	struct sockaddr *addr;
	struct ifnet *ifp;
d1016 1
a1016 4
link_rtrequest(cmd, rt, info)
	int cmd;
	struct rtentry *rt;
	struct rt_addrinfo *info;
d1106 1
a1106 2
if_qflush(ifq)
	struct ifqueue *ifq;
d1126 1
a1126 2
if_slowtimo(arg)
	void *arg;
d1147 1
a1147 2
ifunit(name)
	const char *name;
d1162 1
a1162 5
ifioctl(so, cmd, data, p)
	struct socket *so;
	u_long cmd;
	caddr_t data;
	struct proc *p;
d1449 1
a1449 3
ifconf(cmd, data)
	u_long cmd;
	caddr_t data;
d1682 1
a1682 3
ifpromisc(ifp, pswitch)
	struct ifnet *ifp;
	int pswitch;
@


1.107
log
@Introduce if_linkstatehooks.
This converts if_link_state_change() to a generic usable
callback with dohooks().

OK henning@@, camield@@
Tested by camield@@ and Alexey E. Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.106 2005/04/05 12:19:37 claudio Exp $	*/
a506 4
#if NPF > 0
	pfi_detach_ifnet(ifp);
#endif

d554 4
@


1.106
log
@Return EINVAL in SIOCSIFLLADDR if new lladdr is a multicast address.
OK derradt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.105 2005/03/30 02:55:36 tedu Exp $	*/
d403 5
d430 5
d638 1
a1120 1
 * XXX Should be converted to dohooks().
d1126 1
a1126 4
#if NCARP > 0           
	if (ifp->if_carp)
		carp_carpdev_state(ifp);
#endif          
@


1.105
log
@add lladdr command to ifconfig to set MAC address.  diffs from freebsd via
Kyunghwan KIM (prs 2117 and 2118) and Fredrik Widlund.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1355 1
a1355 1
	                return(EINVAL);
d1358 1
a1358 1
	                return(EINVAL);
d1360 3
a1362 1
	                return(EINVAL);
d1370 2
a1371 1
			      (caddr_t)((struct arpcom *)ifp)->ac_enaddr, ETHER_ADDR_LEN);
@


1.104
log
@Add new function if_link_state_change() to take care of sending messages
on the routing socket and notifying carp() of link changes.

ok brad@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.103 2005/01/18 22:10:10 claudio Exp $	*/
d1193 2
d1348 42
@


1.104.2.1
log
@MFC:
Fix by deraadt@@

bzero buffers after malloc, or clear string buffer before strlcpy'ing
into them, if you are gonna copy it out to userland

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.104 2005/02/07 15:00:16 mcbride Exp $	*/
a825 1
		bzero(outbuf, sizeof outbuf);
a1643 1
		bzero(&ifgrq, sizeof ifgrq);
@


1.103
log
@If there is no match in ifaof_ifpforaddr() return the first match -- main
interface address -- and not the last one -- some alias. Also handle point to
point networks a bit more special.
With some input from markus@@ OK markus@@ henning@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.102 2005/01/14 12:04:02 grange Exp $	*/
d1105 15
@


1.102
log
@First step in Bluetooth protocol stack support.

The code is adopted from the FreeBSD netgraph-based Bluetooth
implementation by Maksim Yevmenkin <m_evmenkin@@yahoo.com> but
all netgraph glue was replaced with usual BSD network stack
hooks. This is a work in progress. Only HCI layer works for now,
L2CAP and RFCOMM are on the way.

Help in testing from many, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.101 2005/01/14 11:49:01 henning Exp $	*/
d994 1
a994 1
	struct ifaddr *ifa_maybe = 0;
d1002 3
a1004 2
		ifa_maybe = ifa;
		if (ifa->ifa_netmask == 0) {
@


1.101
log
@remove old ifgroups ioctls
the old ifgroups haven't been in use ever really, and the new
implementation is 3 months old today. theo ok (3 months ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.100 2004/12/20 07:24:38 pascoe Exp $	*/
d64 1
d585 3
@


1.100
log
@Enforce an ordering on ifnet such that CARP interfaces appear later in the
list than physical interfaces.  This makes ifa_ifwith* prefer a physical
interface over a CARP one.

This addresses the problem where a CARP interface in BACKUP state is
selected after a route change, resulting in a loss of communications
despite there being another interface available which is perfectly usable.

ok mcbride@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.99 2004/12/08 07:02:16 mcbride Exp $	*/
a1304 6
		break;

	case OSIOCAIFGROUP:
	case OSIOCGIFGROUP:
	case OSIOCDIFGROUP:
		return (EINVAL);
@


1.99
log
@Call if_down() in if_clone_destroy(). Based on diff from Chris Pascoe.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.98 2004/12/08 06:57:55 mcbride Exp $	*/
d410 4
d424 11
d436 2
d903 1
a903 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
@


1.98
log
@Check if_type in carp_carpdev_state() to make sure we're not
dealing with a carp interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.97 2004/12/07 20:38:46 mcbride Exp $	*/
d684 1
d696 6
@


1.97
log
@Convert carp(4) to behave more like a regular interface, much in the same
style as vlan(4). carp interfaces no longer require the physical interface
to be on the same subnet as the carp interface, or even that the physical
interface has an adress at all, so CARP can now be used on /30 networks.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.96 2004/12/07 19:26:46 mcbride Exp $	*/
d1041 1
a1041 1
		carp_carpdev_state(ifp->if_carp);
d1070 1
a1070 1
		carp_carpdev_state(ifp->if_carp);
@


1.96
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.95 2004/12/04 16:16:45 markus Exp $	*/
d82 1
d491 1
a491 1
	if (ifp->if_carp)
@


1.95
log
@use C comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.94 2004/12/03 17:31:03 henning Exp $	*/
d213 1
a213 1
		
d396 2
a397 1
	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks), M_TEMP, M_NOWAIT);
d414 2
a415 1
	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks), M_TEMP, M_NOWAIT);
d652 1
a652 1
} 
d847 3
a849 2
#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), ((struct sockaddr *)(a1))->sa_len) == 0)
d878 1
a878 1
	        TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
d1378 1
a1378 1
  	}
d1407 3
a1409 2
			else 
				TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
d1416 2
a1417 2
						    sizeof (*sa);
					space += sizeof (ifr);
d1435 1
a1435 1
		} else 
d1447 2
a1448 2
					error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
					    sizeof (ifr));
d1454 2
a1455 2
					error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
					    sizeof (ifr));
d1461 3
a1463 2
					error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
					    sizeof (ifr.ifr_name));
d1607 1
a1607 1
		if ((error = copyout((caddr_t)&ifgrq, (caddr_t)ifgp, 
d1617 1
a1617 1
		
@


1.94
log
@do not use one struct timeout for the if congestion stuff, but embed
a struct timeout to struct ifqueue so that each one has its own - it
is a per-queue thing. from chris pascoe
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.93 2004/10/14 21:28:15 mickey Exp $	*/
d810 1
a810 1
	// Not currently needed, all callers check this
@


1.93
log
@avoid stupid commons
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.92 2004/10/11 10:13:49 henning Exp $	*/
d810 3
a812 1
	static struct timeout	to;
d814 5
a818 4
	ifq->ifq_congestion = 1;
	bzero(&to, sizeof(to));
	timeout_set(&to, if_congestion_clear, ifq);
	timeout_add(&to, hz / 100);
d825 1
a825 1
if_congestion_clear(void *ifq)
d827 5
a831 1
	((struct ifqueue *)ifq)->ifq_congestion = 0;
@


1.92
log
@ifgroups reqrite
there is now a TAILQ with all interface groups as members, and
in struct ofnet there is only a pointer to the group structure stored
and not its name.
mostly hacked at c2k4 and somewhere over the atlantic ocean
ok markus mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.91 2004/09/15 17:46:44 grange Exp $	*/
d135 1
@


1.91
log
@Kill more netiso ghosts.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.90 2004/06/26 17:36:32 markus Exp $	*/
a168 1
	struct ifgroup *ifg;
d172 1
a241 1
	/* setup the group list */
d243 6
a248 10
	ifg = (struct ifgroup *)malloc(sizeof(struct ifgroup), M_TEMP,
	    M_NOWAIT);
	if (ifg != NULL) {
		for (n = 0;
		    ifp->if_xname[n] < '0' || ifp->if_xname[n] > '9';
		    n++)
			continue;
		strlcpy(ifg->ifg_group, ifp->if_xname, n + 1);
		TAILQ_INSERT_HEAD(&ifp->if_groups, ifg, ifg_next);
 	}
d390 1
a390 1
	if (if_index == 0)
d392 2
d407 1
a407 1
	if (if_index == 0)
d409 2
d464 1
a464 1
	struct ifgroup *ifg;
d594 2
a595 4
	    ifg = TAILQ_FIRST(&ifp->if_groups)) {
		TAILQ_REMOVE(&ifp->if_groups, ifg, ifg_next);
		free(ifg, M_TEMP);
	}
d1137 1
d1271 6
d1278 1
a1278 1
		if ((error = suser(p, 0)) != 0)
d1280 2
a1281 1
		if ((error = if_addgroup((struct ifgroupreq *)data, ifp)))
d1291 6
a1296 5
                if ((error = suser(p, 0)) != 0)
                        return (error);
                if ((error = if_delgroup((struct ifgroupreq *)data, ifp)))
                        return (error);
                break;
d1507 1
a1507 1
if_addgroup(struct ifgroupreq *ifgr, struct ifnet *ifp)
d1509 2
a1510 1
	struct ifgroup	*ifgnew, *ifgp;
d1512 2
a1513 2
	TAILQ_FOREACH(ifgp, &ifp->if_groups, ifg_next)
		if (!strcmp(ifgp->ifg_group, ifgr->ifgr_group))
d1516 2
a1517 3
	ifgnew = (struct ifgroup *)malloc(sizeof(struct ifgroup), M_TEMP, 
	    M_NOWAIT);
	if (ifgnew == NULL)
d1519 20
a1538 2
	strlcpy(ifgnew->ifg_group, ifgr->ifgr_group, IFNAMSIZ);
	TAILQ_INSERT_TAIL(&ifp->if_groups, ifgnew, ifg_next);
a1544 1
 * note: the first group is the if-family - do not remove
d1547 1
a1547 1
if_delgroup(struct ifgroupreq *ifgr, struct ifnet *ifp)
d1549 9
a1557 1
	struct ifgroup	*ifgp;
d1559 3
a1561 11
	for (ifgp = TAILQ_FIRST(&ifp->if_groups);
	    ifgp != TAILQ_END(&ifp->if_groups);
	    ifgp = TAILQ_NEXT(ifgp, ifg_next)) {
		if (ifgp == TAILQ_FIRST(&ifp->if_groups) &&
		    !strcmp(ifgp->ifg_group, ifgr->ifgr_group))
			return (EPERM);
		if (!strcmp(ifgp->ifg_group, ifgr->ifgr_group)) {
			TAILQ_REMOVE(&ifp->if_groups, ifgp, ifg_next);
			free(ifgp, M_TEMP);
			return (0);
		}
d1563 4
a1566 1
	return (ENOENT);
d1576 4
a1579 4
	int len;
	int error;
	struct ifgroup *ifgp, *ifgp2, ifg;
	struct ifgroupreq *ifgr = (struct ifgroupreq *)data;
d1582 2
a1583 2
		TAILQ_FOREACH(ifgp, &ifp->if_groups, ifg_next)
			ifgr->ifgr_len += sizeof(struct ifgroup);
d1589 7
a1595 8
	for (ifgp2 = TAILQ_FIRST(&ifp->if_groups); ifgp2 && 
	    len >= sizeof(struct ifgroup);
	    ifgp2 = TAILQ_NEXT(ifgp2, ifg_next)) {
		memset(&ifg, 0, sizeof(struct ifgroup));
		strlcpy(ifg.ifg_group, ifgp2->ifg_group, IFNAMSIZ);
		error = copyout((caddr_t)&ifg, (caddr_t)ifgp, 
		    sizeof(struct ifgroup));
		if (error)
d1597 1
a1598 1
		len -= sizeof(struct ifgroup);
@


1.90
log
@cleanup ioctl for ifgroups; ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.89 2004/06/25 18:24:23 pb Exp $	*/
a554 3
#endif
#ifdef ISO
	IF_DETACH_QUEUES(clnlintrq);
@


1.89
log
@introduce "interface groups"

by "ifconfig fxp0 group foobar" "ifconfig xl0 group foobar"
these two interfaces are in one group.
Every interface has its if-family as default group.

idea/design from henning@@, based on some work/disucssion from Joris Vink.

henning@@, mcbride@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.88 2004/05/29 17:54:45 jcs Exp $	*/
d251 2
a252 2
		strlcpy(ifg->if_group, ifp->if_xname, n + 1);
		TAILQ_INSERT_HEAD(&ifp->if_groups, ifg, group_list);
d599 1
a599 1
		TAILQ_REMOVE(&ifp->if_groups, ifg, group_list);
d1504 1
a1504 1
if_addgroup(struct ifgroupreq *ifg, struct ifnet *ifp)
d1508 2
a1509 2
	TAILQ_FOREACH(ifgp, &ifp->if_groups, group_list)
		if (!strcmp(ifgp->if_group, ifg->ifg_group))
d1516 2
a1517 2
	strlcpy(ifgnew->if_group, ifg->ifg_group, IFNAMSIZ);
	TAILQ_INSERT_TAIL(&ifp->if_groups, ifgnew, group_list);
d1527 1
a1527 1
if_delgroup(struct ifgroupreq *ifg, struct ifnet *ifp)
d1533 1
a1533 1
	    ifgp = TAILQ_NEXT(ifgp, group_list)) {
d1535 1
a1535 1
		    !strcmp(ifgp->if_group, ifg->ifg_group))
d1537 2
a1538 2
		if (!strcmp(ifgp->if_group, ifg->ifg_group)) {
			TAILQ_REMOVE(&ifp->if_groups, ifgp, group_list);
a1542 1

d1558 3
a1560 3
	if (ifgr->ifg_len == 0) {
		TAILQ_FOREACH(ifgp, &ifp->if_groups, group_list)
			ifgr->ifg_len += sizeof(struct ifgroup);
d1564 2
a1565 2
	len = ifgr->ifg_len;
	ifgp = ifgr->ifg_groups;
d1568 1
a1568 1
	    ifgp2 = TAILQ_NEXT(ifgp2, group_list)) {
d1570 1
a1570 1
		strlcpy(ifg.if_group, ifgp2->if_group, IFNAMSIZ);
@


1.88
log
@introduce SIOCSIFDESCR and SIOCGIFDESCR to maintain interface
descriptions, configurable with ifconfig

help from various, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.87 2004/04/28 01:20:29 deraadt Exp $	*/
d169 1
d171 1
d242 13
d465 1
d596 7
d1276 19
d1500 84
@


1.87
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.86 2004/04/28 00:28:43 mcbride Exp $	*/
d1120 1
d1122 1
d1234 17
@


1.86
log
@Make carp(4) aware of its physical interface:
- If the physical interface goes down or the link goes down,
  the carp interface goes down as well.
- We treat this like the preemption holdoff with pfsync.
  So if one of the carp interfaces is known to be bad (because the
  physical interface it's associated with is bad), all the other carp
  interfaces back off: they won't preempt, and their advskew goes to 240.

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.85 2004/04/17 00:09:01 henning Exp $	*/
d1137 2
a1138 2
			if_clone_create(ifr->ifr_name) :
			if_clone_destroy(ifr->ifr_name));
@


1.85
log
@add a congestion indicator to if_queue. It is set when the input queue
is full, along with a timer that unsets it again after 10ms.
The input queue beeing full is a reliable indicator for CPU overload, and
this flag allows other subsystems to cope with the situation.
hacked with beck
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.84 2004/02/28 09:14:10 mcbride Exp $	*/
d1010 4
d1038 4
@


1.84
log
@- Don't permit 0-padded unit numbers on cloned interfaces. Bug repoprt
  from otto@@
- Fix signedness issue with unit numbers. Bug report from Thorsten Glaser

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.83 2004/02/08 19:46:10 markus Exp $	*/
d133 2
d784 23
@


1.83
log
@if_detach_rtdelete(): abort and restart rn_walktree() if a cloning route
gets deleted; fixes pr 3649; ok henning, deraadt, dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.82 2004/01/15 10:47:55 markus Exp $	*/
d697 3
d711 2
a712 1
		if (*cp < '0' || *cp > '9' || unit > INT_MAX / 10) {
@


1.82
log
@add a RTM_IFANNOUNCE message; from netbsd; ok itojun, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.81 2004/01/09 10:44:32 markus Exp $	*/
d407 5
d421 7
a427 3
	if (rt->rt_ifp == ifp)
		rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway, rt_mask(rt),
		    0, NULL);
d493 3
a495 1
			(*rnh->rnh_walktree)(rnh, if_detach_rtdelete, ifp);
@


1.81
log
@fix leak ether_deatch(): if if_free_sadl() is called before if_detach()
then ifnet_addrs[ifp->if_index] leaks; if it's called after if_detach()
then if_free_sadl() does nothing; ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.80 2003/12/31 11:18:25 cedric Exp $	*/
d255 3
d579 3
@


1.80
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.79 2003/12/16 20:33:24 markus Exp $	*/
d330 1
d332 2
a333 1

a335 1
	ifnet_addrs[ifp->if_index] = NULL;
d558 4
d564 3
a566 1
	ifp->if_sadl = NULL;
@


1.79
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.78 2003/12/10 07:22:42 itojun Exp $	*/
d67 1
d114 4
d252 3
d445 4
a702 1

d705 3
@


1.78
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.77 2003/12/10 03:30:21 itojun Exp $	*/
d637 1
a637 2
	(*ifc->ifc_destroy)(ifp);
	return (0);
@


1.77
log
@use if_indexlim (instead of if_index) and ifindex2ifnet[x] != NULL
to check if interface exists, as (1) if_index will have different meaning
(2) ifindex2ifnet could become NULL when interface gets destroyed,
when we introduce dynamically-created interfaces.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.76 2003/12/08 09:09:03 markus Exp $	*/
d749 1
a749 1
	register struct sockaddr *addr;
d751 2
a752 2
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
d777 1
a777 1
	register struct sockaddr *addr;
d779 2
a780 2
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
d803 2
a804 2
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
d810 1
a810 1
		register struct sockaddr_dl *sdl = (struct sockaddr_dl *)addr;
d817 1
a817 1
			register char *cp, *cp2, *cp3;
d845 1
a845 1
	register int af;
d847 2
a848 2
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
d866 1
a866 1
	register struct ifnet *ifp;
d868 3
a870 3
	register struct ifaddr *ifa;
	register char *cp, *cp2, *cp3;
	register char *cplim;
d907 1
a907 1
	register struct rtentry *rt;
d910 1
a910 1
	register struct ifaddr *ifa;
d980 1
a980 1
	register struct ifqueue *ifq;
d982 1
a982 1
	register struct mbuf *m, *n;
d1025 1
a1025 1
	register struct ifnet *ifp;
d1044 2
a1045 2
	register struct ifnet *ifp;
	register struct ifreq *ifr;
d1245 3
a1247 3
	register struct ifconf *ifc = (struct ifconf *)data;
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
d1254 1
a1254 1
			register struct sockaddr *sa;
d1290 1
a1290 1
				register struct sockaddr *sa = ifa->ifa_addr;
@


1.76
log
@add IOCIFGCLONERS; ifconfig -C; from netbsd; ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.75 2003/12/03 13:27:36 markus Exp $	*/
d147 2
a148 1
int if_index = 0;
a162 1
	static int if_indexlim = 8;
d205 2
d810 4
a813 3
	    register struct sockaddr_dl *sdl = (struct sockaddr_dl *)addr;
	    if (sdl->sdl_index && sdl->sdl_index <= if_index)
		return (ifnet_addrs[sdl->sdl_index]);
@


1.75
log
@support for network interface "cloning", e.g. gif(4) via ifconfig(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.74 2003/12/03 11:01:43 markus Exp $	*/
d125 1
d708 34
d1062 2
@


1.74
log
@protect against if_index wrap; similar to what netbsd does; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.73 2003/11/06 21:09:34 mickey Exp $	*/
d125 5
d591 113
d985 1
a985 1
	register char *name;
d1018 11
@


1.73
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.72 2003/10/17 21:04:58 mcbride Exp $	*/
d157 1
d159 28
a186 1
	ifp->if_index = ++if_index;
d283 1
a283 1
	ifnet_addrs[if_index] = ifa;
@


1.72
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.71 2003/10/01 05:06:06 itojun Exp $	*/
a117 1
int	netisr;
@


1.71
log
@make ifindex2ifnet growing code more correct. (found by iij seil team)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.70 2003/08/27 00:33:34 henric Exp $	*/
d66 1
d109 4
d406 6
@


1.70
log
@RNF_IGNORE can corrupt the radix tree when an interface is down, it
makes routing lookups slightly more expensive, and serves no useful
purpose.

ok itojun@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.69 2003/08/25 08:18:54 fgsch Exp $	*/
d163 1
a163 1
		size_t n;
d166 1
d171 1
d176 1
a176 1
			bcopy((caddr_t)ifnet_addrs, q, n/2);
d182 1
d187 1
a187 1
			bcopy((caddr_t)ifindex2ifnet, q, n/2);
@


1.69
log
@if_init support, required by ieee80211.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.67 2003/07/23 22:48:00 itojun Exp $	*/
a110 2
int	if_mark_ignore(struct radix_node *, void *);
int	if_mark_unignore(struct radix_node *, void *);
a372 28
int
if_mark_ignore(rn, vifp)
	struct radix_node *rn;
	void *vifp;
{
	struct ifnet *ifp = vifp;
	struct rtentry *rt = (struct rtentry *)rn;

	if (rt->rt_ifp == ifp)
		rn->rn_flags |= RNF_IGNORE;

	return (0);
}

int
if_mark_unignore(rn, vifp)
	struct radix_node *rn;
	void *vifp;
{
	struct ifnet *ifp = vifp;
	struct rtentry *rt = (struct rtentry *)rn;

	if (rt->rt_ifp == ifp)
		rn->rn_flags &= ~RNF_IGNORE;

	return (0);
}

a737 2
	struct radix_node_head *rnh;
	int i;
a747 10

	/*
	 * Find and mark as ignore all routes which are using this interface.
	 * XXX Factor out into a route.c function?
	 */
	for (i = 1; i <= AF_MAX; i++) {
		rnh = rt_tables[i];
		if (rnh)
			(*rnh->rnh_walktree)(rnh, if_mark_ignore, ifp);
	}
a760 2
	struct radix_node_head *rnh;
	int i;
a775 10

	/*
	 * Find and unignore all routes which are using this interface.
	 * XXX Factor out into a route.c function?
	 */
	for (i = 1; i <= AF_MAX; i++) {
		rnh = rt_tables[i];
		if (rnh)
			(*rnh->rnh_walktree)(rnh, if_mark_unignore, ifp);
	}
@


1.68
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d120 1
d421 1
d1195 6
@


1.67
log
@remove packets in queues (like ipintrq) with m->m_pkthdr.rcvif pointing
to detached if.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.66 2003/06/02 23:28:11 millert Exp $	*/
d935 1
a935 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d954 1
a954 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d965 1
a965 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d990 1
a990 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.66
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.65 2003/05/12 00:48:52 jason Exp $	*/
d117 1
d462 42
d538 35
@


1.65
log
@Nuke a whole bunch of commons; ok tedu (still more to come *sigh*)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.64 2002/09/11 05:38:47 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.64
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.63 2002/07/03 21:19:08 miod Exp $	*/
d119 1
@


1.63
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.62 2002/06/30 13:04:35 itojun Exp $	*/
d1038 1
a1038 1
		return(0);
@


1.62
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.61 2002/06/11 04:26:17 art Exp $	*/
d143 2
@


1.61
log
@splassert(IPL_SOFTNET) where comment indicate that.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.60 2002/06/08 21:51:08 itojun Exp $	*/
d152 1
a152 4
	unsigned int socksize, ifasize;
	int namelen, masklen;
	register struct sockaddr_dl *sdl;
	register struct ifaddr *ifa;
d195 26
d223 3
a225 1
	 * create a Link Level name for this device
d227 3
d246 1
d254 1
d260 23
a282 7
#ifdef ALTQ
	ifp->if_snd.altq_type = 0;
	ifp->if_snd.altq_disc = NULL;
	ifp->if_snd.altq_flags &= ALTQF_CANTCHANGE;
	ifp->if_snd.altq_tbr  = NULL;
	ifp->if_snd.altq_ifp  = ifp;
#endif
d284 2
a285 2
	if (domains)
		if_attachdomain1(ifp);
d470 4
a473 1
	/* Deallocate private resources.  */
d484 2
@


1.60
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.59 2002/06/08 12:02:09 itojun Exp $	*/
d635 1
a635 2
if_down(ifp)
	register struct ifnet *ifp;
d637 1
a637 1
	register struct ifaddr *ifa;
d641 2
d668 1
a668 2
if_up(ifp)
	register struct ifnet *ifp;
d671 1
a671 1
	register struct ifaddr *ifa;
d675 2
@


1.59
log
@more splnet protection to dom_ifattach
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.58 2002/06/08 11:53:29 itojun Exp $	*/
d936 1
a936 1
			int s = splsoftnet();
@


1.58
log
@protect dom_ifattach by splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.57 2002/05/30 05:07:17 itojun Exp $	*/
d246 1
d248 1
d251 1
@


1.57
log
@improve nd6_setmtu(), to warn too-small MTU on SIOCSIFMTU.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.56 2002/05/29 02:51:37 itojun Exp $	*/
d256 3
d267 2
@


1.56
log
@simplify comment, sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.55 2002/05/27 13:42:16 itojun Exp $	*/
d101 1
a122 8

#ifdef INET6
/*
 * XXX: declare here to avoid to include many inet6 related files..
 * should be more generalized?
 */
extern void nd6_setmtu(struct ifnet *);
#endif 
@


1.55
log
@if_attach() gets called before domaininit().  scan all interfaces for if_afdata
initialization after domaininit().
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.54 2002/05/27 02:59:40 itojun Exp $	*/
d264 1
a264 4
	/*
	 * address family dependent data region - effective only
	 * after domaininit()
	 */
@


1.54
log
@framework to add af-dependent data structure to struct ifnet.
as discussed at bsd-api-discuss.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.53 2002/04/24 16:42:59 dhartmei Exp $	*/
d112 1
a163 1
	struct domain *dp;
d245 23
a267 1
	/* address family dependent data region */
@


1.53
log
@Initialize if_addrhooks in if_attachhead() like in if_attach(), either
one may be called.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.52 2002/04/24 00:51:51 dhartmei Exp $	*/
d80 1
d163 1
d244 8
d349 1
d415 1
d417 7
@


1.52
log
@Add hooks to struct ifnet that allow to register callbacks that will be
notified of interface address changes. ok provos@@, angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.51 2002/03/14 01:27:09 millert Exp $	*/
d251 4
@


1.51
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.50 2001/12/09 12:57:26 jason Exp $	*/
d262 4
d400 1
@


1.50
log
@Don't access the tq members directly, use the queue.h macros.  Also,
convert several of the loops to TAILQ_FOREACH.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.49 2001/06/29 22:46:05 fgsch Exp $	*/
d110 4
a113 4
void	if_attachsetup __P((struct ifnet *));
int	if_detach_rtdelete __P((struct radix_node *, void *));
int	if_mark_ignore __P((struct radix_node *, void *));
int	if_mark_unignore __P((struct radix_node *, void *));
d117 3
a119 3
void	if_detached_start __P((struct ifnet *));
int	if_detached_ioctl __P((struct ifnet *, u_long, caddr_t));
void	if_detached_watchdog __P((struct ifnet *));
d126 1
a126 1
extern void nd6_setmtu __P((struct ifnet *));
@


1.50.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.50 2001/12/09 12:57:26 jason Exp $	*/
a79 1
#include <sys/domain.h>
a99 1
#include <netinet6/nd6.h>
d110 4
a113 5
void	if_attachsetup(struct ifnet *);
void	if_attachdomain1(struct ifnet *);
int	if_detach_rtdelete(struct radix_node *, void *);
int	if_mark_ignore(struct radix_node *, void *);
int	if_mark_unignore(struct radix_node *, void *);
d117 11
a127 3
void	if_detached_start(struct ifnet *);
int	if_detached_ioctl(struct ifnet *, u_long, caddr_t);
void	if_detached_watchdog(struct ifnet *);
a241 35

	if (domains)
		if_attachdomain1(ifp);
}

void
if_attachdomain()
{
	struct ifnet *ifp;
	int s;

	s = splnet();
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
		if_attachdomain1(ifp);
	splx(s);
}

void
if_attachdomain1(ifp)
	struct ifnet *ifp;
{
	struct domain *dp;
	int s;

	s = splnet();

	/* address family dependent data region */
	bzero(ifp->if_afdata, sizeof(ifp->if_afdata));
	for (dp = domains; dp; dp = dp->dom_next) {
		if (dp->dom_ifattach)
			ifp->if_afdata[dp->dom_family] =
			    (*dp->dom_ifattach)(ifp);
	}

	splx(s);
a250 4
	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks), M_TEMP, M_NOWAIT);
	if (ifp->if_addrhooks == NULL)
		panic("if_attachhead: malloc");
	TAILQ_INIT(ifp->if_addrhooks);
a261 4
	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks), M_TEMP, M_NOWAIT);
	if (ifp->if_addrhooks == NULL)
		panic("if_attach: malloc");
	TAILQ_INIT(ifp->if_addrhooks);
a330 1
	struct domain *dp;
a395 9

	free(ifp->if_addrhooks, M_TEMP);

	for (dp = domains; dp; dp = dp->dom_next) {
		if (dp->dom_ifdetach && ifp->if_afdata[dp->dom_family])
			(*dp->dom_ifdetach)(ifp,
			    ifp->if_afdata[dp->dom_family]);
	}

d888 1
a888 1
			int s = splnet();
@


1.50.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.50.2.1 2002/06/11 03:30:45 art Exp $	*/
a142 2
struct ifnet_head ifnet;
struct ifnet *lo0ifp;
d152 4
a155 1
	struct ifaddr *ifa;
a197 26
#ifdef ALTQ
	ifp->if_snd.altq_type = 0;
	ifp->if_snd.altq_disc = NULL;
	ifp->if_snd.altq_flags &= ALTQF_CANTCHANGE;
	ifp->if_snd.altq_tbr  = NULL;
	ifp->if_snd.altq_ifp  = ifp;
#endif

	if (domains)
		if_attachdomain1(ifp);
}

/*
 * Allocate the link level name for the specified interface.  This
 * is an attachment helper.  It must be called after ifp->if_addrlen
 * is initialized, which may not be the case when if_attach() is
 * called.
 */
void
if_alloc_sadl(ifp)
	struct ifnet *ifp;
{
	unsigned socksize, ifasize;
	int namelen, masklen;
	struct sockaddr_dl *sdl;
	struct ifaddr *ifa;
d200 1
a200 3
	 * If the interface already has a link name, release it
	 * now.  This is useful for interfaces that can change
	 * link types, and thus switch link names often.
a201 3
	if (ifp->if_sadl != NULL)
		if_free_sadl(ifp);

a217 1
	sdl->sdl_alen = ifp->if_addrlen;
a224 1
	ifp->if_sadl = sdl;
d230 7
a236 1
}
d238 2
a239 24
/*
 * Free the link level name for the specified interface.  This is
 * a detach helper.  This is called from if_detach() or from
 * link layer type specific detach functions.
 */
void
if_free_sadl(ifp)
	struct ifnet *ifp;
{
	struct ifaddr *ifa;
	int s;

	ifa = ifnet_addrs[ifp->if_index];
	if (ifa == NULL)
		return;

	s = splnet();
	rtinit(ifa, RTM_DELETE, 0);
	TAILQ_REMOVE(&ifp->if_addrlist, ifa, ifa_list);

	ifp->if_sadl = NULL;

	ifnet_addrs[ifp->if_index] = NULL;
	splx(s);
d424 1
a424 4
	/*
	 * Deallocate private resources.
	 * XXX should consult refcnt and use IFAFREE
	 */
a434 2
	ifp->if_sadl = NULL;
	ifnet_addrs[ifp->if_index] = NULL;
d635 2
a636 1
if_down(struct ifnet *ifp)
d638 1
a638 1
	struct ifaddr *ifa;
a641 2
	splassert(IPL_SOFTNET);

d667 2
a668 1
if_up(struct ifnet *ifp)
d671 1
a671 1
	struct ifaddr *ifa;
a675 2
	splassert(IPL_SOFTNET);

d983 1
a983 1
		return (0);
@


1.50.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a118 1
int	netisr;
@


1.49
log
@Move ifq_maxlen setting to if_attach(). Doing it at if_init() is wrong,
and has been wrong since PnP devices (pcmcia, carbus, etc) shown up.
If you forgot to set ifq_maxlen somewhere in the driver, you're gonna
see baaaad things; jason@@ ok, angelos@@ "should be ok" , theo
"don't understand why".
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.48 2001/06/27 05:50:06 kjc Exp $	*/
d412 2
a413 2
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
	    for (ifa = ifp->if_addrlist.tqh_first; ifa != 0; ifa = ifa->ifa_list.tqe_next) {
d423 1
d438 1
a438 1
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
d440 1
a440 1
		for (ifa = ifp->if_addrlist.tqh_first; ifa != 0; ifa = ifa->ifa_list.tqe_next) {
d446 1
d470 2
a471 2
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
		for (ifa = ifp->if_addrlist.tqh_first; ifa != 0; ifa = ifa->ifa_list.tqe_next) {
d491 1
d505 2
a506 2
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
		for (ifa = ifp->if_addrlist.tqh_first; ifa != 0; ifa = ifa->ifa_list.tqe_next)
d509 2
d531 1
a531 1
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0; ifa = ifa->ifa_list.tqe_next) {
d596 1
a596 1
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0; ifa = ifa->ifa_list.tqe_next)
d598 1
d632 1
a632 2
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	    ifa = ifa->ifa_list.tqe_next)
d634 1
d684 1
a684 1
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next) {
d704 1
a704 1
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
d707 1
a707 1

d917 1
a917 1
		for (ifp = ifnet.tqh_first; ifp; ifp = ifp->if_list.tqe_next) {
d920 1
a920 1
			if ((ifa = ifp->if_addrlist.tqh_first) == 0)
d923 1
a923 1
				for (; ifa != 0; ifa = ifa->ifa_list.tqe_next) {
d939 2
a940 2
	for (ifp = ifnet.tqh_first; space >= sizeof (ifr) && ifp != 0;
	    ifp = ifp->if_list.tqe_next) {
d942 1
a942 1
		if ((ifa = ifp->if_addrlist.tqh_first) == 0) {
d950 4
a953 2
			for (; space >= sizeof (ifr) && ifa != 0;
			    ifa = ifa->ifa_list.tqe_next) {
@


1.48
log
@ALTQ base modifications to the kernel.
 - ALTQ introduces a set of new queue macros that coexist with the
   traditional IF_XXX macros.
 - "struct ifaltq" replaces "struct ifqueue" in "struct ifnet".
 - assign cdev major 74 for i386 and 54 for alpha as ALTQ control interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.47 2001/06/22 14:28:58 deraadt Exp $	*/
a137 1
	struct ifnet *ifp;
a139 4
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
		if (ifp->if_snd.ifq_maxlen == 0)
			ifp->if_snd.ifq_maxlen = ifqmaxlen;

d200 3
@


1.47
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.46 2001/06/15 03:38:33 itojun Exp $	*/
d237 7
d350 6
d595 1
a595 1
	if_qflush(&ifp->if_snd);
@


1.46
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.45 2001/06/08 04:19:25 angelos Exp $	*/
d616 1
a616 1
	     ifa = ifa->ifa_list.tqe_next)
@


1.45
log
@Move ifpromisc() from bpf.c to if.c, include cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.44 2001/05/30 02:12:24 deraadt Exp $	*/
d579 1
d612 1
@


1.44
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.43 2001/02/20 13:50:53 itojun Exp $	*/
d72 1
a73 1
#include <sys/systm.h>
a82 3
#include <net/if_types.h>
#include <net/radix.h>

a99 1
#include <netinet6/in6_var.h>
d1000 40
@


1.43
log
@provide SIOC[SG]LIFPHYADDR, which greatly simplify userland manipulation.
sync with kame.  old ioctls are kept but not really recommended.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.42 2001/02/13 19:49:32 art Exp $	*/
a105 6
#ifdef IPFILTER
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_nat.h>
#endif

a376 5

#ifdef IPFILTER
	/* XXX More ipf & ipnat cleanup needed.  */
	nat_clearlist();
#endif
@


1.42
log
@When detaching an interface set the if_start, if_ioctl and if_watchdog
functions to 'nops'.

Some protocols might want to output some packets while detaching and
that could be a bad idea when the interface has gone away.
Do we need to change more functions?
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.41 2001/01/30 04:22:24 kjell Exp $	*/
d800 1
d804 1
d813 1
d1015 1
a1015 1
}@


1.41
log
@change ip_compat.h to ip_fil_compat.h for clarity. Impending ipf merge
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.40 2001/01/19 06:37:36 itojun Exp $	*/
d127 4
d337 5
d983 30
@


1.40
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.39 2001/01/17 04:47:18 fgsch Exp $	*/
d107 1
a107 1
#include <netinet/ip_compat.h>
@


1.39
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.38 2000/10/07 03:43:16 itojun Exp $	*/
d550 1
a550 1
link_rtrequest(cmd, rt, sa)
d553 1
a553 1
	struct sockaddr *sa;
d567 1
a567 1
			ifa->ifa_rtrequest(cmd, rt, sa);
@


1.38
log
@repair SIOCGIFP*ADDR.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.37 2000/10/05 02:12:51 itojun Exp $	*/
d107 1
a107 1
#include <netinet/ip_fil_compat.h>
d377 1
a377 1
	nat_ifdetach(ifp);
@


1.37
log
@there is no SIOCDIFPHYADDR in openbsd-current yet (in kame, there is)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.36 2000/10/04 23:17:27 itojun Exp $	*/
d800 2
@


1.36
log
@make sure we have root priv on SIOCSIFPHY*.  from thorpej@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.35 2000/06/20 06:49:04 art Exp $	*/
a790 1
	case SIOCDIFPHYADDR:
@


1.35
log
@Convert if_slowtimo to use new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.34 2000/06/18 00:14:27 deraadt Exp $	*/
d103 1
d790 5
@


1.34
log
@increase my commit count by 1, because after telling niels three times that he has an indentation flaw, he has not fixed it, so i get a commit, thanks niels
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.33 2000/06/17 20:36:36 provos Exp $	*/
a124 1
void	if_slowtimo __P((void *arg));
d143 2
a144 1
	register struct ifnet *ifp;
d149 4
a152 1
	if_slowtimo(NULL);
d666 2
a667 1
	register struct ifnet *ifp;
d677 1
a677 1
	timeout(if_slowtimo, NULL, hz / IFNET_SLOWHZ);
@


1.33
log
@fix comments
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.32 2000/06/17 20:30:34 provos Exp $	*/
d296 1
a296 1
	  rn->rn_flags |= RNF_IGNORE;
d310 1
a310 1
	  rn->rn_flags &= ~RNF_IGNORE;
d842 2
a843 3
						    (struct mbuf *) cmd,
						    (struct mbuf *) data,
						    (struct mbuf *) ifp));
@


1.32
log
@on ifconfig down ignore all routes pointing to the downed interface.
okay itojun@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.31 2000/05/05 07:58:15 itojun Exp $	*/
d587 1
a587 1
	 * Find and remove all routes which is using this interface.
d625 1
a625 1
	 * Find and remove all routes which is using this interface.
@


1.31
log
@cope with interface detach (like pcmcia card removal).  remove any
IPv6 addresses assigned to the interface.  reported by ho, bunch of
help from niklas.   KAME PR 231.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.30 2000/03/22 11:28:42 itojun Exp $	*/
d121 2
d287 28
d577 2
d585 10
d609 2
d623 10
@


1.31.2.1
log
@Pull in patches from current:
Fixes (itojun):
- make sure we have root priv on SIOCSIFPHY*.  from thorpej@@netbsd
- there is no SIOCDIFPHYADDR in openbsd-current yet (in kame, there is)
- repair SIOCGIFP*ADDR.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.38 2000/10/07 03:43:16 itojun Exp $	*/
a102 1
#include <netinet6/in6_var.h>
a730 4
	case SIOCSIFPHYADDR:
#ifdef INET6
	case SIOCSIFPHYADDR_IN6:
#endif
a736 2
	case SIOCGIFPSRCADDR:
	case SIOCGIFPDSTADDR:
@


1.30
log
@remove if_withname(), which was imported during KAME merge by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.29 2000/03/21 23:31:26 mickey Exp $	*/
d102 1
d329 3
@


1.29
log
@add SIOCGIFMTU/SIOCSIFMTU; remediate redundant code of tun, ppp, sppp; chris@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.28 2000/03/12 03:54:43 itojun Exp $	*/
a633 29


/*
 * Map interface name in a sockaddr_dl to
 * interface structure pointer.
 */
struct ifnet *
if_withname(sa)
	struct sockaddr *sa;
{
	char ifname[IFNAMSIZ+1];
	struct sockaddr_dl *sdl = (struct sockaddr_dl *)sa;

	if ( (sa->sa_family != AF_LINK) || (sdl->sdl_nlen == 0) ||
	     (sdl->sdl_nlen > IFNAMSIZ) )
		return NULL;

	/*
	 * ifunit wants a null-terminated name.  It may not be null-terminated
	 * in the sockaddr.  We don't want to change the caller's sockaddr,
	 * and there might not be room to put the trailing null anyway, so we
	 * make a local copy that we know we can null terminate safely.
	 */

	bcopy(sdl->sdl_data, ifname, sdl->sdl_nlen);
	ifname[sdl->sdl_nlen] = '\0';
	return ifunit(ifname);
}

@


1.28
log
@remove redundant check against ifa_dstaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.27 2000/01/02 05:28:24 deraadt Exp $	*/
d700 4
d733 22
@


1.27
log
@do in6_if_up() at splsoftnet() instead of splimp(), permitting device-related interrupts during that time.  It is believed this is safe
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.26 1999/12/18 22:03:43 angelos Exp $	*/
a371 2
			continue;
		if (ifa->ifa_dstaddr == NULL)
@


1.27.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d373 2
d637 29
a701 4
	case SIOCGIFMTU:
		ifr->ifr_mtu = ifp->if_mtu;
		break;

a730 22

	case SIOCSIFMTU:
	{
#ifdef INET6
		int oldmtu = ifp->if_mtu;
#endif

		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
			return (error);
		if (ifp->if_ioctl == NULL)
			return (EOPNOTSUPP);
		error = (*ifp->if_ioctl)(ifp, cmd, data);

		/*
		 * If the link MTU changed, do network layer specific procedure.
		 */
#ifdef INET6
		if (ifp->if_mtu != oldmtu)
			nd6_setmtu(ifp);
#endif
		break;
	}
@


1.27.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.43 2001/02/20 13:50:53 itojun Exp $	*/
a101 2
#include <netinet6/in6_ifattach.h>
#include <netinet6/in6_var.h>
a119 2
int	if_mark_ignore __P((struct radix_node *, void *));
int	if_mark_unignore __P((struct radix_node *, void *));
d122 1
a122 4

void	if_detached_start __P((struct ifnet *));
int	if_detached_ioctl __P((struct ifnet *, u_long, caddr_t));
void	if_detached_watchdog __P((struct ifnet *));
d141 1
a141 2
	struct ifnet *ifp;
	static struct timeout if_slowtim;
d146 1
a146 4

	timeout_set(&if_slowtim, if_slowtimo, &if_slowtim);

	if_slowtimo(&if_slowtim);
a283 28
int
if_mark_ignore(rn, vifp)
	struct radix_node *rn;
	void *vifp;
{
	struct ifnet *ifp = vifp;
	struct rtentry *rt = (struct rtentry *)rn;

	if (rt->rt_ifp == ifp)
		rn->rn_flags |= RNF_IGNORE;

	return (0);
}

int
if_mark_unignore(rn, vifp)
	struct radix_node *rn;
	void *vifp;
{
	struct ifnet *ifp = vifp;
	struct rtentry *rt = (struct rtentry *)rn;

	if (rt->rt_ifp == ifp)
		rn->rn_flags &= ~RNF_IGNORE;

	return (0);
}

a297 5
	ifp->if_flags &= ~IFF_OACTIVE;
	ifp->if_start = if_detached_start;
	ifp->if_ioctl = if_detached_ioctl;
	ifp->if_watchdog = if_detached_watchdog;

a328 3
#ifdef INET6
	in6_ifdetach(ifp);
#endif
d339 1
a339 1
	nat_clearlist();
d512 1
a512 1
link_rtrequest(cmd, rt, info)
d515 1
a515 1
	struct rt_addrinfo *info;
d529 1
a529 1
			ifa->ifa_rtrequest(cmd, rt, info);
a542 2
	struct radix_node_head *rnh;
	int i;
a548 10

	/*
	 * Find and mark as ignore all routes which are using this interface.
	 * XXX Factor out into a route.c function?
	 */
	for (i = 1; i <= AF_MAX; i++) {
		rnh = rt_tables[i];
		if (rnh)
			(*rnh->rnh_walktree)(rnh, if_mark_ignore, ifp);
	}
a562 2
	struct radix_node_head *rnh;
	int i;
a574 10

	/*
	 * Find and unignore all routes which are using this interface.
	 * XXX Factor out into a route.c function?
	 */
	for (i = 1; i <= AF_MAX; i++) {
		rnh = rt_tables[i];
		if (rnh)
			(*rnh->rnh_walktree)(rnh, if_mark_unignore, ifp);
	}
d605 1
a605 2
	struct timeout *to = (struct timeout *)arg;
	struct ifnet *ifp;
d615 1
a615 1
	timeout_add(to, hz / IFNET_SLOWHZ);
a726 6
	case SIOCSIFPHYADDR:
	case SIOCDIFPHYADDR:
#ifdef INET6
	case SIOCSIFPHYADDR_IN6:
#endif
	case SIOCSLIFPHYADDR:
a732 3
	case SIOCGIFPSRCADDR:
	case SIOCGIFPDSTADDR:
	case SIOCGLIFPHYADDR:
d784 3
a786 2
		    (struct mbuf *) cmd, (struct mbuf *) data,
		    (struct mbuf *) ifp));
a904 30
}

/*
 * Dummy functions replaced in ifnet during detach (if protocols decide to
 * fiddle with the if during detach.
 */
void
if_detached_start(struct ifnet *ifp)
{
	struct mbuf *m;

	while (1) {
		IF_DEQUEUE(&ifp->if_snd, m);

		if (m == NULL)
			return;
		m_freem(m);
	}
}

int
if_detached_ioctl(struct ifnet *ifp, u_long a, caddr_t b)
{
	return ENODEV;
}

void
if_detached_watchdog(struct ifnet *ifp)
{
	/* nothing */
@


1.27.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.27.2.2 2001/05/14 22:39:59 niklas Exp $	*/
d72 1
a73 1
#include <sys/mbuf.h>
d83 3
d103 7
d148 1
d151 4
a215 3
	if (ifp->if_snd.ifq_maxlen == 0)
		ifp->if_snd.ifq_maxlen = ifqmaxlen;

a246 7
#ifdef ALTQ
	ifp->if_snd.altq_type = 0;
	ifp->if_snd.altq_disc = NULL;
	ifp->if_snd.altq_flags &= ALTQF_CANTCHANGE;
	ifp->if_snd.altq_tbr  = NULL;
	ifp->if_snd.altq_ifp  = ifp;
#endif
a352 6
#ifdef ALTQ
	if (ALTQ_IS_ENABLED(&ifp->if_snd))
		altq_disable(&ifp->if_snd);
	if (ALTQ_IS_ATTACHED(&ifp->if_snd))
		altq_detach(&ifp->if_snd);
#endif
d384 5
a593 1
	microtime(&ifp->if_lastchange);
d596 1
a596 1
	IFQ_PURGE(&ifp->if_snd);
a625 1
	microtime(&ifp->if_lastchange);
d629 1
a629 1
	    ifa = ifa->ifa_list.tqe_next)
a1014 40
}

/*
 * Set/clear promiscuous mode on interface ifp based on the truth value
 * of pswitch.  The calls are reference counted so that only the first
 * "on" request actually has an effect, as does the final "off" request.
 * Results are undefined if the "off" and "on" requests are not matched.
 */
int
ifpromisc(ifp, pswitch)
	struct ifnet *ifp;
	int pswitch;
{
	struct ifreq ifr;

	if (pswitch) {
		/*
		 * If the device is not configured up, we cannot put it in
		 * promiscuous mode.
		 */
		if ((ifp->if_flags & IFF_UP) == 0)
			return (ENETDOWN);
		if (ifp->if_pcount++ != 0)
			return (0);
		ifp->if_flags |= IFF_PROMISC;
	} else {
		if (--ifp->if_pcount > 0)
			return (0);
		ifp->if_flags &= ~IFF_PROMISC;
		/*
		 * If the device is not configured up, we should not need to
		 * turn off promiscuous mode (device should have turned it
		 * off when interface went down; and will look at IFF_PROMISC
		 * again next time interface comes up).
		 */
		if ((ifp->if_flags & IFF_UP) == 0)
			return (0);
	}
	ifr.ifr_flags = ifp->if_flags;
	return ((*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifr));
@


1.27.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d412 2
a413 2
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
	    TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a422 1
	    }
d437 1
a437 1
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
d439 1
a439 1
	        TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a444 1
		}
d468 2
a469 2
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a488 1
	}
d502 2
a503 2
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a505 2
		}
	}
d526 1
a526 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
d591 1
a591 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a592 1
	}
d626 2
a627 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a628 1
	}
d678 1
a678 1
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
d698 1
a698 1
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
d701 1
a701 1
	}
d911 1
a911 1
		TAILQ_FOREACH(ifp, &ifnet, if_list) {
d914 1
a914 1
			if (TAILQ_EMPTY(&ifp->if_addrlist))
d917 1
a917 1
				TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
d933 2
a934 2
	for (ifp = TAILQ_FIRST(&ifnet); space >= sizeof(ifr) &&
	    ifp != TAILQ_END(&ifnet); ifp = TAILQ_NEXT(ifp, if_list)) {
d936 1
a936 1
		if (TAILQ_EMPTY(&ifp->if_addrlist)) {
d944 2
a945 4
			for (ifa = TAILQ_FIRST(&ifp->if_addrlist);
			    space >= sizeof (ifr) &&
			    ifa != TAILQ_END(&ifp->if_addrlist);
			    ifa = TAILQ_NEXT(ifa, ifa_list)) {
@


1.27.2.5
log
@Merge in -current from roughly a week ago
@
text
@d110 4
a113 4
void	if_attachsetup(struct ifnet *);
int	if_detach_rtdelete(struct radix_node *, void *);
int	if_mark_ignore(struct radix_node *, void *);
int	if_mark_unignore(struct radix_node *, void *);
d117 3
a119 3
void	if_detached_start(struct ifnet *);
int	if_detached_ioctl(struct ifnet *, u_long, caddr_t);
void	if_detached_watchdog(struct ifnet *);
d126 1
a126 1
extern void nd6_setmtu(struct ifnet *);
@


1.27.2.6
log
@Sync the SMP branch with 3.3
@
text
@a79 1
#include <sys/domain.h>
a99 1
#include <netinet6/nd6.h>
a110 1
void	if_attachdomain1(struct ifnet *);
d121 8
a147 2
struct ifnet_head ifnet;
struct ifnet *lo0ifp;
d157 4
a160 1
	struct ifaddr *ifa;
a202 26
#ifdef ALTQ
	ifp->if_snd.altq_type = 0;
	ifp->if_snd.altq_disc = NULL;
	ifp->if_snd.altq_flags &= ALTQF_CANTCHANGE;
	ifp->if_snd.altq_tbr  = NULL;
	ifp->if_snd.altq_ifp  = ifp;
#endif

	if (domains)
		if_attachdomain1(ifp);
}

/*
 * Allocate the link level name for the specified interface.  This
 * is an attachment helper.  It must be called after ifp->if_addrlen
 * is initialized, which may not be the case when if_attach() is
 * called.
 */
void
if_alloc_sadl(ifp)
	struct ifnet *ifp;
{
	unsigned socksize, ifasize;
	int namelen, masklen;
	struct sockaddr_dl *sdl;
	struct ifaddr *ifa;
d205 1
a205 3
	 * If the interface already has a link name, release it
	 * now.  This is useful for interfaces that can change
	 * link types, and thus switch link names often.
a206 3
	if (ifp->if_sadl != NULL)
		if_free_sadl(ifp);

a222 1
	sdl->sdl_alen = ifp->if_addrlen;
a229 1
	ifp->if_sadl = sdl;
d235 7
a241 58
}

/*
 * Free the link level name for the specified interface.  This is
 * a detach helper.  This is called from if_detach() or from
 * link layer type specific detach functions.
 */
void
if_free_sadl(ifp)
	struct ifnet *ifp;
{
	struct ifaddr *ifa;
	int s;

	ifa = ifnet_addrs[ifp->if_index];
	if (ifa == NULL)
		return;

	s = splnet();
	rtinit(ifa, RTM_DELETE, 0);
	TAILQ_REMOVE(&ifp->if_addrlist, ifa, ifa_list);

	ifp->if_sadl = NULL;

	ifnet_addrs[ifp->if_index] = NULL;
	splx(s);
}

void
if_attachdomain()
{
	struct ifnet *ifp;
	int s;

	s = splnet();
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
		if_attachdomain1(ifp);
	splx(s);
}

void
if_attachdomain1(ifp)
	struct ifnet *ifp;
{
	struct domain *dp;
	int s;

	s = splnet();

	/* address family dependent data region */
	bzero(ifp->if_afdata, sizeof(ifp->if_afdata));
	for (dp = domains; dp; dp = dp->dom_next) {
		if (dp->dom_ifattach)
			ifp->if_afdata[dp->dom_family] =
			    (*dp->dom_ifattach)(ifp);
	}

	splx(s);
a250 4
	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks), M_TEMP, M_NOWAIT);
	if (ifp->if_addrhooks == NULL)
		panic("if_attachhead: malloc");
	TAILQ_INIT(ifp->if_addrhooks);
a261 4
	ifp->if_addrhooks = malloc(sizeof(*ifp->if_addrhooks), M_TEMP, M_NOWAIT);
	if (ifp->if_addrhooks == NULL)
		panic("if_attach: malloc");
	TAILQ_INIT(ifp->if_addrhooks);
a330 1
	struct domain *dp;
d385 1
a385 4
	/*
	 * Deallocate private resources.
	 * XXX should consult refcnt and use IFAFREE
	 */
a395 11
	ifp->if_sadl = NULL;
	ifnet_addrs[ifp->if_index] = NULL;

	free(ifp->if_addrhooks, M_TEMP);

	for (dp = domains; dp; dp = dp->dom_next) {
		if (dp->dom_ifdetach && ifp->if_afdata[dp->dom_family])
			(*dp->dom_ifdetach)(ifp,
			    ifp->if_afdata[dp->dom_family]);
	}

d587 2
a588 1
if_down(struct ifnet *ifp)
d590 1
a590 1
	struct ifaddr *ifa;
a593 2
	splassert(IPL_SOFTNET);

d619 2
a620 1
if_up(struct ifnet *ifp)
d623 1
a623 1
	struct ifaddr *ifa;
a627 2
	splassert(IPL_SOFTNET);

d888 1
a888 1
			int s = splnet();
d935 1
a935 1
		return (0);
@


1.27.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.27.2.6 2003/03/28 00:41:28 niklas Exp $	*/
a118 1
int	netisr;
@


1.27.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.27.2.7 2003/05/13 19:36:14 ho Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.27.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a65 2
#include "carp.h"
#include "pf.h"
a107 8
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#endif

d111 2
d115 1
a116 1
void	if_detach_queues(struct ifnet *, struct ifqueue *);
a118 1
int	if_detached_init(struct ifnet *);
a120 6
int	if_clone_list(struct if_clonereq *);
struct if_clone	*if_clone_lookup(const char *, int *);

LIST_HEAD(, if_clone) if_cloners = LIST_HEAD_INITIALIZER(if_cloners);
int if_cloners_count;

d137 1
a137 2
static int if_index = 0;
int if_indexlim = 0;
d152 1
a152 1
	int wrapped = 0;
d154 1
a154 28
	if (ifindex2ifnet == 0)
		if_index = 1;
	else {
		while (if_index < if_indexlim &&
		    ifindex2ifnet[if_index] != NULL) {
			if_index++;
			/*
			 * If we hit USHRT_MAX, we skip back to 1 since
			 * there are a number of places where the value
			 * of ifp->if_index or if_index itself is compared
			 * to or stored in an unsigned short.  By
			 * jumping back, we won't botch those assignments
			 * or comparisons.
			 */
			if (if_index == USHRT_MAX) {
				if_index = 1;
				/*
				 * However, if we have to jump back to 1
				 * *twice* without finding an empty
				 * slot in ifindex2ifnet[], then there
				 * there are too many (>65535) interfaces.
				 */
				if (wrapped++)
					panic("too many interfaces");
			}
		}
	}
	ifp->if_index = if_index;
d163 1
a163 1
		size_t m, n, oldlim;
a165 3
		oldlim = if_indexlim;
		if (if_indexlim == 0)
			if_indexlim = 8;
a169 1
		m = oldlim * sizeof(ifa);
d174 1
a174 1
			bcopy((caddr_t)ifnet_addrs, q, m);
a179 1
		m = oldlim * sizeof(struct ifnet *);
d184 1
a184 1
			bcopy((caddr_t)ifindex2ifnet, q, m);
a203 6
#if NPF > 0
	pfi_attach_ifnet(ifp);
#endif

	/* Announce the interface. */
	rt_ifannouncemsg(ifp, IFAN_ARRIVAL);
d248 1
a248 1
	ifnet_addrs[ifp->if_index] = ifa;
a278 1
#if 0
d280 1
a280 2
	ifnet_addrs[ifp->if_index] = NULL;
#endif
d283 1
d373 28
a418 1
	ifp->if_init = if_detached_init;
a420 4
#if NPF > 0
	pfi_detach_ifnet(ifp);
#endif

a426 6
#if NCARP > 0
	/* Remove the interface from any carp group it is a part of.  */
	if (ifp->if_carp)
		carp_ifdetach(ifp);
#endif

a460 42

	/*
	 * remove packets came from ifp, from software interrupt queues.
	 * net/netisr_dispatch.h is not usable, as some of them use
	 * strange queue names.
	 */
#define IF_DETACH_QUEUES(x) \
do { \
	extern struct ifqueue x; \
	if_detach_queues(ifp, & x); \
} while (0)
#ifdef INET
	IF_DETACH_QUEUES(arpintrq);
	IF_DETACH_QUEUES(ipintrq);
#endif
#ifdef INET6
	IF_DETACH_QUEUES(ip6intrq);
#endif
#ifdef IPX
	IF_DETACH_QUEUES(ipxintrq);
#endif
#ifdef NS
	IF_DETACH_QUEUES(nsintrq);
#endif
#ifdef NETATALK
	IF_DETACH_QUEUES(atintrq1);
	IF_DETACH_QUEUES(atintrq2);
#endif
#ifdef ISO
	IF_DETACH_QUEUES(clnlintrq);
#endif
#ifdef CCITT
	IF_DETACH_QUEUES(llcintrq);
#endif
#ifdef NATM
	IF_DETACH_QUEUES(natmintrq);
#endif
#ifdef DECNET
	IF_DETACH_QUEUES(decnetintrq);
#endif
#undef IF_DETACH_QUEUES

a480 4
		/* XXX if_free_sadl needs this */
		if (ifa == ifnet_addrs[ifp->if_index])
			continue;

d483 1
a483 3
	if_free_sadl(ifp);

	free(ifnet_addrs[ifp->if_index], M_IFADDR);
a493 3
	/* Announce that the interface is gone. */
	rt_ifannouncemsg(ifp, IFAN_DEPARTURE);

a496 183
void
if_detach_queues(ifp, q)
	struct ifnet *ifp;
	struct ifqueue *q;
{
	struct mbuf *m, *prev, *next;

	prev = NULL;
	for (m = q->ifq_head; m; m = next) {
		next = m->m_nextpkt;
#ifdef DIAGNOSTIC
		if ((m->m_flags & M_PKTHDR) == 0) {
			prev = m;
			continue;
		}
#endif
		if (m->m_pkthdr.rcvif != ifp) {
			prev = m;
			continue;
		}

		if (prev)
			prev->m_nextpkt = m->m_nextpkt;
		else
			q->ifq_head = m->m_nextpkt;
		if (q->ifq_tail == m)
			q->ifq_tail = prev;
		q->ifq_len--;

		m->m_nextpkt = NULL;
		m_freem(m);
		IF_DROP(q);
	}
} 

/*
 * Create a clone network interface.
 */
int
if_clone_create(name)
	const char *name;
{
	struct if_clone *ifc;
	int unit;

	ifc = if_clone_lookup(name, &unit);
	if (ifc == NULL)
		return (EINVAL);

	if (ifunit(name) != NULL)
		return (EEXIST);

	return ((*ifc->ifc_create)(ifc, unit));
}

/*
 * Destroy a clone network interface.
 */
int
if_clone_destroy(name)
	const char *name;
{
	struct if_clone *ifc;
	struct ifnet *ifp;

	ifc = if_clone_lookup(name, NULL);
	if (ifc == NULL)
		return (EINVAL);

	ifp = ifunit(name);
	if (ifp == NULL)
		return (ENXIO);

	if (ifc->ifc_destroy == NULL)
		return (EOPNOTSUPP);

	return ((*ifc->ifc_destroy)(ifp));
}

/*
 * Look up a network interface cloner.
 */
struct if_clone *
if_clone_lookup(name, unitp)
	const char *name;
	int *unitp;
{
	struct if_clone *ifc;
	const char *cp;
	int unit;

	/* separate interface name from unit */
	for (cp = name;
	    cp - name < IFNAMSIZ && *cp && (*cp < '0' || *cp > '9');
	    cp++)
		continue;

	if (cp == name || cp - name == IFNAMSIZ || !*cp)
		return (NULL);	/* No name or unit number */

	LIST_FOREACH(ifc, &if_cloners, ifc_list) {
		if (strlen(ifc->ifc_name) == cp - name &&
		    !strncmp(name, ifc->ifc_name, cp - name))
			break;
	}

	if (ifc == NULL)
		return (NULL);

	unit = 0;
	while (cp - name < IFNAMSIZ && *cp) {
		if (*cp < '0' || *cp > '9' || unit > INT_MAX / 10) {
			/* Bogus unit number. */
			return (NULL);
		}
		unit = (unit * 10) + (*cp++ - '0');
	}

	if (unitp != NULL)
		*unitp = unit;
	return (ifc);
}

/*
 * Register a network interface cloner.
 */
void
if_clone_attach(ifc)
	struct if_clone *ifc;
{
	LIST_INSERT_HEAD(&if_cloners, ifc, ifc_list);
	if_cloners_count++;
#if NPF > 0
	pfi_attach_clone(ifc);
#endif
}

/*
 * Unregister a network interface cloner.
 */
void
if_clone_detach(ifc)
	struct if_clone *ifc;
{

	LIST_REMOVE(ifc, ifc_list);
	if_cloners_count--;
}

/*
 * Provide list of interface cloners to userspace.
 */
int
if_clone_list(ifcr)
	struct if_clonereq *ifcr;
{
	char outbuf[IFNAMSIZ], *dst;
	struct if_clone *ifc;
	int count, error = 0;

	ifcr->ifcr_total = if_cloners_count;
	if ((dst = ifcr->ifcr_buffer) == NULL) {
		/* Just asking how many there are. */
		return (0);
	}

	if (ifcr->ifcr_count < 0)
		return (EINVAL);

	count = (if_cloners_count < ifcr->ifcr_count) ?
	    if_cloners_count : ifcr->ifcr_count;

	for (ifc = LIST_FIRST(&if_cloners); ifc != NULL && count != 0;
	     ifc = LIST_NEXT(ifc, ifc_list), count--, dst += IFNAMSIZ) {
		strlcpy(outbuf, ifc->ifc_name, IFNAMSIZ);
		error = copyout(outbuf, dst, IFNAMSIZ);
		if (error)
			break;
	}

	return (error);
}

d503 1
a503 1
	struct sockaddr *addr;
d505 2
a506 2
	struct ifnet *ifp;
	struct ifaddr *ifa;
d531 1
a531 1
	struct sockaddr *addr;
d533 2
a534 2
	struct ifnet *ifp;
	struct ifaddr *ifa;
d557 2
a558 2
	struct ifnet *ifp;
	struct ifaddr *ifa;
d564 3
a566 4
		struct sockaddr_dl *sdl = (struct sockaddr_dl *)addr;
		if (sdl->sdl_index && sdl->sdl_index < if_indexlim &&
		    ifindex2ifnet[sdl->sdl_index])
			return (ifnet_addrs[sdl->sdl_index]);
d570 1
a570 1
			char *cp, *cp2, *cp3;
d598 1
a598 1
	int af;
d600 2
a601 2
	struct ifnet *ifp;
	struct ifaddr *ifa;
d619 1
a619 1
	struct ifnet *ifp;
d621 3
a623 3
	struct ifaddr *ifa;
	char *cp, *cp2, *cp3;
	char *cplim;
d660 1
a660 1
	struct rtentry *rt;
d663 1
a663 1
	struct ifaddr *ifa;
d688 2
d700 10
d723 2
d740 10
d757 1
a757 1
	struct ifqueue *ifq;
d759 1
a759 1
	struct mbuf *m, *n;
d800 1
a800 1
	const char *name;
d802 1
a802 1
	struct ifnet *ifp;
d821 2
a822 2
	struct ifnet *ifp;
	struct ifreq *ifr;
a832 13

	switch (cmd) {
	case SIOCIFCREATE:
	case SIOCIFDESTROY:
		if ((error = suser(p, 0)) != 0)
			return (error);
		return ((cmd == SIOCIFCREATE) ?
			if_clone_create(ifr->ifr_name) :
			if_clone_destroy(ifr->ifr_name));
	case SIOCIFGCLONERS:
		return (if_clone_list((struct if_clonereq *)data));
	}

d857 1
a857 1
		if ((error = suser(p, 0)) != 0)
d876 1
a876 1
		if ((error = suser(p, 0)) != 0)
d887 1
a887 1
		if ((error = suser(p, 0)) != 0)
d912 1
a912 1
		if ((error = suser(p, 0)) != 0)
d1009 3
a1011 3
	struct ifconf *ifc = (struct ifconf *)data;
	struct ifnet *ifp;
	struct ifaddr *ifa;
d1018 1
a1018 1
			struct sockaddr *sa;
d1054 1
a1054 1
				struct sockaddr *sa = ifa->ifa_addr;
a1114 6
}

int
if_detached_init(struct ifnet *ifp)
{
	return (ENXIO);
@


1.27.2.10
log
@Merge with the trunk
@
text
@a132 2
void	if_congestion_clear(void *);

a406 5
 *
 * Note that deleting a RTF_CLONING route can trigger the
 * deletion of more entries, so we need to cancel the walk
 * and return EAGAIN.  The caller should restart the walk
 * as long as EAGAIN is returned.
d416 3
a418 7
	if (rt->rt_ifp == ifp) {
		int cloning = (rt->rt_flags & RTF_CLONING);

		if (rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway,
		    rt_mask(rt), 0, NULL) == 0 && cloning)
			return (EAGAIN);
	}
d484 1
a484 3
			while ((*rnh->rnh_walktree)(rnh,
			    if_detach_rtdelete, ifp) == EAGAIN)
				;
a685 3
	if (cp - name < IFNAMSIZ-1 && *cp == '0' && cp[1] != '\0')
		return (NULL);	/* unit number 0 padded */

d697 1
a697 2
		if (*cp < '0' || *cp > '9' ||
		    unit > (INT_MAX - (*cp - '0')) / 10) {
a769 23
 * set queue congestion marker and register timeout to clear it
 */
void
if_congestion(struct ifqueue *ifq)
{
	static struct timeout	to;

	ifq->ifq_congestion = 1;
	bzero(&to, sizeof(to));
	timeout_set(&to, if_congestion_clear, ifq);
	timeout_add(&to, hz / 100);
}

/*
 * clear the congestion flag
 */
void
if_congestion_clear(void *ifq)
{
	((struct ifqueue *)ifq)->ifq_congestion = 0;
}

/*
a969 4
#if NCARP > 0
	if (ifp->if_carp)
		carp_carpdev_state(ifp->if_carp);
#endif
a994 4
#if NCARP > 0
	if (ifp->if_carp)
		carp_carpdev_state(ifp->if_carp);
#endif
a1071 1
	char ifdescrbuf[IFDESCRSIZE];
a1072 1
	size_t bytesdone;
d1089 2
a1090 2
		    if_clone_create(ifr->ifr_name) :
		    if_clone_destroy(ifr->ifr_name));
a1183 17
		break;

	case SIOCGIFDESCR:
		strlcpy(ifdescrbuf, ifp->if_description, IFDESCRSIZE);
		error = copyoutstr(ifdescrbuf, ifr->ifr_data, IFDESCRSIZE,
		    &bytesdone);
		break;

	case SIOCSIFDESCR:
		if ((error = suser(p, 0)) != 0)
			return (error);
		error = copyinstr(ifr->ifr_data, ifdescrbuf,
		    IFDESCRSIZE, &bytesdone);
		if (error == 0) {
			(void)memset(ifp->if_description, 0, IFDESCRSIZE);
			strlcpy(ifp->if_description, ifdescrbuf, IFDESCRSIZE);
		}
@


1.26
log
@ifdef myip_ifp (kernel/1014, thanks to dne@@mayonnaise.net for testing
the patch)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.25 1999/12/08 06:50:17 itojun Exp $	*/
d809 1
a809 1
			int s = splimp();
@


1.25
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.24 1999/11/20 18:51:58 espie Exp $	*/
d322 1
d324 1
@


1.24
log
@ioctl arguments are u_long.
Replaces `undefined' code with `defined' behavior...

gcc 2.96 performs switch cases range analysis, warns about unreachable
cases, and weeds them out.

In

switch(i) {
case VALUE:
}

VALUE is first coerced into the type of i.  If i is signed, VALUE is
unsigned and exceeds i range, you lose... the result of the conversion
is undefined.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.23 1999/11/09 17:49:01 millert Exp $	*/
d5 29
d85 1
d98 6
d124 8
d150 2
a151 1
struct ifaddr **ifnet_addrs;
d168 18
a185 4
	if (ifnet_addrs == 0 || if_index >= if_indexlim) {
		unsigned int n = (if_indexlim <<= 1) * sizeof(ifa);
		struct ifaddr **q = (struct ifaddr **)
					malloc(n, M_IFADDR, M_WAITOK);
d187 1
a187 1
			bcopy((caddr_t)ifnet_addrs, (caddr_t)q, n/2);
d190 11
a200 1
		ifnet_addrs = q;
d202 3
d226 1
a226 1
	ifnet_addrs[if_index - 1] = ifa;
d376 2
d423 1
a423 1
		return (ifnet_addrs[sdl->sdl_index - 1]);
d572 3
d635 29
d676 2
a677 1
	int error;
d689 1
d739 2
a740 1
		return ((*ifp->if_ioctl)(ifp, cmd, data));
d746 1
a746 1
		return ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
a797 1
		return (error);
d801 1
d803 11
a813 1
	return (0);
@


1.23
log
@Add SIOCSIFMEDIA and SIOCGIFMEDIA to the switch in ifioctl().  SIOCSIFMEDIA
is only allowed if the user is the superuser.  Aparently this got
missed when the ifmedia support was added in ages ago.   More or less
based on how NetBSD does it (though it is rather obvious).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.22 1999/10/27 16:36:25 deraadt Exp $	*/
d642 1
a642 1
		int ocmd = cmd;
@


1.22
log
@move nat_ifdetach() after interface is removed from the list; avalon@@coombs.anu.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.21 1999/08/08 14:59:02 niklas Exp $	*/
d624 1
d627 2
@


1.21
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.20 1999/08/08 00:43:00 niklas Exp $	*/
a254 6

#ifdef IPFILTER
	/* XXX More ipf & ipnat cleanup needed.  */
	nat_ifdetach(ifp);
#endif

d262 5
@


1.20
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.19 1999/07/04 20:39:28 deraadt Exp $	*/
d64 1
a64 1
#include <netinet/ip_mrouting.h>
@


1.19
log
@fix unsigned without a size-type
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.18 1998/08/05 19:51:06 millert Exp $	*/
d39 3
d56 25
d82 2
a83 1
static void if_attachsetup __P((struct ifnet *));
d112 1
a112 1
static void
d189 95
a431 2

#include <net/route.h>
@


1.18
log
@fix ifc_len == 0 hack for variable size structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.17 1998/08/04 20:57:19 millert Exp $	*/
d87 1
a87 1
	unsigned socksize, ifasize;
d95 1
a95 1
		unsigned n = (if_indexlim <<= 1) * sizeof(ifa);
@


1.17
log
@Add hack to SIOCGIFCONF where if ifc_len is 0, fill it in with the size needed and return; Linux does this too.  Suggested by cmetz@@inner.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.16 1998/03/25 07:37:29 deraadt Exp $	*/
d593 17
a609 2
		for (ifp = ifnet.tqh_first; ifp; ifp = ifp->if_list.tqe_next)
			space += sizeof (ifr);
@


1.16
log
@add SIOCGIFDATA; fetches ifdata structure attached to each interface
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.15 1997/12/31 04:09:32 mickey Exp $	*/
d590 8
@


1.15
log
@NULL is not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.14 1997/07/11 23:43:00 provos Exp $	*/
d469 5
@


1.14
log
@argh. commited wrong file
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.12 1996/08/03 17:50:35 deraadt Exp $	*/
d184 1
a184 1
	return ((struct ifaddr *)0);
d206 1
a206 1
	return ((struct ifaddr *)0);
d266 1
a266 1
	return ((struct ifaddr *)0);
d285 1
a285 1
		return (0);
@


1.13
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.11 1996/07/02 06:52:05 niklas Exp $	*/
d232 1
a232 1
			if (!ifa->ifa_addr || ifa->ifa_addr->sa_family != af ||
@


1.12
log
@dst addr might be NULL; netbsd pr#2183; chuck@@maria.wustl.edu
@
text
@d232 1
a232 1
			if (ifa->ifa_addr->sa_family != af ||
@


1.11
log
@-Wall & -Wstrict-prototype fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.10 1996/06/29 18:54:08 deraadt Exp $	*/
d175 2
@


1.10
log
@provide if_attachhead(), and make if_loop use it
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.9 1996/05/10 12:31:07 deraadt Exp $	*/
d53 2
@


1.9
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.8 1996/05/09 11:10:28 deraadt Exp $	*/
d81 2
a82 2
void
if_attach(ifp)
a90 4
	if (if_index == 0)
		TAILQ_INIT(&ifnet);
	TAILQ_INIT(&ifp->if_addrlist);
	TAILQ_INSERT_TAIL(&ifnet, ifp, if_list);
d134 23
@


1.8
log
@linux & svr4 support
@
text
@d1 2
a2 2
/*	$OpenBSD: if.c,v 1.6 1996/03/14 08:35:35 tholo Exp $	*/
/*	$NetBSD: if.c,v 1.24 1996/02/13 22:00:09 christos Exp $	*/
a75 1
static char *sprint_d __P((u_int, char *, int));
d86 1
a86 2
	int namelen, unitlen, masklen;
	char workbuf[12], *unitname;
d109 1
a109 3
	unitname = sprint_d((u_int)ifp->if_unit, workbuf, sizeof(workbuf));
	namelen = strlen(ifp->if_name);
	unitlen = strlen(unitname);
d111 1
a111 2
	masklen = _offsetof(struct sockaddr_dl, sdl_data[0]) +
			       unitlen + namelen;
d123 2
a124 3
	bcopy(ifp->if_name, sdl->sdl_data, namelen);
	bcopy(unitname, namelen + (caddr_t)sdl->sdl_data, unitlen);
	sdl->sdl_nlen = (namelen += unitlen);
d391 1
a391 1
			(*ifp->if_watchdog)(ifp->if_unit);
a404 1
	register char *cp;
a405 3
	int unit;
	unsigned len;
	char *ep, c;
d407 5
a411 24
	for (cp = name; cp < name + IFNAMSIZ && *cp; cp++)
		if (*cp >= '0' && *cp <= '9')
			break;
	if (*cp == '\0' || cp == name + IFNAMSIZ)
		return ((struct ifnet *)0);
	/*
	 * Save first char of unit, and pointer to it,
	 * so we can put a null there to avoid matching
	 * initial substrings of interface names.
	 */
	len = cp - name + 1;
	c = *cp;
	ep = cp;
	for (unit = 0; *cp >= '0' && *cp <= '9'; )
		unit = unit * 10 + *cp++ - '0';
	*ep = 0;
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next) {
		if (bcmp(ifp->if_name, name, len))
			continue;
		if (unit == ifp->if_unit)
			break;
	}
	*ep = c;
	return (ifp);
a559 1
	register char *cp, *ep;
a561 1
	int i, ndig;
d564 3
a566 21
	ep = ifr.ifr_name + sizeof (ifr.ifr_name);
	for (ifp = ifnet.tqh_first;
	    space > sizeof (ifr) && ifp != 0; ifp = ifp->if_list.tqe_next) {
		strncpy(ifr.ifr_name, ifp->if_name, sizeof(ifr.ifr_name) - 2);
		for (cp = ifr.ifr_name; cp < ep && *cp; cp++)
			continue;
		i = ifp->if_unit;
		ndig = 0;
		do {
			ndig++;
			i /= 10;
		} while (i);
		cp += ndig;
		if (cp >= ep)
			continue;
		*cp = '\0';
		i = ifp->if_unit;
		do {
			*--cp = '0' + i % 10;
			i /= 10;
		} while (i);
d575 3
a577 2
		    for (; space > sizeof (ifr) && ifa != 0; ifa = ifa->ifa_list.tqe_next) {
			register struct sockaddr *sa = ifa->ifa_addr;
d579 9
a587 9
			if (cmd == OSIOCGIFCONF) {
				struct osockaddr *osa =
					 (struct osockaddr *)&ifr.ifr_addr;
				ifr.ifr_addr = *sa;
				osa->sa_family = sa->sa_family;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr));
				ifrp++;
			} else
d589 19
a607 8
			if (sa->sa_len <= sizeof(*sa)) {
				ifr.ifr_addr = *sa;
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr));
				ifrp++;
			} else {
				space -= sa->sa_len - sizeof(*sa);
				if (space < sizeof (ifr))
d609 1
a609 7
				error = copyout((caddr_t)&ifr, (caddr_t)ifrp,
						sizeof (ifr.ifr_name));
				if (error == 0)
				    error = copyout((caddr_t)sa,
				      (caddr_t)&ifrp->ifr_addr, sa->sa_len);
				ifrp = (struct ifreq *)
					(sa->sa_len + (caddr_t)&ifrp->ifr_addr);
a610 4
			if (error)
				break;
			space -= sizeof (ifr);
		}
a613 17
}

static char *
sprint_d(n, buf, buflen)
	u_int n;
	char *buf;
	int buflen;
{
	register char *cp = buf + buflen - 1;

	*cp = 0;
	do {
		cp--;
		*cp = "0123456789"[n % 10];
		n /= 10;
	} while (n != 0);
	return (cp);
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d513 1
a513 1
#ifndef COMPAT_43
d523 1
a524 1
		case SIOCSIFADDR:
d626 1
a626 1
#ifdef COMPAT_43
@


1.6
log
@From Lite2; only try to match a destination address on a point-to-point
interface if the destination address has been set
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.5 1996/03/05 02:29:37 dm Exp $	*/
d225 1
@


1.5
log
@need some casts for clean compile
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.4 1996/03/03 21:07:04 niklas Exp $	*/
d183 2
a184 1
			if (ifa->ifa_addr->sa_family != addr->sa_family)
@


1.4
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d513 2
a514 1
			cmd, data, ifp));
@


1.3
log
@Interface# 0's name was incorrectly generated
@
text
@d1 2
a2 1
/*	$NetBSD: if.c,v 1.23 1995/08/12 23:59:19 mycroft Exp $	*/
d52 1
a91 1
	extern void link_rtrequest();
d310 1
a310 1
	if (ifa = ifaof_ifpforaddr(dst, ifp)) {
d346 1
d348 1
d353 2
a354 1
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0; ifa = ifa->ifa_list.tqe_next)
d370 1
a370 1
	while (m = n) {
d476 1
a476 1
		if (error = suser(p->p_ucred, &p->p_acflag))
d495 1
a495 1
		if (error = suser(p->p_ucred, &p->p_acflag))
d502 1
a502 1
		if (error = suser(p->p_ucred, &p->p_acflag))
d551 4
a554 2
		error =  ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL,
							    cmd, data, ifp));
@


1.2
log
@handle interface unit numbers up to 2G-1; skip if total name is too long
@
text
@d592 3
a594 1
		for (i = ifp->if_unit, ndig = 0; i; i /= 10)
d596 2
d602 5
a606 2
		for (i = ifp->if_unit; i; i /= 10)
			*--cp = '0' + (i % 10);
@


1.1
log
@Initial revision
@
text
@d583 1
d586 1
a586 1
	ep = ifr.ifr_name + sizeof (ifr.ifr_name) - 2;
d592 8
a599 1
		*cp++ = '0' + ifp->if_unit; *cp = '\0';
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
