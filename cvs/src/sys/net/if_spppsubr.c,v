head	1.170;
access;
symbols
	OPENBSD_6_1:1.162.0.4
	OPENBSD_6_1_BASE:1.162
	OPENBSD_6_0:1.155.0.4
	OPENBSD_6_0_BASE:1.155
	OPENBSD_5_9:1.149.0.2
	OPENBSD_5_9_BASE:1.149
	OPENBSD_5_8:1.136.0.4
	OPENBSD_5_8_BASE:1.136
	OPENBSD_5_7:1.130.0.2
	OPENBSD_5_7_BASE:1.130
	OPENBSD_5_6:1.125.0.4
	OPENBSD_5_6_BASE:1.125
	OPENBSD_5_5:1.117.0.4
	OPENBSD_5_5_BASE:1.117
	OPENBSD_5_4:1.106.0.2
	OPENBSD_5_4_BASE:1.106
	OPENBSD_5_3:1.99.0.2
	OPENBSD_5_3_BASE:1.99
	OPENBSD_5_2:1.98.0.2
	OPENBSD_5_2_BASE:1.98
	OPENBSD_5_1_BASE:1.96
	OPENBSD_5_1:1.96.0.2
	OPENBSD_5_0:1.94.0.2
	OPENBSD_5_0_BASE:1.94
	OPENBSD_4_9:1.84.0.2
	OPENBSD_4_9_BASE:1.84
	OPENBSD_4_8:1.81.0.2
	OPENBSD_4_8_BASE:1.81
	OPENBSD_4_7:1.79.0.2
	OPENBSD_4_7_BASE:1.79
	OPENBSD_4_6:1.75.0.6
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.75.0.2
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.70.0.2
	OPENBSD_4_4_BASE:1.70
	OPENBSD_4_3:1.65.0.2
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.56.0.2
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.16
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.170
date	2017.08.11.21.24.19;	author mpi;	state Exp;
branches;
next	1.169;
commitid	qO4hXiGM2yDTtiTI;

1.169
date	2017.08.11.15.13.25;	author reyk;	state Exp;
branches;
next	1.168;
commitid	bpVsRDuey9RXoBg1;

1.168
date	2017.08.11.15.12.32;	author reyk;	state Exp;
branches;
next	1.167;
commitid	XMC14LPZcfja3PZ9;

1.167
date	2017.08.11.13.23.27;	author reyk;	state Exp;
branches;
next	1.166;
commitid	8h4NadEHxBrZJgLp;

1.166
date	2017.08.01.20.52.32;	author mpi;	state Exp;
branches;
next	1.165;
commitid	mTMD6P7uGSxbH4ug;

1.165
date	2017.06.16.10.58.43;	author stsp;	state Exp;
branches;
next	1.164;
commitid	FFIiFdwDDwJpmUDV;

1.164
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.163;
commitid	p51F2KIwIJB1dU8P;

1.163
date	2017.04.14.15.11.31;	author bluhm;	state Exp;
branches;
next	1.162;
commitid	0ifmKLHPmgcK2529;

1.162
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.161;
commitid	6c6qq5OdS4VVnyVM;

1.161
date	2017.01.21.05.36.33;	author dlg;	state Exp;
branches;
next	1.160;
commitid	tTVlide7hMDOsfEQ;

1.160
date	2017.01.20.00.51.56;	author mpi;	state Exp;
branches;
next	1.159;
commitid	ASQosbhukUA3DGlR;

1.159
date	2017.01.08.02.16.08;	author bluhm;	state Exp;
branches;
next	1.158;
commitid	fTFKhO9XyPMkires;

1.158
date	2017.01.02.08.41.21;	author mpi;	state Exp;
branches;
next	1.157;
commitid	gy3IrH7EOZvZmYzS;

1.157
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.156;
commitid	QqHqT2WhCBWqYgGJ;

1.156
date	2016.11.16.14.25.19;	author mpi;	state Exp;
branches;
next	1.155;
commitid	SESEFWZG6jMzEhS0;

1.155
date	2016.07.11.13.06.31;	author bluhm;	state Exp;
branches;
next	1.154;
commitid	s9vCFtJQBVcyR7KD;

1.154
date	2016.06.14.20.44.43;	author sthen;	state Exp;
branches;
next	1.153;
commitid	tndIBFePD1o7FA2I;

1.153
date	2016.05.30.23.30.10;	author sthen;	state Exp;
branches;
next	1.152;
commitid	dVgy2mYGXH78Mymf;

1.152
date	2016.05.02.22.15.49;	author jmatthew;	state Exp;
branches;
next	1.151;
commitid	Qe5v796bHPmQNEGf;

1.151
date	2016.05.01.14.08.39;	author sthen;	state Exp;
branches;
next	1.150;
commitid	v8vsbDkbmLMPy5o0;

1.150
date	2016.04.18.14.38.09;	author mikeb;	state Exp;
branches;
next	1.149;
commitid	Ulkx0vStDvav3xQS;

1.149
date	2015.11.23.14.41.05;	author sthen;	state Exp;
branches
	1.149.2.1;
next	1.148;
commitid	oitH8AhkLUiNHPnL;

1.148
date	2015.11.20.12.05.34;	author sthen;	state Exp;
branches;
next	1.147;
commitid	L3ElIBq5lmdDeXQ6;

1.147
date	2015.11.20.11.53.36;	author dlg;	state Exp;
branches;
next	1.146;
commitid	1pcfYFQXSh7Ccley;

1.146
date	2015.11.11.01.49.17;	author dlg;	state Exp;
branches;
next	1.145;
commitid	fxxO32cNBXwxt1KA;

1.145
date	2015.11.09.10.26.26;	author mpi;	state Exp;
branches;
next	1.144;
commitid	xyXAt3vnFrCMLsjZ;

1.144
date	2015.11.02.11.19.30;	author dlg;	state Exp;
branches;
next	1.143;
commitid	HkEo4PheGddsdtFD;

1.143
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.142;
commitid	G2nTzngqgXpQqcJB;

1.142
date	2015.10.24.11.58.46;	author mpi;	state Exp;
branches;
next	1.141;
commitid	JFhYU2VjHxiDHltL;

1.141
date	2015.10.05.19.05.09;	author uebayasi;	state Exp;
branches;
next	1.140;
commitid	KaQeg2gqRFHdXmok;

1.140
date	2015.10.05.15.52.46;	author uebayasi;	state Exp;
branches;
next	1.139;
commitid	Jb3hy8KXZkqIykJt;

1.139
date	2015.09.30.12.19.34;	author sthen;	state Exp;
branches;
next	1.138;
commitid	SJRJDsuXgl8M0A5o;

1.138
date	2015.09.30.09.45.20;	author sthen;	state Exp;
branches;
next	1.137;
commitid	0pACTtUSw4WmBBBr;

1.137
date	2015.08.24.15.58.35;	author mpi;	state Exp;
branches;
next	1.136;
commitid	hOA5qIh5CrYvhG4e;

1.136
date	2015.07.18.15.51.16;	author mpi;	state Exp;
branches;
next	1.135;
commitid	lwQKRpFyNEr7kjoF;

1.135
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.134;
commitid	fE8TgA9vpwdUU5Wy;

1.134
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.133;
commitid	h7z8lokZ0dFyuWpg;

1.133
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.132;
commitid	1aiWjheMGhmTuiHL;

1.132
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.131;
commitid	c7ei8kPelCOOwHXy;

1.131
date	2015.03.18.12.23.15;	author dlg;	state Exp;
branches;
next	1.130;
commitid	veRr3qZI7HBatTwk;

1.130
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.129;
commitid	MyKPm9Q3dQu92BiX;

1.129
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.128;
commitid	zhW8jJrfVCoAthrR;

1.128
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.127;
commitid	t9FBKDfc4VDxpEy2;

1.127
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.126;
commitid	Z1vcFtHO8wRH0yRt;

1.126
date	2014.10.08.20.28.27;	author sthen;	state Exp;
branches;
next	1.125;
commitid	8yoL9T97beHozLrz;

1.125
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.124;
commitid	DQakU8LLWV6Iwx84;

1.124
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.123;
commitid	B4dZSbxas1X1IpXI;

1.123
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.122;

1.122
date	2014.05.02.10.40.26;	author jca;	state Exp;
branches;
next	1.121;

1.121
date	2014.04.19.12.12.02;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.119;

1.119
date	2014.04.03.06.06.56;	author yasuoka;	state Exp;
branches;
next	1.118;

1.118
date	2014.03.18.10.47.34;	author mpi;	state Exp;
branches;
next	1.117;

1.117
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.116;

1.116
date	2014.01.12.15.38.06;	author stsp;	state Exp;
branches;
next	1.115;

1.115
date	2014.01.07.16.34.05;	author stsp;	state Exp;
branches;
next	1.114;

1.114
date	2013.12.11.18.27.23;	author jca;	state Exp;
branches;
next	1.113;

1.113
date	2013.11.20.08.21.33;	author stsp;	state Exp;
branches;
next	1.112;

1.112
date	2013.11.14.16.52.33;	author stsp;	state Exp;
branches;
next	1.111;

1.111
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.110;

1.110
date	2013.11.05.15.32.48;	author stsp;	state Exp;
branches;
next	1.109;

1.109
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.108;

1.108
date	2013.10.01.20.22.13;	author sf;	state Exp;
branches;
next	1.107;

1.107
date	2013.08.16.12.29.18;	author mpi;	state Exp;
branches;
next	1.106;

1.106
date	2013.07.15.13.30.37;	author mpi;	state Exp;
branches;
next	1.105;

1.105
date	2013.07.10.07.46.10;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.103;

1.103
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.102;

1.102
date	2013.05.31.19.16.52;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2012.11.23.20.12.03;	author sthen;	state Exp;
branches;
next	1.98;

1.98
date	2012.07.24.15.16.20;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2012.07.23.10.54.54;	author sthen;	state Exp;
branches;
next	1.96;

1.96
date	2012.01.28.12.14.45;	author sthen;	state Exp;
branches;
next	1.95;

1.95
date	2012.01.19.01.13.20;	author sthen;	state Exp;
branches;
next	1.94;

1.94
date	2011.07.07.00.08.04;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2011.07.06.02.54.31;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2011.07.06.02.49.36;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.05.21.11.36;	author guenther;	state Exp;
branches;
next	1.89;

1.89
date	2011.07.05.20.01.40;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2011.06.29.12.14.46;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2011.06.18.23.52.49;	author jsg;	state Exp;
branches;
next	1.86;

1.86
date	2011.05.04.16.05.49;	author blambert;	state Exp;
branches;
next	1.85;

1.85
date	2011.04.17.20.44.27;	author stsp;	state Exp;
branches;
next	1.84;

1.84
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2010.11.17.19.25.49;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2010.09.13.08.53.06;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2010.07.20.15.36.03;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.79;

1.79
date	2010.02.08.13.37.02;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2009.07.27.11.40.59;	author blambert;	state Exp;
branches;
next	1.76;

1.76
date	2009.07.13.16.23.28;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2009.02.18.08.36.20;	author canacar;	state Exp;
branches;
next	1.74;

1.74
date	2009.02.16.23.24.01;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2009.02.16.20.03.36;	author canacar;	state Exp;
branches;
next	1.72;

1.72
date	2009.02.06.22.07.04;	author grange;	state Exp;
branches;
next	1.71;

1.71
date	2009.01.31.21.28.40;	author grange;	state Exp;
branches;
next	1.70;

1.70
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.69;

1.69
date	2008.06.08.15.06.26;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.17.04.50.54;	author canacar;	state Exp;
branches;
next	1.67;

1.67
date	2008.05.11.02.55.45;	author brad;	state Exp;
branches;
next	1.66;

1.66
date	2008.05.11.02.28.16;	author canacar;	state Exp;
branches;
next	1.65;

1.65
date	2007.12.04.19.49.52;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.21.19.52.04;	author canacar;	state Exp;
branches;
next	1.62;

1.62
date	2007.11.16.05.08.39;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2007.11.01.03.35.43;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.01.02.47.20;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.31.21.13.45;	author mikeb;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.25.23.52.27;	author canacar;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.05.21.01.49;	author canacar;	state Exp;
branches;
next	1.56;

1.56
date	2007.08.28.15.59.18;	author canacar;	state Exp;
branches;
next	1.55;

1.55
date	2007.08.20.16.46.00;	author canacar;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.14.18.11.46;	author canacar;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.07.17.15.13;	author canacar;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.06.10.04.36;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.28.06.31.01;	author mcbride;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.20.18.54.15;	author canacar;	state Exp;
branches;
next	1.49;

1.49
date	2007.04.18.10.40.13;	author mpf;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.17.21.36.58;	author mpf;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.19.23.31.14;	author mpf;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.06.10.37.29;	author bernd;	state Exp;
branches;
next	1.43;

1.43
date	2006.08.28.10.50.13;	author canacar;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.11.21.36.51;	author canacar;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.04.17.18.37;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.02.11.01.06;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.24.20.34.34;	author claudio;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2005.10.07.05.19.34;	author canacar;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.12.21.29.10;	author canacar;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2005.08.03.21.50.21;	author canacar;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.08.06.55.33;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.13.20.17.02;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.24.20.56.48;	author canacar;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.11.17.24.10;	author canacar;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.01.22.09.32;	author canacar;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.24.16.37.52;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.23.00.26.06;	author canacar;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.23.00.11.40;	author canacar;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.10.14.35.30;	author naddy;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.28.23.39.45;	author canacar;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.16.15.01.09;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.22.02.02.45;	author tholo;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.07.14.42.27;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.25.18.50.01;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.06.07.28.39;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.26.20.43.54;	author chris;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.27.09.11.47;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.26.22.36.31;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.10.06.10.53;	author jason;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.07.10.11.09.07;	author espie;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.06.27.06.07.43;	author kjc;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.25.02.56.18;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.22.01.42.35;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.07.05.44.05;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.18.39.38;	author chris;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.03.00.54.57;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	99.08.06.23.02.27;	author niklas;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.07.02.17.46.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.07.01.23.10.40;	author deraadt;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.32;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.40.01;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.07.04.10.54.07;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.3.4.9;

1.3.4.9
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.3.4.10;

1.3.4.10
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2001.12.26.23.51.36;	author jason;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.12.27.15.39.32;	author jason;	state Exp;
branches;
next	;

1.11.2.1
date	2002.01.31.22.55.43;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;

1.36.2.1
date	2006.09.02.18.08.23;	author brad;	state Exp;
branches;
next	;

1.38.2.1
date	2006.09.02.18.09.01;	author brad;	state Exp;
branches;
next	;

1.149.2.1
date	2016.05.06.20.03.25;	author sthen;	state Exp;
branches;
next	;
commitid	TuuWjHtOHkw0ATf2;


desc
@@


1.170
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@/*	$OpenBSD: if_spppsubr.c,v 1.169 2017/08/11 15:13:25 reyk Exp $	*/
/*
 * Synchronous PPP link level subroutines.
 *
 * Copyright (C) 1994-1996 Cronyx Engineering Ltd.
 * Author: Serge Vakulenko, <vak@@cronyx.ru>
 *
 * Heavily revamped to conform to RFC 1661.
 * Copyright (C) 1997, Joerg Wunsch.
 *
 * RFC2472 IPv6CP support.
 * Copyright (C) 2000, Jun-ichiro itojun Hagino <itojun@@iijlab.net>.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * From: Version 2.6, Tue May 12 17:10:39 MSD 1998
 */

#include <sys/param.h>

#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/sockio.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>

#include <sys/timeout.h>
#include <crypto/md5.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/netisr.h>
#include <net/if_types.h>
#include <net/route.h>

#include <sys/stdarg.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>

#ifdef INET6
#include <netinet6/in6_ifattach.h>
#endif

#include <net/if_sppp.h>

# define UNTIMEOUT(fun, arg, handle)	\
	timeout_del(&(handle))

#define LOOPALIVECNT			3	/* loopback detection tries */
#define MAXALIVECNT			3	/* max. missed alive packets */
#define	NORECV_TIME			15	/* before we get worried */

/*
 * Interface flags that can be set in an ifconfig command.
 *
 * Setting link0 will make the link passive, i.e. it will be marked
 * as being administrative openable, but won't be opened to begin
 * with.  Incoming calls will be answered, or subsequent calls with
 * -link1 will cause the administrative open of the LCP layer.
 *
 * Setting link1 will cause the link to auto-dial only as packets
 * arrive to be sent.
 *
 * Setting IFF_DEBUG will syslog the option negotiation and state
 * transitions at level kern.debug.  Note: all logs consistently look
 * like
 *
 *   <if-name><unit>: <proto-name> <additional info...>
 *
 * with <if-name><unit> being something like "bppp0", and <proto-name>
 * being one of "lcp", "ipcp", "chap", "pap", etc.
 */

#define IFF_PASSIVE	IFF_LINK0	/* wait passively for connection */
#define IFF_AUTO	IFF_LINK1	/* auto-dial on output */

#define PPP_ALLSTATIONS 0xff		/* All-Stations broadcast address */
#define PPP_UI		0x03		/* Unnumbered Information */
#define PPP_IP		0x0021		/* Internet Protocol */
#define PPP_ISO		0x0023		/* ISO OSI Protocol */
#define PPP_XNS		0x0025		/* Xerox NS Protocol */
#define PPP_IPX		0x002b		/* Novell IPX Protocol */
#define PPP_IPV6	0x0057		/* Internet Protocol v6 */
#define PPP_LCP		0xc021		/* Link Control Protocol */
#define PPP_PAP		0xc023		/* Password Authentication Protocol */
#define PPP_CHAP	0xc223		/* Challenge-Handshake Auth Protocol */
#define PPP_IPCP	0x8021		/* Internet Protocol Control Protocol */
#define PPP_IPV6CP	0x8057		/* IPv6 Control Protocol */

#define CONF_REQ	1		/* PPP configure request */
#define CONF_ACK	2		/* PPP configure acknowledge */
#define CONF_NAK	3		/* PPP configure negative ack */
#define CONF_REJ	4		/* PPP configure reject */
#define TERM_REQ	5		/* PPP terminate request */
#define TERM_ACK	6		/* PPP terminate acknowledge */
#define CODE_REJ	7		/* PPP code reject */
#define PROTO_REJ	8		/* PPP protocol reject */
#define ECHO_REQ	9		/* PPP echo request */
#define ECHO_REPLY	10		/* PPP echo reply */
#define DISC_REQ	11		/* PPP discard request */

#define LCP_OPT_MRU		1	/* maximum receive unit */
#define LCP_OPT_ASYNC_MAP	2	/* async control character map */
#define LCP_OPT_AUTH_PROTO	3	/* authentication protocol */
#define LCP_OPT_QUAL_PROTO	4	/* quality protocol */
#define LCP_OPT_MAGIC		5	/* magic number */
#define LCP_OPT_RESERVED	6	/* reserved */
#define LCP_OPT_PROTO_COMP	7	/* protocol field compression */
#define LCP_OPT_ADDR_COMP	8	/* address/control field compression */

#define IPCP_OPT_ADDRESSES	1	/* both IP addresses; deprecated */
#define IPCP_OPT_COMPRESSION	2	/* IP compression protocol (VJ) */
#define IPCP_OPT_ADDRESS	3	/* local IP address */

#define IPV6CP_OPT_IFID		1	/* interface identifier */
#define IPV6CP_OPT_COMPRESSION	2	/* IPv6 compression protocol */

#define PAP_REQ			1	/* PAP name/password request */
#define PAP_ACK			2	/* PAP acknowledge */
#define PAP_NAK			3	/* PAP fail */

#define CHAP_CHALLENGE		1	/* CHAP challenge request */
#define CHAP_RESPONSE		2	/* CHAP challenge response */
#define CHAP_SUCCESS		3	/* CHAP response ok */
#define CHAP_FAILURE		4	/* CHAP response failed */

#define CHAP_MD5		5	/* hash algorithm - MD5 */

/* states are named and numbered according to RFC 1661 */
#define STATE_INITIAL	0
#define STATE_STARTING	1
#define STATE_CLOSED	2
#define STATE_STOPPED	3
#define STATE_CLOSING	4
#define STATE_STOPPING	5
#define STATE_REQ_SENT	6
#define STATE_ACK_RCVD	7
#define STATE_ACK_SENT	8
#define STATE_OPENED	9

#define PKTHDRLEN	2

struct ppp_header {
	u_char address;
	u_char control;
	u_short protocol;
};
#define PPP_HEADER_LEN          sizeof (struct ppp_header)

struct lcp_header {
	u_char type;
	u_char ident;
	u_short len;
};
#define LCP_HEADER_LEN          sizeof (struct lcp_header)

/*
 * We follow the spelling and capitalization of RFC 1661 here, to make
 * it easier comparing with the standard.  Please refer to this RFC in
 * case you can't make sense out of these abbreviation; it will also
 * explain the semantics related to the various events and actions.
 */
struct cp {
	u_short	proto;		/* PPP control protocol number */
	u_char protoidx;	/* index into state table in struct sppp */
	u_char flags;
#define CP_LCP		0x01	/* this is the LCP */
#define CP_AUTH		0x02	/* this is an authentication protocol */
#define CP_NCP		0x04	/* this is a NCP */
#define CP_QUAL		0x08	/* this is a quality reporting protocol */
	const char *name;	/* name of this control protocol */
	/* event handlers */
	void	(*Up)(struct sppp *sp);
	void	(*Down)(struct sppp *sp);
	void	(*Open)(struct sppp *sp);
	void	(*Close)(struct sppp *sp);
	void	(*TO)(void *sp);
	int	(*RCR)(struct sppp *sp, struct lcp_header *h, int len);
	void	(*RCN_rej)(struct sppp *sp, struct lcp_header *h, int len);
	void	(*RCN_nak)(struct sppp *sp, struct lcp_header *h, int len);
	/* actions */
	void	(*tlu)(struct sppp *sp);
	void	(*tld)(struct sppp *sp);
	void	(*tls)(struct sppp *sp);
	void	(*tlf)(struct sppp *sp);
	void	(*scr)(struct sppp *sp);
};

static struct sppp *spppq;
static struct timeout keepalive_ch;

#define	SPP_FMT		"%s: "
#define	SPP_ARGS(ifp)	(ifp)->if_xname

/* almost every function needs these */
#define STDDCL							\
	struct ifnet *ifp = &sp->pp_if;				\
	int debug = ifp->if_flags & IFF_DEBUG

int sppp_output(struct ifnet *ifp, struct mbuf *m,
		       struct sockaddr *dst, struct rtentry *rt);

void sppp_cp_input(const struct cp *cp, struct sppp *sp,
			  struct mbuf *m);
void sppp_cp_send(struct sppp *sp, u_short proto, u_char type,
			 u_char ident, u_short len, void *data);
#ifdef notyet
void sppp_cp_timeout(void *arg);
#endif
void sppp_cp_change_state(const struct cp *cp, struct sppp *sp,
				 int newstate);
void sppp_auth_send(const struct cp *cp,
			   struct sppp *sp, unsigned int type, u_int id,
			   ...);

void sppp_up_event(const struct cp *cp, struct sppp *sp);
void sppp_down_event(const struct cp *cp, struct sppp *sp);
void sppp_open_event(const struct cp *cp, struct sppp *sp);
void sppp_close_event(const struct cp *cp, struct sppp *sp);
void sppp_increasing_timeout(const struct cp *cp, struct sppp *sp);
void sppp_to_event(const struct cp *cp, struct sppp *sp);

void sppp_null(struct sppp *sp);

void sppp_lcp_init(struct sppp *sp);
void sppp_lcp_up(struct sppp *sp);
void sppp_lcp_down(struct sppp *sp);
void sppp_lcp_open(struct sppp *sp);
void sppp_lcp_close(struct sppp *sp);
void sppp_lcp_TO(void *sp);
int sppp_lcp_RCR(struct sppp *sp, struct lcp_header *h, int len);
void sppp_lcp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len);
void sppp_lcp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len);
void sppp_lcp_tlu(struct sppp *sp);
void sppp_lcp_tld(struct sppp *sp);
void sppp_lcp_tls(struct sppp *sp);
void sppp_lcp_tlf(struct sppp *sp);
void sppp_lcp_scr(struct sppp *sp);
void sppp_lcp_check_and_close(struct sppp *sp);
int sppp_ncp_check(struct sppp *sp);

void sppp_ipcp_init(struct sppp *sp);
void sppp_ipcp_destroy(struct sppp *sp);
void sppp_ipcp_up(struct sppp *sp);
void sppp_ipcp_down(struct sppp *sp);
void sppp_ipcp_open(struct sppp *sp);
void sppp_ipcp_close(struct sppp *sp);
void sppp_ipcp_TO(void *sp);
int sppp_ipcp_RCR(struct sppp *sp, struct lcp_header *h, int len);
void sppp_ipcp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len);
void sppp_ipcp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len);
void sppp_ipcp_tlu(struct sppp *sp);
void sppp_ipcp_tld(struct sppp *sp);
void sppp_ipcp_tls(struct sppp *sp);
void sppp_ipcp_tlf(struct sppp *sp);
void sppp_ipcp_scr(struct sppp *sp);

void sppp_ipv6cp_init(struct sppp *sp);
void sppp_ipv6cp_destroy(struct sppp *sp);
void sppp_ipv6cp_up(struct sppp *sp);
void sppp_ipv6cp_down(struct sppp *sp);
void sppp_ipv6cp_open(struct sppp *sp);
void sppp_ipv6cp_close(struct sppp *sp);
void sppp_ipv6cp_TO(void *sp);
int sppp_ipv6cp_RCR(struct sppp *sp, struct lcp_header *h, int len);
void sppp_ipv6cp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len);
void sppp_ipv6cp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len);
void sppp_ipv6cp_tlu(struct sppp *sp);
void sppp_ipv6cp_tld(struct sppp *sp);
void sppp_ipv6cp_tls(struct sppp *sp);
void sppp_ipv6cp_tlf(struct sppp *sp);
void sppp_ipv6cp_scr(struct sppp *sp);
const char *sppp_ipv6cp_opt_name(u_char opt);
void sppp_get_ip6_addrs(struct sppp *sp, struct in6_addr *src,
			       struct in6_addr *dst, struct in6_addr *srcmask);
void sppp_set_ip6_addr(struct sppp *sp, const struct in6_addr *src, const struct in6_addr *dst);
void sppp_update_ip6_addr(void *sp);
void sppp_suggest_ip6_addr(struct sppp *sp, struct in6_addr *suggest);

void sppp_pap_input(struct sppp *sp, struct mbuf *m);
void sppp_pap_init(struct sppp *sp);
void sppp_pap_open(struct sppp *sp);
void sppp_pap_close(struct sppp *sp);
void sppp_pap_TO(void *sp);
void sppp_pap_my_TO(void *sp);
void sppp_pap_tlu(struct sppp *sp);
void sppp_pap_tld(struct sppp *sp);
void sppp_pap_scr(struct sppp *sp);

void sppp_chap_input(struct sppp *sp, struct mbuf *m);
void sppp_chap_init(struct sppp *sp);
void sppp_chap_open(struct sppp *sp);
void sppp_chap_close(struct sppp *sp);
void sppp_chap_TO(void *sp);
void sppp_chap_tlu(struct sppp *sp);
void sppp_chap_tld(struct sppp *sp);
void sppp_chap_scr(struct sppp *sp);

const char *sppp_auth_type_name(u_short proto, u_char type);
const char *sppp_cp_type_name(u_char type);
const char *sppp_dotted_quad(u_int32_t addr);
const char *sppp_ipcp_opt_name(u_char opt);
const char *sppp_lcp_opt_name(u_char opt);
const char *sppp_phase_name(enum ppp_phase phase);
const char *sppp_proto_name(u_short proto);
const char *sppp_state_name(int state);
int sppp_get_params(struct sppp *sp, struct ifreq *data);
int sppp_set_params(struct sppp *sp, struct ifreq *data);
void sppp_get_ip_addrs(struct sppp *sp, u_int32_t *src, u_int32_t *dst,
			      u_int32_t *srcmask);
void sppp_keepalive(void *dummy);
void sppp_phase_network(struct sppp *sp);
void sppp_print_bytes(const u_char *p, u_short len);
void sppp_print_string(const char *p, u_short len);
int sppp_update_gw_walker(struct rtentry *rt, void *arg, unsigned int id);
void sppp_update_gw(struct ifnet *ifp);
void sppp_set_ip_addrs(void *);
void sppp_clear_ip_addrs(void *);
void sppp_set_phase(struct sppp *sp);

/* our control protocol descriptors */
static const struct cp lcp = {
	PPP_LCP, IDX_LCP, CP_LCP, "lcp",
	sppp_lcp_up, sppp_lcp_down, sppp_lcp_open, sppp_lcp_close,
	sppp_lcp_TO, sppp_lcp_RCR, sppp_lcp_RCN_rej, sppp_lcp_RCN_nak,
	sppp_lcp_tlu, sppp_lcp_tld, sppp_lcp_tls, sppp_lcp_tlf,
	sppp_lcp_scr
};

static const struct cp ipcp = {
	PPP_IPCP, IDX_IPCP,
	CP_NCP,
	"ipcp",
	sppp_ipcp_up, sppp_ipcp_down, sppp_ipcp_open, sppp_ipcp_close,
	sppp_ipcp_TO, sppp_ipcp_RCR, sppp_ipcp_RCN_rej, sppp_ipcp_RCN_nak,
	sppp_ipcp_tlu, sppp_ipcp_tld, sppp_ipcp_tls, sppp_ipcp_tlf,
	sppp_ipcp_scr
};

static const struct cp ipv6cp = {
	PPP_IPV6CP, IDX_IPV6CP,
#ifdef INET6	/*don't run IPv6CP if there's no IPv6 support*/
	CP_NCP,
#else
	0,
#endif
	"ipv6cp",
	sppp_ipv6cp_up, sppp_ipv6cp_down, sppp_ipv6cp_open, sppp_ipv6cp_close,
	sppp_ipv6cp_TO, sppp_ipv6cp_RCR, sppp_ipv6cp_RCN_rej, sppp_ipv6cp_RCN_nak,
	sppp_ipv6cp_tlu, sppp_ipv6cp_tld, sppp_ipv6cp_tls, sppp_ipv6cp_tlf,
	sppp_ipv6cp_scr
};

static const struct cp pap = {
	PPP_PAP, IDX_PAP, CP_AUTH, "pap",
	sppp_null, sppp_null, sppp_pap_open, sppp_pap_close,
	sppp_pap_TO, 0, 0, 0,
	sppp_pap_tlu, sppp_pap_tld, sppp_null, sppp_null,
	sppp_pap_scr
};

static const struct cp chap = {
	PPP_CHAP, IDX_CHAP, CP_AUTH, "chap",
	sppp_null, sppp_null, sppp_chap_open, sppp_chap_close,
	sppp_chap_TO, 0, 0, 0,
	sppp_chap_tlu, sppp_chap_tld, sppp_null, sppp_null,
	sppp_chap_scr
};

static const struct cp *cps[IDX_COUNT] = {
	&lcp,			/* IDX_LCP */
	&ipcp,			/* IDX_IPCP */
	&ipv6cp,		/* IDX_IPV6CP */
	&pap,			/* IDX_PAP */
	&chap,			/* IDX_CHAP */
};


/*
 * Exported functions, comprising our interface to the lower layer.
 */

/* Workaround */
void
spppattach(struct ifnet *ifp)
{
}

/*
 * Process the received packet.
 */
void
sppp_input(struct ifnet *ifp, struct mbuf *m)
{
	struct ppp_header ht;
	struct sppp *sp = (struct sppp *)ifp;
	struct timeval tv;
	int debug = ifp->if_flags & IFF_DEBUG;

	getmicrouptime(&tv);

	if (ifp->if_flags & IFF_UP) {
		/* Count received bytes, add hardware framing */
		ifp->if_ibytes += m->m_pkthdr.len + sp->pp_framebytes;
		/* Note time of last receive */
		sp->pp_last_receive = tv.tv_sec;
	}

	if (m->m_pkthdr.len <= PPP_HEADER_LEN) {
		/* Too small packet, drop it. */
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "input packet is too small, %d bytes\n",
			    SPP_ARGS(ifp), m->m_pkthdr.len);
	  drop:
		m_freem (m);
		++ifp->if_ierrors;
		++ifp->if_iqdrops;
		return;
	}

	/* mark incoming routing domain */
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

	m_copydata(m, 0, sizeof(ht.protocol), (caddr_t)&ht.protocol);
	m_adj(m, 2);
	ht.control = PPP_UI;
	ht.address = PPP_ALLSTATIONS;

	/* preserve the alignment */
	if (m->m_len < m->m_pkthdr.len) {
		m = m_pullup(m, m->m_pkthdr.len);
		if (m == NULL) {
			if (debug)
				log(LOG_DEBUG,
				    SPP_FMT "Failed to align packet!\n", SPP_ARGS(ifp));
			++ifp->if_ierrors;
			++ifp->if_iqdrops;
			return;
		}
	}

	switch (ht.address) {
	case PPP_ALLSTATIONS:
		if (ht.control != PPP_UI)
			goto invalid;
		switch (ntohs (ht.protocol)) {
		default:
			if (sp->state[IDX_LCP] == STATE_OPENED)
				sppp_cp_send (sp, PPP_LCP, PROTO_REJ,
				    ++sp->pp_seq, 2, &ht.protocol);
			if (debug)
				log(LOG_DEBUG,
				    SPP_FMT "invalid input protocol "
				    "<addr=0x%x ctrl=0x%x proto=0x%x>\n",
				    SPP_ARGS(ifp),
				    ht.address, ht.control, ntohs(ht.protocol));
			++ifp->if_noproto;
			goto drop;
		case PPP_LCP:
			sppp_cp_input(&lcp, sp, m);
			m_freem (m);
			return;
		case PPP_PAP:
			if (sp->pp_phase >= PHASE_AUTHENTICATE)
				sppp_pap_input(sp, m);
			m_freem (m);
			return;
		case PPP_CHAP:
			if (sp->pp_phase >= PHASE_AUTHENTICATE)
				sppp_chap_input(sp, m);
			m_freem (m);
			return;
		case PPP_IPCP:
			if (sp->pp_phase == PHASE_NETWORK)
				sppp_cp_input(&ipcp, sp, m);
			m_freem (m);
			return;
		case PPP_IP:
			if (sp->state[IDX_IPCP] == STATE_OPENED) {
				sp->pp_last_activity = tv.tv_sec;
				if (ifp->if_flags & IFF_UP) {
					ipv4_input(ifp, m);
					return;
				}
			}
			break;
#ifdef INET6
		case PPP_IPV6CP:
			if (sp->pp_phase == PHASE_NETWORK)
				sppp_cp_input(&ipv6cp, sp, m);
			m_freem (m);
			return;
		case PPP_IPV6:
			if (sp->state[IDX_IPV6CP] == STATE_OPENED) {
				sp->pp_last_activity = tv.tv_sec;
				if (ifp->if_flags & IFF_UP) {
					ipv6_input(ifp, m);
					return;
				}
			}
			break;
#endif
		}
		break;
	default:        /* Invalid PPP packet. */
	  invalid:
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "invalid input packet "
			    "<addr=0x%x ctrl=0x%x proto=0x%x>\n",
			    SPP_ARGS(ifp),
			    ht.address, ht.control, ntohs(ht.protocol));
		goto drop;
	}

	goto drop;
}

/*
 * Enqueue transmit packet.
 */
int
sppp_output(struct ifnet *ifp, struct mbuf *m,
	    struct sockaddr *dst, struct rtentry *rt)
{
	struct sppp *sp = (struct sppp*) ifp;
	struct timeval tv;
	int s, rv = 0;
	u_int16_t protocol;

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.ph_rtableid),
		    dst->sa_family);
	}
#endif

	s = splnet();

	getmicrouptime(&tv);
	sp->pp_last_activity = tv.tv_sec;

	if ((ifp->if_flags & IFF_UP) == 0 ||
	    (ifp->if_flags & (IFF_RUNNING | IFF_AUTO)) == 0) {
		m_freem (m);
		splx (s);
		return (ENETDOWN);
	}

	if ((ifp->if_flags & (IFF_RUNNING | IFF_AUTO)) == IFF_AUTO) {
		/*
		 * Interface is not yet running, but auto-dial.  Need
		 * to start LCP for it.
		 */
		ifp->if_flags |= IFF_RUNNING;
		splx(s);
		lcp.Open(sp);
		s = splnet();
	}

	if (dst->sa_family == AF_INET) {
		struct ip *ip = NULL;

		if (m->m_len >= sizeof(struct ip))
			ip = mtod(m, struct ip *);

		/*
		 * When using dynamic local IP address assignment by using
		 * 0.0.0.0 as a local address, the first TCP session will
		 * not connect because the local TCP checksum is computed
		 * using 0.0.0.0 which will later become our real IP address
		 * so the TCP checksum computed at the remote end will
		 * become invalid. So we
		 * - don't let packets with src ip addr 0 thru
		 * - we flag TCP packets with src ip 0 as an error
		 */

		if (ip && ip->ip_src.s_addr == INADDR_ANY) {
			u_int8_t proto = ip->ip_p;

			m_freem(m);
			splx(s);
			if (proto == IPPROTO_TCP)
				return (EADDRNOTAVAIL);
			else
				return (0);
		}
	}

	switch (dst->sa_family) {
	case AF_INET:   /* Internet Protocol */
		/*
		 * Don't choke with an ENETDOWN early.  It's
		 * possible that we just started dialing out,
		 * so don't drop the packet immediately.  If
		 * we notice that we run out of buffer space
		 * below, we will however remember that we are
		 * not ready to carry IP packets, and return
		 * ENETDOWN, as opposed to ENOBUFS.
		 */
		protocol = htons(PPP_IP);
		if (sp->state[IDX_IPCP] != STATE_OPENED)
			rv = ENETDOWN;
		break;
#ifdef INET6
	case AF_INET6:   /* Internet Protocol v6 */
		/*
		 * Don't choke with an ENETDOWN early.  It's
		 * possible that we just started dialing out,
		 * so don't drop the packet immediately.  If
		 * we notice that we run out of buffer space
		 * below, we will however remember that we are
		 * not ready to carry IPv6 packets, and return
		 * ENETDOWN, as opposed to ENOBUFS.
		 */
		protocol = htons(PPP_IPV6);
		if (sp->state[IDX_IPV6CP] != STATE_OPENED)
			rv = ENETDOWN;
		break;
#endif
	default:
		m_freem(m);
		++ifp->if_oerrors;
		splx(s);
		return (EAFNOSUPPORT);
	}

	M_PREPEND(m, 2, M_DONTWAIT);
	if (m == NULL) {
		if (ifp->if_flags & IFF_DEBUG)
			log(LOG_DEBUG, SPP_FMT
			    "no memory for transmit header\n",
			    SPP_ARGS(ifp));
		++ifp->if_oerrors;
		splx(s);
		return (ENOBUFS);
	}
	*mtod(m, u_int16_t *) = protocol;

	/*
	 * Queue message on interface, and start output if interface
	 * not yet active.
	 */
	rv = if_enqueue(ifp, m);
	if (rv != 0) {
		ifp->if_oerrors++;
		splx(s);
		return (rv);
	}

	/*
	 * Count output packets and bytes.
	 * The packet length includes header, FCS and 1 flag,
	 * according to RFC 1333.
	 */
	ifp->if_obytes += sp->pp_framebytes;
	splx(s);

	return (0);
}

void
sppp_attach(struct ifnet *ifp)
{
	struct sppp *sp = (struct sppp*) ifp;
	int i;

	/* Initialize keepalive handler. */
	if (! spppq) {
		timeout_set_proc(&keepalive_ch, sppp_keepalive, NULL);
		timeout_add_sec(&keepalive_ch, 10);
	}

	/* Insert new entry into the keepalive list. */
	sp->pp_next = spppq;
	spppq = sp;

	sp->pp_if.if_type = IFT_PPP;
	sp->pp_if.if_output = sppp_output;
	IFQ_SET_MAXLEN(&sp->pp_if.if_snd, 50);
	mq_init(&sp->pp_cpq, 50, IPL_NET);
	sp->pp_loopcnt = 0;
	sp->pp_alivecnt = 0;
	sp->pp_last_activity = 0;
	sp->pp_last_receive = 0;
	sp->pp_seq = 0;
	sp->pp_rseq = 0;
	sp->pp_phase = PHASE_DEAD;
	sp->pp_up = lcp.Up;
	sp->pp_down = lcp.Down;

	for (i = 0; i < IDX_COUNT; i++)
		timeout_set(&sp->ch[i], (cps[i])->TO, (void *)sp);
	timeout_set(&sp->pap_my_to_ch, sppp_pap_my_TO, (void *)sp);

	sppp_lcp_init(sp);
	sppp_ipcp_init(sp);
	sppp_ipv6cp_init(sp);
	sppp_pap_init(sp);
	sppp_chap_init(sp);
}

void
sppp_detach(struct ifnet *ifp)
{
	struct sppp **q, *p, *sp = (struct sppp*) ifp;
	int i;

	sppp_ipcp_destroy(sp);
	sppp_ipv6cp_destroy(sp);

	/* Remove the entry from the keepalive list. */
	for (q = &spppq; (p = *q); q = &p->pp_next)
		if (p == sp) {
			*q = p->pp_next;
			break;
		}

	/* Stop keepalive handler. */
	if (! spppq)
		UNTIMEOUT(sppp_keepalive, 0, keepalive_ch);

	for (i = 0; i < IDX_COUNT; i++)
		UNTIMEOUT((cps[i])->TO, (void *)sp, sp->ch[i]);
	UNTIMEOUT(sppp_pap_my_TO, (void *)sp, sp->pap_my_to_ch);

	/* release authentication data */
	if (sp->myauth.name != NULL)
		free(sp->myauth.name, M_DEVBUF, 0);
	if (sp->myauth.secret != NULL)
		free(sp->myauth.secret, M_DEVBUF, 0);
	if (sp->hisauth.name != NULL)
		free(sp->hisauth.name, M_DEVBUF, 0);
	if (sp->hisauth.secret != NULL)
		free(sp->hisauth.secret, M_DEVBUF, 0);
}

/*
 * Flush the interface output queue.
 */
void
sppp_flush(struct ifnet *ifp)
{
	struct sppp *sp = (struct sppp*) ifp;

	IFQ_PURGE(&sp->pp_if.if_snd);
	mq_purge(&sp->pp_cpq);
}

/*
 * Check if the output queue is empty.
 */
int
sppp_isempty(struct ifnet *ifp)
{
	struct sppp *sp = (struct sppp*) ifp;
	int empty, s;

	s = splnet();
	empty = mq_empty(&sp->pp_cpq) && IFQ_IS_EMPTY(&sp->pp_if.if_snd);
	splx(s);
	return (empty);
}

/*
 * Get next packet to send.
 */
struct mbuf *
sppp_dequeue(struct ifnet *ifp)
{
	struct sppp *sp = (struct sppp*) ifp;
	struct mbuf *m;
	int s;

	s = splnet();
	/*
	 * Process only the control protocol queue until we have at
	 * least one NCP open.
	 */
	m = mq_dequeue(&sp->pp_cpq);
	if (m == NULL && sppp_ncp_check(sp)) {
		IFQ_DEQUEUE (&sp->pp_if.if_snd, m);
	}
	splx(s);
	return m;
}

/*
 * Process an ioctl request.  Called on low priority level.
 */
int
sppp_ioctl(struct ifnet *ifp, u_long cmd, void *data)
{
	struct ifreq *ifr = data;
	struct sppp *sp = (struct sppp*) ifp;
	int s, rv, going_up, going_down, newmode;

	s = splnet();
	rv = 0;
	switch (cmd) {
	case SIOCSIFDSTADDR:
		break;

	case SIOCSIFADDR:
		if_up(ifp);
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		going_up = (ifp->if_flags & IFF_UP) &&
			(ifp->if_flags & IFF_RUNNING) == 0;
		going_down = (ifp->if_flags & IFF_UP) == 0 &&
			(ifp->if_flags & IFF_RUNNING);
		newmode = ifp->if_flags & (IFF_AUTO | IFF_PASSIVE);
		if (newmode == (IFF_AUTO | IFF_PASSIVE)) {
			/* sanity */
			newmode = IFF_PASSIVE;
			ifp->if_flags &= ~IFF_AUTO;
		}

		if (going_up || going_down)
			lcp.Close(sp);

		if (going_up && newmode == 0) {
			/* neither auto-dial nor passive */
			ifp->if_flags |= IFF_RUNNING;
			lcp.Open(sp);
		} else if (going_down) {
			sppp_flush(ifp);
			ifp->if_flags &= ~IFF_RUNNING;
		}
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu < 128 ||
		    (sp->lcp.their_mru > 0 &&
		     ifr->ifr_mtu > sp->lcp.their_mru)) {
			splx(s);
			return (EINVAL);
		}
		ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCGIFMTU:
		ifr->ifr_mtu = ifp->if_mtu;
		break;
	case SIOCGIFHARDMTU:
		ifr->ifr_hardmtu = ifp->if_hardmtu;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCGSPPPPARAMS:
		rv = sppp_get_params(sp, ifr);
		break;

	case SIOCSSPPPPARAMS:
		rv = sppp_set_params(sp, ifr);
		break;

	default:
		rv = ENOTTY;
	}
	splx(s);
	return rv;
}

/*
 * PPP protocol implementation.
 */

/*
 * Send PPP control protocol packet.
 */
void
sppp_cp_send(struct sppp *sp, u_short proto, u_char type,
	     u_char ident, u_short len, void *data)
{
	STDDCL;
	int s;
	struct lcp_header *lh;
	struct mbuf *m;

	if (len > MHLEN - PKTHDRLEN - LCP_HEADER_LEN)
		len = MHLEN - PKTHDRLEN - LCP_HEADER_LEN;
	MGETHDR (m, M_DONTWAIT, MT_DATA);
	if (! m)
		return;
	m->m_pkthdr.len = m->m_len = PKTHDRLEN + LCP_HEADER_LEN + len;
	m->m_pkthdr.ph_ifidx = 0;
	m->m_pkthdr.pf.prio = sp->pp_if.if_llprio;

	*mtod(m, u_int16_t *) = htons(proto);
	lh = (struct lcp_header *)(mtod(m, u_int8_t *) + 2);
	lh->type = type;
	lh->ident = ident;
	lh->len = htons (LCP_HEADER_LEN + len);
	if (len)
		bcopy (data, lh+1, len);

	if (debug) {
		log(LOG_DEBUG, SPP_FMT "%s output <%s id=0x%x len=%d",
		    SPP_ARGS(ifp),
		    sppp_proto_name(proto),
		    sppp_cp_type_name (lh->type), lh->ident,
		    ntohs (lh->len));
		if (len)
			sppp_print_bytes ((u_char*) (lh+1), len);
		addlog(">\n");
	}

	len = m->m_pkthdr.len + sp->pp_framebytes;
	if (mq_enqueue(&sp->pp_cpq, m) != 0) {
		ifp->if_oerrors++;
		return;
	}

	ifp->if_obytes += len;
	s = splnet();
	if_start(ifp);
	splx(s);
}

/*
 * Handle incoming PPP control protocol packets.
 */
void
sppp_cp_input(const struct cp *cp, struct sppp *sp, struct mbuf *m)
{
	STDDCL;
	struct lcp_header *h;
	int len = m->m_pkthdr.len;
	int rv;
	u_char *p;
	u_long nmagic;

	if (len < 4) {
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "%s invalid packet length: %d bytes\n",
			    SPP_ARGS(ifp), cp->name, len);
		return;
	}
	h = mtod (m, struct lcp_header*);
	if (debug) {
		log(LOG_DEBUG,
		    SPP_FMT "%s input(%s): <%s id=0x%x len=%d",
		    SPP_ARGS(ifp), cp->name,
		    sppp_state_name(sp->state[cp->protoidx]),
		    sppp_cp_type_name (h->type), h->ident, ntohs (h->len));
		if (len > 4)
			sppp_print_bytes ((u_char*) (h+1), len-4);
		addlog(">\n");
	}
	if (len > ntohs (h->len))
		len = ntohs (h->len);
	p = (u_char *)(h + 1);
	switch (h->type) {
	case CONF_REQ:
		if (len < 4) {
			if (debug)
				addlog(SPP_FMT "%s invalid conf-req length %d\n",
				       SPP_ARGS(ifp), cp->name,
				       len);
			++ifp->if_ierrors;
			break;
		}
		/* handle states where RCR doesn't get a SCA/SCN */
		switch (sp->state[cp->protoidx]) {
		case STATE_CLOSING:
		case STATE_STOPPING:
			return;
		case STATE_CLOSED:
			sppp_cp_send(sp, cp->proto, TERM_ACK, h->ident,
				     0, 0);
			return;
		}
		rv = (cp->RCR)(sp, h, len);
		/* silently drop illegal packets */
		if (rv == -1)
			return;
		switch (sp->state[cp->protoidx]) {
		case STATE_OPENED:
			sppp_cp_change_state(cp, sp, rv?
					     STATE_ACK_SENT: STATE_REQ_SENT);
			(cp->tld)(sp);
			(cp->scr)(sp);
			break;
		case STATE_ACK_SENT:
		case STATE_REQ_SENT:
			sppp_cp_change_state(cp, sp, rv?
					     STATE_ACK_SENT: STATE_REQ_SENT);
			break;
		case STATE_STOPPED:
			sp->rst_counter[cp->protoidx] = sp->lcp.max_configure;
			sppp_cp_change_state(cp, sp, rv?
					     STATE_ACK_SENT: STATE_REQ_SENT);
			(cp->scr)(sp);
			break;
		case STATE_ACK_RCVD:
			if (rv) {
				sppp_cp_change_state(cp, sp, STATE_OPENED);
				if (debug)
					log(LOG_DEBUG, SPP_FMT "%s tlu\n",
					    SPP_ARGS(ifp),
					    cp->name);
				(cp->tlu)(sp);
			} else
				sppp_cp_change_state(cp, sp, STATE_ACK_RCVD);
			break;
		default:
			/* printf(SPP_FMT "%s illegal %s in state %s\n",
			       SPP_ARGS(ifp), cp->name,
			       sppp_cp_type_name(h->type),
			       sppp_state_name(sp->state[cp->protoidx])); */
			++ifp->if_ierrors;
		}
		break;
	case CONF_ACK:
		if (h->ident != sp->confid[cp->protoidx]) {
			if (debug)
				addlog(SPP_FMT "%s id mismatch 0x%x != 0x%x\n",
				       SPP_ARGS(ifp), cp->name,
				       h->ident, sp->confid[cp->protoidx]);
			++ifp->if_ierrors;
			break;
		}
		switch (sp->state[cp->protoidx]) {
		case STATE_CLOSED:
		case STATE_STOPPED:
			sppp_cp_send(sp, cp->proto, TERM_ACK, h->ident, 0, 0);
			break;
		case STATE_CLOSING:
		case STATE_STOPPING:
			break;
		case STATE_REQ_SENT:
			sp->rst_counter[cp->protoidx] = sp->lcp.max_configure;
			sppp_cp_change_state(cp, sp, STATE_ACK_RCVD);
			break;
		case STATE_OPENED:
			sppp_cp_change_state(cp, sp, STATE_REQ_SENT);
			(cp->tld)(sp);
			(cp->scr)(sp);
			break;
		case STATE_ACK_RCVD:
			sppp_cp_change_state(cp, sp, STATE_REQ_SENT);
			(cp->scr)(sp);
			break;
		case STATE_ACK_SENT:
			sp->rst_counter[cp->protoidx] = sp->lcp.max_configure;
			sppp_cp_change_state(cp, sp, STATE_OPENED);
			if (debug)
				log(LOG_DEBUG, SPP_FMT "%s tlu\n",
				       SPP_ARGS(ifp), cp->name);
			(cp->tlu)(sp);
			break;
		default:
			/* printf(SPP_FMT "%s illegal %s in state %s\n",
			       SPP_ARGS(ifp), cp->name,
			       sppp_cp_type_name(h->type),
			       sppp_state_name(sp->state[cp->protoidx])); */
			++ifp->if_ierrors;
		}
		break;
	case CONF_NAK:
	case CONF_REJ:
		if (h->ident != sp->confid[cp->protoidx]) {
			if (debug)
				addlog(SPP_FMT "%s id mismatch 0x%x != 0x%x\n",
				       SPP_ARGS(ifp), cp->name,
				       h->ident, sp->confid[cp->protoidx]);
			++ifp->if_ierrors;
			break;
		}
		if (h->type == CONF_NAK)
			(cp->RCN_nak)(sp, h, len);
		else /* CONF_REJ */
			(cp->RCN_rej)(sp, h, len);

		switch (sp->state[cp->protoidx]) {
		case STATE_CLOSED:
		case STATE_STOPPED:
			sppp_cp_send(sp, cp->proto, TERM_ACK, h->ident, 0, 0);
			break;
		case STATE_REQ_SENT:
		case STATE_ACK_SENT:
			sp->rst_counter[cp->protoidx] = sp->lcp.max_configure;
			(cp->scr)(sp);
			break;
		case STATE_OPENED:
			sppp_cp_change_state(cp, sp, STATE_ACK_SENT);
			(cp->tld)(sp);
			(cp->scr)(sp);
			break;
		case STATE_ACK_RCVD:
			sppp_cp_change_state(cp, sp, STATE_ACK_SENT);
			(cp->scr)(sp);
			break;
		case STATE_CLOSING:
		case STATE_STOPPING:
			break;
		default:
			/* printf(SPP_FMT "%s illegal %s in state %s\n",
			       SPP_ARGS(ifp), cp->name,
			       sppp_cp_type_name(h->type),
			       sppp_state_name(sp->state[cp->protoidx])); */
			++ifp->if_ierrors;
		}
		break;

	case TERM_REQ:
		switch (sp->state[cp->protoidx]) {
		case STATE_ACK_RCVD:
		case STATE_ACK_SENT:
			sppp_cp_change_state(cp, sp, STATE_REQ_SENT);
			/* FALLTHROUGH */
		case STATE_CLOSED:
		case STATE_STOPPED:
		case STATE_CLOSING:
		case STATE_STOPPING:
		case STATE_REQ_SENT:
		  sta:
			/* Send Terminate-Ack packet. */
			if (debug)
				log(LOG_DEBUG, SPP_FMT "%s send terminate-ack\n",
				    SPP_ARGS(ifp), cp->name);
			sppp_cp_send(sp, cp->proto, TERM_ACK, h->ident, 0, 0);
			break;
		case STATE_OPENED:
			sp->rst_counter[cp->protoidx] = 0;
			sppp_cp_change_state(cp, sp, STATE_STOPPING);
			(cp->tld)(sp);
			goto sta;
			break;
		default:
			/* printf(SPP_FMT "%s illegal %s in state %s\n",
			       SPP_ARGS(ifp), cp->name,
			       sppp_cp_type_name(h->type),
			       sppp_state_name(sp->state[cp->protoidx])); */
			++ifp->if_ierrors;
		}
		break;
	case TERM_ACK:
		switch (sp->state[cp->protoidx]) {
		case STATE_CLOSED:
		case STATE_STOPPED:
		case STATE_REQ_SENT:
		case STATE_ACK_SENT:
			break;
		case STATE_CLOSING:
			sppp_cp_change_state(cp, sp, STATE_CLOSED);
			(cp->tlf)(sp);
			break;
		case STATE_STOPPING:
			sppp_cp_change_state(cp, sp, STATE_STOPPED);
			(cp->tlf)(sp);
			break;
		case STATE_ACK_RCVD:
			sppp_cp_change_state(cp, sp, STATE_REQ_SENT);
			break;
		case STATE_OPENED:
			sppp_cp_change_state(cp, sp, STATE_ACK_RCVD);
			(cp->tld)(sp);
			(cp->scr)(sp);
			break;
		default:
			/* printf(SPP_FMT "%s illegal %s in state %s\n",
			       SPP_ARGS(ifp), cp->name,
			       sppp_cp_type_name(h->type),
			       sppp_state_name(sp->state[cp->protoidx])); */
			++ifp->if_ierrors;
		}
		break;
	case CODE_REJ:
	case PROTO_REJ:
	    {
		int catastrophic = 0;
		const struct cp *upper = NULL;
		int i;
		u_int16_t proto;

		if (len < 2) {
			if (debug)
				log(LOG_DEBUG, SPP_FMT "invalid proto-rej length\n",
				       SPP_ARGS(ifp));
			++ifp->if_ierrors;
			break;
		}

		proto = ntohs(*((u_int16_t *)p));
		for (i = 0; i < IDX_COUNT; i++) {
			if (cps[i]->proto == proto) {
				upper = cps[i];
				break;
			}
		}
		if (upper == NULL)
			catastrophic++;

		if (catastrophic || debug)
			log(catastrophic? LOG_INFO: LOG_DEBUG,
			    SPP_FMT "%s: RXJ%c (%s) for proto 0x%x (%s/%s)\n",
			    SPP_ARGS(ifp), cp->name, catastrophic ? '-' : '+',
			    sppp_cp_type_name(h->type), proto,
			    upper ? upper->name : "unknown",
			    upper ? sppp_state_name(sp->state[upper->protoidx]) : "?");

		/*
		 * if we got RXJ+ against conf-req, the peer does not implement
		 * this particular protocol type.  terminate the protocol.
		 */
		if (upper) {
			if (sp->state[upper->protoidx] == STATE_REQ_SENT) {
				upper->Close(sp);
				break;
			}
		}

		/* XXX catastrophic rejects (RXJ-) aren't handled yet. */
		switch (sp->state[cp->protoidx]) {
		case STATE_CLOSED:
		case STATE_STOPPED:
		case STATE_REQ_SENT:
		case STATE_ACK_SENT:
		case STATE_CLOSING:
		case STATE_STOPPING:
		case STATE_OPENED:
			break;
		case STATE_ACK_RCVD:
			sppp_cp_change_state(cp, sp, STATE_REQ_SENT);
			break;
		default:
			/* printf(SPP_FMT "%s illegal %s in state %s\n",
			       SPP_ARGS(ifp), cp->name,
			       sppp_cp_type_name(h->type),
			       sppp_state_name(sp->state[cp->protoidx])); */
			++ifp->if_ierrors;
		}
		break;
	    }
	case DISC_REQ:
		if (cp->proto != PPP_LCP)
			goto illegal;
		/* Discard the packet. */
		break;
	case ECHO_REQ:
		if (cp->proto != PPP_LCP)
			goto illegal;
		if (sp->state[cp->protoidx] != STATE_OPENED) {
			if (debug)
				addlog(SPP_FMT "lcp echo req but lcp closed\n",
				       SPP_ARGS(ifp));
			++ifp->if_ierrors;
			break;
		}
		if (len < 8) {
			if (debug)
				addlog(SPP_FMT "invalid lcp echo request "
				       "packet length: %d bytes\n",
				       SPP_ARGS(ifp), len);
			break;
		}

		nmagic = (u_long)p[0] << 24 |
		    (u_long)p[1] << 16 | p[2] << 8 | p[3];

		if (nmagic == sp->lcp.magic) {
			/* Line loopback mode detected. */
			log(LOG_INFO, SPP_FMT "loopback\n", SPP_ARGS(ifp));
			/* Shut down the PPP link. */
			lcp.Close(sp);
			break;
		}

		p[0] = sp->lcp.magic >> 24;
		p[1] = sp->lcp.magic >> 16;
		p[2] = sp->lcp.magic >> 8;
		p[3] = sp->lcp.magic;

		if (debug)
			addlog(SPP_FMT "got lcp echo req, sending echo rep\n",
			       SPP_ARGS(ifp));
		sppp_cp_send (sp, PPP_LCP, ECHO_REPLY, h->ident, len-4, h+1);
		break;
	case ECHO_REPLY:
		if (cp->proto != PPP_LCP)
			goto illegal;
		if (h->ident != sp->lcp.echoid) {
			++ifp->if_ierrors;
			break;
		}
		if (len < 8) {
			if (debug)
				addlog(SPP_FMT "lcp invalid echo reply "
				       "packet length: %d bytes\n",
				       SPP_ARGS(ifp), len);
			break;
		}
		if (debug)
			addlog(SPP_FMT "lcp got echo rep\n",
			       SPP_ARGS(ifp));

		nmagic = (u_long)p[0] << 24 |
		    (u_long)p[1] << 16 | p[2] << 8 | p[3];

		if (nmagic != sp->lcp.magic)
			sp->pp_alivecnt = 0;
		break;
	default:
		/* Unknown packet type -- send Code-Reject packet. */
	  illegal:
		if (debug)
			addlog(SPP_FMT "%s send code-rej for 0x%x\n",
			       SPP_ARGS(ifp), cp->name, h->type);
		sppp_cp_send(sp, cp->proto, CODE_REJ, ++sp->pp_seq,
			     m->m_pkthdr.len, h);
		++ifp->if_ierrors;
	}
}


/*
 * The generic part of all Up/Down/Open/Close/TO event handlers.
 * Basically, the state transition handling in the automaton.
 */
void
sppp_up_event(const struct cp *cp, struct sppp *sp)
{
	STDDCL;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "%s up(%s)\n",
		    SPP_ARGS(ifp), cp->name,
		    sppp_state_name(sp->state[cp->protoidx]));

	switch (sp->state[cp->protoidx]) {
	case STATE_INITIAL:
		sppp_cp_change_state(cp, sp, STATE_CLOSED);
		break;
	case STATE_STARTING:
		sp->rst_counter[cp->protoidx] = sp->lcp.max_configure;
		sppp_cp_change_state(cp, sp, STATE_REQ_SENT);
		(cp->scr)(sp);
		break;
	default:
		/* printf(SPP_FMT "%s illegal up in state %s\n",
		       SPP_ARGS(ifp), cp->name,
		       sppp_state_name(sp->state[cp->protoidx])); */
		break;
	}
}

void
sppp_down_event(const struct cp *cp, struct sppp *sp)
{
	STDDCL;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "%s down(%s)\n",
		    SPP_ARGS(ifp), cp->name,
		    sppp_state_name(sp->state[cp->protoidx]));

	switch (sp->state[cp->protoidx]) {
	case STATE_CLOSED:
	case STATE_CLOSING:
		sppp_cp_change_state(cp, sp, STATE_INITIAL);
		break;
	case STATE_STOPPED:
		sppp_cp_change_state(cp, sp, STATE_STARTING);
		(cp->tls)(sp);
		break;
	case STATE_STOPPING:
	case STATE_REQ_SENT:
	case STATE_ACK_RCVD:
	case STATE_ACK_SENT:
		sppp_cp_change_state(cp, sp, STATE_STARTING);
		break;
	case STATE_OPENED:
		sppp_cp_change_state(cp, sp, STATE_STARTING);
		(cp->tld)(sp);
		break;
	default:
		/* printf(SPP_FMT "%s illegal down in state %s\n",
		       SPP_ARGS(ifp), cp->name,
		       sppp_state_name(sp->state[cp->protoidx])); */
		break;
	}
}


void
sppp_open_event(const struct cp *cp, struct sppp *sp)
{
	STDDCL;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "%s open(%s)\n",
		    SPP_ARGS(ifp), cp->name,
		    sppp_state_name(sp->state[cp->protoidx]));

	switch (sp->state[cp->protoidx]) {
	case STATE_INITIAL:
		sppp_cp_change_state(cp, sp, STATE_STARTING);
		(cp->tls)(sp);
		break;
	case STATE_STARTING:
		break;
	case STATE_CLOSED:
		sp->rst_counter[cp->protoidx] = sp->lcp.max_configure;
		sppp_cp_change_state(cp, sp, STATE_REQ_SENT);
		(cp->scr)(sp);
		break;
	case STATE_STOPPED:
	case STATE_STOPPING:
	case STATE_REQ_SENT:
	case STATE_ACK_RCVD:
	case STATE_ACK_SENT:
	case STATE_OPENED:
		break;
	case STATE_CLOSING:
		sppp_cp_change_state(cp, sp, STATE_STOPPING);
		break;
	}
}


void
sppp_close_event(const struct cp *cp, struct sppp *sp)
{
	STDDCL;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "%s close(%s)\n",
		    SPP_ARGS(ifp), cp->name,
		    sppp_state_name(sp->state[cp->protoidx]));

	switch (sp->state[cp->protoidx]) {
	case STATE_INITIAL:
	case STATE_CLOSED:
	case STATE_CLOSING:
		break;
	case STATE_STARTING:
		sppp_cp_change_state(cp, sp, STATE_INITIAL);
		(cp->tlf)(sp);
		break;
	case STATE_STOPPED:
		sppp_cp_change_state(cp, sp, STATE_CLOSED);
		break;
	case STATE_STOPPING:
		sppp_cp_change_state(cp, sp, STATE_CLOSING);
		break;
	case STATE_OPENED:
		sppp_cp_change_state(cp, sp, STATE_CLOSING);
		sp->rst_counter[cp->protoidx] = sp->lcp.max_terminate;
		sppp_cp_send(sp, cp->proto, TERM_REQ, ++sp->pp_seq, 0, 0);
		(cp->tld)(sp);
		break;
	case STATE_REQ_SENT:
	case STATE_ACK_RCVD:
	case STATE_ACK_SENT:
		sp->rst_counter[cp->protoidx] = sp->lcp.max_terminate;
		sppp_cp_send(sp, cp->proto, TERM_REQ, ++sp->pp_seq, 0, 0);
		sppp_cp_change_state(cp, sp, STATE_CLOSING);
		break;
	}
}

void
sppp_increasing_timeout (const struct cp *cp, struct sppp *sp)
{
	int timo;

	timo = sp->lcp.max_configure - sp->rst_counter[cp->protoidx];
	if (timo < 1)
		timo = 1;
	timeout_add(&sp->ch[cp->protoidx], timo * sp->lcp.timeout);
}

void
sppp_to_event(const struct cp *cp, struct sppp *sp)
{
	STDDCL;
	int s;

	s = splnet();
	if (debug)
		log(LOG_DEBUG, SPP_FMT "%s TO(%s) rst_counter = %d\n",
		    SPP_ARGS(ifp), cp->name,
		    sppp_state_name(sp->state[cp->protoidx]),
		    sp->rst_counter[cp->protoidx]);

	if (--sp->rst_counter[cp->protoidx] < 0)
		/* TO- event */
		switch (sp->state[cp->protoidx]) {
		case STATE_CLOSING:
			sppp_cp_change_state(cp, sp, STATE_CLOSED);
			(cp->tlf)(sp);
			break;
		case STATE_STOPPING:
			sppp_cp_change_state(cp, sp, STATE_STOPPED);
			(cp->tlf)(sp);
			break;
		case STATE_REQ_SENT:
		case STATE_ACK_RCVD:
		case STATE_ACK_SENT:
			sppp_cp_change_state(cp, sp, STATE_STOPPED);
			(cp->tlf)(sp);
			break;
		}
	else
		/* TO+ event */
		switch (sp->state[cp->protoidx]) {
		case STATE_CLOSING:
		case STATE_STOPPING:
			sppp_cp_send(sp, cp->proto, TERM_REQ, ++sp->pp_seq,
				     0, 0);
			sppp_increasing_timeout (cp, sp);
			break;
		case STATE_REQ_SENT:
		case STATE_ACK_RCVD:
			/* sppp_cp_change_state() will restart the timer */
			sppp_cp_change_state(cp, sp, STATE_REQ_SENT);
			(cp->scr)(sp);
			break;
		case STATE_ACK_SENT:
			sppp_increasing_timeout (cp, sp);
			(cp->scr)(sp);
			break;
		}

	splx(s);
}

/*
 * Change the state of a control protocol in the state automaton.
 * Takes care of starting/stopping the restart timer.
 */
void
sppp_cp_change_state(const struct cp *cp, struct sppp *sp, int newstate)
{
	STDDCL;

	if (debug && sp->state[cp->protoidx] != newstate)
		log(LOG_DEBUG, SPP_FMT "%s %s->%s\n",
		    SPP_ARGS(ifp), cp->name,
		    sppp_state_name(sp->state[cp->protoidx]),
		    sppp_state_name(newstate));
	sp->state[cp->protoidx] = newstate;

	switch (newstate) {
	case STATE_INITIAL:
	case STATE_STARTING:
	case STATE_CLOSED:
	case STATE_STOPPED:
	case STATE_OPENED:
		UNTIMEOUT(cp->TO, (void *)sp, sp->ch[cp->protoidx]);
		break;
	case STATE_CLOSING:
	case STATE_STOPPING:
	case STATE_REQ_SENT:
	case STATE_ACK_RCVD:
	case STATE_ACK_SENT:
		if (!timeout_pending(&sp->ch[cp->protoidx]))
			sppp_increasing_timeout (cp, sp);
		break;
	}
}
/*
 *--------------------------------------------------------------------------*
 *                                                                          *
 *                         The LCP implementation.                          *
 *                                                                          *
 *--------------------------------------------------------------------------*
 */
void
sppp_lcp_init(struct sppp *sp)
{
	sp->lcp.opts = (1 << LCP_OPT_MAGIC);
	sp->lcp.magic = 0;
	sp->state[IDX_LCP] = STATE_INITIAL;
	sp->fail_counter[IDX_LCP] = 0;
	sp->lcp.protos = 0;
	sp->lcp.mru = sp->pp_if.if_mtu;
	sp->lcp.their_mru = 0;

	/*
	 * Initialize counters and timeout values.  Note that we don't
	 * use the 3 seconds suggested in RFC 1661 since we are likely
	 * running on a fast link.  XXX We should probably implement
	 * the exponential backoff option.  Note that these values are
	 * relevant for all control protocols, not just LCP only.
	 */
	sp->lcp.timeout = 1 * hz;
	sp->lcp.max_terminate = 2;
	sp->lcp.max_configure = 10;
	sp->lcp.max_failure = 10;
}

void
sppp_lcp_up(struct sppp *sp)
{
	STDDCL;
	struct timeval tv;

	sp->pp_alivecnt = 0;
	sp->lcp.opts = (1 << LCP_OPT_MAGIC);
	sp->lcp.magic = 0;
	sp->lcp.protos = 0;
	if (sp->pp_if.if_mtu != PP_MTU) {
		sp->lcp.mru = sp->pp_if.if_mtu;
		sp->lcp.opts |= (1 << LCP_OPT_MRU);
	} else
		sp->lcp.mru = PP_MTU;
	sp->lcp.their_mru = PP_MTU;

	getmicrouptime(&tv);
	sp->pp_last_receive = sp->pp_last_activity = tv.tv_sec;

	/*
	 * If this interface is passive or dial-on-demand, and we are
	 * still in Initial state, it means we've got an incoming
	 * call.  Activate the interface.
	 */
	if ((ifp->if_flags & (IFF_AUTO | IFF_PASSIVE)) != 0) {
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "Up event", SPP_ARGS(ifp));
		ifp->if_flags |= IFF_RUNNING;
		if (sp->state[IDX_LCP] == STATE_INITIAL) {
			if (debug)
				addlog("(incoming call)\n");
			sp->pp_flags |= PP_CALLIN;
			lcp.Open(sp);
		} else if (debug)
			addlog("\n");
	} else if ((ifp->if_flags & (IFF_AUTO | IFF_PASSIVE)) == 0 &&
		   (sp->state[IDX_LCP] == STATE_INITIAL)) {
			ifp->if_flags |= IFF_RUNNING;
			lcp.Open(sp);
	}

	sppp_up_event(&lcp, sp);
}

void
sppp_lcp_down(struct sppp *sp)
{
	STDDCL;

	sppp_down_event(&lcp, sp);

	/*
	 * If this is neither a dial-on-demand nor a passive
	 * interface, simulate an ``ifconfig down'' action, so the
	 * administrator can force a redial by another ``ifconfig
	 * up''.  XXX For leased line operation, should we immediately
	 * try to reopen the connection here?
	 */
	if ((ifp->if_flags & (IFF_AUTO | IFF_PASSIVE)) == 0) {
		if (debug)
			log(LOG_DEBUG, SPP_FMT "Down event (carrier loss), "
			    "taking interface down.", SPP_ARGS(ifp));
		if_down(ifp);
	} else {
		if (debug)
			log(LOG_DEBUG, SPP_FMT "Down event (carrier loss)\n",
			    SPP_ARGS(ifp));
	}

	if (sp->state[IDX_LCP] != STATE_INITIAL)
		lcp.Close(sp);
	sp->lcp.their_mru = 0;
	sp->pp_flags &= ~PP_CALLIN;
	ifp->if_flags &= ~IFF_RUNNING;
	sppp_flush(ifp);
}

void
sppp_lcp_open(struct sppp *sp)
{
	/*
	 * If we are authenticator, negotiate LCP_AUTH
	 */
	if (sp->hisauth.proto != 0)
		sp->lcp.opts |= (1 << LCP_OPT_AUTH_PROTO);
	else
		sp->lcp.opts &= ~(1 << LCP_OPT_AUTH_PROTO);
	sp->pp_flags &= ~PP_NEEDAUTH;
	sppp_open_event(&lcp, sp);
}

void
sppp_lcp_close(struct sppp *sp)
{
	sppp_close_event(&lcp, sp);
}

void
sppp_lcp_TO(void *cookie)
{
	sppp_to_event(&lcp, (struct sppp *)cookie);
}

/*
 * Analyze a configure request.  Return true if it was agreeable, and
 * caused action sca, false if it has been rejected or nak'ed, and
 * caused action scn.  (The return value is used to make the state
 * transition decision in the state automaton.)
 */
int
sppp_lcp_RCR(struct sppp *sp, struct lcp_header *h, int len)
{
	STDDCL;
	u_char *buf, *r, *p;
	int origlen, rlen;
	u_long nmagic;
	u_short authproto;

	len -= 4;
	origlen = len;
	buf = r = malloc (len, M_TEMP, M_NOWAIT);
	if (! buf)
		return (0);

	if (debug)
		log(LOG_DEBUG, SPP_FMT "lcp parse opts: ",
		    SPP_ARGS(ifp));

	/* pass 1: check for things that need to be rejected */
	p = (void*) (h+1);
	for (rlen = 0; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len) {
			free(buf, M_TEMP, 0);
			return (-1);
		}
		if (debug)
			addlog("%s ", sppp_lcp_opt_name(*p));
		switch (*p) {
		case LCP_OPT_MAGIC:
			/* Magic number. */
			/* FALLTHROUGH, both are same length */
		case LCP_OPT_ASYNC_MAP:
			/* Async control character map. */
			if (len >= 6 && p[1] == 6)
				continue;
			if (debug)
				addlog("[invalid] ");
			break;
		case LCP_OPT_MRU:
			/* Maximum receive unit. */
			if (len >= 4 && p[1] == 4)
				continue;
			if (debug)
				addlog("[invalid] ");
			break;
		case LCP_OPT_AUTH_PROTO:
			if (len < 4) {
				if (debug)
					addlog("[invalid] ");
				break;
			}
			authproto = (p[2] << 8) + p[3];
			if (authproto == PPP_CHAP && p[1] != 5) {
				if (debug)
					addlog("[invalid chap len] ");
				break;
			}
			if (sp->myauth.proto == 0) {
				/* we are not configured to do auth */
				if (debug)
					addlog("[not configured] ");
				break;
			}
			/*
			 * Remote want us to authenticate, remember this,
			 * so we stay in PHASE_AUTHENTICATE after LCP got
			 * up.
			 */
			sp->pp_flags |= PP_NEEDAUTH;
			continue;
		default:
			/* Others not supported. */
			if (debug)
				addlog("[rej] ");
			break;
		}
		/* Add the option to rejected list. */
		bcopy (p, r, p[1]);
		r += p[1];
		rlen += p[1];
	}
	if (rlen) {
		if (debug)
			addlog(" send conf-rej\n");
		sppp_cp_send(sp, PPP_LCP, CONF_REJ, h->ident, rlen, buf);
		goto end;
	} else if (debug)
		addlog("\n");

	/*
	 * pass 2: check for option values that are unacceptable and
	 * thus require to be nak'ed.
	 */
	if (debug)
		log(LOG_DEBUG, SPP_FMT "lcp parse opt values: ",
		    SPP_ARGS(ifp));

	p = (void*) (h+1);
	len = origlen;
	for (rlen=0; len>1 && p[1]; len-=p[1], p+=p[1]) {
		if (debug)
			addlog("%s ", sppp_lcp_opt_name(*p));
		switch (*p) {
		case LCP_OPT_MAGIC:
			/* Magic number -- extract. */
			nmagic = (u_long)p[2] << 24 |
				(u_long)p[3] << 16 | p[4] << 8 | p[5];
			if (nmagic != sp->lcp.magic) {
				if (debug)
					addlog("0x%lx ", nmagic);
				continue;
			}
			if (debug)
				addlog("[glitch] ");
			++sp->pp_loopcnt;
			/*
			 * We negate our magic here, and NAK it.  If
			 * we see it later in an NAK packet, we
			 * suggest a new one.
			 */
			nmagic = ~sp->lcp.magic;
			/* Gonna NAK it. */
			p[2] = nmagic >> 24;
			p[3] = nmagic >> 16;
			p[4] = nmagic >> 8;
			p[5] = nmagic;
			break;

		case LCP_OPT_ASYNC_MAP:
			/* Async control character map -- check to be zero. */
			if (! p[2] && ! p[3] && ! p[4] && ! p[5]) {
				if (debug)
					addlog("[empty] ");
				continue;
			}
			if (debug)
				addlog("[non-empty] ");
			/* suggest a zero one */
			p[2] = p[3] = p[4] = p[5] = 0;
			break;

		case LCP_OPT_MRU:
			/*
			 * Maximum receive unit.  Always agreeable,
			 * but ignored by now.
			 */
			sp->lcp.their_mru = p[2] * 256 + p[3];
			if (debug)
				addlog("%lu ", sp->lcp.their_mru);
			continue;

		case LCP_OPT_AUTH_PROTO:
			authproto = (p[2] << 8) + p[3];
			if (sp->myauth.proto != authproto) {
				/* not agreed, nak */
				if (debug)
					addlog("[mine %s != his %s] ",
					       sppp_proto_name(sp->hisauth.proto),
					       sppp_proto_name(authproto));
				p[2] = sp->myauth.proto >> 8;
				p[3] = sp->myauth.proto;
				break;
			}
			if (authproto == PPP_CHAP && p[4] != CHAP_MD5) {
				if (debug)
					addlog("[chap not MD5] ");
				p[4] = CHAP_MD5;
				break;
			}
			continue;
		}
		/* Add the option to nak'ed list. */
		bcopy (p, r, p[1]);
		r += p[1];
		rlen += p[1];
	}
	if (rlen) {
		if (++sp->fail_counter[IDX_LCP] >= sp->lcp.max_failure) {
			if (debug)
				addlog(" max_failure (%d) exceeded, "
				       "send conf-rej\n",
				       sp->lcp.max_failure);
			sppp_cp_send(sp, PPP_LCP, CONF_REJ, h->ident, rlen, buf);
		} else {
			if (debug)
				addlog(" send conf-nak\n");
			sppp_cp_send(sp, PPP_LCP, CONF_NAK, h->ident, rlen, buf);
		}
		goto end;
	} else {
		if (debug)
			addlog("send conf-ack\n");
		sp->fail_counter[IDX_LCP] = 0;
		sp->pp_loopcnt = 0;
		sppp_cp_send (sp, PPP_LCP, CONF_ACK,
			      h->ident, origlen, h+1);
	}

 end:
	free(buf, M_TEMP, 0);
	return (rlen == 0);
}

/*
 * Analyze the LCP Configure-Reject option list, and adjust our
 * negotiation.
 */
void
sppp_lcp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len)
{
	STDDCL;
	u_char *p;

	len -= 4;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "lcp rej opts: ",
		    SPP_ARGS(ifp));

	p = (void*) (h+1);
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
		if (debug)
			addlog("%s ", sppp_lcp_opt_name(*p));
		switch (*p) {
		case LCP_OPT_MAGIC:
			/* Magic number -- can't use it, use 0 */
			sp->lcp.opts &= ~(1 << LCP_OPT_MAGIC);
			sp->lcp.magic = 0;
			break;
		case LCP_OPT_MRU:
			/*
			 * Should not be rejected anyway, since we only
			 * negotiate a MRU if explicitly requested by
			 * peer.
			 */
			sp->lcp.opts &= ~(1 << LCP_OPT_MRU);
			break;
		case LCP_OPT_AUTH_PROTO:
			/*
			 * Peer doesn't want to authenticate himself,
			 * deny unless this is a dialout call, and
			 * AUTHFLAG_NOCALLOUT is set.
			 */
			if ((sp->pp_flags & PP_CALLIN) == 0 &&
			    (sp->hisauth.flags & AUTHFLAG_NOCALLOUT) != 0) {
				if (debug)
					addlog("[don't insist on auth "
					       "for callout]");
				sp->lcp.opts &= ~(1 << LCP_OPT_AUTH_PROTO);
				break;
			}
			if (debug)
				addlog("[access denied]\n");
			lcp.Close(sp);
			break;
		}
	}
	if (debug)
		addlog("\n");
}

/*
 * Analyze the LCP Configure-NAK option list, and adjust our
 * negotiation.
 */
void
sppp_lcp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len)
{
	STDDCL;
	u_char *p;
	u_long magic;

	len -= 4;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "lcp nak opts: ",
		    SPP_ARGS(ifp));

	p = (void*) (h+1);
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
		if (debug)
			addlog("%s ", sppp_lcp_opt_name(*p));
		switch (*p) {
		case LCP_OPT_MAGIC:
			/* Magic number -- renegotiate */
			if ((sp->lcp.opts & (1 << LCP_OPT_MAGIC)) &&
			    len >= 6 && p[1] == 6) {
				magic = (u_long)p[2] << 24 |
					(u_long)p[3] << 16 | p[4] << 8 | p[5];
				/*
				 * If the remote magic is our negated one,
				 * this looks like a loopback problem.
				 * Suggest a new magic to make sure.
				 */
				if (magic == ~sp->lcp.magic) {
					if (debug)
						addlog("magic glitch ");
					sp->lcp.magic = arc4random();
				} else {
					sp->lcp.magic = magic;
					if (debug)
						addlog("%lu ", magic);
				}
			}
			break;
		case LCP_OPT_MRU:
			/*
			 * Peer wants to advise us to negotiate an MRU.
			 * Agree on it if it's reasonable, or use
			 * default otherwise.
			 */
			if (len >= 4 && p[1] == 4) {
				u_int mru = p[2] * 256 + p[3];
				if (debug)
					addlog("%d ", mru);
				if (mru < PP_MIN_MRU)
					mru = PP_MIN_MRU;
				if (mru > PP_MAX_MRU)
					mru = PP_MAX_MRU;
				sp->lcp.mru = mru;
				sp->lcp.opts |= (1 << LCP_OPT_MRU);
			}
			break;
		case LCP_OPT_AUTH_PROTO:
			/*
			 * Peer doesn't like our authentication method,
			 * deny.
			 */
			if (debug)
				addlog("[access denied]\n");
			lcp.Close(sp);
			break;
		}
	}
	if (debug)
		addlog("\n");
}

void
sppp_lcp_tlu(struct sppp *sp)
{
	struct ifnet *ifp = &sp->pp_if;
	int i;
	u_long mask;

	/* XXX ? */
	if (! (ifp->if_flags & IFF_UP) &&
	    (ifp->if_flags & IFF_RUNNING)) {
		/* Coming out of loopback mode. */
		if_up(ifp);
		if (ifp->if_flags & IFF_DEBUG)
			log(LOG_INFO, SPP_FMT "up\n", SPP_ARGS(ifp));
	}

	for (i = 0; i < IDX_COUNT; i++)
		if ((cps[i])->flags & CP_QUAL)
			(cps[i])->Open(sp);

	if ((sp->lcp.opts & (1 << LCP_OPT_AUTH_PROTO)) != 0 ||
	    (sp->pp_flags & PP_NEEDAUTH) != 0)
		sp->pp_phase = PHASE_AUTHENTICATE;
	else
		sp->pp_phase = PHASE_NETWORK;

	sppp_set_phase(sp);

	/*
	 * Open all authentication protocols.  This is even required
	 * if we already proceeded to network phase, since it might be
	 * that remote wants us to authenticate, so we might have to
	 * send a PAP request.  Undesired authentication protocols
	 * don't do anything when they get an Open event.
	 */
	for (i = 0; i < IDX_COUNT; i++)
		if ((cps[i])->flags & CP_AUTH)
			(cps[i])->Open(sp);

	if (sp->pp_phase == PHASE_NETWORK) {
		/* Notify all NCPs. */
		for (i = 0; i < IDX_COUNT; i++)
			if ((cps[i])->flags & CP_NCP)
				(cps[i])->Open(sp);
	}

	/* Send Up events to all started protos. */
	for (i = 0, mask = 1; i < IDX_COUNT; i++, mask <<= 1)
		if (sp->lcp.protos & mask && ((cps[i])->flags & CP_LCP) == 0)
			(cps[i])->Up(sp);

	/* notify low-level driver of state change */
	if (sp->pp_chg)
		sp->pp_chg(sp, (int)sp->pp_phase);

	if (sp->pp_phase == PHASE_NETWORK)
		/* if no NCP is starting, close down */
		sppp_lcp_check_and_close(sp);
}

void
sppp_lcp_tld(struct sppp *sp)
{
	int i;
	u_long mask;

	sp->pp_phase = PHASE_TERMINATE;

	sppp_set_phase(sp);

	/*
	 * Take upper layers down.  We send the Down event first and
	 * the Close second to prevent the upper layers from sending
	 * ``a flurry of terminate-request packets'', as the RFC
	 * describes it.
	 */
	for (i = 0, mask = 1; i < IDX_COUNT; i++, mask <<= 1)
		if (sp->lcp.protos & mask && ((cps[i])->flags & CP_LCP) == 0) {
			(cps[i])->Down(sp);
			(cps[i])->Close(sp);
		}
}

void
sppp_lcp_tls(struct sppp *sp)
{
	sp->pp_phase = PHASE_ESTABLISH;

	sppp_set_phase(sp);

	/* Notify lower layer if desired. */
	if (sp->pp_tls)
		(sp->pp_tls)(sp);
}

void
sppp_lcp_tlf(struct sppp *sp)
{
	sp->pp_phase = PHASE_DEAD;
	sppp_set_phase(sp);

	/* Notify lower layer if desired. */
	if (sp->pp_tlf)
		(sp->pp_tlf)(sp);
}

void
sppp_lcp_scr(struct sppp *sp)
{
	char opt[6 /* magicnum */ + 4 /* mru */ + 5 /* chap */];
	int i = 0;
	u_short authproto;

	if (sp->lcp.opts & (1 << LCP_OPT_MAGIC)) {
		if (! sp->lcp.magic)
			sp->lcp.magic = arc4random();
		opt[i++] = LCP_OPT_MAGIC;
		opt[i++] = 6;
		opt[i++] = sp->lcp.magic >> 24;
		opt[i++] = sp->lcp.magic >> 16;
		opt[i++] = sp->lcp.magic >> 8;
		opt[i++] = sp->lcp.magic;
	}

	if (sp->lcp.opts & (1 << LCP_OPT_MRU)) {
		opt[i++] = LCP_OPT_MRU;
		opt[i++] = 4;
		opt[i++] = sp->lcp.mru >> 8;
		opt[i++] = sp->lcp.mru;
	}

	if (sp->lcp.opts & (1 << LCP_OPT_AUTH_PROTO)) {
		authproto = sp->hisauth.proto;
		opt[i++] = LCP_OPT_AUTH_PROTO;
		opt[i++] = authproto == PPP_CHAP? 5: 4;
		opt[i++] = authproto >> 8;
		opt[i++] = authproto;
		if (authproto == PPP_CHAP)
			opt[i++] = CHAP_MD5;
	}

	sp->confid[IDX_LCP] = ++sp->pp_seq;
	sppp_cp_send (sp, PPP_LCP, CONF_REQ, sp->confid[IDX_LCP], i, opt);
}

/*
 * Check the open NCPs, return true if at least one NCP is open.
 */
int
sppp_ncp_check(struct sppp *sp)
{
	int i, mask;

	for (i = 0, mask = 1; i < IDX_COUNT; i++, mask <<= 1)
		if (sp->lcp.protos & mask && (cps[i])->flags & CP_NCP)
			return 1;
	return 0;
}

/*
 * Re-check the open NCPs and see if we should terminate the link.
 * Called by the NCPs during their tlf action handling.
 */
void
sppp_lcp_check_and_close(struct sppp *sp)
{

	if (sp->pp_phase < PHASE_NETWORK)
		/* don't bother, we are already going down */
		return;

	if (sppp_ncp_check(sp))
		return;

	lcp.Close(sp);
}
/*
 *--------------------------------------------------------------------------*
 *                                                                          *
 *                        The IPCP implementation.                          *
 *                                                                          *
 *--------------------------------------------------------------------------*
 */

void
sppp_ipcp_init(struct sppp *sp)
{
	sp->ipcp.opts = 0;
	sp->ipcp.flags = 0;
	sp->state[IDX_IPCP] = STATE_INITIAL;
	sp->fail_counter[IDX_IPCP] = 0;
	task_set(&sp->ipcp.set_addr_task, sppp_set_ip_addrs, sp);
	task_set(&sp->ipcp.clear_addr_task, sppp_clear_ip_addrs, sp);
}

void
sppp_ipcp_destroy(struct sppp *sp)
{
	task_del(systq, &sp->ipcp.set_addr_task);
	task_del(systq, &sp->ipcp.clear_addr_task);
}

void
sppp_ipcp_up(struct sppp *sp)
{
	sppp_up_event(&ipcp, sp);
}

void
sppp_ipcp_down(struct sppp *sp)
{
	sppp_down_event(&ipcp, sp);
}

void
sppp_ipcp_open(struct sppp *sp)
{
	sppp_open_event(&ipcp, sp);
}

void
sppp_ipcp_close(struct sppp *sp)
{
	sppp_close_event(&ipcp, sp);
}

void
sppp_ipcp_TO(void *cookie)
{
	sppp_to_event(&ipcp, (struct sppp *)cookie);
}

/*
 * Analyze a configure request.  Return true if it was agreeable, and
 * caused action sca, false if it has been rejected or nak'ed, and
 * caused action scn.  (The return value is used to make the state
 * transition decision in the state automaton.)
 */
int
sppp_ipcp_RCR(struct sppp *sp, struct lcp_header *h, int len)
{
	u_char *buf, *r, *p;
	struct ifnet *ifp = &sp->pp_if;
	int rlen, origlen, debug = ifp->if_flags & IFF_DEBUG;
	u_int32_t hisaddr, desiredaddr;

	len -= 4;
	origlen = len;
	/*
	 * Make sure to allocate a buf that can at least hold a
	 * conf-nak with an `address' option.  We might need it below.
	 */
	buf = r = malloc ((len < 6? 6: len), M_TEMP, M_NOWAIT);
	if (! buf)
		return (0);

	/* pass 1: see if we can recognize them */
	if (debug)
		log(LOG_DEBUG, SPP_FMT "ipcp parse opts: ",
		    SPP_ARGS(ifp));
	p = (void*) (h+1);
	for (rlen = 0; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len) {
			free(buf, M_TEMP, 0);
			return (-1);
		}
		if (debug)
			addlog("%s ", sppp_ipcp_opt_name(*p));
		switch (*p) {
#ifdef notyet
		case IPCP_OPT_COMPRESSION:
			if (len >= 6 && p[1] >= 6) {
				/* correctly formed compress option */
				continue;
			}
			if (debug)
				addlog("[invalid] ");
			break;
#endif
		case IPCP_OPT_ADDRESS:
			if (len >= 6 && p[1] == 6) {
				/* correctly formed address option */
				continue;
			}
			if (debug)
				addlog("[invalid] ");
			break;
		default:
			/* Others not supported. */
			if (debug)
				addlog("[rej] ");
			break;
		}
		/* Add the option to rejected list. */
		bcopy (p, r, p[1]);
		r += p[1];
		rlen += p[1];
	}
	if (rlen) {
		if (debug)
			addlog(" send conf-rej\n");
		sppp_cp_send(sp, PPP_IPCP, CONF_REJ, h->ident, rlen, buf);
		goto end;
	} else if (debug)
		addlog("\n");

	/* pass 2: parse option values */
	if (sp->ipcp.flags & IPCP_HISADDR_SEEN)
		hisaddr = sp->ipcp.req_hisaddr; /* we already agreed on that */
	else
		sppp_get_ip_addrs(sp, 0, &hisaddr, 0); /* user configuration */
	if (debug)
		log(LOG_DEBUG, SPP_FMT "ipcp parse opt values: ",
		       SPP_ARGS(ifp));
	p = (void*) (h+1);
	len = origlen;
	for (rlen=0; len>1 && p[1]; len-=p[1], p+=p[1]) {
		if (debug)
			addlog(" %s ", sppp_ipcp_opt_name(*p));
		switch (*p) {
#ifdef notyet
		case IPCP_OPT_COMPRESSION:
			continue;
#endif
		case IPCP_OPT_ADDRESS:
			desiredaddr = p[2] << 24 | p[3] << 16 |
				p[4] << 8 | p[5];
			if (desiredaddr == hisaddr ||
			    ((sp->ipcp.flags & IPCP_HISADDR_DYN) &&
			    desiredaddr != 0)) {
				/*
				 * Peer's address is same as our value,
				 * or we have set it to 0.0.0.1 to
				 * indicate that we do not really care,
				 * this is agreeable.  Gonna conf-ack
				 * it.
				 */
				if (debug)
					addlog("%s [ack] ",
					       sppp_dotted_quad(desiredaddr));
				/* record that we've seen it already */
				sp->ipcp.flags |= IPCP_HISADDR_SEEN;
				sp->ipcp.req_hisaddr = desiredaddr;
				hisaddr = desiredaddr;
				continue;
			}
			/*
			 * The address wasn't agreeable.  This is either
			 * he sent us 0.0.0.0, asking to assign him an
			 * address, or he send us another address not
			 * matching our value.  Either case, we gonna
			 * conf-nak it with our value.
			 */
			if (debug) {
				if (desiredaddr == 0)
					addlog("[addr requested] ");
				else
					addlog("%s [not agreed] ",
					       sppp_dotted_quad(desiredaddr));
			}

			p[2] = hisaddr >> 24;
			p[3] = hisaddr >> 16;
			p[4] = hisaddr >> 8;
			p[5] = hisaddr;
			break;
		}
		/* Add the option to nak'ed list. */
		bcopy (p, r, p[1]);
		r += p[1];
		rlen += p[1];
	}

	/*
	 * If we are about to conf-ack the request, but haven't seen
	 * his address so far, gonna conf-nak it instead, with the
	 * `address' option present and our idea of his address being
	 * filled in there, to request negotiation of both addresses.
	 *
	 * XXX This can result in an endless req - nak loop if peer
	 * doesn't want to send us his address.  Q: What should we do
	 * about it?  XXX  A: implement the max-failure counter.
	 */
	if (rlen == 0 && !(sp->ipcp.flags & IPCP_HISADDR_SEEN)) {
		buf[0] = IPCP_OPT_ADDRESS;
		buf[1] = 6;
		buf[2] = hisaddr >> 24;
		buf[3] = hisaddr >> 16;
		buf[4] = hisaddr >> 8;
		buf[5] = hisaddr;
		rlen = 6;
		if (debug)
			addlog("still need hisaddr ");
	}

	if (rlen) {
		if (debug)
			addlog(" send conf-nak\n");
		sppp_cp_send (sp, PPP_IPCP, CONF_NAK, h->ident, rlen, buf);
	} else {
		if (debug)
			addlog(" send conf-ack\n");
		sppp_cp_send (sp, PPP_IPCP, CONF_ACK,
			      h->ident, origlen, h+1);
	}

 end:
	free(buf, M_TEMP, 0);
	return (rlen == 0);
}

/*
 * Analyze the IPCP Configure-Reject option list, and adjust our
 * negotiation.
 */
void
sppp_ipcp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len)
{
	u_char *p;
	struct ifnet *ifp = &sp->pp_if;
	int debug = ifp->if_flags & IFF_DEBUG;

	len -= 4;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "ipcp rej opts: ",
		    SPP_ARGS(ifp));

	p = (void*) (h+1);
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
		if (debug)
			addlog("%s ", sppp_ipcp_opt_name(*p));
		switch (*p) {
		case IPCP_OPT_ADDRESS:
			/*
			 * Peer doesn't grok address option.  This is
			 * bad.  XXX  Should we better give up here?
			 */
			sp->ipcp.opts &= ~(1 << IPCP_OPT_ADDRESS);
			break;
#ifdef notyet
		case IPCP_OPT_COMPRESS:
			sp->ipcp.opts &= ~(1 << IPCP_OPT_COMPRESS);
			break;
#endif
		}
	}
	if (debug)
		addlog("\n");
}

/*
 * Analyze the IPCP Configure-NAK option list, and adjust our
 * negotiation.
 */
void
sppp_ipcp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len)
{
	u_char *p;
	struct ifnet *ifp = &sp->pp_if;
	int debug = ifp->if_flags & IFF_DEBUG;
	u_int32_t wantaddr;

	len -= 4;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "ipcp nak opts: ",
		    SPP_ARGS(ifp));

	p = (void*) (h+1);
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
		if (debug)
			addlog("%s ", sppp_ipcp_opt_name(*p));
		switch (*p) {
		case IPCP_OPT_ADDRESS:
			/*
			 * Peer doesn't like our local IP address.  See
			 * if we can do something for him.  We'll drop
			 * him our address then.
			 */
			if (len >= 6 && p[1] == 6) {
				wantaddr = p[2] << 24 | p[3] << 16 |
					p[4] << 8 | p[5];
				sp->ipcp.opts |= (1 << IPCP_OPT_ADDRESS);
				if (debug)
					addlog("[wantaddr %s] ",
					       sppp_dotted_quad(wantaddr));
				/*
				 * When doing dynamic address assignment,
				 * we accept his offer.  Otherwise, we
				 * ignore it and thus continue to negotiate
				 * our already existing value.
				 */
				if (sp->ipcp.flags & IPCP_MYADDR_DYN) {
					if (debug)
						addlog("[agree] ");
					sp->ipcp.flags |= IPCP_MYADDR_SEEN;
					sp->ipcp.req_myaddr = wantaddr;
				}
			}
			break;
#ifdef notyet
		case IPCP_OPT_COMPRESS:
			/*
			 * Peer wants different compression parameters.
			 */
			break;
#endif
		}
	}
	if (debug)
		addlog("\n");
}

void
sppp_ipcp_tlu(struct sppp *sp)
{
	if (sp->ipcp.req_myaddr != 0 || sp->ipcp.req_hisaddr != 0)
		task_add(systq, &sp->ipcp.set_addr_task);
}

void
sppp_ipcp_tld(struct sppp *sp)
{
}

void
sppp_ipcp_tls(struct sppp *sp)
{
	STDDCL;
	u_int32_t myaddr, hisaddr;

	sp->ipcp.flags &= ~(IPCP_HISADDR_SEEN|IPCP_MYADDR_SEEN|
	    IPCP_MYADDR_DYN|IPCP_HISADDR_DYN);
	sp->ipcp.req_myaddr = 0;
	sp->ipcp.req_hisaddr = 0;

	sppp_get_ip_addrs(sp, &myaddr, &hisaddr, 0);
	/*
	 * If we don't have his address, this probably means our
	 * interface doesn't want to talk IP at all.  (This could
	 * be the case if somebody wants to speak only IPX, for
	 * example.)  Don't open IPCP in this case.
	 */
	if (hisaddr == 0) {
		/* XXX this message should go away */
		if (debug)
			log(LOG_DEBUG, SPP_FMT "ipcp_open(): no IP interface\n",
			    SPP_ARGS(ifp));
		return;
	}

	if (myaddr == 0) {
		/*
		 * I don't have an assigned address, so i need to
		 * negotiate my address.
		 */
		sp->ipcp.flags |= IPCP_MYADDR_DYN;
		sp->ipcp.opts |= (1 << IPCP_OPT_ADDRESS);
	}
	if (hisaddr >= 1 && hisaddr <= 255) {
		/*
		 * XXX - remove this hack!
		 * remote has no valid address, we need to get one assigned.
		 */
		sp->ipcp.flags |= IPCP_HISADDR_DYN;
	}

	/* indicate to LCP that it must stay alive */
	sp->lcp.protos |= (1 << IDX_IPCP);
}

void
sppp_ipcp_tlf(struct sppp *sp)
{
	if (sp->ipcp.flags & (IPCP_MYADDR_DYN|IPCP_HISADDR_DYN))
		/* Some address was dynamic, clear it again. */
		task_add(systq, &sp->ipcp.clear_addr_task);

	/* we no longer need LCP */
	sp->lcp.protos &= ~(1 << IDX_IPCP);
	sppp_lcp_check_and_close(sp);
}

void
sppp_ipcp_scr(struct sppp *sp)
{
	char opt[6 /* compression */ + 6 /* address */];
	u_int32_t ouraddr;
	int i = 0;

#ifdef notyet
	if (sp->ipcp.opts & (1 << IPCP_OPT_COMPRESSION)) {
		opt[i++] = IPCP_OPT_COMPRESSION;
		opt[i++] = 6;
		opt[i++] = 0;	/* VJ header compression */
		opt[i++] = 0x2d; /* VJ header compression */
		opt[i++] = max_slot_id;
		opt[i++] = comp_slot_id;
	}
#endif

	if (sp->ipcp.opts & (1 << IPCP_OPT_ADDRESS)) {
		if (sp->ipcp.flags & IPCP_MYADDR_SEEN)
			/* not sure if this can ever happen */
			ouraddr = sp->ipcp.req_myaddr;
		else
			sppp_get_ip_addrs(sp, &ouraddr, 0, 0);
		opt[i++] = IPCP_OPT_ADDRESS;
		opt[i++] = 6;
		opt[i++] = ouraddr >> 24;
		opt[i++] = ouraddr >> 16;
		opt[i++] = ouraddr >> 8;
		opt[i++] = ouraddr;
	}

	sp->confid[IDX_IPCP] = ++sp->pp_seq;
	sppp_cp_send(sp, PPP_IPCP, CONF_REQ, sp->confid[IDX_IPCP], i, opt);
}

/*
 *--------------------------------------------------------------------------*
 *                                                                          *
 *                      The IPv6CP implementation.                          *
 *                                                                          *
 *--------------------------------------------------------------------------*
 */

#ifdef INET6
void
sppp_ipv6cp_init(struct sppp *sp)
{
	sp->ipv6cp.opts = 0;
	sp->ipv6cp.flags = 0;
	sp->state[IDX_IPV6CP] = STATE_INITIAL;
	sp->fail_counter[IDX_IPV6CP] = 0;
	task_set(&sp->ipv6cp.set_addr_task, sppp_update_ip6_addr, sp);
}

void
sppp_ipv6cp_destroy(struct sppp *sp)
{
	task_del(systq, &sp->ipv6cp.set_addr_task);
}

void
sppp_ipv6cp_up(struct sppp *sp)
{
	sppp_up_event(&ipv6cp, sp);
}

void
sppp_ipv6cp_down(struct sppp *sp)
{
	sppp_down_event(&ipv6cp, sp);
}

void
sppp_ipv6cp_open(struct sppp *sp)
{
	STDDCL;
	struct in6_addr myaddr, hisaddr;

	sp->ipv6cp.flags &= ~(IPV6CP_MYIFID_SEEN|IPV6CP_MYIFID_DYN);

	sppp_get_ip6_addrs(sp, &myaddr, &hisaddr, NULL);
	/*
	 * If we don't have our address, this probably means our
	 * interface doesn't want to talk IPv6 at all.  (This could
	 * be the case if the IFXF_NOINET6 flag is set, for
	 * example.)  Don't open IPv6CP in this case.
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&myaddr)) {
		/* XXX this message should go away */
		if (debug)
			log(LOG_DEBUG, SPP_FMT "ipv6cp_open(): no IPv6 interface\n",
			    SPP_ARGS(ifp));
		return;
	}
	sp->ipv6cp.opts |= (1 << IPV6CP_OPT_IFID);
	sppp_open_event(&ipv6cp, sp);
}

void
sppp_ipv6cp_close(struct sppp *sp)
{
	sppp_close_event(&ipv6cp, sp);
}

void
sppp_ipv6cp_TO(void *cookie)
{
	sppp_to_event(&ipv6cp, (struct sppp *)cookie);
}

int
sppp_ipv6cp_RCR(struct sppp *sp, struct lcp_header *h, int len)
{
	u_char *buf, *r, *p;
	struct ifnet *ifp = &sp->pp_if;
	int rlen, origlen, debug = ifp->if_flags & IFF_DEBUG;
	struct in6_addr myaddr, desiredaddr, suggestaddr;
	int ifidcount;
	int type;
	int collision, nohisaddr;
	char addr[INET6_ADDRSTRLEN];

	len -= 4;
	origlen = len;
	/*
	 * Make sure to allocate a buf that can at least hold a
	 * conf-nak with an `address' option.  We might need it below.
	 */
	buf = r = malloc ((len < 6? 6: len), M_TEMP, M_NOWAIT);
	if (! buf)
		return (0);

	/* pass 1: see if we can recognize them */
	if (debug)
		log(LOG_DEBUG, "%s: ipv6cp parse opts:",
		    SPP_ARGS(ifp));
	p = (void *)(h + 1);
	ifidcount = 0;
	for (rlen=0; len>1 && p[1]; len-=p[1], p+=p[1]) {
		/* Sanity check option length */
		if (p[1] < 2 || p[1] > len) {
			free(buf, M_TEMP, 0);
			return (-1);
		}
		if (debug)
			addlog(" %s", sppp_ipv6cp_opt_name(*p));
		switch (*p) {
		case IPV6CP_OPT_IFID:
			if (len >= 10 && p[1] == 10 && ifidcount == 0) {
				/* correctly formed address option */
				ifidcount++;
				continue;
			}
			if (debug)
				addlog(" [invalid]");
			break;
#ifdef notyet
		case IPV6CP_OPT_COMPRESSION:
			if (len >= 4 && p[1] >= 4) {
				/* correctly formed compress option */
				continue;
			}
			if (debug)
				addlog(" [invalid]");
			break;
#endif
		default:
			/* Others not supported. */
			if (debug)
				addlog(" [rej]");
			break;
		}
		/* Add the option to rejected list. */
		bcopy (p, r, p[1]);
		r += p[1];
		rlen += p[1];
	}
	if (rlen) {
		if (debug)
			addlog(" send conf-rej\n");
		sppp_cp_send(sp, PPP_IPV6CP, CONF_REJ, h->ident, rlen, buf);
		goto end;
	} else if (debug)
		addlog("\n");

	/* pass 2: parse option values */
	if (sp->ipv6cp.flags & IPV6CP_MYIFID_DYN)
		myaddr = sp->ipv6cp.req_ifid.ifra_addr.sin6_addr;
	else
		sppp_get_ip6_addrs(sp, &myaddr, NULL, NULL);
	if (debug)
		log(LOG_DEBUG, "%s: ipv6cp parse opt values: ",
		       SPP_ARGS(ifp));
	p = (void *)(h + 1);
	len = origlen;
	type = CONF_ACK;
	for (rlen=0; len>1 && p[1]; len-=p[1], p+=p[1]) {
		if (debug)
			addlog(" %s", sppp_ipv6cp_opt_name(*p));
		switch (*p) {
#ifdef notyet
		case IPV6CP_OPT_COMPRESSION:
			continue;
#endif
		case IPV6CP_OPT_IFID:
			memset(&desiredaddr, 0, sizeof(desiredaddr));
			bcopy(&p[2], &desiredaddr.s6_addr[8], 8);
			collision = (memcmp(&desiredaddr.s6_addr[8],
					&myaddr.s6_addr[8], 8) == 0);
			nohisaddr = IN6_IS_ADDR_UNSPECIFIED(&desiredaddr);

			desiredaddr.s6_addr16[0] = htons(0xfe80);

			if (!collision && !nohisaddr) {
				/* no collision, hisaddr known - Conf-Ack */
				type = CONF_ACK;

				if (debug) {
					addlog(" %s [%s]",
					    inet_ntop(AF_INET6, &desiredaddr,
						addr, sizeof(addr)),
					    sppp_cp_type_name(type));
				}
				sppp_set_ip6_addr(sp, &myaddr, &desiredaddr);
				continue;
			}

			memset(&suggestaddr, 0, sizeof(suggestaddr));
			if (collision && nohisaddr) {
				/* collision, hisaddr unknown - Conf-Rej */
				type = CONF_REJ;
				memset(&p[2], 0, 8);
			} else {
				/*
				 * - no collision, hisaddr unknown, or
				 * - collision, hisaddr known
				 * Conf-Nak, suggest hisaddr
				 */
				type = CONF_NAK;
				sppp_suggest_ip6_addr(sp, &suggestaddr);
				bcopy(&suggestaddr.s6_addr[8], &p[2], 8);
			}
			if (debug)
				addlog(" %s [%s]",
				    inet_ntop(AF_INET6, &desiredaddr, addr,
					sizeof(addr)),
				    sppp_cp_type_name(type));
			break;
		}
		/* Add the option to nak'ed list. */
		bcopy (p, r, p[1]);
		r += p[1];
		rlen += p[1];
	}

	if (rlen == 0 && type == CONF_ACK) {
		if (debug)
			addlog(" send %s\n", sppp_cp_type_name(type));
		sppp_cp_send(sp, PPP_IPV6CP, type, h->ident, origlen, h + 1);
	} else {
#ifdef notdef
		if (type == CONF_ACK)
			panic("IPv6CP RCR: CONF_ACK with non-zero rlen");
#endif

		if (debug) {
			addlog(" send %s suggest %s\n",
			    sppp_cp_type_name(type),
			    inet_ntop(AF_INET6, &suggestaddr, addr,
				sizeof(addr)));
		}
		sppp_cp_send(sp, PPP_IPV6CP, type, h->ident, rlen, buf);
	}

end:
	free(buf, M_TEMP, 0);
	return (rlen == 0);
}

void
sppp_ipv6cp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len)
{
	u_char *p;
	struct ifnet *ifp = &sp->pp_if;
	int debug = ifp->if_flags & IFF_DEBUG;

	len -= 4;

	if (debug)
		log(LOG_DEBUG, "%s: ipv6cp rej opts:",
		    SPP_ARGS(ifp));

	p = (void *)(h + 1);
	for (; len > 1 && p[1]; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
		if (debug)
			addlog(" %s", sppp_ipv6cp_opt_name(*p));
		switch (*p) {
		case IPV6CP_OPT_IFID:
			/*
			 * Peer doesn't grok address option.  This is
			 * bad.  XXX  Should we better give up here?
			 */
			sp->ipv6cp.opts &= ~(1 << IPV6CP_OPT_IFID);
			break;
#ifdef notyet
		case IPV6CP_OPT_COMPRESS:
			sp->ipv6cp.opts &= ~(1 << IPV6CP_OPT_COMPRESS);
			break;
#endif
		}
	}
	if (debug)
		addlog("\n");
	return;
}

void
sppp_ipv6cp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len)
{
	u_char *p;
	struct ifnet *ifp = &sp->pp_if;
	int debug = ifp->if_flags & IFF_DEBUG;
	struct in6_addr suggestaddr;
	char addr[INET6_ADDRSTRLEN];

	len -= 4;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "ipv6cp nak opts: ",
		    SPP_ARGS(ifp));

	p = (void*) (h+1);
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
		if (debug)
			addlog("%s ", sppp_ipv6cp_opt_name(*p));
		switch (*p) {
		case IPV6CP_OPT_IFID:
			/*
			 * Peer doesn't like our local ifid.  See
			 * if we can do something for him.  We'll drop
			 * him our address then.
			 */
			if (len < 10 || p[1] != 10)
				break;
			sp->ipv6cp.flags |= IPV6CP_MYIFID_DYN;
			memset(&suggestaddr, 0, sizeof(suggestaddr));
			bcopy(&p[2], &suggestaddr.s6_addr[8], 8);
			if (IN6_IS_ADDR_UNSPECIFIED(&suggestaddr) ||
			    (sp->ipv6cp.flags & IPV6CP_MYIFID_SEEN)) {
				/*
				 * The peer didn't suggest anything,
				 * or wants us to change a previously
				 * suggested address.
				 * Configure a new address for us.
				 */
				sppp_suggest_ip6_addr(sp, &suggestaddr);
				sppp_set_ip6_addr(sp, &suggestaddr, NULL);
				sp->ipv6cp.flags &= ~IPV6CP_MYIFID_SEEN;
			} else {
				/* Configure address suggested by peer. */
				suggestaddr.s6_addr16[0] = htons(0xfe80);
				sp->ipv6cp.opts |= (1 << IPV6CP_OPT_IFID);
				if (debug)
					addlog(" [suggestaddr %s]",
					    inet_ntop(AF_INET6, &suggestaddr,
					        addr, sizeof(addr)));
				sppp_set_ip6_addr(sp, &suggestaddr, NULL);
				if (debug)
					addlog(" [agree]");
				sp->ipv6cp.flags |= IPV6CP_MYIFID_SEEN;
			}
			break;
#ifdef notyet
		case IPV6CP_OPT_COMPRESS:
			/*
			 * Peer wants different compression parameters.
			 */
			break;
#endif
		}
	}
	if (debug)
		addlog("\n");
}

void
sppp_ipv6cp_tlu(struct sppp *sp)
{
}

void
sppp_ipv6cp_tld(struct sppp *sp)
{
}

void
sppp_ipv6cp_tls(struct sppp *sp)
{
	/* indicate to LCP that it must stay alive */
	sp->lcp.protos |= (1 << IDX_IPV6CP);
}

void
sppp_ipv6cp_tlf(struct sppp *sp)
{
	/* we no longer need LCP */
	sp->lcp.protos &= ~(1 << IDX_IPV6CP);
	sppp_lcp_check_and_close(sp);
}

void
sppp_ipv6cp_scr(struct sppp *sp)
{
	char opt[10 /* ifid */ + 4 /* compression, minimum */];
	struct in6_addr ouraddr;
	int i = 0;

	if (sp->ipv6cp.opts & (1 << IPV6CP_OPT_IFID)) {
		if (sp->ipv6cp.flags & IPV6CP_MYIFID_DYN)
			ouraddr = sp->ipv6cp.req_ifid.ifra_addr.sin6_addr;
		else
			sppp_get_ip6_addrs(sp, &ouraddr, NULL, NULL);
		opt[i++] = IPV6CP_OPT_IFID;
		opt[i++] = 10;
		bcopy(&ouraddr.s6_addr[8], &opt[i], 8);
		i += 8;
	}

#ifdef notyet
	if (sp->ipv6cp.opts & (1 << IPV6CP_OPT_COMPRESSION)) {
		opt[i++] = IPV6CP_OPT_COMPRESSION;
		opt[i++] = 4;
		opt[i++] = 0;   /* TBD */
		opt[i++] = 0;   /* TBD */
		/* variable length data may follow */
	}
#endif

	sp->confid[IDX_IPV6CP] = ++sp->pp_seq;
	sppp_cp_send(sp, PPP_IPV6CP, CONF_REQ, sp->confid[IDX_IPV6CP], i, opt);
}
#else /*INET6*/
void
sppp_ipv6cp_init(struct sppp *sp)
{
}

void
sppp_ipv6cp_destroy(struct sppp *sp)
{
}

void
sppp_ipv6cp_up(struct sppp *sp)
{
}

void
sppp_ipv6cp_down(struct sppp *sp)
{
}

void
sppp_ipv6cp_open(struct sppp *sp)
{
}

void
sppp_ipv6cp_close(struct sppp *sp)
{
}

void
sppp_ipv6cp_TO(void *sp)
{
}

int
sppp_ipv6cp_RCR(struct sppp *sp, struct lcp_header *h,
		int len)
{
	return 0;
}

void
sppp_ipv6cp_RCN_rej(struct sppp *sp, struct lcp_header *h,
		    int len)
{
}

void
sppp_ipv6cp_RCN_nak(struct sppp *sp, struct lcp_header *h,
		    int len)
{
}

void
sppp_ipv6cp_tlu(struct sppp *sp)
{
}

void
sppp_ipv6cp_tld(struct sppp *sp)
{
}

void
sppp_ipv6cp_tls(struct sppp *sp)
{
}

void
sppp_ipv6cp_tlf(struct sppp *sp)
{
}

void
sppp_ipv6cp_scr(struct sppp *sp)
{
}
#endif /*INET6*/

/*
 *--------------------------------------------------------------------------*
 *                                                                          *
 *                        The CHAP implementation.                          *
 *                                                                          *
 *--------------------------------------------------------------------------*
 */

/*
 * The authentication protocols don't employ a full-fledged state machine as
 * the control protocols do, since they do have Open and Close events, but
 * not Up and Down, nor are they explicitly terminated.  Also, use of the
 * authentication protocols may be different in both directions (this makes
 * sense, think of a machine that never accepts incoming calls but only
 * calls out, it doesn't require the called party to authenticate itself).
 *
 * Our state machine for the local authentication protocol (we are requesting
 * the peer to authenticate) looks like:
 *
 *						    RCA-
 *	      +--------------------------------------------+
 *	      V					    scn,tld|
 *	  +--------+			       Close   +---------+ RCA+
 *	  |	   |<----------------------------------|	 |------+
 *   +--->| Closed |				TO*    | Opened	 | sca	|
 *   |	  |	   |-----+		       +-------|	 |<-----+
 *   |	  +--------+ irc |		       |       +---------+
 *   |	    ^		 |		       |	   ^
 *   |	    |		 |		       |	   |
 *   |	    |		 |		       |	   |
 *   |	 TO-|		 |		       |	   |
 *   |	    |tld  TO+	 V		       |	   |
 *   |	    |	+------->+		       |	   |
 *   |	    |	|	 |		       |	   |
 *   |	  +--------+	 V		       |	   |
 *   |	  |	   |<----+<--------------------+	   |
 *   |	  | Req-   | scr				   |
 *   |	  | Sent   |					   |
 *   |	  |	   |					   |
 *   |	  +--------+					   |
 *   | RCA- |	| RCA+					   |
 *   +------+	+------------------------------------------+
 *   scn,tld	  sca,irc,ict,tlu
 *
 *
 *   with:
 *
 *	Open:	LCP reached authentication phase
 *	Close:	LCP reached terminate phase
 *
 *	RCA+:	received reply (pap-req, chap-response), acceptable
 *	RCN:	received reply (pap-req, chap-response), not acceptable
 *	TO+:	timeout with restart counter >= 0
 *	TO-:	timeout with restart counter < 0
 *	TO*:	reschedule timeout for CHAP
 *
 *	scr:	send request packet (none for PAP, chap-challenge)
 *	sca:	send ack packet (pap-ack, chap-success)
 *	scn:	send nak packet (pap-nak, chap-failure)
 *	ict:	initialize re-challenge timer (CHAP only)
 *
 *	tlu:	this-layer-up, LCP reaches network phase
 *	tld:	this-layer-down, LCP enters terminate phase
 *
 * Note that in CHAP mode, after sending a new challenge, while the state
 * automaton falls back into Req-Sent state, it doesn't signal a tld
 * event to LCP, so LCP remains in network phase.  Only after not getting
 * any response (or after getting an unacceptable response), CHAP closes,
 * causing LCP to enter terminate phase.
 *
 * With PAP, there is no initial request that can be sent.  The peer is
 * expected to send one based on the successful negotiation of PAP as
 * the authentication protocol during the LCP option negotiation.
 *
 * Incoming authentication protocol requests (remote requests
 * authentication, we are peer) don't employ a state machine at all,
 * they are simply answered.  Some peers [Ascend P50 firmware rev
 * 4.50] react allergically when sending IPCP requests while they are
 * still in authentication phase (thereby violating the standard that
 * demands that these NCP packets are to be discarded), so we keep
 * track of the peer demanding us to authenticate, and only proceed to
 * phase network once we've seen a positive acknowledge for the
 * authentication.
 */

/*
 * Handle incoming CHAP packets.
 */
void
sppp_chap_input(struct sppp *sp, struct mbuf *m)
{
	STDDCL;
	struct lcp_header *h;
	int len, x;
	u_char *value, *name, digest[AUTHCHALEN], dsize;
	int value_len, name_len;
	MD5_CTX ctx;

	len = m->m_pkthdr.len;
	if (len < 4) {
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "chap invalid packet length: %d bytes\n",
			    SPP_ARGS(ifp), len);
		return;
	}
	h = mtod (m, struct lcp_header*);
	if (len > ntohs (h->len))
		len = ntohs (h->len);

	switch (h->type) {
	/* challenge, failure and success are his authproto */
	case CHAP_CHALLENGE:
		value = 1 + (u_char*)(h+1);
		value_len = value[-1];
		name = value + value_len;
		name_len = len - value_len - 5;
		if (name_len < 0) {
			if (debug) {
				log(LOG_DEBUG,
				    SPP_FMT "chap corrupted challenge "
				    "<%s id=0x%x len=%d",
				    SPP_ARGS(ifp),
				    sppp_auth_type_name(PPP_CHAP, h->type),
				    h->ident, ntohs(h->len));
				if (len > 4)
					sppp_print_bytes((u_char*) (h+1), len-4);
				addlog(">\n");
			}
			break;
		}

		if (debug) {
			log(LOG_DEBUG,
			    SPP_FMT "chap input <%s id=0x%x len=%d name=",
			    SPP_ARGS(ifp),
			    sppp_auth_type_name(PPP_CHAP, h->type), h->ident,
			    ntohs(h->len));
			sppp_print_string((char*) name, name_len);
			addlog(" value-size=%d value=", value_len);
			sppp_print_bytes(value, value_len);
			addlog(">\n");
		}

		/* Compute reply value. */
		MD5Init(&ctx);
		MD5Update(&ctx, &h->ident, 1);
		MD5Update(&ctx, sp->myauth.secret, strlen(sp->myauth.secret));
		MD5Update(&ctx, value, value_len);
		MD5Final(digest, &ctx);
		dsize = sizeof digest;

		sppp_auth_send(&chap, sp, CHAP_RESPONSE, h->ident,
			       sizeof dsize, (const char *)&dsize,
			       sizeof digest, digest,
			       strlen(sp->myauth.name),
			       sp->myauth.name,
			       0);
		break;

	case CHAP_SUCCESS:
		if (debug) {
			log(LOG_DEBUG, SPP_FMT "chap success",
			    SPP_ARGS(ifp));
			if (len > 4) {
				addlog(": ");
				sppp_print_string((char*)(h + 1), len - 4);
			}
			addlog("\n");
		}
		x = splnet();
		sp->pp_flags &= ~PP_NEEDAUTH;
		if (sp->myauth.proto == PPP_CHAP &&
		    (sp->lcp.opts & (1 << LCP_OPT_AUTH_PROTO)) &&
		    (sp->lcp.protos & (1 << IDX_CHAP)) == 0) {
			/*
			 * We are authenticator for CHAP but didn't
			 * complete yet.  Leave it to tlu to proceed
			 * to network phase.
			 */
			splx(x);
			break;
		}
		splx(x);
		sppp_phase_network(sp);
		break;

	case CHAP_FAILURE:
		if (debug) {
			log(LOG_INFO, SPP_FMT "chap failure",
			    SPP_ARGS(ifp));
			if (len > 4) {
				addlog(": ");
				sppp_print_string((char*)(h + 1), len - 4);
			}
			addlog("\n");
		} else
			log(LOG_INFO, SPP_FMT "chap failure\n",
			    SPP_ARGS(ifp));
		/* await LCP shutdown by authenticator */
		break;

	/* response is my authproto */
	case CHAP_RESPONSE:
		value = 1 + (u_char*)(h+1);
		value_len = value[-1];
		name = value + value_len;
		name_len = len - value_len - 5;
		if (name_len < 0) {
			if (debug) {
				log(LOG_DEBUG,
				    SPP_FMT "chap corrupted response "
				    "<%s id=0x%x len=%d",
				    SPP_ARGS(ifp),
				    sppp_auth_type_name(PPP_CHAP, h->type),
				    h->ident, ntohs(h->len));
				if (len > 4)
					sppp_print_bytes((u_char*)(h+1), len-4);
				addlog(">\n");
			}
			break;
		}
		if (h->ident != sp->confid[IDX_CHAP]) {
			if (debug)
				log(LOG_DEBUG,
				    SPP_FMT "chap dropping response for old ID "
				    "(got %d, expected %d)\n",
				    SPP_ARGS(ifp),
				    h->ident, sp->confid[IDX_CHAP]);
			break;
		}
		if (name_len != strlen(sp->hisauth.name)
		    || bcmp(name, sp->hisauth.name, name_len) != 0) {
			log(LOG_INFO, SPP_FMT "chap response, his name ",
			    SPP_ARGS(ifp));
			sppp_print_string(name, name_len);
			addlog(" != expected ");
			sppp_print_string(sp->hisauth.name,
			    strlen(sp->hisauth.name));
			addlog("\n");
		}
		if (debug) {
			log(LOG_DEBUG, SPP_FMT "chap input(%s) "
			    "<%s id=0x%x len=%d name=",
			    SPP_ARGS(ifp),
			    sppp_state_name(sp->state[IDX_CHAP]),
			    sppp_auth_type_name(PPP_CHAP, h->type),
			    h->ident, ntohs (h->len));
			sppp_print_string((char*)name, name_len);
			addlog(" value-size=%d value=", value_len);
			sppp_print_bytes(value, value_len);
			addlog(">\n");
		}
		if (value_len != AUTHCHALEN) {
			if (debug)
				log(LOG_DEBUG,
				    SPP_FMT "chap bad hash value length: "
				    "%d bytes, should be %d\n",
				    SPP_ARGS(ifp), value_len,
				    AUTHCHALEN);
			break;
		}

		MD5Init(&ctx);
		MD5Update(&ctx, &h->ident, 1);
		MD5Update(&ctx, sp->hisauth.secret, strlen(sp->hisauth.secret));
		MD5Update(&ctx, sp->chap_challenge, AUTHCHALEN);
		MD5Final(digest, &ctx);

#define FAILMSG "Failed..."
#define SUCCMSG "Welcome!"

		if (value_len != sizeof digest ||
		    timingsafe_bcmp(digest, value, value_len) != 0) {
			/* action scn, tld */
			sppp_auth_send(&chap, sp, CHAP_FAILURE, h->ident,
				       sizeof(FAILMSG) - 1, (u_char *)FAILMSG,
				       0);
			chap.tld(sp);
			break;
		}
		/* action sca, perhaps tlu */
		if (sp->state[IDX_CHAP] == STATE_REQ_SENT ||
		    sp->state[IDX_CHAP] == STATE_OPENED)
			sppp_auth_send(&chap, sp, CHAP_SUCCESS, h->ident,
				       sizeof(SUCCMSG) - 1, (u_char *)SUCCMSG,
				       0);
		if (sp->state[IDX_CHAP] == STATE_REQ_SENT) {
			sppp_cp_change_state(&chap, sp, STATE_OPENED);
			chap.tlu(sp);
		}
		break;

	default:
		/* Unknown CHAP packet type -- ignore. */
		if (debug) {
			log(LOG_DEBUG, SPP_FMT "chap unknown input(%s) "
			    "<0x%x id=0x%xh len=%d",
			    SPP_ARGS(ifp),
			    sppp_state_name(sp->state[IDX_CHAP]),
			    h->type, h->ident, ntohs(h->len));
			if (len > 4)
				sppp_print_bytes((u_char*)(h+1), len-4);
			addlog(">\n");
		}
		break;

	}
}

void
sppp_chap_init(struct sppp *sp)
{
	/* Chap doesn't have STATE_INITIAL at all. */
	sp->state[IDX_CHAP] = STATE_CLOSED;
	sp->fail_counter[IDX_CHAP] = 0;
}

void
sppp_chap_open(struct sppp *sp)
{
	if (sp->myauth.proto == PPP_CHAP &&
	    (sp->lcp.opts & (1 << LCP_OPT_AUTH_PROTO)) != 0) {
		/* we are authenticator for CHAP, start it */
		chap.scr(sp);
		sp->rst_counter[IDX_CHAP] = sp->lcp.max_configure;
		sppp_cp_change_state(&chap, sp, STATE_REQ_SENT);
	}
	/* nothing to be done if we are peer, await a challenge */
}

void
sppp_chap_close(struct sppp *sp)
{
	if (sp->state[IDX_CHAP] != STATE_CLOSED)
		sppp_cp_change_state(&chap, sp, STATE_CLOSED);
}

void
sppp_chap_TO(void *cookie)
{
	struct sppp *sp = (struct sppp *)cookie;
	STDDCL;
	int s;

	s = splnet();
	if (debug)
		log(LOG_DEBUG, SPP_FMT "chap TO(%s) rst_counter = %d\n",
		    SPP_ARGS(ifp),
		    sppp_state_name(sp->state[IDX_CHAP]),
		    sp->rst_counter[IDX_CHAP]);

	if (--sp->rst_counter[IDX_CHAP] < 0)
		/* TO- event */
		switch (sp->state[IDX_CHAP]) {
		case STATE_REQ_SENT:
			chap.tld(sp);
			sppp_cp_change_state(&chap, sp, STATE_CLOSED);
			break;
		}
	else
		/* TO+ (or TO*) event */
		switch (sp->state[IDX_CHAP]) {
		case STATE_OPENED:
			/* TO* event */
			sp->rst_counter[IDX_CHAP] = sp->lcp.max_configure;
			/* FALLTHROUGH */
		case STATE_REQ_SENT:
			chap.scr(sp);
			/* sppp_cp_change_state() will restart the timer */
			sppp_cp_change_state(&chap, sp, STATE_REQ_SENT);
			break;
		}

	splx(s);
}

void
sppp_chap_tlu(struct sppp *sp)
{
	STDDCL;
	int i = 0, x;

	i = 0;
	sp->rst_counter[IDX_CHAP] = sp->lcp.max_configure;

	/*
	 * Some broken CHAP implementations (Conware CoNet, firmware
	 * 4.0.?) don't want to re-authenticate their CHAP once the
	 * initial challenge-response exchange has taken place.
	 * Provide for an option to avoid rechallenges.
	 */
	if ((sp->hisauth.flags & AUTHFLAG_NORECHALLENGE) == 0) {
		/*
		 * Compute the re-challenge timeout.  This will yield
		 * a number between 300 and 810 seconds.
		 */
		i = 300 + (arc4random() & 0x01fe);

		timeout_add_sec(&sp->ch[IDX_CHAP], i);
	}

	if (debug) {
		log(LOG_DEBUG,
		    SPP_FMT "chap %s, ",
		    SPP_ARGS(ifp),
		    sp->pp_phase == PHASE_NETWORK? "reconfirmed": "tlu");
		if ((sp->hisauth.flags & AUTHFLAG_NORECHALLENGE) == 0)
			addlog("next re-challenge in %d seconds\n", i);
		else
			addlog("re-challenging suppressed\n");
	}

	x = splnet();
	/* indicate to LCP that we need to be closed down */
	sp->lcp.protos |= (1 << IDX_CHAP);

	if (sp->pp_flags & PP_NEEDAUTH) {
		/*
		 * Remote is authenticator, but his auth proto didn't
		 * complete yet.  Defer the transition to network
		 * phase.
		 */
		splx(x);
		return;
	}
	splx(x);

	/*
	 * If we are already in phase network, we are done here.  This
	 * is the case if this is a dummy tlu event after a re-challenge.
	 */
	if (sp->pp_phase != PHASE_NETWORK)
		sppp_phase_network(sp);
}

void
sppp_chap_tld(struct sppp *sp)
{
	STDDCL;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "chap tld\n", SPP_ARGS(ifp));
	UNTIMEOUT(chap.TO, (void *)sp, sp->ch[IDX_CHAP]);
	sp->lcp.protos &= ~(1 << IDX_CHAP);

	lcp.Close(sp);
}

void
sppp_chap_scr(struct sppp *sp)
{
	u_char clen;

	/* Compute random challenge. */
	arc4random_buf(sp->chap_challenge, sizeof(sp->chap_challenge));
	clen = AUTHCHALEN;

	sp->confid[IDX_CHAP] = ++sp->pp_seq;

	sppp_auth_send(&chap, sp, CHAP_CHALLENGE, sp->confid[IDX_CHAP],
		       sizeof clen, (const char *)&clen,
		       (size_t)AUTHCHALEN, sp->chap_challenge,
		       strlen(sp->myauth.name),
		       sp->myauth.name,
		       0);
}
/*
 *--------------------------------------------------------------------------*
 *                                                                          *
 *                        The PAP implementation.                           *
 *                                                                          *
 *--------------------------------------------------------------------------*
 */
/*
 * For PAP, we need to keep a little state also if we are the peer, not the
 * authenticator.  This is since we don't get a request to authenticate, but
 * have to repeatedly authenticate ourself until we got a response (or the
 * retry counter is expired).
 */

/*
 * Handle incoming PAP packets.  */
void
sppp_pap_input(struct sppp *sp, struct mbuf *m)
{
	STDDCL;
	struct lcp_header *h;
	int len, x;
	u_char *name, *passwd, mlen;
	int name_len, passwd_len;

	len = m->m_pkthdr.len;
	if (len < 5) {
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "pap invalid packet length: %d bytes\n",
			    SPP_ARGS(ifp), len);
		return;
	}
	h = mtod (m, struct lcp_header*);
	if (len > ntohs (h->len))
		len = ntohs (h->len);
	switch (h->type) {
	/* PAP request is my authproto */
	case PAP_REQ:
		name = 1 + (u_char*)(h+1);
		name_len = name[-1];
		passwd = name + name_len + 1;
		if (name_len > len - 6 ||
		    (passwd_len = passwd[-1]) > len - 6 - name_len) {
			if (debug) {
				log(LOG_DEBUG, SPP_FMT "pap corrupted input "
				    "<%s id=0x%x len=%d",
				    SPP_ARGS(ifp),
				    sppp_auth_type_name(PPP_PAP, h->type),
				    h->ident, ntohs(h->len));
				if (len > 4)
					sppp_print_bytes((u_char*)(h+1), len-4);
				addlog(">\n");
			}
			break;
		}
		if (debug) {
			log(LOG_DEBUG, SPP_FMT "pap input(%s) "
			    "<%s id=0x%x len=%d name=",
			    SPP_ARGS(ifp),
			    sppp_state_name(sp->state[IDX_PAP]),
			    sppp_auth_type_name(PPP_PAP, h->type),
			    h->ident, ntohs(h->len));
			sppp_print_string((char*)name, name_len);
			addlog(" passwd=");
			sppp_print_string((char*)passwd, passwd_len);
			addlog(">\n");
		}
		if (name_len > AUTHMAXLEN ||
		    passwd_len > AUTHMAXLEN ||
		    bcmp(name, sp->hisauth.name, name_len) != 0 ||
		    bcmp(passwd, sp->hisauth.secret, passwd_len) != 0) {
			/* action scn, tld */
			mlen = sizeof(FAILMSG) - 1;
			sppp_auth_send(&pap, sp, PAP_NAK, h->ident,
				       sizeof mlen, (const char *)&mlen,
				       sizeof(FAILMSG) - 1, (u_char *)FAILMSG,
				       0);
			pap.tld(sp);
			break;
		}
		/* action sca, perhaps tlu */
		if (sp->state[IDX_PAP] == STATE_REQ_SENT ||
		    sp->state[IDX_PAP] == STATE_OPENED) {
			mlen = sizeof(SUCCMSG) - 1;
			sppp_auth_send(&pap, sp, PAP_ACK, h->ident,
				       sizeof mlen, (const char *)&mlen,
				       sizeof(SUCCMSG) - 1, (u_char *)SUCCMSG,
				       0);
		}
		if (sp->state[IDX_PAP] == STATE_REQ_SENT) {
			sppp_cp_change_state(&pap, sp, STATE_OPENED);
			pap.tlu(sp);
		}
		break;

	/* ack and nak are his authproto */
	case PAP_ACK:
		UNTIMEOUT(sppp_pap_my_TO, (void *)sp, sp->pap_my_to_ch);
		if (debug) {
			log(LOG_DEBUG, SPP_FMT "pap success",
			    SPP_ARGS(ifp));
			name_len = *((char *)h);
			if (len > 5 && name_len) {
				addlog(": ");
				sppp_print_string((char*)(h+1), name_len);
			}
			addlog("\n");
		}
		x = splnet();
		sp->pp_flags &= ~PP_NEEDAUTH;
		if (sp->myauth.proto == PPP_PAP &&
		    (sp->lcp.opts & (1 << LCP_OPT_AUTH_PROTO)) &&
		    (sp->lcp.protos & (1 << IDX_PAP)) == 0) {
			/*
			 * We are authenticator for PAP but didn't
			 * complete yet.  Leave it to tlu to proceed
			 * to network phase.
			 */
			splx(x);
			break;
		}
		splx(x);
		sppp_phase_network(sp);
		break;

	case PAP_NAK:
		UNTIMEOUT(sppp_pap_my_TO, (void *)sp, sp->pap_my_to_ch);
		if (debug) {
			log(LOG_INFO, SPP_FMT "pap failure",
			    SPP_ARGS(ifp));
			name_len = *((char *)h);
			if (len > 5 && name_len) {
				addlog(": ");
				sppp_print_string((char*)(h+1), name_len);
			}
			addlog("\n");
		} else
			log(LOG_INFO, SPP_FMT "pap failure\n",
			    SPP_ARGS(ifp));
		/* await LCP shutdown by authenticator */
		break;

	default:
		/* Unknown PAP packet type -- ignore. */
		if (debug) {
			log(LOG_DEBUG, SPP_FMT "pap corrupted input "
			    "<0x%x id=0x%x len=%d",
			    SPP_ARGS(ifp),
			    h->type, h->ident, ntohs(h->len));
			if (len > 4)
				sppp_print_bytes((u_char*)(h+1), len-4);
			addlog(">\n");
		}
		break;

	}
}

void
sppp_pap_init(struct sppp *sp)
{
	/* PAP doesn't have STATE_INITIAL at all. */
	sp->state[IDX_PAP] = STATE_CLOSED;
	sp->fail_counter[IDX_PAP] = 0;
}

void
sppp_pap_open(struct sppp *sp)
{
	if (sp->hisauth.proto == PPP_PAP &&
	    (sp->lcp.opts & (1 << LCP_OPT_AUTH_PROTO)) != 0) {
		/* we are authenticator for PAP, start our timer */
		sp->rst_counter[IDX_PAP] = sp->lcp.max_configure;
		sppp_cp_change_state(&pap, sp, STATE_REQ_SENT);
	}
	if (sp->myauth.proto == PPP_PAP) {
		/* we are peer, send a request, and start a timer */
		pap.scr(sp);
		timeout_add(&sp->pap_my_to_ch, sp->lcp.timeout);
	}
}

void
sppp_pap_close(struct sppp *sp)
{
	if (sp->state[IDX_PAP] != STATE_CLOSED)
		sppp_cp_change_state(&pap, sp, STATE_CLOSED);
}

/*
 * That's the timeout routine if we are authenticator.  Since the
 * authenticator is basically passive in PAP, we can't do much here.
 */
void
sppp_pap_TO(void *cookie)
{
	struct sppp *sp = (struct sppp *)cookie;
	STDDCL;
	int s;

	s = splnet();
	if (debug)
		log(LOG_DEBUG, SPP_FMT "pap TO(%s) rst_counter = %d\n",
		    SPP_ARGS(ifp),
		    sppp_state_name(sp->state[IDX_PAP]),
		    sp->rst_counter[IDX_PAP]);

	if (--sp->rst_counter[IDX_PAP] < 0)
		/* TO- event */
		switch (sp->state[IDX_PAP]) {
		case STATE_REQ_SENT:
			pap.tld(sp);
			sppp_cp_change_state(&pap, sp, STATE_CLOSED);
			break;
		}
	else
		/* TO+ event, not very much we could do */
		switch (sp->state[IDX_PAP]) {
		case STATE_REQ_SENT:
			/* sppp_cp_change_state() will restart the timer */
			sppp_cp_change_state(&pap, sp, STATE_REQ_SENT);
			break;
		}

	splx(s);
}

/*
 * That's the timeout handler if we are peer.  Since the peer is active,
 * we need to retransmit our PAP request since it is apparently lost.
 * XXX We should impose a max counter.
 */
void
sppp_pap_my_TO(void *cookie)
{
	struct sppp *sp = (struct sppp *)cookie;
	STDDCL;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "pap peer TO\n",
		    SPP_ARGS(ifp));

	pap.scr(sp);
}

void
sppp_pap_tlu(struct sppp *sp)
{
	STDDCL;
	int x;

	sp->rst_counter[IDX_PAP] = sp->lcp.max_configure;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "%s tlu\n",
		    SPP_ARGS(ifp), pap.name);

	x = splnet();
	/* indicate to LCP that we need to be closed down */
	sp->lcp.protos |= (1 << IDX_PAP);

	if (sp->pp_flags & PP_NEEDAUTH) {
		/*
		 * Remote is authenticator, but his auth proto didn't
		 * complete yet.  Defer the transition to network
		 * phase.
		 */
		splx(x);
		return;
	}
	splx(x);
	sppp_phase_network(sp);
}

void
sppp_pap_tld(struct sppp *sp)
{
	STDDCL;

	if (debug)
		log(LOG_DEBUG, SPP_FMT "pap tld\n", SPP_ARGS(ifp));
	UNTIMEOUT(pap.TO, (void *)sp, sp->ch[IDX_PAP]);
	UNTIMEOUT(sppp_pap_my_TO, (void *)sp, sp->pap_my_to_ch);
	sp->lcp.protos &= ~(1 << IDX_PAP);

	lcp.Close(sp);
}

void
sppp_pap_scr(struct sppp *sp)
{
	u_char idlen, pwdlen;

	sp->confid[IDX_PAP] = ++sp->pp_seq;
	pwdlen = strlen(sp->myauth.secret);
	idlen = strlen(sp->myauth.name);

	sppp_auth_send(&pap, sp, PAP_REQ, sp->confid[IDX_PAP],
		       sizeof idlen, (const char *)&idlen,
		       (size_t)idlen, sp->myauth.name,
		       sizeof pwdlen, (const char *)&pwdlen,
		       (size_t)pwdlen, sp->myauth.secret,
		       0);
}
/*
 * Random miscellaneous functions.
 */

/*
 * Send a PAP or CHAP proto packet.
 *
 * Varadic function, each of the elements for the ellipsis is of type
 * ``size_t mlen, const u_char *msg''.  Processing will stop iff
 * mlen == 0.
 */

void
sppp_auth_send(const struct cp *cp, struct sppp *sp,
		unsigned int type, u_int id, ...)
{
	STDDCL;
	struct lcp_header *lh;
	struct mbuf *m;
	u_char *p;
	int len, s;
	unsigned int mlen;
	const char *msg;
	va_list ap;

	MGETHDR (m, M_DONTWAIT, MT_DATA);
	if (! m)
		return;
	m->m_pkthdr.ph_ifidx = 0;
	m->m_pkthdr.pf.prio = sp->pp_if.if_llprio;

	*mtod(m, u_int16_t *) = htons(cp->proto);
	lh = (struct lcp_header *)(mtod(m, u_int8_t *) + 2);

	lh->type = type;
	lh->ident = id;
	p = (u_char*) (lh+1);

	va_start(ap, id);
	len = 0;

	while ((mlen = (unsigned int)va_arg(ap, size_t)) != 0) {
		msg = va_arg(ap, const char *);
		len += mlen;
		if (len > MHLEN - PKTHDRLEN - LCP_HEADER_LEN) {
			va_end(ap);
			m_freem(m);
			return;
		}

		bcopy(msg, p, mlen);
		p += mlen;
	}
	va_end(ap);

	m->m_pkthdr.len = m->m_len = PKTHDRLEN + LCP_HEADER_LEN + len;
	lh->len = htons (LCP_HEADER_LEN + len);

	if (debug) {
		log(LOG_DEBUG, SPP_FMT "%s output <%s id=0x%x len=%d",
		    SPP_ARGS(ifp), cp->name,
		    sppp_auth_type_name(cp->proto, lh->type),
		    lh->ident, ntohs(lh->len));
		if (len)
			sppp_print_bytes((u_char*) (lh+1), len);
		addlog(">\n");
	}

	len = m->m_pkthdr.len + sp->pp_framebytes;
	if (mq_enqueue(&sp->pp_cpq, m) != 0) {
		ifp->if_oerrors++;
		return;
	}

	ifp->if_obytes += len;
	s = splnet();
	if_start(ifp);
	splx(s);
}

/*
 * Send keepalive packets, every 10 seconds.
 */
void
sppp_keepalive(void *dummy)
{
	struct sppp *sp;
	int s;
	struct timeval tv;

	NET_LOCK();
	s = splnet();
	getmicrouptime(&tv);
	for (sp=spppq; sp; sp=sp->pp_next) {
		struct ifnet *ifp = &sp->pp_if;

		/* Keepalive mode disabled or channel down? */
		if (! (sp->pp_flags & PP_KEEPALIVE) ||
		    ! (ifp->if_flags & IFF_RUNNING))
			continue;

		/* No keepalive if LCP not opened yet. */
		if (sp->pp_phase < PHASE_AUTHENTICATE)
			continue;

		/* No echo reply, but maybe user data passed through? */
		if ((tv.tv_sec - sp->pp_last_receive) < NORECV_TIME) {
			sp->pp_alivecnt = 0;
			continue;
		}

		if (sp->pp_alivecnt >= MAXALIVECNT) {
			/* No keepalive packets got.  Stop the interface. */
			if_down (ifp);
			mq_purge(&sp->pp_cpq);
			log(LOG_INFO, SPP_FMT "LCP keepalive timeout\n",
			    SPP_ARGS(ifp));
			sp->pp_alivecnt = 0;

			/* we are down, close all open protocols */
			lcp.Close(sp);

			/* And now prepare LCP to reestablish the link,
			 * if configured to do so. */
			sppp_cp_change_state(&lcp, sp, STATE_STOPPED);

			/* Close connection immediately, completion of this
			 * will summon the magic needed to reestablish it. */
			if (sp->pp_tlf)
				sp->pp_tlf(sp);
			continue;
		}
		if (sp->pp_alivecnt < MAXALIVECNT)
			++sp->pp_alivecnt;
		if (sp->pp_phase >= PHASE_AUTHENTICATE) {
			u_int32_t nmagic = htonl(sp->lcp.magic);
			sp->lcp.echoid = ++sp->pp_seq;
			sppp_cp_send (sp, PPP_LCP, ECHO_REQ,
				sp->lcp.echoid, 4, &nmagic);
		}
	}
	splx(s);
	NET_UNLOCK();
	timeout_add_sec(&keepalive_ch, 10);
}

/*
 * Get both IP addresses.
 */
void
sppp_get_ip_addrs(struct sppp *sp, u_int32_t *src, u_int32_t *dst,
    u_int32_t *srcmask)
{
	struct ifnet *ifp = &sp->pp_if;
	struct ifaddr *ifa;
	struct sockaddr_in *si, *sm = 0;
	u_int32_t ssrc, ddst;

	sm = NULL;
	ssrc = ddst = 0;
	/*
	 * Pick the first AF_INET address from the list,
	 * aliases don't make any sense on a p2p link anyway.
	 */
	si = 0;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list)
	{
		if (ifa->ifa_addr->sa_family == AF_INET) {
			si = (struct sockaddr_in *)ifa->ifa_addr;
			sm = (struct sockaddr_in *)ifa->ifa_netmask;
			if (si)
				break;
		}
	}
	if (ifa) {
		if (si && si->sin_addr.s_addr) {
			ssrc = si->sin_addr.s_addr;
			if (srcmask)
				*srcmask = ntohl(sm->sin_addr.s_addr);
		}

		si = (struct sockaddr_in *)ifa->ifa_dstaddr;
		if (si && si->sin_addr.s_addr)
			ddst = si->sin_addr.s_addr;
	}

	if (dst) *dst = ntohl(ddst);
	if (src) *src = ntohl(ssrc);
}

int
sppp_update_gw_walker(struct rtentry *rt, void *arg, unsigned int id)
{
	struct ifnet *ifp = arg;

	if (rt->rt_ifidx == ifp->if_index) {
		if (rt->rt_ifa->ifa_dstaddr->sa_family !=
		    rt->rt_gateway->sa_family ||
		    !ISSET(rt->rt_flags, RTF_GATEWAY))
			return (0);	/* do not modify non-gateway routes */
		rt_setgate(rt, rt->rt_ifa->ifa_dstaddr, ifp->if_rdomain);
	}
	return (0);
}

void
sppp_update_gw(struct ifnet *ifp)
{
	u_int tid;

	/* update routing table */
	for (tid = 0; tid <= RT_TABLEID_MAX; tid++) {
		rtable_walk(tid, AF_INET, sppp_update_gw_walker, ifp);
	}
}

/*
 * Task adding addresses from process context.
 * If an address is 0, leave it the way it is.
 */
void
sppp_set_ip_addrs(void *arg1)
{
	struct sppp *sp = arg1;
	u_int32_t myaddr;
	u_int32_t hisaddr;
	struct ifnet *ifp = &sp->pp_if;
	int debug = ifp->if_flags & IFF_DEBUG;
	struct ifaddr *ifa;
	struct sockaddr_in *si;
	struct sockaddr_in *dest;

	sppp_get_ip_addrs(sp, &myaddr, &hisaddr, NULL);
	if ((sp->ipcp.flags & IPCP_MYADDR_DYN) &&
	    (sp->ipcp.flags & IPCP_MYADDR_SEEN))
		myaddr = sp->ipcp.req_myaddr;
	if ((sp->ipcp.flags & IPCP_HISADDR_DYN) &&
	    (sp->ipcp.flags & IPCP_HISADDR_SEEN))
		hisaddr = sp->ipcp.req_hisaddr;


	NET_LOCK();
	/*
	 * Pick the first AF_INET address from the list,
	 * aliases don't make any sense on a p2p link anyway.
	 */

	si = 0;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list)
	{
		if (ifa->ifa_addr->sa_family == AF_INET)
		{
			si = (struct sockaddr_in *)ifa->ifa_addr;
			dest = (struct sockaddr_in *)ifa->ifa_dstaddr;
			if (si)
				break;
		}
	}

	if (ifa && si) {
		int error;
		struct sockaddr_in new_sin = *si;
		struct sockaddr_in new_dst = *dest;

		in_ifscrub(ifp, ifatoia(ifa));

		if (myaddr != 0)
			new_sin.sin_addr.s_addr = htonl(myaddr);
		if (hisaddr != 0) {
			new_dst.sin_addr.s_addr = htonl(hisaddr);
			if (new_dst.sin_addr.s_addr != dest->sin_addr.s_addr) {
				sp->ipcp.saved_hisaddr = dest->sin_addr.s_addr;
				*dest = new_dst; /* fix dstaddr in place */
			}
		}
		if (!(error = in_ifinit(ifp, ifatoia(ifa), &new_sin, 0)))
			dohooks(ifp->if_addrhooks, 0);
		if (debug && error) {
			log(LOG_DEBUG, SPP_FMT "sppp_set_ip_addrs: in_ifinit "
			" failed, error=%d\n", SPP_ARGS(ifp), error);
			goto out;
		}
		sppp_update_gw(ifp);
	}
out:
	NET_UNLOCK();
}

/*
 * Task clearing addresses from process context.
 * Clear IP addresses.
 */
void
sppp_clear_ip_addrs(void *arg1)
{
	struct sppp *sp = (struct sppp *)arg1;
	struct ifnet *ifp = &sp->pp_if;
	int debug = ifp->if_flags & IFF_DEBUG;
	struct ifaddr *ifa;
	struct sockaddr_in *si;
	struct sockaddr_in *dest;
	u_int32_t remote;

	NET_LOCK();

	if (sp->ipcp.flags & IPCP_HISADDR_DYN)
		remote = sp->ipcp.saved_hisaddr;
	else
		sppp_get_ip_addrs(sp, 0, &remote, 0);

	/*
	 * Pick the first AF_INET address from the list,
	 * aliases don't make any sense on a p2p link anyway.
	 */

	si = 0;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET) {
			si = (struct sockaddr_in *)ifa->ifa_addr;
			dest = (struct sockaddr_in *)ifa->ifa_dstaddr;
			if (si)
				break;
		}
	}

	if (ifa && si) {
		int error;
		struct sockaddr_in new_sin = *si;

		in_ifscrub(ifp, ifatoia(ifa));
		if (sp->ipcp.flags & IPCP_MYADDR_DYN)
			new_sin.sin_addr.s_addr = 0;
		if (sp->ipcp.flags & IPCP_HISADDR_DYN)
			/* replace peer addr in place */
			dest->sin_addr.s_addr = sp->ipcp.saved_hisaddr;
		if (!(error = in_ifinit(ifp, ifatoia(ifa), &new_sin, 0)))
			dohooks(ifp->if_addrhooks, 0);
		if (debug && error) {
			log(LOG_DEBUG, SPP_FMT "sppp_clear_ip_addrs: in_ifinit "
			" failed, error=%d\n", SPP_ARGS(ifp), error);
			goto out;
		}
		sppp_update_gw(ifp);
	}
out:
	NET_UNLOCK();
}


#ifdef INET6
/*
 * Get both IPv6 addresses.
 */
void
sppp_get_ip6_addrs(struct sppp *sp, struct in6_addr *src, struct in6_addr *dst,
		   struct in6_addr *srcmask)
{
	struct ifnet *ifp = &sp->pp_if;
	struct in6_ifaddr *ia6;
	struct in6_addr ssrc, ddst;

	bzero(&ssrc, sizeof(ssrc));
	bzero(&ddst, sizeof(ddst));
	/*
	 * Pick the first link-local AF_INET6 address from the list,
	 * aliases don't make any sense on a p2p link anyway.
	 */
	ia6 = in6ifa_ifpforlinklocal(ifp, 0);
	if (ia6) {
		if (!IN6_IS_ADDR_UNSPECIFIED(&ia6->ia_addr.sin6_addr)) {
			bcopy(&ia6->ia_addr.sin6_addr, &ssrc, sizeof(ssrc));
			if (srcmask) {
				bcopy(&ia6->ia_prefixmask.sin6_addr, srcmask,
				    sizeof(*srcmask));
			}
		}

		if (!IN6_IS_ADDR_UNSPECIFIED(&ia6->ia_dstaddr.sin6_addr))
			bcopy(&ia6->ia_dstaddr.sin6_addr, &ddst, sizeof(ddst));
	}

	if (dst)
		bcopy(&ddst, dst, sizeof(*dst));
	if (src)
		bcopy(&ssrc, src, sizeof(*src));
}

/* Task to update my IPv6 address from process context. */
void
sppp_update_ip6_addr(void *arg)
{
	struct sppp *sp = arg;
	struct ifnet *ifp = &sp->pp_if;
	struct in6_aliasreq *ifra = &sp->ipv6cp.req_ifid;
	struct in6_addr mask = in6mask128;
	struct in6_ifaddr *ia6;
	int error;

	NET_LOCK();

	ia6 = in6ifa_ifpforlinklocal(ifp, 0);
	if (ia6 == NULL) {
		/* IPv6 disabled? */
		goto out;
	}

	/*
	 * Changing the link-local address requires purging all
	 * existing addresses and routes for the interface first.
	 */
	if (sp->ipv6cp.flags & IPV6CP_MYIFID_DYN) {
		in6_ifdetach(ifp);
		error = in6_ifattach_linklocal(ifp, &ifra->ifra_addr.sin6_addr);
		if (error)
			log(LOG_ERR, SPP_FMT
			    "could not update IPv6 address (error %d)\n",
			    SPP_ARGS(ifp), error);
		goto out;
	}

	/*
	 * Code below changes address parameters only, not the address itself.
	 */

	/* Destination address can only be set for /128. */
	if (!in6_are_prefix_equal(&ia6->ia_prefixmask.sin6_addr, &mask, 128)) {
		ifra->ifra_dstaddr.sin6_len = 0;
		ifra->ifra_dstaddr.sin6_family = AF_UNSPEC;
	}

	ifra->ifra_lifetime = ia6->ia6_lifetime;

	error = in6_update_ifa(ifp, ifra, ia6);
	if (error) {
		log(LOG_ERR, SPP_FMT
		    "could not update IPv6 address (error %d)\n",
		    SPP_ARGS(ifp), error);
	}
out:
	NET_UNLOCK();
}

/*
 * Configure my link-local address.
 */
void
sppp_set_ip6_addr(struct sppp *sp, const struct in6_addr *src,
	const struct in6_addr *dst)
{
	struct ifnet *ifp = &sp->pp_if;
	struct in6_aliasreq *ifra = &sp->ipv6cp.req_ifid;

	bzero(ifra, sizeof(*ifra));
	bcopy(ifp->if_xname, ifra->ifra_name, sizeof(ifra->ifra_name));

	ifra->ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
	ifra->ifra_addr.sin6_family = AF_INET6;
	ifra->ifra_addr.sin6_addr = *src;
	if (dst) {
		ifra->ifra_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
		ifra->ifra_dstaddr.sin6_family = AF_INET6;
		ifra->ifra_dstaddr.sin6_addr = *dst;
	} else
		ifra->ifra_dstaddr.sin6_family = AF_UNSPEC;

	/*
	 * Don't change the existing prefixlen.
	 * It is common to use a /64 for IPv6 over point-to-point links
	 * to allow e.g. neighbour discovery and autoconf to work.
	 * But it is legal to use other values.
	 */
	ifra->ifra_prefixmask.sin6_family = AF_UNSPEC;

	task_add(systq, &sp->ipv6cp.set_addr_task);
}

/*
 * Generate an address that differs from our existing address.
 */
void
sppp_suggest_ip6_addr(struct sppp *sp, struct in6_addr *suggest)
{
	struct in6_addr myaddr;
	u_int32_t random;

	sppp_get_ip6_addrs(sp, &myaddr, NULL, NULL);

	myaddr.s6_addr[8] &= ~0x02;	/* u bit to "local" */

	random = arc4random();
	if ((random & 0xff) == 0 && (random & 0xff00) == 0) {
		myaddr.s6_addr[14] ^= 0xff;
		myaddr.s6_addr[15] ^= 0xff;
	} else {
		myaddr.s6_addr[14] ^= (random & 0xff);
		myaddr.s6_addr[15] ^= ((random & 0xff00) >> 8);
	}
	myaddr.s6_addr16[1] = 0; /* KAME hack: clear ifindex */
	bcopy(&myaddr, suggest, sizeof(myaddr));
}
#endif /*INET6*/

int
sppp_get_params(struct sppp *sp, struct ifreq *ifr)
{
	int cmd;

	if (copyin((caddr_t)ifr->ifr_data, &cmd, sizeof cmd) != 0)
		return EFAULT;

	switch (cmd) {
	case SPPPIOGDEFS:
	{
		struct spppreq *spr;

		spr = malloc(sizeof(*spr), M_DEVBUF, M_WAITOK);
		spr->cmd = cmd;
		spr->phase = sp->pp_phase;

		if (copyout(spr, (caddr_t)ifr->ifr_data, sizeof(*spr)) != 0) {
			free(spr, M_DEVBUF, 0);
			return EFAULT;
		}
		free(spr, M_DEVBUF, 0);
		break;
	}
	case SPPPIOGMAUTH:
	case SPPPIOGHAUTH:
	{
		struct sauthreq *spa;
		struct sauth *auth;

		spa = malloc(sizeof(*spa), M_DEVBUF, M_WAITOK);
		auth = (cmd == SPPPIOGMAUTH) ? &sp->myauth : &sp->hisauth;
		bzero(spa, sizeof(*spa));
		spa->proto = auth->proto;
		spa->flags = auth->flags;

		/* do not copy the secret, and only let root know the name */
		if (auth->name != NULL && suser(curproc, 0) == 0)
			strlcpy(spa->name, auth->name, sizeof(spa->name));

		if (copyout(spa, (caddr_t)ifr->ifr_data, sizeof(*spa)) != 0) {
			free(spa, M_DEVBUF, 0);
			return EFAULT;
		}
		free(spa, M_DEVBUF, 0);
		break;
	}
	default:
		return EINVAL;
	}

	return 0;
}


int
sppp_set_params(struct sppp *sp, struct ifreq *ifr)
{
	int cmd;

	if (copyin((caddr_t)ifr->ifr_data, &cmd, sizeof cmd) != 0)
		return EFAULT;

	switch (cmd) {
	case SPPPIOSDEFS:
	{
		struct spppreq *spr;

		spr = malloc(sizeof(*spr), M_DEVBUF, M_WAITOK);

		if (copyin((caddr_t)ifr->ifr_data, spr, sizeof(*spr)) != 0) {
			free(spr, M_DEVBUF, 0);
			return EFAULT;
		}
		/*
		 * Also, we only allow for authentication parameters to be
		 * specified.
		 *
		 * XXX Should allow to set or clear pp_flags.
		 */
		free(spr, M_DEVBUF, 0);
		break;
	}
	case SPPPIOSMAUTH:
	case SPPPIOSHAUTH:
	{
		/*
		 * Finally, if the respective authentication protocol to
		 * be used is set differently than 0, but the secret is
		 * passed as all zeros, we don't trash the existing secret.
		 * This allows an administrator to change the system name
		 * only without clobbering the secret (which he didn't get
		 * back in a previous SPPPIOGXAUTH call).  However, the
		 * secrets are cleared if the authentication protocol is
		 * reset to 0.
		 */

		struct sauthreq *spa;
		struct sauth *auth;
		char *p;
		int len;

		spa = malloc(sizeof(*spa), M_DEVBUF, M_WAITOK);

		auth = (cmd == SPPPIOSMAUTH) ? &sp->myauth : &sp->hisauth;

		if (copyin((caddr_t)ifr->ifr_data, spa, sizeof(*spa)) != 0) {
			free(spa, M_DEVBUF, 0);
			return EFAULT;
		}

		if (spa->proto != 0 && spa->proto != PPP_PAP &&
		    spa->proto != PPP_CHAP) {
			free(spa, M_DEVBUF, 0);
			return EINVAL;
		}

		if (spa->proto == 0) {
			/* resetting auth */
			if (auth->name != NULL)
				free(auth->name, M_DEVBUF, 0);
			if (auth->secret != NULL)
				free(auth->secret, M_DEVBUF, 0);
			bzero(auth, sizeof *auth);
			explicit_bzero(sp->chap_challenge, sizeof sp->chap_challenge);
		} else {
			/* setting/changing auth */
			auth->proto = spa->proto;
			auth->flags = spa->flags;

			spa->name[AUTHMAXLEN - 1] = '\0';
			len = strlen(spa->name) + 1;
			p = malloc(len, M_DEVBUF, M_WAITOK);
			strlcpy(p, spa->name, len);
			if (auth->name != NULL)
				free(auth->name, M_DEVBUF, 0);
			auth->name = p;

			if (spa->secret[0] != '\0') {
				spa->secret[AUTHMAXLEN - 1] = '\0';
				len = strlen(spa->secret) + 1;
				p = malloc(len, M_DEVBUF, M_WAITOK);
				strlcpy(p, spa->secret, len);
				if (auth->secret != NULL)
					free(auth->secret, M_DEVBUF, 0);
				auth->secret = p;
			} else if (!auth->secret) {
				p = malloc(1, M_DEVBUF, M_WAITOK);
				p[0] = '\0';
				auth->secret = p;
			}
		}
		free(spa, M_DEVBUF, 0);
		break;
	}
	default:
		return EINVAL;
	}

	return (ENETRESET);
}

void
sppp_phase_network(struct sppp *sp)
{
	int i;
	u_long mask;

	sp->pp_phase = PHASE_NETWORK;

	sppp_set_phase(sp);

	/* Notify NCPs now. */
	for (i = 0; i < IDX_COUNT; i++)
		if ((cps[i])->flags & CP_NCP)
			(cps[i])->Open(sp);

	/* Send Up events to all NCPs. */
	for (i = 0, mask = 1; i < IDX_COUNT; i++, mask <<= 1)
		if (sp->lcp.protos & mask && ((cps[i])->flags & CP_NCP))
			(cps[i])->Up(sp);

	/* if no NCP is starting, all this was in vain, close down */
	sppp_lcp_check_and_close(sp);
}


const char *
sppp_cp_type_name(u_char type)
{
	static char buf[12];
	switch (type) {
	case CONF_REQ:   return "conf-req";
	case CONF_ACK:   return "conf-ack";
	case CONF_NAK:   return "conf-nak";
	case CONF_REJ:   return "conf-rej";
	case TERM_REQ:   return "term-req";
	case TERM_ACK:   return "term-ack";
	case CODE_REJ:   return "code-rej";
	case PROTO_REJ:  return "proto-rej";
	case ECHO_REQ:   return "echo-req";
	case ECHO_REPLY: return "echo-reply";
	case DISC_REQ:   return "discard-req";
	}
	snprintf (buf, sizeof buf, "0x%x", type);
	return buf;
}

const char *
sppp_auth_type_name(u_short proto, u_char type)
{
	static char buf[12];
	switch (proto) {
	case PPP_CHAP:
		switch (type) {
		case CHAP_CHALLENGE:	return "challenge";
		case CHAP_RESPONSE:	return "response";
		case CHAP_SUCCESS:	return "success";
		case CHAP_FAILURE:	return "failure";
		}
	case PPP_PAP:
		switch (type) {
		case PAP_REQ:		return "req";
		case PAP_ACK:		return "ack";
		case PAP_NAK:		return "nak";
		}
	}
	snprintf (buf, sizeof buf, "0x%x", type);
	return buf;
}

const char *
sppp_lcp_opt_name(u_char opt)
{
	static char buf[12];
	switch (opt) {
	case LCP_OPT_MRU:		return "mru";
	case LCP_OPT_ASYNC_MAP:		return "async-map";
	case LCP_OPT_AUTH_PROTO:	return "auth-proto";
	case LCP_OPT_QUAL_PROTO:	return "qual-proto";
	case LCP_OPT_MAGIC:		return "magic";
	case LCP_OPT_PROTO_COMP:	return "proto-comp";
	case LCP_OPT_ADDR_COMP:		return "addr-comp";
	}
	snprintf (buf, sizeof buf, "0x%x", opt);
	return buf;
}

const char *
sppp_ipcp_opt_name(u_char opt)
{
	static char buf[12];
	switch (opt) {
	case IPCP_OPT_ADDRESSES:	return "addresses";
	case IPCP_OPT_COMPRESSION:	return "compression";
	case IPCP_OPT_ADDRESS:		return "address";
	}
	snprintf (buf, sizeof buf, "0x%x", opt);
	return buf;
}

#ifdef INET6
const char *
sppp_ipv6cp_opt_name(u_char opt)
{
	static char buf[12];
	switch (opt) {
	case IPV6CP_OPT_IFID:		return "ifid";
	case IPV6CP_OPT_COMPRESSION:	return "compression";
	}
	snprintf (buf, sizeof buf, "0x%x", opt);
	return buf;
}
#endif

const char *
sppp_state_name(int state)
{
	switch (state) {
	case STATE_INITIAL:	return "initial";
	case STATE_STARTING:	return "starting";
	case STATE_CLOSED:	return "closed";
	case STATE_STOPPED:	return "stopped";
	case STATE_CLOSING:	return "closing";
	case STATE_STOPPING:	return "stopping";
	case STATE_REQ_SENT:	return "req-sent";
	case STATE_ACK_RCVD:	return "ack-rcvd";
	case STATE_ACK_SENT:	return "ack-sent";
	case STATE_OPENED:	return "opened";
	}
	return "illegal";
}

const char *
sppp_phase_name(enum ppp_phase phase)
{
	switch (phase) {
	case PHASE_DEAD:	return "dead";
	case PHASE_ESTABLISH:	return "establish";
	case PHASE_TERMINATE:	return "terminate";
	case PHASE_AUTHENTICATE: return "authenticate";
	case PHASE_NETWORK:	return "network";
	}
	return "illegal";
}

const char *
sppp_proto_name(u_short proto)
{
	static char buf[12];
	switch (proto) {
	case PPP_LCP:	return "lcp";
	case PPP_IPCP:	return "ipcp";
	case PPP_IPV6CP: return "ipv6cp";
	case PPP_PAP:	return "pap";
	case PPP_CHAP:	return "chap";
	}
	snprintf(buf, sizeof buf, "0x%x", (unsigned)proto);
	return buf;
}

void
sppp_print_bytes(const u_char *p, u_short len)
{
	addlog(" %02x", *p++);
	while (--len > 0)
		addlog("-%02x", *p++);
}

void
sppp_print_string(const char *p, u_short len)
{
	u_char c;

	while (len-- > 0) {
		c = *p++;
		/*
		 * Print only ASCII chars directly.  RFC 1994 recommends
		 * using only them, but we don't rely on it.  */
		if (c < ' ' || c > '~')
			addlog("\\x%x", c);
		else
			addlog("%c", c);
	}
}

const char *
sppp_dotted_quad(u_int32_t addr)
{
	static char s[16];
	snprintf(s, sizeof s, "%d.%d.%d.%d",
		(int)((addr >> 24) & 0xff),
		(int)((addr >> 16) & 0xff),
		(int)((addr >> 8) & 0xff),
		(int)(addr & 0xff));
	return s;
}

/* a dummy, used to drop uninteresting events */
void
sppp_null(struct sppp *unused)
{
	/* do just nothing */
}

void
sppp_set_phase(struct sppp *sp)
{
	STDDCL;
	int lstate;

	if (debug)
		log(LOG_INFO, SPP_FMT "phase %s\n", SPP_ARGS(ifp),
		    sppp_phase_name(sp->pp_phase));

	/* set link state */
	if (sp->pp_phase == PHASE_NETWORK)
		lstate = LINK_STATE_UP;
	else
		lstate = LINK_STATE_DOWN;

	if (ifp->if_link_state != lstate) {
		ifp->if_link_state = lstate;
		if_link_state_change(ifp);
	}
}
@


1.169
log
@space after if.

Pointed out by tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.168 2017/08/11 15:12:32 reyk Exp $	*/
d4051 1
a4051 1
	int s, sl;
d4054 1
a4054 1
	NET_LOCK(sl);
d4106 1
a4106 1
	NET_UNLOCK(sl);
a4194 1
	int s;
d4205 1
a4205 1
	NET_LOCK(s);
d4249 1
a4249 1
	NET_UNLOCK(s);
a4265 1
	int s;
d4267 1
a4267 1
	NET_LOCK(s);
d4309 1
a4309 1
	NET_UNLOCK(s);
d4360 1
a4360 1
	int s, error;
d4362 1
a4362 1
	NET_LOCK(s);
d4403 1
a4403 1
	NET_UNLOCK(s);
@


1.168
log
@Revision 1.139 accidentally removed an ip = mtod(), resulting in a
pointless "ip = NULL; if (ip) ..." sequence.

Coverity CID 1453286; Severity: Minor

OK sthen@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.167 2017/08/11 13:23:27 reyk Exp $	*/
d603 1
a603 1
		if(ip && ip->ip_src.s_addr == INADDR_ANY) {
d608 1
a608 1
			if(proto == IPPROTO_TCP)
@


1.167
log
@The timeval in sppp_input() is also used when the interface is not IFF_UP.

Always call getmicrouptime(&tv) to avoid an "Uninitialized scalar variable".

Coverity CID 1453266; Severity: Insignificant

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.166 2017/08/01 20:52:32 mpi Exp $	*/
d588 3
@


1.166
log
@Add missing splx().

I introduced this bug in 2015 but the splsoftnet()/splx() dance in the
upper layer masked it.  Pseudo drivers generally don't need any splnet()
protection.

Found by Mark Patruck and Andrei-Marius Radu since the NET_LOCK() no longer
raise any IPL.

Strangely jsg@@ confirmed that cppcheck nor coccinelle found the missing splx().

ok kettenis@@, sthen@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.165 2017/06/16 10:58:43 stsp Exp $	*/
d422 2
a427 1
		getmicrouptime(&tv);
@


1.165
log
@In sppp(4), allow additional 'wildcard' addresses for the destination.
Any address within the range 0.0.0.1 - 0.0.0.255 can now be used.
This allows for multiple pppoe(4) interfaces with dynamic addresses within
the same routing table. Which used to work before OpenBSD 5.8, but since 5.8
only one interface in a routing table can use destination address 0.0.0.1.

Problem first reported by Steve (fiverings04 at australian yahoo) on misc@@.
I ran into it on an EdgeRouter lite which is supposed to serve two ADSL lines.
ok sthen@@ mpi@@
man page help from jmc@@ for an earlier variant of this change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.164 2017/05/30 07:50:37 mpi Exp $	*/
d668 1
d678 1
@


1.164
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.163 2017/04/14 15:11:31 bluhm Exp $	*/
d2635 1
a2635 1
	if (hisaddr == 1) {
@


1.163
log
@Avoid some false positives with cppcheck.  No binary change.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.162 2017/01/24 10:08:30 krw Exp $	*/
a60 2
#include <netinet/tcp.h>
#include <netinet/if_ether.h>
a417 1
	struct niqueue *inq = NULL;
a437 1
	  dropped:
a501 1
				inq = &ipintrq;
d503 4
a516 1
				inq = &ip6intrq;
d518 4
d538 1
a538 10
	if (! (ifp->if_flags & IFF_UP) || ! inq)
		goto drop;

	if (niq_enqueue(inq, m) != 0) {
		/* Queue overflow. */
		if (debug)
			log(LOG_DEBUG, SPP_FMT "protocol queue overflow\n",
				SPP_ARGS(ifp));
		goto dropped;
	}
@


1.162
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.161 2017/01/21 05:36:33 dlg Exp $	*/
d3103 1
a3103 1
p		opt[i++] = 0;   /* TBD */
@


1.161
log
@remove some extra whitespace.

no functional change (unfortunately)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.160 2017/01/20 00:51:56 mpi Exp $	*/
d73 2
a74 2
#define LOOPALIVECNT     		3	/* loopback detection tries */
#define MAXALIVECNT    			3	/* max. missed alive packets */
d1542 1
a1542 1
  			sppp_increasing_timeout (cp, sp);
d1551 1
a1551 1
  			sppp_increasing_timeout (cp, sp);
@


1.160
log
@No need to handle SIOCAIFADDR in drivers, it's never passed down to
them.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.159 2017/01/08 02:16:08 bluhm Exp $	*/
d22 2
a23 2
 * THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT ``AS IS'' AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
d31 1
a31 1
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   
d403 1
a403 1
/*
d893 1
a893 1
/*
d1327 1
a1327 1
		    
d1593 1
a1593 1
/*
d2254 1
a2254 1
/*
d3660 1
a3660 1
/*
d3965 1
a3965 1
/*
d4373 1
a4373 1
	/* 
d4387 1
a4387 1
	/* 
d4432 1
a4432 1
	/* 
d4538 1
a4538 1
		
@


1.159
log
@When if_down() is called, sppp_keepalive() needs a NET_LOCK().
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.158 2017/01/02 08:41:21 mpi Exp $	*/
a826 1
	case SIOCAIFADDR:
@


1.158
log
@Grab the NET_LOCK() when setting an IPv6 address, just like it is done
for IPv4.

Assert reported and diff tested by semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.157 2016/12/19 08:36:49 mpi Exp $	*/
d696 1
a696 1
		timeout_set(&keepalive_ch, sppp_keepalive, NULL);
d4053 1
a4053 1
	int s;
d4056 1
d4108 1
@


1.157
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.156 2016/11/16 14:25:19 mpi Exp $	*/
d4245 1
a4245 2
			NET_UNLOCK(s);
			return;
d4249 1
d4306 1
a4306 2
			NET_UNLOCK(s);
			return;
d4310 1
d4364 1
a4364 1
	s = splnet();
d4369 1
a4369 2
		splx(s);
		return;
d4383 1
a4383 2
		splx(s);
		return;
d4404 2
a4405 1
	splx(s);
@


1.156
log
@if_link_state_change() doesn't need to be called under splsoftnet(),
it just schedule a task.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.155 2016/07/11 13:06:31 bluhm Exp $	*/
d4196 1
a4196 1
	
a4204 1
	s = splsoftnet();
d4206 1
d4245 1
a4245 1
			splx(s);
d4250 1
a4250 1
	splx(s);
d4269 1
a4269 1
	s = splsoftnet();
d4306 1
a4306 1
			splx(s);
d4311 1
a4311 1
	splx(s);
@


1.155
log
@Path MTU discovery was slightly broken.  I took two ICMP packets
to create and change the dynamic route.  This behavior was introduced
in net/route.c rev 1.269 when the gateway route allocation was moved
from rt_setgateway() to _rtalloc().  So rtrequest(RTM_ADD) could
return a route without a valid gateway route.  To fix this, call
rt_setgwroute() from _rtalloc() and rt_setgateway().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.154 2016/06/14 20:44:43 sthen Exp $	*/
d4838 1
a4838 1
	int lstate, s;
a4851 1
		s = splsoftnet();
a4852 1
		splx(s);
@


1.154
log
@Don't hardcode vlan/queue priority for pppoe packets; inherit it from the
new "llprio" setting on the pppoe(4) interface instead.

Tested by Daniel Gillen and myself, ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.153 2016/05/30 23:30:10 sthen Exp $	*/
d4164 1
a4164 1
		rt_setgate(rt, rt->rt_ifa->ifa_dstaddr);
@


1.153
log
@Set pppoe(4) control frames to high (NC, "network control")
priority.  This is translated into an 802.1p priority tag when
sent over a vlan interface, reducing the risk of them being
crowded out by data packets on a busy link.

Some users have problems with ISPs that place specific
requirements on vlan priority (typically the packet header
value must be '0', relating to priority 1).  This diff
doesn't fix that yet, but gives a single place to patch
to change tags on control packets without affecting
normal vlan priority operation on other interfaces.

ok mikeb.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.152 2016/05/02 22:15:49 jmatthew Exp $	*/
d917 1
a917 1
	m->m_pkthdr.pf.prio = SPPP_CTL_PRIO;
d3995 1
a3995 1
	m->m_pkthdr.pf.prio = SPPP_CTL_PRIO;
@


1.152
log
@Simplify life for routing table implementations by requiring that rtable_walk
callbacks return EAGAIN if they modify the routing table.  While we're here,
simplify life for rtable_walk callers by moving the loop that restarts the
walk on EAGAIN into rtable_walk itself.

Flushing cloned routes on interface state changes becomes a bit more
inefficient, but this can be improved later.

ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.151 2016/05/01 14:08:39 sthen Exp $	*/
d917 1
d3995 1
@


1.151
log
@Remove a bogus "else" that was causing breakage with LCP echoes,
bug introduced in r1.138.

Reported at https://twitter.com/DarkSoul4242/status/722365165262405633
(twitter is *NOT* the place to report bugs!) and in
https://marc.info/?l=openbsd-bugs&m=145988918010707&w=2,
pointed out by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.150 2016/04/18 14:38:09 mikeb Exp $	*/
d4174 1
a4174 3
		while (rtable_walk(tid, AF_INET, sppp_update_gw_walker,
		    ifp) == EAGAIN)
			;	/* nothing */
@


1.150
log
@Remove the hack that prevents changing pppoe params at runtime.

The EBUSY hack imposes an order on the ifconfig commands issued
against the pppoe interface used to configure the sppp layer below.
To counter this we use the ENETRESET trick that other drivers use
to tell the pppoe layer that sppp has requested a stop/init reset
sequence to proceed which we oblige with in case pppoe is UP and
RUNNING.

Tested by semarie@@ and Jan Schreiber <jes@@posteo.de>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.149 2015/11/23 14:41:05 sthen Exp $	*/
d4097 1
a4097 1
		else if (sp->pp_phase >= PHASE_AUTHENTICATE) {
@


1.149
log
@if_start needs splnet. help/ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.148 2015/11/20 12:05:34 sthen Exp $	*/
a4531 13
	/*
	 * We have a very specific idea of which fields we allow
	 * being passed back from userland, so to not clobber our
	 * current state.  For one, we only allow setting
	 * anything if LCP is in dead phase.  Once the LCP
	 * negotiations started, the authentication settings must
	 * not be changed again.  (The administrator can force an
	 * ifconfig down in order to get LCP back into dead
	 * phase.)
	 */
	if (sp->pp_phase != PHASE_DEAD)
		return EBUSY;

d4628 1
a4628 1
	return 0;
@


1.149.2.1
log
@MFC if_spppsubr.c r1.151

Remove a bogus "else" that was causing breakage with LCP echoes,
bug introduced in r1.138.

(specifically, when the line was quiescent we should have been sending
echoes, the bug caused this not to occur resulting in some unwanted
termination req's).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.149 2015/11/23 14:41:05 sthen Exp $	*/
d4097 1
a4097 1
		if (sp->pp_phase >= PHASE_AUTHENTICATE) {
@


1.148
log
@sppp(4) is now only used for pppoe(4) which doesn't use framing, so remove
support for sppp with framing, simplifying things. Remove unused ifdefs while
there.

"sppp will go away before it gets used for something else" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.147 2015/11/20 11:53:36 dlg Exp $	*/
d906 1
d944 1
d946 1
d3985 1
a3985 1
	int len;
d4039 1
d4041 1
@


1.147
log
@avoid a use after enqueue, which is like a use after free.

once you enqueue an mbuf, you no longer own it. therefore you cant
read the length out of it. this reads the length first, then tries
to enq it.

also, call if_start instead of a bare call to the underlying start
routine.

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.146 2015/11/11 01:49:17 dlg Exp $	*/
d165 2
d450 4
a453 10
	if (sp->pp_flags & PP_NOFRAMING) {
		m_copydata(m, 0, sizeof(ht.protocol), (caddr_t)&ht.protocol);
		m_adj(m, 2);
		ht.control = PPP_UI;
		ht.address = PPP_ALLSTATIONS;
	} else {
		/* Get PPP header. */
		m_copydata(m, 0, sizeof(ht), (caddr_t)&ht);
		m_adj (m, PPP_HEADER_LEN);
	}
a555 1
	struct ppp_header *h;
a617 23
	if (sp->pp_flags & PP_NOFRAMING)
		goto skip_header;
	/*
	 * Prepend general data packet PPP header. For now, IP only.
	 */
	M_PREPEND (m, PPP_HEADER_LEN, M_DONTWAIT);
	if (!m) {
		if (ifp->if_flags & IFF_DEBUG)
			log(LOG_DEBUG, SPP_FMT "no memory for transmit header\n",
				SPP_ARGS(ifp));
		++ifp->if_oerrors;
		splx (s);
		return (ENOBUFS);
	}
	/*
	 * May want to check size of packet
	 * (albeit due to the implementation it's always enough)
	 */
	h = mtod (m, struct ppp_header*);
	h->address = PPP_ALLSTATIONS;        /* broadcast address */
	h->control = PPP_UI;                 /* Unnumbered Info */

 skip_header:
d656 11
a666 14
	if (sp->pp_flags & PP_NOFRAMING) {
		M_PREPEND(m, 2, M_DONTWAIT);
		if (m == NULL) {
			if (ifp->if_flags & IFF_DEBUG)
				log(LOG_DEBUG, SPP_FMT
				    "no memory for transmit header\n",
				    SPP_ARGS(ifp));
			++ifp->if_oerrors;
			splx(s);
			return (ENOBUFS);
		}
		*mtod(m, u_int16_t *) = protocol;
	} else
		h->protocol = protocol;
a859 1
#ifdef SIOCSIFMTU
a868 13
#endif
#ifdef SLIOCSETMTU
	case SLIOCSETMTU:
		if (*(short*)data < 128 ||
		    (sp->lcp.their_mru > 0 &&
		     *(short*)data > sp->lcp.their_mru)) {
			splx(s);
			return (EINVAL);
		}
		ifp->if_mtu = *(short*)data;
		break;
#endif
#ifdef SIOCGIFMTU
a871 2
#endif
#ifdef SIOCGIFHARDMTU
a874 6
#endif
#ifdef SLIOCGETMTU
	case SLIOCGETMTU:
		*(short*)data = ifp->if_mtu;
		break;
#endif
a905 1
	struct ppp_header *h;
a907 1
	size_t pkthdrlen;
d909 2
a910 4
	pkthdrlen = (sp->pp_flags & PP_NOFRAMING) ? 2 : PPP_HEADER_LEN;

	if (len > MHLEN - pkthdrlen - LCP_HEADER_LEN)
		len = MHLEN - pkthdrlen - LCP_HEADER_LEN;
d914 1
a914 1
	m->m_pkthdr.len = m->m_len = pkthdrlen + LCP_HEADER_LEN + len;
d917 2
a918 10
	if (sp->pp_flags & PP_NOFRAMING) {
		*mtod(m, u_int16_t *) = htons(proto);
		lh = (struct lcp_header *)(mtod(m, u_int8_t *) + 2);
	} else {	
		h = mtod (m, struct ppp_header*);
		h->address = PPP_ALLSTATIONS;	/* broadcast address */
		h->control = PPP_UI;		/* Unnumbered Info */
		h->protocol = htons (proto);	/* Link Control Protocol */
		lh = (struct lcp_header*) (h + 1);
	}
a3978 1
	struct ppp_header *h;
a3982 1
	size_t pkthdrlen;
d3992 2
a3993 12
	if (sp->pp_flags & PP_NOFRAMING) {
		*mtod(m, u_int16_t *) = htons(cp->proto);
		pkthdrlen = 2;
		lh = (struct lcp_header *)(mtod(m, u_int8_t *) + 2);
	} else {
		h = mtod (m, struct ppp_header*);
		h->address = PPP_ALLSTATIONS;	/* broadcast address */
		h->control = PPP_UI;		/* Unnumbered Info */
		h->protocol = htons(cp->proto);
		pkthdrlen = PPP_HEADER_LEN;
		lh = (struct lcp_header*)(h + 1);
	}
d4005 1
a4005 1
		if (len > MHLEN - pkthdrlen - LCP_HEADER_LEN) {
d4016 1
a4016 1
	m->m_pkthdr.len = m->m_len = pkthdrlen + LCP_HEADER_LEN + len;
@


1.146
log
@replace the ifqueue used for the pp_cpq with an mbuf_queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.145 2015/11/09 10:26:26 mpi Exp $	*/
d1000 2
d1003 2
a1004 2
		++ifp->if_oerrors;
		m = NULL;
d1006 3
a1008 4
	if (!(ifp->if_flags & IFF_OACTIVE))
		(*ifp->if_start) (ifp);
	if (m != NULL)
		ifp->if_obytes += m->m_pkthdr.len + sp->pp_framebytes;
d4105 2
d4108 2
a4109 2
		++ifp->if_oerrors;
		m = NULL;
d4111 3
a4113 4
	if (! (ifp->if_flags & IFF_OACTIVE))
		(*ifp->if_start) (ifp);
	if (m != NULL)
		ifp->if_obytes += m->m_pkthdr.len + sp->pp_framebytes;
@


1.145
log
@Rewrite rtalloc(9) to consider RTF_GATEWAY entries without valid next-
hop route as invalid.

Previously when such entrie was returned by rtalloc(9) a second route
lookup was done in rt_checkgate() very late in the journey of a packet.

In other words a single rtalloc(9) call can now result in multiple
route lookups if a RTF_GATEWAY entry is returned.

This is a step towards always calling L2 output functions with valid
destination information.

Tested by various including jmc@@, naddy@@, Hrvoje Popovski
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.144 2015/11/02 11:19:30 dlg Exp $	*/
a336 1
void sppp_qflush(struct ifqueue *ifq);
d738 1
a738 1
	IFQ_SET_MAXLEN(&sp->pp_cpq, 50);
d804 1
a804 1
	sppp_qflush (&sp->pp_cpq);
d817 1
a817 2
	empty = IF_IS_EMPTY(&sp->pp_cpq) &&
		IFQ_IS_EMPTY(&sp->pp_if.if_snd);
d837 1
a837 1
	IF_DEQUEUE(&sp->pp_cpq, m);
d1000 1
a1000 3
	if (IF_QFULL (&sp->pp_cpq)) {
		IF_DROP (&ifp->if_snd);
		m_freem (m);
d1003 1
a1003 2
	} else
		IF_ENQUEUE (&sp->pp_cpq, m);
d4104 1
a4104 3
	if (IF_QFULL (&sp->pp_cpq)) {
		IF_DROP (&ifp->if_snd);
		m_freem (m);
d4107 1
a4107 2
	} else
		IF_ENQUEUE (&sp->pp_cpq, m);
a4114 9
 * Flush interface queue.
 */
void
sppp_qflush(struct ifqueue *ifq)
{
	IF_PURGE(ifq);
}

/*
d4147 1
a4147 1
			sppp_qflush (&sp->pp_cpq);
@


1.144
log
@sppp_pick is unused, it can go away.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.143 2015/10/25 11:58:11 mpi Exp $	*/
d4247 1
a4247 1
		    (rt->rt_flags & RTF_GATEWAY) == 0)
d4249 1
a4249 2
		bcopy(rt->rt_ifa->ifa_dstaddr, rt->rt_gateway,
		    rt->rt_ifa->ifa_dstaddr->sa_len);
@


1.143
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.142 2015/10/24 11:58:46 mpi Exp $	*/
a844 20
}

/*
 * Pick the next packet, do not remove it from the queue.
 */
struct mbuf *
sppp_pick(struct ifnet *ifp)
{
	struct sppp *sp = (struct sppp*)ifp;
	struct mbuf *m;
	int s;

	s = splnet();
	IF_POLL(&sp->pp_cpq, m);
	if (m == NULL &&
	    (sp->pp_phase == PHASE_NETWORK)) {
		IFQ_POLL(&sp->pp_if.if_snd, m);
	}
	splx (s);
	return (m);
@


1.142
log
@Some rt_ifp to rt_ifidx conversions.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.141 2015/10/05 19:05:09 uebayasi Exp $	*/
a873 1
	struct ifaddr *ifa = data;
a885 1
		ifa->ifa_rtrequest = p2p_rtrequest;
@


1.141
log
@Revert if_oqdrops accounting changes done in kernel, per request from mpi@@.

(Especially adding IF_DROP() after IFQ_ENQUEUE() was completely wrong because
IFQ_ENQUEUE() already does it.  Oops.)

After this revert, the situation becomes:

- if_snd.ifq_drops is incremented in either IFQ_ENQUEUE() or IF_DROP(), but
  it is not shown to userland, and

- if_data.ifi_oqdrops is shown to userland, but it is not incremented by
  anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4266 1
a4266 1
	if (rt->rt_ifp == ifp) {
@


1.140
log
@Don't count IF_DROP()'ed packets as if_oerrors too.

mpi@@ plans to clean-up IF_DROP()'s, but fix consistent use of it for now.

OK dlg@@
@
text
@d1027 1
d4134 1
@


1.139
log
@Remove remnants of sppp's special queue handling for telnet/rlogin/ftp,
the rest was done in r1.96.  ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.138 2015/09/30 09:45:20 sthen Exp $	*/
a1026 1
		++ifp->if_oerrors;
a4132 1
		++ifp->if_oerrors;
@


1.138
log
@remove cisco hdlc code from sppp(4), it's no longer used - pppoe(4) only uses
ppp framing, and the drivers for sync serial cards have been removed so the
sppp code is now only used to support pppoe(4).  ok mpi@@, kill it chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.137 2015/08/24 15:58:35 mpi Exp $	*/
a597 4
	/*
	 * Put low delay, telnet, rlogin and ftp control packets
	 * in front of the queue.
	 */
a599 1
		struct tcphdr *th = NULL;
a600 9
		if (m->m_len >= sizeof(struct ip)) {
			ip = mtod(m, struct ip *);
			if (ip->ip_p == IPPROTO_TCP &&
			    m->m_len >= sizeof(struct ip) + (ip->ip_hl << 2) +
			    sizeof(struct tcphdr)) {
				th = (struct tcphdr *)
				    ((caddr_t)ip + (ip->ip_hl << 2));
			}
		}
@


1.137
log
@Rework the code to decide when to perform DAD to no longer rely on the
IN6_IFF_NODAD pseudo-flag not being set.

This was just a flag for spaghetti code that should not exist in the
first place.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.136 2015/07/18 15:51:16 mpi Exp $	*/
d3 1
a3 2
 * Synchronous PPP/Cisco link level subroutines.
 * Keepalive protocol implemented in both Cisco and PPP modes.
d95 1
a95 1
 * being one of "lcp", "ipcp", "cisco", "chap", "pap", etc.
a152 7
#define CISCO_MULTICAST		0x8f	/* Cisco multicast address */
#define CISCO_UNICAST		0x0f	/* Cisco unicast address */
#define CISCO_KEEPALIVE		0x8035	/* Cisco keepalive protocol */
#define CISCO_ADDR_REQ		0	/* Cisco address request */
#define CISCO_ADDR_REPLY	1	/* Cisco address reply */
#define CISCO_KEEPALIVE_REQ	2	/* Cisco keepalive request */

a178 10
struct cisco_packet {
	u_int32_t type;
	u_int32_t par1;
	u_int32_t par2;
	u_short rel;
	u_short time0;
	u_short time1;
};
#define CISCO_PACKET_LEN 18

a224 3
void sppp_cisco_send(struct sppp *sp, u_int32_t type, u_int32_t par1, u_int32_t par2);
void sppp_cisco_input(struct sppp *sp, struct mbuf *m);

a476 9
		if (sp->pp_flags & PP_CISCO) {
			if (debug)
				log(LOG_DEBUG,
				    SPP_FMT "PPP packet in Cisco mode "
				    "<addr=0x%x ctrl=0x%x proto=0x%x>\n",
				    SPP_ARGS(ifp),
				    ht.address, ht.control, ntohs(ht.protocol));
			goto drop;
		}
a529 30
	case CISCO_MULTICAST:
	case CISCO_UNICAST:
		/* Don't check the control field here (RFC 1547). */
		if (! (sp->pp_flags & PP_CISCO)) {
			if (debug)
				log(LOG_DEBUG,
				    SPP_FMT "Cisco packet in PPP mode "
				    "<addr=0x%x ctrl=0x%x proto=0x%x>\n",
				    SPP_ARGS(ifp),
				    ht.address, ht.control, ntohs(ht.protocol));
			goto drop;
		}
		switch (ntohs (ht.protocol)) {
		default:
			++ifp->if_noproto;
			goto invalid;
		case CISCO_KEEPALIVE:
			sppp_cisco_input ((struct sppp*) ifp, m);
			m_freem (m);
			return;
		case ETHERTYPE_IP:
			inq = &ipintrq;
			break;
#ifdef INET6
		case ETHERTYPE_IPV6:
			inq = &ip6intrq;
			break;
#endif
		}
		break;
d657 2
a658 7
	if (sp->pp_flags & PP_CISCO) {
		h->address = CISCO_UNICAST;        /* unicast address */
		h->control = 0;
	} else {
		h->address = PPP_ALLSTATIONS;        /* broadcast address */
		h->control = PPP_UI;                 /* Unnumbered Info */
	}
d663 12
a674 16
		if (sp->pp_flags & PP_CISCO)
			protocol = htons (ETHERTYPE_IP);
		else {
			/*
			 * Don't choke with an ENETDOWN early.  It's
			 * possible that we just started dialing out,
			 * so don't drop the packet immediately.  If
			 * we notice that we run out of buffer space
			 * below, we will however remember that we are
			 * not ready to carry IP packets, and return
			 * ENETDOWN, as opposed to ENOBUFS.
			 */
			protocol = htons(PPP_IP);
			if (sp->state[IDX_IPCP] != STATE_OPENED)
				rv = ENETDOWN;
		}
d678 12
a689 16
		if (sp->pp_flags & PP_CISCO)
			protocol = htons (ETHERTYPE_IPV6);
		else {
			/*
			 * Don't choke with an ENETDOWN early.  It's
			 * possible that we just started dialing out,
			 * so don't drop the packet immediately.  If
			 * we notice that we run out of buffer space
			 * below, we will however remember that we are
			 * not ready to carry IPv6 packets, and return
			 * ENETDOWN, as opposed to ENOBUFS.
			 */
			protocol = htons(PPP_IPV6);
			if (sp->state[IDX_IPV6CP] != STATE_OPENED)
				rv = ENETDOWN;
		}
a851 2
	 *
	 * Do always serve all queues in Cisco mode.
d854 1
a854 2
	if (m == NULL &&
	    (sppp_ncp_check(sp) || (sp->pp_flags & PP_CISCO) != 0)) {
d874 1
a874 2
	    (sp->pp_phase == PHASE_NETWORK ||
	     (sp->pp_flags & PP_CISCO) != 0)) {
d917 1
a917 2
			if (!(sp->pp_flags & PP_CISCO))
				lcp.Close(sp);
d922 1
a922 2
			if (!(sp->pp_flags & PP_CISCO))
				lcp.Open(sp);
a984 128

/*
 * Cisco framing implementation.
 */

/*
 * Handle incoming Cisco keepalive protocol packets.
 */
void
sppp_cisco_input(struct sppp *sp, struct mbuf *m)
{
	STDDCL;
	struct cisco_packet *h;
	u_int32_t me, mymask;

	if (m->m_pkthdr.len < CISCO_PACKET_LEN) {
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "cisco invalid packet length: %d bytes\n",
			    SPP_ARGS(ifp), m->m_pkthdr.len);
		return;
	}
	h = mtod (m, struct cisco_packet*);
	if (debug)
		log(LOG_DEBUG,
		    SPP_FMT "cisco input: %d bytes "
		    "<0x%x 0x%x 0x%x 0x%x 0x%x-0x%x>\n",
		    SPP_ARGS(ifp), m->m_pkthdr.len,
		    ntohl(h->type), h->par1, h->par2, (u_int)h->rel,
		    (u_int)h->time0, (u_int)h->time1);
	switch (ntohl (h->type)) {
	default:
		if (debug)
			addlog(SPP_FMT "cisco unknown packet type: 0x%x\n",
			       SPP_ARGS(ifp), ntohl(h->type));
		break;
	case CISCO_ADDR_REPLY:
		/* Reply on address request, ignore */
		break;
	case CISCO_KEEPALIVE_REQ:
		sp->pp_alivecnt = 0;
		sp->pp_rseq = ntohl (h->par1);
		if (sp->pp_seq == sp->pp_rseq) {
			/* Local and remote sequence numbers are equal.
			 * Probably, the line is in loopback mode. */
			if (sp->pp_loopcnt >= LOOPALIVECNT) {
				log(LOG_INFO, SPP_FMT "loopback\n",
					SPP_ARGS(ifp));
				sp->pp_loopcnt = 0;
				if (ifp->if_flags & IFF_UP) {
					if_down (ifp);
					sppp_qflush (&sp->pp_cpq);
				}
			}
			++sp->pp_loopcnt;

			/* Generate new local sequence number */
			sp->pp_seq = arc4random();
			break;
		}
		sp->pp_loopcnt = 0;
		if (! (ifp->if_flags & IFF_UP) &&
		    (ifp->if_flags & IFF_RUNNING)) {
			if_up(ifp);
			if (debug)
				log(LOG_INFO, SPP_FMT "up\n", SPP_ARGS(ifp));
		}
		break;
	case CISCO_ADDR_REQ:
		sppp_get_ip_addrs(sp, &me, 0, &mymask);
		if (me != 0)
			sppp_cisco_send(sp, CISCO_ADDR_REPLY, me, mymask);
		break;
	}
}

/*
 * Send Cisco keepalive packet.
 */
void
sppp_cisco_send(struct sppp *sp, u_int32_t type, u_int32_t par1, u_int32_t par2)
{
	STDDCL;
	struct ppp_header *h;
	struct cisco_packet *ch;
	struct mbuf *m;
	struct timeval tv;	

	getmicrouptime(&tv);

	MGETHDR (m, M_DONTWAIT, MT_DATA);
	if (! m)
		return;
	m->m_pkthdr.len = m->m_len = PPP_HEADER_LEN + CISCO_PACKET_LEN;
	m->m_pkthdr.ph_ifidx = 0;

	h = mtod (m, struct ppp_header*);
	h->address = CISCO_MULTICAST;
	h->control = 0;
	h->protocol = htons (CISCO_KEEPALIVE);

	ch = (struct cisco_packet*) (h + 1);
	ch->type = htonl (type);
	ch->par1 = htonl (par1);
	ch->par2 = htonl (par2);
	ch->rel = -1;

	ch->time0 = htons ((u_short) (tv.tv_sec >> 16));
	ch->time1 = htons ((u_short) tv.tv_sec);

	if (debug)
		log(LOG_DEBUG, SPP_FMT
		    "cisco output: <0x%x 0x%x 0x%x 0x%x 0x%x-0x%x>\n",
			SPP_ARGS(ifp), ntohl(ch->type), ch->par1, ch->par2,
			(u_int)ch->rel, (u_int)ch->time0, (u_int)ch->time1);

	if (IF_QFULL (&sp->pp_cpq)) {
		IF_DROP (&ifp->if_snd);
		m_freem (m);
		m = NULL;
	} else
		IF_ENQUEUE (&sp->pp_cpq, m);
	if (! (ifp->if_flags & IFF_OACTIVE))
		(*ifp->if_start) (ifp);
	if (m != NULL)
		ifp->if_obytes += m->m_pkthdr.len + sp->pp_framebytes;
}

a1731 8
	if (sp->pp_flags & PP_CISCO) {
		int s = splsoftnet();
		sp->pp_if.if_link_state = LINK_STATE_UP;
		if_link_state_change(&sp->pp_if);
		splx(s);
		return;
	}

a1776 8
	if (sp->pp_flags & PP_CISCO) {
		int s = splsoftnet();
		sp->pp_if.if_link_state = LINK_STATE_DOWN;
		if_link_state_change(&sp->pp_if);
		splx(s);
		return;
	}

d4187 2
a4188 3
		/* No keepalive in PPP mode if LCP not opened yet. */
		if (! (sp->pp_flags & PP_CISCO) &&
		    sp->pp_phase < PHASE_AUTHENTICATE)
d4192 1
a4192 2
		if (!(sp->pp_flags & PP_CISCO) &&
		    (tv.tv_sec - sp->pp_last_receive) < NORECV_TIME) {
d4201 3
a4203 4
			if (! (sp->pp_flags & PP_CISCO)) {
				log(LOG_INFO, SPP_FMT "LCP keepalive timeout\n",
				    SPP_ARGS(ifp));
				sp->pp_alivecnt = 0;
d4205 2
a4206 2
				/* we are down, close all open protocols */
				lcp.Close(sp);
d4208 9
a4216 9
				/* And now prepare LCP to reestablish the link, if configured to do so. */
				sppp_cp_change_state(&lcp, sp, STATE_STOPPED);

				/* Close connection immediately, completition of this
				 * will summon the magic needed to reestablish it. */
				if (sp->pp_tlf)
					sp->pp_tlf(sp);
				continue;
			}
a4219 3
		if (sp->pp_flags & PP_CISCO)
			sppp_cisco_send (sp, CISCO_KEEPALIVE_REQ, ++sp->pp_seq,
				sp->pp_rseq);
@


1.136
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.135 2015/06/30 13:54:42 mpi Exp $	*/
a4791 3

	/* DAD is redundant after an IPv6CP exchange. */
	ifra->ifra_flags |= IN6_IFF_NODAD;
@


1.135
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.134 2015/06/16 11:09:39 mpi Exp $	*/
d359 1
a359 1
int sppp_update_gw_walker(struct radix_node *rn, void *arg, u_int);
d4505 1
a4505 1
sppp_update_gw_walker(struct radix_node *rn, void *arg, u_int id)
a4507 1
	struct rtentry *rt = (struct rtentry *)rn;
a4522 1
        struct radix_node_head *rnh;
d4527 3
a4529 5
		if ((rnh = rtable_get(tid, AF_INET)) != NULL) {
			while ((*rnh->rnh_walktree)(rnh,
			    sppp_update_gw_walker, ifp) == EAGAIN)
				;	/* nothing */
		}
@


1.134
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.133 2015/05/15 10:15:13 mpi Exp $	*/
d791 1
a791 1
	rv = if_output(ifp, m);
@


1.133
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.132 2015/04/10 13:58:20 dlg Exp $	*/
d1158 1
a1158 1
	m->m_pkthdr.rcvif = 0;
d1217 1
a1217 1
	m->m_pkthdr.rcvif = 0;
d4320 1
a4320 1
	m->m_pkthdr.rcvif = 0;
@


1.132
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.131 2015/03/18 12:23:15 dlg Exp $	*/
d623 1
a623 1
	int s, len, rv = 0;
d791 1
a791 3
	len = m->m_pkthdr.len;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);

d793 1
a793 2
		++ifp->if_oerrors;
		splx (s);
a796 3
	if (!(ifp->if_flags & IFF_OACTIVE))
		(*ifp->if_start) (ifp);

d802 2
a803 2
	ifp->if_obytes += len + sp->pp_framebytes;
	splx (s);
@


1.131
log
@remove the congestion handling from struct ifqueue.

its only used for the ip and ip6 network stack input queues, so it
seems unfair that every instance of ifqueue has to carry a pointer
around for this specific use case.

this moves the congestion marker to a kernel global. if we detect
that we're congested, we assume the whole system is busy and punish
all input queues.

marking a system as congested is done by setting the global to the
current value of ticks. as the system moves away from that value,
it moves away from being congested until the comparison fails.

written at s2k15
ok henning@@ beck@@ bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.130 2015/01/27 03:17:36 dlg Exp $	*/
d440 1
a440 1
	struct ifqueue *inq = 0;
a443 1
	int s;
d460 2
a463 1
		m_freem (m);
a540 1
				schednetisr (NETISR_IP);
a552 1
				schednetisr (NETISR_IPV6);
a580 1
			schednetisr (NETISR_IP);
a584 1
			schednetisr (NETISR_IPV6);
d604 1
a604 3
	/* Check queue. */
	s = splnet();
	if (IF_QFULL (inq)) {
a605 2
		IF_DROP(inq);
		splx(s);
d609 1
a609 2
		if_congestion();
		goto drop;
a610 2
	IF_ENQUEUE(inq, m);
	splx(s);
@


1.130
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.129 2014/12/19 17:14:39 tedu Exp $	*/
d617 1
a617 2
		if (!inq->ifq_congestion)
			if_congestion(inq);
@


1.129
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.128 2014/12/05 15:50:04 mpi Exp $	*/
d320 1
a320 1
void sppp_update_ip6_addr(void *arg1, void *arg2);
d361 2
a362 2
void sppp_set_ip_addrs(void *, void *);
void sppp_clear_ip_addrs(void *, void *);
d2612 2
a2613 2
	task_set(&sp->ipcp.set_addr_task, sppp_set_ip_addrs, sp, NULL);
	task_set(&sp->ipcp.clear_addr_task, sppp_clear_ip_addrs, sp, NULL);
d3061 1
a3061 2
	task_set(&sp->ipv6cp.set_addr_task, sppp_update_ip6_addr, sp,
	    &sp->ipv6cp.req_ifid);
d4560 1
a4560 1
sppp_set_ip_addrs(void *arg1, void *arg2)
d4633 1
a4633 1
sppp_clear_ip_addrs(void *arg1, void *arg2)
d4730 1
a4730 1
sppp_update_ip6_addr(void *arg1, void *arg2)
d4732 1
a4732 1
	struct sppp *sp = arg1;
d4734 1
a4734 1
	struct in6_aliasreq *ifra = arg2;
@


1.128
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.127 2014/11/18 02:37:31 tedu Exp $	*/
a58 1
#ifdef INET
a63 1
#endif
a375 1
#ifdef INET	/* don't run IPCP if there's no IPv4 support */
a376 3
#else
	0,
#endif
a533 1
#ifdef INET
a545 1
#endif
a581 1
#ifdef INET
a585 1
#endif
a669 1
#ifdef INET
a708 1
#endif
a738 1
#ifdef INET
a756 1
#endif
@


1.127
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.126 2014/10/08 20:28:27 sthen Exp $	*/
d52 1
@


1.126
log
@print ipv6cp by name rather than number in "0x8057 output <...>" debug lines,
as already done for lcp/ipcp/pap/chap
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.125 2014/07/22 11:06:09 mpi Exp $	*/
a54 3

/* for arc4random() */
#include <dev/rndvar.h>
@


1.125
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.124 2014/07/12 18:44:22 tedu Exp $	*/
d5190 1
@


1.124
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.123 2014/05/05 11:44:33 mpi Exp $	*/
a62 1
#include <netinet/in_systm.h>
@


1.123
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.122 2014/05/02 10:40:26 jca Exp $	*/
d909 1
a909 1
		free(sp->myauth.name, M_DEVBUF);
d911 1
a911 1
		free(sp->myauth.secret, M_DEVBUF);
d913 1
a913 1
		free(sp->hisauth.name, M_DEVBUF);
d915 1
a915 1
		free(sp->hisauth.secret, M_DEVBUF);
d2118 1
a2118 1
			free(buf, M_TEMP);
d2295 1
a2295 1
	free(buf, M_TEMP);
d2701 1
a2701 1
			free(buf, M_TEMP);
d2845 1
a2845 1
	free(buf, M_TEMP);
d3169 1
a3169 1
			free(buf, M_TEMP);
d3303 1
a3303 1
	free(buf, M_TEMP);
d4883 1
a4883 1
			free(spr, M_DEVBUF);
d4886 1
a4886 1
		free(spr, M_DEVBUF);
d4906 1
a4906 1
			free(spa, M_DEVBUF);
d4909 1
a4909 1
		free(spa, M_DEVBUF);
d4949 1
a4949 1
			free(spr, M_DEVBUF);
d4958 1
a4958 1
		free(spr, M_DEVBUF);
d4985 1
a4985 1
			free(spa, M_DEVBUF);
d4991 1
a4991 1
			free(spa, M_DEVBUF);
d4998 1
a4998 1
				free(auth->name, M_DEVBUF);
d5000 1
a5000 1
				free(auth->secret, M_DEVBUF);
d5013 1
a5013 1
				free(auth->name, M_DEVBUF);
d5022 1
a5022 1
					free(auth->secret, M_DEVBUF);
d5030 1
a5030 1
		free(spa, M_DEVBUF);
@


1.122
log
@Kill annoying and useless emacs local variable.  ok mikeb@@

The variable would have no effect unless you use hilit19.el from
emacs21, and even there the specified value has not been kept up to date
with the file growth.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.121 2014/04/19 12:12:02 henning Exp $	*/
d999 2
a1000 1
	struct ifreq *ifr = (struct ifreq*) data;
d1013 1
@


1.121
log
@all I wanted to do is removing the altq special casing, but then it turned
out the entire codepath is unreachable. glad I'm not our ppp maintainer, he
has work to do.
kill that unreachable code, with & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.119 2014/04/03 06:06:56 yasuoka Exp $	*/
a5238 7
/*
 * This file is large.  Tell emacs to highlight it nevertheless.
 *
 * Local Variables:
 * hilit-auto-highlight-maxout: 120000
 * End:
 */
@


1.120
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@a646 1
	struct ifqueue *ifq = NULL;
d821 1
a821 14
	if (ifq != NULL
#ifdef ALTQ
	    && ALTQ_IS_ENABLED(&ifp->if_snd) == 0
#endif
		) {
		if (IF_QFULL (ifq)) {
			IF_DROP (&ifp->if_snd);
			m_freem (m);
			if (rv == 0)
				rv = ENOBUFS;
		} else
			IF_ENQUEUE (ifq, m);
	} else
		IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);
@


1.119
log
@It cannot be assumed the top of the mbuf chain has required length here.
Actually, since packets from Octeon's cnmac(4) don't have enough size,
pppoe(4) is unable to connect.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.118 2014/03/18 10:47:34 mpi Exp $	*/
d477 1
a477 1
	m->m_pkthdr.rdomain = ifp->if_rdomain;
d653 1
a653 1
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
d656 1
a656 1
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain),
@


1.118
log
@Rename rt_gettable() into rtable_get(), swap its arguments to be
coherent with the existing rtable_* functions and document it.

While here fix some other manpage glitches pointed out by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.117 2014/01/13 23:03:52 bluhm Exp $	*/
d448 1
a448 1
	struct ppp_header *h, ht;
d480 1
a480 1
		memcpy(&ht.protocol, mtod(m, char *), sizeof(ht.protocol));
a483 1
		h = &ht;
d486 1
a486 1
		h = mtod (m, struct ppp_header*);
d503 1
a503 1
	switch (h->address) {
d505 1
a505 1
		if (h->control != PPP_UI)
d513 1
a513 1
				    h->address, h->control, ntohs(h->protocol));
d516 1
a516 1
		switch (ntohs (h->protocol)) {
d520 1
a520 1
				    ++sp->pp_seq, 2, &h->protocol);
d526 1
a526 1
				    h->address, h->control, ntohs(h->protocol));
d582 1
a582 1
				    h->address, h->control, ntohs(h->protocol));
d585 1
a585 1
		switch (ntohs (h->protocol)) {
d614 1
a614 1
			    h->address, h->control, ntohs(h->protocol));
@


1.117
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.116 2014/01/12 15:38:06 stsp Exp $	*/
d4578 1
a4578 1
		if ((rnh = rt_gettable(AF_INET, tid)) != NULL) {
@


1.116
log
@Remove no-op 'HIDE' macro from sppp code. This probably existed to allow
for easy switching to static functions. But we don't usually have static
functions in the kernel.
ok deraadt mpi mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.115 2014/01/07 16:34:05 stsp Exp $	*/
d4730 1
a4730 1
	struct in6_ifaddr *ia;
d4739 4
a4742 4
	ia = in6ifa_ifpforlinklocal(ifp, 0);
	if (ia) {
		if (!IN6_IS_ADDR_UNSPECIFIED(&ia->ia_addr.sin6_addr)) {
			bcopy(&ia->ia_addr.sin6_addr, &ssrc, sizeof(ssrc));
d4744 1
a4744 1
				bcopy(&ia->ia_prefixmask.sin6_addr, srcmask,
d4749 2
a4750 2
		if (!IN6_IS_ADDR_UNSPECIFIED(&ia->ia_dstaddr.sin6_addr))
			bcopy(&ia->ia_dstaddr.sin6_addr, &ddst, sizeof(ddst));
d4767 1
a4767 1
	struct in6_ifaddr *ia;
d4772 2
a4773 2
	ia = in6ifa_ifpforlinklocal(ifp, 0);
	if (ia == NULL) {
d4799 1
a4799 1
	if (!in6_are_prefix_equal(&ia->ia_prefixmask.sin6_addr, &mask, 128)) {
d4804 1
a4804 1
	ifra->ifra_lifetime = ia->ia6_lifetime;
d4806 1
a4806 1
	error = in6_update_ifa(ifp, ifra, ia);
@


1.115
log
@Some follow-up fixes for IFID collision handling in IPv6CP.

Really change the link-local address in the unlikely event of an IFID
collision, instead of going into an infinite conf-nak loop with the peer.

To make the netinet6 code use the IPv6CP IFID in a new link-local address,
in6_ifattach_linklocal() must accept a provided IFID.  Replace the unused
'altifp' parameter with a new 'ifid' parameter for this purpose.

Always use the latest suggested address in IPv6CP replies, even if
the task to update the interface's address hasn't run yet.
Also, clear the ifindex (KAME hack) in addresses sent during IPv6CP.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.114 2013/12/11 18:27:23 jca Exp $	*/
a39 2
#define HIDE

d245 1
a245 1
HIDE int sppp_output(struct ifnet *ifp, struct mbuf *m,
d248 2
a249 2
HIDE void sppp_cisco_send(struct sppp *sp, u_int32_t type, u_int32_t par1, u_int32_t par2);
HIDE void sppp_cisco_input(struct sppp *sp, struct mbuf *m);
d251 1
a251 1
HIDE void sppp_cp_input(const struct cp *cp, struct sppp *sp,
d253 1
a253 1
HIDE void sppp_cp_send(struct sppp *sp, u_short proto, u_char type,
d256 1
a256 1
HIDE void sppp_cp_timeout(void *arg);
d258 1
a258 1
HIDE void sppp_cp_change_state(const struct cp *cp, struct sppp *sp,
d260 1
a260 1
HIDE void sppp_auth_send(const struct cp *cp,
d264 59
a322 59
HIDE void sppp_up_event(const struct cp *cp, struct sppp *sp);
HIDE void sppp_down_event(const struct cp *cp, struct sppp *sp);
HIDE void sppp_open_event(const struct cp *cp, struct sppp *sp);
HIDE void sppp_close_event(const struct cp *cp, struct sppp *sp);
HIDE void sppp_increasing_timeout(const struct cp *cp, struct sppp *sp);
HIDE void sppp_to_event(const struct cp *cp, struct sppp *sp);

HIDE void sppp_null(struct sppp *sp);

HIDE void sppp_lcp_init(struct sppp *sp);
HIDE void sppp_lcp_up(struct sppp *sp);
HIDE void sppp_lcp_down(struct sppp *sp);
HIDE void sppp_lcp_open(struct sppp *sp);
HIDE void sppp_lcp_close(struct sppp *sp);
HIDE void sppp_lcp_TO(void *sp);
HIDE int sppp_lcp_RCR(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_lcp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_lcp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_lcp_tlu(struct sppp *sp);
HIDE void sppp_lcp_tld(struct sppp *sp);
HIDE void sppp_lcp_tls(struct sppp *sp);
HIDE void sppp_lcp_tlf(struct sppp *sp);
HIDE void sppp_lcp_scr(struct sppp *sp);
HIDE void sppp_lcp_check_and_close(struct sppp *sp);
HIDE int sppp_ncp_check(struct sppp *sp);

HIDE void sppp_ipcp_init(struct sppp *sp);
HIDE void sppp_ipcp_destroy(struct sppp *sp);
HIDE void sppp_ipcp_up(struct sppp *sp);
HIDE void sppp_ipcp_down(struct sppp *sp);
HIDE void sppp_ipcp_open(struct sppp *sp);
HIDE void sppp_ipcp_close(struct sppp *sp);
HIDE void sppp_ipcp_TO(void *sp);
HIDE int sppp_ipcp_RCR(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_ipcp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_ipcp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_ipcp_tlu(struct sppp *sp);
HIDE void sppp_ipcp_tld(struct sppp *sp);
HIDE void sppp_ipcp_tls(struct sppp *sp);
HIDE void sppp_ipcp_tlf(struct sppp *sp);
HIDE void sppp_ipcp_scr(struct sppp *sp);

HIDE void sppp_ipv6cp_init(struct sppp *sp);
HIDE void sppp_ipv6cp_destroy(struct sppp *sp);
HIDE void sppp_ipv6cp_up(struct sppp *sp);
HIDE void sppp_ipv6cp_down(struct sppp *sp);
HIDE void sppp_ipv6cp_open(struct sppp *sp);
HIDE void sppp_ipv6cp_close(struct sppp *sp);
HIDE void sppp_ipv6cp_TO(void *sp);
HIDE int sppp_ipv6cp_RCR(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_ipv6cp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_ipv6cp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len);
HIDE void sppp_ipv6cp_tlu(struct sppp *sp);
HIDE void sppp_ipv6cp_tld(struct sppp *sp);
HIDE void sppp_ipv6cp_tls(struct sppp *sp);
HIDE void sppp_ipv6cp_tlf(struct sppp *sp);
HIDE void sppp_ipv6cp_scr(struct sppp *sp);
HIDE const char *sppp_ipv6cp_opt_name(u_char opt);
HIDE void sppp_get_ip6_addrs(struct sppp *sp, struct in6_addr *src,
d324 34
a357 34
HIDE void sppp_set_ip6_addr(struct sppp *sp, const struct in6_addr *src, const struct in6_addr *dst);
HIDE void sppp_update_ip6_addr(void *arg1, void *arg2);
HIDE void sppp_suggest_ip6_addr(struct sppp *sp, struct in6_addr *suggest);

HIDE void sppp_pap_input(struct sppp *sp, struct mbuf *m);
HIDE void sppp_pap_init(struct sppp *sp);
HIDE void sppp_pap_open(struct sppp *sp);
HIDE void sppp_pap_close(struct sppp *sp);
HIDE void sppp_pap_TO(void *sp);
HIDE void sppp_pap_my_TO(void *sp);
HIDE void sppp_pap_tlu(struct sppp *sp);
HIDE void sppp_pap_tld(struct sppp *sp);
HIDE void sppp_pap_scr(struct sppp *sp);

HIDE void sppp_chap_input(struct sppp *sp, struct mbuf *m);
HIDE void sppp_chap_init(struct sppp *sp);
HIDE void sppp_chap_open(struct sppp *sp);
HIDE void sppp_chap_close(struct sppp *sp);
HIDE void sppp_chap_TO(void *sp);
HIDE void sppp_chap_tlu(struct sppp *sp);
HIDE void sppp_chap_tld(struct sppp *sp);
HIDE void sppp_chap_scr(struct sppp *sp);

HIDE const char *sppp_auth_type_name(u_short proto, u_char type);
HIDE const char *sppp_cp_type_name(u_char type);
HIDE const char *sppp_dotted_quad(u_int32_t addr);
HIDE const char *sppp_ipcp_opt_name(u_char opt);
HIDE const char *sppp_lcp_opt_name(u_char opt);
HIDE const char *sppp_phase_name(enum ppp_phase phase);
HIDE const char *sppp_proto_name(u_short proto);
HIDE const char *sppp_state_name(int state);
HIDE int sppp_get_params(struct sppp *sp, struct ifreq *data);
HIDE int sppp_set_params(struct sppp *sp, struct ifreq *data);
HIDE void sppp_get_ip_addrs(struct sppp *sp, u_int32_t *src, u_int32_t *dst,
d359 5
a363 5
HIDE void sppp_keepalive(void *dummy);
HIDE void sppp_phase_network(struct sppp *sp);
HIDE void sppp_print_bytes(const u_char *p, u_short len);
HIDE void sppp_print_string(const char *p, u_short len);
HIDE void sppp_qflush(struct ifqueue *ifq);
d366 3
a368 3
HIDE void sppp_set_ip_addrs(void *, void *);
HIDE void sppp_clear_ip_addrs(void *, void *);
HIDE void sppp_set_phase(struct sppp *sp);
d642 1
a642 1
HIDE int
d1120 1
a1120 1
HIDE void
d1191 1
a1191 1
HIDE void
d1247 1
a1247 1
HIDE void
d1309 1
a1309 1
HIDE void
d1708 1
a1708 1
HIDE void
d1735 1
a1735 1
HIDE void
d1773 1
a1773 1
HIDE void
d1809 1
a1809 1
HIDE void
d1850 1
a1850 1
HIDE void
d1861 1
a1861 1
HIDE void
d1957 1
a1957 1
HIDE void
d1981 1
a1981 1
HIDE void
d2035 1
a2035 1
HIDE void
d2076 1
a2076 1
HIDE void
d2090 1
a2090 1
HIDE void
d2096 1
a2096 1
HIDE void
d2108 1
a2108 1
HIDE int
d2316 1
a2316 1
HIDE void
d2376 1
a2376 1
HIDE void
d2451 1
a2451 1
HIDE void
d2511 1
a2511 1
HIDE void
d2534 1
a2534 1
HIDE void
d2546 1
a2546 1
HIDE void
d2557 1
a2557 1
HIDE void
d2599 1
a2599 1
HIDE int
d2614 1
a2614 1
HIDE void
d2635 1
a2635 1
HIDE void
d2646 1
a2646 1
HIDE void
d2653 1
a2653 1
HIDE void
d2659 1
a2659 1
HIDE void
d2665 1
a2665 1
HIDE void
d2671 1
a2671 1
HIDE void
d2677 1
a2677 1
HIDE void
d2689 1
a2689 1
HIDE int
d2866 1
a2866 1
HIDE void
d2908 1
a2908 1
HIDE void
d2969 1
a2969 1
HIDE void
d2976 1
a2976 1
HIDE void
d2981 1
a2981 1
HIDE void
d3027 1
a3027 1
HIDE void
d3039 1
a3039 1
HIDE void
d3084 1
a3084 1
HIDE void
d3095 1
a3095 1
HIDE void
d3101 1
a3101 1
HIDE void
d3107 1
a3107 1
HIDE void
d3113 1
a3113 1
HIDE void
d3139 1
a3139 1
HIDE void
d3145 1
a3145 1
HIDE void
d3151 1
a3151 1
HIDE int
d3320 1
a3320 1
HIDE void
d3359 1
a3359 1
HIDE void
d3430 1
a3430 1
HIDE void
d3435 1
a3435 1
HIDE void
d3440 1
a3440 1
HIDE void
d3447 1
a3447 1
HIDE void
d3455 1
a3455 1
HIDE void
d3487 1
a3487 1
HIDE void
d3492 1
a3492 1
HIDE void
d3497 1
a3497 1
HIDE void
d3502 1
a3502 1
HIDE void
d3507 1
a3507 1
HIDE void
d3512 1
a3512 1
HIDE void
d3517 1
a3517 1
HIDE void
d3522 1
a3522 1
HIDE int
d3529 1
a3529 1
HIDE void
d3535 1
a3535 1
HIDE void
d3541 1
a3541 1
HIDE void
d3546 1
a3546 1
HIDE void
d3551 1
a3551 1
HIDE void
d3556 1
a3556 1
HIDE void
d3561 1
a3561 1
HIDE void
d3877 1
a3877 1
HIDE void
d3885 1
a3885 1
HIDE void
d3898 1
a3898 1
HIDE void
d3905 1
a3905 1
HIDE void
d3944 1
a3944 1
HIDE void
d4003 1
a4003 1
HIDE void
d4016 1
a4016 1
HIDE void
d4050 1
a4050 1
HIDE void
d4193 1
a4193 1
HIDE void
d4201 1
a4201 1
HIDE void
d4217 1
a4217 1
HIDE void
d4228 1
a4228 1
HIDE void
d4267 1
a4267 1
HIDE void
d4280 1
a4280 1
HIDE void
d4309 1
a4309 1
HIDE void
d4323 1
a4323 1
HIDE void
d4351 1
a4351 1
HIDE void
d4433 1
a4433 1
HIDE void
d4442 1
a4442 1
HIDE void
d4512 1
a4512 1
HIDE void
d4590 1
a4590 1
HIDE void
d4663 1
a4663 1
HIDE void
d4725 1
a4725 1
HIDE void
d4760 1
a4760 1
HIDE void
d4818 1
a4818 1
HIDE void
d4855 1
a4855 1
HIDE void
d4878 1
a4878 1
HIDE int
d4933 1
a4933 1
HIDE int
d5053 1
a5053 1
HIDE void
d5078 1
a5078 1
HIDE const char *
d5099 1
a5099 1
HIDE const char *
d5122 1
a5122 1
HIDE const char *
d5139 1
a5139 1
HIDE const char *
d5153 1
a5153 1
HIDE const char *
d5166 1
a5166 1
HIDE const char *
d5184 1
a5184 1
HIDE const char *
d5197 1
a5197 1
HIDE const char *
d5211 1
a5211 1
HIDE void
d5219 1
a5219 1
HIDE void
d5236 1
a5236 1
HIDE const char *
d5249 1
a5249 1
HIDE void
d5262 1
a5262 1
HIDE void
@


1.114
log
@Use an u_int32_t instead of an unsigned long to store the magic number
we're about to send.  Should a bug on big-endian LP64 archs reported by
James MacMahon (jwm at operand dot ca).  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.113 2013/11/20 08:21:33 stsp Exp $	*/
d72 4
d3229 4
a3232 1
	sppp_get_ip6_addrs(sp, &myaddr, NULL, NULL);
d3465 4
a3468 1
		sppp_get_ip6_addrs(sp, &ouraddr, NULL, NULL);
d4781 19
d4875 1
@


1.113
log
@Convert sppp(4) to taskq; ok mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.112 2013/11/14 16:52:33 stsp Exp $	*/
d4491 1
a4491 1
			unsigned long nmagic = htonl (sp->lcp.magic);
@


1.112
log
@Improvements for address assignment and related issues in IPv6CP.

Move address assignment to process context. This uses a workq at
present, conversion to taskq is on my todo list (discussed with dlg).
Instead of rummaging around in sockaddr_in6 structs, use the proper
netinet6 APIs to configure addresses.
Deal with IFID collisions instead of ignoring them. The whole point of
IPv6CP is to avoid IFID collisions. Use arc4random() during IFID generation.
Assign destination address to /128 point-to-point links.

tested by me and sthen with pppoe(4)
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.111 2013/11/11 09:15:34 mpi Exp $	*/
a48 1
#include <sys/workq.h>
a73 4
#ifdef INET6
#include <netinet6/in6_var.h>
#endif

d289 1
d305 1
d902 3
d2640 9
a2966 6
struct sppp_set_ip_addrs_args {
	struct sppp *sp;
	u_int32_t myaddr;
	u_int32_t hisaddr;
};

d2970 2
a2971 23
	struct ifnet *ifp = &sp->pp_if;
	struct sppp_set_ip_addrs_args *args;

	args = malloc(sizeof(*args), M_TEMP, M_NOWAIT);
	if (args == NULL)
		return;

	args->sp = sp;

	/* we are up. Set addresses and notify anyone interested */
	sppp_get_ip_addrs(sp, &args->myaddr, &args->hisaddr, 0);
	if ((sp->ipcp.flags & IPCP_MYADDR_DYN) &&
	    (sp->ipcp.flags & IPCP_MYADDR_SEEN))
		args->myaddr = sp->ipcp.req_myaddr;
	if ((sp->ipcp.flags & IPCP_HISADDR_DYN) &&
	    (sp->ipcp.flags & IPCP_HISADDR_SEEN))
		args->hisaddr = sp->ipcp.req_hisaddr;

	if (workq_add_task(NULL, 0, sppp_set_ip_addrs, args, NULL)) {
		free(args, M_TEMP);
		printf("%s: workq_add_task failed, cannot set "
		    "addresses\n", ifp->if_xname);
	}
a3027 2
	struct ifnet *ifp = &sp->pp_if;

d3030 1
a3030 5
		if (workq_add_task(NULL, 0,
		    sppp_clear_ip_addrs, (void *)sp, NULL)) {
			printf("%s: workq_add_task failed, cannot clear "
			    "addresses\n", ifp->if_xname);
		}
d3089 8
d3485 5
d4579 1
a4579 1
 * Work queue task adding addresses from process context.
d4585 3
a4587 4
	struct sppp_set_ip_addrs_args *args = arg1;
	struct sppp *sp = args->sp;
	u_int32_t myaddr = args->myaddr;
	u_int32_t hisaddr = args->hisaddr;
d4595 7
a4601 2
	/* Arguments are now on local stack so free temporary storage. */
	free(args, M_TEMP);
d4652 1
a4652 1
 * Work queue task clearing addresses from process context.
a4767 1
		free(ifra, M_TEMP);
a4785 1
	free(ifra, M_TEMP);
d4796 1
a4796 5
	struct in6_aliasreq *ifra;

	ifra = malloc(sizeof(*ifra), M_TEMP, M_NOWAIT|M_ZERO);
	if (ifra == NULL)
		return;
d4798 1
d4822 1
a4822 5
	if (workq_add_task(NULL, 0, sppp_update_ip6_addr, sp, ifra)) {
		free(ifra, M_TEMP);
		printf("%s: workq_add_task failed, cannot set IPv6 "
		    "addresses\n", ifp->if_xname);
	}
@


1.111
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.110 2013/11/05 15:32:48 stsp Exp $	*/
d75 4
d325 2
a326 2
HIDE void sppp_set_ip6_addr(struct sppp *sp, const struct in6_addr *src);
HIDE void sppp_gen_ip6_addr(struct sppp *sp, struct in6_addr *addr);
a3132 1
#ifdef IPV6CP_MYIFID_DYN
a3133 3
#else
	sp->ipv6cp.flags &= ~IPV6CP_MYIFID_SEEN;
#endif
d3135 1
a3135 1
	sppp_get_ip6_addrs(sp, &myaddr, &hisaddr, 0);
d3139 1
a3139 1
	 * be the case if somebody wants to speak only IPX, for
a3148 1
	sp->ipv6cp.flags |= IPV6CP_MYIFID_SEEN;
d3241 1
a3241 1
	sppp_get_ip6_addrs(sp, &myaddr, 0, 0);
d3275 1
d3400 1
a3401 1
			suggestaddr.s6_addr16[0] = htons(0xfe80);
d3403 2
a3404 13

			sp->ipv6cp.opts |= (1 << IPV6CP_OPT_IFID);
			if (debug)
				addlog(" [suggestaddr %s]",
				    inet_ntop(AF_INET6, &suggestaddr, addr,
					sizeof(addr)));
#ifdef IPV6CP_MYIFID_DYN
			/*
			 * When doing dynamic address assignment,
			 * we accept his offer.
			 */
			if (sp->ipv6cp.flags & IPV6CP_MYIFID_DYN) {
				struct in6_addr lastsuggest;
d3406 4
a3409 4
				 * If <suggested myaddr from peer> equals to
				 * <hisaddr we have suggested last time>,
				 * we have a collision.  generate new random
				 * ifid.
d3411 12
a3422 8
				sppp_suggest_ip6_addr(sp,&lastsuggest);
				if (IN6_ARE_ADDR_EQUAL(&suggestaddr,
						 &lastsuggest)) {
					if (debug)
						addlog(" [random]");
					sppp_gen_ip6_addr(sp, &suggestaddr);
				}
				sppp_set_ip6_addr(sp, &suggestaddr);
a3426 13
#else
			/*
			 * Since we do not do dynamic address assignment,
			 * we ignore it and thus continue to negotiate
			 * our already existing value.  This can possibly
			 * go into infinite request-reject loop.
			 *
			 * This is not likely because we normally use
			 * ifid based on MAC-address.
			 * If you have no ethernet card on the node, too bad.
			 * XXX should we use fail_counter?
			 */
#endif
d3474 1
a3474 1
		sppp_get_ip6_addrs(sp, &ouraddr, 0, 0);
d4729 1
a4729 2
	struct ifaddr *ifa;
	struct sockaddr_in6 *si, *sm;
a4731 1
	sm = NULL;
d4738 4
a4741 13
	si = 0;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			si = (struct sockaddr_in6 *)ifa->ifa_addr;
			sm = (struct sockaddr_in6 *)ifa->ifa_netmask;
			if (si && IN6_IS_ADDR_LINKLOCAL(&si->sin6_addr))
				break;
		}
	}

	if (ifa) {
		if (si && !IN6_IS_ADDR_UNSPECIFIED(&si->sin6_addr)) {
			bcopy(&si->sin6_addr, &ssrc, sizeof(ssrc));
d4743 1
a4743 1
				bcopy(&sm->sin6_addr, srcmask,
d4748 2
a4749 3
		si = (struct sockaddr_in6 *)ifa->ifa_dstaddr;
		if (si && !IN6_IS_ADDR_UNSPECIFIED(&si->sin6_addr))
			bcopy(&si->sin6_addr, &ddst, sizeof(ddst));
d4758 1
a4758 4
#ifdef IPV6CP_MYIFID_DYN
/*
 * Generate random ifid.
 */
d4760 1
a4760 1
sppp_gen_ip6_addr(struct sppp *sp, struct in6_addr *addr)
d4762 33
a4794 1
	/* TBD */
d4798 1
a4798 1
 * Set my IPv6 address.  Must be called at splnet.
d4801 2
a4802 1
sppp_set_ip6_addr(struct sppp *sp, const struct in6_addr *src)
d4805 17
a4821 2
	struct ifaddr *ifa;
	struct sockaddr_in6 *sin6;
d4823 5
a4827 3
	/*
	 * Pick the first link-local AF_INET6 address from the list,
	 * aliases don't make any sense on a p2p link anyway.
d4829 1
d4831 2
a4832 8
	sin6 = NULL;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
			if (sin6 && IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
				break;
		}
	}
d4834 4
a4837 4
	if (ifa && sin6) {
		struct sockaddr_in6 new_sin6 = *sin6;
		bcopy(src, &new_sin6.sin6_addr, sizeof(new_sin6.sin6_addr));
		dohooks(ifp->if_addrhooks, 0);
a4839 1
#endif
d4842 1
a4842 1
 * Suggest a candidate address to be used by peer.
d4848 1
a4848 1
	struct timeval tv;
d4850 1
a4850 1
	sppp_get_ip6_addrs(sp, &myaddr, 0, 0);
d4853 3
a4855 2
	getmicrouptime(&tv);
	if ((tv.tv_usec & 0xff) == 0 && (tv.tv_sec & 0xff) == 0) {
d4859 2
a4860 2
		myaddr.s6_addr[14] ^= (tv.tv_usec & 0xff);
		myaddr.s6_addr[15] ^= (tv.tv_sec & 0xff);
d4862 1
a4862 2
	if (suggest)
		bcopy(&myaddr, suggest, sizeof(myaddr));
@


1.110
log
@Remove useless #ifdef *BSD cruft from sppp(4). No binary change.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.109 2013/10/24 11:31:43 mpi Exp $	*/
d3176 1
d3272 2
a3273 1
					    ip6_sprintf(&desiredaddr),
d3295 3
a3297 1
				addlog(" %s [%s]", ip6_sprintf(&desiredaddr),
d3319 3
a3321 1
			    sppp_cp_type_name(type), ip6_sprintf(&suggestaddr));
d3377 1
d3407 2
a3408 1
				       ip6_sprintf(&suggestaddr));
@


1.109
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.108 2013/10/01 20:22:13 sf Exp $	*/
a50 1
#if defined (__OpenBSD__)
a52 3
#else
#include <sys/md5.h>
#endif
a61 5
#if defined (__FreeBSD__) || defined(__OpenBSD_) || defined(__NetBSD__)
#include <machine/random.h>
#endif
#if defined (__NetBSD__) || defined (__OpenBSD__)
#endif
d70 1
a70 5
# if defined (__FreeBSD__) || defined (__OpenBSD__)
#  include <netinet/if_ether.h>
# else
#  include <net/ethertypes.h>
# endif
a74 4
#if defined (__FreeBSD__)
# define UNTIMEOUT(fun, arg, handle)	\
	untimeout(fun, arg, handle)
#elif defined(__OpenBSD__)
a76 4
#else
# define UNTIMEOUT(fun, arg, handle)	\
	untimeout(fun, arg)
#endif
a233 1
#if defined (__OpenBSD__)
a234 4
#endif
#if defined (__FreeBSD__)
static struct callout_handle keepalive_ch;
#endif
a235 4
#if defined (__FreeBSD__)
#define	SPP_FMT		"%s%d: "
#define	SPP_ARGS(ifp)	(ifp)->if_name, (ifp)->if_unit
#else
a237 1
#endif
a432 1
#if defined(__OpenBSD__)
a437 1
#endif
a861 3
#if defined (__FreeBSD__)
		keepalive_ch = timeout(sppp_keepalive, 0, hz * 10);
#elif defined(__OpenBSD__)
a863 1
#endif
a1162 1
#if defined (__FreeBSD__) || defined (__NetBSD__) || defined(__OpenBSD__)
a1163 3
#else
			sp->pp_seq ^= time.tv_sec ^ time.tv_usec;
#endif
a1851 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	sp->ch[cp->protoidx] = 
	    timeout(cp->TO, (void *)sp, timo * sp->lcp.timeout);
#elif defined(__OpenBSD__)
a1852 1
#endif
a1972 3
#if defined (__FreeBSD__)
	callout_handle_init(&sp->ch[IDX_LCP]);
#endif
a2559 1
#if defined (__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
a2560 3
#else
			sp->lcp.magic = time.tv_sec + time.tv_usec;
#endif
a2635 3
#if defined (__FreeBSD__)
	callout_handle_init(&sp->ch[IDX_IPCP]);
#endif
a3108 3
#if defined (__FreeBSD__)
	callout_handle_init(&sp->ch[IDX_IPV6CP]);
#endif
a3897 3
#if defined (__FreeBSD__)
	callout_handle_init(&sp->ch[IDX_CHAP]);
#endif
a3980 3
#if defined (__FreeBSD__)
		sp->ch[IDX_CHAP] = timeout(chap.TO, (void *)sp, i * hz);
#elif defined(__OpenBSD__)
a3981 1
#endif
a4213 4
#if defined (__FreeBSD__)
	callout_handle_init(&sp->ch[IDX_PAP]);
	callout_handle_init(&sp->pap_my_to_ch);
#endif
a4227 4
#if defined (__FreeBSD__)
		sp->pap_my_to_ch =
		    timeout(sppp_pap_my_TO, (void *)sp, sp->lcp.timeout);
#elif defined (__OpenBSD__)
a4228 1
#endif
a4520 4
#if defined (__FreeBSD__)
	keepalive_ch = timeout(sppp_keepalive, 0, hz * 10);
#endif
#if defined (__OpenBSD__)
a4521 1
#endif
a4541 5
#if defined (__FreeBSD__)
	for (ifa = ifp->if_addrhead.tqh_first, si = 0;
	     ifa;
	     ifa = ifa->ifa_link.tqe_next)
#else
a4543 1
#endif
a4628 5
#if defined (__FreeBSD__)
	for (ifa = ifp->if_addrhead.tqh_first, si = 0;
	     ifa;
	     ifa = ifa->ifa_link.tqe_next)
#else
a4630 1
#endif
@


1.108
log
@Format string fixes: %hu/%hd for uint16_t, %u/%d/%x for uint32_t

- despite the name, ntohl returns uint32_t, not long
- also fix some %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.107 2013/08/16 12:29:18 mpi Exp $	*/
a83 4
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
@


1.107
log
@Replace the misleading SIOC{G,S}IFGENERIC ioctls by SIOCG{G,S}PPPPARAMS.

This is another ABI break but no port rely on them as verified by naddy@@.

ok claudio@@, mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.106 2013/07/15 13:30:37 mpi Exp $	*/
d1263 1
a1263 1
		    "cisco output: <0x%lx 0x%lx 0x%lx 0x%x 0x%x-0x%x>\n",
@


1.106
log
@Remove a comment which is no longer true.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.105 2013/07/10 07:46:10 mpi Exp $	*/
d1132 1
a1132 1
	case SIOCGIFGENERIC:
d1136 1
a1136 1
	case SIOCSIFGENERIC:
@


1.105
log
@Change the structure used in the SPPPIOSDEFS and SPPPIOGDEFS ioctls
to only include what is really needed.  In particular stop including
a "struct ifnet" and move kernel-only definition into the proper #if
dance.

While here remove the unused spppinfo() from ifconfig.

ok guenther@@, sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.104 2013/06/20 12:03:40 mpi Exp $	*/
a4958 9

		/*
		 * We copy over the entire current state, but clean
		 * out some of the stuff we don't wanna pass up.
		 * Remember, SIOCGIFGENERIC is unprotected, and can be
		 * called by any user.  No need to ever get PAP or
		 * CHAP secrets back to userland anyway.
		 */

@


1.104
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.103 2013/06/20 09:38:24 mpi Exp $	*/
d4969 1
a4969 6
		bcopy(sp, &spr->defs, sizeof(struct sppp));
		
		explicit_bzero(&spr->defs.myauth, sizeof(spr->defs.myauth));
		explicit_bzero(&spr->defs.hisauth, sizeof(spr->defs.hisauth));
		explicit_bzero(&spr->defs.chap_challenge,
		    sizeof(spr->defs.chap_challenge));
@


1.103
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.102 2013/05/31 19:16:52 mpi Exp $	*/
d4754 1
a4754 1
			dohooks(&ifp->if_addrhooks, 0);
d4815 1
a4815 1
			dohooks(&ifp->if_addrhooks, 0);
d4915 1
a4915 1
		dohooks(&ifp->if_addrhooks, 0);
@


1.102
log
@Remove the scrub argument from in_ifinit() and simply call in_ifscrub()
unconditionally for SIOCSIFADDR.

ok bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.101 2013/03/28 16:55:27 deraadt Exp $	*/
d4754 1
a4754 1
			dohooks(ifp->if_addrhooks, 0);
d4815 1
a4815 1
			dohooks(ifp->if_addrhooks, 0);
d4915 1
a4915 1
		dohooks(ifp->if_addrhooks, 0);
@


1.101
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.100 2013/03/28 16:45:16 tedu Exp $	*/
a4741 5
		/*
		 * Scrub old routes now instead of calling in_ifinit with
		 * scrub=1, because we may change the dstaddr
		 * before the call to in_ifinit.
		 */
d4753 1
a4753 1
		if (!(error = in_ifinit(ifp, ifatoia(ifa), &new_sin, 0, 0)))
d4814 1
a4814 1
		if (!(error = in_ifinit(ifp, ifatoia(ifa), &new_sin, 0, 0)))
@


1.100
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.99 2012/11/23 20:12:03 sthen Exp $	*/
a69 1
#include <machine/cpu.h> /* XXX for softnet */
@


1.99
log
@Add SIOCGIFHARDMTU to allow retrieving the driver's maximum supported MTU
looks fine reyk@@ ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.98 2012/07/24 15:16:20 deraadt Exp $	*/
a45 1
#include <sys/proc.h>
@


1.98
log
@decls before code
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.97 2012/07/23 10:54:54 sthen Exp $	*/
d1118 5
@


1.97
log
@Call sppp_clear_ip_addrs from a workq. Problem reported by RD Thrush and
LEVAI Daniel, diagnosed by matthew@@, original diff from RD Thrush, cleaned
up by me with feedback from mikeb@@. OK mikeb dcoppa deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.96 2012/01/28 12:14:45 sthen Exp $	*/
d4781 1
a4785 1
	u_int32_t remote;
@


1.96
log
@Remove a horrible sppp(4)-specific "fast queue" used for tcp ports 21 23 513.
You should use the proper queues via pf instead.  ok phessler@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.95 2012/01/19 01:13:20 sthen Exp $	*/
d401 1
a401 1
HIDE void sppp_clear_ip_addrs(struct sppp *sp);
d3099 2
d3103 5
a3107 1
		sppp_clear_ip_addrs(sp);
d4769 2
a4770 1
 * Clear IP addresses.  Must be called at splnet.
d4773 1
a4773 1
sppp_clear_ip_addrs(struct sppp *sp)
d4775 1
d4777 1
d4781 3
d4807 1
d4816 1
a4816 1
		if (!in_ifinit(ifp, ifatoia(ifa), &new_sin, 0, 0))
d4818 6
d4826 1
@


1.95
log
@Teach pppoe(4) about RFC 4638. This allows negotiating increased MTU with
compatible equipment provided that the physical interface and other layer 2
devices involved support and are configured to use jumbo frames.

Manpage to follow; typical use is to request 1500 MTU for pppoe, this
requires 1508+ MTU on the physical interface, e.g. "ifconfig em0 mtu 1508;
ifconfig pppoe0 mtu 1500". Known to be usable in the UK with some ISPs
(e.g. aaisp) using BT FTTC backhaul.

From Matt Dainty, originally based on support in NetBSD, changed to
decouple pppoe from physical interface MTU. Tested with UK FTTC by Matt,
no regressions on my standard UK ADSL setup or yasuoka@@'s setup (in Japan,
NTT uses 1452 byte MTU for PPPoE and 1500 byte MTU for IPv6 on the same
network).

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.94 2011/07/07 00:08:04 henning Exp $	*/
a275 14
/*
 * The following disgusting hack gets around the problem that IP TOS
 * can't be set yet.  We want to put "interactive" traffic on a high
 * priority queue.  To decide if traffic is interactive, we check that
 * a) it is TCP and b) one of its ports is telnet, rlogin or ftp control.
 *
 * XXX is this really still necessary?  - joerg -
 */
static u_short interactive_ports[8] = {
	0,	513,	0,	0,
	0,	21,	0,	23,
};
#define INTERACTIVE(p) (interactive_ports[(p) & 7] == (p))

a759 6

		if (!IF_QFULL(&sp->pp_fastq) &&
		    ((ip && (ip->ip_tos & IPTOS_LOWDELAY)) ||
	    	      (th && (INTERACTIVE(ntohs(th->th_sport)) ||
	    	       INTERACTIVE(ntohs(th->th_dport))))))
			ifq = &sp->pp_fastq;
a915 1
	IFQ_SET_MAXLEN(&sp->pp_fastq, 50);
a978 1
	sppp_qflush (&sp->pp_fastq);
d992 1
a992 1
	empty = IF_IS_EMPTY(&sp->pp_fastq) && IF_IS_EMPTY(&sp->pp_cpq) &&
d1013 1
a1013 1
	 * Do always serve all three queues in Cisco mode.
d1018 1
a1018 3
		IF_DEQUEUE(&sp->pp_fastq, m);
		if (m == NULL)
			IFQ_DEQUEUE (&sp->pp_if.if_snd, m);
d1039 1
a1039 3
		IF_POLL(&sp->pp_fastq, m);
		if ((m) == NULL)
			IFQ_POLL(&sp->pp_if.if_snd, m);
a1264 1
		IF_DROP (&sp->pp_fastq);
a1329 1
		IF_DROP (&sp->pp_fastq);
a4502 1
		IF_DROP (&sp->pp_fastq);
@


1.94
log
@another case of "clever" fiddling with ifq internals, just stumbled over
this in my monster diff and wondered that i hadn't put that in already...
claudio ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.93 2011/07/06 02:54:31 henning Exp $	*/
d1121 3
a1123 1
		if (ifr->ifr_mtu < 128 || ifr->ifr_mtu > sp->lcp.their_mru) {
d1132 3
a1134 1
		if (*(short*)data < 128 || *(short*)data > sp->lcp.their_mru) {
d1717 1
a1717 1
 			lcp.Close(sp);
d2034 2
a2035 1
	sp->lcp.mru = sp->lcp.their_mru = sp->pp_if.if_mtu;
d2067 10
a2076 5
 	sp->pp_alivecnt = 0;
 	sp->lcp.opts = (1 << LCP_OPT_MAGIC);
 	sp->lcp.magic = 0;
 	sp->lcp.protos = 0;
 	sp->lcp.mru = sp->lcp.their_mru = sp->pp_if.if_mtu;
d2142 2
a2143 1
 	sp->pp_flags &= ~PP_CALLIN;
d2145 1
a2145 1
 	sppp_flush(ifp);
d4724 2
a4725 2
 	struct ifaddr *ifa;
 	struct sockaddr_in *si;
@


1.93
log
@and make sppp_qflush a wrapper around IF_PURGE instead of handrolling
the same, ok'd with IFQ_PURGE with happens to break on altq kernels by
claudio, ryan and bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.92 2011/07/06 02:49:36 henning Exp $	*/
d1059 1
a1059 1
	m = sp->pp_cpq.ifq_head;
d1062 3
a1064 2
	     (sp->pp_flags & PP_CISCO) != 0))
		if ((m = sp->pp_fastq.ifq_head) == NULL)
d1066 1
@


1.92
log
@second trial: stop messing with ifq internals, this time use IF_IS_EMPTY
and not IFQ_IS_EMPTY, the former doesn't get overloaded with altq-specific
stuffz. original oks from claudio and ryan and bluhm, i take the liberty
to assume the oks for this fixed version
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.91 2011/07/06 02:42:28 henning Exp $	*/
d4537 1
a4537 10
	struct mbuf *m, *n;

	n = ifq->ifq_head;
	while ((m = n)) {
		n = m->m_act;
		m_freem (m);
	}
	ifq->ifq_head = 0;
	ifq->ifq_tail = 0;
	ifq->ifq_len = 0;
@


1.91
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.90 2011/07/05 21:11:36 guenther Exp $	*/
d1014 1
a1014 1
	empty = !sp->pp_fastq.ifq_head && !sp->pp_cpq.ifq_head &&
@


1.90
log
@Revert henning's commit-n-run that broke the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.88 2011/06/29 12:14:46 tedu Exp $	*/
d936 2
a937 2
	sp->pp_fastq.ifq_maxlen = 50;
	sp->pp_cpq.ifq_maxlen = 50;
a946 1

@


1.89
log
@2 cases of IFQ_IS_EMPTY instead of mucking with ifqueue internals
make sppp_flush use IFQ_PURGE instead of handrolling the same making
assumptions about ifqueue internals. ok ryan claudio
@
text
@d1015 1
a1015 1
	empty = IFQ_IS_EMPTY(&sp->pp_fastq) && IFQ_IS_EMPTY(&sp->pp_cpq) &&
d4538 10
a4547 1
	IFQ_PURGE(ifq);
@


1.88
log
@always set sppp auth secret, as other code assumes it.
confirmed to fix paul stoeber's crash.  ok deraadt sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.87 2011/06/18 23:52:49 jsg Exp $	*/
d1015 1
a1015 1
	empty = !sp->pp_fastq.ifq_head && !sp->pp_cpq.ifq_head &&
d4538 1
a4538 10
	struct mbuf *m, *n;

	n = ifq->ifq_head;
	while ((m = n)) {
		n = m->m_act;
		m_freem (m);
	}
	ifq->ifq_head = 0;
	ifq->ifq_tail = 0;
	ifq->ifq_len = 0;
@


1.87
log
@pass the correct size to memset
spotted by clang, ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.86 2011/05/04 16:05:49 blambert Exp $	*/
d3799 1
a3799 2
		MD5Update(&ctx, sp->myauth.secret,
			  strlen(sp->myauth.secret));
d3917 1
a3917 2
		MD5Update(&ctx, sp->hisauth.secret,
			  strlen(sp->hisauth.secret));
d5125 4
@


1.86
log
@Collapse m_pullup and m_pullup2 into a single function, as they're
essentially identical; the only difference being that m_pullup2 is
capable of handling mbuf clusters, but called m_pullup for shorter
lengths (!).

testing dlg@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.85 2011/04/17 20:44:27 stsp Exp $	*/
d3347 1
a3347 1
			memset(&suggestaddr, 0, sizeof(&suggestaddr));
@


1.85
log
@in_ifinit() is not prepared to be called from interrupt context so add
addresses from process context by scheduling a work queue.
Fixes an assertwaitok panic. ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.84 2011/01/11 15:42:05 deraadt Exp $	*/
d543 1
a543 1
		m = m_pullup2(m, m->m_pkthdr.len);
@


1.84
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.83 2010/11/17 19:25:49 henning Exp $	*/
d50 1
d414 1
a414 2
HIDE void sppp_set_ip_addrs(struct sppp *sp, u_int32_t myaddr,
			      u_int32_t hisaddr);
d3027 6
d3036 9
d3046 1
a3046 2
	u_int32_t myaddr, hisaddr;
	sppp_get_ip_addrs(sp, &myaddr, &hisaddr, 0);
d3049 1
a3049 1
		myaddr = sp->ipcp.req_myaddr;
d3052 7
a3058 2
		hisaddr = sp->ipcp.req_hisaddr;
	sppp_set_ip_addrs(sp, myaddr, hisaddr);
d4711 1
d4715 1
a4715 1
sppp_set_ip_addrs(struct sppp *sp, u_int32_t myaddr, u_int32_t hisaddr)
d4717 6
a4722 1
	STDDCL;
d4726 6
d4782 1
d4787 1
@


1.83
log
@an extra parameter for in_ifinit, indicating wether the ifaddr passed to it
is new or an already existing one. for existing ones, call ifa_del first
tested by many as part of a larger diff, ok claudio dlg krw sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.82 2010/09/13 08:53:06 claudio Exp $	*/
d4948 4
a4951 3
		bzero(&spr->defs.myauth, sizeof(spr->defs.myauth));
		bzero(&spr->defs.hisauth, sizeof(spr->defs.hisauth));
		bzero(&spr->defs.chap_challenge, sizeof(spr->defs.chap_challenge));
d5073 1
a5073 1
			bzero(sp->chap_challenge, sizeof sp->chap_challenge);
@


1.82
log
@Using a normaly unavailable 0.0.0.1 gateway on routes on sppp(4) based
devices is a bad idea. The problem is that the default route per se works
but PMTU is unable to clone host routes because the gateway is unreachable.
Fix sppp(4) so that it walks the routing table and fixes the gateways.
This makes PMTU work again. Diff tested by weerd@@ and markus@@ (older version)
for a long time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.81 2010/07/20 15:36:03 matthew Exp $	*/
d4746 1
a4746 1
		if (!(error = in_ifinit(ifp, ifatoia(ifa), &new_sin, 0)))
d4798 1
a4798 1
		if (!in_ifinit(ifp, ifatoia(ifa), &new_sin, 0))
@


1.81
log
@Switch some obvious network stack MAC comparisons from bcmp() to
timingsafe_bcmp().

ok deraadt@@; committed over WPA.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.80 2010/05/01 08:14:26 mk Exp $	*/
d411 2
d4658 33
d4751 1
d4753 1
d4800 1
@


1.80
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.79 2010/02/08 13:37:02 claudio Exp $	*/
d3906 1
a3906 1
		    bcmp(digest, value, value_len) != 0) {
@


1.79
log
@The IMPs are history so is splimp, this needs now splnet so update comment.
Another thing found by Gleydson Soares.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.78 2009/11/03 10:59:04 claudio Exp $	*/
d524 1
a524 1
	/* mark incomming routing domain */
@


1.78
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.77 2009/07/27 11:40:59 blambert Exp $	*/
d4828 1
a4828 1
 * Set my IPv6 address.  Must be called at splimp.
@


1.77
log
@tiemout_add -> timeout_add_sec

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.76 2009/07/13 16:23:28 claudio Exp $	*/
d702 1
a702 1
	if (ifp->if_rdomain != m->m_pkthdr.rdomain) {
d704 3
a706 4
		    "%d vs. %d, AF %d\n", ifp->if_xname, ifp->if_rdomain,
		    m->m_pkthdr.rdomain, dst->sa_family);
		m_freem (m);
		return (ENETDOWN);
@


1.76
log
@Do the same rdomain checking in sppp as we do in the Ethernet case.
Encapsulated pppoe packets are moved into the rdomain of the physical interface
because it is possible that a pppoe(4) interface is in a different rdomain
then the physical interface.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.75 2009/02/18 08:36:20 canacar Exp $	*/
d924 1
a924 1
		timeout_add(&keepalive_ch, hz * 10);
d4039 1
a4039 1
		timeout_add(&sp->ch[IDX_CHAP], i * hz);
d4603 1
a4603 1
	timeout_add(&keepalive_ch, hz * 10);
@


1.75
log
@Free authentication data when detaching sppp from interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.74 2009/02/16 23:24:01 deraadt Exp $	*/
d524 3
d700 10
@


1.74
log
@allocate the large structures instead of putting them on the stack, and
use M_CANWAIT throughout
ok sthen canacar claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.73 2009/02/16 20:03:36 canacar Exp $	*/
d966 10
@


1.73
log
@Allow username and password to be up to 255 characters in length.
Tested by many, thanks.
Put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.72 2009/02/06 22:07:04 grange Exp $	*/
d4873 4
a4876 1
		struct spppreq spr;
d4884 3
a4886 2
		spr.cmd = cmd;
		bcopy(sp, &spr.defs, sizeof(struct sppp));
d4888 3
a4890 3
		bzero(&spr.defs.myauth, sizeof spr.defs.myauth);
		bzero(&spr.defs.hisauth, sizeof spr.defs.hisauth);
		bzero(spr.defs.chap_challenge, sizeof spr.defs.chap_challenge);
d4892 2
a4893 1
		if (copyout(&spr, (caddr_t)ifr->ifr_data, sizeof spr) != 0)
d4895 2
d4902 1
a4902 1
		struct sauthreq spa;
d4905 1
d4907 3
a4909 4

		bzero(&spa, sizeof(spa));
		spa.proto = auth->proto;
		spa.flags = auth->flags;
d4913 1
a4913 1
			strlcpy(spa.name, auth->name, sizeof(spa.name));
d4915 2
a4916 1
		if (copyout(&spa, (caddr_t)ifr->ifr_data, sizeof spa) != 0)
d4918 2
d4954 6
a4959 2
		struct spppreq spr;
		if (copyin((caddr_t)ifr->ifr_data, &spr, sizeof spr) != 0)
d4961 1
d4968 1
d4985 1
a4985 1
		struct sauthreq spa;
d4990 2
d4994 2
a4995 1
		if (copyin((caddr_t)ifr->ifr_data, &spa, sizeof spa) != 0)
d4997 1
d4999 3
a5001 2
		if (spa.proto != 0 && spa.proto != PPP_PAP &&
		    spa.proto != PPP_CHAP)
d5003 1
d5005 1
a5005 1
		if (spa.proto == 0) {
d5015 2
a5016 2
			auth->proto = spa.proto;
			auth->flags = spa.flags;
d5018 4
a5021 6
			spa.name[AUTHMAXLEN - 1] = '\0';
			len = strlen(spa.name) + 1;
			p = malloc(len, M_DEVBUF, M_WAITOK|M_CANFAIL);
			if (p == NULL)
				return (ENOMEM);
			strlcpy(p, spa.name, len);
d5026 5
a5030 7
			if (spa.secret[0] != '\0') {
				spa.secret[AUTHMAXLEN - 1] = '\0';
				len = strlen(spa.secret) + 1;
				p = malloc(len, M_DEVBUF, M_WAITOK|M_CANFAIL);
				if (p == NULL)
					return (ENOMEM);
				strlcpy(p, spa.secret, len);
d5036 1
@


1.72
log
@Remove bogus casts of integer constants SPPPIO[GS]DEFS to caddr_t
and fix typo while here.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.71 2009/01/31 21:28:40 grange Exp $	*/
d402 2
a403 2
HIDE int sppp_params(struct sppp *sp, u_long cmd, void *data);
HIDE int sppp_strnlen(u_char *p, int max);
d1127 3
d1131 1
a1131 1
		rv = sppp_params(sp, cmd, data);
d3703 1
a3703 1
	u_char *value, *name, digest[AUTHKEYLEN], dsize;
d3757 1
a3757 1
			  sppp_strnlen(sp->myauth.secret, AUTHKEYLEN));
d3765 1
a3765 1
			       (size_t)sppp_strnlen(sp->myauth.name, AUTHNAMELEN),
d3841 1
a3841 1
		if (name_len != sppp_strnlen(sp->hisauth.name, AUTHNAMELEN)
d3848 1
a3848 1
					  sppp_strnlen(sp->hisauth.name, AUTHNAMELEN));
d3863 1
a3863 1
		if (value_len != AUTHKEYLEN) {
d3869 1
a3869 1
				    AUTHKEYLEN);
d3876 2
a3877 2
			  sppp_strnlen(sp->hisauth.secret, AUTHKEYLEN));
		MD5Update(&ctx, sp->myauth.challenge, AUTHKEYLEN);
d4073 2
a4074 2
	arc4random_buf(sp->myauth.challenge, sizeof(sp->myauth.challenge));
	clen = AUTHKEYLEN;
d4080 2
a4081 2
		       (size_t)AUTHKEYLEN, sp->myauth.challenge,
		       (size_t)sppp_strnlen(sp->myauth.name, AUTHNAMELEN),
d4153 2
a4154 2
		if (name_len > AUTHNAMELEN ||
		    passwd_len > AUTHKEYLEN ||
d4389 2
a4390 2
	pwdlen = sppp_strnlen(sp->myauth.secret, AUTHKEYLEN);
	idlen = sppp_strnlen(sp->myauth.name, AUTHNAMELEN);
d4863 1
a4863 1
sppp_params(struct sppp *sp, u_long cmd, void *data)
d4865 1
a4865 2
	struct ifreq *ifr = (struct ifreq *)data;
	struct spppreq spr;
d4867 1
a4867 1
	if (copyin((caddr_t)ifr->ifr_data, &spr, sizeof spr) != 0)
d4870 1
a4870 1
	switch (spr.cmd) {
d4872 2
a4873 2
		if (cmd != SIOCGIFGENERIC)
			return EINVAL;
d4881 1
d4883 35
a4917 9
		if (suser(curproc, 0) != 0) {
			bzero(spr.defs.myauth.name, AUTHNAMELEN);
			bzero(spr.defs.hisauth.name, AUTHNAMELEN);
		}
		bzero(spr.defs.myauth.secret, AUTHKEYLEN);
		bzero(spr.defs.myauth.challenge, AUTHKEYLEN);
		bzero(spr.defs.hisauth.secret, AUTHKEYLEN);
		bzero(spr.defs.hisauth.challenge, AUTHKEYLEN);
		return copyout(&spr, (caddr_t)ifr->ifr_data, sizeof spr);
d4919 23
d4943 4
a4946 2
		if (cmd != SIOCSIFGENERIC)
			return EINVAL;
a4947 9
		 * We have a very specific idea of which fields we allow
		 * being passed back from userland, so to not clobber our
		 * current state.  For one, we only allow setting
		 * anything if LCP is in dead phase.  Once the LCP
		 * negotiations started, the authentication settings must
		 * not be changed again.  (The administrator can force an
		 * ifconfig down in order to get LCP back into dead
		 * phase.)
		 *
d4952 7
a4958 1
		 *
d4964 1
a4964 1
		 * back in a previous SPPPIOGDEFS call).  However, the
a4967 2
		if (sp->pp_phase != PHASE_DEAD)
			return EBUSY;
d4969 12
a4980 4
		if ((spr.defs.myauth.proto != 0 && spr.defs.myauth.proto != PPP_PAP &&
		     spr.defs.myauth.proto != PPP_CHAP) ||
		    (spr.defs.hisauth.proto != 0 && spr.defs.hisauth.proto != PPP_PAP &&
		     spr.defs.hisauth.proto != PPP_CHAP))
d4983 34
a5016 22
		if (spr.defs.myauth.proto == 0)
			/* resetting myauth */
			bzero(&sp->myauth, sizeof sp->myauth);
		else {
			/* setting/changing myauth */
			sp->myauth.proto = spr.defs.myauth.proto;
			bcopy(spr.defs.myauth.name, sp->myauth.name, AUTHNAMELEN);
			if (spr.defs.myauth.secret[0] != '\0')
				bcopy(spr.defs.myauth.secret, sp->myauth.secret,
				      AUTHKEYLEN);
		}
		if (spr.defs.hisauth.proto == 0)
			/* resetting hisauth */
			bzero(&sp->hisauth, sizeof sp->hisauth);
		else {
			/* setting/changing hisauth */
			sp->hisauth.proto = spr.defs.hisauth.proto;
			sp->hisauth.flags = spr.defs.hisauth.flags;
			bcopy(spr.defs.hisauth.name, sp->hisauth.name, AUTHNAMELEN);
			if (spr.defs.hisauth.secret[0] != '\0')
				bcopy(spr.defs.hisauth.secret, sp->hisauth.secret,
				      AUTHKEYLEN);
d5019 1
a5019 1

a5219 10
}

HIDE int
sppp_strnlen(u_char *p, int max)
{
	int len;

	for (len = 0; len < max && *p; ++p)
		++len;
	return len;
@


1.71
log
@u_char is not compatible with default argument promotion type thus
can't be used with va_start. change it to u_int.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.70 2008/06/09 07:07:16 djm Exp $	*/
d4869 1
a4869 1
	case (int)SPPPIOGDEFS:
d4890 1
a4890 1
	case (int)SPPPIOSDEFS:
@


1.70
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.69 2008/06/08 15:06:26 claudio Exp $	*/
d310 1
a310 1
			   struct sppp *sp, unsigned int type, u_char id,
d4410 1
a4410 1
		unsigned int type, u_char id, ...)
@


1.69
log
@Don't spam dmesg with sppp messages, instead use log(9).
OK canacar@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.68 2008/05/17 04:50:54 canacar Exp $	*/
d4070 1
a4070 1
	arc4random_bytes(sp->myauth.challenge, sizeof(sp->myauth.challenge));
@


1.68
log
@Initialize the timeouts only once instead of everytime they are started
Prevents hangs as reported and tested by James Stark, PR:5795, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.67 2008/05/11 02:55:45 brad Exp $	*/
d1184 1
a1184 1
				printf (SPP_FMT "loopback\n",
d1683 1
a1683 1
			printf(SPP_FMT "loopback\n", SPP_ARGS(ifp));
d4543 1
a4543 1
				printf (SPP_FMT "LCP keepalive timeout\n",
@


1.67
log
@Check to make sure pp_tlf is not NULL in sppp_keepalive() before calling it.

From NetBSD

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.66 2008/05/11 02:28:16 canacar Exp $	*/
d903 1
d934 5
a1893 1
	timeout_set(&sp->ch[cp->protoidx], cp->TO, (void *)sp);
a4012 1
		timeout_set(&sp->ch[IDX_CHAP], chap.TO, (void *)sp);
a4268 1
		timeout_set(&sp->pap_my_to_ch, sppp_pap_my_TO, (void *)sp);
@


1.66
log
@When passing opt[] array as an argument, use opt instead of &opt. While
they point to the same address, this is more readable. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.65 2007/12/04 19:49:52 claudio Exp $	*/
d4552 2
a4553 1
				sp->pp_tlf(sp);
@


1.65
log
@1500 is a 'magic number' in the protocol that all implementations
must be able to handle as MRU but while testing pppoe(4) against a pppoe(8)
server I figured out that pppoe(8) insists on a MRU 1492. Because of this
we allow the offered MRU to be between PP_MIN_MRU and PP_MAX_MRU especially
because the MRU is not used at all as long as it is smaller then PP_MAX_MRU.
OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.64 2007/11/26 09:28:33 martynas Exp $	*/
d2625 1
a2625 1
	sppp_cp_send (sp, PPP_LCP, CONF_REQ, sp->confid[IDX_LCP], i, &opt);
d3106 1
a3106 1
	sppp_cp_send(sp, PPP_IPCP, CONF_REQ, sp->confid[IDX_IPCP], i, &opt);
d3523 1
a3523 1
	sppp_cp_send(sp, PPP_IPV6CP, CONF_REQ, sp->confid[IDX_IPV6CP], i, &opt);
@


1.64
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.63 2007/11/21 19:52:04 canacar Exp $	*/
d1997 1
a1997 1
	sp->lcp.mru = sp->lcp.their_mru = PP_MTU;
d2033 1
a2033 1
 	sp->lcp.mru = sp->lcp.their_mru = PP_MTU;
d2456 4
a2459 2
				if (mru < PP_MTU || mru > PP_MAX_MRU)
					mru = PP_MTU;
@


1.63
log
@simplify sppp_chap_scr() now that we are using arc4random_bytes()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.62 2007/11/16 05:08:39 djm Exp $	*/
d4019 1
a4019 1
			addlog("re-challenging supressed\n");
d4548 1
a4548 1
				/* Close connection imediatly, completition of this
@


1.62
log
@use arc4random_bytes() instead of multiple arc4random() calls;
ok deraadt@@ dlg@@ henric@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.61 2007/11/01 03:35:43 deraadt Exp $	*/
a4060 1
	u_int32_t *ch;
d4064 1
a4064 2
	ch = (u_int32_t *)sp->myauth.challenge;
	arc4random_bytes(ch, sizeof(*ch) * 4);
@


1.61
log
@correct fix
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.60 2007/11/01 02:47:20 deraadt Exp $	*/
d4066 1
a4066 4
	ch[0] = arc4random();
	ch[1] = arc4random();
	ch[2] = arc4random();
	ch[3] = arc4random();
@


1.60
log
@tsk tsk tsk, noone tested this; spotted by canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.59 2007/10/31 21:13:45 mikeb Exp $	*/
d46 1
a4861 1
	extern struct proc *curproc;
@


1.59
log
@Don't leak potentially secret authname through ioctl interface.

Suggestions from mpf@@ and canacar@@

ok deraadt mpf canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.58 2007/09/25 23:52:27 canacar Exp $	*/
d4861 1
@


1.58
log
@Handle incoming protocol reject packets now that we have
more than one protocol. From FreeBSD, reported and tested by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.57 2007/09/05 21:01:49 canacar Exp $	*/
d4878 4
@


1.57
log
@IPv6 support for sppp layer, based on NetBSD version.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.56 2007/08/28 15:59:18 canacar Exp $	*/
d1583 43
a1626 5
		log(LOG_INFO,
		    SPP_FMT "%s: ignoring RXJ (%s) for proto 0x%x, "
		    "danger will robinson\n",
		    SPP_ARGS(ifp), cp->name,
		    sppp_cp_type_name(h->type), ntohs(*((u_short *)p)));
d1647 1
@


1.56
log
@The m_pulldown used for aligning was not copying the header,
revert back to m_pullup2. Reported and tested by Enache Adrian
additional testing by naddy@@ and claudio@@
ok claudio@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.55 2007/08/20 16:46:00 canacar Exp $	*/
d12 3
d84 4
a87 2
#else
# error Huh? sppp without INET?
d137 1
d142 1
d169 3
d353 21
d425 7
a431 1
	PPP_IPCP, IDX_IPCP, CP_NCP, "ipcp",
d438 14
d471 1
d602 14
d644 6
d817 20
d934 1
d3067 281
d3349 211
a3559 1
/*
d4700 118
d5011 14
@


1.55
log
@Align the packet after the ppp header.
The earlier change was broken in sparc due to alignment problems.
reported and tested by nady@@, ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.54 2007/08/14 18:11:46 canacar Exp $	*/
d484 10
a493 8
	m = m_pulldown(m, 0, m->m_pkthdr.len, NULL);
	if (m == NULL) {
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "Failed to align packet!\n", SPP_ARGS(ifp));
		++ifp->if_ierrors;
		++ifp->if_iqdrops;
		return;
@


1.54
log
@Make sure all the packet is in one continuous mbuf.
This is a bandaid solution, a better solution will go
in post 4.2. Reported and tested by Joerg Zinke.
ok claudio@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.53 2007/08/07 17:15:13 canacar Exp $	*/
a446 1
	void *prej;
a470 19
	if (m->m_pkthdr.len > MCLBYTES) {
		/* Too large packet, drop it. */
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "input packet is too large, %d bytes\n",
			    SPP_ARGS(ifp), m->m_pkthdr.len);
		goto drop;
	}

	m = m_pullup2(m, m->m_pkthdr.len);
	if (m == NULL) {
		if (debug)
			log(LOG_DEBUG,
			    SPP_FMT "m_pullup2() failed!\n", SPP_ARGS(ifp));
		++ifp->if_ierrors;
		++ifp->if_iqdrops;
		return;
	}

d472 1
a472 2
		prej = mtod(m, void *);
		memcpy(&ht.protocol, prej, sizeof(ht.protocol));
a479 1
		prej = &h->protocol;
d483 11
d511 1
a511 1
				    ++sp->pp_seq, m->m_len + 2, prej);
@


1.53
log
@Use the length of the mbuf instead of the packet.
When sending a protocol reject. Prevents reading
past the mbuf in case the mbuf does not cover the
whole packet. ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.52 2007/06/06 10:04:36 henning Exp $	*/
d469 19
@


1.52
log
@remove remaining IPX hooks. all inside #ifdef IPX, so no actual change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.51 2007/05/28 06:31:01 mcbride Exp $	*/
d503 1
a503 1
				    ++sp->pp_seq, m->m_pkthdr.len + 2, prej);
@


1.51
log
@Users of arc4random() should include dev/rndvar.h directly.

ok dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.50 2007/05/20 18:54:15 canacar Exp $	*/
a84 5
#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

a539 9
#ifdef IPX
		case PPP_IPX:
			/* IPX IPXCP not implemented yet */
			if (sp->pp_phase == PHASE_NETWORK) {
				schednetisr (NETISR_IPX);
				inq = &ipxintrq;
			}
			break;
#endif
a567 6
#ifdef IPX
		case ETHERTYPE_IPX:
			schednetisr (NETISR_IPX);
			inq = &ipxintrq;
			break;
#endif
a732 6
		break;
#endif
#ifdef IPX
	case AF_IPX:     /* Novell IPX Protocol */
		protocol = htons ((sp->pp_flags & PP_CISCO) ?
			ETHERTYPE_IPX : PPP_IPX);
@


1.50
log
@Handle IP address stuff in tls/tlf state messages
instead of open/close events. Fixes PR 5457 where
an extra open event arrived due to an authentication
timeout/retransmission and confused things. Tested
by RD Thrush and mpf@@, discussions and ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.49 2007/04/18 10:40:13 mpf Exp $	*/
d58 3
@


1.49
log
@Typo in comment. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.48 2007/04/17 21:36:58 mpf Exp $	*/
a2571 38
	STDDCL;
	u_int32_t myaddr, hisaddr;

	sp->ipcp.flags &= ~(IPCP_HISADDR_SEEN|IPCP_MYADDR_SEEN|
	    IPCP_MYADDR_DYN|IPCP_HISADDR_DYN);
	sp->ipcp.req_myaddr = 0;
	sp->ipcp.req_hisaddr = 0;

	sppp_get_ip_addrs(sp, &myaddr, &hisaddr, 0);
	/*
	 * If we don't have his address, this probably means our
	 * interface doesn't want to talk IP at all.  (This could
	 * be the case if somebody wants to speak only IPX, for
	 * example.)  Don't open IPCP in this case.
	 */
	if (hisaddr == 0) {
		/* XXX this message should go away */
		if (debug)
			log(LOG_DEBUG, SPP_FMT "ipcp_open(): no IP interface\n",
			    SPP_ARGS(ifp));
		return;
	}

	if (myaddr == 0) {
		/*
		 * I don't have an assigned address, so i need to
		 * negotiate my address.
		 */
		sp->ipcp.flags |= IPCP_MYADDR_DYN;
		sp->ipcp.opts |= (1 << IPCP_OPT_ADDRESS);
	}
	if (hisaddr == 1) {
		/*
		 * XXX - remove this hack!
		 * remote has no valid address, we need to get one assigned.
		 */
		sp->ipcp.flags |= IPCP_HISADDR_DYN;
	}
a2578 5
	if (sp->ipcp.flags & (IPCP_MYADDR_DYN|IPCP_HISADDR_DYN))
		/*
		 * Some address was dynamic, clear it again.
		 */
		sppp_clear_ip_addrs(sp);
d2896 39
d2942 4
@


1.48
log
@Add support for setting the address of the ppp peer.
Use the proper in_ifscrub() / in_ifinit() calls for
address changes to generate routing messages.
The correct way to set the default route now
needs the -ifp option, e.g.
 route add default -ifp pppoe0 0.0.0.1
Since the route is set right after bringing
the interface up, it still works w/out -ifp though.

Changes mostly from NetBSD.

Tested by Matthias Bauer and bluhm@@
OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.47 2007/03/19 23:31:14 mpf Exp $	*/
d2606 1
a2606 1
		 * remote has no valid adress, we need to get one assigned.
@


1.47
log
@Use u_int32_t instead of u_long for IP addresses.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.46 2007/02/14 00:53:48 jsg Exp $	*/
d381 3
a383 1
HIDE void sppp_set_ip_addr(struct sppp *sp, u_int32_t src);
d2575 5
d2603 7
d2617 1
a2617 1
	if (sp->ipcp.flags & IPCP_MYADDR_DYN)
d2619 1
a2619 1
		 * My address was dynamic, clear it again.
d2621 1
a2621 1
		sppp_set_ip_addr(sp, 0);
d2705 4
a2708 1
	sppp_get_ip_addrs(sp, 0, &hisaddr, 0);
d2726 2
a2727 1
			    (hisaddr == 1 && desiredaddr != 0)) {
d2740 2
a2895 1
					sppp_set_ip_addr(sp, wantaddr);
d2898 2
d2919 10
d2970 5
a2974 1
		sppp_get_ip_addrs(sp, &ouraddr, 0, 0);
d4020 1
a4020 1
 * Set my IP address.  Must be called at splnet.
d4023 1
a4023 1
sppp_set_ip_addr(struct sppp *sp, u_int32_t src)
d4025 4
a4028 3
	struct ifnet *ifp = &sp->pp_if;
	struct ifaddr *ifa;
	struct sockaddr_in *si;
d4047 1
d4054 72
a4125 2
		si->sin_addr.s_addr = htonl(src);
		dohooks(ifp->if_addrhooks, 0);
@


1.46
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.45 2007/02/11 20:29:22 miod Exp $	*/
d366 1
a366 1
HIDE const char *sppp_dotted_quad(u_long addr);
d374 2
a375 2
HIDE void sppp_get_ip_addrs(struct sppp *sp, u_long *src, u_long *dst,
			      u_long *srcmask);
d381 1
a381 1
HIDE void sppp_set_ip_addr(struct sppp *sp, u_long src);
d1062 1
a1062 1
	u_long me, mymask;
d1123 1
a1123 1
		if (me != 0L)
d2571 1
a2571 1
	u_long myaddr, hisaddr;
d2580 1
a2580 1
	if (hisaddr == 0L) {
d2588 1
a2588 1
	if (myaddr == 0L) {
d2607 1
a2607 1
		sppp_set_ip_addr(sp, 0L);
d2628 1
a2628 1
	u_long hisaddr, desiredaddr;
d2841 1
a2841 1
	u_long wantaddr;
d2924 1
a2924 1
	u_long ouraddr;
d3938 2
a3939 1
sppp_get_ip_addrs(struct sppp *sp, u_long *src, u_long *dst, u_long *srcmask)
d3944 1
a3944 1
	u_long ssrc, ddst;
d3947 1
a3947 1
	ssrc = ddst = 0L;
d3988 1
a3988 1
sppp_set_ip_addr(struct sppp *sp, u_long src)
d4287 1
a4287 1
sppp_dotted_quad(u_long addr)
@


1.45
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.44 2006/12/06 10:37:29 bernd Exp $	*/
d976 1
a976 1
		/* fall through... */
d1441 1
a1441 1
			/* fall through */
d2045 1
a2045 1
			/* fall through, both are same length */
d3324 1
a3324 1
			/* fall through */
@


1.44
log
@Missing newline in printf.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.43 2006/08/28 10:50:13 canacar Exp $	*/
a36 13
#if defined (__FreeBSD__)
#include "opt_inet.h"
#include "opt_ipx.h"
#endif

#ifdef NetBSD1_3
#  if NetBSD1_3 > 6
#      include "opt_inet.h"
#      include "opt_iso.h"
#  endif
#endif

#ifdef __OpenBSD__
a37 3
#else
#define HIDE static
#endif
@


1.43
log
@Check for illegal option lengths when parsing LCP packets
and drop such bad packets. Also remove some redundant mallocs.

This fixes possible heap overflows when forming replys to such bad
packets as discovered by Martin Husemann and Pavel Cahyna.

reported by NetBSD, initial diff from markus@@,
additional comments by claudio@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.42 2006/07/11 21:36:51 canacar Exp $	*/
d3913 1
a3913 1
				printf (SPP_FMT "LCP keepalive timeout",
@


1.42
log
@Only print link state changes if interface is in debug mode.
Affects devices using the sppp layer (pppoe, art, san, lmc)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.41 2006/07/04 17:18:37 deraadt Exp $	*/
d1320 3
d2051 5
a2055 1
	for (rlen=0; len>1 && p[1]; len-=p[1], p+=p[1]) {
d2242 1
a2242 1
	u_char *buf, *p;
a2244 3
	buf = malloc (len, M_TEMP, M_NOWAIT);
	if (!buf)
		return;
d2251 3
a2253 1
	for (; len > 1 && p[1]; len -= p[1], p += p[1]) {
a2291 2
	free (buf, M_TEMP);
	return;
d2302 1
a2302 1
	u_char *buf, *p;
a2305 3
	buf = malloc (len, M_TEMP, M_NOWAIT);
	if (!buf)
		return;
d2312 3
a2314 1
	for (; len > 1 && p[1]; len -= p[1], p += p[1]) {
a2368 2
	free (buf, M_TEMP);
	return;
d2661 5
a2665 1
	for (rlen=0; len>1 && p[1]; len-=p[1], p+=p[1]) {
d2812 1
a2812 1
	u_char *buf, *p;
a2816 3
	buf = malloc (len, M_TEMP, M_NOWAIT);
	if (!buf)
		return;
d2823 3
a2825 1
	for (; len > 1 && p[1]; len -= p[1], p += p[1]) {
a2844 2
	free (buf, M_TEMP);
	return;
d2854 1
a2854 1
	u_char *buf, *p;
a2859 3
	buf = malloc (len, M_TEMP, M_NOWAIT);
	if (!buf)
		return;
d2866 3
a2868 1
	for (; len > 1 && p[1]; len -= p[1], p += p[1]) {
a2908 2
	free (buf, M_TEMP);
	return;
@


1.41
log
@logging should be in debug mode only.  if every network driver did a
dmesg printf everytime they came up, would that be a better world?
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.40 2006/07/02 11:01:06 reyk Exp $	*/
d4341 1
a4341 1
	struct ifnet *ifp = &sp->pp_if;
d4344 3
a4346 2
	log(LOG_INFO, SPP_FMT "phase %s\n", SPP_ARGS(ifp),
	    sppp_phase_name(sp->pp_phase));
@


1.40
log
@diff from peter phillip at freenet dot de:

	the "pppoe0: up" message is annoying when one is on console and the
	system has been configured to recall the ISP every minute or so.
	Moving the printf() to a log() fixes this and the "pppoe0: up"
	message is still seen in logs and dmesg.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.39 2006/03/04 22:40:16 brad Exp $	*/
d1133 2
a1134 1
			log(LOG_INFO, SPP_FMT "up\n", SPP_ARGS(ifp));
d2382 2
a2383 1
		log(LOG_INFO, SPP_FMT "up\n", SPP_ARGS(ifp));
@


1.39
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.38 2006/02/24 20:34:34 claudio Exp $	*/
d1133 1
a1133 1
			printf (SPP_FMT "up\n", SPP_ARGS(ifp));
d2381 1
a2381 1
		printf (SPP_FMT "up\n", SPP_ARGS(ifp));
@


1.38
log
@Another gem from the the-world-runs-on-i386 departement. Using u_long in
a packet format causes some troubles on 64bit archs. This fixes a sppp(4)
panic I got on alpha and makes cisco HDLC mode actually work. More cleanup
needs to be done post 3.9. OK brad@@ looks good canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.37 2005/10/07 05:19:34 canacar Exp $	*/
d616 1
a616 1
	s = splimp();
d646 1
a646 1
	s = splimp();
d666 1
a666 1
		s = splimp();
d917 1
a917 1
	s = splimp();
d934 1
a934 1
	s = splimp();
d962 1
a962 2
	s= splimp ();

d983 1
a983 1
	s = splimp();
d1789 1
a1789 1
	s = splimp();
d3139 1
a3139 1
		x = splimp();
d3318 1
a3318 1
	s = splimp();
d3391 1
a3391 1
	x = splimp();
d3559 1
a3559 1
		x = splimp();
d3661 1
a3661 1
	s = splimp();
d3718 1
a3718 1
	x = splimp();
d3885 1
a3885 1
	s = splimp();
d3999 1
a3999 1
 * Set my IP address.  Must be called at splimp.
@


1.38.2.1
log
@MFC:
Fix by canacar@@

Check for illegal option lengths when parsing LCP packets
and drop such bad packets. Also remove some redundant mallocs.

This fixes possible heap overflows when forming replys to such bad
packets as discovered by Martin Husemann and Pavel Cahyna.

reported by NetBSD, initial diff from markus@@,
additional comments by claudio@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.38 2006/02/24 20:34:34 claudio Exp $	*/
a1319 3
		/* silently drop illegal packets */
		if (rv == -1)
			return;
d2048 1
a2048 5
	for (rlen = 0; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len) {
			free(buf, M_TEMP);
			return (-1);
		}
d2235 1
a2235 1
	u_char *p;
d2238 3
d2247 1
a2247 3
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
d2286 2
d2298 1
a2298 1
	u_char *p;
d2302 3
d2311 1
a2311 3
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
d2366 2
d2659 1
a2659 5
	for (rlen = 0; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len) {
			free(buf, M_TEMP);
			return (-1);
		}
d2806 1
a2806 1
	u_char *p;
d2811 3
d2820 1
a2820 3
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
d2840 2
d2851 1
a2851 1
	u_char *p;
d2857 3
d2866 1
a2866 3
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
d2907 2
@


1.37
log
@Report interface link state changes in sppp layer
Help and ok claudio@@, ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.36 2005/08/12 21:29:10 canacar Exp $	*/
d225 3
a227 3
	u_long type;
	u_long par1;
	u_long par2;
d304 1
a304 1
HIDE void sppp_cisco_send(struct sppp *sp, int type, long par1, long par2);
d1092 1
a1092 1
		    "<0x%lx 0x%lx 0x%lx 0x%x 0x%x-0x%x>\n",
d1094 1
a1094 1
		    (u_long)ntohl (h->type), (u_long)h->par1, (u_long)h->par2, (u_int)h->rel,
d1099 2
a1100 2
			addlog(SPP_FMT "cisco unknown packet type: 0x%lx\n",
			       SPP_ARGS(ifp), (u_long)ntohl (h->type));
d1149 1
a1149 1
sppp_cisco_send(struct sppp *sp, int type, long par1, long par2)
d1180 4
a1183 4
		log(LOG_DEBUG,
		    SPP_FMT "cisco output: <0x%lx 0x%lx 0x%lx 0x%x 0x%x-0x%x>\n",
			SPP_ARGS(ifp), (u_long)ntohl (ch->type), (u_long)ch->par1,
			(u_long)ch->par2, (u_int)ch->rel, (u_int)ch->time0, (u_int)ch->time1);
@


1.36
log
@Use actual packet contents when sending protocol rejects. Fixes PR 4305.
Different fix tested by the submitter, xiangbo3 at gmail com.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.35 2005/08/03 21:50:21 canacar Exp $	*/
d73 1
d398 1
d1912 5
a1916 1
	if (sp->pp_flags & PP_CISCO)
d1918 1
d1960 5
a1964 1
	if (sp->pp_flags & PP_CISCO)
d1966 1
d2395 1
a2395 2
	log(LOG_INFO, SPP_FMT "phase %s\n", SPP_ARGS(ifp),
	    sppp_phase_name(sp->pp_phase));
a2431 1
	struct ifnet *ifp = &sp->pp_if;
d2437 1
a2437 2
	log(LOG_INFO, SPP_FMT "phase %s\n", SPP_ARGS(ifp),
	    sppp_phase_name(sp->pp_phase));
a2454 2
	struct ifnet *ifp = &sp->pp_if;

d2457 1
a2457 2
	log(LOG_INFO, SPP_FMT "phase %s\n", SPP_ARGS(ifp),
	    sppp_phase_name(sp->pp_phase));
a2466 2
	struct ifnet *ifp = &sp->pp_if;

d2468 1
a2468 2
	log(LOG_INFO, SPP_FMT "phase %s\n", SPP_ARGS(ifp),
	    sppp_phase_name(sp->pp_phase));
a4134 1
	struct ifnet *ifp = &sp->pp_if;
d4140 1
a4140 2
	log(LOG_INFO, SPP_FMT "phase %s\n", SPP_ARGS(ifp),
	    sppp_phase_name(sp->pp_phase));
d4336 23
@


1.36.2.1
log
@MFC:
Fix by canacar@@

Check for illegal option lengths when parsing LCP packets
and drop such bad packets. Also remove some redundant mallocs.

This fixes possible heap overflows when forming replys to such bad
packets as discovered by Martin Husemann and Pavel Cahyna.

reported by NetBSD, initial diff from markus@@,
additional comments by claudio@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.36 2005/08/12 21:29:10 canacar Exp $	*/
a1317 3
		/* silently drop illegal packets */
		if (rv == -1)
			return;
d2036 1
a2036 5
	for (rlen = 0; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len) {
			free(buf, M_TEMP);
			return (-1);
		}
d2223 1
a2223 1
	u_char *p;
d2226 3
d2235 1
a2235 3
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
d2274 2
d2286 1
a2286 1
	u_char *p;
d2290 3
d2299 1
a2299 3
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
d2354 2
d2656 1
a2656 5
	for (rlen = 0; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len) {
			free(buf, M_TEMP);
			return (-1);
		}
d2803 1
a2803 1
	u_char *p;
d2808 3
d2817 1
a2817 3
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
d2837 2
d2848 1
a2848 1
	u_char *p;
d2854 3
d2863 1
a2863 3
	for (; len > 1; len -= p[1], p += p[1]) {
		if (p[1] < 2 || p[1] > len)
			return;
d2904 2
@


1.35
log
@prevent unaligned memory access when processing LCP echo packets,
making pppoe(4) work on sparc64. Fixes PR-4311
Reported and fix tested by David Coppa < dcoppa at gmail com >
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.34 2005/06/08 06:55:33 henning Exp $	*/
d461 1
d487 2
a488 1
		memcpy(&ht.protocol, mtod(m, void *), 2);
d496 1
d517 1
a517 2
					++sp->pp_seq, m->m_pkthdr.len + 2,
					&h->protocol);
@


1.34
log
@bye bye netns (and a few leftover DECNET bits while here)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.33 2005/05/13 20:17:02 brad Exp $	*/
d1272 1
d1558 5
a1562 1
		if (ntohl (*(long*)(h+1)) == sp->lcp.magic) {
d1569 6
a1574 1
		*(long*)(h+1) = htonl (sp->lcp.magic);
d1597 5
a1601 1
		if (ntohl (*(long*)(h+1)) != sp->lcp.magic)
@


1.33
log
@Fix for a panic experienced when authenticating a pppoe session on an amd64 system.

From: i4b project via FreeBSD via Jason Ackley

Fixes PR 4190 & 4196

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.32 2005/04/24 20:56:48 canacar Exp $	*/
a101 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a560 9
#ifdef NS
		case PPP_XNS:
			/* XNS IDPCP not implemented yet */
			if (sp->pp_phase == PHASE_NETWORK) {
				schednetisr (NETISR_NS);
				inq = &nsintrq;
			}
			break;
#endif
a594 6
#ifdef NS
		case ETHERTYPE_NS:
			schednetisr (NETISR_NS);
			inq = &nsintrq;
			break;
#endif
a759 6
		break;
#endif
#ifdef NS
	case AF_NS:     /* Xerox NS Protocol */
		protocol = htons ((sp->pp_flags & PP_CISCO) ?
			ETHERTYPE_NS : PPP_XNS);
@


1.32
log
@Fix cisco-mode check in lcp up/down.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.31 2005/04/11 17:24:10 canacar Exp $	*/
d321 1
a321 1
			   struct sppp *sp, u_char type, u_char id,
d3786 2
a3787 2
sppp_auth_send(const struct cp *cp, struct sppp *sp, u_char type, u_char id,
	       ...)
d3795 2
a3796 1
	size_t mlen, pkthdrlen;
d3825 1
a3825 1
	while ((mlen = va_arg(ap, size_t)) != 0) {
@


1.31
log
@Ignore lcp up/down events in cisco mode
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.30 2005/04/01 22:09:32 canacar Exp $	*/
d1920 1
a1920 1
	if (ifp->if_flags & PP_CISCO)
d1963 1
a1963 1
	if (ifp->if_flags & PP_CISCO)
@


1.30
log
@do not mess with lcp if we are in cisco mode
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.29 2005/03/24 16:37:52 claudio Exp $	*/
d1920 3
d1962 3
@


1.29
log
@Unbreak tree, mono_time may no longer be used because of timecounters.
Use getmicrouptime() instead. Found by grange@@ and henning@@.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.28 2005/03/23 00:26:06 canacar Exp $	*/
d1030 3
a1032 1
			lcp.Close(sp);
@


1.28
log
@Merge some sppp improvements from NetBSD:
1. better timeout and keepalive handling
2. fix some memory leaks on error paths.
3. use arc4random instead of random
4. always send keepalives in cHDLC mode, from claudio@@
Tested by Greg Mortensen (san) and jmc@@ (pppoe), ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.26 2004/12/10 14:35:30 naddy Exp $	*/
a463 1
	int s;
d465 1
d467 1
d473 2
a474 1
		sp->pp_last_receive = mono_time.tv_sec;
d553 1
a553 1
				sp->pp_last_activity = mono_time.tv_sec;
d658 1
d664 2
a665 1
	sp->pp_last_activity = mono_time.tv_sec;
d1916 1
d1924 2
a1925 1
	sp->pp_last_receive = sp->pp_last_activity = mono_time.tv_sec;
d3882 1
a3882 1
	time_t now;
d3885 1
a3885 1
	now = mono_time.tv_sec;
d3901 1
a3901 1
		    (now - sp->pp_last_receive) < NORECV_TIME) {
@


1.27
log
@Follow RFC and do not reset timeouts everytime sppp_cp_change_state()
is called. Makes two sppp instances to handshake against each other.
Tested by Greg Mortensen, ok claudio@@
@
text
@d119 4
a122 1
#define MAXALIVECNT     3               /* max. alive packets */
d468 1
a468 1
	if (ifp->if_flags & IFF_UP)
d471 3
d551 1
d661 2
d877 2
d1000 1
a1000 1
	int s, rv, going_up, going_down;
d1014 6
d1021 1
a1021 1
		if (ifp->if_flags & IFF_PASSIVE)
d1023 1
d1025 1
a1025 7
		going_up = (ifp->if_flags & IFF_UP) && ! (ifp->if_flags &
			(IFF_RUNNING | IFF_AUTO | IFF_PASSIVE));
		going_down = ! (ifp->if_flags & IFF_UP) &&
			(ifp->if_flags & IFF_RUNNING);

		if (going_up || going_down) {
			if (! (sp->pp_flags & PP_CISCO))
d1027 1
a1027 6
			else {
				sppp_flush(ifp);
				ifp->if_flags &= ~IFF_RUNNING;
			}
		}
		if (going_up) {
d1032 3
d1127 1
a1127 1
			if (sp->pp_loopcnt >= MAXALIVECNT) {
d1140 1
a1140 1
			sp->pp_seq = random();
d1918 3
a1925 1
	ifp->if_flags |= IFF_RUNNING;
d1930 1
d1938 4
d1952 10
d1963 6
a1968 1
		log(LOG_DEBUG, SPP_FMT "Down event (carrier loss)\n",
d1970 1
a1970 1
  	sppp_down_event(&lcp, sp);
d1972 1
a1972 1
 	if ((ifp->if_flags & (IFF_AUTO | IFF_PASSIVE)) != 0)
d2038 1
a2038 5
			if (len >= 6 && p[1] == 6)
				continue;
			if (debug)
				addlog("[invalid] ");
			break;
d2092 2
a2093 2
		sppp_cp_send (sp, PPP_LCP, CONF_REJ, h->ident, rlen, buf);
		return 0;
d2185 1
a2185 1
		if (++sp->fail_counter[IDX_LCP] < sp->lcp.max_failure) {
d2187 8
a2194 3
				addlog("send conf-nak\n");
			sppp_cp_send (sp, PPP_LCP, CONF_NAK, h->ident, rlen, buf);
			return 0;
d2196 1
a2196 9
		if (debug)
			addlog("max_failure (%d) exceeded, closing\n",
			       sp->lcp.max_failure);
		if (sp->pp_loopcnt >= MAXALIVECNT)
			printf (SPP_FMT "loopback\n", SPP_ARGS(ifp));
		lcp.Close(sp);
		sp->fail_counter[IDX_LCP] = 0;
		sp->pp_loopcnt = 0;
		return 0;
d2206 2
a2207 1
	free (buf, M_TEMP);
d2405 4
d2478 1
a2478 1
			sp->lcp.magic = random();
d2688 2
a2689 2
		sppp_cp_send (sp, PPP_IPCP, CONF_REJ, h->ident, rlen, buf);
		return 0;
d2740 1
d2742 4
a2745 5
				p[2] = hisaddr >> 24;
				p[3] = hisaddr >> 16;
				p[4] = hisaddr >> 8;
				p[5] = hisaddr;
			}
d2787 2
a2788 1
	free (buf, M_TEMP);
d3364 1
a3364 1
		i = 300 + ((unsigned)(random() & 0xff00) >> 7);
d3876 1
d3879 1
d3893 8
a3900 1
		if (sp->pp_alivecnt == MAXALIVECNT) {
a3901 2
			printf (SPP_FMT "down\n", SPP_ARGS(ifp));
 			if (sp->pp_flags & PP_CISCO) {
d3904 15
a3918 3
 			} else {
				/* Shut down the PPP link. */
 				lcp.Close(sp);
d3921 1
a3921 1
		if (sp->pp_alivecnt <= MAXALIVECNT)
d3927 1
a3927 1
			long nmagic = htonl (sp->lcp.magic);
@


1.26
log
@Run address change notification hooks when the interface address is updated.
Notably, this fixes "(pppoe0)" in pf.  ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.25 2004/11/28 23:39:45 canacar Exp $	*/
a1846 1
	UNTIMEOUT(cp->TO, (void *)sp, sp->ch[cp->protoidx]);
d1853 1
d1860 2
a1861 1
 		sppp_increasing_timeout (cp, sp);
@


1.25
log
@In kernel pppoe client, a simple IPv4 only implementation.
Initial porting from NetBSD by David Berghoff.
Modified/simplified to match our sppp implementation.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.24 2004/07/16 15:01:09 henning Exp $	*/
d3972 1
a3972 1
	if (ifa && si)
d3974 2
@


1.24
log
@remove netiso shitz, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.23 2004/06/24 19:35:25 tholo Exp $	*/
d459 1
a459 1
	struct ppp_header *h;
d466 2
a467 2
		/* Count received bytes, add FCS and one flag */
		ifp->if_ibytes += m->m_pkthdr.len + 3;
d482 11
a492 3
	/* Get PPP header. */
	h = mtod (m, struct ppp_header*);
	m_adj (m, PPP_HEADER_LEN);
d650 1
d678 2
a679 3
		/* XXX Check mbuf length here? */
		struct ip *ip = mtod (m, struct ip*);
		struct tcphdr *tcp = (struct tcphdr*) ((long*)ip + ip->ip_hl);
d681 9
d701 3
a703 2
		if(ip->ip_src.s_addr == INADDR_ANY)     /* -hm */
		{
d706 1
a706 1
			if(ip->ip_p == IPPROTO_TCP)
d712 4
a715 7

		if (! IF_QFULL (&sp->pp_fastq) &&
		    ((ip->ip_tos & IPTOS_LOWDELAY) ||
	    	     (ip->ip_p == IPPROTO_TCP &&
	    	      m->m_len >= sizeof (struct ip) + sizeof (struct tcphdr) &&
	    	      (INTERACTIVE (ntohs (tcp->th_sport)) ||
	    	       INTERACTIVE (ntohs (tcp->th_dport))))))
d720 2
d726 1
a726 1
	if (! m) {
d747 1
d752 1
a752 1
			h->protocol = htons (ETHERTYPE_IP);
d763 1
a763 1
			h->protocol = htons(PPP_IP);
d771 1
a771 1
		h->protocol = htons ((sp->pp_flags & PP_CISCO) ?
d777 1
a777 1
		h->protocol = htons ((sp->pp_flags & PP_CISCO) ?
d782 1
a782 1
		m_freem (m);
d784 1
a784 1
		splx (s);
d788 15
d818 2
a819 2
		}
		IF_ENQUEUE (ifq, m);
d822 1
d829 1
a829 1
	if (! (ifp->if_flags & IFF_OACTIVE))
d837 1
a837 1
	ifp->if_obytes += len + 3;
d848 1
a848 1
	if (! spppq)
d855 1
d1201 1
a1201 1
		ifp->if_obytes += m->m_pkthdr.len + 3;
d1219 3
d1223 2
a1224 2
	if (len > MHLEN - PPP_HEADER_LEN - LCP_HEADER_LEN)
		len = MHLEN - PPP_HEADER_LEN - LCP_HEADER_LEN;
d1228 1
a1228 1
	m->m_pkthdr.len = m->m_len = PPP_HEADER_LEN + LCP_HEADER_LEN + len;
d1231 10
a1240 6
	h = mtod (m, struct ppp_header*);
	h->address = PPP_ALLSTATIONS;        /* broadcast address */
	h->control = PPP_UI;                 /* Unnumbered Info */
	h->protocol = htons (proto);         /* Link Control Protocol */

	lh = (struct lcp_header*) (h + 1);
d1265 1
a1265 1
	if (! (ifp->if_flags & IFF_OACTIVE))
d1268 1
a1268 1
		ifp->if_obytes += m->m_pkthdr.len + 3;
d2286 1
a2286 5
#if defined (__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
					sp->lcp.magic = random();
#else
					sp->lcp.magic = time.tv_sec + time.tv_usec;
#endif
d3749 1
a3749 1
	size_t mlen;
d3758 12
a3769 4
	h = mtod (m, struct ppp_header*);
	h->address = PPP_ALLSTATIONS;		/* broadcast address */
	h->control = PPP_UI;			/* Unnumbered Info */
	h->protocol = htons(cp->proto);
a3770 1
	lh = (struct lcp_header*)(h + 1);
d3781 1
a3781 1
		if (len > MHLEN - PPP_HEADER_LEN - LCP_HEADER_LEN) {
d3792 1
a3792 1
	m->m_pkthdr.len = m->m_len = PPP_HEADER_LEN + LCP_HEADER_LEN + len;
d3815 1
a3815 1
		ifp->if_obytes += m->m_pkthdr.len + 3;
@


1.23
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.22 2004/06/22 02:02:45 tholo Exp $	*/
a106 7
#ifdef ISO
#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#endif

a557 9
#ifdef ISO
		case PPP_ISO:
			/* OSI NLCP not implemented yet */
			if (sp->pp_phase == PHASE_NETWORK) {
				schednetisr (NETISR_ISO);
				inq = &clnlintrq;
			}
			break;
#endif
a761 8
#endif
#ifdef ISO
	case AF_ISO:    /* ISO OSI Protocol */
		if (sp->pp_flags & PP_CISCO)
			goto nosupport;
		h->protocol = htons (PPP_ISO);
		break;
nosupport:
@


1.22
log
@Don't use time-based random number generation

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.21 2004/05/07 14:42:27 millert Exp $	*/
d1150 1
a1150 5
#if defined (__FreeBSD__)
	struct timeval tv;
#else
	u_long t = (time.tv_sec - boottime.tv_sec) * 1000;
#endif
a1151 1
#if defined (__FreeBSD__)
a1152 1
#endif
a1170 1
#if defined (__FreeBSD__)
a1172 4
#else
	ch->time0 = htons ((u_short) (t >> 16));
	ch->time1 = htons ((u_short) t);
#endif
@


1.21
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.20 2004/04/25 18:50:01 henning Exp $	*/
d3389 1
a3389 1
	u_long *ch, seed;
a3390 3
#if defined (__NetBSD__) || defined (__OpenBSD__)
	struct timeval tv;
#endif
d3393 5
a3397 11
	ch = (u_long *)sp->myauth.challenge;
#if defined (__FreeBSD__)
	read_random(&seed, sizeof seed);
#else
	microtime(&tv);
	seed = tv.tv_sec ^ tv.tv_usec;
#endif
	ch[0] = seed ^ random();
	ch[1] = seed ^ random();
	ch[2] = seed ^ random();
	ch[3] = seed ^ random();
@


1.20
log
@check for input queue congestion on those as well and call if_congestion when
needed; these  are slightly different so that we cannot use the new
IF_INPUT_ENQUEUE macro
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.19 2004/01/03 14:08:53 espie Exp $	*/
d65 1
a65 1
#include <sys/md5k.h>
@


1.19
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.18 2003/05/06 07:28:39 deraadt Exp $	*/
d639 2
@


1.18
log
@string cleaning; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.17 2003/01/07 09:00:33 kjc Exp $	*/
d80 1
a80 1
#include <machine/stdarg.h>
@


1.17
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.16 2002/09/26 20:43:54 chris Exp $	*/
d4112 1
a4112 1
	sprintf (buf, "0x%x", type);
d4135 1
a4135 1
	sprintf (buf, "0x%x", type);
d4152 1
a4152 1
	sprintf (buf, "0x%x", opt);
d4165 1
a4165 1
	sprintf (buf, "0x%x", opt);
d4210 1
a4210 1
	sprintf(buf, "0x%x", (unsigned)proto);
d4243 1
a4243 1
	sprintf(s, "%d.%d.%d.%d",
@


1.16
log
@BSD-style license from Serge Vakulenko <vak@@cronyx.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.15 2002/09/11 05:38:47 itojun Exp $	*/
a655 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a676 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d810 1
a810 1
		IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, rv);
@


1.15
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.14 2002/03/12 09:51:20 kjc Exp $	*/
d12 19
a30 8
 * This software is distributed with NO WARRANTIES, not even the implied
 * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Authors grant any other persons or organisations permission to use
 * or modify this software as long as this message is kept with the software,
 * all derivative works or modified versions.
 *
 * Version 2.6, Tue May 12 17:10:39 MSD 1998
d32 1
@


1.14
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.13 2001/12/27 09:11:47 itojun Exp $	*/
d698 1
a698 1
				return(EADDRNOTAVAIL);
d700 1
a700 1
				return(0);
@


1.13
log
@revision 1.12 lacks paren around && within || (gcc warns and compilation stops).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.12 2001/12/26 22:36:31 mickey Exp $	*/
d804 1
a804 2
	}
	else
@


1.12
log
@misplaced (), causing tcp header be examined in non-tcp packets
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.11 2001/12/10 06:10:53 jason Exp $	*/
d706 4
a709 4
	    	    ((ip->ip_p == IPPROTO_TCP &&
	    	    m->m_len >= sizeof (struct ip) + sizeof (struct tcphdr) &&
	    	    (INTERACTIVE (ntohs (tcp->th_sport))) ||
	    	     INTERACTIVE (ntohs (tcp->th_dport))))))
@


1.11
log
@use queue.h macros for TAILQ operations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.10 2001/07/10 11:09:07 espie Exp $	*/
d708 2
a709 2
	    	    (INTERACTIVE (ntohs (tcp->th_sport)))) ||
	    	    INTERACTIVE (ntohs (tcp->th_dport)))))
@


1.11.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.13 2001/12/27 09:11:47 itojun Exp $	*/
d706 4
a709 4
	    	     (ip->ip_p == IPPROTO_TCP &&
	    	      m->m_len >= sizeof (struct ip) + sizeof (struct tcphdr) &&
	    	      (INTERACTIVE (ntohs (tcp->th_sport)) ||
	    	       INTERACTIVE (ntohs (tcp->th_dport))))))
@


1.11.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.11.2.1 2002/01/31 22:55:43 niklas Exp $	*/
d804 2
a805 1
	} else
@


1.11.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.11.2.2 2002/06/11 03:30:45 art Exp $	*/
d12 8
a19 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT ``AS IS'' AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   
 * POSSIBILITY OF SUCH DAMAGE.
a20 1
 * From: Version 2.6, Tue May 12 17:10:39 MSD 1998
d698 1
a698 1
				return (EADDRNOTAVAIL);
d700 1
a700 1
				return (0);
@


1.11.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d656 1
d678 6
d817 1
a817 1
		IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);
d4119 1
a4119 1
	snprintf (buf, sizeof buf, "0x%x", type);
d4142 1
a4142 1
	snprintf (buf, sizeof buf, "0x%x", type);
d4159 1
a4159 1
	snprintf (buf, sizeof buf, "0x%x", opt);
d4172 1
a4172 1
	snprintf (buf, sizeof buf, "0x%x", opt);
d4217 1
a4217 1
	snprintf(buf, sizeof buf, "0x%x", (unsigned)proto);
d4250 1
a4250 1
	snprintf(s, sizeof s, "%d.%d.%d.%d",
@


1.10
log
@Missing breaks.
Case labels must be integral values for deterministic behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.9 2001/06/27 06:07:43 kjc Exp $	*/
d3906 2
a3907 3
	for (ifa = ifp->if_addrlist.tqh_first, si = 0;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
d3909 1
d3916 1
d3953 2
a3954 3
	for (ifa = ifp->if_addrlist.tqh_first, si = 0;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
@


1.10.2.1
log
@Pull in patch from current:
Fix (mickey):
misplaced (), causing tcp header be examined in non-tcp packets
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.10 2001/07/10 11:09:07 espie Exp $	*/
d708 2
a709 2
	    	    (INTERACTIVE (ntohs (tcp->th_sport))) ||
	    	     INTERACTIVE (ntohs (tcp->th_dport))))))
@


1.10.2.2
log
@Pull in patch from current:
Fix (itojun):
revision 1.12 lacks paren around && within || (gcc warns and compilation stops).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.10.2.1 2001/12/26 23:51:36 jason Exp $	*/
d706 4
a709 4
	    	     (ip->ip_p == IPPROTO_TCP &&
	    	      m->m_len >= sizeof (struct ip) + sizeof (struct tcphdr) &&
	    	      (INTERACTIVE (ntohs (tcp->th_sport)) ||
	    	       INTERACTIVE (ntohs (tcp->th_dport))))))
@


1.9
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.8 2001/03/25 02:56:18 csapuntz Exp $	*/
d1627 1
d1664 1
d3979 1
a3979 1
	case SPPPIOGDEFS:
d3996 1
a3996 1
	case SPPPIOSDEFS:
@


1.8
log
@Minor bug. Could corrupt stat counters
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.7 2001/03/22 01:42:35 mickey Exp $	*/
d642 3
a644 2
	struct ifqueue *ifq;
	int s, rv = 0;
d666 6
a671 1
	ifq = &ifp->if_snd;
d791 17
a807 3
	if (IF_QFULL (ifq)) {
		IF_DROP (&ifp->if_snd);
		m_freem (m);
d810 1
a810 1
		return (rv? rv: ENOBUFS);
d812 1
a812 1
	IF_ENQUEUE (ifq, m);
d821 1
a821 1
	ifp->if_obytes += m->m_pkthdr.len + 3;
d846 1
a846 1
	sp->pp_if.if_snd.ifq_maxlen = 50;
d893 1
a893 1
	sppp_qflush (&sp->pp_if.if_snd);
d909 1
a909 1
		!sp->pp_if.if_snd.ifq_head;
d936 1
a936 1
			IF_DEQUEUE (&sp->pp_if.if_snd, m);
d959 1
a959 1
			m = sp->pp_if.if_snd.ifq_head;
@


1.7
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.7 2001/03/22 01:42:04 mickey Exp $	*/
d1169 1
d1174 2
a1175 1
	ifp->if_obytes += m->m_pkthdr.len + 3;
d1229 1
d1234 2
a1235 1
	ifp->if_obytes += m->m_pkthdr.len + 3;
d3780 1
d3785 2
a3786 1
	ifp->if_obytes += m->m_pkthdr.len + 3;
@


1.6
log
@Missing splx() calls in failure cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.5 2000/04/26 18:39:38 chris Exp $	*/
d52 1
d107 3
d263 3
d814 4
a817 1
		keepalive_ch =
a818 1
		timeout(sppp_keepalive, 0, hz * 10);
d1730 4
a1734 1
	timeout(cp->TO, (void *)sp, timo * sp->lcp.timeout);
d3300 4
a3303 1
		sp->ch[IDX_CHAP] =
a3304 1
		timeout(chap.TO, (void *)sp, i * hz);
d3571 4
a3575 1
		timeout(sppp_pap_my_TO, (void *)sp, sp->lcp.timeout);
d3849 4
a3852 1
	keepalive_ch =
a3853 1
	timeout(sppp_keepalive, 0, hz * 10);
@


1.5
log
@Cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.4 2000/03/03 00:54:57 todd Exp $	*/
d984 2
a985 1
		if (ifr->ifr_mtu < 128 || ifr->ifr_mtu > sp->lcp.their_mru)
d987 1
d993 2
a994 1
		if (*(short*)data < 128 || *(short*)data > sp->lcp.their_mru)
d996 1
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.3 1999/08/06 23:02:27 niklas Exp $	*/
a982 3
#ifndef ifr_mtu
#define ifr_mtu ifr_metric
#endif
@


1.3
log
@Fix an uninitialized variable bug.  Remove statics.
@
text
@d1 1
a20 1
 * $Id: if_spppsubr.c,v 1.2 1999/07/02 17:46:55 deraadt Exp $
@


1.3.4.1
log
@Sync with -current
@
text
@a0 1
/*	$OpenBSD$	*/
d20 1
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.8 2001/03/25 02:56:18 csapuntz Exp $	*/
a51 1
#include <sys/timeout.h>
a105 3
#elif defined(__OpenBSD__)
# define UNTIMEOUT(fun, arg, handle)	\
	timeout_del(&(handle))
a258 3
#if defined (__OpenBSD__)
static struct timeout keepalive_ch;
#endif
d807 1
a807 4
		keepalive_ch = timeout(sppp_keepalive, 0, hz * 10);
#elif defined(__OpenBSD__)
		timeout_set(&keepalive_ch, sppp_keepalive, NULL);
		timeout_add(&keepalive_ch, hz * 10);
d809 1
d983 3
d987 1
a987 2
		if (ifr->ifr_mtu < 128 || ifr->ifr_mtu > sp->lcp.their_mru) {
			splx(s);
a988 1
		}
d994 1
a994 2
		if (*(short*)data < 128 || *(short*)data > sp->lcp.their_mru) {
			splx(s);
a995 1
		}
a1158 1
		m = NULL;
d1163 1
a1163 2
	if (m != NULL)
		ifp->if_obytes += m->m_pkthdr.len + 3;
a1216 1
		m = NULL;
d1221 1
a1221 2
	if (m != NULL)
		ifp->if_obytes += m->m_pkthdr.len + 3;
a1719 4
	    timeout(cp->TO, (void *)sp, timo * sp->lcp.timeout);
#elif defined(__OpenBSD__)
	timeout_set(&sp->ch[cp->protoidx], cp->TO, (void *)sp);
	timeout_add(&sp->ch[cp->protoidx], timo * sp->lcp.timeout);
d1721 1
d3287 1
a3287 4
		sp->ch[IDX_CHAP] = timeout(chap.TO, (void *)sp, i * hz);
#elif defined(__OpenBSD__)
		timeout_set(&sp->ch[IDX_CHAP], chap.TO, (void *)sp);
		timeout_add(&sp->ch[IDX_CHAP], i * hz);
d3289 1
a3555 4
		    timeout(sppp_pap_my_TO, (void *)sp, sp->lcp.timeout);
#elif defined (__OpenBSD__)
		timeout_set(&sp->pap_my_to_ch, sppp_pap_my_TO, (void *)sp);
		timeout_add(&sp->pap_my_to_ch, sp->lcp.timeout);
d3557 1
a3757 1
		m = NULL;
d3762 1
a3762 2
	if (m != NULL)
		ifp->if_obytes += m->m_pkthdr.len + 3;
d3831 1
a3831 4
	keepalive_ch = timeout(sppp_keepalive, 0, hz * 10);
#endif
#if defined (__OpenBSD__)
	timeout_add(&keepalive_ch, hz * 10);
d3833 1
@


1.3.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.3.4.2 2001/05/14 22:40:01 niklas Exp $	*/
d642 2
a643 3
	struct ifqueue *ifq = NULL;
	int s, len, rv = 0;
	ALTQ_DECL(struct altq_pktattr pktattr;)
d665 1
a665 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d785 3
a787 17
	len = m->m_pkthdr.len;
	if (ifq != NULL
#ifdef ALTQ
	    && ALTQ_IS_ENABLED(&ifp->if_snd) == 0
#endif
		) {
		if (IF_QFULL (ifq)) {
			IF_DROP (&ifp->if_snd);
			m_freem (m);
			if (rv == 0)
				rv = ENOBUFS;
		}
		IF_ENQUEUE (ifq, m);
	}
	else
		IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, rv);
	if (rv != 0) {
d790 1
a790 1
		return (rv);
d792 1
a792 1

d801 1
a801 1
	ifp->if_obytes += len + 3;
d826 1
a826 1
	IFQ_SET_MAXLEN(&sp->pp_if.if_snd, 50);
d873 1
a873 1
	IFQ_PURGE(&sp->pp_if.if_snd);
d889 1
a889 1
		IFQ_IS_EMPTY(&sp->pp_if.if_snd);
d916 1
a916 1
			IFQ_DEQUEUE (&sp->pp_if.if_snd, m);
d939 1
a939 1
			IFQ_POLL(&sp->pp_if.if_snd, m);
@


1.3.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.3.4.3 2001/07/04 10:54:07 niklas Exp $	*/
a1626 1
		break;
a1662 1
		break;
d3977 1
a3977 1
	case (int)SPPPIOGDEFS:
d3994 1
a3994 1
	case (int)SPPPIOSDEFS:
@


1.3.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d706 4
a709 4
	    	     (ip->ip_p == IPPROTO_TCP &&
	    	      m->m_len >= sizeof (struct ip) + sizeof (struct tcphdr) &&
	    	      (INTERACTIVE (ntohs (tcp->th_sport)) ||
	    	       INTERACTIVE (ntohs (tcp->th_dport))))))
d3906 3
a3908 2
	si = 0;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list)
a3909 1
	{
a3915 1
	}
d3952 3
a3954 2
	si = 0;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list)
@


1.3.4.6
log
@Merge in -current from roughly a week ago
@
text
@d804 2
a805 1
	} else
@


1.3.4.7
log
@Sync the SMP branch with 3.3
@
text
@d12 2
a13 7
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
d15 5
a19 11
 * THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT ``AS IS'' AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   
 * POSSIBILITY OF SUCH DAMAGE.
a20 1
 * From: Version 2.6, Tue May 12 17:10:39 MSD 1998
d644 1
d666 6
d698 1
a698 1
				return (EADDRNOTAVAIL);
d700 1
a700 1
				return (0);
d805 1
a805 1
		IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);
@


1.3.4.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_spppsubr.c,v 1.3.4.7 2003/03/28 00:41:28 niklas Exp $	*/
d4112 1
a4112 1
	snprintf (buf, sizeof buf, "0x%x", type);
d4135 1
a4135 1
	snprintf (buf, sizeof buf, "0x%x", type);
d4152 1
a4152 1
	snprintf (buf, sizeof buf, "0x%x", opt);
d4165 1
a4165 1
	snprintf (buf, sizeof buf, "0x%x", opt);
d4210 1
a4210 1
	snprintf(buf, sizeof buf, "0x%x", (unsigned)proto);
d4243 1
a4243 1
	snprintf(s, sizeof s, "%d.%d.%d.%d",
@


1.3.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
#include <sys/stdarg.h>
@


1.3.4.10
log
@Merge with the trunk
@
text
@d65 1
a65 1
#include <crypto/md5.h>
a638 2
		if (!inq->ifq_congestion)
			if_congestion(inq);
@


1.2
log
@do not use fuword()
@
text
@d20 1
a20 1
 * $Id: if_spppsubr.c,v 1.1 1999/07/01 23:10:40 deraadt Exp $
d37 6
d290 1
a290 1
static int sppp_output(struct ifnet *ifp, struct mbuf *m,
d293 2
a294 2
static void sppp_cisco_send(struct sppp *sp, int type, long par1, long par2);
static void sppp_cisco_input(struct sppp *sp, struct mbuf *m);
d296 1
a296 1
static void sppp_cp_input(const struct cp *cp, struct sppp *sp,
d298 1
a298 1
static void sppp_cp_send(struct sppp *sp, u_short proto, u_char type,
d301 1
a301 1
static void sppp_cp_timeout(void *arg);
d303 1
a303 1
static void sppp_cp_change_state(const struct cp *cp, struct sppp *sp,
d305 1
a305 1
static void sppp_auth_send(const struct cp *cp,
d309 71
a379 70
static void sppp_up_event(const struct cp *cp, struct sppp *sp);
static void sppp_down_event(const struct cp *cp, struct sppp *sp);
static void sppp_open_event(const struct cp *cp, struct sppp *sp);
static void sppp_close_event(const struct cp *cp, struct sppp *sp);
static void sppp_to_event(const struct cp *cp, struct sppp *sp);

static void sppp_null(struct sppp *sp);

static void sppp_lcp_init(struct sppp *sp);
static void sppp_lcp_up(struct sppp *sp);
static void sppp_lcp_down(struct sppp *sp);
static void sppp_lcp_open(struct sppp *sp);
static void sppp_lcp_close(struct sppp *sp);
static void sppp_lcp_TO(void *sp);
static int sppp_lcp_RCR(struct sppp *sp, struct lcp_header *h, int len);
static void sppp_lcp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len);
static void sppp_lcp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len);
static void sppp_lcp_tlu(struct sppp *sp);
static void sppp_lcp_tld(struct sppp *sp);
static void sppp_lcp_tls(struct sppp *sp);
static void sppp_lcp_tlf(struct sppp *sp);
static void sppp_lcp_scr(struct sppp *sp);
static void sppp_lcp_check_and_close(struct sppp *sp);
static int sppp_ncp_check(struct sppp *sp);

static void sppp_ipcp_init(struct sppp *sp);
static void sppp_ipcp_up(struct sppp *sp);
static void sppp_ipcp_down(struct sppp *sp);
static void sppp_ipcp_open(struct sppp *sp);
static void sppp_ipcp_close(struct sppp *sp);
static void sppp_ipcp_TO(void *sp);
static int sppp_ipcp_RCR(struct sppp *sp, struct lcp_header *h, int len);
static void sppp_ipcp_RCN_rej(struct sppp *sp, struct lcp_header *h, int len);
static void sppp_ipcp_RCN_nak(struct sppp *sp, struct lcp_header *h, int len);
static void sppp_ipcp_tlu(struct sppp *sp);
static void sppp_ipcp_tld(struct sppp *sp);
static void sppp_ipcp_tls(struct sppp *sp);
static void sppp_ipcp_tlf(struct sppp *sp);
static void sppp_ipcp_scr(struct sppp *sp);

static void sppp_pap_input(struct sppp *sp, struct mbuf *m);
static void sppp_pap_init(struct sppp *sp);
static void sppp_pap_open(struct sppp *sp);
static void sppp_pap_close(struct sppp *sp);
static void sppp_pap_TO(void *sp);
static void sppp_pap_my_TO(void *sp);
static void sppp_pap_tlu(struct sppp *sp);
static void sppp_pap_tld(struct sppp *sp);
static void sppp_pap_scr(struct sppp *sp);

static void sppp_chap_input(struct sppp *sp, struct mbuf *m);
static void sppp_chap_init(struct sppp *sp);
static void sppp_chap_open(struct sppp *sp);
static void sppp_chap_close(struct sppp *sp);
static void sppp_chap_TO(void *sp);
static void sppp_chap_tlu(struct sppp *sp);
static void sppp_chap_tld(struct sppp *sp);
static void sppp_chap_scr(struct sppp *sp);

static const char *sppp_auth_type_name(u_short proto, u_char type);
static const char *sppp_cp_type_name(u_char type);
static const char *sppp_dotted_quad(u_long addr);
static const char *sppp_ipcp_opt_name(u_char opt);
static const char *sppp_lcp_opt_name(u_char opt);
static const char *sppp_phase_name(enum ppp_phase phase);
static const char *sppp_proto_name(u_short proto);
static const char *sppp_state_name(int state);
static int sppp_params(struct sppp *sp, u_long cmd, void *data);
static int sppp_strnlen(u_char *p, int max);
static void sppp_get_ip_addrs(struct sppp *sp, u_long *src, u_long *dst,
d381 6
a386 6
static void sppp_keepalive(void *dummy);
static void sppp_phase_network(struct sppp *sp);
static void sppp_print_bytes(const u_char *p, u_short len);
static void sppp_print_string(const char *p, u_short len);
static void sppp_qflush(struct ifqueue *ifq);
static void sppp_set_ip_addr(struct sppp *sp, u_long src);
d629 1
a629 1
static int
d1033 1
a1033 1
static void
d1107 1
a1107 1
static void
d1173 1
a1173 1
static void
d1227 1
a1227 1
static void
d1570 1
a1570 1
static void
d1596 1
a1596 1
static void
d1633 1
a1633 1
static void
d1669 1
a1669 1
static void
d1710 1
a1710 1
static void
d1724 1
a1724 1
static void
d1819 1
a1819 1
static void
d1845 1
a1845 1
static void
d1877 1
a1877 1
static void
d1894 1
a1894 1
static void
d1908 1
a1908 1
static void
d1914 1
a1914 1
static void
d1926 1
a1926 1
static int
d2136 1
a2136 1
static void
d2199 1
a2199 1
static void
d2279 1
a2279 1
static void
d2335 1
a2335 1
static void
d2360 1
a2360 1
static void
d2375 1
a2375 1
static void
d2389 1
a2389 1
static void
d2435 1
a2435 1
static int
d2450 1
a2450 1
static void
d2471 1
a2471 1
static void
d2483 1
a2483 1
static void
d2489 1
a2489 1
static void
d2495 1
a2495 1
static void
d2527 1
a2527 1
static void
d2538 1
a2538 1
static void
d2550 1
a2550 1
static int
d2716 1
a2716 1
static void
d2761 1
a2761 1
static void
d2824 1
a2824 1
static void
d2829 1
a2829 1
static void
d2834 1
a2834 1
static void
d2841 1
a2841 1
static void
d2849 1
a2849 1
static void
d3194 1
a3194 1
static void
d3205 1
a3205 1
static void
d3218 1
a3218 1
static void
d3225 1
a3225 1
static void
d3264 1
a3264 1
static void
d3326 1
a3326 1
static void
d3339 1
a3339 1
static void
d3387 1
a3387 1
static void
d3530 1
a3530 1
static void
d3542 1
a3542 1
static void
d3561 1
a3561 1
static void
d3572 1
a3572 1
static void
d3611 1
a3611 1
static void
d3624 1
a3624 1
static void
d3653 1
a3653 1
static void
d3667 1
a3667 1
static void
d3695 1
a3695 1
static void
d3768 1
a3768 1
static void
d3786 1
a3786 1
static void
d3839 1
a3839 1
static void
d3887 1
a3887 1
static void
d3921 1
a3921 1
static int
a3923 1
	u_long subcmd;
d3930 1
a3930 1
	switch (subcmd) {
d4016 1
a4016 1
static void
d4043 1
a4043 1
static const char *
d4064 1
a4064 1
static const char *
d4087 1
a4087 1
static const char *
d4104 1
a4104 1
static const char *
d4117 1
a4117 1
static const char *
d4135 1
a4135 1
static const char *
d4148 1
a4148 1
static const char *
d4162 1
a4162 1
static void
d4170 1
a4170 1
static void
d4187 1
a4187 1
static const char *
d4199 1
a4199 1
static int
d4210 1
a4210 1
static void
@


1.1
log
@lmc driver; ported by chris@@dqc.org
@
text
@d20 1
a20 1
 * $Id: if_spppsubr.c,v 1.45 1998/10/06 21:12:45 joerg Exp $
a3919 8

	/*
	 * ifr->ifr_data is supposed to point to a struct spppreq.
	 * Check the cmd word first before attempting to fetch all the
	 * data.
	 */
	if ((subcmd = fuword(ifr->ifr_data)) == -1)
		return EFAULT;
@

