head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.10
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.9;
commitid	F6oNrr9LCLUSAxgA;

1.9
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.8;
commitid	VyLWTsbepAOk7VQM;

1.8
date	2016.11.29.10.09.57;	author reyk;	state Exp;
branches;
next	1.7;
commitid	KGFiK26819ueNC3N;

1.7
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.6;
commitid	Xo6g1xk26RWDGcjJ;

1.6
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.5;
commitid	ILbVM1M3uPNjwswz;

1.5
date	2015.10.30.12.54.36;	author reyk;	state Exp;
branches;
next	1.4;
commitid	suP3B6WRHhMgnRWI;

1.4
date	2015.10.25.12.59.57;	author mpi;	state Exp;
branches;
next	1.3;
commitid	Bszh1FAAPADDCr4p;

1.3
date	2015.10.25.12.05.40;	author mpi;	state Exp;
branches;
next	1.2;
commitid	iXTa9MhdGfWGiTE6;

1.2
date	2015.10.24.11.01.39;	author reyk;	state Exp;
branches;
next	1.1;
commitid	tZlLDryo5maQFhUe;

1.1
date	2015.10.24.10.52.05;	author reyk;	state Exp;
branches;
next	;
commitid	PvSfHvj4AhI0uuuE;


desc
@@


1.10
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@/*	$OpenBSD: if_pair.c,v 1.9 2017/01/22 10:17:39 dlg Exp $	*/

/*
 * Copyright (c) 2015 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2009 Theo de Raadt <deraadt@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

void	pairattach(int);
int	pairioctl(struct ifnet *, u_long, caddr_t);
void	pairstart(struct ifnet *);
int	pair_clone_create(struct if_clone *, int);
int	pair_clone_destroy(struct ifnet *);
int	pair_media_change(struct ifnet *);
void	pair_media_status(struct ifnet *, struct ifmediareq *);
void	pair_link_state(struct ifnet *);

struct pair_softc {
	struct arpcom		sc_ac;
	struct ifmedia		sc_media;
	unsigned int		sc_pairedif;
};

struct if_clone	pair_cloner =
    IF_CLONE_INITIALIZER("pair", pair_clone_create, pair_clone_destroy);

int
pair_media_change(struct ifnet *ifp)
{
	return (0);
}

void
pair_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct pair_softc	*sc = ifp->if_softc;
	struct ifnet		*pairedifp;

	imr->ifm_active = IFM_ETHER | IFM_AUTO;

	if ((pairedifp = if_get(sc->sc_pairedif)) == NULL) {
		imr->ifm_status = 0;
		return;
	}
	if_put(pairedifp);

	imr->ifm_status = IFM_AVALID | IFM_ACTIVE;
}

void
pair_link_state(struct ifnet *ifp)
{
	struct pair_softc	*sc = ifp->if_softc;
	struct ifnet		*pairedifp;
	unsigned int		 link_state;

	/* The pair state is determined by the paired interface */
	if ((pairedifp = if_get(sc->sc_pairedif)) != NULL) {
		link_state = LINK_STATE_UP;
		if_put(pairedifp);
	} else
		link_state = LINK_STATE_DOWN;

	if (ifp->if_link_state != link_state) {
		ifp->if_link_state = link_state;
		if_link_state_change(ifp);
	}
}

void
pairattach(int npair)
{
	if_clone_attach(&pair_cloner);
}

int
pair_clone_create(struct if_clone *ifc, int unit)
{
	struct ifnet		*ifp;
	struct pair_softc	*sc;

	if ((sc = malloc(sizeof(*sc),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	ifp = &sc->sc_ac.ac_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "pair%d", unit);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ether_fakeaddr(ifp);

	ifp->if_softc = sc;
	ifp->if_ioctl = pairioctl;
	ifp->if_start = pairstart;
	ifp->if_xflags = IFXF_CLONED;
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	ifp->if_hardmtu = ETHER_MAX_HARDMTU_LEN;
	ifp->if_capabilities = IFCAP_VLAN_MTU;

	ifmedia_init(&sc->sc_media, 0, pair_media_change,
	    pair_media_status);
	ifmedia_add(&sc->sc_media, IFM_ETHER | IFM_AUTO, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER | IFM_AUTO);

	if_attach(ifp);
	ether_ifattach(ifp);

	pair_link_state(ifp);

	return (0);
}

int
pair_clone_destroy(struct ifnet *ifp)
{
	struct pair_softc	*sc = ifp->if_softc;
	struct ifnet		*pairedifp;
	struct pair_softc	*dstsc = ifp->if_softc;

	if ((pairedifp = if_get(sc->sc_pairedif)) != NULL) {
		dstsc = pairedifp->if_softc;
		dstsc->sc_pairedif = 0;
		pair_link_state(pairedifp);
		if_put(pairedifp);
	}

	ifmedia_delete_instance(&sc->sc_media, IFM_INST_ANY);
	ether_ifdetach(ifp);
	if_detach(ifp);
	free(sc, M_DEVBUF, sizeof(*sc));

	return (0);
}

void
pairstart(struct ifnet *ifp)
{
	struct pair_softc	*sc = (struct pair_softc *)ifp->if_softc;
	struct mbuf_list	 ml = MBUF_LIST_INITIALIZER();
	struct ifnet		*pairedifp;
	struct mbuf		*m;

	pairedifp = if_get(sc->sc_pairedif);

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif /* NBPFILTER > 0 */

		if (pairedifp != NULL) {
			if (m->m_flags & M_PKTHDR)
				m_resethdr(m);
			ml_enqueue(&ml, m);
		} else
			m_freem(m);
	}

	if (pairedifp != NULL) {
		if_input(pairedifp, &ml);
		if_put(pairedifp);
	}
}

int
pairioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct pair_softc	*sc = (struct pair_softc *)ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	struct if_clone		*ifc;
	struct pair_softc	*pairedsc = ifp->if_softc;
	struct ifnet		*oldifp = NULL, *newifp = NULL;
	int			 error = 0, unit;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP)
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	case SIOCSIFPAIR:
		if (sc->sc_pairedif == ifr->ifr_index)
			break;

		/* Cannot link to myself */
		if (ifr->ifr_index == ifp->if_index) {
			error = EINVAL;
			break;
		}

		oldifp = if_get(sc->sc_pairedif);
		newifp = if_get(ifr->ifr_index);

		if (newifp != NULL) {
			pairedsc = newifp->if_softc;

			if (pairedsc->sc_pairedif != 0) {
				error = EBUSY;
				break;
			}

			/* Only allow pair(4) interfaces for the pair */
			if ((ifc = if_clone_lookup(newifp->if_xname,
			    &unit)) == NULL || strcmp("pair",
			    ifc->ifc_name) != 0) {
				error = ENODEV;
				break;
			}

			pairedsc->sc_pairedif = ifp->if_index;
			sc->sc_pairedif = ifr->ifr_index;
		} else
			sc->sc_pairedif = 0;

		if (oldifp != NULL) {
			pairedsc = oldifp->if_softc;
			pairedsc->sc_pairedif = 0;
		}
		break;

	case SIOCGIFPAIR:
		ifr->ifr_index = sc->sc_pairedif;
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}

	if (newifp != NULL || oldifp != NULL)
		pair_link_state(ifp);
	if (oldifp != NULL) {
		pair_link_state(oldifp);
		if_put(oldifp);
	}
	if (newifp != NULL) {
		pair_link_state(newifp);
		if_put(newifp);
	}

	return (error);
}
@


1.9
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pair.c,v 1.8 2016/11/29 10:09:57 reyk Exp $	*/
d123 1
@


1.8
log
@For virtual Ethernet drivers that don't have a technical limit of the
hardmtu, pick a value of 65435 that leaves space for some
encapsulation and almost a complete max-IP packet.  After some
discussion we picked this arbitrary value.

OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pair.c,v 1.7 2016/04/13 11:41:15 mpi Exp $	*/
a182 1
		ifp->if_opackets++;
@


1.7
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pair.c,v 1.6 2015/12/05 10:07:55 tedu Exp $	*/
d125 1
a125 1
	ifp->if_hardmtu = 0xffff;
@


1.6
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pair.c,v 1.5 2015/10/30 12:54:36 reyk Exp $	*/
a123 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.5
log
@Add m_resethdr() to clear any state (pf, tags, flags) of an mbuf packet.
Start using it in pair(4) to clear state on the receiving interface;
m_resethdr() will also be used in other parts of the stack.

OK bluhm@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pair.c,v 1.4 2015/10/25 12:59:57 mpi Exp $	*/
a198 1
/* ARGSUSED */
@


1.4
log
@ifa is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pair.c,v 1.3 2015/10/25 12:05:40 mpi Exp $	*/
d185 3
a187 1
		if (pairedifp != NULL)
d189 1
a189 1
		else
@


1.3
log
@arp_ifinit() is no longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pair.c,v 1.2 2015/10/24 11:01:39 reyk Exp $	*/
a201 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
@


1.2
log
@Remove superfluous assignment.

Pointed out by and OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pair.c,v 1.1 2015/10/24 10:52:05 reyk Exp $	*/
a211 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.1
log
@Add pair(4), a vether-based virtual Ethernet driver to interconnect
rdomains and bridges on the local system.  This can be used to route
through local rdomains, to create L2 devices (like trunks) between
them, and many other things.

Discussed with many, with input from mpi@@
OK sthen@@ phessler@@ yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a260 1
			pairedsc = newifp->if_softc;
@

