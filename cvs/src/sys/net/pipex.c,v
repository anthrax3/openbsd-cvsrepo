head	1.93;
access;
symbols
	OPENBSD_6_1:1.92.0.4
	OPENBSD_6_1_BASE:1.92
	OPENBSD_6_0:1.87.0.4
	OPENBSD_6_0_BASE:1.87
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.93
date	2017.04.18.01.24.47;	author yasuoka;	state Exp;
branches;
next	1.92;
commitid	OcXOcwgnmdCa9kXD;

1.92
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.91;
commitid	6c6qq5OdS4VVnyVM;

1.91
date	2016.12.19.15.51.53;	author mpi;	state Exp;
branches;
next	1.90;
commitid	idBp6KgOT2Unmfdr;

1.90
date	2016.11.18.02.53.47;	author dlg;	state Exp;
branches;
next	1.89;
commitid	VkivwyRVzetroSYM;

1.89
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.88;
commitid	RlO92XR575sygHqm;

1.88
date	2016.08.30.23.29.04;	author dlg;	state Exp;
branches;
next	1.87;
commitid	YJI4ctrYXdTqMdq4;

1.87
date	2016.03.22.23.53.01;	author dlg;	state Exp;
branches;
next	1.86;
commitid	0UJ2lURKb5Y3g6Hz;

1.86
date	2016.03.22.23.51.01;	author dlg;	state Exp;
branches;
next	1.85;
commitid	6iC86Zox1RxQgKoy;

1.85
date	2016.03.04.22.38.23;	author sashan;	state Exp;
branches;
next	1.84;
commitid	7fajBfMUpKRTskMd;

1.84
date	2015.11.03.21.33.56;	author chl;	state Exp;
branches;
next	1.83;
commitid	g9MGNg3Hr2jmY81S;

1.83
date	2015.10.07.10.50.35;	author mpi;	state Exp;
branches;
next	1.82;
commitid	hPrd2a6fiZdlN2yP;

1.82
date	2015.10.05.06.51.50;	author yasuoka;	state Exp;
branches;
next	1.81;
commitid	6KcAI5O6NqISSIJX;

1.81
date	2015.09.22.10.09.19;	author mpi;	state Exp;
branches;
next	1.80;
commitid	ABoJoE2FOB5ENPkT;

1.80
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.79;
commitid	zZXiESHR0g5lNO0l;

1.79
date	2015.09.12.20.26.07;	author mpi;	state Exp;
branches;
next	1.78;
commitid	UM7jfgLT8vWQUBm1;

1.78
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.77;
commitid	Cr0DVA7exR1t2zXg;

1.77
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.76;
commitid	sTEWfQrcV5GjIWc0;

1.76
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.75;
commitid	PcRGyy4jlpJbKkXz;

1.75
date	2015.09.04.08.43.39;	author mpi;	state Exp;
branches;
next	1.74;
commitid	qAevExm24QrBjVNL;

1.74
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.73;
commitid	RRi5waWu1LaKRicG;

1.73
date	2015.08.24.14.00.28;	author bluhm;	state Exp;
branches;
next	1.72;
commitid	0LcoZC9QTu9wgpyX;

1.72
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.71;
commitid	STtcOm1B3VSMXz2h;

1.71
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	ncpqEGjDtSFuLAgn;

1.70
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.69;
commitid	h7z8lokZ0dFyuWpg;

1.69
date	2015.04.23.09.45.24;	author dlg;	state Exp;
branches;
next	1.68;
commitid	BpkIGymqTMK3ZEHF;

1.68
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.67;
commitid	c7ei8kPelCOOwHXy;

1.67
date	2015.04.10.11.02.12;	author dlg;	state Exp;
branches;
next	1.66;
commitid	Yo2S19U4e5J9njNu;

1.66
date	2015.03.18.12.23.15;	author dlg;	state Exp;
branches;
next	1.65;
commitid	veRr3qZI7HBatTwk;

1.65
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.64;
commitid	zhW8jJrfVCoAthrR;

1.64
date	2014.12.01.06.55.05;	author yasuoka;	state Exp;
branches;
next	1.63;
commitid	J6mEszBKqi5g0A9d;

1.63
date	2014.11.20.14.51.42;	author krw;	state Exp;
branches;
next	1.62;
commitid	dOUqRDzYiPQXkCLL;

1.62
date	2014.11.04.15.24.40;	author mpi;	state Exp;
branches;
next	1.61;
commitid	7WMzGcppcCD2uLp0;

1.61
date	2014.10.28.09.45.37;	author yasuoka;	state Exp;
branches;
next	1.60;
commitid	TctvmuPt3poMHIbF;

1.60
date	2014.10.28.09.15.09;	author yasuoka;	state Exp;
branches;
next	1.59;
commitid	mLMAek7T1Q02TXz6;

1.59
date	2014.10.28.09.10.21;	author yasuoka;	state Exp;
branches;
next	1.58;
commitid	yZ4XwA2Yg0m3FKEZ;

1.58
date	2014.10.21.10.52.53;	author yasuoka;	state Exp;
branches;
next	1.57;
commitid	yUVe4HyafiEJIH3w;

1.57
date	2014.10.20.16.33.32;	author uebayasi;	state Exp;
branches;
next	1.56;
commitid	EjGBWsvJHqxzBj9m;

1.56
date	2014.10.18.19.28.02;	author uebayasi;	state Exp;
branches;
next	1.55;
commitid	WIpMMSXh5WqpgHAS;

1.55
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches
	1.55.4.1;
next	1.54;
commitid	DQakU8LLWV6Iwx84;

1.54
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.53;
commitid	B4dZSbxas1X1IpXI;

1.53
date	2014.06.13.06.47.09;	author yasuoka;	state Exp;
branches;
next	1.52;
commitid	E2dOxIJOcIu9vuZ1;

1.52
date	2014.06.13.06.44.11;	author yasuoka;	state Exp;
branches;
next	1.51;
commitid	l8R2vsYqc8buh8sF;

1.51
date	2014.06.13.06.35.58;	author yasuoka;	state Exp;
branches;
next	1.50;
commitid	QfBvDfn4t6LI6h2v;

1.50
date	2014.04.21.12.22.25;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2014.04.18.22.23.50;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches
	1.48.4.1;
next	1.47;

1.47
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.10.19.10.51.41;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2013.10.17.16.27.43;	author bluhm;	state Exp;
branches;
next	1.43;

1.43
date	2013.09.20.08.11.55;	author yasuoka;	state Exp;
branches;
next	1.42;

1.42
date	2013.06.08.14.24.38;	author yasuoka;	state Exp;
branches;
next	1.41;

1.41
date	2013.04.16.07.36.55;	author yasuoka;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2013.02.13.22.10.38;	author yasuoka;	state Exp;
branches;
next	1.37;

1.37
date	2012.12.14.01.19.26;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2012.12.13.06.59.36;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2012.09.28.16.09.05;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2012.09.19.22.37.23;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2012.09.19.17.50.17;	author yasuoka;	state Exp;
branches;
next	1.32;

1.32
date	2012.09.10.07.20.58;	author yasuoka;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.10.07.14.33;	author yasuoka;	state Exp;
branches;
next	1.30;

1.30
date	2012.07.17.03.18.57;	author yasuoka;	state Exp;
branches;
next	1.29;

1.29
date	2012.05.05.14.48.51;	author yasuoka;	state Exp;
branches;
next	1.28;

1.28
date	2012.04.22.15.27.24;	author yasuoka;	state Exp;
branches;
next	1.27;

1.27
date	2012.04.04.04.31.38;	author yasuoka;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.31.12.04.20;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.23.03.36.21;	author yasuoka;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.18.02.02.53;	author yasuoka;	state Exp;
branches;
next	1.23;

1.23
date	2011.11.25.13.05.06;	author yasuoka;	state Exp;
branches;
next	1.22;

1.22
date	2011.10.15.03.24.11;	author yasuoka;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.09.04.11.15;	author dhill;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.08.19.34.04;	author yasuoka;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.08.18.30.17;	author yasuoka;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.07.22.32.51;	author mcbride;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2011.03.14.06.53.33;	author yasuoka;	state Exp;
branches;
next	1.15;

1.15
date	2011.02.24.04.21.34;	author yasuoka;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.28.06.43.00;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.29.22.15.54;	author yasuoka;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.28.14.14.54;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.26.07.04.43;	author yasuoka;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.14.50.30;	author hsuenaga;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.22.13.03.48;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.21.07.44.54;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.09.08.36.31;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.08.08.40.29;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.03.00.16.07;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.13.07.23.38;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.06.05.47;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.03.50.56;	author yasuoka;	state Exp;
branches;
next	;

1.48.4.1
date	2014.12.01.06.59.03;	author yasuoka;	state Exp;
branches;
next	;
commitid	0ySGdQmz0Su3q2qP;

1.55.4.1
date	2014.12.01.06.57.33;	author yasuoka;	state Exp;
branches;
next	;
commitid	osz9lx24s4ChW0bH;


desc
@@


1.93
log
@Fix pipex(4) not to cause panics on strict alignment architectures.

ok claudio
@
text
@/*	$OpenBSD: pipex.c,v 1.92 2017/01/24 10:08:30 krw Exp $	*/

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/sysctl.h>
#include <sys/syslog.h>
#include <sys/conf.h>
#include <sys/time.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/pool.h>

#include <net/if.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/if_dl.h>

#include <net/radix.h>
#include <net/route.h>
#include <net/netisr.h>
#include <net/ppp_defs.h>
#include <net/ppp-comp.h>

#include "pf.h"
#if NPF > 0
#include <net/pfvar.h>
#endif

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/ip.h>
#include <netinet/ip_var.h>
#ifdef INET6
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <crypto/arc4.h>

/* drop static for ddb debuggability */
#define	Static

#include <net/pipex.h>
#include "pipex_local.h"

struct pool pipex_session_pool;
struct pool mppe_key_pool;

/*
 * static/global variables
 */
int	pipex_enable = 0;
struct pipex_hash_head
    pipex_session_list,				/* master session list */
    pipex_close_wait_list,			/* expired session list */
    pipex_peer_addr_hashtable[PIPEX_HASH_SIZE],	/* peer's address hash */
    pipex_id_hashtable[PIPEX_HASH_SIZE];	/* peer id hash */

struct radix_node_head pipex_rd_head4;
struct radix_node_head pipex_rd_head6;
int pipex_rd_head4_initialized;
int pipex_rd_head6_initialized;
struct timeout pipex_timer_ch;		/* callout timer context */
int pipex_prune = 1;			/* walk list every seconds */

/* pipex traffic queue */
struct mbuf_queue pipexinq = MBUF_QUEUE_INITIALIZER(IFQ_MAXLEN, IPL_NET);
struct mbuf_queue pipexoutq = MBUF_QUEUE_INITIALIZER(IFQ_MAXLEN, IPL_NET);
void *pipex_softintr = NULL;
Static void pipex_softintr_handler(void *);

/* borrow an mbuf pkthdr field */
#define ph_ppp_proto ether_vtag

/* from udp_usrreq.c */
extern int udpcksum;

#ifdef PIPEX_DEBUG
int pipex_debug = 0;		/* systcl net.inet.ip.pipex_debug */
#endif

/* PPP compression == MPPE is assumed, so don't answer CCP Reset-Request. */
#define PIPEX_NO_CCP_RESETACK	1

/************************************************************************
 * Core functions
 ************************************************************************/
void
pipex_init(void)
{
	int		 i;

	if (pipex_softintr != NULL)
		return;

	rn_init(sizeof(struct sockaddr_in6));

	pool_init(&pipex_session_pool, sizeof(struct pipex_session), 0,
	    IPL_NONE, PR_WAITOK, "ppxss", NULL);
	pool_init(&mppe_key_pool, PIPEX_MPPE_KEYLEN * PIPEX_MPPE_NOLDKEY, 0,
	    IPL_NONE, PR_WAITOK, "mppekey", NULL);

	LIST_INIT(&pipex_session_list);
	LIST_INIT(&pipex_close_wait_list);

	for (i = 0; i < nitems(pipex_id_hashtable); i++)
		LIST_INIT(&pipex_id_hashtable[i]);
	for (i = 0; i < nitems(pipex_peer_addr_hashtable); i++)
		LIST_INIT(&pipex_peer_addr_hashtable[i]);
	/* softintr init */
	pipex_softintr =
	    softintr_establish(IPL_SOFTNET, pipex_softintr_handler, NULL);
}

void
pipex_iface_init(struct pipex_iface_context *pipex_iface, struct ifnet *ifp)
{
	int s;
	struct pipex_session *session;

	pipex_iface->pipexmode = 0;
	pipex_iface->ifnet_this = ifp;

	s = splnet();
	if (!pipex_rd_head4_initialized) {
		pipex_rd_head4_initialized++;
		if (!rn_inithead0(&pipex_rd_head4,
		    offsetof(struct sockaddr_in, sin_addr)))
			panic("rn_inithead0() failed on pipex_init()");
	}
	if (!pipex_rd_head6_initialized) {
		pipex_rd_head6_initialized++;
		if (!rn_inithead0(&pipex_rd_head6,
		    offsetof(struct sockaddr_in6, sin6_addr)))
			panic("rn_inithead0() failed on pipex_init()");
	}
	splx(s);

	/* virtual pipex_session entry for multicast */
	session = pool_get(&pipex_session_pool, PR_WAITOK | PR_ZERO);
	session->is_multicast = 1;
	session->pipex_iface = pipex_iface;
	pipex_iface->multicast_session = session;
}

Static void
pipex_iface_start(struct pipex_iface_context *pipex_iface)
{
	pipex_iface->pipexmode = 1;
}

Static void
pipex_iface_stop(struct pipex_iface_context *pipex_iface)
{
	struct pipex_session *session;
	struct pipex_session *session_next;

	pipex_iface->pipexmode = 0;
	/*
	 * traversal all pipex sessions.
	 * it will become heavy if the number of pppac devices bocomes large.
	 */
	for (session = LIST_FIRST(&pipex_session_list);
	    session; session = session_next) {
		session_next = LIST_NEXT(session, session_list);
		if (session->pipex_iface == pipex_iface)
			pipex_destroy_session(session);
	}
}

void
pipex_iface_fini(struct pipex_iface_context *pipex_iface)
{
	int	 s;

	s = splnet();

	pool_put(&pipex_session_pool, pipex_iface->multicast_session);
	pipex_iface_stop(pipex_iface);

	splx(s);
}

/* called from tunioctl() with splnet() */
int
pipex_ioctl(struct pipex_iface_context *pipex_iface, u_long cmd, caddr_t data)
{
	int pipexmode, ret;

	switch (cmd) {
	case PIPEXSMODE:
		pipexmode = *(int *)data;
		if (pipex_iface->pipexmode != pipexmode) {
			if (pipexmode)
				pipex_iface_start(pipex_iface);
			else
				pipex_iface_stop(pipex_iface);
		}
		break;

	case PIPEXGMODE:
		*(int *)data = pipex_iface->pipexmode;
		break;

	case PIPEXASESSION:
		ret = pipex_add_session((struct pipex_session_req *)data,
		    pipex_iface);
		return (ret);

	case PIPEXDSESSION:
		ret = pipex_close_session(
		    (struct pipex_session_close_req *)data);
		return (ret);

	case PIPEXCSESSION:
		ret = pipex_config_session(
		    (struct pipex_session_config_req *)data);
		return (ret);

	case PIPEXGSTAT:
		ret = pipex_get_stat((struct pipex_session_stat_req *)data);
		return (ret);

	case PIPEXGCLOSED:
		ret = pipex_get_closed((struct pipex_session_list_req *)data);
		return (ret);

	default:
		return (ENOTTY);

	}
	return (0);
}

/************************************************************************
 * Session management functions
 ************************************************************************/
Static int
pipex_add_session(struct pipex_session_req *req,
    struct pipex_iface_context *iface)
{
	struct pipex_session *session;
	struct pipex_hash_head *chain;
	struct radix_node *rn;
	int s;
#ifdef PIPEX_PPPOE
	struct ifnet *over_ifp = NULL;
#endif

	/* Checks requeted parameters.  */
	if (!iface->pipexmode)
		return (ENXIO);
	switch (req->pr_protocol) {
#ifdef PIPEX_PPPOE
	case PIPEX_PROTO_PPPOE:
		over_ifp = ifunit(req->pr_proto.pppoe.over_ifname);
		if (over_ifp == NULL)
			return (EINVAL);
		if (req->pr_peer_address.ss_family != AF_UNSPEC)
			return (EINVAL);
		break;
#endif
#if defined(PIPEX_L2TP) || defined(PIPEX_PPTP)
#ifdef PIPEX_PPTP
	case PIPEX_PROTO_PPTP:
#endif
#ifdef PIPEX_L2TP
	case PIPEX_PROTO_L2TP:
#endif
		switch (req->pr_peer_address.ss_family) {
		case AF_INET:
			if (req->pr_peer_address.ss_len !=
			    sizeof(struct sockaddr_in))
				return (EINVAL);
			break;
#ifdef INET6
		case AF_INET6:
			if (req->pr_peer_address.ss_len !=
			    sizeof(struct sockaddr_in6))
				return (EINVAL);
			break;
#endif
		default:
			return (EPROTONOSUPPORT);
		}
		if (req->pr_peer_address.ss_family !=
		    req->pr_local_address.ss_family ||
		    req->pr_peer_address.ss_len !=
		    req->pr_local_address.ss_len)
			return (EINVAL);
		break;
#endif
	default:
		return (EPROTONOSUPPORT);
	}

	/* prepare a new session */
	session = pool_get(&pipex_session_pool, PR_WAITOK | PR_ZERO);
	session->state = PIPEX_STATE_OPENED;
	session->protocol = req->pr_protocol;
	session->session_id = req->pr_session_id;
	session->peer_session_id = req->pr_peer_session_id;
	session->peer_mru = req->pr_peer_mru;
	session->timeout_sec = req->pr_timeout_sec;
	session->pipex_iface = iface;
	session->ppp_flags = req->pr_ppp_flags;
	session->ppp_id = req->pr_ppp_id;

	session->ip_forward = 1;

	session->ip_address.sin_family = AF_INET;
	session->ip_address.sin_len = sizeof(struct sockaddr_in);
	session->ip_address.sin_addr = req->pr_ip_address;

	session->ip_netmask.sin_family = AF_INET;
	session->ip_netmask.sin_len = sizeof(struct sockaddr_in);
	session->ip_netmask.sin_addr = req->pr_ip_netmask;

	if (session->ip_netmask.sin_addr.s_addr == 0L)
		session->ip_netmask.sin_addr.s_addr = 0xffffffffL;
	session->ip_address.sin_addr.s_addr &=
	    session->ip_netmask.sin_addr.s_addr;

	if (req->pr_peer_address.ss_len > 0)
		memcpy(&session->peer, &req->pr_peer_address,
		    MIN(req->pr_peer_address.ss_len, sizeof(session->peer)));
	if (req->pr_local_address.ss_len > 0)
		memcpy(&session->local, &req->pr_local_address,
		    MIN(req->pr_local_address.ss_len, sizeof(session->local)));
#ifdef PIPEX_PPPOE
	if (req->pr_protocol == PIPEX_PROTO_PPPOE)
		session->proto.pppoe.over_ifp = over_ifp;
#endif
#ifdef PIPEX_PPTP
	if (req->pr_protocol == PIPEX_PROTO_PPTP) {
		struct pipex_pptp_session *sess_pptp = &session->proto.pptp;

		sess_pptp->snd_gap = 0;
		sess_pptp->rcv_gap = 0;
		sess_pptp->snd_una = req->pr_proto.pptp.snd_una;
		sess_pptp->snd_nxt = req->pr_proto.pptp.snd_nxt;
		sess_pptp->rcv_nxt = req->pr_proto.pptp.rcv_nxt;
		sess_pptp->rcv_acked = req->pr_proto.pptp.rcv_acked;

		sess_pptp->winsz = req->pr_proto.pptp.winsz;
		sess_pptp->maxwinsz = req->pr_proto.pptp.maxwinsz;
		sess_pptp->peer_maxwinsz = req->pr_proto.pptp.peer_maxwinsz;
		/* last ack number */
		sess_pptp->ul_snd_una = sess_pptp->snd_una - 1;
	}
#endif
#ifdef PIPEX_L2TP
	if (req->pr_protocol == PIPEX_PROTO_L2TP) {
		struct pipex_l2tp_session *sess_l2tp = &session->proto.l2tp;

		/* session keys */
		sess_l2tp->tunnel_id = req->pr_proto.l2tp.tunnel_id;
		sess_l2tp->peer_tunnel_id = req->pr_proto.l2tp.peer_tunnel_id;

		/* protocol options */
		sess_l2tp->option_flags = req->pr_proto.l2tp.option_flags;

		/* initial state of dynamic context */
		sess_l2tp->ns_gap = sess_l2tp->nr_gap = 0;
		sess_l2tp->ns_nxt = req->pr_proto.l2tp.ns_nxt;
		sess_l2tp->nr_nxt = req->pr_proto.l2tp.nr_nxt;
		sess_l2tp->ns_una = req->pr_proto.l2tp.ns_una;
		sess_l2tp->nr_acked = req->pr_proto.l2tp.nr_acked;
		/* last ack number */
		sess_l2tp->ul_ns_una = sess_l2tp->ns_una - 1;
		sess_l2tp->ipsecflowinfo = req->pr_proto.l2tp.ipsecflowinfo;
	}
#endif
#ifdef PIPEX_MPPE
	if ((req->pr_ppp_flags & PIPEX_PPP_MPPE_ACCEPTED) != 0) {
		if (req->pr_mppe_recv.keylenbits <= 0) {
			pool_put(&pipex_session_pool, session);
			return (EINVAL);
		}
		pipex_session_init_mppe_recv(session,
		    req->pr_mppe_recv.stateless, req->pr_mppe_recv.keylenbits,
		    req->pr_mppe_recv.master_key);
	}
	if ((req->pr_ppp_flags & PIPEX_PPP_MPPE_ENABLED) != 0) {
		if (req->pr_mppe_send.keylenbits <= 0) {
			pool_put(&pipex_session_pool, session);
			return (EINVAL);
		}
		pipex_session_init_mppe_send(session,
		    req->pr_mppe_send.stateless, req->pr_mppe_send.keylenbits,
		    req->pr_mppe_send.master_key);
	}

	if (pipex_session_is_mppe_required(session)) {
		if (!pipex_session_is_mppe_enabled(session) ||
		    !pipex_session_is_mppe_accepted(session)) {
			pool_put(&pipex_session_pool, session);
			return (EINVAL);
		}
	}
#endif

	/* commit the session */
	s = splnet();
	if (!in_nullhost(session->ip_address.sin_addr)) {
		if (pipex_lookup_by_ip_address(session->ip_address.sin_addr)
		    != NULL) {
			splx(s);
			pool_put(&pipex_session_pool, session);
			return (EADDRINUSE);
		}

		rn = rn_addroute(&session->ip_address, &session->ip_netmask,
		    &pipex_rd_head4, session->ps4_rn, RTP_STATIC);
		if (rn == NULL) {
			splx(s);
			pool_put(&pipex_session_pool, session);
			return (ENOMEM);
		}
	}
	if (0) { /* NOT YET */
		rn = rn_addroute(&session->ip6_address, &session->ip6_prefixlen,
		    &pipex_rd_head6, session->ps6_rn, RTP_STATIC);
		if (rn == NULL) {
			splx(s);
			pool_put(&pipex_session_pool, session);
			return (ENOMEM);
		}
	}

	chain = PIPEX_ID_HASHTABLE(session->session_id);
	LIST_INSERT_HEAD(chain, session, id_chain);
	LIST_INSERT_HEAD(&pipex_session_list, session, session_list);
	switch (req->pr_protocol) {
	case PIPEX_PROTO_PPTP:
	case PIPEX_PROTO_L2TP:
		chain = PIPEX_PEER_ADDR_HASHTABLE(
		    pipex_sockaddr_hash_key((struct sockaddr *)&session->peer));
		LIST_INSERT_HEAD(chain, session, peer_addr_chain);
	}

	/* if first session is added, start timer */
	if (LIST_NEXT(session, session_list) == NULL)
		pipex_timer_start();

	splx(s);

	pipex_session_log(session, LOG_INFO, "PIPEX is ready.");

	return (0);
}

int
pipex_notify_close_session(struct pipex_session *session)
{
	int s;

	s = splnet();
	session->state = PIPEX_STATE_CLOSE_WAIT;
	session->stat.idle_time = 0;
	LIST_INSERT_HEAD(&pipex_close_wait_list, session, state_list);
	splx(s);

	return (0);
}

int
pipex_notify_close_session_all(void)
{
	struct pipex_session *session;
	int s;

	s = splnet();
	LIST_FOREACH(session, &pipex_session_list, session_list)
		if (session->state == PIPEX_STATE_OPENED)
			pipex_notify_close_session(session);
	splx(s);

	return (0);
}

Static int
pipex_close_session(struct pipex_session_close_req *req)
{
	struct pipex_session *session;
	int s;

	s = splnet();
	session = pipex_lookup_by_session_id(req->pcr_protocol,
	    req->pcr_session_id);
	if (session == NULL) {
		splx(s);
		return (EINVAL);
	}

	/* remove from close_wait list */
	if (session->state == PIPEX_STATE_CLOSE_WAIT)
		LIST_REMOVE(session, state_list);

	/* get statistics before destroy the session */
	req->pcr_stat = session->stat;
	session->state = PIPEX_STATE_CLOSED;
	splx(s);

	return (0);
}

Static int
pipex_config_session(struct pipex_session_config_req *req)
{
	struct pipex_session *session;
	int s;

	s = splnet();
	session = pipex_lookup_by_session_id(req->pcr_protocol,
	    req->pcr_session_id);
	if (session == NULL) {
		splx(s);
		return (EINVAL);
	}
	session->ip_forward = req->pcr_ip_forward;
	splx(s);

	return (0);
}

Static int
pipex_get_stat(struct pipex_session_stat_req *req)
{
	struct pipex_session *session;
	int s;

	s = splnet();
	session = pipex_lookup_by_session_id(req->psr_protocol,
	    req->psr_session_id);
	if (session == NULL) {
		splx(s);
		return (EINVAL);
	}
	req->psr_stat = session->stat;
	splx(s);

	return (0);
}

Static int
pipex_get_closed(struct pipex_session_list_req *req)
{
	struct pipex_session *session;
	int s;

	s = splnet();
	bzero(req, sizeof(*req));
	while (!LIST_EMPTY(&pipex_close_wait_list)) {
		session = LIST_FIRST(&pipex_close_wait_list);
		req->plr_ppp_id[req->plr_ppp_id_count++] = session->ppp_id;
		LIST_REMOVE(session, state_list);
		session->state = PIPEX_STATE_CLOSE_WAIT2;
		if (req->plr_ppp_id_count >= PIPEX_MAX_LISTREQ) {
			if (!LIST_EMPTY(&pipex_close_wait_list))
				req->plr_flags |= PIPEX_LISTREQ_MORE;
			break;
		}
	}
	splx(s);

	return (0);
}

Static int
pipex_destroy_session(struct pipex_session *session)
{
	struct radix_node *rn;
	int s;

	/* remove from radix tree and hash chain */
	s = splnet();

	if (!in_nullhost(session->ip_address.sin_addr)) {
		rn = rn_delete(&session->ip_address, &session->ip_netmask,
		    &pipex_rd_head4, (struct radix_node *)session);
		KASSERT(rn != NULL);
	}

	LIST_REMOVE(session, id_chain);
	LIST_REMOVE(session, session_list);
#ifdef PIPEX_PPTP
	if (session->protocol == PIPEX_PROTO_PPTP) {
		LIST_REMOVE(session, peer_addr_chain);
	}
#endif
#ifdef PIPEX_L2TP
	if (session->protocol == PIPEX_PROTO_L2TP) {
		LIST_REMOVE(session, peer_addr_chain);
	}
#endif
	/* if final session is destroyed, stop timer */
	if (LIST_EMPTY(&pipex_session_list))
		pipex_timer_stop();

	splx(s);

	if (session->mppe_recv.old_session_keys)
		pool_put(&mppe_key_pool, session->mppe_recv.old_session_keys);
	pool_put(&pipex_session_pool, session);

	return (0);
}

Static struct pipex_session *
pipex_lookup_by_ip_address(struct in_addr addr)
{
	struct pipex_session *session;
	struct sockaddr_in pipex_in4, pipex_in4mask;

	bzero(&pipex_in4, sizeof(pipex_in4));
	pipex_in4.sin_addr = addr;
	pipex_in4.sin_family = AF_INET;
	pipex_in4.sin_len = sizeof(pipex_in4);

	bzero(&pipex_in4mask, sizeof(pipex_in4mask));
	pipex_in4mask.sin_addr.s_addr = htonl(0xFFFFFFFFL);
	pipex_in4mask.sin_family = AF_INET;
	pipex_in4mask.sin_len = sizeof(pipex_in4mask);

	session = (struct pipex_session *)rn_lookup(&pipex_in4, &pipex_in4mask,
	    &pipex_rd_head4);

#ifdef PIPEX_DEBUG
	if (session == NULL) {
		char buf[INET_ADDRSTRLEN];

		PIPEX_DBG((NULL, LOG_DEBUG, "<%s> session not found (addr=%s)",
		    __func__, inet_ntop(AF_INET, &addr, buf, sizeof(buf))));
	}
#endif

	return (session);
}

Static struct pipex_session *
pipex_lookup_by_session_id(int protocol, int session_id)
{
	struct pipex_hash_head *list;
	struct pipex_session *session;

	list = PIPEX_ID_HASHTABLE(session_id);
	LIST_FOREACH(session, list, id_chain) {
		if (session->protocol == protocol &&
		    session->session_id == session_id)
			break;
	}

#ifdef PIPEX_DEBUG
	if (session == NULL)
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> session not found (session_id=%d)", __func__,
		    session_id));
#endif

	return (session);
}

/***********************************************************************
 * Queue and Software Interrupt Handler
 ***********************************************************************/
Static void
pipex_softintr_handler(void *dummy)
{
	pipex_ppp_dequeue();
}

Static void
pipex_ppp_dequeue(void)
{
	struct pipex_session *pkt_session;
	u_int16_t proto;
	struct mbuf *m;
	struct mbuf_list ml;

	/* ppp output */
	mq_delist(&pipexoutq, &ml);
	while ((m = ml_dequeue(&ml)) != NULL) {
		pkt_session = m->m_pkthdr.ph_cookie;
		if (pkt_session == NULL) {
			m_freem(m);
			continue;
		}
		proto = m->m_pkthdr.ph_ppp_proto;

		m->m_pkthdr.ph_cookie = NULL;
		m->m_pkthdr.ph_ppp_proto = 0;

		if (pkt_session->is_multicast != 0) {
			struct pipex_session *session;
			struct mbuf *m0;

			LIST_FOREACH(session, &pipex_session_list,
			    session_list) {
				if (session->pipex_iface !=
				    pkt_session->pipex_iface)
					continue;
				if (session->ip_forward == 0 &&
				    session->ip6_forward == 0)
					continue;
				m0 = m_copym(m, 0, M_COPYALL, M_NOWAIT);
				if (m0 == NULL) {
					session->stat.oerrors++;
					continue;
				}
				pipex_ppp_output(m0, session, proto);
			}
			m_freem(m);
		} else
			pipex_ppp_output(m, pkt_session, proto);
	}

	/* ppp input */
	mq_delist(&pipexinq, &ml);
	while ((m = ml_dequeue(&ml)) != NULL) {
		pkt_session = m->m_pkthdr.ph_cookie;
		if (pkt_session == NULL) {
			m_freem(m);
			continue;
		}
		pipex_ppp_input(m, pkt_session, 0);
	}
}

Static int
pipex_ppp_enqueue(struct mbuf *m0, struct pipex_session *session,
    struct mbuf_queue *mq)
{
	m0->m_pkthdr.ph_cookie = session;
	/* XXX need to support other protocols */
	m0->m_pkthdr.ph_ppp_proto = PPP_IP;

	if (mq_enqueue(mq, m0) != 0)
		return (1);

	softintr_schedule(pipex_softintr);
	return (0);
}

/***********************************************************************
 * Timer functions
 ***********************************************************************/
Static void
pipex_timer_start(void)
{
	timeout_set(&pipex_timer_ch, pipex_timer, NULL);
	timeout_add_sec(&pipex_timer_ch, pipex_prune);
}

Static void
pipex_timer_stop(void)
{
	timeout_del(&pipex_timer_ch);
}

Static void
pipex_timer(void *ignored_arg)
{
	int s;
	struct pipex_session *session;
	struct pipex_session *session_next;

	s = splnet();
	timeout_add_sec(&pipex_timer_ch, pipex_prune);

	/* walk through */
	for (session = LIST_FIRST(&pipex_session_list); session;
	    session = session_next) {
		session_next = LIST_NEXT(session, session_list);
		switch (session->state) {
		case PIPEX_STATE_OPENED:
			if (session->timeout_sec == 0)
				continue;

			session->stat.idle_time++;
			if (session->stat.idle_time < session->timeout_sec)
				continue;

			pipex_notify_close_session(session);
			break;

		case PIPEX_STATE_CLOSE_WAIT:
		case PIPEX_STATE_CLOSE_WAIT2:
			/* Wait PIPEXDSESSION from userland */
			session->stat.idle_time++;
			if (session->stat.idle_time < PIPEX_CLOSE_TIMEOUT)
				continue;

			if (session->state == PIPEX_STATE_CLOSE_WAIT)
				LIST_REMOVE(session, state_list);
			session->state = PIPEX_STATE_CLOSED;
			/* FALLTHROUGH */

		case PIPEX_STATE_CLOSED:
			/*
			 * mbuf queued in pipexinq or pipexoutq may have a
			 * refererce to this session.
			 */
			if (!mq_empty(&pipexinq) || !mq_empty(&pipexoutq))
				continue;

			pipex_destroy_session(session);
			break;

		default:
			break;
		}
	}

	splx(s);
}

/***********************************************************************
 * Common network I/O functions.  (tunnel protocol independent)
 ***********************************************************************/
struct mbuf *
pipex_output(struct mbuf *m0, int af, int off,
    struct pipex_iface_context *pipex_iface)
{
	struct pipex_session *session;
	struct ip ip;
	struct mbuf *mret;

	session = NULL;
	mret = NULL;
	switch (af) {
	case AF_INET:
		if (m0->m_pkthdr.len >= sizeof(struct ip) + off) {
			m_copydata(m0, off, sizeof(struct ip), (caddr_t)&ip);
			if (IN_MULTICAST(ip.ip_dst.s_addr))
				session = pipex_iface->multicast_session;
			else
				session = pipex_lookup_by_ip_address(ip.ip_dst);
		}
		if (session != NULL) {
			if (session == pipex_iface->multicast_session) {
				mret = m0;
				m0 = m_copym(m0, 0, M_COPYALL, M_NOWAIT);
				if (m0 == NULL) {
					m0 = mret;
					mret = NULL;
					goto drop;
				}
			}

			if (off > 0)
				m_adj(m0, off);

			pipex_ip_output(m0, session);
			return (mret);
		}
		break;
	}

	return (m0);

drop:
	m_freem(m0);
	if (session != NULL)
		session->stat.oerrors++;
	return(NULL);
}

Static void
pipex_ip_output(struct mbuf *m0, struct pipex_session *session)
{
	int is_idle;
	struct ifnet *ifp;

	/* output succeed here as a interface */
	ifp = session->pipex_iface->ifnet_this;
	ifp->if_opackets++;
	ifp->if_obytes+=m0->m_pkthdr.len;

	if (session->is_multicast == 0) {
		/*
		 * Multicast packet is a idle packet and it's not TCP.
		 */
		if (session->ip_forward == 0 && session->ip6_forward == 0)
			goto drop;
		/* reset idle timer */
		if (session->timeout_sec != 0) {
			is_idle = 0;
			m0 = ip_is_idle_packet(m0, &is_idle);
			if (m0 == NULL)
				goto dropped;
			if (is_idle == 0)
				/* update expire time */
				session->stat.idle_time = 0;
		}

		/* adjust tcpmss */
		if ((session->ppp_flags & PIPEX_PPP_ADJUST_TCPMSS) != 0) {
			m0 = adjust_tcp_mss(m0, session->peer_mru);
			if (m0 == NULL)
				goto dropped;
		}
	} else
		m0->m_flags &= ~(M_BCAST|M_MCAST);

	/* output ip packets to the session tunnel */
	if (pipex_ppp_enqueue(m0, session, &pipexoutq))
		goto dropped;

	return;
drop:
	m_freem(m0);
dropped:
	session->stat.oerrors++;
}

Static void
pipex_ppp_output(struct mbuf *m0, struct pipex_session *session, int proto)
{
	u_char *cp, hdr[16];

#ifdef PIPEX_MPPE
	if (pipex_session_is_mppe_enabled(session)) {
		if (proto == PPP_IP) {
			pipex_mppe_output(m0, session, PPP_IP);
			return;
		}
	}
#endif /* PIPEX_MPPE */
	cp = hdr;
	if (session->protocol != PIPEX_PROTO_PPPOE) {
		/* PPPoE has not address and control field */
		PUTCHAR(PPP_ALLSTATIONS, cp);
		PUTCHAR(PPP_UI, cp);
	}
	PUTSHORT(proto, cp);

	M_PREPEND(m0, cp - hdr, M_NOWAIT);
	if (m0 == NULL)
		goto drop;
	memcpy(mtod(m0, u_char *), hdr, cp - hdr);

	switch (session->protocol) {
#ifdef	PIPEX_PPPOE
	case PIPEX_PROTO_PPPOE:
		pipex_pppoe_output(m0, session);
		break;
#endif
#ifdef PIPEX_PPTP
	case PIPEX_PROTO_PPTP:
		pipex_pptp_output(m0, session, 1, 1);
		break;
#endif
#ifdef	PIPEX_L2TP
	case PIPEX_PROTO_L2TP:
		pipex_l2tp_output(m0, session);
		break;
#endif
	default:
		goto drop;
	}

	return;
drop:
	m_freem(m0);
	session->stat.oerrors++;
}

Static void
pipex_ppp_input(struct mbuf *m0, struct pipex_session *session, int decrypted)
{
	int proto, hlen = 0;
	struct mbuf *n;

	KASSERT(m0->m_pkthdr.len >= PIPEX_PPPMINLEN);
	proto = pipex_ppp_proto(m0, session, 0, &hlen);
#ifdef PIPEX_MPPE
	if (proto == PPP_COMP) {
		if (decrypted)
			goto drop;

		/* checked this on ppp_common_input() already. */
		KASSERT(pipex_session_is_mppe_accepted(session));

		m_adj(m0, hlen);
		pipex_mppe_input(m0, session);
		return;
	}
	if (proto == PPP_CCP) {
		if (decrypted)
			goto drop;

#if NBPFILTER > 0
	    {
		struct ifnet *ifp = session->pipex_iface->ifnet_this;
		if (ifp->if_bpf && ifp->if_type == IFT_PPP)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_IN);
	    }
#endif
		m_adj(m0, hlen);
		pipex_ccp_input(m0, session);
		return;
	}
#endif
	m_adj(m0, hlen);
	if (!ALIGNED_POINTER(mtod(m0, caddr_t), uint32_t)) {
		n = m_dup_pkt(m0, 0, M_NOWAIT);
		if (n == NULL)
			goto drop;
		m_freem(m0);
		m0 = n;
	}

	switch (proto) {
	case PPP_IP:
		if (session->ip_forward == 0)
			goto drop;
		if (!decrypted && pipex_session_is_mppe_required(session))
			/*
			 * if ip packet received when mppe
			 * is required, discard it.
			 */
			goto drop;
		pipex_ip_input(m0, session);
		return;
#ifdef INET6
	case PPP_IPV6:
		if (session->ip6_forward == 0)
			goto drop;
		if (!decrypted && pipex_session_is_mppe_required(session))
			/*
			 * if ip packet received when mppe
			 * is required, discard it.
			 */
			goto drop;
		pipex_ip6_input(m0, session);
		return;
#endif
	default:
		if (decrypted)
			goto drop;
		/* protocol must be checked on pipex_common_input() already */
		KASSERT(0);
		goto drop;
	}

	return;
drop:
	m_freem(m0);
	session->stat.ierrors++;
}

Static void
pipex_ip_input(struct mbuf *m0, struct pipex_session *session)
{
	struct ifnet *ifp;
	struct ip *ip;
	int len;
	int is_idle;

	/* change recvif */
	ifp = session->pipex_iface->ifnet_this;
	m0->m_pkthdr.ph_ifidx = ifp->if_index;

	if (ISSET(session->ppp_flags, PIPEX_PPP_INGRESS_FILTER)) {
		PIPEX_PULLUP(m0, sizeof(struct ip));
		if (m0 == NULL)
			goto drop;
		/* ingress filter */
		ip = mtod(m0, struct ip *);
		if ((ip->ip_src.s_addr & session->ip_netmask.sin_addr.s_addr) !=
		    session->ip_address.sin_addr.s_addr) {
			char src[INET_ADDRSTRLEN];

			pipex_session_log(session, LOG_DEBUG,
			    "ip packet discarded by ingress filter (src %s)",
			    inet_ntop(AF_INET, &ip->ip_src, src, sizeof(src)));
			goto drop;
		}
	}

	/* idle timer */
	if (session->timeout_sec != 0) {
		is_idle = 0;
		m0 = ip_is_idle_packet(m0, &is_idle);
		if (m0 == NULL)
			goto drop;
		if (is_idle == 0)
			/* update expire time */
			session->stat.idle_time = 0;
	}

	/* adjust tcpmss */
	if (session->ppp_flags & PIPEX_PPP_ADJUST_TCPMSS) {
		m0 = adjust_tcp_mss(m0, session->peer_mru);
		if (m0 == NULL)
			goto drop;
	}

#if NPF > 0
	pf_pkt_addr_changed(m0);
#endif

	len = m0->m_pkthdr.len;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, AF_INET, m0, BPF_DIRECTION_IN);
#endif

	if (niq_enqueue(&ipintrq, m0) != 0) {
		ifp->if_collisions++;
		goto dropped;
	}

	ifp->if_ipackets++;
	ifp->if_ibytes += len;
	session->stat.ipackets++;
	session->stat.ibytes += len;

	return;
drop:
	m_freem(m0);
dropped:
	session->stat.ierrors++;
}

#ifdef INET6
Static void
pipex_ip6_input(struct mbuf *m0, struct pipex_session *session)
{
	struct ifnet *ifp;
	int len;

	/* change recvif */
	ifp = session->pipex_iface->ifnet_this;
	m0->m_pkthdr.ph_ifidx = ifp->if_index;

	/*
	 * XXX: what is reasonable ingress filter ???
	 *      only one address is enough ??
	 */

	/* XXX: we must define idle packet for IPv6(ICMPv6). */

	/*
	 * XXX: tcpmss adjustment for IPv6 is required???
	 *      We may use PMTUD in IPv6....
	 */

#if NPF > 0
	pf_pkt_addr_changed(m0);
#endif

	len = m0->m_pkthdr.len;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, AF_INET6, m0, BPF_DIRECTION_IN);
#endif

	if (niq_enqueue(&ip6intrq, m0) != 0) {
		ifp->if_collisions++;
		goto dropped;
	}

	ifp->if_ipackets++;
	ifp->if_ibytes += len;
	session->stat.ipackets++;
	session->stat.ibytes += len;

	return;
dropped:
	session->stat.ierrors++;
}
#endif

Static struct mbuf *
pipex_common_input(struct pipex_session *session, struct mbuf *m0, int hlen,
    int plen)
{
	int proto, ppphlen;
	u_char code;

	if ((m0->m_pkthdr.len < hlen + PIPEX_PPPMINLEN) ||
	    (plen < PIPEX_PPPMINLEN))
		goto drop;

	proto = pipex_ppp_proto(m0, session, hlen, &ppphlen);
	switch (proto) {
#ifdef PIPEX_MPPE
	case PPP_CCP:
		code = 0;
		KASSERT(m0->m_pkthdr.len >= hlen + ppphlen + 1);
		m_copydata(m0, hlen + ppphlen, 1, (caddr_t)&code);
		if (code != CCP_RESETREQ && code != CCP_RESETACK)
			goto not_ours;
		break;

	case PPP_COMP:
		if (pipex_session_is_mppe_accepted(session))
			break;
		goto not_ours;
#endif
	case PPP_IP:
#ifdef INET6
	case PPP_IPV6:
#endif
		break;
	default:
		goto not_ours;
	}

	/* ok,  The packet is for PIPEX */
	m_adj(m0, hlen);/* cut off the tunnle protocol header */

	/* ensure the mbuf length equals the PPP frame length */
	if (m0->m_pkthdr.len < plen)
		goto drop;
	if (m0->m_pkthdr.len > plen) {
		if (m0->m_len == m0->m_pkthdr.len) {
			m0->m_len = plen;
			m0->m_pkthdr.len = plen;
		} else
			m_adj(m0, plen - m0->m_pkthdr.len);
	}

	/* input ppp packets to kernel session */
	if (pipex_ppp_enqueue(m0, session, &pipexinq) != 0)
		goto dropped;
	else
		return (NULL);
drop:
	m_freem(m0);
dropped:
	session->stat.ierrors++;
	return (NULL);

not_ours:
	return (m0);	/* Not to be handled by PIPEX */
}

/*
 * pipex_ppp_proto
 */
Static int
pipex_ppp_proto(struct mbuf *m0, struct pipex_session *session, int off,
    int *hlenp)
{
	int proto;
	u_char *cp, pktbuf[4];

	KASSERT(m0->m_pkthdr.len > sizeof(pktbuf));
	m_copydata(m0, off, sizeof(pktbuf), pktbuf);
	cp = pktbuf;

	if (pipex_session_has_acf(session)) {
		if (cp[0] == PPP_ALLSTATIONS && cp[1] == PPP_UI)
			cp += 2;
#ifdef PIPEX_DEBUG
		else if (!pipex_session_is_acfc_accepted(session))
			PIPEX_DBG((session, LOG_DEBUG,
			    "no acf but acfc is not accepted by the peer."));
#endif
	}
	if ((*cp & 0x01) != 0) {
		if (!pipex_session_is_pfc_accepted(session)) {
			PIPEX_DBG((session, LOG_DEBUG, "Received a broken ppp "
			    "frame.  No protocol field. %02x-%02x",
			    cp[0], cp[1]));
			return (-1);
		}
		GETCHAR(proto, cp);
	} else
		GETSHORT(proto, cp);

	if (hlenp != NULL)
		*hlenp = cp - pktbuf;

	return (proto);
}

#ifdef PIPEX_PPPOE
/***********************************************************************
 * PPPoE
 ***********************************************************************/
Static u_char	pipex_pppoe_padding[ETHERMIN];
/*
 * pipex_pppoe_lookup_session
 */
struct pipex_session *
pipex_pppoe_lookup_session(struct mbuf *m0)
{
	struct pipex_session *session;
	struct pipex_pppoe_header pppoe;

	/* short packet */
	if (m0->m_pkthdr.len < (sizeof(struct ether_header) + sizeof(pppoe)))
		return (NULL);

	m_copydata(m0, sizeof(struct ether_header),
	    sizeof(struct pipex_pppoe_header), (caddr_t)&pppoe);
	pppoe.session_id = ntohs(pppoe.session_id);
	session = pipex_lookup_by_session_id(PIPEX_PROTO_PPPOE,
	    pppoe.session_id);
#ifdef PIPEX_DEBUG
	if (session == NULL)
		PIPEX_DBG((NULL, LOG_DEBUG, "<%s> session not found (id=%d)",
		    __func__, pppoe.session_id));
#endif

	return (session);
}

struct mbuf *
pipex_pppoe_input(struct mbuf *m0, struct pipex_session *session)
{
	int hlen;
	struct pipex_pppoe_header pppoe;

	/* already checked at pipex_pppoe_lookup_session */
	KASSERT(m0->m_pkthdr.len >= (sizeof(struct ether_header) +
	    sizeof(pppoe)));

	m_copydata(m0, sizeof(struct ether_header),
	    sizeof(struct pipex_pppoe_header), (caddr_t)&pppoe);

	hlen = sizeof(struct ether_header) + sizeof(struct pipex_pppoe_header);
	if ((m0 = pipex_common_input(session, m0, hlen, ntohs(pppoe.length)))
	    == NULL)
		return (NULL);
	m_freem(m0);
	session->stat.ierrors++;
	return (NULL);
}

/*
 * pipex_ppope_output
 */
Static void
pipex_pppoe_output(struct mbuf *m0, struct pipex_session *session)
{
	struct pipex_pppoe_header *pppoe;
	struct ifnet *ifp, *over_ifp;
	int len, padlen;

	/* save length for pppoe header */
	len = m0->m_pkthdr.len;

	ifp = session->pipex_iface->ifnet_this;
	over_ifp = session->proto.pppoe.over_ifp;

	/* prepend protocol header */
	M_PREPEND(m0, sizeof(struct pipex_pppoe_header), M_NOWAIT);
	if (m0 == NULL) {
		PIPEX_DBG((NULL, LOG_ERR,
		    "<%s> cannot prepend header.", __func__));
		session->stat.oerrors++;
		return;
	}
	padlen = ETHERMIN - m0->m_pkthdr.len;
	if (padlen > 0)
		m_copyback(m0, m0->m_pkthdr.len, padlen, pipex_pppoe_padding,
		    M_NOWAIT);

	/* setup pppoe header information */
	pppoe = mtod(m0, struct pipex_pppoe_header *);
	pppoe->vertype = PIPEX_PPPOE_VERTYPE;
	pppoe->code = PIPEX_PPPOE_CODE_SESSION;
	pppoe->session_id = htons(session->session_id);
	pppoe->length = htons(len);

	m0->m_pkthdr.ph_ifidx = ifp->if_index;
	m0->m_flags &= ~(M_BCAST|M_MCAST);

	session->stat.opackets++;
	session->stat.obytes += len;

	over_ifp->if_output(over_ifp, m0, (struct sockaddr *)&session->peer,
	    NULL);
}
#endif /* PIPEX_PPPOE */

#ifdef PIPEX_PPTP
/***********************************************************************
 * PPTP
 ***********************************************************************/
Static void
pipex_pptp_output(struct mbuf *m0, struct pipex_session *session,
    int has_seq, int has_ack)
{
	int len, reqlen;
	struct pipex_gre_header *gre = NULL;
	struct ip *ip;
	u_char *cp;

	reqlen = PIPEX_IPGRE_HDRLEN + (has_seq + has_ack) * 4;

	len = 0;
	if (m0 != NULL) {
		/* save length for gre header */
		len = m0->m_pkthdr.len;
		/* prepend protocol header */
		M_PREPEND(m0, reqlen, M_NOWAIT);
		if (m0 == NULL)
			goto drop;
	} else {
		MGETHDR(m0, M_DONTWAIT, MT_DATA);
		if (m0 && reqlen > MHLEN) {
			MCLGET(m0, M_DONTWAIT);
			if ((m0->m_flags & M_EXT) == 0) {
				m_freem(m0);
				m0 = NULL;
			}
		}
		if (m0 == NULL)
			goto drop;
		m0->m_pkthdr.len = m0->m_len = reqlen;
	}

	/* setup ip header information */
	ip = mtod(m0, struct ip *);

	ip->ip_len = htons(m0->m_pkthdr.len);
	ip->ip_off = 0;
	ip->ip_ttl = MAXTTL;
	ip->ip_p = IPPROTO_GRE;
	ip->ip_tos = 0;

	ip->ip_src = session->local.sin4.sin_addr;
	ip->ip_dst = session->peer.sin4.sin_addr;
#if NPF > 0
	pf_pkt_addr_changed(m0);
#endif

	/* setup gre(ver1) header information */
	gre = PIPEX_SEEK_NEXTHDR(ip, sizeof(struct ip),
	    struct pipex_gre_header *);
	gre->type = htons(PIPEX_GRE_PROTO_PPP);
	gre->call_id = htons(session->peer_session_id);
	gre->flags = PIPEX_GRE_KFLAG | PIPEX_GRE_VER;	/* do htons later */
	gre->len = htons(len);

	cp = PIPEX_SEEK_NEXTHDR(gre, sizeof(struct pipex_gre_header),u_char *);
	if (has_seq) {
		gre->flags |= PIPEX_GRE_SFLAG;
		PUTLONG(session->proto.pptp.snd_nxt, cp);
		session->proto.pptp.snd_nxt++;
		session->proto.pptp.snd_gap++;
	}
	if (has_ack) {
		gre->flags |= PIPEX_GRE_AFLAG;
		session->proto.pptp.rcv_acked = session->proto.pptp.rcv_nxt - 1;
		PUTLONG(session->proto.pptp.rcv_acked, cp);
	}
	gre->flags = htons(gre->flags);

	m0->m_pkthdr.ph_ifidx = session->pipex_iface->ifnet_this->if_index;
	if (ip_output(m0, NULL, NULL, 0, NULL, NULL, 0) != 0) {
		PIPEX_DBG((session, LOG_DEBUG, "ip_output failed."));
		goto drop;
	}
	if (len > 0) {	/* network layer only */
		/* countup statistics */
		session->stat.opackets++;
		session->stat.obytes += len;
	}

	return;
drop:
	session->stat.oerrors++;
}

struct pipex_session *
pipex_pptp_lookup_session(struct mbuf *m0)
{
	struct pipex_session *session;
	struct pipex_gre_header gre;
	struct ip ip;
	uint16_t flags;
	uint16_t id;
	int hlen;

	if (m0->m_pkthdr.len < PIPEX_IPGRE_HDRLEN) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> packet length is too short", __func__));
		goto not_ours;
	}

	/* get ip header info */
	m_copydata(m0, 0, sizeof(struct ip), (caddr_t)&ip);
	hlen = ip.ip_hl << 2;

	/*
	 * m0 has already passed ip_input(), so there is
	 * no necessity for ip packet inspection.
	 */

	/* get gre flags */
	m_copydata(m0, hlen, sizeof(gre), (caddr_t)&gre);
	flags = ntohs(gre.flags);

	/* gre version must be '1' */
	if ((flags & PIPEX_GRE_VERMASK) != PIPEX_GRE_VER) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> gre header wrong version.", __func__));
		goto not_ours;
	}

	/* gre keys must be present */
	if ((flags & PIPEX_GRE_KFLAG) == 0) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> gre header has no keys.", __func__));
		goto not_ours;
	}

	/* flag check */
	if ((flags & PIPEX_GRE_UNUSEDFLAGS) != 0) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> gre header has unused flags at pptp.", __func__));
		goto not_ours;
	}

	/* lookup pipex session table */
	id = ntohs(gre.call_id);
	session = pipex_lookup_by_session_id(PIPEX_PROTO_PPTP, id);
#ifdef PIPEX_DEBUG
	if (session == NULL) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> session not found (id=%d)", __func__, id));
		goto not_ours;
	}
#endif

	return (session);

not_ours:
	return (NULL);
}

struct mbuf *
pipex_pptp_input(struct mbuf *m0, struct pipex_session *session)
{
	int hlen, has_seq, has_ack, nseq;
	const char *reason = "";
	u_char *cp, *seqp = NULL, *ackp = NULL;
	uint32_t flags, seq = 0, ack = 0;
	struct ip *ip;
	struct pipex_gre_header *gre;
	struct pipex_pptp_session *pptp_session;
	int rewind = 0;

	KASSERT(m0->m_pkthdr.len >= PIPEX_IPGRE_HDRLEN);
	pptp_session = &session->proto.pptp;

	/* get ip header */
	ip = mtod(m0, struct ip *);
	hlen = ip->ip_hl << 2;

	/* seek gre header */
	gre = PIPEX_SEEK_NEXTHDR(ip, hlen, struct pipex_gre_header *);
	flags = ntohs(gre->flags);

	/* pullup for seek sequences in header */
	has_seq = (flags & PIPEX_GRE_SFLAG) ? 1 : 0;
	has_ack = (flags & PIPEX_GRE_AFLAG) ? 1 : 0;
	hlen = PIPEX_IPGRE_HDRLEN + 4 * (has_seq + has_ack);
	if (m0->m_len < hlen) {
		m0 = m_pullup(m0, hlen);
		if (m0 == NULL) {
			PIPEX_DBG((session, LOG_DEBUG, "pullup failed."));
			goto drop;
		}
	}

	/* check sequence */
	cp = PIPEX_SEEK_NEXTHDR(gre, sizeof(struct pipex_gre_header),u_char *);
	if (has_seq) {
		seqp = cp;
		GETLONG(seq, cp);
	}
	if (has_ack) {
		ackp = cp;
		GETLONG(ack, cp);
		if (ack + 1 == pptp_session->snd_una) {
			/* ack has not changed before */
		} else if (SEQ32_LT(ack, pptp_session->snd_una)) {
			/* OoO ack packets should not be dropped. */
			rewind = 1;
		} else if (SEQ32_GT(ack, pptp_session->snd_nxt)) {
			reason = "ack for unknown sequence";
			goto out_seq;
		} else
			pptp_session->snd_una = ack + 1;
	}
	if (!has_seq) {
		/* ack only packet */
		goto not_ours;
	}
	if (SEQ32_LT(seq, pptp_session->rcv_nxt)) {
		rewind = 1;
		if (SEQ32_LT(seq,
		    pptp_session->rcv_nxt - PIPEX_REWIND_LIMIT)) {
			reason = "out of sequence";
			goto out_seq;
		}
	} else if (SEQ32_GE(seq, pptp_session->rcv_nxt +
	    pptp_session->maxwinsz)) {
		pipex_session_log(session, LOG_DEBUG,
		    "received packet caused window overflow. seq=%u(%u-%u)"
		    "may lost %d packets.", seq, pptp_session->rcv_nxt,
		    pptp_session->rcv_nxt + pptp_session->maxwinsz,
		    (int)SEQ32_SUB(seq, pptp_session->rcv_nxt));
	}

	seq++;
	nseq = SEQ32_SUB(seq, pptp_session->rcv_nxt);
	if (!rewind) {
		pptp_session->rcv_nxt = seq;
		if (SEQ32_SUB(seq, pptp_session->rcv_acked) >
		    roundup(pptp_session->winsz, 2) / 2) /* Send ack only packet. */
			pipex_pptp_output(NULL, session, 0, 1);
	}

	if ((m0 = pipex_common_input(session, m0, hlen, (int)ntohs(gre->len)))
	    == NULL) {
		/* ok,  The packet is for PIPEX */
		if (!rewind)
			session->proto.pptp.rcv_gap += nseq;
		return (NULL);
	}

	if (rewind)
		goto out_seq;

not_ours:
	seq--;	/* revert original seq value */

	/*
	 * overwrite sequence numbers to adjust a gap between pipex and
	 * userland.
	 */
	if (seqp != NULL) {
		seq -= pptp_session->rcv_gap;
		PUTLONG(seq, seqp);
	}
	if (ackp != NULL) {
		if (pptp_session->snd_nxt == pptp_session->snd_una) {
			ack -= session->proto.pptp.snd_gap;
			pptp_session->ul_snd_una = ack;
		} else {
			/*
			 * There are sending packets they are not acked.
			 * In this situation, (ack - snd_gap) may points
			 * before sending window of userland.  So we don't
			 * update the ack number.
			 */
			ack = pptp_session->ul_snd_una;
		}
		PUTLONG(ack, ackp);
	}

	return (m0);
out_seq:
	pipex_session_log(session, LOG_DEBUG,
	    "Received bad data packet: %s: seq=%u(%u-%u) ack=%u(%u-%u)",
	    reason, seq, pptp_session->rcv_nxt,
	    pptp_session->rcv_nxt + pptp_session->maxwinsz,
	    ack, pptp_session->snd_una,
	    pptp_session->snd_nxt);

	/* FALLTHROUGH */
drop:
	m_freem(m0);
	session->stat.ierrors++;

	return (NULL);
}

struct pipex_session *
pipex_pptp_userland_lookup_session_ipv4(struct mbuf *m0, struct in_addr dst)
{
	struct sockaddr_in sin;

	memset(&sin, 0, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;
	sin.sin_addr = dst;

	return pipex_pptp_userland_lookup_session(m0, sintosa(&sin));
}

#ifdef INET6
struct pipex_session *
pipex_pptp_userland_lookup_session_ipv6(struct mbuf *m0, struct in6_addr dst)
{
	struct sockaddr_in6 sin6;

	memset(&sin6, 0, sizeof(sin6));
	sin6.sin6_len = sizeof(sin6);
	sin6.sin6_family = AF_INET6;
	in6_recoverscope(&sin6, &dst);

	return pipex_pptp_userland_lookup_session(m0, sin6tosa(&sin6));
}
#endif

Static struct pipex_session *
pipex_pptp_userland_lookup_session(struct mbuf *m0, struct sockaddr *sa)
{
	struct pipex_gre_header gre;
	struct pipex_hash_head *list;
	struct pipex_session *session;
	uint16_t id, flags;

	/* pullup */
	if (m0->m_pkthdr.len < sizeof(gre)) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> packet length is too short", __func__));
		return (NULL);
	}

	/* get flags */
	m_copydata(m0, 0, sizeof(struct pipex_gre_header), (caddr_t)&gre);
	flags = ntohs(gre.flags);

	/* gre version must be '1' */
	if ((flags & PIPEX_GRE_VERMASK) != PIPEX_GRE_VER) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> gre header wrong version.", __func__));
		return (NULL);
	}

	/* gre keys must be present */
	if ((flags & PIPEX_GRE_KFLAG) == 0) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> gre header has no keys.", __func__));
		return (NULL);
	}

	/* lookup pipex session table */
	id = ntohs(gre.call_id);

	list = PIPEX_PEER_ADDR_HASHTABLE(pipex_sockaddr_hash_key(sa));
	LIST_FOREACH(session, list, peer_addr_chain) {
		if (pipex_sockaddr_compar_addr(
		    (struct sockaddr *)&session->peer, sa) != 0)
			continue;
		if (session->peer_session_id == id)
			break;
	}
#ifdef PIPEX_DEBUG
	if (session == NULL) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> session not found (,call_id=%d)",
		    __func__, (int)gre.call_id));
	}
#endif
	return (session);
}

/*
 * pipex_pptp_userland_output
 */
struct mbuf *
pipex_pptp_userland_output(struct mbuf *m0, struct pipex_session *session)
{
	int len;
	struct pipex_gre_header *gre, gre0;
	uint16_t flags;
	u_char *cp, *cp0;
	uint32_t val32;

	len = sizeof(struct pipex_gre_header);
	m_copydata(m0, 0, len, (caddr_t)&gre0);
	gre = &gre0;
	flags = ntohs(gre->flags);
	if ((flags & PIPEX_GRE_SFLAG) != 0)
		len += 4;
	if ((flags & PIPEX_GRE_AFLAG) != 0)
		len += 4;

	/* check length */
	PIPEX_PULLUP(m0, len);
	if (m0 == NULL) {
		PIPEX_DBG((session, LOG_DEBUG, "gre header is too short."));
		return (NULL);
	}

	gre = mtod(m0, struct pipex_gre_header *);
	cp = PIPEX_SEEK_NEXTHDR(gre, sizeof(struct pipex_gre_header), u_char *);

	/*
	 * overwrite sequence numbers to adjust a gap between pipex and
	 * userland.
	 */
	if ((flags & PIPEX_GRE_SFLAG) != 0) {
		cp0 = cp;
		GETLONG(val32, cp);
		val32 += session->proto.pptp.snd_gap;
		PUTLONG(val32, cp0);
		session->proto.pptp.snd_nxt++;
	}
	if ((flags & PIPEX_GRE_AFLAG) != 0) {
		cp0 = cp;
		GETLONG(val32, cp);
		val32 += session->proto.pptp.rcv_gap;
		PUTLONG(val32, cp0);
		if (SEQ32_GT(val32, session->proto.pptp.rcv_acked))
			session->proto.pptp.rcv_acked = val32;
	}

	return (m0);
}
#endif /* PIPEX_PPTP */

#ifdef PIPEX_L2TP
/***********************************************************************
 * L2TP support
 ***********************************************************************/
Static void
pipex_l2tp_output(struct mbuf *m0, struct pipex_session *session)
{
	int hlen, plen, datalen;
	struct pipex_l2tp_header *l2tp = NULL;
	struct pipex_l2tp_seq_header *seq = NULL;
	struct udphdr *udp;
	struct ip *ip;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif

	hlen = sizeof(struct pipex_l2tp_header) +
	    ((pipex_session_is_l2tp_data_sequencing_on(session))
		    ? sizeof(struct pipex_l2tp_seq_header) : 0) +
	    sizeof(struct udphdr) +
#ifdef INET6
	    ((session->peer.sin6.sin6_family == AF_INET6)
		    ? sizeof(struct ip6_hdr) : sizeof(struct ip));
#else
	    sizeof(struct ip);
#endif

	datalen = 0;
	if (m0 != NULL) {
		datalen = m0->m_pkthdr.len;
		M_PREPEND(m0, hlen, M_NOWAIT);
		if (m0 == NULL)
			goto drop;
	} else {
		MGETHDR(m0, M_DONTWAIT, MT_DATA);
		if (m0 == NULL)
			goto drop;
		KASSERT(hlen <= MHLEN);
		m0->m_pkthdr.len = m0->m_len = hlen;
	}

#ifdef INET6
	hlen = (session->peer.sin6.sin6_family == AF_INET6)
	    ? sizeof(struct ip6_hdr) : sizeof(struct ip);
#else
	hlen = sizeof(struct ip);
#endif
	plen = datalen + sizeof(struct pipex_l2tp_header) +
	    ((pipex_session_is_l2tp_data_sequencing_on(session))
		    ? sizeof(struct pipex_l2tp_seq_header) : 0);

	l2tp = (struct pipex_l2tp_header *)
	    (mtod(m0, caddr_t) + hlen + sizeof(struct udphdr));
	l2tp->flagsver = PIPEX_L2TP_VER | PIPEX_L2TP_FLAG_LENGTH;
	l2tp->length = htons(plen);
	l2tp->tunnel_id = htons(session->proto.l2tp.peer_tunnel_id);
	l2tp->session_id = htons(session->peer_session_id);
	if (pipex_session_is_l2tp_data_sequencing_on(session)) {
		seq = (struct pipex_l2tp_seq_header *)(l2tp + 1);
		l2tp->flagsver |= PIPEX_L2TP_FLAG_SEQUENCE;
		seq->ns = htons(session->proto.l2tp.ns_nxt);
		session->proto.l2tp.ns_nxt++;
		session->proto.l2tp.ns_gap++;
		session->proto.l2tp.nr_acked = session->proto.l2tp.nr_nxt - 1;
		seq->nr = htons(session->proto.l2tp.nr_acked);
	}
	l2tp->flagsver = htons(l2tp->flagsver);

	plen += sizeof(struct udphdr);
	udp = (struct udphdr *)(mtod(m0, caddr_t) + hlen);
	udp->uh_sport = session->local.sin6.sin6_port;
	udp->uh_dport = session->peer.sin6.sin6_port;
	udp->uh_ulen = htons(plen);
	udp->uh_sum = 0;

	m0->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
	m0->m_pkthdr.ph_ifidx = session->pipex_iface->ifnet_this->if_index;
#if NPF > 0
	pf_pkt_addr_changed(m0);
#endif
	switch (session->peer.sin6.sin6_family) {
	case AF_INET:
		ip = mtod(m0, struct ip *);
		ip->ip_p = IPPROTO_UDP;
		ip->ip_src = session->local.sin4.sin_addr;
		ip->ip_dst = session->peer.sin4.sin_addr;
		ip->ip_len = htons(hlen + plen);
		ip->ip_ttl = MAXTTL;
		ip->ip_tos = 0;
		ip->ip_off = 0;

		if (ip_output(m0, NULL, NULL, 0, NULL, NULL,
		    session->proto.l2tp.ipsecflowinfo) != 0) {
			PIPEX_DBG((session, LOG_DEBUG, "ip_output failed."));
			goto drop;
		}
		break;
#ifdef INET6
	case AF_INET6:
		ip6 = mtod(m0, struct ip6_hdr *);

		ip6->ip6_flow = 0;
		ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
		ip6->ip6_vfc |= IPV6_VERSION;
		ip6->ip6_nxt = IPPROTO_UDP;
		ip6->ip6_src = session->local.sin6.sin6_addr;
		(void)in6_embedscope(&ip6->ip6_dst,
		    &session->peer.sin6, NULL);
		/* ip6->ip6_plen will be filled in ip6_output. */

		if (ip6_output(m0, NULL, NULL, 0, NULL, NULL) != 0) {
			PIPEX_DBG((session, LOG_DEBUG, "ip6_output failed."));
			goto drop;
		}
		break;
#endif
	}
	udpstat_inc(udps_opackets);

	if (datalen > 0) {	/* network layer only */
		/* countup statistics */
		session->stat.opackets++;
		session->stat.obytes += datalen;
	}

	return;
drop:
	session->stat.oerrors++;
}

struct pipex_session *
pipex_l2tp_lookup_session(struct mbuf *m0, int off)
{
	struct pipex_session *session;
	uint16_t flags, session_id, ver;
	u_char *cp, buf[PIPEX_L2TP_MINLEN];

	if (m0->m_pkthdr.len < off + PIPEX_L2TP_MINLEN) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> packet length is too short", __func__));
		goto not_ours;
	}

	/* get first 16bits of L2TP */
	m_copydata(m0, off, sizeof(buf), buf);
	cp = buf;
	GETSHORT(flags, cp);
	ver = flags & PIPEX_L2TP_VER_MASK;

	/* l2tp version must be '2' */
	if (ver != PIPEX_L2TP_VER) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> l2tp header wrong version %u.", __func__, ver));
		goto not_ours;
	}
	if ((flags & PIPEX_L2TP_FLAG_TYPE) != 0)
		goto not_ours;

	if (flags & PIPEX_L2TP_FLAG_LENGTH)
		cp += 2;			/* skip length field */
	cp += 2;				/* skip tunnel-id field */
	GETSHORT(session_id, cp);		/* get session-id field */

	/* lookup pipex session table */
	session = pipex_lookup_by_session_id(PIPEX_PROTO_L2TP, session_id);
#ifdef PIPEX_DEBUG
	if (session == NULL) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> session not found (id=%d)", __func__, session_id));
		goto not_ours;
	}
#endif

	return (session);

not_ours:
	return (NULL);
}

struct mbuf *
pipex_l2tp_input(struct mbuf *m0, int off0, struct pipex_session *session,
    uint32_t ipsecflowinfo)
{
	struct pipex_l2tp_session *l2tp_session;
	int length, offset, hlen, nseq;
	u_char *cp, *nsp, *nrp;
	uint16_t flags, ns = 0, nr = 0;
	int rewind = 0;

	length = offset = ns = nr = 0;
	l2tp_session = &session->proto.l2tp;
	l2tp_session->ipsecflowinfo = ipsecflowinfo;
	nsp = nrp = NULL;

	m_copydata(m0, off0, sizeof(flags), (caddr_t)&flags);

	flags = ntohs(flags) & PIPEX_L2TP_FLAG_MASK;
	KASSERT((flags & PIPEX_L2TP_FLAG_TYPE) == 0);

	hlen = 2;				/* flags and version fields */
	if (flags & PIPEX_L2TP_FLAG_LENGTH)	/* length */
		hlen += 2;
	hlen += 4;				/* tunnel-id and session-id */
	if (flags & PIPEX_L2TP_FLAG_SEQUENCE)	/* ns and nr */
		hlen += 4;
	if (flags & PIPEX_L2TP_FLAG_OFFSET)	/* offset */
		hlen += 2;

	PIPEX_PULLUP(m0, off0 + hlen);
	if (m0  == NULL)
		goto drop;

	cp = mtod(m0, u_char *) + off0;
	cp += 2;	/* flags and version */
	if (flags & PIPEX_L2TP_FLAG_LENGTH)
		GETSHORT(length, cp);
	else
		length = m0->m_pkthdr.len - off0;
	cp += 4;	/* skip tunnel-id and session-id field */

	/* pullup for seek sequences in header */
	nseq = 0;
	if (flags & PIPEX_L2TP_FLAG_SEQUENCE) {
		nsp = cp;
		GETSHORT(ns, cp);
		nrp = cp;
		GETSHORT(nr, cp);

		nr++;
		if (SEQ16_GT(nr, l2tp_session->ns_una) &&
		    SEQ16_LE(nr, l2tp_session->ns_nxt))
			/* update 'ns_una' only if the ns is in valid range */
			l2tp_session->ns_una = nr;
		if (SEQ16_LT(ns, l2tp_session->nr_nxt)) {
			rewind = 1;
			if (SEQ16_LT(ns,
			    l2tp_session->nr_nxt - PIPEX_REWIND_LIMIT))
				goto out_seq;
		}

		ns++;
		nseq = SEQ16_SUB(ns, l2tp_session->nr_nxt);
		if (!rewind)
			l2tp_session->nr_nxt = ns;
	}
	if (flags & PIPEX_L2TP_FLAG_OFFSET)
		GETSHORT(offset, cp);

	length -= hlen + offset;
	hlen += off0 + offset;
	if ((m0 = pipex_common_input(session, m0, hlen, length)) == NULL) {
		/* ok,  The packet is for PIPEX */
		if (!rewind)
			session->proto.l2tp.nr_gap += nseq;
		return (NULL);
	}

	if (rewind)
		goto out_seq;

	/*
	 * overwrite sequence numbers to adjust a gap between pipex and
	 * userland.
	 */
	if (flags & PIPEX_L2TP_FLAG_SEQUENCE) {
		--ns; --nr;	/* revert original values */
		ns -= l2tp_session->nr_gap;
		PUTSHORT(ns, nsp);

		if (l2tp_session->ns_nxt == l2tp_session->ns_una) {
			nr -= l2tp_session->ns_gap;
			l2tp_session->ul_ns_una = nr;
		} else {
			/*
			 * There are sending packets they are not acked.
			 * In this situation, (ack - snd_gap) may points
			 * before sending window of userland.  So we don't
			 * update the ack number.
			 */
			nr = l2tp_session->ul_ns_una;
		}
		PUTSHORT(nr, nrp);
	}

	return (m0);
out_seq:
	pipex_session_log(session, LOG_DEBUG,
	    "Received bad data packet: out of sequence: seq=%u(%u-) "
	    "ack=%u(%u-%u)", ns, l2tp_session->nr_nxt, nr, l2tp_session->ns_una,
	    l2tp_session->ns_nxt);

	/* FALLTHROUGH */
drop:
	m_freem(m0);
	session->stat.ierrors++;

	return (NULL);
}

struct pipex_session *
pipex_l2tp_userland_lookup_session_ipv4(struct mbuf *m0, struct in_addr dst)
{
	struct sockaddr_in sin;

	memset(&sin, 0, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;
	sin.sin_addr = dst;

	return pipex_l2tp_userland_lookup_session(m0, sintosa(&sin));
}

#ifdef INET6
struct pipex_session *
pipex_l2tp_userland_lookup_session_ipv6(struct mbuf *m0, struct in6_addr dst)
{
	struct sockaddr_in6 sin6;

	memset(&sin6, 0, sizeof(sin6));
	sin6.sin6_len = sizeof(sin6);
	sin6.sin6_family = AF_INET6;
	in6_recoverscope(&sin6, &dst);

	return pipex_l2tp_userland_lookup_session(m0, sin6tosa(&sin6));
}
#endif

struct pipex_session *
pipex_l2tp_userland_lookup_session(struct mbuf *m0, struct sockaddr *sa)
{
	struct pipex_l2tp_header l2tp;
	struct pipex_hash_head *list;
	struct pipex_session *session;
	uint16_t session_id, tunnel_id, flags;

	if (sa->sa_family != AF_INET && sa->sa_family != AF_INET6)
		return (NULL);

	/* pullup */
	if (m0->m_pkthdr.len < sizeof(l2tp)) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> packet length is too short", __func__));
		return (NULL);
	}

	/* get flags */
	m_copydata(m0, 0, sizeof(l2tp), (caddr_t)&l2tp);
	flags = ntohs(l2tp.flagsver);

	/* l2tp version must be '2' */
	if ((flags & PIPEX_L2TP_VER_MASK) != PIPEX_L2TP_VER) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> l2tp header wrong version.", __func__));
		return (NULL);
	}
	/* We need L2TP data messages only */
	if ((flags & PIPEX_L2TP_FLAG_TYPE) != 0)
		return (NULL);
	/* No need to hook packets that don't have the sequence field */
	if ((flags & PIPEX_L2TP_FLAG_SEQUENCE) == 0)
		return (NULL);

	session_id = ntohs(l2tp.session_id);
	tunnel_id = ntohs(l2tp.tunnel_id);

	list = PIPEX_PEER_ADDR_HASHTABLE(pipex_sockaddr_hash_key(sa));
	LIST_FOREACH(session, list, peer_addr_chain) {
		if (pipex_sockaddr_compar_addr(
		    (struct sockaddr *)&session->peer, sa) != 0)
			continue;
		if (session->proto.l2tp.peer_tunnel_id != tunnel_id)
			continue;
		if (session->peer_session_id == session_id)
			break;
	}
#ifdef PIPEX_DEBUG
	if (session == NULL) {
		PIPEX_DBG((NULL, LOG_DEBUG, "<%s> session not found "
		    "(tunnel_id=%d, session_id=%d)", __func__,
		    tunnel_id, session_id));
	}
#endif

	return (session);
}

struct mbuf *
pipex_l2tp_userland_output(struct mbuf *m0, struct pipex_session *session)
{
	struct pipex_l2tp_header *l2tp;
	struct pipex_l2tp_seq_header *seq;
	uint16_t ns, nr;

	/* check length */
	PIPEX_PULLUP(m0, sizeof(struct pipex_l2tp_header) +
	    sizeof(struct pipex_l2tp_seq_header));
	if (m0 == NULL)
		return (NULL);

	l2tp = mtod(m0, struct pipex_l2tp_header *);
	KASSERT(ntohs(l2tp->flagsver) & PIPEX_L2TP_FLAG_SEQUENCE);

	/*
	 * overwrite sequence numbers to adjust a gap between pipex and
	 * userland.
	 */
		seq = (struct pipex_l2tp_seq_header *)(l2tp + 1);
		ns = ntohs(seq->ns);
		nr = ntohs(seq->nr);

		ns += session->proto.l2tp.ns_gap;
		seq->ns = htons(ns);
		session->proto.l2tp.ns_nxt++;

		nr += session->proto.l2tp.nr_gap;
		seq->nr = htons(nr);
		if (SEQ16_GT(nr, session->proto.l2tp.nr_acked))
			session->proto.l2tp.nr_acked = nr;

	return (m0);
}
#endif /* PIPEX_L2TP */

#ifdef PIPEX_MPPE
/**********************************************************************
 * MPPE
 ***********************************************************************/
#define	PIPEX_COHERENCY_CNT_MASK		0x0fff
Static void
pipex_mppe_init(struct pipex_mppe *mppe, int stateless, int keylenbits,
    u_char *master_key, int has_oldkey)
{
	memset(mppe, 0, sizeof(struct pipex_mppe));
	if (stateless)
		mppe->stateless = 1;
	if (has_oldkey)
		mppe->old_session_keys =
		    pool_get(&mppe_key_pool, PR_WAITOK);
	else
		mppe->old_session_keys = NULL;
	memcpy(mppe->master_key, master_key, sizeof(mppe->master_key));

	mppe->keylenbits = keylenbits;
	switch (keylenbits) {
	case 40:
	case 56:
		mppe->keylen = 8;
		break;
	case 128:
		mppe->keylen = 16;
		break;
	}

	GetNewKeyFromSHA(mppe->master_key, mppe->master_key, mppe->keylen,
	    mppe->session_key);
	pipex_mppe_reduce_key(mppe);
	pipex_mppe_setkey(mppe);
}

void
pipex_session_init_mppe_recv(struct pipex_session *session, int stateless,
    int keylenbits, u_char *master_key)
{
	pipex_mppe_init(&session->mppe_recv, stateless, keylenbits,
	    master_key, stateless);
	session->ppp_flags |= PIPEX_PPP_MPPE_ACCEPTED;
}

void
pipex_session_init_mppe_send(struct pipex_session *session, int stateless,
    int keylenbits, u_char *master_key)
{
	pipex_mppe_init(&session->mppe_send, stateless, keylenbits,
	    master_key, 0);
	session->ppp_flags |= PIPEX_PPP_MPPE_ENABLED;
}

#include <crypto/sha1.h>

static u_char SHAPad1[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}, SHAPad2[] = {
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
};

Static void
GetNewKeyFromSHA(u_char *StartKey, u_char *SessionKey, int SessionKeyLength,
    u_char *InterimKey)
{
	u_char Digest[20];
	SHA1_CTX Context;

	SHA1Init(&Context);
	SHA1Update(&Context, StartKey, SessionKeyLength);
	SHA1Update(&Context, SHAPad1, 40);
	SHA1Update(&Context, SessionKey, SessionKeyLength);
	SHA1Update(&Context, SHAPad2, 40);
	SHA1Final(Digest, &Context);

	memcpy(InterimKey, Digest, SessionKeyLength);
}

Static void
pipex_mppe_reduce_key(struct pipex_mppe *mppe)
{
	switch (mppe->keylenbits) {
	case 40:
		mppe->session_key[1] = 0x26;
		mppe->session_key[2] = 0x9e;
	case 56:
		mppe->session_key[0] = 0xd1;
	}
}

Static void
mppe_key_change(struct pipex_mppe *mppe)
{
	u_char interim[16];
	struct rc4_ctx keychg;

	memset(&keychg, 0, sizeof(keychg));

	GetNewKeyFromSHA(mppe->master_key, mppe->session_key, mppe->keylen,
	    interim);

	rc4_keysetup(&keychg, interim, mppe->keylen);
	rc4_crypt(&keychg, interim, mppe->session_key, mppe->keylen);

	pipex_mppe_reduce_key(mppe);

	if (mppe->old_session_keys) {
		int idx = mppe->coher_cnt & PIPEX_MPPE_OLDKEYMASK;
		memcpy(mppe->old_session_keys[idx],
		    mppe->session_key, PIPEX_MPPE_KEYLEN);
	}
}

Static void
pipex_mppe_input(struct mbuf *m0, struct pipex_session *session)
{
	int pktloss, encrypt, flushed, m, n, len;
	struct pipex_mppe *mppe;
	uint16_t coher_cnt;
	struct mbuf *m1;
	u_char *cp;
	int rewind = 0;

	/* pullup */
	PIPEX_PULLUP(m0, sizeof(coher_cnt));
	if (m0 == NULL)
		goto drop;

	mppe = &session->mppe_recv;
	/* get header information */
	cp = mtod(m0, u_char *);
	GETSHORT(coher_cnt, cp);
	flushed = ((coher_cnt & 0x8000) != 0) ? 1 : 0;
	encrypt = ((coher_cnt & 0x1000) != 0) ? 1 : 0;
	coher_cnt &= PIPEX_COHERENCY_CNT_MASK;
	pktloss = 0;

	PIPEX_MPPE_DBG((session, LOG_DEBUG, "in coher_cnt=%03x %s%s",
	    mppe->coher_cnt, (flushed) ? "[flushed]" : "",
	    (encrypt) ? "[encrypt]" : ""));

	if (encrypt == 0) {
		pipex_session_log(session, LOG_DEBUG,
		    "Received unexpected MPPE packet.(no ecrypt)");
		goto drop;
	}

	/* adjust mbuf */
	m_adj(m0, sizeof(coher_cnt));

	/*
	 * L2TP data session may be used without sequencing, PPP frames may
	 * arrive in disorder.  The 'coherency counter' of MPPE detects such
	 * situations, but we cannot distinguish between 'disorder' and
	 * 'packet loss' exactly.
	 *
	 * When 'coherency counter' detects lost packets greater than
	 * (4096 - 256), we treat as 'disorder' otherwise treat as
	 * 'packet loss'.
	 */
    {
	int coher_cnt0;

	coher_cnt0 = coher_cnt;
	if (coher_cnt < mppe->coher_cnt)
		coher_cnt0 += 0x1000;
	if (coher_cnt0 - mppe->coher_cnt > 0x0f00) {
		if (!mppe->stateless ||
		    coher_cnt0 - mppe->coher_cnt
		    <= 0x1000 - PIPEX_MPPE_NOLDKEY) {
			pipex_session_log(session, LOG_DEBUG,
			    "Workaround the out-of-sequence PPP framing problem: "
			    "%d => %d", mppe->coher_cnt, coher_cnt);
			goto drop;
		}
		rewind = 1;
	}
    }

	if (mppe->stateless != 0) {
		if (!rewind) {
			mppe_key_change(mppe);
			while (mppe->coher_cnt != coher_cnt) {
				mppe->coher_cnt++;
				mppe->coher_cnt &= PIPEX_COHERENCY_CNT_MASK;
				mppe_key_change(mppe);
				pktloss++;
			}
		}
		pipex_mppe_setoldkey(mppe, coher_cnt);
	} else {
		if (flushed) {
			if (coher_cnt < mppe->coher_cnt) {
				coher_cnt += 0x1000;
			}
			pktloss += coher_cnt - mppe->coher_cnt;
			m = mppe->coher_cnt / 256;
			n = coher_cnt / 256;
			while (m++ < n)
				mppe_key_change(mppe);

			coher_cnt &= PIPEX_COHERENCY_CNT_MASK;
			mppe->coher_cnt = coher_cnt;
		} else if (mppe->coher_cnt != coher_cnt) {
			/* Send CCP ResetReq */
			PIPEX_DBG((session, LOG_DEBUG, "CCP SendResetReq"));
			pipex_ccp_output(session, CCP_RESETREQ,
			    session->ccp_id++);
			goto drop;
		}
		if ((coher_cnt & 0xff) == 0xff) {
			mppe_key_change(mppe);
			flushed = 1;
		}
		if (flushed)
			pipex_mppe_setkey(mppe);
	}

	if (pktloss > 1000) {
		pipex_session_log(session, LOG_DEBUG,
		    "%d packets loss.", pktloss);
	}

	/* decrypt ppp payload */
	for (m1 = m0; m1; m1 = m1->m_next) {
		cp = mtod(m1, u_char *);
		len = m1->m_len;
		pipex_mppe_crypt(mppe, len, cp, cp);
	}

	if (!rewind) {
		/* update coher_cnt */
		mppe->coher_cnt++;
		mppe->coher_cnt &= PIPEX_COHERENCY_CNT_MASK;
	}
	if (m0->m_pkthdr.len < PIPEX_PPPMINLEN)
		goto drop;

	pipex_ppp_input(m0, session, 1);

	return;
drop:
	m_freem(m0);
	session->stat.ierrors++;
}

Static void
pipex_mppe_output(struct mbuf *m0, struct pipex_session *session,
    uint16_t protocol)
{
	int encrypt, flushed, len;
	struct mppe_header {
		uint16_t coher_cnt;
		uint16_t protocol;
	} __packed *hdr;
	u_char *cp;
	struct pipex_mppe *mppe;
	struct mbuf *m;

	mppe = &session->mppe_send;

	/*
	 * create a deep-copy if the mbuf has a shared mbuf cluster.
	 * this is required to handle cases of tcp retransmition.
	 */
	for (m = m0; m != NULL; m = m->m_next) {
		if (M_READONLY(m)) {
			m = m_dup_pkt(m0, max_linkhdr, M_NOWAIT);
			m_freem(m0);
			if (m == NULL)
				goto drop;
			m0 = m;
			break;
		}
	}
	/* prepend mppe header */
	M_PREPEND(m0, sizeof(struct mppe_header), M_NOWAIT);
	if (m0 == NULL)
		goto drop;
	hdr = mtod(m0, struct mppe_header *);
	hdr->protocol = protocol;

	/* check coherency counter */
	flushed = 0;
	encrypt = 1;

	if (mppe->stateless != 0) {
		flushed = 1;
		mppe_key_change(mppe);
	} else {
		if ((mppe->coher_cnt % 0x100) == 0xff) {
			flushed = 1;
			mppe_key_change(mppe);
		} else if (mppe->resetreq != 0) {
			flushed = 1;
			mppe->resetreq = 0;
		}
	}

	if (flushed)
		pipex_mppe_setkey(mppe);

	PIPEX_MPPE_DBG((session, LOG_DEBUG, "out coher_cnt=%03x %s%s",
	    mppe->coher_cnt, (flushed) ? "[flushed]" : "",
	    (encrypt) ? "[encrypt]" : ""));

	/* setup header information */
	hdr->coher_cnt = (mppe->coher_cnt++) & PIPEX_COHERENCY_CNT_MASK;
	hdr->coher_cnt &= PIPEX_COHERENCY_CNT_MASK;
	if (flushed)
		hdr->coher_cnt |= 0x8000;
	if (encrypt)
		hdr->coher_cnt |= 0x1000;

	hdr->protocol = htons(hdr->protocol);
	hdr->coher_cnt = htons(hdr->coher_cnt);

	/* encrypt chain */
	for (m = m0; m; m = m->m_next) {
		cp = mtod(m, u_char *);
		len = m->m_len;
		if (m == m0 && len > offsetof(struct mppe_header, protocol)) {
			len -= offsetof(struct mppe_header, protocol);
			cp += offsetof(struct mppe_header, protocol);
		}
		pipex_mppe_crypt(mppe, len, cp, cp);
	}

	pipex_ppp_output(m0, session, PPP_COMP);

	return;
drop:
	session->stat.oerrors++;
}

Static void
pipex_ccp_input(struct mbuf *m0, struct pipex_session *session)
{
	u_char *cp;
	int code, id, len;

	if (m0->m_pkthdr.len < PPP_HDRLEN)
		goto drop;
	if ((m0 = m_pullup(m0, PPP_HDRLEN)) == NULL)
		goto drop;

	cp = mtod(m0, u_char *);
	GETCHAR(code, cp);
	GETCHAR(id, cp);
	GETSHORT(len, cp);

	switch (code) {
	case CCP_RESETREQ:
		PIPEX_DBG((session, LOG_DEBUG, "CCP RecvResetReq"));
		session->mppe_send.resetreq = 1;
#ifndef PIPEX_NO_CCP_RESETACK
		PIPEX_DBG((session, LOG_DEBUG, "CCP SendResetAck"));
		pipex_ccp_output(session, CCP_RESETACK, id);
#endif
		/* ignore error */
		break;
	case CCP_RESETACK:
		PIPEX_DBG((session, LOG_DEBUG, "CCP RecvResetAck"));
		break;
	default:
		PIPEX_DBG((session, LOG_DEBUG, "CCP Recv code=%d", code));
		goto drop;
	}
	m_freem(m0);

	return;
drop:
	m_freem(m0);
	session->stat.ierrors++;
}

Static int
pipex_ccp_output(struct pipex_session *session, int code, int id)
{
	u_char *cp;
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		session->stat.oerrors++;
		return (1);
	}
	m->m_pkthdr.len = m->m_len = 4;
	cp = mtod(m, u_char *);
	PUTCHAR(code, cp);
	PUTCHAR(id, cp);
	PUTSHORT(4, cp);

	pipex_ppp_output(m, session, PPP_CCP);

	return (0);
}
#endif
/***********************************************************************
 * Miscellaneous fuctions
 ***********************************************************************/
/* adapted from FreeBSD:src/usr.sbin/ppp/tcpmss.c */
/*
 * Copyright (c) 2000 Ruslan Ermilov and Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/usr.sbin/ppp/tcpmss.c,v 1.1.4.3 2001/07/19 11:39:54 brian Exp $
 */
#define TCP_OPTLEN_IN_SEGMENT	12	/* timestamp option and padding */
#define MAXMSS(mtu) (mtu - sizeof(struct ip) - sizeof(struct tcphdr) - \
    TCP_OPTLEN_IN_SEGMENT)
/*
 * The following macro is used to update an internet checksum.  "acc" is a
 * 32-bit accumulation of all the changes to the checksum (adding in old
 * 16-bit words and subtracting out new words), and "cksum" is the checksum
 * value to be updated.
 */
#define ADJUST_CHECKSUM(acc, cksum) {			\
	acc += cksum;					\
	if (acc < 0) {					\
		acc = -acc;				\
		acc = (acc >> 16) + (acc & 0xffff);	\
		acc += acc >> 16;			\
		cksum = (u_short) ~acc;			\
	} else {					\
		acc = (acc >> 16) + (acc & 0xffff);	\
		acc += acc >> 16;			\
		cksum = (u_short) acc;			\
	}						\
}

/*
 * Rewrite max-segment-size TCP option to avoid PMTU blackhole issues.
 * The mtu parameter should be the MTU bottleneck (as far as we know)
 * on the link between the source and the destination.
 */
Static struct mbuf *
adjust_tcp_mss(struct mbuf *m0, int mtu)
{
	int opt, optlen, acc, mss, maxmss, lpktp;
	struct ip *pip;
	struct tcphdr *th;
	u_char *pktp, *mssp;
	u_int16_t ip_off;

	lpktp = sizeof(struct ip) + sizeof(struct tcphdr) + PIPEX_TCP_OPTLEN;
	lpktp = MIN(lpktp, m0->m_pkthdr.len);

	PIPEX_PULLUP(m0, lpktp);
	if (m0 == NULL)
		goto drop;

	pktp = mtod(m0, char *);
	pip = (struct ip *)pktp;
	ip_off = ntohs(pip->ip_off);

	/* Non TCP or fragmented packet must not have a MSS option */
	if (pip->ip_p != IPPROTO_TCP ||
	    (ip_off & IP_MF) != 0 || (ip_off & IP_OFFMASK) != 0)
		goto handled;

	pktp += pip->ip_hl << 2;
	lpktp -= pip->ip_hl << 2;

	/* packet is broken */
	if (sizeof(struct tcphdr) > lpktp)
		goto drop;
	th = (struct tcphdr *)pktp;

	/*
	 * As RFC 973, a MSS field must only be sent in the initial
	 * connection request(it must be with SYN).
	 */
	if ((th->th_flags & TH_SYN) == 0)
		goto handled;

	lpktp = MIN(th->th_off << 4, lpktp);

	pktp += sizeof(struct tcphdr);
	lpktp -= sizeof(struct tcphdr);
	while (lpktp >= TCPOLEN_MAXSEG) {
		GETCHAR(opt, pktp);
		switch (opt) {
		case TCPOPT_MAXSEG:
			GETCHAR(optlen, pktp);
			mssp = pktp;		/* mss place holder */
			GETSHORT(mss, pktp);
			maxmss = MAXMSS(mtu);
			if (mss > maxmss) {
				PIPEX_DBG((NULL, LOG_DEBUG,
				    "change tcp-mss %d => %d", mss, maxmss));
				PUTSHORT(maxmss, mssp);
				acc = htons(mss);
				acc -= htons(maxmss);
				ADJUST_CHECKSUM(acc, th->th_sum);
			}
			goto handled;
			/* NOTREACHED */
		case TCPOPT_EOL:
			goto handled;
			/* NOTREACHED */
		case TCPOPT_NOP:
			lpktp--;
			break;
		default:
			GETCHAR(optlen, pktp);
			if (optlen < 2)	/* packet is broken */
				goto drop;
			pktp += optlen - 2;
			lpktp -= optlen;
			break;
		}
	}

handled:
	return (m0);

drop:
	m_freem(m0);
	return (NULL);
}

/*
 *  Check whether a packet should reset idle timer
 *  Returns 1 to don't reset timer (i.e. the packet is "idle" packet)
 */
Static struct mbuf *
ip_is_idle_packet(struct mbuf *m0, int *ris_idle)
{
	u_int16_t ip_off;
	const struct udphdr *uh;
	struct ip *pip;
	int len;

	/* pullup ip header */
	len = sizeof(struct ip);
	PIPEX_PULLUP(m0, len);
	if (m0 == NULL)
		goto error;
	pip = mtod(m0, struct ip *);

	/*
	 * the packet which fragmentations was not the idle packet.
	 */
	ip_off = ntohs(pip->ip_off);
	if ((ip_off & IP_MF) || ((ip_off & IP_OFFMASK) != 0))
		goto is_active;

	switch (pip->ip_p) {
	case IPPROTO_IGMP:
		goto is_active;
	case IPPROTO_ICMP:
		len = pip->ip_hl * 4 + 8;
		PIPEX_PULLUP(m0, len);
		if (m0 == NULL)
			goto error;
		pip = mtod(m0, struct ip *);

		switch (((unsigned char *) pip)[pip->ip_hl * 4]) {
		case 0:	/* Echo Reply */
		case 8:	/* Echo Request */
			goto is_active;
		default:
			goto is_idle;
		}

	case IPPROTO_UDP:
	case IPPROTO_TCP:
		len = pip->ip_hl * 4 + sizeof(struct udphdr);
		PIPEX_PULLUP(m0, len);
		if (m0 == NULL)
			goto error;
		pip = mtod(m0, struct ip *);
		uh = (struct udphdr *)(mtod(m0, caddr_t) + pip->ip_hl * 4);

		switch (ntohs(uh->uh_sport)) {
		case 53:	/* DOMAIN */
		case 67:	/* BOOTPS */
		case 68:	/* BOOTPC */
		case 123:	/* NTP */
		case 137:	/* NETBIOS-NS */
		case 520:	/* RIP */
			goto is_idle;
		}
		switch (ntohs(uh->uh_dport)) {
		case 53:	/* DOMAIN */
		case 67:	/* BOOTPS */
		case 68:	/* BOOTPC */
		case 123:	/* NTP */
		case 137:	/* NETBIOS-NS */
		case 520:	/* RIP */
			goto is_idle;
		}
		goto is_active;
	default:
		goto is_active;
	}

is_active:
	*ris_idle = 0;
	return (m0);

is_idle:
	*ris_idle = 1;
	return (m0);

error:
	return (NULL);
}

Static void
pipex_session_log(struct pipex_session *session, int prio, const char *fmt, ...)
{
	char logbuf[1024];
	va_list ap;

	logpri(prio);
	if (session != NULL) {
		addlog("pipex: ppp=%d iface=%s protocol=%s id=%d ",
		    session->ppp_id, session->pipex_iface->ifnet_this->if_xname,
		    (session->protocol == PIPEX_PROTO_PPPOE)? "PPPoE" :
		    (session->protocol == PIPEX_PROTO_PPTP)? "PPTP" :
		    (session->protocol == PIPEX_PROTO_L2TP) ? "L2TP" :
		    "Unknown", session->session_id);
	} else
		addlog("pipex: ");

	va_start(ap, fmt);
	vsnprintf(logbuf, sizeof(logbuf), fmt, ap);
	va_end(ap);
	addlog("%s\n", logbuf);
}

Static uint32_t
pipex_sockaddr_hash_key(struct sockaddr *sa)
{
	switch (sa->sa_family) {
	case AF_INET:
		return ntohl(satosin(sa)->sin_addr.s_addr);
	case AF_INET6:
		return ntohl(satosin6(sa)->sin6_addr.s6_addr32[3]);
	}
	panic("pipex_sockaddr_hash_key: unknown address family");
	return (0);
}

/*
 * Compare struct sockaddr_in{,6} with the address only.
 * The port number is not covered.
 */
Static int
pipex_sockaddr_compar_addr(struct sockaddr *a, struct sockaddr *b)
{
	int cmp;

	cmp = b->sa_family - a->sa_family;
	if (cmp != 0)
		return cmp;
	switch (a->sa_family) {
	case AF_INET:
		return (satosin(b)->sin_addr.s_addr -
		    satosin(a)->sin_addr.s_addr);
	case AF_INET6:
		cmp = (satosin6(b)->sin6_scope_id - satosin6(a)->sin6_scope_id);
		if (cmp != 0)
			return cmp;
		return (memcmp(&satosin6(a)->sin6_addr,
		    &satosin6(b)->sin6_addr,
		    sizeof(struct in6_addr)));
	}
	panic("pipex_sockaddr_compar_addr: unknown address family");

	return (-1);
}

Static inline int
pipex_mppe_setkey(struct pipex_mppe *mppe)
{
	rc4_keysetup(&mppe->rc4ctx, mppe->session_key, mppe->keylen);

	return (0);
}

Static inline int
pipex_mppe_setoldkey(struct pipex_mppe *mppe, uint16_t coher_cnt)
{
	KASSERT(mppe->old_session_keys != NULL);

	rc4_keysetup(&mppe->rc4ctx,
	    mppe->old_session_keys[coher_cnt & PIPEX_MPPE_OLDKEYMASK],
	    mppe->keylen);

	return (0);
}

Static inline void
pipex_mppe_crypt(struct pipex_mppe *mppe, int len, u_char *indata,
    u_char *outdata)
{
	rc4_crypt(&mppe->rc4ctx, indata, outdata, len);
}

int
pipex_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	switch (name[0]) {
	case PIPEXCTL_ENABLE:
		if (namelen != 1)
			return (ENOTDIR);
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &pipex_enable));
	case PIPEXCTL_INQ:
	        return (sysctl_mq(name + 1, namelen - 1,
		    oldp, oldlenp, newp, newlen, &pipexinq));
	case PIPEXCTL_OUTQ:
	        return (sysctl_mq(name + 1, namelen - 1,
		    oldp, oldlenp, newp, newlen, &pipexoutq));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


1.92
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.91 2016/12/19 15:51:53 mpi Exp $	*/
d1009 1
d1041 9
a1059 1
		m_adj(m0, hlen);
a1071 1
		m_adj(m0, hlen);
d1101 3
a1103 13
	PIPEX_PULLUP(m0, sizeof(struct ip));
	if (m0 == NULL)
		goto drop;

#if 0
	/*
	 * XXX: hsuenaga
	 * we need to know openbsd manners to adjust alignment
	 */
	if (!ALIGNED_POINTER(mtod(m0, caddr_t), struct ip *)) {
		/* ip_output() assumes ip packet is aligned.  */
		if ((m0 = m_copyup(m0, sizeof(struct ip),
		    ((max_linkhdr + 3) & ~3))) == NULL)
a1104 3
	}
#endif
	if (ISSET(session->ppp_flags, PIPEX_PPP_INGRESS_FILTER)) {
a1173 13

#if 0 /* XXX: alignment */
	PIPEX_PULLUP(m0, sizeof(struct ip6_hdr));
	if (m0 == NULL)
		goto drop;

	if (!ALIGNED_POINTER(mtod(m0, caddr_t), struct ip6_hdr *)) {
		/* ip6_output() assumes ip packet is aligned.  */
		if ((m0 = m_copyup(m0, sizeof(struct ip6_hdr),
		    ((max_linkhdr + 3) & ~3))) == NULL)
			goto drop;
	}
#endif
@


1.91
log
@Kill useless comment about splsoftnet() which is going away.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.90 2016/11/18 02:53:47 dlg Exp $	*/
d93 1
a93 1
    pipex_id_hashtable[PIPEX_HASH_SIZE]; 	/* peer id hash */
d99 1
a99 1
struct timeout pipex_timer_ch; 		/* callout timer context */
@


1.90
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the udpstat struct.

udpstat_inc(udps_foo) replaces udpstat.udps_foo++ for the actual
updates. udpstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the udpstat struct for
now.

ok mpi@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.89 2016/09/15 02:00:18 dlg Exp $	*/
a705 1
	/* called at splsoftnet() */
@


1.89
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.88 2016/08/30 23:29:04 dlg Exp $	*/
d1989 1
a1989 1
	udpstat.udps_opackets++;
@


1.88
log
@pool_setipl

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.87 2016/03/22 23:53:01 dlg Exp $	*/
d134 4
a137 6
	pool_init(&pipex_session_pool, sizeof(struct pipex_session), 0, 0,
	    PR_WAITOK, "ppxss", NULL);
	pool_setipl(&pipex_session_pool, IPL_NONE);
	pool_init(&mppe_key_pool, PIPEX_MPPE_KEYLEN * PIPEX_MPPE_NOLDKEY, 0, 0,
	    PR_WAITOK, "mppekey", NULL);
	pool_setipl(&mppe_key_pool, IPL_NONE);
@


1.87
log
@dont leak an mbuf when copying the packet in pipex_mppe_output fails

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.86 2016/03/22 23:51:01 dlg Exp $	*/
d134 3
a136 2
	pool_init(&pipex_session_pool, sizeof(struct pipex_session), 0, 0, 0,
	    "ppxss", NULL);
d138 2
a139 1
	    0, "mppekey", NULL);
@


1.86
log
@replace m_copym2 with m_dup_pkt

this gives us preallocated space at the start of the packet for
headers so later calls to M_PREPEND are far less likely to fail.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.85 2016/03/04 22:38:23 sashan Exp $	*/
d2572 1
a2574 1
			m_freem(m0);
@


1.85
log
@- putting back KASSERT(), which I've backed out on Jan 31
  We don't expect inbound packets to come to PF with statekey attached.

- I've also found missing call to pf_pkt_addr_changed() at various
  places, which needs to get fixed to prevent KASSERT() from firing.

OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.84 2015/11/03 21:33:56 chl Exp $	*/
d2571 1
a2571 1
			m = m_copym2(m0, 0, M_COPYALL, M_NOWAIT);
@


1.84
log
@Remove dead assignment and newly created unused variable.

Found by LLVM/Clang Static Analyzer.

ok yasuoka@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.83 2015/10/07 10:50:35 mpi Exp $	*/
d1141 4
@


1.83
log
@Initialize the routing table before domains.

The routing table is not an optional component of the network stack
and initializing it inside the "routing domain" requires some ugly
introspection in the domain interface.

This put the rtable* layer at the same level of the if* level.  These
two subsystem are organized around the two global data structure used
in the network stack:

- the global &ifnet list, to be used in process context only, and
- the routing table which can be read in interrupt context.

This change makes the rtable_* layer domain-aware and extends the
"struct domain" such that INET, INET6 and MPLS can specify the length
of the binary key used in lookups.  This allows us to keep, or move
towards, AF-free route and rtable layers.

While here stop the madness and pass the size of the maximum key length
in *byte* to rn_inithead0().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.82 2015/10/05 06:51:50 yasuoka Exp $	*/
a1170 1
	struct ip6_hdr *ip6;
a1188 1
	ip6 = mtod(m0, struct ip6_hdr *);
@


1.82
log
@Fix ip_is_idle_packet() to parse packets properly.
diff from Yuuichi Someya
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.81 2015/09/22 10:09:19 mpi Exp $	*/
d164 1
a164 1
		    offsetof(struct sockaddr_in, sin_addr) * NBBY))
d170 1
a170 1
		    offsetof(struct sockaddr_in6, sin6_addr) *NBBY))
@


1.81
log
@Use the radix-tree API instead of function pointers.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.80 2015/09/13 17:53:44 mpi Exp $	*/
d2879 1
d2895 2
a2896 1
		uh = mtod(m0, struct udphdr *);
@


1.80
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.79 2015/09/12 20:26:07 mpi Exp $	*/
d449 2
a450 2
		rn = pipex_rd_head4.rnh_addaddr(&session->ip_address,
		    &session->ip_netmask, &pipex_rd_head4, session->ps4_rn, RTP_STATIC);
d458 2
a459 3
		rn = pipex_rd_head6.rnh_addaddr(&session->ip6_address,
		    &session->ip6_prefixlen, &pipex_rd_head6, session->ps6_rn,
		    RTP_STATIC);
d616 2
a617 3
		rn = pipex_rd_head4.rnh_deladdr(&session->ip_address,
		    &session->ip_netmask, &pipex_rd_head4,
		    (struct radix_node *)session);
d662 2
a663 2
	session = (struct pipex_session *)pipex_rd_head4.rnh_lookup(
	    &pipex_in4, &pipex_in4mask, &pipex_rd_head4);
@


1.79
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.78 2015/09/11 08:17:06 claudio Exp $	*/
d1434 2
a1435 1
	if_output(over_ifp, m0, (struct sockaddr *)&session->peer, NULL);
@


1.78
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.77 2015/09/11 07:42:35 claudio Exp $	*/
d1434 1
a1434 2
	over_ifp->if_output(over_ifp, m0, (struct sockaddr *)&session->peer,
	    NULL);
@


1.77
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.76 2015/09/10 17:52:05 claudio Exp $	*/
d1982 1
a1982 1
		if (ip6_output(m0, NULL, NULL, 0, NULL, NULL, NULL) != 0) {
@


1.76
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.75 2015/09/04 08:43:39 mpi Exp $	*/
d1979 1
a1979 1
		    &session->peer.sin6, NULL, NULL);
@


1.75
log
@Make every subsystem using a radix tree call rn_init() and pass the
length of the key as argument.

This way every consumer of the radix tree has a chance to explicitly
initialize the shared data structures and no longer rely on another
subsystem to do the initialization.

As a bonus ``dom_maxrtkey'' is no longer used an die.

ART kernels should now be fully usable because pf(4) and IPSEC properly
initialized the radix tree.

ok chris@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.74 2015/09/01 21:24:04 bluhm Exp $	*/
d1757 1
a1757 1
	in6_recoverscope(&sin6, &dst, NULL);
d2193 1
a2193 1
	in6_recoverscope(&sin6, &dst, NULL);
@


1.74
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.73 2015/08/24 14:00:28 bluhm Exp $	*/
a127 1
	extern int	 max_keylen;		/* for radix.c */
d132 2
a141 2
	if (sizeof(struct sockaddr_in) > max_keylen)
		max_keylen = sizeof(struct sockaddr_in);
@


1.73
log
@In kernel initialize struct sockaddr_in and sockaddr_in6 to zero
everywhere to avoid passing around pointers to uninitialized stack
memory.  While there, fix the call to in6_recoverscope() in
fill_drlist().
OK deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.72 2015/07/16 16:12:15 mpi Exp $	*/
d2962 1
a2962 1
		return ntohl(((struct sockaddr_in *)sa)->sin_addr.s_addr);
d2964 1
a2964 2
		return ntohl(((struct sockaddr_in6 *)sa)->sin6_addr
		    .s6_addr32[3]);
d2984 2
a2985 2
		return ((struct sockaddr_in *)b)->sin_addr.s_addr -
		    ((struct sockaddr_in *)a)->sin_addr.s_addr;
d2987 1
a2987 2
		cmp = ((struct sockaddr_in6 *)b)->sin6_scope_id -
		    ((struct sockaddr_in6 *)a)->sin6_scope_id;
d2990 3
a2992 3
		return memcmp(&((struct sockaddr_in6 *)a)->sin6_addr,
		    &((struct sockaddr_in6 *)b)->sin6_addr,
		    sizeof(struct in6_addr));
@


1.72
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.71 2015/07/15 22:16:42 deraadt Exp $	*/
d1739 1
a1739 1
	struct sockaddr_in sin4;
d1741 4
a1744 2
	sin4.sin_family = AF_INET;
	sin4.sin_addr = dst;
d1746 1
a1746 1
	return pipex_pptp_userland_lookup_session(m0, (struct sockaddr *)&sin4);
d1755 2
d1760 1
a1760 1
	return pipex_pptp_userland_lookup_session(m0, (struct sockaddr *)&sin6);
d2175 1
a2175 1
	struct sockaddr_in sin4;
d2177 4
a2180 2
	sin4.sin_family = AF_INET;
	sin4.sin_addr = dst;
d2182 1
a2182 1
	return pipex_l2tp_userland_lookup_session(m0, (struct sockaddr *)&sin4);
d2191 2
d2196 1
a2196 1
	return pipex_l2tp_userland_lookup_session(m0, (struct sockaddr *)&sin6);
@


1.71
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.70 2015/06/16 11:09:40 mpi Exp $	*/
d1359 1
a1359 1
	NTOHS(pppoe.session_id);
d1935 1
a1935 1
	HTONS(l2tp->flagsver);
d2611 2
a2612 2
	HTONS(hdr->protocol);
	HTONS(hdr->coher_cnt);
@


1.70
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.69 2015/04/23 09:45:24 dlg Exp $	*/
d903 1
a903 2
	if (m0 != NULL)
		m_freem(m0);
d952 1
a952 2
	if (m0 != NULL)
		m_freem(m0);
d1005 1
a1005 2
	if (m0 != NULL)
		m_freem(m0);
d1081 1
a1081 2
	if (m0 != NULL)
		m_freem(m0);
d1164 1
a1164 2
	if (m0 != NULL)
		m_freem(m0);
d1730 1
a1730 2
	if (m0 != NULL)
		m_freem(m0);
d2162 1
a2162 2
	if (m0 != NULL)
		m_freem(m0);
d2539 1
a2539 2
	if (m0 != NULL)
		m_freem(m0);
d2669 1
a2669 2
	if (m0 != NULL)
		m_freem(m0);
d2836 1
a2836 2
	if (m0)
		m_freem(m0);
@


1.69
log
@replace the use of struct ifqueue in pipex with mbuf_queues.

this has a slight semantic change. previously pipex would only
process up to 128 packets on the input and output queues at a time
and would reschedule the softint if there were any left. now it
mq_delists the current set of pending packets and only processes
them. if anything is added to the queues later they'll cause the
softint to run again.

this in turn lets us deprecate sysctl_ifq since nothing uses it
anymore. because niqueues are mostly wrappers around mbuf_queues,
we can provide sysctl_mq and just #define sysctl_niq to it.

pipex bits are ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.68 2015/04/10 13:58:20 dlg Exp $	*/
d1098 2
a1099 2
	m0->m_pkthdr.rcvif = session->pipex_iface->ifnet_this;
	ifp = m0->m_pkthdr.rcvif;
d1183 2
a1184 2
	m0->m_pkthdr.rcvif = session->pipex_iface->ifnet_this;
	ifp = m0->m_pkthdr.rcvif;
d1434 1
a1434 1
	m0->m_pkthdr.rcvif = ifp; 
d1519 1
a1519 1
	m0->m_pkthdr.rcvif = session->pipex_iface->ifnet_this;
d1951 1
a1951 1
	m0->m_pkthdr.rcvif = session->pipex_iface->ifnet_this;
@


1.68
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.67 2015/04/10 11:02:12 dlg Exp $	*/
d103 2
a104 2
struct ifqueue pipexinq;
struct ifqueue pipexoutq;
d147 1
a147 3
	/* queue and softintr init */
	IFQ_SET_MAXLEN(&pipexinq, IFQ_MAXLEN);
	IFQ_SET_MAXLEN(&pipexoutq, IFQ_MAXLEN);
d719 1
a719 1
	int c, s;
d722 2
a723 9
	for (c = 0; c < PIPEX_DEQUEUE_LIMIT; c++) {
		s = splnet();
		IF_DEQUEUE(&pipexoutq, m);
		if (m == NULL) {
			splx(s);
			break;
		}
		splx(s);

d759 2
a760 9
	for (c = 0; c < PIPEX_DEQUEUE_LIMIT; c++) {
		s = splnet();
		IF_DEQUEUE(&pipexinq, m);
		if (m == NULL) {
			splx(s);
			break;
		}
		splx(s);

a767 9

	/*
	 * When packet remains in queue, it is necessary
	 * to re-schedule software interrupt.
	 */
	s = splnet();
	if (!IF_IS_EMPTY(&pipexinq) || !IF_IS_EMPTY(&pipexoutq))
		softintr_schedule(pipex_softintr);
	splx(s);
d772 1
a772 1
    struct ifqueue *queue)
a773 2
	int s;

d778 2
a779 8
	s = splnet();
	if (IF_QFULL(queue)) {
		IF_DROP(queue);
		splx(s);
		goto fail;
	}
	IF_ENQUEUE(queue, m0);
	splx(s);
a782 4

fail:
	/* caller is responsible for freeing m0 */
	return (1);
d844 1
a844 1
			if (!IF_IS_EMPTY(&pipexinq) || !IF_IS_EMPTY(&pipexoutq))
d932 1
a932 1
				goto drop;
d942 1
a942 1
				goto drop;
d949 1
a949 1
		goto drop;
d955 1
d1290 3
a1292 1
	if (pipex_ppp_enqueue(m0, session, &pipexinq) == 0)
d1296 1
d3041 1
a3041 1
	        return (sysctl_ifq(name + 1, namelen - 1,
d3044 1
a3044 1
	        return (sysctl_ifq(name + 1, namelen - 1,
@


1.67
log
@mpi@@ introduced a ph_cookie in mbuf packet headers that can be used
by a subsystem to stash some state while the mbuf gets queued. eg,
net80211 uses it to keep track of the wireless node associated with
a packet before submitting it to a drivers snd queue for transmission.

this makes pipex use ph_cookie to keep track of the pipex session
associated with a packet before submitting it to the softint queues.
this lets us get rid of an mbuf tag type, and avoids the cost of
tag allocation.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.66 2015/03/18 12:23:15 dlg Exp $	*/
d1130 1
a1130 1
	int s, len;
d1192 1
a1192 3
	s = splnet();
	if (IF_QFULL(&ipintrq)) {
		IF_DROP(&ipintrq);
d1194 1
a1194 3
		if_congestion();
		splx(s);
		goto drop;
a1195 2
	IF_ENQUEUE(&ipintrq, m0);
	schednetisr(NETISR_IP);
a1201 2
	splx(s);

d1206 1
d1216 1
a1216 1
	int s, len;
d1259 1
a1259 3
	s = splnet();
	if (IF_QFULL(&ip6intrq)) {
		IF_DROP(&ip6intrq);
d1261 1
a1261 3
		if_congestion();
		splx(s);
		goto drop;
a1262 2
	IF_ENQUEUE(&ip6intrq, m0);
	schednetisr(NETISR_IPV6);
a1268 2
	splx(s);

d1270 1
a1270 3
drop:
	if (m0 != NULL)
		m_freem(m0);
@


1.66
log
@remove the congestion handling from struct ifqueue.

its only used for the ip and ip6 network stack input queues, so it
seems unfair that every instance of ifqueue has to carry a pointer
around for this specific use case.

this moves the congestion marker to a kernel global. if we detect
that we're congested, we assume the whole system is busy and punish
all input queues.

marking a system as congested is done by setting the global to the
current value of ticks. as the system moves away from that value,
it moves away from being congested until the comparison fails.

written at s2k15
ok henning@@ beck@@ bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.65 2014/12/19 17:14:40 tedu Exp $	*/
a104 4
struct pipex_tag {
	struct pipex_session *session;
	int			proto;
};
d108 3
d718 2
a720 2
	struct m_tag *mtag;
	struct pipex_tag *tag;
d733 2
a734 2
		mtag = m_tag_find(m, PACKET_TAG_PIPEX, NULL);
		if (mtag == NULL) {
d738 6
a743 2
		tag = (struct pipex_tag *)(mtag + 1);
		if (tag->session->is_multicast != 0) {
d750 1
a750 1
				    tag->session->pipex_iface)
d760 1
a760 1
				pipex_ppp_output(m0, session, tag->proto);
d764 1
a764 1
			pipex_ppp_output(m, tag->session, tag->proto);
d777 2
a778 2
		mtag = m_tag_find(m, PACKET_TAG_PIPEX, NULL);
		if (mtag == NULL) {
d782 1
a782 2
		tag = (struct pipex_tag *)(mtag + 1);
		pipex_ppp_input(m, tag->session, 0);
a798 2
	struct pipex_tag *tag;
	struct m_tag *mtag;
d801 4
a810 10
	mtag = m_tag_get(PACKET_TAG_PIPEX, sizeof(struct pipex_tag), M_NOWAIT);
	if (mtag == NULL) {
		splx(s);
		goto fail;
	}
	m_tag_prepend(m0, mtag);
	tag = (struct pipex_tag *)(mtag + 1);
	tag->session = session;
	tag->proto = PPP_IP;	/* XXX need to support other protocols */

a903 2
	struct pipex_tag *tag;
	struct m_tag *mtag;
a917 14
			for (mtag = m_tag_find(m0, PACKET_TAG_PIPEX, NULL);
			    mtag != NULL;
			    mtag = m_tag_find(m0, PACKET_TAG_PIPEX, mtag)) {
				tag = (struct pipex_tag *)(mtag + 1);
				if (tag->session == session) {
					/*
					 * Don't encapsulate encapsulated
					 * packets.
					 */
					m_freem(m0);
					return (NULL);
				}
			}

a1051 2
	struct m_tag *mtag;
	struct pipex_tag *tag;
a1082 10
	/* delete mtag from decapsulated packet */
	for (mtag = m_tag_find(m0, PACKET_TAG_PIPEX, NULL); mtag;
	    mtag = m_tag_find(m0, PACKET_TAG_PIPEX, mtag)) {
		tag = (struct pipex_tag *)(mtag + 1);
		if (tag->session == session) {
			m_tag_delete(m0, mtag);
			break;
		}
	}

@


1.65
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.64 2014/12/01 06:55:05 yasuoka Exp $	*/
d1230 1
a1230 2
		if (!ipintrq.ifq_congestion)
			if_congestion(&ipintrq);
d1304 1
a1304 2
		if (!ip6intrq.ifq_congestion)
			if_congestion(&ip6intrq);
@


1.64
log
@Check the header fields of GRE and MPPE packets strictly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.63 2014/11/20 14:51:42 krw Exp $	*/
a64 1
#ifdef INET
a73 1
#endif
@


1.63
log
@Yet more #include de-duplication.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.62 2014/11/04 15:24:40 mpi Exp $	*/
d1079 1
d1337 2
a1338 1
	if (m0->m_pkthdr.len < hlen + PIPEX_PPPMINLEN)
d1402 1
d1666 7
d2627 2
@


1.62
log
@Remove "pl" suffix on pool names.

ok dlg@@, uebayasi@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.61 2014/10/28 09:45:37 yasuoka Exp $	*/
a61 1
#include <sys/time.h>
a65 1
#include <netinet/in.h>
@


1.61
log
@Fix pipex(4) to return multicast packets to the caller so that npppd can
handle them.  Also use M_NOWAIT for copying a multicast packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.60 2014/10/28 09:15:09 yasuoka Exp $	*/
d139 3
a141 3
	    "ppxsspl", NULL);
	pool_init(&mppe_key_pool, PIPEX_MPPE_KEYLEN * PIPEX_MPPE_NOLDKEY, 0, 0, 0,
	    "mppekeypl", NULL);
@


1.60
log
@Initialize the lists of the hash tables and the virtual pipex
sesssion for multicast in proper way.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.59 2014/10/28 09:10:21 yasuoka Exp $	*/
d756 1
a756 1
				m0 = m_copym(m, 0, M_COPYALL, M_WAITOK);
d916 1
d919 1
d944 10
d958 1
a958 1
			return (NULL);
d964 7
@


1.59
log
@Fix pipex(4) to initialize DF bit in IP header for L2TP message.
Without this, the packets larger than the minimum MTU on the routes to
the L2TP peer had been dropped.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.58 2014/10/21 10:52:53 yasuoka Exp $	*/
d132 2
a133 1
	extern int max_keylen;		/* for radix.c */
d148 4
a151 2
	memset(pipex_id_hashtable, 0, sizeof(pipex_id_hashtable));
	memset(pipex_peer_addr_hashtable, 0, sizeof(pipex_peer_addr_hashtable));
d184 1
a184 1
	session = pool_get(&pipex_session_pool, PR_WAITOK);
@


1.58
log
@tun(4) has a pipex session which is used for multicast internally, it
wasn't freeed when the interface is destroyed.  Free it properly.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.57 2014/10/20 16:33:32 uebayasi Exp $	*/
d2022 1
@


1.57
log
@pipex(4): Converted to use pool(9)

OK blambert@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d187 1
a187 1
void
d193 1
a193 1
void
a197 1
	int s;
a198 1
	s = splnet();
d210 12
@


1.56
log
@Whitespace.
@
text
@d41 1
d86 3
d137 5
d181 1
a181 1
	session = malloc(sizeof(*session), M_TEMP, M_WAITOK);
d329 1
a329 1
	session = malloc(sizeof(*session), M_TEMP, M_WAITOK | M_ZERO);
d408 1
a408 1
			free(session, M_TEMP, 0);
d417 1
a417 1
			free(session, M_TEMP, 0);
d428 1
a428 1
			free(session, M_TEMP, 0);
d440 1
a440 1
			free(session, M_TEMP, 0);
d448 1
a448 1
			free(session, M_TEMP, 0);
d458 1
a458 1
			free(session, M_TEMP, 0);
d637 2
a638 2
		free(session->mppe_recv.old_session_keys, M_TEMP, 0);
	free(session, M_TEMP, 0);
d2356 1
a2356 2
		    malloc(PIPEX_MPPE_KEYLEN * PIPEX_MPPE_NOLDKEY,
		    M_TEMP, M_WAITOK);
@


1.55
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.54 2014/07/12 18:44:22 tedu Exp $	*/
d80 1
a80 1
#define	Static	
d143 1
a143 1
        pipex_softintr =
d217 1
a217 1
				pipex_iface_start(pipex_iface);	
d219 1
a219 1
				pipex_iface_stop(pipex_iface);	
d250 1
a250 1
	default:	
d397 1
a397 1
    	if ((req->pr_ppp_flags & PIPEX_PPP_MPPE_ACCEPTED) != 0) {
d406 1
a406 1
    	if ((req->pr_ppp_flags & PIPEX_PPP_MPPE_ENABLED) != 0) {
d444 8
a451 8
                rn = pipex_rd_head6.rnh_addaddr(&session->ip6_address,
                    &session->ip6_prefixlen, &pipex_rd_head6, session->ps6_rn, 
                    RTP_STATIC);
                if (rn == NULL) {
                        splx(s);
                        free(session, M_TEMP, 0);
                        return (ENOMEM);
                }
d495 1
a495 1
	
d782 1
a782 1
	
d815 1
a815 1
{	
d1056 1
a1056 1
	
d1241 2
a1242 2
	 * XXX: what is reasonable ingress filter ??? 
	 *      only one address is enough ?? 
d1247 1
a1247 1
	/* 
d1254 1
a1254 1
#endif  
d1480 1
a1480 1
	m0->m_pkthdr.rcvif = ifp; 	
d1541 1
a1541 1
#endif  
d1562 1
a1562 1
       	}
d1592 1
a1592 1
		PIPEX_DBG((NULL, LOG_DEBUG, 
d1707 1
a1707 1
	} else if (SEQ32_GE(seq, pptp_session->rcv_nxt + 
d1709 1
a1709 1
		pipex_session_log(session, LOG_DEBUG, 
d1765 1
a1765 1
	pipex_session_log(session, LOG_DEBUG, 
d1964 1
a1964 1
 
d1981 1
a1981 1
 
d1993 1
a1993 1
#endif  
d2051 1
a2051 1
		PIPEX_DBG((NULL, LOG_DEBUG, 
d2143 1
a2143 1
		    SEQ16_LE(nr, l2tp_session->ns_nxt))	
d2199 1
a2199 1
	pipex_session_log(session, LOG_DEBUG, 
d2734 1
a2734 1
	PUTSHORT(4, cp); 
d2898 1
a2898 1
	
d2907 2
a2908 2
         * the packet which fragmentations was not the idle packet.
         */
d2964 1
a2964 1
	
d2984 1
a2984 1
		    (session->protocol == PIPEX_PROTO_PPTP)? "PPTP" : 
@


1.55.4.1
log
@Check the header fields of GRE and MPPE packets strictly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.55 2014/07/22 11:06:10 mpi Exp $	*/
a1039 1
	KASSERT(m0->m_pkthdr.len >= PIPEX_PPPMINLEN);
d1297 1
a1297 2
	if ((m0->m_pkthdr.len < hlen + PIPEX_PPPMINLEN) ||
	    (plen < PIPEX_PPPMINLEN))
a1360 1
	KASSERT(m0->m_pkthdr.len > sizeof(pktbuf));
a1623 7
	/* flag check */
	if ((flags & PIPEX_GRE_UNUSEDFLAGS) != 0) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> gre header has unused flags at pptp.", __func__));
		goto not_ours;
	}

a2577 2
	if (m0->m_pkthdr.len < PIPEX_PPPMINLEN)
		goto drop;
@


1.54
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.53 2014/06/13 06:47:09 yasuoka Exp $	*/
a66 1
#include <netinet/in_systm.h>
@


1.53
log
@KASSERT in pipex_ppp_input() fails if a compressed PPP frame is received
by the pipex session whose mppe is not accepted.  Fix ppp_common_input()
to not pass such frames to pipex.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.52 2014/06/13 06:44:11 yasuoka Exp $	*/
d400 1
a400 1
			free(session, M_TEMP);
d409 1
a409 1
			free(session, M_TEMP);
d420 1
a420 1
			free(session, M_TEMP);
d432 1
a432 1
			free(session, M_TEMP);
d440 1
a440 1
			free(session, M_TEMP);
d450 1
a450 1
                        free(session, M_TEMP);
d629 2
a630 2
		free(session->mppe_recv.old_session_keys, M_TEMP);
	free(session, M_TEMP);
@


1.52
log
@Fix KASSERT on pipex_ppp_input().  Must not reached there even if the
tunneling protocol is PPPoE.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.51 2014/06/13 06:35:58 yasuoka Exp $	*/
d1043 1
a1043 1
	if (pipex_session_is_mppe_accepted(session) && proto == PPP_COMP) {
d1046 4
d1313 3
@


1.51
log
@Fix tcp-mss-adjust of pipex and npppd to update the pointer of
tcp option and check the boundary correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.50 2014/04/21 12:22:25 henning Exp $	*/
d1106 3
a1108 4
		KASSERT(session->protocol == PIPEX_PROTO_PPPOE);
		/* will be proccessed by userland */
		m_freem(m0);
		return;
@


1.50
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.48 2013/11/11 09:15:34 mpi Exp $	*/
d2835 2
d2865 3
a2867 1
			pktp += 2 - optlen;
@


1.49
log
@There is no need to initialize globals to 0.
@
text
@d1561 1
a1561 1
	if (ip_output(m0, NULL, NULL, 0, NULL, NULL) != 0) {
d1999 1
a1999 1
		if (ip_output(m0, NULL, NULL, IP_IPSECFLOW, NULL, NULL,
@


1.48
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.47 2013/10/24 11:31:43 mpi Exp $	*/
d98 2
a99 2
int pipex_rd_head4_initialized = 0;
int pipex_rd_head6_initialized = 0;
@


1.48.4.1
log
@Check the header fields of GRE and MPPE packets strictly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.48 2013/11/11 09:15:34 mpi Exp $	*/
a1040 1
	KASSERT(m0->m_pkthdr.len >= PIPEX_PPPMINLEN);
d1295 1
a1295 2
	if ((m0->m_pkthdr.len < hlen + PIPEX_PPPMINLEN) ||
	    (plen < PIPEX_PPPMINLEN))
a1355 1
	KASSERT(m0->m_pkthdr.len > sizeof(pktbuf));
a1618 7
	/* flag check */
	if ((flags & PIPEX_GRE_UNUSEDFLAGS) != 0) {
		PIPEX_DBG((NULL, LOG_DEBUG,
		    "<%s> gre header has unused flags at pptp.", __func__));
		goto not_ours;
	}

a2572 2
	if (m0->m_pkthdr.len < PIPEX_PPPMINLEN)
		goto drop;
@


1.47
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.46 2013/10/23 15:12:42 mpi Exp $	*/
d655 3
a657 1
	if (session == NULL)
d659 2
a660 1
		    __func__, inet_ntoa(addr)));
d1152 2
d1156 1
a1156 1
			    inet_ntoa(ip->ip_src));
@


1.46
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.45 2013/10/19 10:51:41 henning Exp $	*/
a70 1
#include <netinet6/in6_var.h>
@


1.45
log
@simplify checksum handling. no need to compute the pseudo hdr cksum
in the v4 case any more, and computing the cksum in the v6 case isn't
needed either. ok florian lteo
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.44 2013/10/17 16:27:43 bluhm Exp $	*/
a66 1
#include <netinet/in_var.h>
@


1.44
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.43 2013/09/20 08:11:55 yasuoka Exp $	*/
d1979 1
d1981 1
a1995 7
		if (udpcksum) {
			udp->uh_sum = in_cksum_phdr(ip->ip_src.s_addr,
			   ip->ip_dst.s_addr, htons(plen  + IPPROTO_UDP));
			m0->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
		} else
			udp->uh_sum = 0;

a2014 4
		udp->uh_sum = 0;
		if ((udp->uh_sum = in6_cksum(m0, IPPROTO_UDP,
		    sizeof(struct ip6_hdr), plen)) == 0)
			udp->uh_sum = 0xffff;
@


1.43
log
@Fix a panic bug in pipex.  If pipex deletes a session by the idle-timer
when the userland program (npppd) is dead or frozen, the session remains in
state_list after it is destroyed, it will be used after free.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.42 2013/06/08 14:24:38 yasuoka Exp $	*/
d72 1
@


1.42
log
@Add new sysctl for pipex packet input/output queue length and
counters.

ok guenther, feedback jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.41 2013/04/16 07:36:55 yasuoka Exp $	*/
d853 1
d857 3
d862 1
d865 2
a866 3
			 * if mbuf which queued pipexinq has
			 * session reference pointer, the
			 * referenced session must not destroy.
d868 1
a868 2
			if (!IF_IS_EMPTY(&pipexinq) ||
			    !IF_IS_EMPTY(&pipexoutq))
@


1.41
log
@When pipex session is terminated by idle timer, there was a problem that
the session is removed from the pipex_closed_wait_list twice, fixed it.
It always causes panic because QUEUE_MACRO_DEBUG is enabled by default.
Also remove some needless (struct pipex_session *) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.40 2013/03/28 23:10:05 tedu Exp $	*/
a3063 4
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

d3066 2
d3070 6
@


1.40
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.39 2013/03/28 16:45:16 tedu Exp $	*/
d523 1
a523 1
		LIST_REMOVE((struct pipex_session *)session, state_list);
d582 2
a583 1
		LIST_REMOVE((struct pipex_session *)session, state_list);
d585 1
a585 1
			if (LIST_NEXT(session, state_list))
d611 2
a612 2
	LIST_REMOVE((struct pipex_session *)session, id_chain);
	LIST_REMOVE((struct pipex_session *)session, session_list);
d615 1
a615 2
		LIST_REMOVE((struct pipex_session *)session,
		    peer_addr_chain);
d620 1
a620 2
		LIST_REMOVE((struct pipex_session *)session,
		    peer_addr_chain);
d852 1
@


1.39
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.38 2013/02/13 22:10:38 yasuoka Exp $	*/
d39 1
@


1.38
log
@Pipex did panic when the 0 length mppe is given by ioctl.  Return
EINVAL instead of panic.  Also npppd called ioctl with the invalid
argument because of the bugs introduced by the config parser change
commit.  Fixed those bugs and make sure not to use 0 length keys for
MPPE.

reported by csszep at gmail and giovanni
ok giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.37 2012/12/14 01:19:26 dlg Exp $	*/
a29 1
#include <sys/proc.h>
@


1.37
log
@oops, debug printf sneaked in. i must be out of practice.

spotted by krw@@, poked by jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.36 2012/12/13 06:59:36 dlg Exp $	*/
d399 5
a403 1
    	if ((req->pr_ppp_flags & PIPEX_PPP_MPPE_ACCEPTED) != 0)
d407 6
a412 1
    	if ((req->pr_ppp_flags & PIPEX_PPP_MPPE_ENABLED) != 0)
d416 1
@


1.36
log
@pipex_init can be called multiple times (by whatever subsystems want to use
it), so return early if the work has already been done.

ok yasuoka@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.35 2012/09/28 16:09:05 markus Exp $	*/
d132 1
a132 2
	if (pipex_softintr != NULL) {
		printf("pipex_init called twice\n");
a133 1
	}
@


1.35
log
@fix adress family for ipv6 bpf packet capture; ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.34 2012/09/19 22:37:23 jsg Exp $	*/
d131 5
@


1.34
log
@ioctl requests are u_long not int, spotted via clang
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.33 2012/09/19 17:50:17 yasuoka Exp $	*/
d1238 1
a1238 1
		bpf_mtap_af(ifp->if_bpf, AF_INET, m0, BPF_DIRECTION_IN);
@


1.33
log
@cleanup around the pipex.  naming style, delete or update comments.
no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.32 2012/09/10 07:20:58 yasuoka Exp $	*/
d207 1
a207 1
pipex_ioctl(struct pipex_iface_context *pipex_iface, int cmd, caddr_t data)
@


1.32
log
@drop the unencrypted packets when the MPPE is required.  This was
missing on IPv6 path only.

From brad
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.31 2012/09/10 07:14:33 yasuoka Exp $	*/
a27 3
/*
 * PIPEX(PPPAC IP Extension)
 */
d152 1
a152 1
	pipex_iface->pipexmode = PIPEX_DISABLE;
d180 1
a180 1
	pipex_iface->pipexmode |= PIPEX_ENABLED;
d191 1
a191 1
	pipex_iface->pipexmode = PIPEX_DISABLE;
d209 1
a209 1
	int mode, ret;
d213 3
a215 3
		mode = *(int *)data;
		if (pipex_iface->pipexmode != mode) {
			if (mode == PIPEX_ENABLE)
d272 1
a272 1
	if (iface->pipexmode != PIPEX_ENABLE)
d280 1
a280 1
		if (req->peer_address.ss_family != AF_UNSPEC)
d291 1
a291 1
		switch (req->peer_address.ss_family) {
d293 2
a294 1
			if (req->peer_address.ss_len != sizeof(struct sockaddr_in))
d299 2
a300 1
			if (req->peer_address.ss_len != sizeof(struct sockaddr_in6))
d307 4
a310 4
		if (req->peer_address.ss_family !=
		    req->local_address.ss_family ||
		    req->peer_address.ss_len !=
		    req->local_address.ss_len)
d345 6
a350 6
	if (req->peer_address.ss_len > 0)
		memcpy(&session->peer, &req->peer_address,
		    MIN(req->peer_address.ss_len, sizeof(session->peer)));
	if (req->local_address.ss_len > 0)
		memcpy(&session->local, &req->local_address,
		    MIN(req->local_address.ss_len, sizeof(session->local)));
@


1.31
log
@add missing the congestion indicator code on IPv6 path.

From brad
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.30 2012/07/17 03:18:57 yasuoka Exp $	*/
d1076 6
a1081 1
		/* XXX: support MPPE */
@


1.30
log
@use IPsec flowinfo on pipex(4) to select the IPsec tunnel for sending
L2TP packets.

ok markus henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.29 2012/05/05 14:48:51 yasuoka Exp $	*/
d1241 2
@


1.29
log
@pipex_ip6_input() called IF_DROP() with incorrect queue.

diff from blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.28 2012/04/22 15:27:24 yasuoka Exp $	*/
d393 1
d1978 2
a1979 1
		if (ip_output(m0, NULL, NULL, 0, NULL, NULL) != 0) {
d2071 2
a2072 1
pipex_l2tp_input(struct mbuf *m0, int off0, struct pipex_session *session)
d2082 1
@


1.28
log
@Remove redundant returns from functions returning void.  Wrap return
values in () for consistency.

diff from Michael W. Bombardieri.
ok sthen dlg mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.27 2012/04/04 04:31:38 yasuoka Exp $	*/
d1238 1
a1238 1
		IF_DROP(&ipintrq);
@


1.27
log
@pipex hook in udp_usrreq() mistakenly assumed that `inp' is connected.
It could not use the destination address properly, so it failed to
find the pipex session.  This bug caused LCP keepalive failures on some
clients.

found and tested by sebastia@@ and mxb at alumni.chalmers.se.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.26 2012/01/31 12:04:20 markus Exp $	*/
a205 2

	return;
a759 2

	return;
a960 1
	return;
a1013 1
	return;
a1093 2

	return;
a1184 2

	return;
a1257 2

	return;
a1455 2

	return;
a1546 1
	return;
a2016 2

	return;
a2559 2

	return;
a2963 2

	return;
d2977 1
a2977 1
	return 0;
@


1.26
log
@add missing calls to pf_pkt_addr_changed(); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.25 2012/01/23 03:36:21 yasuoka Exp $	*/
d2228 1
a2228 1
Static struct pipex_session *
d2235 3
@


1.25
log
@The ingress filter of pipex and npppd become configurable and disabled
by default.  After this change we need to add

  ppp.ingress_filter: true

to npppd.conf if it is needed.

ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.24 2012/01/18 02:02:53 yasuoka Exp $	*/
d57 5
d1235 4
d1521 3
d1972 3
@


1.24
log
@Fix a problem that causes LCP keepalive timeout.  In case the ack number of
a packet that is passed to the userland has not incremented, `pipex' passed
the packet mistakenly with invalid ack number.  Then `npppd' will drop these
packets, so that caused the problem.

tested jmatthew
ok jmatthew
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.23 2011/11/25 13:05:06 yasuoka Exp $	*/
d1127 10
a1136 9

	/* ingress filter */
	ip = mtod(m0, struct ip *);
	if ((ip->ip_src.s_addr & session->ip_netmask.sin_addr.s_addr) !=
	    session->ip_address.sin_addr.s_addr) {
		pipex_session_log(session, LOG_DEBUG,
		    "ip packet discarded by ingress filter (src %s)",
		    inet_ntoa(ip->ip_src));
		goto drop;
@


1.23
log
@fix compile errors without INET6.  no binary change.

pointed out by Julien Crapovich on misc@@
ok deraadt mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.22 2011/10/15 03:24:11 yasuoka Exp $	*/
d1663 2
a1664 4
		} else {
			ack++;
			pptp_session->snd_una = ack;
		}
d1707 1
a1707 3
	/* revert original seq/ack values */
	seq--;
	ack--;
@


1.22
log
@Added "provision for rewound PPP frames" that allows receiving
reorder packets to pass to the upper layer without reorder.  It
will improve performance (throughput or loss rate) for PPTP or
L2TP(/IPesc) on networks that latency is unstable such as mobile
network.

As our test environment (bandwidth: 6Mbps, latency: 50ms for 97% of
traffic and 52ms for rest of traffic), throughput has changed from
0.76MB to 2.17MB on file upload by PPTP connected Windows Vista
ftp.exe.

Developed by UMEZAWA Takeshi at IIJ.

ok jmatthew@@
tested jmatthew@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.21 2011/07/09 04:11:15 dhill Exp $	*/
d1261 1
a1390 1
#endif
d1908 1
d1911 3
d1929 1
d1932 3
@


1.21
log
@honor the net.inet.udp.checksum setting.

ok claudio henning yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.20 2011/07/08 19:34:04 yasuoka Exp $	*/
a121 3
/* see the comment on pipex_mppe_input() */
#define	WORKAROUND_OUT_OF_SEQUENCE_PPP_FRAMING	1

d394 3
a396 1
		pipex_mppe_req_init(&req->pr_mppe_recv, &session->mppe_recv);
d398 3
a400 1
		pipex_mppe_req_init(&req->pr_mppe_send, &session->mppe_send);
d613 3
d1621 1
d1658 2
a1659 2
			reason = "ack out of sequence";
			goto inseq;
d1662 1
a1662 1
			goto inseq;
d1673 6
a1678 2
		reason = "out of sequence";
		goto inseq;
d1690 6
a1695 5
	pptp_session->rcv_nxt = seq;

	if (SEQ32_SUB(seq, pptp_session->rcv_acked) >
	    roundup(pptp_session->winsz, 2) / 2) /* Send ack only packet. */
		pipex_pptp_output(NULL, session, 0, 1);
d1700 3
a1702 2
		session->proto.pptp.rcv_gap += nseq;
		return (m0);
d1704 4
d1738 1
a1738 1
inseq:
d2072 1
d2117 6
a2122 3

		if (SEQ16_LT(ns, l2tp_session->nr_nxt))
			goto out_seq;
d2126 2
a2127 1
		l2tp_session->nr_nxt = ns;
d2136 2
a2137 1
		session->proto.l2tp.nr_gap += nseq;
d2141 3
a2305 1

d2307 2
a2308 1
pipex_mppe_req_init(struct pipex_mppe_req *mppe_req, struct pipex_mppe *mppe)
d2310 2
a2311 1
	if (mppe_req->stateless)
d2313 7
a2319 2
	memcpy(mppe->master_key, mppe_req->master_key,
	    sizeof(mppe->master_key));
d2321 2
a2322 2
	mppe->keylenbits = mppe_req->keylenbits;
	switch (mppe_req->keylenbits) {
d2335 19
a2353 1
	rc4_keysetup(&mppe->rc4ctx, mppe->session_key, mppe->keylen);
d2405 1
a2405 1
	struct pipex_mppe keychg;	/* just for rc4ctx */
d2412 2
a2413 2
	rc4_keysetup(&keychg.rc4ctx, interim, mppe->keylen);
	rc4_crypt(&keychg.rc4ctx, interim, mppe->session_key, mppe->keylen);
d2416 6
d2432 1
a2460 1
#ifdef	WORKAROUND_OUT_OF_SEQUENCE_PPP_FRAMING
d2478 9
a2486 4
		pipex_session_log(session, LOG_DEBUG,
		    "Workaround the out-of-sequence PPP framing problem: "
		    "%d => %d", mppe->coher_cnt, coher_cnt);
		goto drop;
d2489 1
a2489 1
#endif
d2491 1
a2491 2
		mppe_key_change(mppe);
		while (mppe->coher_cnt != coher_cnt) {
d2493 6
a2498 3
			mppe->coher_cnt++;
			mppe->coher_cnt &= PIPEX_COHERENCY_CNT_MASK;
			pktloss++;
d2500 1
a2500 1
		flushed = 1;
d2525 2
d2528 1
a2528 1
#ifndef	WORKAROUND_OUT_OF_SEQUENCE_PPP_FRAMING
a2532 3
#endif
	if (flushed)
		rc4_keysetup(&mppe->rc4ctx, mppe->session_key, mppe->keylen);
d2538 1
a2538 1
		rc4_crypt(&mppe->rc4ctx, cp, cp, len);
d2541 5
a2545 3
	/* update coher_cnt */
	mppe->coher_cnt++;
	mppe->coher_cnt &= PIPEX_COHERENCY_CNT_MASK;
d2612 1
a2612 1
		rc4_keysetup(&mppe->rc4ctx, mppe->session_key, mppe->keylen);
d2637 1
a2637 1
		rc4_crypt(&mppe->rc4ctx, cp, cp, len);
d3004 29
a3032 1
	return -1;
@


1.20
log
@Last part of pipex_{pppoe,l2tp,pptp}_input() are almost identical.
Integrate them into pipex_common_input().

ok hsuenaga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.19 2011/07/08 18:30:17 yasuoka Exp $	*/
d112 3
d1950 6
a1955 3
		udp->uh_sum = in_cksum_phdr(ip->ip_src.s_addr,
		    ip->ip_dst.s_addr, htons(plen  + IPPROTO_UDP));
		m0->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
@


1.19
log
@Include PIPEX in kernel by default.  And add new sysctl variable
`net.pipex.enable' to enable PIPEX.   By default, pipex is disabled
and it will not process packets from wire.  Update man pages and
update HOWTO_PIPEX_NPPPD.txt for testers.

discussed with dlg@@, ok deraadt@@ mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.18 2011/07/07 22:32:51 mcbride Exp $	*/
d1255 58
d1388 1
d1398 5
a1402 27
	/* cut off PPPoE Header */
	m_adj(m0, sizeof(struct ether_header) +
	    sizeof(struct pipex_pppoe_header));

	/* ensure the mbuf length equals the PPP frame length */
	pppoe.length = ntohs(pppoe.length);
	if (pppoe.length < PIPEX_PPPMINLEN)
		goto drop;
	if (m0->m_pkthdr.len < pppoe.length)
		goto drop;
	if (m0->m_pkthdr.len > pppoe.length) {
		if (m0->m_len == m0->m_pkthdr.len) {
			m0->m_len = pppoe.length;
			m0->m_pkthdr.len = pppoe.length;
		} else
			m_adj(m0, pppoe.length - m0->m_pkthdr.len);
	}

	/* input ppp packets to kernel session */
	if (pipex_ppp_enqueue(m0, session, &pipexinq))
		goto drop;
	
	return (NULL);

drop:
	if (m0 != NULL)
		m_freem(m0);
a1459 1

d1607 1
a1607 1
	int hlen, plen, ppphlen, has_seq, has_ack, nseq, proto;
d1609 1
a1609 1
	u_char *cp, *seqp = NULL, *ackp = NULL, code;
d1684 5
a1688 21
	if (m0->m_pkthdr.len < hlen + PIPEX_PPPMINLEN)
		goto drop;

	proto = pipex_ppp_proto(m0, session, hlen, &ppphlen);
	switch (proto) {
#ifdef PIPEX_MPPE
	case PPP_CCP:
		code = 0;
		KASSERT(m0->m_pkthdr.len >= hlen + ppphlen + 1);
		m_copydata(m0, hlen + ppphlen, 1, (caddr_t)&code);
		if (code != CCP_RESETREQ && code != CCP_RESETACK)
			goto not_ours;
		break;

	case PPP_COMP:
#endif
	case PPP_IP:
		break;

	default:
		goto not_ours;
a1689 22

	/* ok,  The packet is for PIPEX */
	session->proto.pptp.rcv_gap += nseq;
	plen = ntohs(gre->len);			/* payload length */
	m_adj(m0, hlen);			/* cut off the IP/GRE header */

	/* ensure the mbuf length equals the PPP frame length */
	if (m0->m_pkthdr.len < plen)
		goto drop;
	if (m0->m_pkthdr.len > plen) {
		if (m0->m_len == m0->m_pkthdr.len) {
			m0->m_len = plen;
			m0->m_pkthdr.len = plen;
		} else
			m_adj(m0, plen - m0->m_pkthdr.len);
	}

	/* input ppp packets to kernel session */
	if (pipex_ppp_enqueue(m0, session, &pipexinq))
		goto drop;

	return (NULL);
d2048 2
a2049 2
	int length, offset, hlen, nseq, proto, ppphlen;
	u_char *cp, *nsp, *nrp, code;
d2099 3
a2101 3
	ns++;
	nseq = SEQ16_SUB(ns, l2tp_session->nr_nxt);
	l2tp_session->nr_nxt = ns;
a2105 32
	if (m0->m_pkthdr.len < off0 + hlen + offset + PIPEX_PPPMINLEN)
		goto drop;

	proto = pipex_ppp_proto(m0, session, off0 + hlen + offset, &ppphlen);
	switch (proto) {
#ifdef	PIPEX_MPPE
	case PPP_CCP:
		code = 0;
		m_copydata(m0, hlen + ppphlen, 1, &code);
		if (code != CCP_RESETREQ && code != CCP_RESETACK)
			goto not_ours;
		break;

	case PPP_COMP:
#endif
	case PPP_IP:
#if 0 /* NOT YET */
#ifdef INET6
	case PPP_IPV6:
#endif
#endif
		break;

	default:
		goto not_ours;
	}

	/* ok,  The packet is for PIPEX */
	session->proto.l2tp.nr_gap += nseq;

	/* cut off the header and offset */
	m_adj(m0, off0 + hlen + offset);
d2107 5
a2111 10

	/* ensure the mbuf length equals the PPP frame length */
	if (m0->m_pkthdr.len < length)
		goto drop;
	if (m0->m_pkthdr.len > length) {
		if (m0->m_len == m0->m_pkthdr.len) {
			m0->m_len = length;
			m0->m_pkthdr.len = length;
		} else
			m_adj(m0, length - m0->m_pkthdr.len);
a2113 6
	/* input ppp packets to kernel session */
	if (pipex_ppp_enqueue(m0, session, &pipexinq))
		goto drop;

	return (NULL);
not_ours:
@


1.18
log
@We should not have any direct initialization of ifq structures.
(in this case it's unnecessary, bss is initialized to zero at boot)

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.17 2011/04/05 18:01:21 henning Exp $	*/
d39 1
d88 1
d2982 18
@


1.17
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.16 2011/03/14 06:53:33 yasuoka Exp $	*/
d101 2
a102 2
struct ifqueue pipexinq = { NULL };
struct ifqueue pipexoutq = { NULL };
@


1.16
log
@fixed a use-after-free bug introduced at 1.7 in pipex_mppe_output().

ok dlg@@
tested by jono
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.15 2011/02/24 04:21:34 yasuoka Exp $	*/
d1949 1
a1949 1
		m0->m_pkthdr.csum_flags |= M_UDPV4_CSUM_OUT;
@


1.15
log
@Don't use address and control field on PPPoE, they must not be used as
the protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.14 2011/01/28 06:43:00 dlg Exp $	*/
a2547 7
	/* prepend mppe header */
	M_PREPEND(m0, sizeof(struct mppe_header), M_NOWAIT);
	if (m0 == NULL)
		goto drop;
	hdr = mtod(m0, struct mppe_header *);
	hdr->protocol = protocol;

d2562 6
@


1.14
log
@make sure that the size of the addresses userland is trying to configure
make sense, not just the family.

from jonathan matthew
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.13 2010/09/29 22:15:54 yasuoka Exp $	*/
d968 5
a972 2
	PUTCHAR(PPP_ALLSTATIONS, cp);
	PUTCHAR(PPP_UI, cp);
@


1.13
log
@pipex_pptp_userland_output() calls always m_pullup() 16 bytes to the
GRE message.  But when npppd send a ack-only GRE message, the message
will be only 12 bytes, so the m_pullup() will fail.  call m_pullup()
with proper length.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.12 2010/09/28 14:14:54 yasuoka Exp $	*/
d291 3
d296 1
a296 3
#endif
			if (req->peer_address.ss_family !=
			    req->local_address.ss_family)
d299 1
d303 5
@


1.12
log
@wrap long line.  correct indent.  delete a useless comment.

OK djm@@ claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.11 2010/09/26 07:04:43 yasuoka Exp $	*/
d1811 2
a1812 1
	struct pipex_gre_header *gre;
d1817 9
d1827 1
a1827 1
	PIPEX_PULLUP(m0, sizeof(struct pipex_gre_header) + 8);
d1829 1
a1829 2
		PIPEX_DBG((session, LOG_DEBUG,
		    "gre header is too short."));
a1834 1
	flags = ntohs(gre->flags);
@


1.11
log
@Length field in L2TP header was broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.10 2010/09/24 14:50:30 hsuenaga Exp $	*/
d961 3
a963 3
			PUTCHAR(PPP_ALLSTATIONS, cp);
			PUTCHAR(PPP_UI, cp);
		PUTSHORT(proto, cp);
a1505 1
	/* pullup */
@


1.10
log
@Add L2TP support to PIPEX.
We can use IPv6 address as outer header of L2TP.

Kernel ABI is changed. You must update npppd.

OK @@claudio, yasuoka@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.9 2010/09/22 13:03:48 claudio Exp $	*/
a1904 1
		l2tp->length += sizeof(struct pipex_l2tp_seq_header);
@


1.9
log
@Add a new interface pppx(4) -- the ppp multiplexer to be used with npppd
and pipex. pppx(4) creates an interface whenever a session is created
so that altq and pf can work on these.
Started by dlg@@ debugged and made usable by myself
OK dlg@@ yasuoka@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.8 2010/09/21 07:44:54 yasuoka Exp $	*/
d45 1
a45 1

d48 1
d68 4
d74 1
d94 1
d96 1
d105 1
d129 1
d158 6
a266 2
	struct ether_header *eh;
	struct sockaddr peer_addr;
d278 2
a279 6
		bzero(&peer_addr, sizeof(peer_addr));
		peer_addr.sa_family = AF_UNSPEC;
		eh = (struct ether_header *)&peer_addr.sa_data;
		eh->ether_type = htons(ETHERTYPE_PPPOE);
		memcpy(&eh->ether_dhost, &req->pr_proto.pppoe.peer_address,
		    sizeof(eh->ether_dhost));
d282 1
d285 16
d334 6
d341 1
a341 2
	if (req->pr_protocol == PIPEX_PROTO_PPPOE) {
		session->proto.pppoe.peer_addr = peer_addr;
a342 1
	}
d346 35
a380 14
		session->proto.pptp.snd_gap = 0;
		session->proto.pptp.rcv_gap = 0;
		session->proto.pptp.snd_una = req->pr_proto.pptp.snd_una;
		session->proto.pptp.snd_nxt = req->pr_proto.pptp.snd_nxt;
		session->proto.pptp.rcv_nxt = req->pr_proto.pptp.rcv_nxt;
		session->proto.pptp.rcv_acked = req->pr_proto.pptp.rcv_acked;
		session->proto.pptp.winsz = req->pr_proto.pptp.winsz;
		session->proto.pptp.maxwinsz = req->pr_proto.pptp.maxwinsz;
		session->proto.pptp.peer_maxwinsz
		    = req->pr_proto.pptp.peer_maxwinsz;
		session->proto.pptp.peer_address =
		    req->pr_proto.pptp.peer_address;
		session->proto.pptp.our_address =
		    req->pr_proto.pptp.our_address;
d400 15
a414 4
	if (pipex_lookup_by_ip_address(session->ip_address.sin_addr) != NULL) {
		splx(s);
		free(session, M_TEMP);
		return (EADDRINUSE);
d416 9
a424 7

	rn = pipex_rd_head4.rnh_addaddr(&session->ip_address,
	    &session->ip_netmask, &pipex_rd_head4, session->ps4_rn, RTP_STATIC);
	if (rn == NULL) {
		splx(s);
		free(session, M_TEMP);
		return (ENOMEM);
d430 3
a432 2
#ifdef PIPEX_PPTP
	if (req->pr_protocol == PIPEX_PROTO_PPTP) {
d434 1
a434 1
		    session->proto.pptp.peer_address.s_addr);
a436 1
#endif
d553 1
a553 1
		LIST_REMOVE(session, state_list);
d573 7
a579 4
	rn = pipex_rd_head4.rnh_deladdr(&session->ip_address,
	    &session->ip_netmask, &pipex_rd_head4,
	    (struct radix_node *)session);
	KASSERT(rn != NULL);
d589 6
d699 2
a700 1
				if (session->ip_forward == 0)
d707 1
a707 1
				pipex_ppp_output(m0, session, PPP_IP);
d711 1
a711 1
			pipex_ppp_output(m, tag->session, PPP_IP);
d767 1
d858 2
d872 14
d913 1
a913 1
		if (session->ip_forward == 0)
a960 2
	if (pipex_session_has_acf(session)) {
		if (!pipex_session_is_acfc_enabled(session)) {
a962 5
		}
	}
	if (pipex_session_is_pfc_enabled(session) && proto <= 0xff)
		PUTCHAR(proto, cp);	/* protocol field compression */
	else
d981 5
d1002 2
d1005 1
a1005 1
	switch ((proto = pipex_ppp_proto(m0, session, 0, &hlen))) {
d1007 1
a1007 1
	case PPP_CCP:
d1011 1
a1011 1
		pipex_ccp_input(m0, session);
d1013 2
a1014 1
	case PPP_COMP:
d1017 8
d1026 1
a1026 1
		pipex_mppe_input(m0, session);
d1028 1
d1030 11
d1053 9
d1096 13
d1172 71
d1313 1
d1400 1
a1400 1
	over_ifp->if_output(over_ifp, m0, &session->proto.pppoe.peer_addr,
d1454 2
a1455 2
	ip->ip_src = session->proto.pptp.our_address;
	ip->ip_dst = session->proto.pptp.peer_address;
d1474 2
a1475 2
		session->proto.pptp.rcv_acked = session->proto.pptp.rcv_nxt;
		PUTLONG(session->proto.pptp.rcv_nxt - 1, cp);
d1684 1
a1684 1
	ack--;	
d1729 25
a1753 1
pipex_pptp_userland_lookup_session(struct mbuf *m0, struct in_addr dst)
d1788 1
a1788 1
	list = PIPEX_PEER_ADDR_HASHTABLE(dst.s_addr);
d1790 2
a1791 1
		if (session->proto.pptp.peer_address.s_addr != dst.s_addr)
d1799 2
a1800 2
		    "<%s> session not found (dst=%s,call_id=%d)",
		    __func__, inet_ntoa(dst), (int)gre.call_id));
d1853 445
d2910 3
a2912 2
		    (session->protocol == PIPEX_PROTO_PPTP)? "PPTP" : "Unknown",
		    session->session_id);
d2922 43
@


1.8
log
@Cleanup handlings for memory shortage condition:

- use rn_inithead0() instead of rn_inithead() to avoid failures on memory
  shortage.
- delete a needless failure handling for malloc(,M_WAITOK) in
  pipex_add_session().

pointed out by blambert@@.  ok hsuenaga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.7 2010/07/09 08:36:31 yasuoka Exp $	*/
d81 1
a81 1
static LIST_HEAD(pipex_hash_head, pipex_session)
d86 5
a90 4
static struct radix_node_head pipex_rd_head4;
static int pipex_rd_head4_initialized = 0;
static struct timeout pipex_timer_ch; 		/* callout timer context */
static int pipex_prune = 1;			/* walk list every seconds */
@


1.7
log
@Modified to make sure that pipex_mppe_ouput() keeps the packet 32bit
aligned.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.6 2010/07/08 08:40:29 yasuoka Exp $	*/
d86 2
a87 1
static struct radix_node_head *pipex_rd_head4 = NULL;
a135 1
	void *ptr;
d141 5
a145 7
	if (pipex_rd_head4 == NULL) {
		/* XXX avoid dereferencing pointer warning */
		ptr = pipex_rd_head4;

		rn_inithead(&ptr, offsetof(struct sockaddr_in, sin_addr) *
		    NBBY);
		pipex_rd_head4 = ptr;
a280 3
	if (session == NULL) 
		return (ENOMEM);

d353 2
a354 2
	rn = pipex_rd_head4->rnh_addaddr(&session->ip_address,
	    &session->ip_netmask, pipex_rd_head4, session->ps4_rn, RTP_STATIC);
d507 3
a509 2
	rn = pipex_rd_head4->rnh_deladdr(&session->ip_address,
	    &session->ip_netmask, pipex_rd_head4, (struct radix_node *)session);
d546 2
a547 2
	session = (struct pipex_session *)pipex_rd_head4->rnh_lookup(
	    &pipex_in4, &pipex_in4mask, pipex_rd_head4);
@


1.6
log
@pipex didn't work on output.  Fixed following problems:
 - pipex failed to lookup the radix tree because address and netmask
   were not initialized.
 - pipex used wrong place as a ip header because it didn't adjust
   32bit address family header that are added at tun_output.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.5 2010/07/03 00:16:07 yasuoka Exp $	*/
a861 1
	int mppe = 0;
d865 4
a868 2
		if (proto == PPP_IP) 
			mppe = 1;
d872 1
a872 1
	if (!mppe && pipex_session_has_acf(session)) {
d878 1
a878 1
	if (!mppe && pipex_session_is_pfc_enabled(session) && proto <= 0xff)
a887 7
#ifdef PIPEX_MPPE
	if (mppe) {
		pipex_mppe_output(m0, session);
		return;
	}
#endif /* PIPEX_MPPE */

d1844 2
a1845 1
pipex_mppe_output(struct mbuf *m0, struct pipex_session *session)
d1848 4
a1851 1
	uint16_t coher_cnt;
d1859 1
a1859 4
	M_PREPEND(m0, sizeof(coher_cnt), M_NOWAIT);
	if (m0 == NULL)
		goto drop;
	m0 = m_pullup(m0, 2);
d1862 3
a1878 1
	cp = mtod(m0, u_char *);
d1905 2
a1906 2
	coher_cnt = (mppe->coher_cnt++) & PIPEX_COHERENCY_CNT_MASK;
	mppe->coher_cnt &= PIPEX_COHERENCY_CNT_MASK;
d1908 1
a1908 1
		coher_cnt |= 0x8000;
d1910 1
a1910 1
		coher_cnt |= 0x1000;
d1912 2
a1913 3
	PUTSHORT(coher_cnt, cp);
	len = m0->m_len - 2;
	rc4_crypt(&mppe->rc4ctx, cp, cp, len);
d1916 1
a1916 1
	for (m = m0->m_next; m; m = m->m_next) {
d1919 4
@


1.5
log
@s/$Id$/$OpenBSD$/
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex.c,v 1.4 2010/07/02 02:40:16 blambert Exp $	*/
d540 1
d544 2
d779 2
a780 2
struct pipex_session *
pipex_ip_lookup_session(struct mbuf *m0,
d786 13
a798 6
	/* length check */
	if (m0->m_pkthdr.len < sizeof(struct ip)) {
		PIPEX_DBG((NULL, LOG_DEBUG, 
		    "<%s> packet length is too short", __func__));
		return (NULL);
	}
d800 4
a803 12
	/* copy ip header info */
	m_copydata(m0, 0, sizeof(struct ip), (caddr_t)&ip);

	if (IN_MULTICAST(ip.ip_dst.s_addr) && pipex_iface != NULL)
		return (pipex_iface->multicast_session);

	/* lookup pipex session table */
	session = pipex_lookup_by_ip_address(ip.ip_dst);
	if (session == NULL) {
		PIPEX_DBG((NULL, LOG_DEBUG, "<%s> session not found.",
		    __func__));
		return (NULL);
d806 1
a806 1
	return (session);
d809 1
a809 1
void
@


1.4
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 2
a2 1
/*	$Id: pipex.c,v 1.3 2010/01/13 07:23:38 yasuoka Exp $	*/
@


1.3
log
@cleanup pipex code.  ok henning@@
@
text
@d1 1
a1 1
/*	$Id: pipex.c,v 1.2 2010/01/13 06:05:47 dlg Exp $	*/
d1183 2
a1184 1
		m_copyback(m0, m0->m_pkthdr.len, padlen, pipex_pppoe_padding);
@


1.2
log
@replace static on functions with Static so openbsd can define it away
to nothing. this lets us see functions in ddb, while not hurting the
ability to share the code with other projects.

idea borrowed from the usb stack.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$Id: pipex.c,v 1.1 2010/01/11 03:50:56 yasuoka Exp $	*/
a29 8
/*
 * FIXME: don't use != 1 for boolean like variable names.
 * FIXME: we don't use sysctl now, delete sysctl comments.
 */
#ifdef _KERNEL_OPT
#include "opt_inet.h"
#include "opt_pipex.h"
#endif
a40 3
#if defined(__OpenBSD__)
#include <sys/timeout.h>
#endif
a44 4
#if defined(__NetBSD__)
#include <machine/stdarg.h>
#include <net/if_ether.h>
#else
a46 1
#endif
d69 4
a76 11
#ifdef PIPEX_MPPE
#ifdef NBSAFE_RC4
#include <lib/libnbsafe/nbsafe.h>
#else
#if defined(__NetBSD__)
#include <crypto/arc4/arc4.h>
#else
#include <crypto/arc4.h>
#endif
#endif
#endif
a94 1
#if defined(__OpenBSD__) || defined(__HAVE_GENERIC_SOFT_INTERRUPTS)
a96 4
#else
struct callout pipex_softintr = CALLOUT_INITIALIZER;
void pipex_softintr_handler(void *);
#endif
a110 3
/*
 * pipex_init - first initialize of pipex.
 */
a124 1
#if defined(__OpenBSD__) || defined(__HAVE_GENERIC_SOFT_INTERRUPTS)
a126 1
#endif
a128 3
/*
 * pipex_iface_init - interface pipex initiilze.
 */
a156 3
/*
 * pipex_start - start interface pipex.
 */
a162 3
/*
 * pipex_stop - clear interface pipex sessions.
 */
d187 1
a187 3
/*
 * pppac_ioctl.  Please call with the mutex of outer object of 'pipex_iface'.
 */
d211 1
a211 1
		return ret;
d216 1
a216 1
		return ret;
d221 1
a221 1
		return ret;
d225 1
a225 1
		return ret;
d232 1
a232 1
		return ENOTTY;
d235 1
a235 1
	return 0;
d257 1
a257 1
		return ENXIO;
d263 1
a263 1
			return EINVAL;
d266 1
a266 1
		eh = (struct ether_header*)&peer_addr.sa_data;
d277 1
a277 1
		return EPROTONOSUPPORT;
d283 1
a283 1
		return ENOMEM;
a334 5
#if 1
#define	arc4_ctxlen()		(sizeof(struct rc4_ctx))
#endif
	KASSERT(arc4_ctxlen() <= PIPEX_RC4_CTXLEN);

d344 1
a344 1
			return EINVAL;
d354 1
a354 1
		return EADDRINUSE;
a358 1
	KASSERT(rn != NULL);
d362 1
a362 1
		return ENOMEM;
d384 1
a384 1
	return 0;
d398 1
a398 1
	return 0;
d408 1
a408 1
	LIST_FOREACH(session, &pipex_session_list, session_list) {
a410 1
	}
d413 1
a413 1
	return 0;
d427 1
a427 1
		return EINVAL;
d439 1
a439 1
	return 0;
d453 1
a453 1
		return EINVAL;
d458 1
a458 1
	return 0;
d472 1
a472 1
		return EINVAL;
d477 1
a477 1
	return 0;
d487 1
a487 1
	bzero((u_char *)req, sizeof(struct pipex_session_list_req));
d491 1
a491 1
		LIST_REMOVE((struct pipex_session *)session, state_list);
d500 1
a500 1
	return 0;
a510 1
	rn = NULL;
a527 1

d530 1
a530 1
	return 0;
d537 1
a537 8
	struct sockaddr_in pipex_in4 = {
	    .sin_family = AF_INET,
	    .sin_len = sizeof(struct sockaddr_in),
	}, pipex_in4mask = {
	    .sin_family = AF_INET,
	    .sin_len = sizeof(struct sockaddr_in),
	    .sin_addr = { .s_addr = htonl(0xFFFFFFFFL) }
	};
d540 5
d555 1
a555 1
	return session;
d578 1
a578 1
	return session;
a583 1
#if defined(__OpenBSD__) || defined(__HAVE_GENERIC_SOFT_INTERRUPTS)
a589 12
#else
void
pipex_softintr_handler(void *dummy)
{
	int s;

	s = splsoftnet();
	pipex_ppp_dequeue();
	callout_deactivate(&pipex_softintr);
	splx(s);
}
#endif
a609 1
		KASSERT(mtag != NULL);
a648 1
		KASSERT(mtag != NULL);
d662 1
a662 2
	if (!IF_IS_EMPTY(&pipexinq) || !IF_IS_EMPTY(&pipexoutq)) {
#if defined(__OpenBSD__) || defined(__HAVE_GENERIC_SOFT_INTERRUPTS)
a663 6
#else
		if (!callout_active(&pipex_softintr))
			callout_reset(&pipex_softintr, 1,
			    pipex_softintr_handler, NULL);
#endif
	}
a694 1
#if defined(__OpenBSD__) || defined(__HAVE_GENERIC_SOFT_INTERRUPTS)
d696 1
a696 6
#else
	if (!callout_active(&pipex_softintr))
		callout_reset(&pipex_softintr, 1, pipex_softintr_handler,
		    NULL);
#endif
	return 0;
d699 2
a700 5
	/*
	 * if pipex_ppp_enqueue is failed,
	 * it is necessary to free mbuf.
	 */
	return 1;
a705 3
/*
 * pipex_timer_start
 */
a708 1
	/* init timeout */
a712 3
/*
 * pipex_timer_stop
 */
a718 3
/*
 * pipex_timer
 */
a774 3
/*
 * pipex_ip_lookup_session - assuming that the IP packet was inputted.
 */
d776 2
a777 2
pipex_ip_lookup_session(struct mbuf *m0, struct pipex_iface_context
    *pipex_iface)
d786 1
a786 1
		return NULL;
d793 1
a793 1
		return pipex_iface->multicast_session;
d800 1
a800 1
		return NULL;
d803 1
a803 1
	return session;
a805 3
/*
 * pipex_ip_output - output an ip packet to the tunnel.
 */
d840 1
a840 1
	} else {
a841 1
	}
a844 1
		/* enqueue failed. */
d869 1
a869 3
		if (pipex_session_is_acfc_enabled(session)) {
			/* address and control field compression */
		} else {
d874 1
a874 1
	if (!mppe && pipex_session_is_pfc_enabled(session) && proto <= 0xff) {
d876 1
a876 1
	} else {
a877 1
	}
d897 1
a897 1
#ifdef	PIPEX_PPTP
a902 3
#ifdef DIAGNOSTIC
		panic("NOTREACHED %s:%s:%d", __func__, __FILE__, __LINE__);
#endif
a913 3
/*
 * pipex_ppp_input
 */
a963 3
/*
 * pipex_ip_input
 */
a967 1
	struct ifqueue *ifq = &ipintrq;
a978 8
#if defined(__NetBSD__)
	/* some components assume ip packet is aligned.  */
	if (!ALIGNED_POINTER(mtod(m0, caddr_t), struct ip *)) {
		if ((m0 = m_copyup(m0, sizeof(struct ip),
		    ((max_linkhdr + 3) & ~3))) == NULL)
			goto drop;
	}
#endif
d982 2
a983 2
	if ((ip->ip_src.s_addr & session->ip_netmask.sin_addr.s_addr)
	    != session->ip_address.sin_addr.s_addr) {
a1014 6
#ifdef GATEWAY
	if (ipflow_fastforward(m0))
		goto done;
#endif

	/* enqueue to ipintrq */
d1016 5
a1020 2
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
a1021 1
		ifp->if_collisions++;	/* same as if_tun or if_pppac */
d1024 1
a1024 2
	IF_ENQUEUE(ifq, m0);
	splx(s);
a1026 4
#ifdef GATEWAY
done:
#endif
	/* countup statistics */
d1032 2
d1046 1
a1046 1
Static inline int
d1057 1
a1057 1
		if (cp[0] == PPP_ALLSTATIONS && cp[1] == PPP_UI) {
d1060 1
a1060 1
		} else if (!pipex_session_is_acfc_accepted(session)) {
a1063 1
		}
d1070 1
a1070 1
			return -1;
d1073 1
a1073 1
	} else {
a1074 1
	}
d1079 1
a1079 1
	return proto;
d1098 1
a1098 1
		return NULL;
d1106 1
a1106 1
	if (session == NULL) {
a1108 1
	}
d1111 1
a1111 1
	return session;
a1128 7
#if defined(__NetBSD__)
	/* cut off FCS */
	if (m0->m_flags & M_HASFCS) {
		m0->m_flags &= ~M_HASFCS;
		m_adj(m0, -ETHER_CRC_LEN);
	}
#endif
d1148 1
a1148 1
	return NULL;
d1154 1
a1154 1
	return NULL;
d1182 1
a1182 1
	if (padlen > 0) {
a1183 1
	}
d1198 2
a1199 2
	over_ifp->if_output(
	    over_ifp, m0, &session->proto.pppoe.peer_addr, NULL);
a1209 3
/*
 * pipex_pptp_output
 */
a1245 7
#if 0
	/*
	 * On NetBSD 1.6 or FreeBSD, ip_ouput assumes ip#ip_len must be host
	 * byte order.
	 */
	ip->ip_len = m0->m_pkthdr.len;
#else
a1246 1
#endif
a1276 11

#if defined(__NetBSD__)
	if (!ALIGNED_POINTER(mtod(m0, caddr_t), struct ip *)) {
		/* some components assume ip packet is aligned.  */
		if ((m0 = m_copyup(m0, sizeof(struct ip),
		    ((max_linkhdr + 3) & ~3))) == NULL) {
			goto drop;
		}
	}
#endif

a1290 1

a1293 3
/*
 * pipex_pptp_lookup_session
 */
d1349 1
a1349 1
	return session;
d1352 1
a1352 1
	return NULL;
a1354 3
/*
 * pipex_pptp_input
 */
a1366 1

d1432 1
a1432 2
	    RUPDIV(pptp_session->winsz, 2)) {
		/* Send ack only packet. */
a1433 1
	}
d1440 1
a1440 1
#ifdef	PIPEX_MPPE
d1478 1
a1478 1
	return NULL;
d1480 4
a1483 1
	--seq; --ack;	/* revert original values */
d1508 1
a1508 1
	return m0;
d1523 1
a1523 1
	return NULL;
a1525 3
/*
 * pipex_pptp_userland_lookup_session
 */
d1538 1
a1538 1
		return NULL;
d1549 1
a1549 1
		return NULL;
d1556 1
a1556 1
		return NULL;
d1564 1
a1564 2
		if (session->proto.pptp.peer_address.s_addr
		    != dst.s_addr)
d1576 1
a1576 1
	return session;
d1595 1
a1595 1
		return NULL;
d1622 1
a1622 1
	return m0;
d1637 2
a1638 1
	memcpy(mppe->master_key, mppe_req->master_key,sizeof(mppe->master_key));
d1651 2
a1652 2
	GetNewKeyFromSHA(mppe->master_key, mppe->master_key,
	    mppe->keylen, mppe->session_key);
d1654 1
a1654 1
	rc4_key(mppe, mppe->keylen, mppe->session_key);
a1656 3
#if defined(__NetBSD__)
#include <sys/sha1.h>
#else
a1657 1
#endif
a1672 31

#if defined(__OpenBSD__)
#define	arc4_setkey(_ctx, _key, _keylen) \
    rc4_keysetup((struct rc4_ctx *)(_ctx), (_key), (_keylen))
#define	arc4_encrypt(_ctx, _out, _in, _len) \
    rc4_crypt((struct rc4_ctx *)(_ctx), (_in), (_out), (_len))
#endif

Static inline int
rc4_key(struct pipex_mppe *mppe, int lkey, u_char *key)
{

	arc4_setkey(&mppe->rc4ctx, key, lkey);

	return 0;
}

Static inline void
rc4(struct pipex_mppe *mppe, int len, u_char *indata, u_char *outdata)
{

	arc4_encrypt(&mppe->rc4ctx, outdata, indata, len);
}

#define	ZeroMemory(dst, len)		memset(dst, 0, len)
#define	MoveMemory(dst, src, len)	memcpy(dst, src, len)
#define SHA_CTX				SHA1_CTX
#define SHAInit				SHA1Init
#define SHAUpdate			SHA1Update
#define SHAFinal(ctx,digest)		SHA1Final(digest, ctx)

d1674 2
a1675 5
GetNewKeyFromSHA(StartKey, SessionKey, SessionKeyLength, InterimKey)
	u_char *StartKey;
	u_char *SessionKey;
	int SessionKeyLength;
	u_char *InterimKey;
d1678 1
a1678 3
	SHA_CTX Context;

	ZeroMemory(Digest, 20);
d1680 6
a1685 6
	SHAInit(&Context);
	SHAUpdate(&Context, StartKey, SessionKeyLength);
	SHAUpdate(&Context, SHAPad1, 40);
	SHAUpdate(&Context, SessionKey, SessionKeyLength);
	SHAUpdate(&Context, SHAPad2, 40);
	SHAFinal(&Context, Digest);
d1687 1
a1687 1
	MoveMemory(InterimKey, Digest, SessionKeyLength);
a1689 3
/*
 * pipex_mppe_reduce_key
 */
a1701 3
/*
 * mppe_key_change
 */
d1710 5
a1714 2
	GetNewKeyFromSHA(mppe->master_key, mppe->session_key,
	    mppe->keylen, interim);
a1715 2
	rc4_key(&keychg, mppe->keylen, interim);
	rc4(&keychg, mppe->keylen, interim, mppe->session_key);
a1718 3
/*
 * mppe_decap - mppe decapsulation and payload decryption
 */
d1821 1
a1821 1
		rc4_key(mppe, mppe->keylen, mppe->session_key);
d1827 1
a1827 1
		rc4(mppe, len, cp, cp);
a1844 3
/*
 * pipex_mppe_output - mppe payload encryption and encapsulation
 */
a1868 1
#if 1
a1869 3
#else
			m = m_dup(m0, 0, M_COPYALL, M_NOWAIT);
#endif
d1897 1
a1897 1
		rc4_key(mppe, mppe->keylen, mppe->session_key);
d1913 1
a1913 1
	rc4(mppe, len, cp, cp);
d1919 1
a1919 1
		rc4(mppe, len, cp, cp);
d1980 1
a1980 1
		return 1;
d1990 1
a1990 1
	return 0;
a2111 1
			break;
a2114 1
			break;
d2127 1
a2127 1
	return m0;
d2132 1
a2132 1
	return NULL;
d2211 1
a2211 1
	return m0;
d2215 1
a2215 1
	return m0;
d2218 1
a2218 1
	return NULL;
a2220 3
/*
 * log for the pipex_session. 
 */
@


1.1
log
@Initial import PIPEX.  PIPEX(Pppac IP EXtension) is a IP forwarding
acceleration for PPP access concentrator.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d1 1
a1 1
/*	$Id: pipex.c,v 1.68 2009-02-17 14:41:06 yasuoka Exp $	*/
d120 1
a120 1
static void pipex_softintr_handler(void *);
d285 1
a285 1
static int
d467 1
a467 1
static int
d493 1
a493 1
static int
d512 1
a512 1
static int
d531 1
a531 1
static int
d554 1
a554 1
static int
d586 1
a586 1
static struct pipex_session *
d613 1
a613 1
static struct pipex_session *
d640 1
a640 1
static void
d659 1
a659 1
static void
d746 1
a746 1
static int
d795 1
a795 1
static void
d806 1
a806 1
static void
d815 1
a815 1
static void
d959 1
a959 1
static void
d1027 1
a1027 1
static void
d1080 1
a1080 1
static void
d1178 1
a1178 1
static inline int
d1220 1
a1220 1
static u_char	pipex_pppoe_padding[ETHERMIN];
d1302 1
a1302 1
static void
d1356 1
a1356 1
static void
d1808 1
a1808 1
static void
d1860 1
a1860 1
static inline int
d1869 1
a1869 1
static inline void
d1883 1
a1883 1
static void
d1908 1
a1908 1
static void
d1923 1
a1923 1
static void
d1942 1
a1942 1
static void
d2071 1
a2071 1
static void
d2159 1
a2159 1
static void
d2201 1
a2201 1
static int
d2282 1
a2282 1
static struct mbuf *
d2371 1
a2371 1
static struct mbuf *
d2456 1
a2456 1
static void
@

