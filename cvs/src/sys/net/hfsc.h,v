head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.11
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.10;
commitid	eYnPulzvLjDImPCa;

1.10
date	2015.11.09.01.06.31;	author dlg;	state Exp;
branches;
next	1.9;
commitid	mmu5QhvHibHMvv4f;

1.9
date	2015.09.30.11.36.20;	author dlg;	state Exp;
branches;
next	1.8;
commitid	shgH1LXPCebxWgto;

1.8
date	2015.04.12.09.58.46;	author dlg;	state Exp;
branches;
next	1.7;
commitid	FhB7HPYrCRsWAEGg;

1.7
date	2015.04.11.13.00.12;	author dlg;	state Exp;
branches;
next	1.6;
commitid	uT17hi9tQuyDqgaw;

1.6
date	2014.04.19.16.02.17;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2014.01.27.15.41.06;	author pelikan;	state Exp;
branches;
next	1.4;

1.4
date	2013.11.01.23.00.02;	author pelikan;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.31.13.19.17;	author pelikan;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.31.08.52.44;	author pelikan;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.12.11.39.17;	author henning;	state Exp;
branches;
next	;


desc
@@


1.11
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@/*	$OpenBSD: hfsc.h,v 1.9 2015/09/30 11:36:20 dlg Exp $	*/

/*
 * Copyright (c) 2012-2013 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 1997-1999 Carnegie Mellon University. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation is hereby granted (including for commercial or
 * for-profit use), provided that both the copyright notice and this
 * permission notice appear in all copies of the software, derivative
 * works, or modified versions, and any portions thereof.
 *
 * THIS SOFTWARE IS EXPERIMENTAL AND IS KNOWN TO HAVE BUGS, SOME OF
 * WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON PROVIDES THIS
 * SOFTWARE IN ITS ``AS IS'' CONDITION, AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 * Carnegie Mellon encourages (but does not require) users of this
 * software to return any improvements or extensions that they make,
 * and to grant Carnegie Mellon the rights to redistribute these
 * changes without encumbrance.
 */
#ifndef _HFSC_H_
#define	_HFSC_H_

/* hfsc class flags */
#define	HFSC_RED		0x0001	/* use RED */
#define	HFSC_ECN		0x0002  /* use RED/ECN */
#define	HFSC_RIO		0x0004  /* use RIO */
#define	HFSC_DEFAULTCLASS	0x1000	/* default class */

struct hfsc_pktcntr {
	u_int64_t	packets;
	u_int64_t	bytes;
};

#define	PKTCNTR_INC(cntr, len)	\
	do { (cntr)->packets++; (cntr)->bytes += len; } while (0)

struct hfsc_sc {
	u_int	m1;	/* slope of the first segment in bits/sec */
	u_int	d;	/* the x-projection of the first segment in msec */
	u_int	m2;	/* slope of the second segment in bits/sec */
};

/* special class handles */
#define	HFSC_NULLCLASS_HANDLE	0
#define	HFSC_DEFAULT_CLASSES	64
#define	HFSC_MAX_CLASSES	65535

/* service curve types */
#define	HFSC_REALTIMESC		1
#define	HFSC_LINKSHARINGSC	2
#define	HFSC_UPPERLIMITSC	4
#define	HFSC_DEFAULTSC		(HFSC_REALTIMESC|HFSC_LINKSHARINGSC)

struct hfsc_class_stats {
	u_int			class_id;
	u_int32_t		class_handle;
	struct hfsc_sc		rsc;
	struct hfsc_sc		fsc;
	struct hfsc_sc		usc;	/* upper limit service curve */

	u_int64_t		total;	/* total work in bytes */
	u_int64_t		cumul;	/* cumulative work in bytes
					   done by real-time criteria */
	u_int64_t		d;		/* deadline */
	u_int64_t		e;		/* eligible time */
	u_int64_t		vt;		/* virtual time */
	u_int64_t		f;		/* fit time for upper-limit */

	/* info helpful for debugging */
	u_int64_t		initvt;		/* init virtual time */
	u_int64_t		vtoff;		/* cl_vt_ipoff */
	u_int64_t		cvtmax;		/* cl_maxvt */
	u_int64_t		myf;		/* cl_myf */
	u_int64_t		cfmin;		/* cl_mincf */
	u_int64_t		cvtmin;		/* cl_mincvt */
	u_int64_t		myfadj;		/* cl_myfadj */
	u_int64_t		vtadj;		/* cl_vtadj */
	u_int64_t		cur_time;
	u_int32_t		machclk_freq;

	u_int			qlength;
	u_int			qlimit;
	struct hfsc_pktcntr	xmit_cnt;
	struct hfsc_pktcntr	drop_cnt;
	u_int			period;

	u_int			vtperiod;	/* vt period sequence no */
	u_int			parentperiod;	/* parent's vt period seqno */
	int			nactive;	/* number of active children */

	/* red and rio related info */
	int			qtype;
/*	struct redstats		red[3]; */
};

#ifdef _KERNEL
struct ifnet;
struct ifqueue;
struct pf_queuespec;
struct hfsc_if;

extern const struct ifq_ops * const ifq_hfsc_ops;

#define	HFSC_ENABLED(ifq)	((ifq)->ifq_ops == ifq_hfsc_ops)
#define	HFSC_DEFAULT_QLIMIT	50

struct hfsc_if	*hfsc_pf_alloc(struct ifnet *);
int		 hfsc_pf_addqueue(struct hfsc_if *, struct pf_queuespec *);
void		 hfsc_pf_free(struct hfsc_if *);
int		 hfsc_pf_qstats(struct pf_queuespec *, void *, int *);

void		 hfsc_initialize(void);
u_int64_t	 hfsc_microuptime(void);

#endif /* _KERNEL */
#endif /* _HFSC_H_ */
@


1.10
log
@kenjiro cho points out that requeue is hard to support on queue
disciplines

while i was simply concerned with the safety of the mbuf, requeue
is weird when it comes to how statistics are supposed to be handled
and ultimately isnt worth it.

this removes hfsc_requeue.
@
text
@d115 3
a117 1
#define	HFSC_ENABLED(ifq)	((ifq)->ifq_hfsc != NULL)
d120 5
a125 5
int		 hfsc_attach(struct ifnet *);
int		 hfsc_detach(struct ifnet *);
void		 hfsc_purge(struct ifqueue *);
int		 hfsc_enqueue(struct ifqueue *, struct mbuf *);
struct mbuf	*hfsc_dequeue(struct ifqueue *, int);
a126 3
int		 hfsc_addqueue(struct pf_queuespec *);
int		 hfsc_delqueue(struct pf_queuespec *);
int		 hfsc_qstats(struct pf_queuespec *, void *, int *);
@


1.9
log
@provide a hfsc_requeue()

this will allow packets to taken off an interfaces send queue, and
requeued if space didnt exist on the hardware.

the internal names are a bit ugly, i want to change them in the
next commit.

ok henning@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hfsc.h,v 1.8 2015/04/12 09:58:46 dlg Exp $	*/
a123 1
void		 hfsc_requeue(struct ifqueue *, struct mbuf *);
@


1.8
log
@pull structs and macros that are only used in hfsc.c out of the header
and into the .c file.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hfsc.h,v 1.7 2015/04/11 13:00:12 dlg Exp $	*/
d124 1
@


1.7
log
@the hfsc pools are only used in hfsc.c, so move the init of them
there instead of pf_ioctl.c.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hfsc.h,v 1.6 2014/04/19 16:02:17 henning Exp $	*/
a35 2
#include <sys/timeout.h>

d110 4
a113 143
/*
 * kernel internal service curve representation
 *	coordinates are given by 64 bit unsigned integers.
 *	x-axis: unit is clock count.  for the intel x86 architecture,
 *		the raw Pentium TSC (Timestamp Counter) value is used.
 *		virtual time is also calculated in this time scale.
 *	y-axis: unit is byte.
 *
 *	the service curve parameters are converted to the internal
 *	representation.
 *	the slope values are scaled to avoid overflow.
 *	the inverse slope values as well as the y-projection of the 1st
 *	segment are kept in order to to avoid 64-bit divide operations
 *	that are expensive on 32-bit architectures.
 *
 *  note: Intel Pentium TSC never wraps around in several thousands of years.
 *	x-axis doesn't wrap around for 1089 years with 1GHz clock.
 *      y-axis doesn't wrap around for 4358 years with 1Gbps bandwidth.
 */

/* kernel internal representation of a service curve */
struct hfsc_internal_sc {
	u_int64_t	sm1;	/* scaled slope of the 1st segment */
	u_int64_t	ism1;	/* scaled inverse-slope of the 1st segment */
	u_int64_t	dx;	/* the x-projection of the 1st segment */
	u_int64_t	dy;	/* the y-projection of the 1st segment */
	u_int64_t	sm2;	/* scaled slope of the 2nd segment */
	u_int64_t	ism2;	/* scaled inverse-slope of the 2nd segment */
};

/* runtime service curve */
struct hfsc_runtime_sc {
	u_int64_t	x;	/* current starting position on x-axis */
	u_int64_t	y;	/* current starting position on x-axis */
	u_int64_t	sm1;	/* scaled slope of the 1st segment */
	u_int64_t	ism1;	/* scaled inverse-slope of the 1st segment */
	u_int64_t	dx;	/* the x-projection of the 1st segment */
	u_int64_t	dy;	/* the y-projection of the 1st segment */
	u_int64_t	sm2;	/* scaled slope of the 2nd segment */
	u_int64_t	ism2;	/* scaled inverse-slope of the 2nd segment */
};

struct hfsc_classq {
	struct mbuf	*tail;	 /* Tail of packet queue */
	int		 qlen;	 /* Queue length (in number of packets) */
	int		 qlimit; /* Queue limit (in number of packets*) */
	int		 qtype;	 /* Queue type */
};

/* for TAILQ based ellist and actlist implementation */
struct hfsc_class;
typedef TAILQ_HEAD(hfsc_eligible, hfsc_class) hfsc_ellist_t;
typedef TAILQ_ENTRY(hfsc_class) hfsc_elentry_t;
typedef TAILQ_HEAD(hfsc_active, hfsc_class) hfsc_actlist_t;
typedef TAILQ_ENTRY(hfsc_class) hfsc_actentry_t;
#define	hfsc_ellist_first(s)		TAILQ_FIRST(s)
#define	hfsc_actlist_first(s)		TAILQ_FIRST(s)
#define	hfsc_actlist_last(s)		TAILQ_LAST(s, hfsc_active)

struct hfsc_class {
	u_int		cl_id;		/* class id (just for debug) */
	u_int32_t	cl_handle;	/* class handle */
	struct hfsc_if	*cl_hif;	/* back pointer to struct hfsc_if */
	int		cl_flags;	/* misc flags */

	struct hfsc_class *cl_parent;	/* parent class */
	struct hfsc_class *cl_siblings;	/* sibling classes */
	struct hfsc_class *cl_children;	/* child classes */

	struct hfsc_classq *cl_q;	/* class queue structure */
/*	struct red	*cl_red;*/	/* RED state */
	struct altq_pktattr *cl_pktattr; /* saved header used by ECN */

	u_int64_t	cl_total;	/* total work in bytes */
	u_int64_t	cl_cumul;	/* cumulative work in bytes
					   done by real-time criteria */
	u_int64_t	cl_d;		/* deadline */
	u_int64_t	cl_e;		/* eligible time */
	u_int64_t	cl_vt;		/* virtual time */
	u_int64_t	cl_f;		/* time when this class will fit for
					   link-sharing, max(myf, cfmin) */
	u_int64_t	cl_myf;		/* my fit-time (as calculated from this
					   class's own upperlimit curve) */
	u_int64_t	cl_myfadj;	/* my fit-time adjustment
					   (to cancel history dependence) */
	u_int64_t	cl_cfmin;	/* earliest children's fit-time (used
					   with cl_myf to obtain cl_f) */
	u_int64_t	cl_cvtmin;	/* minimal virtual time among the
					   children fit for link-sharing
					   (monotonic within a period) */
	u_int64_t	cl_vtadj;	/* intra-period cumulative vt
					   adjustment */
	u_int64_t	cl_vtoff;	/* inter-period cumulative vt offset */
	u_int64_t	cl_cvtmax;	/* max child's vt in the last period */

	u_int64_t	cl_initvt;	/* init virtual time (for debugging) */

	struct hfsc_internal_sc *cl_rsc; /* internal real-time service curve */
	struct hfsc_internal_sc *cl_fsc; /* internal fair service curve */
	struct hfsc_internal_sc *cl_usc; /* internal upperlimit service curve */
	struct hfsc_runtime_sc   cl_deadline; /* deadline curve */
	struct hfsc_runtime_sc   cl_eligible; /* eligible curve */
	struct hfsc_runtime_sc   cl_virtual;  /* virtual curve */
	struct hfsc_runtime_sc   cl_ulimit;   /* upperlimit curve */

	u_int		cl_vtperiod;	/* vt period sequence no */
	u_int		cl_parentperiod;  /* parent's vt period seqno */
	int		cl_nactive;	/* number of active children */
	hfsc_actlist_t	*cl_actc;	/* active children list */

	hfsc_actentry_t	cl_actlist;	/* active children list entry */
	hfsc_elentry_t	cl_ellist;	/* eligible list entry */

	struct {
		struct hfsc_pktcntr xmit_cnt;
		struct hfsc_pktcntr drop_cnt;
		u_int period;
	} cl_stats;
};

/*
 * hfsc interface state
 */
struct hfsc_if {
	struct hfsc_if		*hif_next;	/* interface state list */
	struct ifqueue		*hif_ifq;	/* backpointer to ifq */
	struct hfsc_class	*hif_rootclass;		/* root class */
	struct hfsc_class	*hif_defaultclass;	/* default class */
	struct hfsc_class	**hif_class_tbl;
	struct hfsc_class	*hif_pollcache;	/* cache for poll operation */

	u_int	hif_allocated;			/* # of slots in hif_class_tbl */
	u_int	hif_classes;			/* # of classes in the tree */
	u_int	hif_packets;			/* # of packets in the tree */
	u_int	hif_classid;			/* class id sequence number */

	hfsc_ellist_t *hif_eligible;			/* eligible list */
	struct timeout hif_defer;	/* for queues that weren't ready */
};

#define HFSC_CLK_SHIFT		8
#define HFSC_FREQ		(1000000 << HFSC_CLK_SHIFT)
#define HFSC_CLK_PER_TICK	(HFSC_FREQ / hz)
a116 2

struct ifnet; struct ifqueue; struct pf_queuespec;
@


1.6
log
@disgusting altq compat hack goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: hfsc.h,v 1.4 2013/11/01 23:00:02 pelikan Exp $	*/
d261 1
@


1.5
log
@Make the amount of classes limited by 64k, with automatic table growing.

The limit is because in places, queue IDs are being stored as u_int16_t's.

tested by me, discussed at length with (and ok) claudio henning
@
text
@a258 6
/* XXX hack */
#ifndef ALTQ_IS_ENABLED
#define ALTQ_IS_ENABLED(ifq)	HFSC_ENABLED(ifq)
#endif
/* XXX hack */

@


1.4
log
@push the queues every 1/HZ using timeout(9)

This is a modified version of oldtbr_timeout() with a timeout for each
HFSC enabled interface.  We can now safely include <sys/timeout.h> in
net/hfsc.h without breaking the build.
tested by naddy, ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: hfsc.h,v 1.3 2013/10/31 13:19:17 pelikan Exp $	*/
d60 2
a61 1
#define	HFSC_MAX_CLASSES	64
d240 1
a240 1
	struct hfsc_class	*hif_class_tbl[HFSC_MAX_CLASSES];
d243 1
@


1.3
log
@revert previous, net/if.h exports bad things to userspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: hfsc.h,v 1.2 2013/10/31 08:52:44 pelikan Exp $	*/
d36 2
d247 1
@


1.2
log
@push the queues every 1/HZ using timeout(9)

This is a modified version of oldtbr_timeout() with a timeout for each
HFSC enabled interface.
ok henning claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: hfsc.h,v 1.1 2013/10/12 11:39:17 henning Exp $	*/
a35 2
#include <sys/timeout.h>

a244 1
	struct timeout hif_defer;	/* for queues that weren't ready */
@


1.1
log
@standalone hfsc implementation with new interface to the consumers, for
the new bandwidth shaping subsystem. looked over & tested by many,
ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 2
d247 1
@

