head	1.16;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.0.8
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.6
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.4
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.2
	OPENBSD_4_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2017.09.05.22.15.32;	author sashan;	state Exp;
branches;
next	1.15;
commitid	txJG8pmyr9np7kyo;

1.15
date	2017.05.30.20.00.48;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	8EZKfkPqWca68i5l;

1.14
date	2016.09.27.04.57.17;	author dlg;	state Exp;
branches;
next	1.13;
commitid	irzdR7hwk1GHVaEu;

1.13
date	2016.09.27.02.51.12;	author dlg;	state Exp;
branches;
next	1.12;
commitid	bZuzILta8BoFCDiT;

1.12
date	2016.07.19.13.34.12;	author henning;	state Exp;
branches;
next	1.11;
commitid	7irX13ju2Ijz6e6m;

1.11
date	2016.01.15.02.37.12;	author mmcc;	state Exp;
branches;
next	1.10;
commitid	6hOPP0TlRM3DZTcS;

1.10
date	2015.07.18.19.19.00;	author sashan;	state Exp;
branches;
next	1.9;
commitid	JLCIxhdc71KA1Osw;

1.9
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.8;
commitid	DQakU8LLWV6Iwx84;

1.8
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.7;
commitid	B4dZSbxas1X1IpXI;

1.7
date	2012.11.15.17.44.10;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.22.22.34.50;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.06.12.05.55;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.06.21.57.51;	author thib;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.18.15.31.37;	author dhill;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.27.13.56.51;	author mcbride;	state Exp;
branches;
next	;


desc
@@


1.16
log
@- split pf_find_or_create_ruleset() to smaller chunks.
  tested by Hrvoje

OK mpi@@, OK bluhm@@
@
text
@/*	$OpenBSD: pf_ruleset.c,v 1.15 2017/05/30 20:00:48 deraadt Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002,2003 Henning Brauer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/param.h>
#include <sys/socket.h>
#ifdef _KERNEL
#include <sys/systm.h>
#include <sys/mbuf.h>
#endif /* _KERNEL */
#include <sys/syslog.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <net/if.h>
#include <net/pfvar.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif /* INET6 */


#ifdef _KERNEL
#define rs_malloc(x)		malloc(x, M_TEMP, M_WAITOK|M_CANFAIL|M_ZERO)
#define rs_free(x, siz)		free(x, M_TEMP, siz)

#else	/* !_KERNEL */
/* Userland equivalents so we can lend code to pfctl et al. */

#include <arpa/inet.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define rs_malloc(x)		 calloc(1, x)
#define rs_free(x, siz)		 freezero(x, siz)

#ifdef PFDEBUG
#include <sys/stdarg.h>	/* for DPFPRINTF() */
#endif	/* PFDEBUG */
#endif /* _KERNEL */


struct pf_anchor_global	 pf_anchors;
struct pf_anchor	 pf_main_anchor;

static __inline int pf_anchor_compare(struct pf_anchor *, struct pf_anchor *);

RB_GENERATE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
RB_GENERATE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);

static __inline int
pf_anchor_compare(struct pf_anchor *a, struct pf_anchor *b)
{
	int c = strcmp(a->path, b->path);

	return (c ? (c < 0 ? -1 : 1) : 0);
}

void
pf_init_ruleset(struct pf_ruleset *ruleset)
{
	memset(ruleset, 0, sizeof(struct pf_ruleset));
	TAILQ_INIT(&ruleset->rules.queues[0]);
	TAILQ_INIT(&ruleset->rules.queues[1]);
	ruleset->rules.active.ptr = &ruleset->rules.queues[0];
	ruleset->rules.inactive.ptr = &ruleset->rules.queues[1];
}

struct pf_anchor *
pf_find_anchor(const char *path)
{
	struct pf_anchor	*key, *found;

	key = rs_malloc(sizeof(*key));
	if (key == NULL)
		return (NULL);
	strlcpy(key->path, path, sizeof(key->path));
	found = RB_FIND(pf_anchor_global, &pf_anchors, key);
	rs_free(key, sizeof(*key));
	return (found);
}

struct pf_ruleset *
pf_find_ruleset(const char *path)
{
	struct pf_anchor	*anchor;

	while (*path == '/')
		path++;
	if (!*path)
		return (&pf_main_ruleset);
	anchor = pf_find_anchor(path);
	if (anchor == NULL)
		return (NULL);
	else
		return (&anchor->ruleset);
}

struct pf_ruleset *
pf_get_leaf_ruleset(char *path, char **path_remainder)
{
	struct pf_ruleset	*ruleset;
	char			*leaf, *p;
	int			 i = 0;

	p = path;
	while (*p == '/')
		p++;

	ruleset = pf_find_ruleset(p);
	leaf = p;
	while (ruleset == NULL) {
		leaf = strrchr(p, '/');
		if (leaf != NULL) {
			*leaf = '\0';
			i++;
			ruleset = pf_find_ruleset(p);
		} else {
			leaf = path;
			/*
			 * if no path component exists, then main ruleset is
			 * our parent.
			 */
			ruleset = &pf_main_ruleset;
		}
	}

	if (path_remainder != NULL)
		*path_remainder = leaf;

	/* restore slashes in path.  */
	while (i != 0) {
		while (*leaf != '\0')
			leaf++;
		*leaf = '/';
		i--;
	}

	return (ruleset);
}

struct pf_anchor *
pf_create_anchor(struct pf_anchor *parent, const char *aname)
{
	struct pf_anchor	*anchor, *dup;

	if (!*aname || (strlen(aname) >= PF_ANCHOR_NAME_SIZE) ||
	    ((parent != NULL) && (strlen(parent->path) >= PF_ANCHOR_MAXPATH)))
		return (NULL);

	anchor = rs_malloc(sizeof(*anchor));
	if (anchor == NULL)
		return (NULL);

	RB_INIT(&anchor->children);
	strlcpy(anchor->name, aname, sizeof(anchor->name));
	if (parent != NULL) {
		/*
		 * Make sure path for levels 2, 3, ... is terminated by '/':
		 *	1/2/3/...
		 */
		strlcpy(anchor->path, parent->path, sizeof(anchor->path));
		strlcat(anchor->path, "/", sizeof(anchor->path));
	}
	strlcat(anchor->path, anchor->name, sizeof(anchor->path));

	if ((dup = RB_INSERT(pf_anchor_global, &pf_anchors, anchor)) != NULL) {
		DPFPRINTF(LOG_NOTICE,
		    "%s: RB_INSERT to global '%s' '%s' collides with '%s' '%s'",
		    __func__, anchor->path, anchor->name, dup->path, dup->name);
		rs_free(anchor, sizeof(*anchor));
		return (NULL);
	}

	if (parent != NULL) {
		anchor->parent = parent;
		dup = RB_INSERT(pf_anchor_node, &parent->children, anchor);
		if (dup != NULL) {
			DPFPRINTF(LOG_NOTICE,
			    "%s: RB_INSERT to parent '%s' '%s' collides with "
			    "'%s' '%s'", __func__, anchor->path, anchor->name,
			    dup->path, dup->name);
			RB_REMOVE(pf_anchor_global, &pf_anchors,
			    anchor);
			rs_free(anchor, sizeof(*anchor));
			return (NULL);
		}
	}

	pf_init_ruleset(&anchor->ruleset);
	anchor->ruleset.anchor = anchor;

	return (anchor);
}

struct pf_ruleset *
pf_find_or_create_ruleset(const char *path)
{
	char			*p, *aname, *r;
	struct pf_ruleset	*ruleset;
	struct pf_anchor	*anchor;

	if (path[0] == 0)
		return (&pf_main_ruleset);

	while (*path == '/')
		path++;

	ruleset = pf_find_ruleset(path);
	if (ruleset != NULL)
		return (ruleset);

	p = rs_malloc(MAXPATHLEN);
	if (p == NULL)
		return (NULL);
	strlcpy(p, path, MAXPATHLEN);

	ruleset = pf_get_leaf_ruleset(p, &aname);
	anchor = ruleset->anchor;

	while (*aname == '/')
		aname++;
	/*
	 * aname is a path remainder, which contains nodes we must create.  We
	 * process the aname path from left to right, effectively descending
	 * from parents to children.
	 */
	while ((r = strchr(aname, '/')) != NULL || *aname) {
		if (r != NULL)
			*r = 0;

		anchor = pf_create_anchor(anchor, aname);
		if (anchor == NULL) {
			rs_free(p, MAXPATHLEN);
			return (NULL);
		}

		if (r == NULL)
			break;
		else
			aname = r + 1;
	}

	rs_free(p, MAXPATHLEN);
	return (&anchor->ruleset);
}

void
pf_remove_if_empty_ruleset(struct pf_ruleset *ruleset)
{
	struct pf_anchor	*parent;

	while (ruleset != NULL) {
		if (ruleset == &pf_main_ruleset || ruleset->anchor == NULL ||
		    !RB_EMPTY(&ruleset->anchor->children) ||
		    ruleset->anchor->refcnt > 0 || ruleset->tables > 0 ||
		    ruleset->topen)
			return;
		if (!TAILQ_EMPTY(ruleset->rules.active.ptr) ||
		    !TAILQ_EMPTY(ruleset->rules.inactive.ptr) ||
		    ruleset->rules.inactive.open)
			return;
		RB_REMOVE(pf_anchor_global, &pf_anchors, ruleset->anchor);
		if ((parent = ruleset->anchor->parent) != NULL)
			RB_REMOVE(pf_anchor_node, &parent->children,
			    ruleset->anchor);
		rs_free(ruleset->anchor, sizeof(*(ruleset->anchor)));
		if (parent == NULL)
			return;
		ruleset = &parent->ruleset;
	}
}

int
pf_anchor_setup(struct pf_rule *r, const struct pf_ruleset *s,
    const char *name)
{
	char			*p, *path;
	struct pf_ruleset	*ruleset;

	r->anchor = NULL;
	r->anchor_relative = 0;
	r->anchor_wildcard = 0;
	if (!name[0])
		return (0);
	path = rs_malloc(MAXPATHLEN);
	if (path == NULL)
		return (1);
	if (name[0] == '/')
		strlcpy(path, name + 1, MAXPATHLEN);
	else {
		/* relative path */
		r->anchor_relative = 1;
		if (s->anchor == NULL || !s->anchor->path[0])
			path[0] = 0;
		else
			strlcpy(path, s->anchor->path, MAXPATHLEN);
		while (name[0] == '.' && name[1] == '.' && name[2] == '/') {
			if (!path[0]) {
				DPFPRINTF(LOG_NOTICE,
				    "pf_anchor_setup: .. beyond root");
				rs_free(path, MAXPATHLEN);
				return (1);
			}
			if ((p = strrchr(path, '/')) != NULL)
				*p = 0;
			else
				path[0] = 0;
			r->anchor_relative++;
			name += 3;
		}
		if (path[0])
			strlcat(path, "/", MAXPATHLEN);
		strlcat(path, name, MAXPATHLEN);
	}
	if ((p = strrchr(path, '/')) != NULL && !strcmp(p, "/*")) {
		r->anchor_wildcard = 1;
		*p = 0;
	}
	ruleset = pf_find_or_create_ruleset(path);
	rs_free(path, MAXPATHLEN);
	if (ruleset == NULL || ruleset->anchor == NULL) {
		DPFPRINTF(LOG_NOTICE,
		    "pf_anchor_setup: ruleset");
		return (1);
	}
	r->anchor = ruleset->anchor;
	r->anchor->refcnt++;
	return (0);
}

int
pf_anchor_copyout(const struct pf_ruleset *rs, const struct pf_rule *r,
    struct pfioc_rule *pr)
{
	pr->anchor_call[0] = 0;
	if (r->anchor == NULL)
		return (0);
	if (!r->anchor_relative) {
		strlcpy(pr->anchor_call, "/", sizeof(pr->anchor_call));
		strlcat(pr->anchor_call, r->anchor->path,
		    sizeof(pr->anchor_call));
	} else {
		char	*a, *p;
		int	 i;

		a = rs_malloc(MAXPATHLEN);
		if (a == NULL)
			return (1);
		if (rs->anchor == NULL)
			a[0] = 0;
		else
			strlcpy(a, rs->anchor->path, MAXPATHLEN);
		for (i = 1; i < r->anchor_relative; ++i) {
			if ((p = strrchr(a, '/')) == NULL)
				p = a;
			*p = 0;
			strlcat(pr->anchor_call, "../",
			    sizeof(pr->anchor_call));
		}
		if (strncmp(a, r->anchor->path, strlen(a))) {
			DPFPRINTF(LOG_NOTICE,
			    "pf_anchor_copyout: '%s' '%s'", a,
			    r->anchor->path);
			rs_free(a, MAXPATHLEN);
			return (1);
		}
		if (strlen(r->anchor->path) > strlen(a))
			strlcat(pr->anchor_call, r->anchor->path + (a[0] ?
			    strlen(a) + 1 : 0), sizeof(pr->anchor_call));
		rs_free(a, MAXPATHLEN);
	}
	if (r->anchor_wildcard)
		strlcat(pr->anchor_call, pr->anchor_call[0] ? "/*" : "*",
		    sizeof(pr->anchor_call));
	return (0);
}

void
pf_anchor_remove(struct pf_rule *r)
{
	if (r->anchor == NULL)
		return;
	if (r->anchor->refcnt <= 0) {
		DPFPRINTF(LOG_NOTICE,
		    "pf_anchor_remove: broken refcount");
		r->anchor = NULL;
		return;
	}
	if (!--r->anchor->refcnt)
		pf_remove_if_empty_ruleset(&r->anchor->ruleset);
	r->anchor = NULL;
}
@


1.15
log
@sizes for free()
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.14 2016/09/27 04:57:17 dlg Exp $ */
d115 1
a115 1
	rs_free(key, sizeof (*key));
d136 97
d235 1
a235 1
	char			*p, *q, *r;
d237 1
a237 1
	struct pf_anchor	*anchor, *dup, *parent = NULL;
d241 1
d244 1
d248 1
d253 12
a264 17
	while (parent == NULL && (q = strrchr(p, '/')) != NULL) {
		*q = 0;
		if ((ruleset = pf_find_ruleset(p)) != NULL) {
			parent = ruleset->anchor;
			break;
		}
	}
	if (q == NULL)
		q = p;
	else
		q++;
	strlcpy(p, path, MAXPATHLEN);
	if (!*q) {
		rs_free(p, MAXPATHLEN);
		return (NULL);
	}
	while ((r = strchr(q, '/')) != NULL || *q) {
d267 2
a268 7
		if (!*q || strlen(q) >= PF_ANCHOR_NAME_SIZE ||
		    (parent != NULL && strlen(parent->path) >=
		    MAXPATHLEN - PF_ANCHOR_NAME_SIZE - 1)) {
			rs_free(p, MAXPATHLEN);
			return (NULL);
		}
		anchor = rs_malloc(sizeof(*anchor));
d273 3
a275 39
		RB_INIT(&anchor->children);
		strlcpy(anchor->name, q, sizeof(anchor->name));
		if (parent != NULL) {
			strlcpy(anchor->path, parent->path,
			    sizeof(anchor->path));
			strlcat(anchor->path, "/", sizeof(anchor->path));
		}
		strlcat(anchor->path, anchor->name, sizeof(anchor->path));
		if ((dup = RB_INSERT(pf_anchor_global, &pf_anchors, anchor)) !=
		    NULL) {
			DPFPRINTF(LOG_NOTICE,
			    "pf_find_or_create_ruleset: RB_INSERT1 "
			    "'%s' '%s' collides with '%s' '%s'",
			    anchor->path, anchor->name, dup->path, dup->name);
			rs_free(anchor, sizeof(*anchor));
			rs_free(p, MAXPATHLEN);
			return (NULL);
		}
		if (parent != NULL) {
			anchor->parent = parent;
			if ((dup = RB_INSERT(pf_anchor_node, &parent->children,
			    anchor)) != NULL) {
				DPFPRINTF(LOG_NOTICE,
				    "pf_find_or_create_ruleset: "
				    "RB_INSERT2 '%s' '%s' collides with "
				    "'%s' '%s'", anchor->path, anchor->name,
				    dup->path, dup->name);
				RB_REMOVE(pf_anchor_global, &pf_anchors,
				    anchor);
				rs_free(anchor, sizeof(*anchor));
				rs_free(p, MAXPATHLEN);
				return (NULL);
			}
		}
		pf_init_ruleset(&anchor->ruleset);
		anchor->ruleset.anchor = anchor;
		parent = anchor;
		if (r != NULL)
			q = r + 1;
d277 1
a277 1
			*q = 0;
d279 1
@


1.14
log
@roll back turning RB into RBT until i get better at this process.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.13 2016/09/27 02:51:12 dlg Exp $ */
d60 1
a60 1
#define rs_free(x)		free(x, M_TEMP, 0)
d71 1
a71 1
#define rs_free(x)		 free(x)
d115 1
a115 1
	rs_free(key);
d166 1
a166 1
		rs_free(p);
d175 1
a175 1
			rs_free(p);
d180 1
a180 1
			rs_free(p);
d197 2
a198 2
			rs_free(anchor);
			rs_free(p);
d212 2
a213 2
				rs_free(anchor);
				rs_free(p);
d225 1
a225 1
	rs_free(p);
d248 1
a248 1
		rs_free(ruleset->anchor);
d283 1
a283 1
				rs_free(path);
d302 1
a302 1
	rs_free(path);
d346 1
a346 1
			rs_free(a);
d352 1
a352 1
		rs_free(a);
@


1.13
log
@move pf from the RB macros to the RBT functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.12 2016/07/19 13:34:12 henning Exp $ */
d82 1
a82 2
static __inline int pf_anchor_compare(const struct pf_anchor *,
    const struct pf_anchor *);
d84 2
a85 2
RBT_GENERATE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
RBT_GENERATE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);
d88 1
a88 1
pf_anchor_compare(const struct pf_anchor *a, const struct pf_anchor *b)
d114 1
a114 1
	found = RBT_FIND(pf_anchor_global, &pf_anchors, key);
d183 1
a183 1
		RBT_INIT(pf_anchor_node, &anchor->children);
d191 1
a191 1
		if ((dup = RBT_INSERT(pf_anchor_global, &pf_anchors, anchor)) !=
d194 1
a194 1
			    "pf_find_or_create_ruleset: RBT_INSERT1 "
d203 1
a203 1
			if ((dup = RBT_INSERT(pf_anchor_node, &parent->children,
d207 1
a207 1
				    "RBT_INSERT2 '%s' '%s' collides with "
d210 1
a210 1
				RBT_REMOVE(pf_anchor_global, &pf_anchors,
d236 1
a236 1
		    !RBT_EMPTY(pf_anchor_node, &ruleset->anchor->children) ||
d244 1
a244 1
		RBT_REMOVE(pf_anchor_global, &pf_anchors, ruleset->anchor);
d246 1
a246 1
			RBT_REMOVE(pf_anchor_node, &parent->children,
@


1.12
log
@style: no spaces after # for define/include, ok phessler benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.10 2015/07/18 19:19:00 sashan Exp $ */
d82 2
a83 1
static __inline int pf_anchor_compare(struct pf_anchor *, struct pf_anchor *);
d85 2
a86 2
RB_GENERATE(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
RB_GENERATE(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);
d89 1
a89 1
pf_anchor_compare(struct pf_anchor *a, struct pf_anchor *b)
d115 1
a115 1
	found = RB_FIND(pf_anchor_global, &pf_anchors, key);
d184 1
a184 1
		RB_INIT(&anchor->children);
d192 1
a192 1
		if ((dup = RB_INSERT(pf_anchor_global, &pf_anchors, anchor)) !=
d195 1
a195 1
			    "pf_find_or_create_ruleset: RB_INSERT1 "
d204 1
a204 1
			if ((dup = RB_INSERT(pf_anchor_node, &parent->children,
d208 1
a208 1
				    "RB_INSERT2 '%s' '%s' collides with "
d211 1
a211 1
				RB_REMOVE(pf_anchor_global, &pf_anchors,
d237 1
a237 1
		    !RB_EMPTY(&ruleset->anchor->children) ||
d245 1
a245 1
		RB_REMOVE(pf_anchor_global, &pf_anchors, ruleset->anchor);
d247 1
a247 1
			RB_REMOVE(pf_anchor_node, &parent->children,
@


1.11
log
@rs_malloc() does not need to be cast
@
text
@d41 2
a42 2
# include <sys/systm.h>
# include <sys/mbuf.h>
d65 11
a75 11
# include <arpa/inet.h>
# include <errno.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# define rs_malloc(x)		 calloc(1, x)
# define rs_free(x)		 free(x)

# ifdef PFDEBUG
#  include <sys/stdarg.h>	/* for DPFPRINTF() */
# endif	/* PFDEBUG */
@


1.10
log
@msg.mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.9 2014/07/22 11:06:10 mpi Exp $ */
d110 1
a110 1
	key = (struct pf_anchor *)rs_malloc(sizeof(*key));
d149 1
a149 1
	p = (char *)rs_malloc(MAXPATHLEN);
d178 1
a178 1
		anchor = (struct pf_anchor *)rs_malloc(sizeof(*anchor));
d267 1
a267 1
	path = (char *)rs_malloc(MAXPATHLEN);
d328 1
a328 1
		a = (char *)rs_malloc(MAXPATHLEN);
@


1.9
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.8 2014/07/12 18:44:22 tedu Exp $ */
d62 1
a62 1
#else
d75 1
a75 1
# endif
@


1.8
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.7 2012/11/15 17:44:10 deraadt Exp $ */
a46 1
#include <netinet/in_systm.h>
@


1.7
log
@this code is shared into userland, and there it should not pull
in sys/mbuf.h
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.6 2010/01/18 23:52:46 mcbride Exp $ */
d61 1
a61 1
#define rs_free(x)		free(x, M_TEMP)
@


1.6
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.5 2009/11/22 22:34:50 henning Exp $ */
d42 1
a43 1
#include <sys/mbuf.h>
@


1.5
log
@cleanup after the NAT changes. we used to have multiple rulesets (scrub,
NAT, filter). now we only have one. no need for an array any more. simplifies
the code quite a bit.
in the process fix the abuse of PF_RULESET_* by (surprise, isn't it) the
table code.
written at the filesystem hackathon in stockholm, committed from the
hardware hackathon in portugal. ok gcc and jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.4 2009/04/06 12:05:55 henning Exp $ */
d44 1
a59 3
# define DPFPRINTF(format, x...)		\
	if (pf_status.debug >= PF_DEBUG_NOISY)	\
		printf(format , ##x)
d75 2
a76 5
#  include <sys/stdarg.h>
#  define DPFPRINTF(format, x...)	fprintf(stderr, format , ##x)
# else
#  define DPFPRINTF(format, x...)	((void)0)
# endif /* PFDEBUG */
d194 3
a196 2
			printf("pf_find_or_create_ruleset: RB_INSERT1 "
			    "'%s' '%s' collides with '%s' '%s'\n",
d206 2
a207 1
				printf("pf_find_or_create_ruleset: "
d209 1
a209 1
				    "'%s' '%s'\n", anchor->path, anchor->name,
d282 2
a283 1
				printf("pf_anchor_setup: .. beyond root\n");
d305 2
a306 1
		printf("pf_anchor_setup: ruleset\n");
d344 2
a345 1
			printf("pf_anchor_copyout: '%s' '%s'\n", a,
d367 2
a368 1
		printf("pf_anchor_remove: broken refcount\n");
@


1.4
log
@1) scrub rules are completely gone.
2) packet reassembly: only one method remains, full reassembly. crop
and drop-ovl are gone.
.  set reassemble yes|no [no-df]
if no-df is given fragments (and only fragments!) with the df bit set
have it cleared before entering the fragment cache, and thus the
reassembled packet doesn't have df set either. it does NOT touch
non-fragmented packets.
3) regular rules can have scrub options.
.  pass scrub(no-df, min-ttl 64, max-mss 1400, set-tos lowdelay)
.  match scrub(reassemble tcp, random-id)
of course all options are optional. the individual options still do
what they used to do on scrub rules, but everything is stateful now.
4) match rules
"match" is a new action, just like pass and block are, and can be used
like they do. opposed to pass or block, they do NOT change the
pass/block state of a packet. i. e.
.  pass
.  match
passes the packet, and
.  block
.  match
blocks it.
Every time (!) a match rule matches, i. e. not only when it is the
last matching rule, the following actions are set:
-queue assignment. can be overwritten later, the last rule that set a
queue wins. note how this is different from the last matching rule
wins, if the last matching rule has no queue assignments and the
second last matching rule was a match rule with queue assignments,
these assignments are taken.
-rtable assignments. works the same as queue assignments.
-set-tos, min-ttl, max-mss, no-df, random-id, reassemble tcp, all work
like the above
-logging. every matching rule causes the packet to be logged. this
 means a single packet can get logged more than once (think multiple log
 interfaces with different receivers, like pflogd and spamlogd)
.
almost entirely hacked at n2k9 in basel, could not be committed close to
release. this really should have been multiple diffs, but splitting them
now is not feasible any more. input from mcbride and dlg, and frantzen
about the fragment handling.
speedup around 7% for the common case, the more the more scrub rules
were in use.
manpage not up to date, being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.3 2009/01/06 21:57:51 thib Exp $ */
a100 27
int
pf_get_ruleset_number(u_int8_t action)
{
	switch (action) {
	case PF_PASS:
	case PF_MATCH:
	case PF_DROP:
		return (PF_RULESET_FILTER);
		break;
	case PF_NAT:
	case PF_NONAT:
		return (PF_RULESET_NAT);
		break;
	case PF_BINAT:
	case PF_NOBINAT:
		return (PF_RULESET_BINAT);
		break;
	case PF_RDR:
	case PF_NORDR:
		return (PF_RULESET_RDR);
		break;
	default:
		return (PF_RULESET_MAX);
		break;
	}
}

a103 2
	int	i;

d105 4
a108 6
	for (i = 0; i < PF_RULESET_MAX; i++) {
		TAILQ_INIT(&ruleset->rules[i].queues[0]);
		TAILQ_INIT(&ruleset->rules[i].queues[1]);
		ruleset->rules[i].active.ptr = &ruleset->rules[i].queues[0];
		ruleset->rules[i].inactive.ptr = &ruleset->rules[i].queues[1];
	}
a236 1
	int			 i;
d244 4
a247 5
		for (i = 0; i < PF_RULESET_MAX; ++i)
			if (!TAILQ_EMPTY(ruleset->rules[i].active.ptr) ||
			    !TAILQ_EMPTY(ruleset->rules[i].inactive.ptr) ||
			    ruleset->rules[i].inactive.open)
				return;
@


1.3
log
@Always check rs_malloc() returns. Also add M_ZERO and M_CANFAIL
to the flags passed to malloc() in the kernel case since we
always zero the memory and are able to fail gracefully.

remove memset()'s and bzero's accordingly and use calloc(1, ...)
in the userland case so we get it zeroed.

OK henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.2 2008/12/18 15:31:37 dhill Exp $ */
a104 4
	case PF_SCRUB:
	case PF_NOSCRUB:
		return (PF_RULESET_SCRUB);
		break;
d106 1
@


1.2
log
@Remove redundant function prototypes which are already in pfvar.h

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_ruleset.c,v 1.1 2006/10/27 13:56:51 mcbride Exp $ */
d62 1
a62 1
#define rs_malloc(x)		malloc(x, M_TEMP, M_WAITOK)
d73 1
a73 1
# define rs_malloc(x)		 malloc(x)
d151 2
a152 1
	memset(key, 0, sizeof(*key));
d190 2
a191 1
	bzero(p, MAXPATHLEN);
a222 1
		memset(anchor, 0, sizeof(*anchor));
d308 2
a309 1
	bzero(path, MAXPATHLEN);
d367 2
a368 1
		bzero(a, MAXPATHLEN);
@


1.1
log
@Split ruleset manipulation functions out into pf_ruleset.c to allow them to
be imported into pfctl. This is a precursor to separating ruleset parsing
from loading in pfctl, and tons of good things will come from it.

2 minor changes aside from cut-n-paste and #define portability magic:

- instead of defining the global pf_main_ruleset, define pf_main_anchor
  (which contains the pf_main_ruleset)

- allow pf_find_or_create_ruleset() to return the pf_main_ruleset if it's
  passed an empty anchor name.

ok henning dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a86 8

int			 pf_get_ruleset_number(u_int8_t);
void			 pf_init_ruleset(struct pf_ruleset *);
int			 pf_anchor_setup(struct pf_rule *,
			    const struct pf_ruleset *, const char *);
int			 pf_anchor_copyout(const struct pf_ruleset *,
			    const struct pf_rule *, struct pfioc_rule *);
void			 pf_anchor_remove(struct pf_rule *);
@

