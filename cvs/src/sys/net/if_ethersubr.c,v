head	1.246;
access;
symbols
	OPENBSD_6_2:1.246.0.4
	OPENBSD_6_2_BASE:1.246
	OPENBSD_6_1:1.242.0.4
	OPENBSD_6_1_BASE:1.242
	OPENBSD_6_0:1.239.0.4
	OPENBSD_6_0_BASE:1.239
	OPENBSD_5_9:1.233.0.2
	OPENBSD_5_9_BASE:1.233
	OPENBSD_5_8:1.221.0.4
	OPENBSD_5_8_BASE:1.221
	OPENBSD_5_7:1.189.0.2
	OPENBSD_5_7_BASE:1.189
	OPENBSD_5_6:1.174.0.4
	OPENBSD_5_6_BASE:1.174
	OPENBSD_5_5:1.162.0.4
	OPENBSD_5_5_BASE:1.162
	OPENBSD_5_4:1.157.0.2
	OPENBSD_5_4_BASE:1.157
	OPENBSD_5_3:1.153.0.2
	OPENBSD_5_3_BASE:1.153
	OPENBSD_5_2:1.151.0.6
	OPENBSD_5_2_BASE:1.151
	OPENBSD_5_1_BASE:1.151
	OPENBSD_5_1:1.151.0.4
	OPENBSD_5_0:1.151.0.2
	OPENBSD_5_0_BASE:1.151
	OPENBSD_4_9:1.148.0.2
	OPENBSD_4_9_BASE:1.148
	OPENBSD_4_8:1.145.0.2
	OPENBSD_4_8_BASE:1.145
	OPENBSD_4_7:1.139.0.2
	OPENBSD_4_7_BASE:1.139
	OPENBSD_4_6:1.133.0.4
	OPENBSD_4_6_BASE:1.133
	OPENBSD_4_5:1.131.0.2
	OPENBSD_4_5_BASE:1.131
	OPENBSD_4_4:1.123.0.2
	OPENBSD_4_4_BASE:1.123
	OPENBSD_4_3:1.114.0.2
	OPENBSD_4_3_BASE:1.114
	OPENBSD_4_2:1.110.0.2
	OPENBSD_4_2_BASE:1.110
	OPENBSD_4_1:1.105.0.2
	OPENBSD_4_1_BASE:1.105
	OPENBSD_4_0:1.103.0.2
	OPENBSD_4_0_BASE:1.103
	OPENBSD_3_9:1.99.0.2
	OPENBSD_3_9_BASE:1.99
	OPENBSD_3_8:1.96.0.2
	OPENBSD_3_8_BASE:1.96
	OPENBSD_3_7:1.88.0.2
	OPENBSD_3_7_BASE:1.88
	OPENBSD_3_6:1.79.0.2
	OPENBSD_3_6_BASE:1.79
	SMP_SYNC_A:1.76
	SMP_SYNC_B:1.76
	OPENBSD_3_5:1.75.0.2
	OPENBSD_3_5_BASE:1.75
	OPENBSD_3_4:1.70.0.2
	OPENBSD_3_4_BASE:1.70
	UBC_SYNC_A:1.68
	OPENBSD_3_3:1.68.0.2
	OPENBSD_3_3_BASE:1.68
	OPENBSD_3_2:1.66.0.2
	OPENBSD_3_2_BASE:1.66
	OPENBSD_3_1:1.61.0.2
	OPENBSD_3_1_BASE:1.61
	UBC_SYNC_B:1.66
	UBC:1.60.0.2
	UBC_BASE:1.60
	OPENBSD_3_0:1.58.0.2
	OPENBSD_3_0_BASE:1.58
	OPENBSD_2_9_BASE:1.44
	OPENBSD_2_9:1.44.0.2
	OPENBSD_2_8:1.39.0.2
	OPENBSD_2_8_BASE:1.39
	OPENBSD_2_7:1.35.0.2
	OPENBSD_2_7_BASE:1.35
	SMP:1.34.0.2
	SMP_BASE:1.34
	kame_19991208:1.32
	OPENBSD_2_6:1.31.0.2
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.28.0.2
	OPENBSD_2_5_BASE:1.28
	OPENBSD_2_4:1.26.0.2
	OPENBSD_2_4_BASE:1.26
	OPENBSD_2_3:1.25.0.2
	OPENBSD_2_3_BASE:1.25
	OPENBSD_2_2:1.24.0.2
	OPENBSD_2_2_BASE:1.24
	OPENBSD_2_1:1.17.0.2
	OPENBSD_2_1_BASE:1.17
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.246
date	2017.05.31.05.59.09;	author mpi;	state Exp;
branches;
next	1.245;
commitid	XqMqqfSTUVDwiwE7;

1.245
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.244;
commitid	p51F2KIwIJB1dU8P;

1.244
date	2017.05.28.12.51.34;	author yasuoka;	state Exp;
branches;
next	1.243;
commitid	2vGVzcFLNmfkoMEp;

1.243
date	2017.05.22.01.56.22;	author dlg;	state Exp;
branches;
next	1.242;
commitid	DElywg6xAhLlzwy7;

1.242
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.241;
commitid	6c6qq5OdS4VVnyVM;

1.241
date	2016.10.11.11.40.12;	author mikeb;	state Exp;
branches;
next	1.240;
commitid	69hl53WMOpPLjsXx;

1.240
date	2016.10.10.02.44.17;	author dlg;	state Exp;
branches;
next	1.239;
commitid	3csUIPZAhZyJvnWM;

1.239
date	2016.07.12.09.33.13;	author mpi;	state Exp;
branches;
next	1.238;
commitid	bGHAD4QJZHhDusKV;

1.238
date	2016.06.08.12.57.58;	author mpi;	state Exp;
branches;
next	1.237;
commitid	3tTbgX0YOYAZziFF;

1.237
date	2016.05.31.07.48.19;	author mpi;	state Exp;
branches;
next	1.236;
commitid	ow1hjTBbfk2orGyW;

1.236
date	2016.05.18.20.15.14;	author mpi;	state Exp;
branches;
next	1.235;
commitid	GXDQtPDrSoQkUAr1;

1.235
date	2016.04.01.04.03.35;	author jsg;	state Exp;
branches;
next	1.234;
commitid	mLDEumOGraMzIlUg;

1.234
date	2016.03.01.01.48.14;	author dlg;	state Exp;
branches;
next	1.233;
commitid	ouNuJMxsb4QCBx8e;

1.233
date	2016.01.22.17.09.05;	author sf;	state Exp;
branches;
next	1.232;
commitid	5qBaP71Kk3Bu5OCW;

1.232
date	2016.01.08.13.53.24;	author mpi;	state Exp;
branches;
next	1.231;
commitid	l2mfiUCCi0ZhRviM;

1.231
date	2015.12.02.08.47.00;	author claudio;	state Exp;
branches;
next	1.230;
commitid	bBZq0t5zueGnkAtX;

1.230
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.229;
commitid	G2nTzngqgXpQqcJB;

1.229
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.228;
commitid	tp9bS9eCrwvRYjyO;

1.228
date	2015.09.29.10.11.40;	author deraadt;	state Exp;
branches;
next	1.227;
commitid	L3Bwt4zBOCs33Zbo;

1.227
date	2015.09.27.16.50.40;	author stsp;	state Exp;
branches;
next	1.226;
commitid	7pQnBFgz31Qa5o3q;

1.226
date	2015.09.17.04.53.27;	author dlg;	state Exp;
branches;
next	1.225;
commitid	v8IKw2ZwWZAKGiZb;

1.225
date	2015.09.13.10.42.32;	author dlg;	state Exp;
branches;
next	1.224;
commitid	KU5edmiQtbtt0saW;

1.224
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.223;
commitid	LU3jSOpFfLxcllFL;

1.223
date	2015.09.10.16.41.30;	author mikeb;	state Exp;
branches;
next	1.222;
commitid	Dj2db8t0KelqURhl;

1.222
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.221;
commitid	JbEzJsyDrWqOW57C;

1.221
date	2015.07.29.00.04.03;	author rzalamena;	state Exp;
branches;
next	1.220;
commitid	9x7oePEcDKgC05vn;

1.220
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.219;
commitid	t2fhFUpUuj89g4Sj;

1.219
date	2015.07.18.00.25.06;	author claudio;	state Exp;
branches;
next	1.218;
commitid	Th9VwH79DUy48R3N;

1.218
date	2015.07.17.21.58.07;	author rzalamena;	state Exp;
branches;
next	1.217;
commitid	mcxCGeLLrJsYHrgD;

1.217
date	2015.07.15.22.16.41;	author deraadt;	state Exp;
branches;
next	1.216;
commitid	ncpqEGjDtSFuLAgn;

1.216
date	2015.07.02.23.15.03;	author dlg;	state Exp;
branches;
next	1.215;
commitid	XIzHhlm2bBsSyPOM;

1.215
date	2015.07.02.15.16.57;	author mpi;	state Exp;
branches;
next	1.214;
commitid	NmSSHdQB6wwXPBPP;

1.214
date	2015.07.02.09.40.02;	author mpi;	state Exp;
branches;
next	1.213;
commitid	eKXa0TkOIth1tkBS;

1.213
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.212;
commitid	J4OPNuggl4DOKGzM;

1.212
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.211;
commitid	fE8TgA9vpwdUU5Wy;

1.211
date	2015.06.29.10.32.29;	author dlg;	state Exp;
branches;
next	1.210;
commitid	rqyNfIORa1UIJQnb;

1.210
date	2015.06.25.09.22.36;	author mpi;	state Exp;
branches;
next	1.209;
commitid	Ay7UhGlTVVuOtk7N;

1.209
date	2015.06.25.09.20.20;	author mpi;	state Exp;
branches;
next	1.208;
commitid	qTf6nSNIg5TdnuJD;

1.208
date	2015.06.25.09.10.15;	author mpi;	state Exp;
branches;
next	1.207;
commitid	YVZmr3fTlWxhsbkr;

1.207
date	2015.06.23.13.20.17;	author mpi;	state Exp;
branches;
next	1.206;
commitid	VHA7iwrVjcqP8Q9Q;

1.206
date	2015.06.23.09.42.23;	author mpi;	state Exp;
branches;
next	1.205;
commitid	p9JxIlTsQMWvTdAT;

1.205
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.204;
commitid	h7z8lokZ0dFyuWpg;

1.204
date	2015.06.08.13.44.08;	author mpi;	state Exp;
branches;
next	1.203;
commitid	QBkAtlGdp82XwFPf;

1.203
date	2015.06.08.13.40.48;	author mpi;	state Exp;
branches;
next	1.202;
commitid	HBw1Z8jFgWtpRSr4;

1.202
date	2015.06.02.09.38.24;	author mpi;	state Exp;
branches;
next	1.201;
commitid	9P4LdKlfMy8SaZ0b;

1.201
date	2015.05.26.11.39.07;	author mpi;	state Exp;
branches;
next	1.200;
commitid	VJjEISzzvhOYKF2A;

1.200
date	2015.05.26.11.36.26;	author dlg;	state Exp;
branches;
next	1.199;
commitid	XIDnUp3itFSZuopj;

1.199
date	2015.05.19.11.09.24;	author mpi;	state Exp;
branches;
next	1.198;
commitid	i7YRRkkCxLwyGmml;

1.198
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.197;
commitid	1aiWjheMGhmTuiHL;

1.197
date	2015.05.13.08.16.01;	author mpi;	state Exp;
branches;
next	1.196;
commitid	vrUnLjm6nwy7iRD7;

1.196
date	2015.05.11.08.41.43;	author mpi;	state Exp;
branches;
next	1.195;
commitid	clvzRlWWi271kseu;

1.195
date	2015.05.04.10.24.08;	author mpi;	state Exp;
branches;
next	1.194;
commitid	pcqNjYq7eK2oXz3l;

1.194
date	2015.04.13.08.52.51;	author mpi;	state Exp;
branches;
next	1.193;
commitid	eIjCB6UMjE3earTB;

1.193
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.192;
commitid	c7ei8kPelCOOwHXy;

1.192
date	2015.04.10.08.48.24;	author mpi;	state Exp;
branches;
next	1.191;
commitid	izQrYBwx0zII1gXv;

1.191
date	2015.04.07.10.46.20;	author mpi;	state Exp;
branches;
next	1.190;
commitid	m3c6YErI0cVMQeYc;

1.190
date	2015.03.17.14.51.27;	author mpi;	state Exp;
branches;
next	1.189;
commitid	4cwyUU1sgtU3wesa;

1.189
date	2015.02.16.18.24.02;	author markus;	state Exp;
branches;
next	1.188;
commitid	FGgaAyIP8iDNUN6K;

1.188
date	2015.02.09.00.21.58;	author dlg;	state Exp;
branches;
next	1.187;
commitid	APj0QFdmnmGzZark;

1.187
date	2015.02.08.06.00.52;	author mpi;	state Exp;
branches;
next	1.186;
commitid	LWJ12V7CpWdalkDf;

1.186
date	2015.02.06.16.00.30;	author benno;	state Exp;
branches;
next	1.185;
commitid	esqyv9JbOmOQ1StE;

1.185
date	2015.01.08.14.29.18;	author mpi;	state Exp;
branches;
next	1.184;
commitid	WNXddVtZkuvCWdN4;

1.184
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.183;
commitid	zhW8jJrfVCoAthrR;

1.183
date	2014.12.08.10.46.14;	author mpi;	state Exp;
branches;
next	1.182;
commitid	ExaN0TCQ4X0c1lo6;

1.182
date	2014.12.04.00.01.53;	author tedu;	state Exp;
branches;
next	1.181;
commitid	wP6d1LFSgXabDbTH;

1.181
date	2014.12.01.17.46.56;	author tedu;	state Exp;
branches;
next	1.180;
commitid	uXR6OAYMENjxgiU5;

1.180
date	2014.11.29.18.50.06;	author tedu;	state Exp;
branches;
next	1.179;
commitid	T4stiQgtm0SXik0w;

1.179
date	2014.11.20.14.51.42;	author krw;	state Exp;
branches;
next	1.178;
commitid	dOUqRDzYiPQXkCLL;

1.178
date	2014.11.19.19.47.52;	author tedu;	state Exp;
branches;
next	1.177;
commitid	iwUbuQfxc71LiK3L;

1.177
date	2014.11.06.14.28.47;	author henning;	state Exp;
branches;
next	1.176;
commitid	05Mz71nOYpaapgMd;

1.176
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.175;
commitid	w0MRp28dmfD1ZzO8;

1.175
date	2014.10.07.20.23.32;	author tedu;	state Exp;
branches;
next	1.174;
commitid	1hbxZJRSxjvGk5Dm;

1.174
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches
	1.174.4.1;
next	1.173;
commitid	B4dZSbxas1X1IpXI;

1.173
date	2014.07.08.07.10.12;	author dlg;	state Exp;
branches;
next	1.172;
commitid	LjJqbuphCuSi7amX;

1.172
date	2014.04.22.12.07.20;	author henning;	state Exp;
branches;
next	1.171;

1.171
date	2014.04.22.11.43.07;	author henning;	state Exp;
branches;
next	1.170;

1.170
date	2014.04.21.18.52.25;	author henning;	state Exp;
branches;
next	1.169;

1.169
date	2014.04.21.18.38.36;	author henning;	state Exp;
branches;
next	1.168;

1.168
date	2014.04.20.15.29.52;	author henning;	state Exp;
branches;
next	1.167;

1.167
date	2014.04.20.14.54.39;	author henning;	state Exp;
branches;
next	1.166;

1.166
date	2014.04.20.14.51.50;	author henning;	state Exp;
branches;
next	1.165;

1.165
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.164;

1.164
date	2014.03.26.15.13.59;	author mpi;	state Exp;
branches;
next	1.163;

1.163
date	2014.03.26.10.46.53;	author mpi;	state Exp;
branches;
next	1.162;

1.162
date	2014.02.17.14.48.48;	author mpi;	state Exp;
branches
	1.162.4.1;
next	1.161;

1.161
date	2014.01.22.09.35.20;	author mpi;	state Exp;
branches;
next	1.160;

1.160
date	2014.01.16.10.26.21;	author mpi;	state Exp;
branches;
next	1.159;

1.159
date	2013.11.18.20.22.23;	author deraadt;	state Exp;
branches;
next	1.158;

1.158
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.157;

1.157
date	2013.06.05.10.42.58;	author dlg;	state Exp;
branches;
next	1.156;

1.156
date	2013.06.03.12.32.06;	author kettenis;	state Exp;
branches;
next	1.155;

1.155
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.154;

1.154
date	2013.03.15.20.45.34;	author tedu;	state Exp;
branches;
next	1.153;

1.153
date	2013.01.18.12.10.11;	author sthen;	state Exp;
branches;
next	1.152;

1.152
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.151;

1.151
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2011.07.08.18.30.16;	author yasuoka;	state Exp;
branches;
next	1.149;

1.149
date	2011.07.04.23.58.26;	author claudio;	state Exp;
branches;
next	1.148;

1.148
date	2011.01.28.13.19.44;	author reyk;	state Exp;
branches;
next	1.147;

1.147
date	2010.10.11.11.31.14;	author claudio;	state Exp;
branches;
next	1.146;

1.146
date	2010.08.24.14.43.56;	author blambert;	state Exp;
branches;
next	1.145;

1.145
date	2010.07.02.00.49.43;	author claudio;	state Exp;
branches;
next	1.144;

1.144
date	2010.06.03.16.15.00;	author naddy;	state Exp;
branches;
next	1.143;

1.143
date	2010.05.28.12.09.09;	author claudio;	state Exp;
branches;
next	1.142;

1.142
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.141;

1.141
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.140;

1.140
date	2010.04.03.00.15.35;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2010.01.12.06.47.25;	author yasuoka;	state Exp;
branches;
next	1.138;

1.138
date	2010.01.12.03.41.29;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2010.01.11.03.50.56;	author yasuoka;	state Exp;
branches;
next	1.136;

1.136
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.135;

1.135
date	2009.08.12.20.02.42;	author dlg;	state Exp;
branches;
next	1.134;

1.134
date	2009.08.12.14.39.05;	author dlg;	state Exp;
branches;
next	1.133;

1.133
date	2009.06.05.00.05.21;	author claudio;	state Exp;
branches;
next	1.132;

1.132
date	2009.03.05.19.47.05;	author michele;	state Exp;
branches;
next	1.131;

1.131
date	2009.01.28.22.18.43;	author michele;	state Exp;
branches;
next	1.130;

1.130
date	2008.11.25.12.07.55;	author claudio;	state Exp;
branches;
next	1.129;

1.129
date	2008.11.24.12.57.37;	author dlg;	state Exp;
branches;
next	1.128;

1.128
date	2008.11.23.23.44.01;	author tedu;	state Exp;
branches;
next	1.127;

1.127
date	2008.10.16.19.12.51;	author naddy;	state Exp;
branches;
next	1.126;

1.126
date	2008.10.09.03.31.07;	author brad;	state Exp;
branches;
next	1.125;

1.125
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.124;

1.124
date	2008.08.28.13.10.54;	author brad;	state Exp;
branches;
next	1.123;

1.123
date	2008.08.04.18.55.08;	author damien;	state Exp;
branches;
next	1.122;

1.122
date	2008.06.13.23.24.21;	author mpf;	state Exp;
branches;
next	1.121;

1.121
date	2008.05.10.01.52.34;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2008.05.09.00.37.43;	author claudio;	state Exp;
branches;
next	1.119;

1.119
date	2008.05.07.05.51.12;	author mpf;	state Exp;
branches;
next	1.118;

1.118
date	2008.04.23.10.55.14;	author norby;	state Exp;
branches;
next	1.117;

1.117
date	2008.04.18.09.16.14;	author djm;	state Exp;
branches;
next	1.116;

1.116
date	2008.04.10.23.15.45;	author dlg;	state Exp;
branches;
next	1.115;

1.115
date	2008.04.10.22.33.14;	author brad;	state Exp;
branches;
next	1.114;

1.114
date	2008.02.05.22.57.30;	author mpf;	state Exp;
branches;
next	1.113;

1.113
date	2008.01.17.17.50.59;	author bluhm;	state Exp;
branches;
next	1.112;

1.112
date	2007.11.22.01.21.40;	author mpf;	state Exp;
branches;
next	1.111;

1.111
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2007.06.06.10.04.36;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.29.20.19.37;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2007.05.16.20.27.58;	author michele;	state Exp;
branches;
next	1.107;

1.107
date	2007.05.16.09.24.07;	author dlg;	state Exp;
branches;
next	1.106;

1.106
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.105;

1.105
date	2006.12.07.18.15.29;	author reyk;	state Exp;
branches;
next	1.104;

1.104
date	2006.10.31.14.28.29;	author jason;	state Exp;
branches;
next	1.103;

1.103
date	2006.06.16.16.49.39;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2006.05.26.20.50.41;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.19.19.50.23;	author reyk;	state Exp;
branches;
next	1.100;

1.100
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.99;

1.99
date	2005.11.03.20.00.18;	author reyk;	state Exp;
branches;
next	1.98;

1.98
date	2005.10.17.08.43.35;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2005.09.30.02.39.24;	author brad;	state Exp;
branches;
next	1.96;

1.96
date	2005.06.08.06.55.33;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2005.06.07.07.09.42;	author camield;	state Exp;
branches;
next	1.94;

1.94
date	2005.06.07.02.45.11;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2005.05.24.16.28.03;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2005.05.24.16.00.02;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2005.05.24.07.51.53;	author reyk;	state Exp;
branches;
next	1.90;

1.90
date	2005.05.24.02.45.17;	author reyk;	state Exp;
branches;
next	1.89;

1.89
date	2005.04.25.01.34.27;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2005.01.18.23.26.52;	author mpf;	state Exp;
branches;
next	1.87;

1.87
date	2004.12.19.03.25.36;	author mcbride;	state Exp;
branches;
next	1.86;

1.86
date	2004.12.17.12.42.02;	author pascoe;	state Exp;
branches;
next	1.85;

1.85
date	2004.12.10.22.35.17;	author mcbride;	state Exp;
branches;
next	1.84;

1.84
date	2004.12.09.16.57.35;	author mcbride;	state Exp;
branches;
next	1.83;

1.83
date	2004.12.07.20.38.46;	author mcbride;	state Exp;
branches;
next	1.82;

1.82
date	2004.12.07.19.26.46;	author mcbride;	state Exp;
branches;
next	1.81;

1.81
date	2004.11.28.23.39.45;	author canacar;	state Exp;
branches;
next	1.80;

1.80
date	2004.10.09.19.55.29;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2004.07.16.15.01.08;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2004.06.26.06.01.14;	author naddy;	state Exp;
branches;
next	1.77;

1.77
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.76;

1.76
date	2004.04.17.00.09.01;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.15.02.52.41;	author avsm;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.09.10.44.32;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.72;

1.72
date	2003.10.25.19.31.05;	author mcbride;	state Exp;
branches;
next	1.71;

1.71
date	2003.10.17.21.04.58;	author mcbride;	state Exp;
branches;
next	1.70;

1.70
date	2003.08.18.11.01.41;	author dhartmei;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.66;

1.66
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.10.22.48.09;	author chris;	state Exp;
branches;
next	1.63;

1.63
date	2002.05.17.07.21.53;	author kjc;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.07.19.28.58;	author nate;	state Exp;
branches;
next	1.61;

1.61
date	2002.02.07.23.20.57;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2001.12.09.13.09.13;	author jason;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2001.11.30.07.59.17;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2001.10.03.11.34.38;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2001.09.20.18.55.55;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2001.09.20.16.07.21;	author peter;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.19.15.28.24;	author jason;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.30.21.48.58;	author jason;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.25.03.28.19;	author jason;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.27.06.07.40;	author kjc;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.24.22.34.04;	author fgsch;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.23.22.52.51;	author fgsch;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.23.06.20.35;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.23.04.01.18;	author aaron;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.15.03.38.33;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.14.02.13.58;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.28.19.51.06;	author dugsong;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.23.02.15.23;	author jason;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2001.03.22.05.26.35;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.20.19.39.27;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.01.01.32.51;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2000.12.12.03.41.22;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.18.16.16.33;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.07.04.48.58;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.02.15.44.56;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.02.00.36.41;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.26.19.03.11;	author chris;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.07.06.09.08;	author itojun;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.01.11.19.27.52;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	99.09.01.21.38.48;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	99.08.08.02.42.58;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	99.02.26.17.01.32;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	99.01.08.00.56.45;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.07.07.19.26.18;	author ryker;	state Exp;
branches;
next	1.25;

1.25
date	98.02.03.19.06.28;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.09.27.02.35.57;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.07.27.05.28.34;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.07.24.22.59.29;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.07.23.20.37.19;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.07.23.20.20.10;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.07.23.16.13.26;	author denny;	state Exp;
branches;
next	1.18;

1.18
date	97.07.23.03.46.01;	author denny;	state Exp;
branches;
next	1.17;

1.17
date	97.01.26.21.43.36;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	97.01.02.20.45.49;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.12.19.12.58.14;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	96.12.19.10.59.21;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	96.06.02.16.31.01;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.05.10.12.31.08;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.05.06.14.13.53;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.05.06.05.43.41;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.05.05.13.39.50;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.05.02.13.45.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.29.11.42.06;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.04.29.01.13.01;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.04.28.14.36.59;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.04.19.18.12.28;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.21.07.07;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.36.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches;
next	;

1.34.2.1
date	2001.05.14.22.40.00;	author niklas;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.07.04.10.53.59;	author niklas;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.34.2.8;

1.34.2.8
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.34.2.9;

1.34.2.9
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.44.2.1
date	2001.07.29.13.20.00;	author jason;	state Exp;
branches;
next	;

1.60.2.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.60.2.3;

1.60.2.3
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;

1.162.4.1
date	2014.12.01.17.51.41;	author tedu;	state Exp;
branches;
next	;
commitid	ZNYYkxE05Lm2yI71;

1.174.4.1
date	2014.12.01.17.50.43;	author tedu;	state Exp;
branches;
next	;
commitid	4lab5uD0jzDYHoZf;


desc
@@


1.246
log
@Move IPv4 & IPv6 incoming/forwarding path, PIPEX ppp processing and
IPv4 & IPv6 dispatch functions outside the KERNEL_LOCK().

We currently rely on the NET_LOCK() serializing access to most global
data structures for that.  IP input queues are no longer used in the
forwarding case.  They still exist as boundary between the network and
transport layers because TCP/UDP & friends still need the KERNEL_LOCK().

Since we do not want to grab the NET_LOCK() for every packet, the
softnet thread will do it once before processing a batch.  That means
the L2 processing path, which is currently running without lock, will
now run with the NET_LOCK().

IPsec isn't ready to run without KERNEL_LOCK(), so the softnet thread
will grab the KERNEL_LOCK() as soon as ``ipsec_in_use'' is set.

Tested by Hrvoje Popovski.

ok visa@@, bluhm@@, henning@@
@
text
@/*	$OpenBSD: if_ethersubr.c,v 1.245 2017/05/30 07:50:37 mpi Exp $	*/
/*	$NetBSD: if_ethersubr.c,v 1.19 1996/05/07 02:40:30 thorpej Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_ethersubr.c	8.1 (Berkeley) 6/10/93
 */

/*
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/if_llc.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_types.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip_ipsp.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include "pppoe.h"
#if NPPPOE > 0
#include <net/if_pppoe.h>
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>
#endif

#ifdef PIPEX
#include <net/pipex.h>
#endif

#ifdef MPLS
#include <netmpls/mpls.h>
#endif /* MPLS */

u_int8_t etherbroadcastaddr[ETHER_ADDR_LEN] =
    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
u_int8_t etheranyaddr[ETHER_ADDR_LEN] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
#define senderr(e) { error = (e); goto bad;}

int
ether_ioctl(struct ifnet *ifp, struct arpcom *arp, u_long cmd, caddr_t data)
{
	struct ifreq *ifr = (struct ifreq *)data;
	int error = 0;

	switch (cmd) {
	case SIOCSIFADDR:
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		if (ifp->if_flags & IFF_MULTICAST) {
			error = (cmd == SIOCADDMULTI) ?
			    ether_addmulti(ifr, arp) :
			    ether_delmulti(ifr, arp);
		} else
			error = ENOTTY;
		break;

	default:
		error = ENOTTY;
	}

	return (error);
}


void
ether_rtrequest(struct ifnet *ifp, int req, struct rtentry *rt)
{
	switch (rt_key(rt)->sa_family) {
	case AF_INET:
		arp_rtrequest(ifp, req, rt);
		break;
#ifdef INET6
	case AF_INET6:
		nd6_rtrequest(ifp, req, rt);
		break;
#endif
	default:
		break;
	}
}
/*
 * Ethernet output routine.
 * Encapsulate a packet of type family for the local net.
 * Assumes that ifp is actually pointer to arpcom structure.
 */
int
ether_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	u_int16_t etype;
	u_char edst[ETHER_ADDR_LEN];
	u_char *esrc;
	struct mbuf *mcopy = NULL;
	struct ether_header *eh;
	struct arpcom *ac = (struct arpcom *)ifp;
	sa_family_t af = dst->sa_family;
	int error = 0;

	KASSERT(rt != NULL || ISSET(m->m_flags, M_MCAST|M_BCAST) ||
		af == AF_UNSPEC || af == pseudo_AF_HDRCMPLT);

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.ph_rtableid));
	}
#endif

	esrc = ac->ac_enaddr;

	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		senderr(ENETDOWN);

	switch (af) {
	case AF_INET:
		error = arpresolve(ifp, rt, m, dst, edst);
		if (error)
			return (error == EAGAIN ? 0 : error);
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    !m->m_pkthdr.pf.routed)
			mcopy = m_copym(m, 0, M_COPYALL, M_NOWAIT);
		etype = htons(ETHERTYPE_IP);
		break;
#ifdef INET6
	case AF_INET6:
		error = nd6_resolve(ifp, rt, m, dst, edst);
		if (error)
			return (error == EAGAIN ? 0 : error);
		etype = htons(ETHERTYPE_IPV6);
		break;
#endif
#ifdef MPLS
	case AF_MPLS:
		if (rt)
			dst = rt_key(rt);
		else
			senderr(EHOSTUNREACH);

		if (!ISSET(ifp->if_xflags, IFXF_MPLS))
			senderr(ENETUNREACH);

		switch (dst->sa_family) {
			case AF_LINK:
				if (satosdl(dst)->sdl_alen < sizeof(edst))
					senderr(EHOSTUNREACH);
				memcpy(edst, LLADDR(satosdl(dst)),
				    sizeof(edst));
				break;
			case AF_INET:
			case AF_MPLS:
				error = arpresolve(ifp, rt, m, dst, edst);
				if (error)
					return (error == EAGAIN ? 0 : error);
				break;
			default:
				senderr(EHOSTUNREACH);
		}
		/* XXX handling for simplex devices in case of M/BCAST ?? */
		if (m->m_flags & (M_BCAST | M_MCAST))
			etype = htons(ETHERTYPE_MPLS_MCAST);
		else
			etype = htons(ETHERTYPE_MPLS);
		break;
#endif /* MPLS */
	case pseudo_AF_HDRCMPLT:
		eh = (struct ether_header *)dst->sa_data;
		esrc = eh->ether_shost;
		/* FALLTHROUGH */

	case AF_UNSPEC:
		eh = (struct ether_header *)dst->sa_data;
		memcpy(edst, eh->ether_dhost, sizeof(edst));
		/* AF_UNSPEC doesn't swap the byte order of the ether_type. */
		etype = eh->ether_type;
		break;

	default:
		printf("%s: can't handle af%d\n", ifp->if_xname,
			dst->sa_family);
		senderr(EAFNOSUPPORT);
	}

	/* XXX Should we feed-back an unencrypted IPsec packet ? */
	if (mcopy)
		if_input_local(ifp, mcopy, dst->sa_family);

	M_PREPEND(m, sizeof(struct ether_header) + ETHER_ALIGN, M_DONTWAIT);
	if (m == NULL)
		return (ENOBUFS);
	m_adj(m, ETHER_ALIGN);
	eh = mtod(m, struct ether_header *);
	eh->ether_type = etype;
	memcpy(eh->ether_dhost, edst, sizeof(eh->ether_dhost));
	memcpy(eh->ether_shost, esrc, sizeof(eh->ether_shost));

	return (if_enqueue(ifp, m));
bad:
	m_freem(m);
	return (error);
}

/*
 * Process a received Ethernet packet;
 * the packet is in the mbuf chain m without
 * the ether header, which is provided separately.
 */
int
ether_input(struct ifnet *ifp, struct mbuf *m, void *cookie)
{
	struct ether_header *eh;
	struct niqueue *inq;
	u_int16_t etype;
	int llcfound = 0;
	struct llc *l;
	struct arpcom *ac;
#if NPPPOE > 0
	struct ether_header *eh_tmp;
#endif

	/* Drop short frames */
	if (m->m_len < ETHER_HDR_LEN)
		goto dropanyway;

	ac = (struct arpcom *)ifp;
	eh = mtod(m, struct ether_header *);
	m_adj(m, ETHER_HDR_LEN);

	if (ETHER_IS_MULTICAST(eh->ether_dhost)) {
		/*
		 * If this is not a simplex interface, drop the packet
		 * if it came from us.
		 */
		if ((ifp->if_flags & IFF_SIMPLEX) == 0) {
			if (memcmp(ac->ac_enaddr, eh->ether_shost,
			    ETHER_ADDR_LEN) == 0) {
				m_freem(m);
				return (1);
			}
		}

		if (memcmp(etherbroadcastaddr, eh->ether_dhost,
		    sizeof(etherbroadcastaddr)) == 0)
			m->m_flags |= M_BCAST;
		else
			m->m_flags |= M_MCAST;
		ifp->if_imcasts++;
	}

	/*
	 * HW vlan tagged packets that were not collected by vlan(4) must
	 * be dropped now.
	 */
	if (m->m_flags & M_VLANTAG) {
		m_freem(m);
		return (1);
	}

	/*
	 * If packet is unicast, make sure it is for us.  Drop otherwise.
	 * This check is required in promiscous mode, and for some hypervisors
	 * where the MAC filter is 'best effort' only.
	 */
	if ((m->m_flags & (M_BCAST|M_MCAST)) == 0) {
		if (memcmp(ac->ac_enaddr, eh->ether_dhost, ETHER_ADDR_LEN)) {
			m_freem(m);
			return (1);
		}
	}

	etype = ntohs(eh->ether_type);

decapsulate:
	switch (etype) {
	case ETHERTYPE_IP:
		ipv4_input(ifp, m);
		return (1);

	case ETHERTYPE_ARP:
		if (ifp->if_flags & IFF_NOARP)
			goto dropanyway;
		arpinput(ifp, m);
		return (1);

	case ETHERTYPE_REVARP:
		if (ifp->if_flags & IFF_NOARP)
			goto dropanyway;
		revarpinput(ifp, m);
		return (1);

#ifdef INET6
	/*
	 * Schedule IPv6 software interrupt for incoming IPv6 packet.
	 */
	case ETHERTYPE_IPV6:
		ipv6_input(ifp, m);
		return (1);
#endif /* INET6 */
#if NPPPOE > 0 || defined(PIPEX)
	case ETHERTYPE_PPPOEDISC:
	case ETHERTYPE_PPPOE:
		if (m->m_flags & (M_MCAST | M_BCAST))
			goto dropanyway;
		M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
		if (m == NULL)
			return (1);

		eh_tmp = mtod(m, struct ether_header *);
		/*
		 * danger!
		 * eh_tmp and eh may overlap because eh
		 * is stolen from the mbuf above.
		 */
		memmove(eh_tmp, eh, sizeof(struct ether_header));
#ifdef PIPEX
		if (pipex_enable) {
			struct pipex_session *session;

			if ((session = pipex_pppoe_lookup_session(m)) != NULL) {
				pipex_pppoe_input(m, session);
				return (1);
			}
		}
#endif
		if (etype == ETHERTYPE_PPPOEDISC)
			inq = &pppoediscinq;
		else
			inq = &pppoeinq;
		break;
#endif
#ifdef MPLS
	case ETHERTYPE_MPLS:
	case ETHERTYPE_MPLS_MCAST:
		mpls_input(m);
		return (1);
#endif
	default:
		if (llcfound || etype > ETHERMTU ||
		    m->m_len < sizeof(struct llc))
			goto dropanyway;
		llcfound = 1;
		l = mtod(m, struct llc *);
		switch (l->llc_dsap) {
		case LLC_SNAP_LSAP:
			if (l->llc_control == LLC_UI &&
			    l->llc_dsap == LLC_SNAP_LSAP &&
			    l->llc_ssap == LLC_SNAP_LSAP) {
				/* SNAP */
				if (m->m_pkthdr.len > etype)
					m_adj(m, etype - m->m_pkthdr.len);
				m_adj(m, 6);
				M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
				if (m == NULL)
					return (1);
				*mtod(m, struct ether_header *) = *eh;
				goto decapsulate;
			}
		default:
			goto dropanyway;
		}
	}

	niq_enqueue(inq, m);
	return (1);
dropanyway:
	m_freem(m);
	return (1);
}

/*
 * Convert Ethernet address to printable (loggable) representation.
 */
static char digits[] = "0123456789abcdef";
char *
ether_sprintf(u_char *ap)
{
	int i;
	static char etherbuf[ETHER_ADDR_LEN * 3];
	char *cp = etherbuf;

	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		*cp++ = digits[*ap >> 4];
		*cp++ = digits[*ap++ & 0xf];
		*cp++ = ':';
	}
	*--cp = 0;
	return (etherbuf);
}

/*
 * Generate a (hopefully) acceptable MAC address, if asked.
 */
void
ether_fakeaddr(struct ifnet *ifp)
{
	static int unit;
	int rng = arc4random();

	/* Non-multicast; locally administered address */
	((struct arpcom *)ifp)->ac_enaddr[0] = 0xfe;
	((struct arpcom *)ifp)->ac_enaddr[1] = 0xe1;
	((struct arpcom *)ifp)->ac_enaddr[2] = 0xba;
	((struct arpcom *)ifp)->ac_enaddr[3] = 0xd0 | (unit++ & 0xf);
	((struct arpcom *)ifp)->ac_enaddr[4] = rng;
	((struct arpcom *)ifp)->ac_enaddr[5] = rng >> 8;
}

/*
 * Perform common duties while attaching to interface list
 */
void
ether_ifattach(struct ifnet *ifp)
{
	struct arpcom *ac = (struct arpcom *)ifp;

	/*
	 * Any interface which provides a MAC address which is obviously
	 * invalid gets whacked, so that users will notice.
	 */
	if (ETHER_IS_MULTICAST(((struct arpcom *)ifp)->ac_enaddr))
		ether_fakeaddr(ifp);

	ifp->if_type = IFT_ETHER;
	ifp->if_addrlen = ETHER_ADDR_LEN;
	ifp->if_hdrlen = ETHER_HDR_LEN;
	ifp->if_mtu = ETHERMTU;
	ifp->if_output = ether_output;
	ifp->if_rtrequest = ether_rtrequest;

	if_ih_insert(ifp, ether_input, NULL);

	if (ifp->if_hardmtu == 0)
		ifp->if_hardmtu = ETHERMTU;

	if_alloc_sadl(ifp);
	memcpy(LLADDR(ifp->if_sadl), ac->ac_enaddr, ifp->if_addrlen);
	LIST_INIT(&ac->ac_multiaddrs);
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, ETHER_HDR_LEN);
#endif
}

void
ether_ifdetach(struct ifnet *ifp)
{
	struct arpcom *ac = (struct arpcom *)ifp;
	struct ether_multi *enm;

	/* Undo pseudo-driver changes. */
	if_deactivate(ifp);

	if_ih_remove(ifp, ether_input, NULL);

	KASSERT(SRPL_EMPTY_LOCKED(&ifp->if_inputs));

	for (enm = LIST_FIRST(&ac->ac_multiaddrs);
	    enm != NULL;
	    enm = LIST_FIRST(&ac->ac_multiaddrs)) {
		LIST_REMOVE(enm, enm_list);
		free(enm, M_IFMADDR, sizeof *enm);
	}
}

#if 0
/*
 * This is for reference.  We have table-driven versions of the
 * crc32 generators, which are faster than the double-loop.
 */
u_int32_t __pure
ether_crc32_le_update(u_int_32_t crc, const u_int8_t *buf, size_t len)
{
	u_int32_t c, carry;
	size_t i, j;

	for (i = 0; i < len; i++) {
		c = buf[i];
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x01) ? 1 : 0) ^ (c & 0x01);
			crc >>= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ ETHER_CRC_POLY_LE);
		}
	}

	return (crc);
}

u_int32_t __pure
ether_crc32_be_update(u_int_32_t crc, const u_int8_t *buf, size_t len)
{
	u_int32_t c, carry;
	size_t i, j;

	for (i = 0; i < len; i++) {
		c = buf[i];
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000U) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ ETHER_CRC_POLY_BE) | carry;
		}
	}

	return (crc);
}
#else
u_int32_t __pure
ether_crc32_le_update(u_int32_t crc, const u_int8_t *buf, size_t len)
{
	static const u_int32_t crctab[] = {
		0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
	};
	size_t i;

	for (i = 0; i < len; i++) {
		crc ^= buf[i];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
	}

	return (crc);
}

u_int32_t __pure
ether_crc32_be_update(u_int32_t crc, const u_int8_t *buf, size_t len)
{
	static const u_int8_t rev[] = {
		0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6, 0xe,
		0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf
	};
	static const u_int32_t crctab[] = {
		0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
		0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
		0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
		0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd
	};
	size_t i;
	u_int8_t data;

	for (i = 0; i < len; i++) {
		data = buf[i];
		crc = (crc << 4) ^ crctab[(crc >> 28) ^ rev[data & 0xf]];
		crc = (crc << 4) ^ crctab[(crc >> 28) ^ rev[data >> 4]];
	}

	return (crc);
}
#endif

u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
{
	return ether_crc32_le_update(0xffffffff, buf, len);
}

u_int32_t
ether_crc32_be(const u_int8_t *buf, size_t len)
{
	return ether_crc32_be_update(0xffffffff, buf, len);
}

u_char	ether_ipmulticast_min[ETHER_ADDR_LEN] =
    { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x00 };
u_char	ether_ipmulticast_max[ETHER_ADDR_LEN] =
    { 0x01, 0x00, 0x5e, 0x7f, 0xff, 0xff };

#ifdef INET6
u_char	ether_ip6multicast_min[ETHER_ADDR_LEN] =
    { 0x33, 0x33, 0x00, 0x00, 0x00, 0x00 };
u_char	ether_ip6multicast_max[ETHER_ADDR_LEN] =
    { 0x33, 0x33, 0xff, 0xff, 0xff, 0xff };
#endif

/*
 * Convert a sockaddr into an Ethernet address or range of Ethernet
 * addresses.
 */
int
ether_multiaddr(struct sockaddr *sa, u_int8_t addrlo[ETHER_ADDR_LEN],
    u_int8_t addrhi[ETHER_ADDR_LEN])
{
	struct sockaddr_in *sin;
#ifdef INET6
	struct sockaddr_in6 *sin6;
#endif /* INET6 */

	switch (sa->sa_family) {

	case AF_UNSPEC:
		memcpy(addrlo, sa->sa_data, ETHER_ADDR_LEN);
		memcpy(addrhi, addrlo, ETHER_ADDR_LEN);
		break;

	case AF_INET:
		sin = satosin(sa);
		if (sin->sin_addr.s_addr == INADDR_ANY) {
			/*
			 * An IP address of INADDR_ANY means listen to
			 * or stop listening to all of the Ethernet
			 * multicast addresses used for IP.
			 * (This is for the sake of IP multicast routers.)
			 */
			memcpy(addrlo, ether_ipmulticast_min, ETHER_ADDR_LEN);
			memcpy(addrhi, ether_ipmulticast_max, ETHER_ADDR_LEN);
		} else {
			ETHER_MAP_IP_MULTICAST(&sin->sin_addr, addrlo);
			memcpy(addrhi, addrlo, ETHER_ADDR_LEN);
		}
		break;
#ifdef INET6
	case AF_INET6:
		sin6 = satosin6(sa);
		if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
			/*
			 * An IP6 address of 0 means listen to or stop
			 * listening to all of the Ethernet multicast
			 * address used for IP6.
			 *
			 * (This might not be healthy, given IPv6's reliance on
			 * multicast for things like neighbor discovery.
			 * Perhaps initializing all-nodes, solicited nodes, and
			 * possibly all-routers for this interface afterwards
			 * is not a bad idea.)
			 */

			memcpy(addrlo, ether_ip6multicast_min, ETHER_ADDR_LEN);
			memcpy(addrhi, ether_ip6multicast_max, ETHER_ADDR_LEN);
		} else {
			ETHER_MAP_IPV6_MULTICAST(&sin6->sin6_addr, addrlo);
			memcpy(addrhi, addrlo, ETHER_ADDR_LEN);
		}
		break;
#endif

	default:
		return (EAFNOSUPPORT);
	}
	return (0);
}

/*
 * Add an Ethernet multicast address or range of addresses to the list for a
 * given interface.
 */
int
ether_addmulti(struct ifreq *ifr, struct arpcom *ac)
{
	struct ether_multi *enm;
	u_char addrlo[ETHER_ADDR_LEN];
	u_char addrhi[ETHER_ADDR_LEN];
	int s = splnet(), error;

	error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	if (error != 0) {
		splx(s);
		return (error);
	}

	/*
	 * Verify that we have valid Ethernet multicast addresses.
	 */
	if ((addrlo[0] & 0x01) != 1 || (addrhi[0] & 0x01) != 1) {
		splx(s);
		return (EINVAL);
	}
	/*
	 * See if the address range is already in the list.
	 */
	ETHER_LOOKUP_MULTI(addrlo, addrhi, ac, enm);
	if (enm != NULL) {
		/*
		 * Found it; just increment the reference count.
		 */
		++enm->enm_refcount;
		splx(s);
		return (0);
	}
	/*
	 * New address or range; malloc a new multicast record
	 * and link it into the interface's multicast list.
	 */
	enm = malloc(sizeof(*enm), M_IFMADDR, M_NOWAIT);
	if (enm == NULL) {
		splx(s);
		return (ENOBUFS);
	}
	memcpy(enm->enm_addrlo, addrlo, ETHER_ADDR_LEN);
	memcpy(enm->enm_addrhi, addrhi, ETHER_ADDR_LEN);
	enm->enm_refcount = 1;
	LIST_INSERT_HEAD(&ac->ac_multiaddrs, enm, enm_list);
	ac->ac_multicnt++;
	if (memcmp(addrlo, addrhi, ETHER_ADDR_LEN) != 0)
		ac->ac_multirangecnt++;
	splx(s);
	/*
	 * Return ENETRESET to inform the driver that the list has changed
	 * and its reception filter should be adjusted accordingly.
	 */
	return (ENETRESET);
}

/*
 * Delete a multicast address record.
 */
int
ether_delmulti(struct ifreq *ifr, struct arpcom *ac)
{
	struct ether_multi *enm;
	u_char addrlo[ETHER_ADDR_LEN];
	u_char addrhi[ETHER_ADDR_LEN];
	int s = splnet(), error;

	error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	if (error != 0) {
		splx(s);
		return (error);
	}

	/*
	 * Look up the address in our list.
	 */
	ETHER_LOOKUP_MULTI(addrlo, addrhi, ac, enm);
	if (enm == NULL) {
		splx(s);
		return (ENXIO);
	}
	if (--enm->enm_refcount != 0) {
		/*
		 * Still some claims to this record.
		 */
		splx(s);
		return (0);
	}
	/*
	 * No remaining claims to this record; unlink and free it.
	 */
	LIST_REMOVE(enm, enm_list);
	free(enm, M_IFMADDR, sizeof *enm);
	ac->ac_multicnt--;
	if (memcmp(addrlo, addrhi, ETHER_ADDR_LEN) != 0)
		ac->ac_multirangecnt--;
	splx(s);
	/*
	 * Return ENETRESET to inform the driver that the list has changed
	 * and its reception filter should be adjusted accordingly.
	 */
	return (ENETRESET);
}
@


1.245
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.244 2017/05/28 12:51:34 yasuoka Exp $	*/
a418 1
			int s;
a419 1
			NET_LOCK(s);
a421 1
				NET_UNLOCK(s);
a423 1
			NET_UNLOCK(s);
@


1.244
log
@Remove all splnet/splx from pipex(4) and pppx(4) and replace some of
them by NET_LOCK/NET_UNLOCK.  Also make the timeout for pipex_timer
run with a thread context and replace pipex softintr by NETISR_PIPEX.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.243 2017/05/22 01:56:22 dlg Exp $	*/
d377 2
a378 2
		inq = &ipintrq;
		break;
d397 2
a398 2
		inq = &ip6intrq;
		break;
@


1.243
log
@white space fix. no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.242 2017/01/24 10:08:30 krw Exp $	*/
d419 1
d421 1
a421 1
			KERNEL_LOCK();
d424 1
a424 1
				KERNEL_UNLOCK();
d427 1
a427 1
			KERNEL_UNLOCK();
@


1.242
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.241 2016/10/11 11:40:12 mikeb Exp $	*/
d235 1
a235 1
       case AF_MPLS:
@


1.241
log
@Strengthen Ethernet packet length checks on input;  ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.240 2016/10/10 02:44:17 dlg Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
@


1.240
log
@ensure prepended ethernet headers are placed on ETHER_ALIGN boundaries,
even if m_prepend allocates a new mbuf in front of the current one.

this is done by asking M_PREPEND for ETHER_HDR_LEN + ETHER_ALIGN bytes,
and then calling m_adj(ETHER_ALIGN) after.

in the case M_PREPEND does not allocate a new mbuf and ends up with the
same layout as before.

in the allocation case, the requested length is provided on a long
boundary. an ETHER_HDR_LEN request would therefore be 6 bytes
allocated on a long boundary, when we want it to be at ETHER_ALIGN.
by asking for ETHER_HDR_LEN plus ETHER_ALIGN, we can m_adj ETHER_ALIGN
off to get us to the ETHER_ALIGN offset.

ok yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.239 2016/07/12 09:33:13 mpi Exp $	*/
d322 4
d442 2
a443 1
		if (llcfound || etype > ETHERMTU)
@


1.239
log
@Directly drop packets filtered by bpf(4) instead of going through the
input handlers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.238 2016/06/08 12:57:58 mpi Exp $	*/
d289 1
a289 1
	M_PREPEND(m, sizeof(struct ether_header), M_DONTWAIT);
d292 1
@


1.238
log
@Move ND resoluton logic from nd6_output() to nd6_storelladdr() and
rename it to nd6_resolve().

This allows us to get rid of non-Ethernet hacks by moving Ethernet
specific logic in the appropriate layer.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.237 2016/05/31 07:48:19 mpi Exp $	*/
d347 2
a348 3
	 * If packet has been filtered by the bpf listener, drop it now
	 * also HW vlan tagged packets that were not collected by vlan(4)
	 * must be dropped now.
d350 1
a350 1
	if (m->m_flags & (M_FILDROP | M_VLANTAG)) {
@


1.237
log
@Ensure that a valid route entry is passed to ether_output() if L2
resolution is required.

This will allow us to enforce that no route entry is inserted in
the routing table after ether_output().

This is now possible because if_output() is no longer called with
a NULL route argument.

Tested by Hrvoje Popovski, ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.236 2016/05/18 20:15:14 mpi Exp $	*/
d228 1
a228 1
		error = nd6_storelladdr(ifp, rt, m, dst, (u_char *)edst);
d230 1
a230 1
			return (error);
@


1.236
log
@Remove some superflous if_get(9)/if_put(9) dances now that ARP input
routines are call directly by ether_input().

ok visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.235 2016/04/01 04:03:35 jsg Exp $	*/
d196 1
d199 3
d215 1
a215 1
	switch (dst->sa_family) {
@


1.235
log
@Building kernels with PPPOE_SERVER enabled has been broken for at least
eleven years, remove it.

Despite what the wildly outdated time(9) claims, there is no longer
globally visible "struct timeval mono_time" or "struct timeval time".

ok mpi@@ sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.234 2016/03/01 01:48:14 dlg Exp $	*/
d375 1
a375 1
		arpinput(m);
d381 1
a381 1
		revarpinput(m);
@


1.234
log
@enm_ac in ether_multi is set but never used. so we dont need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.233 2016/01/22 17:09:05 sf Exp $	*/
a394 1
#ifndef PPPOE_SERVER
a396 1
#endif
@


1.233
log
@Always check destination MAC address of received unicast packets, not
only when in promiscuous mode

This necessary for NICs like virtio, where the unicast MAC filter is
'best effort' only.

ok dlg@@
encouragement from mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.232 2016/01/08 13:53:24 mpi Exp $	*/
a790 1
	enm->enm_ac = ac;
@


1.232
log
@Get rid of the arp and revarp input queues.

Packets of types ARP and REVARP are now processed in the softnet task,
directly from ether_input() and without holding the KERNEL_LOCK.

Tested by many, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.231 2015/12/02 08:47:00 claudio Exp $	*/
d353 3
a355 2
	 * If packet is unicast and we're in promiscuous mode, make sure it
	 * is for us.  Drop otherwise.
d357 1
a357 2
	if ((m->m_flags & (M_BCAST|M_MCAST)) == 0 &&
	    (ifp->if_flags & IFF_PROMISC)) {
@


1.231
log
@Rework the MPLS handling. Remove the lookup loops since nothing is using
them and they make everything so much harder with no gain. Remove the
ifp argument from mpls_input since it is not needed. On the input side
the lookup side is modified a bit when it comes to BOS handling.
Tested in a L3VPN setup with ldpd and bgpd. Commiting now so we can move
on with cleaning up rt_ifp usage. If this breaks L2VPN I will fix it once
reported. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.230 2015/10/25 11:58:11 mpi Exp $	*/
d375 2
a376 2
		inq = &arpintrq;
		break;
d381 2
a382 2
		inq = &rarpintrq;
		break;
@


1.230
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.229 2015/10/22 15:37:47 bluhm Exp $	*/
d432 1
a432 1
		mpls_input(ifp, m);
@


1.229
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.228 2015/09/29 10:11:40 deraadt Exp $	*/
d164 17
d525 1
@


1.228
log
@add sizes to some of the simpler free calls
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.227 2015/09/27 16:50:40 stsp Exp $	*/
d225 1
a225 2
				if (((struct sockaddr_dl *)dst)->sdl_alen <
				    sizeof(edst))
d227 1
a227 1
				memcpy(edst, LLADDR((struct sockaddr_dl *)dst),
@


1.227
log
@Welcome etheranyaddr, cousin of etherbroadcastaddr.
Can be used to check if a MAC address is all zeros.
Will be used by iwm(4) soon.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.226 2015/09/17 04:53:27 dlg Exp $	*/
d540 1
a540 1
		free(enm, M_IFMADDR, 0);
d824 1
a824 1
	free(enm, M_IFMADDR, 0);
@


1.226
log
@instead of leaking rarp packets, break from the switch statement
so packets can get enqueued for the arp netisr to process.

fixes jsgs nfs mountroot problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.225 2015/09/13 10:42:32 dlg Exp $	*/
d124 1
a124 1
u_char etherbroadcastaddr[ETHER_ADDR_LEN] =
d126 2
@


1.225
log
@queue revarps to softnet so we can defer processing to a context with
the kernel lock.

"do it" claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.224 2015/09/12 13:34:12 mpi Exp $	*/
d364 1
a364 1
		return (1);
@


1.224
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.223 2015/09/10 16:41:30 mikeb Exp $	*/
d299 1
d309 1
a309 1
			if (memcmp(LLADDR(ifp->if_sadl), eh->ether_shost,
a323 4
	etype = ntohs(eh->ether_type);

	ac = (struct arpcom *)ifp;

d346 2
d363 1
a363 1
		revarpinput(m);	/* XXX queue? */
@


1.223
log
@pass a cookie argument to interface input handlers that can be used
to pass additional context or transient data with the similar life
time.

ok mpi, suggestions, hand holding and ok from dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.222 2015/09/10 13:32:19 dlg Exp $	*/
d265 1
a265 1
		(void) looutput(ifp, mcopy, dst, rt);
@


1.222
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.221 2015/07/29 00:04:03 rzalamena Exp $	*/
d287 1
a287 1
ether_input(struct ifnet *ifp, struct mbuf *m)
d509 1
a509 1
	if_ih_insert(ifp, ether_input);
d531 1
a531 1
	if_ih_remove(ifp, ether_input);
@


1.221
log
@Don't use mpls_input() as input handler anymore and instead call it
directly. Also protect non mp-safe functions while at it.

ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.220 2015/07/20 21:16:39 rzalamena Exp $	*/
a494 1
	struct ifih *ether_ifih;
d509 1
a509 3
	ether_ifih = malloc(sizeof(*ether_ifih), M_DEVBUF, M_WAITOK);
	ether_ifih->ifih_input = ether_input;
	SLIST_INSERT_HEAD(&ifp->if_inputs, ether_ifih, ifih_next);
a525 1
	struct ifih *ether_ifih;
d531 1
a531 2
	ether_ifih = SLIST_FIRST(&ifp->if_inputs);
	SLIST_REMOVE_HEAD(&ifp->if_inputs, ifih_next);
d533 1
a533 3
	KASSERT(SLIST_EMPTY(&ifp->if_inputs));

	free(ether_ifih, M_DEVBUF, sizeof(*ether_ifih));
@


1.220
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.219 2015/07/18 00:25:06 claudio Exp $	*/
d415 2
a416 6
		/* Let's call mpls_input() handler. */
		if (ifp->if_xflags & IFXF_MPLS)
			return (0);

		/* Otherwise this packet has nowhere to go. */
		goto dropanyway;
@


1.219
log
@Packets that make it to ether_input that have M_VLANTAG set must be dropped.
vlan(4) clears M_VLANTAG when a tag matches but if the tag is still there
it means that the vlan is not configured on the interface.
Found with mpi@@ and rzalamena@@ while discussing various vlan troubles.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.218 2015/07/17 21:58:07 rzalamena Exp $	*/
d415 6
a420 2
		inq = &mplsintrq;
		break;
@


1.218
log
@Fix MPLS routing when receiving packet with multiple labels.

ok claudio@@, phessler@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.217 2015/07/15 22:16:41 deraadt Exp $	*/
d329 2
d332 1
a332 1
	if (m->m_flags & M_FILDROP) {
@


1.217
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.216 2015/07/02 23:15:03 dlg Exp $	*/
d230 1
@


1.216
log
@most of the destinations for mbufs in ether_input are mpsafe except for
pipex and bridge. this puts KERNEL_LOCK/KERNEL_UNLOCK around the pipex
chunk till we can give it some mp love.

ok yasuoka@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.215 2015/07/02 15:16:57 mpi Exp $	*/
d276 1
a276 2
	if (m)
		m_freem(m);
@


1.215
log
@Move back rdomain's check into ether_output() otherwise it triggers
if a pseudo-interface is on a different rdomain than its parent.

Sorry for the inconvenience, I hope you'll fly again with us.

Regression reported by and ok semarie@@, ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.214 2015/07/02 09:40:02 mpi Exp $	*/
d395 1
d398 1
d401 1
@


1.214
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.213 2015/06/30 15:30:17 mpi Exp $	*/
d178 8
@


1.213
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.212 2015/06/30 13:54:42 mpi Exp $	*/
d279 1
a279 1
ether_input(struct mbuf *m)
a280 1
	struct ifnet *ifp;
a289 7

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	KASSERT(ifp != NULL);
	if ((ifp->if_flags & IFF_UP) == 0) {
		m_freem(m);
		return (1);
	}
@


1.212
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.211 2015/06/29 10:32:29 dlg Exp $	*/
d192 1
a192 1
			mcopy = m_copy(m, 0, (int)M_COPYALL);
@


1.211
log
@count if_ibytes in if_input like we do for if_ipackets.

tweaks and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.210 2015/06/25 09:22:36 mpi Exp $	*/
d266 1
a266 1
	return (if_output(ifp, m));
@


1.210
log
@No more NBRIDGE in the Ethernet layer.  Fewer layer violation, say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.209 2015/06/25 09:20:20 mpi Exp $	*/
a321 2

	ifp->if_ibytes += m->m_pkthdr.len + sizeof(*eh);
@


1.209
log
@Move brige(4)'s output hook outside of ether_output().

This fix some weird bridge(4) configurations involving pseudo-drivers
stacked on top of interfaces in a bridge.

Also simplifies the loop prevention logic to match bridge's input path.
Instead of using a tag per port/bridge simply flag output mbufs to make
sure only one copy per bridge go through bridge_output().

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.208 2015/06/25 09:10:15 mpi Exp $	*/
a103 5
#endif

#include "bridge.h"
#if NBRIDGE > 0
#include <net/if_bridge.h>
@


1.208
log
@Check for correct rdomain in if_output() rather than in ether_output().

Not all drivers make use of ether_output() and there's no real reason to
call it when no ARP resolution is needed.  But in this case we still want
to make sure we're sending packets in the correct rdomain.

ok bluhm@@, claudio@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.207 2015/06/23 13:20:17 mpi Exp $	*/
a269 41

#if NBRIDGE > 0
	/*
	 * Interfaces that are bridgeports need special handling for output.
	 */
	if (ifp->if_bridgeport) {
		struct m_tag *mtag;

		/*
		 * Check if this packet has already been sent out through
		 * this bridgeport, in which case we simply send it out
		 * without further bridge processing.
		 */
		for (mtag = m_tag_find(m, PACKET_TAG_BRIDGE, NULL); mtag;
		    mtag = m_tag_find(m, PACKET_TAG_BRIDGE, mtag)) {
#ifdef DEBUG
			/* Check that the information is there */
			if (mtag->m_tag_len != sizeof(caddr_t)) {
				error = EINVAL;
				goto bad;
			}
#endif
			if (!memcmp(&ifp->if_bridgeport, mtag + 1,
			    sizeof(caddr_t)))
				break;
		}
		if (mtag == NULL) {
			/* Attach a tag so we can detect loops */
			mtag = m_tag_get(PACKET_TAG_BRIDGE, sizeof(caddr_t),
			    M_NOWAIT);
			if (mtag == NULL) {
				error = ENOBUFS;
				goto bad;
			}
			memcpy(mtag + 1, &ifp->if_bridgeport, sizeof(caddr_t));
			m_tag_prepend(m, mtag);
			error = bridge_output(ifp, m, NULL, NULL);
			return (error);
		}
	}
#endif
@


1.207
log
@Pass a "struct ifnet *" instead of a "struct arpcom *" to arpresolve().

Most of the ARP layer already take an ifp pointer and this makes clear
wich chunks of code are messing with ac_enaddr.

Note that our Ethernet code assume that these pointer are interchangeable
since the first element of the "struct arpcom" is a "struct ifnet".
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.206 2015/06/23 09:42:23 mpi Exp $	*/
a182 9

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.ph_rtableid),
		    dst->sa_family);
	}
#endif
@


1.206
log
@Adapt bridge(4) to the new if_input() framework.

Move bridge_input() outside of ether_input() in order to duplicate packets
flowing through a bridge port before applying any transformation on mbufs.

This saves a various m_adj(9)/M_PREPEND(9) dances and remove the bridge(4)
hack from vlan(4).

Tested by mxb <mxb AT alumni DOT chalmers DOT se> and kettenis@@

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.205 2015/06/16 11:09:39 mpi Exp $	*/
d200 1
a200 1
		error = arpresolve(ac, rt, m, dst, edst);
d236 1
a236 1
				error = arpresolve(ac, rt, m, dst, edst);
@


1.205
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.204 2015/06/08 13:44:08 mpi Exp $	*/
a380 22

#if NBRIDGE > 0
	/*
	 * Tap the packet off here for a bridge, if configured and
	 * active for this interface.  bridge_input returns
	 * NULL if it has consumed the packet, otherwise, it
	 * gets processed as normal.
	 */
	if (ifp->if_bridgeport) {
		if (m->m_flags & M_PROTO1)
			m->m_flags &= ~M_PROTO1;
		else {
			m = bridge_input(ifp, eh, m);
			if (m == NULL)
				return (1);
			/* The bridge has determined it's for us. */
			ifp = if_get(m->m_pkthdr.ph_ifidx);
			KASSERT(ifp != NULL);
			m_adj(m, ETHER_HDR_LEN);
		}
	}
#endif
@


1.204
log
@Merge multiple copies of the code doing VLAN tag insertion back into
vlan_start().

ok sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.203 2015/06/08 13:40:48 mpi Exp $	*/
d347 2
a348 1
	ifp = m->m_pkthdr.rcvif;
d397 2
a398 1
			ifp = m->m_pkthdr.rcvif;
@


1.203
log
@Move carp-related logic from ether_output() into carp_start().

ok sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.202 2015/06/02 09:38:24 mpi Exp $	*/
a110 5
#include "vlan.h"
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif /* NVLAN > 0 */

a132 3
static inline int	ether_addheader(struct mbuf **, struct ifnet *,
			   u_int16_t, u_char *, u_char *);

a166 60
static inline int
ether_addheader(struct mbuf **m, struct ifnet *ifp, u_int16_t etype,
    u_char *esrc, u_char *edst)
{
	struct ether_header *eh;

#if NVLAN > 0
	if ((*m)->m_flags & M_VLANTAG) {
		struct ifvlan	*ifv = ifp->if_softc;
		struct ifnet	*p = ifv->ifv_p;
		u_int8_t	prio = (*m)->m_pkthdr.pf.prio;

		/* IEEE 802.1p has prio 0 and 1 swapped */
		if (prio <= 1)
			prio = !prio;

#if NBRIDGE > 0
		/*
		 * The bridge might send on non-vlan interfaces -- which
		 * do not need this header -- or add the vlan-header itself
		 * in bridge_ifenqueue -- which would add a second header.
		 */
		if (ifp->if_bridgeport)
			(*m)->m_flags &= ~M_VLANTAG;
		else
#endif
		/* should we use the tx tagging hw offload at all? */
		if ((p->if_capabilities & IFCAP_VLAN_HWTAGGING) &&
		    (ifv->ifv_type == ETHERTYPE_VLAN)) {
			(*m)->m_pkthdr.ether_vtag = ifv->ifv_tag +
			    (prio << EVL_PRIO_BITS);
			/* don't return, need to add regular ethernet header */
		} else {
			struct ether_vlan_header	*evh;

			M_PREPEND(*m, sizeof(*evh), M_DONTWAIT);
			if (*m == NULL)
				return (-1);
			evh = mtod(*m, struct ether_vlan_header *);
			memcpy(evh->evl_dhost, edst, sizeof(evh->evl_dhost));
			memcpy(evh->evl_shost, esrc, sizeof(evh->evl_shost));
			evh->evl_proto = etype;
			evh->evl_encap_proto = htons(ifv->ifv_type);
			evh->evl_tag = htons(ifv->ifv_tag +
			    (prio << EVL_PRIO_BITS));
			(*m)->m_flags &= ~M_VLANTAG;
			return (0);
		}
	}
#endif /* NVLAN > 0 */
	M_PREPEND(*m, ETHER_HDR_LEN, M_DONTWAIT);
	if (*m == NULL)
		return (-1);
	eh = mtod(*m, struct ether_header *);
	eh->ether_type = etype;
	memcpy(eh->ether_dhost, edst, sizeof(eh->ether_dhost));
	memcpy(eh->ether_shost, esrc, sizeof(eh->ether_shost));
	return (0);
}

d173 1
a173 1
ether_output(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst,
a178 1
	struct mbuf *m = m0;
d272 7
a278 2
	if (ether_addheader(&m, ifp, etype, esrc, edst) == -1)
		senderr(ENOBUFS);
@


1.202
log
@Take carp(4) out of ether_input().

Tested by <mxb AT alumni DOT chalmers DOT se>, thanks!

ok bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.201 2015/05/26 11:39:07 mpi Exp $	*/
a115 5
#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

d241 1
a241 1
ether_output(struct ifnet *ifp0, struct mbuf *m0, struct sockaddr *dst,
a244 1
	int len, error = 0;
d250 2
a251 2
	struct arpcom *ac = (struct arpcom *)ifp0;
	struct ifnet *ifp = ifp0;
a263 14
#if NCARP > 0
	if (ifp->if_type == IFT_CARP) {
		ifp = ifp->if_carpdev;
		ac = (struct arpcom *)ifp;

		if ((ifp0->if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			senderr(ENETDOWN);
	}

	if (ifp0 != ifp && ifp0->if_type == IFT_CARP)
		esrc = carp_get_srclladdr(ifp0, esrc);
#endif /* NCARP > 0 */

d385 1
a385 8
	len = m->m_pkthdr.len;

	error = if_output(ifp, m);
#if NCARP > 0
	if (!error && ifp != ifp0)
		ifp0->if_obytes += len;
#endif /* NCARP > 0 */
	return (error);
@


1.201
log
@Now that the Ethernet header is always passed as part of the mbuf, kill
the second (unused) argument of the input packet handlers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.200 2015/05/26 11:36:26 dlg Exp $	*/
a491 12

#if NCARP > 0
	if (ifp->if_carp) {
		if (ifp->if_type != IFT_CARP && (carp_input(ifp, eh, m) == 0))
			return (1);
		/* clear mcast if received on a carp IP balanced address */
		else if (ifp->if_type == IFT_CARP &&
		    m->m_flags & (M_BCAST|M_MCAST) &&
		    carp_our_mcastaddr(ifp, (u_int8_t *)&eh->ether_dhost))
			m->m_flags &= ~(M_BCAST|M_MCAST);
	}
#endif /* NCARP > 0 */
@


1.200
log
@move add_net_randomness from ether_input to the if_input task.

change it from feeding the ethertype of the packet (which is almost
certainly an ip packet or vlan packet, so not that variable) to the
number of packets about to be processed.

ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.199 2015/05/19 11:09:24 mpi Exp $	*/
d425 1
a425 1
ether_input(struct mbuf *m, void *hdr)
d428 1
a428 1
	struct ether_header *eh = hdr;
a437 2

	/* mark incoming routing table */
a438 7
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

	if (eh == NULL) {
		eh = mtod(m, struct ether_header *);
		m_adj(m, ETHER_HDR_LEN);
	}

d443 4
@


1.199
log
@Take vlan(4) out of ether_input().

To keep the list of input handlers short, multiple vlans share the
same ifih.

if_input_process() now looks if the interface of a mbuf changed to
make sure the corresponding handlers are executed.  This is a hack
and will be improved later.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.198 2015/05/15 10:15:13 mpi Exp $	*/
a101 2
#include <dev/rndvar.h>

a475 5

	if (!(netisr & (1 << NETISR_RND_DONE))) {
		add_net_randomness(etype);
		atomic_setbits_int(&netisr, (1 << NETISR_RND_DONE));
	}
@


1.198
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.197 2015/05/13 08:16:01 mpi Exp $	*/
d429 1
a429 1
	struct ifnet *ifp0, *ifp;
d442 1
a442 1
	ifp = ifp0 = m->m_pkthdr.rcvif;
a483 6
#if NVLAN > 0
	if (((m->m_flags & M_VLANTAG) || etype == ETHERTYPE_VLAN ||
	    etype == ETHERTYPE_QINQ) && (vlan_input(eh, m) == 0))
		return (1);
#endif

d532 1
a532 1
	    ((ifp->if_flags & IFF_PROMISC) || (ifp0->if_flags & IFF_PROMISC))) {
@


1.197
log
@Get rid of the last "#if NTRUNK" by overwriting trunk ports' output
function.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.196 2015/05/11 08:41:43 mpi Exp $	*/
d252 1
a252 1
	int s, len, error = 0;
a258 1
	short mflags;
d406 1
a406 1
	mflags = m->m_flags;
d408 2
a409 12
	s = splnet();
	/*
	 * Queue message on interface, and start output if interface
	 * not yet active.
	 */
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		/* mbuf is already freed */
		splx(s);
		return (error);
	}
	ifp->if_obytes += len;
d411 1
a411 1
	if (ifp != ifp0)
a413 4
	if (mflags & M_MCAST)
		ifp->if_omcasts++;
	if_start(ifp);
	splx(s);
a414 1

@


1.196
log
@Take trunk(4) out of ether_input().

Each physical interface of a trunk now gets a specific ifih (interface
input handler) that runs before ether_input().

Tested by sthen@@, dlg@@, Theo Buehler and <mxb AT alumni.chalmers DOT se>

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.195 2015/05/04 10:24:08 mpi Exp $	*/
a89 2
#include <crypto/siphash.h>	/* required by if_trunk.h */

a127 5
#include "trunk.h"
#if NTRUNK > 0
#include <net/if_trunk.h>
#endif

a268 7
#endif

#if NTRUNK > 0
	/* restrict transmission on trunk members to bpf only */
	if (ifp->if_type == IFT_IEEE8023ADLAG &&
	    (m_tag_find(m, PACKET_TAG_DLT, NULL) == NULL))
		senderr(EBUSY);
@


1.195
log
@Use ether_input() as default input packet handler and do the necessary
m_adj(9) to keep bridge(4) working while other pseudo-drivers are
converted to if_input().

Tested by mxb <mxb AT alumni DOT chalmers DOT se>, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.194 2015/04/13 08:52:51 mpi Exp $	*/
a465 3
#if NTRUNK > 0
	int i = 0;
#endif
a479 15
#if NTRUNK > 0
	/* Handle input from a trunk port */
	while (ifp->if_type == IFT_IEEE8023ADLAG) {
		if (++i > TRUNK_MAX_STACKING) {
			m_freem(m);
			return (1);
		}
		if (trunk_input(ifp, eh, m) != 0)
			return (1);

		/* Has been set to the trunk interface */
		ifp = m->m_pkthdr.rcvif;
	}
#endif

a502 4
#if NTRUNK > 0
		if (ifp != ifp0)
			ifp0->if_imcasts++;
#endif
a505 4
#if NTRUNK > 0
	if (ifp != ifp0)
		ifp0->if_ibytes += m->m_pkthdr.len + sizeof(*eh);
#endif
@


1.194
log
@Move one "#ifdef NVLAN" chunk needed only if you're running bridge(4) on
to of vlan(4) from ether_input() to bridge_input().

One of the goal of the if_input() plumbing is to stop doing all possible
pseudo-drivers checks on every packets.  There's no reason that even if
you're not running a bridge(4) you've to run this code.

This change also will also makes it easier to convert vlan(4) to if_input().

Reviewed by Rafael Zalamena and mikeb@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.193 2015/04/10 13:58:20 dlg Exp $	*/
d562 1
@


1.193
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.192 2015/04/10 08:48:24 mpi Exp $	*/
a564 10

#if NVLAN > 0
	if ((m->m_flags & M_VLANTAG) || etype == ETHERTYPE_VLAN ||
	    etype == ETHERTYPE_QINQ) {
		/* The bridge did not want the vlan frame either, drop it. */
		ifp->if_noproto++;
		m_freem(m);
		return (1);
	}
#endif /* NVLAN > 0 */
@


1.192
log
@Run detach hook and similar before cleaning up any other resource when
an interface is destroyed/removed.  This way we can ensure pseudo-driver
changes done after attaching an interface are undone before detaching it.

Note: it is safe to call if_deactivate() multiple times as the interface
should not have any attached pseudo-interface after the first call.

ok deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.191 2015/04/07 10:46:20 mpi Exp $	*/
d461 1
a461 1
	struct ifqueue *inq;
d463 1
a463 1
	int s, llcfound = 0;
a609 4
	/*
	 * Schedule softnet interrupt and enqueue packet within the same spl.
	 */
	s = splnet();
a610 1

a612 1
		schednetisr(NETISR_IP);
a618 1
		schednetisr(NETISR_ARP);
d626 1
a626 1
		goto done;
a632 1
		schednetisr(NETISR_IPV6);
d640 2
a641 4
		if (m->m_flags & (M_MCAST | M_BCAST)) {
			m_freem(m);
			goto done;
		}
d645 1
a645 1
			goto done;
d660 1
a660 1
				goto done;
a667 2

		schednetisr(NETISR_PPPOE);
a673 1
		schednetisr(NETISR_MPLS);
d692 1
a692 1
					goto done;
d696 1
a697 4
		dropanyway:
		default:
			m_freem(m);
			goto done;
d701 4
a704 3
	IF_INPUT_ENQUEUE(inq, m);
done:
	splx(s);
@


1.191
log
@Do not pass an `ifp' argument to interface input handlers since it
might be overwritten by pseudo-drivers.

ok dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.190 2015/03/17 14:51:27 mpi Exp $	*/
d804 3
@


1.190
log
@Merge two "#ifdef NCARP" chunks.

"Look safe" henning@@, ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.189 2015/02/16 18:24:02 markus Exp $	*/
d457 1
a457 1
ether_input(struct ifnet *ifp0, void *hdr, struct mbuf *m)
d459 1
a465 1
	struct ifnet *ifp = ifp0;
d473 1
d475 1
@


1.189
log
@avoid double vlan-header or vlan-header for non-vlan(4) interfaces
(will panic) in bridge context; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.188 2015/02/09 00:21:58 dlg Exp $	*/
d296 3
a376 5

#if NCARP > 0
	if (ifp0 != ifp && ifp0->if_type == IFT_CARP)
		esrc = carp_get_srclladdr(ifp0, esrc);
#endif
@


1.188
log
@move the init of the if_input from ether_ifattach to if_attach.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.187 2015/02/08 06:00:52 mpi Exp $	*/
d205 10
@


1.187
log
@Introduce if_input() a function to pass packets dequeued from a
recieving ring to the stack.

if_input() is at the moment a drop-in replacement for ether_input_mbuf()
but will let us stack pseudo-driver in a nice way in order to no longer
call ether_input() recursively.

ok pelikan@@, reyk@@, blambert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.186 2015/02/06 16:00:30 benno Exp $	*/
a771 1
	SLIST_INIT(&ifp->if_inputs);
@


1.186
log
@earlier rev 1.112 sys/net/if_vlan.c corrects the mapping of 802.1p
prio from the vlan header to our pf priority levels. This fixes the
mapping on the ouput path.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.185 2015/01/08 14:29:18 mpi Exp $	*/
d448 2
a449 2
void
ether_input(struct ifnet *ifp0, struct ether_header *eh, struct mbuf *m)
d451 1
d478 1
a478 1
			return;
d481 1
a481 1
			return;
d490 1
a490 1
		return;
d501 1
a501 1
				return;
d533 1
a533 1
		return;
d549 1
a549 1
				return;
d562 1
a562 1
		return;
d569 1
a569 1
			return;
d585 1
a585 1
		return;
d596 1
a596 1
			return;
d710 1
d757 3
d772 5
d782 2
a783 3
	memcpy(LLADDR(ifp->if_sadl), ((struct arpcom *)ifp)->ac_enaddr,
	    ifp->if_addrlen);
	LIST_INIT(&((struct arpcom *)ifp)->ac_multiaddrs);
d793 1
d795 7
@


1.185
log
@Factorize various duplicated chunks of (old and horrible) code, checking
for the validity of a given outgoing route entry into a single function.

This change is inspired from FreeBSD r111767.  The function introduced
here, rt_checkgate(), should hopefully die in a near future.  Why should
it die?  Well, it is way too late to do such validity checks: if your
kernel can ends up in ether_output() with an invalid route, please do
not let it try to find a new one that might do the job.

Go read this function if you're wondering why you're getting messages
like:

"arpresolve: X.X.X.X: route without link local address"

Since this horrible logic has survived 20 years of copy & past and small
modifications for workarounds without a single clear commit message, let's
assume it is full of dragons and try to play safe.  This factorization is
not intended to change any behavior.

With much inputs from bluhm@@, tested by weerd@@ and florian@@ on setups
with p2p IPv6 interfaces.

ok bluhm@@, benno@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.184 2014/12/19 17:14:39 tedu Exp $	*/
d199 5
d209 1
a209 1
			    ((*m)->m_pkthdr.pf.prio << EVL_PRIO_BITS);
d223 1
a223 1
			    ((*m)->m_pkthdr.pf.prio << EVL_PRIO_BITS));
@


1.184
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.183 2014/12/08 10:46:14 mpi Exp $	*/
d241 1
a241 1
    struct rtentry *rt0)
a247 1
	struct rtentry *rt;
a284 8
	if ((rt = rt0) != NULL) {
		if ((rt->rt_flags & RTF_UP) == 0) {
			if ((rt0 = rt = rtalloc(dst, RT_REPORT|RT_RESOLVE,
			    m->m_pkthdr.ph_rtableid)) != NULL)
				rt->rt_refcnt--;
			else
				senderr(EHOSTUNREACH);
		}
a285 18
		if (rt->rt_flags & RTF_GATEWAY) {
			if (rt->rt_gwroute == NULL)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt);
				rt = rt0;
			lookup:
				rt->rt_gwroute = rtalloc(rt->rt_gateway,
				    RT_REPORT|RT_RESOLVE, ifp->if_rdomain);
				if ((rt = rt->rt_gwroute) == NULL)
					senderr(EHOSTUNREACH);
			}
		}
		if (rt->rt_flags & RTF_REJECT)
			if (rt->rt_rmx.rmx_expire == 0 ||
			    time_second < rt->rt_rmx.rmx_expire)
				senderr(rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
	}
a286 1

d288 3
a290 2
		if (!arpresolve(ac, rt, m, dst, edst))
			return (0);	/* if not yet resolved */
d299 3
a301 2
		if (!nd6_storelladdr(ifp, rt, m, dst, (u_char *)edst))
			return (0); /* it must be impossible, but... */
d324 3
a326 2
				if (!arpresolve(ac, rt, m, dst, edst))
					return (0); /* if not yet resolved */
@


1.183
log
@There's no good reason to keep into "struct ifnet" a pointer that's only
used by enc(4) devices to attach their routes.

ok sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.182 2014/12/04 00:01:53 tedu Exp $	*/
a314 1
#ifdef INET
a323 1
#endif
a625 1
#ifdef INET
a643 1
#endif
a916 1
#ifdef INET
a920 1
#endif
a936 1
#ifdef INET
a937 1
#endif /* INET */
a948 1
#ifdef INET
a964 1
#endif
@


1.182
log
@use siphash for trunk loadbalancing. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.181 2014/12/01 17:46:56 tedu Exp $	*/
a815 5

#if 0
	/* moved to if_detach() */
	if_free_sadl(ifp);
#endif
@


1.181
log
@reconvert (rereconvert?) to memcpy except in the one case where memmove
is needed. more thoroughly reviewed. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.180 2014/11/29 18:50:06 tedu Exp $	*/
d90 1
@


1.180
log
@restore the "hot" memcpy that existed before recent conversion flipflop
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.179 2014/11/20 14:51:42 krw Exp $	*/
d347 1
a347 1
				memmove(edst, LLADDR((struct sockaddr_dl *)dst),
d371 1
a371 1
		memmove(edst, eh->ether_dhost, sizeof(edst));
d427 1
a427 1
			memmove(mtag + 1, &ifp->if_bridgeport, sizeof(caddr_t));
d670 5
d795 1
a795 1
	memmove(LLADDR(ifp->if_sadl), ((struct arpcom *)ifp)->ac_enaddr,
d957 2
a958 2
		memmove(addrlo, sa->sa_data, ETHER_ADDR_LEN);
		memmove(addrhi, addrlo, ETHER_ADDR_LEN);
d971 2
a972 2
			memmove(addrlo, ether_ipmulticast_min, ETHER_ADDR_LEN);
			memmove(addrhi, ether_ipmulticast_max, ETHER_ADDR_LEN);
d975 1
a975 1
			memmove(addrhi, addrlo, ETHER_ADDR_LEN);
d995 2
a996 2
			memmove(addrlo, ether_ip6multicast_min, ETHER_ADDR_LEN);
			memmove(addrhi, ether_ip6multicast_max, ETHER_ADDR_LEN);
d999 1
a999 1
			memmove(addrhi, addrlo, ETHER_ADDR_LEN);
d1056 2
a1057 2
	memmove(enm->enm_addrlo, addrlo, ETHER_ADDR_LEN);
	memmove(enm->enm_addrhi, addrhi, ETHER_ADDR_LEN);
@


1.179
log
@Yet more #include de-duplication.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.178 2014/11/19 19:47:52 tedu Exp $	*/
d212 2
a213 2
			memmove(evh->evl_dhost, edst, sizeof(evh->evl_dhost));
			memmove(evh->evl_shost, esrc, sizeof(evh->evl_shost));
d228 2
a229 2
	memmove(eh->ether_dhost, edst, sizeof(eh->ether_dhost));
	memmove(eh->ether_shost, esrc, sizeof(eh->ether_shost));
@


1.178
log
@bulk convert memcpy to memmove. at least one bcopy conversion was wrong,
so use the safer function. can be converted back to memcpy if necessary,
but later and only after more careful inspection.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.177 2014/11/06 14:28:47 henning Exp $	*/
a134 3
#ifndef INET
#include <netinet/in.h>
#endif
@


1.177
log
@fix mac address selection with unnumbered carpdevs
IP-traffic over a carp interface with the underlaying carpdev being unnumbered
(in the numbered case usually the ifp is the carpdev to begin with) went out
with the carpdev's mac address istead of the carp interface's one due to a
carp hack in ether_output exchanging the carp ifp for its carpdev ones one.
move the source mac selection to before that.
fixes unnumbered carp use in environments with strict mac address regimes
like some exchange points. issue found by your's truly the hard way.
ok mpi dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.176 2014/11/01 21:40:38 mpi Exp $	*/
d215 2
a216 2
			memcpy(evh->evl_dhost, edst, sizeof(evh->evl_dhost));
			memcpy(evh->evl_shost, esrc, sizeof(evh->evl_shost));
d231 2
a232 2
	memcpy(eh->ether_dhost, edst, sizeof(eh->ether_dhost));
	memcpy(eh->ether_shost, esrc, sizeof(eh->ether_shost));
d350 1
a350 1
				memcpy(edst, LLADDR((struct sockaddr_dl *)dst),
d374 1
a374 1
		memcpy(edst, eh->ether_dhost, sizeof(edst));
d430 1
a430 1
			memcpy(mtag + 1, &ifp->if_bridgeport, sizeof(caddr_t));
d673 1
a673 1
		memcpy(eh_tmp, eh, sizeof(struct ether_header));
d793 1
a793 1
	memcpy(LLADDR(ifp->if_sadl), ((struct arpcom *)ifp)->ac_enaddr,
d955 2
a956 2
		memcpy(addrlo, sa->sa_data, ETHER_ADDR_LEN);
		memcpy(addrhi, addrlo, ETHER_ADDR_LEN);
d969 2
a970 2
			memcpy(addrlo, ether_ipmulticast_min, ETHER_ADDR_LEN);
			memcpy(addrhi, ether_ipmulticast_max, ETHER_ADDR_LEN);
d973 1
a973 1
			memcpy(addrhi, addrlo, ETHER_ADDR_LEN);
d993 2
a994 2
			memcpy(addrlo, ether_ip6multicast_min, ETHER_ADDR_LEN);
			memcpy(addrhi, ether_ip6multicast_max, ETHER_ADDR_LEN);
d997 1
a997 1
			memcpy(addrhi, addrlo, ETHER_ADDR_LEN);
d1054 2
a1055 2
	memcpy(enm->enm_addrlo, addrlo, ETHER_ADDR_LEN);
	memcpy(enm->enm_addrhi, addrhi, ETHER_ADDR_LEN);
@


1.176
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.175 2014/10/07 20:23:32 tedu Exp $	*/
d273 2
a314 1
	esrc = ac->ac_enaddr;
@


1.175
log
@remove preliminary AOE (ata over ethernet) support. not finished after
many years and wide spread demand for support never materialized.
time to pack it in.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.174 2014/07/12 18:44:22 tedu Exp $	*/
d288 1
a288 1
			if ((rt0 = rt = rtalloc1(dst, RT_REPORT,
d302 2
a303 2
				rt->rt_gwroute = rtalloc1(rt->rt_gateway,
				    RT_REPORT, ifp->if_rdomain);
@


1.174
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.173 2014/07/08 07:10:12 dlg Exp $	*/
a133 4
#ifdef AOE
#include <net/if_aoe.h>
#endif /* AOE */

a690 5
#ifdef AOE
	case ETHERTYPE_AOE:
		aoe_input(ifp, m);
		goto done;
#endif /* AOE */
@


1.174.4.1
log
@backport the correct fix for overlapping memcpy which caused corrupt MACs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.174 2014/07/12 18:44:22 tedu Exp $	*/
d676 1
a676 6
		/*
		 * danger!
		 * eh_tmp and eh may overlap because eh
		 * is stolen from the mbuf above.
		 */
		memmove(eh_tmp, eh, sizeof(struct ether_header));
@


1.173
log
@pull the rx ring accounting out of the mbuf layer now that its all done
via if_rxring things. this effectively deprecates the third argument
for MCLGETI and m_clget and makes the mbuf layer no longer care about
interfaces and simplifies the allocation paths.

the timeout used to measure livelock has been moved to net/if.c.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.172 2014/04/22 12:07:20 henning Exp $	*/
d819 1
a819 1
		free(enm, M_IFMADDR);
d1114 1
a1114 1
	free(enm, M_IFMADDR);
@


1.172
log
@NULL is cooler than 0 when pointers are concerned
ok gcc & md5 (aka no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.171 2014/04/22 11:43:07 henning Exp $	*/
a489 2

	m_cluncount(m, 1);
@


1.171
log
@we used to handle the vlan tag etc insertion very very very late,
on al already ass embed ethernet frame, which meant:
-copy (most of) the existing ethernet header into a ether_vlan_header
on the stack
-fill the extra fields in ether_vlan_header
-set the ether type
-m_adj() to make room for the extra space ether_vlan_header needs
-m_copyback the ether_vlan_header into the mbuf
that involves moving data around, which isn't all that cheap.
cleaner & easier to have ether_output prepend the ether_vlan_header instead
of the regular ethernet header, which makes the vlan tagging essentially
free in most cases.
help & ok reyk, naddy; waste of time bikeshedding tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.170 2014/04/21 18:52:25 henning Exp $	*/
d216 1
a216 1
			if (*m == 0)
d231 1
a231 1
	if (*m == 0)
d255 1
a255 1
	struct mbuf *mcopy = (struct mbuf *)0;
d300 1
a300 1
			if (rt->rt_gwroute == 0)
d724 1
a724 1
				if (m == 0)
@


1.170
log
@g/c hdrcmplt var, we can just set the esrc ptr earlier and re-set it in
the pseudo_AF_HDRCMPLT case, ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.169 2014/04/21 18:38:36 henning Exp $	*/
d158 2
a159 2
static inline int    ether_addheader(struct mbuf **, u_int16_t, u_char *,
			   u_char *);
d196 2
a197 1
ether_addheader(struct mbuf **m, u_int16_t etype, u_char *esrc, u_char *edst)
d201 29
d397 1
a397 1
	if (ether_addheader(&m, etype, esrc, edst) == -1)
@


1.169
log
@__inline -> inline
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.167 2014/04/20 14:54:39 henning Exp $	*/
d220 1
a220 1
	int s, len, error = 0, hdrcmplt = 0;
d287 1
a340 1
		hdrcmplt = 1;
a361 2
	if (!hdrcmplt)
		esrc = ac->ac_enaddr;
@


1.168
log
@factor our ether_addheader for readability; there's more to come there
ok claudio reyk
@
text
@d158 1
a158 1
static __inline int    ether_addheader(struct mbuf **, u_int16_t, u_char *,
d195 1
a195 1
static __inline int
@


1.167
log
@ether_output: instead of assembling the ethernet header and then calling
carp_rewrite_lladdr to overwrite the src lladdr, get the intended src
lladdr before assembling the ethernet header.
carp_rewrite_lladdr -> carp_get_srclladdr
ok reyk claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.166 2014/04/20 14:51:50 henning Exp $	*/
d158 3
d195 15
d369 1
a369 6
	/*
	 * Add local net header.  If no space in first mbuf,
	 * allocate another.
	 */
	M_PREPEND(m, ETHER_HDR_LEN, M_DONTWAIT);
	if (m == 0)
a370 4
	eh = mtod(m, struct ether_header *);
	eh->ether_type = etype;
	memcpy(eh->ether_dhost, edst, sizeof(eh->ether_dhost));
	memcpy(eh->ether_shost, esrc, sizeof(eh->ether_shost));
@


1.166
log
@ether_output: instead of using an esrc buffer in which we copy the intended
src lladdr just to copy it from the esrc buffer into the ethernet header
a few lines later, use an esrc pointer to figure out where to copy the
src lladdr from. ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.164 2014/03/26 15:13:59 mpi Exp $	*/
d346 4
a361 5

#if NCARP > 0
	if (ifp0 != ifp && ifp0->if_type == IFT_CARP)
	    carp_rewrite_lladdr(ifp0, eh->ether_shost);
#endif
@


1.165
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@a157 1

d203 2
a204 1
	u_char edst[ETHER_ADDR_LEN], esrc[ETHER_ADDR_LEN];
d324 1
a324 1
		memcpy(esrc, eh->ether_shost, sizeof(esrc));
d344 3
d356 2
a357 5
	memcpy(eh->ether_dhost, edst, sizeof(edst));
	if (hdrcmplt)
		memcpy(eh->ether_shost, esrc, sizeof(eh->ether_shost));
	else
		memcpy(eh->ether_shost, ac->ac_enaddr, sizeof(eh->ether_shost));
@


1.164
log
@bcmp -> memcmp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.163 2014/03/26 10:46:53 mpi Exp $	*/
d214 1
a214 1
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
d217 1
a217 1
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain),
d245 1
a245 1
			    m->m_pkthdr.rdomain)) != NULL)
d457 2
a458 2
	/* mark incoming routing domain */
	m->m_pkthdr.rdomain = ifp->if_rdomain;
@


1.163
log
@No need to check here if the destination address is ours, because in
such case loouput() is called not ether_output().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.162 2014/02/17 14:48:48 mpi Exp $	*/
d385 2
a386 1
			if (!bcmp(&ifp->if_bridgeport, mtag + 1, sizeof(caddr_t)))
d497 1
a497 1
		if (bcmp((caddr_t)etherbroadcastaddr, (caddr_t)eh->ether_dhost,
d586 1
a586 2
		if (bcmp(ac->ac_enaddr, (caddr_t)eh->ether_dhost,
		    ETHER_ADDR_LEN)) {
d1034 1
a1034 1
	if (bcmp(addrlo, addrhi, ETHER_ADDR_LEN) != 0)
d1082 1
a1082 1
	if (bcmp(addrlo, addrhi, ETHER_ADDR_LEN) != 0)
@


1.162
log
@Convert bcopy()s to memcpy()s.

ok pelikan@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.161 2014/01/22 09:35:20 mpi Exp $	*/
a230 8
		struct ifaddr *ifa;

		/* loop back if this is going to the carp interface */
		if (dst != NULL && LINK_STATE_IS_UP(ifp0->if_link_state) &&
		    (ifa = ifa_ifwithaddr(dst, ifp->if_rdomain)) != NULL &&
		    ifa->ifa_ifp == ifp0)
			return (looutput(ifp0, m, dst, rt0));

@


1.162.4.1
log
@backport the correct fix for overlapping memcpy which caused corrupt MACs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.162 2014/02/17 14:48:48 mpi Exp $	*/
d650 1
a650 6
		/*
		 * danger!
		 * eh_tmp and eh may overlap because eh
		 * is stolen from the mbuf above.
		 */
		memmove(eh_tmp, eh, sizeof(struct ether_header));
@


1.161
log
@Pass the receiving interface pointer to carp_input() instead of re-
reading it from the packet header.  While here makes carp_input()
take the same arguments as ether_input().

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.160 2014/01/16 10:26:21 mpi Exp $	*/
d312 1
a312 1
				bcopy(LLADDR(((struct sockaddr_dl *)dst)), edst,
d332 1
a332 1
		bcopy((caddr_t)eh->ether_shost, (caddr_t)esrc, sizeof(esrc));
d337 1
a337 1
		bcopy((caddr_t)eh->ether_dhost, (caddr_t)edst, sizeof(edst));
d363 1
a363 2
		memcpy(eh->ether_shost, esrc,
		    sizeof(eh->ether_shost));
d365 1
a365 2
		memcpy(eh->ether_shost, ac->ac_enaddr, 
		    sizeof(eh->ether_shost));
d404 1
a404 1
			bcopy(&ifp->if_bridgeport, mtag + 1, sizeof(caddr_t));
d650 1
a650 1
		bcopy(eh, eh_tmp, sizeof(struct ether_header));
d775 2
a776 2
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	    LLADDR(ifp->if_sadl), ifp->if_addrlen);
d937 2
a938 2
		bcopy(sa->sa_data, addrlo, ETHER_ADDR_LEN);
		bcopy(addrlo, addrhi, ETHER_ADDR_LEN);
d951 2
a952 2
			bcopy(ether_ipmulticast_min, addrlo, ETHER_ADDR_LEN);
			bcopy(ether_ipmulticast_max, addrhi, ETHER_ADDR_LEN);
d955 1
a955 1
			bcopy(addrlo, addrhi, ETHER_ADDR_LEN);
d975 2
a976 2
			bcopy(ether_ip6multicast_min, addrlo, ETHER_ADDR_LEN);
			bcopy(ether_ip6multicast_max, addrhi, ETHER_ADDR_LEN);
d979 1
a979 1
			bcopy(addrlo, addrhi, ETHER_ADDR_LEN);
d1036 2
a1037 2
	bcopy(addrlo, enm->enm_addrlo, ETHER_ADDR_LEN);
	bcopy(addrhi, enm->enm_addrhi, ETHER_ADDR_LEN);
@


1.160
log
@Replaces a lookup to find the link-layer address by accessing the if_sadl
member directly.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.159 2013/11/18 20:22:23 deraadt Exp $	*/
d569 1
a569 3
		if (ifp->if_type != IFT_CARP &&
		    (carp_input(m, (u_int8_t *)&eh->ether_shost,
		    (u_int8_t *)&eh->ether_dhost, eh->ether_type) == 0))
@


1.159
log
@use arc4random() for ether_fakeaddr, because it is safe
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.158 2013/10/23 15:12:42 mpi Exp $	*/
d494 4
d499 1
a499 14
			struct ifaddr *ifa;
			struct sockaddr_dl *sdl = NULL;

			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
				if ((sdl =
				    (struct sockaddr_dl *)ifa->ifa_addr) &&
				    sdl->sdl_family == AF_LINK)
					break;
			}
			/*
			 * If this is not a simplex interface, drop the packet
			 * if it came from us.
			 */
			if (sdl && bcmp(LLADDR(sdl), eh->ether_shost,
@


1.158
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.157 2013/06/05 10:42:58 dlg Exp $	*/
d754 1
a754 1
	int rng;
a760 1
	rng = cold ? random() ^ (long)ifp : arc4random();
@


1.157
log
@ansi function declarations.

ok sha256
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.156 2013/06/03 12:32:06 kettenis Exp $	*/
a99 3
#ifdef INET
#include <netinet/in_var.h>
#endif
@


1.156
log
@Replace "hot" bcopy() calls in ether_output() with memcpy().  This tells the
compiler that source and destination are not overlapping, allowing for more
aggressive optimization, leading to a significant performance improvement
on busy firewalls.  Reworking of a diff by dlg@@, who did the hard work of
benchmarking this.

ok deraadt@@, mikeb@@, henning@@, mcbride@@, tedu@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.155 2013/03/28 16:55:27 deraadt Exp $	*/
d202 2
a203 5
ether_output(ifp0, m0, dst, rt0)
	struct ifnet *ifp0;
	struct mbuf *m0;
	struct sockaddr *dst;
	struct rtentry *rt0;
d452 1
a452 4
ether_input(ifp0, eh, m)
	struct ifnet *ifp0;
	struct ether_header *eh;
	struct mbuf *m;
d735 1
a735 2
ether_sprintf(ap)
	u_char *ap;
d773 1
a773 2
ether_ifattach(ifp)
	struct ifnet *ifp;
d801 1
a801 2
ether_ifdetach(ifp)
	struct ifnet *ifp;
d1012 1
a1012 3
ether_addmulti(ifr, ac)
	struct ifreq *ifr;
	struct arpcom *ac;
d1073 1
a1073 3
ether_delmulti(ifr, ac)
	struct ifreq *ifr;
	struct arpcom *ac;
@


1.155
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.154 2013/03/15 20:45:34 tedu Exp $	*/
d366 2
a367 3
	bcopy((caddr_t)&etype,(caddr_t)&eh->ether_type,
		sizeof(eh->ether_type));
	bcopy((caddr_t)edst, (caddr_t)eh->ether_dhost, sizeof(edst));
d369 1
a369 1
		bcopy((caddr_t)esrc, (caddr_t)eh->ether_shost,
d372 1
a372 1
		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
@


1.154
log
@change LIST_END to literal NULL for clarity.
ok claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.153 2013/01/18 12:10:11 sthen Exp $	*/
a89 1
#include <machine/cpu.h>
@


1.153
log
@Relax the restriction on sending frames to trunk(4) members to allow BPF writes.
Method (checking for PACKET_TAG_DLT) suggested by claudio, ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.152 2012/10/05 17:17:04 camield Exp $	*/
d818 1
a818 1
	    enm != LIST_END(&ac->ac_multiaddrs);
@


1.152
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.151 2011/07/09 00:47:18 henning Exp $	*/
d230 3
a232 1
	if (ifp->if_type == IFT_IEEE8023ADLAG)
@


1.151
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.150 2011/07/08 18:30:16 yasuoka Exp $	*/
d382 1
a382 2
	 * Interfaces that are bridge members need special handling
	 * for output.
d384 1
a384 1
	if (ifp->if_bridge) {
d389 1
a389 1
		 * this bridge, in which case we simply send it out
d401 1
a401 1
			if (!bcmp(&ifp->if_bridge, mtag + 1, sizeof(caddr_t)))
d412 1
a412 1
			bcopy(&ifp->if_bridge, mtag + 1, sizeof(caddr_t));
d562 1
a562 1
	if (ifp->if_bridge) {
@


1.150
log
@Include PIPEX in kernel by default.  And add new sysctl variable
`net.pipex.enable' to enable PIPEX.   By default, pipex is disabled
and it will not process packets from wire.  Update man pages and
update HOWTO_PIPEX_NPPPD.txt for testers.

discussed with dlg@@, ok deraadt@@ mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.149 2011/07/04 23:58:26 claudio Exp $	*/
a153 9
#ifdef NETATALK
#include <netatalk/at.h>
#include <netatalk/at_var.h>
#include <netatalk/at_extern.h>

extern u_char	at_org_code[ 3 ];
extern u_char	aarp_org_code[ 3 ];
#endif /* NETATALK */

a165 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a170 7
		switch (ifa->ifa_addr->sa_family) {
#ifdef NETATALK
		case AF_APPLETALK:
			/* Nothing to do. */
			break;
#endif /* NETATALK */
		}
a301 50
#ifdef NETATALK
	case AF_APPLETALK: {
		struct at_ifaddr *aa;

		if (!aarpresolve(ac, m, (struct sockaddr_at *)dst, edst)) {
#ifdef NETATALKDEBUG
			extern char *prsockaddr(struct sockaddr *);
			printf("aarpresolv: failed for %s\n", prsockaddr(dst));
#endif /* NETATALKDEBUG */
			return (0);
		}

		/*
		 * ifaddr is the first thing in at_ifaddr
		 */
		aa = (struct at_ifaddr *)at_ifawithnet(
			(struct sockaddr_at *)dst,
			TAILQ_FIRST(&ifp->if_addrlist));
		if (aa == 0)
			goto bad;

		/*
		 * In the phase 2 case, we need to prepend an mbuf for the llc
		 * header. Since we must preserve the value of m, which is
		 * passed to us by value, we m_copy() the first mbuf,
		 * and use it for our llc header.
		 */
		if (aa->aa_flags & AFA_PHASE2) {
			struct llc llc;

			M_PREPEND(m, AT_LLC_SIZE, M_DONTWAIT);
			if (m == NULL)
				return (0);
			/*
			 * FreeBSD doesn't count the LLC len in
			 * ifp->obytes, so they increment a length
			 * field here. We don't do this.
			 */
			llc.llc_dsap = llc.llc_ssap = LLC_SNAP_LSAP;
			llc.llc_control = LLC_UI;
			bcopy(at_org_code, llc.llc_snap.org_code,
				sizeof(at_org_code));
			llc.llc_snap.ether_type = htons( ETHERTYPE_AT );
			bcopy(&llc, mtod(m, caddr_t), AT_LLC_SIZE);
			etype = htons(m->m_pkthdr.len);
		} else {
			etype = htons(ETHERTYPE_AT);
		}
		} break;
#endif /* NETATALK */
a658 11
#ifdef NETATALK
	case ETHERTYPE_AT:
		schednetisr(NETISR_ATALK);
		inq = &atintrq1;
		break;
	case ETHERTYPE_AARP:
		/* probably this should be done with a NETISR as well */
		/* XXX queue this */
		aarpinput((struct arpcom *)ifp, m);
		goto done;
#endif
a710 30
#ifdef NETATALK
			/*
			 * Some protocols (like Appletalk) need special
			 * handling depending on if they are type II
			 * or SNAP encapsulated. Everything else
			 * gets handled by stripping off the SNAP header
			 * and going back up to decapsulate.
			 */
			if (l->llc_control == LLC_UI &&
			    l->llc_ssap == LLC_SNAP_LSAP &&
			    Bcmp(&(l->llc_snap.org_code)[0],
			    at_org_code, sizeof(at_org_code)) == 0 &&
			    ntohs(l->llc_snap.ether_type) == ETHERTYPE_AT) {
				inq = &atintrq2;
				m_adj(m, AT_LLC_SIZE);
				schednetisr(NETISR_ATALK);
				break;
			}

			if (l->llc_control == LLC_UI &&
			    l->llc_ssap == LLC_SNAP_LSAP &&
			    Bcmp(&(l->llc_snap.org_code)[0],
			    aarp_org_code, sizeof(aarp_org_code)) == 0 &&
			    ntohs(l->llc_snap.ether_type) == ETHERTYPE_AARP) {
				m_adj(m, AT_LLC_SIZE);
				/* XXX Really this should use netisr too */
				aarpinput((struct arpcom *)ifp, m);
				goto done;
			}
#endif /* NETATALK */
@


1.149
log
@Say no to hand-rolled m_adj(). It also kills three XXX.
OK dlg@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.148 2011/01/28 13:19:44 reyk Exp $	*/
d753 2
a754 2
	{
		struct pipex_session *session;
d756 4
a759 3
		if ((session = pipex_pppoe_lookup_session(m)) != NULL) {
			pipex_pppoe_input(m, session);
			goto done;
a760 1
	}
@


1.148
log
@Change an m_free() to m_freem() to free the whole mbuf chain and to prevent
a possible memory leak with bpf's BIOCSFILDROP option which is currently
used by dhcpd and dhclient.

Found by gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.147 2010/10/11 11:31:14 claudio Exp $	*/
d825 1
a825 3
				m->m_data += 6;		/* XXX */
				m->m_len -= 6;		/* XXX */
				m->m_pkthdr.len -= 6;	/* XXX */
@


1.147
log
@Remove some commented code we will never have.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.146 2010/08/24 14:43:56 blambert Exp $	*/
d673 1
a673 1
		m_free(m);
@


1.146
log
@legibility fixes:

1) one statement per line
2) label gets its own line, and doesn't share it with a statement

no functional change

"Let the turd shine." claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.145 2010/07/02 00:49:43 claudio Exp $	*/
a739 7
		/* XXX we dont have this flag */
		/*
		if (m->m_flags & M_PROMISC) {
			m_freem(m);
			goto done;
		}
		*/
d769 1
a769 1
#endif /* NPPPOE > 0 || defined(PIPEX) */
@


1.145
log
@Some functions change the ifp in during ether_input(). This confuses the
IFF_PROMISC check that ensures that only local packets make it into the
network stack. Check both the original ifp and the new ifp for IFF_PROMISC.
Problem identified by Patrick Coleman.
OK mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.144 2010/06/03 16:15:00 naddy Exp $	*/
d285 6
a290 4
				rtfree(rt); rt = rt0;
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway,
			    RT_REPORT, ifp->if_rdomain);
				if ((rt = rt->rt_gwroute) == 0)
@


1.144
log
@Add support for 802.1ad-style QinQ nested VLANs.

QinQ-compliant svlan (service VLAN) interfaces are implemented as
a new cloner type, use Ethernet type 0x88a8, and have a dedicated
VLAN tag hash to avoid ID conflicts.  vlan(4) interfaces can be
stacked on top of svlan(4).

Originally from reyk@@, input from claudio@@ and deraadt@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.143 2010/05/28 12:09:09 claudio Exp $	*/
d680 1
a680 1
	    (ifp->if_flags & IFF_PROMISC)) {
@


1.143
log
@Rework the way we handle MPLS in the kernel. Instead of fumbling MPLS into
ether_output() and later on other L2 output functions use a trick and over-
load the ifp->if_output() function pointer on MPLS enabled interfaces to
go through mpls_output() which will then call the link level output function.
By setting IFXF_MPLS on an interface the output pointers are switched.
This now allows to cleanup the MPLS input and output pathes and fix mpe(4)
so that the MPLS code now actually works for both P and PE systems.
Tested by myself and michele
(A custom kernel with MPLS and mpe enabled is still needed).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.142 2010/05/07 13:33:16 claudio Exp $	*/
d616 2
a617 2
	if (((m->m_flags & M_VLANTAG) || etype == ETHERTYPE_VLAN)
	    && (vlan_input(eh, m) == 0))
d642 2
a643 1
	if ((m->m_flags & M_VLANTAG) || etype == ETHERTYPE_VLAN) {
@


1.142
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.141 2010/05/01 08:14:26 mk Exp $	*/
d280 1
a280 6
#ifdef MPLS
		if (rt->rt_flags & RTF_MPLS) {
			if ((m = mpls_output(m, rt)) == NULL)
				senderr(EHOSTUNREACH);
		}
#endif
a296 1

d307 1
a307 6
#ifdef MPLS
		if (rt0 != NULL && rt0->rt_flags & RTF_MPLS)
			etype = htons(ETHERTYPE_MPLS);
		else
#endif
			etype = htons(ETHERTYPE_IP);
d374 3
a484 1

@


1.141
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.140 2010/04/03 00:15:35 deraadt Exp $	*/
d274 1
a274 1
			if ((rt0 = rt = rtalloc1(dst, 1,
d291 2
a292 2
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1,
			    ifp->if_rdomain);
@


1.140
log
@document the first byte of the random MAC address
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.139 2010/01/12 06:47:25 yasuoka Exp $	*/
d550 1
a550 1
	/* mark incomming routing domain */
@


1.139
log
@After calling pipex_pppoe_input(), we must goto done to restore the spl.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.138 2010/01/12 03:41:29 deraadt Exp $	*/
d890 1
@


1.138
log
@Unify the various fake ethernet generators as ether_fakeaddr() which
is safe for both hardware devices and virtual devices
ok mpf, kettenis, moaning and groaning and slow acceptance from mcbride
XXX should loop checking for uniqueness after new henning diff goes in
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.137 2010/01/11 03:50:56 yasuoka Exp $	*/
d771 1
a771 1
			return;
@


1.137
log
@Initial import PIPEX.  PIPEX(Pppac IP EXtension) is a IP forwarding
acceleration for PPP access concentrator.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.136 2009/11/03 10:59:04 claudio Exp $	*/
d882 18
a905 1

d910 2
a911 13
	if (ETHER_IS_MULTICAST(((struct arpcom *)ifp)->ac_enaddr)) {
		((struct arpcom *)ifp)->ac_enaddr[0] = 0x00;
		((struct arpcom *)ifp)->ac_enaddr[1] = 0xfe;
		((struct arpcom *)ifp)->ac_enaddr[2] = 0xe1;
		((struct arpcom *)ifp)->ac_enaddr[3] = 0xba;
		((struct arpcom *)ifp)->ac_enaddr[4] = 0xd0;
		/*
		 * XXX use of random() by anything except the scheduler is
		 * normally invalid, but this is boot time, so pre-scheduler,
		 * and the random subsystem is not alive yet
		 */
		((struct arpcom *)ifp)->ac_enaddr[5] = (u_char)random() & 0xff;
	}
@


1.136
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.135 2009/08/12 20:02:42 dlg Exp $	*/
d150 4
d743 1
a743 1
#if NPPPOE > 0
d765 3
d769 6
d782 1
a782 1
#endif /* NPPPOE > 0 */
@


1.135
log
@revert my change to m_cluncount which tries to prevent the system
running out of mbufs for rx rings.

if the system low watermark is lower than a rx rings low watermark,
we'll never send a packet up the stack, we'll always recycle it.

found by thib@@ on a bge
sadface
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.134 2009/08/12 14:39:05 dlg Exp $	*/
d234 1
a234 1
	if (ifp->if_rdomain != m->m_pkthdr.rdomain) {
d236 3
a238 3
		    "%d vs. %d, AF %d\n", ifp->if_xname, ifp->if_rdomain,
		    m->m_pkthdr.rdomain, dst->sa_family);
		senderr(ENETDOWN);
a252 1
		    /* XXX why ifa_ifwithaddr() and not ifaof_ifpforaddr() */
d271 1
a271 1
			    m->m_pkthdr.pf.rtableid)) != NULL)
@


1.134
log
@if we get dangerously low on clusters during interrupts, we need
to free some for use on the rx rings on network cards.

this modifies m_cluncount to advise callers when we're in such a
situation, and makes them responsible for freeing up the cluster
for allocation by MCLGETI later.

fixes an awesome lockup with sis(4) henning has been experiencing.
this is not the best fix, but it is better than the current situation.

yep deraadt@@ tested by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.133 2009/06/05 00:05:21 claudio Exp $	*/
d545 1
a545 8
	/*
	 * the cluster is no longer on the ring, so don't count it against the
	 * ring. if the system wants the packet back we should give it back.
	 */
	if (m_cluncount(m) != 0) {
		m_freem(m);
		return;
	}
@


1.133
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.132 2009/03/05 19:47:05 michele Exp $	*/
d545 8
a552 1
	m_cluncount(m, 1);
@


1.132
log
@Fix a panic in ether_output() when attempting to send multicast traffic on
MPLS enabled kernels.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.131 2009/01/28 22:18:43 michele Exp $	*/
d233 9
d253 2
a254 1
		    (ifa = ifa_ifwithaddr(dst)) != NULL &&
d271 2
a272 1
			if ((rt0 = rt = rtalloc1(dst, 1, 0)) != NULL)
d288 2
a289 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1, 0);
d546 3
@


1.131
log
@Get rid of the ugly rtentry hack.

We can now act as edge node and allow ipv4 packets to
enter a Label Switched Path and not just forwarding
MPLS packets.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.130 2008/11/25 12:07:55 claudio Exp $	*/
d299 1
a299 1
		if (rt0->rt_flags & RTF_MPLS)
@


1.130
log
@m_cluncount() needs to walk the mbuf chain to correctly uncount all clusters
but don't do that in m_free() as that will cause a double loop behaviour when
called via m_freem().
OK dlg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.129 2008/11/24 12:57:37 dlg Exp $	*/
d266 6
d298 6
a303 1
		etype = htons(ETHERTYPE_IP);
@


1.129
log
@add several backend pools to allocate mbufs clusters of various sizes out
of. currently limited to MCLBYTES (2048 bytes) and 4096 bytes until pools
can allocate objects of sizes greater than PAGESIZE.

this allows drivers to ask for "jumbo" packets to fill rx rings with.

the second half of this change is per interface mbuf cluster allocator
statistics. drivers can use the new interface (MCLGETI), which will use
these stats to selectively fail allocations based on demand for mbufs. if
the driver isnt rapidly consuming rx mbufs, we dont allow it to allocate
many to put on its rx ring.

drivers require modifications to take advantage of both the new allocation
semantic and large clusters.

this was written and developed with deraadt@@ over the last two days
ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.128 2008/11/23 23:44:01 tedu Exp $	*/
d522 1
a522 1
	m_cluncount(m);
@


1.128
log
@softraid support for ata over ethernet (aoe).  this includes a client and
part of a server.  there's no configuration yet, and several other drawbacks,
but it can be hammered into shape.  i haven't moved the code forward in a year,
and marco wants it in the tree to hack on.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.127 2008/10/16 19:12:51 naddy Exp $	*/
d521 2
@


1.127
log
@* Allow ether_input() and vlan_input() to handle incoming packets
  where the tag is stored in the mbuf header.
* Make bridge(4) handle interfaces with and without hardware tag
  support and forward packets inbetween.

Help and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.126 2008/10/09 03:31:07 brad Exp $	*/
d138 4
d743 5
@


1.126
log
@Add fallback ioctl handlers for MTU and multicast to ether_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.125 2008/10/02 20:21:14 brad Exp $	*/
d590 2
a591 1
	if (etype == ETHERTYPE_VLAN && (vlan_input(eh, m) == 0))
d616 1
a616 1
	if (etype == ETHERTYPE_VLAN) {
@


1.125
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.124 2008/08/28 13:10:54 brad Exp $	*/
d165 1
a165 5
ether_ioctl(ifp, arp, cmd, data)
	struct ifnet *ifp;
	struct arpcom *arp;
	u_long cmd;
	caddr_t data;
d168 2
a169 1
	int	error = 0;
d181 18
d203 1
a203 1
	return error;
@


1.124
log
@Fix a typo in the naming of the PPPoE input queues, ppoe -> pppoe.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.123 2008/08/04 18:55:08 damien Exp $	*/
a174 1

d185 1
a185 1
		break;
@


1.123
log
@do not count ethernet header twice in if_obytes stats.
do not count address family field twice in tun's if_obytes stats.

ok henning@@ reyk@@ deraadt@@ for the ethernet bits.
ok deraadt@@ for the tun bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.122 2008/06/13 23:24:21 mpf Exp $	*/
d717 1
a717 1
			inq = &ppoediscinq;
d719 1
a719 1
			inq = &ppoeinq;
@


1.122
log
@Move the responsibility to free received packets on trunked interfaces
from ether_input() into trunk_input() where it can be handled in a smarter way.
OK claudio@@ and reyk@@ on an earlier version.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.121 2008/05/10 01:52:34 claudio Exp $	*/
d463 1
a463 1
	ifp->if_obytes += len + ETHER_HDR_LEN;
d466 1
a466 1
		ifp0->if_obytes += len + ETHER_HDR_LEN;
@


1.121
log
@convert sdltosa to a real cast because I removed the silly makro last night.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.120 2008/05/09 00:37:43 claudio Exp $	*/
d512 2
a513 4
		if (++i > TRUNK_MAX_STACKING ||
		    trunk_input(ifp, eh, m) != 0) {
			if (m)
				m_freem(m);
d516 2
@


1.120
log
@A little bit of magic to make arp lookups work in MPLS as they should.
No need to preload the arp table anymore. hai norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.119 2008/05/07 05:51:12 mpf Exp $	*/
d343 2
a344 1
				if (satosdl(dst)->sdl_alen < sizeof(edst))
d346 2
a347 1
				bcopy(LLADDR(satosdl(dst)), edst, sizeof(edst));
@


1.119
log
@Prevent virtual interfaces from adding to the random pool.
Also move the sampling into ether_input() where it can happen
at the interrupt and not within splnet() processing, which might
be less random. Discussed with mickey.
OK markus@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.118 2008/04/23 10:55:14 norby Exp $	*/
d337 1
a337 1
			dst = (struct sockaddr *)rt->rt_gateway;
@


1.118
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.117 2008/04/18 09:16:14 djm Exp $	*/
d107 2
d567 5
@


1.117
log
@extend the if_ethersubr.c crc functions to support updating a running
crc in addition to the existing "oneshot" mode and use them to replace
ieee80211_crc_update() with the new ether_crc32_le_update(). Saves 1k
kernel bss + some code.

Mark the new ether_crc32_[lb]e_update functions as __pure for a
~25x speedup (on my i386 at least).

feedback and ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.116 2008/04/10 23:15:45 dlg Exp $	*/
d153 4
d332 27
d715 7
@


1.116
log
@introduce mitigation for the calling of an interfaces start routine.

decent drivers prefer to have a lot of packets on the send queue so they
can queue a lot of them up on the tx ring and then post them all in one
big chunk. unfortunately our stack queues one packet onto the send queue
and then calls the start handler immediately.

this mitigates against that queue, send, queue, send behaviour by trying to
call the start routine only once per softnet. now its queue, queue, queue,
send.

this is the result of a lot of discussion with claudio@@
tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.115 2008/04/10 22:33:14 brad Exp $	*/
d839 2
a840 2
u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
d842 1
a842 1
	u_int32_t c, crc, carry;
a844 2
	crc = 0xffffffffU;	/* initial value */

d859 2
a860 2
u_int32_t
ether_crc32_be(const u_int8_t *buf, size_t len)
d862 1
a862 1
	u_int32_t c, crc, carry;
a864 2
	crc = 0xffffffffU;	/* initial value */

d879 2
a880 2
u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
a888 3
	u_int32_t crc;

	crc = 0xffffffffU;	/* initial value */
d899 2
a900 2
u_int32_t
ether_crc32_be(const u_int8_t *buf, size_t len)
a912 1
	u_int32_t crc;
a914 1
	crc = 0xffffffffU;	/* initial value */
d924 12
@


1.115
log
@Also count multicast packets and input bytes for interfaces enslaved by
trunk(4).

PR 5248

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.114 2008/02/05 22:57:30 mpf Exp $	*/
d435 1
a435 2
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
@


1.114
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.113 2008/01/17 17:50:59 bluhm Exp $	*/
d452 2
a453 2
ether_input(ifp, eh, m)
	struct ifnet *ifp;
d462 1
d522 4
d529 4
@


1.113
log
@In ether_input() scheduling the soft interrupt and queueing the
packet have to be protected by the same splnet.  Otherwise on
architectures where soft interrupts are executed immediately, the
interrupt is processed before the packet is in the queue.

On real hardware interfaces this was not a problem as ether_input()
is called at splnet anyway.  But when sending to a tun interface
the packet got delayed.

ok beck@@ miod@@ henning@@ mpf@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.112 2007/11/22 01:21:40 mpf Exp $	*/
d567 1
a567 1
		/* Always clear multicast flags if received on a carp address */
a568 1
		    ifp->if_flags & IFF_LINK2 &&
d570 1
a570 2
		    !bcmp(((struct arpcom *)ifp)->ac_enaddr,
		    (caddr_t)eh->ether_dhost, ETHER_ADDR_LEN))
@


1.112
log
@Factor out the virtual host portion of carp into a separate struct
that is kept in a list per carp interface.  This is the huge first
step necessary to make carp load balancing nice and easy. One carp
interface can now contain up to 32 virtual host instances.
This doesn't do anything useful yet, but here is how an ifconfig
for multiple entries now looks like:

# ifconfig carp2 carpnodes 5:0,6:100 192.168.5.88

carp2: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        lladdr 00:00:5e:00:01:05
        carp: carpdev sis0 advbase 1
                state MASTER vhid 5 advskew 0
                state BACKUP vhid 6 advskew 100
        groups: carp
        inet 192.168.5.88 netmask 0xffffff00 broadcast 192.168.5.255

OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.111 2007/09/15 16:43:51 henning Exp $	*/
d600 4
d624 1
a624 1
		return;
d645 1
a645 1
		return;
d654 1
a654 1
			return;
d660 1
a660 1
			return;
d665 1
a665 1
			return;
d712 1
a712 1
				return;
d726 1
a726 1
					return;
d734 1
a734 1
			return;
a737 1
	s = splnet();
d739 1
@


1.111
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.110 2007/06/06 10:04:36 henning Exp $	*/
d370 2
a371 5
	if (ifp0 != ifp && ifp0->if_type == IFT_CARP &&
	    !(ifp0->if_flags & IFF_LINK1)) {
		bcopy((caddr_t)((struct arpcom *)ifp0)->ac_enaddr,
		    (caddr_t)eh->ether_shost, sizeof(eh->ether_shost));
	}
@


1.110
log
@remove remaining IPX hooks. all inside #ifdef IPX, so no actual change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.109 2007/05/29 20:19:37 henning Exp $	*/
d1055 1
a1055 1
	enm = (struct ether_multi *)malloc(sizeof(*enm), M_IFMADDR, M_NOWAIT);
@


1.109
log
@there was code inside
#if NPF > 0
to prevent feeding back the mbuf do looutput if we are on simplex
interfaces and the packet has been routed by pf, whch can lead to a loop
in weird corner cases.
apparently nobody triggered these cases in ages, since pf.h was not included
and thus NPF not defined and thus this code not compiled.
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.108 2007/05/16 20:27:58 michele Exp $	*/
a143 5
#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

a171 14
#ifdef IPX
		case AF_IPX:
		    {
			struct ipx_addr *ina = &IA_SIPX(ifa)->sipx_addr;

			if (ipx_nullhost(*ina))
				ina->ipx_host =
				    *(union ipx_host *)(arp->ac_enaddr);
			else
				bcopy(ina->ipx_host.c_host,
				    arp->ac_enaddr, sizeof(arp->ac_enaddr));
			break;
		    }
#endif /* IPX */
a277 10
#ifdef IPX
	case AF_IPX:
		etype = htons(ETHERTYPE_IPX);
		bcopy((caddr_t)&satosipx(dst)->sipx_addr.ipx_host,
		    (caddr_t)edst, sizeof(edst));
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		break;
#endif
a634 6
#ifdef IPX
	case ETHERTYPE_IPX:
		schednetisr(NETISR_IPX);
		inq = &ipxintrq;
		break;
#endif
@


1.108
log
@fix return values in bridge_output.

OK claudio@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.107 2007/05/16 09:24:07 dlg Exp $	*/
d284 3
a286 8
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX)) {
#if NPF > 0
			struct pf_mtag	*t;

			if ((t = pf_find_mtag(m)) == NULL || !t->routed)
#endif
				mcopy = m_copy(m, 0, (int)M_COPYALL);
		}
@


1.107
log
@count the number of multicast ranges that are kept in the list of multicast
addresses in struct arpcom. this lets a nic driver easily see if it wants
allmulti behaviour, which in turn means we can clean some code up.

ok jason@@ claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.106 2007/03/18 23:23:17 mpf Exp $	*/
d446 1
a446 1
			bridge_output(ifp, m, NULL, NULL);
@


1.106
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.105 2006/12/07 18:15:29 reyk Exp $	*/
d1106 2
d1156 2
@


1.105
log
@use LINK_STATE_IS_UP(ifp0->if_link_state) instead of
ifp0->if_link_state == LINK_STATE_UP to handle the new half/full
duplex link states. i forgot to commit these snippets before.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.104 2006/10/31 14:28:29 jason Exp $	*/
d404 2
a405 1
	if (ifp0 != ifp && ifp0->if_type == IFT_CARP) {
d599 13
a611 4
	if (ifp->if_carp && ifp->if_type != IFT_CARP &&
	    (carp_input(m, (u_int8_t *)&eh->ether_shost,
	    (u_int8_t *)&eh->ether_dhost, eh->ether_type) == 0))
		return;
@


1.104
log
@ether_input_mbuf() isn't necessary, turn it into a macro and deal with
it's "special" case in ether_input().  Based on similiar idea in FreeBSD.
ok brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.103 2006/06/16 16:49:39 henning Exp $	*/
d238 1
a238 1
		if (dst != NULL && ifp0->if_link_state == LINK_STATE_UP &&
@


1.103
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.102 2006/05/26 20:50:41 deraadt Exp $	*/
a482 16
 * Temporary function to migrate while
 * removing ether_header * from ether_input().
 */
void
ether_input_mbuf(ifp, m)
	struct ifnet *ifp;
	struct mbuf *m;
{
	struct ether_header *eh;

	eh = mtod(m, struct ether_header *);
	m_adj(m, ETHER_HDR_LEN);
	ether_input(ifp, eh, m);
}

/*
d504 5
@


1.102
log
@rename jumbo mtu to if_hardmtu; ok brad reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.101 2006/05/19 19:50:23 reyk Exp $	*/
d256 1
a256 1
			if ((rt0 = rt = rtalloc1(dst, 1)) != NULL)
d266 1
a266 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
@


1.101
log
@add a if_jumbo_mtu field to the interface structure for drivers
supporting ethernet jumbo frames. there's no standard for the size of
jumbo MTUs, so either let the driver set it's own value or use 9000
byte jumbo frames by default.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.100 2006/03/04 22:40:15 brad Exp $	*/
d836 2
a837 8
	/*
	 * If the device supports sending of jumbo frames,
	 * either use the default maximum jumbo frame size
	 * or the one specified by the driver.
	 */
	if (ifp->if_capabilities & IFCAP_JUMBO_MTU &&
	    ifp->if_jumbo_mtu == 0)
		ifp->if_jumbo_mtu = ETHERMTU_JUMBO;
@


1.100
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.99 2005/11/03 20:00:18 reyk Exp $	*/
d835 9
@


1.99
log
@re-implement the bpf "filter drop" option that it actually works. the
bpf FILDROP interface exists for about one year but the required
interface to the drivers was missing - so it was useless. this new
approach based on a design by henning@@ uses a new mbuf flag to mark
filtered packets and to drop them in the generic network stack input
routines (like ether_input).

for example; after some additional testing, this could be used by
dhclient to filter everything except DHCP packets (track tech@@
for a corresponding dhclient diff). the "filter dropped" packets won't
reach the network stack. so it's probably some kind of a very basic
application layer packet filter ;).

ok canacar@@, discussed with henning@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.98 2005/10/17 08:43:35 henning Exp $	*/
d453 1
a453 1
	s = splimp();
d778 1
a778 1
	s = splimp();
d1062 1
a1062 1
	int s = splimp(), error;
d1123 1
a1123 1
	int s = splimp(), error;
@


1.98
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.97 2005/09/30 02:39:24 brad Exp $	*/
d616 8
@


1.97
log
@remove old unused NRL IPv6 code.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.96 2005/06/08 06:55:33 henning Exp $	*/
d284 8
a291 3
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    m_tag_find(m, PACKET_TAG_PF_ROUTED, NULL) == NULL)
			mcopy = m_copy(m, 0, (int)M_COPYALL);
@


1.96
log
@bye bye netns (and a few leftover DECNET bits while here)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.95 2005/06/07 07:09:42 camield Exp $	*/
a306 23
#if 0	/*NRL INET6*/
	case AF_INET6:
		/*
		 * The bottom line here is to either queue the outgoing packet
		 * in the discovery engine, or fill in edst with something
		 * that'll work.
		 */
		if (m->m_flags & M_MCAST) {
			/*
			 * If multicast dest., then use IPv6 -> Ethernet
			 * mcast mapping.  Really simple.
			 */
			ETHER_MAP_IPV6_MULTICAST(
			    &((struct sockaddr_in6 *)dst)->sin6_addr,
			    edst);
		} else {
			/* Do unicast neighbor discovery stuff. */
			if (!ipv6_discov_resolve(ifp, rt, m, dst, edst))
				return 0;
		}
		etype = htons(ETHERTYPE_IPV6);
		break;
#endif /* INET6 */
@


1.95
log
@Run vlan_input before bridge_input, and change vlan_input to not
consume vlan frames that no vlan interface wants, so they can
still be bridged.

This way, the bridge can bridge encapsulated frames _and_ bridge
between vlan interfaces.

ok henning markus
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.94 2005/06/07 02:45:11 henning Exp $	*/
a143 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a195 15
#ifdef NS
		/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(arp->ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    arp->ac_enaddr, sizeof(arp->ac_enaddr));
			break;
		    }
#endif /* NS */
a296 12
#ifdef NS
	case AF_NS:
		etype = htons(ETHERTYPE_NS);
		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
		    (caddr_t)edst, sizeof(edst));
		if (!bcmp((caddr_t)edst, (caddr_t)&ns_thishost, sizeof(edst)))
			return (looutput(ifp, m, dst, rt));
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		break;
#endif
a683 6
		break;
#endif
#ifdef NS
	case ETHERTYPE_NS:
		schednetisr(NETISR_NS);
		inq = &nsintrq;
@


1.94
log
@do not handle CCITT any longer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.93 2005/05/24 16:28:03 deraadt Exp $	*/
d624 5
d651 3
a653 2
		if (vlan_input(eh, m) < 0)
			ifp->if_noproto++;
@


1.93
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.92 2005/05/24 16:00:02 deraadt Exp $	*/
a153 6
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_extern.h>
#include <netccitt/dll.h>
#include <netccitt/llc_var.h>

a162 4
#if defined(CCITT)
#include <sys/socketvar.h>
#endif

a179 7
#if defined(CCITT)
	case SIOCSIFCONF_X25:
		ifp->if_flags |= IFF_UP;
		ifa->ifa_rtrequest = cons_rtrequest;
		error = x25_llcglue(PRC_IFUP, ifa->ifa_addr);
		break;
#endif /* CCITT */
a411 37
/*	case AF_NSAP: */
	case AF_CCITT: {
		struct sockaddr_dl *sdl =
			(struct sockaddr_dl *) rt -> rt_gateway;

		if (sdl && sdl->sdl_family == AF_LINK
		    && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (char *)edst,
				sizeof(edst));
		} else goto bad; /* Not a link interface ? Funny ... */
		if ((ifp->if_flags & IFF_SIMPLEX) && (*edst & 1) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof(*eh), M_DONTWAIT);
			if (mcopy) {
				eh = mtod(mcopy, struct ether_header *);
				bcopy(edst, eh->ether_dhost, sizeof(edst));
				bcopy(ac->ac_enaddr, eh->ether_shost,
				    sizeof(edst));
			}
		}
		etype = htons(m->m_pkthdr.len);
#ifdef LLC_DEBUG
		{
			int i;
			struct llc *l = mtod(m, struct llc *);

			printf("ether_output: sending LLC2 pkt to: ");
			for (i=0; i < ETHER_ADDR_LEN; i++)
				printf("%x ", edst[i] & 0xff);
			printf(" len 0x%x dsap 0x%x ssap 0x%x control 0x%x\n",
			    m->m_pkthdr.len, l->llc_dsap & 0xff,
			    l->llc_ssap &0xff, l->llc_control & 0xff);

		}
#endif /* LLC_DEBUG */
		} break;

a812 19
#ifdef CCITT
		case LLC_X25_LSAP:
			if (m->m_pkthdr.len > etype)
				m_adj(m, etype - m->m_pkthdr.len);
			M_PREPEND(m, sizeof(struct sdl_hdr) , M_DONTWAIT);
			if (m == 0)
				return;
			if (!sdl_sethdrif(ifp, eh->ether_shost, LLC_X25_LSAP,
			    eh->ether_dhost, LLC_X25_LSAP, ETHER_ADDR_LEN,
			    mtod(m, struct sdl_hdr *)))
				panic("ETHER cons addr failure");
			mtod(m, struct sdl_hdr *)->sdlhdr_len = etype;
#ifdef LLC_DEBUG
			printf("llc packet\n");
#endif /* LLC_DEBUG */
			schednetisr(NETISR_CCITT);
			inq = &llcintrq;
			break;
#endif /* CCITT */
@


1.92
log
@let ramdisks compile again.  people -- please always try to compile with your new options off, too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.91 2005/05/24 07:51:53 reyk Exp $	*/
d619 1
a619 1
	i = 0;
@


1.91
log
@support trunk stacking (trunks as trunk ports) and some fixes

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.90 2005/05/24 02:45:17 reyk Exp $	*/
d615 1
a615 1
	int s, llcfound = 0, i = 0;
d618 3
@


1.90
log
@initial import of a trunking (link aggregation and link failover)
implementation. it currently supports round robin mode with link state
checking, additional modes will be added later.

ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.89 2005/04/25 01:34:27 brad Exp $	*/
d615 1
a615 1
	int s, llcfound = 0;
d624 5
a628 2
	if (ifp->if_type == IFT_IEEE8023ADLAG) {
		if (trunk_input(ifp, eh, m) != 0)
d630 2
@


1.89
log
@Use ETHERTYPE_VLAN.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.88 2005/01/18 23:26:52 mpf Exp $	*/
d97 1
d131 5
d265 5
d620 10
@


1.88
log
@Rewriting the lladdr can now be done without using mbuf tags.
Advertisements run through the carp interface first.
So we just take the address from ifp0.
While we're there,
also remove carp_macmatch6, which isn't used anymore.

Proposed by mcbride@@
ok mcbride@@, pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.87 2004/12/19 03:25:36 mcbride Exp $	*/
d670 1
a670 1
	if (etype == ETHERTYPE_8021Q) {
@


1.87
log
@Make it possible for carp to work on fddi and token ring again.

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.86 2004/12/17 12:42:02 pascoe Exp $	*/
d497 3
a499 4
	if (ifp->if_carp) {
		error = carp_fix_lladdr(ifp0, m, dst, NULL);
		if (error)
			goto bad;
@


1.86
log
@Reorder code in the ethernet output path, and enhance unicast address
matching in the bridge receive path to make CARP operate correctly
on physical interfaces that are participating in a bridge.

ok mcbride@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.85 2004/12/10 22:35:17 mcbride Exp $	*/
d680 2
a681 1
	    (carp_input(eh, m) == 0))
@


1.85
log
@Rename carp_output() to carp_fix_lladdr().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.84 2004/12/09 16:57:35 mcbride Exp $	*/
d496 8
a541 8
	}
#endif

#if NCARP > 0
	if (ifp->if_carp) {
		error = carp_fix_lladdr(ifp0, m, dst, NULL);
		if (error)
			goto bad;
@


1.84
log
@Remove shadow variable 'error'. From camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.83 2004/12/07 20:38:46 mcbride Exp $	*/
d539 1
a539 1
		error = carp_output(ifp0, m, dst, NULL);
@


1.83
log
@Convert carp(4) to behave more like a regular interface, much in the same
style as vlan(4). carp interfaces no longer require the physical interface
to be on the same subnet as the carp interface, or even that the physical
interface has an adress at all, so CARP can now be used on /30 networks.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.82 2004/12/07 19:26:46 mcbride Exp $	*/
a538 1
		int error;
@


1.82
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.81 2004/11/28 23:39:45 canacar Exp $	*/
d242 2
a243 2
ether_output(ifp, m0, dst, rt0)
	struct ifnet *ifp;
d255 1
a255 1
	struct arpcom *ac = (struct arpcom *)ifp;
d257 20
d540 1
a540 1
		error = carp_output(ifp, m, dst, NULL);
d560 4
d680 3
a682 3
	if (ifp->if_carp &&
	    carp_forus(ifp->if_carp, eh->ether_dhost))
		goto decapsulate;
@


1.81
log
@In kernel pppoe client, a simple IPv4 only implementation.
Initial porting from NetBSD by David Berghoff.
Modified/simplified to match our sppp implementation.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.80 2004/10/09 19:55:29 brad Exp $	*/
d167 2
a168 1
u_char etherbroadcastaddr[ETHER_ADDR_LEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
d250 1
a250 1
 	u_char edst[ETHER_ADDR_LEN], esrc[ETHER_ADDR_LEN];
d306 2
a307 2
 		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
		    (caddr_t)edst, sizeof (edst));
d318 2
a319 2
 		bcopy((caddr_t)&satosipx(dst)->sipx_addr.ipx_host,
		    (caddr_t)edst, sizeof (edst));
d337 2
a338 1
			ETHER_MAP_IPV6_MULTICAST(&((struct sockaddr_in6 *)dst)->sin6_addr,
d410 1
a410 1
			M_PREPEND(mcopy, sizeof (*eh), M_DONTWAIT);
d413 1
a413 1
				bcopy(edst, eh->ether_dhost, sizeof (edst));
d415 1
a415 1
				    sizeof (edst));
d428 2
a429 2
			    m->m_pkthdr.len, l->llc_dsap & 0xff, l->llc_ssap &0xff,
			    l->llc_control & 0xff);
d438 1
a438 1
		bcopy((caddr_t)eh->ether_shost, (caddr_t)esrc, sizeof (esrc));
d443 1
a443 1
 		bcopy((caddr_t)eh->ether_dhost, (caddr_t)edst, sizeof (edst));
d468 1
a468 1
 	bcopy((caddr_t)edst, (caddr_t)eh->ether_dhost, sizeof (edst));
d470 1
a470 1
	 	bcopy((caddr_t)esrc, (caddr_t)eh->ether_shost,
d473 1
a473 1
	 	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
d599 2
a600 1
				if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
d623 1
a623 1
	ifp->if_ibytes += m->m_pkthdr.len + sizeof (*eh);
d652 1
a652 1
       }
d750 1
a750 1
		
d753 2
a754 2
		
		if (etype == ETHERTYPE_PPPOEDISC) 
d808 1
a808 1
				M_PREPEND(m, sizeof *eh, M_DONTWAIT);
d892 1
a892 1
		
@


1.80
log
@sizeof(struct ether_header) -> ETHER_HDR_LEN

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.79 2004/07/16 15:01:08 henning Exp $	*/
d125 5
d583 3
d728 31
@


1.79
log
@remove netiso shitz, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.78 2004/06/26 06:01:14 naddy Exp $	*/
d455 1
a455 1
	M_PREPEND(m, sizeof (struct ether_header), M_DONTWAIT);
d532 1
a532 1
	ifp->if_obytes += len + sizeof (struct ether_header);
d862 1
a862 1
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
@


1.78
log
@Add a table-driven implementation of ether_crc32_be().
From Seishi Hiragushi via FreeBSD PR kern/49957.

Also, while we're here, make the loop counter size_t.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.77 2004/06/21 23:50:36 tholo Exp $	*/
a142 7
#ifdef ISO
#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#endif

a390 46
#ifdef	ISO
	case AF_ISO: {
		int	snpalen;
		struct	llc *l;
		struct sockaddr_dl *sdl;

		if (rt && (sdl = (struct sockaddr_dl *)rt->rt_gateway) &&
		    sdl->sdl_family == AF_LINK && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (caddr_t)edst, sizeof(edst));
		} else {
			error = iso_snparesolve(ifp, (struct sockaddr_iso *)dst,
						(char *)edst, &snpalen);
			if (error)
				goto bad; /* Not Resolved */
		}
		/* If broadcasting on a simplex interface, loopback a copy */
		if (*edst & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*eh), M_DONTWAIT);
			if (mcopy) {
				eh = mtod(mcopy, struct ether_header *);
				bcopy(edst, eh->ether_dhost, sizeof (edst));
				bcopy(ac->ac_enaddr, eh->ether_shost,
				    sizeof (edst));
			}
		}
		M_PREPEND(m, 3, M_DONTWAIT);
		if (m == NULL)
			return (0);
		etype = htons(m->m_pkthdr.len);
		l = mtod(m, struct llc *);
		l->llc_dsap = l->llc_ssap = LLC_ISO_LSAP;
		l->llc_control = LLC_UI;
#ifdef ARGO_DEBUG
		if (argo_debug[D_ETHER]) {
			int i;
			printf("unoutput: sending pkt to: ");
			for (i=0; i < ETHER_ADDR_LEN; i++)
				printf("%x ", edst[i] & 0xff);
			printf("\n");
		}
#endif
		} break;
#endif /* ISO */
a772 64
#ifdef	ISO
		case LLC_ISO_LSAP:
			switch (l->llc_control) {
			case LLC_UI:
				/* LLC_UI_P forbidden in class 1 service */
				if ((l->llc_dsap == LLC_ISO_LSAP) &&
				    (l->llc_ssap == LLC_ISO_LSAP)) {
					/* LSAP for ISO */
					if (m->m_pkthdr.len > etype)
						m_adj(m, etype - m->m_pkthdr.len);
					m->m_data += 3;		/* XXX */
					m->m_len -= 3;		/* XXX */
					m->m_pkthdr.len -= 3;	/* XXX */
					M_PREPEND(m, sizeof *eh, M_DONTWAIT);
					if (m == 0)
						return;
					*mtod(m, struct ether_header *) = *eh;
#ifdef ARGO_DEBUG
					if (argo_debug[D_ETHER])
						printf("clnp packet");
#endif
					schednetisr(NETISR_ISO);
					inq = &clnlintrq;
					break;
				}
				goto dropanyway;

			case LLC_XID:
			case LLC_XID_P:
				if (m->m_len < ETHER_ADDR_LEN)
					goto dropanyway;
				l->llc_window = 0;
				l->llc_fid = 9;
				l->llc_class = 1;
				l->llc_dsap = l->llc_ssap = 0;
				/* Fall through to */
			case LLC_TEST:
			case LLC_TEST_P:
			{
				struct sockaddr sa;
				struct ether_header *eh2;
				int i;
				u_char c = l->llc_dsap;

				l->llc_dsap = l->llc_ssap;
				l->llc_ssap = c;
				if (m->m_flags & (M_BCAST | M_MCAST))
					bcopy(ac->ac_enaddr,
					    eh->ether_dhost, ETHER_ADDR_LEN);
				sa.sa_family = AF_UNSPEC;
				sa.sa_len = sizeof(sa);
				eh2 = (struct ether_header *)sa.sa_data;
				for (i = 0; i < ETHER_ADDR_LEN; i++) {
					eh2->ether_shost[i] = c = eh->ether_dhost[i];
					eh2->ether_dhost[i] =
						eh->ether_dhost[i] = eh->ether_shost[i];
					eh->ether_shost[i] = c;
				}
				ifp->if_output(ifp, m, &sa, NULL);
				return;
			}
			break;
			}
#endif /* ISO */
@


1.77
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.76 2004/04/17 00:09:01 henning Exp $	*/
d1005 2
a1006 3
 * This is for reference.  We have a table-driven version
 * of the little-endian crc32 generator, which is faster
 * than the double-loop.
d1029 22
d1061 1
a1062 1
	int i;
a1073 1
#endif
d1078 13
a1090 2
	u_int32_t c, crc, carry;
	size_t i, j;
a1092 1

d1094 3
a1096 8
		c = buf[i];
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000U) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ ETHER_CRC_POLY_BE) | carry;
		}
d1101 1
@


1.76
log
@add a congestion indicator to if_queue. It is set when the input queue
is full, along with a timer that unsets it again after 10ms.
The input queue beeing full is a reliable indicator for CPU overload, and
this flag allows other subsystems to cope with the situation.
hacked with beck
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.75 2004/02/15 02:52:41 avsm Exp $	*/
d280 1
a280 1
			    time.tv_sec < rt->rt_rmx.rmx_expire)
@


1.75
log
@18 -> ETHER_ADDR_LEN*3 in ether_sprintf() for clarity
itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.74 2004/01/09 10:44:32 markus Exp $	*/
d917 1
a917 5
	if (IF_QFULL(inq)) {
		IF_DROP(inq);
		m_freem(m);
	} else
		IF_ENQUEUE(inq, m);
@


1.74
log
@fix leak ether_deatch(): if if_free_sadl() is called before if_detach()
then ifnet_addrs[ifp->if_index] leaks; if it's called after if_detach()
then if_free_sadl() does nothing; ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.73 2003/12/10 07:22:42 itojun Exp $	*/
d934 1
a934 1
	static char etherbuf[18];
@


1.73
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.72 2003/10/25 19:31:05 mcbride Exp $	*/
d1001 2
d1004 1
@


1.72
log
@"goto bad" on error with carp_input, instead of simply returning.
Fixes leakage of mbufs on error.

Pointed out by Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.71 2003/10/17 21:04:58 mcbride Exp $	*/
d175 1
a175 1
	register struct ifnet *ifp;
d244 1
a244 1
	register struct ifnet *ifp;
d252 2
a253 2
	register struct mbuf *m = m0;
	register struct rtentry *rt;
d255 1
a255 1
	register struct ether_header *eh;
d402 1
a402 1
		register struct sockaddr_dl *sdl;
d446 1
a446 1
		register struct sockaddr_dl *sdl =
d468 1
a468 1
			register struct llc *l = mtod(m, struct llc *);
d623 1
a623 1
	register struct ether_header *eh;
d626 1
a626 1
	register struct ifqueue *inq;
d629 1
a629 1
	register struct llc *l;
d866 1
a866 1
				register struct ether_header *eh2;
d931 1
a931 1
	register u_char *ap;
d933 1
a933 1
	register int i;
d935 1
a935 1
	register char *cp = etherbuf;
d951 1
a951 1
	register struct ifnet *ifp;
d1170 1
a1170 1
	register struct arpcom *ac;
d1172 1
a1172 1
	register struct ether_multi *enm;
d1231 1
a1231 1
	register struct arpcom *ac;
d1233 1
a1233 1
	register struct ether_multi *enm;
@


1.71
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.70 2003/08/18 11:01:41 dhartmei Exp $	*/
d568 1
a568 1
			return (error);
@


1.70
log
@prevent looutput() feedback of broadcast/multicast packets if they are
pf routed. prevents a kernel lockup with some (non-sensical) route-to
rules. report and debugging by mpech@@. ok itojun@@, henning@@, mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.69 2003/06/02 23:28:12 millert Exp $	*/
d120 5
d563 9
d696 6
@


1.69
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.68 2003/02/16 21:30:13 deraadt Exp $	*/
d286 2
a287 1
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
@


1.68
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.67 2003/01/07 09:00:33 kjc Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.67
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.66 2002/09/11 05:38:47 itojun Exp $	*/
d838 1
a838 1
				if(m->m_len < ETHER_ADDR_LEN)
@


1.66
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.65 2002/06/30 13:04:36 itojun Exp $	*/
a256 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a282 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d568 1
a568 1
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
a586 93

#ifdef ALTQ
/*
 * This routine is a slight hack to allow a packet to be classified
 * if the Ethernet headers are present.  It will go away when ALTQ's
 * classification engine understands link headers.
 */
void
altq_etherclassify(struct ifaltq *ifq, struct mbuf *m,
    struct altq_pktattr *pktattr)
{
	struct ether_header *eh;
	u_int16_t ether_type;
	int hlen, af, hdrsize;
	caddr_t hdr;

	hlen = ETHER_HDR_LEN;
	eh = mtod(m, struct ether_header *);

	ether_type = htons(eh->ether_type);

	if (ether_type < ETHERMTU) {
		/* LLC/SNAP */
		struct llc *llc = (struct llc *)(eh + 1);
		hlen += 8;

		if (m->m_len < hlen ||
		    llc->llc_dsap != LLC_SNAP_LSAP ||
		    llc->llc_ssap != LLC_SNAP_LSAP ||
		    llc->llc_control != LLC_UI) {
			/* Not SNAP. */
			goto bad;
		}

		ether_type = htons(llc->llc_un.type_snap.ether_type);
	}

	switch (ether_type) {
	case ETHERTYPE_IP:
		af = AF_INET;
		hdrsize = 20;		/* sizeof(struct ip) */
		break;

	case ETHERTYPE_IPV6:
		af = AF_INET6;
		hdrsize = 40;		/* sizeof(struct ip6_hdr) */
		break;

	default:
		af = AF_UNSPEC;
		hdrsize = 0;
		break;
	}

	while (m->m_len <= hlen) {
		hlen -= m->m_len;
		m = m->m_next;
	}
	if (m->m_len < (hlen + hdrsize)) {
		/*
		 * protocol header not in a single mbuf.
		 * We can't cope with this situation right now
		 * (but it shouldn't ever happen, really, anyhow).
		 */
#ifdef DEBUG
		printf("altq_etherclassify: headers span multiple mbufs: "
		    "%d < %d\n", m->m_len, (hlen + hdrsize));
#endif
		goto bad;
	}

	m->m_data += hlen;
	m->m_len -= hlen;

	hdr = mtod(m, caddr_t);

	if (ALTQ_NEEDS_CLASSIFY(ifq))
		pktattr->pattr_class =
		    (*ifq->altq_classify)(ifq->altq_clfier, m, af);
	pktattr->pattr_af = af;
	pktattr->pattr_hdr = hdr;

	m->m_data -= hlen;
	m->m_len += hlen;

	return;

 bad:
	pktattr->pattr_class = NULL;
	pktattr->pattr_hdr = NULL;
	pktattr->pattr_af = AF_UNSPEC;
}
#endif /* ALTQ */
@


1.65
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.64 2002/06/10 22:48:09 chris Exp $	*/
d305 1
a305 1
			return(0); /* it must be impossible, but... */
d1263 1
a1263 1
		return(error);
@


1.64
log
@Split common code which converts a multicast address to an ethernet
address from ether_addmulti() and ether_delmulti() into ether_multiaddr(),
a'la netbsd.

Also clean up some magic numbers.

itojun likes it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.63 2002/05/17 07:21:53 kjc Exp $	*/
a1035 2
	register struct ifaddr *ifa;
	register struct sockaddr_dl *sdl;
d1060 4
a1063 10
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
		    sdl->sdl_family == AF_LINK) {
			sdl->sdl_type = IFT_ETHER;
			sdl->sdl_alen = ifp->if_addrlen;
			bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			    LLADDR(sdl), ifp->if_addrlen);
			break;
		}
	}
d1083 2
@


1.63
log
@sync with KAME.
 - make altq_etherclassify() able to handle packets whose ethernet header
   is in a separate mbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.62 2002/05/07 19:28:58 nate Exp $	*/
d168 1
a168 1
u_char	etherbroadcastaddr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
d250 1
a250 1
 	u_char edst[6], esrc[6];
d442 1
a442 1
			for (i=0; i<6; i++)
d476 1
a476 1
			for (i=0; i<6; i++)
d938 1
a938 1
				if(m->m_len < 6)
d957 1
a957 1
					    eh->ether_dhost, 6);
d961 1
a961 1
				for (i = 0; i < 6; i++) {
d981 1
a981 1
			    eh->ether_dhost, LLC_X25_LSAP, 6,
d1020 1
a1020 1
	for (i = 0; i < 6; i++) {
d1058 2
a1059 2
	ifp->if_addrlen = 6;
	ifp->if_hdrlen = 14;
d1167 6
a1172 2
u_char	ether_ipmulticast_min[6] = { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x00 };
u_char	ether_ipmulticast_max[6] = { 0x01, 0x00, 0x5e, 0x7f, 0xff, 0xff };
d1175 4
a1178 2
u_char	ether_ip6multicast_min[6] = { 0x33, 0x33, 0x00, 0x00, 0x00, 0x00 };
u_char	ether_ip6multicast_max[6] = { 0x33, 0x33, 0xff, 0xff, 0xff, 0xff };
d1182 2
a1183 2
 * Add an Ethernet multicast address or range of addresses to the list for a
 * given interface.
d1186 2
a1187 3
ether_addmulti(ifr, ac)
	struct ifreq *ifr;
	register struct arpcom *ac;
a1188 1
	register struct ether_multi *enm;
d1191 1
a1191 1
#endif
a1194 3
	u_char addrlo[6];
	u_char addrhi[6];
	int s = splimp();
d1196 1
a1196 1
	switch (ifr->ifr_addr.sa_family) {
d1199 2
a1200 2
		bcopy(ifr->ifr_addr.sa_data, addrlo, 6);
		bcopy(addrlo, addrhi, 6);
d1205 1
a1205 1
		sin = (struct sockaddr_in *)&(ifr->ifr_addr);
d1208 3
a1210 2
			 * An IP address of INADDR_ANY means listen to all
			 * of the Ethernet multicast addresses used for IP.
d1213 3
a1215 4
			bcopy(ether_ipmulticast_min, addrlo, 6);
			bcopy(ether_ipmulticast_max, addrhi, 6);
		}
		else {
d1217 1
a1217 1
			bcopy(addrlo, addrhi, 6);
d1223 1
a1223 2
		sin6 = (struct sockaddr_in6 *)
			&(((struct in6_ifreq *)ifr)->ifr_addr);
d1226 9
a1234 3
			 * An unspecified IPv6 address means listen to all
			 * of the IPv6 multicast addresses on this Ethernet.
			 * (Multicast routers like this.)
d1236 1
d1244 1
a1244 1
#endif /* INET6 */
d1247 21
d1269 1
a1269 1
		return (EAFNOSUPPORT);
d1300 2
a1301 2
	bcopy(addrlo, enm->enm_addrlo, 6);
	bcopy(addrhi, enm->enm_addrhi, 6);
d1323 3
a1325 9
#ifdef INET
	struct sockaddr_in *sin;
#endif
#ifdef INET6
	struct sockaddr_in6 *sin6;
#endif /* INET6 */
	u_char addrlo[6];
	u_char addrhi[6];
	int s = splimp();
d1327 2
a1328 49
	switch (ifr->ifr_addr.sa_family) {

	case AF_UNSPEC:
		bcopy(ifr->ifr_addr.sa_data, addrlo, 6);
		bcopy(addrlo, addrhi, 6);
		break;

#ifdef INET
	case AF_INET:
		sin = (struct sockaddr_in *)&(ifr->ifr_addr);
		if (sin->sin_addr.s_addr == INADDR_ANY) {
			/*
			 * An IP address of INADDR_ANY means stop listening
			 * to the range of Ethernet multicast addresses used
			 * for IP.
			 */
			bcopy(ether_ipmulticast_min, addrlo, 6);
			bcopy(ether_ipmulticast_max, addrhi, 6);
		}
		else {
			ETHER_MAP_IP_MULTICAST(&sin->sin_addr, addrlo);
			bcopy(addrlo, addrhi, 6);
		}
		break;
#endif
#ifdef INET6
	case AF_INET6:
		sin6 = (struct sockaddr_in6 *)&(ifr->ifr_addr);
		if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
			/*
			 * An unspecified IPv6 address means stop listening to
			 * all IPv6 multicast addresses on this Ethernet.'
			 *
			 * (This might not be healthy, given IPv6's reliance on
			 * multicast for things like neighbor discovery.
			 * Perhaps initializing all-nodes, solicited nodes, and
			 * possibly all-routers for this interface afterwards
			 * is not a bad idea.)
			 */
			bcopy(ether_ip6multicast_min, addrlo, ETHER_ADDR_LEN);
			bcopy(ether_ip6multicast_max, addrhi, ETHER_ADDR_LEN);
		} else {
			ETHER_MAP_IPV6_MULTICAST(&sin6->sin6_addr, addrlo);
			bcopy(addrlo, addrhi, ETHER_ADDR_LEN);
		}
		break;
#endif /* INET6 */

	default:
d1330 1
a1330 1
		return (EAFNOSUPPORT);
@


1.62
log
@move ether_crc32_le to if_ethersubr.c.  Add ether_crc32_be
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.61 2002/02/07 23:20:57 art Exp $	*/
d648 4
d654 3
a656 4
		 * Ethernet and protocol header not in a single
		 * mbuf.  We can't cope with this situation right
		 * now (but it shouldn't ever happen, really, anyhow).
		 * XXX Should use m_pulldown().
@


1.61
log
@Quiet down an annoying message in altq_etherclassify.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.60 2001/12/09 13:09:13 jason Exp $	*/
d1088 74
@


1.60
log
@Use queue.h TAILQ macros instead of accessing members directly.
(And convert a few loops to TAILQ_FOREACH).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.59 2001/11/30 07:59:17 itojun Exp $	*/
d655 1
d658 1
@


1.60.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.60 2001/12/09 13:09:13 jason Exp $	*/
a647 4
	while (m->m_len <= hlen) {
		hlen -= m->m_len;
		m = m->m_next;
	}
d650 4
a653 3
		 * protocol header not in a single mbuf.
		 * We can't cope with this situation right now
		 * (but it shouldn't ever happen, really, anyhow).
a654 1
#ifdef DEBUG
a656 1
#endif
a1085 74
}

#if 0
/*
 * This is for reference.  We have a table-driven version
 * of the little-endian crc32 generator, which is faster
 * than the double-loop.
 */
u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
{
	u_int32_t c, crc, carry;
	size_t i, j;

	crc = 0xffffffffU;	/* initial value */

	for (i = 0; i < len; i++) {
		c = buf[i];
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x01) ? 1 : 0) ^ (c & 0x01);
			crc >>= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ ETHER_CRC_POLY_LE);
		}
	}

	return (crc);
}
#else
u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
{
	static const u_int32_t crctab[] = {
		0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
	};
	u_int32_t crc;
	int i;

	crc = 0xffffffffU;	/* initial value */

	for (i = 0; i < len; i++) {
		crc ^= buf[i];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
	}

	return (crc);
}
#endif

u_int32_t
ether_crc32_be(const u_int8_t *buf, size_t len)
{
	u_int32_t c, crc, carry;
	size_t i, j;

	crc = 0xffffffffU;	/* initial value */

	for (i = 0; i < len; i++) {
		c = buf[i];
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000U) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ ETHER_CRC_POLY_BE) | carry;
		}
	}

	return (crc);
@


1.60.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.60.2.1 2002/06/11 03:30:45 art Exp $	*/
d168 1
a168 1
u_char etherbroadcastaddr[ETHER_ADDR_LEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
d250 1
a250 1
 	u_char edst[ETHER_ADDR_LEN], esrc[ETHER_ADDR_LEN];
d305 1
a305 1
			return (0); /* it must be impossible, but... */
d442 1
a442 1
			for (i=0; i < ETHER_ADDR_LEN; i++)
d476 1
a476 1
			for (i=0; i < ETHER_ADDR_LEN; i++)
d938 1
a938 1
				if(m->m_len < ETHER_ADDR_LEN)
d957 1
a957 1
					    eh->ether_dhost, ETHER_ADDR_LEN);
d961 1
a961 1
				for (i = 0; i < ETHER_ADDR_LEN; i++) {
d981 1
a981 1
			    eh->ether_dhost, LLC_X25_LSAP, ETHER_ADDR_LEN,
d1020 1
a1020 1
	for (i = 0; i < ETHER_ADDR_LEN; i++) {
d1036 2
d1058 2
a1059 2
	ifp->if_addrlen = ETHER_ADDR_LEN;
	ifp->if_hdrlen = ETHER_HDR_LEN;
d1062 10
a1071 4

	if_alloc_sadl(ifp);
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	    LLADDR(ifp->if_sadl), ifp->if_addrlen);
a1090 2

	if_free_sadl(ifp);
d1167 2
a1168 6
#ifdef INET
u_char	ether_ipmulticast_min[ETHER_ADDR_LEN] =
    { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x00 };
u_char	ether_ipmulticast_max[ETHER_ADDR_LEN] =
    { 0x01, 0x00, 0x5e, 0x7f, 0xff, 0xff };
#endif
d1171 2
a1172 4
u_char	ether_ip6multicast_min[ETHER_ADDR_LEN] =
    { 0x33, 0x33, 0x00, 0x00, 0x00, 0x00 };
u_char	ether_ip6multicast_max[ETHER_ADDR_LEN] =
    { 0x33, 0x33, 0xff, 0xff, 0xff, 0xff };
d1176 2
a1177 2
 * Convert a sockaddr into an Ethernet address or range of Ethernet
 * addresses.
d1180 3
a1182 2
ether_multiaddr(struct sockaddr *sa, u_int8_t addrlo[ETHER_ADDR_LEN],
    u_int8_t addrhi[ETHER_ADDR_LEN])
d1184 1
d1187 1
a1187 1
#endif /* INET */
d1191 3
d1195 1
a1195 1
	switch (sa->sa_family) {
d1198 2
a1199 2
		bcopy(sa->sa_data, addrlo, ETHER_ADDR_LEN);
		bcopy(addrlo, addrhi, ETHER_ADDR_LEN);
d1204 1
a1204 1
		sin = satosin(sa);
d1207 2
a1208 3
			 * An IP address of INADDR_ANY means listen to
			 * or stop listening to all of the Ethernet
			 * multicast addresses used for IP.
d1211 4
a1214 3
			bcopy(ether_ipmulticast_min, addrlo, ETHER_ADDR_LEN);
			bcopy(ether_ipmulticast_max, addrhi, ETHER_ADDR_LEN);
		} else {
d1216 1
a1216 1
			bcopy(addrlo, addrhi, ETHER_ADDR_LEN);
d1222 2
a1223 1
		sin6 = satosin6(sa);
d1226 3
a1228 9
			 * An IP6 address of 0 means listen to or stop
			 * listening to all of the Ethernet multicast
			 * address used for IP6.
			 *
			 * (This might not be healthy, given IPv6's reliance on
			 * multicast for things like neighbor discovery.
			 * Perhaps initializing all-nodes, solicited nodes, and
			 * possibly all-routers for this interface afterwards
			 * is not a bad idea.)
a1229 1

d1237 1
a1237 1
#endif
d1240 1
a1242 22
	return (0);
}

/*
 * Add an Ethernet multicast address or range of addresses to the list for a
 * given interface.
 */
int
ether_addmulti(ifr, ac)
	struct ifreq *ifr;
	register struct arpcom *ac;
{
	register struct ether_multi *enm;
	u_char addrlo[ETHER_ADDR_LEN];
	u_char addrhi[ETHER_ADDR_LEN];
	int s = splimp(), error;

	error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	if (error != 0) {
		splx(s);
		return (error);
	}
d1272 2
a1273 2
	bcopy(addrlo, enm->enm_addrlo, ETHER_ADDR_LEN);
	bcopy(addrhi, enm->enm_addrhi, ETHER_ADDR_LEN);
d1295 57
a1351 3
	u_char addrlo[ETHER_ADDR_LEN];
	u_char addrhi[ETHER_ADDR_LEN];
	int s = splimp(), error;
d1353 1
a1353 2
	error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	if (error != 0) {
d1355 1
a1355 1
		return (error);
@


1.60.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d257 1
d284 6
d575 1
a575 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d595 93
d938 1
a938 1
				if (m->m_len < ETHER_ADDR_LEN)
@


1.59
log
@unifdef OLDIP6OUTPUT
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.58 2001/10/03 11:34:38 art Exp $	*/
d370 1
a370 1
			ifp->if_addrlist.tqh_first);
d725 1
a725 2
			for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
			    ifa = ifa->ifa_list.tqe_next)
d729 1
a729 1

@


1.58
log
@M_WAIT in ether_output is wrong. Fix APPLETALK stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.57 2001/09/20 18:55:55 deraadt Exp $	*/
a303 1
#ifndef OLDIP6OUTPUT
a305 4
#else
		if (!nd6_resolve(ifp, rt, m, dst, (u_char *)edst))
			return(0);	/* if not yet resolves */
#endif
@


1.57
log
@document why we use random()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.56 2001/09/20 16:07:21 peter Exp $	*/
d385 1
a385 1
		if ( aa->aa_flags & AFA_PHASE2 ) {
d388 3
a390 2
			/* XXX Really this should use netisr too */
			M_PREPEND(m, AT_LLC_SIZE, M_WAIT);
@


1.56
log
@the use of arc4random() in ether_ifattach() is wrong as randomattach()
has not yet been called at this point.

replace arc4random() with the more mundae random()&0xff as the use
of a strong PRNG is not need here, where this code just helps fix
up broken MAC addresses anyway

now to find the real problem with my sis(4) LAN interface...

ok'd by jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.55 2001/08/19 15:28:24 jason Exp $	*/
d1049 5
@


1.55
log
@compile w/out INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.54 2001/07/30 21:48:58 jason Exp $	*/
d1049 1
a1049 1
		((struct arpcom *)ifp)->ac_enaddr[5] = (u_char)arc4random();
@


1.54
log
@use queue.h macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.53 2001/07/25 03:28:19 jason Exp $	*/
d1106 1
d1108 1
d1216 1
d1218 1
@


1.53
log
@Initialization of arpcom * based on ifp was too soon: ifp can change as
a result of a call to bridge_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.52 2001/06/27 06:07:40 kjc Exp $	*/
d1057 1
a1057 2
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	    ifa = ifa->ifa_list.tqe_next)
d1066 1
d1080 2
a1081 1
	for (enm = LIST_FIRST(&ac->ac_multiaddrs); enm;
@


1.52
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.51 2001/06/24 22:34:04 fgsch Exp $	*/
d718 1
a718 1
	struct arpcom *ac = (struct arpcom *)ifp;
d785 2
@


1.51
log
@Use ETHER_IS_MULTICAST macro; jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.50 2001/06/23 22:52:51 fgsch Exp $	*/
d249 1
a249 1
	int s, error = 0, hdrcmplt = 0;
d256 2
d283 7
d572 2
d579 3
a581 2
	if (IF_QFULL(&ifp->if_snd)) {
		IF_DROP(&ifp->if_snd);
d583 1
a583 1
		senderr(ENOBUFS);
d585 2
a586 3
	ifp->if_obytes += m->m_pkthdr.len;
	IF_ENQUEUE(&ifp->if_snd, m);
	if (m->m_flags & M_MCAST)
d598 88
@


1.50
log
@Add ether_input_mbuf to help us remove the ether_header from
ether_input; all drivers should start migrating to this.
Discussed with jason@@, deraadt@@ more or les ok'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.49 2001/06/23 06:20:35 angelos Exp $	*/
d625 1
a625 1
	if (eh->ether_dhost[0] & 1) {
@


1.49
log
@Check for bridge loops.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.48 2001/06/23 04:01:18 aaron Exp $	*/
d586 16
@


1.48
log
@Use standard defined macros to access inner ifnet data structure members.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.47 2001/06/15 03:38:33 itojun Exp $	*/
d108 1
d500 1
d528 32
a559 2
		bridge_output(ifp, m, NULL, NULL);
		return (error);
@


1.47
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.46 2001/06/14 02:13:58 itojun Exp $	*/
d634 1
a634 1
			ifp->if_data.ifi_noproto++;
@


1.46
log
@drop multicast packet from myself, if the interface is !IFF_SIMPLEX.
sync with netbsd/kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.45 2001/05/28 19:51:06 dugsong Exp $	*/
a257 1
	ifp->if_lastchange = time;
a606 1
	ifp->if_lastchange = time;
@


1.45
log
@add BIOC[GS]HDRCMPLT ioctl for BPF, to disable overwriting of link level source address in forged frames. from NetBSD. art@@ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.44 2001/03/23 02:15:23 jason Exp $	*/
a577 2
	ifp->if_lastchange = time;
	ifp->if_ibytes += m->m_pkthdr.len + sizeof (*eh);
d579 21
d605 1
d607 3
a609 2
	if (m->m_flags & (M_BCAST|M_MCAST))
		ifp->if_imcasts++;
@


1.44
log
@move the vlan and bridge handling around a bit, and make sure the test
for (mcast || bcase || (unicast || for us)) is always called.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.43 2001/03/22 05:26:35 jason Exp $	*/
d248 2
a249 2
	int s, error = 0;
 	u_char edst[6];
d481 6
d514 6
a519 2
 	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
	    sizeof(eh->ether_shost));
@


1.44.2.1
log
@MFC:
Initialization of arpcom * based on ifp was too soon: ifp can change as
a result of a call to bridge_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.44 2001/03/23 02:15:23 jason Exp $	*/
d562 1
a562 1
	struct arpcom *ac;
a608 2

	ac = (struct arpcom *)ifp;
@


1.43
log
@remove vlan_proto variable, replace with ETHERTYPE_8021Q
define if_type for vlan interfaces (IFT_8021_VLAN)
#ifdef DEBUG some debugging printf's
protect against other uses of M_PROTO1
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.42 2001/02/20 19:39:27 mickey Exp $	*/
d580 2
d590 1
a590 1
		if (m->m_flags & M_PROTO1) {
d592 6
a597 1
			goto decapsulate;
a598 6
		m = bridge_input(ifp, eh, m);
		if (m == NULL)
			return;
		/* The bridge has determined it's for us. */
		ifp = m->m_pkthdr.rcvif;
		goto decapsulate;
d601 9
a623 10

	etype = ntohs(eh->ether_type);

#if NVLAN > 0
	if (etype == ETHERTYPE_8021Q) {
		if (vlan_input(eh, m) < 0)
			ifp->if_data.ifi_noproto++;
		return;
       }
#endif /* NVLAN > 0 */
@


1.42
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.41 2001/02/01 01:32:51 jason Exp $	*/
d618 1
a618 1
	if (etype == vlan_proto) {
@


1.41
log
@packets received on gif's for local processing can't just fall down the
stack, they have to be pushed; when calling ether_input():
1 - unicast packets have the ifp of the matching interface
2 - bcast/mcast packets have the ifp of the first IFT_ETHER bridge member
based on discussion with angelos.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.40 2000/12/12 03:41:22 jason Exp $	*/
d80 2
d109 4
d890 3
@


1.40
log
@Add support for 802.1D spanning tree protocol.
NOTE: this requires recompiling brconfig with updated include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.39 2000/10/18 16:16:33 jason Exp $	*/
d582 4
@


1.39
log
@use llc_snap instead of home grown macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.38 2000/09/07 04:48:58 deraadt Exp $	*/
d90 1
@


1.38
log
@if an interface comes up with a bad ethernet address, change it --
setting it to fe:e1:ba:d0:xx where xx is a random number.  this avoids
various network catastrophies, and also client machines will complain
everytime that server is rebooted...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.37 2000/06/02 15:44:56 jason Exp $	*/
a151 3
#define llc_snap_org_code llc_un.type_snap.org_code
#define llc_snap_ether_type llc_un.type_snap.ether_type

d381 1
a381 1
			bcopy(at_org_code, llc.llc_snap_org_code,
d383 1
a383 1
			llc.llc_snap_ether_type = htons( ETHERTYPE_AT );
d684 1
a684 1
			    Bcmp(&(l->llc_snap_org_code)[0],
d686 1
a686 1
			    ntohs(l->llc_snap_ether_type) == ETHERTYPE_AT) {
d695 1
a695 1
			    Bcmp(&(l->llc_snap_org_code)[0],
d697 1
a697 1
			    ntohs(l->llc_snap_ether_type) == ETHERTYPE_AARP) {
@


1.37
log
@vlan was consuming all vlan frames before they had a chance to be bridged.
Change the order of operations to be:
	ether_input() -> bridge_input() -> vlan_input()
Also, only process vlan frames that are unicast for us or bcast/mcast.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.36 2000/06/02 00:36:41 jason Exp $	*/
d853 13
@


1.36
log
@On input if the packet matches one of the member interface MAC addresses,
set the receiving interface to be that interface for further processing;
thanks to dorcula@@uncool.org for reporting and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.35 2000/04/26 19:03:11 chris Exp $	*/
a575 10
	etype = ntohs(eh->ether_type);

#if NVLAN > 0
	if (etype == vlan_proto) {
		if (vlan_input(eh, m) < 0)
			ifp->if_data.ifi_noproto++;
		return;
       }
#endif /* NVLAN > 0 */

d606 11
@


1.35
log
@if_vlan from FreeBSD and a few modifications
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.34 2000/02/07 06:09:08 itojun Exp $	*/
d598 1
@


1.34
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.33 2000/01/11 19:27:52 fgsch Exp $	*/
d111 5
d576 10
a614 1
	etype = ntohs(eh->ether_type);
@


1.34.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.44 2001/03/23 02:15:23 jason Exp $	*/
a79 2
#include "bpfilter.h"

a89 1
#include <sys/timeout.h>
a105 4
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

a110 5
#include "vlan.h"
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif /* NVLAN > 0 */

d147 3
d379 1
a379 1
			bcopy(at_org_code, llc.llc_snap.org_code,
d381 1
a381 1
			llc.llc_snap.ether_type = htons( ETHERTYPE_AT );
a570 2
	etype = ntohs(eh->ether_type);

d579 5
a583 9
		if (m->m_flags & M_PROTO1)
			m->m_flags &= ~M_PROTO1;
		else {
			m = bridge_input(ifp, eh, m);
			if (m == NULL)
				return;
			/* The bridge has determined it's for us. */
			ifp = m->m_pkthdr.rcvif;
		}
a585 9

#if NVLAN > 0
	if (etype == ETHERTYPE_8021Q) {
		if (vlan_input(eh, m) < 0)
			ifp->if_data.ifi_noproto++;
		return;
       }
#endif /* NVLAN > 0 */

d600 1
a600 1

d671 1
a671 1
			    Bcmp(&(l->llc_snap.org_code)[0],
d673 1
a673 1
			    ntohs(l->llc_snap.ether_type) == ETHERTYPE_AT) {
d682 1
a682 1
			    Bcmp(&(l->llc_snap.org_code)[0],
d684 1
a684 1
			    ntohs(l->llc_snap.ether_type) == ETHERTYPE_AARP) {
a836 13
	/*
	 * Any interface which provides a MAC address which is obviously
	 * invalid gets whacked, so that users will notice.
	 */
	if (ETHER_IS_MULTICAST(((struct arpcom *)ifp)->ac_enaddr)) {
		((struct arpcom *)ifp)->ac_enaddr[0] = 0x00;
		((struct arpcom *)ifp)->ac_enaddr[1] = 0xfe;
		((struct arpcom *)ifp)->ac_enaddr[2] = 0xe1;
		((struct arpcom *)ifp)->ac_enaddr[3] = 0xba;
		((struct arpcom *)ifp)->ac_enaddr[4] = 0xd0;
		((struct arpcom *)ifp)->ac_enaddr[5] = (u_char)arc4random();
	}
		
a852 3
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.34.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.34.2.1 2001/05/14 22:40:00 niklas Exp $	*/
a107 1
#include <netinet/ip_ipsp.h>
d248 2
a249 2
	int s, len, error = 0, hdrcmplt = 0;
 	u_char edst[6], esrc[6];
a254 2
	short mflags;
	ALTQ_DECL(struct altq_pktattr pktattr;)
d258 1
a280 7

	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

a480 6
	case pseudo_AF_HDRCMPLT:
		hdrcmplt = 1;
		eh = (struct ether_header *)dst->sa_data;
		bcopy((caddr_t)eh->ether_shost, (caddr_t)esrc, sizeof (esrc));
		/* FALLTHROUGH */

a493 1
	/* XXX Should we feed-back an unencrypted IPsec packet ? */
d508 2
a509 6
	if (hdrcmplt)
	 	bcopy((caddr_t)esrc, (caddr_t)eh->ether_shost,
		    sizeof(eh->ether_shost));
	else
	 	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
		    sizeof(eh->ether_shost));
d517 2
a518 32
		struct m_tag *mtag;

		/*
		 * Check if this packet has already been sent out through
		 * this bridge, in which case we simply send it out
		 * without further bridge processing.
		 */
		for (mtag = m_tag_find(m, PACKET_TAG_BRIDGE, NULL); mtag;
		    mtag = m_tag_find(m, PACKET_TAG_BRIDGE, mtag)) {
#ifdef DEBUG
			/* Check that the information is there */
			if (mtag->m_tag_len != sizeof(caddr_t)) {
				error = EINVAL;
				goto bad;
			}
#endif
			if (!bcmp(&ifp->if_bridge, mtag + 1, sizeof(caddr_t)))
				break;
		}
		if (mtag == NULL) {
			/* Attach a tag so we can detect loops */
			mtag = m_tag_get(PACKET_TAG_BRIDGE, sizeof(caddr_t),
			    M_NOWAIT);
			if (mtag == NULL) {
				error = ENOBUFS;
				goto bad;
			}
			bcopy(&ifp->if_bridge, mtag + 1, sizeof(caddr_t));
			m_tag_prepend(m, mtag);
			bridge_output(ifp, m, NULL, NULL);
			return (error);
		}
a521 2
	mflags = m->m_flags;
	len = m->m_pkthdr.len;
d527 2
a528 3
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		/* mbuf is already freed */
d530 1
a530 1
		return (error);
d532 3
a534 2
	ifp->if_obytes += len + sizeof (struct ether_header);
	if (mflags & M_MCAST)
a546 104
#ifdef ALTQ
/*
 * This routine is a slight hack to allow a packet to be classified
 * if the Ethernet headers are present.  It will go away when ALTQ's
 * classification engine understands link headers.
 */
void
altq_etherclassify(struct ifaltq *ifq, struct mbuf *m,
    struct altq_pktattr *pktattr)
{
	struct ether_header *eh;
	u_int16_t ether_type;
	int hlen, af, hdrsize;
	caddr_t hdr;

	hlen = ETHER_HDR_LEN;
	eh = mtod(m, struct ether_header *);

	ether_type = htons(eh->ether_type);

	if (ether_type < ETHERMTU) {
		/* LLC/SNAP */
		struct llc *llc = (struct llc *)(eh + 1);
		hlen += 8;

		if (m->m_len < hlen ||
		    llc->llc_dsap != LLC_SNAP_LSAP ||
		    llc->llc_ssap != LLC_SNAP_LSAP ||
		    llc->llc_control != LLC_UI) {
			/* Not SNAP. */
			goto bad;
		}

		ether_type = htons(llc->llc_un.type_snap.ether_type);
	}

	switch (ether_type) {
	case ETHERTYPE_IP:
		af = AF_INET;
		hdrsize = 20;		/* sizeof(struct ip) */
		break;

	case ETHERTYPE_IPV6:
		af = AF_INET6;
		hdrsize = 40;		/* sizeof(struct ip6_hdr) */
		break;

	default:
		af = AF_UNSPEC;
		hdrsize = 0;
		break;
	}

	if (m->m_len < (hlen + hdrsize)) {
		/*
		 * Ethernet and protocol header not in a single
		 * mbuf.  We can't cope with this situation right
		 * now (but it shouldn't ever happen, really, anyhow).
		 * XXX Should use m_pulldown().
		 */
		printf("altq_etherclassify: headers span multiple mbufs: "
		    "%d < %d\n", m->m_len, (hlen + hdrsize));
		goto bad;
	}

	m->m_data += hlen;
	m->m_len -= hlen;

	hdr = mtod(m, caddr_t);

	if (ALTQ_NEEDS_CLASSIFY(ifq))
		pktattr->pattr_class =
		    (*ifq->altq_classify)(ifq->altq_clfier, m, af);
	pktattr->pattr_af = af;
	pktattr->pattr_hdr = hdr;

	m->m_data -= hlen;
	m->m_len += hlen;

	return;

 bad:
	pktattr->pattr_class = NULL;
	pktattr->pattr_hdr = NULL;
	pktattr->pattr_af = AF_UNSPEC;
}
#endif /* ALTQ */

/*
 * Temporary function to migrate while
 * removing ether_header * from ether_input().
 */
void
ether_input_mbuf(ifp, m)
	struct ifnet *ifp;
	struct mbuf *m;
{
	struct ether_header *eh;

	eh = mtod(m, struct ether_header *);
	m_adj(m, ETHER_HDR_LEN);
	ether_input(ifp, eh, m);
}

d568 3
a570 22
	if (ETHER_IS_MULTICAST(eh->ether_dhost)) {
		if ((ifp->if_flags & IFF_SIMPLEX) == 0) {
			struct ifaddr *ifa;
			struct sockaddr_dl *sdl = NULL;

			for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
			    ifa = ifa->ifa_list.tqe_next)
				if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
				    sdl->sdl_family == AF_LINK)
					break;

			/*
			 * If this is not a simplex interface, drop the packet
			 * if it came from us.
			 */
			if (sdl && bcmp(LLADDR(sdl), eh->ether_shost,
			    ETHER_ADDR_LEN) == 0) {
				m_freem(m);
				return;
			}
		}

d576 2
a578 3
	}

	ifp->if_ibytes += m->m_pkthdr.len + sizeof (*eh);
d605 1
a605 1
			ifp->if_noproto++;
@


1.34.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.34.2.2 2001/07/04 10:53:59 niklas Exp $	*/
d385 1
a385 1
		if (aa->aa_flags & AFA_PHASE2) {
d388 2
a389 3
			M_PREPEND(m, AT_LLC_SIZE, M_DONTWAIT);
			if (m == NULL)
				return (0);
d718 1
a718 1
	struct arpcom *ac;
a785 2
	ac = (struct arpcom *)ifp;

d1047 1
a1047 6
		/*
		 * XXX use of random() by anything except the scheduler is
		 * normally invalid, but this is boot time, so pre-scheduler,
		 * and the random subsystem is not alive yet
		 */
		((struct arpcom *)ifp)->ac_enaddr[5] = (u_char)random() & 0xff;
d1055 2
a1056 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a1064 1
	}
d1078 1
a1078 2
	for (enm = LIST_FIRST(&ac->ac_multiaddrs);
	    enm != LIST_END(&ac->ac_multiaddrs);
a1102 1
#ifdef INET
a1103 1
#endif
a1210 1
#ifdef INET
a1211 1
#endif
@


1.34.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d304 1
d307 4
@


1.34.2.5
log
@Merge in trunk
@
text
@d370 1
a370 1
			TAILQ_FIRST(&ifp->if_addrlist));
a654 1
#ifdef DEBUG
a656 1
#endif
d725 2
a726 1
			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
d730 1
a730 1
			}
@


1.34.2.6
log
@Sync the SMP branch with 3.3
@
text
@d168 1
a168 1
u_char etherbroadcastaddr[ETHER_ADDR_LEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
d250 1
a250 1
 	u_char edst[ETHER_ADDR_LEN], esrc[ETHER_ADDR_LEN];
d257 1
d284 6
d305 1
a305 1
			return (0); /* it must be impossible, but... */
d442 1
a442 1
			for (i=0; i < ETHER_ADDR_LEN; i++)
d476 1
a476 1
			for (i=0; i < ETHER_ADDR_LEN; i++)
d575 1
a575 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d595 90
d935 1
a935 1
				if (m->m_len < ETHER_ADDR_LEN)
d954 1
a954 1
					    eh->ether_dhost, ETHER_ADDR_LEN);
d958 1
a958 1
				for (i = 0; i < ETHER_ADDR_LEN; i++) {
d978 1
a978 1
			    eh->ether_dhost, LLC_X25_LSAP, ETHER_ADDR_LEN,
d1017 1
a1017 1
	for (i = 0; i < ETHER_ADDR_LEN; i++) {
d1033 2
d1055 2
a1056 2
	ifp->if_addrlen = ETHER_ADDR_LEN;
	ifp->if_hdrlen = ETHER_HDR_LEN;
d1059 10
a1068 4

	if_alloc_sadl(ifp);
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	    LLADDR(ifp->if_sadl), ifp->if_addrlen);
a1087 53

	if_free_sadl(ifp);
}

#if 0
/*
 * This is for reference.  We have a table-driven version
 * of the little-endian crc32 generator, which is faster
 * than the double-loop.
 */
u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
{
	u_int32_t c, crc, carry;
	size_t i, j;

	crc = 0xffffffffU;	/* initial value */

	for (i = 0; i < len; i++) {
		c = buf[i];
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x01) ? 1 : 0) ^ (c & 0x01);
			crc >>= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ ETHER_CRC_POLY_LE);
		}
	}

	return (crc);
}
#else
u_int32_t
ether_crc32_le(const u_int8_t *buf, size_t len)
{
	static const u_int32_t crctab[] = {
		0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
	};
	u_int32_t crc;
	int i;

	crc = 0xffffffffU;	/* initial value */

	for (i = 0; i < len; i++) {
		crc ^= buf[i];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
		crc = (crc >> 4) ^ crctab[crc & 0xf];
	}

	return (crc);
a1088 7
#endif

u_int32_t
ether_crc32_be(const u_int8_t *buf, size_t len)
{
	u_int32_t c, crc, carry;
	size_t i, j;
d1090 2
a1091 22
	crc = 0xffffffffU;	/* initial value */

	for (i = 0; i < len; i++) {
		c = buf[i];
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000U) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ ETHER_CRC_POLY_BE) | carry;
		}
	}

	return (crc);
}

#ifdef INET
u_char	ether_ipmulticast_min[ETHER_ADDR_LEN] =
    { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x00 };
u_char	ether_ipmulticast_max[ETHER_ADDR_LEN] =
    { 0x01, 0x00, 0x5e, 0x7f, 0xff, 0xff };
#endif
d1094 2
a1095 4
u_char	ether_ip6multicast_min[ETHER_ADDR_LEN] =
    { 0x33, 0x33, 0x00, 0x00, 0x00, 0x00 };
u_char	ether_ip6multicast_max[ETHER_ADDR_LEN] =
    { 0x33, 0x33, 0xff, 0xff, 0xff, 0xff };
d1099 2
a1100 2
 * Convert a sockaddr into an Ethernet address or range of Ethernet
 * addresses.
d1103 3
a1105 2
ether_multiaddr(struct sockaddr *sa, u_int8_t addrlo[ETHER_ADDR_LEN],
    u_int8_t addrhi[ETHER_ADDR_LEN])
d1107 1
d1110 1
a1110 1
#endif /* INET */
d1114 3
d1118 1
a1118 1
	switch (sa->sa_family) {
d1121 2
a1122 2
		bcopy(sa->sa_data, addrlo, ETHER_ADDR_LEN);
		bcopy(addrlo, addrhi, ETHER_ADDR_LEN);
d1127 1
a1127 1
		sin = satosin(sa);
d1130 2
a1131 3
			 * An IP address of INADDR_ANY means listen to
			 * or stop listening to all of the Ethernet
			 * multicast addresses used for IP.
d1134 4
a1137 3
			bcopy(ether_ipmulticast_min, addrlo, ETHER_ADDR_LEN);
			bcopy(ether_ipmulticast_max, addrhi, ETHER_ADDR_LEN);
		} else {
d1139 1
a1139 1
			bcopy(addrlo, addrhi, ETHER_ADDR_LEN);
d1145 2
a1146 1
		sin6 = satosin6(sa);
d1149 3
a1151 9
			 * An IP6 address of 0 means listen to or stop
			 * listening to all of the Ethernet multicast
			 * address used for IP6.
			 *
			 * (This might not be healthy, given IPv6's reliance on
			 * multicast for things like neighbor discovery.
			 * Perhaps initializing all-nodes, solicited nodes, and
			 * possibly all-routers for this interface afterwards
			 * is not a bad idea.)
a1152 1

d1160 1
a1160 1
#endif
d1163 1
a1165 22
	return (0);
}

/*
 * Add an Ethernet multicast address or range of addresses to the list for a
 * given interface.
 */
int
ether_addmulti(ifr, ac)
	struct ifreq *ifr;
	register struct arpcom *ac;
{
	register struct ether_multi *enm;
	u_char addrlo[ETHER_ADDR_LEN];
	u_char addrhi[ETHER_ADDR_LEN];
	int s = splimp(), error;

	error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	if (error != 0) {
		splx(s);
		return (error);
	}
d1195 2
a1196 2
	bcopy(addrlo, enm->enm_addrlo, ETHER_ADDR_LEN);
	bcopy(addrhi, enm->enm_addrhi, ETHER_ADDR_LEN);
d1218 11
a1228 3
	u_char addrlo[ETHER_ADDR_LEN];
	u_char addrhi[ETHER_ADDR_LEN];
	int s = splimp(), error;
d1230 47
a1276 2
	error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	if (error != 0) {
d1278 1
a1278 1
		return (error);
@


1.34.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.34.2.6 2003/03/28 00:41:28 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.34.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a119 5
#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

d170 1
a170 1
	struct ifnet *ifp;
d239 1
a239 1
	struct ifnet *ifp;
d247 2
a248 2
	struct mbuf *m = m0;
	struct rtentry *rt;
d250 1
a250 1
	struct ether_header *eh;
d286 1
a286 2
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    m_tag_find(m, PACKET_TAG_PF_ROUTED, NULL) == NULL)
d396 1
a396 1
		struct sockaddr_dl *sdl;
d440 1
a440 1
		struct sockaddr_dl *sdl =
d462 1
a462 1
			struct llc *l = mtod(m, struct llc *);
a556 9
#if NCARP > 0
	if (ifp->if_carp) {
		int error;
		error = carp_output(ifp, m, dst, NULL);
		if (error)
			goto bad;
	}
#endif

d608 1
a608 1
	struct ether_header *eh;
d611 1
a611 1
	struct ifqueue *inq;
d614 1
a614 1
	struct llc *l;
a681 6
#if NCARP > 0
	if (ifp->if_carp &&
	    carp_forus(ifp->if_carp, eh->ether_dhost))
		goto decapsulate;
#endif /* NCARP > 0 */

d845 1
a845 1
				struct ether_header *eh2;
d910 1
a910 1
	u_char *ap;
d912 1
a912 1
	int i;
d914 1
a914 1
	char *cp = etherbuf;
d930 1
a930 1
	struct ifnet *ifp;
a979 2
#if 0
	/* moved to if_detach() */
a980 1
#endif
d1149 1
a1149 1
	struct arpcom *ac;
d1151 1
a1151 1
	struct ether_multi *enm;
d1210 1
a1210 1
	struct arpcom *ac;
d1212 1
a1212 1
	struct ether_multi *enm;
@


1.34.2.9
log
@Merge with the trunk
@
text
@d917 5
a921 1
	IF_INPUT_ENQUEUE(inq, m);
d934 1
a934 1
	static char etherbuf[ETHER_ADDR_LEN * 3];
@


1.33
log
@Remove unneeded loout call that uses ipx_thishost.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.32 1999/12/08 06:50:17 itojun Exp $	*/
a156 5

#if 0	/*NRL INET6*/
#include <netinet6/in6.h>
#include <netinet6/in6_var.h>
#endif /* INET6 */
@


1.32
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.31 1999/09/01 21:38:48 jason Exp $	*/
a317 2
		if (!bcmp((caddr_t)edst, (caddr_t)&ipx_thishost, sizeof(edst)))
			return (looutput(ifp, m, dst, rt));
@


1.31
log
@o simpler handling of "forme" packets
o when ~IFF_UP, don't act like a bridge for output either
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.30 1999/08/08 02:42:58 niklas Exp $	*/
d5 29
d111 8
d158 1
a158 1
#ifdef INET6
d289 12
d325 1
a325 1
#ifdef INET6
d337 1
a337 1
			ETHER_MAP_IN6_MULTICAST(((struct sockaddr_in6 *)dst)->sin6_addr,
d635 1
a635 1
		inq = &ipv6intrq;
d880 3
a882 3
u_char	ether_ipv6multicast_min[6] = { 0x33, 0x33, 0x00, 0x00, 0x00, 0x00 };
u_char	ether_ipv6multicast_max[6] = { 0x33, 0x33, 0xff, 0xff, 0xff, 0xff };
#endif /* INET6 */
d929 2
a930 1
		sin6 = (struct sockaddr_in6 *)&(ifr->ifr_addr);
d937 2
a938 2
			bcopy(ether_ipv6multicast_min, addrlo, ETHER_ADDR_LEN);
			bcopy(ether_ipv6multicast_max, addrhi, ETHER_ADDR_LEN);
d940 1
a940 1
			ETHER_MAP_IN6_MULTICAST(sin6->sin6_addr, addrlo);
d1049 2
a1050 2
			bcopy(ether_ipv6multicast_min, addrlo, ETHER_ADDR_LEN);
			bcopy(ether_ipv6multicast_max, addrhi, ETHER_ADDR_LEN);
d1052 1
a1052 1
			ETHER_MAP_IN6_MULTICAST(sin6->sin6_addr, addrlo);
@


1.30
log
@Fix cases when wanting to communicate with the bridge'
s remote interfaces, both ARP and local delivery had bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.29 1999/08/08 00:43:00 niklas Exp $	*/
d509 1
a509 1
	int s, llcfound = 0, forme = 0;
d537 1
a537 1
		m = bridge_input(ifp, eh, m, &forme);
d540 2
d548 1
a548 1
	if (!forme && (m->m_flags & (M_BCAST|M_MCAST)) == 0 &&
@


1.29
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.28 1999/02/26 17:01:32 jason Exp $	*/
d509 1
a509 1
	int s, llcfound = 0;
d537 1
a537 1
		m = bridge_input(ifp, eh, m);
d546 1
a546 1
	if ((m->m_flags & (M_BCAST|M_MCAST)) == 0 &&
@


1.28
log
@Ethernet bridge/IP firewall driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.27 1999/01/08 00:56:45 deraadt Exp $	*/
d809 14
@


1.27
log
@inet6 support; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.26 1998/07/07 19:26:18 ryker Exp $	*/
d77 5
d459 12
a510 1
#if defined(ISO)
a511 1
#endif
d528 26
@


1.26
log
@htons(ETHERTYPE_IPX)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.25 1998/02/03 19:06:28 deraadt Exp $	*/
d39 12
d116 5
d153 1
a153 1
					*(union ipx_host *)(arp->ac_enaddr);
d155 2
a156 2
				bcopy (ina->ipx_host.c_host,
				       arp->ac_enaddr, sizeof(arp->ac_enaddr));
d173 1
a173 1
					*(union ns_host *)(arp->ac_enaddr);
d176 1
a176 1
				      arp->ac_enaddr, sizeof(arp->ac_enaddr));
d217 1
a217 1
			else 
d271 22
d365 3
a367 4
				bcopy((caddr_t)edst,
				      (caddr_t)eh->ether_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)eh->ether_shost, sizeof (edst));
d390 1
a390 1
		register struct sockaddr_dl *sdl = 
d403 3
a405 4
				bcopy((caddr_t)edst,
				      (caddr_t)eh->ether_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)eh->ether_shost, sizeof (edst));
d417 1
a417 1
			printf(" len 0x%x dsap 0x%x ssap 0x%x control 0x%x\n", 
d537 9
d623 1
a623 1
		case LLC_ISO_LSAP: 
d648 1
a648 1
				
d669 2
a670 2
					bcopy((caddr_t)ac->ac_enaddr,
					      (caddr_t)eh->ether_dhost, 6);
d676 1
a676 1
					eh2->ether_dhost[i] = 
d764 1
a764 1
			      LLADDR(sdl), ifp->if_addrlen);
d772 6
d789 3
d821 17
d896 3
d928 22
@


1.25
log
@bad types; wileyc@@sekiya.twics.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.24 1997/09/27 02:35:57 deraadt Exp $	*/
d244 1
a244 1
		etype = ETHERTYPE_IPX;
@


1.24
log
@undo previous AF_UNSPEC change. analyze two alternatives: AF_SOMETHINGNEW,
or how much work it would be fix everything that uses AF_UNSPEC.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.22 1997/07/24 22:59:29 deraadt Exp $	*/
d683 1
a683 1
	register i;
@


1.23
log
@for AF_UNSPEC sockets, do not whack the ethernet address; this is what bpf
uses when it sends packets out. blame tqbf@@rdist.org for this fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.21 1997/07/23 20:37:19 mickey Exp $	*/
d186 1
a186 1
	u_char edst[6], esrc[6];
d233 1
a233 1
		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
d245 1
a245 1
		bcopy((caddr_t)&satosipx(dst)->sipx_addr.ipx_host,
d390 1
a390 2
		bcopy((caddr_t)eh->ether_dhost, (caddr_t)edst, sizeof (edst));
		bcopy((caddr_t)eh->ether_shost, (caddr_t)esrc, sizeof (esrc));
d414 3
a416 7
	bcopy((caddr_t)edst, (caddr_t)eh->ether_dhost, sizeof (edst));
	if (dst->sa_family == AF_UNSPEC)
		bcopy((caddr_t)esrc, (caddr_t)eh->ether_shost,
		    sizeof(eh->ether_shost));
	else
		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
		    sizeof(eh->ether_shost));
@


1.22
log
@do not ignore IFF_NOARP
@
text
@d186 1
a186 1
 	u_char edst[6];
d233 1
a233 1
 		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
d245 1
a245 1
 		bcopy((caddr_t)&satosipx(dst)->sipx_addr.ipx_host,
d390 2
a391 1
 		bcopy((caddr_t)eh->ether_dhost, (caddr_t)edst, sizeof (edst));
d415 7
a421 3
 	bcopy((caddr_t)edst, (caddr_t)eh->ether_dhost, sizeof (edst));
 	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)eh->ether_shost,
	    sizeof(eh->ether_shost));
@


1.21
log
@define ETHERTYPE_IPX
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.20 1997/07/23 20:20:10 mickey Exp $	*/
d487 2
d494 2
@


1.20
log
@make it compile w/o NETATALK defined
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.19 1997/07/23 16:13:26 denny Exp $	*/
a92 1
/* Should we include <netatalk/phase2.h> here instead? */
a99 1

d244 1
a244 1
		etype = htons(satosipx(dst)->sipx_type);
d497 1
a497 1
	case ETHERTYPE_II:
a533 1
#ifdef NETATALK
d544 1
a544 1
#endif /* NETATALK */
d555 1
a555 1
#endif
@


1.19
log
@A block of code from the last commit was not #ifdef NETATALK.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.18 1997/07/23 03:46:01 denny Exp $	*/
d528 1
d547 1
a547 1

@


1.18
log
@AppleTalk support based on netatalk-1.4a2 and FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.17 1997/01/26 21:43:36 tholo Exp $	*/
d535 1
d557 1
a557 1

@


1.17
log
@Don't examine an mbuf after it has been released; from Andreas Gunnarsson
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.16 1997/01/02 20:45:49 deraadt Exp $	*/
d88 14
d145 5
d256 49
d510 11
d528 29
@


1.16
log
@accept llc/snap packets; still cannot send them...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.15 1996/12/19 12:58:14 mickey Exp $	*/
d363 2
a367 2
	if (m->m_flags & M_MCAST)
		ifp->if_omcasts++;
@


1.15
log
@do SIOCGIFADDR
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.14 1996/12/19 10:59:21 mickey Exp $	*/
a81 1
#ifdef LLC
a86 1
#endif
d88 1
a88 1
#if defined(LLC) && defined(CCITT)
a103 1
	struct ifreq *ifr = (struct ifreq *) data;
d108 1
a108 1
#if	defined(CCITT) && defined(LLC)
d114 1
a114 1
#endif /* CCITT && LLC */
a147 7

	case SIOCGIFADDR:
		bcopy((caddr_t) arp->ac_enaddr,
		      (caddr_t) ((struct sockaddr *)&ifr->ifr_data)->sa_data,
		      ETHER_ADDR_LEN);
		break;

a283 1
#ifdef	LLC
a320 1
#endif /* LLC */	
d389 1
a389 2
	int s;
#if defined (ISO) || defined (LLC)
d391 1
d411 1
d428 1
d443 1
a443 2
#if defined (ISO) || defined (LLC)
		if (etype > ETHERMTU)
d445 1
d448 17
d526 1
a526 3
			default:
				m_freem(m);
				return;
a527 1
			break;
d529 1
a529 1
#ifdef LLC
a530 1
		{
d536 3
a538 3
			if ( !sdl_sethdrif(ifp, eh->ether_shost, LLC_X25_LSAP,
					    eh->ether_dhost, LLC_X25_LSAP, 6, 
					    mtod(m, struct sdl_hdr *)))
d542 1
a542 1
				printf("llc packet\n");
d547 1
a547 2
		}
#endif /* LLC */
a552 4
#else /* ISO || LLC */
	    m_freem(m);
	    return;
#endif /* ISO || LLC */
@


1.14
log
@treat only ether II type packets for ipx.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.13 1996/06/02 16:31:01 niklas Exp $	*/
d106 1
d150 6
@


1.13
log
@removed an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.4 1996/04/19 18:12:28 mickey Exp $	*/
a433 4
	case ETHERTYPE_8022:
	case ETHERTYPE_8022TR:
	case ETHERTYPE_8023:
	case ETHERTYPE_SNAP:
@


1.12
log
@if_name/if_unit -> if_xname/if_softc
@
text
@a105 1
	struct ifreq *ifr = (struct ifreq *)data;
@


1.11
log
@fix includes for x25/llc.
@
text
@d2 1
a2 1
/*	$NetBSD: if_ethersubr.c,v 1.18 1996/02/13 22:00:14 christos Exp $	*/
d336 1
a336 1
		printf("%s%d: can't handle af%d\n", ifp->if_name, ifp->if_unit,
@


1.10
log
@if.h was missed from the commit.
if_ethersubr.c: missed variables added.
@
text
@d83 3
a91 1
#include <netccitt/x25.h>
@


1.9
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d105 1
d153 2
a154 1
	return 0;
@


1.8
log
@pretty
@
text
@d88 2
a89 1
extern struct ifqueue pkintrq;
d95 60
d227 2
a228 2
		etype = htons(ETHERTYPE_IPX);
 		bcopy((caddr_t)&(((struct sockaddr_ipx *)dst)->sipx_addr.ipx_host),
d431 5
a435 1
	case ETHERTYPE_IPX:
@


1.7
log
@fix last fix that was unfix for the before previous fix.
that is, redundant ).
@
text
@d194 2
a195 2
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX)
		    && (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
@


1.6
log
@fix the wrong changes, so the bcasts will work now ;)
@
text
@d194 1
a194 1
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
@


1.5
log
@IPX additions and fixes.
ether -- missed the input for IPX.
fddi -- just added.
ppp -- field codes added.
loop -- minor fix.
@
text
@d147 1
a147 1
		if (m->m_flags & (M_BCAST|IFF_SIMPLEX) == (M_BCAST|IFF_SIMPLEX))
d160 1
a160 1
		if (m->m_flags & (M_BCAST|IFF_SIMPLEX) == (M_BCAST|IFF_SIMPLEX))
d172 1
a172 1
		if (m->m_flags & (M_BCAST|IFF_SIMPLEX) == (M_BCAST|IFF_SIMPLEX))
d194 1
a194 1
		if((m->m_flags & (M_BCAST|IFF_SIMPLEX)) == (M_BCAST|IFF_SIMPLEX)
@


1.4
log
@According to the latest config stuff changes (as for if_ppp.c).
the other stuff is just for IPX support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ethersubr.c,v 1.3 1996/03/03 21:07:07 niklas Exp $	*/
d369 6
a379 1

@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 5
d147 1
a147 1
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
d160 13
a172 1
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
d194 2
a195 2
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
@


1.2
log
@from netbsd; Avoid extra byte-swapping in average cases
@
text
@d1 2
a2 1
/*	$NetBSD: if_ethersubr.c,v 1.17 1995/12/24 03:33:43 mycroft Exp $	*/
d113 1
a113 1
	if (rt = rt0) {
d115 1
a115 1
			if (rt0 = rt = rtalloc1(dst, 1))
d168 6
a173 4
		} else if (error =
			    iso_snparesolve(ifp, (struct sockaddr_iso *)dst,
					    (char *)edst, &snpalen))
			goto bad; /* Not Resolved */
d195 2
a196 1
		IFDEBUG(D_ETHER)
d202 2
a203 1
		ENDDEBUG
d312 3
a315 1
	u_int16_t etype;
d317 1
a317 1
	int s;
d382 2
a383 1
					IFDEBUG(D_ETHER)
d385 1
a385 1
					ENDDEBUG
a620 1
	register struct ether_multi **p;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_ethersubr.c,v 1.15 1995/09/29 03:37:43 phil Exp $	*/
a90 2
 * Use trailer local net encapsulation if enough data in first
 * packet leaves a multiple of 512 bytes of data in remainder.
d143 1
a143 1
		etype = ETHERTYPE_IP;
d148 1
a148 1
		etype = ETHERTYPE_NS;
d188 1
a188 1
		etype = m->m_pkthdr.len;
d223 1
a223 1
		etype = m->m_pkthdr.len;
d233 2
a234 2
			       etype & 0xff, l->llc_dsap & 0xff, l->llc_ssap &0xff,
			       l->llc_control & 0xff);
d245 1
a245 1
		etype = ntohs(eh->ether_type);
a253 1

d256 1
a264 1
	etype = htons(etype);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
