head	1.20;
access;
symbols
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.2.0.4
	OPENBSD_5_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2017.03.02.03.09.50;	author renato;	state Exp;
branches;
next	1.19;
commitid	15KE7F69zvHLMIyM;

1.19
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.18;
commitid	6c6qq5OdS4VVnyVM;

1.18
date	2017.01.24.03.57.35;	author dlg;	state Exp;
branches;
next	1.17;
commitid	PERtGPXCvlLRRBr8;

1.17
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.16;
commitid	F6oNrr9LCLUSAxgA;

1.16
date	2016.12.20.12.18.44;	author mpi;	state Exp;
branches;
next	1.15;
commitid	NBiVrSI027L6H6zm;

1.15
date	2016.09.21.07.41.49;	author mpi;	state Exp;
branches;
next	1.14;
commitid	W19auu7eqXTbl8XK;

1.14
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.13;
commitid	Xo6g1xk26RWDGcjJ;

1.13
date	2016.03.09.04.19.43;	author dlg;	state Exp;
branches;
next	1.12;
commitid	7BTbcLCC55GnWMwi;

1.12
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.11;
commitid	ILbVM1M3uPNjwswz;

1.11
date	2015.12.02.13.29.25;	author claudio;	state Exp;
branches;
next	1.10;
commitid	Hf3C2AvfIXmCAmHE;

1.10
date	2015.11.06.11.45.04;	author mpi;	state Exp;
branches;
next	1.9;
commitid	4kzpH4Y5VxalqIOD;

1.9
date	2015.11.03.11.51.07;	author dlg;	state Exp;
branches;
next	1.8;
commitid	dRCNegsey33VRNKU;

1.8
date	2015.10.22.17.48.34;	author mpi;	state Exp;
branches;
next	1.7;
commitid	ToMJCJHoIWfUEPhu;

1.7
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	tp9bS9eCrwvRYjyO;

1.6
date	2015.09.12.20.50.17;	author mpi;	state Exp;
branches;
next	1.5;
commitid	L7FukNYlBzoQuXvw;

1.5
date	2015.09.10.16.41.30;	author mikeb;	state Exp;
branches;
next	1.4;
commitid	Dj2db8t0KelqURhl;

1.4
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.3;
commitid	JbEzJsyDrWqOW57C;

1.3
date	2015.09.09.20.13.20;	author dlg;	state Exp;
branches;
next	1.2;
commitid	Bt5i72IR94yfZ5c4;

1.2
date	2015.07.21.04.58.52;	author rzalamena;	state Exp;
branches;
next	1.1;
commitid	tazkVU3O5M6TD0Tt;

1.1
date	2015.07.20.22.16.41;	author rzalamena;	state Exp;
branches;
next	;
commitid	yaHvJbufOxtjWSFd;


desc
@@


1.20
log
@Allow MPLS switching and VPLS across rdomains.

OK claudio@@ mpi@@
@
text
@/*	$OpenBSD: if_mpw.c,v 1.19 2017/01/24 10:08:30 krw Exp $ */

/*
 * Copyright (c) 2015 Rafael Zalamena <rzalamena@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>

#include <netinet/if_ether.h>
#include <netmpls/mpls.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif /* NBPFILTER */

#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

struct mpw_softc {
	struct		ifnet sc_if;

	struct		ifaddr sc_ifa;
	struct		sockaddr_mpls sc_smpls; /* Local label */

	uint32_t	sc_flags;
	uint32_t	sc_type;
	struct		shim_hdr sc_rshim;
	struct		sockaddr_storage sc_nexthop;
};

void	mpwattach(int);
int	mpw_clone_create(struct if_clone *, int);
int	mpw_clone_destroy(struct ifnet *);
int	mpw_ioctl(struct ifnet *, u_long, caddr_t);
int	mpw_output(struct ifnet *, struct mbuf *, struct sockaddr *,
    struct rtentry *);
void	mpw_start(struct ifnet *);
int	mpw_input(struct ifnet *, struct mbuf *, void *);
#if NVLAN > 0
struct	mbuf *mpw_vlan_handle(struct mbuf *, struct mpw_softc *);
#endif /* NVLAN */

struct if_clone mpw_cloner =
    IF_CLONE_INITIALIZER("mpw", mpw_clone_create, mpw_clone_destroy);

void
mpwattach(int n)
{
	if_clone_attach(&mpw_cloner);
}

int
mpw_clone_create(struct if_clone *ifc, int unit)
{
	struct mpw_softc *sc;
	struct ifnet *ifp;

	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc == NULL)
		return (ENOMEM);

	ifp = &sc->sc_if;
	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "mpw%d", unit);
	ifp->if_softc = sc;
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_POINTOPOINT;
	ifp->if_xflags = IFXF_CLONED;
	ifp->if_ioctl = mpw_ioctl;
	ifp->if_output = mpw_output;
	ifp->if_start = mpw_start;
	ifp->if_type = IFT_MPLSTUNNEL;
	ifp->if_hdrlen = ETHER_HDR_LEN;
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	if_attach(ifp);
	if_alloc_sadl(ifp);

	sc->sc_ifa.ifa_ifp = ifp;
	sc->sc_ifa.ifa_addr = sdltosa(ifp->if_sadl);
	sc->sc_smpls.smpls_len = sizeof(sc->sc_smpls);
	sc->sc_smpls.smpls_family = AF_MPLS;

	if_ih_insert(ifp, mpw_input, NULL);

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, ETHER_HDR_LEN);
#endif /* NBFILTER */

	return (0);
}

int
mpw_clone_destroy(struct ifnet *ifp)
{
	struct mpw_softc *sc = ifp->if_softc;

	ifp->if_flags &= ~IFF_RUNNING;

	if (sc->sc_smpls.smpls_label) {
		rt_ifa_del(&sc->sc_ifa, RTF_MPLS,
		    smplstosa(&sc->sc_smpls));
	}

	if_ih_remove(ifp, mpw_input, NULL);

	if_detach(ifp);
	free(sc, M_DEVBUF, sizeof(*sc));

	return (0);
}

int
mpw_input(struct ifnet *ifp, struct mbuf *m, void *cookie)
{
	/* Don't have local broadcast. */
	m_freem(m);
	return (1);
}

int
mpw_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ifreq *ifr = (struct ifreq *) data;
	struct mpw_softc *sc = ifp->if_softc;
	struct sockaddr_in *sin;
	struct sockaddr_in *sin_nexthop;
	int error = 0;
	struct ifmpwreq imr;

	switch (cmd) {
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < MPE_MTU_MIN ||
		    ifr->ifr_mtu > MPE_MTU_MAX)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP))
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
		break;

	case SIOCSETMPWCFG:
		error = suser(curproc, 0);
		if (error != 0)
			break;

		error = copyin(ifr->ifr_data, &imr, sizeof(imr));
		if (error != 0)
			break;

		/* Teardown all configuration if got no nexthop */
		sin = (struct sockaddr_in *) &imr.imr_nexthop;
		if (sin->sin_addr.s_addr == 0) {
			if (rt_ifa_del(&sc->sc_ifa, RTF_MPLS,
			    smplstosa(&sc->sc_smpls)) == 0)
				sc->sc_smpls.smpls_label = 0;

			memset(&sc->sc_rshim, 0, sizeof(sc->sc_rshim));
			memset(&sc->sc_nexthop, 0, sizeof(sc->sc_nexthop));
			sc->sc_flags = 0;
			sc->sc_type = 0;
			break;
		}

		/* Validate input */
		if (sin->sin_family != AF_INET ||
		    imr.imr_lshim.shim_label > MPLS_LABEL_MAX ||
		    imr.imr_lshim.shim_label <= MPLS_LABEL_RESERVED_MAX ||
		    imr.imr_rshim.shim_label > MPLS_LABEL_MAX ||
		    imr.imr_rshim.shim_label <= MPLS_LABEL_RESERVED_MAX) {
			error = EINVAL;
			break;
		}

		/* Setup labels and create inbound route */
		imr.imr_lshim.shim_label =
		    htonl(imr.imr_lshim.shim_label << MPLS_LABEL_OFFSET);
		imr.imr_rshim.shim_label =
		    htonl(imr.imr_rshim.shim_label << MPLS_LABEL_OFFSET);

		if (sc->sc_smpls.smpls_label != imr.imr_lshim.shim_label) {
			if (sc->sc_smpls.smpls_label)
				rt_ifa_del(&sc->sc_ifa, RTF_MPLS,
				    smplstosa(&sc->sc_smpls));

			sc->sc_smpls.smpls_label = imr.imr_lshim.shim_label;
			error = rt_ifa_add(&sc->sc_ifa, RTF_MPLS,
			    smplstosa(&sc->sc_smpls));
			if (error != 0) {
				sc->sc_smpls.smpls_label = 0;
				break;
			}
		}

		/* Apply configuration */
		sc->sc_flags = imr.imr_flags;
		sc->sc_type = imr.imr_type;
		sc->sc_rshim.shim_label = imr.imr_rshim.shim_label;
		sc->sc_rshim.shim_label |= MPLS_BOS_MASK;

		memset(&sc->sc_nexthop, 0, sizeof(sc->sc_nexthop));
		sin_nexthop = (struct sockaddr_in *) &sc->sc_nexthop;
		sin_nexthop->sin_family = sin->sin_family;
		sin_nexthop->sin_len = sizeof(struct sockaddr_in);
		sin_nexthop->sin_addr.s_addr = sin->sin_addr.s_addr;
		break;

	case SIOCGETMPWCFG:
		imr.imr_flags = sc->sc_flags;
		imr.imr_type = sc->sc_type;
		imr.imr_lshim.shim_label =
		    ((ntohl(sc->sc_smpls.smpls_label & MPLS_LABEL_MASK)) >>
			MPLS_LABEL_OFFSET);
		imr.imr_rshim.shim_label =
		    ((ntohl(sc->sc_rshim.shim_label & MPLS_LABEL_MASK)) >>
			MPLS_LABEL_OFFSET);
		memcpy(&imr.imr_nexthop, &sc->sc_nexthop,
		    sizeof(imr.imr_nexthop));

		error = copyout(&imr, ifr->ifr_data, sizeof(imr));
		break;

	default:
		error = ENOTTY;
		break;
	}

	return (error);
}

int
mpw_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *sa,
    struct rtentry *rt)
{
	struct mpw_softc *sc = ifp->if_softc;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct ether_header *eh, ehc;
	struct shim_hdr *shim;
	int s;

	if (sc->sc_type == IMR_TYPE_NONE) {
		m_freem(m);
		return (EHOSTUNREACH);
	}

	if (sc->sc_flags & IMR_FLAG_CONTROLWORD) {
		shim = mtod(m, struct shim_hdr *);
		m_adj(m, MPLS_HDRLEN);

		/*
		 * The first 4 bits identifies that this packet is a
		 * control word. If the control word is configured and
		 * we received an IP datagram we shall drop it.
		 */
		if (shim->shim_label & CW_ZERO_MASK) {
			ifp->if_ierrors++;
			m_freem(m);
			return (EINVAL);
		}

		/* We don't support fragmentation just yet. */
		if (shim->shim_label & CW_FRAG_MASK) {
			ifp->if_ierrors++;
			m_freem(m);
			return (EINVAL);
		}
	}

	if (sc->sc_type == IMR_TYPE_ETHERNET_TAGGED) {
		m_copydata(m, 0, sizeof(ehc), (caddr_t) &ehc);
		m_adj(m, ETHER_HDR_LEN);

		/* Ethernet tagged expects at least 2 VLANs */
		if (ntohs(ehc.ether_type) != ETHERTYPE_QINQ) {
			ifp->if_ierrors++;
			m_freem(m);
			return (EINVAL);
		}

		/* Remove dummy VLAN and update ethertype */
		if (EVL_VLANOFTAG(*mtod(m, uint16_t *)) == 0) {
			m_adj(m, EVL_ENCAPLEN);
			ehc.ether_type = htons(ETHERTYPE_VLAN);
		}

		M_PREPEND(m, sizeof(*eh), M_NOWAIT);
		if (m == NULL)
			return (ENOMEM);

		eh = mtod(m, struct ether_header *);
		memcpy(eh, &ehc, sizeof(*eh));
	}

	ml_enqueue(&ml, m);

	s = splnet();
	if_input(ifp, &ml);
	splx(s);

	return (0);
}

#if NVLAN > 0
extern void vlan_start(struct ifqueue *);

/*
 * This routine handles VLAN tag reinsertion in packets flowing through
 * the pseudowire. Also it does the necessary modifications to the VLANs
 * to respect the RFC.
 */
struct mbuf *
mpw_vlan_handle(struct mbuf *m, struct mpw_softc *sc)
{
	struct ifnet *ifp;
	struct ifvlan *ifv;

	uint16_t type = ETHERTYPE_QINQ;
	uint16_t tag = 0;

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp != NULL && ifp->if_qstart == vlan_start &&
	    ISSET(ifp->if_flags, IFF_RUNNING)) {
		ifv = ifp->if_softc;
		type = ifv->ifv_type;
		tag = ifv->ifv_tag;
	}
	if_put(ifp);

	return (vlan_inject(m, type, tag));
}
#endif /* NVLAN */

void
mpw_start(struct ifnet *ifp)
{
	struct mpw_softc *sc = ifp->if_softc;
	struct rtentry *rt;
	struct ifnet *p;
	struct mbuf *m;
	struct shim_hdr *shim;
	struct sockaddr_storage ss;

	if (!ISSET(ifp->if_flags, IFF_RUNNING) ||
	    sc->sc_rshim.shim_label == 0 ||
	    sc->sc_type == IMR_TYPE_NONE) {
		IFQ_PURGE(&ifp->if_snd);
		return;
	}

	rt = rtalloc((struct sockaddr *)&sc->sc_nexthop, RT_RESOLVE,
	    ifp->if_rdomain);
	if (!rtisvalid(rt)) {
		IFQ_PURGE(&ifp->if_snd);
		goto rtfree;
	}

	p = if_get(rt->rt_ifidx);
	if (p == NULL) {
		IFQ_PURGE(&ifp->if_snd);
		goto rtfree;
	}

	/*
	 * XXX: lie about being MPLS, so mpls_output() get the TTL from
	 * the right place.
	 */
	memcpy(&ss, &sc->sc_nexthop, sizeof(sc->sc_nexthop));
	((struct sockaddr *)&ss)->sa_family = AF_MPLS;

	while ((m = ifq_dequeue(&ifp->if_snd)) != NULL) {
#if NBPFILTER > 0
		if (sc->sc_if.if_bpf)
			bpf_mtap(sc->sc_if.if_bpf, m, BPF_DIRECTION_OUT);
#endif /* NBPFILTER */

		if (sc->sc_type == IMR_TYPE_ETHERNET_TAGGED) {
 #if NVLAN > 0
			m = mpw_vlan_handle(m, sc);
			if (m == NULL) {
				ifp->if_oerrors++;
				continue;
			}
 #else
			/* Ethernet tagged doesn't work without VLANs'*/
			m_freem(m);
			continue;
 #endif /* NVLAN */
		}

		if (sc->sc_flags & IMR_FLAG_CONTROLWORD) {
			M_PREPEND(m, sizeof(*shim), M_NOWAIT);
			if (m == NULL)
				continue;

			shim = mtod(m, struct shim_hdr *);
			memset(shim, 0, sizeof(*shim));
		}

		M_PREPEND(m, sizeof(*shim), M_NOWAIT);
		if (m == NULL)
			continue;

		shim = mtod(m, struct shim_hdr *);
		shim->shim_label = htonl(mpls_defttl) & MPLS_TTL_MASK;
		shim->shim_label |= sc->sc_rshim.shim_label;

		m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

		mpls_output(p, m, (struct sockaddr *)&ss, rt);
	}

	if_put(p);
rtfree:
	rtfree(rt);
}
@


1.19
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.18 2017/01/24 03:57:35 dlg Exp $ */
d382 2
a383 1
	rt = rtalloc((struct sockaddr *)&sc->sc_nexthop, RT_RESOLVE, 0);
d439 1
a439 2
		/* XXX: MPLS only uses domain 0 */
		m->m_pkthdr.ph_rtableid = 0;
@


1.18
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.17 2017/01/23 11:37:29 mpi Exp $ */
d348 1
a348 1
 
d351 1
a351 1
 
d355 1
a355 1
 		ifv = ifp->if_softc;
d358 1
a358 1
 	}
d416 2
a417 2
 			m_freem(m);
 			continue;
d420 2
a421 2
 
 		if (sc->sc_flags & IMR_FLAG_CONTROLWORD) {
@


1.17
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.16 2016/12/20 12:18:44 mpi Exp $ */
d336 1
a336 1
extern void vlan_start(struct ifnet *ifp);
d353 1
a353 1
	if (ifp != NULL && ifp->if_start == vlan_start &&
@


1.16
log
@Kill recursive splsoftnet()/splx() dances in ioctl(2) path.

ok rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.15 2016/09/21 07:41:49 mpi Exp $ */
d95 1
@


1.15
log
@Remove recursive splsoftnet() calls, from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.14 2016/04/13 11:41:15 mpi Exp $ */
a154 1
	int s;
a184 1
			s = splsoftnet();
a187 1
			splx(s);
a212 1
			s = splsoftnet();
a219 1
			splx(s);
@


1.14
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.13 2016/03/09 04:19:43 dlg Exp $ */
a122 1
	int s;
a126 1
		s = splsoftnet();
a128 1
		splx(s);
@


1.13
log
@rework how mpw(4) interacts with vlan(4)

previously mpw would walk around our interface hierarchy so it could
reinject vlan tags for packets that were received on a stack of
vlan interfaces. this got in the way of making vlan mpsafe, but is
also unecessary according to how i read RFC 4448 which describes
how mpls pseudowires should function.

the behaviour is now:

- in raw mode mpw(4) acts like a normal ethernet interface

it no longer injects a tag from a vlan interface that may be on the
same bridge as it, and it allows you to configure ip addresses on
the local interface and use them without panicking the kernel.

- in tagged mode it will only add tags from vlan interfaces on the
same bridge as it, but not any parent/child tags from interfaces
on top of that vlan. if the packet did not come from a vlan interface
on a bridge it will inject a tag for vlan 0.

this will also allow vlan to move forward.

ok mpi@@ rzalamena@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.12 2015/12/05 10:07:55 tedu Exp $ */
a100 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.12
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.11 2015/12/02 13:29:25 claudio Exp $ */
d354 14
a367 60
	int needsdummy = 0;
	int fakeifv = 0;
	struct ifvlan *ifv = NULL;
	struct ether_vlan_header *evh;
	struct ifnet *ifp, *ifp0;
	int nvlan, moff;
	struct ether_header eh;
	struct ifvlan fifv;
	struct vlan_shim {
		uint16_t	vs_tpid;
		uint16_t	vs_tci;
	} vs;

	ifp = ifp0 = if_get(m->m_pkthdr.ph_ifidx);
	KASSERT(ifp != NULL);
	if (ifp->if_start == vlan_start)
		ifv = ifp->if_softc;

	/* If we were relying on VLAN HW support, fake an ifv */
	if (ifv == NULL && (m->m_flags & M_VLANTAG) == M_VLANTAG) {
		memset(&fifv, 0, sizeof(fifv));
		fifv.ifv_tag = EVL_VLANOFTAG(m->m_pkthdr.ether_vtag);
		fifv.ifv_prio = EVL_PRIOFTAG(m->m_pkthdr.ether_vtag);
		ifv = &fifv;
		fakeifv = 1;
	}

	/*
	 * Always remove VLAN flag as we are inserting them here. Also we
	 * might get a tagged packet with no VLAN interface, in this case
	 * we can't do anything.
	 */
	m->m_flags &= ~M_VLANTAG;

	/*
	 * Do VLAN managing.
	 *
	 * Case ethernet (raw):
	 *  No VLAN: just pass it.
	 *  One or more VLANs: insert VLAN tag back.
	 *
	 * NOTE: In case of raw access mode, the if_vlan will do the job
	 * of dropping non tagged packets for us.
	 */
	if (sc->sc_type == IMR_TYPE_ETHERNET && ifv == NULL) {
		if_put(ifp0);
		return (m);
	}

	/*
	 * Case ethernet-tagged:
	 *  0 VLAN: Drop packet
	 *  1 VLAN: Tag packet with dummy VLAN
	 *  >1 VLAN: Nothing
	 */
	if (sc->sc_type == IMR_TYPE_ETHERNET_TAGGED && ifv == NULL) {
		m_freem(m);
		if_put(ifp0);
		return (NULL);
	}
d369 1
a369 74
	/* Copy and remove ethernet header */
	m_copydata(m, 0, sizeof(eh), (caddr_t) &eh);
	if (ntohs(eh.ether_type) == ETHERTYPE_VLAN ||
	    ntohs(eh.ether_type) == ETHERTYPE_QINQ)
		m_adj(m, sizeof(*evh));
	else
		m_adj(m, sizeof(eh));

	/* Count VLAN stack size */
	nvlan = 0;
	while ((ifp = ifv->ifv_p) != NULL && ifp->if_start == vlan_start) {
		ifv = ifp->if_softc;
		nvlan++;
	}
	moff = sizeof(*evh) + (nvlan * EVL_ENCAPLEN);

	/* The mode ethernet tagged always need at least 2 VLANs */
	if (sc->sc_type == IMR_TYPE_ETHERNET_TAGGED && nvlan == 0) {
		needsdummy = 1;
		moff += EVL_ENCAPLEN;
	}

	/* Add VLAN to the beginning of the packet */
	M_PREPEND(m, moff, M_NOWAIT);
	if (m == NULL) {
		if_put(ifp0);
		return (NULL);
	}

	/* Copy original ethernet type */
	moff -= sizeof(eh.ether_type);
	m_copyback(m, moff, sizeof(eh.ether_type), &eh.ether_type, M_NOWAIT);

	/* Fill inner VLAN values */
	ifv = ifp0->if_softc;
	while (nvlan-- > 0) {
		vs.vs_tci = htons((ifv->ifv_prio << EVL_PRIO_BITS) +
		    ifv->ifv_tag);
		vs.vs_tpid = htons(ifv->ifv_type);

		moff -= sizeof(vs);
		m_copyback(m, moff, sizeof(vs), &vs, M_NOWAIT);

		ifp = ifv->ifv_p;
		ifv = ifp->if_softc;
	}

	/* Copy ethernet header back */
	evh = mtod(m, struct ether_vlan_header *);
	memcpy(evh->evl_dhost, eh.ether_dhost, sizeof(evh->evl_dhost));
	memcpy(evh->evl_shost, eh.ether_shost, sizeof(evh->evl_shost));

	if (fakeifv)
		ifv = &fifv;

	/* Insert the last VLAN and optionally a dummy VLAN */
	if (needsdummy) {
		evh->evl_encap_proto = ntohs(ETHERTYPE_QINQ);
		evh->evl_tag = 0;

		vs.vs_tci = ntohs((m->m_pkthdr.pf.prio << EVL_PRIO_BITS) +
		    ifv->ifv_tag);
		vs.vs_tpid = ntohs(ETHERTYPE_VLAN);
		m_copyback(m, moff, sizeof(vs), &vs, M_NOWAIT);
	} else {
		evh->evl_encap_proto = (nvlan > 0) ?
		    ntohs(ETHERTYPE_QINQ) : ntohs(ETHERTYPE_VLAN);
		evh->evl_tag = ntohs((m->m_pkthdr.pf.prio << EVL_PRIO_BITS) +
		    ifv->ifv_tag);
	}

	if_put(ifp0);

	return (m);
d374 1
a374 1
mpw_start(struct ifnet *ifp0)
d376 3
a378 1
	struct mpw_softc *sc = ifp0->if_softc;
a379 2
	struct rtentry *rt;
	struct ifnet *ifp;
d383 8
a390 1
	rt = rtalloc((struct sockaddr *) &sc->sc_nexthop, RT_RESOLVE, 0);
d392 2
a393 2
		rtfree(rt);
		return;
d396 4
a399 4
	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL) {
		rtfree(rt);
		return;
d407 1
a407 25
	((struct sockaddr *) &ss)->sa_family = AF_MPLS;

	for (;;) {
		IFQ_DEQUEUE(&ifp0->if_snd, m);
		if (m == NULL)
			break;

		if ((ifp0->if_flags & IFF_RUNNING) == 0 ||
		    sc->sc_rshim.shim_label == 0 ||
		    sc->sc_type == IMR_TYPE_NONE) {
			m_freem(m);
			continue;
		}

#if NVLAN > 0
		m = mpw_vlan_handle(m, sc);
		if (m == NULL)
			continue;
#else
		/* Ethernet tagged doesn't work without VLANs'*/
		if (sc->sc_type == IMR_TYPE_ETHERNET_TAGGED) {
			m_freem(m);
			continue;
		}
#endif /* NVLAN */
d409 1
d415 15
a429 1
		if (sc->sc_flags & IMR_FLAG_CONTROLWORD) {
d449 1
a449 1
		mpls_output(ifp, m, (struct sockaddr *) &ss, rt);
d452 2
a453 1
	if_put(ifp);
@


1.11
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.10 2015/11/06 11:45:04 mpi Exp $ */
a73 1
/* ARGSUSED */
@


1.10
log
@Do not use rt_ifp directly.

ok rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.9 2015/11/03 11:51:07 dlg Exp $ */
d503 1
a503 2
	rt = rtalloc((struct sockaddr *) &sc->sc_nexthop,
	    RT_REPORT | RT_RESOLVE, 0);
@


1.9
log
@pull packets off the send queue with IFQ_DEQUEUE instead of IF_DEQUEUE.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.8 2015/10/22 17:48:34 mpi Exp $ */
d494 1
a494 1
mpw_start(struct ifnet *ifp)
d496 1
a496 1
	struct mpw_softc *sc = ifp->if_softc;
d499 1
d505 8
a512 1
	if (rt == NULL)
d514 1
d524 1
a524 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d528 1
a528 1
		if ((ifp->if_flags & IFF_RUNNING) == 0 ||
d572 1
a572 1
		mpls_output(rt->rt_ifp, m, (struct sockaddr *) &ss, rt);
d575 1
@


1.8
log
@Kill link_rtrequest(), introduce in 1990 to "fix" the result
of rt_getifa() when adding link level route from outside the
kernel.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.7 2015/10/22 15:37:47 bluhm Exp $ */
d515 1
a515 1
		IF_DEQUEUE(&ifp->if_snd, m);
@


1.7
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.6 2015/09/12 20:50:17 mpi Exp $ */
a107 1
	sc->sc_ifa.ifa_rtrequest = link_rtrequest;
@


1.6
log
@Now that rtrequest1(9) properly sets RTF_UP for newly added route,
stop passing it in every rt_ifa_add(9) calls.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.5 2015/09/10 16:41:30 mikeb Exp $ */
d30 1
d109 1
a109 1
	sc->sc_ifa.ifa_addr = (struct sockaddr *) ifp->if_sadl;
@


1.5
log
@pass a cookie argument to interface input handlers that can be used
to pass additional context or transient data with the similar life
time.

ok mpi, suggestions, hand holding and ok from dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.4 2015/09/10 13:32:19 dlg Exp $ */
d131 1
a131 1
		rt_ifa_del(&sc->sc_ifa, RTF_MPLS | RTF_UP,
d192 1
a192 1
			if (rt_ifa_del(&sc->sc_ifa, RTF_MPLS | RTF_UP,
d223 1
a223 1
				rt_ifa_del(&sc->sc_ifa, RTF_MPLS | RTF_UP,
d227 1
a227 1
			error = rt_ifa_add(&sc->sc_ifa, RTF_MPLS | RTF_UP,
@


1.4
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.3 2015/09/09 20:13:20 dlg Exp $ */
d65 1
a65 1
int	mpw_input(struct ifnet *, struct mbuf *);
d112 1
a112 1
	if_ih_insert(ifp, mpw_input);
d136 1
a136 1
	if_ih_remove(ifp, mpw_input);
d145 1
a145 1
mpw_input(struct ifnet *ifp, struct mbuf *m)
@


1.3
log
@if_put after you if_get

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mpw.c,v 1.2 2015/07/21 04:58:52 rzalamena Exp $ */
a84 1
	struct ifih *ifih;
a89 6
	ifih = malloc(sizeof(*ifih), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ifih == NULL) {
		free(sc, M_DEVBUF, sizeof(*sc));
		return (ENOMEM);
	}

d112 1
a112 2
	ifih->ifih_input = mpw_input;
	SLIST_INSERT_HEAD(&ifp->if_inputs, ifih, ifih_next);
a124 1
	struct ifih *ifih = SLIST_FIRST(&ifp->if_inputs);
d136 1
a136 2
	SLIST_REMOVE(&ifp->if_inputs, ifih, ifih, ifih_next);
	free(ifih, M_DEVBUF, sizeof(*ifih));
@


1.2
log
@Added OpenBSD CVS tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d378 1
a378 1
	ifp0 = ifp = if_get(m->m_pkthdr.ph_ifidx);
d409 2
a410 1
	if (sc->sc_type == IMR_TYPE_ETHERNET && ifv == NULL)
d412 1
d422 1
d450 2
a451 1
	if (m == NULL)
d453 1
d496 2
@


1.1
log
@Implemented MPLS pseudowire (mpw(4)) to be used with VPLS and VPWS.

ok mpi@@, claudio@@.
@
text
@d1 2
@

