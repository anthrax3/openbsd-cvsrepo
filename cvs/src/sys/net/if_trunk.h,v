head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.12
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.10
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2015.09.23.12.40.12;	author mikeb;	state Exp;
branches;
next	1.24;
commitid	XbcW7OHbAl4AkrQy;

1.24
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.23;
commitid	JbEzJsyDrWqOW57C;

1.23
date	2015.05.26.11.39.07;	author mpi;	state Exp;
branches;
next	1.22;
commitid	VJjEISzzvhOYKF2A;

1.22
date	2015.05.14.10.55.28;	author mpi;	state Exp;
branches;
next	1.21;
commitid	xa3lMMK6DiUzaKDq;

1.21
date	2015.05.13.08.16.01;	author mpi;	state Exp;
branches;
next	1.20;
commitid	vrUnLjm6nwy7iRD7;

1.20
date	2015.05.11.08.41.43;	author mpi;	state Exp;
branches;
next	1.19;
commitid	clvzRlWWi271kseu;

1.19
date	2014.12.04.00.01.53;	author tedu;	state Exp;
branches;
next	1.18;
commitid	wP6d1LFSgXabDbTH;

1.18
date	2013.11.18.09.16.30;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.04.04.29.17;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.15.06.56.09;	author mpf;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.13.07.03.45;	author mpf;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.22.14.48.52;	author pyr;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.06.16.22.55;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.26.08.57.59;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.31.06.20.19;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.28.01.14.15;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.23.04.35.52;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.20.22.03.24;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.09.13.33.38;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.18.17.59.59;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.27.09.27.14;	author mcbride;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.03.01.46.47;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.10.22.40.36;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.24.07.51.53;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.24.02.45.17;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove trunk watchdog code since it doesn't do anything useful
and we want to limit the number of different places where we
access trunk port pointers.

trunk_watchdog should be never called as we don't set up it's
if_timer and trunk_port_watchdog just calls the if_watchdog
from the underlying interface.

It's possible that this is no longer needed due to if_slowtimo/
if_watchdog changes done earlier.

ok mpi
@
text
@/*	$OpenBSD: if_trunk.h,v 1.24 2015/09/10 13:32:19 dlg Exp $	*/

/*
 * Copyright (c) 2005, 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _NET_TRUNK_H
#define _NET_TRUNK_H

/*
 * Global definitions
 */

#define TRUNK_MAX_PORTS		32	/* logically */
#define TRUNK_MAX_NAMESIZE	32	/* name of a protocol */
#define TRUNK_MAX_STACKING	4	/* maximum number of stacked trunks */

/* Port flags */
#define TRUNK_PORT_SLAVE		0x00000000 /* normal enslaved port */
#define TRUNK_PORT_MASTER		0x00000001 /* primary port */
#define TRUNK_PORT_STACK		0x00000002 /* stacked trunk port */
#define TRUNK_PORT_ACTIVE		0x00000004 /* port is active */
#define TRUNK_PORT_COLLECTING		0x00000008 /* port is receiving frames */
#define TRUNK_PORT_DISTRIBUTING	0x00000010 /* port is sending frames */
#define TRUNK_PORT_DISABLED		0x00000020 /* port is disabled */
#define TRUNK_PORT_GLOBAL		0x80000000 /* IOCTL: global flag */
#define TRUNK_PORT_BITS		"\20\01MASTER\02STACK\03ACTIVE" \
					 "\04COLLECTING\05DISTRIBUTING\06DISABLED"

/* Supported trunk PROTOs */
enum trunk_proto {
	TRUNK_PROTO_NONE	= 0,		/* no trunk protocol defined */
	TRUNK_PROTO_ROUNDROBIN	= 1,		/* simple round robin */
	TRUNK_PROTO_FAILOVER	= 2,		/* active failover */
	TRUNK_PROTO_LOADBALANCE	= 3,		/* loadbalance */
	TRUNK_PROTO_BROADCAST	= 4,		/* broadcast */
	TRUNK_PROTO_LACP	= 5,		/* 802.3ad LACP */
	TRUNK_PROTO_MAX		= 6
};

struct trunk_protos {
	const char		*tpr_name;
	enum trunk_proto	tpr_proto;
};

#define	TRUNK_PROTO_DEFAULT	TRUNK_PROTO_ROUNDROBIN
#define TRUNK_PROTOS	{						\
	{ "roundrobin",		TRUNK_PROTO_ROUNDROBIN },		\
	{ "failover",		TRUNK_PROTO_FAILOVER },			\
	{ "lacp",		TRUNK_PROTO_LACP },			\
	{ "loadbalance",	TRUNK_PROTO_LOADBALANCE },		\
	{ "broadcast",		TRUNK_PROTO_BROADCAST },		\
	{ "none",		TRUNK_PROTO_NONE },			\
	{ "default",		TRUNK_PROTO_DEFAULT }			\
}

/*
 * Trunk ioctls.
 */

/*
 * LACP current operational parameters structure.
 */
struct lacp_opreq {
	u_int16_t		actor_prio;
	u_int8_t		actor_mac[ETHER_ADDR_LEN];
	u_int16_t		actor_key;
	u_int16_t		actor_portprio;
	u_int16_t		actor_portno;
	u_int8_t		actor_state;
	u_int16_t		partner_prio;
	u_int8_t		partner_mac[ETHER_ADDR_LEN];
	u_int16_t		partner_key;
	u_int16_t		partner_portprio;
	u_int16_t		partner_portno;
	u_int8_t		partner_state;
};

/* Trunk port settings */
struct trunk_reqport {
	char			rp_ifname[IFNAMSIZ];	/* name of the trunk */
	char			rp_portname[IFNAMSIZ];	/* name of the port */
	u_int32_t		rp_prio;		/* port priority */
	u_int32_t		rp_flags;		/* port flags */
	union {
		struct lacp_opreq rpsc_lacp;
	} rp_psc;
#define rp_lacpreq	rp_psc.rpsc_lacp
};

#define SIOCGTRUNKPORT		_IOWR('i', 140, struct trunk_reqport)
#define SIOCSTRUNKPORT		 _IOW('i', 141, struct trunk_reqport)
#define SIOCSTRUNKDELPORT	 _IOW('i', 142, struct trunk_reqport)

/* Trunk, ports and options */
struct trunk_reqall {
	char			ra_ifname[IFNAMSIZ];	/* name of the trunk */
	u_int			ra_proto;		/* trunk protocol */

	size_t			ra_size;		/* size of buffer */
	struct trunk_reqport	*ra_port;		/* allocated buffer */
	int			ra_ports;		/* total port count */
	union {
		struct lacp_opreq rpsc_lacp;
	} ra_psc;
#define ra_lacpreq	ra_psc.rpsc_lacp
};

#define SIOCGTRUNK		_IOWR('i', 143, struct trunk_reqall)
#define SIOCSTRUNK		 _IOW('i', 144, struct trunk_reqall)

#ifdef _KERNEL
/*
 * Internal kernel part
 */
struct trunk_softc;
struct trunk_port {
	struct ifnet			*tp_if;		/* physical interface */
	struct trunk_softc		*tp_trunk;	/* parent trunk */
	u_int8_t			tp_lladdr[ETHER_ADDR_LEN];
	caddr_t				tp_psc;		/* protocol data */

	u_char				tp_iftype;	/* interface type */
	u_int32_t			tp_prio;	/* port priority */
	u_int32_t			tp_flags;	/* port flags */
	void				*lh_cookie;	/* if state hook */
	void				*dh_cookie;	/* if detach hook */

	/* Redirected callbacks */
	int	(*tp_ioctl)(struct ifnet *, u_long, caddr_t);
	int	(*tp_output)(struct ifnet *, struct mbuf *, struct sockaddr *,
		    struct rtentry *);

	SLIST_ENTRY(trunk_port)		tp_entries;
};

#define tp_ifname		tp_if->if_xname		/* interface name */
#define tp_ifflags		tp_if->if_flags		/* interface flags */
#define tp_link_state		tp_if->if_link_state	/* link state */
#define tp_capabilities		tp_if->if_capabilities	/* capabilities */

#define TRUNK_PORTACTIVE(_tp)	(					\
	LINK_STATE_IS_UP((_tp)->tp_link_state) &&			\
	(_tp)->tp_ifflags & IFF_UP)

struct trunk_mc {
	union {
		struct ether_multi	*mcu_enm;
	} mc_u;
	struct sockaddr_storage		mc_addr;

	SLIST_ENTRY(trunk_mc)		mc_entries;
};

#define mc_enm	mc_u.mcu_enm

struct trunk_ifreq {
	union {
		struct ifreq ifreq;
		struct {
			char ifr_name[IFNAMSIZ];
			struct sockaddr_storage ifr_ss;
		} ifreq_storage;
	} ifreq;
};

struct trunk_softc {
	struct arpcom			tr_ac;		/* virtual interface */
	int				tr_unit;	/* trunk unit */
	enum trunk_proto		tr_proto;	/* trunk protocol */
	u_int				tr_count;	/* number of ports */
	struct trunk_port		*tr_primary;	/* primary port */
	struct ifmedia			tr_media;	/* media config */
	caddr_t				tr_psc;		/* protocol data */

	SLIST_HEAD(__tplhd, trunk_port)	tr_ports;	/* list of interfaces */
	SLIST_ENTRY(trunk_softc)	tr_entries;

	SLIST_HEAD(__mclhd, trunk_mc)	tr_mc_head;	/* multicast addresses */

	/* Trunk protocol callbacks */
	int	(*tr_detach)(struct trunk_softc *);
	int	(*tr_start)(struct trunk_softc *, struct mbuf *);
	int	(*tr_input)(struct trunk_softc *, struct trunk_port *,
		    struct mbuf *);
	int	(*tr_port_create)(struct trunk_port *);
	void	(*tr_port_destroy)(struct trunk_port *);
	void	(*tr_linkstate)(struct trunk_port *);
	void	(*tr_init)(struct trunk_softc *);
	void	(*tr_stop)(struct trunk_softc *);
	void	(*tr_req)(struct trunk_softc *, caddr_t);
	void	(*tr_portreq)(struct trunk_port *, caddr_t);
};

#define tr_ifflags		tr_ac.ac_if.if_flags		/* flags */
#define tr_ifname		tr_ac.ac_if.if_xname		/* name */
#define tr_capabilities		tr_ac.ac_if.if_capabilities	/* capabilities */
#define tr_ifindex		tr_ac.ac_if.if_index		/* int index */
#define tr_lladdr		tr_ac.ac_enaddr			/* lladdr */

#define IFCAP_TRUNK_MASK	0xffff0000	/* private capabilities */
#define IFCAP_TRUNK_FULLDUPLEX	0x00010000	/* full duplex with >1 ports */

/* Private data used by the loadbalancing protocol */
struct trunk_lb {
	SIPHASH_KEY		lb_key;
	struct trunk_port	*lb_ports[TRUNK_MAX_PORTS];
};

int		trunk_enqueue(struct ifnet *, struct mbuf *);
u_int32_t	trunk_hashmbuf(struct mbuf *, SIPHASH_KEY *);
#endif /* _KERNEL */

#endif /* _NET_TRUNK_H */
@


1.24
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.23 2015/05/26 11:39:07 mpi Exp $	*/
a141 1
	void	(*tp_watchdog)(struct ifnet *);
a195 1
	int	(*tr_watchdog)(struct trunk_softc *);
@


1.23
log
@Now that the Ethernet header is always passed as part of the mbuf, kill
the second (unused) argument of the input packet handlers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.22 2015/05/14 10:55:28 mpi Exp $	*/
a139 1
	struct ifih			tp_ifih;	/* input handler */
@


1.22
log
@Allocate the input packet handler as part of the trunk_port structure
since they have the same lifetime.

Requested by and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.21 2015/05/13 08:16:01 mpi Exp $	*/
a224 1
int		trunk_input(struct mbuf *, void *);
@


1.21
log
@Get rid of the last "#if NTRUNK" by overwriting trunk ports' output
function.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.20 2015/05/11 08:41:43 mpi Exp $	*/
d140 1
@


1.20
log
@Take trunk(4) out of ether_input().

Each physical interface of a trunk now gets a specific ifih (interface
input handler) that runs before ether_input().

Tested by sthen@@, dlg@@, Theo Buehler and <mxb AT alumni.chalmers DOT se>

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.19 2014/12/04 00:01:53 tedu Exp $	*/
d144 2
@


1.19
log
@use siphash for trunk loadbalancing. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.18 2013/11/18 09:16:30 mpi Exp $	*/
d197 1
a197 1
		    struct ether_header *, struct mbuf *);
d222 1
a222 2
int	 	trunk_input(struct ifnet *, struct ether_header *,
		    struct mbuf *);
@


1.18
log
@Convert trunk(4) to use a detachhook, discussed at b2k13 with many.

While here add a comment explaining detach hooks' order of execution when
destroying/detaching an interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.17 2011/07/04 04:29:17 claudio Exp $	*/
a216 1
#define TRUNK_LB_MAXKEYS	8
d218 1
a218 1
	u_int32_t		lb_key;
d225 1
a225 1
u_int32_t	trunk_hashmbuf(struct mbuf *, u_int32_t);
@


1.17
log
@LINK_STATE cleanup. It is no longer needed to special case carp(4).
LINK_STATE_IS_UP() does the trick now for all cases.
OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.16 2008/06/15 06:56:09 mpf Exp $	*/
d139 1
a222 1
void	 	trunk_port_ifdetach(struct ifnet *);
@


1.16
log
@Add 802.3ad LACP support for trunk(4).
Implementation from NetBSD. Ported via FreeBSD's version in trunk^Wlagg(4).
This is still work in progress.  Tested with a HP ProCurve 3500.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.15 2008/06/13 07:03:45 mpf Exp $	*/
d153 1
a153 2
	(LINK_STATE_IS_UP((_tp)->tp_link_state) ||			\
	(_tp)->tp_link_state == LINK_STATE_UNKNOWN) &&			\
@


1.15
log
@Treat LINK_STATE_UNKNOWN as LINK_STATE_UP.
This restores the old behaviour where we were checking for != LINK_STATE_DOWN.
Fixes the ethernet to wireless failover feature and also allows trunk(4)
to be used within qemu.
Tested by sturm@@.
OK reyk@@. "grumble, we should fix more drivers' link state handling" brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.14 2007/10/22 14:48:52 pyr Exp $	*/
d31 10
a40 7
#define TRUNK_PORT_SLAVE	0x00000000	/* normal enslaved port */
#define TRUNK_PORT_MASTER	0x00000001	/* primary port */
#define TRUNK_PORT_STACK	0x00000002	/* stacked trunk port */
#define TRUNK_PORT_ACTIVE	0x00000004	/* port is active */
#define TRUNK_PORT_GLOBAL	0x80000000	/* IOCTL: global flag */
#define TRUNK_PORT_BITS							\
	"\20\01MASTER\02STACK\03ACTIVE"
d49 2
a50 1
	TRUNK_PROTO_MAX		= 5
d62 1
d73 18
d97 4
d115 4
d203 2
@


1.14
log
@Add a broadcast mode to trunk(4). This mode sends frames on all
ports and receives frame on any port. This allows interaction with
some L2 configurations.
with input and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.13 2007/09/06 16:22:55 reyk Exp $	*/
d122 3
a124 3
	(LINK_STATE_IS_UP((_tp)->tp_link_state)) &&			\
	((_tp)->tp_ifflags & IFF_UP)					\
)
@


1.13
log
@bump the copyright while touching these files
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.12 2007/04/26 08:57:59 reyk Exp $	*/
d45 2
a46 1
	TRUNK_PROTO_MAX		= 4
d59 1
@


1.12
log
@extend the trunk protocol API with some additional callbacks required
for future work. also move the repeated tx start code into a common
function.

parts of it are merged from FreeBSD's trunk(4) port. oh, wait... they
renamed it to 'lagg(4)' because a little green guy from Cizzco-Eeeh
told them "trunk is for VLANs, trunk is for VLANs". Bad FreeBSD, don't
listen to the little green guy from Cizzco-Eeeh!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.11 2007/01/31 06:20:19 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005, 2006 Reyk Floeter <reyk@@openbsd.org>
@


1.11
log
@handle the full duplex link state in trunk(4). load sharing trunks
with at least two ports are always handled as full fuplex links. this
change will allow trunks as edge ports in a rstp bridge(4).

ok brad@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.10 2006/05/28 01:14:15 reyk Exp $	*/
d36 2
a37 1
#define TRUNK_PORT_BITS		"\20\01MASTER\02STACK\03ACTIVE"
d95 1
a95 1

d98 1
a98 1
	caddr_t				tp_trunk;	/* parent trunk */
d100 1
d167 3
d175 2
d188 5
a192 2
void	 trunk_port_ifdetach(struct ifnet *);
int	 trunk_input(struct ifnet *, struct ether_header *, struct mbuf *);
@


1.10
log
@check if the interface is active and UP. some, but not all, network
drivers report an active link state even if the interface is DOWN.
this should fix trunk with various ethernet devices.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.9 2006/05/23 04:35:52 reyk Exp $	*/
d118 1
a118 1
	((_tp)->tp_link_state != LINK_STATE_DOWN) &&			\
d170 3
@


1.9
log
@add
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.8 2006/05/20 22:03:24 reyk Exp $	*/
d113 1
d116 5
@


1.8
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.7 2006/02/09 13:33:38 reyk Exp $	*/
d43 2
a44 1
	TRUNK_PROTO_MAX		= 3
d54 5
a58 4
	{ "roundrobin",	TRUNK_PROTO_ROUNDROBIN },			\
	{ "failover",	TRUNK_PROTO_FAILOVER },				\
	{ "none",	TRUNK_PROTO_NONE },				\
	{ "default",	TRUNK_PROTO_DEFAULT }				\
d164 7
@


1.7
log
@remove trailing ',' in enum declaration
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.6 2005/12/18 17:59:59 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Reyk Floeter <reyk@@openbsd.org>
@


1.6
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.5 2005/11/27 09:27:14 mcbride Exp $	*/
d43 1
a43 1
	TRUNK_PROTO_MAX		= 3,
@


1.5
log
@Make the trunk interface link state depend on the link states of the
trunkports (link is UP as long as at least one of the trunkports is up)

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.4 2005/10/03 01:46:47 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.4
log
@add a simple active "failover" trunk mode. port priorities will be
added later, currently the master port will always be the default
(active) port and the the next active port will be used as the
failover port.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.3 2005/09/10 22:40:36 reyk Exp $	*/
d101 1
@


1.3
log
@update the trunk(4) driver

- add multicast support by passing multicast addresses to the ports.
this is a requirement for carp(4) over trunk(4).

- support the smallest common interface capabilities. ie., this adds
support for VLAN MTUs if all attached ports have this capability.

- add a port_destroy callback to the trunk protocol. this fixes a
potential crash if the master port has been detached while running.

discussed with deraadt@@, brad@@ and some others.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.2 2005/05/24 07:51:53 reyk Exp $	*/
d34 1
d36 1
a36 1
#define TRUNK_PORT_BITS		"\20\01MASTER\02STACK"
d42 1
d54 1
d67 1
d96 1
d99 1
@


1.2
log
@support trunk stacking (trunks as trunk ports) and some fixes

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.h,v 1.1 2005/05/24 02:45:17 reyk Exp $	*/
d105 22
d140 2
d148 2
d152 3
a154 2
#define tr_ifflags		tr_ac.ac_if.if_flags	/* interface flags */
#define tr_ifname		tr_ac.ac_if.if_xname	/* interface name */
@


1.1
log
@initial import of a trunking (link aggregation and link failover)
implementation. it currently supports round robin mode with link state
checking, additional modes will be added later.

ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 1
d33 1
d35 1
a35 1
#define TRUNK_PORT_BITS		"\20\01MASTER"
@

