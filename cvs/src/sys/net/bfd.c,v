head	1.61;
access;
symbols;
locks; strict;
comment	@ * @;


1.61
date	2017.03.10.02.12.46;	author phessler;	state Exp;
branches;
next	1.60;
commitid	pxPVXQfOW0bg8y30;

1.60
date	2017.03.10.01.38.07;	author phessler;	state Exp;
branches;
next	1.59;
commitid	MrAjkUsCwKSGPVVk;

1.59
date	2017.03.06.08.56.39;	author mpi;	state Exp;
branches;
next	1.58;
commitid	aDXuIkVsOPuafbD0;

1.58
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.57;
commitid	6c6qq5OdS4VVnyVM;

1.57
date	2017.01.24.03.53.32;	author phessler;	state Exp;
branches;
next	1.56;
commitid	ZoJR3UuJfegIPMwX;

1.56
date	2017.01.24.02.52.36;	author phessler;	state Exp;
branches;
next	1.55;
commitid	YQPoqmgLP43m6h8B;

1.55
date	2017.01.22.00.39.45;	author phessler;	state Exp;
branches;
next	1.54;
commitid	PN1doAj3G6ZlLd2R;

1.54
date	2017.01.21.10.15.15;	author phessler;	state Exp;
branches;
next	1.53;
commitid	a5rcDoLnVRoBbUVv;

1.53
date	2017.01.21.08.40.04;	author phessler;	state Exp;
branches;
next	1.52;
commitid	7elRyj01SCLG0Nc9;

1.52
date	2017.01.20.10.18.52;	author phessler;	state Exp;
branches;
next	1.51;
commitid	uJ2ppx5lbXhJt7Da;

1.51
date	2017.01.20.09.18.52;	author phessler;	state Exp;
branches;
next	1.50;
commitid	cbsoNHlCUaYRUhO2;

1.50
date	2017.01.20.09.01.19;	author phessler;	state Exp;
branches;
next	1.49;
commitid	JUIhabDwwt20ARMW;

1.49
date	2017.01.20.08.50.45;	author phessler;	state Exp;
branches;
next	1.48;
commitid	hZ2qHPDHcyIfoNTx;

1.48
date	2017.01.20.08.37.48;	author phessler;	state Exp;
branches;
next	1.47;
commitid	d7LGl1pW7tElfgqS;

1.47
date	2017.01.19.23.18.29;	author phessler;	state Exp;
branches;
next	1.46;
commitid	blN5b1tPhlkhcTy8;

1.46
date	2017.01.19.10.19.39;	author phessler;	state Exp;
branches;
next	1.45;
commitid	JgjwVz8ghxYVoAAb;

1.45
date	2017.01.19.09.57.39;	author phessler;	state Exp;
branches;
next	1.44;
commitid	FDzWbltsl2XeMP6B;

1.44
date	2017.01.19.09.08.50;	author phessler;	state Exp;
branches;
next	1.43;
commitid	jpiENPg1r6acZJa0;

1.43
date	2017.01.19.08.55.46;	author phessler;	state Exp;
branches;
next	1.42;
commitid	7m5iWjZEqr7Jp4V4;

1.42
date	2017.01.12.16.14.42;	author mpi;	state Exp;
branches;
next	1.41;
commitid	MG25tJCcr7Xe6cjA;

1.41
date	2016.09.24.19.29.55;	author phessler;	state Exp;
branches;
next	1.40;
commitid	mpkZ5IfRsSYtW903;

1.40
date	2016.09.23.14.06.29;	author phessler;	state Exp;
branches;
next	1.39;
commitid	RHfTwmkJ1bAbUPR3;

1.39
date	2016.09.23.12.50.17;	author phessler;	state Exp;
branches;
next	1.38;
commitid	JaIzFKjeOMmctaPI;

1.38
date	2016.09.23.10.20.20;	author phessler;	state Exp;
branches;
next	1.37;
commitid	1srw2HJwRktQZRVb;

1.37
date	2016.09.23.10.09.07;	author phessler;	state Exp;
branches;
next	1.36;
commitid	mku5xPL2pztk8sE3;

1.36
date	2016.09.20.19.43.56;	author phessler;	state Exp;
branches;
next	1.35;
commitid	mr2ESnk2tlWeYlhd;

1.35
date	2016.09.20.19.40.53;	author phessler;	state Exp;
branches;
next	1.34;
commitid	pumdlQM0Q1aDBXZo;

1.34
date	2016.09.20.19.38.16;	author phessler;	state Exp;
branches;
next	1.33;
commitid	cbqd5Mm7v5HLRcgz;

1.33
date	2016.09.19.10.54.18;	author phessler;	state Exp;
branches;
next	1.32;
commitid	z2rqOinkq8kBP8ao;

1.32
date	2016.09.19.10.03.40;	author phessler;	state Exp;
branches;
next	1.31;
commitid	56HojCPra73Vpdc4;

1.31
date	2016.09.19.09.03.41;	author phessler;	state Exp;
branches;
next	1.30;
commitid	Eovo7fO6p2ykECSW;

1.30
date	2016.09.19.07.58.57;	author phessler;	state Exp;
branches;
next	1.29;
commitid	zNCjOyvRMxFTiMvM;

1.29
date	2016.09.19.07.28.40;	author phessler;	state Exp;
branches;
next	1.28;
commitid	J6BMe1N7H8G0OaDK;

1.28
date	2016.09.18.21.00.55;	author phessler;	state Exp;
branches;
next	1.27;
commitid	oBIB5bCOZLWIpvoR;

1.27
date	2016.09.17.07.35.05;	author phessler;	state Exp;
branches;
next	1.26;
commitid	XybSw76BMA6y6rFn;

1.26
date	2016.09.15.08.39.44;	author phessler;	state Exp;
branches;
next	1.25;
commitid	SK7gBoCXPA7zWDdi;

1.25
date	2016.09.15.07.47.00;	author phessler;	state Exp;
branches;
next	1.24;
commitid	5W04eJp9ybo2JWPY;

1.24
date	2016.09.13.07.56.05;	author phessler;	state Exp;
branches;
next	1.23;
commitid	TjBSOerlNHV7v6iE;

1.23
date	2016.09.12.15.24.51;	author phessler;	state Exp;
branches;
next	1.22;
commitid	8BB6jad3LMaxMxeg;

1.22
date	2016.09.10.05.39.38;	author jsg;	state Exp;
branches;
next	1.21;
commitid	W8bo9GhtLBuuTx53;

1.21
date	2016.09.07.09.23.07;	author mpi;	state Exp;
branches;
next	1.20;
commitid	LNP0TYTlk1QxtKEN;

1.20
date	2016.09.07.09.21.33;	author mpi;	state Exp;
branches;
next	1.19;
commitid	8XNPG0JQ4tuDPIfh;

1.19
date	2016.09.04.17.12.00;	author claudio;	state Exp;
branches;
next	1.18;
commitid	L3bKj9ae8N8aKAcr;

1.18
date	2016.09.04.13.24.27;	author claudio;	state Exp;
branches;
next	1.17;
commitid	M26tMmI8If3AIxA9;

1.17
date	2016.09.04.11.34.56;	author claudio;	state Exp;
branches;
next	1.16;
commitid	o6tO03DyTm4tGgYL;

1.16
date	2016.09.04.09.39.01;	author claudio;	state Exp;
branches;
next	1.15;
commitid	WcOp57BWVEJv93S4;

1.15
date	2016.09.03.22.51.15;	author phessler;	state Exp;
branches;
next	1.14;
commitid	iRkekSobE8wgc2Rq;

1.14
date	2016.09.03.22.24.43;	author phessler;	state Exp;
branches;
next	1.13;
commitid	6u6eOIAOX4UBVfWh;

1.13
date	2016.09.03.21.01.42;	author phessler;	state Exp;
branches;
next	1.12;
commitid	HTDYJGzlgKJToGC3;

1.12
date	2016.09.03.20.35.07;	author phessler;	state Exp;
branches;
next	1.11;
commitid	XT4je69Zb3mVxgqF;

1.11
date	2016.09.03.20.02.49;	author phessler;	state Exp;
branches;
next	1.10;
commitid	62JAfdhcbUfgKXb7;

1.10
date	2016.09.03.19.55.42;	author phessler;	state Exp;
branches;
next	1.9;
commitid	ieu1lL3qZcKZlKy8;

1.9
date	2016.09.03.19.17.49;	author phessler;	state Exp;
branches;
next	1.8;
commitid	oQwYHDP0cSwtwFDI;

1.8
date	2016.09.03.16.56.13;	author phessler;	state Exp;
branches;
next	1.7;
commitid	yV7DmUNVqiWOwnjt;

1.7
date	2016.09.03.16.47.26;	author phessler;	state Exp;
branches;
next	1.6;
commitid	DLNL8NFARlZLFNrz;

1.6
date	2016.09.03.16.45.27;	author phessler;	state Exp;
branches;
next	1.5;
commitid	2GVfihEHKDw98b1F;

1.5
date	2016.09.03.15.49.00;	author phessler;	state Exp;
branches;
next	1.4;
commitid	Sv6HSZhrV8xlFvNq;

1.4
date	2016.09.03.15.07.22;	author phessler;	state Exp;
branches;
next	1.3;
commitid	Y6PVE1Ea0f3pD4Oy;

1.3
date	2016.09.03.15.06.11;	author phessler;	state Exp;
branches;
next	1.2;
commitid	VTSdJb7sXa3kYuf4;

1.2
date	2016.09.03.15.05.25;	author phessler;	state Exp;
branches;
next	1.1;
commitid	wsfngr22Znp79Bbl;

1.1
date	2016.09.03.14.14.20;	author phessler;	state Exp;
branches;
next	;
commitid	wvCqdCfoSx943JOG;


desc
@@


1.61
log
@move clearing the bfd config to a task.  while here, fix a typo
@
text
@/*	$OpenBSD: bfd.c,v 1.60 2017/03/10 01:38:07 phessler Exp $	*/

/*
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Support for Bi-directional Forwarding Detection (RFC 5880 / 5881)
 */

#include <sys/errno.h>
#include <sys/param.h>

#include <sys/task.h>
#include <sys/pool.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/stdint.h>
#include <sys/systm.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#include <net/bfd.h>

/*
 * RFC 5880 Page 7
 * The Mandatory Section of a BFD Control packet has the following
 * format:
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |Vers | Diag    |Sta|P|F|C|A|D|M|  Detect Mult  |    Length     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      My Discriminator                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     Your Discriminator                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  Desired Min TX Interval                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                 Required Min RX Interval                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                Required Min Echo RX Interval                  |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *
 * An optional Authentication Section MAY be present:
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |   Auth Type   |   Auth Len    |     Authentication Data...    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 */

/* BFD on-wire format */
struct bfd_header {
	uint8_t	bfd_ver_diag;
	uint8_t	bfd_sta_flags;

	uint8_t		bfd_detect_multi;	/* detection time multiplier */
	uint8_t		bfd_length;		/* in bytes */
	uint32_t	bfd_my_discriminator;		/* From this system */
	uint32_t	bfd_your_discriminator;		/* Received */
	uint32_t	bfd_desired_min_tx_interval;	/* in microseconds */
	uint32_t	bfd_required_min_rx_interval;	/* in microseconds */
	uint32_t	bfd_required_min_echo_interval;	/* in microseconds */
} __packed;

/* optional authentication on-wire format */
struct bfd_auth_header {
	uint8_t	bfd_auth_type;
	uint8_t	bfd_auth_len;
	uint16_t	bfd_auth_data;
} __packed;

#define BFD_VERSION		1	/* RFC 5880 Page 6 */
#define BFD_VER(x)		(((x) & 0xe0) >> 5)
#define BFD_DIAG(x)		((x) & 0x1f)
#define BFD_STATE(x)		(((x) & 0xf0) >> 6)
#define BFD_FLAGS(x)		((x) & 0x0f)
#define BFD_HDRLEN		24	/* RFC 5880 Page 37 */
#define BFD_AUTH_SIMPLE_LEN	16 + 3	/* RFC 5880 Page 10 */
#define BFD_AUTH_MD5_LEN	24	/* RFC 5880 Page 11 */
#define BFD_AUTH_SHA1_LEN	28	/* RFC 5880 Page 12 */

/* Diagnostic Code (RFC 5880 Page 8) */
#define BFD_DIAG_NONE			0
#define BFD_DIAG_EXPIRED		1
#define BFD_DIAG_ECHO_FAILED		2
#define BFD_DIAG_NEIGHBOR_SIGDOWN	3
#define BFD_DIAG_FIB_RESET		4
#define BFD_DIAG_PATH_DOWN		5
#define BFD_DIAG_CONCAT_PATH_DOWN	6
#define BFD_DIAG_ADMIN_DOWN		7
#define BFD_DIAG_CONCAT_REVERSE_DOWN	8

/* State (RFC 5880 Page 8) */
#define BFD_STATE_ADMINDOWN		0
#define BFD_STATE_DOWN			1
#define BFD_STATE_INIT			2
#define BFD_STATE_UP			3

/* Flags (RFC 5880 Page 8) */
#define BFD_FLAG_P			0x20
#define BFD_FLAG_F			0x10
#define BFD_FLAG_C			0x08
#define BFD_FLAG_A			0x04
#define BFD_FLAG_D			0x02
#define BFD_FLAG_M			0x01


/* Auth Type (RFC 5880 Page 10) */
#define BFD_AUTH_TYPE_RESERVED		0
#define BFD_AUTH_TYPE_SIMPLE		1
#define BFD_AUTH_KEYED_MD5		2
#define BFD_AUTH_METICULOUS_MD5		3
#define BFD_AUTH_KEYED_SHA1		4
#define BFD_AUTH_METICULOUS_SHA1	5

#define BFD_UDP_PORT_CONTROL		3784
#define BFD_UDP_PORT_ECHO		3785

#define BFD_SECOND			1000000 /* 1,000,000 us == 1 second */
/* We currently tick every 10ms, so force a minimum that can be handled */
#define BFD_MINIMUM			50000	/* 50,000 us == 50 ms */


struct pool	 bfd_pool, bfd_pool_neigh, bfd_pool_time;
struct taskq	*bfdtq;


struct bfd_config *bfd_lookup(struct rtentry *);
void		 bfddestroy(void);

struct socket	*bfd_listener(struct bfd_config *, unsigned int);
struct socket	*bfd_sender(struct bfd_config *, unsigned int);
void		 bfd_input(struct bfd_config *, struct mbuf *);
void		 bfd_set_state(struct bfd_config *, int);

int	 bfd_send(struct bfd_config *, struct mbuf *);
void	 bfd_send_control(void *);

void	 bfd_start_task(void *);
void	 bfd_send_task(void *);
void	 bfd_upcall_task(void *);
void	 bfd_clear_task(void *);
void	 bfd_error(struct bfd_config *);
void	 bfd_timeout_rx(void *);
void	 bfd_timeout_tx(void *);

void	 bfd_upcall(struct socket *, caddr_t, int);
void	 bfd_senddown(struct bfd_config *);
void	 bfd_reset(struct bfd_config *);
void	 bfd_set_uptime(struct bfd_config *);

void	 bfd_debug(struct bfd_config *);

TAILQ_HEAD(bfd_queue, bfd_config)  bfd_queue;

/*
 * allocate a new bfd session
 */
int
bfdset(struct rtentry *rt)
{
	struct bfd_config	*bfd;

	/* at the moment it is not allowed to run BFD on indirect routes */
	if (ISSET(rt->rt_flags, RTF_GATEWAY) || !ISSET(rt->rt_flags, RTF_HOST))
		return (EINVAL);

	/* make sure we don't already have this setup */
	if (bfd_lookup(rt) != NULL)
		return (EADDRINUSE);

	/* Do our necessary memory allocations upfront */
	bfd = pool_get(&bfd_pool, PR_WAITOK | PR_ZERO);
	bfd->bc_neighbor = pool_get(&bfd_pool_neigh, PR_WAITOK | PR_ZERO);
	bfd->bc_time = pool_get(&bfd_pool_time, PR_WAITOK | PR_ZERO);

	bfd->bc_rt = rt;
	rtref(bfd->bc_rt);	/* we depend on this route not going away */

	microtime(bfd->bc_time);
	bfd_reset(bfd);
	bfd->bc_neighbor->bn_ldiscr = arc4random();

	if (!timeout_initialized(&bfd->bc_timo_rx))
		timeout_set(&bfd->bc_timo_rx, bfd_timeout_rx, bfd);
	if (!timeout_initialized(&bfd->bc_timo_tx))
		timeout_set(&bfd->bc_timo_tx, bfd_timeout_tx, bfd);

	task_set(&bfd->bc_bfd_task, bfd_start_task, bfd);
	task_set(&bfd->bc_clear_task, bfd_clear_task, bfd);

	task_add(bfdtq, &bfd->bc_bfd_task);

	TAILQ_INSERT_TAIL(&bfd_queue, bfd, bc_entry);
	bfd_set_state(bfd, BFD_STATE_DOWN);

	return (0);
}

/*
 * remove and free a bfd session
 */
void
bfdclear(struct rtentry *rt)
{
	struct bfd_config *bfd;

	if ((bfd = bfd_lookup(rt)) == NULL)
		return;

	task_add(systqmp, &bfd->bc_clear_task);
}

void
bfd_clear_task(void *arg)
{
	struct rtentry *rt = (struct rtentry *)arg;
	struct bfd_config *bfd;

	splsoftassert(IPL_SOFTNET);

	if ((bfd = bfd_lookup(rt)) == NULL)
		return;

	timeout_del(&bfd->bc_timo_rx);
	timeout_del(&bfd->bc_timo_tx);
	task_del(bfdtq, &bfd->bc_upcall_task);
	task_del(bfdtq, &bfd->bc_bfd_send_task);

	TAILQ_REMOVE(&bfd_queue, bfd, bc_entry);

	/* inform our neighbor */
	if (rtisvalid(bfd->bc_rt))
		bfd_senddown(bfd);

	rt->rt_flags &= ~RTF_BFD;
	if (bfd->bc_so) {
		/* remove upcall before calling soclose or it will be called */
		bfd->bc_so->so_upcall = NULL;
		soclose(bfd->bc_so);
	}
	if (bfd->bc_soecho) {
		bfd->bc_soecho->so_upcall = NULL;
		soclose(bfd->bc_soecho);
	}
	if (bfd->bc_sosend)
		soclose(bfd->bc_sosend);

	rtfree(bfd->bc_rt);
	bfd->bc_rt = NULL;

	pool_put(&bfd_pool_time, bfd->bc_time);
	pool_put(&bfd_pool_neigh, bfd->bc_neighbor);
	pool_put(&bfd_pool, bfd);
}

/*
 * Create and initialize the global bfd framework
 */
void
bfdinit(void)
{
	pool_init(&bfd_pool, sizeof(struct bfd_config), 0,
	    IPL_SOFTNET, 0, "bfd_config", NULL);
	pool_init(&bfd_pool_neigh, sizeof(struct bfd_neighbor), 0,
	    IPL_SOFTNET, 0, "bfd_config_peer", NULL);
	pool_init(&bfd_pool_time, sizeof(struct timeval), 0,
	    IPL_SOFTNET, 0, "bfd_config_time", NULL);

	bfdtq = taskq_create("bfd", 1, IPL_SOFTNET, 0);
	if (bfdtq == NULL)
		panic("unable to create BFD taskq");

	TAILQ_INIT(&bfd_queue);
}

/*
 * Destroy all bfd sessions and remove the tasks
 *
 */
void
bfddestroy(void)
{
	struct bfd_config	*bfd;

	/* inform our neighbor we are rebooting */
	while ((bfd = TAILQ_FIRST(&bfd_queue))) {
		bfd->bc_neighbor->bn_ldiag = BFD_DIAG_FIB_RESET;
		bfdclear(bfd->bc_rt);
	}

	taskq_destroy(bfdtq);
	pool_destroy(&bfd_pool_time);
	pool_destroy(&bfd_pool_neigh);
	pool_destroy(&bfd_pool);
}

/*
 * Return the matching bfd
 */
struct bfd_config *
bfd_lookup(struct rtentry *rt)
{
	struct bfd_config *bfd;

	TAILQ_FOREACH(bfd, &bfd_queue, bc_entry) {
		if (bfd->bc_rt == rt)
			return (bfd);
	}
	return (NULL);
}

struct sockaddr *
bfd2sa(struct rtentry *rt, struct sockaddr_bfd *sa_bfd)
{
	struct bfd_config *bfd;

	bfd = bfd_lookup(rt);

	if (bfd == NULL)
		return (NULL);

	memset(sa_bfd, 0, sizeof(*sa_bfd));
	sa_bfd->bs_len = sizeof(*sa_bfd);
	sa_bfd->bs_family = bfd->bc_rt->rt_dest->sa_family;

	sa_bfd->bs_mode = bfd->bc_mode;
	sa_bfd->bs_mintx = bfd->bc_mintx;
	sa_bfd->bs_minrx = bfd->bc_minrx;
	sa_bfd->bs_minecho = bfd->bc_minecho;
	sa_bfd->bs_multiplier = bfd->bc_multiplier;

	sa_bfd->bs_uptime = bfd->bc_time->tv_sec;
	sa_bfd->bs_lastuptime = bfd->bc_lastuptime;
	sa_bfd->bs_state = bfd->bc_state;
	sa_bfd->bs_remotestate = bfd->bc_neighbor->bn_rstate;
	sa_bfd->bs_laststate = bfd->bc_laststate;
	sa_bfd->bs_error = bfd->bc_error;

	sa_bfd->bs_localdiscr = bfd->bc_neighbor->bn_ldiscr;
	sa_bfd->bs_localdiag = bfd->bc_neighbor->bn_ldiag;
	sa_bfd->bs_remotediscr = bfd->bc_neighbor->bn_rdiscr;
	sa_bfd->bs_remotediag = bfd->bc_neighbor->bn_rdiag;

	return ((struct sockaddr *)sa_bfd);
}

/*
 * End of public interfaces.
 *
 * Everything below this line should not be used outside of this file.
 */

/*
 * Task to listen and kick off the bfd process
 */
void
bfd_start_task(void *arg)
{
	struct bfd_config	*bfd = (struct bfd_config *)arg;

	/* start listeners */
	bfd->bc_so = bfd_listener(bfd, BFD_UDP_PORT_CONTROL);
	if (!bfd->bc_so)
		printf("bfd_listener(%d) failed\n",
		    BFD_UDP_PORT_CONTROL);
	bfd->bc_soecho = bfd_listener(bfd, BFD_UDP_PORT_ECHO);
	if (!bfd->bc_soecho)
		printf("bfd_listener(%d) failed\n",
		    BFD_UDP_PORT_ECHO);

	/* start sending */
	bfd->bc_sosend = bfd_sender(bfd, BFD_UDP_PORT_CONTROL);
	if (bfd->bc_sosend) {
		task_set(&bfd->bc_bfd_send_task, bfd_send_task, bfd);
		task_add(bfdtq, &bfd->bc_bfd_send_task);
	}

	task_set(&bfd->bc_upcall_task, bfd_upcall_task, bfd);

	return;
}

void
bfd_send_task(void *arg)
{
	struct bfd_config	*bfd = (struct bfd_config *)arg;
	struct rtentry		*rt = bfd->bc_rt;

	if (ISSET(rt->rt_flags, RTF_UP)) {
		bfd_send_control(bfd);
	} else {
		if (bfd->bc_neighbor->bn_lstate > BFD_STATE_DOWN) {
			bfd->bc_error++;
			bfd->bc_neighbor->bn_ldiag = BFD_DIAG_PATH_DOWN;
			bfd_reset(bfd);
			bfd_set_state(bfd, BFD_STATE_DOWN);
		}
	}
//rtm_bfd(bfd);

	/* re-add 70%-90% jitter to our transmits, rfc 5880 6.8.7 */
	timeout_add_usec(&bfd->bc_timo_tx,
	    bfd->bc_mintx * (arc4random_uniform(20) + 70) / 100);
}

/*
 * Setup a bfd listener socket
 */
struct socket *
bfd_listener(struct bfd_config *bfd, unsigned int port)
{
	struct proc		*p = curproc;
	struct rtentry		*rt = bfd->bc_rt;
	struct sockaddr		*src = rt->rt_ifa->ifa_addr;
	struct sockaddr		*dst = rt_key(rt);
	struct sockaddr		*sa;
	struct sockaddr_in	*sin;
	struct sockaddr_in6	*sin6;
	struct socket		*so;
	struct mbuf		*m = NULL, *mopt = NULL;
	int			*ip, error;

	/* sa_family and sa_len must be equal */
	if (src->sa_family != dst->sa_family || src->sa_len != dst->sa_len)
		return (NULL);

	error = socreate(dst->sa_family, &so, SOCK_DGRAM, 0);
	if (error) {
		printf("%s: socreate error %d\n",
		    __func__, error);
		return (NULL);
	}

	MGET(mopt, M_WAIT, MT_SOOPTS);
	mopt->m_len = sizeof(int);
	ip = mtod(mopt, int *);
	*ip = MAXTTL;
	error = sosetopt(so, IPPROTO_IP, IP_MINTTL, mopt);
	if (error) {
		printf("%s: sosetopt error %d\n",
		    __func__, error);
		goto close;
	}

	MGET(m, M_WAIT, MT_SONAME);
	m->m_len = src->sa_len;
	sa = mtod(m, struct sockaddr *);
	memcpy(sa, src, src->sa_len);
	switch(sa->sa_family) {
	case AF_INET:
		sin = (struct sockaddr_in *)sa;
		sin->sin_port = htons(port);
		break;
	case AF_INET6:
		sin6 = (struct sockaddr_in6 *)sa;
		sin6->sin6_port = htons(port);
		break;
	default:
		break;
	}

	error = sobind(so, m, p);
	if (error) {
		printf("%s: sobind error %d\n",
		    __func__, error);
		goto close;
	}
	so->so_upcallarg = (caddr_t)bfd;
	so->so_upcall = bfd_upcall;

	return (so);

 close:
	m_free(m);
	soclose(so);

	return (NULL);
}

/*
 * Setup the bfd sending process
 */
struct socket *
bfd_sender(struct bfd_config *bfd, unsigned int port)
{
	struct socket		*so;
	struct rtentry		*rt = bfd->bc_rt;
	struct proc		*p = curproc;
	struct mbuf		*m = NULL, *mopt = NULL;
	struct sockaddr		*src = rt->rt_ifa->ifa_addr;
	struct sockaddr		*dst = rt_key(rt);
	struct sockaddr		*sa;
	struct sockaddr_in6	*sin6;
	struct sockaddr_in	*sin;
	int		 error, *ip;

	/* sa_family and sa_len must be equal */
	if (src->sa_family != dst->sa_family || src->sa_len != dst->sa_len)
		return (NULL);

	error = socreate(dst->sa_family, &so, SOCK_DGRAM, 0);

	if (error)
		return (NULL);

	MGET(mopt, M_WAIT, MT_SOOPTS);
	mopt->m_len = sizeof(int);
	ip = mtod(mopt, int *);
	*ip = IP_PORTRANGE_HIGH;
	error = sosetopt(so, IPPROTO_IP, IP_PORTRANGE, mopt);
	if (error) {
		printf("%s: sosetopt error %d\n",
		    __func__, error);
		goto close;
	}

	MGET(mopt, M_WAIT, MT_SOOPTS);
	mopt->m_len = sizeof(int);
	ip = mtod(mopt, int *);
	*ip = MAXTTL;
	error = sosetopt(so, IPPROTO_IP, IP_TTL, mopt);
	if (error) {
		printf("%s: sosetopt error %d\n",
		    __func__, error);
		goto close;
	}

	MGET(mopt, M_WAIT, MT_SOOPTS);
	mopt->m_len = sizeof(int);
	ip = mtod(mopt, int *);
	*ip = IPTOS_PREC_INTERNETCONTROL;
	error = sosetopt(so, IPPROTO_IP, IP_TOS, mopt);
	if (error) {
		printf("%s: sosetopt error %d\n",
		    __func__, error);
		goto close;
	}

	MGET(m, M_WAIT, MT_SONAME);
	m->m_len = src->sa_len;
	sa = mtod(m, struct sockaddr *);
	memcpy(sa, src, src->sa_len);
	switch(sa->sa_family) {
	case AF_INET:
		sin = (struct sockaddr_in *)sa;
		sin->sin_port = 0;
		break;
	case AF_INET6:
		sin6 = (struct sockaddr_in6 *)sa;
		sin6->sin6_port = 0;
		break;
	default:
		break;
	}

	error = sobind(so, m, p);
	if (error) {
		printf("%s: sobind error %d\n",
		    __func__, error);
		goto close;
	}

	memcpy(sa, dst, dst->sa_len);
	switch(sa->sa_family) {
	case AF_INET:
		sin = (struct sockaddr_in *)sa;
		sin->sin_port = ntohs(port);
		break;
	case AF_INET6:
		sin6 = (struct sockaddr_in6 *)sa;
		sin6->sin6_port = ntohs(port);
		break;
	default:
		break;
	}

	error = soconnect(so, m);
	if (error && error != ECONNREFUSED) {
		printf("%s: soconnect error %d\n",
		    __func__, error);
		goto close;
	}

	m_free(m);

	return (so);

 close:
	m_free(m);
	soclose(so);

	return (NULL);
}

/*
 * Will be called per-received packet
 */
void
bfd_upcall(struct socket *so, caddr_t arg, int waitflag)
{
	struct bfd_config *bfd = (struct bfd_config *)arg;

	bfd->bc_upcallso = so;
	task_add(bfdtq, &bfd->bc_upcall_task);	
}

void
bfd_upcall_task(void *arg)
{
	struct bfd_config	*bfd = (struct bfd_config *)arg;
	struct socket		*so = bfd->bc_upcallso;
	struct mbuf		*m;
	struct uio		 uio;
	int			 flags, error;

	uio.uio_procp = NULL;
	do {
		uio.uio_resid = so->so_rcv.sb_cc;
		flags = MSG_DONTWAIT;
		error = soreceive(so, NULL, &uio, &m, NULL, &flags, 0);
		if (error && error != EAGAIN) {
			bfd_error(bfd);
			return;
		}
		if (m != NULL)
			bfd_input(bfd, m);
	} while (so->so_rcv.sb_cc);

	bfd->bc_upcallso = NULL;

	return;
}

void
bfd_error(struct bfd_config *bfd)
{
	if (bfd->bc_state <= BFD_STATE_DOWN)
		return;

	if (++bfd->bc_error >= bfd->bc_neighbor->bn_mult) {
		bfd->bc_neighbor->bn_ldiag = BFD_DIAG_EXPIRED;
		bfd_reset(bfd);
		if (bfd->bc_state > BFD_STATE_DOWN)
			bfd_set_state(bfd, BFD_STATE_DOWN);
	}
}

void
bfd_timeout_tx(void *v)
{
	struct bfd_config *bfd = v;
	task_add(bfdtq, &bfd->bc_bfd_send_task);
}

/*
 * Triggers when we do not receive a valid packet in time
 */
void
bfd_timeout_rx(void *v)
{
	struct bfd_config *bfd = v;

	if (bfd->bc_state > BFD_STATE_DOWN) {
		bfd_error(bfd);
		rtm_bfd(bfd);
	}

	timeout_add_usec(&bfd->bc_timo_rx, bfd->bc_minrx);
}

/*
 * Tell our neighbor that we are going down
 */
void
bfd_senddown(struct bfd_config *bfd)
{
	/* If we are down, return early */
	if (bfd->bc_state < BFD_STATE_INIT)
		return;

	if (bfd->bc_neighbor->bn_ldiag == 0)
		bfd->bc_neighbor->bn_ldiag = BFD_DIAG_ADMIN_DOWN;

	bfd_set_state(bfd, BFD_STATE_ADMINDOWN);
	bfd_send_control(bfd);

	return;
}

/*
 * Clean a BFD peer to defaults
 */
void
bfd_reset(struct bfd_config *bfd)
{
	/* Clean */
	bfd->bc_neighbor->bn_rdiscr = 0;
	bfd->bc_neighbor->bn_demand = 0;
	bfd->bc_neighbor->bn_rdemand = 0;
	bfd->bc_neighbor->bn_authtype = 0;
	bfd->bc_neighbor->bn_rauthseq = 0;
	bfd->bc_neighbor->bn_lauthseq = 0;
	bfd->bc_neighbor->bn_authseqknown = 0;
	bfd->bc_neighbor->bn_ldiag = 0;

	bfd->bc_mode = BFD_MODE_ASYNC;
	bfd->bc_state = BFD_STATE_DOWN;

	/* rfc5880 6.8.18 */
	bfd->bc_neighbor->bn_lstate = BFD_STATE_DOWN;
	bfd->bc_neighbor->bn_rstate = BFD_STATE_DOWN;
	bfd->bc_neighbor->bn_mintx = BFD_SECOND;
	bfd->bc_neighbor->bn_req_minrx = BFD_SECOND;
	bfd->bc_neighbor->bn_rminrx = 1;
	bfd->bc_neighbor->bn_mult = 3;

	bfd->bc_mintx = bfd->bc_neighbor->bn_mintx;
	bfd->bc_minrx = bfd->bc_neighbor->bn_req_minrx;
	bfd->bc_multiplier = bfd->bc_neighbor->bn_mult;
	bfd->bc_minecho = 0;	//XXX - BFD_SECOND;

	bfd_set_uptime(bfd);

	return;
}

void
bfd_input(struct bfd_config *bfd, struct mbuf *m)
{
	struct bfd_header	*peer;
	struct bfd_auth_header	*auth;
	struct mbuf		*mp, *mp0;
	unsigned int		 ver, diag = BFD_DIAG_NONE, state, flags;
	int			 offp;

	mp = m_pulldown(m, 0, sizeof(*peer), &offp);

	if (mp == NULL)
		return;
	peer = (struct bfd_header *)(mp->m_data + offp);

	/* We only support BFD Version 1 */
	if (( ver = BFD_VER(peer->bfd_ver_diag)) != 1)
		goto discard;

	diag = BFD_DIAG(peer->bfd_ver_diag);
	state = BFD_STATE(peer->bfd_sta_flags);
	flags = BFD_FLAGS(peer->bfd_sta_flags);

	if (peer->bfd_length + offp > mp->m_len) {
		printf("%s: bad len %d != %d\n", __func__,
		    peer->bfd_length + offp, mp->m_len);
		goto discard;
	}

	if (peer->bfd_detect_multi == 0)
		goto discard;
	if (flags & BFD_FLAG_M)
		goto discard;
	if (ntohl(peer->bfd_my_discriminator) == 0)
		goto discard;
	if (ntohl(peer->bfd_your_discriminator) == 0 &&
	    BFD_STATE(peer->bfd_sta_flags) > BFD_STATE_DOWN)
		goto discard;
	if ((ntohl(peer->bfd_your_discriminator) != 0) &&
	    (ntohl(peer->bfd_your_discriminator) !=
	    bfd->bc_neighbor->bn_ldiscr)) {
		bfd_error(bfd);
		goto discard;
	}

	if ((flags & BFD_FLAG_A) && bfd->bc_neighbor->bn_authtype == 0)
		goto discard;
	if (!(flags & BFD_FLAG_A) && bfd->bc_neighbor->bn_authtype != 0)
		goto discard;
	if (flags & BFD_FLAG_A) {
		mp0 = m_pulldown(mp, 0, sizeof(*auth), &offp);
		if (mp0 == NULL)
			goto discard;
		auth = (struct bfd_auth_header *)(mp0->m_data + offp);
#if 0
		if (bfd_process_auth(bfd, auth) != 0) {
			m_free(mp0);
			goto discard;
		}
#endif
	}

	bfd->bc_neighbor->bn_rdiscr = ntohl(peer->bfd_my_discriminator);
	bfd->bc_neighbor->bn_rstate = state;
	bfd->bc_neighbor->bn_rdemand = (flags & BFD_FLAG_D);
	bfd->bc_poll = (flags & BFD_FLAG_F);

	/* Local change to the algorithm, we don't accept below 50ms */
	if (ntohl(peer->bfd_required_min_rx_interval) < BFD_MINIMUM)
		goto discard;
	/*
	 * Local change to the algorithm, we can't use larger than signed
	 * 32bits for a timeout.
	 * That is Too Long(tm) anyways.
	 */
	if (ntohl(peer->bfd_required_min_rx_interval) > INT32_MAX)
		goto discard;
	bfd->bc_neighbor->bn_rminrx =
	    ntohl(peer->bfd_required_min_rx_interval);
	bfd->bc_minrx = bfd->bc_neighbor->bn_req_minrx;

	bfd->bc_neighbor->bn_mintx =
	    htonl(peer->bfd_desired_min_tx_interval);
	if (bfd->bc_neighbor->bn_lstate != BFD_STATE_UP)
		bfd->bc_neighbor->bn_mintx = BFD_SECOND;

	bfd->bc_neighbor->bn_req_minrx =
	    ntohl(peer->bfd_required_min_rx_interval);

	/* rfc5880 6.8.7 */
	bfd->bc_mintx = max(bfd->bc_neighbor->bn_rminrx,
	    bfd->bc_neighbor->bn_mintx);

	/* According the to pseudo-code RFC 5880 page 34 */
	if (bfd->bc_state == BFD_STATE_ADMINDOWN)
		goto discard;
	if (bfd->bc_neighbor->bn_rstate == BFD_STATE_ADMINDOWN) {
		if (bfd->bc_neighbor->bn_lstate != BFD_STATE_DOWN) {
			bfd->bc_neighbor->bn_ldiag = BFD_DIAG_NEIGHBOR_SIGDOWN;
			bfd_set_state(bfd, BFD_STATE_DOWN);
		}
	} else if (bfd->bc_neighbor->bn_lstate == BFD_STATE_DOWN) {
		if (bfd->bc_neighbor->bn_rstate == BFD_STATE_DOWN)
			bfd_set_state(bfd, BFD_STATE_INIT);
		else if (bfd->bc_neighbor->bn_rstate == BFD_STATE_INIT) {
			bfd->bc_neighbor->bn_ldiag = 0;
			bfd_set_state(bfd, BFD_STATE_UP);
		}
	} else if (bfd->bc_neighbor->bn_lstate == BFD_STATE_INIT) {
		if (bfd->bc_neighbor->bn_rstate >= BFD_STATE_INIT) {
			bfd->bc_neighbor->bn_ldiag = 0;
			bfd_set_state(bfd, BFD_STATE_UP);
		} else {
			goto discard;
		}
	} else {
		if (bfd->bc_neighbor->bn_rstate == BFD_STATE_DOWN) {
			bfd->bc_neighbor->bn_ldiag = BFD_DIAG_NEIGHBOR_SIGDOWN;
			bfd_set_state(bfd, BFD_STATE_DOWN);
			goto discard;
		}
	}

	if (bfd->bc_neighbor->bn_lstate == BFD_STATE_UP) {
		bfd->bc_neighbor->bn_ldiag = 0;
		bfd->bc_neighbor->bn_demand = 1;
		bfd->bc_neighbor->bn_rdemand = (flags & BFD_FLAG_D);
	}

	bfd->bc_error = 0;

 discard:
	bfd->bc_neighbor->bn_rdiag = diag;
	m_free(m);

	timeout_add_usec(&bfd->bc_timo_rx, bfd->bc_minrx);

	return;
}

void
bfd_set_state(struct bfd_config *bfd, int state)
{
	struct ifnet	*ifp;
	struct rtentry	*rt = bfd->bc_rt;

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL) {
		printf("%s: cannot find interface index %u\n",
		    __func__, rt->rt_ifidx);
		bfd->bc_error++;
		bfd_reset(bfd);
		return;
	}

	bfd->bc_neighbor->bn_lstate = state;
	if (state > BFD_STATE_ADMINDOWN)
		bfd->bc_neighbor->bn_ldiag = 0;

	if (!rtisvalid(rt))
		bfd->bc_neighbor->bn_lstate = BFD_STATE_DOWN;

	switch (state) {
	case BFD_STATE_ADMINDOWN:
		bfd->bc_laststate = bfd->bc_state;
	/* FALLTHROUGH */
	case BFD_STATE_DOWN:
		if (bfd->bc_laststate == BFD_STATE_UP) {
			bfd->bc_laststate = bfd->bc_state;
			bfd_set_uptime(bfd);
		}
		break;
	case BFD_STATE_INIT:
		bfd->bc_laststate = bfd->bc_state;
		break;
	case BFD_STATE_UP:
		bfd->bc_laststate =
		    bfd->bc_state == BFD_STATE_INIT ?
		    bfd->bc_laststate : bfd->bc_state;
		bfd_set_uptime(bfd);
		break;
	}

	bfd->bc_state = state;
	rtm_bfd(bfd);
	if_put(ifp);

	return;
}

void
bfd_set_uptime(struct bfd_config *bfd)
{
	struct timeval tv;

	microtime(&tv);
	bfd->bc_lastuptime = tv.tv_sec - bfd->bc_time->tv_sec;
	memcpy(bfd->bc_time, &tv, sizeof(tv));
}

void
bfd_send_control(void *x)
{
	struct bfd_config	*bfd = x;
	struct mbuf		*m;
	struct bfd_header	*h;
	int error, len;

	MGETHDR(m, M_WAIT, MT_DATA);
	MCLGET(m, M_WAIT);

	len = BFD_HDRLEN;
	m->m_len = m->m_pkthdr.len = len;
	h = mtod(m, struct bfd_header *);

	memset(h, 0xff, sizeof(*h));	/* canary */

	h->bfd_ver_diag = ((BFD_VERSION << 5) | (bfd->bc_neighbor->bn_ldiag));
	h->bfd_sta_flags = (bfd->bc_state << 6);
	h->bfd_detect_multi = bfd->bc_neighbor->bn_mult;
	h->bfd_length = BFD_HDRLEN;
	h->bfd_my_discriminator = htonl(bfd->bc_neighbor->bn_ldiscr);
	h->bfd_your_discriminator = htonl(bfd->bc_neighbor->bn_rdiscr);

	h->bfd_desired_min_tx_interval =
	    htonl(bfd->bc_neighbor->bn_mintx);
	h->bfd_required_min_rx_interval =
	    htonl(bfd->bc_neighbor->bn_req_minrx);
	h->bfd_required_min_echo_interval = htonl(bfd->bc_minecho);

	error = bfd_send(bfd, m);

	if (error) {
		bfd_error(bfd);
		if (!(error == EHOSTDOWN || error == ECONNREFUSED)) {
			printf("%s: %u\n", __func__, error);
		}
	}
}

int
bfd_send(struct bfd_config *bfd, struct mbuf *m)
{
	struct rtentry *rt = bfd->bc_rt;

	if (!rtisvalid(rt) || !ISSET(rt->rt_flags, RTF_BFD)) {
		m_freem(m);
		return (EHOSTDOWN);
	}

	return(sosend(bfd->bc_sosend, NULL, NULL, m, NULL, MSG_DONTWAIT));
}

/*
 * Print debug information about this bfd instance
 */
void
bfd_debug(struct bfd_config *bfd)
{
	struct rtentry	*rt = bfd->bc_rt;
	struct timeval	 tv;
	char buf[64];

	printf("dest: %s ", sockaddr_ntop(rt_key(rt), buf, sizeof(buf)));
	printf("src: %s ", sockaddr_ntop(rt->rt_ifa->ifa_addr, buf,
	    sizeof(buf)));
	printf("\n");
	printf("\t");
	printf("session state: %u ", bfd->bc_state);
	printf("mode: %u ", bfd->bc_mode);
	printf("error: %u ", bfd->bc_error);
	printf("minrx: %u ", bfd->bc_minrx);
	printf("mintx: %u ", bfd->bc_mintx);
	printf("multiplier: %u ", bfd->bc_multiplier);
	printf("\n");
	printf("\t");
	printf("local session state: %u ", bfd->bc_neighbor->bn_lstate);
	printf("local diag: %u ", bfd->bc_neighbor->bn_ldiag);
	printf("\n");
	printf("\t");
	printf("remote discriminator: %u ", bfd->bc_neighbor->bn_rdiscr);
	printf("local discriminator: %u ", bfd->bc_neighbor->bn_ldiscr);
	printf("\n");
	printf("\t");
	printf("remote session state: %u ", bfd->bc_neighbor->bn_rstate);
	printf("remote diag: %u ", bfd->bc_neighbor->bn_rdiag);
	printf("remote min rx: %u ", bfd->bc_neighbor->bn_rminrx);
	printf("\n");
	printf("\t");
	printf("last state: %u ", bfd->bc_laststate);
	getmicrotime(&tv);
	printf("uptime %llds ", tv.tv_sec - bfd->bc_time->tv_sec);
	printf("time started %lld.%06ld ", bfd->bc_time->tv_sec,
	    bfd->bc_time->tv_usec);
	printf("last uptime %llds ", bfd->bc_lastuptime);
	printf("\n");
}
@


1.60
log
@move receiving and processing the BFD packet into a task
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.59 2017/03/06 08:56:39 mpi Exp $	*/
d161 1
d209 2
d227 12
d246 1
a246 1
	task_del(bfdtq, &bfd->bc_bfd_upcall_task);
@


1.59
log
@Prefix functions dealing with routing messages with 'rtm_' and keep
them all in net/rtsock.c.

This allows to easily spot which functions are doing a copyout(9)
when dealing with the routing midlayer.

ok phessler@@, bluhm@@, dhill@@, krw@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.58 2017/01/24 10:08:30 krw Exp $	*/
d160 1
d231 1
d383 2
d607 13
a619 3
	struct mbuf *m;
	struct uio uio;
	int flags, error;
d633 2
@


1.58
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.57 2017/01/24 03:53:32 phessler Exp $	*/
d400 1
a400 1
//rt_bfdmsg(bfd);
d654 1
a654 1
		rt_bfdmsg(bfd);
d900 1
a900 1
	rt_bfdmsg(bfd);
@


1.57
log
@only send the rt msg on timeout failure if bfd is not down
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.56 2017/01/24 02:52:36 phessler Exp $	*/
d378 1
a378 1
		task_add(bfdtq, &bfd->bc_bfd_send_task);	
d487 1
a487 1
	struct socket 		*so;
d641 1
a641 1
	task_add(bfdtq, &bfd->bc_bfd_send_task);	
@


1.56
log
@move setting the IP TOS from the listening socket to the sending socket
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.55 2017/01/22 00:39:45 phessler Exp $	*/
d652 4
a655 2
	bfd_error(bfd);
	rt_bfdmsg(bfd);
@


1.55
log
@set the TOS/ECN field to Internetwork Control, since that is exactly
what we are doing
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.54 2017/01/21 10:15:15 phessler Exp $	*/
a445 11
	MGET(mopt, M_WAIT, MT_SOOPTS);
	mopt->m_len = sizeof(int);
	ip = mtod(mopt, int *);
	*ip = IPTOS_PREC_INTERNETCONTROL;
	error = sosetopt(so, IPPROTO_IP, IP_TOS, mopt);
	if (error) {
		printf("%s: sosetopt error %d\n",
		    __func__, error);
		goto close;
	}

d523 11
@


1.54
log
@sockets tell us the size of their data.  since we want one udp packet,
just use that.  uses one less soreceive() loop per packet received.

hints from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.53 2017/01/21 08:40:04 phessler Exp $	*/
d440 11
@


1.53
log
@be more explict with the size of bfd packets we send and receive
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.52 2017/01/20 10:18:52 phessler Exp $	*/
d598 1
a598 1
		uio.uio_resid =  BFD_HDRLEN;
d607 1
a607 1
	} while (m != NULL);
@


1.52
log
@if a route is not valid, set down instead of admindown
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.51 2017/01/20 09:18:52 phessler Exp $	*/
d598 1
a598 1
		uio.uio_resid = 1000000000;
d909 1
a909 1
	int error;
d914 2
a915 1
	m->m_len = m->m_pkthdr.len = sizeof(*bfd);
@


1.51
log
@fix typo
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.50 2017/01/20 09:01:19 phessler Exp $	*/
d863 1
a863 1
		bfd->bc_neighbor->bn_lstate = BFD_STATE_ADMINDOWN;
@


1.50
log
@don't increase the error counter in the not-down case, in general
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.49 2017/01/20 08:50:45 phessler Exp $	*/
d694 1
a694 1
	bfd->bc_minrx = bfd->bc_neighbor->bn_req_rminrx;
@


1.49
log
@only increase the error counter if we are in a not-down state
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.48 2017/01/20 08:37:48 phessler Exp $	*/
d615 3
@


1.48
log
@correctly set our rx timer to be the required minimum, not the bare
minimum the neighbor supports
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.47 2017/01/19 23:18:29 phessler Exp $	*/
a392 1
		bfd->bc_error++;
d394 1
@


1.47
log
@add hooks so we can query the current state of a BFD session

bfd session details are visible with "route -n get 192.0.2.1 -bfd"

OK mpi@@ deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.46 2017/01/19 10:19:39 phessler Exp $	*/
d691 1
a691 1
	bfd->bc_minrx = bfd->bc_neighbor->bn_rminrx;
@


1.46
log
@when parsing a BFD packet, avoid an uninitialized variable if the
version check fails

found by jsg@@ with clang
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.45 2017/01/19 09:57:39 phessler Exp $	*/
d313 35
@


1.45
log
@make error handling a function, and use it in a few places

not all error handling is converted, some require a bit more thought
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.44 2017/01/19 09:08:50 phessler Exp $	*/
d671 1
a671 1
	unsigned int		 ver, diag, state, flags;
@


1.44
log
@rtisvalid() checks for RTF_UP, so instead check for RTF_BFD
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.43 2017/01/19 08:55:46 phessler Exp $	*/
d160 1
d567 1
a567 1
			bfd->bc_error++;
d577 10
d603 1
a603 9
	if (++bfd->bc_error >= bfd->bc_neighbor->bn_mult) {
		bfd->bc_neighbor->bn_ldiag = BFD_DIAG_EXPIRED;
		bfd_reset(bfd);
		if (bfd->bc_state > BFD_STATE_DOWN)
			bfd_set_state(bfd, BFD_STATE_DOWN);

		return;
	}

d706 1
a706 1
		bfd->bc_error++;
d897 1
@


1.43
log
@when deconfiguring a BFD session, clear both the RTF_BFD flag on the
route, and the pointer to the route bfd uses
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.42 2017/01/12 16:14:42 mpi Exp $	*/
d905 1
a905 1
	if (!rtisvalid(rt) || !ISSET(rt->rt_flags, RTF_UP)) {
@


1.42
log
@Remove unneeded splsoftnet().

Global data structures are protected by the KERNEL_LOCK() and
route_input() already raises the IPL when it needs it.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.41 2016/09/24 19:29:55 phessler Exp $	*/
d237 1
d251 1
@


1.41
log
@a route message for BFD, so we can notify userland about the status.
currently used on state-transitions.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.40 2016/09/23 14:06:29 phessler Exp $	*/
d276 1
a276 1
/* 
a283 1
	int s;
a285 1
	s = splsoftnet();
a289 1
	splx(s);
a350 1
	int s;
a361 1
s = splsoftnet();
a362 1
splx(s);
a588 1
	int s;
a598 1
	s = splsoftnet();
a599 1
	splx(s);
a804 1
	int s;
a843 1
	s = splsoftnet();
a844 1
	splx(s);
@


1.40
log
@since the kernel ticks are every 10ms, bump our minimum up a little bit.
make it harder to overload the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.39 2016/09/23 12:50:17 phessler Exp $	*/
d595 1
a595 1

d606 4
d855 1
a855 1
//	rt_bfdmsg(bfd);
@


1.39
log
@based on a more careful reading of the spec, we're not allowed to make
decisions on what the "my discriminator" value is from our neighbor.  we
should only copy it and send it back.
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.38 2016/09/23 10:20:20 phessler Exp $	*/
d139 2
a140 2
/* We cannot handle more often than 10ms, so force a minimum */
#define BFD_MINIMUM			10000	/* 10,000 us == 10 ms */
d732 1
a732 1
	/* Local change to the algorithm, we don't accept below 10ms */
@


1.38
log
@only set the diag code when we we decide to fail it, not when the first
problem is seen
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.37 2016/09/23 10:09:07 phessler Exp $	*/
d727 1
a727 7
	if ((bfd->bc_neighbor->bn_rdiscr == 0) &&
	    (ntohl(peer->bfd_my_discriminator) != 0))
		bfd->bc_neighbor->bn_rdiscr = ntohl(peer->bfd_my_discriminator);

	if (bfd->bc_neighbor->bn_rdiscr != ntohl(peer->bfd_my_discriminator))
		goto discard;

a728 1

@


1.37
log
@remove splsoftnet around the socket functions.  if they need it, they
will call it themselves.

also ensure that bfdclear is protected by softnet.

requested by claudio@@ and mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.36 2016/09/20 19:43:56 phessler Exp $	*/
a359 1
		bfd->bc_neighbor->bn_ldiag = BFD_DIAG_PATH_DOWN;
d361 1
@


1.36
log
@properly set our state to down when we initially create the session.

while here, fix the diag code for route-down
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.35 2016/09/20 19:40:53 phessler Exp $	*/
d221 2
a222 1
	int s;
a236 1
	s = splsoftnet();
a247 1
	splx(s);
d284 1
d287 1
d292 1
a327 1
	int s;
a329 1
	s = splsoftnet();
a344 1
	splx(s);
d562 1
a562 1
	int flags, error, s;
a567 1
		s = splsoftnet();
a570 1
			splx(s);
a576 1
	splx(s);
a916 1
	int error, s;
d923 1
a923 5
	s = splsoftnet();
	error = sosend(bfd->bc_sosend, NULL, NULL, m, NULL, MSG_DONTWAIT);
	splx(s);

	return (error);
@


1.35
log
@little bit of whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.34 2016/09/20 19:38:16 phessler Exp $	*/
d209 1
d361 1
a361 1
		bfd->bc_neighbor->bn_ldiag = BFD_DIAG_ADMIN_DOWN;
@


1.34
log
@sprinkle some splsoftnet around sosocket and our soon-to-be-rtmsg locations
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.33 2016/09/19 10:54:18 phessler Exp $	*/
d75 2
a76 2
	uint8_t	bfd_detect_multi;		/* detection time multiplier */
	uint8_t	bfd_length;			/* in bytes */
d198 1
a198 1
	bfd->bc_neighbor->bn_ldiscr = arc4random();	/* XXX - MUST be globally unique */
d691 3
a693 2
	if (peer->bfd_length + offp != mp->m_len) {
		printf("%s: bad len %d != %d\n", __func__, peer->bfd_length + offp, mp->m_len);
d707 2
a708 1
	    (ntohl(peer->bfd_your_discriminator) != bfd->bc_neighbor->bn_ldiscr)) {
@


1.33
log
@sigh, correct typo
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.32 2016/09/19 10:03:40 phessler Exp $	*/
d220 1
d235 1
d247 1
d325 1
d328 1
d344 1
d354 1
d366 1
a366 1

d368 1
d562 1
a562 1
	int flags, error;
d568 1
d572 1
d579 1
d818 1
d858 1
d860 1
d918 1
d925 5
a929 1
	return (sosend(bfd->bc_sosend, NULL, NULL, m, NULL, MSG_DONTWAIT));
@


1.32
log
@do a better job of setting "last state"
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.31 2016/09/19 09:03:41 phessler Exp $	*/
d284 1
a284 1
		bfd->bc_neighbor->bn_ldiag = BFD_DIAG_FIB_DOWN;
@


1.31
log
@send a nice diagnostic reason when we destroy all bfd interfaces (reboot)
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.30 2016/09/19 07:58:57 phessler Exp $	*/
d817 2
a818 2
	bfd->bc_state = bfd->bc_neighbor->bn_lstate = state;
	if (bfd->bc_state > BFD_STATE_ADMINDOWN)
d825 3
a827 1
	case BFD_STATE_ADMINDOWN:	/* FALLTHROUGH */
d829 2
a830 1
		if (bfd->bc_laststate == BFD_STATE_UP)
d832 1
d835 1
d838 3
d845 1
a858 1
	bfd->bc_laststate = bfd->bc_state;
@


1.30
log
@remove a bunch of noisy implementation-helper printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.29 2016/09/19 07:28:40 phessler Exp $	*/
d230 1
a230 1
	/* send suicide packets immediately */
d282 1
a282 1
	/* send suicide packets immediately */
d284 1
@


1.29
log
@once again, fix the bfd state-machine.  this time, tested against a
juniper which rolled through several states during testing
(up->admindown->up->timeout->up)
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.28 2016/09/18 21:00:55 phessler Exp $	*/
a589 1
printf("%s: failed, bfd->bc_error %u\n", __func__, bfd->bc_error);
a624 3
if (bfd->bc_error)
printf("%s: error=%u\n", __func__, bfd->bc_error);

a651 1
printf("%s: localdiscr: %u\n", __func__, bfd->bc_neighbor->bn_ldiscr);
a695 2
printf("%s: peer your discr %u != local %u\n",
    __func__, ntohl(peer->bfd_your_discriminator), bfd->bc_neighbor->bn_ldiscr);
a762 3
printf("%s: BFD_STATE_DOWN remote 0x%x  ", __func__, ntohl(peer->bfd_my_discriminator));
printf("local 0x%x\n", ntohl(peer->bfd_your_discriminator));
bfd_debug(bfd);
a765 1
printf("%s: set BFD_STATE_UP\n", __func__);
a769 3
printf("%s: BFD_STATE_INIT remote 0x%x  ", __func__, ntohl(peer->bfd_my_discriminator));
printf("local 0x%x\n", ntohl(peer->bfd_your_discriminator));

a770 1
printf("%s: set BFD_STATE_UP\n", __func__);
a777 1
printf("%s: set BFD_STATE_DOWN\n", __func__);
a795 1
	//XXX task_add(bfdtq, &bfd->bc_bfd_send_task);	
@


1.28
log
@apply the canary to the correct variable
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.27 2016/09/17 07:35:05 phessler Exp $	*/
a227 1
/* XXX - punt this off to a task */
d359 2
d588 1
a588 2
	if ((bfd->bc_neighbor->bn_lstate > BFD_STATE_DOWN) &&
	    (++bfd->bc_error >= bfd->bc_neighbor->bn_mult)) {
d592 2
a593 1
		bfd_set_state(bfd, BFD_STATE_DOWN);
a610 1
	bfd->bc_neighbor->bn_lstate = BFD_STATE_ADMINDOWN;
d614 1
d642 1
a642 1
	/* Set RFC mandated values */
d646 1
a646 1
	bfd->bc_neighbor->bn_req_minrx = BFD_SECOND; /* rfc5880 6.8.18 */
d648 1
a648 1
	bfd->bc_neighbor->bn_mult = 3; /* XXX - MUST be nonzero */
d653 1
d691 3
a693 1
	if  (ntohl(peer->bfd_my_discriminator) == 0)
a702 2
		bfd->bc_neighbor->bn_ldiag = BFD_DIAG_EXPIRED;
		bfd_senddown(bfd);
d732 3
a734 2
	bfd->bc_neighbor->bn_rminrx =
	    ntohl(peer->bfd_required_min_rx_interval);
d736 1
a736 1
	if (bfd->bc_neighbor->bn_req_minrx < BFD_MINIMUM)
d743 1
a743 1
	if (bfd->bc_neighbor->bn_req_minrx > INT32_MAX)
d745 2
d761 3
a766 1
			bfd->bc_neighbor->bn_lstate = BFD_STATE_DOWN;
d769 1
a769 5
		goto discard;
	}

	/* According the to pseudo-code RFC 5880 page 34 */
	if (bfd->bc_neighbor->bn_lstate == BFD_STATE_DOWN) {
d774 1
a774 1
			bfd->bc_neighbor->bn_lstate = BFD_STATE_INIT;
d809 1
a822 1
	int		 new_state;
a832 2
	bfd_set_uptime(bfd);

d834 2
d840 5
a844 5
	switch (bfd->bc_neighbor->bn_lstate) {
	case BFD_STATE_ADMINDOWN:
		new_state = RTM_BFD;
//		rt->rt_flags &= ~RTF_BFDUP;
//		rt->rt_flags |= RTF_BFDDOWN;
d846 1
a846 4
	case BFD_STATE_DOWN:
		new_state = RTM_BFD;
//		rt->rt_flags &= ~RTF_BFDUP;
//		rt->rt_flags |= RTF_BFDDOWN;
d849 1
a849 3
		new_state = RTM_BFD;
//		rt->rt_flags &= ~RTF_BFDDOWN;
//		rt->rt_flags |= RTF_BFDUP;
d853 1
a853 3
printf("%s: BFD set linkstate %u (oldstate: %u)\n", ifp->if_xname, new_state, state);
	rt_sendmsg(rt, new_state, ifp->if_rdomain);

d887 1
a887 1
	h->bfd_sta_flags = (bfd->bc_neighbor->bn_lstate << 6);
d897 1
a897 2
	h->bfd_required_min_echo_interval =
	    htonl(bfd->bc_neighbor->bn_rminrx);
d913 1
a913 1
	if (!ISSET(rt->rt_flags, RTF_UP)) {
@


1.27
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.26 2016/09/15 08:39:44 phessler Exp $	*/
d888 1
a888 1
	memset(bfd, 0xff, sizeof(*h));	/* canary */
@


1.26
log
@print local and remote discr as decimal, easier to compare with remote systems

while here, play with whitespace for pool_init.
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.25 2016/09/15 07:47:00 phessler Exp $	*/
d143 3
a145 20
/* These spellings and capitalizations match RFC 5880 6.8.1*/
/* Do not change */
struct bfd_state {
	uint32_t	SessionState;
	uint32_t	RemoteSessionState;
	uint32_t	LocalDiscr;	/* Unique identifier */
	uint32_t	RemoteDiscr;	/* Unique identifier */
	uint32_t	LocalDiag;
	uint32_t	RemoteDiag;
	uint32_t	DesiredMinTxInterval;
	uint32_t	RequiredMinRxInterval;
	uint32_t	RemoteMinRxInterval;
	uint32_t	DemandMode;
	uint32_t	RemoteDemandMode;
	uint32_t	DetectMult;	/* Detection Time Multiplier*/
	uint32_t	AuthType;
	uint32_t	RcvAuthSeq;
	uint32_t	XmitAuthSeq;
	uint32_t	AuthSeqKnown;
};
d147 2
a148 2
struct pool	 bfd_pool, bfd_pool_peer, bfd_pool_time;
struct taskq	*bfdtq;
d150 4
a153 4
struct socket	*bfd_listener(struct bfd_softc *, unsigned int);
struct socket	*bfd_sender(struct bfd_softc *, unsigned int);
void		 bfd_input(struct bfd_softc *, struct mbuf *);
void		 bfd_set_state(struct bfd_softc *, int);
d155 1
a155 1
int	 bfd_send(struct bfd_softc *, struct mbuf *);
d164 3
a166 3
void	 bfd_senddown(struct bfd_softc *);
void	 bfd_reset(struct bfd_softc *);
void	 bfd_set_uptime(struct bfd_softc *);
d168 1
a168 1
void	 bfd_debug(struct bfd_softc *);
d170 1
a170 1
TAILQ_HEAD(bfd_queue, bfd_softc)  bfd_queue;
d176 1
a176 1
bfd_rtalloc(struct rtentry *rt)
d178 1
a178 1
	struct bfd_softc	*sc;
d189 15
a203 15
	sc = pool_get(&bfd_pool, PR_WAITOK | PR_ZERO);
	sc->sc_peer = pool_get(&bfd_pool_peer, PR_WAITOK | PR_ZERO);
	sc->sc_time = pool_get(&bfd_pool_time, PR_WAITOK | PR_ZERO);

	sc->sc_rt = rt;
	rtref(sc->sc_rt);	/* we depend on this route not going away */

	microtime(sc->sc_time);
	bfd_reset(sc);
	sc->sc_peer->LocalDiscr = arc4random();	/* XXX - MUST be globally unique */

	if (!timeout_initialized(&sc->sc_timo_rx))
		timeout_set(&sc->sc_timo_rx, bfd_timeout_rx, sc);
	if (!timeout_initialized(&sc->sc_timo_tx))
		timeout_set(&sc->sc_timo_tx, bfd_timeout_tx, sc);
d205 2
a206 2
	task_set(&sc->sc_bfd_task, bfd_start_task, sc);
	task_add(bfdtq, &sc->sc_bfd_task);
d208 1
a208 1
	TAILQ_INSERT_TAIL(&bfd_queue, sc, bfd_next);
d217 1
a217 1
bfd_rtfree(struct rtentry *rt)
d219 1
a219 1
	struct bfd_softc *sc;
d221 1
a221 1
	if ((sc = bfd_lookup(rt)) == NULL)
d224 3
a226 3
	timeout_del(&sc->sc_timo_rx);
	timeout_del(&sc->sc_timo_tx);
	task_del(bfdtq, &sc->sc_bfd_send_task);
d229 1
a229 1
	TAILQ_REMOVE(&bfd_queue, sc, bfd_next);
d232 2
a233 2
	if (rtisvalid(sc->sc_rt))
		bfd_senddown(sc);
d235 1
a235 1
	if (sc->sc_so) {
d237 2
a238 2
		sc->sc_so->so_upcall = NULL;
		soclose(sc->sc_so);
d240 3
a242 3
	if (sc->sc_soecho) {
		sc->sc_soecho->so_upcall = NULL;
		soclose(sc->sc_soecho);
d244 2
a245 2
	if (sc->sc_sosend)
		soclose(sc->sc_sosend);
d247 1
a247 1
	rtfree(sc->sc_rt);
d249 3
a251 3
	pool_put(&bfd_pool_time, sc->sc_time);
	pool_put(&bfd_pool_peer, sc->sc_peer);
	pool_put(&bfd_pool, sc);
d260 4
a263 4
	pool_init(&bfd_pool, sizeof(struct bfd_softc), 0,
	    IPL_SOFTNET, 0, "bfd_softc", NULL);
	pool_init(&bfd_pool_peer, sizeof(struct bfd_state), 0,
	    IPL_SOFTNET, 0, "bfd_softc_peer", NULL);
d265 1
a265 1
	    IPL_SOFTNET, 0, "bfd_softc_time", NULL);
d281 1
a281 1
	struct bfd_softc	*sc;
d284 2
a285 2
	while ((sc = TAILQ_FIRST(&bfd_queue))) {
		bfd_rtfree(sc->sc_rt);
d290 1
a290 1
	pool_destroy(&bfd_pool_peer);
d297 1
a297 1
struct bfd_softc *
d300 1
a300 1
	struct bfd_softc *sc;
d302 3
a304 3
	TAILQ_FOREACH(sc, &bfd_queue, bfd_next) {
		if (sc->sc_rt == rt)
			return (sc);
d321 1
a321 1
	struct bfd_softc	*sc = (struct bfd_softc *)arg;
d324 2
a325 2
	sc->sc_so = bfd_listener(sc, BFD_UDP_PORT_CONTROL);
	if (!sc->sc_so)
d328 2
a329 2
	sc->sc_soecho = bfd_listener(sc, BFD_UDP_PORT_ECHO);
	if (!sc->sc_soecho)
d334 4
a337 4
	sc->sc_sosend = bfd_sender(sc, BFD_UDP_PORT_CONTROL);
	if (sc->sc_sosend) {
		task_set(&sc->sc_bfd_send_task, bfd_send_task, sc);
		task_add(bfdtq, &sc->sc_bfd_send_task);	
d346 2
a347 2
	struct bfd_softc	*sc = (struct bfd_softc *)arg;
	struct rtentry		*rt = sc->sc_rt;
d350 1
a350 1
		bfd_send_control(sc);
d352 5
a356 5
		sc->error++;
		sc->sc_peer->LocalDiag = BFD_DIAG_ADMIN_DOWN;
		if (sc->sc_peer->SessionState > BFD_STATE_DOWN) {
			bfd_reset(sc);
			bfd_set_state(sc, BFD_STATE_DOWN);
d361 2
a362 2
	timeout_add_usec(&sc->sc_timo_tx,
	    sc->mintx * (arc4random_uniform(20) + 70) / 100);
d369 1
a369 1
bfd_listener(struct bfd_softc *sc, unsigned int port)
d372 1
a372 1
	struct rtentry		*rt = sc->sc_rt;
d427 1
a427 1
	so->so_upcallarg = (caddr_t)sc;
d443 1
a443 1
bfd_sender(struct bfd_softc *sc, unsigned int port)
d446 1
a446 1
	struct rtentry		*rt = sc->sc_rt;
d549 1
a549 1
	struct bfd_softc *sc = (struct bfd_softc *)arg;
d560 1
a560 1
			sc->error++;
d564 1
a564 1
			bfd_input(sc, m);
d574 2
a575 2
	struct bfd_softc *sc = v;
	task_add(bfdtq, &sc->sc_bfd_send_task);	
d584 1
a584 1
	struct bfd_softc *sc = v;
d587 6
a592 6
	if ((sc->sc_peer->SessionState > BFD_STATE_DOWN) &&
	    (++sc->error >= sc->sc_peer->DetectMult)) {
		sc->sc_peer->LocalDiag = BFD_DIAG_EXPIRED;
printf("%s: failed, sc->error %u\n", __func__, sc->error);
		bfd_reset(sc);
		bfd_set_state(sc, BFD_STATE_DOWN);
d597 1
a597 1
	timeout_add_usec(&sc->sc_timo_rx, sc->minrx);
d604 1
a604 1
bfd_senddown(struct bfd_softc *sc)
d607 1
a607 1
	if (sc->state < BFD_STATE_INIT)
d610 3
a612 3
	sc->sc_peer->SessionState = BFD_STATE_ADMINDOWN;
	if (sc->sc_peer->LocalDiag == 0)
		sc->sc_peer->LocalDiag = BFD_DIAG_ADMIN_DOWN;
d614 1
a614 1
	bfd_send_control(sc);
d623 1
a623 1
bfd_reset(struct bfd_softc *sc)
d625 2
a626 2
if (sc->error)
printf("%s: error=%u\n", __func__, sc->error);
d629 8
a636 8
	sc->sc_peer->RemoteDiscr = 0;
	sc->sc_peer->DemandMode = 0;
	sc->sc_peer->RemoteDemandMode = 0;
	sc->sc_peer->AuthType = 0;
	sc->sc_peer->RcvAuthSeq = 0;
	sc->sc_peer->XmitAuthSeq = 0;
	sc->sc_peer->AuthSeqKnown = 0;
	sc->sc_peer->LocalDiag = 0;
d638 2
a639 2
	sc->mode = BFD_MODE_ASYNC;
	sc->state = BFD_STATE_DOWN;
d642 10
a651 10
	sc->sc_peer->SessionState = BFD_STATE_DOWN;
	sc->sc_peer->RemoteSessionState = BFD_STATE_DOWN;
	sc->sc_peer->DesiredMinTxInterval = BFD_SECOND;
	sc->sc_peer->RequiredMinRxInterval = BFD_SECOND; /* rfc5880 6.8.18 */
	sc->sc_peer->RemoteMinRxInterval = 1;
	sc->sc_peer->DetectMult = 3; /* XXX - MUST be nonzero */

	sc->mintx = sc->sc_peer->DesiredMinTxInterval;
	sc->minrx = sc->sc_peer->RemoteMinRxInterval;
	sc->multiplier = sc->sc_peer->DetectMult;
d653 2
a654 2
	bfd_set_uptime(sc);
printf("%s: localdiscr: %u\n", __func__, sc->sc_peer->LocalDiscr);
d660 1
a660 1
bfd_input(struct bfd_softc *sc, struct mbuf *m)
d695 2
a696 2
	    (ntohl(peer->bfd_your_discriminator) != sc->sc_peer->LocalDiscr)) {
		sc->error++;
d698 3
a700 3
    __func__, ntohl(peer->bfd_your_discriminator), sc->sc_peer->LocalDiscr);
		sc->sc_peer->LocalDiag = BFD_DIAG_EXPIRED;
		bfd_senddown(sc);
d704 1
a704 1
	if ((flags & BFD_FLAG_A) && sc->sc_peer->AuthType == 0)
d706 1
a706 1
	if (!(flags & BFD_FLAG_A) && sc->sc_peer->AuthType != 0)
d714 1
a714 1
		if (bfd_process_auth(sc, auth) != 0) {
d721 1
a721 1
	if ((sc->sc_peer->RemoteDiscr == 0) &&
d723 1
a723 1
		sc->sc_peer->RemoteDiscr = ntohl(peer->bfd_my_discriminator);
d725 1
a725 1
	if (sc->sc_peer->RemoteDiscr != ntohl(peer->bfd_my_discriminator))
d728 1
a728 1
	sc->sc_peer->RemoteSessionState = state;
d730 1
a730 1
	sc->sc_peer->RemoteMinRxInterval =
d733 1
a733 1
	if (sc->sc_peer->RequiredMinRxInterval < BFD_MINIMUM)
d740 1
a740 1
	if (sc->sc_peer->RequiredMinRxInterval > INT32_MAX)
d742 1
a742 1
	sc->minrx = sc->sc_peer->RequiredMinRxInterval;
d744 1
a744 1
	sc->sc_peer->DesiredMinTxInterval =
d746 2
a747 2
	if (sc->sc_peer->SessionState != BFD_STATE_UP)
		sc->sc_peer->DesiredMinTxInterval = BFD_SECOND;
d749 1
a749 1
	sc->sc_peer->RequiredMinRxInterval =
d753 2
a754 2
	sc->mintx = max(sc->sc_peer->RemoteMinRxInterval,
	    sc->sc_peer->DesiredMinTxInterval);
d756 5
a760 5
	if (sc->sc_peer->RemoteSessionState == BFD_STATE_ADMINDOWN) {
		if (sc->sc_peer->SessionState != BFD_STATE_DOWN) {
			sc->sc_peer->LocalDiag = BFD_DIAG_NEIGHBOR_SIGDOWN;
			sc->sc_peer->SessionState = BFD_STATE_DOWN;
			bfd_set_state(sc, BFD_STATE_DOWN);
d766 1
a766 1
	if (sc->sc_peer->SessionState == BFD_STATE_DOWN) {
d769 4
a772 4
bfd_debug(sc);
		if (sc->sc_peer->RemoteSessionState == BFD_STATE_DOWN)
			sc->sc_peer->SessionState = BFD_STATE_INIT;
		else if (sc->sc_peer->RemoteSessionState == BFD_STATE_INIT) {
d774 2
a775 2
			sc->sc_peer->LocalDiag = 0;
			bfd_set_state(sc, BFD_STATE_UP);
d777 1
a777 1
	} else if (sc->sc_peer->SessionState == BFD_STATE_INIT) {
d781 1
a781 1
		if (sc->sc_peer->RemoteSessionState >= BFD_STATE_INIT) {
d783 2
a784 2
			sc->sc_peer->LocalDiag = 0;
			bfd_set_state(sc, BFD_STATE_UP);
d789 1
a789 1
		if (sc->sc_peer->RemoteSessionState == BFD_STATE_DOWN) {
d791 2
a792 2
			sc->sc_peer->LocalDiag = BFD_DIAG_NEIGHBOR_SIGDOWN;
			bfd_set_state(sc, BFD_STATE_DOWN);
d797 4
a800 4
	if (sc->sc_peer->SessionState == BFD_STATE_UP) {
		sc->sc_peer->LocalDiag = 0;
		sc->sc_peer->DemandMode = 1;
		sc->sc_peer->RemoteDemandMode = (flags & BFD_FLAG_D);
d803 1
a803 1
	sc->error = 0;
d808 2
a809 2
	//XXX task_add(bfdtq, &sc->sc_bfd_send_task);	
	timeout_add_usec(&sc->sc_timo_rx, sc->minrx);
d815 1
a815 1
bfd_set_state(struct bfd_softc *sc, int state)
d818 1
a818 1
	struct rtentry	*rt = sc->sc_rt;
d825 2
a826 2
		sc->error++;
		bfd_reset(sc);
d830 1
a830 1
	bfd_set_uptime(sc);
d832 1
a832 1
	sc->state = sc->sc_peer->SessionState = state;
d835 1
a835 1
		sc->sc_peer->SessionState = BFD_STATE_ADMINDOWN;
d837 1
a837 1
	switch (sc->sc_peer->SessionState) {
d864 1
a864 1
bfd_set_uptime(struct bfd_softc *sc)
d869 3
a871 3
	sc->lastuptime = tv.tv_sec - sc->sc_time->tv_sec;
	sc->laststate = sc->state;
	memcpy(sc->sc_time, &tv, sizeof(tv));
d877 1
a877 1
	struct bfd_softc	*sc = x;
d879 1
a879 1
	struct bfd_header	*bfd;
d886 1
a886 1
	bfd = mtod(m, struct bfd_header *);
d888 1
a888 1
	memset(bfd, 0xff, sizeof(*bfd));	/* canary */
d890 13
a902 13
	bfd->bfd_ver_diag = ((BFD_VERSION << 5) | (sc->sc_peer->LocalDiag));
	bfd->bfd_sta_flags = (sc->sc_peer->SessionState << 6);
	bfd->bfd_detect_multi = sc->sc_peer->DetectMult;
	bfd->bfd_length = BFD_HDRLEN;
	bfd->bfd_my_discriminator = htonl(sc->sc_peer->LocalDiscr);
	bfd->bfd_your_discriminator = htonl(sc->sc_peer->RemoteDiscr);

	bfd->bfd_desired_min_tx_interval =
	    htonl(sc->sc_peer->DesiredMinTxInterval);
	bfd->bfd_required_min_rx_interval =
	    htonl(sc->sc_peer->RequiredMinRxInterval);
	bfd->bfd_required_min_echo_interval =
	    htonl(sc->sc_peer->RemoteMinRxInterval);
d904 1
a904 1
	error = bfd_send(sc, m);
d914 1
a914 1
bfd_send(struct bfd_softc *sc, struct mbuf *m)
d916 1
a916 1
	struct rtentry *rt = sc->sc_rt;
d923 1
a923 1
	return (sosend(sc->sc_sosend, NULL, NULL, m, NULL, MSG_DONTWAIT));
d930 1
a930 1
bfd_debug(struct bfd_softc *sc)
d932 1
a932 1
	struct rtentry	*rt = sc->sc_rt;
d941 6
a946 6
	printf("session state: %u ", sc->state);
	printf("mode: %u ", sc->mode);
	printf("error: %u ", sc->error);
	printf("minrx: %u ", sc->minrx);
	printf("mintx: %u ", sc->mintx);
	printf("multiplier: %u ", sc->multiplier);
d949 2
a950 2
	printf("local session state: %u ", sc->sc_peer->SessionState);
	printf("local diag: %u ", sc->sc_peer->LocalDiag);
d953 2
a954 2
	printf("remote discriminator: %u ", sc->sc_peer->RemoteDiscr);
	printf("local discriminator: %u ", sc->sc_peer->LocalDiscr);
d957 3
a959 3
	printf("remote session state: %u ", sc->sc_peer->RemoteSessionState);
	printf("remote diag: %u ", sc->sc_peer->RemoteDiag);
	printf("remote min rx: %u ", sc->sc_peer->RemoteMinRxInterval);
d962 1
a962 1
	printf("last state: %u ", sc->laststate);
d964 4
a967 4
	printf("uptime %llds ", tv.tv_sec - sc->sc_time->tv_sec);
	printf("time started %lld.%06ld ", sc->sc_time->tv_sec,
	    sc->sc_time->tv_usec);
	printf("last uptime %llds ", sc->lastuptime);
@


1.25
log
@chase dlg@@'s change of merging pool_setipl into pool_init
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.24 2016/09/13 07:56:05 phessler Exp $	*/
d277 6
a282 6
	pool_init(&bfd_pool, sizeof(struct bfd_softc), 0, IPL_SOFTNET, 0,
	    "bfd_softc", NULL);
	pool_init(&bfd_pool_peer, sizeof(struct bfd_state), 0, IPL_SOFTNET, 0,
	    "bfd_softc_peer", NULL);
	pool_init(&bfd_pool_time, sizeof(struct timeval), 0, IPL_SOFTNET, 0,
	    "bfd_softc_time", NULL);
d671 1
a671 1
printf("%s: localdiscr: 0x%x\n", __func__, sc->sc_peer->LocalDiscr);
d714 1
a714 1
printf("%s: peer your discr 0x%x != local 0x%x\n",
d970 2
a971 2
	printf("remote discriminator: 0x%x ", sc->sc_peer->RemoteDiscr);
	printf("local discriminator: 0x%x ", sc->sc_peer->LocalDiscr);
@


1.24
log
@we no longer reach around and call DDB specific functions, so always
define bfd_debug() especially since we use it in a lot of places right now
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.23 2016/09/12 15:24:51 phessler Exp $	*/
d277 1
a277 1
	pool_init(&bfd_pool, sizeof(struct bfd_softc), 0, 0, 0,
d279 1
a279 2
	pool_setipl(&bfd_pool, IPL_SOFTNET);
	pool_init(&bfd_pool_peer, sizeof(struct bfd_state), 0, 0, 0,
d281 1
a281 2
	pool_setipl(&bfd_pool_peer, IPL_SOFTNET);
	pool_init(&bfd_pool_time, sizeof(struct timeval), 0, 0, 0,
a282 1
	pool_setipl(&bfd_pool_time, IPL_SOFTNET);
@


1.23
log
@Add data about how long the session has been in the current state, and
the previous state.

Shuffle some headers so they can be used outside of our own engine.

While here, correct the spelling of the two modes for BFD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.22 2016/09/10 05:39:38 jsg Exp $	*/
a184 1
#ifdef DDB
a185 2
#endif

a945 1
#ifdef DDB
a989 1
#endif /* DDB */
@


1.22
log
@Remove a semicolon after an if statement that resulted in
bfd_senddown() always returning before the rest of the function
could run.  Found with clang.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.21 2016/09/07 09:23:07 mpi Exp $	*/
a100 3
#define BFD_MODE_ACTIVE		1
#define BFD_MODE_PASSIVE	2

d164 1
a164 1
struct pool	 bfd_pool, bfd_pool_peer;
a166 1
struct bfd_softc *bfd_lookup(struct rtentry *);
d183 1
d211 1
d216 1
d269 1
d286 3
d312 2
a314 1
	pool_destroy(&bfd_pool_peer);
a317 6
 * End of public interfaces.
 *
 * Everything below this line should not be used outside of this file.
 */

/*
d333 6
d661 1
a661 1
	sc->mode = BFD_MODE_ACTIVE;
d675 2
d783 1
d852 4
a855 1
	sc->sc_peer->SessionState = state;
d887 11
a948 2


d957 1
d960 2
a961 2
	printf("dest: %s\n", sockaddr_ntop(rt_key(rt), buf, sizeof(buf)));
	printf("src: %s\n", sockaddr_ntop(rt->rt_ifa->ifa_addr, buf,
d963 2
d973 1
a973 1
	printf("session state: %u ", sc->sc_peer->SessionState);
d984 8
@


1.21
log
@Do not check for NULL after calling an allocator with WAITOK.

All allocations are done during ioctl() so it is safe to sleep.

ok claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.20 2016/09/07 09:21:33 mpi Exp $	*/
d626 1
a626 1
	if (sc->state < BFD_STATE_INIT);
@


1.20
log
@Use C99 types.

ok claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.19 2016/09/04 17:12:00 claudio Exp $	*/
d212 2
a213 5
	if ((sc = pool_get(&bfd_pool, PR_WAITOK | PR_ZERO)) == NULL)
		goto fail;
	if ((sc->sc_peer = pool_get(&bfd_pool_peer, PR_WAITOK | PR_ZERO)) ==
	    NULL)
		goto fail;
a231 7

fail:
	if (sc->sc_peer)
		pool_put(&bfd_pool_peer, sc->sc_peer);
	if (sc)
		pool_put(&bfd_pool, sc);
	return (ENOMEM);
@


1.19
log
@Refactor the code an fix a few issues by doing so.
- Use rt_key() instead of rt_gwroute / rt_gateway since bfd runs on host routes
- Fixup the timeout / task interaction a bit (still broken but better)
- fix panics in bfd_rtfree when calling soclose().
  It is required to clear the upcall before calling soclose() because sorflush()
  would be calling the upcall again which then results in a reenter panic.
- Simplify the mbuf dance a bit in bfd_send_control()
With and OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.18 2016/09/04 13:24:27 claudio Exp $	*/
d72 2
a73 2
	u_int8_t	bfd_ver_diag;
	u_int8_t	bfd_sta_flags;
d75 7
a81 7
	u_int8_t	bfd_detect_multi;		/* detection time multiplier */
	u_int8_t	bfd_length;			/* in bytes */
	u_int32_t	bfd_my_discriminator;		/* From this system */
	u_int32_t	bfd_your_discriminator;		/* Received */
	u_int32_t	bfd_desired_min_tx_interval;	/* in microseconds */
	u_int32_t	bfd_required_min_rx_interval;	/* in microseconds */
	u_int32_t	bfd_required_min_echo_interval;	/* in microseconds */
d86 3
a88 3
	u_int8_t	bfd_auth_type;
	u_int8_t	bfd_auth_len;
	u_int16_t	bfd_auth_data;
d149 16
a164 16
	u_int32_t	SessionState;
	u_int32_t	RemoteSessionState;
	u_int32_t	LocalDiscr;	/* Unique identifier */
	u_int32_t	RemoteDiscr;	/* Unique identifier */
	u_int32_t	LocalDiag;
	u_int32_t	RemoteDiag;
	u_int32_t	DesiredMinTxInterval;
	u_int32_t	RequiredMinRxInterval;
	u_int32_t	RemoteMinRxInterval;
	u_int32_t	DemandMode;
	u_int32_t	RemoteDemandMode;
	u_int32_t	DetectMult;	/* Detection Time Multiplier*/
	u_int32_t	AuthType;
	u_int32_t	RcvAuthSeq;
	u_int32_t	XmitAuthSeq;
	u_int32_t	AuthSeqKnown;
d171 2
a172 2
struct socket	*bfd_listener(struct bfd_softc *, u_int);
struct socket	*bfd_sender(struct bfd_softc *, u_int);
d398 1
a398 1
bfd_listener(struct bfd_softc *sc, u_int port)
d472 1
a472 1
bfd_sender(struct bfd_softc *sc, u_int port)
d692 1
a692 1
	u_int			 ver, diag, state, flags;
@


1.18
log
@Only allow bfd on host routes and non-gateway routes for now.
Also just use bfd_lookup() instead of handrolling the same lookup.
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.17 2016/09/04 11:34:56 claudio Exp $	*/
a189 1
extern void db_print_sa(struct sockaddr *);	/* XXX - sys/net/route.c */
d266 3
a268 1
	if (sc->sc_so)
d270 3
a272 1
	if (sc->sc_soecho)
d274 1
d376 1
d378 10
a387 4
	/* add 70%-90% jitter to our transmits, rfc 5880 6.8.7 */
	if (!timeout_pending(&sc->sc_timo_tx))
		timeout_add_usec(&sc->sc_timo_tx,
		    sc->mintx * (arc4random_uniform(20) + 70) / 100);
d389 3
a391 1
	return;
d403 1
a403 1
	struct sockaddr		*dst = rt->rt_gateway;
d479 1
a479 1
	struct sockaddr		*dst = rt->rt_gateway;
d603 2
a604 18
	struct bfd_softc	*sc = v;
	struct rtentry		*rt = sc->sc_rt;

	if (ISSET(rt->rt_gwroute->rt_flags, RTF_UP)) {
		bfd_send_control(sc);
	} else {
		sc->error++;
		sc->sc_peer->LocalDiag = BFD_DIAG_ADMIN_DOWN;
		if (sc->sc_peer->SessionState > BFD_STATE_DOWN) {
			bfd_reset(sc);
			bfd_set_state(sc, BFD_STATE_DOWN);
		}
	}

	/* add 70%-90% jitter to our transmits, rfc 5880 6.8.7 */
	if (!timeout_pending(&sc->sc_timo_tx))
		timeout_add_usec(&sc->sc_timo_tx,
		    sc->mintx * (arc4random_uniform(20) + 70) / 100);
a626 1

d834 1
a834 1
	task_add(bfdtq, &sc->sc_bfd_send_task);	
d891 1
a891 1
	struct bfd_header	bfd;
d897 2
a898 1
	m->m_len = m->m_pkthdr.len = sizeof(bfd);
d900 1
a900 1
	memset(&bfd, 0xff, sizeof(bfd));	/* canary */
d902 6
a907 6
	bfd.bfd_ver_diag = ((BFD_VERSION << 5) | (sc->sc_peer->LocalDiag));
	bfd.bfd_sta_flags = (sc->sc_peer->SessionState << 6);
	bfd.bfd_detect_multi = sc->sc_peer->DetectMult;
	bfd.bfd_length = BFD_HDRLEN;
	bfd.bfd_my_discriminator = htonl(sc->sc_peer->LocalDiscr);
	bfd.bfd_your_discriminator = htonl(sc->sc_peer->RemoteDiscr);
d909 1
a909 1
	bfd.bfd_desired_min_tx_interval =
d911 1
a911 1
	bfd.bfd_required_min_rx_interval =
d913 1
a913 1
	bfd.bfd_required_min_echo_interval =
a915 2
	m_copyback(m, 0, BFD_HDRLEN, &bfd, M_NOWAIT);

d930 2
a931 2
	if (!ISSET(rt->rt_gwroute->rt_flags, RTF_UP)) {
		m_free(m);
a940 1

a946 1
	struct ifnet	*ifp;
d948 1
d950 3
a952 8
	ifp = if_get(rt->rt_ifidx);

	if (ifp == NULL) {
	printf("%s: cannot find interface index %u\n",
	    __func__, rt->rt_ifidx);
		return;
	}

a972 2

	if_put(ifp);
@


1.17
log
@Grab a reference to the route and free it once no longer needed.
Also free all sockets in bfd_rtfree(). Agreement with phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.16 2016/09/04 09:39:01 claudio Exp $	*/
d204 4
d209 2
a210 6
	TAILQ_FOREACH(sc, &bfd_queue, bfd_next) {
		if (sc->sc_rt == rt)
			return (EADDRINUSE);
	}

	/* XXX - do we need to force RTM_RESOLVE? */
@


1.16
log
@Make it possible to toggle RTF_BFD via RTM_CHANGE and fix some minor things
in bfd.c. Make bfd_rtfree() a void function.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.15 2016/09/03 22:51:15 phessler Exp $	*/
d220 1
a220 1
//	rtref(sc->sc_rt);	/* we depend on this route not going away */
d269 4
a272 1
	sc->sc_so = NULL;
d274 1
a274 1
//	rtfree(sc->sc_rt);
@


1.15
log
@handle the remaining bits of the packet we are sent
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.14 2016/09/03 22:24:43 phessler Exp $	*/
d200 1
a200 1
bfd_rtalloc(struct rtentry *rt, struct bfd_flags *flags)
d214 4
a217 3
		goto nomem;
	if ((sc->sc_peer = pool_get(&bfd_pool_peer, PR_WAITOK | PR_ZERO)) == NULL)
		goto nomem2;
a229 2
	TAILQ_INSERT_TAIL(&bfd_queue, sc, bfd_next);

d233 2
d237 5
a241 4
	pool_put(&bfd_pool_peer, sc);
 nomem2:
	pool_put(&bfd_pool, sc);
 nomem:
d248 1
a248 1
int
d254 1
a254 1
		return (ENOENT);
d267 2
a268 2
	soclose(sc->sc_so);
//	sc->sc_so->so_upcall = NULL;
d270 3
a274 2

	return (0);
@


1.14
log
@only clear the error counter if we are successful, not if we get
partially through processing
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.13 2016/09/03 21:01:42 phessler Exp $	*/
a753 1
	sc->sc_peer->RemoteMinRxInterval = ntohl(peer->bfd_required_min_rx_interval);
d755 2
d758 1
a758 1
	if (sc->sc_peer->RemoteMinRxInterval < BFD_MINIMUM)
a759 1

d765 1
a765 1
	if (sc->sc_peer->RemoteMinRxInterval > INT32_MAX)
d767 9
a776 1
	sc->minrx = sc->sc_peer->RequiredMinRxInterval;
@


1.13
log
@handle timer limitations
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.12 2016/09/03 20:35:07 phessler Exp $	*/
a753 1
	sc->error = 0;
d819 1
@


1.12
log
@we really should ntohl fields coming in from the network
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.11 2016/09/03 20:02:49 phessler Exp $	*/
d31 1
d757 1
d759 1
a759 1
		sc->sc_peer->RemoteMinRxInterval = BFD_MINIMUM;
d761 7
a767 5
	if (sc->sc_peer->RemoteMinRxInterval > 30 * BFD_SECOND) {
printf("%s: RemoteMinRxInterval is massive: %u\n", __func__,
    sc->sc_peer->RemoteMinRxInterval);
		sc->sc_peer->RemoteMinRxInterval = BFD_SECOND;
	}
@


1.11
log
@jsg@@ also found some uninitialized variables, thank you!
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.10 2016/09/03 19:55:42 phessler Exp $	*/
d754 1
a754 1
	sc->sc_peer->RemoteMinRxInterval = peer->bfd_required_min_rx_interval;
@


1.10
log
@in order to avoid problems with precise timing, obey rfc 5880 section 6.8.7,
and jitter the sender by 70%-90% of the requested tx time
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.9 2016/09/03 19:17:49 phessler Exp $	*/
d388 1
a388 1
	struct mbuf		*m, *mopt;
d457 1
a457 1
	struct mbuf		*m, *mopt;
d738 2
a739 1
		if (bfd_process_auth(sc, auth) != 0)
d741 1
@


1.9
log
@if_get requires the corresponding if_put call.
while here, check that if_get was successful

noticed by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.8 2016/09/03 16:56:13 phessler Exp $	*/
d366 1
d368 2
a369 1
		timeout_add_usec(&sc->sc_timo_tx, sc->mintx);
d597 1
a597 2
	/* XXX - we're getting lucky with timing, need a better mechanism */
printf("%s: timeout_tx: %u\n", __func__, sc->mintx);
d599 2
a600 1
		timeout_add_usec(&sc->sc_timo_tx, sc->mintx);
@


1.8
log
@remove testing printf that snuck in accidentally.

while here, bump an error counter if we cannot receive a packet
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.7 2016/09/03 16:47:26 phessler Exp $	*/
d830 7
d863 2
d936 6
d962 2
@


1.7
log
@instead of doing everything manually, use goto cleanup idiom
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.6 2016/09/03 16:45:27 phessler Exp $	*/
a560 1
printf("%s: packet\n", __func__);
d567 1
a567 2
			/* XXX - handle errors */
printf("%s soreceive error %d\n", __func__, error);
@


1.6
log
@check the TTL field for incoming packets, we only support directly
connected neighbors
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.5 2016/09/03 15:49:00 phessler Exp $	*/
a429 1
		soclose(so);
d432 1
a432 1
		return (NULL);
@


1.5
log
@remove a bunch of printf-debugging output and commented lines
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.4 2016/09/03 15:07:22 phessler Exp $	*/
d386 2
a387 2
	struct mbuf		*m;
	int error;
d399 12
d439 6
d487 1
a487 1
	*ip = 255;	/* XXX - use a #define */
a548 1

d562 1
a697 6

#if 0
	/* XXX check TTL security */
	if (peer->ttl != MAXTTL)
		goto discard;
#endif
@


1.4
log
@remove spl-dance.  the functions we are protecting already do that.

reminded by and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.3 2016/09/03 15:06:11 phessler Exp $	*/
a339 6
//struct rtentry		*rt = sc->sc_rt;
//struct ifnet		*ifp;

//ifp = if_get(rt->rt_ifidx);
//printf("%s: if %s dest: ", __func__, ifp->if_xname);
//db_print_sa(rt->rt_ifa->ifa_addr);
a364 5
//struct rtentry		*rt = sc->sc_rt;
//struct ifnet		*ifp;

//ifp = if_get(rt->rt_ifidx);
//printf("%s: if %s dest: ", __func__, ifp->if_xname);
a365 3
//bfd_debug(sc);
//	bfd_send_control(sc);
printf("%s: timeout_tx: %u\n", __func__, sc->mintx);
a592 1
//	struct rtentry	*rt = sc->sc_rt;
d595 2
a596 5
bfd_debug(sc);

	if (((sc->sc_peer->SessionState > BFD_STATE_DOWN) &&
	    (++sc->error >= sc->sc_peer->DetectMult)) /* ||
		(!ISSET(rt->rt_gwroute->rt_flags, RTF_UP)) */) {
a603 1
printf("%s: error #%u\n", __func__, sc->error);
a604 1
printf("%s: timeout_rx: %u\n", __func__, sc->minrx);
a614 3
printf("%s", __func__);
//bfd_debug(sc);

a621 1
printf("%s: sc->sc_peer->LocalDiag %u", __func__, sc->sc_peer->LocalDiag);
a656 4
//	sc->sc_peer->LocalDiscr = arc4random();	/* XXX - MUST be globally unique */
//	sc->sc_peer->RcvAuthSeq = arc4random();

//	sc->ttl = MAXTTL;
a756 1
//printf("%s1 \n", __func__);
a764 2
//printf("%s2 \n", __func__);

a785 1
//printf("%s2b \n", __func__);
a795 1
//printf("%s3 \n", __func__);
a916 6

//	printf("%s if: %s AF: %x ",
//	    __func__, ifp->if_xname,
//	    rt->rt_gateway->sa_family);
//printf("gw: "); db_print_sa(rt->rt_gateway);
//	printf("\n");
@


1.3
log
@use the correct size for the pool we are init'ing

pointed out by and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.2 2016/09/03 15:05:25 phessler Exp $	*/
a300 1
	int			 s;
a306 2
	s = splsoftnet();

a309 2

	splx(s);
d458 1
a458 1
	int		 error, s, *ip;
a463 1
	s = splsoftnet();
a464 1
	splx(s);
a507 1
	s = splsoftnet();
a508 1
	splx(s);
a528 1
	s = splsoftnet();
a529 2
	splx(s);

@


1.2
log
@Remove comments about taskq flags we want to eventually run with.
that'll take quite some time to get to.

pointed out by and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.c,v 1.1 2016/09/03 14:14:20 phessler Exp $	*/
d282 1
a282 1
	pool_init(&bfd_pool_peer, sizeof(struct bfd_softc), 0, 0, 0,
@


1.1
log
@add support for Bidirectional Forwarding Detection (RFC 5880/5881).
This is only the engine, the glue will come soon.

We can negotiate a BFD session against a Juniper MX, and against
ourselves.

Requires a lot of cleanup, but we can do that in the tree.

discussed with the network hackers
OK claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d286 1
a286 2
	/* XXX - requires biglock because of sobind */
	bfdtq = taskq_create("bfd", 1, IPL_SOFTNET, 0 /* | TASKQ_MPSAFE */);
@

