head	1.55;
access;
symbols
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.48.0.6
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.4
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.31.0.16
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.12
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.14
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.10
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.8
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.6
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.4
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.4
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6;
locks; strict;
comment	@ * @;


1.55
date	2017.01.20.05.03.48;	author claudio;	state Exp;
branches;
next	1.54;
commitid	Q27bfMOYZAZ4a7pL;

1.54
date	2017.01.11.08.47.48;	author mpi;	state Exp;
branches;
next	1.53;
commitid	AJ9PmR6uM0vXGXzV;

1.53
date	2016.10.03.12.26.13;	author rzalamena;	state Exp;
branches;
next	1.52;
commitid	599KriAM2Xmcdmg8;

1.52
date	2016.09.29.11.37.44;	author reyk;	state Exp;
branches;
next	1.51;
commitid	TXqeFb76AWQD8eLy;

1.51
date	2016.09.03.13.46.57;	author reyk;	state Exp;
branches;
next	1.50;
commitid	3QjHFZLzmkdTcUlc;

1.50
date	2016.09.02.10.01.36;	author goda;	state Exp;
branches;
next	1.49;
commitid	CnmnHsRybZkqp1q2;

1.49
date	2016.09.01.10.06.33;	author goda;	state Exp;
branches;
next	1.48;
commitid	53X2QcUepPKjCjvt;

1.48
date	2015.12.01.18.28.29;	author goda;	state Exp;
branches;
next	1.47;
commitid	6ZruJ8AlaPn1cF8H;

1.47
date	2015.11.28.15.21.45;	author yasuoka;	state Exp;
branches;
next	1.46;
commitid	4hife1MpTz9UOICA;

1.46
date	2015.11.07.12.42.19;	author mpi;	state Exp;
branches;
next	1.45;
commitid	3n9C29EcvMo1935D;

1.45
date	2015.08.24.21.28.47;	author bluhm;	state Exp;
branches;
next	1.44;
commitid	FmknfKH1sTvQ2vzt;

1.44
date	2015.07.02.09.40.02;	author mpi;	state Exp;
branches;
next	1.43;
commitid	eKXa0TkOIth1tkBS;

1.43
date	2015.06.23.09.42.23;	author mpi;	state Exp;
branches;
next	1.42;
commitid	p9JxIlTsQMWvTdAT;

1.42
date	2015.04.12.09.57.54;	author dlg;	state Exp;
branches;
next	1.41;
commitid	BtLjuNCz8HMw1Ud8;

1.41
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	VK3ncyiP3NS1N4Sy;

1.40
date	2014.12.22.03.38.01;	author tedu;	state Exp;
branches;
next	1.39;
commitid	2s9cV5abDgo3vkqh;

1.39
date	2013.10.13.12.09.54;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2013.10.13.10.10.03;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.23.13.28.36;	author camield;	state Exp;
branches;
next	1.36;

1.36
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.35;

1.35
date	2012.09.20.14.10.18;	author mpf;	state Exp;
branches;
next	1.34;

1.34
date	2010.11.20.14.23.09;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2010.10.31.15.14.30;	author mpf;	state Exp;
branches;
next	1.32;

1.32
date	2010.10.28.13.49.54;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.11.22.11.48;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.03.13.41.19;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.28.00.33.04;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.09.19.44.22;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.23.09.32.55;	author camield;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.03.14.55.58;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.15.03.41.15;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.25.09.41.18;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.18.42.56;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.30.21.15.41;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.30.20.08.34;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.09.10.11.52;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.04.15.44.21;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.08.17.49.43;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.15.08.40.56;	author jason;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.06.09.06.16.37;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.22.03.48.29;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.12.03.41.22;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.25.22.06.27;	author jason;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.01.10.22.18.29;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	99.09.03.12.47.12;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	99.09.01.21.38.48;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	99.08.08.02.42.58;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.03.19.22.47.33;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.03.19.02.46.54;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.03.12.02.40.43;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.03.05.21.10.52;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.04.44.44;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.17.01.32;	author jason;	state Exp;
branches;
next	;

1.12.2.1
date	2001.05.14.22.40.00;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.07.04.10.53.57;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Stop using pfsockaddr_union outside of pf so that we can remove its usage
inside pf later on. pfsync can use the one from ip_ipsp.h and bridge can
have its own version for now.
OK mpi@@ phessler@@
@
text
@/*	$OpenBSD: if_bridge.h,v 1.54 2017/01/11 08:47:48 mpi Exp $	*/

/*
 * Copyright (c) 1999, 2000 Jason L. Wright (jason@@thought.net)
 * Copyright (c) 2006 Andrew Thompson (thompsa@@FreeBSD.org)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#ifndef _NET_IF_BRIDGE_H_
#define _NET_IF_BRIDGE_H_

#include <sys/timeout.h>
#include <net/pfvar.h>

/*
 * Bridge control request: add/delete member interfaces.
 */
struct ifbreq {
	char		ifbr_name[IFNAMSIZ];	/* bridge ifs name */
	char		ifbr_ifsname[IFNAMSIZ];	/* member ifs name */
	u_int32_t	ifbr_ifsflags;		/* member ifs flags */
	u_int32_t	ifbr_portno;		/* member port number */

	u_int8_t	ifbr_state;		/* member stp state */
	u_int8_t	ifbr_priority;		/* member stp priority */
	u_int32_t	ifbr_path_cost;		/* member stp path cost */
	u_int32_t	ifbr_stpflags;          /* member stp flags */
	u_int8_t	ifbr_proto;		/* member stp protocol */
	u_int8_t	ifbr_role;		/* member stp role */
	u_int32_t	ifbr_fwd_trans;		/* member stp fwd transitions */
	u_int64_t	ifbr_desg_bridge;	/* member stp designated bridge */
	u_int32_t	ifbr_desg_port;		/* member stp designated port */
	u_int64_t	ifbr_root_bridge;	/* member stp root bridge */
	u_int32_t	ifbr_root_cost;		/* member stp root cost */
	u_int32_t	ifbr_root_port;		/* member stp root port */
};

/* SIOCBRDGIFFLGS, SIOCBRDGIFFLGS */
#define	IFBIF_LEARNING		0x0001	/* ifs can learn */
#define	IFBIF_DISCOVER		0x0002	/* ifs sends packets w/unknown dest */
#define	IFBIF_BLOCKNONIP	0x0004	/* ifs blocks non-IP/ARP in/out */
#define	IFBIF_STP		0x0008	/* ifs participates in spanning tree */
#define IFBIF_BSTP_EDGE		0x0010	/* member stp edge port */
#define IFBIF_BSTP_AUTOEDGE	0x0020  /* member stp autoedge enabled */
#define IFBIF_BSTP_PTP		0x0040  /* member stp ptp */
#define IFBIF_BSTP_AUTOPTP	0x0080	/* member stp autoptp enabled */
#define	IFBIF_SPAN		0x0100	/* ifs is a span port (ro) */
#define	IFBIF_LOCAL		0x1000	/* local port in switch(4) */
#define	IFBIF_RO_MASK		0x0f00	/* read only bits */

/* SIOCBRDGFLUSH */
#define	IFBF_FLUSHDYN	0x0	/* flush dynamic addresses only */
#define	IFBF_FLUSHALL	0x1	/* flush all addresses from cache */

/* port states */
#define	BSTP_IFSTATE_DISABLED	0
#define	BSTP_IFSTATE_LISTENING	1
#define	BSTP_IFSTATE_LEARNING	2
#define	BSTP_IFSTATE_FORWARDING	3
#define	BSTP_IFSTATE_BLOCKING	4
#define	BSTP_IFSTATE_DISCARDING	5

#define	BSTP_TCSTATE_ACTIVE	1
#define	BSTP_TCSTATE_DETECTED	2
#define	BSTP_TCSTATE_INACTIVE	3
#define	BSTP_TCSTATE_LEARNING	4
#define	BSTP_TCSTATE_PROPAG	5
#define	BSTP_TCSTATE_ACK	6
#define	BSTP_TCSTATE_TC		7
#define	BSTP_TCSTATE_TCN	8

#define	BSTP_ROLE_DISABLED	0
#define	BSTP_ROLE_ROOT		1
#define	BSTP_ROLE_DESIGNATED	2
#define	BSTP_ROLE_ALTERNATE	3
#define	BSTP_ROLE_BACKUP	4

/*
 * Interface list structure
 */
struct ifbifconf {
	char		ifbic_name[IFNAMSIZ];	/* bridge ifs name */
	u_int32_t	ifbic_len;		/* buffer size */
	union {
		caddr_t	ifbicu_buf;
		struct	ifbreq *ifbicu_req;
	} ifbic_ifbicu;
#define	ifbic_buf	ifbic_ifbicu.ifbicu_buf
#define	ifbic_req	ifbic_ifbicu.ifbicu_req
};

/*
 * Bridge address request
 */
struct ifbareq {
	char			ifba_name[IFNAMSIZ];	/* bridge name */
	char			ifba_ifsname[IFNAMSIZ];	/* destination ifs */
	u_int8_t		ifba_age;		/* address age */
	u_int8_t		ifba_flags;		/* address flags */
	struct ether_addr	ifba_dst;		/* destination addr */
	struct sockaddr_storage	ifba_dstsa;		/* tunnel endpoint */
};

#define	IFBAF_TYPEMASK		0x03		/* address type mask */
#define	IFBAF_DYNAMIC		0x00		/* dynamically learned */
#define	IFBAF_STATIC		0x01		/* static address */

struct ifbaconf {
	char			ifbac_name[IFNAMSIZ];	/* bridge ifs name */
	u_int32_t		ifbac_len;		/* buffer size */
	union {
		caddr_t	ifbacu_buf;			/* buffer */
		struct ifbareq *ifbacu_req;		/* request pointer */
	} ifbac_ifbacu;
#define	ifbac_buf	ifbac_ifbacu.ifbacu_buf
#define	ifbac_req	ifbac_ifbacu.ifbacu_req
};

struct ifbrparam {
	char			ifbrp_name[IFNAMSIZ];
	union {
		u_int32_t	ifbrpu_csize;		/* cache size */
		int		ifbrpu_ctime;		/* cache time (sec) */
		u_int16_t	ifbrpu_prio;		/* bridge priority */
		u_int8_t	ifbrpu_hellotime;	/* hello time (sec) */
		u_int8_t	ifbrpu_fwddelay;	/* fwd delay (sec) */
		u_int8_t	ifbrpu_maxage;		/* max age (sec) */
		u_int8_t	ifbrpu_proto;		/* bridge protocol */
		u_int8_t	ifbrpu_txhc;		/* bpdu tx holdcount */
		u_int64_t	ifbrpu_datapath;	/* datapath-id */
		u_int32_t	ifbrpu_maxgroup;	/* group size */
	} ifbrp_ifbrpu;
};
#define	ifbrp_csize	ifbrp_ifbrpu.ifbrpu_csize
#define	ifbrp_ctime	ifbrp_ifbrpu.ifbrpu_ctime
#define	ifbrp_prio	ifbrp_ifbrpu.ifbrpu_prio
#define	ifbrp_proto	ifbrp_ifbrpu.ifbrpu_proto
#define	ifbrp_txhc	ifbrp_ifbrpu.ifbrpu_txhc
#define	ifbrp_hellotime	ifbrp_ifbrpu.ifbrpu_hellotime
#define	ifbrp_fwddelay	ifbrp_ifbrpu.ifbrpu_fwddelay
#define	ifbrp_maxage	ifbrp_ifbrpu.ifbrpu_maxage
#define	ifbrp_datapath	ifbrp_ifbrpu.ifbrpu_datapath
#define	ifbrp_maxflow	ifbrp_ifbrpu.ifbrpu_csize
#define	ifbrp_maxgroup	ifbrp_ifbrpu.ifbrpu_maxgroup

/* Protocol versions */
#define	BSTP_PROTO_ID		0x00
#define	BSTP_PROTO_STP		0x00
#define	BSTP_PROTO_RSTP		0x02
#define	BSTP_PROTO_MAX		BSTP_PROTO_RSTP

/*
 * Bridge current operational parameters structure.
 */
struct ifbropreq {
	char		ifbop_name[IFNAMSIZ];
	u_int8_t	ifbop_holdcount;
	u_int8_t	ifbop_maxage;
	u_int8_t	ifbop_hellotime;
	u_int8_t	ifbop_fwddelay;
	u_int8_t	ifbop_protocol;
	u_int16_t	ifbop_priority;
	u_int64_t	ifbop_root_bridge;
	u_int16_t	ifbop_root_port;
	u_int32_t	ifbop_root_path_cost;
	u_int64_t	ifbop_desg_bridge;
	struct timeval	ifbop_last_tc_time;
};

/*
 * Bridge mac rules
 */
struct ifbrlreq {
	char			ifbr_name[IFNAMSIZ];	/* bridge ifs name */
	char			ifbr_ifsname[IFNAMSIZ];	/* member ifs name */
	u_int8_t		ifbr_action;		/* disposition */
	u_int8_t		ifbr_flags;		/* flags */
	struct ether_addr	ifbr_src;		/* source mac */
	struct ether_addr	ifbr_dst;		/* destination mac */
	char			ifbr_tagname[PF_TAG_NAME_SIZE];	/* pf tagname */
};
#define	BRL_ACTION_BLOCK	0x01			/* block frame */
#define	BRL_ACTION_PASS		0x02			/* pass frame */
#define	BRL_FLAG_IN		0x08			/* input rule */
#define	BRL_FLAG_OUT		0x04			/* output rule */
#define	BRL_FLAG_SRCVALID	0x02			/* src valid */
#define	BRL_FLAG_DSTVALID	0x01			/* dst valid */

struct ifbrlconf {
	char		ifbrl_name[IFNAMSIZ];	/* bridge ifs name */
	char		ifbrl_ifsname[IFNAMSIZ];/* member ifs name */
	u_int32_t	ifbrl_len;		/* buffer size */
	union {
		caddr_t	ifbrlu_buf;
		struct	ifbrlreq *ifbrlu_req;
	} ifbrl_ifbrlu;
#define	ifbrl_buf	ifbrl_ifbrlu.ifbrlu_buf
#define	ifbrl_req	ifbrl_ifbrlu.ifbrlu_req
};

#ifdef _KERNEL
/* STP port flags */
#define	BSTP_PORT_CANMIGRATE	0x0001
#define	BSTP_PORT_NEWINFO	0x0002
#define	BSTP_PORT_DISPUTED	0x0004
#define	BSTP_PORT_ADMCOST	0x0008
#define	BSTP_PORT_AUTOEDGE	0x0010
#define	BSTP_PORT_AUTOPTP	0x0020

/* BPDU priority */
#define	BSTP_PDU_SUPERIOR	1
#define	BSTP_PDU_REPEATED	2
#define	BSTP_PDU_INFERIOR	3
#define	BSTP_PDU_INFERIORALT	4
#define	BSTP_PDU_OTHER		5

/* BPDU flags */
#define	BSTP_PDU_PRMASK		0x0c		/* Port Role */
#define	BSTP_PDU_PRSHIFT	2		/* Port Role offset */
#define	BSTP_PDU_F_UNKN		0x00		/* Unknown port    (00) */
#define	BSTP_PDU_F_ALT		0x01		/* Alt/Backup port (01) */
#define	BSTP_PDU_F_ROOT		0x02		/* Root port       (10) */
#define	BSTP_PDU_F_DESG		0x03		/* Designated port (11) */

#define	BSTP_PDU_STPMASK	0x81		/* strip unused STP flags */
#define	BSTP_PDU_RSTPMASK	0x7f		/* strip unused RSTP flags */
#define	BSTP_PDU_F_TC		0x01		/* Topology change */
#define	BSTP_PDU_F_P		0x02		/* Proposal flag */
#define	BSTP_PDU_F_L		0x10		/* Learning flag */
#define	BSTP_PDU_F_F		0x20		/* Forwarding flag */
#define	BSTP_PDU_F_A		0x40		/* Agreement flag */
#define	BSTP_PDU_F_TCA		0x80		/* Topology change ack */

/*
 * Bridge filtering rules
 */
SIMPLEQ_HEAD(brl_head, brl_node);

struct brl_node {
	SIMPLEQ_ENTRY(brl_node)	brl_next;	/* next rule */
	struct ether_addr	brl_src;	/* source mac address */
	struct ether_addr	brl_dst;	/* destination mac address */
	u_int16_t		brl_tag;	/* pf tag ID */
	u_int8_t		brl_action;	/* what to do with match */
	u_int8_t		brl_flags;	/* comparision flags */
};

struct bstp_timer {
	u_int16_t	active;
	u_int16_t	value;
	u_int32_t	latched;
};

struct bstp_pri_vector {
	u_int64_t	pv_root_id;
	u_int32_t	pv_cost;
	u_int64_t	pv_dbridge_id;
	u_int16_t	pv_dport_id;
	u_int16_t	pv_port_id;
};

struct bstp_config_unit {
	struct bstp_pri_vector	cu_pv;
	u_int16_t	cu_message_age;
	u_int16_t	cu_max_age;
	u_int16_t	cu_forward_delay;
	u_int16_t	cu_hello_time;
	u_int8_t	cu_message_type;
	u_int8_t	cu_topology_change_ack;
	u_int8_t	cu_topology_change;
	u_int8_t	cu_proposal;
	u_int8_t	cu_agree;
	u_int8_t	cu_learning;
	u_int8_t	cu_forwarding;
	u_int8_t	cu_role;
};

struct bstp_tcn_unit {
	u_int8_t	tu_message_type;
};

struct bstp_port {
	LIST_ENTRY(bstp_port)	bp_next;
	struct ifnet		*bp_ifp;	/* parent if */
	struct bstp_state	*bp_bs;
	void			*bp_lhcookie;	/* if linkstate hook */
	u_int8_t		bp_active;
	u_int8_t		bp_protover;
	u_int32_t		bp_flags;
	u_int32_t		bp_path_cost;
	u_int16_t		bp_port_msg_age;
	u_int16_t		bp_port_max_age;
	u_int16_t		bp_port_fdelay;
	u_int16_t		bp_port_htime;
	u_int16_t		bp_desg_msg_age;
	u_int16_t		bp_desg_max_age;
	u_int16_t		bp_desg_fdelay;
	u_int16_t		bp_desg_htime;
	struct bstp_timer	bp_edge_delay_timer;
	struct bstp_timer	bp_forward_delay_timer;
	struct bstp_timer	bp_hello_timer;
	struct bstp_timer	bp_message_age_timer;
	struct bstp_timer	bp_migrate_delay_timer;
	struct bstp_timer	bp_recent_backup_timer;
	struct bstp_timer	bp_recent_root_timer;
	struct bstp_timer	bp_tc_timer;
	struct bstp_config_unit bp_msg_cu;
	struct bstp_pri_vector	bp_desg_pv;
	struct bstp_pri_vector	bp_port_pv;
	u_int16_t		bp_port_id;
	u_int8_t		bp_state;
	u_int8_t		bp_tcstate;
	u_int8_t		bp_role;
	u_int8_t		bp_infois;
	u_int8_t		bp_tc_ack;
	u_int8_t		bp_tc_prop;
	u_int8_t		bp_fdbflush;
	u_int8_t		bp_priority;
	u_int8_t		bp_ptp_link;
	u_int8_t		bp_agree;
	u_int8_t		bp_agreed;
	u_int8_t		bp_sync;
	u_int8_t		bp_synced;
	u_int8_t		bp_proposing;
	u_int8_t		bp_proposed;
	u_int8_t		bp_operedge;
	u_int8_t		bp_reroot;
	u_int8_t		bp_rcvdtc;
	u_int8_t		bp_rcvdtca;
	u_int8_t		bp_rcvdtcn;
	u_int32_t		bp_forward_transitions;
	u_int8_t		bp_txcount;
};

/*
 * Software state for each bridge STP.
 */
struct bstp_state {
	struct ifnet		*bs_ifp;
	struct bstp_pri_vector	bs_bridge_pv;
	struct bstp_pri_vector	bs_root_pv;
	struct bstp_port	*bs_root_port;
	u_int8_t		bs_protover;
	u_int16_t		bs_migration_delay;
	u_int16_t		bs_edge_delay;
	u_int16_t		bs_bridge_max_age;
	u_int16_t		bs_bridge_fdelay;
	u_int16_t		bs_bridge_htime;
	u_int16_t		bs_root_msg_age;
	u_int16_t		bs_root_max_age;
	u_int16_t		bs_root_fdelay;
	u_int16_t		bs_root_htime;
	u_int16_t		bs_hold_time;
	u_int16_t		bs_bridge_priority;
	u_int8_t		bs_txholdcount;
	u_int8_t		bs_allsynced;
	struct timeout		bs_bstptimeout;		/* stp timeout */
	struct bstp_timer	bs_link_timer;
	struct timeval		bs_last_tc_time;
	LIST_HEAD(, bstp_port)	bs_bplist;
};
#define	bs_ifflags		bs_ifp->if_flags

/*
 * Bridge interface list
 */
struct bridge_iflist {
	TAILQ_ENTRY(bridge_iflist)	next;		/* next in list */
	struct bridge_softc		*bridge_sc;
	struct bstp_port		*bif_stp;	/* STP port state */
	struct brl_head			bif_brlin;	/* input rules */
	struct brl_head			bif_brlout;	/* output rules */
	struct				ifnet *ifp;	/* member interface */
	u_int32_t			bif_flags;	/* member flags */
	void				*bif_dhcookie;
};
#define bif_state			bif_stp->bp_state

#define SAME_BRIDGE(_bp1, _bp2)						\
	(_bp1 && _bp2 && ((struct bridge_iflist *)_bp1)->bridge_sc ==	\
	    ((struct bridge_iflist *)_bp2)->bridge_sc)

/*
 * XXX ip_ipsp.h's sockaddr_union should be converted to sockaddr *
 * passing with correct sa_len, then a good approach for cleaning this
 * will become more clear.
 */
union brsockaddr_union {
	struct sockaddr		sa;
	struct sockaddr_in	sin;
	struct sockaddr_in6	sin6;
};

/*
 * Bridge tunnel tagging
 */
struct bridge_tunneltag {
	union brsockaddr_union		brtag_peer;
	union brsockaddr_union		brtag_local;
	u_int32_t			brtag_id;
};

/*
 * Bridge route node
 */
struct bridge_rtnode {
	LIST_ENTRY(bridge_rtnode)	brt_next;	/* next in list */
	struct ifnet			*brt_if;	/* destination ifs */
	u_int8_t			brt_flags;	/* address flags */
	u_int8_t			brt_age;	/* age counter */
	struct ether_addr		brt_addr;	/* dst addr */
	struct bridge_tunneltag		brt_tunnel;	/* tunnel endpoint */
};

#ifndef BRIDGE_RTABLE_SIZE
#define BRIDGE_RTABLE_SIZE	1024
#endif
#define BRIDGE_RTABLE_MASK	(BRIDGE_RTABLE_SIZE - 1)

/*
 * Software state for each bridge
 */
struct bridge_softc {
	struct ifnet			sc_if;	/* the interface */
	u_int32_t			sc_brtmax;	/* max # addresses */
	u_int32_t			sc_brtcnt;	/* current # addrs */
	int				sc_brttimeout;	/* timeout ticks */
	u_int64_t			sc_hashkey[2];	/* siphash key */
	struct timeout			sc_brtimeout;	/* timeout state */
	struct bstp_state		*sc_stp;	/* stp state */
	TAILQ_HEAD(, bridge_iflist)	sc_iflist;	/* interface list */
	TAILQ_HEAD(, bridge_iflist)	sc_spanlist;	/* span ports */
	LIST_HEAD(, bridge_rtnode)	sc_rts[BRIDGE_RTABLE_SIZE];	/* hash table */
};

extern const u_int8_t bstp_etheraddr[];
struct llc;

int	bridge_output(struct ifnet *, struct mbuf *, struct sockaddr *,
    struct rtentry *);
void	bridge_update(struct ifnet *, struct ether_addr *, int);
void	bridge_rtdelete(struct bridge_softc *, struct ifnet *, int);
void	bridge_rtagenode(struct ifnet *, int);
struct bridge_tunneltag *bridge_tunnel(struct mbuf *);
struct bridge_tunneltag *bridge_tunneltag(struct mbuf *);
void	bridge_tunneluntag(struct mbuf *);
void	bridge_copyaddr(struct sockaddr *, struct sockaddr *);
void	bridge_copytag(struct bridge_tunneltag *, struct bridge_tunneltag *);

struct bstp_state *bstp_create(struct ifnet *);
void	bstp_destroy(struct bstp_state *);
void	bstp_initialization(struct bstp_state *);
void	bstp_stop(struct bstp_state *);
int	bstp_ioctl(struct ifnet *, u_long, caddr_t);
struct bstp_port *bstp_add(struct bstp_state *, struct ifnet *);
void	bstp_delete(struct bstp_port *);
struct mbuf *bstp_input(struct bstp_state *, struct bstp_port *,
    struct ether_header *, struct mbuf *);
void	bstp_ifstate(void *);
u_int8_t bstp_getstate(struct bstp_state *, struct bstp_port *);
void	bstp_ifsflags(struct bstp_port *, u_int);
void	bridge_send_icmp_err(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *, int, struct llc *, int, int, int);

int	bridgectl_ioctl(struct ifnet *, u_long, caddr_t);
struct ifnet *bridge_rtupdate(struct bridge_softc *,
    struct ether_addr *, struct ifnet *ifp, int, u_int8_t, struct mbuf *);
struct bridge_rtnode *bridge_rtlookup(struct bridge_softc *,
    struct ether_addr *);
void	bridge_rtflush(struct bridge_softc *, int);
void	bridge_rtage(void *);

u_int8_t bridge_filterrule(struct brl_head *, struct ether_header *,
    struct mbuf *);
void	bridge_flushrule(struct bridge_iflist *);

struct mbuf *bridge_ip(struct bridge_softc *, int, struct ifnet *,
    struct ether_header *, struct mbuf *);
void	bridge_fragment(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
int	bridge_ifenqueue(struct bridge_softc *, struct ifnet *, struct mbuf *);

#endif /* _KERNEL */
#endif /* _NET_IF_BRIDGE_H_ */
@


1.54
log
@No need for a splsoftnet()/splx() dance when the KERNEL_LOCK() is what
serialize access to bridge(4) data structures.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.53 2016/10/03 12:26:13 rzalamena Exp $	*/
d410 11
d424 2
a425 2
	union pfsockaddr_union		brtag_peer;
	union pfsockaddr_union		brtag_local;
@


1.53
log
@Use detach hook to notify bridge of interface removal instead of adding
code to if.c.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.52 2016/09/29 11:37:44 reyk Exp $	*/
d486 1
a486 1
void	bridge_timer(void *);
@


1.52
log
@Rename brtag_src/brtag_dst to brtag_peer/brtag_local to avoid
confusion about the tunnel endpoints when responding to the peer.

OK yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.51 2016/09/03 13:46:57 reyk Exp $	*/
d401 1
a453 1
void	bridge_ifdetach(struct ifnet *);
@


1.51
log
@Add support for a multipoint-to-multipoint mode in vxlan(4).  In this
mode, vxlan(4) must be configured to accept any virtual network
identifier with "vnetid any" and added to a bridge(4) or switch(4).
This way the driver will dynamically learn the tunnel endpoints and
their vnetids for the responses and can be used to dynamically bridge
between VXLANs.  It is also being used in combination with switch(4)
and the OpenFlow tunnel classifiers.

With input from yasuoka@@ goda@@
OK deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.50 2016/09/02 10:01:36 goda Exp $	*/
d412 2
a413 2
	union pfsockaddr_union		brtag_src;
	union pfsockaddr_union		brtag_dst;
@


1.50
log
@Add switch(4) support to ifconfig

ok deraadt@@ yasuoka@@ reyk@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.49 2016/09/01 10:06:33 goda Exp $	*/
d409 9
d422 1
a422 1
	struct				ifnet *brt_if;	/* destination ifs */
d425 2
a426 2
	struct				ether_addr brt_addr;	/* dst addr */
	union pfsockaddr_union		brt_tunnel;	/* tunnel endpoint */
d459 2
a460 2
struct sockaddr *bridge_tunnel(struct mbuf *);
struct sockaddr *bridge_tunneltag(struct mbuf *, int);
d463 1
@


1.49
log
@Import switch(4), an in-kernel OpenFlow switch which can work alone.
switch(4) currently supports OpenFlow 1.3.5.
Currently, it's disabled by the kernel config.

With help from yasuoka@@ reyk@@ jsg@@.

ok deraadt@@ yasuoka@@ reyk@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.48 2015/12/01 18:28:29 goda Exp $	*/
d48 1
a48 1
	u_int8_t	ifbr_portno;		/* member port number */
d74 2
a75 1
#define	IFBIF_RO_MASK		0xff00	/* read only bits */
d156 2
d168 3
d481 4
a484 1
void    bridge_fragment(struct bridge_softc *, struct ifnet *,
d486 1
@


1.48
log
@Split functions in if_bridge.c into if_bridge.c bridgectl.c .

Splitting functions in if_bridge.c into if_bridge.c for the forwarding part
and bridgectl.c for the control part. It shouldn't have any functional change.

ok reyk@@ mpi@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.47 2015/11/28 15:21:45 yasuoka Exp $	*/
d475 2
@


1.47
log
@Delete sc_root_port which became unused when RSTP is merged.

ok reyk mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.46 2015/11/07 12:42:19 mpi Exp $	*/
d436 1
d447 1
d461 15
@


1.46
log
@Use input handlers for bridge(4).

This allows more flexible configurations with vlan(4) and bridge(4) on
top of the same physical interface.  In particular it allows to not feed
VLAN tagget packets into a bridge(4).

Fix regression reported by Armin Wolfermann on bugs@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.45 2015/08/24 21:28:47 bluhm Exp $	*/
a423 1
	struct bridge_iflist		*sc_root_port;
@


1.45
log
@The bridge list is a relict, delete the remaining LIST_REMOVE.
This fixes a crash during ifconfig bridge0 destroy.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.44 2015/07/02 09:40:02 mpi Exp $	*/
a438 1
struct mbuf *bridge_input(struct ifnet *, struct mbuf *);
@


1.44
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.43 2015/06/23 09:42:23 mpi Exp $	*/
a423 1
	LIST_ENTRY(bridge_softc)	sc_list;	/* all bridges */
@


1.43
log
@Adapt bridge(4) to the new if_input() framework.

Move bridge_input() outside of ether_input() in order to duplicate packets
flowing through a bridge port before applying any transformation on mbufs.

This saves a various m_adj(9)/M_PREPEND(9) dances and remove the bridge(4)
hack from vlan(4).

Tested by mxb <mxb AT alumni DOT chalmers DOT se> and kettenis@@

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.42 2015/04/12 09:57:54 dlg Exp $	*/
d440 1
a440 1
struct mbuf *bridge_input(struct mbuf *);
@


1.42
log
@dont rely on hfsc.h via pfvar.h to include sys/timeout.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.41 2015/01/24 00:29:06 deraadt Exp $	*/
d440 1
a440 2
struct mbuf *bridge_input(struct ifnet *, struct ether_header *,
    struct mbuf *);
@


1.41
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.40 2014/12/22 03:38:01 tedu Exp $	*/
d38 1
@


1.40
log
@convert to using siphash
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.39 2013/10/13 12:09:54 reyk Exp $	*/
d410 1
a410 1
	union sockaddr_union		brt_tunnel;	/* tunnel endpoint */
@


1.39
log
@Just use sockaddr_union instead of a handcrafted version and rename
bridge_tunnelupdate to a more generic name bridge_copyaddr.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.38 2013/10/13 10:10:03 reyk Exp $	*/
d428 1
a428 1
	u_int32_t			sc_hashkey;	/* hash key */
@


1.38
log
@Import vxlan(4), the virtual extensible local area network tunnel
interface.  VXLAN is a UDP-based tunnelling protocol for overlaying
virtualized layer 2 networks over layer 3 networks. The implementation
is based on draft-mahalingam-dutt-dcops-vxlan-04 and has been tested
with other implementations in the wild.

put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.37 2013/01/23 13:28:36 camield Exp $	*/
d410 1
a410 9
	union {
		struct sockaddr		sa;
#ifdef INET
		struct sockaddr_in	sin;
#endif
#ifdef INET6
		struct sockaddr_in6	sin6;
#endif
	}				brt_tunnel;	/* tunnel endpoint */
@


1.37
log
@
Change interface and span interface lists from LIST to TAILQ.

This way the configuration order is preserved.  Order matters
because MAC address are not unique: vlan interfaces can have
the same MAC as their parent.

Frames destined for the bridge itself are now delivered to
the first-configured interface that matches the MAC instead
of the last-configured.  This means that the bridge behavior
does not suddenly change anymore when adding a vlan interface.

ok henning reyk (a while ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.36 2012/10/05 17:17:04 camield Exp $	*/
d125 1
d410 9
d454 3
@


1.36
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.35 2012/09/20 14:10:18 mpf Exp $	*/
d386 1
a386 1
	LIST_ENTRY(bridge_iflist)	next;		/* next in list */
d429 2
a430 1
	LIST_HEAD(, bridge_iflist)	sc_iflist;	/* interface list */
a431 1
	LIST_HEAD(, bridge_iflist)	sc_spanlist;	/* span ports */
@


1.35
log
@Don't filter spanning tree BPDUs. Either process, or forward them.
Even though this violates IEEE 802.1D, we'd rather avoid bridging loops
by not getting in the way of STP.
OK henning, camield, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.34 2010/11/20 14:23:09 fgsch Exp $	*/
d387 1
d395 4
@


1.34
log
@remove bs_list occurrences. fixes panic on destroy.
ok from the m guild: mikeb@@ miod@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.33 2010/10/31 15:14:30 mpf Exp $	*/
d447 1
a447 1
void	bstp_input(struct bstp_state *, struct bstp_port *,
@


1.33
log
@Remove unused bstp_list and bstp_attach.
OK blambert, claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.32 2010/10/28 13:49:54 claudio Exp $	*/
a356 1
	LIST_ENTRY(bstp_state)	bs_list;
@


1.32
log
@A function that only returns NULL should return void.
bstp_input() always consumes the packet so remove the mbuf handling
dance around it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.31 2006/12/11 22:11:48 reyk Exp $	*/
a440 1
void	bstp_attach(int);
@


1.31
log
@refer to the RSTP point to point option as "PTP" instead of "P2P".
P2P is commonly used in relation to peer to peer networks, PTP is used
in various protocols for layer 2 point to point links (ie., full
duplex ethernet links).

note that the newly added brconfig commands [-]p2p and [-]autop2p will
change to [-]ptp and [-]autoptp.

suggested by Andrew Thompson (thompsa@@freebsd.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.30 2006/12/03 13:41:19 reyk Exp $	*/
d449 1
a449 1
struct mbuf *bstp_input(struct bstp_state *, struct bstp_port *,
@


1.30
log
@Add Rapid Spanning Tree Protocol support (802.1d-2004) based on work
by Andrew Thompson (thompsa@@freebsd.org). The local changes include
adoption to our bridge code, reduced stack usage and many other bits.
If stp is enabled, RSTP will now be used by default.

Thanks for help from Andrew.

This code has been in snaps for while now, commit encouraged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.29 2006/05/28 00:33:04 henning Exp $	*/
d70 2
a71 2
#define IFBIF_BSTP_P2P		0x0040  /* member stp p2p */
#define IFBIF_BSTP_AUTOP2P	0x0080	/* member stp autop2p enabled */
d226 1
a226 1
#define	BSTP_PORT_AUTOP2P	0x0020
d337 1
a337 1
	u_int8_t		bp_p2p_link;
@


1.29
log
@fix a whitespace error causing confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.28 2005/10/09 19:44:22 reyk Exp $	*/
d5 1
d47 2
a50 1
	u_int8_t	ifbr_portno;		/* member port number */
d52 9
d62 1
d68 4
d74 1
d85 16
d151 2
d158 2
d164 24
d220 32
d266 12
a277 3
struct bridge_timer {
	u_int16_t active;
	u_int16_t value;
d281 1
a281 3
	u_int64_t	cu_rootid;
	u_int64_t	cu_bridge_id;
	u_int32_t	cu_root_path_cost;
d284 1
a285 2
	u_int16_t	cu_forward_delay;
	u_int16_t	cu_port_id;
d287 1
a287 1
	u_int8_t	cu_topology_change_acknowledgment;
d289 5
d300 83
d388 1
a388 15
	u_int64_t			bif_designated_root;
	u_int64_t			bif_designated_bridge;
	u_int32_t			bif_path_cost;
	u_int32_t			bif_designated_cost;
	struct bridge_timer		bif_hold_timer;
	struct bridge_timer		bif_message_age_timer;
	struct bridge_timer		bif_forward_delay_timer;
	struct bstp_config_unit		bif_config_bpdu;
	u_int16_t			bif_port_id;
	u_int16_t			bif_designated_port;
	u_int8_t			bif_state;
	u_int8_t			bif_topology_change_acknowledge;
	u_int8_t			bif_config_pending;
	u_int8_t			bif_change_detection_enabled;
	u_int8_t			bif_priority;
d394 1
a417 2
	u_int64_t			sc_designated_root;
	u_int64_t			sc_bridge_id;
a418 15
	u_int32_t			sc_root_path_cost;
	u_int16_t			sc_max_age;
	u_int16_t			sc_hello_time;
	u_int16_t			sc_forward_delay;
	u_int16_t			sc_bridge_max_age;
	u_int16_t			sc_bridge_hello_time;
	u_int16_t			sc_bridge_forward_delay;
	u_int16_t			sc_topology_change_time;
	u_int16_t			sc_hold_time;
	u_int16_t			sc_bridge_priority;
	u_int8_t			sc_topology_change_detected;
	u_int8_t			sc_topology_change;
	struct bridge_timer		sc_hello_timer;
	struct bridge_timer		sc_topology_change_timer;
	struct bridge_timer		sc_tcn_timer;
d424 1
a424 1
	struct timeout			sc_bstptimeout;	/* stp timeout */
d430 1
a430 1
extern u_int8_t bstp_etheraddr[];
d438 12
a449 1
struct mbuf *bstp_input(struct bridge_softc *, struct ifnet *,
d451 3
a453 3
void	bstp_initialization(struct bridge_softc *);
int	bstp_ioctl(struct ifnet *, u_long, caddr_t);
void	bridge_rtdelete(struct bridge_softc *, struct ifnet *, int);
@


1.28
log
@if the wireless hostap interface belongs to a bridge, learn the node's
address dynamically on this interface after successful association.
this could speed wireless roaming to openbsd accesspoints.

ok jason@@, jsg@@ can't see anything obectionable
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.27 2004/12/23 09:32:55 camield Exp $	*/
d242 1
a242 1
	struct				ifnet sc_if;	/* the interface */
@


1.27
log
@Simplify hashtable (de)allocation by moving it into the clone functions.

ok mickey@@ henning@@, "looks good" markus@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.26 2003/12/03 14:55:58 markus Exp $	*/
d280 1
@


1.26
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.25 2003/07/15 03:41:15 jason Exp $	*/
d233 5
d269 1
a269 1
	LIST_HEAD(bridge_rthead, bridge_rtnode)	*sc_rts;/* hash table */
@


1.25
log
@no named args in prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.24 2003/06/25 09:41:18 henning Exp $	*/
d238 1
@


1.24
log
@add a pf_tagname field to ifbrlreq and a pf_tag field to ifbrlnode.
on bridge rule load translate tagnames to pf tags using pf_tagname2tag etc
if packets match a bridge filter rule tag them using pf_tag_packet() with
the given tag
help dhartmei@@
ok deraadt@@ jason@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.23 2003/06/02 18:42:56 jason Exp $	*/
d273 1
a273 1
    struct rtentry *rt);
@


1.23
log
@nuke clause 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.22 2003/05/30 21:15:41 henning Exp $	*/
d37 2
d137 1
d168 1
@


1.22
log
@KNF & ANSI, jason agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.21 2003/05/30 20:08:34 henning Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.21
log
@o the timeout is int, not u_int32_t
o check timeout for negative values and overflow

ok tedu@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.20 2002/12/09 10:11:52 markus Exp $	*/
d57 1
a57 1
#define	IFBIF_BLOCKNONIP 	0x0004	/* ifs blocks non-IP/ARP in/out */
@


1.20
log
@allow setting of ifcost with brconfig.  enables selection of preferred
port/path to root bridge among several LANs.   unlike ifpriority, which
allows you to select designated port if serveral interfaces belong
to the same LAN;  ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.19 2002/12/04 15:44:21 markus Exp $	*/
d116 1
a116 1
		u_int32_t	ifbrpu_ctime;		/* cache time (sec) */
d259 1
a259 1
	u_int32_t			sc_brttimeout;	/* timeout ticks */
@


1.19
log
@spanning tree: flush dynamic mac cache if interface goes to the
blocking or disabled state.  send packets only if interface is the
forwarding state; comment from netbsd; with and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.18 2002/04/08 17:49:43 jason Exp $	*/
d52 1
@


1.18
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.17 2002/03/14 01:27:09 millert Exp $	*/
d278 1
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.16 2001/12/15 08:40:56 jason Exp $	*/
d32 5
@


1.16
log
@add support for creating span ports so that one can snoop a bridge
from another interface/machine/network.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.15 2001/06/09 06:16:37 angelos Exp $	*/
d264 9
a272 9
void	bridge_ifdetach __P((struct ifnet *));
struct mbuf *bridge_input __P((struct ifnet *, struct ether_header *,
    struct mbuf *));
int	bridge_output __P((struct ifnet *, struct mbuf *, struct sockaddr *,
    struct rtentry *rt));
struct mbuf *bstp_input __P((struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *));
void	bstp_initialization __P((struct bridge_softc *));
int	bstp_ioctl __P((struct ifnet *, u_long, caddr_t));
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.16 2001/12/15 08:40:56 jason Exp $	*/
a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d264 9
a272 9
void	bridge_ifdetach(struct ifnet *);
struct mbuf *bridge_input(struct ifnet *, struct ether_header *,
    struct mbuf *);
int	bridge_output(struct ifnet *, struct mbuf *, struct sockaddr *,
    struct rtentry *rt);
struct mbuf *bstp_input(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void	bstp_initialization(struct bridge_softc *);
int	bstp_ioctl(struct ifnet *, u_long, caddr_t);
@


1.16.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a51 1
	u_int32_t	ifbr_path_cost;		/* member stp path cost */
a277 1
void	bridge_rtdelete(struct bridge_softc *, struct ifnet *, int);
@


1.15
log
@By popular demand, protect from multiple inclusion, and fix to use the
same naming style.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.14 2001/03/22 03:48:29 jason Exp $	*/
d49 6
a54 4
#define	IFBIF_LEARNING		0x01	/* ifs can learn */
#define	IFBIF_DISCOVER		0x02	/* ifs sends packets w/unknown dest */
#define	IFBIF_BLOCKNONIP 	0x04	/* ifs blocks non-IP/ARP in/out */
#define	IFBIF_STP		0x08	/* ifs participates in spanning tree */
d259 1
@


1.14
log
@let bstp_transmit_tcn() handle all of the work for sending TCN messages
and remove unnecessary structure element
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.13 2000/12/12 03:41:22 jason Exp $	*/
d34 3
d271 1
@


1.13
log
@Add support for 802.1D spanning tree protocol.
NOTE: this requires recompiling brconfig with updated include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.12 2000/01/25 22:06:27 jason Exp $	*/
a198 1
	struct bstp_tcn_unit		bif_tcn_bpdu;
@


1.12
log
@add ethernet MAC filtering capability
also includes split of bridgeintr() with some optimizations for quicker
frame handling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.11 2000/01/10 22:18:29 angelos Exp $	*/
d41 3
d46 4
a49 3
#define	IFBIF_LEARNING	0x1	/* ifs can learn */
#define	IFBIF_DISCOVER	0x2	/* ifs sends packets w/unknown dest */
#define IFBIF_BLOCKNONIP 0x04	/* ifs blocks non-IP/ARP traffic in/out */
d54 7
d101 10
a110 14
/*
 * Bridge cache size get/set
 */
struct ifbcachereq {
	char			ifbc_name[IFNAMSIZ];	/* bridge ifs name */
	u_int32_t		ifbc_size;		/* cache size */
};

/*
 * Bridge cache timeout get/set
 */
struct ifbcachetoreq {
	char			ifbct_name[IFNAMSIZ];	/* bridge ifs name */
	u_int32_t		ifbct_time;		/* cache time (sec) */
d112 6
d150 109
d264 4
@


1.12.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.14 2001/03/22 03:48:29 jason Exp $	*/
a40 3
	u_int8_t	ifbr_state;		/* member stp state */
	u_int8_t	ifbr_priority;		/* member stp priority */
	u_int8_t	ifbr_portno;		/* member port number */
d43 3
a45 4
#define	IFBIF_LEARNING		0x01	/* ifs can learn */
#define	IFBIF_DISCOVER		0x02	/* ifs sends packets w/unknown dest */
#define	IFBIF_BLOCKNONIP 	0x04	/* ifs blocks non-IP/ARP in/out */
#define	IFBIF_STP		0x08	/* ifs participates in spanning tree */
a49 7
/* port states */
#define	BSTP_IFSTATE_DISABLED	0
#define	BSTP_IFSTATE_LISTENING	1
#define	BSTP_IFSTATE_LEARNING	2
#define	BSTP_IFSTATE_FORWARDING	3
#define	BSTP_IFSTATE_BLOCKING	4

d90 14
a103 10
struct ifbrparam {
	char			ifbrp_name[IFNAMSIZ];
	union {
		u_int32_t	ifbrpu_csize;		/* cache size */
		u_int32_t	ifbrpu_ctime;		/* cache time (sec) */
		u_int16_t	ifbrpu_prio;		/* bridge priority */
		u_int8_t	ifbrpu_hellotime;	/* hello time (sec) */
		u_int8_t	ifbrpu_fwddelay;	/* fwd delay (sec) */
		u_int8_t	ifbrpu_maxage;		/* max age (sec) */
	} ifbrp_ifbrpu;
a104 6
#define	ifbrp_csize	ifbrp_ifbrpu.ifbrpu_csize
#define	ifbrp_ctime	ifbrp_ifbrpu.ifbrpu_ctime
#define	ifbrp_prio	ifbrp_ifbrpu.ifbrpu_prio
#define	ifbrp_hellotime	ifbrp_ifbrpu.ifbrpu_hellotime
#define	ifbrp_fwddelay	ifbrp_ifbrpu.ifbrpu_fwddelay
#define	ifbrp_maxage	ifbrp_ifbrpu.ifbrpu_maxage
a136 108
/*
 * Bridge filtering rules
 */
SIMPLEQ_HEAD(brl_head, brl_node);

struct brl_node {
	SIMPLEQ_ENTRY(brl_node)	brl_next;	/* next rule */
	struct ether_addr	brl_src;	/* source mac address */
	struct ether_addr	brl_dst;	/* destination mac address */
	u_int8_t		brl_action;	/* what to do with match */
	u_int8_t		brl_flags;	/* comparision flags */
};

struct bridge_timer {
	u_int16_t active;
	u_int16_t value;
};

struct bstp_config_unit {
	u_int64_t	cu_rootid;
	u_int64_t	cu_bridge_id;
	u_int32_t	cu_root_path_cost;
	u_int16_t	cu_message_age;
	u_int16_t	cu_max_age;
	u_int16_t	cu_hello_time;
	u_int16_t	cu_forward_delay;
	u_int16_t	cu_port_id;
	u_int8_t	cu_message_type;
	u_int8_t	cu_topology_change_acknowledgment;
	u_int8_t	cu_topology_change;
};

struct bstp_tcn_unit {
	u_int8_t	tu_message_type;
};

/*
 * Bridge interface list
 */
struct bridge_iflist {
	LIST_ENTRY(bridge_iflist)	next;		/* next in list */
	u_int64_t			bif_designated_root;
	u_int64_t			bif_designated_bridge;
	u_int32_t			bif_path_cost;
	u_int32_t			bif_designated_cost;
	struct bridge_timer		bif_hold_timer;
	struct bridge_timer		bif_message_age_timer;
	struct bridge_timer		bif_forward_delay_timer;
	struct bstp_config_unit		bif_config_bpdu;
	u_int16_t			bif_port_id;
	u_int16_t			bif_designated_port;
	u_int8_t			bif_state;
	u_int8_t			bif_topology_change_acknowledge;
	u_int8_t			bif_config_pending;
	u_int8_t			bif_change_detection_enabled;
	u_int8_t			bif_priority;
	struct brl_head			bif_brlin;	/* input rules */
	struct brl_head			bif_brlout;	/* output rules */
	struct				ifnet *ifp;	/* member interface */
	u_int32_t			bif_flags;	/* member flags */
};

/*
 * Bridge route node
 */
struct bridge_rtnode {
	LIST_ENTRY(bridge_rtnode)	brt_next;	/* next in list */
	struct				ifnet *brt_if;	/* destination ifs */
	u_int8_t			brt_flags;	/* address flags */
	u_int8_t			brt_age;	/* age counter */
	struct				ether_addr brt_addr;	/* dst addr */
};

/*
 * Software state for each bridge
 */
struct bridge_softc {
	struct				ifnet sc_if;	/* the interface */
	u_int64_t			sc_designated_root;
	u_int64_t			sc_bridge_id;
	struct bridge_iflist		*sc_root_port;
	u_int32_t			sc_root_path_cost;
	u_int16_t			sc_max_age;
	u_int16_t			sc_hello_time;
	u_int16_t			sc_forward_delay;
	u_int16_t			sc_bridge_max_age;
	u_int16_t			sc_bridge_hello_time;
	u_int16_t			sc_bridge_forward_delay;
	u_int16_t			sc_topology_change_time;
	u_int16_t			sc_hold_time;
	u_int16_t			sc_bridge_priority;
	u_int8_t			sc_topology_change_detected;
	u_int8_t			sc_topology_change;
	struct bridge_timer		sc_hello_timer;
	struct bridge_timer		sc_topology_change_timer;
	struct bridge_timer		sc_tcn_timer;
	u_int32_t			sc_brtmax;	/* max # addresses */
	u_int32_t			sc_brtcnt;	/* current # addrs */
	u_int32_t			sc_brttimeout;	/* timeout ticks */
	u_int32_t			sc_hashkey;	/* hash key */
	struct timeout			sc_brtimeout;	/* timeout state */
	struct timeout			sc_bstptimeout;	/* stp timeout */
	LIST_HEAD(, bridge_iflist)	sc_iflist;	/* interface list */
	LIST_HEAD(bridge_rthead, bridge_rtnode)	*sc_rts;/* hash table */
};

extern u_int8_t bstp_etheraddr[];

a141 4
struct mbuf *bstp_input __P((struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *));
void	bstp_initialization __P((struct bridge_softc *));
int	bstp_ioctl __P((struct ifnet *, u_long, caddr_t));
@


1.12.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.12.2.1 2001/05/14 22:40:00 niklas Exp $	*/
a33 3
#ifndef _NET_IF_BRIDGE_H_
#define _NET_IF_BRIDGE_H_

a267 1
#endif /* _NET_IF_BRIDGE_H_ */
@


1.12.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 4
a52 6
#define	IFBIF_LEARNING		0x0001	/* ifs can learn */
#define	IFBIF_DISCOVER		0x0002	/* ifs sends packets w/unknown dest */
#define	IFBIF_BLOCKNONIP 	0x0004	/* ifs blocks non-IP/ARP in/out */
#define	IFBIF_STP		0x0008	/* ifs participates in spanning tree */
#define	IFBIF_SPAN		0x0100	/* ifs is a span port (ro) */
#define	IFBIF_RO_MASK		0xff00	/* read only bits */
a256 1
	LIST_HEAD(, bridge_iflist)	sc_spanlist;	/* span ports */
@


1.12.2.4
log
@Merge in -current from roughly a week ago
@
text
@d264 9
a272 9
void	bridge_ifdetach(struct ifnet *);
struct mbuf *bridge_input(struct ifnet *, struct ether_header *,
    struct mbuf *);
int	bridge_output(struct ifnet *, struct mbuf *, struct sockaddr *,
    struct rtentry *rt);
struct mbuf *bstp_input(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void	bstp_initialization(struct bridge_softc *);
int	bstp_ioctl(struct ifnet *, u_long, caddr_t);
@


1.12.2.5
log
@Sync the SMP branch with 3.3
@
text
@a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a46 1
	u_int32_t	ifbr_path_cost;		/* member stp path cost */
a272 1
void	bridge_rtdelete(struct bridge_softc *, struct ifnet *, int);
@


1.12.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.12.2.5 2003/03/28 00:41:28 niklas Exp $	*/
d15 5
d57 1
a57 1
#define	IFBIF_BLOCKNONIP	0x0004	/* ifs blocks non-IP/ARP in/out */
d116 1
a116 1
		int		ifbrpu_ctime;		/* cache time (sec) */
d259 1
a259 1
	int				sc_brttimeout;	/* timeout ticks */
@


1.12.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 2
#include <net/pfvar.h>

a134 1
	char			ifbr_tagname[PF_TAG_NAME_SIZE];	/* pf tagname */
a164 1
	u_int16_t		brl_tag;	/* pf tag ID */
a233 1
	LIST_ENTRY(bridge_softc)	sc_list;	/* all bridges */
d269 1
a269 1
    struct rtentry *);
@


1.11
log
@Implement the blocknonip flag
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.10 1999/09/03 12:47:12 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Jason L. Wright (jason@@thought.net)
d45 1
a45 1
#define IFBIF_BLOCKNONIP 0x04	/* ifs does not allow non-IP/ARP traffic in/out */
d106 29
@


1.10
log
@Don't delete the cache on down/up transitions unless it's empty.  Instead
flush the dynamics.  Required other handling of the cache table to accomodate.
Modify SIOCBRDGFLUSH to handle flushall and flush dynamic requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.9 1999/09/01 21:38:48 jason Exp $	*/
d45 1
@


1.9
log
@o simpler handling of "forme" packets
o when ~IFF_UP, don't act like a bridge for output either
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.8 1999/08/08 02:42:58 niklas Exp $	*/
d40 1
a40 1
	u_int32_t	ifbr_ifsflags;		/* memver ifs flags */
d42 1
a42 1

d45 3
@


1.8
log
@Fix cases when wanting to communicate with the bridge'
s remote interfaces, both ARP and local delivery had bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.7 1999/08/08 00:43:00 niklas Exp $	*/
d106 1
a106 1
    struct mbuf *, int *));
@


1.7
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.6 1999/03/19 22:47:33 jason Exp $	*/
d106 1
a106 1
    struct mbuf *));
@


1.6
log
@Add flag to allow some interfaces to not see packets with unknown destination.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.5 1999/03/19 02:46:54 jason Exp $	*/
d104 2
a105 1
struct mbuf *	bridge_input	__P((struct ifnet *, struct ether_header *,
d107 2
a108 2
int		bridge_output	__P((struct ifnet *, struct mbuf *,
    struct sockaddr *, struct rtentry *rt));
@


1.5
log
@Add the ability to mark an interface as "non-learning"
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.4 1999/03/12 02:40:43 jason Exp $	*/
d43 2
a44 1
#define	IFBIF_LEARNING	0x1			/* ifs can learn */
@


1.4
log
@big overhaul:
o SNAP encapsulated IP filtering
o static address cache entries
o address deletion from cache
o dynamic & full cache flush
o filter packets based on each interface, not on the bridge as a whole
o KNF nits
o allow addition of ~IFF_UP interfaces
o man page & user level fixes to match the above
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.3 1999/03/05 21:10:52 jason Exp $	*/
d42 2
@


1.3
log
@Make address cache expiration actually work and provide a knob
for adjusting the timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.2 1999/03/01 04:44:44 jason Exp $	*/
d61 4
a64 2
	char			ifba_name[IFNAMSIZ];	/* destination ifs */
	u_int32_t		ifba_age;		/* route age */
d67 4
@


1.2
log
@completely (almost) revamped ioctl's:
o new ioctls for getting/setting cache size (default == 100)
o changed SIOCBRDGRT -> SIOCBRDGRTS
o changed SIOCBRDGIDX -> SIOCBRDGIFS
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bridge.h,v 1.1 1999/02/26 17:01:32 jason Exp $	*/
d84 9
@


1.1
log
@Ethernet bridge/IP firewall driver.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
a35 1
 * Bridge control request: (add/delete/iterate) member interfaces.
d38 3
a40 3
	char		ifbname[IFNAMSIZ];	/* bridge ifs name */
	char		ifsname[IFNAMSIZ];	/* member ifs name */
	u_int32_t	index;			/* iteration index */
d44 1
a44 1
 * Bridge routing request: iterate known routes.
d46 37
a82 6
struct ifbrtreq {
	char			ifbname[IFNAMSIZ];	/* bridge ifs name */
	u_int32_t		index;			/* iteration index */
	struct ether_addr	dst;			/* destination addr */
	char			ifsname[IFNAMSIZ];	/* destination ifs */
	u_int16_t		age;			/* route age */
@

