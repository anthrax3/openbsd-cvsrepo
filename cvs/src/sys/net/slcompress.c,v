head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.8
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.6
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.26
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.24
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.22
	OPENBSD_5_0:1.9.0.20
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.18
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.16
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.12
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.28
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.26
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.24
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.22
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.20
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.18
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.03.14.34.48;	author blambert;	state Exp;
branches;
next	1.11;
commitid	q8jAoDnlQ5E32uEv;

1.11
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.10;
commitid	DQakU8LLWV6Iwx84;

1.10
date	2013.06.11.18.15.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.05.04.27.04;	author millert;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	96.07.25.14.20.52;	author joshd;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.28.46;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.21.07.22;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.20.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.12
log
@ANSIfy function definitions

no change in .o file checksum

ok claudio@@
@
text
@/*	$OpenBSD: slcompress.c,v 1.11 2014/07/22 11:06:10 mpi Exp $	*/
/*	$NetBSD: slcompress.c,v 1.17 1997/05/17 21:12:10 christos Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)slcompress.c	8.2 (Berkeley) 4/16/94
 */

/*
 * Routines to compress and uncompess tcp packets (for transmission
 * over low speed serial lines.
 *
 * Van Jacobson (van@@helios.ee.lbl.gov), Dec 31, 1989:
 *	- Initial distribution.
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <net/slcompress.h>

#ifndef SL_NO_STATS
#define INCR(counter) ++comp->counter;
#else
#define INCR(counter)
#endif

#define BCMP(p1, p2, n) bcmp((char *)(p1), (char *)(p2), (int)(n))
#define BCOPY(p1, p2, n) bcopy((char *)(p1), (char *)(p2), (int)(n))

void
sl_compress_init(struct slcompress *comp)
{
	u_int i;
	struct cstate *tstate = comp->tstate;

	bzero((char *)comp, sizeof(*comp));
	for (i = MAX_STATES - 1; i > 0; --i) {
		tstate[i].cs_id = i;
		tstate[i].cs_next = &tstate[i - 1];
	}
	tstate[0].cs_next = &tstate[MAX_STATES - 1];
	tstate[0].cs_id = 0;
	comp->last_cs = &tstate[0];
	comp->last_recv = 255;
	comp->last_xmit = 255;
	comp->flags = SLF_TOSS;
}


/*
 * Like sl_compress_init, but we get to specify the maximum connection
 * ID to use on transmission.
 */
void
sl_compress_setup(struct slcompress *comp, int max_state)
{
	u_int i;
	struct cstate *tstate = comp->tstate;

	if (max_state == -1) {
		max_state = MAX_STATES - 1;
		bzero((char *)comp, sizeof(*comp));
	} else {
		/* Don't reset statistics */
		bzero((char *)comp->tstate, sizeof(comp->tstate));
		bzero((char *)comp->rstate, sizeof(comp->rstate));
	}
	for (i = max_state; i > 0; --i) {
		tstate[i].cs_id = i;
		tstate[i].cs_next = &tstate[i - 1];
	}
	tstate[0].cs_next = &tstate[max_state];
	tstate[0].cs_id = 0;
	comp->last_cs = &tstate[0];
	comp->last_recv = 255;
	comp->last_xmit = 255;
	comp->flags = SLF_TOSS;
}


/* ENCODE encodes a number that is known to be non-zero.  ENCODEZ
 * checks for zero (since zero has to be encoded in the long, 3 byte
 * form).
 */
#define ENCODE(n) { \
	if ((u_int16_t)(n) >= 256) { \
		*cp++ = 0; \
		cp[1] = (n); \
		cp[0] = (n) >> 8; \
		cp += 2; \
	} else { \
		*cp++ = (n); \
	} \
}
#define ENCODEZ(n) { \
	if ((u_int16_t)(n) >= 256 || (u_int16_t)(n) == 0) { \
		*cp++ = 0; \
		cp[1] = (n); \
		cp[0] = (n) >> 8; \
		cp += 2; \
	} else { \
		*cp++ = (n); \
	} \
}

#define DECODEL(f) { \
	if (*cp == 0) {\
		(f) = htonl(ntohl(f) + ((cp[1] << 8) | cp[2])); \
		cp += 3; \
	} else { \
		(f) = htonl(ntohl(f) + (u_int32_t)*cp++); \
	} \
}

#define DECODES(f) { \
	if (*cp == 0) {\
		(f) = htons(ntohs(f) + ((cp[1] << 8) | cp[2])); \
		cp += 3; \
	} else { \
		(f) = htons(ntohs(f) + (u_int32_t)*cp++); \
	} \
}

#define DECODEU(f) { \
	if (*cp == 0) {\
		(f) = htons((cp[1] << 8) | cp[2]); \
		cp += 3; \
	} else { \
		(f) = htons((u_int32_t)*cp++); \
	} \
}

u_int
sl_compress_tcp(struct mbuf *m, struct ip *ip, struct slcompress *comp,
    int compress_cid)
{
	struct cstate *cs = comp->last_cs->cs_next;
	u_int hlen = ip->ip_hl;
	struct tcphdr *oth;
	struct tcphdr *th;
	u_int deltaS, deltaA;
	u_int changes = 0;
	u_char new_seq[16];
	u_char *cp = new_seq;

	/*
	 * Bail if this is an IP fragment or if the TCP packet isn't
	 * `compressible' (i.e., ACK isn't set or some other control bit is
	 * set).  (We assume that the caller has already made sure the
	 * packet is IP proto TCP).
	 */
	if ((ip->ip_off & htons(0x3fff)) || m->m_len < 40)
		return (TYPE_IP);

	th = (struct tcphdr *)&((int32_t *)ip)[hlen];
	if ((th->th_flags & (TH_SYN|TH_FIN|TH_RST|TH_ACK)) != TH_ACK)
		return (TYPE_IP);
	/*
	 * Packet is compressible -- we're going to send either a
	 * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way we need
	 * to locate (or create) the connection state.  Special case the
	 * most recently used connection since it's most likely to be used
	 * again & we don't have to do any reordering if it's used.
	 */
	INCR(sls_packets)
	if (ip->ip_src.s_addr != cs->cs_ip.ip_src.s_addr ||
	    ip->ip_dst.s_addr != cs->cs_ip.ip_dst.s_addr ||
	    *(int32_t *)th != ((int32_t *)&cs->cs_ip)[cs->cs_ip.ip_hl]) {
		/*
		 * Wasn't the first -- search for it.
		 *
		 * States are kept in a circularly linked list with
		 * last_cs pointing to the end of the list.  The
		 * list is kept in lru order by moving a state to the
		 * head of the list whenever it is referenced.  Since
		 * the list is short and, empirically, the connection
		 * we want is almost always near the front, we locate
		 * states via linear search.  If we don't find a state
		 * for the datagram, the oldest state is (re-)used.
		 */
		struct cstate *lcs;
		struct cstate *lastcs = comp->last_cs;

		do {
			lcs = cs; cs = cs->cs_next;
			INCR(sls_searches)
			if (ip->ip_src.s_addr == cs->cs_ip.ip_src.s_addr
			    && ip->ip_dst.s_addr == cs->cs_ip.ip_dst.s_addr
			    && *(int32_t *)th ==
			    ((int32_t *)&cs->cs_ip)[cs->cs_ip.ip_hl])
				goto found;
		} while (cs != lastcs);

		/*
		 * Didn't find it -- re-use oldest cstate.  Send an
		 * uncompressed packet that tells the other side what
		 * connection number we're using for this conversation.
		 * Note that since the state list is circular, the oldest
		 * state points to the newest and we only need to set
		 * last_cs to update the lru linkage.
		 */
		INCR(sls_misses)
		comp->last_cs = lcs;
		hlen += th->th_off;
		hlen <<= 2;
		goto uncompressed;

	found:
		/*
		 * Found it -- move to the front on the connection list.
		 */
		if (cs == lastcs)
			comp->last_cs = lcs;
		else {
			lcs->cs_next = cs->cs_next;
			cs->cs_next = lastcs->cs_next;
			lastcs->cs_next = cs;
		}
	}

	/*
	 * Make sure that only what we expect to change changed. The first
	 * line of the `if' checks the IP protocol version, header length &
	 * type of service.  The 2nd line checks the "Don't fragment" bit.
	 * The 3rd line checks the time-to-live and protocol (the protocol
	 * check is unnecessary but costless).  The 4th line checks the TCP
	 * header length.  The 5th line checks IP options, if any.  The 6th
	 * line checks TCP options, if any.  If any of these things are
	 * different between the previous & current datagram, we send the
	 * current datagram `uncompressed'.
	 */
	oth = (struct tcphdr *)&((int32_t *)&cs->cs_ip)[hlen];
	deltaS = hlen;
	hlen += th->th_off;
	hlen <<= 2;

	if (((u_int16_t *)ip)[0] != ((u_int16_t *)&cs->cs_ip)[0] ||
	    ((u_int16_t *)ip)[3] != ((u_int16_t *)&cs->cs_ip)[3] ||
	    ((u_int16_t *)ip)[4] != ((u_int16_t *)&cs->cs_ip)[4] ||
	    th->th_off != oth->th_off ||
	    (deltaS > 5 &&
	     BCMP(ip + 1, &cs->cs_ip + 1, (deltaS - 5) << 2)) ||
	    (th->th_off > 5 &&
	     BCMP(th + 1, oth + 1, (th->th_off - 5) << 2)))
		goto uncompressed;

	/*
	 * Figure out which of the changing fields changed.  The
	 * receiver expects changes in the order: urgent, window,
	 * ack, seq (the order minimizes the number of temporaries
	 * needed in this section of code).
	 */
	if (th->th_flags & TH_URG) {
		deltaS = ntohs(th->th_urp);
		ENCODEZ(deltaS);
		changes |= NEW_U;
	} else if (th->th_urp != oth->th_urp)
		/* argh! URG not set but urp changed -- a sensible
		 * implementation should never do this but RFC793
		 * doesn't prohibit the change so we have to deal
		 * with it. */
		 goto uncompressed;

	deltaS = (u_int16_t)(ntohs(th->th_win) - ntohs(oth->th_win));
	if (deltaS) {
		ENCODE(deltaS);
		changes |= NEW_W;
	}

	deltaA = ntohl(th->th_ack) - ntohl(oth->th_ack);
	if (deltaA) {
		if (deltaA > 0xffff)
			goto uncompressed;
		ENCODE(deltaA);
		changes |= NEW_A;
	}

	deltaS = ntohl(th->th_seq) - ntohl(oth->th_seq);
	if (deltaS) {
		if (deltaS > 0xffff)
			goto uncompressed;
		ENCODE(deltaS);
		changes |= NEW_S;
	}

	switch(changes) {

	case 0:
		/*
		 * Nothing changed. If this packet contains data and the
		 * last one didn't, this is probably a data packet following
		 * an ack (normal on an interactive connection) and we send
		 * it compressed.  Otherwise it's probably a retransmit,
		 * retransmitted ack or window probe.  Send it uncompressed
		 * in case the other side missed the compressed version.
		 */
		if (ip->ip_len != cs->cs_ip.ip_len &&
		    ntohs(cs->cs_ip.ip_len) == hlen)
			break;

		/* FALLTHROUGH */

	case SPECIAL_I:
	case SPECIAL_D:
		/*
		 * actual changes match one of our special case encodings --
		 * send packet uncompressed.
		 */
		goto uncompressed;

	case NEW_S|NEW_A:
		if (deltaS == deltaA &&
		    deltaS == ntohs(cs->cs_ip.ip_len) - hlen) {
			/* special case for echoed terminal traffic */
			changes = SPECIAL_I;
			cp = new_seq;
		}
		break;

	case NEW_S:
		if (deltaS == ntohs(cs->cs_ip.ip_len) - hlen) {
			/* special case for data xfer */
			changes = SPECIAL_D;
			cp = new_seq;
		}
		break;
	}

	deltaS = ntohs(ip->ip_id) - ntohs(cs->cs_ip.ip_id);
	if (deltaS != 1) {
		ENCODEZ(deltaS);
		changes |= NEW_I;
	}
	if (th->th_flags & TH_PUSH)
		changes |= TCP_PUSH_BIT;
	/*
	 * Grab the cksum before we overwrite it below.  Then update our
	 * state with this packet's header.
	 */
	deltaA = ntohs(th->th_sum);
	BCOPY(ip, &cs->cs_ip, hlen);

	/*
	 * We want to use the original packet as our compressed packet.
	 * (cp - new_seq) is the number of bytes we need for compressed
	 * sequence numbers.  In addition we need one byte for the change
	 * mask, one for the connection id and two for the tcp checksum.
	 * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how
	 * many bytes of the original packet to toss so subtract the two to
	 * get the new packet size.
	 */
	deltaS = cp - new_seq;
	cp = (u_char *)ip;
	if (compress_cid == 0 || comp->last_xmit != cs->cs_id) {
		comp->last_xmit = cs->cs_id;
		hlen -= deltaS + 4;
		cp += hlen;
		*cp++ = changes | NEW_C;
		*cp++ = cs->cs_id;
	} else {
		hlen -= deltaS + 3;
		cp += hlen;
		*cp++ = changes;
	}
	m->m_len -= hlen;
	m->m_data += hlen;
	*cp++ = deltaA >> 8;
	*cp++ = deltaA;
	BCOPY(new_seq, cp, deltaS);
	INCR(sls_compressed)
	return (TYPE_COMPRESSED_TCP);

	/*
	 * Update connection state cs & send uncompressed packet ('uncompressed'
	 * means a regular ip/tcp packet but with the 'conversation id' we hope
	 * to use on future compressed packets in the protocol field).
	 */
uncompressed:
	BCOPY(ip, &cs->cs_ip, hlen);
	ip->ip_p = cs->cs_id;
	comp->last_xmit = cs->cs_id;
	return (TYPE_UNCOMPRESSED_TCP);
}


int
sl_uncompress_tcp(u_char **bufp, int len, u_int type, struct slcompress *comp)
{
	u_char *hdr, *cp;
	int hlen, vjlen;

	cp = bufp? *bufp: NULL;
	vjlen = sl_uncompress_tcp_core(cp, len, len, type, comp, &hdr, &hlen);
	if (vjlen < 0)
		return (0);	/* error */
	if (vjlen == 0)
		return (len);	/* was uncompressed already */

	cp += vjlen;
	len -= vjlen;

	/*
	 * At this point, cp points to the first byte of data in the
	 * packet.  If we're not aligned on a 4-byte boundary, copy the
	 * data down so the ip & tcp headers will be aligned.  Then back up
	 * cp by the tcp/ip header length to make room for the reconstructed
	 * header (we assume the packet we were handed has enough space to
	 * prepend 128 bytes of header).
	 */
	if ((long)cp & 3) {
		if (len > 0)
			(void) memmove((caddr_t)((long)cp &~ 3), cp, len);
		cp = (u_char *)((long)cp &~ 3);
	}
	cp -= hlen;
	len += hlen;
	BCOPY(hdr, cp, hlen);

	*bufp = cp;
	return (len);
}

/*
 * Uncompress a packet of total length total_len.  The first buflen
 * bytes are at buf; this must include the entire (compressed or
 * uncompressed) TCP/IP header.  This procedure returns the length
 * of the VJ header, with a pointer to the uncompressed IP header
 * in *hdrp and its length in *hlenp.
 */
int
sl_uncompress_tcp_core(u_char *buf, int buflen, int total_len, u_int type,
    struct slcompress *comp, u_char **hdrp, u_int *hlenp)
{
	u_char *cp;
	u_int hlen, changes;
	struct tcphdr *th;
	struct cstate *cs;
	struct ip *ip;
	u_int16_t *bp;
	u_int vjlen;

	switch (type) {

	case TYPE_UNCOMPRESSED_TCP:
		ip = (struct ip *) buf;
		if (ip->ip_p >= MAX_STATES)
			goto bad;
		cs = &comp->rstate[comp->last_recv = ip->ip_p];
		comp->flags &=~ SLF_TOSS;
		ip->ip_p = IPPROTO_TCP;
		/*
		 * Calculate the size of the TCP/IP header and make sure that
		 * we don't overflow the space we have available for it.
		 */
		hlen = ip->ip_hl << 2;
		if (hlen + sizeof(struct tcphdr) > buflen)
			goto bad;
		hlen += ((struct tcphdr *)&((char *)ip)[hlen])->th_off << 2;
		if (hlen > MAX_HDR || hlen > buflen)
			goto bad;
		BCOPY(ip, &cs->cs_ip, hlen);
		cs->cs_hlen = hlen;
		INCR(sls_uncompressedin)
		*hdrp = (u_char *) &cs->cs_ip;
		*hlenp = hlen;
		return (0);

	default:
		goto bad;

	case TYPE_COMPRESSED_TCP:
		break;
	}
	/* We've got a compressed packet. */
	INCR(sls_compressedin)
	cp = buf;
	changes = *cp++;
	if (changes & NEW_C) {
		/* Make sure the state index is in range, then grab the state.
		 * If we have a good state index, clear the 'discard' flag. */
		if (*cp >= MAX_STATES)
			goto bad;

		comp->flags &=~ SLF_TOSS;
		comp->last_recv = *cp++;
	} else {
		/* this packet has an implicit state index.  If we've
		 * had a line error since the last time we got an
		 * explicit state index, we have to toss the packet. */
		if (comp->flags & SLF_TOSS) {
			INCR(sls_tossed)
			return (-1);
		}
	}
	cs = &comp->rstate[comp->last_recv];
	hlen = cs->cs_ip.ip_hl << 2;
	th = (struct tcphdr *)&((u_char *)&cs->cs_ip)[hlen];
	th->th_sum = htons((*cp << 8) | cp[1]);
	cp += 2;
	if (changes & TCP_PUSH_BIT)
		th->th_flags |= TH_PUSH;
	else
		th->th_flags &=~ TH_PUSH;

	switch (changes & SPECIALS_MASK) {
	case SPECIAL_I:
		{
		u_int i = ntohs(cs->cs_ip.ip_len) - cs->cs_hlen;
		th->th_ack = htonl(ntohl(th->th_ack) + i);
		th->th_seq = htonl(ntohl(th->th_seq) + i);
		}
		break;

	case SPECIAL_D:
		th->th_seq = htonl(ntohl(th->th_seq) + ntohs(cs->cs_ip.ip_len)
				   - cs->cs_hlen);
		break;

	default:
		if (changes & NEW_U) {
			th->th_flags |= TH_URG;
			DECODEU(th->th_urp)
		} else
			th->th_flags &=~ TH_URG;
		if (changes & NEW_W)
			DECODES(th->th_win)
		if (changes & NEW_A)
			DECODEL(th->th_ack)
		if (changes & NEW_S)
			DECODEL(th->th_seq)
		break;
	}
	if (changes & NEW_I) {
		DECODES(cs->cs_ip.ip_id)
	} else
		cs->cs_ip.ip_id = htons(ntohs(cs->cs_ip.ip_id) + 1);

	/*
	 * At this point, cp points to the first byte of data in the
	 * packet.  Fill in the IP total length and update the IP
	 * header checksum.
	 */
	vjlen = cp - buf;
	buflen -= vjlen;
	if (buflen < 0)
		/* we must have dropped some characters (crc should detect
		 * this but the old slip framing won't) */
		goto bad;

	total_len += cs->cs_hlen - vjlen;
	cs->cs_ip.ip_len = htons(total_len);

	/* recompute the ip header checksum */
	bp = (u_int16_t *) &cs->cs_ip;
	cs->cs_ip.ip_sum = 0;
	for (changes = 0; hlen > 0; hlen -= 2)
		changes += *bp++;
	changes = (changes & 0xffff) + (changes >> 16);
	changes = (changes & 0xffff) + (changes >> 16);
	cs->cs_ip.ip_sum = ~ changes;

	*hdrp = (u_char *) &cs->cs_ip;
	*hlenp = cs->cs_hlen;
	return vjlen;

bad:
	comp->flags |= SLF_TOSS;
	INCR(sls_errorin)
	return (-1);
}
@


1.11
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: slcompress.c,v 1.10 2013/06/11 18:15:53 deraadt Exp $	*/
d63 1
a63 2
sl_compress_init(comp)
	struct slcompress *comp;
d87 1
a87 3
sl_compress_setup(comp, max_state)
 	struct slcompress *comp;
 	int max_state;
d166 2
a167 5
sl_compress_tcp(m, ip, comp, compress_cid)
	struct mbuf *m;
	struct ip *ip;
	struct slcompress *comp;
	int compress_cid;
d419 1
a419 5
sl_uncompress_tcp(bufp, len, type, comp)
	u_char **bufp;
	int len;
	u_int type;
	struct slcompress *comp;
d463 2
a464 7
sl_uncompress_tcp_core(buf, buflen, total_len, type, comp, hdrp, hlenp)
	u_char *buf;
	int buflen, total_len;
	u_int type;
	struct slcompress *comp;
	u_char **hdrp;
	u_int *hlenp;
@


1.10
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: slcompress.c,v 1.9 2007/02/14 00:53:48 jsg Exp $	*/
a47 1
#include <netinet/in_systm.h>
@


1.9
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slcompress.c,v 1.8 2003/12/10 07:22:42 itojun Exp $	*/
a61 4
#ifndef _KERNEL
#define ovbcopy bcopy
#endif

d455 1
a455 1
			(void) ovbcopy(cp, (caddr_t)((long)cp &~ 3), len);
@


1.8
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: slcompress.c,v 1.7 2003/06/02 23:28:12 millert Exp $	*/
d344 1
a344 1
		/* (fall through) */
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: slcompress.c,v 1.6 1997/09/05 04:27:04 millert Exp $	*/
d71 2
a72 2
	register u_int i;
	register struct cstate *tstate = comp->tstate;
d97 2
a98 2
	register u_int i;
	register struct cstate *tstate = comp->tstate;
d176 1
a176 1
	register struct ip *ip;
d180 6
a185 6
	register struct cstate *cs = comp->last_cs->cs_next;
	register u_int hlen = ip->ip_hl;
	register struct tcphdr *oth;
	register struct tcphdr *th;
	register u_int deltaS, deltaA;
	register u_int changes = 0;
d187 1
a187 1
	register u_char *cp = new_seq;
d224 2
a225 2
		register struct cstate *lcs;
		register struct cstate *lastcs = comp->last_cs;
d486 7
a492 7
	register u_char *cp;
	register u_int hlen, changes;
	register struct tcphdr *th;
	register struct cstate *cs;
	register struct ip *ip;
	register u_int16_t *bp;
	register u_int vjlen;
d560 1
a560 1
		register u_int i = ntohs(cs->cs_ip.ip_len) - cs->cs_hlen;
@


1.6
log
@Minor changes from ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: slcompress.c,v 1.5 1996/07/25 14:20:52 joshd Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6.12.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: slcompress.c,v 1.6 1997/09/05 04:27:04 millert Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.12.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 2
a72 2
	u_int i;
	struct cstate *tstate = comp->tstate;
d97 2
a98 2
	u_int i;
	struct cstate *tstate = comp->tstate;
d176 1
a176 1
	struct ip *ip;
d180 6
a185 6
	struct cstate *cs = comp->last_cs->cs_next;
	u_int hlen = ip->ip_hl;
	struct tcphdr *oth;
	struct tcphdr *th;
	u_int deltaS, deltaA;
	u_int changes = 0;
d187 1
a187 1
	u_char *cp = new_seq;
d224 2
a225 2
		struct cstate *lcs;
		struct cstate *lastcs = comp->last_cs;
d486 7
a492 7
	u_char *cp;
	u_int hlen, changes;
	struct tcphdr *th;
	struct cstate *cs;
	struct ip *ip;
	u_int16_t *bp;
	u_int vjlen;
d560 1
a560 1
		u_int i = ntohs(cs->cs_ip.ip_len) - cs->cs_hlen;
@


1.5
log
@Kernel changes for ppp2.3a4.
@
text
@d1 2
a2 2
/*	$OpenBSD: slcompress.c,v 1.4 1996/04/21 22:28:46 deraadt Exp $	*/
/*	$NetBSD: slcompress.c,v 1.15 1996/03/15 02:28:12 paulus Exp $	*/
d70 1
d72 1
a72 1
sl_compress_init(comp, max_state)
d74 26
a99 1
	int max_state;
d106 1
a106 1
	bzero((char *)comp, sizeof(*comp));
d507 10
a516 11
                /*
                 * Calculate the size of the TCP/IP header and make sure that
                 * we don't overflow the space we have available for it.
                 */
                hlen = ip->ip_hl << 2;
                if (hlen + sizeof(struct tcphdr) > buflen)
                        goto bad;
                hlen += ((struct tcphdr *)&((char *)ip)[hlen])->th_off << 2;
                if (hlen > MAX_HDR || hlen > buflen)
                        goto bad;

@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: slcompress.c,v 1.3 1996/03/03 21:07:22 niklas Exp $	*/
d481 11
a491 3
		hlen = ip->ip_hl;
		hlen += ((struct tcphdr *)&((int32_t *)ip)[hlen])->th_off;
		hlen <<= 2;
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: slcompress.c,v 1.14 1996/02/13 22:00:55 christos Exp $	*/
d78 1
a78 1
	if (max_state == -1)
d81 5
@


1.2
log
@from netbsd; fix casts; should cast pointers to longs, not ints
@
text
@d1 2
a2 1
/*	$NetBSD: slcompress.c,v 1.13 1995/11/20 20:43:33 cgd Exp $	*/
d49 1
d280 2
a281 1
	if (deltaS = (u_int16_t)(ntohs(th->th_win) - ntohs(oth->th_win))) {
d286 2
a287 1
	if (deltaA = ntohl(th->th_ack) - ntohl(oth->th_ack)) {
d294 2
a295 1
	if (deltaS = ntohl(th->th_seq) - ntohl(oth->th_seq)) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: slcompress.c,v 1.12 1995/07/04 06:28:28 paulus Exp $	*/
d425 1
a425 1
	if ((int)cp & 3) {
d427 2
a428 2
			(void) ovbcopy(cp, (caddr_t)((int)cp &~ 3), len);
		cp = (u_char *)((int)cp &~ 3);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
