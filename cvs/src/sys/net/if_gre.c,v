head	1.87;
access;
symbols
	OPENBSD_6_1:1.84.0.4
	OPENBSD_6_1_BASE:1.84
	OPENBSD_6_0:1.78.0.6
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.78.0.2
	OPENBSD_5_9_BASE:1.78
	OPENBSD_5_8:1.75.0.4
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.70.0.4
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.59.0.2
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.58.0.2
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.4
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.45.0.4
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.44.0.4
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.41.0.6
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.41.0.4
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.24
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6;
locks; strict;
comment	@ * @;


1.87
date	2017.08.11.21.24.19;	author mpi;	state Exp;
branches;
next	1.86;
commitid	qO4hXiGM2yDTtiTI;

1.86
date	2017.05.15.14.33.20;	author bluhm;	state Exp;
branches;
next	1.85;
commitid	eq87jc59cmIYiFIR;

1.85
date	2017.05.15.14.09.13;	author mpi;	state Exp;
branches;
next	1.84;
commitid	DHanu2pUx71ICGfr;

1.84
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.83;
commitid	6c6qq5OdS4VVnyVM;

1.83
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.82;
commitid	F6oNrr9LCLUSAxgA;

1.82
date	2016.12.19.15.50.18;	author mpi;	state Exp;
branches;
next	1.81;
commitid	eFtYznAk8GuhjOgb;

1.81
date	2016.11.16.14.50.13;	author mpi;	state Exp;
branches;
next	1.80;
commitid	Tssok5QYXp7KCsYx;

1.80
date	2016.08.31.15.00.02;	author reyk;	state Exp;
branches;
next	1.79;
commitid	7HICEJ2aTYkrMgNF;

1.79
date	2016.08.28.07.22.11;	author reyk;	state Exp;
branches;
next	1.78;
commitid	jIduHL9KU1lnm7G1;

1.78
date	2015.11.10.06.34.35;	author dlg;	state Exp;
branches;
next	1.77;
commitid	hzwo6DiiDUse3MSm;

1.77
date	2015.11.09.15.18.52;	author benno;	state Exp;
branches;
next	1.76;
commitid	7tq4V84fZuXEkZbc;

1.76
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.75;
commitid	G2nTzngqgXpQqcJB;

1.75
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.74;
commitid	STtcOm1B3VSMXz2h;

1.74
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.73;
commitid	p4LJxGKbi0BU2cG6;

1.73
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.72;
commitid	zhW8jJrfVCoAthrR;

1.72
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.71;
commitid	mdGXHklUZmESVFlY;

1.71
date	2014.10.14.09.52.25;	author mpi;	state Exp;
branches;
next	1.70;
commitid	6AYfDT0Lpez1LFQp;

1.70
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.69;
commitid	DQakU8LLWV6Iwx84;

1.69
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.68;
commitid	B4dZSbxas1X1IpXI;

1.68
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2014.04.21.12.22.25;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.64;

1.64
date	2013.10.19.14.46.30;	author mpi;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.17.16.27.40;	author bluhm;	state Exp;
branches;
next	1.62;

1.62
date	2013.06.05.15.17.40;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.28.00.32.11;	author bluhm;	state Exp;
branches;
next	1.59;

1.59
date	2012.11.23.20.12.03;	author sthen;	state Exp;
branches;
next	1.58;

1.58
date	2012.04.14.09.39.47;	author yasuoka;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.12.15.23.50;	author jsg;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.04.20.40.58;	author dhill;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.29.15.14.10;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.04.15.50.18;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.23.11.34.50;	author blambert;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.26.22.11.51;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.26.19.49.54;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.11.09.22.56;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.21.14.08.14;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.02.17.10.23;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.28.04.30.16;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.10.18.40.29;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.14.09.55.56;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.08.06.35.04;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.14.19.24.23;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.18.18.37.53;	author canacar;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.08.10.23.39;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.03.14.52.23;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2003.07.09.22.03.15;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.25.18.10.06;	author millert;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2003.01.04.22.36.12;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.28.15.43.02;	author pefo;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.10.23.06.55;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.09.18.00.08;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.09.17.32.35;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.09.17.25.58;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.03.20.35.58;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.27.03.49.53;	author angelos;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.06.25.06.31.44;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.25.06.30.22;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.25.01.50.16;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.22.14.28.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.05.23.43.45;	author maja;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.27.11.54.32;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.11.17.20.10;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.25.07.10.47;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.07.05.43.49;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.17.19.50.14;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.16.00.34.39;	author angelos;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.01.11.08.26.45;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.08.01.39.24;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.07.23.25.21;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.07.21.55.05;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.07.21.37.30;	author angelos;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.40.00;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.54.02;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;

1.26.2.1
date	2003.12.20.20.38.29;	author margarida;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2003.12.21.14.50.24;	author margarida;	state Exp;
branches;
next	;

1.28.2.1
date	2003.12.23.01.58.49;	author brad;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@/*      $OpenBSD: if_gre.c,v 1.86 2017/05/15 14:33:20 bluhm Exp $ */
/*	$NetBSD: if_gre.c,v 1.9 1999/10/25 19:18:11 drochner Exp $ */

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Heiko W.Rupp <hwr@@pilhuhn.de>
 *
 * IPv6-over-GRE contributed by Gert Doering <gert@@greenie.muc.de>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Encapsulate L3 protocols into IP, per RFC 1701 and 1702.
 * See gre(4) for more details.
 * Also supported: IP in IP encapsulation (proto 55) per RFC 2004.
 */

#include "gre.h"
#if NGRE > 0

#include "bpfilter.h"
#include "pf.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#endif

#include <net/if_gre.h>

#ifndef GRE_RECURSION_LIMIT
#define GRE_RECURSION_LIMIT	3   /* How many levels of recursion allowed */
#endif /* GRE_RECURSION_LIMIT */

/*
 * It is not easy to calculate the right value for a GRE MTU.
 * We leave this task to the admin and use the same default that
 * other vendors use.
 */
#define GREMTU 1476

int	gre_clone_create(struct if_clone *, int);
int	gre_clone_destroy(struct ifnet *);

struct gre_softc_head gre_softc_list;

struct if_clone gre_cloner =
    IF_CLONE_INITIALIZER("gre", gre_clone_create, gre_clone_destroy);
struct if_clone mobileip_cloner =
    IF_CLONE_INITIALIZER("mobileip", gre_clone_create, gre_clone_destroy);

/*
 * We can control the acceptance of GRE and MobileIP packets by
 * altering the sysctl net.inet.gre.allow and net.inet.mobileip.allow values
 * respectively. Zero means drop them, all else is acceptance.  We can also
 * control acceptance of WCCPv1-style GRE packets through the
 * net.inet.gre.wccp value, but be aware it depends upon normal GRE being
 * allowed as well.
 *
 */
int gre_allow = 0;
int gre_wccp = 0;
int ip_mobile_allow = 0;

void gre_keepalive(void *);
void gre_send_keepalive(void *);
void gre_link_state(struct gre_softc *);

void
greattach(int n)
{
	LIST_INIT(&gre_softc_list);
	if_clone_attach(&gre_cloner);
	if_clone_attach(&mobileip_cloner);
}

int
gre_clone_create(struct if_clone *ifc, int unit)
{
	struct gre_softc *sc;

	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!sc)
		return (ENOMEM);
	snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "%s%d",
	    ifc->ifc_name, unit);
	sc->sc_if.if_softc = sc;
	sc->sc_if.if_type = IFT_TUNNEL;
	sc->sc_if.if_addrlen = 0;
	sc->sc_if.if_hdrlen = 24; /* IP + GRE */
	sc->sc_if.if_mtu = GREMTU;
	sc->sc_if.if_flags = IFF_POINTOPOINT|IFF_MULTICAST;
	sc->sc_if.if_xflags = IFXF_CLONED;
	sc->sc_if.if_output = gre_output;
	sc->sc_if.if_ioctl = gre_ioctl;
	sc->sc_if.if_rtrequest = p2p_rtrequest;
	sc->sc_if.if_collisions = 0;
	sc->sc_if.if_ierrors = 0;
	sc->sc_if.if_oerrors = 0;
	sc->sc_if.if_ipackets = 0;
	sc->sc_if.if_opackets = 0;
	sc->g_dst.s_addr = sc->g_src.s_addr = INADDR_ANY;
	sc->sc_ka_state = GRE_STATE_UKNWN;

	if (strcmp("gre", ifc->ifc_name) == 0) {
		/* GRE encapsulation */
		sc->g_proto = IPPROTO_GRE;
	} else {
		/* Mobile IP encapsulation */
		sc->g_proto = IPPROTO_MOBILE;
	}

	timeout_set(&sc->sc_ka_hold, gre_keepalive, sc);
	timeout_set_proc(&sc->sc_ka_snd, gre_send_keepalive, sc);

	if_attach(&sc->sc_if);
	if_alloc_sadl(&sc->sc_if);

#if NBPFILTER > 0
	bpfattach(&sc->sc_if.if_bpf, &sc->sc_if, DLT_LOOP, sizeof(u_int32_t));
#endif
	NET_LOCK();
	LIST_INSERT_HEAD(&gre_softc_list, sc, sc_list);
	NET_UNLOCK();

	return (0);
}

int
gre_clone_destroy(struct ifnet *ifp)
{
	struct gre_softc *sc = ifp->if_softc;

	timeout_del(&sc->sc_ka_snd);
	timeout_del(&sc->sc_ka_hold);
	NET_LOCK();
	LIST_REMOVE(sc, sc_list);
	NET_UNLOCK();

	if_detach(ifp);

	free(sc, M_DEVBUF, sizeof(*sc));
	return (0);
}

/*
 * The output routine. Takes a packet and encapsulates it in the protocol
 * given by sc->g_proto. See also RFC 1701 and RFC 2004.
 */

int
gre_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
	   struct rtentry *rt)
{
	int error = 0;
	struct gre_softc *sc = (struct gre_softc *) (ifp->if_softc);
	struct greip *gh = NULL;
	struct ip *inp = NULL;
	u_int8_t ip_tos = 0;
	u_int16_t etype = 0;
	struct mobile_h mob_h;
	struct m_tag *mtag;

	if ((ifp->if_flags & IFF_UP) == 0 ||
	    sc->g_src.s_addr == INADDR_ANY || sc->g_dst.s_addr == INADDR_ANY) {
		m_freem(m);
		error = ENETDOWN;
		goto end;
	}

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.ph_rtableid),
		    dst->sa_family);
	}
#endif

	/* Try to limit infinite recursion through misconfiguration. */
	for (mtag = m_tag_find(m, PACKET_TAG_GRE, NULL); mtag;
	     mtag = m_tag_find(m, PACKET_TAG_GRE, mtag)) {
		if (!bcmp((caddr_t)(mtag + 1), &ifp, sizeof(struct ifnet *))) {
			m_freem(m);
			error = EIO;
			goto end;
		}
	}

	mtag = m_tag_get(PACKET_TAG_GRE, sizeof(struct ifnet *), M_NOWAIT);
	if (mtag == NULL) {
		m_freem(m);
		error = ENOBUFS;
		goto end;
	}
	bcopy(&ifp, (caddr_t)(mtag + 1), sizeof(struct ifnet *));
	m_tag_prepend(m, mtag);

	m->m_flags &= ~(M_BCAST|M_MCAST);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m, BPF_DIRECTION_OUT);
#endif

	if (sc->g_proto == IPPROTO_MOBILE) {
		if (ip_mobile_allow == 0) {
			m_freem(m);
			error = EACCES;
			goto end;
		}

		if (dst->sa_family == AF_INET) {
			struct mbuf *m0;
			int msiz;

			/*
			 * Make sure the complete IP header (with options)
			 * is in the first mbuf.
			 */
			if (m->m_len < sizeof(struct ip)) {
				m = m_pullup(m, sizeof(struct ip));
				if (m == NULL) {
					error = ENOBUFS;
					goto end;
				} else
					inp = mtod(m, struct ip *);

				if (m->m_len < inp->ip_hl << 2) {
					m = m_pullup(m, inp->ip_hl << 2);
					if (m == NULL) {
						error = ENOBUFS;
						goto end;
					}
				}
			}

			inp = mtod(m, struct ip *);

			bzero(&mob_h, MOB_H_SIZ_L);
			mob_h.proto = (inp->ip_p) << 8;
			mob_h.odst = inp->ip_dst.s_addr;
			inp->ip_dst.s_addr = sc->g_dst.s_addr;

			/*
			 * If the packet comes from our host, we only change
			 * the destination address in the IP header.
			 * Otherwise we need to save and change the source.
			 */
			if (inp->ip_src.s_addr == sc->g_src.s_addr) {
				msiz = MOB_H_SIZ_S;
			} else {
				mob_h.proto |= MOB_H_SBIT;
				mob_h.osrc = inp->ip_src.s_addr;
				inp->ip_src.s_addr = sc->g_src.s_addr;
				msiz = MOB_H_SIZ_L;
			}

			mob_h.proto = htons(mob_h.proto);
			mob_h.hcrc = gre_in_cksum((u_int16_t *) &mob_h, msiz);

			/* Squeeze in the mobility header */
			if ((m->m_data - msiz) < m->m_pktdat) {
				/* Need new mbuf */
				MGETHDR(m0, M_DONTWAIT, MT_HEADER);
				if (m0 == NULL) {
					m_freem(m);
					error = ENOBUFS;
					goto end;
				}
				M_MOVE_HDR(m0, m);

				m0->m_len = msiz + (inp->ip_hl << 2);
				m0->m_data += max_linkhdr;
				m0->m_pkthdr.len = m->m_pkthdr.len + msiz;
				m->m_data += inp->ip_hl << 2;
				m->m_len -= inp->ip_hl << 2;

				bcopy((caddr_t) inp, mtod(m0, caddr_t),
				    sizeof(struct ip));

				m0->m_next = m;
				m = m0;
			} else {  /* we have some space left in the old one */
				m->m_data -= msiz;
				m->m_len += msiz;
				m->m_pkthdr.len += msiz;
				bcopy(inp, mtod(m, caddr_t),
				    inp->ip_hl << 2);
			}

			/* Copy Mobility header */
			inp = mtod(m, struct ip *);
			bcopy(&mob_h, (caddr_t)(inp + 1), (unsigned) msiz);
			inp->ip_len = htons(ntohs(inp->ip_len) + msiz);
		} else {  /* AF_INET */
			m_freem(m);
			error = EINVAL;
			goto end;
		}
	} else if (sc->g_proto == IPPROTO_GRE) {
		if (gre_allow == 0) {
			m_freem(m);
			error = EACCES;
			goto end;
		}

		switch(dst->sa_family) {
		case AF_INET:
			if (m->m_len < sizeof(struct ip)) {
				m = m_pullup(m, sizeof(struct ip));
				if (m == NULL) {
					error = ENOBUFS;
					goto end;
				}
			}

			inp = mtod(m, struct ip *);
			ip_tos = inp->ip_tos;
			etype = ETHERTYPE_IP;
			break;
#ifdef INET6
		case AF_INET6:
			etype = ETHERTYPE_IPV6;
			break;
#endif
#ifdef MPLS
		case AF_MPLS:
			if (m->m_flags & (M_BCAST | M_MCAST))
				etype = ETHERTYPE_MPLS_MCAST;
			else
				etype = ETHERTYPE_MPLS;
			break;
#endif
		default:
			m_freem(m);
			error = EAFNOSUPPORT;
			goto end;
		}

		M_PREPEND(m, sizeof(struct greip), M_DONTWAIT);
	} else {
		m_freem(m);
		error = EINVAL;
		goto end;
	}

	if (m == NULL) {
		error = ENOBUFS;
		goto end;
	}

	gh = mtod(m, struct greip *);
	if (sc->g_proto == IPPROTO_GRE) {
		/* We don't support any GRE flags for now */

		bzero((void *) &gh->gi_g, sizeof(struct gre_h));
		gh->gi_ptype = htons(etype);
	}

	gh->gi_pr = sc->g_proto;
	if (sc->g_proto != IPPROTO_MOBILE) {
		gh->gi_src = sc->g_src;
		gh->gi_dst = sc->g_dst;
		((struct ip *) gh)->ip_hl = (sizeof(struct ip)) >> 2;
		((struct ip *) gh)->ip_ttl = ip_defttl;
		((struct ip *) gh)->ip_tos = ip_tos;
		gh->gi_len = htons(m->m_pkthdr.len);
	}

	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;


	m->m_pkthdr.ph_rtableid = sc->g_rtableid;

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif

	/* Send it off */
	error = ip_output(m, NULL, &sc->route, 0, NULL, NULL, 0);
  end:
	if (error)
		ifp->if_oerrors++;
	return (error);
}

int
gre_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{

	struct ifreq *ifr = (struct ifreq *)data;
	struct if_laddrreq *lifr = (struct if_laddrreq *)data;
	struct ifkalivereq *ikar = (struct ifkalivereq *)data;
	struct gre_softc *sc = ifp->if_softc;
	struct sockaddr_in si;
	int error = 0;
	struct proc *prc = curproc;		/* XXX */

	switch(cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		break;
	case SIOCSIFDSTADDR:
		break;
	case SIOCSIFFLAGS:
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < 576) {
			error = EINVAL;
			break;
		}
		ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCGIFMTU:
		ifr->ifr_mtu = sc->sc_if.if_mtu;
		break;
	case SIOCGIFHARDMTU:
		ifr->ifr_hardmtu = sc->sc_if.if_hardmtu;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;
	case SIOCSETKALIVE:
		if ((error = suser(prc, 0)) != 0)
			break;
		if (ikar->ikar_timeo < 0 || ikar->ikar_timeo > 86400 ||
		    ikar->ikar_cnt < 0 || ikar->ikar_cnt > 256) {
			error = EINVAL;
			break;
		}
		sc->sc_ka_timout = ikar->ikar_timeo;
		sc->sc_ka_cnt = ikar->ikar_cnt;
		if (sc->sc_ka_timout == 0 || sc->sc_ka_cnt == 0) {
			sc->sc_ka_timout = 0;
			sc->sc_ka_cnt = 0;
			sc->sc_ka_state = GRE_STATE_UKNWN;
			gre_link_state(sc);
			break;
		}
		if (!timeout_pending(&sc->sc_ka_snd)) {
			sc->sc_ka_holdmax = sc->sc_ka_cnt;
			timeout_add(&sc->sc_ka_snd, 1);
			timeout_add_sec(&sc->sc_ka_hold, sc->sc_ka_timout *
			    sc->sc_ka_cnt);
		}
		break;
	case SIOCGETKALIVE:
		ikar->ikar_timeo = sc->sc_ka_timout;
		ikar->ikar_cnt = sc->sc_ka_cnt;
		break;
	case SIOCSLIFPHYADDR:
		if ((error = suser(prc, 0)) != 0)
			break;
		if (lifr->addr.ss_family != AF_INET ||
		    lifr->dstaddr.ss_family != AF_INET) {
			error = EAFNOSUPPORT;
			break;
		}
		if (lifr->addr.ss_len != sizeof(si) ||
		    lifr->dstaddr.ss_len != sizeof(si)) {
			error = EINVAL;
			break;
		}
		sc->g_src = ((struct sockaddr_in *)&lifr->addr)->sin_addr;
		sc->g_dst = ((struct sockaddr_in *)&lifr->dstaddr)->sin_addr;
 recompute:
		if ((sc->g_src.s_addr != INADDR_ANY) &&
		    (sc->g_dst.s_addr != INADDR_ANY)) {
			if (sc->route.ro_rt != NULL) {
				rtfree(sc->route.ro_rt);
				sc->route.ro_rt = NULL;
			}
			/* ip_output() will do the lookup */
			bzero(&sc->route, sizeof(sc->route));
			ifp->if_flags |= IFF_UP;
		}
		break;
	case SIOCDIFPHYADDR:
		if ((error = suser(prc, 0)) != 0)
			break;
		sc->g_src.s_addr = INADDR_ANY;
		sc->g_dst.s_addr = INADDR_ANY;
		break;
	case SIOCGLIFPHYADDR:
		if (sc->g_src.s_addr == INADDR_ANY ||
		    sc->g_dst.s_addr == INADDR_ANY) {
			error = EADDRNOTAVAIL;
			break;
		}
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
		si.sin_addr.s_addr = sc->g_src.s_addr;
		memcpy(&lifr->addr, &si, sizeof(si));
		si.sin_addr.s_addr = sc->g_dst.s_addr;
		memcpy(&lifr->dstaddr, &si, sizeof(si));
		break;
	case SIOCSLIFPHYRTABLE:
		if ((error = suser(prc, 0)) != 0)
			break;
		if (ifr->ifr_rdomainid < 0 ||
		    ifr->ifr_rdomainid > RT_TABLEID_MAX ||
		    !rtable_exists(ifr->ifr_rdomainid)) {
			error = EINVAL;
			break;
		}
		sc->g_rtableid = ifr->ifr_rdomainid;
		goto recompute;
	case SIOCGLIFPHYRTABLE:
		ifr->ifr_rdomainid = sc->g_rtableid;
		break;
	default:
		error = ENOTTY;
	}

	return (error);
}

/*
 * do a checksum of a buffer - much like in_cksum, which operates on
 * mbufs.
 */
u_int16_t
gre_in_cksum(u_int16_t *p, u_int len)
{
	u_int32_t sum = 0;
	int nwords = len >> 1;

	while (nwords-- != 0)
		sum += *p++;

	if (len & 1) {
		union {
			u_short w;
			u_char c[2];
		} u;
		u.c[0] = *(u_char *) p;
		u.c[1] = 0;
		sum += u.w;
	}

	/* end-around-carry */
	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);
	return (~sum);
}

void
gre_keepalive(void *arg)
{
	struct gre_softc *sc = arg;

	if (!sc->sc_ka_timout)
		return;

	sc->sc_ka_state = GRE_STATE_DOWN;
	gre_link_state(sc);
}

void
gre_send_keepalive(void *arg)
{
	struct gre_softc *sc = arg;
	struct mbuf *m;
	struct ip *ip;
	struct gre_h *gh;
	struct sockaddr dst;

	if (sc->sc_ka_timout)
		timeout_add_sec(&sc->sc_ka_snd, sc->sc_ka_timout);

	if (sc->g_proto != IPPROTO_GRE)
		return;
	if ((sc->sc_if.if_flags & IFF_UP) == 0 ||
	    sc->g_src.s_addr == INADDR_ANY || sc->g_dst.s_addr == INADDR_ANY)
		return;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		sc->sc_if.if_oerrors++;
		return;
	}

	m->m_len = m->m_pkthdr.len = sizeof(*ip) + sizeof(*gh);
	MH_ALIGN(m, m->m_len);

	/* use the interface's rdomain when sending keepalives. */
	m->m_pkthdr.ph_rtableid = sc->sc_if.if_rdomain;

	/* build the ip header */
	ip = mtod(m, struct ip *);

	ip->ip_v = IPVERSION;
	ip->ip_hl = sizeof(*ip) >> 2;
	ip->ip_tos = IPTOS_LOWDELAY;
	ip->ip_len = htons(m->m_pkthdr.len);
	ip->ip_id = htons(ip_randomid());
	ip->ip_off = htons(IP_DF);
	ip->ip_ttl = ip_defttl;
	ip->ip_p = IPPROTO_GRE;
	ip->ip_src.s_addr = sc->g_dst.s_addr;
	ip->ip_dst.s_addr = sc->g_src.s_addr;
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, sizeof(*ip));

	gh = (struct gre_h *)(ip + 1);
	/* We don't support any GRE flags for now */
	bzero(gh, sizeof(*gh));

	bzero(&dst, sizeof(dst));
	dst.sa_family = AF_INET;

	NET_LOCK();
	/* should we care about the error? */
	gre_output(&sc->sc_if, m, &dst, NULL);
	NET_UNLOCK();
}

void
gre_recv_keepalive(struct gre_softc *sc)
{
	if (!sc->sc_ka_timout)
		return;

	/* link state flap dampening */
	switch (sc->sc_ka_state) {
	case GRE_STATE_UKNWN:
	case GRE_STATE_DOWN:
		sc->sc_ka_state = GRE_STATE_HOLD;
		sc->sc_ka_holdcnt = sc->sc_ka_holdmax;
		sc->sc_ka_holdmax = MIN(sc->sc_ka_holdmax * 2,
		    16 * sc->sc_ka_cnt);
		break;
	case GRE_STATE_HOLD:
		if (--sc->sc_ka_holdcnt < 1) {
			sc->sc_ka_state = GRE_STATE_UP;
			gre_link_state(sc);
		}
		break;
	case GRE_STATE_UP:
		sc->sc_ka_holdmax--;
		sc->sc_ka_holdmax = MAX(sc->sc_ka_holdmax, sc->sc_ka_cnt);
		break;
	}

	/* rescedule hold timer */
	timeout_add_sec(&sc->sc_ka_hold, sc->sc_ka_timout * sc->sc_ka_cnt);
}

void
gre_link_state(struct gre_softc *sc)
{
	struct ifnet *ifp = &sc->sc_if;
	int link_state = LINK_STATE_UNKNOWN;

	if (sc->sc_ka_state == GRE_STATE_UP)
		link_state = LINK_STATE_UP;
	else if (sc->sc_ka_state != GRE_STATE_UKNWN)
		link_state = LINK_STATE_KALIVE_DOWN;

	if (ifp->if_link_state != link_state) {
		ifp->if_link_state = link_state;
		if_link_state_change(ifp);
	}
}
#endif
@


1.86
log
@Remove unused variable mobileip_softc_list.
OK mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.85 2017/05/15 14:09:13 mpi Exp $ */
a123 1
	int s;
d165 1
a165 1
	NET_LOCK(s);
d167 1
a167 1
	NET_UNLOCK(s);
a175 1
	int s;
d179 1
a179 1
	NET_LOCK(s);
d181 1
a181 1
	NET_UNLOCK(s);
a612 1
	int s;
d658 1
a658 1
	NET_LOCK(s);
d661 1
a661 1
	NET_UNLOCK(s);
@


1.85
log
@Protect the gloal list of gre(4) interfaces by the NET_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.84 2017/01/24 10:08:30 krw Exp $ */
a88 1
struct gre_softc_head mobileip_softc_list;
a115 1
	LIST_INIT(&mobileip_softc_list);
@


1.84
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.83 2017/01/23 11:37:29 mpi Exp $ */
d168 1
a168 1
	s = splnet();
d170 1
a170 1
	splx(s);
a180 1
	s = splnet();
d183 1
d185 1
a185 1
	splx(s);
a443 1
	int s;
a447 1
	s = splnet();
a564 1
	splx(s);
@


1.83
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.82 2016/12/19 15:50:18 mpi Exp $ */
d103 1
a103 1
 * 
d152 1
a152 1
		/* GRE encapsulation */	
@


1.82
log
@Sending keep alive ends up in ip_output(), so it needs the NET_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.81 2016/11/16 14:50:13 mpi Exp $ */
d139 1
@


1.81
log
@Convert gre_send_keepalive() to timeout_set_proc(9) as it calls ip_output().
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.80 2016/08/31 15:00:02 reyk Exp $ */
d665 1
a665 1
	s = splsoftnet();
d668 1
a668 1
	splx(s);
@


1.80
log
@Split gre(4) into two interfaces: gre(4) and mobileip(4).

Like vlan/svlan and tun/tap, it remains a single driver that decides
on the mode based on the interface name.  This removes the need for
removing the default link0 flag to turn gre into Mobile IP mode.
Using linkX / IFF_LINK{0,1,2} for interface modes is a deprecated style.

OK millert@@ dlg@@ many

Not much consensus on the name but mobileip is also used for the sysctls, so
OK henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.79 2016/08/28 07:22:11 reyk Exp $ */
d159 1
a159 1
	timeout_set(&sc->sc_ka_snd, gre_send_keepalive, sc);
@


1.79
log
@Remove obsolete gre(4) ioctls GRESADDRS, GRESADDRD, GREGADDRS,
GREGADDRD, GRESPROTO, and GREGPROTO.  They have been replaced by
generic ioctls some time ago (eg. the "ifconfig gre0 tunnel") and
there is no need to keep the old ones around.  They are neither used
in base nor in ports.

OK sthen@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.78 2015/11/10 06:34:35 dlg Exp $ */
d89 2
d93 2
d117 1
d119 1
a147 2
	sc->g_proto = IPPROTO_GRE;
	sc->sc_if.if_flags |= IFF_LINK0;
d150 8
a455 4
		if ((ifr->ifr_flags & IFF_LINK0) != 0)
			sc->g_proto = IPPROTO_GRE;
		else
			sc->g_proto = IPPROTO_MOBILE;
@


1.78
log
@dont use IF_DROP when there was some arbitary problem sending a packet.

IF_DROP increments the drop counter on the send queue, it exists
to indicate a drop on the send queue. if there was an error sending
a packet be content incrementing if_oerrors.

ok mpi@@ uebayasi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.77 2015/11/09 15:18:52 benno Exp $ */
a432 1
	struct sockaddr *sa = NULL;
a464 63
	case GRESPROTO:
		/* Check for superuser */
		if ((error = suser(prc, 0)) != 0)
			break;

		sc->g_proto = ifr->ifr_flags;
		switch (sc->g_proto) {
		case IPPROTO_GRE:
			ifp->if_flags |= IFF_LINK0;
			break;
		case IPPROTO_MOBILE:
			ifp->if_flags &= ~IFF_LINK0;
			break;
		default:
			error = EPROTONOSUPPORT;
			break;
		}
		break;
	case GREGPROTO:
		ifr->ifr_flags = sc->g_proto;
		break;
	case GRESADDRS:
	case GRESADDRD:
		/* Check for superuser */
		if ((error = suser(prc, 0)) != 0)
			break;

		/*
		 * set tunnel endpoints and mark if as up
		 */
		sa = &ifr->ifr_addr;
		if (cmd == GRESADDRS )
			sc->g_src = (satosin(sa))->sin_addr;
		if (cmd == GRESADDRD )
			sc->g_dst = (satosin(sa))->sin_addr;
recompute:
		if ((sc->g_src.s_addr != INADDR_ANY) &&
		    (sc->g_dst.s_addr != INADDR_ANY)) {
			if (sc->route.ro_rt != NULL) {
				rtfree(sc->route.ro_rt);
				sc->route.ro_rt = NULL;
			}
			/* ip_output() will do the lookup */
			bzero(&sc->route, sizeof(sc->route));
			ifp->if_flags |= IFF_UP;
		}
		break;
	case GREGADDRS:
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
		si.sin_addr.s_addr = sc->g_src.s_addr;
		sa = sintosa(&si);
		ifr->ifr_addr = *sa;
		break;
	case GREGADDRD:
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
		si.sin_addr.s_addr = sc->g_dst.s_addr;
		sa = sintosa(&si);
		ifr->ifr_addr = *sa;
		break;
d508 12
a519 1
		goto recompute;
@


1.77
log
@use the correct rdomain when sending gre(4) keepalive packets.
bug found and fixed by Joonas Ruohonen, thanks
ok claudio@@ phessler@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.76 2015/10/25 11:58:11 mpi Exp $ */
a217 1
			IF_DROP(&ifp->if_snd);
a225 1
		IF_DROP(&ifp->if_snd);
a241 1
			IF_DROP(&ifp->if_snd);
a257 1
					IF_DROP(&ifp->if_snd);
a265 1
						IF_DROP(&ifp->if_snd);
a300 1
					IF_DROP(&ifp->if_snd);
a330 1
			IF_DROP(&ifp->if_snd);
a336 1
			IF_DROP(&ifp->if_snd);
a346 1
					IF_DROP(&ifp->if_snd);
a369 1
			IF_DROP(&ifp->if_snd);
a376 1
		IF_DROP(&ifp->if_snd);
a382 1
		IF_DROP(&ifp->if_snd);
@


1.76
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.75 2015/07/16 16:12:15 mpi Exp $ */
d695 3
@


1.75
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.74 2015/03/14 03:38:51 jsg Exp $ */
d135 1
a439 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a452 1
		ifa->ifa_rtrequest = p2p_rtrequest;
@


1.74
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.73 2014/12/19 17:14:39 tedu Exp $ */
d297 1
a297 1
			HTONS(mob_h.proto);
@


1.73
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.72 2014/11/23 07:39:02 deraadt Exp $ */
a56 1
#include <net/netisr.h>
@


1.72
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.71 2014/10/14 09:52:25 mpi Exp $ */
a59 1
#ifdef INET
a63 3
#else
#error "if_gre used without inet"
#endif
@


1.71
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.70 2014/07/22 11:06:09 mpi Exp $ */
d180 1
a180 1
	free(sc, M_DEVBUF, 0);
@


1.70
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.69 2014/07/12 18:44:22 tedu Exp $ */
d522 4
a525 2
			if (sc->route.ro_rt != 0)
				RTFREE(sc->route.ro_rt);
@


1.69
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.68 2014/05/05 11:44:33 mpi Exp $ */
a61 1
#include <netinet/in_systm.h>
@


1.68
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.67 2014/04/21 12:22:25 henning Exp $ */
d181 1
a181 1
	free(sc, M_DEVBUF);
@


1.67
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.66 2014/04/21 11:10:54 henning Exp $ */
d444 2
a445 1
	struct ifreq *ifr = (struct ifreq *) data;
d459 1
@


1.66
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.64 2013/10/19 14:46:30 mpi Exp $ */
d433 1
a433 1
	error = ip_output(m, NULL, &sc->route, 0, NULL, NULL);
@


1.65
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d433 1
a433 1
	error = ip_output(m, (void *)NULL, &sc->route, 0, (void *)NULL, (void *)NULL);
@


1.64
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.63 2013/10/17 16:27:40 bluhm Exp $ */
d211 1
a211 1
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
d214 1
a214 1
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain),
d426 1
a426 1
	m->m_pkthdr.rdomain = sc->g_rtableid;
@


1.63
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.62 2013/06/05 15:17:40 bluhm Exp $ */
a481 17
		if (ifr == 0) {
			error = EAFNOSUPPORT;
			break;
		}
		switch (ifr->ifr_addr.sa_family) {
#ifdef INET
		case AF_INET:
			break;
#endif
#ifdef INET6
		case AF_INET6:
			break;
#endif
		default:
			error = EAFNOSUPPORT;
			break;
		}
@


1.62
log
@Include sys/timeout.h to make if_gre.c compile without pf.
No binary change.  OK henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.61 2013/03/28 16:45:16 tedu Exp $ */
a62 1
#include <netinet/in_var.h>
@


1.61
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.60 2013/03/28 00:32:11 bluhm Exp $ */
d53 1
@


1.60
log
@Unfortunately the satosin, sintosa, ifatoia, satosin6, sin6tosa,
ifatoia6 macros do not check the source type.  They just cast
anything.  Remove needless casts and do not use those macros if the
source type does not match.  Remove duplicate defines.
No binary change.  OK kettenis@@ krw@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.59 2012/11/23 20:12:03 sthen Exp $ */
a47 1
#include <sys/proc.h>
@


1.59
log
@Add SIOCGIFHARDMTU to allow retrieving the driver's maximum supported MTU
looks fine reyk@@ ok mikeb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.58 2012/04/14 09:39:47 yasuoka Exp $ */
d603 2
a604 3
		sc->g_src = (satosin((struct sockadrr *)&lifr->addr))->sin_addr;
		sc->g_dst =
		    (satosin((struct sockadrr *)&lifr->dstaddr))->sin_addr;
@


1.58
log
@Use DLT_LOOP for all tunneling interfaces.
Byte order adjustment for bpf was hidden behind bpf_mtap_af() and
sizeof(u_int32_t) is used for length of the bpf header.

tested by sebastia and mxb at alumni.chalmers.se.
ok claudio
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.57 2011/07/12 15:23:50 jsg Exp $ */
d477 3
@


1.57
log
@break up a line of code that involved a decrement operator and macros
so it evaluates in the order we want.

ok claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.56 2011/07/09 00:47:18 henning Exp $ */
d159 1
a159 2
	bpfattach(&sc->sc_if.if_bpf, &sc->sc_if, DLT_NULL,
	    sizeof(u_int32_t));
@


1.56
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.55 2011/07/04 20:40:58 dhill Exp $ */
d767 2
a768 1
		sc->sc_ka_holdmax = MAX(sc->sc_ka_holdmax--, sc->sc_ka_cnt);
@


1.55
log
@use mtod.

no change in binary

"Sure" claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.54 2011/04/29 15:14:10 claudio Exp $ */
a70 6
#ifdef NETATALK
#include <netatalk/at.h>
#include <netatalk/at_var.h>
#include <netatalk/at_extern.h>
#endif

a371 5
#ifdef NETATALK
		case AF_APPLETALK:
			etype = ETHERTYPE_AT;
			break;
#endif
@


1.54
log
@Why precompute the route for the gre tunnel when ip_output can do
that for you without the nasty side-effects of the precomputation?
Fixes strange problems seen on directly connected tunnels and
probably behaves a lot better. This still caches to route for
subsequent packets.
Testing and OK phessler
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.53 2011/04/04 15:50:18 claudio Exp $ */
d728 1
a728 1
	ip = (struct ip *)m->m_data;
@


1.53
log
@Don't do crazy address manipulations when looking up the remote end
of the gre(4) tunnel. Instead just us a RT_NOCLONING route lookup
and be done with it. Makes gre(4) work between systems in the same
LAN. This diff was enough long on tech@@ and nobody complained.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.52 2010/09/23 11:34:50 blambert Exp $ */
a117 1
void gre_compute_route(struct gre_softc *);
d538 1
a538 2
		 * set tunnel endpoints, compute a less specific route
		 * to the remote end and mark if as up
d548 1
a548 2
			if (sc->route.ro_rt != 0) {
				/* free old route */
d550 2
a551 3
				sc->route.ro_rt = (struct rtentry *) 0;
			}
			gre_compute_route(sc);
a655 41
}

/*
 * computes a route to our destination that is not the one
 * which would be taken by ip_output(), as this one will loop back to
 * us. If the interface is p2p as  a--->b, then a routing entry exists
 * If we now send a packet to b (e.g. ping b), this will come down here
 * gets src=a, dst=b tacked on and would from ip_output() sent back to
 * if_gre.
 * Goal here is to compute a route to b that is less specific than
 * a-->b. We know that this one exists as in normal operation we have
 * at least a default route which matches.
 */

void
gre_compute_route(struct gre_softc *sc)
{
	struct route *ro;

	ro = &sc->route;

	bzero(ro, sizeof(struct route));
	ro->ro_dst.sa_family = AF_INET;
	ro->ro_dst.sa_len = sizeof(ro->ro_dst);
	((struct sockaddr_in *) &ro->ro_dst)->sin_addr = sc->g_dst;

	ro->ro_rt = rtalloc1(&ro->ro_dst, RT_REPORT | RT_NOCLONING,
	    sc->g_rtableid);
	if (ro->ro_rt == NULL)
		return;

	/*
	 * Check whether we just created a loop. An even more paranoid
	 * check would be against all GRE interfaces, but that would
	 * not allow people to link GRE tunnels.
	 */
	if (ro->ro_rt->rt_ifp == &sc->sc_if) {
		RTFREE(ro->ro_rt);
		ro->ro_rt = NULL;
		return;
	}
@


1.52
log
@fix indentation to not confusingly align with an unassociated while() statement

ok claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.51 2010/07/03 04:44:51 guenther Exp $ */
a677 1
	u_int32_t a, b, c;
a681 1
	((struct sockaddr_in *) &ro->ro_dst)->sin_addr = sc->g_dst;
d684 1
a684 15

	/*
	 * toggle last bit, so our interface is not found, but a less
	 * specific route. I'd rather like to specify a shorter mask,
 	 * but this is not possible. Should work though. XXX
	 * there is a simpler way ...
	 */
	if ((sc->sc_if.if_flags & IFF_LINK1) == 0) {
		a = ntohl(sc->g_dst.s_addr);
		b = a & 0x01;
		c = a & 0xfffffffe;
		b = b ^ 0x01;
		a = b | c;
		((struct sockaddr_in *) &ro->ro_dst)->sin_addr.s_addr = htonl(a);
	}
a700 7

	/*
	 * now change it back - else ip_output will just drop
	 * the route and search one to this interface ...
	 */
	if ((sc->sc_if.if_flags & IFF_LINK1) == 0)
		((struct sockaddr_in *) &ro->ro_dst)->sin_addr = sc->g_dst;
@


1.51
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.50 2010/06/26 22:11:51 claudio Exp $ */
d739 9
a747 9
		if (len & 1) {
			union {
				u_short w;
				u_char c[2];
			} u;
			u.c[0] = *(u_char *) p;
			u.c[1] = 0;
			sum += u.w;
		}
d749 4
a752 4
		/* end-around-carry */
		sum = (sum >> 16) + (sum & 0xffff);
		sum += (sum >> 16);
		return (~sum);
@


1.50
log
@timeout_del() the timers before destroying an interface so that no timeout
is fired afterwards. Fixes a use after free crash.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.49 2010/06/26 19:49:54 claudio Exp $ */
d640 1
a640 1
	case SIOCSLIFPHYRTABLEID:
d651 1
a651 1
	case SIOCGLIFPHYRTABLEID:
@


1.49
log
@Implement a simple keepalive mechanism in gre(4) that is compatible with
the one used by Cisco. It sends a return gre packet inside a gre packet
to the other side and expects it to return.
OK deraadt, reyk additional testing by sthen
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.48 2010/05/11 09:22:56 claudio Exp $ */
d183 2
@


1.48
log
@Add support for MPLS in GRE. Fairly trivial and a NOP unless option MPLS
is defined.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.47 2010/05/07 13:33:16 claudio Exp $ */
d118 4
a121 1
static void gre_compute_route(struct gre_softc *sc);
d157 4
d249 1
a249 1
#if NBPFILTER >0
d458 1
d573 28
d672 1
a672 1
static void
d751 116
@


1.47
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.46 2009/11/21 14:08:14 claudio Exp $ */
d378 8
@


1.46
log
@Add a way to bind the tunnel endpoint of a gif/gre interface into a
different rdomain than the default one. This allows to do MPLS VPNs
without the MPLS madness.  OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.45 2009/06/02 17:10:23 henning Exp $ */
d656 2
a657 1
	ro->ro_rt = rtalloc1(&ro->ro_dst, 1, sc->g_rtableid);
@


1.45
log
@do the pf_pkt_addr_changed(m) magic just like gif etc
tested by Manuel Rodriguez Morales <marodriguez at grupogdt.com>
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.44 2008/06/26 05:42:20 ray Exp $ */
d210 9
d422 3
d529 1
a529 1
	recompute:
d594 14
d656 2
a657 2
	rtalloc(ro);
	if (ro->ro_rt == 0)
d667 1
a667 1
		ro->ro_rt = (struct rtentry *) 0;
@


1.44
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.43 2007/12/20 02:53:02 brad Exp $ */
d45 1
d81 4
d412 4
@


1.43
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.42 2007/09/15 16:43:51 henning Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.42
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.41 2006/05/28 04:30:16 claudio Exp $ */
d581 1
a581 1
		error = EINVAL;
@


1.41
log
@Fix multicast and broadcast over gre(4) tunnels. Clear the M_MCAST and M_BCAST
mbuf flags so that the packet is sent out with a normal link local address
instead of a multicast or broadcast address. OK brad@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.40 2006/03/25 22:41:47 djm Exp $ */
d135 1
a135 1
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
a137 1
	bzero(sc, sizeof(*sc));
@


1.40
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.39 2006/03/04 22:40:15 brad Exp $ */
d233 2
@


1.39
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.38 2006/01/04 06:04:42 canacar Exp $ */
d236 1
a236 1
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m);
@


1.38
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.37 2005/12/10 18:40:29 krw Exp $ */
d435 1
a435 1
	s = splimp();
@


1.37
log
@m_pullup() the whole header, not the number of bytes in an int. Found
by lint.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.36 2005/08/14 09:55:56 markus Exp $ */
a181 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif  
@


1.36
log
@don't require a valid route when configuring the tunnel;
from Stephen Marley; ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.35 2005/07/31 03:52:18 pascoe Exp $ */
d268 1
a268 2
					m = m_pullup(m,
					    sizeof(inp->ip_hl << 2));
@


1.35
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.34 2005/06/08 06:35:04 henning Exp $ */
a525 1

a526 7
			if (sc->route.ro_rt == 0)
			{
				sc->g_src.s_addr = INADDR_ANY;
				sc->g_dst.s_addr = INADDR_ANY;
				splx(s);
				return EIO; /* Is this is good ? */
			}
@


1.34
log
@no more netns handling for the various tunnel devices and loopback
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.33 2005/05/14 19:24:23 brad Exp $ */
d238 2
a239 18
	if (ifp->if_bpf) {
		/*
		 * We need to prepend the address family as a four
		 * byte field.  Cons up a fake header to pacify bpf.
		 * This is safe because bpf will only read from the
		 * mbuf (i.e., it won't try to free it or keep a
		 * pointer a to it).
		 */
		struct mbuf m0;
		u_int32_t af = dst->sa_family;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *) &af;

		bpf_mtap(ifp->if_bpf, &m0);
	}
@


1.33
log
@- Add IPv6 over GRE.
- u_short -> u_int16_t
- Change default MTU to 1476 (same value that Cisco and other *BSD's use).
- Mark gre(4) interfaces as IFT_TUNNEL (Encapsulation interface).

From NetBSD

- Support setting the MTU

Be very careful when upgrading, the change in default MTU might cause
problems with an existing OpenBSD <-> OpenBSD setup.

Thanks to Stephen Marley <stephen dot marley at catwoman dot cl-is dot com>
for some testing.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.32 2004/08/18 18:37:53 canacar Exp $ */
a76 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a384 5
			break;
#endif
#ifdef NS
		case AF_NS:
			etype = ETHERTYPE_NS;
@


1.32
log
@fix bad packets passed to bpf from the gre(4) interface.
reported by Robert Stone ( robert at arbor net ) via PR 3852
This is a different fix since gre(4) may carry non-ip packets.
tested by Robert Stone and markus@@ ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.31 2003/12/16 20:33:25 markus Exp $ */
d11 2
d98 6
a103 5
#define GREMTU 1450	/* XXX this is below the standard MTU of
                         1500 Bytes, allowing for headers,
                         but we should possibly do path mtu discovery
                         before changing if state to up to find the
                         correct value */
d147 1
a147 1
	sc->sc_if.if_type = IFT_OTHER;
d209 2
a210 1
	u_short etype = 0;
d321 1
a321 1
			mob_h.hcrc = gre_in_cksum((u_short *) &mob_h, msiz);
d384 1
d397 5
d437 1
a437 1
		((struct ip *) gh)->ip_tos = inp->ip_tos;
d478 10
d499 4
d692 2
a693 2
u_short
gre_in_cksum(u_short *p, u_int len)
d695 1
a695 1
	u_int sum = 0;
@


1.31
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.30 2003/12/08 10:23:39 markus Exp $ */
d164 1
a164 1
	bpfattach(&sc->sc_if.if_bpf, &sc->sc_if, DLT_RAW,
d239 18
a256 2
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
@


1.30
log
@ip_output expects network byte order; report Bob Kitella; ok deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.29 2003/12/03 14:52:23 markus Exp $ */
d103 1
a103 1
void    gre_clone_destroy(struct ifnet *);
d174 1
a174 1
void   
d190 1
@


1.29
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.28 2003/08/15 20:32:19 tedu Exp $ */
d411 1
a411 1
		gh->gi_len = m->m_pkthdr.len;
@


1.28
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.27 2003/07/09 22:03:15 itojun Exp $ */
d102 2
a103 1
struct gre_softc *gre = 0;
d105 3
a107 1
int ngre = 0;
d125 8
a132 2
greattach(n)
	int n;
d135 1
a135 1
	int i;
d137 22
a158 22
	ngre = n;
	gre = sc = malloc(ngre * sizeof(struct gre_softc), M_DEVBUF, M_WAIT);
	bzero(sc, ngre * sizeof(struct gre_softc));
	for (i = 0; i < ngre ; sc++) {
		snprintf(sc->sc_if.if_xname, sizeof(sc->sc_if.if_xname),
			 "gre%d", i++);
		sc->sc_if.if_softc = sc;
		sc->sc_if.if_type = IFT_OTHER;
		sc->sc_if.if_addrlen = 0;
		sc->sc_if.if_hdrlen = 24; /* IP + GRE */
		sc->sc_if.if_mtu = GREMTU;
		sc->sc_if.if_flags = IFF_POINTOPOINT|IFF_MULTICAST;
		sc->sc_if.if_output = gre_output;
		sc->sc_if.if_ioctl = gre_ioctl;
		sc->sc_if.if_collisions = 0;
		sc->sc_if.if_ierrors = 0;
		sc->sc_if.if_oerrors = 0;
		sc->sc_if.if_ipackets = 0;
		sc->sc_if.if_opackets = 0;
		sc->g_dst.s_addr = sc->g_src.s_addr = INADDR_ANY;
		sc->g_proto = IPPROTO_GRE;
		sc->sc_if.if_flags |= IFF_LINK0;
d160 2
a161 2
		if_attach(&sc->sc_if);
		if_alloc_sadl(&sc->sc_if);
d164 2
a165 2
		bpfattach(&sc->sc_if.if_bpf, &sc->sc_if, DLT_RAW,
		    sizeof(u_int32_t));
d167 23
a189 1
	}
@


1.28.2.1
log
@MFC:
Fix by markus@@

ip_output expects network byte order; report Bob Kitella

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.28 2003/08/15 20:32:19 tedu Exp $ */
d380 1
a380 1
		gh->gi_len = htons(m->m_pkthdr.len);
@


1.27
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.26 2003/03/25 18:10:06 millert Exp $ */
d438 1
a438 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d460 1
a460 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d509 1
a509 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
d526 1
a526 1
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
@


1.26
log
@Missing splx(); Patrick Latifi
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.25 2003/01/04 22:36:12 deraadt Exp $ */
d305 1
a305 2
			NTOHS(inp->ip_len);
			inp->ip_len += msiz;
@


1.26.2.1
log
@Pull patch from -current:
Fix by markus@@

ip_output expects network byte order; report Bob Kitella

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.30 2003/12/08 10:23:39 markus Exp $ */
d381 1
a381 1
		gh->gi_len = htons(m->m_pkthdr.len);
@


1.26.2.2
log
@Revert. This doesn't apply to 3.3.
Thanks to markus@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.26 2003/03/25 18:10:06 millert Exp $ */
d381 1
a381 1
		gh->gi_len = m->m_pkthdr.len;
@


1.25
log
@spelling
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.24 2002/08/28 15:43:02 pefo Exp $ */
d451 2
a452 1
			return EPROTONOSUPPORT;
@


1.24
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.23 2002/06/30 13:04:36 itojun Exp $ */
d558 1
a558 1
 * gets src=a, dst=b tacked on and would from ip_ouput() sent back to
@


1.23
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.22 2002/06/10 23:06:55 itojun Exp $ */
d388 1
a388 1
	error = ip_output(m, NULL, &sc->route, 0, NULL, NULL);
@


1.22
log
@- stop abusing IFF_UP.
- do not use L3 address pair for L2.5 address pair.  configure L2.5 address
  pair by using "ifconfig tunnel".
- IFF_LINK2 is not needed, as it is just a reverse of IFF_LINK0.
- do not modify IFF_LINK1 when you modify protocol type.

chris ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.21 2002/06/09 18:00:08 itojun Exp $ */
d152 1
@


1.21
log
@if_addrlen need not be 4, set to 0.  From: Martin Husemann <martin@@duskware.de>
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.20 2002/06/09 17:32:35 itojun Exp $ */
a101 2
#define LINK_MASK (IFF_LINK0|IFF_LINK1|IFF_LINK2)

d149 1
d177 7
d190 2
a191 1
			return (EIO);	/* Use the same as in if_gif.c */
d199 2
a200 1
		return (ENOBUFS);
d214 2
a215 1
			return (EACCES);
d230 2
a231 1
					return (ENOBUFS);
d240 2
a241 1
						return (ENOBUFS);
d277 2
a278 1
					return (ENOBUFS);
d309 2
a310 1
			return (EINVAL);
d316 2
a317 1
			return (EACCES);
d326 2
a327 1
					return (ENOBUFS);
d347 2
a348 1
			return (EAFNOSUPPORT);
a352 1
		error = EINVAL;
d355 2
a356 1
		return (error);
d361 2
a362 1
		return (ENOBUFS);
d388 1
a397 1
	struct ifaddr *ifa = (struct ifaddr *) data;
a398 1
	struct in_ifaddr *ia = (struct in_ifaddr *) data;
d410 2
a412 28
		/*
		 * set tunnel endpoints in case that we "only"
		 * have ip over ip encapsulation. This allows to
		 * set tunnel endpoints with ifconfig.
		 */
		if (ifa->ifa_addr->sa_family == AF_INET) {
			sa = ifa->ifa_addr;
			sc->g_src = (satosin(sa))->sin_addr;
			sc->g_dst = ia->ia_dstaddr.sin_addr;
			if ((sc->g_src.s_addr != INADDR_ANY) &&
			    (sc->g_dst.s_addr != INADDR_ANY)) {
				if (sc->route.ro_rt != 0) {
					/* free old route */
					RTFREE(sc->route.ro_rt);
					sc->route.ro_rt = (struct rtentry *) 0;
				}

				gre_compute_route(sc);
				if (sc->route.ro_rt == 0) {
					sc->g_src.s_addr = INADDR_ANY;
					sc->g_dst.s_addr = INADDR_ANY;
					splx(s);
					return EIO; /* Is this is good ? */
				}

				ifp->if_flags |= IFF_UP;
			}
		}
d415 4
a418 16
		if ((sc->g_dst.s_addr == INADDR_ANY) ||
		    (sc->g_src.s_addr == INADDR_ANY))
			ifp->if_flags &= ~IFF_UP;

		switch(ifr->ifr_flags & LINK_MASK) {
			case IFF_LINK0:
				sc->g_proto = IPPROTO_GRE;
				ifp->if_flags |= IFF_LINK0;
				ifp->if_flags &= ~(IFF_LINK1|IFF_LINK2);
				break;
			case IFF_LINK2:
				sc->g_proto = IPPROTO_MOBILE;
				ifp->if_flags |= IFF_LINK2;
				ifp->if_flags &= ~(IFF_LINK0|IFF_LINK1);
				break;
		}
d443 1
a443 1
		case IPPROTO_GRE :
a444 1
			ifp->if_flags &= ~(IFF_LINK1|IFF_LINK2);
d446 2
a447 3
		case IPPROTO_MOBILE :
			ifp->if_flags |= IFF_LINK2;
			ifp->if_flags &= ~(IFF_LINK1|IFF_LINK2);
d450 1
a450 1
			ifp->if_flags &= ~(IFF_LINK0|IFF_LINK1|IFF_LINK2);
@


1.20
log
@make sure to bzero sockaddr_in
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.19 2002/06/09 17:25:58 itojun Exp $ */
d138 1
a138 1
		sc->sc_if.if_addrlen = 4;
@


1.19
log
@support SIO*PHYADDR, so that we can configure outer address with ifconfig(8)
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.18 2002/04/03 20:35:58 angelos Exp $ */
d516 3
d524 3
d560 1
d564 1
a564 4
		sa = sintosa(&si);
		memcpy(&lifr->addr, sa, sa->sa_len);
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
d566 1
a566 2
		sa = sintosa(&si);
		memcpy(&lifr->dstaddr, sa, sa->sa_len);
@


1.18
log
@WCCP sysctl variable -- ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.17 2001/06/27 03:49:53 angelos Exp $ */
d137 1
a137 1
		sc->sc_if.if_type =  IFT_OTHER;
d156 1
a156 1
			  sizeof(u_int32_t) );
d383 1
d495 1
d524 40
@


1.17
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.16 2001/06/25 06:31:44 angelos Exp $ */
d111 5
a115 1
 * respectively. Zero means drop them, all else is acceptance.
d118 1
@


1.17.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.17 2001/06/27 03:49:53 angelos Exp $ */
d111 1
a111 5
 * respectively. Zero means drop them, all else is acceptance.  We can also
 * control acceptance of WCCPv1-style GRE packets through the
 * net.inet.gre.wccp value, but be aware it depends upon normal GRE being
 * allowed as well.
 * 
a113 1
int gre_wccp = 0;
@


1.17.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.17.4.1 2002/06/11 03:30:45 art Exp $ */
d102 2
d137 2
a138 2
		sc->sc_if.if_type = IFT_OTHER;
		sc->sc_if.if_addrlen = 0;
a150 1
		sc->sc_if.if_flags |= IFF_LINK0;
a152 1
		if_alloc_sadl(&sc->sc_if);
d156 1
a156 1
		    sizeof(u_int32_t));
a177 7
	if ((ifp->if_flags & IFF_UP) == 0 ||
	    sc->g_src.s_addr == INADDR_ANY || sc->g_dst.s_addr == INADDR_ANY) {
		m_freem(m);
		error = ENETDOWN;
		goto end;
	}

d184 1
a184 2
			error = EIO;
			goto end;
d192 1
a192 2
		error = ENOBUFS;
		goto end;
d206 1
a206 2
			error = EACCES;
			goto end;
d221 1
a221 2
					error = ENOBUFS;
					goto end;
d230 1
a230 2
						error = ENOBUFS;
						goto end;
d266 1
a266 2
					error = ENOBUFS;
					goto end;
d297 1
a297 2
			error = EINVAL;
			goto end;
d303 1
a303 2
			error = EACCES;
			goto end;
d312 1
a312 2
					error = ENOBUFS;
					goto end;
d332 1
a332 2
			error = EAFNOSUPPORT;
			goto end;
d337 1
d340 1
a340 2
		error = EINVAL;
		goto end;
d345 1
a345 2
		error = ENOBUFS;
		goto end;
d370 1
a370 2
	error = ip_output(m, (void *)NULL, &sc->route, 0, (void *)NULL, (void *)NULL);
  end:
d380 1
d382 1
a382 1
	struct if_laddrreq *lifr = (struct if_laddrreq *)data;
a392 2
		ifp->if_flags |= IFF_UP;
		break;
d394 28
d424 16
a439 4
		if ((ifr->ifr_flags & IFF_LINK0) != 0)
			sc->g_proto = IPPROTO_GRE;
		else
			sc->g_proto = IPPROTO_MOBILE;
d464 1
a464 1
		case IPPROTO_GRE:
d466 1
d468 3
a470 2
		case IPPROTO_MOBILE:
			ifp->if_flags &= ~IFF_LINK0;
d473 1
a473 1
			return EPROTONOSUPPORT;
a493 1
	recompute:
a513 3
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
a518 3
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
a521 37
		break;
	case SIOCSLIFPHYADDR:
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
		if (lifr->addr.ss_family != AF_INET ||
		    lifr->dstaddr.ss_family != AF_INET) {
			error = EAFNOSUPPORT;
			break;
		}
		if (lifr->addr.ss_len != sizeof(si) ||
		    lifr->dstaddr.ss_len != sizeof(si)) {
			error = EINVAL;
			break;
		}
		sc->g_src = (satosin((struct sockadrr *)&lifr->addr))->sin_addr;
		sc->g_dst =
		    (satosin((struct sockadrr *)&lifr->dstaddr))->sin_addr;
		goto recompute;
	case SIOCDIFPHYADDR:
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
		sc->g_src.s_addr = INADDR_ANY;
		sc->g_dst.s_addr = INADDR_ANY;
		break;
	case SIOCGLIFPHYADDR:
		if (sc->g_src.s_addr == INADDR_ANY ||
		    sc->g_dst.s_addr == INADDR_ANY) {
			error = EADDRNOTAVAIL;
			break;
		}
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
		si.sin_addr.s_addr = sc->g_src.s_addr;
		memcpy(&lifr->addr, &si, sizeof(si));
		si.sin_addr.s_addr = sc->g_dst.s_addr;
		memcpy(&lifr->dstaddr, &si, sizeof(si));
@


1.17.4.3
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d451 1
a451 2
			error = EPROTONOSUPPORT;
			break;
d558 1
a558 1
 * gets src=a, dst=b tacked on and would from ip_output() sent back to
@


1.16
log
@IF_DROP()
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.15 2001/06/25 06:30:22 angelos Exp $ */
d263 1
a263 1
				M_COPY_HDR(m0, m);
@


1.15
log
@Use tags to detect loops. In the future, perhaps we'll use them to
actually also send the packet out the right interface.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.14 2001/06/25 01:50:16 fgsch Exp $ */
d185 1
@


1.14
log
@Move common post M_COPY_HDR manipulation to the macro itself; angelos@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.13 2001/06/22 14:28:58 deraadt Exp $ */
d171 1
a171 1
	static int recursions = 0;	/* XXX MUTEX */
d173 12
a184 3
	/* Try to limit infinite recursion through misconfiguration */
	if (++recursions >= GRE_RECURSION_LIMIT) {
		IF_DROP(&ifp->if_snd);
d186 1
a186 2
		recursions = 0;
		return (EIO);	/* Use the same as in if_gif.c */
d188 2
a199 1
			recursions = 0;
a214 1
					recursions = 0;
a223 1
						recursions = 0;
a259 1
					recursions = 0;
a290 1
			recursions = 0;
a296 1
			recursions = 0;
a305 1
					recursions = 0;
a325 1
			recursions = 0;
a333 1
		recursions = 0;
a338 1
		recursions = 0;
a366 1
	recursions = 0;
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.12 2001/06/05 23:43:45 maja Exp $ */
a256 2
				m_tag_init(m);
				m->m_flags &= ~M_PKTHDR;
@


1.12
log
@Allow boot -c to change number of gre devices. -moj ok angelos@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.11 2001/05/27 11:54:32 angelos Exp $ */
d97 1
a97 1
                         1500 Bytes, allowing for headers, 
d99 1
a99 1
                         before changing if state to up to find the 
d135 1
a135 1
		sc->sc_if.if_mtu = GREMTU; 
d156 1
a156 1
/* 
d187 2
a188 2
	        if (ip_mobile_allow == 0) {
		        IF_DROP(&ifp->if_snd);
d202 3
a204 4
			if (m->m_len < sizeof(struct ip))
			{
			        m = m_pullup(m, sizeof(struct ip));
			        if (m == NULL) {
d208 2
a209 3
				}
				else
				        inp = mtod(m, struct ip *);
d212 2
a213 2
				        m = m_pullup(m,
						     sizeof(inp->ip_hl << 2));
d215 1
a215 1
					        IF_DROP(&ifp->if_snd);
d267 1
a267 1
				       sizeof(struct ip));
d275 2
a276 2
				bcopy(inp, mtod(m, caddr_t), 
				      inp->ip_hl << 2);
d291 2
a292 2
	        if (gre_allow == 0) {
		        IF_DROP(&ifp->if_snd);
d300 2
a301 2
		        if (m->m_len < sizeof(struct ip)) {
			        m = m_pullup(m, sizeof(struct ip));
d303 1
a303 1
				        IF_DROP(&ifp->if_snd);
d337 1
a337 1
			
d356 1
a356 1
		((struct ip *) gh)->ip_hl = (sizeof(struct ip)) >> 2; 
d385 1
a385 1
	struct proc *prc = curproc;             /* XXX */
d389 7
a395 7
	case SIOCSIFADDR:		
	case SIOCSIFDSTADDR: 	
		/* 
                 * set tunnel endpoints in case that we "only"
                 * have ip over ip encapsulation. This allows to
                 * set tunnel endpoints with ifconfig.
                 */
d403 1
a403 1
                                        /* free old route */
d421 1
a421 1
		if ((sc->g_dst.s_addr == INADDR_ANY) || 
d455 3
a457 3
	        /* Check for superuser */
	        if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
		        break;
d478 3
a480 3
	        /* Check for superuser */
	        if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
		        break;
d483 3
a485 3
	         * set tunnel endpoints, compute a less specific route
	         * to the remote end and mark if as up
                 */
d494 1
a494 1
			        /* free old route */
d528 1
a528 1
/* 
d533 1
a533 1
 * gets src=a, dst=b tacked on and would from ip_ouput() sent back to 
d547 1
a547 1
	
d555 1
a555 1
         * specific route. I'd rather like to specify a shorter mask,
d558 1
a558 1
         */
d578 2
a579 2
                RTFREE(ro->ro_rt);
                ro->ro_rt = (struct rtentry *) 0;
d584 3
a586 3
	 * now change it back - else ip_output will just drop 
         * the route and search one to this interface ...
         */
d592 2
a593 2
 * do a checksum of a buffer - much like in_cksum, which operates on  
 * mbufs. 
a594 1

d598 1
a598 1
	u_int sum = 0; 
d600 1
a600 1
  
d603 1
a603 1
  
d607 1
a607 1
				u_char c[2]; 
d612 2
a613 2
		} 
 
@


1.11
log
@Fixup old mbuf chain head.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.10 2001/05/11 17:20:10 aaron Exp $ */
d104 3
a106 1
struct gre_softc gre_softc[NGRE];
d119 2
a120 1
greattach(void)
d125 4
a128 1
	for (i = 0, sc = gre_softc ; i < NGRE ; sc++ ) {
@


1.10
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.9 2001/03/25 07:10:47 csapuntz Exp $ */
d252 3
@


1.9
log
@Missing splx(s). Thanks to dawson and team
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.8 2001/03/07 05:43:49 aaron Exp $ */
d199 1
a199 1
			        if (m == 0) {
d210 1
a210 1
					if (m == 0) {
d295 1
a295 1
				if (m == 0) {
@


1.8
log
@Missing splx() in failure case; deraadt@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.7 2001/01/17 19:50:14 angelos Exp $ */
d497 1
@


1.7
log
@Don't copy the inner header's TTL on the outer header.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.6 2000/01/16 00:34:39 angelos Exp $ */
d405 1
@


1.6
log
@ETHERTYPE_ATALK -> ETHERTYPE_AT
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.5 2000/01/11 08:26:45 angelos Exp $ */
a162 1
	u_char ttl = 255;
a302 1
			ttl = inp->ip_ttl;
d350 1
a350 1
		((struct ip *) gh)->ip_ttl = ttl;
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.9 2001/03/25 07:10:47 csapuntz Exp $ */
d163 1
d304 1
d352 1
a352 1
		((struct ip *) gh)->ip_ttl = ip_defttl;
a406 1
					splx(s);
a497 1
				splx(s);
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.6.2.1 2001/05/14 22:40:00 niklas Exp $ */
d97 1
a97 1
                         1500 Bytes, allowing for headers,
d99 1
a99 1
                         before changing if state to up to find the
d104 1
a104 3
struct gre_softc *gre = 0;

int ngre = 0;
d117 1
a117 2
greattach(n)
	int n;
d122 1
a122 4
	ngre = n;
	gre = sc = malloc(ngre * sizeof(struct gre_softc), M_DEVBUF, M_WAIT);
	bzero(sc, ngre * sizeof(struct gre_softc));
	for (i = 0; i < ngre ; sc++) {
d129 1
a129 1
		sc->sc_if.if_mtu = GREMTU;
d150 1
a150 1
/*
d165 1
a165 11
	struct m_tag *mtag;

	/* Try to limit infinite recursion through misconfiguration. */
	for (mtag = m_tag_find(m, PACKET_TAG_GRE, NULL); mtag;
	     mtag = m_tag_find(m, PACKET_TAG_GRE, mtag)) {
		if (!bcmp((caddr_t)(mtag + 1), &ifp, sizeof(struct ifnet *))) {
			IF_DROP(&ifp->if_snd);
			m_freem(m);
			return (EIO);	/* Use the same as in if_gif.c */
		}
	}
d167 2
a168 2
	mtag = m_tag_get(PACKET_TAG_GRE, sizeof(struct ifnet *), M_NOWAIT);
	if (mtag == NULL) {
d171 2
a172 1
		return (ENOBUFS);
a173 2
	bcopy(&ifp, (caddr_t)(mtag + 1), sizeof(struct ifnet *));
	m_tag_prepend(m, mtag);
d181 2
a182 2
		if (ip_mobile_allow == 0) {
			IF_DROP(&ifp->if_snd);
d184 1
d196 4
a199 3
			if (m->m_len < sizeof(struct ip)) {
				m = m_pullup(m, sizeof(struct ip));
				if (m == NULL) {
d201 1
d203 3
a205 2
				} else
					inp = mtod(m, struct ip *);
d208 5
a212 4
					m = m_pullup(m,
					    sizeof(inp->ip_hl << 2));
					if (m == NULL) {
						IF_DROP(&ifp->if_snd);
d249 1
a251 1
				M_MOVE_HDR(m0, m);
d260 1
a260 1
				    sizeof(struct ip));
d268 2
a269 2
				bcopy(inp, mtod(m, caddr_t),
				    inp->ip_hl << 2);
d280 1
d284 2
a285 2
		if (gre_allow == 0) {
			IF_DROP(&ifp->if_snd);
d287 1
d293 5
a297 4
			if (m->m_len < sizeof(struct ip)) {
				m = m_pullup(m, sizeof(struct ip));
				if (m == NULL) {
					IF_DROP(&ifp->if_snd);
d318 1
d327 1
d330 1
a330 1

d333 1
d349 1
a349 1
		((struct ip *) gh)->ip_hl = (sizeof(struct ip)) >> 2;
d362 1
d378 1
a378 1
	struct proc *prc = curproc;		/* XXX */
d382 7
a388 7
	case SIOCSIFADDR:
	case SIOCSIFDSTADDR:
		/*
		 * set tunnel endpoints in case that we "only"
		 * have ip over ip encapsulation. This allows to
		 * set tunnel endpoints with ifconfig.
		 */
d396 1
a396 1
					/* free old route */
d414 1
a414 1
		if ((sc->g_dst.s_addr == INADDR_ANY) ||
d448 3
a450 3
		/* Check for superuser */
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
d471 3
a473 3
		/* Check for superuser */
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
d476 3
a478 3
		 * set tunnel endpoints, compute a less specific route
		 * to the remote end and mark if as up
		 */
d487 1
a487 1
				/* free old route */
d521 1
a521 1
/*
d526 1
a526 1
 * gets src=a, dst=b tacked on and would from ip_ouput() sent back to
d540 1
a540 1

d548 1
a548 1
	 * specific route. I'd rather like to specify a shorter mask,
d551 1
a551 1
	 */
d571 2
a572 2
		RTFREE(ro->ro_rt);
		ro->ro_rt = (struct rtentry *) 0;
d577 3
a579 3
	 * now change it back - else ip_output will just drop
	 * the route and search one to this interface ...
	 */
d585 2
a586 2
 * do a checksum of a buffer - much like in_cksum, which operates on
 * mbufs.
d588 1
d592 1
a592 1
	u_int sum = 0;
d594 1
a594 1

d597 1
a597 1

d601 1
a601 1
				u_char c[2];
d606 2
a607 2
		}

@


1.6.2.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d102 2
d111 1
a111 5
 * respectively. Zero means drop them, all else is acceptance.  We can also
 * control acceptance of WCCPv1-style GRE packets through the
 * net.inet.gre.wccp value, but be aware it depends upon normal GRE being
 * allowed as well.
 * 
a113 1
int gre_wccp = 0;
d132 2
a133 2
		sc->sc_if.if_type = IFT_OTHER;
		sc->sc_if.if_addrlen = 0;
a145 1
		sc->sc_if.if_flags |= IFF_LINK0;
a147 1
		if_alloc_sadl(&sc->sc_if);
d151 1
a151 1
		    sizeof(u_int32_t));
a172 7
	if ((ifp->if_flags & IFF_UP) == 0 ||
	    sc->g_src.s_addr == INADDR_ANY || sc->g_dst.s_addr == INADDR_ANY) {
		m_freem(m);
		error = ENETDOWN;
		goto end;
	}

d179 1
a179 2
			error = EIO;
			goto end;
d187 1
a187 2
		error = ENOBUFS;
		goto end;
d201 1
a201 2
			error = EACCES;
			goto end;
d216 1
a216 2
					error = ENOBUFS;
					goto end;
d225 1
a225 2
						error = ENOBUFS;
						goto end;
d261 1
a261 2
					error = ENOBUFS;
					goto end;
d292 1
a292 2
			error = EINVAL;
			goto end;
d298 1
a298 2
			error = EACCES;
			goto end;
d307 1
a307 2
					error = ENOBUFS;
					goto end;
d327 1
a327 2
			error = EAFNOSUPPORT;
			goto end;
d332 1
d335 1
a335 2
		error = EINVAL;
		goto end;
d340 1
a340 2
		error = ENOBUFS;
		goto end;
d365 1
a365 2
	error = ip_output(m, (void *)NULL, &sc->route, 0, (void *)NULL, (void *)NULL);
  end:
d375 1
d377 1
a377 1
	struct if_laddrreq *lifr = (struct if_laddrreq *)data;
a387 2
		ifp->if_flags |= IFF_UP;
		break;
d389 28
d419 16
a434 4
		if ((ifr->ifr_flags & IFF_LINK0) != 0)
			sc->g_proto = IPPROTO_GRE;
		else
			sc->g_proto = IPPROTO_MOBILE;
d459 1
a459 1
		case IPPROTO_GRE:
d461 1
d463 3
a465 2
		case IPPROTO_MOBILE:
			ifp->if_flags &= ~IFF_LINK0;
d468 1
a468 2
			error = EPROTONOSUPPORT;
			break;
a488 1
	recompute:
a508 3
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
a513 3
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
a517 37
	case SIOCSLIFPHYADDR:
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
		if (lifr->addr.ss_family != AF_INET ||
		    lifr->dstaddr.ss_family != AF_INET) {
			error = EAFNOSUPPORT;
			break;
		}
		if (lifr->addr.ss_len != sizeof(si) ||
		    lifr->dstaddr.ss_len != sizeof(si)) {
			error = EINVAL;
			break;
		}
		sc->g_src = (satosin((struct sockadrr *)&lifr->addr))->sin_addr;
		sc->g_dst =
		    (satosin((struct sockadrr *)&lifr->dstaddr))->sin_addr;
		goto recompute;
	case SIOCDIFPHYADDR:
		if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
			break;
		sc->g_src.s_addr = INADDR_ANY;
		sc->g_dst.s_addr = INADDR_ANY;
		break;
	case SIOCGLIFPHYADDR:
		if (sc->g_src.s_addr == INADDR_ANY ||
		    sc->g_dst.s_addr == INADDR_ANY) {
			error = EADDRNOTAVAIL;
			break;
		}
		bzero(&si, sizeof(si));
		si.sin_family = AF_INET;
		si.sin_len = sizeof(struct sockaddr_in);
		si.sin_addr.s_addr = sc->g_src.s_addr;
		memcpy(&lifr->addr, &si, sizeof(si));
		si.sin_addr.s_addr = sc->g_dst.s_addr;
		memcpy(&lifr->dstaddr, &si, sizeof(si));
		break;
d531 1
a531 1
 * gets src=a, dst=b tacked on and would from ip_output() sent back to
@


1.6.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d102 1
a102 2
int	gre_clone_create(struct if_clone *, int);
int	gre_clone_destroy(struct ifnet *);
d104 1
a104 3
struct gre_softc_head gre_softc_list;
struct if_clone gre_cloner =
    IF_CLONE_INITIALIZER("gre", gre_clone_create, gre_clone_destroy);
d122 2
a123 8
greattach(int n)
{
	LIST_INIT(&gre_softc_list);
	if_clone_attach(&gre_cloner);
}

int
gre_clone_create(struct if_clone *ifc, int unit)
d126 1
a126 1
	int s;
d128 22
a149 22
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
	if (!sc)
		return (ENOMEM);
	bzero(sc, sizeof(*sc));
	snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "%s%d",
	    ifc->ifc_name, unit);
	sc->sc_if.if_softc = sc;
	sc->sc_if.if_type = IFT_OTHER;
	sc->sc_if.if_addrlen = 0;
	sc->sc_if.if_hdrlen = 24; /* IP + GRE */
	sc->sc_if.if_mtu = GREMTU;
	sc->sc_if.if_flags = IFF_POINTOPOINT|IFF_MULTICAST;
	sc->sc_if.if_output = gre_output;
	sc->sc_if.if_ioctl = gre_ioctl;
	sc->sc_if.if_collisions = 0;
	sc->sc_if.if_ierrors = 0;
	sc->sc_if.if_oerrors = 0;
	sc->sc_if.if_ipackets = 0;
	sc->sc_if.if_opackets = 0;
	sc->g_dst.s_addr = sc->g_src.s_addr = INADDR_ANY;
	sc->g_proto = IPPROTO_GRE;
	sc->sc_if.if_flags |= IFF_LINK0;
d151 2
a152 2
	if_attach(&sc->sc_if);
	if_alloc_sadl(&sc->sc_if);
d155 2
a156 2
	bpfattach(&sc->sc_if.if_bpf, &sc->sc_if, DLT_RAW,
	    sizeof(u_int32_t));
d158 1
a158 24
	s = splnet();
	LIST_INSERT_HEAD(&gre_softc_list, sc, sc_list);
	splx(s);

	return (0);
}

int
gre_clone_destroy(struct ifnet *ifp)
{
	struct gre_softc *sc = ifp->if_softc;
	int s;

	s = splnet();
	LIST_REMOVE(sc, sc_list);
	splx(s);

#if NBPFILTER > 0
	bpfdetach(ifp);
#endif  
	if_detach(ifp);

	free(sc, M_DEVBUF);
	return (0);
d305 2
a306 1
			inp->ip_len = htons(ntohs(inp->ip_len) + msiz);
d381 1
a381 1
		gh->gi_len = htons(m->m_pkthdr.len);
d439 1
a439 1
		if ((error = suser(prc, 0)) != 0)
d461 1
a461 1
		if ((error = suser(prc, 0)) != 0)
d510 1
a510 1
		if ((error = suser(prc, 0)) != 0)
d527 1
a527 1
		if ((error = suser(prc, 0)) != 0)
@


1.5
log
@Add a recursion depth limit, similar to if_gif.c; also, when
computing the route for the GRE tunnel, verify that it does not point
back to ourselves.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.4 2000/01/08 01:39:24 angelos Exp $ */
d309 1
a309 1
			etype = ETHERTYPE_ATALK;
@


1.4
log
@We don't need a pseudo-header for tcpdump on the output routine.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.3 2000/01/07 23:25:21 angelos Exp $ */
d92 4
d109 1
a109 1
 * respectively.  Zero means drop them, all else is acceptance.
d166 9
d185 1
d202 1
d213 1
d250 1
d281 1
d288 1
d298 1
d320 1
d329 1
d335 1
d364 1
d404 6
d494 6
d564 11
@


1.3
log
@Fix tcpdump -n -i greN (causes a panic in NetBSD)
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.2 2000/01/07 21:55:05 angelos Exp $ */
d148 1
a148 1
 * given by sc->g_proto. See also RFC 1701 and RFC 2004
d164 2
a165 17
	if (ifp->if_bpf) {
                /*
                 * We need to prepend the address family as
                 * a four byte field.  Cons up a fake header
                 * to pacify bpf.  This is safe because bpf
                 * will only read from the mbuf (i.e., it won't
                 * try to free it or keep a pointer a to it).
                 */
		struct mbuf m0;
		u_int af = dst->sa_family;

		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *) &af;
		
		bpf_mtap(ifp->if_bpf, &m0);
	}
d373 2
a374 1
				if (sc->route.ro_rt != 0) /* free old route */
d376 3
d457 2
a458 1
			if (sc->route.ro_rt != 0) /* free old route */
d460 3
d522 1
a522 2
		((struct sockaddr_in *) &ro->ro_dst)->sin_addr.s_addr
			= htonl(a);
d526 2
@


1.2
log
@Make some of the GRE-specific ioctls privileged. Remove a lot of
unnecessary include files.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_gre.c,v 1.1 2000/01/07 21:37:30 angelos Exp $ */
d110 1
a110 1
void gre_compute_route(struct gre_softc *sc);
d140 1
a140 1
		bpfattach(&sc->gre_bpf, &sc->sc_if, DLT_RAW,
d164 1
a164 1
	if (sc->gre_bpf) {
d504 1
a504 1
void
@


1.1
log
@gre interface code, from NetBSD (with some changes)
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
a52 1
#include <sys/malloc.h>
a53 3
#include <sys/buf.h>
#include <sys/dkstat.h>
#include <sys/protosw.h>
a54 1
#include <sys/ioctl.h>
a55 2
#include <sys/file.h>
#include <sys/tty.h>
a56 1
#include <sys/conf.h>
a57 3
#include <sys/sysctl.h>

#include <machine/cpu.h>
a86 1
#include <sys/time.h>
d370 2
a371 3
	int error;

	error = 0;
d430 4
d453 4
@

