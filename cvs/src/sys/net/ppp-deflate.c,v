head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.10
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.14
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.12
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.22
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.20
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.18
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.16
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.14
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.5.0.18
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.16
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.14
	OPENBSD_2_8:1.5.0.12
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.8
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	ncpqEGjDtSFuLAgn;

1.11
date	2014.12.02.18.11.56;	author tedu;	state Exp;
branches;
next	1.10;
commitid	R6VIBSqPh5FMhwGK;

1.10
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.9;
commitid	B4dZSbxas1X1IpXI;

1.9
date	2011.07.07.02.57.25;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.13.00.12.07;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.05.08.05.02.07;	author millert;	state Exp;
branches
	1.5.8.1
	1.5.18.1;
next	1.4;

1.4
date	97.09.05.04.27.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.02.24.13.34.04;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.12.19.13.45.17;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.04.21.22.28.41;	author deraadt;	state Exp;
branches;
next	;

1.5.8.1
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	;

1.5.18.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.5.18.2;

1.5.18.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@/*	$OpenBSD: ppp-deflate.c,v 1.11 2014/12/02 18:11:56 tedu Exp $	*/
/*	$NetBSD: ppp-deflate.c,v 1.1 1996/03/15 02:28:09 paulus Exp $	*/

/*
 * ppp_deflate.c - interface the zlib procedures for Deflate compression
 * and decompression (as used by gzip) to the PPP code.
 * This version is for use with mbufs on BSD-derived systems.
 *
 * Copyright (c) 1989-2002 Paul Mackerras. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name(s) of the authors of this software must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Paul Mackerras
 *     <paulus@@samba.org>".
 *
 * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <net/ppp_defs.h>
#include <lib/libz/zlib.h>

#define PACKETPTR	struct mbuf *
#include <net/ppp-comp.h>

#if DO_DEFLATE

/*
 * State for a Deflate (de)compressor.
 */
struct deflate_state {
    int		seqno;
    int		w_size;
    int		unit;
    int		hdrlen;
    int		mru;
    int		debug;
    z_stream	strm;
    struct compstat stats;
};

#define DEFLATE_OVHD	2		/* Deflate overhead/packet */

static void	*zcalloc(void *, u_int items, u_int size);
static void	zcfree(void *, void *ptr);
static void	*z_comp_alloc(u_char *options, int opt_len);
static void	*z_decomp_alloc(u_char *options, int opt_len);
static void	z_comp_free(void *state);
static void	z_decomp_free(void *state);
static int	z_comp_init(void *state, u_char *options, int opt_len,
				 int unit, int hdrlen, int debug);
static int	z_decomp_init(void *state, u_char *options, int opt_len,
				     int unit, int hdrlen, int mru, int debug);
static int	z_compress(void *state, struct mbuf **mret,
				  struct mbuf *mp, int slen, int maxolen);
static void	z_incomp(void *state, struct mbuf *dmsg);
static int	z_decompress(void *state, struct mbuf *cmp,
				    struct mbuf **dmpp);
static void	z_comp_reset(void *state);
static void	z_decomp_reset(void *state);
static void	z_comp_stats(void *state, struct compstat *stats);

/*
 * Procedures exported to if_ppp.c.
 */
struct compressor ppp_deflate = {
    CI_DEFLATE,			/* compress_proto */
    z_comp_alloc,		/* comp_alloc */
    z_comp_free,		/* comp_free */
    z_comp_init,		/* comp_init */
    z_comp_reset,		/* comp_reset */
    z_compress,			/* compress */
    z_comp_stats,		/* comp_stat */
    z_decomp_alloc,		/* decomp_alloc */
    z_decomp_free,		/* decomp_free */
    z_decomp_init,		/* decomp_init */
    z_decomp_reset,		/* decomp_reset */
    z_decompress,		/* decompress */
    z_incomp,			/* incomp */
    z_comp_stats,		/* decomp_stat */
};

struct compressor ppp_deflate_draft = {
    CI_DEFLATE_DRAFT,		/* compress_proto */
    z_comp_alloc,		/* comp_alloc */
    z_comp_free,		/* comp_free */
    z_comp_init,		/* comp_init */
    z_comp_reset,		/* comp_reset */
    z_compress,			/* compress */
    z_comp_stats,		/* comp_stat */
    z_decomp_alloc,		/* decomp_alloc */
    z_decomp_free,		/* decomp_free */
    z_decomp_init,		/* decomp_init */
    z_decomp_reset,		/* decomp_reset */
    z_decompress,		/* decompress */
    z_incomp,			/* incomp */
    z_comp_stats,		/* decomp_stat */
};
/*
 * Space allocation and freeing routines for use by zlib routines.
 */
void *
zcalloc(notused, items, size)
    void *notused;
    u_int items, size;
{
    void *ptr;

    ptr = mallocarray(items, size, M_DEVBUF, M_NOWAIT);
    return ptr;
}

void
zcfree(notused, ptr)
    void *notused;
    void *ptr;
{
    free(ptr, M_DEVBUF, 0);
}

/*
 * Allocate space for a compressor.
 */
static void *
z_comp_alloc(options, opt_len)
    u_char *options;
    int opt_len;
{
    struct deflate_state *state;
    int w_size;

    if (opt_len != CILEN_DEFLATE
	|| (options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT)
	|| options[1] != CILEN_DEFLATE
	|| DEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL
	|| options[3] != DEFLATE_CHK_SEQUENCE)
	return NULL;
    w_size = DEFLATE_SIZE(options[2]);
    if (w_size < DEFLATE_MIN_SIZE || w_size > DEFLATE_MAX_SIZE)
	return NULL;

    state = malloc(sizeof(*state), M_DEVBUF, M_NOWAIT);
    if (state == NULL)
	return NULL;

    state->strm.next_in = NULL;
    state->strm.zalloc = zcalloc;
    state->strm.zfree = zcfree;
    if (deflateInit2(&state->strm, Z_DEFAULT_COMPRESSION, DEFLATE_METHOD_VAL,
		     -w_size, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
	free(state, M_DEVBUF, 0);
	return NULL;
    }

    state->w_size = w_size;
    bzero(&state->stats, sizeof(state->stats));
    return (void *) state;
}

static void
z_comp_free(arg)
    void *arg;
{
    struct deflate_state *state = (struct deflate_state *) arg;

    deflateEnd(&state->strm);
    free(state, M_DEVBUF, 0);
}

static int
z_comp_init(arg, options, opt_len, unit, hdrlen, debug)
    void *arg;
    u_char *options;
    int opt_len, unit, hdrlen, debug;
{
    struct deflate_state *state = (struct deflate_state *) arg;

    if (opt_len < CILEN_DEFLATE
	|| (options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT)
	|| options[1] != CILEN_DEFLATE
	|| DEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL
	|| DEFLATE_SIZE(options[2]) != state->w_size
	|| options[3] != DEFLATE_CHK_SEQUENCE)
	return 0;

    state->seqno = 0;
    state->unit = unit;
    state->hdrlen = hdrlen;
    state->debug = debug;

    deflateReset(&state->strm);

    return 1;
}

static void
z_comp_reset(arg)
    void *arg;
{
    struct deflate_state *state = (struct deflate_state *) arg;

    state->seqno = 0;
    deflateReset(&state->strm);
}

int
z_compress(arg, mret, mp, orig_len, maxolen)
    void *arg;
    struct mbuf **mret;		/* compressed packet (out) */
    struct mbuf *mp;		/* uncompressed packet (in) */
    int orig_len, maxolen;
{
    struct deflate_state *state = (struct deflate_state *) arg;
    u_char *rptr, *wptr;
    int proto, olen, wspace, r, flush;
    struct mbuf *m;

    /*
     * Check that the protocol is in the range we handle.
     */
    rptr = mtod(mp, u_char *);
    proto = PPP_PROTOCOL(rptr);
    if (proto > 0x3fff || proto == 0xfd || proto == 0xfb) {
	*mret = NULL;
	return orig_len;
    }

    /* Allocate one mbuf initially. */
    if (maxolen > orig_len)
	maxolen = orig_len;
    MGET(m, M_DONTWAIT, MT_DATA);
    *mret = m;
    if (m != NULL) {
	m->m_len = 0;
	if (maxolen + state->hdrlen > MLEN)
	    MCLGET(m, M_DONTWAIT);
	wspace = M_TRAILINGSPACE(m);
	if (state->hdrlen + PPP_HDRLEN + 2 < wspace) {
	    m->m_data += state->hdrlen;
	    wspace -= state->hdrlen;
	}
	wptr = mtod(m, u_char *);

	/*
	 * Copy over the PPP header and store the 2-byte sequence number.
	 */
	wptr[0] = PPP_ADDRESS(rptr);
	wptr[1] = PPP_CONTROL(rptr);
	wptr[2] = PPP_COMP >> 8;
	wptr[3] = PPP_COMP;
	wptr += PPP_HDRLEN;
	wptr[0] = state->seqno >> 8;
	wptr[1] = state->seqno;
	wptr += 2;
	state->strm.next_out = wptr;
	state->strm.avail_out = wspace - (PPP_HDRLEN + 2);
    } else {
	state->strm.next_out = NULL;
	state->strm.avail_out = 1000000;
	wptr = NULL;
	wspace = 0;
    }
    ++state->seqno;

    rptr += (proto > 0xff)? 2: 3;	/* skip 1st proto byte if 0 */
    state->strm.next_in = rptr;
    state->strm.avail_in = mtod(mp, u_char *) + mp->m_len - rptr;
    mp = mp->m_next;
    flush = (mp == NULL)? Z_SYNC_FLUSH: Z_NO_FLUSH;
    olen = 0;
    for (;;) {
	r = deflate(&state->strm, flush);
	if (r != Z_OK) {
	    printf("z_compress: deflate returned %d (%s)\n",
		   r, (state->strm.msg? state->strm.msg: ""));
	    break;
	}
	if (flush != Z_NO_FLUSH && state->strm.avail_out != 0)
	    break;		/* all done */
	if (state->strm.avail_in == 0 && mp != NULL) {
	    state->strm.next_in = mtod(mp, u_char *);
	    state->strm.avail_in = mp->m_len;
	    mp = mp->m_next;
	    if (mp == NULL)
		flush = Z_SYNC_FLUSH;
	}
	if (state->strm.avail_out == 0) {
	    if (m != NULL) {
		m->m_len = wspace;
		olen += wspace;
		MGET(m->m_next, M_DONTWAIT, MT_DATA);
		m = m->m_next;
		if (m != NULL) {
		    m->m_len = 0;
		    if (maxolen - olen > MLEN)
			MCLGET(m, M_DONTWAIT);
		    state->strm.next_out = mtod(m, u_char *);
		    state->strm.avail_out = wspace = M_TRAILINGSPACE(m);
		}
	    }
	    if (m == NULL) {
		state->strm.next_out = NULL;
		state->strm.avail_out = 1000000;
	    }
	}
    }
    if (m != NULL)
	olen += (m->m_len = wspace - state->strm.avail_out);

    /*
     * See if we managed to reduce the size of the packet.
     * If the compressor just gave us a single zero byte, it means
     * the packet was incompressible.
     */
    if (m != NULL && olen < orig_len
	&& !(olen == PPP_HDRLEN + 3 && *wptr == 0)) {
	state->stats.comp_bytes += olen;
	state->stats.comp_packets++;
    } else {
	m_freem(*mret);
	*mret = NULL;

	state->stats.inc_bytes += orig_len;
	state->stats.inc_packets++;
	olen = orig_len;
    }
    state->stats.unc_bytes += orig_len;
    state->stats.unc_packets++;

    return olen;
}

static void
z_comp_stats(arg, stats)
    void *arg;
    struct compstat *stats;
{
    struct deflate_state *state = (struct deflate_state *) arg;
    u_int out;

    *stats = state->stats;
    stats->ratio = stats->unc_bytes;
    out = stats->comp_bytes + stats->inc_bytes;
    if (stats->ratio <= 0x7ffffff)
	stats->ratio <<= 8;
    else
	out >>= 8;
    if (out != 0)
	stats->ratio /= out;
}

/*
 * Allocate space for a decompressor.
 */
static void *
z_decomp_alloc(options, opt_len)
    u_char *options;
    int opt_len;
{
    struct deflate_state *state;
    int w_size;

    if (opt_len != CILEN_DEFLATE
	|| (options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT)
	|| options[1] != CILEN_DEFLATE
	|| DEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL
	|| options[3] != DEFLATE_CHK_SEQUENCE)
	return NULL;
    w_size = DEFLATE_SIZE(options[2]);
    if (w_size < DEFLATE_MIN_SIZE || w_size > DEFLATE_MAX_SIZE)
	return NULL;

    state = malloc(sizeof(*state), M_DEVBUF, M_NOWAIT);
    if (state == NULL)
	return NULL;

    state->strm.next_out = NULL;
    state->strm.zalloc = zcalloc;
    state->strm.zfree = zcfree;
    if (inflateInit2(&state->strm, -w_size) != Z_OK) {
	free(state, M_DEVBUF, 0);
	return NULL;
    }

    state->w_size = w_size;
    bzero(&state->stats, sizeof(state->stats));
    return (void *) state;
}

static void
z_decomp_free(arg)
    void *arg;
{
    struct deflate_state *state = (struct deflate_state *) arg;

    inflateEnd(&state->strm);
    free(state, M_DEVBUF, 0);
}

static int
z_decomp_init(arg, options, opt_len, unit, hdrlen, mru, debug)
    void *arg;
    u_char *options;
    int opt_len, unit, hdrlen, mru, debug;
{
    struct deflate_state *state = (struct deflate_state *) arg;

    if (opt_len < CILEN_DEFLATE
	|| (options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT)
	|| options[1] != CILEN_DEFLATE
	|| DEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL
	|| DEFLATE_SIZE(options[2]) != state->w_size
	|| options[3] != DEFLATE_CHK_SEQUENCE)
	return 0;

    state->seqno = 0;
    state->unit = unit;
    state->hdrlen = hdrlen;
    state->debug = debug;
    state->mru = mru;

    inflateReset(&state->strm);

    return 1;
}

static void
z_decomp_reset(arg)
    void *arg;
{
    struct deflate_state *state = (struct deflate_state *) arg;

    state->seqno = 0;
    inflateReset(&state->strm);
}

/*
 * Decompress a Deflate-compressed packet.
 *
 * Because of patent problems, we return DECOMP_ERROR for errors
 * found by inspecting the input data and for system problems, but
 * DECOMP_FATALERROR for any errors which could possibly be said to
 * be being detected "after" decompression.  For DECOMP_ERROR,
 * we can issue a CCP reset-request; for DECOMP_FATALERROR, we may be
 * infringing a patent of Motorola's if we do, so we take CCP down
 * instead.
 *
 * Given that the frame has the correct sequence number and a good FCS,
 * errors such as invalid codes in the input most likely indicate a
 * bug, so we return DECOMP_FATALERROR for them in order to turn off
 * compression, even though they are detected by inspecting the input.
 */
int
z_decompress(arg, mi, mop)
    void *arg;
    struct mbuf *mi, **mop;
{
    struct deflate_state *state = (struct deflate_state *) arg;
    struct mbuf *mo, *mo_head;
    u_char *rptr, *wptr;
    int rlen, olen, ospace;
    int seq, i, flush, r, decode_proto;
    u_char hdr[PPP_HDRLEN + DEFLATE_OVHD];

    *mop = NULL;
    rptr = mtod(mi, u_char *);
    rlen = mi->m_len;
    for (i = 0; i < PPP_HDRLEN + DEFLATE_OVHD; ++i) {
	while (rlen <= 0) {
	    mi = mi->m_next;
	    if (mi == NULL)
		return DECOMP_ERROR;
	    rptr = mtod(mi, u_char *);
	    rlen = mi->m_len;
	}
	hdr[i] = *rptr++;
	--rlen;
    }

    /* Check the sequence number. */
    seq = (hdr[PPP_HDRLEN] << 8) + hdr[PPP_HDRLEN+1];
    if (seq != state->seqno) {
	if (state->debug)
	    printf("z_decompress%d: bad seq # %d, expected %d\n",
		   state->unit, seq, state->seqno);
	return DECOMP_ERROR;
    }
    ++state->seqno;

    /* Allocate an output mbuf. */
    MGETHDR(mo, M_DONTWAIT, MT_DATA);
    if (mo == NULL)
	return DECOMP_ERROR;
    mo_head = mo;
    mo->m_len = 0;
    mo->m_next = NULL;
    MCLGET(mo, M_DONTWAIT);
    ospace = M_TRAILINGSPACE(mo);
    if (state->hdrlen + PPP_HDRLEN < ospace) {
	mo->m_data += state->hdrlen;
	ospace -= state->hdrlen;
    }

    /*
     * Fill in the first part of the PPP header.  The protocol field
     * comes from the decompressed data.
     */
    wptr = mtod(mo, u_char *);
    wptr[0] = PPP_ADDRESS(hdr);
    wptr[1] = PPP_CONTROL(hdr);
    wptr[2] = 0;

    /*
     * Set up to call inflate.  We set avail_out to 1 initially so we can
     * look at the first byte of the output and decide whether we have
     * a 1-byte or 2-byte protocol field.
     */
    state->strm.next_in = rptr;
    state->strm.avail_in = rlen;
    mi = mi->m_next;
    flush = (mi == NULL)? Z_SYNC_FLUSH: Z_NO_FLUSH;
    rlen += PPP_HDRLEN + DEFLATE_OVHD;
    state->strm.next_out = wptr + 3;
    state->strm.avail_out = 1;
    decode_proto = 1;
    olen = PPP_HDRLEN;

    /*
     * Call inflate, supplying more input or output as needed.
     */
    for (;;) {
	r = inflate(&state->strm, flush);
	if (r != Z_OK) {
#ifndef DEFLATE_DEBUG
	    if (state->debug)
#endif
		printf("z_decompress%d: inflate returned %d (%s)\n",
		       state->unit, r, (state->strm.msg? state->strm.msg: ""));
	    m_freem(mo_head);
	    return DECOMP_FATALERROR;
	}
	if (flush != Z_NO_FLUSH && state->strm.avail_out != 0)
	    break;		/* all done */
	if (state->strm.avail_in == 0 && mi != NULL) {
	    state->strm.next_in = mtod(mi, u_char *);
	    state->strm.avail_in = mi->m_len;
	    rlen += mi->m_len;
	    mi = mi->m_next;
	    if (mi == NULL)
		flush = Z_SYNC_FLUSH;
	}
	if (state->strm.avail_out == 0) {
	    if (decode_proto) {
		state->strm.avail_out = ospace - PPP_HDRLEN;
		if ((wptr[3] & 1) == 0) {
		    /* 2-byte protocol field */
		    wptr[2] = wptr[3];
		    --state->strm.next_out;
		    ++state->strm.avail_out;
		    --olen;
		}
		decode_proto = 0;
	    } else {
		mo->m_len = ospace;
		olen += ospace;
		MGET(mo->m_next, M_DONTWAIT, MT_DATA);
		mo = mo->m_next;
		if (mo == NULL) {
		    m_freem(mo_head);
		    return DECOMP_ERROR;
		}
		MCLGET(mo, M_DONTWAIT);
		state->strm.next_out = mtod(mo, u_char *);
		state->strm.avail_out = ospace = M_TRAILINGSPACE(mo);
	    }
	}
    }
    if (decode_proto) {
	m_freem(mo_head);
	return DECOMP_ERROR;
    }
    olen += (mo->m_len = ospace - state->strm.avail_out);
#ifdef DEFLATE_DEBUG
    if (olen > state->mru + PPP_HDRLEN)
	printf("ppp_deflate%d: exceeded mru (%d > %d)\n",
	       state->unit, olen, state->mru + PPP_HDRLEN);
#endif

    state->stats.unc_bytes += olen;
    state->stats.unc_packets++;
    state->stats.comp_bytes += rlen;
    state->stats.comp_packets++;

    *mop = mo_head;
    return DECOMP_OK;
}

/*
 * Incompressible data has arrived - add it to the history.
 */
static void
z_incomp(arg, mi)
    void *arg;
    struct mbuf *mi;
{
    struct deflate_state *state = (struct deflate_state *) arg;
    u_char *rptr;
    int rlen, proto, r;

    /*
     * Check that the protocol is one we handle.
     */
    rptr = mtod(mi, u_char *);
    proto = PPP_PROTOCOL(rptr);
    if (proto > 0x3fff || proto == 0xfd || proto == 0xfb)
	return;

    ++state->seqno;

    /*
     * Iterate through the mbufs, adding the characters in them
     * to the decompressor's history.  For the first mbuf, we start
     * at the either the 1st or 2nd byte of the protocol field,
     * depending on whether the protocol value is compressible.
     */
    rlen = mi->m_len;
    state->strm.next_in = rptr + 3;
    state->strm.avail_in = rlen - 3;
    if (proto > 0xff) {
	--state->strm.next_in;
	++state->strm.avail_in;
    }
    for (;;) {
	r = inflateInit(&state->strm);
	if (r != Z_OK) {
	    /* gak! */
#ifndef DEFLATE_DEBUG
	    if (state->debug)
#endif
		printf("z_incomp%d: inflateIncomp returned %d (%s)\n",
		       state->unit, r, (state->strm.msg? state->strm.msg: ""));
	    return;
	}
	mi = mi->m_next;
	if (mi == NULL)
	    break;
	state->strm.next_in = mtod(mi, u_char *);
	state->strm.avail_in = mi->m_len;
	rlen += mi->m_len;
    }

    /*
     * Update stats.
     */
    state->stats.inc_bytes += rlen;
    state->stats.inc_packets++;
    state->stats.unc_bytes += rlen;
    state->stats.unc_packets++;
}

#endif /* DO_DEFLATE */
@


1.11
log
@replace some malloc multiplies with mallocarry. ok deraadt henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.10 2014/07/12 18:44:22 tedu Exp $	*/
d345 3
a347 4
	if (*mret != NULL) {
	    m_freem(*mret);
	    *mret = NULL;
	}
@


1.10
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.9 2011/07/07 02:57:25 deraadt Exp $	*/
d134 1
a134 1
    ptr = malloc(items * size, M_DEVBUF, M_NOWAIT);
@


1.9
log
@Replace the cruddy old sys/net/zlib.[ch].  We now use the sys/lib/libz
code.  Missing chunks of the API are imported from the libc version,
with a few #ifdef's to port it into the kernel environment.

The bootblocks already used the newer code, and should encounter no
surprises since there are so few changes to the existing files. In
the kernel, ipcomp and kernel ppp are changed to the new API.
ipcomp has been tested.

ok tedu the brave
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.8 2007/09/15 16:43:51 henning Exp $	*/
d143 1
a143 1
    free(ptr, M_DEVBUF);
d176 1
a176 1
	free(state, M_DEVBUF);
d192 1
a192 1
    free(state, M_DEVBUF);
d407 1
a407 1
	free(state, M_DEVBUF);
d423 1
a423 1
    free(state, M_DEVBUF);
@


1.8
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.7 2002/09/13 00:12:07 deraadt Exp $	*/
d46 1
a46 1
#include <net/zlib.h>
d69 2
a70 2
static void	*zalloc(void *, u_int items, u_int size);
static void	zfree(void *, void *ptr, u_int nb);
d128 1
a128 1
zalloc(notused, items, size)
d139 1
a139 1
zfree(notused, ptr, nbytes)
a141 1
    u_int nbytes;
d172 2
a173 2
    state->strm.zalloc = zalloc;
    state->strm.zfree = zfree;
d175 1
a175 1
		     -w_size, 8, Z_DEFAULT_STRATEGY, DEFLATE_OVHD+2) != Z_OK) {
d294 1
a294 1
    flush = (mp == NULL)? Z_PACKET_FLUSH: Z_NO_FLUSH;
d310 1
a310 1
		flush = Z_PACKET_FLUSH;
d404 2
a405 2
    state->strm.zalloc = zalloc;
    state->strm.zfree = zfree;
d547 1
a547 1
    flush = (mi == NULL)? Z_PACKET_FLUSH: Z_NO_FLUSH;
d576 1
a576 1
		flush = Z_PACKET_FLUSH;
d660 1
a660 1
	r = inflateIncomp(&state->strm);
@


1.7
log
@Paul Mackerras and the Australian National University have worked things
out, and as a result, Paul now owns copyright on all these files, with the
proper terms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.6 2002/03/14 01:27:10 millert Exp $	*/
d134 1
a134 1
    MALLOC(ptr, void *, items * size, M_DEVBUF, M_NOWAIT);
d144 1
a144 1
    FREE(ptr, M_DEVBUF);
d168 1
a168 2
    MALLOC(state, struct deflate_state *, sizeof(struct deflate_state),
	   M_DEVBUF, M_NOWAIT);
d177 1
a177 1
	FREE(state, M_DEVBUF);
d193 1
a193 1
    FREE(state, M_DEVBUF);
d400 1
a400 2
    MALLOC(state, struct deflate_state *, sizeof(struct deflate_state),
	   M_DEVBUF, M_NOWAIT);
d408 1
a408 1
	FREE(state, M_DEVBUF);
d424 1
a424 1
    FREE(state, M_DEVBUF);
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.5 1998/05/08 05:02:07 millert Exp $	*/
d9 1
a9 2
 * Copyright (c) 1994 The Australian National University.
 * All rights reserved.
d11 28
a38 19
 * Permission to use, copy, modify, and distribute this software and its
 * documentation is hereby granted, provided that the above copyright
 * notice appears in all copies.  This software is provided without any
 * warranty, express or implied. The Australian National University
 * makes no representations about the suitability of this software for
 * any purpose.
 *
 * IN NO EVENT SHALL THE AUSTRALIAN NATIONAL UNIVERSITY BE LIABLE TO ANY
 * PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 * THE AUSTRALIAN NATIONAL UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * THE AUSTRALIAN NATIONAL UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE AUSTRALIAN NATIONAL UNIVERSITY HAS NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
 * OR MODIFICATIONS.
@


1.5
log
@Add support for RFC-comliant deflate protocol
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.4 1997/09/05 04:27:03 millert Exp $	*/
d61 18
a78 18
static void	*zalloc __P((void *, u_int items, u_int size));
static void	zfree __P((void *, void *ptr, u_int nb));
static void	*z_comp_alloc __P((u_char *options, int opt_len));
static void	*z_decomp_alloc __P((u_char *options, int opt_len));
static void	z_comp_free __P((void *state));
static void	z_decomp_free __P((void *state));
static int	z_comp_init __P((void *state, u_char *options, int opt_len,
				 int unit, int hdrlen, int debug));
static int	z_decomp_init __P((void *state, u_char *options, int opt_len,
				     int unit, int hdrlen, int mru, int debug));
static int	z_compress __P((void *state, struct mbuf **mret,
				  struct mbuf *mp, int slen, int maxolen));
static void	z_incomp __P((void *state, struct mbuf *dmsg));
static int	z_decompress __P((void *state, struct mbuf *cmp,
				    struct mbuf **dmpp));
static void	z_comp_reset __P((void *state));
static void	z_decomp_reset __P((void *state));
static void	z_comp_stats __P((void *state, struct compstat *stats));
@


1.5.18.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.5 1998/05/08 05:02:07 millert Exp $	*/
d61 18
a78 18
static void	*zalloc(void *, u_int items, u_int size);
static void	zfree(void *, void *ptr, u_int nb);
static void	*z_comp_alloc(u_char *options, int opt_len);
static void	*z_decomp_alloc(u_char *options, int opt_len);
static void	z_comp_free(void *state);
static void	z_decomp_free(void *state);
static int	z_comp_init(void *state, u_char *options, int opt_len,
				 int unit, int hdrlen, int debug);
static int	z_decomp_init(void *state, u_char *options, int opt_len,
				     int unit, int hdrlen, int mru, int debug);
static int	z_compress(void *state, struct mbuf **mret,
				  struct mbuf *mp, int slen, int maxolen);
static void	z_incomp(void *state, struct mbuf *dmsg);
static int	z_decompress(void *state, struct mbuf *cmp,
				    struct mbuf **dmpp);
static void	z_comp_reset(void *state);
static void	z_decomp_reset(void *state);
static void	z_comp_stats(void *state, struct compstat *stats);
@


1.5.18.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.5.18.1 2002/06/11 03:30:46 art Exp $	*/
d9 2
a10 1
 * Copyright (c) 1989-2002 Paul Mackerras. All rights reserved.
d12 19
a30 28
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name(s) of the authors of this software must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Paul Mackerras
 *     <paulus@@samba.org>".
 *
 * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.5.8.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 18
a78 18
static void	*zalloc(void *, u_int items, u_int size);
static void	zfree(void *, void *ptr, u_int nb);
static void	*z_comp_alloc(u_char *options, int opt_len);
static void	*z_decomp_alloc(u_char *options, int opt_len);
static void	z_comp_free(void *state);
static void	z_decomp_free(void *state);
static int	z_comp_init(void *state, u_char *options, int opt_len,
				 int unit, int hdrlen, int debug);
static int	z_decomp_init(void *state, u_char *options, int opt_len,
				     int unit, int hdrlen, int mru, int debug);
static int	z_compress(void *state, struct mbuf **mret,
				  struct mbuf *mp, int slen, int maxolen);
static void	z_incomp(void *state, struct mbuf *dmsg);
static int	z_decompress(void *state, struct mbuf *cmp,
				    struct mbuf **dmpp);
static void	z_comp_reset(void *state);
static void	z_decomp_reset(void *state);
static void	z_comp_stats(void *state, struct compstat *stats);
@


1.5.8.2
log
@Sync the SMP branch with 3.3
@
text
@d9 2
a10 1
 * Copyright (c) 1989-2002 Paul Mackerras. All rights reserved.
d12 19
a30 28
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name(s) of the authors of this software must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Paul Mackerras
 *     <paulus@@samba.org>".
 *
 * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.4
log
@Minor changes from ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.3 1997/02/24 13:34:04 niklas Exp $	*/
d100 16
d150 2
a151 1
    if (opt_len != CILEN_DEFLATE || options[0] != CI_DEFLATE
d197 2
a198 1
    if (opt_len < CILEN_DEFLATE || options[0] != CI_DEFLATE
d383 2
a384 1
    if (opt_len != CILEN_DEFLATE || options[0] != CI_DEFLATE
d429 2
a430 1
    if (opt_len < CILEN_DEFLATE || options[0] != CI_DEFLATE
@


1.3
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD: ppp-deflate.c,v 1.1 1996/03/15 02:28:09 paulus Exp $	*/
d586 2
a587 2
        printf("ppp_deflate%d: exceeded mru (%d > %d)\n",
               state->unit, olen, state->mru + PPP_HDRLEN);
@


1.2
log
@sync to 2.3b3
@
text
@d1 1
@


1.1
log
@partial sync with netbsd 960418, more to come
@
text
@d534 1
d536 1
d583 5
d637 3
a639 1
	    if (state->debug) {
a641 1
	    }
@
