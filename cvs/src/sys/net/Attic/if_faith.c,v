head	1.28;
access;
symbols
	OPENBSD_5_3:1.27.0.4
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.12
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.28
date	2013.03.14.11.18.37;	author mpi;	state dead;
branches;
next	1.27;

1.27
date	2012.04.14.09.39.46;	author yasuoka;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.06.21.38.19;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.07.02.11.34;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.31.03.53.38;	author pascoe;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.03.14.53.04;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.04.22.14.16;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.26.06.29.01;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.10.02.57.10;	author fgsch;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.06.09.06.30.16;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.09.06.23.06;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.20.10.33.28;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.19.06.37.36;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.07.06.09.08;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.01.07.19.31.29;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.40.00;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.54.00;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.3.2.9;

1.3.2.9
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.01.31.22.55.43;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@/*	$OpenBSD: if_faith.c,v 1.27 2012/04/14 09:39:46 yasuoka Exp $	*/
/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * derived from 
 *	@@(#)if_loop.c	8.1 (Berkeley) 6/10/93
 * Id: if_loop.c,v 1.22 1996/06/19 16:24:10 wollman Exp
 */

/*
 * Loopback interface driver for protocol testing and timing.
 */
#include "faith.h"

#if NFAITH > 0

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>

#ifdef	INET
#include <netinet/in.h>
#include <netinet/in_var.h>
#endif

#ifdef INET6
#ifndef INET
#include <netinet/in.h>
#endif
#include <netinet6/in6_var.h>
#endif

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

static int faithioctl(struct ifnet *, u_long, caddr_t);
int faithoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *);

void	faithattach(int);
int	faith_clone_create(struct if_clone *, int);
int	faith_clone_destroy(struct ifnet *ifp);

struct if_clone faith_cloner =
    IF_CLONE_INITIALIZER("faith", faith_clone_create, faith_clone_destroy);

#define	FAITHMTU	1500

/* ARGSUSED */
void
faithattach(faith)
	int faith;
{
	if_clone_attach(&faith_cloner);
}

int
faith_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
{
	struct ifnet *ifp;

	ifp = malloc(sizeof(*ifp), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!ifp)
		return (ENOMEM);
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name, 
	    unit);
	ifp->if_mtu = FAITHMTU;
	/* Change to BROADCAST experimentaly to announce its prefix. */
	ifp->if_flags = /* IFF_LOOPBACK */ IFF_BROADCAST | IFF_MULTICAST;
	ifp->if_ioctl = faithioctl;
	ifp->if_output = faithoutput;
	ifp->if_type = IFT_FAITH;
	ifp->if_hdrlen = 0;
	ifp->if_addrlen = 0;
	if_attach(ifp);
	if_alloc_sadl(ifp);
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
#endif
	return (0);
}

int
faith_clone_destroy(ifp)
	struct ifnet *ifp;
{
	if_detach(ifp);

	free(ifp, M_DEVBUF);
	return (0);
}

int
faithoutput(ifp, m, dst, rt)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr *dst;
	struct rtentry *rt;
{
	int s, isr;
	struct ifqueue *ifq = 0;

	if ((m->m_flags & M_PKTHDR) == 0)
		panic("faithoutput no HDR");
#if NBPFILTER > 0
	/* BPF write needs to be handled specially */
	if (dst->sa_family == AF_UNSPEC) {
		dst->sa_family = *(mtod(m, int *));
		m->m_len -= sizeof(int);
		m->m_pkthdr.len -= sizeof(int);
		m->m_data += sizeof(int);
	}

	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m, BPF_DIRECTION_OUT);
#endif

	if (rt && rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE)) {
		m_freem(m);
		return (rt->rt_flags & RTF_BLACKHOLE ? 0 :
		        rt->rt_flags & RTF_HOST ? EHOSTUNREACH : ENETUNREACH);
	}
	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;
	switch (dst->sa_family) {
#ifdef INET
	case AF_INET:
		ifq = &ipintrq;
		isr = NETISR_IP;
		break;
#endif
#ifdef INET6
	case AF_INET6:
		ifq = &ip6intrq;
		isr = NETISR_IPV6;
		break;
#endif
	default:
		m_freem(m);
		return EAFNOSUPPORT;
	}

	/* XXX do we need more sanity checks? */

	m->m_pkthdr.rcvif = ifp;
	s = splnet();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
		splx(s);
		return (ENOBUFS);
	}
	IF_ENQUEUE(ifq, m);
	schednetisr(isr);
	ifp->if_ipackets++;
	ifp->if_ibytes += m->m_pkthdr.len;
	splx(s);
	return (0);
}

/*
 * Process an ioctl request.
 */
/* ARGSUSED */
static int
faithioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ifaddr *ifa;
	struct ifreq *ifr = (struct ifreq *)data;
	int error = 0;

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP | IFF_RUNNING;
		ifa = (struct ifaddr *)data;
		/*
		 * Everything else is done at a higher level.
		 */
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		if (ifr == 0) {
			error = EAFNOSUPPORT;		/* XXX */
			break;
		}
		switch (ifr->ifr_addr.sa_family) {
#ifdef INET
		case AF_INET:
			break;
#endif
#ifdef INET6
		case AF_INET6:
			break;
#endif

		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;

	case SIOCSIFFLAGS:
		break;

	default:
		error = ENOTTY;
	}
	return (error);
}
#endif /* NFAITH > 0 */
@


1.27
log
@Use DLT_LOOP for all tunneling interfaces.
Byte order adjustment for bpf was hidden behind bpf_mtap_af() and
sizeof(u_int32_t) is used for length of the bpf header.

tested by sebastia and mxb at alumni.chalmers.se.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.26 2010/05/06 21:38:19 claudio Exp $	*/
@


1.26
log
@Move the net/bpf.h include done and wrap it in the ususal #if NBPFILTER > 0
block as done in other drivers. Based on an old diff by Gleydson Soares.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.25 2008/05/07 02:11:34 claudio Exp $	*/
d115 1
a115 1
	bpfattach(&ifp->if_bpf, ifp, DLT_NULL, sizeof(u_int));
@


1.25
log
@There is no reason to have a faithrtrequest() function that sets the MTU to
route MTU to the interface MTU. By default if no route MTU is set it will
fall back to the interface MTU anyway. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.24 2007/12/20 02:53:02 brad Exp $	*/
a52 1
#include <net/bpf.h>
d67 3
@


1.24
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.23 2007/09/15 16:43:51 henning Exp $	*/
a71 1
static void faithrtrequest(int, struct rtentry *, struct rt_addrinfo *);
a195 11
/* ARGSUSED */
static void
faithrtrequest(cmd, rt, info)
	int cmd;
	struct rtentry *rt;
	struct rt_addrinfo *info;
{
	if (rt)
		rt->rt_rmx.rmx_mtu = rt->rt_ifp->if_mtu; /* for ISO */
}

a214 1
		ifa->ifa_rtrequest = faithrtrequest;
@


1.23
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.22 2006/03/25 22:41:47 djm Exp $	*/
d259 1
a259 1
		error = EINVAL;
@


1.22
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.21 2006/03/04 22:40:15 brad Exp $	*/
d98 1
a98 1
	ifp = malloc(sizeof(*ifp), M_DEVBUF, M_NOWAIT);
a100 1
	bzero(ifp, sizeof(*ifp));
@


1.21
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.20 2006/01/04 06:04:42 canacar Exp $	*/
d152 1
a152 1
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m);
@


1.20
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.19 2005/07/31 03:53:38 pascoe Exp $	*/
d183 1
a183 1
	s = splimp();
@


1.19
log
@Missed argument in previous commit, applied separately to ease merges.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.18 2005/07/31 03:52:18 pascoe Exp $	*/
a123 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif  
@


1.18
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.17 2003/12/16 20:33:25 markus Exp $	*/
d155 1
a155 1
		bpf_mtap_af(ifp->if_bpf, dst->sa_family);
@


1.17
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.16 2003/12/03 14:53:04 markus Exp $	*/
d154 2
a155 18
	if (ifp->if_bpf) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a faith header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer a to it).
		 */
		struct mbuf m0;
		u_int32_t af = dst->sa_family;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *)&af;

		bpf_mtap(ifp->if_bpf, &m0);
	}
@


1.16
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.15 2003/06/02 23:28:12 millert Exp $	*/
d76 1
a76 1
void	faith_clone_destroy(struct ifnet *ifp);
d120 1
a120 1
void
d130 1
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.14 2003/05/03 21:15:11 deraadt Exp $	*/
d74 3
a76 1
void faithattach(int);
d78 2
a79 1
static struct ifnet faithif[NFAITH];
d88 8
a96 1
	int i;
d98 16
a113 14
	for (i = 0; i < NFAITH; i++) {
		ifp = &faithif[i];
		bzero(ifp, sizeof(faithif[i]));
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "faith%d", i);
		ifp->if_mtu = FAITHMTU;
		/* Change to BROADCAST experimentaly to announce its prefix. */
		ifp->if_flags = /* IFF_LOOPBACK */ IFF_BROADCAST | IFF_MULTICAST;
		ifp->if_ioctl = faithioctl;
		ifp->if_output = faithoutput;
		ifp->if_type = IFT_FAITH;
		ifp->if_hdrlen = 0;
		ifp->if_addrlen = 0;
		if_attach(ifp);
		if_alloc_sadl(ifp);
d115 1
a115 1
		bpfattach(&ifp->if_bpf, ifp, DLT_NULL, sizeof(u_int));
d117 13
a129 1
	}
@


1.14
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.13 2003/05/03 01:43:07 itojun Exp $	*/
d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.12 2002/06/30 13:04:36 itojun Exp $	*/
d95 1
a95 1
		sprintf(ifp->if_xname, "faith%d", i);
@


1.12
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.11 2002/06/04 22:14:16 itojun Exp $	*/
d144 1
@


1.11
log
@no need to specify rmx_send/recvpipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.10 2002/03/14 01:27:09 millert Exp $	*/
d105 1
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.9 2001/12/26 06:29:01 itojun Exp $	*/
d201 1
a201 1
	if (rt) {
a202 8
		/*
		 * For optimal performance, the send and receive buffers
		 * should be at least twice the MTU plus a little more for
		 * overhead.
		 */
		rt->rt_rmx.rmx_recvpipe =
			rt->rt_rmx.rmx_sendpipe = 3 * FAITHMTU;
	}
@


1.9
log
@cosmetic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.8 2001/07/10 02:57:10 fgsch Exp $	*/
d73 4
a76 4
static int faithioctl __P((struct ifnet *, u_long, caddr_t));
int faithoutput __P((struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *));
static void faithrtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
d78 1
a78 1
void faithattach __P((int));
@


1.8
log
@another lame OpenBSD tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 2
a75 2
int faithoutput __P((struct ifnet *, register struct mbuf *, struct sockaddr *,
	register struct rtentry *));
d89 2
a90 2
	register struct ifnet *ifp;
	register int i;
d114 1
a114 1
	register struct mbuf *m;
d116 1
a116 1
	register struct rtentry *rt;
d119 1
a119 1
	register struct ifqueue *ifq = 0;
d208 1
a208 1
		rt->rt_rmx.rmx_recvpipe = 
d219 1
a219 1
	register struct ifnet *ifp;
d223 3
a225 3
	register struct ifaddr *ifa;
	register struct ifreq *ifr = (struct ifreq *)data;
	register int error = 0;
@


1.8.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.9 2001/12/26 06:29:01 itojun Exp $	*/
d74 2
a75 2
int faithoutput __P((struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *));
d89 2
a90 2
	struct ifnet *ifp;
	int i;
d114 1
a114 1
	struct mbuf *m;
d116 1
a116 1
	struct rtentry *rt;
d119 1
a119 1
	struct ifqueue *ifq = 0;
d208 1
a208 1
		rt->rt_rmx.rmx_recvpipe =
d219 1
a219 1
	struct ifnet *ifp;
d223 3
a225 3
	struct ifaddr *ifa;
	struct ifreq *ifr = (struct ifreq *)data;
	int error = 0;
@


1.8.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.8.4.1 2002/01/31 22:55:43 niklas Exp $	*/
d73 4
a76 4
static int faithioctl(struct ifnet *, u_long, caddr_t);
int faithoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *);
static void faithrtrequest(int, struct rtentry *, struct rt_addrinfo *);
d78 1
a78 1
void faithattach(int);
d201 1
a201 1
	if (rt)
d203 8
@


1.8.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.8.4.2 2002/06/11 03:30:45 art Exp $	*/
a104 1
		if_alloc_sadl(ifp);
@


1.8.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 1
a95 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "faith%d", i);
a143 1
		m0.m_flags = 0;
@


1.7
log
@Include cleanup.
@
text
@d1 1
@


1.6
log
@These don't need net_osdep.h
@
text
@a47 1
#include <sys/kernel.h>
a49 1
#include <sys/errno.h>
a50 1
#include <sys/time.h>
a59 1
#include <netinet/in_systm.h>
a60 1
#include <netinet/ip.h>
a67 1
#include <netinet/ip6.h>
@


1.5
log
@use u_int32_t, not u_int, for DLT_NULL encapsulation.  sync with kame
@
text
@a77 2
#include <net/net_osdep.h>

@


1.4
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d148 1
a148 1
		u_int af = dst->sa_family;
@


1.3
log
@fix include file path related to ip6.
@
text
@d83 1
a83 1
static void faithrtrequest __P((int, struct rtentry *, struct sockaddr *));
d203 1
a203 1
faithrtrequest(cmd, rt, sa)
d206 1
a206 1
	struct sockaddr *sa;
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d83 1
a83 1
static void faithrtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
d148 1
a148 1
		u_int32_t af = dst->sa_family;
d203 1
a203 1
faithrtrequest(cmd, rt, info)
d206 1
a206 1
	struct rt_addrinfo *info;
@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d48 1
d51 1
d53 1
d63 1
d65 1
d73 1
d77 2
@


1.3.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.3.2.4
log
@Merge in trunk
@
text
@d74 2
a75 2
int faithoutput __P((struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *));
d89 2
a90 2
	struct ifnet *ifp;
	int i;
d114 1
a114 1
	struct mbuf *m;
d116 1
a116 1
	struct rtentry *rt;
d119 1
a119 1
	struct ifqueue *ifq = 0;
d208 1
a208 1
		rt->rt_rmx.rmx_recvpipe =
d219 1
a219 1
	struct ifnet *ifp;
d223 3
a225 3
	struct ifaddr *ifa;
	struct ifreq *ifr = (struct ifreq *)data;
	int error = 0;
@


1.3.2.5
log
@Merge in -current from roughly a week ago
@
text
@d73 4
a76 4
static int faithioctl(struct ifnet *, u_long, caddr_t);
int faithoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *);
static void faithrtrequest(int, struct rtentry *, struct rt_addrinfo *);
d78 1
a78 1
void faithattach(int);
@


1.3.2.6
log
@Sync the SMP branch with 3.3
@
text
@a104 1
		if_alloc_sadl(ifp);
d201 1
a201 1
	if (rt)
d203 8
@


1.3.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.3.2.6 2003/03/28 00:41:28 niklas Exp $	*/
d95 1
a95 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "faith%d", i);
a143 1
		m0.m_flags = 0;
@


1.3.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_faith.c,v 1.3.2.7 2003/05/13 19:36:15 ho Exp $	*/
d14 5
a18 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 3
void	faithattach(int);
int	faith_clone_create(struct if_clone *, int);
int	faith_clone_destroy(struct ifnet *ifp);
d76 1
a76 2
struct if_clone faith_cloner =
    IF_CLONE_INITIALIZER("faith", faith_clone_create, faith_clone_destroy);
a84 8
	if_clone_attach(&faith_cloner);
}

int
faith_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
{
d86 1
d88 14
a101 16
	ifp = malloc(sizeof(*ifp), M_DEVBUF, M_NOWAIT);
	if (!ifp)
		return (ENOMEM);
	bzero(ifp, sizeof(*ifp));
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name, 
	    unit);
	ifp->if_mtu = FAITHMTU;
	/* Change to BROADCAST experimentaly to announce its prefix. */
	ifp->if_flags = /* IFF_LOOPBACK */ IFF_BROADCAST | IFF_MULTICAST;
	ifp->if_ioctl = faithioctl;
	ifp->if_output = faithoutput;
	ifp->if_type = IFT_FAITH;
	ifp->if_hdrlen = 0;
	ifp->if_addrlen = 0;
	if_attach(ifp);
	if_alloc_sadl(ifp);
d103 1
a103 1
	bpfattach(&ifp->if_bpf, ifp, DLT_NULL, sizeof(u_int));
d105 1
a105 14
	return (0);
}

int
faith_clone_destroy(ifp)
	struct ifnet *ifp;
{
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif  
	if_detach(ifp);

	free(ifp, M_DEVBUF);
	return (0);
@


1.2
log
@ifdef cleanup
@
text
@d73 1
a73 1
#include <netinet6/ip6.h>
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d42 1
a42 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include "opt_inet.h"
#endif
a43 1
#include "faith.h"
a51 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include <sys/sockio.h>
#else
a52 1
#endif
a53 3
#ifdef __bsdi__
#include <machine/cpu.h>
#endif
a79 3
#if defined(__FreeBSD__) && __FreeBSD__ < 3
static int faithioctl __P((struct ifnet *, int, caddr_t));
#else
a80 1
#endif
a84 4
#ifdef __FreeBSD__
void faithattach __P((void *));
PSEUDO_SET(faithattach, if_faith);
#else
a85 1
#endif
a93 3
#ifdef __FreeBSD__
	void *faith;
#else
a94 1
#endif
a101 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a102 4
#else
		ifp->if_name = "faith";
		ifp->if_unit = i;
#endif
a112 3
#ifdef HAVE_OLD_BPF
		bpfattach(ifp, DLT_NULL, sizeof(u_int));
#else
a114 1
#endif
a153 3
#ifdef HAVE_OLD_BPF
		bpf_mtap(ifp, &m0);
#else
a154 1
#endif
a226 3
#if defined(__FreeBSD__) && __FreeBSD__ < 3
	int cmd;
#else
a227 1
#endif
a265 8

#ifdef SIOCSIFMTU
#ifndef __OpenBSD__
	case SIOCSIFMTU:
		ifp->if_mtu = ifr->ifr_mtu;
		break;
#endif
#endif
@

