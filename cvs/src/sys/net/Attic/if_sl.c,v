head	1.55;
access;
symbols
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.6
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.35.0.4
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.29.0.6
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.17
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.55
date	2014.10.01.10.08.30;	author mpi;	state dead;
branches;
next	1.54;
commitid	H2YI4nUd6WXupaiB;

1.54
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.53;
commitid	uuiU9j2I8AUx0fez;

1.53
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.52;
commitid	DQakU8LLWV6Iwx84;

1.52
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.51;
commitid	B4dZSbxas1X1IpXI;

1.51
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.50;

1.50
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.10.19.14.46.31;	author mpi;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.16.12.05.04;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.17.21.22.54;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.06.11.52.41;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.02.22.34.31;	author stsp;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.24.08.00.12;	author stsp;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.19.08.16.06;	author blambert;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.08.15.01.50;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.22.23.04.45;	author mpf;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.13.14.21.01;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.11.22.44.47;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.25.18.50.01;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.13.10.01.16;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.12.12.54.57;	author hshoexer;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.07.15.41.27;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.06.07.43;	author kjc;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.06.15.03.38.34;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.12.21.41.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.17.18.41.46;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.13.05.16.06;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.04.22.20.02.43;	author art;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	97.09.05.04.27.01;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.08.22.00.35.52;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.09.09.59.19;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.07.28.25;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.31.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.14.08.41.45;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.21.07.10;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.05.14.22.40.01;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.07.04.10.54.05;	author niklas;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.9.4.8;

1.9.4.8
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.55
log
@sl(4) is no more, thanks for all the fish!
@
text
@/*	$OpenBSD: if_sl.c,v 1.54 2014/09/15 19:08:21 miod Exp $	*/
/*	$NetBSD: if_sl.c,v 1.39.4.1 1996/06/02 16:26:31 thorpej Exp $	*/

/*
 * Copyright (c) 1987, 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_sl.c	8.6 (Berkeley) 2/1/94
 */

/*
 * Serial Line interface
 *
 * Rick Adams
 * Center for Seismic Studies
 * 1300 N 17th Street, Suite 1450
 * Arlington, Virginia 22209
 * (703)276-7900
 * rick@@seismo.ARPA
 * seismo!rick
 *
 * Pounded on heavily by Chris Torek (chris@@mimsy.umd.edu, umcp-cs!chris).
 * N.B.: this belongs in netinet, not net, the way it stands now.
 * Should have a link-layer type designation, but wouldn't be
 * backwards-compatible.
 *
 * Converted to 4.3BSD Beta by Chris Torek.
 * Other changes made at Berkeley, based in part on code by Kirk Smith.
 * W. Jolitz added slip abort.
 *
 * Hacked almost beyond recognition by Van Jacobson (van@@helios.ee.lbl.gov).
 * Added priority queuing for "interactive" traffic; hooks for TCP
 * header compression; ICMP filtering (at 2400 baud, some cretin
 * pinging you can use up all your bandwidth).  Made low clist behavior
 * more robust and slightly less likely to hang serial line.
 * Sped up a bunch of things.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/tty.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/systm.h>


#include <net/if.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/ip.h>
#else
#error Huh? Slip without inet?
#endif

#include <net/slcompress.h>
#include <net/if_slvar.h>
#include <net/slip.h>

#if NBPFILTER > 0
#include <sys/time.h>
#include <net/bpf.h>
#endif

/*
 * SLMAX is a hard limit on input packet size.  To simplify the code
 * and improve performance, we require that packets fit in an mbuf
 * cluster, and if we get a compressed packet, there's enough extra
 * room to expand the header into a max length tcp/ip header (128
 * bytes).  So, SLMAX can be at most
 *	MCLBYTES - 128
 *
 * SLMTU is a hard limit on output packet size.  To insure good
 * interactive response, SLMTU wants to be the smallest size that
 * amortizes the header cost.  (Remember that even with
 * type-of-service queuing, we have to wait for any in-progress
 * packet to finish.  I.e., we wait, on the average, 1/2 * mtu /
 * cps, where cps is the line speed in characters per second.
 * E.g., 533ms wait for a 1024 byte MTU on a 9600 baud line.  The
 * average compressed header size is 6-8 bytes so any MTU > 90
 * bytes will give us 90% of the line bandwidth.  A 100ms wait is
 * tolerable (500ms is not), so want an MTU around 296.  (Since TCP
 * will send 256 byte segments (to allow for 40 byte headers), the
 * typical packet size on the wire will be around 260 bytes).  In
 * 4.3tahoe+ systems, we can set an MTU in a route so we do that &
 * leave the interface MTU relatively high (so we don't IP fragment
 * when acting as a gateway to someone using a stupid MTU).
 *
 * Similar considerations apply to SLIP_HIWAT:  It's the amount of
 * data that will be queued 'downstream' of us (i.e., in clists
 * waiting to be picked up by the tty output interrupt).  If we
 * queue a lot of data downstream, it's immune to our t.o.s. queuing.
 * E.g., if SLIP_HIWAT is 1024, the interactive traffic in mixed
 * telnet/ftp will see a 1 sec wait, independent of the mtu (the
 * wait is dependent on the ftp window size but that's typically
 * 1k - 4k).  So, we want SLIP_HIWAT just big enough to amortize
 * the cost (in idle time on the wire) of the tty driver running
 * off the end of its clists & having to call back slstart for a
 * new packet.  For a tty interface with any buffering at all, this
 * cost will be zero.  Even with a totally brain dead interface (like
 * the one on a typical workstation), the cost will be <= 1 character
 * time.  So, setting SLIP_HIWAT to ~100 guarantees that we'll lose
 * at most 1% while maintaining good interactive response.
 */
#if NBPFILTER > 0
#define	BUFOFFSET	(128+sizeof(struct ifnet **)+SLIP_HDRLEN)
#else
#define	BUFOFFSET	(128+sizeof(struct ifnet **))
#endif
#define	SLMAX		(MCLBYTES - BUFOFFSET)
#define	SLBUFSIZE	(SLMAX + BUFOFFSET)
#ifndef SLMTU
#define	SLMTU		296
#endif
#if (SLMTU < 3)
#error Huh?  SLMTU way too small.
#endif
#define	SLIP_HIWAT	100

/*
 * SLIP ABORT ESCAPE MECHANISM:
 *	(inspired by HAYES modem escape arrangement)
 *	1sec escape 1sec escape 1sec escape { 1sec escape 1sec escape }
 *	within window time signals a "soft" exit from slip mode by remote end
 *	if the IFF_DEBUG flag is on.
 */
#define	ABT_ESC		'\033'	/* can't be t_intr - distant host must know it*/
#define	ABT_IDLE	1	/* in seconds - idle before an escape */
#define	ABT_COUNT	3	/* count of escapes for abort */
#define	ABT_WINDOW	(ABT_COUNT*2+2)	/* in seconds - time to count */


#define FRAME_END	 	0xc0		/* Frame End */
#define FRAME_ESCAPE		0xdb		/* Frame Esc */
#define TRANS_FRAME_END	 	0xdc		/* transposed frame end */
#define TRANS_FRAME_ESCAPE 	0xdd		/* transposed frame esc */

static int slinit(struct sl_softc *);
static struct mbuf *sl_btom(struct sl_softc *, int);

int	sl_clone_create(struct if_clone *, int);
int	sl_clone_destroy(struct ifnet *);

LIST_HEAD(, sl_softc) sl_softc_list;
struct if_clone sl_cloner =
    IF_CLONE_INITIALIZER("sl", sl_clone_create, sl_clone_destroy);

/*
 * Called from boot code to establish sl interfaces.
 */
void
slattach(n)
	int n;
{
	LIST_INIT(&sl_softc_list);
	if_clone_attach(&sl_cloner);
}

int
sl_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
{
	struct sl_softc *sc;
	int s;

	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!sc)
		return (ENOMEM);

	sc->sc_unit = unit;	/* XXX */
	snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "%s%d",
	    ifc->ifc_name, unit);
	sc->sc_if.if_softc = sc;
	sc->sc_if.if_mtu = SLMTU;
	sc->sc_if.if_flags =
	    IFF_POINTOPOINT | SC_AUTOCOMP | IFF_MULTICAST;
	sc->sc_if.if_type = IFT_SLIP;
	sc->sc_if.if_ioctl = slioctl;
	sc->sc_if.if_output = sloutput;
	IFQ_SET_MAXLEN(&sc->sc_if.if_snd, 50);
	IFQ_SET_MAXLEN(&sc->sc_fastq, 32);
	IFQ_SET_READY(&sc->sc_if.if_snd);
	if_attach(&sc->sc_if);
	if_alloc_sadl(&sc->sc_if);
#if NBPFILTER > 0
	bpfattach(&sc->sc_bpf, &sc->sc_if, DLT_SLIP, SLIP_HDRLEN);
#endif
	s = splnet();
	LIST_INSERT_HEAD(&sl_softc_list, sc, sc_list);
	splx(s);

	return (0);
}

int
sl_clone_destroy(ifp)
	struct ifnet *ifp;
{
	struct sl_softc *sc = ifp->if_softc;
	int s;

	if (sc->sc_ttyp != NULL)
		return (EBUSY);

	s = splnet();
	LIST_REMOVE(sc, sc_list);
	splx(s);

	if_detach(ifp);

	free(sc, M_DEVBUF, 0);
	return (0);
}

static int
slinit(sc)
	struct sl_softc *sc;
{
	if (sc->sc_ep == (u_char *) 0) {
		MGETHDR(sc->sc_mbuf, M_WAIT, MT_DATA);
		if (sc->sc_mbuf)
			MCLGET(sc->sc_mbuf, M_WAIT);
		if (sc->sc_mbuf == NULL || sc->sc_mbuf->m_ext.ext_buf == NULL) {
			printf("sl%d: can't allocate buffer\n", sc->sc_unit);
			sc->sc_if.if_flags &= ~IFF_UP;
			return (0);
		}
	}
	sc->sc_ep = (u_char *) sc->sc_mbuf->m_ext.ext_buf +
	    sc->sc_mbuf->m_ext.ext_size;
	sc->sc_mp = sc->sc_pktstart = (u_char *) sc->sc_mbuf->m_ext.ext_buf +
	    BUFOFFSET;

	sl_compress_init(&sc->sc_comp);

	return (1);
}

/*
 * Line specific open routine.
 * Attach the given tty to the first available sl unit.
 */
/* ARGSUSED */
int
slopen(dev, tp)
	dev_t dev;
	struct tty *tp;
{
	struct proc *p = curproc;		/* XXX */
	struct sl_softc *sc;
	int error, s;

	if ((error = suser(p, 0)) != 0)
		return (error);

	if (tp->t_line == SLIPDISC)
		return (0);

	LIST_FOREACH(sc, &sl_softc_list, sc_list)
		if (sc->sc_ttyp == NULL) {
			if (slinit(sc) == 0)
				return (ENOBUFS);
			tp->t_sc = (caddr_t)sc;
			sc->sc_ttyp = tp;
			sc->sc_if.if_baudrate = tp->t_ospeed;
			s = spltty();
			tp->t_state |= TS_ISOPEN | TS_XCLUDE;
			splx(s);
			ttyflush(tp, FREAD | FWRITE);
			/*
			 * make sure tty output queue is large enough
			 * to hold a full-sized packet (including frame
			 * end, and a possible extra frame end).  full-sized
			 * packet occupies a max of 2*SLMTU bytes (because
			 * of possible escapes), and add two on for frame
			 * ends.
			 */
			s = spltty();
			if (tp->t_outq.c_cn < 2*SLMTU+2) {
				sc->sc_oldbufsize = tp->t_outq.c_cn;
				sc->sc_oldbufquot = tp->t_outq.c_cq != 0;

				clfree(&tp->t_outq);
				clalloc(&tp->t_outq, 3*SLMTU, 0);
			} else
				sc->sc_oldbufsize = sc->sc_oldbufquot = 0;
			splx(s);
			return (0);
		}
	return (ENXIO);
}

/*
 * Line specific close routine.
 * Detach the tty from the sl unit.
 */
void
slclose(tp)
	struct tty *tp;
{
	struct sl_softc *sc;
	int s;

	ttywflush(tp);
	tp->t_line = 0;
	sc = (struct sl_softc *)tp->t_sc;
	if (sc != NULL) {
		s = spltty();

		if_down(&sc->sc_if);
		sc->sc_ttyp = NULL;
		tp->t_sc = NULL;

		m_freem(sc->sc_mbuf);
		sc->sc_mbuf = NULL;
		sc->sc_ep = sc->sc_mp = sc->sc_pktstart = NULL;

		/* if necessary, install a new outq buffer of the appropriate size */
		if (sc->sc_oldbufsize != 0) {
			clfree(&tp->t_outq);
			clalloc(&tp->t_outq, sc->sc_oldbufsize, sc->sc_oldbufquot);
		}
		splx(s);
	}
}

/*
 * Line specific (tty) ioctl routine.
 * Provide a way to get the sl unit number.
 */
/* ARGSUSED */
int
sltioctl(tp, cmd, data, flag)
	struct tty *tp;
	u_long cmd;
	caddr_t data;
	int flag;
{
	struct sl_softc *sc = (struct sl_softc *)tp->t_sc;

	switch (cmd) {
	case SLIOCGUNIT:
		*(int *)data = sc->sc_unit;	/* XXX */
		break;

	default:
		return (-1);
	}
	return (0);
}

/*
 * Queue a packet.  Start transmission if not active.
 * Compression happens in slstart; if we do it here, IP TOS
 * will cause us to not compress "background" packets, because
 * ordering gets trashed.  It can be done for all packets in slstart.
 */
int
sloutput(ifp, m, dst, rtp)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr *dst;
	struct rtentry *rtp;
{
	struct sl_softc *sc = ifp->if_softc;
	struct ip *ip;
	int s, error;

	/*
	 * `Cannot happen' (see slioctl).  Someday we will extend
	 * the line protocol to support other address families.
	 */
	if (dst->sa_family != AF_INET) {
		printf("%s: af%d not supported\n", sc->sc_if.if_xname,
			dst->sa_family);
		m_freem(m);
		sc->sc_if.if_noproto++;
		return (EAFNOSUPPORT);
	}

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.ph_rtableid),
		    dst->sa_family);
	}
#endif

	if (sc->sc_ttyp == NULL) {
		m_freem(m);
		return (ENETDOWN);	/* sort of */
	}
	if ((sc->sc_ttyp->t_state & TS_CARR_ON) == 0 &&
	    (sc->sc_ttyp->t_cflag & CLOCAL) == 0) {
		m_freem(m);
		return (EHOSTUNREACH);
	}
	ip = mtod(m, struct ip *);
	if (sc->sc_if.if_flags & SC_NOICMP && ip->ip_p == IPPROTO_ICMP) {
		m_freem(m);
		return (ENETRESET);		/* XXX ? */
	}
	s = spltty();
	if (sc->sc_oqlen && sc->sc_ttyp->t_outq.c_cc == sc->sc_oqlen) {
		struct timeval tv, tm;

		getmicrotime(&tm);
		/* if output's been stalled for too long, and restart */
		timersub(&tm, &sc->sc_lastpacket, &tv);
		if (tv.tv_sec > 0) {
			sc->sc_otimeout++;
			slstart(sc->sc_ttyp);
		}
	}

	(void) splnet();
	IFQ_ENQUEUE(&sc->sc_if.if_snd, m, NULL, error);
	if (error) {
		splx(s);
		sc->sc_if.if_oerrors++;
		return (error);
	}

	(void) spltty();
	getmicrotime(&sc->sc_lastpacket);
	if ((sc->sc_oqlen = sc->sc_ttyp->t_outq.c_cc) == 0)
		slstart(sc->sc_ttyp);
	splx(s);
	return (0);
}

/*
 * Start output on interface.  Get another datagram
 * to send from the interface queue and map it to
 * the interface before starting output.
 */
void
slstart(tp)
	struct tty *tp;
{
	struct sl_softc *sc = (struct sl_softc *)tp->t_sc;
	struct mbuf *m;
	u_char *cp;
	struct ip *ip;
	int s;
	struct mbuf *m2;
#if NBPFILTER > 0
	u_char bpfbuf[SLMTU + SLIP_HDRLEN];
	int len = 0;
#endif

	for (;;) {
		/*
		 * If there is more in the output queue, just send it now.
		 * We are being called in lieu of ttstart and must do what
		 * it would.
		 */
		if (tp->t_outq.c_cc != 0) {
			(*tp->t_oproc)(tp);
			if (tp->t_outq.c_cc > SLIP_HIWAT)
				return;
		}
		/*
		 * This happens briefly when the line shuts down.
		 */
		if (sc == NULL)
			return;

		/*
		 * Do not remove the packet from the IP queue if it
		 * doesn't look like the packet will fit into the
		 * current serial output queue, with a packet full of
		 * escapes this could be as bad as SLMTU*2+2.
		 */
		if (tp->t_outq.c_cn - tp->t_outq.c_cc < 2*SLMTU+2)
			return;

		/*
		 * Get a packet and send it to the interface.
		 */
		s = splnet();
		IF_DEQUEUE(&sc->sc_fastq, m);
		if (m)
			sc->sc_if.if_omcasts++;		/* XXX */
		else
			IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
		splx(s);
		if (m == NULL)
			return;

		/*
		 * We do the header compression here rather than in sloutput
		 * because the packets will be out of order if we are using TOS
		 * queueing, and the connection id compression will get
		 * munged when this happens.
		 */
#if NBPFILTER > 0
		if (sc->sc_bpf) {
			/*
			 * We need to save the TCP/IP header before it's
			 * compressed.  To avoid complicated code, we just
			 * copy the entire packet into a stack buffer (since
			 * this is a serial line, packets should be short
			 * and/or the copy should be negligible cost compared
			 * to the packet transmission time).
			 */
			struct mbuf *m1 = m;

			cp = bpfbuf + SLIP_HDRLEN;
			len = 0;
			do {
				int mlen = m1->m_len;

				bcopy(mtod(m1, caddr_t), cp, mlen);
				cp += mlen;
				len += mlen;
			} while ((m1 = m1->m_next) != NULL);
		}
#endif
		if ((ip = mtod(m, struct ip *))->ip_p == IPPROTO_TCP) {
			if (sc->sc_if.if_flags & SC_COMPRESS)
				*mtod(m, u_char *) |= sl_compress_tcp(m, ip,
				    &sc->sc_comp, 1);
		}
#if NBPFILTER > 0
		if (sc->sc_bpf) {
			/*
			 * Put the SLIP pseudo-"link header" in place.  The
			 * compressed header is now at the beginning of the
			 * mbuf.
			 */
			bpfbuf[SLX_DIR] = SLIPDIR_OUT;
			bcopy(mtod(m, caddr_t), &bpfbuf[SLX_CHDR], CHDR_LEN);
			bpf_tap(sc->sc_bpf, bpfbuf, len + SLIP_HDRLEN,
			    BPF_DIRECTION_OUT);
		}
#endif
		getmicrotime(&sc->sc_lastpacket);

		/*
		 * The extra FRAME_END will start up a new packet, and thus
		 * will flush any accumulated garbage.  We do this whenever
		 * the line may have been idle for some time.
		 */
		if (tp->t_outq.c_cc == 0) {
			++sc->sc_if.if_obytes;
			(void) putc(FRAME_END, &tp->t_outq);
		}

		while (m) {
			u_char *ep;

			cp = mtod(m, u_char *); ep = cp + m->m_len;
			while (cp < ep) {
				/*
				 * Find out how many bytes in the string we can
				 * handle without doing something special.
				 */
				u_char *bp = cp;

				while (cp < ep) {
					switch (*cp++) {
					case FRAME_ESCAPE:
					case FRAME_END:
						--cp;
						goto out;
					}
				}
				out:
				if (cp > bp) {
					/*
					 * Put n characters at once
					 * into the tty output queue.
					 */
					if (b_to_q((u_char *)bp, cp - bp,
					    &tp->t_outq))
						break;
					sc->sc_if.if_obytes += cp - bp;
				}
				/*
				 * If there are characters left in the mbuf,
				 * the first one must be special..
				 * Put it out in a different form.
				 */
				if (cp < ep) {
					if (putc(FRAME_ESCAPE, &tp->t_outq))
						break;
					if (putc(*cp++ == FRAME_ESCAPE ?
					   TRANS_FRAME_ESCAPE : TRANS_FRAME_END,
					   &tp->t_outq)) {
						(void) unputc(&tp->t_outq);
						break;
					}
					sc->sc_if.if_obytes += 2;
				}
			}
			MFREE(m, m2);
			m = m2;
		}

		if (putc(FRAME_END, &tp->t_outq)) {
			/*
			 * Not enough room.  Remove a char to make room
			 * and end the packet normally.
			 * If you get many collisions (more than one or two
			 * a day) you probably do not have enough clists
			 * and you should increase "nclist" in param.c.
			 */
			(void) unputc(&tp->t_outq);
			(void) putc(FRAME_END, &tp->t_outq);
			sc->sc_if.if_collisions++;
		} else {
			++sc->sc_if.if_obytes;
			sc->sc_if.if_opackets++;
		}
	}
}

/*
 * Copy data buffer to mbuf chain; add ifnet pointer.
 */
static struct mbuf *
sl_btom(sc, len)
	struct sl_softc *sc;
	int len;
{
	struct mbuf *m;

	/*
	 * Allocate a new input buffer and swap.
	 */
	m = sc->sc_mbuf;
	MGETHDR(sc->sc_mbuf, M_DONTWAIT, MT_DATA);
	if (sc->sc_mbuf == NULL) {
		sc->sc_mbuf = m;
		return (NULL);
	}
	MCLGET(sc->sc_mbuf, M_DONTWAIT);
	if ((sc->sc_mbuf->m_flags & M_EXT) == 0) {
		/*
		 * we couldn't get a cluster - if memory's this
		 * low, it's time to start dropping packets.
		 */
		m_freem(sc->sc_mbuf);
		sc->sc_mbuf = m;
		return (NULL);
	}
	sc->sc_ep = (u_char *) sc->sc_mbuf->m_ext.ext_buf +
		sc->sc_mbuf->m_ext.ext_size;
	
	m->m_data = sc->sc_pktstart;

	m->m_len = len;
	m->m_pkthdr.len = len;
	m->m_pkthdr.rcvif = &sc->sc_if;
	return (m);
}

/*
 * tty interface receiver interrupt.
 */
void
slinput(c, tp)
	int c;
	struct tty *tp;
{
	struct sl_softc *sc;
	struct mbuf *m;
	int len;
	int s;
#if NBPFILTER > 0
	u_char chdr[CHDR_LEN];
#endif

	tk_nin++;
	sc = (struct sl_softc *)tp->t_sc;
	if (sc == NULL)
		return;
	if (c & TTY_ERRORMASK || ((tp->t_state & TS_CARR_ON) == 0 &&
	    (tp->t_cflag & CLOCAL) == 0)) {
		sc->sc_flags |= SC_ERROR;
		return;
	}
	c &= TTY_CHARMASK;

	++sc->sc_if.if_ibytes;

	if (sc->sc_if.if_flags & IFF_DEBUG) {
		if (c == ABT_ESC) {
			/*
			 * If we have a previous abort, see whether
			 * this one is within the time limit.
			 */
			if (sc->sc_abortcount &&
			    time_second >= sc->sc_starttime + ABT_WINDOW)
				sc->sc_abortcount = 0;
			/*
			 * If we see an abort after "idle" time, count it;
			 * record when the first abort escape arrived.
			 */
			if (time_second >= sc->sc_lasttime + ABT_IDLE) {
				if (++sc->sc_abortcount == 1)
					sc->sc_starttime = time_second;
				if (sc->sc_abortcount >= ABT_COUNT) {
					slclose(tp);
					return;
				}
			}
		} else
			sc->sc_abortcount = 0;
		sc->sc_lasttime = time_second;
	}

	switch (c) {

	case TRANS_FRAME_ESCAPE:
		if (sc->sc_escape)
			c = FRAME_ESCAPE;
		break;

	case TRANS_FRAME_END:
		if (sc->sc_escape)
			c = FRAME_END;
		break;

	case FRAME_ESCAPE:
		sc->sc_escape = 1;
		return;

	case FRAME_END:
		if(sc->sc_flags & SC_ERROR) {
			sc->sc_flags &= ~SC_ERROR;
			goto newpack;
		}
		len = sc->sc_mp - sc->sc_pktstart;
		if (len < 3)
			/* less than min length packet - ignore */
			goto newpack;

#if NBPFILTER > 0
		if (sc->sc_bpf) {
			/*
			 * Save the compressed header, so we
			 * can tack it on later.  Note that we
			 * will end up copying garbage in some
			 * cases but this is okay.  We remember
			 * where the buffer started so we can
			 * compute the new header length.
			 */
			bcopy(sc->sc_pktstart, chdr, CHDR_LEN);
		}
#endif

		if ((c = (*sc->sc_pktstart & 0xf0)) != (IPVERSION << 4)) {
			if (c & 0x80)
				c = TYPE_COMPRESSED_TCP;
			else if (c == TYPE_UNCOMPRESSED_TCP)
				*sc->sc_pktstart &= 0x4f; /* XXX */
			/*
			 * We've got something that's not an IP packet.
			 * If compression is enabled, try to decompress it.
			 * Otherwise, if `auto-enable' compression is on and
			 * it's a reasonable packet, decompress it and then
			 * enable compression.  Otherwise, drop it.
			 */
			if (sc->sc_if.if_flags & SC_COMPRESS) {
				len = sl_uncompress_tcp(&sc->sc_pktstart, len,
							(u_int)c, &sc->sc_comp);
				if (len <= 0)
					goto error;
			} else if ((sc->sc_if.if_flags & SC_AUTOCOMP) &&
			    c == TYPE_UNCOMPRESSED_TCP && len >= 40) {
				len = sl_uncompress_tcp(&sc->sc_pktstart, len,
							(u_int)c, &sc->sc_comp);
				if (len <= 0)
					goto error;
				sc->sc_if.if_flags |= SC_COMPRESS;
			} else
				goto error;
		}

		m = sl_btom(sc, len);
		if (m == NULL)
			goto error;

		/* mark incoming routing table */
		m->m_pkthdr.ph_rtableid = sc->sc_if.if_rdomain;

#if NBPFILTER > 0
		if (sc->sc_bpf) {
			/*
			 * Put the SLIP pseudo-"link header" in place.
			 * Note this M_PREPEND() should bever fail,
			 * since we know we always have enough space
			 * in the input buffer.
			 */
			u_char *hp;

			M_PREPEND(m, SLIP_HDRLEN, M_DONTWAIT);
			if (m == NULL)
				goto error;

			hp = mtod(m, u_char *);
			hp[SLX_DIR] = SLIPDIR_IN;
			memcpy(&hp[SLX_CHDR], chdr, CHDR_LEN);

			s = splnet();
			bpf_mtap(sc->sc_bpf, m, BPF_DIRECTION_IN);
			splx(s);

			m_adj(m, SLIP_HDRLEN);
		}
#endif

		sc->sc_if.if_ipackets++;
		getmicrotime(&sc->sc_lastpacket);
		s = splnet();
		if (IF_QFULL(&ipintrq)) {
			IF_DROP(&ipintrq);
			sc->sc_if.if_ierrors++;
			sc->sc_if.if_iqdrops++;
			m_freem(m);
			if (!ipintrq.ifq_congestion)
				if_congestion(&ipintrq);
		} else {
			IF_ENQUEUE(&ipintrq, m);
			schednetisr(NETISR_IP);
		}
		splx(s);
		goto newpack;
	}
	if (sc->sc_mp < sc->sc_ep) {
		*sc->sc_mp++ = c;
		sc->sc_escape = 0;
		return;
	}

	/* can't put lower; would miss an extra frame */
	sc->sc_flags |= SC_ERROR;

error:
	sc->sc_if.if_ierrors++;
newpack:
	sc->sc_mp = sc->sc_pktstart = (u_char *) sc->sc_mbuf->m_ext.ext_buf +
	    BUFOFFSET;
	sc->sc_escape = 0;
}

/*
 * Process an ioctl request.
 */
int
slioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct sl_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	int s = splnet(), error = 0;
	struct sl_stats *slsp;

	switch (cmd) {

	case SIOCSIFADDR:
		if (ifa->ifa_addr->sa_family == AF_INET)
			ifp->if_flags |= IFF_UP;
		else
			error = EAFNOSUPPORT;
		break;

	case SIOCSIFDSTADDR:
		if (ifa->ifa_addr->sa_family != AF_INET)
			error = EAFNOSUPPORT;
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCGSLSTATS:
		slsp = &((struct ifslstatsreq *) data)->stats;
		bzero(slsp, sizeof(*slsp));
		/* slsp->sl = sc->sc_stats; */
		slsp->sl.sl_ibytes = sc->sc_if.if_ibytes;
		slsp->sl.sl_obytes = sc->sc_if.if_obytes;
		slsp->sl.sl_ipackets = sc->sc_if.if_ipackets;
		slsp->sl.sl_opackets = sc->sc_if.if_opackets;
#ifdef INET
		slsp->vj.vjs_packets = sc->sc_comp.sls_packets;
		slsp->vj.vjs_compressed = sc->sc_comp.sls_compressed;
		slsp->vj.vjs_searches = sc->sc_comp.sls_searches;
		slsp->vj.vjs_misses = sc->sc_comp.sls_misses;
		slsp->vj.vjs_uncompressedin = sc->sc_comp.sls_uncompressedin;
		slsp->vj.vjs_compressedin = sc->sc_comp.sls_compressedin;
		slsp->vj.vjs_errorin = sc->sc_comp.sls_errorin;
		slsp->vj.vjs_tossed = sc->sc_comp.sls_tossed;
#endif /* INET */
		break;

	default:
		error = ENOTTY;
	}
	splx(s);
	return (error);
}
@


1.54
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.53 2014/07/22 11:06:09 mpi Exp $	*/
@


1.53
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.52 2014/07/12 18:44:22 tedu Exp $	*/
a66 1
#include <sys/dkstat.h>
@


1.52
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.51 2014/04/14 09:06:42 mpi Exp $	*/
a83 1
#include <netinet/in_systm.h>
@


1.51
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.50 2013/10/23 15:12:42 mpi Exp $	*/
d246 1
a246 1
	free(sc, M_DEVBUF);
@


1.50
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.49 2013/10/19 14:46:31 mpi Exp $	*/
d417 1
a417 1
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
d420 1
a420 1
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain),
d822 2
a823 2
		/* mark incoming routing domain */
		m->m_pkthdr.rdomain = sc->sc_if.if_rdomain;
@


1.49
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.48 2013/04/16 12:05:04 mpi Exp $	*/
a84 1
#include <netinet/in_var.h>
@


1.48
log
@Remove code under ifndef OpenBSD. No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.47 2013/03/28 16:55:27 deraadt Exp $	*/
a896 1
	struct ifreq *ifr;
a915 16
		ifr = (struct ifreq *)data;
		if (ifr == 0) {
			error = EAFNOSUPPORT;		/* XXX */
			break;
		}
		switch (ifr->ifr_addr.sa_family) {

#ifdef INET
		case AF_INET:
			break;
#endif

		default:
			error = EAFNOSUPPORT;
			break;
		}
@


1.47
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.46 2013/03/28 16:45:16 tedu Exp $	*/
a73 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a74 1
#endif
a153 3
#if !(defined(__NetBSD__) || defined(__OpenBSD__))		/* XXX - cgd */
#define	CLISTRESERVE	1024	/* Can't let clists get too low */
#endif	/* !NetBSD */
a305 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a323 1
#endif /* NetBSD */
a353 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a358 1
#endif
a487 3
#if !(defined(__NetBSD__) || defined(__OpenBSD__))	/* XXX - cgd */
	extern int cfreecount;
#endif
a505 1
#if defined(__NetBSD__) || defined(__OpenBSD__)		/* XXX - cgd */
a513 1
#endif /* NetBSD */
a576 12
#if !(defined(__NetBSD__) || defined(__OpenBSD__))		/* XXX - cgd */
		/*
		 * If system is getting low on clists, just flush our
		 * output queue (if the stuff was important, it'll get
		 * retransmitted).
		 */
		if (cfreecount < CLISTRESERVE + SLMTU) {
			m_freem(m);
			sc->sc_if.if_collisions++;
			continue;
		}
#endif /* !__NetBSD__ */
a611 1
#if defined(__NetBSD__) || defined(__OpenBSD__)		/* XXX - cgd */
a612 3
#else
					if (b_to_q((char *)bp, cp - bp,
#endif
@


1.46
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.45 2013/01/17 21:22:54 deraadt Exp $	*/
a77 1
#include <machine/cpu.h>
@


1.45
log
@hardwire SLIP_HIWAT to 100 (as the comment above suggests) since we are
using tty ring buffers instead of clists
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.44 2011/07/06 02:42:28 henning Exp $	*/
a65 1
#include <sys/proc.h>
@


1.44
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.43 2011/01/06 11:52:41 claudio Exp $	*/
d157 1
a157 1
#define	SLIP_HIWAT	roundup(50,CBSIZE)
@


1.43
log
@Do not assign m->m_pkthdr.rdomain before m was allocated.
Fix for rev 1.37 commit which would crash when slip(4) is used.
Problem found the hard way by Henri Kemppainen.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.42 2010/05/02 22:34:31 stsp Exp $	*/
d224 1
a224 1
	sc->sc_fastq.ifq_maxlen = 32;
@


1.42
log
@The line-discipline-specific ioctls return -1 to indicate that
the non-line-discipline-specific ioctl handler should be tried.
So changing these to return ENOTTY was wrong.

Noted on misc@@ because of resulting pppd log spam (but it didn't break
anything serious): http://marc.info/?l=openbsd-misc&m=127258856501621&w=2

ok sthen@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.41 2010/05/01 08:14:26 mk Exp $	*/
a754 3
	/* mark incoming routing domain */
	m->m_pkthdr.rdomain = sc->sc_if.if_rdomain;

d854 3
@


1.41
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.40 2010/04/24 08:00:12 stsp Exp $	*/
d394 1
a394 1
		return (ENOTTY);
@


1.40
log
@Make if_ppp and if_sl ioctl handlers return ENOTTY for unsupported
ioctls, instead of -1 or EINVAL. ENOTTY audit suggested to me by uwe.
ok dlg tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.39 2009/11/03 10:59:04 claudio Exp $	*/
d755 1
a755 1
	/* mark incomming routing domain */
@


1.39
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.38 2009/07/19 08:16:06 blambert Exp $	*/
d394 1
a394 1
		return (-1);
@


1.38
log
@clalloc() can't fail, so there's no need to handle failure cases.
Change to void function.
Also, no need to have global tty stats pointer, so just return it
from clalloc, as the caller frees it immediately anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.37 2009/07/08 15:01:50 claudio Exp $	*/
d429 1
a429 1
	if (ifp->if_rdomain != m->m_pkthdr.rdomain) {
d431 3
a433 4
		    "%d vs. %d, AF %d\n", ifp->if_xname, ifp->if_rdomain,
		    m->m_pkthdr.rdomain, dst->sa_family);
		m_freem(m);
		return (ENETDOWN);
@


1.37
log
@Add the same routing domain assignments and checks into the not so used
protocols as it is currently in if_ethersubr.c. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.36 2008/10/22 23:04:45 mpf Exp $	*/
d328 1
a328 5
				error = clalloc(&tp->t_outq, 3*SLMTU, 0);
				if (error) {
					splx(s);
					return (error);
				}
@


1.36
log
@#if INET  => #ifdef INET
#if INET6 => #ifdef INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.35 2007/12/20 02:53:02 brad Exp $	*/
d432 10
d759 3
@


1.35
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.34 2007/10/13 14:21:01 fgsch Exp $	*/
d86 1
a86 1
#if INET
@


1.34
log
@remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.33 2007/09/15 16:43:51 henning Exp $	*/
d980 1
a980 1
		error = EINVAL;
@


1.33
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.32 2006/03/25 22:41:47 djm Exp $	*/
a555 1
			u_char *cp = bpfbuf + SLIP_HDRLEN;
d557 1
@


1.32
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.31 2006/03/11 22:44:47 brad Exp $	*/
d209 1
a209 1
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
a211 1
	bzero(sc, sizeof(*sc));
@


1.31
log
@splimp -> spltty/splnet

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.30 2006/01/04 06:04:42 canacar Exp $	*/
d583 2
a584 1
			bpf_tap(sc->sc_bpf, bpfbuf, len + SLIP_HDRLEN);
d870 1
a870 1
			bpf_mtap(sc->sc_bpf, m);
@


1.30
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.29 2004/06/24 19:35:25 tholo Exp $	*/
a60 3
 * 
 * Note that splimp() is used throughout to block both (tty) input
 * interrupts and network activity; thus, splimp must be >= spltty.
d232 1
a232 1
	s = splimp();
d249 1
a249 1
	s = splimp();
d358 1
a358 1
		s = splimp();		/* actually, max(spltty, splsoftnet) */
d447 1
a447 1
	s = splimp();
d459 2
d468 1
d530 1
a530 1
		s = splimp();
d878 1
a878 1
		s = splimp();
d922 1
a922 1
	int s = splimp(), error = 0;
@


1.29
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.28 2004/06/21 23:50:36 tholo Exp $	*/
a255 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.28
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.27 2004/04/25 18:50:01 henning Exp $	*/
d455 1
a455 1
		struct timeval tv;
d457 1
d459 1
a459 1
		timersub(&time, &sc->sc_lastpacket, &tv);
d472 1
a472 1
	sc->sc_lastpacket = time;
d589 1
a589 1
		sc->sc_lastpacket = time;
d880 1
a880 1
		sc->sc_lastpacket = time;
@


1.27
log
@check for input queue congestion on those as well and call if_congestion when
needed; these  are slightly different so that we cannot use the new
IF_INPUT_ENQUEUE macro
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.26 2003/12/16 20:33:25 markus Exp $	*/
d761 1
a761 1
			    time.tv_sec >= sc->sc_starttime + ABT_WINDOW)
d767 1
a767 1
			if (time.tv_sec >= sc->sc_lasttime + ABT_IDLE) {
d769 1
a769 1
					sc->sc_starttime = time.tv_sec;
d777 1
a777 1
		sc->sc_lasttime = time.tv_sec;
@


1.26
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.25 2003/12/13 10:01:16 markus Exp $	*/
d886 2
@


1.25
log
@initial support ifconfig destroy; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.24 2003/12/12 12:54:57 hshoexer Exp $	*/
d187 1
a187 1
void	sl_clone_destroy(struct ifnet *);
d242 1
a242 1
void
d250 1
a250 1
		return;
d262 1
@


1.24
log
@small compiler warning cleanup (#error instead of bailing out)

ok henning@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.23 2003/12/10 07:22:42 itojun Exp $	*/
d187 1
d191 1
a191 1
    IF_CLONE_INITIALIZER("sl", sl_clone_create, NULL);
d240 22
@


1.23
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.22 2003/12/07 15:41:27 markus Exp $	*/
d95 1
a95 1
Huh? Slip without inet?
d158 1
a158 1
Huh?  SLMTU way too small.
@


1.22
log
@support ifconfig create; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.21 2003/08/15 20:32:19 tedu Exp $	*/
d243 1
a243 1
	register struct sl_softc *sc;
d273 1
a273 1
	register struct tty *tp;
d276 1
a276 1
	register struct sl_softc *sc;
d333 1
a333 1
	register struct sl_softc *sc;
d395 1
a395 1
	register struct mbuf *m;
d399 2
a400 2
	register struct sl_softc *sc = ifp->if_softc;
	register struct ip *ip;
d461 1
a461 1
	register struct tty *tp;
d463 4
a466 4
	register struct sl_softc *sc = (struct sl_softc *)tp->t_sc;
	register struct mbuf *m;
	register u_char *cp;
	register struct ip *ip;
d471 1
a471 1
	register int len = 0;
d534 2
a535 2
			register struct mbuf *m1 = m;
			register u_char *cp = bpfbuf + SLIP_HDRLEN;
d539 1
a539 1
				register int mlen = m1->m_len;
d589 1
a589 1
			register u_char *ep;
d597 1
a597 1
				register u_char *bp = cp;
d666 2
a667 2
	register struct sl_softc *sc;
	register int len;
d706 2
a707 2
	register int c;
	register struct tty *tp;
d709 3
a711 3
	register struct sl_softc *sc;
	register struct mbuf *m;
	register int len;
d891 1
a891 1
	register struct ifnet *ifp;
d895 4
a898 4
	register struct sl_softc *sc = ifp->if_softc;
	register struct ifaddr *ifa = (struct ifaddr *)data;
	register struct ifreq *ifr;
	register int s = splimp(), error = 0;
@


1.21
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.20 2003/06/02 23:28:12 millert Exp $	*/
a176 2
struct sl_softc *sl_softc;
int nsl;
d186 6
d199 32
a230 24
	register struct sl_softc *sc;
	register int i = 0;
	
	sl_softc = malloc(n * sizeof(struct sl_softc), M_DEVBUF, M_NOWAIT);
	if (!sl_softc)
		return;
	nsl = n;
	bzero(sl_softc, n * sizeof(struct sl_softc));
	for (sc = sl_softc; i < nsl; sc++) {
		sc->sc_unit = i;		/* XXX */
		snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname,
		    "sl%d", i++);
		sc->sc_if.if_softc = sc;
		sc->sc_if.if_mtu = SLMTU;
		sc->sc_if.if_flags =
		    IFF_POINTOPOINT | SC_AUTOCOMP | IFF_MULTICAST;
		sc->sc_if.if_type = IFT_SLIP;
		sc->sc_if.if_ioctl = slioctl;
		sc->sc_if.if_output = sloutput;
		IFQ_SET_MAXLEN(&sc->sc_if.if_snd, 50);
		sc->sc_fastq.ifq_maxlen = 32;
		IFQ_SET_READY(&sc->sc_if.if_snd);
		if_attach(&sc->sc_if);
		if_alloc_sadl(&sc->sc_if);
d232 1
a232 1
		bpfattach(&sc->sc_bpf, &sc->sc_if, DLT_SLIP, SLIP_HDRLEN);
d234 5
a238 1
	}
d277 1
a277 1
	int i, error, s;
d285 1
a285 1
	for (i = nsl, sc = sl_softc; i--; sc++)
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.19 2003/05/03 21:15:11 deraadt Exp $	*/
d263 1
a263 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.19
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.18 2003/01/07 09:00:33 kjc Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.17 2002/09/11 05:38:47 itojun Exp $	*/
d209 2
a210 1
		sprintf(sc->sc_if.if_xname, "sl%d", i++);
@


1.17
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.16 2002/06/30 13:04:36 itojun Exp $	*/
a388 3
	ALTQ_DECL(struct altq_pktattr pktattr;)

	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);
d427 1
a427 1
	IFQ_ENQUEUE(&sc->sc_if.if_snd, m, &pktattr, error);
@


1.16
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.15 2002/03/14 01:27:09 millert Exp $	*/
d301 1
a301 1
					return(error);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.14 2001/06/27 06:07:43 kjc Exp $	*/
d221 1
@


1.14
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.13 2001/06/15 03:38:34 itojun Exp $	*/
d189 2
a190 2
static int slinit __P((struct sl_softc *));
static struct mbuf *sl_btom __P((struct sl_softc *, int));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.14 2001/06/27 06:07:43 kjc Exp $	*/
d189 2
a190 2
static int slinit(struct sl_softc *);
static struct mbuf *sl_btom(struct sl_softc *, int);
@


1.14.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.14.4.1 2002/06/11 03:30:45 art Exp $	*/
a220 1
		if_alloc_sadl(&sc->sc_if);
d300 1
a300 1
					return (error);
@


1.14.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d209 1
a209 2
		snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname,
		    "sl%d", i++);
d389 3
d430 1
a430 1
	IFQ_ENQUEUE(&sc->sc_if.if_snd, m, NULL, error);
@


1.13
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.12 2001/06/12 21:41:32 deraadt Exp $	*/
d217 1
a217 1
		sc->sc_if.if_snd.ifq_maxlen = 50;
d219 1
d387 4
a390 2
	register struct ifqueue *ifq;
	int s;
a412 1
	ifq = &sc->sc_if.if_snd;
a417 2
	if (ip->ip_tos & IPTOS_LOWDELAY)
		ifq = &sc->sc_fastq;
d429 2
a430 3
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
d433 1
a433 1
		return (ENOBUFS);
d435 1
a435 1
	IF_ENQUEUE(ifq, m);
d502 1
a502 1
			IF_DEQUEUE(&sc->sc_if.if_snd, m);
@


1.12
log
@one less setuid program (use an ioctl like pppstats)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.11 2001/05/17 18:41:46 provos Exp $	*/
d423 1
a423 1
		timersub(&time, &sc->sc_if.if_lastchange, &tv);
d437 1
a437 1
	sc->sc_if.if_lastchange = time;
d554 1
a554 1
		sc->sc_if.if_lastchange = time;
d845 1
a845 1
		sc->sc_if.if_lastchange = time;
@


1.11
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.10 2001/03/13 05:16:06 mickey Exp $	*/
d885 1
d889 1
d923 20
@


1.10
log
@allow configuring number of these in ukc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.9 1999/04/22 20:02:43 art Exp $	*/
a229 2
	register caddr_t p;

d231 4
a234 4
		MCLALLOC(p, M_WAIT);
		if (p)
			sc->sc_ep = (u_char *)p + SLBUFSIZE;
		else {
d240 5
a244 2
	sc->sc_buf = sc->sc_ep - SLMAX;
	sc->sc_mp = sc->sc_buf;
d246 1
a321 1
	s = splimp();		/* actually, max(spltty, splsoftnet) */
d325 2
d330 5
a334 5
		MCLFREE((caddr_t)(sc->sc_ep - SLBUFSIZE));
		sc->sc_ep = 0;
		sc->sc_mp = 0;
		sc->sc_buf = 0;
	}
d336 7
a342 4
	/* if necessary, install a new outq buffer of the appropriate size */
	if (sc->sc_oldbufsize != 0) {
		clfree(&tp->t_outq);
		clalloc(&tp->t_outq, sc->sc_oldbufsize, sc->sc_oldbufquot);
a343 2
#endif
	splx(s);
d659 1
a659 5
	register struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
d662 1
a662 5
	 * If we have more than MHLEN bytes, it's cheaper to
	 * queue the cluster we just filled & allocate a new one
	 * for the input buffer.  Otherwise, fill the mbuf we
	 * allocated above.  Note that code in the input routine
	 * guarantees that packet will fit in a cluster.
d664 20
a683 15
	if (len >= MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			/*
			 * we couldn't get a cluster - if memory's this
			 * low, it's time to start dropping packets.
			 */
			(void) m_free(m);
			return (NULL);
		}
		sc->sc_ep = mtod(m, u_char *) + SLBUFSIZE;
		m->m_data = (caddr_t)sc->sc_buf;
		m->m_ext.ext_buf = (caddr_t)((long)sc->sc_buf &~ MCLOFSET);
	} else
		bcopy((caddr_t)sc->sc_buf, mtod(m, caddr_t), len);
d767 1
a767 1
		len = sc->sc_mp - sc->sc_buf;
d782 1
a782 1
			bcopy(sc->sc_buf, chdr, CHDR_LEN);
d786 1
a786 1
		if ((c = (*sc->sc_buf & 0xf0)) != (IPVERSION << 4)) {
d790 1
a790 1
				*sc->sc_buf &= 0x4f; /* XXX */
d799 1
a799 1
				len = sl_uncompress_tcp(&sc->sc_buf, len,
d805 1
a805 1
				len = sl_uncompress_tcp(&sc->sc_buf, len,
d813 5
d822 3
a824 3
			 * We couldn't do this any earlier since
			 * decompression probably moved the buffer
			 * pointer.  Then, invoke BPF.
d826 5
a830 1
			register u_char *hp = sc->sc_buf - SLIP_HDRLEN;
d832 1
d834 7
a840 2
			bcopy(chdr, &hp[SLX_CHDR], CHDR_LEN);
			bpf_tap(sc->sc_bpf, hp, len + SLIP_HDRLEN);
a842 3
		m = sl_btom(sc, len);
		if (m == NULL)
			goto error;
d871 2
a872 1
	sc->sc_mp = sc->sc_buf = sc->sc_ep - SLMAX;
@


1.9
log
@we don't need to include buf.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.8 1997/09/05 04:27:01 millert Exp $	*/
a69 3
#include "sl.h"
#if NSL > 0

d181 2
a182 1
struct sl_softc sl_softc[NSL];
d196 2
a197 1
slattach()
d201 7
a207 2

	for (sc = sl_softc; i < NSL; sc++) {
d260 1
a260 3
	register int nsl;
	int error;
	int s;
d268 1
a268 1
	for (nsl = NSL, sc = sl_softc; --nsl >= 0; sc++)
a914 1
#endif
@


1.9.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.10 2001/03/13 05:16:06 mickey Exp $	*/
d70 3
d184 1
a184 2
struct sl_softc *sl_softc;
int nsl;
d198 1
a198 2
slattach(n)
	int n;
d202 2
a203 7
	
	sl_softc = malloc(n * sizeof(struct sl_softc), M_DEVBUF, M_NOWAIT);
	if (!sl_softc)
		return;
	nsl = n;
	bzero(sl_softc, n * sizeof(struct sl_softc));
	for (sc = sl_softc; i < nsl; sc++) {
d256 3
a258 1
	int i, error, s;
d266 1
a266 1
	for (i = nsl, sc = sl_softc; i--; sc++)
d913 1
@


1.9.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.9.4.1 2001/05/14 22:40:01 niklas Exp $	*/
d217 1
a217 1
		IFQ_SET_MAXLEN(&sc->sc_if.if_snd, 50);
a218 1
		IFQ_SET_READY(&sc->sc_if.if_snd);
d230 2
d233 4
a236 4
		MGETHDR(sc->sc_mbuf, M_WAIT, MT_DATA);
		if (sc->sc_mbuf)
			MCLGET(sc->sc_mbuf, M_WAIT);
		if (sc->sc_mbuf == NULL || sc->sc_mbuf->m_ext.ext_buf == NULL) {
d242 2
a243 5
	sc->sc_ep = (u_char *) sc->sc_mbuf->m_ext.ext_buf +
	    sc->sc_mbuf->m_ext.ext_size;
	sc->sc_mp = sc->sc_pktstart = (u_char *) sc->sc_mbuf->m_ext.ext_buf +
	    BUFOFFSET;

a244 1

d320 1
a323 2
		s = splimp();		/* actually, max(spltty, splsoftnet) */

d327 5
a331 5

		m_freem(sc->sc_mbuf);
		sc->sc_mbuf = NULL;
		sc->sc_ep = sc->sc_mp = sc->sc_pktstart = NULL;

d333 5
a337 5
		/* if necessary, install a new outq buffer of the appropriate size */
		if (sc->sc_oldbufsize != 0) {
			clfree(&tp->t_outq);
			clalloc(&tp->t_outq, sc->sc_oldbufsize, sc->sc_oldbufquot);
		}
d339 1
a339 2
		splx(s);
	}
d382 2
a383 4
	int s, error;
	ALTQ_DECL(struct altq_pktattr pktattr;)

	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);
d406 1
d412 2
d419 1
a419 1
		timersub(&time, &sc->sc_lastpacket, &tv);
d425 3
a427 2
	IFQ_ENQUEUE(&sc->sc_if.if_snd, m, &pktattr, error);
	if (error) {
d430 1
a430 1
		return (error);
d432 2
a433 2

	sc->sc_lastpacket = time;
d499 1
a499 1
			IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
d550 1
a550 1
		sc->sc_lastpacket = time;
d655 5
a659 1
	struct mbuf *m;
d662 5
a666 1
	 * Allocate a new input buffer and swap.
d668 15
a682 20
	m = sc->sc_mbuf;
	MGETHDR(sc->sc_mbuf, M_DONTWAIT, MT_DATA);
	if (sc->sc_mbuf == NULL) {
		sc->sc_mbuf = m;
		return (NULL);
	}
	MCLGET(sc->sc_mbuf, M_DONTWAIT);
	if ((sc->sc_mbuf->m_flags & M_EXT) == 0) {
		/*
		 * we couldn't get a cluster - if memory's this
		 * low, it's time to start dropping packets.
		 */
		m_freem(sc->sc_mbuf);
		sc->sc_mbuf = m;
		return (NULL);
	}
	sc->sc_ep = (u_char *) sc->sc_mbuf->m_ext.ext_buf +
		sc->sc_mbuf->m_ext.ext_size;
	
	m->m_data = sc->sc_pktstart;
d766 1
a766 1
		len = sc->sc_mp - sc->sc_pktstart;
d781 1
a781 1
			bcopy(sc->sc_pktstart, chdr, CHDR_LEN);
d785 1
a785 1
		if ((c = (*sc->sc_pktstart & 0xf0)) != (IPVERSION << 4)) {
d789 1
a789 1
				*sc->sc_pktstart &= 0x4f; /* XXX */
d798 1
a798 1
				len = sl_uncompress_tcp(&sc->sc_pktstart, len,
d804 1
a804 1
				len = sl_uncompress_tcp(&sc->sc_pktstart, len,
a811 5

		m = sl_btom(sc, len);
		if (m == NULL)
			goto error;

d816 3
a818 3
			 * Note this M_PREPEND() should bever fail,
			 * since we know we always have enough space
			 * in the input buffer.
d820 1
a820 1
			u_char *hp;
a821 5
			M_PREPEND(m, SLIP_HDRLEN, M_DONTWAIT);
			if (m == NULL)
				goto error;

			hp = mtod(m, u_char *);
d823 2
a824 7
			memcpy(&hp[SLX_CHDR], chdr, CHDR_LEN);

			s = splnet();
			bpf_mtap(sc->sc_bpf, m);
			splx(s);

			m_adj(m, SLIP_HDRLEN);
d827 3
d832 1
a832 1
		sc->sc_lastpacket = time;
d858 1
a858 2
	sc->sc_mp = sc->sc_pktstart = (u_char *) sc->sc_mbuf->m_ext.ext_buf +
	    BUFOFFSET;
a870 1
	register struct sl_softc *sc = ifp->if_softc;
a873 1
	struct sl_stats *slsp;
a906 20
		break;

	case SIOCGSLSTATS:
		slsp = &((struct ifslstatsreq *) data)->stats;
		bzero(slsp, sizeof(*slsp));
		/* slsp->sl = sc->sc_stats; */
		slsp->sl.sl_ibytes = sc->sc_if.if_ibytes;
		slsp->sl.sl_obytes = sc->sc_if.if_obytes;
		slsp->sl.sl_ipackets = sc->sc_if.if_ipackets;
		slsp->sl.sl_opackets = sc->sc_if.if_opackets;
#ifdef INET
		slsp->vj.vjs_packets = sc->sc_comp.sls_packets;
		slsp->vj.vjs_compressed = sc->sc_comp.sls_compressed;
		slsp->vj.vjs_searches = sc->sc_comp.sls_searches;
		slsp->vj.vjs_misses = sc->sc_comp.sls_misses;
		slsp->vj.vjs_uncompressedin = sc->sc_comp.sls_uncompressedin;
		slsp->vj.vjs_compressedin = sc->sc_comp.sls_compressedin;
		slsp->vj.vjs_errorin = sc->sc_comp.sls_errorin;
		slsp->vj.vjs_tossed = sc->sc_comp.sls_tossed;
#endif /* INET */
@


1.9.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d189 2
a190 2
static int slinit(struct sl_softc *);
static struct mbuf *sl_btom(struct sl_softc *, int);
@


1.9.4.4
log
@Sync the SMP branch with 3.3
@
text
@a220 1
		if_alloc_sadl(&sc->sc_if);
d300 1
a300 1
					return (error);
d388 3
d429 1
a429 1
	IFQ_ENQUEUE(&sc->sc_if.if_snd, m, NULL, error);
@


1.9.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.9.4.4 2003/03/28 00:41:28 niklas Exp $	*/
d209 1
a209 2
		snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname,
		    "sl%d", i++);
@


1.9.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.9.4.5 2003/05/13 19:36:15 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 1
a95 1
#error Huh? Slip without inet?
d158 1
a158 1
#error Huh?  SLMTU way too small.
d177 2
a187 7
int	sl_clone_create(struct if_clone *, int);
int	sl_clone_destroy(struct ifnet *);

LIST_HEAD(, sl_softc) sl_softc_list;
struct if_clone sl_cloner =
    IF_CLONE_INITIALIZER("sl", sl_clone_create, sl_clone_destroy);

d195 24
a218 32
	LIST_INIT(&sl_softc_list);
	if_clone_attach(&sl_cloner);
}

int
sl_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
{
	struct sl_softc *sc;
	int s;

	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
	if (!sc)
		return (ENOMEM);
	bzero(sc, sizeof(*sc));

	sc->sc_unit = unit;	/* XXX */
	snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "%s%d",
	    ifc->ifc_name, unit);
	sc->sc_if.if_softc = sc;
	sc->sc_if.if_mtu = SLMTU;
	sc->sc_if.if_flags =
	    IFF_POINTOPOINT | SC_AUTOCOMP | IFF_MULTICAST;
	sc->sc_if.if_type = IFT_SLIP;
	sc->sc_if.if_ioctl = slioctl;
	sc->sc_if.if_output = sloutput;
	IFQ_SET_MAXLEN(&sc->sc_if.if_snd, 50);
	sc->sc_fastq.ifq_maxlen = 32;
	IFQ_SET_READY(&sc->sc_if.if_snd);
	if_attach(&sc->sc_if);
	if_alloc_sadl(&sc->sc_if);
d220 1
a220 1
	bpfattach(&sc->sc_bpf, &sc->sc_if, DLT_SLIP, SLIP_HDRLEN);
d222 1
a222 28
	s = splimp();
	LIST_INSERT_HEAD(&sl_softc_list, sc, sc_list);
	splx(s);

	return (0);
}

int
sl_clone_destroy(ifp)
	struct ifnet *ifp;
{
	struct sl_softc *sc = ifp->if_softc;
	int s;

	if (sc->sc_ttyp != NULL)
		return (EBUSY);

	s = splimp();
	LIST_REMOVE(sc, sc_list);
	splx(s);

#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
	if_detach(ifp);

	free(sc, M_DEVBUF);
	return (0);
d227 1
a227 1
	struct sl_softc *sc;
d257 1
a257 1
	struct tty *tp;
d260 2
a261 2
	struct sl_softc *sc;
	int error, s;
d263 1
a263 1
	if ((error = suser(p, 0)) != 0)
d269 1
a269 1
	LIST_FOREACH(sc, &sl_softc_list, sc_list)
d317 1
a317 1
	struct sl_softc *sc;
d379 1
a379 1
	struct mbuf *m;
d383 2
a384 2
	struct sl_softc *sc = ifp->if_softc;
	struct ip *ip;
d445 1
a445 1
	struct tty *tp;
d447 4
a450 4
	struct sl_softc *sc = (struct sl_softc *)tp->t_sc;
	struct mbuf *m;
	u_char *cp;
	struct ip *ip;
d455 1
a455 1
	int len = 0;
d518 2
a519 2
			struct mbuf *m1 = m;
			u_char *cp = bpfbuf + SLIP_HDRLEN;
d523 1
a523 1
				int mlen = m1->m_len;
d573 1
a573 1
			u_char *ep;
d581 1
a581 1
				u_char *bp = cp;
d650 2
a651 2
	struct sl_softc *sc;
	int len;
d690 2
a691 2
	int c;
	struct tty *tp;
d693 3
a695 3
	struct sl_softc *sc;
	struct mbuf *m;
	int len;
d875 1
a875 1
	struct ifnet *ifp;
d879 4
a882 4
	struct sl_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr;
	int s = splimp(), error = 0;
@


1.9.4.8
log
@Merge with the trunk
@
text
@a885 2
			if (!ipintrq.ifq_congestion)
				if_congestion(&ipintrq);
@


1.8
log
@Minor changes from ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.7 1996/08/22 00:35:52 deraadt Exp $	*/
a77 1
#include <sys/buf.h>
@


1.7
log
@__OpenBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.6 1996/08/09 09:59:19 niklas Exp $	*/
d241 1
a241 1
	sl_compress_init(&sc->sc_comp, -1);
@


1.6
log
@Silly unit number calculation changed to use sc_unit instead
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.5 1996/06/10 07:28:25 deraadt Exp $	*/
d86 1
a86 1
#if __NetBSD__
d169 1
a169 1
#ifndef NetBSD						/* XXX - cgd */
d278 1
a278 1
#ifdef NetBSD
d331 1
a331 1
#ifdef NetBSD
d458 1
a458 1
#ifndef NetBSD						/* XXX - cgd */
d479 1
a479 1
#ifdef NetBSD						/* XXX - cgd */
d551 1
a551 1
#ifndef __NetBSD__					/* XXX - cgd */
d598 1
a598 1
#ifdef __NetBSD__					/* XXX - cgd */
@


1.5
log
@init sc_unit properly
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sl.c,v 1.4 1996/05/10 12:31:11 deraadt Exp $	*/
d234 1
a234 1
			printf("sl%d: can't allocate buffer\n", sc - sl_softc);
@


1.4
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 2
a2 2
/*	$OpenBSD: if_sl.c,v 1.2 1996/03/03 21:07:10 niklas Exp $	*/
/*	$NetBSD: if_sl.c,v 1.39 1996/05/07 02:40:43 thorpej Exp $	*/
d205 1
a207 1
		sc->sc_unit = i;		/* XXX */
@


1.3
log
@From Lite2; mark terminal devices as exclusively opened before flushing
@
text
@d2 1
a2 1
/*	$NetBSD: if_sl.c,v 1.38 1996/02/13 22:00:23 christos Exp $	*/
d205 3
a207 2
		sc->sc_if.if_name = "sl";
		sc->sc_if.if_unit = i++;
d357 1
a357 1
		*(int *)data = sc->sc_if.if_unit;
d379 1
a379 1
	register struct sl_softc *sc = &sl_softc[ifp->if_unit];
d389 1
a389 1
		printf("sl%d: af%d not supported\n", sc->sc_if.if_unit,
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a257 1
#ifdef NetBSD
a258 1
#endif
d273 3
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: if_sl.c,v 1.37 1995/08/12 23:59:22 mycroft Exp $	*/
d86 3
d262 1
a262 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d454 1
a454 1
	register int len;
d527 1
a527 1
			} while (m1 = m1->m_next);
d549 1
a549 1
#ifndef NetBSD						/* XXX - cgd */
d560 1
a560 1
#endif /* !NetBSD */
d596 1
a596 1
#ifdef NetBSD						/* XXX - cgd */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
