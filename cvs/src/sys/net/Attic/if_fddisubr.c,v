head	1.65;
access;
symbols
	OPENBSD_5_4:1.61.0.2
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.60.0.10
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.60.0.8
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.6
	OPENBSD_5_0:1.60.0.4
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.59.0.2
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.57.0.2
	OPENBSD_4_7_BASE:1.57
	OPENBSD_4_6:1.55.0.4
	OPENBSD_4_6_BASE:1.55
	OPENBSD_4_5:1.54.0.4
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.54.0.2
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.53.0.2
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.40.0.2
	OPENBSD_3_6_BASE:1.40
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.28.0.4
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.29
	UBC:1.28.0.2
	UBC_BASE:1.28
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.8
	OPENBSD_2_8:1.22.0.6
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.22.0.4
	OPENBSD_2_7_BASE:1.22
	SMP:1.22.0.2
	SMP_BASE:1.22
	kame_19991208:1.20
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.65
date	2013.10.28.12.33.32;	author mpi;	state dead;
branches;
next	1.64;

1.64
date	2013.10.23.19.24.59;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.10.17.16.27.40;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2010.08.24.14.43.56;	author blambert;	state Exp;
branches;
next	1.59;

1.59
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.57;

1.57
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2009.07.08.15.01.50;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.05.00.05.21;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2008.05.07.13.45.35;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.13.14.21.01;	author fgsch;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.06.10.04.36;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.29.20.31.38;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.07.18.15.29;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.16.16.49.39;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.17.08.43.35;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.08.06.55.33;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2005.06.07.02.45.11;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2005.01.18.23.26.52;	author mpf;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.19.03.25.36;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.10.22.35.17;	author mcbride;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.09.16.57.35;	author mcbride;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.16.15.01.08;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.08.15.01.05;	author mcbride;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.17.00.09.01;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.25.19.31.05;	author mcbride;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.17.21.04.58;	author mcbride;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.18.11.01.41;	author dhartmei;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.14.20.40.52;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.18.23.07.49;	author deraadt;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.12.10.06.10.53;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.30.07.59.17;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.27.06.07.40;	author kjc;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.15.03.38.33;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.28.19.51.06;	author dugsong;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.07.06.09.08;	author itojun;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.01.11.19.27.53;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	99.07.28.20.02.41;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	99.01.08.00.56.45;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.07.08.22.22.51;	author ryker;	state Exp;
branches;
next	1.16;

1.16
date	98.07.07.14.52.38;	author ryker;	state Exp;
branches;
next	1.15;

1.15
date	98.06.30.21.51.06;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	97.09.27.02.35.58;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.07.27.05.28.35;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.07.24.22.59.31;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.02.24.13.33.59;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.01.02.20.45.51;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.10.16.22.58.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.10.16.12.48.41;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.22.00.35.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.22.11.48.24;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.10.12.31.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.29.01.13.02;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.14.37.04;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.36.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches;
next	;

1.22.2.1
date	2001.07.04.10.54.00;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.28.2.1
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.65
log
@tedu FDDI support and the 3 flavors the driver for DEC devices, even
miod@@ cannot find two boards using the same media.

With precious punctuation review from guenther@@, thanks!

ok deraadt@@, henning@@
@
text
@/*	$OpenBSD: if_fddisubr.c,v 1.64 2013/10/23 19:24:59 deraadt Exp $	*/
/*	$NetBSD: if_fddisubr.c,v 1.5 1996/05/07 23:20:21 christos Exp $	*/

/*
 * Copyright (c) 1995
 *	Matt Thomas.  All rights reserved.
 * Copyright (c) 1982, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_fddisubr.c	8.1 (Berkeley) 6/10/93
 */

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) January 1997
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>


#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/if_llc.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#endif
#include <netinet/if_ether.h>
#include <net/if_fddi.h>

#ifdef INET6
#ifndef INET
#include <netinet/in.h>
#endif
#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>
#endif

#include "bpfilter.h"

#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

#define senderr(e) { error = (e); goto bad;}

/*
 * This really should be defined in if_llc.h but in case it isn't.
 */
#ifndef llc_snap
#define	llc_snap	llc_un.type_snap
#endif

/*
 * FDDI output routine.
 * Encapsulate a packet of type family for the local net.
 * Assumes that ifp is actually pointer to arpcom structure.
 */
int
fddi_output(ifp0, m0, dst, rt0)
	struct ifnet *ifp0;
	struct mbuf *m0;
	struct sockaddr *dst;
	struct rtentry *rt0;
{
	u_int16_t type;
	int s, len, error = 0, hdrcmplt = 0;
 	u_char edst[6], esrc[6];
	struct mbuf *m = m0;
	struct rtentry *rt;
	struct mbuf *mcopy = (struct mbuf *)0;
	struct fddi_header *fh;
	struct arpcom *ac = (struct arpcom *)ifp0;
	short mflags;
	struct ifnet *ifp = ifp0;

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain),
		    dst->sa_family);
	}
#endif

#if NCARP > 0
	if (ifp->if_type == IFT_CARP) {
		struct ifaddr *ifa;

		/* loop back if this is going to the carp interface */
		if (dst != NULL && LINK_STATE_IS_UP(ifp0->if_link_state) &&
		    (ifa = ifa_ifwithaddr(dst, ifp->if_rdomain)) != NULL &&
		    ifa->ifa_ifp == ifp0)
			return (looutput(ifp0, m, dst, rt0));

		ifp = ifp->if_carpdev;
		ac = (struct arpcom *)ifp;

		if ((ifp0->if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			senderr(ENETDOWN);
	}
#endif /* NCARP > 0 */
	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		senderr(ENETDOWN);
	if ((rt = rt0) != NULL) {
		if ((rt->rt_flags & RTF_UP) == 0) {
			if ((rt0 = rt = rtalloc1(dst, RT_REPORT,
			    m->m_pkthdr.rdomain)) != NULL)
				rt->rt_refcnt--;
			else 
				senderr(EHOSTUNREACH);
		}
		if (rt->rt_flags & RTF_GATEWAY) {
			if (rt->rt_gwroute == 0)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt);
				rt = rt0;
			lookup:
				rt->rt_gwroute = rtalloc1(rt->rt_gateway,
				    RT_REPORT, ifp->if_rdomain);
				if ((rt = rt->rt_gwroute) == NULL)
					senderr(EHOSTUNREACH);
			}
		}
		if (rt->rt_flags & RTF_REJECT)
			if (rt->rt_rmx.rmx_expire == 0 ||
			    time_second < rt->rt_rmx.rmx_expire)
				senderr(rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
	}

	switch (dst->sa_family) {

#ifdef INET
	case AF_INET:
		if (!arpresolve(ac, rt, m, dst, edst))
			return (0);	/* if not yet resolved */
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    !m->m_pkthdr.pf.routed)
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		type = htons(ETHERTYPE_IP);
		break;
#endif
#ifdef INET6
	case AF_INET6:
		if (!nd6_storelladdr(ifp, rt, m, dst, (u_char *)edst))
			return (0);	/* if not yet resolved */
		type = htons(ETHERTYPE_IPV6);
		break;
#endif
	case pseudo_AF_HDRCMPLT:
		fh = (struct fddi_header *)dst->sa_data;
		hdrcmplt = 1;
		bcopy((caddr_t)fh->fddi_shost, (caddr_t)esrc, sizeof (esrc));
		/* FALLTHROUGH */

	case AF_UNSPEC:
	{
		struct ether_header *eh;
		eh = (struct ether_header *)dst->sa_data;
 		bcopy((caddr_t)eh->ether_dhost, (caddr_t)edst, sizeof (edst));
		if (*edst & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		type = eh->ether_type;
		break;
	}

#if NBPFILTER > 0
	case AF_IMPLINK:
	{
		fh = mtod(m, struct fddi_header *);
		error = EPROTONOSUPPORT;
		switch (fh->fddi_fc & (FDDIFC_C|FDDIFC_L|FDDIFC_F)) {
			case FDDIFC_LLC_ASYNC: {
				/* legal priorities are 0 through 7 */
				if ((fh->fddi_fc & FDDIFC_Z) > 7)
			        	goto bad;
				break;
			}
			case FDDIFC_LLC_SYNC: {
				/* FDDIFC_Z bits reserved, must be zero */
				if (fh->fddi_fc & FDDIFC_Z)
					goto bad;
				break;
			}
			case FDDIFC_SMT: {
				/* FDDIFC_Z bits must be non zero */
				if ((fh->fddi_fc & FDDIFC_Z) == 0)
					goto bad;
				break;
			}
			default: {
				/* anything else is too dangerous */
               	 		goto bad;
			}
		}
		error = 0;
		if (fh->fddi_dhost[0] & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		goto queue_it;
	}
#endif
	default:
		printf("%s: can't handle af%d\n", ifp->if_xname,
			dst->sa_family);
		senderr(EAFNOSUPPORT);
	}

	if (mcopy)
		(void) looutput(ifp, mcopy, dst, rt);

	if (type != 0) {
		struct llc *l;
		M_PREPEND(m, sizeof (struct llc), M_DONTWAIT);
		if (m == 0)
			senderr(ENOBUFS);
		l = mtod(m, struct llc *);
		l->llc_control = LLC_UI;
		l->llc_dsap = l->llc_ssap = LLC_SNAP_LSAP;
		l->llc_snap.org_code[0] = l->llc_snap.org_code[1] = l->llc_snap.org_code[2] = 0;
		bcopy((caddr_t) &type, (caddr_t) &l->llc_snap.ether_type,
			sizeof(u_short));
	}
	/*
	 * Add local net header.  If no space in first mbuf,
	 * allocate another.
	 */
	M_PREPEND(m, sizeof (struct fddi_header), M_DONTWAIT);
	if (m == 0)
		senderr(ENOBUFS);
	fh = mtod(m, struct fddi_header *);
	fh->fddi_fc = FDDIFC_LLC_ASYNC|FDDIFC_LLC_PRIO4;
 	bcopy((caddr_t)edst, (caddr_t)fh->fddi_dhost, sizeof (edst));
#if NBPFILTER > 0
  queue_it:
#endif
	if (hdrcmplt)
		bcopy((caddr_t)esrc, (caddr_t)fh->fddi_shost,
		    sizeof(fh->fddi_shost));
	else
 		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)fh->fddi_shost,
		    sizeof(fh->fddi_shost));
#if NCARP > 0
	if (ifp0 != ifp && ifp0->if_type == IFT_CARP) {
		bcopy((caddr_t)((struct arpcom *)ifp0)->ac_enaddr,
		    (caddr_t)fh->fddi_shost, sizeof(fh->fddi_shost));
	}
#endif
	mflags = m->m_flags;
	len = m->m_pkthdr.len;
	s = splnet();
	/*
	 * Queue message on interface, and start output if interface
	 * not yet active.
	 */
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		/* mbuf is already freed */
		splx(s);
		return (error);
	}
	ifp->if_obytes += len;
#if NCARP > 0
	if (ifp != ifp0)
		ifp0->if_obytes += len;
#endif /* NCARP > 0 */
	if (mflags & M_MCAST)
		ifp->if_omcasts++;
	if_start(ifp);
	splx(s);
	return (error);

bad:
	if (m)
		m_freem(m);
	return (error);
}

/*
 * Process a received FDDI packet;
 * the packet is in the mbuf chain m without
 * the fddi header, which is provided separately.
 */
void
fddi_input(ifp, fh, m)
	struct ifnet *ifp;
	struct fddi_header *fh;
	struct mbuf *m;
{
	struct ifqueue *inq;
	struct llc *l;
	int s;

	if ((ifp->if_flags & IFF_UP) == 0) {
		m_freem(m);
		return;
	}
	/* mark incoming routing domain */
	m->m_pkthdr.rdomain = ifp->if_rdomain;

	ifp->if_ibytes += m->m_pkthdr.len + sizeof (*fh);
	if (bcmp((caddr_t)fddibroadcastaddr, (caddr_t)fh->fddi_dhost,
	    sizeof(fddibroadcastaddr)) == 0)
		m->m_flags |= M_BCAST;
	else if (fh->fddi_dhost[0] & 1)
		m->m_flags |= M_MCAST;
	if (m->m_flags & (M_BCAST|M_MCAST))
		ifp->if_imcasts++;

	l = mtod(m, struct llc *);
	switch (l->llc_dsap) {
#if defined(INET) || defined(INET6)
	case LLC_SNAP_LSAP:
	{
		u_int16_t etype;
		if (l->llc_control != LLC_UI || l->llc_ssap != LLC_SNAP_LSAP)
			goto dropanyway;
		if (l->llc_snap.org_code[0] != 0 || l->llc_snap.org_code[1] != 0|| l->llc_snap.org_code[2] != 0)
			goto dropanyway;
		etype = ntohs(l->llc_snap.ether_type);
		m_adj(m, LLC_SNAPFRAMELEN);

#if NCARP > 0
		if (ifp->if_carp && ifp->if_type != IFT_CARP &&
		    (carp_input(m, (u_int8_t *)&fh->fddi_shost,
		    (u_int8_t *)&fh->fddi_dhost, l->llc_snap.ether_type) == 0))
			return;
#endif

		switch (etype) {
#ifdef INET
		case ETHERTYPE_IP:
			schednetisr(NETISR_IP);
			inq = &ipintrq;
			break;

		case ETHERTYPE_ARP:
			if (ifp->if_flags & IFF_NOARP)
				goto dropanyway;
			schednetisr(NETISR_ARP);
			inq = &arpintrq;
			break;
#endif
#ifdef INET6
		case ETHERTYPE_IPV6:
			schednetisr(NETISR_IPV6);
			inq = &ip6intrq;
			break;
#endif /* INET6 */
		default:
			/* printf("fddi_input: unknown protocol 0x%x\n", etype); */
			ifp->if_noproto++;
			goto dropanyway;
		}
		break;
	}
#endif /* INET || INET6 */
		
	default:
		/* printf("fddi_input: unknown dsap 0x%x\n", l->llc_dsap); */
		ifp->if_noproto++;
	dropanyway:
		m_freem(m);
		return;
	}

	s = splnet();
	IF_INPUT_ENQUEUE(inq, m);
	splx(s);
}
/*
 * Perform common duties while attaching to interface list
 */
void
fddi_ifattach(ifp)
	struct ifnet *ifp;
{

	ifp->if_type = IFT_FDDI;
	ifp->if_addrlen = 6;
	ifp->if_hdrlen = 21;
	ifp->if_mtu = FDDIMTU;
	ifp->if_output = fddi_output;
	if_alloc_sadl(ifp);
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	      LLADDR(ifp->if_sadl), ifp->if_addrlen);
}
@


1.64
log
@delete junk NRL v6 block; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.63 2013/10/23 15:12:42 mpi Exp $	*/
@


1.63
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.62 2013/10/17 16:27:40 bluhm Exp $	*/
a224 25
#if 0	/*NRL IPv6*/
#ifdef INET6
	case AF_INET6:
		/*
		 * The bottom line here is to either queue the outgoing packet
		 * in the discovery engine, or fill in edst with something
		 * that'll work.
		 */
		if (m->m_flags & M_MCAST) {
			/*
			 * If multicast dest., then use IPv6 -> Ethernet mcast
			 * mapping.  Really simple.
			 */
			ETHER_MAP_IN6_MULTICAST(((struct sockaddr_in6 *)dst)->sin6_addr,
			    edst);
		} else {
			/* Do unicast neighbor discovery stuff. */
			if (!ipv6_discov_resolve(ifp, rt, m, dst, edst))
 				return 0;
		}
		type = htons(ETHERTYPE_IPV6);
		break;
#endif /* INET6 */
#endif

@


1.62
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.61 2013/03/28 16:55:27 deraadt Exp $	*/
a97 1
#include <netinet/in_var.h>
@


1.61
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.60 2010/08/24 14:43:56 blambert Exp $	*/
a105 1
#include <netinet/in_var.h>
d107 1
@


1.60
log
@legibility fixes:

1) one statement per line
2) label gets its own line, and doesn't share it with a statement

no functional change

"Let the turd shine." claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.59 2010/05/07 13:33:16 claudio Exp $	*/
a87 1
#include <machine/cpu.h>
@


1.59
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.58 2010/05/01 08:14:26 mk Exp $	*/
d192 6
a197 4
				rtfree(rt); rt = rt0;
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway,
			    RT_REPORT, ifp->if_rdomain);
				if ((rt = rt->rt_gwroute) == 0)
@


1.58
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.57 2009/11/03 10:59:04 claudio Exp $	*/
d182 2
a183 1
			if ((rt0 = rt = rtalloc1(dst, 1, 0)) != NULL)
d193 2
a194 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1, 0);
@


1.57
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.56 2009/07/08 15:01:50 claudio Exp $	*/
d395 1
a395 1
	/* mark incomming routing domain */
@


1.56
log
@Add the same routing domain assignments and checks into the not so used
protocols as it is currently in if_ethersubr.c. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.55 2009/06/05 00:05:21 claudio Exp $	*/
d152 1
a152 1
	if (ifp->if_rdomain != m->m_pkthdr.rdomain) {
d154 3
a156 3
		    "%d vs. %d, AF %d\n", ifp->if_xname, ifp->if_rdomain,
		    m->m_pkthdr.rdomain, dst->sa_family);
		senderr(ENETDOWN);
@


1.55
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.54 2008/05/07 13:45:35 dlg Exp $	*/
d151 9
d395 3
@


1.54
log
@enable tx mitigation when putting packets on the wire by switching from
calls to ifp->if_start to if_start(). these are the obviously right cases
where we can do that, the less obvious ones may follow as theyre figured
out.

deraadt@@ said to go for it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.52 2007/06/06 10:04:36 henning Exp $	*/
d157 1
a157 1
		    (ifa = ifa_ifwithaddr(dst)) != NULL &&
@


1.53
log
@remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d357 1
a357 2
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
@


1.52
log
@remove remaining IPX hooks. all inside #ifdef IPX, so no actual change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.51 2007/05/29 20:31:38 henning Exp $	*/
d240 1
a240 2
	{
		struct fddi_header *fh = (struct fddi_header *)dst->sa_data;
a243 1
	}
@


1.51
log
@now i get my hands dirty in here... from if_ethersubr.c:
there was code inside
#if NPF > 0
to prevent feeding back the mbuf do looutput if we are on simplex
interfaces and the packet has been routed by pf, which can lead to a loop
in weird corner cases.
apparently nobody triggered these cases in ages, since pf.h was not included
and thus NPF not defined and thus this code not compiled.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.50 2006/12/07 18:15:29 reyk Exp $	*/
a103 5
#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

a237 10
#ifdef IPX
	case AF_IPX:
		type = htons(ETHERTYPE_IPX);
 		bcopy((caddr_t)&(((struct sockaddr_ipx*)dst)->sipx_addr.ipx_host),
		    (caddr_t)edst, sizeof (edst));
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		break;
#endif
d400 1
a400 1
#if defined(INET) || defined(IPX) || defined(INET6)
a437 6
#ifdef IPX
		case ETHERTYPE_IPX:
			schednetisr(NETISR_IPX);
			inq = &ipxintrq;
			break;
#endif
d445 1
a445 1
#endif /* INET || IPX || INET6 */
@


1.50
log
@use LINK_STATE_IS_UP(ifp0->if_link_state) instead of
ifp0->if_link_state == LINK_STATE_UP to handle the new half/full
duplex link states. i forgot to commit these snippets before.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.49 2006/06/16 16:49:39 henning Exp $	*/
d206 2
a207 6
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX)) {
#if NPF > 0
			struct pf_mtag	*t;

			if ((t = pf_find_mtag(m)) == NULL || !t->routed)
#endif
a208 1
		}
@


1.49
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.48 2006/03/04 22:40:15 brad Exp $	*/
d161 1
a161 1
		if (dst != NULL && ifp0->if_link_state == LINK_STATE_UP &&
@


1.48
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.47 2005/10/17 08:43:35 henning Exp $	*/
d178 1
a178 1
			if ((rt0 = rt = rtalloc1(dst, 1)) != NULL)
d188 1
a188 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
@


1.47
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.46 2005/06/08 06:55:33 henning Exp $	*/
d361 1
a361 1
	s = splimp();
d481 1
a481 1
	s = splimp();
@


1.46
log
@bye bye netns (and a few leftover DECNET bits while here)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.45 2005/06/07 02:45:11 henning Exp $	*/
d206 6
a211 2
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    m_tag_find(m, PACKET_TAG_PF_ROUTED, NULL) == NULL)
d213 1
@


1.45
log
@do not handle CCITT any longer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.44 2005/01/18 23:26:52 mpf Exp $	*/
a116 9
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#ifdef DECNET
#include <netdnet/dn.h>
#endif

a252 12
#ifdef NS
	case AF_NS:
		type = htons(ETHERTYPE_NS);
 		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
		    (caddr_t)edst, sizeof (edst));
		if (!bcmp((caddr_t)edst, (caddr_t)&ns_thishost, sizeof(edst)))
			return (looutput(ifp, m, dst, rt));
		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		break;
#endif
d415 1
a415 1
#if defined(INET) || defined(IPX) || defined(NS) || defined(DECNET) || defined(INET6)
a458 12
#ifdef NS
		case ETHERTYPE_NS:
			schednetisr(NETISR_NS);
			inq = &nsintrq;
			break;
#endif
#ifdef DECNET
		case ETHERTYPE_DECNET:
			schednetisr(NETISR_DECNET);
			inq = &decnetintrq;
			break;
#endif
d466 1
a466 1
#endif /* INET || IPX || NS || DECNET */
@


1.44
log
@Rewriting the lladdr can now be done without using mbuf tags.
Advertisements run through the carp interface first.
So we just take the address from ifp0.
While we're there,
also remove carp_macmatch6, which isn't used anymore.

Proposed by mcbride@@
ok mcbride@@, pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.43 2004/12/19 03:25:36 mcbride Exp $	*/
a127 7
#include <netccitt/dll.h>
#include <netccitt/llc_var.h>

#if defined(CCITT)
extern struct ifqueue pkintrq;
#endif

a273 40
#ifdef	CCITT
/*	case AF_NSAP: */
	case AF_CCITT: {
		struct sockaddr_dl *sdl = 
			(struct sockaddr_dl *) rt->rt_gateway;

		if (sdl && sdl->sdl_family == AF_LINK
		    && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (char *)edst,
				sizeof(edst));
		} else goto bad; /* Not a link interface ? Funny ... */
		if ((ifp->if_flags & IFF_SIMPLEX) && (*edst & 1) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*fh), M_DONTWAIT);
			if (mcopy) {
				fh = mtod(mcopy, struct fddi_header *);
				bcopy((caddr_t)edst,
				      (caddr_t)fh->fddi_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)fh->fddi_shost, sizeof (edst));
				fh->fddi_fc = FDDIFC_LLC_ASYNC|FDDIFC_LLC_PRIO4;
			}
		}
		type = 0;
#ifdef LLC_DEBUG
		{
			int i;
			struct llc *l = mtod(m, struct llc *);

			printf("fddi_output: sending LLC2 pkt to: ");
			for (i=0; i<6; i++)
				printf("%x ", edst[i] & 0xff);
			printf(" len 0x%x dsap 0x%x ssap 0x%x control 0x%x\n", 
			    m->m_pkthdr.len, l->llc_dsap & 0xff, l->llc_ssap &0xff,
			    l->llc_control & 0xff);

		}
#endif /* LLC_DEBUG */
		} break;
#endif /* CCITT */	
a499 19
#ifdef CCITT
	case LLC_X25_LSAP:
	{
		M_PREPEND(m, sizeof(struct sdl_hdr) , M_DONTWAIT);
		if (m == 0)
			return;
		if ( !sdl_sethdrif(ifp, fh->fddi_shost, LLC_X25_LSAP,
				    fh->fddi_dhost, LLC_X25_LSAP, 6, 
				    mtod(m, struct sdl_hdr *)))
			panic("ETHER cons addr failure");
		mtod(m, struct sdl_hdr *)->sdlhdr_len = m->m_pkthdr.len - sizeof(struct sdl_hdr);
#ifdef LLC_DEBUG
		printf("llc packet\n");
#endif /* LLC_DEBUG */
		schednetisr(NETISR_CCITT);
		inq = &llcintrq;
		break;
	}
#endif /* CCITT */
@


1.43
log
@Make it possible for carp to work on fddi and token ring again.

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.42 2004/12/10 22:35:17 mcbride Exp $	*/
d417 3
a419 4
	if (ifp->if_carp) { 
		error = carp_fix_lladdr(ifp0, m, dst, NULL);
		if (error)
			goto bad;
@


1.42
log
@Rename carp_output() to carp_fix_lladdr().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.41 2004/12/09 16:57:35 mcbride Exp $	*/
d155 2
a156 2
fddi_output(ifp, m0, dst, rt0)
	struct ifnet *ifp;
d168 1
a168 1
	struct arpcom *ac = (struct arpcom *)ifp;
d170 5
d176 14
d418 1
a418 1
		error = carp_fix_lladdr(ifp, m, NULL, NULL);
d437 4
d494 8
@


1.41
log
@Remove shadow variable 'error'. From camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.40 2004/07/16 15:01:08 henning Exp $	*/
d399 1
a399 1
		error = carp_output(ifp, m, NULL, NULL);
@


1.40
log
@remove netiso shitz, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.39 2004/07/08 15:01:05 mcbride Exp $	*/
a398 1
		int error;
@


1.39
log
@Move carp_output() call to after mcopy of MAC address so the virtual address
does not get overwritten.

Report and fix from Chris Pascoe.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.38 2004/06/21 23:50:36 tholo Exp $	*/
a125 7
#ifdef ISO
#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#endif

a261 36
#ifdef	ISO
	case AF_ISO: {
		int	snpalen;
		struct	llc *l;
		struct sockaddr_dl *sdl;

		if (rt && (sdl = (struct sockaddr_dl *)rt->rt_gateway) &&
		    sdl->sdl_family == AF_LINK && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (caddr_t)edst, sizeof(edst));
		} else if ((error =
			    iso_snparesolve(ifp, (struct sockaddr_iso *)dst,
					    (char *)edst, &snpalen)) != 0)
			goto bad; /* Not Resolved */
		/* If broadcasting on a simplex interface, loopback a copy */
		if (*edst & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*fh), M_DONTWAIT);
			if (mcopy) {
				fh = mtod(mcopy, struct fddi_header *);
				bcopy((caddr_t)edst,
				      (caddr_t)fh->fddi_dhost, sizeof (edst));
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)fh->fddi_shost, sizeof (edst));
			}
		}
		M_PREPEND(m, 3, M_DONTWAIT);
		if (m == NULL)
			return (0);
		type = 0;
		l = mtod(m, struct llc *);
		l->llc_dsap = l->llc_ssap = LLC_ISO_LSAP;
		l->llc_control = LLC_UI;
		} break;
#endif /* ISO */
a444 3
#ifdef	ISO
	struct arpcom *ac = (struct arpcom *)ifp;
#endif
a517 62
#ifdef	ISO
	case LLC_ISO_LSAP: 
		switch (l->llc_control) {
		case LLC_UI:
			/* LLC_UI_P forbidden in class 1 service */
			if ((l->llc_dsap == LLC_ISO_LSAP) &&
			    (l->llc_ssap == LLC_ISO_LSAP)) {
				/* LSAP for ISO */
				m->m_data += 3;		/* XXX */
				m->m_len -= 3;		/* XXX */
				m->m_pkthdr.len -= 3;	/* XXX */
				M_PREPEND(m, sizeof *fh, M_DONTWAIT);
				if (m == 0)
					return;
				*mtod(m, struct fddi_header *) = *fh;
				schednetisr(NETISR_ISO);
				inq = &clnlintrq;
				break;
			}
			goto dropanyway;
			
		case LLC_XID:
		case LLC_XID_P:
			if(m->m_len < 6)
				goto dropanyway;
			l->llc_window = 0;
			l->llc_fid = 9;
			l->llc_class = 1;
			l->llc_dsap = l->llc_ssap = 0;
			/* Fall through to */
		case LLC_TEST:
		case LLC_TEST_P:
		{
			struct sockaddr sa;
			struct ether_header *eh;
			int i;
			u_char c = l->llc_dsap;

			l->llc_dsap = l->llc_ssap;
			l->llc_ssap = c;
			if (m->m_flags & (M_BCAST | M_MCAST))
				bcopy((caddr_t)ac->ac_enaddr,
				      (caddr_t)fh->fddi_dhost, 6);
			sa.sa_family = AF_UNSPEC;
			sa.sa_len = sizeof(sa);
			eh = (struct ether_header *)sa.sa_data;
			for (i = 0; i < 6; i++) {
				eh->ether_shost[i] = c = fh->fddi_dhost[i];
				eh->ether_dhost[i] = 
					fh->fddi_dhost[i] = fh->fddi_shost[i];
				fh->fddi_shost[i] = c;
			}
			eh->ether_type = 0;
			ifp->if_output(ifp, m, &sa, NULL);
			return;
		}
		default:
			m_freem(m);
			return;
		}
		break;
#endif /* ISO */
@


1.38
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.37 2004/04/17 00:09:01 henning Exp $	*/
d434 6
a447 7

	if (hdrcmplt)
		bcopy((caddr_t)esrc, (caddr_t)fh->fddi_shost,
		    sizeof(fh->fddi_shost));
	else
 		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)fh->fddi_shost,
		    sizeof(fh->fddi_shost));
@


1.37
log
@add a congestion indicator to if_queue. It is set when the input queue
is full, along with a timer that unsets it again after 10ms.
The input queue beeing full is a reliable indicator for CPU overload, and
this flag allows other subsystems to cope with the situation.
hacked with beck
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.36 2003/12/10 07:22:42 itojun Exp $	*/
d199 1
a199 1
			    time.tv_sec < rt->rt_rmx.rmx_expire)
@


1.36
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.35 2003/10/25 19:31:05 mcbride Exp $	*/
d656 1
a656 5
	if (IF_QFULL(inq)) {
		IF_DROP(inq);
		m_freem(m);
	} else
		IF_ENQUEUE(inq, m);
@


1.35
log
@"goto bad" on error with carp_input, instead of simply returning.
Fixes leakage of mbufs on error.

Pointed out by Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.34 2003/10/17 21:04:58 mcbride Exp $	*/
d163 1
a163 1
	register struct ifnet *ifp;
d171 2
a172 2
	register struct mbuf *m = m0;
	register struct rtentry *rt;
d174 1
a174 1
	register struct fddi_header *fh;
d273 1
a273 1
		register struct sockaddr_dl *sdl;
d308 1
a308 1
		register struct sockaddr_dl *sdl = 
d332 1
a332 1
			register struct llc *l = mtod(m, struct llc *);
d410 1
a410 1
		register struct llc *l;
d484 1
a484 1
	register struct fddi_header *fh;
d487 2
a488 2
	register struct ifqueue *inq;
	register struct llc *l;
d599 1
a599 1
			register struct ether_header *eh;
d668 1
a668 1
	register struct ifnet *ifp;
@


1.34
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.33 2003/08/18 11:01:41 dhartmei Exp $	*/
d439 1
a439 1
			return (error);
@


1.33
log
@prevent looutput() feedback of broadcast/multicast packets if they are
pf routed. prevents a kernel lockup with some (non-sensical) route-to
rules. report and debugging by mpech@@. ok itojun@@, henning@@, mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.32 2003/06/02 23:28:12 millert Exp $	*/
d142 5
d434 9
@


1.32
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.31 2003/05/14 20:40:52 itojun Exp $	*/
d205 2
a206 1
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
@


1.31
log
@unifdef __FreeBSD__ and stuff.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.30 2003/01/07 09:00:33 kjc Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.30
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.29 2002/06/30 13:04:36 itojun Exp $	*/
a105 3
#if defined(__FreeBSD__)
#include <netinet/if_fddi.h>
#else
a106 1
#endif
a154 9
#if defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
#define	RTALLOC1(a, b)			rtalloc1(a, b)
#define	ARPRESOLVE(a, b, c, d, e, f)	arpresolve(a, b, c, d, e)
#define	TYPEHTONS(t)			(t)
#elif defined(__FreeBSD__)
#define	RTALLOC1(a, b)			rtalloc1(a, b, 0UL)
#define	ARPRESOLVE(a, b, c, d, e, f)	arpresolve(a, b, c, d, e, f)
#define	TYPEHTONS(t)			(htons(t))
#endif
d181 1
a181 1
			if ((rt0 = rt = RTALLOC1(dst, 1)) != NULL)
d191 1
a191 1
			lookup: rt->rt_gwroute = RTALLOC1(rt->rt_gateway, 1);
d206 1
a206 1
		if (!ARPRESOLVE(ac, rt, m, dst, edst, rt0))
a300 9
#if defined(__FreeBSD__)
		IFDEBUG(D_ETHER)
			int i;
			printf("unoutput: sending pkt to: ");
			for (i=0; i<6; i++)
				printf("%x ", edst[i] & 0xff);
			printf("\n");
		ENDDEBUG
#endif
d359 1
a359 1
		type = TYPEHTONS(eh->ether_type);
a568 5
#if defined(__FreeBSD__)
				IFDEBUG(D_ETHER)
					printf("clnp packet");
				ENDDEBUG
#endif
@


1.29
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.28 2001/12/18 23:07:49 deraadt Exp $	*/
a187 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a214 6
	/*
	 * If the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d467 1
a467 1
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
@


1.28
log
@NRL license cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.27 2001/12/10 06:10:53 jason Exp $	*/
a692 2
	register struct ifaddr *ifa;
	register struct sockaddr_dl *sdl;
d699 3
a701 14
#if defined(__NetBSD__) || defined(__OpenBSD__)
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
#else
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
#endif
		if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
		    sdl->sdl_family == AF_LINK) {
			sdl->sdl_type = IFT_FDDI;
			sdl->sdl_alen = ifp->if_addrlen;
			bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			      LLADDR(sdl), ifp->if_addrlen);
			break;
		}
	}
@


1.28.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.28 2001/12/18 23:07:49 deraadt Exp $	*/
d693 2
d701 14
a714 3
	if_alloc_sadl(ifp);
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	      LLADDR(ifp->if_sadl), ifp->if_addrlen);
@


1.28.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 3
d110 1
d159 9
d188 1
d195 1
a195 1
			if ((rt0 = rt = rtalloc1(dst, 1)) != NULL)
d205 1
a205 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
d216 6
d226 1
a226 1
		if (!arpresolve(ac, rt, m, dst, edst))
d321 9
d388 1
a388 1
		type = eh->ether_type;
d474 1
a474 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d598 5
@


1.27
log
@use queue.h macros for TAILQ operations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.26 2001/11/30 07:59:17 itojun Exp $	*/
d42 38
a79 10
%%% portions-copyright-nrl-97
Portions of this software are Copyright 1997-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.26
log
@unifdef OLDIP6OUTPUT
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.25 2001/06/27 06:07:40 kjc Exp $	*/
d674 1
a674 2
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	    ifa = ifa->ifa_list.tqe_next)
d676 1
a676 1
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
d686 1
@


1.25
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.24 2001/06/15 03:38:33 itojun Exp $	*/
d208 1
a208 2
#ifdef OLDIP6OUTPUT
		if (!nd6_resolve(ifp, rt, m, dst, edst))
a209 4
#else
		if (!nd6_storelladdr(ifp, rt, m, dst, (u_char *)edst))
			return 0;
#endif
@


1.24
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.23 2001/05/28 19:51:06 dugsong Exp $	*/
d153 1
a153 1
	int s, error = 0, hdrcmplt = 0;
d160 2
d187 7
d444 2
d451 3
a453 2
	if (IF_QFULL(&ifp->if_snd)) {
		IF_DROP(&ifp->if_snd);
d455 1
a455 1
		senderr(ENOBUFS);
d457 3
a459 2
	ifp->if_obytes += m->m_pkthdr.len;
	IF_ENQUEUE(&ifp->if_snd, m);
a462 2
	if (m->m_flags & M_MCAST)
		ifp->if_omcasts++;
@


1.23
log
@add BIOC[GS]HDRCMPLT ioctl for BPF, to disable overwriting of link level source address in forged frames. from NetBSD. art@@ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.22 2000/02/07 06:09:08 itojun Exp $	*/
a162 1
	ifp->if_lastchange = time;
a481 1
	ifp->if_lastchange = time;
@


1.22
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.21 2000/01/11 19:27:53 fgsch Exp $	*/
d153 2
a154 2
	int s, error = 0;
 	u_char edst[6];
d342 8
d430 6
a435 2
 	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)fh->fddi_shost,
	    sizeof(fh->fddi_shost));
@


1.22.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.22 2000/02/07 06:09:08 itojun Exp $	*/
d153 2
a154 2
	int s, len, error = 0, hdrcmplt = 0;
 	u_char edst[6], esrc[6];
a159 2
	ALTQ_DECL(struct altq_pktattr pktattr;)
	short mflags;
d163 1
a185 7

	/*
	 * If the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

a341 8
	case pseudo_AF_HDRCMPLT:
	{
		struct fddi_header *fh = (struct fddi_header *)dst->sa_data;
		hdrcmplt = 1;
		bcopy((caddr_t)fh->fddi_shost, (caddr_t)esrc, sizeof (esrc));
		/* FALLTHROUGH */
	}

d422 2
a423 8
	if (hdrcmplt)
		bcopy((caddr_t)esrc, (caddr_t)fh->fddi_shost,
		    sizeof(fh->fddi_shost));
	else
 		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)fh->fddi_shost,
		    sizeof(fh->fddi_shost));
	mflags = m->m_flags;
	len = m->m_pkthdr.len;
d429 2
a430 3
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		/* mbuf is already freed */
d432 1
a432 1
		return (error);
d434 2
a435 3
	ifp->if_obytes += len;
	if (mflags & M_MCAST)
		ifp->if_omcasts++;
d439 2
d471 1
@


1.22.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d208 4
d213 2
a214 1
			return (0);	/* if not yet resolved */
@


1.22.2.3
log
@Merge in trunk
@
text
@d42 10
a51 38
 *	@@(#)COPYRIGHT	1.1 (NRL) January 1997
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d674 2
a675 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
d677 1
a677 1
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) {
a686 1
	}
@


1.22.2.4
log
@Sync the SMP branch with 3.3
@
text
@d188 1
d216 6
d474 1
a474 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d693 2
d701 14
a714 3
	if_alloc_sadl(ifp);
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	      LLADDR(ifp->if_sadl), ifp->if_addrlen);
@


1.22.2.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d106 3
d110 1
d159 9
d194 1
a194 1
			if ((rt0 = rt = rtalloc1(dst, 1)) != NULL)
d204 1
a204 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
d219 1
a219 1
		if (!arpresolve(ac, rt, m, dst, edst))
d314 9
d381 1
a381 1
		type = eh->ether_type;
d591 5
@


1.22.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.22.2.5 2003/05/16 00:29:43 niklas Exp $	*/
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.22.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a141 5
#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

d158 1
a158 1
	struct ifnet *ifp;
d166 2
a167 2
	struct mbuf *m = m0;
	struct rtentry *rt;
d169 1
a169 1
	struct fddi_header *fh;
d205 1
a205 2
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    m_tag_find(m, PACKET_TAG_PF_ROUTED, NULL) == NULL)
d267 1
a267 1
		struct sockaddr_dl *sdl;
d302 1
a302 1
		struct sockaddr_dl *sdl = 
d326 1
a326 1
			struct llc *l = mtod(m, struct llc *);
d404 1
a404 1
		struct llc *l;
a427 9
#if NCARP > 0
	if (ifp->if_carp) { 
		int error;
		error = carp_output(ifp, m, NULL, NULL);
		if (error)
			goto bad;
	}
#endif

d469 1
a469 1
	struct fddi_header *fh;
d472 2
a473 2
	struct ifqueue *inq;
	struct llc *l;
d584 1
a584 1
			struct ether_header *eh;
d653 1
a653 1
	struct ifnet *ifp;
@


1.22.2.8
log
@Merge with the trunk
@
text
@d656 5
a660 1
	IF_INPUT_ENQUEUE(inq, m);
@


1.21
log
@Remove unneeded loout call that uses ipx_thishost.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.20 1999/12/08 06:50:18 itojun Exp $	*/
a116 5

#ifdef INET6
#include <netinet6/in6.h>
#include <netinet6/in6_var.h>
#endif /* INET6 */
@


1.20
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.19 1999/07/28 20:02:41 fgsch Exp $	*/
a243 2
		if (!bcmp((caddr_t)edst, (caddr_t)&ipx_thishost, sizeof(edst)))
			return (looutput(ifp, m, dst, rt));
@


1.19
log
@Add LLC_SNAPFRAMELEN define. indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.18 1999/01/08 00:56:45 deraadt Exp $	*/
d89 8
d205 13
d238 1
d517 1
a517 1
			inq = &ipv6intrq;
@


1.18
log
@inet6 support; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.17 1998/07/08 22:22:51 ryker Exp $	*/
d477 1
a477 1
		m_adj(m, 8);
@


1.17
log
@Correct error in original cloning from if_ethersubr.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.16 1998/07/07 14:52:38 ryker Exp $	*/
d41 12
d110 5
d195 22
d468 1
a468 1
#if defined(INET) || defined(IPX) || defined(NS) || defined(DECNET)
d492 6
@


1.16
log
@DECNET is not DECENT. :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.15 1998/06/30 21:51:06 beck Exp $	*/
d533 2
a534 2
					eh->ether_dhost[i] = fh->fddi_shost[i];
				eh->ether_shost[i] = c;
@


1.15
log
@Fix broken IPX so the kernel will compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.14 1997/09/27 02:35:58 deraadt Exp $	*/
d466 1
a466 1
		case ETHERTYPE_DECENT:
@


1.14
log
@undo previous AF_UNSPEC change. analyze two alternatives: AF_SOMETHINGNEW,
or how much work it would be fix everything that uses AF_UNSPEC.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.12 1997/07/24 22:59:31 deraadt Exp $	*/
d181 1
a181 1
 		bcopy((caddr_t)&(((struct sockaddr_ipx*)dst)->sipx_addr.x_host),
@


1.13
log
@for AF_UNSPEC sockets, do not whack the ethernet address; this is what bpf
uses when it sends packets out. blame tqbf@@rdist.org for this fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.11 1997/02/24 13:33:59 niklas Exp $	*/
d134 1
a134 1
	u_char edst[6], esrc[6];
d181 1
a181 1
		bcopy((caddr_t)&(((struct sockaddr_ipx*)dst)->sipx_addr.x_host),
d193 1
a193 1
		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
a290 1

d292 1
a292 2
		bcopy((caddr_t)eh->ether_dhost, (caddr_t)edst, sizeof (edst));
		bcopy((caddr_t)eh->ether_shost, (caddr_t)esrc, sizeof (esrc));
d305 1
a305 1
			case FDDIFC_LLC_ASYNC:
d308 1
a308 1
					goto bad;
d310 2
a311 1
			case FDDIFC_LLC_SYNC:
d316 2
a317 1
			case FDDIFC_SMT:
d322 2
a323 1
			default:
d325 2
a326 1
				goto bad;
d351 1
a351 2
		l->llc_snap.org_code[0] = l->llc_snap.org_code[1] =
		    l->llc_snap.org_code[2] = 0;
d364 1
a364 7
	bcopy((caddr_t)edst, (caddr_t)fh->fddi_dhost, sizeof (edst));
	if (dst->sa_family == AF_UNSPEC)
		bcopy((caddr_t)esrc, (caddr_t)fh->fddi_shost,
		    sizeof(fh->fddi_shost));
	else
		bcopy((caddr_t)ac->ac_enaddr, (caddr_t)fh->fddi_shost,
		    sizeof(fh->fddi_shost));
d366 1
a366 1
queue_it:
d368 2
@


1.12
log
@do not ignore IFF_NOARP
@
text
@d134 1
a134 1
 	u_char edst[6];
d181 1
a181 1
 		bcopy((caddr_t)&(((struct sockaddr_ipx*)dst)->sipx_addr.x_host),
d193 1
a193 1
 		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
d291 1
d293 2
a294 1
 		bcopy((caddr_t)eh->ether_dhost, (caddr_t)edst, sizeof (edst));
d307 1
a307 1
			case FDDIFC_LLC_ASYNC: {
d310 1
a310 1
			        	goto bad;
d312 1
a312 2
			}
			case FDDIFC_LLC_SYNC: {
d317 1
a317 2
			}
			case FDDIFC_SMT: {
d322 1
a322 2
			}
			default: {
d324 1
a324 2
               	 		goto bad;
			}
d349 2
a350 1
		l->llc_snap.org_code[0] = l->llc_snap.org_code[1] = l->llc_snap.org_code[2] = 0;
d363 7
a369 1
 	bcopy((caddr_t)edst, (caddr_t)fh->fddi_dhost, sizeof (edst));
d371 1
a371 1
  queue_it:
a372 2
 	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)fh->fddi_shost,
	    sizeof(fh->fddi_shost));
@


1.11
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fddisubr.c,v 1.5 1996/05/07 23:20:21 christos Exp $	*/
d447 2
@


1.10
log
@accept llc/snap packets; still cannot send them...
@
text
@d1 1
@


1.9
log
@label only useful in bpf case
@
text
@a93 1
#ifdef LLC
a95 1
#endif
d97 1
a97 1
#if defined(LLC) && defined(CCITT)
d246 1
a246 1
#ifdef	LLC
d285 1
a285 1
#endif /* LLC */	
d543 1
a543 1
#ifdef LLC
d561 1
a561 1
#endif /* LLC */
@


1.8
log
@contextual usage
@
text
@d366 1
d368 1
@


1.7
log
@__OpenBSD__
@
text
@d407 1
d409 1
@


1.6
log
@sync
@
text
@d112 1
a112 1
#if defined(__bsdi__) || defined(__NetBSD__)
d592 1
a592 1
#ifdef __NetBSD__
@


1.5
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$NetBSD: if_fddisubr.c,v 1.4 1996/05/07 02:40:32 thorpej Exp $	*/
d145 1
a145 1
	if (rt = rt0) {
d147 1
a147 1
			if (rt0 = rt = RTALLOC1(dst, 1))
d212 1
a212 1
		} else if (error =
d214 1
a214 1
					    (char *)edst, &snpalen))
d252 1
a252 1
			(struct sockaddr_dl *) rt -> rt_gateway;
@


1.4
log
@fix the wrong changes, so the bcasts will work now ;)
@
text
@d1 1
a1 1
/*	$NetBSD: if_fddisubr.c,v 1.3 1995/12/24 03:32:03 mycroft Exp $	*/
d237 1
d245 1
d336 1
a336 1
		printf("%s%d: can't handle af%d\n", ifp->if_name, ifp->if_unit,
d489 1
d493 1
@


1.3
log
@IPX additions and fixes.
ether -- missed the input for IPX.
fddi -- just added.
ppp -- field codes added.
loop -- minor fix.
@
text
@d187 1
a187 1
		if ((m->m_flags & (M_BCAST|IFF_SIMPLEX))==(M_BCAST|IFF_SIMPLEX))
@


1.2
log
@from netbsd:
Remove old comment regarding trailers.
Fix a diagnostic message.
Make some variables use fixed-size types.
Initialize if_output in fddi_ifattach().
@
text
@d71 5
d179 12
d424 1
a424 1
#if defined(INET) || defined(NS) || defined(DECNET)
d446 6
d471 1
a471 1
#endif /* INET || NS */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_fddisubr.c,v 1.2 1995/08/19 04:35:29 cgd Exp $	*/
a118 2
 * Use trailer local net encapsulation if enough data in first
 * packet leaves a multiple of 512 bytes of data in remainder.
d128 1
a128 1
	short type;
d262 2
a263 2
			       type & 0xff, l->llc_dsap & 0xff, l->llc_ssap &0xff,
			       l->llc_control & 0xff);
a321 1

d324 1
d410 1
a410 1
		unsigned fddi_type;
d415 1
a415 1
		fddi_type = ntohs(l->llc_snap.ether_type);
d417 1
a417 1
		switch (fddi_type) {
d442 1
a442 1
			/* printf("fddi_input: unknown protocol 0x%x\n", fddi_type); */
d564 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
