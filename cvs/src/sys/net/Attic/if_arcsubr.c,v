head	1.24;
access;
symbols
	OPENBSD_3_9:1.21.0.8
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.13
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.20
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2006.07.18.11.52.12;	author dlg;	state dead;
branches;
next	1.23;

1.23
date	2006.06.17.14.14.12;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.21.17.20.59;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.17.00.09.01;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.12.12.54.57;	author hshoexer;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.18.11.01.41;	author dhartmei;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.15.16.02.13;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.30.13.04.35;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.09.13.09.13;	author jason;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.06.15.03.38.33;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.11.17.20.09;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	97.02.24.13.33.57;	author niklas;	state Exp;
branches
	1.5.14.1;
next	1.4;

1.4
date	96.05.10.12.31.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.28.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.35.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2001.07.04.10.53.54;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.5.14.4;

1.5.14.4
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.5.14.5;

1.5.14.5
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.5.14.6;

1.5.14.6
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.5.14.7;

1.5.14.7
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@get rid of arc network support. we have no users of it so this is dead
code. however, it is still cluttering up the kernel namespace a bit. it is
better gone.

ok claudio@@
@
text
@/*	$OpenBSD: if_arcsubr.c,v 1.23 2006/06/17 14:14:12 henning Exp $	*/
/*	$NetBSD: if_arcsubr.c,v 1.8 1996/05/07 02:40:29 thorpej Exp $	*/

/*
 * Copyright (c) 1994, 1995 Ignatios Souvatzis
 * Copyright (c) 1982, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: NetBSD: if_ethersubr.c,v 1.9 1994/06/29 06:36:11 cgd Exp
 *       @@(#)if_ethersubr.c	8.1 (Berkeley) 6/10/93
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>

#include <machine/cpu.h>

#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_var.h>
#endif
#include <netinet/if_arc.h>

#ifndef	ARC_PHDSMTU
#define	ARC_PHDSMTU	1500
#endif

static struct mbuf *arc_defrag(struct ifnet *, struct mbuf *);

/*
 * RC1201 requires us to have this configurable. We have it only per 
 * machine at the moment... there is no generic "set mtu" ioctl, AFAICS.
 * Anyway, it is possible to binpatch this or set it per kernel config
 * option.
 */
#if ARC_PHDSMTU > 60480
#error The arc_phdsmtu is ARC_PHDSMTU, but must not exceed 60480.
#endif
u_int16_t arc_phdsmtu = ARC_PHDSMTU;
u_int8_t  arcbroadcastaddr = 0;

#define senderr(e) { error = (e); goto bad;}
#define SIN(s) ((struct sockaddr_in *)s)

/*
 * ARCnet output routine.
 * Encapsulate a packet of type family for the local net.
 * Assumes that ifp is actually pointer to arccom structure.
 */
int
arc_output(ifp, m0, dst, rt0)
	struct ifnet *ifp;
	struct mbuf *m0;
	struct sockaddr *dst;
	struct rtentry *rt0;
{
	struct mbuf		*m, *m1, *mcopy;
	struct rtentry		*rt;
	struct arccom		*ac;
	struct arc_header *ah;
	int			s, error, newencoding, len;
	u_int8_t		atype, adst;
	int			tfrags, sflag, fsflag, rsflag;

	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) 
		return (ENETDOWN); /* m, m1 aren't initialized yet */

	error = newencoding = 0;
	ac = (struct arccom *)ifp;
	m = m0;
	mcopy = m1 = NULL;

	if ((rt = rt0)) {
		if ((rt->rt_flags & RTF_UP) == 0) {
			if ((rt0 = rt = rtalloc1(dst, 1, 0)))
				rt->rt_refcnt--;
			else 
				senderr(EHOSTUNREACH);
		}
		if (rt->rt_flags & RTF_GATEWAY) {
			if (rt->rt_gwroute == 0)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt); rt = rt0;
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1, 0);
				if ((rt = rt->rt_gwroute) == 0)
					senderr(EHOSTUNREACH);
			}
		}
		if (rt->rt_flags & RTF_REJECT)
			if (rt->rt_rmx.rmx_expire == 0 ||
			    time_second < rt->rt_rmx.rmx_expire)
				senderr(rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
	}

	switch (dst->sa_family) {
#ifdef INET
	case AF_INET:

		/*
		 * For now, use the simple IP addr -> ARCnet addr mapping
		 */
		if (m->m_flags & M_BCAST) 
			adst = arcbroadcastaddr; /* ARCnet broadcast address */
		else
			adst = ntohl(SIN(dst)->sin_addr.s_addr) & 0xFF;

		/* If broadcasting on a simplex interface, loopback a copy */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    m_tag_find(m, PACKET_TAG_PF_ROUTED, NULL) == NULL)
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		if (ifp->if_flags & IFF_LINK0) {
			atype = ARCTYPE_IP;
			newencoding = 1;
		} else {
			atype = ARCTYPE_IP_OLD;
			newencoding = 0;
		}
		break;
#endif

	case AF_UNSPEC:
		ah = (struct arc_header *)dst->sa_data;
 		adst = ah->arc_dhost;
		atype = ah->arc_type;
		break;

	default:
		printf("%s: can't handle af%d\n", ifp->if_xname,
			dst->sa_family);
		senderr(EAFNOSUPPORT);
	}

	if (mcopy)
		(void) looutput(ifp, mcopy, dst, rt);

	/*
	 * Add local net header.  If no space in first mbuf,
	 * allocate another.
	 * 
	 * For ARCnet, this is just symbolic. The header changes
	 * form and position on its way into the hardware and out of
	 * the wire.  At this point, it contains source, destination and
	 * packet type.
	 */
	if (newencoding) {
		++ac->ac_seqid; /* make the seqid unique */

		tfrags = (m->m_pkthdr.len + 503) / 504;
		fsflag = 2 * tfrags - 3;
		sflag = 0;
		rsflag = fsflag;

		while (sflag < fsflag) {
			/* we CAN'T have short packets here */
			m1 = m_split(m, 504, M_DONTWAIT);
			if (m1 == 0)
				senderr(ENOBUFS);

			M_PREPEND(m, ARC_HDRNEWLEN, M_DONTWAIT);
			if (m == 0)
				senderr(ENOBUFS);
			ah = mtod(m, struct arc_header *);
			ah->arc_type = atype;
			ah->arc_dhost = adst;
			ah->arc_shost = ac->ac_anaddr;
			ah->arc_flag = rsflag;
			ah->arc_seqid = ac->ac_seqid;

			len = m->m_pkthdr.len;
			s = splnet();
			/*
			 * Queue message on interface, and start output if 
			 * interface not yet active.
			 */
			IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
			if (error) {
				/* mbuf is already freed */
				splx(s);
				return (error);
			}
			ifp->if_obytes += len;
			if ((ifp->if_flags & IFF_OACTIVE) == 0)
				(*ifp->if_start)(ifp);
			splx(s);
	
			m = m1;
			sflag += 2;
			rsflag = sflag;
		}
		m1 = NULL;

		M_PREPEND(m, ARC_HDRNEWLEN, M_DONTWAIT);
		if (m == 0)
			senderr(ENOBUFS);
		ah = mtod(m, struct arc_header *);
		ah->arc_type = atype;
		ah->arc_flag = sflag;
		ah->arc_seqid = ac->ac_seqid;

		/* here we can have small, especially forbidden packets */

		if ((m->m_pkthdr.len >= ARC_MIN_FORBID_LEN + 2) &&
		    (m->m_pkthdr.len <= ARC_MAX_FORBID_LEN + 2)) {
			M_PREPEND(m, 4, M_DONTWAIT);
			if (m == 0)
				senderr(ENOBUFS);
			m = m_pullup(m, ARC_HDRNEWLEN);
			if (m == NULL)
				senderr(ENOBUFS);
			ah = mtod(m, struct arc_header *);
			ah->arc_type = atype;
			ah->arc_flag = 0xFF;
			ah->arc_seqid = 0xFFFF;
		}

		ah->arc_dhost = adst;
		ah->arc_shost = ac->ac_anaddr;
	} else {
		M_PREPEND(m, ARC_HDRLEN, M_DONTWAIT);
		if (m == 0)
			senderr(ENOBUFS);
		ah = mtod(m, struct arc_header *);
		ah->arc_type = atype;
		ah->arc_dhost = adst;
		ah->arc_shost = ac->ac_anaddr;
	}

	len = m->m_pkthdr.len;
	s = splnet();
	/*
	 * Queue message on interface, and start output if interface
	 * not yet active.
	 */
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		/* mbuf is already freed */
		splx(s);
		return (error);
	}
	ifp->if_obytes += len;
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
	splx(s);

	return (error);

bad:
	if (m1)
		m_freem(m1);
	if (m)
		m_freem(m);
	return (error);
}

/*
 * Defragmenter. Returns mbuf if last packet found, else 
 * NULL. frees imcoming mbuf as necessary.
 */

__inline struct mbuf *
arc_defrag(ifp, m)
	struct ifnet *ifp;
	struct mbuf *m;
{
	struct arc_header *ah, *ah1;
	struct arccom *ac;
	struct ac_frag *af;
	struct mbuf *m1;
	char *s;
	int newflen;
	u_char src,dst,typ;
	
	ac = (struct arccom *)ifp;

	m = m_pullup(m, ARC_HDRNEWLEN);
	if (m == NULL) {
		++ifp->if_ierrors;
		return NULL;
	}

	ah = mtod(m, struct arc_header *);
	typ = ah->arc_type;

	if (!arc_isphds(typ))
		return m;

	src = ah->arc_shost;
	dst = ah->arc_dhost;

	if (ah->arc_flag == 0xff) {
		m_adj(m, 4);

		m = m_pullup(m, ARC_HDRNEWLEN);
		if (m == NULL) {
			++ifp->if_ierrors;
			return NULL;
		}

		ah = mtod(m, struct arc_header *);
		ah->arc_shost = src;
		ah->arc_dhost = dst;
		ah->arc_type = typ;
	}

	af = &ac->ac_fragtab[src];
	m1 = af->af_packet;
	s = "debug code error";

	if (ah->arc_flag & 1) {
		/* 
		 * first fragment. We always initialize, which is
		 * about the right thing to do, as we only want to
		 * accept one fragmented packet per src at a time.
		 */
		if (m1 != NULL)
			m_freem(m1);

		af->af_packet = m;
		m1 = m;
		af->af_maxflag = ah->arc_flag;
		af->af_lastseen = 0;
		af->af_seqid = ah->arc_seqid;

		return NULL;
		/* notreached */
	} else {
		/* check for unfragmented packet */
		if (ah->arc_flag == 0)
			return m;

		/* do we have a first packet from that src? */
		if (m1 == NULL) {
			s = "no first frag";
			goto outofseq;
		}

		ah1 = mtod(m1, struct arc_header *);

		if (ah->arc_seqid != ah1->arc_seqid) {
			s = "seqid differs";
			goto outofseq;
		}

		if (ah->arc_type != ah1->arc_type) {
			s = "type differs";
			goto outofseq;
		}

		if (ah->arc_dhost != ah1->arc_dhost) {
			s = "dest host differs";
			goto outofseq;
		}

		/* typ, seqid and dst are ok here. */

		if (ah->arc_flag == af->af_lastseen) {
			m_freem(m);
			return NULL;
		}

		if (ah->arc_flag == af->af_lastseen + 2) {
			/* ok, this is next fragment */
			af->af_lastseen = ah->arc_flag;
			m_adj(m,ARC_HDRNEWLEN);

			/* 
			 * m_cat might free the first mbuf (with pkthdr)
			 * in 2nd chain; therefore:
			 */

			newflen = m->m_pkthdr.len;	

			m_cat(m1,m);

			m1->m_pkthdr.len += newflen;

			/* is it the last one? */
			if (af->af_lastseen > af->af_maxflag) {
				af->af_packet = NULL;
				return (m1);
			} else
				return NULL;
		}
		s = "other reason";
		/* if all else fails, it is out of sequence, too */
	}
outofseq:
	if (m1) {
		m_freem(m1);
		af->af_packet = NULL;
	}

	if (m) 
		m_freem(m);

	log(LOG_INFO,"%s: got out of seq. packet: %s\n",
	    ifp->if_xname, s);

	return NULL;
}

/*
 * return 1 if Packet Header Definition Standard, else 0.
 * For now: old IP, old ARP aren't obviously. Lacking correct information,
 * we guess that besides new IP and new ARP also IPX and APPLETALK are PHDS.
 * (Apple and Novell corporations were involved, among others, in PHDS work).
 * Easiest is to assume that everybody else uses that, too.
 */
int
arc_isphds(type)
	u_int8_t type;
{
	return ((type != ARCTYPE_IP_OLD && 
		 type != ARCTYPE_ARP_OLD));
}

/*
 * Process a received Arcnet packet;
 * the packet is in the mbuf chain m with
 * the ARCnet header.
 */
void
arc_input(ifp, m)
	struct ifnet *ifp;
	struct mbuf *m;
{
	struct arc_header *ah;
	struct ifqueue *inq;
	u_int8_t atype;
	int s;

	if ((ifp->if_flags & IFF_UP) == 0) {
		m_freem(m);
		return;
	}

	/* possibly defragment: */
	m = arc_defrag(ifp, m);
	if (m == NULL) 
		return;

	ah = mtod(m, struct arc_header *);

	ifp->if_ibytes += m->m_pkthdr.len;

	if (arcbroadcastaddr == ah->arc_dhost) {
		m->m_flags |= M_BCAST;
		ifp->if_imcasts++;
	}

	atype = ah->arc_type;
	switch (atype) {
#ifdef INET
	case ARCTYPE_IP:
		m_adj(m, ARC_HDRNEWLEN);
		schednetisr(NETISR_IP);
		inq = &ipintrq;
		break;

	case ARCTYPE_IP_OLD:
		m_adj(m, ARC_HDRLEN);
		schednetisr(NETISR_IP);
		inq = &ipintrq;
		break;
#endif
	default:
		m_freem(m);
		return;
	}

	s = splnet();
	IF_INPUT_ENQUEUE(inq, m);
	splx(s);
}

/*
 * Convert Arcnet address to printable (loggable) representation.
 */
static char digits[] = "0123456789abcdef";
char *
arc_sprintf(ap)
	u_int8_t *ap;
{
	static char arcbuf[3];
	char *cp = arcbuf;

	*cp++ = digits[*ap >> 4];
	*cp++ = digits[*ap++ & 0xf];
	*cp   = 0;
	return (arcbuf);
}

/*
 * Perform common duties while attaching to interface list
 */
void
arc_ifattach(ifp)
	struct ifnet *ifp;
{
	struct arccom *ac;

	ifp->if_type = IFT_ARCNET;
	ifp->if_addrlen = 1;
	ifp->if_hdrlen = ARC_HDRLEN;
	if (ifp->if_flags & IFF_LINK0 && arc_phdsmtu > 60480)
		log(LOG_ERR,
		    "%s: arc_phdsmtu is %d, but must not exceed 60480",
		    ifp->if_xname, arc_phdsmtu);

	ifp->if_mtu = (ifp->if_flags & IFF_LINK0 ? arc_phdsmtu : ARCMTU);
	ac = (struct arccom *)ifp;
	ac->ac_seqid = arc4random() & 0xFFFF; /* try to make seqid unique */
	if (ac->ac_anaddr == 0) {
		/* XXX this message isn't entirely clear, to me -- cgd */
		log(LOG_ERR,"%s: link address 0 reserved for broadcasts.  Please change it and ifconfig %s down up\n",
		   ifp->if_xname, ifp->if_xname); 
	}
	if_alloc_sadl(ifp);
	bcopy((caddr_t)&((struct arccom *)ifp)->ac_anaddr,
	      LLADDR(ifp->if_sadl), ifp->if_addrlen);
}
@


1.23
log
@adopt to extended rtrequest / rtalloc1 api
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.22 2006/03/04 22:40:15 brad Exp $	*/
@


1.22
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.21 2004/06/21 23:50:36 tholo Exp $	*/
d114 1
a114 1
			if ((rt0 = rt = rtalloc1(dst, 1)))
d124 1
a124 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
@


1.21
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.20 2004/06/21 17:20:59 tholo Exp $	*/
d210 1
a210 1
			s = splimp();
d269 1
a269 1
	s = splimp();
d511 1
a511 1
	s = splimp();
@


1.20
log
@Don't use time for random starting value... "love it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.19 2004/04/17 00:09:01 henning Exp $	*/
d131 1
a131 1
			    time.tv_sec < rt->rt_rmx.rmx_expire)
@


1.19
log
@add a congestion indicator to if_queue. It is set when the input queue
is full, along with a timer that unsets it again after 10ms.
The input queue beeing full is a reliable indicator for CPU overload, and
this flag allows other subsystems to cope with the situation.
hacked with beck
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.18 2003/12/12 12:54:57 hshoexer Exp $	*/
d552 1
a552 1
	ac->ac_seqid = (time.tv_sec) & 0xFFFF; /* try to make seqid unique */
@


1.18
log
@small compiler warning cleanup (#error instead of bailing out)

ok henning@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.17 2003/12/10 07:22:42 itojun Exp $	*/
d512 1
a512 5
	if (IF_QFULL(inq)) {
		IF_DROP(inq);
		m_freem(m);
	} else
		IF_ENQUEUE(inq, m);
@


1.17
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.16 2003/08/18 11:01:41 dhartmei Exp $	*/
d76 1
a76 1
ERROR: The arc_phdsmtu is ARC_PHDSMTU, but must not exceed 60480.
@


1.16
log
@prevent looutput() feedback of broadcast/multicast packets if they are
pf routed. prevents a kernel lockup with some (non-sensical) route-to
rules. report and debugging by mpech@@. ok itojun@@, henning@@, mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.15 2003/06/02 23:28:11 millert Exp $	*/
d91 1
a91 1
	register struct ifnet *ifp;
d99 1
a99 1
	register struct arc_header *ah;
d467 2
a468 2
	register struct arc_header *ah;
	register struct ifqueue *inq;
d526 1
a526 1
	register u_int8_t *ap;
d529 1
a529 1
	register char *cp = arcbuf;
d542 1
a542 1
	register struct ifnet *ifp;
d544 1
a544 1
	register struct arccom *ac;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.14 2003/01/07 09:00:33 kjc Exp $	*/
d148 2
a149 1
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
@


1.14
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.13 2002/09/15 16:02:13 niklas Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@Make compile with -Werror (unused vars warnings)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.12 2002/09/11 05:38:47 itojun Exp $	*/
a106 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a138 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d218 1
a218 1
			IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
@


1.12
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.11 2002/06/30 13:04:35 itojun Exp $	*/
a553 2
	register struct ifaddr *ifa;
	register struct sockaddr_dl *sdl;
@


1.11
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.10 2002/03/14 01:27:09 millert Exp $	*/
d110 1
a110 1
		return(ENETDOWN); /* m, m1 aren't initialized yet */
d430 1
a430 1
				return(m1);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.9 2002/03/12 09:51:20 kjc Exp $	*/
d574 3
a576 10
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
		    sdl->sdl_family == AF_LINK) {
			sdl->sdl_type = IFT_ARCNET;
			sdl->sdl_alen = ifp->if_addrlen;
			bcopy((caddr_t)&((struct arccom *)ifp)->ac_anaddr,
			      LLADDR(sdl), ifp->if_addrlen);
			break;
		}
	}
@


1.9
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.8 2001/12/09 13:09:13 jason Exp $	*/
d71 1
a71 1
static struct mbuf *arc_defrag __P((struct ifnet *, struct mbuf *));
@


1.8
log
@Use queue.h TAILQ macros instead of accessing members directly.
(And convert a few loops to TAILQ_FOREACH).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.7 2001/06/15 03:38:33 itojun Exp $	*/
d104 1
a104 1
	int			s, error, newencoding;
d107 1
d140 6
d219 1
d225 3
a227 2
			if (IF_QFULL(&ifp->if_snd)) {
				IF_DROP(&ifp->if_snd);
d229 1
a229 1
				senderr(ENOBUFS);
d231 1
a231 2
			ifp->if_obytes += m->m_pkthdr.len;
			IF_ENQUEUE(&ifp->if_snd, m);
d278 1
d284 3
a286 2
	if (IF_QFULL(&ifp->if_snd)) {
		IF_DROP(&ifp->if_snd);
d288 1
a288 1
		senderr(ENOBUFS);
d290 1
a290 2
	ifp->if_obytes += m->m_pkthdr.len;
	IF_ENQUEUE(&ifp->if_snd, m);
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.8 2001/12/09 13:09:13 jason Exp $	*/
d71 1
a71 1
static struct mbuf *arc_defrag(struct ifnet *, struct mbuf *);
d104 1
a104 1
	int			s, error, newencoding, len;
a106 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a138 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

a211 1
			len = m->m_pkthdr.len;
d217 2
a218 3
			IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
			if (error) {
				/* mbuf is already freed */
d220 1
a220 1
				return (error);
d222 2
a223 1
			ifp->if_obytes += len;
a269 1
	len = m->m_pkthdr.len;
d275 2
a276 3
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		/* mbuf is already freed */
d278 1
a278 1
		return (error);
d280 2
a281 1
	ifp->if_obytes += len;
@


1.8.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.8.2.1 2002/06/11 03:30:45 art Exp $	*/
d110 1
a110 1
		return (ENETDOWN); /* m, m1 aren't initialized yet */
d430 1
a430 1
				return (m1);
d554 2
d574 10
a583 3
	if_alloc_sadl(ifp);
	bcopy((caddr_t)&((struct arccom *)ifp)->ac_anaddr,
	      LLADDR(ifp->if_sadl), ifp->if_addrlen);
@


1.8.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
d140 6
d225 1
a225 1
			IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
@


1.7
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.6 2001/05/11 17:20:09 aaron Exp $	*/
d565 1
a565 2
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	    ifa = ifa->ifa_list.tqe_next)
d574 1
@


1.6
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.5 1997/02/24 13:33:57 niklas Exp $	*/
a115 1
	ifp->if_lastchange = time;
a484 1
	ifp->if_lastchange = time;
@


1.5
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.8 1996/05/07 02:40:29 thorpej Exp $	*/
d251 1
a251 1
			if (m == 0)
@


1.5.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.5 1997/02/24 13:33:57 niklas Exp $	*/
d116 1
d251 1
a251 1
			if (m == NULL)
d486 1
@


1.5.14.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d565 2
a566 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a574 1
	}
@


1.5.14.3
log
@Merge in -current from roughly a week ago
@
text
@d71 1
a71 1
static struct mbuf *arc_defrag(struct ifnet *, struct mbuf *);
d104 1
a104 1
	int			s, error, newencoding, len;
a106 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a138 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

a211 1
			len = m->m_pkthdr.len;
d217 2
a218 3
			IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
			if (error) {
				/* mbuf is already freed */
d220 1
a220 1
				return (error);
d222 2
a223 1
			ifp->if_obytes += len;
a269 1
	len = m->m_pkthdr.len;
d275 2
a276 3
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		/* mbuf is already freed */
d278 1
a278 1
		return (error);
d280 2
a281 1
	ifp->if_obytes += len;
@


1.5.14.4
log
@Sync the SMP branch with 3.3
@
text
@d107 1
d110 1
a110 1
		return (ENETDOWN); /* m, m1 aren't initialized yet */
d140 6
d225 1
a225 1
			IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d430 1
a430 1
				return (m1);
d554 2
d574 10
a583 3
	if_alloc_sadl(ifp);
	bcopy((caddr_t)&((struct arccom *)ifp)->ac_anaddr,
	      LLADDR(ifp->if_sadl), ifp->if_addrlen);
@


1.5.14.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_arcsubr.c,v 1.5.14.4 2003/03/28 00:41:28 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.14.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 1
a76 1
#error The arc_phdsmtu is ARC_PHDSMTU, but must not exceed 60480.
d91 1
a91 1
	struct ifnet *ifp;
d99 1
a99 1
	struct arc_header *ah;
d148 1
a148 2
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    m_tag_find(m, PACKET_TAG_PF_ROUTED, NULL) == NULL)
d466 2
a467 2
	struct arc_header *ah;
	struct ifqueue *inq;
d525 1
a525 1
	u_int8_t *ap;
d528 1
a528 1
	char *cp = arcbuf;
d541 1
a541 1
	struct ifnet *ifp;
d543 1
a543 1
	struct arccom *ac;
@


1.5.14.7
log
@Merge with the trunk
@
text
@d512 5
a516 1
	IF_INPUT_ENQUEUE(inq, m);
@


1.4
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: if_arcsubr.c,v 1.7 1996/04/15 14:01:25 is Exp $	*/
d171 1
a171 1
		printf("%s%d: can't handle af%d\n", ifp->if_name, ifp->if_unit,
d437 2
a438 2
	log(LOG_INFO,"%s%d: got out of seq. packet: %s\n",
	    ifp->if_name, ifp->if_unit, s);
d555 2
a556 2
		    "%s%d: arc_phdsmtu is %d, but must not exceed 60480",
		    ifp->if_name, ifp->if_unit, arc_phdsmtu);
d563 2
a564 2
		log(LOG_ERR,"%s%d: link address 0 reserved for broadcasts.  Please change it and ifconfig %s%d down up\n",
		   ifp->if_name,ifp->if_unit,ifp->if_name,ifp->if_unit); 
@


1.2
log
@miscellanous if_arcsubr.c cleanup and optimizations; from is@@beverly.rhein.de; netbsd pr#1825
@
text
@d1 1
a1 1
/*	$NetBSD: if_arcsubr.c,v 1.6 1995/12/24 03:03:55 mycroft Exp $	*/
d108 1
a108 1
		senderr(ENETDOWN);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_arcsubr.c,v 1.5 1995/07/12 08:27:26 cgd Exp $	*/
d46 1
d48 2
a50 1
#include <sys/errno.h>
a69 2
/* why isnt this in /sys/sys/mbuf.h?? */
extern struct mbuf *m_split __P((struct mbuf *, int, int));
a102 1
	int			off, len;
d107 1
a107 1
	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
a112 1
	len = m->m_pkthdr.len;
d116 1
a116 1
	if (rt = rt0) {
d118 1
a118 1
			if (rt0 = rt = rtalloc1(dst, 1))
a153 1
		off = m->m_pkthdr.len - m->m_len;
d191 2
a192 2
		tfrags = (len + 503) / 504;
		fsflag = 2*tfrags-3;
a204 4
			m = m_pullup(m,ARC_HDRNEWLEN);
			if (m == 0)
				senderr(ENOBUFS);

d222 1
a227 3
			/* we don't count the hardwares lenght bytes here */
			ifp->if_obytes += 504 + ARC_HDRNEWLEN;

a228 1
			len -= 504;
a236 4
		m = m_pullup(m, ARC_HDRNEWLEN);
		if (m == 0)
			senderr(ENOBUFS);

d240 1
a240 1
		ah->arc_seqid= ac->ac_seqid;
d244 2
a245 3
		if ((len >= ARC_MIN_FORBID_LEN - ARC_HDRNEWLEN + 2) &&
		    (len <= ARC_MAX_FORBID_LEN - ARC_HDRNEWLEN + 2)) {

a248 1
				
a251 1

d255 1
a255 2
			ah->arc_seqid= 0xFFFF;
			len += 4;
d258 2
a259 20
		ah->arc_dhost= adst;
		ah->arc_shost= ac->ac_anaddr;

		s = splimp();
		/*
		 * Queue message on interface, and start output if interface
		 * not yet active.
		 */
		if (IF_QFULL(&ifp->if_snd)) {
			IF_DROP(&ifp->if_snd);
			splx(s);
			senderr(ENOBUFS);
		}
		IF_ENQUEUE(&ifp->if_snd, m);
		if ((ifp->if_flags & IFF_OACTIVE) == 0)
			(*ifp->if_start)(ifp);
		splx(s);
	
		ifp->if_obytes += len + ARC_HDRNEWLEN;
		
d266 11
a276 15
		ah->arc_dhost= adst;
		ah->arc_shost= ac->ac_anaddr;
		s = splimp();
		/*
		 * Queue message on interface, and start output if interface
		 * not yet active.
		 */
		if (IF_QFULL(&ifp->if_snd)) {
			IF_DROP(&ifp->if_snd);
			splx(s);
			senderr(ENOBUFS);
		}
		IF_ENQUEUE(&ifp->if_snd, m);
		if ((ifp->if_flags & IFF_OACTIVE) == 0)
			(*ifp->if_start)(ifp);
d278 1
a278 2
	
		ifp->if_obytes += len + ARC_HDRLEN;
d280 6
d452 1
a452 1
	int type;
d497 1
a497 1
		m_adj(m,ARC_HDRNEWLEN);
d503 1
a503 1
		m_adj(m,ARC_HDRLEN);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
