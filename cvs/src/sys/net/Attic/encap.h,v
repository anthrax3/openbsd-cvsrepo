head	1.14;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	UBC_SYNC_A:1.14
	UBC_SYNC_B:1.14
	SMP:1.14.0.2
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	99.02.24.22.36.21;	author angelos;	state dead;
branches;
next	1.13;

1.13
date	98.05.24.14.13.59;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.05.18.21.10.18;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.11.04.09.10.54;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.07.27.23.30.32;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.07.15.23.11.09;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.07.14.08.46.40;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.07.11.23.37.52;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.07.02.06.58.40;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.07.01.22.12.40;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.06.25.07.53.20;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.06.17.23.25.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.02.24.13.33.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.40;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Not used anymore.
@
text
@/*	$OpenBSD: encap.h,v 1.13 1998/05/24 14:13:59 provos Exp $	*/

/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * encap.h
 *
 * Declarations useful in the encapsulation code.
 */

/* Sysctl definitions */

#define ENCAPCTL_ENCDEBUG	1
#define ENCAPCTL_MAXID		2

#define ENCAPCTL_NAMES {\
	{ 0, 0 }, \
	{ "encdebug", CTLTYPE_INT }, \
}

/*
 * Definitions for encapsulation-related phenomena.
 *
 * A lot of encapsulation protocols (ipip, swipe, ip_encap, ipsp, etc.)
 * select their tunnel based on the destination (and sometimes the source)
 * of the packet. The encap address/protocol family provides a generic
 * mechanism for specifying tunnels.
 */

/*
 * A tunnel is characterized by which source/destination address pairs
 * (with netmasks) it is valid for (the "destination" as far as the
 * routing code is concerned), and what the source (local) and destination
 * (remote) endpoints of the tunnel, and the SPI, should be (the "gateway"
 * as far as the routing code is concerned.
 */
  
struct sockaddr_encap
{
    u_int8_t	sen_len;		/* length */
    u_int8_t	sen_family;		/* AF_ENCAP */
    u_int16_t	sen_type;		/* see SENT_* */
    union
    {
	u_int8_t	Data[16];	/* other stuff mapped here */

	struct				/* SENT_IP4 */
	{
	    struct in_addr Src;
	    struct in_addr Dst;
	    u_int16_t Sport;
	    u_int16_t Dport;
	    u_int8_t Proto;
	    u_int8_t Filler[3];
	} Sip4;

	struct				/* SENT_IPSP */
	{
	    struct in_addr Dst;
	    u_int32_t Spi;
	    u_int8_t Sproto;
	    u_int8_t Filler[7];
	} Sipsp;
    } Sen;
};

#define PFENCAP_VERSION_0	0
#define PFENCAP_VERSION_1	1

#define sen_data	Sen.Data
#define sen_ip_src	Sen.Sip4.Src
#define sen_ip_dst	Sen.Sip4.Dst
#define sen_proto	Sen.Sip4.Proto
#define sen_sport	Sen.Sip4.Sport
#define sen_dport	Sen.Sip4.Dport
#define sen_ipsp_dst	Sen.Sipsp.Dst
#define sen_ipsp_spi	Sen.Sipsp.Spi
#define sen_ipsp_sproto	Sen.Sipsp.Sproto

/*
 * The "type" is really part of the address as far as the routing
 * system is concerned. By using only one bit in the type field
 * for each type, we sort-of make sure that different types of
 * encapsulation addresses won't be matched against the wrong type.
 * 
 */

#define SENT_IP4	0x0001		/* data is two struct in_addr */
#define SENT_IPSP	0x0002		/* data as in IP4 plus SPI */

/*
 * SENT_HDRLEN is the length of the "header"
 * SENT_*_LEN are the lengths of various forms of sen_data
 * SENT_*_OFF are the offsets in the sen_data array of various fields
 */

#define SENT_HDRLEN	(2 * sizeof(u_int8_t) + sizeof(u_int16_t))

#define SENT_IP4_SRCOFF	(0)
#define SENT_IP4_DSTOFF (sizeof (struct in_addr))

#define SENT_IP4_LEN	20
#define SENT_IPSP_LEN	20

/*
 * For encapsulation routes are possible not only for the destination
 * address but also for the protocol, source and destination ports
 * if available
 */

struct route_enc {
    struct rtentry *re_rt;
    struct sockaddr_encap re_dst;
};

/*
 * Tunnel descriptors are setup and torn down using a socket of the 
 * AF_ENCAP domain. The following defines the messages that can
 * be sent down that socket.
 */
struct encap_msghdr
{
    u_int16_t	em_msglen;		/* message length */
    u_int8_t	em_version;		/* for future expansion */
    u_int8_t	em_type;		/* message type */
    u_int32_t   foo;                    /* Alignment to 64 bit */
    union
    {
	/* 
	 * This is used to set/change the attributes of an SPI. If oSrc and
	 * oDst are set to non-zero values, the SPI will also do IP-in-IP
	 * encapsulation (tunneling). If only one of them is set, an error
	 * is returned. Both zero implies transport mode.
	 */
	struct
	{
	    u_int32_t      Spi;		/* SPI */
	    int32_t        Alg;		/* Algorithm to use */
	    struct in_addr Dst;		/* Destination address */
	    struct in_addr Src;		/* This is used to set our source
					 * address when the outgoing packet
				         * does not have a source address 
					 * (is zero). */
	    struct in_addr oSrc;	 /* Outter header source address */
	    struct in_addr oDst;	 /* Same, for destination address */
	    u_int64_t      First_Use_Hard; /* Expire relative to first use */
	    u_int64_t      First_Use_Soft;
	    u_int64_t      Expire_Hard;	/* Expire at fixed point in time */
	    u_int64_t      Expire_Soft;
	    u_int64_t      Bytes_Hard;	/* Expire after bytes recved/sent */
	    u_int64_t      Bytes_Soft;
	    u_int64_t      Packets_Hard; /* Expire after packets recved/sent */
	    u_int64_t      Packets_Soft;
	    int32_t	   TTL;		/* When tunneling, what TTL to use.
					 * If set to IP4_SAME_TTL, the ttl
					 * from the encapsulated packet will
					 * be copied. If set to IP4_DEFAULT_TTL,
					 * the system default TTL will be used.
					 * If set to anything else, then the
					 * ttl used will be TTL % 256 */
	    u_int16_t      Satype;
	    u_int8_t       Sproto;	/* ESP or AH */
	    u_int8_t	   Foo;		/* Alignment */
	    u_int8_t       Dat[1];	/* Data */
	} Xfm;

	/*
 	 * For expiration notifications, the kernel fills in
	 * Notification_Type, Spi, Dst and Sproto, Src and Satype.
  	 * No direct response is expected.
	 *
 	 * For SA Requests, the kernel fills in
	 * Notification_Type, MsgID, Dst, Satype, (and optionally
	 * Protocol, Src, Sport, Dport and UserID).
 	 *
	 */
	struct				/* kernel->userland notifications */
	{
	    u_int32_t      Notification_Type;
	    u_int32_t      MsgID;	/* Request ID */
	    u_int32_t      Spi;		
	    struct in_addr Dst;		/* Peer */
	    struct in_addr Src;		/* Might have our local address */
	    u_int16_t      Sport;	/* Source port */
            u_int16_t      Dport;	/* Destination port */
	    u_int8_t       Protocol;	/* Transport protocol */
	    u_int8_t       Sproto;	/* IPsec protocol */
	    u_int16_t      Satype;	/* SA type */
	    u_int32_t      Foo;		/* Alignment */
	    u_int8_t       UserID[1];	/* Might be used to indicate user */
	} Notify;

	/* Link two SPIs */
	struct
	{
	    u_int32_t        Spi;	/* SPI */
	    u_int32_t        Spi2;
	    struct in_addr   Dst;	/* Dest */
	    struct in_addr   Dst2;
	    u_int8_t	     Sproto; 	/* IPsec protocol */
	    u_int8_t	     Sproto2;
	} Rel;

	/* Enable/disable an SA for a session */
	struct
	{
	    u_int32_t      Spi;
	    struct in_addr Dst;
	    struct in_addr iSrc;	/* Source... */
	    struct in_addr iDst;	/* ...and destination in inner IP */
	    struct in_addr iSmask;	/* Source netmask */
	    struct in_addr iDmask;	/* Destination netmask */
	    u_int16_t	   Sport; 	/* Source port, if applicable */
	    u_int16_t	   Dport;	/* Destination port, if applicable */
	    u_int8_t       Protocol;	/* Transport mode for which protocol */
	    u_int8_t 	   Sproto;	/* IPsec protocol */
	    u_int16_t	   Flags;
	    u_int32_t      Spi2;	/* Used in REPLACESPI... */
	    struct in_addr Dst2;	/* ...to specify which SPI is... */
	    u_int8_t       Sproto2;	/* ...replaced. */
	} Ena;

	/* For general use: (in)validate, delete (chain), reserve */
	struct 
	{
	    u_int32_t       Spi;
	    struct in_addr  Dst;
	    u_int8_t	    Sproto;
	} Gen;
    } Eu;
};

#define ENABLE_FLAG_REPLACE    	1	/* Replace existing flow with new */
#define ENABLE_FLAG_LOCAL      	2	/* Add routes for 0.0.0.0 */
#define ENABLE_FLAG_MODIFY     	4	/* Keep routing masks */

#define ENCAP_MSG_FIXED_LEN    	(2 * sizeof(u_int32_t))

#define NOTIFY_SOFT_EXPIRE     	0	/* Soft expiration of SA */
#define NOTIFY_HARD_EXPIRE     	1	/* Hard expiration of SA */
#define NOTIFY_REQUEST_SA      	2	/* Establish an SA */

#define NOTIFY_SATYPE_CONF	1	/* SA should do encryption */
#define NOTIFY_SATYPE_AUTH	2	/* SA should do authentication */
#define NOTIFY_SATYPE_TUNNEL	4	/* SA should use tunneling */

#define em_ena_spi	  Eu.Ena.Spi
#define em_ena_dst	  Eu.Ena.Dst
#define em_ena_isrc	  Eu.Ena.iSrc
#define em_ena_idst	  Eu.Ena.iDst
#define em_ena_ismask	  Eu.Ena.iSmask
#define em_ena_idmask	  Eu.Ena.iDmask
#define em_ena_sport	  Eu.Ena.Sport
#define em_ena_dport	  Eu.Ena.Dport
#define em_ena_protocol   Eu.Ena.Protocol
#define em_ena_sproto	  Eu.Ena.Sproto
#define em_ena_flags	  Eu.Ena.Flags

#define em_gen_spi        Eu.Gen.Spi
#define em_gen_dst        Eu.Gen.Dst
#define em_gen_sproto	  Eu.Gen.Sproto

#define em_not_type       Eu.Notify.Notification_Type
#define em_not_spi        Eu.Notify.Spi
#define em_not_dst        Eu.Notify.Dst
#define em_not_src	  Eu.Notify.Src
#define em_not_satype     Eu.Notify.Satype
#define em_not_userid     Eu.Notify.UserID
#define em_not_msgid      Eu.Notify.MsgID
#define em_not_sport      Eu.Notify.Sport
#define em_not_dport      Eu.Notify.Dport
#define em_not_protocol   Eu.Notify.Protocol
#define em_not_sproto	  Eu.Notify.Sproto

#define em_spi	          Eu.Xfm.Spi
#define em_dst	          Eu.Xfm.Dst
#define em_src	          Eu.Xfm.Src
#define em_osrc	          Eu.Xfm.oSrc
#define em_odst	          Eu.Xfm.oDst
#define em_alg	          Eu.Xfm.Alg
#define em_dat	          Eu.Xfm.Dat
#define em_first_use_hard Eu.Xfm.First_Use_Hard
#define em_first_use_soft Eu.Xfm.First_Use_Soft
#define em_expire_hard    Eu.Xfm.Expire_Hard
#define em_expire_soft    Eu.Xfm.Expire_Soft
#define em_bytes_hard     Eu.Xfm.Bytes_Hard
#define em_bytes_soft     Eu.Xfm.Bytes_Soft
#define em_packets_hard   Eu.Xfm.Packets_Hard
#define em_packets_soft   Eu.Xfm.Packets_Soft
#define em_ttl		  Eu.Xfm.TTL
#define em_sproto	  Eu.Xfm.Sproto
#define em_satype         Eu.Xfm.Satype

#define em_rel_spi	  Eu.Rel.Spi
#define em_rel_spi2	  Eu.Rel.Spi2
#define em_rel_dst	  Eu.Rel.Dst
#define em_rel_dst2	  Eu.Rel.Dst2
#define em_rel_sproto	  Eu.Rel.Sproto
#define em_rel_sproto2	  Eu.Rel.Sproto2

#define EMT_SETSPI	1		/* Set SPI properties */
#define EMT_GRPSPIS	2		/* Group SPIs */
#define EMT_DELSPI	3		/* delete an SPI */
#define EMT_DELSPICHAIN 4		/* delete an SPI chain starting from */
#define EMT_RESERVESPI  5		/* Give us an SPI */
#define EMT_ENABLESPI   6		/* Enable an SA */
#define EMT_DISABLESPI  7		/* Disable an SA */
#define EMT_NOTIFY      8		/* kernel->userland key mgmt not. */
#define EMT_REPLACESPI  10		/* Replace all uses of an SA */

/* Total packet lengths */
#define EMT_SETSPI_FLEN	      104
#define EMT_GRPSPIS_FLEN      26
#define EMT_GENLEN            17
#define EMT_DELSPI_FLEN       EMT_GENLEN
#define EMT_DELSPICHAIN_FLEN  EMT_GENLEN
#define EMT_RESERVESPI_FLEN   EMT_GENLEN
#define EMT_NOTIFY_FLEN       40
#define EMT_ENABLESPI_FLEN    49
#define EMT_DISABLESPI_FLEN   EMT_ENABLESPI_FLEN
#define EMT_REPLACESPI_FLEN   EMT_ENABLESPI_FLEN

#ifdef _KERNEL
extern struct ifaddr *encap_findgwifa(struct sockaddr *);
extern struct ifnet enc_softc;
#endif
@


1.13
log
@add support for Virtual Private Networks (VPN).
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.12 1998/05/18 21:10:18 provos Exp $	*/
@


1.12
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.11 1997/11/04 09:10:54 provos Exp $	*/
d264 3
a266 2
#define ENABLE_FLAG_REPLACE    	1
#define ENABLE_FLAG_LOCAL      	2
@


1.11
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.10 1997/07/27 23:30:32 niklas Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
d137 11
d273 3
a275 3
#define NOTIFY_SATYPE_CONF	0	/* SA should do encryption */
#define NOTIFY_SATYPE_AUTH	1	/* SA should do authentication */
#define NOTIFY_SATYPE_TUNNEL	2	/* SA should use tunneling */
d296 1
@


1.10
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.9 1997/07/15 23:11:09 provos Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
@


1.9
log
@flags for tunnels and replacing existing routes, sysctl! + tiny bug fix
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.8 1997/07/14 08:46:40 provos Exp $	*/
a155 2
	    u_int64_t      Relative_Hard; /* Expire relative to creation */
	    u_int64_t      Relative_Soft;
d171 1
d173 1
a173 1
	    u_int8_t	   Foo[3];	/* Alignment */
d179 1
a179 1
	 * Notification_Type, Spi, Dst and Sproto. 
d183 1
a183 1
	 * Notification_Type, MsgID, Seclevel, Dst, SAType, (and optionally
a185 5
	 * The response should have the same values in all the fields
	 * and:
	 * Spi will hold the SPI for the three seclevels
	 * Sproto will hold the IPsec protocol used (AH/ESP)
	 * UserID can optionally hold the peer's UserID (if applicable)
a191 1
	    u_int32_t      SAType;	/* What do we want for this SA */
d198 2
a199 1
	    u_int8_t       Foo[2];	/* Alignment */
a211 1
	    u_int16_t	     Foo;
d228 3
a238 1
   	    u_int8_t	    Foo[3];
d275 1
a275 1
#define em_not_satype     Eu.Notify.SAType
a289 2
#define em_relative_hard  Eu.Xfm.Relative_Hard
#define em_relative_soft  Eu.Xfm.Relative_Soft
d300 1
d317 1
a317 2
#define EMT_VALIDATE    9		/* Make an SPI valid for use */
#define EMT_INVALIDATE  10		/* Make an SPI invalid for use */
d320 3
a322 3
#define EMT_SETSPI_FLEN	      120
#define EMT_GRPSPIS_FLEN      28
#define EMT_GENLEN            20
a325 2
#define EMT_VALIDATE_FLEN     EMT_GENLEN
#define EMT_INVALIDATE_FLEN   EMT_GENLEN
d327 1
a327 1
#define EMT_ENABLESPI_FLEN    40
d329 1
@


1.8
log
@sysctl...
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.7 1997/07/11 23:37:52 provos Exp $	*/
d234 1
a234 1
	    u_int8_t       Foo[2];	/* Alignment */
d248 4
a251 1
#define ENCAP_MSG_FIXED_LEN    (2 * sizeof(u_int32_t))
d253 7
a259 3
#define NOTIFY_SOFT_EXPIRE     0	/* Soft expiration of SA */
#define NOTIFY_HARD_EXPIRE     1	/* Hard expiration of SA */
#define NOTIFY_REQUEST_SA      2	/* Establish an SA */
d271 1
@


1.7
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.6 1997/07/02 06:58:40 provos Exp $	*/
d31 10
@


1.6
log
@fix neglected _FLEN's + reserve_spi + output reserved spi's without alg.
correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.5 1997/07/01 22:12:40 provos Exp $	*/
d72 2
a73 1
	    u_int8_t Filler[8];
d89 1
d141 5
a145 6
					 * address when doing tunneling and
					 * the outgoing packet does not
					 * have a source address (is zero) */
	    struct in_addr oSrc;	/* Source... */
	    struct in_addr oDst;	/* ...and destination in outter IP
					 * header, if we're doing IP-in-IP */
d163 2
a164 4
	    u_int16_t	   Sport; 	/* Source port, if applicable */
	    u_int16_t	   Dport;	/* Destination port, if applicable */
  	    u_int8_t	   Proto;	/* Protocol, if applicable */
	    u_int8_t	   foo[3];	/* Alignment */
d170 2
a171 1
	 * Notification_Type, Spi and Dst. No direct response is expected.
d174 1
a174 1
	 * Notification_Type, MsgID, Spi, Seclevel, Dst (and optionally
d179 2
a180 1
	 * Spi/Spi2/Spi3 will hold the SPIs for the three seclevels
d188 1
a188 4
	    u_int32_t      Spi2;
	    u_int32_t      Spi3;
	    u_int8_t       Seclevel[3];	/* see netinet/in_pcb.h */
	    u_int8_t       Protocol;	/* Transport mode for which protocol */
d193 3
d202 7
a208 4
	    u_int32_t        emr_spi;	/* SPI */
	    u_int32_t        emr_spi2;
	    struct in_addr   emr_dst;	/* Dest */
	    struct in_addr   emr_dst2;
d211 17
a227 1
	/* For general use */
d230 4
a233 2
	    u_int32_t       emg_spi;
	    struct in_addr  emg_dst;
d238 1
a238 3
#define  NOTIFY_SOFT_EXPIRE     0	/* Soft expiration of SA */
#define  NOTIFY_HARD_EXPIRE     1	/* Hard expiration of SA */
#define  NOTIFY_REQUEST_SA      2	/* Establish an SA */
d240 18
a257 2
#define em_gen_spi        Eu.Gen.emg_spi
#define em_gen_dst        Eu.Gen.emg_dst
a260 2
#define em_not_spi2       Eu.Notify.Spi2
#define em_not_spi3       Eu.Notify.Spi3
d262 1
a262 1
#define em_not_seclevel   Eu.Notify.Seclevel
d268 1
d273 2
a274 3
#define em_osrc           Eu.Xfm.oSrc
#define em_odst           Eu.Xfm.oDst
#define em_if	          Eu.Xfm.If
d288 8
a295 8
#define em_proto	  Eu.Xfm.Proto
#define em_sport	  Eu.Xfm.Sport
#define em_dport	  Eu.Xfm.Dport

#define em_rel_spi	  Eu.Rel.emr_spi
#define em_rel_spi2	  Eu.Rel.emr_spi2
#define em_rel_dst	  Eu.Rel.emr_dst
#define em_rel_dst2	  Eu.Rel.emr_dst2
d298 1
a298 1
#define EMT_GRPSPIS	2		/* Group SPIs (output order)  */
d305 2
d309 3
a311 3
#define EMT_SETSPI_FLEN	      124
#define EMT_GRPSPIS_FLEN      24
#define EMT_GENLEN            16
a313 2
#define EMT_ENABLESPI_FLEN    EMT_GENLEN
#define EMT_DISABLESPI_FLEN   EMT_GENLEN
d315 5
a319 1
#define EMT_NOTIFY_FLEN       44
@


1.5
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.4 1997/06/25 07:53:20 provos Exp $	*/
d274 2
a275 2
#define EMT_GRPSPIS_FLEN      20
#define EMT_GENLEN            12
d281 1
a281 1
#define EMT_NOTIFY_FLEN       40
@


1.4
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.3 1997/06/17 23:25:54 deraadt Exp $	*/
a48 1

d57 2
a58 13
	struct sockaddr Dfl;	/* SENT_DEFIF */
	struct			/* SENT_SA */
	{
	    struct sockaddr Src;
	    struct sockaddr Dst;
	} Sa;
#ifdef INET
	struct			/* SENT_SAIN */
	{
	    struct sockaddr_in Src;
	    struct sockaddr_in Dst;
	} Sin;
	struct			/* SENT_IP4 */
d67 2
a68 1
	struct			/* SENT_IPSP */
a69 1
	    struct in_addr Src;
d72 1
a72 2
	    u_int8_t Ifn;
	    u_int8_t Filler[3];
a73 2
	
#endif
d77 3
a80 6
#define sen_dfl		Sen.Dfl
#define sen_sa_src	Sen.Sa.Src
#define sen_sa_dst	Sen.Sa.Dst
#ifdef INET
#define sen_sin_src	Sen.Sin.Src
#define sen_sin_dst	Sen.Sin.Dst
a82 4
#define sen_ipsp_src	Sen.Sipsp.Src
#define sen_ipsp_dst	Sen.Sipsp.Dst
#define sen_ipsp_spi	Sen.Sipsp.Spi
#define sen_ipsp_ifn	Sen.Sipsp.Ifn
d86 2
a87 1
#endif
d97 2
a98 5
#define SENT_DEFIF	0x0001		/* data is a default sockaddr for if */
#define SENT_SA		0x0002		/* data is two struct sockaddr */
#define SENT_SAIN	0x0004		/* data is two struct sockaddr_in */
#define SENT_IP4	0x0008		/* data is two struct in_addr */
#define SENT_IPSP	0x0010		/* data as in IP4 plus SPI and if# */
d106 1
a106 3
#define SENT_HDRLEN	(2*sizeof(u_int8_t)+sizeof(u_int16_t))

#define SENT_DEFIF_LEN	(SENT_HDRLEN + sizeof (struct sockaddr_in))
a109 1
#define SENT_IP4_OPTOFF	(2*sizeof(struct in_addr)+2*sizeof(u_int16_t)+sizeof(u_int8_t)+3*sizeof(u_int8_t))
d111 2
a112 24
#define SENT_IP4_LEN	(SENT_HDRLEN + SENT_IP4_OPTOFF)

#define SENT_IPSP_LEN	(SENT_HDRLEN + 2 * sizeof (struct in_addr) + sizeof (u_int32_t) + 4)

/*
 * Options 0x00 and 01 are 1-byte options (no arguments).
 * The rest of the options are T-L-V fields, where the L includes
 * the T and L bytes; thus, the minimum length for an option with
 * no arguments is 2. An option of length less than 2 causes en EINVAL
 */
 

#define SENO_EOL	0x00		/* End of Options, or placeholder */
#define SENO_NOP	0x01		/* No Operation. Skip */
#define SENO_NAME	0x02		/* tunnel name, NUL-terminated */
#define SENO_SPI	0x03		/* Security Parameters Index */
#define SENO_IFN	0x04		/* Encap interface number */
#define SENO_IFIP4A	0x05		/* Encap interface IPv4 address */
#define SENO_IPSA	0x06		/* Encap interface generic sockaddr */

struct enc_softc
{
	struct ifnet enc_if;
};
a118 4

#define EM_MAXRELSPIS	4		/* at most five chained xforms */
	

d124 1
d127 6
d135 2
a136 8
	    struct in_addr Ia;
	    u_int8_t	Ifn;
	    u_int8_t  xxx[3];		/* makes life a lot easier */
	} Ifa;
	
	struct
	{
	    u_int32_t Spi;		/* SPI */
d138 29
a166 13
	    u_int64_t Relative_Hard;	/* Expire relative to creation */
	    u_int64_t Relative_Soft;
	    u_int64_t First_Use_Hard;	/* Expire relative to first use */
	    u_int64_t First_Use_Soft;
	    u_int64_t Expire_Hard;	/* Expire at fixed point in time */
	    u_int64_t Expire_Soft;
	    u_int64_t Bytes_Hard;	/* Expire after bytes recved/sent */
	    u_int64_t Bytes_Soft;
	    u_int64_t Packets_Hard;	/* Expire after packets recved/sent */
	    u_int64_t Packets_Soft;
	    u_int32_t If;		/* enc i/f for input */
	    int32_t Alg;		/* Algorithm to use */
	    u_int8_t Dat[1];		/* Data */
d184 7
a190 10
	    u_int32_t Notification_Type;
#define  NOTIFY_SOFT_EXPIRE     0	/* Soft expiration of SA */
#define  NOTIFY_HARD_EXPIRE     1	/* Hard expiration of SA */
#define  NOTIFY_REQUEST_SA      2	/* Establish an SA */
	    u_int32_t MsgID;		/* Request ID */
	    u_int32_t Spi;		
	    u_int32_t Spi2;
	    u_int32_t Spi3;
	    u_int8_t Seclevel[3];	/* see netinet/in_pcb.h */
	    u_int8_t Protocol;		/* Transport mode for which protocol */
d193 3
a195 3
	    u_int16_t Sport;		/* Source port */
            u_int16_t Dport;		/* Destination port */
	    u_int8_t UserID[1];		/* Might be used to indicate user */
d197 2
a198 1
	
d201 12
a212 5
	    u_int32_t emr_spi;		/* SPI */
	    struct in_addr emr_dst;	/* Dest */
	    struct tdb *emr_tdb;	/* used internally! */
	    
	} Rel[EM_MAXRELSPIS];
d216 27
a242 21
#define em_not_type      Eu.Notify.Notification_Type
#define em_not_spi       Eu.Notify.Spi
#define em_not_spi2      Eu.Notify.Spi2
#define em_not_spi3      Eu.Notify.Spi3
#define em_not_src       Eu.Notify.Src
#define em_not_dst       Eu.Notify.Dst
#define em_not_seclevel  Eu.Notify.Seclevel
#define em_not_userid    Eu.Notify.UserID
#define em_not_msgid     Eu.Notify.MsgID
#define em_not_sport     Eu.Notify.Sport
#define em_not_dport     Eu.Notify.Dport
#define em_not_protocol  Eu.Notify.Protocol

#define em_ifa	Eu.Ifa.Ia
#define em_ifn	Eu.Ifa.Ifn

#define em_spi	Eu.Xfm.Spi
#define em_dst	Eu.Xfm.Dst
#define em_if	Eu.Xfm.If
#define em_alg	Eu.Xfm.Alg
#define em_dat	Eu.Xfm.Dat
d253 29
a281 19

#define em_rel	Eu.Rel

#define EMT_IFADDR	1		/* set enc if addr */
#define EMT_SETSPI	2		/* Set SPI properties */
#define EMT_GRPSPIS	3		/* Group SPIs (output order)  */
#define EMT_DELSPI	4		/* delete an SPI */
#define EMT_DELSPICHAIN 5		/* delete an SPI chain starting from */
#define EMT_RESERVESPI  6		/* Give us an SPI */
#define EMT_ENABLESPI   7		/* Enable an SA */
#define EMT_DISABLESPI  8		/* Disable an SA */
#define EMT_NOTIFY      9		/* kernel->userland key mgmt not. */

#define EM_MINLEN	8		/* count!!! */
#define EMT_IFADDR_LEN	12
#define EMT_SETSPI_FLEN	20
#define EMT_GRPSPIS_FLEN 4
#define EMT_DELSPI_FLEN 20
#define EMT_DELSPICHAIN_FLEN 20
d285 1
a285 2
extern struct enc_softc *enc_softc;
extern int32_t nencap;
@


1.3
log
@check em_if and em_ifn better; thanks adam@@math.tau.ac.il
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.h,v 1.2 1997/02/24 13:33:56 niklas Exp $	*/
d52 12
a63 12
	u_int8_t	sen_len;		/* length */
	u_int8_t	sen_family;		/* AF_ENCAP */
	u_int16_t	sen_type;		/* see SENT_* */
	union
	{
		u_int8_t	Data[16];	/* other stuff mapped here */
		struct sockaddr Dfl;	/* SENT_DEFIF */
		struct			/* SENT_SA */
		{
			struct sockaddr Src;
			struct sockaddr Dst;
		} Sa;
d65 23
a87 22
		struct			/* SENT_SAIN */
		{
			struct sockaddr_in Src;
			struct sockaddr_in Dst;
		} Sin;
		struct			/* SENT_IP4 */
		{
			struct in_addr Src;
			struct in_addr Dst;
			u_int16_t Sport;
			u_int16_t Dport;
			u_int8_t Proto;
			u_int8_t Filler[3];
		} Sip4;
		struct			/* SENT_IPSP */
		{
			struct in_addr Src;
			struct in_addr Dst;
			u_int32_t Spi;
			u_int8_t Ifn;
			u_int8_t Filler[3];
		} Sipsp;
d89 1
a89 1
	} Sen;
d174 71
a244 29
	u_int16_t	em_msglen;		/* message length */
	u_int8_t	em_version;		/* for future expansion */
	u_int8_t	em_type;		/* message type */
	union
	{
		struct
		{
			struct in_addr Ia;
			u_int8_t	Ifn;
			u_int8_t  xxx[3];	/* makes life a lot easier */
		} Ifa;

		struct
		{
			u_int32_t Spi;	/* SPI */
			struct in_addr Dst; /* Destination address */
			u_int32_t If;		/* enc i/f for input */
			int32_t Alg;	/* Algorithm to use */
			u_int8_t Dat[1];	/* Data */
		} Xfm;
		
		struct
		{
			u_int32_t emr_spi;	/* SPI */
			struct in_addr emr_dst; /* Dest */
			struct tdb * emr_tdb; /* used internally! */
			
		} Rel[EM_MAXRELSPIS];
	} Eu;
d247 13
d268 10
d286 4
@


1.2
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d189 1
a189 1
			int32_t If;		/* enc i/f for input */
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 2
@
