head	1.37;
access;
symbols
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.30.0.8
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.6
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.22
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.6
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.4
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.37
date	2009.08.25.16.16.34;	author jsg;	state dead;
branches;
next	1.36;

1.36
date	2009.07.19.08.16.06;	author blambert;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.22.23.04.45;	author mpf;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.11.22.44.47;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.25.18.50.01;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.30.23.30.50;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.24.00.17.29;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.03.16.10;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.27.06.07.44;	author kjc;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.06.15.03.38.34;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.30.01.02.55;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.26.22.51.01;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.04.22.20.02.43;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	98.02.10.12.00.46;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.09.05.04.27.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.06.20.09.30.55;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.01.20.40.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.24.13.34.01;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.04.01.58.56;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.22.00.35.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.27.11.07.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.07.28.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.48.25;	author deraadt;	state Exp;
branches;
next	;

1.11.4.1
date	2001.05.14.22.40.02;	author niklas;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2001.07.04.10.54.08;	author niklas;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.11.4.4;

1.11.4.4
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.11.4.5;

1.11.4.5
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.11.4.6;

1.11.4.6
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.11.4.7;

1.11.4.7
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.11.4.8;

1.11.4.8
date	2004.06.05.23.11.24;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Remove support for packet mode of Metricom Ricochet radios.
It currently doesn't compile and this is unlikely to change
as there are many alternatives now since we no longer live
in the early 1990s and Metricom went bankrupt some time ago.

ok many @@
@
text
@/*	$OpenBSD: if_strip.c,v 1.36 2009/07/19 08:16:06 blambert Exp $	*/
/*	$NetBSD: if_strip.c,v 1.2.4.3 1996/08/03 00:58:32 jtc Exp $	*/
/*	from: NetBSD: if_sl.c,v 1.38 1996/02/13 22:00:23 christos Exp $	*/

/*
 * Copyright 1996 The Board of Trustees of The Leland Stanford
 * Junior University. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  Stanford University
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 *
 * This driver was contributed by Jonathan Stone.
 *
 * Starmode Radio IP interface (STRIP) for Metricom wireless radio.
 * This STRIP driver assumes address resolution of IP addresses to
 * Metricom MAC addresses is done via local link-level routes.
 * The link-level addresses are entered as an 8-digit packed BCD number.
 * To add a route for a radio at IP address 10.1.2.3, with radio
 * address '1234-5678', reachable via interface st0, use the command 
 *
 *	route add -host 10.1.2.3  -link st0:12:34:56:78
 */


/*
 * Copyright (c) 1987, 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_sl.c	8.6 (Berkeley) 2/1/94
 */

/*
 * Derived from: Serial Line interface written by Rick Adams (rick@@seismo.gov)
 *
 * Rick Adams
 * Center for Seismic Studies
 * 1300 N 17th Street, Suite 1450
 * Arlington, Virginia 22209
 * (703)276-7900
 * rick@@seismo.ARPA
 * seismo!rick
 *
 * Pounded on heavily by Chris Torek (chris@@mimsy.umd.edu, umcp-cs!chris).
 * N.B.: this belongs in netinet, not net, the way it stands now.
 * Should have a link-layer type designation, but wouldn't be
 * backwards-compatible.
 *
 * Converted to 4.3BSD Beta by Chris Torek.
 * Other changes made at Berkeley, based in part on code by Kirk Smith.
 * W. Jolitz added slip abort.
 *
 * Hacked almost beyond recognition by Van Jacobson (van@@helios.ee.lbl.gov).
 * Added priority queuing for "interactive" traffic; hooks for TCP
 * header compression; ICMP filtering (at 2400 baud, some cretin
 * pinging you can use up all your bandwidth).  Made low clist behavior
 * more robust and slightly less likely to hang serial line.
 * Sped up a bunch of things.
 */

#include "strip.h"
#if NSTRIP > 0

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/mbuf.h>
#include <sys/dkstat.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/tty.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/systm.h>
#endif
#include <sys/syslog.h>

#include <machine/cpu.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#else
#error Starmode Radio IP configured without configuring inet?
#endif

#include <net/slcompress.h>
#include <net/if_stripvar.h>
#include <net/slip.h>

#if defined(__NetBSD__) || defined(__OpenBSD__)	/* XXX -- jrs */
typedef u_char ttychar_t;
#else
typedef char ttychar_t;
#endif

#if NBPFILTER > 0
#include <sys/time.h>
#include <net/bpf.h>
#endif

/*
 * SLMAX is a hard limit on input packet size.  To simplify the code
 * and improve performance, we require that packets fit in an mbuf
 * cluster, and if we get a compressed packet, there's enough extra
 * room to expand the header into a max length tcp/ip header (128
 * bytes).  So, SLMAX can be at most
 *	MCLBYTES - 128
 *
 * SLMTU is a hard limit on output packet size.  To insure good
 * interactive response, SLMTU wants to be the smallest size that
 * amortizes the header cost.  Remember that even with
 * type-of-service queuing, we have to wait for any in-progress
 * packet to finish.  I.e., we wait, on the average, 1/2 * mtu /
 * cps, where cps is the line speed in characters per second.
 * E.g., 533ms wait for a 1024 byte MTU on a 9600 baud line.  The
 * average compressed header size is 6-8 bytes so any MTU > 90
 * bytes will give us 90% of the line bandwidth.  A 100ms wait is
 * tolerable (500ms is not), so want an MTU around 296.  (Since TCP
 * will send 256 byte segments (to allow for 40 byte headers), the
 * typical packet size on the wire will be around 260 bytes).  In
 * 4.3tahoe+ systems, we can set an MTU in a route so we do that &
 * leave the interface MTU relatively high (so we don't IP fragment
 * when acting as a gateway to someone using a stupid MTU).
 *
 * Similar considerations apply to SLIP_HIWAT:  It's the amount of
 * data that will be queued 'downstream' of us (i.e., in clists
 * waiting to be picked up by the tty output interrupt).  If we
 * queue a lot of data downstream, it's immune to our t.o.s. queuing.
 * E.g., if SLIP_HIWAT is 1024, the interactive traffic in mixed
 * telnet/ftp will see a 1 sec wait, independent of the mtu (the
 * wait is dependent on the ftp window size but that's typically
 * 1k - 4k).  So, we want SLIP_HIWAT just big enough to amortize
 * the cost (in idle time on the wire) of the tty driver running
 * off the end of its clists & having to call back slstart for a
 * new packet.  For a tty interface with any buffering at all, this
 * cost will be zero.  Even with a totally brain dead interface (like
 * the one on a typical workstation), the cost will be <= 1 character
 * time.  So, setting SLIP_HIWAT to ~100 guarantees that we'll lose
 * at most 1% while maintaining good interactive response.
 */
#if NBPFILTER > 0
#define	BUFOFFSET	(128+sizeof(struct ifnet **)+SLIP_HDRLEN)
#else
#define	BUFOFFSET	(128+sizeof(struct ifnet **))
#endif
#define	SLMAX		(MCLBYTES - BUFOFFSET)
#define	SLBUFSIZE	(SLMAX + BUFOFFSET)
#ifdef SLMTU
#undef SLMTU
#endif
#define SLMTU		1100 /* XXX -- appromaximated. 1024 may be safer. */

#define STRIP_MTU_ONWIRE (SLMTU + 20 + STRIP_HDRLEN) /* (2*SLMTU+2 in sl.c */



#define	SLIP_HIWAT	roundup(50,CBSIZE)

/* This is a NetBSD-1.0 or later kernel. */
#define CCOUNT(q)	((q)->c_cc)


#if !(defined(__NetBSD__) || defined(__OpenBSD__))	/* XXX - cgd */
#define	CLISTRESERVE	1024	/* Can't let clists get too low */
#endif	/* !__NetBSD__ */

/*
 * SLIP ABORT ESCAPE MECHANISM:
 *	(inspired by HAYES modem escape arrangement)
 *	1sec escape 1sec escape 1sec escape { 1sec escape 1sec escape }
 *	within window time signals a "soft" exit from slip mode by remote end
 *	if the IFF_DEBUG flag is on.
 */
#define	ABT_ESC		'\033'	/* can't be t_intr - distant host must know it*/
#define	ABT_IDLE	1	/* in seconds - idle before an escape */
#define	ABT_COUNT	3	/* count of escapes for abort */
#define	ABT_WINDOW	(ABT_COUNT*2+2)	/* in seconds - time to count */

struct st_softc st_softc[NSTRIP];

#define STRIP_FRAME_END		0x0D		/* carriage return */


static int stripinit(struct st_softc *);
static 	struct mbuf *strip_btom(struct st_softc *, int);

/*
 * STRIP header: '*' + modem address (dddd-dddd) + '*' + mactype ('SIP0')
 * A Metricom packet looks like this: *<address>*<key><payload><CR>
 *   eg. *0000-1164*SIP0<payload><CR>
 *
 */

#define STRIP_ENCAP_SIZE(X) ((36) + (X)*65/64 + 2)
#define STRIP_HDRLEN 15
#define STRIP_MAC_ADDR_LEN 9

/*
 * Star mode packet header.
 * (may be used for encapsulations other than STRIP.)
 */
#define STARMODE_ADDR_LEN 11
struct st_header {
	u_char starmode_addr[STARMODE_ADDR_LEN];
	u_char starmode_type[4];
};

/*
 * Forward declarations for Metricom-specific functions.
 * Ideally, these would be in a library and shared across
 * different STRIP implementations: *BSD, Linux, etc.
 *
 */
static u_char *UnStuffData(u_char *src, u_char *end, u_char
				*dest, u_long dest_length); 

static u_char *StuffData(u_char *src, u_long length, u_char *dest,
			      u_char **code_ptr_ptr);

static void RecvErr(char *msg, struct st_softc *sc);
static void RecvErr_Message(struct st_softc *strip_info,
				u_char *sendername, u_char *msg);
void	strip_resetradio(struct st_softc *sc, struct tty *tp);
void	strip_proberadio(struct st_softc *sc, struct tty *tp);
void	strip_watchdog(struct ifnet *ifp);
void	strip_sendbody(struct st_softc *sc, struct mbuf *m);
int	strip_newpacket(struct st_softc *sc, u_char *ptr, u_char *end);
struct mbuf * strip_send(struct st_softc *sc, struct mbuf *m0);

void strip_timeout(void *x);



#ifdef DEBUG
#define DPRINTF(x)	printf x
#else
#define DPRINTF(x)
#endif



/*
 * Radio reset macros.
 * The Metricom radios are not particularly well-designed for
 * use in packet mode (starmode).  There's no easy way to tell
 * when the radio is in starmode.  Worse, when the radios are reset
 * or power-cycled, they come back up in Hayes AT-emulation mode,
 * and there's no good way for this driver to tell.
 * We deal with this by peridically tickling the radio
 * with an invalid starmode command.  If the radio doesn't
 * respond with an error, the driver knows to reset the radio.
 */

/* Radio-reset finite state machine (if_watchdog) callback rate, in seconds */
#define STRIP_WATCHDOG_INTERVAL	5

/* Period between intrusive radio probes, in seconds */
#define ST_PROBE_INTERVAL 10

/* Grace period for radio to answer probe, in seconds */
#define ST_PROBERESPONSE_INTERVAL 2

/* Be less aggressive about repeated resetting. */
#define STRIP_RESET_INTERVAL 5

/*
 * We received a response from the radio that indicates it's in
 * star mode.  Clear any pending probe or reset timer.
 * Don't  probe radio again for standard polling interval.
 */
#define CLEAR_RESET_TIMER(sc) \
 do {\
    (sc)->sc_state = ST_ALIVE;	\
    (sc)->sc_statetimo = time_second + ST_PROBE_INTERVAL;	\
} while (0)

/*
 * we received a response from the radio that indicates it's crashed
 * out of starmode into Hayse mode. Reset it ASAP.
 */
#define FORCE_RESET(sc) \
 do {\
    (sc)->sc_statetimo = time_second - 1; \
    (sc)->sc_state = ST_DEAD;	\
    /*(sc)->sc_if.if_timer = 0;*/ \
 } while (0)

#define RADIO_PROBE_TIMEOUT(sc) \
	 ((sc)-> sc_statetimo > time_second)



/*
 * Called from boot code to establish sl interfaces.
 */
void
stripattach(n)
	int n;
{
	struct st_softc *sc;
	int i = 0;

	for (sc = st_softc; i < NSTRIP; sc++) {
		timeout_set(&sc->sc_timo, strip_timeout, sc);
		sc->sc_unit = i;		/* XXX */
		snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname,
		    "strip%d", i++);
		sc->sc_if.if_softc = sc;
		sc->sc_if.if_mtu = SLMTU;
		sc->sc_if.if_flags = 0;
		sc->sc_if.if_type = IFT_OTHER;
#if 0
		sc->sc_if.if_flags |= SC_AUTOCOMP /* | IFF_POINTOPOINT | IFF_MULTICAST*/;
#endif
		sc->sc_if.if_type = IFT_SLIP;
		sc->sc_if.if_ioctl = stripioctl;
		sc->sc_if.if_output = stripoutput;
		IFQ_SET_MAXLEN(&sc->sc_if.if_snd, 50);
		sc->sc_fastq.ifq_maxlen = 32;

		sc->sc_if.if_watchdog = strip_watchdog;
		sc->sc_if.if_timer = STRIP_WATCHDOG_INTERVAL;
		IFQ_SET_READY(&sc->sc_if.if_snd);
		if_attach(&sc->sc_if);
		if_alloc_sadl(&sc->sc_if);
#if NBPFILTER > 0
		bpfattach(&sc->sc_bpf, &sc->sc_if, DLT_SLIP, SLIP_HDRLEN);
#endif
	}
}

static int
stripinit(sc)
	struct st_softc *sc;
{
	caddr_t p;

	if (sc->sc_ep == (u_char *) 0) {
		MCLALLOC(p, M_WAIT);
		if (p)
			sc->sc_ep = (u_char *)p + SLBUFSIZE;
		else {
			addlog("%s: can't allocate buffer\n",
			       sc->sc_if.if_xname);
			sc->sc_if.if_flags &= ~IFF_UP;
			return (0);
		}
	}

	/* Get contiguous buffer in which to de-bytestuff/rll-decode input */
	if (sc->sc_rxbuf == (u_char *) 0) {
		MCLALLOC(p, M_WAIT);
		if (p)
			sc->sc_rxbuf = (u_char *)p + SLBUFSIZE - SLMAX;
		else {
			addlog("%s: can't allocate input buffer\n",
			       sc->sc_if.if_xname);
			sc->sc_if.if_flags &= ~IFF_UP;
			return (0);
		}
	}

	/* Get contiguous buffer in which to bytestuff/rll-encode output */
	if (sc->sc_txbuf == (u_char *) 0) {
		MCLALLOC(p, M_WAIT);
		if (p)
			sc->sc_txbuf = (u_char *)p + SLBUFSIZE - SLMAX;
		else {
			addlog("%s: can't allocate buffer\n",
				sc->sc_if.if_xname);
			
			sc->sc_if.if_flags &= ~IFF_UP;
			return (0);
		}
	}

	sc->sc_buf = sc->sc_ep - SLMAX;
	sc->sc_mp = sc->sc_buf;
	sl_compress_init(&sc->sc_comp);

	/* Initialize radio probe/reset state machine */
	sc->sc_state = ST_DEAD;		/* assumet the worst. */
	sc->sc_statetimo = time_second; /* do reset immediately */

	return (1);
}

/*
 * Line specific open routine.
 * Attach the given tty to the first available sl unit.
 */
/* ARGSUSED */
int
stripopen(dev, tp)
	dev_t dev;
	struct tty *tp;
{
	struct proc *p = curproc;		/* XXX */
	struct st_softc *sc;
	int nstrip;
	int error;
#if defined(__NetBSD__) || defined(__OpenBSD__)
	int s;
#endif

	if ((error = suser(p, 0)) != 0)
		return (error);

	if (tp->t_line == STRIPDISC)
		return (0);

	for (nstrip = NSTRIP, sc = st_softc; --nstrip >= 0; sc++)
		if (sc->sc_ttyp == NULL) {
			if (stripinit(sc) == 0)
				return (ENOBUFS);
			tp->t_sc = (caddr_t)sc;
			sc->sc_ttyp = tp;
			sc->sc_if.if_baudrate = tp->t_ospeed;
			ttyflush(tp, FREAD | FWRITE);
#if defined(__NetBSD__) || defined(__OpenBSD__)
			/*
			 * Make sure tty output queue is large enough
			 * to hold a full-sized packet (including frame
			 * end, and a possible extra frame end).
			 * A   full-sized   of 65/64) *SLMTU bytes (because
			 * of escapes and clever RLL bytestuffing),
			 * plus frame header, and add two on for frame ends.
			 */
			s = spltty();
			if (tp->t_outq.c_cn < STRIP_MTU_ONWIRE) {
				sc->sc_oldbufsize = tp->t_outq.c_cn;
				sc->sc_oldbufquot = tp->t_outq.c_cq != 0;

				clfree(&tp->t_outq);
				clalloc(&tp->t_outq, 3*SLMTU, 0);
			} else
				sc->sc_oldbufsize = sc->sc_oldbufquot = 0;
			splx(s);
#endif /* __NetBSD__ */
			s = spltty();
			strip_resetradio(sc, tp);
			splx(s);

			return (0);
		}
	return (ENXIO);
}

/*
 * Line specific close routine.
 * Detach the tty from the strip unit.
 */
void
stripclose(tp)
	struct tty *tp;
{
	struct st_softc *sc;
	int s;

	ttywflush(tp);

	s = spltty();
	tp->t_line = 0;
	sc = (struct st_softc *)tp->t_sc;
	if (sc != NULL) {
		if_down(&sc->sc_if);
		sc->sc_ttyp = NULL;
		tp->t_sc = NULL;
		MCLFREE((caddr_t)(sc->sc_ep - SLBUFSIZE));
		MCLFREE((caddr_t)(sc->sc_rxbuf - SLBUFSIZE + SLMAX)); /* XXX */
		MCLFREE((caddr_t)(sc->sc_txbuf - SLBUFSIZE + SLMAX)); /* XXX */
		sc->sc_ep = 0;
		sc->sc_mp = 0;
		sc->sc_buf = 0;
		sc->sc_rxbuf = 0;
		sc->sc_txbuf = 0;

		if (sc->sc_flags & SC_TIMEOUT) {
			timeout_del(&sc->sc_timo);
			sc->sc_flags &= ~SC_TIMEOUT;
		}
	}
#if defined(__NetBSD__) || defined(__OpenBSD__)
	/* if necessary, install a new outq buffer of the appropriate size */
	if (sc->sc_oldbufsize != 0) {
		clfree(&tp->t_outq);
		clalloc(&tp->t_outq, sc->sc_oldbufsize, sc->sc_oldbufquot);
	}
#endif
	splx(s);
}

/*
 * Line specific (tty) ioctl routine.
 * Provide a way to get the sl unit number.
 */
/* ARGSUSED */
int
striptioctl(tp, cmd, data, flag)
	struct tty *tp;
	u_long cmd;
	caddr_t data;
	int flag;
{
	struct st_softc *sc = (struct st_softc *)tp->t_sc;

	switch (cmd) {
	case SLIOCGUNIT:
		*(int *)data = sc->sc_unit;
		break;

	default:
		return (-1);
	}
	return (0);
}

/*
 * Take an mbuf chain  containing a STRIP packet (no link-level header),
 * byte-stuff (escape) it, and enqueue it on the tty send queue.
 */
void
strip_sendbody(sc, m)
	struct st_softc  *sc;
	struct mbuf *m;
{
	struct tty *tp = sc->sc_ttyp;
	u_char *dp = sc->sc_txbuf;
	struct mbuf *m2;
	int len;
	u_char	*rllstate_ptr = NULL;

	while (m) {
		/*
		 * Byte-stuff/run-length encode this mbuf's data into the
		 * output buffer.
		 * XXX
		 * Note that chained calls to stuffdata()
		 * require that the stuffed data be left in the
		 * output buffer until the entire packet is encoded.
		 */
		dp = StuffData(mtod(m, u_char *), m->m_len, dp, &rllstate_ptr);

		MFREE(m, m2);
		m = m2;
	}

	/*
	 * Put the entire stuffed packet into the tty output queue.
	 */
	len = dp - sc->sc_txbuf;
	if (b_to_q((ttychar_t *)sc->sc_txbuf,
			   len, &tp->t_outq)) {
			if (sc->sc_if.if_flags & IFF_DEBUG)
				addlog("%s: tty output overflow\n",
					 sc->sc_if.if_xname);
			goto bad;
		}
		sc->sc_if.if_obytes += len;

	return;

bad:
	m_freem(m);
	return;
}


/* 
 *  Prepend a STRIP header to the packet.
 * (based on 4.4bsd if_ppp)
 *
 * XXX manipulates tty queues with putc.
 * must be called at spl >= spltty.
 */
struct mbuf *
strip_send(sc, m0)
    struct st_softc *sc;
    struct mbuf *m0;
{
	struct tty *tp = sc->sc_ttyp;
	struct st_header *hdr;

	/*
	 * Send starmode header (unstuffed).
	 */
	hdr = mtod(m0, struct st_header *);
	if (b_to_q((ttychar_t *)hdr, STRIP_HDRLEN, &tp->t_outq)) {
		if (sc->sc_if.if_flags & IFF_DEBUG)
		  	addlog("%s: outq overflow writing header\n",
				 sc->sc_if.if_xname);
		m_freem(m0);
		return 0;
	}

	/* The header has been enqueued in clear;  undo the M_PREPEND() of the header. */
	m0->m_data += sizeof(struct st_header);
	m0->m_len -= sizeof(struct st_header);
	if (m0->m_flags & M_PKTHDR) {
		m0->m_pkthdr.len -= sizeof(struct st_header);
	}
#ifdef DIAGNOSTIC
	 else
		addlog("%s: strip_send: missing pkthdr, %d remains\n",
		sc->sc_if.if_xname,  m0->m_len); /*XXX*/
#endif

	/*
	 * If M_PREPEND() had to prepend a new mbuf, it is now empty.
	 * Discard it.
	 */
	if (m0->m_len == 0) {
		struct mbuf *m;
		MFREE(m0, m);
		m0 = m;
	}

	/* Byte-stuff and run-length encode the remainder of the packet. */
	strip_sendbody(sc, m0);

	if (putc(STRIP_FRAME_END, &tp->t_outq)) {
		/*
		 * Not enough room.  Remove a char to make room
		 * and end the packet normally.
		 * If you get many collisions (more than one or two
		 * a day) you probably do not have enough clists
		 * and you should increase "nclist" in param.c.
		 */
		(void) unputc(&tp->t_outq);
		(void) putc(STRIP_FRAME_END, &tp->t_outq);
		sc->sc_if.if_collisions++;
	} else {
		++sc->sc_if.if_obytes;
		sc->sc_if.if_opackets++;
	}

	/*
	 * If a radio  probe is due now, append it to this packet  rather
	 * than waiting until  the watchdog routine next runs.
	 */
	if (time_second >= sc->sc_statetimo && sc->sc_state == ST_ALIVE)
		strip_proberadio(sc, tp);

	return (m0);
}



/*
 * Queue a packet.  Start transmission if not active.
 * Compression happens in slstart; if we do it here, IP TOS
 * will cause us to not compress "background" packets, because
 * ordering gets trashed.  It can be done for all packets in slstart.
 */
int
stripoutput(ifp, m, dst, rt)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr *dst;
	struct rtentry *rt;
{
	struct st_softc *sc = ifp->if_softc;
	struct ip *ip;
	struct ifqueue *ifq;
	struct st_header *shp;
	u_char *dldst;		/* link-level next-hop */
	int s;
	u_char dl_addrbuf[STARMODE_ADDR_LEN+1];

	/*
	 * Verify tty line is up and alive.
	 */
	if (sc->sc_ttyp == NULL) {
		m_freem(m);
		return (ENETDOWN);	/* sort of */
	}
	if ((sc->sc_ttyp->t_state & TS_CARR_ON) == 0 &&
	    (sc->sc_ttyp->t_cflag & CLOCAL) == 0) {
		m_freem(m);
		return (EHOSTUNREACH);
	}

#define SDL(a)          ((struct sockaddr_dl *) (a))

#ifdef DEBUG
	   if (rt) {
	   	printf("stripout, rt: dst af%d gw af%d",
		       rt_key(rt)->sa_family,
		       rt->rt_gateway->sa_family);
		if (rt_key(rt)->sa_family == AF_INET)
		  printf(" dst %x",
			 ((struct sockaddr_in *)rt_key(rt))->sin_addr.s_addr);
		printf("\n");
	}
#endif

	switch (dst->sa_family) {
	case AF_INET:
                if (rt != NULL && rt->rt_gwroute != NULL)
                        rt = rt->rt_gwroute;

                /* assume rt is never NULL */
                if (rt == NULL || rt->rt_gateway->sa_family != AF_LINK
                    || SDL(rt->rt_gateway)->sdl_alen != ifp->if_addrlen) {
		  	DPRINTF(("strip: could not arp starmode addr %x\n",
			 ((struct sockaddr_in *)dst)->sin_addr.s_addr));
			m_freem(m);
			return (EHOSTUNREACH);
		}
		/*bcopy(LLADDR(SDL(rt->rt_gateway)), dldst, ifp->if_addrlen);*/
                dldst = LLADDR(SDL(rt->rt_gateway));
                break;

	case AF_LINK:
		/*bcopy(LLADDR(SDL(rt->rt_gateway)), dldst, ifp->if_addrlen);*/
		dldst = LLADDR(SDL(dst));
		break;

	default:
		/*
		 * `Cannot happen' (see stripioctl).  Someday we will extend
		 * the line protocol to support other address families.
		 */
		addlog("%s: af %d not supported\n", sc->sc_if.if_xname,
			dst->sa_family);
		m_freem(m);
		sc->sc_if.if_noproto++;
		return (EAFNOSUPPORT);
	}
	
	ifq = NULL;
	ip = mtod(m, struct ip *);
	if (sc->sc_if.if_flags & SC_NOICMP && ip->ip_p == IPPROTO_ICMP) {
		m_freem(m);
		return (ENETRESET);		/* XXX ? */
	}
	if ((ip->ip_tos & IPTOS_LOWDELAY)
#ifdef ALTQ
	    && ALTQ_IS_ENABLED(&sc->sc_if.if_snd) == 0
#endif
		)
		ifq = &sc->sc_fastq;

	/*
	 * Add local net header.  If no space in first mbuf,
	 * add another.
	 */
	M_PREPEND(m, sizeof(struct st_header), M_DONTWAIT);
	if (m == 0) {
	  	DPRINTF(("strip: could not prepend starmode header\n"));
	  	return (ENOBUFS);
	}


	/*
	 * Unpack BCD route entry into an ASCII starmode address.
	 */

	dl_addrbuf[0] = '*';

	dl_addrbuf[1] = ((dldst[0] >> 4) & 0x0f) + '0';
	dl_addrbuf[2] = ((dldst[0]     ) & 0x0f) + '0';

	dl_addrbuf[3] = ((dldst[1] >> 4) & 0x0f) + '0';
	dl_addrbuf[4] = ((dldst[1]     ) & 0x0f) + '0';

	dl_addrbuf[5] = '-';

	dl_addrbuf[6] = ((dldst[2] >> 4) & 0x0f) + '0';
	dl_addrbuf[7] = ((dldst[2]     ) & 0x0f) + '0';

	dl_addrbuf[8] = ((dldst[3] >> 4) & 0x0f) + '0';
	dl_addrbuf[9] = ((dldst[3]     ) & 0x0f) + '0';

	dl_addrbuf[10] = '*';
	dl_addrbuf[11] = 0;
	dldst = dl_addrbuf;

	shp = mtod(m, struct st_header *);
	bcopy((caddr_t)"SIP0", (caddr_t)shp->starmode_type,
		sizeof(shp->starmode_type));

 	bcopy((caddr_t)dldst, (caddr_t)shp->starmode_addr,
		sizeof (shp->starmode_addr));

	s = spltty();
	if (sc->sc_oqlen && sc->sc_ttyp->t_outq.c_cc == sc->sc_oqlen) {
		struct timeval tv, tm;

		/* if output's been stalled for too long, and restart */
		getmicrotime(&tm);
		timersub(&tm, &sc->sc_lastpacket, &tv);
		if (tv.tv_sec > 0) {
			DPRINTF(("stripoutput: stalled, resetting\n"));
			sc->sc_otimeout++;
			stripstart(sc->sc_ttyp);
		}
	}

	(void) splnet();
	if (ifq != NULL) {
		if (IF_QFULL(ifq)) {
			IF_DROP(ifq);
			m_freem(m);
			error = ENOBUFS;
		} else {
			IF_ENQUEUE(ifq, m);
			error = 0;
		}
	} else
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m, NULL, error);
	if (error) {
		splx(s);
		sc->sc_if.if_oerrors++;
		return (error);
	}

	(void) spltty();
	getmicrotime(&sc->sc_lastpacket);
	if ((sc->sc_oqlen = sc->sc_ttyp->t_outq.c_cc) == 0) {
		stripstart(sc->sc_ttyp);
	}

	/*
	 * slip doesn't call its start routine unconditionally (again)
	 * here, but doing so apepars to reduce latency.
	 */
	 stripstart(sc->sc_ttyp);

	splx(s);
	return (0);
}


/*
 * Start output on interface.  Get another datagram
 * to send from the interface queue and map it to
 * the interface before starting output.
 *
 */
void
stripstart(tp)
	struct tty *tp;
{
	struct st_softc *sc = (struct st_softc *)tp->t_sc;
	struct mbuf *m;
	struct ip *ip;
	int s;
#if NBPFILTER > 0
	u_char bpfbuf[SLMTU + SLIP_HDRLEN];
	int len = 0;
#endif
#if !(defined(__NetBSD__) || defined(__OpenBSD__))		/* XXX - cgd */
	extern int cfreecount;
#endif


	/*
	 * Ppp checks that strip is still the line discipline,
	 * and if not, calls t_oproc here.  sl.c  does not.
	 * PPP is newer...
	 */

	if (((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0)
	    || sc == NULL || tp != (struct tty *) sc->sc_ttyp) {
		if (tp->t_oproc != NULL)
			(*tp->t_oproc)(tp);
		if (sc && (sc->sc_if.if_flags & IFF_DEBUG))
			addlog("%s: late call to stripstart\n ",
			       sc->sc_if.if_xname);
	}

	/* Start any pending output asap */
	if (CCOUNT(&tp->t_outq) != 0) {
		(*tp->t_oproc)(tp);
	}

	while (CCOUNT(&tp->t_outq) < SLIP_HIWAT) {

		/*
		 * This happens briefly when the line shuts down.
		 */
		if (sc == NULL) {
			return;
		}

#if defined(__NetBSD__) || defined(__OpenBSD__)		/* XXX - cgd */
		/*
		 * Do not remove the packet from the IP queue if it
		 * doesn't look like the packet will fit into the
		 * current serial output queue, with a packet full of
		 * escapes this could be as bad as STRIP_MTU_ONWIRE
		 * (for slip, SLMTU*2+2, for STRIP, header + 20 bytes).
		 * Also allow  4 bytes in case we need to send a probe
		 * to the radio.
		 */
		if (tp->t_outq.c_cn - tp->t_outq.c_cc < STRIP_MTU_ONWIRE + 4)
			return;
#endif /* __NetBSD__ */
		/*
		 * Get a packet and send it to the interface.
		 */
		s = splnet();
		IF_DEQUEUE(&sc->sc_fastq, m);
		if (m)
			sc->sc_if.if_omcasts++;		/* XXX */
		else
			IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
		splx(s);
		if (m == NULL) {
			return;
		}
		/*
		 * We do the header compression here rather than in stripoutput
		 * because the packets will be out of order if we are using TOS
		 * queueing, and the connection id compression will get
		 * munged when this happens.
		 */
#if NBPFILTER > 0
		if (sc->sc_bpf) {
			/*
			 * We need to save the TCP/IP header before it's
			 * compressed.  To avoid complicated code, we just
			 * copy the entire packet into a stack buffer (since
			 * this is a serial line, packets should be short
			 * and/or the copy should be negligible cost compared
			 * to the packet transmission time).
			 */
			struct mbuf *m1 = m;
			u_char *cp = bpfbuf + SLIP_HDRLEN;

			len = 0;
			do {
				int mlen = m1->m_len;

				bcopy(mtod(m1, caddr_t), cp, mlen);
				cp += mlen;
				len += mlen;
			} while ((m1 = m1->m_next) != NULL);
		}
#endif
		if ((ip = mtod(m, struct ip *))->ip_p == IPPROTO_TCP) {
			if (sc->sc_if.if_flags & SC_COMPRESS)
				*mtod(m, u_char *) |= sl_compress_tcp(m, ip,
				    &sc->sc_comp, 1);
		}
#if NBPFILTER > 0
		if (sc->sc_bpf) {
			u_char *cp = bpfbuf + STRIP_HDRLEN;
			/*
			 * Put the SLIP pseudo-"link header" in place.  The
			 * compressed header is now at the beginning of the
			 * mbuf.
			 */
			cp[SLX_DIR] = SLIPDIR_OUT;

			bcopy(mtod(m, caddr_t)+STRIP_HDRLEN, &cp[SLX_CHDR], CHDR_LEN);
			bpf_tap(sc->sc_bpf, cp, len + SLIP_HDRLEN,
			    BPF_DIRECTION_OUT);
		}
#endif
		getmicrotime(&sc->sc_lastpacket);

#if !(defined(__NetBSD__) || defined(__OpenBSD__))		/* XXX - cgd */
		/*
		 * If system is getting low on clists, just flush our
		 * output queue (if the stuff was important, it'll get
		 * retransmitted).
		 */
		if (cfreecount < CLISTRESERVE + SLMTU) {
			m_freem(m);
			sc->sc_if.if_collisions++;
			continue;
		}
#endif /* !__NetBSD__ */

		if (strip_send(sc, m) == NULL) {
	 	 	DPRINTF(("stripsend: failed to send pkt\n")); /*XXX*/
		}
	}


#if 0
	/* schedule timeout to start output */
	if ((sc->sc_flags & SC_TIMEOUT) == 0) {
		timeout_add_sec(&sc->sc_timo, 1);
		sc->sc_flags |= SC_TIMEOUT;
	}
#endif

#if 0
	/*
	 * This timeout is needed for operation on a pseudo-tty,
	 * because the pty code doesn't call our start routine
	 * after it has drained the t_outq.
	 */
	if ((sc->sc_flags & SC_TIMEOUT) == 0) {
		timeout_add_sec(&sc->sc_timo, 1);
		sc->sc_flags |= SC_TIMEOUT;
	}
#endif

    /*
     * XXX ppp calls oproc at the end of its loop, but slip
     * does it at the beginning.  We do both.
     */

    /*
     * If there is stuff in the output queue, send it now.
     * We are being called in lieu of ttstart and must do what it would.
     */
    if (tp->t_oproc != NULL)
	(*tp->t_oproc)(tp);
}



/*
 * Copy data buffer to mbuf chain; add ifnet pointer.
 */
static struct mbuf *
strip_btom(sc, len)
	struct st_softc *sc;
	int len;
{
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	/*
	 * If we have more than MHLEN bytes, it's cheaper to
	 * queue the cluster we just filled & allocate a new one
	 * for the input buffer.  Otherwise, fill the mbuf we
	 * allocated above.  Note that code in the input routine
	 * guarantees that packet will fit in a cluster.
	 */
	if (len >= MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			/*
			 * we couldn't get a cluster - if memory's this
			 * low, it's time to start dropping packets.
			 */
			(void) m_free(m);
			return (NULL);
		}
		sc->sc_ep = mtod(m, u_char *) + SLBUFSIZE;
		m->m_data = (caddr_t)sc->sc_buf;
		m->m_ext.ext_buf = (caddr_t)((long)sc->sc_buf &~ MCLOFSET);
	} else
		bcopy((caddr_t)sc->sc_buf, mtod(m, caddr_t), len);

	m->m_len = len;
	m->m_pkthdr.len = len;
	m->m_pkthdr.rcvif = &sc->sc_if;
	return (m);
}

/*
 * tty interface receiver interrupt.
 *
 * Called with a single char from the tty receiver interrupt; put
 * the char into the buffer containing a partial packet. If the
 * char is a packet delimiter, decapsulate the packet, wrap it in
 * an mbuf, and put it on the protocol input queue.
*/
void
stripinput(c, tp)
	int c;
	struct tty *tp;
{
	struct st_softc *sc;
	struct mbuf *m;
	int len;
	int s;
#if NBPFILTER > 0
	u_char chdr[CHDR_LEN];
#endif

	tk_nin++;
	sc = (struct st_softc *)tp->t_sc;
	if (sc == NULL)
		return;
	if (c & TTY_ERRORMASK || ((tp->t_state & TS_CARR_ON) == 0 &&
	    (tp->t_cflag & CLOCAL) == 0)) {
		sc->sc_flags |= SC_ERROR;
		DPRINTF(("strip: input, error %x\n", c));	 /* XXX */
		return;
	}
	c &= TTY_CHARMASK;

	++sc->sc_if.if_ibytes;

	/*
	 * Accumulate characters until we see a frame terminator (\r).
	 */
	switch (c) {

	case '\n':
		/*
		 * Error message strings from the modem are terminated with
		 * \r\n. This driver interprets the  \r as a packet terminator.
		 * If the first character in a packet is a \n, drop it.
		 * (it can never be the first char of a vaild frame).
		 */
		if (sc->sc_mp - sc->sc_buf == 0)
			break;

	/* Fall through to */

	default:
		if (sc->sc_mp < sc->sc_ep) {
			*sc->sc_mp++ = c;
		} else {
			sc->sc_flags |= SC_ERROR;
			goto error;
		}
		return;

	case STRIP_FRAME_END:
		break;
	}


	/*
	 * We only reach here if we see a CR delimiting a packet.
	 */


	len = sc->sc_mp - sc->sc_buf;

#ifdef XDEBUG
 	if (len < 15 || sc->sc_flags & SC_ERROR)
	  	addlog("stripinput: end of pkt, len %d, err %d\n",
			 len, sc->sc_flags & SC_ERROR); /*XXX*/
#endif
	if(sc->sc_flags & SC_ERROR) {
		sc->sc_flags &= ~SC_ERROR;
		addlog("%s: sc error flag set. terminating packet\n",
			sc->sc_if.if_xname);
		goto newpack;
	}

	/*
	 * We have a frame.
	 * Process an IP packet, ARP packet, AppleTalk packet,
	 * AT command resposne, or Starmode error.
	 */
	len = strip_newpacket(sc, sc->sc_buf, sc->sc_mp);
	if (len <= 1)
		/* less than min length packet - ignore */
		goto newpack;


#if NBPFILTER > 0
	if (sc->sc_bpf) {
		/*
		 * Save the compressed header, so we
		 * can tack it on later.  Note that we
		 * will end up copying garbage in some
		 * cases but this is okay.  We remember
		 * where the buffer started so we can
		 * compute the new header length.
		 */
		bcopy(sc->sc_buf, chdr, CHDR_LEN);
	}
#endif

	if ((c = (*sc->sc_buf & 0xf0)) != (IPVERSION << 4)) {
		if (c & 0x80)
			c = TYPE_COMPRESSED_TCP;
		else if (c == TYPE_UNCOMPRESSED_TCP)
			*sc->sc_buf &= 0x4f; /* XXX */
		/*
		 * We've got something that's not an IP packet.
		 * If compression is enabled, try to decompress it.
		 * Otherwise, if `auto-enable' compression is on and
		 * it's a reasonable packet, decompress it and then
		 * enable compression.  Otherwise, drop it.
		 */
		if (sc->sc_if.if_flags & SC_COMPRESS) {
			len = sl_uncompress_tcp(&sc->sc_buf, len,
						(u_int)c, &sc->sc_comp);
			if (len <= 0)
				goto error;
		} else if ((sc->sc_if.if_flags & SC_AUTOCOMP) &&
		    c == TYPE_UNCOMPRESSED_TCP && len >= 40) {
			len = sl_uncompress_tcp(&sc->sc_buf, len,
						(u_int)c, &sc->sc_comp);
			if (len <= 0)
				goto error;
			sc->sc_if.if_flags |= SC_COMPRESS;
		} else
			goto error;
	}

#if NBPFILTER > 0
	if (sc->sc_bpf) {
		/*
		 * Put the SLIP pseudo-"link header" in place.
		 * We couldn't do this any earlier since
		 * decompression probably moved the buffer
		 * pointer.  Then, invoke BPF.
		 */
		u_char *hp = sc->sc_buf - SLIP_HDRLEN;

		hp[SLX_DIR] = SLIPDIR_IN;
		bcopy(chdr, &hp[SLX_CHDR], CHDR_LEN);
		bpf_tap(sc->sc_bpf, hp, len + SLIP_HDRLEN, BPF_DIRECTION_IN);
	}
#endif
	m = strip_btom(sc, len);
	if (m == NULL) {
		goto error;
	}

	sc->sc_if.if_ipackets++;
	getmicrotime(&sc->sc_lastpacket);
	s = splnet();
	if (IF_QFULL(&ipintrq)) {
		IF_DROP(&ipintrq);
		sc->sc_if.if_ierrors++;
		sc->sc_if.if_iqdrops++;
		if (!ipintrq.ifq_congestion)
			if_congestion(&ipintrq);
		m_freem(m);
	} else {
		IF_ENQUEUE(&ipintrq, m);
		schednetisr(NETISR_IP);
	}
	splx(s);
	goto newpack;

error:
	sc->sc_if.if_ierrors++;

newpack:

	sc->sc_mp = sc->sc_buf = sc->sc_ep - SLMAX;
}

/*
 * Process an ioctl request.
 */
int
stripioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr;
	int s = splnet(), error = 0;

	switch (cmd) {

	case SIOCSIFADDR:
		if (ifa->ifa_addr->sa_family == AF_INET)
			ifp->if_flags |= IFF_UP;
		else
			error = EAFNOSUPPORT;
		break;

	case SIOCSIFDSTADDR:
		if (ifa->ifa_addr->sa_family != AF_INET)
			error = EAFNOSUPPORT;
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		if (ifr == 0) {
			error = EAFNOSUPPORT;		/* XXX */
			break;
		}
		switch (ifr->ifr_addr.sa_family) {

#ifdef INET
		case AF_INET:
			break;
#endif

		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;

	default:

#ifdef DEBUG
	  addlog("stripioctl: unknown request 0x%lx\n", cmd);
#endif
		error = EINVAL;
	}
	splx(s);
	return (error);
}


/*
 * Strip subroutines
 */

/*
 * Set a radio into starmode.
 * XXX must be called at spltty() or higher (e.g., splvm()
 */
void
strip_resetradio(sc, tp)
	struct st_softc *sc;
	struct tty *tp;
{
#if 0
	static ttychar_t InitString[] =
		"\r\n\r\n\r\nat\r\n\r\n\r\nate0dt**starmode\r\n**\r\n";
#else
	static ttychar_t InitString[] =
		"\r\rat\r\r\rate0q1dt**starmode\r**\r";
#endif
	int i;

	/*
	 * XXX Perhaps flush  tty output queue?
	 */

	if (tp == NULL)
		return;

	if ((i = b_to_q(InitString, sizeof(InitString) - 1, &tp->t_outq))) {
		addlog("resetradio: %d chars didn't fit in tty queue\n", i);
		return;
	}
	sc->sc_if.if_obytes += sizeof(InitString) - 1;

	/*
	 * Assume the radio is still dead, so we can detect repeated
	 * resets (perhaps the radio is disconnected, powered off, or
	 * is so badlyhung it needs  powercycling.
	 */
	sc->sc_state = ST_DEAD;
	getmicrotime(&sc->sc_lastpacket);
	sc->sc_statetimo = time_second + STRIP_RESET_INTERVAL;

	/*
	 * XXX Does calling the tty output routine now help resets?
	 */
	(*sc->sc_ttyp->t_oproc)(tp);
}


/*
 * Send an invalid starmode packet to the radio, to induce an error message
 * indicating the radio is in starmode.
 * Update the state machine to indicate a response is expected.
 * Either the radio answers, which will be caught by the parser,
 * or the watchdog will start resetting.
 *
 * NOTE: drops chars directly on the tty output queue.
 * should be caled at spl >= spltty.
 */
void
strip_proberadio(sc, tp)
	struct st_softc *sc;
	struct tty *tp;
{

	int overflow;
	char *strip_probestr = "**";

	if (sc->sc_if.if_flags & IFF_DEBUG)
		addlog("%s: attempting to probe radio\n", sc->sc_if.if_xname);

	if (tp == NULL) {
		addlog("%s: no tty attached\n", sc->sc_if.if_xname);
		return;
	}

	overflow = b_to_q((ttychar_t *)strip_probestr, 2, &tp->t_outq);
	if (overflow == 0) {
		if (sc->sc_if.if_flags & IFF_DEBUG)
			addlog("%s:: sent probe  to radio\n",
			       sc->sc_if.if_xname);
		/* Go to probe-sent state, set timeout accordingly. */
		sc->sc_state = ST_PROBE_SENT;
		sc->sc_statetimo = time_second + ST_PROBERESPONSE_INTERVAL;
	} else {
		addlog("%s: incomplete probe, tty queue %d bytes overfull\n",
			sc->sc_if.if_xname, overflow);
	}
}


#ifdef DEBUG
static char *strip_statenames[] = {
	"Alive",
	"Probe sent, awaiting answer",
	"Probe not answered, resetting"
};
#endif


/*
 * Timeout routine -- try to start more output.
 * Will be needed to make strip work on ptys.
 */
void
strip_timeout(x)
    void *x;
{
    struct st_softc *sc = (struct st_softc *) x;
    struct tty *tp =  sc->sc_ttyp;
    int s;

    s = spltty();
    sc->sc_flags &= ~SC_TIMEOUT;
    stripstart(tp);
    splx(s);
}

	
/*
 * Strip watchdog routine.
 * The radio hardware is balky. When sent long packets or bursts of small
 * packets, the radios crash and reboots into Hayes-emulation mode.
 * The transmit-side machinery, the error parser, and strip_watchdog()
 * implement a simple finite state machine.
 *
 * We attempt to send a probe to the radio every ST_PROBE seconds. There
 * is no direct way to tell if the radio is in starmode, so we send it a
 * malformed starmode packet -- a frame with no destination address --
 * and expect to an "name missing" error response from the radio within
 * 1 second. If we hear such a response, we assume the radio is alive
 * for the next ST_PROBE seconds.
 * If we don't hear a starmode-error response from  the radio, we reset it.
 *
 * Probes, and parsing of error responses,  are normally done inside the send
 * and receive side respectively. This watchdog routine examines the
 * state-machine variables. If there are no packets to send to the radio
 * during an entire probe interval, strip_output  will not be called,
 * so we send a probe on its behalf.
 */
void
strip_watchdog(ifp)
	struct ifnet *ifp;
{
	struct st_softc *sc = ifp->if_softc;
	struct tty *tp =  sc->sc_ttyp;

#ifdef DEBUG
	if (ifp->if_flags & IFF_DEBUG)
		addlog("\n%s: in watchdog, state %s timeout %ld\n",
		       ifp->if_xname,
 		       ((unsigned) sc->sc_state < 3) ?
		       strip_statenames[sc->sc_state] : "<<illegal state>>",
		       sc->sc_statetimo - time_second);
#endif

	/*
	 * If time in this state hasn't yet expired, return.
	 */
	if ((ifp->if_flags & IFF_UP) ==  0 || sc->sc_statetimo > time_second) {
		goto done;
	}

	/*
	 * The time in the current state has expired.
	 * Take appropriate action and advance FSA to the next state.
	 */
	switch (sc->sc_state) {
	      case ST_ALIVE:
		/*
		 * A probe is due but we haven't piggybacked one on a packet.
		 * Send a probe now.
		 */
		if (tp == NULL)
			break;
		strip_proberadio(sc, sc->sc_ttyp);
		(*tp->t_oproc)(tp);
		break;

	      case ST_PROBE_SENT:
		/*
		 * Probe sent but no response within timeout. Reset.
		 */
		addlog("%s: no answer to probe, resetting radio\n",
		       ifp->if_xname);
		strip_resetradio(sc, sc->sc_ttyp);
		ifp->if_oerrors++;
		break;

	      case ST_DEAD:
		/*
		 * The radio has been sent a reset but didn't respond.
		 * XXX warn user to remove AC adaptor and battery,
		 * wait  5 secs, and replace.
		 */
		addlog("%s: radio reset but not responding, Trying again\n",
		       ifp->if_xname);
		strip_resetradio(sc, sc->sc_ttyp);
		ifp->if_oerrors++;
		break;

	      default:
		/* Cannot happen. To be safe, do  a reset. */
		addlog("%s: %s %d, resetting\n",
		       sc->sc_if.if_xname,
		       "radio-reset finite-state machine in invalid state",
		       sc->sc_state);
		strip_resetradio(sc, sc->sc_ttyp);
		sc->sc_state = ST_DEAD;
		break;
	}

      done:
	ifp->if_timer = STRIP_WATCHDOG_INTERVAL;
	return;
}


/*
 * The following bytestuffing and run-length encoding/decoding
 * fucntions are  taken, with permission from Stuart Cheshire,
 * from  the MosquitonNet strip  driver for Linux.
 * XXX Linux style left intact, to ease folding in updates from
 * the Mosquitonet group.
 */


/*
 * Process a received packet.
 */
int
strip_newpacket(sc, ptr, end)
	struct st_softc *sc;
	u_char *ptr, *end;
{
	int len = ptr - end;
	u_char *name, *name_end;
	u_int packetlen;

	/* Ignore empty lines */
	if (len == 0) return 0;

	/* Catch 'OK' responses which show radio has fallen out of starmode */
	if (len >= 2 && ptr[0] == 'O' && ptr[1] == 'K') {
		addlog("%s: Radio is back in AT command mode: will reset\n",
			sc->sc_if.if_xname);
		FORCE_RESET(sc);		/* Do reset ASAP */
	return 0;
	}

	/* Check for start of address marker, and then skip over it */
	if (*ptr != '*') {
		/* Catch other error messages */
		if (ptr[0] == 'E' && ptr[1] == 'R' && ptr[2] == 'R' && ptr[3] == '_')
			RecvErr_Message(sc, NULL, ptr+4);
			 /* XXX what should the message above be? */
		else {
			RecvErr("No initial *", sc);
			addlog("(len = %d)\n", len);
		     }
		return 0;
	}

	/* skip the '*' */
	ptr++;

	/* Skip the return address */
	name = ptr;
	while (ptr < end && *ptr != '*')
		ptr++;

	/* Check for end of address marker, and skip over it */
	if (ptr == end) {
		RecvErr("No second *", sc);
		return 0;
	}
	name_end = ptr++;

	/* Check for SRIP key, and skip over it */
	if (ptr[0] != 'S' || ptr[1] != 'I' || ptr[2] != 'P' || ptr[3] != '0') {
		if (ptr[0] == 'E' && ptr[1] == 'R' && ptr[2] == 'R' &&
		    ptr[3] == '_') { 
			*name_end = 0;
			RecvErr_Message(sc, name, ptr+4);
		 }
		else RecvErr("No SRIP key", sc);
		return 0;
	}
	ptr += 4;

	/* Decode start of the IP packet header */
	ptr = UnStuffData(ptr, end, sc->sc_rxbuf, 4);
	if (ptr == 0) {
		RecvErr("Runt packet (hdr)", sc);
		return 0;
	}

	/*
	 * The STRIP bytestuff/RLL encoding has no explicit length
	 * of the decoded packet.  Decode start of IP header, get the
	 * IP header length and decode that many bytes in total.
	 */
	packetlen = ((u_short)sc->sc_rxbuf[2] << 8) | sc->sc_rxbuf[3];

#ifdef DIAGNOSTIC
/*	addlog("Packet %02x.%02x.%02x.%02x\n",
		sc->sc_rxbuf[0], sc->sc_rxbuf[1],
		sc->sc_rxbuf[2], sc->sc_rxbuf[3]);
	addlog("Got %d byte packet\n", packetlen); */
#endif

	/* Decode remainder of the IP packer */
	ptr = UnStuffData(ptr, end, sc->sc_rxbuf+4, packetlen-4);
	if (ptr == 0) {
		RecvErr("Short packet", sc);
		return 0;
	}

	/* XXX redundant copy */
	bcopy(sc->sc_rxbuf, sc->sc_buf, packetlen );
	return (packetlen);
}


/*
 * Stuffing scheme:
 * 00    Unused (reserved character)
 * 01-3F Run of 2-64 different characters
 * 40-7F Run of 1-64 different characters plus a single zero at the end
 * 80-BF Run of 1-64 of the same character
 * C0-FF Run of 1-64 zeroes (ASCII 0)
*/
typedef enum
{
	Stuff_Diff      = 0x00,
	Stuff_DiffZero  = 0x40,
	Stuff_Same      = 0x80,
	Stuff_Zero      = 0xC0,
	Stuff_NoCode    = 0xFF,		/* Special code, meaning no code selected */
	
	Stuff_CodeMask  = 0xC0,
	Stuff_CountMask = 0x3F,
	Stuff_MaxCount  = 0x3F,
	Stuff_Magic     = 0x0D		/* The value we are eliminating */
} StuffingCode;

/*
 * StuffData encodes the data starting at "src" for "length" bytes.
 * It writes it to the buffer pointed to by "dest" (which must be at least
 * as long as 1 + 65/64 of the input length). The output may be up to 1.6%
 * larger than the input for pathological input, but will usually be smaller.
 * StuffData returns the new value of the dest pointer as its result.
 *
 * "code_ptr_ptr" points to a "u_char *" which is used to hold
 * encoding state between calls, allowing an encoded packet to be
 * incrementally built up from small parts.
 * On the first call, the "u_char *" pointed to should be initialized
 * to NULL;  between subsequent calls the calling routine should leave
 * the value alone and simply pass it back unchanged so that the
 * encoder can recover its current state.
 */ 

#define StuffData_FinishBlock(X) \
	(*code_ptr = (X) ^ Stuff_Magic, code = Stuff_NoCode)

static u_char *
StuffData(u_char *src, u_long length, u_char *dest, u_char **code_ptr_ptr)
{
	u_char *end = src + length;
	u_char *code_ptr = *code_ptr_ptr;
	u_char code = Stuff_NoCode, count = 0;
	
	if (!length) return (dest);
	
	if (code_ptr) {	/* Recover state from last call, if applicable */
		code  = (*code_ptr ^ Stuff_Magic) & Stuff_CodeMask;
		count = (*code_ptr ^ Stuff_Magic) & Stuff_CountMask;
	}

	while (src < end) {
		switch (code) {
		/*
		 * Stuff_NoCode: If no current code, select one
		 */
		case Stuff_NoCode:
		  	code_ptr = dest++;	/* Record where we're going to put this code */
			count = 0;		/* Reset the count (zero means one instance) */
							/* Tentatively start a new block */
			if (*src == 0) {
				code = Stuff_Zero;
				src++;
			} else {
				code = Stuff_Same;
				*dest++ = *src++ ^ Stuff_Magic;
			}
			/* Note: We optimistically assume run of same -- which will be */
			/* fixed later in Stuff_Same if it turns out not to be true. */
			break;

		/*
		 * Stuff_Zero: We already have at least one zero encoded
		 */
		case Stuff_Zero:
		  	
			/* If another zero, count it, else finish this code block */
			if (*src == 0) {
				count++;
				src++;
			} else
				StuffData_FinishBlock(Stuff_Zero + count);
			break;

		/*
		 * Stuff_Same: We already have at least one byte encoded
		 */
		case Stuff_Same:
			/* If another one the same, count it */
			if ((*src ^ Stuff_Magic) == code_ptr[1]) {
				count++;
				src++;
				break;
			}
			/* else, this byte does not match this block. */
			/* If we already have two or more bytes encoded, finish this code block */
			if (count) {
				StuffData_FinishBlock(Stuff_Same + count);
				break;
			}
			/* else, we only have one so far, so switch to Stuff_Diff code */
			code = Stuff_Diff; /* and fall through to Stuff_Diff case below */

		case Stuff_Diff:	/* Stuff_Diff: We have at least two *different* bytes encoded */
			/* If this is a zero, must encode a Stuff_DiffZero, and begin a new block */
			if (*src == 0)
				StuffData_FinishBlock(Stuff_DiffZero + count);
			/* else, if we have three in a row, it is worth starting a Stuff_Same block */
			else if ((*src ^ Stuff_Magic) == dest[-1] && dest[-1] == dest[-2])
				{
				code += count-2;
				if (code == Stuff_Diff)
					code = Stuff_Same;
				StuffData_FinishBlock(code);
				code_ptr = dest-2;
				/* dest[-1] already holds the correct value */
				count = 2;		/* 2 means three bytes encoded */
				code = Stuff_Same;
				}
			/* else, another different byte, so add it to the block */
			else {
				*dest++ = *src ^ Stuff_Magic;
				count++;
			}
			src++;	/* Consume the byte */
			break;
		}

		if (count == Stuff_MaxCount)
			StuffData_FinishBlock(code + count);
		}
	if (code == Stuff_NoCode)
		*code_ptr_ptr = NULL;
	else {
		*code_ptr_ptr = code_ptr;
		StuffData_FinishBlock(code + count);
	}

	return (dest);
}



/*
 * UnStuffData decodes the data at "src", up to (but not including)
 * "end".  It writes the decoded data into the buffer pointed to by
 * "dst", up to a  maximum of "dst_length", and returns the new
 * value of "src" so that a follow-on call can read more data,
 * continuing from where the first left off. 
 *
 * There are three types of results:
 * 1. The source data runs out before extracting "dst_length" bytes:
 *    UnStuffData returns NULL to indicate failure.
 * 2. The source data produces exactly "dst_length" bytes:
 *    UnStuffData returns new_src = end to indicate that all bytes
 *    were consumed. 
 * 3. "dst_length" bytes are extracted, with more
 *     remaining. UnStuffData returns new_src < end to indicate that
 *     there are more bytes to be read.
 *
 * Note: The decoding may be dstructive, in that it may alter the
 * source data in the process of decoding it (this is necessary to
 * allow a follow-on  call to resume correctly).
 */

static u_char *
UnStuffData(u_char *src, u_char *end, u_char *dst, u_long dst_length)
{
	u_char *dst_end = dst + dst_length;

	/* Sanity check */
	if (!src || !end || !dst || !dst_length)
		return (NULL);

	while (src < end && dst < dst_end)
	{
		int count = (*src ^ Stuff_Magic) & Stuff_CountMask;
		switch ((*src ^ Stuff_Magic) & Stuff_CodeMask)
			{
			case Stuff_Diff:
				if (src+1+count >= end)
					return (NULL);
				do
				{
					*dst++ = *++src ^ Stuff_Magic;
				}
				while(--count >= 0 && dst < dst_end);
				if (count < 0)
					src += 1;
				else
				 if (count == 0)
					*src = Stuff_Same ^ Stuff_Magic;
				else
					*src = (Stuff_Diff + count) ^ Stuff_Magic;
				break;
			case Stuff_DiffZero:
				if (src+1+count >= end)
					return (NULL);
				do
				{
					*dst++ = *++src ^ Stuff_Magic;
				}
				while(--count >= 0 && dst < dst_end);
				if (count < 0)
					*src = Stuff_Zero ^ Stuff_Magic;
				else
					*src = (Stuff_DiffZero + count) ^ Stuff_Magic;
				break;
			case Stuff_Same:
				if (src+1 >= end)
					return (NULL);
				do
				{
					*dst++ = src[1] ^ Stuff_Magic;
				}
				while(--count >= 0 && dst < dst_end);
				if (count < 0)
					src += 2;
				else
					*src = (Stuff_Same + count) ^ Stuff_Magic;
				break;
			case Stuff_Zero:
				do
				{
					*dst++ = 0;
				}
				while(--count >= 0 && dst < dst_end);
				if (count < 0)
					src += 1;
				else
					*src = (Stuff_Zero + count) ^ Stuff_Magic;
				break;
			}
	}

	if (dst < dst_end)
		return (NULL);
	else
		return (src);
}



/*
 * Log an error mesesage (for a packet received with errors?)
 * from the STRIP driver.
 */
static void
RecvErr(msg, sc)
	char *msg;
	struct st_softc *sc;
{
	static const int MAX_RecErr = 80;
	u_char *ptr = sc->sc_buf;
	u_char *end = sc->sc_mp;
	u_char pkt_text[MAX_RecErr], *p = pkt_text;
	*p++ = '\"';
	while (ptr < end && p < &pkt_text[MAX_RecErr-4]) {
		if (*ptr == '\\') {
			*p++ = '\\';
			*p++ = '\\';
		} else if (*ptr >= 32 && *ptr <= 126)
			*p++ = *ptr;
		else {
			sprintf(p, "\\%02x", *ptr);
			p+= 3;
		}
		ptr++;
	}

	if (ptr == end) *p++ = '\"';
	*p++ = 0;
	addlog("%s: %13s : %s\n", sc->sc_if.if_xname, msg, pkt_text);

	sc->sc_if.if_ierrors++;
}


/*
 * Parse an error message from the radio.
 */
static void
RecvErr_Message(strip_info, sendername, msg)
	struct st_softc *strip_info;
	u_char *sendername;
	/*const*/ u_char *msg;
{
	static const char ERR_001[] = "001"; /* Not in StarMode! */
	static const char ERR_002[] = "002"; /* Remap handle */
	static const char ERR_003[] = "003"; /* Can't resolve name */
	static const char ERR_004[] = "004"; /* Name too small or missing */
	static const char ERR_005[] = "005"; /* Bad count specification */
	static const char ERR_006[] = "006"; /* Header too big */
	static const char ERR_007[] = "007"; /* Body too big */
	static const char ERR_008[] = "008"; /* Bad character in name */
	static const char ERR_009[] = "009"; /* No count or line terminator */

	char * if_name;

	if_name = strip_info->sc_if.if_xname;

	if (!strncmp(msg, ERR_001, sizeof(ERR_001)-1))
	{
		RecvErr("radio error message:", strip_info);
		addlog("%s: Radio %s is not in StarMode\n",
			if_name, sendername);
	}
	else if (!strncmp(msg, ERR_002, sizeof(ERR_002)-1))
	{
		RecvErr("radio error message:", strip_info);
#ifdef notyet		/*Kernel doesn't have scanf!*/
		int handle;
		u_char newname[64];
		sscanf(msg, "ERR_002 Remap handle &%d to name %s", &handle, newname);
		addlog("%s: Radio name %s is handle %d\n",
			if_name, newname, handle);
#endif
	}
	else if (!strncmp(msg, ERR_003, sizeof(ERR_003)-1))
	{
		RecvErr("radio error message:", strip_info);
		addlog("%s: Destination radio name is unknown\n", if_name);
	}
	else if (!strncmp(msg, ERR_004, sizeof(ERR_004)-1)) {
		/*
		 * The radio reports it got a badly-framed starmode packet
		 * from us; so it must me in starmode.
		 */
		if (strip_info->sc_if.if_flags & IFF_DEBUG)
			addlog("%s: radio responded to probe\n", if_name);
		if (strip_info->sc_state == ST_DEAD) {
			/* A successful reset... */
			addlog("%s: Radio back in starmode\n", if_name);
		}
		CLEAR_RESET_TIMER(strip_info);
	}
	else if (!strncmp(msg, ERR_005, sizeof(ERR_005)-1))
        	RecvErr("radio error message:", strip_info);
	else if (!strncmp(msg, ERR_006, sizeof(ERR_006)-1))
        	RecvErr("radio error message:", strip_info);
	else if (!strncmp(msg, ERR_007, sizeof(ERR_007)-1))
	 {
		/*
		 *	Note: This error knocks the radio back into
		 *	command mode.
		 */
		RecvErr("radio error message:", strip_info);
		addlog("%s: Error! Packet size too big for radio.",
			if_name);
		FORCE_RESET(strip_info);
	}
	else if (!strncmp(msg, ERR_008, sizeof(ERR_008)-1))
	{
		RecvErr("radio error message:", strip_info);
		addlog("%s: Radio name contains illegal character\n",
			if_name);
	}
	else if (!strncmp(msg, ERR_009, sizeof(ERR_009)-1))
        	RecvErr("radio error message:", strip_info);
	else {
		addlog("failed to parse ]%3s[\n", msg);
		RecvErr("unparsed radio error message:", strip_info);
	}
}

#endif /* NSTRIP > 0 */
@


1.36
log
@clalloc() can't fail, so there's no need to handle failure cases.
Change to void function.
Also, no need to have global tty stats pointer, so just return it
from clalloc, as the caller frees it immediately anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.35 2008/10/22 23:04:45 mpf Exp $	*/
@


1.35
log
@#if INET  => #ifdef INET
#if INET6 => #ifdef INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.34 2008/09/10 14:01:23 blambert Exp $	*/
d476 1
a476 5
				error = clalloc(&tp->t_outq, 3*SLMTU, 0);
				if (error) {
					splx(s);
					return (error);
				}
@


1.34
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.33 2007/11/27 16:22:13 martynas Exp $	*/
d118 1
a118 1
#if INET
@


1.33
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.32 2006/03/25 22:41:47 djm Exp $	*/
d1031 1
a1031 1
		timeout_add(&sc->sc_timo, hz);
d1043 1
a1043 1
		timeout_add(&sc->sc_timo, hz);
@


1.32
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.31 2006/03/11 22:44:47 brad Exp $	*/
d304 1
a304 1
/* Be less agressive about repeated resetting. */
@


1.31
log
@splimp -> spltty/splnet

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.30 2004/06/24 19:35:25 tholo Exp $	*/
d1003 2
a1004 1
			bpf_tap(sc->sc_bpf, cp, len + SLIP_HDRLEN);
d1256 1
a1256 1
		bpf_tap(sc->sc_bpf, hp, len + SLIP_HDRLEN);
@


1.30
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.29 2004/06/21 23:50:36 tholo Exp $	*/
a87 3
 * 
 * Note that splimp() is used throughout to block both (tty) input
 * interrupts and network activity; thus, splimp must be >= spltty.
d507 1
a507 1
	s = splimp();		/* actually, max(spltty, splsoftnet) */
d831 1
a831 2

	s = splimp();
d844 2
d862 2
d948 1
a948 1
		s = splimp();
d1265 1
a1265 1
	s = splimp();
d1299 1
a1299 1
	int s = splimp(), error = 0;
d1353 1
a1353 1
 * XXX must be called at spltty() or higher (e.g., splimp()
@


1.29
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.28 2004/04/25 18:50:01 henning Exp $	*/
d837 1
a837 1
		struct timeval tv;
d840 2
a841 1
		timersub(&time, &sc->sc_lastpacket, &tv);
d864 1
a864 1
	sc->sc_lastpacket = time;
d1006 1
a1006 1
		sc->sc_lastpacket = time;
d1264 1
a1264 1
	sc->sc_lastpacket = time;
d1388 1
a1388 1
	sc->sc_lastpacket = time;
@


1.28
log
@check for input queue congestion on those as well and call if_congestion when
needed; these  are slightly different so that we cannot use the new
IF_INPUT_ENQUEUE macro
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.27 2003/12/10 07:22:42 itojun Exp $	*/
d318 1
a318 1
    (sc)->sc_statetimo = time.tv_sec + ST_PROBE_INTERVAL;	\
d327 1
a327 1
    (sc)->sc_statetimo = time.tv_sec - 1; \
d333 1
a333 1
	 ((sc)-> sc_statetimo > time.tv_sec)
d427 1
a427 1
	sc->sc_statetimo = time.tv_sec; /* do reset immediately */
d689 1
a689 1
	if (time.tv_sec >= sc->sc_statetimo && sc->sc_state == ST_ALIVE)
d1388 1
a1388 1
	sc->sc_statetimo = time.tv_sec + STRIP_RESET_INTERVAL;
d1431 1
a1431 1
		sc->sc_statetimo = time.tv_sec + ST_PROBERESPONSE_INTERVAL;
d1501 1
a1501 1
		       sc->sc_statetimo - time.tv_sec);
d1507 1
a1507 1
	if ((ifp->if_flags & IFF_UP) ==  0 || sc->sc_statetimo > time.tv_sec) {
@


1.27
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.26 2003/08/15 20:32:19 tedu Exp $	*/
d1269 2
@


1.26
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.25 2003/06/02 23:28:12 millert Exp $	*/
d344 2
a345 2
	register struct st_softc *sc;
	register int i = 0;
d378 1
a378 1
	register struct st_softc *sc;
d380 1
a380 1
	register caddr_t p;
d440 1
a440 1
	register struct tty *tp;
d443 2
a444 2
	register struct st_softc *sc;
	register int nstrip;
d505 1
a505 1
	register struct st_softc *sc;
d575 2
a576 2
	register struct tty *tp = sc->sc_ttyp;
	register u_char *dp = sc->sc_txbuf;
d578 1
a578 1
	register int len;
d629 1
a629 1
	register struct tty *tp = sc->sc_ttyp;
d661 1
a661 1
		register struct mbuf *m;
d706 1
a706 1
	register struct mbuf *m;
d710 5
a714 5
	register struct st_softc *sc = ifp->if_softc;
	register struct ip *ip;
	register struct ifqueue *ifq;
	register struct st_header *shp;
	register u_char *dldst;		/* link-level next-hop */
d887 1
a887 1
	register struct tty *tp;
d889 3
a891 3
	register struct st_softc *sc = (struct st_softc *)tp->t_sc;
	register struct mbuf *m;
	register struct ip *ip;
d895 1
a895 1
	register int len = 0;
d973 2
a974 2
			register struct mbuf *m1 = m;
			register u_char *cp = bpfbuf + SLIP_HDRLEN;
d978 1
a978 1
				register int mlen = m1->m_len;
d993 1
a993 1
			register u_char *cp = bpfbuf + STRIP_HDRLEN;
d1066 2
a1067 2
	register struct st_softc *sc;
	register int len;
d1069 1
a1069 1
	register struct mbuf *m;
d1114 2
a1115 2
	register int c;
	register struct tty *tp;
d1117 3
a1119 3
	register struct st_softc *sc;
	register struct mbuf *m;
	register int len;
d1250 1
a1250 1
		register u_char *hp = sc->sc_buf - SLIP_HDRLEN;
d1290 1
a1290 1
	register struct ifnet *ifp;
d1294 3
a1296 3
	register struct ifaddr *ifa = (struct ifaddr *)data;
	register struct ifreq *ifr;
	register int s = splimp(), error = 0;
d1364 1
a1364 1
	register int i;
d1407 2
a1408 2
	register struct st_softc *sc;
	register struct tty *tp;
d1490 1
a1490 1
	register struct st_softc *sc = ifp->if_softc;
d1579 1
a1579 1
	register u_char *ptr, *end;
d1581 2
a1582 2
	register int len = ptr - end;
	register u_char *name, *name_end;
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.24 2003/05/03 21:15:11 deraadt Exp $	*/
d450 1
a450 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.24
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.23 2003/01/07 09:00:33 kjc Exp $	*/
d43 1
a43 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.22 2002/09/11 05:38:47 itojun Exp $	*/
d354 2
a355 1
		sprintf(sc->sc_if.if_xname, "strip%d", i++);
@


1.22
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.21 2002/07/30 23:30:50 itojun Exp $	*/
a719 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a746 5
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);
d860 1
a860 1
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m, &pktattr, error);
@


1.21
log
@no need for check if m0 is NULL, as we have touched it already.
From: tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.20 2002/06/30 13:04:36 itojun Exp $	*/
d485 1
a485 1
					return(error);
d695 1
a695 1
	return(m0);
d765 1
a765 1
			return(EHOSTUNREACH);
d808 1
a808 1
	  	return(ENOBUFS);
d1675 1
a1675 1
	return(packetlen);
d1727 1
a1727 1
	if (!length) return(dest);
d1821 1
a1821 1
	return(dest);
d1855 1
a1855 1
		return(NULL);
d1864 1
a1864 1
					return(NULL);
d1880 1
a1880 1
					return(NULL);
d1893 1
a1893 1
					return(NULL);
d1919 1
a1919 1
		return(NULL);
d1921 1
a1921 1
		return(src);
@


1.20
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.19 2002/06/24 00:17:29 itojun Exp $	*/
d650 1
a650 1
	if (m0 && m0->m_flags & M_PKTHDR) {
@


1.19
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.18 2002/03/14 03:16:10 millert Exp $	*/
d372 1
@


1.18
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.17 2002/03/14 01:27:09 millert Exp $	*/
d754 1
a754 3

            case AF_INET:

d770 1
a770 1
            case AF_LINK:
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.16 2002/03/12 09:51:20 kjc Exp $	*/
d262 1
a262 1
static u_char* UnStuffData(u_char *src, u_char *end, u_char
d265 1
a265 1
static u_char* StuffData(u_char *src, u_long length, u_char *dest,
d1721 1
a1721 1
static u_char*
d1849 1
a1849 1
static u_char*
@


1.16
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.15 2001/06/27 06:07:44 kjc Exp $	*/
d232 2
a233 2
static int stripinit __P((struct st_softc *));
static 	struct mbuf *strip_btom __P((struct st_softc *, int));
d262 2
a263 2
static u_char* UnStuffData __P((u_char *src, u_char *end, u_char
				*dest, u_long dest_length)); 
d265 2
a266 2
static u_char* StuffData __P((u_char *src, u_long length, u_char *dest,
			      u_char **code_ptr_ptr));
d268 9
a276 9
static void RecvErr __P((char *msg, struct st_softc *sc));
static void RecvErr_Message __P((struct st_softc *strip_info,
				u_char *sendername, u_char *msg));
void	strip_resetradio __P((struct st_softc *sc, struct tty *tp));
void	strip_proberadio __P((struct st_softc *sc, struct tty *tp));
void	strip_watchdog __P((struct ifnet *ifp));
void	strip_sendbody __P((struct st_softc *sc, struct mbuf *m));
int	strip_newpacket __P((struct st_softc *sc, u_char *ptr, u_char *end));
struct mbuf * strip_send __P((struct st_softc *sc, struct mbuf *m0));
d278 1
a278 1
void strip_timeout __P((void *x));
@


1.15
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.14 2001/06/15 03:38:34 itojun Exp $	*/
d747 6
@


1.15.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.15 2001/06/27 06:07:44 kjc Exp $	*/
d232 2
a233 2
static int stripinit(struct st_softc *);
static 	struct mbuf *strip_btom(struct st_softc *, int);
d262 2
a263 2
static u_char *UnStuffData(u_char *src, u_char *end, u_char
				*dest, u_long dest_length); 
d265 2
a266 2
static u_char *StuffData(u_char *src, u_long length, u_char *dest,
			      u_char **code_ptr_ptr);
d268 9
a276 9
static void RecvErr(char *msg, struct st_softc *sc);
static void RecvErr_Message(struct st_softc *strip_info,
				u_char *sendername, u_char *msg);
void	strip_resetradio(struct st_softc *sc, struct tty *tp);
void	strip_proberadio(struct st_softc *sc, struct tty *tp);
void	strip_watchdog(struct ifnet *ifp);
void	strip_sendbody(struct st_softc *sc, struct mbuf *m);
int	strip_newpacket(struct st_softc *sc, u_char *ptr, u_char *end);
struct mbuf * strip_send(struct st_softc *sc, struct mbuf *m0);
d278 1
a278 1
void strip_timeout(void *x);
a746 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d1715 1
a1715 1
static u_char *
d1843 1
a1843 1
static u_char *
@


1.15.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.15.4.1 2002/06/11 03:30:45 art Exp $	*/
a371 1
		if_alloc_sadl(&sc->sc_if);
d484 1
a484 1
					return (error);
d649 1
a649 1
	if (m0->m_flags & M_PKTHDR) {
d694 1
a694 1
	return (m0);
d754 3
a756 1
	case AF_INET:
d766 1
a766 1
			return (EHOSTUNREACH);
d772 1
a772 1
	case AF_LINK:
d809 1
a809 1
	  	return (ENOBUFS);
d1676 1
a1676 1
	return (packetlen);
d1728 1
a1728 1
	if (!length) return (dest);
d1822 1
a1822 1
	return (dest);
d1856 1
a1856 1
		return (NULL);
d1865 1
a1865 1
					return (NULL);
d1881 1
a1881 1
					return (NULL);
d1894 1
a1894 1
					return (NULL);
d1920 1
a1920 1
		return (NULL);
d1922 1
a1922 1
		return (src);
@


1.15.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d354 1
a354 2
		snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname,
		    "strip%d", i++);
d720 1
d748 5
d866 1
a866 1
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m, NULL, error);
@


1.14
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.13 2000/12/30 01:02:55 angelos Exp $	*/
d365 1
a365 1
		sc->sc_if.if_snd.ifq_maxlen = 50;
d370 1
d719 1
a719 1

d783 1
a783 1
	ifq = &sc->sc_if.if_snd;
d789 5
a793 1
	if (ip->ip_tos & IPTOS_LOWDELAY)
d851 12
a862 3
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
d865 1
a865 1
		return (ENOBUFS);
a866 1
	IF_ENQUEUE(ifq, m);
d956 1
a956 1
			IF_DEQUEUE(&sc->sc_if.if_snd, m);
@


1.13
log
@Fix PR 342: the problem was that the code was assuming that when the
strip interface was configured up, a tty was already associated with
it -- and proceeded to probe/reset/initialize it through a watchdog
routine...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.12 2000/06/26 22:51:01 art Exp $	*/
d839 1
a839 1
		timersub(&time, &sc->sc_if.if_lastchange, &tv);
d854 1
a854 1
	sc->sc_if.if_lastchange = time;
d996 1
a996 1
		sc->sc_if.if_lastchange = time;
d1254 1
a1254 1
	sc->sc_if.if_lastchange = time;
d1376 1
a1376 1
	sc->sc_if.if_lastchange = time;
@


1.12
log
@New timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.11 1999/04/22 20:02:43 art Exp $	*/
d388 1
a388 1
			printf("%s: can't allocate buffer\n",
d401 1
a401 1
			printf("%s: can't allocate input buffer\n",
d414 1
a414 1
			printf("%s: can't allocate buffer\n",
d775 1
a775 1
		printf("%s: af %d not supported\n", sc->sc_if.if_xname,
d1170 1
a1170 1
	  	printf("stripinput: end of pkt, len %d, err %d\n",
d1326 1
a1326 1
	  printf("stripioctl: unknown request 0x%lx\n", cmd);
d1361 3
d1365 1
a1365 1
		printf("resetradio: %d chars didn't fit in tty queue\n", i);
d1408 5
d1441 1
a1441 1
static void
d1510 2
d1581 1
a1581 1
		printf("%s: Radio is back in AT command mode: will reset\n",
d1642 1
a1642 1
/*	printf("Packet %02x.%02x.%02x.%02x\n",
d1645 1
a1645 1
	printf("Got %d byte packet\n", packetlen); */
d2012 1
a2012 1
		printf("%s: Error! Packet size too big for radio.",
d2019 1
a2019 1
		printf("%s: Radio name contains illegal character\n",
@


1.11
log
@we don't need to include buf.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.10 1998/02/10 12:00:46 angelos Exp $	*/
d204 1
d278 1
a278 1
static void strip_timeout __P((void *x));
d352 1
d528 1
a528 1
			untimeout(strip_timeout, (void *) sc);
d1020 1
a1020 1
		timeout(strip_timeout, (void *) sc, HZ);
d1032 1
a1032 1
		timeout(strip_timeout, (void *) sc, HZ);
@


1.11.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.13 2000/12/30 01:02:55 angelos Exp $	*/
a203 1

d277 1
a277 1
void strip_timeout __P((void *x));
a350 1
		timeout_set(&sc->sc_timo, strip_timeout, sc);
d386 1
a386 1
			addlog("%s: can't allocate buffer\n",
d399 1
a399 1
			addlog("%s: can't allocate input buffer\n",
d412 1
a412 1
			addlog("%s: can't allocate buffer\n",
d526 1
a526 1
			timeout_del(&sc->sc_timo);
d773 1
a773 1
		addlog("%s: af %d not supported\n", sc->sc_if.if_xname,
d1018 1
a1018 1
		timeout_add(&sc->sc_timo, hz);
d1030 1
a1030 1
		timeout_add(&sc->sc_timo, hz);
d1168 1
a1168 1
	  	addlog("stripinput: end of pkt, len %d, err %d\n",
d1324 1
a1324 1
	  addlog("stripioctl: unknown request 0x%lx\n", cmd);
a1358 3
	if (tp == NULL)
		return;

d1360 1
a1360 1
		addlog("resetradio: %d chars didn't fit in tty queue\n", i);
a1402 5
	if (tp == NULL) {
		addlog("%s: no tty attached\n", sc->sc_if.if_xname);
		return;
	}

d1431 1
a1431 1
void
a1499 2
		if (tp == NULL)
			break;
d1569 1
a1569 1
		addlog("%s: Radio is back in AT command mode: will reset\n",
d1630 1
a1630 1
/*	addlog("Packet %02x.%02x.%02x.%02x\n",
d1633 1
a1633 1
	addlog("Got %d byte packet\n", packetlen); */
d2000 1
a2000 1
		addlog("%s: Error! Packet size too big for radio.",
d2007 1
a2007 1
		addlog("%s: Radio name contains illegal character\n",
@


1.11.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.11.4.1 2001/05/14 22:40:02 niklas Exp $	*/
d365 1
a365 1
		IFQ_SET_MAXLEN(&sc->sc_if.if_snd, 50);
a369 1
		IFQ_SET_READY(&sc->sc_if.if_snd);
d718 1
a718 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
d782 1
a782 1
	ifq = NULL;
d788 1
a788 5
	if ((ip->ip_tos & IPTOS_LOWDELAY)
#ifdef ALTQ
	    && ALTQ_IS_ENABLED(&sc->sc_if.if_snd) == 0
#endif
		)
d839 1
a839 1
		timersub(&time, &sc->sc_lastpacket, &tv);
d846 3
a848 12
	if (ifq != NULL) {
		if (IF_QFULL(ifq)) {
			IF_DROP(ifq);
			m_freem(m);
			error = ENOBUFS;
		} else {
			IF_ENQUEUE(ifq, m);
			error = 0;
		}
	} else
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m, &pktattr, error);
	if (error) {
d851 1
a851 1
		return (error);
d853 2
a854 1
	sc->sc_lastpacket = time;
d943 1
a943 1
			IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
d996 1
a996 1
		sc->sc_lastpacket = time;
d1254 1
a1254 1
	sc->sc_lastpacket = time;
d1376 1
a1376 1
	sc->sc_lastpacket = time;
@


1.11.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d232 2
a233 2
static int stripinit(struct st_softc *);
static 	struct mbuf *strip_btom(struct st_softc *, int);
d262 2
a263 2
static u_char *UnStuffData(u_char *src, u_char *end, u_char
				*dest, u_long dest_length); 
d265 2
a266 2
static u_char *StuffData(u_char *src, u_long length, u_char *dest,
			      u_char **code_ptr_ptr);
d268 9
a276 9
static void RecvErr(char *msg, struct st_softc *sc);
static void RecvErr_Message(struct st_softc *strip_info,
				u_char *sendername, u_char *msg);
void	strip_resetradio(struct st_softc *sc, struct tty *tp);
void	strip_proberadio(struct st_softc *sc, struct tty *tp);
void	strip_watchdog(struct ifnet *ifp);
void	strip_sendbody(struct st_softc *sc, struct mbuf *m);
int	strip_newpacket(struct st_softc *sc, u_char *ptr, u_char *end);
struct mbuf * strip_send(struct st_softc *sc, struct mbuf *m0);
d278 1
a278 1
void strip_timeout(void *x);
a746 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d1715 1
a1715 1
static u_char *
d1843 1
a1843 1
static u_char *
@


1.11.4.4
log
@Sync the SMP branch with 3.3
@
text
@a371 1
		if_alloc_sadl(&sc->sc_if);
d484 1
a484 1
					return (error);
d649 1
a649 1
	if (m0->m_flags & M_PKTHDR) {
d694 1
a694 1
	return (m0);
d719 1
d747 5
d754 3
a756 1
	case AF_INET:
d766 1
a766 1
			return (EHOSTUNREACH);
d772 1
a772 1
	case AF_LINK:
d809 1
a809 1
	  	return (ENOBUFS);
d867 1
a867 1
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m, NULL, error);
d1676 1
a1676 1
	return (packetlen);
d1728 1
a1728 1
	if (!length) return (dest);
d1822 1
a1822 1
	return (dest);
d1856 1
a1856 1
		return (NULL);
d1865 1
a1865 1
					return (NULL);
d1881 1
a1881 1
					return (NULL);
d1894 1
a1894 1
					return (NULL);
d1920 1
a1920 1
		return (NULL);
d1922 1
a1922 1
		return (src);
@


1.11.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.11.4.4 2003/03/28 00:41:28 niklas Exp $	*/
d354 1
a354 2
		snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname,
		    "strip%d", i++);
@


1.11.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.11.4.5 2003/05/13 19:36:15 ho Exp $	*/
d43 5
a47 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d344 2
a345 2
	struct st_softc *sc;
	int i = 0;
d378 1
a378 1
	struct st_softc *sc;
d380 1
a380 1
	caddr_t p;
d440 1
a440 1
	struct tty *tp;
d443 2
a444 2
	struct st_softc *sc;
	int nstrip;
d450 1
a450 1
	if ((error = suser(p, 0)) != 0)
d505 1
a505 1
	struct st_softc *sc;
d575 2
a576 2
	struct tty *tp = sc->sc_ttyp;
	u_char *dp = sc->sc_txbuf;
d578 1
a578 1
	int len;
d629 1
a629 1
	struct tty *tp = sc->sc_ttyp;
d661 1
a661 1
		struct mbuf *m;
d706 1
a706 1
	struct mbuf *m;
d710 5
a714 5
	struct st_softc *sc = ifp->if_softc;
	struct ip *ip;
	struct ifqueue *ifq;
	struct st_header *shp;
	u_char *dldst;		/* link-level next-hop */
d887 1
a887 1
	struct tty *tp;
d889 3
a891 3
	struct st_softc *sc = (struct st_softc *)tp->t_sc;
	struct mbuf *m;
	struct ip *ip;
d895 1
a895 1
	int len = 0;
d973 2
a974 2
			struct mbuf *m1 = m;
			u_char *cp = bpfbuf + SLIP_HDRLEN;
d978 1
a978 1
				int mlen = m1->m_len;
d993 1
a993 1
			u_char *cp = bpfbuf + STRIP_HDRLEN;
d1066 2
a1067 2
	struct st_softc *sc;
	int len;
d1069 1
a1069 1
	struct mbuf *m;
d1114 2
a1115 2
	int c;
	struct tty *tp;
d1117 3
a1119 3
	struct st_softc *sc;
	struct mbuf *m;
	int len;
d1250 1
a1250 1
		u_char *hp = sc->sc_buf - SLIP_HDRLEN;
d1290 1
a1290 1
	struct ifnet *ifp;
d1294 3
a1296 3
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr;
	int s = splimp(), error = 0;
d1364 1
a1364 1
	int i;
d1407 2
a1408 2
	struct st_softc *sc;
	struct tty *tp;
d1490 1
a1490 1
	struct st_softc *sc = ifp->if_softc;
d1579 1
a1579 1
	u_char *ptr, *end;
d1581 2
a1582 2
	int len = ptr - end;
	u_char *name, *name_end;
@


1.11.4.8
log
@Merge with the trunk
@
text
@a1268 2
		if (!ipintrq.ifq_congestion)
			if_congestion(&ipintrq);
@


1.10
log
@undef SLMTU if it's been externally defined
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.9 1997/09/05 04:27:02 millert Exp $	*/
a104 1
#include <sys/buf.h>
@


1.9
log
@Minor changes from ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.8 1997/06/20 09:30:55 deraadt Exp $	*/
d197 3
@


1.8
log
@strip%d not st%d
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.7 1997/06/01 20:40:56 deraadt Exp $	*/
d420 1
a420 1
	sl_compress_init(&sc->sc_comp, -1);
@


1.7
log
@pass Wstrict-prototypes; grr, PR#193
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.6 1997/02/24 13:34:01 niklas Exp $	*/
d350 1
a350 1
		sprintf(sc->sc_if.if_xname, "st%d", i++);
@


1.6
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD: if_strip.c,v 1.2.4.3 1996/08/03 00:58:32 jtc Exp $	*/
d711 1
a711 1
	register const u_char *dldst;		/* link-level next-hop */
d823 1
a823 1
	bcopy((caddr_t)"SIP0", (caddr_t)&shp->starmode_type,
d1396 1
a1396 1
	const char *strip_probestr = "**";
@


1.5
log
@sync to netbsd 0901
@
text
@d1 1
@


1.4
log
@__OpenBSD__
@
text
@d1 1
a1 1
/*	$NetBSD: if_strip.c,v 1.2.4.2 1996/06/26 22:37:00 jtc Exp $	*/
d159 1
a159 1
 * amortizes the header cost.  (Remember that even with
d196 1
a196 1
#define SLMTU		1200 /*XXX*/
d199 2
d203 4
d268 1
d270 1
a270 1
void	strip_esc __P((struct st_softc *sc, struct mbuf *m));
d274 3
a278 3
void ipdump __P((const char *msg, u_char *p, int len));
void stripdump __P((const char *msg, u_char *p, int len));
void stripdumpm __P((const char *msg, struct mbuf *m, int len));
a279 2
#define TXPRINTF(x)	printf x/* causes outrageous delays */
#define RXPRINTF(x)	printf x /* causes outrageous delays */
a281 2
#define TXPRINTF(x)
#define RXPRINTF(x)
a283 1
#define XDPRINTF(x)	/* really verbose debugging */
d298 27
d327 3
a329 2
    printf("strip: XXX: reset state-machine not yet implemented in *BSD\n"); \
    (sc)->sc_if.if_timer = 0; \
d332 2
a333 5
#define CLEAR_RESET_TIMER(sc) \
 do {\
    printf("strip: clearing  reset timeout: not yet implemented in *BSD\n"); \
    (sc)->sc_if.if_timer = 0; \
} while (0)
d364 1
a364 1
		sc->sc_if.if_timer = 15; /* seconds */ 
d383 2
a384 1
			printf("sl%d: can't allocate buffer\n", sc - st_softc);
d390 1
a390 1
	/* get buffer in which to unstuff input */
d396 2
a397 1
			printf("sl%d: can't allocate buffer\n", sc - st_softc);
d403 1
a403 1
	/* get buffer in which to stuff output */
d409 2
a410 1
			printf("sl%d: can't allocate buffer\n", sc - st_softc);
d421 4
d495 1
a495 1
 * Detach the tty from the sl unit.
a505 1
	DPRINTF(("stripclose: closing\n"));
d521 5
d567 1
a567 1
strip_esc(sc, m)
d580 3
a582 1
		 * output buffer.  XXX note that chained calls to stuffdata()
d598 3
d617 2
a618 1
 * XXX manipulates tty queues with putc
d633 3
a635 1
	  	TXPRINTF(("prepend: outq overflow\n"));
d637 1
d648 2
a649 1
		addlog("strip_send: not pkthdr, %d remains\n", m0->m_len); /*XXX*/
d652 4
a655 1
	/* If M_PREPEND() had to prepend a new mbuf, it is now empty. Discard it. */
d663 1
a663 1
	strip_esc(sc, m0);
d680 8
a743 1
		/* XXX untested */
a827 1
	TXPRINTF(("strip address is %16s\n", (char *)shp));
d836 1
a836 1
 /*XXX*/  		DPRINTF(("stripoutput: stalled, resetting\n"));
a845 1
 /*XXX*/  	TXPRINTF(("stripoutput: ifq full\n"));
a850 1
 /*XXX*/  		TXPRINTF(("stripoutput: enqueued pkt, restarting\n"));
d853 7
a859 2
/* XXX FIXME */
	stripstart(sc->sc_ttyp);
d886 11
a896 8
	for (;;) {
/*XXX*/		TXPRINTF(("stripstart\n"));
		/*
		 * If there is more in the output queue, just send it now.
		 * We are being called in lieu of ttstart and must do what
		 * it would.
		 */
		if (tp->t_outq.c_cc != 0) {
d898 12
a909 10
			if (tp->t_outq.c_cc > SLIP_HIWAT) {
			  	TXPRINTF(("stripstart: outq past SLIP_HIWAT\n"));
#if 0
				/* XXX can't  just stop output on
				 *  framed  packet-radio links!
				 */
				return;
#endif
			}
		}
a913 1
		  	TXPRINTF(("(shutdown)\n"));
d924 2
d927 1
a927 1
		if (tp->t_outq.c_cn - tp->t_outq.c_cc < STRIP_MTU_ONWIRE)
a940 1
/*XXX*/			TXPRINTF(("(empty q)\n"));
a1005 1

d1007 1
a1007 1
/*XXX*/	 	 	DPRINTF(("stripsend: failed to send pkt\n"));
d1010 33
a1080 3
		TXPRINTF(("strip_btom: new cluster for sc_buf\n"));
		XDPRINTF(("XXX 1: sc_buf %x end %x hardlim %x\n",
			 sc->sc_buf, sc->sc_mp, sc->sc_ep));
d1125 3
d1130 7
a1136 3
#ifdef notanymore
	case 0x0a:
	/* (leading newline characters are ignored) */
d1138 3
a1140 2
		  return;
#endif
d1142 8
d1152 10
a1161 1
		len = sc->sc_mp - sc->sc_buf;
d1164 10
a1173 21
	 	if (len < 15 || sc->sc_flags & SC_ERROR)
		  	printf("stripinput: end of pkt, len %d, err %d\n",
				 len, sc->sc_flags & SC_ERROR); /*XXX*/
#endif
		if(sc->sc_flags & SC_ERROR) {
			sc->sc_flags &= ~SC_ERROR;
			goto newpack;
		}

		/*
		 * We have a frame.
		 * Process an IP packet, ARP packet, AppleTalk packet,
		 * AT command resposne, or Starmode error.
		 */
		len = strip_newpacket(sc, sc->sc_buf, sc->sc_mp);
		if (len <= 1)
			/* less than min length packet - ignore */
			goto newpack;
#if DEBUG > 1
		ipdump("after destuff", sc->sc_buf, len);
#endif /* DEBUG */		
d1175 9
d1187 11
a1197 11
		if (sc->sc_bpf) {
			/*
			 * Save the compressed header, so we
			 * can tack it on later.  Note that we
			 * will end up copying garbage in some
			 * cases but this is okay.  We remember
			 * where the buffer started so we can
			 * compute the new header length.
			 */
			bcopy(sc->sc_buf, chdr, CHDR_LEN);
		}
d1200 22
a1221 25
		if ((c = (*sc->sc_buf & 0xf0)) != (IPVERSION << 4)) {
			if (c & 0x80)
				c = TYPE_COMPRESSED_TCP;
			else if (c == TYPE_UNCOMPRESSED_TCP)
				*sc->sc_buf &= 0x4f; /* XXX */
			/*
			 * We've got something that's not an IP packet.
			 * If compression is enabled, try to decompress it.
			 * Otherwise, if `auto-enable' compression is on and
			 * it's a reasonable packet, decompress it and then
			 * enable compression.  Otherwise, drop it.
			 */
			if (sc->sc_if.if_flags & SC_COMPRESS) {
				len = sl_uncompress_tcp(&sc->sc_buf, len,
							(u_int)c, &sc->sc_comp);
				if (len <= 0)
					goto error;
			} else if ((sc->sc_if.if_flags & SC_AUTOCOMP) &&
			    c == TYPE_UNCOMPRESSED_TCP && len >= 40) {
				len = sl_uncompress_tcp(&sc->sc_buf, len,
							(u_int)c, &sc->sc_comp);
				if (len <= 0)
					goto error;
				sc->sc_if.if_flags |= SC_COMPRESS;
			} else
d1223 5
a1227 1
		}
d1229 8
a1236 8
		if (sc->sc_bpf) {
			/*
			 * Put the SLIP pseudo-"link header" in place.
			 * We couldn't do this any earlier since
			 * decompression probably moved the buffer
			 * pointer.  Then, invoke BPF.
			 */
			register u_char *hp = sc->sc_buf - SLIP_HDRLEN;
d1238 4
a1241 4
			hp[SLX_DIR] = SLIPDIR_IN;
			bcopy(chdr, &hp[SLX_CHDR], CHDR_LEN);
			bpf_tap(sc->sc_bpf, hp, len + SLIP_HDRLEN);
		}
d1243 3
a1245 19
		m = strip_btom(sc, len);
		if (m == NULL)
			goto error;

		sc->sc_if.if_ipackets++;
		sc->sc_if.if_lastchange = time;
		s = splimp();
		if (IF_QFULL(&ipintrq)) {
			IF_DROP(&ipintrq);
			DPRINTF(("stripinput: ipintrq full\n"));
			sc->sc_if.if_ierrors++;
			sc->sc_if.if_iqdrops++;
			m_freem(m);
		} else {
			IF_ENQUEUE(&ipintrq, m);
			schednetisr(NETISR_IP);
		}
		splx(s);
		goto newpack;
d1248 11
a1258 4
	if (sc->sc_mp < sc->sc_ep) {
		*sc->sc_mp++ = c;
		/*sc->sc_escape = 0;*/
		return;
d1260 2
a1261 5

	/* can't put lower; would miss an extra frame */
	sc->sc_flags |= SC_ERROR;
	DPRINTF(("stripinput: overran buf\n"));
	goto quiet_error;
a1263 2
	RXPRINTF(("stripinput: error\n"));
quiet_error:
a1264 1
	goto quiet_newpack;
d1267 1
a1267 2
	/*DPRINTF(("stripinput: newpack\n"));*/	 /* XXX */
quiet_newpack:
d1328 2
d1348 1
a1348 1
		"\r\rat\r\r\rate0q1dt**starmode\r*\r";
a1351 2

	DPRINTF(("strip: resetting radio\n"));
d1355 1
d1362 6
a1367 6
#ifdef linux /*XXX*/
	/* reset the watchdog counter */
	sc->watchdog_doprobe = jiffies + 10 * HZ;
	sc->watchdog_doreset = jiffies + 1 * HZ;
#endif

d1369 1
d1377 66
d1445 18
a1462 4
 * The radio hardware is balky and sometimes crashes doesn't reste properly,
 * or crashes and reboots into Hayes-emulation mode.
 * If we don't hear a starmode-only response from the radio within a
 *  given time, reset it.
d1469 17
d1487 35
d1523 6
a1528 2
	if (0) {
		addlog("%s: watchdog\n", ifp->if_xname);
d1530 2
a1531 1
		++ifp->if_oerrors;
d1534 2
a1535 1
	sc->sc_if.if_timer = 15; /* seconds */ 
d1541 5
a1545 2
 * The following is taken, with permission of the author, from
 * the LInux strip  driver. 
d1576 1
a1576 1
			RecvErr_Message(sc, NULL, ptr);
d1580 1
a1580 1
			addlog("(len = %d\n", len);
a1595 2
		XDPRINTF(("XXX 3: sc_buf %x ptr %x end %x mp %x hardlim %x\n",
			 sc->sc_buf, ptr, end, sc->sc_mp, sc->sc_ep));
d1605 1
a1605 1
			RecvErr_Message(sc, name, ptr);
d1614 1
a1614 1
	if (!ptr) {
d1619 5
a1623 1
	/* XXX is this the IP header length, or what? */
d1635 1
a1635 1
	if (!ptr) {
d1796 1
a1796 1
 * "dest", up to a  maximum of "dest_length", and returns the new
d1801 1
a1801 1
 * 1. The source data runs out before extracting "dest_length" bytes:
d1803 1
a1803 1
 * 2. The source data produces exactly "dest_length" bytes:
d1806 1
a1806 1
 * 3. "dest_length" bytes are extracted, with more
d1810 1
a1810 1
 * Note: The decoding may be destructive, in that it may alter the
d1816 1
a1816 1
UnStuffData(u_char *src, u_char *end, u_char *dest, u_long dest_length)
d1818 1
a1818 1
	u_char *dest_end = dest + dest_length;
d1821 1
a1821 1
	if (!src || !end || !dest || !dest_length)
d1824 2
a1825 1
	while (src < end && dest < dest_end) {
d1833 4
a1836 2
					*dest++ = *++src ^ Stuff_Magic;
				while(--count >= 0 && dest < dest_end);
d1839 2
a1840 1
				else if (count == 0)
d1849 4
a1852 2
					*dest++ = *++src ^ Stuff_Magic;
				while(--count >= 0 && dest < dest_end);
d1862 4
a1865 2
					*dest++ = src[1] ^ Stuff_Magic;
				while(--count >= 0 && dest < dest_end);
d1873 4
a1876 2
					*dest++ = 0;
				while(--count >= 0 && dest < dest_end);
d1885 1
a1885 1
	if (dest < dest_end)
d1922 1
a1922 1
	addlog("%13s : %s\n", msg, pkt_text);
d1928 3
d1953 1
a1953 1
		RecvErr("Error Msg:", strip_info);
d1959 1
a1959 1
		RecvErr("Error Msg:", strip_info);
d1970 1
a1970 1
		RecvErr("Error Msg:", strip_info);
d1973 10
a1982 8
	else if (!strncmp(msg, ERR_004, sizeof(ERR_004)-1))
	{
#ifdef notyet /* FIXME jrs */ 
        	strip_info->watchdog_doreset = jiffies + LONG_TIME;
		if (!strip_info->working)
		{
			strip_info->working = 1;
			addlog("%s: Radio now in starmode\n", if_name);
d1984 1
a1984 1
#endif
d1987 1
a1987 1
        	RecvErr("Error Msg:", strip_info);
d1989 1
a1989 1
        	RecvErr("Error Msg:", strip_info);
d1996 1
a1996 1
		RecvErr("Error Msg:", strip_info);
d1999 1
a1999 3
#ifdef FIXME /* FIXME jrs */ 
		strip_info->watchdog_doreset = jiffies;		/* Do reset ASAP */
#endif
d2003 1
a2003 1
		RecvErr("Error Msg:", strip_info);
d2008 4
a2011 47
        	RecvErr("Error Msg:", strip_info);
	else
		RecvErr("Error Msg:", strip_info);
}

#ifdef DEBUG
void
stripdumpm(msg, m, len)
     	const char *msg;
	struct mbuf *m;
{
  stripdump(msg, mtod(m, u_char*), len);
  /*XXX*/
}

void
stripdump(msg, p, len)
	const char *msg;
	u_char *p;
	int len;
{
	register int i;


	printf(msg);
	for (i = 0; i < STRIP_HDRLEN; i++)
		printf("%c", p[i]);
	printf("\n");

	p += STRIP_HDRLEN;
	for (i = 0; i < 32; i++) {
	  	printf("%02x ", p[i]);
	}
		printf("\n");
}

void
ipdump(msg, p, len)
	const char *msg;
	u_char *p;
	int len;
{
	register int i;

	printf(msg);
	for (i = 0; i < 32; i++) {
	  	printf("%02x ", p[i]);
a2012 1
		printf("\n");
a2014 1
#endif /* DEBUG */
@


1.3
log
@various fixes
@
text
@d112 1
a112 1
#if __NetBSD__
d138 1
a138 1
#ifdef __NetBSD__	/* XXX -- jrs */
d201 1
a201 1
#ifndef __NetBSD__					/* XXX - cgd */
d408 1
a408 1
#ifdef __NetBSD__
d426 1
a426 1
#ifdef __NetBSD__
d489 1
a489 1
#ifdef __NetBSD__
d823 1
a823 1
#ifndef __NetBSD__					/* XXX - cgd */
d853 1
a853 1
#if defined(__NetBSD__)					/* XXX - cgd */
d928 1
a928 1
#ifndef __NetBSD__					/* XXX - cgd */
@


1.2
log
@init sc_unit properly
@
text
@d1 1
a1 1
/*	$NetBSD: if_strip.c,v 1.2.4.1 1996/06/05 23:23:02 thorpej Exp $	*/
d198 1
d258 2
a259 2
static void RecErr __P((char *msg, struct st_softc *sc));
static void RecERR_Message __P((struct st_softc *strip_info,
d261 2
a262 1
void	resetradio __P((struct st_softc *sc, struct tty *tp));
d299 1
d305 2
a306 1
 } while (0)
d335 3
d428 1
a428 1
			 * make sure tty output queue is large enough
d430 4
a433 4
			 * end, and a possible extra frame end).  full-sized
			 * packet occupies a max of 2*SLMTU bytes (because
			 * of possible escapes), and add two on for frame
			 * ends.
d436 1
a436 1
			if (tp->t_outq.c_cn < 2*SLMTU+2) {
d451 1
a451 1
			resetradio(sc, tp);
a523 1
/*XXX*/
d525 2
a526 2
 * Take an mbuf chain  containing a SLIP packet, byte-stuff (escape)
 * the packet, and enqueue it on the tty send queue.
d534 1
a534 2
	register u_char *cp;
	register u_char *ep;
d537 1
a537 1
	u_char         *stuffstate = NULL;
a539 1
		cp = mtod(m, u_char *); ep = cp + m->m_len;
d541 4
a544 2
		 * Find out how many bytes in the string we can
		 * handle without doing something special.
d546 1
a546 2
		ep = StuffData(cp, m->m_len, sc->sc_txbuf, &stuffstate);
		len = ep - sc->sc_txbuf;
a547 8
		/*
		 * Put n characters at once
		 * into the tty output queue.
		 */
		if (b_to_q((ttychar_t *)sc->sc_txbuf,
			   len, &tp->t_outq))
			goto bad;
		sc->sc_if.if_obytes += len;
d551 11
d569 1
d573 2
d593 1
a593 1
	/* XXX undo M_PREPEND() */
d596 1
a596 1
	if (m0 && m0->m_flags & M_PKTHDR)
d598 12
a609 1
	
d611 1
d804 1
d809 1
d839 2
a840 2
				   framed  packet-radio links!
				   */
a852 1
#if 0						 	/* XXX - jrs*/
d858 2
a859 1
		 * escapes this could be as bad as SLMTU*2+2.
d861 1
a861 1
		if (tp->t_outq.c_cn - tp->t_outq.c_cc < 2*SLMTU+2)
a863 1
#endif
d914 1
d920 4
a923 3
			bpfbuf[SLX_DIR] = SLIPDIR_OUT;
			bcopy(mtod(m, caddr_t), &bpfbuf[SLX_CHDR], CHDR_LEN);
			bpf_tap(sc->sc_bpf, bpfbuf, len + SLIP_HDRLEN);
d1054 5
a1166 1
	/*sc->sc_escape = 0;*/
d1232 1
d1235 1
a1235 1
resetradio(sc, tp)
d1244 1
a1244 1
		"\r\rat\r\r\rate0dt**starmode\r*\r";
d1250 3
d1264 1
a1264 1
	/*XXX jrs DANGEROUS - does this help? */
d1267 3
a1269 1
	/*XXX jrs DANGEROUS - does this work? */
d1273 24
d1299 1
a1299 2
 * XXX
 * The following is taken, with permisino of the author, from
d1331 2
a1332 1
			RecERR_Message(sc, NULL, ptr); /* XXX stuart? */
d1334 1
a1334 1
			RecErr("No initial *", sc);
d1350 1
a1350 1
		RecErr("No second *", sc);
d1362 1
a1362 1
			RecERR_Message(sc, name, ptr);
d1364 1
a1364 1
		else RecErr("No SRIP key", sc);
d1372 1
a1372 1
		RecErr("Runt packet (hdr)", sc);
d1378 2
d1384 1
d1389 1
a1389 1
		RecErr("Short packet", sc);
d1393 2
a1394 5
	/* XXX*/ bcopy(sc->sc_rxbuf, sc->sc_buf, packetlen );

#ifdef linux
	strip_bump(sc, packetlen);
#endif
d1450 2
a1451 2
		code  = *code_ptr & Stuff_CodeMask;
		count = *code_ptr & Stuff_CountMask;
d1573 1
d1575 1
a1575 1
		return(NULL);	/* Sanity check */
d1638 1
a1638 2
 * rom the STRIP driver.
 * XXX check with original author.
d1641 1
a1641 1
RecErr(msg, sc)
a1666 4
#ifdef linux
	set_bit(SLF_ERROR, &sc->flags);
	sc->rx_errors++;
#endif /* linux */
d1670 1
a1670 10
/*
 * Log an error message for a packet recieved from a remote Metricom
 * radio.  Update the radio-reset timer if the message is one that
 * is generated only in starmode.
 *
 * We only call this function when we have an error message from
 * the radio, which can only happen after seeing a frame delimeter
 * in the input-side routine; so it's safe to call the output side
 * to reset the radio.
 */
d1672 2
a1673 2
RecERR_Message(sc, sendername, msg)
	struct st_softc *sc;
d1675 1
a1675 1
	u_char *msg;
d1677 23
a1699 11
	static const char ERR_001[] = "ERR_001 Not in StarMode!";
	static const char ERR_002[] = "ERR_002 Remap handle";
	static const char ERR_003[] = "ERR_003 Can't resolve name";
	static const char ERR_004[] = "ERR_004 Name too small or missing";
	static const char ERR_007[] = "ERR_007 Body too big";
	static const char ERR_008[] = "ERR_008 Bad character in name";

	if (!strncmp(msg, ERR_001, sizeof(ERR_001)-1)) {
		printf("Radio %s is not in StarMode\n", sendername);
	}
	else if (!strncmp(msg, ERR_002, sizeof(ERR_002)-1)) {
d1704 2
a1705 1
		printf("Radio name %s is handle %d\n", newname, handle);
d1707 14
d1722 24
a1745 7
	else if (!strncmp(msg, ERR_003, sizeof(ERR_003)-1)) {
		printf("Radio name <unspecified> is unknown (\"Can't resolve name\" error)\n");
		}
	else if (!strncmp(msg, ERR_004, sizeof(ERR_004)-1)) {
		CLEAR_RESET_TIMER(sc);
		/* printf("%s: Received tickle response; clearing watchdog_doreset timer.\n",
			sc->sc_if.if_xname); */
d1747 4
a1750 9
	else if (!strncmp(msg, ERR_007, sizeof(ERR_007)-1)) {
		/* Note: This error knoks the radio back into command mode. */
		printf("Error! Packet size <unspecified> is too big for radio.");
		FORCE_RESET(sc);		/* Do reset ASAP */
		}
	else if (!strncmp(msg, ERR_008, sizeof(ERR_008)-1)) {
		printf("Name <unspecified> contains illegal character\n");
		}
	else RecErr("Error Msg:", sc);
@


1.1
log
@sync
@
text
@d1 1
a1 1
/*	$NetBSD: if_strip.c,v 1.2 1996/05/19 22:09:36 jonathan Exp $	*/
d317 1
a319 1
		sc->sc_unit = i;		/* XXX */
@
