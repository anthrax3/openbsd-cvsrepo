head	1.27;
access;
symbols
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	UBC_SYNC_A:1.27
	UBC_SYNC_B:1.27
	SMP:1.27.0.2
	OPENBSD_2_4:1.24.0.2
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.27
date	99.02.24.22.36.19;	author angelos;	state dead;
branches;
next	1.26;

1.26
date	99.01.11.22.52.49;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	99.01.07.06.05.02;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.08.19.13.29.18;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	98.05.24.14.13.57;	author provos;	state Exp;
branches;
next	1.22;

1.22
date	98.05.18.21.10.15;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	98.04.08.10.58.03;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	98.02.22.01.23.29;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.11.15.00.07.06;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.11.04.09.10.53;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	97.10.02.02.31.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.09.28.22.57.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.07.28.18.53.21;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.07.27.23.30.31;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.07.23.12.07.04;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.07.21.21.10.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.18.18.09.48;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.07.15.23.11.08;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.07.14.08.46.39;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.07.11.23.37.51;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.07.02.06.58.40;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.07.01.22.12.40;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.06.25.07.53.19;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.06.17.23.25.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.04.25.01.19.20;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.24.13.33.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Not used anymore.
@
text
@/*	$OpenBSD: encap.c,v 1.26 1999/01/11 22:52:49 angelos Exp $	*/

/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/ioctl.h>
#include <vm/vm.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>
#include <net/raw_cb.h>
#include <machine/stdarg.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#endif 

#include <net/encap.h>
#include <netinet/ip_ipsp.h>
#include <netinet/ip_ip4.h>

#include <sys/syslog.h>

void encap_init(void);
void encap_sendnotify(int, struct tdb *, void *);
int encap_notify_sa(u_int32_t, struct in_addr, struct in_addr, 
    u_int16_t, u_int16_t, u_int16_t, u_int16_t);
int encap_enable_spi(u_int32_t, struct in_addr, struct in_addr, struct in_addr,
    struct in_addr, struct in_addr, u_int16_t, u_int16_t, 
    u_int16_t, u_int16_t, u_int16_t);
int encap_output __P((struct mbuf *, ...));
int encap_usrreq(struct socket *, int, struct mbuf *, struct mbuf *, 
		 struct mbuf *);
int encap_sysctl(int *, u_int, void *, size_t *, void *, size_t);

extern int tdb_init(struct tdb *, struct mbuf *);

extern struct domain encapdomain;

extern struct inpcbtable tcbtable; /* Notify - XXX */
extern struct inpcbtable udbtable; /* Notify - XXX */
extern struct inpcbtable rawcbtable; /* Notify - XXX */

struct sockaddr encap_dst = { 2, PF_ENCAP, };
struct sockaddr encap_src = { 2, PF_ENCAP, };
struct sockproto encap_proto = { PF_ENCAP, };

struct protosw encapsw[] = { 
    { SOCK_RAW,	&encapdomain,	0,		PR_ATOMIC|PR_ADDR,
      raw_input,	encap_output,	raw_ctlinput,	0,
      encap_usrreq,
      encap_init,	0,		0,		0,
      encap_sysctl
    },
};

struct domain encapdomain =
{ AF_ENCAP, "encapsulation", 0, 0, 0, 
  encapsw, &encapsw[sizeof(encapsw) / sizeof(encapsw[0])], 0,
  rn_inithead, 16, sizeof(struct sockaddr_encap)};

/*
 * Sysctl for encap variables
 */
int
encap_sysctl(int *name, u_int namelen, void *oldp, size_t *oldplenp, 
	     void *newp, size_t newlen)
{
    /* All sysctl names at this level are terminal */
    if (namelen != 1)
      return ENOTDIR;

    switch (name[0]) 
    {
        case ENCAPCTL_ENCDEBUG:
	    return (sysctl_int(oldp, oldplenp, newp, newlen, &encdebug));

	default:
	    return ENOPROTOOPT;
    }
    /* Not reached */
}

void
encap_init()
{
    struct xformsw *xsp;
    
    for (xsp = xformsw; xsp < xformswNXFORMSW; xsp++)
    {
	/*log(LOG_INFO, "encap_init(): attaching <%s>\n", xsp->xf_name);*/
	(*(xsp->xf_attach))();
    }
}

/*ARGSUSED*/
int
encap_usrreq(register struct socket *so, int req, struct mbuf *m, 
	     struct mbuf *nam, struct mbuf *control)
{
    register struct rawcb *rp = sotorawcb(so);
    register int error = 0;
    int s;
    
    if (req == PRU_ATTACH)
    {
	MALLOC(rp, struct rawcb *, sizeof(*rp), M_PCB, M_WAITOK);
        if (rp == (struct rawcb *) NULL)
	  return ENOBUFS;

	if ((so->so_pcb = (caddr_t) rp))
	  bzero(so->so_pcb, sizeof(*rp));
    }

    s = splnet();
    error = raw_usrreq(so, req, m, nam, control);
    rp = sotorawcb(so);
    if ((req == PRU_ATTACH) && rp)
    {
	/* int af = rp->rcb_proto.sp_protocol; */
	
	if (error)
	{
	    free((caddr_t) rp, M_PCB);
	    splx(s);
	    return error;
	}
	rp->rcb_faddr = &encap_src;
	soisconnected(so);
	so->so_options |= SO_USELOOPBACK;
    }
    splx(s);
    return error;
}

int
encap_notify_sa(u_int32_t spi, struct in_addr dst, struct in_addr src,
		u_int16_t sport, u_int16_t dport, u_int16_t protocol, 
		u_int16_t sproto)
{
	struct inpcbtable *table = NULL;
	struct inpcb *inp = NULL;
	struct in_addr altm, zeroin_addr;
	struct tdb *tdbp;
	struct flow *flow;
	int error = 0;
	u_int8_t secrequire;

	altm.s_addr = INADDR_BROADCAST;
    
	switch (protocol) {
	case IPPROTO_TCP:
		table = &tcbtable;
		break;
	case IPPROTO_UDP:
		table = &udbtable;
		break;
	default:
		break;
	}

	if (table != NULL) {
		/* Protocols with own inpcb tables */
		bzero((caddr_t)&zeroin_addr, sizeof(zeroin_addr));
		inp = in_pcblookup(table, &dst, dport, &zeroin_addr, sport, 
		    INPLOOKUP_WILDCARD);
	} else {
		/* RAW protocol - taken from raw_ip.c */
		/* XXX - we can have more than one inp sleeping here */
		for (inp = rawcbtable.inpt_queue.cqh_first;
		     inp != (struct inpcb *)&rawcbtable.inpt_queue;
		     inp = inp->inp_queue.cqe_next) {
			if (!inp->inp_socket || 
			    inp->inp_socket->so_proto->pr_protocol != protocol)
				continue;
			if (inp->inp_faddr.s_addr && 
			    inp->inp_faddr.s_addr != dst.s_addr)
				continue;
			if (inp->inp_secrequire != 0 && 
			    inp->inp_secresult == SR_WAIT)
				break;
		}	    
		if (inp == (struct inpcb *)&rawcbtable.inpt_queue)
			inp = NULL;
	}

#ifdef ENCDEBUG
	if (encdebug && inp != NULL)
		printf("encap: found inp for protocol %d\n", protocol);
#endif /* ENCDEBUG */

	if (inp && inp->inp_secresult == SR_WAIT && inp->inp_secrequire != 0) {
		secrequire = inp->inp_secrequire;
	} else {
		/* 
		 * XXX - is this the right thing to do ?? We need to know if 
		 * IPSec is already in use.
		 * This does only work for host-to-host 
		 */
		flow = find_global_flow(src, altm, dst, altm, 0,0,0);
		if (flow == (struct flow *)NULL)
			return (ENOENT);

		SPI_CHAIN_ATTRIB(secrequire, tdb_onext, flow->flow_sa);
#ifdef ENCDEBUG
		if (encdebug)
			printf("encap: Existing flow (%0x) requires: %d\n", 
			       flow, secrequire);
#endif /* ENCDEBUG */
	}

	if (spi == 0) {
#ifdef ENCDEBUG
		if (encdebug)
			printf("encap: key management failed\n");
#endif
		if (inp != NULL) {
			inp->inp_secresult = SR_FAILED;
			wakeup(inp);
		}
		return (0);
	} else {
		u_int8_t sa_have;

		tdbp = gettdb(spi, dst, sproto);
		if (tdbp == NULL)
			return (ENOENT);
#ifdef ENCDEBUG
		if (encdebug)
			printf("encap: found tdb\n");
#endif /* ENCDEBUG */
		    
		SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdbp);

		/* Requirements not met */
		if (secrequire & ~sa_have)
			return (EINVAL);
#ifdef ENCDEBUG
		if (encdebug)
			printf("encap: tdb meets requirements\n");
#endif /* ENCDEBUG */

		/*
		 * This is a stupid hack, we do not support socketwise
		 * keying at the moment, so we do it for the whole host
		 */
		error = encap_enable_spi(spi, dst, src, altm, dst, altm,
					 0, 0, 0, sproto, 
					 ENABLE_FLAG_REPLACE|ENABLE_FLAG_LOCAL);

		if (!error) {
#ifdef ENCDEBUG
			if (encdebug)
				printf("encap: key management succeeded\n");
#endif /* ENCDEBUG */
			if (inp != NULL) {
				inp->inp_secresult = SR_SUCCESS;
				wakeup(inp);
			}
		}
	}

	return (error);
}

int
encap_enable_spi(u_int32_t spi, struct in_addr dst,
		 struct in_addr isrc, struct in_addr ismask,
		 struct in_addr idst, struct in_addr idmask,
		 u_int16_t sport, u_int16_t dport,
		 u_int16_t protocol, u_int16_t sproto,
		 u_int16_t flags)
{
	struct sockaddr_encap encapdst, encapgw, encapnetmask;
	struct flow *flow, *flow2, *flow3, *flow4;
	struct in_addr alts, altm;
	struct tdb *tdbp;
	int error = 0;

	tdbp = gettdb(spi, dst, sproto);
	if (tdbp == NULL)
		return (ENOENT);

	bzero((caddr_t) &encapdst, sizeof(struct sockaddr_encap));
	bzero((caddr_t) &encapnetmask, sizeof(struct sockaddr_encap));
	bzero((caddr_t) &encapgw, sizeof(struct sockaddr_encap));

	flow = flow2 = flow3 = flow4 = (struct flow *) NULL;

	/* Retrieve source and destination masks from routing entry */
	if (flags & ENABLE_FLAG_MODIFY) {
		struct route_enc re0, *re = &re0;
		struct sockaddr_encap *dest, *mask;

		bzero((caddr_t) re, sizeof(*re));
		dest = (struct sockaddr_encap *) &re->re_dst;
		dest->sen_family = AF_ENCAP;
		dest->sen_len = SENT_IP4_LEN;
		dest->sen_type = SENT_IP4;
		dest->sen_ip_src = tdbp->tdb_src;
		dest->sen_ip_dst = dst;
		dest->sen_proto = protocol;
		dest->sen_sport = sport;
		dest->sen_dport = dport;
		rtalloc((struct route *) re);
		if (re->re_rt == NULL)
			return (ENOENT);

		mask = (struct sockaddr_encap *) (rt_mask(re->re_rt));
		if (mask == NULL)
			return (ENOENT);

		ismask.s_addr = mask->sen_ip_src.s_addr;
		idmask.s_addr = mask->sen_ip_dst.s_addr;

		RTFREE(re->re_rt);
	}

	isrc.s_addr &= ismask.s_addr;
	idst.s_addr &= idmask.s_addr;

	flow3 = find_global_flow(isrc, ismask, idst, idmask, 
				 protocol, sport, dport);
	if ((flow3 != (struct flow *) NULL) && !(flags & ENABLE_FLAG_REPLACE))
		return (EEXIST);

	/* Check for 0.0.0.0/255.255.255.255 if the flow is local */
	if (flags & ENABLE_FLAG_LOCAL) {
		alts.s_addr = INADDR_ANY;
		altm.s_addr = INADDR_BROADCAST;
		flow4 = find_global_flow(alts, altm, idst, idmask, 
					 protocol, sport, dport);
		if (flow4 != (struct flow *) NULL) {
			if (!(flags & ENABLE_FLAG_REPLACE))
				return (EEXIST);
			else if (flow3 == flow4)
				return (EINVAL);
		}
	}

	flow = get_flow();
	if (flow == (struct flow *) NULL)
		return (ENOBUFS);

	flow->flow_src.s_addr = isrc.s_addr;
	flow->flow_dst.s_addr = idst.s_addr;
	flow->flow_srcmask.s_addr = ismask.s_addr;
	flow->flow_dstmask.s_addr = idmask.s_addr;
	flow->flow_proto = protocol;
	flow->flow_sport = sport;
	flow->flow_dport = dport;

	if (flags & ENABLE_FLAG_LOCAL) {
		flow2 = get_flow();
		if (flow2 == (struct flow *) NULL) {
			FREE(flow, M_TDB);
			return (ENOBUFS);
		}

		flow2->flow_src.s_addr = INADDR_ANY;
		flow2->flow_dst.s_addr = idst.s_addr;
		flow2->flow_srcmask.s_addr = INADDR_BROADCAST;
		flow2->flow_dstmask.s_addr = idmask.s_addr;
		flow2->flow_proto = protocol;
		flow2->flow_sport = sport;
		flow2->flow_dport = dport;

		put_flow(flow2, tdbp);
	}

	put_flow(flow, tdbp);

	/* Setup the encap fields */
	encapdst.sen_len = SENT_IP4_LEN;
	encapdst.sen_family = AF_ENCAP;
	encapdst.sen_type = SENT_IP4;
	encapdst.sen_ip_src.s_addr = flow->flow_src.s_addr;
	encapdst.sen_ip_dst.s_addr = flow->flow_dst.s_addr;
	encapdst.sen_proto = flow->flow_proto;
	encapdst.sen_sport = flow->flow_sport;
	encapdst.sen_dport = flow->flow_dport;

	encapgw.sen_len = SENT_IPSP_LEN;
	encapgw.sen_family = AF_ENCAP;
	encapgw.sen_type = SENT_IPSP;
	encapgw.sen_ipsp_dst.s_addr = tdbp->tdb_dst.s_addr;
	encapgw.sen_ipsp_spi = tdbp->tdb_spi;
	encapgw.sen_ipsp_sproto = tdbp->tdb_sproto;

	encapnetmask.sen_len = SENT_IP4_LEN;
	encapnetmask.sen_family = AF_ENCAP;
	encapnetmask.sen_type = SENT_IP4;
	encapnetmask.sen_ip_src.s_addr = flow->flow_srcmask.s_addr;
	encapnetmask.sen_ip_dst.s_addr = flow->flow_dstmask.s_addr;

	if (flow->flow_proto) {
		encapnetmask.sen_proto = 0xff;

		if (flow->flow_sport)
			encapnetmask.sen_sport = 0xffff;

		if (flow->flow_dport)
			encapnetmask.sen_dport = 0xffff;
	}

	/* If this is set, delete any old route for this flow */
	if (flags & ENABLE_FLAG_REPLACE)
		rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
			  (struct sockaddr *) 0,
			  (struct sockaddr *) &encapnetmask, 0,
			  (struct rtentry **) 0);

	/* Add the entry in the routing table */
	error = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
			  (struct sockaddr *) &encapgw,
			  (struct sockaddr *) &encapnetmask,
			  RTF_UP | RTF_GATEWAY | RTF_STATIC,
			  (struct rtentry **) 0);
	    
	if (error) {
		encapdst.sen_len = SENT_IP4_LEN;
		encapdst.sen_family = AF_ENCAP;
		encapdst.sen_type = SENT_IP4;
		encapdst.sen_ip_src.s_addr = flow3->flow_src.s_addr;
		encapdst.sen_ip_dst.s_addr = flow3->flow_dst.s_addr;
		encapdst.sen_proto = flow3->flow_proto;
		encapdst.sen_sport = flow3->flow_sport;
		encapdst.sen_dport = flow3->flow_dport;

		encapgw.sen_len = SENT_IPSP_LEN;
		encapgw.sen_family = AF_ENCAP;
		encapgw.sen_type = SENT_IPSP;
		encapgw.sen_ipsp_dst.s_addr = flow3->flow_sa->tdb_dst.s_addr;
		encapgw.sen_ipsp_spi = flow3->flow_sa->tdb_spi;
		encapgw.sen_ipsp_sproto = flow3->flow_sa->tdb_sproto;

		encapnetmask.sen_len = SENT_IP4_LEN;
		encapnetmask.sen_family = AF_ENCAP;
		encapnetmask.sen_type = SENT_IP4;
		encapnetmask.sen_ip_src.s_addr = flow3->flow_srcmask.s_addr;
		encapnetmask.sen_ip_dst.s_addr = flow3->flow_dstmask.s_addr;

		if (flow3->flow_proto) {
			encapnetmask.sen_proto = 0xff;
	    
			if (flow3->flow_sport)
				encapnetmask.sen_sport = 0xffff;
	    
			if (flow->flow_dport)
				encapnetmask.sen_dport = 0xffff;
		}
		
		/* Try to add the old entry back in */
		rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
			  (struct sockaddr *) &encapgw,
			  (struct sockaddr *) &encapnetmask,
			  RTF_UP | RTF_GATEWAY | RTF_STATIC,
			  (struct rtentry **) 0);
	    
		delete_flow(flow, tdbp);
		if (flow2)
			delete_flow(flow2, tdbp);
		return (error);
	}

	/* If this is a "local" packet flow */
	if (flags & ENABLE_FLAG_LOCAL) {
		encapdst.sen_ip_src.s_addr = INADDR_ANY;
		encapnetmask.sen_ip_src.s_addr = INADDR_BROADCAST;

		if (flags & ENABLE_FLAG_REPLACE)
			rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
				  (struct sockaddr *) 0,
				  (struct sockaddr *) &encapnetmask, 0,
				  (struct rtentry **) 0);

		error = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				  (struct sockaddr *) &encapgw,
				  (struct sockaddr *) &encapnetmask,
				  RTF_UP | RTF_GATEWAY | RTF_STATIC,
				  (struct rtentry **) 0);

		if (error) {
				/* Delete the first entry inserted */
			encapdst.sen_ip_src.s_addr = isrc.s_addr;
			encapnetmask.sen_ip_src.s_addr = ismask.s_addr;

			rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
				  (struct sockaddr *) 0,
				  (struct sockaddr *) &encapnetmask, 0,
				  (struct rtentry **) 0);

				/* Setup the old entries */
			encapdst.sen_len = SENT_IP4_LEN;
			encapdst.sen_family = AF_ENCAP;
			encapdst.sen_type = SENT_IP4;
			encapdst.sen_ip_src.s_addr = flow3->flow_src.s_addr;
			encapdst.sen_ip_dst.s_addr = flow3->flow_dst.s_addr;
			encapdst.sen_proto = flow3->flow_proto;
			encapdst.sen_sport = flow3->flow_sport;
			encapdst.sen_dport = flow3->flow_dport;

			encapgw.sen_len = SENT_IPSP_LEN;
			encapgw.sen_family = AF_ENCAP;
			encapgw.sen_type = SENT_IPSP;
			encapgw.sen_ipsp_dst.s_addr = flow3->flow_sa->tdb_dst.s_addr;
			encapgw.sen_ipsp_spi = flow3->flow_sa->tdb_spi;
			encapgw.sen_ipsp_sproto = flow3->flow_sa->tdb_sproto;
		   
			encapnetmask.sen_len = SENT_IP4_LEN;
			encapnetmask.sen_family = AF_ENCAP;
			encapnetmask.sen_type = SENT_IP4;
			encapnetmask.sen_ip_src.s_addr = flow3->flow_srcmask.s_addr;
			encapnetmask.sen_ip_dst.s_addr = flow3->flow_dstmask.s_addr;

			if (flow3->flow_proto) {
				encapnetmask.sen_proto = 0xff;
		
				if (flow3->flow_sport)
					encapnetmask.sen_sport = 0xffff;

				if (flow->flow_dport)
					encapnetmask.sen_dport = 0xffff;
			}
		
			rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				  (struct sockaddr *) &encapgw,
				  (struct sockaddr *) &encapnetmask,
				  RTF_UP | RTF_GATEWAY | RTF_STATIC,
				  (struct rtentry **) 0);

			encapdst.sen_ip_src.s_addr = INADDR_ANY;
			encapnetmask.sen_ip_src.s_addr = INADDR_BROADCAST;

			rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				  (struct sockaddr *) &encapgw,
				  (struct sockaddr *) &encapnetmask,
				  RTF_UP | RTF_GATEWAY | RTF_STATIC,
				  (struct rtentry **) 0);

			delete_flow(flow, tdbp);
			delete_flow(flow2, tdbp);
			return (error);
		}
	}

	/*
	 * If we're here, it means we've successfully added the new
	 * entries, so free the old ones.
	 */
	if (flow3)
		delete_flow(flow3, flow3->flow_sa);

	if (flow4)
		delete_flow(flow4, flow4->flow_sa);
	    
	return 0;
}

int
#ifdef __STDC__
encap_output(struct mbuf *m, ...)
#else
encap_output(m, va_alist)
register struct mbuf *m;
va_dcl
#endif
{
#define SENDERR(e) do { error = e; goto flush;} while (0)
    struct sockaddr_encap encapdst, encapgw, encapnetmask;
    struct flow *flow, *flow2;
    int len, emlen, error = 0;
    struct in_addr alts, altm;
    struct encap_msghdr *emp;
    struct tdb *tdbp, *tdbp2;
    struct expiration *exp;
    caddr_t buffer = 0;
    struct socket *so;
    u_int32_t spi;
    va_list ap;

    va_start(ap, m);
    so = va_arg(ap, struct socket *);
    va_end(ap);

    if ((m == 0) || ((m->m_len < sizeof(int32_t)) &&
		     (m = m_pullup(m, sizeof(int32_t))) == 0))
      return ENOBUFS;

    if ((m->m_flags & M_PKTHDR) == 0)
      SENDERR(EINVAL);

    len = m->m_pkthdr.len; 

    emp = mtod(m, struct encap_msghdr *);

    emlen = emp->em_msglen;
    if (len < emlen)
      SENDERR(EINVAL);

    if (m->m_len < emlen)
    {
	MALLOC(buffer, caddr_t, emlen, M_TEMP, M_WAITOK);	
	if (buffer == 0)
	  SENDERR(ENOBUFS);

	m_copydata(m, 0, emlen, buffer);

	emp = (struct encap_msghdr *) buffer;
    }
	
    if (emp->em_version != PFENCAP_VERSION_1)
      SENDERR(EINVAL);

    bzero((caddr_t) &encapdst, sizeof(struct sockaddr_encap));
    bzero((caddr_t) &encapnetmask, sizeof(struct sockaddr_encap));
    bzero((caddr_t) &encapgw, sizeof(struct sockaddr_encap));

    switch (emp->em_type)
    {
	case EMT_SETSPI:
	    if (emlen <= EMT_SETSPI_FLEN)
	      SENDERR(EINVAL);

	    /* 
	     * If only one of the two outter addresses is set, return
	     * error.
	     */
	    if ((emp->em_osrc.s_addr != 0) ^
		(emp->em_odst.s_addr != 0))
	      SENDERR(EINVAL);	    

	    tdbp = gettdb(emp->em_spi, emp->em_dst, emp->em_sproto);
	    if (tdbp == NULL)
	    {
		MALLOC(tdbp, struct tdb *, sizeof(*tdbp), M_TDB, M_WAITOK);
		if (tdbp == NULL)
		  SENDERR(ENOBUFS);
		
		bzero((caddr_t) tdbp, sizeof(*tdbp));
		
		tdbp->tdb_spi = emp->em_spi;
		tdbp->tdb_dst = emp->em_dst;
		tdbp->tdb_sproto = emp->em_sproto;
		puttdb(tdbp);
	    }
	    else
	    {
		if (tdbp->tdb_xform)
		  (*tdbp->tdb_xform->xf_zeroize)(tdbp);
		
		cleanup_expirations(tdbp->tdb_dst, tdbp->tdb_spi,
				    tdbp->tdb_sproto);
	    }
	    
	    tdbp->tdb_src = emp->em_src;
	    tdbp->tdb_satype = emp->em_satype;

	    /* Check if this is an encapsulating SPI */
	    if (emp->em_osrc.s_addr != 0)
	    {
		tdbp->tdb_flags |= TDBF_TUNNELING;
		tdbp->tdb_osrc = emp->em_osrc;
		tdbp->tdb_odst = emp->em_odst;
		
		/* TTL */
		switch (emp->em_ttl)
		{
		    case IP4_DEFAULT_TTL:
			tdbp->tdb_ttl = 0;
			break;
			
		    case IP4_SAME_TTL:
			tdbp->tdb_flags |= TDBF_SAME_TTL;
			break;

		    default:
			/* Get just the least significant bits */
			tdbp->tdb_ttl = emp->em_ttl % 256;
			break;
		}
	    }
	    
	    /* Clear the INVALID flag */
	    tdbp->tdb_flags &= (~TDBF_INVALID);

	    /* Various timers/counters */
	    if (emp->em_first_use_hard != 0)
	    {
		tdbp->tdb_exp_first_use = emp->em_first_use_hard;
		tdbp->tdb_flags |= TDBF_FIRSTUSE;
	    }
		
	    if (emp->em_first_use_soft != 0)
	    {
		tdbp->tdb_soft_first_use = emp->em_first_use_soft;
		tdbp->tdb_flags |= TDBF_SOFT_FIRSTUSE;
	    }

	    if (emp->em_expire_hard != 0)
	    {
		tdbp->tdb_exp_timeout = emp->em_expire_hard;
		tdbp->tdb_flags |= TDBF_TIMER;
		
		exp = get_expiration();
		if (exp == (struct expiration *) NULL)
		{
		    tdb_delete(tdbp, 0);
		    SENDERR(ENOBUFS);
		}

		exp->exp_dst.s_addr = tdbp->tdb_dst.s_addr;
		exp->exp_spi = tdbp->tdb_spi;
		exp->exp_sproto = tdbp->tdb_sproto;
		exp->exp_timeout = emp->em_expire_hard;
		put_expiration(exp);
	    }
		
	    if (emp->em_expire_soft != 0)
	    {
		tdbp->tdb_soft_timeout = emp->em_expire_soft;
		tdbp->tdb_flags |= TDBF_SOFT_TIMER;

		if (tdbp->tdb_soft_timeout <= tdbp->tdb_exp_timeout)
		{
		    exp = get_expiration();
		    if (exp == (struct expiration *) NULL)
		    {
			tdb_delete(tdbp, 0);
			SENDERR(ENOBUFS);
		    }

		    exp->exp_dst.s_addr = tdbp->tdb_dst.s_addr;
		    exp->exp_spi = tdbp->tdb_spi;
		    exp->exp_sproto = tdbp->tdb_sproto;
		    exp->exp_timeout = emp->em_expire_soft;
		    put_expiration(exp);
		}
	    }
		
	    if (emp->em_bytes_hard != 0)
	    {
		tdbp->tdb_exp_bytes = emp->em_bytes_hard;
		tdbp->tdb_flags |= TDBF_BYTES;
	    }

	    if (emp->em_bytes_soft != 0)
	    {
		tdbp->tdb_soft_bytes = emp->em_bytes_soft;
		tdbp->tdb_flags |= TDBF_SOFT_BYTES;
	    }
		
	    if (emp->em_packets_hard != 0)
	    {
		tdbp->tdb_exp_packets = emp->em_packets_hard;
		tdbp->tdb_flags |= TDBF_PACKETS;
	    }

	    if (emp->em_packets_soft != 0)
	    {
		tdbp->tdb_soft_packets = emp->em_packets_soft;
		tdbp->tdb_flags |= TDBF_SOFT_PACKETS;
	    }

	    error = tdb_init(tdbp, m);
	    if (error)
	    {
		tdb_delete(tdbp, 0);
	      	SENDERR(EINVAL);
	    }
	    
	    break;
		
	case EMT_DELSPI:
	    if (emlen != EMT_DELSPI_FLEN)
	      SENDERR(EINVAL);
	    
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst, 
			  emp->em_gen_sproto);
	    if (tdbp == NULL)
	      SENDERR(ENOENT);

	    error = tdb_delete(tdbp, 0);
	    if (error)
	      SENDERR(EINVAL);
	    
	    break;

	case EMT_DELSPICHAIN:
	    if (emlen != EMT_DELSPICHAIN_FLEN)
	      SENDERR(EINVAL);

	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst, 
			  emp->em_gen_sproto);
	    if (tdbp == NULL)
	      SENDERR(ENOENT);

	    error = tdb_delete(tdbp, 1);
	    if (error)
	      SENDERR(EINVAL);

	    break;

	case EMT_GRPSPIS:
	    if (emlen != EMT_GRPSPIS_FLEN)
	      SENDERR(EINVAL);
	    
	    tdbp = gettdb(emp->em_rel_spi, emp->em_rel_dst, 
			  emp->em_rel_sproto);
	    if (tdbp == NULL)
	      SENDERR(ENOENT);

	    tdbp2 = gettdb(emp->em_rel_spi2, emp->em_rel_dst2,
			   emp->em_rel_sproto2);
	    if (tdbp2 == NULL)
	      SENDERR(ENOENT);
	    
	    tdbp->tdb_onext = tdbp2;
	    tdbp2->tdb_inext = tdbp;
	    
	    error = 0;

	    break;

	case EMT_RESERVESPI:
	    if (emlen != EMT_RESERVESPI_FLEN)
	      SENDERR(EINVAL);
	    
	    spi = reserve_spi(emp->em_gen_spi, emp->em_gen_dst, 
			      emp->em_gen_sproto, &error);
	    if (spi == 0)
	      SENDERR(error);

	    emp->em_gen_spi = spi;
	    
	    /* If we're using a buffer, copy the data back to an mbuf. */
	    if (buffer)
	      m_copyback(m, 0, emlen, buffer);

	    /* Send it back to us */
	    if (sbappendaddr(&so->so_rcv, &encap_src, m,
			     (struct mbuf *) 0) == 0)
	      SENDERR(ENOBUFS);
	    else
	      sorwakeup(so);		/* wakeup  */

	    m = NULL;			/* So it's not free'd */
	    error = 0;
	    
	    break;
	    
	case EMT_ENABLESPI:
	    if (emlen != EMT_ENABLESPI_FLEN)
	      SENDERR(EINVAL);

	    error = encap_enable_spi(emp->em_ena_spi, emp->em_ena_dst,
				     emp->em_ena_isrc, emp->em_ena_ismask,
				     emp->em_ena_idst, emp->em_ena_idmask,
				     emp->em_ena_sport, emp->em_ena_dport,
				     emp->em_ena_protocol, emp->em_ena_sproto,
				     emp->em_ena_flags);

	    break;

	case EMT_DISABLESPI:
	    if (emlen != EMT_DISABLESPI_FLEN)
	      SENDERR(EINVAL);

            tdbp = gettdb(emp->em_ena_spi, emp->em_ena_dst, 
			  emp->em_ena_sproto);
            if (tdbp == NULL)
              SENDERR(ENOENT);

	    /* Retrieve source and destination masks from routing entry */
	    if (emp->em_ena_flags & ENABLE_FLAG_MODIFY) {
		    struct route_enc re0, *re = &re0;
		    struct sockaddr_encap *dest, *mask;
	      
		    bzero((caddr_t) re, sizeof(*re));
		    dest = (struct sockaddr_encap *) &re->re_dst;
		    dest->sen_family = AF_ENCAP;
		    dest->sen_len = SENT_IP4_LEN;
		    dest->sen_type = SENT_IP4;
		    dest->sen_ip_src = tdbp->tdb_src;
		    dest->sen_ip_dst = emp->em_ena_dst;
		    dest->sen_proto = emp->em_ena_protocol;
		    dest->sen_sport = emp->em_ena_sport;
		    dest->sen_dport = emp->em_ena_dport;
		    rtalloc((struct route *) re);
		    if (re->re_rt == NULL)
			    return (ENOENT);

		    mask = (struct sockaddr_encap *) (rt_mask(re->re_rt));
		    if (mask == NULL)
			    return (ENOENT);

		    emp->em_ena_ismask.s_addr = mask->sen_ip_src.s_addr;
		    emp->em_ena_idmask.s_addr = mask->sen_ip_dst.s_addr;

		    RTFREE(re->re_rt);
	    }

	    emp->em_ena_isrc.s_addr &= emp->em_ena_ismask.s_addr;
	    emp->em_ena_idst.s_addr &= emp->em_ena_idmask.s_addr;

	    flow = find_flow(emp->em_ena_isrc, emp->em_ena_ismask,
			     emp->em_ena_idst, emp->em_ena_idmask,
			     emp->em_ena_protocol, emp->em_ena_sport,
			     emp->em_ena_dport, tdbp);
	    if (flow == (struct flow *) NULL)
	      SENDERR(ENOENT);

	    if (emp->em_ena_flags & ENABLE_FLAG_LOCAL)
	    {
		alts.s_addr = INADDR_ANY;
		altm.s_addr = INADDR_BROADCAST;

		flow2 = find_flow(alts, altm, emp->em_ena_idst,
				  emp->em_ena_idmask, emp->em_ena_protocol,
				  emp->em_ena_sport, emp->em_ena_dport, tdbp);
		if (flow2 == (struct flow *) NULL)
		  SENDERR(ENOENT);

		if (flow == flow2)
		  SENDERR(EINVAL);
	    }

            /* Setup the encap fields */
            encapdst.sen_len = SENT_IP4_LEN;
            encapdst.sen_family = AF_ENCAP;
            encapdst.sen_type = SENT_IP4;
            encapdst.sen_ip_src.s_addr = flow->flow_src.s_addr;
            encapdst.sen_ip_dst.s_addr = flow->flow_dst.s_addr;
            encapdst.sen_proto = flow->flow_proto;
            encapdst.sen_sport = flow->flow_sport;
            encapdst.sen_dport = flow->flow_dport;

            encapnetmask.sen_len = SENT_IP4_LEN;
            encapnetmask.sen_family = AF_ENCAP;
            encapnetmask.sen_type = SENT_IP4;
            encapnetmask.sen_ip_src.s_addr = flow->flow_srcmask.s_addr;
            encapnetmask.sen_ip_dst.s_addr = flow->flow_dstmask.s_addr;

            if (flow->flow_proto)
            {
                encapnetmask.sen_proto = 0xff;

                if (flow->flow_sport)
                  encapnetmask.sen_sport = 0xffff;

                if (flow->flow_dport)
                  encapnetmask.sen_dport = 0xffff;
            }

            /* Delete the entry */
            rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
		      (struct sockaddr *) 0,
		      (struct sockaddr *) &encapnetmask, 0,
		      (struct rtentry **) 0);

	    if (emp->em_ena_flags & ENABLE_FLAG_MODIFY) {
		    encapgw.sen_len = SENT_IPSP_LEN;
		    encapgw.sen_family = AF_ENCAP;
		    encapgw.sen_type = SENT_IPSP;
		    encapgw.sen_ipsp_dst.s_addr = emp->em_ena_dst.s_addr;
		    encapgw.sen_ipsp_spi = htonl(1);
		    encapgw.sen_ipsp_sproto = IPPROTO_ESP;
		    error = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				      (struct sockaddr *) &encapgw,
				      (struct sockaddr *) &encapnetmask,
				      RTF_UP | RTF_GATEWAY | RTF_STATIC,
				      (struct rtentry **) 0);
	    }
	    
	    if (emp->em_ena_flags & ENABLE_FLAG_LOCAL)
	    {

		encapdst.sen_ip_src.s_addr = INADDR_ANY;
		encapnetmask.sen_ip_src.s_addr = INADDR_BROADCAST;

		rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
			  (struct sockaddr *) 0,
			  (struct sockaddr *) &encapnetmask, 0,
			  (struct rtentry **) 0);
		
		if (emp->em_ena_flags & ENABLE_FLAG_MODIFY) {
			encapgw.sen_len = SENT_IPSP_LEN;
			encapgw.sen_family = AF_ENCAP;
			encapgw.sen_type = SENT_IPSP;
			encapgw.sen_ipsp_dst.s_addr = emp->em_ena_dst.s_addr;
			encapgw.sen_ipsp_spi = htonl(1);
			encapgw.sen_ipsp_sproto = IPPROTO_ESP;
			error = rtrequest(RTM_ADD, 
					  (struct sockaddr *) &encapdst,
					  (struct sockaddr *) &encapgw,
					  (struct sockaddr *) &encapnetmask,
					  RTF_UP | RTF_GATEWAY | RTF_STATIC,
					  (struct rtentry **) 0);
		}
		delete_flow(flow2, tdbp);
	    }

	    delete_flow(flow, tdbp);

	    break;

	case EMT_REPLACESPI:
	    if (emlen <= EMT_REPLACESPI_FLEN)
	      SENDERR(EINVAL);
	    
	    /* XXX Not yet finished */

	    SENDERR(EINVAL);
	    
	    break;
	    
	case EMT_NOTIFY:
	    if (emlen < EMT_NOTIFY_FLEN)
	      SENDERR(EINVAL);

	    if (emp->em_not_type != NOTIFY_REQUEST_SA)
	      SENDERR(EINVAL);

	    error = encap_notify_sa(emp->em_not_spi, 
				    emp->em_not_dst, emp->em_not_src, 
				    emp->em_not_sport, emp->em_not_dport,
				    emp->em_not_protocol, emp->em_not_sproto);

	    break;
	    
	default:
	    SENDERR(EINVAL);
    }
    
flush:
    if (m)
      m_freem(m);

    if (buffer)
      free(buffer, M_TEMP);

    return error;
}

void
encap_sendnotify(int subtype, struct tdb *tdbp, void *data)
{
    struct encap_msghdr em;
    struct mbuf *m;
    
    bzero(&em, sizeof(struct encap_msghdr));

    em.em_msglen = EMT_NOTIFY_FLEN;
    em.em_version = PFENCAP_VERSION_1;
    em.em_type = EMT_NOTIFY;
    
    notify_msgids++;

    switch (subtype)
    {
	case NOTIFY_SOFT_EXPIRE:
	case NOTIFY_HARD_EXPIRE:
	    em.em_not_spi = tdbp->tdb_spi;
	    em.em_not_sproto = tdbp->tdb_sproto;
	    em.em_not_dst.s_addr = tdbp->tdb_dst.s_addr;
	    em.em_not_type = subtype;
	    em.em_not_satype = tdbp->tdb_satype;
	    break;
	    
	case NOTIFY_REQUEST_SA:
	    em.em_not_dst.s_addr = tdbp->tdb_dst.s_addr;
#ifdef INET
	    if (data != NULL) {
		    struct inpcb *inp = (struct inpcb *) data;
		    struct socket *so = inp->inp_socket;
		    em.em_not_dport = inp->inp_fport;
		    em.em_not_sport = inp->inp_lport;
		    if (so != 0) 
			    em.em_not_protocol = so->so_proto->pr_protocol;
	    }
#endif
	    em.em_not_type = subtype;
	    em.em_not_satype = tdbp->tdb_satype;
	    break;

	default:
#ifdef ENCDEBUG
	    if (encdebug)
	        log(LOG_WARNING, "encap_sendnotify(): unknown subtype %d\n", subtype);
#endif /* ENCDEBUG */
	    return;
    }

    m = m_gethdr(M_DONTWAIT, MT_DATA);
    if (m == NULL)
    {
	if (encdebug)
	  log(LOG_ERR, "encap_sendnotify(): m_gethdr() returned NULL\n");
	return;
    }
   
    m->m_len = min(MHLEN, em.em_msglen); 
    m_copyback(m, 0, em.em_msglen, (caddr_t) &em);
    raw_input(m, &encap_proto, &encap_src, &encap_dst);

    return;
}

struct ifaddr *
encap_findgwifa(struct sockaddr *gw)
{
    return enc_softc.if_addrlist.tqh_first;
}
@


1.26
log
@Remove unnecessary panic().
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.25 1999/01/07 06:05:02 deraadt Exp $	*/
@


1.25
log
@in_pcblookup() now takes ptr to both ip address arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.24 1998/08/19 13:29:18 provos Exp $	*/
d633 1
a633 1
      panic("encap_output()");
@


1.24
log
@use correct upper bound
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.23 1998/05/24 14:13:57 provos Exp $	*/
d207 2
a208 2
		inp = in_pcblookup(table, dst, dport, zeroin_addr, sport, 
				   INPLOOKUP_WILDCARD);
@


1.23
log
@add support for Virtual Private Networks (VPN).
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.22 1998/05/18 21:10:15 provos Exp $	*/
d1144 1
a1144 1
    m->m_len = min(MLEN, em.em_msglen); 
@


1.22
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.21 1998/04/08 10:58:03 provos Exp $	*/
d332 29
d916 29
d1002 14
d1028 14
@


1.21
log
@fix encap notifies.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.20 1998/02/22 01:23:29 niklas Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
d55 3
d67 6
a72 1
void encap_sendnotify(int, struct tdb *);
d82 4
d179 395
d584 1
a584 1
    struct flow *flow, *flow2, *flow3, *flow4;
d869 6
a874 261
            tdbp = gettdb(emp->em_ena_spi, emp->em_ena_dst, 
			  emp->em_ena_sproto);
            if (tdbp == NULL)
              SENDERR(ENOENT);

	    flow = flow2 = flow3 = flow4 = (struct flow *) NULL;

	    emp->em_ena_isrc.s_addr &= emp->em_ena_ismask.s_addr;
	    emp->em_ena_idst.s_addr &= emp->em_ena_idmask.s_addr;

	    flow3 = find_global_flow(emp->em_ena_isrc, emp->em_ena_ismask,
			     	     emp->em_ena_idst, emp->em_ena_idmask,
			     	     emp->em_ena_protocol, emp->em_ena_sport,
			     	     emp->em_ena_dport);
	    if (flow3 != (struct flow *) NULL)
	      if (!(emp->em_ena_flags & ENABLE_FLAG_REPLACE))
	     	SENDERR(EEXIST);

	    /* Check for 0.0.0.0/255.255.255.255 if the flow is local */
	    if (emp->em_ena_flags & ENABLE_FLAG_LOCAL)
	    {
		alts.s_addr = INADDR_ANY;
		altm.s_addr = INADDR_BROADCAST;
		flow4 = find_global_flow(alts, altm, emp->em_ena_idst,
				         emp->em_ena_idmask,
					 emp->em_ena_protocol,
				    	 emp->em_ena_sport, emp->em_ena_dport);
		if (flow4 != (struct flow *) NULL)
		{
		  if (!(emp->em_ena_flags & ENABLE_FLAG_REPLACE))
		    SENDERR(EEXIST);
		  else if (flow3 == flow4)
		    SENDERR(EINVAL);
		}
	    }

	    flow = get_flow();
	    if (flow == (struct flow *) NULL)
	      SENDERR(ENOBUFS);

	    flow->flow_src.s_addr = emp->em_ena_isrc.s_addr;
	    flow->flow_dst.s_addr = emp->em_ena_idst.s_addr;
	    flow->flow_srcmask.s_addr = emp->em_ena_ismask.s_addr;
	    flow->flow_dstmask.s_addr = emp->em_ena_idmask.s_addr;
	    flow->flow_proto = emp->em_ena_protocol;
	    flow->flow_sport = emp->em_ena_sport;
	    flow->flow_dport = emp->em_ena_dport;

	    if (emp->em_ena_flags & ENABLE_FLAG_LOCAL)
	    {
	    	flow2 = get_flow();
	    	if (flow2 == (struct flow *) NULL)
	    	{
		    FREE(flow, M_TDB);
		    SENDERR(ENOBUFS);
	    	}

		flow2->flow_src.s_addr = INADDR_ANY;
		flow2->flow_dst.s_addr = emp->em_ena_idst.s_addr;
	    	flow2->flow_srcmask.s_addr = INADDR_BROADCAST;
	    	flow2->flow_dstmask.s_addr = emp->em_ena_idmask.s_addr;
	    	flow2->flow_proto = emp->em_ena_protocol;
	    	flow2->flow_sport = emp->em_ena_sport;
	    	flow2->flow_dport = emp->em_ena_dport;

	    	put_flow(flow2, tdbp);
	    }

	    put_flow(flow, tdbp);

	    /* Setup the encap fields */
	    encapdst.sen_len = SENT_IP4_LEN;
	    encapdst.sen_family = AF_ENCAP;
	    encapdst.sen_type = SENT_IP4;
	    encapdst.sen_ip_src.s_addr = flow->flow_src.s_addr;
	    encapdst.sen_ip_dst.s_addr = flow->flow_dst.s_addr;
	    encapdst.sen_proto = flow->flow_proto;
	    encapdst.sen_sport = flow->flow_sport;
	    encapdst.sen_dport = flow->flow_dport;

	    encapgw.sen_len = SENT_IPSP_LEN;
	    encapgw.sen_family = AF_ENCAP;
	    encapgw.sen_type = SENT_IPSP;
	    encapgw.sen_ipsp_dst.s_addr = tdbp->tdb_dst.s_addr;
	    encapgw.sen_ipsp_spi = tdbp->tdb_spi;
	    encapgw.sen_ipsp_sproto = tdbp->tdb_sproto;

	    encapnetmask.sen_len = SENT_IP4_LEN;
	    encapnetmask.sen_family = AF_ENCAP;
	    encapnetmask.sen_type = SENT_IP4;
	    encapnetmask.sen_ip_src.s_addr = flow->flow_srcmask.s_addr;
	    encapnetmask.sen_ip_dst.s_addr = flow->flow_dstmask.s_addr;

	    if (flow->flow_proto)
	    {
	        encapnetmask.sen_proto = 0xff;

	    	if (flow->flow_sport)
	      	  encapnetmask.sen_sport = 0xffff;

	    	if (flow->flow_dport)
	      	  encapnetmask.sen_dport = 0xffff;
	    }

	    /* If this is set, delete any old route for this flow */
	    if (emp->em_ena_flags & ENABLE_FLAG_REPLACE)
	      rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
                        (struct sockaddr *) 0,
                        (struct sockaddr *) &encapnetmask, 0,
                        (struct rtentry **) 0);

	    /* Add the entry in the routing table */
	    error = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
			      (struct sockaddr *) &encapgw,
			      (struct sockaddr *) &encapnetmask,
			      RTF_UP | RTF_GATEWAY | RTF_STATIC,
			      (struct rtentry **) 0);
	    
	    if (error)
	    {
		encapdst.sen_len = SENT_IP4_LEN;
		encapdst.sen_family = AF_ENCAP;
		encapdst.sen_type = SENT_IP4;
		encapdst.sen_ip_src.s_addr = flow3->flow_src.s_addr;
		encapdst.sen_ip_dst.s_addr = flow3->flow_dst.s_addr;
		encapdst.sen_proto = flow3->flow_proto;
		encapdst.sen_sport = flow3->flow_sport;
		encapdst.sen_dport = flow3->flow_dport;

		encapgw.sen_len = SENT_IPSP_LEN;
		encapgw.sen_family = AF_ENCAP;
		encapgw.sen_type = SENT_IPSP;
		encapgw.sen_ipsp_dst.s_addr = flow3->flow_sa->tdb_dst.s_addr;
		encapgw.sen_ipsp_spi = flow3->flow_sa->tdb_spi;
		encapgw.sen_ipsp_sproto = flow3->flow_sa->tdb_sproto;

		encapnetmask.sen_len = SENT_IP4_LEN;
		encapnetmask.sen_family = AF_ENCAP;
		encapnetmask.sen_type = SENT_IP4;
		encapnetmask.sen_ip_src.s_addr = flow3->flow_srcmask.s_addr;
		encapnetmask.sen_ip_dst.s_addr = flow3->flow_dstmask.s_addr;

		if (flow3->flow_proto)
		{
		    encapnetmask.sen_proto = 0xff;
		    
		    if (flow3->flow_sport)
		      encapnetmask.sen_sport = 0xffff;

		    if (flow->flow_dport)
		      encapnetmask.sen_dport = 0xffff;
		}
		
		/* Try to add the old entry back in */
		rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
			  (struct sockaddr *) &encapgw,
			  (struct sockaddr *) &encapnetmask,
			  RTF_UP | RTF_GATEWAY | RTF_STATIC,
			  (struct rtentry **) 0);
	    
	 	delete_flow(flow, tdbp);
		if (flow2)
		  delete_flow(flow2, tdbp);
		SENDERR(error);
	    }

	    /* If this is a "local" packet flow */
	    if (emp->em_ena_flags & ENABLE_FLAG_LOCAL)
	    {
		encapdst.sen_ip_src.s_addr = INADDR_ANY;
		encapnetmask.sen_ip_src.s_addr = INADDR_BROADCAST;

		if (emp->em_ena_flags & ENABLE_FLAG_REPLACE)
		  rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
			    (struct sockaddr *) 0,
			    (struct sockaddr *) &encapnetmask, 0,
			    (struct rtentry **) 0);

		error = rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
				  (struct sockaddr *) &encapgw,
				  (struct sockaddr *) &encapnetmask,
				  RTF_UP | RTF_GATEWAY | RTF_STATIC,
				  (struct rtentry **) 0);

	    	if (error)
	    	{
		    /* Delete the first entry inserted */
		    encapdst.sen_ip_src.s_addr = emp->em_ena_isrc.s_addr;
		    encapnetmask.sen_ip_src.s_addr = emp->em_ena_ismask.s_addr;

		    rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
			      (struct sockaddr *) 0,
			      (struct sockaddr *) &encapnetmask, 0,
			      (struct rtentry **) 0);

		    /* Setup the old entries */
		    encapdst.sen_len = SENT_IP4_LEN;
		    encapdst.sen_family = AF_ENCAP;
		    encapdst.sen_type = SENT_IP4;
		    encapdst.sen_ip_src.s_addr = flow3->flow_src.s_addr;
		    encapdst.sen_ip_dst.s_addr = flow3->flow_dst.s_addr;
		    encapdst.sen_proto = flow3->flow_proto;
		    encapdst.sen_sport = flow3->flow_sport;
		    encapdst.sen_dport = flow3->flow_dport;

		    encapgw.sen_len = SENT_IPSP_LEN;
		    encapgw.sen_family = AF_ENCAP;
		    encapgw.sen_type = SENT_IPSP;
		    encapgw.sen_ipsp_dst.s_addr = flow3->flow_sa->tdb_dst.s_addr;
		    encapgw.sen_ipsp_spi = flow3->flow_sa->tdb_spi;
		    encapgw.sen_ipsp_sproto = flow3->flow_sa->tdb_sproto;
		   
		    encapnetmask.sen_len = SENT_IP4_LEN;
		    encapnetmask.sen_family = AF_ENCAP;
		    encapnetmask.sen_type = SENT_IP4;
		    encapnetmask.sen_ip_src.s_addr = flow3->flow_srcmask.s_addr;
		    encapnetmask.sen_ip_dst.s_addr = flow3->flow_dstmask.s_addr;

		    if (flow3->flow_proto)
		    {
			encapnetmask.sen_proto = 0xff;
			
			if (flow3->flow_sport)
			  encapnetmask.sen_sport = 0xffff;

			if (flow->flow_dport)
			  encapnetmask.sen_dport = 0xffff;
		    }
		
		    rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
			      (struct sockaddr *) &encapgw,
			      (struct sockaddr *) &encapnetmask,
			      RTF_UP | RTF_GATEWAY | RTF_STATIC,
			      (struct rtentry **) 0);

		    encapdst.sen_ip_src.s_addr = INADDR_ANY;
		    encapnetmask.sen_ip_src.s_addr = INADDR_BROADCAST;

		    rtrequest(RTM_ADD, (struct sockaddr *) &encapdst,
			      (struct sockaddr *) &encapgw,
			      (struct sockaddr *) &encapnetmask,
			      RTF_UP | RTF_GATEWAY | RTF_STATIC,
			      (struct rtentry **) 0);

		    delete_flow(flow, tdbp);
		    delete_flow(flow2, tdbp);
		    SENDERR(error);
	    	}
	    }

	    /*
	     * If we're here, it means we've successfully added the new
	     * entries, so free the old ones.
	     */
	    if (flow3)
	      delete_flow(flow3, flow3->flow_sa);

	    if (flow4)
	      delete_flow(flow4, flow4->flow_sa);

	    error = 0;
d974 1
a974 1
	    if (emlen <= EMT_NOTIFY_FLEN)
a978 7
	    
	    tdbp = gettdb(emp->em_not_spi, emp->em_not_dst, 
			   emp->em_not_sproto);
	    if (tdbp == NULL)
	      SENDERR(ENOENT);
	    
	    /* XXX Not yet finished */
d980 4
a983 1
	    SENDERR(EINVAL);
d1002 1
a1002 1
encap_sendnotify(int subtype, struct tdb *tdbp)
d1027 15
a1041 3
	    /* XXX */
	    return;
	    
d1045 1
a1045 1
	      log(LOG_WARNING, "encap_sendnotify(): unknown subtype %d\n", subtype);
@


1.20
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.19 1997/11/15 00:07:06 deraadt Exp $	*/
d891 2
a892 1
    
@


1.19
log
@fix memory management errors
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.18 1997/11/04 09:10:53 provos Exp $	*/
d484 1
d487 3
a489 3
		  else
		    if (flow3 == flow4)
		      SENDERR(EINVAL);
@


1.18
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.17 1997/10/02 02:31:01 deraadt Exp $	*/
d367 4
a370 1
	      SENDERR(EINVAL);
@


1.17
log
@conditional error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.16 1997/09/28 22:57:52 deraadt Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
@


1.16
log
@log() needs a \n
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.15 1997/07/28 18:53:21 provos Exp $	*/
d879 2
a880 1
	log(LOG_ERR, "encap_sendnotify(): m_gethdr() returned NULL\n");
@


1.15
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.14 1997/07/27 23:30:31 niklas Exp $	*/
d871 1
a871 1
	      log(LOG_WARNING, "encap_sendnotify(): unknown subtype %d", subtype);
d879 1
a879 1
	log(LOG_ERR, "encap_sendnotify(): m_gethdr() returned NULL");
@


1.14
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.13 1997/07/23 12:07:04 provos Exp $	*/
d871 1
a871 1
	      log(LOG_WARN, "encap_sendnotify(): unknown subtype %d", subtype);
@


1.13
log
@enablespi, delete the right flows on replace.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.12 1997/07/21 21:10:37 deraadt Exp $	*/
d54 1
d172 1
a174 1
    struct mbuf *m0;
d244 7
a250 2
	      if (tdbp->tdb_xform)
	        (*tdbp->tdb_xform->xf_zeroize)(tdbp);
d253 1
a283 12
	    if (emp->em_relative_hard != 0)
	    {
		tdbp->tdb_exp_relative = emp->em_relative_hard;
		tdbp->tdb_flags |= TDBF_RELATIVE;
	    }

	    if (emp->em_relative_soft != 0)
	    {
		tdbp->tdb_soft_relative = emp->em_relative_soft;
		tdbp->tdb_flags |= TDBF_SOFT_RELATIVE;
	    }
		
d300 13
d319 16
d371 2
a372 1
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst, emp->em_gen_sproto);
d375 1
a375 1
	    
d386 2
a387 1
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst, emp->em_gen_sproto);
d390 1
a390 1
	    
d401 2
a402 1
	    tdbp = gettdb(emp->em_rel_spi, emp->em_rel_dst, emp->em_rel_sproto);
a432 4
	    m0 = m_copy(m, 0, (int) M_COPYALL);
	    if (m0 == NULL)
	      SENDERR(ENOBUFS);

d434 1
a434 1
	    if (sbappendaddr(&so->so_rcv, &encap_src, m0,
d436 1
a436 4
	    {
		m_freem(m0);
	      	SENDERR(ENOBUFS);
	    }
d440 1
a444 30
	case EMT_VALIDATE:
	    if (emlen != EMT_VALIDATE_FLEN)
	      SENDERR(EINVAL);
	    
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst, emp->em_gen_sproto);
	    if (tdbp == NULL)
	      SENDERR(ENOENT);

	    /* Clear the INVALID flag */
	    tdbp->tdb_flags &= (~TDBF_INVALID);

	    error = 0;

	    break;
	    
	case EMT_INVALIDATE:
	    if (emlen != EMT_INVALIDATE_FLEN)
	      SENDERR(EINVAL);
	    
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst, emp->em_gen_sproto);
	    if (tdbp == NULL)
	      SENDERR(ENOENT);
	    
	    /* Set the INVALID flag */
	    tdbp->tdb_flags |= TDBF_INVALID;

	    error = 0;
	    
	    break;

d449 2
a450 1
            tdbp = gettdb(emp->em_ena_spi, emp->em_ena_dst, emp->em_ena_sproto);
d479 3
d568 40
d634 1
d643 49
d698 4
d716 2
a717 1
            tdbp = gettdb(emp->em_ena_spi, emp->em_ena_dst, emp->em_ena_sproto);
d741 3
d774 5
a778 10
            error = rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
			      (struct sockaddr *) 0,
			      (struct sockaddr *) &encapnetmask, 0,
			      (struct rtentry **) 0);

	    delete_flow(flow, tdbp);

	    if (error)
	      SENDERR(error);

d785 5
a789 5
		error = rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
				  (struct sockaddr *) 0,
				  (struct sockaddr *) &encapnetmask, 0,
				  (struct rtentry **) 0);

d791 1
d793 1
a793 3
		if (error)
		  SENDERR(error);
	    }
d797 10
d810 8
a828 5
    if (buffer)
      free(buffer, M_TEMP);

    return error;
    
d837 50
@


1.12
log
@be quiet
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.11 1997/07/18 18:09:48 provos Exp $	*/
d166 2
a167 1
    int fl, fl2, len, emlen, error = 0;
a168 1
    struct flow *flow, *flow2;
d173 1
d193 1
a193 1
    if ((len < emlen))
d402 1
a402 1
	    /* If we're using a buffer, copy the data back to the mbuf */
d406 4
d411 6
a416 3
	    if (sbappendaddr(&so->so_rcv, &encap_src, m, 
			     (struct mbuf *)0) == 0)
	      SENDERR(ENOBUFS);
d462 1
a462 1
	    fl = fl2 = 0;
d467 7
a473 7
	    flow = find_flow(emp->em_ena_isrc, emp->em_ena_ismask,
			     emp->em_ena_idst, emp->em_ena_idmask,
			     emp->em_ena_protocol, emp->em_ena_sport,
			     emp->em_ena_dport, tdbp);
	    if ((flow != (struct flow *) NULL) &&
		!(emp->em_ena_flags & ENABLE_FLAG_REPLACE))
	      SENDERR(EEXIST);
d480 7
a486 6
		flow2 = find_flow(alts, altm, emp->em_ena_idst,
				  emp->em_ena_idmask, emp->em_ena_protocol,
				  emp->em_ena_sport, emp->em_ena_dport, tdbp);
		if ((flow2 != (struct flow *) NULL) &&
		    !(emp->em_ena_flags & ENABLE_FLAG_REPLACE))
		  SENDERR(EEXIST);
d489 1
d491 1
a491 12
	    {
	    	flow = get_flow();
	    	if (flow == (struct flow *) NULL)
	      	  SENDERR(ENOBUFS);

	    	flow->flow_src.s_addr = emp->em_ena_isrc.s_addr;
	    	flow->flow_dst.s_addr = emp->em_ena_idst.s_addr;
	    	flow->flow_srcmask.s_addr = emp->em_ena_ismask.s_addr;
	    	flow->flow_dstmask.s_addr = emp->em_ena_idmask.s_addr;
	    	flow->flow_proto = emp->em_ena_protocol;
	    	flow->flow_sport = emp->em_ena_sport;
	    	flow->flow_dport = emp->em_ena_dport;
d493 7
a499 2
		fl = 1;
	    }
d501 1
a501 2
	    if ((emp->em_ena_flags & ENABLE_FLAG_LOCAL) &&
		(flow2 == (struct flow *) NULL))
a517 2
		fl2 = 1;

d521 1
a521 2
	    if (fl == 1)
	      put_flow(flow, tdbp);
d573 2
a574 3
		if (fl)
		  delete_flow(flow, tdbp);
		if ((emp->em_ena_flags & ENABLE_FLAG_LOCAL) && (fl2))
d607 2
a608 5
		    if (fl)
		      delete_flow(flow, tdbp);

		    if (fl2)
		      delete_flow(flow2, tdbp);
d612 6
@


1.11
log
@enablespi/disablespi in encap + print spi's in hostorder
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.10 1997/07/15 23:11:08 provos Exp $	*/
d110 1
a110 1
	log(LOG_INFO, "encap_init(): attaching <%s>\n", xsp->xf_name);
@


1.10
log
@flags for tunnels and replacing existing routes, sysctl! + tiny bug fix
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.9 1997/07/14 08:46:39 provos Exp $	*/
d63 3
a65 3
struct	sockaddr encap_dst = { 2, PF_ENCAP, };
struct	sockaddr encap_src = { 2, PF_ENCAP, };
struct	sockproto encap_proto = { PF_ENCAP, };
a80 1

d166 1
a167 1
    int len, emlen, error = 0;
d209 4
d454 5
d463 2
a464 1
	    if (flow != (struct flow *) NULL)
d475 2
a476 1
		if (flow2 != (struct flow *) NULL)
a479 1
	    flow = get_flow();
d481 15
a495 1
	      SENDERR(ENOBUFS);
d497 2
a498 1
	    if (emp->em_ena_flags & ENABLE_FLAG_LOCAL)
d515 2
d520 2
a521 9
	    flow->flow_src.s_addr = emp->em_ena_isrc.s_addr;
	    flow->flow_dst.s_addr = emp->em_ena_idst.s_addr;
	    flow->flow_srcmask.s_addr = emp->em_ena_ismask.s_addr;
	    flow->flow_dstmask.s_addr = emp->em_ena_idmask.s_addr;
	    flow->flow_proto = emp->em_ena_protocol;
	    flow->flow_sport = emp->em_ena_sport;
	    flow->flow_dport = emp->em_ena_dport;

	    put_flow(flow, tdbp);
d538 1
d560 3
a562 4
			(struct sockaddr *) &encapgw,
			(struct sockaddr *) &encapnetmask,
			RTF_UP | RTF_GATEWAY | RTF_STATIC,
			(struct rtentry **) 0);
d573 3
a575 2
		delete_flow(flow, tdbp);
		if (emp->em_ena_flags & ENABLE_FLAG_LOCAL)
d588 2
a589 3
			    (struct sockaddr *) &encapgw,
			    (struct sockaddr *) &encapnetmask,
			    RTF_UP | RTF_GATEWAY | RTF_STATIC,
d604 2
a605 3
			      (struct sockaddr *) &encapgw,
			      (struct sockaddr *) &encapnetmask,
			      RTF_UP | RTF_GATEWAY | RTF_STATIC,
d608 5
a612 2
		    delete_flow(flow, tdbp);
		    delete_flow(flow2, tdbp);
d625 1
a625 1
            tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst, emp->em_gen_sproto);
d629 3
a660 6
            encapgw.sen_len = SENT_IPSP_LEN;
            encapgw.sen_family = AF_ENCAP;
            encapgw.sen_type = SENT_IPSP;
            encapgw.sen_ipsp_dst.s_addr = tdbp->tdb_dst.s_addr;
            encapgw.sen_ipsp_spi = tdbp->tdb_spi;

d680 3
a682 4
			      (struct sockaddr *) &encapgw,
			      (struct sockaddr *) &encapnetmask,
                              RTF_UP | RTF_GATEWAY | RTF_STATIC,
                              (struct rtentry **) 0);
d696 2
a697 3
				  (struct sockaddr *) &encapgw,
				  (struct sockaddr *) &encapnetmask,
				  RTF_UP | RTF_GATEWAY | RTF_STATIC,
@


1.9
log
@sysctl...
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.8 1997/07/11 23:37:51 provos Exp $	*/
d167 1
d169 1
a173 1
    struct flow *flow;
d458 12
d474 20
d537 8
d555 2
d560 36
d615 12
d660 1
a660 1
            /* Add the entry in the routing table */
d668 21
@


1.8
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.7 1997/07/02 06:58:40 provos Exp $	*/
d95 1
a95 1
        case IPSECCTL_ENCDEBUG:
@


1.7
log
@fix neglected _FLEN's + reserve_spi + output reserved spi's without alg.
correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.6 1997/07/01 22:12:40 provos Exp $	*/
d35 2
d51 1
a51 3
extern struct ifnet loif;

extern int ipspkernfs_dirty;
d57 1
d72 1
d78 1
a78 1
  encapsw, &encapsw[sizeof(encapsw)/sizeof(encapsw[0])], 0,
d82 22
d111 1
a111 1
	printf("encap_init: attaching <%s>\n", xsp->xf_name);
d128 4
a131 1
	if ((so->so_pcb = (caddr_t)rp))
d144 1
a144 1
	    free((caddr_t)rp, M_PCB);
d166 1
d172 1
d175 1
a175 1
    
d185 1
a185 1
      panic("encap_output");
d223 1
a223 1
	    tdbp = gettdb(emp->em_spi, emp->em_dst);
d226 1
a226 1
		MALLOC(tdbp, struct tdb *, sizeof (*tdbp), M_TDB, M_WAITOK);
d230 1
a230 1
		bzero((caddr_t)tdbp, sizeof(*tdbp));
d234 1
a234 1

a240 4
	    tdbp->tdb_proto = emp->em_proto;
	    tdbp->tdb_sport = emp->em_sport;
	    tdbp->tdb_dport = emp->em_dport;

a335 2
	    ipspkernfs_dirty = 1;

d342 1
a342 1
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst);
d356 1
a356 1
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst);
d370 1
a370 1
	    tdbp = gettdb(emp->em_rel_spi, emp->em_rel_dst);
d374 2
a375 1
	    tdbp2 = gettdb(emp->em_rel_spi2, emp->em_rel_dst2);
a381 1
	    ipspkernfs_dirty = 1;
d383 1
d390 2
a391 1
	    spi = reserve_spi(emp->em_gen_spi, emp->em_gen_dst, &error);
d412 2
a413 2
	case EMT_ENABLESPI:
	    if (emlen != EMT_ENABLESPI_FLEN)
d416 1
a416 1
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst);
a422 2
	    /* XXX Install a routing entry */

d427 2
a428 2
	case EMT_DISABLESPI:
	    if (emlen != EMT_DISABLESPI_FLEN)
d431 1
a431 1
	    tdbp = gettdb(emp->em_gen_spi, emp->em_gen_dst);
d438 78
a515 1
	    /* XXX Delete a routing entry, if on exists */
d518 60
a577 1
	    
@


1.6
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.5 1997/06/25 07:53:19 provos Exp $	*/
d185 9
a193 1
	    
a196 8
		/* 
		 * If only one of the two outter addresses is set, return
		 * error.
		 */
		if ((emp->em_osrc.s_addr != 0) ^
		    (emp->em_odst.s_addr != 0))
		  SENDERR(EINVAL);
		
d206 9
a214 3
		tdbp->tdb_proto = emp->em_proto;
		tdbp->tdb_sport = emp->em_sport;
		tdbp->tdb_dport = emp->em_dport;
d216 1
a216 1
	        tdbp->tdb_src = emp->em_src;
d218 9
a226 2
		/* Check if this is an encapsulating SPI */
		if (emp->em_osrc.s_addr != 0)
d228 12
a239 20
		    tdbp->tdb_flags |= TDBF_TUNNELING;
		    tdbp->tdb_osrc = emp->em_osrc;
		    tdbp->tdb_odst = emp->em_odst;

		    /* TTL */
		    switch (emp->em_ttl)
		    {
			case IP4_DEFAULT_TTL:
			    tdbp->tdb_ttl = 0;
			    break;
			    
			case IP4_SAME_TTL:
			    tdbp->tdb_flags |= TDBF_SAME_TTL;
			    break;

			default:
			    /* Get just the least significant bits */
			    tdbp->tdb_ttl = emp->em_ttl % 256;
			    break;
		    }
a240 2
		
		puttdb(tdbp);
d242 3
a244 2
	    else
	      (*tdbp->tdb_xform->xf_zeroize)(tdbp);
d366 1
a366 1
	    spi = reserve_spi(emp->em_gen_spi, emp->em_gen_dst);
d368 1
a368 4
	      if (emp->em_gen_spi == 0)
		SENDERR(ENOBUFS);
	      else
		SENDERR(EINVAL);
d398 2
d414 2
@


1.5
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.4 1997/06/17 23:25:53 deraadt Exp $	*/
d47 1
d55 2
a56 1
int encap_usrreq(struct socket *, int, struct mbuf *, struct mbuf *, struct mbuf *);
d94 2
a95 1
encap_usrreq(register struct socket *so, int req, struct mbuf *m, struct mbuf *nam, struct mbuf *control)
d97 1
a98 1
    register struct rawcb *rp = sotorawcb(so);
d139 4
d144 1
a144 7
    int len, emlen, error = 0, nspis, i;
    struct encap_msghdr *emp;
    struct ifnet *ifp;
    struct ifaddr *ifa;
    struct sockaddr_encap *sen, *sen2;
    struct sockaddr_in *sin;
    struct tdb *tdbp, *tprev;
a145 1
    u_int32_t spi;
d159 1
d161 1
d168 2
a169 2
	m = m_pullup(m, emlen);
	if (m == NULL)
d171 4
a174 2
		
	emp = mtod(m, struct encap_msghdr *);
d177 3
d182 3
a184 7
	case EMT_IFADDR:
	    if (emp->em_ifn >= nencap)
	      SENDERR(ENODEV);
	    
            /*
	     * Set the default source address for an encap interface
	     */
a185 42
	    ifp = &(enc_softc[emp->em_ifn].enc_if);
		
	    if ((ifp->if_addrlist.tqh_first == NULL) ||
		(ifp->if_addrlist.tqh_first->ifa_addr == NULL) ||
		(ifp->if_addrlist.tqh_first->ifa_addr->sa_family != AF_ENCAP))
	    {
		MALLOC(ifa, struct ifaddr *, sizeof (struct ifaddr) + 
		       2 * SENT_DEFIF_LEN, M_IFADDR, M_WAITOK);
		if (ifa == NULL)
		  SENDERR(ENOBUFS);

		bzero((caddr_t)ifa, sizeof (struct ifaddr) + 
		      2 * SENT_DEFIF_LEN);
		sen = (struct sockaddr_encap *)(ifa + 1);
		sen2 = (struct sockaddr_encap *)((caddr_t)sen + 
						 SENT_DEFIF_LEN);
		ifa->ifa_addr = (struct sockaddr *)sen;
		ifa->ifa_dstaddr = (struct sockaddr *)sen2;
		ifa->ifa_ifp = ifp;
		TAILQ_INSERT_HEAD(&(ifp->if_addrlist), ifa, ifa_list);
	    }
	    else
	    {
		sen = (struct sockaddr_encap *)((&(ifp->if_addrlist))->tqh_first->ifa_addr);
		sen2 = (struct sockaddr_encap *)((&(ifp->if_addrlist))->tqh_first->ifa_dstaddr);
	    }

	    sen->sen_family = AF_ENCAP;
	    sen->sen_len = SENT_DEFIF_LEN;
	    sen->sen_type = SENT_DEFIF;
	    sin = (struct sockaddr_in *) &(sen->sen_dfl);
	    sin->sin_len = sizeof(*sin);
	    sin->sin_family = AF_INET;
	    sin->sin_addr = emp->em_ifa;

	    *sen2 = *sen;

	    break;
		
	case EMT_SETSPI:
	    if (emp->em_if >= nencap)
	      SENDERR(ENODEV);
d189 8
a204 1
		tdbp->tdb_rcvif = &(enc_softc[emp->em_if].enc_if);
d206 31
d304 3
d308 1
d312 4
a315 3
	    if (emp->em_if >= nencap)
	      SENDERR(ENODEV);
	    tdbp = gettdb(emp->em_spi, emp->em_dst);
d317 2
a318 11
	    {
		error = EINVAL;
		break;
	    }

	    if (emp->em_alg != tdbp->tdb_xform->xf_type)
	    {
		error = EINVAL;
		break;
	    }

d320 3
d326 4
a329 3
	    if (emp->em_if >= nencap)
	      SENDERR(ENODEV);
	    tdbp = gettdb(emp->em_spi, emp->em_dst);
d331 5
a335 10
	    {
		error = EINVAL;
		break;
	    }

	    if (emp->em_alg != tdbp->tdb_xform->xf_type)
	    {
		error = EINVAL;
		break;
	    }
a336 1
	    error = tdb_delete(tdbp, 1);
d340 1
a340 2
	    nspis = (emlen - 4) / 12;
	    if (nspis * 12 + 4 != emlen)
d343 3
a345 5
	    for (i = 0; i < nspis; i++)
	      if ((tdbp = gettdb(emp->em_rel[i].emr_spi, emp->em_rel[i].emr_dst)) == NULL)
		SENDERR(ENOENT);
	      else
		emp->em_rel[i].emr_tdb = tdbp;
d347 7
a353 10
	    tprev = emp->em_rel[0].emr_tdb;
	    tprev->tdb_inext = NULL;
	    for (i = 1; i < nspis; i++)
	    {
		tdbp = emp->em_rel[i].emr_tdb;
		tprev->tdb_onext = tdbp;
		tdbp->tdb_inext = tprev;
		tprev = tdbp;
	    }
	    tprev->tdb_onext = NULL;
d359 4
a362 1
	    spi = reserve_spi(emp->em_spi, emp->em_dst);
d364 1
a364 1
	      if (emp->em_spi == 0)
d369 1
a369 1
	    emp->em_spi = spi;
d371 4
d387 4
a390 1
	    tdbp = gettdb(emp->em_spi, emp->em_dst);
d396 1
d402 4
a405 1
	    tdbp = gettdb(emp->em_spi, emp->em_dst);
d411 1
d415 10
d430 3
d438 4
d448 1
a448 74
    struct sockaddr_encap *egw = (struct sockaddr_encap *)gw;
    u_char *op = (u_char *)gw;
    int i, j;
    struct ifaddr *retval = loif.if_addrlist.tqh_first;
    union
    {
	struct in_addr ia;
	u_char io[4];
    } iao;
	
    switch (egw->sen_type)
    {
	case SENT_IPSP:
	    return enc_softc[egw->sen_ipsp_ifn].enc_if.if_addrlist.tqh_first;
	    break;
	    
	case SENT_IP4:
	    /*
	     * Pretty-much standard options walking code.
	     * Repeated elsewhere as necessary
	     */
	    
	    for (i = SENT_IP4_LEN; i < egw->sen_len;)
	      switch (op[i])
	      {
		  case SENO_EOL:
		      goto opt_done;
		      
		  case SENO_NOP:
		      i++;
		      continue;
		      
		  case SENO_IFN:
		      if (op[i+1] != 3)
		      {
			  return NULL;
		      }
		      retval = enc_softc[op[i+2]].enc_if.if_addrlist.tqh_first;
		      goto opt_done;
		      
		  case SENO_IFIP4A:
		      if (op[i+1] != 6) /* XXX -- IPv4 address */
		      {
			  return NULL;
		      }
		      iao.io[0] = op[i+2];
		      iao.io[1] = op[i+3];
		      iao.io[2] = op[i+4];
		      iao.io[3] = op[i+5];
		      
		      for (j = 0; j < nencap; j++)
		      {
			  struct ifaddr *ia = (struct ifaddr *)enc_softc[j].enc_if.if_addrlist.tqh_first;
			  
			  struct sockaddr_in *si = (struct sockaddr_in *)ia->ifa_addr;
			  
			  if ((si->sin_family == AF_INET) && (si->sin_addr.s_addr == iao.ia.s_addr))
			  {
			      retval = ia;
			      goto opt_done;
			  }
		      }
		      i += 6;
		      break;
		      
		  default:
		      if (op[i+1] == 0)
			return NULL;
		      i += op[i+i];
	      }
    opt_done:
	    break;
    }
    return retval;
@


1.4
log
@check em_if and em_ifn better; thanks adam@@math.tau.ac.il
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.3 1997/04/25 01:19:20 angelos Exp $	*/
d65 5
a69 5
{ SOCK_RAW,	&encapdomain,	0,		PR_ATOMIC|PR_ADDR,
  raw_input,	encap_output,	raw_ctlinput,	0,
  encap_usrreq,
  encap_init,	0,		0,		0,
},
d73 3
a75 3
    { AF_ENCAP, "encapsulation", 0, 0, 0, 
      encapsw, &encapsw[sizeof(encapsw)/sizeof(encapsw[0])], 0,
      rn_inithead, 16, sizeof(struct sockaddr_encap)};
d81 7
a87 7
	struct xformsw *xsp;

	for (xsp = xformsw; xsp < xformswNXFORMSW; xsp++)
	{
		printf("encap_init: attaching <%s>\n", xsp->xf_name);
		(*(xsp->xf_attach))();
	}
d94 19
a112 5
	register int error = 0;
	register struct rawcb *rp = sotorawcb(so);
	int s;

	if (req == PRU_ATTACH)
d114 3
a116 4
		MALLOC(rp, struct rawcb *, sizeof(*rp), M_PCB, M_WAITOK);
		if ((so->so_pcb = (caddr_t)rp))
		  bzero(so->so_pcb, sizeof(*rp));

d118 6
a123 19
	s = splnet();
	error = raw_usrreq(so, req, m, nam, control);
	rp = sotorawcb(so);
	if ((req == PRU_ATTACH) && rp)
	{
	    /* int af = rp->rcb_proto.sp_protocol; */
		
		if (error)
		{
			free((caddr_t)rp, M_PCB);
			splx(s);
			return error;
		}
		rp->rcb_faddr = &encap_src;
		soisconnected(so);
		so->so_options |= SO_USELOOPBACK;
	}
	splx(s);
	return error;
d131 2
a132 2
	register struct mbuf *m;
	va_dcl
d136 57
a192 17
	struct socket *so;
	int len, emlen, error = 0, nspis, i;
	struct encap_msghdr *emp;
	struct ifnet *ifp;
	struct ifaddr *ifa;
	struct sockaddr_encap *sen, *sen2;
	struct sockaddr_in *sin;
	struct tdb *tdbp, *tprev;
	va_list ap;

	va_start(ap, m);
	so = va_arg(ap, struct socket *);
	va_end(ap);

	if ((m == 0) || ((m->m_len < sizeof(int32_t)) &&
			 (m = m_pullup(m, sizeof(int32_t))) == 0))
	  return ENOBUFS;
d194 23
a216 2
	if ((m->m_flags & M_PKTHDR) == 0)
	  panic("encap_output");
d218 1
a218 5
	len = m->m_pkthdr.len; 
	emp = mtod(m, struct encap_msghdr *);
	emlen = emp->em_msglen;
	if ((len < emlen))
	  SENDERR(EINVAL);
d220 10
a229 4
	if (m->m_len < emlen)
	{
		m = m_pullup(m, emlen);
		if (m == NULL)
d232 85
a316 42
		emp = mtod(m, struct encap_msghdr *);
	}
	
	switch (emp->em_type)
	{
	      case EMT_IFADDR:
		if (emp->em_ifn >= nencap)
			SENDERR(ENODEV);
		/*
		 * Set the default source address for an encap interface
		 */

		ifp = &(enc_softc[emp->em_ifn].enc_if);
		
		if ((ifp->if_addrlist.tqh_first == NULL) ||
		    (ifp->if_addrlist.tqh_first->ifa_addr == NULL) ||
		    (ifp->if_addrlist.tqh_first->ifa_addr->sa_family != AF_ENCAP))
		{
			MALLOC(ifa, struct ifaddr *, sizeof (struct ifaddr) + 2*SENT_DEFIF_LEN, M_IFADDR, M_WAITOK);
			if (ifa == NULL)
			  SENDERR(ENOBUFS);
			bzero((caddr_t)ifa, sizeof (struct ifaddr) + 2*SENT_DEFIF_LEN);
			sen = (struct sockaddr_encap *)(ifa + 1);
			sen2 = (struct sockaddr_encap *)((caddr_t)sen + SENT_DEFIF_LEN);
			ifa->ifa_addr = (struct sockaddr *)sen;
			ifa->ifa_dstaddr = (struct sockaddr *)sen2;
			ifa->ifa_ifp = ifp;
			TAILQ_INSERT_HEAD(&(ifp->if_addrlist), ifa, ifa_list);
		}
		else
		{
			sen = (struct sockaddr_encap *)((&(ifp->if_addrlist))->tqh_first->ifa_addr);
			sen2 = (struct sockaddr_encap *)((&(ifp->if_addrlist))->tqh_first->ifa_dstaddr);
		}

		sen->sen_family = AF_ENCAP;
		sen->sen_len = SENT_DEFIF_LEN;
		sen->sen_type = SENT_DEFIF;
		sin = (struct sockaddr_in *) &(sen->sen_dfl);
		sin->sin_len = sizeof(*sin);
		sin->sin_family = AF_INET;
		sin->sin_addr = emp->em_ifa;
d318 5
a322 1
		*sen2 = *sen;
d324 2
a325 21
		break;
		
	      case EMT_SETSPI:
		if (emp->em_if >= nencap)
			SENDERR(ENODEV);
		tdbp = gettdb(emp->em_spi, emp->em_dst);
		if (tdbp == NULL)
		{
			MALLOC(tdbp, struct tdb *, sizeof (*tdbp), M_TDB, M_WAITOK);
			if (tdbp == NULL)
			  SENDERR(ENOBUFS);
			
			bzero((caddr_t)tdbp, sizeof(*tdbp));
			
			tdbp->tdb_spi = emp->em_spi;
			tdbp->tdb_dst = emp->em_dst;
			tdbp->tdb_rcvif = &(enc_softc[emp->em_if].enc_if);
			puttdb(tdbp);
		}
		else
		  (*tdbp->tdb_xform->xf_zeroize)(tdbp);
d327 7
a333 2
		error = tdb_init(tdbp, m);
		ipspkernfs_dirty = 1;
d335 1
a335 16
		
	      case EMT_DELSPI:
		if (emp->em_if >= nencap)
			SENDERR(ENODEV);
		tdbp = gettdb(emp->em_spi, emp->em_dst);
		if (tdbp == NULL)
		{
			error = EINVAL;
			break;
		}

		if (emp->em_alg != tdbp->tdb_xform->xf_type)
		{
			error = EINVAL;
			break;
		}
d337 3
a339 1
		error = tdb_delete(tdbp, 0);
d341 1
d343 2
a344 42
	      case EMT_DELSPICHAIN:
		if (emp->em_if >= nencap)
			SENDERR(ENODEV);
                tdbp = gettdb(emp->em_spi, emp->em_dst);
                if (tdbp == NULL)
                {
                        error = EINVAL;
                        break;
                }

		if (emp->em_alg != tdbp->tdb_xform->xf_type)
		{
			error = EINVAL;
			break;
		}

                error = tdb_delete(tdbp, 1);
                break;

	      case EMT_GRPSPIS:
		nspis = (emlen - 4) / 12;
		if (nspis * 12 + 4 != emlen)
			SENDERR(EINVAL);
		
		for (i = 0; i < nspis; i++)
		  if ((tdbp = gettdb(emp->em_rel[i].emr_spi, emp->em_rel[i].emr_dst)) == NULL)
		    SENDERR(ENOENT);
		  else
		    emp->em_rel[i].emr_tdb = tdbp;
		tprev = emp->em_rel[0].emr_tdb;
		tprev->tdb_inext = NULL;
		for (i = 1; i < nspis; i++)
		{
			tdbp = emp->em_rel[i].emr_tdb;
			tprev->tdb_onext = tdbp;
			tdbp->tdb_inext = tprev;
			tprev = tdbp;
		}
		tprev->tdb_onext = NULL;
		ipspkernfs_dirty = 1;
		error = 0;
		break;
d346 31
a376 1
	      default:
a377 3
	}
	
	return error;
d379 45
a423 4
      flush:
	if (m)
	  m_freem(m);
	return error;
d429 9
a437 9
	struct sockaddr_encap *egw = (struct sockaddr_encap *)gw;
	u_char *op = (u_char *)gw;
	int i, j;
	struct ifaddr *retval = loif.if_addrlist.tqh_first;
	union
	{
		struct in_addr ia;
		u_char io[4];
	} iao;
d439 43
a481 17
	switch (egw->sen_type)
	{
	      case SENT_IPSP:
		return enc_softc[egw->sen_ipsp_ifn].enc_if.if_addrlist.tqh_first;
		break;
		
	      case SENT_IP4:
		/*
		 * Pretty-much standard options walking code.
		 * Repeated elsewhere as necessary
		 */

		for (i = SENT_IP4_LEN; i < egw->sen_len;)
		  switch (op[i])
		  {
			case SENO_EOL:
			  goto opt_done;
d483 1
a483 11
			case SENO_NOP:
			  i++;
			  continue;
			  
			case SENO_IFN:
			  if (op[i+1] != 3)
			  {
				  return NULL;
			  }
			  retval = enc_softc[op[i+2]].enc_if.if_addrlist.tqh_first;
			  goto opt_done;
d485 1
a485 2
			case SENO_IFIP4A:
			  if (op[i+1] != 6) /* XXX -- IPv4 address */
d487 2
a488 1
				  return NULL;
d490 13
a502 29
			  iao.io[0] = op[i+2];
			  iao.io[1] = op[i+3];
			  iao.io[2] = op[i+4];
			  iao.io[3] = op[i+5];

			  for (j = 0; j < nencap; j++)
			  {
				  struct ifaddr *ia = (struct ifaddr *)enc_softc[j].enc_if.if_addrlist.tqh_first;
				  
				  struct sockaddr_in *si = (struct sockaddr_in *)ia->ifa_addr;
				  
				  if ((si->sin_family == AF_INET) && (si->sin_addr.s_addr == iao.ia.s_addr))
				  {
					  retval = ia;
					  goto opt_done;
				  }
			  }
			  i += 6;
			  break;
			  
			default:
			  if (op[i+1] == 0)
			    return NULL;
			  i += op[i+i];
		  }
	      opt_done:
		break;
	}
	return retval;
@


1.3
log
@64bit cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: encap.c,v 1.2 1997/02/24 13:33:56 niklas Exp $	*/
d175 2
d218 1
a218 2
		  SENDERR(ENODEV);
		
d242 1
a242 2
		  SENDERR(ENODEV);

d260 2
a261 3
                if (emp->em_if >= nencap)
                  SENDERR(ENODEV);

a280 1
		{
a281 2
			break;
		}
@


1.2
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d150 2
a151 2
	if ((m == 0) || ((m->m_len < sizeof(long)) &&
			 (m = m_pullup(m, sizeof(long))) == 0))
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 2
@
