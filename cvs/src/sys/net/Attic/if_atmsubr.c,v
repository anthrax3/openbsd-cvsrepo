head	1.34;
access;
symbols
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.10
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.8
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.6
	OPENBSD_5_0:1.32.0.4
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.8
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.6
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.4
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.18.0.4
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.20
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.34
date	2013.08.20.09.14.23;	author mpi;	state dead;
branches;
next	1.33;

1.33
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.24.14.43.56;	author blambert;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.08.15.01.50;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.07.13.45.35;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.30.02.39.24;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.17.04.19.33;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.17.00.09.01;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.30.14.09.32;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.30.13.04.35;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.18.23.07.49;	author deraadt;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.09.13.09.13;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.27.06.07.38;	author kjc;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.15.03.38.33;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.11.17.20.10;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.12.04.09.11;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.07.06.09.08;	author itojun;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.02.04.00.04.18;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.04.16.07.36.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.03.25.23.57.36;	author chuck;	state Exp;
branches;
next	1.8;

1.8
date	96.11.09.23.02.32;	author chuck;	state Exp;
branches;
next	1.7;

1.7
date	96.10.18.19.28.17;	author chuck;	state Exp;
branches;
next	1.6;

1.6
date	96.07.03.17.14.30;	author chuck;	state Exp;
branches;
next	1.5;

1.5
date	96.06.29.20.05.41;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	96.06.27.04.33.10;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.04.21.32;	author chuck;	state Exp;
branches;
next	1.2;

1.2
date	96.06.21.21.35.19;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	96.06.21.15.13.40;	author chuck;	state Exp;
branches;
next	;

1.12.2.1
date	2001.05.14.22.39.59;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.07.04.10.53.55;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@/*      $OpenBSD: if_atmsubr.c,v 1.33 2013/03/28 16:55:27 deraadt Exp $       */

/*
 *
 * Copyright (c) 1996 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and 
 *	Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

/*
 * if_atmsubr.c
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>


#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/if_atm.h>

#include <netinet/in.h>
#include <netinet/if_atm.h>
#include <netinet/if_ether.h> /* XXX: for ETHERTYPE_* */
#if defined(INET) || defined(INET6)
#include <netinet/in_var.h>
#endif
#ifdef NATM
#include <netnatm/natm.h>
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
#endif /* INET6 */

#define senderr(e) { error = (e); goto bad;}

/*
 * atm_output: ATM output routine
 *   inputs:
 *     "ifp" = ATM interface to output to
 *     "m0" = the packet to output
 *     "dst" = the sockaddr to send to (either IP addr, or raw VPI/VCI)
 *     "rt0" = the route to use
 *   returns: error code   [0 == ok]
 *
 *   note: special semantic: if (dst == NULL) then we assume "m" already
 *		has an atm_pseudohdr on it and just send it directly.
 *		[for native mode ATM output]   if dst is null, then
 *		rt0 must also be NULL.
 */

int
atm_output(ifp, m0, dst, rt0)
	struct ifnet *ifp;
	struct mbuf *m0;
	struct sockaddr *dst;
	struct rtentry *rt0;
{
	u_int16_t etype = 0;			/* if using LLC/SNAP */
	int s, error = 0, sz, len;
	struct atm_pseudohdr atmdst, *ad;
	struct mbuf *m = m0;
	struct rtentry *rt;
	struct atmllc *atmllc;
	u_int32_t atm_flags;

	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		senderr(ENETDOWN);

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain),
		    dst->sa_family);
	}
#endif

	/*
	 * check route
	 */
	if ((rt = rt0) != NULL) {

		if ((rt->rt_flags & RTF_UP) == 0) { /* route went down! */
			if ((rt0 = rt = rtalloc1(dst, RT_REPORT,
			     m->m_pkthdr.rdomain)) != NULL)
				rt->rt_refcnt--;
			else 
				senderr(EHOSTUNREACH);
		}

		if (rt->rt_flags & RTF_GATEWAY) {
			if (rt->rt_gwroute == 0)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt);
				rt = rt0;
			lookup:
				rt->rt_gwroute = rtalloc1(rt->rt_gateway,
				    RT_REPORT, ifp->if_rdomain);
				if ((rt = rt->rt_gwroute) == NULL)
					senderr(EHOSTUNREACH);
			}
		}

		/* XXX: put RTF_REJECT code here if doing ATMARP */

	}

	/*
	 * check for non-native ATM traffic   (dst != NULL)
	 */
	if (dst) {
		switch (dst->sa_family) {
#ifdef INET
		case AF_INET:
#endif
#ifdef INET6
		case AF_INET6:
#endif
#if defined(INET) || defined(INET6)
			if (dst->sa_family == AF_INET)
				etype = ETHERTYPE_IP;
			else
				etype = ETHERTYPE_IPV6;
			if (!atmresolve(rt, m, dst, &atmdst)) {
				m = NULL; 
				/* XXX: atmresolve already free'd it */
				senderr(EHOSTUNREACH);
				/* XXX: put ATMARP stuff here */
				/* XXX: watch who frees m on failure */
			}
			break;
#endif

		default:
#if defined(__NetBSD__) || defined(__OpenBSD__)
			printf("%s: can't handle af%d\n", ifp->if_xname, 
			       dst->sa_family);
#elif defined(__FreeBSD__) || defined(__bsdi__)
			printf("%s%d: can't handle af%d\n", ifp->if_name, 
			       ifp->if_unit, dst->sa_family);
#endif
			senderr(EAFNOSUPPORT);
		}

		/*
		 * must add atm_pseudohdr to data
		 */
		sz = sizeof(atmdst);
		atm_flags = ATM_PH_FLAGS(&atmdst);
		if (atm_flags & ATM_PH_LLCSNAP) sz += 8; /* sizeof snap == 8 */
		M_PREPEND(m, sz, M_DONTWAIT);
		if (m == 0)
			senderr(ENOBUFS);
		ad = mtod(m, struct atm_pseudohdr *);
		*ad = atmdst;
		if (atm_flags & ATM_PH_LLCSNAP) {
			atmllc = (struct atmllc *)(ad + 1);
			bcopy(ATMLLC_HDR, atmllc->llchdr, 
						sizeof(atmllc->llchdr));
			ATM_LLC_SETTYPE(atmllc, etype); 
		}
	}

	/*
	 * Queue message on interface, and start output if interface
	 * not yet active.
	 */
	len = m->m_pkthdr.len;
	s = splnet();
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		splx(s);
		return (error);
	}
	ifp->if_obytes += len;
	if_start(ifp);
	splx(s);
	return (error);

bad:
	if (m)
		m_freem(m);
	return (error);
}

/*
 * Process a received ATM packet;
 * the packet is in the mbuf chain m.
 */
void
atm_input(ifp, ah, m, rxhand)
	struct ifnet *ifp;
	struct atm_pseudohdr *ah;
	struct mbuf *m;
	void *rxhand;
{
	struct ifqueue *inq;
	u_int16_t etype = ETHERTYPE_IP; /* default */
	int s;

	if ((ifp->if_flags & IFF_UP) == 0) {
		m_freem(m);
		return;
	}

	/* mark incoming routing domain */
	m->m_pkthdr.rdomain = ifp->if_rdomain;

	ifp->if_ibytes += m->m_pkthdr.len;

	if (rxhand) {
#ifdef NATM
	  struct natmpcb *npcb = rxhand;
	  s = splnet();			/* in case 2 atm cards @@ diff lvls */
	  npcb->npcb_inq++;			/* count # in queue */
	  splx(s);
	  schednetisr(NETISR_NATM);
	  inq = &natmintrq;
	  m->m_pkthdr.rcvif = rxhand; /* XXX: overload */
#else
	  printf("atm_input: NATM detected but not configured in kernel\n");
	  m_freem(m);
	  return;
#endif
	} else {
	  /*
	   * handle LLC/SNAP header, if present
	   */
	  if (ATM_PH_FLAGS(ah) & ATM_PH_LLCSNAP) {
	    struct atmllc *alc;
	    if (m->m_len < sizeof(*alc) &&
		(m = m_pullup(m, sizeof(*alc))) == NULL)
		  return; /* failed */
	    alc = mtod(m, struct atmllc *);
	    if (bcmp(alc, ATMLLC_HDR, 6)) {
#if defined(__NetBSD__) || defined(__OpenBSD__)
	      printf("%s: recv'd invalid LLC/SNAP frame [vp=%d,vc=%d]\n",
		  ifp->if_xname, ATM_PH_VPI(ah), ATM_PH_VCI(ah));
#elif defined(__FreeBSD__) || defined(__bsdi__)
	      printf("%s%d: recv'd invalid LLC/SNAP frame [vp=%d,vc=%d]\n",
		  ifp->if_name, ifp->if_unit, ATM_PH_VPI(ah), ATM_PH_VCI(ah));
#endif
	      m_freem(m);
              return;
	    }
	    etype = ATM_LLC_TYPE(alc);
	    m_adj(m, sizeof(*alc));
	  }

	  switch (etype) {
#ifdef INET
	  case ETHERTYPE_IP:
		  schednetisr(NETISR_IP);
		  inq = &ipintrq;
		  break;
#endif /* INET */
#ifdef INET6
	  case ETHERTYPE_IPV6:
		  schednetisr(NETISR_IPV6);
		  inq = &ip6intrq;
		  break;
#endif
	  default:
	      m_freem(m);
	      return;
	  }
	}

	s = splnet();
	IF_INPUT_ENQUEUE(inq, m);
	splx(s);
}

/*
 * Perform common duties while attaching to interface list
 */
void
atm_ifattach(ifp)
	struct ifnet *ifp;
{

	ifp->if_type = IFT_ATM;
	ifp->if_addrlen = 0;
	ifp->if_hdrlen = 0;
	ifp->if_mtu = ATMMTU;
	ifp->if_output = atm_output;

	if_alloc_sadl(ifp);
#ifdef notyet /* if using ATMARP, store hardware address using the next line */
	bcopy(ifp->hw_addr, LLADDR(ifp->if_sadl), ifp->if_addrlen);
#endif
}
@


1.33
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.32 2010/08/24 14:43:56 blambert Exp $       */
@


1.32
log
@legibility fixes:

1) one statement per line
2) label gets its own line, and doesn't share it with a statement

no functional change

"Let the turd shine." claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.31 2010/05/07 13:33:16 claudio Exp $       */
a89 1
#include <machine/cpu.h>
@


1.31
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.30 2010/05/01 08:14:26 mk Exp $       */
d174 6
a179 4
				rtfree(rt); rt = rt0;
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway,
			    RT_REPORT, ifp->if_rdomain);
				if ((rt = rt->rt_gwroute) == 0)
@


1.30
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.29 2009/11/03 10:59:04 claudio Exp $       */
d163 2
a164 1
			if ((rt0 = rt = RTALLOC1(dst, 0)) != NULL)
d175 2
a176 1
			lookup: rt->rt_gwroute = RTALLOC1(rt->rt_gateway, 0);
@


1.29
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.28 2009/07/08 15:01:50 claudio Exp $       */
d282 1
a282 1
	/* mark incomming routing domain */
@


1.28
log
@Add the same routing domain assignments and checks into the not so used
protocols as it is currently in if_ethersubr.c. OK reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.27 2008/05/07 13:45:35 dlg Exp $       */
d149 1
a149 1
	if (ifp->if_rdomain != m->m_pkthdr.rdomain) {
d151 3
a153 3
		    "%d vs. %d, AF %d\n", ifp->if_xname, ifp->if_rdomain,
		    m->m_pkthdr.rdomain, dst->sa_family);
		senderr(ENETDOWN);
@


1.27
log
@enable tx mitigation when putting packets on the wire by switching from
calls to ifp->if_start to if_start(). these are the obviously right cases
where we can do that, the less obvious ones may follow as theyre figured
out.

deraadt@@ said to go for it
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.25 2005/09/30 02:39:24 brad Exp $       */
d148 9
d281 4
@


1.26
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d243 1
a243 2
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
@


1.25
log
@remove old unused NRL IPv6 code.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.24 2004/04/17 04:19:33 henning Exp $       */
d236 1
a236 1
	s = splimp();
d278 1
a278 1
	  s = splimp();			/* in case 2 atm cards @@ diff lvls */
d333 1
a333 1
	s = splimp();
@


1.24
log
@unbreak
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.23 2004/04/17 00:09:01 henning Exp $       */
a199 23
#if 0	/*NRL INET6*/
		case AF_INET6:
			/*
			 * The bottom line here is to either queue the
			 * outgoing packet in the discovery engine, or fill
			 * in edst with something that'll work.
			 */
			if (m->m_flags & M_MCAST) {
				/*
				 * If multicast dest., then use IPv6 -> Ethernet
				 * mcast mapping.  Really simple.
				 */
				ETHER_MAP_IN6_MULTICAST(
				    ((struct sockaddr_in6 *)dst)->sin6_addr,
				    edst);
			} else {
				/* Do unicast neighbor discovery stuff. */
				if (!ipv6_discov_resolve(ifp, rt, m, dst, edst))
	 				return 0;
			}
			type = htons(ETHERTYPE_IPV6);
			break;
#endif /* INET6 */
@


1.23
log
@add a congestion indicator to if_queue. It is set when the input queue
is full, along with a timer that unsets it again after 10ms.
The input queue beeing full is a reliable indicator for CPU overload, and
this flag allows other subsystems to cope with the situation.
hacked with beck
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.22 2003/12/10 07:22:42 itojun Exp $       */
d357 1
a357 1
	IF_INPUT_ENQUEUE(inq);
@


1.22
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.21 2003/01/07 09:00:33 kjc Exp $       */
d357 1
a357 5
	if (IF_QFULL(inq)) {
		IF_DROP(inq);
		m_freem(m);
	} else
		IF_ENQUEUE(inq, m);
@


1.21
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.20 2002/06/30 14:09:32 art Exp $       */
d132 1
a132 1
	register struct ifnet *ifp;
d140 2
a141 2
	register struct mbuf *m = m0;
	register struct rtentry *rt;
d284 1
a284 1
	register struct atm_pseudohdr *ah;
d288 1
a288 1
	register struct ifqueue *inq;
@


1.20
log
@Fix fallout from recent changes.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.19 2002/06/30 13:04:35 itojun Exp $       */
a143 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a148 7
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m,
		     (dst != NULL ? dst->sa_family : AF_UNSPEC), &pktattr);

	/*
d260 1
a260 1
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
@


1.19
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.18 2001/12/18 23:07:49 deraadt Exp $       */
d378 1
a378 1
	register struct ifnet *ifp;
a379 2
	register struct ifaddr *ifa;
	register struct sockaddr_dl *sdl;
@


1.18
log
@NRL license cleaning
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.17 2001/12/09 13:09:13 jason Exp $       */
d389 1
a389 10
#if defined(__NetBSD__) || defined(__OpenBSD__)
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
#elif defined(__FreeBSD__) || defined(__bsdi__)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)  {
#endif

		if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
		    sdl->sdl_family == AF_LINK) {
			sdl->sdl_type = IFT_ATM;
			sdl->sdl_alen = ifp->if_addrlen;
d391 1
a391 1
			bcopy(ifp->hw_addr, LLADDR(sdl), ifp->if_addrlen);
a392 3
			break;
		}
	}
@


1.18.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.18 2001/12/18 23:07:49 deraadt Exp $       */
d378 1
a378 1
	struct ifnet *ifp;
d380 2
d389 10
a398 1
	if_alloc_sadl(ifp);
d400 1
a400 1
	bcopy(ifp->hw_addr, LLADDR(ifp->if_sadl), ifp->if_addrlen);
d402 3
@


1.18.2.2
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$       */
d144 1
d150 7
d268 1
a268 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
@


1.17
log
@Use queue.h TAILQ macros instead of accessing members directly.
(And convert a few loops to TAILQ_FOREACH).
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.16 2001/06/27 06:07:38 kjc Exp $       */
d36 38
a73 10
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.16
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.15 2001/06/15 03:38:33 itojun Exp $       */
d362 1
a362 2
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	    ifa = ifa->ifa_list.tqe_next)
d364 1
a364 1
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next) 
d376 1
@


1.15
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.14 2001/05/11 17:20:10 aaron Exp $       */
d110 1
a110 1
	int s, error = 0, sz;
d116 1
d122 7
a170 8
# ifdef ATM_PVCEXT
			if (ifp->if_flags & IFF_POINTOPOINT) {
				/* pvc subinterface */
				struct pvcsif *pvcsif = (struct pvcsif *)ifp;
				atmdst = pvcsif->sif_aph;
				break;
			}
# endif
d238 1
a238 1

d240 2
a241 2
	if (IF_QFULL(&ifp->if_snd)) {
		IF_DROP(&ifp->if_snd);
d243 1
a243 1
		senderr(ENOBUFS);
d245 1
a245 2
	ifp->if_obytes += m->m_pkthdr.len;
	IF_ENQUEUE(&ifp->if_snd, m);
@


1.14
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.13 2000/09/12 04:09:11 itojun Exp $       */
a118 1
	ifp->if_lastchange = time;
a276 1
	ifp->if_lastchange = time;
@


1.13
log
@make it compile with INET6 defined.  the old INET6 code was from NRL,
and L2 macros were different.  not really tested.  sync with kame/ALTQ.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.12 2000/02/07 06:09:08 itojun Exp $       */
d301 2
a302 1
	    if (m->m_len < sizeof(*alc) && (m = m_pullup(m, sizeof(*alc))) == 0)
@


1.12
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.11 1999/02/04 00:04:18 deraadt Exp $       */
d74 1
a74 1
#ifdef INET
d80 1
d155 17
a178 1
			etype = ETHERTYPE_IP;
d181 1
a181 1
#ifdef INET6
d208 1
a208 1
				dst->sa_family);
d211 1
a211 1
				ifp->if_unit, dst->sa_family);
a231 1
					/* note: already in network order */
d325 6
a331 6
#ifdef INET6
	case ETHERTYPE_IPV6:
		schednetisr(NETISR_IPV6);
		inq = &ipv6intrq;
		break;
#endif /* INET6 */
@


1.12.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.13 2000/09/12 04:09:11 itojun Exp $       */
d74 1
a74 1
#if defined(INET) || defined(INET6)
a79 1

a153 17
#endif
#ifdef INET6
		case AF_INET6:
#endif
#if defined(INET) || defined(INET6)
			if (dst->sa_family == AF_INET)
				etype = ETHERTYPE_IP;
			else
				etype = ETHERTYPE_IPV6;
# ifdef ATM_PVCEXT
			if (ifp->if_flags & IFF_POINTOPOINT) {
				/* pvc subinterface */
				struct pvcsif *pvcsif = (struct pvcsif *)ifp;
				atmdst = pvcsif->sif_aph;
				break;
			}
# endif
d161 1
d164 1
a164 1
#if 0	/*NRL INET6*/
d191 1
a191 1
			       dst->sa_family);
d194 1
a194 1
			       ifp->if_unit, dst->sa_family);
d215 1
d309 1
a309 1
#endif /* INET */
d311 5
a315 5
	  case ETHERTYPE_IPV6:
		  schednetisr(NETISR_IPV6);
		  inq = &ip6intrq;
		  break;
#endif
@


1.12.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.12.2.1 2001/05/14 22:39:59 niklas Exp $       */
d110 1
a110 1
	int s, error = 0, sz, len;
a115 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
d119 1
a119 7

	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m,
		     (dst != NULL ? dst->sa_family : AF_UNSPEC), &pktattr);
d164 8
d239 1
a239 1
	len = m->m_pkthdr.len;
d241 2
a242 2
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
d244 1
a244 1
		return (error);
d246 2
a247 1
	ifp->if_obytes += len;
d278 1
d301 1
a301 2
	    if (m->m_len < sizeof(*alc) &&
		(m = m_pullup(m, sizeof(*alc))) == NULL)
@


1.12.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*      $OpenBSD$       */
d36 10
a45 38
 *	@@(#)COPYRIGHT	1.1 (NRL) January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d362 2
a363 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
d365 1
a365 1
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)  {
a376 1
	}
@


1.12.2.4
log
@Sync the SMP branch with 3.3
@
text
@d144 1
d150 7
d268 1
a268 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d378 1
a378 1
	struct ifnet *ifp;
d380 2
d389 10
a398 1
	if_alloc_sadl(ifp);
d400 1
a400 1
	bcopy(ifp->hw_addr, LLADDR(ifp->if_sadl), ifp->if_addrlen);
d402 3
@


1.12.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d132 1
a132 1
	struct ifnet *ifp;
d140 2
a141 2
	struct mbuf *m = m0;
	struct rtentry *rt;
d284 1
a284 1
	struct atm_pseudohdr *ah;
d288 1
a288 1
	struct ifqueue *inq;
@


1.12.2.6
log
@Merge with the trunk
@
text
@d357 5
a361 1
	IF_INPUT_ENQUEUE(inq, m);
@


1.11
log
@ipv6 support for atm
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.10 1998/04/16 07:36:41 deraadt Exp $       */
a80 1
#include <netinet6/in6.h>
@


1.10
log
@proper htons() and ntohs() handling in output/input, i think
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.9 1998/03/25 23:57:36 chuck Exp $       */
d36 12
d80 4
d165 23
d311 6
@


1.9
log
@Add a missing ntohs.  fixes llc/snap connections.
from: bouyer@@netbsd
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.8 1996/11/09 23:02:32 chuck Exp $       */
d146 1
a146 1
			etype = htons(ETHERTYPE_IP);
d261 1
a261 1
	    etype = ntohs(ATM_LLC_TYPE(alc));
@


1.8
log
@fix previous byte-order fix the correct way
(from Zdenek Salvet <salvet@@horn.ics.muni.cz>)
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.7 1996/10/18 19:28:17 chuck Exp $       */
d261 1
a261 1
	    etype = ATM_LLC_TYPE(alc);
@


1.7
log
@fix: add missing ntohs() for llc mode, as noted by several people including
Dong Lin, Zdenek Salvet, and Matthias Drochner(i think).
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.4 1996/06/29 20:07:06 chuck Exp $       */
d261 1
a261 1
	    etype = ntohs(ATM_LLC_TYPE(alc));
@


1.6
log
@ported to FreeBSD 2.2-960612-SNAP.
@
text
@d261 1
a261 1
	    etype = ATM_LLC_TYPE(alc);
@


1.5
log
@change:
  - change asock to rxhand and adjust all for this [esp atm_input]
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.3 1996/06/27 04:34:21 chuck Exp $       */
d60 1
d111 1
a111 1
			if ((rt0 = rt = rtalloc1(dst, 0)) != NULL)
d122 1
a122 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 0);
d151 1
d154 4
d251 1
d254 4
d302 2
d306 4
@


1.4
log
@fix/improvement:
 - add proto if atm_input
 - add native mode atm hooks to if_atmsubr.c (atm_input)
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.2 1996/06/26 04:22:56 chuck Exp $       */
d204 1
a204 1
atm_input(ifp, ah, m, so)
d208 1
a208 1
	struct socket *so;
d221 1
a221 1
	if (so) {
d223 4
d229 1
a229 1
	  m->m_pkthdr.rcvif = (struct ifnet *) so; /* XXX: overload */
@


1.3
log
@[1] add new rxso passing structure to if_atm.h
[2] modify atm_output to handle native mode atm output mbufs
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.1 1996/06/22 01:47:37 chuck Exp $       */
d64 3
d204 1
a204 1
atm_input(ifp, ah, m)
d208 1
d221 27
a247 13
	/*
	 * handle LLC/SNAP header, if present
	 */
	if (ATM_PH_FLAGS(ah) & ATM_PH_LLCSNAP) {
	  struct atmllc *alc;
	  if (m->m_len < sizeof(*alc) && (m = m_pullup(m, sizeof(*alc))) == 0)
		return; /* failed */
	  alc = mtod(m, struct atmllc *);
	  if (bcmp(alc, ATMLLC_HDR, 6)) {
	    printf("%s: recv'd invalid LLC/SNAP frame [vp=%d,vc=%d]\n",
		ifp->if_xname, ATM_PH_VPI(ah), ATM_PH_VCI(ah));
	    m_freem(m);
            return;
a248 3
	  etype = ATM_LLC_TYPE(alc);
	  m_adj(m, sizeof(*alc));
	}
d250 1
a250 1
	switch (etype) {
d252 4
a255 4
	case ETHERTYPE_IP:
		schednetisr(NETISR_IP);
		inq = &ipintrq;
		break;
d257 4
a260 3
	default:
	    m_freem(m);
	    return;
@


1.2
log
@use correct copyright
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atmsubr.c,v 1.1 1996/06/21 15:13:40 chuck Exp $       */
d18 2
a19 2
 *      This product includes software developed by Charles D. Cranor and
 * 	Washington University.
d75 5
d127 6
a132 1
	switch (dst->sa_family) {
d134 10
a143 8
	case AF_INET:
		if (!atmresolve(rt, m, dst, &atmdst)) {
			m = NULL; /* XXX: atmresolve already free'd it */
			senderr(EHOSTUNREACH);
			/* XXX: ATMARP stuff here, watch who frees m on fail */
		}
		etype = htons(ETHERTYPE_IP);
		break;
d146 5
a150 1
	/* case AF_ATM: XXX: need raw ATM handle here? */
d152 18
a169 18
	default:
		printf("%s: can't handle af%d\n", ifp->if_xname, 
			dst->sa_family);
		senderr(EAFNOSUPPORT);
	}

	sz = sizeof(atmdst);
	atm_flags = ATM_PH_FLAGS(&atmdst);
	if (atm_flags & ATM_PH_LLCSNAP) sz += 8; /* sizeof snap == 8 */
	M_PREPEND(m, sz, M_DONTWAIT);
	if (m == 0)
		senderr(ENOBUFS);
	ad = mtod(m, struct atm_pseudohdr *);
	*ad = atmdst;
	if (atm_flags & ATM_PH_LLCSNAP) {
		atmllc = (struct atmllc *)(ad + 1);
		bcopy(ATMLLC_HDR, atmllc->llchdr, sizeof(atmllc->llchdr));
		ATM_LLC_SETTYPE(atmllc, etype); /* already in network order */
@


1.1
log
@network support for ATM networks (ATM == Async Transfer Mode, not
Automatic Teller Machine).

Currently supports PVCs only (no ATM ARP either).
@
text
@d1 1
a1 1
/*      $OpenBSD: $       */
d5 1
a5 1
 * Copyright (c) 1996 Charles D. Cranor
d18 2
a19 1
 *      This product includes software developed by Charles D. Cranor.
@
