head	1.11;
access;
symbols
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.2.0.10
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.8
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.6
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.4
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.03.14.52.39;	author mpi;	state dead;
branches;
next	1.10;
commitid	dxC8XEETMDhMlqh6;

1.10
date	2016.01.08.13.53.24;	author mpi;	state Exp;
branches
	1.10.2.1;
next	1.9;
commitid	l2mfiUCCi0ZhRviM;

1.9
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.8;
commitid	ILbVM1M3uPNjwswz;

1.8
date	2015.12.03.12.22.51;	author dlg;	state Exp;
branches;
next	1.7;
commitid	Xu3de8VDlKImDsXf;

1.7
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.6;
commitid	t2fhFUpUuj89g4Sj;

1.6
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.5;
commitid	zhW8jJrfVCoAthrR;

1.5
date	2014.07.11.21.54.38;	author tedu;	state Exp;
branches;
next	1.4;
commitid	0n9cIGBISFAEt4b1;

1.4
date	2014.01.22.04.03.06;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2013.08.20.09.14.24;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	;

1.10.2.1
date	2016.07.14.11.13.13;	author mpi;	state Exp;
branches;
next	;
commitid	c3zMIeXyCizF4IZR;


desc
@@


1.11
log
@Stop using a soft-interrupt context to process incoming network packets.

Use a new task that runs holding the KERNEL_LOCK to execute mp-unsafe
code.  Our current goal is to progressively move input functions to the
unlocked task.

This gives a small performance boost confirmed by Hrvoje Popovski's
IPv4 forwarding measurement:

before:					after:

send           receive			send           receive
400kpps        400kpps                  400kpps        400kpps
500kpps        500kpps                  500kpps        500kpps
600kpps        600kpps                  600kpps        600kpps
650kpps        650kpps                  650kpps        640kpps
700kpps        700kpps                  700kpps        700kpps
720kpps        640kpps                  720kpps        710kpps
800kpps        640kpps                  800kpps        650kpps
1.4Mpps        570kpps                  1.4Mpps        590kpps
14Mpps         570kpps                  14Mpps         590kpps


ok kettenis@@, bluhm@@, dlg@@
@
text
@/*
 * Copyright (c) 2010 Owain G. Ainsworth <oga@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/param.h>
#include <sys/systm.h>

#include <net/netisr.h>

#include <machine/intr.h>

#include "ppp.h"
#include "bridge.h"
#include "pppoe.h"
#include "pfsync.h"

void	 netintr(void *);

int	 netisr;
void	*netisr_intr;

void
netintr(void *unused)
{
	int n, t = 0;

	while ((n = netisr) != 0) {
		atomic_clearbits_int(&netisr, n);

		if (n & (1 << NETISR_IP))
			ipintr();
#ifdef INET6
		if (n & (1 << NETISR_IPV6))
			ip6intr();
#endif
#if NPPP > 0
		if (n & (1 << NETISR_PPP))
			pppintr();
#endif
#if NBRIDGE > 0
		if (n & (1 << NETISR_BRIDGE))
			bridgeintr();
#endif
#if NPPPOE > 0
		if (n & (1 << NETISR_PPPOE))
			pppoeintr();
#endif
		t |= n;
	}

#if NPFSYNC > 0
	if (t & (1 << NETISR_PFSYNC))
		pfsyncintr();
#endif
}

void
netisr_init(void)
{
	netisr_intr = softintr_establish(IPL_SOFTNET, netintr, NULL);
	if (netisr_intr == NULL)
		panic("can't establish softnet handler");
}
@


1.10
log
@Get rid of the arp and revarp input queues.

Packets of types ARP and REVARP are now processed in the softnet task,
directly from ether_input() and without holding the KERNEL_LOCK.

Tested by many, ok dlg@@
@
text
@@


1.10.2.1
log
@Backport ARP race fix:

Move ARP processing back to the KERNEL_LOCK()ed task until the race
triggered by updating a cached, but removed from the table, entry is
properly fixed.

Diff from dlg@@, prodding deraadt@@
@
text
@a26 1
#include "ether.h"
a40 4
#if NETHER > 0
		if (n & (1 << NETISR_ARP))
			arpintr();
#endif
@


1.9
log
@remove old lint annotations
@
text
@a22 1
#include "ether.h"
a40 4
#if NETHER > 0
		if (n & (1 << NETISR_ARP))
			arpintr();
#endif
@


1.8
log
@rework if_start to allow nics to provide an mpsafe start routine.

existing start routines will still be called under the kernel lock
and at IPL_NET.

mpsafe start routines will be serialised so only one instance of
each interfaces function will be running in the kernel at any point
in time. this guarantees packets will be dequeued in order, and the
start routines dont have to lock against themselves because if_start
does it for them.

the code to do that is based on the scsi runqueue code.

this also provides an if_start_barrier() function that should wait
until any currently running instances of if_start have finished.

a driver can opt in to the mpsafe if_start call by doing the following:

1. setting ifp->if_xflags = IFXF_MPSAFE
2. only calling if_start() instead of its own start routine
3. clearing IFF_RUNNING before calling if_start_barrier() on its way down
4. only using IFQ_DEQUEUE (not ifq_deq_begin/commit/rollback)

to simplify the implementation the tx mitigation code has been removed.

tested by several
ok mpi@@ jmatthew@@
@
text
@d35 1
a35 1
netintr(void *unused) /* ARGSUSED */
@


1.7
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@a70 2
	if (t & (1 << NETISR_TX))
		nettxintr();
@


1.6
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@a51 4
#ifdef MPLS
		if (n & (1 << NETISR_MPLS))
			mplsintr();
#endif
@


1.5
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@a41 1
#ifdef INET
a47 1
#endif
@


1.4
log
@do the tx and pfsync handlers only once on the way out of netisr
instead of in every loop.

tested for a long time on many machines at work.
ok henning@@
@
text
@a22 1
#include "bluetooth.h"
a69 5
#if NBLUETOOTH > 0
		if (n & (1 << NETISR_BT))
			btintr();
#endif

@


1.3
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@d38 2
a39 1
	int n;
d75 4
d80 2
a81 2
		if (n & (1 << NETISR_PFSYNC))
			pfsyncintr();
d83 2
a84 3
		if (n & (1 << NETISR_TX))
			nettxintr();
	}
@


1.2
log
@begone, fucking rotten appletalk shit. ok room
@
text
@a57 4
#if NATM > 0
		if (n & (1 << NETISR_NATM))
			natmintr();
#endif
@


1.1
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@a57 4
#ifdef NETATALK
		if (n & (1 << NETISR_ATALK))
			atintr();
#endif
@

