head	1.26;
access;
symbols
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.2
	SMP_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2007.05.29.21.01.55;	author claudio;	state dead;
branches;
next	1.25;

1.25
date	2007.05.29.18.21.19;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.07.18.15.29;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2006.09.26.13.11.38;	author pedro;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.17.14.14.12;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.08.06.55.33;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.07.02.45.11;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.18.23.26.52;	author mpf;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.19.03.25.36;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.16.15.01.09;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.17.00.09.01;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.18.11.01.41;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.01.06.13.00;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.18.03.26.59;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.09.13.09.13;	author jason;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.06.27.06.07.45;	author kjc;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.15.03.38.34;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.21.13.44.27;	author fgsch;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.12.27.21.47.23;	author fgsch;	state Exp;
branches;
next	;

1.2.2.1
date	2001.07.04.10.54.10;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	2004.06.05.23.11.24;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@It helps to commit removals from the tree that has the files cvs removed
instead of one where they where just empty. Figured out by art@@
@
text
@@


1.25
log
@Move tokenring support to the attic where it can join the cards that where
decomissioned aeon ago. We will not miss it at all.
OK dlg@@ henning@@ and a lot of cheers by other in the room
@
text
@@


1.24
log
@use LINK_STATE_IS_UP(ifp0->if_link_state) instead of
ifp0->if_link_state == LINK_STATE_UP to handle the new half/full
duplex link states. i forgot to commit these snippets before.

ok jsg@@
@
text
@a0 499
/*	$OpenBSD: if_tokensubr.c,v 1.23 2006/09/26 13:11:38 pedro Exp $	*/
/*	$NetBSD: if_tokensubr.c,v 1.7 1999/05/30 00:39:07 bad Exp $	*/

/*
 * Copyright (c) 1997-1999
 *	Onno van der Linden
 * Copyright (c) 1995
 *	Matt Thomas.  All rights reserved.
 * Copyright (c) 1982, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: NetBSD: if_fddisubr.c,v 1.2 1995/08/19 04:35:29 cgd Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>

#include <machine/cpu.h>

#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/if_llc.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/in_var.h>
#include <net/if_token.h>
#endif

#include "bpfilter.h"

#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

/*
 * TODO:
 * handle source routing via send_xid()
 * IPX cases
 * handle "fast" forwarding like if_ether and if_fddi
 */

#define senderr(e) { error = (e); goto bad;}

#if defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
#define	RTALLOC1(a, b)			rtalloc1(a, b, 0)
#define	ARPRESOLVE(a, b, c, d, e, f)	arpresolve(a, b, c, d, e)
#define	TYPEHTONS(t)			(t)
#elif defined(__FreeBSD__)
#define	RTALLOC1(a, b)			rtalloc1(a, b, 0UL)
#define	ARPRESOLVE(a, b, c, d, e, f)	arpresolve(a, b, c, d, e, f)
#define	TYPEHTONS(t)			(htons(t))
#endif

#define RCF_ALLROUTES (2 << 8) | TOKEN_RCF_FRAME2 | TOKEN_RCF_BROADCAST_ALL
#define RCF_SINGLEROUTE (2 << 8) | TOKEN_RCF_FRAME2 | TOKEN_RCF_BROADCAST_SINGLE

/*
 * This really should be defined in if_llc.h but in case it isn't.
 */
#ifndef llc_snap
#define	llc_snap	llc_un.type_snap
#endif

int	token_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *); 

/*
 * Token Ring output routine.
 * Encapsulate a packet of type family for the local net.
 * Assumes that ifp is actually pointer to arphdr structure.
 * XXX route info has to go into the same mbuf as the header
 */
int
token_output(ifp0, m0, dst, rt0)
	struct ifnet *ifp0;
	struct mbuf *m0;
	struct sockaddr *dst;
	struct rtentry *rt0;
{
	u_int16_t etype;
	int s, len, error = 0;
	u_char edst[ISO88025_ADDR_LEN];
	struct mbuf *m = m0;
	struct rtentry *rt;
	struct mbuf *mcopy = (struct mbuf *)0;
	struct token_header *trh;
#ifdef INET
	struct arpcom *ac = (struct arpcom *)ifp0;
#endif /* INET */
	struct token_rif *rif = (struct  token_rif *)0;
	struct token_rif bcastrif;
	size_t riflen = 0;
	short mflags;
	struct ifnet *ifp = ifp0;

#if NCARP > 0
	if (ifp->if_type == IFT_CARP) {
		struct ifaddr *ifa;

		/* loop back if this is going to the carp interface */
		if (dst != NULL && LINK_STATE_IS_UP(ifp0->if_link_state) &&
		    (ifa = ifa_ifwithaddr(dst)) != NULL &&
		    ifa->ifa_ifp == ifp0)
			return (looutput(ifp0, m, dst, rt0));

		ifp = ifp->if_carpdev;
		ac = (struct arpcom *)ifp;

		if ((ifp0->if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			senderr(ENETDOWN);
	}
#endif /* NCARP > 0 */

	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		senderr(ENETDOWN);
	if ((rt = rt0)) {
		if ((rt->rt_flags & RTF_UP) == 0) {
			if ((rt0 = rt = RTALLOC1(dst, 1)))
				rt->rt_refcnt--;
			else
				senderr(EHOSTUNREACH);
		}
		if (rt->rt_flags & RTF_GATEWAY) {
			if (rt->rt_gwroute == 0)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt); rt = rt0;
			lookup: rt->rt_gwroute = RTALLOC1(rt->rt_gateway, 1);
				if ((rt = rt->rt_gwroute) == 0)
					senderr(EHOSTUNREACH);
			}
		}
		if (rt->rt_flags & RTF_REJECT)
			if (rt->rt_rmx.rmx_expire == 0 ||
			    time_second < rt->rt_rmx.rmx_expire)
				senderr(rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
	}

	switch (dst->sa_family) {

#ifdef INET
	case AF_INET:
		if (m->m_flags & M_BCAST) {
			if (ifp->if_flags & IFF_LINK0) {
				if (ifp->if_flags & IFF_LINK1)
					bcastrif.tr_rcf = htons(RCF_ALLROUTES);
				else
					bcastrif.tr_rcf = htons(RCF_SINGLEROUTE);
				rif = &bcastrif;
				riflen = sizeof(rif->tr_rcf);
			}
			bcopy((caddr_t)tokenbroadcastaddr, (caddr_t)edst,
			    sizeof(edst));
		}
/*
 * XXX m->m_flags & M_MCAST   IEEE802_MAP_IP_MULTICAST ??
 */
		else {
			if (!ARPRESOLVE(ac, rt, m, dst, edst, rt0))
				return (0);	/* if not yet resolved */
			rif = TOKEN_RIF((struct llinfo_arp *) rt->rt_llinfo);
			riflen = (ntohs(rif->tr_rcf) & TOKEN_RCF_LEN_MASK) >> 8;
		}
		/* If broadcasting on a simplex interface, loopback a copy. */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX)) {
#if NPF > 0
			struct pf_mtag *t;

			if ((t = pf_find_mtag(m)) == NULL || !t->routed)
#endif
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		}
		etype = htons(ETHERTYPE_IP);
		break;
#if 0
	case AF_ARP:
/*
 * XXX source routing, assume m->m_data contains the useful stuff
 */
		ah = mtod(m, struct arphdr *);
		ah->ar_hrd = htons(ARPHRD_IEEE802);

		switch(ntohs(ah->ar_op)) {
		case ARPOP_REVREQUEST:
		case ARPOP_REVREPLY:
			etype = htons(ETHERTYPE_REVARP);
			break;

		case ARPOP_REQUEST:
		case ARPOP_REPLY:
		default:
			etype = htons(ETHERTYPE_ARP);
		}

		if (m->m_flags & M_BCAST) {
			if (ifp->if_flags & IFF_LINK0) {
				if (ifp->if_flags & IFF_LINK1)
					bcastrif.tr_rcf = htons(RCF_ALLROUTES);
				else
					bcastrif.tr_rcf = htons(RCF_SINGLEROUTE);
				rif = &bcastrif;
				riflen = sizeof(rif->tr_rcf);
			}
			bcopy((caddr_t)tokenbroadcastaddr, (caddr_t)edst,
			    sizeof(edst));
		}
		else {
			bcopy((caddr_t)ar_tha(ah), (caddr_t)edst, sizeof(edst));
			trh = (struct token_header *)M_TRHSTART(m);
			trh->token_ac = TOKEN_AC;
			trh->token_fc = TOKEN_FC;
			if (trh->token_shost[0] & TOKEN_RI_PRESENT) {
				struct token_rif *trrif;

				trrif = TOKEN_RIF(trh);
				riflen = (ntohs(trrif->tr_rcf) & TOKEN_RCF_LEN_MASK) >> 8;
			}
			bcopy((caddr_t)edst, (caddr_t)trh->token_dhost,
			    sizeof (edst));
			bcopy(LLADDR(ifp->if_sadl), (caddr_t)trh->token_shost,
			    sizeof(trh->token_shost));
			if (riflen != 0)
				trh->token_shost[0] |= TOKEN_RI_PRESENT;
/*
 * compare (m->m_data - m->m_pktdat) with (sizeof(struct token_header) + riflen + ...
 */
			m->m_len += (sizeof(*trh) + riflen + LLC_SNAPFRAMELEN);
			m->m_data -= (sizeof(*trh) + riflen + LLC_SNAPFRAMELEN);
			m->m_pkthdr.len += (sizeof(*trh) + riflen + LLC_SNAPFRAMELEN);
			goto send;
		}
		break;
#endif /* 0 */
#endif
	case AF_UNSPEC:
	{
		struct ether_header *eh;
		eh = (struct ether_header *)dst->sa_data;
		bcopy((caddr_t)eh->ether_dhost, (caddr_t)edst, sizeof (edst));
		if (*edst & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		etype = TYPEHTONS(eh->ether_type);
		if (m->m_flags & M_BCAST) {
			if (ifp->if_flags & IFF_LINK0) {
				if (ifp->if_flags & IFF_LINK1)
					bcastrif.tr_rcf = htons(RCF_ALLROUTES);
				else
					bcastrif.tr_rcf = htons(RCF_SINGLEROUTE);
				rif = &bcastrif;
				riflen = sizeof(bcastrif.tr_rcf);
			}
		}
		break;
	}

	default:
		printf("%s: can't handle af%d\n", ifp->if_xname,
		    dst->sa_family);
		senderr(EAFNOSUPPORT);
	}


	if (mcopy)
		(void) looutput(ifp, mcopy, dst, rt);
	if (etype != 0) {
		struct llc *l;
		M_PREPEND(m, LLC_SNAPFRAMELEN, M_DONTWAIT);
		if (m == 0)
			senderr(ENOBUFS);
		l = mtod(m, struct llc *);
		l->llc_control = LLC_UI;
		l->llc_dsap = l->llc_ssap = LLC_SNAP_LSAP;
		l->llc_snap.org_code[0] = l->llc_snap.org_code[1] =
		    l->llc_snap.org_code[2] = 0;
		bcopy((caddr_t) &etype, (caddr_t) &l->llc_snap.ether_type,
		    sizeof(u_short));
	}

	/*
	 * Add local net header.  If no space in first mbuf,
	 * allocate another.
	 */

	M_PREPEND(m, (riflen + sizeof (*trh)), M_DONTWAIT);
	if (m == 0)
		senderr(ENOBUFS);
	trh = mtod(m, struct token_header *);
	trh->token_ac = TOKEN_AC;
	trh->token_fc = TOKEN_FC;
	bcopy((caddr_t)edst, (caddr_t)trh->token_dhost, sizeof (edst));
	bcopy((caddr_t)ac->ac_enaddr, (caddr_t)trh->token_shost,
	    sizeof(trh->token_shost));

	if (riflen != 0) {
		struct token_rif *trrif;

		trh->token_shost[0] |= TOKEN_RI_PRESENT;
		trrif = TOKEN_RIF(trh);
		bcopy(rif, trrif, riflen);
	}
#if 0
send:
#endif /* 0 */

#if NCARP > 0
	if (ifp0 != ifp && ifp0->if_type == IFT_CARP) {
		bcopy((caddr_t)((struct arpcom *)ifp0)->ac_enaddr,
		    (caddr_t)trh->token_shost, sizeof(trh->token_shost));
	}
#endif

	mflags = m->m_flags;
	len = m->m_pkthdr.len;
	s = splnet();
	/*
	 * Queue message on interface, and start output if interface
	 * not yet active.
	 */
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		/* mbuf is already freed */
		splx(s);
		return (error);
	}
	ifp->if_obytes += len;
#if NCARP > 0
	if (ifp != ifp0)
		ifp0->if_obytes += len;
#endif /* NCARP > 0 */
	if (mflags & M_MCAST)
		ifp->if_omcasts++;
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
	splx(s);
	return (error);

bad:
	if (m)
		m_freem(m);
	return (error);
}

/*
 * Process a received token ring packet;
 * the packet is in the mbuf chain m with
 * the token ring header.
 */
void
token_input(ifp, m)
	struct ifnet *ifp;
	struct mbuf *m;
{
	struct ifqueue *inq;
	struct llc *l;
	struct token_header *trh;
	int s, lan_hdr_len;

	if ((ifp->if_flags & IFF_UP) == 0) {
		m_freem(m);
		return;
	}

	trh = mtod(m, struct token_header *);

	ifp->if_ibytes += m->m_pkthdr.len;
	if (bcmp((caddr_t)tokenbroadcastaddr, (caddr_t)trh->token_dhost,
	    sizeof(tokenbroadcastaddr)) == 0)
		m->m_flags |= M_BCAST;
	else if (trh->token_dhost[0] & 1)
		m->m_flags |= M_MCAST;
	if (m->m_flags & (M_BCAST|M_MCAST))
		ifp->if_imcasts++;

	/* Skip past the Token Ring header and RIF. */
	lan_hdr_len = sizeof(struct token_header);
	if (trh->token_shost[0] & TOKEN_RI_PRESENT) {
		struct token_rif *trrif;

		trrif = TOKEN_RIF(trh);
		lan_hdr_len += (ntohs(trrif->tr_rcf) & TOKEN_RCF_LEN_MASK) >> 8;
	}
	m_adj(m, lan_hdr_len);

	l = mtod(m, struct llc *);
	switch (l->llc_dsap) {
#if defined(INET)
	case LLC_SNAP_LSAP:
	{
		u_int16_t etype;
		if (l->llc_control != LLC_UI || l->llc_ssap != LLC_SNAP_LSAP)
			goto dropanyway;
		if (l->llc_snap.org_code[0] != 0 ||
		    l->llc_snap.org_code[1] != 0 ||
		    l->llc_snap.org_code[2] != 0)
			goto dropanyway;
		etype = ntohs(l->llc_snap.ether_type);
		m_adj(m, LLC_SNAPFRAMELEN);

#if NCARP > 0
		if (ifp->if_carp && ifp->if_type != IFT_CARP &&
		    (carp_input(m, (u_int8_t *)&trh->token_shost,
		    (u_int8_t *)&trh->token_dhost, l->llc_snap.ether_type) == 0))
			return;
#endif

		switch (etype) {
#ifdef INET
		case ETHERTYPE_IP:
			schednetisr(NETISR_IP);
			inq = &ipintrq;
			break;

		case ETHERTYPE_ARP:
			schednetisr(NETISR_ARP);
			inq = &arpintrq;
			break;
#endif
		default:
			/*
			printf("token_input: unknown protocol 0x%x\n", etype);
			*/
			ifp->if_noproto++;
			goto dropanyway;
		}
		break;
	}
#endif /* INET */

	default:
		/* printf("token_input: unknown dsap 0x%x\n", l->llc_dsap); */
		ifp->if_noproto++;
	dropanyway:
		m_freem(m);
		return;
	}

	s = splnet();
	IF_INPUT_ENQUEUE(inq, m);
	splx(s);
}

/*
 * Perform common duties while attaching to interface list
 */
void
token_ifattach(ifp)
	struct ifnet *ifp;
{
	ifp->if_type = IFT_ISO88025;
	ifp->if_addrlen = ISO88025_ADDR_LEN;
	ifp->if_hdrlen = 14;
	ifp->if_mtu = ISO88025_MTU;
	ifp->if_output = token_output;
#ifdef IFF_NOTRAILERS
	ifp->if_flags |= IFF_NOTRAILERS;
#endif
	if_alloc_sadl(ifp);
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	    LLADDR(ifp->if_sadl), ifp->if_addrlen);
}
@


1.23
log
@Fix compilation, okay henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.22 2006/06/17 14:14:12 henning Exp $	*/
d139 1
a139 1
		if (dst != NULL && ifp0->if_link_state == LINK_STATE_UP &&
@


1.22
log
@adopt to extended rtrequest / rtalloc1 api
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.21 2006/03/04 22:40:16 brad Exp $	*/
d204 6
a209 2
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    m_tag_find(m, PACKET_TAG_PF_ROUTED, NULL) == NULL)
d211 1
d440 2
a441 2
		    (carp_input(m, (u_int8_t *)&th->token_shost,
		    (u_int8_t *)&th->token_dhost, l->llc_snap.ether_type) == 0))
@


1.21
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.20 2005/06/08 06:55:33 henning Exp $	*/
d83 1
a83 1
#define	RTALLOC1(a, b)			rtalloc1(a, b)
@


1.20
log
@bye bye netns (and a few leftover DECNET bits while here)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.19 2005/06/07 02:45:11 henning Exp $	*/
d348 1
a348 1
	s = splimp();
d471 1
a471 1
	s = splimp();
@


1.19
log
@do not handle CCITT any longer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.18 2005/01/18 23:26:52 mpf Exp $	*/
a65 9
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#ifdef DECNET
#include <netdnet/dn.h>
#endif

a268 13
#ifdef NS
	case AF_NS:
		etype = htons(ETHERTYPE_NS);
		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
		    (caddr_t)edst, sizeof (edst));
		if (!bcmp((caddr_t)edst, (caddr_t)&ns_thishost, sizeof(edst)))
			return (looutput(ifp, m, dst, rt));
		/* If broadcasting on a simplex interface, loopback a copy. */
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
			mcopy = m_copy(m, 0, (int)M_COPYALL);
		break;
#endif

d420 1
a420 1
#if defined(INET) || defined(NS) || defined(DECNET)
a451 12
#ifdef NS
		case ETHERTYPE_NS:
			schednetisr(NETISR_NS);
			inq = &nsintrq;
			break;
#endif
#ifdef DECNET
		case ETHERTYPE_DECNET:
			schednetisr(NETISR_DECNET);
			inq = &decnetintrq;
			break;
#endif
d461 1
a461 1
#endif /* INET || NS */
@


1.18
log
@Rewriting the lladdr can now be done without using mbuf tags.
Advertisements run through the carp interface first.
So we just take the address from ifp0.
While we're there,
also remove carp_macmatch6, which isn't used anymore.

Proposed by mcbride@@
ok mcbride@@, pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.17 2004/12/19 03:25:36 mcbride Exp $	*/
a58 1

a81 5
#ifdef LLC
#include <netccitt/dll.h>
#include <netccitt/llc_var.h>
#endif

a84 2
 * source routing for ISO,LLC,CCITT protocols
 * need sockaddr_dl_8025 to handle this correctly
a88 4
#if defined(LLC) && defined(CCITT)
extern struct ifqueue pkintrq;
#endif

d104 3
d108 1
a108 1
#define llc_snap	llc_un.type_snap
a289 43
#ifdef	LLC
/*	case AF_NSAP: */
	case AF_CCITT: {
		struct sockaddr_dl *sdl =
		    (struct sockaddr_dl *) rt -> rt_gateway;

		if (sdl && sdl->sdl_family == AF_LINK
		    && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (char *)edst, sizeof(edst));
		}
		else {
			/* Not a link interface ? Funny ... */
			goto bad;
		}
		if ((ifp->if_flags & IFF_SIMPLEX) && (*edst & 1) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*trh), M_DONTWAIT);
			if (mcopy) {
				trh = mtod(mcopy, struct token_header *);
				bcopy((caddr_t)edst,
				    (caddr_t)trh->token_dhost, sizeof (edst));
				bcopy(LLADDR(ifp->if_sadl),
				    (caddr_t)trh->token_shost, sizeof (edst));
			}
		}
		etype = 0;
#ifdef LLC_DEBUG
		{
			int i;
			struct llc *l = mtod(m, struct llc *);

			printf("token_output: sending LLC2 pkt to: ");
			for (i=0; i < ISO88025_ADDR_LEN; i++)
				printf("%x ", edst[i] & 0xff);
			printf(" len 0x%x dsap 0x%x ssap 0x%x control 0x%x\n",
			    etype & 0xff, l->llc_dsap & 0xff, l->llc_ssap &0xff,
			    l->llc_control & 0xff);

		}
#endif /* LLC_DEBUG */
		}
		break;
#endif /* LLC */
a495 25
#ifdef LLC
	case LLC_X25_LSAP:
	{
/*
 * XXX check for source routing info ? (sizeof(struct sdl_hdr) and
 * ISO88025_ADDR_LEN)
 */
		M_PREPEND(m, sizeof(struct sdl_hdr) , M_DONTWAIT);
		if (m == 0)
			return;
		if (!sdl_sethdrif(ifp, trh->token_shost, LLC_X25_LSAP,
				    trh->token_dhost, LLC_X25_LSAP,
				    ISO88025_ADDR_LEN,
				    mtod(m, struct sdl_hdr *)))
			panic("ETHER cons addr failure");
		mtod(m, struct sdl_hdr *)->sdlhdr_len =
		    m->m_pkthdr.len - sizeof(struct sdl_hdr);
#ifdef LLC_DEBUG
		printf("llc packet\n");
#endif /* LLC_DEBUG */
		schednetisr(NETISR_CCITT);
		inq = &llcintrq;
		break;
	}
#endif /* LLC */
@


1.17
log
@Make it possible for carp to work on fddi and token ring again.

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.16 2004/07/16 15:01:09 henning Exp $	*/
d412 1
d414 3
a416 4
	if (ifp->if_carp) {
		error = carp_fix_lladdr(ifp0, m, dst, NULL);
		if (error)
			goto bad;
a418 1

@


1.16
log
@remove netiso shitz, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.15 2004/06/21 23:50:36 tholo Exp $	*/
d78 5
d130 2
a131 2
token_output(ifp, m0, dst, rt0)
	struct ifnet *ifp;
d144 1
a144 1
	struct arpcom *ac = (struct arpcom *)ifp;
d150 20
d412 8
d435 4
d507 8
@


1.15
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.14 2004/04/17 00:09:01 henning Exp $	*/
a75 7
#ifdef ISO
#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#endif

a273 46
#ifdef	ISO
	case AF_ISO: {
		int	snpalen;
		struct	llc *l;
		struct sockaddr_dl *sdl;

		if (rt && (sdl = (struct sockaddr_dl *)rt->rt_gateway) &&
		    sdl->sdl_family == AF_LINK && sdl->sdl_alen > 0) {
			bcopy(LLADDR(sdl), (caddr_t)edst, sizeof(edst));
		}
		else if ((error =
			    iso_snparesolve(ifp, (struct sockaddr_iso *)dst,
					    (char *)edst, &snpalen)))
			goto bad; /* Not resolved */
		/* If broadcasting on a simplex interface, loopback a copy. */
		if (*edst & 1)
			m->m_flags |= (M_BCAST|M_MCAST);
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    (mcopy = m_copy(m, 0, (int)M_COPYALL))) {
			M_PREPEND(mcopy, sizeof (*trh), M_DONTWAIT);
			if (mcopy) {
				trh = mtod(mcopy, struct token_header *);
				bcopy((caddr_t)edst,
				    (caddr_t)trh->token_dhost, sizeof (edst));
				bcopy(LLADDR(ifp->if_sadl),
				    (caddr_t)trh->token_shost, sizeof (edst));
			}
		}
		M_PREPEND(m, 3, M_DONTWAIT);
		if (m == NULL)
			return (0);
		etype = 0;
		l = mtod(m, struct llc *);
		l->llc_dsap = l->llc_ssap = LLC_ISO_LSAP;
		l->llc_control = LLC_UI;
#if defined(__FreeBSD__)
		IFDEBUG(D_ETHER)
			int i;
			printf("token_output: sending pkt to: ");
			for (i=0; i < ISO88025_ADDR_LEN; i++)
				printf("%x ", edst[i] & 0xff);
			printf("\n");
		ENDDEBUG
#endif
		} break;
#endif /* ISO */
a503 68
#ifdef	ISO
	case LLC_ISO_LSAP:
		switch (l->llc_control) {
		case LLC_UI:
			/* LLC_UI_P forbidden in class 1 service */
			if ((l->llc_dsap == LLC_ISO_LSAP) &&
			    (l->llc_ssap == LLC_ISO_LSAP)) {
				/* LSAP for ISO */
				m->m_data += 3;		/* XXX */
				m->m_len -= 3;		/* XXX */
				m->m_pkthdr.len -= 3;	/* XXX */
				M_PREPEND(m, sizeof *trh, M_DONTWAIT);
				if (m == 0)
					return;
				*mtod(m, struct token_header *) = *trh;
#if defined(__FreeBSD__)
				IFDEBUG(D_ETHER)
					printf("clnp packet");
				ENDDEBUG
#endif
				schednetisr(NETISR_ISO);
				inq = &clnlintrq;
				break;
			}
			goto dropanyway;

		case LLC_XID:
		case LLC_XID_P:
			if(m->m_len < ISO88025_ADDR_LEN)
				goto dropanyway;
			l->llc_window = 0;
			l->llc_fid = 9;
			l->llc_class = 1;
			l->llc_dsap = l->llc_ssap = 0;
			/* Fall through to */
		case LLC_TEST:
		case LLC_TEST_P:
		{
			struct sockaddr sa;
			struct ether_header *eh;
			int i;
			u_char c = l->llc_dsap;

			l->llc_dsap = l->llc_ssap;
			l->llc_ssap = c;
			if (m->m_flags & (M_BCAST | M_MCAST))
				bcopy(LLADDR(ifp->if_sadl),
				    (caddr_t)trh->token_dhost,
				    ISO88025_ADDR_LEN);
			sa.sa_family = AF_UNSPEC;
			sa.sa_len = sizeof(sa);
			eh = (struct ether_header *)sa.sa_data;
			for (i = 0; i < ISO88025_ADDR_LEN; i++) {
				eh->ether_shost[i] = c = trh->token_dhost[i];
				eh->ether_dhost[i] =
				    eh->ether_dhost[i] = trh->token_shost[i];
				eh->ether_shost[i] = c;
			}
			eh->ether_type = 0;
			ifp->if_output(ifp, m, &sa, NULL);
			return;
		}
		default:
			m_freem(m);
			return;
		}
		break;
#endif /* ISO */
@


1.14
log
@add a congestion indicator to if_queue. It is set when the input queue
is full, along with a timer that unsets it again after 10ms.
The input queue beeing full is a reliable indicator for CPU overload, and
this flag allows other subsystems to cope with the situation.
hacked with beck
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.13 2003/12/10 07:22:42 itojun Exp $	*/
d174 1
a174 1
			    time.tv_sec < rt->rt_rmx.rmx_expire)
@


1.13
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.12 2003/08/18 11:01:41 dhartmei Exp $	*/
d660 1
a660 6
	if (IF_QFULL(inq)) {
		IF_DROP(inq);
		m_freem(m);
	}
	else
		IF_ENQUEUE(inq, m);
@


1.12
log
@prevent looutput() feedback of broadcast/multicast packets if they are
pf routed. prevents a kernel lockup with some (non-sensical) route-to
rules. report and debugging by mpech@@. ok itojun@@, henning@@, mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.11 2003/06/02 23:28:12 millert Exp $	*/
d133 1
a133 1
	register struct ifnet *ifp;
d141 2
a142 2
	register struct mbuf *m = m0;
	register struct rtentry *rt;
d285 1
a285 1
		register struct sockaddr_dl *sdl;
d330 1
a330 1
		register struct sockaddr_dl *sdl =
d356 1
a356 1
			register struct llc *l = mtod(m, struct llc *);
d402 1
a402 1
		register struct llc *l;
d478 2
a479 2
	register struct ifqueue *inq;
	register struct llc *l;
d596 1
a596 1
			register struct ether_header *eh;
d674 1
a674 1
	register struct ifnet *ifp;
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.10 2003/05/01 06:13:00 itojun Exp $	*/
d204 2
a205 1
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX))
@


1.10
log
@use "tokenbroadcastaddr" throughout the code for consistency.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.9 2003/01/07 09:00:33 kjc Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.8 2002/07/18 03:26:59 mickey Exp $	*/
d195 1
a195 1
			bcopy((caddr_t)etherbroadcastaddr, (caddr_t)edst,
d241 1
a241 1
			bcopy((caddr_t)etherbroadcastaddr, (caddr_t)edst,
@


1.8
log
@make it compile by removing unused local vars
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.7 2002/06/30 13:04:36 itojun Exp $	*/
a154 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a181 6
	/*
	 * If the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d451 1
a451 1
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
@


1.7
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.6 2002/03/14 01:27:09 millert Exp $	*/
a685 3
	register struct ifaddr *ifa;
	register struct sockaddr_dl *sdl;

@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.5 2001/12/09 13:09:13 jason Exp $	*/
d697 3
a699 10
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
		    sdl->sdl_family == AF_LINK) {
			sdl->sdl_type = IFT_ISO88025;
			sdl->sdl_alen = ifp->if_addrlen;
			bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			    LLADDR(sdl), ifp->if_addrlen);
			break;
		}
	}
@


1.5
log
@Use queue.h TAILQ macros instead of accessing members directly.
(And convert a few loops to TAILQ_FOREACH).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.4 2001/06/27 06:07:45 kjc Exp $	*/
d126 2
a127 2
int	token_output __P((struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *)); 
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.5 2001/12/09 13:09:13 jason Exp $	*/
d126 2
a127 2
int	token_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *); 
@


1.5.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.5.2.1 2002/06/11 03:30:45 art Exp $	*/
d686 3
d697 10
a706 3
	if_alloc_sadl(ifp);
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	    LLADDR(ifp->if_sadl), ifp->if_addrlen);
@


1.5.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d155 1
d183 6
d202 1
a202 1
			bcopy((caddr_t)tokenbroadcastaddr, (caddr_t)edst,
d248 1
a248 1
			bcopy((caddr_t)tokenbroadcastaddr, (caddr_t)edst,
d458 1
a458 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
@


1.4
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.3 2001/06/15 03:38:34 itojun Exp $	*/
d697 1
a697 2
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	    ifa = ifa->ifa_list.tqe_next)
d706 1
@


1.3
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.2 2000/01/21 13:44:27 fgsch Exp $	*/
d143 1
a143 1
	int s, error = 0;
d155 2
d182 7
d451 2
d458 3
a460 2
	if (IF_QFULL(&ifp->if_snd)) {
		IF_DROP(&ifp->if_snd);
d462 1
a462 1
		senderr(ENOBUFS);
d464 3
a466 2
	ifp->if_obytes += m->m_pkthdr.len;
	IF_ENQUEUE(&ifp->if_snd, m);
a469 2
	if (m->m_flags & M_MCAST)
		ifp->if_omcasts++;
@


1.2
log
@Make token_output not static.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.1 1999/12/27 21:47:23 fgsch Exp $	*/
a157 1
	ifp->if_lastchange = time;
a488 1
	ifp->if_lastchange = time;
@


1.2.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.2 2000/01/21 13:44:27 fgsch Exp $	*/
d143 1
a143 1
	int s, len, error = 0;
a154 2
	ALTQ_DECL(struct altq_pktattr pktattr;)
	short mflags;
d158 1
a180 7

	/*
	 * If the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

a442 2
	mflags = m->m_flags;
	len = m->m_pkthdr.len;
d448 2
a449 3
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		/* mbuf is already freed */
d451 1
a451 1
		return (error);
d453 2
a454 3
	ifp->if_obytes += len;
	if (mflags & M_MCAST)
		ifp->if_omcasts++;
d458 2
d490 1
@


1.2.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d697 2
a698 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
a706 1
	}
@


1.2.2.3
log
@Merge in -current from roughly a week ago
@
text
@d126 2
a127 2
int	token_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	struct rtentry *); 
@


1.2.2.4
log
@Sync the SMP branch with 3.3
@
text
@d155 1
d183 6
d458 1
a458 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
d686 3
d697 10
a706 3
	if_alloc_sadl(ifp);
	bcopy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
	    LLADDR(ifp->if_sadl), ifp->if_addrlen);
@


1.2.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.2.2.4 2003/03/28 00:41:28 niklas Exp $	*/
d195 1
a195 1
			bcopy((caddr_t)tokenbroadcastaddr, (caddr_t)edst,
d241 1
a241 1
			bcopy((caddr_t)tokenbroadcastaddr, (caddr_t)edst,
@


1.2.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tokensubr.c,v 1.2.2.5 2003/05/13 19:36:15 ho Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 1
a133 1
	struct ifnet *ifp;
d141 2
a142 2
	struct mbuf *m = m0;
	struct rtentry *rt;
d204 1
a204 2
		if ((m->m_flags & M_BCAST) && (ifp->if_flags & IFF_SIMPLEX) &&
		    m_tag_find(m, PACKET_TAG_PF_ROUTED, NULL) == NULL)
d284 1
a284 1
		struct sockaddr_dl *sdl;
d329 1
a329 1
		struct sockaddr_dl *sdl =
d355 1
a355 1
			struct llc *l = mtod(m, struct llc *);
d401 1
a401 1
		struct llc *l;
d477 2
a478 2
	struct ifqueue *inq;
	struct llc *l;
d595 1
a595 1
			struct ether_header *eh;
d673 1
a673 1
	struct ifnet *ifp;
@


1.2.2.8
log
@Merge with the trunk
@
text
@d660 6
a665 1
	IF_INPUT_ENQUEUE(inq, m);
@


1.1
log
@Token ring subroutines. For details see next commit.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 2
a127 2
static	int token_output __P((struct ifnet *, struct mbuf *,
	    struct sockaddr *, struct rtentry *)); 
d135 1
a135 1
static int
@

