head	1.65;
access;
symbols
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.62.0.6
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.42.0.2
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.36.0.8
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.4
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.26.0.4
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2;
locks; strict;
comment	@ * @;


1.65
date	2017.05.16.12.24.01;	author mpi;	state Exp;
branches;
next	1.64;
commitid	SAe3SQ48vKH6r5FL;

1.64
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.63;
commitid	6c6qq5OdS4VVnyVM;

1.63
date	2016.09.20.12.14.49;	author bluhm;	state Exp;
branches;
next	1.62;
commitid	cbAxlibllOTTvpU0;

1.62
date	2015.11.07.12.37.18;	author mpi;	state Exp;
branches;
next	1.61;
commitid	pimjpVkDm7QHrGoX;

1.61
date	2015.11.02.14.35.12;	author reyk;	state Exp;
branches;
next	1.60;
commitid	j9YM93HAjqViMl2H;

1.60
date	2015.09.29.10.11.40;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	L3Bwt4zBOCs33Zbo;

1.59
date	2015.07.17.18.15.41;	author mpi;	state Exp;
branches;
next	1.58;
commitid	3IgG0LoTLeHVR6fM;

1.58
date	2015.07.15.22.16.41;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	ncpqEGjDtSFuLAgn;

1.57
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.56;
commitid	fE8TgA9vpwdUU5Wy;

1.56
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.55;
commitid	h7z8lokZ0dFyuWpg;

1.55
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.54;
commitid	1aiWjheMGhmTuiHL;

1.54
date	2015.05.12.12.35.10;	author mpi;	state Exp;
branches;
next	1.53;
commitid	lfBofUNmSp0LArg2;

1.53
date	2015.05.04.10.24.08;	author mpi;	state Exp;
branches;
next	1.52;
commitid	pcqNjYq7eK2oXz3l;

1.52
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.51;
commitid	p4LJxGKbi0BU2cG6;

1.51
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.50;
commitid	zhW8jJrfVCoAthrR;

1.50
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.49;
commitid	ZqXwxwmeo3l29NOg;

1.49
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.48;
commitid	DQakU8LLWV6Iwx84;

1.48
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.47;
commitid	B4dZSbxas1X1IpXI;

1.47
date	2014.04.19.15.54.39;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.20.08.48.39;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2013.10.17.16.27.40;	author bluhm;	state Exp;
branches;
next	1.44;

1.44
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.41;

1.41
date	2012.09.20.14.10.18;	author mpf;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.09.04.53.33;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2010.11.20.14.23.09;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2010.10.31.15.14.30;	author mpf;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.28.13.49.54;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.07.18.09.22;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.14.19.13.42;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.13.19.08.19;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.21.21.10.50;	author mk;	state Exp;
branches;
next	1.31;

1.31
date	2008.05.07.13.45.35;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.30.09.04.47;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.14.12.27.35;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.15.12.43.26;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.11.22.11.48;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.03.13.41.19;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.24.11.50.32;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.07.18.21.10;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.12.15.17.18;	author markus;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2005.06.07.17.53.44;	author deraadt;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2005.06.07.17.42.58;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.16.20.30.07;	author avsm;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.18.42.56;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.10.13.22.55;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.09.18.56.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.09.10.11.52;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.04.15.44.21;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.26.17.34.43;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.24.19.52.20;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.27.06.07.37;	author kjc;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.05.30.02.12.23;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.22.03.48.29;	author jason;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.01.30.04.22.23;	author kjell;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.17.04.47.18;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.18.03.38.56;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.12.03.41.22;	author jason;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.39.59;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.53.52;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2003.05.19.22.29.06;	author tedu;	state Exp;
branches;
next	;

1.18.2.1
date	2006.05.10.20.15.30;	author brad;	state Exp;
branches;
next	;

1.19.2.1
date	2006.05.10.19.59.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@/*	$OpenBSD: bridgestp.c,v 1.64 2017/01/24 10:08:30 krw Exp $	*/

/*
 * Copyright (c) 2000 Jason L. Wright (jason@@thought.net)
 * Copyright (c) 2006 Andrew Thompson (thompsa@@FreeBSD.org)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Implementation of the spanning tree protocol as defined in
 * ISO/IEC 802.1D-2004, June 9, 2004.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/if_llc.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>

#include <net/if_bridge.h>

/* STP port states */
#define	BSTP_IFSTATE_DISABLED	0
#define	BSTP_IFSTATE_LISTENING	1
#define	BSTP_IFSTATE_LEARNING	2
#define	BSTP_IFSTATE_FORWARDING	3
#define	BSTP_IFSTATE_BLOCKING	4
#define	BSTP_IFSTATE_DISCARDING	5

#define	BSTP_TCSTATE_ACTIVE	1
#define	BSTP_TCSTATE_DETECTED	2
#define	BSTP_TCSTATE_INACTIVE	3
#define	BSTP_TCSTATE_LEARNING	4
#define	BSTP_TCSTATE_PROPAG	5
#define	BSTP_TCSTATE_ACK	6
#define	BSTP_TCSTATE_TC		7
#define	BSTP_TCSTATE_TCN	8

#define	BSTP_ROLE_DISABLED	0
#define	BSTP_ROLE_ROOT		1
#define	BSTP_ROLE_DESIGNATED	2
#define	BSTP_ROLE_ALTERNATE	3
#define	BSTP_ROLE_BACKUP	4

/* STP port flags */
#define	BSTP_PORT_CANMIGRATE	0x0001
#define	BSTP_PORT_NEWINFO	0x0002
#define	BSTP_PORT_DISPUTED	0x0004
#define	BSTP_PORT_ADMCOST	0x0008
#define	BSTP_PORT_AUTOEDGE	0x0010

/* BPDU priority */
#define	BSTP_PDU_SUPERIOR	1
#define	BSTP_PDU_REPEATED	2
#define	BSTP_PDU_INFERIOR	3
#define	BSTP_PDU_INFERIORALT	4
#define	BSTP_PDU_OTHER		5

/* BPDU flags */
#define	BSTP_PDU_PRMASK		0x0c		/* Port Role */
#define	BSTP_PDU_PRSHIFT	2		/* Port Role offset */
#define	BSTP_PDU_F_UNKN		0x00		/* Unknown port    (00) */
#define	BSTP_PDU_F_ALT		0x01		/* Alt/Backup port (01) */
#define	BSTP_PDU_F_ROOT		0x02		/* Root port       (10) */
#define	BSTP_PDU_F_DESG		0x03		/* Designated port (11) */

#define	BSTP_PDU_STPMASK	0x81		/* strip unused STP flags */
#define	BSTP_PDU_RSTPMASK	0x7f		/* strip unused RSTP flags */
#define	BSTP_PDU_F_TC		0x01		/* Topology change */
#define	BSTP_PDU_F_P		0x02		/* Proposal flag */
#define	BSTP_PDU_F_L		0x10		/* Learning flag */
#define	BSTP_PDU_F_F		0x20		/* Forwarding flag */
#define	BSTP_PDU_F_A		0x40		/* Agreement flag */
#define	BSTP_PDU_F_TCA		0x80		/* Topology change ack */

/*
 * Spanning tree defaults.
 */
#define	BSTP_DEFAULT_MAX_AGE		(20 * 256)
#define	BSTP_DEFAULT_HELLO_TIME		(2 * 256)
#define	BSTP_DEFAULT_FORWARD_DELAY	(15 * 256)
#define	BSTP_DEFAULT_HOLD_TIME		(1 * 256)
#define	BSTP_DEFAULT_MIGRATE_DELAY	(3 * 256)
#define	BSTP_DEFAULT_HOLD_COUNT		6
#define	BSTP_DEFAULT_BRIDGE_PRIORITY	0x8000
#define	BSTP_DEFAULT_PORT_PRIORITY	0x80
#define	BSTP_DEFAULT_PATH_COST		55
#define	BSTP_MIN_HELLO_TIME		(1 * 256)
#define	BSTP_MIN_MAX_AGE		(6 * 256)
#define	BSTP_MIN_FORWARD_DELAY		(4 * 256)
#define	BSTP_MIN_HOLD_COUNT		1
#define	BSTP_MAX_HELLO_TIME		(2 * 256)
#define	BSTP_MAX_MAX_AGE		(40 * 256)
#define	BSTP_MAX_FORWARD_DELAY		(30 * 256)
#define	BSTP_MAX_HOLD_COUNT		10
#define	BSTP_MAX_PRIORITY		61440
#define	BSTP_MAX_PORT_PRIORITY		240
#define	BSTP_MAX_PATH_COST		200000000

/* BPDU message types */
#define	BSTP_MSGTYPE_CFG	0x00		/* Configuration */
#define	BSTP_MSGTYPE_RSTP	0x02		/* Rapid STP */
#define	BSTP_MSGTYPE_TCN	0x80		/* Topology chg notification */

#define	BSTP_INFO_RECEIVED	1
#define	BSTP_INFO_MINE		2
#define	BSTP_INFO_AGED		3
#define	BSTP_INFO_DISABLED	4

#define	BSTP_MESSAGE_AGE_INCR	(1 * 256)	/* in 256ths of a second */
#define	BSTP_TICK_VAL		(1 * 256)	/* in 256ths of a second */
#define	BSTP_LINK_TIMER		(BSTP_TICK_VAL * 15)

#ifdef	BRIDGESTP_DEBUG
#define	DPRINTF(fmt, arg...)	printf("bstp: " fmt, ##arg)
#else
#define	DPRINTF(fmt, arg...)
#endif

#define	PV2ADDR(pv, eaddr)	do {		\
	eaddr[0] = pv >> 40;			\
	eaddr[1] = pv >> 32;			\
	eaddr[2] = pv >> 24;			\
	eaddr[3] = pv >> 16;			\
	eaddr[4] = pv >> 8;			\
	eaddr[5] = pv >> 0;			\
} while (0)

#define	INFO_BETTER	1
#define	INFO_SAME	0
#define	INFO_WORSE	-1

#define	BSTP_IFQ_PRIO	6

/*
 * Because BPDU's do not make nicely aligned structures, two different
 * declarations are used: bstp_?bpdu (wire representation, packed) and
 * bstp_*_unit (internal, nicely aligned version).
 */

/* configuration bridge protocol data unit */
struct bstp_cbpdu {
	u_int8_t	cbu_dsap;		/* LLC: destination sap */
	u_int8_t	cbu_ssap;		/* LLC: source sap */
	u_int8_t	cbu_ctl;		/* LLC: control */
	u_int16_t	cbu_protoid;		/* protocol id */
	u_int8_t	cbu_protover;		/* protocol version */
	u_int8_t	cbu_bpdutype;		/* message type */
	u_int8_t	cbu_flags;		/* flags (below) */

	/* root id */
	u_int16_t	cbu_rootpri;		/* root priority */
	u_int8_t	cbu_rootaddr[6];	/* root address */

	u_int32_t	cbu_rootpathcost;	/* root path cost */

	/* bridge id */
	u_int16_t	cbu_bridgepri;		/* bridge priority */
	u_int8_t	cbu_bridgeaddr[6];	/* bridge address */

	u_int16_t	cbu_portid;		/* port id */
	u_int16_t	cbu_messageage;		/* current message age */
	u_int16_t	cbu_maxage;		/* maximum age */
	u_int16_t	cbu_hellotime;		/* hello time */
	u_int16_t	cbu_forwarddelay;	/* forwarding delay */
	u_int8_t	cbu_versionlen;		/* version 1 length */
} __packed;

#define	BSTP_BPDU_STP_LEN	(3 + 35)	/* LLC + STP pdu */
#define	BSTP_BPDU_RSTP_LEN	(3 + 36)	/* LLC + RSTP pdu */

/* topology change notification bridge protocol data unit */
struct bstp_tbpdu {
	u_int8_t	tbu_dsap;		/* LLC: destination sap */
	u_int8_t	tbu_ssap;		/* LLC: source sap */
	u_int8_t	tbu_ctl;		/* LLC: control */
	u_int16_t	tbu_protoid;		/* protocol id */
	u_int8_t	tbu_protover;		/* protocol version */
	u_int8_t	tbu_bpdutype;		/* message type */
} __packed;

const u_int8_t bstp_etheraddr[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };


void	bstp_transmit(struct bstp_state *, struct bstp_port *);
void	bstp_transmit_bpdu(struct bstp_state *, struct bstp_port *);
void	bstp_transmit_tcn(struct bstp_state *, struct bstp_port *);
void	bstp_decode_bpdu(struct bstp_port *, struct bstp_cbpdu *,
	    struct bstp_config_unit *);
void	bstp_send_bpdu(struct bstp_state *, struct bstp_port *,
	    struct bstp_cbpdu *);
int	bstp_pdu_flags(struct bstp_port *);
void	bstp_received_stp(struct bstp_state *, struct bstp_port *,
	    struct mbuf **, struct bstp_tbpdu *);
void	bstp_received_rstp(struct bstp_state *, struct bstp_port *,
	    struct mbuf **, struct bstp_tbpdu *);
void	bstp_received_tcn(struct bstp_state *, struct bstp_port *,
	    struct bstp_tcn_unit *);
void	bstp_received_bpdu(struct bstp_state *, struct bstp_port *,
	    struct bstp_config_unit *);
int	bstp_pdu_rcvtype(struct bstp_port *, struct bstp_config_unit *);
int	bstp_pdu_bettersame(struct bstp_port *, int);
int	bstp_info_cmp(struct bstp_pri_vector *,
	    struct bstp_pri_vector *);
int	bstp_info_superior(struct bstp_pri_vector *,
	    struct bstp_pri_vector *);
void	bstp_assign_roles(struct bstp_state *);
void	bstp_update_roles(struct bstp_state *, struct bstp_port *);
void	bstp_update_state(struct bstp_state *, struct bstp_port *);
void	bstp_update_tc(struct bstp_port *);
void	bstp_update_info(struct bstp_port *);
void	bstp_set_other_tcprop(struct bstp_port *);
void	bstp_set_all_reroot(struct bstp_state *);
void	bstp_set_all_sync(struct bstp_state *);
void	bstp_set_port_state(struct bstp_port *, int);
void	bstp_set_port_role(struct bstp_port *, int);
void	bstp_set_port_proto(struct bstp_port *, int);
void	bstp_set_port_tc(struct bstp_port *, int);
void	bstp_set_timer_tc(struct bstp_port *);
void	bstp_set_timer_msgage(struct bstp_port *);
int	bstp_rerooted(struct bstp_state *, struct bstp_port *);
u_int32_t	bstp_calc_path_cost(struct bstp_port *);
void	bstp_notify_rtage(struct bstp_port *, int);
void	bstp_ifupdstatus(struct bstp_state *, struct bstp_port *);
void	bstp_enable_port(struct bstp_state *, struct bstp_port *);
void	bstp_disable_port(struct bstp_state *, struct bstp_port *);
void	bstp_tick(void *);
void	bstp_timer_start(struct bstp_timer *, u_int16_t);
void	bstp_timer_stop(struct bstp_timer *);
void	bstp_timer_latch(struct bstp_timer *);
int	bstp_timer_expired(struct bstp_timer *);
void	bstp_hello_timer_expiry(struct bstp_state *,
		    struct bstp_port *);
void	bstp_message_age_expiry(struct bstp_state *,
		    struct bstp_port *);
void	bstp_migrate_delay_expiry(struct bstp_state *,
		    struct bstp_port *);
void	bstp_edge_delay_expiry(struct bstp_state *,
		    struct bstp_port *);
int	bstp_addr_cmp(const u_int8_t *, const u_int8_t *);
int	bstp_same_bridgeid(u_int64_t, u_int64_t);


void
bstp_transmit(struct bstp_state *bs, struct bstp_port *bp)
{
	if ((bs->bs_ifflags & IFF_RUNNING) == 0 || bp == NULL)
		return;

	/*
	 * a PDU can only be sent if we have tx quota left and the
	 * hello timer is running.
	 */
	if (bp->bp_hello_timer.active == 0) {
		/* Test if it needs to be reset */
		bstp_hello_timer_expiry(bs, bp);
		return;
	}
	if (bp->bp_txcount > bs->bs_txholdcount)
		/* Ran out of karma */
		return;

	if (bp->bp_protover == BSTP_PROTO_RSTP) {
		bstp_transmit_bpdu(bs, bp);
		bp->bp_tc_ack = 0;
	} else { /* STP */
		switch (bp->bp_role) {
		case BSTP_ROLE_DESIGNATED:
			bstp_transmit_bpdu(bs, bp);
			bp->bp_tc_ack = 0;
			break;

		case BSTP_ROLE_ROOT:
			bstp_transmit_tcn(bs, bp);
			break;
		}
	}
	bstp_timer_start(&bp->bp_hello_timer, bp->bp_desg_htime);
	bp->bp_flags &= ~BSTP_PORT_NEWINFO;
}

void
bstp_transmit_bpdu(struct bstp_state *bs, struct bstp_port *bp)
{
	struct bstp_cbpdu bpdu;

	bpdu.cbu_rootpri = htons(bp->bp_desg_pv.pv_root_id >> 48);
	PV2ADDR(bp->bp_desg_pv.pv_root_id, bpdu.cbu_rootaddr);

	bpdu.cbu_rootpathcost = htonl(bp->bp_desg_pv.pv_cost);

	bpdu.cbu_bridgepri = htons(bp->bp_desg_pv.pv_dbridge_id >> 48);
	PV2ADDR(bp->bp_desg_pv.pv_dbridge_id, bpdu.cbu_bridgeaddr);

	bpdu.cbu_portid = htons(bp->bp_port_id);
	bpdu.cbu_messageage = htons(bp->bp_desg_msg_age);
	bpdu.cbu_maxage = htons(bp->bp_desg_max_age);
	bpdu.cbu_hellotime = htons(bp->bp_desg_htime);
	bpdu.cbu_forwarddelay = htons(bp->bp_desg_fdelay);

	bpdu.cbu_flags = bstp_pdu_flags(bp);

	switch (bp->bp_protover) {
	case BSTP_PROTO_STP:
		bpdu.cbu_bpdutype = BSTP_MSGTYPE_CFG;
		break;
	case BSTP_PROTO_RSTP:
		bpdu.cbu_bpdutype = BSTP_MSGTYPE_RSTP;
		break;
	}

	bstp_send_bpdu(bs, bp, &bpdu);
}

void
bstp_transmit_tcn(struct bstp_state *bs, struct bstp_port *bp)
{
	struct bstp_tbpdu bpdu;
	struct ifnet *ifp = bp->bp_ifp;
	struct ether_header *eh;
	struct mbuf *m;

	if (ifp == NULL || (ifp->if_flags & IFF_RUNNING) == 0)
		return;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return;
	m->m_pkthdr.ph_ifidx = ifp->if_index;
	m->m_pkthdr.len = sizeof(*eh) + sizeof(bpdu);
	m->m_pkthdr.pf.prio = BSTP_IFQ_PRIO;
	m->m_len = m->m_pkthdr.len;

	eh = mtod(m, struct ether_header *);
	bcopy(LLADDR(ifp->if_sadl), eh->ether_shost, ETHER_ADDR_LEN);
	bcopy(bstp_etheraddr, eh->ether_dhost, ETHER_ADDR_LEN);
	eh->ether_type = htons(sizeof(bpdu));

	bpdu.tbu_ssap = bpdu.tbu_dsap = LLC_8021D_LSAP;
	bpdu.tbu_ctl = LLC_UI;
	bpdu.tbu_protoid = 0;
	bpdu.tbu_protover = 0;
	bpdu.tbu_bpdutype = BSTP_MSGTYPE_TCN;
	bcopy(&bpdu, mtod(m, caddr_t) + sizeof(*eh), sizeof(bpdu));

	bp->bp_txcount++;
	if_enqueue(ifp, m);
}

void
bstp_decode_bpdu(struct bstp_port *bp, struct bstp_cbpdu *cpdu,
    struct bstp_config_unit *cu)
{
	int flags;

	cu->cu_pv.pv_root_id =
	    (((u_int64_t)ntohs(cpdu->cbu_rootpri)) << 48) |
	    (((u_int64_t)cpdu->cbu_rootaddr[0]) << 40) |
	    (((u_int64_t)cpdu->cbu_rootaddr[1]) << 32) |
	    (((u_int64_t)cpdu->cbu_rootaddr[2]) << 24) |
	    (((u_int64_t)cpdu->cbu_rootaddr[3]) << 16) |
	    (((u_int64_t)cpdu->cbu_rootaddr[4]) << 8) |
	    (((u_int64_t)cpdu->cbu_rootaddr[5]) << 0);

	cu->cu_pv.pv_dbridge_id =
	    (((u_int64_t)ntohs(cpdu->cbu_bridgepri)) << 48) |
	    (((u_int64_t)cpdu->cbu_bridgeaddr[0]) << 40) |
	    (((u_int64_t)cpdu->cbu_bridgeaddr[1]) << 32) |
	    (((u_int64_t)cpdu->cbu_bridgeaddr[2]) << 24) |
	    (((u_int64_t)cpdu->cbu_bridgeaddr[3]) << 16) |
	    (((u_int64_t)cpdu->cbu_bridgeaddr[4]) << 8) |
	    (((u_int64_t)cpdu->cbu_bridgeaddr[5]) << 0);

	cu->cu_pv.pv_cost = ntohl(cpdu->cbu_rootpathcost);
	cu->cu_message_age = ntohs(cpdu->cbu_messageage);
	cu->cu_max_age = ntohs(cpdu->cbu_maxage);
	cu->cu_hello_time = ntohs(cpdu->cbu_hellotime);
	cu->cu_forward_delay = ntohs(cpdu->cbu_forwarddelay);
	cu->cu_pv.pv_dport_id = ntohs(cpdu->cbu_portid);
	cu->cu_pv.pv_port_id = bp->bp_port_id;
	cu->cu_message_type = cpdu->cbu_bpdutype;

	/* Strip off unused flags in STP mode */
	flags = cpdu->cbu_flags;
	switch (cpdu->cbu_protover) {
	case BSTP_PROTO_STP:
		flags &= BSTP_PDU_STPMASK;
		/* A STP BPDU explicitly conveys a Designated Port */
		cu->cu_role = BSTP_ROLE_DESIGNATED;
		break;
	case BSTP_PROTO_RSTP:
		flags &= BSTP_PDU_RSTPMASK;
		break;
	}

	cu->cu_topology_change_ack =
		(flags & BSTP_PDU_F_TCA) ? 1 : 0;
	cu->cu_proposal =
		(flags & BSTP_PDU_F_P) ? 1 : 0;
	cu->cu_agree =
		(flags & BSTP_PDU_F_A) ? 1 : 0;
	cu->cu_learning =
		(flags & BSTP_PDU_F_L) ? 1 : 0;
	cu->cu_forwarding =
		(flags & BSTP_PDU_F_F) ? 1 : 0;
	cu->cu_topology_change =
		(flags & BSTP_PDU_F_TC) ? 1 : 0;

	switch ((flags & BSTP_PDU_PRMASK) >> BSTP_PDU_PRSHIFT) {
	case BSTP_PDU_F_ROOT:
		cu->cu_role = BSTP_ROLE_ROOT;
		break;
	case BSTP_PDU_F_ALT:
		cu->cu_role = BSTP_ROLE_ALTERNATE;
		break;
	case BSTP_PDU_F_DESG:
		cu->cu_role = BSTP_ROLE_DESIGNATED;
		break;
	}
}

void
bstp_send_bpdu(struct bstp_state *bs, struct bstp_port *bp,
    struct bstp_cbpdu *bpdu)
{
	struct ifnet *ifp = bp->bp_ifp;
	struct mbuf *m;
	struct ether_header *eh;
	int s;

	s = splnet();
	if (ifp == NULL || (ifp->if_flags & IFF_RUNNING) == 0)
		goto done;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		goto done;

	eh = mtod(m, struct ether_header *);

	bpdu->cbu_ssap = bpdu->cbu_dsap = LLC_8021D_LSAP;
	bpdu->cbu_ctl = LLC_UI;
	bpdu->cbu_protoid = htons(BSTP_PROTO_ID);

	memcpy(eh->ether_shost, LLADDR(ifp->if_sadl), ETHER_ADDR_LEN);
	memcpy(eh->ether_dhost, bstp_etheraddr, ETHER_ADDR_LEN);

	switch (bpdu->cbu_bpdutype) {
	case BSTP_MSGTYPE_CFG:
		bpdu->cbu_protover = BSTP_PROTO_STP;
		m->m_pkthdr.len = sizeof(*eh) + BSTP_BPDU_STP_LEN;
		eh->ether_type = htons(BSTP_BPDU_STP_LEN);
		memcpy(mtod(m, caddr_t) + sizeof(*eh), bpdu,
		    BSTP_BPDU_STP_LEN);
		break;
	case BSTP_MSGTYPE_RSTP:
		bpdu->cbu_protover = BSTP_PROTO_RSTP;
		bpdu->cbu_versionlen = htons(0);
		m->m_pkthdr.len = sizeof(*eh) + BSTP_BPDU_RSTP_LEN;
		eh->ether_type = htons(BSTP_BPDU_RSTP_LEN);
		memcpy(mtod(m, caddr_t) + sizeof(*eh), bpdu,
		    BSTP_BPDU_RSTP_LEN);
		break;
	default:
		panic("not implemented");
	}
	m->m_pkthdr.ph_ifidx = ifp->if_index;
	m->m_len = m->m_pkthdr.len;
	m->m_pkthdr.pf.prio = BSTP_IFQ_PRIO;

	bp->bp_txcount++;
	if_enqueue(ifp, m);
 done:
	splx(s);
}

int
bstp_pdu_flags(struct bstp_port *bp)
{
	int flags = 0;

	if (bp->bp_proposing && bp->bp_state != BSTP_IFSTATE_FORWARDING)
		flags |= BSTP_PDU_F_P;

	if (bp->bp_agree)
		flags |= BSTP_PDU_F_A;

	if (bp->bp_tc_timer.active)
		flags |= BSTP_PDU_F_TC;

	if (bp->bp_tc_ack)
		flags |= BSTP_PDU_F_TCA;

	switch (bp->bp_state) {
	case BSTP_IFSTATE_LEARNING:
		flags |= BSTP_PDU_F_L;
		break;
	case BSTP_IFSTATE_FORWARDING:
		flags |= (BSTP_PDU_F_L | BSTP_PDU_F_F);
		break;
	}

	switch (bp->bp_role) {
	case BSTP_ROLE_ROOT:
		flags |= (BSTP_PDU_F_ROOT << BSTP_PDU_PRSHIFT);
		break;
	case BSTP_ROLE_ALTERNATE:
	case BSTP_ROLE_BACKUP:
		flags |= (BSTP_PDU_F_ALT << BSTP_PDU_PRSHIFT);
		break;
	case BSTP_ROLE_DESIGNATED:
		flags |= (BSTP_PDU_F_DESG << BSTP_PDU_PRSHIFT);
		break;
	}

	/* Strip off unused flags in either mode */
	switch (bp->bp_protover) {
	case BSTP_PROTO_STP:
		flags &= BSTP_PDU_STPMASK;
		break;
	case BSTP_PROTO_RSTP:
		flags &= BSTP_PDU_RSTPMASK;
		break;
	}
	return (flags);
}

struct mbuf *
bstp_input(struct bstp_state *bs, struct bstp_port *bp,
    struct ether_header *eh, struct mbuf *m)
{
	struct bstp_tbpdu tpdu;
	u_int16_t len;

	if (bs == NULL || bp == NULL || bp->bp_active == 0)
		return (m);

	len = ntohs(eh->ether_type);
	if (len < sizeof(tpdu))
		goto out;

	m_adj(m, ETHER_HDR_LEN);

	if (m->m_pkthdr.len > len)
		m_adj(m, len - m->m_pkthdr.len);
	if ((m = m_pullup(m, sizeof(tpdu))) == NULL)
		goto out;
	bcopy(mtod(m, struct tpdu *), &tpdu, sizeof(tpdu));

	if (tpdu.tbu_dsap != LLC_8021D_LSAP ||
	    tpdu.tbu_ssap != LLC_8021D_LSAP ||
	    tpdu.tbu_ctl != LLC_UI)
		goto out;
	if (tpdu.tbu_protoid != BSTP_PROTO_ID)
		goto out;

	/*
	 * We can treat later versions of the PDU as the same as the maximum
	 * version we implement. All additional parameters/flags are ignored.
	 */
	if (tpdu.tbu_protover > BSTP_PROTO_MAX)
		tpdu.tbu_protover = BSTP_PROTO_MAX;

	if (tpdu.tbu_protover != bp->bp_protover) {
		/*
		 * Wait for the migration delay timer to expire before changing
		 * protocol version to avoid flip-flops.
		 */
		if (bp->bp_flags & BSTP_PORT_CANMIGRATE)
			bstp_set_port_proto(bp, tpdu.tbu_protover);
		else
			goto out;
	}

	/* Clear operedge upon receiving a PDU on the port */
	bp->bp_operedge = 0;
	bstp_timer_start(&bp->bp_edge_delay_timer,
	    BSTP_DEFAULT_MIGRATE_DELAY);

	switch (tpdu.tbu_protover) {
	case BSTP_PROTO_STP:
		bstp_received_stp(bs, bp, &m, &tpdu);
		break;
	case BSTP_PROTO_RSTP:
		bstp_received_rstp(bs, bp, &m, &tpdu);
		break;
	}
 out:
	m_freem(m);
	return (NULL);
}

void
bstp_received_stp(struct bstp_state *bs, struct bstp_port *bp,
    struct mbuf **mp, struct bstp_tbpdu *tpdu)
{
	struct bstp_cbpdu cpdu;
	struct bstp_config_unit *cu = &bp->bp_msg_cu;
	struct bstp_tcn_unit tu;

	switch (tpdu->tbu_bpdutype) {
	case BSTP_MSGTYPE_TCN:
		tu.tu_message_type = tpdu->tbu_bpdutype;
		bstp_received_tcn(bs, bp, &tu);
		break;
	case BSTP_MSGTYPE_CFG:
		if ((*mp)->m_len < BSTP_BPDU_STP_LEN &&
		    (*mp = m_pullup(*mp, BSTP_BPDU_STP_LEN)) == NULL)
			return;
		memcpy(&cpdu, mtod(*mp, caddr_t), BSTP_BPDU_STP_LEN);

		bstp_decode_bpdu(bp, &cpdu, cu);
		bstp_received_bpdu(bs, bp, cu);
		break;
	}
}

void
bstp_received_rstp(struct bstp_state *bs, struct bstp_port *bp,
    struct mbuf **mp, struct bstp_tbpdu *tpdu)
{
	struct bstp_cbpdu cpdu;
	struct bstp_config_unit *cu = &bp->bp_msg_cu;

	if (tpdu->tbu_bpdutype != BSTP_MSGTYPE_RSTP)
		return;

	if ((*mp)->m_len < BSTP_BPDU_RSTP_LEN &&
	    (*mp = m_pullup(*mp, BSTP_BPDU_RSTP_LEN)) == NULL)
		return;
	memcpy(&cpdu, mtod(*mp, caddr_t), BSTP_BPDU_RSTP_LEN);

	bstp_decode_bpdu(bp, &cpdu, cu);
	bstp_received_bpdu(bs, bp, cu);
}

void
bstp_received_tcn(struct bstp_state *bs, struct bstp_port *bp,
    struct bstp_tcn_unit *tcn)
{
	bp->bp_rcvdtcn = 1;
	bstp_update_tc(bp);
}

void
bstp_received_bpdu(struct bstp_state *bs, struct bstp_port *bp,
    struct bstp_config_unit *cu)
{
	int type;

	/* We need to have transitioned to INFO_MINE before proceeding */
	switch (bp->bp_infois) {
	case BSTP_INFO_DISABLED:
	case BSTP_INFO_AGED:
		return;
	}

	type = bstp_pdu_rcvtype(bp, cu);

	switch (type) {
	case BSTP_PDU_SUPERIOR:
		bs->bs_allsynced = 0;
		bp->bp_agreed = 0;
		bp->bp_proposing = 0;

		if (cu->cu_proposal && cu->cu_forwarding == 0)
			bp->bp_proposed = 1;
		if (cu->cu_topology_change)
			bp->bp_rcvdtc = 1;
		if (cu->cu_topology_change_ack)
			bp->bp_rcvdtca = 1;

		if (bp->bp_agree &&
		    !bstp_pdu_bettersame(bp, BSTP_INFO_RECEIVED))
			bp->bp_agree = 0;

		/* copy the received priority and timers to the port */
		bp->bp_port_pv = cu->cu_pv;
		bp->bp_port_msg_age = cu->cu_message_age;
		bp->bp_port_max_age = cu->cu_max_age;
		bp->bp_port_fdelay = cu->cu_forward_delay;
		bp->bp_port_htime =
		    (cu->cu_hello_time > BSTP_MIN_HELLO_TIME ?
		     cu->cu_hello_time : BSTP_MIN_HELLO_TIME);

		/* set expiry for the new info */
		bstp_set_timer_msgage(bp);

		bp->bp_infois = BSTP_INFO_RECEIVED;
		bstp_assign_roles(bs);
		break;

	case BSTP_PDU_REPEATED:
		if (cu->cu_proposal && cu->cu_forwarding == 0)
			bp->bp_proposed = 1;
		if (cu->cu_topology_change)
			bp->bp_rcvdtc = 1;
		if (cu->cu_topology_change_ack)
			bp->bp_rcvdtca = 1;

		/* rearm the age timer */
		bstp_set_timer_msgage(bp);
		break;

	case BSTP_PDU_INFERIOR:
		if (cu->cu_learning) {
			bp->bp_agreed = 1;
			bp->bp_proposing = 0;
		}
		break;

	case BSTP_PDU_INFERIORALT:
		/*
		 * only point to point links are allowed fast
		 * transitions to forwarding.
		 */
		if (cu->cu_agree && bp->bp_ptp_link) {
			bp->bp_agreed = 1;
			bp->bp_proposing = 0;
		} else
			bp->bp_agreed = 0;

		if (cu->cu_topology_change)
			bp->bp_rcvdtc = 1;
		if (cu->cu_topology_change_ack)
			bp->bp_rcvdtca = 1;
		break;

	case BSTP_PDU_OTHER:
		return;	/* do nothing */
	}

	/* update the state machines with the new data */
	bstp_update_state(bs, bp);
}

int
bstp_pdu_rcvtype(struct bstp_port *bp, struct bstp_config_unit *cu)
{
	int type;

	/* default return type */
	type = BSTP_PDU_OTHER;

	switch (cu->cu_role) {
	case BSTP_ROLE_DESIGNATED:
		if (bstp_info_superior(&bp->bp_port_pv, &cu->cu_pv))
			/* bpdu priority is superior */
			type = BSTP_PDU_SUPERIOR;
		else if (bstp_info_cmp(&bp->bp_port_pv, &cu->cu_pv) ==
		    INFO_SAME) {
			if (bp->bp_port_msg_age != cu->cu_message_age ||
			    bp->bp_port_max_age != cu->cu_max_age ||
			    bp->bp_port_fdelay != cu->cu_forward_delay ||
			    bp->bp_port_htime != cu->cu_hello_time)
				/* bpdu priority is equal and timers differ */
				type = BSTP_PDU_SUPERIOR;
			else
				/* bpdu is equal */
				type = BSTP_PDU_REPEATED;
		} else
			/* bpdu priority is worse */
			type = BSTP_PDU_INFERIOR;

		break;

	case BSTP_ROLE_ROOT:
	case BSTP_ROLE_ALTERNATE:
	case BSTP_ROLE_BACKUP:
		if (bstp_info_cmp(&bp->bp_port_pv, &cu->cu_pv) <= INFO_SAME)
			/*
			 * not a designated port and priority is the same or
			 * worse
			 */
			type = BSTP_PDU_INFERIORALT;
		break;
	}

	return (type);
}

int
bstp_pdu_bettersame(struct bstp_port *bp, int newinfo)
{
	if (newinfo == BSTP_INFO_RECEIVED &&
	    bp->bp_infois == BSTP_INFO_RECEIVED &&
	    bstp_info_cmp(&bp->bp_port_pv, &bp->bp_msg_cu.cu_pv) >= INFO_SAME)
		return (1);

	if (newinfo == BSTP_INFO_MINE &&
	    bp->bp_infois == BSTP_INFO_MINE &&
	    bstp_info_cmp(&bp->bp_port_pv, &bp->bp_desg_pv) >= INFO_SAME)
		return (1);

	return (0);
}

int
bstp_info_cmp(struct bstp_pri_vector *pv,
    struct bstp_pri_vector *cpv)
{
	if (cpv->pv_root_id < pv->pv_root_id)
		return (INFO_BETTER);
	if (cpv->pv_root_id > pv->pv_root_id)
		return (INFO_WORSE);

	if (cpv->pv_cost < pv->pv_cost)
		return (INFO_BETTER);
	if (cpv->pv_cost > pv->pv_cost)
		return (INFO_WORSE);

	if (cpv->pv_dbridge_id < pv->pv_dbridge_id)
		return (INFO_BETTER);
	if (cpv->pv_dbridge_id > pv->pv_dbridge_id)
		return (INFO_WORSE);

	if (cpv->pv_dport_id < pv->pv_dport_id)
		return (INFO_BETTER);
	if (cpv->pv_dport_id > pv->pv_dport_id)
		return (INFO_WORSE);

	return (INFO_SAME);
}

/*
 * This message priority vector is superior to the port priority vector and
 * will replace it if, and only if, the message priority vector is better than
 * the port priority vector, or the message has been transmitted from the same
 * designated bridge and designated port as the port priority vector.
 */
int
bstp_info_superior(struct bstp_pri_vector *pv,
    struct bstp_pri_vector *cpv)
{
	if (bstp_info_cmp(pv, cpv) == INFO_BETTER ||
	    (bstp_same_bridgeid(pv->pv_dbridge_id, cpv->pv_dbridge_id) &&
	    (cpv->pv_dport_id & 0xfff) == (pv->pv_dport_id & 0xfff)))
		return (1);
	return (0);
}

void
bstp_assign_roles(struct bstp_state *bs)
{
	struct bstp_port *bp, *rbp = NULL;
	struct bstp_pri_vector pv;

	/* default to our priority vector */
	bs->bs_root_pv = bs->bs_bridge_pv;
	bs->bs_root_msg_age = 0;
	bs->bs_root_max_age = bs->bs_bridge_max_age;
	bs->bs_root_fdelay = bs->bs_bridge_fdelay;
	bs->bs_root_htime = bs->bs_bridge_htime;
	bs->bs_root_port = NULL;

	/* check if any received info supersedes us */
	LIST_FOREACH(bp, &bs->bs_bplist, bp_next) {
		if (bp->bp_infois != BSTP_INFO_RECEIVED)
			continue;

		pv = bp->bp_port_pv;
		pv.pv_cost += bp->bp_path_cost;

		/*
		 * The root priority vector is the best of the set comprising
		 * the bridge priority vector plus all root path priority
		 * vectors whose bridge address is not equal to us.
		 */
		if (bstp_same_bridgeid(pv.pv_dbridge_id,
		    bs->bs_bridge_pv.pv_dbridge_id) == 0 &&
		    bstp_info_cmp(&bs->bs_root_pv, &pv) == INFO_BETTER) {
			/* the port vector replaces the root */
			bs->bs_root_pv = pv;
			bs->bs_root_msg_age = bp->bp_port_msg_age +
			    BSTP_MESSAGE_AGE_INCR;
			bs->bs_root_max_age = bp->bp_port_max_age;
			bs->bs_root_fdelay = bp->bp_port_fdelay;
			bs->bs_root_htime = bp->bp_port_htime;
			rbp = bp;
		}
	}

	LIST_FOREACH(bp, &bs->bs_bplist, bp_next) {
		/* calculate the port designated vector */
		bp->bp_desg_pv.pv_root_id = bs->bs_root_pv.pv_root_id;
		bp->bp_desg_pv.pv_cost = bs->bs_root_pv.pv_cost;
		bp->bp_desg_pv.pv_dbridge_id = bs->bs_bridge_pv.pv_dbridge_id;
		bp->bp_desg_pv.pv_dport_id = bp->bp_port_id;
		bp->bp_desg_pv.pv_port_id = bp->bp_port_id;

		/* calculate designated times */
		bp->bp_desg_msg_age = bs->bs_root_msg_age;
		bp->bp_desg_max_age = bs->bs_root_max_age;
		bp->bp_desg_fdelay = bs->bs_root_fdelay;
		bp->bp_desg_htime = bs->bs_bridge_htime;


		switch (bp->bp_infois) {
		case BSTP_INFO_DISABLED:
			bstp_set_port_role(bp, BSTP_ROLE_DISABLED);
			break;

		case BSTP_INFO_AGED:
			bstp_set_port_role(bp, BSTP_ROLE_DESIGNATED);
			bstp_update_info(bp);
			break;

		case BSTP_INFO_MINE:
			bstp_set_port_role(bp, BSTP_ROLE_DESIGNATED);
			/* update the port info if stale */
			if (bstp_info_cmp(&bp->bp_port_pv,
			    &bp->bp_desg_pv) != INFO_SAME ||
			    (rbp != NULL &&
			    (bp->bp_port_msg_age != rbp->bp_port_msg_age ||
			    bp->bp_port_max_age != rbp->bp_port_max_age ||
			    bp->bp_port_fdelay != rbp->bp_port_fdelay ||
			    bp->bp_port_htime != rbp->bp_port_htime)))
				bstp_update_info(bp);
			break;

		case BSTP_INFO_RECEIVED:
			if (bp == rbp) {
				/*
				 * root priority is derived from this
				 * port, make it the root port.
				 */
				bstp_set_port_role(bp, BSTP_ROLE_ROOT);
				bs->bs_root_port = bp;
			} else if (bstp_info_cmp(&bp->bp_port_pv,
				    &bp->bp_desg_pv) == INFO_BETTER) {
				/*
				 * the port priority is lower than the root
				 * port.
				 */
				bstp_set_port_role(bp, BSTP_ROLE_DESIGNATED);
				bstp_update_info(bp);
			} else {
				if (bstp_same_bridgeid(
				    bp->bp_port_pv.pv_dbridge_id,
				    bs->bs_bridge_pv.pv_dbridge_id)) {
					/*
					 * the designated bridge refers to
					 * another port on this bridge.
					 */
					bstp_set_port_role(bp,
					    BSTP_ROLE_BACKUP);
				} else {
					/*
					 * the port is an inferior path to the
					 * root bridge.
					 */
					bstp_set_port_role(bp,
					    BSTP_ROLE_ALTERNATE);
				}
			}
			break;
		}
	}
}

void
bstp_update_state(struct bstp_state *bs, struct bstp_port *bp)
{
	struct bstp_port *bp2;
	int synced;

	/* check if all the ports have synchronized again */
	if (!bs->bs_allsynced) {
		synced = 1;
		LIST_FOREACH(bp2, &bs->bs_bplist, bp_next) {
			if (!(bp2->bp_synced ||
			     bp2->bp_role == BSTP_ROLE_ROOT)) {
				synced = 0;
				break;
			}
		}
		bs->bs_allsynced = synced;
	}

	bstp_update_roles(bs, bp);
	bstp_update_tc(bp);
}

void
bstp_update_roles(struct bstp_state *bs, struct bstp_port *bp)
{
	switch (bp->bp_role) {
	case BSTP_ROLE_DISABLED:
		/* Clear any flags if set */
		if (bp->bp_sync || !bp->bp_synced || bp->bp_reroot) {
			bp->bp_sync = 0;
			bp->bp_synced = 1;
			bp->bp_reroot = 0;
		}
		break;

	case BSTP_ROLE_ALTERNATE:
	case BSTP_ROLE_BACKUP:
		if ((bs->bs_allsynced && !bp->bp_agree) ||
		    (bp->bp_proposed && bp->bp_agree)) {
			bp->bp_proposed = 0;
			bp->bp_agree = 1;
			bp->bp_flags |= BSTP_PORT_NEWINFO;
			DPRINTF("%s -> ALTERNATE_AGREED\n",
			    bp->bp_ifp->if_xname);
		}

		if (bp->bp_proposed && !bp->bp_agree) {
			bstp_set_all_sync(bs);
			bp->bp_proposed = 0;
			DPRINTF("%s -> ALTERNATE_PROPOSED\n",
			    bp->bp_ifp->if_xname);
		}

		/* Clear any flags if set */
		if (bp->bp_sync || !bp->bp_synced || bp->bp_reroot) {
			bp->bp_sync = 0;
			bp->bp_synced = 1;
			bp->bp_reroot = 0;
			DPRINTF("%s -> ALTERNATE_PORT\n", bp->bp_ifp->if_xname);
		}
		break;

	case BSTP_ROLE_ROOT:
		if (bp->bp_state != BSTP_IFSTATE_FORWARDING && !bp->bp_reroot) {
			bstp_set_all_reroot(bs);
			DPRINTF("%s -> ROOT_REROOT\n", bp->bp_ifp->if_xname);
		}

		if ((bs->bs_allsynced && !bp->bp_agree) ||
		    (bp->bp_proposed && bp->bp_agree)) {
			bp->bp_proposed = 0;
			bp->bp_sync = 0;
			bp->bp_agree = 1;
			bp->bp_flags |= BSTP_PORT_NEWINFO;
			DPRINTF("%s -> ROOT_AGREED\n", bp->bp_ifp->if_xname);
		}

		if (bp->bp_proposed && !bp->bp_agree) {
			bstp_set_all_sync(bs);
			bp->bp_proposed = 0;
			DPRINTF("%s -> ROOT_PROPOSED\n", bp->bp_ifp->if_xname);
		}

		if (bp->bp_state != BSTP_IFSTATE_FORWARDING &&
		    (bp->bp_forward_delay_timer.active == 0 ||
		    (bstp_rerooted(bs, bp) &&
		    bp->bp_recent_backup_timer.active == 0 &&
		    bp->bp_protover == BSTP_PROTO_RSTP))) {
			switch (bp->bp_state) {
			case BSTP_IFSTATE_DISCARDING:
				bstp_set_port_state(bp, BSTP_IFSTATE_LEARNING);
				break;
			case BSTP_IFSTATE_LEARNING:
				bstp_set_port_state(bp,
				    BSTP_IFSTATE_FORWARDING);
				break;
			}
		}

		if (bp->bp_state == BSTP_IFSTATE_FORWARDING && bp->bp_reroot) {
			bp->bp_reroot = 0;
			DPRINTF("%s -> ROOT_REROOTED\n", bp->bp_ifp->if_xname);
		}
		break;

	case BSTP_ROLE_DESIGNATED:
		if (bp->bp_recent_root_timer.active == 0 && bp->bp_reroot) {
			bp->bp_reroot = 0;
			DPRINTF("%s -> DESIGNATED_RETIRED\n",
			    bp->bp_ifp->if_xname);
		}

		if ((bp->bp_state == BSTP_IFSTATE_DISCARDING &&
		    !bp->bp_synced) || (bp->bp_agreed && !bp->bp_synced) ||
		    (bp->bp_operedge && !bp->bp_synced) ||
		    (bp->bp_sync && bp->bp_synced)) {
			bstp_timer_stop(&bp->bp_recent_root_timer);
			bp->bp_synced = 1;
			bp->bp_sync = 0;
			DPRINTF("%s -> DESIGNATED_SYNCED\n",
			    bp->bp_ifp->if_xname);
		}

		if (bp->bp_state != BSTP_IFSTATE_FORWARDING &&
		    !bp->bp_agreed && !bp->bp_proposing &&
		    !bp->bp_operedge) {
			bp->bp_proposing = 1;
			bp->bp_flags |= BSTP_PORT_NEWINFO;
			bstp_timer_start(&bp->bp_edge_delay_timer,
			    (bp->bp_ptp_link ? BSTP_DEFAULT_MIGRATE_DELAY :
			     bp->bp_desg_max_age));
			DPRINTF("%s -> DESIGNATED_PROPOSE\n",
			    bp->bp_ifp->if_xname);
		}

		if (bp->bp_state != BSTP_IFSTATE_FORWARDING &&
		    (bp->bp_forward_delay_timer.active == 0 || bp->bp_agreed ||
		    bp->bp_operedge) &&
		    (bp->bp_recent_root_timer.active == 0 || !bp->bp_reroot) &&
		    !bp->bp_sync) {
			if (bp->bp_agreed)
				DPRINTF("%s -> AGREED\n", bp->bp_ifp->if_xname);
			/*
			 * If agreed|operedge then go straight to forwarding,
			 * otherwise follow discard -> learn -> forward.
			 */
			if (bp->bp_agreed || bp->bp_operedge ||
			    bp->bp_state == BSTP_IFSTATE_LEARNING) {
				bstp_set_port_state(bp,
				    BSTP_IFSTATE_FORWARDING);
				bp->bp_agreed = bp->bp_protover;
			} else if (bp->bp_state == BSTP_IFSTATE_DISCARDING)
				bstp_set_port_state(bp, BSTP_IFSTATE_LEARNING);
		}

		if (((bp->bp_sync && !bp->bp_synced) ||
		    (bp->bp_reroot && bp->bp_recent_root_timer.active) ||
		    (bp->bp_flags & BSTP_PORT_DISPUTED)) && !bp->bp_operedge &&
		    bp->bp_state != BSTP_IFSTATE_DISCARDING) {
			bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
			bp->bp_flags &= ~BSTP_PORT_DISPUTED;
			bstp_timer_start(&bp->bp_forward_delay_timer,
			    bp->bp_protover == BSTP_PROTO_RSTP ?
			    bp->bp_desg_htime : bp->bp_desg_fdelay);
			DPRINTF("%s -> DESIGNATED_DISCARD\n",
			    bp->bp_ifp->if_xname);
		}
		break;
	}

	if (bp->bp_flags & BSTP_PORT_NEWINFO)
		bstp_transmit(bs, bp);
}

void
bstp_update_tc(struct bstp_port *bp)
{
	switch (bp->bp_tcstate) {
	case BSTP_TCSTATE_ACTIVE:
		if ((bp->bp_role != BSTP_ROLE_DESIGNATED &&
		    bp->bp_role != BSTP_ROLE_ROOT) || bp->bp_operedge)
			bstp_set_port_tc(bp, BSTP_TCSTATE_LEARNING);

		if (bp->bp_rcvdtcn)
			bstp_set_port_tc(bp, BSTP_TCSTATE_TCN);
		if (bp->bp_rcvdtc)
			bstp_set_port_tc(bp, BSTP_TCSTATE_TC);

		if (bp->bp_tc_prop && !bp->bp_operedge)
			bstp_set_port_tc(bp, BSTP_TCSTATE_PROPAG);

		if (bp->bp_rcvdtca)
			bstp_set_port_tc(bp, BSTP_TCSTATE_ACK);
		break;

	case BSTP_TCSTATE_INACTIVE:
		if ((bp->bp_state == BSTP_IFSTATE_LEARNING ||
		    bp->bp_state == BSTP_IFSTATE_FORWARDING) &&
		    bp->bp_fdbflush == 0)
			bstp_set_port_tc(bp, BSTP_TCSTATE_LEARNING);
		break;

	case BSTP_TCSTATE_LEARNING:
		if (bp->bp_rcvdtc || bp->bp_rcvdtcn || bp->bp_rcvdtca ||
		    bp->bp_tc_prop)
			bstp_set_port_tc(bp, BSTP_TCSTATE_LEARNING);
		else if (bp->bp_role != BSTP_ROLE_DESIGNATED &&
			 bp->bp_role != BSTP_ROLE_ROOT &&
			 bp->bp_state == BSTP_IFSTATE_DISCARDING)
			bstp_set_port_tc(bp, BSTP_TCSTATE_INACTIVE);

		if ((bp->bp_role == BSTP_ROLE_DESIGNATED ||
		    bp->bp_role == BSTP_ROLE_ROOT) &&
		    bp->bp_state == BSTP_IFSTATE_FORWARDING &&
		    !bp->bp_operedge)
			bstp_set_port_tc(bp, BSTP_TCSTATE_DETECTED);
		break;

	/* these are transient states and go straight back to ACTIVE */
	case BSTP_TCSTATE_DETECTED:
	case BSTP_TCSTATE_TCN:
	case BSTP_TCSTATE_TC:
	case BSTP_TCSTATE_PROPAG:
	case BSTP_TCSTATE_ACK:
		DPRINTF("Invalid TC state for %s\n",
		    bp->bp_ifp->if_xname);
		break;
	}

}

void
bstp_update_info(struct bstp_port *bp)
{
	struct bstp_state *bs = bp->bp_bs;

	bp->bp_proposing = 0;
	bp->bp_proposed = 0;

	if (bp->bp_agreed && !bstp_pdu_bettersame(bp, BSTP_INFO_MINE))
		bp->bp_agreed = 0;

	if (bp->bp_synced && !bp->bp_agreed) {
		bp->bp_synced = 0;
		bs->bs_allsynced = 0;
	}

	/* copy the designated pv to the port */
	bp->bp_port_pv = bp->bp_desg_pv;
	bp->bp_port_msg_age = bp->bp_desg_msg_age;
	bp->bp_port_max_age = bp->bp_desg_max_age;
	bp->bp_port_fdelay = bp->bp_desg_fdelay;
	bp->bp_port_htime = bp->bp_desg_htime;
	bp->bp_infois = BSTP_INFO_MINE;

	/* Set transmit flag but do not immediately send */
	bp->bp_flags |= BSTP_PORT_NEWINFO;
}

/* set tcprop on every port other than the caller */
void
bstp_set_other_tcprop(struct bstp_port *bp)
{
	struct bstp_state *bs = bp->bp_bs;
	struct bstp_port *bp2;

	LIST_FOREACH(bp2, &bs->bs_bplist, bp_next) {
		if (bp2 == bp)
			continue;
		bp2->bp_tc_prop = 1;
	}
}

void
bstp_set_all_reroot(struct bstp_state *bs)
{
	struct bstp_port *bp;

	LIST_FOREACH(bp, &bs->bs_bplist, bp_next)
		bp->bp_reroot = 1;
}

void
bstp_set_all_sync(struct bstp_state *bs)
{
	struct bstp_port *bp;

	LIST_FOREACH(bp, &bs->bs_bplist, bp_next) {
		bp->bp_sync = 1;
		bp->bp_synced = 0;	/* Not explicit in spec */
	}

	bs->bs_allsynced = 0;
}

void
bstp_set_port_state(struct bstp_port *bp, int state)
{
	if (bp->bp_state == state)
		return;

	bp->bp_state = state;

	switch (bp->bp_state) {
	case BSTP_IFSTATE_DISCARDING:
		DPRINTF("state changed to DISCARDING on %s\n",
		    bp->bp_ifp->if_xname);
		break;

	case BSTP_IFSTATE_LEARNING:
		DPRINTF("state changed to LEARNING on %s\n",
		    bp->bp_ifp->if_xname);

		bstp_timer_start(&bp->bp_forward_delay_timer,
		    bp->bp_protover == BSTP_PROTO_RSTP ?
		    bp->bp_desg_htime : bp->bp_desg_fdelay);
		break;

	case BSTP_IFSTATE_FORWARDING:
		DPRINTF("state changed to FORWARDING on %s\n",
		    bp->bp_ifp->if_xname);

		bstp_timer_stop(&bp->bp_forward_delay_timer);
		/* Record that we enabled forwarding */
		bp->bp_forward_transitions++;
		break;
	}
}

void
bstp_set_port_role(struct bstp_port *bp, int role)
{
	struct bstp_state *bs = bp->bp_bs;

	if (bp->bp_role == role)
		return;

	/* perform pre-change tasks */
	switch (bp->bp_role) {
	case BSTP_ROLE_DISABLED:
		bstp_timer_start(&bp->bp_forward_delay_timer,
		    bp->bp_desg_max_age);
		break;

	case BSTP_ROLE_BACKUP:
		bstp_timer_start(&bp->bp_recent_backup_timer,
		    bp->bp_desg_htime * 2);
		/* FALLTHROUGH */
	case BSTP_ROLE_ALTERNATE:
		bstp_timer_start(&bp->bp_forward_delay_timer,
		    bp->bp_desg_fdelay);
		bp->bp_sync = 0;
		bp->bp_synced = 1;
		bp->bp_reroot = 0;
		break;

	case BSTP_ROLE_ROOT:
		bstp_timer_start(&bp->bp_recent_root_timer,
		    BSTP_DEFAULT_FORWARD_DELAY);
		break;
	}

	bp->bp_role = role;
	/* clear values not carried between roles */
	bp->bp_proposing = 0;
	bs->bs_allsynced = 0;

	/* initialise the new role */
	switch (bp->bp_role) {
	case BSTP_ROLE_DISABLED:
	case BSTP_ROLE_ALTERNATE:
	case BSTP_ROLE_BACKUP:
		DPRINTF("%s role -> ALT/BACK/DISABLED\n",
		    bp->bp_ifp->if_xname);
		bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
		bstp_timer_stop(&bp->bp_recent_root_timer);
		bstp_timer_latch(&bp->bp_forward_delay_timer);
		bp->bp_sync = 0;
		bp->bp_synced = 1;
		bp->bp_reroot = 0;
		break;

	case BSTP_ROLE_ROOT:
		DPRINTF("%s role -> ROOT\n",
		    bp->bp_ifp->if_xname);
		bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
		bstp_timer_latch(&bp->bp_recent_root_timer);
		bp->bp_proposing = 0;
		break;

	case BSTP_ROLE_DESIGNATED:
		DPRINTF("%s role -> DESIGNATED\n",
		    bp->bp_ifp->if_xname);
		bstp_timer_start(&bp->bp_hello_timer,
		    bp->bp_desg_htime);
		bp->bp_agree = 0;
		break;
	}

	/* let the TC state know that the role changed */
	bstp_update_tc(bp);
}

void
bstp_set_port_proto(struct bstp_port *bp, int proto)
{
	struct bstp_state *bs = bp->bp_bs;

	/* supported protocol versions */
	switch (proto) {
	case BSTP_PROTO_STP:
		/* we can downgrade protocols only */
		bstp_timer_stop(&bp->bp_migrate_delay_timer);
		/* clear unsupported features */
		bp->bp_operedge = 0;
		break;

	case BSTP_PROTO_RSTP:
		bstp_timer_start(&bp->bp_migrate_delay_timer,
		    bs->bs_migration_delay);
		break;

	default:
		DPRINTF("Unsupported STP version %d\n", proto);
		return;
	}

	bp->bp_protover = proto;
	bp->bp_flags &= ~BSTP_PORT_CANMIGRATE;
}

void
bstp_set_port_tc(struct bstp_port *bp, int state)
{
	struct bstp_state *bs = bp->bp_bs;

	bp->bp_tcstate = state;

	/* initialise the new state */
	switch (bp->bp_tcstate) {
	case BSTP_TCSTATE_ACTIVE:
		DPRINTF("%s -> TC_ACTIVE\n", bp->bp_ifp->if_xname);
		/* nothing to do */
		break;

	case BSTP_TCSTATE_INACTIVE:
		bstp_timer_stop(&bp->bp_tc_timer);
		/* flush routes on the parent bridge */
		bp->bp_fdbflush = 1;
		bstp_notify_rtage(bp, 0);
		bp->bp_tc_ack = 0;
		DPRINTF("%s -> TC_INACTIVE\n", bp->bp_ifp->if_xname);
		break;

	case BSTP_TCSTATE_LEARNING:
		bp->bp_rcvdtc = 0;
		bp->bp_rcvdtcn = 0;
		bp->bp_rcvdtca = 0;
		bp->bp_tc_prop = 0;
		DPRINTF("%s -> TC_LEARNING\n", bp->bp_ifp->if_xname);
		break;

	case BSTP_TCSTATE_DETECTED:
		bstp_set_timer_tc(bp);
		bstp_set_other_tcprop(bp);
		/* send out notification */
		bp->bp_flags |= BSTP_PORT_NEWINFO;
		bstp_transmit(bs, bp);
		getmicrotime(&bs->bs_last_tc_time);
		DPRINTF("%s -> TC_DETECTED\n", bp->bp_ifp->if_xname);
		bp->bp_tcstate = BSTP_TCSTATE_ACTIVE; /* UCT */
		break;

	case BSTP_TCSTATE_TCN:
		bstp_set_timer_tc(bp);
		DPRINTF("%s -> TC_TCN\n", bp->bp_ifp->if_xname);
		/* FALLTHROUGH */
	case BSTP_TCSTATE_TC:
		bp->bp_rcvdtc = 0;
		bp->bp_rcvdtcn = 0;
		if (bp->bp_role == BSTP_ROLE_DESIGNATED)
			bp->bp_tc_ack = 1;

		bstp_set_other_tcprop(bp);
		DPRINTF("%s -> TC_TC\n", bp->bp_ifp->if_xname);
		bp->bp_tcstate = BSTP_TCSTATE_ACTIVE; /* UCT */
		break;

	case BSTP_TCSTATE_PROPAG:
		/* flush routes on the parent bridge */
		bp->bp_fdbflush = 1;
		bstp_notify_rtage(bp, 0);
		bp->bp_tc_prop = 0;
		bstp_set_timer_tc(bp);
		DPRINTF("%s -> TC_PROPAG\n", bp->bp_ifp->if_xname);
		bp->bp_tcstate = BSTP_TCSTATE_ACTIVE; /* UCT */
		break;

	case BSTP_TCSTATE_ACK:
		bstp_timer_stop(&bp->bp_tc_timer);
		bp->bp_rcvdtca = 0;
		DPRINTF("%s -> TC_ACK\n", bp->bp_ifp->if_xname);
		bp->bp_tcstate = BSTP_TCSTATE_ACTIVE; /* UCT */
		break;
	}
}

void
bstp_set_timer_tc(struct bstp_port *bp)
{
	struct bstp_state *bs = bp->bp_bs;

	if (bp->bp_tc_timer.active)
		return;

	switch (bp->bp_protover) {
	case BSTP_PROTO_RSTP:
		bstp_timer_start(&bp->bp_tc_timer,
		    bp->bp_desg_htime + BSTP_TICK_VAL);
		bp->bp_flags |= BSTP_PORT_NEWINFO;
		break;
	case BSTP_PROTO_STP:
		bstp_timer_start(&bp->bp_tc_timer,
		    bs->bs_root_max_age + bs->bs_root_fdelay);
		break;
	}
}

void
bstp_set_timer_msgage(struct bstp_port *bp)
{
	if (bp->bp_port_msg_age + BSTP_MESSAGE_AGE_INCR <=
	    bp->bp_port_max_age) {
		bstp_timer_start(&bp->bp_message_age_timer,
		    bp->bp_port_htime * 3);
	} else
		/* expires immediately */
		bstp_timer_start(&bp->bp_message_age_timer, 0);
}

int
bstp_rerooted(struct bstp_state *bs, struct bstp_port *bp)
{
	struct bstp_port *bp2;
	int rr_set = 0;

	LIST_FOREACH(bp2, &bs->bs_bplist, bp_next) {
		if (bp2 == bp)
			continue;
		if (bp2->bp_recent_root_timer.active) {
			rr_set = 1;
			break;
		}
	}
	return (!rr_set);
}

/*
 * Calculate the path cost according to the link speed.
 */
u_int32_t
bstp_calc_path_cost(struct bstp_port *bp)
{
	struct ifnet *ifp = bp->bp_ifp;
	u_int32_t path_cost;

	/* If the priority has been manually set then retain the value */
	if (bp->bp_flags & BSTP_PORT_ADMCOST)
		return bp->bp_path_cost;

	if (ifp->if_baudrate < 1000)
		return (BSTP_DEFAULT_PATH_COST);

 	/* formula from section 17.14, IEEE Std 802.1D-2004 */
	path_cost = 20000000000ULL / (ifp->if_baudrate / 1000);

	if (path_cost > BSTP_MAX_PATH_COST)
		path_cost = BSTP_MAX_PATH_COST;

	/* STP compat mode only uses 16 bits of the 32 */
	if (bp->bp_protover == BSTP_PROTO_STP && path_cost > 65535)
		path_cost = 65535;

	return (path_cost);
}

void
bstp_notify_rtage(struct bstp_port *bp, int pending)
{
	int age = 0;

	NET_ASSERT_LOCKED();

	switch (bp->bp_protover) {
	case BSTP_PROTO_STP:
		/* convert to seconds */
		age = bp->bp_desg_fdelay / BSTP_TICK_VAL;
		break;
	case BSTP_PROTO_RSTP:
		age = 0;
		break;
	}

	if (bp->bp_active == 1)
		bridge_rtagenode(bp->bp_ifp, age);

	/* flush is complete */
	bp->bp_fdbflush = 0;
}

void
bstp_ifstate(void *arg)
{
	struct ifnet *ifp = (struct ifnet *)arg;
	struct bridge_iflist *p;
	struct bstp_port *bp;
	struct bstp_state *bs;
	int s;

	if (ifp->if_type == IFT_BRIDGE)
		return;

	s = splnet();
	if ((p = (struct bridge_iflist *)ifp->if_bridgeport) == NULL)
		goto done;
	if ((p->bif_flags & IFBIF_STP) == 0)
		goto done;
	if ((bp = p->bif_stp) == NULL)
		goto done;
	if ((bs = bp->bp_bs) == NULL)
		goto done;

	/* update the link state */
	bstp_ifupdstatus(bs, bp);
	bstp_update_state(bs, bp);
 done:
	splx(s);
}

void
bstp_ifupdstatus(struct bstp_state *bs, struct bstp_port *bp)
{
	struct ifnet *ifp = bp->bp_ifp;

	if (ifp == NULL)
		return;

	bp->bp_path_cost = bstp_calc_path_cost(bp);

	if ((ifp->if_flags & IFF_UP) &&
	    ifp->if_link_state != LINK_STATE_DOWN) {
		if (bp->bp_flags & BSTP_PORT_AUTOPTP) {
			/* A full-duplex link is assumed to be ptp */
			bp->bp_ptp_link = ifp->if_link_state ==
			    LINK_STATE_FULL_DUPLEX ? 1 : 0;
		}

		if (bp->bp_infois == BSTP_INFO_DISABLED)
			bstp_enable_port(bs, bp);
	} else {
		if (bp->bp_infois != BSTP_INFO_DISABLED)
			bstp_disable_port(bs, bp);
	}
}

void
bstp_enable_port(struct bstp_state *bs, struct bstp_port *bp)
{
	bp->bp_infois = BSTP_INFO_AGED;
	bstp_assign_roles(bs);
}

void
bstp_disable_port(struct bstp_state *bs, struct bstp_port *bp)
{
	bp->bp_infois = BSTP_INFO_DISABLED;
	bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
	bstp_assign_roles(bs);
}

void
bstp_tick(void *arg)
{
	struct bstp_state *bs = (struct bstp_state *)arg;
	struct bstp_port *bp;
	int s;

	s = splnet();
	if ((bs->bs_ifflags & IFF_RUNNING) == 0) {
		splx(s);
		return;
	}

	/* slow timer to catch missed link events */
	if (bstp_timer_expired(&bs->bs_link_timer)) {
		LIST_FOREACH(bp, &bs->bs_bplist, bp_next)
			bstp_ifupdstatus(bs, bp);
		bstp_timer_start(&bs->bs_link_timer, BSTP_LINK_TIMER);
	}

	LIST_FOREACH(bp, &bs->bs_bplist, bp_next) {
		/* no events need to happen for these */
		bstp_timer_expired(&bp->bp_tc_timer);
		bstp_timer_expired(&bp->bp_recent_root_timer);
		bstp_timer_expired(&bp->bp_forward_delay_timer);
		bstp_timer_expired(&bp->bp_recent_backup_timer);

		if (bstp_timer_expired(&bp->bp_hello_timer))
			bstp_hello_timer_expiry(bs, bp);

		if (bstp_timer_expired(&bp->bp_message_age_timer))
			bstp_message_age_expiry(bs, bp);

		if (bstp_timer_expired(&bp->bp_migrate_delay_timer))
			bstp_migrate_delay_expiry(bs, bp);

		if (bstp_timer_expired(&bp->bp_edge_delay_timer))
			bstp_edge_delay_expiry(bs, bp);

		/* update the various state machines for the port */
		bstp_update_state(bs, bp);

		if (bp->bp_txcount > 0)
			bp->bp_txcount--;
	}

	if (bs->bs_ifp->if_flags & IFF_RUNNING)
		timeout_add_sec(&bs->bs_bstptimeout, 1);

	splx(s);
}

void
bstp_timer_start(struct bstp_timer *t, u_int16_t v)
{
	t->value = v;
	t->active = 1;
	t->latched = 0;
}

void
bstp_timer_stop(struct bstp_timer *t)
{
	t->value = 0;
	t->active = 0;
	t->latched = 0;
}

void
bstp_timer_latch(struct bstp_timer *t)
{
	t->latched = 1;
	t->active = 1;
}

int
bstp_timer_expired(struct bstp_timer *t)
{
	if (t->active == 0 || t->latched)
		return (0);
	t->value -= BSTP_TICK_VAL;
	if (t->value <= 0) {
		bstp_timer_stop(t);
		return (1);
	}
	return (0);
}

void
bstp_hello_timer_expiry(struct bstp_state *bs, struct bstp_port *bp)
{
	if ((bp->bp_flags & BSTP_PORT_NEWINFO) ||
	    bp->bp_role == BSTP_ROLE_DESIGNATED ||
	    (bp->bp_role == BSTP_ROLE_ROOT &&
	     bp->bp_tc_timer.active == 1)) {
		bstp_timer_start(&bp->bp_hello_timer, bp->bp_desg_htime);
		bp->bp_flags |= BSTP_PORT_NEWINFO;
		bstp_transmit(bs, bp);
	}
}

void
bstp_message_age_expiry(struct bstp_state *bs, struct bstp_port *bp)
{
	if (bp->bp_infois == BSTP_INFO_RECEIVED) {
		bp->bp_infois = BSTP_INFO_AGED;
		bstp_assign_roles(bs);
		DPRINTF("aged info on %s\n", bp->bp_ifp->if_xname);
	}
}

void
bstp_migrate_delay_expiry(struct bstp_state *bs, struct bstp_port *bp)
{
	bp->bp_flags |= BSTP_PORT_CANMIGRATE;
}

void
bstp_edge_delay_expiry(struct bstp_state *bs, struct bstp_port *bp)
{
	if ((bp->bp_flags & BSTP_PORT_AUTOEDGE) &&
	    bp->bp_protover == BSTP_PROTO_RSTP && bp->bp_proposing &&
	    bp->bp_role == BSTP_ROLE_DESIGNATED)
		bp->bp_operedge = 1;
}

int
bstp_addr_cmp(const u_int8_t *a, const u_int8_t *b)
{
	int i, d;

	for (i = 0, d = 0; i < ETHER_ADDR_LEN && d == 0; i++) {
		d = ((int)a[i]) - ((int)b[i]);
	}

	return (d);
}

/*
 * compare the bridge address component of the bridgeid
 */
int
bstp_same_bridgeid(u_int64_t id1, u_int64_t id2)
{
	u_char addr1[ETHER_ADDR_LEN];
	u_char addr2[ETHER_ADDR_LEN];

	PV2ADDR(id1, addr1);
	PV2ADDR(id2, addr2);

	if (bstp_addr_cmp(addr1, addr2) == 0)
		return (1);

	return (0);
}

void
bstp_initialization(struct bstp_state *bs)
{
	struct bstp_port *bp;
	struct ifnet *mif = NULL;
	u_char *e_addr;

	if (LIST_EMPTY(&bs->bs_bplist)) {
		bstp_stop(bs);
		return;
	}

	/*
	 * Search through the Ethernet interfaces and find the one
	 * with the lowest value.
	 * Make sure we take the address from an interface that is
	 * part of the bridge to make sure two bridges on the system
	 * will not use the same one. It is not possible for mif to be
	 * null, at this point we have at least one STP port and hence
	 * at least one NIC.
	 */
	LIST_FOREACH(bp, &bs->bs_bplist, bp_next) {
		if (mif == NULL) {
			mif = bp->bp_ifp;
			continue;
		}
		if (bstp_addr_cmp(LLADDR(bp->bp_ifp->if_sadl),
		    LLADDR(mif->if_sadl)) < 0) {
			mif = bp->bp_ifp;
			continue;
		}
	}

	e_addr = LLADDR(mif->if_sadl);
	bs->bs_bridge_pv.pv_dbridge_id =
	    (((u_int64_t)bs->bs_bridge_priority) << 48) |
	    (((u_int64_t)e_addr[0]) << 40) |
	    (((u_int64_t)e_addr[1]) << 32) |
	    (((u_int64_t)e_addr[2]) << 24) |
	    (((u_int64_t)e_addr[3]) << 16) |
	    (((u_int64_t)e_addr[4]) << 8) |
	    (((u_int64_t)e_addr[5]));

	bs->bs_bridge_pv.pv_root_id = bs->bs_bridge_pv.pv_dbridge_id;
	bs->bs_bridge_pv.pv_cost = 0;
	bs->bs_bridge_pv.pv_dport_id = 0;
	bs->bs_bridge_pv.pv_port_id = 0;

	if (!timeout_initialized(&bs->bs_bstptimeout))
		timeout_set(&bs->bs_bstptimeout, bstp_tick, bs);
	if (bs->bs_ifflags & IFF_RUNNING &&
	    !timeout_pending(&bs->bs_bstptimeout))
		timeout_add_sec(&bs->bs_bstptimeout, 1);

	LIST_FOREACH(bp, &bs->bs_bplist, bp_next) {
		bp->bp_port_id = (bp->bp_priority << 8) |
		    (bp->bp_ifp->if_index & 0xfff);
		bstp_ifupdstatus(bs, bp);
	}

	bstp_assign_roles(bs);
	bstp_timer_start(&bs->bs_link_timer, BSTP_LINK_TIMER);
}

struct bstp_state *
bstp_create(struct ifnet *ifp)
{
	struct bstp_state *bs;
	int s;

	s = splnet();
	bs = malloc(sizeof(*bs), M_DEVBUF, M_WAITOK|M_ZERO);
	LIST_INIT(&bs->bs_bplist);

	bs->bs_ifp = ifp;
	bs->bs_bridge_max_age = BSTP_DEFAULT_MAX_AGE;
	bs->bs_bridge_htime = BSTP_DEFAULT_HELLO_TIME;
	bs->bs_bridge_fdelay = BSTP_DEFAULT_FORWARD_DELAY;
	bs->bs_bridge_priority = BSTP_DEFAULT_BRIDGE_PRIORITY;
	bs->bs_hold_time = BSTP_DEFAULT_HOLD_TIME;
	bs->bs_migration_delay = BSTP_DEFAULT_MIGRATE_DELAY;
	bs->bs_txholdcount = BSTP_DEFAULT_HOLD_COUNT;
	bs->bs_protover = BSTP_PROTO_RSTP;	/* STP instead of RSTP? */

	getmicrotime(&bs->bs_last_tc_time);

	splx(s);

	return (bs);
}

void
bstp_destroy(struct bstp_state *bs)
{
	if (bs == NULL)
		return;

	if (!LIST_EMPTY(&bs->bs_bplist))
		panic("bstp still active");

	free(bs, M_DEVBUF, sizeof *bs);
}

void
bstp_stop(struct bstp_state *bs)
{
	struct bstp_port *bp;

	LIST_FOREACH(bp, &bs->bs_bplist, bp_next)
		bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);

	if (timeout_initialized(&bs->bs_bstptimeout))
		timeout_del(&bs->bs_bstptimeout);
}

struct bstp_port *
bstp_add(struct bstp_state *bs, struct ifnet *ifp)
{
	struct bstp_port *bp;

	switch (ifp->if_type) {
	case IFT_ETHER:	/* These can do spanning tree. */
		break;
	default:
		/* Nothing else can. */
		return (NULL);
	}

	bp = malloc(sizeof(*bp), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (bp == NULL)
		return (NULL);

	bp->bp_ifp = ifp;
	bp->bp_bs = bs;
	bp->bp_priority = BSTP_DEFAULT_PORT_PRIORITY;
	bp->bp_txcount = 0;

	/* Init state */
	bp->bp_infois = BSTP_INFO_DISABLED;
	bp->bp_flags = BSTP_PORT_AUTOEDGE | BSTP_PORT_AUTOPTP;
	bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
	bstp_set_port_proto(bp, bs->bs_protover);
	bstp_set_port_role(bp, BSTP_ROLE_DISABLED);
	bstp_set_port_tc(bp, BSTP_TCSTATE_INACTIVE);
	bp->bp_path_cost = bstp_calc_path_cost(bp);

	LIST_INSERT_HEAD(&bs->bs_bplist, bp, bp_next);

	bp->bp_active = 1;
	bp->bp_flags |= BSTP_PORT_NEWINFO;
	bstp_initialization(bs);
	bstp_update_roles(bs, bp);

	/* Register callback for physical link state changes */
	if (ifp->if_linkstatehooks != NULL)
		bp->bp_lhcookie = hook_establish(ifp->if_linkstatehooks, 1,
		    bstp_ifstate, ifp);

	return (bp);
}

void
bstp_delete(struct bstp_port *bp)
{
	struct bstp_state *bs = bp->bp_bs;
	struct ifnet *ifp = bp->bp_ifp;

	if (!bp->bp_active)
		panic("not a bstp member");

	if (ifp != NULL && ifp->if_linkstatehooks != NULL)
		hook_disestablish(ifp->if_linkstatehooks, bp->bp_lhcookie);

	LIST_REMOVE(bp, bp_next);
	free(bp, M_DEVBUF, sizeof *bp);
	bstp_initialization(bs);
}

u_int8_t
bstp_getstate(struct bstp_state *bs, struct bstp_port *bp)
{
	u_int8_t state = bp->bp_state;

	if (bs->bs_protover != BSTP_PROTO_STP)
		return (state);

	/*
	 * Translate RSTP roles and states to STP port states
	 * (IEEE Std 802.1D-2004 Table 17-1).
	 */
	if (bp->bp_role == BSTP_ROLE_DISABLED)
		state = BSTP_IFSTATE_DISABLED;
	else if (bp->bp_role == BSTP_ROLE_ALTERNATE ||
	    bp->bp_role == BSTP_ROLE_BACKUP)
		state = BSTP_IFSTATE_BLOCKING;
	else if (state == BSTP_IFSTATE_DISCARDING)
		state = BSTP_IFSTATE_LISTENING;

	return (state);
}

void
bstp_ifsflags(struct bstp_port *bp, u_int flags)
{
	struct bstp_state *bs;

	if ((flags & IFBIF_STP) == 0)
		return;
	bs = bp->bp_bs;

	/*
	 * Set edge status
	 */
	if (flags & IFBIF_BSTP_AUTOEDGE) {
		if ((bp->bp_flags & BSTP_PORT_AUTOEDGE) == 0) {
			bp->bp_flags |= BSTP_PORT_AUTOEDGE;

			/* we may be able to transition straight to edge */
			if (bp->bp_edge_delay_timer.active == 0)
				bstp_edge_delay_expiry(bs, bp);
		}
	} else
		bp->bp_flags &= ~BSTP_PORT_AUTOEDGE;

	if (flags & IFBIF_BSTP_EDGE)
		bp->bp_operedge = 1;
	else
		bp->bp_operedge = 0;

	/*
	 * Set point to point status
	 */
	if (flags & IFBIF_BSTP_AUTOPTP) {
		if ((bp->bp_flags & BSTP_PORT_AUTOPTP) == 0) {
			bp->bp_flags |= BSTP_PORT_AUTOPTP;

			bstp_ifupdstatus(bs, bp);
		}
	} else
		bp->bp_flags &= ~BSTP_PORT_AUTOPTP;

	if (flags & IFBIF_BSTP_PTP)
		bp->bp_ptp_link = 1;
	else
		bp->bp_ptp_link = 0;
}

int
bstp_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct bridge_softc *sc = (struct bridge_softc *)ifp->if_softc;
	struct bstp_state *bs = sc->sc_stp;
	struct ifbrparam *ifbp = (struct ifbrparam *)data;
	struct ifbreq *ifbr = (struct ifbreq *)data;
	struct bridge_iflist *p;
	struct ifnet *ifs;
	struct bstp_port *bp;
	int r = 0, err = 0, val;

	switch (cmd) {
	case SIOCBRDGSIFPRIO:
	case SIOCBRDGSIFCOST:
		ifs = ifunit(ifbr->ifbr_ifsname);
		if (ifs == NULL) {
			err = ENOENT;
			break;
		}
		p = (struct bridge_iflist *)ifs->if_bridgeport;
		if (p == NULL || p->bridge_sc != sc) {
			err = ESRCH;
			break;
		}
		if ((p->bif_flags & IFBIF_STP) == 0) {
			err = EINVAL;
			break;
		}
		bp = p->bif_stp;
		break;
	default:
		break;
	}
	if (err)
		return (err);

	switch (cmd) {
	case SIOCBRDGGPRI:
		ifbp->ifbrp_prio = bs->bs_bridge_priority;
		break;
	case SIOCBRDGSPRI:
		val = ifbp->ifbrp_prio;
		if (val < 0 || val > BSTP_MAX_PRIORITY) {
			err = EINVAL;
			break;
		}

		/* Limit to steps of 4096 */
		val -= val % 4096;
		bs->bs_bridge_priority = val;
		r = 1;
		break;
	case SIOCBRDGGMA:
		ifbp->ifbrp_maxage = bs->bs_bridge_max_age >> 8;
		break;
	case SIOCBRDGSMA:
		val = ifbp->ifbrp_maxage;

		/* convert seconds to ticks */
		val *= BSTP_TICK_VAL;

		if (val < BSTP_MIN_MAX_AGE || val > BSTP_MAX_MAX_AGE) {
			err = EINVAL;
			break;
		}
		bs->bs_bridge_max_age = val;
		r = 1;
		break;
	case SIOCBRDGGHT:
		ifbp->ifbrp_hellotime = bs->bs_bridge_htime >> 8;
		break;
	case SIOCBRDGSHT:
		val = ifbp->ifbrp_hellotime;

		/* convert seconds to ticks */
		val *=  BSTP_TICK_VAL;

		/* value can only be changed in leagacy stp mode */
		if (bs->bs_protover != BSTP_PROTO_STP) {
			err = EPERM;
			break;
		}
		if (val < BSTP_MIN_HELLO_TIME || val > BSTP_MAX_HELLO_TIME) {
			err = EINVAL;
			break;
		}
		bs->bs_bridge_htime = val;
		r = 1;
		break;
	case SIOCBRDGGFD:
		ifbp->ifbrp_fwddelay = bs->bs_bridge_fdelay >> 8;
		break;
	case SIOCBRDGSFD:
		val = ifbp->ifbrp_fwddelay;

		/* convert seconds to ticks */
		val *= BSTP_TICK_VAL;

		if (val < BSTP_MIN_FORWARD_DELAY ||
		    val > BSTP_MAX_FORWARD_DELAY) {
			err = EINVAL;
			break;
		}
		bs->bs_bridge_fdelay = val;
		r = 1;
		break;
	case SIOCBRDGSTXHC:
		val = ifbp->ifbrp_txhc;

		if (val < BSTP_MIN_HOLD_COUNT || val > BSTP_MAX_HOLD_COUNT) {
			err = EINVAL;
			break;
		}
		bs->bs_txholdcount = val;
		LIST_FOREACH(bp, &bs->bs_bplist, bp_next)
			bp->bp_txcount = 0;
		break;
	case SIOCBRDGSIFPRIO:
		val = ifbr->ifbr_priority;
		if (val < 0 || val > BSTP_MAX_PORT_PRIORITY)
			return (EINVAL);

		/* Limit to steps of 16 */
		val -= val % 16;
		bp->bp_priority = val;
		r = 1;
		break;
	case SIOCBRDGSIFCOST:
		val = ifbr->ifbr_path_cost;
		if (val > BSTP_MAX_PATH_COST) {
			err = EINVAL;
			break;
		}
		if (val == 0) {	/* use auto */
			bp->bp_flags &= ~BSTP_PORT_ADMCOST;
			bp->bp_path_cost = bstp_calc_path_cost(bp);
		} else {
			bp->bp_path_cost = val;
			bp->bp_flags |= BSTP_PORT_ADMCOST;
		}
		r = 1;
		break;
	case SIOCBRDGSPROTO:
		val = ifbp->ifbrp_proto;

		/* Supported protocol versions */
		switch (val) {
		case BSTP_PROTO_STP:
		case BSTP_PROTO_RSTP:
			bs->bs_protover = val;
			bs->bs_bridge_htime = BSTP_DEFAULT_HELLO_TIME;
			LIST_FOREACH(bp, &bs->bs_bplist, bp_next) {
				/* reinit state */
				bp->bp_infois = BSTP_INFO_DISABLED;
				bp->bp_txcount = 0;
				bstp_set_port_proto(bp, bs->bs_protover);
				bstp_set_port_role(bp, BSTP_ROLE_DISABLED);
				bstp_set_port_tc(bp, BSTP_TCSTATE_INACTIVE);
				bstp_timer_stop(&bp->bp_recent_backup_timer);
			}
			r = 1;
			break;
		default:
			err = EINVAL;
		}
		break;
	default:
		break;
	}

	if (r)
		bstp_initialization(bs);

	return (err);
}
@


1.64
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.63 2016/09/20 12:14:49 bluhm Exp $	*/
d1587 1
a1587 1
	splsoftassert(IPL_SOFTNET);
@


1.63
log
@Use splsoftassert() together with IPL_SOFTNET.  On alpha and m88k
it is defined differently than splassert(IPL_SOFTNET).  No binary
change on amd64.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.62 2015/11/07 12:37:18 mpi Exp $	*/
d2020 1
a2020 1
	 * (IEEE Std 802.1D-2004 Table 17-1). 
@


1.62
log
@Don't try to be clever testing if a queue is full before calling
if_enqueue().  As pointed by dlg@@, IF_QFULL on works in the priq
case.

Prompted by a diff from uebayasi@@ to export ifi_oqdrops, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.61 2015/11/02 14:35:12 reyk Exp $	*/
d1587 1
a1587 1
	splassert(IPL_SOFTNET);
@


1.61
log
@Some of the bridge code is running in splsoftnet now, change the
splassert() in bstp_notify_rtage() from IPL_NET to IPL_SOFTNET
accordingly.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.60 2015/09/29 10:11:40 deraadt Exp $	*/
a467 5

	if (IF_QFULL(&ifp->if_snd)) {
		IF_DROP(&ifp->if_snd);
		goto done;
	}
@


1.60
log
@add sizes to some of the simpler free calls
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.59 2015/07/17 18:15:41 mpi Exp $	*/
d1592 1
a1592 1
	splassert(IPL_NET);
@


1.59
log
@Pass the correct argument to bstp_notify_rtage().

Problem found and fix provided by Ryota Ozaki, thanks!

ok deraadt@@, yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.58 2015/07/15 22:16:41 deraadt Exp $	*/
d1937 1
a1937 1
	free(bs, M_DEVBUF, 0);
d2011 1
a2011 3
	bp->bp_bs = NULL;
	bp->bp_active = 0;
	free(bp, M_DEVBUF, 0);
@


1.58
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.57 2015/06/30 13:54:42 mpi Exp $	*/
d257 1
a257 1
void	bstp_notify_rtage(void *, int);
d1450 1
a1450 1
		bstp_notify_rtage(bp->bp_ifp, 0);
d1492 1
a1492 1
		bstp_notify_rtage(bp->bp_ifp, 0);
d1588 1
a1588 1
bstp_notify_rtage(void *arg, int pending)
a1589 1
	struct bstp_port *bp = (struct bstp_port *)arg;
@


1.57
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.56 2015/06/16 11:09:39 mpi Exp $	*/
d628 1
a628 2
	if (m)
		m_freem(m);
@


1.56
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.55 2015/05/15 10:15:13 mpi Exp $	*/
d381 1
a381 1
	if_output(ifp, m);
d511 1
a511 1
	if_output(ifp, m);
@


1.55
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.54 2015/05/12 12:35:10 mpi Exp $	*/
d363 1
a363 1
	m->m_pkthdr.rcvif = ifp;
d506 1
a506 1
	m->m_pkthdr.rcvif = ifp;
@


1.54
log
@This file is only compiled when "pseudo-device bridge" is included in
your kernel configuration, no need for a #if NBRIDGE > 0 dance.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.53 2015/05/04 10:24:08 mpi Exp $	*/
a355 1
	int s, len, error;
a379 1
	s = splnet();
d381 1
a381 8
	len = m->m_pkthdr.len;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error == 0) {
		ifp->if_obytes += len;
		ifp->if_omcasts++;
		if_start(ifp);
	}
	splx(s);
d463 1
a463 1
	int s, len, error;
d511 1
a511 7
	len = m->m_pkthdr.len;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error == 0) {
		ifp->if_obytes += len;
		ifp->if_omcasts++;
		if_start(ifp);
	}
@


1.53
log
@Use ether_input() as default input packet handler and do the necessary
m_adj(9) to keep bridge(4) working while other pseudo-drivers are
converted to if_input().

Tested by mxb <mxb AT alumni DOT chalmers DOT se>, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.52 2015/03/14 03:38:51 jsg Exp $	*/
a34 4
#include "bridge.h"

#if NBRIDGE > 0

a2278 1
#endif /* NBRIDGE */
@


1.52
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.51 2014/12/19 17:14:39 tedu Exp $	*/
d599 3
@


1.51
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.50 2014/09/08 06:24:13 jsg Exp $	*/
a51 1
#include <net/if_media.h>
@


1.50
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.49 2014/07/22 11:06:09 mpi Exp $	*/
a54 1
#ifdef INET
a57 1
#endif
@


1.49
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.48 2014/07/12 18:44:22 tedu Exp $	*/
a52 1
#include <net/route.h>
@


1.48
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.47 2014/04/19 15:54:39 henning Exp $	*/
a57 1
#include <netinet/in_systm.h>
@


1.47
log
@minus altq tentacles, plus missing IF_DROP here as well
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.46 2013/10/20 08:48:39 deraadt Exp $	*/
d1960 1
a1960 1
	free(bs, M_DEVBUF);
d2036 1
a2036 1
	free(bp, M_DEVBUF);
@


1.46
log
@remove irrelevant comment
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.45 2013/10/17 16:27:40 bluhm Exp $	*/
d487 2
a488 4
#ifdef ALTQ
	if (!ALTQ_IS_ENABLED(&ifp->if_snd))
#endif
	if (IF_QFULL(&ifp->if_snd))
d490 1
@


1.45
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.44 2013/06/20 12:03:40 mpi Exp $	*/
a33 4

#if 0
__FBSDID("$FreeBSD: /repoman/r/ncvs/src/sys/net/bridgestp.c,v 1.25 2006/11/03 03:34:04 thompsa Exp $");
#endif
@


1.44
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.43 2013/06/20 09:38:24 mpi Exp $	*/
a62 1
#include <netinet/in_var.h>
@


1.43
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.42 2012/10/05 17:17:04 camield Exp $	*/
d2020 3
a2022 2
	bp->bp_lhcookie = hook_establish(&ifp->if_linkstatehooks, 1,
	    bstp_ifstate, ifp);
d2036 2
a2037 2
	if (ifp != NULL)
		hook_disestablish(&ifp->if_linkstatehooks, bp->bp_lhcookie);
@


1.42
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.41 2012/09/20 14:10:18 mpf Exp $	*/
d2020 2
a2021 3
	if (ifp->if_linkstatehooks != NULL)
		bp->bp_lhcookie = hook_establish(ifp->if_linkstatehooks, 1,
		    bstp_ifstate, ifp);
d2035 2
a2036 2
	if (ifp != NULL && ifp->if_linkstatehooks != NULL)
		hook_disestablish(ifp->if_linkstatehooks, bp->bp_lhcookie);
@


1.41
log
@Don't filter spanning tree BPDUs. Either process, or forward them.
Even though this violates IEEE 802.1D, we'd rather avoid bridging loops
by not getting in the way of STP.
OK henning, camield, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.40 2011/07/09 04:53:33 henning Exp $	*/
a1643 1
	struct bridge_softc *sc;
a1650 1
	sc = (struct bridge_softc *)ifp->if_bridge;
d1653 3
a1655 7
	LIST_FOREACH(p, &sc->sc_iflist, next) {
		if ((p->bif_flags & IFBIF_STP) == 0)
			continue;
		if (p->ifp == ifp)
			break;
	}
	if (p == LIST_END(&sc->sc_iflist))
d2118 1
a2118 1
	struct bridge_softc *sc = (struct bridge_softc *)ifp;
d2135 2
a2136 9
		if ((caddr_t)sc != ifs->if_bridge) {
			err = ESRCH;
			break;
		}
		LIST_FOREACH(p, &sc->sc_iflist, next) {
			if (p->ifp == ifs)
				break;
		}
		if (p == LIST_END(&sc->sc_iflist)) {
@


1.40
log
@sned BPDUs at prio 6, just like lacp and carp, ryan zinke mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.39 2010/11/20 14:23:09 fgsch Exp $	*/
d597 1
a597 1
void
d605 1
a605 1
		goto out;
d657 1
@


1.39
log
@remove bs_list occurrences. fixes panic on destroy.
ok from the m guild: mikeb@@ miod@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.38 2010/10/31 15:14:30 mpf Exp $	*/
d181 2
d380 1
d532 1
@


1.38
log
@Remove unused bstp_list and bstp_attach.
OK blambert, claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.37 2010/10/28 13:49:54 claudio Exp $	*/
a1960 2
	int s;

a1966 2
	s = splnet();
	LIST_REMOVE(bs, bs_list);
a1967 1
	splx(s);
@


1.37
log
@A function that only returns NULL should return void.
bstp_input() always consumes the packet so remove the mbuf handling
dance around it.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.36 2008/09/10 14:01:23 blambert Exp $	*/
a229 1
LIST_HEAD(, bstp_state) bstp_list;
a288 5
void
bstp_attach(int n)
{
	LIST_INIT(&bstp_list);
}
a1952 1
	LIST_INSERT_HEAD(&bstp_list, bs, bs_list);
@


1.36
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.35 2008/08/07 18:09:22 damien Exp $	*/
d599 1
a599 1
struct mbuf *
a658 1
	return (NULL);
@


1.35
log
@account spanning tree frames in if_obytes and if_omcasts.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.34 2008/06/14 19:13:42 jsing Exp $	*/
d1765 1
a1765 1
		timeout_add(&bs->bs_bstptimeout, hz);
d1926 1
a1926 1
		timeout_add(&bs->bs_bstptimeout, hz);
@


1.34
log
@Remove NBPFILTER conditional since we do not include "bpfilter.h" and the
<net/bpf.h> header is not required here.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.33 2008/06/13 19:08:19 henning Exp $	*/
d374 1
a374 1
	int s,error;
d400 1
d402 3
a404 1
	if (error == 0)
d406 1
d489 1
a489 1
	int s, error;
d537 1
d539 3
a541 1
	if (error == 0)
d543 1
@


1.33
log
@we used to use the lowest (so it is deterministic) mac address in the
system for the bridge ID for stp. That worksfine unless you have
two bridges in the system that talkto the same neighboring systems
(switches), because the two bridges on the openbsd system would have the
same ID.
fix by only looking at interfaces part of the bridge and using the lowest
mac address of these. works fine because stpcan only be enabled on
IFT_ETHER interfaces so there is always at least one and we re-evaluate
every time an interface is added or deleted from the bridge.
diff was rotting in my tree for at least a year, I have no idea what
triggered it really.
ok reyk mk djm
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.32 2008/05/21 21:10:50 mk Exp $	*/
a65 4
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
@


1.32
log
@Just clear the timeout since timeout_del() can cope with
unscheduled/already triggered timeouts.

ok brad claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.31 2008/05/07 13:45:35 dlg Exp $	*/
d1874 1
a1874 1
	struct ifnet *ifp, *mif;
a1881 1
	mif = NULL;
d1884 4
a1887 3
	 * with the lowest value. The adapter which we take the MAC
	 * address from does not need to be part of the bridge, it just
	 * needs to be a unique value. It is not possible for mif to be
d1891 1
a1891 3
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_type != IFT_ETHER)
			continue;
d1893 1
a1893 1
			mif = ifp;
d1896 1
a1896 1
		if (bstp_addr_cmp(LLADDR(ifp->if_sadl),
d1898 1
a1898 1
			mif = ifp;
@


1.31
log
@enable tx mitigation when putting packets on the wire by switching from
calls to ifp->if_start to if_start(). these are the obviously right cases
where we can do that, the less obvious ones may follow as theyre figured
out.

deraadt@@ said to go for it
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.29 2007/10/30 09:04:47 henning Exp $	*/
d1989 1
a1989 2
	if (timeout_initialized(&bs->bs_bstptimeout) &&
	    timeout_pending(&bs->bs_bstptimeout))
@


1.30
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d405 2
a406 2
	if (error == 0 && (ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
d538 2
a539 2
	if (error == 0 && (ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
@


1.29
log
@fix a typo, LIST_FOREACH(bp2, ... and then using bp instead of bp2
inside that loop doesn't yield the expected results.
from freebsd r1.37 Andrew Thompson <thompsa@@freebsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.28 2007/10/14 12:27:35 krw Exp $	*/
d157 1
a157 1
#define	BSTP_INFO_RECIEVED	1
d739 1
a739 1
		    !bstp_pdu_bettersame(bp, BSTP_INFO_RECIEVED))
d754 1
a754 1
		bp->bp_infois = BSTP_INFO_RECIEVED;
d850 2
a851 2
	if (newinfo == BSTP_INFO_RECIEVED &&
	    bp->bp_infois == BSTP_INFO_RECIEVED &&
d921 1
a921 1
	/* check if any recieved info supersedes us */
d923 1
a923 1
		if (bp->bp_infois != BSTP_INFO_RECIEVED)
d986 1
a986 1
		case BSTP_INFO_RECIEVED:
d1818 1
a1818 1
	if (bp->bp_infois == BSTP_INFO_RECIEVED) {
@


1.28
log
@'syncronize' -> 'synchronize'. From Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.27 2007/09/15 16:43:51 henning Exp $	*/
d1036 2
a1037 2
			if (!(bp->bp_synced ||
			     bp->bp_role == BSTP_ROLE_ROOT)) {
@


1.27
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.26 2007/02/15 12:43:26 reyk Exp $	*/
d1032 1
a1032 1
	/* check if all the ports have syncronised again */
@


1.26
log
@Set topology change propagation on all ports _except_ the caller.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.25 2007/02/14 00:53:48 jsg Exp $	*/
d1943 1
a1943 2
	bs = (struct bstp_state *)malloc(sizeof(*bs), M_DEVBUF, M_WAITOK);
	bzero(bs, sizeof(*bs));
d2007 1
a2007 1
	bp = (struct bstp_port *)malloc(sizeof(*bp), M_DEVBUF, M_NOWAIT);
a2009 1
	bzero(bp, sizeof(*bp));
@


1.25
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.24 2006/12/11 22:11:48 reyk Exp $	*/
d1296 1
a1296 1
		bp->bp_tc_prop = 1;
@


1.24
log
@refer to the RSTP point to point option as "PTP" instead of "P2P".
P2P is commonly used in relation to peer to peer networks, PTP is used
in various protocols for layer 2 point to point links (ie., full
duplex ethernet links).

note that the newly added brconfig commands [-]p2p and [-]autop2p will
change to [-]ptp and [-]autoptp.

suggested by Andrew Thompson (thompsa@@freebsd.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.23 2006/12/03 13:41:19 reyk Exp $	*/
d1503 1
a1503 1
		/* FALLTROUGH */
@


1.23
log
@Add Rapid Spanning Tree Protocol support (802.1d-2004) based on work
by Andrew Thompson (thompsa@@freebsd.org). The local changes include
adoption to our bridge code, reduced stack usage and many other bits.
If stp is enabled, RSTP will now be used by default.

Thanks for help from Andrew.

This code has been in snaps for while now, commit encouraged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.21 2006/03/07 18:21:10 brad Exp $	*/
d782 1
a782 1
		if (cu->cu_agree && bp->bp_p2p_link) {
d1156 1
a1156 1
			    (bp->bp_p2p_link ? BSTP_DEFAULT_MIGRATE_DELAY :
d1685 3
a1687 3
		if (bp->bp_flags & BSTP_PORT_AUTOP2P) {
			/* A full-duplex link is assumed to be p2p */
			bp->bp_p2p_link = ifp->if_link_state ==
d2020 1
a2020 1
	bp->bp_flags = BSTP_PORT_AUTOEDGE | BSTP_PORT_AUTOP2P;
d2115 3
a2117 3
	if (flags & IFBIF_BSTP_AUTOP2P) {
		if ((bp->bp_flags & BSTP_PORT_AUTOP2P) == 0) {
			bp->bp_flags |= BSTP_PORT_AUTOP2P;
d2122 1
a2122 1
		bp->bp_flags &= ~BSTP_PORT_AUTOP2P;
d2124 2
a2125 2
	if (flags & IFBIF_BSTP_P2P)
		bp->bp_p2p_link = 1;
d2127 1
a2127 1
		bp->bp_p2p_link = 0;
@


1.22
log
@never call an ioctl without process context! this diffs checks the
ifp->if_link_state instead of calling the ifmedia ioctl. this is safe
in timeouts without process context and allows to use bridge stp with
usb ethernet devices now.

figured out and tested by Stuart Henderson, closes pr 5304.
@
text
@d5 1
d32 1
a32 2
 * ISO/IEC Final DIS 15802-3 (IEEE P802.1D/D17), May 25, 1998.
 * (In English: IEEE 802.1D, Draft 17, 1998)
d35 4
d54 1
d74 78
d154 1
d157 4
a160 3
/* BPDU flags */
#define	BSTP_FLAG_TC		0x01		/* Topology change */
#define	BSTP_FLAG_TCA		0x80		/* Topology change ack */
d164 20
d216 1
d219 3
d232 1
a232 1
u_int8_t bstp_etheraddr[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };
d234 1
a234 58
void bstp_initialization(struct bridge_softc *);
void bstp_stop(struct bridge_softc *);
void bstp_initialize_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_ifupdstatus(struct bridge_softc *, struct bridge_iflist *);
void bstp_enable_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_disable_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_enable_change_detection(struct bridge_iflist *);
void bstp_disable_change_detection(struct bridge_iflist *);
int bstp_root_bridge(struct bridge_softc *sc);
int bstp_supersedes_port_info(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_config_unit *);
int bstp_designated_port(struct bridge_softc *, struct bridge_iflist *);
int bstp_designated_for_some_port(struct bridge_softc *);
void bstp_transmit_config(struct bridge_softc *, struct bridge_iflist *);
void bstp_transmit_tcn(struct bridge_softc *);
struct mbuf *bstp_input(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void bstp_received_config_bpdu(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_config_unit *);
void bstp_received_tcn_bpdu(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_tcn_unit *);
void bstp_record_config_information(struct bridge_softc *,
    struct bridge_iflist *, struct bstp_config_unit *);
void bstp_record_config_timeout_values(struct bridge_softc *,
    struct bstp_config_unit *);
void bstp_config_bpdu_generation(struct bridge_softc *);
void bstp_send_config_bpdu(struct bridge_iflist *, struct bstp_config_unit *);
void bstp_configuration_update(struct bridge_softc *);
void bstp_root_selection(struct bridge_softc *);
void bstp_designated_port_selection(struct bridge_softc *);
void bstp_become_designated_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_port_state_selection(struct bridge_softc *);
void bstp_make_forwarding(struct bridge_softc *, struct bridge_iflist *);
void bstp_make_blocking(struct bridge_softc *, struct bridge_iflist *);
void bstp_set_port_state(struct bridge_iflist *, u_int8_t);
void bstp_set_bridge_priority(struct bridge_softc *, u_int64_t);
void bstp_set_port_priority(struct bridge_softc *, struct bridge_iflist *,
    u_int16_t);
void bstp_set_path_cost(struct bridge_softc *, struct bridge_iflist *,
    u_int32_t);
void bstp_topology_change_detection(struct bridge_softc *);
void bstp_topology_change_acknowledged(struct bridge_softc *);
void bstp_acknowledge_topology_change(struct bridge_softc *,
    struct bridge_iflist *);

void bstp_tick(void *);
void bstp_timer_start(struct bridge_timer *, u_int16_t);
void bstp_timer_stop(struct bridge_timer *);
int bstp_timer_expired(struct bridge_timer *, u_int16_t);

void bstp_hold_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
void bstp_message_age_timer_expiry(struct bridge_softc *,
    struct bridge_iflist *);
void bstp_forward_delay_timer_expiry(struct bridge_softc *,
    struct bridge_iflist *);
void bstp_topology_change_timer_expiry(struct bridge_softc *);
void bstp_tcn_timer_expiry(struct bridge_softc *);
void bstp_hello_timer_expiry(struct bridge_softc *);
d236 60
a295 4
void
bstp_transmit_config(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
d297 1
a297 31
	if (bif->bif_hold_timer.active) {
		bif->bif_config_pending = 1;
		return;
	}

	bif->bif_config_bpdu.cu_message_type = BSTP_MSGTYPE_CFG;
	bif->bif_config_bpdu.cu_rootid = sc->sc_designated_root;
	bif->bif_config_bpdu.cu_root_path_cost = sc->sc_root_path_cost;
	bif->bif_config_bpdu.cu_bridge_id = sc->sc_bridge_id;
	bif->bif_config_bpdu.cu_port_id = bif->bif_port_id;

	if (bstp_root_bridge(sc))
		bif->bif_config_bpdu.cu_message_age = 0;
	else
		bif->bif_config_bpdu.cu_message_age =
		    sc->sc_root_port->bif_message_age_timer.value +
		    BSTP_MESSAGE_AGE_INCR;

	bif->bif_config_bpdu.cu_max_age = sc->sc_max_age;
	bif->bif_config_bpdu.cu_hello_time = sc->sc_hello_time;
	bif->bif_config_bpdu.cu_forward_delay = sc->sc_forward_delay;
	bif->bif_config_bpdu.cu_topology_change_acknowledgment
	    = bif->bif_topology_change_acknowledge;
	bif->bif_config_bpdu.cu_topology_change = sc->sc_topology_change;

	if (bif->bif_config_bpdu.cu_message_age < sc->sc_max_age) {
		bif->bif_topology_change_acknowledge = 0;
		bif->bif_config_pending = 0;
		bstp_send_config_bpdu(bif, &bif->bif_config_bpdu);
		bstp_timer_start(&bif->bif_hold_timer, 0);
	}
d301 1
a301 3
bstp_send_config_bpdu(bif, cu)
	struct bridge_iflist *bif;
	struct bstp_config_unit *cu;
d303 2
a304 10
	struct arpcom *arp;
	struct ifnet *ifp;
	struct mbuf *m;
	struct ether_header eh;
	struct bstp_cbpdu bpdu;
	int s, error;

	s = splnet();
	ifp = bif->ifp;
	arp = (struct arpcom *)ifp;
d306 7
a312 9
	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		splx(s);
		return;
	}
#ifdef ALTQ
	if (!ALTQ_IS_ENABLED(&ifp->if_snd))
#endif
	if (IF_QFULL(&ifp->if_snd)) {
		splx(s);
d315 2
a316 4

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		splx(s);
a317 4
	}
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = sizeof(eh) + sizeof(bpdu);
	m->m_len = m->m_pkthdr.len;
d319 9
a327 35
	bpdu.cbu_ssap = bpdu.cbu_dsap = LLC_8021D_LSAP;
	bpdu.cbu_ctl = LLC_UI;
	bpdu.cbu_protoid = htons(0);
	bpdu.cbu_protover = 0;
	bpdu.cbu_bpdutype = cu->cu_message_type;
	bpdu.cbu_flags = (cu->cu_topology_change ? BSTP_FLAG_TC : 0) |
	    (cu->cu_topology_change_acknowledgment ? BSTP_FLAG_TCA : 0);

	bpdu.cbu_rootpri = htons(cu->cu_rootid >> 48);
	bpdu.cbu_rootaddr[0] = cu->cu_rootid >> 40;
	bpdu.cbu_rootaddr[1] = cu->cu_rootid >> 32;
	bpdu.cbu_rootaddr[2] = cu->cu_rootid >> 24;
	bpdu.cbu_rootaddr[3] = cu->cu_rootid >> 16;
	bpdu.cbu_rootaddr[4] = cu->cu_rootid >> 8;
	bpdu.cbu_rootaddr[5] = cu->cu_rootid >> 0;

	bpdu.cbu_rootpathcost = htonl(cu->cu_root_path_cost);

	bpdu.cbu_bridgepri = htons(cu->cu_bridge_id >> 48);
	bpdu.cbu_bridgeaddr[0] = cu->cu_bridge_id >> 40;
	bpdu.cbu_bridgeaddr[1] = cu->cu_bridge_id >> 32;
	bpdu.cbu_bridgeaddr[2] = cu->cu_bridge_id >> 24;
	bpdu.cbu_bridgeaddr[3] = cu->cu_bridge_id >> 16;
	bpdu.cbu_bridgeaddr[4] = cu->cu_bridge_id >> 8;
	bpdu.cbu_bridgeaddr[5] = cu->cu_bridge_id >> 0;

	bpdu.cbu_portid = htons(cu->cu_port_id);
	bpdu.cbu_messageage = htons(cu->cu_message_age);
	bpdu.cbu_maxage = htons(cu->cu_max_age);
	bpdu.cbu_hellotime = htons(cu->cu_hello_time);
	bpdu.cbu_forwarddelay = htons(cu->cu_forward_delay);

	bcopy(arp->ac_enaddr, eh.ether_shost, ETHER_ADDR_LEN);
	bcopy(bstp_etheraddr, eh.ether_dhost, ETHER_ADDR_LEN);
	eh.ether_type = htons(sizeof(bpdu));
d329 7
a335 7
	bcopy(&eh, m->m_data, sizeof(eh));
	bcopy(&bpdu, m->m_data + sizeof(eh), sizeof(bpdu));

	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error == 0 && (ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
	splx(s);
d338 2
a339 3
int
bstp_root_bridge(sc)
	struct bridge_softc *sc;
d341 1
a341 18
	return (sc->sc_designated_root == sc->sc_bridge_id);
}

int
bstp_supersedes_port_info(sc, bif, cu)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
	struct bstp_config_unit *cu;
{
	if (cu->cu_rootid < bif->bif_designated_root)
		return (1);
	if (cu->cu_rootid > bif->bif_designated_root)
		return (0);

	if (cu->cu_root_path_cost < bif->bif_designated_cost)
		return (1);
	if (cu->cu_root_path_cost > bif->bif_designated_cost)
		return (0);
d343 2
a344 4
	if (cu->cu_bridge_id < bif->bif_designated_bridge)
		return (1);
	if (cu->cu_bridge_id > bif->bif_designated_bridge)
		return (0);
d346 1
a346 6
	if (sc->sc_bridge_id != cu->cu_bridge_id)
		return (1);
	if (cu->cu_port_id <= bif->bif_designated_port)
		return (1);
	return (0);
}
d348 2
a349 12
void
bstp_record_config_information(sc, bif, cu)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
	struct bstp_config_unit *cu;
{
	bif->bif_designated_root = cu->cu_rootid;
	bif->bif_designated_cost = cu->cu_root_path_cost;
	bif->bif_designated_bridge = cu->cu_bridge_id;
	bif->bif_designated_port = cu->cu_port_id;
	bstp_timer_start(&bif->bif_message_age_timer, cu->cu_message_age);
}
d351 5
a355 10
void
bstp_record_config_timeout_values(sc, config)
	struct bridge_softc *sc;
	struct bstp_config_unit *config;
{
	sc->sc_max_age = config->cu_max_age;
	sc->sc_hello_time = config->cu_hello_time;
	sc->sc_forward_delay = config->cu_forward_delay;
	sc->sc_topology_change = config->cu_topology_change;
}
d357 1
a357 5
void
bstp_config_bpdu_generation(sc)
	struct bridge_softc *sc;
{
	struct bridge_iflist *bif;
d359 7
a365 6
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bstp_designated_port(sc, bif) &&
		    (bif->bif_state != BSTP_IFSTATE_DISABLED))
			bstp_transmit_config(sc, bif);
a366 1
}
d368 1
a368 7
int
bstp_designated_port(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
{
	return ((bif->bif_designated_bridge == sc->sc_bridge_id)
	    && (bif->bif_designated_port == bif->bif_port_id));
d372 1
a372 2
bstp_transmit_tcn(sc)
	struct bridge_softc *sc;
d375 1
a375 3
	struct bridge_iflist *bif = sc->sc_root_port;
	struct ifnet *ifp = bif->ifp;
	struct arpcom *arp = (struct arpcom *)ifp;
d378 1
a378 1
	int s, error;
d380 1
a380 1
	if ((ifp->if_flags & IFF_RUNNING) == 0)
d391 1
a391 1
	bcopy(arp->ac_enaddr, eh->ether_shost, ETHER_ADDR_LEN);
d400 1
a400 1
	bcopy(&bpdu, m->m_data + sizeof(*eh), sizeof(bpdu));
d403 1
a406 1
	m = NULL;
d411 2
a412 2
bstp_configuration_update(sc)
	struct bridge_softc *sc;
d414 66
a479 2
	bstp_root_selection(sc);
	bstp_designated_port_selection(sc);
d483 2
a484 2
bstp_root_selection(sc)
	struct bridge_softc *sc;
d486 8
a493 1
	struct bridge_iflist *root_port = NULL, *bif;
d495 5
a499 11
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bstp_designated_port(sc, bif))
			continue;
		if (bif->bif_state == BSTP_IFSTATE_DISABLED)
			continue;
		if (bif->bif_designated_root >= sc->sc_bridge_id)
			continue;
		if (root_port == NULL)
			goto set_port;
d501 3
a503 4
		if (bif->bif_designated_root < root_port->bif_designated_root)
			goto set_port;
		if (bif->bif_designated_root > root_port->bif_designated_root)
			continue;
d505 1
a505 6
		if ((bif->bif_designated_cost + bif->bif_path_cost) <
		    (root_port->bif_designated_cost + root_port->bif_path_cost))
			goto set_port;
		if ((bif->bif_designated_cost + bif->bif_path_cost) >
		    (root_port->bif_designated_cost + root_port->bif_path_cost))
			continue;
d507 3
a509 4
		if (bif->bif_designated_bridge < root_port->bif_designated_bridge)
			goto set_port;
		if (bif->bif_designated_bridge > root_port->bif_designated_bridge)
			continue;
d511 2
a512 4
		if (bif->bif_designated_port < root_port->bif_designated_port)
			goto set_port;
		if (bif->bif_designated_port > root_port->bif_designated_port)
			continue;
d514 18
a531 4
		if (bif->bif_port_id >= root_port->bif_port_id)
			continue;
set_port:
		root_port = bif;
d533 2
d536 6
a541 9
	sc->sc_root_port = root_port;
	if (root_port == NULL) {
		sc->sc_designated_root = sc->sc_bridge_id;
		sc->sc_root_path_cost = 0;
	} else {
		sc->sc_designated_root = root_port->bif_designated_root;
		sc->sc_root_path_cost = root_port->bif_designated_cost +
		    root_port->bif_path_cost;
	}
d544 2
a545 3
void
bstp_designated_port_selection(sc)
	struct bridge_softc *sc;
d547 1
a547 14
	struct bridge_iflist *bif;

	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bstp_designated_port(sc, bif))
			goto designated;
		if (bif->bif_designated_root != sc->sc_designated_root)
			goto designated;

		if (sc->sc_root_path_cost < bif->bif_designated_cost)
			goto designated;
		if (sc->sc_root_path_cost > bif->bif_designated_cost)
			continue;
d549 2
a550 4
		if (sc->sc_bridge_id < bif->bif_designated_bridge)
			goto designated;
		if (sc->sc_bridge_id > bif->bif_designated_bridge)
			continue;
d552 2
a553 6
		if (bif->bif_port_id > bif->bif_designated_port)
			continue;
designated:
		bstp_become_designated_port(sc, bif);
	}
}
d555 2
a556 10
void
bstp_become_designated_port(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
{
	bif->bif_designated_root = sc->sc_designated_root;
	bif->bif_designated_cost = sc->sc_root_path_cost;
	bif->bif_designated_bridge = sc->sc_bridge_id;
	bif->bif_designated_port = bif->bif_port_id;
}
d558 2
a559 5
void
bstp_port_state_selection(sc)
	struct bridge_softc *sc;
{
	struct bridge_iflist *bif;
d561 7
a567 15
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bif == sc->sc_root_port) {
			bif->bif_config_pending = 0;
			bif->bif_topology_change_acknowledge = 0;
			bstp_make_forwarding(sc, bif);
		} else if (bstp_designated_port(sc, bif)) {
			bstp_timer_stop(&bif->bif_message_age_timer);
			bstp_make_forwarding(sc, bif);
		} else {
			bif->bif_config_pending = 0;
			bif->bif_topology_change_acknowledge = 0;
			bstp_make_blocking(sc, bif);
		}
a568 1
}
d570 11
a580 8
void
bstp_make_forwarding(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
{
	if (bif->bif_state == BSTP_IFSTATE_BLOCKING) {
		bstp_set_port_state(bif, BSTP_IFSTATE_LISTENING);
		bstp_timer_start(&bif->bif_forward_delay_timer, 0);
a581 1
}
d583 8
a590 37
void
bstp_make_blocking(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
{
	if ((bif->bif_state != BSTP_IFSTATE_DISABLED) &&
	    (bif->bif_state != BSTP_IFSTATE_BLOCKING)) {
		if ((bif->bif_state == BSTP_IFSTATE_FORWARDING) ||
		    (bif->bif_state == BSTP_IFSTATE_LEARNING)) {
			if (bif->bif_change_detection_enabled) {
				bstp_topology_change_detection(sc);
			}
			bridge_rtdelete(sc, bif->ifp, 1);
		}
		bstp_set_port_state(bif, BSTP_IFSTATE_BLOCKING);
		bstp_timer_stop(&bif->bif_forward_delay_timer);
	}
}

void
bstp_set_port_state(bif, state)
	struct bridge_iflist *bif;
	u_int8_t state;
{
	bif->bif_state = state;
}

void
bstp_topology_change_detection(sc)
	struct bridge_softc *sc;
{
	if (bstp_root_bridge(sc)) {
		sc->sc_topology_change = 1;
		bstp_timer_start(&sc->sc_topology_change_timer, 0);
	} else if (!sc->sc_topology_change_detected) {
		bstp_transmit_tcn(sc);
		bstp_timer_start(&sc->sc_tcn_timer, 0);
d592 1
a592 18
	sc->sc_topology_change_detected = 1;
}

void
bstp_topology_change_acknowledged(sc)
	struct bridge_softc *sc;
{
	sc->sc_topology_change_detected = 0;
	bstp_timer_stop(&sc->sc_tcn_timer);
}

void
bstp_acknowledge_topology_change(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
{
	bif->bif_topology_change_acknowledge = 1;
	bstp_transmit_config(sc, bif);
d596 2
a597 5
bstp_input(sc, ifp, eh, m)
	struct bridge_softc *sc;
	struct ifnet *ifp;
	struct ether_header *eh;
	struct mbuf *m;
a598 1
	struct bridge_iflist *bif = NULL;
a599 3
	struct bstp_cbpdu cpdu;
	struct bstp_config_unit cu;
	struct bstp_tcn_unit tu;
d602 1
a602 7
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bif->ifp == ifp)
			break;
	}
	if (bif == NULL)
d618 1
a618 1
	if (tpdu.tbu_protoid != 0 || tpdu.tbu_protover != 0)
d621 15
a635 7
	switch (tpdu.tbu_bpdutype) {
	case BSTP_MSGTYPE_TCN:
		tu.tu_message_type = tpdu.tbu_bpdutype;
		bstp_received_tcn_bpdu(sc, bif, &tu);
		break;
	case BSTP_MSGTYPE_CFG:
		if ((m = m_pullup(m, sizeof(cpdu))) == NULL)
d637 1
a637 1
		bcopy(mtod(m, struct bstp_cpdu *), &cpdu, sizeof(cpdu));
d639 11
a649 30
		cu.cu_rootid =
		    (((u_int64_t)ntohs(cpdu.cbu_rootpri)) << 48) |
		    (((u_int64_t)cpdu.cbu_rootaddr[0]) << 40) |
		    (((u_int64_t)cpdu.cbu_rootaddr[1]) << 32) |
		    (((u_int64_t)cpdu.cbu_rootaddr[2]) << 24) |
		    (((u_int64_t)cpdu.cbu_rootaddr[3]) << 16) |
		    (((u_int64_t)cpdu.cbu_rootaddr[4]) << 8) |
		    (((u_int64_t)cpdu.cbu_rootaddr[5]) << 0);

		cu.cu_bridge_id =
		    (((u_int64_t)ntohs(cpdu.cbu_bridgepri)) << 48) |
		    (((u_int64_t)cpdu.cbu_bridgeaddr[0]) << 40) |
		    (((u_int64_t)cpdu.cbu_bridgeaddr[1]) << 32) |
		    (((u_int64_t)cpdu.cbu_bridgeaddr[2]) << 24) |
		    (((u_int64_t)cpdu.cbu_bridgeaddr[3]) << 16) |
		    (((u_int64_t)cpdu.cbu_bridgeaddr[4]) << 8) |
		    (((u_int64_t)cpdu.cbu_bridgeaddr[5]) << 0);

		cu.cu_root_path_cost = ntohl(cpdu.cbu_rootpathcost);
		cu.cu_message_age = ntohs(cpdu.cbu_messageage);
		cu.cu_max_age = ntohs(cpdu.cbu_maxage);
		cu.cu_hello_time = ntohs(cpdu.cbu_hellotime);
		cu.cu_forward_delay = ntohs(cpdu.cbu_forwarddelay);
		cu.cu_port_id = ntohs(cpdu.cbu_portid);
		cu.cu_message_type = cpdu.cbu_bpdutype;
		cu.cu_topology_change_acknowledgment =
		    (cpdu.cbu_flags & BSTP_FLAG_TCA) ? 1 : 0;
		cu.cu_topology_change =
		    (cpdu.cbu_flags & BSTP_FLAG_TC) ? 1 : 0;
		bstp_received_config_bpdu(sc, bif, &cu);
a650 2
	default:
		goto out;
d652 1
a652 2

out:
d659 2
a660 4
bstp_received_config_bpdu(sc, bif, cu)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
	struct bstp_config_unit *cu;
d662 3
a664 1
	int root;
d666 10
a675 1
	root = bstp_root_bridge(sc);
d677 3
a679 25
	if (bif->bif_state != BSTP_IFSTATE_DISABLED) {
		if (bstp_supersedes_port_info(sc, bif, cu)) {
			bstp_record_config_information(sc, bif, cu);
			bstp_configuration_update(sc);
			bstp_port_state_selection(sc);

			if ((!bstp_root_bridge(sc)) && root) {
				bstp_timer_stop(&sc->sc_hello_timer);

				if (sc->sc_topology_change_detected) {
					bstp_timer_stop(&sc->sc_topology_change_timer);
					bstp_transmit_tcn(sc);
					bstp_timer_start(&sc->sc_tcn_timer, 0);
				}
			}

			if (bif == sc->sc_root_port) {
				bstp_record_config_timeout_values(sc, cu);
				bstp_config_bpdu_generation(sc);

				if (cu->cu_topology_change_acknowledgment)
					bstp_topology_change_acknowledged(sc);
			}
		} else if (bstp_designated_port(sc, bif))
			bstp_transmit_config(sc, bif);
d684 2
a685 4
bstp_received_tcn_bpdu(sc, bif, tcn)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
	struct bstp_tcn_unit *tcn;
d687 13
a699 5
	if (bif->bif_state != BSTP_IFSTATE_DISABLED &&
	    bstp_designated_port(sc, bif)) {
		bstp_topology_change_detection(sc);
		bstp_acknowledge_topology_change(sc, bif);
	}
d703 2
a704 2
bstp_hello_timer_expiry(sc)
	struct bridge_softc *sc;
d706 2
a707 2
	bstp_config_bpdu_generation(sc);
	bstp_timer_start(&sc->sc_hello_timer, 0);
d711 2
a712 3
bstp_message_age_timer_expiry(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
d714 55
a768 1
	int root;
d770 6
a775 4
	root = bstp_root_bridge(sc);
	bstp_become_designated_port(sc, bif);
	bstp_configuration_update(sc);
	bstp_port_state_selection(sc);
d777 16
a792 4
	if ((bstp_root_bridge(sc)) && (!root)) {
		sc->sc_max_age = sc->sc_bridge_max_age;
		sc->sc_hello_time = sc->sc_bridge_hello_time;
		sc->sc_forward_delay = sc->sc_bridge_forward_delay;
d794 2
a795 4
		bstp_topology_change_detection(sc);
		bstp_timer_stop(&sc->sc_tcn_timer);
		bstp_config_bpdu_generation(sc);
		bstp_timer_start(&sc->sc_hello_timer, 0);
d797 3
d802 2
a803 4
void
bstp_forward_delay_timer_expiry(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
d805 37
a841 8
	if (bif->bif_state == BSTP_IFSTATE_LISTENING) {
		bstp_set_port_state(bif, BSTP_IFSTATE_LEARNING);
		bstp_timer_start(&bif->bif_forward_delay_timer, 0);
	} else if (bif->bif_state == BSTP_IFSTATE_LEARNING) {
		bstp_set_port_state(bif, BSTP_IFSTATE_FORWARDING);
		if (bstp_designated_for_some_port(sc) &&
		    bif->bif_change_detection_enabled)
			bstp_topology_change_detection(sc);
d843 2
d848 1
a848 2
bstp_designated_for_some_port(sc)
	struct bridge_softc *sc;
d850 4
d855 4
a858 1
	struct bridge_iflist *bif;
a859 6
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bif->bif_designated_bridge == sc->sc_bridge_id)
			return (1);
	}
d863 36
a898 3
void
bstp_tcn_timer_expiry(sc)
	struct bridge_softc *sc;
d900 5
a904 2
	bstp_transmit_tcn(sc);
	bstp_timer_start(&sc->sc_tcn_timer, 0);
d908 1
a908 2
bstp_topology_change_timer_expiry(sc)
	struct bridge_softc *sc;
d910 114
a1023 2
	sc->sc_topology_change_detected = 0;
	sc->sc_topology_change = 0;
d1027 1
a1027 3
bstp_hold_timer_expiry(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
d1029 18
a1046 2
	if (bif->bif_config_pending)
		bstp_transmit_config(sc, bif);
d1050 1
a1050 2
bstp_initialization(sc)
	struct bridge_softc *sc;
d1052 27
a1078 2
	struct bridge_iflist *bif, *mif;
	struct arpcom *ac, *mac;
d1080 81
a1160 8
	mif = NULL; mac = NULL;
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bif->ifp->if_type != IFT_ETHER)
			continue;
		bif->bif_port_id = (bif->bif_priority << 8) |
		    (bif->ifp->if_index & 0xff);
d1162 18
a1179 4
		if (mif == NULL) {
			mif = bif;
			mac = (struct arpcom *)bif->ifp;
			continue;
d1181 12
a1192 5
		ac = (struct arpcom *)bif->ifp;
		if (memcmp(ac->ac_enaddr, mac->ac_enaddr, ETHER_ADDR_LEN) < 0) {
			mif = bif;
			mac = (struct arpcom *)bif->ifp;
			continue;
d1194 1
a1194 4
	}
	if (mif == NULL) {
		bstp_stop(sc);
		return;
d1197 57
a1253 31
	sc->sc_bridge_id =
	    (((u_int64_t)sc->sc_bridge_priority) << 48) |
	    (((u_int64_t)mac->ac_enaddr[0]) << 40) |
	    (((u_int64_t)mac->ac_enaddr[1]) << 32) |
	    ((unsigned int)mac->ac_enaddr[2] << 24) |
	    ((unsigned int)mac->ac_enaddr[3] << 16) |
	    ((unsigned int)mac->ac_enaddr[4] << 8) |
	    ((unsigned int)mac->ac_enaddr[5]);

	sc->sc_designated_root = sc->sc_bridge_id;
	sc->sc_root_path_cost = 0;
	sc->sc_root_port = NULL;

	sc->sc_max_age = sc->sc_bridge_max_age;
	sc->sc_hello_time = sc->sc_bridge_hello_time;
	sc->sc_forward_delay = sc->sc_bridge_forward_delay;
	sc->sc_topology_change_detected = 0;
	sc->sc_topology_change = 0;
	bstp_timer_stop(&sc->sc_tcn_timer);
	bstp_timer_stop(&sc->sc_topology_change_timer);

	if (!timeout_initialized(&sc->sc_bstptimeout))
		timeout_set(&sc->sc_bstptimeout, bstp_tick, sc);
	if (!timeout_pending(&sc->sc_bstptimeout))
		timeout_add(&sc->sc_bstptimeout, hz);

	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (bif->bif_flags & IFBIF_STP)
			bstp_enable_port(sc, bif);
		else
			bstp_disable_port(sc, bif);
a1255 3
	bstp_port_state_selection(sc);
	bstp_config_bpdu_generation(sc);
	bstp_timer_start(&sc->sc_hello_timer, 0);
d1259 1
a1259 2
bstp_stop(sc)
	struct bridge_softc *sc;
d1261 4
d1266 2
a1267 1
	struct bridge_iflist *bif;
d1269 3
a1271 5
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		bstp_set_port_state(bif, BSTP_IFSTATE_DISABLED);
		bstp_timer_stop(&bif->bif_hold_timer);
		bstp_timer_stop(&bif->bif_message_age_timer);
		bstp_timer_stop(&bif->bif_forward_delay_timer);
d1274 11
a1284 3
	if (timeout_initialized(&sc->sc_bstptimeout) &&
	    timeout_pending(&sc->sc_bstptimeout))
		timeout_del(&sc->sc_bstptimeout);
d1286 6
a1291 3
	bstp_timer_stop(&sc->sc_topology_change_timer);
	bstp_timer_stop(&sc->sc_tcn_timer);
	bstp_timer_stop(&sc->sc_hello_timer);
d1293 5
d1301 1
a1301 3
bstp_initialize_port(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
d1303 4
a1306 8
	bstp_become_designated_port(sc, bif);
	bstp_set_port_state(bif, BSTP_IFSTATE_BLOCKING);
	bif->bif_topology_change_acknowledge = 0;
	bif->bif_config_pending = 0;
	bstp_enable_change_detection(bif);
	bstp_timer_stop(&bif->bif_message_age_timer);
	bstp_timer_stop(&bif->bif_forward_delay_timer);
	bstp_timer_stop(&bif->bif_hold_timer);
d1310 1
a1310 3
bstp_enable_port(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
d1312 8
a1319 2
	bstp_initialize_port(sc, bif);
	bstp_port_state_selection(sc);
d1323 1
a1323 3
bstp_disable_port(sc, bif)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
d1325 2
a1326 1
	int root;
d1328 1
a1328 10
	root = bstp_root_bridge(sc);
	bstp_become_designated_port(sc, bif);
	bstp_set_port_state(bif, BSTP_IFSTATE_DISABLED);
	bif->bif_topology_change_acknowledge = 0;
	bif->bif_config_pending = 0;
	bstp_timer_stop(&bif->bif_message_age_timer);
	bstp_timer_stop(&bif->bif_forward_delay_timer);
	bstp_configuration_update(sc);
	bstp_port_state_selection(sc);
	bridge_rtdelete(sc, bif->ifp, 1);
d1330 14
a1343 4
	if (bstp_root_bridge(sc) && (!root))	{
		sc->sc_max_age = sc->sc_bridge_max_age;
		sc->sc_hello_time = sc->sc_bridge_hello_time;
		sc->sc_forward_delay = sc->sc_bridge_forward_delay;
d1345 8
a1352 4
		bstp_topology_change_detection(sc);
		bstp_timer_stop(&sc->sc_tcn_timer);
		bstp_config_bpdu_generation(sc);
		bstp_timer_start(&sc->sc_hello_timer, 0);
d1357 1
a1357 3
bstp_set_bridge_priority(sc, new_bridge_id)
	struct bridge_softc *sc;
	u_int64_t new_bridge_id;
d1359 11
a1369 2
	int root;
	struct bridge_iflist *bif;
d1371 11
a1381 1
	root = bstp_root_bridge(sc);
d1383 4
a1386 5
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bstp_designated_port(sc, bif))
			bif->bif_designated_bridge = new_bridge_id;
d1389 19
a1407 1
	sc->sc_bridge_id = new_bridge_id;
d1409 7
a1415 2
	bstp_configuration_update(sc);
	bstp_port_state_selection(sc);
d1417 8
a1424 4
	if (bstp_root_bridge(sc) && (!root)) {
		sc->sc_max_age = sc->sc_bridge_max_age;
		sc->sc_hello_time = sc->sc_bridge_hello_time;
		sc->sc_forward_delay = sc->sc_bridge_forward_delay;
d1426 26
a1451 4
		bstp_topology_change_detection(sc);
		bstp_timer_stop(&sc->sc_tcn_timer);
		bstp_config_bpdu_generation(sc);
		bstp_timer_start(&sc->sc_hello_timer, 0);
d1453 3
d1459 1
a1459 4
bstp_set_port_priority(sc, bif, new_port_id)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
	u_int16_t new_port_id;
d1461 1
a1461 2
	if (bstp_designated_port(sc, bif))
		bif->bif_designated_port = new_port_id;
d1463 25
a1487 1
	bif->bif_port_id = new_port_id;
d1489 42
a1530 4
	if ((sc->sc_bridge_id == bif->bif_designated_bridge) &&
	    (bif->bif_port_id < bif->bif_designated_port)) {
		bstp_become_designated_port(sc, bif);
		bstp_port_state_selection(sc);
d1535 1
a1535 4
bstp_set_path_cost(sc, bif, path_cost)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
	u_int32_t path_cost;
d1537 16
a1552 3
	bif->bif_path_cost = path_cost;
	bstp_configuration_update(sc);
	bstp_port_state_selection(sc);
d1556 1
a1556 2
bstp_enable_change_detection(bif)
	struct bridge_iflist *bif;
d1558 53
a1610 1
	bif->bif_change_detection_enabled = 1;
d1614 1
a1614 2
bstp_disable_change_detection(bif)
	struct bridge_iflist *bif;
d1616 20
a1635 1
	bif->bif_change_detection_enabled = 0;
d1639 3
a1641 1
bstp_ifupdstatus(sc, bif)
d1643 32
a1674 1
	struct bridge_iflist *bif;
d1676 6
a1681 1
	struct ifnet *ifp = bif->ifp;
d1685 8
a1692 2
		if (bif->bif_state == BSTP_IFSTATE_DISABLED)
			bstp_enable_port(sc, bif);
d1694 2
a1695 2
		if (bif->bif_state != BSTP_IFSTATE_DISABLED)
			bstp_disable_port(sc, bif);
d1700 1
a1700 2
bstp_tick(vsc)
	void *vsc;
d1702 17
a1718 2
	struct bridge_softc *sc = vsc;
	struct bridge_iflist *bif;
d1722 4
d1727 5
a1731 4
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		bstp_ifupdstatus(sc, bif);
d1734 9
a1742 2
	if (bstp_timer_expired(&sc->sc_hello_timer, sc->sc_hello_time))
		bstp_hello_timer_expiry(sc);
d1744 2
a1745 2
	if (bstp_timer_expired(&sc->sc_tcn_timer, sc->sc_bridge_hello_time))
		bstp_tcn_timer_expiry(sc);
d1747 2
a1748 3
	if (bstp_timer_expired(&sc->sc_topology_change_timer,
	    sc->sc_topology_change_time))
		bstp_topology_change_timer_expiry(sc);
d1750 2
a1751 7
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bstp_timer_expired(&bif->bif_message_age_timer,
		    sc->sc_max_age))
			bstp_message_age_timer_expiry(sc, bif);
	}
d1753 2
a1754 6
	LIST_FOREACH(bif, &sc->sc_iflist, next) {
		if (!(bif->bif_flags & IFBIF_STP))
			continue;
		if (bstp_timer_expired(&bif->bif_forward_delay_timer,
		    sc->sc_forward_delay))
			bstp_forward_delay_timer_expiry(sc, bif);
d1756 2
a1757 3
		if (bstp_timer_expired(&bif->bif_hold_timer,
		    sc->sc_hold_time))
			bstp_hold_timer_expiry(sc, bif);
d1760 2
a1761 2
	if (sc->sc_if.if_flags & IFF_RUNNING)
		timeout_add(&sc->sc_bstptimeout, hz);
d1767 1
a1767 3
bstp_timer_start(t, v)
	struct bridge_timer *t;
	u_int16_t v;
d1771 1
d1775 1
a1775 2
bstp_timer_stop(t)
	struct bridge_timer *t;
d1779 8
d1790 1
a1790 3
bstp_timer_expired(t, v)
	struct bridge_timer *t;
	u_int16_t v;
d1792 1
a1792 1
	if (!t->active)
d1794 2
a1795 2
	t->value += BSTP_TICK_VAL;
	if (t->value >= v) {
d1800 1
d1802 36
d1841 291
a2131 4
bstp_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t	data;
d2134 7
a2140 2
	struct ifbrparam *bp = (struct ifbrparam *)data;
	int r = 0, err = 0;
d2143 24
a2166 2
	case SIOCBRDGGPRI:
		bp->ifbrp_prio = sc->sc_bridge_priority;
d2168 1
a2168 2
	case SIOCBRDGGMA:
		bp->ifbrp_maxage = sc->sc_bridge_max_age >> 8;
d2170 7
a2176 5
	case SIOCBRDGGHT:
		bp->ifbrp_hellotime = sc->sc_bridge_hello_time >> 8;
		break;
	case SIOCBRDGGFD:
		bp->ifbrp_fwddelay = sc->sc_bridge_forward_delay >> 8;
d2179 9
a2187 1
		sc->sc_bridge_priority = bp->ifbrp_prio;
d2190 3
d2194 6
a2199 1
		if (bp->ifbrp_maxage == 0) {
d2203 1
a2203 1
		sc->sc_bridge_max_age = bp->ifbrp_maxage << 8;
d2206 3
d2210 11
a2220 1
		if (bp->ifbrp_hellotime == 0) {
d2224 1
a2224 1
		sc->sc_bridge_hello_time = bp->ifbrp_hellotime << 8;
d2227 3
d2231 7
a2237 1
		if (bp->ifbrp_fwddelay == 0) {
d2241 1
a2241 1
		sc->sc_bridge_forward_delay = bp->ifbrp_fwddelay << 8;
d2244 11
a2254 3
	case SIOCBRDGADD:
	case SIOCBRDGDEL:
	case SIOCBRDGSIFFLGS:
d2256 9
d2266 12
d2280 24
d2309 1
a2309 1
		bstp_initialization(sc);
a2312 1

@


1.21
log
@use the cu_bridge_id rather than the cu_rootid for the bridge address.

From: Onno Molenkamp via Andrew Thompson <thompsa at freebsd dot org>

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.20 2006/03/04 22:40:15 brad Exp $	*/
a1090 23
	struct ifmediareq ifmr;
	int err;

	if (ifp->if_flags & IFF_UP) {
		ifmr.ifm_count = 0;
		err = (*ifp->if_ioctl)(ifp, SIOCGIFMEDIA, (caddr_t)&ifmr);
		if (err) {
			if (bif->bif_state == BSTP_IFSTATE_DISABLED)
				bstp_enable_port(sc, bif);
			return;
		}

		if (!(ifmr.ifm_status & IFM_AVALID)) {
			if (bif->bif_state == BSTP_IFSTATE_DISABLED)
				bstp_enable_port(sc, bif);
			return;
		}

		if (ifmr.ifm_status & IFM_ACTIVE) {
			if (bif->bif_state == BSTP_IFSTATE_DISABLED)
				bstp_enable_port(sc, bif);
			return;
		}
d1092 5
a1098 2

		return;
a1099 3

	if (bif->bif_state != BSTP_IFSTATE_DISABLED)
		bstp_disable_port(sc, bif);
@


1.20
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.19 2005/10/12 15:17:18 markus Exp $	*/
d277 7
a283 7
	bpdu.cbu_bridgepri = htons(cu->cu_rootid >> 48);
	bpdu.cbu_bridgeaddr[0] = cu->cu_rootid >> 40;
	bpdu.cbu_bridgeaddr[1] = cu->cu_rootid >> 32;
	bpdu.cbu_bridgeaddr[2] = cu->cu_rootid >> 24;
	bpdu.cbu_bridgeaddr[3] = cu->cu_rootid >> 16;
	bpdu.cbu_bridgeaddr[4] = cu->cu_rootid >> 8;
	bpdu.cbu_bridgeaddr[5] = cu->cu_rootid >> 0;
@


1.19
log
@no need to call mfree() since m is always NULL; from Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.18 2005/06/07 17:53:44 deraadt Exp $	*/
d234 1
a234 1
	s = splimp();
d421 1
a421 1
	s = splimp();
@


1.19.2.1
log
@MFC:
Fix by brad@@

use the cu_bridge_id rather than the cu_rootid for the bridge address.

From: Onno Molenkamp via Andrew Thompson <thompsa at freebsd dot org>
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.19 2005/10/12 15:17:18 markus Exp $	*/
d277 7
a283 7
	bpdu.cbu_bridgepri = htons(cu->cu_bridge_id >> 48);
	bpdu.cbu_bridgeaddr[0] = cu->cu_bridge_id >> 40;
	bpdu.cbu_bridgeaddr[1] = cu->cu_bridge_id >> 32;
	bpdu.cbu_bridgeaddr[2] = cu->cu_bridge_id >> 24;
	bpdu.cbu_bridgeaddr[3] = cu->cu_bridge_id >> 16;
	bpdu.cbu_bridgeaddr[4] = cu->cu_bridge_id >> 8;
	bpdu.cbu_bridgeaddr[5] = cu->cu_bridge_id >> 0;
@


1.18
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.17 2005/06/07 17:42:58 deraadt Exp $	*/
a425 1

a426 2
	if (m != NULL)
		m_freem(m);
@


1.18.2.1
log
@MFC:
Fix by brad@@

use the cu_bridge_id rather than the cu_rootid for the bridge address.

From: Onno Molenkamp via Andrew Thompson <thompsa at freebsd dot org>
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.18 2005/06/07 17:53:44 deraadt Exp $	*/
d277 7
a283 7
	bpdu.cbu_bridgepri = htons(cu->cu_bridge_id >> 48);
	bpdu.cbu_bridgeaddr[0] = cu->cu_bridge_id >> 40;
	bpdu.cbu_bridgeaddr[1] = cu->cu_bridge_id >> 32;
	bpdu.cbu_bridgeaddr[2] = cu->cu_bridge_id >> 24;
	bpdu.cbu_bridgeaddr[3] = cu->cu_bridge_id >> 16;
	bpdu.cbu_bridgeaddr[4] = cu->cu_bridge_id >> 8;
	bpdu.cbu_bridgeaddr[5] = cu->cu_bridge_id >> 0;
@


1.17
log
@avoid retarded C unsigned char -> signed integer promotion rules.
mac->ac_enaddr[2] << 24 resulted in sign extension smashing other stuff
djast@@cs.toronto.edu, ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.16 2003/11/16 20:30:07 avsm Exp $	*/
d900 3
a902 3
	    (((unsigned int)mac->ac_enaddr[3] << 16) |
	    (((unsigned int)mac->ac_enaddr[4] << 8) |
	    (((unsigned int)mac->ac_enaddr[5]);
@


1.16
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.15 2003/06/02 18:42:56 jason Exp $	*/
d899 4
a902 2
	    (mac->ac_enaddr[2] << 24) | (mac->ac_enaddr[3] << 16) |
	    (mac->ac_enaddr[4] << 8) | (mac->ac_enaddr[5]);
@


1.15
log
@nuke clause 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.14 2002/12/10 13:22:55 markus Exp $	*/
d111 1
a111 1
} __attribute__((__packed__));
d121 1
a121 1
} __attribute__((__packed__));
@


1.14
log
@check IFF_RUNNING early in bstp_transmit_tcn; from netbsd; ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.13 2002/12/09 18:56:14 deraadt Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.12 2002/12/09 10:11:52 markus Exp $	*/
d404 3
a426 2
	if ((ifp->if_flags & IFF_RUNNING) == 0)
		goto out;
a431 1
out:
@


1.12
log
@allow setting of ifcost with brconfig.  enables selection of preferred
port/path to root bridge among several LANs.   unlike ifpriority, which
allows you to select designated port if serveral interfaces belong
to the same LAN;  ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.11 2002/12/04 15:44:21 markus Exp $	*/
d139 2
a140 1
int bstp_supersedes_port_info(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
d147 8
a154 4
void bstp_received_config_bpdu(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
void bstp_received_tcn_bpdu(struct bridge_softc *, struct bridge_iflist *, struct bstp_tcn_unit *);
void bstp_record_config_information(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
void bstp_record_config_timeout_values(struct bridge_softc *, struct bstp_config_unit *);
d166 4
a169 2
void bstp_set_port_priority(struct bridge_softc *, struct bridge_iflist *, u_int16_t);
void bstp_set_path_cost(struct bridge_softc *, struct bridge_iflist *, u_int32_t);
d172 2
a173 1
void bstp_acknowledge_topology_change(struct bridge_softc *, struct bridge_iflist *);
d181 4
a184 2
void bstp_message_age_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
void bstp_forward_delay_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
d694 1
a694 1
		    
d760 1
a760 2
		}
		else if (bstp_designated_port(sc, bif))
d773 2
a774 2
			bstp_topology_change_detection(sc);
			bstp_acknowledge_topology_change(sc, bif);
@


1.11
log
@spanning tree: flush dynamic mac cache if interface goes to the
blocking or disabled state.  send packets only if interface is the
forwarding state; comment from netbsd; with and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.10 2002/11/26 17:34:43 jason Exp $	*/
d1262 1
@


1.10
log
@Call the enable function, don't set the variable directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.9 2002/09/24 19:52:20 jason Exp $	*/
d581 1
d991 1
@


1.9
log
@sizeof(structure) not sizeof(structure *); pointed out by dvamsi@@yahoo.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.8 2002/03/14 01:27:09 millert Exp $	*/
d959 1
a959 1
	bif->bif_change_detection_enabled = 1;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.7 2001/06/27 06:07:37 kjc Exp $	*/
d398 1
a398 1
	m->m_pkthdr.len = sizeof(eh) + sizeof(bpdu);
d411 1
a411 1
	bcopy(&bpdu, m->m_data + sizeof(eh), sizeof(bpdu));
@


1.7
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.6 2001/05/30 02:12:23 deraadt Exp $	*/
d130 48
a177 48
void bstp_initialization __P((struct bridge_softc *));
void bstp_stop __P((struct bridge_softc *));
void bstp_initialize_port __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_ifupdstatus __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_enable_port __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_disable_port __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_enable_change_detection __P((struct bridge_iflist *));
void bstp_disable_change_detection __P((struct bridge_iflist *));
int bstp_root_bridge __P((struct bridge_softc *sc));
int bstp_supersedes_port_info __P((struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *));
int bstp_designated_port __P((struct bridge_softc *, struct bridge_iflist *));
int bstp_designated_for_some_port __P((struct bridge_softc *));
void bstp_transmit_config __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_transmit_tcn __P((struct bridge_softc *));
struct mbuf *bstp_input __P((struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *));
void bstp_received_config_bpdu __P((struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *));
void bstp_received_tcn_bpdu __P((struct bridge_softc *, struct bridge_iflist *, struct bstp_tcn_unit *));
void bstp_record_config_information __P((struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *));
void bstp_record_config_timeout_values __P((struct bridge_softc *, struct bstp_config_unit *));
void bstp_config_bpdu_generation __P((struct bridge_softc *));
void bstp_send_config_bpdu __P((struct bridge_iflist *, struct bstp_config_unit *));
void bstp_configuration_update __P((struct bridge_softc *));
void bstp_root_selection __P((struct bridge_softc *));
void bstp_designated_port_selection __P((struct bridge_softc *));
void bstp_become_designated_port __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_port_state_selection __P((struct bridge_softc *));
void bstp_make_forwarding __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_make_blocking __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_set_port_state __P((struct bridge_iflist *, u_int8_t));
void bstp_set_bridge_priority __P((struct bridge_softc *, u_int64_t));
void bstp_set_port_priority __P((struct bridge_softc *, struct bridge_iflist *, u_int16_t));
void bstp_set_path_cost __P((struct bridge_softc *, struct bridge_iflist *, u_int32_t));
void bstp_topology_change_detection __P((struct bridge_softc *));
void bstp_topology_change_acknowledged __P((struct bridge_softc *));
void bstp_acknowledge_topology_change __P((struct bridge_softc *, struct bridge_iflist *));

void bstp_tick __P((void *));
void bstp_timer_start __P((struct bridge_timer *, u_int16_t));
void bstp_timer_stop __P((struct bridge_timer *));
int bstp_timer_expired __P((struct bridge_timer *, u_int16_t));

void bstp_hold_timer_expiry __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_message_age_timer_expiry __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_forward_delay_timer_expiry __P((struct bridge_softc *, struct bridge_iflist *));
void bstp_topology_change_timer_expiry __P((struct bridge_softc *));
void bstp_tcn_timer_expiry __P((struct bridge_softc *));
void bstp_hello_timer_expiry __P((struct bridge_softc *));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.7 2001/06/27 06:07:37 kjc Exp $	*/
d130 48
a177 48
void bstp_initialization(struct bridge_softc *);
void bstp_stop(struct bridge_softc *);
void bstp_initialize_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_ifupdstatus(struct bridge_softc *, struct bridge_iflist *);
void bstp_enable_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_disable_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_enable_change_detection(struct bridge_iflist *);
void bstp_disable_change_detection(struct bridge_iflist *);
int bstp_root_bridge(struct bridge_softc *sc);
int bstp_supersedes_port_info(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
int bstp_designated_port(struct bridge_softc *, struct bridge_iflist *);
int bstp_designated_for_some_port(struct bridge_softc *);
void bstp_transmit_config(struct bridge_softc *, struct bridge_iflist *);
void bstp_transmit_tcn(struct bridge_softc *);
struct mbuf *bstp_input(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void bstp_received_config_bpdu(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
void bstp_received_tcn_bpdu(struct bridge_softc *, struct bridge_iflist *, struct bstp_tcn_unit *);
void bstp_record_config_information(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
void bstp_record_config_timeout_values(struct bridge_softc *, struct bstp_config_unit *);
void bstp_config_bpdu_generation(struct bridge_softc *);
void bstp_send_config_bpdu(struct bridge_iflist *, struct bstp_config_unit *);
void bstp_configuration_update(struct bridge_softc *);
void bstp_root_selection(struct bridge_softc *);
void bstp_designated_port_selection(struct bridge_softc *);
void bstp_become_designated_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_port_state_selection(struct bridge_softc *);
void bstp_make_forwarding(struct bridge_softc *, struct bridge_iflist *);
void bstp_make_blocking(struct bridge_softc *, struct bridge_iflist *);
void bstp_set_port_state(struct bridge_iflist *, u_int8_t);
void bstp_set_bridge_priority(struct bridge_softc *, u_int64_t);
void bstp_set_port_priority(struct bridge_softc *, struct bridge_iflist *, u_int16_t);
void bstp_set_path_cost(struct bridge_softc *, struct bridge_iflist *, u_int32_t);
void bstp_topology_change_detection(struct bridge_softc *);
void bstp_topology_change_acknowledged(struct bridge_softc *);
void bstp_acknowledge_topology_change(struct bridge_softc *, struct bridge_iflist *);

void bstp_tick(void *);
void bstp_timer_start(struct bridge_timer *, u_int16_t);
void bstp_timer_stop(struct bridge_timer *);
int bstp_timer_expired(struct bridge_timer *, u_int16_t);

void bstp_hold_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
void bstp_message_age_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
void bstp_forward_delay_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
void bstp_topology_change_timer_expiry(struct bridge_softc *);
void bstp_tcn_timer_expiry(struct bridge_softc *);
void bstp_hello_timer_expiry(struct bridge_softc *);
@


1.7.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.7.4.1 2002/06/11 03:30:45 art Exp $	*/
d398 1
a398 1
	m->m_pkthdr.len = sizeof(*eh) + sizeof(bpdu);
d411 1
a411 1
	bcopy(&bpdu, m->m_data + sizeof(*eh), sizeof(bpdu));
@


1.7.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d139 1
a139 2
int bstp_supersedes_port_info(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_config_unit *);
d146 4
a149 8
void bstp_received_config_bpdu(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_config_unit *);
void bstp_received_tcn_bpdu(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_tcn_unit *);
void bstp_record_config_information(struct bridge_softc *,
    struct bridge_iflist *, struct bstp_config_unit *);
void bstp_record_config_timeout_values(struct bridge_softc *,
    struct bstp_config_unit *);
d161 2
a162 4
void bstp_set_port_priority(struct bridge_softc *, struct bridge_iflist *,
    u_int16_t);
void bstp_set_path_cost(struct bridge_softc *, struct bridge_iflist *,
    u_int32_t);
d165 1
a165 2
void bstp_acknowledge_topology_change(struct bridge_softc *,
    struct bridge_iflist *);
d173 2
a174 4
void bstp_message_age_timer_expiry(struct bridge_softc *,
    struct bridge_iflist *);
void bstp_forward_delay_timer_expiry(struct bridge_softc *,
    struct bridge_iflist *);
a393 3
	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

d414 2
d421 1
a580 1
			bridge_rtdelete(sc, bif->ifp, 1);
d683 1
a683 1

d749 2
a750 1
		} else if (bstp_designated_port(sc, bif))
d763 2
a764 2
		bstp_topology_change_detection(sc);
		bstp_acknowledge_topology_change(sc, bif);
d959 1
a959 1
	bstp_enable_change_detection(bif);
a989 1
	bridge_rtdelete(sc, bif->ifp, 1);
a1259 1
	case SIOCBRDGSIFCOST:
@


1.6
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.5 2001/03/22 03:48:29 jason Exp $	*/
d227 1
a227 1
	int s;
d237 3
d293 2
a294 2
	IF_ENQUEUE(&ifp->if_snd, m);
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
d392 1
a392 1
	int s;
d416 2
a417 4
	if (IF_QFULL(&ifp->if_snd))
		goto out;
	IF_ENQUEUE(&ifp->if_snd, m);
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
@


1.5
log
@let bstp_transmit_tcn() handle all of the work for sending TCN messages
and remove unnecessary structure element
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.4 2001/01/30 04:22:23 kjell Exp $	*/
a65 5

#ifdef IPFILTER
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#endif
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.5 2001/03/22 03:48:29 jason Exp $	*/
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.5.4.1 2001/05/14 22:39:59 niklas Exp $	*/
d66 5
d232 1
a232 1
	int s, error;
a241 3
#ifdef ALTQ
	if (!ALTQ_IS_ENABLED(&ifp->if_snd))
#endif
d295 2
a296 2
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error == 0 && (ifp->if_flags & IFF_OACTIVE) == 0)
d394 1
a394 1
	int s, error;
d418 4
a421 2
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error == 0 && (ifp->if_flags & IFF_OACTIVE) == 0)
@


1.5.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 48
a177 48
void bstp_initialization(struct bridge_softc *);
void bstp_stop(struct bridge_softc *);
void bstp_initialize_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_ifupdstatus(struct bridge_softc *, struct bridge_iflist *);
void bstp_enable_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_disable_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_enable_change_detection(struct bridge_iflist *);
void bstp_disable_change_detection(struct bridge_iflist *);
int bstp_root_bridge(struct bridge_softc *sc);
int bstp_supersedes_port_info(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
int bstp_designated_port(struct bridge_softc *, struct bridge_iflist *);
int bstp_designated_for_some_port(struct bridge_softc *);
void bstp_transmit_config(struct bridge_softc *, struct bridge_iflist *);
void bstp_transmit_tcn(struct bridge_softc *);
struct mbuf *bstp_input(struct bridge_softc *, struct ifnet *,
    struct ether_header *, struct mbuf *);
void bstp_received_config_bpdu(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
void bstp_received_tcn_bpdu(struct bridge_softc *, struct bridge_iflist *, struct bstp_tcn_unit *);
void bstp_record_config_information(struct bridge_softc *, struct bridge_iflist *, struct bstp_config_unit *);
void bstp_record_config_timeout_values(struct bridge_softc *, struct bstp_config_unit *);
void bstp_config_bpdu_generation(struct bridge_softc *);
void bstp_send_config_bpdu(struct bridge_iflist *, struct bstp_config_unit *);
void bstp_configuration_update(struct bridge_softc *);
void bstp_root_selection(struct bridge_softc *);
void bstp_designated_port_selection(struct bridge_softc *);
void bstp_become_designated_port(struct bridge_softc *, struct bridge_iflist *);
void bstp_port_state_selection(struct bridge_softc *);
void bstp_make_forwarding(struct bridge_softc *, struct bridge_iflist *);
void bstp_make_blocking(struct bridge_softc *, struct bridge_iflist *);
void bstp_set_port_state(struct bridge_iflist *, u_int8_t);
void bstp_set_bridge_priority(struct bridge_softc *, u_int64_t);
void bstp_set_port_priority(struct bridge_softc *, struct bridge_iflist *, u_int16_t);
void bstp_set_path_cost(struct bridge_softc *, struct bridge_iflist *, u_int32_t);
void bstp_topology_change_detection(struct bridge_softc *);
void bstp_topology_change_acknowledged(struct bridge_softc *);
void bstp_acknowledge_topology_change(struct bridge_softc *, struct bridge_iflist *);

void bstp_tick(void *);
void bstp_timer_start(struct bridge_timer *, u_int16_t);
void bstp_timer_stop(struct bridge_timer *);
int bstp_timer_expired(struct bridge_timer *, u_int16_t);

void bstp_hold_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
void bstp_message_age_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
void bstp_forward_delay_timer_expiry(struct bridge_softc *, struct bridge_iflist *);
void bstp_topology_change_timer_expiry(struct bridge_softc *);
void bstp_tcn_timer_expiry(struct bridge_softc *);
void bstp_hello_timer_expiry(struct bridge_softc *);
@


1.5.4.4
log
@Sync the SMP branch with 3.3
@
text
@d139 1
a139 2
int bstp_supersedes_port_info(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_config_unit *);
d146 4
a149 8
void bstp_received_config_bpdu(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_config_unit *);
void bstp_received_tcn_bpdu(struct bridge_softc *, struct bridge_iflist *,
    struct bstp_tcn_unit *);
void bstp_record_config_information(struct bridge_softc *,
    struct bridge_iflist *, struct bstp_config_unit *);
void bstp_record_config_timeout_values(struct bridge_softc *,
    struct bstp_config_unit *);
d161 2
a162 4
void bstp_set_port_priority(struct bridge_softc *, struct bridge_iflist *,
    u_int16_t);
void bstp_set_path_cost(struct bridge_softc *, struct bridge_iflist *,
    u_int32_t);
d165 1
a165 2
void bstp_acknowledge_topology_change(struct bridge_softc *,
    struct bridge_iflist *);
d173 2
a174 4
void bstp_message_age_timer_expiry(struct bridge_softc *,
    struct bridge_iflist *);
void bstp_forward_delay_timer_expiry(struct bridge_softc *,
    struct bridge_iflist *);
a393 3
	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

d398 1
a398 1
	m->m_pkthdr.len = sizeof(*eh) + sizeof(bpdu);
d411 1
a411 1
	bcopy(&bpdu, m->m_data + sizeof(*eh), sizeof(bpdu));
d414 2
d421 1
a580 1
			bridge_rtdelete(sc, bif->ifp, 1);
d683 1
a683 1

d749 2
a750 1
		} else if (bstp_designated_port(sc, bif))
d763 2
a764 2
		bstp_topology_change_detection(sc);
		bstp_acknowledge_topology_change(sc, bif);
d959 1
a959 1
	bstp_enable_change_detection(bif);
a989 1
	bridge_rtdelete(sc, bif->ifp, 1);
a1259 1
	case SIOCBRDGSIFCOST:
@


1.5.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.5.4.4 2003/03/28 00:41:28 niklas Exp $	*/
d15 5
@


1.5.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 1
a111 1
} __packed;
d121 1
a121 1
} __packed;
@


1.4
log
@change ip_compat.h to ip_fil_compat.h for clarity. Impending ipf merge
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.3 2001/01/17 04:47:18 fgsch Exp $	*/
a156 1
void bstp_send_tcn_bpdu __P((struct bridge_softc *, struct bridge_iflist *, struct bstp_tcn_unit *));
d388 5
a392 15
	struct bridge_iflist *bif;

	bif = sc->sc_root_port;
	bif->bif_tcn_bpdu.tu_message_type = BSTP_MSGTYPE_TCN;
	bstp_send_tcn_bpdu(sc, bif, &bif->bif_tcn_bpdu);
}

void
bstp_send_tcn_bpdu(sc, bif, tu)
	struct bridge_softc *sc;
	struct bridge_iflist *bif;
	struct bstp_tcn_unit *tu;
{
	struct arpcom *arp;
	struct ifnet *ifp;
a393 2
	struct ether_header eh;
	struct bstp_tbpdu bpdu;
a395 13
	s = splimp();
	ifp = bif->ifp;
	arp = (struct arpcom *)ifp;

	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		splx(s);
		return;
	}
	if (IF_QFULL(&ifp->if_snd)) {
		splx(s);
		return;
	}

d397 1
a397 2
	if (m == NULL) {
		splx(s);
a398 1
	}
d403 5
d412 1
a412 7
	bpdu.tbu_bpdutype = tu->tu_message_type;

	bcopy(arp->ac_enaddr, eh.ether_shost, ETHER_ADDR_LEN);
	bcopy(bstp_etheraddr, eh.ether_dhost, ETHER_ADDR_LEN);
	eh.ether_type = htons(sizeof(bpdu));

	bcopy(&eh, m->m_data, sizeof(eh));
d415 5
d423 3
d427 2
@


1.3
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.2 2000/12/18 03:38:56 mickey Exp $	*/
d68 1
a68 1
#include <netinet/ip_compat.h>
@


1.2
log
@include timeout.h to make it compile w/o ipfilter
@
text
@d1 1
a1 1
/*	$OpenBSD: bridgestp.c,v 1.1 2000/12/12 03:41:22 jason Exp $	*/
d68 1
a68 1
#include <netinet/ip_fil_compat.h>
@


1.1
log
@Add support for 802.1D spanning tree protocol.
NOTE: this requires recompiling brconfig with updated include files.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
@

