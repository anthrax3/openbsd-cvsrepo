head	1.35;
access;
symbols
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.17.0.30
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.28
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.26
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.24
	OPENBSD_5_0:1.17.0.22
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.20
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.18
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.14
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.34;
commitid	6c6qq5OdS4VVnyVM;

1.34
date	2017.01.09.19.15.01;	author mpi;	state Exp;
branches;
next	1.33;
commitid	gY9uoXPuboETv0Ph;

1.33
date	2017.01.03.19.28.50;	author mpi;	state Exp;
branches;
next	1.32;
commitid	j0M5Y0DG9i3fG0eI;

1.32
date	2017.01.02.11.07.31;	author mpi;	state Exp;
branches;
next	1.31;
commitid	2jYH2wzuBTM9zLGf;

1.31
date	2016.08.22.10.40.36;	author mpi;	state Exp;
branches;
next	1.30;
commitid	6FqmydzsIfw5T27V;

1.30
date	2016.03.30.12.33.10;	author dlg;	state Exp;
branches;
next	1.29;
commitid	INNrVhF0rco4JJYt;

1.29
date	2015.12.03.16.27.32;	author mpi;	state Exp;
branches;
next	1.28;
commitid	wK6td35Fr7xdNzh3;

1.28
date	2015.09.09.11.55.37;	author dlg;	state Exp;
branches;
next	1.27;
commitid	yzxE5xegGlAC9CXF;

1.27
date	2015.09.01.04.50.27;	author dlg;	state Exp;
branches;
next	1.26;
commitid	zhzN4J5NBYqh1Jfl;

1.26
date	2015.08.23.10.14.25;	author dlg;	state Exp;
branches;
next	1.25;
commitid	nmKb4l0Xabz9Ytks;

1.25
date	2015.08.16.12.17.16;	author dlg;	state Exp;
branches;
next	1.24;
commitid	1LM3GdO8Sc7UxIGJ;

1.24
date	2015.02.10.00.53.55;	author pelikan;	state Exp;
branches;
next	1.23;
commitid	gfoM2KwSYVDTr1Yq;

1.23
date	2014.10.05.18.43.56;	author lteo;	state Exp;
branches;
next	1.22;
commitid	XvMAPKWiAorDgYfA;

1.22
date	2013.12.18.13.40.08;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.12.01.12.09;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.11.16.21.08;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.11.03.06.43;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.24.11.14.33;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.21.18.16.45;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.17.15.56.58;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.22.04.04.19;	author canacar;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.28.08.16.23;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.08.20.54.13;	author canacar;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.22.18.42.40;	author canacar;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.09.06.16.37;	author angelos;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.05.28.19.51.06;	author dugsong;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.19.03.00.54;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	98.06.26.09.13.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.08.31.20.42.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.02.24.13.33.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.39.59;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.53.52;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	;


desc
@@


1.35
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: bpfdesc.h,v 1.34 2017/01/09 19:15:01 mpi Exp $	*/
/*	$NetBSD: bpfdesc.h,v 1.11 1995/09/27 18:30:42 thorpej Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from the Stanford/CMU enet packet filter,
 * (net/enet.c) distributed as part of 4.3BSD, and code contributed
 * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence
 * Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)bpfdesc.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NET_BPFDESC_H_
#define _NET_BPFDESC_H_

#ifdef _KERNEL

/*
 * Descriptor associated with each open bpf file.
 */
struct bpf_d {
	SRPL_ENTRY(bpf_d) bd_next;	/* Linked list of descriptors */
	/*
	 * Buffer slots: two mbuf clusters buffer the incoming packets.
	 *   The model has three slots.  Sbuf is always occupied.
	 *   sbuf (store) - Receive interrupt puts packets here.
	 *   hbuf (hold) - When sbuf is full, put cluster here and
	 *                 wakeup read (replace sbuf with fbuf).
	 *   fbuf (free) - When read is done, put cluster here.
	 * On receiving, if sbuf is full and fbuf is 0, packet is dropped.
	 */
	struct mutex	bd_mtx;		/* protect buffer slots below */
	caddr_t		bd_sbuf;	/* store slot */
	caddr_t		bd_hbuf;	/* hold slot */
	caddr_t		bd_fbuf;	/* free slot */
	int		bd_slen;	/* current length of store buffer */
	int		bd_hlen;	/* current length of hold buffer */
	int		bd_bufsize;	/* absolute length of buffers */

	int		bd_in_uiomove;	/* for debugging purpose */

	struct bpf_if  *bd_bif;		/* interface descriptor */
	u_long		bd_rtout;	/* Read timeout in 'ticks' */
	u_long		bd_rdStart;	/* when the read started */
	struct srp	bd_rfilter;	/* read filter code */
	struct srp	bd_wfilter;	/* write filter code */
	u_long		bd_rcount;	/* number of packets received */
	u_long		bd_dcount;	/* number of packets dropped */

	u_char		bd_promisc;	/* true if listening promiscuously */
	u_char		bd_state;	/* idle, waiting, or timed out */
	u_char		bd_immediate;	/* true to return on packet arrival */
	u_char		bd_locked;	/* true if descriptor is locked */
	u_char		bd_fildrop;	/* true if filtered packets will be dropped */
	u_char		bd_dirfilt;	/* direction filter */
	int		bd_hdrcmplt;	/* false to fill in src lladdr automatically */
	int		bd_async;	/* non-zero if packet reception should generate signal */
	int		bd_sig;		/* signal to send upon packet reception */
	pid_t		bd_pgid;	/* process or group id for signal */
	uid_t		bd_siguid;	/* uid for process that set pgid */
	uid_t		bd_sigeuid;	/* euid for process that set pgid */
	u_int		bd_ref;		/* reference count */
	struct selinfo	bd_sel;		/* bsd select info */
	int		bd_unit;	/* logical unit number */
	LIST_ENTRY(bpf_d) bd_list;	/* descriptor list */

	struct task	bd_wake_task;	/* delay csignal() and selwakeup() */
};

/*
 * Descriptor associated with each attached hardware interface.
 */
struct bpf_if {
	struct bpf_if *bif_next;	/* list of all interfaces */
	SRPL_HEAD(, bpf_d) bif_dlist;		/* descriptor list */
	struct bpf_if **bif_driverp;	/* pointer into softc */
	u_int bif_dlt;			/* link layer type */
	u_int bif_hdrlen;		/* length of header (with padding) */
	struct ifnet *bif_ifp;		/* corresponding interface */
};

int	 bpf_setf(struct bpf_d *, struct bpf_program *, int);
#endif /* _KERNEL */
#endif /* _NET_BPFDESC_H_ */
@


1.34
log
@Use a mutex to serialize accesses to buffer slots.

With this change bpf_catchpacket() no longer need the KERNEL_LOCK().

Tested by Hrvoje Popovski who reported a recursion in the previous
attempt.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.33 2017/01/03 19:28:50 mpi Exp $	*/
d73 1
a73 1
	struct srp	bd_wfilter; 	/* write filter code */
@


1.33
log
@Revert previous, there's still a problem with recursive entries in
bpf_mpath_ether().

Problem reported by Hrvoje Popovski.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.31 2016/08/22 10:40:36 mpi Exp $	*/
d59 1
d65 1
d67 1
a67 1
	int		bd_bufsize;	/* absolute length of buffers */
d69 1
a69 1
	struct bpf_if *	bd_bif;		/* interface descriptor */
@


1.32
log
@Use a mutex to serialize accesses to buffer slots.

With this change bpf_catchpacket() no longer need the KERNEL_LOCK().

ok bluhm@@, jmatthew@@
@
text
@a58 1
	struct mutex	bd_mtx;		/* protect buffer slots below */
d64 1
d67 1
a67 3
	int		bd_in_uiomove;	/* debugging purpose */

	struct bpf_if  *bd_bif;		/* interface descriptor */
@


1.31
log
@Call csignal() and selwakeup() from a KERNEL_LOCK'd task.

This will allow us make bpf_tap() KERNEL_LOCK() free.

Discussed with dlg@@ and input from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.30 2016/03/30 12:33:10 dlg Exp $	*/
d59 1
d65 1
d67 1
a67 1
	int		bd_bufsize;	/* absolute length of buffers */
d69 1
a69 1
	struct bpf_if *	bd_bif;		/* interface descriptor */
@


1.30
log
@remove support for BIOCGQUEUE and BIOSGQUEUE

nothing uses them, and the implementation make incorrect assumptions
about mbufs within bpf processing that could lead to some weird
failures.

ok sthen@@ deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.29 2015/12/03 16:27:32 mpi Exp $	*/
a44 2
#include <sys/selinfo.h>

d91 2
@


1.29
log
@Use SRPL_HEAD() and SRPL_ENTRY() to be consistent with and allow to
fallback to a SLIST.

ok dlg@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.28 2015/09/09 11:55:37 dlg Exp $	*/
a82 1
	u_int		bd_queue;	/* the queue the user wants to watch (0 == all) */
@


1.28
log
@convert bpf to using an srp list for the list of descriptors.

this replaces the hand rolled list. the code has always used hand
rolled lists, but that gets a bit cumbersome when theyre SRPs.

requested ages ago by mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.27 2015/09/01 04:50:27 dlg Exp $	*/
d51 1
a51 1
	struct srpl_entry bd_next;	/* Linked list of descriptors */
d101 1
a101 1
	struct srpl bif_dlist;		/* descriptor list */
@


1.27
log
@reintroduce bpf.c r1.121.

this differs slightly from 1.121 in that it uses the new srp_follow()
to walk the list of descriptors on an interface. this is instead
of interleaving srp_enter() and srp_leave(), which can lead to races
and corruption if you're touching the same SRPs at different IPLs
on the same CPU.

ok deraadt@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.26 2015/08/23 10:14:25 dlg Exp $	*/
d51 1
a51 1
	struct srp	bd_next;	/* Linked list of descriptors */
d101 1
a101 1
	struct srp bif_dlist;		/* descriptor list */
@


1.26
log
@back out bpf+srp. its blowing up in a bridge setup.

ill debug this out of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.24 2015/02/10 00:53:55 pelikan Exp $	*/
d51 1
a51 1
	struct bpf_d	*bd_next;	/* Linked list of descriptors */
d72 2
a73 2
	struct bpf_insn *bd_rfilter; 	/* read filter code */
	struct bpf_insn *bd_wfilter; 	/* write filter code */
d101 1
a101 1
	struct bpf_d *bif_dlist;	/* descriptor list */
@


1.25
log
@make bpf_mtap mpsafe by using SRPs.

this was originally implemented by jmatthew@@ last year, and updated
by us both during s2k15.

there are four data structures that need to be looked after.

the first is the bpf interface itself. it is allocated and freed
at the same time as an actual interface, so if you're able to send
or receive packets, you're able to run bpf on an interface too.
dont need to do any work there.

the second are bpf descriptors. these represent userland attaching
to a bpf interface, so you can have many of them on a single bpf
interface. they were arranged in a singly linked list before. now
the head and next pointers are replaced with SRP pointers and
followed by srp_enter. the list updates are serialised by the kernel
lock.

the third are the bpf filters. there is an inbound and outbound
filter on each bpf descriptor, ann a process can replace them at
any time. the pointers from the descriptor to those is also changed
to be accessed via srp_enter. updates are serialised by the kernel
lock.

the fourth thing is the ring that bpf writes to for userland to
read. there's one of these per descriptor. because these are only
updated when a filter matches (which is hopefully a relatively rare
event), we take the kernel lock to serialise the writes to the ring.

all this together means you can run bpf against a packet without
taking the kernel lock unless you actually caught a packet and need
to send it to userland. even better, you can run bpf in parallel,
so if we ever support multiple rings on a single interface, we can
run bpf on each ring on different cpus safely.

ive hit this pretty hard in production at work (yay dhcrelay) on
myx (which does rx outside the biglock).

ok jmatthew@@ mpi@@ millert@@
@
text
@d51 1
a51 1
	struct srp	bd_next;	/* Linked list of descriptors */
d72 2
a73 2
	struct srp	bd_rfilter;	/* read filter code */
	struct srp	bd_wfilter; 	/* write filter code */
d101 1
a101 1
	struct srp bif_dlist;		/* descriptor list */
@


1.24
log
@make bpf(4) able to filter based on a pf(4) queue ID for tcpdump -Q qname

ALTQ version has been on tech@@ for years, people were generally ok with it.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.23 2014/10/05 18:43:56 lteo Exp $	*/
d51 1
a51 1
	struct bpf_d	*bd_next;	/* Linked list of descriptors */
d72 2
a73 2
	struct bpf_insn *bd_rfilter; 	/* read filter code */
	struct bpf_insn *bd_wfilter; 	/* write filter code */
d101 1
a101 1
	struct bpf_d *bif_dlist;	/* descriptor list */
@


1.23
log
@fix typo in comment: correspoding -> corresponding
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.22 2013/12/18 13:40:08 krw Exp $	*/
d83 1
@


1.22
log
@Revert the *other* part of bpf.c's r1.84. May finally fix RD Thrush's
encounter with "timeout_add: to_ticks (-1) < 0". Pointed out by RD
Thrush.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.21 2013/11/12 01:12:09 dlg Exp $	*/
d104 1
a104 1
	struct ifnet *bif_ifp;		/* correspoding interface */
@


1.21
log
@try bpf.c r1.84 again, this time without semantic changes to if statements.

cheers to sthen@@ and krw@@ for properly dealing with the fallout of my
first commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.20 2013/11/11 16:21:08 sthen Exp $	*/
d70 2
a71 2
	int		bd_rtout;	/* Read timeout in 'ticks' */
	int		bd_rdStart;	/* when the read started */
@


1.20
log
@Revert bpf.c 1.84 / bpfdesc.h 1.19 for now, "panic: timeout_add: to_ticks (-1)
< 0" seen by RD Thrush, http://article.gmane.org/gmane.os.openbsd.bugs/20113
where he has a long-running process using bpf which is active at the time of
panic.  krw@@ agrees with reverting for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.18 2013/10/24 11:14:33 deraadt Exp $	*/
d70 2
a71 2
	u_long		bd_rtout;	/* Read timeout in 'ticks' */
	u_long		bd_rdStart;	/* when the read started */
@


1.19
log
@replace the user of ticks in a condition like "interval + start < ticks"
with "ticks - start > interval" because the latter copes with the ticks
value wrapping.

pointed out by guenther@@
ok krw@@
@
text
@d70 2
a71 2
	int		bd_rtout;	/* Read timeout in 'ticks' */
	int		bd_rdStart;	/* when the read started */
@


1.18
log
@Move obvious kernel prototypes (and structure's with kernel pointers,
obviously only used in the kernel) behind #ifdef _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.17 2006/03/25 22:41:47 djm Exp $	*/
d70 2
a71 2
	u_long		bd_rtout;	/* Read timeout in 'ticks' */
	u_long		bd_rdStart;	/* when the read started */
@


1.17
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.16 2005/11/21 18:16:45 millert Exp $	*/
d43 2
a106 1
#ifdef _KERNEL
@


1.16
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.15 2004/12/17 15:56:58 reyk Exp $	*/
d80 1
@


1.15
log
@knf cleanup, convert old k&r-style functions to ansi-style for a
consistent style in sys/net/bpf.c.

ok henning@@, "looks fine" canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.14 2004/06/22 04:04:19 canacar Exp $	*/
d43 1
a43 1
#include <sys/select.h>
@


1.14
log
@Add a new "filter drop" flag to bpf and related ioclts.
When enabled, it notifies the calling interface that the packet
matches a bpf filter and should be dropped.
ok henning@@ markus@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.13 2004/05/28 08:16:23 grange Exp $	*/
d62 2
a63 2
	int 		bd_slen;	/* current length of store buffer */
	int 		bd_hlen;	/* current length of hold buffer */
@


1.13
log
@bpf device cloning.
Now to have more bpf devices just add device nodes in /dev,
no need to recompile kernel anymore.

Code from form@@pdp-11.org.ru, some help from markus@@.
ok markus@@ canacar@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.12 2004/05/08 20:54:13 canacar Exp $	*/
d79 1
@


1.12
log
@reference count bpf descriptors to protect against disappearing interfaces
while asleep in read. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.11 2003/10/22 18:42:40 canacar Exp $	*/
d87 2
@


1.11
log
@Add locking and write filtering to bpf descriptors.
Locking prevents dangerous ioctls such as changing the
interface and sending signals to be executed by an
unprivileged process. A filter can also be applied
to packets injected through a bpf descriptor.

These features allow programs using bpf descriptors to
safely drop/seperate privileges.

ok frantzen@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.10 2003/06/02 23:28:11 millert Exp $	*/
d85 1
a85 1
	u_char		bd_pad;		/* explicit alignment */
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.9 2002/03/14 01:27:09 millert Exp $	*/
d70 2
a71 1
	struct bpf_insn *bd_filter; 	/* filter code */
d78 1
d102 1
a102 1
int	 bpf_setf(struct bpf_d *, struct bpf_program *);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.8 2001/06/09 06:16:37 angelos Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@By popular demand, protect from multiple inclusion, and fix to use the
same naming style.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.7 2001/05/28 19:51:06 dugsong Exp $	*/
d104 1
a104 1
int	 bpf_setf __P((struct bpf_d *, struct bpf_program *));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.8 2001/06/09 06:16:37 angelos Exp $	*/
d104 1
a104 1
int	 bpf_setf(struct bpf_d *, struct bpf_program *);
@


1.7
log
@add BIOC[GS]HDRCMPLT ioctl for BPF, to disable overwriting of link level source address in forged frames. from NetBSD. art@@ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.6 2000/06/19 03:00:54 jason Exp $	*/
d44 3
d105 2
a106 2
#endif

@


1.6
log
@de-#ifdef-ize
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.5 1999/08/08 00:43:00 niklas Exp $	*/
d78 1
@


1.5
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.4 1998/06/26 09:13:13 deraadt Exp $	*/
a82 5
#if BSD < 199103
	u_char		bd_selcoll;	/* true if selects collide */
	int		bd_timedout;
	struct proc *	bd_selproc;	/* process that last selected us */
#else
a84 1
#endif
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.6 2000/06/19 03:00:54 jason Exp $	*/
d83 5
d90 1
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.5.4.1 2001/05/14 22:39:59 niklas Exp $	*/
a43 3
#ifndef _NET_BPFDESC_H_
#define _NET_BPFDESC_H_

a77 1
	int		bd_hdrcmplt;	/* false to fill in src lladdr automatically */
d101 2
a102 2
#endif /* _KERNEL */
#endif /* _NET_BPFDESC_H_ */
@


1.5.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 1
a104 1
int	 bpf_setf(struct bpf_d *, struct bpf_program *);
@


1.5.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.5.4.3 2002/03/28 14:57:36 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 2
	struct bpf_insn *bd_rfilter; 	/* read filter code */
	struct bpf_insn *bd_wfilter; 	/* write filter code */
a76 1
	u_char		bd_locked;	/* true if descriptor is locked */
d100 1
a100 1
int	 bpf_setf(struct bpf_d *, struct bpf_program *, int);
@


1.5.4.6
log
@Merge with the trunk
@
text
@d85 1
a85 1
	u_int		bd_ref;		/* reference count */
a86 2
	int		bd_unit;	/* logical unit number */
	LIST_ENTRY(bpf_d) bd_list;	/* descriptor list */
@


1.4
log
@fix bpf select(); from mts@@rare.net
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.3 1997/08/31 20:42:30 deraadt Exp $	*/
d108 1
@


1.3
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.2 1997/02/24 13:33:56 niklas Exp $	*/
d70 1
@


1.2
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD: bpfdesc.h,v 1.11 1995/09/27 18:30:42 thorpej Exp $	*/
d80 2
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
