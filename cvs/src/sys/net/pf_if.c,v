head	1.89;
access;
symbols
	OPENBSD_6_0:1.82.0.6
	OPENBSD_6_0_BASE:1.82
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.79.0.4
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.74.0.4
	OPENBSD_5_6_BASE:1.74
	OPENBSD_5_5:1.72.0.4
	OPENBSD_5_5_BASE:1.72
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.64.0.2
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.63.0.6
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.4
	OPENBSD_5_0:1.63.0.2
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.61.0.4
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.60.0.2
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.56.0.4
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.55.0.2
	OPENBSD_4_5_BASE:1.55
	OPENBSD_4_4:1.54.0.2
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.51.0.2
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.47.0.2
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.45.0.4
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	SMP:1.8.0.2;
locks; strict;
comment	@ * @;


1.89
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.88;
commitid	6c6qq5OdS4VVnyVM;

1.88
date	2016.12.12.13.30.05;	author mpi;	state Exp;
branches;
next	1.87;
commitid	xE1u7dyap9CYmwHS;

1.87
date	2016.11.16.08.46.05;	author mpi;	state Exp;
branches;
next	1.86;
commitid	pUZOAlSRSuvtMpYj;

1.86
date	2016.09.27.04.57.17;	author dlg;	state Exp;
branches;
next	1.85;
commitid	irzdR7hwk1GHVaEu;

1.85
date	2016.09.27.02.51.12;	author dlg;	state Exp;
branches;
next	1.84;
commitid	bZuzILta8BoFCDiT;

1.84
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.83;
commitid	RlO92XR575sygHqm;

1.83
date	2016.09.02.10.19.49;	author dlg;	state Exp;
branches;
next	1.82;
commitid	BjJg5d9vjutHaOpJ;

1.82
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.81;
commitid	eYnPulzvLjDImPCa;

1.81
date	2015.10.30.11.33.55;	author mikeb;	state Exp;
branches;
next	1.80;
commitid	b90TPnSXmdusuD88;

1.80
date	2015.09.04.21.40.25;	author kettenis;	state Exp;
branches;
next	1.79;
commitid	9bdTRxc2FCD8lXug;

1.79
date	2015.07.21.02.32.04;	author sashan;	state Exp;
branches;
next	1.78;
commitid	cPDXdho3rjhTprUk;

1.78
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.77;
commitid	p4LJxGKbi0BU2cG6;

1.77
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.76;
commitid	zhW8jJrfVCoAthrR;

1.76
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.75;
commitid	t9FBKDfc4VDxpEy2;

1.75
date	2014.12.02.18.11.56;	author tedu;	state Exp;
branches;
next	1.74;
commitid	R6VIBSqPh5FMhwGK;

1.74
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.73;
commitid	DQakU8LLWV6Iwx84;

1.73
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.72;
commitid	B4dZSbxas1X1IpXI;

1.72
date	2014.01.22.04.33.34;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2014.01.21.01.50.07;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2014.01.08.22.38.29;	author bluhm;	state Exp;
branches;
next	1.69;

1.69
date	2014.01.03.12.43.09;	author pelikan;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.17.16.27.42;	author bluhm;	state Exp;
branches;
next	1.67;

1.67
date	2013.08.30.18.23.17;	author haesbaert;	state Exp;
branches;
next	1.66;

1.66
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.65;

1.65
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.64;

1.64
date	2012.12.28.17.52.06;	author gsoares;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.28.11.03.49;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2011.05.20.22.50.44;	author sthen;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.28.23.21.41;	author mcbride;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.58;

1.58
date	2009.08.25.23.21.04;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.25.10.42.27;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.09.13.53.10;	author mcbride;	state Exp;
branches;
next	1.55;

1.55
date	2008.11.24.13.22.09;	author mikeb;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.14.16.55.28;	author mk;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.14.02.22.13;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2008.05.18.11.54.04;	author mcbride;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.07.17.28.40;	author mpf;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.27.22.24.05;	author mpf;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.01.18.49.27;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2007.07.13.09.17.48;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.13.09.01.59;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.30.12.39.13;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.28.01.46.32;	author pascoe;	state Exp;
branches;
next	1.43;

1.43
date	2005.08.18.10.28.14;	author pascoe;	state Exp;
branches;
next	1.42;

1.42
date	2005.08.07.11.35.59;	author pascoe;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.02.12.40.42;	author pascoe;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.20.17.06.30;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2005.06.06.03.44.21;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.05.20.47.46;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.02.17.51.48;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.28.20.26.25;	author mcbride;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.27.19.16.32;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.26.05.28.35;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.26.05.21.16;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.25.06.50.05;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.24.04.17.19;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.23.22.30.21;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.23.20.40.13;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.22.18.35.43;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.22.18.23.04;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.21.21.05.16;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.21.21.03.57;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.21.13.34.45;	author pascoe;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.22.17.17.55;	author dhartmei;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.13.23.51.22;	author dhartmei;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.06.10.38.19;	author mpf;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.15.15.31.46;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.11.12.06.44;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.10.11.10.01;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.11.15.22.22;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.04.22.56.52;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.25.00.54.27;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.19.17.50.52;	author dhartmei;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.28.02.43.09;	author pb;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.15.11.38.23;	author cedric;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.09.21.44.41;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.20.19.22.03;	author mcbride;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.17.08.26.47;	author cedric;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2004.02.10.18.49.10;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.09.13.27.50;	author cedric;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.07.19.58.54;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.31.22.14.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.31.15.32.43;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.31.11.18.25;	author cedric;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.12.20.05.45;	author cedric;	state Exp;
branches;
next	;

1.8.2.1
date	2004.02.19.10.57.22;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2004.06.05.23.11.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.89
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: pf_if.c,v 1.88 2016/12/12 13:30:05 mpi Exp $ */

/*
 * Copyright 2005 Henning Brauer <henning@@openbsd.org>
 * Copyright 2005 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2003 Cedric Berger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/filio.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/time.h>
#include <sys/pool.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_var.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#include <net/pfvar.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif /* INET6 */

struct pfi_kif		 *pfi_all = NULL;
struct pool		  pfi_addr_pl;
struct pfi_ifhead	  pfi_ifs;
long			  pfi_update = 1;
struct pfr_addr		 *pfi_buffer;
int			  pfi_buffer_cnt;
int			  pfi_buffer_max;

void		 pfi_kif_update(struct pfi_kif *);
void		 pfi_dynaddr_update(struct pfi_dynaddr *dyn);
void		 pfi_table_update(struct pfr_ktable *, struct pfi_kif *,
		    u_int8_t, int);
void		 pfi_kifaddr_update(void *);
void		 pfi_instance_add(struct ifnet *, u_int8_t, int);
void		 pfi_address_add(struct sockaddr *, sa_family_t, u_int8_t);
int		 pfi_if_compare(struct pfi_kif *, struct pfi_kif *);
int		 pfi_skip_if(const char *, struct pfi_kif *);
int		 pfi_unmask(void *);

RB_PROTOTYPE(pfi_ifhead, pfi_kif, pfik_tree, pfi_if_compare);
RB_GENERATE(pfi_ifhead, pfi_kif, pfik_tree, pfi_if_compare);

#define PFI_BUFFER_MAX		0x10000
#define PFI_MTYPE		M_IFADDR

void
pfi_initialize(void)
{
	if (pfi_all != NULL)	/* already initialized */
		return;

	pool_init(&pfi_addr_pl, sizeof(struct pfi_dynaddr), 0, IPL_SOFTNET, 0,
	    "pfiaddrpl", NULL);
	pfi_buffer_max = 64;
	pfi_buffer = mallocarray(pfi_buffer_max, sizeof(*pfi_buffer),
	    PFI_MTYPE, M_WAITOK);

	if ((pfi_all = pfi_kif_get(IFG_ALL)) == NULL)
		panic("pfi_kif_get for pfi_all failed");
}

struct pfi_kif *
pfi_kif_find(const char *kif_name)
{
	struct pfi_kif_cmp	 s;

	bzero(&s, sizeof(s));
	strlcpy(s.pfik_name, kif_name, sizeof(s.pfik_name));
	return (RB_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&s));
}

struct pfi_kif *
pfi_kif_get(const char *kif_name)
{
	struct pfi_kif		*kif;

	if ((kif = pfi_kif_find(kif_name)))
		return (kif);

	/* create new one */
	if ((kif = malloc(sizeof(*kif), PFI_MTYPE, M_NOWAIT|M_ZERO)) == NULL)
		return (NULL);

	strlcpy(kif->pfik_name, kif_name, sizeof(kif->pfik_name));
	kif->pfik_tzero = time_second;
	TAILQ_INIT(&kif->pfik_dynaddrs);

	if (!strcmp(kif->pfik_name, "any")) {
		/* both so it works in the ioctl and the regular case */
		kif->pfik_flags |= PFI_IFLAG_ANY;
		kif->pfik_flags_new |= PFI_IFLAG_ANY;
	}

	RB_INSERT(pfi_ifhead, &pfi_ifs, kif);
	return (kif);
}

void
pfi_kif_ref(struct pfi_kif *kif, enum pfi_kif_refs what)
{
	switch (what) {
	case PFI_KIF_REF_RULE:
		kif->pfik_rules++;
		break;
	case PFI_KIF_REF_STATE:
		kif->pfik_states++;
		break;
	case PFI_KIF_REF_ROUTE:
		kif->pfik_routes++;
		break;
	default:
		panic("pfi_kif_ref with unknown type");
	}
}

void
pfi_kif_unref(struct pfi_kif *kif, enum pfi_kif_refs what)
{
	if (kif == NULL)
		return;

	switch (what) {
	case PFI_KIF_REF_NONE:
		break;
	case PFI_KIF_REF_RULE:
		if (kif->pfik_rules <= 0) {
			DPFPRINTF(LOG_ERR,
			    "pfi_kif_unref: rules refcount <= 0");
			return;
		}
		kif->pfik_rules--;
		break;
	case PFI_KIF_REF_STATE:
		if (kif->pfik_states <= 0) {
			DPFPRINTF(LOG_ERR,
			    "pfi_kif_unref: state refcount <= 0");
			return;
		}
		kif->pfik_states--;
		break;
	case PFI_KIF_REF_ROUTE:
		if (kif->pfik_routes <= 0) {
			DPFPRINTF(LOG_ERR,
			    "pfi_kif_unref: state refcount <= 0");
			return;
		}
		kif->pfik_routes--;
		break;
	default:
		panic("pfi_kif_unref with unknown type");
	}

	if (kif->pfik_ifp != NULL || kif->pfik_group != NULL || kif == pfi_all)
		return;

	if (kif->pfik_rules || kif->pfik_states || kif->pfik_routes)
		return;

	RB_REMOVE(pfi_ifhead, &pfi_ifs, kif);
	free(kif, PFI_MTYPE, 0);
}

int
pfi_kif_match(struct pfi_kif *rule_kif, struct pfi_kif *packet_kif)
{
	struct ifg_list	*p;

	if (rule_kif == NULL || rule_kif == packet_kif)
		return (1);

	if (rule_kif->pfik_group != NULL)
		TAILQ_FOREACH(p, &packet_kif->pfik_ifp->if_groups, ifgl_next)
			if (p->ifgl_group == rule_kif->pfik_group)
				return (1);

	if (rule_kif->pfik_flags & PFI_IFLAG_ANY && packet_kif->pfik_ifp &&
	    !(packet_kif->pfik_ifp->if_flags & IFF_LOOPBACK))
		return (1);

	return (0);
}

void
pfi_attach_ifnet(struct ifnet *ifp)
{
	struct pfi_kif		*kif;

	pfi_initialize();
	pfi_update++;
	if ((kif = pfi_kif_get(ifp->if_xname)) == NULL)
		panic("pfi_kif_get failed");

	kif->pfik_ifp = ifp;
	ifp->if_pf_kif = (caddr_t)kif;

	if ((kif->pfik_ah_cookie = hook_establish(ifp->if_addrhooks, 1,
	    pfi_kifaddr_update, kif)) == NULL)
		panic("pfi_attach_ifnet: cannot allocate '%s' address hook",
		    ifp->if_xname);

	pfi_kif_update(kif);
}

void
pfi_detach_ifnet(struct ifnet *ifp)
{
	struct pfi_kif		*kif;

	if ((kif = (struct pfi_kif *)ifp->if_pf_kif) == NULL)
		return;

	pfi_update++;
	hook_disestablish(ifp->if_addrhooks, kif->pfik_ah_cookie);
	pfi_kif_update(kif);

	kif->pfik_ifp = NULL;
	ifp->if_pf_kif = NULL;
	pfi_kif_unref(kif, PFI_KIF_REF_NONE);
}

void
pfi_attach_ifgroup(struct ifg_group *ifg)
{
	struct pfi_kif	*kif;

	pfi_initialize();
	pfi_update++;
	if ((kif = pfi_kif_get(ifg->ifg_group)) == NULL)
		panic("pfi_kif_get failed");

	kif->pfik_group = ifg;
	ifg->ifg_pf_kif = (caddr_t)kif;
}

void
pfi_detach_ifgroup(struct ifg_group *ifg)
{
	struct pfi_kif	*kif;

	if ((kif = (struct pfi_kif *)ifg->ifg_pf_kif) == NULL)
		return;

	pfi_update++;

	kif->pfik_group = NULL;
	ifg->ifg_pf_kif = NULL;
	pfi_kif_unref(kif, PFI_KIF_REF_NONE);
}

void
pfi_group_change(const char *group)
{
	struct pfi_kif		*kif;

	pfi_update++;
	if ((kif = pfi_kif_get(group)) == NULL)
		panic("pfi_kif_get failed");

	pfi_kif_update(kif);
}

int
pfi_match_addr(struct pfi_dynaddr *dyn, struct pf_addr *a, sa_family_t af)
{
	switch (af) {
	case AF_INET:
		switch (dyn->pfid_acnt4) {
		case 0:
			return (0);
		case 1:
			return (PF_MATCHA(0, &dyn->pfid_addr4,
			    &dyn->pfid_mask4, a, AF_INET));
		default:
			return (pfr_match_addr(dyn->pfid_kt, a, AF_INET));
		}
		break;
#ifdef INET6
	case AF_INET6:
		switch (dyn->pfid_acnt6) {
		case 0:
			return (0);
		case 1:
			return (PF_MATCHA(0, &dyn->pfid_addr6,
			    &dyn->pfid_mask6, a, AF_INET6));
		default:
			return (pfr_match_addr(dyn->pfid_kt, a, AF_INET6));
		}
		break;
#endif /* INET6 */
	default:
		return (0);
	}
}

int
pfi_dynaddr_setup(struct pf_addr_wrap *aw, sa_family_t af)
{
	struct pfi_dynaddr	*dyn;
	char			 tblname[PF_TABLE_NAME_SIZE];
	struct pf_ruleset	*ruleset = NULL;
	int			 rv = 0;

	if (aw->type != PF_ADDR_DYNIFTL)
		return (0);
	if ((dyn = pool_get(&pfi_addr_pl, PR_WAITOK | PR_LIMITFAIL | PR_ZERO))
	    == NULL)
		return (1);

	if (!strcmp(aw->v.ifname, "self"))
		dyn->pfid_kif = pfi_kif_get(IFG_ALL);
	else
		dyn->pfid_kif = pfi_kif_get(aw->v.ifname);
	if (dyn->pfid_kif == NULL) {
		rv = 1;
		goto _bad;
	}
	pfi_kif_ref(dyn->pfid_kif, PFI_KIF_REF_RULE);

	dyn->pfid_net = pfi_unmask(&aw->v.a.mask);
	if (af == AF_INET && dyn->pfid_net == 32)
		dyn->pfid_net = 128;
	strlcpy(tblname, aw->v.ifname, sizeof(tblname));
	if (aw->iflags & PFI_AFLAG_NETWORK)
		strlcat(tblname, ":network", sizeof(tblname));
	if (aw->iflags & PFI_AFLAG_BROADCAST)
		strlcat(tblname, ":broadcast", sizeof(tblname));
	if (aw->iflags & PFI_AFLAG_PEER)
		strlcat(tblname, ":peer", sizeof(tblname));
	if (aw->iflags & PFI_AFLAG_NOALIAS)
		strlcat(tblname, ":0", sizeof(tblname));
	if (dyn->pfid_net != 128)
		snprintf(tblname + strlen(tblname),
		    sizeof(tblname) - strlen(tblname), "/%d", dyn->pfid_net);
	if ((ruleset = pf_find_or_create_ruleset(PF_RESERVED_ANCHOR)) == NULL) {
		rv = 1;
		goto _bad;
	}

	if ((dyn->pfid_kt = pfr_attach_table(ruleset, tblname, 1)) == NULL) {
		rv = 1;
		goto _bad;
	}

	dyn->pfid_kt->pfrkt_flags |= PFR_TFLAG_ACTIVE;
	dyn->pfid_iflags = aw->iflags;
	dyn->pfid_af = af;

	TAILQ_INSERT_TAIL(&dyn->pfid_kif->pfik_dynaddrs, dyn, entry);
	aw->p.dyn = dyn;
	pfi_kif_update(dyn->pfid_kif);
	return (0);

_bad:
	if (dyn->pfid_kt != NULL)
		pfr_detach_table(dyn->pfid_kt);
	if (ruleset != NULL)
		pf_remove_if_empty_ruleset(ruleset);
	if (dyn->pfid_kif != NULL)
		pfi_kif_unref(dyn->pfid_kif, PFI_KIF_REF_RULE);
	pool_put(&pfi_addr_pl, dyn);
	return (rv);
}

void
pfi_kif_update(struct pfi_kif *kif)
{
	struct ifg_list		*ifgl;
	struct pfi_dynaddr	*p;

	/* update all dynaddr */
	TAILQ_FOREACH(p, &kif->pfik_dynaddrs, entry)
		pfi_dynaddr_update(p);

	/* again for all groups kif is member of */
	if (kif->pfik_ifp != NULL)
		TAILQ_FOREACH(ifgl, &kif->pfik_ifp->if_groups, ifgl_next)
			pfi_kif_update((struct pfi_kif *)
			    ifgl->ifgl_group->ifg_pf_kif);
}

void
pfi_dynaddr_update(struct pfi_dynaddr *dyn)
{
	struct pfi_kif		*kif;
	struct pfr_ktable	*kt;

	if (dyn == NULL || dyn->pfid_kif == NULL || dyn->pfid_kt == NULL)
		panic("pfi_dynaddr_update");

	kif = dyn->pfid_kif;
	kt = dyn->pfid_kt;

	if (kt->pfrkt_larg != pfi_update) {
		/* this table needs to be brought up-to-date */
		pfi_table_update(kt, kif, dyn->pfid_net, dyn->pfid_iflags);
		kt->pfrkt_larg = pfi_update;
	}
	pfr_dynaddr_update(kt, dyn);
}

void
pfi_table_update(struct pfr_ktable *kt, struct pfi_kif *kif, u_int8_t net, int flags)
{
	int			 e, size2 = 0;
	struct ifg_member	*ifgm;

	pfi_buffer_cnt = 0;

	if (kif->pfik_ifp != NULL)
		pfi_instance_add(kif->pfik_ifp, net, flags);
	else if (kif->pfik_group != NULL)
		TAILQ_FOREACH(ifgm, &kif->pfik_group->ifg_members, ifgm_next)
			pfi_instance_add(ifgm->ifgm_ifp, net, flags);

	if ((e = pfr_set_addrs(&kt->pfrkt_t, pfi_buffer, pfi_buffer_cnt, &size2,
	    NULL, NULL, NULL, 0, PFR_TFLAG_ALLMASK)))
		DPFPRINTF(LOG_ERR,
		    "pfi_table_update: cannot set %d new addresses "
		    "into table %s: %d", pfi_buffer_cnt, kt->pfrkt_name, e);
}

void
pfi_instance_add(struct ifnet *ifp, u_int8_t net, int flags)
{
	struct ifaddr	*ifa;
	int		 got4 = 0, got6 = 0;
	int		 net2, af;

	if (ifp == NULL)
		return;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr == NULL)
			continue;
		af = ifa->ifa_addr->sa_family;
		if (af != AF_INET && af != AF_INET6)
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) && af == AF_INET6)
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) &&
		    !(ifp->if_flags & IFF_BROADCAST))
			continue;
		if ((flags & PFI_AFLAG_PEER) &&
		    !(ifp->if_flags & IFF_POINTOPOINT))
			continue;
		if ((flags & PFI_AFLAG_NETWORK) && af == AF_INET6 &&
		    IN6_IS_ADDR_LINKLOCAL(
		    &((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr))
			continue;
		if (flags & PFI_AFLAG_NOALIAS) {
			if (af == AF_INET && got4)
				continue;
			if (af == AF_INET6 && got6)
				continue;
		}
		if (af == AF_INET)
			got4 = 1;
		else if (af == AF_INET6)
			got6 = 1;
		net2 = net;
		if (net2 == 128 && (flags & PFI_AFLAG_NETWORK)) {
			if (af == AF_INET)
				net2 = pfi_unmask(&((struct sockaddr_in *)
				    ifa->ifa_netmask)->sin_addr);
			else if (af == AF_INET6)
				net2 = pfi_unmask(&((struct sockaddr_in6 *)
				    ifa->ifa_netmask)->sin6_addr);
		}
		if (af == AF_INET && net2 > 32)
			net2 = 32;
		if (flags & PFI_AFLAG_BROADCAST)
			pfi_address_add(ifa->ifa_broadaddr, af, net2);
		else if (flags & PFI_AFLAG_PEER)
			pfi_address_add(ifa->ifa_dstaddr, af, net2);
		else
			pfi_address_add(ifa->ifa_addr, af, net2);
	}
}

void
pfi_address_add(struct sockaddr *sa, sa_family_t af, u_int8_t net)
{
	struct pfr_addr	*p;
	int		 i;

	if (pfi_buffer_cnt >= pfi_buffer_max) {
		int		 new_max = pfi_buffer_max * 2;

		if (new_max > PFI_BUFFER_MAX) {
			DPFPRINTF(LOG_ERR,
			    "pfi_address_add: address buffer full (%d/%d)",
			    pfi_buffer_cnt, PFI_BUFFER_MAX);
			return;
		}
		p = mallocarray(new_max, sizeof(*pfi_buffer), PFI_MTYPE,
		    M_DONTWAIT);
		if (p == NULL) {
			DPFPRINTF(LOG_ERR,
			    "pfi_address_add: no memory to grow buffer "
			    "(%d/%d)", pfi_buffer_cnt, PFI_BUFFER_MAX);
			return;
		}
		memcpy(p, pfi_buffer, pfi_buffer_max * sizeof(*pfi_buffer));
		/* no need to zero buffer */
		free(pfi_buffer, PFI_MTYPE, 0);
		pfi_buffer = p;
		pfi_buffer_max = new_max;
	}
	if (af == AF_INET && net > 32)
		net = 128;
	p = pfi_buffer + pfi_buffer_cnt++;
	bzero(p, sizeof(*p));
	p->pfra_af = af;
	p->pfra_net = net;
	if (af == AF_INET)
		p->pfra_ip4addr = ((struct sockaddr_in *)sa)->sin_addr;
	else if (af == AF_INET6) {
		p->pfra_ip6addr = ((struct sockaddr_in6 *)sa)->sin6_addr;
		if (IN6_IS_SCOPE_EMBED(&p->pfra_ip6addr))
			p->pfra_ip6addr.s6_addr16[1] = 0;
	}
	/* mask network address bits */
	if (net < 128)
		((caddr_t)p)[p->pfra_net/8] &= ~(0xFF >> (p->pfra_net%8));
	for (i = (p->pfra_net+7)/8; i < sizeof(p->pfra_u); i++)
		((caddr_t)p)[i] = 0;
}

void
pfi_dynaddr_remove(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL ||
	    aw->p.dyn->pfid_kif == NULL || aw->p.dyn->pfid_kt == NULL)
		return;

	TAILQ_REMOVE(&aw->p.dyn->pfid_kif->pfik_dynaddrs, aw->p.dyn, entry);
	pfi_kif_unref(aw->p.dyn->pfid_kif, PFI_KIF_REF_RULE);
	aw->p.dyn->pfid_kif = NULL;
	pfr_detach_table(aw->p.dyn->pfid_kt);
	aw->p.dyn->pfid_kt = NULL;
	pool_put(&pfi_addr_pl, aw->p.dyn);
	aw->p.dyn = NULL;
}

void
pfi_dynaddr_copyout(struct pf_addr_wrap *aw)
{
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL ||
	    aw->p.dyn->pfid_kif == NULL)
		return;
	aw->p.dyncnt = aw->p.dyn->pfid_acnt4 + aw->p.dyn->pfid_acnt6;
}

void
pfi_kifaddr_update(void *v)
{
	struct pfi_kif		*kif = (struct pfi_kif *)v;

	splsoftassert(IPL_SOFTNET);

	pfi_update++;
	pfi_kif_update(kif);
}

int
pfi_if_compare(struct pfi_kif *p, struct pfi_kif *q)
{
	return (strncmp(p->pfik_name, q->pfik_name, IFNAMSIZ));
}

void
pfi_update_status(const char *name, struct pf_status *pfs)
{
	struct pfi_kif		*p;
	struct pfi_kif_cmp	 key;
	struct ifg_member	 p_member, *ifgm;
	TAILQ_HEAD(, ifg_member) ifg_members;
	int			 i, j, k;

	if (*name == '\0' && pfs == NULL) {
		RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
			bzero(p->pfik_packets, sizeof(p->pfik_packets));
			bzero(p->pfik_bytes, sizeof(p->pfik_bytes));
			p->pfik_tzero = time_second;
		}
		return;
	}

	strlcpy(key.pfik_name, name, sizeof(key.pfik_name));
	p = RB_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&key);
	if (p == NULL) {
		return;
	}
	if (p->pfik_group != NULL) {
		memcpy(&ifg_members, &p->pfik_group->ifg_members,
		    sizeof(ifg_members));
	} else {
		/* build a temporary list for p only */
		bzero(&p_member, sizeof(p_member));
		p_member.ifgm_ifp = p->pfik_ifp;
		TAILQ_INIT(&ifg_members);
		TAILQ_INSERT_TAIL(&ifg_members, &p_member, ifgm_next);
	}
	if (pfs) {
		bzero(pfs->pcounters, sizeof(pfs->pcounters));
		bzero(pfs->bcounters, sizeof(pfs->bcounters));
	}
	TAILQ_FOREACH(ifgm, &ifg_members, ifgm_next) {
		if (ifgm->ifgm_ifp == NULL)
			continue;
		p = (struct pfi_kif *)ifgm->ifgm_ifp->if_pf_kif;

		/* just clear statistics */
		if (pfs == NULL) {
			bzero(p->pfik_packets, sizeof(p->pfik_packets));
			bzero(p->pfik_bytes, sizeof(p->pfik_bytes));
			p->pfik_tzero = time_second;
			continue;
		}
		for (i = 0; i < 2; i++)
			for (j = 0; j < 2; j++)
				for (k = 0; k < 2; k++) {
					pfs->pcounters[i][j][k] +=
						p->pfik_packets[i][j][k];
					pfs->bcounters[i][j] +=
						p->pfik_bytes[i][j][k];
				}
	}
}

int
pfi_get_ifaces(const char *name, struct pfi_kif *buf, int *size)
{
	struct pfi_kif	*p, *nextp;
	int		 n = 0;

	for (p = RB_MIN(pfi_ifhead, &pfi_ifs); p; p = nextp) {
		nextp = RB_NEXT(pfi_ifhead, &pfi_ifs, p);
		if (pfi_skip_if(name, p))
			continue;
		if (*size > n++) {
			if (!p->pfik_tzero)
				p->pfik_tzero = time_second;
			pfi_kif_ref(p, PFI_KIF_REF_RULE);
			if (copyout(p, buf++, sizeof(*buf))) {
				pfi_kif_unref(p, PFI_KIF_REF_RULE);
				return (EFAULT);
			}
			nextp = RB_NEXT(pfi_ifhead, &pfi_ifs, p);
			pfi_kif_unref(p, PFI_KIF_REF_RULE);
		}
	}
	*size = n;
	return (0);
}

int
pfi_skip_if(const char *filter, struct pfi_kif *p)
{
	struct ifg_list	*i;
	int		 n;

	if (filter == NULL || !*filter)
		return (0);
	if (!strcmp(p->pfik_name, filter))
		return (0);	/* exact match */
	n = strlen(filter);
	if (n < 1 || n >= IFNAMSIZ)
		return (1);	/* sanity check */
	if (filter[n-1] >= '0' && filter[n-1] <= '9')
		return (1);     /* group names may not end in a digit */
	if (p->pfik_ifp != NULL)
		TAILQ_FOREACH(i, &p->pfik_ifp->if_groups, ifgl_next)
			if (!strncmp(i->ifgl_group->ifg_group, filter, IFNAMSIZ))
				return (0);	/* iface is in group "filter" */
	return (1);
}

int
pfi_set_flags(const char *name, int flags)
{
	struct pfi_kif	*p;

	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
		if (pfi_skip_if(name, p))
			continue;
		p->pfik_flags_new = p->pfik_flags | flags;
	}
	return (0);
}

int
pfi_clear_flags(const char *name, int flags)
{
	struct pfi_kif	*p;

	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
		if (pfi_skip_if(name, p))
			continue;
		p->pfik_flags_new = p->pfik_flags & ~flags;
	}
	return (0);
}

void
pfi_xcommit(void)
{
	struct pfi_kif	*p;

	RB_FOREACH(p, pfi_ifhead, &pfi_ifs)
		p->pfik_flags = p->pfik_flags_new;
}

/* from pf_print_state.c */
int
pfi_unmask(void *addr)
{
	struct pf_addr *m = addr;
	int i = 31, j = 0, b = 0;
	u_int32_t tmp;

	while (j < 4 && m->addr32[j] == 0xffffffff) {
		b += 32;
		j++;
	}
	if (j < 4) {
		tmp = ntohl(m->addr32[j]);
		for (i = 31; tmp & (1 << i); --i)
			b++;
	}
	return (b);
}

@


1.88
log
@Kill recursive splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.87 2016/11/16 08:46:05 mpi Exp $ */
d217 1
a217 1
		return (1); 
@


1.87
log
@Kill recursive splsoftnet()s.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.86 2016/09/27 04:57:17 dlg Exp $ */
a225 1
	int			 s;
a227 1
	s = splsoftnet();
a240 2

	splx(s);
a245 1
	int			 s;
a250 1
	s = splsoftnet();
a257 2

	splx(s);
a263 1
	int		 s;
a265 1
	s = splsoftnet();
a271 2

	splx(s);
a276 1
	int		 s;
a281 1
	s = splsoftnet();
a286 1
	splx(s);
a292 1
	int			 s;
a293 1
	s = splsoftnet();
a298 2

	splx(s);
a594 1
	int			 s;
d597 2
a598 1
	s = splsoftnet();
a600 1
	splx(s);
@


1.86
log
@roll back turning RB into RBT until i get better at this process.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.85 2016/09/27 02:51:12 dlg Exp $ */
d359 1
a359 1
	int			 s, rv = 0;
a366 1
	s = splsoftnet();
a408 1
	splx(s);
a418 1
	splx(s);
a588 2
	int	s;

a592 1
	s = splsoftnet();
a599 1
	splx(s);
d636 1
a636 1
	int			 i, j, k, s;
a637 1
	s = splsoftnet();
a643 1
		splx(s);
a649 1
		splx(s);
a686 1
	splx(s);
d693 1
a693 1
	int		 s, n = 0;
a694 1
	s = splsoftnet();
a704 1
				splx(s);
a710 1
	splx(s);
a740 1
	int		 s;
a741 1
	s = splsoftnet();
a746 1
	splx(s);
a753 1
	int		 s;
a754 1
	s = splsoftnet();
a759 1
	splx(s);
a766 1
	int		 s;
a767 1
	s = splsoftnet();
a769 1
	splx(s);
@


1.85
log
@move pf from the RB macros to the RBT functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.84 2016/09/15 02:00:18 dlg Exp $ */
d75 1
a75 1
int		 pfi_if_compare(const struct pfi_kif *, const struct pfi_kif *);
d79 2
a80 2
RBT_PROTOTYPE(pfi_ifhead, pfi_kif, pfik_tree, pfi_if_compare);
RBT_GENERATE(pfi_ifhead, pfi_kif, pfik_tree, pfi_if_compare);
d108 1
a108 1
	return (RBT_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&s));
d133 1
a133 1
	RBT_INSERT(pfi_ifhead, &pfi_ifs, kif);
d198 1
a198 1
	RBT_REMOVE(pfi_ifhead, &pfi_ifs, kif);
d631 1
a631 1
pfi_if_compare(const struct pfi_kif *p, const struct pfi_kif *q)
d647 1
a647 1
		RBT_FOREACH(p, pfi_ifhead, &pfi_ifs) {
d657 1
a657 1
	p = RBT_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&key);
d707 2
a708 2
	for (p = RBT_MIN(pfi_ifhead, &pfi_ifs); p; p = nextp) {
		nextp = RBT_NEXT(pfi_ifhead, p);
d720 1
a720 1
			nextp = RBT_NEXT(pfi_ifhead, p);
d758 1
a758 1
	RBT_FOREACH(p, pfi_ifhead, &pfi_ifs) {
d774 1
a774 1
	RBT_FOREACH(p, pfi_ifhead, &pfi_ifs) {
d790 1
a790 1
	RBT_FOREACH(p, pfi_ifhead, &pfi_ifs)
@


1.84
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.83 2016/09/02 10:19:49 dlg Exp $ */
d75 1
a75 1
int		 pfi_if_compare(struct pfi_kif *, struct pfi_kif *);
d79 2
a80 2
RB_PROTOTYPE(pfi_ifhead, pfi_kif, pfik_tree, pfi_if_compare);
RB_GENERATE(pfi_ifhead, pfi_kif, pfik_tree, pfi_if_compare);
d108 1
a108 1
	return (RB_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&s));
d133 1
a133 1
	RB_INSERT(pfi_ifhead, &pfi_ifs, kif);
d198 1
a198 1
	RB_REMOVE(pfi_ifhead, &pfi_ifs, kif);
d631 1
a631 1
pfi_if_compare(struct pfi_kif *p, struct pfi_kif *q)
d647 1
a647 1
		RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
d657 1
a657 1
	p = RB_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&key);
d707 2
a708 2
	for (p = RB_MIN(pfi_ifhead, &pfi_ifs); p; p = nextp) {
		nextp = RB_NEXT(pfi_ifhead, &pfi_ifs, p);
d720 1
a720 1
			nextp = RB_NEXT(pfi_ifhead, &pfi_ifs, p);
d758 1
a758 1
	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
d774 1
a774 1
	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
d790 1
a790 1
	RB_FOREACH(p, pfi_ifhead, &pfi_ifs)
@


1.83
log
@pool_setipl for pf bits

ok phessler@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.82 2015/11/20 03:35:23 dlg Exp $ */
d91 1
a91 1
	pool_init(&pfi_addr_pl, sizeof(struct pfi_dynaddr), 0, 0, 0,
a92 1
	pool_setipl(&pfi_addr_pl, IPL_SOFTNET);
@


1.82
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.81 2015/10/30 11:33:55 mikeb Exp $ */
d93 1
@


1.81
log
@Clean up handling of 'clear states' pfsync packets.

If interface was specified in the packet only if-bound states
attached to this interface must be purged.

ok mpi, looked at by sasha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.80 2015/09/04 21:40:25 kettenis Exp $ */
a259 5

	if (HFSC_ENABLED(&ifp->if_snd)) {
		pf_remove_queues(ifp);
		pf_free_queues(pf_queues_active, ifp);
	}
@


1.80
log
@The pf_osfp_pl and pf_osfp_entry_pl never get used in interrupt context.
Drop the explicit pool backend allocator here and add PR_WAITOK to the
flags passed to pool_init(9).

The pfi_addr_pl and pf_rule_pl can get used in interrupt context though.
So simply drop the explicit pool backend allocator without adding PR_WAITOK
to the flags passed to pool_init(9).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.79 2015/07/21 02:32:04 sashan Exp $ */
d102 1
a102 1
pfi_kif_get(const char *kif_name)
a103 1
	struct pfi_kif		*kif;
d108 9
a116 1
	if ((kif = RB_FIND(pfi_ifhead, &pfi_ifs, (struct pfi_kif *)&s)) != NULL)
@


1.79
log
@- added /* FALLTHROUGH */ comments, typecasts (u_int32_t)-1, ...


ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.78 2015/03/14 03:38:51 jsg Exp $ */
d92 1
a92 1
	    "pfiaddrpl", &pool_allocator_nointr);
@


1.78
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.77 2014/12/19 17:14:40 tedu Exp $ */
d71 1
a71 1
		    int, int);
d73 2
a74 2
void		 pfi_instance_add(struct ifnet *, int, int);
void		 pfi_address_add(struct sockaddr *, int, int);
d461 1
a461 1
pfi_table_update(struct pfr_ktable *kt, struct pfi_kif *kif, int net, int flags)
d482 1
a482 1
pfi_instance_add(struct ifnet *ifp, int net, int flags)
d539 1
a539 1
pfi_address_add(struct sockaddr *sa, int af, int net)
@


1.77
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.76 2014/12/05 15:50:04 mpi Exp $ */
a48 1
#include <net/if_types.h>
@


1.76
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.75 2014/12/02 18:11:56 tedu Exp $ */
a322 1
#ifdef INET
a333 1
#endif /* INET */
@


1.75
log
@replace some malloc multiplies with mallocarry. ok deraadt henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.74 2014/07/22 11:06:09 mpi Exp $ */
d48 1
@


1.74
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.73 2014/07/12 18:44:22 tedu Exp $ */
d94 1
a94 1
	pfi_buffer = malloc(pfi_buffer_max * sizeof(*pfi_buffer),
d555 1
a555 1
		p = malloc(new_max * sizeof(*pfi_buffer), PFI_MTYPE,
@


1.73
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.72 2014/01/22 04:33:34 henning Exp $ */
a50 1
#include <netinet/in_systm.h>
@


1.72
log
@7x bcopy -> memcpy, impossibility of overlaps verified. ok benno dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.71 2014/01/21 01:50:07 henning Exp $ */
d193 1
a193 1
	free(kif, PFI_MTYPE);
d566 1
a566 1
		free(pfi_buffer, PFI_MTYPE);
@


1.71
log
@introduce a way to match "any" interface, excluding loopback ones.
pfi_kif_get annotates the kif with a flag indicating it is the "any" match
pfi_kif_match obeys that flag
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.69 2014/01/03 12:43:09 pelikan Exp $ */
d664 1
a664 1
		bcopy(&p->pfik_group->ifg_members, &ifg_members,
@


1.70
log
@Name the local variables for struct ifaddr consistently "ifa".
OK mikeb@@
@
text
@d121 6
d208 4
@


1.69
log
@Make queues disappear correctly on interfaces being destroyed.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.68 2013/10/17 16:27:42 bluhm Exp $ */
d477 1
a477 1
	struct ifaddr	*ia;
d483 2
a484 2
	TAILQ_FOREACH(ia, &ifp->if_addrlist, ifa_list) {
		if (ia->ifa_addr == NULL)
d486 1
a486 1
		af = ia->ifa_addr->sa_family;
d499 1
a499 1
		    &((struct sockaddr_in6 *)ia->ifa_addr)->sin6_addr))
d515 1
a515 1
				    ia->ifa_netmask)->sin_addr);
d518 1
a518 1
				    ia->ifa_netmask)->sin6_addr);
d523 1
a523 1
			pfi_address_add(ia->ifa_broadaddr, af, net2);
d525 1
a525 1
			pfi_address_add(ia->ifa_dstaddr, af, net2);
d527 1
a527 1
			pfi_address_add(ia->ifa_addr, af, net2);
@


1.68
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.67 2013/08/30 18:23:17 haesbaert Exp $ */
d245 5
d253 1
@


1.67
log
@Missing splx on return path.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.66 2013/06/20 12:03:40 mpi Exp $ */
a50 1
#include <netinet/in_var.h>
@


1.66
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.65 2013/06/20 09:38:24 mpi Exp $ */
d638 1
@


1.65
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.64 2012/12/28 17:52:06 gsoares Exp $ */
d222 1
a222 1
	if ((kif->pfik_ah_cookie = hook_establish(&ifp->if_addrhooks, 1,
d243 1
a243 1
	hook_disestablish(&ifp->if_addrhooks, kif->pfik_ah_cookie);
@


1.64
log
@change the malloc(9) flags from M_DONTWAIT to M_NOWAIT; OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.63 2011/07/28 11:03:49 henning Exp $ */
d222 1
a222 1
	if ((kif->pfik_ah_cookie = hook_establish(ifp->if_addrhooks, 1,
d243 1
a243 1
	hook_disestablish(ifp->if_addrhooks, kif->pfik_ah_cookie);
@


1.63
log
@fix set skip group matching: don't match partial strings, i. e. 'set skip on
lo' must not match a group 'local'. diff from sthen who is not around for a
few days, ok me and mpf. I can't find the mail of the guy who initially
ran into this problem, sorry for that, thanks for reporting!
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.62 2011/05/20 22:50:44 sthen Exp $ */
d115 1
a115 1
	if ((kif = malloc(sizeof(*kif), PFI_MTYPE, M_DONTWAIT|M_ZERO)) == NULL)
@


1.62
log
@Change 'set skip on <...>' to work with interface groups.
Feedback from various people, ok henning@@

Previously if an interface type (without number), e.g. "set skip on vlan"
or "set skip on em" was used, it would have the undocumented behaviour of
matching any interface of that type.

Now it will only match an interface which is a member of the named group.
This results in some changed behaviour:

If you currently use "set skip" with a physical interface type (e.g.
"set skip on ix") you will need to add the interface to a group of that
name: 'ifconfig ix0 group ix' or add 'group ix' to hostname.ix0.

Interfaces cloned at runtime (e.g. lo, trunk, vlan, pppoe, carp, gif,
mpe and others) default to being in a group named after the interface type,
so for these interfaces there will be no change in behaviour unless you
have deliberately changed groups, e.g. 'ifconfig carp456 -group carp'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.61 2010/06/28 23:21:41 mcbride Exp $ */
d731 1
a731 1
			if (!strncmp(i->ifgl_group->ifg_group, filter, n))
@


1.61
log
@Clean up iterface stats handling:
- 'make -Fi' reset ALL the interface statistics
     can be restricted with -i ifname
- 'make -Fa -i ifname' fail (it's meaningless)
- get rid of a silly little struct that's only used for one thing

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.60 2010/01/18 23:52:46 mcbride Exp $ */
d717 2
a718 1
	int	n;
d728 6
a733 4
		return (1);	/* only do exact match in that case */
	if (strncmp(p->pfik_name, filter, n))
		return (1);	/* prefix doesn't match */
	return (p->pfik_name[n] < '0' || p->pfik_name[n] > '9');
@


1.60
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.59 2010/01/12 03:20:51 mcbride Exp $ */
d631 10
a641 1
	s = splsoftnet();
@


1.59
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.58 2009/08/25 23:21:04 krw Exp $ */
d45 1
d155 2
a156 1
			printf("pfi_kif_unref: rules refcount <= 0\n");
d163 2
a164 1
			printf("pfi_kif_unref: state refcount <= 0\n");
d171 2
a172 1
			printf("pfi_kif_unref: state refcount <= 0\n");
d464 3
a466 2
		printf("pfi_table_update: cannot set %d new addresses "
		    "into table %s: %d\n", pfi_buffer_cnt, kt->pfrkt_name, e);
d536 2
a537 1
			printf("pfi_address_add: address buffer full (%d/%d)\n",
d544 3
a546 2
			printf("pfi_address_add: no memory to grow buffer "
			    "(%d/%d)\n", pfi_buffer_cnt, PFI_BUFFER_MAX);
@


1.58
log
@Clearly copy the whole, and nothing but the whole, old buffer into
the resized buffer.

From Pawel Jakob Dawidek via Max Laier via Marc Balmer via tech@@.
As was the previous commit where I didn't mention Pawel.

'should be olright' henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.57 2009/08/25 10:42:27 krw Exp $ */
d135 3
d166 7
d180 1
a180 1
	if (kif->pfik_rules || kif->pfik_states)
@


1.57
log
@Fix order of memcpy() arguments so data is copied from src to dest,
not the other way. At least partial fix for interfaces with >64
aliases. From Max Laier via Marc Balmer.

'seems right' sthen@@ ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.56 2009/03/09 13:53:10 mcbride Exp $ */
d532 1
a532 1
		memcpy(p, pfi_buffer, pfi_buffer_cnt * sizeof(*pfi_buffer));
@


1.56
log
@Make the DIOCSETIFFLAG, DIOCSETLIMIT, and DIOCSETTIMEOUT ioctls
transactional, closing PRs 4941 and 5910.  Minor flag day, requires rebuild
of userland tools that use struct pfi_kif.

ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.55 2008/11/24 13:22:09 mikeb Exp $ */
d532 1
a532 1
		memcpy(pfi_buffer, p, pfi_buffer_cnt * sizeof(*pfi_buffer));
@


1.55
log
@Fix splasserts seen in pr 5987 by propagating a flag that discribes
whether we're called from the interrupt context to the functions
performing allocations.

Looked at by mpf@@ and henning@@, tested by mpf@@ and Antti Harri,
the pr originator.

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.54 2008/06/14 16:55:28 mk Exp $ */
d717 1
a717 1
		p->pfik_flags |= flags;
d733 1
a733 1
		p->pfik_flags &= ~flags;
d737 12
@


1.54
log
@Also do the PR_ZERO dance here.  This was held back on Henning's request
because it conflicted with the change he did in pf_if.c earlier.

He finally woke up to ok (well, ``yes'', really) this version now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.53 2008/06/14 02:22:13 henning Exp $ */
d370 1
a370 1
	if ((dyn->pfid_kt = pfr_attach_table(ruleset, tblname)) == NULL) {
@


1.53
log
@pool_get()s not in interrupt context should not be PR_NOWAIT, but
PR_WAITOK | PR_LIMITFAIL. from discussion with art. ok ryan claudio thib
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.52 2008/05/18 11:54:04 mcbride Exp $ */
d335 2
a336 1
	if ((dyn = pool_get(&pfi_addr_pl, PR_WAITOK|PR_LIMITFAIL)) == NULL)
a337 1
	bzero(dyn, sizeof(*dyn));
@


1.52
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.51 2007/11/07 17:28:40 mpf Exp $ */
d335 1
a335 1
	if ((dyn = pool_get(&pfi_addr_pl, PR_NOWAIT)) == NULL)
@


1.51
log
@Check for pfi_kif's that are neither groups nor have a real interface.
This prevents a null-deref when empty groups are used in set loginterface.
Fixes PR 5628 as reported by Andreas Bihlmaier.
Bad mpf :(
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.50 2007/09/27 22:24:05 mpf Exp $ */
d609 1
a609 1
	struct pfi_kif_cmp 	 key;
@


1.50
log
@Add loginterface support for groups.
Using a group sums up the statistics of all members.
Modify pfctl(1) slightly to allow a groupname "all",
which gives us an overall pf(4) statistic.

OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.49 2007/09/15 16:43:51 henning Exp $ */
d636 2
@


1.49
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.48 2007/09/01 18:49:27 henning Exp $ */
d606 1
a606 1
pfi_fill_oldstatus(struct pf_status *pfs)
d610 2
d614 1
a614 1
	strlcpy(key.pfik_name, pfs->ifname, sizeof(key.pfik_name));
d621 22
a642 22
	bzero(pfs->pcounters, sizeof(pfs->pcounters));
	bzero(pfs->bcounters, sizeof(pfs->bcounters));
	for (i = 0; i < 2; i++)
		for (j = 0; j < 2; j++)
			for (k = 0; k < 2; k++) {
				pfs->pcounters[i][j][k] =
					p->pfik_packets[i][j][k];
				pfs->bcounters[i][j] +=
					p->pfik_bytes[i][j][k];
			}
	splx(s);
}

int
pfi_clr_istats(const char *name)
{
	struct pfi_kif	*p;
	int		 s;

	s = splsoftnet();
	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
		if (pfi_skip_if(name, p))
d644 9
a652 3
		bzero(p->pfik_packets, sizeof(p->pfik_packets));
		bzero(p->pfik_bytes, sizeof(p->pfik_bytes));
		p->pfik_tzero = time_second;
a654 2

	return (0);
@


1.48
log
@since the
MGET* macros were changed to function calls, there wasn't any
need for the pool declarations and the inclusion of pool.h
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.47 2007/07/13 09:17:48 markus Exp $ */
d114 1
a114 1
	if ((kif = malloc(sizeof(*kif), PFI_MTYPE, M_DONTWAIT)) == NULL)
a116 1
	bzero(kif, sizeof(*kif));
@


1.47
log
@remove obsolete pfi_statehead and pfik_w_states; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.46 2006/12/13 09:01:59 itojun Exp $ */
d44 1
@


1.46
log
@use IN6_IS_SCOPE_EMBED to check kernel-internal form addresses
(s6_addr16[1] filled)
ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.45 2006/01/30 12:39:13 henning Exp $ */
a60 1
struct pfi_statehead	  pfi_statehead;
a90 1
	TAILQ_INIT(&pfi_statehead);
d133 1
a133 2
		if (!kif->pfik_states++)
			TAILQ_INSERT_TAIL(&pfi_statehead, kif, pfik_w_states);
d161 1
a161 2
		if (!--kif->pfik_states)
			TAILQ_REMOVE(&pfi_statehead, kif, pfik_w_states);
@


1.45
log
@fix updating of tables associated with interface groups used in
pass to (ifgroup)
style notation.
instead of walking the list of associated dynaddrs with a pf-abstracted
interface which might not be present when there is no reference
to them in the rulset, and checking their pointer back to the interface
for group memberships, walk the groups an interface is member of
directly. even makes the code easier.
tests & ok bob ryan markus + tested moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.44 2005/09/28 01:46:32 pascoe Exp $ */
d552 1
a552 1
		if (IN6_IS_ADDR_LINKLOCAL(&p->pfra_ip6addr))
@


1.44
log
@Improve the safety of pf IOCTLs, taking into account that some paths can sleep.

- Introduces a rw_lock in pfioctl so that we can have concurrent readers
  but only one process performing updates at a time;

- Separates state expiry into "unlink" and "free" parts; anyone can unlink
  a state/src node from the RB trees at any time, but a state can only be
  freed whilst the write lock is held;

- Converts state_updates into list state_list containing all states,
  regardless of whether they are "linked" or "unlinked";

- Introduces a new PFTM_UNLINKED state that is used on the "unlinked" states
  to signal that they can be freed;

- Converts pf_purge_expired_state to an "unlink" state routine, which only
  unlinks the state from the RB trees.  Freeing the state/src nodes is left
  to the purge thread, which runs whilst holding a write lock, such that all
  "next" references remain valid;

- Converts pfsync_bulk_update and DIOCGETSTATES to walk state_list rather
  than the RB trees;

- Converts the purge thread to use the new state_list and perform a partial
  purge every second, with the target rate a full state table walk every
  PFTM_INTERVAL seconds.

seen by mcbride, henning, dhartmei pre-3.8, but too intrusive for then
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.43 2005/08/18 10:28:14 pascoe Exp $ */
d69 1
a200 1
	struct pfi_dynaddr	*dyn;
d217 1
a217 2
	TAILQ_FOREACH(dyn, &kif->pfik_dynaddrs, entry)
		pfi_dynaddr_update(dyn);
a226 1
	struct pfi_dynaddr	*dyn;
d234 1
a234 2
	TAILQ_FOREACH(dyn, &kif->pfik_dynaddrs, entry)
		pfi_dynaddr_update(dyn);
a281 1
	struct pfi_dynaddr	*dyn;
d289 1
a289 2
	TAILQ_FOREACH(dyn, &kif->pfik_dynaddrs, entry)
		pfi_dynaddr_update(dyn);
d385 1
a385 1
	pfi_dynaddr_update(aw->p.dyn);
d402 17
a422 2
	struct ifg_list		*ifgl;
	struct pfi_dynaddr	*p;
a435 6

	if (kif->pfik_ifp != NULL)
		TAILQ_FOREACH(ifgl, &kif->pfik_ifp->if_groups, ifgl_next)
			TAILQ_FOREACH(p, &((struct pfi_kif *)
			    ifgl->ifgl_group->ifg_pf_kif)->pfik_dynaddrs, entry)
				pfi_dynaddr_update(p);
a595 1
	struct pfi_dynaddr	*dyn;
d599 1
a599 2
	TAILQ_FOREACH(dyn, &kif->pfik_dynaddrs, entry)
		pfi_dynaddr_update(dyn);
@


1.43
log
@Rearrange pf_state and pfi_kif so that the parts of the structure needed
to search for a particular entry in the RB trees are at the start of the
structure.

This permits us to place a much smaller structure on the stack in the
interrupt paths that match packets against state entries.

ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.42 2005/08/07 11:35:59 pascoe Exp $ */
d656 1
a656 1
	struct pfi_kif	*p;
d660 2
a661 1
	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
d667 1
d669 1
d673 2
@


1.42
log
@Reset kif->pfik_ifp to NULL before calling pfi_kif_unref(), similar change
to that in rev 1.40 for interface groups.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.41 2005/08/02 12:40:42 pascoe Exp $ */
d105 2
a106 1
	struct pfi_kif	s, *kif;
d110 1
a110 1
	if ((kif = RB_FIND(pfi_ifhead, &pfi_ifs, &s)) != NULL)
d610 3
a612 2
	struct pfi_kif	*p, key;
	int		 i, j, k, s;
d616 1
a616 1
	p = RB_FIND(pfi_ifhead, &pfi_ifs, &key);
@


1.41
log
@Instead of copying a table structure so we can mask off a bit before
"validating" it, pass the bits to be ignored down to the validating
function in its allowedflags argument.  Saves a 1kB+ stack allocation.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.40 2005/07/20 17:06:30 henning Exp $ */
a237 1
	pfi_kif_unref(kif, PFI_KIF_REF_NONE);
d240 1
@


1.40
log
@need to reset kif->pfik_group to NULL before calling pfi_kif_unref() so it can
notice that this kif is not referenced and not attached to an interface
or a group and actually deletes it. plugs a memleak, PR 4267 is caused by
this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.39 2005/06/06 03:44:21 henning Exp $ */
a436 1
	struct pfr_table	 t;
d447 2
a448 4
	t = kt->pfrkt_t;
	t.pfrt_flags = 0;
	if ((e = pfr_set_addrs(&t, pfi_buffer, pfi_buffer_cnt, &size2,
	    NULL, NULL, NULL, 0)))
@


1.39
log
@use a define instead of hardcoding "all" in 3 places
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.38 2005/06/05 20:47:46 henning Exp $ */
a121 1

a273 1
	pfi_kif_unref(kif, PFI_KIF_REF_NONE);
d276 1
@


1.38
log
@const'ify the char * parameter to pfi_kif_get and pfi_group_change
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.37 2005/06/02 17:51:48 henning Exp $ */
d98 1
a98 1
	if ((pfi_all = pfi_kif_get("all")) == NULL)
d350 1
a350 1
		dyn->pfid_kif = pfi_kif_get("all");
@


1.37
log
@tsc, ryan left debug crap behind
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.36 2005/05/28 20:26:25 mcbride Exp $ */
d103 1
a103 1
pfi_kif_get(char *kif_name)
d282 1
a282 1
pfi_group_change(char *group)
@


1.36
log
@Remove duplicate pfi_ifs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.35 2005/05/27 19:16:32 henning Exp $ */
d430 1
a430 3
			    ifgl->ifgl_group->ifg_pf_kif)->pfik_dynaddrs, entry) {

				if (p == dyn) panic("henning is a knob");
a431 1
			}
@


1.35
log
@-in our current model, a kif has either a pointer to an interface (ifnet) or
a group, or there cannot be addresses associated with it. so we can get rid
of checking kifs in the 3rd case and just be done with it.
-we don't need to try to manually clear the table used for the (interface)
notation when both the ifp and the group pointers are NULL, the pfr_set_addrs
call will do the right thing with an empty set of addrs
suggested by cedric, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.34 2005/05/26 05:28:35 henning Exp $ */
a60 1
struct pfi_ifhead	  pfi_ifs;
d430 3
a432 1
			    ifgl->ifgl_group->ifg_pf_kif)->pfik_dynaddrs, entry)
d434 1
@


1.34
log
@turd polishing
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.33 2005/05/26 05:21:16 henning Exp $ */
a438 1
	struct pfi_kif		*p;
a441 4
	if (kif->pfik_ifp == NULL && kif->pfik_group == NULL) {
		pfr_clr_addrs(&kt->pfrkt_t, NULL, 0);
		return;
	}
a448 4
	else
		RB_FOREACH(p, pfi_ifhead, &pfi_ifs)
			if (p->pfik_ifp != NULL)
				pfi_instance_add(p->pfik_ifp, net, flags);
@


1.33
log
@repair (self) notation - just attach "self" to the "all" group
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.32 2005/05/25 06:50:05 henning Exp $ */
d345 1
a345 2
	dyn = pool_get(&pfi_addr_pl, PR_NOWAIT);
	if (dyn == NULL)
d375 1
a375 2
	ruleset = pf_find_or_create_ruleset(PF_RESERVED_ANCHOR);
	if (ruleset == NULL) {
d380 1
a380 2
	dyn->pfid_kt = pfr_attach_table(ruleset, tblname);
	if (dyn->pfid_kt == NULL) {
d506 1
a506 1
			if (af == AF_INET) {
d509 1
a509 1
			} else if (af == AF_INET6) {
a511 1
			}
d559 1
a559 1
	if (af == AF_INET6) {
@


1.32
log
@when an interface joins or leaves a group call back into pf so it can
update the internal tables used for (ifgroup) notation
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.31 2005/05/24 04:17:19 henning Exp $ */
d351 4
a354 1
	dyn->pfid_kif = pfi_kif_get(aw->v.ifname);
@


1.31
log
@add support for brace notation for interface groups, i. e. (testgroup) matches
all IPs on all interfaces in testgroup
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.30 2005/05/23 22:30:21 henning Exp $ */
d282 18
d451 1
a451 1
	else if (kif->pfik_group != NULL) {
d454 1
a454 1
	} else
@


1.30
log
@further cleanup: don't mimic ifnet and add hooks and the dohooks() stuff to
pf's interface abstraction, just attahc a linked list of the dynaddrs to
the respective kifs. makes things way easier and will be needed for the next
step, ryan jajajaja
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.28 2005/05/22 18:35:43 henning Exp $ */
d394 2
d409 6
d423 1
d425 1
a425 1
	if (kif->pfik_ifp == NULL) {
d433 4
a436 1
	else
@


1.29
log
@repair updates for the tables used for (interface) notation
the way it is done is completely retarded, needs fixing
with ryan
@
text
@d70 1
a70 1
void		 pfi_dynaddr_update(void *);
d120 1
a120 9

	if ((kif->pfik_ah_head = malloc(sizeof(*kif->pfik_ah_head), PFI_MTYPE,
	    M_DONTWAIT)) == NULL) {
		free(kif, PFI_MTYPE);
		return (NULL);
	}

	bzero(kif->pfik_ah_head, sizeof(*kif->pfik_ah_head));
	TAILQ_INIT(kif->pfik_ah_head);
a177 1
	free(kif->pfik_ah_head, PFI_MTYPE);
d200 3
a202 2
	struct pfi_kif	*kif;
	int		 s;
d217 3
a219 1
	dohooks(kif->pfik_ah_head, 0);
d227 3
a229 2
	int		 s;
	struct pfi_kif	*kif;
d237 2
a238 1
	dohooks(kif->pfik_ah_head, 0);
a369 6
	dyn->pfid_hook_cookie = hook_establish(dyn->pfid_kif->pfik_ah_head, 1,
	    pfi_dynaddr_update, dyn);
	if (dyn->pfid_hook_cookie == NULL) {
		rv = 1;
		goto _bad;
	}
d371 1
d390 1
a390 1
pfi_dynaddr_update(void *p)
a391 1
	struct pfi_dynaddr	*dyn = (struct pfi_dynaddr *)p;
d552 1
a552 2
	hook_disestablish(aw->p.dyn->pfid_kif->pfik_ah_head,
	    aw->p.dyn->pfid_hook_cookie);
d574 3
a576 1
	int		 s;
d580 2
a581 1
	dohooks(((struct pfi_kif *)v)->pfik_ah_head, 0);
@


1.28
log
@no need to search for the kif before callig pf_get_kif, it does that for us
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.27 2005/05/22 18:23:04 henning Exp $ */
d214 1
a214 1

d240 1
d258 1
d278 1
d588 1
@


1.27
log
@allow pf to match on interface groups
pass on mygroup ...
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.26 2005/05/21 21:05:16 henning Exp $ */
d209 1
a209 1
	struct pfi_kif	*kif, key;
d215 2
a216 4
	strlcpy(key.pfik_name, ifp->if_xname, sizeof(key.pfik_name));
	if ((kif = RB_FIND(pfi_ifhead, &pfi_ifs, &key)) == NULL)
		if ((kif = pfi_kif_get(ifp->if_xname)) == NULL)
			panic("pfi_kif_get failed");
@


1.26
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.25 2005/05/21 21:03:57 henning Exp $ */
d179 1
a179 2
	/* XXX check for ifgroups ptr too */
	if (kif->pfik_ifp != NULL || kif == pfi_all)
d193 2
d198 4
a201 1
	/* XXX walk rule_kif's ifgroups and check for match */
d251 34
a430 1
	/* XXXXXX bugs bugs bugs ? */
@


1.25
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.24 2005/04/21 13:34:45 pascoe Exp $ */
d243 1
a243 1
	ifp->if_pf_kif = NULL;	
@


1.24
log
@Catch failed hook_establish call immediately, rather than misbehaving and
panicing at detach time.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.23 2004/12/22 17:17:55 dhartmei Exp $ */
d4 2
d60 1
a60 12
#define ACCEPT_FLAGS(oklist)			\
	do {					\
		if ((flags & ~(oklist)) &	\
		    PFI_FLAG_ALLMASK)		\
			return (EINVAL);	\
	} while (0)

#define senderr(e)      do { rv = (e); goto _bad; } while (0)

struct pfi_kif		**pfi_index2kif;
struct pfi_kif		 *pfi_self;
int			  pfi_indexlim;
a62 1
int			  pfi_ifcnt;
d64 1
a70 1
void		 pfi_kifaddr_update(void *);
d73 1
d77 1
a77 4
struct pfi_kif	*pfi_if_create(const char *, struct pfi_kif *, int);
void		 pfi_copy_group(char *, const char *, int);
void		 pfi_newgroup(const char *, int);
int		 pfi_skip_if(const char *, struct pfi_kif *, int);
a78 1
void		 pfi_dohooks(struct pfi_kif *);
d89 1
a89 1
	if (pfi_self != NULL)	/* already initialized */
d98 35
a132 1
	pfi_self = pfi_if_create("self", NULL, PFI_IFLAG_GROUP);
d136 1
a136 1
pfi_attach_clone(struct if_clone *ifc)
d138 11
a148 2
	pfi_initialize();
	pfi_newgroup(ifc->ifc_name, PFI_IFLAG_CLONABLE);
d152 1
a152 1
pfi_attach_ifnet(struct ifnet *ifp)
d154 2
a155 2
	struct pfi_kif	*p, *q, key;
	int		 s;
d157 20
a176 29
	pfi_initialize();
	s = splsoftnet();
	pfi_update++;
	if (ifp->if_index >= pfi_indexlim) {
		/*
		 * grow pfi_index2kif,  similar to ifindex2ifnet code in if.c
		 */
		size_t m, n, oldlim;
		struct pfi_kif **mp, **np;

		oldlim = pfi_indexlim;
		if (pfi_indexlim == 0)
			pfi_indexlim = 64;
		while (ifp->if_index >= pfi_indexlim)
			pfi_indexlim <<= 1;

		m = oldlim * sizeof(struct pfi_kif *);
		mp = pfi_index2kif;
		n = pfi_indexlim * sizeof(struct pfi_kif *);
		np = malloc(n, PFI_MTYPE, M_DONTWAIT);
		if (np == NULL)
			panic("pfi_attach_ifnet: "
			    "cannot allocate translation table");
		bzero(np, n);
		if (mp != NULL)
			bcopy(mp, np, m);
		pfi_index2kif = np;
		if (mp != NULL)
			free(mp, PFI_MTYPE);
d179 10
a188 30
	strlcpy(key.pfik_name, ifp->if_xname, sizeof(key.pfik_name));
	p = RB_FIND(pfi_ifhead, &pfi_ifs, &key);
	if (p == NULL) {
		/* add group */
		pfi_copy_group(key.pfik_name, ifp->if_xname,
		    sizeof(key.pfik_name));
		q = RB_FIND(pfi_ifhead, &pfi_ifs, &key);
		if (q == NULL)
		    q = pfi_if_create(key.pfik_name, pfi_self, PFI_IFLAG_GROUP);
		if (q == NULL)
			panic("pfi_attach_ifnet: "
			    "cannot allocate '%s' group", key.pfik_name);

		/* add interface */
		p = pfi_if_create(ifp->if_xname, q, PFI_IFLAG_INSTANCE);
		if (p == NULL)
			panic("pfi_attach_ifnet: "
			    "cannot allocate '%s' interface", ifp->if_xname);
	} else
		q = p->pfik_parent;
	p->pfik_ifp = ifp;
	p->pfik_flags |= PFI_IFLAG_ATTACHED;
	p->pfik_ah_cookie =
	    hook_establish(ifp->if_addrhooks, 1, pfi_kifaddr_update, p);
	if (p->pfik_ah_cookie == NULL)
		panic("pfi_attach_ifnet: cannot allocate '%s' address hook",
		    ifp->if_xname);
	pfi_index2kif[ifp->if_index] = p;
	pfi_dohooks(p);
	splx(s);
d191 2
a192 2
void
pfi_detach_ifnet(struct ifnet *ifp)
d194 2
a195 2
	struct pfi_kif	*p, *q, key;
	int		 s;
d197 1
a197 1
	strlcpy(key.pfik_name, ifp->if_xname, sizeof(key.pfik_name));
d199 1
a199 16
	s = splsoftnet();
	pfi_update++;
	p = RB_FIND(pfi_ifhead, &pfi_ifs, &key);
	if (p == NULL) {
		printf("pfi_detach_ifnet: cannot find %s", ifp->if_xname);
		splx(s);
		return;
	}
	hook_disestablish(p->pfik_ifp->if_addrhooks, p->pfik_ah_cookie);
	q = p->pfik_parent;
	p->pfik_ifp = NULL;
	p->pfik_flags &= ~PFI_IFLAG_ATTACHED;
	pfi_index2kif[ifp->if_index] = NULL;
	pfi_dohooks(p);
	pfi_maybe_destroy(p);
	splx(s);
d202 2
a203 2
struct pfi_kif *
pfi_lookup_create(const char *name)
d205 1
a205 1
	struct pfi_kif	*p, *q, key;
d208 1
a209 15
	p = pfi_lookup_if(name);
	if (p == NULL) {
		pfi_copy_group(key.pfik_name, name, sizeof(key.pfik_name));
		q = pfi_lookup_if(key.pfik_name);
		if (q == NULL) {
			pfi_newgroup(key.pfik_name, PFI_IFLAG_DYNAMIC);
			q = pfi_lookup_if(key.pfik_name);
		}
		p = pfi_lookup_if(name);
		if (p == NULL && q != NULL)
			p = pfi_if_create(name, q, PFI_IFLAG_INSTANCE);
	}
	splx(s);
	return (p);
}
d211 13
a223 4
struct pfi_kif *
pfi_attach_rule(const char *name)
{
	struct pfi_kif	*p;
d225 1
a225 4
	p = pfi_lookup_create(name);
	if (p != NULL)
		p->pfik_rules++;
	return (p);
d229 1
a229 1
pfi_detach_rule(struct pfi_kif *p)
d231 4
a234 1
	if (p == NULL)
a235 6
	if (p->pfik_rules > 0)
		p->pfik_rules--;
	else
		printf("pfi_detach_rule: reference count at 0\n");
	pfi_maybe_destroy(p);
}
d237 8
a244 5
void
pfi_attach_state(struct pfi_kif *p)
{
	if (!p->pfik_states++)
		TAILQ_INSERT_TAIL(&pfi_statehead, p, pfik_w_states);
d247 2
a248 2
void
pfi_detach_state(struct pfi_kif *p)
d250 29
a278 5
	if (p == NULL)
		return;
	if (p->pfik_states <= 0) {
		printf("pfi_detach_state: reference count <= 0\n");
		return;
a279 3
	if (!--p->pfik_states)
		TAILQ_REMOVE(&pfi_statehead, p, pfik_w_states);
	pfi_maybe_destroy(p);
d298 6
a303 3
	dyn->pfid_kif = pfi_attach_rule(aw->v.ifname);
	if (dyn->pfid_kif == NULL)
		senderr(1);
d321 4
a324 2
	if (ruleset == NULL)
		senderr(1);
d327 4
a330 2
	if (dyn->pfid_kt == NULL)
		senderr(1);
d337 4
a340 2
	if (dyn->pfid_hook_cookie == NULL)
		senderr(1);
d353 1
a353 1
		pfi_detach_rule(dyn->pfid_kif);
d371 1
d387 1
a387 1
	if ((kif->pfik_flags & PFI_IFLAG_INSTANCE) && kif->pfik_ifp == NULL) {
d392 3
a394 1
	if ((kif->pfik_flags & PFI_IFLAG_INSTANCE))
d396 1
a396 4
	else if (strcmp(kif->pfik_name, "self")) {
		TAILQ_FOREACH(p, &kif->pfik_grouphead, pfik_instances)
			pfi_instance_add(p->pfik_ifp, net, flags);
	} else {
d398 1
a398 1
			if (p->pfik_flags & PFI_IFLAG_INSTANCE)
d400 1
a400 1
	}
d526 1
a526 1
	pfi_detach_rule(aw->p.dyn->pfid_kif);
d550 1
a550 2
	pfi_update++;
	pfi_dohooks(v);
a559 92
struct pfi_kif *
pfi_if_create(const char *name, struct pfi_kif *q, int flags)
{
	struct pfi_kif *p;

	p = malloc(sizeof(*p), PFI_MTYPE, M_DONTWAIT);
	if (p == NULL)
		return (NULL);
	bzero(p, sizeof(*p));
	p->pfik_ah_head = malloc(sizeof(*p->pfik_ah_head), PFI_MTYPE,
	    M_DONTWAIT);
	if (p->pfik_ah_head == NULL) {
		free(p, PFI_MTYPE);
		return (NULL);
	}
	bzero(p->pfik_ah_head, sizeof(*p->pfik_ah_head));
	TAILQ_INIT(p->pfik_ah_head);
	TAILQ_INIT(&p->pfik_grouphead);
	strlcpy(p->pfik_name, name, sizeof(p->pfik_name));
	RB_INIT(&p->pfik_lan_ext);
	RB_INIT(&p->pfik_ext_gwy);
	p->pfik_flags = flags;
	p->pfik_parent = q;
	p->pfik_tzero = time_second;

	RB_INSERT(pfi_ifhead, &pfi_ifs, p);
	if (q != NULL) {
		q->pfik_addcnt++;
		TAILQ_INSERT_TAIL(&q->pfik_grouphead, p, pfik_instances);
	}
	pfi_ifcnt++;
	return (p);
}

int
pfi_maybe_destroy(struct pfi_kif *p)
{
	int		 i, j, k, s;
	struct pfi_kif	*q = p->pfik_parent;

	if ((p->pfik_flags & (PFI_IFLAG_ATTACHED | PFI_IFLAG_GROUP)) ||
	    p->pfik_rules > 0 || p->pfik_states > 0)
		return (0);

	s = splsoftnet();
	if (q != NULL) {
		for (i = 0; i < 2; i++)
			for (j = 0; j < 2; j++)
				for (k = 0; k < 2; k++) {
					q->pfik_bytes[i][j][k] +=
					    p->pfik_bytes[i][j][k];
					q->pfik_packets[i][j][k] +=
					    p->pfik_packets[i][j][k];
				}
		q->pfik_delcnt++;
		TAILQ_REMOVE(&q->pfik_grouphead, p, pfik_instances);
	}
	pfi_ifcnt--;
	RB_REMOVE(pfi_ifhead, &pfi_ifs, p);
	splx(s);

	free(p->pfik_ah_head, PFI_MTYPE);
	free(p, PFI_MTYPE);
	return (1);
}

void
pfi_copy_group(char *p, const char *q, int m)
{
	while (m > 1 && *q && !(*q >= '0' && *q <= '9')) {
		*p++ = *q++;
		m--;
	}
	if (m > 0)
		*p++ = '\0';
}

void
pfi_newgroup(const char *name, int flags)
{
	struct pfi_kif	*p;

	p = pfi_lookup_if(name);
	if (p == NULL)
		p = pfi_if_create(name, pfi_self, PFI_IFLAG_GROUP);
	if (p == NULL) {
		printf("pfi_newgroup: cannot allocate '%s' group", name);
		return;
	}
	p->pfik_flags |= flags;
}

d587 1
a587 1
pfi_clr_istats(const char *name, int *nzero, int flags)
d590 1
a590 2
	int		 n = 0, s;
	long		 tzero = time_second;
a591 1
	ACCEPT_FLAGS(PFI_FLAG_GROUP|PFI_FLAG_INSTANCE);
d594 1
a594 1
		if (pfi_skip_if(name, p, flags))
d598 1
a598 2
		p->pfik_tzero = tzero;
		n++;
a600 4
	if (nzero != NULL)
		*nzero = n;
	return (0);
}
a601 35
int
pfi_set_flags(const char *name, int flags)
{
	struct pfi_kif	*p;
	int		 s;

	if (flags & ~PFI_IFLAG_SETABLE_MASK)
		return (EINVAL);

	s = splsoftnet();
	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
		if (pfi_skip_if(name, p, PFI_FLAG_GROUP|PFI_FLAG_INSTANCE))
			continue;
		p->pfik_flags |= flags;
	}
	splx(s);
	return (0);
}

int
pfi_clear_flags(const char *name, int flags)
{
	struct pfi_kif	*p;
	int		 s;

	if (flags & ~PFI_IFLAG_SETABLE_MASK)
		return (EINVAL);

	s = splsoftnet();
	RB_FOREACH(p, pfi_ifhead, &pfi_ifs) {
		if (pfi_skip_if(name, p, PFI_FLAG_GROUP|PFI_FLAG_INSTANCE))
			continue;
		p->pfik_flags &= ~flags;
	}
	splx(s);
d606 1
a606 1
pfi_get_ifaces(const char *name, struct pfi_if *buf, int *size, int flags)
a610 1
	ACCEPT_FLAGS(PFI_FLAG_GROUP|PFI_FLAG_INSTANCE);
d613 1
a613 1
		if (pfi_skip_if(name, p, flags))
a628 10
struct pfi_kif *
pfi_lookup_if(const char *name)
{
	struct pfi_kif	*p, key;

	strlcpy(key.pfik_name, name, sizeof(key.pfik_name));
	p = RB_FIND(pfi_ifhead, &pfi_ifs, &key);
	return (p);
}

d630 1
a630 1
pfi_skip_if(const char *filter, struct pfi_kif *p, int f)
a633 4
	if ((p->pfik_flags & PFI_IFLAG_GROUP) && !(f & PFI_FLAG_GROUP))
		return (1);
	if ((p->pfik_flags & PFI_IFLAG_INSTANCE) && !(f & PFI_FLAG_INSTANCE))
		return (1);
d648 32
a699 41
void
pfi_dohooks(struct pfi_kif *p)
{
	for (; p != NULL; p = p->pfik_parent)
		dohooks(p->pfik_ah_head, 0);
}

int
pfi_match_addr(struct pfi_dynaddr *dyn, struct pf_addr *a, sa_family_t af)
{
	switch (af) {
#ifdef INET
	case AF_INET:
		switch (dyn->pfid_acnt4) {
		case 0:
			return (0);
		case 1:
			return (PF_MATCHA(0, &dyn->pfid_addr4,
			    &dyn->pfid_mask4, a, AF_INET));
		default:
			return (pfr_match_addr(dyn->pfid_kt, a, AF_INET));
		}
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		switch (dyn->pfid_acnt6) {
		case 0:
			return (0);
		case 1:
			return (PF_MATCHA(0, &dyn->pfid_addr6,
			    &dyn->pfid_mask6, a, AF_INET6));
		default:
			return (pfr_match_addr(dyn->pfid_kt, a, AF_INET6));
		}
		break;
#endif /* INET6 */
	default:
		return (0);
	}
}
@


1.23
log
@Introduce 'set skip on <ifspec>' to support a list of interfaces where no
packet filtering should occur (like loopback, for instance).
Code from Max Laier, with minor improvements based on feedback from
deraadt@@. ok mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.22 2004/12/13 23:51:22 dhartmei Exp $ */
d182 3
@


1.22
log
@move splsoftnet() below ACCEPT_FLAGS(), which contains a potential return.
from Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.21 2004/12/06 10:38:19 mpf Exp $ */
d688 38
@


1.21
log
@Check a NULL dereference before it could happen.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.20 2004/08/15 15:31:46 henning Exp $ */
d675 1
a676 1
	ACCEPT_FLAGS(PFI_FLAG_GROUP|PFI_FLAG_INSTANCE);
@


1.20
log
@undo last commit, skipping over ifaddrs without IFA_ROUTE has unwanted
sideffects in IPv6 land, noticed by Johan Fredin <griffin@@legonet.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.18 2004/08/10 11:10:01 dlg Exp $ */
d352 2
a353 2
	struct pfi_kif		*kif = dyn->pfid_kif;
	struct pfr_ktable	*kt = dyn->pfid_kt;
d355 1
a355 1
	if (dyn == NULL || kif == NULL || kt == NULL)
d357 3
@


1.19
log
@skip over interface addresses without IFA_ROUTE, fixes some issue with pppd
from Max Laier <max@@love2party.net>
@
text
@a44 1
#include <net/route.h>
a408 2
			continue;
		if (!(ia->ifa_flags & IFA_ROUTE))
@


1.18
log
@when inserting a dynamic group entry into the pfi_ifs tree, don't incorrectly
create an interface entry with the same name.  Prevents panics due to
subsequent invalid refcounting.

from Chris Pascoe

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.17 2004/07/11 15:22:22 mcbride Exp $ */
d45 1
d410 2
@


1.17
log
@Create the group when adding a dynamic interface that's not yet plugged in.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.16 2004/07/04 22:56:52 henning Exp $ */
d228 2
a229 2
		q = pfi_lookup_if(key.pfik_name);
		if (q != NULL)
@


1.16
log
@remove the half-baked and bogus pfi_dynamic_drivers() which tries to guess
which drivers are hotpluggable. since we removed the stupid check from pfctl
a few days ago nothing relies on this any more.
ok pb@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.15 2004/06/25 00:54:27 tholo Exp $ */
d223 5
@


1.15
log
@Minor fixes suggested by nordin@@ and henning@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.14 2004/06/21 23:50:36 tholo Exp $ */
a87 1
void		 pfi_dynamic_drivers(void);
a95 1
#define PFI_DYNAMIC_BUSES	{ "pcmcia", "cardbus", "uhub" }
a111 1
	pfi_dynamic_drivers();
a616 40
}

void
pfi_dynamic_drivers(void)
{
	char		*buses[] = PFI_DYNAMIC_BUSES;
	int		 nbuses = sizeof(buses)/sizeof(buses[0]);
	int		 enabled[sizeof(buses)/sizeof(buses[0])];
	struct device	*dev;
	struct cfdata	*cf;
	struct cfdriver	*drv;
	short		*p;
	int		 i;

	bzero(enabled, sizeof(enabled));
	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (!(dev->dv_flags & DVF_ACTIVE))
			continue;
		for (i = 0; i < nbuses; i++)
			if (!enabled[i] && !strcmp(buses[i],
			    dev->dv_cfdata->cf_driver->cd_name))
				enabled[i] = 1;
	}
	for (cf = cfdata; cf->cf_driver; cf++) {
		if (cf->cf_driver->cd_class != DV_IFNET)
			continue;
		for (p = cf->cf_parents; p && *p >= 0; p++) {
			if ((drv = cfdata[*p].cf_driver) == NULL)
				continue;
			for (i = 0; i < nbuses; i++)
				if (enabled[i] &&
				    !strcmp(drv->cd_name, buses[i]))
					break;
			if (i < nbuses) {
				pfi_newgroup(cf->cf_driver->cd_name,
				    PFI_IFLAG_DYNAMIC);
				break;
			}
		}
	}
@


1.14
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.13 2004/05/19 17:50:52 dhartmei Exp $ */
d739 1
a739 1
				p->pfik_tzero = boottime.tv_sec;
@


1.13
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.12 2004/04/28 02:43:09 pb Exp $ */
d568 1
a568 1
	p->pfik_tzero = time.tv_sec;
d708 1
a708 1
	long		 tzero = time.tv_sec;
@


1.12
log
@Dont step into INET6 code, just because af != AF_INET
Also comment #endif properly while being here

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.11 2004/03/15 11:38:23 cedric Exp $ */
a77 4
char			  pfi_reserved_anchor[PF_ANCHOR_NAME_SIZE] =
				PF_RESERVED_ANCHOR;
char			  pfi_interface_ruleset[PF_RULESET_NAME_SIZE] =
				PF_INTERFACE_RULESET;
d313 1
a313 2
	ruleset = pf_find_or_create_ruleset(pfi_reserved_anchor,
	    pfi_interface_ruleset);
@


1.11
log
@Kill redundant(IPv4) and bogus(IPv6) tests. found+ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.10 2004/03/09 21:44:41 mcbride Exp $ */
d433 1
a433 1
		else
d440 1
a440 1
			} else {
d819 3
a821 1
	if (af == AF_INET) {
d831 4
a834 1
	} else {
d844 4
@


1.10
log
@KNF, ok cedric@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.9 2004/02/20 19:22:03 mcbride Exp $ */
a823 2
			if (PF_AZERO(&dyn->pfid_mask4, AF_INET))
				return (1);
a833 2
			if (PF_AZERO(&dyn->pfid_mask6, AF_INET6));
				return (1);
@


1.9
log
@Make pfsync deal with clearing states bound to a group or interface (eg
pfctl -i fxp0 -Fs). Also don't send out individual state deletions if we're
sending a clear message, move pfsync_clear_states() inside splnet, and fix
if_pfsync.h includes in  pf.c and pf_ioctl.c.

ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.8 2004/02/17 08:26:47 cedric Exp $ */
d547 1
a547 1
	return strncmp(p->pfik_name, q->pfik_name, IFNAMSIZ);
d829 1
a829 1
			return pfr_match_addr(dyn->pfid_kt, a, AF_INET);
d841 1
a841 1
			return pfr_match_addr(dyn->pfid_kt, a, AF_INET6);
@


1.8
log
@Tighten pfi_skip_if() up, and a bit of KNF. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.7 2004/02/10 18:49:10 henning Exp $ */
a93 1
struct pfi_kif	*pfi_lookup_if(const char *);
@


1.8.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d58 6
a63 6
#define ACCEPT_FLAGS(oklist)                    \
        do {                                    \
                if ((flags & ~(oklist)) &       \
                    PFI_FLAG_ALLMASK)           \
                        return (EINVAL);        \
        } while (0)
d78 1
a78 1
char 			  pfi_reserved_anchor[PF_ANCHOR_NAME_SIZE] =
d94 1
a94 1
struct pfi_kif 	*pfi_lookup_if(const char *);
d133 1
a133 1
	int 		 s;
d188 2
a189 2
	p->pfik_ah_cookie = hook_establish(ifp->if_addrhooks,
	    1, pfi_kifaddr_update, p);
d316 2
a317 3
		snprintf(tblname+strlen(tblname),
		    sizeof(tblname)-strlen(tblname),
		    "/%d", dyn->pfid_net);
d330 1
a330 2
	dyn->pfid_hook_cookie = hook_establish(
	    dyn->pfid_kif->pfik_ah_head, 1,
d362 1
a362 1
		/* this table need to be brought up-to-date */
d467 2
a468 2
			printf("pfi_address_add: address buffer full "
			    "(%d/%d)\n", pfi_buffer_cnt, PFI_BUFFER_MAX);
d475 1
a475 1
			    " (%d/%d)\n", pfi_buffer_cnt, PFI_BUFFER_MAX);
d498 4
a501 4
        if (net < 128)
                ((caddr_t)p)[p->pfra_net/8] &= ~(0xFF >> (p->pfra_net%8));
        for (i = (p->pfra_net+7)/8; i < sizeof(p->pfra_u); i++)
                ((caddr_t)p)[i] = 0;
d649 2
a650 2
        for (cf = cfdata; cf->cf_driver; cf++) {
                if (cf->cf_driver->cd_class != DV_IFNET)
d770 2
d778 10
a787 1
	return !strncmp(p->pfik_name, filter, strlen(filter));
d806 2
a807 2
        }
        return (b);
d834 1
a834 1
		case (0):
@


1.8.2.2
log
@Merge with the trunk
@
text
@d58 6
a63 6
#define ACCEPT_FLAGS(oklist)			\
	do {					\
		if ((flags & ~(oklist)) &	\
		    PFI_FLAG_ALLMASK)		\
			return (EINVAL);	\
	} while (0)
d78 4
d94 1
d133 1
a133 1
	int		 s;
d188 2
a189 2
	p->pfik_ah_cookie =
	    hook_establish(ifp->if_addrhooks, 1, pfi_kifaddr_update, p);
d316 5
a320 3
		snprintf(tblname + strlen(tblname),
		    sizeof(tblname) - strlen(tblname), "/%d", dyn->pfid_net);
	ruleset = pf_find_or_create_ruleset(PF_RESERVED_ANCHOR);
d331 2
a332 1
	dyn->pfid_hook_cookie = hook_establish(dyn->pfid_kif->pfik_ah_head, 1,
d364 1
a364 1
		/* this table needs to be brought up-to-date */
d436 1
a436 1
		else if (af == AF_INET6)
d443 1
a443 1
			} else if (af == AF_INET6) {
d469 2
a470 2
			printf("pfi_address_add: address buffer full (%d/%d)\n",
			    pfi_buffer_cnt, PFI_BUFFER_MAX);
d477 1
a477 1
			    "(%d/%d)\n", pfi_buffer_cnt, PFI_BUFFER_MAX);
d500 4
a503 4
	if (net < 128)
		((caddr_t)p)[p->pfra_net/8] &= ~(0xFF >> (p->pfra_net%8));
	for (i = (p->pfra_net+7)/8; i < sizeof(p->pfra_u); i++)
		((caddr_t)p)[i] = 0;
d550 1
a550 1
	return (strncmp(p->pfik_name, q->pfik_name, IFNAMSIZ));
d651 2
a652 2
	for (cf = cfdata; cf->cf_driver; cf++) {
		if (cf->cf_driver->cd_class != DV_IFNET)
a771 2
	int	n;

d778 1
a778 10
	if (!strcmp(p->pfik_name, filter))
		return (0);	/* exact match */
	n = strlen(filter);
	if (n < 1 || n >= IFNAMSIZ)
		return (1);	/* sanity check */
	if (filter[n-1] >= '0' && filter[n-1] <= '9')
		return (1);	/* only do exact match in that case */
	if (strncmp(p->pfik_name, filter, n))
		return (1);	/* prefix doesn't match */
	return (p->pfik_name[n] < '0' || p->pfik_name[n] > '9');
d797 2
a798 2
	}
	return (b);
d811 1
a811 3
	switch (af) {
#ifdef INET
	case AF_INET:
d816 2
d821 1
a821 1
			return (pfr_match_addr(dyn->pfid_kt, a, AF_INET));
d823 1
a823 4
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
d825 1
a825 1
		case 0:
d828 2
d833 1
a833 1
			return (pfr_match_addr(dyn->pfid_kt, a, AF_INET6));
a834 4
		break;
#endif /* INET6 */
	default:
		return (0);
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.6 2004/02/09 13:27:50 cedric Exp $ */
d770 2
d778 10
a787 1
	return strncmp(p->pfik_name, filter, strlen(filter));
d834 1
a834 1
		case (0):
@


1.6
log
@Repair "set loginterface". Don't flush stats on pfctl -e. pf_status.since
is the time of last "pf -e" or "pf -d". ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.5 2004/01/07 19:58:54 markus Exp $ */
d58 6
a63 6
#define ACCEPT_FLAGS(oklist)                    \
        do {                                    \
                if ((flags & ~(oklist)) &       \
                    PFI_FLAG_ALLMASK)           \
                        return (EINVAL);        \
        } while (0)
d78 1
a78 1
char 			  pfi_reserved_anchor[PF_ANCHOR_NAME_SIZE] =
d94 1
a94 1
struct pfi_kif 	*pfi_lookup_if(const char *);
d133 1
a133 1
	int 		 s;
d188 2
a189 2
	p->pfik_ah_cookie = hook_establish(ifp->if_addrhooks,
	    1, pfi_kifaddr_update, p);
d316 2
a317 3
		snprintf(tblname+strlen(tblname),
		    sizeof(tblname)-strlen(tblname),
		    "/%d", dyn->pfid_net);
d330 1
a330 2
	dyn->pfid_hook_cookie = hook_establish(
	    dyn->pfid_kif->pfik_ah_head, 1,
d362 1
a362 1
		/* this table need to be brought up-to-date */
d467 2
a468 2
			printf("pfi_address_add: address buffer full "
			    "(%d/%d)\n", pfi_buffer_cnt, PFI_BUFFER_MAX);
d475 1
a475 1
			    " (%d/%d)\n", pfi_buffer_cnt, PFI_BUFFER_MAX);
d498 4
a501 4
        if (net < 128)
                ((caddr_t)p)[p->pfra_net/8] &= ~(0xFF >> (p->pfra_net%8));
        for (i = (p->pfra_net+7)/8; i < sizeof(p->pfra_u); i++)
                ((caddr_t)p)[i] = 0;
d649 2
a650 2
        for (cf = cfdata; cf->cf_driver; cf++) {
                if (cf->cf_driver->cd_class != DV_IFNET)
d795 2
a796 2
        }
        return (b);
@


1.5
log
@PFI_MTYPE leak; ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.4 2003/12/31 22:14:42 deraadt Exp $ */
d778 1
a778 1
	return !strncmp(p->pfik_name, filter, strlen(filter));
@


1.4
log
@spacing.  note this, cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.3 2003/12/31 15:32:43 markus Exp $ */
d614 1
@


1.3
log
@delay interfaces attach until "self" has been created; ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.2 2003/12/31 11:18:25 cedric Exp $ */
d139 1
a139 1
		/* 
d407 1
a407 1
	
d716 1
a716 1
	
d762 1
a762 1
	
@


1.2
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_if.c,v 1.1 2003/12/12 20:05:45 cedric Exp $ */
a114 1
	pfi_dynamic_drivers();
d119 1
@


1.1
log
@Move PF interface code to new net/pf_if.c
Expect improvements in this area soon.
ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf.c,v 1.406 2003/12/11 13:13:27 cedric Exp $ */
d5 1
a30 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d40 1
a41 1
#include <sys/pool.h>
d58 191
a248 1
#define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x
d250 11
a260 3
/*
 * Global variables
 */
d262 20
a281 1
void	pfi_dynaddr_update(void *);
d286 5
d293 2
a294 2
	aw->p.dyn = pool_get(&pf_addr_pl, PR_NOWAIT);
	if (aw->p.dyn == NULL)
d296 42
a337 18
	bcopy(aw->v.ifname, aw->p.dyn->ifname, sizeof(aw->p.dyn->ifname));
	aw->p.dyn->ifp = ifunit(aw->p.dyn->ifname);
	if (aw->p.dyn->ifp == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
		return (1);
	}
	aw->p.dyn->addr = &aw->v.a.addr;
	aw->p.dyn->af = af;
	aw->p.dyn->undefined = 1;
	aw->p.dyn->hook_cookie = hook_establish(
	    aw->p.dyn->ifp->if_addrhooks, 1,
	    pfi_dynaddr_update, aw->p.dyn);
	if (aw->p.dyn->hook_cookie == NULL) {
		pool_put(&pf_addr_pl, aw->p.dyn);
		aw->p.dyn = NULL;
		return (1);
	}
d339 1
d341 11
d357 3
a359 3
	struct pf_addr_dyn	*ad = (struct pf_addr_dyn *)p;
	struct ifaddr		*ia;
	int			 s, changed = 0;
d361 1
a361 1
	if (ad == NULL || ad->ifp == NULL)
d363 37
a399 17
	s = splsoftnet();
	TAILQ_FOREACH(ia, &ad->ifp->if_addrlist, ifa_list)
		if (ia->ifa_addr != NULL &&
		    ia->ifa_addr->sa_family == ad->af) {
			if (ad->af == AF_INET) {
				struct in_addr *a, *b;

				a = &ad->addr->v4;
				b = &((struct sockaddr_in *)ia->ifa_addr)
				    ->sin_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
			} else if (ad->af == AF_INET6) {
				struct in6_addr *a, *b;
d401 45
a445 8
				a = &ad->addr->v6;
				b = &((struct sockaddr_in6 *)ia->ifa_addr)
				    ->sin6_addr;
				if (ad->undefined ||
				    memcmp(a, b, sizeof(*a))) {
					bcopy(b, a, sizeof(*a));
					changed = 1;
				}
a446 3
			if (changed)
				ad->undefined = 0;
			break;
d448 56
a503 3
	if (ia == NULL)
		ad->undefined = 1;
	splx(s);
d509 4
a512 1
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
d514 9
a522 3
	hook_disestablish(aw->p.dyn->ifp->if_addrhooks,
	    aw->p.dyn->hook_cookie);
	pool_put(&pf_addr_pl, aw->p.dyn);
d524 1
d530 149
a678 1
	if (aw->type != PF_ADDR_DYNIFTL || aw->p.dyn == NULL)
d680 155
a834 2
	bcopy(aw->p.dyn->ifname, aw->v.ifname, sizeof(aw->v.ifname));
	aw->p.dyn = (struct pf_addr_dyn *)1;
@

