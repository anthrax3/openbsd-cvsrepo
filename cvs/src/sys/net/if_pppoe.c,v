head	1.62;
access;
symbols
	OPENBSD_6_1:1.60.0.4
	OPENBSD_6_1_BASE:1.60
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.37.0.6
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.35.0.4
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.62
date	2017.05.27.18.36.20;	author mpi;	state Exp;
branches;
next	1.61;
commitid	2bS6ySDpaPOSkyoW;

1.61
date	2017.05.16.12.24.01;	author mpi;	state Exp;
branches;
next	1.60;
commitid	SAe3SQ48vKH6r5FL;

1.60
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.59;
commitid	VyLWTsbepAOk7VQM;

1.59
date	2017.01.02.08.44.13;	author mpi;	state Exp;
branches;
next	1.58;
commitid	Ksb6PazDWJwdKoxF;

1.58
date	2017.01.02.08.42.52;	author mpi;	state Exp;
branches;
next	1.57;
commitid	k8E8tLM5IqNZwlji;

1.57
date	2016.06.14.20.44.43;	author sthen;	state Exp;
branches;
next	1.56;
commitid	tndIBFePD1o7FA2I;

1.56
date	2016.05.30.23.30.11;	author sthen;	state Exp;
branches;
next	1.55;
commitid	dVgy2mYGXH78Mymf;

1.55
date	2016.04.18.14.38.08;	author mikeb;	state Exp;
branches;
next	1.54;
commitid	Ulkx0vStDvav3xQS;

1.54
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.53;
commitid	Xo6g1xk26RWDGcjJ;

1.53
date	2016.04.01.04.03.35;	author jsg;	state Exp;
branches;
next	1.52;
commitid	mLDEumOGraMzIlUg;

1.52
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.51;
commitid	ILbVM1M3uPNjwswz;

1.51
date	2015.11.28.19.10.26;	author reyk;	state Exp;
branches;
next	1.50;
commitid	QjldOtS72XyXkzo2;

1.50
date	2015.11.20.12.05.34;	author sthen;	state Exp;
branches;
next	1.49;
commitid	L3ElIBq5lmdDeXQ6;

1.49
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.48;
commitid	G2nTzngqgXpQqcJB;

1.48
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.47;
commitid	zZXiESHR0g5lNO0l;

1.47
date	2015.09.12.20.26.06;	author mpi;	state Exp;
branches;
next	1.46;
commitid	UM7jfgLT8vWQUBm1;

1.46
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.45;
commitid	h7z8lokZ0dFyuWpg;

1.45
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.44;
commitid	c7ei8kPelCOOwHXy;

1.44
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.43;
commitid	p4LJxGKbi0BU2cG6;

1.43
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.42;
commitid	t9FBKDfc4VDxpEy2;

1.42
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.41;
commitid	Z1vcFtHO8wRH0yRt;

1.41
date	2014.08.13.12.03.40;	author mpi;	state Exp;
branches;
next	1.40;
commitid	UZ9xTy39ZzyHtOyg;

1.40
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.39;
commitid	B4dZSbxas1X1IpXI;

1.39
date	2014.06.07.11.04.14;	author henning;	state Exp;
branches;
next	1.38;
commitid	3AS3WOjnaTtfOf9y;

1.38
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.37;

1.37
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2012.04.11.17.42.53;	author mikeb;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.19.01.13.20;	author sthen;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.05.20.00.14;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.13.16.23.28;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.16.12.20.27;	author canacar;	state Exp;
branches;
next	1.28;

1.28
date	2008.10.11.20.34.10;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.01.16.51.48;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.28.13.19.38;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.28.13.10.54;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.27.08.41.46;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.09.11.25.05;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.24.11.36.38;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.20.16.46.34;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.18.21.33.45;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.18.21.23.47;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.14.02.56.26;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.12.17.27.03;	author canacar;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.20.09.37.52;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.28.06.31.01;	author mcbride;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.28.23.38.23;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.28.20.06.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.11.21.21.59;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.08.20.31.25;	author canacar;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.07.05.10.57;	author canacar;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.01.00.30.31;	author canacar;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.29.20.15.40;	author pat;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.28.23.39.45;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Protect the global list of softc with the NET_LOCK().

While here remove superfluous splnet()/splx() in the ioctl routine.

ok sashan@@
@
text
@/* $OpenBSD: if_pppoe.c,v 1.61 2017/05/16 12:24:01 mpi Exp $ */
/* $NetBSD: if_pppoe.c,v 1.51 2003/11/28 08:56:48 keihan Exp $ */

/*
 * Copyright (c) 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Martin Husemann <martin@@NetBSD.org>.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "pppoe.h"
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/types.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/if_sppp.h>
#include <net/if_pppoe.h>
#include <net/netisr.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#undef PPPOE_DEBUG	/* XXX - remove this or make it an option */

#define PPPOEDEBUG(a)	((sc->sc_sppp.pp_if.if_flags & IFF_DEBUG) ? printf a : 0)

struct pppoehdr {
	u_int8_t vertype;
	u_int8_t code;
	u_int16_t session;
	u_int16_t plen;
} __packed;

struct pppoetag {
	u_int16_t tag;
	u_int16_t len;
} __packed;

#define	PPPOE_HEADERLEN		sizeof(struct pppoehdr)
#define	PPPOE_OVERHEAD		(PPPOE_HEADERLEN + 2)
#define	PPPOE_VERTYPE		0x11		/* VER=1, TYPE = 1 */

#define	PPPOE_TAG_EOL		0x0000		/* end of list */
#define	PPPOE_TAG_SNAME		0x0101		/* service name */
#define	PPPOE_TAG_ACNAME	0x0102		/* access concentrator name */
#define	PPPOE_TAG_HUNIQUE	0x0103		/* host unique */
#define	PPPOE_TAG_ACCOOKIE	0x0104		/* AC cookie */
#define	PPPOE_TAG_VENDOR	0x0105		/* vendor specific */
#define	PPPOE_TAG_RELAYSID	0x0110		/* relay session id */
#define	PPPOE_TAG_MAX_PAYLOAD	0x0120		/* RFC 4638 max payload */
#define	PPPOE_TAG_SNAME_ERR	0x0201		/* service name error */
#define	PPPOE_TAG_ACSYS_ERR	0x0202		/* AC system error */
#define	PPPOE_TAG_GENERIC_ERR	0x0203		/* generic error */

#define	PPPOE_CODE_PADI		0x09		/* Active Discovery Initiation */
#define	PPPOE_CODE_PADO		0x07		/* Active Discovery Offer */
#define	PPPOE_CODE_PADR		0x19		/* Active Discovery Request */
#define	PPPOE_CODE_PADS		0x65		/* Active Discovery Session confirmation */
#define	PPPOE_CODE_PADT		0xA7		/* Active Discovery Terminate */

/* two byte PPP protocol discriminator, then IP data */
#define	PPPOE_MTU	(ETHERMTU - PPPOE_OVERHEAD)
#define	PPPOE_MAXMTU	PP_MAX_MRU

/* Add a 16 bit unsigned value to a buffer pointed to by PTR */
#define	PPPOE_ADD_16(PTR, VAL)			\
		*(PTR)++ = (VAL) / 256;		\
		*(PTR)++ = (VAL) % 256

/* Add a complete PPPoE header to the buffer pointed to by PTR */
#define	PPPOE_ADD_HEADER(PTR, CODE, SESS, LEN)	\
		*(PTR)++ = PPPOE_VERTYPE;	\
		*(PTR)++ = (CODE);		\
		PPPOE_ADD_16(PTR, SESS);	\
		PPPOE_ADD_16(PTR, LEN)

#define	PPPOE_DISC_TIMEOUT	(hz*5)	/* base for quick timeout calculation */
#define	PPPOE_SLOW_RETRY	(hz*60)	/* persistent retry interval */
#define	PPPOE_DISC_MAXPADI	4	/* retry PADI four times (quickly) */
#define	PPPOE_DISC_MAXPADR	2	/* retry PADR twice */

struct pppoe_softc {
	struct sppp sc_sppp;		/* contains a struct ifnet as first element */
	LIST_ENTRY(pppoe_softc) sc_list;
	unsigned int sc_eth_ifidx;

	int sc_state;			/* discovery phase or session connected */
	struct ether_addr sc_dest;	/* hardware address of concentrator */
	u_int16_t sc_session;		/* PPPoE session id */

	char *sc_service_name;		/* if != NULL: requested name of service */
	char *sc_concentrator_name;	/* if != NULL: requested concentrator id */
	u_int8_t *sc_ac_cookie;		/* content of AC cookie we must echo back */
	size_t sc_ac_cookie_len;	/* length of cookie data */
	u_int8_t *sc_relay_sid;		/* content of relay SID we must echo back */
	size_t sc_relay_sid_len;	/* length of relay SID data */
	u_int32_t sc_unique;		/* our unique id */
	struct timeout sc_timeout;	/* timeout while not in session state */
	int sc_padi_retried;		/* number of PADI retries already done */
	int sc_padr_retried;		/* number of PADR retries already done */

	struct timeval sc_session_time;	/* time the session was established */
};

/* incoming traffic will be queued here */
struct niqueue pppoediscinq = NIQUEUE_INITIALIZER(IFQ_MAXLEN, NETISR_PPPOE);
struct niqueue pppoeinq = NIQUEUE_INITIALIZER(IFQ_MAXLEN, NETISR_PPPOE);

/* input routines */
static void pppoe_disc_input(struct mbuf *);
static void pppoe_dispatch_disc_pkt(struct mbuf *, int);
static void pppoe_data_input(struct mbuf *);

/* management routines */
void pppoeattach(int);
static int  pppoe_connect(struct pppoe_softc *);
static int  pppoe_disconnect(struct pppoe_softc *);
static void pppoe_abort_connect(struct pppoe_softc *);
static int  pppoe_ioctl(struct ifnet *, unsigned long, caddr_t);
static void pppoe_tls(struct sppp *);
static void pppoe_tlf(struct sppp *);
static void pppoe_start(struct ifnet *);

/* internal timeout handling */
static void pppoe_timeout(void *);

/* sending actual protocol control packets */
static int pppoe_send_padi(struct pppoe_softc *);
static int pppoe_send_padr(struct pppoe_softc *);
static int pppoe_send_padt(unsigned int, u_int, const u_int8_t *, u_int8_t);

/* raw output */
static int pppoe_output(struct pppoe_softc *, struct mbuf *);

/* internal helper functions */
static struct pppoe_softc *pppoe_find_softc_by_session(u_int, u_int);
static struct pppoe_softc *pppoe_find_softc_by_hunique(u_int8_t *, size_t, u_int);
static struct mbuf	  *pppoe_get_mbuf(size_t len);

LIST_HEAD(pppoe_softc_head, pppoe_softc) pppoe_softc_list;

/* interface cloning */
int pppoe_clone_create(struct if_clone *, int);
int pppoe_clone_destroy(struct ifnet *);

struct if_clone pppoe_cloner =
    IF_CLONE_INITIALIZER("pppoe", pppoe_clone_create, pppoe_clone_destroy);


void
pppoeattach(int count)
{
	LIST_INIT(&pppoe_softc_list);
	if_clone_attach(&pppoe_cloner);
}

/* Create a new interface. */
int
pppoe_clone_create(struct if_clone *ifc, int unit)
{
	struct pppoe_softc *sc, *tmpsc;
	u_int32_t unique;
	int s;

        sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK|M_CANFAIL|M_ZERO);
        if (sc == NULL)
                return (ENOMEM);

	snprintf(sc->sc_sppp.pp_if.if_xname,
		 sizeof(sc->sc_sppp.pp_if.if_xname),
		 "pppoe%d", unit);
	sc->sc_sppp.pp_if.if_softc = sc;
	sc->sc_sppp.pp_if.if_mtu = PPPOE_MTU;
	sc->sc_sppp.pp_if.if_flags = IFF_SIMPLEX | IFF_POINTOPOINT | IFF_MULTICAST;
	sc->sc_sppp.pp_if.if_type = IFT_PPP;
	sc->sc_sppp.pp_if.if_hdrlen = sizeof(struct ether_header) + PPPOE_HEADERLEN;
	sc->sc_sppp.pp_flags |= PP_KEEPALIVE;		/* use LCP keepalive */
	sc->sc_sppp.pp_framebytes = PPPOE_HEADERLEN;	/* framing added to ppp packets */
	sc->sc_sppp.pp_if.if_ioctl = pppoe_ioctl;
	sc->sc_sppp.pp_if.if_start = pppoe_start;
	sc->sc_sppp.pp_if.if_rtrequest = p2p_rtrequest;
	sc->sc_sppp.pp_tls = pppoe_tls;
	sc->sc_sppp.pp_tlf = pppoe_tlf;
	IFQ_SET_MAXLEN(&sc->sc_sppp.pp_if.if_snd, IFQ_MAXLEN);

	/* changed to real address later */
	memcpy(&sc->sc_dest, etherbroadcastaddr, sizeof(sc->sc_dest));

	/* init timer for interface watchdog */
	timeout_set_proc(&sc->sc_timeout, pppoe_timeout, sc);

	if_attach(&sc->sc_sppp.pp_if);
	if_alloc_sadl(&sc->sc_sppp.pp_if);
	sppp_attach(&sc->sc_sppp.pp_if);
#if NBPFILTER > 0
	bpfattach(&sc->sc_sppp.pp_if.if_bpf, &sc->sc_sppp.pp_if, DLT_PPP_ETHER, 0);
#endif

	NET_LOCK(s);
retry:
	unique = arc4random();
	LIST_FOREACH(tmpsc, &pppoe_softc_list, sc_list)
		if (tmpsc->sc_unique == unique)
			goto retry;
	sc->sc_unique = unique;
	LIST_INSERT_HEAD(&pppoe_softc_list, sc, sc_list);
	NET_UNLOCK(s);

	return (0);
}

/* Destroy a given interface. */
int
pppoe_clone_destroy(struct ifnet *ifp)
{
	struct pppoe_softc *sc = ifp->if_softc;
	int s;

	NET_LOCK(s);
	LIST_REMOVE(sc, sc_list);
	NET_UNLOCK(s);

	timeout_del(&sc->sc_timeout);

	sppp_detach(&sc->sc_sppp.pp_if);
	if_detach(ifp);

	if (sc->sc_concentrator_name)
		free(sc->sc_concentrator_name, M_DEVBUF, 0);
	if (sc->sc_service_name)
		free(sc->sc_service_name, M_DEVBUF, 0);
	if (sc->sc_ac_cookie)
		free(sc->sc_ac_cookie, M_DEVBUF, 0);
	if (sc->sc_relay_sid)
		free(sc->sc_relay_sid, M_DEVBUF, 0);

	free(sc, M_DEVBUF, 0);

	return (0);
}

/*
 * Find the interface handling the specified session.
 * Note: O(number of sessions open), this is a client-side only, mean
 * and lean implementation, so number of open sessions typically should
 * be 1.
 */
static struct pppoe_softc *
pppoe_find_softc_by_session(u_int session, u_int ifidx)
{
	struct pppoe_softc *sc;

	if (session == 0)
		return (NULL);

	LIST_FOREACH(sc, &pppoe_softc_list, sc_list) {
		if (sc->sc_state == PPPOE_STATE_SESSION
		    && sc->sc_session == session
		    && sc->sc_eth_ifidx == ifidx) {
			return (sc);
		}
	}
	return (NULL);
}

/*
 * Check host unique token passed and return appropriate softc pointer,
 * or NULL if token is bogus.
 */
static struct pppoe_softc *
pppoe_find_softc_by_hunique(u_int8_t *token, size_t len, u_int ifidx)
{
	struct pppoe_softc *sc;
	u_int32_t hunique;

	if (LIST_EMPTY(&pppoe_softc_list))
		return (NULL);

	if (len != sizeof(hunique))
		return (NULL);
	memcpy(&hunique, token, len);

	LIST_FOREACH(sc, &pppoe_softc_list, sc_list)
		if (sc->sc_unique == hunique)
			break;

	if (sc == NULL) {
		printf("pppoe: alien host unique tag, no session found\n");
		return (NULL);
	}

	/* should be safe to access *sc now */
	if (sc->sc_state < PPPOE_STATE_PADI_SENT || sc->sc_state >= PPPOE_STATE_SESSION) {
		printf("%s: host unique tag found, but it belongs to a connection in state %d\n",
			sc->sc_sppp.pp_if.if_xname, sc->sc_state);
		return (NULL);
	}
	if (sc->sc_eth_ifidx != ifidx) {
		printf("%s: wrong interface, not accepting host unique\n",
			sc->sc_sppp.pp_if.if_xname);
		return (NULL);
	}
	return (sc);
}

/* Interface interrupt handler routine. */
void
pppoeintr(void)
{
	struct mbuf *m;

	NET_ASSERT_LOCKED();

	while ((m = niq_dequeue(&pppoediscinq)) != NULL)
		pppoe_disc_input(m);

	while ((m = niq_dequeue(&pppoeinq)) != NULL)
		pppoe_data_input(m);
}

/* Analyze and handle a single received packet while not in session state. */
static void pppoe_dispatch_disc_pkt(struct mbuf *m, int off)
{
	struct pppoe_softc *sc;
	struct pppoehdr *ph;
	struct pppoetag *pt;
	struct mbuf *n;
	struct ether_header *eh;
	const char *err_msg, *devname;
	size_t ac_cookie_len;
	size_t relay_sid_len;
	int noff, err, errortag;
	u_int16_t *max_payload;
	u_int16_t tag, len;
	u_int16_t session, plen;
	u_int8_t *ac_cookie;
	u_int8_t *relay_sid;
	u_int8_t code;

	err_msg = NULL;
	devname = "pppoe";
	errortag = 0;

	if (m->m_len < sizeof(*eh)) {
		m = m_pullup(m, sizeof(*eh));
		if (m == NULL)
			goto done;
	}
	eh = mtod(m, struct ether_header *);
	off += sizeof(*eh);

	ac_cookie = NULL;
	ac_cookie_len = 0;
	relay_sid = NULL;
	relay_sid_len = 0;
	max_payload = NULL;

	session = 0;
	if (m->m_pkthdr.len - off <= PPPOE_HEADERLEN) {
		printf("pppoe: packet too short: %d\n", m->m_pkthdr.len);
		goto done;
	}

	n = m_pulldown(m, off, sizeof(*ph), &noff);
	if (n == NULL) {
		printf("pppoe: could not get PPPoE header\n");
		m = NULL;
		goto done;
	}
	ph = (struct pppoehdr *)(mtod(n, caddr_t) + noff);
	if (ph->vertype != PPPOE_VERTYPE) {
		printf("pppoe: unknown version/type packet: 0x%x\n",
		    ph->vertype);
		goto done;
	}

	session = ntohs(ph->session);
	plen = ntohs(ph->plen);
	code = ph->code;
	off += sizeof(*ph);
	if (plen + off > m->m_pkthdr.len) {
		printf("pppoe: packet content does not fit: data available = %d, packet size = %u\n",
		    m->m_pkthdr.len - off, plen);
		goto done;
	}

	/* ignore trailing garbage */
	m_adj(m, off + plen - m->m_pkthdr.len);

	tag = 0;
	len = 0;
	sc = NULL;
	while (off + sizeof(*pt) <= m->m_pkthdr.len) {
		n = m_pulldown(m, off, sizeof(*pt), &noff);
		if (n == NULL) {
			printf("%s: parse error\n", devname);
			m = NULL;
			goto done;
		}
		pt = (struct pppoetag *)(mtod(n, caddr_t) + noff);
		tag = ntohs(pt->tag);
		len = ntohs(pt->len);
		off += sizeof(*pt);
		if (off + len > m->m_pkthdr.len) {
			printf("%s: tag 0x%x len 0x%x is too long\n",
			    devname, tag, len);
			goto done;
		}
		switch (tag) {
		case PPPOE_TAG_EOL:
			goto breakbreak;
		case PPPOE_TAG_SNAME:
			break;	/* ignored */
		case PPPOE_TAG_ACNAME:
			break;	/* ignored */
		case PPPOE_TAG_HUNIQUE:
			if (sc != NULL)
				break;
			n = m_pulldown(m, off, len, &noff);
			if (n == NULL) {
				m = NULL;
				err_msg = "TAG HUNIQUE ERROR";
				break;
			}
			sc = pppoe_find_softc_by_hunique(mtod(n, caddr_t) + noff,
			    len, m->m_pkthdr.ph_ifidx);
			if (sc != NULL)
				devname = sc->sc_sppp.pp_if.if_xname;
			break;
		case PPPOE_TAG_ACCOOKIE:
			if (ac_cookie == NULL) {
				n = m_pulldown(m, off, len,
				    &noff);
				if (n == NULL) {
					err_msg = "TAG ACCOOKIE ERROR";
					m = NULL;
					break;
				}
				ac_cookie = mtod(n, caddr_t) + noff;
				ac_cookie_len = len;
			}
			break;
		case PPPOE_TAG_RELAYSID:
			if (relay_sid == NULL) {
				n = m_pulldown(m, off, len,
				    &noff);
				if (n == NULL) {
					err_msg = "TAG RELAYSID ERROR";
					m = NULL;
					break;
				}
				relay_sid = mtod(n, caddr_t) + noff;
				relay_sid_len = len;
			}
			break;
		case PPPOE_TAG_MAX_PAYLOAD:
			if (max_payload == NULL) {
				n = m_pulldown(m, off, len,
				    &noff);
				if (n == NULL || len != 2) {
					err_msg = "TAG MAX_PAYLOAD ERROR";
					m = NULL;
					break;
				}
				max_payload = (u_int16_t *)(mtod(n, caddr_t) + noff);
			}
			break;
		case PPPOE_TAG_SNAME_ERR:
			err_msg = "SERVICE NAME ERROR";
			errortag = 1;
			break;
		case PPPOE_TAG_ACSYS_ERR:
			err_msg = "AC SYSTEM ERROR";
			errortag = 1;
			break;
		case PPPOE_TAG_GENERIC_ERR:
			err_msg = "GENERIC ERROR";
			errortag = 1;
			break;
		}
		if (err_msg) {
			log(LOG_INFO, "%s: %s: ", devname, err_msg);
			if (errortag && len) {
				n = m_pulldown(m, off, len,
				    &noff);
				if (n) {
					u_int8_t *et = mtod(n, caddr_t) + noff;
					while (len--)
						addlog("%c", *et++);
				}
			}
			addlog("\n");
			goto done;
		}
		off += len;
	}
breakbreak:
	switch (code) {
	case PPPOE_CODE_PADI:
	case PPPOE_CODE_PADR:
		/* ignore, we are no access concentrator */
		goto done;
	case PPPOE_CODE_PADO:
		if (sc == NULL) {
			/* be quiet if there is not a single pppoe instance */
			if (!LIST_EMPTY(&pppoe_softc_list))
				printf("pppoe: received PADO but could not find request for it\n");
			goto done;
		}
		if (sc->sc_state != PPPOE_STATE_PADI_SENT) {
			printf("%s: received unexpected PADO\n",
			    sc->sc_sppp.pp_if.if_xname);
			goto done;
		}
		if (ac_cookie) {
			if (sc->sc_ac_cookie)
				free(sc->sc_ac_cookie, M_DEVBUF, 0);
			sc->sc_ac_cookie = malloc(ac_cookie_len, M_DEVBUF,
			    M_DONTWAIT);
			if (sc->sc_ac_cookie == NULL)
				goto done;
			sc->sc_ac_cookie_len = ac_cookie_len;
			memcpy(sc->sc_ac_cookie, ac_cookie, ac_cookie_len);
		}
		if (relay_sid) {
			if (sc->sc_relay_sid)
				free(sc->sc_relay_sid, M_DEVBUF, 0);
			sc->sc_relay_sid = malloc(relay_sid_len, M_DEVBUF,
			    M_DONTWAIT);
			if (sc->sc_relay_sid == NULL)
				goto done;
			sc->sc_relay_sid_len = relay_sid_len;
			memcpy(sc->sc_relay_sid, relay_sid, relay_sid_len);
		}
		if (sc->sc_sppp.pp_if.if_mtu > PPPOE_MTU &&
		    (max_payload == NULL ||
		     ntohs(*max_payload) != sc->sc_sppp.pp_if.if_mtu)) {
			printf("%s: No valid PPP-Max-Payload tag received in PADO\n",
			    sc->sc_sppp.pp_if.if_xname);
			sc->sc_sppp.pp_if.if_mtu = PPPOE_MTU;
		}

		memcpy(&sc->sc_dest, eh->ether_shost, sizeof(sc->sc_dest));
		sc->sc_padr_retried = 0;
		sc->sc_state = PPPOE_STATE_PADR_SENT;
		if ((err = pppoe_send_padr(sc)) != 0) {
			PPPOEDEBUG(("%s: failed to send PADR, error=%d\n",
			    sc->sc_sppp.pp_if.if_xname, err));
		}
		timeout_add(&sc->sc_timeout,
		    PPPOE_DISC_TIMEOUT * (1 + sc->sc_padr_retried));

		break;
	case PPPOE_CODE_PADS:
		if (sc == NULL)
			goto done;

		sc->sc_session = session;
		timeout_del(&sc->sc_timeout);
		PPPOEDEBUG(("%s: session 0x%x connected\n",
		    sc->sc_sppp.pp_if.if_xname, session));
		sc->sc_state = PPPOE_STATE_SESSION;
		microtime(&sc->sc_session_time);
		sc->sc_sppp.pp_up(&sc->sc_sppp);	/* notify upper layers */

		break;
	case PPPOE_CODE_PADT:
		if (sc == NULL)
			goto done;

		/* stop timer (we might be about to transmit a PADT ourself) */
		timeout_del(&sc->sc_timeout);
		PPPOEDEBUG(("%s: session 0x%x terminated, received PADT\n",
		    sc->sc_sppp.pp_if.if_xname, session));

		/* clean up softc */
		sc->sc_state = PPPOE_STATE_INITIAL;
		memcpy(&sc->sc_dest, etherbroadcastaddr, sizeof(sc->sc_dest));
		if (sc->sc_ac_cookie) {
			free(sc->sc_ac_cookie, M_DEVBUF, 0);
			sc->sc_ac_cookie = NULL;
		}
		if (sc->sc_relay_sid) {
			free(sc->sc_relay_sid, M_DEVBUF, 0);
			sc->sc_relay_sid = NULL;
		}
		sc->sc_ac_cookie_len = 0;
		sc->sc_relay_sid_len = 0;
		sc->sc_session = 0;
		sc->sc_session_time.tv_sec = 0;
		sc->sc_session_time.tv_usec = 0;
		sc->sc_sppp.pp_down(&sc->sc_sppp);	/* signal upper layer */

		break;
	default:
		printf("%s: unknown code (0x%04x) session = 0x%04x\n",
		    sc ? sc->sc_sppp.pp_if.if_xname : "pppoe",
		    code, session);
		break;
	}

done:
	m_freem(m);
}

/* Input function for discovery packets. */
static void
pppoe_disc_input(struct mbuf *m)
{
	/* avoid error messages if there is not a single pppoe instance */
	if (!LIST_EMPTY(&pppoe_softc_list)) {
		KASSERT(m->m_flags & M_PKTHDR);
		pppoe_dispatch_disc_pkt(m, 0);
	} else
		m_freem(m);
}

/* Input function for data packets */
static void
pppoe_data_input(struct mbuf *m)
{
	struct pppoe_softc *sc;
	struct pppoehdr *ph;
	u_int16_t session, plen;
#ifdef PPPOE_TERM_UNKNOWN_SESSIONS
	u_int8_t shost[ETHER_ADDR_LEN];
#endif
	if (LIST_EMPTY(&pppoe_softc_list))
		goto drop;

	KASSERT(m->m_flags & M_PKTHDR);

#ifdef PPPOE_TERM_UNKNOWN_SESSIONS
	memcpy(shost, mtod(m, struct ether_header*)->ether_shost, ETHER_ADDR_LEN);
#endif
	m_adj(m, sizeof(struct ether_header));
	if (m->m_pkthdr.len <= PPPOE_HEADERLEN) {
		printf("pppoe (data): dropping too short packet: %d bytes\n",
		    m->m_pkthdr.len);
		goto drop;
	}
	if (m->m_len < sizeof(*ph)) {
		m = m_pullup(m, sizeof(*ph));
		if (m == NULL) {
			printf("pppoe (data): could not get PPPoE header\n");
			return;
		}
	}
	ph = mtod(m, struct pppoehdr *);
	if (ph->vertype != PPPOE_VERTYPE) {
		printf("pppoe (data): unknown version/type packet: 0x%x\n",
		    ph->vertype);
		goto drop;
	}
	if (ph->code != 0)
		goto drop;

	session = ntohs(ph->session);
	sc = pppoe_find_softc_by_session(session, m->m_pkthdr.ph_ifidx);
	if (sc == NULL) {
#ifdef PPPOE_TERM_UNKNOWN_SESSIONS
		printf("pppoe (data): input for unknown session 0x%x, sending PADT\n",
		    session);
		pppoe_send_padt(m->m_pkthdr.ph_ifidx, session, shost, 0);
#endif
		goto drop;
	}

	plen = ntohs(ph->plen);

#if NBPFILTER > 0
	if(sc->sc_sppp.pp_if.if_bpf)
		bpf_mtap(sc->sc_sppp.pp_if.if_bpf, m, BPF_DIRECTION_IN);
#endif

	m_adj(m, PPPOE_HEADERLEN);

#ifdef PPPOE_DEBUG
	{
		struct mbuf *p;

		printf("%s: pkthdr.len=%d, pppoe.len=%d",
			sc->sc_sppp.pp_if.if_xname,
			m->m_pkthdr.len, plen);
		p = m;
		while (p) {
			printf(" l=%d", p->m_len);
			p = p->m_next;
		}
		printf("\n");
	}
#endif

	if (m->m_pkthdr.len < plen)
		goto drop;

	/* fix incoming interface pointer (not the raw ethernet interface anymore) */
	m->m_pkthdr.ph_ifidx = sc->sc_sppp.pp_if.if_index;

	/* pass packet up and account for it */
	sc->sc_sppp.pp_if.if_ipackets++;
	sppp_input(&sc->sc_sppp.pp_if, m);
	return;

drop:
	m_freem(m);
}

static int
pppoe_output(struct pppoe_softc *sc, struct mbuf *m)
{
	struct sockaddr dst;
	struct ether_header *eh;
	struct ifnet *eth_if;
	u_int16_t etype;
	int ret;

	if ((eth_if = if_get(sc->sc_eth_ifidx)) == NULL) {
		m_freem(m);
		return (EIO);
	}

	if ((eth_if->if_flags & (IFF_UP|IFF_RUNNING))
	    != (IFF_UP|IFF_RUNNING)) {
		if_put(eth_if);
		m_freem(m);
		return (ENETDOWN);
	}

	memset(&dst, 0, sizeof dst);
	dst.sa_family = AF_UNSPEC;
	eh = (struct ether_header*)&dst.sa_data;
	etype = sc->sc_state == PPPOE_STATE_SESSION ? ETHERTYPE_PPPOE : ETHERTYPE_PPPOEDISC;
	eh->ether_type = htons(etype);
	memcpy(&eh->ether_dhost, &sc->sc_dest, sizeof sc->sc_dest);

	PPPOEDEBUG(("%s (%x) state=%d, session=0x%x output -> %s, len=%d\n",
	    sc->sc_sppp.pp_if.if_xname, etype,
	    sc->sc_state, sc->sc_session,
	    ether_sprintf((unsigned char *)&sc->sc_dest), m->m_pkthdr.len));

	m->m_flags &= ~(M_BCAST|M_MCAST);
	/* encapsulated packet is forced into rdomain of physical interface */
	m->m_pkthdr.ph_rtableid = eth_if->if_rdomain;

	ret = eth_if->if_output(eth_if, m, &dst, NULL);
	if_put(eth_if);

	return (ret);
}

/* The ioctl routine. */
static int
pppoe_ioctl(struct ifnet *ifp, unsigned long cmd, caddr_t data)
{
	struct proc *p = curproc;	/* XXX */
	struct pppoe_softc *sc = (struct pppoe_softc *)ifp;
	struct ifnet *eth_if;
	int error = 0;

	switch (cmd) {
	case PPPOESETPARMS:
	{
		struct pppoediscparms *parms = (struct pppoediscparms *)data;
		int len;

		if ((error = suser(p, 0)) != 0)
			return (error);
		if (parms->eth_ifname[0] != '\0') {
			struct ifnet	*eth_if;

			eth_if = ifunit(parms->eth_ifname);
			if (eth_if == NULL || eth_if->if_type != IFT_ETHER) {
				sc->sc_eth_ifidx = 0;
				return (ENXIO);
			}

			if (sc->sc_sppp.pp_if.if_mtu >
			    eth_if->if_mtu - PPPOE_OVERHEAD) {
				sc->sc_sppp.pp_if.if_mtu = eth_if->if_mtu -
				    PPPOE_OVERHEAD;
			}
			sc->sc_eth_ifidx = eth_if->if_index;
		}

		if (sc->sc_concentrator_name)
			free(sc->sc_concentrator_name, M_DEVBUF, 0);
		sc->sc_concentrator_name = NULL;

		len = strlen(parms->ac_name);
		if (len > 0 && len < sizeof(parms->ac_name)) {
			char *p = malloc(len + 1, M_DEVBUF, M_WAITOK|M_CANFAIL);
			if (p == NULL)
				return (ENOMEM);
			strlcpy(p, parms->ac_name, len + 1);
			sc->sc_concentrator_name = p;
		}

		if (sc->sc_service_name)
			free(sc->sc_service_name, M_DEVBUF, 0);
		sc->sc_service_name = NULL;

		len = strlen(parms->service_name);
		if (len > 0 && len < sizeof(parms->service_name)) {
			char *p = malloc(len + 1, M_DEVBUF, M_WAITOK|M_CANFAIL);
			if (p == NULL)
				return (ENOMEM);
			strlcpy(p, parms->service_name, len + 1);
			sc->sc_service_name = p;
		}
		return (0);
	}
	break;
	case PPPOEGETPARMS:
	{
		struct pppoediscparms *parms = (struct pppoediscparms *)data;

		if ((eth_if = if_get(sc->sc_eth_ifidx)) != NULL) {
			strlcpy(parms->eth_ifname, eth_if->if_xname,
			    IFNAMSIZ);
			if_put(eth_if);
		} else
			parms->eth_ifname[0] = '\0';

		if (sc->sc_concentrator_name)
			strlcpy(parms->ac_name, sc->sc_concentrator_name,
			    sizeof(parms->ac_name));
		else
			parms->ac_name[0] = '\0';

		if (sc->sc_service_name)
			strlcpy(parms->service_name, sc->sc_service_name,
			    sizeof(parms->service_name));
		else
			parms->service_name[0] = '\0';

		return (0);
	}
	break;
	case PPPOEGETSESSION:
	{
		struct pppoeconnectionstate *state =
		    (struct pppoeconnectionstate *)data;
		state->state = sc->sc_state;
		state->session_id = sc->sc_session;
		state->padi_retry_no = sc->sc_padi_retried;
		state->padr_retry_no = sc->sc_padr_retried;
		state->session_time.tv_sec = sc->sc_session_time.tv_sec;
		state->session_time.tv_usec = sc->sc_session_time.tv_usec;
		return (0);
	}
	break;
	case SIOCSIFFLAGS:
	{
		struct ifreq *ifr = (struct ifreq *)data;
		/*
		 * Prevent running re-establishment timers overriding
		 * administrators choice.
		 */
		if ((ifr->ifr_flags & IFF_UP) == 0
		     && sc->sc_state >= PPPOE_STATE_PADI_SENT
		     && sc->sc_state < PPPOE_STATE_SESSION) {
			timeout_del(&sc->sc_timeout);
			sc->sc_state = PPPOE_STATE_INITIAL;
			sc->sc_padi_retried = 0;
			sc->sc_padr_retried = 0;
			memcpy(&sc->sc_dest, etherbroadcastaddr,
			    sizeof(sc->sc_dest));
		}
		return (sppp_ioctl(ifp, cmd, data));
	}
	case SIOCSIFMTU:
	{
		struct ifreq *ifr = (struct ifreq *)data;

		eth_if = if_get(sc->sc_eth_ifidx);

		if (ifr->ifr_mtu > MIN(PPPOE_MAXMTU,
		    (eth_if == NULL ? PPPOE_MAXMTU :
		    (eth_if->if_mtu - PPPOE_OVERHEAD))))
			error = EINVAL;
		else
			error = 0;

		if_put(eth_if);

		return (sppp_ioctl(ifp, cmd, data));
	}
	default:
		error = sppp_ioctl(ifp, cmd, data);
		if (error == ENETRESET) {
			error = 0;
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING)) {
				if_down(ifp);
				if (sc->sc_state >= PPPOE_STATE_PADI_SENT &&
				    sc->sc_state < PPPOE_STATE_SESSION) {
					timeout_del(&sc->sc_timeout);
					sc->sc_state = PPPOE_STATE_INITIAL;
					sc->sc_padi_retried = 0;
					sc->sc_padr_retried = 0;
					memcpy(&sc->sc_dest,
					    etherbroadcastaddr,
					    sizeof(sc->sc_dest));
				}
				error = sppp_ioctl(ifp, SIOCSIFFLAGS, NULL);
				if (error)
					return (error);
				if_up(ifp);
				return (sppp_ioctl(ifp, SIOCSIFFLAGS, NULL));
			}
		}
		return (error);
	}
	return (0);
}

/*
 * Allocate a mbuf/cluster with space to store the given data length
 * of payload, leaving space for prepending an ethernet header
 * in front.
 */
static struct mbuf *
pppoe_get_mbuf(size_t len)
{
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	if (len + sizeof(struct ether_header) > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			return (NULL);
		}
	}
	m->m_data += sizeof(struct ether_header);
	m->m_len = len;
	m->m_pkthdr.len = len;
	m->m_pkthdr.ph_ifidx = 0;

	return (m);
}

/* Send PADI. */
static int
pppoe_send_padi(struct pppoe_softc *sc)
{
	struct mbuf *m0;
	int len, l1 = 0, l2 = 0; /* XXX: gcc */
	u_int8_t *p;

	if (sc->sc_state > PPPOE_STATE_PADI_SENT)
		panic("pppoe_send_padi in state %d", sc->sc_state);

	/* calculate length of frame (excluding ethernet header + pppoe header) */
	len = 2 + 2 + 2 + 2 + sizeof(sc->sc_unique); /* service name tag is required, host unique is sent too */
	if (sc->sc_service_name != NULL) {
		l1 = strlen(sc->sc_service_name);
		len += l1;
	}
	if (sc->sc_concentrator_name != NULL) {
		l2 = strlen(sc->sc_concentrator_name);
		len += 2 + 2 + l2;
	}
	if (sc->sc_sppp.pp_if.if_mtu > PPPOE_MTU)
		len += 2 + 2 + 2;

	/* allocate a buffer */
	m0 = pppoe_get_mbuf(len + PPPOE_HEADERLEN);	/* header len + payload len */
	if (m0 == NULL)
		return (ENOBUFS);
	m0->m_pkthdr.pf.prio = sc->sc_sppp.pp_if.if_llprio;

	/* fill in pkt */
	p = mtod(m0, u_int8_t *);
	PPPOE_ADD_HEADER(p, PPPOE_CODE_PADI, 0, len);
	PPPOE_ADD_16(p, PPPOE_TAG_SNAME);
	if (sc->sc_service_name != NULL) {
		PPPOE_ADD_16(p, l1);
		memcpy(p, sc->sc_service_name, l1);
		p += l1;
	} else {
		PPPOE_ADD_16(p, 0);
	}
	if (sc->sc_concentrator_name != NULL) {
		PPPOE_ADD_16(p, PPPOE_TAG_ACNAME);
		PPPOE_ADD_16(p, l2);
		memcpy(p, sc->sc_concentrator_name, l2);
		p += l2;
	}
	PPPOE_ADD_16(p, PPPOE_TAG_HUNIQUE);
	PPPOE_ADD_16(p, sizeof(sc->sc_unique));
	memcpy(p, &sc->sc_unique, sizeof(sc->sc_unique));
	p += sizeof(sc->sc_unique);

	if (sc->sc_sppp.pp_if.if_mtu > PPPOE_MTU) {
		PPPOE_ADD_16(p, PPPOE_TAG_MAX_PAYLOAD);
		PPPOE_ADD_16(p, 2);
		PPPOE_ADD_16(p, (u_int16_t)sc->sc_sppp.pp_if.if_mtu);
	}

#ifdef PPPOE_DEBUG
	if (p - mtod(m0, u_int8_t *) != len + PPPOE_HEADERLEN)
		panic("pppoe_send_padi: garbled output len, should be %ld, is %ld",
		    (long)(len + PPPOE_HEADERLEN), (long)(p - mtod(m0, u_int8_t *)));
#endif

	/* send pkt */
	return (pppoe_output(sc, m0));
}

/* Watchdog function. */
static void
pppoe_timeout(void *arg)
{
	struct pppoe_softc *sc = (struct pppoe_softc *)arg;
	int s, x, retry_wait, err;

	PPPOEDEBUG(("%s: timeout\n", sc->sc_sppp.pp_if.if_xname));

	NET_LOCK(s);

	switch (sc->sc_state) {
	case PPPOE_STATE_PADI_SENT:
		/*
		 * We have two basic ways of retrying:
		 *  - Quick retry mode: try a few times in short sequence
		 *  - Slow retry mode: we already had a connection successfully
		 *    established and will try infinitely (without user
		 *    intervention)
		 * We only enter slow retry mode if IFF_LINK1 (aka autodial)
		 * is not set.
		 */

		/* initialize for quick retry mode */
		retry_wait = PPPOE_DISC_TIMEOUT * (1 + sc->sc_padi_retried);

		x = splnet();
		sc->sc_padi_retried++;
		if (sc->sc_padi_retried >= PPPOE_DISC_MAXPADI) {
			if ((sc->sc_sppp.pp_if.if_flags & IFF_LINK1) == 0) {
				/* slow retry mode */
				retry_wait = PPPOE_SLOW_RETRY;
			} else {
				pppoe_abort_connect(sc);
				splx(x);
				break;
			}
		}
		if ((err = pppoe_send_padi(sc)) != 0) {
			sc->sc_padi_retried--;
			PPPOEDEBUG(("%s: failed to transmit PADI, error=%d\n",
			    sc->sc_sppp.pp_if.if_xname, err));
		}
		timeout_add(&sc->sc_timeout, retry_wait);
		splx(x);

		break;
	case PPPOE_STATE_PADR_SENT:
		x = splnet();
		sc->sc_padr_retried++;
		if (sc->sc_padr_retried >= PPPOE_DISC_MAXPADR) {
			memcpy(&sc->sc_dest, etherbroadcastaddr,
			    sizeof(sc->sc_dest));
			sc->sc_state = PPPOE_STATE_PADI_SENT;
			sc->sc_padr_retried = 0;
			if ((err = pppoe_send_padi(sc)) != 0) {
				PPPOEDEBUG(("%s: failed to send PADI, error=%d\n",
				    sc->sc_sppp.pp_if.if_xname, err));
			}
			timeout_add(&sc->sc_timeout,
			    PPPOE_DISC_TIMEOUT * (1 + sc->sc_padi_retried));
			splx(x);
			break;
		}
		if ((err = pppoe_send_padr(sc)) != 0) {
			sc->sc_padr_retried--;
			PPPOEDEBUG(("%s: failed to send PADR, error=%d\n",
			    sc->sc_sppp.pp_if.if_xname, err));
		}
		timeout_add(&sc->sc_timeout,
		    PPPOE_DISC_TIMEOUT * (1 + sc->sc_padr_retried));
		splx(x);

		break;
	case PPPOE_STATE_CLOSING:
		pppoe_disconnect(sc);
		break;
	default:
		break;	/* all done, work in peace */
	}

	NET_UNLOCK(s);
}

/* Start a connection (i.e. initiate discovery phase). */
static int
pppoe_connect(struct pppoe_softc *sc)
{
	int x, err;

	if (sc->sc_state != PPPOE_STATE_INITIAL)
		return (EBUSY);

	x = splnet();

	/* save state, in case we fail to send PADI */
	sc->sc_state = PPPOE_STATE_PADI_SENT;
	sc->sc_padr_retried = 0;
	err = pppoe_send_padi(sc);
	if (err != 0)
		PPPOEDEBUG(("%s: failed to send PADI, error=%d\n",
		    sc->sc_sppp.pp_if.if_xname, err));

	timeout_add(&sc->sc_timeout, PPPOE_DISC_TIMEOUT);
	splx(x);

	return (err);
}

/* disconnect */
static int
pppoe_disconnect(struct pppoe_softc *sc)
{
	int err, x;

	x = splnet();

	if (sc->sc_state < PPPOE_STATE_SESSION)
		err = EBUSY;
	else {
		PPPOEDEBUG(("%s: disconnecting\n",
		    sc->sc_sppp.pp_if.if_xname));
		err = pppoe_send_padt(sc->sc_eth_ifidx,
		    sc->sc_session, (const u_int8_t *)&sc->sc_dest,
		    sc->sc_sppp.pp_if.if_llprio);
	}

	/* cleanup softc */
	sc->sc_state = PPPOE_STATE_INITIAL;
	memcpy(&sc->sc_dest, etherbroadcastaddr, sizeof(sc->sc_dest));
	if (sc->sc_ac_cookie) {
		free(sc->sc_ac_cookie, M_DEVBUF, 0);
		sc->sc_ac_cookie = NULL;
	}
	sc->sc_ac_cookie_len = 0;
	if (sc->sc_relay_sid) {
		free(sc->sc_relay_sid, M_DEVBUF, 0);
		sc->sc_relay_sid = NULL;
	}
	sc->sc_relay_sid_len = 0;
	sc->sc_session = 0;

	/* notify upper layer */
	sc->sc_sppp.pp_down(&sc->sc_sppp);

	splx(x);

	return (err);
}

/* Connection attempt aborted. */
static void
pppoe_abort_connect(struct pppoe_softc *sc)
{
	printf("%s: could not establish connection\n",
		sc->sc_sppp.pp_if.if_xname);
	sc->sc_state = PPPOE_STATE_CLOSING;

	/* notify upper layer */
	sc->sc_sppp.pp_down(&sc->sc_sppp);

	/* clear connection state */
	memcpy(&sc->sc_dest, etherbroadcastaddr, sizeof(sc->sc_dest));
	sc->sc_state = PPPOE_STATE_INITIAL;
}

/* Send a PADR packet */
static int
pppoe_send_padr(struct pppoe_softc *sc)
{
	struct mbuf *m0;
	u_int8_t *p;
	size_t len, l1 = 0; /* XXX: gcc */

	if (sc->sc_state != PPPOE_STATE_PADR_SENT)
		return (EIO);

	len = 2 + 2 + 2 + 2 + sizeof(sc->sc_unique);	/* service name, host unique */
	if (sc->sc_service_name != NULL) {		/* service name tag maybe empty */
		l1 = strlen(sc->sc_service_name);
		len += l1;
	}
	if (sc->sc_ac_cookie_len > 0)
		len += 2 + 2 + sc->sc_ac_cookie_len;	/* AC cookie */
	if (sc->sc_relay_sid_len > 0)
		len += 2 + 2 + sc->sc_relay_sid_len;	/* Relay SID */
	if (sc->sc_sppp.pp_if.if_mtu > PPPOE_MTU)
		len += 2 + 2 + 2;

	m0 = pppoe_get_mbuf(len + PPPOE_HEADERLEN);
	if (m0 == NULL)
		return (ENOBUFS);
	m0->m_pkthdr.pf.prio = sc->sc_sppp.pp_if.if_llprio;

	p = mtod(m0, u_int8_t *);
	PPPOE_ADD_HEADER(p, PPPOE_CODE_PADR, 0, len);
	PPPOE_ADD_16(p, PPPOE_TAG_SNAME);

	if (sc->sc_service_name != NULL) {
		PPPOE_ADD_16(p, l1);
		memcpy(p, sc->sc_service_name, l1);
		p += l1;
	} else {
		PPPOE_ADD_16(p, 0);
	}
	if (sc->sc_ac_cookie_len > 0) {
		PPPOE_ADD_16(p, PPPOE_TAG_ACCOOKIE);
		PPPOE_ADD_16(p, sc->sc_ac_cookie_len);
		memcpy(p, sc->sc_ac_cookie, sc->sc_ac_cookie_len);
		p += sc->sc_ac_cookie_len;
	}
	if (sc->sc_relay_sid_len > 0) {
		PPPOE_ADD_16(p, PPPOE_TAG_RELAYSID);
		PPPOE_ADD_16(p, sc->sc_relay_sid_len);
		memcpy(p, sc->sc_relay_sid, sc->sc_relay_sid_len);
		p += sc->sc_relay_sid_len;
	}
	PPPOE_ADD_16(p, PPPOE_TAG_HUNIQUE);
	PPPOE_ADD_16(p, sizeof(sc->sc_unique));
	memcpy(p, &sc->sc_unique, sizeof(sc->sc_unique));
	p += sizeof(sc->sc_unique);

	if (sc->sc_sppp.pp_if.if_mtu > PPPOE_MTU) {
		PPPOE_ADD_16(p, PPPOE_TAG_MAX_PAYLOAD);
		PPPOE_ADD_16(p, 2);
		PPPOE_ADD_16(p, (u_int16_t)sc->sc_sppp.pp_if.if_mtu);
	}

#ifdef PPPOE_DEBUG
	if (p - mtod(m0, u_int8_t *) != len + PPPOE_HEADERLEN)
		panic("pppoe_send_padr: garbled output len, should be %ld, is %ld",
			(long)(len + PPPOE_HEADERLEN), (long)(p - mtod(m0, u_int8_t *)));
#endif

	return (pppoe_output(sc, m0));
}

/* Send a PADT packet. */
static int
pppoe_send_padt(unsigned int ifidx, u_int session, const u_int8_t *dest, u_int8_t prio)
{
	struct ether_header *eh;
	struct sockaddr dst;
	struct ifnet *eth_if;
	struct mbuf *m0;
	u_int8_t *p;
	int ret;

	if ((eth_if = if_get(ifidx)) == NULL)
		return (EINVAL);

	m0 = pppoe_get_mbuf(PPPOE_HEADERLEN);
	if (m0 == NULL) {
		if_put(eth_if);
		return (ENOBUFS);
	}
	m0->m_pkthdr.pf.prio = prio;

	p = mtod(m0, u_int8_t *);
	PPPOE_ADD_HEADER(p, PPPOE_CODE_PADT, session, 0);

	memset(&dst, 0, sizeof(dst));
	dst.sa_family = AF_UNSPEC;
	eh = (struct ether_header *)&dst.sa_data;
	eh->ether_type = htons(ETHERTYPE_PPPOEDISC);
	memcpy(&eh->ether_dhost, dest, ETHER_ADDR_LEN);

	m0->m_flags &= ~(M_BCAST|M_MCAST);
	/* encapsulated packet is forced into rdomain of physical interface */
	m0->m_pkthdr.ph_rtableid = eth_if->if_rdomain;

	ret = eth_if->if_output(eth_if, m0, &dst, NULL);
	if_put(eth_if);

	return (ret);
}


/* this-layer-start function */
static void
pppoe_tls(struct sppp *sp)
{
	struct pppoe_softc *sc = (void *)sp;

	if (sc->sc_state != PPPOE_STATE_INITIAL)
		return;
	pppoe_connect(sc);
}

/* this-layer-finish function */
static void
pppoe_tlf(struct sppp *sp)
{
	struct pppoe_softc *sc = (void *)sp;

	if (sc->sc_state < PPPOE_STATE_SESSION)
		return;
	/*
	 * Do not call pppoe_disconnect here, the upper layer state
	 * machine gets confused by this. We must return from this
	 * function and defer disconnecting to the timeout handler.
	 */
	sc->sc_state = PPPOE_STATE_CLOSING;
	timeout_add(&sc->sc_timeout, hz / 50);
}

static void
pppoe_start(struct ifnet *ifp)
{
	struct pppoe_softc *sc = (void *)ifp;
	struct mbuf *m;
	size_t len;
	u_int8_t *p;

	if (sppp_isempty(ifp))
		return;

	/* are we ready to process data yet? */
	if (sc->sc_state < PPPOE_STATE_SESSION) {
		sppp_flush(&sc->sc_sppp.pp_if);
		return;
	}

	while ((m = sppp_dequeue(ifp)) != NULL) {
		len = m->m_pkthdr.len;
		M_PREPEND(m, PPPOE_HEADERLEN, M_DONTWAIT);
		if (m == NULL) {
			ifp->if_oerrors++;
			continue;
		}
		p = mtod(m, u_int8_t *);
		PPPOE_ADD_HEADER(p, 0, sc->sc_session, len);

#if NBPFILTER > 0
		if(sc->sc_sppp.pp_if.if_bpf)
			bpf_mtap(sc->sc_sppp.pp_if.if_bpf, m,
			    BPF_DIRECTION_OUT);
#endif

		pppoe_output(sc, m);
	}
}
@


1.61
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.60 2017/01/22 10:17:39 dlg Exp $ */
d235 1
a235 1
	s = splnet();
d243 1
a243 1
	splx(s);
d255 1
a255 1
	s = splnet();
d257 2
a259 1
	splx(s);
d795 1
a795 1
	int s, error = 0;
a930 1
				s = splnet();
a931 1
				splx(s);
a944 1
				s = splnet();
a945 1
				splx(s);
@


1.60
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.59 2017/01/02 08:44:13 mpi Exp $ */
d347 1
a347 1
	splsoftassert(IPL_SOFTNET);
@


1.59
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.58 2017/01/02 08:42:52 mpi Exp $ */
a780 1
	sc->sc_sppp.pp_if.if_opackets++;
@


1.58
log
@pppoe_timeout() needs to take the NET_LOCK().

Assert reported and diff tested by semarie@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.57 2016/06/14 20:44:43 sthen Exp $ */
d205 2
a206 2
	snprintf(sc->sc_sppp.pp_if.if_xname, 
		 sizeof(sc->sc_sppp.pp_if.if_xname), 
d224 1
a224 1
	
d227 1
a227 1
	
d234 1
a234 1
	
d259 1
a259 1
	
d301 1
a301 1
/* 
d577 1
a577 1
		
d587 1
a587 1
		
d592 1
a592 1
		
d600 1
a600 1
		
d605 1
a605 1
		
d610 1
a610 1
		
d627 1
a627 1
		sc->sc_sppp.pp_down(&sc->sc_sppp);	/* signal upper layer */ 
d961 1
a961 1
 * in front. 
d1099 1
a1099 1
		
d1126 1
a1126 1
	
d1148 1
a1148 1
	
d1156 1
a1156 1
	
d1159 1
a1159 1
	
d1337 1
a1337 1
	
d1348 1
a1348 1
	
@


1.57
log
@Don't hardcode vlan/queue priority for pppoe packets; inherit it from the
new "llprio" setting on the pppoe(4) interface instead.

Tested by Daniel Gillen and myself, ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.56 2016/05/30 23:30:11 sthen Exp $ */
d226 1
a226 1
	timeout_set(&sc->sc_timeout, pppoe_timeout, sc);
d1059 1
a1059 1
	int x, retry_wait, err;
d1063 2
d1089 1
a1089 1
				return;
d1116 1
a1116 1
			return;
d1132 1
a1132 1
		return;	/* all done, work in peace */
d1134 2
@


1.56
log
@Set pppoe(4) control frames to high (NC, "network control")
priority.  This is translated into an 802.1p priority tag when
sent over a vlan interface, reducing the risk of them being
crowded out by data packets on a busy link.

Some users have problems with ISPs that place specific
requirements on vlan priority (typically the packet header
value must be '0', relating to priority 1).  This diff
doesn't fix that yet, but gives a single place to patch
to change tags on control packets without affecting
normal vlan priority operation on other interfaces.

ok mikeb.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.55 2016/04/18 14:38:08 mikeb Exp $ */
d166 1
a166 1
static int pppoe_send_padt(unsigned int, u_int, const u_int8_t *);
d699 1
a699 1
		pppoe_send_padt(m->m_pkthdr.ph_ifidx, session, shost);
d1014 1
a1014 1
	m0->m_pkthdr.pf.prio = SPPP_CTL_PRIO;
d1173 2
a1174 1
		    sc->sc_session, (const u_int8_t *)&sc->sc_dest);
d1242 1
a1242 1
	m0->m_pkthdr.pf.prio = SPPP_CTL_PRIO;
d1289 1
a1289 1
pppoe_send_padt(unsigned int ifidx, u_int session, const u_int8_t *dest)
d1306 1
a1306 1
	m0->m_pkthdr.pf.prio = SPPP_CTL_PRIO;
@


1.55
log
@Remove the hack that prevents changing pppoe params at runtime.

The EBUSY hack imposes an order on the ifconfig commands issued
against the pppoe interface used to configure the sppp layer below.
To counter this we use the ENETRESET trick that other drivers use
to tell the pppoe layer that sppp has requested a stop/init reset
sequence to proceed which we oblige with in case pppoe is UP and
RUNNING.

Tested by semarie@@ and Jan Schreiber <jes@@posteo.de>, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.54 2016/04/13 11:41:15 mpi Exp $ */
d1014 1
d1241 1
d1305 1
@


1.54
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.53 2016/04/01 04:03:35 jsg Exp $ */
d795 1
a795 1
	int error = 0;
d926 28
a953 1
		return (sppp_ioctl(ifp, cmd, data));
@


1.53
log
@Building kernels with PPPOE_SERVER enabled has been broken for at least
eleven years, remove it.

Despite what the wildly outdated time(9) claims, there is no longer
globally visible "struct timeval mono_time" or "struct timeval time".

ok mpi@@ sthen@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.52 2015/12/05 10:07:55 tedu Exp $ */
a220 1
	IFQ_SET_READY(&sc->sc_sppp.pp_if.if_snd);
@


1.52
log
@remove old lint annotations
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.51 2015/11/28 19:10:26 reyk Exp $ */
a117 4
#ifdef PPPOE_SERVER
#define	IFF_PASSIVE	IFF_LINK0	/* wait passively for connection */
#endif

a132 4
#ifdef PPPOE_SERVER
	u_int8_t *sc_hunique;		/* content of host unique we must echo back */
	size_t sc_hunique_len;		/* length of host unique */
#endif
a165 4
#ifdef PPPOE_SERVER
static int pppoe_send_pado(struct pppoe_softc *);
static int pppoe_send_pads(struct pppoe_softc *);
#endif
a374 4
#ifdef PPPOE_SERVER
	u_int8_t *hunique;
	size_t hunique_len;
#endif
a392 4
#ifdef PPPOE_SERVER
	hunique = NULL;
	hunique_len = 0;
#endif
a460 4
#ifdef PPPOE_SERVER
			hunique = mtod(n, caddr_t) + noff;
			hunique_len = len;
#endif
a535 39
#ifdef PPPOE_SERVER
		/*
		 * Got service name, concentrator name, and/or host unique.
		 * Ignore if we have no interfaces with IFF_PASSIVE|IFF_UP.
		 */
		if (LIST_EMPTY(&pppoe_softc_list))
			goto done;
		
		LIST_FOREACH(sc, &pppoe_softc_list, sc_list) {
			if (!(sc->sc_sppp.pp_if.if_flags & IFF_UP))
				continue;
			if (!(sc->sc_sppp.pp_if.if_flags & IFF_PASSIVE))
				continue;
			if (sc->sc_state == PPPOE_STATE_INITIAL)
				break;
		}
		if (sc == NULL) {
#ifdef PPPOE_DEBUG
			printf("pppoe: free passive interface is not found\n");
#endif
			goto done;
		}
		if (hunique) {
			if (sc->sc_hunique)
				free(sc->sc_hunique, M_DEVBUF, 0);
			sc->sc_hunique = malloc(hunique_len, M_DEVBUF,
			    M_DONTWAIT);
			if (sc->sc_hunique == NULL)
				goto done;
			sc->sc_hunique_len = hunique_len;
			memcpy(sc->sc_hunique, hunique, hunique_len);
		}
		
		memcpy(&sc->sc_dest, eh->ether_shost, sizeof(sc->sc_dest));
		sc->sc_state = PPPOE_STATE_PADO_SENT;
		pppoe_send_pado(sc);

		break;
#endif /* PPPOE_SERVER */
a536 41
#ifdef PPPOE_SERVER
		/*
		 * Get sc from ac_cookie if IFF_PASSIVE.
		 */
		if (ac_cookie == NULL) {
			/* be quiet if there is not a single pppoe instance */
			printf("pppoe: received PADR but not includes ac_cookie\n");
			goto done;
		}
		
		sc = pppoe_find_softc_by_hunique(ac_cookie,
						 ac_cookie_len,
						 m->m_pkthdr.ph_ifidx);
		if (sc == NULL) {
			/* be quiet if there is not a single pppoe instance */
			if (!LIST_EMPTY(&pppoe_softc_list))
				printf("pppoe: received PADR but could not find request for it\n");
			goto done;
		}
		if (sc->sc_state != PPPOE_STATE_PADO_SENT) {
			printf("%s: received unexpected PADR\n",
			    sc->sc_sppp.pp_if.if_xname);
			goto done;
		}
		if (hunique) {
			if (sc->sc_hunique)
				free(sc->sc_hunique, M_DEVBUF, 0);
			sc->sc_hunique = malloc(hunique_len, M_DEVBUF,
			    M_DONTWAIT);
			if (sc->sc_hunique == NULL)
				goto done;
			sc->sc_hunique_len = hunique_len;
			memcpy(sc->sc_hunique, hunique, hunique_len);
		}
		
		pppoe_send_pads(sc);
		sc->sc_state = PPPOE_STATE_SESSION;
		sc->sc_sppp.pp_up(&sc->sc_sppp);
		
		break;
#else
a538 1
#endif /* PPPOE_SERVER */
a1115 5
#ifdef PPPOE_SERVER
	/* wait for PADI if IFF_PASSIVE */
	if ((sc->sc_sppp.pp_if.if_flags & IFF_PASSIVE))
		return (0);
#endif
a1161 7
#ifdef PPPOE_SERVER
	if (sc->sc_hunique) {
		free(sc->sc_hunique, M_DEVBUF, 0);
		sc->sc_hunique = NULL;
	}
	sc->sc_hunique_len = 0;
#endif
a1296 79
#ifdef PPPOE_SERVER
/* Send a PADO packet. */
static int
pppoe_send_pado(struct pppoe_softc *sc)
{
	struct mbuf *m0;
	size_t len;
	u_int8_t *p;
	
	if (sc->sc_state != PPPOE_STATE_PADO_SENT)
		return (EIO);

	/* calc length */
	len = 0;
	/* include ac_cookie */
	len += 2 + 2 + sizeof(sc->sc_unique);
	/* include hunique */
	len += 2 + 2 + sc->sc_hunique_len;
	
	m0 = pppoe_get_mbuf(len + PPPOE_HEADERLEN);
	if (m0 == NULL)
		return (ENOBUFS);

	p = mtod(m0, u_int8_t *);
	PPPOE_ADD_HEADER(p, PPPOE_CODE_PADO, 0, len);
	PPPOE_ADD_16(p, PPPOE_TAG_ACCOOKIE);
	PPPOE_ADD_16(p, sizeof(sc->sc_unique));
	memcpy(p, &sc, sizeof(sc->sc_unique));
	p += sizeof(sc->sc_unique);
	PPPOE_ADD_16(p, PPPOE_TAG_HUNIQUE);
	PPPOE_ADD_16(p, sc->sc_hunique_len);
	memcpy(p, sc->sc_hunique, sc->sc_hunique_len);

	return (pppoe_output(sc, m0));
}

/* Send a PADS packet. */
static int
pppoe_send_pads(struct pppoe_softc *sc)
{
	struct mbuf *m0;
	size_t len, l1;
	u_int8_t *p;

	if (sc->sc_state != PPPOE_STATE_PADO_SENT)
		return (EIO);

	sc->sc_session = mono_time.tv_sec % 0xff + 1;

	/* calc length */
	len = 0;
	/* include hunique */
	len += 2 + 2 + 2 + 2 + sc->sc_hunique_len;	/* service name, host unique */
	if (sc->sc_service_name != NULL) {		/* service name tag maybe empty */
		l1 = strlen(sc->sc_service_name);
		len += l1;
	}
	
	m0 = pppoe_get_mbuf(len + PPPOE_HEADERLEN);
	if (m0 == NULL)
		return (ENOBUFS);

	p = mtod(m0, u_int8_t *);
	PPPOE_ADD_HEADER(p, PPPOE_CODE_PADS, sc->sc_session, len);
	PPPOE_ADD_16(p, PPPOE_TAG_SNAME);
	if (sc->sc_service_name != NULL) {
		PPPOE_ADD_16(p, l1);
		memcpy(p, sc->sc_service_name, l1);
		p += l1;
	} else {
		PPPOE_ADD_16(p, 0);
	}
	PPPOE_ADD_16(p, PPPOE_TAG_HUNIQUE);
	PPPOE_ADD_16(p, sc->sc_hunique_len);
	memcpy(p, sc->sc_hunique, sc->sc_hunique_len);

	return (pppoe_output(sc, m0));
}
#endif
@


1.51
log
@Convert pppoe(4) to use if_get()/if_put(): instead of storing a
pointer to the parent "pppoedev", it now only stores an interface
index.  This also fixes a potential NULL pointer dereference that
could happen in pppoe_find_softc_by_session() when the parent got
deconfigured but the session was still active.

Found the hard way with pppoe(4) on vlan7.

OK mpi@@, with debugging help from mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.50 2015/11/20 12:05:34 sthen Exp $ */
a197 1
/* ARGSUSED */
@


1.50
log
@sppp(4) is now only used for pppoe(4) which doesn't use framing, so remove
support for sppp with framing, simplifying things. Remove unused ifdefs while
there.

"sppp will go away before it gets used for something else" dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.49 2015/10/25 11:58:11 mpi Exp $ */
d125 1
a125 1
	struct ifnet *sc_eth_if;	/* ethernet interface we are using */
d178 1
a178 1
static int pppoe_send_padt(struct ifnet *, u_int, const u_int8_t *);
d308 1
a308 1
		    && sc->sc_eth_if->if_index == ifidx) {
d347 1
a347 1
	if (sc->sc_eth_if->if_index != ifidx) {
d806 1
a806 1
		pppoe_send_padt(m->m_pkthdr.rcvif, session, shost);
d856 1
d858 1
d860 1
a860 1
	if (sc->sc_eth_if == NULL) {
d864 2
a865 2
	
	if ((sc->sc_eth_if->if_flags & (IFF_UP|IFF_RUNNING))
d867 1
d886 1
a886 1
	m->m_pkthdr.ph_rtableid = sc->sc_eth_if->if_rdomain;
d889 4
a892 1
	return sc->sc_eth_if->if_output(sc->sc_eth_if, m, &dst, NULL);
d901 1
d917 1
a917 1
				sc->sc_eth_if = NULL;
d926 1
a926 1
			sc->sc_eth_if = eth_if;
d961 2
a962 2
		if (sc->sc_eth_if)
			strlcpy(parms->eth_ifname, sc->sc_eth_if->if_xname,
d964 2
a965 1
		else
d1019 2
d1022 8
a1029 3
		    (sc->sc_eth_if == NULL ? PPPOE_MAXMTU :
		    (sc->sc_eth_if->if_mtu - PPPOE_OVERHEAD))))
			return (EINVAL);
d1256 2
a1257 1
		err = pppoe_send_padt(sc->sc_eth_if, sc->sc_session, (const u_int8_t *)&sc->sc_dest);
d1378 1
a1378 1
pppoe_send_padt(struct ifnet *outgoing_if, u_int session, const u_int8_t *dest)
d1382 1
d1385 4
d1391 2
a1392 1
	if (m0 == NULL)
d1394 1
d1407 4
a1410 1
	m0->m_pkthdr.ph_rtableid = outgoing_if->if_rdomain;
d1412 1
a1412 1
	return outgoing_if->if_output(outgoing_if, m0, &dst, NULL);
@


1.49
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.48 2015/09/13 17:53:44 mpi Exp $ */
d226 1
a226 2
	sc->sc_sppp.pp_flags |= PP_KEEPALIVE |		/* use LCP keepalive */
			        PP_NOFRAMING;		/* no serial encapsulation */
@


1.48
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.47 2015/09/12 20:26:06 mpi Exp $ */
d231 1
@


1.47
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.46 2015/06/16 11:09:39 mpi Exp $ */
d886 1
a886 1
	return if_output(sc->sc_eth_if, m, &dst, NULL);
d1386 1
a1386 1
	return if_output(outgoing_if, m0, &dst, NULL);
@


1.46
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.45 2015/04/10 13:58:20 dlg Exp $ */
d886 1
a886 1
	return (sc->sc_eth_if->if_output(sc->sc_eth_if, m, &dst, NULL));
d1386 1
a1386 1
	return (outgoing_if->if_output(outgoing_if, m0, &dst, NULL));
@


1.45
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.44 2015/03/14 03:38:51 jsg Exp $ */
d184 2
a185 2
static struct pppoe_softc *pppoe_find_softc_by_session(u_int, struct ifnet *);
static struct pppoe_softc *pppoe_find_softc_by_hunique(u_int8_t *, size_t, struct ifnet *);
d298 1
a298 1
pppoe_find_softc_by_session(u_int session, struct ifnet *rcvif)
d308 1
a308 1
		    && sc->sc_eth_if == rcvif) {
d320 1
a320 1
pppoe_find_softc_by_hunique(u_int8_t *token, size_t len, struct ifnet *rcvif)
d347 1
a347 1
	if (sc->sc_eth_if != rcvif) {
d487 1
a487 1
			    len, m->m_pkthdr.rcvif);
d613 1
a613 1
						 m->m_pkthdr.rcvif);
d801 1
a801 1
	sc = pppoe_find_softc_by_session(session, m->m_pkthdr.rcvif);
d840 1
a840 1
	m->m_pkthdr.rcvif = &sc->sc_sppp.pp_if;
d1046 1
a1046 1
	m->m_pkthdr.rcvif = NULL;
@


1.44
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.43 2014/12/05 15:50:04 mpi Exp $ */
d51 1
d150 2
a151 2
struct ifqueue pppoediscinq;
struct ifqueue pppoeinq;
a203 3

	IFQ_SET_MAXLEN(&pppoediscinq, IFQ_MAXLEN);
	IFQ_SET_MAXLEN(&pppoeinq, IFQ_MAXLEN);
a359 1
	int s;
d362 2
a363 7
	
	for (;;) {
		s = splnet();
		IF_DEQUEUE(&pppoediscinq, m);
		splx(s);
		if (m == NULL)
			break;
a364 1
	}
d366 1
a366 6
	for (;;) {
		s = splnet();
		IF_DEQUEUE(&pppoeinq, m);
		splx(s);
		if (m == NULL)
			break;
a367 1
	}
@


1.43
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.42 2014/11/18 02:37:31 tedu Exp $ */
a50 1
#include <net/netisr.h>
@


1.42
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.41 2014/08/13 12:03:40 mpi Exp $ */
d47 1
@


1.41
log
@Correctly set the rtable ID of the packet header when sending
Active Discovery Terminate packets.

ok mikeb@@, henning@@, phessler@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.40 2014/07/12 18:44:22 tedu Exp $ */
a52 3

/* for arc4random() */
#include <dev/rndvar.h>
@


1.40
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.39 2014/06/07 11:04:14 henning Exp $ */
d1401 3
@


1.39
log
@g/c unused IFT_L2VLAN, ok reyk bluhm
the #define stays since it's userland visible and who knows what uses it
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.37 2013/04/10 08:50:59 mpi Exp $ */
d283 1
a283 1
		free(sc->sc_concentrator_name, M_DEVBUF);
d285 1
a285 1
		free(sc->sc_service_name, M_DEVBUF);
d287 1
a287 1
		free(sc->sc_ac_cookie, M_DEVBUF);
d289 1
a289 1
		free(sc->sc_relay_sid, M_DEVBUF);
d291 1
a291 1
	free(sc, M_DEVBUF);
d603 1
a603 1
				free(sc->sc_hunique, M_DEVBUF);
d645 1
a645 1
				free(sc->sc_hunique, M_DEVBUF);
d677 1
a677 1
				free(sc->sc_ac_cookie, M_DEVBUF);
d687 1
a687 1
				free(sc->sc_relay_sid, M_DEVBUF);
d740 1
a740 1
			free(sc->sc_ac_cookie, M_DEVBUF);
d744 1
a744 1
			free(sc->sc_relay_sid, M_DEVBUF);
d941 1
a941 1
			free(sc->sc_concentrator_name, M_DEVBUF);
d954 1
a954 1
			free(sc->sc_service_name, M_DEVBUF);
d1266 1
a1266 1
		free(sc->sc_ac_cookie, M_DEVBUF);
d1271 1
a1271 1
		free(sc->sc_relay_sid, M_DEVBUF);
d1277 1
a1277 1
		free(sc->sc_hunique, M_DEVBUF);
@


1.38
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d927 1
a927 3
			if (eth_if == NULL ||
			    (eth_if->if_type != IFT_ETHER &&
			     eth_if->if_type != IFT_L2VLAN)) {
@


1.37
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.36 2013/03/28 16:45:16 tedu Exp $ */
d901 1
a901 1
	m->m_pkthdr.rdomain = sc->sc_eth_if->if_rdomain;
@


1.36
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.35 2012/04/11 17:42:53 mikeb Exp $ */
a153 2

extern int sppp_ioctl(struct ifnet *, unsigned long, void *);
@


1.35
log
@fix all the suser calls which pass an incorrect p_acflag argument;
figured out by and ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.34 2012/01/19 01:13:20 sthen Exp $ */
a44 1
#include <sys/proc.h>
@


1.34
log
@Teach pppoe(4) about RFC 4638. This allows negotiating increased MTU with
compatible equipment provided that the physical interface and other layer 2
devices involved support and are configured to use jumbo frames.

Manpage to follow; typical use is to request 1500 MTU for pppoe, this
requires 1508+ MTU on the physical interface, e.g. "ifconfig em0 mtu 1508;
ifconfig pppoe0 mtu 1500". Known to be usable in the UK with some ISPs
(e.g. aaisp) using BT FTTC backhaul.

From Matt Dainty, originally based on support in NetBSD, changed to
decouple pppoe from physical interface MTU. Tested with UK FTTC by Matt,
no regressions on my standard UK ADSL setup or yasuoka@@'s setup (in Japan,
NTT uses 1452 byte MTU for PPPoE and 1500 byte MTU for IPv6 on the same
network).

ok yasuoka@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.33 2011/07/06 02:42:28 henning Exp $ */
d923 2
a924 2
		
		if ((error = suser(p, p->p_acflag)) != 0)
@


1.33
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.32 2011/07/05 20:00:14 henning Exp $ */
d89 1
d92 1
a92 1
#define	PPPOE_TAG_GENERIC_ERR	0x0203		/* gerneric error */
d101 2
a102 1
#define	PPPOE_MAXMTU	(ETHERMTU - PPPOE_OVERHEAD)
d230 1
a230 1
	sc->sc_sppp.pp_if.if_mtu = PPPOE_MAXMTU;
d403 1
d430 1
d538 12
d698 7
d1034 3
a1036 2
		if (ifr->ifr_mtu > (sc->sc_eth_if == NULL ?
		    PPPOE_MAXMTU : (sc->sc_eth_if->if_mtu - PPPOE_OVERHEAD)))
d1095 2
d1123 7
a1131 1
	p += sizeof(sc->sc_unique);
d1333 2
d1366 7
a1374 1
	p += sizeof(sc->sc_unique);
@


1.32
log
@ifqueues in BSS don't need NULL init, especially not absolutely incorrect
ones that make assumptions about ifqueue internals... ok ryan claudio
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.31 2009/07/13 16:23:28 claudio Exp $ */
d208 2
a209 2
	pppoediscinq.ifq_maxlen = IFQ_MAXLEN;
	pppoeinq.ifq_maxlen = IFQ_MAXLEN;
@


1.31
log
@Do the same rdomain checking in sppp as we do in the Ethernet case.
Encapsulated pppoe packets are moved into the rdomain of the physical interface
because it is possible that a pppoe(4) interface is in a different rdomain
then the physical interface.
OK reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.30 2009/03/15 19:40:41 miod Exp $ */
d151 2
a152 2
struct ifqueue pppoediscinq = { NULL };
struct ifqueue pppoeinq = { NULL };
@


1.30
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.29 2008/10/16 12:20:27 canacar Exp $ */
d880 3
@


1.29
log
@Make the session id unique per receiving interface so that pppoe
interfaces attached to different networks can use the same session id.
reported by gm_sjo <saqmaster at gmail dot com>
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.28 2008/10/11 20:34:10 miod Exp $ */
d368 1
a368 1
	splassert(IPL_SOFTNET);
@


1.28
log
@Make sure no two pppoe devices share the same sc_unique identifier. While
there, fix some typos, and pass M_CANFAIL to all malloc() calls which use
M_WAITOK but are tested for failure.

test&ok brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.27 2008/10/01 16:51:48 mk Exp $ */
d313 3
a315 5
		    && sc->sc_session == session) {
			if (sc->sc_eth_if == rcvif)
				return (sc);
			else
				return (NULL);
@


1.27
log
@Don't timeout_del() if we're going to do a timeout_add() right away.

ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.26 2008/08/28 13:19:38 brad Exp $ */
d174 1
a174 1
/* sending actual protocol controll packets */
d216 2
a217 1
	struct pppoe_softc *sc;
d220 1
a220 1
        sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK|M_ZERO);
a223 2
	sc->sc_unique = arc4random();

d256 6
d927 1
a927 1
			char *p = malloc(len + 1, M_DEVBUF, M_WAITOK);
d940 1
a940 1
			char *p = malloc(len + 1, M_DEVBUF, M_WAITOK);
d1061 1
a1061 1
	len = 2 + 2 + 2 + 2 + sizeof(sc->sc_unique); /* service name tag is required, host unique is send too */
@


1.26
log
@some style fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.25 2008/08/28 13:10:54 brad Exp $ */
a680 1
		timeout_del(&sc->sc_timeout);
@


1.25
log
@Fix a typo in the naming of the PPPoE input queues, ppoe -> pppoe.

ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.24 2008/08/27 08:41:46 brad Exp $ */
d78 1
a78 1
#define PPPOE_HEADERLEN		sizeof(struct pppoehdr)
d93 1
a93 1
#define PPPOE_CODE_PADI		0x09		/* Active Discovery Initiation */
d108 1
a108 1
#define PPPOE_ADD_HEADER(PTR, CODE, SESS, LEN)	\
d116 1
a116 1
#define PPPOE_DISC_MAXPADI	4	/* retry PADI four times (quickly) */
d120 1
a120 1
#define IFF_PASSIVE	IFF_LINK0	/* wait passively for connection */
@


1.24
log
@Fix length check when parsing PPPoE discovery phase packets.

Malicious PPPoE discovery packets could cause the kernel to
crash.

From canacar@@ and inspired by the original fix from NetBSD.
ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.23 2008/08/09 11:25:05 thib Exp $ */
d151 2
a152 2
struct ifqueue ppoediscinq = { NULL };
struct ifqueue ppoeinq = { NULL };
d208 2
a209 2
	ppoediscinq.ifq_maxlen = IFQ_MAXLEN;
	ppoeinq.ifq_maxlen = IFQ_MAXLEN;
d369 1
a369 1
		IF_DEQUEUE(&ppoediscinq, m);
d378 1
a378 1
		IF_DEQUEUE(&ppoeinq, m);
@


1.23
log
@turn an MFREE() into an m_free() and garbage collect an
unused mbuf pointer.

OK claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.22 2008/06/26 05:42:20 ray Exp $ */
d474 1
d490 1
a490 1
			n = m_pulldown(m, off + sizeof(*pt), len, &noff);
d507 1
a507 1
				n = m_pulldown(m, off + sizeof(*pt), len,
d520 1
a520 1
				n = m_pulldown(m, off + sizeof(*pt), len,
d547 1
a547 1
				n = m_pulldown(m, off + sizeof(*pt), len,
d558 1
a558 1
		off += sizeof(*pt) + len;
@


1.22
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.21 2008/05/13 02:24:08 brad Exp $ */
d1032 1
a1032 3
			struct mbuf *n;

			MFREE(m, n);
@


1.21
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.20 2008/04/24 11:36:38 dlg Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.20
log
@the softnet intr handlers check if the input queue has packets on
it by reading the queues head pointer. if that pointer is not null
then it takes splnet and dequeues a packet for handling. this is
bad because the ifqueue head is modified at splnet and the sofnet
handlers read it without holding splnet.

this removes that check of the head pointer and simply checks if
the dequeue gave us a packet or not before proceeding.

found while reading mpls code.
discussed with norby@@ and henning@@

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.19 2008/03/20 16:46:34 brad Exp $ */
a38 5

#include <sys/cdefs.h>
/*
__KERNEL_RCSID(0, "$NetBSD: if_pppoe.c,v 1.51 2003/11/28 08:56:48 keihan Exp $");
*/
@


1.19
log
@Adapt maximum MTU permitted on pppoe(4) interfaces to the MTU of the
connected Ethernet/VLAN interface.

From NetBSD

Tested by brad@@ sthen@@
ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.18 2008/03/18 21:33:45 claudio Exp $ */
d379 1
a379 1
	while (ppoediscinq.ifq_head) {
d388 1
a388 1
	while (ppoeinq.ifq_head) {
@


1.18
log
@Don't use ph after the m_pulldown() calls because the mbuf chain could be
modified. Better save than sorry. OK canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.17 2008/03/18 21:23:47 claudio Exp $ */
d91 1
d112 1
a112 1
#define	PPPOE_MAXMTU	(ETHERMTU - PPPOE_HEADERLEN - 2)
d910 6
a915 4
			sc->sc_eth_if = ifunit(parms->eth_ifname);
			if (sc->sc_eth_if == NULL ||
			    (sc->sc_eth_if->if_type != IFT_ETHER &&
			     sc->sc_eth_if->if_type != IFT_L2VLAN)) {
d919 7
d1017 2
a1018 1
		if (ifr->ifr_mtu > PPPOE_MAXMTU)
@


1.17
log
@Don't use MBUFLOCK() for ifqueue protection use the correct splnet() dance
instead. OK canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.16 2008/03/14 02:56:26 brad Exp $ */
d413 1
d461 1
d571 1
a571 1
	switch (ph->code) {
d746 1
a746 1
		    ph->code, session);
@


1.16
log
@Do not allow pppoe(4) interfaces to be attached to anything but Ethernet
or VLAN interfaces.

Based on a similar change from NetBSD.

ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.15 2008/03/12 17:27:03 canacar Exp $ */
d374 1
d379 3
a381 1
		MBUFLOCK(IF_DEQUEUE(&ppoediscinq, m););
d388 3
a390 1
		MBUFLOCK(IF_DEQUEUE(&ppoeinq, m););
@


1.15
log
@Include relay-sid in the response if one was received.
Reported and tested by Zach Wilkinson
ok brad@@, claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.14 2008/02/20 09:37:52 brad Exp $ */
d903 4
a906 1
			if (sc->sc_eth_if == NULL)
d908 1
@


1.14
log
@Fix a mbuf leak which can be triggered on a system
receiving PPPoE packets but without any PPPoE interfaces
setup.

From mickey@@ via PR 5713.

ok canacar@@ claudio@@ dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.13 2007/09/15 16:43:51 henning Exp $ */
d147 2
d295 2
d402 1
d407 1
d427 2
d521 13
d672 10
d724 4
d729 1
d1229 5
d1285 2
d1308 6
@


1.13
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.12 2007/05/28 06:31:01 mcbride Exp $ */
a368 1
	struct pppoe_softc *sc;
d373 6
a378 7
	LIST_FOREACH(sc, &pppoe_softc_list, sc_list) {
		while (ppoediscinq.ifq_head) {
			MBUFLOCK(IF_DEQUEUE(&ppoediscinq, m););
			if (m == NULL)
				break;
			pppoe_disc_input(m);
		}
d380 5
a384 6
		while (ppoeinq.ifq_head) {
			MBUFLOCK(IF_DEQUEUE(&ppoeinq, m););
			if (m == NULL)
				break;
			pppoe_data_input(m);
		}
d733 2
@


1.12
log
@Users of arc4random() should include dev/rndvar.h directly.

ok dlg claudio
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.11 2006/12/28 23:38:23 todd Exp $ */
d228 1
a228 1
        MALLOC(sc, struct pppoe_softc *, sizeof(*sc), M_DEVBUF, M_WAITOK);
a230 1
        bzero(sc, sizeof(struct pppoe_softc));
@


1.11
log
@knf, from bred@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.10 2006/12/28 20:06:11 deraadt Exp $ */
d66 3
@


1.10
log
@check if ifqueue has anything queued before doing the dance of
splnet/IF_DEQUEUE/splx; ok various people
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.9 2006/07/11 21:21:59 canacar Exp $ */
d375 2
a376 1
			if (m == NULL) break;
d382 2
a383 1
			if (m == NULL) break;
d986 1
@


1.9
log
@Error messages from remote may not be '\0' terminated.
Also cleanup error message device name printing.
Based on diff from NetBSD via Andrey Matveev
Also, use log when printing error messages, and syslog will
handle any nonprintable characters, discussed with deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.8 2006/03/25 22:41:47 djm Exp $ */
d373 1
a373 1
		for (;;) {
d379 1
a379 1
		for (;;) {
@


1.8
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.7 2006/03/04 22:40:15 brad Exp $ */
d56 1
d395 1
a395 1
	const char *err_msg, *err_txt;
d406 2
a407 1
	err_msg = err_txt = NULL;
d462 1
a462 2
			printf("%s: parse error\n",
			    sc ? sc->sc_sppp.pp_if.if_xname : "pppoe");
d470 2
a471 2
			printf("pppoe: tag 0x%x len 0x%x is too long\n",
			    tag, len);
d496 2
d526 1
a526 1
			err_txt = "";
d530 5
a534 2
				if (n)
					err_txt = mtod(n, caddr_t) + noff;
d536 1
a536 3
			printf("%s: %s: %*s\n",
			    sc ? sc->sc_sppp.pp_if.if_xname : "pppoe*",
			    err_msg, len, err_txt);
a707 1
	return;
@


1.7
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.6 2006/01/04 06:04:42 canacar Exp $ */
d772 1
a772 1
		bpf_mtap(sc->sc_sppp.pp_if.if_bpf, m);
d1436 2
a1437 1
			bpf_mtap(sc->sc_sppp.pp_if.if_bpf, m);
@


1.6
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.5 2005/10/08 20:31:25 canacar Exp $ */
d262 1
a262 1
	s = splimp();
d276 1
a276 1
	s = splimp();
@


1.5
log
@Prevent information leak by using a random hunique value instead of
the address of the softc. Reported by Peter Phillip via PR-4501.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.4 2005/06/07 05:10:57 canacar Exp $ */
a280 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.4
log
@fix a possible panic in error path,
do not try to check debug status of a
non existing interface in server mode.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.3 2005/01/01 00:30:31 canacar Exp $ */
d147 1
d229 2
d332 2
a333 1
	struct pppoe_softc *sc, *t;
d338 1
a338 1
	if (len != sizeof(sc))
d340 1
a340 1
	memcpy(&t, token, len);
d343 2
a344 1
		if (sc == t) break;
d1008 1
a1008 1
	len = 2 + 2 + 2 + 2 + sizeof(sc);	/* service name tag is required, host unique is send too */
d1041 2
a1042 2
	PPPOE_ADD_16(p, sizeof(sc));
	memcpy(p, &sc, sizeof(sc));
d1045 1
a1045 1
	p += sizeof sc;
d1233 1
a1233 1
	len = 2 + 2 + 2 + 2 + sizeof(sc);		/* service name, host unique */
d1263 2
a1264 2
	PPPOE_ADD_16(p, sizeof(sc));
	memcpy(p, &sc, sizeof(sc));
d1267 1
a1267 1
	p += sizeof(sc);
d1317 1
a1317 1
	len += 2 + 2 + sizeof(sc);
d1328 3
a1330 3
	PPPOE_ADD_16(p, sizeof(sc));
	memcpy(p, &sc, sizeof(sc));
	p += sizeof(sc);
@


1.3
log
@Disable timeout before destroying a pppoe interface
ok deraadt@@, henning@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.2 2004/11/29 20:15:40 pat Exp $ */
d531 1
a531 2
			if (errortag)
				goto done;
d555 3
a557 1
			PPPOEDEBUG(("pppoe: free passive interface is not found\n"));
@


1.2
log
@plug memory leaks on error

ok canacar markus millert
@
text
@d1 1
a1 1
/* $OpenBSD: if_pppoe.c,v 1.1 2004/11/28 23:39:45 canacar Exp $ */
d275 1
@


1.1
log
@In kernel pppoe client, a simple IPv4 only implementation.
Initial porting from NetBSD by David Berghoff.
Modified/simplified to match our sppp implementation.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d812 1
a812 1
		m_free(m);
d816 3
a818 1
	if ((sc->sc_eth_if->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
d820 1
@

