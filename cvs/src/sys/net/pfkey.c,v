head	1.40;
access;
symbols
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.8
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.18.0.18
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.16
	OPENBSD_5_0:1.18.0.14
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.12
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.10
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.8
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.6
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.11.0.8
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.40
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.39;
commitid	ZsxSSZJSFxZH81LL;

1.39
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.38;
commitid	LtQeAWkATeJFPv2t;

1.38
date	2017.03.02.08.58.24;	author mpi;	state Exp;
branches;
next	1.37;
commitid	tz6lHk1OQ6UxADoY;

1.37
date	2017.02.22.19.34.42;	author dhill;	state Exp;
branches;
next	1.36;
commitid	8MQyAJVsE6ZNz4mh;

1.36
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.35;
commitid	6c6qq5OdS4VVnyVM;

1.35
date	2017.01.23.16.31.24;	author bluhm;	state Exp;
branches;
next	1.34;
commitid	9EAe7cRTLFNc3XTC;

1.34
date	2017.01.13.08.52.09;	author mpi;	state Exp;
branches;
next	1.33;
commitid	OhxRzTvnc9kLxnqM;

1.33
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.32;
commitid	ZQetSMB5ilG2z10X;

1.32
date	2016.11.07.10.04.57;	author mpi;	state Exp;
branches;
next	1.31;
commitid	9qRV4NcQ7UVngnFp;

1.31
date	2016.09.05.15.12.30;	author claudio;	state Exp;
branches;
next	1.30;
commitid	9stAtK16gR2yeKoN;

1.30
date	2016.08.15.11.35.25;	author dlg;	state Exp;
branches;
next	1.29;
commitid	CgCan1eMToI9G3qa;

1.29
date	2016.03.22.11.53.21;	author dlg;	state Exp;
branches;
next	1.28;
commitid	PHuDNibNEv4OF3hH;

1.28
date	2015.10.07.10.50.35;	author mpi;	state Exp;
branches;
next	1.27;
commitid	hPrd2a6fiZdlN2yP;

1.27
date	2015.09.04.08.43.39;	author mpi;	state Exp;
branches;
next	1.26;
commitid	qAevExm24QrBjVNL;

1.26
date	2015.08.30.10.39.16;	author mpi;	state Exp;
branches;
next	1.25;
commitid	avqdJydG8T8nvZhe;

1.25
date	2015.07.17.18.31.08;	author blambert;	state Exp;
branches;
next	1.24;
commitid	WEUQfMsVq6mbe3cF;

1.24
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.23;
commitid	zM5ckwX4kwwmipG0;

1.23
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	mdGXHklUZmESVFlY;

1.22
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.21;
commitid	ZqXwxwmeo3l29NOg;

1.21
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.20;
commitid	B4dZSbxas1X1IpXI;

1.20
date	2012.11.27.17.29.07;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.13.21.00.14;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.26.18.02.22;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.03.12.10.48;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.16.19.54.20;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.11.21.48.40;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.08.03.58.48;	author angelos;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.06.05.02.31.33;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.19.03.19.39;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.12.21.39.26;	author angelos;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.06.01.23.43.42;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	99.05.21.23.15.22;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.05.03.22.30.27;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.04.11.19.41.35;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.02.25.19.09.18;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.02.25.02.48.26;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.02.24.22.36.03;	author angelos;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.40.03;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.54.14;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2003.05.19.22.29.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@/*	$OpenBSD: pfkey.c,v 1.39 2017/03/03 15:48:02 bluhm Exp $	*/

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Craig Metz. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/mbuf.h>
#include <sys/socketvar.h>
#include <net/radix.h>
#include <netinet/ip_ipsp.h>
#include <net/pfkeyv2.h>

#include <sys/protosw.h>
#include <sys/domain.h>
#include <net/raw_cb.h>

#define PFKEY_PROTOCOL_MAX 3
static struct pfkey_version *pfkey_versions[PFKEY_PROTOCOL_MAX+1] =
    { NULL, NULL, NULL, NULL };

#define PFKEY_MSG_MAXSZ 4096

struct sockaddr pfkey_addr = { 2, PF_KEY, };

int pfkey_usrreq(struct socket *, int , struct mbuf *, struct mbuf *,
    struct mbuf *, struct proc *);
int pfkey_output(struct mbuf *, struct socket *, struct sockaddr *,
    struct mbuf *);

void pfkey_init(void);
int pfkey_buildprotosw(void);

int
pfkey_register(struct pfkey_version *version)
{
	int rval;

	if ((version->protocol > PFKEY_PROTOCOL_MAX) ||
	    (version->protocol < 0))
		return (EPROTONOSUPPORT);

	if (pfkey_versions[version->protocol])
		return (EADDRINUSE);

	pfkey_versions[version->protocol] = version;

	if ((rval = pfkey_buildprotosw()) != 0) {
		pfkey_versions[version->protocol] = NULL;
		return (rval);
	}

	return (0);
}

int
pfkey_unregister(struct pfkey_version *version)
{
	int rval;

	if ((rval = pfkey_buildprotosw()) != 0)
		return (rval);

	pfkey_versions[version->protocol] = NULL;
	return (0);
}

int
pfkey_sendup(struct socket *socket, struct mbuf *packet, int more)
{
	struct mbuf *packet2;

	splsoftassert(IPL_SOFTNET);

	if (more) {
		if (!(packet2 = m_dup_pkt(packet, 0, M_DONTWAIT)))
			return (ENOMEM);
	} else
		packet2 = packet;

	if (!sbappendaddr(&socket->so_rcv, &pfkey_addr, packet2, NULL)) {
		m_freem(packet2);
		return (ENOBUFS);
	}

	sorwakeup(socket);
	return (0);
}

int
pfkey_output(struct mbuf *mbuf, struct socket *socket, struct sockaddr *dstaddr,
    struct mbuf *control)
{
	void *message;
	int error = 0;

#ifdef DIAGNOSTIC
	if (!mbuf || !(mbuf->m_flags & M_PKTHDR)) {
		error = EINVAL;
		goto ret;
	}
#endif /* DIAGNOSTIC */

	if (mbuf->m_pkthdr.len > PFKEY_MSG_MAXSZ) {
		error = EMSGSIZE;
		goto ret;
	}

	if (!(message = malloc((unsigned long) mbuf->m_pkthdr.len,
	    M_PFKEY, M_DONTWAIT))) {
		error = ENOMEM;
		goto ret;
	}

	m_copydata(mbuf, 0, mbuf->m_pkthdr.len, message);

	error = pfkey_versions[socket->so_proto->pr_protocol]->send(socket,
	    message, mbuf->m_pkthdr.len);

ret:
	m_freem(mbuf);
	return (error);
}

int
pfkey_attach(struct socket *so, int proto)
{
	int rval;

	if ((so->so_state & SS_PRIV) == 0)
		return EACCES;

	if ((so->so_proto->pr_protocol > PFKEY_PROTOCOL_MAX) ||
	    (so->so_proto->pr_protocol < 0) ||
	    !pfkey_versions[so->so_proto->pr_protocol])
		return (EPROTONOSUPPORT);

	if (!(so->so_pcb = malloc(sizeof(struct rawcb),
	    M_PCB, M_DONTWAIT | M_ZERO)))
		return (ENOMEM);

	rval = raw_attach(so, so->so_proto->pr_protocol);
	if (rval)
		goto ret;

	((struct rawcb *)so->so_pcb)->rcb_faddr = &pfkey_addr;
	soisconnected(so);

	so->so_options |= SO_USELOOPBACK;
	if ((rval =
	    pfkey_versions[so->so_proto->pr_protocol]->create(so)) != 0)
		goto ret;

	return (0);

ret:
	free(so->so_pcb, M_PCB, sizeof(struct rawcb));
	return (rval);
}

static int
pfkey_detach(struct socket *socket, struct proc *p)
{
	int rval, i;

	rval = pfkey_versions[socket->so_proto->pr_protocol]->release(socket);
	i = raw_usrreq(socket, PRU_DETACH, NULL, NULL, NULL, p);

	if (!rval)
		rval = i;

	return (rval);
}

int
pfkey_usrreq(struct socket *socket, int req, struct mbuf *mbuf,
    struct mbuf *nam, struct mbuf *control, struct proc *p)
{
	int rval;

	if ((socket->so_proto->pr_protocol > PFKEY_PROTOCOL_MAX) ||
	    (socket->so_proto->pr_protocol < 0) ||
	    !pfkey_versions[socket->so_proto->pr_protocol])
		return (EPROTONOSUPPORT);

	switch (req) {
	case PRU_DETACH:
		return (pfkey_detach(socket, p));

	default:
		rval = raw_usrreq(socket, req, mbuf, nam, control, p);
	}

	return (rval);
}

struct domain pfkeydomain = {
  .dom_family = PF_KEY,
  .dom_name = "PF_KEY",
  .dom_init = pfkey_init,
};

static struct protosw pfkey_protosw_template = {
  .pr_type	= SOCK_RAW,
  .pr_domain	= &pfkeydomain,
  .pr_protocol	= -1,
  .pr_flags	= PR_ATOMIC | PR_ADDR,
  .pr_output	= pfkey_output,
  .pr_usrreq	= pfkey_usrreq,
  .pr_attach	= pfkey_attach,
};

int
pfkey_buildprotosw(void)
{
	struct protosw *protosw, *p;
	int i, j;

	for (i = j = 0; i <= PFKEY_PROTOCOL_MAX; i++)
		if (pfkey_versions[i])
			j++;

	if (j) {
		if (!(protosw = mallocarray(j, sizeof(struct protosw),
		    M_PFKEY, M_DONTWAIT)))
			return (ENOMEM);

		for (i = 0, p = protosw; i <= PFKEY_PROTOCOL_MAX; i++)
			if (pfkey_versions[i]) {
				bcopy(&pfkey_protosw_template, p,
				    sizeof(struct protosw));
				p->pr_protocol = pfkey_versions[i]->protocol;
				p->pr_sysctl = pfkey_versions[i]->sysctl;
				p++;
			}

		if (pfkeydomain.dom_protosw)
			free(pfkeydomain.dom_protosw, M_PFKEY, 0);

		pfkeydomain.dom_protosw = protosw;
		pfkeydomain.dom_protoswNPROTOSW = p;
	} else {
		if (!(protosw = malloc(sizeof(struct protosw), M_PFKEY,
		    M_DONTWAIT)))
			return (ENOMEM);

		bcopy(&pfkey_protosw_template, protosw,
		    sizeof(struct protosw));

		if (pfkeydomain.dom_protosw)
			free(pfkeydomain.dom_protosw, M_PFKEY, 0);

		pfkeydomain.dom_protosw = protosw;
		pfkeydomain.dom_protoswNPROTOSW = protosw;
	}

	return (0);
}

void
pfkey_init(void)
{
	rn_init(sizeof(struct sockaddr_encap));

	if (pfkey_buildprotosw() != 0)
		return;

	pfkeyv2_init();
}
@


1.39
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.38 2017/03/02 08:58:24 mpi Exp $	*/
d192 2
a193 2
static int
pfkey_attach(struct socket *socket, struct mbuf *proto, struct proc *p)
d197 9
a205 1
	if (!(socket->so_pcb = malloc(sizeof(struct rawcb),
d209 1
a209 1
	rval = raw_usrreq(socket, PRU_ATTACH, NULL, proto, NULL, p);
d213 2
a214 2
	((struct rawcb *)socket->so_pcb)->rcb_faddr = &pfkey_addr;
	soisconnected(socket);
d216 1
a216 1
	socket->so_options |= SO_USELOOPBACK;
d218 1
a218 1
	    pfkey_versions[socket->so_proto->pr_protocol]->create(socket)) != 0)
d224 1
a224 1
	free(socket->so_pcb, M_PCB, sizeof(struct rawcb));
a253 3
	case PRU_ATTACH:
		return (pfkey_attach(socket, nam, p));

d276 2
a277 1
  .pr_usrreq	= pfkey_usrreq
@


1.38
log
@Convert domain declarations to C99 initializers.

ok dhill@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.37 2017/02/22 19:34:42 dhill Exp $	*/
d93 4
a96 4
/* static struct domain pfkeydomain; */
static int pfkey_usrreq(struct socket *socket, int req, struct mbuf *mbuf,
    struct mbuf *nam, struct mbuf *control, struct proc *);
static int pfkey_output(struct mbuf *mbuf, struct socket *socket);
d157 3
a159 2
static int
pfkey_output(struct mbuf *mbuf, struct socket *socket)
d234 1
a234 1
static int
d270 1
a270 1
  .pr_output	= (void *) pfkey_output,
@


1.37
log
@Use c99 struct initialization with protosw.

This makes it easier to grep for a member, such as .pr_usrreq, and know
which functions to review.

ok mpi@@ bluhm@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.36 2017/01/24 10:08:30 krw Exp $	*/
d259 3
a261 7
	PF_KEY,
	"PF_KEY",
	pfkey_init, /* init */
	NULL, /* externalize */
	NULL, /* dispose */
	NULL, /* protosw */
	NULL, /* protoswNPROTOSW */
@


1.36
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.35 2017/01/23 16:31:24 bluhm Exp $	*/
d269 6
a274 14
	SOCK_RAW,
	&pfkeydomain,
	-1, /* protocol */
	PR_ATOMIC | PR_ADDR,
	NULL, /* input */
	(void *) pfkey_output,
	NULL, /* ctlinput */
	NULL, /* ctloutput */
	pfkey_usrreq,
	NULL, /* init */
	NULL, /* fasttimo */
	NULL, /* slowtimo */
	NULL, /* drain */
	NULL	/* sysctl */
@


1.35
log
@The function raw_input() has not been called since netiso has been
removed in 2004.  The comment about raw_input() above rip_input()
was added in 1981, but it is wrong since 1992.  After that it has
been copied to rip6_input().  (*pr_input)() is never called with
the parameters (mbuf, sockproto, sockaddr, sockaddr).
So retire raw_input().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.34 2017/01/13 08:52:09 mpi Exp $	*/
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d17 4
a20 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d24 1
a24 1
 * 
d36 1
a36 1
 * 
@


1.34
log
@Remove recursive splsoftnet() but use splsoftassert() instead.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.33 2016/11/29 10:22:30 jsg Exp $	*/
d273 1
a273 1
	(void *) raw_input,
@


1.33
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.32 2016/11/07 10:04:57 mpi Exp $	*/
d139 2
a140 1
	int s;
a147 1
	s = splsoftnet();
a149 1
		splx(s);
a151 1
	splx(s);
@


1.32
log
@Kill duplicated declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.31 2016/09/05 15:12:30 claudio Exp $	*/
d189 1
a189 2
	if (mbuf)
		m_freem(mbuf);
@


1.31
log
@Kill raw_ctlinput() this function is INCOMPLETE since rev 1.1 and is not
needed. All callers using the protosw pr_ctlinput pointer do a NULL check
before so there is no need to provide the function.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.30 2016/08/15 11:35:25 dlg Exp $	*/
a97 3
int pfkey_register(struct pfkey_version *version);
int pfkey_unregister(struct pfkey_version *version);
int pfkey_sendup(struct socket *socket, struct mbuf *packet, int more);
@


1.30
log
@replace the last uses of m_copym2 with m_dup_pkt.

ok mpi@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.29 2016/03/22 11:53:21 dlg Exp $	*/
d281 1
a281 1
	(void *) raw_ctlinput,
@


1.29
log
@slight knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.28 2015/10/07 10:50:35 mpi Exp $	*/
d145 1
a145 1
		if (!(packet2 = m_copym2(packet, 0, M_COPYALL, M_DONTWAIT)))
@


1.28
log
@Initialize the routing table before domains.

The routing table is not an optional component of the network stack
and initializing it inside the "routing domain" requires some ugly
introspection in the domain interface.

This put the rtable* layer at the same level of the if* level.  These
two subsystem are organized around the two global data structure used
in the network stack:

- the global &ifnet list, to be used in process context only, and
- the routing table which can be read in interrupt context.

This change makes the rtable_* layer domain-aware and extends the
"struct domain" such that INET, INET6 and MPLS can specify the length
of the binary key used in lookups.  This allows us to keep, or move
towards, AF-free route and rtable layers.

While here stop the madness and pass the size of the maximum key length
in *byte* to rn_inithead0().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.27 2015/09/04 08:43:39 mpi Exp $	*/
d148 1
a148 1
	  packet2 = packet;
d193 1
a193 1
		m_freem (mbuf);
@


1.27
log
@Make every subsystem using a radix tree call rn_init() and pass the
length of the key as argument.

This way every consumer of the radix tree has a chance to explicitly
initialize the shared data structures and no longer rely on another
subsystem to do the initialization.

As a bonus ``dom_maxrtkey'' is no longer used an die.

ART kernels should now be fully usable because pf(4) and IPSEC properly
initialized the radix tree.

ok chris@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.26 2015/08/30 10:39:16 mpi Exp $	*/
a271 2
	NULL, /* dom_rtattach */
	16 /* rtoffset */
@


1.26
log
@Use a global table for domains instead of building a list at run time.

As a side effect there's no need to run if_attachdomain() after the
list of domains has been built.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.25 2015/07/17 18:31:08 blambert Exp $	*/
d273 1
a273 2
	16, /* rtoffset */
	sizeof(struct sockaddr_encap)  /* maxrtkey */
d343 2
@


1.25
log
@manage spd entries by using the radix api directly instead of
reaching around through the routing table

original diff by myself, much improved by mikeb@@ and mpi@@

ok and testing mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.24 2014/12/09 07:05:06 doug Exp $	*/
a271 1
	NULL, /* dom_next */
@


1.24
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.23 2014/11/23 07:39:02 deraadt Exp $	*/
d93 1
a93 1
/* static struct domain pfkey_domain; */
d264 1
a264 1
static struct domain pfkey_domain = {
d267 1
a267 1
	NULL, /* init */
d273 1
a273 1
	rn_inithead, /* dom_rtattach */
d280 1
a280 1
	&pfkey_domain,
d319 2
a320 2
		if (pfkey_domain.dom_protosw)
			free(pfkey_domain.dom_protosw, M_PFKEY, 0);
d322 2
a323 2
		pfkey_domain.dom_protosw = protosw;
		pfkey_domain.dom_protoswNPROTOSW = p;
d332 2
a333 2
		if (pfkey_domain.dom_protosw)
			free(pfkey_domain.dom_protosw, M_PFKEY, 0);
d335 2
a336 2
		pfkey_domain.dom_protosw = protosw;
		pfkey_domain.dom_protoswNPROTOSW = protosw;
a347 2
	pfkey_domain.dom_next = domains;
	domains = &pfkey_domain;
@


1.23
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.22 2014/09/08 06:24:13 jsg Exp $	*/
d306 1
a306 1
		if (!(protosw = malloc(j * sizeof(struct protosw),
@


1.22
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.21 2014/07/12 18:44:22 tedu Exp $	*/
d221 1
a221 1
	free(socket->so_pcb, M_PCB, 0);
@


1.21
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.20 2012/11/27 17:29:07 mikeb Exp $	*/
d77 1
a77 1
#include <net/route.h>
@


1.20
log
@remove incorrect splnet usage in pfkey interface
and make raw_usrreq do an splsoftnet on its own;
joint work with david hill, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.19 2012/09/20 10:25:03 blambert Exp $	*/
d221 1
a221 1
	free(socket->so_pcb, M_PCB);
d320 1
a320 1
			free(pfkey_domain.dom_protosw, M_PFKEY);
d333 1
a333 1
			free(pfkey_domain.dom_protosw, M_PFKEY);
@


1.19
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.18 2008/05/23 15:51:12 thib Exp $	*/
a200 1
	int s;
a205 1
	s = splnet();
a206 1
	splx(s);
d228 1
a228 1
	int rval, i, s;
a230 1
	s = splnet();
a231 1
	splx(s);
a243 1
	int s;
a257 1
		s = splnet();
a258 1
		splx(s);
@


1.18
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.17 2007/09/13 21:00:14 hshoexer Exp $	*/
d150 1
a150 1
	s = spltdb();
@


1.17
log
@Convert MALLOC/FREE to malloc/free and use M_ZERO where applicable.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.16 2004/11/26 18:02:22 markus Exp $	*/
d95 1
a95 1
    struct mbuf *nam, struct mbuf *control);
d198 1
a198 1
pfkey_attach(struct socket *socket, struct mbuf *proto)
d208 1
a208 1
	rval = raw_usrreq(socket, PRU_ATTACH, NULL, proto, NULL);
d229 1
a229 1
pfkey_detach(struct socket *socket)
d235 1
a235 1
	i = raw_usrreq(socket, PRU_DETACH, NULL, NULL, NULL);
d246 1
a246 1
    struct mbuf *nam, struct mbuf *control)
d258 1
a258 1
		return (pfkey_attach(socket, nam));
d261 1
a261 1
		return (pfkey_detach(socket));
d265 1
a265 1
		rval = raw_usrreq(socket, req, mbuf, nam, control);
@


1.16
log
@implement net.key.v2.sadb_dump.{unspec,esp,ah,...} sysctl subtree
and use sysctl for 'ipsecadm show'; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.15 2004/08/03 12:10:48 todd Exp $	*/
d204 1
a204 1
	    M_PCB, M_DONTWAIT)))
a205 1
	bzero(socket->so_pcb, sizeof(struct rawcb));
@


1.15
log
@the rest of the '#if DIAGNOSTIC' -> '#ifdef DIAGNOSTIC' in the kernel; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.14 2003/02/16 21:30:13 deraadt Exp $	*/
d324 1
@


1.14
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.13 2003/02/16 19:54:20 jason Exp $	*/
d168 1
a168 1
#if DIAGNOSTIC
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.12 2002/12/11 21:48:40 fgsch Exp $	*/
d257 1
a257 1
	switch(req) {
d306 1
a306 1
{  
@


1.12
log
@Use m_copym2 to copy the whole mbuf (cluster included) and not
incrementing its reference. Fixes a m_zero panic reported by markus@@ when
pfdatatopacket returns a cluster.
Tested by markus@@, jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.10 2001/06/05 02:31:33 deraadt Exp $	*/
d86 2
a87 1
static struct pfkey_version *pfkey_versions[PFKEY_PROTOCOL_MAX+1] = { NULL, NULL, NULL, NULL };
d95 1
a95 1
			struct mbuf *nam, struct mbuf *control);
d102 1
a102 1
static int pfkey_buildprotosw(void);
d107 1
a107 1
  int rval;
d109 3
a111 2
  if ((version->protocol > PFKEY_PROTOCOL_MAX) || (version->protocol < 0))
    return EPROTONOSUPPORT;
d113 2
a114 2
  if (pfkey_versions[version->protocol])
    return EADDRINUSE;
d116 1
a116 1
  pfkey_versions[version->protocol] = version;
d118 4
a121 4
  if ((rval = pfkey_buildprotosw()) != 0) {
    pfkey_versions[version->protocol] = NULL;
    return rval;
  }
d123 1
a123 1
  return 0;
d129 1
a129 1
  int rval;
d131 2
a132 2
  if ((rval = pfkey_buildprotosw()) != 0)
    return rval;
d134 2
a135 2
  pfkey_versions[version->protocol] = NULL;
  return 0;
d141 2
a142 2
  struct mbuf *packet2;
  int s;
d144 13
a156 13
  if (more) {
    if (!(packet2 = m_copym2(packet, 0, M_COPYALL, M_DONTWAIT)))
      return ENOMEM;
  } else
    packet2 = packet;

  s = spltdb();
  if (!sbappendaddr(&socket->so_rcv, &pfkey_addr, packet2, NULL)) {
    m_freem(packet2);
    splx(s);
    return ENOBUFS;
  }
  splx(s);
d158 2
a159 2
  sorwakeup(socket);
  return 0;
d165 2
a166 2
  void *message;
  int error = 0;
d169 4
a172 4
  if (!mbuf || !(mbuf->m_flags & M_PKTHDR)) {
    error = EINVAL;
    goto ret;
  }
d175 20
a194 21
  if (mbuf->m_pkthdr.len > PFKEY_MSG_MAXSZ) {
    error = EMSGSIZE;
    goto ret;
  }

  if (!(message = malloc((unsigned long) mbuf->m_pkthdr.len, M_PFKEY,
			 M_DONTWAIT))) {
    error = ENOMEM;
    goto ret;
  }

  m_copydata(mbuf, 0, mbuf->m_pkthdr.len, message);

  error =
    pfkey_versions[socket->so_proto->pr_protocol]->send(socket, message,
							mbuf->m_pkthdr.len);

 ret:
  if (mbuf)
    m_freem (mbuf);
  return error;
d200 2
a201 2
  int rval;
  int s;
d203 18
a220 17
  if (!(socket->so_pcb = malloc(sizeof(struct rawcb), M_PCB, M_DONTWAIT)))
    return ENOMEM;
  bzero(socket->so_pcb, sizeof(struct rawcb));

  s = splnet();
  rval = raw_usrreq(socket, PRU_ATTACH, NULL, proto, NULL);
  splx(s);
  if (rval)
    goto ret;

  ((struct rawcb *)socket->so_pcb)->rcb_faddr = &pfkey_addr;
  soisconnected(socket);

  socket->so_options |= SO_USELOOPBACK;
  if ((rval = pfkey_versions[socket->so_proto->pr_protocol]->create(socket))
      != 0)
    goto ret;
d222 1
a222 1
  return 0;
d225 2
a226 2
  free(socket->so_pcb, M_PCB);
  return rval;
d232 1
a232 1
  int rval, i, s;
d234 4
a237 4
  rval = pfkey_versions[socket->so_proto->pr_protocol]->release(socket);
  s = splnet();
  i = raw_usrreq(socket, PRU_DETACH, NULL, NULL, NULL);
  splx(s);
d239 2
a240 2
  if (!rval)
    rval = i;
d242 1
a242 1
  return rval;
d247 1
a247 1
	     struct mbuf *nam, struct mbuf *control)
d249 2
a250 2
  int rval;
  int s;
d252 17
a268 17
  if ((socket->so_proto->pr_protocol > PFKEY_PROTOCOL_MAX) ||
      (socket->so_proto->pr_protocol < 0) ||
      !pfkey_versions[socket->so_proto->pr_protocol])
    return EPROTONOSUPPORT;

  switch(req) {
    case PRU_ATTACH:
      return pfkey_attach(socket, nam);

    case PRU_DETACH:
      return pfkey_detach(socket);

    default:
      s = splnet();
      rval = raw_usrreq(socket, req, mbuf, nam, control);
      splx(s);
  }
d270 1
a270 1
  return rval;
d274 11
a284 11
  PF_KEY,
  "PF_KEY",
  NULL, /* init */
  NULL, /* externalize */
  NULL, /* dispose */
  NULL, /* protosw */
  NULL, /* protoswNPROTOSW */
  NULL, /* dom_next */
  rn_inithead, /* dom_rtattach */
  16, /* rtoffset */
  sizeof(struct sockaddr_encap)  /* maxrtkey */
d288 14
a301 14
  SOCK_RAW,
  &pfkey_domain,
  -1, /* protocol */
  PR_ATOMIC | PR_ADDR,
  (void *) raw_input,
  (void *) pfkey_output,
  (void *) raw_ctlinput,
  NULL, /* ctloutput */
  pfkey_usrreq,
  NULL, /* init */
  NULL, /* fasttimo */
  NULL, /* slowtimo */
  NULL, /* drain */
  NULL	/* sysctl */
d304 1
a304 1
static int
d307 2
a308 2
  struct protosw *protosw, *p;
  int i, j;
d310 36
a345 32
  for (i = j = 0; i <= PFKEY_PROTOCOL_MAX; i++)
    if (pfkey_versions[i])
      j++;

  if (j) {
    if (!(protosw = malloc(j * sizeof(struct protosw), M_PFKEY, M_DONTWAIT)))
      return ENOMEM;

    for (i = 0, p = protosw; i <= PFKEY_PROTOCOL_MAX; i++)
      if (pfkey_versions[i]) {
	bcopy(&pfkey_protosw_template, p, sizeof(struct protosw));
	p->pr_protocol = pfkey_versions[i]->protocol;
	p++;
      }

    if (pfkey_domain.dom_protosw)
      free(pfkey_domain.dom_protosw, M_PFKEY);

    pfkey_domain.dom_protosw = protosw;
    pfkey_domain.dom_protoswNPROTOSW = p;
  } else  {
    if (!(protosw = malloc(sizeof(struct protosw), M_PFKEY, M_DONTWAIT)))
      return ENOMEM;

    bcopy(&pfkey_protosw_template, protosw, sizeof(struct protosw));

    if (pfkey_domain.dom_protosw)
      free(pfkey_domain.dom_protosw, M_PFKEY);

    pfkey_domain.dom_protosw = protosw;
    pfkey_domain.dom_protoswNPROTOSW = protosw;
  }
d347 1
a347 1
  return 0;
d350 2
a351 1
void pfkey_init(void)
d353 2
a354 2
  if (pfkey_buildprotosw() != 0)
    return;
d356 3
a358 3
  pfkey_domain.dom_next = domains;
  domains = &pfkey_domain;
  pfkeyv2_init();
@


1.11
log
@Yet more include file cleanup.
@
text
@d143 1
a143 1
    if (!(packet2 = m_copym(packet, 0, M_COPYALL, M_DONTWAIT)))
@


1.11.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
a86 2
static struct pfkey_version *pfkey_versions[PFKEY_PROTOCOL_MAX+1] =
    { NULL, NULL, NULL, NULL };
d94 1
a94 1
    struct mbuf *nam, struct mbuf *control);
d101 1
a101 1
int pfkey_buildprotosw(void);
d106 1
a106 1
	int rval;
d108 2
a109 3
	if ((version->protocol > PFKEY_PROTOCOL_MAX) ||
	    (version->protocol < 0))
		return (EPROTONOSUPPORT);
d111 2
a112 2
	if (pfkey_versions[version->protocol])
		return (EADDRINUSE);
d114 1
a114 1
	pfkey_versions[version->protocol] = version;
d116 4
a119 4
	if ((rval = pfkey_buildprotosw()) != 0) {
		pfkey_versions[version->protocol] = NULL;
		return (rval);
	}
d121 1
a121 1
	return (0);
d127 1
a127 1
	int rval;
d129 2
a130 2
	if ((rval = pfkey_buildprotosw()) != 0)
		return (rval);
d132 2
a133 2
	pfkey_versions[version->protocol] = NULL;
	return (0);
d139 2
a140 2
	struct mbuf *packet2;
	int s;
d142 13
a154 13
	if (more) {
		if (!(packet2 = m_copym2(packet, 0, M_COPYALL, M_DONTWAIT)))
			return (ENOMEM);
	} else
	  packet2 = packet;

	s = spltdb();
	if (!sbappendaddr(&socket->so_rcv, &pfkey_addr, packet2, NULL)) {
		m_freem(packet2);
		splx(s);
		return (ENOBUFS);
	}
	splx(s);
d156 2
a157 2
	sorwakeup(socket);
	return (0);
d163 2
a164 2
	void *message;
	int error = 0;
d167 4
a170 4
	if (!mbuf || !(mbuf->m_flags & M_PKTHDR)) {
		error = EINVAL;
		goto ret;
	}
d173 21
a193 20
	if (mbuf->m_pkthdr.len > PFKEY_MSG_MAXSZ) {
		error = EMSGSIZE;
		goto ret;
	}

	if (!(message = malloc((unsigned long) mbuf->m_pkthdr.len,
	    M_PFKEY, M_DONTWAIT))) {
		error = ENOMEM;
		goto ret;
	}

	m_copydata(mbuf, 0, mbuf->m_pkthdr.len, message);

	error = pfkey_versions[socket->so_proto->pr_protocol]->send(socket,
	    message, mbuf->m_pkthdr.len);

ret:
	if (mbuf)
		m_freem (mbuf);
	return (error);
d199 2
a200 2
	int rval;
	int s;
d202 17
a218 18
	if (!(socket->so_pcb = malloc(sizeof(struct rawcb),
	    M_PCB, M_DONTWAIT)))
		return (ENOMEM);
	bzero(socket->so_pcb, sizeof(struct rawcb));

	s = splnet();
	rval = raw_usrreq(socket, PRU_ATTACH, NULL, proto, NULL);
	splx(s);
	if (rval)
		goto ret;

	((struct rawcb *)socket->so_pcb)->rcb_faddr = &pfkey_addr;
	soisconnected(socket);

	socket->so_options |= SO_USELOOPBACK;
	if ((rval =
	    pfkey_versions[socket->so_proto->pr_protocol]->create(socket)) != 0)
		goto ret;
d220 1
a220 1
	return (0);
d223 2
a224 2
	free(socket->so_pcb, M_PCB);
	return (rval);
d230 1
a230 1
	int rval, i, s;
d232 4
a235 4
	rval = pfkey_versions[socket->so_proto->pr_protocol]->release(socket);
	s = splnet();
	i = raw_usrreq(socket, PRU_DETACH, NULL, NULL, NULL);
	splx(s);
d237 2
a238 2
	if (!rval)
		rval = i;
d240 1
a240 1
	return (rval);
d245 1
a245 1
    struct mbuf *nam, struct mbuf *control)
d247 2
a248 2
	int rval;
	int s;
d250 17
a266 17
	if ((socket->so_proto->pr_protocol > PFKEY_PROTOCOL_MAX) ||
	    (socket->so_proto->pr_protocol < 0) ||
	    !pfkey_versions[socket->so_proto->pr_protocol])
		return (EPROTONOSUPPORT);

	switch (req) {
	case PRU_ATTACH:
		return (pfkey_attach(socket, nam));

	case PRU_DETACH:
		return (pfkey_detach(socket));

	default:
		s = splnet();
		rval = raw_usrreq(socket, req, mbuf, nam, control);
		splx(s);
	}
d268 1
a268 1
	return (rval);
d272 11
a282 11
	PF_KEY,
	"PF_KEY",
	NULL, /* init */
	NULL, /* externalize */
	NULL, /* dispose */
	NULL, /* protosw */
	NULL, /* protoswNPROTOSW */
	NULL, /* dom_next */
	rn_inithead, /* dom_rtattach */
	16, /* rtoffset */
	sizeof(struct sockaddr_encap)  /* maxrtkey */
d286 14
a299 14
	SOCK_RAW,
	&pfkey_domain,
	-1, /* protocol */
	PR_ATOMIC | PR_ADDR,
	(void *) raw_input,
	(void *) pfkey_output,
	(void *) raw_ctlinput,
	NULL, /* ctloutput */
	pfkey_usrreq,
	NULL, /* init */
	NULL, /* fasttimo */
	NULL, /* slowtimo */
	NULL, /* drain */
	NULL	/* sysctl */
d302 1
a302 1
int
d304 36
a339 40
{
	struct protosw *protosw, *p;
	int i, j;

	for (i = j = 0; i <= PFKEY_PROTOCOL_MAX; i++)
		if (pfkey_versions[i])
			j++;

	if (j) {
		if (!(protosw = malloc(j * sizeof(struct protosw),
		    M_PFKEY, M_DONTWAIT)))
			return (ENOMEM);

		for (i = 0, p = protosw; i <= PFKEY_PROTOCOL_MAX; i++)
			if (pfkey_versions[i]) {
				bcopy(&pfkey_protosw_template, p,
				    sizeof(struct protosw));
				p->pr_protocol = pfkey_versions[i]->protocol;
				p++;
			}

		if (pfkey_domain.dom_protosw)
			free(pfkey_domain.dom_protosw, M_PFKEY);

		pfkey_domain.dom_protosw = protosw;
		pfkey_domain.dom_protoswNPROTOSW = p;
	} else {
		if (!(protosw = malloc(sizeof(struct protosw), M_PFKEY,
		    M_DONTWAIT)))
			return (ENOMEM);

		bcopy(&pfkey_protosw_template, protosw,
		    sizeof(struct protosw));

		if (pfkey_domain.dom_protosw)
			free(pfkey_domain.dom_protosw, M_PFKEY);

		pfkey_domain.dom_protosw = protosw;
		pfkey_domain.dom_protoswNPROTOSW = protosw;
	}
d341 1
a341 1
	return (0);
d344 1
a344 2
void
pfkey_init(void)
d346 2
a347 2
	if (pfkey_buildprotosw() != 0)
		return;
d349 3
a351 3
	pfkey_domain.dom_next = domains;
	domains = &pfkey_domain;
	pfkeyv2_init();
@


1.10
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 1
a74 1
#include <sys/systm.h>
a75 2
#include <sys/kernel.h>
#include <sys/malloc.h>
a76 1
#include <sys/proc.h>
a77 1
#include <netinet/in.h>
a83 1
#include <netinet/ip_ipsp.h>
@


1.9
log
@SPD-driven IPsec.
@
text
@d1 2
d4 38
a41 8
%%% copyright-nrl-97
This software is Copyright 1997-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
d43 27
a69 7
%%% copyright-cmetz-97
This software is Copyright 1997-1998 by Craig Metz, All Rights Reserved.
The Inner Net License Version 2 applies to this software.
You should have received a copy of the license with this software. If
you didn't get a copy, you may request one from <license@@inner.net>.

*/
@


1.8
log
@Major style cleanup for pfkeyv2.c
@
text
@d30 1
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@a29 1
#include <netinet/ip_ipsp.h>
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 9
a9 1
/*	$OpenBSD$	*/
d11 5
a15 39
/*
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d17 1
a17 27
/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Craig Metz. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
d21 1
a22 1
#include <sys/socket.h>
d24 2
d27 1
d29 1
d36 1
@


1.8.2.3
log
@Sync the SMP branch with 3.3
@
text
@d86 1
a86 2
static struct pfkey_version *pfkey_versions[PFKEY_PROTOCOL_MAX+1] =
    { NULL, NULL, NULL, NULL };
d94 1
a94 1
    struct mbuf *nam, struct mbuf *control);
d101 1
a101 1
int pfkey_buildprotosw(void);
d106 1
a106 1
	int rval;
d108 2
a109 3
	if ((version->protocol > PFKEY_PROTOCOL_MAX) ||
	    (version->protocol < 0))
		return (EPROTONOSUPPORT);
d111 2
a112 2
	if (pfkey_versions[version->protocol])
		return (EADDRINUSE);
d114 1
a114 1
	pfkey_versions[version->protocol] = version;
d116 4
a119 4
	if ((rval = pfkey_buildprotosw()) != 0) {
		pfkey_versions[version->protocol] = NULL;
		return (rval);
	}
d121 1
a121 1
	return (0);
d127 1
a127 1
	int rval;
d129 2
a130 2
	if ((rval = pfkey_buildprotosw()) != 0)
		return (rval);
d132 2
a133 2
	pfkey_versions[version->protocol] = NULL;
	return (0);
d139 2
a140 2
	struct mbuf *packet2;
	int s;
d142 13
a154 13
	if (more) {
		if (!(packet2 = m_copym2(packet, 0, M_COPYALL, M_DONTWAIT)))
			return (ENOMEM);
	} else
	  packet2 = packet;

	s = spltdb();
	if (!sbappendaddr(&socket->so_rcv, &pfkey_addr, packet2, NULL)) {
		m_freem(packet2);
		splx(s);
		return (ENOBUFS);
	}
	splx(s);
d156 2
a157 2
	sorwakeup(socket);
	return (0);
d163 2
a164 2
	void *message;
	int error = 0;
d167 4
a170 4
	if (!mbuf || !(mbuf->m_flags & M_PKTHDR)) {
		error = EINVAL;
		goto ret;
	}
d173 21
a193 20
	if (mbuf->m_pkthdr.len > PFKEY_MSG_MAXSZ) {
		error = EMSGSIZE;
		goto ret;
	}

	if (!(message = malloc((unsigned long) mbuf->m_pkthdr.len,
	    M_PFKEY, M_DONTWAIT))) {
		error = ENOMEM;
		goto ret;
	}

	m_copydata(mbuf, 0, mbuf->m_pkthdr.len, message);

	error = pfkey_versions[socket->so_proto->pr_protocol]->send(socket,
	    message, mbuf->m_pkthdr.len);

ret:
	if (mbuf)
		m_freem (mbuf);
	return (error);
d199 2
a200 2
	int rval;
	int s;
d202 17
a218 18
	if (!(socket->so_pcb = malloc(sizeof(struct rawcb),
	    M_PCB, M_DONTWAIT)))
		return (ENOMEM);
	bzero(socket->so_pcb, sizeof(struct rawcb));

	s = splnet();
	rval = raw_usrreq(socket, PRU_ATTACH, NULL, proto, NULL);
	splx(s);
	if (rval)
		goto ret;

	((struct rawcb *)socket->so_pcb)->rcb_faddr = &pfkey_addr;
	soisconnected(socket);

	socket->so_options |= SO_USELOOPBACK;
	if ((rval =
	    pfkey_versions[socket->so_proto->pr_protocol]->create(socket)) != 0)
		goto ret;
d220 1
a220 1
	return (0);
d223 2
a224 2
	free(socket->so_pcb, M_PCB);
	return (rval);
d230 1
a230 1
	int rval, i, s;
d232 4
a235 4
	rval = pfkey_versions[socket->so_proto->pr_protocol]->release(socket);
	s = splnet();
	i = raw_usrreq(socket, PRU_DETACH, NULL, NULL, NULL);
	splx(s);
d237 2
a238 2
	if (!rval)
		rval = i;
d240 1
a240 1
	return (rval);
d245 1
a245 1
    struct mbuf *nam, struct mbuf *control)
d247 2
a248 2
	int rval;
	int s;
d250 17
a266 17
	if ((socket->so_proto->pr_protocol > PFKEY_PROTOCOL_MAX) ||
	    (socket->so_proto->pr_protocol < 0) ||
	    !pfkey_versions[socket->so_proto->pr_protocol])
		return (EPROTONOSUPPORT);

	switch (req) {
	case PRU_ATTACH:
		return (pfkey_attach(socket, nam));

	case PRU_DETACH:
		return (pfkey_detach(socket));

	default:
		s = splnet();
		rval = raw_usrreq(socket, req, mbuf, nam, control);
		splx(s);
	}
d268 1
a268 1
	return (rval);
d272 11
a282 11
	PF_KEY,
	"PF_KEY",
	NULL, /* init */
	NULL, /* externalize */
	NULL, /* dispose */
	NULL, /* protosw */
	NULL, /* protoswNPROTOSW */
	NULL, /* dom_next */
	rn_inithead, /* dom_rtattach */
	16, /* rtoffset */
	sizeof(struct sockaddr_encap)  /* maxrtkey */
d286 14
a299 14
	SOCK_RAW,
	&pfkey_domain,
	-1, /* protocol */
	PR_ATOMIC | PR_ADDR,
	(void *) raw_input,
	(void *) pfkey_output,
	(void *) raw_ctlinput,
	NULL, /* ctloutput */
	pfkey_usrreq,
	NULL, /* init */
	NULL, /* fasttimo */
	NULL, /* slowtimo */
	NULL, /* drain */
	NULL	/* sysctl */
d302 1
a302 1
int
d304 36
a339 40
{
	struct protosw *protosw, *p;
	int i, j;

	for (i = j = 0; i <= PFKEY_PROTOCOL_MAX; i++)
		if (pfkey_versions[i])
			j++;

	if (j) {
		if (!(protosw = malloc(j * sizeof(struct protosw),
		    M_PFKEY, M_DONTWAIT)))
			return (ENOMEM);

		for (i = 0, p = protosw; i <= PFKEY_PROTOCOL_MAX; i++)
			if (pfkey_versions[i]) {
				bcopy(&pfkey_protosw_template, p,
				    sizeof(struct protosw));
				p->pr_protocol = pfkey_versions[i]->protocol;
				p++;
			}

		if (pfkey_domain.dom_protosw)
			free(pfkey_domain.dom_protosw, M_PFKEY);

		pfkey_domain.dom_protosw = protosw;
		pfkey_domain.dom_protoswNPROTOSW = p;
	} else {
		if (!(protosw = malloc(sizeof(struct protosw), M_PFKEY,
		    M_DONTWAIT)))
			return (ENOMEM);

		bcopy(&pfkey_protosw_template, protosw,
		    sizeof(struct protosw));

		if (pfkey_domain.dom_protosw)
			free(pfkey_domain.dom_protosw, M_PFKEY);

		pfkey_domain.dom_protosw = protosw;
		pfkey_domain.dom_protoswNPROTOSW = protosw;
	}
d341 1
a341 1
	return (0);
d344 1
a344 2
void
pfkey_init(void)
d346 2
a347 2
	if (pfkey_buildprotosw() != 0)
		return;
d349 3
a351 3
	pfkey_domain.dom_next = domains;
	domains = &pfkey_domain;
	pfkeyv2_init();
@


1.7
log
@Introduce M_PFKEY kmem type, and use it. (angelos@@ ok)
@
text
@a36 7
struct pfkey_version {
  int protocol;
  int (*create)(struct socket *socket);
  int (*release)(struct socket *socket);
  int (*send)(struct socket *socket, void *message, int len);
};

a51 1
int pfkeyv2_init(void);
@


1.6
log
@For hard expiration-pressure you need to protect PF_KEY socket
queueing with spltdb()
@
text
@d138 1
a138 1
  if (!(message = malloc((unsigned long) mbuf->m_pkthdr.len, M_TEMP,
d273 1
a273 1
    if (!(protosw = malloc(j * sizeof(struct protosw), M_TEMP, M_DONTWAIT)))
d284 1
a284 1
      free(pfkey_domain.dom_protosw, M_TEMP);
d289 1
a289 1
    if (!(protosw = malloc(sizeof(struct protosw), M_TEMP, M_DONTWAIT)))
d295 1
a295 1
      free(pfkey_domain.dom_protosw, M_TEMP);
@


1.5
log
@Plug mbuf leak
@
text
@d100 1
d108 1
d111 2
a112 1
    return 0;
d114 1
@


1.4
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d120 1
d123 4
a126 2
  if (!mbuf || !(mbuf->m_flags & M_PKTHDR)) 
    return EINVAL;
d129 4
a132 2
  if (mbuf->m_pkthdr.len > PFKEY_MSG_MAXSZ)
    return EMSGSIZE;
d135 4
a138 2
			 M_DONTWAIT)))
    return ENOMEM;
d142 8
a149 1
  return pfkey_versions[socket->so_proto->pr_protocol]->send(socket, message, mbuf->m_pkthdr.len);
@


1.3
log
@Unnecessary ifdef
@
text
@a34 1
#include <sys/sysctl.h>
a36 3
int pfkey_sysctl(int *, u_int, void *, size_t *, void *, size_t);
extern int encdebug;

d241 1
a241 1
  pfkey_sysctl,
a242 20

/* XXX fix this so it's reachable */
int
pfkey_sysctl(int *name, u_int namelen, void *oldp, size_t *oldplenp, 
	     void *newp, size_t newlen)
{
    /* All sysctl names at this level are terminal */
    if (namelen != 1)
      return ENOTDIR;

    switch (name[0]) 
    {
        case PFKEYCTL_ENCDEBUG:
	    return (sysctl_int(oldp, oldplenp, newp, newlen, &encdebug));
	    
	default:
	    return ENOPROTOOPT;
    }
    /* Not reached */
}
@


1.2
log
@Removed osdep.h dependencies.
@
text
@a31 1

a316 2

#if KEY || CONFIG_PFKEY_V2
a317 1
#endif /* KEY || CONFIG_PFKEY_V2 */
@


1.1
log
@PF_KEY_V2, with local extensions for SPD management.
@
text
@d18 15
a32 1
#include <sys/osdep.h>
d74 1
a74 1
    return OSDEP_ERROR(EPROTONOSUPPORT);
d77 1
a77 1
    return OSDEP_ERROR(EADDRINUSE);
@

