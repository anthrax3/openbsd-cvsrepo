head	1.29;
access;
symbols
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.29
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.28;
commitid	6c6qq5OdS4VVnyVM;

1.28
date	2015.11.24.15.17.26;	author mpi;	state Exp;
branches;
next	1.27;
commitid	zxKVQDKR6YlbQfa6;

1.27
date	2015.11.24.13.37.16;	author mpi;	state Exp;
branches;
next	1.26;
commitid	djjKhPvMtRdFfuFJ;

1.26
date	2015.10.05.13.00.04;	author mikeb;	state Exp;
branches;
next	1.25;
commitid	49G7IYOLbXQgQ7Cs;

1.25
date	2015.09.24.14.01.20;	author mikeb;	state Exp;
branches;
next	1.24;
commitid	DHugk9hjYm6Xthvw;

1.24
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.23;
commitid	fE8TgA9vpwdUU5Wy;

1.23
date	2015.06.10.09.20.21;	author mpi;	state Exp;
branches;
next	1.22;
commitid	Zu3FROuEB5aVwuow;

1.22
date	2015.06.09.14.50.14;	author mpi;	state Exp;
branches;
next	1.21;
commitid	hzPq5pFo63wV6Ehi;

1.21
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.20;
commitid	1aiWjheMGhmTuiHL;

1.20
date	2015.05.11.08.41.43;	author mpi;	state Exp;
branches;
next	1.19;
commitid	clvzRlWWi271kseu;

1.19
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.18;
commitid	p4LJxGKbi0BU2cG6;

1.18
date	2014.12.04.00.01.53;	author tedu;	state Exp;
branches;
next	1.17;
commitid	wP6d1LFSgXabDbTH;

1.17
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	mdGXHklUZmESVFlY;

1.16
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.15;
commitid	Z1vcFtHO8wRH0yRt;

1.15
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.14;
commitid	B4dZSbxas1X1IpXI;

1.14
date	2012.12.05.23.20.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.09.04.38.03;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.17.13.17.55;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.09.15.01.18;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.31.09.21.13;	author blambert;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.01.10.40.57;	author brad;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2008.11.08.01.00.01;	author mpf;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.24.04.44.52;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.12.19.03.12;	author mpf;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.28.11.10.25;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.06.17.04.28;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.19.00.57;	author mpf;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.15.06.56.09;	author mpf;	state Exp;
branches;
next	;

1.9.6.1
date	2010.05.14.11.54.14;	author stephan;	state Exp;
branches;
next	;


desc
@@


1.29
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: trunklacp.c,v 1.28 2015/11/24 15:17:26 mpi Exp $ */
/*	$NetBSD: ieee8023ad_lacp.c,v 1.3 2005/12/11 12:24:54 christos Exp $ */
/*	$FreeBSD:ieee8023ad_lacp.c,v 1.15 2008/03/16 19:25:30 thompsa Exp $ */

/*
 * Copyright (c)2005 YAMAMOTO Takashi,
 * Copyright (c)2008 Andrew Thompson <thompsa@@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/lock.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/task.h>
#include <sys/timeout.h>

#include <crypto/siphash.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_trunk.h>
#include <net/trunklacp.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

/*
 * actor system priority and port priority.
 * XXX should be configurable.
 */
#define	LACP_SYSTEM_PRIO	0x8000
#define	LACP_PORT_PRIO		0x8000
#define	LACP_IFQ_PRIO		6

const u_int8_t ethermulticastaddr_slowprotocols[ETHER_ADDR_LEN] =
    { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x02 };

const struct tlv_template lacp_info_tlv_template[] = {
	{ LACP_TYPE_ACTORINFO,
	    sizeof(struct tlvhdr) + sizeof(struct lacp_peerinfo) },
	{ LACP_TYPE_PARTNERINFO,
	    sizeof(struct tlvhdr) + sizeof(struct lacp_peerinfo) },
	{ LACP_TYPE_COLLECTORINFO,
	    sizeof(struct tlvhdr) + sizeof(struct lacp_collectorinfo) },
	{ 0, 0 },
};

const struct tlv_template marker_info_tlv_template[] = {
	{ MARKER_TYPE_INFO,
	    sizeof(struct tlvhdr) + sizeof(struct lacp_markerinfo) },
	{ 0, 0 },
};

const struct tlv_template marker_response_tlv_template[] = {
	{ MARKER_TYPE_RESPONSE,
	    sizeof(struct tlvhdr) + sizeof(struct lacp_markerinfo) },
	{ 0, 0 },
};

typedef void (*lacp_timer_func_t)(struct lacp_port *);

void		lacp_fill_actorinfo(struct lacp_port *, struct lacp_peerinfo *);
void		lacp_fill_markerinfo(struct lacp_port *,
		    struct lacp_markerinfo *);

u_int64_t	lacp_aggregator_bandwidth(struct lacp_aggregator *);
void		lacp_suppress_distributing(struct lacp_softc *,
		    struct lacp_aggregator *);
void		lacp_transit_expire(void *);
void		lacp_update_portmap(struct lacp_softc *);
void		lacp_select_active_aggregator(struct lacp_softc *);
u_int16_t	lacp_compose_key(struct lacp_port *);
int		tlv_check(const void *, size_t, const struct tlvhdr *,
		    const struct tlv_template *, int);
void		lacp_tick(void *);

void		lacp_fill_aggregator_id(struct lacp_aggregator *,
		    const struct lacp_port *);
void		lacp_fill_aggregator_id_peer(struct lacp_peerinfo *,
		    const struct lacp_peerinfo *);
int		lacp_aggregator_is_compatible(const struct lacp_aggregator *,
		    const struct lacp_port *);
int		lacp_peerinfo_is_compatible(const struct lacp_peerinfo *,
		    const struct lacp_peerinfo *);

struct lacp_aggregator *lacp_aggregator_get(struct lacp_softc *,
		    struct lacp_port *);
void		lacp_aggregator_addref(struct lacp_softc *,
		    struct lacp_aggregator *);
void		lacp_aggregator_delref(struct lacp_softc *,
		    struct lacp_aggregator *);

/* receive machine */

void		lacp_input_process(void *);
int		lacp_pdu_input(struct lacp_port *, struct mbuf *);
int		lacp_marker_input(struct lacp_port *, struct mbuf *);
void		lacp_sm_rx(struct lacp_port *, const struct lacpdu *);
void		lacp_sm_rx_timer(struct lacp_port *);
void		lacp_sm_rx_set_expired(struct lacp_port *);
void		lacp_sm_rx_update_ntt(struct lacp_port *,
		    const struct lacpdu *);
void		lacp_sm_rx_record_pdu(struct lacp_port *,
		    const struct lacpdu *);
void		lacp_sm_rx_update_selected(struct lacp_port *,
		    const struct lacpdu *);
void		lacp_sm_rx_record_default(struct lacp_port *);
void		lacp_sm_rx_update_default_selected(struct lacp_port *);
void		lacp_sm_rx_update_selected_from_peerinfo(struct lacp_port *,
		    const struct lacp_peerinfo *);

/* mux machine */

void		lacp_sm_mux(struct lacp_port *);
void		lacp_set_mux(struct lacp_port *, enum lacp_mux_state);
void		lacp_sm_mux_timer(struct lacp_port *);

/* periodic transmit machine */

void		lacp_sm_ptx_update_timeout(struct lacp_port *, u_int8_t);
void		lacp_sm_ptx_tx_schedule(struct lacp_port *);
void		lacp_sm_ptx_timer(struct lacp_port *);

/* transmit machine */

void		lacp_sm_tx(struct lacp_port *);
void		lacp_sm_assert_ntt(struct lacp_port *);

void		lacp_run_timers(struct lacp_port *);
int		lacp_compare_peerinfo(const struct lacp_peerinfo *,
		    const struct lacp_peerinfo *);
int		lacp_compare_systemid(const struct lacp_systemid *,
		    const struct lacp_systemid *);
void		lacp_port_enable(struct lacp_port *);
void		lacp_port_disable(struct lacp_port *);
void		lacp_select(struct lacp_port *);
void		lacp_unselect(struct lacp_port *);
void		lacp_disable_collecting(struct lacp_port *);
void		lacp_enable_collecting(struct lacp_port *);
void		lacp_disable_distributing(struct lacp_port *);
void		lacp_enable_distributing(struct lacp_port *);
int		lacp_xmit_lacpdu(struct lacp_port *);
int		lacp_xmit_marker(struct lacp_port *);

#if defined(LACP_DEBUG)
void		lacp_dump_lacpdu(const struct lacpdu *);
const char	*lacp_format_partner(const struct lacp_peerinfo *, char *,
		    size_t);
const char	*lacp_format_lagid(const struct lacp_peerinfo *,
		    const struct lacp_peerinfo *, char *, size_t);
const char	*lacp_format_lagid_aggregator(const struct lacp_aggregator *,
		    char *, size_t);
const char	*lacp_format_state(u_int8_t, char *, size_t);
const char	*lacp_format_mac(const u_int8_t *, char *, size_t);
const char	*lacp_format_systemid(const struct lacp_systemid *, char *,
		    size_t);
const char	*lacp_format_portid(const struct lacp_portid *, char *,
		    size_t);
void		lacp_dprintf(const struct lacp_port *, const char *, ...)
		    __attribute__((__format__(__printf__, 2, 3)));
#define	LACP_DPRINTF(a)	lacp_dprintf a
#else
#define LACP_DPRINTF(a) /* nothing */
#endif

/*
 * partner administration variables.
 * XXX should be configurable.
 */

const struct lacp_peerinfo lacp_partner_admin = {
	{ 0xffff },	/* lip_systemid.lsi_prio */
	0,		/* lip_key */
	{ 0xffff },	/* lip_portid.lpi_prio */
#if 1
	/* optimistic lip_state */
	LACP_STATE_SYNC | LACP_STATE_AGGREGATION |
	    LACP_STATE_COLLECTING | LACP_STATE_DISTRIBUTING
#else
	/* pessimistic lip_state */
	0
#endif
};

const lacp_timer_func_t lacp_timer_funcs[LACP_NTIMER] = {
	[LACP_TIMER_CURRENT_WHILE] = lacp_sm_rx_timer,
	[LACP_TIMER_PERIODIC] = lacp_sm_ptx_timer,
	[LACP_TIMER_WAIT_WHILE] = lacp_sm_mux_timer,
};

int
lacp_input(struct trunk_port *tp, struct mbuf *m)
{
	struct lacp_port *lp = LACP_PORT(tp);
	struct lacp_softc *lsc = lp->lp_lsc;
	struct lacp_aggregator *la = lp->lp_aggregator;
	struct ether_header *eh;
	u_int8_t subtype;

	eh = mtod(m, struct ether_header *);

	if (ntohs(eh->ether_type) == ETHERTYPE_SLOW) {
#if NBPFILTER > 0
		if (tp->tp_if->if_bpf)
			bpf_mtap_ether(tp->tp_if->if_bpf, m, BPF_DIRECTION_IN);
#endif

		if (m->m_pkthdr.len < (sizeof(*eh) + sizeof(subtype)))
			return (-1);

		m_copydata(m, sizeof(*eh), sizeof(subtype), &subtype);
		switch (subtype) {
		case SLOWPROTOCOLS_SUBTYPE_LACP:
		case SLOWPROTOCOLS_SUBTYPE_MARKER:
			mq_enqueue(&lp->lp_mq, m);
			task_add(systq, &lsc->lsc_input);
			return (1);
		}
	}

	/*
	 * If the port is not collecting or not in the active aggregator then
	 * free and return.
	 */
	/* This port is joined to the active aggregator */
	if ((lp->lp_state & LACP_STATE_COLLECTING) == 0 ||
	    la == NULL || la != lsc->lsc_active_aggregator) {
		m_freem(m);
		return (-1);
	}

	/* Not a subtype we are interested in */
	return (0);
}

void
lacp_input_process(void *arg)
{
	struct lacp_softc *lsc = arg;
	struct lacp_port *lp;
	struct mbuf *m;
	u_int8_t subtype;

	LIST_FOREACH(lp, &lsc->lsc_ports, lp_next) {
		while ((m = mq_dequeue(&lp->lp_mq)) != NULL) {
			m_copydata(m, sizeof(struct ether_header),
			    sizeof(subtype), &subtype);

			switch (subtype) {
			case SLOWPROTOCOLS_SUBTYPE_LACP:
				lacp_pdu_input(lp, m);
				break;

			case SLOWPROTOCOLS_SUBTYPE_MARKER:
				lacp_marker_input(lp, m);
				break;
			}
		}
	}
}

/*
 * lacp_pdu_input: process lacpdu
 */
int
lacp_pdu_input(struct lacp_port *lp, struct mbuf *m)
{
	struct lacpdu *du;
	int error = 0;

	if (m->m_pkthdr.len != sizeof(*du))
		goto bad;

	if (m->m_len < sizeof(*du)) {
		m = m_pullup(m, sizeof(*du));
		if (m == NULL)
			return (ENOMEM);
	}
	du = mtod(m, struct lacpdu *);

	if (memcmp(&du->ldu_eh.ether_dhost,
	    &ethermulticastaddr_slowprotocols, ETHER_ADDR_LEN))
		goto bad;

	/*
	 * ignore the version for compatibility with
	 * the future protocol revisions.
	 */
#if 0
	if (du->ldu_sph.sph_version != 1)
		goto bad;
#endif

	/*
	 * ignore tlv types for compatibility with the
	 * future protocol revisions. (IEEE 802.3-2005 43.4.12)
	 */
	if (tlv_check(du, sizeof(*du), &du->ldu_tlv_actor,
	    lacp_info_tlv_template, 0))
		goto bad;

#if defined(LACP_DEBUG)
	LACP_DPRINTF((lp, "lacpdu receive\n"));
	lacp_dump_lacpdu(du);
#endif /* defined(LACP_DEBUG) */

	lacp_sm_rx(lp, du);

	m_freem(m);
	return (error);

bad:
	m_freem(m);
	return (EINVAL);
}

void
lacp_fill_actorinfo(struct lacp_port *lp, struct lacp_peerinfo *info)
{
	struct trunk_port *tp = lp->lp_trunk;
	struct trunk_softc *sc = tp->tp_trunk;

	info->lip_systemid.lsi_prio = htons(LACP_SYSTEM_PRIO);
	memcpy(&info->lip_systemid.lsi_mac,
	    sc->tr_ac.ac_enaddr, ETHER_ADDR_LEN);
	info->lip_portid.lpi_prio = htons(LACP_PORT_PRIO);
	info->lip_portid.lpi_portno = htons(lp->lp_ifp->if_index);
	info->lip_state = lp->lp_state;
}

void
lacp_fill_markerinfo(struct lacp_port *lp, struct lacp_markerinfo *info)
{
	struct ifnet *ifp = lp->lp_ifp;

	/* Fill in the port index and system id (encoded as the MAC) */
	info->mi_rq_port = htons(ifp->if_index);
	memcpy(&info->mi_rq_system, lp->lp_systemid.lsi_mac, ETHER_ADDR_LEN);
	info->mi_rq_xid = htonl(0);
}

int
lacp_xmit_lacpdu(struct lacp_port *lp)
{
	struct trunk_port *tp = lp->lp_trunk;
	struct mbuf *m;
	struct lacpdu *du;
	int error;

	m = m_gethdr(M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOMEM);
	m->m_len = m->m_pkthdr.len = sizeof(*du);
	m->m_pkthdr.pf.prio = LACP_IFQ_PRIO;

	du = mtod(m, struct lacpdu *);
	memset(du, 0, sizeof(*du));

	memcpy(&du->ldu_eh.ether_dhost, ethermulticastaddr_slowprotocols,
	    ETHER_ADDR_LEN);
	memcpy(&du->ldu_eh.ether_shost, tp->tp_lladdr, ETHER_ADDR_LEN);
	du->ldu_eh.ether_type = htons(ETHERTYPE_SLOW);

	du->ldu_sph.sph_subtype = SLOWPROTOCOLS_SUBTYPE_LACP;
	du->ldu_sph.sph_version = 1;

	TLV_SET(&du->ldu_tlv_actor, LACP_TYPE_ACTORINFO, sizeof(du->ldu_actor));
	du->ldu_actor = lp->lp_actor;

	TLV_SET(&du->ldu_tlv_partner, LACP_TYPE_PARTNERINFO,
	    sizeof(du->ldu_partner));
	du->ldu_partner = lp->lp_partner;

	TLV_SET(&du->ldu_tlv_collector, LACP_TYPE_COLLECTORINFO,
	    sizeof(du->ldu_collector));
	du->ldu_collector.lci_maxdelay = 0;

#if defined(LACP_DEBUG)
	LACP_DPRINTF((lp, "lacpdu transmit\n"));
	lacp_dump_lacpdu(du);
#endif /* defined(LACP_DEBUG) */

	m->m_flags |= M_MCAST;

	/*
	 * XXX should use higher priority queue.
	 * otherwise network congestion can break aggregation.
	 */
	error = if_enqueue(lp->lp_ifp, m);
	return (error);
}

int
lacp_xmit_marker(struct lacp_port *lp)
{
	struct trunk_port *tp = lp->lp_trunk;
	struct mbuf *m;
	struct markerdu *mdu;
	int error;

	m = m_gethdr(M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOMEM);
	m->m_len = m->m_pkthdr.len = sizeof(*mdu);
	m->m_pkthdr.pf.prio = LACP_IFQ_PRIO;

	mdu = mtod(m, struct markerdu *);
	memset(mdu, 0, sizeof(*mdu));

	memcpy(&mdu->mdu_eh.ether_dhost, ethermulticastaddr_slowprotocols,
	    ETHER_ADDR_LEN);
	memcpy(&mdu->mdu_eh.ether_shost, tp->tp_lladdr, ETHER_ADDR_LEN);
	mdu->mdu_eh.ether_type = htons(ETHERTYPE_SLOW);

	mdu->mdu_sph.sph_subtype = SLOWPROTOCOLS_SUBTYPE_MARKER;
	mdu->mdu_sph.sph_version = 1;

	/* Bump the transaction id and copy over the marker info */
	lp->lp_marker.mi_rq_xid = htonl(ntohl(lp->lp_marker.mi_rq_xid) + 1);
	TLV_SET(&mdu->mdu_tlv, MARKER_TYPE_INFO, sizeof(mdu->mdu_info));
	mdu->mdu_info = lp->lp_marker;

	LACP_DPRINTF((lp, "marker transmit, port=%u, sys=%s, id=%u\n",
	    ntohs(mdu->mdu_info.mi_rq_port),
	    ether_sprintf(mdu->mdu_info.mi_rq_system),
	    ntohl(mdu->mdu_info.mi_rq_xid)));

	m->m_flags |= M_MCAST;
	error = if_enqueue(lp->lp_ifp, m);
	return (error);
}

void
lacp_linkstate(struct trunk_port *tp)
{
	struct lacp_port *lp = LACP_PORT(tp);
	u_int8_t old_state;
	u_int16_t old_key;

	old_state = lp->lp_state;
	old_key = lp->lp_key;

	/*
	 * If the port is not an active full duplex Ethernet link then it can
	 * not be aggregated.
	 */
	if (tp->tp_link_state == LINK_STATE_UNKNOWN ||
	    tp->tp_link_state == LINK_STATE_FULL_DUPLEX)
		lacp_port_enable(lp);
	else
		lacp_port_disable(lp);

	lp->lp_key = lacp_compose_key(lp);

	if (old_state != lp->lp_state || old_key != lp->lp_key) {
		LACP_DPRINTF((lp, "-> UNSELECTED\n"));
		lp->lp_selected = LACP_UNSELECTED;
	}
}

void
lacp_tick(void *arg)
{
	struct lacp_softc *lsc = arg;
	struct lacp_port *lp;

	LIST_FOREACH(lp, &lsc->lsc_ports, lp_next) {
		if ((lp->lp_state & LACP_STATE_AGGREGATION) == 0)
			continue;

		lacp_run_timers(lp);

		lacp_select(lp);
		lacp_sm_mux(lp);
		lacp_sm_tx(lp);
		lacp_sm_ptx_tx_schedule(lp);
	}
	timeout_add_sec(&lsc->lsc_callout, 1);
}

int
lacp_port_create(struct trunk_port *tp)
{
	struct trunk_softc *sc = tp->tp_trunk;
	struct lacp_softc *lsc = LACP_SOFTC(sc);
	struct lacp_port *lp;
	struct ifnet *ifp = tp->tp_if;
	struct ifreq ifr;
	int error;

	int active = 1; /* XXX should be configurable */
	int fast = 0; /* XXX should be configurable */

	bzero(&ifr, sizeof(ifr));
	ifr.ifr_addr.sa_family = AF_UNSPEC;
	ifr.ifr_addr.sa_len = ETHER_ADDR_LEN;
	bcopy(&ethermulticastaddr_slowprotocols,
	    ifr.ifr_addr.sa_data, ETHER_ADDR_LEN);

	error = ether_addmulti(&ifr, (struct arpcom *)ifp);
	if (error && error != ENETRESET) {
		printf("%s: ADDMULTI failed on %s\n", __func__, tp->tp_ifname);
		return (error);
	}

	lp = malloc(sizeof(struct lacp_port),
	    M_DEVBUF, M_NOWAIT|M_ZERO);
	if (lp == NULL)
		return (ENOMEM);

	tp->tp_psc = (caddr_t)lp;
	lp->lp_ifp = ifp;
	lp->lp_trunk = tp;
	lp->lp_lsc = lsc;

	mq_init(&lp->lp_mq, 8, IPL_NET);

	LIST_INSERT_HEAD(&lsc->lsc_ports, lp, lp_next);

	lacp_fill_actorinfo(lp, &lp->lp_actor);
	lacp_fill_markerinfo(lp, &lp->lp_marker);
	lp->lp_state =
	    (active ? LACP_STATE_ACTIVITY : 0) |
	    (fast ? LACP_STATE_TIMEOUT : 0);
	lp->lp_aggregator = NULL;
	lacp_sm_rx_set_expired(lp);

	lacp_linkstate(tp);

	return (0);
}

void
lacp_port_destroy(struct trunk_port *tp)
{
	struct lacp_port *lp = LACP_PORT(tp);
	struct mbuf *m;
	int i;

	for (i = 0; i < LACP_NTIMER; i++)
		LACP_TIMER_DISARM(lp, i);

	lacp_disable_collecting(lp);
	lacp_disable_distributing(lp);
	lacp_unselect(lp);

	LIST_REMOVE(lp, lp_next);

	while ((m = mq_dequeue(&lp->lp_mq)) != NULL)
		m_freem(m);

	free(lp, M_DEVBUF, sizeof(*lp));
}

void
lacp_req(struct trunk_softc *sc, caddr_t data)
{
	struct lacp_opreq *req = (struct lacp_opreq *)data;
	struct lacp_softc *lsc = LACP_SOFTC(sc);
	struct lacp_aggregator *la = lsc->lsc_active_aggregator;

	bzero(req, sizeof(struct lacp_opreq));
	if (la != NULL) {
		req->actor_prio = ntohs(la->la_actor.lip_systemid.lsi_prio);
		memcpy(&req->actor_mac, &la->la_actor.lip_systemid.lsi_mac,
		    ETHER_ADDR_LEN);
		req->actor_key = ntohs(la->la_actor.lip_key);
		req->actor_portprio = ntohs(la->la_actor.lip_portid.lpi_prio);
		req->actor_portno = ntohs(la->la_actor.lip_portid.lpi_portno);
		req->actor_state = la->la_actor.lip_state;

		req->partner_prio = ntohs(la->la_partner.lip_systemid.lsi_prio);
		memcpy(&req->partner_mac, &la->la_partner.lip_systemid.lsi_mac,
		    ETHER_ADDR_LEN);
		req->partner_key = ntohs(la->la_partner.lip_key);
		req->partner_portprio =
		    ntohs(la->la_partner.lip_portid.lpi_prio);
		req->partner_portno =
		    ntohs(la->la_partner.lip_portid.lpi_portno);
		req->partner_state = la->la_partner.lip_state;
	}
}

u_int
lacp_port_status(struct trunk_port *lgp)
{
	struct lacp_port	*lp = LACP_PORT(lgp);
	struct lacp_softc	*lsc = lp->lp_lsc;
	struct lacp_aggregator	*la = lp->lp_aggregator;
	u_int			 flags = 0;

	/* This port is joined to the active aggregator */
	if (la != NULL && la == lsc->lsc_active_aggregator)
		flags |= TRUNK_PORT_ACTIVE;

	if (lp->lp_state & LACP_STATE_COLLECTING)
		flags |= TRUNK_PORT_COLLECTING;
	if (lp->lp_state & LACP_STATE_DISTRIBUTING)
		flags |= TRUNK_PORT_DISTRIBUTING;

	return (flags);
}

void
lacp_portreq(struct trunk_port *tp, caddr_t data)
{
	struct lacp_opreq *req = (struct lacp_opreq *)data;
	struct lacp_port *lp = LACP_PORT(tp);

	req->actor_prio = ntohs(lp->lp_actor.lip_systemid.lsi_prio);
	memcpy(&req->actor_mac, &lp->lp_actor.lip_systemid.lsi_mac,
	    ETHER_ADDR_LEN);
	req->actor_key = ntohs(lp->lp_actor.lip_key);
	req->actor_portprio = ntohs(lp->lp_actor.lip_portid.lpi_prio);
	req->actor_portno = ntohs(lp->lp_actor.lip_portid.lpi_portno);
	req->actor_state = lp->lp_actor.lip_state;

	req->partner_prio = ntohs(lp->lp_partner.lip_systemid.lsi_prio);
	memcpy(&req->partner_mac, &lp->lp_partner.lip_systemid.lsi_mac,
	    ETHER_ADDR_LEN);
	req->partner_key = ntohs(lp->lp_partner.lip_key);
	req->partner_portprio = ntohs(lp->lp_partner.lip_portid.lpi_prio);
	req->partner_portno = ntohs(lp->lp_partner.lip_portid.lpi_portno);
	req->partner_state = lp->lp_partner.lip_state;
}

void
lacp_disable_collecting(struct lacp_port *lp)
{
	LACP_DPRINTF((lp, "collecting disabled\n"));
	lp->lp_state &= ~LACP_STATE_COLLECTING;
}

void
lacp_enable_collecting(struct lacp_port *lp)
{
	LACP_DPRINTF((lp, "collecting enabled\n"));
	lp->lp_state |= LACP_STATE_COLLECTING;
}

void
lacp_disable_distributing(struct lacp_port *lp)
{
	struct lacp_aggregator *la = lp->lp_aggregator;
	struct lacp_softc *lsc = lp->lp_lsc;
#if defined(LACP_DEBUG)
	char buf[LACP_LAGIDSTR_MAX+1];
#endif /* defined(LACP_DEBUG) */

	if (la == NULL || (lp->lp_state & LACP_STATE_DISTRIBUTING) == 0)
		return;

	KASSERT(!TAILQ_EMPTY(&la->la_ports));
	KASSERT(la->la_nports > 0);
	KASSERT(la->la_refcnt >= la->la_nports);

	LACP_DPRINTF((lp, "disable distributing on aggregator %s, "
	    "nports %d -> %d\n",
	    lacp_format_lagid_aggregator(la, buf, sizeof(buf)),
	    la->la_nports, la->la_nports - 1));

	TAILQ_REMOVE(&la->la_ports, lp, lp_dist_q);
	la->la_nports--;

	if (lsc->lsc_active_aggregator == la) {
		lacp_suppress_distributing(lsc, la);
		lacp_select_active_aggregator(lsc);
		/* regenerate the port map, the active aggregator has changed */
		lacp_update_portmap(lsc);
	}

	lp->lp_state &= ~LACP_STATE_DISTRIBUTING;
}

void
lacp_enable_distributing(struct lacp_port *lp)
{
	struct lacp_aggregator *la = lp->lp_aggregator;
	struct lacp_softc *lsc = lp->lp_lsc;
#if defined(LACP_DEBUG)
	char buf[LACP_LAGIDSTR_MAX+1];
#endif /* defined(LACP_DEBUG) */

	if ((lp->lp_state & LACP_STATE_DISTRIBUTING) != 0)
		return;

	LACP_DPRINTF((lp, "enable distributing on aggregator %s, "
	    "nports %d -> %d\n",
	    lacp_format_lagid_aggregator(la, buf, sizeof(buf)),
	    la->la_nports, la->la_nports + 1));

	KASSERT(la->la_refcnt > la->la_nports);
	TAILQ_INSERT_HEAD(&la->la_ports, lp, lp_dist_q);
	la->la_nports++;

	lp->lp_state |= LACP_STATE_DISTRIBUTING;

	if (lsc->lsc_active_aggregator == la) {
		lacp_suppress_distributing(lsc, la);
		lacp_update_portmap(lsc);
	} else
		/* try to become the active aggregator */
		lacp_select_active_aggregator(lsc);
}

void
lacp_transit_expire(void *vp)
{
	struct lacp_softc *lsc = vp;

	LACP_DPRINTF((NULL, "%s\n", __func__));
	lsc->lsc_suppress_distributing = 0;
}

int
lacp_attach(struct trunk_softc *sc)
{
	struct lacp_softc *lsc;

	lsc = malloc(sizeof(struct lacp_softc),
	    M_DEVBUF, M_NOWAIT|M_ZERO);
	if (lsc == NULL)
		return (ENOMEM);

	sc->tr_psc = (caddr_t)lsc;
	lsc->lsc_softc = sc;

	arc4random_buf(&lsc->lsc_hashkey, sizeof(lsc->lsc_hashkey));
	lsc->lsc_active_aggregator = NULL;
	TAILQ_INIT(&lsc->lsc_aggregators);
	LIST_INIT(&lsc->lsc_ports);

	timeout_set(&lsc->lsc_transit_callout, lacp_transit_expire, lsc);
	timeout_set(&lsc->lsc_callout, lacp_tick, lsc);
	task_set(&lsc->lsc_input, lacp_input_process, lsc);

	/* if the trunk is already up then do the same */
	if (sc->tr_ac.ac_if.if_flags & IFF_RUNNING)
		lacp_init(sc);

	return (0);
}

int
lacp_detach(struct trunk_softc *sc)
{
	struct lacp_softc *lsc = LACP_SOFTC(sc);

	KASSERT(TAILQ_EMPTY(&lsc->lsc_aggregators));
	KASSERT(lsc->lsc_active_aggregator == NULL);

	sc->tr_psc = NULL;
	timeout_del(&lsc->lsc_transit_callout);
	timeout_del(&lsc->lsc_callout);

	free(lsc, M_DEVBUF, sizeof(*lsc));
	return (0);
}

void
lacp_init(struct trunk_softc *sc)
{
	struct lacp_softc *lsc = LACP_SOFTC(sc);

	timeout_add_sec(&lsc->lsc_callout, 1);
}

void
lacp_stop(struct trunk_softc *sc)
{
	struct lacp_softc *lsc = LACP_SOFTC(sc);

	timeout_del(&lsc->lsc_transit_callout);
	timeout_del(&lsc->lsc_callout);
}

struct trunk_port *
lacp_select_tx_port(struct trunk_softc *sc, struct mbuf *m)
{
	struct lacp_softc *lsc = LACP_SOFTC(sc);
	struct lacp_portmap *pm;
	struct lacp_port *lp;
	u_int32_t hash;

	if (__predict_false(lsc->lsc_suppress_distributing)) {
		LACP_DPRINTF((NULL, "%s: waiting transit\n", __func__));
		return (NULL);
	}

	pm = &lsc->lsc_pmap[lsc->lsc_activemap];
	if (pm->pm_count == 0) {
		LACP_DPRINTF((NULL, "%s: no active aggregator\n", __func__));
		return (NULL);
	}

	hash = trunk_hashmbuf(m, &lsc->lsc_hashkey);
	hash %= pm->pm_count;
	lp = pm->pm_map[hash];

	KASSERT((lp->lp_state & LACP_STATE_DISTRIBUTING) != 0);

	return (lp->lp_trunk);
}

/*
 * lacp_suppress_distributing: drop transmit packets for a while
 * to preserve packet ordering.
 */
void
lacp_suppress_distributing(struct lacp_softc *lsc, struct lacp_aggregator *la)
{
	struct lacp_port *lp;

	if (lsc->lsc_active_aggregator != la)
		return;

	LACP_DPRINTF((NULL, "%s\n", __func__));
	lsc->lsc_suppress_distributing = 1;

	/* send a marker frame down each port to verify the queues are empty */
	LIST_FOREACH(lp, &lsc->lsc_ports, lp_next) {
		lp->lp_flags |= LACP_PORT_MARK;
		lacp_xmit_marker(lp);
	}

	/* set a timeout for the marker frames */
	timeout_add_msec(&lsc->lsc_transit_callout, LACP_TRANSIT_DELAY);
}

int
lacp_compare_peerinfo(const struct lacp_peerinfo *a,
    const struct lacp_peerinfo *b)
{
	return (memcmp(a, b, offsetof(struct lacp_peerinfo, lip_state)));
}

int
lacp_compare_systemid(const struct lacp_systemid *a,
    const struct lacp_systemid *b)
{
	return (memcmp(a, b, sizeof(*a)));
}

#if 0	/* unused */
int
lacp_compare_portid(const struct lacp_portid *a,
    const struct lacp_portid *b)
{
	return (memcmp(a, b, sizeof(*a)));
}
#endif

u_int64_t
lacp_aggregator_bandwidth(struct lacp_aggregator *la)
{
	struct lacp_port *lp;
	u_int64_t speed;

	lp = TAILQ_FIRST(&la->la_ports);
	if (lp == NULL)
		return (0);

	speed = lp->lp_ifp->if_baudrate;
	speed *= la->la_nports;
	if (speed == 0) {
		LACP_DPRINTF((lp, "speed 0? media=0x%x nports=%d\n",
		    lp->lp_media, la->la_nports));
	}

	return (speed);
}

/*
 * lacp_select_active_aggregator: select an aggregator to be used to transmit
 * packets from trunk(4) interface.
 */
void
lacp_select_active_aggregator(struct lacp_softc *lsc)
{
	struct lacp_aggregator *la;
	struct lacp_aggregator *best_la = NULL;
	u_int64_t best_speed = 0;
#if defined(LACP_DEBUG)
	char buf[LACP_LAGIDSTR_MAX+1];
#endif /* defined(LACP_DEBUG) */

	LACP_DPRINTF((NULL, "%s:\n", __func__));

	TAILQ_FOREACH(la, &lsc->lsc_aggregators, la_q) {
		u_int64_t speed;

		if (la->la_nports == 0)
			continue;

		speed = lacp_aggregator_bandwidth(la);
		LACP_DPRINTF((NULL, "%s, speed=%jd, nports=%d\n",
		    lacp_format_lagid_aggregator(la, buf, sizeof(buf)),
		    speed, la->la_nports));

		/*
		 * This aggregator is chosen if
		 *      the partner has a better system priority
		 *  or, the total aggregated speed is higher
		 *  or, it is already the chosen aggregator
		 */
		if ((best_la != NULL && LACP_SYS_PRI(la->la_partner) <
		     LACP_SYS_PRI(best_la->la_partner)) ||
		    speed > best_speed ||
		    (speed == best_speed &&
		    la == lsc->lsc_active_aggregator)) {
			best_la = la;
			best_speed = speed;
		}
	}

	KASSERT(best_la == NULL || best_la->la_nports > 0);
	KASSERT(best_la == NULL || !TAILQ_EMPTY(&best_la->la_ports));

#if defined(LACP_DEBUG)
	if (lsc->lsc_active_aggregator != best_la) {
		LACP_DPRINTF((NULL, "active aggregator changed\n"));
		LACP_DPRINTF((NULL, "old %s\n",
		    lacp_format_lagid_aggregator(lsc->lsc_active_aggregator,
		    buf, sizeof(buf))));
	} else
		LACP_DPRINTF((NULL, "active aggregator not changed\n"));

	LACP_DPRINTF((NULL, "new %s\n",
	    lacp_format_lagid_aggregator(best_la, buf, sizeof(buf))));
#endif /* defined(LACP_DEBUG) */

	if (lsc->lsc_active_aggregator != best_la) {
		lsc->lsc_active_aggregator = best_la;
		lacp_update_portmap(lsc);
		if (best_la)
			lacp_suppress_distributing(lsc, best_la);
	}
}

/*
 * Updated the inactive portmap array with the new list of ports and
 * make it live.
 */
void
lacp_update_portmap(struct lacp_softc *lsc)
{
	struct lacp_aggregator *la;
	struct lacp_portmap *p;
	struct lacp_port *lp;
	u_int newmap;
	int i;

	newmap = lsc->lsc_activemap == 0 ? 1 : 0;
	p = &lsc->lsc_pmap[newmap];
	la = lsc->lsc_active_aggregator;
	bzero(p, sizeof(struct lacp_portmap));

	if (la != NULL && la->la_nports > 0) {
		p->pm_count = la->la_nports;
		i = 0;
		TAILQ_FOREACH(lp, &la->la_ports, lp_dist_q)
			p->pm_map[i++] = lp;
		KASSERT(i == p->pm_count);
	}

	/* switch the active portmap over */
	lsc->lsc_activemap = newmap;
	LACP_DPRINTF((NULL, "Set table %d with %d ports\n",
		    lsc->lsc_activemap,
		    lsc->lsc_pmap[lsc->lsc_activemap].pm_count));
}

u_int16_t
lacp_compose_key(struct lacp_port *lp)
{
	struct trunk_port *tp = lp->lp_trunk;
	struct trunk_softc *sc = tp->tp_trunk;
	u_int64_t speed;
	u_int16_t key;

	if ((lp->lp_state & LACP_STATE_AGGREGATION) == 0) {
		/* bit 0..14: (some bits of) if_index of this port */
		key = lp->lp_ifp->if_index;

		/* non-aggregatable */
		key |= 0x8000;
	} else {
		/* bit 0..2: speed indication */
		speed = lp->lp_ifp->if_baudrate;
		if (speed == 0)
			key = 0;
		else if (speed <= IF_Mbps(1))
			key = 1;
		else if (speed <= IF_Mbps(10))
			key = 2;
		else if (speed <= IF_Mbps(100))
			key = 3;
		else if (speed <= IF_Gbps(1))
			key = 4;
		else if (speed <= IF_Gbps(10))
			key = 5;
		else if (speed <= IF_Gbps(100))
			key = 6;
		else
			key = 7;

		/* bit 3..13: (some bits of) if_index of the trunk device */
		key |= sc->tr_ac.ac_if.if_index << 3;

		/* bit 14: the port active flag (includes link state) */
		if (TRUNK_PORTACTIVE(tp))
			key |= 0x4000;
		else
			key &= ~0x4000;

		/* clear the non-aggregatable bit */
		key &= ~0x8000;
	}
	return (htons(key));
}

void
lacp_aggregator_addref(struct lacp_softc *lsc, struct lacp_aggregator *la)
{
#if defined(LACP_DEBUG)
	char buf[LACP_LAGIDSTR_MAX+1];
#endif

	LACP_DPRINTF((NULL, "%s: lagid=%s, refcnt %d -> %d\n",
	    __func__,
	    lacp_format_lagid(&la->la_actor, &la->la_partner,
	    buf, sizeof(buf)),
	    la->la_refcnt, la->la_refcnt + 1));

	KASSERT(la->la_refcnt > 0);
	la->la_refcnt++;
	KASSERT(la->la_refcnt > la->la_nports);
}

void
lacp_aggregator_delref(struct lacp_softc *lsc, struct lacp_aggregator *la)
{
#if defined(LACP_DEBUG)
	char buf[LACP_LAGIDSTR_MAX+1];
#endif

	LACP_DPRINTF((NULL, "%s: lagid=%s, refcnt %d -> %d\n",
	    __func__,
	    lacp_format_lagid(&la->la_actor, &la->la_partner,
	    buf, sizeof(buf)),
	    la->la_refcnt, la->la_refcnt - 1));

	KASSERT(la->la_refcnt > la->la_nports);
	la->la_refcnt--;
	if (la->la_refcnt > 0)
		return;

	KASSERT(la->la_refcnt == 0);
	KASSERT(lsc->lsc_active_aggregator != la);

	TAILQ_REMOVE(&lsc->lsc_aggregators, la, la_q);

	free(la, M_DEVBUF, sizeof(*la));
}

/*
 * lacp_aggregator_get: allocate an aggregator.
 */
struct lacp_aggregator *
lacp_aggregator_get(struct lacp_softc *lsc, struct lacp_port *lp)
{
	struct lacp_aggregator *la;

	la = malloc(sizeof(*la), M_DEVBUF, M_NOWAIT);
	if (la) {
		la->la_refcnt = 1;
		la->la_nports = 0;
		TAILQ_INIT(&la->la_ports);
		la->la_pending = 0;
		TAILQ_INSERT_TAIL(&lsc->lsc_aggregators, la, la_q);
	}

	return (la);
}

/*
 * lacp_fill_aggregator_id: setup a newly allocated aggregator from a port.
 */
void
lacp_fill_aggregator_id(struct lacp_aggregator *la, const struct lacp_port *lp)
{
	lacp_fill_aggregator_id_peer(&la->la_partner, &lp->lp_partner);
	lacp_fill_aggregator_id_peer(&la->la_actor, &lp->lp_actor);

	la->la_actor.lip_state = lp->lp_state & LACP_STATE_AGGREGATION;
}

void
lacp_fill_aggregator_id_peer(struct lacp_peerinfo *lpi_aggr,
    const struct lacp_peerinfo *lpi_port)
{
	memset(lpi_aggr, 0, sizeof(*lpi_aggr));
	lpi_aggr->lip_systemid = lpi_port->lip_systemid;
	lpi_aggr->lip_key = lpi_port->lip_key;
}

/*
 * lacp_aggregator_is_compatible: check if a port can join to an aggregator.
 */
int
lacp_aggregator_is_compatible(const struct lacp_aggregator *la,
    const struct lacp_port *lp)
{
	if (!(lp->lp_state & LACP_STATE_AGGREGATION) ||
	    !(lp->lp_partner.lip_state & LACP_STATE_AGGREGATION))
		return (0);

	if (!(la->la_actor.lip_state & LACP_STATE_AGGREGATION))
		return (0);

	if (!lacp_peerinfo_is_compatible(&la->la_partner, &lp->lp_partner))
		return (0);

	if (!lacp_peerinfo_is_compatible(&la->la_actor, &lp->lp_actor))
		return (0);

	return (1);
}

int
lacp_peerinfo_is_compatible(const struct lacp_peerinfo *a,
    const struct lacp_peerinfo *b)
{
	if (memcmp(&a->lip_systemid, &b->lip_systemid,
	    sizeof(a->lip_systemid)))
		return (0);

	if (memcmp(&a->lip_key, &b->lip_key, sizeof(a->lip_key)))
		return (0);

	return (1);
}

void
lacp_port_enable(struct lacp_port *lp)
{
	lp->lp_state |= LACP_STATE_AGGREGATION;
}

void
lacp_port_disable(struct lacp_port *lp)
{
	lacp_set_mux(lp, LACP_MUX_DETACHED);

	lp->lp_state &= ~LACP_STATE_AGGREGATION;
	lp->lp_selected = LACP_UNSELECTED;
	lacp_sm_rx_record_default(lp);
	lp->lp_partner.lip_state &= ~LACP_STATE_AGGREGATION;
	lp->lp_state &= ~LACP_STATE_EXPIRED;
}

/*
 * lacp_select: select an aggregator.  create one if necessary.
 */
void
lacp_select(struct lacp_port *lp)
{
	struct lacp_softc *lsc = lp->lp_lsc;
	struct lacp_aggregator *la;
#if defined(LACP_DEBUG)
	char buf[LACP_LAGIDSTR_MAX+1];
#endif

	if (lp->lp_aggregator)
		return;

	KASSERT(!LACP_TIMER_ISARMED(lp, LACP_TIMER_WAIT_WHILE));

	LACP_DPRINTF((lp, "port lagid=%s\n",
	    lacp_format_lagid(&lp->lp_actor, &lp->lp_partner,
	    buf, sizeof(buf))));

	TAILQ_FOREACH(la, &lsc->lsc_aggregators, la_q) {
		if (lacp_aggregator_is_compatible(la, lp))
			break;
	}

	if (la == NULL) {
		la = lacp_aggregator_get(lsc, lp);
		if (la == NULL) {
			LACP_DPRINTF((lp, "aggregator creation failed\n"));

			/*
			 * will retry on the next tick.
			 */

			return;
		}
		lacp_fill_aggregator_id(la, lp);
		LACP_DPRINTF((lp, "aggregator created\n"));
	} else {
		LACP_DPRINTF((lp, "compatible aggregator found\n"));
		if (la->la_refcnt == LACP_MAX_PORTS)
			return;
		lacp_aggregator_addref(lsc, la);
	}

	LACP_DPRINTF((lp, "aggregator lagid=%s\n",
	    lacp_format_lagid(&la->la_actor, &la->la_partner,
	    buf, sizeof(buf))));

	lp->lp_aggregator = la;
	lp->lp_selected = LACP_SELECTED;
}

/*
 * lacp_unselect: finish unselect/detach process.
 */
void
lacp_unselect(struct lacp_port *lp)
{
	struct lacp_softc *lsc = lp->lp_lsc;
	struct lacp_aggregator *la = lp->lp_aggregator;

	KASSERT(!LACP_TIMER_ISARMED(lp, LACP_TIMER_WAIT_WHILE));

	if (la == NULL)
		return;

	lp->lp_aggregator = NULL;
	lacp_aggregator_delref(lsc, la);
}

/* mux machine */
void
lacp_sm_mux(struct lacp_port *lp)
{
	enum lacp_mux_state new_state;
	int p_sync =
	    (lp->lp_partner.lip_state & LACP_STATE_SYNC) != 0;
	int p_collecting =
	    (lp->lp_partner.lip_state & LACP_STATE_COLLECTING) != 0;
	enum lacp_selected selected = lp->lp_selected;
	struct lacp_aggregator *la;

	/* LACP_DPRINTF((lp, "%s: state %d\n", __func__, lp->lp_mux_state)); */

re_eval:
	la = lp->lp_aggregator;
	KASSERT(lp->lp_mux_state == LACP_MUX_DETACHED || la != NULL);
	new_state = lp->lp_mux_state;
	switch (lp->lp_mux_state) {
	case LACP_MUX_DETACHED:
		if (selected != LACP_UNSELECTED)
			new_state = LACP_MUX_WAITING;
		break;
	case LACP_MUX_WAITING:
		KASSERT(la->la_pending > 0 ||
		    !LACP_TIMER_ISARMED(lp, LACP_TIMER_WAIT_WHILE));
		if (selected == LACP_SELECTED && la->la_pending == 0)
			new_state = LACP_MUX_ATTACHED;
		else if (selected == LACP_UNSELECTED)
			new_state = LACP_MUX_DETACHED;
		break;
	case LACP_MUX_ATTACHED:
		if (selected == LACP_SELECTED && p_sync)
			new_state = LACP_MUX_COLLECTING;
		else if (selected != LACP_SELECTED)
			new_state = LACP_MUX_DETACHED;
		break;
	case LACP_MUX_COLLECTING:
		if (selected == LACP_SELECTED && p_sync && p_collecting)
			new_state = LACP_MUX_DISTRIBUTING;
		else if (selected != LACP_SELECTED || !p_sync)
			new_state = LACP_MUX_ATTACHED;
		break;
	case LACP_MUX_DISTRIBUTING:
		if (selected != LACP_SELECTED || !p_sync || !p_collecting)
			new_state = LACP_MUX_COLLECTING;
		break;
	default:
		panic("%s: unknown state", __func__);
	}

	if (lp->lp_mux_state == new_state)
		return;

	lacp_set_mux(lp, new_state);
	goto re_eval;
}

void
lacp_set_mux(struct lacp_port *lp, enum lacp_mux_state new_state)
{
	struct lacp_aggregator *la = lp->lp_aggregator;

	if (lp->lp_mux_state == new_state)
		return;

	switch (new_state) {
	case LACP_MUX_DETACHED:
		lp->lp_state &= ~LACP_STATE_SYNC;
		lacp_disable_distributing(lp);
		lacp_disable_collecting(lp);
		lacp_sm_assert_ntt(lp);
		/* cancel timer */
		if (LACP_TIMER_ISARMED(lp, LACP_TIMER_WAIT_WHILE)) {
			KASSERT(la->la_pending > 0);
			la->la_pending--;
		}
		LACP_TIMER_DISARM(lp, LACP_TIMER_WAIT_WHILE);
		lacp_unselect(lp);
		break;
	case LACP_MUX_WAITING:
		LACP_TIMER_ARM(lp, LACP_TIMER_WAIT_WHILE,
		    LACP_AGGREGATE_WAIT_TIME);
		la->la_pending++;
		break;
	case LACP_MUX_ATTACHED:
		lp->lp_state |= LACP_STATE_SYNC;
		lacp_disable_collecting(lp);
		lacp_sm_assert_ntt(lp);
		break;
	case LACP_MUX_COLLECTING:
		lacp_enable_collecting(lp);
		lacp_disable_distributing(lp);
		lacp_sm_assert_ntt(lp);
		break;
	case LACP_MUX_DISTRIBUTING:
		lacp_enable_distributing(lp);
		break;
	default:
		panic("%s: unknown state", __func__);
	}

	LACP_DPRINTF((lp, "mux_state %d -> %d\n", lp->lp_mux_state, new_state));

	lp->lp_mux_state = new_state;
}

void
lacp_sm_mux_timer(struct lacp_port *lp)
{
	struct lacp_aggregator *la = lp->lp_aggregator;
#if defined(LACP_DEBUG)
	char buf[LACP_LAGIDSTR_MAX+1];
#endif

	KASSERT(la->la_pending > 0);

	LACP_DPRINTF((lp, "%s: aggregator %s, pending %d -> %d\n", __func__,
	    lacp_format_lagid(&la->la_actor, &la->la_partner,
	    buf, sizeof(buf)),
	    la->la_pending, la->la_pending - 1));

	la->la_pending--;
}

/* periodic transmit machine */
void
lacp_sm_ptx_update_timeout(struct lacp_port *lp, u_int8_t oldpstate)
{
	if (LACP_STATE_EQ(oldpstate, lp->lp_partner.lip_state,
	    LACP_STATE_TIMEOUT))
		return;

	LACP_DPRINTF((lp, "partner timeout changed\n"));

	/*
	 * FAST_PERIODIC -> SLOW_PERIODIC
	 * or
	 * SLOW_PERIODIC (-> PERIODIC_TX) -> FAST_PERIODIC
	 *
	 * let lacp_sm_ptx_tx_schedule to update timeout.
	 */

	LACP_TIMER_DISARM(lp, LACP_TIMER_PERIODIC);

	/* if timeout has been shortened, assert NTT. */
	if ((lp->lp_partner.lip_state & LACP_STATE_TIMEOUT))
		lacp_sm_assert_ntt(lp);
}

void
lacp_sm_ptx_tx_schedule(struct lacp_port *lp)
{
	int timeout;

	if (!(lp->lp_state & LACP_STATE_ACTIVITY) &&
	    !(lp->lp_partner.lip_state & LACP_STATE_ACTIVITY)) {

		/* NO_PERIODIC */
		LACP_TIMER_DISARM(lp, LACP_TIMER_PERIODIC);
		return;
	}

	if (LACP_TIMER_ISARMED(lp, LACP_TIMER_PERIODIC))
		return;

	timeout = (lp->lp_partner.lip_state & LACP_STATE_TIMEOUT) ?
	    LACP_FAST_PERIODIC_TIME : LACP_SLOW_PERIODIC_TIME;

	LACP_TIMER_ARM(lp, LACP_TIMER_PERIODIC, timeout);
}

void
lacp_sm_ptx_timer(struct lacp_port *lp)
{
	lacp_sm_assert_ntt(lp);
}

void
lacp_sm_rx(struct lacp_port *lp, const struct lacpdu *du)
{
	int timeout;

	/* check LACP_DISABLED first */
	if (!(lp->lp_state & LACP_STATE_AGGREGATION))
		return;

	/* check loopback condition. */
	if (!lacp_compare_systemid(&du->ldu_actor.lip_systemid,
	    &lp->lp_actor.lip_systemid))
		return;

	/*
	 * EXPIRED, DEFAULTED, CURRENT -> CURRENT
	 */
	lacp_sm_rx_update_selected(lp, du);
	lacp_sm_rx_update_ntt(lp, du);
	lacp_sm_rx_record_pdu(lp, du);

	timeout = (lp->lp_state & LACP_STATE_TIMEOUT) ?
	    LACP_SHORT_TIMEOUT_TIME : LACP_LONG_TIMEOUT_TIME;
	LACP_TIMER_ARM(lp, LACP_TIMER_CURRENT_WHILE, timeout);

	lp->lp_state &= ~LACP_STATE_EXPIRED;

	/* kick transmit machine without waiting the next tick. */
	lacp_sm_tx(lp);
}

void
lacp_sm_rx_set_expired(struct lacp_port *lp)
{
	lp->lp_partner.lip_state &= ~LACP_STATE_SYNC;
	lp->lp_partner.lip_state |= LACP_STATE_TIMEOUT;
	LACP_TIMER_ARM(lp, LACP_TIMER_CURRENT_WHILE, LACP_SHORT_TIMEOUT_TIME);
	lp->lp_state |= LACP_STATE_EXPIRED;
}

void
lacp_sm_rx_timer(struct lacp_port *lp)
{
	if ((lp->lp_state & LACP_STATE_EXPIRED) == 0) {
		/* CURRENT -> EXPIRED */
		LACP_DPRINTF((lp, "%s: CURRENT -> EXPIRED\n", __func__));
		lacp_sm_rx_set_expired(lp);
	} else {
		/* EXPIRED -> DEFAULTED */
		LACP_DPRINTF((lp, "%s: EXPIRED -> DEFAULTED\n", __func__));
		lacp_sm_rx_update_default_selected(lp);
		lacp_sm_rx_record_default(lp);
		lp->lp_state &= ~LACP_STATE_EXPIRED;
	}
}

void
lacp_sm_rx_record_pdu(struct lacp_port *lp, const struct lacpdu *du)
{
	int active;
	u_int8_t oldpstate;
#if defined(LACP_DEBUG)
	char buf[LACP_STATESTR_MAX+1];
#endif

	/* LACP_DPRINTF((lp, "%s\n", __func__)); */

	oldpstate = lp->lp_partner.lip_state;

	active = (du->ldu_actor.lip_state & LACP_STATE_ACTIVITY)
	    || ((lp->lp_state & LACP_STATE_ACTIVITY) &&
	    (du->ldu_partner.lip_state & LACP_STATE_ACTIVITY));

	lp->lp_partner = du->ldu_actor;
	if (active &&
	    ((LACP_STATE_EQ(lp->lp_state, du->ldu_partner.lip_state,
	    LACP_STATE_AGGREGATION) &&
	    !lacp_compare_peerinfo(&lp->lp_actor, &du->ldu_partner))
	    || (du->ldu_partner.lip_state & LACP_STATE_AGGREGATION) == 0)) {
		/* XXX nothing? */
	} else
		lp->lp_partner.lip_state &= ~LACP_STATE_SYNC;

	lp->lp_state &= ~LACP_STATE_DEFAULTED;

	if (oldpstate != lp->lp_partner.lip_state) {
		LACP_DPRINTF((lp, "old pstate %s\n",
		    lacp_format_state(oldpstate, buf, sizeof(buf))));
		LACP_DPRINTF((lp, "new pstate %s\n",
		    lacp_format_state(lp->lp_partner.lip_state, buf,
		    sizeof(buf))));
	}

	lacp_sm_ptx_update_timeout(lp, oldpstate);
}

void
lacp_sm_rx_update_ntt(struct lacp_port *lp, const struct lacpdu *du)
{
	/* LACP_DPRINTF((lp, "%s\n", __func__)); */

	if (lacp_compare_peerinfo(&lp->lp_actor, &du->ldu_partner) ||
	    !LACP_STATE_EQ(lp->lp_state, du->ldu_partner.lip_state,
	    LACP_STATE_ACTIVITY | LACP_STATE_SYNC | LACP_STATE_AGGREGATION)) {
		LACP_DPRINTF((lp, "%s: assert ntt\n", __func__));
		lacp_sm_assert_ntt(lp);
	}
}

void
lacp_sm_rx_record_default(struct lacp_port *lp)
{
	u_int8_t oldpstate;

	/* LACP_DPRINTF((lp, "%s\n", __func__)); */

	oldpstate = lp->lp_partner.lip_state;
	lp->lp_partner = lacp_partner_admin;
	lp->lp_state |= LACP_STATE_DEFAULTED;
	lacp_sm_ptx_update_timeout(lp, oldpstate);
}

void
lacp_sm_rx_update_selected_from_peerinfo(struct lacp_port *lp,
    const struct lacp_peerinfo *info)
{
	/* LACP_DPRINTF((lp, "%s\n", __func__)); */

	if (lacp_compare_peerinfo(&lp->lp_partner, info) ||
	    !LACP_STATE_EQ(lp->lp_partner.lip_state, info->lip_state,
	    LACP_STATE_AGGREGATION)) {
		lp->lp_selected = LACP_UNSELECTED;
		/* mux machine will clean up lp->lp_aggregator */
	}
}

void
lacp_sm_rx_update_selected(struct lacp_port *lp, const struct lacpdu *du)
{
	/* LACP_DPRINTF((lp, "%s\n", __func__)); */

	lacp_sm_rx_update_selected_from_peerinfo(lp, &du->ldu_actor);
}

void
lacp_sm_rx_update_default_selected(struct lacp_port *lp)
{
	/* LACP_DPRINTF((lp, "%s\n", __func__)); */

	lacp_sm_rx_update_selected_from_peerinfo(lp, &lacp_partner_admin);
}

/* transmit machine */

void
lacp_sm_tx(struct lacp_port *lp)
{
	int error;

	if (!(lp->lp_state & LACP_STATE_AGGREGATION)
#if 1
	    || (!(lp->lp_state & LACP_STATE_ACTIVITY)
	    && !(lp->lp_partner.lip_state & LACP_STATE_ACTIVITY))
#endif
	    ) {
		lp->lp_flags &= ~LACP_PORT_NTT;
	}

	if (!(lp->lp_flags & LACP_PORT_NTT))
		return;

	/* Rate limit to 3 PDUs per LACP_FAST_PERIODIC_TIME */
	if (ppsratecheck(&lp->lp_last_lacpdu, &lp->lp_lacpdu_sent,
		    (3 / LACP_FAST_PERIODIC_TIME)) == 0) {
		LACP_DPRINTF((lp, "rate limited pdu\n"));
		return;
	}

	error = lacp_xmit_lacpdu(lp);

	if (error == 0)
		lp->lp_flags &= ~LACP_PORT_NTT;
	else
		LACP_DPRINTF((lp, "lacpdu transmit failure, error %d\n",
		    error));
}

void
lacp_sm_assert_ntt(struct lacp_port *lp)
{
	lp->lp_flags |= LACP_PORT_NTT;
}

void
lacp_run_timers(struct lacp_port *lp)
{
	int i;

	for (i = 0; i < LACP_NTIMER; i++) {
		KASSERT(lp->lp_timer[i] >= 0);
		if (lp->lp_timer[i] == 0)
			continue;
		else if (--lp->lp_timer[i] <= 0) {
			if (lacp_timer_funcs[i])
				(*lacp_timer_funcs[i])(lp);
		}
	}
}

int
lacp_marker_input(struct lacp_port *lp, struct mbuf *m)
{
	struct lacp_softc *lsc = lp->lp_lsc;
	struct trunk_port *tp = lp->lp_trunk;
	struct lacp_port *lp2;
	struct markerdu *mdu;
	int error = 0;
	int pending = 0;

	if (m->m_pkthdr.len != sizeof(*mdu))
		goto bad;

	if ((m->m_flags & M_MCAST) == 0)
		goto bad;

	if (m->m_len < sizeof(*mdu)) {
		m = m_pullup(m, sizeof(*mdu));
		if (m == NULL)
			return (ENOMEM);
	}

	mdu = mtod(m, struct markerdu *);

	if (memcmp(&mdu->mdu_eh.ether_dhost,
	    &ethermulticastaddr_slowprotocols, ETHER_ADDR_LEN))
		goto bad;

	if (mdu->mdu_sph.sph_version != 1)
		goto bad;

	switch (mdu->mdu_tlv.tlv_type) {
	case MARKER_TYPE_INFO:
		if (tlv_check(mdu, sizeof(*mdu), &mdu->mdu_tlv,
		    marker_info_tlv_template, 1))
			goto bad;

		mdu->mdu_tlv.tlv_type = MARKER_TYPE_RESPONSE;
		memcpy(&mdu->mdu_eh.ether_dhost,
		    &ethermulticastaddr_slowprotocols, ETHER_ADDR_LEN);
		memcpy(&mdu->mdu_eh.ether_shost,
		    tp->tp_lladdr, ETHER_ADDR_LEN);
		error = if_enqueue(lp->lp_ifp, m);
		break;

	case MARKER_TYPE_RESPONSE:
		if (tlv_check(mdu, sizeof(*mdu), &mdu->mdu_tlv,
		    marker_response_tlv_template, 1))
			goto bad;

		LACP_DPRINTF((lp, "marker response, port=%u, sys=%s, id=%u\n",
		    ntohs(mdu->mdu_info.mi_rq_port),
		    ether_sprintf(mdu->mdu_info.mi_rq_system),
		    ntohl(mdu->mdu_info.mi_rq_xid)));

		/* Verify that it is the last marker we sent out */
		if (memcmp(&mdu->mdu_info, &lp->lp_marker,
		    sizeof(struct lacp_markerinfo)))
			goto bad;

		lp->lp_flags &= ~LACP_PORT_MARK;

		if (lsc->lsc_suppress_distributing) {
			/* Check if any ports are waiting for a response */
			LIST_FOREACH(lp2, &lsc->lsc_ports, lp_next) {
				if (lp2->lp_flags & LACP_PORT_MARK) {
					pending = 1;
					break;
				}
			}

			if (pending == 0) {
				/* All interface queues are clear */
				LACP_DPRINTF((NULL, "queue flush complete\n"));
				lsc->lsc_suppress_distributing = 0;
			}
		}
		break;

	default:
		goto bad;
	}

	m_freem(m);
	return (error);

bad:
	LACP_DPRINTF((lp, "bad marker frame\n"));
	m_freem(m);
	return (EINVAL);
}

int
tlv_check(const void *p, size_t size, const struct tlvhdr *tlv,
    const struct tlv_template *tmpl, int check_type)
{
	while (/* CONSTCOND */ 1) {
		if ((const char *)tlv - (const char *)p + sizeof(*tlv) > size)
			return (EINVAL);

		if ((check_type && tlv->tlv_type != tmpl->tmpl_type) ||
		    tlv->tlv_length != tmpl->tmpl_length)
			return (EINVAL);

		if (tmpl->tmpl_type == 0)
			break;

		tlv = (const struct tlvhdr *)
		    ((const char *)tlv + tlv->tlv_length);
		tmpl++;
	}

	return (0);
}

#if defined(LACP_DEBUG)
const char *
lacp_format_mac(const u_int8_t *mac, char *buf, size_t buflen)
{
	snprintf(buf, buflen, "%02X-%02X-%02X-%02X-%02X-%02X",
	    (int)mac[0],
	    (int)mac[1],
	    (int)mac[2],
	    (int)mac[3],
	    (int)mac[4],
	    (int)mac[5]);

	return (buf);
}

const char *
lacp_format_systemid(const struct lacp_systemid *sysid,
    char *buf, size_t buflen)
{
	char macbuf[LACP_MACSTR_MAX+1];

	snprintf(buf, buflen, "%04X,%s",
	    ntohs(sysid->lsi_prio),
	    lacp_format_mac(sysid->lsi_mac, macbuf, sizeof(macbuf)));

	return (buf);
}

const char *
lacp_format_portid(const struct lacp_portid *portid, char *buf, size_t buflen)
{
	snprintf(buf, buflen, "%04X,%04X",
	    ntohs(portid->lpi_prio),
	    ntohs(portid->lpi_portno));

	return (buf);
}

const char *
lacp_format_partner(const struct lacp_peerinfo *peer, char *buf, size_t buflen)
{
	char sysid[LACP_SYSTEMIDSTR_MAX+1];
	char portid[LACP_PORTIDSTR_MAX+1];

	snprintf(buf, buflen, "(%s,%04X,%s)",
	    lacp_format_systemid(&peer->lip_systemid, sysid, sizeof(sysid)),
	    ntohs(peer->lip_key),
	    lacp_format_portid(&peer->lip_portid, portid, sizeof(portid)));

	return (buf);
}

const char *
lacp_format_lagid(const struct lacp_peerinfo *a,
    const struct lacp_peerinfo *b, char *buf, size_t buflen)
{
	char astr[LACP_PARTNERSTR_MAX+1];
	char bstr[LACP_PARTNERSTR_MAX+1];

#if 0
	/*
	 * there's a convention to display small numbered peer
	 * in the left.
	 */
	if (lacp_compare_peerinfo(a, b) > 0) {
		const struct lacp_peerinfo *t;

		t = a;
		a = b;
		b = t;
	}
#endif

	snprintf(buf, buflen, "[%s,%s]",
	    lacp_format_partner(a, astr, sizeof(astr)),
	    lacp_format_partner(b, bstr, sizeof(bstr)));

	return (buf);
}

const char *
lacp_format_lagid_aggregator(const struct lacp_aggregator *la,
    char *buf, size_t buflen)
{
	if (la == NULL)
		return ("(none)");

	return (lacp_format_lagid(&la->la_actor, &la->la_partner, buf, buflen));
}

const char *
lacp_format_state(u_int8_t state, char *buf, size_t buflen)
{
	snprintf(buf, buflen, "%b", state, LACP_STATE_BITS);
	return (buf);
}

void
lacp_dump_lacpdu(const struct lacpdu *du)
{
	char buf[LACP_PARTNERSTR_MAX+1];
	char buf2[LACP_STATESTR_MAX+1];

	printf("actor=%s\n",
	    lacp_format_partner(&du->ldu_actor, buf, sizeof(buf)));
	printf("actor.state=%s\n",
	    lacp_format_state(du->ldu_actor.lip_state, buf2, sizeof(buf2)));
	printf("partner=%s\n",
	    lacp_format_partner(&du->ldu_partner, buf, sizeof(buf)));
	printf("partner.state=%s\n",
	    lacp_format_state(du->ldu_partner.lip_state, buf2, sizeof(buf2)));

	printf("maxdelay=%d\n", ntohs(du->ldu_collector.lci_maxdelay));
}

void
lacp_dprintf(const struct lacp_port *lp, const char *fmt, ...)
{
	va_list va;

	if (lp)
		printf("%s: ", lp->lp_ifp->if_xname);

	va_start(va, fmt);
	vprintf(fmt, va);
	va_end(va);
}
#endif
@


1.28
log
@No need for <net/ethertypes.h> it is part of <netinet/if_ether.h>

While here use < > rather than " " to for driver includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.27 2015/11/24 13:37:16 mpi Exp $ */
d1707 1
a1707 1
	    	    ether_sprintf(mdu->mdu_info.mi_rq_system),
@


1.27
log
@No need for <net/if_types.h>

As a bonus this removes a "#if NCARP > 0", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.26 2015/10/05 13:00:04 mikeb Exp $ */
a47 1
#include <net/ethertypes.h>
d53 2
a54 2
#include "if_trunk.h"
#include "trunklacp.h"
@


1.26
log
@Factor LACP frame processing out to a separate task

This is slightly refactored version of the diff by jmatthew@@
that makes use of a single per-trunk task but retains per-port
mbuf queues.

Running LACP frame processing in a task context allows a simple
way to synchronize changes to the trunk ports and trunk itself
performed from the ioctl, timeout and task contexts with a kernel
lock.

OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.25 2015/09/24 14:01:20 mikeb Exp $ */
a49 1
#include <net/if_types.h>
@


1.25
log
@Avoid a theoretical m_pullup(9) mishandling by delegating the mbuf
reclaiming to the PDU and marker input routines.

m_pullup may return a pointer to the newly allocated mbuf.  In this
case m_freem is called by the trunk_input, not by the proto specific
code and pointer to the mbuf is not passed by reference. Therefore
m_freem will either be called on the middle element of the chain
(when the m_pullup call succeeds) or on the stale pointer (when it
frees the chain in the failure case).  Fortunately we should never
hit this case as the receive path uniformly uses contiguous chunks
of memory.

Verified with and ok blambert, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.24 2015/06/30 13:54:42 mpi Exp $ */
d42 1
d131 1
a249 3
			lacp_pdu_input(lp, m);
			return (1);

d251 2
a252 1
			lacp_marker_input(lp, m);
d272 26
d552 2
d573 1
d584 4
d771 1
@


1.24
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.23 2015/06/10 09:20:21 mpi Exp $ */
d263 2
a264 1
	    la == NULL || la != lsc->lsc_active_aggregator)
d266 1
d286 1
a286 1
		if (m == NULL) {
a287 1
		}
d319 1
d323 1
d1706 1
d1711 1
@


1.23
log
@Add missing include.
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.22 2015/06/09 14:50:14 mpi Exp $ */
d396 1
a396 1
	error = if_output(lp->lp_ifp, m);
d436 1
a436 1
	error = if_output(lp->lp_ifp, m);
d1662 1
a1662 1
		error = if_output(lp->lp_ifp, m);
@


1.22
log
@Convert trunk(4) to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.21 2015/05/15 10:15:13 mpi Exp $ */
d57 5
d238 2
a239 2
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
@


1.21
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.20 2015/05/11 08:41:43 mpi Exp $ */
d232 5
@


1.20
log
@Take trunk(4) out of ether_input().

Each physical interface of a trunk now gets a specific ifih (interface
input handler) that runs before ether_input().

Tested by sthen@@, dlg@@, Theo Buehler and <mxb AT alumni.chalmers DOT se>

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.19 2015/03/14 03:38:51 jsg Exp $ */
d345 1
a345 1
	int error, s;
d386 1
a386 3
	s = splnet();
	error = trunk_enqueue(lp->lp_ifp, m);
	splx(s);
d396 1
a396 1
	int error, s;
d426 1
a426 3
	s = splnet();
	error = trunk_enqueue(lp->lp_ifp, m);
	splx(s);
d1652 1
a1652 1
		error = trunk_enqueue(lp->lp_ifp, m);
@


1.19
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.18 2014/12/04 00:01:53 tedu Exp $ */
d125 2
a126 4
int		lacp_pdu_input(struct lacp_port *,
		    struct ether_header *, struct mbuf *);
int		lacp_marker_input(struct lacp_port *,
		    struct ether_header *, struct mbuf *);
d220 2
a221 2
struct mbuf *
lacp_input(struct trunk_port *tp, struct ether_header *eh, struct mbuf *m)
d226 1
d229 2
d232 2
a233 5
		if (m->m_pkthdr.len < sizeof(subtype)) {
			m_freem(m);
			return (NULL);
		}
		subtype = *mtod(m, u_int8_t *);
d235 1
d238 2
a239 2
			lacp_pdu_input(lp, eh, m);
			return (NULL);
d242 2
a243 2
			lacp_marker_input(lp, eh, m);
			return (NULL);
d253 2
a254 4
	    la == NULL || la != lsc->lsc_active_aggregator) {
		m_freem(m);
		return (NULL);
	}
d257 1
a257 1
	return (m);
d264 1
a264 1
lacp_pdu_input(struct lacp_port *lp, struct ether_header *eh, struct mbuf *m)
d280 1
a280 1
	if (memcmp(&eh->ether_dhost,
a307 1
	m_freem(m);
a310 1
	m_freem(m);
a343 1
	struct ether_header *eh;
d350 1
a350 1
	m->m_len = m->m_pkthdr.len = sizeof(*eh) + sizeof(*du);
a352 7
	eh = mtod(m, struct ether_header *);
	memcpy(&eh->ether_dhost, ethermulticastaddr_slowprotocols,
	    ETHER_ADDR_LEN);
	memcpy(&eh->ether_shost, tp->tp_lladdr, ETHER_ADDR_LEN);
	eh->ether_type = htons(ETHERTYPE_SLOW);

	m->m_data += sizeof(*eh);
d354 1
a354 1
	m->m_data -= sizeof(*eh);
d356 4
a359 1
	memset(du, 0, sizeof(*du));
a396 1
	struct ether_header *eh;
d403 1
a403 1
	m->m_len = m->m_pkthdr.len = sizeof(*eh) + sizeof(*mdu);
a405 7
	eh = mtod(m, struct ether_header *);
	memcpy(&eh->ether_dhost, ethermulticastaddr_slowprotocols,
	    ETHER_ADDR_LEN);
	memcpy(&eh->ether_shost, tp->tp_lladdr, ETHER_ADDR_LEN);
	eh->ether_type = htons(ETHERTYPE_SLOW);

	m->m_data += sizeof(*eh);
d407 1
a407 1
	m->m_data -= sizeof(*eh);
d409 4
a412 1
	memset(mdu, 0, sizeof(*mdu));
d422 3
a424 2
	LACP_DPRINTF((lp, "marker transmit, port=%u, sys=%6D, id=%u\n",
	    ntohs(mdu->mdu_info.mi_rq_port), mdu->mdu_info.mi_rq_system, ":",
d1615 1
a1615 1
lacp_marker_input(struct lacp_port *lp, struct ether_header *eh, struct mbuf *m)
d1638 1
a1638 1
	if (memcmp(&eh->ether_dhost,
d1652 1
a1652 1
		memcpy(&eh->ether_dhost,
d1654 1
a1654 1
		memcpy(&eh->ether_shost,
d1664 4
a1667 3
		LACP_DPRINTF((lp, "marker response, port=%u, sys=%6D, id=%u\n",
		    ntohs(mdu->mdu_info.mi_rq_port), mdu->mdu_info.mi_rq_system,
		    ":", ntohl(mdu->mdu_info.mi_rq_xid)));
a1690 1
		m_freem(m);
a1700 1
	m_freem(m);
@


1.18
log
@use siphash for trunk loadbalancing. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.17 2014/11/23 07:39:02 deraadt Exp $ */
a46 1
#include <net/if_dl.h>
@


1.17
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.16 2014/11/18 02:37:31 tedu Exp $ */
d44 2
d737 1
a737 1
	lsc->lsc_hashkey = arc4random();
d804 1
a804 1
	hash = trunk_hashmbuf(m, lsc->lsc_hashkey);
@


1.16
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.15 2014/07/12 18:44:22 tedu Exp $ */
d559 1
a559 1
	free(lp, M_DEVBUF, 0);
d762 1
a762 1
	free(lsc, M_DEVBUF, 0);
d1069 1
a1069 1
	free(la, M_DEVBUF, 0);
@


1.15
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.14 2012/12/05 23:20:23 deraadt Exp $ */
a42 1
#include <dev/rndvar.h>
@


1.14
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.13 2011/07/09 04:38:03 henning Exp $ */
d560 1
a560 1
	free(lp, M_DEVBUF);
d763 1
a763 1
	free(lsc, M_DEVBUF);
d1070 1
a1070 1
	free(la, M_DEVBUF);
@


1.13
log
@mark the mgmt pkts for queueing prio 6, mpf ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.12 2009/09/17 13:17:55 claudio Exp $ */
a30 2

#include <sys/cdefs.h>
@


1.12
log
@Wrap trunk_enqueue() calls in splnet() since sending out lacp packets
starts in a timeout handler which runs at a lower spl.
This fixes the problems with lacp trunks where some interfaces suddenly
fail for no obvious reason. Problem report and fix tested by Stephan A.
Rickauer. OK henning, reyk, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.11 2009/09/09 15:01:18 reyk Exp $ */
d65 1
d359 1
d417 1
@


1.11
log
@remove inline functions and move some code from the trunk_lacp_input()
API function directly to lacp_input() to simplify the code path.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.10 2009/07/31 09:21:13 blambert Exp $ */
d352 1
a352 1
	int error;
d396 1
d398 1
d409 1
a409 1
	int error;
d441 1
d443 1
@


1.10
log
@timeout_add -> timeout_add_msec

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.9 2008/12/01 10:40:57 brad Exp $ */
d227 2
d231 6
a236 5
	if (m->m_pkthdr.len < sizeof(subtype)) {
		m_freem(m);
		return (NULL);
	}
	subtype = *mtod(m, u_int8_t *);
d238 1
a238 2
	switch (subtype) {
		/* FALLTHROUGH */
d246 12
a319 30
__inline int
lacp_isactive(struct trunk_port *lgp)
{
	struct lacp_port *lp = LACP_PORT(lgp);
	struct lacp_softc *lsc = lp->lp_lsc;
	struct lacp_aggregator *la = lp->lp_aggregator;

	/* This port is joined to the active aggregator */
	if (la != NULL && la == lsc->lsc_active_aggregator)
		return (1);

	return (0);
}

__inline int
lacp_iscollecting(struct trunk_port *lgp)
{
	struct lacp_port *lp = LACP_PORT(lgp);

	return ((lp->lp_state & LACP_STATE_COLLECTING) != 0);
}

__inline int
lacp_isdistributing(struct trunk_port *lgp)
{
	struct lacp_port *lp = LACP_PORT(lgp);

	return ((lp->lp_state & LACP_STATE_DISTRIBUTING) != 0);
}

d585 20
@


1.9
log
@A bit more cleanup.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.8 2008/11/08 01:00:01 mpf Exp $ */
d825 1
a825 1
	timeout_add(&lsc->lsc_transit_callout, LACP_TRANSIT_DELAY * hz / 1000);
@


1.9.6.1
log
@MFC, original commit from claudio@@:
-----------------------------------------------------------------------
Wrap trunk_enqueue() calls in splnet() since sending out lacp packets
starts in a timeout handler which runs at a lower spl.
This fixes the problems with lacp trunks where some interfaces suddenly
fail for no obvious reason. Problem report and fix tested by Stephan A.
Rickauer. OK henning, reyk, mpf
-----------------------------------------------------------------------

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.12 2009/09/17 13:17:55 claudio Exp $ */
d368 1
a368 1
	int error, s;
a411 1
	s = splnet();
a412 1
	splx(s);
d423 1
a423 1
	int error, s;
a454 1
	s = splnet();
a455 1
	splx(s);
@


1.8
log
@Take into account that our ether_input() already strips the
ethernet header. This lets us actually process the incoming
LACP-Packets.  It should now work with a lot more switches.
At least a Catalyst 3500 seems happy.
OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.7 2008/10/24 04:44:52 brad Exp $ */
d279 1
a279 1
	if (du->ldu_sph.sph_version != 1) {
a280 1
	}
d288 1
a288 1
	    lacp_info_tlv_template, 0)) {
a289 1
	}
d371 1
a371 1
	if (m == NULL) {
a372 1
	}
d426 1
a426 1
	if (m == NULL) {
a427 1
	}
d563 1
a563 1
	for (i = 0; i < LACP_NTIMER; i++) {
a564 1
	}
d649 1
a649 1
	if (la == NULL || (lp->lp_state & LACP_STATE_DISTRIBUTING) == 0) {
a650 1
	}
d683 1
a683 1
	if ((lp->lp_state & LACP_STATE_DISTRIBUTING) != 0) {
a684 1
	}
d812 1
a812 1
	if (lsc->lsc_active_aggregator != la) {
a813 1
	}
d858 1
a858 1
	if (lp == NULL) {
a859 1
	}
d890 1
a890 1
		if (la->la_nports == 0) {
a891 1
		}
d923 1
a923 1
	} else {
d925 1
a925 1
	}
d933 1
a933 1
		if (best_la) {
a934 1
		}
d1053 1
a1053 1
	if (la->la_refcnt > 0) {
a1054 1
	}
d1113 1
a1113 1
	    !(lp->lp_partner.lip_state & LACP_STATE_AGGREGATION)) {
a1114 1
	}
d1116 1
a1116 1
	if (!(la->la_actor.lip_state & LACP_STATE_AGGREGATION)) {
a1117 1
	}
d1119 1
a1119 1
	if (!lacp_peerinfo_is_compatible(&la->la_partner, &lp->lp_partner)) {
a1120 1
	}
d1122 1
a1122 1
	if (!lacp_peerinfo_is_compatible(&la->la_actor, &lp->lp_actor)) {
a1123 1
	}
d1133 1
a1133 1
	    sizeof(a->lip_systemid))) {
a1134 1
	}
d1136 1
a1136 1
	if (memcmp(&a->lip_key, &b->lip_key, sizeof(a->lip_key))) {
a1137 1
	}
d1172 1
a1172 1
	if (lp->lp_aggregator) {
a1173 1
	}
d1182 1
a1182 1
		if (lacp_aggregator_is_compatible(la, lp)) {
a1183 1
		}
d1225 1
a1225 1
	if (la == NULL) {
a1226 1
	}
d1252 1
a1252 1
		if (selected != LACP_UNSELECTED) {
a1253 1
		}
d1258 1
a1258 1
		if (selected == LACP_SELECTED && la->la_pending == 0) {
d1260 1
a1260 1
		} else if (selected == LACP_UNSELECTED) {
a1261 1
		}
d1264 1
a1264 1
		if (selected == LACP_SELECTED && p_sync) {
d1266 1
a1266 1
		} else if (selected != LACP_SELECTED) {
a1267 1
		}
d1270 1
a1270 1
		if (selected == LACP_SELECTED && p_sync && p_collecting) {
d1272 1
a1272 1
		} else if (selected != LACP_SELECTED || !p_sync) {
a1273 1
		}
d1276 1
a1276 1
		if (selected != LACP_SELECTED || !p_sync || !p_collecting) {
a1277 1
		}
d1283 1
a1283 1
	if (lp->lp_mux_state == new_state) {
a1284 1
	}
d1295 1
a1295 1
	if (lp->lp_mux_state == new_state) {
a1296 1
	}
d1362 1
a1362 1
	    LACP_STATE_TIMEOUT)) {
a1363 1
	}
d1378 1
a1378 1
	if ((lp->lp_partner.lip_state & LACP_STATE_TIMEOUT)) {
a1379 1
	}
d1395 1
a1395 1
	if (LACP_TIMER_ISARMED(lp, LACP_TIMER_PERIODIC)) {
a1396 1
	}
d1416 1
a1416 1
	if (!(lp->lp_state & LACP_STATE_AGGREGATION)) {
a1417 1
	}
d1421 1
a1421 1
	    &lp->lp_actor.lip_systemid)) {
a1422 1
	}
d1490 1
a1490 1
	} else {
a1491 1
	}
d1578 1
a1578 1
	if (!(lp->lp_flags & LACP_PORT_NTT)) {
a1579 1
	}
d1590 1
a1590 1
	if (error == 0) {
d1592 1
a1592 1
	} else {
a1594 1
	}
d1610 1
a1610 1
		if (lp->lp_timer[i] == 0) {
d1612 2
a1613 2
		} else if (--lp->lp_timer[i] <= 0) {
			if (lacp_timer_funcs[i]) {
a1614 1
			}
d1629 1
a1629 1
	if (m->m_pkthdr.len != sizeof(*mdu)) {
a1630 1
	}
d1632 1
a1632 1
	if ((m->m_flags & M_MCAST) == 0) {
a1633 1
	}
d1637 1
a1637 1
		if (m == NULL) {
a1638 1
		}
d1644 1
a1644 1
	    &ethermulticastaddr_slowprotocols, ETHER_ADDR_LEN)) {
a1645 1
	}
d1647 1
a1647 1
	if (mdu->mdu_sph.sph_version != 1) {
a1648 1
	}
d1653 1
a1653 1
		    marker_info_tlv_template, 1)) {
d1655 1
a1655 1
		}
d1666 1
a1666 1
		    marker_response_tlv_template, 1)) {
d1668 1
a1668 1
		}
d1715 1
a1715 1
		if ((const char *)tlv - (const char *)p + sizeof(*tlv) > size) {
d1717 1
a1717 1
		}
d1719 1
a1719 1
		    tlv->tlv_length != tmpl->tmpl_length) {
d1721 2
a1722 2
		}
		if (tmpl->tmpl_type == 0) {
d1724 1
a1724 1
		}
d1817 1
a1817 1
	if (la == NULL) {
a1818 1
	}
d1853 1
a1853 1
	if (lp) {
a1854 1
	}
@


1.7
log
@Allow the debug printf code which is trying to retreive the interface
pointer to get at the interface name by pointing to the correct struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.6 2008/10/15 19:12:18 blambert Exp $ */
d126 4
a129 2
int		lacp_pdu_input(struct lacp_port *, struct mbuf *);
int		lacp_marker_input(struct lacp_port *, struct mbuf *);
d224 1
a224 1
lacp_input(struct trunk_port *tp, struct mbuf *m)
d229 1
a229 1
	if (m->m_pkthdr.len < sizeof(struct ether_header) + sizeof(subtype)) {
d233 1
a234 1
	m_copydata(m, sizeof(struct ether_header), sizeof(subtype), &subtype);
d238 1
a238 1
			lacp_pdu_input(lp, m);
d242 1
a242 1
			lacp_marker_input(lp, m);
d254 1
a254 1
lacp_pdu_input(struct lacp_port *lp, struct mbuf *m)
d259 1
a259 1
	if (m->m_pkthdr.len != sizeof(*du)) {
a260 5
	}

	if ((m->m_flags & M_MCAST) == 0) {
		goto bad;
	}
a267 1

d270 2
a271 2
	if (memcmp(&du->ldu_eh.ether_dhost,
	    &ethermulticastaddr_slowprotocols, ETHER_ADDR_LEN)) {
a272 1
	}
d285 2
a286 2
	 * ignore tlv types for compatibility with
	 * the future protocol revisions.
d368 1
d376 1
a376 1
	m->m_len = m->m_pkthdr.len = sizeof(*du);
d378 7
d386 2
a389 5
	memcpy(&du->ldu_eh.ether_dhost, ethermulticastaddr_slowprotocols,
	    ETHER_ADDR_LEN);
	memcpy(&du->ldu_eh.ether_shost, tp->tp_lladdr, ETHER_ADDR_LEN);
	du->ldu_eh.ether_type = htons(ETHERTYPE_SLOW);

d424 1
d432 1
a432 1
	m->m_len = m->m_pkthdr.len = sizeof(*mdu);
d434 7
d442 2
a445 5
	memcpy(&mdu->mdu_eh.ether_dhost, ethermulticastaddr_slowprotocols,
	    ETHER_ADDR_LEN);
	memcpy(&mdu->mdu_eh.ether_shost, tp->tp_lladdr, ETHER_ADDR_LEN);
	mdu->mdu_eh.ether_type = htons(ETHERTYPE_SLOW);

d1259 1
a1259 1
		    (lp->lp_partner.lip_state & LACP_STATE_SYNC) != 0;
d1657 1
a1657 1
lacp_marker_input(struct lacp_port *lp, struct mbuf *m)
d1683 1
a1683 1
	if (memcmp(&mdu->mdu_eh.ether_dhost,
d1699 1
a1699 1
		memcpy(&mdu->mdu_eh.ether_dhost,
d1701 1
a1701 1
		memcpy(&mdu->mdu_eh.ether_shost,
@


1.6
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.5 2008/10/12 19:03:12 mpf Exp $ */
d1892 1
a1892 1
		printf("%s: ", lp->tp_if->if_xname);
@


1.5
log
@Some more cleanup. No binary change.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.4 2008/08/28 11:10:25 reyk Exp $ */
d503 1
a503 1
	timeout_add(&lsc->lsc_callout, hz);
d765 1
a765 1
	timeout_add(&lsc->lsc_callout, hz);
@


1.4
log
@encode the speed and link state in the local port key.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.3 2008/08/06 17:04:28 reyk Exp $ */
d38 2
a39 2
#include <sys/kernel.h> /* hz */
#include <sys/socket.h> /* for net/if.h */
a62 1

d177 1
a177 1
const char 	*lacp_format_partner(const struct lacp_peerinfo *, char *,
a414 1

a471 1

d595 4
a598 2
		req->partner_portprio = ntohs(la->la_partner.lip_portid.lpi_prio);
		req->partner_portno = ntohs(la->la_partner.lip_portid.lpi_portno);
d804 1
a808 1

a878 1

d903 2
a904 1
		/* This aggregator is chosen if
a1073 1

a1093 1

a1114 1

a1231 1

a1248 1

a1380 1

d1401 1
a1401 4
	/*
	 * if timeout has been shortened, assert NTT.
	 */

d1415 1
a1415 4
		/*
		 * NO_PERIODIC
		 */

d1441 1
a1441 4
	/*
	 * check LACP_DISABLED first
	 */

d1446 1
a1446 4
	/*
	 * check loopback condition.
	 */

a1454 1

d1465 1
a1465 4
	/*
	 * kick transmit machine without waiting the next tick.
	 */

a1630 1

a1833 1

@


1.3
log
@fix trunk breakage that sneaked in with the lacp diff:

- don't use in-kernel IFMEDIA ioctls in lacp and remove two KASSERTs
that caused reliable panics - the lacp key can be locally assigned and
we don't need to query the media subtype here.

- unbreak failover/loadbalance/broadcast status handling.

Reported by brad@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.2 2008/06/15 19:00:57 mpf Exp $ */
d983 1
d987 2
d990 1
a990 9
		/*
		 * non-aggregatable links should have unique keys.
		 *
		 * XXX this isn't really unique as if_index is 16 bit.
		 */

		/* bit 0..14:	(some bits of) if_index of this port */
		key = lp->lp_ifp->if_index;
		/* bit 15:	1 */
d993 29
a1021 3
		/* bit 0..14:	(some bits of) if_index of trunk device */
		key = sc->tr_ac.ac_if.if_index;
		/* bit 15:	0 */
@


1.2
log
@A bit of cleanup:
- we prefer u_int*_t over uint_*t.
- static is bad for debugging.
- header files should not contain functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: trunklacp.c,v 1.1 2008/06/15 06:56:09 mpf Exp $ */
a516 1
	struct ifmediareq ifmr;
a553 5
	bzero((char *)&ifmr, sizeof(ifmr));
	error = (*ifp->if_ioctl)(ifp, SIOCGIFMEDIA, (caddr_t)&ifmr);
	if (error == 0)
		lp->lp_media = ifmr.ifm_active;

a866 1
	speed = ifmedia_baudrate(lp->lp_media);
a982 1
	u_int media = lp->lp_media;
d998 2
a999 9
		u_int subtype = IFM_SUBTYPE(media);

		KASSERT(IFM_TYPE(media) == IFM_ETHER);
		KASSERT((media & IFM_FDX) != 0);

		/* bit 0..4:	IFM_SUBTYPE */
		key = subtype;
		/* bit 5..14:	(some bits of) if_index of trunk device */
		key |= 0x7fe0 & ((sc->tr_ac.ac_if.if_index) << 5);
d1001 1
@


1.1
log
@Add 802.3ad LACP support for trunk(4).
Implementation from NetBSD. Ported via FreeBSD's version in trunk^Wlagg(4).
This is still work in progress.  Tested with a HP ProCurve 3500.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d67 1
a67 1
const uint8_t ethermulticastaddr_slowprotocols[ETHER_ADDR_LEN] =
d70 1
a70 1
static const struct tlv_template lacp_info_tlv_template[] = {
d80 1
a80 1
static const struct tlv_template marker_info_tlv_template[] = {
d86 1
a86 1
static const struct tlv_template marker_response_tlv_template[] = {
d94 2
a95 2
static void	lacp_fill_actorinfo(struct lacp_port *, struct lacp_peerinfo *);
static void	lacp_fill_markerinfo(struct lacp_port *,
d98 2
a99 2
static uint64_t	lacp_aggregator_bandwidth(struct lacp_aggregator *);
static void	lacp_suppress_distributing(struct lacp_softc *,
d101 5
a105 5
static void	lacp_transit_expire(void *);
static void	lacp_update_portmap(struct lacp_softc *);
static void	lacp_select_active_aggregator(struct lacp_softc *);
static uint16_t	lacp_compose_key(struct lacp_port *);
static int	tlv_check(const void *, size_t, const struct tlvhdr *,
d107 1
a107 1
static void	lacp_tick(void *);
d109 1
a109 1
static void	lacp_fill_aggregator_id(struct lacp_aggregator *,
d111 1
a111 1
static void	lacp_fill_aggregator_id_peer(struct lacp_peerinfo *,
d113 1
a113 1
static int	lacp_aggregator_is_compatible(const struct lacp_aggregator *,
d115 1
a115 1
static int	lacp_peerinfo_is_compatible(const struct lacp_peerinfo *,
d118 1
a118 1
static struct lacp_aggregator *lacp_aggregator_get(struct lacp_softc *,
d120 1
a120 1
static void	lacp_aggregator_addref(struct lacp_softc *,
d122 1
a122 1
static void	lacp_aggregator_delref(struct lacp_softc *,
d127 6
a132 6
static int	lacp_pdu_input(struct lacp_port *, struct mbuf *);
static int	lacp_marker_input(struct lacp_port *, struct mbuf *);
static void	lacp_sm_rx(struct lacp_port *, const struct lacpdu *);
static void	lacp_sm_rx_timer(struct lacp_port *);
static void	lacp_sm_rx_set_expired(struct lacp_port *);
static void	lacp_sm_rx_update_ntt(struct lacp_port *,
d134 1
a134 1
static void	lacp_sm_rx_record_pdu(struct lacp_port *,
d136 1
a136 1
static void	lacp_sm_rx_update_selected(struct lacp_port *,
d138 3
a140 3
static void	lacp_sm_rx_record_default(struct lacp_port *);
static void	lacp_sm_rx_update_default_selected(struct lacp_port *);
static void	lacp_sm_rx_update_selected_from_peerinfo(struct lacp_port *,
d145 3
a147 3
static void	lacp_sm_mux(struct lacp_port *);
static void	lacp_set_mux(struct lacp_port *, enum lacp_mux_state);
static void	lacp_sm_mux_timer(struct lacp_port *);
d151 3
a153 3
static void	lacp_sm_ptx_update_timeout(struct lacp_port *, uint8_t);
static void	lacp_sm_ptx_tx_schedule(struct lacp_port *);
static void	lacp_sm_ptx_timer(struct lacp_port *);
d157 2
a158 2
static void	lacp_sm_tx(struct lacp_port *);
static void	lacp_sm_assert_ntt(struct lacp_port *);
d160 2
a161 2
static void	lacp_run_timers(struct lacp_port *);
static int	lacp_compare_peerinfo(const struct lacp_peerinfo *,
d163 1
a163 1
static int	lacp_compare_systemid(const struct lacp_systemid *,
d165 10
a174 10
static void	lacp_port_enable(struct lacp_port *);
static void	lacp_port_disable(struct lacp_port *);
static void	lacp_select(struct lacp_port *);
static void	lacp_unselect(struct lacp_port *);
static void	lacp_disable_collecting(struct lacp_port *);
static void	lacp_enable_collecting(struct lacp_port *);
static void	lacp_disable_distributing(struct lacp_port *);
static void	lacp_enable_distributing(struct lacp_port *);
static int	lacp_xmit_lacpdu(struct lacp_port *);
static int	lacp_xmit_marker(struct lacp_port *);
d177 2
a178 2
static void	lacp_dump_lacpdu(const struct lacpdu *);
static const char *lacp_format_partner(const struct lacp_peerinfo *, char *,
d180 1
a180 1
static const char *lacp_format_lagid(const struct lacp_peerinfo *,
d182 1
a182 1
static const char *lacp_format_lagid_aggregator(const struct lacp_aggregator *,
d184 3
a186 3
static const char *lacp_format_state(uint8_t, char *, size_t);
static const char *lacp_format_mac(const uint8_t *, char *, size_t);
static const char *lacp_format_systemid(const struct lacp_systemid *, char *,
d188 1
a188 1
static const char *lacp_format_portid(const struct lacp_portid *, char *,
d190 1
a190 1
static void	lacp_dprintf(const struct lacp_port *, const char *, ...)
d202 1
a202 1
static const struct lacp_peerinfo lacp_partner_admin = {
d216 1
a216 1
static const lacp_timer_func_t lacp_timer_funcs[LACP_NTIMER] = {
d226 1
a226 1
	uint8_t subtype;
d252 1
a252 1
static int
d314 31
a344 1
static void
d358 1
a358 1
static void
d369 1
a369 1
static int
d421 1
a421 1
static int
d464 2
a465 2
	uint8_t old_state;
	uint16_t old_key;
d489 1
a489 1
static void
d633 1
a633 1
static void
d640 1
a640 1
static void
d647 1
a647 1
static void
d682 1
a682 1
static void
d714 1
a714 1
static void
d790 1
a790 1
	uint32_t hash;
d816 1
a816 1
static void
d838 1
a838 1
static int
d845 1
a845 1
static int
d853 1
a853 1
static int
d861 1
a861 1
static uint64_t
d865 1
a865 1
	uint64_t speed;
d888 1
a888 1
static void
d893 1
a893 1
	uint64_t best_speed = 0;
d901 1
a901 1
		uint64_t speed;
d956 1
a956 1
static void
d985 1
a985 1
static uint16_t
d991 1
a991 1
	uint16_t key;
d1020 1
a1020 1
static void
d1038 1
a1038 1
static void
d1069 1
a1069 1
static struct lacp_aggregator *
d1090 1
a1090 1
static void
d1099 1
a1099 1
static void
d1112 1
a1112 1
static int
d1136 1
a1136 1
static int
d1152 1
a1152 1
static void
d1158 1
a1158 1
static void
d1173 1
a1173 1
static void
d1230 1
a1230 1
static void
d1248 1
a1248 1
static void
d1311 1
a1311 1
static void
d1361 1
a1361 1
static void
d1381 2
a1382 2
static void
lacp_sm_ptx_update_timeout(struct lacp_port *lp, uint8_t oldpstate)
d1410 1
a1410 1
static void
d1436 1
a1436 1
static void
d1442 1
a1442 1
static void
d1485 1
a1485 1
static void
d1494 1
a1494 1
static void
d1510 1
a1510 1
static void
d1514 1
a1514 1
	uint8_t oldpstate;
d1551 1
a1551 1
static void
d1564 1
a1564 1
static void
d1567 1
a1567 1
	uint8_t oldpstate;
d1577 1
a1577 1
static void
d1591 1
a1591 1
static void
d1599 1
a1599 1
static void
d1609 1
a1609 1
static void
d1644 1
a1644 1
static void
d1651 1
a1651 1
static void
d1764 1
a1764 1
static int
d1789 1
a1789 1
lacp_format_mac(const uint8_t *mac, char *buf, size_t buflen)
d1880 1
a1880 1
lacp_format_state(uint8_t state, char *buf, size_t buflen)
d1886 1
a1886 1
static void
d1904 1
a1904 1
static void
@

