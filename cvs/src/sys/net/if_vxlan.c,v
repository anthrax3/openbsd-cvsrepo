head	1.60;
access;
symbols
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10;
locks; strict;
comment	@ * @;


1.60
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.59;
commitid	Gef6NNDxonzfVaq2;

1.59
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.58;
commitid	zztPc3QpQPdWwQ6h;

1.58
date	2017.04.09.17.57.58;	author dhill;	state Exp;
branches;
next	1.57;
commitid	eRsveMbENOTEvu0s;

1.57
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.56;
commitid	VyLWTsbepAOk7VQM;

1.56
date	2017.01.04.12.49.49;	author mikeb;	state Exp;
branches;
next	1.55;
commitid	5cKtgAvrhcstRxcY;

1.55
date	2017.01.03.15.35.34;	author reyk;	state Exp;
branches;
next	1.54;
commitid	XXFIelISvxnPQ8CE;

1.54
date	2016.12.13.06.51.11;	author dlg;	state Exp;
branches;
next	1.53;
commitid	OT2zwp1xv8iSCwtY;

1.53
date	2016.12.02.11.16.04;	author mpi;	state Exp;
branches;
next	1.52;
commitid	WNL3JHfh9QQ4epFM;

1.52
date	2016.11.29.10.09.57;	author reyk;	state Exp;
branches;
next	1.51;
commitid	KGFiK26819ueNC3N;

1.51
date	2016.10.25.16.31.08;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	kUWTKwErIyjX089M;

1.50
date	2016.10.14.10.25.02;	author mikeb;	state Exp;
branches;
next	1.49;
commitid	PpbuZUb9zQVpnqvR;

1.49
date	2016.10.07.06.16.03;	author yasuoka;	state Exp;
branches;
next	1.48;
commitid	35zq7caLJqVinIOc;

1.48
date	2016.09.30.10.22.05;	author yasuoka;	state Exp;
branches;
next	1.47;
commitid	UxJGmX1TtrbdWYO4;

1.47
date	2016.09.29.11.37.44;	author reyk;	state Exp;
branches;
next	1.46;
commitid	TXqeFb76AWQD8eLy;

1.46
date	2016.09.28.14.26.43;	author yasuoka;	state Exp;
branches;
next	1.45;
commitid	Cm26txWBchUfC49c;

1.45
date	2016.09.28.14.10.35;	author yasuoka;	state Exp;
branches;
next	1.44;
commitid	UdTZZeOrK4PlopW7;

1.44
date	2016.09.04.11.14.44;	author reyk;	state Exp;
branches;
next	1.43;
commitid	pAFELpo7rb5aYX6v;

1.43
date	2016.09.03.13.46.57;	author reyk;	state Exp;
branches;
next	1.42;
commitid	3QjHFZLzmkdTcUlc;

1.42
date	2016.08.07.14.26.26;	author reyk;	state Exp;
branches;
next	1.41;
commitid	BKceXNrpnoL9Vs0e;

1.41
date	2016.08.07.13.49.12;	author reyk;	state Exp;
branches;
next	1.40;
commitid	IQ8KtYOT7k3LcKgr;

1.40
date	2016.08.06.14.33.33;	author reyk;	state Exp;
branches;
next	1.39;
commitid	WFeOyxM6LJyDGj8P;

1.39
date	2016.08.06.14.29.48;	author reyk;	state Exp;
branches;
next	1.38;
commitid	AWiCCKunhYqQoUPE;

1.38
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.37;
commitid	Xo6g1xk26RWDGcjJ;

1.37
date	2016.01.22.11.56.14;	author goda;	state Exp;
branches;
next	1.36;
commitid	zKcYZsh0kIfJyGCP;

1.36
date	2016.01.14.09.20.31;	author mpi;	state Exp;
branches;
next	1.35;
commitid	mmanJIPww2fqlSXb;

1.35
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.34;
commitid	ILbVM1M3uPNjwswz;

1.34
date	2015.11.27.16.17.52;	author mpi;	state Exp;
branches;
next	1.33;
commitid	7hBeu8KjAV1tmWqu;

1.33
date	2015.10.25.12.05.40;	author mpi;	state Exp;
branches;
next	1.32;
commitid	iXTa9MhdGfWGiTE6;

1.32
date	2015.10.23.01.19.04;	author dlg;	state Exp;
branches;
next	1.31;
commitid	amrA8l73DaZf9wmS;

1.31
date	2015.10.15.13.59.21;	author yasuoka;	state Exp;
branches;
next	1.30;
commitid	xslPVlnx5Sp5Qvz5;

1.30
date	2015.10.12.10.51.49;	author dlg;	state Exp;
branches;
next	1.29;
commitid	nEAoohuoVEKE9HT9;

1.29
date	2015.10.03.07.22.05;	author yasuoka;	state Exp;
branches;
next	1.28;
commitid	n6QdlzUNgA9xbA82;

1.28
date	2015.09.09.20.05.21;	author dlg;	state Exp;
branches;
next	1.27;
commitid	GgfmulmvLEJpPhGi;

1.27
date	2015.07.20.22.54.30;	author mpi;	state Exp;
branches;
next	1.26;
commitid	kUJLGGhKrehg9sRa;

1.26
date	2015.07.18.22.15.14;	author goda;	state Exp;
branches;
next	1.25;
commitid	Z1rfy0CAE09Lr6YX;

1.25
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.24;
commitid	MVWrtktB46JRxFWT;

1.24
date	2015.04.13.08.40.32;	author mpi;	state Exp;
branches;
next	1.23;
commitid	oX156rD9SOOWQhQj;

1.23
date	2015.04.07.10.46.20;	author mpi;	state Exp;
branches;
next	1.22;
commitid	m3c6YErI0cVMQeYc;

1.22
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.21;
commitid	p4LJxGKbi0BU2cG6;

1.21
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	VK3ncyiP3NS1N4Sy;

1.20
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.19;
commitid	zhW8jJrfVCoAthrR;

1.19
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.18;
commitid	cYQY7jiay4SydLhD;

1.18
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.17;
commitid	Vq8oSnWLkf7dyy0N;

1.17
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.16;
commitid	t9FBKDfc4VDxpEy2;

1.16
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	mdGXHklUZmESVFlY;

1.15
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.14;
commitid	DQakU8LLWV6Iwx84;

1.14
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.13;
commitid	B4dZSbxas1X1IpXI;

1.13
date	2014.04.21.12.22.25;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.11.08.44.37;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.22.08.34.04;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.19.18.22.37;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.19.14.46.31;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.19.11.37.20;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.19.11.20.08;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.15.10.24.41;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.14.13.04.26;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.13.12.21.54;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.13.10.41.11;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.13.10.10.03;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@/*	$OpenBSD: if_vxlan.c,v 1.59 2017/04/11 14:43:49 dhill Exp $	*/

/*
 * Copyright (c) 2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bpfilter.h"
#include "vxlan.h"
#include "vlan.h"
#include "pf.h"
#include "bridge.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>
#include <net/route.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/in_pcb.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#if NBRIDGE > 0
#include <net/if_bridge.h>
#endif

#include <net/if_vxlan.h>

struct vxlan_softc {
	struct arpcom		 sc_ac;
	struct ifmedia		 sc_media;

	struct ip_moptions	 sc_imo;
	void			*sc_ahcookie;
	void			*sc_lhcookie;
	void			*sc_dhcookie;

	struct sockaddr_storage	 sc_src;
	struct sockaddr_storage	 sc_dst;
	in_port_t		 sc_dstport;
	u_int			 sc_rdomain;
	int64_t			 sc_vnetid;
	u_int8_t		 sc_ttl;

	LIST_ENTRY(vxlan_softc)	 sc_entry;
};

void	 vxlanattach(int);
int	 vxlanioctl(struct ifnet *, u_long, caddr_t);
void	 vxlanstart(struct ifnet *);
int	 vxlan_clone_create(struct if_clone *, int);
int	 vxlan_clone_destroy(struct ifnet *);
void	 vxlan_multicast_cleanup(struct ifnet *);
int	 vxlan_multicast_join(struct ifnet *, struct sockaddr *,
	    struct sockaddr *);
int	 vxlan_media_change(struct ifnet *);
void	 vxlan_media_status(struct ifnet *, struct ifmediareq *);
int	 vxlan_config(struct ifnet *, struct sockaddr *, struct sockaddr *);
int	 vxlan_output(struct ifnet *, struct mbuf *);
void	 vxlan_addr_change(void *);
void	 vxlan_if_change(void *);
void	 vxlan_link_change(void *);

int	 vxlan_sockaddr_cmp(struct sockaddr *, struct sockaddr *);
uint16_t vxlan_sockaddr_port(struct sockaddr *);

struct if_clone	vxlan_cloner =
    IF_CLONE_INITIALIZER("vxlan", vxlan_clone_create, vxlan_clone_destroy);

int	 vxlan_enable = 0;
u_long	 vxlan_tagmask;

#define VXLAN_TAGHASHSIZE		 32
#define VXLAN_TAGHASH(tag)		 ((unsigned int)tag & vxlan_tagmask)
LIST_HEAD(vxlan_taghash, vxlan_softc)	*vxlan_tagh, vxlan_any;

void
vxlanattach(int count)
{
	/* Regular vxlan interfaces with a VNI */
	if ((vxlan_tagh = hashinit(VXLAN_TAGHASHSIZE, M_DEVBUF, M_NOWAIT,
	    &vxlan_tagmask)) == NULL)
		panic("vxlanattach: hashinit");

	/* multipoint-to-multipoint interfaces that accept any VNI */
	LIST_INIT(&vxlan_any);

	if_clone_attach(&vxlan_cloner);
}

int
vxlan_clone_create(struct if_clone *ifc, int unit)
{
	struct ifnet		*ifp;
	struct vxlan_softc	*sc;

	if ((sc = malloc(sizeof(*sc),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	sc->sc_imo.imo_membership = malloc(
	    (sizeof(struct in_multi *) * IP_MIN_MEMBERSHIPS), M_IPMOPTS,
	    M_WAITOK|M_ZERO);
	sc->sc_imo.imo_max_memberships = IP_MIN_MEMBERSHIPS;
	sc->sc_dstport = htons(VXLAN_PORT);
	sc->sc_vnetid = VXLAN_VNI_UNSET;

	ifp = &sc->sc_ac.ac_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "vxlan%d", unit);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ether_fakeaddr(ifp);

	ifp->if_softc = sc;
	ifp->if_ioctl = vxlanioctl;
	ifp->if_start = vxlanstart;
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	ifp->if_hardmtu = ETHER_MAX_HARDMTU_LEN;
	ifp->if_capabilities = IFCAP_VLAN_MTU;

	ifmedia_init(&sc->sc_media, 0, vxlan_media_change,
	    vxlan_media_status);
	ifmedia_add(&sc->sc_media, IFM_ETHER | IFM_AUTO, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER | IFM_AUTO);

	if_attach(ifp);
	ether_ifattach(ifp);

#if 0
	/*
	 * Instead of using a decreased MTU of 1450 bytes, prefer
	 * to use the default Ethernet-size MTU of 1500 bytes and to
	 * increase the MTU of the outer transport interfaces to
	 * at least 1550 bytes. The following is disabled by default.
	 */
	ifp->if_mtu = ETHERMTU - sizeof(struct ether_header);
	ifp->if_mtu -= sizeof(struct vxlanudphdr) + sizeof(struct ipovly);
#endif

	LIST_INSERT_HEAD(&vxlan_tagh[VXLAN_TAGHASH(0)], sc, sc_entry);
	vxlan_enable++;

	return (0);
}

int
vxlan_clone_destroy(struct ifnet *ifp)
{
	struct vxlan_softc	*sc = ifp->if_softc;
	int			 s;

	NET_LOCK(s);
	vxlan_multicast_cleanup(ifp);
	NET_UNLOCK(s);

	vxlan_enable--;
	LIST_REMOVE(sc, sc_entry);

	ifmedia_delete_instance(&sc->sc_media, IFM_INST_ANY);
	ether_ifdetach(ifp);
	if_detach(ifp);
	free(sc->sc_imo.imo_membership, M_IPMOPTS, 0);
	free(sc, M_DEVBUF, sizeof(*sc));

	return (0);
}

void
vxlan_multicast_cleanup(struct ifnet *ifp)
{
	struct vxlan_softc	*sc = (struct vxlan_softc *)ifp->if_softc;
	struct ip_moptions	*imo = &sc->sc_imo;
	struct ifnet		*mifp;

	mifp = if_get(imo->imo_ifidx);
	if (mifp != NULL) {
		if (sc->sc_ahcookie != NULL) {
			hook_disestablish(mifp->if_addrhooks, sc->sc_ahcookie);
			sc->sc_ahcookie = NULL;
		}
		if (sc->sc_lhcookie != NULL) {
			hook_disestablish(mifp->if_linkstatehooks,
			    sc->sc_lhcookie);
			sc->sc_lhcookie = NULL;
		}
		if (sc->sc_dhcookie != NULL) {
			hook_disestablish(mifp->if_detachhooks,
			    sc->sc_dhcookie);
			sc->sc_dhcookie = NULL;
		}

		if_put(mifp);
	}

	if (imo->imo_num_memberships > 0) {
		in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
		imo->imo_ifidx = 0;
	}
}

int
vxlan_multicast_join(struct ifnet *ifp, struct sockaddr *src,
    struct sockaddr *dst)
{
	struct vxlan_softc	*sc = ifp->if_softc;
	struct ip_moptions	*imo = &sc->sc_imo;
	struct sockaddr_in	*src4, *dst4;
#ifdef INET6
	struct sockaddr_in6	*dst6;
#endif /* INET6 */
	struct ifaddr		*ifa;
	struct ifnet		*mifp;

	switch (dst->sa_family) {
	case AF_INET:
		dst4 = satosin(dst);
		if (!IN_MULTICAST(dst4->sin_addr.s_addr))
			return (0);
		break;
#ifdef INET6
	case AF_INET6:
		dst6 = satosin6(dst);
		if (!IN6_IS_ADDR_MULTICAST(&dst6->sin6_addr))
			return (0);

		/* Multicast mode is currently not supported for IPv6 */
		return (EAFNOSUPPORT);
#endif /* INET6 */
	default:
		return (EAFNOSUPPORT);
	}

	src4 = satosin(src);
	dst4 = satosin(dst);

	if (src4->sin_addr.s_addr == INADDR_ANY ||
	    IN_MULTICAST(src4->sin_addr.s_addr))
		return (EINVAL);
	if ((ifa = ifa_ifwithaddr(src, sc->sc_rdomain)) == NULL ||
	    (mifp = ifa->ifa_ifp) == NULL ||
	    (mifp->if_flags & IFF_MULTICAST) == 0)
		return (EADDRNOTAVAIL);

	if ((imo->imo_membership[0] =
	    in_addmulti(&dst4->sin_addr, mifp)) == NULL)
		return (ENOBUFS);

	imo->imo_num_memberships++;
	imo->imo_ifidx = mifp->if_index;
	if (sc->sc_ttl > 0)
		imo->imo_ttl = sc->sc_ttl;
	else
		imo->imo_ttl = IP_DEFAULT_MULTICAST_TTL;
	imo->imo_loop = 0;

	/*
	 * Use interface hooks to track any changes on the interface
	 * that is used to send out the tunnel traffic as multicast.
	 */
	if ((sc->sc_ahcookie = hook_establish(mifp->if_addrhooks,
	    0, vxlan_addr_change, sc)) == NULL ||
	    (sc->sc_lhcookie = hook_establish(mifp->if_linkstatehooks,
	    0, vxlan_link_change, sc)) == NULL ||
	    (sc->sc_dhcookie = hook_establish(mifp->if_detachhooks,
	    0, vxlan_if_change, sc)) == NULL)
		panic("%s: cannot allocate interface hook",
		    mifp->if_xname);

	return (0);
}

void
vxlanstart(struct ifnet *ifp)
{
	struct mbuf		*m;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			return;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		vxlan_output(ifp, m);
	}
}

int
vxlan_config(struct ifnet *ifp, struct sockaddr *src, struct sockaddr *dst)
{
	struct vxlan_softc	*sc = (struct vxlan_softc *)ifp->if_softc;
	int			 reset = 0, error, af;
	socklen_t		 slen;
	in_port_t		 port;
	struct vxlan_taghash	*tagh;

	if (src != NULL && dst != NULL) {
		if ((af = src->sa_family) != dst->sa_family)
			return (EAFNOSUPPORT);
	} else {
		/* Reset current configuration */
		af = sc->sc_src.ss_family;
		src = sstosa(&sc->sc_src);
		dst = sstosa(&sc->sc_dst);
		reset = 1;
	}

	switch (af) {
	case AF_INET:
		slen = sizeof(struct sockaddr_in);
		break;
#ifdef INET6
	case AF_INET6:
		slen = sizeof(struct sockaddr_in6);
		break;
#endif /* INET6 */
	default:
		return (EAFNOSUPPORT);
	}

	if (src->sa_len != slen || dst->sa_len != slen)
		return (EINVAL);

	vxlan_multicast_cleanup(ifp);

	/* returns without error if multicast is not configured */
	if ((error = vxlan_multicast_join(ifp, src, dst)) != 0)
		return (error);

	if ((port = vxlan_sockaddr_port(dst)) != 0)
		sc->sc_dstport = port;

	if (!reset) {
		bzero(&sc->sc_src, sizeof(sc->sc_src));
		bzero(&sc->sc_dst, sizeof(sc->sc_dst));
		memcpy(&sc->sc_src, src, src->sa_len);
		memcpy(&sc->sc_dst, dst, dst->sa_len);
	}

	if (sc->sc_vnetid == VXLAN_VNI_ANY) {
		/*
		 * If the interface accepts any VNI, put it into a separate
		 * list that is not part of the main hash.
		 */
		tagh = &vxlan_any;
	} else
		tagh = &vxlan_tagh[VXLAN_TAGHASH(sc->sc_vnetid)];

	LIST_REMOVE(sc, sc_entry);
	LIST_INSERT_HEAD(tagh, sc, sc_entry);

	return (0);
}

int
vxlanioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct vxlan_softc	*sc = (struct vxlan_softc *)ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	struct if_laddrreq	*lifr = (struct if_laddrreq *)data;
	int			 error = 0;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			ifp->if_flags |= IFF_RUNNING;
		} else {
			ifp->if_flags &= ~IFF_RUNNING;
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	case SIOCSLIFPHYADDR:
		error = vxlan_config(ifp,
		    sstosa(&lifr->addr),
		    sstosa(&lifr->dstaddr));
		break;

	case SIOCDIFPHYADDR:
		vxlan_multicast_cleanup(ifp);
		bzero(&sc->sc_src, sizeof(sc->sc_src));
		bzero(&sc->sc_dst, sizeof(sc->sc_dst));
		sc->sc_dstport = htons(VXLAN_PORT);
		break;

	case SIOCGLIFPHYADDR:
		if (sc->sc_dst.ss_family == AF_UNSPEC) {
			error = EADDRNOTAVAIL;
			break;
		}
		bzero(&lifr->addr, sizeof(lifr->addr));
		bzero(&lifr->dstaddr, sizeof(lifr->dstaddr));
		memcpy(&lifr->addr, &sc->sc_src, sc->sc_src.ss_len);
		memcpy(&lifr->dstaddr, &sc->sc_dst, sc->sc_dst.ss_len);
		break;

	case SIOCSLIFPHYRTABLE:
		if (ifr->ifr_rdomainid < 0 ||
		    ifr->ifr_rdomainid > RT_TABLEID_MAX ||
		    !rtable_exists(ifr->ifr_rdomainid)) {
			error = EINVAL;
			break;
		}
		sc->sc_rdomain = ifr->ifr_rdomainid;
		(void)vxlan_config(ifp, NULL, NULL);
		break;

	case SIOCGLIFPHYRTABLE:
		ifr->ifr_rdomainid = sc->sc_rdomain;
		break;

	case SIOCSLIFPHYTTL:
		if (ifr->ifr_ttl < 0 || ifr->ifr_ttl > 0xff) {
			error = EINVAL;
			break;
		}
		if (sc->sc_ttl == (u_int8_t)ifr->ifr_ttl)
			break;
		sc->sc_ttl = (u_int8_t)(ifr->ifr_ttl);
		(void)vxlan_config(ifp, NULL, NULL);
		break;

	case SIOCGLIFPHYTTL:
		ifr->ifr_ttl = (int)sc->sc_ttl;
		break;

	case SIOCSVNETID:
		if (sc->sc_vnetid == ifr->ifr_vnetid)
			break;

		if ((ifr->ifr_vnetid != VXLAN_VNI_ANY) &&
		    (ifr->ifr_vnetid > VXLAN_VNI_MAX ||
		     ifr->ifr_vnetid < VXLAN_VNI_MIN)) {
			error = EINVAL;
			break;
		}

		sc->sc_vnetid = (int)ifr->ifr_vnetid;
		(void)vxlan_config(ifp, NULL, NULL);
		break;

	case SIOCGVNETID:
		if ((sc->sc_vnetid != VXLAN_VNI_ANY) &&
		    (sc->sc_vnetid > VXLAN_VNI_MAX ||
		     sc->sc_vnetid < VXLAN_VNI_MIN)) {
			error = EADDRNOTAVAIL;
			break;
		}

		ifr->ifr_vnetid = sc->sc_vnetid;
		break;

	case SIOCDVNETID:
		sc->sc_vnetid = VXLAN_VNI_UNSET;
		(void)vxlan_config(ifp, NULL, NULL);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
		break;
	}

	return (error);
}

int
vxlan_media_change(struct ifnet *ifp)
{
	return (0);
}

void
vxlan_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	imr->ifm_status = IFM_AVALID | IFM_ACTIVE;
}

int
vxlan_sockaddr_cmp(struct sockaddr *srcsa, struct sockaddr *dstsa)
{
	struct sockaddr_in	*src4, *dst4;
#ifdef INET6
	struct sockaddr_in6	*src6, *dst6;
#endif /* INET6 */

	if (srcsa->sa_family != dstsa->sa_family)
		return (1);

	switch (dstsa->sa_family) {
	case AF_INET:
		src4 = satosin(srcsa);
		dst4 = satosin(dstsa);
		if (src4->sin_addr.s_addr == dst4->sin_addr.s_addr)
			return (0);
#ifdef INET6
	case AF_INET6:
		src6 = satosin6(srcsa);
		dst6 = satosin6(dstsa);
		if (IN6_ARE_ADDR_EQUAL(&src6->sin6_addr, &dst6->sin6_addr) &&
		    src6->sin6_scope_id == dst6->sin6_scope_id)
			return (0);
#endif /* INET6 */
	}

	return (1);
}

uint16_t
vxlan_sockaddr_port(struct sockaddr *sa)
{
	struct sockaddr_in	*sin4;
#ifdef INET6
	struct sockaddr_in6	*sin6;
#endif /* INET6 */

	switch (sa->sa_family) {
	case AF_INET:
		sin4 = satosin(sa);
		return (sin4->sin_port);
#ifdef INET6
	case AF_INET6:
		sin6 = satosin6(sa);
		return (sin6->sin6_port);
#endif /* INET6 */
	default:
		break;
	}

	return (0);
}

int
vxlan_lookup(struct mbuf *m, struct udphdr *uh, int iphlen,
    struct sockaddr *srcsa, struct sockaddr *dstsa)
{
	struct mbuf_list	 ml = MBUF_LIST_INITIALIZER();
	struct vxlan_softc	*sc = NULL, *sc_cand = NULL;
	struct vxlan_header	 v;
	int			 vni;
	struct ifnet		*ifp;
	int			 skip;
#if NBRIDGE > 0
	struct bridge_tunneltag	*brtag;
#endif
	struct mbuf		*n;
	int			 off;

	/* XXX Should verify the UDP port first before copying the packet */
	skip = iphlen + sizeof(*uh);
	if (m->m_pkthdr.len - skip < sizeof(v))
		return (0);
	m_copydata(m, skip, sizeof(v), (caddr_t)&v);
	skip += sizeof(v);

	if (v.vxlan_flags & htonl(VXLAN_RESERVED1) ||
	    v.vxlan_id & htonl(VXLAN_RESERVED2))
		return (0);

	vni = ntohl(v.vxlan_id) >> VXLAN_VNI_S;
	if ((v.vxlan_flags & htonl(VXLAN_FLAGS_VNI)) == 0) {
		if (vni != 0)
			return (0);

		vni = VXLAN_VNI_UNSET;
	}

	/* First search for a vxlan(4) interface with the packet's VNI */
	LIST_FOREACH(sc, &vxlan_tagh[VXLAN_TAGHASH(vni)], sc_entry) {
		if ((uh->uh_dport == sc->sc_dstport) &&
		    vni == sc->sc_vnetid &&
		    sc->sc_rdomain == rtable_l2(m->m_pkthdr.ph_rtableid)) {
			sc_cand = sc;
			if (vxlan_sockaddr_cmp(srcsa, sstosa(&sc->sc_dst)) == 0)
				goto found;
		}
	}

	/*
	 * Now loop through all the vxlan(4) interfaces that are configured
	 * to accept any VNI and operating in multipoint-to-multipoint mode
	 * that is used in combination with bridge(4) or switch(4).
	 * If a vxlan(4) interface has been found for the packet's VNI, this
	 * code is not reached as the other interface is more specific.
	 */
	LIST_FOREACH(sc, &vxlan_any, sc_entry) {
		if ((uh->uh_dport == sc->sc_dstport) &&
		    (sc->sc_rdomain == rtable_l2(m->m_pkthdr.ph_rtableid))) {
			sc_cand = sc;
			goto found;
		}
	}

	if (sc_cand) {
		sc = sc_cand;
		goto found;
	}

	/* not found */
	return (0);

 found:
	if (m->m_pkthdr.len < skip + sizeof(struct ether_header)) {
		m_freem(m);
		return (EINVAL);
	}

	m_adj(m, skip);
	ifp = &sc->sc_ac.ac_if;

#if NBRIDGE > 0
	/* Store the tunnel src/dst IP and vni for the bridge or switch */
	if ((ifp->if_bridgeport != NULL || ifp->if_switchport != NULL) &&
	    srcsa->sa_family != AF_UNSPEC &&
	    ((brtag = bridge_tunneltag(m)) != NULL)) {
		memcpy(&brtag->brtag_peer.sa, srcsa, srcsa->sa_len);
		memcpy(&brtag->brtag_local.sa, dstsa, dstsa->sa_len);
		brtag->brtag_id = vni;
	}
#endif

	m->m_flags &= ~(M_MCAST|M_BCAST);

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif
	if ((m->m_len < sizeof(struct ether_header)) &&
	    (m = m_pullup(m, sizeof(struct ether_header))) == NULL)
		return (ENOBUFS);

	n = m_getptr(m, sizeof(struct ether_header), &off);
	if (n == NULL) {
		m_freem(m);
		return (EINVAL);
	}
	if (!ALIGNED_POINTER(mtod(n, caddr_t) + off, uint32_t)) {
		n = m_dup_pkt(m, ETHER_ALIGN, M_NOWAIT);
		/* Dispose of the original mbuf chain */
		m_freem(m);
		if (n == NULL)
			return (ENOBUFS);
		m = n;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);

	/* success */
	return (1);
}

struct mbuf *
vxlan_encap4(struct ifnet *ifp, struct mbuf *m,
    struct sockaddr *src, struct sockaddr *dst)
{
	struct vxlan_softc	*sc = (struct vxlan_softc *)ifp->if_softc;
	struct ip		*ip;

	M_PREPEND(m, sizeof(*ip), M_DONTWAIT);
	if (m == NULL)
		return (NULL);

	ip = mtod(m, struct ip *);
	ip->ip_v = IPVERSION;
	ip->ip_hl = sizeof(struct ip) >> 2;
	ip->ip_id = htons(ip_randomid());
	ip->ip_off = 0; /* htons(IP_DF); XXX should we disallow IP fragments? */
	ip->ip_p = IPPROTO_UDP;
	ip->ip_tos = IPTOS_LOWDELAY;
	ip->ip_len = htons(m->m_pkthdr.len);

	ip->ip_src = satosin(src)->sin_addr;
	ip->ip_dst = satosin(dst)->sin_addr;

	if (sc->sc_ttl > 0)
		ip->ip_ttl = sc->sc_ttl;
	else
		ip->ip_ttl = IPDEFTTL;

	return (m);
}

#ifdef INET6
struct mbuf *
vxlan_encap6(struct ifnet *ifp, struct mbuf *m,
    struct sockaddr *src, struct sockaddr *dst)
{
	struct vxlan_softc	*sc = (struct vxlan_softc *)ifp->if_softc;
	struct ip6_hdr		*ip6;
	struct in6_addr		*in6a;

	M_PREPEND(m, sizeof(struct ip6_hdr), M_DONTWAIT);
	if (m == NULL)
		return (NULL);

	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_flow = 0;
	ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc |= IPV6_VERSION;
	ip6->ip6_nxt = IPPROTO_UDP;
	ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(struct ip6_hdr));
	if (in6_embedscope(&ip6->ip6_src, satosin6(src), NULL) != 0)
		goto drop;
	if (in6_embedscope(&ip6->ip6_dst, satosin6(dst), NULL) != 0)
		goto drop;

	if (sc->sc_ttl > 0)
		ip6->ip6_hlim = sc->sc_ttl;
	else
		ip6->ip6_hlim = ip6_defhlim;

	if (IN6_IS_ADDR_UNSPECIFIED(&satosin6(src)->sin6_addr)) {
		if (in6_selectsrc(&in6a, satosin6(dst), NULL,
		    sc->sc_rdomain) != 0)
			goto drop;

		ip6->ip6_src = *in6a;
	}

	/*
	 * The UDP checksum of VXLAN packets should be set to zero,
	 * but the IPv6 UDP checksum is not optional.  There is an RFC 6539
	 * to relax the IPv6 UDP checksum requirement for tunnels, but it
	 * is currently not supported by most implementations.
	 */
	m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;

	return (m);

drop:
	m_freem(m);
	return (NULL);
}
#endif /* INET6 */

int
vxlan_output(struct ifnet *ifp, struct mbuf *m)
{
	struct vxlan_softc	*sc = (struct vxlan_softc *)ifp->if_softc;
	struct vxlanudphdr	*vu;
	struct sockaddr		*src, *dst;
#if NBRIDGE > 0
	struct bridge_tunneltag	*brtag;
#endif
	int			 error, af;
	uint32_t		 tag;
	struct mbuf		*m0;

	/* VXLAN header */
	MGETHDR(m0, M_DONTWAIT, m->m_type);
	if (m0 == NULL) {
		ifp->if_oerrors++;
		return (ENOBUFS);
	}
	M_MOVE_PKTHDR(m0, m);
	m0->m_next = m;
	m = m0;
	MH_ALIGN(m, sizeof(*vu));
	m->m_len = sizeof(*vu);
	m->m_pkthdr.len += sizeof(*vu);

	src = sstosa(&sc->sc_src);
	dst = sstosa(&sc->sc_dst);
	af = src->sa_family;

	vu = mtod(m, struct vxlanudphdr *);
	vu->vu_u.uh_sport = sc->sc_dstport;
	vu->vu_u.uh_dport = sc->sc_dstport;
	vu->vu_u.uh_ulen = htons(m->m_pkthdr.len);
	vu->vu_u.uh_sum = 0;
	tag = sc->sc_vnetid;

#if NBRIDGE > 0
	if ((brtag = bridge_tunnel(m)) != NULL) {
		dst = &brtag->brtag_peer.sa;

		/* If accepting any VNI, source ip address is from brtag */
		if (sc->sc_vnetid == VXLAN_VNI_ANY) {
			src = &brtag->brtag_local.sa;
			tag = (uint32_t)brtag->brtag_id;
			af = src->sa_family;
		}

		if (dst->sa_family != af) {
			ifp->if_oerrors++;
			m_freem(m);
			return (EINVAL);
		}
	} else
#endif
	if (sc->sc_vnetid == VXLAN_VNI_ANY) {
		/*
		 * If accepting any VNI, build the vxlan header only by
		 * bridge_tunneltag or drop packet if the tag does not exist.
		 */
		ifp->if_oerrors++;
		m_freem(m);
		return (ENETUNREACH);
	}

	if (sc->sc_vnetid != VXLAN_VNI_UNSET) {
		vu->vu_v.vxlan_flags = htonl(VXLAN_FLAGS_VNI);
		vu->vu_v.vxlan_id = htonl(tag << VXLAN_VNI_S);
	} else {
		vu->vu_v.vxlan_flags = htonl(0);
		vu->vu_v.vxlan_id = htonl(0);
	}

	switch (af) {
	case AF_INET:
		m = vxlan_encap4(ifp, m, src, dst);
		break;
#ifdef INET6
	case AF_INET6:
		m = vxlan_encap6(ifp, m, src, dst);
		break;
#endif /* INET6 */
	default:
		m_freem(m);
		m = NULL;
	}

	if (m == NULL) {
		ifp->if_oerrors++;
		return (ENOBUFS);
	}

#if NBRIDGE > 0
	if (brtag != NULL)
		bridge_tunneluntag(m);
#endif

	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;

	m->m_pkthdr.ph_rtableid = sc->sc_rdomain;

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif

	switch (af) {
	case AF_INET:
		error = ip_output(m, NULL, NULL, IP_RAWOUTPUT,
		    &sc->sc_imo, NULL, 0);
		break;
#ifdef INET6
	case AF_INET6:
		error = ip6_output(m, 0, NULL, IPV6_MINMTU, 0, NULL);
		break;
#endif /* INET6 */
	default:
		m_freem(m);
		error = EAFNOSUPPORT;
	}

	if (error)
		ifp->if_oerrors++;

	return (error);
}

void
vxlan_addr_change(void *arg)
{
	struct vxlan_softc	*sc = arg;
	struct ifnet		*ifp = &sc->sc_ac.ac_if;
	int			 error;

	/*
	 * Reset the configuration after resume or any possible address
	 * configuration changes.
	 */
	if ((error = vxlan_config(ifp, NULL, NULL))) {
		/*
		 * The source address of the tunnel can temporarily disappear,
		 * after a link state change when running the DHCP client,
		 * so keep it configured.
		 */
	}
}

void
vxlan_if_change(void *arg)
{
	struct vxlan_softc	*sc = arg;
	struct ifnet		*ifp = &sc->sc_ac.ac_if;

	/*
	 * Reset the configuration after the parent interface disappeared.
	 */
	vxlan_multicast_cleanup(ifp);
	memset(&sc->sc_src, 0, sizeof(sc->sc_src));
	memset(&sc->sc_dst, 0, sizeof(sc->sc_dst));
	sc->sc_dstport = htons(VXLAN_PORT);
}

void
vxlan_link_change(void *arg)
{
	struct vxlan_softc	*sc = arg;
	struct ifnet		*ifp = &sc->sc_ac.ac_if;

	/*
	 * The machine might have lost its multicast associations after
	 * link state changes.  This fixes a problem with VMware after
	 * suspend/resume of the host or guest.
	 */
	(void)vxlan_config(ifp, NULL, NULL);
}
@


1.59
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.58 2017/04/09 17:57:58 dhill Exp $	*/
d337 2
a338 2
		src = (struct sockaddr *)&sc->sc_src;
		dst = (struct sockaddr *)&sc->sc_dst;
d421 2
a422 2
		    (struct sockaddr *)&lifr->addr,
		    (struct sockaddr *)&lifr->dstaddr);
d619 1
a619 2
			if (vxlan_sockaddr_cmp(srcsa,
			    (struct sockaddr *)&sc->sc_dst) == 0)
d807 2
a808 2
	src = (struct sockaddr *)&sc->sc_src;
	dst = (struct sockaddr *)&sc->sc_dst;
@


1.58
log
@Use mallocarray to allocate multicast group memberships.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.57 2017/01/22 10:17:39 dlg Exp $	*/
d132 2
a133 2
	sc->sc_imo.imo_membership = mallocarray(
	    IP_MIN_MEMBERSHIPS, sizeof(struct in_multi *), M_IPMOPTS,
@


1.57
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.56 2017/01/04 12:49:49 mikeb Exp $	*/
d132 2
a133 2
	sc->sc_imo.imo_membership = malloc(
	    (sizeof(struct in_multi *) * IP_MIN_MEMBERSHIPS), M_IPMOPTS,
@


1.56
log
@As noticed by bluhm@@ the netlock is required for the multicast cleanup

While here, remove unnecessary splnet's.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.55 2017/01/03 15:35:34 reyk Exp $	*/
a311 2

		ifp->if_opackets++;
@


1.55
log
@Don't try to reconfigure the multicast group in the detach handler of
the multicast interface - simply clear the VXLAN configuration when
the associated multicast interface disappears.  This fixes some
locking and recursion problems.

OK mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.54 2016/12/13 06:51:11 dlg Exp $	*/
d183 1
a183 1
	s = splnet();
d185 1
a185 1
	splx(s);
d397 1
a397 1
	int			 error = 0, s;
a421 1
		s = splnet();
a424 1
		splx(s);
a427 1
		s = splnet();
a431 1
		splx(s);
a451 1
		s = splnet();
a453 1
		splx(s);
a466 1
		s = splnet();
a468 1
		splx(s);
a485 1
		s = splnet();
a487 1
		splx(s);
a501 1
		s = splnet();
a503 1
		splx(s);
d916 1
a916 1
	int			 s, error;
a921 1
	s = splnet();
a928 1
	splx(s);
a935 1
	int			 s;
a939 1
	s = splnet();
a943 1
	splx(s);
a950 1
	int			 s;
a956 1
	s = splnet();
a957 1
	splx(s);
@


1.54
log
@make v6 tunnel address handling consider ipv6 scope.

an earlier version of this diff was ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.53 2016/12/02 11:16:04 mpi Exp $	*/
d950 1
a950 1
	int			 s, error;
d956 4
a959 5
	if ((error = vxlan_config(ifp, NULL, NULL)) != 0) {
		/* The configured tunnel addresses are invalid, remove them */
		bzero(&sc->sc_src, sizeof(sc->sc_src));
		bzero(&sc->sc_dst, sizeof(sc->sc_dst));
	}
@


1.53
log
@Rremoves 'struct route_in6 *' argument from in6_selectsrc().

Move the corresponding code in in6_pcbselsrc().  This reduces
differences with IPv4 and will help us to get rid of 'struct route*'.

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.52 2016/11/29 10:09:57 reyk Exp $	*/
d559 2
a560 1
		if (IN6_ARE_ADDR_EQUAL(&src6->sin6_addr, &dst6->sin6_addr))
a750 1
	int			 error;
d762 4
a765 2
	ip6->ip6_src  = satosin6(src)->sin6_addr;
	ip6->ip6_dst = satosin6(dst)->sin6_addr;
d773 4
a776 6
		error = in6_selectsrc(&in6a, satosin6(dst), NULL,
		    sc->sc_rdomain);
		if (error != 0) {
			m_freem(m);
			return (NULL);
		}
d789 4
@


1.52
log
@For virtual Ethernet drivers that don't have a technical limit of the
hardmtu, pick a value of 65435 that leaves space for some
encapsulation and almost a complete max-IP packet.  After some
discussion we picked this arbitrary value.

OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.51 2016/10/25 16:31:08 bluhm Exp $	*/
d771 1
a771 1
		error = in6_selectsrc(&in6a, satosin6(dst), NULL, NULL,
@


1.51
log
@Make kernel without INET6 compile again.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.50 2016/10/14 10:25:02 mikeb Exp $	*/
d149 1
a149 1
	ifp->if_hardmtu = 0xffff;
@


1.50
log
@Fulfil our contractual obligations with ether_input

Since ether_input expects the m_data to point directly at the Ethernet
header and most upper layer protocols immediately following Ethernet
expect their headers to be aligned to the 4 byte boundary, we need to
ensure that the decapsulated VXLAN packet payload satisfies these
requirements.

prompted by a diff by vgross@@, with input from dlg@@, ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.49 2016/10/07 06:16:03 yasuoka Exp $	*/
d239 1
d241 1
d245 2
a246 1
	if (dst->sa_family == AF_INET) {
d250 3
a252 1
	} else if (dst->sa_family == AF_INET6) {
d259 3
d344 2
a345 1
	if (af == AF_INET)
d347 3
a349 1
	else if (af == AF_INET6)
d351 3
a353 1
	else
d355 1
d542 1
d544 1
d555 1
d561 1
d571 1
d573 1
d579 1
d583 1
d742 1
d790 1
d865 2
a866 1
	if (af == AF_INET)
d868 3
a870 1
	else if (af == AF_INET6)
d872 3
a874 1
	else {
d898 2
a899 1
	if (af == AF_INET)
d902 3
a904 1
	else
d906 6
@


1.49
log
@Fix vxlan_lookup() to comply the assumption of ether_input().  Put the
entire ethernet header on first mbuf and align 32bit at the payload.
Also fix the vxlan_output() not to cause an alignment fault.  Use a
new mbuf for VXLAN header instead of M_PREPEND to make sure that the
mbuf is aligned 32bit.  This is required to align 32 bit at the outer
IP header.

input vgross mikeb
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.48 2016/09/30 10:22:05 yasuoka Exp $	*/
d582 2
a583 1
	struct mbuf		*m0;
d640 2
a641 1
	if (m->m_pkthdr.len < skip + sizeof(struct ether_header))
d643 1
d664 2
a665 1
	if ((m = m_pullup(m, sizeof(struct ether_header))) == NULL)
d668 10
a677 5
	if (!ALIGNED_POINTER(mtod(m, caddr_t) + ETHER_HDR_LEN, uint32_t)) {
		m0 = m;
		m = m_dup_pkt(m0, ETHER_ALIGN, M_NOWAIT);
		m_freem(m0);
		if (m == NULL)
d679 1
@


1.48
log
@Accept a packet smaller than ETHERMIN.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.47 2016/09/29 11:37:44 reyk Exp $	*/
d582 1
d661 10
d769 1
d772 2
a773 2
	M_PREPEND(m, sizeof(*vu), M_DONTWAIT);
	if (m == NULL) {
d777 6
@


1.47
log
@Rename brtag_src/brtag_dst to brtag_peer/brtag_local to avoid
confusion about the tunnel endpoints when responding to the peer.

OK yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.46 2016/09/28 14:26:43 yasuoka Exp $	*/
d638 1
a638 1
	if (m->m_pkthdr.len < skip + sizeof(struct ether_header) + ETHERMIN)
@


1.46
log
@Fix vxlan to use the destination address correctly.

Use the dst of the bridge_tunneltag for src on vxlan output and vice
versa.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.45 2016/09/28 14:10:35 yasuoka Exp $	*/
d649 2
a650 2
		memcpy(&brtag->brtag_src.sa, srcsa, srcsa->sa_len);
		memcpy(&brtag->brtag_dst.sa, dstsa, dstsa->sa_len);
d779 1
a779 1
		dst = &brtag->brtag_src.sa;
d783 1
a783 1
			src = &brtag->brtag_dst.sa;
@


1.45
log
@Fix the way of checking the length of vxlan packet and made it strict.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.44 2016/09/04 11:14:44 reyk Exp $	*/
d779 1
a779 1
		dst = &brtag->brtag_dst.sa;
d783 1
a783 1
			src = &brtag->brtag_src.sa;
@


1.44
log
@Remove the IFF_LINK0 option to send the response back to the peer's
UDP src port - the VXLAN RFC clearly says that packet should be send
to the configured VXLAN port (4789).

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.43 2016/09/03 13:46:57 reyk Exp $	*/
a578 1
	struct ether_header	*eh;
d638 3
a642 3

	if ((eh = mtod(m, struct ether_header *)) == NULL)
		return (EINVAL);
@


1.43
log
@Add support for a multipoint-to-multipoint mode in vxlan(4).  In this
mode, vxlan(4) must be configured to accept any virtual network
identifier with "vnetid any" and added to a bridge(4) or switch(4).
This way the driver will dynamically learn the tunnel endpoints and
their vnetids for the responses and can be used to dynamically bridge
between VXLANs.  It is also being used in combination with switch(4)
and the OpenFlow tunnel classifiers.

With input from yasuoka@@ goda@@
OK deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.42 2016/08/07 14:26:26 reyk Exp $	*/
a793 8

		/*
		 * If the LINK0 flag is set, send the packet back to
		 * the original source port of the endport, otherwise use
		 * the configured VXLAN port.
		 */
		if (ifp->if_flags & IFF_LINK0)
			vu->vu_u.uh_dport = vxlan_sockaddr_port(dst);
@


1.42
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.41 2016/08/07 13:49:12 reyk Exp $	*/
d73 1
a73 1
	int			 sc_vnetid;
d106 1
a106 1
LIST_HEAD(vxlan_taghash, vxlan_softc)	*vxlan_tagh;
d111 1
d116 3
d323 1
d362 9
d372 1
a372 2
	LIST_INSERT_HEAD(&vxlan_tagh[VXLAN_TAGHASH(sc->sc_vnetid)],
	    sc, sc_entry);
d470 6
a475 1
		if (ifr->ifr_vnetid > VXLAN_VNI_MAX) {
d479 1
d487 3
a489 1
		if (sc->sc_vnetid == VXLAN_VNI_UNSET) {
d493 2
a494 1
		ifr->ifr_vnetid = (uint32_t)sc->sc_vnetid;
a520 1
	imr->ifm_active = IFM_ETHER | IFM_AUTO;
d571 1
a571 1
    struct sockaddr *srcsa)
d581 1
a581 1
	struct sockaddr		*sa;
d603 1
d615 15
d646 2
a647 2
	/* Store the peer IP address for the bridge */
	if (ifp->if_bridgeport != NULL &&
d649 5
a653 2
	    (sa = bridge_tunneltag(m, srcsa->sa_family)) != NULL)
		memcpy(sa, srcsa, sa->sa_len);
d755 1
a755 1
	struct sockaddr		*brtag;
d758 1
d776 1
d780 8
a787 1
		dst = brtag;
d802 10
a812 1
#endif
d816 1
a816 1
		vu->vu_v.vxlan_id = htonl(sc->sc_vnetid << VXLAN_VNI_S);
@


1.41
log
@Define VXLAN_VNI_UNSET and VXLAN_VNI_MAX instead of using magic numbers.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.40 2016/08/06 14:33:33 reyk Exp $	*/
d348 1
a348 1
		sc->sc_dstport = port;		
@


1.40
log
@Add support for IPv6 tunnel endpoints.  This currently only works for
unicast mode, multicast is not yet supported.

	ifconfig vxlan0 tunnel fd00::1 fd00::2

Roughly based on an earlier diff by goda@@
OK yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.39 2016/08/06 14:29:48 reyk Exp $	*/
d133 1
a133 1
	sc->sc_vnetid = -1;
d457 1
a457 1
		if (ifr->ifr_vnetid > 0x00ffffff) {
d468 1
a468 1
		if (sc->sc_vnetid == -1) {
d477 1
a477 1
		sc->sc_vnetid = -1;
d579 1
a579 1
		vni = -1;
d756 1
a756 1
	if (sc->sc_vnetid != -1) {
@


1.39
log
@Fix multicast mode (destination is a multicast IP): the BCAST and
MCAST flags have to be cleared from the mbuf after decapsulating
packets.  This fixes tunneled broadcast packets, eg. ARP.  It used to
work before the input path was changed the flags got cleared later in
the stack.

OK yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.38 2016/04/13 11:41:15 mpi Exp $	*/
d85 2
a86 2
int	 vxlan_multicast_join(struct ifnet *, struct sockaddr_in *,
	    struct sockaddr_in *);
d95 3
d164 1
a164 1
	ifp->if_mtu -= sizeof(struct vxlanudpiphdr);
d229 2
a230 2
vxlan_multicast_join(struct ifnet *ifp, struct sockaddr_in *src,
    struct sockaddr_in *dst)
d234 2
d239 15
a253 2
	if (!IN_MULTICAST(dst->sin_addr.s_addr))
		return (0);
d255 2
a256 2
	if (src->sin_addr.s_addr == INADDR_ANY ||
	    IN_MULTICAST(src->sin_addr.s_addr))
d258 1
a258 1
	if ((ifa = ifa_ifwithaddr(sintosa(src), sc->sc_rdomain)) == NULL ||
d264 1
a264 1
	    in_addmulti(&dst->sin_addr, mifp)) == NULL)
d316 3
a318 2
	struct sockaddr_in	*src4, *dst4;
	int			 reset = 0, error;
d321 1
a321 2
		/* XXX inet6 is not supported */
		if (src->sa_family != AF_INET || dst->sa_family != AF_INET)
d325 1
d331 6
a336 2
	src4 = satosin(src);
	dst4 = satosin(dst);
d338 1
a338 1
	if (src4->sin_len != sizeof(*src4) || dst4->sin_len != sizeof(*dst4))
d343 6
a348 6
	if (IN_MULTICAST(dst4->sin_addr.s_addr)) {
		if ((error = vxlan_multicast_join(ifp, src4, dst4)) != 0)
			return (error);
	}
	if (dst4->sin_port)
		sc->sc_dstport = dst4->sin_port;
d504 45
a558 2
	struct sockaddr_in	*srcsin4, *scsin4;
	struct sockaddr_in6	*srcsin6, *scsin6;
d587 3
a589 18
			switch (srcsa->sa_family) {
			case AF_INET:
				srcsin4 = satosin(srcsa);
				scsin4 = satosin(
				    (struct sockaddr *)&sc->sc_dst);
				if (srcsin4->sin_addr.s_addr ==
				    scsin4->sin_addr.s_addr)
					goto found;
				break;
			case AF_INET6:
				srcsin6 = satosin6(srcsa);
				scsin6 = satosin6(
				    (struct sockaddr *)&sc->sc_dst);
				if (IN6_ARE_ADDR_EQUAL(
				    &srcsin6->sin6_addr, &scsin6->sin6_addr))
					goto found;
				break;
			}
d629 3
a631 2
int
vxlan_output(struct ifnet *ifp, struct mbuf *m)
a633 3
	struct udpiphdr		*ui;
	struct vxlanudpiphdr	*vi;
	u_int16_t		 len = m->m_pkthdr.len;
a634 13
#if NBRIDGE > 0
	struct sockaddr_in	*sin;
#endif
	int			 error;

	/* VXLAN header */
	M_PREPEND(m, sizeof(*vi), M_DONTWAIT);
	if (m == NULL) {
		ifp->if_oerrors++;
		return (ENOBUFS);
	}

	len += sizeof(struct vxlan_header);
d636 3
a638 7
	ui = mtod(m, struct udpiphdr *);
	ui->ui_pr = IPPROTO_UDP;
	ui->ui_src = ((struct sockaddr_in *)&sc->sc_src)->sin_addr;
	ui->ui_dst = ((struct sockaddr_in *)&sc->sc_dst)->sin_addr;
	ui->ui_sport = sc->sc_dstport;
	ui->ui_dport = sc->sc_dstport;
	ui->ui_ulen = htons(sizeof(struct udphdr) + len);
d640 1
a640 1
	ip = (struct ip *)ui;
d645 1
d647 5
a651 1
	ip->ip_len = htons(sizeof(struct udpiphdr) + len);
d657 57
d715 30
a744 3
	if ((sin = satosin(bridge_tunnel(m))) != NULL &&
	    sin->sin_family == AF_INET) {
		ui->ui_dst = sin->sin_addr;
d752 1
a752 1
			ui->ui_dport = sin->sin_port;
a753 2
	if (sin != NULL)
		bridge_tunneluntag(m);
a755 1
	vi = (struct vxlanudpiphdr *)ui;
d757 2
a758 2
		vi->ui_v.vxlan_flags = htonl(VXLAN_FLAGS_VNI);
		vi->ui_v.vxlan_id = htonl(sc->sc_vnetid << VXLAN_VNI_S);
d760 16
a775 2
		vi->ui_v.vxlan_flags = htonl(0);
		vi->ui_v.vxlan_id = htonl(0);
d778 4
a781 2
	/* UDP checksum should be 0 */
	ui->ui_sum = 0;
d792 7
a798 2
	if ((error =
	    ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo, NULL, 0))) {
a799 1
	}
@


1.38
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.37 2016/01/22 11:56:14 goda Exp $	*/
d565 1
a565 5
	/* Clear multicast flag from the outer packet */
	if (sc->sc_imo.imo_num_memberships > 0 &&
	    m->m_flags & (M_MCAST) &&
	    !ETHER_IS_MULTICAST(eh->ether_dhost))
		m->m_flags &= ~M_MCAST;
@


1.37
log
@Drop packets whose VNI flag is not set and VNI is not zero

ok reyk@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.36 2016/01/14 09:20:31 mpi Exp $	*/
a140 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.36
log
@No need for a splnet() dance around IFQ_DEQUEUE() anymore.

From David Hill, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.35 2015/12/05 10:07:55 tedu Exp $	*/
d510 1
a510 1
	if ((v.vxlan_flags & htonl(VXLAN_FLAGS_VNI)) != 0) {
@


1.35
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.34 2015/11/27 16:17:52 mpi Exp $	*/
a277 1
	int			 s;
a279 1
		s = splnet();
a280 2
		splx(s);

d283 1
@


1.34
log
@Keep "struct vxlan_softc" private to prevent pulling more headers when
<net/if_vxlan.h> is included.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.33 2015/10/25 12:05:40 mpi Exp $	*/
a344 1
/* ARGSUSED */
@


1.33
log
@arp_ifinit() is no longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.32 2015/10/23 01:19:04 dlg Exp $	*/
d59 19
@


1.32
log
@tweak the vnetid so it can be optional and therefore cleared/deleted.

the abstract vnetid is promoted to a uin32_t, and adds a SIOCDVNETID
ioctl so it can be cleared.

this is all because i set an assignment on implementing a virtual
network interface and the students got confused when vnetid 0 didnt
show up in ifconfig output.

the vnetid in the vxlan(4) protocol is optional, but the current
code confuses 0 with no vnetid being set. this makes it clear.

ok reyk@@ who also simplified my diff
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.31 2015/10/15 13:59:21 yasuoka Exp $	*/
a330 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a337 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.31
log
@Fix previous.  The port number is not included in sc_src and it is
checked already at beginning of the loop.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.30 2015/10/12 10:51:49 dlg Exp $	*/
d83 1
a83 1
#define VXLAN_TAGHASH(tag)		 (tag & vxlan_tagmask)
d111 1
a111 1
	sc->sc_vnetid = 0;
d423 1
a423 1
		if (ifr->ifr_vnetid < 0 || ifr->ifr_vnetid > 0x00ffffff) {
d428 1
a428 1
		sc->sc_vnetid = (u_int32_t)ifr->ifr_vnetid;
d434 12
a445 1
		ifr->ifr_vnetid = (int)sc->sc_vnetid;
d476 1
a476 1
	u_int32_t		 vni;
d493 8
a500 1
	vni = ntohl(v.vxlan_id);
d502 2
a503 4
	/* Validate header */
	if ((vni == 0) || (vni & VXLAN_RESERVED2) ||
	    (ntohl(v.vxlan_flags) != VXLAN_FLAGS_VNI))
		return (0);
a504 1
	vni >>= VXLAN_VNI_S;
d631 7
a637 2
	vi->ui_v.vxlan_flags = htonl(VXLAN_FLAGS_VNI);
	vi->ui_v.vxlan_id = htonl(sc->sc_vnetid << VXLAN_VNI_S);
@


1.30
log
@dont need to do suser checks in ioctl paths cos if.c does them for us.

ok mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.29 2015/10/03 07:22:05 yasuoka Exp $	*/
d501 1
a501 2
				    scsin4->sin_addr.s_addr &&
				    srcsin4->sin_port == scsin4->sin_port)
d509 1
a509 2
				    &srcsin6->sin6_addr, &scsin6->sin6_addr) &&
				    srcsin6->sin6_port == scsin6->sin6_port)
@


1.29
log
@When multiple vxlan interfaces are configured with same VNI, select the
interface whose tunnel destination corresponded to the incoming packets'
source address.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.28 2015/09/09 20:05:21 dlg Exp $	*/
a333 1
	struct proc		*p = curproc;
a360 2
		if ((error = suser(p, 0)) != 0)
			break;
a368 2
		if ((error = suser(p, 0)) != 0)
			break;
a388 2
		if ((error = suser(p, 0)) != 0)
			break;
a405 2
		if ((error = suser(p, 0)) != 0)
			break;
a422 2
		if ((error = suser(p, 0)) != 0)
			break;
@


1.28
log
@if_put after the if_get.

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.27 2015/07/20 22:54:30 mpi Exp $	*/
d474 1
a474 1
	struct vxlan_softc	*sc = NULL;
d480 2
d504 28
a531 2
		    sc->sc_rdomain == rtable_l2(m->m_pkthdr.ph_rtableid))
			goto found;
@


1.27
log
@Remove splassert(IPL_NET) from if_input().

if_input() has been designed to be able to safely handle a batch of
packets from physical drivers to the network stack.  Most of these
drivers have an interrupt routine executed at IPL_NET and the check
made sense during the conversion.  However we also want to re-enqueue
packets with if_input() from the network stack currently running at
IPL_SOFTNET.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.26 2015/07/18 22:15:14 goda Exp $	*/
d197 2
@


1.26
log
@Raise SPL to SPL_NET before calling if_input() in vxlan_lookup().

ok reyk@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.25 2015/06/24 09:40:54 mpi Exp $	*/
a480 1
	int			 s;
a532 1
	s = splnet();
a533 1
	splx(s);
@


1.25
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.24 2015/04/13 08:40:32 mpi Exp $	*/
d481 1
d534 1
d536 1
@


1.24
log
@ether_input() should not longer be called directly so convert to
if_input().

Needed for the upcoming pseudo-driver integration work.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.23 2015/04/07 10:46:20 mpi Exp $	*/
a531 1
	ifp->if_ipackets++;
a532 1

@


1.23
log
@Do not pass an `ifp' argument to interface input handlers since it
might be overwritten by pseudo-drivers.

ok dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.22 2015/03/14 03:38:51 jsg Exp $	*/
d471 1
a509 1
	m->m_pkthdr.rcvif = ifp;
a527 7
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	m_adj(m, ETHER_HDR_LEN);

d533 3
a535 1
	ether_input(m, eh);
@


1.22
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.21 2015/01/24 00:29:06 deraadt Exp $	*/
d540 1
a540 1
	ether_input(ifp, eh, m);
@


1.21
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.20 2014/12/19 17:14:40 tedu Exp $	*/
a33 1
#include <net/if_dl.h>
@


1.20
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.19 2014/12/17 09:57:13 mpi Exp $	*/
a41 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d50 4
@


1.19
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.18 2014/12/17 09:45:59 mpi Exp $	*/
a143 1
#ifdef INET
a145 1
#endif
a281 1
#ifdef INET
a282 1
#endif
a295 1
#ifdef INET
a300 1
#endif
a303 1
#ifdef INET
a309 1
#endif
a329 1
#ifdef INET
a330 1
#endif
a338 1
#ifdef INET
a340 1
#endif
a550 1
#ifdef INET
a557 1
#endif
a559 1
#ifdef INET
a611 1
#endif
a621 1
#ifdef INET
a625 1
#endif
@


1.18
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.17 2014/12/05 15:50:04 mpi Exp $	*/
d235 1
a235 1
		imo->imo_multicast_ttl = sc->sc_ttl;
d237 2
a238 2
		imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
	imo->imo_multicast_loop = 0;
@


1.17
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.16 2014/11/23 07:39:02 deraadt Exp $	*/
d182 1
a182 1
	struct ifnet		*mifp = imo->imo_multicast_ifp;
d184 1
d204 1
a204 1
		imo->imo_multicast_ifp = NULL;
d233 1
a233 1
	imo->imo_multicast_ifp = mifp;
@


1.16
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.15 2014/07/22 11:06:09 mpi Exp $	*/
d33 1
@


1.15
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.14 2014/07/12 18:44:22 tedu Exp $	*/
d171 1
a171 1
	free(sc, M_DEVBUF, 0);
@


1.14
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.13 2014/04/21 12:22:25 henning Exp $	*/
a46 1
#include <netinet/in_systm.h>
@


1.13
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.11 2014/04/11 08:44:37 mpi Exp $	*/
d171 2
a172 2
	free(sc->sc_imo.imo_membership, M_IPMOPTS);
	free(sc, M_DEVBUF);
@


1.12
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d639 1
a639 1
	    ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo, NULL))) {
@


1.11
log
@Interfaces are associated to rdomains, make it clear by renaming
`sc_rtableid' into `sc_rdomain'.  No functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.10 2013/10/22 08:34:04 reyk Exp $	*/
d511 1
a511 1
		    sc->sc_rdomain == rtable_l2(m->m_pkthdr.rdomain))
d631 1
a631 1
	m->m_pkthdr.rdomain = sc->sc_rdomain;
@


1.10
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.9 2013/10/19 18:22:37 reyk Exp $	*/
d222 2
a223 2
	if ((ifa = ifa_ifwithaddr(sintosa(src),
	    sc->sc_rtableid)) == NULL || (mifp = ifa->ifa_ifp) == NULL ||
d413 1
a413 1
		sc->sc_rtableid = ifr->ifr_rdomainid;
d419 1
a419 1
		ifr->ifr_rdomainid = sc->sc_rtableid;
d511 1
a511 1
		    sc->sc_rtableid == rtable_l2(m->m_pkthdr.rdomain))
d631 1
a631 1
	m->m_pkthdr.rdomain = sc->sc_rtableid;
@


1.9
log
@Improve the address and linkstate hooks and add an additional detach
hook to track any changes of the parent multicast interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.8 2013/10/19 14:46:31 mpi Exp $	*/
d227 1
a227 1
 	if ((imo->imo_membership[0] =
@


1.8
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.7 2013/10/19 11:37:20 reyk Exp $	*/
d67 1
a67 1
int	 vxlan_join_multicast(struct ifnet *, struct sockaddr_in *,
d74 1
d184 15
a198 7
	if (mifp != NULL && sc->sc_ahcookie != NULL) {
		hook_disestablish(mifp->if_addrhooks, sc->sc_ahcookie);
		sc->sc_ahcookie = NULL;
	}
	if (mifp != NULL && sc->sc_lhcookie != NULL) {
		hook_disestablish(mifp->if_linkstatehooks, sc->sc_lhcookie);
		sc->sc_lhcookie = NULL;
d208 1
a208 1
vxlan_join_multicast(struct ifnet *ifp, struct sockaddr_in *src,
d214 1
d223 2
a224 2
	    sc->sc_rtableid)) == NULL || ifa->ifa_ifp == NULL ||
	    (ifa->ifa_ifp->if_flags & IFF_MULTICAST) == 0)
d228 1
a228 1
	    in_addmulti(&dst->sin_addr, ifa->ifa_ifp)) == NULL)
d232 1
a232 1
	imo->imo_multicast_ifp = ifa->ifa_ifp;
d239 13
a282 1
	struct ip_moptions	*imo = &sc->sc_imo;
a286 1
	struct ifnet		*mifp = imo->imo_multicast_ifp;
d311 1
a311 1
		if ((error = vxlan_join_multicast(ifp, src4, dst4)) != 0)
a312 14

		mifp = imo->imo_multicast_ifp;

		/* Insert addr and link state hooks at head */
		if ((sc->sc_ahcookie =
		    hook_establish(mifp->if_addrhooks,
		    0, vxlan_addr_change, sc)) == NULL)
			panic("%s: cannot allocate %s address hook",
			    __func__, mifp->if_xname);
		if ((sc->sc_lhcookie =
		    hook_establish(mifp->if_linkstatehooks,
		    0, vxlan_link_change, sc)) == NULL)
			panic("%s: cannot allocate %s linkstate hook",
			    __func__, mifp->if_xname);
d652 1
a652 1
	int			 s;
d659 23
a681 1
	if (vxlan_config(ifp, NULL, NULL) != 0) {
@


1.7
log
@In an ideal world, we would use splsoftnet() for all the interface
configuration steps.  But vxlan(4) has to configure the link state and
address hooks of a parent interface that potentially need splnet().
So revert everything back to use splnet() for now.

Discussed with mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.6 2013/10/19 11:20:08 reyk Exp $	*/
a356 9
		if (ifr == 0) {
			error = EAFNOSUPPORT;
			break;
		}
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ac) :
		    ether_delmulti(ifr, &sc->sc_ac);
		if (error == ENETRESET)
			error = 0;
@


1.6
log
@When a multicast tunnel destination is configured, we have to detect address
and link state changes on the interface that is sending out the tunnel
traffic.  Attach a link state and address hook in this case and reset the
multicast configuration.  This also fixes a problem on VMware that looses
the multicast associations when the virtual link state of the NIC is
triggered.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.5 2013/10/15 10:24:41 mpi Exp $	*/
d160 1
a160 1
	s = splsoftnet();
d386 1
a386 1
		s = splsoftnet();
d414 1
a414 1
		s = splsoftnet();
d433 1
a433 1
		s = splsoftnet();
d450 1
a450 1
		s = splsoftnet();
@


1.5
log
@Remove the multicast filter from the ``real'' interface when destroying
a vxlan(4) interface and convert some splnet() to splsoftnet() when
appropriate.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.4 2013/10/14 13:04:26 mpi Exp $	*/
d67 2
d73 2
d181 10
d198 34
a262 1
	struct ifaddr		*ifa;
d264 2
a265 1
	int			 reset = 0;
a283 11

	if (IN_MULTICAST(dst4->sin_addr.s_addr)) {
		if (src4->sin_addr.s_addr == INADDR_ANY ||
		    IN_MULTICAST(src4->sin_addr.s_addr))
			return (EINVAL);
		if ((ifa = ifa_ifwithaddr(sintosa(src4),
		    sc->sc_rtableid)) == NULL ||
		    ifa->ifa_ifp == NULL ||
		    (ifa->ifa_ifp->if_flags & IFF_MULTICAST) == 0)
			return (EADDRNOTAVAIL);
	}
d290 16
a305 10
		if ((imo->imo_membership[0] =
		    in_addmulti(&dst4->sin_addr, ifa->ifa_ifp)) == NULL)
			return (ENOBUFS);
		imo->imo_num_memberships++;
		imo->imo_multicast_ifp = ifa->ifa_ifp;
		if (sc->sc_ttl > 0)
			imo->imo_multicast_ttl = sc->sc_ttl;
		else
			imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
		imo->imo_multicast_loop = 0;
d647 36
@


1.4
log
@Make use of satosin() when applicable plus a couple of style nits.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.3 2013/10/13 12:21:54 reyk Exp $	*/
d66 1
d154 5
d173 12
d249 1
a249 5
	if (imo->imo_num_memberships > 0) {
		in_delmulti(imo->imo_membership[
		    --imo->imo_num_memberships]);
		imo->imo_multicast_ifp = NULL;
	}
a293 1
	struct ip_moptions	*imo = &sc->sc_imo;
d343 2
a344 6
		s = splnet();
		if (imo->imo_num_memberships > 0) {
			in_delmulti(imo->imo_membership[
			    --imo->imo_num_memberships]);
			imo->imo_multicast_ifp = NULL;
		}
d371 1
a371 1
		s = splnet();
d390 1
a390 1
		s = splnet();
d403 1
a403 2
		if (ifr->ifr_vnetid < 0 ||
		    ifr->ifr_vnetid > 0x00ffffff) {
d407 1
a407 1
		s = splnet();
@


1.3
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.2 2013/10/13 10:41:11 reyk Exp $	*/
d213 2
a214 2
	src4 = (struct sockaddr_in *)src;
	dst4 = (struct sockaddr_in *)dst;
d223 1
a223 1
		if ((ifa = ifa_ifwithaddr((struct sockaddr *)src4,
d277 1
a277 1
	struct if_laddrreq *lifr = (struct if_laddrreq *)data;
d459 1
a459 2
	LIST_FOREACH(sc, &vxlan_tagh[VXLAN_TAGHASH(vni)],
	    sc_entry) {
d555 1
a555 1
	if ((sin = (struct sockaddr_in *)bridge_tunnel(m)) != NULL &&
@


1.2
log
@Set the default MTU to full 1500 bytes.  We do not want to encourage
running vxlan(4) with a lowered MTU of just 1450 bytes instead of
bumping the MTU of the transport interfaces to at least 1550 or
preferrably 1600 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vxlan.c,v 1.1 2013/10/13 10:10:03 reyk Exp $	*/
d186 1
a186 1
		vxlan_output(ifp, m);		
d548 1
a548 1
	ip->ip_tos = IPTOS_LOWDELAY;		
d577 1
a577 1
	ui->ui_sum = 0;	
@


1.1
log
@Import vxlan(4), the virtual extensible local area network tunnel
interface.  VXLAN is a UDP-based tunnelling protocol for overlaying
virtualized layer 2 networks over layer 3 networks. The implementation
is based on draft-mahalingam-dutt-dcops-vxlan-04 and has been tested
with other implementations in the wild.

put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 7
a136 1
	/* XXX should we allow IP fragments? */
d140 1
@

