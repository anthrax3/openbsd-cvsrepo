head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.20.0.10
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.15.0.12
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.10
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.26
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.25;
commitid	6c6qq5OdS4VVnyVM;

1.25
date	2016.06.14.20.44.43;	author sthen;	state Exp;
branches;
next	1.24;
commitid	tndIBFePD1o7FA2I;

1.24
date	2016.05.30.23.30.11;	author sthen;	state Exp;
branches;
next	1.23;
commitid	dVgy2mYGXH78Mymf;

1.23
date	2015.11.11.01.49.17;	author dlg;	state Exp;
branches;
next	1.22;
commitid	fxxO32cNBXwxt1KA;

1.22
date	2015.11.02.11.19.30;	author dlg;	state Exp;
branches;
next	1.21;
commitid	HkEo4PheGddsdtFD;

1.21
date	2015.09.30.09.45.20;	author sthen;	state Exp;
branches;
next	1.20;
commitid	0pACTtUSw4WmBBBr;

1.20
date	2013.11.20.08.21.33;	author stsp;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.14.16.52.33;	author stsp;	state Exp;
branches;
next	1.18;

1.18
date	2013.07.10.07.46.10;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2012.01.29.10.21.54;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.12.12.32.59;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.16.20.03.36;	author canacar;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.06.22.07.04;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.04.19.49.52;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.05.21.01.49;	author canacar;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.17.21.36.58;	author mpf;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.24.20.34.34;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.23.00.26.06;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.08.20.35.59;	author canacar;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.28.23.39.45;	author canacar;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.26.20.43.54;	author chris;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.09.17.20.05;	author fgsch;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.06.09.06.16.38;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.22.01.42.35;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.18.39.00;	author chris;	state Exp;
branches;
next	1.1;

1.1
date	99.07.01.23.10.40;	author deraadt;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.40.01;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.10.54.06;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: if_sppp.h,v 1.25 2016/06/14 20:44:43 sthen Exp $	*/
/*	$NetBSD: if_sppp.h,v 1.2.2.1 1999/04/04 06:57:39 explorer Exp $	*/

/*
 * Defines for synchronous PPP link level subroutines.
 *
 * Copyright (C) 1994 Cronyx Ltd.
 * Author: Serge Vakulenko, <vak@@cronyx.ru>
 *
 * Heavily revamped to conform to RFC 1661.
 * Copyright (C) 1997, Joerg Wunsch.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * From: Version 2.0, Fri Oct  6 20:39:21 MSK 1995
 *
 * From: if_sppp.h,v 1.8 1997/10/11 11:25:20 joerg Exp
 *
 * From: Id: if_sppp.h,v 1.7 1998/12/01 20:20:19 hm Exp
 */

#ifndef _NET_IF_SPPP_H_
#define _NET_IF_SPPP_H_

#define AUTHFLAG_NOCALLOUT	1 /* don't require authentication on callouts */
#define AUTHFLAG_NORECHALLENGE	2 /* don't re-challenge CHAP */

/*
 * Don't change the order of this.  Ordering the phases this way allows
 * for a comparision of ``pp_phase >= PHASE_AUTHENTICATE'' in order to
 * know whether LCP is up.
 */
enum ppp_phase {
	PHASE_DEAD, PHASE_ESTABLISH, PHASE_TERMINATE,
	PHASE_AUTHENTICATE, PHASE_NETWORK
};


#define AUTHMAXLEN	256	/* including terminating '\0' */
#define AUTHCHALEN	16	/* length of the challenge we send */

/*
 * Definitions to pass struct sppp data down into the kernel using the
 * SIOC[SG]IFGENERIC ioctl interface.
 *
 * In order to use this, create a struct spppreq, fill in the cmd
 * field with SPPPIOGDEFS, and put the address of this structure into
 * the ifr_data portion of a struct ifreq.  Pass this struct to a
 * SIOCGIFGENERIC ioctl.  Then replace the cmd field by SPPPIOSDEFS,
 * modify the defs field as desired, and pass the struct ifreq now
 * to a SIOCSIFGENERIC ioctl.
 */

struct sauthreq {
	int cmd;
	u_short	proto;			/* authentication protocol to use */
	u_short	flags;
	u_char	name[AUTHMAXLEN];	/* system identification name */
	u_char	secret[AUTHMAXLEN];	/* secret password */
};

struct spppreq {
	int	cmd;
	enum ppp_phase phase;	/* phase we're currently in */
};

#define SPPPIOGDEFS  ((int)(('S' << 24) + (1 << 16) + sizeof(struct spppreq)))
#define SPPPIOSDEFS  ((int)(('S' << 24) + (2 << 16) + sizeof(struct spppreq)))
#define SPPPIOGMAUTH ((int)(('S' << 24) + (3 << 16) + sizeof(struct sauthreq)))
#define SPPPIOSMAUTH ((int)(('S' << 24) + (4 << 16) + sizeof(struct sauthreq)))
#define SPPPIOGHAUTH ((int)(('S' << 24) + (5 << 16) + sizeof(struct sauthreq)))
#define SPPPIOSHAUTH ((int)(('S' << 24) + (6 << 16) + sizeof(struct sauthreq)))


#ifdef _KERNEL

#include <sys/timeout.h>
#include <sys/task.h>

#ifdef INET6
#include <netinet/in.h>
#include <netinet6/in6_var.h>
#endif

#define IDX_LCP 0		/* idx into state table */

struct slcp {
	u_long	opts;		/* LCP options to send (bitfield) */
	u_long  magic;          /* local magic number */
	u_long	mru;		/* our max receive unit */
	u_long	their_mru;	/* their max receive unit */
	u_long	protos;		/* bitmask of protos that are started */
	u_char  echoid;         /* id of last keepalive echo request */
	/* restart max values, see RFC 1661 */
	int	timeout;
	int	max_terminate;
	int	max_configure;
	int	max_failure;
};

#define IDX_IPCP 1		/* idx into state table */
#define IDX_IPV6CP 2

struct sipcp {
	u_long	opts;		/* IPCP options to send (bitfield) */
	u_int	flags;
#define IPCP_HISADDR_SEEN 1	/* have seen his address already */
#define IPCP_MYADDR_DYN   2	/* my address is dynamically assigned */
#define IPCP_MYADDR_SEEN  4	/* have seen my address already */
#define IPCP_HISADDR_DYN  8	/* his address is dynamically assigned */
#define IPV6CP_MYIFID_DYN	1 /* my ifid is dynamically assigned */
#define IPV6CP_MYIFID_SEEN	2 /* have seen my suggested ifid */
	u_int32_t saved_hisaddr; /* if hisaddr (IPv4) is dynamic, save
				  * original one here, in network byte order */
	u_int32_t req_hisaddr;	/* remote address requested (IPv4) */
	u_int32_t req_myaddr;	/* local address requested (IPv4) */
#ifdef INET6
	struct in6_aliasreq req_ifid;	/* local ifid requested (IPv6) */
#endif
	struct task set_addr_task;	/* set address from process context */
	struct task clear_addr_task;	/* clear address from process context */
};

struct sauth {
	u_short	proto;			/* authentication protocol to use */
	u_short	flags;
	u_char	*name;	/* system identification name */
	u_char	*secret;	/* secret password */
};

#define IDX_PAP		3
#define IDX_CHAP	4

#define IDX_COUNT (IDX_CHAP + 1) /* bump this when adding cp's! */

struct sppp {
	/* NB: pp_if _must_ be first */
	struct  ifnet pp_if;    /* network interface data */
	struct	mbuf_queue pp_cpq;	/* PPP control protocol queue */
	struct  sppp *pp_next;  /* next interface in keepalive list */
	u_int   pp_flags;
	u_int   pp_framebytes;	/* number of bytes added by hardware framing */
	u_short pp_alivecnt;    /* keepalive packets counter */
	u_short pp_loopcnt;     /* loopback detection counter */
	u_int32_t  pp_seq;      /* local sequence number */
	u_int32_t  pp_rseq;     /* remote sequence number */
	time_t	pp_last_receive;	/* peer's last "sign of life" */
	time_t	pp_last_activity;	/* second of last payload data s/r */
	enum ppp_phase pp_phase;	/* phase we're currently in */
	int	state[IDX_COUNT];	/* state machine */
	u_char  confid[IDX_COUNT];	/* id of last configuration request */
	int	rst_counter[IDX_COUNT];	/* restart counter */
	int	fail_counter[IDX_COUNT]; /* negotiation failure counter */
	struct timeout ch[IDX_COUNT];
	struct timeout pap_my_to_ch;
	struct slcp lcp;		/* LCP params */
	struct sipcp ipcp;		/* IPCP params */
	struct sipcp ipv6cp;		/* IPV6CP params */
	struct sauth myauth;		/* auth params, i'm peer */
	struct sauth hisauth;		/* auth params, i'm authenticator */
	u_char chap_challenge[AUTHCHALEN]; /* random challenge used by CHAP */

	/*
	 * These functions are filled in by sppp_attach(), and are
	 * expected to be used by the lower layer (hardware) drivers
	 * in order to communicate the (un)availability of the
	 * communication link.  Lower layer drivers that are always
	 * ready to communicate (like hardware HDLC) can shortcut
	 * pp_up from pp_tls, and pp_down from pp_tlf.
	 */
	void	(*pp_up)(struct sppp *sp);
	void	(*pp_down)(struct sppp *sp);
	/*
	 * These functions need to be filled in by the lower layer
	 * (hardware) drivers if they request notification from the
	 * PPP layer whether the link is actually required.  They
	 * correspond to the tls and tlf actions.
	 */
	void	(*pp_tls)(struct sppp *sp);
	void	(*pp_tlf)(struct sppp *sp);
	/*
	 * These (optional) functions may be filled by the hardware
	 * driver if any notification of established connections
	 * (currently: IPCP up) is desired (pp_con) or any internal
	 * state change of the interface state machine should be
	 * signaled for monitoring purposes (pp_chg).
	 */
	void	(*pp_con)(struct sppp *sp);
	void	(*pp_chg)(struct sppp *sp, int new_state);
};

#define PP_KEEPALIVE    0x01    /* use keepalive protocol */
				/* 0x02 was PP_CISCO */
				/* 0x04 was PP_TIMO */
#define PP_CALLIN	0x08	/* we are being called */
#define PP_NEEDAUTH	0x10	/* remote requested authentication */
#define PP_NOFRAMING	0x20	/* do not add/expect encapsulation
                                   around PPP frames (i.e. the serial
                                   HDLC like encapsulation, RFC1662) */

#define PP_MIN_MRU	IP_MSS	/* minimal MRU */
#define PP_MTU		1500	/* default MTU */
#define PP_MAX_MRU	2048	/* maximal MRU we want to negotiate */

void sppp_attach (struct ifnet *ifp);
void sppp_detach (struct ifnet *ifp);
void sppp_input (struct ifnet *ifp, struct mbuf *m);

/* Workaround */
void spppattach (struct ifnet *ifp);
int sppp_ioctl(struct ifnet *ifp, u_long cmd, void *data);

struct mbuf *sppp_dequeue (struct ifnet *ifp);
int sppp_isempty (struct ifnet *ifp);
void sppp_flush (struct ifnet *ifp);
#endif /* _KERNEL */
#endif /* _NET_IF_SPPP_H_ */
@


1.25
log
@Don't hardcode vlan/queue priority for pppoe packets; inherit it from the
new "llprio" setting on the pppoe(4) interface instead.

Tested by Daniel Gillen and myself, ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.24 2016/05/30 23:30:11 sthen Exp $	*/
d26 1
a26 1
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
d29 1
a29 1
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
d161 1
a161 1
 	u_short pp_alivecnt;    /* keepalive packets counter */
@


1.24
log
@Set pppoe(4) control frames to high (NC, "network control")
priority.  This is translated into an 802.1p priority tag when
sent over a vlan interface, reducing the risk of them being
crowded out by data packets on a busy link.

Some users have problems with ISPs that place specific
requirements on vlan priority (typically the packet header
value must be '0', relating to priority 1).  This diff
doesn't fix that yet, but gives a single place to patch
to change tags on control packets without affecting
normal vlan priority operation on other interfaces.

ok mikeb.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.23 2015/11/11 01:49:17 dlg Exp $	*/
a58 1
#define SPPP_CTL_PRIO	7	/* priority to use for control packets */
@


1.23
log
@replace the ifqueue used for the pp_cpq with an mbuf_queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.22 2015/11/02 11:19:30 dlg Exp $	*/
d59 1
@


1.22
log
@sppp_pick is unused, it can go away.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.21 2015/09/30 09:45:20 sthen Exp $	*/
d157 1
a157 1
	struct	ifqueue pp_cpq;	/* PPP control protocol queue */
@


1.21
log
@remove cisco hdlc code from sppp(4), it's no longer used - pppoe(4) only uses
ppp framing, and the drivers for sync serial cards have been removed so the
sppp code is now only used to support pppoe(4).  ok mpi@@, kill it chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.20 2013/11/20 08:21:33 stsp Exp $	*/
a231 1
struct mbuf *sppp_pick(struct ifnet *ifp);
@


1.20
log
@Convert sppp(4) to taskq; ok mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.19 2013/11/14 16:52:33 stsp Exp $	*/
d5 1
a5 1
 * Defines for synchronous PPP/Cisco link level subroutines.
d159 1
a159 1
	u_int   pp_flags;       /* use Cisco protocol instead of PPP */
d211 1
a211 1
#define PP_CISCO        0x02    /* use Cisco protocol instead of PPP */
@


1.19
log
@Improvements for address assignment and related issues in IPv6CP.

Move address assignment to process context. This uses a workq at
present, conversion to taskq is on my todo list (discussed with dlg).
Instead of rummaging around in sockaddr_in6 structs, use the proper
netinet6 APIs to configure addresses.
Deal with IFID collisions instead of ignoring them. The whole point of
IPv6CP is to avoid IFID collisions. Use arc4random() during IFID generation.
Assign destination address to /128 point-to-point links.

tested by me and sthen with pppoe(4)
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.18 2013/07/10 07:46:10 mpi Exp $	*/
d96 6
d133 7
a139 2
	u_int32_t req_hisaddr;	/* remote address requested */
	u_int32_t req_myaddr;	/* local address requested */
@


1.18
log
@Change the structure used in the SPPPIOSDEFS and SPPPIOGDEFS ioctls
to only include what is really needed.  In particular stop including
a "struct ifnet" and move kernel-only definition into the proper #if
dance.

While here remove the unused spppinfo() from ifconfig.

ok guenther@@, sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.17 2012/01/29 10:21:54 sthen Exp $	*/
d123 2
a124 2
#define IPV6CP_MYIFID_DYN	2
#define IPV6CP_MYIFID_SEEN	4
@


1.17
log
@Remove fastq from struct sppp. Missed when I committed if_spppsubr.c r1.96,
pointed out / ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.16 2011/11/12 12:32:59 claudio Exp $	*/
d43 52
a130 3
#define AUTHMAXLEN	256	/* including terminating '\0' */
#define AUTHCHALEN	16	/* length of the challenge we send */

a133 3
#define AUTHFLAG_NOCALLOUT	1	/* do not require authentication on */
					/* callouts */
#define AUTHFLAG_NORECHALLENGE	2	/* do not re-challenge CHAP */
a142 10
/*
 * Don't change the order of this.  Ordering the phases this way allows
 * for a comparision of ``pp_phase >= PHASE_AUTHENTICATE'' in order to
 * know whether LCP is up.
 */
enum ppp_phase {
	PHASE_DEAD, PHASE_ESTABLISH, PHASE_TERMINATE,
	PHASE_AUTHENTICATE, PHASE_NETWORK
};

a211 34
/*
 * Definitions to pass struct sppp data down into the kernel using the
 * SIOC[SG]IFGENERIC ioctl interface.
 *
 * In order to use this, create a struct spppreq, fill in the cmd
 * field with SPPPIOGDEFS, and put the address of this structure into
 * the ifr_data portion of a struct ifreq.  Pass this struct to a
 * SIOCGIFGENERIC ioctl.  Then replace the cmd field by SPPPIOSDEFS,
 * modify the defs field as desired, and pass the struct ifreq now
 * to a SIOCSIFGENERIC ioctl.
 */

struct sauthreq {
	int cmd;
	u_short	proto;			/* authentication protocol to use */
	u_short	flags;
	u_char	name[AUTHMAXLEN];	/* system identification name */
	u_char	secret[AUTHMAXLEN];	/* secret password */
};

struct spppreq {
	int	cmd;
	struct sppp defs;
};

#define SPPPIOGDEFS  ((int)(('S' << 24) + (1 << 16) + sizeof(struct spppreq)))
#define SPPPIOSDEFS  ((int)(('S' << 24) + (2 << 16) + sizeof(struct spppreq)))
#define SPPPIOGMAUTH ((int)(('S' << 24) + (3 << 16) + sizeof(struct sauthreq)))
#define SPPPIOSMAUTH ((int)(('S' << 24) + (4 << 16) + sizeof(struct sauthreq)))
#define SPPPIOGHAUTH ((int)(('S' << 24) + (5 << 16) + sizeof(struct sauthreq)))
#define SPPPIOSHAUTH ((int)(('S' << 24) + (6 << 16) + sizeof(struct sauthreq)))


#if defined(_KERNEL)
d224 1
a224 1
#endif
@


1.16
log
@Fix a comment
From Abel Abraham Camarillo Ojeda, reminded by Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.15 2009/02/16 20:03:36 canacar Exp $	*/
a109 1
	struct  ifqueue pp_fastq; /* fast output queue */
@


1.15
log
@Allow username and password to be up to 255 characters in length.
Tested by many, thanks.
Put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.14 2009/02/06 22:07:04 grange Exp $	*/
d69 1
a69 1
#define IPCP_MYADDR_SEEN  4	/* have seen his address already */
@


1.14
log
@Remove bogus casts of integer constants SPPPIO[GS]DEFS to caddr_t
and fix typo while here.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.13 2007/12/04 19:49:52 claudio Exp $	*/
d79 2
a80 2
#define AUTHNAMELEN	64
#define AUTHKEYLEN	16
d88 2
a89 3
	u_char	name[AUTHNAMELEN];	/* system identification name */
	u_char	secret[AUTHKEYLEN];	/* secret password */
	u_char	challenge[AUTHKEYLEN];	/* random challenge */
d133 2
d189 7
a195 2
#define SPPPIOGDEFS  ((int)(('S' << 24) + (1 << 16) + sizeof(struct sppp)))
#define SPPPIOSDEFS  ((int)(('S' << 24) + (2 << 16) + sizeof(struct sppp)))
d201 8
@


1.13
log
@1500 is a 'magic number' in the protocol that all implementations
must be able to handle as MRU but while testing pppoe(4) against a pppoe(8)
server I figured out that pppoe(8) insists on a MRU 1492. Because of this
we allow the offered MRU to be between PP_MIN_MRU and PP_MAX_MRU especially
because the MRU is not used at all as long as it is smaller then PP_MAX_MRU.
OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.12 2007/09/05 21:01:49 canacar Exp $	*/
d183 1
a183 1
 * SIOCGIFGENERIC ioctl.  Then replace the cmd field by SPPPIOCDEFS,
d188 2
a189 2
#define SPPPIOGDEFS  ((caddr_t)(('S' << 24) + (1 << 16) + sizeof(struct sppp)))
#define SPPPIOSDEFS  ((caddr_t)(('S' << 24) + (2 << 16) + sizeof(struct sppp)))
@


1.12
log
@IPv6 support for sppp layer, based on NetBSD version.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.11 2007/04/17 21:36:58 mpf Exp $	*/
d172 2
a173 1
#define PP_MTU          1500    /* default/minimal MRU */
@


1.11
log
@Add support for setting the address of the ppp peer.
Use the proper in_ifscrub() / in_ifinit() calls for
address changes to generate routing messages.
The correct way to set the default route now
needs the -ifp option, e.g.
 route add default -ifp pppoe0 0.0.0.1
Since the route is set right after bringing
the interface up, it still works w/out -ifp though.

Changes mostly from NetBSD.

Tested by Matthias Bauer and bluhm@@
OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.10 2006/02/24 20:34:34 claudio Exp $	*/
d62 1
d71 2
d93 2
a94 2
#define IDX_PAP		2
#define IDX_CHAP	3
d131 1
@


1.10
log
@Another gem from the the-world-runs-on-i386 departement. Using u_long in
a packet format causes some troubles on 64bit archs. This fixes a sppp(4)
panic I got on alpha and makes cisco HDLC mode actually work. More cleanup
needs to be done post 3.9. OK brad@@ looks good canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.9 2005/03/23 00:26:06 canacar Exp $	*/
d69 5
@


1.9
log
@Merge some sppp improvements from NetBSD:
1. better timeout and keepalive handling
2. fix some memory leaks on error paths.
3. use arc4random instead of random
4. always send keepalives in cHDLC mode, from claudio@@
Tested by Greg Mortensen (san) and jmc@@ (pppoe), ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.8 2005/01/08 20:35:59 canacar Exp $	*/
d110 2
a111 2
	u_long  pp_seq;         /* local sequence number */
	u_long  pp_rseq;        /* remote sequence number */
@


1.8
log
@Unslack and increase AUTHNAMELEN, since some ISP's prefer long usernames.
Reported long time ago by Marc Huber and more recently by Steffen Schutz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.7 2004/11/28 23:39:45 canacar Exp $	*/
d112 2
@


1.7
log
@In kernel pppoe client, a simple IPv4 only implementation.
Initial porting from NetBSD by David Berghoff.
Modified/simplified to match our sppp implementation.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.6 2002/09/26 20:43:54 chris Exp $	*/
d71 1
a71 1
#define AUTHNAMELEN	32
@


1.6
log
@BSD-style license from Serge Vakulenko <vak@@cronyx.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.5 2001/07/09 17:20:05 fgsch Exp $	*/
d107 2
a108 1
	u_short pp_alivecnt;    /* keepalive packets counter */
d157 3
a159 1

@


1.5
log
@More lame OpenBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d13 7
a19 2
 * This software is distributed with NO WARRANTIES, not even the implied
 * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
d21 11
a31 3
 * Authors grant any other persons or organizations permission to use
 * or modify this software as long as this message is kept with the software,
 * all derivative works or modified versions.
@


1.5.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sppp.h,v 1.5 2001/07/09 17:20:05 fgsch Exp $	*/
d13 2
a14 7
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
d16 3
a18 11
 * THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
@


1.4
log
@By popular demand, protect from multiple inclusion, and fix to use the
same naming style.
@
text
@d1 1
@


1.3
log
@new timeouts
@
text
@d26 2
a27 2
#ifndef _NET_IF_HDLC_H_
#define _NET_IF_HDLC_H_ 1
a28 1
#ifdef __OpenBSD__
a29 1
#endif
a101 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	struct callout_handle ch[IDX_COUNT]; /* per-proto and if callouts */
	struct callout_handle pap_my_to_ch; /* PAP needs one more... */
#elif defined(__OpenBSD__)
a103 1
#endif
d167 1
a167 1
#if defined(KERNEL) || defined(_KERNEL)
d171 1
a171 1
#if defined(__OpenBSD__)
a173 4
#endif
#if (defined(__FreeBSD_version) && __FreeBSD_version >= 300003)
int sppp_ioctl(struct ifnet *ifp, int cmd, void *data);
#else
d175 1
a175 1
#endif
d181 1
a181 2

#endif /* _NET_IF_HDLC_H_ */
@


1.2
log
@SIOCSIFGENERIC is now in sys/sockio.h
@
text
@d29 4
d107 3
@


1.1
log
@lmc driver; ported by chris@@dqc.org
@
text
@a166 7
#if (defined(__FreeBSD_version) && __FreeBSD_version < 300000)  ||	\
    (defined(__FreeBSD__) && __FreeBSD__ < 3)			||	\
    defined(__NetBSD__) || defined (__OpenBSD__)
#define	SIOCSIFGENERIC	 _IOW('i', 57, struct ifreq)	/* generic IF set op */
#define	SIOCGIFGENERIC	_IOWR('i', 58, struct ifreq)	/* generic IF get op */
#endif

@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@a28 4
#ifdef __OpenBSD__
#include <sys/timeout.h>
#endif

a102 3
#elif defined(__OpenBSD__)
	struct timeout ch[IDX_COUNT];
	struct timeout pap_my_to_ch;
d166 7
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d26 2
a27 2
#ifndef _NET_IF_SPPP_H_
#define _NET_IF_SPPP_H_
d29 1
d31 1
d104 4
d110 1
d174 1
a174 1
#if defined(_KERNEL)
d178 1
a178 1

d181 4
d186 1
a186 1

d192 2
a193 1
#endif /* _NET_IF_SPPP_H_ */
@


1.1.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.1.4.4
log
@Sync the SMP branch with 3.3
@
text
@d13 2
a14 7
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
d16 3
a18 11
 * THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
@


