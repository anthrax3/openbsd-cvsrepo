head	1.62;
access;
symbols
	OPENBSD_6_1:1.62.0.2
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.56.0.4
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.43.0.10
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.6
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.4
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.2
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.38.0.4
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.33.0.8
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.6
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.4
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.62
date	2017.02.22.09.56.03;	author reyk;	state Exp;
branches;
next	1.61;
commitid	4n1TwsPtyp8BGaci;

1.61
date	2016.11.17.15.41.14;	author sthen;	state Exp;
branches;
next	1.60;
commitid	RlbVwkgQ8RLhrte9;

1.60
date	2016.11.16.13.47.27;	author reyk;	state Exp;
branches;
next	1.59;
commitid	XyJooSdwV3dkETpz;

1.59
date	2016.10.30.17.46.34;	author phessler;	state Exp;
branches;
next	1.58;
commitid	TxYDJOgTc8nReiHO;

1.58
date	2016.09.12.16.24.37;	author krw;	state Exp;
branches;
next	1.57;
commitid	RJDGNn3vwOF2QQ11;

1.57
date	2016.09.11.13.57.57;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	TFYSYrtt6Di1eE3v;

1.56
date	2016.05.10.23.48.07;	author dlg;	state Exp;
branches;
next	1.55;
commitid	if1SGq8o06Yb7jtJ;

1.55
date	2016.04.03.01.37.26;	author dlg;	state Exp;
branches;
next	1.54;
commitid	XT7eCY4S3l57bhpT;

1.54
date	2016.04.02.09.05.16;	author dlg;	state Exp;
branches;
next	1.53;
commitid	H5lilsfaBbklUHtU;

1.53
date	2016.04.02.08.49.49;	author dlg;	state Exp;
branches;
next	1.52;
commitid	BPyrNLQIxS9UMvYc;

1.52
date	2016.03.30.12.51.10;	author dlg;	state Exp;
branches;
next	1.51;
commitid	qOZHyvcHqPAtGdEt;

1.51
date	2016.03.29.10.38.27;	author dlg;	state Exp;
branches;
next	1.50;
commitid	89OUI52hmN8GbHJi;

1.50
date	2016.03.09.16.32.19;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	rWA8CNSm4rSFHf86;

1.49
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.48;
commitid	h7z8lokZ0dFyuWpg;

1.48
date	2015.02.10.00.53.55;	author pelikan;	state Exp;
branches;
next	1.47;
commitid	gfoM2KwSYVDTr1Yq;

1.47
date	2014.10.07.11.16.23;	author dlg;	state Exp;
branches;
next	1.46;
commitid	p6HaTuy2dxbTD4Pm;

1.46
date	2014.07.10.09.46.29;	author henning;	state Exp;
branches;
next	1.45;
commitid	K02ipswh8Nqemdsh;

1.45
date	2014.07.09.11.03.04;	author henning;	state Exp;
branches;
next	1.44;
commitid	mfsvjrJC7UBF4ZGt;

1.44
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.43;
commitid	Nnxg8ONtI4Ep9pUb;

1.43
date	2012.03.26.19.37.42;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.26.09.24.52;	author martynas;	state Exp;
branches;
next	1.41;

1.41
date	2010.10.29.03.43.35;	author canacar;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.21.04.06.37;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.26.16.49.01;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2008.12.22.12.13.13;	author michele;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.26.18.01.43;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.09.15.08.26;	author naddy;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.29.19.31.16;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.06.13.33.50;	author pyr;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.03.20.00.18;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.07.16.28.38;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.17.15.56.58;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.22.04.04.19;	author canacar;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.16.04.34.58;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.26.08.10.10;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.06.22.38.58;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.22.18.42.40;	author canacar;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.25.08.16.41;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.14.08.42.00;	author canacar;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.29.18.35.15;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.29.18.25.22;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.02.18.04.35;	author deraadt;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.06.25.23.02.17;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.09.06.16.37;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.28.19.51.06;	author dugsong;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.19.03.00.54;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	99.07.04.18.44.28;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	99.07.04.18.37.19;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.05.26.19.26.11;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	98.06.26.09.13.11;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.06.10.23.57.09;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	98.06.04.23.11.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.03.17.16.29.37;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.12.07.57.41;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.07.13.40.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.21.07.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches;
next	;

1.12.4.1
date	2001.05.14.22.39.59;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2001.07.04.10.53.51;	author niklas;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.12.4.5;

1.12.4.5
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.12.4.6;

1.12.4.6
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.12.4.7;

1.12.4.7
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.12.4.8;

1.12.4.8
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.12.4.9;

1.12.4.9
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2003.05.19.22.29.06;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.62
log
@The pcap people gave us ID 267 for DLT_OPENFLOW

Via https://github.com/the-tcpdump-group/libpcap/issues/542

OK sthen@@ jsg@@
@
text
@/*	$OpenBSD: bpf.h,v 1.61 2016/11/17 15:41:14 sthen Exp $	*/
/*	$NetBSD: bpf.h,v 1.15 1996/12/13 07:57:33 mikel Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from the Stanford/CMU enet packet filter,
 * (net/enet.c) distributed as part of 4.3BSD, and code contributed
 * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence
 * Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)bpf.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NET_BPF_H_
#define _NET_BPF_H_

/* BSD style release date */
#define BPF_RELEASE 199606

typedef	int32_t	bpf_int32;
typedef u_int32_t	bpf_u_int32;
/*
 * Alignment macros.  BPF_WORDALIGN rounds up to the next even multiple of
 * BPF_ALIGNMENT (which is at least as much as what a timeval needs).
 */
#define BPF_ALIGNMENT sizeof(u_int32_t)
#define BPF_WORDALIGN(x) (((x) + (BPF_ALIGNMENT - 1)) & ~(BPF_ALIGNMENT - 1))

#define BPF_MAXINSNS 512
#define BPF_MAXBUFSIZE (2 * 1024 * 1024)
#define BPF_MINBUFSIZE 32

/*
 *  Structure for BIOCSETF.
 */
struct bpf_program {
	u_int bf_len;
	struct bpf_insn *bf_insns;
};

/*
 * Struct returned by BIOCGSTATS.
 */
struct bpf_stat {
	u_int bs_recv;		/* number of packets received */
	u_int bs_drop;		/* number of packets dropped */
};

/*
 * Struct return by BIOCVERSION.  This represents the version number of
 * the filter language described by the instruction encodings below.
 * bpf understands a program iff kernel_major == filter_major &&
 * kernel_minor >= filter_minor, that is, if the value returned by the
 * running kernel has the same major number and a minor number equal
 * equal to or less than the filter being downloaded.  Otherwise, the
 * results are undefined, meaning an error may be returned or packets
 * may be accepted haphazardly.
 * It has nothing to do with the source code version.
 */
struct bpf_version {
	u_short bv_major;
	u_short bv_minor;
};
/* Current version number of filter architecture. */
#define BPF_MAJOR_VERSION 1
#define BPF_MINOR_VERSION 1

/*
 * BPF ioctls
 */
#define	BIOCGBLEN	_IOR('B',102, u_int)
#define	BIOCSBLEN	_IOWR('B',102, u_int)
#define	BIOCSETF	_IOW('B',103, struct bpf_program)
#define	BIOCFLUSH	_IO('B',104)
#define BIOCPROMISC	_IO('B',105)
#define	BIOCGDLT	_IOR('B',106, u_int)
#define BIOCGETIF	_IOR('B',107, struct ifreq)
#define BIOCSETIF	_IOW('B',108, struct ifreq)
#define BIOCSRTIMEOUT	_IOW('B',109, struct timeval)
#define BIOCGRTIMEOUT	_IOR('B',110, struct timeval)
#define BIOCGSTATS	_IOR('B',111, struct bpf_stat)
#define BIOCIMMEDIATE	_IOW('B',112, u_int)
#define BIOCVERSION	_IOR('B',113, struct bpf_version)
#define BIOCSRSIG	_IOW('B',114, u_int)
#define BIOCGRSIG	_IOR('B',115, u_int)
#define BIOCGHDRCMPLT	_IOR('B',116, u_int)
#define BIOCSHDRCMPLT	_IOW('B',117, u_int)
#define	BIOCLOCK	_IO('B',118)
#define	BIOCSETWF	_IOW('B',119, struct bpf_program)
#define BIOCGFILDROP	_IOR('B',120, u_int)
#define BIOCSFILDROP	_IOW('B',121, u_int)
#define BIOCSDLT	_IOW('B',122, u_int)
#define BIOCGDLTLIST	_IOWR('B',123, struct bpf_dltlist)
#define BIOCGDIRFILT	_IOR('B',124, u_int)
#define BIOCSDIRFILT	_IOW('B',125, u_int)

/*
 * Direction filters for BIOCSDIRFILT/BIOCGDIRFILT
 */
#define BPF_DIRECTION_IN	1
#define BPF_DIRECTION_OUT	(1<<1)

struct bpf_timeval {
	u_int32_t	tv_sec;
	u_int32_t	tv_usec;
};

/*
 * Structure prepended to each packet.
 */
struct bpf_hdr {
	struct bpf_timeval bh_tstamp;	/* time stamp */
	u_int32_t	bh_caplen;	/* length of captured portion */
	u_int32_t	bh_datalen;	/* original length of packet */
	u_int16_t	bh_hdrlen;	/* length of bpf header (this struct
					   plus alignment padding) */
};
/*
 * Because the structure above is not a multiple of 4 bytes, some compilers
 * will insist on inserting padding; hence, sizeof(struct bpf_hdr) won't work.
 * Only the kernel needs to know about it; applications use bh_hdrlen.
 * XXX To save a few bytes on 32-bit machines, we avoid end-of-struct
 * XXX padding by using the size of the header data elements.  This is
 * XXX fail-safe: on new machines, we just use the 'safe' sizeof.
 */
#ifdef _KERNEL
#if defined(__arm__) || defined(__i386__) || defined(__mips__) || \
    defined(__sparc64__)
#define SIZEOF_BPF_HDR 18
#else
#define SIZEOF_BPF_HDR sizeof(struct bpf_hdr)
#endif
#endif

/*
 * Data-link level type codes.
 */
#define DLT_NULL		0	/* no link-layer encapsulation */
#define DLT_EN10MB		1	/* Ethernet (10Mb) */
#define DLT_EN3MB		2	/* Experimental Ethernet (3Mb) */
#define DLT_AX25		3	/* Amateur Radio AX.25 */
#define DLT_PRONET		4	/* Proteon ProNET Token Ring */
#define DLT_CHAOS		5	/* Chaos */
#define DLT_IEEE802		6	/* IEEE 802 Networks */
#define DLT_ARCNET		7	/* ARCNET */
#define DLT_SLIP		8	/* Serial Line IP */
#define DLT_PPP			9	/* Point-to-point Protocol */
#define DLT_FDDI		10	/* FDDI */
#define DLT_ATM_RFC1483		11	/* LLC/SNAP encapsulated atm */
#define DLT_LOOP		12	/* loopback type (af header) */
#define DLT_ENC			13	/* IPSEC enc type (af header, spi, flags) */
#define DLT_RAW			14	/* raw IP */
#define DLT_SLIP_BSDOS		15	/* BSD/OS Serial Line IP */
#define DLT_PPP_BSDOS		16	/* BSD/OS Point-to-point Protocol */
#define DLT_PFSYNC		18	/* Packet filter state syncing */
#define DLT_PPP_SERIAL		50	/* PPP over Serial with HDLC */
#define DLT_PPP_ETHER		51	/* PPP over Ethernet; session only w/o ether header */
#define DLT_C_HDLC		104	/* Cisco HDLC */
#define DLT_IEEE802_11		105	/* IEEE 802.11 wireless */
#define DLT_PFLOG		117	/* Packet filter logging, by pcap people */
#define DLT_IEEE802_11_RADIO	127	/* IEEE 802.11 plus WLAN header */
#define DLT_USER0		147	/* Reserved for private use */
#define DLT_USER1		148	/* Reserved for private use */
#define DLT_USER2		149	/* Reserved for private use */
#define DLT_USER3		150	/* Reserved for private use */
#define DLT_USER4		151	/* Reserved for private use */
#define DLT_USER5		152	/* Reserved for private use */
#define DLT_USER6		153	/* Reserved for private use */
#define DLT_USER7		154	/* Reserved for private use */
#define DLT_USER8		155	/* Reserved for private use */
#define DLT_USER9		156	/* Reserved for private use */
#define DLT_USER10		157	/* Reserved for private use */
#define DLT_USER11		158	/* Reserved for private use */
#define DLT_USER12		159	/* Reserved for private use */
#define DLT_USER13		160	/* Reserved for private use */
#define DLT_USER14		161	/* Reserved for private use */
#define DLT_USER15		162	/* Reserved for private use */
#define DLT_MPLS		219	/* MPLS Provider Edge header */
#define DLT_OPENFLOW		267	/* in-kernel OpenFlow, by pcap */

/*
 * The instruction encodings.
 */
/* instruction classes */
#define BPF_CLASS(code) ((code) & 0x07)
#define		BPF_LD		0x00
#define		BPF_LDX		0x01
#define		BPF_ST		0x02
#define		BPF_STX		0x03
#define		BPF_ALU		0x04
#define		BPF_JMP		0x05
#define		BPF_RET		0x06
#define		BPF_MISC	0x07

/* ld/ldx fields */
#define BPF_SIZE(code)	((code) & 0x18)
#define		BPF_W		0x00
#define		BPF_H		0x08
#define		BPF_B		0x10
#define BPF_MODE(code)	((code) & 0xe0)
#define		BPF_IMM		0x00
#define		BPF_ABS		0x20
#define		BPF_IND		0x40
#define		BPF_MEM		0x60
#define		BPF_LEN		0x80
#define		BPF_MSH		0xa0

/* alu/jmp fields */
#define BPF_OP(code)	((code) & 0xf0)
#define		BPF_ADD		0x00
#define		BPF_SUB		0x10
#define		BPF_MUL		0x20
#define		BPF_DIV		0x30
#define		BPF_OR		0x40
#define		BPF_AND		0x50
#define		BPF_LSH		0x60
#define		BPF_RSH		0x70
#define		BPF_NEG		0x80
#define		BPF_JA		0x00
#define		BPF_JEQ		0x10
#define		BPF_JGT		0x20
#define		BPF_JGE		0x30
#define		BPF_JSET	0x40
#define BPF_SRC(code)	((code) & 0x08)
#define		BPF_K		0x00
#define		BPF_X		0x08

/* ret - BPF_K and BPF_X also apply */
#define BPF_RVAL(code)	((code) & 0x18)
#define		BPF_A		0x10

/* misc */
#define BPF_MISCOP(code) ((code) & 0xf8)
#define		BPF_TAX		0x00
#define		BPF_TXA		0x80

/*
 * The instruction data structure.
 */
struct bpf_insn {
	u_int16_t	code;
	u_char		jt;
	u_char		jf;
	u_int32_t	k;
};

/*
 * Structure to retrieve available DLTs for the interface.
 */
struct bpf_dltlist {
	u_int	bfl_len;	/* number of bfd_list array */
	u_int	*bfl_list;	/* array of DLTs */
};

/*
 * Load operations for _bpf_filter to use against the packet pointer.
 */
struct bpf_ops {
	u_int32_t	(*ldw)(const void *, u_int32_t, int *);
	u_int32_t	(*ldh)(const void *, u_int32_t, int *);
	u_int32_t	(*ldb)(const void *, u_int32_t, int *);
};

/*
 * Macros for insn array initializers.
 */
#define BPF_STMT(code, k) { (u_int16_t)(code), 0, 0, k }
#define BPF_JUMP(code, k, jt, jf) { (u_int16_t)(code), jt, jf, k }

__BEGIN_DECLS
u_int	 bpf_filter(const struct bpf_insn *, const u_char *, u_int, u_int)
	    __bounded((__buffer__, 2, 4));

u_int	 _bpf_filter(const struct bpf_insn *, const struct bpf_ops *,
	     const void *, u_int);
__END_DECLS

#ifdef _KERNEL
struct ifnet;
struct mbuf;

int	 bpf_validate(struct bpf_insn *, int);
int	 bpf_mtap(caddr_t, const struct mbuf *, u_int);
int	 bpf_mtap_hdr(caddr_t, caddr_t, u_int, const struct mbuf *, u_int,
	    void (*)(const void *, void *, size_t));
int	 bpf_mtap_af(caddr_t, u_int32_t, const struct mbuf *, u_int);
int	 bpf_mtap_ether(caddr_t, const struct mbuf *, u_int);
void	 bpfattach(caddr_t *, struct ifnet *, u_int, u_int);
void	 bpfdetach(struct ifnet *);
void	 bpfilterattach(int);

u_int	 bpf_mfilter(const struct bpf_insn *, const struct mbuf *, u_int);
#endif /* _KERNEL */

/*
 * Number of scratch memory words (for BPF_LD|BPF_MEM and BPF_ST).
 */
#define BPF_MEMWORDS 16

#endif /* _NET_BPF_H_ */
@


1.61
log
@Add DLT_USER1..15 with the same values as the upstream libpcap repository.
Suggested by reyk@@ as a quick fix to unbreak ports/net/wireshark.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.60 2016/11/16 13:47:27 reyk Exp $	*/
d205 1
a205 1
#define DLT_OPENFLOW		DLT_USER0
@


1.60
log
@Add new DLT_OPENFLOW link-type to allow using tcpdump to debug switch(4),
eg. tcpdump -y openflow -i switch0

Includes a minor bump for libpcap.

Feedback and OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.59 2016/10/30 17:46:34 phessler Exp $	*/
d189 15
@


1.59
log
@add __BEGIN_DECLS/__END_DECLS to the public userland side of net/bpf.h,
so c++ programs can use them.

OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.58 2016/09/12 16:24:37 krw Exp $	*/
d188 1
d190 1
@


1.58
log
@bpf_tap() is long dead! Long live bpf_mtap() & friends.

ok natano@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.57 2016/09/11 13:57:57 deraadt Exp $	*/
d279 1
d285 1
@


1.57
log
@Remove #ifdef's for architectures of the past around SIZEOF_BPF_HDR
This is still a mess.  Why don't we just clean this up?
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.56 2016/05/10 23:48:07 dlg Exp $	*/
a289 1
int	 bpf_tap(caddr_t, u_char *, u_int, u_int);
@


1.56
log
@make the bpf tap functions take const struct mbuf *

this makes it more obvious that the bpf code should only read
packets, never modify them.

now possible because the paths that care about M_FILDROP set it
after calling bpf_mtap.

ok mpi@@ visa@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.55 2016/04/03 01:37:26 dlg Exp $	*/
d153 1
a153 2
#if defined(__arm__) || defined(__i386__) || defined(__m68k__) || \
    defined(__mips__) || defined(__ns32k__) || defined(__sparc__) || \
@


1.55
log
@mark the packet buffer in bpf_filter as bounded by the pktlen arg

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.54 2016/04/02 09:05:16 dlg Exp $	*/
d292 2
a293 2
int	 bpf_mtap(caddr_t, struct mbuf *, u_int);
int	 bpf_mtap_hdr(caddr_t, caddr_t, u_int, struct mbuf *, u_int,
d295 2
a296 2
int	 bpf_mtap_af(caddr_t, u_int32_t, struct mbuf *, u_int);
int	 bpf_mtap_ether(caddr_t, struct mbuf *, u_int);
@


1.54
log
@mark the program and buffer as const in bpf_filter()

other projects have already done this, and there's software (eg,
gopacket) which now expects it.

based on a discussion with jasper@@ and canacar@@
ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.53 2016/04/02 08:49:49 dlg Exp $	*/
d280 2
a281 1
u_int	 bpf_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
@


1.53
log
@refactor bpf_filter a bit.

the code was confusing around how it dealt with packets in mbufs
vs plain memory buffers with a lenght.

this renames bpf_filter to _bpf_filter, and changes it so the packet
memory is referred to by an opaque pointer, and callers have to
provide a set of operations to extra values from that opaque pointer.

bpf_filter is now provided as a wrapper around _bpf_filter. it
provides a set of operators that work on a straight buffer with a
lenght.

this also adds a bpf_mfilter function which takes an mbuf instead
of a buffer, and it provides explicit operations for extracting
values from mbufs.

if we want to use bpf filters against other data structures (usb
or scsi packets maybe?) we are able to provide functions for
extracting payloads from them and use _bpf_filter as is.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.51 2016/03/29 10:38:27 dlg Exp $	*/
d280 1
a280 1
u_int	 bpf_filter(struct bpf_insn *, u_char *, u_int, u_int);
@


1.52
log
@BIOCGQUEUE and BIOCSQUEUE are no more
@
text
@d266 9
d280 5
d287 1
d299 2
a300 1
u_int	 bpf_filter(struct bpf_insn *, u_char *, u_int, u_int);
@


1.51
log
@make bpf_mtap et al return whether the mbuf should be dropped

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.50 2016/03/09 16:32:19 deraadt Exp $	*/
a121 2
#define BIOCGQUEUE	_IOR('B',126, u_int)
#define BIOCSQUEUE	_IOW('B',127, u_int)
@


1.50
log
@remove __vax__
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.49 2015/06/16 11:09:39 mpi Exp $	*/
d278 2
a279 2
void	 bpf_mtap(caddr_t, struct mbuf *, u_int);
void	 bpf_mtap_hdr(caddr_t, caddr_t, u_int, struct mbuf *, u_int,
d281 2
a282 2
void	 bpf_mtap_af(caddr_t, u_int32_t, struct mbuf *, u_int);
void	 bpf_mtap_ether(caddr_t, struct mbuf *, u_int);
@


1.49
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.48 2015/02/10 00:53:55 pelikan Exp $	*/
d157 1
a157 1
    defined(__sparc64__) || defined(__vax__)
@


1.48
log
@make bpf(4) able to filter based on a pf(4) queue ID for tcpdump -Q qname

ALTQ version has been on tech@@ for years, people were generally ok with it.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.47 2014/10/07 11:16:23 dlg Exp $	*/
d274 2
@


1.47
log
@when running bpf on an outgoing vlan interface that doesnt have a
parent that doesnt offload the tag insertion, we need to chop the
vlan subheader out before the filter is run, not after.

this moves the mbuf surgery out from the bpf layer into the vlan
layer.

ok henning@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.46 2014/07/10 09:46:29 henning Exp $	*/
d122 2
@


1.46
log
@introduce bpf_mcopy_stripvlan, which cuts the 4 extra bytes out of the
ether_vlan_header to make it a regular ether_header while copying into
the bpf buffer.
add bpf_mtap_stripvlan, which is a 1-line wrapper around _bpf_mtap passing
this copy function in.
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.45 2014/07/09 11:03:04 henning Exp $	*/
a274 1
void	 bpf_mtap_stripvlan(caddr_t, struct mbuf *, u_int);
@


1.45
log
@tedu bpf_mtap_pflog().
now that it is a trivial wrapper around the extended bpf_mtap_hdr, we can
use bpf_mtap_hdr directly. added benefit: pflog_bpfcopy doesn't need to
be exported any more and can stay private to if_pflog.c
ok benno bluhm reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.44 2014/07/09 09:30:49 henning Exp $	*/
d275 1
@


1.44
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.42 2011/07/26 09:24:52 martynas Exp $	*/
a278 1
void	 bpf_mtap_pflog(caddr_t, caddr_t, struct mbuf *);
@


1.43
log
@Add DLT_PPP_SERIAL and DLT_C_HDLC to bpf.h even though the system will not
generate such packets but it helps porting applications that assume that
these are available on any system.
Requested by dhill long time ago.
@
text
@d275 2
a276 1
void	 bpf_mtap_hdr(caddr_t, caddr_t, u_int, struct mbuf *, u_int);
@


1.42
log
@__arm32__ -> __arm__, since our new compiler isn't defining the
former anymore.  OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.41 2010/10/29 03:43:35 canacar Exp $	*/
d183 1
d185 1
@


1.41
log
@Align to 32-bits instead of sizeof(long) which may be bigger. There is no
practical value of aligning things to 64-bit and waste more space then
necessary on some architectures.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.40 2010/09/21 04:06:37 henning Exp $	*/
d153 1
a153 1
#if defined(__arm32__) || defined(__i386__) || defined(__m68k__) || \
@


1.40
log
@pflog overhaul
pflog was logging the "wrong" as in not yet rewritten (nat/rdr) addresses.
to address this without making an extra copy of the mbuf chain:
-introduce bpf_mtap_pflog, which is a 1:1 copy of bpf_mtap_hdr, except that
it supplies bpf_catchpacket with pflog_bpfcopy as copy function instead of
plain bcopy
-said new shiny pflog_bpfcopy knows what a pflog packet looks like, copies
everything into bpf's buffer, contructs a fake mbuf (which is allocated once
at attach time and reused over and over) which points to the bpf buffer
as data storage
-call pf_setup_pdesc on said fake mbuf
-then call pf_translate to rewrite the addresses as needed right in the
bpf buffer
this changes the pflog header as we have to pass the new addresses/ports
around. relies on canacar's awesome work in libpcap to work olrite with the
new, longer pflog header as well as with the old, shorter one.
almost completely written at c2k10 in canada, finished here at j2k10 in
japan. ok ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.39 2010/06/26 16:49:01 henning Exp $	*/
d52 1
a52 1
#define BPF_ALIGNMENT sizeof(long)
@


1.39
log
@bye bye DLT_OLD_PFLOG & friends. dead since 2003. 7 years oughta be enough
ok ryan theo reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.38 2008/12/22 12:13:13 michele Exp $	*/
d276 1
@


1.38
log
@Change DLT_MPLS number.
Use one assigned by tcpdump guys to keep
things in sync with them.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.37 2008/11/26 18:01:43 dlg Exp $	*/
a181 1
#define DLT_OLD_PFLOG		17	/* Packet filter logging, old (XXX remove?) */
@


1.37
log
@dont have bpf.h expose the kernel ticks variable wherever it is includeing.

it is very confusing like this.

ok deraadt@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.36 2008/11/09 15:08:26 naddy Exp $	*/
d188 1
a188 1
#define DLT_MPLS		128	/* MPLS Provider Edge header */
@


1.36
log
@Introduce bpf_mtap_ether(), which for the benefit of bpf listeners
creates the VLAN encapsulation from the tag stored in the mbuf
header.  Idea from FreeBSD, input from claudio@@ and canacar@@.

Switch all hardware VLAN enabled drivers to the new function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.35 2008/06/29 19:31:16 deraadt Exp $	*/
a286 3

extern int ticks;	/* from kern/kern_clock.c; incremented each */
			/* clock tick. */
@


1.35
log
@this stupid per-arch SIZEOF_BPF_HDR define is really really stupid, but
for now add __sparc64__ to the list (ridiculous as it seems, but that is
the best we know to do so far)
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.34 2008/05/06 13:33:50 pyr Exp $	*/
d276 1
@


1.34
log
@bring in the mpe interface - for ``MPLS Provider Edge'' - this is a work
in progress and some bits need to be cleaned up but will be in-tree for
convenience.

ok claudio@@, norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.33 2006/03/25 22:41:47 djm Exp $	*/
d155 1
a155 1
    defined(__vax__)
@


1.33
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.32 2005/11/03 20:00:18 reyk Exp $	*/
d188 1
@


1.32
log
@re-implement the bpf "filter drop" option that it actually works. the
bpf FILDROP interface exists for about one year but the required
interface to the drivers was missing - so it was useless. this new
approach based on a design by henning@@ uses a new mbuf flag to mark
filtered packets and to drop them in the generic network stack input
routines (like ether_input).

for example; after some additional testing, this could be used by
dhclient to filter everything except DHCP packets (track tech@@
for a corresponding dhclient diff). the "filter dropped" packets won't
reach the network stack. so it's probably some kind of a very basic
application layer packet filter ;).

ok canacar@@, discussed with henning@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.31 2005/07/31 03:52:18 pascoe Exp $	*/
d120 8
d271 4
a274 4
int	 bpf_tap(caddr_t, u_char *, u_int);
void	 bpf_mtap(caddr_t, struct mbuf *);
void	 bpf_mtap_hdr(caddr_t, caddr_t, u_int, struct mbuf *);
void	 bpf_mtap_af(caddr_t, u_int32_t, struct mbuf *);
@


1.31
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.30 2005/01/07 16:28:38 reyk Exp $	*/
d264 3
a266 3
int	 bpf_mtap(caddr_t, struct mbuf *);
int	 bpf_mtap_hdr(caddr_t, caddr_t, u_int, struct mbuf *);
int	 bpf_mtap_af(caddr_t, u_int32_t, struct mbuf *);
@


1.30
log
@add support for BIOCGDLTLIST and BIOCSDLT, see bpf(4)

ok canacar@@, fgsch@@, tested by some other people
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.29 2004/12/17 15:56:58 reyk Exp $	*/
d265 2
@


1.29
log
@knf cleanup, convert old k&r-style functions to ansi-style for a
consistent style in sys/net/bpf.c.

ok henning@@, "looks fine" canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.28 2004/06/22 04:04:19 canacar Exp $	*/
d118 2
d179 1
d245 8
@


1.28
log
@Add a new "filter drop" flag to bpf and related ioclts.
When enabled, it notifies the calling interface that the packet
matches a bpf filter and should be dropped.
ok henning@@ markus@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.27 2004/05/16 04:34:58 brad Exp $	*/
d155 22
a176 22
#define DLT_NULL	0	/* no link-layer encapsulation */
#define DLT_EN10MB	1	/* Ethernet (10Mb) */
#define DLT_EN3MB	2	/* Experimental Ethernet (3Mb) */
#define DLT_AX25	3	/* Amateur Radio AX.25 */
#define DLT_PRONET	4	/* Proteon ProNET Token Ring */
#define DLT_CHAOS	5	/* Chaos */
#define DLT_IEEE802	6	/* IEEE 802 Networks */
#define DLT_ARCNET	7	/* ARCNET */
#define DLT_SLIP	8	/* Serial Line IP */
#define DLT_PPP		9	/* Point-to-point Protocol */
#define DLT_FDDI	10	/* FDDI */
#define DLT_ATM_RFC1483	11	/* LLC/SNAP encapsulated atm */
#define DLT_LOOP	12	/* loopback type (af header) */
#define DLT_ENC		13	/* IPSEC enc type (af header, spi, flags) */
#define DLT_RAW		14	/* raw IP */
#define DLT_SLIP_BSDOS	15	/* BSD/OS Serial Line IP */
#define DLT_PPP_BSDOS	16	/* BSD/OS Point-to-point Protocol */
#define DLT_OLD_PFLOG	17	/* Packet filter logging, old (XXX remove?) */
#define DLT_PFSYNC	18	/* Packet filter state syncing */
#define DLT_PPP_ETHER	51	/* PPP over Ethernet; session only, w/o ether header */
#define DLT_IEEE802_11	105	/* IEEE 802.11 wireless */
#define DLT_PFLOG	117	/* Packet filter logging, by pcap people */
d198 1
a198 1
#define		BPF_IMM 	0x00
d238 4
a241 4
	u_int16_t code;
	u_char 	  jt;
	u_char 	  jf;
	u_int32_t k;
@


1.27
log
@add DLT_PPP_ETHER DLT type

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.26 2004/04/26 08:10:10 otto Exp $	*/
d116 2
d252 2
a253 2
void	 bpf_tap(caddr_t, u_char *, u_int);
void	 bpf_mtap(caddr_t, struct mbuf *);
@


1.26
log
@- make the k field in struct bpf_insn unsigned, as promised in the
manual page.
- more strict bpf code validation, preventing arbitrary kernel memory
read and writes.
Some help from frantzen@@ and canacar@@; testing jmc@@ markus@@;
ok canacar@@ henning@@ franzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.25 2004/02/06 22:38:58 tedu Exp $	*/
d172 1
@


1.25
log
@as seen in netbsd.  crank bpf sizes to adapt to faster networks.
max size goes to 2MB, default goes to 32k.  ok canacar@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.24 2003/10/22 18:42:40 canacar Exp $	*/
d238 1
a238 1
	int32_t	  k;
@


1.24
log
@Add locking and write filtering to bpf descriptors.
Locking prevents dangerous ioctls such as changing the
interface and sending signals to be executed by an
unprivileged process. A filter can also be applied
to packets injected through a bpf descriptor.

These features allow programs using bpf descriptors to
safely drop/seperate privileges.

ok frantzen@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.23 2003/08/25 08:16:41 fgsch Exp $	*/
d56 1
a56 1
#define BPF_MAXBUFSIZE 0x80000
@


1.23
log
@add DLT_IEEE802_11; deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.21 2003/05/14 08:42:00 canacar Exp $	*/
d114 2
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d170 1
@


1.21
log
@Use official (from pcap people) link type for pflog.
With this change, the log header format also changes.
The new log format is extendible and allows logging
of the originating anchor and ruleset information.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.20 2002/11/29 18:35:15 henning Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.19 2002/11/29 18:25:22 mickey Exp $	*/
d172 1
a172 1
#define DLT_PFLOG	17	/* Packet filter logging */
d174 1
@


1.19
log
@expose state table changes
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.18 2002/03/14 01:27:09 millert Exp $	*/
d47 1
a47 1
/* BSD style release date */ 
d70 1
a70 1
 
d80 1
a80 1
 * Struct return by BIOCVERSION.  This represents the version number of 
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.17 2001/10/02 18:04:35 deraadt Exp $	*/
d173 1
@


1.17
log
@change timeval to bpf_timeval; 32 bit in size, permitting much greater portability
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.16 2001/06/25 23:02:17 provos Exp $	*/
d247 7
a253 7
int	 bpf_validate __P((struct bpf_insn *, int));
void	 bpf_tap __P((caddr_t, u_char *, u_int));
void	 bpf_mtap __P((caddr_t, struct mbuf *));
void	 bpfattach __P((caddr_t *, struct ifnet *, u_int, u_int));
void	 bpfdetach __P((struct ifnet *));
void	 bpfilterattach __P((int));
u_int	 bpf_filter __P((struct bpf_insn *, u_char *, u_int, u_int));
@


1.17.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.17 2001/10/02 18:04:35 deraadt Exp $	*/
d247 7
a253 7
int	 bpf_validate(struct bpf_insn *, int);
void	 bpf_tap(caddr_t, u_char *, u_int);
void	 bpf_mtap(caddr_t, struct mbuf *);
void	 bpfattach(caddr_t *, struct ifnet *, u_int, u_int);
void	 bpfdetach(struct ifnet *);
void	 bpfilterattach(int);
u_int	 bpf_filter(struct bpf_insn *, u_char *, u_int, u_int);
@


1.17.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
/* BSD style release date */
d70 1
a70 1

d80 1
a80 1
 * Struct return by BIOCVERSION.  This represents the version number of
d172 1
a172 3
#define DLT_OLD_PFLOG	17	/* Packet filter logging, old (XXX remove?) */
#define DLT_PFSYNC	18	/* Packet filter state syncing */
#define DLT_PFLOG	117	/* Packet filter logging, by pcap people */
@


1.16
log
@extend the logging via a new link header type.  export interface, direction,
action and rule nr.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.15 2001/06/09 06:16:37 angelos Exp $	*/
d119 5
d128 1
a128 1
	struct timeval	bh_tstamp;	/* time stamp */
@


1.15
log
@By popular demand, protect from multiple inclusion, and fix to use the
same naming style.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.14 2001/05/28 19:51:06 dugsong Exp $	*/
d167 1
@


1.14
log
@add BIOC[GS]HDRCMPLT ioctl for BPF, to disable overwriting of link level source address in forged frames. from NetBSD. art@@ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.13 2000/06/19 03:00:54 jason Exp $	*/
d248 1
a248 1
#endif
@


1.13
log
@de-#ifdef-ize
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.12 1999/08/08 00:43:00 niklas Exp $	*/
d116 2
@


1.12
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.11 1999/07/04 18:44:28 brad Exp $	*/
d100 1
a100 22
 *
 * The first set is for compatibility with Sun's pcc style
 * header files.  If you're using gcc, we assume that you
 * have run fixincludes so the latter set should work.
 */
#if (defined(sun) || defined(ibm032)) && !defined(__GNUC__)
#define	BIOCGBLEN	_IOR(B,102, u_int)
#define	BIOCSBLEN	_IOWR(B,102, u_int)
#define	BIOCSETF	_IOW(B,103, struct bpf_program)
#define	BIOCFLUSH	_IO(B,104)
#define BIOCPROMISC	_IO(B,105)
#define	BIOCGDLT	_IOR(B,106, u_int)
#define BIOCGETIF	_IOR(B,107, struct ifreq)
#define BIOCSETIF	_IOW(B,108, struct ifreq)
#define BIOCSRTIMEOUT	_IOW(B,109, struct timeval)
#define BIOCGRTIMEOUT	_IOR(B,110, struct timeval)
#define BIOCGSTATS	_IOR(B,111, struct bpf_stat)
#define BIOCIMMEDIATE	_IOW(B,112, u_int)
#define BIOCVERSION	_IOR(B,113, struct bpf_version)
#define BIOCSRSIG	_IOW(B,114, u_int)
#define BIOCGRSIG	_IOR(B,115, u_int)
#else
a115 1
#endif
@


1.12.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.13 2000/06/19 03:00:54 jason Exp $	*/
d100 22
a121 1
 */
d137 1
@


1.12.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.12.4.1 2001/05/14 22:39:59 niklas Exp $	*/
a115 2
#define BIOCGHDRCMPLT	_IOR('B',116, u_int)
#define BIOCSHDRCMPLT	_IOW('B',117, u_int)
a164 1
#define DLT_PFLOG	17	/* Packet filter logging */
d246 1
a246 1
#endif /* _KERNEL */
@


1.12.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.12.4.2 2001/07/04 10:53:51 niklas Exp $	*/
a118 5
struct bpf_timeval {
	u_int32_t	tv_sec;
	u_int32_t	tv_usec;
};

d123 1
a123 1
	struct bpf_timeval bh_tstamp;	/* time stamp */
@


1.12.4.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d247 7
a253 7
int	 bpf_validate(struct bpf_insn *, int);
void	 bpf_tap(caddr_t, u_char *, u_int);
void	 bpf_mtap(caddr_t, struct mbuf *);
void	 bpfattach(caddr_t *, struct ifnet *, u_int, u_int);
void	 bpfdetach(struct ifnet *);
void	 bpfilterattach(int);
u_int	 bpf_filter(struct bpf_insn *, u_char *, u_int, u_int);
@


1.12.4.5
log
@Sync the SMP branch with 3.3
@
text
@d47 1
a47 1
/* BSD style release date */
d70 1
a70 1

d80 1
a80 1
 * Struct return by BIOCVERSION.  This represents the version number of
a172 1
#define DLT_PFSYNC	18	/* Packet filter state syncing */
@


1.12.4.6
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d172 1
a172 1
#define DLT_OLD_PFLOG	17	/* Packet filter logging, old (XXX remove?) */
a173 1
#define DLT_PFLOG	117	/* Packet filter logging, by pcap people */
@


1.12.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.12.4.6 2003/05/16 00:29:43 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a113 2
#define	BIOCLOCK	_IO('B',118)
#define	BIOCSETWF	_IOW('B',119, struct bpf_program)
a169 1
#define DLT_IEEE802_11	105	/* IEEE 802.11 wireless */
@


1.12.4.9
log
@Merge with the trunk
@
text
@d56 1
a56 1
#define BPF_MAXBUFSIZE (2 * 1024 * 1024)
a171 1
#define DLT_PPP_ETHER	51	/* PPP over Ethernet; session only, w/o ether header */
d238 1
a238 1
	u_int32_t k;
@


1.11
log
@fix link level type codes
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.10 1999/07/04 18:37:19 espie Exp $	*/
d265 1
@


1.10
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.9 1999/05/26 19:26:11 brad Exp $	*/
d184 3
a186 3
#define DLT_RAW		12	/* raw IP */
#define DLT_SLIP_BSDOS	13	/* BSD/OS Serial Line IP */
#define DLT_PPP_BSDOS	14	/* BSD/OS Point-to-point Protocol */
@


1.9
log
@Implement DLT_RAW, DLT_{SLIP,PPP}_BSDOS from libpcap 0.4
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.8 1998/06/26 09:13:11 deraadt Exp $	*/
d102 1
a102 1
 * header files.  If your using gcc, we assume that you
d189 1
a189 1
 * The instruction encondings.
@


1.8
log
@fix bpf select(); from mts@@rare.net
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.7 1998/06/10 23:57:09 provos Exp $	*/
d184 3
@


1.7
log
@make the packets which were successfully processed by IPSec available to
bpf via the enc0 interface, using linktype DLT_ENC.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.6 1998/06/04 23:11:37 deraadt Exp $	*/
d60 1
a60 1
#define BPF_MAXBUFSIZE 0x8000
d270 3
@


1.6
log
@add DLT_LOOP support; 4-byte header indicates proto; cstone@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.5 1997/03/17 16:29:37 niklas Exp $	*/
d183 1
@


1.5
log
@Removed static specifiers.  Align bpf headers on sizeof(long) boundaries
as it begins with a timeval struct.  This fixes the alpha bpf panics.
Removed double prototypes.  Reordered includes.  The last change came from
NetBSD.  Updated $NetBSD$ tags.  Slight KNF too.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.h,v 1.4 1996/07/12 07:57:41 mickey Exp $	*/
d182 1
@


1.4
log
@refresh to the latest bpf code release.
@
text
@d1 2
a2 2
/*	$OpenBSD: bpf.h,v 1.2 1996/03/03 21:07:02 niklas Exp $	*/
/*	$NetBSD: bpf.h,v 1.14 1996/05/02 00:57:28 cgd Exp $	*/
d53 2
a54 2
 * Alignment macros.  BPF_WORDALIGN rounds up to the next 
 * even multiple of BPF_ALIGNMENT. 
d56 2
a57 2
#define BPF_ALIGNMENT sizeof(u_int32_t)
#define BPF_WORDALIGN(x) (((x)+(BPF_ALIGNMENT-1))&~(BPF_ALIGNMENT-1))
@


1.3
log
@gross BPF_HDR hack, do better
@
text
@d47 5
d56 1
a56 1
#define BPF_ALIGNMENT sizeof(long)
d181 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: bpf.h,v 1.13 1996/02/13 21:59:58 christos Exp $	*/
d148 3
d153 3
d157 3
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: bpf.h,v 1.12 1995/09/27 18:30:40 thorpej Exp $	*/
a241 6
int	 bpfopen __P((dev_t, int));
int	 bpfclose __P((dev_t, int));
int	 bpfread __P((dev_t, struct uio *));
int	 bpfwrite __P((dev_t, struct uio *));
int	 bpfioctl __P((dev_t, u_long, caddr_t, int));
int	 bpf_select __P((dev_t, int, struct proc *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
