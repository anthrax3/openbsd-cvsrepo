head	1.35;
access;
symbols
	OPENBSD_6_0:1.35.0.6
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.12
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.10
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.35
date	2015.11.06.17.55.55;	author mpi;	state Exp;
branches;
next	1.34;
commitid	rF3eCQCnoqyAKLl5;

1.34
date	2015.10.08.08.41.58;	author mpi;	state Exp;
branches;
next	1.33;
commitid	OesGi9XmSKvtapL6;

1.33
date	2015.09.28.08.36.24;	author mpi;	state Exp;
branches;
next	1.32;
commitid	wT9nmVgN3CsJH8u1;

1.32
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.31;
commitid	RRi5waWu1LaKRicG;

1.31
date	2015.07.18.15.51.16;	author mpi;	state Exp;
branches;
next	1.30;
commitid	lwQKRpFyNEr7kjoF;

1.30
date	2015.07.16.18.17.27;	author claudio;	state Exp;
branches;
next	1.29;
commitid	VvtF6H2REt7RsEKf;

1.29
date	2015.03.04.15.53.29;	author claudio;	state Exp;
branches;
next	1.28;
commitid	HcUm5dlQngW9TTDu;

1.28
date	2015.02.06.01.21.17;	author mpi;	state Exp;
branches;
next	1.27;
commitid	hYUJkvmCO3leeXRT;

1.27
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.26;
commitid	zhW8jJrfVCoAthrR;

1.26
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.25;
commitid	Z1vcFtHO8wRH0yRt;

1.25
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.24;
commitid	w0MRp28dmfD1ZzO8;

1.24
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.23;
commitid	HQcmytntiCJTHORs;

1.23
date	2014.05.27.19.38.15;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.22.10.17.59;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.20.16.17.36;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.20.13.23.35;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.02.14.39.24;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.29.13.14.08;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.06.21.40.47;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.29.20.37.26;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.24.12.53.53;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.21.18.01.30;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.07.02.45.24;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.05.01.18.52;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.04.19.43.04;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.18.12.03.19;	author pascoe;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.18.11.47.45;	author pascoe;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.16.16.49.39;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.15.19.03.04;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.15.16.40.09;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.19.19.55.53;	author cedric;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.25.02.48.03;	author itojun;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Rename rt_mpath_next() into rtable_mpath_next() and provide an
implementation for ART based on the singly-linked list of route
entries.
@
text
@/*	$OpenBSD: radix_mpath.c,v 1.34 2015/10/08 08:41:58 mpi Exp $	*/
/*	$KAME: radix_mpath.c,v 1.13 2002/10/28 21:05:59 itojun Exp $	*/

/*
 * Copyright (C) 2001 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * THE AUTHORS DO NOT GUARANTEE THAT THIS SOFTWARE DOES NOT INFRINGE
 * ANY OTHERS' INTELLECTUAL PROPERTIES. IN NO EVENT SHALL THE AUTHORS
 * BE LIABLE FOR ANY INFRINGEMENT OF ANY OTHERS' INTELLECTUAL
 * PROPERTIES.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/socket.h>
#include <sys/domain.h>
#include <sys/syslog.h>
#include <net/radix.h>
#include <net/radix_mpath.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip_var.h>

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

int
rn_mpath_capable(struct radix_node_head *rnh)
{
	return rnh->rnh_multipath;
}

struct radix_node *
rn_mpath_next(struct radix_node *rn, int mode)
{
	struct radix_node	*next;
	struct rtentry		*nt, *rt = (struct rtentry *)rn;

	if (!rn->rn_dupedkey)
		return NULL;
	next = rn->rn_dupedkey;

	if (rn->rn_mask != next->rn_mask)
		return NULL;

	switch (mode) {
	case RMP_MODE_BYPRIO:
		/* scan all of the list until we find a match */
		while (next) {
			if (rn->rn_mask != next->rn_mask)
				return NULL;
			nt = (struct rtentry *)next;
			if ((rt->rt_priority & RTP_MASK) ==
			    (nt->rt_priority & RTP_MASK))
				return next;
			rn = next;
			next = next->rn_dupedkey;
		}
		return NULL;
	case RMP_MODE_ACTIVE:
		nt = (struct rtentry *)next;
		if (rt->rt_priority != nt->rt_priority)
			return NULL;
		break;
	case RMP_MODE_ALL:
		break;
	}
	return next;
}

/*
 * return first route matching prio or the node just before.
 */
struct radix_node *
rn_mpath_prio(struct radix_node *rn, u_int8_t prio)
{
	struct radix_node	*hit = rn;
	struct rtentry		*rt;

	if (prio == RTP_ANY)
		return (hit);

	do {
		rt = (struct rtentry *)rn;
		if (rt->rt_priority == prio)
			/* perfect match */
			return (rn);

		/* list is sorted remember last more prefered (smaller) entry */
		if (rt->rt_priority < prio)
			hit = rn;
	} while ((rn = rn_mpath_next(rn, RMP_MODE_ALL)) != NULL);

	return (hit);
}

/*
 * Adjust the RTF_MPATH flag for the part of the rn_dupedkey chain
 * that matches the prio.
 */
void
rn_mpath_adj_mpflag(struct radix_node *rn, u_int8_t prio)
{
	struct rtentry *rt = (struct rtentry *)rn;

	if (!rn)
		return;

	prio &= RTP_MASK;
	rt = rt_mpath_matchgate(rt, NULL, prio);
	rn = (struct radix_node *)rt;
	
	if (!rn)
		return;
	if (rn_mpath_next(rn, RMP_MODE_BYPRIO)) {
		while (rn != NULL) {
			((struct rtentry *)rn)->rt_flags |= RTF_MPATH;
			rn = rn_mpath_next(rn, RMP_MODE_BYPRIO);
		}
	} else
		rt->rt_flags &= ~RTF_MPATH;
}

int
rn_mpath_active_count(struct radix_node *rn)
{
	int i;

	i = 1;
	while ((rn = rn_mpath_next(rn, RMP_MODE_ACTIVE)) != NULL)
		i++;
	return i;
}

/*
 * return best matching route based on gateway and prio. If both are
 * specified it acts as a lookup function to get the actual rt.
 * If gate is NULL the first node matching the prio will be returned.
 */
struct rtentry *
rt_mpath_matchgate(struct rtentry *rt, struct sockaddr *gate, u_int8_t prio)
{
	struct radix_node *rn = (struct radix_node *)rt;

	do {
		rt = (struct rtentry *)rn;

		/* first find routes with correct priority */
		if (prio != RTP_ANY &&
		    (rt->rt_priority & RTP_MASK) != (prio & RTP_MASK))
			continue;
		/* if no gate is set we found a match */
		if (!gate)
			return rt;
		if (rt->rt_gateway->sa_len == gate->sa_len &&
		    !memcmp(rt->rt_gateway, gate, gate->sa_len))
			break;
	} while ((rn = rn_mpath_next(rn, RMP_MODE_ALL)) != NULL);

	return (struct rtentry *)rn;
}

/*
 * check if we have the same key/mask/gateway on the table already.
 */
int
rt_mpath_conflict(struct radix_node_head *rnh, struct sockaddr *dst,
    struct sockaddr *netmask, struct sockaddr *gate, u_int8_t prio, int mpathok)
{
	struct radix_node *rn1;
	struct rtentry *rt1;
	char *p, *q, *eq;
	int same, l, skip;

	rn1 = rn_lookup(dst, netmask, rnh);
	if (!rn1)
		return 0;

	/*
	 * unlike other functions we have in this file, we have to check
	 * all key/mask/gateway as rn_lookup can match less specific entry.
	 */
	rt1 = (struct rtentry *)rn1;

	/* compare key. */
	if (rt_key(rt1)->sa_len != dst->sa_len ||
	    bcmp(rt_key(rt1), dst, rt_key(rt1)->sa_len))
		goto different;

	/* key was the same.  compare netmask.  hairy... */
	if (rt_mask(rt1) && netmask) {
		skip = rnh->rnh_treetop->rn_off;
		if (rt_mask(rt1)->sa_len > netmask->sa_len) {
			/*
			 * as rt_mask(rt1) is made optimal by radix.c,
			 * there must be some 1-bits on rt_mask(rt1)
			 * after netmask->sa_len.  therefore, in
			 * this case, the entries are different.
			 */
			if (rt_mask(rt1)->sa_len > skip)
				goto different;
			else {
				/* no bits to compare, i.e. same*/
				goto maskmatched;
			}
		}

		l = rt_mask(rt1)->sa_len;
		if (skip > l) {
			/* no bits to compare, i.e. same */
			goto maskmatched;
		}
		p = (char *)rt_mask(rt1);
		q = (char *)netmask;
		if (bcmp(p + skip, q + skip, l - skip))
			goto different;
		/*
		 * need to go through all the bit, as netmask is not
		 * optimal and can contain trailing 0s
		 */
		eq = (char *)netmask + netmask->sa_len;
		q += l;
		same = 1;
		while (eq > q)
			if (*q++) {
				same = 0;
				break;
			}
		if (!same)
			goto different;
	} else if (!rt_mask(rt1) && !netmask)
		; /* no mask to compare, i.e. same */
	else {
		/* one has mask and the other does not, different */
		goto different;
	}

 maskmatched:
	if (!mpathok && rt1->rt_priority == prio)
		return EEXIST;

	/* key/mask were the same.  compare gateway for all multipaths */
	if (rt_mpath_matchgate(rt1, gate, prio))
		/* all key/mask/gateway are the same.  conflicting entry. */
		return EEXIST;

 different:
	return 0;
}

void
rn_mpath_reprio(struct radix_node *rn, int newprio)
{
	struct radix_node	*prev = rn->rn_p;
	struct radix_node	*next = rn->rn_dupedkey;
	struct radix_node	*t, *tt, *saved_tt, *head;
	struct rtentry		*rt = (struct rtentry *)rn;
	int			 mid, oldprio, prioinv = 0;

	oldprio = rt->rt_priority;
	rt->rt_priority = newprio;

	/* same prio, no change needed */
	if (oldprio == newprio)
		return;
	if (rn_mpath_next(rn, RMP_MODE_ALL) == NULL) {
		/* no need to move node, route is alone */
		if (prev->rn_mask != rn->rn_mask)
			return;
		/* ... or route is last and prio gets bigger */
		if (oldprio < newprio)
			return;
	}

	/* remove node from dupedkey list and reinsert at correct place */
	if (prev->rn_dupedkey == rn) {
		prev->rn_dupedkey = next;
		if (next)
			next->rn_p = prev;
		else
			next = prev;
	} else {
		if (next == NULL)
			panic("next == NULL");
		next->rn_p = prev;
		if (prev->rn_l == rn)
			prev->rn_l = next;
		else
			prev->rn_r = next;
	}

	/* re-insert rn at the right spot, so first rewind to the head */
	for (tt = next; tt->rn_p->rn_dupedkey == tt; tt = tt->rn_p)
		;
	saved_tt = tt;

	/*
	 * Stolen from radix.c rn_addroute().
	 * This is nasty code with a certain amount of magic and dragons.
	 * t is the element where the re-priorized rn is inserted -- before
	 * or after depending on prioinv. saved_tt points to the head of the
	 * dupedkey chain and tt is a bit of a helper
	 *
	 * First we skip with tt to the start of the mpath group then we
	 * search the right spot to enter our node.
	 */
	for (; tt; tt = tt->rn_dupedkey)
		if (rn->rn_mask == tt->rn_mask)
			break;
	head = tt; /* store current head entry for rn_mklist check */

	tt = rn_mpath_prio(tt, newprio);
	if (((struct rtentry *)tt)->rt_priority != newprio) {
		if (((struct rtentry *)tt)->rt_priority > newprio)
			prioinv = 1;
		t = tt;
	} else {
		mid = rn_mpath_active_count(tt) / 2;
		do {
			t = tt;
			tt = rn_mpath_next(tt, RMP_MODE_ACTIVE);
		} while (tt && --mid > 0);
	}

	/* insert rn before or after t depending on prioinv */
	rn_link_dupedkey(rn, t, prioinv);

	/* the rn_mklist needs to be fixed if the best route changed */
	if (rn->rn_mklist && rn->rn_flags & RNF_NORMAL) {
		if (rn->rn_mklist->rm_leaf != rn) {
			if (rn->rn_mklist->rm_leaf->rn_p == rn)
				/* changed route is now best */
				rn->rn_mklist->rm_leaf = rn;
		} else if (rn->rn_dupedkey != head) {
			/* rn moved behind head, so head is new head */
			rn->rn_mklist->rm_leaf = head;
		}
	}
}
@


1.34
log
@Use the radix API directly and get rid of the function pointers.  There
is no point in keeping an unused level of abstraction.

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.33 2015/09/28 08:36:24 mpi Exp $	*/
a96 8
}

struct rtentry *
rt_mpath_next(struct rtentry *rt)
{
	struct radix_node *rn = (struct radix_node *)rt;

	return ((struct rtentry *)rn_mpath_next(rn, RMP_MODE_ACTIVE));
@


1.33
log
@Factors ou the route hashing code to implement Equal-Cost Multi-Path
for ART.

While here sync the two remaining mix() macros.

ok chris@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.32 2015/09/01 21:24:04 bluhm Exp $	*/
d211 1
a211 1
	rn1 = rnh->rnh_lookup(dst, netmask, rnh);
d217 1
a217 1
	 * all key/mask/gateway as rnh_lookup can match less specific entry.
@


1.32
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.31 2015/07/18 15:51:16 mpi Exp $	*/
a54 7
u_int32_t rn_mpath_hash(struct sockaddr *, u_int32_t *);

/*
 * give some jitter to hash, to avoid synchronization between routers
 */
static u_int32_t hashjitter;

a374 107
}

/* Gateway selection by Hash-Threshold (RFC 2992) */
struct rtentry *
rn_mpath_select(struct rtentry *rt, uint32_t *srcaddrp)
{
	struct radix_node *rn;
	int hash, npaths, threshold;

	rn = (struct radix_node *)rt;
	npaths = rn_mpath_active_count(rn);
	hash = rn_mpath_hash(rt_key(rt), srcaddrp) & 0xffff;
	threshold = 1 + (0xffff / npaths);
	while (hash > threshold && rn) {
		/* stay within the multipath routes */
		rn = rn_mpath_next(rn, RMP_MODE_ACTIVE);
		hash -= threshold;
	}

	/* if gw selection fails, use the first match (default) */
	if (rn != NULL) {
		rtfree(rt);
		rt = (struct rtentry *)rn;
		rt->rt_refcnt++;
	}

	return (rt);
}

int
rn_mpath_inithead(void **head, int off)
{
	struct radix_node_head *rnh;

	while (hashjitter == 0)
		hashjitter = arc4random();
	if (rn_inithead(head, off) == 1) {
		rnh = (struct radix_node_head *)*head;
		rnh->rnh_multipath = 1;
		return 1;
	} else
		return 0;
}

/*
 * hash function based on pf_hash in pf.c
 */
#define mix(a,b,c) \
	do {					\
		a -= b; a -= c; a ^= (c >> 13);	\
		b -= c; b -= a; b ^= (a << 8);	\
		c -= a; c -= b; c ^= (b >> 13);	\
		a -= b; a -= c; a ^= (c >> 12);	\
		b -= c; b -= a; b ^= (a << 16);	\
		c -= a; c -= b; c ^= (b >> 5);	\
		a -= b; a -= c; a ^= (c >> 3);	\
		b -= c; b -= a; b ^= (a << 10);	\
		c -= a; c -= b; c ^= (b >> 15);	\
	} while (0)

u_int32_t
rn_mpath_hash(struct sockaddr *dst, u_int32_t *srcaddrp)
{
	u_int32_t a, b, c;

	a = b = 0x9e3779b9;
	c = hashjitter;

	switch (dst->sa_family) {
	case AF_INET:
	    {
		struct sockaddr_in *sin_dst;

		sin_dst = satosin(dst);
		a += sin_dst->sin_addr.s_addr;
		b += srcaddrp ? srcaddrp[0] : 0;
		mix(a, b, c);
		break;
	    }
#ifdef INET6
	case AF_INET6:
	    {
		struct sockaddr_in6 *sin6_dst;

		sin6_dst = satosin6(dst);
		a += sin6_dst->sin6_addr.s6_addr32[0];
		b += sin6_dst->sin6_addr.s6_addr32[2];
		c += srcaddrp ? srcaddrp[0] : 0;
		mix(a, b, c);
		a += sin6_dst->sin6_addr.s6_addr32[1];
		b += sin6_dst->sin6_addr.s6_addr32[3];
		c += srcaddrp ? srcaddrp[1] : 0;
		mix(a, b, c);
		a += sin6_dst->sin6_addr.s6_addr32[2];
		b += sin6_dst->sin6_addr.s6_addr32[1];
		c += srcaddrp ? srcaddrp[2] : 0;
		mix(a, b, c);
		a += sin6_dst->sin6_addr.s6_addr32[3];
		b += sin6_dst->sin6_addr.s6_addr32[0];
		c += srcaddrp ? srcaddrp[3] : 0;
		mix(a, b, c);
		break;
	    }
#endif /* INET6 */
	}

	return c;
@


1.31
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.30 2015/07/16 18:17:27 claudio Exp $	*/
d455 1
a455 1
		sin_dst = (struct sockaddr_in *)dst;
d466 1
a466 1
		sin6_dst = (struct sockaddr_in6 *)dst;
@


1.30
log
@Fix rn_match and there for the expoerted lookup functions in radix.c
to never return the internal RNF_ROOT nodes. This removes the checks
in the callee to verify that not an RNF_ROOT node was returned.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.29 2015/03/04 15:53:29 claudio Exp $	*/
d384 1
a384 3
/*
 * allocate a route, potentially using multipath to select the peer.
 */
d386 1
a386 1
rtalloc_mpath(struct sockaddr *dst, u_int32_t *srcaddrp, u_int rtableid)
a387 1
	struct rtentry *rt;
a390 16
	rt = rtalloc(dst, RT_REPORT|RT_RESOLVE, rtableid);

	/* if the route does not exist or it is not multipath, don't care */
	if (rt == NULL || !ISSET(rt->rt_flags, RTF_MPATH))
		return (rt);

	/* check if multipath routing is enabled for the specified protocol */
	if (!(0
	    || (ipmultipath && dst->sa_family == AF_INET)
#ifdef INET6
	    || (ip6_multipath && dst->sa_family == AF_INET6)
#endif
	    ))
		return (rt);

	/* gw selection by Hash-Threshold (RFC 2992) */
d393 1
a393 1
	hash = rn_mpath_hash(dst, srcaddrp) & 0xffff;
@


1.29
log
@Make sure that rn_mpath_adj_mpflag() is called with the correct pointer
to the multipath chain when removing routes. This fixes the sbin/route
testcases 17-19 and fixes an annoying opsfd bug because of routes
wrongly marked as multipath ones.
OK deraadt, mpi, sthen, benno, phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.28 2015/02/06 01:21:17 mpi Exp $	*/
d219 1
a219 1
	if (!rn1 || rn1->rn_flags & RNF_ROOT)
@


1.28
log
@Change rt_mpath_conflict() to not rely on an initialized rtentry when
checking for actual conflict.

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.27 2014/12/19 17:14:40 tedu Exp $	*/
d148 3
@


1.27
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.26 2014/11/18 02:37:31 tedu Exp $	*/
d207 2
a208 2
rt_mpath_conflict(struct radix_node_head *rnh, struct rtentry *rt,
		   struct sockaddr *netmask, int mpathok)
d210 1
a210 1
	struct radix_node *rn, *rn1;
d215 1
a215 2
	rn = (struct radix_node *)rt;
	rn1 = rnh->rnh_lookup(rt_key(rt), netmask, rnh);
d226 2
a227 2
	if (rt_key(rt1)->sa_len != rt_key(rt)->sa_len ||
	    bcmp(rt_key(rt1), rt_key(rt), rt_key(rt1)->sa_len))
d279 1
a279 1
	if (!mpathok && rt1->rt_priority == rt->rt_priority)
d283 1
a283 1
	if (rt_mpath_matchgate(rt1, rt->rt_gateway, rt->rt_priority))
@


1.26
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.25 2014/11/01 21:40:38 mpi Exp $	*/
a388 1
#if defined(INET) || defined(INET6)
a390 1
#endif
a399 1
#ifdef INET
a400 1
#endif
a406 1
#if defined(INET) || defined(INET6)
a423 1
#endif
a467 1
#ifdef INET
a477 1
#endif /* INET */
@


1.25
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.24 2014/09/27 12:26:16 mpi Exp $	*/
a45 1
#include <dev/rndvar.h>
@


1.24
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.23 2014/05/27 19:38:15 claudio Exp $	*/
d395 1
a395 1
	rt = rtalloc1(dst, RT_REPORT, rtableid);
@


1.23
log
@Big refactoring of the radix code (mainly rn_addroute but also part
of rn_delete was changed). The mpath code gets a much better
rn_mpath_next() function that allows looping through the dupedkey list
based on prio, any or only active routes. This solves the issues seen
with failed deletes of down routes.
Commit this now so that it gets tested. Both sthen@@ and blambert@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.22 2014/01/22 10:17:59 claudio Exp $	*/
d56 1
a56 1
u_int32_t rn_mpath_hash(struct route *, u_int32_t *);
d386 2
a387 2
void
rtalloc_mpath(struct route *ro, u_int32_t *srcaddrp)
d389 1
d395 1
a395 7
	/*
	 * return a cached entry if it is still valid, otherwise we increase
	 * the risk of disrupting local flows.
	 */
	if (ro->ro_rt && ro->ro_rt->rt_ifp && (ro->ro_rt->rt_flags & RTF_UP))
		return;
	ro->ro_rt = rtalloc1(&ro->ro_dst, RT_REPORT, ro->ro_tableid);
d398 2
a399 2
	if (!ro->ro_rt || !(ro->ro_rt->rt_flags & RTF_MPATH))
		return;
d404 1
a404 1
	    || (ipmultipath && ro->ro_dst.sa_family == AF_INET)
d407 1
a407 1
	    || (ip6_multipath && ro->ro_dst.sa_family == AF_INET6)
d410 1
a410 1
		return;
d414 1
a414 1
	rn = (struct radix_node *)ro->ro_rt;
d416 1
a416 1
	hash = rn_mpath_hash(ro, srcaddrp) & 0xffff;
d425 6
a430 2
	if (!rn)
		return;
d432 1
a432 4
	rtfree(ro->ro_rt);
	ro->ro_rt = (struct rtentry *)rn;
	ro->ro_rt->rt_refcnt++;
#endif
d467 1
a467 1
rn_mpath_hash(struct route *ro, u_int32_t *srcaddrp)
d474 1
a474 1
	switch (ro->ro_dst.sa_family) {
d480 1
a480 1
		sin_dst = (struct sockaddr_in *)&ro->ro_dst;
d492 1
a492 1
		sin6_dst = (struct sockaddr_in6 *)&ro->ro_dst;
@


1.22
log
@Kill the RN_DEBUG code it is broken since rev 1.1 and not worth fixing.
OK mpi@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.21 2013/10/20 16:17:36 claudio Exp $	*/
a40 1
#define	M_DONTWAIT M_NOWAIT
d70 1
a70 1
rn_mpath_next(struct radix_node *rn, int all)
d73 1
a73 1
	struct rtentry		*rt = (struct rtentry *)rn;
d78 2
a79 4
	if (rn->rn_mask == next->rn_mask && (all ||
	    rt->rt_priority == ((struct rtentry *)next)->rt_priority))
		return next;
	else
d81 32
d115 3
d121 1
a121 1
	struct radix_node	*prev = rn;
d125 1
a125 6
		return (rn);

	while (rn) {
		/* different netmask -> different route */
		if (rn->rn_mask != prev->rn_mask)
			return (prev);
d127 1
d130 1
d132 7
a138 7
		if (rt->rt_priority > prio)
			/* list is sorted return last more prefered entry */
			return (prev);
		prev = rn;
		rn = rn->rn_dupedkey;
	}
	return (prev);
d141 4
d146 1
a146 1
rn_mpath_reprio(struct radix_node *rn, int newprio)
d148 1
a148 5
	struct radix_node	*prev = rn->rn_p;
	struct radix_node	*next = rn->rn_dupedkey;
	struct radix_node	*t, *tt, *saved_tt, *head;
	struct rtentry		*rt = (struct rtentry *)rn;
	int			 mid, oldprio, prioinv = 0;
d150 5
a154 5
	oldprio = rt->rt_priority;
	rt->rt_priority = newprio;

	/* same prio, no change needed */
	if (oldprio == newprio)
d156 4
a159 92
	if (rn_mpath_next(rn, 1) == NULL) {
		/* no need to move node, route is alone */
		if (prev->rn_mask != rn->rn_mask)
			return;
		/* ... or route is last and prio gets bigger */
		if (oldprio < newprio)
			return;
	}

	/* remove node from dupedkey list and reinsert at correct place */
	if (prev->rn_dupedkey == rn) {
		prev->rn_dupedkey = next;
		if (next)
			next->rn_p = prev;
		else
			next = prev;
	} else {
		if (next == NULL)
			panic("next == NULL");
		next->rn_p = prev;
		if (prev->rn_l == rn)
			prev->rn_l = next;
		else
			prev->rn_r = next;
	}

	/* re-insert rn at the right spot, so first rewind to the head */
	for (tt = next; tt->rn_p->rn_dupedkey == tt; tt = tt->rn_p)
		;
	saved_tt = tt;

	/*
	 * Stolen from radix.c rn_addroute().
	 * This is nasty code with a certain amount of magic and dragons.
	 * t is the element where the re-priorized rn is inserted -- before
	 * or after depending on prioinv. saved_tt points to the head of the
	 * dupedkey chain and tt is a bit of a helper
	 *
	 * First we skip with tt to the start of the mpath group then we
	 * search the right spot to enter our node.
	 */
	for (; tt; tt = tt->rn_dupedkey)
		if (rn->rn_mask == tt->rn_mask)
			break;
	head = tt; /* store current head entry for rn_mklist check */

	tt = rn_mpath_prio(tt, newprio);
	if (((struct rtentry *)tt)->rt_priority != newprio) {
		if (((struct rtentry *)tt)->rt_priority > newprio)
			prioinv = 1;
		t = tt;
	} else {
		mid = rn_mpath_active_count(tt) / 2;
		do {
			t = tt;
			tt = rn_mpath_next(tt, 0);
		} while (tt && --mid > 0);
	}

	/* insert rn before or after t depending on prioinv, tt and saved_tt */
	if (tt == saved_tt && prioinv) {
		/* link in at head of list */
		rn->rn_dupedkey = tt;
		rn->rn_p = tt->rn_p;
		tt->rn_p = rn;
		if (rn->rn_p->rn_l == tt)
			rn->rn_p->rn_l = rn;
		else
			rn->rn_p->rn_r = rn;
	} else if (prioinv == 1) {
		rn->rn_dupedkey = t;
		t->rn_p->rn_dupedkey = rn;
		rn->rn_p = t->rn_p;
		t->rn_p = rn;
	} else {
		rn->rn_dupedkey = t->rn_dupedkey;
		t->rn_dupedkey = rn;
		rn->rn_p = t;
		if (rn->rn_dupedkey)
			rn->rn_dupedkey->rn_p = rn;
	}

	if (rn->rn_mklist && rn->rn_flags & RNF_NORMAL) {
		/* the rn_mklist needs to be fixed if the best route changed */
		if (rn->rn_mklist->rm_leaf != rn) {
			if (rn->rn_mklist->rm_leaf->rn_p == rn)
				/* changed route is now best */
				rn->rn_mklist->rm_leaf = rn;
		} else {
			if (rn->rn_dupedkey != head)
				/* rn moved behind head, so head is new head */
				rn->rn_mklist->rm_leaf = head;
d161 2
a162 1
	}
d171 1
a171 1
	while ((rn = rn_mpath_next(rn, 0)) != NULL)
d176 5
d193 2
a194 5
		/*
		 * if gate is set it must be compared, if not set the route
		 * must be a non-multipath one.
		 */
		if (!gate && !rn_mpath_next(rn, 0))
a195 4
		if (!gate)
			return NULL;
		if (!rt->rt_gateway)
			continue;
d199 1
a199 1
	} while ((rn = rn_mpath_next(rn, 1)) != NULL);
a283 1
	rn1 = rn_mpath_prio((struct radix_node *)rt1, rt->rt_priority);
d285 1
a285 12
	do {
		rt1 = (struct rtentry *)rn1;

		/* sanity: no use in comparing the same thing */
		if (rn1 == rn)
			continue;

		if (rt1->rt_gateway->sa_len != rt->rt_gateway->sa_len ||
		    bcmp(rt1->rt_gateway, rt->rt_gateway,
		    rt1->rt_gateway->sa_len))
			continue;

a287 1
	} while ((rn1 = rn_mpath_next(rn1, 0)) != NULL);
d293 90
d425 1
a425 3
		if (rn_mpath_next(rn, 0) == NULL)
			break;
		rn = rn->rn_dupedkey;
a427 2

	/* XXX try filling rt_gwroute and avoid unreachable gw  */
@


1.21
log
@Rename rn_mpath_count() to rn_mpath_active_count() since it will only
return the number of active aka RTF_UP multipath routes. OK grep & gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.20 2013/10/20 13:23:35 claudio Exp $	*/
a62 3
#ifdef RN_DEBUG
extern struct radix_node	*rn_clist;
#endif
a207 10

#ifdef RN_DEBUG
	/* readd at head of creation list */
	for (t = rn_clist; t && t->rn_ybro != rn; t = t->rn_ybro)
		;
	if (t)
		t->rn_ybro = rn->rn_ybro;
	rn->rn_ybro = rn_clist;
	rn_clist = rn;
#endif
@


1.20
log
@In rt_mpath_conflict() there is no need to check the priority in the loop
since rt_mpath_prio() and rt_mpath_next() ensure that this is always the
case.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.19 2013/04/10 08:50:59 mpi Exp $	*/
d182 1
a182 1
		mid = rn_mpath_count(tt) / 2;
d237 1
a237 1
rn_mpath_count(struct radix_node *rn)
d416 1
a416 1
	npaths = rn_mpath_count(rn);
@


1.19
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.18 2010/05/07 13:33:16 claudio Exp $	*/
a368 4
			continue;

		/* check the route priority */
		if (rt1->rt_priority != rt->rt_priority)
@


1.18
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.17 2009/03/02 14:39:24 claudio Exp $	*/
d50 1
d52 4
a55 2
extern int ipmultipath;
extern int ip6_multipath;
@


1.17
log
@Make sure rt_gateway is not NULL in rt_mpath_matchgate(). It is possible to
hit this case with a root node that comes with no real rtentry attached to it.
Problem found by Mischa Diehm, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.16 2009/01/29 13:14:08 claudio Exp $	*/
d384 1
a384 1
rtalloc_mpath(struct route *ro, u_int32_t *srcaddrp, u_int tableid)
d397 1
a397 1
	ro->ro_rt = rtalloc1(&ro->ro_dst, 1, tableid);
@


1.16
log
@Fix a crash found by bluhm@@ in rn_mpath_reprio(). The rn_mklist handling was
wrong which resulted in a NULL rm_leaf which caussed a NULL deref a bit later.
Check against the right route nodes to figure out if the rm_leaf needs to be
updated. Tested by bluhm@@, OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.15 2009/01/06 21:40:47 claudio Exp $	*/
d264 2
a265 1

@


1.15
log
@Change the way way rn_mklists work (especially the RNF_NORMAL ones).
Until now RNF_NORMAL masks did not use the refcount because only one route
in a particular subtree could have this mask. With multipath routing this is
no longer correct. The result was wrong backtracking information beeing stored
in the radix tree and so cretain lookups ended up on the wrong multipath nodes.
Use rm_refs for RNF_NORMAL masks so that all multipath routes are able
to point to the same radix_mask entry. Additional logic ensures that rm_leaf
always points back to the head of the multipath rn_dupedkey chain.
Tested by dlg@@, gollo@@, david@@, sthen@@ and a few more
This can have my OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.14 2008/12/29 20:37:26 claudio Exp $	*/
d117 1
a117 1
	struct radix_node	*t, *tt, *saved_tt;
d171 1
a171 1
	next = tt->rn_dupedkey; /* store next entry for rn_mklist check */
d219 1
a219 1
	if (rn->rn_mklist) {
d226 3
a228 3
			if (rn->rn_dupedkey != next)
				/* rn moved behind next, next is new head */
				rn->rn_mklist->rm_leaf = next;
@


1.14
log
@Use rn_mpath_next() in rtalloc_mpath() to figure out if the next route
belongs to the same multipath group instead of own wrong check which failed
to look at the priority.
Found and diff tested by gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.13 2008/11/24 12:53:53 claudio Exp $	*/
d128 1
a128 1
		/* no need to move node route is alone */
d153 2
a154 3
	/* re-insert rn at the right spot */
	for (tt = next; tt->rn_p->rn_mask == rn->rn_mask;
	    tt = tt->rn_p)
d162 5
a166 1
	 * or after depending on prioinv. tt and saved_tt are just helpers.
d168 5
d186 1
d208 1
d211 1
a211 1
	for (t = rn_clist; t && t->rn_ybro != rn; t->rn_ybro)
d218 13
@


1.13
log
@Implement link-state tracking on the routing table. Routes to interfaces
which are considered down will no be marked ~RTF_UP and so multipath routing
will start to work as expected and not pump 50% of the traffic to nirvana.
Most of the magic happens in rn_mpath_reprio() which fiddles with the
routing table internals. The rest is more straight forward.
get it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.12 2008/11/21 18:01:30 claudio Exp $	*/
d398 1
a398 1
		if (rn->rn_dupedkey && rn->rn_mask != rn->rn_dupedkey->rn_mask)
@


1.12
log
@Change rn_mpath_next() to be able to walk over the full multipath list
not only over routes of the same prio. This makes it possible to modify
rt_mpath_matchgate() so that if only gateway is specified without a specific
priority it will scan the full list and not only the first routes.
This is also needed for upcoming link state tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.11 2008/05/07 05:14:21 claudio Exp $	*/
d60 3
d110 98
@


1.11
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.10 2008/05/07 02:45:24 claudio Exp $	*/
d68 1
a68 1
rn_mpath_next(struct radix_node *rn)
d76 2
a77 2
	if (rn->rn_mask == next->rn_mask &&
	    rt->rt_priority == ((struct rtentry *)next)->rt_priority)
d115 1
a115 1
	while ((rn = rn_mpath_next(rn)) != NULL)
d125 2
a126 5
	rn = rn_mpath_prio((struct radix_node *)rt, prio);
	rt = (struct rtentry *)rn;
	/* check if returned node has same priority */
	if (prio != RTP_ANY && rt->rt_priority != prio)
		return NULL;
d128 12
a139 8
	/*
	 * if gate is set it must be compared, if not set the route must be
	 * a non-multipath one.
	 */
	if (!gate && !rn_mpath_next(rn))
		return rt;
	if (!gate)
		return NULL;
a140 2
	do {
		rt = (struct rtentry *)rn;
d144 1
a144 1
	} while ((rn = rn_mpath_next(rn)) != NULL);
d249 1
a249 1
	} while ((rn1 = rn_mpath_next(rn1)) != NULL);
@


1.10
log
@Redo rev 1.8 but this time with an additional fix to solve the dhclient crashes
seen by krw. This is a prerequisite for upcomming routing priorities:
Always compare the nexthop if one is specified even if it is a non-multipath
route. This mostly affects "route delete" and it will not remove the last
route if previous delete is redone. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.9 2007/12/05 01:18:52 krw Exp $	*/
d70 2
a71 1
	struct radix_node *next;
d76 2
a77 1
	if (rn->rn_mask == next->rn_mask)
d83 26
d121 1
a121 1
rt_mpath_matchgate(struct rtentry *rt, struct sockaddr *gate)
d125 6
d227 1
a227 1
	if (!mpathok)
d230 1
d242 4
@


1.9
log
@Revert change which seems to break things like dhclient. Requested by
deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.8 2007/12/04 19:43:04 claudio Exp $	*/
d95 1
a95 1
	struct radix_node *rn;
d97 5
a101 1
	if (!rn_mpath_next((struct radix_node *)rt))
a102 1

d105 1
a105 2
	/* beyond here, we use rn as the master copy */
	rn = (struct radix_node *)rt;
a111 2
	if (!rn)
		return NULL;
@


1.8
log
@Always compare the nexthop if one is specified even if it is a non-multipath
route. This mostly affects "route delete" and it will not remove the last
route if previous delete is redone. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.7 2006/06/18 12:03:19 pascoe Exp $	*/
d95 1
a95 1
	struct radix_node *rn = (struct radix_node *)rt;
d97 1
a97 5
	/*
	 * if gate is set it must be compared, if not set the route must be
	 * a non-multipath one.
	 */
	if (!gate && !rn_mpath_next(rn))
d99 1
d102 2
a103 1

d110 2
@


1.7
log
@Whitespace, oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.6 2006/06/18 11:47:45 pascoe Exp $	*/
d95 1
a95 1
	struct radix_node *rn;
d97 5
a101 1
	if (!rn_mpath_next((struct radix_node *)rt))
a102 1

d105 1
a105 2
	/* beyond here, we use rn as the master copy */
	rn = (struct radix_node *)rt;
a111 2
	if (!rn)
		return NULL;
@


1.6
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.5 2006/06/16 16:49:39 henning Exp $	*/
d231 1
a231 1
	 */ 
@


1.5
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.4 2005/05/15 19:03:04 henning Exp $	*/
d49 7
a63 1

d217 3
d221 1
a221 1
rtalloc_mpath(struct route *ro, int hash, u_int tableid)
d223 4
a226 2
	struct radix_node *rn0, *rn;
	int n;
d229 3
a231 3
	 * XXX we don't attempt to lookup cached route again; what should
	 * be done for sendto(2) case?
	 */
d233 1
a233 1
		return;				 /* XXX */
d235 1
d237 1
a237 1
	if (!ro->ro_rt || !rn_mpath_next((struct radix_node *)ro->ro_rt))
d240 10
a249 3
	/* beyond here, we use rn as the master copy */
	rn0 = rn = (struct radix_node *)ro->ro_rt;
	n = rn_mpath_count(rn0);
d251 7
a257 4
	/* gw selection by Modulo-N Hash (RFC2991) XXX need improvement? */
	hash += hashjitter;
	hash %= n;
	while (hash-- > 0 && rn) {
d262 1
d274 1
d282 2
a283 1
	hashjitter = arc4random();
d290 67
@


1.4
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.3 2005/05/15 16:40:09 henning Exp $	*/
d212 1
a212 1
rtalloc_mpath(struct route *ro, int hash)
d223 1
a223 1
	ro->ro_rt = rtalloc1(&ro->ro_dst, 1);
@


1.3
log
@ANSI, mostly from Toni Mueller <openbsd-tech@@oeko.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.2 2004/06/19 19:55:53 cedric Exp $	*/
d219 1
a219 1
	 * be done for sendto(3) case?
@


1.2
log
@require RTF_MPATH to enter a multipath route with RTM_ADD.
route(8) takes a new -mpath modifier to enter a multipath route.
requested deraadt@@, ok itojun@@ mcbride@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radix_mpath.c,v 1.1 2004/04/25 02:48:03 itojun Exp $	*/
d55 1
a55 2
rn_mpath_capable(rnh)
	struct radix_node_head *rnh;
d62 1
a62 2
rn_mpath_next(rn)
	struct radix_node *rn;
d76 1
a76 2
rn_mpath_count(rn)
	struct radix_node *rn;
d87 1
a87 3
rt_mpath_matchgate(rt, gate)
	struct rtentry *rt;
	struct sockaddr *gate;
d114 2
a115 5
rt_mpath_conflict(rnh, rt, netmask, mpathok)
	struct radix_node_head *rnh;
	struct rtentry *rt;
	struct sockaddr *netmask;
	int mpathok;
d212 1
a212 3
rtalloc_mpath(ro, hash)
	struct route *ro;
	int hash;
d254 1
a254 3
rn_mpath_inithead(head, off)
	void **head;
	int off;
@


1.1
log
@radix tree with multipath support.  from kame.  deraadt ok
user visible changes:
- you can add multiple routes with same key (route add A B then route add A C)
- you have to specify gateway address if there are multiple entries on the table
  (route delete A B, instead of route delete A)
kernel change:
- radix_node_head has an extra entry
- rnh_deladdr takes extra argument

TODO:
- actually take advantage of multipath (rtalloc -> rtalloc_mpath)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 1
a119 1
rt_mpath_conflict(rnh, rt, netmask)
d123 1
d194 3
a196 1
 maskmatched:;
@


1.1.2.1
log
@Merge with the trunk
@
text
@@

