head	1.173;
access;
symbols
	OPENBSD_6_1_BASE:1.173
	OPENBSD_6_0:1.168.0.4
	OPENBSD_6_0_BASE:1.168
	OPENBSD_5_9:1.166.0.2
	OPENBSD_5_9_BASE:1.166
	OPENBSD_5_8:1.151.0.4
	OPENBSD_5_8_BASE:1.151
	OPENBSD_5_7:1.132.0.2
	OPENBSD_5_7_BASE:1.132
	OPENBSD_5_6:1.127.0.4
	OPENBSD_5_6_BASE:1.127
	OPENBSD_5_5:1.120.0.4
	OPENBSD_5_5_BASE:1.120
	OPENBSD_5_4:1.115.0.2
	OPENBSD_5_4_BASE:1.115
	OPENBSD_5_3:1.112.0.8
	OPENBSD_5_3_BASE:1.112
	OPENBSD_5_2:1.112.0.6
	OPENBSD_5_2_BASE:1.112
	OPENBSD_5_1_BASE:1.112
	OPENBSD_5_1:1.112.0.4
	OPENBSD_5_0:1.112.0.2
	OPENBSD_5_0_BASE:1.112
	OPENBSD_4_9:1.109.0.2
	OPENBSD_4_9_BASE:1.109
	OPENBSD_4_8:1.107.0.2
	OPENBSD_4_8_BASE:1.107
	OPENBSD_4_7:1.105.0.2
	OPENBSD_4_7_BASE:1.105
	OPENBSD_4_6:1.97.0.4
	OPENBSD_4_6_BASE:1.97
	OPENBSD_4_5:1.96.0.2
	OPENBSD_4_5_BASE:1.96
	OPENBSD_4_4:1.94.0.2
	OPENBSD_4_4_BASE:1.94
	OPENBSD_4_3:1.91.0.2
	OPENBSD_4_3_BASE:1.91
	OPENBSD_4_2:1.89.0.2
	OPENBSD_4_2_BASE:1.89
	OPENBSD_4_1:1.85.0.2
	OPENBSD_4_1_BASE:1.85
	OPENBSD_4_0:1.79.0.2
	OPENBSD_4_0_BASE:1.79
	OPENBSD_3_9:1.74.0.2
	OPENBSD_3_9_BASE:1.74
	OPENBSD_3_8:1.68.0.2
	OPENBSD_3_8_BASE:1.68
	OPENBSD_3_7:1.64.0.2
	OPENBSD_3_7_BASE:1.64
	OPENBSD_3_6:1.61.0.2
	OPENBSD_3_6_BASE:1.61
	SMP_SYNC_A:1.59
	SMP_SYNC_B:1.59
	OPENBSD_3_5:1.58.0.2
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.49.0.2
	OPENBSD_3_4_BASE:1.49
	UBC_SYNC_A:1.47
	OPENBSD_3_3:1.45.0.2
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.43.0.2
	OPENBSD_3_2_BASE:1.43
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.43
	UBC:1.40.0.2
	UBC_BASE:1.40
	OPENBSD_3_0:1.39.0.2
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9_BASE:1.33
	OPENBSD_2_9:1.33.0.2
	OPENBSD_2_8:1.29.0.4
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.29.0.2
	OPENBSD_2_7_BASE:1.29
	SMP:1.28.0.2
	SMP_BASE:1.28
	kame_19991208:1.28
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.24.0.4
	OPENBSD_2_5_BASE:1.24
	OPENBSD_2_4:1.24.0.2
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.22.0.2
	OPENBSD_2_3_BASE:1.22
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.14.0.2
	OPENBSD_2_0_BASE:1.14
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.173
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.172;
commitid	6c6qq5OdS4VVnyVM;

1.172
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.171;
commitid	VyLWTsbepAOk7VQM;

1.171
date	2016.12.21.13.13.01;	author mikeb;	state Exp;
branches;
next	1.170;
commitid	ozFGpM8R39zrggjy;

1.170
date	2016.12.12.09.51.30;	author mpi;	state Exp;
branches;
next	1.169;
commitid	4shAe6LbqmAnsu7t;

1.169
date	2016.09.04.15.46.39;	author reyk;	state Exp;
branches;
next	1.168;
commitid	05wK3oqe2BKozGUg;

1.168
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.167;
commitid	Xo6g1xk26RWDGcjJ;

1.167
date	2016.03.01.21.47.52;	author stsp;	state Exp;
branches;
next	1.166;
commitid	3sFpj2WevbU5W9d5;

1.166
date	2016.01.31.13.54.13;	author stefan;	state Exp;
branches;
next	1.165;
commitid	R4X61RORL7hWwUvP;

1.165
date	2016.01.07.05.31.17;	author guenther;	state Exp;
branches;
next	1.164;
commitid	SRBGEkRcMG3FAm8C;

1.164
date	2015.12.05.16.09.09;	author yasuoka;	state Exp;
branches;
next	1.163;
commitid	eScyCzcQlMEbBURx;

1.163
date	2015.11.20.12.20.30;	author mpi;	state Exp;
branches;
next	1.162;
commitid	4RMunOPdYfQoD801;

1.162
date	2015.11.20.05.38.10;	author dlg;	state Exp;
branches;
next	1.161;
commitid	7BVssPH7N0HCX4Uq;

1.161
date	2015.11.20.05.15.33;	author dlg;	state Exp;
branches;
next	1.160;
commitid	PXDFralC2jpPwYxx;

1.160
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.159;
commitid	eYnPulzvLjDImPCa;

1.159
date	2015.10.25.12.05.40;	author mpi;	state Exp;
branches;
next	1.158;
commitid	iXTa9MhdGfWGiTE6;

1.158
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.157;
commitid	G2nTzngqgXpQqcJB;

1.157
date	2015.10.24.04.12.24;	author dlg;	state Exp;
branches;
next	1.156;
commitid	wyJhjbYgc7SnSG5y;

1.156
date	2015.10.23.15.08.24;	author claudio;	state Exp;
branches;
next	1.155;
commitid	5RjoeWACD03f7MXN;

1.155
date	2015.09.10.17.41.15;	author dlg;	state Exp;
branches;
next	1.154;
commitid	kbDgy0mWgx8fG2GH;

1.154
date	2015.09.09.20.18.03;	author dlg;	state Exp;
branches;
next	1.153;
commitid	UYC1HuxhVMGtUanY;

1.153
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.152;
commitid	RRi5waWu1LaKRicG;

1.152
date	2015.08.28.15.37.04;	author reyk;	state Exp;
branches;
next	1.151;
commitid	XREOhbo6GiCuxIbS;

1.151
date	2015.07.20.22.54.29;	author mpi;	state Exp;
branches;
next	1.150;
commitid	kUJLGGhKrehg9sRa;

1.150
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.149;
commitid	ncpqEGjDtSFuLAgn;

1.149
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.148;
commitid	9ERVupAoYqW4Iok9;

1.148
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.147;
commitid	fE8TgA9vpwdUU5Wy;

1.147
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.146;
commitid	MVWrtktB46JRxFWT;

1.146
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.145;
commitid	h7z8lokZ0dFyuWpg;

1.145
date	2015.06.01.07.48.04;	author mpi;	state Exp;
branches;
next	1.144;
commitid	yw17xJE2GwOy0XZZ;

1.144
date	2015.05.26.11.36.26;	author dlg;	state Exp;
branches;
next	1.143;
commitid	XIDnUp3itFSZuopj;

1.143
date	2015.05.20.08.28.54;	author mpi;	state Exp;
branches;
next	1.142;
commitid	fTNkviHPk3FLJmC5;

1.142
date	2015.05.19.15.10.59;	author mpi;	state Exp;
branches;
next	1.141;
commitid	3cm5aSOIpt8l1gCH;

1.141
date	2015.05.15.12.40.05;	author mpi;	state Exp;
branches;
next	1.140;
commitid	QGNGwrIsY12C2TEX;

1.140
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.139;
commitid	1aiWjheMGhmTuiHL;

1.139
date	2015.04.30.15.19.50;	author mpi;	state Exp;
branches;
next	1.138;
commitid	O1SV1dtTjb2Ydl3U;

1.138
date	2015.04.29.16.00.06;	author deraadt;	state Exp;
branches;
next	1.137;
commitid	sx5PrAMpqsz5YRe8;

1.137
date	2015.04.15.10.11.29;	author mpi;	state Exp;
branches;
next	1.136;
commitid	8Osj0shuVLl2SeHR;

1.136
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.135;
commitid	c7ei8kPelCOOwHXy;

1.135
date	2015.04.01.14.29.54;	author mpi;	state Exp;
branches;
next	1.134;
commitid	YvwyndathKBmcy5L;

1.134
date	2015.03.18.12.23.15;	author dlg;	state Exp;
branches;
next	1.133;
commitid	veRr3qZI7HBatTwk;

1.133
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.132;
commitid	p4LJxGKbi0BU2cG6;

1.132
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.131;
commitid	C5iGb36LQxjM60Q3;

1.131
date	2015.01.21.02.23.14;	author guenther;	state Exp;
branches;
next	1.130;
commitid	z0tt692wWLCZ7FbG;

1.130
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.129;
commitid	zhW8jJrfVCoAthrR;

1.129
date	2014.10.21.10.52.53;	author yasuoka;	state Exp;
branches;
next	1.128;
commitid	yUVe4HyafiEJIH3w;

1.128
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.127;
commitid	ZqXwxwmeo3l29NOg;

1.127
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.126;
commitid	DQakU8LLWV6Iwx84;

1.126
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.125;
commitid	B4dZSbxas1X1IpXI;

1.125
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.124;

1.124
date	2014.04.22.14.41.03;	author mpi;	state Exp;
branches;
next	1.123;

1.123
date	2014.04.18.15.20.00;	author henning;	state Exp;
branches;
next	1.122;

1.122
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.120;

1.120
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.119;

1.119
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.118;

1.118
date	2013.10.19.14.46.31;	author mpi;	state Exp;
branches;
next	1.117;

1.117
date	2013.10.17.16.27.41;	author bluhm;	state Exp;
branches;
next	1.116;

1.116
date	2013.10.04.08.40.32;	author mpi;	state Exp;
branches;
next	1.115;

1.115
date	2013.05.25.10.05.52;	author mikeb;	state Exp;
branches;
next	1.114;

1.114
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2013.03.26.13.19.26;	author mpi;	state Exp;
branches;
next	1.112;

1.112
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2011.07.07.20.42.56;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.23.04.47.02;	author matthew;	state Exp;
branches;
next	1.108;

1.108
date	2010.09.22.05.44.27;	author matthew;	state Exp;
branches;
next	1.107;

1.107
date	2010.07.08.08.40.29;	author yasuoka;	state Exp;
branches;
next	1.106;

1.106
date	2010.05.06.13.06.40;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2010.01.13.07.23.38;	author yasuoka;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.12.11.28.09;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2010.01.12.04.06.55;	author yasuoka;	state Exp;
branches;
next	1.102;

1.102
date	2010.01.12.03.41.29;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2010.01.11.03.50.56;	author yasuoka;	state Exp;
branches;
next	1.100;

1.100
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.09.10.09.12;	author claudio;	state Exp;
branches;
next	1.98;

1.98
date	2009.08.02.19.50.16;	author mpf;	state Exp;
branches;
next	1.97;

1.97
date	2009.06.04.06.57.27;	author claudio;	state Exp;
branches;
next	1.96;

1.96
date	2009.02.20.12.47.57;	author jsing;	state Exp;
branches;
next	1.95;

1.95
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.94;

1.94
date	2008.08.04.18.55.08;	author damien;	state Exp;
branches;
next	1.93;

1.93
date	2008.05.07.05.51.12;	author mpf;	state Exp;
branches;
next	1.92;

1.92
date	2008.05.06.07.18.09;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2007.06.06.10.04.36;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.26.17.13.31;	author jason;	state Exp;
branches;
next	1.87;

1.87
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.03.21.03.46;	author mpf;	state Exp;
branches;
next	1.85;

1.85
date	2007.02.21.13.24.55;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2007.02.16.13.41.21;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2007.02.06.10.49.40;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.26.10.58.47;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2006.11.10.09.34.39;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2006.11.01.03.37.24;	author tedu;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.20.10.03.49;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.16.09.30.54;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2006.03.05.02.35.38;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2006.01.11.12.51.33;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.29.02.59.42;	author jolan;	state Exp;
branches;
next	1.72;

1.72
date	2005.11.25.13.45.02;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.21.18.16.45;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2005.11.17.11.08.52;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2005.11.16.10.45.33;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2005.06.08.06.53.32;	author henning;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2005.06.08.06.35.04;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.04.12.10.27;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2005.05.03.14.33.50;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2004.11.11.10.42.04;	author mpf;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.09.14.15.40;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.09.13.45.03;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2004.07.16.15.01.09;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2004.06.25.04.09.03;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.25.18.50.01;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.02.23.09.29;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.12.04.48.25;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.05.23.53.24;	author mpf;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.06.09.16.38;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.03.14.53.04;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.02.06.00.18;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.12.10.49.17;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.18.05.26.13;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.07.09.00.34;	author kjc;	state Exp;
branches;
next	1.44;

1.44
date	2002.12.06.15.58.49;	author nate;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.06.21.34.16;	author provos;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.10.06.10.53;	author jason;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2001.08.21.11.03.45;	author brian;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.03.21.13.40;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.02.22.30.41;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.27.06.07.46;	author kjc;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.15.03.38.34;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.16.12.53.34;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.23.13.55.27;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.05.04.00.36;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.06.03.32.02;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2000.12.05.07.22.59;	author hugh;	state Exp;
branches;
next	1.29;

1.29
date	2000.03.21.23.31.27;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	99.09.29.04.30.39;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.07.24.03.18.32;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	99.04.22.20.02.44;	author art;	state Exp;
branches;
next	1.24;

1.24
date	98.08.02.07.17.43;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	98.06.26.09.14.39;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.12.31.06.30.30;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.12.31.01.22.55;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.08.31.20.42.32;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.07.29.07.18.20;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.07.29.05.53.22;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.07.24.22.03.15;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.07.23.20.50.14;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.02.14.18.15.28;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.06.17.11.06.18;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.06.02.17.24.58;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.06.02.16.27.44;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.05.27.07.57.59;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.16.11.52.08;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.05.10.12.31.13;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.24.06.43.51;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.24.06.26.47;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.28.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.03.21.07.11;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.21.12.50.02;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.14.34.00;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.01.40.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches;
next	;

1.28.2.1
date	2000.03.24.09.09.33;	author niklas;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2001.05.14.22.40.02;	author niklas;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2001.07.04.10.54.11;	author niklas;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.28.2.5;

1.28.2.5
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.28.2.6;

1.28.2.6
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.28.2.7;

1.28.2.7
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.28.2.8;

1.28.2.8
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.28.2.9;

1.28.2.9
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.28.2.10;

1.28.2.10
date	2004.06.05.23.11.24;	author niklas;	state Exp;
branches;
next	;

1.40.2.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;

1.68.2.1
date	2006.07.14.01.18.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.173
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: if_tun.c,v 1.172 2017/01/22 10:17:39 dlg Exp $	*/
/*	$NetBSD: if_tun.c,v 1.24 1996/05/07 02:40:48 thorpej Exp $	*/

/*
 * Copyright (c) 1988, Julian Onions <Julian.Onions@@nexor.co.uk>
 * Nottingham University 1987.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This driver takes packets off the IP i/f and hands them up to a
 * user process to have its wicked way with. This driver has its
 * roots in a similar driver written by Phil Cockcroft (formerly) at
 * UCL. This driver is based much more on read/write/select mode of
 * operation though.
 */

/* #define	TUN_DEBUG	9 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/selinfo.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/vnode.h>
#include <sys/signalvar.h>
#include <sys/poll.h>
#include <sys/conf.h>


#include <net/if.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/rtable.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#ifdef PIPEX
#include <net/pipex.h>
#endif

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <net/if_tun.h>

struct tun_softc {
	struct arpcom	arpcom;		/* ethernet common data */
	struct selinfo	tun_rsel;	/* read select */
	struct selinfo	tun_wsel;	/* write select (not used) */
	LIST_ENTRY(tun_softc) entry;	/* all tunnel interfaces */
	int		tun_unit;
	uid_t		tun_siguid;	/* uid for process that set tun_pgid */
	uid_t		tun_sigeuid;	/* euid for process that set tun_pgid */
	pid_t		tun_pgid;	/* the process group - if any */
	u_short		tun_flags;	/* misc flags */
#define tun_if	arpcom.ac_if
#ifdef PIPEX
	struct pipex_iface_context pipex_iface; /* pipex context */
#endif
};

#ifdef	TUN_DEBUG
int	tundebug = TUN_DEBUG;
#define TUNDEBUG(a)	(tundebug? printf a : 0)
#else
#define TUNDEBUG(a)	/* (tundebug? printf a : 0) */
#endif

/* Only these IFF flags are changeable by TUNSIFINFO */
#define TUN_IFF_FLAGS (IFF_UP|IFF_POINTOPOINT|IFF_MULTICAST|IFF_BROADCAST)

void	tunattach(int);

/* cdev functions */
int	tunopen(dev_t, int, int, struct proc *);
int	tunclose(dev_t, int, int, struct proc *);
int	tunioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	tunread(dev_t, struct uio *, int);
int	tunwrite(dev_t, struct uio *, int);
int	tunpoll(dev_t, int, struct proc *);
int	tunkqfilter(dev_t, struct knote *);

int	tapopen(dev_t, int, int, struct proc *);
int	tapclose(dev_t, int, int, struct proc *);
int	tapioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	tapread(dev_t, struct uio *, int);
int	tapwrite(dev_t, struct uio *, int);
int	tappoll(dev_t, int, struct proc *);
int	tapkqfilter(dev_t, struct knote *);

int	tun_dev_open(struct tun_softc *, int, int, struct proc *);
int	tun_dev_close(struct tun_softc *, int, int, struct proc *);
int	tun_dev_ioctl(struct tun_softc *, u_long, caddr_t, int, struct proc *);
int	tun_dev_read(struct tun_softc *, struct uio *, int);
int	tun_dev_write(struct tun_softc *, struct uio *, int);
int	tun_dev_poll(struct tun_softc *, int, struct proc *);
int	tun_dev_kqfilter(struct tun_softc *, struct knote *);


int	tun_ioctl(struct ifnet *, u_long, caddr_t);
int	tun_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);
int	tun_clone_create(struct if_clone *, int);
int	tap_clone_create(struct if_clone *, int);
int	tun_create(struct if_clone *, int, int);
int	tun_clone_destroy(struct ifnet *);
static inline struct	tun_softc *tun_lookup(int);
static inline struct	tun_softc *tap_lookup(int);
void	tun_wakeup(struct tun_softc *);
int	tun_init(struct tun_softc *);
void	tun_start(struct ifnet *);
int	filt_tunread(struct knote *, long);
int	filt_tunwrite(struct knote *, long);
void	filt_tunrdetach(struct knote *);
void	filt_tunwdetach(struct knote *);
void	tun_link_state(struct tun_softc *);

struct filterops tunread_filtops =
	{ 1, NULL, filt_tunrdetach, filt_tunread};

struct filterops tunwrite_filtops =
	{ 1, NULL, filt_tunwdetach, filt_tunwrite};

LIST_HEAD(, tun_softc) tun_softc_list;
LIST_HEAD(, tun_softc) tap_softc_list;

struct if_clone tun_cloner =
    IF_CLONE_INITIALIZER("tun", tun_clone_create, tun_clone_destroy);

struct if_clone tap_cloner =
    IF_CLONE_INITIALIZER("tap", tap_clone_create, tun_clone_destroy);

void
tunattach(int n)
{
	LIST_INIT(&tun_softc_list);
	LIST_INIT(&tap_softc_list);
	if_clone_attach(&tun_cloner);
	if_clone_attach(&tap_cloner);
#ifdef PIPEX
	pipex_init();
#endif
}

int
tun_clone_create(struct if_clone *ifc, int unit)
{
	return (tun_create(ifc, unit, 0));
}

int
tap_clone_create(struct if_clone *ifc, int unit)
{
	return (tun_create(ifc, unit, TUN_LAYER2));
}

int
tun_create(struct if_clone *ifc, int unit, int flags)
{
	struct tun_softc	*tp;
	struct ifnet		*ifp;
	int			 s;

	tp = malloc(sizeof(*tp), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (tp == NULL)
		return (ENOMEM);

	tp->tun_unit = unit;
	tp->tun_flags = TUN_INITED|TUN_STAYUP;

	ifp = &tp->tun_if;
	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d", ifc->ifc_name,
	    unit);
	ifp->if_softc = tp;

	ifp->if_ioctl = tun_ioctl;
	ifp->if_output = tun_output;
	ifp->if_start = tun_start;
	ifp->if_hardmtu = TUNMRU;
	ifp->if_link_state = LINK_STATE_DOWN;
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	if ((flags & TUN_LAYER2) == 0) {
		tp->tun_flags &= ~TUN_LAYER2;
		ifp->if_mtu = ETHERMTU;
		ifp->if_flags = (IFF_POINTOPOINT|IFF_MULTICAST);
		ifp->if_type = IFT_TUNNEL;
		ifp->if_hdrlen = sizeof(u_int32_t);
		ifp->if_rtrequest = p2p_rtrequest;

		if_attach(ifp);
		if_alloc_sadl(ifp);
#if NBPFILTER > 0
		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
#endif
		s = splnet();
		LIST_INSERT_HEAD(&tun_softc_list, tp, entry);
		splx(s);
	} else {
		tp->tun_flags |= TUN_LAYER2;
		ether_fakeaddr(ifp);
		ifp->if_flags =
		    (IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST);
		ifp->if_capabilities = IFCAP_VLAN_MTU;

		if_attach(ifp);
		ether_ifattach(ifp);

		s = splnet();
		LIST_INSERT_HEAD(&tap_softc_list, tp, entry);
		splx(s);
	}

#ifdef PIPEX
	if ((tp->tun_flags & TUN_LAYER2) == 0)
		pipex_iface_init(&tp->pipex_iface, ifp);
#endif

	return (0);
}

int
tun_clone_destroy(struct ifnet *ifp)
{
	struct tun_softc	*tp = ifp->if_softc;
	int			 s;

#ifdef PIPEX
	if ((tp->tun_flags & TUN_LAYER2) == 0)
		pipex_iface_fini(&tp->pipex_iface);
#endif
	tun_wakeup(tp);

	s = splhigh();
	klist_invalidate(&tp->tun_rsel.si_note);
	klist_invalidate(&tp->tun_wsel.si_note);
	splx(s);

	s = splnet();
	LIST_REMOVE(tp, entry);
	splx(s);

	if (tp->tun_flags & TUN_LAYER2)
		ether_ifdetach(ifp);

	if_detach(ifp);

	free(tp, M_DEVBUF, 0);
	return (0);
}

static inline struct tun_softc *
tun_lookup(int unit)
{
	struct tun_softc *tp;

	LIST_FOREACH(tp, &tun_softc_list, entry)
		if (tp->tun_unit == unit)
			return (tp);
	return (NULL);
}

static inline struct tun_softc *
tap_lookup(int unit)
{
	struct tun_softc *tp;

	LIST_FOREACH(tp, &tap_softc_list, entry)
		if (tp->tun_unit == unit)
			return (tp);
	return (NULL);
}

/*
 * tunnel open - must be superuser & the device must be
 * configured in
 */
int
tunopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tun_softc *tp;
	unsigned int rdomain = rtable_l2(p->p_p->ps_rtableid);

	if ((tp = tun_lookup(minor(dev))) == NULL) {	/* create on demand */
		char	xname[IFNAMSIZ];
		int	s, error;

		snprintf(xname, sizeof(xname), "%s%d", "tun", minor(dev));
		NET_LOCK(s);
		error = if_clone_create(xname, rdomain);
		NET_UNLOCK(s);
		if (error != 0)
			return (error);

		if ((tp = tun_lookup(minor(dev))) == NULL)
			return (ENXIO);
		tp->tun_flags &= ~TUN_STAYUP;
	}

	return (tun_dev_open(tp, flag, mode, p));
}

int
tapopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tun_softc *tp;
	unsigned int rdomain = rtable_l2(p->p_p->ps_rtableid);

	if ((tp = tap_lookup(minor(dev))) == NULL) {	/* create on demand */
		char	xname[IFNAMSIZ];
		int	s, error;

		snprintf(xname, sizeof(xname), "%s%d", "tap", minor(dev));
		NET_LOCK(s);
		error = if_clone_create(xname, rdomain);
		NET_UNLOCK(s);
		if (error != 0)
			return (error);

		if ((tp = tap_lookup(minor(dev))) == NULL)
			return (ENXIO);
		tp->tun_flags &= ~TUN_STAYUP;
	}

	return (tun_dev_open(tp, flag, mode, p));
}

int
tun_dev_open(struct tun_softc *tp, int flag, int mode, struct proc *p)
{
	struct ifnet *ifp;
	int s;

	if (tp->tun_flags & TUN_OPEN)
		return (EBUSY);

	ifp = &tp->tun_if;
	tp->tun_flags |= TUN_OPEN;
	if (flag & FNONBLOCK)
		tp->tun_flags |= TUN_NBIO;

	/* automatically mark the interface running on open */
	s = splnet();
	ifp->if_flags |= IFF_RUNNING;
	tun_link_state(tp);
	splx(s);

	TUNDEBUG(("%s: open\n", ifp->if_xname));
	return (0);
}

/*
 * tunclose - close the device; if closing the real device, flush pending
 *  output and unless STAYUP bring down and destroy the interface.
 */
int
tunclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tun_softc	*tp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_close(tp, flag, mode, p));
}

int
tapclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tun_softc	*tp;

	if ((tp = tap_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_close(tp, flag, mode, p));
}

int
tun_dev_close(struct tun_softc *tp, int flag, int mode, struct proc *p)
{
	int			 s, error = 0;
	struct ifnet		*ifp;

	ifp = &tp->tun_if;
	tp->tun_flags &= ~(TUN_OPEN|TUN_NBIO|TUN_ASYNC);

	/*
	 * junk all pending output
	 */
	s = splnet();
	ifp->if_flags &= ~IFF_RUNNING;
	tun_link_state(tp);
	IFQ_PURGE(&ifp->if_snd);
	splx(s);

	TUNDEBUG(("%s: closed\n", ifp->if_xname));

	if (!(tp->tun_flags & TUN_STAYUP)) {
		NET_LOCK(s);
		error = if_clone_destroy(ifp->if_xname);
		NET_UNLOCK(s);
	} else {
		tp->tun_pgid = 0;
		selwakeup(&tp->tun_rsel);
	}

	return (error);
}

int
tun_init(struct tun_softc *tp)
{
	struct ifnet	*ifp = &tp->tun_if;
	struct ifaddr	*ifa;

	TUNDEBUG(("%s: tun_init\n", ifp->if_xname));

	ifp->if_flags |= IFF_UP | IFF_RUNNING;

	tp->tun_flags &= ~(TUN_IASET|TUN_DSTADDR|TUN_BRDADDR);
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET) {
			struct sockaddr_in *sin;

			sin = satosin(ifa->ifa_addr);
			if (sin && sin->sin_addr.s_addr)
				tp->tun_flags |= TUN_IASET;

			if (ifp->if_flags & IFF_POINTOPOINT) {
				sin = satosin(ifa->ifa_dstaddr);
				if (sin && sin->sin_addr.s_addr)
					tp->tun_flags |= TUN_DSTADDR;
			} else
				tp->tun_flags &= ~TUN_DSTADDR;

			if (ifp->if_flags & IFF_BROADCAST) {
				sin = satosin(ifa->ifa_broadaddr);
				if (sin && sin->sin_addr.s_addr)
					tp->tun_flags |= TUN_BRDADDR;
			} else
				tp->tun_flags &= ~TUN_BRDADDR;
		}
#ifdef INET6
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			struct sockaddr_in6 *sin6;

			sin6 = satosin6(ifa->ifa_addr);
			if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr))
				tp->tun_flags |= TUN_IASET;

			if (ifp->if_flags & IFF_POINTOPOINT) {
				sin6 = satosin6(ifa->ifa_dstaddr);
				if (sin6 &&
				    !IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr))
					tp->tun_flags |= TUN_DSTADDR;
			} else
				tp->tun_flags &= ~TUN_DSTADDR;
		}
#endif /* INET6 */
	}

	return (0);
}

/*
 * Process an ioctl request.
 */
int
tun_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct tun_softc	*tp = (struct tun_softc *)(ifp->if_softc);
	struct ifreq		*ifr = (struct ifreq *)data;
	int			 error = 0, s;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		tun_init(tp);
		break;
	case SIOCSIFDSTADDR:
		tun_init(tp);
		TUNDEBUG(("%s: destination address set\n", ifp->if_xname));
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > TUNMRU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;
	case SIOCSIFFLAGS:
		break;
	default:
		if (tp->tun_flags & TUN_LAYER2)
			error = ether_ioctl(ifp, &tp->arpcom, cmd, data);
		else
			error = ENOTTY;
	}

	splx(s);
	return (error);
}

/*
 * tun_output - queue packets from higher level ready to put out.
 */
int
tun_output(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst,
    struct rtentry *rt)
{
	struct tun_softc	*tp = ifp->if_softc;
	int			 s, error;
	u_int32_t		*af;

	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) {
		m_freem(m0);
		return (EHOSTDOWN);
	}

	TUNDEBUG(("%s: tun_output\n", ifp->if_xname));

	if ((tp->tun_flags & TUN_READY) != TUN_READY) {
		TUNDEBUG(("%s: not ready %#x\n", ifp->if_xname,
		     tp->tun_flags));
		m_freem(m0);
		return (EHOSTDOWN);
	}

	if (tp->tun_flags & TUN_LAYER2)
		return (ether_output(ifp, m0, dst, rt));

	M_PREPEND(m0, sizeof(*af), M_DONTWAIT);
	if (m0 == NULL)
		return (ENOBUFS);
	af = mtod(m0, u_int32_t *);
	*af = htonl(dst->sa_family);

	s = splnet();

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
#ifdef PIPEX
	if (pipex_enable && (m0 = pipex_output(m0, dst->sa_family,
	    sizeof(u_int32_t), &tp->pipex_iface)) == NULL) {
		splx(s);
		return (0);
	}
#endif

	error = if_enqueue(ifp, m0);
	splx(s);

	if (error) {
		ifp->if_collisions++;
		return (error);
	}

	tun_wakeup(tp);
	return (0);
}

void
tun_wakeup(struct tun_softc *tp)
{
	if (tp->tun_flags & TUN_RWAIT) {
		tp->tun_flags &= ~TUN_RWAIT;
		wakeup((caddr_t)tp);
	}
	if (tp->tun_flags & TUN_ASYNC && tp->tun_pgid)
		csignal(tp->tun_pgid, SIGIO,
		    tp->tun_siguid, tp->tun_sigeuid);
	selwakeup(&tp->tun_rsel);
}

/*
 * the cdevsw interface is now pretty minimal.
 */
int
tunioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct tun_softc *tp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_ioctl(tp, cmd, data, flag, p));
}

int
tapioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct tun_softc *tp;

	if ((tp = tap_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_ioctl(tp, cmd, data, flag, p));
}

int
tun_dev_ioctl(struct tun_softc *tp, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	int			 s;
	struct tuninfo		*tunp;
	struct mbuf		*m;

	s = splnet();
	switch (cmd) {
	case TUNSIFINFO:
		tunp = (struct tuninfo *)data;
		if (tunp->mtu < ETHERMIN || tunp->mtu > TUNMRU) {
			splx(s);
			return (EINVAL);
		}
		tp->tun_if.if_mtu = tunp->mtu;
		tp->tun_if.if_type = tunp->type;
		tp->tun_if.if_flags =
		    (tunp->flags & TUN_IFF_FLAGS) |
		    (tp->tun_if.if_flags & ~TUN_IFF_FLAGS);
		tp->tun_if.if_baudrate = tunp->baudrate;
		break;
	case TUNGIFINFO:
		tunp = (struct tuninfo *)data;
		tunp->mtu = tp->tun_if.if_mtu;
		tunp->type = tp->tun_if.if_type;
		tunp->flags = tp->tun_if.if_flags;
		tunp->baudrate = tp->tun_if.if_baudrate;
		break;
#ifdef TUN_DEBUG
	case TUNSDEBUG:
		tundebug = *(int *)data;
		break;
	case TUNGDEBUG:
		*(int *)data = tundebug;
		break;
#endif
	case TUNSIFMODE:
		switch (*(int *)data & (IFF_POINTOPOINT|IFF_BROADCAST)) {
		case IFF_POINTOPOINT:
		case IFF_BROADCAST:
			tp->tun_if.if_flags &= ~TUN_IFF_FLAGS;
			tp->tun_if.if_flags |= *(int *)data & TUN_IFF_FLAGS;
			break;
		default:
			splx(s);
			return (EINVAL);
		}
		break;

	case FIONBIO:
		if (*(int *)data)
			tp->tun_flags |= TUN_NBIO;
		else
			tp->tun_flags &= ~TUN_NBIO;
		break;
	case FIOASYNC:
		if (*(int *)data)
			tp->tun_flags |= TUN_ASYNC;
		else
			tp->tun_flags &= ~TUN_ASYNC;
		break;
	case FIONREAD:
		m = ifq_deq_begin(&tp->tun_if.if_snd);
		if (m != NULL) {
			*(int *)data = m->m_pkthdr.len;
			ifq_deq_rollback(&tp->tun_if.if_snd, m);
		} else
			*(int *)data = 0;
		break;
	case TIOCSPGRP:
		tp->tun_pgid = *(int *)data;
		tp->tun_siguid = p->p_ucred->cr_ruid;
		tp->tun_sigeuid = p->p_ucred->cr_uid;
		break;
	case TIOCGPGRP:
		*(int *)data = tp->tun_pgid;
		break;
	case SIOCGIFADDR:
		if (!(tp->tun_flags & TUN_LAYER2)) {
			splx(s);
			return (EINVAL);
		}
		bcopy(tp->arpcom.ac_enaddr, data,
		    sizeof(tp->arpcom.ac_enaddr));
		break;

	case SIOCSIFADDR:
		if (!(tp->tun_flags & TUN_LAYER2)) {
			splx(s);
			return (EINVAL);
		}
		bcopy(data, tp->arpcom.ac_enaddr,
		    sizeof(tp->arpcom.ac_enaddr));
		break;
	default:
#ifdef PIPEX
		if (!(tp->tun_flags & TUN_LAYER2)) {
			int ret;
			ret = pipex_ioctl(&tp->pipex_iface, cmd, data);
			splx(s);
			return (ret);
		}
#endif
		splx(s);
		return (ENOTTY);
	}
	splx(s);
	return (0);
}

/*
 * The cdevsw read interface - reads a packet at a time, or at
 * least as much of a packet as can be read.
 */
int
tunread(dev_t dev, struct uio *uio, int ioflag)
{
	struct tun_softc *tp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_read(tp, uio, ioflag));
}

int
tapread(dev_t dev, struct uio *uio, int ioflag)
{
	struct tun_softc *tp;

	if ((tp = tap_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_read(tp, uio, ioflag));
}

int
tun_dev_read(struct tun_softc *tp, struct uio *uio, int ioflag)
{
	struct ifnet		*ifp = &tp->tun_if;
	struct mbuf		*m, *m0;
	unsigned int		 ifidx;
	int			 error = 0, s;
	size_t			 len;

	if ((tp->tun_flags & TUN_READY) != TUN_READY)
		return (EHOSTDOWN);

	ifidx = ifp->if_index;
	tp->tun_flags &= ~TUN_RWAIT;

	s = splnet();
	do {
		struct ifnet *ifp1;
		int destroyed;

		while ((tp->tun_flags & TUN_READY) != TUN_READY) {
			if ((error = tsleep((caddr_t)tp,
			    (PZERO + 1)|PCATCH, "tunread", 0)) != 0) {
				splx(s);
				return (error);
			}
			/* Make sure the interface still exists. */
			ifp1 = if_get(ifidx);
			destroyed = (ifp1 == NULL);
			if_put(ifp1);
			if (destroyed) {
				splx(s);
				return (ENXIO);
			}
		}
		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL) {
			if (tp->tun_flags & TUN_NBIO && ioflag & IO_NDELAY) {
				splx(s);
				return (EWOULDBLOCK);
			}
			tp->tun_flags |= TUN_RWAIT;
			if ((error = tsleep((caddr_t)tp,
			    (PZERO + 1)|PCATCH, "tunread", 0)) != 0) {
				splx(s);
				return (error);
			}
			/* Make sure the interface still exists. */
			ifp1 = if_get(ifidx);
			destroyed = (ifp1 == NULL);
			if_put(ifp1);
			if (destroyed) {
				splx(s);
				return (ENXIO);
			}
		}
	} while (m0 == NULL);
	splx(s);

	if (tp->tun_flags & TUN_LAYER2) {
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
	}

	while (m0 != NULL && uio->uio_resid > 0 && error == 0) {
		len = ulmin(uio->uio_resid, m0->m_len);
		if (len != 0)
			error = uiomove(mtod(m0, caddr_t), len, uio);
		m = m_free(m0);
		m0 = m;
	}

	if (m0 != NULL) {
		TUNDEBUG(("Dropping mbuf\n"));
		m_freem(m0);
	}
	if (error)
		ifp->if_oerrors++;

	return (error);
}

/*
 * the cdevsw write interface - an atomic write is a packet - or else!
 */
int
tunwrite(dev_t dev, struct uio *uio, int ioflag)
{
	struct tun_softc *tp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_write(tp, uio, ioflag));
}

int
tapwrite(dev_t dev, struct uio *uio, int ioflag)
{
	struct tun_softc *tp;

	if ((tp = tap_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_write(tp, uio, ioflag));
}

int
tun_dev_write(struct tun_softc *tp, struct uio *uio, int ioflag)
{
	struct ifnet		*ifp;
	struct niqueue		*ifq;
	u_int32_t		*th;
	struct mbuf		*top, **mp, *m;
	int			error = 0, tlen;
	size_t			mlen;
#if NBPFILTER > 0
	int			 s;
#endif
	ifp = &tp->tun_if;
	TUNDEBUG(("%s: tunwrite\n", ifp->if_xname));

	if (uio->uio_resid == 0 || uio->uio_resid > ifp->if_mtu +
	    (tp->tun_flags & TUN_LAYER2 ? ETHER_HDR_LEN : sizeof(*th))) {
		TUNDEBUG(("%s: len=%d!\n", ifp->if_xname, uio->uio_resid));
		return (EMSGSIZE);
	}
	tlen = uio->uio_resid;

	/* get a header mbuf */
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);
	mlen = MHLEN;
	if (uio->uio_resid >= MINCLSIZE) {
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_free(m);
			return (ENOBUFS);
		}
		mlen = MCLBYTES;
	}

	top = NULL;
	mp = &top;
	if (tp->tun_flags & TUN_LAYER2) {
		/*
		 * Pad so that IP header is correctly aligned
		 * this is necessary for all strict aligned architectures.
		 */
		mlen -= ETHER_ALIGN;
		m->m_data += ETHER_ALIGN;
	}
	while (error == 0 && uio->uio_resid > 0) {
		m->m_len = ulmin(mlen, uio->uio_resid);
		error = uiomove(mtod (m, caddr_t), m->m_len, uio);
		*mp = m;
		mp = &m->m_next;
		if (error == 0 && uio->uio_resid > 0) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				error = ENOBUFS;
				break;
			}
			mlen = MLEN;
			if (uio->uio_resid >= MINCLSIZE) {
				MCLGET(m, M_DONTWAIT);
				if (!(m->m_flags & M_EXT)) {
					error = ENOBUFS;
					m_free(m);
					break;
				}
				mlen = MCLBYTES;
			}
		}
	}
	if (error) {
		m_freem(top);
		ifp->if_ierrors++;
		return (error);
	}

	top->m_pkthdr.len = tlen;

	if (tp->tun_flags & TUN_LAYER2) {
		struct mbuf_list ml = MBUF_LIST_INITIALIZER();

		ml_enqueue(&ml, top);
		if_input(ifp, &ml);
		return (0);
	}

#if NBPFILTER > 0
	if (ifp->if_bpf) {
		s = splnet();
		bpf_mtap(ifp->if_bpf, top, BPF_DIRECTION_IN);
		splx(s);
	}
#endif

	th = mtod(top, u_int32_t *);
	/* strip the tunnel header */
	top->m_data += sizeof(*th);
	top->m_len  -= sizeof(*th);
	top->m_pkthdr.len -= sizeof(*th);
	top->m_pkthdr.ph_rtableid = ifp->if_rdomain;
	top->m_pkthdr.ph_ifidx = ifp->if_index;

	switch (ntohl(*th)) {
	case AF_INET:
		ifq = &ipintrq;
		break;
#ifdef INET6
	case AF_INET6:
		ifq = &ip6intrq;
		break;
#endif
	default:
		m_freem(top);
		return (EAFNOSUPPORT);
	}

	if (niq_enqueue(ifq, top) != 0) {
		ifp->if_collisions++;
		return (ENOBUFS);
	}

	ifp->if_ipackets++;
	ifp->if_ibytes += top->m_pkthdr.len;

	return (error);
}

/*
 * tunpoll - the poll interface, this is only useful on reads
 * really. The write detect always returns true, write never blocks
 * anyway, it either accepts the packet or drops it.
 */
int
tunpoll(dev_t dev, int events, struct proc *p)
{
	struct tun_softc *tp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (POLLERR);
	return (tun_dev_poll(tp, events, p));
}

int
tappoll(dev_t dev, int events, struct proc *p)
{
	struct tun_softc *tp;

	if ((tp = tap_lookup(minor(dev))) == NULL)
		return (POLLERR);
	return (tun_dev_poll(tp, events, p));
}

int
tun_dev_poll(struct tun_softc *tp, int events, struct proc *p)
{
	int			 revents, s;
	struct ifnet		*ifp;
	unsigned int		 len;

	ifp = &tp->tun_if;
	revents = 0;
	s = splnet();
	TUNDEBUG(("%s: tunpoll\n", ifp->if_xname));

	if (events & (POLLIN | POLLRDNORM)) {
		len = IFQ_LEN(&ifp->if_snd);
		if (len > 0) {
			TUNDEBUG(("%s: tunselect q=%d\n", ifp->if_xname, len));
			revents |= events & (POLLIN | POLLRDNORM);
		} else {
			TUNDEBUG(("%s: tunpoll waiting\n", ifp->if_xname));
			selrecord(p, &tp->tun_rsel);
		}
	}
	if (events & (POLLOUT | POLLWRNORM))
		revents |= events & (POLLOUT | POLLWRNORM);
	splx(s);
	return (revents);
}

/*
 * kqueue(2) support.
 *
 * The tun driver uses an array of tun_softc's based on the minor number
 * of the device.  kn->kn_hook gets set to the specific tun_softc.
 *
 * filt_tunread() sets kn->kn_data to the iface qsize
 * filt_tunwrite() sets kn->kn_data to the MTU size
 */
int
tunkqfilter(dev_t dev, struct knote *kn)
{
	struct tun_softc *tp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_kqfilter(tp, kn));
}

int
tapkqfilter(dev_t dev, struct knote *kn)
{
	struct tun_softc *tp;

	if ((tp = tap_lookup(minor(dev))) == NULL)
		return (ENXIO);
	return (tun_dev_kqfilter(tp, kn));
}

int
tun_dev_kqfilter(struct tun_softc *tp, struct knote *kn)
{
	int			 s;
	struct klist		*klist;
	struct ifnet		*ifp;

	ifp = &tp->tun_if;
	TUNDEBUG(("%s: tunkqfilter\n", ifp->if_xname));

	switch (kn->kn_filter) {
		case EVFILT_READ:
			klist = &tp->tun_rsel.si_note;
			kn->kn_fop = &tunread_filtops;
			break;
		case EVFILT_WRITE:
			klist = &tp->tun_wsel.si_note;
			kn->kn_fop = &tunwrite_filtops;
			break;
		default:
			return (EINVAL);
	}

	kn->kn_hook = (caddr_t)tp;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_tunrdetach(struct knote *kn)
{
	int			 s;
	struct tun_softc	*tp;

	tp = (struct tun_softc *)kn->kn_hook;
	s = splhigh();
	if (!(kn->kn_status & KN_DETACHED))
		SLIST_REMOVE(&tp->tun_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_tunread(struct knote *kn, long hint)
{
	int			 s;
	struct tun_softc	*tp;
	struct ifnet		*ifp;
	unsigned int		 len;

	if (kn->kn_status & KN_DETACHED) {
		kn->kn_data = 0;
		return (1);
	}

	tp = (struct tun_softc *)kn->kn_hook;
	ifp = &tp->tun_if;

	s = splnet();
	len = IFQ_LEN(&ifp->if_snd);
	if (len > 0) {
		splx(s);
		kn->kn_data = len;

		TUNDEBUG(("%s: tunkqread q=%d\n", ifp->if_xname,
		    IFQ_LEN(&ifp->if_snd)));
		return (1);
	}
	splx(s);
	TUNDEBUG(("%s: tunkqread waiting\n", ifp->if_xname));
	return (0);
}

void
filt_tunwdetach(struct knote *kn)
{
	int			 s;
	struct tun_softc	*tp;

	tp = (struct tun_softc *)kn->kn_hook;
	s = splhigh();
	if (!(kn->kn_status & KN_DETACHED))
		SLIST_REMOVE(&tp->tun_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_tunwrite(struct knote *kn, long hint)
{
	struct tun_softc	*tp;
	struct ifnet		*ifp;

	if (kn->kn_status & KN_DETACHED) {
		kn->kn_data = 0;
		return (1);
	}

	tp = (struct tun_softc *)kn->kn_hook;
	ifp = &tp->tun_if;

	kn->kn_data = ifp->if_mtu;

	return (1);
}

void
tun_start(struct ifnet *ifp)
{
	struct tun_softc	*tp = ifp->if_softc;

	splassert(IPL_NET);

	if (IFQ_LEN(&ifp->if_snd))
		tun_wakeup(tp);
}

void
tun_link_state(struct tun_softc *tp)
{
	struct ifnet *ifp = &tp->tun_if;
	int link_state = LINK_STATE_DOWN;

	if (tp->tun_flags & TUN_OPEN) {
		if (tp->tun_flags & TUN_LAYER2)
			link_state = LINK_STATE_FULL_DUPLEX;
		else
			link_state = LINK_STATE_UP;
	}
	if (ifp->if_link_state != link_state) {
		ifp->if_link_state = link_state;
		if_link_state_change(ifp);
	}
}
@


1.172
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.171 2016/12/21 13:13:01 mikeb Exp $	*/
d652 1
a652 1
		tp->tun_if.if_flags = 
d732 1
a732 1
	    	if (!(tp->tun_flags & TUN_LAYER2)) {
@


1.171
log
@Grab the netlock when opened and closed;  ok mpi, rzalamena
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.170 2016/12/12 09:51:30 mpi Exp $	*/
a592 1
	ifp->if_opackets++;
a833 1
		ifp->if_opackets++;
@


1.170
log
@Remove most of the splsoftnet() recursions related to cloned interfaces.

inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.169 2016/09/04 15:46:39 reyk Exp $	*/
d322 1
a322 1
		s = splsoftnet();
d324 1
a324 1
		splx(s);
d347 1
a347 1
		s = splsoftnet();
d349 1
a349 1
		splx(s);
d430 1
a430 1
		s = splsoftnet();
d432 1
a432 1
		splx(s);
@


1.169
log
@When auto-creating an interface when opening a /dev/{tun,tap,switch}
device, inherit the rdomain from the calling process.  This adds an
rdomain argument to if_clone_create().

OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.168 2016/04/13 11:41:15 mpi Exp $	*/
d315 1
a315 1
	int error;
d319 1
d322 4
a325 2
		if ((error = if_clone_create(xname,
		    rtable_l2(p->p_p->ps_rtableid))) != 0)
d340 1
a340 1
	int error;
d344 1
d347 4
a350 2
		if ((error = if_clone_create(xname,
		    rtable_l2(p->p_p->ps_rtableid))) != 0)
d412 1
a412 1
	int			 s;
d429 5
a433 3
	if (!(tp->tun_flags & TUN_STAYUP))
		return (if_clone_destroy(ifp->if_xname));
	else {
d438 1
a438 1
	return (0);
@


1.168
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.167 2016/03/01 21:47:52 stsp Exp $	*/
d63 1
d321 2
a322 1
		if ((error = if_clone_create(xname)) != 0)
d343 2
a344 1
		if ((error = if_clone_create(xname)) != 0)
@


1.167
log
@Set IFF_MULTICAST flag on tun(4) interfaces so IPv6 addresses can be assigned.
ok millert@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.166 2016/01/31 13:54:13 stefan Exp $	*/
a213 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.166
log
@Convert to ulmin and uiomove to prevent integer truncations.
Reviewed by Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.165 2016/01/07 05:31:17 guenther Exp $	*/
d219 1
a219 1
		ifp->if_flags = IFF_POINTOPOINT;
@


1.165
log
@Make open(O_NONBLOCK) of tun, tap, and bpf behave like open+ioctl(FIONBIO)

problem noted by yasuoka@@
ok yasuoka@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.164 2015/12/05 16:09:09 yasuoka Exp $	*/
d767 2
a768 1
	int			 error = 0, len, s;
d829 1
a829 1
		len = min(uio->uio_resid, m0->m_len);
d831 1
a831 1
			error = uiomovei(mtod(m0, caddr_t), len, uio);
d876 2
a877 1
	int			 error=0, tlen, mlen;
d916 2
a917 2
		m->m_len = min(mlen, uio->uio_resid);
		error = uiomovei(mtod (m, caddr_t), m->m_len, uio);
@


1.164
log
@Make pppx pass packets with npppd through the device.  This makes pppx work
without pipex.enable=1.  Also fix tun(4) not to pass the packets to pipex
when pipex.enable=0.

"go for it" dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.163 2015/11/20 12:20:30 mpi Exp $	*/
d364 2
@


1.163
log
@Prefer if_get() over if_ref() when checking if the interface has been
destroyed during our sleep.

No objection from the slackers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.162 2015/11/20 05:38:10 dlg Exp $	*/
d567 2
a568 2
	if ((m0 = pipex_output(m0, dst->sa_family, sizeof(u_int32_t),
	    &tp->pipex_iface)) == NULL) {
@


1.162
log
@dont needlessly clear IFF_OACTIVE.

only a driver sets or clears OACTIVE. clearing it without setting it is
a waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.161 2015/11/20 05:15:33 dlg Exp $	*/
d762 1
a762 1
	struct ifnet		*ifp;
d764 1
a765 1
	unsigned int		ifindex;
d767 1
a767 6
	ifp = if_ref(&tp->tun_if);
	ifindex = ifp->if_index;
	TUNDEBUG(("%s: read\n", ifp->if_xname));
	if ((tp->tun_flags & TUN_READY) != TUN_READY) {
		TUNDEBUG(("%s: not ready %#x\n", ifp->if_xname, tp->tun_flags));
		if_put(ifp);
a768 1
	}
d770 1
d775 3
a778 1
			if_put(ifp);
d784 5
a788 1
			if ((ifp = if_get(ifindex)) == NULL) {
a794 1
			if_put(ifp);
d805 5
a809 1
			if ((ifp = if_get(ifindex)) == NULL) {
a839 1
	if_put(ifp);
a1080 2

	s = splnet();
a1081 1
	splx(s);
@


1.161
log
@if we deq m0, we should probably send it to bpf, not m.

found by and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.160 2015/11/20 03:35:23 dlg Exp $	*/
a437 1
	ifp->if_flags &= ~IFF_OACTIVE; /* we are never active */
@


1.160
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.159 2015/10/25 12:05:40 mpi Exp $	*/
d817 1
a817 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
@


1.159
log
@arp_ifinit() is no longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.158 2015/10/25 11:58:11 mpi Exp $	*/
d688 2
a689 2
		IFQ_POLL(&tp->tun_if.if_snd, m);
		if (m != NULL)
d691 2
a692 1
		else
d814 8
d1019 1
a1019 1
	struct mbuf		*m;
d1027 3
a1029 4
		IFQ_POLL(&ifp->if_snd, m);
		if (m != NULL) {
			TUNDEBUG(("%s: tunselect q=%d\n", ifp->if_xname,
			    IFQ_LEN(ifp->if_snd)));
d1125 1
a1125 1
	struct mbuf		*m;
d1136 2
a1137 2
	IFQ_POLL(&ifp->if_snd, m);
	if (m != NULL) {
d1139 1
a1139 1
		kn->kn_data = IFQ_LEN(&ifp->if_snd);
a1185 1
	struct mbuf		*m;
d1189 1
a1189 9
	IFQ_POLL(&ifp->if_snd, m);
	if (m != NULL) {
		if (tp->tun_flags & TUN_LAYER2) {
#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
			ifp->if_opackets++;
		}
a1190 1
	}
@


1.158
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.157 2015/10/24 04:12:24 dlg Exp $	*/
a492 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a499 10
		TUNDEBUG(("%s: address set\n", ifp->if_xname));
		if (tp->tun_flags & TUN_LAYER2) {
			switch (ifa->ifa_addr->sa_family) {
			case AF_INET:
				arp_ifinit(&tp->arpcom, ifa);
				break;
			default:
				break;
			}
		}
@


1.157
log
@lookup tap devices in tapkqfilter, not tun devices.

libevent likes this more.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.155 2015/09/10 17:41:15 dlg Exp $	*/
d222 1
a509 2
		} else {
			ifa->ifa_rtrequest = p2p_rtrequest;
@


1.156
log
@Split up tun(4) into tun(4) & tap(4). Killing the link0 magic to switch
between modes. The two drivers still share most of the code but the mode
switcher is gone.
OK dlg@@ mpi@@
@
text
@d1070 1
a1070 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
@


1.155
log
@dont leak an ifp reference if tun isnt ready to read.

found by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.154 2015/09/09 20:18:03 dlg Exp $	*/
d82 1
a82 1
	LIST_ENTRY(tun_softc) tun_list;	/* all tunnel interfaces */
d105 2
a108 3
int	tun_ioctl(struct ifnet *, u_long, caddr_t);
int	tun_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);
d114 21
d136 1
d139 2
a140 1
struct	tun_softc *tun_lookup(int);
d142 2
a143 5
int	tun_switch(struct tun_softc *, int);

void	tun_ifattach(struct ifnet *, int);
void	tun_ifdetach(struct ifnet *);
int	tuninit(struct tun_softc *);
a147 1
void	tunstart(struct ifnet *);
d157 1
d162 3
d169 1
d171 1
d183 8
a190 2
void
tun_ifattach(struct ifnet *ifp, int flags)
d192 2
a193 1
	struct tun_softc	*tp = ifp->if_softc;
d196 12
d210 1
a210 1
	ifp->if_start = tunstart;
d228 3
d233 1
d235 1
a235 1
		    (IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST|IFF_LINK0);
d240 4
a245 3
	s = splnet();
	LIST_INSERT_HEAD(&tun_softc_list, tp, tun_list);
	splx(s);
d247 2
a248 1
	pipex_iface_init(&tp->pipex_iface, ifp);
d251 1
d254 2
a255 2
void
tun_ifdetach(struct ifnet *ifp)
d261 2
a262 1
	pipex_iface_fini(&tp->pipex_iface);
d272 1
a272 1
	LIST_REMOVE(tp, tun_list);
a278 32
}

int
tun_create(struct if_clone *ifc, int unit, int flags)
{
	struct tun_softc	*tp;
	struct ifnet		*ifp;

	tp = malloc(sizeof(*tp), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (tp == NULL)
		return (ENOMEM);

	tp->tun_unit = unit;
	tp->tun_flags = TUN_INITED|TUN_STAYUP;

	ifp = &tp->tun_if;
	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d", ifc->ifc_name,
	    unit);
	ether_fakeaddr(ifp);
	ifp->if_softc = tp;

	tun_ifattach(ifp, flags);

	return (0);
}

int
tun_clone_destroy(struct ifnet *ifp)
{
	struct tun_softc	*tp = ifp->if_softc;

	tun_ifdetach(ifp);
d284 1
a284 1
struct tun_softc *
d289 1
a289 1
	LIST_FOREACH(tp, &tun_softc_list, tun_list)
d295 2
a296 2
int
tun_switch(struct tun_softc *tp, int flags)
d298 1
a298 5
	struct ifnet		*ifp = &tp->tun_if;
	int			 unit, open, s;
	struct ifg_list		*ifgl;
	u_int			ifgr_len;
	char			*ifgrpnames, *p;
d300 4
a303 47
	if ((tp->tun_flags & TUN_LAYER2) == (flags & TUN_LAYER2))
		return (0);

	/* tp will be removed so store unit number */
	unit = tp->tun_unit;
	open = tp->tun_flags & (TUN_OPEN|TUN_NBIO|TUN_ASYNC);
	TUNDEBUG(("%s: switching to layer %d\n", ifp->if_xname,
		    flags & TUN_LAYER2 ? 2 : 3));

	/* remember joined groups */
	ifgr_len = 0;
	ifgrpnames = NULL;
	TAILQ_FOREACH(ifgl, &ifp->if_groups, ifgl_next)
		ifgr_len += IFNAMSIZ;
	if (ifgr_len)
		ifgrpnames = malloc(ifgr_len + 1, M_TEMP, M_NOWAIT|M_ZERO);
	if (ifgrpnames) {
		p = ifgrpnames;
		TAILQ_FOREACH(ifgl, &ifp->if_groups, ifgl_next) {
			strlcpy(p, ifgl->ifgl_group->ifg_group, IFNAMSIZ);
			p += IFNAMSIZ;
		}
	}

	if (ifp->if_flags & IFF_UP)
		if_down(ifp);

	tun_ifdetach(ifp);
	tun_ifattach(ifp, flags);

	/* rejoin groups */
	for (p = ifgrpnames; p && *p; p += IFNAMSIZ)
		if_addgroup(ifp, p);

	if (open) {
		/* already opened before ifconfig tunX link0 */
		s = splnet();
		tp->tun_flags |= open;
		ifp->if_flags |= IFF_RUNNING;
		tun_link_state(tp);
		splx(s);
		TUNDEBUG(("%s: already open\n", tp->tun_if.if_xname));
	}
	if (ifgrpnames)
		free(ifgrpnames, M_TEMP, 0);

	return (0);
d313 2
a314 3
	struct tun_softc	*tp;
	struct ifnet		*ifp;
	int			 error, s;
d328 30
a380 1
	int			 s;
a381 1
	struct ifnet		*ifp;
d385 18
d429 1
a429 1
tuninit(struct tun_softc *tp)
d434 1
a434 1
	TUNDEBUG(("%s: tuninit\n", ifp->if_xname));
d499 1
a499 1
		tuninit(tp);
d514 1
a514 1
		tuninit(tp);
a526 2
		error = tun_switch(tp,
		    ifp->if_flags & IFF_LINK0 ? TUN_LAYER2 : 0);
d619 21
a640 1
	struct tun_softc	*tp;
a643 3
	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

d733 7
a739 7
	    {
		int ret;
		ret = pipex_ioctl(&tp->pipex_iface, cmd, data);
		splx(s);
		return (ret);
	    }
#else
a741 1
#endif
d754 20
a773 1
	struct tun_softc	*tp;
a778 3
	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

d850 20
a869 1
	struct tun_softc	*tp;
a877 4

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

d1000 20
a1020 1
	struct tun_softc	*tp;
a1023 3
	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (POLLERR);

d1058 20
a1079 1
	struct tun_softc	*tp;
a1081 3
	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

d1187 1
a1187 1
tunstart(struct ifnet *ifp)
@


1.154
log
@if_put after if_get.

this is a bit funky cos we give up the ref while sleeping in tunread,
and have to get a new ref on wakeup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.153 2015/09/01 21:24:04 bluhm Exp $	*/
d737 1
@


1.153
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.152 2015/08/28 15:37:04 reyk Exp $	*/
d732 1
a732 1
	ifp = &tp->tun_if;
d745 1
d758 1
d792 1
@


1.152
log
@Fix compiling a kernel without NBPFILTER > 0.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.151 2015/07/20 22:54:29 mpi Exp $	*/
d447 1
a447 1
			struct sockaddr_in6 *sin;
d449 2
a450 2
			sin = (struct sockaddr_in6 *)ifa->ifa_addr;
			if (!IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
d454 3
a456 3
				sin = (struct sockaddr_in6 *)ifa->ifa_dstaddr;
				if (sin &&
				    !IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
@


1.151
log
@Remove splassert(IPL_NET) from if_input().

if_input() has been designed to be able to safely handle a batch of
packets from physical drivers to the network stack.  Most of these
drivers have an interrupt routine executed at IPL_NET and the check
made sense during the conversion.  However we also want to re-enqueue
packets with if_input() from the network stack currently running at
IPL_SOFTNET.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.150 2015/07/15 22:16:42 deraadt Exp $	*/
d804 4
a807 1
	int			 error=0, s, tlen, mlen;
@


1.150
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.149 2015/07/08 07:21:50 mpi Exp $	*/
a877 1
		s = splnet();
a878 2
		splx(s);

@


1.149
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.148 2015/06/30 13:54:42 mpi Exp $	*/
d867 1
a867 2
		if (top != NULL)
			m_freem(top);
@


1.148
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.147 2015/06/24 09:40:54 mpi Exp $	*/
d779 1
a779 1
		MFREE(m0, m);
@


1.147
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.146 2015/06/16 11:09:39 mpi Exp $	*/
d572 1
a572 1
	error = if_output(ifp, m0);
@


1.146
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.145 2015/06/01 07:48:04 mpi Exp $	*/
a881 1
		ifp->if_ipackets++;
@


1.145
log
@Convert tun(4) to if_input().

Tested by Norman Golisz and <mxb AT alumni DOT chalmers DOT se>, thanks!

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.144 2015/05/26 11:36:26 dlg Exp $	*/
d901 1
a901 1
	top->m_pkthdr.rcvif = ifp;
@


1.144
log
@move add_net_randomness from ether_input to the if_input task.

change it from feeding the ethertype of the packet (which is almost
certainly an ip packet or vlan packet, so not that variable) to the
number of packets about to be processed.

ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.143 2015/05/20 08:28:54 mpi Exp $	*/
d874 12
a885 1
	top->m_pkthdr.rcvif = ifp;
a894 10
	if (tp->tun_flags & TUN_LAYER2) {
		s = splnet();
		ether_input_mbuf(ifp, top);
		splx(s);

		ifp->if_ipackets++;

		return (0);
	}

d901 1
@


1.143
log
@Do not increment if_opackets in if_output().  It might make sense to do
that later but all drivers should be adapated.

Should fix a double output packet accounting, reported by Hrvoje Popovski.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.142 2015/05/19 15:10:59 mpi Exp $	*/
a884 3
		/* quirk to not add randomness from a virtual device */
		atomic_setbits_int(&netisr, (1 << NETISR_RND_DONE));

@


1.142
log
@splx should also be called in the error case, fix a regression
introduced during the if_output() conversion.

Found by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.141 2015/05/15 12:40:05 mpi Exp $	*/
d579 1
@


1.141
log
@Remove useless comments mentioning ether_output().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.140 2015/05/15 10:15:13 mpi Exp $	*/
d573 2
a578 2

	splx(s);
@


1.140
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.139 2015/04/30 15:19:50 mpi Exp $	*/
a549 1
		/* call ether_output and that will call tunstart at the end */
a1089 4
/*
 * Start packet transmission on the interface.
 * In layer 2 mode this function is called from ether_output.
 */
@


1.139
log
@Do not free & reallocate a new chunk of memory for the interface
descriptor during SIOCSIFFLAGS.

This prevent a use after free, triggered by the pool/malloc damage
finder being currently cooked by dlg@@ and deraadt@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.138 2015/04/29 16:00:06 deraadt Exp $	*/
d532 1
a532 1
	int			 s, len, error;
d573 1
a573 2
	len = m0->m_pkthdr.len;
	IFQ_ENQUEUE(&ifp->if_snd, m0, NULL, error);
a574 1
		splx(s);
d578 1
a579 2
	ifp->if_opackets++;
	ifp->if_obytes += len;
@


1.138
log
@Use if_get() after every tsleep(), in case the bottom half of the driver
has destroyed or damaged the interface clone.
with mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.137 2015/04/15 10:11:29 mpi Exp $	*/
d122 2
d159 2
a160 2
int
tun_create(struct if_clone *ifc, int unit, int flags)
d162 1
a162 2
	struct tun_softc	*tp;
	struct ifnet		*ifp;
a164 13
	tp = malloc(sizeof(*tp), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!tp)
		return (ENOMEM);

	tp->tun_unit = unit;
	tp->tun_flags = TUN_INITED|TUN_STAYUP;

	ifp = &tp->tun_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name,
	    unit);
	ether_fakeaddr(ifp);

	ifp->if_softc = tp;
a193 2
	/* force output function to our function */
	ifp->if_output = tun_output;
a201 1
	return (0);
d204 2
a205 2
int
tun_clone_destroy(struct ifnet *ifp)
d228 32
d280 1
a280 1
	int			 unit, open, r, s;
d309 9
a317 11
	/* remove old device and ... */
	tun_clone_destroy(ifp);
	/* attach new interface */
	r = tun_create(&tun_cloner, unit, flags);

	if (r == 0) {
		if ((tp = tun_lookup(unit)) == NULL) {
			/* this should never fail */
			r = ENXIO;
			goto abort;
		}
d319 1
a319 6
		/* rejoin groups */
		ifp = &tp->tun_if;
		for (p = ifgrpnames; p && *p; p += IFNAMSIZ)
			if_addgroup(ifp, p);
	}
	if (open && r == 0) {
a327 1
 abort:
d330 2
a331 1
	return (r);
@


1.137
log
@Fix a typo introduced in the niq_enqueue() conversion.

Should fix a panic reported by many on bugs@@ and misc@@.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.136 2015/04/10 13:58:20 dlg Exp $	*/
d720 1
d726 1
d737 1
a737 1
		while ((tp->tun_flags & TUN_READY) != TUN_READY)
d743 5
d759 4
@


1.136
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.135 2015/04/01 14:29:54 mpi Exp $	*/
d900 1
a900 1
	if (niq_enqueue(ifq, m) != 0) {
@


1.135
log
@Kill useless comments talking about ether_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.134 2015/03/18 12:23:15 dlg Exp $	*/
d783 1
a783 1
	struct ifqueue		*ifq;
a785 1
	int			 isr;
a888 1
		isr = NETISR_IP;
a892 1
		isr = NETISR_IPV6;
d900 1
a900 4
	s = splnet();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		splx(s);
a901 2
		m_freem(top);
		if_congestion();
d904 1
a904 2
	IF_ENQUEUE(ifq, top);
	schednetisr(isr);
d907 1
a907 1
	splx(s);
@


1.134
log
@remove the congestion handling from struct ifqueue.

its only used for the ip and ip6 network stack input queues, so it
seems unfair that every instance of ifqueue has to carry a pointer
around for this specific use case.

this moves the congestion marker to a kernel global. if we detect
that we're congested, we assume the whole system is busy and punish
all input queues.

marking a system as congested is done by setting the global to the
current value of ticks. as the system moves away from that value,
it moves away from being congested until the comparison fails.

written at s2k15
ok henning@@ beck@@ bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.133 2015/03/14 03:38:51 jsg Exp $	*/
d875 1
a875 1
		ifp->if_ipackets++; /* ibytes are counted in ether_input */
@


1.133
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.132 2015/02/10 21:56:10 miod Exp $	*/
d909 1
a909 2
		if (!ifq->ifq_congestion)
			if_congestion(ifq);
@


1.132
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.131 2015/01/21 02:23:14 guenther Exp $	*/
a64 1
#include <netinet/ip.h>
@


1.131
log
@Delete option COMPAT_43: support for pre-sa_len binaries has been obsolete
for a couple decades.  Keep the OSIOCGIFCONF ioctl to support COMPAT_LINUX
but move the rest of the Linux-specific ioctl() handling into linux_socket.c
This lets struct osockaddr finally move from sys/socket.h to protocols/talkd.h

ok krw@@ deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.130 2014/12/19 17:14:40 tedu Exp $	*/
d761 1
a761 1
			error = uiomove(mtod(m0, caddr_t), len, uio);
d829 1
a829 1
		error = uiomove(mtod (m, caddr_t), m->m_len, uio);
@


1.130
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.129 2014/10/21 10:52:53 yasuoka Exp $	*/
a675 1
	case OSIOCGIFADDR:
@


1.129
log
@tun(4) has a pipex session which is used for multicast internally, it
wasn't freeed when the interface is destroyed.  Free it properly.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.128 2014/09/08 06:24:13 jsg Exp $	*/
a63 1
#ifdef INET
a66 1
#endif
a414 1
#ifdef INET
a435 1
#endif
a476 1
#ifdef INET
a479 1
#endif
a889 1
#ifdef INET
a893 1
#endif
@


1.128
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.127 2014/07/22 11:06:09 mpi Exp $	*/
d229 1
a229 1
	pipex_iface_stop(&tp->pipex_iface);
@


1.127
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.126 2014/07/12 18:44:22 tedu Exp $	*/
a62 1
#include <net/route.h>
@


1.126
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.125 2014/05/05 11:44:33 mpi Exp $	*/
a66 1
#include <netinet/in_systm.h>
@


1.125
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.124 2014/04/22 14:41:03 mpi Exp $	*/
d249 1
a249 1
	free(tp, M_DEVBUF);
d325 1
a325 1
		free(ifgrpnames, M_TEMP);
@


1.124
log
@Remove some altq tentacles.

ok pelikan@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.123 2014/04/18 15:20:00 henning Exp $	*/
d472 1
d481 2
a482 2
		if (tp->tun_flags & TUN_LAYER2)
			switch (((struct ifaddr *)data)->ifa_addr->sa_family) {
d485 1
a485 1
				arp_ifinit(&tp->arpcom, (struct ifaddr *)data);
d491 3
@


1.123
log
@reaching into altq outside #ifdef ALTQ is bad, mmkay? ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.121 2014/03/30 21:54:48 guenther Exp $	*/
a1092 3
 * when the interface queue is rate-limited by ALTQ or TBR,
 * if_start is needed to drain packets from the queue in order
 * to notify readers when outgoing packets become ready.
@


1.122
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@a1105 5
	if (!(tp->tun_flags & TUN_LAYER2) &&
	    !ALTQ_IS_ENABLED(&ifp->if_snd) &&
	    !TBR_IS_ENABLED(&ifp->if_snd))
		return;

@


1.121
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.120 2013/10/24 11:31:43 mpi Exp $	*/
d891 1
a891 1
	top->m_pkthdr.rdomain = ifp->if_rdomain;
@


1.120
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.119 2013/10/23 15:12:42 mpi Exp $	*/
d674 1
a674 1
		tp->tun_siguid = p->p_cred->p_ruid;
@


1.119
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.118 2013/10/19 14:46:31 mpi Exp $	*/
a69 4
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
@


1.118
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.117 2013/10/17 16:27:41 bluhm Exp $	*/
a67 1
#include <netinet/in_var.h>
@


1.117
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.116 2013/10/04 08:40:32 mpi Exp $	*/
d507 1
a507 34
	case SIOCDELMULTI: {
		if (ifr == 0) {
			error = EAFNOSUPPORT;	   /* XXX */
			break;
		}

		if (tp->tun_flags & TUN_LAYER2) {
			error = (cmd == SIOCADDMULTI) ?
			    ether_addmulti(ifr, &tp->arpcom) :
			    ether_delmulti(ifr, &tp->arpcom);
			if (error == ENETRESET) {
				/*
				 * Multicast list has changed; set the hardware
				 * filter accordingly. The good thing is we do 
				 * not have a hardware filter (:
				 */
				error = 0;
			}
			break;
		}

		switch (ifr->ifr_addr.sa_family) {
#ifdef INET
		case AF_INET:
			break;
#endif
#ifdef INET6
		case AF_INET6:
			break;
#endif
		default:
			error = EAFNOSUPPORT;
			break;
		}
a508 2
	}

@


1.116
log
@SIOCSIFBRDADDR is not passed to the per-driver ioctl function, so it
makes no sense to let tun(4) handle it.

ok claudio@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.115 2013/05/25 10:05:52 mikeb Exp $	*/
d71 4
@


1.115
log
@set the IFF_RUNNNING flag when recreating an interface after the
IFF_LINK0 flag has been added;  from form, ok deraadt claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.114 2013/03/28 16:55:27 deraadt Exp $	*/
a494 4
		break;
	case SIOCSIFBRDADDR:
		tuninit(tp);
		TUNDEBUG(("%s: broadcast address set\n", ifp->if_xname));
@


1.114
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.113 2013/03/26 13:19:26 mpi Exp $	*/
d319 1
@


1.113
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.112 2011/07/09 00:47:18 henning Exp $	*/
a58 1
#include <machine/cpu.h>
@


1.112
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.111 2011/07/07 20:42:56 henning Exp $	*/
d189 1
a189 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.111
log
@use IF_LEN/IFQ_LEN to access and ifqueue's length field. ryan ok
with this nothing in the tree fiddles if ifqueue internals any more, of
course except if.c and if.h (and some altq)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.110 2011/07/02 22:20:08 nicm Exp $	*/
a77 5
#ifdef NETATALK
#include <netatalk/at.h>
#include <netatalk/at_var.h>
#endif

a943 6
		break;
#endif
#ifdef NETATALK
	case AF_APPLETALK:
		ifq = &atintrq2;
		isr = NETISR_ATALK;
@


1.110
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.109 2010/09/23 04:47:02 matthew Exp $	*/
d1005 1
a1005 1
			    ifp->if_snd.ifq_len));
d1099 1
a1099 1
		kn->kn_data = ifp->if_snd.ifq_len;
d1102 1
a1102 1
		    ifp->if_snd.ifq_len));
@


1.109
log
@If tunread() fails, we should increment if_oerrors, not if_ierrors.

"yup" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.108 2010/09/22 05:44:27 matthew Exp $	*/
d1054 1
a1054 1
			return (EPERM);	/* 1 */
@


1.108
log
@Don't bother calling suser() in tunopen().

"Sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.107 2010/07/08 08:40:29 yasuoka Exp $	*/
d821 1
a821 1
		ifp->if_ierrors++;
@


1.107
log
@pipex didn't work on output.  Fixed following problems:
 - pipex failed to lookup the radix tree because address and netmask
   were not initialized.
 - pipex used wrong place as a ip header because it didn't adjust
   32bit address family header that are added at tun_output.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.106 2010/05/06 13:06:40 claudio Exp $	*/
a344 3

	if ((error = suser(p, 0)) != 0)
		return (error);
@


1.106
log
@Remove the incorrect if_media code. It is no longer needed to show and track
link states. Additionally do not up the interface when opening the device.
Resulting in the same behaviour as on real ethernet interfaces.
OK sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.105 2010/01/13 07:23:38 yasuoka Exp $	*/
a576 3
#ifdef PIPEX
	struct pipex_session	*session;
#endif
d609 2
a610 2
	if ((session = pipex_ip_lookup_session(m0, &tp->pipex_iface)) != NULL) {
		pipex_ip_output(m0, session);
@


1.105
log
@cleanup pipex code.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.104 2010/01/12 11:28:09 deraadt Exp $	*/
a61 1
#include <net/if_media.h>
a94 1
	struct ifmedia	tun_media;
a140 2
int	tun_media_change(struct ifnet *);
void	tun_media_status(struct ifnet *, struct ifmediareq *);
d193 1
a196 4
	ifmedia_init(&tp->tun_media, 0, tun_media_change, tun_media_status);
	ifmedia_add(&tp->tun_media, IFM_ETHER | IFM_AUTO, 0, NULL);
	ifmedia_set(&tp->tun_media, IFM_ETHER | IFM_AUTO);

d367 1
a367 1
	/* automatically UP the interface on open */
a370 1
	if_up(ifp);
a555 4
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &tp->tun_media, cmd);
		break;
a1196 22
}

int
tun_media_change(struct ifnet *ifp)
{
	/* Ignore */
	return (0);
}

void
tun_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct tun_softc *tp = ifp->if_softc;

	imr->ifm_active = IFM_ETHER | IFM_AUTO;
	imr->ifm_status = IFM_AVALID;

	tun_link_state(tp);

	if (LINK_STATE_IS_UP(ifp->if_link_state) &&
	    ifp->if_flags & IFF_UP)
		imr->ifm_status |= IFM_ACTIVE;
@


1.104
log
@do not need rndvar.h anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.103 2010/01/12 04:06:55 yasuoka Exp $	*/
d104 1
a104 2
	/* pipex context */
	struct pipex_iface_context	pipex_iface;
d590 2
a591 2
	struct pipex_session *session;
#endif /* PIPEX */
d629 1
a629 1
#endif /* PIPEX */
d767 1
a767 1
		return ret;
@


1.103
log
@Remove simple_unlock() that is mistakenly introduced and add required
splx().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.102 2010/01/12 03:41:29 deraadt Exp $	*/
a87 3

/* for arc4random() */
#include <dev/rndvar.h>
@


1.102
log
@Unify the various fake ethernet generators as ether_fakeaddr() which
is safe for both hardware devices and virtual devices
ok mpf, kettenis, moaning and groaning and slow acceptance from mcbride
XXX should loop checking for uniqueness after new henning diff goes in
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.101 2010/01/11 03:50:56 yasuoka Exp $	*/
d630 1
a630 1
		simple_unlock(&tp->pppac_lock);
@


1.101
log
@Initial import PIPEX.  PIPEX(Pppac IP EXtension) is a IP forwarding
acceleration for PPP access concentrator.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.100 2009/11/09 17:53:39 nicm Exp $	*/
a181 1
	u_int32_t		 macaddr_rnd;
a190 11
	/* generate fake MAC address: 00 bd xx xx xx unit_no */
	tp->arpcom.ac_enaddr[0] = 0x00;
	tp->arpcom.ac_enaddr[1] = 0xbd;
	/*
	 * This no longer happens pre-scheduler so let's use the real
	 * random subsystem instead of random().
	 */
	macaddr_rnd = arc4random();
	bcopy(&macaddr_rnd, &tp->arpcom.ac_enaddr[2], sizeof(u_int32_t));
	tp->arpcom.ac_enaddr[5] = (u_char)unit + 1;

d194 2
@


1.100
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.99 2009/08/09 10:09:12 claudio Exp $	*/
d75 4
d106 4
d166 3
d245 3
d258 3
d603 3
d637 7
d776 8
d786 1
@


1.99
log
@Tag packets into correct rdomain in tunwrite(). For L2 traffic this will be
done in ether_input() but L3 traffic needs to do it self.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.98 2009/08/02 19:50:16 mpf Exp $	*/
a414 1
		KNOTE(&tp->tun_rsel.si_note, 0);
a643 1
	KNOTE(&tp->tun_rsel.si_note, 0);
@


1.98
log
@Preserve joined interface groups when tun(4) is switched
between layer 2 and 3 tunneling mode.
OK claudio@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.97 2009/06/04 06:57:27 claudio Exp $	*/
d934 1
@


1.97
log
@Emulate a link state in tun(4). The link state goes up when the device is
opened and goes down when the device fd is closed. Makes working with qemu
a bit nicer when routing to tun(4) interfaces.
dlg@@ "diff reads good"
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.96 2009/02/20 12:47:57 jsing Exp $	*/
d278 5
a282 2
	struct ifnet	*ifp = &tp->tun_if;
	int		 unit, open, r, s;
d293 15
d313 12
a326 3
		if ((tp = tun_lookup(unit)) == NULL)
			/* this should never fail */
			return (ENXIO);
d333 3
@


1.96
log
@Ensure that bpf_mtap() is always called at the same interrupt priority
level within the tun(4) driver. Otherwise we can be interrupted whilst
copying a packet into the BPF buffer, leading to a race between bpf_mtap()
calls. This can result in corruption within the BPF buffers.

Also ensure that we are at IPL_NET when calling ether_input_mbuf().

Fixes PR6073.

ok claudio@@, canacar@@ (for an earlier version of this diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.94 2008/08/04 18:55:08 damien Exp $	*/
d62 1
a91 4
	u_short		tun_flags;	/* misc flags */
	pid_t		tun_pgid;	/* the process group - if any */
	uid_t		tun_siguid;	/* uid for process that set tun_pgid */
	uid_t		tun_sigeuid;	/* euid for process that set tun_pgid */
d94 2
d97 4
a100 1
	LIST_ENTRY(tun_softc) tun_list;	/* all tunnel interfaces */
d132 1
a132 2
static int tuninit(struct tun_softc *);
static void tunstart(struct ifnet *);
d137 4
d199 1
d202 5
d213 1
d223 2
d279 1
a279 1
	int		 unit, open, r;
d300 1
d302 2
d343 2
a345 1
	ifp->if_flags |= IFF_RUNNING;
a367 1
	ifp->if_flags &= ~IFF_RUNNING;
d373 2
d391 1
a391 1
static int
d532 4
d1116 1
a1116 1
static void
d1140 40
@


1.95
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d559 2
a566 1
	s = splnet();
d856 2
a857 1
	if (ifp->if_bpf)
d859 2
d867 1
d869 2
d872 1
d1098 2
@


1.94
log
@do not count ethernet header twice in if_obytes stats.
do not count address family field twice in tun's if_obytes stats.

ok henning@@ reyk@@ deraadt@@ for the ethernet bits.
ok deraadt@@ for the tun bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.93 2008/05/07 05:51:12 mpf Exp $	*/
d441 1
a441 5
	if (tp->tun_flags & TUN_LAYER2)
		if ((error = ether_ioctl(ifp, &tp->arpcom, cmd, data)) > 0) {
			splx(s);
			return (error);
		}
d514 4
a517 1
		error = ENOTTY;
d519 1
@


1.93
log
@Prevent virtual interfaces from adding to the random pool.
Also move the sampling into ether_input() where it can happen
at the interrupt and not within splnet() processing, which might
be less random. Discussed with mickey.
OK markus@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.92 2008/05/06 07:18:09 krw Exp $	*/
d564 1
a564 1
	len = m0->m_pkthdr.len + sizeof(*af);
@


1.92
log
@M_PREPEND can set its first parameter to NULL, and all other code
using M_PREPEND checks for NULL after the invocation. So check
here too and return ENOBUFS if NULL is detected.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.91 2007/12/20 02:53:02 brad Exp $	*/
d860 3
@


1.91
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.90 2007/09/15 16:43:51 henning Exp $	*/
d554 2
@


1.90
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.89 2007/06/06 10:04:36 henning Exp $	*/
d518 1
a518 1
		error = EINVAL;
@


1.89
log
@remove remaining IPX hooks. all inside #ifdef IPX, so no actual change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.88 2007/05/26 17:13:31 jason Exp $	*/
d169 1
a169 1
	tp = malloc(sizeof(*tp), M_DEVBUF, M_NOWAIT);
a171 1
	bzero(tp, sizeof(*tp));
@


1.88
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.87 2007/05/26 00:36:03 krw Exp $	*/
a73 5
#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

a880 6
		break;
#endif
#ifdef IPX
	case AF_IPX:
		ifq = &ipxintrq;
		isr = NETISR_IPX;
@


1.87
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.86 2007/05/03 21:03:46 mpf Exp $	*/
a115 2

extern int ifqmaxlen;
@


1.86
log
@Use if_flags instead of ifr_flags.
It shouldn't make a difference, but some
ioctl-callers don't initialize the ifreq properly.
Fixes a panic w/ tun(4) on trunk(4).
OK reyk@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.85 2007/02/21 13:24:55 claudio Exp $	*/
d822 1
a822 1
		 * this is neccessary for all strict aligned architectures.
@


1.85
log
@For TUNSIFMODE protect the if_flags similar to the TUNSIFINFO case.
Don't allow the userland to fiddle with flags reserved by the driver.
Noticed by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.84 2007/02/16 13:41:21 claudio Exp $	*/
d523 1
a523 1
		    ifr->ifr_flags & IFF_LINK0 ? TUN_LAYER2 : 0);
@


1.84
log
@Unbreak ppp(8) over tun(4) by restriciting the flags that can be changed
via TUNSIFINFO. ppp(8) was happily clearing the RUNNING flag and so all
incomming packets where dropped. Issue reported by irix <at> ukr <dot> net.
While there check that the mtu is in a valid range -- stolen from SIOCSIFMTU
case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.83 2007/02/06 10:49:40 claudio Exp $	*/
d648 2
a649 3
		tp->tun_if.if_flags &=
		    ~(IFF_BROADCAST|IFF_POINTOPOINT|IFF_MULTICAST);
			tp->tun_if.if_flags |= *(int *)data;
@


1.83
log
@Change the behaviour of tun(4) on close.
 - if the interface was auto-created by opening a /dev/tun* device it will
   auto-destroy on close. This is comparable to ifconfig tun0 destroy and
   will remove all routes and addresses associated with the interface.
 - if the interface was created by ifconfig(8) or hostname.if(5) the interface
   is persistent -- it is just marked as not running. Especially routes are no
   longer removed when the interface is closed. This is useful for static
   setups like the server side of a ssh vpn or static qemu session.
This behaviour is more logic then the half done cleanup that is currently done.
OK mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.82 2007/01/26 10:58:47 claudio Exp $	*/
d114 3
d618 4
d624 3
a626 1
		tp->tun_if.if_flags = tunp->flags;
@


1.82
log
@When switching mode inherit the TUN_NBIO and TUN_ASYNC flags and clear
these flags on close.  OK mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.81 2006/11/10 09:34:39 claudio Exp $	*/
d179 1
a179 1
	tp->tun_flags = TUN_INITED;
d320 1
d341 1
a341 1
 *  output and (unless set STAYUP) bring down the interface.
d364 1
a364 6
	if ((ifp->if_flags & IFF_UP) && !(tp->tun_flags & TUN_STAYUP)) {
		s = splnet();
		if_down(ifp);
		if (ifp->if_flags & IFF_RUNNING) {
			/* find internet addresses and delete routes */
			struct ifaddr	*ifa = NULL;
d366 6
a371 15
			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
#ifdef INET
				if (ifa->ifa_addr->sa_family == AF_INET) {
					rtinit(ifa, (int)RTM_DELETE,
					    (tp->tun_flags & TUN_DSTADDR)?
					    RTF_HOST : 0);
				}
				/* XXX INET6 */
#endif
			}

			rt_if_remove(ifp);
			ifp->if_flags &= ~IFF_RUNNING;
		}
		splx(s);
a372 3
	tp->tun_pgid = 0;
	selwakeup(&tp->tun_rsel);
	KNOTE(&tp->tun_rsel.si_note, 0);
a373 1
	TUNDEBUG(("%s: closed\n", ifp->if_xname));
d540 1
a540 1
	if (!(ifp->if_flags & IFF_UP)) {
@


1.81
log
@Fix an mbuf leak in an error path. OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.80 2006/11/01 03:37:24 tedu Exp $	*/
d277 1
a277 1
	open = tp->tun_flags & TUN_OPEN;
d281 1
a281 3
	/*
	 * remove old device
	 */
d283 2
a285 4
	/*
	 * attach new interface
	 */
	r = tun_create(&tun_cloner, unit, flags);
d291 1
a291 1
		tp->tun_flags |= TUN_OPEN;
d353 2
a354 1
	tp->tun_flags &= ~TUN_OPEN;
@


1.80
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.79 2006/03/25 22:41:48 djm Exp $	*/
d823 1
a823 1
			m_freem(m);
d855 1
@


1.79
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.78 2006/03/20 10:03:49 henning Exp $	*/
d950 1
a950 1
		return (ENXIO);
@


1.78
log
@introduce rt_if_remove which takes care of routing table updates for an
interface that is removed. use that from if.c and if_tun.c instead of
re-implementing in the latter case. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.77 2006/03/16 09:30:54 claudio Exp $	*/
d584 1
a584 1
		bpf_mtap(ifp->if_bpf, m0);
d873 1
a873 1
		bpf_mtap(ifp->if_bpf, top);
d1121 1
a1121 1
				bpf_mtap(ifp->if_bpf, m);
@


1.77
log
@Switch tun(4) from encapsualting packets into a long mbuf chain over to use
mbuf clusters if the packet is big enough. This should speed up tun(4) and
may help in other cases where long mbuf chains hurt.
Additionally switch the default tun(4) MTU to a more sane 1500 bytes.
TUNMTU is kept because it is used in userland.
Input and OK from brad@@ and djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.76 2006/03/05 02:35:38 brad Exp $	*/
d349 1
a349 2
	extern int if_detach_rtdelete(struct radix_node *, void *);
	int			 s, i;
a351 1
	struct radix_node_head	*rnh;
d383 2
a384 11
			/*
			 * Find and remove all routes which is using this
			 * interface. Stolen from if.c if_detach().
			 */
			for (i = 1; i <= AF_MAX; i++) {
				rnh = rt_tables[i];
				if (rnh)
					while ((*rnh->rnh_walktree)(rnh,
					    if_detach_rtdelete, ifp) == EAGAIN)
						;
			}
@


1.76
log
@change the interface type from IFF_POINTOPOINT to the more correct
type of IFF_TUNNEL (Encapsulation interface).

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.75 2006/03/04 22:40:16 brad Exp $	*/
d203 1
a203 1
		ifp->if_mtu = TUNMTU;
d831 8
d862 8
@


1.75
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.74 2006/01/11 12:51:33 claudio Exp $	*/
d205 1
a205 1
		ifp->if_type  = IFF_POINTOPOINT;
@


1.74
log
@Do not use m_adj() on empty mbufs (m->m_len is uninitialised), instead bump
m->m_data directly. This fixes the tun(4) / bridge(4) crash reported in
PR4963. OK djm@@ mpf@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.73 2005/11/29 02:59:42 jolan Exp $	*/
d205 1
a205 1
		ifp->if_type  = IFT_PROPVIRTUAL;
d222 1
a222 1
	s = splimp();
d242 1
a242 1
	s = splimp();
d333 1
a333 1
	s = splimp();
d364 1
a364 1
	s = splimp();
d369 1
a369 1
		s = splimp();
d476 1
a476 1
	s = splimp();
d599 1
a599 1
	s = splimp();
d642 1
a642 1
	s = splimp();
d757 1
a757 1
	s = splimp();
d913 1
a913 1
	s = splimp();
d949 1
a949 1
	s = splimp();
d991 1
a991 1
	s = splimp();
@


1.73
log
@something in the eurobsdcon route-a-thon broke my simple home network
router so back out the routing stuff to pre-eurobsdcon where my machine
doesn't crash immediately.

i am happy to test diffs and report success/failures but i am not happy
to have instantaneous crashes when i reboot with a new kernel that was
compiled from pristine sources.

if you are going to be an elitist asshole then you could at least make
sure your code works.

ok and "be crass towards them" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.71 2005/11/21 18:16:45 millert Exp $	*/
d840 1
a840 1
		m_adj(m, ETHER_ALIGN);
@


1.72
log
@move the code to delete routes having a specific interface as output
when the interface is deleted to a function in route.c, and replace
the copies of that code by calls to that function
from basel almost-hackathon
@
text
@d349 2
a350 1
	int			 s;
d353 1
d385 11
a395 1
			rt_if_remove(ifp);
@


1.71
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.70 2005/11/17 11:08:52 henning Exp $	*/
d349 1
a349 2
	extern int if_detach_rtdelete(struct radix_node *, void *);
	int			 s, i;
a351 1
	struct radix_node_head	*rnh;
d383 1
a383 11
			/*
			 * Find and remove all routes which is using this
			 * interface. Stolen from if.c if_detach().
			 */
			for (i = 1; i <= AF_MAX; i++) {
				rnh = rt_tables[i];
				if (rnh)
					while ((*rnh->rnh_walktree)(rnh,
					    if_detach_rtdelete, ifp) == EAGAIN)
						;
			}
@


1.70
log
@tun devices get created (cloned) automagically when the device is opened.
the code took a shortcut which results in the new device not beeing added
to its interface class group as it should.
call the regular if_clone_create() instead of taking shortcuts, and all is
fine.
ok markus, tested Mike Belopuhov <mkb@@crypt.org.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.69 2005/11/16 10:45:33 henning Exp $	*/
d50 1
a50 1
#include <sys/select.h>
@


1.69
log
@small doses of KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.68 2005/06/08 06:53:32 henning Exp $	*/
d316 5
a320 1
		tun_clone_create(&tun_cloner, minor(dev));
@


1.68
log
@huch, more netns shitz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.67 2005/06/08 06:35:04 henning Exp $	*/
d162 1
a162 1
	return tun_create(ifc, unit, 0);
d168 4
a171 4
	struct tun_softc *tp;
	struct ifnet *ifp;
	u_int32_t macaddr_rnd;
	int s;
d232 2
a233 2
	struct tun_softc *tp = ifp->if_softc;
	int s;
d269 2
a270 2
	struct ifnet *ifp = &tp->tun_if;
	int unit, open, r;
d323 1
a323 1
		return EBUSY;
d459 1
a459 1
	return 0;
d468 3
a470 3
	struct tun_softc *tp = (struct tun_softc *)(ifp->if_softc);
	struct ifreq *ifr = (struct ifreq *)data;
	int	error = 0, s;
d792 1
a792 1
	return error;
d977 4
a980 4
	int s;
	struct klist *klist;
	struct tun_softc *tp;
	struct ifnet *ifp;
d1016 2
a1017 2
	int s;
	struct tun_softc *tp = (struct tun_softc *)kn->kn_hook;
d1019 1
d1029 4
a1032 4
	int s;
	struct tun_softc *tp;
	struct ifnet *ifp;
	struct mbuf *m;
d1036 1
a1036 1
		return 1;
d1060 2
a1061 2
	int s;
	struct tun_softc *tp = (struct tun_softc *)kn->kn_hook;
d1063 1
d1073 2
a1074 2
	struct tun_softc *tp;
	struct ifnet *ifp;
d1099 2
a1100 2
	struct tun_softc *tp = ifp->if_softc;
	struct mbuf *m;
@


1.68.2.1
log
@MFC:
Fix by claudio@@

Do not use m_adj() on empty mbufs (m->m_len is uninitialised), instead bump
m->m_data directly. This fixes the tun(4) / bridge(4) crash reported in
PR4963.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.68 2005/06/08 06:53:32 henning Exp $	*/
d836 1
a836 1
		m->m_data += ETHER_ALIGN;
@


1.67
log
@no more netns handling for the various tunnel devices and loopback
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.66 2005/05/04 12:10:27 markus Exp $	*/
a889 6
		break;
#endif
#ifdef NS
	case AF_NS:
		ifq = &nsintrq;
		isr = NETISR_NS;
@


1.66
log
@set RUNNING on open; from Alexey E. Suslikov; ok henning, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.65 2005/05/03 14:33:50 brad Exp $	*/
a71 5
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
@


1.65
log
@typo, automaticaly -> automatically
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.64 2004/11/11 10:42:04 mpf Exp $	*/
d336 1
@


1.64
log
@Check IFF_UP at tun_output().
ok henning, markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.63 2004/11/09 14:15:40 henning Exp $	*/
d333 1
a333 1
	/* automaticaly UP the interface on open */
@


1.63
log
@big KNF spanking, no change in object file, ecstatic ok from claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.62 2004/11/09 13:45:03 henning Exp $	*/
d570 5
@


1.62
log
@use NULL instead of 0 for poiter comparisions,
from "Alexey E. Suslikov" <cruel@@texnika.com.ua> with a little help from itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.61 2004/07/16 15:01:09 henning Exp $	*/
d100 9
a108 1
	struct	arpcom arpcom;		/* ethernet common data */
a109 8
	u_short	tun_flags;		/* misc flags */
	pid_t	tun_pgid;		/* the process group - if any */
	uid_t	tun_siguid;		/* uid for process that set tun_pgid */
	uid_t	tun_sigeuid;		/* euid for process that set tun_pgid */
	struct	selinfo	tun_rsel;	/* read select */
	struct	selinfo	tun_wsel;	/* write select (not used) */
	int	tun_unit;
	LIST_ENTRY(tun_softc) tun_list;	/* all tunnel interfaces */
d126 1
a126 1
		        struct rtentry *rt);
d158 1
a158 2
tunattach(n)
	int n;
d165 1
a165 3
tun_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
d194 1
a194 2
	bcopy(&macaddr_rnd, &tp->arpcom.ac_enaddr[2],
	    sizeof(u_int32_t));
d198 1
a198 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name, 
d235 1
a235 2
tun_clone_destroy(ifp)
	struct ifnet *ifp;
d261 1
a261 2
tun_lookup(unit)
	int unit;
d311 1
a311 4
tunopen(dev, flag, mode, p)
	dev_t	dev;
	int	flag, mode;
	struct proc *p;
d313 3
a315 3
	struct tun_softc *tp;
	struct ifnet	*ifp;
	int error, s;
d320 2
a321 3
	if ((tp = tun_lookup(minor(dev))) == NULL) {
		/* create on demand */
                (void) tun_clone_create(&tun_cloner, minor(dev));
d347 1
a347 5
tunclose(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d403 1
a403 1
		
d409 1
a409 2
tuninit(tp)
	struct tun_softc *tp;
d412 1
a412 1
	struct ifaddr *ifa;
d470 1
a470 4
tun_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long	cmd;
	caddr_t	data;
d482 1
a482 1
	switch(cmd) {
d564 2
a565 5
tun_output(ifp, m0, dst, rt)
	struct ifnet   *ifp;
	struct mbuf    *m0;
	struct sockaddr *dst;
	struct rtentry *rt;
d567 3
a569 3
	struct tun_softc *tp = ifp->if_softc;
	int		s, len, error;
	u_int32_t	*af;
d575 3
a577 3
			  tp->tun_flags));
		m_freem (m0);
		return EHOSTDOWN;
d583 1
a583 1
	
d606 1
a606 1
	return 0;
d610 1
a610 2
tun_wakeup(tp)
	struct tun_softc *tp;
d627 1
a627 6
tunioctl(dev, cmd, data, flag, p)
	dev_t		dev;
	u_long		cmd;
	caddr_t		data;
	int		flag;
	struct proc	*p;
d629 4
a632 4
	int		s;
	struct tun_softc *tp;
	struct tuninfo *tunp;
	struct mbuf *m;
d661 13
a673 13
        case TUNSIFMODE:
	        switch (*(int *)data & (IFF_POINTOPOINT|IFF_BROADCAST)) {
                case IFF_POINTOPOINT:
                case IFF_BROADCAST:
                        tp->tun_if.if_flags &=
                                ~(IFF_BROADCAST|IFF_POINTOPOINT|IFF_MULTICAST);
                        tp->tun_if.if_flags |= *(int *)data;
                        break;
                default:
		        splx(s);
                        return (EINVAL);
                }
                break;
d675 1
a675 1
       	case FIONBIO:
d691 1
a691 1
		else	
d733 1
a733 4
tunread(dev, uio, ioflag)
	dev_t		dev;
	struct uio	*uio;
	int		ioflag;
d735 4
a738 4
	struct tun_softc *tp;
	struct ifnet	*ifp;
	struct mbuf	*m, *m0;
	int		error = 0, len, s;
d746 2
a747 3
		TUNDEBUG(("%s: not ready %#x\n", ifp->if_xname,
			  tp->tun_flags));
		return EHOSTDOWN;
d756 1
a756 1
			    (PZERO+1)|PCATCH, "tunread", 0)) != 0) {
d764 1
a764 1
				return EWOULDBLOCK;
d798 1
a798 4
tunwrite(dev, uio, ioflag)
	dev_t		dev;
	struct uio	*uio;
	int		ioflag;
d800 7
a806 7
	struct tun_softc *tp;
	struct ifnet	*ifp;
	struct ifqueue	*ifq;
	u_int32_t	*th;
	struct mbuf	*top, **mp, *m;
	int		isr;
	int		error=0, s, tlen, mlen;
d817 1
a817 1
		return EMSGSIZE;
d824 1
a824 1
		return ENOBUFS;
d843 1
a843 1
			MGET (m, M_DONTWAIT, MT_DATA);
d855 1
a855 1
		return error;
d865 1
a865 1
	
d911 1
a911 1
		return EAFNOSUPPORT;
d922 1
a922 1
		return ENOBUFS;
d929 1
a929 1
	return error;
d938 1
a938 4
tunpoll(dev, events, p)
	dev_t		dev;
	int		events;
	struct proc	*p;
d940 4
a943 4
	int		revents, s;
	struct tun_softc *tp;
	struct ifnet	*ifp;
	struct mbuf	*m;
d957 1
a957 1
				  ifp->if_snd.ifq_len));
d980 1
a980 1
tunkqfilter(dev_t dev,struct knote *kn)
d1006 1
a1006 1
			return EPERM;	/* 1 */
d1015 1
a1015 1
	return 0;
d1053 2
a1054 2
					ifp->if_snd.ifq_len));
		return 1;
d1058 1
a1058 1
	return 0;
d1081 1
a1081 1
		return 1;
d1089 1
a1089 1
	return 1;
d1100 1
a1100 2
tunstart(ifp)
	struct ifnet *ifp;
@


1.61
log
@remove netiso shitz, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.60 2004/06/25 04:09:03 claudio Exp $	*/
d792 1
a792 1
		if (m0 == 0) {
d804 1
a804 1
	} while (m0 == 0);
d807 1
a807 1
	while (m0 && uio->uio_resid > 0 && error == 0) {
d815 1
a815 1
	if (m0) {
d861 1
a861 1
	top = 0;
d878 1
a878 1
			if (m == 0) {
d886 2
a887 2
		if (top)
			m_freem (top);
@


1.60
log
@Add tap aka layer 2 tunneling support to tun(4). It can be enabled by setting
the link0 flag via ifconfig(8). OK markus@@, canacar@@ also tested by ish@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.59 2004/04/25 18:50:01 henning Exp $	*/
a88 5
#ifdef ISO
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#endif

a940 6
		break;
#endif
#ifdef ISO
	case AF_ISO:
		ifq = &clnlintrq;
		isr = NETISR_ISO;
@


1.59
log
@check for input queue congestion on those as well and call if_congestion when
needed; these  are slightly different so that we cannot use the new
IF_INPUT_ENQUEUE macro
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.58 2004/03/02 23:09:29 markus Exp $	*/
d71 1
a71 1
/* #include <netinet/if_ether.h> */
d99 3
d105 2
a106 1
	struct	ifnet tun_if;		/* the interface */
d138 1
d142 1
a144 1
#ifdef ALTQ
a145 1
#endif
d175 6
d183 1
d194 12
a209 1
	ifp->if_mtu = TUNMTU;
a211 1
#ifdef ALTQ
a212 3
#endif
	ifp->if_flags = IFF_POINTOPOINT;
	ifp->if_type  = IFT_PROPVIRTUAL;
d215 8
a222 10
	ifp->if_hdrlen = sizeof(u_int32_t);
	ifp->if_collisions = 0;
	ifp->if_ierrors = 0;
	ifp->if_oerrors = 0;
	ifp->if_ipackets = 0;
	ifp->if_opackets = 0;
	ifp->if_ibytes = 0;
	ifp->if_obytes = 0;
	if_attach(ifp);
	if_alloc_sadl(ifp);
d224 1
a224 1
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d226 10
d250 2
d261 3
a263 4
	tun_wakeup(tp);
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
d282 35
d329 1
a329 1
	int error;
d347 6
d368 5
a372 3
	int	s;
	struct tun_softc *tp;
	struct ifnet	*ifp;
d392 2
a393 1
			struct ifaddr *ifa;
d398 2
a399 2
					       (tp->tun_flags & TUN_DSTADDR)?
							RTF_HOST : 0);
d401 1
d404 12
d437 1
d495 2
d500 5
d507 1
a507 1
		tuninit((struct tun_softc *)(ifp->if_softc));
d509 10
d521 1
a521 1
		tuninit((struct tun_softc *)(ifp->if_softc));
d525 1
a525 1
		tuninit((struct tun_softc *)(ifp->if_softc));
d529 4
a532 1
		ifp->if_mtu = ((struct ifreq *)data)->ifr_mtu;
a535 1
		struct ifreq *ifr = (struct ifreq *)data;
d540 16
d573 2
d600 1
a600 1
		TUNDEBUG(("%s: not ready 0%o\n", ifp->if_xname,
d606 4
a696 4
                        if (tp->tun_if.if_flags & IFF_UP) {
                                splx(s);
                                return (EBUSY);
                        }
d734 18
d781 1
a781 1
		TUNDEBUG(("%s: not ready 0%o\n", ifp->if_xname,
d853 2
a854 1
	if (uio->uio_resid == 0 || uio->uio_resid > TUNMRU) {
d868 8
d904 6
d978 1
a978 1
 * tunselect - the select interface, this is only useful on reads
d1041 1
a1041 1
	TUNDEBUG(("%s: tunselect\n", ifp->if_xname));
a1139 1
#ifdef ALTQ
d1145 1
d1154 3
a1156 1
	if (!ALTQ_IS_ENABLED(&ifp->if_snd) && !TBR_IS_ENABLED(&ifp->if_snd))
d1160 8
a1167 1
	if (m != NULL)
d1169 1
a1170 1
#endif
@


1.58
log
@don't leak mbuf if uiomove fails; from netbsd;
ok henning, cedric, claudio, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.57 2004/01/12 04:48:25 tedu Exp $	*/
d810 2
@


1.57
log
@use klist_invalidate to permit destroy while kqueued. ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.56 2004/01/05 23:53:24 mpf Exp $	*/
d732 1
a732 1
		if (uio->uio_resid > 0) {
@


1.56
log
@stop ifc_destroy() if there are still knotes registered.
ok mcbride@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.55 2003/12/16 20:33:25 markus Exp $	*/
d224 4
a227 3
	if (!SLIST_EMPTY(&tp->tun_rsel.si_note) ||
	    !SLIST_EMPTY(&tp->tun_wsel.si_note))
		return(EBUSY);
d916 2
a917 1
	SLIST_REMOVE(&tp->tun_rsel.si_note, kn, knote, kn_selnext);
d929 5
d959 2
a960 1
	SLIST_REMOVE(&tp->tun_wsel.si_note, kn, knote, kn_selnext);
d969 5
@


1.55
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.54 2003/12/10 07:22:42 itojun Exp $	*/
d223 4
@


1.54
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.53 2003/12/06 09:16:38 markus Exp $	*/
d134 1
a134 1
void	tun_clone_destroy(struct ifnet *);
d217 1
a217 1
void
d235 1
@


1.53
log
@support destroy; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.52 2003/12/03 14:53:04 markus Exp $	*/
d316 1
a316 1
			register struct ifaddr *ifa;
d342 1
a342 1
	register struct ifaddr *ifa;
@


1.52
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.51 2003/12/02 06:00:18 mickey Exp $	*/
d134 1
d136 1
d156 1
a156 1
    IF_CLONE_INITIALIZER("tun", tun_clone_create, NULL);
d210 1
a210 1
	s = splnet();
d217 20
d499 8
a515 1
	return 0;
d983 2
a984 11
	if (m != NULL) {
		if (tp->tun_flags & TUN_RWAIT) {
			tp->tun_flags &= ~TUN_RWAIT;
			wakeup((caddr_t)tp);
		}
		if (tp->tun_flags & TUN_ASYNC && tp->tun_pgid)
			csignal(tp->tun_pgid, SIGIO,
			    tp->tun_siguid, tp->tun_sigeuid);
		selwakeup(&tp->tun_rsel);
		KNOTE(&tp->tun_rsel.si_note, 0);
	}
@


1.51
log
@add kq support from wayne@@epipe.com.au and cmaxwell@@themanor.net (now that regress test is there too)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.50 2003/09/23 16:51:13 millert Exp $	*/
d109 2
a119 3
struct tun_softc *tunctl;
int ntun;

d133 2
a134 1

d151 5
d160 10
a169 1
	register int i;
d171 9
d181 7
a187 12
	ntun = n;
	tunctl = malloc(ntun * sizeof(*tunctl), M_DEVBUF, M_WAITOK);
	bzero(tunctl, ntun * sizeof(*tunctl));
	for (i = 0; i < ntun; i++) {
		tunctl[i].tun_flags = TUN_INITED;

		ifp = &tunctl[i].tun_if;
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "tun%d", i);
		ifp->if_softc = &tunctl[i];
		ifp->if_mtu = TUNMTU;
		ifp->if_ioctl = tun_ioctl;
		ifp->if_output = tun_output;
d189 1
a189 1
		ifp->if_start = tunstart;
d191 14
a204 14
		ifp->if_flags = IFF_POINTOPOINT;
		ifp->if_type  = IFT_PROPVIRTUAL;
		IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
		IFQ_SET_READY(&ifp->if_snd);
		ifp->if_hdrlen = sizeof(u_int32_t);
		ifp->if_collisions = 0;
		ifp->if_ierrors = 0;
		ifp->if_oerrors = 0;
		ifp->if_ipackets = 0;
		ifp->if_opackets = 0;
		ifp->if_ibytes = 0;
		ifp->if_obytes = 0;
		if_attach(ifp);
		if_alloc_sadl(ifp);
d206 1
a206 1
		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d208 17
a224 1
	}
d239 1
a239 1
	register int	unit, error;
d244 7
a250 2
	if ((unit = minor(dev)) >= ntun)
		return (ENXIO);
a251 1
	tp = &tunctl[unit];
d272 1
a272 1
	register int	unit, s;
d276 1
a276 1
	if ((unit = minor(dev)) >= ntun)
a278 1
	tp = &tunctl[unit];
d500 1
a500 1
	int		unit, s;
d505 1
a505 1
	if ((unit = minor(dev)) >= ntun)
a507 2
	tp = &tunctl[unit];

a594 1
	int		unit;
d600 1
a600 1
	if ((unit = minor(dev)) >= ntun)
a602 1
	tp = &tunctl[unit];
d664 1
a664 1
	int		unit;
d672 1
a672 1
	if ((unit = minor(dev)) >= ntun)
d675 1
a675 1
	ifp = &tunctl[unit].tun_if;
d796 1
a796 1
	int		unit, revents, s;
d801 1
a801 1
	if ((unit = minor(dev)) >= ntun)
a803 1
	tp = &tunctl[unit];
d838 1
a838 1
	int unit, s;
d843 2
a844 2
	if ((unit = minor(dev)) >= ntun)
		return ENXIO;
a845 1
	tp = &tunctl[unit];
@


1.50
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.49 2003/08/15 20:32:19 tedu Exp $	*/
d140 10
d272 1
d448 1
d794 96
a889 1
/* Does not currently work */
d892 1
a892 1
tunkqfilter(dev_t dev,struct knote *kn)
d894 9
a902 1
	return (1);
d932 1
@


1.49
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.48 2003/06/12 10:49:17 henning Exp $	*/
d56 1
d132 1
a132 1
int	tunselect(dev_t, int, struct proc *);
d746 1
a746 1
tunselect(dev, rw, p)
d748 1
a748 1
	int		rw;
d751 1
a751 1
	int		unit, s;
d761 1
d763 1
a763 1
	TUNDEBUG(("%s: tunselect\n", ifp->if_xname));
d765 1
a765 2
	switch (rw) {
	case FREAD:
a767 1
			splx(s);
d770 4
a773 1
			return 1;
a774 5
		selrecord(curproc, &tp->tun_rsel);
		break;
	case FWRITE:
		splx(s);
		return 1;
d776 2
d779 1
a779 2
	TUNDEBUG(("%s: tunselect waiting\n", ifp->if_xname));
	return 0;
@


1.48
log
@in FIONREAD and FREAD, use IFQ_POLL instead of looking at if_snd.ifq_len /
ifq_head, to make altq work. prevents programs from spinning in non-blocking
select()/read() loops in case of queues hitting their limits.

This makes queueing on tun interfaces work. while it is still advised to
assign packets to queues on tunX and queue on the physical interface in
generic, this doesn't work in the PPPoE case with the userland pppoe process,
there the mbuf tags with the queue IDs don't survive obviously.

based on diff from Trevor Talbot, tested successfully by a lot of people
on the pf@@benzedrine.cx list.

ok pb@@ kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.47 2003/05/03 21:15:11 deraadt Exp $	*/
d196 1
a196 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.47
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.46 2003/04/18 05:26:13 jason Exp $	*/
d453 1
d515 3
a517 2
		if (tp->tun_if.if_snd.ifq_head)
			*(int *)data = tp->tun_if.if_snd.ifq_head->m_pkthdr.len;
d753 1
d765 2
a766 1
		if (ifp->if_snd.ifq_len > 0) {
@


1.46
log
@Add code to set the TUN_* flags for INET6 addresses too.  This allows a
tun with ipv6 only to actually send/recv packets.  itojun "looks ok to me"
(after helping correct several iterations =)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.45 2003/01/07 09:00:34 kjc Exp $	*/
d154 1
a154 1
		sprintf(ifp->if_xname, "tun%d", i);
@


1.45
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.44 2002/12/06 15:58:49 nate Exp $	*/
d302 17
@


1.44
log
@Replace license with something that's actually free.
Approved by original author.  Julian.Onions@@nexor.co.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.43 2002/06/30 13:04:36 itojun Exp $	*/
a379 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a389 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m0, dst->sa_family, &pktattr);
 
d401 1
a401 1
	IFQ_ENQUEUE(&ifp->if_snd, m0, &pktattr, error);
@


1.43
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.42 2002/06/06 21:34:16 provos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1988, Julian Onions <jpo@@cs.nott.ac.uk>
d7 1
d9 8
a16 2
 * This source may be freely distributed, however I would be interested
 * in any changes that are made.
d18 13
@


1.42
log
@kqueue support for bpf; okay markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.41 2002/03/14 01:27:09 millert Exp $	*/
d155 1
@


1.41
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.40 2001/12/10 06:10:53 jason Exp $	*/
d112 1
d746 8
@


1.40
log
@use queue.h macros for TAILQ operations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.39 2001/08/21 11:03:45 brian Exp $	*/
d102 10
a111 10
void	tunattach __P((int));
int	tunopen	__P((dev_t, int, int, struct proc *));
int	tunclose __P((dev_t, int, int, struct proc *));
int	tun_ioctl __P((struct ifnet *, u_long, caddr_t));
int	tun_output __P((struct ifnet *, struct mbuf *, struct sockaddr *,
		        struct rtentry *rt));
int	tunioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	tunread	__P((dev_t, struct uio *, int));
int	tunwrite __P((dev_t, struct uio *, int));
int	tunselect __P((dev_t, int, struct proc *));
d114 1
a114 1
static int tuninit __P((struct tun_softc *));
d116 1
a116 1
static void tunstart __P((struct ifnet *));
@


1.40.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.40 2001/12/10 06:10:53 jason Exp $	*/
d102 10
a111 11
void	tunattach(int);
int	tunopen(dev_t, int, int, struct proc *);
int	tunclose(dev_t, int, int, struct proc *);
int	tun_ioctl(struct ifnet *, u_long, caddr_t);
int	tun_output(struct ifnet *, struct mbuf *, struct sockaddr *,
		        struct rtentry *rt);
int	tunioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	tunread(dev_t, struct uio *, int);
int	tunwrite(dev_t, struct uio *, int);
int	tunselect(dev_t, int, struct proc *);
int	tunkqfilter(dev_t, struct knote *);
d114 1
a114 1
static int tuninit(struct tun_softc *);
d116 1
a116 1
static void tunstart(struct ifnet *);
a744 8
}

/* Does not currently work */

int
tunkqfilter(dev_t dev,struct knote *kn)
{
	return (1);
@


1.40.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.40.2.1 2002/06/11 03:30:45 art Exp $	*/
a154 1
		if_alloc_sadl(ifp);
@


1.40.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * Copyright (c) 1988, Julian Onions <Julian.Onions@@nexor.co.uk>
a6 1
 * All rights reserved.
d8 2
a9 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
a10 13
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
d134 1
a134 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "tun%d", i);
a281 17
#ifdef INET6
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			struct sockaddr_in6 *sin;

			sin = (struct sockaddr_in6 *)ifa->ifa_addr;
			if (!IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
				tp->tun_flags |= TUN_IASET;

			if (ifp->if_flags & IFF_POINTOPOINT) {
				sin = (struct sockaddr_in6 *)ifa->ifa_dstaddr;
				if (sin &&
				    !IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
					tp->tun_flags |= TUN_DSTADDR;
			} else
				tp->tun_flags &= ~TUN_DSTADDR;
		}
#endif /* INET6 */
d360 1
d371 6
d388 1
a388 1
	IFQ_ENQUEUE(&ifp->if_snd, m0, NULL, error);
@


1.39
log
@Add support for SIOCADDMULTI & SIOCDELMULTI; NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.38 2001/08/03 21:13:40 itojun Exp $	*/
d225 1
a225 2
			for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
			     ifa = ifa->ifa_list.tqe_next) {
d256 1
a256 2
	for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
	    ifa = ifa->ifa_list.tqe_next) {
@


1.38
log
@simplify previous fix (0-length mbuf in mbuf chain).  from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.37 2001/08/02 22:30:41 itojun Exp $	*/
d315 23
@


1.37
log
@do not exit loop even if m_len == 0.  it is legal to have an mbuf with
m_len == 0 in mbuf chain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.36 2001/06/27 06:07:46 kjc Exp $	*/
a536 5
		if (m0->m_len == 0) {
			MFREE(m0, m);
			m0 = m;
			continue;
		}
d538 2
a539 3
		if (len == 0)
			break;
		error = uiomove(mtod(m0, caddr_t), len, uio);
@


1.36
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.35 2001/06/15 03:38:34 itojun Exp $	*/
d537 5
@


1.35
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.34 2001/05/16 12:53:34 ho Exp $	*/
d115 3
d138 3
d143 2
a144 1
		ifp->if_snd.ifq_maxlen = ifqmaxlen;
a203 1
	struct mbuf	*m;
d215 3
a217 7
	do {
		s = splimp();
		IF_DEQUEUE(&ifp->if_snd, m);
		splx(s);
		if (m)
			m_freem(m);
	} while (m);
d335 1
a335 1
	int		s;
d337 1
d348 6
d363 1
d365 2
a366 3
	if (IF_QFULL(&ifp->if_snd)) {
		IF_DROP(&ifp->if_snd);
		m_freem(m0);
d369 1
a369 1
		return (ENOBUFS);
d371 1
a371 2
	IF_ENQUEUE(&ifp->if_snd, m0);

d373 1
a373 2
	ifp->if_obytes += m0->m_pkthdr.len + sizeof(*af);
	splx(s);
d520 1
a520 1
		IF_DEQUEUE(&ifp->if_snd, m0);
d726 31
@


1.34
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.33 2001/04/23 13:55:27 art Exp $	*/
a343 2
	ifp->if_lastchange = time;

@


1.33
log
@s = splimp(); ... s = splimp(); ... splx(x); ... splx(s); is a bad idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.32 2001/03/05 04:00:36 angelos Exp $	*/
a124 2
	if (!tunctl)
		return;
@


1.32
log
@TUNSIFMODE ioctl (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.31 2001/02/06 03:32:02 mickey Exp $	*/
a457 1
		s = splimp();
a461 1
		splx(s);
@


1.31
log
@allow configuring number of tunnel ifaces
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.30 2000/12/05 07:22:59 hugh Exp $	*/
d427 19
a445 1
	case FIONBIO:
@


1.30
log
@Change bpfattach() link layer type to DLT_LOOP making pcap generated
bpf filters work on the tun interface. itojun@@ approved.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.29 2000/03/21 23:31:27 mickey Exp $	*/
a17 3
#include "tun.h"
#if NTUN > 0

d81 1
a82 1
	struct	ifnet tun_if;		/* the interface */
d97 2
a98 1
struct tun_softc tunctl[NTUN];
d117 2
a118 2
tunattach(unused)
	int unused;
d123 6
a128 1
	for (i = 0; i < NTUN; i++) {
d172 1
a172 1
	if ((unit = minor(dev)) >= NTUN)
d201 1
a201 1
	if ((unit = minor(dev)) >= NTUN)
d398 1
a398 1
	if ((unit = minor(dev)) >= NTUN)
d479 1
a479 1
	if ((unit = minor(dev)) >= NTUN)
d553 1
a553 1
	if ((unit = minor(dev)) >= NTUN)
d681 1
a681 1
	if ((unit = minor(dev)) >= NTUN)
a706 2

#endif  /* NTUN */
@


1.29
log
@add SIOCGIFMTU/SIOCSIFMTU; remediate redundant code of tun, ppp, sppp; chris@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.28 1999/12/08 06:50:18 itojun Exp $	*/
d147 1
a147 1
		bpfattach(&ifp->if_bpf, ifp, DLT_NULL, sizeof(u_int32_t));
@


1.28
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.27 1999/09/29 04:30:39 deraadt Exp $	*/
a308 1
#if 0
d310 1
a310 4
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
			break;
		((struct tun_softc *)(ifp->if_softc))->tun_if.if_mtu
			= ((struct ifreq *)data)->ifr_mtu;
a311 5
	case SIOCGIFMTU:
		((struct ifreq *)data)->ifr_mtu =
			((struct tun_softc *)(ifp->if_softc))->tun_if.if_mtu;
		break;
#endif
@


1.28.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d309 1
d311 4
a314 1
		ifp->if_mtu = ((struct ifreq *)data)->ifr_mtu;
d316 5
@


1.28.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.32 2001/03/05 04:00:36 angelos Exp $	*/
d18 3
d84 1
a85 1
	u_short	tun_flags;		/* misc flags */
d100 1
a100 2
struct tun_softc *tunctl;
int ntun;
d119 2
a120 2
tunattach(n)
	int n;
d125 1
a125 6
	ntun = n;
	tunctl = malloc(ntun * sizeof(*tunctl), M_DEVBUF, M_WAITOK);
	if (!tunctl)
		return;
	bzero(tunctl, ntun * sizeof(*tunctl));
	for (i = 0; i < ntun; i++) {
d147 1
a147 1
		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d169 1
a169 1
	if ((unit = minor(dev)) >= ntun)
d198 1
a198 1
	if ((unit = minor(dev)) >= ntun)
d395 1
a395 1
	if ((unit = minor(dev)) >= ntun)
d424 1
a424 19
        case TUNSIFMODE:
	        switch (*(int *)data & (IFF_POINTOPOINT|IFF_BROADCAST)) {
                case IFF_POINTOPOINT:
                case IFF_BROADCAST:
                        if (tp->tun_if.if_flags & IFF_UP) {
                                splx(s);
                                return (EBUSY);
                        }
                        tp->tun_if.if_flags &=
                                ~(IFF_BROADCAST|IFF_POINTOPOINT|IFF_MULTICAST);
                        tp->tun_if.if_flags |= *(int *)data;
                        break;
                default:
		        splx(s);
                        return (EINVAL);
                }
                break;

       	case FIONBIO:
d476 1
a476 1
	if ((unit = minor(dev)) >= ntun)
d550 1
a550 1
	if ((unit = minor(dev)) >= ntun)
d678 1
a678 1
	if ((unit = minor(dev)) >= ntun)
d704 2
@


1.28.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.28.2.2 2001/05/14 22:40:02 niklas Exp $	*/
a114 3
#ifdef ALTQ
static void tunstart __P((struct ifnet *));
#endif
d125 2
a136 3
#ifdef ALTQ
		ifp->if_start = tunstart;
#endif
d139 1
a139 2
		IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
		IFQ_SET_READY(&ifp->if_snd);
d199 1
d211 7
a217 3
	s = splimp();
	IFQ_PURGE(&ifp->if_snd);
	splx(s);
d335 1
a335 1
	int		s, len, error;
a336 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
d346 2
a348 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it before prepending link headers.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m0, dst->sa_family, &pktattr);
 
a357 1
	len = m0->m_pkthdr.len + sizeof(*af);
d359 3
a361 2
	IFQ_ENQUEUE(&ifp->if_snd, m0, &pktattr, error);
	if (error) {
d364 1
a364 1
		return (error);
d366 4
a370 2
	ifp->if_opackets++;
	ifp->if_obytes += len;
d458 1
d463 1
d519 1
a519 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
a724 31

#ifdef ALTQ
/*
 * Start packet transmission on the interface.
 * when the interface queue is rate-limited by ALTQ or TBR,
 * if_start is needed to drain packets from the queue in order
 * to notify readers when outgoing packets become ready.
 */
static void
tunstart(ifp)
	struct ifnet *ifp;
{
	struct tun_softc *tp = ifp->if_softc;
	struct mbuf *m;

	if (!ALTQ_IS_ENABLED(&ifp->if_snd) && !TBR_IS_ENABLED(&ifp->if_snd))
		return;

	IFQ_POLL(&ifp->if_snd, m);
	if (m != NULL) {
		if (tp->tun_flags & TUN_RWAIT) {
			tp->tun_flags &= ~TUN_RWAIT;
			wakeup((caddr_t)tp);
		}
		if (tp->tun_flags & TUN_ASYNC && tp->tun_pgid)
			csignal(tp->tun_pgid, SIGIO,
			    tp->tun_siguid, tp->tun_sigeuid);
		selwakeup(&tp->tun_rsel);
	}
}
#endif
@


1.28.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.28.2.3 2001/07/04 10:54:11 niklas Exp $	*/
a314 23
	case SIOCADDMULTI:
	case SIOCDELMULTI: {
		struct ifreq *ifr = (struct ifreq *)data;
		if (ifr == 0) {
			error = EAFNOSUPPORT;	   /* XXX */
			break;
		}
		switch (ifr->ifr_addr.sa_family) {
#ifdef INET
		case AF_INET:
			break;
#endif
#ifdef INET6
		case AF_INET6:
			break;
#endif
		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;
	}

d538 3
a540 2
		if (len != 0)
			error = uiomove(mtod(m0, caddr_t), len, uio);
@


1.28.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d225 2
a226 1
			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
d257 2
a258 1
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
@


1.28.2.6
log
@Merge in -current from roughly a week ago
@
text
@d102 10
a111 10
void	tunattach(int);
int	tunopen(dev_t, int, int, struct proc *);
int	tunclose(dev_t, int, int, struct proc *);
int	tun_ioctl(struct ifnet *, u_long, caddr_t);
int	tun_output(struct ifnet *, struct mbuf *, struct sockaddr *,
		        struct rtentry *rt);
int	tunioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	tunread(dev_t, struct uio *, int);
int	tunwrite(dev_t, struct uio *, int);
int	tunselect(dev_t, int, struct proc *);
d114 1
a114 1
static int tuninit(struct tun_softc *);
d116 1
a116 1
static void tunstart(struct ifnet *);
@


1.28.2.7
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 1
 * Copyright (c) 1988, Julian Onions <Julian.Onions@@nexor.co.uk>
a6 1
 * All rights reserved.
d8 2
a9 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
a10 13
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
a111 1
int	tunkqfilter(dev_t, struct knote *);
a153 1
		if_alloc_sadl(ifp);
d358 1
d369 6
d386 1
a386 1
	IFQ_ENQUEUE(&ifp->if_snd, m0, NULL, error);
a744 8
}

/* Does not currently work */

int
tunkqfilter(dev_t dev,struct knote *kn)
{
	return (1);
@


1.28.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.28.2.7 2003/03/28 00:41:28 niklas Exp $	*/
d154 1
a154 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "tun%d", i);
a301 17
#ifdef INET6
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			struct sockaddr_in6 *sin;

			sin = (struct sockaddr_in6 *)ifa->ifa_addr;
			if (!IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
				tp->tun_flags |= TUN_IASET;

			if (ifp->if_flags & IFF_POINTOPOINT) {
				sin = (struct sockaddr_in6 *)ifa->ifa_dstaddr;
				if (sin &&
				    !IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr))
					tp->tun_flags |= TUN_DSTADDR;
			} else
				tp->tun_flags &= ~TUN_DSTADDR;
		}
#endif /* INET6 */
@


1.28.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a55 1
#include <sys/poll.h>
a107 2
	int	tun_unit;
	LIST_ENTRY(tun_softc) tun_list;	/* all tunnel interfaces */
d117 3
d131 1
a131 1
int	tunpoll(dev_t, int, struct proc *);
d133 1
a133 4
int	tun_clone_create(struct if_clone *, int);
int	tun_clone_destroy(struct ifnet *);
struct	tun_softc *tun_lookup(int);
void	tun_wakeup(struct tun_softc *);
a138 15
int	filt_tunread(struct knote *, long);
int	filt_tunwrite(struct knote *, long);
void	filt_tunrdetach(struct knote *);
void	filt_tunwdetach(struct knote *);

struct filterops tunread_filtops =
	{ 1, NULL, filt_tunrdetach, filt_tunread};

struct filterops tunwrite_filtops =
	{ 1, NULL, filt_tunwdetach, filt_tunwrite};

LIST_HEAD(, tun_softc) tun_softc_list;

struct if_clone tun_cloner =
    IF_CLONE_INITIALIZER("tun", tun_clone_create, tun_clone_destroy);
d144 1
a144 10
	LIST_INIT(&tun_softc_list);
	if_clone_attach(&tun_cloner);
}

int
tun_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
{
	struct tun_softc *tp;
a145 6
	int s;

	tp = malloc(sizeof(*tp), M_DEVBUF, M_NOWAIT);
	if (!tp)
		return (ENOMEM);
	bzero(tp, sizeof(*tp));
d147 12
a158 10
	tp->tun_unit = unit;
	tp->tun_flags = TUN_INITED;

	ifp = &tp->tun_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name, 
	    unit);
	ifp->if_softc = tp;
	ifp->if_mtu = TUNMTU;
	ifp->if_ioctl = tun_ioctl;
	ifp->if_output = tun_output;
d160 1
a160 1
	ifp->if_start = tunstart;
d162 14
a175 14
	ifp->if_flags = IFF_POINTOPOINT;
	ifp->if_type  = IFT_PROPVIRTUAL;
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
	IFQ_SET_READY(&ifp->if_snd);
	ifp->if_hdrlen = sizeof(u_int32_t);
	ifp->if_collisions = 0;
	ifp->if_ierrors = 0;
	ifp->if_oerrors = 0;
	ifp->if_ipackets = 0;
	ifp->if_opackets = 0;
	ifp->if_ibytes = 0;
	ifp->if_obytes = 0;
	if_attach(ifp);
	if_alloc_sadl(ifp);
d177 1
a177 1
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d179 1
a179 43
	s = splimp();
	LIST_INSERT_HEAD(&tun_softc_list, tp, tun_list);
	splx(s);

	return (0);
}

int
tun_clone_destroy(ifp)
	struct ifnet *ifp;
{
	struct tun_softc *tp = ifp->if_softc;
	int s;

	s = splhigh();
	klist_invalidate(&tp->tun_rsel.si_note);
	klist_invalidate(&tp->tun_wsel.si_note);
	splx(s);

	s = splimp();
	LIST_REMOVE(tp, tun_list);
	splx(s);

	tun_wakeup(tp);
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
	if_detach(ifp);

	free(tp, M_DEVBUF);
	return (0);
}

struct tun_softc *
tun_lookup(unit)
	int unit;
{
	struct tun_softc *tp;

	LIST_FOREACH(tp, &tun_softc_list, tun_list)
		if (tp->tun_unit == unit)
			return (tp);
	return (NULL);
d194 1
a194 1
	int error;
d196 1
a196 1
	if ((error = suser(p, 0)) != 0)
d199 2
a200 7
	if ((tp = tun_lookup(minor(dev))) == NULL) {
		/* create on demand */
                (void) tun_clone_create(&tun_cloner, minor(dev));

		if ((tp = tun_lookup(minor(dev))) == NULL)
			return (ENXIO);
	}
d202 1
d223 1
a223 1
	int	s;
d227 1
a227 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d230 1
d246 1
a246 1
			struct ifaddr *ifa;
a260 1
	KNOTE(&tp->tun_rsel.si_note, 0);
d271 1
a271 1
	struct ifaddr *ifa;
a427 8
	tun_wakeup(tp);
	return 0;
}

void
tun_wakeup(tp)
	struct tun_softc *tp;
{
d436 1
a436 1
	KNOTE(&tp->tun_rsel.si_note, 0);
d450 1
a450 1
	int		s;
a452 1
	struct mbuf *m;
d454 1
a454 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d457 2
d514 2
a515 3
		IFQ_POLL(&tp->tun_if.if_snd, m);
		if (m != NULL)
			*(int *)data = m->m_pkthdr.len;
d545 1
d551 1
a551 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d554 1
d616 1
a616 1
	struct tun_softc *tp;
d624 1
a624 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d627 1
a627 1
	ifp = &tp->tun_if;
d743 1
a743 1
tunpoll(dev, events, p)
d745 1
a745 1
	int		events;
d748 1
a748 1
	int		revents, s;
a750 1
	struct mbuf	*m;
d752 1
a752 1
	if ((tp = tun_lookup(minor(dev))) == NULL)
d755 1
a756 1
	revents = 0;
d758 1
a758 1
	TUNDEBUG(("%s: tunpoll\n", ifp->if_xname));
d760 4
a763 3
	if (events & (POLLIN | POLLRDNORM)) {
		IFQ_POLL(&ifp->if_snd, m);
		if (m != NULL) {
d766 1
a766 4
			revents |= events & (POLLIN | POLLRDNORM);
		} else {
			TUNDEBUG(("%s: tunpoll waiting\n", ifp->if_xname));
			selrecord(p, &tp->tun_rsel);
d768 3
a770 86
	}
	if (events & (POLLOUT | POLLWRNORM))
		revents |= events & (POLLOUT | POLLWRNORM);
	splx(s);
	return (revents);
}

/*
 * kqueue(2) support.
 *
 * The tun driver uses an array of tun_softc's based on the minor number
 * of the device.  kn->kn_hook gets set to the specific tun_softc.
 *
 * filt_tunread() sets kn->kn_data to the iface qsize
 * filt_tunwrite() sets kn->kn_data to the MTU size
 */
int
tunkqfilter(dev_t dev,struct knote *kn)
{
	int s;
	struct klist *klist;
	struct tun_softc *tp;
	struct ifnet *ifp;

	if ((tp = tun_lookup(minor(dev))) == NULL)
		return (ENXIO);

	ifp = &tp->tun_if;

	s = splimp();
	TUNDEBUG(("%s: tunselect\n", ifp->if_xname));
	splx(s);

	switch (kn->kn_filter) {
		case EVFILT_READ:
			klist = &tp->tun_rsel.si_note;
			kn->kn_fop = &tunread_filtops;
			break;
		case EVFILT_WRITE:
			klist = &tp->tun_wsel.si_note;
			kn->kn_fop = &tunwrite_filtops;
			break;
		default:
			return EPERM;	/* 1 */
	}

	kn->kn_hook = (caddr_t)tp;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return 0;
}

void
filt_tunrdetach(struct knote *kn)
{
	int s;
	struct tun_softc *tp = (struct tun_softc *)kn->kn_hook;

	s = splhigh();
	if (!(kn->kn_status & KN_DETACHED))
		SLIST_REMOVE(&tp->tun_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_tunread(struct knote *kn, long hint)
{
	int s;
	struct tun_softc *tp;
	struct ifnet *ifp;
	struct mbuf *m;

	if (kn->kn_status & KN_DETACHED) {
		kn->kn_data = 0;
		return 1;
	}

	tp = (struct tun_softc *)kn->kn_hook;
	ifp = &tp->tun_if;

	s = splnet();
	IFQ_POLL(&ifp->if_snd, m);
	if (m != NULL) {
a771 4
		kn->kn_data = ifp->if_snd.ifq_len;

		TUNDEBUG(("%s: tunkqread q=%d\n", ifp->if_xname,
					ifp->if_snd.ifq_len));
d775 1
a775 1
	TUNDEBUG(("%s: tunkqread waiting\n", ifp->if_xname));
d779 1
a779 11
void
filt_tunwdetach(struct knote *kn)
{
	int s;
	struct tun_softc *tp = (struct tun_softc *)kn->kn_hook;

	s = splhigh();
	if (!(kn->kn_status & KN_DETACHED))
		SLIST_REMOVE(&tp->tun_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}
d782 1
a782 1
filt_tunwrite(struct knote *kn, long hint)
d784 1
a784 14
	struct tun_softc *tp;
	struct ifnet *ifp;

	if (kn->kn_status & KN_DETACHED) {
		kn->kn_data = 0;
		return 1;
	}

	tp = (struct tun_softc *)kn->kn_hook;
	ifp = &tp->tun_if;

	kn->kn_data = ifp->if_mtu;

	return 1;
d805 10
a814 2
	if (m != NULL)
		tun_wakeup(tp);
@


1.28.2.10
log
@Merge with the trunk
@
text
@d732 1
a732 1
		if (error == 0 && uio->uio_resid > 0) {
a809 2
		if (!ifq->ifq_congestion)
			if_congestion(ifq);
@


1.27
log
@fix byte counters; imain@@netidea.com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.26 1999/07/24 03:18:32 brian Exp $	*/
d224 1
d230 1
d256 1
d278 1
d321 2
d619 6
@


1.26
log
@Return EMSGSIZE for zero length writes - don't panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.25 1999/04/22 20:02:44 art Exp $	*/
d143 2
a366 1
	splx(s);
d370 1
d655 1
a655 1
	ifp->if_ibytes += m->m_pkthdr.len;
@


1.25
log
@we don't need to include buf.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.24 1998/08/02 07:17:43 brian Exp $	*/
d557 1
a557 1
	if (uio->uio_resid < 0 || uio->uio_resid > TUNMRU) {
@


1.24
log
@#define TUNMRU as 16384 and allow incoming packets
of up to this size rather than restricting them based
on our MTU.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.23 1998/06/26 09:14:39 deraadt Exp $	*/
a27 1
#include <sys/buf.h>
@


1.23
log
@convert DLT_LOOP header to network-order u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.22 1997/12/31 06:30:30 deraadt Exp $	*/
d558 1
a558 1
	if (uio->uio_resid < 0 || uio->uio_resid > ifp->if_mtu) {
@


1.22
log
@return error instead of EINTR; brian
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.21 1997/12/31 01:22:55 deraadt Exp $	*/
d138 1
a138 1
		ifp->if_hdrlen = sizeof(struct tunnel_header);
d146 1
a146 2
		bpfattach(&ifp->if_bpf, ifp, DLT_NULL,
		    sizeof(struct tunnel_header));
a333 1
	struct tunnel_header *th;
d335 1
d347 4
a350 3
	M_PREPEND(m0, sizeof(struct tunnel_header), M_DONTWAIT);
	th = mtod(m0, struct tunnel_header *);
	th->tun_af = dst->sa_family;
d369 1
a369 1
	ifp->if_obytes += m0->m_pkthdr.len + sizeof(struct tunnel_header);
d547 1
a547 1
	struct tunnel_header *th;
d601 1
a601 1
	th = mtod(top, struct tunnel_header *);
d607 1
a607 1
	switch (th->tun_af) {
@


1.21
log
@two missing splx(); one from brian, one from me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.20 1997/08/31 20:42:32 deraadt Exp $	*/
d495 2
a496 2
			if (tsleep((caddr_t)tp, (PZERO+1)|PCATCH,
			    "tunread", 0) != 0) {
d498 1
a498 1
				return(EINTR);
d507 2
a508 2
			if (tsleep((caddr_t)tp, (PZERO + 1)|PCATCH,
			    "tunread", 0) != 0) {
d510 1
a510 1
				return EINTR;
@


1.20
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.19 1997/07/29 07:18:20 deraadt Exp $	*/
d495 3
a497 1
			if (tsleep((caddr_t)tp, (PZERO+1)|PCATCH, "tunread", 0) != 0)
d499 1
a499 1

d507 3
a509 1
			if (tsleep((caddr_t)tp, (PZERO + 1)|PCATCH, "tunread", 0) != 0)
d511 1
@


1.19
log
@tun_bpf not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.18 1997/07/29 05:53:22 deraadt Exp $	*/
d87 3
a89 1
	int	tun_pgrp;		/* the process group - if any */
d233 1
a233 1
	tp->tun_pgrp = 0;
a335 1
	struct proc	*p;
d375 3
a377 6
	if (tp->tun_flags & TUN_ASYNC && tp->tun_pgrp) {
		if (tp->tun_pgrp > 0)
			gsignal(tp->tun_pgrp, SIGIO);
		else if ((p = pfind(-tp->tun_pgrp)) != NULL)
			psignal(p, SIGIO);
	}
d447 3
a449 1
		tp->tun_pgrp = *(int *)data;
d452 1
a452 1
		*(int *)data = tp->tun_pgrp;
@


1.18
log
@tell bpf packet header is u_char sized; also indent. spotted by newsham
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.17 1997/07/24 22:03:15 deraadt Exp $	*/
a89 3
#if NBPFILTER > 0
	caddr_t		tun_bpf;
#endif
@


1.17
log
@reindent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.16 1997/07/23 20:50:14 mickey Exp $	*/
d147 2
a148 1
		bpfattach(&ifp->if_bpf, ifp, DLT_NULL, sizeof(u_int32_t));
d336 1
d350 3
a352 5
	M_PREPEND( m0, sizeof(struct tunnel_header), M_DONTWAIT );
	{
		struct tunnel_header	*th = mtod( m0, struct tunnel_header * );
		th->tun_af = dst->sa_family;
	}
d545 1
a545 1
	struct tunnel_header	*th;
d599 2
a600 2
	th = mtod( top, struct tunnel_header * );
		/* strip the tunnel header */
d605 1
a605 2
	switch( th->tun_af )
	{
d642 2
a643 3
	if( IF_QFULL(ifq) )
	{
		IF_DROP( ifq );
d649 2
a650 2
	IF_ENQUEUE( ifq, top );
	schednetisr( isr );
@


1.16
log
@add atalk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.15 1997/02/14 18:15:28 deraadt Exp $	*/
d400 1
a400 1
 	struct tuninfo *tunp;
d409 1
a409 1
 	case TUNSIFINFO:
d411 12
a422 12
 		tp->tun_if.if_mtu = tunp->mtu;
 		tp->tun_if.if_type = tunp->type;
 		tp->tun_if.if_flags = tunp->flags;
 		tp->tun_if.if_baudrate = tunp->baudrate;
 		break;
 	case TUNGIFINFO:
 		tunp = (struct tuninfo *)data;
 		tunp->mtu = tp->tun_if.if_mtu;
 		tunp->type = tp->tun_if.if_type;
 		tunp->flags = tp->tun_if.if_flags;
 		tunp->baudrate = tp->tun_if.if_baudrate;
 		break;
@


1.15
log
@limit writes to ifp->if_mtu not TUNMTU
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.14 1996/06/17 11:06:18 deraadt Exp $	*/
d67 5
d623 6
@


1.14
log
@bad splx, bad bad bad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.13 1996/06/02 17:24:58 niklas Exp $	*/
d551 1
a551 1
	if (uio->uio_resid < 0 || uio->uio_resid > TUNMTU) {
@


1.13
log
@Fix accident in last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.12 1996/06/02 16:27:44 niklas Exp $	*/
a627 1
		splx(s);
@


1.12
log
@shut up GCC -Wall about /* inside a comment
@
text
@d1 1
a1 1
o/*	$OpenBSD: if_tun.c,v 1.11 1996/05/27 07:57:59 deraadt Exp $	*/
@


1.11
log
@if_name -> if_xname
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.10 1996/05/16 11:52:08 mickey Exp $	*/
d21 1
a21 1
/* #define	TUN_DEBUG	9 /* */
@


1.10
log
@drom NetBSD PR#2411:
add bcast support, do if_flags setable, minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.7 1996/04/24 06:26:47 mickey Exp $	*/
d294 1
a294 1
		TUNDEBUG(("%s: destination address set\n", ifp->if_name));
d298 1
a298 1
		TUNDEBUG(("%s: broadcast address set\n", ifp->if_name));
@


1.9
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d79 11
a134 1
		ifp->if_addrlen = 0;
d157 1
a158 1
	struct tun_softc *tp;
d166 1
d169 2
a170 1
		return ENXIO;
d178 2
a179 2
 * tunclose - close the device - mark i/f down & delete
 * routing info
d188 3
a190 3
	register int	unit = minor(dev), s;
	struct tun_softc *tp = &tunctl[unit];
	struct ifnet	*ifp = &tp->tun_if;
d193 5
d211 1
a211 1
	if (ifp->if_flags & IFF_UP) {
d218 1
a218 1
				 ifa = ifa->ifa_list.tqe_next) {
d221 2
a222 1
					    tp->tun_flags & TUN_DSTADDR ? RTF_HOST : 0);
d246 1
d256 13
a268 3
			sin = satosin(ifa->ifa_dstaddr);
			if (sin && sin->sin_addr.s_addr)
				tp->tun_flags |= TUN_DSTADDR;
d284 1
a284 1
	int		error = 0, s;
d296 16
d393 2
a394 2
	int		unit = minor(dev), s;
	struct tun_softc *tp = &tunctl[unit];
d397 6
d405 1
a405 1
        tunp = (struct tuninfo *)data;
d408 1
d415 1
d453 1
d456 1
d470 3
a472 3
	int		unit = minor(dev);
	struct tun_softc *tp = &tunctl[unit];
	struct ifnet	*ifp = &tp->tun_if;
d474 4
a477 1
	int		error=0, len, s;
d479 2
d492 4
d503 2
a504 1
			tsleep((caddr_t)tp, PZERO + 1, "tunread", 0);
d537 2
a538 2
	int		unit = minor (dev);
	struct ifnet	*ifp = &tunctl[unit].tun_if;
d545 4
d553 1
a553 1
		return EIO;
d660 6
a665 3
	int		unit = minor(dev), s;
	struct tun_softc *tp = &tunctl[unit];
	struct ifnet	*ifp = &tp->tun_if;
d667 2
d677 1
a677 1
			    ifp->if_snd.ifq_len));
@


1.8
log
@sorry, folks. cut&paste bug happened.
@
text
@d2 1
a2 1
/*	$NetBSD: if_tun.c,v 1.22 1996/02/13 22:00:26 christos Exp $	*/
d102 1
a102 1
static int tuninit __P((int));
d115 2
a116 2
		ifp->if_unit = i;
		ifp->if_name = "tun";
d161 1
a161 1
	TUNDEBUG(("%s%d: open\n", ifp->if_name, ifp->if_unit));
d213 1
a213 1
	TUNDEBUG(("%s%d: closed\n", ifp->if_name, ifp->if_unit));
d218 2
a219 2
tuninit(unit)
	int	unit;
a220 1
	struct tun_softc *tp = &tunctl[unit];
d224 1
a224 1
	TUNDEBUG(("%s%d: tuninit\n", ifp->if_name, ifp->if_unit));
d260 2
a261 2
		tuninit(ifp->if_unit);
		TUNDEBUG(("%s%d: address set\n", ifp->if_name, ifp->if_unit));
d264 2
a265 3
		tuninit(ifp->if_unit);
		TUNDEBUG(("%s%d: destination address set\n",
			 ifp->if_name, ifp->if_unit));
d284 1
a284 1
	struct tun_softc *tp = &tunctl[ifp->if_unit];
d288 1
a288 1
	TUNDEBUG(("%s%d: tun_output\n", ifp->if_name, ifp->if_unit));
d291 2
a292 2
		TUNDEBUG(("%s%d: not ready 0%o\n", ifp->if_name,
			  ifp->if_unit, tp->tun_flags));
d421 1
a421 1
	TUNDEBUG(("%s%d: read\n", ifp->if_name, ifp->if_unit));
d423 2
a424 2
		TUNDEBUG(("%s%d: not ready 0%o\n", ifp->if_name,
			  ifp->if_unit, tp->tun_flags));
d480 1
a480 1
	TUNDEBUG(("%s%d: tunwrite\n", ifp->if_name, ifp->if_unit));
d483 1
a483 2
		TUNDEBUG(("%s%d: len=%d!\n", ifp->if_name, ifp->if_unit,
		    uio->uio_resid));
d596 1
a596 1
	TUNDEBUG(("%s%d: tunselect\n", ifp->if_name, ifp->if_unit));
d602 2
a603 2
			TUNDEBUG(("%s%d: tunselect q=%d\n", ifp->if_name,
			    ifp->if_unit, ifp->if_snd.ifq_len));
d613 1
a613 1
	TUNDEBUG(("%s%d: tunselect waiting\n", ifp->if_name, ifp->if_unit));
@


1.7
log
@Add IPX support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.6 1996/04/21 22:28:35 deraadt Exp $	*/
a547 1
#ifdef ISO
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tun.c,v 1.5 1996/03/03 21:07:11 niklas Exp $	*/
d62 5
d546 7
@


1.5
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a72 1
#include <net/net_conf.h>
@


1.4
log
@fixed bug in debugging code, so it'll compiles now w/o TUN_DEBUG
enabled.
@
text
@d1 2
a2 1
/*	$OpenBSD: if_tun.c,v 1.19 1995/12/13 23:47:40 pk Exp $	*/
d12 1
a12 1
 * user process to have it's wicked way with. This driver has it's
a37 1
#include <sys/conf.h>
d39 1
d72 1
d85 11
a95 10
int		tunopen		__P((dev_t, int, int, struct proc *));
int		tunclose	__P((dev_t, int, int, struct proc *));
int		tunoutput	__P((struct ifnet *, struct mbuf *, struct sockaddr *,
					struct rtentry *rt));
int		tunread		__P((dev_t, struct uio *, int));
int		tunwrite	__P((dev_t, struct uio *, int));
int		tunioctl	__P((dev_t, u_long, caddr_t, int, struct proc *));
int		tunifioctl	__P((struct ifnet *, u_long, caddr_t));
int		tunselect	__P((dev_t, int, struct proc *));
void	tunattach	__P((int));
a104 1
	struct sockaddr_in *sin;
d113 2
a114 2
		ifp->if_ioctl = tunifioctl;
		ifp->if_output = tunoutput;
d146 1
a146 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d167 2
a168 1
	int		flag,mode;
d246 1
a246 1
tunifioctl(ifp, cmd, data)
a250 1
	struct tun_softc *tp = &tunctl[ifp->if_unit];
d272 1
a272 1
 * tunoutput - queue packets from higher level ready to put out.
d275 1
a275 1
tunoutput(ifp, m0, dst, rt)
d285 1
a285 1
	TUNDEBUG(("%s%d: tunoutput\n", ifp->if_name, ifp->if_unit));
d327 1
a327 1
		else if (p = pfind(-tp->tun_pgrp))
d407 1
a407 1
tunread(dev, uio,flags)
d410 1
a410 1
	int			flags;
d431 1
a431 1
			if (tp->tun_flags & TUN_NBIO && flags & IO_NDELAY) {
d464 1
a464 1
tunwrite(dev, uio, flags)
d467 1
a467 1
	int			flags;
d579 1
a579 1
	dev_t	dev;
d581 1
a581 1
	struct proc *p;
@


1.3
log
@bug fixes, speedups. multiple AFs support.
bpf fixes.
@
text
@a72 1
#define TUNDEBUG	if (tundebug) printf
d74 3
d154 1
a154 1
	TUNDEBUG("%s%d: open\n", ifp->if_name, ifp->if_unit);
d205 1
a205 1
	TUNDEBUG ("%s%d: closed\n", ifp->if_name, ifp->if_unit);
d217 1
a217 1
	TUNDEBUG("%s%d: tuninit\n", ifp->if_name, ifp->if_unit);
d255 1
a255 2
		TUNDEBUG("%s%d: address set\n",
			 ifp->if_name, ifp->if_unit);
d259 2
a260 2
		TUNDEBUG("%s%d: destination address set\n",
			 ifp->if_name, ifp->if_unit);
d283 1
a283 1
	TUNDEBUG ("%s%d: tunoutput\n", ifp->if_name, ifp->if_unit);
d286 2
a287 2
		TUNDEBUG ("%s%d: not ready 0%o\n", ifp->if_name,
			  ifp->if_unit, tp->tun_flags);
d416 1
a416 1
	TUNDEBUG ("%s%d: read\n", ifp->if_name, ifp->if_unit);
d418 2
a419 2
		TUNDEBUG ("%s%d: not ready 0%o\n", ifp->if_name,
			  ifp->if_unit, tp->tun_flags);
d449 1
a449 1
		TUNDEBUG("Dropping mbuf\n");
d475 1
a475 1
	TUNDEBUG("%s%d: tunwrite\n", ifp->if_name, ifp->if_unit);
d478 2
a479 2
		TUNDEBUG("%s%d: len=%d!\n", ifp->if_name, ifp->if_unit,
		    uio->uio_resid);
d586 1
a586 1
	TUNDEBUG("%s%d: tunselect\n", ifp->if_name, ifp->if_unit);
d592 2
a593 2
			TUNDEBUG("%s%d: tunselect q=%d\n", ifp->if_name,
			    ifp->if_unit, ifp->if_snd.ifq_len);
d603 1
a603 1
	TUNDEBUG("%s%d: tunselect waiting\n", ifp->if_name, ifp->if_unit);
@


1.2
log
@use m_pkthdr.len for FIONREAD, correctly indicates how much data is available
@
text
@d1 1
a1 1
/*	$NetBSD: if_tun.c,v 1.19 1995/12/13 23:47:40 pk Exp $	*/
d20 2
d23 1
d35 4
d43 1
d52 1
a52 1
#include <netinet/if_ether.h>
d60 5
a66 1
#include <sys/time.h>
d72 1
d74 2
a75 1
int	tundebug = 0;
d78 1
d81 10
a90 10
int	tunopen __P((dev_t, int, int, struct proc *));
int	tunclose __P((dev_t, int));
int	tunoutput __P((struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *rt));
int	tunread __P((dev_t, struct uio *));
int	tunwrite __P((dev_t, struct uio *));
int	tuncioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	tunioctl __P((struct ifnet *, u_long, caddr_t));
int	tunselect __P((dev_t, int));
void	tunattach __P((int));
d109 1
a109 1
		ifp->if_ioctl = tunioctl;
d112 1
d114 2
d123 1
a123 1
		bpfattach(&tunctl[i].tun_bpf, ifp, DLT_NULL, sizeof(u_int32_t));
d161 1
a161 1
tunclose(dev, flag)
d163 2
a164 1
	int	flag;
d191 1
a191 1
			    ifa = ifa->ifa_list.tqe_next) {
d241 1
a241 1
tunioctl(ifp, cmd, data)
d290 7
d299 2
a300 17
	if (tp->tun_bpf) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer to it).
		 */
		struct mbuf m;
		u_int32_t af = dst->sa_family;

		m.m_next = m0;
		m.m_len = sizeof(af);
		m.m_data = (char *)&af;

		bpf_mtap(tp->tun_bpf, &m);
	}
d303 4
a306 12
	switch(dst->sa_family) {
#ifdef INET
	case AF_INET:
		s = splimp();
		if (IF_QFULL(&ifp->if_snd)) {
			IF_DROP(&ifp->if_snd);
			m_freem(m0);
			splx(s);
			ifp->if_collisions++;
			return (ENOBUFS);
		}
		IF_ENQUEUE(&ifp->if_snd, m0);
d308 2
a309 6
		ifp->if_opackets++;
		break;
#endif
	default:
		m_freem(m0);
		return EAFNOSUPPORT;
d311 5
d335 1
a335 1
tuncioctl(dev, cmd, data, flag, p)
d344 1
d347 13
d366 1
d404 1
a404 1
tunread(dev, uio)
d407 1
d428 1
a428 1
			if (tp->tun_flags & TUN_NBIO) {
d453 1
d461 1
a461 1
tunwrite(dev, uio)
d464 1
d468 2
d471 1
d516 9
a524 14
	if (tunctl[unit].tun_bpf) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer to it).
		 */
		struct mbuf m;
		u_int32_t af = AF_INET;

		m.m_next = top;
		m.m_len = sizeof(af);
		m.m_data = (char *)&af;
d526 24
a549 1
		bpf_mtap(tunctl[unit].tun_bpf, &m);
a550 1
#endif
d553 3
a555 2
	if (IF_QFULL (&ipintrq)) {
		IF_DROP(&ipintrq);
d561 4
a564 1
	IF_ENQUEUE(&ipintrq, top);
a565 2
	ifp->if_ipackets++;
	schednetisr(NETISR_IP);
d575 2
a576 2
tunselect(dev, rw)
	dev_t		dev;
d578 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_tun.c,v 1.18 1995/06/13 05:59:37 mycroft Exp $	*/
d363 1
a363 1
			*(int *)data = tp->tun_if.if_snd.ifq_head->m_len;
d431 2
d483 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
