head	1.39;
access;
symbols
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.26.0.8
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.6
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.10.0.10
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	SMP:1.9.0.2
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.39
date	2016.11.22.19.29.54;	author procter;	state Exp;
branches;
next	1.38;
commitid	Wwno1dT3ILCyVgb1;

1.38
date	2016.10.26.21.07.22;	author bluhm;	state Exp;
branches;
next	1.37;
commitid	aaKAr0kv3QWNHoVo;

1.37
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.36;
commitid	RlO92XR575sygHqm;

1.36
date	2016.09.02.11.43.53;	author dlg;	state Exp;
branches;
next	1.35;
commitid	84ilr4xAVgBSd8KA;

1.35
date	2016.09.02.10.19.49;	author dlg;	state Exp;
branches;
next	1.34;
commitid	BjJg5d9vjutHaOpJ;

1.34
date	2016.07.19.13.34.12;	author henning;	state Exp;
branches;
next	1.33;
commitid	7irX13ju2Ijz6e6m;

1.33
date	2016.04.04.16.26.00;	author sthen;	state Exp;
branches;
next	1.32;
commitid	NOQPmnaJyaxPCccu;

1.32
date	2015.09.04.21.40.25;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	9bdTRxc2FCD8lXug;

1.31
date	2015.07.18.19.19.00;	author sashan;	state Exp;
branches;
next	1.30;
commitid	JLCIxhdc71KA1Osw;

1.30
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.29;
commitid	STtcOm1B3VSMXz2h;

1.29
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.28;
commitid	DQakU8LLWV6Iwx84;

1.28
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2011.09.28.17.15.45;	author bluhm;	state Exp;
branches;
next	1.25;

1.25
date	2011.09.22.14.57.12;	author bluhm;	state Exp;
branches;
next	1.24;

1.24
date	2011.09.21.19.07.30;	author bluhm;	state Exp;
branches;
next	1.23;

1.23
date	2011.09.20.15.17.26;	author bluhm;	state Exp;
branches;
next	1.22;

1.22
date	2011.09.19.12.51.52;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.18.15.55.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.10.17.12.14.28;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.04.09.13.05;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.13.12.56.06;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.09.20.58.06;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.14.02.22.13;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.12.18.17.01;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.01.18.49.27;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.13.18.14.10;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.13.05.10.15;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.09.19.30.41;	author frantzen;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.04.20.08.42;	author pvalchev;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2004.01.04.06.57.48;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.03.14.51.02;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.19.20.09.01;	author dhartmei;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.18.16.07.38;	author dhartmei;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.27.18.23.36;	author frantzen;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.27.16.13.21;	author frantzen;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.21.19.12.08;	author frantzen;	state Exp;
branches;
next	;

1.9.2.1
date	2004.02.19.10.57.22;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2004.06.05.23.11.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Fold union pf_headers buffer into struct pf_pdesc (enabled by pfvar_priv.h).
Prevent pf_socket_lookup() reading uninitialised header buffers on fragments.
OK blum@@ sashan@@
@
text
@/*	$OpenBSD: pf_osfp.c,v 1.38 2016/10/26 21:07:22 bluhm Exp $ */

/*
 * Copyright (c) 2003 Mike Frantzen <frantzen@@w4g.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#include <sys/param.h>
#include <sys/socket.h>
#ifdef _KERNEL
#include <sys/systm.h>
#include <sys/pool.h>
#endif /* _KERNEL */
#include <sys/queue.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#endif /* INET6 */

#include <net/pfvar.h>
#include <net/pfvar_priv.h>

#ifdef _KERNEL
typedef struct pool pool_t;

#else	/* !_KERNEL */
/* Userland equivalents so we can lend code to tcpdump et al. */

#include <arpa/inet.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#define pool_t			int
#define pool_get(pool, flags)	malloc(*(pool))
#define pool_put(pool, item)	free(item)
#define pool_init(pool, size, a, ao, f, m, p)	(*(pool)) = (size)

#ifdef PFDEBUG
#include <sys/stdarg.h>	/* for DPFPRINTF() */
#endif /* PFDEBUG */

#endif /* _KERNEL */

SLIST_HEAD(pf_osfp_list, pf_os_fingerprint) pf_osfp_list;
pool_t pf_osfp_entry_pl;
pool_t pf_osfp_pl;

struct pf_os_fingerprint	*pf_osfp_find(struct pf_osfp_list *,
				    struct pf_os_fingerprint *, u_int8_t);
struct pf_os_fingerprint	*pf_osfp_find_exact(struct pf_osfp_list *,
				    struct pf_os_fingerprint *);
void				 pf_osfp_insert(struct pf_osfp_list *,
				    struct pf_os_fingerprint *);


#ifdef _KERNEL
/*
 * Passively fingerprint the OS of the host (IPv4 TCP SYN packets only)
 * Returns the list of possible OSes.
 */
struct pf_osfp_enlist *
pf_osfp_fingerprint(struct pf_pdesc *pd)
{
	struct tcphdr	*th = &pd->hdr.tcp;
	struct ip	*ip = NULL;
	struct ip6_hdr	*ip6 = NULL;
	char		 hdr[60];

	if (pd->proto != IPPROTO_TCP)
		return (NULL);

	switch (pd->af) {
	case AF_INET:
		ip = mtod(pd->m, struct ip *);
		break;
	case AF_INET6:
		ip6 = mtod(pd->m, struct ip6_hdr *);
		break;
	}
	if (!pf_pull_hdr(pd->m, pd->off, hdr, th->th_off << 2, NULL, NULL,
	    pd->af))
		return (NULL);

	return (pf_osfp_fingerprint_hdr(ip, ip6, (struct tcphdr *)hdr));
}
#endif /* _KERNEL */

struct pf_osfp_enlist *
pf_osfp_fingerprint_hdr(const struct ip *ip, const struct ip6_hdr *ip6,
    const struct tcphdr *tcp)
{
	struct pf_os_fingerprint fp, *fpresult;
	int cnt, optlen = 0;
	const u_int8_t *optp;
#ifdef _KERNEL
	char srcname[128];
#else	/* !_KERNEL */
	char srcname[NI_MAXHOST];
#endif	/* _KERNEL */

	if ((tcp->th_flags & (TH_SYN|TH_ACK)) != TH_SYN)
		return (NULL);
	if (ip) {
		if ((ip->ip_off & htons(IP_OFFMASK)) != 0)
			return (NULL);
	}

	memset(&fp, 0, sizeof(fp));

	if (ip) {
#ifndef _KERNEL
		struct sockaddr_in sin;
#endif	/* _KERNEL */

		fp.fp_psize = ntohs(ip->ip_len);
		fp.fp_ttl = ip->ip_ttl;
		if (ip->ip_off & htons(IP_DF))
			fp.fp_flags |= PF_OSFP_DF;
#ifdef _KERNEL
		inet_ntop(AF_INET, &ip->ip_src, srcname, sizeof(srcname));
#else	/* !_KERNEL */
		memset(&sin, 0, sizeof(sin));
		sin.sin_family = AF_INET;
		sin.sin_len = sizeof(struct sockaddr_in);
		sin.sin_addr = ip->ip_src;
		(void)getnameinfo((struct sockaddr *)&sin,
		    sizeof(struct sockaddr_in), srcname, sizeof(srcname),
		    NULL, 0, NI_NUMERICHOST);
#endif	/* _KERNEL */
	}
#ifdef INET6
	else if (ip6) {
#ifndef _KERNEL
		struct sockaddr_in6 sin6;
#endif	/* !_KERNEL */

		/* jumbo payload? */
		fp.fp_psize = sizeof(struct ip6_hdr) + ntohs(ip6->ip6_plen);
		fp.fp_ttl = ip6->ip6_hlim;
		fp.fp_flags |= PF_OSFP_DF;
		fp.fp_flags |= PF_OSFP_INET6;
#ifdef _KERNEL
		inet_ntop(AF_INET6, &ip6->ip6_src, srcname, sizeof(srcname));
#else	/* !_KERNEL */
		memset(&sin6, 0, sizeof(sin6));
		sin6.sin6_family = AF_INET6;
		sin6.sin6_len = sizeof(struct sockaddr_in6);
		sin6.sin6_addr = ip6->ip6_src;
		(void)getnameinfo((struct sockaddr *)&sin6,
		    sizeof(struct sockaddr_in6), srcname, sizeof(srcname),
		    NULL, 0, NI_NUMERICHOST);
#endif	/* !_KERNEL */
	}
#endif	/* INET6 */
	else
		return (NULL);
	fp.fp_wsize = ntohs(tcp->th_win);


	cnt = (tcp->th_off << 2) - sizeof(*tcp);
	optp = (const u_int8_t *)((const char *)tcp + sizeof(*tcp));
	for (; cnt > 0; cnt -= optlen, optp += optlen) {
		if (*optp == TCPOPT_EOL)
			break;

		fp.fp_optcnt++;
		if (*optp == TCPOPT_NOP) {
			fp.fp_tcpopts = (fp.fp_tcpopts << PF_OSFP_TCPOPT_BITS) |
			    PF_OSFP_TCPOPT_NOP;
			optlen = 1;
		} else {
			if (cnt < 2)
				return (NULL);
			optlen = optp[1];
			if (optlen > cnt || optlen < 2)
				return (NULL);
			switch (*optp) {
			case TCPOPT_MAXSEG:
				if (optlen >= TCPOLEN_MAXSEG)
					memcpy(&fp.fp_mss, &optp[2],
					    sizeof(fp.fp_mss));
				fp.fp_tcpopts = (fp.fp_tcpopts <<
				    PF_OSFP_TCPOPT_BITS) | PF_OSFP_TCPOPT_MSS;
				fp.fp_mss = ntohs(fp.fp_mss);
				break;
			case TCPOPT_WINDOW:
				if (optlen >= TCPOLEN_WINDOW)
					memcpy(&fp.fp_wscale, &optp[2],
					    sizeof(fp.fp_wscale));
				fp.fp_tcpopts = (fp.fp_tcpopts <<
				    PF_OSFP_TCPOPT_BITS) |
				    PF_OSFP_TCPOPT_WSCALE;
				break;
			case TCPOPT_SACK_PERMITTED:
				fp.fp_tcpopts = (fp.fp_tcpopts <<
				    PF_OSFP_TCPOPT_BITS) | PF_OSFP_TCPOPT_SACK;
				break;
			case TCPOPT_TIMESTAMP:
				if (optlen >= TCPOLEN_TIMESTAMP) {
					u_int32_t ts;
					memcpy(&ts, &optp[2], sizeof(ts));
					if (ts == 0)
						fp.fp_flags |= PF_OSFP_TS0;

				}
				fp.fp_tcpopts = (fp.fp_tcpopts <<
				    PF_OSFP_TCPOPT_BITS) | PF_OSFP_TCPOPT_TS;
				break;
			default:
				return (NULL);
			}
		}
		optlen = MAX(optlen, 1);	/* paranoia */
	}

	DPFPRINTF(LOG_NOTICE,
	    "fingerprinted %s:%d  %d:%d:%d:%d:%llx (%d) "
	    "(TS=%s,M=%s%d,W=%s%d)",
	    srcname, ntohs(tcp->th_sport),
	    fp.fp_wsize, fp.fp_ttl, (fp.fp_flags & PF_OSFP_DF) != 0,
	    fp.fp_psize, (long long int)fp.fp_tcpopts, fp.fp_optcnt,
	    (fp.fp_flags & PF_OSFP_TS0) ? "0" : "",
	    (fp.fp_flags & PF_OSFP_MSS_MOD) ? "%" :
	    (fp.fp_flags & PF_OSFP_MSS_DC) ? "*" : "",
	    fp.fp_mss,
	    (fp.fp_flags & PF_OSFP_WSCALE_MOD) ? "%" :
	    (fp.fp_flags & PF_OSFP_WSCALE_DC) ? "*" : "",
	    fp.fp_wscale);

	if ((fpresult = pf_osfp_find(&pf_osfp_list, &fp,
	    PF_OSFP_MAXTTL_OFFSET)))
		return (&fpresult->fp_oses);
	return (NULL);
}

/* Match a fingerprint ID against a list of OSes */
int
pf_osfp_match(struct pf_osfp_enlist *list, pf_osfp_t os)
{
	struct pf_osfp_entry *entry;
	int os_class, os_version, os_subtype;
	int en_class, en_version, en_subtype;

	if (os == PF_OSFP_ANY)
		return (1);
	if (list == NULL) {
		DPFPRINTF(LOG_NOTICE, "osfp no match against %x", os);
		return (os == PF_OSFP_UNKNOWN);
	}
	PF_OSFP_UNPACK(os, os_class, os_version, os_subtype);
	SLIST_FOREACH(entry, list, fp_entry) {
		PF_OSFP_UNPACK(entry->fp_os, en_class, en_version, en_subtype);
		if ((os_class == PF_OSFP_ANY || en_class == os_class) &&
		    (os_version == PF_OSFP_ANY || en_version == os_version) &&
		    (os_subtype == PF_OSFP_ANY || en_subtype == os_subtype)) {
			DPFPRINTF(LOG_NOTICE,
			    "osfp matched %s %s %s  %x==%x",
			    entry->fp_class_nm, entry->fp_version_nm,
			    entry->fp_subtype_nm, os, entry->fp_os);
			return (1);
		}
	}
	DPFPRINTF(LOG_NOTICE, "fingerprint 0x%x didn't match", os);
	return (0);
}

/* Initialize the OS fingerprint system */
void
pf_osfp_initialize(void)
{
	pool_init(&pf_osfp_entry_pl, sizeof(struct pf_osfp_entry), 0,
	    IPL_NONE, PR_WAITOK, "pfosfpen", NULL);
	pool_init(&pf_osfp_pl, sizeof(struct pf_os_fingerprint), 0,
	    IPL_NONE, PR_WAITOK, "pfosfp", NULL);
	SLIST_INIT(&pf_osfp_list);
}

/* Flush the fingerprint list */
void
pf_osfp_flush(void)
{
	struct pf_os_fingerprint *fp;
	struct pf_osfp_entry *entry;

	while ((fp = SLIST_FIRST(&pf_osfp_list))) {
		SLIST_REMOVE_HEAD(&pf_osfp_list, fp_next);
		while ((entry = SLIST_FIRST(&fp->fp_oses))) {
			SLIST_REMOVE_HEAD(&fp->fp_oses, fp_entry);
			pool_put(&pf_osfp_entry_pl, entry);
		}
		pool_put(&pf_osfp_pl, fp);
	}
}


/* Add a fingerprint */
int
pf_osfp_add(struct pf_osfp_ioctl *fpioc)
{
	struct pf_os_fingerprint *fp, fpadd;
	struct pf_osfp_entry *entry;

	memset(&fpadd, 0, sizeof(fpadd));
	fpadd.fp_tcpopts = fpioc->fp_tcpopts;
	fpadd.fp_wsize = fpioc->fp_wsize;
	fpadd.fp_psize = fpioc->fp_psize;
	fpadd.fp_mss = fpioc->fp_mss;
	fpadd.fp_flags = fpioc->fp_flags;
	fpadd.fp_optcnt = fpioc->fp_optcnt;
	fpadd.fp_wscale = fpioc->fp_wscale;
	fpadd.fp_ttl = fpioc->fp_ttl;

	DPFPRINTF(LOG_DEBUG,
	    "adding osfp %s %s %s = %s%d:%d:%d:%s%d:0x%llx %d "
	    "(TS=%s,M=%s%d,W=%s%d) %x",
	    fpioc->fp_os.fp_class_nm, fpioc->fp_os.fp_version_nm,
	    fpioc->fp_os.fp_subtype_nm,
	    (fpadd.fp_flags & PF_OSFP_WSIZE_MOD) ? "%" :
	    (fpadd.fp_flags & PF_OSFP_WSIZE_MSS) ? "S" :
	    (fpadd.fp_flags & PF_OSFP_WSIZE_MTU) ? "T" :
	    (fpadd.fp_flags & PF_OSFP_WSIZE_DC) ? "*" : "",
	    fpadd.fp_wsize,
	    fpadd.fp_ttl,
	    (fpadd.fp_flags & PF_OSFP_DF) ? 1 : 0,
	    (fpadd.fp_flags & PF_OSFP_PSIZE_MOD) ? "%" :
	    (fpadd.fp_flags & PF_OSFP_PSIZE_DC) ? "*" : "",
	    fpadd.fp_psize,
	    (long long int)fpadd.fp_tcpopts, fpadd.fp_optcnt,
	    (fpadd.fp_flags & PF_OSFP_TS0) ? "0" : "",
	    (fpadd.fp_flags & PF_OSFP_MSS_MOD) ? "%" :
	    (fpadd.fp_flags & PF_OSFP_MSS_DC) ? "*" : "",
	    fpadd.fp_mss,
	    (fpadd.fp_flags & PF_OSFP_WSCALE_MOD) ? "%" :
	    (fpadd.fp_flags & PF_OSFP_WSCALE_DC) ? "*" : "",
	    fpadd.fp_wscale,
	    fpioc->fp_os.fp_os);

	if ((fp = pf_osfp_find_exact(&pf_osfp_list, &fpadd))) {
		 SLIST_FOREACH(entry, &fp->fp_oses, fp_entry) {
			if (PF_OSFP_ENTRY_EQ(entry, &fpioc->fp_os))
				return (EEXIST);
		}
		if ((entry = pool_get(&pf_osfp_entry_pl,
		    PR_WAITOK|PR_LIMITFAIL)) == NULL)
			return (ENOMEM);
	} else {
		if ((fp = pool_get(&pf_osfp_pl,
		    PR_WAITOK|PR_ZERO|PR_LIMITFAIL)) == NULL)
			return (ENOMEM);
		fp->fp_tcpopts = fpioc->fp_tcpopts;
		fp->fp_wsize = fpioc->fp_wsize;
		fp->fp_psize = fpioc->fp_psize;
		fp->fp_mss = fpioc->fp_mss;
		fp->fp_flags = fpioc->fp_flags;
		fp->fp_optcnt = fpioc->fp_optcnt;
		fp->fp_wscale = fpioc->fp_wscale;
		fp->fp_ttl = fpioc->fp_ttl;
		SLIST_INIT(&fp->fp_oses);
		if ((entry = pool_get(&pf_osfp_entry_pl,
		    PR_WAITOK|PR_LIMITFAIL)) == NULL) {
			pool_put(&pf_osfp_pl, fp);
			return (ENOMEM);
		}
		pf_osfp_insert(&pf_osfp_list, fp);
	}
	memcpy(entry, &fpioc->fp_os, sizeof(*entry));

	/* Make sure the strings are NUL terminated */
	entry->fp_class_nm[sizeof(entry->fp_class_nm)-1] = '\0';
	entry->fp_version_nm[sizeof(entry->fp_version_nm)-1] = '\0';
	entry->fp_subtype_nm[sizeof(entry->fp_subtype_nm)-1] = '\0';

	SLIST_INSERT_HEAD(&fp->fp_oses, entry, fp_entry);

#ifdef PFDEBUG
	if ((fp = pf_osfp_validate()))
		DPFPRINTF(LOG_NOTICE,
		    "Invalid fingerprint list");
#endif /* PFDEBUG */
	return (0);
}


/* Find a fingerprint in the list */
struct pf_os_fingerprint *
pf_osfp_find(struct pf_osfp_list *list, struct pf_os_fingerprint *find,
    u_int8_t ttldiff)
{
	struct pf_os_fingerprint *f;

#define MATCH_INT(_MOD, _DC, _field)					\
	if ((f->fp_flags & _DC) == 0) {					\
		if ((f->fp_flags & _MOD) == 0) {			\
			if (f->_field != find->_field)			\
				continue;				\
		} else {						\
			if (f->_field == 0 || find->_field % f->_field)	\
				continue;				\
		}							\
	}

	SLIST_FOREACH(f, list, fp_next) {
		if (f->fp_tcpopts != find->fp_tcpopts ||
		    f->fp_optcnt != find->fp_optcnt ||
		    f->fp_ttl < find->fp_ttl ||
		    f->fp_ttl - find->fp_ttl > ttldiff ||
		    (f->fp_flags & (PF_OSFP_DF|PF_OSFP_TS0)) !=
		    (find->fp_flags & (PF_OSFP_DF|PF_OSFP_TS0)))
			continue;

		MATCH_INT(PF_OSFP_PSIZE_MOD, PF_OSFP_PSIZE_DC, fp_psize)
		MATCH_INT(PF_OSFP_MSS_MOD, PF_OSFP_MSS_DC, fp_mss)
		MATCH_INT(PF_OSFP_WSCALE_MOD, PF_OSFP_WSCALE_DC, fp_wscale)
		if ((f->fp_flags & PF_OSFP_WSIZE_DC) == 0) {
			if (f->fp_flags & PF_OSFP_WSIZE_MSS) {
				if (find->fp_mss == 0)
					continue;

/* Some "smart" NAT devices and DSL routers will tweak the MSS size and
 * will set it to whatever is suitable for the link type.
 */
#define SMART_MSS	1460
				if ((find->fp_wsize % find->fp_mss ||
				    find->fp_wsize / find->fp_mss !=
				    f->fp_wsize) &&
				    (find->fp_wsize % SMART_MSS ||
				    find->fp_wsize / SMART_MSS !=
				    f->fp_wsize))
					continue;
			} else if (f->fp_flags & PF_OSFP_WSIZE_MTU) {
				if (find->fp_mss == 0)
					continue;

#define MTUOFF	(sizeof(struct ip) + sizeof(struct tcphdr))
#define SMART_MTU	(SMART_MSS + MTUOFF)
				if ((find->fp_wsize % (find->fp_mss + MTUOFF) ||
				    find->fp_wsize / (find->fp_mss + MTUOFF) !=
				    f->fp_wsize) &&
				    (find->fp_wsize % SMART_MTU ||
				    find->fp_wsize / SMART_MTU !=
				    f->fp_wsize))
					continue;
			} else if (f->fp_flags & PF_OSFP_WSIZE_MOD) {
				if (f->fp_wsize == 0 || find->fp_wsize %
				    f->fp_wsize)
					continue;
			} else {
				if (f->fp_wsize != find->fp_wsize)
					continue;
			}
		}
		return (f);
	}

	return (NULL);
}

/* Find an exact fingerprint in the list */
struct pf_os_fingerprint *
pf_osfp_find_exact(struct pf_osfp_list *list, struct pf_os_fingerprint *find)
{
	struct pf_os_fingerprint *f;

	SLIST_FOREACH(f, list, fp_next) {
		if (f->fp_tcpopts == find->fp_tcpopts &&
		    f->fp_wsize == find->fp_wsize &&
		    f->fp_psize == find->fp_psize &&
		    f->fp_mss == find->fp_mss &&
		    f->fp_flags == find->fp_flags &&
		    f->fp_optcnt == find->fp_optcnt &&
		    f->fp_wscale == find->fp_wscale &&
		    f->fp_ttl == find->fp_ttl)
			return (f);
	}

	return (NULL);
}

/* Insert a fingerprint into the list */
void
pf_osfp_insert(struct pf_osfp_list *list, struct pf_os_fingerprint *ins)
{
	struct pf_os_fingerprint *f, *prev = NULL;

	/* XXX need to go semi tree based.  can key on tcp options */

	SLIST_FOREACH(f, list, fp_next)
		prev = f;
	if (prev)
		SLIST_INSERT_AFTER(prev, ins, fp_next);
	else
		SLIST_INSERT_HEAD(list, ins, fp_next);
}

/* Fill a fingerprint by its number (from an ioctl) */
int
pf_osfp_get(struct pf_osfp_ioctl *fpioc)
{
	struct pf_os_fingerprint *fp;
	struct pf_osfp_entry *entry;
	int num = fpioc->fp_getnum;
	int i = 0;


	memset(fpioc, 0, sizeof(*fpioc));
	SLIST_FOREACH(fp, &pf_osfp_list, fp_next) {
		SLIST_FOREACH(entry, &fp->fp_oses, fp_entry) {
			if (i++ == num) {
				fpioc->fp_mss = fp->fp_mss;
				fpioc->fp_wsize = fp->fp_wsize;
				fpioc->fp_flags = fp->fp_flags;
				fpioc->fp_psize = fp->fp_psize;
				fpioc->fp_ttl = fp->fp_ttl;
				fpioc->fp_wscale = fp->fp_wscale;
				fpioc->fp_getnum = num;
				memcpy(&fpioc->fp_os, entry,
				    sizeof(fpioc->fp_os));
				return (0);
			}
		}
	}

	return (EBUSY);
}


/* Validate that each signature is reachable */
struct pf_os_fingerprint *
pf_osfp_validate(void)
{
	struct pf_os_fingerprint *f, *f2, find;

	SLIST_FOREACH(f, &pf_osfp_list, fp_next) {
		memcpy(&find, f, sizeof(find));

		/* We do a few MSS/th_win percolations to make things unique */
		if (find.fp_mss == 0)
			find.fp_mss = 128;
		if (f->fp_flags & PF_OSFP_WSIZE_MSS)
			find.fp_wsize *= find.fp_mss;
		else if (f->fp_flags & PF_OSFP_WSIZE_MTU)
			find.fp_wsize *= (find.fp_mss + 40);
		else if (f->fp_flags & PF_OSFP_WSIZE_MOD)
			find.fp_wsize *= 2;
		if (f != (f2 = pf_osfp_find(&pf_osfp_list, &find, 0))) {
			if (f2)
				DPFPRINTF(LOG_NOTICE,
				    "Found \"%s %s %s\" instead of "
				    "\"%s %s %s\"\n",
				    SLIST_FIRST(&f2->fp_oses)->fp_class_nm,
				    SLIST_FIRST(&f2->fp_oses)->fp_version_nm,
				    SLIST_FIRST(&f2->fp_oses)->fp_subtype_nm,
				    SLIST_FIRST(&f->fp_oses)->fp_class_nm,
				    SLIST_FIRST(&f->fp_oses)->fp_version_nm,
				    SLIST_FIRST(&f->fp_oses)->fp_subtype_nm);
			else
				DPFPRINTF(LOG_NOTICE,
				    "Couldn't find \"%s %s %s\"\n",
				    SLIST_FIRST(&f->fp_oses)->fp_class_nm,
				    SLIST_FIRST(&f->fp_oses)->fp_version_nm,
				    SLIST_FIRST(&f->fp_oses)->fp_subtype_nm);
			return (f);
		}
	}
	return (NULL);
}
@


1.38
log
@Put union pf_headers and struct pf_pdesc into separate header file
pfvar_priv.h.  The pf_headers had to be defined in multiple .c files
before.  In pfvar.h it would have unknown storage size, this file
is included in too many places.  The idea is to have a private pf
header that is only included in the pf part of the kernel.  For now
it contains pf_pdesc and pf_headers, it may be extended later.
discussion, input and OK henning@@ procter@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.37 2016/09/15 02:00:18 dlg Exp $ */
d89 1
a89 1
	struct tcphdr	*th = pd->hdr.tcp;
@


1.37
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.36 2016/09/02 11:43:53 dlg Exp $ */
d30 2
d34 1
d36 1
d38 1
a38 3
#include <net/if.h>
#include <net/pfvar.h>

d40 2
d43 2
@


1.36
log
@provide a pool_setipl so tcpdump can compile this file

spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.35 2016/09/02 10:19:49 dlg Exp $ */
a55 1
#define pool_setipl(pool, ipl)	((void)0)
d290 4
a293 6
	pool_init(&pf_osfp_entry_pl, sizeof(struct pf_osfp_entry), 0, 0,
	    PR_WAITOK, "pfosfpen", NULL);
	pool_setipl(&pf_osfp_entry_pl, IPL_NONE);
	pool_init(&pf_osfp_pl, sizeof(struct pf_os_fingerprint), 0, 0,
	    PR_WAITOK, "pfosfp", NULL);
	pool_setipl(&pf_osfp_pl, IPL_NONE);
@


1.35
log
@pool_setipl for pf bits

ok phessler@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.34 2016/07/19 13:34:12 henning Exp $ */
d56 1
@


1.34
log
@style: no spaces after # for define/include, ok phessler benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.32 2015/09/04 21:40:25 kettenis Exp $ */
d292 1
d295 1
@


1.33
log
@Add sys/queue.h where it's needed. Unbreak userland following recent
removal from mbuf.h.  ok mpi@@
@
text
@d23 1
a23 1
# include <sys/systm.h>
d46 14
a59 14
# include <arpa/inet.h>
# include <errno.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <netdb.h>
# define pool_t			int
# define pool_get(pool, flags)	malloc(*(pool))
# define pool_put(pool, item)	free(item)
# define pool_init(pool, size, a, ao, f, m, p)	(*(pool)) = (size)

# ifdef PFDEBUG
#  include <sys/stdarg.h>	/* for DPFPRINTF() */
# endif /* PFDEBUG */
a61 1

@


1.32
log
@The pf_osfp_pl and pf_osfp_entry_pl never get used in interrupt context.
Drop the explicit pool backend allocator here and add PR_WAITOK to the
flags passed to pool_init(9).

The pfi_addr_pl and pf_rule_pl can get used in interrupt context though.
So simply drop the explicit pool backend allocator without adding PR_WAITOK
to the flags passed to pool_init(9).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.31 2015/07/18 19:19:00 sashan Exp $ */
d26 1
@


1.31
log
@msg.mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.30 2015/07/16 16:12:15 mpi Exp $ */
d290 4
a293 4
	pool_init(&pf_osfp_entry_pl, sizeof(struct pf_osfp_entry), 0, 0, 0,
	    "pfosfpen", &pool_allocator_nointr);
	pool_init(&pf_osfp_pl, sizeof(struct pf_os_fingerprint), 0, 0, 0,
	    "pfosfp", &pool_allocator_nointr);
@


1.30
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.29 2014/07/22 11:06:10 mpi Exp $ */
d42 1
a42 1
#else
d116 1
a116 1
#else
d118 1
a118 1
#endif
d132 1
a132 1
#endif
d140 1
a140 1
#else
d148 1
a148 1
#endif
d154 1
a154 1
#endif
d163 1
a163 1
#else
d171 1
a171 1
#endif
d173 1
a173 1
#endif
@


1.29
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.28 2013/11/11 09:15:34 mpi Exp $ */
d203 1
a203 1
				NTOHS(fp.fp_mss);
@


1.28
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.27 2013/10/24 11:31:43 mpi Exp $ */
a29 1
#include <netinet/in_systm.h>
@


1.27
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.26 2011/09/28 17:15:45 bluhm Exp $ */
d140 1
a140 1
		strlcpy(srcname, inet_ntoa(ip->ip_src), sizeof(srcname));
d163 1
a163 2
		strlcpy(srcname, ip6_sprintf((struct in6_addr *)&ip6->ip6_src),
		    sizeof(srcname));
@


1.26
log
@As requested by henning, move the mbuf pointer into struct pf_pdesc.
Also sort pd to the beginning of the functions' parameter lists for
consistency.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.25 2011/09/22 14:57:12 bluhm Exp $ */
a37 3
#ifdef _KERNEL
#include <netinet6/in6_var.h>
#endif
@


1.25
log
@As I have touched half of pf lines anyway, fix whitespaces now.
KNF, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.24 2011/09/21 19:07:30 bluhm Exp $ */
d85 1
a85 1
pf_osfp_fingerprint(struct pf_pdesc *pd, struct mbuf *m)
d97 1
a97 1
		ip = mtod(m, struct ip *);
d100 1
a100 1
		ip6 = mtod(m, struct ip6_hdr *);
d103 2
a104 1
	if (!pf_pull_hdr(m, pd->off, hdr, th->th_off << 2, NULL, NULL, pd->af))
@


1.24
log
@Check the protocol header length for tcp, udp, icmp, icmp6 in
pf_setup_pdesc().  It is better to check and bail out early than
to rely on pf_pull_hdr() later.
ok henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.23 2011/09/20 15:17:26 bluhm Exp $ */
d111 2
a112 1
pf_osfp_fingerprint_hdr(const struct ip *ip, const struct ip6_hdr *ip6, const struct tcphdr *tcp)
d279 1
a279 1
			DPFPRINTF(LOG_NOTICE, 
@


1.23
log
@pf_setup_pdesc() panics if address family is neither AF_INET nor
AF_INET6.  So remove useless af switch defaults here and there.
Always use "switch(af)" instead of "if (af) else" for af dependent
code.  Always use AF_ defines instead of PF_ when checking af values.
ok claudio mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.22 2011/09/19 12:51:52 bluhm Exp $ */
d92 1
a92 1
	if (pd->proto != IPPROTO_TCP || (th->th_off << 2) < sizeof(*th))
@


1.22
log
@Consolidate pf function parameters.  Move off and hdrlen into pdesc
and change their type from int to u_int32_t.  Do not pass struct
tcphdr *th and sa_family_t af, it is in pd anyway.  Do not use af
and pd->af intermixed, the latter makes clear where it comes from.
Do not calculate the packet length again if pd already has it.  Use
pd2.off instead of off2.
go go go go don't stop henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.21 2010/10/18 15:55:28 deraadt Exp $ */
d88 3
a90 3
	struct ip *ip;
	struct ip6_hdr *ip6;
	char hdr[60];
d92 1
a92 2
	if ((pd->af != PF_INET && pd->af != PF_INET6) ||
	    pd->proto != IPPROTO_TCP || (th->th_off << 2) < sizeof(*th))
d95 2
a96 1
	if (pd->af == PF_INET) {
d98 2
a99 3
		ip6 = (struct ip6_hdr *)NULL;
	} else {
		ip = (struct ip *)NULL;
d101 1
@


1.21
log
@Revert non-compatible and undocumented bullshit commited by 3 developers
who decided to just do it on their own.  henning, mcbride, jsing -- shame
on you -- if you had shown this diff to just 1 other network developer,
the astounding mistake in it would have been noticed.  Start practicing
inclusionary development instead of going alone.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.19 2010/10/04 09:13:05 claudio Exp $ */
d85 1
a85 2
pf_osfp_fingerprint(struct pf_pdesc *pd, struct mbuf *m, int off,
    const struct tcphdr *tcp)
d87 1
d93 1
a93 1
	    pd->proto != IPPROTO_TCP || (tcp->th_off << 2) < sizeof(*tcp))
d103 2
a104 2
	if (!pf_pull_hdr(m, off, hdr, tcp->th_off << 2, NULL, NULL,
	    pd->af)) return (NULL);
@


1.20
log
@Add quirks support to operating system fingerprinting. tcpdump part
by mcbride@@.

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.18 2010/07/13 12:56:06 henning Exp $ */
d114 1
a114 1
	int cnt, tscnt = 0, optlen = 0;
a139 4
		if (ip->ip_hl > 5)
			fp.fp_quirks |= PF_OSFP_QUIRK_IPOPT;
		if (ip->ip_id == 0)
			fp.fp_quirks |= PF_OSFP_QUIRK_ZEROID;
a180 13
	/* Set quirks flags. */
	if (tcp->th_seq == tcp->th_ack)
		fp.fp_quirks |= PF_OSFP_QUIRK_SEQEQ;
	if (tcp->th_seq == 0)
		fp.fp_quirks |= PF_OSFP_QUIRK_SEQZERO;
	if (tcp->th_ack != 0)
		fp.fp_quirks |= PF_OSFP_QUIRK_ACKNO;
	if (tcp->th_urp != 0)
		fp.fp_quirks |= PF_OSFP_QUIRK_URG;
	if (tcp->th_x2 != 0)
		fp.fp_quirks |= PF_OSFP_QUIRK_X2;
	if (tcp->th_flags & ~(TH_SYN|TH_ACK|TH_RST|TH_ECE|TH_CWR))
		fp.fp_quirks |= PF_OSFP_QUIRK_FLAGS;
a220 1
				tscnt++;
d226 1
a226 3
					else if (tscnt > 1)
						fp.fp_quirks |=
						    PF_OSFP_QUIRK_TS2;
d239 2
a240 2
	    "fingerprinted %s:%d %d:%d:%d:%d:%llx (%d) "
	    "(TS=%s,M=%s%d,W=%s%d) (0x%hx)",
d250 1
a250 1
	    fp.fp_wscale, fp.fp_quirks);
a330 1
	fpadd.fp_quirks = fpioc->fp_quirks;
d361 1
a361 1
		SLIST_FOREACH(entry, &fp->fp_oses, fp_entry) {
a376 1
		fp->fp_quirks = fpioc->fp_quirks;
a473 2
		if (f->fp_quirks != find->fp_quirks)
			continue;
a491 1
		    f->fp_quirks == find->fp_quirks &&
d526 1
a533 1
				fpioc->fp_quirks = fp->fp_quirks;
d547 1
@


1.19
log
@fp_wscale is only a single byte so do not byteswap it. This makes os
fingerprinting on little endian systems work. People using the osfp
feature need to update /etc/pf.os or -current will be blocked.
OK deraadt@@, jsg@@, jsing@@, millert@@, sthen@@
@
text
@d114 1
a114 1
	int cnt, optlen = 0;
d140 4
d185 13
d238 1
d244 3
a246 1

d259 2
a260 2
	    "fingerprinted %s:%d  %d:%d:%d:%d:%llx (%d) "
	    "(TS=%s,M=%s%d,W=%s%d)",
d270 1
a270 1
	    fp.fp_wscale);
d351 1
d382 1
a382 1
		 SLIST_FOREACH(entry, &fp->fp_oses, fp_entry) {
d398 1
d496 2
d516 1
a550 1

d558 1
a571 1

@


1.18
log
@-                       find.fp_wsize *= find.fp_mss, 1;
+                       find.fp_wsize *= find.fp_mss;
From: Ed Schouten <ed at FreeBSD.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.17 2010/04/09 20:58:06 oga Exp $ */
a211 1
				NTOHS(fp.fp_wscale);
@


1.17
log
@replace pool_get(), memset(,0,) with pool_get(,PR_ZERO) as $DEITY
intended.

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.16 2010/01/18 23:52:46 mcbride Exp $ */
d563 1
a563 1
			find.fp_wsize *= find.fp_mss, 1;
@


1.16
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.15 2008/06/14 02:22:13 henning Exp $ */
d371 1
a371 1
		    PR_WAITOK|PR_LIMITFAIL)) == NULL)
a372 1
		memset(fp, 0, sizeof(*fp));
@


1.15
log
@pool_get()s not in interrupt context should not be PR_NOWAIT, but
PR_WAITOK | PR_LIMITFAIL. from discussion with art. ok ryan claudio thib
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.14 2008/06/12 18:17:01 henning Exp $ */
d27 1
a43 3
# define DPFPRINTF(format, x...)		\
	if (pf_status.debug >= PF_DEBUG_NOISY)	\
		printf(format , ##x)
d61 1
a61 4
#  include <sys/stdarg.h>
#  define DPFPRINTF(format, x...)	fprintf(stderr, format , ##x)
# else
#  define DPFPRINTF(format, x...)	((void)0)
d63 1
d239 3
a241 2
	DPFPRINTF("fingerprinted %s:%d  %d:%d:%d:%d:%llx (%d) "
	    "(TS=%s,M=%s%d,W=%s%d)\n",
d270 1
a270 1
		DPFPRINTF("osfp no match against %x\n", os);
d279 2
a280 1
			DPFPRINTF("osfp matched %s %s %s  %x==%x\n",
d286 1
a286 1
	DPFPRINTF("fingerprint 0x%x didn't match\n", os);
d336 3
a338 3
#if 0	/* XXX RYAN wants to fix logging */
	DPFPRINTF("adding osfp %s %s %s = %s%d:%d:%d:%s%d:0x%llx %d "
	    "(TS=%s,M=%s%d,W=%s%d) %x\n",
a359 1
#endif
d401 2
a402 1
		printf("Invalid fingerprint list\n");
d571 2
a572 1
				printf("Found \"%s %s %s\" instead of "
d581 2
a582 1
				printf("Couldn't find \"%s %s %s\"\n",
@


1.14
log
@#if 0 an annoygly chatty printf active whenever we're at loglevel
loud, spilling out hundreds of lines on ruleset reloads is disturbing when
you're hacking over cereal console, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.13 2007/09/01 18:49:27 henning Exp $ */
d369 2
a370 1
		if ((entry = pool_get(&pf_osfp_entry_pl, PR_NOWAIT)) == NULL)
d373 2
a374 1
		if ((fp = pool_get(&pf_osfp_pl, PR_NOWAIT)) == NULL)
d386 2
a387 1
		if ((entry = pool_get(&pf_osfp_entry_pl, PR_NOWAIT)) == NULL) {
@


1.13
log
@since the
MGET* macros were changed to function calls, there wasn't any
need for the pool declarations and the inclusion of pool.h
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.12 2006/12/13 18:14:10 itojun Exp $ */
d338 1
d362 1
a362 1

@


1.12
log
@wrap ipv6 portion with #ifdef INET6.  from cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.11 2006/12/13 05:10:15 itojun Exp $ */
d24 1
@


1.11
log
@IPv6 passive OS fingerprinting.
reuses IPv4 signature file (assuming that TCP code is shared among IPv4/v6).
mcbride ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.10 2004/04/09 19:30:41 frantzen Exp $ */
d154 3
a156 1
	} else if (ip6) {
d178 3
a180 1
	} else
@


1.10
log
@move some of the non-interrupt pools from the small kmem_map to the much
larger kernel map
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.9 2004/01/04 20:08:42 pvalchev Exp $ */
a34 1
#ifdef INET6
d36 3
a38 1
#endif /* INET6 */
d55 1
d92 1
d95 2
a96 3
	/* XXX don't have a fingerprint database for IPv6 :-( */
	if (pd->af != PF_INET || pd->proto != IPPROTO_TCP || (tcp->th_off << 2)
	    < sizeof(*tcp))
d99 9
a107 3
	ip = mtod(m, struct ip *);
	if (!pf_pull_hdr(m, off, hdr, tcp->th_off << 2, NULL, NULL, pd->af))
		return (NULL);
d109 1
a109 1
	return (pf_osfp_fingerprint_hdr(ip, (struct tcphdr *)hdr));
d114 1
a114 1
pf_osfp_fingerprint_hdr(const struct ip *ip, const struct tcphdr *tcp)
d119 5
d125 1
a125 2
	if ((tcp->th_flags & (TH_SYN|TH_ACK)) != TH_SYN || (ip->ip_off &
	    htons(IP_OFFMASK)))
d127 4
d134 28
a161 3
	fp.fp_psize = ntohs(ip->ip_len);
	fp.fp_ttl = ip->ip_ttl;
	if (ip->ip_off & htons(IP_DF))
d163 15
d240 1
a240 1
	    inet_ntoa(ip->ip_src), ntohs(tcp->th_sport),
@


1.9
log
@oops... string.h ended up being included twice; pointed out by espie
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.8 2004/01/04 06:57:48 pvalchev Exp $ */
d236 1
a236 1
	    "pfosfpen", NULL);
d238 1
a238 1
	    "pfosfp", NULL);
@


1.9.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.9.2.2
log
@Merge with the trunk
@
text
@d236 1
a236 1
	    "pfosfpen", &pool_allocator_nointr);
d238 1
a238 1
	    "pfosfp", &pool_allocator_nointr);
@


1.8
log
@include proper protos for userland; deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.7 2004/01/03 14:51:02 espie Exp $ */
a23 2
#else
# include <string.h>
@


1.7
log
@make sure userland sees memcmp and friends (gcc3)
okay frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.5 2003/12/19 20:09:01 dhartmei Exp $ */
d24 2
@


1.6
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d53 1
@


1.5
log
@more const-correctness, ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.4 2003/12/18 16:07:38 dhartmei Exp $ */
d59 1
a59 1
#  include <stdarg.h>
@


1.4
log
@resolve compiler warnings, from Pyun YongHyeon, ok cedric@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.3 2003/08/27 18:23:36 frantzen Exp $ */
d125 1
a125 1
	optp = (caddr_t)tcp + sizeof(*tcp);
@


1.3
log
@fix inconsistency how we handle tcpopt EOL versus how p0f v2 handles it
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.2 2003/08/27 16:13:21 frantzen Exp $ */
d109 1
a109 1
	u_int8_t *optp;
@


1.2
log
@it is supprisingly common (>4%) for some NAT and DSL routers to tweak MSS
by setting it to whatever is suitable for the link type.  so we try a guessed
1460 MTU and 1500 MSS if the primary check fails.
algorithm tweak from Michal Zalewski
name a few constants too while I'm in there
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_osfp.c,v 1.1 2003/08/21 19:12:08 frantzen Exp $ */
a126 1
		fp.fp_optcnt++;
d129 3
a131 1
		else if (*optp == TCPOPT_NOP) {
@


1.1
log
@Add Michal Zalewski's p0f v2 style passive OS fingerprinting to PF.
Exposes the source IP's operating system to the filter language.
Interesting policy decisions are now enforceable:
.	block proto tcp from any os SCO
.	block proto tcp from any os Windows to any port smtp
.	rdr ... from any os "Windows 98" to port WWW -> 127.0.0.1 port 8001
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d375 8
a382 2
				if (find->fp_mss == 0 ||
				    find->fp_wsize % find->fp_mss ||
d384 4
a387 1
				    f->fp_wsize)
d390 11
a400 4
				if (find->fp_mss == 0 ||
				    find->fp_wsize % (find->fp_mss + 40) ||
				    find->fp_wsize / (find->fp_mss + 40) !=
				    f->fp_wsize)
@

