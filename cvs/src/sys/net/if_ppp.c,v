head	1.105;
access;
symbols
	OPENBSD_6_1:1.105.0.2
	OPENBSD_6_1_BASE:1.105
	OPENBSD_6_0:1.100.0.4
	OPENBSD_6_0_BASE:1.100
	OPENBSD_5_9:1.97.0.2
	OPENBSD_5_9_BASE:1.97
	OPENBSD_5_8:1.87.0.4
	OPENBSD_5_8_BASE:1.87
	OPENBSD_5_7:1.80.0.2
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.76.0.4
	OPENBSD_5_6_BASE:1.76
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.69.0.2
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.65.0.2
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.2
	OPENBSD_5_0:1.63.0.2
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.58.0.4
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.58.0.2
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.52.0.2
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.50.0.4
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.2
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.49.0.2
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.42.0.6
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.42.0.4
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	OPENBSD_3_5:1.40.0.2
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.34
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.31
	UBC:1.25.0.4
	UBC_BASE:1.25
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.6
	OPENBSD_2_8:1.16.0.4
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	SMP:1.15.0.2
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.105
date	2017.03.08.11.35.34;	author mpi;	state Exp;
branches;
next	1.104;
commitid	bEPtAj7p3VHfjZJG;

1.104
date	2017.03.03.08.00.36;	author mpi;	state Exp;
branches;
next	1.103;
commitid	KuCW82qjmjAC2LiB;

1.103
date	2017.01.01.15.39.01;	author mpi;	state Exp;
branches;
next	1.102;
commitid	vqnOyUzBXsLvwFNE;

1.102
date	2016.11.16.14.23.10;	author mpi;	state Exp;
branches;
next	1.101;
commitid	YEeB82d9UcBrvel5;

1.101
date	2016.10.06.19.09.08;	author bluhm;	state Exp;
branches;
next	1.100;
commitid	IO8dsedjngxSg7J1;

1.100
date	2016.06.22.19.44.26;	author jca;	state Exp;
branches;
next	1.99;
commitid	52NLcoIf4kbcNN7R;

1.99
date	2016.05.23.15.22.44;	author tedu;	state Exp;
branches;
next	1.98;
commitid	Hsu9ZZbSw737UJHI;

1.98
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.97;
commitid	Xo6g1xk26RWDGcjJ;

1.97
date	2015.11.20.06.22.09;	author jsg;	state Exp;
branches;
next	1.96;
commitid	yKYZftdVS9wXEqsO;

1.96
date	2015.11.11.01.38.55;	author dlg;	state Exp;
branches;
next	1.95;
commitid	rtwAv4YW76BohQPr;

1.95
date	2015.11.06.07.07.19;	author dlg;	state Exp;
branches;
next	1.94;
commitid	hhWyuWlQO4sdP5Zj;

1.94
date	2015.11.05.10.53.54;	author dlg;	state Exp;
branches;
next	1.93;
commitid	tu4715xRLunIDkZE;

1.93
date	2015.11.04.01.54.14;	author dlg;	state Exp;
branches;
next	1.92;
commitid	FSpZ4K6ru8wZJfXb;

1.92
date	2015.11.02.23.39.20;	author dlg;	state Exp;
branches;
next	1.91;
commitid	5S5DmnnP7vgf9mYk;

1.91
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.90;
commitid	G2nTzngqgXpQqcJB;

1.90
date	2015.10.12.13.17.58;	author dlg;	state Exp;
branches;
next	1.89;
commitid	jErEkfao8orfupjn;

1.89
date	2015.10.05.19.05.09;	author uebayasi;	state Exp;
branches;
next	1.88;
commitid	KaQeg2gqRFHdXmok;

1.88
date	2015.10.05.15.57.27;	author uebayasi;	state Exp;
branches;
next	1.87;
commitid	6akt7VG8aLhHdJOU;

1.87
date	2015.07.15.22.16.41;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	ncpqEGjDtSFuLAgn;

1.86
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.85;
commitid	9ERVupAoYqW4Iok9;

1.85
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.84;
commitid	h7z8lokZ0dFyuWpg;

1.84
date	2015.06.03.00.50.09;	author dlg;	state Exp;
branches;
next	1.83;
commitid	gxTjkPThodI9Be3R;

1.83
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.82;
commitid	hN5bFCE56DrAjl99;

1.82
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.81;
commitid	c7ei8kPelCOOwHXy;

1.81
date	2015.03.18.12.23.15;	author dlg;	state Exp;
branches;
next	1.80;
commitid	veRr3qZI7HBatTwk;

1.80
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.79;
commitid	zhW8jJrfVCoAthrR;

1.79
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.78;
commitid	20ZyHa9gTJxHxhwD;

1.78
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.77;
commitid	t9FBKDfc4VDxpEy2;

1.77
date	2014.11.20.14.51.42;	author krw;	state Exp;
branches;
next	1.76;
commitid	dOUqRDzYiPQXkCLL;

1.76
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.75;
commitid	DQakU8LLWV6Iwx84;

1.75
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.74;
commitid	B4dZSbxas1X1IpXI;

1.74
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.73;

1.73
date	2014.04.19.12.08.10;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.71;

1.71
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.70;

1.70
date	2013.10.19.14.46.30;	author mpi;	state Exp;
branches;
next	1.69;

1.69
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2013.03.26.13.19.26;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2012.11.29.22.56.08;	author yasuoka;	state Exp;
branches;
next	1.66;

1.66
date	2012.11.26.20.21.14;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2012.03.28.19.39.33;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2012.01.20.23.36.53;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.07.20.42.56;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.06.22.08.50;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.05.19.59.18;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.04.20.40.58;	author dhill;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.02.22.34.31;	author stsp;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.56;

1.56
date	2010.04.24.08.00.12;	author stsp;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.08.15.01.50;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2008.10.22.23.04.45;	author mpf;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.17.20.10.37;	author chl;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.26.17.13.31;	author jason;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.11.14.50.55;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.12.28.20.06.11;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.12.00.18.07;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.25.18.50.01;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.13.10.01.16;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.07.15.41.27;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.07.09.00.33;	author kjc;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.01.19.31.34;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.19.08.48.57;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.11.04.27.40;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.13.08.14.48;	author kjc;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.16.00.42.44;	author millert;	state Exp;
branches
	1.25.4.1;
next	1.24;

1.24
date	2001.07.20.22.47.15;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.27.06.07.42;	author kjc;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.27.03.49.53;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.25.01.50.17;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.15.03.38.34;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.28.07.53.04;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.27.11.57.09;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.16.12.53.34;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.21.23.31.27;	author mickey;	state Exp;
branches
	1.16.4.1
	1.16.6.1;
next	1.15;

1.15
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	98.07.12.04.33.20;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	98.07.01.21.02.23;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	98.05.08.05.02.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.09.05.04.26.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.01.02.11.10.18;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.12.19.13.45.16;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.07.25.14.20.50;	author joshd;	state Exp;
branches;
next	1.7;

1.7
date	96.05.10.12.31.10;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.28.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.19.18.12.29;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.03.21.07.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.12.28.19.10.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.18.17.51.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.06;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2000.03.24.09.09.32;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.07.04.10.54.04;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.15.2.8;

1.15.2.8
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.15.2.9;

1.15.2.9
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.15.2.10;

1.15.2.10
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.16.4.1
date	2001.09.16.15.22.03;	author miod;	state Exp;
branches;
next	;

1.16.6.1
date	2001.10.14.20.44.49;	author jason;	state Exp;
branches;
next	;

1.25.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.25.4.2;

1.25.4.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.25.4.3;

1.25.4.3
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.105
log
@No need to clear IFF_UP after calling if_down().
@
text
@/*	$OpenBSD: if_ppp.c,v 1.104 2017/03/03 08:00:36 mpi Exp $	*/
/*	$NetBSD: if_ppp.c,v 1.39 1997/05/17 21:11:59 christos Exp $	*/

/*
 * if_ppp.c - Point-to-Point Protocol (PPP) Asynchronous driver.
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Based on:
 *	@@(#)if_sl.c	7.6.1.2 (Berkeley) 2/15/89
 *
 * Copyright (c) 1987, 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Serial Line interface
 *
 * Rick Adams
 * Center for Seismic Studies
 * 1300 N 17th Street, Suite 1450
 * Arlington, Virginia 22209
 * (703)276-7900
 * rick@@seismo.ARPA
 * seismo!rick
 *
 * Pounded on heavily by Chris Torek (chris@@mimsy.umd.edu, umcp-cs!chris).
 * Converted to 4.3BSD Beta by Chris Torek.
 * Other changes made at Berkeley, based in part on code by Kirk Smith.
 *
 * Converted to 4.3BSD+ 386BSD by Brad Parker (brad@@cayman.com)
 * Added VJ tcp header compression; more unified ioctls
 *
 * Extensively modified by Paul Mackerras (paulus@@cs.anu.edu.au).
 * Cleaned up a lot of the mbuf-related code to fix bugs that
 * caused system crashes and packet corruption.  Changed pppstart
 * so that it doesn't just give up with a collision if the whole
 * packet doesn't fit in the output ring buffer.
 *
 * Added priority queueing for interactive IP packets, following
 * the model of if_sl.c, plus hooks for bpf.
 * Paul Mackerras (paulus@@cs.anu.edu.au).
 */

/* from if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp */
/* from NetBSD: if_ppp.c,v 1.15.2.2 1994/07/28 05:17:58 cgd Exp */

#include "ppp.h"
#if NPPP > 0

#define VJC
#define PPP_COMPRESS

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/malloc.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/ip.h>

#include "bpfilter.h"

#ifdef VJC
#include <net/slcompress.h>
#endif

#include <net/ppp_defs.h>
#include <net/if_ppp.h>
#include <net/if_pppvar.h>

#ifdef PPP_COMPRESS
#define PACKETPTR	struct mbuf *
#include <net/ppp-comp.h>
#endif

static int	 pppsioctl(struct ifnet *, u_long, caddr_t);
static void	 ppp_requeue(struct ppp_softc *);
static void	 ppp_ccp(struct ppp_softc *, struct mbuf *m, int rcvd);
static void	 ppp_ccp_closed(struct ppp_softc *);
static void	 ppp_inproc(struct ppp_softc *, struct mbuf *);
static void	 pppdumpm(struct mbuf *m0);
static void	 ppp_ifstart(struct ifnet *ifp);
int		 ppp_clone_create(struct if_clone *, int);
int		 ppp_clone_destroy(struct ifnet *);

void		 ppp_pkt_list_init(struct ppp_pkt_list *, u_int);
int		 ppp_pkt_enqueue(struct ppp_pkt_list *, struct ppp_pkt *);
struct ppp_pkt	*ppp_pkt_dequeue(struct ppp_pkt_list *);
struct mbuf	*ppp_pkt_mbuf(struct ppp_pkt *);

/*
 * We steal two bits in the mbuf m_flags, to mark high-priority packets
 * for output, and received packets following lost/corrupted packets.
 */
#define M_ERRMARK	M_LINK0		/* steal a bit in mbuf m_flags */


#ifdef PPP_COMPRESS
/*
 * List of compressors we know about.
 */

extern struct compressor ppp_bsd_compress;
extern struct compressor ppp_deflate, ppp_deflate_draft;

struct compressor *ppp_compressors[] = {
#if DO_BSD_COMPRESS && defined(PPP_BSDCOMP)
	&ppp_bsd_compress,
#endif
#if DO_DEFLATE && defined(PPP_DEFLATE)
	&ppp_deflate,
	&ppp_deflate_draft,
#endif
	NULL
};
#endif /* PPP_COMPRESS */

LIST_HEAD(, ppp_softc) ppp_softc_list;
struct if_clone ppp_cloner =
    IF_CLONE_INITIALIZER("ppp", ppp_clone_create, ppp_clone_destroy);

/*
 * Called from boot code to establish ppp interfaces.
 */
void
pppattach(void)
{
	LIST_INIT(&ppp_softc_list);
	if_clone_attach(&ppp_cloner);
}

int
ppp_clone_create(struct if_clone *ifc, int unit)
{
	struct ppp_softc *sc;
	int s;

	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!sc)
		return (ENOMEM);

	sc->sc_unit = unit;
	snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "%s%d",
	    ifc->ifc_name, unit);
	sc->sc_if.if_softc = sc;
	sc->sc_if.if_mtu = PPP_MTU;
	sc->sc_if.if_flags = IFF_POINTOPOINT | IFF_MULTICAST;
	sc->sc_if.if_type = IFT_PPP;
	sc->sc_if.if_hdrlen = PPP_HDRLEN;
	sc->sc_if.if_ioctl = pppsioctl;
	sc->sc_if.if_output = pppoutput;
	sc->sc_if.if_start = ppp_ifstart;
	sc->sc_if.if_rtrequest = p2p_rtrequest;
	IFQ_SET_MAXLEN(&sc->sc_if.if_snd, IFQ_MAXLEN);
	mq_init(&sc->sc_inq, IFQ_MAXLEN, IPL_NET);
	ppp_pkt_list_init(&sc->sc_rawq, IFQ_MAXLEN);
	if_attach(&sc->sc_if);
	if_alloc_sadl(&sc->sc_if);
#if NBPFILTER > 0
	bpfattach(&sc->sc_bpf, &sc->sc_if, DLT_PPP, PPP_HDRLEN);
#endif
	s = splnet();
	LIST_INSERT_HEAD(&ppp_softc_list, sc, sc_list);
	splx(s);

	return (0);
}

int
ppp_clone_destroy(struct ifnet *ifp)
{
	struct ppp_softc *sc = ifp->if_softc;
	int s;

	if (sc->sc_devp != NULL)
		return (EBUSY);

	s = splnet();
	LIST_REMOVE(sc, sc_list);
	splx(s);

	if_detach(ifp);

	free(sc, M_DEVBUF, 0);
	return (0);
}

/*
 * Allocate a ppp interface unit and initialize it.
 */
struct ppp_softc *
pppalloc(pid_t pid)
{
	int i;
	struct ppp_softc *sc;

	LIST_FOREACH(sc, &ppp_softc_list, sc_list) {
		if (sc->sc_xfer == pid) {
			sc->sc_xfer = 0;
			return sc;
		}
	}
	LIST_FOREACH(sc, &ppp_softc_list, sc_list) {
		if (sc->sc_devp == NULL)
			break;
	}
	if (sc == NULL)
		return NULL;

	sc->sc_flags = 0;
	sc->sc_mru = PPP_MRU;
	sc->sc_relinq = NULL;
	bzero((char *)&sc->sc_stats, sizeof(sc->sc_stats));
#ifdef VJC
	sc->sc_comp = malloc(sizeof(struct slcompress), M_DEVBUF, M_NOWAIT);
	if (sc->sc_comp)
		sl_compress_init(sc->sc_comp);
#endif
#ifdef PPP_COMPRESS
	sc->sc_xc_state = NULL;
	sc->sc_rc_state = NULL;
#endif /* PPP_COMPRESS */
	for (i = 0; i < NUM_NP; ++i)
		sc->sc_npmode[i] = NPMODE_ERROR;
	ml_init(&sc->sc_npqueue);
	sc->sc_last_sent = sc->sc_last_recv = time_uptime;

	return sc;
}

/*
 * Deallocate a ppp unit.
 */
void
pppdealloc(struct ppp_softc *sc)
{
	struct ppp_pkt *pkt;
	int s;

	NET_LOCK(s);
	if_down(&sc->sc_if);
	sc->sc_if.if_flags &= ~IFF_RUNNING;
	sc->sc_devp = NULL;
	sc->sc_xfer = 0;
	while ((pkt = ppp_pkt_dequeue(&sc->sc_rawq)) != NULL)
		ppp_pkt_free(pkt);
	mq_purge(&sc->sc_inq);
	ml_purge(&sc->sc_npqueue);
	m_freem(sc->sc_togo);
	sc->sc_togo = NULL;

#ifdef PPP_COMPRESS
	ppp_ccp_closed(sc);
	sc->sc_xc_state = NULL;
	sc->sc_rc_state = NULL;
#endif /* PPP_COMPRESS */
#if NBPFILTER > 0
	if (sc->sc_pass_filt.bf_insns != 0) {
		free(sc->sc_pass_filt.bf_insns, M_DEVBUF, 0);
		sc->sc_pass_filt.bf_insns = 0;
		sc->sc_pass_filt.bf_len = 0;
	}
	if (sc->sc_active_filt.bf_insns != 0) {
		free(sc->sc_active_filt.bf_insns, M_DEVBUF, 0);
		sc->sc_active_filt.bf_insns = 0;
		sc->sc_active_filt.bf_len = 0;
	}
#endif
#ifdef VJC
	if (sc->sc_comp != 0) {
		free(sc->sc_comp, M_DEVBUF, 0);
		sc->sc_comp = 0;
	}
#endif
	NET_UNLOCK(s);
}

/*
 * Ioctl routine for generic ppp devices.
 */
int
pppioctl(struct ppp_softc *sc, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	int s, error, flags, mru, npx;
	u_int nb;
	struct ppp_option_data *odp;
	struct compressor **cp;
	struct npioctl *npi;
	time_t t;
#if NBPFILTER > 0
	struct bpf_program *bp, *nbp;
	struct bpf_insn *newcode, *oldcode;
	int newcodelen;
#endif
#ifdef	PPP_COMPRESS
	u_char ccp_option[CCP_MAX_OPTION_LENGTH];
#endif

	switch (cmd) {
	case FIONREAD:
		*(int *)data = mq_len(&sc->sc_inq);
		break;

	case PPPIOCGUNIT:
		*(int *)data = sc->sc_unit;	/* XXX */
		break;

	case PPPIOCGFLAGS:
		*(u_int *)data = sc->sc_flags;
		break;

	case PPPIOCSFLAGS:
		if ((error = suser(p, 0)) != 0)
			return (error);
		flags = *(int *)data & SC_MASK;
#ifdef PPP_COMPRESS
		if (sc->sc_flags & SC_CCP_OPEN && !(flags & SC_CCP_OPEN))
			ppp_ccp_closed(sc);
#endif
		s = splnet();
		sc->sc_flags = (sc->sc_flags & ~SC_MASK) | flags;
		splx(s);
		break;

	case PPPIOCSMRU:
		if ((error = suser(p, 0)) != 0)
			return (error);
		mru = *(int *)data;
		if (mru >= PPP_MRU && mru <= PPP_MAXMRU)
			sc->sc_mru = mru;
		break;

	case PPPIOCGMRU:
		*(int *)data = sc->sc_mru;
		break;

#ifdef VJC
	case PPPIOCSMAXCID:
		if ((error = suser(p, 0)) != 0)
			return (error);
		if (sc->sc_comp)
			sl_compress_setup(sc->sc_comp, *(int *)data);
		break;
#endif

	case PPPIOCXFERUNIT:
		if ((error = suser(p, 0)) != 0)
			return (error);
		sc->sc_xfer = p->p_p->ps_pid;
		break;

#ifdef PPP_COMPRESS
	case PPPIOCSCOMPRESS:
		if ((error = suser(p, 0)) != 0)
			return (error);
		odp = (struct ppp_option_data *) data;
		nb = odp->length;
		if (nb > sizeof(ccp_option))
			nb = sizeof(ccp_option);
		if ((error = copyin(odp->ptr, ccp_option, nb)) != 0)
			return (error);
		 /* preliminary check on the length byte */
		if (ccp_option[1] < 2)
			return (EINVAL);
		for (cp = ppp_compressors; *cp != NULL; ++cp)
			if ((*cp)->compress_proto == ccp_option[0]) {
			/*
			 * Found a handler for the protocol - try to allocate
			 * a compressor or decompressor.
			 */
			error = 0;
			if (odp->transmit) {
				if (sc->sc_xc_state != NULL) {
					(*sc->sc_xcomp->comp_free)(
					    sc->sc_xc_state);
				}
				sc->sc_xcomp = *cp;
				sc->sc_xc_state = (*cp)->comp_alloc(ccp_option,
				    nb);
				if (sc->sc_xc_state == NULL) {
					if (sc->sc_flags & SC_DEBUG)
						printf(
						    "%s: comp_alloc failed\n",
						    sc->sc_if.if_xname);
					error = ENOBUFS;
				}
				s = splnet();
				sc->sc_flags &= ~SC_COMP_RUN;
				splx(s);
			} else {
				if (sc->sc_rc_state != NULL) {
					(*sc->sc_rcomp->decomp_free)(
					    sc->sc_rc_state);
				}
				sc->sc_rcomp = *cp;
				sc->sc_rc_state = (*cp)->decomp_alloc(
				    ccp_option, nb);
				if (sc->sc_rc_state == NULL) {
					if (sc->sc_flags & SC_DEBUG) {
						printf(
						    "%s: decomp_alloc failed\n",
						    sc->sc_if.if_xname);
					}
					error = ENOBUFS;
				}
				s = splnet();
				sc->sc_flags &= ~SC_DECOMP_RUN;
				splx(s);
			}
			return (error);
		}
		if (sc->sc_flags & SC_DEBUG) {
			printf("%s: no compressor for [%x %x %x], %x\n",
			    sc->sc_if.if_xname, ccp_option[0], ccp_option[1],
			    ccp_option[2], nb);
		}
		return (EINVAL);	/* no handler found */
#endif /* PPP_COMPRESS */

	case PPPIOCGNPMODE:
	case PPPIOCSNPMODE:
		npi = (struct npioctl *)data;
		switch (npi->protocol) {
		case PPP_IP:
			npx = NP_IP;
			break;
		default:
			return EINVAL;
		}
		if (cmd == PPPIOCGNPMODE) {
			npi->mode = sc->sc_npmode[npx];
		} else {
			if ((error = suser(p, 0)) != 0)
				return (error);
			if (npi->mode != sc->sc_npmode[npx]) {
				sc->sc_npmode[npx] = npi->mode;
				if (npi->mode != NPMODE_QUEUE) {
					ppp_requeue(sc);
					(*sc->sc_start)(sc);
				}
			}
		}
		break;

	case PPPIOCGIDLE:
		t = time_uptime;
		((struct ppp_idle *)data)->xmit_idle = t - sc->sc_last_sent;
		((struct ppp_idle *)data)->recv_idle = t - sc->sc_last_recv;
		break;

#if NBPFILTER > 0
	case PPPIOCSPASS:
	case PPPIOCSACTIVE:
		nbp = (struct bpf_program *) data;
		if ((unsigned) nbp->bf_len > BPF_MAXINSNS)
			return EINVAL;
		newcodelen = nbp->bf_len * sizeof(struct bpf_insn);
		if (nbp->bf_len != 0) {
			newcode = mallocarray(nbp->bf_len,
			    sizeof(struct bpf_insn), M_DEVBUF, M_WAITOK);
			if ((error = copyin((caddr_t)nbp->bf_insns,
			    (caddr_t)newcode, newcodelen)) != 0) {
				free(newcode, M_DEVBUF, 0);
				return error;
			}
			if (!bpf_validate(newcode, nbp->bf_len)) {
				free(newcode, M_DEVBUF, 0);
				return EINVAL;
			}
		} else
			newcode = 0;
		bp = (cmd == PPPIOCSPASS) ?
		    &sc->sc_pass_filt : &sc->sc_active_filt;
		oldcode = bp->bf_insns;
		s = splnet();
		bp->bf_len = nbp->bf_len;
		bp->bf_insns = newcode;
		splx(s);
		if (oldcode != 0)
			free(oldcode, M_DEVBUF, 0);
		break;
#endif

	default:
		return (-1);
	}
	return (0);
}

/*
 * Process an ioctl request to the ppp network interface.
 */
static int
pppsioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ppp_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	struct ppp_stats *psp;
#ifdef	PPP_COMPRESS
	struct ppp_comp_stats *pcp;
#endif
	int s = splnet(), error = 0;

	switch (cmd) {
	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_RUNNING) == 0)
			ifp->if_flags &= ~IFF_UP;
		break;

	case SIOCSIFADDR:
		if (ifa->ifa_addr->sa_family != AF_INET)
			error = EAFNOSUPPORT;
		break;

	case SIOCSIFDSTADDR:
		if (ifa->ifa_addr->sa_family != AF_INET)
			error = EAFNOSUPPORT;
		break;

	case SIOCSIFMTU:
		sc->sc_if.if_mtu = ifr->ifr_mtu;
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCGPPPSTATS:
		psp = &((struct ifpppstatsreq *) data)->stats;
		bzero(psp, sizeof(*psp));
		psp->p = sc->sc_stats;
#if defined(VJC) && !defined(SL_NO_STATS)
		if (sc->sc_comp) {
			psp->vj.vjs_packets = sc->sc_comp->sls_packets;
			psp->vj.vjs_compressed = sc->sc_comp->sls_compressed;
			psp->vj.vjs_searches = sc->sc_comp->sls_searches;
			psp->vj.vjs_misses = sc->sc_comp->sls_misses;
			psp->vj.vjs_uncompressedin =
			    sc->sc_comp->sls_uncompressedin;
			psp->vj.vjs_compressedin =
			    sc->sc_comp->sls_compressedin;
			psp->vj.vjs_errorin = sc->sc_comp->sls_errorin;
			psp->vj.vjs_tossed = sc->sc_comp->sls_tossed;
		}
#endif /* VJC */
		break;

#ifdef PPP_COMPRESS
	case SIOCGPPPCSTATS:
		pcp = &((struct ifpppcstatsreq *) data)->stats;
		bzero(pcp, sizeof(*pcp));
		if (sc->sc_xc_state != NULL)
			(*sc->sc_xcomp->comp_stat)(sc->sc_xc_state, &pcp->c);
		if (sc->sc_rc_state != NULL)
			(*sc->sc_rcomp->decomp_stat)(sc->sc_rc_state, &pcp->d);
		break;
#endif /* PPP_COMPRESS */

	default:
		error = ENOTTY;
	}
	splx(s);
	return (error);
}

/*
 * Queue a packet.  Start transmission if not active.
 * Packet is placed in Information field of PPP frame.
 */
int
pppoutput(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst,
    struct rtentry *rtp)
{
	struct ppp_softc *sc = ifp->if_softc;
	int protocol, address, control;
	u_char *cp;
	int error;
	enum NPmode mode;
	int len;

	if (sc->sc_devp == NULL || (ifp->if_flags & IFF_RUNNING) == 0
	    || ((ifp->if_flags & IFF_UP) == 0 && dst->sa_family != AF_UNSPEC)) {
		error = ENETDOWN;	/* sort of */
		goto bad;
	}

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m0->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m0->m_pkthdr.ph_rtableid),
		    dst->sa_family);
	}
#endif

	/*
	 * Compute PPP header.
	 */
	switch (dst->sa_family) {
	case AF_INET:
		address = PPP_ALLSTATIONS;
		control = PPP_UI;
		protocol = PPP_IP;
		mode = sc->sc_npmode[NP_IP];
		break;
	case AF_UNSPEC:
		address = PPP_ADDRESS(dst->sa_data);
		control = PPP_CONTROL(dst->sa_data);
		protocol = PPP_PROTOCOL(dst->sa_data);
		mode = NPMODE_PASS;
		break;
	default:
		printf("%s: af%d not supported\n", ifp->if_xname,
		    dst->sa_family);
		error = EAFNOSUPPORT;
		goto bad;
	}

	/*
	 * Drop this packet, or return an error, if necessary.
	 */
	if (mode == NPMODE_ERROR) {
		error = ENETDOWN;
		goto bad;
	}
	if (mode == NPMODE_DROP) {
		error = 0;
		goto bad;
	}

	/*
	 * Add PPP header.  If no space in first mbuf, allocate another.
	 * (This assumes M_LEADINGSPACE is always 0 for a cluster mbuf.)
	 */
	M_PREPEND(m0, PPP_HDRLEN, M_DONTWAIT);
	if (m0 == NULL) {
		error = ENOBUFS;
		goto bad;
	}

	cp = mtod(m0, u_char *);
	*cp++ = address;
	*cp++ = control;
	*cp++ = protocol >> 8;
	*cp++ = protocol & 0xff;

	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("mbuf packet without packet header!");
	len = m0->m_pkthdr.len;

	if (sc->sc_flags & SC_LOG_OUTPKT) {
		printf("%s output: ", ifp->if_xname);
		pppdumpm(m0);
	}

	if ((protocol & 0x8000) == 0) {
#if NBPFILTER > 0
		/*
		 * Apply the pass and active filters to the packet,
		 * but only if it is a data packet.
		 */
		*mtod(m0, u_char *) = 1;	/* indicates outbound */
		if (sc->sc_pass_filt.bf_insns != 0 &&
		    bpf_filter(sc->sc_pass_filt.bf_insns, (u_char *)m0,
		    len, 0) == 0) {
			error = 0; /* drop this packet */
			goto bad;
		}

		/*
		 * Update the time we sent the most recent packet.
		 */
		if (sc->sc_active_filt.bf_insns == 0 ||
		    bpf_filter(sc->sc_active_filt.bf_insns, (u_char *)m0,
		    len, 0))
			sc->sc_last_sent = time_uptime;

		*mtod(m0, u_char *) = address;
#else
		/*
		 * Update the time we sent the most recent packet.
		 */
		sc->sc_last_sent = time_uptime;
#endif
	}

#if NBPFILTER > 0
	/*
	 * See if bpf wants to look at the packet.
	 */
	if (sc->sc_bpf)
		bpf_mtap(sc->sc_bpf, m0, BPF_DIRECTION_OUT);
#endif

	/*
	 * Put the packet on the appropriate queue.
	 */
	if (mode == NPMODE_QUEUE) {
		/* XXX we should limit the number of packets on this queue */
		ml_enqueue(&sc->sc_npqueue, m0);
	} else {
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m0, error);
		if (error) {
			sc->sc_if.if_oerrors++;
			sc->sc_stats.ppp_oerrors++;
			return (error);
		}
		(*sc->sc_start)(sc);
	}
	ifp->if_opackets++;
	ifp->if_obytes += len;

	return (0);

bad:
	m_freem(m0);
	return (error);
}



/*
 * After a change in the NPmode for some NP, move packets from the
 * npqueue to the send queue or the fast queue as appropriate.
 */
static void
ppp_requeue(struct ppp_softc *sc)
{
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	enum NPmode mode;
	int error;

	while ((m = ml_dequeue(&sc->sc_npqueue)) != NULL) {
		switch (PPP_PROTOCOL(mtod(m, u_char *))) {
		case PPP_IP:
			mode = sc->sc_npmode[NP_IP];
			break;
		default:
			mode = NPMODE_PASS;
		}

		switch (mode) {
		case NPMODE_PASS:
			IFQ_ENQUEUE(&sc->sc_if.if_snd, m, error);
			if (error) {
				sc->sc_if.if_oerrors++;
				sc->sc_stats.ppp_oerrors++;
			}
			break;

		case NPMODE_DROP:
		case NPMODE_ERROR:
			m_freem(m);
			break;

		case NPMODE_QUEUE:
			ml_enqueue(&ml, m);
			break;
		}
	}
	sc->sc_npqueue = ml;
}

/*
 * Transmitter has finished outputting some stuff;
 */
void
ppp_restart(struct ppp_softc *sc)
{
	int s = splnet();

	sc->sc_flags &= ~SC_TBUSY;
	schednetisr(NETISR_PPP);
	splx(s);
}

/*
 * Get a packet to send.
 */
struct mbuf *
ppp_dequeue(struct ppp_softc *sc)
{
	struct mbuf *m, *mp;
	u_char *cp;
	int address, control, protocol;

	/*
	 * Grab a packet to send: first try the fast queue, then the
	 * normal queue.
	 */
	IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
	if (m == NULL)
		return NULL;

	++sc->sc_stats.ppp_opackets;

	/*
	 * Extract the ppp header of the new packet.
	 * The ppp header will be in one mbuf.
	 */
	cp = mtod(m, u_char *);
	address = PPP_ADDRESS(cp);
	control = PPP_CONTROL(cp);
	protocol = PPP_PROTOCOL(cp);

	switch (protocol) {
	case PPP_IP:
#ifdef VJC
		/*
		 * If the packet is a TCP/IP packet, see if we can compress it.
		 */
		if ((sc->sc_flags & SC_COMP_TCP) && sc->sc_comp != NULL) {
			struct ip *ip;
			int type;

			mp = m;
			ip = (struct ip *)(cp + PPP_HDRLEN);
			if (mp->m_len <= PPP_HDRLEN) {
				mp = mp->m_next;
				if (mp == NULL)
					break;
				ip = mtod(mp, struct ip *);
			}
			/*
			 * this code assumes the IP/TCP header is in one
			 * non-shared mbuf.
			 */
			if (ip->ip_p == IPPROTO_TCP) {
				type = sl_compress_tcp(mp, ip, sc->sc_comp,
				    !(sc->sc_flags & SC_NO_TCP_CCID));
				switch (type) {
				case TYPE_UNCOMPRESSED_TCP:
					protocol = PPP_VJC_UNCOMP;
					break;
				case TYPE_COMPRESSED_TCP:
					protocol = PPP_VJC_COMP;
					cp = mtod(m, u_char *);
					cp[0] = address; /* header has moved */
					cp[1] = control;
					cp[2] = 0;
					break;
				}
				/* update protocol in PPP header */
				cp[3] = protocol;
			}
		}
#endif	/* VJC */
		break;

#ifdef PPP_COMPRESS
	case PPP_CCP:
		ppp_ccp(sc, m, 0);
		break;
#endif	/* PPP_COMPRESS */
	}

#ifdef PPP_COMPRESS
	if (protocol != PPP_LCP && protocol != PPP_CCP &&
	    sc->sc_xc_state && (sc->sc_flags & SC_COMP_RUN)) {
		struct mbuf *mcomp = NULL;
		int slen;

		slen = 0;
		for (mp = m; mp != NULL; mp = mp->m_next)
			slen += mp->m_len;
		(*sc->sc_xcomp->compress)(sc->sc_xc_state, &mcomp, m, slen,
		    (sc->sc_flags & SC_CCP_UP ?
		    sc->sc_if.if_mtu + PPP_HDRLEN : 0));
		if (mcomp != NULL) {
			if (sc->sc_flags & SC_CCP_UP) {
				/* Send the compressed packet instead. */
				m_freem(m);
				m = mcomp;
				cp = mtod(m, u_char *);
				protocol = cp[3];
			} else {
				/*
				 * Can't transmit compressed packets until
				 * CCP is up.
				 */
				m_freem(mcomp);
			}
		}
	}
#endif	/* PPP_COMPRESS */

	/*
	 * Compress the address/control and protocol, if possible.
	 */
	if (sc->sc_flags & SC_COMP_AC && address == PPP_ALLSTATIONS &&
	    control == PPP_UI && protocol != PPP_ALLSTATIONS &&
	    protocol != PPP_LCP) {
		/* can compress address/control */
		m->m_data += 2;
		m->m_len -= 2;
	}
	if (sc->sc_flags & SC_COMP_PROT && protocol < 0xFF) {
		/* can compress protocol */
		if (mtod(m, u_char *) == cp) {
			cp[2] = cp[1];	/* move address/control up */
			cp[1] = cp[0];
		}
		++m->m_data;
		--m->m_len;
	}

	return m;
}

/*
 * Software interrupt routine.
 */
void
pppintr(void)
{
	struct ppp_softc *sc;
	int s;
	struct ppp_pkt *pkt;
	struct mbuf *m;

	splsoftassert(IPL_SOFTNET);

	LIST_FOREACH(sc, &ppp_softc_list, sc_list) {
		if (!(sc->sc_flags & SC_TBUSY) &&
		    (!IFQ_IS_EMPTY(&sc->sc_if.if_snd))) {
			s = splnet();
			sc->sc_flags |= SC_TBUSY;
			splx(s);
			(*sc->sc_start)(sc);
		}
		while ((pkt = ppp_pkt_dequeue(&sc->sc_rawq)) != NULL) {
			m = ppp_pkt_mbuf(pkt);
			if (m == NULL)
				continue;
			ppp_inproc(sc, m);
		}
	}
}

#ifdef PPP_COMPRESS
/*
 * Handle a CCP packet.  `rcvd' is 1 if the packet was received,
 * 0 if it is about to be transmitted.
 */
static void
ppp_ccp(struct ppp_softc *sc, struct mbuf *m, int rcvd)
{
	u_char *dp, *ep;
	struct mbuf *mp;
	int slen, s;

	/*
	 * Get a pointer to the data after the PPP header.
	 */
	if (m->m_len <= PPP_HDRLEN) {
		mp = m->m_next;
		if (mp == NULL)
			return;
		dp = mtod(mp, u_char *);
	} else {
		mp = m;
		dp = mtod(mp, u_char *) + PPP_HDRLEN;
	}

	ep = mtod(mp, u_char *) + mp->m_len;
	if (dp + CCP_HDRLEN > ep)
		return;
	slen = CCP_LENGTH(dp);
	if (dp + slen > ep) {
		if (sc->sc_flags & SC_DEBUG) {
			printf("if_ppp/ccp: not enough data in mbuf"
			    " (%p+%x > %p+%x)\n", dp, slen,
			    mtod(mp, u_char *), mp->m_len);
		}
		return;
	}

	switch (CCP_CODE(dp)) {
	case CCP_CONFREQ:
	case CCP_TERMREQ:
	case CCP_TERMACK:
		/* CCP must be going down - disable compression */
		if (sc->sc_flags & SC_CCP_UP) {
			s = splnet();
			sc->sc_flags &=
			    ~(SC_CCP_UP | SC_COMP_RUN | SC_DECOMP_RUN);
			splx(s);
		}
		break;

	case CCP_CONFACK:
		if (sc->sc_flags & SC_CCP_OPEN &&
		    !(sc->sc_flags & SC_CCP_UP) &&
		    slen >= CCP_HDRLEN + CCP_OPT_MINLEN &&
		    slen >= CCP_OPT_LENGTH(dp + CCP_HDRLEN) + CCP_HDRLEN) {
			if (!rcvd) {
				/* we're agreeing to send compressed packets. */
				if (sc->sc_xc_state != NULL &&
				    (*sc->sc_xcomp->comp_init)(sc->sc_xc_state,
				    dp + CCP_HDRLEN, slen - CCP_HDRLEN,
				    sc->sc_unit, 0, sc->sc_flags & SC_DEBUG)) {
					s = splnet();
					sc->sc_flags |= SC_COMP_RUN;
					splx(s);
				}
			} else {
				/* peer agrees to send compressed packets */
				if (sc->sc_rc_state != NULL &&
				    (*sc->sc_rcomp->decomp_init)(
				     sc->sc_rc_state, dp + CCP_HDRLEN,
				     slen - CCP_HDRLEN, sc->sc_unit, 0,
				     sc->sc_mru, sc->sc_flags & SC_DEBUG)) {
					s = splnet();
					sc->sc_flags |= SC_DECOMP_RUN;
					sc->sc_flags &=
					    ~(SC_DC_ERROR | SC_DC_FERROR);
					splx(s);
				}
			}
		}
		break;

	case CCP_RESETACK:
		if (sc->sc_flags & SC_CCP_UP) {
			if (!rcvd) {
				if (sc->sc_xc_state &&
				    (sc->sc_flags & SC_COMP_RUN)) {
					(*sc->sc_xcomp->comp_reset)(
					    sc->sc_xc_state);
				}
			} else {
				if (sc->sc_rc_state &&
				    (sc->sc_flags & SC_DECOMP_RUN)) {
					(*sc->sc_rcomp->decomp_reset)(
					    sc->sc_rc_state);
					s = splnet();
					sc->sc_flags &= ~SC_DC_ERROR;
					splx(s);
				}
			}
		}
		break;
	}
}

/*
 * CCP is down; free (de)compressor state if necessary.
 */
static void
ppp_ccp_closed(struct ppp_softc *sc)
{
	if (sc->sc_xc_state) {
		(*sc->sc_xcomp->comp_free)(sc->sc_xc_state);
		sc->sc_xc_state = NULL;
	}
	if (sc->sc_rc_state) {
		(*sc->sc_rcomp->decomp_free)(sc->sc_rc_state);
		sc->sc_rc_state = NULL;
	}
}
#endif /* PPP_COMPRESS */

/*
 * PPP packet input routine.
 * The caller has checked and removed the FCS and has inserted
 * the address/control bytes and the protocol high byte if they
 * were omitted.
 */
void
ppppktin(struct ppp_softc *sc, struct ppp_pkt *pkt, int lost)
{
	pkt->p_hdr.ph_errmark = lost;
	if (ppp_pkt_enqueue(&sc->sc_rawq, pkt) == 0)
		schednetisr(NETISR_PPP);
}

/*
 * Process a received PPP packet, doing decompression as necessary.
 */
#define COMPTYPE(proto)	((proto) == PPP_VJC_COMP? TYPE_COMPRESSED_TCP: \
			 TYPE_UNCOMPRESSED_TCP)

static void
ppp_inproc(struct ppp_softc *sc, struct mbuf *m)
{
	struct ifnet *ifp = &sc->sc_if;
	int s, ilen, xlen, proto, rv;
	u_char *cp, adrs, ctrl;
	struct mbuf *mp, *dmp = NULL;
	u_char *iphdr;
	u_int hlen;

	sc->sc_stats.ppp_ipackets++;

	if (sc->sc_flags & SC_LOG_INPKT) {
		ilen = 0;
		for (mp = m; mp != NULL; mp = mp->m_next)
			ilen += mp->m_len;
		printf("%s: got %d bytes\n", ifp->if_xname, ilen);
		pppdumpm(m);
	}

	cp = mtod(m, u_char *);
	adrs = PPP_ADDRESS(cp);
	ctrl = PPP_CONTROL(cp);
	proto = PPP_PROTOCOL(cp);

	if (m->m_flags & M_ERRMARK) {
		m->m_flags &= ~M_ERRMARK;
		s = splnet();
		sc->sc_flags |= SC_VJ_RESET;
		splx(s);
	}

#ifdef PPP_COMPRESS
	/*
	 * Decompress this packet if necessary, update the receiver's
	 * dictionary, or take appropriate action on a CCP packet.
	 */
	if (proto == PPP_COMP && sc->sc_rc_state &&
	    (sc->sc_flags & SC_DECOMP_RUN) && !(sc->sc_flags & SC_DC_ERROR) &&
	    !(sc->sc_flags & SC_DC_FERROR)) {
		/* decompress this packet */
		rv = (*sc->sc_rcomp->decompress)(sc->sc_rc_state, m, &dmp);
		if (rv == DECOMP_OK) {
			m_freem(m);
			if (dmp == NULL) {
				/*
				 * no error, but no decompressed packet
				 * produced
				 */
				return;
			}
			m = dmp;
			cp = mtod(m, u_char *);
			proto = PPP_PROTOCOL(cp);

		} else {
			/*
			 * An error has occurred in decompression.
			 * Pass the compressed packet up to pppd, which may
			 * take CCP down or issue a Reset-Req.
			 */
			if (sc->sc_flags & SC_DEBUG) {
				printf("%s: decompress failed %d\n",
				    ifp->if_xname, rv);
			}
			s = splnet();
			sc->sc_flags |= SC_VJ_RESET;
			if (rv == DECOMP_ERROR)
				sc->sc_flags |= SC_DC_ERROR;
			else
				sc->sc_flags |= SC_DC_FERROR;
			splx(s);
		}

	} else {
		if (sc->sc_rc_state && (sc->sc_flags & SC_DECOMP_RUN)) {
			(*sc->sc_rcomp->incomp)(sc->sc_rc_state, m);
		}
		if (proto == PPP_CCP) {
			ppp_ccp(sc, m, 1);
		}
	}
#endif

	ilen = 0;
	for (mp = m; mp != NULL; mp = mp->m_next)
		ilen += mp->m_len;

#ifdef VJC
	if (sc->sc_flags & SC_VJ_RESET) {
		/*
		* If we've missed a packet, we must toss subsequent compressed
		* packets which don't have an explicit connection ID.
		*/
		if (sc->sc_comp)
			sl_uncompress_tcp(NULL, 0, TYPE_ERROR, sc->sc_comp);
		s = splnet();
		sc->sc_flags &= ~SC_VJ_RESET;
		splx(s);
	}

	/*
	 * See if we have a VJ-compressed packet to uncompress.
	 */
	if (proto == PPP_VJC_COMP) {
		if ((sc->sc_flags & SC_REJ_COMP_TCP) || sc->sc_comp == 0)
			goto bad;

		xlen = sl_uncompress_tcp_core(cp + PPP_HDRLEN,
		    m->m_len - PPP_HDRLEN, ilen - PPP_HDRLEN,
		    TYPE_COMPRESSED_TCP, sc->sc_comp, &iphdr, &hlen);

		if (xlen <= 0) {
			if (sc->sc_flags & SC_DEBUG) {
				printf("%s: VJ uncompress failed "
				    "on type comp\n", ifp->if_xname);
			}
			goto bad;
		}

		/* Copy the PPP and IP headers into a new mbuf. */
		MGETHDR(mp, M_DONTWAIT, MT_DATA);
		if (mp == NULL)
			goto bad;
		mp->m_len = 0;
		mp->m_next = NULL;
		if (hlen + PPP_HDRLEN > MHLEN) {
			MCLGET(mp, M_DONTWAIT);
			if (M_TRAILINGSPACE(mp) < hlen + PPP_HDRLEN) {
				m_freem(mp);
				/* lose if big headers and no clusters */
				goto bad;
			}
		}
		if (m->m_flags & M_PKTHDR)
			M_MOVE_HDR(mp, m);
		cp = mtod(mp, u_char *);
		cp[0] = adrs;
		cp[1] = ctrl;
		cp[2] = 0;
		cp[3] = PPP_IP;
		proto = PPP_IP;
		bcopy(iphdr, cp + PPP_HDRLEN, hlen);
		mp->m_len = hlen + PPP_HDRLEN;

		/*
		 * Trim the PPP and VJ headers off the old mbuf
		 * and stick the new and old mbufs together.
		 */
		m->m_data += PPP_HDRLEN + xlen;
		m->m_len -= PPP_HDRLEN + xlen;
		if (m->m_len <= M_TRAILINGSPACE(mp)) {
			bcopy(mtod(m, u_char *),
			    mtod(mp, u_char *) + mp->m_len, m->m_len);
			mp->m_len += m->m_len;
			mp->m_next = m_free(m);
		} else
			mp->m_next = m;
		m = mp;
		ilen += hlen - xlen;

	} else if (proto == PPP_VJC_UNCOMP) {
		if ((sc->sc_flags & SC_REJ_COMP_TCP) || sc->sc_comp == 0)
			goto bad;

		xlen = sl_uncompress_tcp_core(cp + PPP_HDRLEN,
		    m->m_len - PPP_HDRLEN, ilen - PPP_HDRLEN,
		    TYPE_UNCOMPRESSED_TCP, sc->sc_comp, &iphdr, &hlen);

		if (xlen < 0) {
			if (sc->sc_flags & SC_DEBUG) {
				printf("%s: VJ uncompress failed "
				    "on type uncomp\n", ifp->if_xname);
			}
			goto bad;
		}

		proto = PPP_IP;
		cp[3] = PPP_IP;
	}
#endif /* VJC */

	m->m_pkthdr.len = ilen;
	m->m_pkthdr.ph_ifidx = ifp->if_index;

	/* mark incoming routing table */
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

	if ((proto & 0x8000) == 0) {
#if NBPFILTER > 0
		/*
		 * See whether we want to pass this packet, and
		 * if it counts as link activity.
		 */
		adrs = *mtod(m, u_char *);	/* save address field */
		*mtod(m, u_char *) = 0;		/* indicate inbound */
		if (sc->sc_pass_filt.bf_insns != 0 &&
		    bpf_filter(sc->sc_pass_filt.bf_insns, (u_char *) m,
		     ilen, 0) == 0) {
			/* drop this packet */
			m_freem(m);
			return;
		}
		if (sc->sc_active_filt.bf_insns == 0 ||
		    bpf_filter(sc->sc_active_filt.bf_insns, (u_char *)m,
		     ilen, 0))
			sc->sc_last_recv = time_uptime;

		*mtod(m, u_char *) = adrs;
#else
		/*
		 * Record the time that we received this packet.
		 */
		sc->sc_last_recv = time_uptime;
#endif
	}

#if NBPFILTER > 0
	/* See if bpf wants to look at the packet. */
	if (sc->sc_bpf)
		bpf_mtap(sc->sc_bpf, m, BPF_DIRECTION_IN);
#endif

	rv = 0;
	switch (proto) {
	case PPP_IP:
		/*
		 * IP packet - take off the ppp header and pass it up to IP.
		 */
		if ((ifp->if_flags & IFF_UP) == 0 ||
		    sc->sc_npmode[NP_IP] != NPMODE_PASS) {
			/* interface is down - drop the packet. */
			m_freem(m);
			return;
		}
		m->m_pkthdr.len -= PPP_HDRLEN;
		m->m_data += PPP_HDRLEN;
		m->m_len -= PPP_HDRLEN;

		if (niq_enqueue(&ipintrq, m) != 0)
			rv = 0; /* failure */
		else
			rv = 1; /* ipintrq success */
		break;

	default:
		/*
		 * Some other protocol - place on input queue for read().
		 */
		if (mq_enqueue(&sc->sc_inq, m) != 0) {
			if_congestion();
			rv = 0; /* failure */
		} else
			rv = 2; /* input queue */
		break;
	}

	if (rv == 0) {
		/* failure */
		if (sc->sc_flags & SC_DEBUG)
			printf("%s: input queue full\n", ifp->if_xname);
		ifp->if_iqdrops++;
		goto dropped;
	}

	ifp->if_ipackets++;
	ifp->if_ibytes += ilen;

	if (rv == 2)
		(*sc->sc_ctlp)(sc);

	return;

bad:
	m_freem(m);
dropped:
	sc->sc_if.if_ierrors++;
	sc->sc_stats.ppp_ierrors++;
}

#define MAX_DUMP_BYTES	128

static void
pppdumpm(struct mbuf *m0)
{
	char buf[3*MAX_DUMP_BYTES+4];
	char *bp = buf;
	struct mbuf *m;
	static char digits[] = "0123456789abcdef";

	for (m = m0; m; m = m->m_next) {
		int l = m->m_len;
		u_char *rptr = mtod(m, u_char *);

		while (l--) {
			if (bp > buf + sizeof(buf) - 4)
				goto done;

			/* convert byte to ascii hex */
			*bp++ = digits[*rptr >> 4];
			*bp++ = digits[*rptr++ & 0xf];
		}

		if (m->m_next) {
			if (bp > buf + sizeof(buf) - 3)
				goto done;
			*bp++ = '|';
		} else
			*bp++ = ' ';
	}
done:
	if (m)
		*bp++ = '>';
	*bp = 0;
	printf("%s\n", buf);
}

static void
ppp_ifstart(struct ifnet *ifp)
{
	struct ppp_softc *sc;

	sc = ifp->if_softc;
	(*sc->sc_start)(sc);
}

void
ppp_pkt_list_init(struct ppp_pkt_list *pl, u_int limit)
{
	mtx_init(&pl->pl_mtx, IPL_TTY);
	pl->pl_head = pl->pl_tail = NULL;
	pl->pl_count = 0;
	pl->pl_limit = limit;
}

int
ppp_pkt_enqueue(struct ppp_pkt_list *pl, struct ppp_pkt *pkt)
{
	int drop = 0;

	mtx_enter(&pl->pl_mtx);
	if (pl->pl_count < pl->pl_limit) {
		if (pl->pl_tail == NULL)
			pl->pl_head = pl->pl_tail = pkt;
		else {
			PKT_NEXTPKT(pl->pl_tail) = pkt;
			pl->pl_tail = pkt;
		}
		PKT_NEXTPKT(pkt) = NULL;
		pl->pl_count++;
	} else
		drop = 1;
	mtx_leave(&pl->pl_mtx);

	if (drop)
		ppp_pkt_free(pkt);

	return (drop);
}

struct ppp_pkt *
ppp_pkt_dequeue(struct ppp_pkt_list *pl)
{
	struct ppp_pkt *pkt;

	mtx_enter(&pl->pl_mtx);
	pkt = pl->pl_head;
	if (pkt != NULL) {
		pl->pl_head = PKT_NEXTPKT(pkt);
		if (pl->pl_head == NULL)
			pl->pl_tail = NULL;

		pl->pl_count--;
	}
	mtx_leave(&pl->pl_mtx);

	return (pkt);
}

struct mbuf *
ppp_pkt_mbuf(struct ppp_pkt *pkt0)
{
	extern struct pool ppp_pkts;
	struct mbuf *m0 = NULL, **mp = &m0, *m;
	struct ppp_pkt *pkt = pkt0;
	size_t len = 0;

	do {
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			goto fail;

		MEXTADD(m, pkt, sizeof(*pkt), M_EXTWR,
		    MEXTFREE_POOL, &ppp_pkts);
		m->m_data += sizeof(pkt->p_hdr);
		m->m_len = PKT_LEN(pkt);

		len += m->m_len;

		*mp = m;
		mp = &m->m_next;

		pkt = PKT_NEXT(pkt);
	} while (pkt != NULL);

	m0->m_pkthdr.len = len;
	if (pkt0->p_hdr.ph_errmark)
		m0->m_flags |= M_ERRMARK;

	return (m0);

fail:
	m_freem(m0);
	ppp_pkt_free(pkt0);
	return (NULL);
}

#endif	/* NPPP > 0 */
@


1.104
log
@Remove non longer needed splsoftnet()/splx() dances.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.103 2017/01/01 15:39:01 mpi Exp $	*/
d313 1
a313 1
	sc->sc_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
@


1.103
log
@Grab the NET_LOCK() in pppdealloc(), prevent an assert reported by stsp@@.

ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.102 2016/11/16 14:23:10 mpi Exp $	*/
a387 1
		s = splsoftnet();
d392 1
a392 1
		splnet();
d413 1
a413 2
		if (sc->sc_comp) {
			s = splsoftnet();
a414 2
			splx(s);
		}
a444 1
				s = splsoftnet();
d459 1
a459 1
				splnet();
a462 1
				s = splsoftnet();
d478 1
a478 1
				splnet();
a507 1
				s = splsoftnet();
a512 1
				splx(s);
a517 1
		s = splsoftnet();
a520 1
		splx(s);
d650 1
a650 1
	int s, error;
a770 1
	s = splsoftnet();
a776 1
			splx(s);
a785 1
	splx(s);
a806 2
	splsoftassert(IPL_SOFTNET);

a1152 1
 * Should be called at splsoftnet.
@


1.102
log
@Kill outdated comment talking about sofnet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.101 2016/10/06 19:09:08 bluhm Exp $	*/
d309 1
d311 1
a311 2
	splsoftassert(IPL_SOFTNET);

d346 1
@


1.101
log
@Remove redundant comments that say a function must be called at
splsoftnet() if the function does a splsoftassert(IPL_SOFTNET)
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.100 2016/06/22 19:44:26 jca Exp $	*/
a853 1
 * remember to call sc->sc_start later at splsoftnet.
d866 1
a866 4
 * Get a packet to send.  This procedure is intended to be called at
 * splsoftnet, since it may involve time-consuming operations such as
 * applying VJ compression, packet compression, address/control and/or
 * protocol field compression to the packet.
@


1.100
log
@No modules thus no need for extra space for additional ppp compressions.

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.99 2016/05/23 15:22:44 tedu Exp $	*/
d303 1
a303 1
 * Deallocate a ppp unit.  Must be called at splsoftnet or higher.
a809 1
 * Should be called at splsoftnet.
d1003 1
a1003 1
 * Software interrupt routine, called at splsoftnet.
@


1.99
log
@remove the function pointer from mbufs. this memory is shared with data
via unions, and we don't want to make it easy to control the target.
instead an integer index into an array of acceptable functions is used.
drivers using custom functions must register them to receive an index.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.98 2016/04/13 11:41:15 mpi Exp $	*/
a171 1
 * We leave some space so maybe we can modload compressors.
d177 1
a177 1
struct compressor *ppp_compressors[8] = {
@


1.98
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.97 2015/11/20 06:22:09 jsg Exp $	*/
d1571 1
a1571 1
		    m_extfree_pool, &ppp_pkts);
@


1.97
log
@correctly indent a line to make the intent clear
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.96 2015/11/11 01:38:55 dlg Exp $	*/
a228 1
	IFQ_SET_READY(&sc->sc_if.if_snd);
@


1.96
log
@use time_uptime instead of time_second.

this avoids wall clock jumps skewing the idle times.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.95 2015/11/06 07:07:19 dlg Exp $	*/
d426 1
a426 1
			sc->sc_xfer = p->p_p->ps_pid;
@


1.95
log
@replace sc_npqueue and sc_npqtail with a simple mbuf_list.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.94 2015/11/05 10:53:54 dlg Exp $	*/
d299 1
a299 1
	sc->sc_last_sent = sc->sc_last_recv = time_second;
d528 1
a528 1
		t = time_second;
d760 1
a760 1
			sc->sc_last_sent = time_second;
d767 1
a767 1
		sc->sc_last_sent = time_second;
d1385 1
a1385 1
			sc->sc_last_recv = time_second;
d1392 1
a1392 1
		sc->sc_last_recv = time_second;
@


1.94
log
@apply some knf.

ok many
no objections from anyone
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.93 2015/11/04 01:54:14 dlg Exp $	*/
d298 1
a298 2
	sc->sc_npqueue = NULL;
	sc->sc_npqtail = &sc->sc_npqueue;
a310 1
	struct mbuf *m;
d321 1
a321 4
	while ((m = sc->sc_npqueue) != NULL) {
		sc->sc_npqueue = m->m_nextpkt;
		m_freem(m);
	}
d785 1
a785 3
		*sc->sc_npqtail = m0;
		m0->m_nextpkt = NULL;
		sc->sc_npqtail = &m0->m_nextpkt;
d807 2
d817 2
a818 1
	struct mbuf *m, **mpp;
d824 1
a824 1
	for (mpp = &sc->sc_npqueue; (m = *mpp) != NULL; ) {
a834 6
			/*
			 * This packet can now go on one of the queues
			 * to be sent.
			 */
			*mpp = m->m_nextpkt;
			m->m_nextpkt = NULL;
a843 1
			*mpp = m->m_nextpkt;
d848 1
a848 1
			mpp = &m->m_nextpkt;
d852 1
a852 1
	sc->sc_npqtail = mpp;
@


1.93
log
@use mq_purge to free a queue of mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.92 2015/11/02 23:39:20 dlg Exp $	*/
d147 14
a160 14
static int	pppsioctl(struct ifnet *, u_long, caddr_t);
static void	ppp_requeue(struct ppp_softc *);
static void	ppp_ccp(struct ppp_softc *, struct mbuf *m, int rcvd);
static void	ppp_ccp_closed(struct ppp_softc *);
static void	ppp_inproc(struct ppp_softc *, struct mbuf *);
static void	pppdumpm(struct mbuf *m0);
static void	ppp_ifstart(struct ifnet *ifp);
int		ppp_clone_create(struct if_clone *, int);
int		ppp_clone_destroy(struct ifnet *);

void		ppp_pkt_list_init(struct ppp_pkt_list *, u_int);
int		ppp_pkt_enqueue(struct ppp_pkt_list *, struct ppp_pkt *);
struct ppp_pkt *ppp_pkt_dequeue(struct ppp_pkt_list *);
struct mbuf *	ppp_pkt_mbuf(struct ppp_pkt *);
d180 1
a180 1
    &ppp_bsd_compress,
d183 2
a184 2
    &ppp_deflate,
    &ppp_deflate_draft,
d186 1
a186 1
    NULL
d200 2
a201 2
    LIST_INIT(&ppp_softc_list);
    if_clone_attach(&ppp_cloner);
d207 2
a208 2
    struct ppp_softc *sc;
    int s;
d210 22
a231 22
    sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT|M_ZERO);
    if (!sc)
	return (ENOMEM);

    sc->sc_unit = unit;
    snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "%s%d",
	ifc->ifc_name, unit);
    sc->sc_if.if_softc = sc;
    sc->sc_if.if_mtu = PPP_MTU;
    sc->sc_if.if_flags = IFF_POINTOPOINT | IFF_MULTICAST;
    sc->sc_if.if_type = IFT_PPP;
    sc->sc_if.if_hdrlen = PPP_HDRLEN;
    sc->sc_if.if_ioctl = pppsioctl;
    sc->sc_if.if_output = pppoutput;
    sc->sc_if.if_start = ppp_ifstart;
    sc->sc_if.if_rtrequest = p2p_rtrequest;
    IFQ_SET_MAXLEN(&sc->sc_if.if_snd, IFQ_MAXLEN);
    mq_init(&sc->sc_inq, IFQ_MAXLEN, IPL_NET);
    ppp_pkt_list_init(&sc->sc_rawq, IFQ_MAXLEN);
    IFQ_SET_READY(&sc->sc_if.if_snd);
    if_attach(&sc->sc_if);
    if_alloc_sadl(&sc->sc_if);
d233 1
a233 1
    bpfattach(&sc->sc_bpf, &sc->sc_if, DLT_PPP, PPP_HDRLEN);
d235 3
a237 3
    s = splnet();
    LIST_INSERT_HEAD(&ppp_softc_list, sc, sc_list);
    splx(s);
d239 1
a239 1
    return (0);
d245 2
a246 2
    struct ppp_softc *sc = ifp->if_softc;
    int s;
d248 2
a249 2
    if (sc->sc_devp != NULL)
	return (EBUSY);
d251 3
a253 3
    s = splnet();
    LIST_REMOVE(sc, sc_list);
    splx(s);
d255 1
a255 1
    if_detach(ifp);
d257 2
a258 2
    free(sc, M_DEVBUF, 0);
    return (0);
d267 2
a268 2
    int i;
    struct ppp_softc *sc;
d270 17
a286 15
    LIST_FOREACH(sc, &ppp_softc_list, sc_list)
	if (sc->sc_xfer == pid) {
	    sc->sc_xfer = 0;
	    return sc;
	}
    LIST_FOREACH(sc, &ppp_softc_list, sc_list)
	if (sc->sc_devp == NULL)
	    break;
    if (sc == NULL)
	return NULL;

    sc->sc_flags = 0;
    sc->sc_mru = PPP_MRU;
    sc->sc_relinq = NULL;
    bzero((char *)&sc->sc_stats, sizeof(sc->sc_stats));
d288 3
a290 3
    sc->sc_comp = malloc(sizeof(struct slcompress), M_DEVBUF, M_NOWAIT);
    if (sc->sc_comp)
	sl_compress_init(sc->sc_comp);
d293 2
a294 2
    sc->sc_xc_state = NULL;
    sc->sc_rc_state = NULL;
d296 5
a300 5
    for (i = 0; i < NUM_NP; ++i)
	sc->sc_npmode[i] = NPMODE_ERROR;
    sc->sc_npqueue = NULL;
    sc->sc_npqtail = &sc->sc_npqueue;
    sc->sc_last_sent = sc->sc_last_recv = time_second;
d302 1
a302 1
    return sc;
d311 2
a312 2
    struct ppp_pkt *pkt;
    struct mbuf *m;
d314 1
a314 1
    splsoftassert(IPL_SOFTNET);
d316 13
a328 13
    if_down(&sc->sc_if);
    sc->sc_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
    sc->sc_devp = NULL;
    sc->sc_xfer = 0;
    while ((pkt = ppp_pkt_dequeue(&sc->sc_rawq)) != NULL)
	ppp_pkt_free(pkt);
    mq_purge(&sc->sc_inq);
    while ((m = sc->sc_npqueue) != NULL) {
	sc->sc_npqueue = m->m_nextpkt;
	m_freem(m);
    }
    m_freem(sc->sc_togo);
    sc->sc_togo = NULL;
d331 3
a333 3
    ppp_ccp_closed(sc);
    sc->sc_xc_state = NULL;
    sc->sc_rc_state = NULL;
d336 10
a345 10
    if (sc->sc_pass_filt.bf_insns != 0) {
	free(sc->sc_pass_filt.bf_insns, M_DEVBUF, 0);
	sc->sc_pass_filt.bf_insns = 0;
	sc->sc_pass_filt.bf_len = 0;
    }
    if (sc->sc_active_filt.bf_insns != 0) {
	free(sc->sc_active_filt.bf_insns, M_DEVBUF, 0);
	sc->sc_active_filt.bf_insns = 0;
	sc->sc_active_filt.bf_len = 0;
    }
d348 4
a351 4
    if (sc->sc_comp != 0) {
	free(sc->sc_comp, M_DEVBUF, 0);
	sc->sc_comp = 0;
    }
d362 6
a367 6
    int s, error, flags, mru, npx;
    u_int nb;
    struct ppp_option_data *odp;
    struct compressor **cp;
    struct npioctl *npi;
    time_t t;
d369 3
a371 3
    struct bpf_program *bp, *nbp;
    struct bpf_insn *newcode, *oldcode;
    int newcodelen;
d374 1
a374 1
    u_char ccp_option[CCP_MAX_OPTION_LENGTH];
d377 18
a394 18
    switch (cmd) {
    case FIONREAD:
	*(int *)data = mq_len(&sc->sc_inq);
	break;

    case PPPIOCGUNIT:
	*(int *)data = sc->sc_unit;	/* XXX */
	break;

    case PPPIOCGFLAGS:
	*(u_int *)data = sc->sc_flags;
	break;

    case PPPIOCSFLAGS:
	if ((error = suser(p, 0)) != 0)
	    return (error);
	flags = *(int *)data & SC_MASK;
	s = splsoftnet();
d396 2
a397 2
	if (sc->sc_flags & SC_CCP_OPEN && !(flags & SC_CCP_OPEN))
	    ppp_ccp_closed(sc);
d399 4
a402 4
	splnet();
	sc->sc_flags = (sc->sc_flags & ~SC_MASK) | flags;
	splx(s);
	break;
d404 11
a414 11
    case PPPIOCSMRU:
	if ((error = suser(p, 0)) != 0)
	    return (error);
	mru = *(int *)data;
	if (mru >= PPP_MRU && mru <= PPP_MAXMRU)
	    sc->sc_mru = mru;
	break;

    case PPPIOCGMRU:
	*(int *)data = sc->sc_mru;
	break;
d417 9
a425 9
    case PPPIOCSMAXCID:
	if ((error = suser(p, 0)) != 0)
	    return (error);
	if (sc->sc_comp) {
	    s = splsoftnet();
	    sl_compress_setup(sc->sc_comp, *(int *)data);
	    splx(s);
	}
	break;
d428 5
a432 5
    case PPPIOCXFERUNIT:
	if ((error = suser(p, 0)) != 0)
	    return (error);
	sc->sc_xfer = p->p_p->ps_pid;
	break;
d435 81
a515 33
    case PPPIOCSCOMPRESS:
	if ((error = suser(p, 0)) != 0)
	    return (error);
	odp = (struct ppp_option_data *) data;
	nb = odp->length;
	if (nb > sizeof(ccp_option))
	    nb = sizeof(ccp_option);
	if ((error = copyin(odp->ptr, ccp_option, nb)) != 0)
	    return (error);
	if (ccp_option[1] < 2)	/* preliminary check on the length byte */
	    return (EINVAL);
	for (cp = ppp_compressors; *cp != NULL; ++cp)
	    if ((*cp)->compress_proto == ccp_option[0]) {
		/*
		 * Found a handler for the protocol - try to allocate
		 * a compressor or decompressor.
		 */
		error = 0;
		if (odp->transmit) {
		    s = splsoftnet();
		    if (sc->sc_xc_state != NULL)
			(*sc->sc_xcomp->comp_free)(sc->sc_xc_state);
		    sc->sc_xcomp = *cp;
		    sc->sc_xc_state = (*cp)->comp_alloc(ccp_option, nb);
		    if (sc->sc_xc_state == NULL) {
			if (sc->sc_flags & SC_DEBUG)
			    printf("%s: comp_alloc failed\n",
				sc->sc_if.if_xname);
			error = ENOBUFS;
		    }
		    splnet();
		    sc->sc_flags &= ~SC_COMP_RUN;
		    splx(s);
d517 13
a529 23
		    s = splsoftnet();
		    if (sc->sc_rc_state != NULL)
			(*sc->sc_rcomp->decomp_free)(sc->sc_rc_state);
		    sc->sc_rcomp = *cp;
		    sc->sc_rc_state = (*cp)->decomp_alloc(ccp_option, nb);
		    if (sc->sc_rc_state == NULL) {
			if (sc->sc_flags & SC_DEBUG)
			    printf("%s: decomp_alloc failed\n",
				sc->sc_if.if_xname);
			error = ENOBUFS;
		    }
		    splnet();
		    sc->sc_flags &= ~SC_DECOMP_RUN;
		    splx(s);
		}
		return (error);
	    }
	if (sc->sc_flags & SC_DEBUG)
	    printf("%s: no compressor for [%x %x %x], %x\n",
		sc->sc_if.if_xname, ccp_option[0], ccp_option[1],
		ccp_option[2], nb);
	return (EINVAL);	/* no handler found */
#endif /* PPP_COMPRESS */
d531 1
a531 16
    case PPPIOCGNPMODE:
    case PPPIOCSNPMODE:
	npi = (struct npioctl *) data;
	switch (npi->protocol) {
	case PPP_IP:
	    npx = NP_IP;
	    break;
	default:
	    return EINVAL;
	}
	if (cmd == PPPIOCGNPMODE) {
	    npi->mode = sc->sc_npmode[npx];
	} else {
	    if ((error = suser(p, 0)) != 0)
		return (error);
	    if (npi->mode != sc->sc_npmode[npx]) {
d533 3
a535 5
		sc->sc_npmode[npx] = npi->mode;
		if (npi->mode != NPMODE_QUEUE) {
		    ppp_requeue(sc);
		    (*sc->sc_start)(sc);
		}
d537 1
a537 11
	    }
	}
	break;

    case PPPIOCGIDLE:
	s = splsoftnet();
	t = time_second;
	((struct ppp_idle *)data)->xmit_idle = t - sc->sc_last_sent;
	((struct ppp_idle *)data)->recv_idle = t - sc->sc_last_recv;
	splx(s);
	break;
d540 30
a569 29
    case PPPIOCSPASS:
    case PPPIOCSACTIVE:
	nbp = (struct bpf_program *) data;
	if ((unsigned) nbp->bf_len > BPF_MAXINSNS)
	    return EINVAL;
	newcodelen = nbp->bf_len * sizeof(struct bpf_insn);
	if (nbp->bf_len != 0) {
	    newcode = mallocarray(nbp->bf_len, sizeof(struct bpf_insn),
		M_DEVBUF, M_WAITOK);
	    if ((error = copyin((caddr_t)nbp->bf_insns, (caddr_t)newcode,
			       newcodelen)) != 0) {
		free(newcode, M_DEVBUF, 0);
		return error;
	    }
	    if (!bpf_validate(newcode, nbp->bf_len)) {
		free(newcode, M_DEVBUF, 0);
		return EINVAL;
	    }
	} else
	    newcode = 0;
	bp = (cmd == PPPIOCSPASS)? &sc->sc_pass_filt: &sc->sc_active_filt;
	oldcode = bp->bf_insns;
	s = splnet();
	bp->bf_len = nbp->bf_len;
	bp->bf_insns = newcode;
	splx(s);
	if (oldcode != 0)
	    free(oldcode, M_DEVBUF, 0);
	break;
d572 4
a575 4
    default:
	return (-1);
    }
    return (0);
d584 4
a587 4
    struct ppp_softc *sc = ifp->if_softc;
    struct ifaddr *ifa = (struct ifaddr *)data;
    struct ifreq *ifr = (struct ifreq *)data;
    struct ppp_stats *psp;
d589 1
a589 1
    struct ppp_comp_stats *pcp;
d591 1
a591 1
    int s = splnet(), error = 0;
d593 28
a620 28
    switch (cmd) {
    case SIOCSIFFLAGS:
	if ((ifp->if_flags & IFF_RUNNING) == 0)
	    ifp->if_flags &= ~IFF_UP;
	break;

    case SIOCSIFADDR:
	if (ifa->ifa_addr->sa_family != AF_INET)
	    error = EAFNOSUPPORT;
	break;

    case SIOCSIFDSTADDR:
	if (ifa->ifa_addr->sa_family != AF_INET)
	    error = EAFNOSUPPORT;
	break;

    case SIOCSIFMTU:
	sc->sc_if.if_mtu = ifr->ifr_mtu;
	break;

    case SIOCADDMULTI:
    case SIOCDELMULTI:
	break;

    case SIOCGPPPSTATS:
	psp = &((struct ifpppstatsreq *) data)->stats;
	bzero(psp, sizeof(*psp));
	psp->p = sc->sc_stats;
d622 12
a633 10
	if (sc->sc_comp) {
	    psp->vj.vjs_packets = sc->sc_comp->sls_packets;
	    psp->vj.vjs_compressed = sc->sc_comp->sls_compressed;
	    psp->vj.vjs_searches = sc->sc_comp->sls_searches;
	    psp->vj.vjs_misses = sc->sc_comp->sls_misses;
	    psp->vj.vjs_uncompressedin = sc->sc_comp->sls_uncompressedin;
	    psp->vj.vjs_compressedin = sc->sc_comp->sls_compressedin;
	    psp->vj.vjs_errorin = sc->sc_comp->sls_errorin;
	    psp->vj.vjs_tossed = sc->sc_comp->sls_tossed;
	}
d635 1
a635 1
	break;
d638 8
a645 8
    case SIOCGPPPCSTATS:
	pcp = &((struct ifpppcstatsreq *) data)->stats;
	bzero(pcp, sizeof(*pcp));
	if (sc->sc_xc_state != NULL)
	    (*sc->sc_xcomp->comp_stat)(sc->sc_xc_state, &pcp->c);
	if (sc->sc_rc_state != NULL)
	    (*sc->sc_rcomp->decomp_stat)(sc->sc_rc_state, &pcp->d);
	break;
d648 5
a652 5
    default:
	error = ENOTTY;
    }
    splx(s);
    return (error);
d663 12
a674 12
    struct ppp_softc *sc = ifp->if_softc;
    int protocol, address, control;
    u_char *cp;
    int s, error;
    enum NPmode mode;
    int len;

    if (sc->sc_devp == NULL || (ifp->if_flags & IFF_RUNNING) == 0
	|| ((ifp->if_flags & IFF_UP) == 0 && dst->sa_family != AF_UNSPEC)) {
	error = ENETDOWN;	/* sort of */
	goto bad;
    }
d677 6
a682 5
    if (ifp->if_rdomain != rtable_l2(m0->m_pkthdr.ph_rtableid)) {
	printf("%s: trying to send packet on wrong domain. "
	    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname, ifp->if_rdomain,
	    rtable_l2(m0->m_pkthdr.ph_rtableid), dst->sa_family);
    }
d685 22
a706 58
    /*
     * Compute PPP header.
     */
    switch (dst->sa_family) {
    case AF_INET:
	address = PPP_ALLSTATIONS;
	control = PPP_UI;
	protocol = PPP_IP;
	mode = sc->sc_npmode[NP_IP];
	break;
    case AF_UNSPEC:
	address = PPP_ADDRESS(dst->sa_data);
	control = PPP_CONTROL(dst->sa_data);
	protocol = PPP_PROTOCOL(dst->sa_data);
	mode = NPMODE_PASS;
	break;
    default:
	printf("%s: af%d not supported\n", ifp->if_xname, dst->sa_family);
	error = EAFNOSUPPORT;
	goto bad;
    }

    /*
     * Drop this packet, or return an error, if necessary.
     */
    if (mode == NPMODE_ERROR) {
	error = ENETDOWN;
	goto bad;
    }
    if (mode == NPMODE_DROP) {
	error = 0;
	goto bad;
    }

    /*
     * Add PPP header.  If no space in first mbuf, allocate another.
     * (This assumes M_LEADINGSPACE is always 0 for a cluster mbuf.)
     */
    M_PREPEND(m0, PPP_HDRLEN, M_DONTWAIT);
    if (m0 == NULL) {
	error = ENOBUFS;
	goto bad;
    }

    cp = mtod(m0, u_char *);
    *cp++ = address;
    *cp++ = control;
    *cp++ = protocol >> 8;
    *cp++ = protocol & 0xff;

    if ((m0->m_flags & M_PKTHDR) == 0)
	    panic("mbuf packet without packet header!");
    len = m0->m_pkthdr.len;

    if (sc->sc_flags & SC_LOG_OUTPKT) {
	printf("%s output: ", ifp->if_xname);
	pppdumpm(m0);
    }
a707 2
    if ((protocol & 0x8000) == 0) {
#if NBPFILTER > 0
d709 1
a709 2
	 * Apply the pass and active filters to the packet,
	 * but only if it is a data packet.
d711 7
a717 6
	*mtod(m0, u_char *) = 1;	/* indicates outbound */
	if (sc->sc_pass_filt.bf_insns != 0
	    && bpf_filter(sc->sc_pass_filt.bf_insns, (u_char *) m0,
			  len, 0) == 0) {
	    error = 0;		/* drop this packet */
	    goto bad;
d721 2
a722 1
	 * Update the time we sent the most recent packet.
d724 20
a743 3
	if (sc->sc_active_filt.bf_insns == 0
	    || bpf_filter(sc->sc_active_filt.bf_insns, (u_char *) m0, len, 0))
	    sc->sc_last_sent = time_second;
d745 23
a767 1
	*mtod(m0, u_char *) = address;
d769 4
a772 4
	/*
	 * Update the time we sent the most recent packet.
	 */
	sc->sc_last_sent = time_second;
d774 1
a774 1
    }
d777 5
a781 5
    /*
     * See if bpf wants to look at the packet.
     */
    if (sc->sc_bpf)
	bpf_mtap(sc->sc_bpf, m0, BPF_DIRECTION_OUT);
d784 18
a801 16
    /*
     * Put the packet on the appropriate queue.
     */
    s = splsoftnet();
    if (mode == NPMODE_QUEUE) {
	/* XXX we should limit the number of packets on this queue */
	*sc->sc_npqtail = m0;
	m0->m_nextpkt = NULL;
	sc->sc_npqtail = &m0->m_nextpkt;
    } else {
	IFQ_ENQUEUE(&sc->sc_if.if_snd, m0, error);
	if (error) {
	    splx(s);
	    sc->sc_if.if_oerrors++;
	    sc->sc_stats.ppp_oerrors++;
	    return (error);
d803 2
a804 4
	(*sc->sc_start)(sc);
    }
    ifp->if_opackets++;
    ifp->if_obytes += len;
d806 2
a807 2
    splx(s);
    return (0);
d810 2
a811 2
    m_freem(m0);
    return (error);
d822 14
a835 3
    struct mbuf *m, **mpp;
    enum NPmode mode;
    int error;
d837 25
a861 9
    splsoftassert(IPL_SOFTNET);

    for (mpp = &sc->sc_npqueue; (m = *mpp) != NULL; ) {
	switch (PPP_PROTOCOL(mtod(m, u_char *))) {
	case PPP_IP:
	    mode = sc->sc_npmode[NP_IP];
	    break;
	default:
	    mode = NPMODE_PASS;
d863 1
a863 27

	switch (mode) {
	case NPMODE_PASS:
	    /*
	     * This packet can now go on one of the queues to be sent.
	     */
	    *mpp = m->m_nextpkt;
	    m->m_nextpkt = NULL;
	    IFQ_ENQUEUE(&sc->sc_if.if_snd, m, error);
	    if (error) {
		sc->sc_if.if_oerrors++;
		sc->sc_stats.ppp_oerrors++;
	    }
	    break;

	case NPMODE_DROP:
	case NPMODE_ERROR:
	    *mpp = m->m_nextpkt;
	    m_freem(m);
	    break;

	case NPMODE_QUEUE:
	    mpp = &m->m_nextpkt;
	    break;
	}
    }
    sc->sc_npqtail = mpp;
d873 1
a873 1
    int s = splnet();
d875 3
a877 3
    sc->sc_flags &= ~SC_TBUSY;
    schednetisr(NETISR_PPP);
    splx(s);
d889 13
a901 22
    struct mbuf *m, *mp;
    u_char *cp;
    int address, control, protocol;

    /*
     * Grab a packet to send: first try the fast queue, then the
     * normal queue.
     */
    IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
    if (m == NULL)
      return NULL;

    ++sc->sc_stats.ppp_opackets;

    /*
     * Extract the ppp header of the new packet.
     * The ppp header will be in one mbuf.
     */
    cp = mtod(m, u_char *);
    address = PPP_ADDRESS(cp);
    control = PPP_CONTROL(cp);
    protocol = PPP_PROTOCOL(cp);
a902 3
    switch (protocol) {
    case PPP_IP:
#ifdef VJC
d904 2
a905 1
	 * If the packet is a TCP/IP packet, see if we can compress it.
d907 45
a951 27
	if ((sc->sc_flags & SC_COMP_TCP) && sc->sc_comp != NULL) {
	    struct ip *ip;
	    int type;

	    mp = m;
	    ip = (struct ip *) (cp + PPP_HDRLEN);
	    if (mp->m_len <= PPP_HDRLEN) {
		mp = mp->m_next;
		if (mp == NULL)
		    break;
		ip = mtod(mp, struct ip *);
	    }
	    /* this code assumes the IP/TCP header is in one non-shared mbuf */
	    if (ip->ip_p == IPPROTO_TCP) {
		type = sl_compress_tcp(mp, ip, sc->sc_comp,
				       !(sc->sc_flags & SC_NO_TCP_CCID));
		switch (type) {
		case TYPE_UNCOMPRESSED_TCP:
		    protocol = PPP_VJC_UNCOMP;
		    break;
		case TYPE_COMPRESSED_TCP:
		    protocol = PPP_VJC_COMP;
		    cp = mtod(m, u_char *);
		    cp[0] = address;	/* header has moved */
		    cp[1] = control;
		    cp[2] = 0;
		    break;
a952 3
		cp[3] = protocol;	/* update protocol in PPP header */
	    }
	}
d954 1
a954 1
	break;
d957 3
a959 3
    case PPP_CCP:
	ppp_ccp(sc, m, 0);
	break;
d961 1
a961 1
    }
d964 26
a989 22
    if (protocol != PPP_LCP && protocol != PPP_CCP
	&& sc->sc_xc_state && (sc->sc_flags & SC_COMP_RUN)) {
	struct mbuf *mcomp = NULL;
	int slen;

	slen = 0;
	for (mp = m; mp != NULL; mp = mp->m_next)
	    slen += mp->m_len;
	(*sc->sc_xcomp->compress)
	    (sc->sc_xc_state, &mcomp, m, slen,
	     (sc->sc_flags & SC_CCP_UP ? sc->sc_if.if_mtu + PPP_HDRLEN : 0));
	if (mcomp != NULL) {
	    if (sc->sc_flags & SC_CCP_UP) {
		/* Send the compressed packet instead of the original. */
		m_freem(m);
		m = mcomp;
		cp = mtod(m, u_char *);
		protocol = cp[3];
	    } else {
		/* Can't transmit compressed packets until CCP is up. */
		m_freem(mcomp);
	    }
a990 1
    }
d993 19
a1011 19
    /*
     * Compress the address/control and protocol, if possible.
     */
    if (sc->sc_flags & SC_COMP_AC && address == PPP_ALLSTATIONS &&
	control == PPP_UI && protocol != PPP_ALLSTATIONS &&
	protocol != PPP_LCP) {
	/* can compress address/control */
	m->m_data += 2;
	m->m_len -= 2;
    }
    if (sc->sc_flags & SC_COMP_PROT && protocol < 0xFF) {
	/* can compress protocol */
	if (mtod(m, u_char *) == cp) {
	    cp[2] = cp[1];	/* move address/control up */
	    cp[1] = cp[0];
	}
	++m->m_data;
	--m->m_len;
    }
d1013 1
a1013 1
    return m;
d1022 21
a1042 20
    struct ppp_softc *sc;
    int s;
    struct ppp_pkt *pkt;
    struct mbuf *m;

    splsoftassert(IPL_SOFTNET);

    LIST_FOREACH(sc, &ppp_softc_list, sc_list) {
	if (!(sc->sc_flags & SC_TBUSY)
	    && (!IFQ_IS_EMPTY(&sc->sc_if.if_snd))) {
	    s = splnet();
	    sc->sc_flags |= SC_TBUSY;
	    splx(s);
	    (*sc->sc_start)(sc);
	}
	while ((pkt = ppp_pkt_dequeue(&sc->sc_rawq)) != NULL) {
	    m = ppp_pkt_mbuf(pkt);
	    if (m == NULL)
		continue;
	    ppp_inproc(sc, m);
a1043 1
    }
d1054 3
a1056 16
    u_char *dp, *ep;
    struct mbuf *mp;
    int slen, s;

    /*
     * Get a pointer to the data after the PPP header.
     */
    if (m->m_len <= PPP_HDRLEN) {
	mp = m->m_next;
	if (mp == NULL)
	    return;
	dp = mtod(mp, u_char *);
    } else {
	mp = m;
	dp = mtod(mp, u_char *) + PPP_HDRLEN;
    }
d1058 70
a1127 10
    ep = mtod(mp, u_char *) + mp->m_len;
    if (dp + CCP_HDRLEN > ep)
	return;
    slen = CCP_LENGTH(dp);
    if (dp + slen > ep) {
	if (sc->sc_flags & SC_DEBUG)
	    printf("if_ppp/ccp: not enough data in mbuf (%p+%x > %p+%x)\n",
		dp, slen, mtod(mp, u_char *), mp->m_len);
	return;
    }
d1129 18
a1146 53
    switch (CCP_CODE(dp)) {
    case CCP_CONFREQ:
    case CCP_TERMREQ:
    case CCP_TERMACK:
	/* CCP must be going down - disable compression */
	if (sc->sc_flags & SC_CCP_UP) {
	    s = splnet();
	    sc->sc_flags &= ~(SC_CCP_UP | SC_COMP_RUN | SC_DECOMP_RUN);
	    splx(s);
	}
	break;

    case CCP_CONFACK:
	if (sc->sc_flags & SC_CCP_OPEN && !(sc->sc_flags & SC_CCP_UP)
	    && slen >= CCP_HDRLEN + CCP_OPT_MINLEN
	    && slen >= CCP_OPT_LENGTH(dp + CCP_HDRLEN) + CCP_HDRLEN) {
	    if (!rcvd) {
		/* we're agreeing to send compressed packets. */
		if (sc->sc_xc_state != NULL
		    && (*sc->sc_xcomp->comp_init)
			(sc->sc_xc_state, dp + CCP_HDRLEN, slen - CCP_HDRLEN,
			 sc->sc_unit, 0, sc->sc_flags & SC_DEBUG)) {
		    s = splnet();
		    sc->sc_flags |= SC_COMP_RUN;
		    splx(s);
		}
	    } else {
		/* peer is agreeing to send compressed packets. */
		if (sc->sc_rc_state != NULL
		    && (*sc->sc_rcomp->decomp_init)
			(sc->sc_rc_state, dp + CCP_HDRLEN, slen - CCP_HDRLEN,
			 sc->sc_unit, 0, sc->sc_mru,
			 sc->sc_flags & SC_DEBUG)) {
		    s = splnet();
		    sc->sc_flags |= SC_DECOMP_RUN;
		    sc->sc_flags &= ~(SC_DC_ERROR | SC_DC_FERROR);
		    splx(s);
		}
	    }
	}
	break;

    case CCP_RESETACK:
	if (sc->sc_flags & SC_CCP_UP) {
	    if (!rcvd) {
		if (sc->sc_xc_state && (sc->sc_flags & SC_COMP_RUN))
		    (*sc->sc_xcomp->comp_reset)(sc->sc_xc_state);
	    } else {
		if (sc->sc_rc_state && (sc->sc_flags & SC_DECOMP_RUN)) {
		    (*sc->sc_rcomp->decomp_reset)(sc->sc_rc_state);
		    s = splnet();
		    sc->sc_flags &= ~SC_DC_ERROR;
		    splx(s);
d1148 1
a1148 1
	    }
a1149 2
	break;
    }
d1158 8
a1165 8
    if (sc->sc_xc_state) {
	(*sc->sc_xcomp->comp_free)(sc->sc_xc_state);
	sc->sc_xc_state = NULL;
    }
    if (sc->sc_rc_state) {
	(*sc->sc_rcomp->decomp_free)(sc->sc_rc_state);
	sc->sc_rc_state = NULL;
    }
d1178 3
a1180 3
    pkt->p_hdr.ph_errmark = lost;
    if (ppp_pkt_enqueue(&sc->sc_rawq, pkt) == 0)
	schednetisr(NETISR_PPP);
d1193 28
a1220 6
    struct ifnet *ifp = &sc->sc_if;
    int s, ilen, xlen, proto, rv;
    u_char *cp, adrs, ctrl;
    struct mbuf *mp, *dmp = NULL;
    u_char *iphdr;
    u_int hlen;
d1222 22
a1243 1
    sc->sc_stats.ppp_ipackets++;
d1245 18
a1262 38
    if (sc->sc_flags & SC_LOG_INPKT) {
	ilen = 0;
	for (mp = m; mp != NULL; mp = mp->m_next)
	    ilen += mp->m_len;
	printf("%s: got %d bytes\n", ifp->if_xname, ilen);
	pppdumpm(m);
    }

    cp = mtod(m, u_char *);
    adrs = PPP_ADDRESS(cp);
    ctrl = PPP_CONTROL(cp);
    proto = PPP_PROTOCOL(cp);

    if (m->m_flags & M_ERRMARK) {
	m->m_flags &= ~M_ERRMARK;
	s = splnet();
	sc->sc_flags |= SC_VJ_RESET;
	splx(s);
    }

#ifdef PPP_COMPRESS
    /*
     * Decompress this packet if necessary, update the receiver's
     * dictionary, or take appropriate action on a CCP packet.
     */
    if (proto == PPP_COMP && sc->sc_rc_state && (sc->sc_flags & SC_DECOMP_RUN)
	&& !(sc->sc_flags & SC_DC_ERROR) && !(sc->sc_flags & SC_DC_FERROR)) {
	/* decompress this packet */
	rv = (*sc->sc_rcomp->decompress)(sc->sc_rc_state, m, &dmp);
	if (rv == DECOMP_OK) {
	    m_freem(m);
	    if (dmp == NULL) {
		/* no error, but no decompressed packet produced */
		return;
	    }
	    m = dmp;
	    cp = mtod(m, u_char *);
	    proto = PPP_PROTOCOL(cp);
d1265 6
a1270 22
	    /*
	     * An error has occurred in decompression.
	     * Pass the compressed packet up to pppd, which may take
	     * CCP down or issue a Reset-Req.
	     */
	    if (sc->sc_flags & SC_DEBUG)
		printf("%s: decompress failed %d\n", ifp->if_xname, rv);
	    s = splnet();
	    sc->sc_flags |= SC_VJ_RESET;
	    if (rv == DECOMP_ERROR)
		sc->sc_flags |= SC_DC_ERROR;
	    else
		sc->sc_flags |= SC_DC_FERROR;
	    splx(s);
	}

    } else {
	if (sc->sc_rc_state && (sc->sc_flags & SC_DECOMP_RUN)) {
	    (*sc->sc_rcomp->incomp)(sc->sc_rc_state, m);
	}
	if (proto == PPP_CCP) {
	    ppp_ccp(sc, m, 1);
a1271 1
    }
d1274 3
a1276 3
    ilen = 0;
    for (mp = m; mp != NULL; mp = mp->m_next)
	ilen += mp->m_len;
d1279 12
a1290 1
    if (sc->sc_flags & SC_VJ_RESET) {
d1292 1
a1292 2
	 * If we've missed a packet, we must toss subsequent compressed
	 * packets which don't have an explicit connection ID.
d1294 15
a1308 6
	if (sc->sc_comp)
	    sl_uncompress_tcp(NULL, 0, TYPE_ERROR, sc->sc_comp);
	s = splnet();
	sc->sc_flags &= ~SC_VJ_RESET;
	splx(s);
    }
d1310 24
a1333 41
    /*
     * See if we have a VJ-compressed packet to uncompress.
     */
    if (proto == PPP_VJC_COMP) {
	if ((sc->sc_flags & SC_REJ_COMP_TCP) || sc->sc_comp == 0)
	    goto bad;

	xlen = sl_uncompress_tcp_core(cp + PPP_HDRLEN, m->m_len - PPP_HDRLEN,
				      ilen - PPP_HDRLEN, TYPE_COMPRESSED_TCP,
				      sc->sc_comp, &iphdr, &hlen);

	if (xlen <= 0) {
	    if (sc->sc_flags & SC_DEBUG)
		printf("%s: VJ uncompress failed on type comp\n",
		    ifp->if_xname);
	    goto bad;
	}

	/* Copy the PPP and IP headers into a new mbuf. */
	MGETHDR(mp, M_DONTWAIT, MT_DATA);
	if (mp == NULL)
	    goto bad;
	mp->m_len = 0;
	mp->m_next = NULL;
	if (hlen + PPP_HDRLEN > MHLEN) {
	    MCLGET(mp, M_DONTWAIT);
	    if (M_TRAILINGSPACE(mp) < hlen + PPP_HDRLEN) {
		m_freem(mp);
		goto bad;	/* lose if big headers and no clusters */
	    }
	}
	if (m->m_flags & M_PKTHDR)
		M_MOVE_HDR(mp, m);
	cp = mtod(mp, u_char *);
	cp[0] = adrs;
	cp[1] = ctrl;
	cp[2] = 0;
	cp[3] = PPP_IP;
	proto = PPP_IP;
	bcopy(iphdr, cp + PPP_HDRLEN, hlen);
	mp->m_len = hlen + PPP_HDRLEN;
d1335 35
a1369 33
	/*
	 * Trim the PPP and VJ headers off the old mbuf
	 * and stick the new and old mbufs together.
	 */
	m->m_data += PPP_HDRLEN + xlen;
	m->m_len -= PPP_HDRLEN + xlen;
	if (m->m_len <= M_TRAILINGSPACE(mp)) {
	    bcopy(mtod(m, u_char *), mtod(mp, u_char *) + mp->m_len, m->m_len);
	    mp->m_len += m->m_len;
	    mp->m_next = m_free(m);
	} else
	    mp->m_next = m;
	m = mp;
	ilen += hlen - xlen;

    } else if (proto == PPP_VJC_UNCOMP) {
	if ((sc->sc_flags & SC_REJ_COMP_TCP) || sc->sc_comp == 0)
	    goto bad;

	xlen = sl_uncompress_tcp_core(cp + PPP_HDRLEN, m->m_len - PPP_HDRLEN,
				      ilen - PPP_HDRLEN, TYPE_UNCOMPRESSED_TCP,
				      sc->sc_comp, &iphdr, &hlen);

	if (xlen < 0) {
	    if (sc->sc_flags & SC_DEBUG)
		printf("%s: VJ uncompress failed on type uncomp\n",
		    ifp->if_xname);
	    goto bad;
	}

	proto = PPP_IP;
	cp[3] = PPP_IP;
    }
d1372 2
a1373 2
    m->m_pkthdr.len = ilen;
    m->m_pkthdr.ph_ifidx = ifp->if_index;
d1375 2
a1376 2
    /* mark incoming routing table */
    m->m_pkthdr.ph_rtableid = ifp->if_rdomain;
d1378 1
a1378 1
    if ((proto & 0x8000) == 0) {
d1380 17
a1396 16
	/*
	 * See whether we want to pass this packet, and
	 * if it counts as link activity.
	 */
	adrs = *mtod(m, u_char *);	/* save address field */
	*mtod(m, u_char *) = 0;		/* indicate inbound */
	if (sc->sc_pass_filt.bf_insns != 0
	    && bpf_filter(sc->sc_pass_filt.bf_insns, (u_char *) m,
			  ilen, 0) == 0) {
	    /* drop this packet */
	    m_freem(m);
	    return;
	}
	if (sc->sc_active_filt.bf_insns == 0
	    || bpf_filter(sc->sc_active_filt.bf_insns, (u_char *) m, ilen, 0))
	    sc->sc_last_recv = time_second;
d1398 1
a1398 1
	*mtod(m, u_char *) = adrs;
d1400 4
a1403 4
	/*
	 * Record the time that we received this packet.
	 */
	sc->sc_last_recv = time_second;
d1405 1
a1405 1
    }
d1408 3
a1410 3
    /* See if bpf wants to look at the packet. */
    if (sc->sc_bpf)
	bpf_mtap(sc->sc_bpf, m, BPF_DIRECTION_IN);
d1413 49
a1461 21
    rv = 0;
    switch (proto) {
    case PPP_IP:
	/*
	 * IP packet - take off the ppp header and pass it up to IP.
	 */
	if ((ifp->if_flags & IFF_UP) == 0
	    || sc->sc_npmode[NP_IP] != NPMODE_PASS) {
	    /* interface is down - drop the packet. */
	    m_freem(m);
	    return;
	}
	m->m_pkthdr.len -= PPP_HDRLEN;
	m->m_data += PPP_HDRLEN;
	m->m_len -= PPP_HDRLEN;

	if (niq_enqueue(&ipintrq, m) != 0)
		rv = 0; /* failure */
	else
		rv = 1; /* ipintrq success */
	break;
d1463 5
a1467 33
    default:
	/*
	 * Some other protocol - place on input queue for read().
	 */
	if (mq_enqueue(&sc->sc_inq, m) != 0) {
		if_congestion();
		rv = 0; /* failure */
	} else
		rv = 2; /* input queue */
	break;
    }

    if (rv == 0) {
	/* failure */
	if (sc->sc_flags & SC_DEBUG)
	    printf("%s: input queue full\n", ifp->if_xname);
	ifp->if_iqdrops++;
	goto dropped;
    }

    ifp->if_ipackets++;
    ifp->if_ibytes += ilen;

    if (rv == 2)
	(*sc->sc_ctlp)(sc);

    return;

 bad:
    m_freem(m);
 dropped:
    sc->sc_if.if_ierrors++;
    sc->sc_stats.ppp_ierrors++;
d1475 25
a1499 23
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    struct mbuf *m;
    static char digits[] = "0123456789abcdef";

    for (m = m0; m; m = m->m_next) {
	int l = m->m_len;
	u_char *rptr = mtod(m, u_char *);

	while (l--) {
	    if (bp > buf + sizeof(buf) - 4)
		goto done;
	    *bp++ = digits[*rptr >> 4]; /* convert byte to ascii hex */
	    *bp++ = digits[*rptr++ & 0xf];
	}

	if (m->m_next) {
	    if (bp > buf + sizeof(buf) - 3)
		goto done;
	    *bp++ = '|';
	} else
	    *bp++ = ' ';
    }
d1501 4
a1504 4
    if (m)
	*bp++ = '>';
    *bp = 0;
    printf("%s\n", buf);
d1546 1
a1546 1
 
@


1.92
log
@get rid of the "fastq", which is where this driver puts ip packets
with IPTOS_LOWDELAY set.

this complicates efforts to clean up the send queue, and is probably
better done by queues in pf than unconditionally in a single driver.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.91 2015/10/25 11:58:11 mpi Exp $	*/
d320 1
a320 2
    while ((m = mq_dequeue(&sc->sc_inq)) != NULL)
	m_freem(m);
@


1.91
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.90 2015/10/12 13:17:58 dlg Exp $	*/
a165 1
#define M_HIGHPRI	M_PROTO1	/* output packet for sc_fastq */
a227 1
    IFQ_SET_MAXLEN(&sc->sc_fastq, IFQ_MAXLEN);
a321 6
    for (;;) {
	IF_DEQUEUE(&sc->sc_fastq, m);
	if (m == NULL)
	    break;
	m_freem(m);
    }
a651 2
    struct ip *ip;
    struct ifqueue *ifq;
a671 1
    m0->m_flags &= ~M_HIGHPRI;
a677 8

	/*
	 * If this packet has the "low delay" bit set in the IP header,
	 * put it on the fastq instead.
	 */
	ip = mtod(m0, struct ip *);
	if (ip->ip_tos & IPTOS_LOWDELAY)
	    m0->m_flags |= M_HIGHPRI;
d776 1
a776 13
	if (m0->m_flags & M_HIGHPRI) {
	    ifq = &sc->sc_fastq;
	    if (IF_QFULL(ifq) && dst->sa_family != AF_UNSPEC) {
		IF_DROP(ifq);
		m_freem(m0);
		error = ENOBUFS;
	    }
	    else {
		IF_ENQUEUE(ifq, m0);
		error = 0;
	    }
	} else
	    IFQ_ENQUEUE(&sc->sc_if.if_snd, m0, error);
a804 1
    struct ifqueue *ifq;
d826 1
a826 13
	    if (m->m_flags & M_HIGHPRI) {
		ifq = &sc->sc_fastq;
		if (IF_QFULL(ifq)) {
		    IF_DROP(ifq);
		    m_freem(m);
		    error = ENOBUFS;
		}
		else {
		    IF_ENQUEUE(ifq, m);
		    error = 0;
		}
	    } else
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m, error);
d878 1
a878 3
    IF_DEQUEUE(&sc->sc_fastq, m);
    if (m == NULL)
	IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
d1005 1
a1005 2
	    && (!IFQ_IS_EMPTY(&sc->sc_if.if_snd) ||
	    !IFQ_IS_EMPTY(&sc->sc_fastq))) {
@


1.90
log
@the pattr argument to IFQ_ENQUEUE is unused, so let's get rid of it.

also the comment above IFQ_ENQUEUE that says the pattr argument is unused.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.89 2015/10/05 19:05:09 uebayasi Exp $	*/
d226 1
a596 1
	ifa->ifa_rtrequest = p2p_rtrequest;
@


1.89
log
@Revert if_oqdrops accounting changes done in kernel, per request from mpi@@.

(Especially adding IF_DROP() after IFQ_ENQUEUE() was completely wrong because
IFQ_ENQUEUE() already does it.  Oops.)

After this revert, the situation becomes:

- if_snd.ifq_drops is incremented in either IFQ_ENQUEUE() or IF_DROP(), but
  it is not shown to userland, and

- if_data.ifi_oqdrops is shown to userland, but it is not incremented by
  anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d807 1
a807 1
	    IFQ_ENQUEUE(&sc->sc_if.if_snd, m0, NULL, error);
d870 1
a870 1
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m, NULL, error);
@


1.88
log
@Count IFQ_ENQUEUE() failure as output drop.

mpi@@ prefers checking IFQ_ENQUEUE() error, and this matches that.

OK dlg@@
@
text
@d806 1
a806 1
	} else {
a807 3
	    if (error)
		IF_DROP(&sc->sc_if.if_snd);
	}
d810 1
d869 1
a869 1
	    } else {
a870 3
		if (error)
		    IF_DROP(&sc->sc_if.if_snd);
	    }
d872 1
@


1.87
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.86 2015/07/08 07:21:50 mpi Exp $	*/
d806 1
a806 1
	} else
d808 3
a812 1
	    sc->sc_if.if_oerrors++;
d871 1
a871 1
	    } else
d873 3
a876 1
		sc->sc_if.if_oerrors++;
@


1.86
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.85 2015/06/16 11:09:39 mpi Exp $	*/
d333 3
a335 4
    if (sc->sc_togo != NULL) {
	m_freem(sc->sc_togo);
	sc->sc_togo = NULL;
    }
@


1.85
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.84 2015/06/03 00:50:09 dlg Exp $	*/
d1348 1
a1348 1
	    MFREE(m, mp->m_next);
@


1.84
log
@there's been a long standing issue in ppp on a tty/serial line where it allocates mbufs at IPL_SOFTTTY, which is above the IPL_NET the mbuf layer protects itself at.

recent improvements to diagnostics in pools and mbufs now panic
instead of letting these things silently corrupt.

this reworks the ppp handling in the tty layer so it has its own
private pool to allocate packet memory out of. these packets get
built and then queued for softnet to process. softnet dequeues the
packet and attaches it to mbufs as external storage before handing
it on to the rest of the stack.

this was reported on bugs@@ and tested by both Walter Daugherity and
Martin van den Nieuwelaar
ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.83 2015/05/13 10:42:46 jsg Exp $	*/
d1375 1
a1375 1
    m->m_pkthdr.rcvif = ifp;
@


1.83
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.82 2015/04/10 13:58:20 dlg Exp $	*/
d157 4
a160 12
/*
 * Some useful mbuf macros not in mbuf.h.
 */
#define M_IS_CLUSTER(m)	((m)->m_flags & M_EXT)

#define M_DATASTART(m)	\
	(M_IS_CLUSTER(m) ? (m)->m_ext.ext_buf : \
	    (m)->m_flags & M_PKTHDR ? (m)->m_pktdat : (m)->m_dat)

#define M_DATASIZE(m)	\
	(M_IS_CLUSTER(m) ? (m)->m_ext.ext_size : \
	    (m)->m_flags & M_PKTHDR ? MHLEN: MLEN)
d229 1
a229 1
    IFQ_SET_MAXLEN(&sc->sc_rawq, IFQ_MAXLEN);
d310 1
d319 2
a320 6
    for (;;) {
	IF_DEQUEUE(&sc->sc_rawq, m);
	if (m == NULL)
	    break;
	m_freem(m);
    }
d1044 2
a1045 1
    int s, s2;
a1049 1
    s = splsoftnet();	/* XXX - what's the point of this? see comment above */
d1054 1
a1054 1
	    s2 = splnet();
d1056 1
a1056 1
	    splx(s2);
d1059 2
a1060 4
	while (!IFQ_IS_EMPTY(&sc->sc_rawq)) {
	    s2 = splnet();
	    IF_DEQUEUE(&sc->sc_rawq, m);
	    splx(s2);
d1062 1
a1062 1
		break;
a1065 1
    splx(s);
d1188 1
a1188 1
ppppktin(struct ppp_softc *sc, struct mbuf *m, int lost)
d1190 3
a1192 7
    int s = splnet();

    if (lost)
	m->m_flags |= M_ERRMARK;
    IF_ENQUEUE(&sc->sc_rawq, m);
    schednetisr(NETISR_PPP);
    splx(s);
a1373 13
    /*
     * If the packet will fit in a header mbuf, don't waste a
     * whole cluster on it.
     */
    if (ilen <= MHLEN && M_IS_CLUSTER(m)) {
	MGETHDR(mp, M_DONTWAIT, MT_DATA);
	if (mp != NULL) {
	    m_copydata(m, 0, ilen, mtod(mp, caddr_t));
	    m_freem(m);
	    m = mp;
	    m->m_len = ilen;
	}
    }
d1514 92
@


1.82
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.81 2015/03/18 12:23:15 dlg Exp $	*/
d739 1
a739 1
    if (m0 == 0) {
@


1.81
log
@remove the congestion handling from struct ifqueue.

its only used for the ip and ip6 network stack input queues, so it
seems unfair that every instance of ifqueue has to carry a pointer
around for this specific use case.

this moves the congestion marker to a kernel global. if we detect
that we're congested, we assume the whole system is busy and punish
all input queues.

marking a system as congested is done by setting the global to the
current value of ticks. as the system moves away from that value,
it moves away from being congested until the comparison fails.

written at s2k15
ok henning@@ beck@@ bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.80 2014/12/19 17:14:39 tedu Exp $	*/
d235 1
a235 1
    IFQ_SET_MAXLEN(&sc->sc_inq, IFQ_MAXLEN);
d332 1
a332 4
    for (;;) {
	IF_DEQUEUE(&sc->sc_inq, m);
	if (m == NULL)
	    break;
a333 1
    }
d397 1
a397 1
	*(int *)data = IFQ_LEN(&sc->sc_inq);
a1223 1
    struct ifqueue *inq;
d1460 5
a1464 2
	schednetisr(NETISR_IP);
	inq = &ipintrq;
d1471 5
a1475 2
	inq = &sc->sc_inq;
	rv = 1;
d1479 2
a1480 7
    /*
     * Put the packet on the appropriate input queue.
     */
    s = splnet();
    if (IF_QFULL(inq)) {
	IF_DROP(inq);
	splx(s);
d1484 1
a1484 2
	if_congestion();
	goto bad;
d1486 1
a1486 2
    IF_ENQUEUE(inq, m);
    splx(s);
d1490 1
a1490 1
    if (rv)
d1497 1
@


1.80
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.79 2014/12/13 21:05:33 doug Exp $	*/
d1488 1
a1488 2
	if (!inq->ifq_congestion)
		if_congestion(inq);
@


1.79
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.78 2014/12/05 15:50:04 mpi Exp $	*/
a128 1
#ifdef INET
a130 7
#else
#ifdef _KERNEL
#ifdef VJC
#error ppp device with VJC assumes INET
#endif
#endif
#endif
a699 1
#ifdef INET
a713 1
#endif
a1451 1
#ifdef INET
a1467 1
#endif
@


1.78
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.77 2014/11/20 14:51:42 krw Exp $	*/
d565 3
a567 2
	if (newcodelen != 0) {
	    newcode = malloc(newcodelen, M_DEVBUF, M_WAITOK);
@


1.77
log
@Yet more #include de-duplication.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.76 2014/07/22 11:06:09 mpi Exp $	*/
d123 1
@


1.76
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.75 2014/07/12 18:44:22 tedu Exp $	*/
a139 3
#if NBPFILTER > 0
#include <net/bpf.h>
#endif
@


1.75
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.74 2014/05/05 11:44:33 mpi Exp $	*/
a129 1
#include <netinet/in_systm.h>
@


1.74
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.73 2014/04/19 12:08:10 henning Exp $	*/
d277 1
a277 1
    free(sc, M_DEVBUF);
d370 1
a370 1
	free(sc->sc_pass_filt.bf_insns, M_DEVBUF);
d375 1
a375 1
	free(sc->sc_active_filt.bf_insns, M_DEVBUF);
d382 1
a382 1
	free(sc->sc_comp, M_DEVBUF);
d572 1
a572 1
		free(newcode, M_DEVBUF);
d576 1
a576 1
		free(newcode, M_DEVBUF);
d588 1
a588 1
	    free(oldcode, M_DEVBUF);
@


1.73
log
@remove altq special casing.
big WTF regarding the fastq use there while verifying w/ claudio, but
that's for the ppp maintainer and unrelated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.71 2013/10/23 15:12:42 mpi Exp $	*/
d622 1
@


1.72
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d822 1
a822 5
	if ((m0->m_flags & M_HIGHPRI)
#ifdef ALTQ
	    && ALTQ_IS_ENABLED(&sc->sc_if.if_snd) == 0
#endif
	    ) {
d885 1
a885 5
	    if ((m->m_flags & M_HIGHPRI)
#ifdef ALTQ
		&& ALTQ_IS_ENABLED(&sc->sc_if.if_snd) == 0
#endif
		) {
@


1.71
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.70 2013/10/19 14:46:30 mpi Exp $	*/
d697 1
a697 1
    if (ifp->if_rdomain != rtable_l2(m0->m_pkthdr.rdomain)) {
d700 1
a700 1
	    rtable_l2(m0->m_pkthdr.rdomain), dst->sa_family);
d1432 2
a1433 2
    /* mark incoming routing domain */
    m->m_pkthdr.rdomain = ifp->if_rdomain;
@


1.70
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.69 2013/03/28 16:55:27 deraadt Exp $	*/
a130 1
#include <netinet/in_var.h>
@


1.69
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.68 2013/03/26 13:19:26 mpi Exp $	*/
a635 13
	if (ifr == 0) {
	    error = EAFNOSUPPORT;
	    break;
	}
	switch(ifr->ifr_addr.sa_family) {
#ifdef INET
	case AF_INET:
	    break;
#endif
	default:
	    error = EAFNOSUPPORT;
	    break;
	}
@


1.68
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.67 2012/11/29 22:56:08 yasuoka Exp $	*/
a152 1
#include <machine/cpu.h>
@


1.67
log
@Delete needless check for NULL.  From Michael W. Bombardieri.

no binary changes on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.66 2012/11/26 20:21:14 markus Exp $	*/
d247 4
a250 4
    IFQ_SET_MAXLEN(&sc->sc_if.if_snd, ifqmaxlen);
    IFQ_SET_MAXLEN(&sc->sc_inq, ifqmaxlen);
    IFQ_SET_MAXLEN(&sc->sc_fastq, ifqmaxlen);
    IFQ_SET_MAXLEN(&sc->sc_rawq, ifqmaxlen);
@


1.66
log
@do not steal mbuf types (leads to a panic if M_ZEROIZE gets set on
readonly mbufs) but use M_PROTO1 and M_LINK0 instead; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.65 2012/03/28 19:39:33 claudio Exp $	*/
d1139 1
a1139 1
	dp = (mp != NULL)? mtod(mp, u_char *): NULL;
@


1.65
log
@More p_pid to p_p->ps_pid updates. OK deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.64 2012/01/20 23:36:53 bluhm Exp $	*/
d187 2
a188 2
#define M_HIGHPRI	0x2000	/* output packet for sc_fastq */
#define M_ERRMARK	0x4000	/* steal a bit in mbuf m_flags */
@


1.64
log
@Ansify ppp... function definitions.
from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.63 2011/07/07 20:42:56 henning Exp $	*/
d466 1
a466 1
	sc->sc_xfer = p->p_pid;
@


1.63
log
@use IF_LEN/IFQ_LEN to access and ifqueue's length field. ryan ok
with this nothing in the tree fiddles if ifqueue internals any more, of
course except if.c and if.h (and some altq)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.62 2011/07/06 22:08:50 henning Exp $	*/
d220 1
a220 1
pppattach()
d227 1
a227 3
ppp_clone_create(ifc, unit)
    struct if_clone *ifc;
    int unit;
d265 1
a265 2
ppp_clone_destroy(ifp)
    struct ifnet *ifp;
d287 1
a287 2
pppalloc(pid)
    pid_t pid;
d329 1
a329 2
pppdealloc(sc)
    struct ppp_softc *sc;
d394 2
a395 6
pppioctl(sc, cmd, data, flag, p)
    struct ppp_softc *sc;
    u_long cmd;
    caddr_t data;
    int flag;
    struct proc *p;
d604 1
a604 4
pppsioctl(ifp, cmd, data)
    struct ifnet *ifp;
    u_long cmd;
    caddr_t data;
d693 2
a694 5
pppoutput(ifp, m0, dst, rtp)
    struct ifnet *ifp;
    struct mbuf *m0;
    struct sockaddr *dst;
    struct rtentry *rtp;
d879 1
a879 2
ppp_requeue(sc)
    struct ppp_softc *sc;
d946 1
a946 2
ppp_restart(sc)
    struct ppp_softc *sc;
d962 1
a962 2
ppp_dequeue(sc)
    struct ppp_softc *sc;
d1090 1
a1090 1
pppintr()
d1126 1
a1126 4
ppp_ccp(sc, m, rcvd)
    struct ppp_softc *sc;
    struct mbuf *m;
    int rcvd;
d1220 1
a1220 2
ppp_ccp_closed(sc)
    struct ppp_softc *sc;
d1240 1
a1240 4
ppppktin(sc, m, lost)
    struct ppp_softc *sc;
    struct mbuf *m;
    int lost;
d1259 1
a1259 3
ppp_inproc(sc, m)
    struct ppp_softc *sc;
    struct mbuf *m;
d1547 1
a1547 2
pppdumpm(m0)
    struct mbuf *m0;
d1580 1
a1580 2
ppp_ifstart(ifp)
	struct ifnet *ifp;
@


1.62
log
@ppp_ifstart unconditionally. depending on ALTQ for this is ridiculous.
one tree less in my forest (for a few seconds)! ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.61 2011/07/06 02:42:28 henning Exp $	*/
d423 1
a423 1
	*(int *)data = sc->sc_inq.ifq_len;
@


1.61
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.60 2011/07/05 19:59:18 henning Exp $	*/
a165 1
#ifdef ALTQ
a166 1
#endif
a247 1
#ifdef ALTQ
a248 1
#endif
a1606 5
#ifdef ALTQ
/*
 * a wrapper to transmit a packet from if_start since ALTQ uses
 * if_start to send a packet.
 */
a1615 2
#endif

@


1.60
log
@use IFQ_IS_EMPTY instead of fiddling with ifqueue internals - 3 cases
why bother with APIs when you can muck with internals directly, it's obvious
there'll NEVER be changes, right. ok claudio ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.59 2011/07/04 20:40:58 dhill Exp $	*/
d254 3
a256 3
    sc->sc_inq.ifq_maxlen = ifqmaxlen;
    sc->sc_fastq.ifq_maxlen = ifqmaxlen;
    sc->sc_rawq.ifq_maxlen = ifqmaxlen;
@


1.59
log
@use mtod.

no change in binary

"Sure" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.58 2010/05/02 22:34:31 stsp Exp $	*/
d1123 2
a1124 1
	    && (IFQ_IS_EMPTY(&sc->sc_if.if_snd) == 0 || sc->sc_fastq.ifq_head)) {
d1130 1
a1130 1
	while (sc->sc_rawq.ifq_head) {
@


1.58
log
@The line-discipline-specific ioctls return -1 to indicate that
the non-line-discipline-specific ioctl handler should be tried.
So changing these to return ENOTTY was wrong.

Noted on misc@@ because of resulting pppd log spam (but it didn't break
anything serious): http://marc.info/?l=openbsd-misc&m=127258856501621&w=2

ok sthen@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.57 2010/05/01 08:14:26 mk Exp $	*/
d1587 1
a1587 1
	u_char *rptr = (u_char *)m->m_data;
@


1.57
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.56 2010/04/24 08:00:12 stsp Exp $	*/
d608 1
a608 1
	return (ENOTTY);
@


1.56
log
@Make if_ppp and if_sl ioctl handlers return ENOTTY for unsupported
ioctls, instead of -1 or EINVAL. ENOTTY audit suggested to me by uwe.
ok dlg tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.55 2009/11/03 10:59:04 claudio Exp $	*/
d1477 1
a1477 1
    /* mark incomming routing domain */
@


1.55
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.54 2009/07/08 15:01:50 claudio Exp $	*/
d608 1
a608 1
	return (-1);
d698 1
a698 1
	error = EINVAL;
@


1.54
log
@Add the same routing domain assignments and checks into the not so used
protocols as it is currently in if_ethersubr.c. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.53 2009/03/15 19:40:41 miod Exp $	*/
d731 1
a731 1
    if (ifp->if_rdomain != m0->m_pkthdr.rdomain) {
d733 2
a734 4
	    "%d vs. %d, AF %d\n", ifp->if_xname, ifp->if_rdomain,
	    m0->m_pkthdr.rdomain, dst->sa_family);
	error = ENETDOWN;
	goto bad;
@


1.53
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.52 2008/10/22 23:04:45 mpf Exp $	*/
d730 10
d1478 3
@


1.52
log
@#if INET  => #ifdef INET
#if INET6 => #ifdef INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.51 2008/09/17 20:10:37 chl Exp $	*/
d342 1
a342 1
    splassert(IPL_SOFTNET);
d898 1
a898 1
    splassert(IPL_SOFTNET);
d1110 1
a1110 1
    splassert(IPL_SOFTNET);
@


1.51
log
@remove dead stores and newly created unused variables.

fix potential use of uninitialized value in trunk_port_ioctl() function.

Found by LLVM/Clang Static Analyzer.

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.50 2007/09/15 16:43:51 henning Exp $	*/
d128 1
a128 1
#if INET
@


1.50
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.49 2007/05/26 17:13:31 jason Exp $	*/
d1054 1
a1054 1
	int slen, clen;
d1059 1
a1059 1
	clen = (*sc->sc_xcomp->compress)
@


1.49
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.48 2007/04/11 14:50:55 claudio Exp $	*/
d236 1
a236 1
    sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
a238 1
    bzero(sc, sizeof(*sc));
d316 1
a316 2
    MALLOC(sc->sc_comp, struct slcompress *, sizeof(struct slcompress),
	   M_DEVBUF, M_NOWAIT);
d381 1
a381 1
	FREE(sc->sc_pass_filt.bf_insns, M_DEVBUF);
d386 1
a386 1
	FREE(sc->sc_active_filt.bf_insns, M_DEVBUF);
d393 1
a393 1
	FREE(sc->sc_comp, M_DEVBUF);
d584 1
a584 1
	    MALLOC(newcode, struct bpf_insn *, newcodelen, M_DEVBUF, M_WAITOK);
d587 1
a587 1
		FREE(newcode, M_DEVBUF);
d591 1
a591 1
		FREE(newcode, M_DEVBUF);
d603 1
a603 1
	    FREE(oldcode, M_DEVBUF);
@


1.48
log
@Don't use m_prepend() even if it is used mostly correct here.
m_prepend() should never be called directly, use M_PREPEND() instead.
Doing so simplifies the code. Tested by fkr@@ and Paul de Weerd.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.47 2006/12/28 20:06:11 deraadt Exp $	*/
a232 1
    extern int ifqmaxlen;
@


1.47
log
@check if ifqueue has anything queued before doing the dance of
splnet/IF_DEQUEUE/splx; ok various people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.46 2006/03/25 22:41:47 djm Exp $	*/
a725 1
    struct mbuf *m;
d782 5
a786 9
    if (M_LEADINGSPACE(m0) < PPP_HDRLEN) {
	m0 = m_prepend(m0, PPP_HDRLEN, M_DONTWAIT);
	if (m0 == 0) {
	    error = ENOBUFS;
	    goto bad;
	}
	m0->m_len = 0;
    } else
	m0->m_data -= PPP_HDRLEN;
a792 1
    m0->m_len += PPP_HDRLEN;
d794 3
a796 3
    len = 0;
    for (m = m0; m != 0; m = m->m_next)
	len += m->m_len;
@


1.46
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.45 2006/03/12 00:18:07 brad Exp $	*/
d1130 1
a1130 1
	for (;;) {
@


1.45
log
@remove BPF filter support if the bpfilter device is removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.44 2006/03/04 22:40:15 brad Exp $	*/
d844 1
a844 1
	bpf_mtap(sc->sc_bpf, m0);
d1509 1
a1509 1
	bpf_mtap(sc->sc_bpf, m);
@


1.44
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.43 2006/01/04 06:04:42 canacar Exp $	*/
d382 1
d393 1
d419 1
d423 1
d579 1
d608 1
d810 1
d831 6
d1479 1
d1498 6
@


1.43
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.42 2004/06/21 23:50:36 tholo Exp $	*/
d265 1
a265 1
    s = splimp();
d282 1
a282 1
    s = splimp();
d446 1
a446 1
	splimp();
d512 1
a512 1
		    splimp();
d527 1
a527 1
		    splimp();
d596 1
a596 1
	s = splimp();
d626 1
a626 1
    int s = splimp(), error = 0;
d957 1
a957 1
    int s = splimp();
d1112 1
a1112 1
	    s2 = splimp();
d1118 1
a1118 1
	    s2 = splimp();
d1174 1
a1174 1
	    s = splimp();
d1190 1
a1190 1
		    s = splimp();
d1201 1
a1201 1
		    s = splimp();
d1218 1
a1218 1
		    s = splimp();
d1258 1
a1258 1
    int s = splimp();
d1304 1
a1304 1
	s = splimp();
d1336 1
a1336 1
	    s = splimp();
d1367 1
a1367 1
	s = splimp();
d1525 1
a1525 1
    s = splimp();
@


1.42
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.41 2004/04/25 18:50:01 henning Exp $	*/
a285 3
#if NBPFILTER > 0
    bpfdetach(ifp);
#endif
@


1.41
log
@check for input queue congestion on those as well and call if_congestion when
needed; these  are slightly different so that we cannot use the new
IF_INPUT_ENQUEUE macro
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.40 2003/12/16 20:33:25 markus Exp $	*/
a142 1
#include <sys/time.h>
d334 1
a334 1
    sc->sc_last_sent = sc->sc_last_recv = time.tv_sec;
d572 1
a572 1
	t = time.tv_sec;
d824 1
a824 1
	    sc->sc_last_sent = time.tv_sec;
d1484 1
a1484 1
	    sc->sc_last_recv = time.tv_sec;
@


1.40
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.39 2003/12/13 10:01:16 markus Exp $	*/
d1536 2
@


1.39
log
@initial support ifconfig destroy; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.38 2003/12/10 07:22:42 itojun Exp $	*/
d171 1
a171 1
void		ppp_clone_destroy(struct ifnet *);
d273 1
a273 1
void
d281 1
a281 1
	return;
d293 1
@


1.38
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.37 2003/12/07 15:41:27 markus Exp $	*/
d170 2
a214 2
int     ppp_clone_create(struct if_clone *, int);

d217 1
a217 1
    IF_CLONE_INITIALIZER("ppp", ppp_clone_create, NULL);
d271 22
@


1.37
log
@support ifconfig create; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.36 2003/08/15 20:32:19 tedu Exp $	*/
d235 1
a235 1
    register struct ppp_softc *sc;
d596 1
a596 1
    register struct ifnet *ifp;
d600 3
a602 3
    register struct ppp_softc *sc = ifp->if_softc;
    register struct ifaddr *ifa = (struct ifaddr *)data;
    register struct ifreq *ifr = (struct ifreq *)data;
d693 1
a693 1
    register struct ppp_softc *sc = ifp->if_softc;
@


1.36
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.35 2003/06/02 23:28:12 millert Exp $	*/
a160 2
struct	ppp_softc ppp_softc[NPPP];

d213 5
d225 9
d236 1
a236 1
    register int i = 0;
d238 15
a252 10
    for (sc = ppp_softc; i < NPPP; sc++) {
	sc->sc_unit = i;	/* XXX */
	snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "ppp%d", i++);
	sc->sc_if.if_softc = sc;
	sc->sc_if.if_mtu = PPP_MTU;
	sc->sc_if.if_flags = IFF_POINTOPOINT | IFF_MULTICAST;
	sc->sc_if.if_type = IFT_PPP;
	sc->sc_if.if_hdrlen = PPP_HDRLEN;
	sc->sc_if.if_ioctl = pppsioctl;
	sc->sc_if.if_output = pppoutput;
d254 1
a254 1
	sc->sc_if.if_start = ppp_ifstart;
d256 7
a262 7
	IFQ_SET_MAXLEN(&sc->sc_if.if_snd, ifqmaxlen);
	sc->sc_inq.ifq_maxlen = ifqmaxlen;
	sc->sc_fastq.ifq_maxlen = ifqmaxlen;
	sc->sc_rawq.ifq_maxlen = ifqmaxlen;
	IFQ_SET_READY(&sc->sc_if.if_snd);
	if_attach(&sc->sc_if);
	if_alloc_sadl(&sc->sc_if);
d264 1
a264 1
	bpfattach(&sc->sc_bpf, &sc->sc_if, DLT_PPP, PPP_HDRLEN);
d266 5
a270 1
    }
d280 1
a280 1
    int nppp, i;
d283 1
a283 1
    for (nppp = 0, sc = ppp_softc; nppp < NPPP; nppp++, sc++)
d288 1
a288 1
    for (nppp = 0, sc = ppp_softc; nppp < NPPP; nppp++, sc++)
d291 1
a291 1
    if (nppp >= NPPP)
d1084 1
a1084 1
    int i, s, s2;
a1088 1
    sc = ppp_softc;
d1090 1
a1090 1
    for (i = 0; i < NPPP; ++i, ++sc) {
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.34 2003/05/03 21:15:11 deraadt Exp $	*/
d398 1
a398 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d412 1
a412 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d425 1
a425 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d436 1
a436 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d443 1
a443 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d513 1
a513 1
	    if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.34
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.33 2003/02/12 14:41:07 jason Exp $	*/
d59 1
a59 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.33
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.32 2003/01/07 09:00:33 kjc Exp $	*/
d232 1
a232 1
	sprintf(sc->sc_if.if_xname, "ppp%d", i++);
@


1.32
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.31 2002/07/01 19:31:34 deraadt Exp $	*/
d164 2
@


1.31
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.30 2002/06/30 13:04:36 itojun Exp $	*/
a682 1
    ALTQ_DECL(struct altq_pktattr pktattr;)
a689 2
    IFQ_CLASSIFY(&ifp->if_snd, m0, dst->sa_family, &pktattr);

d822 1
a822 1
	    IFQ_ENQUEUE(&sc->sc_if.if_snd, m0, &pktattr, error);
@


1.30
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.29 2002/06/19 08:48:57 deraadt Exp $	*/
d7 1
a7 2
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
d9 35
a43 18
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Drew D. Perkins
 * Carnegie Mellon University
 * 4910 Forbes Ave.
 * Pittsburgh, PA 15213
 * (412) 268-8576
 * ddp@@andrew.cmu.edu
@


1.29
log
@this was derived from UCB if_sl.  therefore, we can update the UCB if_sl
copyright contained in this.  a license problem remains, of course...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.28 2002/06/11 04:27:40 art Exp $	*/
d231 1
@


1.28
log
@sprinkle splasserts where function comments tell us to.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.27 2002/03/14 01:27:09 millert Exp $	*/
d32 2
a33 2
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.
d35 27
a61 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
@


1.27
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.26 2002/02/13 08:14:48 kjc Exp $	*/
d274 2
d826 2
d1038 2
d1041 1
a1041 1
    s = splsoftnet();
@


1.26
log
@sync with KAME.

make altq actually work with kernl ppp.
add if_start for the altq case to kick transmission.
don't call ppp_restart() to prevent useless interrupt
loop under rate-limiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.25 2001/09/16 00:42:44 millert Exp $	*/
d133 6
a138 6
static int	pppsioctl __P((struct ifnet *, u_long, caddr_t));
static void	ppp_requeue __P((struct ppp_softc *));
static void	ppp_ccp __P((struct ppp_softc *, struct mbuf *m, int rcvd));
static void	ppp_ccp_closed __P((struct ppp_softc *));
static void	ppp_inproc __P((struct ppp_softc *, struct mbuf *));
static void	pppdumpm __P((struct mbuf *m0));
d140 1
a140 1
static void	ppp_ifstart __P((struct ifnet *ifp));
@


1.25
log
@Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.24 2001/07/20 22:47:15 mickey Exp $	*/
d139 3
d206 3
d1512 16
@


1.25.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.25 2001/09/16 00:42:44 millert Exp $	*/
d133 6
a138 9
static int	pppsioctl(struct ifnet *, u_long, caddr_t);
static void	ppp_requeue(struct ppp_softc *);
static void	ppp_ccp(struct ppp_softc *, struct mbuf *m, int rcvd);
static void	ppp_ccp_closed(struct ppp_softc *);
static void	ppp_inproc(struct ppp_softc *, struct mbuf *);
static void	pppdumpm(struct mbuf *m0);
#ifdef ALTQ
static void	ppp_ifstart(struct ifnet *ifp);
#endif
a202 3
#ifdef ALTQ
	sc->sc_if.if_start = ppp_ifstart;
#endif
a1505 16

#ifdef ALTQ
/*
 * a wrapper to transmit a packet from if_start since ALTQ uses
 * if_start to send a packet.
 */
static void
ppp_ifstart(ifp)
	struct ifnet *ifp;
{
	struct ppp_softc *sc;

	sc = ifp->if_softc;
	(*sc->sc_start)(sc);
}
#endif
@


1.25.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.25.4.1 2002/06/11 03:30:45 art Exp $	*/
d7 2
a8 1
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
d10 11
a20 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d22 6
a27 31
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d32 2
a33 18
 * Copyright (c) 1987, 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d35 11
a45 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a214 1
	if_alloc_sadl(&sc->sc_if);
a273 2
    splassert(IPL_SOFTNET);

a823 2
    splassert(IPL_SOFTNET);

a1033 2
    splassert(IPL_SOFTNET);

d1035 1
a1035 1
    s = splsoftnet();	/* XXX - what's the point of this? see comment above */
@


1.25.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a164 2
struct	ppp_softc ppp_softc[NPPP];

d230 1
a230 1
	snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "ppp%d", i++);
d683 1
d691 2
d825 1
a825 1
	    IFQ_ENQUEUE(&sc->sc_if.if_snd, m0, NULL, error);
@


1.24
log
@use a variable, not it's default value from constant
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.23 2001/06/27 06:07:42 kjc Exp $	*/
d332 2
a333 1
    int s, error, flags, mru, nb, npx;
@


1.23
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.22 2001/06/27 03:49:53 angelos Exp $	*/
d189 1
d203 4
a206 4
	IFQ_SET_MAXLEN(&sc->sc_if.if_snd, IFQ_MAXLEN);
	sc->sc_inq.ifq_maxlen = IFQ_MAXLEN;
	sc->sc_fastq.ifq_maxlen = IFQ_MAXLEN;
	sc->sc_rawq.ifq_maxlen = IFQ_MAXLEN;
@


1.22
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.21 2001/06/25 01:50:17 fgsch Exp $	*/
d202 1
a202 1
	sc->sc_if.if_snd.ifq_maxlen = IFQ_MAXLEN;
d206 1
d640 1
d648 2
d766 18
a783 3
	ifq = (m0->m_flags & M_HIGHPRI)? &sc->sc_fastq: &ifp->if_snd;
	if (IF_QFULL(ifq) && dst->sa_family != AF_UNSPEC) {
	    IF_DROP(ifq);
d787 1
a787 2
	    error = ENOBUFS;
	    goto bad;
a788 1
	IF_ENQUEUE(ifq, m0);
d814 1
d832 18
a849 3
	    ifq = (m->m_flags & M_HIGHPRI)? &sc->sc_fastq: &sc->sc_if.if_snd;
	    if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
d852 1
a852 2
	    } else
		IF_ENQUEUE(ifq, m);
d904 1
a904 1
	IF_DEQUEUE(&sc->sc_if.if_snd, m);
d1030 1
a1030 1
	    && (sc->sc_if.if_snd.ifq_head || sc->sc_fastq.ifq_head)) {
@


1.21
log
@Move common post M_COPY_HDR manipulation to the macro itself; angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.20 2001/06/15 03:38:34 itojun Exp $	*/
d1291 1
a1291 1
		M_COPY_HDR(mp, m);
@


1.20
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.19 2001/05/28 07:53:04 angelos Exp $	*/
d1290 1
a1290 1
	if (m->m_flags & M_PKTHDR) {
a1291 3
		m_tag_init(m);
		m->m_flags &= ~M_PKTHDR;
	}
@


1.19
log
@Copy the packet header only if the original mbuf had a packet header
(just general paranoia).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.18 2001/05/27 11:57:09 angelos Exp $	*/
a773 1
    ifp->if_lastchange = time;
a1427 1
    ifp->if_lastchange = time;
@


1.18
log
@Fixup tags on old mbuf chain head.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.17 2001/05/16 12:53:34 ho Exp $	*/
d1291 5
a1295 3
	M_COPY_HDR(mp, m);
	m_tag_init(m);
	m->m_flags &= ~M_PKTHDR;
@


1.17
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.16 2000/03/21 23:31:27 mickey Exp $	*/
d1291 3
@


1.16
log
@add SIOCGIFMTU/SIOCSIFMTU; remediate redundant code of tun, ppp, sppp; chris@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.15 1999/12/08 06:50:18 itojun Exp $	*/
a500 3
	    if (newcode == 0) {
		return EINVAL;		/* or sumpin */
	    }
@


1.16.6.1
log
@MFS (from millert):
Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.16 2000/03/21 23:31:27 mickey Exp $	*/
d330 1
a330 2
    int s, error, flags, mru, npx;
    u_int nb;
@


1.16.4.1
log
@MFC:
Add some missing lengths checks when passing data from userland to the
kernel. From NetBSD via millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.25 2001/09/16 00:42:44 millert Exp $	*/
d330 1
a330 2
    int s, error, flags, mru, npx;
    u_int nb;
@


1.15
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.14 1998/07/12 04:33:20 angelos Exp $	*/
a539 1
    register struct proc *p = curproc;	/* XXX */
a565 2
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
	    break;
a566 4
	break;

    case SIOCGIFMTU:
	ifr->ifr_mtu = sc->sc_if.if_mtu;
@


1.15.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d540 1
d567 2
d570 4
@


1.15.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.15.2.1 2000/03/24 09:09:32 niklas Exp $	*/
d202 1
a202 1
	IFQ_SET_MAXLEN(&sc->sc_if.if_snd, IFQ_MAXLEN);
a205 1
	IFQ_SET_READY(&sc->sc_if.if_snd);
d501 3
a641 1
    ALTQ_DECL(struct altq_pktattr pktattr;)
a648 2
    IFQ_CLASSIFY(&ifp->if_snd, m0, dst->sa_family, &pktattr);

d765 3
a767 18
	if ((m0->m_flags & M_HIGHPRI)
#ifdef ALTQ
	    && ALTQ_IS_ENABLED(&sc->sc_if.if_snd) == 0
#endif
	    ) {
	    ifq = &sc->sc_fastq;
	    if (IF_QFULL(ifq) && dst->sa_family != AF_UNSPEC) {
		IF_DROP(ifq);
		m_freem(m0);
		error = ENOBUFS;
	    }
	    else {
		IF_ENQUEUE(ifq, m0);
		error = 0;
	    }
	} else
	    IFQ_ENQUEUE(&sc->sc_if.if_snd, m0, &pktattr, error);
	if (error) {
d771 2
a772 1
	    return (error);
d774 1
d777 1
a800 1
    int error;
d818 3
a820 18
	    if ((m->m_flags & M_HIGHPRI)
#ifdef ALTQ
		&& ALTQ_IS_ENABLED(&sc->sc_if.if_snd) == 0
#endif
		) {
		ifq = &sc->sc_fastq;
		if (IF_QFULL(ifq)) {
		    IF_DROP(ifq);
		    m_freem(m);
		    error = ENOBUFS;
		}
		else {
		    IF_ENQUEUE(ifq, m);
		    error = 0;
		}
	    } else
		IFQ_ENQUEUE(&sc->sc_if.if_snd, m, NULL, error);
	    if (error) {
d823 2
a824 1
	    }
d876 1
a876 1
	IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
d1002 1
a1002 1
	    && (IFQ_IS_EMPTY(&sc->sc_if.if_snd) == 0 || sc->sc_fastq.ifq_head)) {
a1293 2
	if (m->m_flags & M_PKTHDR)
		M_MOVE_HDR(mp, m);
d1427 1
@


1.15.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.15.2.2 2001/07/04 10:54:04 niklas Exp $	*/
a188 1
    extern int ifqmaxlen;
d202 4
a205 4
	IFQ_SET_MAXLEN(&sc->sc_if.if_snd, ifqmaxlen);
	sc->sc_inq.ifq_maxlen = ifqmaxlen;
	sc->sc_fastq.ifq_maxlen = ifqmaxlen;
	sc->sc_rawq.ifq_maxlen = ifqmaxlen;
d331 1
a331 2
    int s, error, flags, mru, npx;
    u_int nb;
@


1.15.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a138 3
#ifdef ALTQ
static void	ppp_ifstart __P((struct ifnet *ifp));
#endif
a202 3
#ifdef ALTQ
	sc->sc_if.if_start = ppp_ifstart;
#endif
a1505 16

#ifdef ALTQ
/*
 * a wrapper to transmit a packet from if_start since ALTQ uses
 * if_start to send a packet.
 */
static void
ppp_ifstart(ifp)
	struct ifnet *ifp;
{
	struct ppp_softc *sc;

	sc = ifp->if_softc;
	(*sc->sc_start)(sc);
}
#endif
@


1.15.2.5
log
@Merge in -current from roughly a week ago
@
text
@d133 6
a138 6
static int	pppsioctl(struct ifnet *, u_long, caddr_t);
static void	ppp_requeue(struct ppp_softc *);
static void	ppp_ccp(struct ppp_softc *, struct mbuf *m, int rcvd);
static void	ppp_ccp_closed(struct ppp_softc *);
static void	ppp_inproc(struct ppp_softc *, struct mbuf *);
static void	pppdumpm(struct mbuf *m0);
d140 1
a140 1
static void	ppp_ifstart(struct ifnet *ifp);
@


1.15.2.6
log
@Sync the SMP branch with 3.3
@
text
@d7 2
a8 1
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
d10 11
a20 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d22 6
a27 31
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d32 2
a33 18
 * Copyright (c) 1987, 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d35 11
a45 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a132 2
struct	ppp_softc ppp_softc[NPPP];

a214 1
	if_alloc_sadl(&sc->sc_if);
a273 2
    splassert(IPL_SOFTNET);

d648 1
d656 2
d790 1
a790 1
	    IFQ_ENQUEUE(&sc->sc_if.if_snd, m0, NULL, error);
a823 2
    splassert(IPL_SOFTNET);

a1033 2
    splassert(IPL_SOFTNET);

d1035 1
a1035 1
    s = splsoftnet();	/* XXX - what's the point of this? see comment above */
@


1.15.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.15.2.6 2003/03/28 00:41:28 niklas Exp $	*/
d232 1
a232 1
	snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "ppp%d", i++);
@


1.15.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.15.2.7 2003/05/13 19:36:15 ho Exp $	*/
d59 5
a63 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.15.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d161 2
a171 2
int		ppp_clone_create(struct if_clone *, int);
int		ppp_clone_destroy(struct ifnet *);
a214 3
LIST_HEAD(, ppp_softc) ppp_softc_list;
struct if_clone ppp_cloner =
    IF_CLONE_INITIALIZER("ppp", ppp_clone_create, ppp_clone_destroy);
a221 9
    LIST_INIT(&ppp_softc_list);
    if_clone_attach(&ppp_cloner);
}

int
ppp_clone_create(ifc, unit)
    struct if_clone *ifc;
    int unit;
{
d223 2
a224 2
    struct ppp_softc *sc;
    int s;
d226 10
a235 15
    sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
    if (!sc)
	return (ENOMEM);
    bzero(sc, sizeof(*sc));

    sc->sc_unit = unit;
    snprintf(sc->sc_if.if_xname, sizeof sc->sc_if.if_xname, "%s%d",
	ifc->ifc_name, unit);
    sc->sc_if.if_softc = sc;
    sc->sc_if.if_mtu = PPP_MTU;
    sc->sc_if.if_flags = IFF_POINTOPOINT | IFF_MULTICAST;
    sc->sc_if.if_type = IFT_PPP;
    sc->sc_if.if_hdrlen = PPP_HDRLEN;
    sc->sc_if.if_ioctl = pppsioctl;
    sc->sc_if.if_output = pppoutput;
d237 1
a237 1
    sc->sc_if.if_start = ppp_ifstart;
d239 7
a245 7
    IFQ_SET_MAXLEN(&sc->sc_if.if_snd, ifqmaxlen);
    sc->sc_inq.ifq_maxlen = ifqmaxlen;
    sc->sc_fastq.ifq_maxlen = ifqmaxlen;
    sc->sc_rawq.ifq_maxlen = ifqmaxlen;
    IFQ_SET_READY(&sc->sc_if.if_snd);
    if_attach(&sc->sc_if);
    if_alloc_sadl(&sc->sc_if);
d247 1
a247 1
    bpfattach(&sc->sc_bpf, &sc->sc_if, DLT_PPP, PPP_HDRLEN);
d249 1
a249 28
    s = splimp();
    LIST_INSERT_HEAD(&ppp_softc_list, sc, sc_list);
    splx(s);

    return (0);
}

int
ppp_clone_destroy(ifp)
    struct ifnet *ifp;
{
    struct ppp_softc *sc = ifp->if_softc;
    int s;

    if (sc->sc_devp != NULL)
	return (EBUSY);

    s = splimp();
    LIST_REMOVE(sc, sc_list);
    splx(s);

#if NBPFILTER > 0
    bpfdetach(ifp);
#endif
    if_detach(ifp);

    free(sc, M_DEVBUF);
    return (0);
d259 1
a259 1
    int i;
d262 1
a262 1
    LIST_FOREACH(sc, &ppp_softc_list, sc_list)
d267 1
a267 1
    LIST_FOREACH(sc, &ppp_softc_list, sc_list)
d270 1
a270 1
    if (sc == NULL)
d398 1
a398 1
	if ((error = suser(p, 0)) != 0)
d412 1
a412 1
	if ((error = suser(p, 0)) != 0)
d425 1
a425 1
	if ((error = suser(p, 0)) != 0)
d436 1
a436 1
	if ((error = suser(p, 0)) != 0)
d443 1
a443 1
	if ((error = suser(p, 0)) != 0)
d513 1
a513 1
	    if ((error = suser(p, 0)) != 0)
d575 1
a575 1
    struct ifnet *ifp;
d579 3
a581 3
    struct ppp_softc *sc = ifp->if_softc;
    struct ifaddr *ifa = (struct ifaddr *)data;
    struct ifreq *ifr = (struct ifreq *)data;
d672 1
a672 1
    struct ppp_softc *sc = ifp->if_softc;
d1063 1
a1063 1
    int s, s2;
d1068 1
d1070 1
a1070 1
    LIST_FOREACH(sc, &ppp_softc_list, sc_list) {
@


1.15.2.10
log
@Merge with the trunk
@
text
@a1535 2
	if (!inq->ifq_congestion)
		if_congestion(inq);
@


1.14
log
@Remove the NPMODE_KEEPLAST defs; they're not really necessary. Also,
sync with NetBSD (the recent splhigh->splimp changes).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.13 1998/07/01 21:02:23 angelos Exp $	*/
d105 6
@


1.13
log
@Add NPMODE_KEEPLAST conditions; not supported yet (act like NPMODE_QUEUE).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.12 1998/05/08 05:02:09 millert Exp $	*/
d127 6
a132 6
int	pppsioctl __P((struct ifnet *, u_long, caddr_t));
void	ppp_requeue __P((struct ppp_softc *));
void	ppp_ccp __P((struct ppp_softc *, struct mbuf *m, int rcvd));
void	ppp_ccp_closed __P((struct ppp_softc *));
void	ppp_inproc __P((struct ppp_softc *, struct mbuf *));
void	pppdumpm __P((struct mbuf *m0));
d358 1
a358 1
	splhigh();
d424 1
a424 1
		    splhigh();
d439 1
a439 1
		    splhigh();
d470 1
a470 2
		if ((npi->mode != NPMODE_QUEUE) &&
		    (npi->mode != NPMODE_KEEPLAST)) {
d528 1
a528 1
int
d739 1
a739 1
	 * Update the time we sent the most recent data packet.
d760 1
a760 2
    if ((mode == NPMODE_QUEUE) ||
	(mode == NPMODE_KEEPLAST)) /* XXX Fix eventually */ {
d795 1
a795 1
void
a833 1
	case NPMODE_KEEPLAST:	/* XXX Fix eventually */
a869 1
    int s = splhigh();
d878 2
a879 4
    if (m == NULL) {
	splx(s);
	return NULL;
    }
a985 1
    splx(s);
d1026 1
a1026 1
void
d1110 1
a1110 1
		    s = splhigh();
d1123 1
a1123 1
void
d1166 1
a1166 1
void
d1443 1
a1443 1
void
@


1.12
log
@Add support for RFC-comliant deflate protocol
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.11 1997/09/05 04:26:58 millert Exp $	*/
d470 2
a471 1
		if (npi->mode != NPMODE_QUEUE) {
d761 2
a762 1
    if (mode == NPMODE_QUEUE) {
d836 1
@


1.11
log
@Minor changes from ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.10 1997/01/02 11:10:18 mickey Exp $	*/
d162 1
a162 1
extern struct compressor ppp_deflate;
d170 1
@


1.10
log
@PPP_BSDCOMP not PPP_BSD_COMP
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ppp.c,v 1.9 1996/12/19 13:45:16 mickey Exp $	*/
/*	$NetBSD: if_ppp.c,v 1.31 1996/05/07 02:40:36 thorpej Exp $	*/
a93 4
#if NetBSD1_0 && defined(i386)
#include <machine/psl.h>
#endif

a121 4
#if NetBSD1_0
#define splsoftnet    splnet
#endif

d127 6
a132 5
static void	ppp_requeue __P((struct ppp_softc *));
static void	ppp_ccp __P((struct ppp_softc *, struct mbuf *m, int rcvd));
static void	ppp_ccp_closed __P((struct ppp_softc *));
static void	ppp_inproc __P((struct ppp_softc *, struct mbuf *));
static void	pppdumpm __P((struct mbuf *m0));
d175 1
a203 13

#if NetBSD1_0 && defined(i386)
    /*
     * XXX kludge to fix the bug in the i386 interrupt handling code,
     * where software interrupts could be taken while hardware
     * interrupts were blocked.
     */
    if ((imask[IPL_TTY] & (1 << SIR_NET)) == 0) {
      imask[IPL_TTY] |= (1 << SIR_NET);
      intr_calculatemasks();
    }
#endif

d235 1
a235 1
	sl_compress_init(sc->sc_comp, -1);
d379 3
a381 3
	s = splsoftnet();
	    sl_compress_init(sc->sc_comp, *(int *)data);
	splx(s);
d420 1
a420 1
			       sc->sc_if.if_xname);
d435 1
a435 1
			       sc->sc_if.if_xname);
d446 2
a447 2
		   sc->sc_if.if_xname, ccp_option[0], ccp_option[1],
		   ccp_option[2], nb);
d533 1
a533 1
    struct proc *p = curproc;	/* XXX */
d569 2
a570 2
	case SIOCADDMULTI:
	case SIOCDELMULTI:
d577 2
a578 2
		case AF_INET:
			break;
d580 5
a584 5
		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;
d640 1
a640 1
    int active, len;
a723 5
    /*
     * Apply the pass and active filters to the packet,
     * but only if it is a data packet.
     */
    active = 0;
d725 4
d794 1
a794 1
static void
a855 1

d870 1
a870 1
  
d876 1
a876 1
    if (m == NULL)   
d878 3
a880 3
    if (m == NULL)
    {   splx(s);
        return NULL;
d882 1
a882 1
  
d887 1
a887 1
     * The ppp header will be in one mbuf.  
d893 1
a893 1
    
d897 37
a933 37
        /*
         * If the packet is a TCP/IP packet, see if we can compress it.
         */
        if ((sc->sc_flags & SC_COMP_TCP) && sc->sc_comp != NULL) {
            struct ip *ip;
            int type;
    
            mp = m;
            ip = (struct ip *) (cp + PPP_HDRLEN);
            if (mp->m_len <= PPP_HDRLEN) {
                mp = mp->m_next;
                if (mp == NULL) 
                    break;
                ip = mtod(mp, struct ip *);
            }
            /* this code assumes the IP/TCP header is in one non-shared mbuf */
            if (ip->ip_p == IPPROTO_TCP) {
                type = sl_compress_tcp(mp, ip, sc->sc_comp,
                                       !(sc->sc_flags & SC_NO_TCP_CCID));
                switch (type) {
                case TYPE_UNCOMPRESSED_TCP:
                    protocol = PPP_VJC_UNCOMP;
                    break;
                case TYPE_COMPRESSED_TCP:
                    protocol = PPP_VJC_COMP;
                    cp = mtod(m, u_char *);
                    cp[0] = address;    /* header has moved */
                    cp[1] = control;
                    cp[2] = 0;
                    break;
                }
                cp[3] = protocol;       /* update protocol in PPP header */
            }
        }
#endif  /* VJC */
        break;
                
d936 3
a938 3
        ppp_ccp(sc, m, 0);
        break;
#endif  /* PPP_COMPRESS */
d940 1
a940 1
                                       
d943 22
a964 22
        && sc->sc_xc_state && (sc->sc_flags & SC_COMP_RUN)) {
        struct mbuf *mcomp = NULL;
        int slen, clen;
                    
        slen = 0;
        for (mp = m; mp != NULL; mp = mp->m_next)
            slen += mp->m_len;
        clen = (*sc->sc_xcomp->compress)
            (sc->sc_xc_state, &mcomp, m, slen,
             (sc->sc_flags & SC_CCP_UP? sc->sc_if.if_mtu + PPP_HDRLEN: 0));
        if (mcomp != NULL) {
            if (sc->sc_flags & SC_CCP_UP) {
                /* Send the compressed packet instead of the original. */
                m_freem(m);
                m = mcomp;
                cp = mtod(m, u_char *);
                protocol = cp[3];
            } else {
                /* Can't transmit compressed packets until CCP is up. */
                m_freem(mcomp);
            }
        }       
d966 2
a967 2
#endif  /* PPP_COMPRESS */
        
d972 6
a977 6
        control == PPP_UI && protocol != PPP_ALLSTATIONS &&
        protocol != PPP_LCP) {
        /* can compress address/control */
        m->m_data += 2;
        m->m_len -= 2; 
    }               
d979 7
a985 7
        /* can compress protocol */
        if (mtod(m, u_char *) == cp) {
            cp[2] = cp[1];      /* move address/control up */
            cp[1] = cp[0];
        }
        ++m->m_data;
        --m->m_len;
d987 2
a988 1
    splx(s);        
a989 1
                
d1001 1
a1001 1
            
d1003 1
a1003 1
    s = splsoftnet(); 
d1005 15
a1019 15
        if (!(sc->sc_flags & SC_TBUSY)
            && (sc->sc_if.if_snd.ifq_head || sc->sc_fastq.ifq_head)) {
            s2 = splimp();
            sc->sc_flags |= SC_TBUSY;
            splx(s2);
            (*sc->sc_start)(sc);
        }
        for (;;) {
            s2 = splimp();
            IF_DEQUEUE(&sc->sc_rawq, m);
            splx(s2);
            if (m == NULL)
                break;
            ppp_inproc(sc, m);
        }
a1021 1
 
a1023 2


d1029 1
a1029 1
static void
d1059 1
a1059 1
		   dp, slen, mtod(mp, u_char *), mp->m_len);
d1126 1
a1126 1
static void
d1169 1
a1169 1
static void
d1281 1
a1281 1
			ifp->if_xname);
d1333 1
a1333 1
			ifp->if_xname);
a1357 4
    /*
     * See whether we want to pass this packet, and
     * if it counts as link activity.
     */
d1359 4
d1446 1
a1446 1
static void
@


1.9
log
@sync to 2.3b3
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.8 1996/07/25 14:20:50 joshd Exp $	*/
d172 1
a172 1
#if DO_BSD_COMPRESS && defined(PPP_BSD_COMP)
@


1.8
log
@Kernel changes for ppp2.3a4.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.7 1996/05/10 12:31:10 deraadt Exp $	*/
d758 1
a758 1
	 * Update the time we sent the most recent packet.
d933 1
a933 2
            /* this code assumes the IP/TCP header is in one non-shared
mbuf */
d973 1
a973 1
             (sc->sc_flags & SC_CCP_UP? sc->sc_if.if_mtu: 0));
d975 10
a984 4
            m_freem(m);
            m = mcomp;
            cp = mtod(m, u_char *);
            protocol = cp[3];
@


1.7
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ppp.c,v 1.5 1996/04/19 18:12:29 mickey Exp $	*/
d94 4
d126 4
a135 1
static void	ppp_outpkt __P((struct ppp_softc *));
d210 13
d862 2
a863 5
 * Get a packet to send.  This procedure is intended to be called at
 * spltty or splimp, so it takes little time.  If there isn't a packet
 * waiting to go out, it schedules a software interrupt to prepare a
 * new packet; the device start routine gets called again when a
 * packet is ready.
d865 2
a866 2
struct mbuf *
ppp_dequeue(sc)
d869 1
a869 2
    struct mbuf *m;
    int s = splhigh();
a870 13
    m = sc->sc_togo;
    if (m) {
	/*
	 * Had a packet waiting - send it.
	 */
	sc->sc_togo = NULL;
	sc->sc_flags |= SC_TBUSY;
	splx(s);
	return m;
    }
    /*
     * Remember we wanted a packet and schedule a software interrupt.
     */
a873 1
    return NULL;
a875 25
/*
 * Software interrupt routine, called at splsoftnet.
 */
void
pppintr()
{
    struct ppp_softc *sc;
    int i, s;
    struct mbuf *m;

    sc = ppp_softc;
    for (i = 0; i < NPPP; ++i, ++sc) {
	if (!(sc->sc_flags & SC_TBUSY) && sc->sc_togo == NULL
	    && (sc->sc_if.if_snd.ifq_head || sc->sc_fastq.ifq_head))
	    ppp_outpkt(sc);
	for (;;) {
	    s = splhigh();
	    IF_DEQUEUE(&sc->sc_rawq, m);
	    splx(s);
	    if (m == NULL)
		break;
	    ppp_inproc(sc, m);
	}
    }
}
d878 4
a881 3
 * Grab another packet off a queue and apply VJ compression,
 * packet compression, address/control and/or protocol compression
 * if enabled.  Should be called at splsoftnet.
d883 2
a884 2
static void
ppp_outpkt(sc)
d890 2
a891 1

d897 1
a897 1
    if (m == NULL)
d900 4
a903 2
	return;

d908 1
a908 1
     * The ppp header will be in one mbuf.
d914 1
a914 1

d918 38
a955 37
	/*
	 * If the packet is a TCP/IP packet, see if we can compress it.
	 */
	if ((sc->sc_flags & SC_COMP_TCP) && sc->sc_comp != NULL) {
	    struct ip *ip;
	    int type;

	    mp = m;
	    ip = (struct ip *) (cp + PPP_HDRLEN);
	    if (mp->m_len <= PPP_HDRLEN) {
		mp = mp->m_next;
		if (mp == NULL)
		    break;
		ip = mtod(mp, struct ip *);
	    }
	    /* this code assumes the IP/TCP header is in one non-shared mbuf */
	    if (ip->ip_p == IPPROTO_TCP) {
		type = sl_compress_tcp(mp, ip, sc->sc_comp,
				       !(sc->sc_flags & SC_NO_TCP_CCID));
		switch (type) {
		case TYPE_UNCOMPRESSED_TCP:
		    protocol = PPP_VJC_UNCOMP;
		    break;
		case TYPE_COMPRESSED_TCP:
		    protocol = PPP_VJC_COMP;
		    cp = mtod(m, u_char *);
		    cp[0] = address;	/* header has moved */
		    cp[1] = control;
		    cp[2] = 0;
		    break;
		}
		cp[3] = protocol;	/* update protocol in PPP header */
	    }
	}
#endif	/* VJC */
	break;

d958 3
a960 3
	ppp_ccp(sc, m, 0);
	break;
#endif	/* PPP_COMPRESS */
d962 1
a962 1

d965 16
a980 16
	&& sc->sc_xc_state && (sc->sc_flags & SC_COMP_RUN)) {
	struct mbuf *mcomp = NULL;
	int slen, clen;

	slen = 0;
	for (mp = m; mp != NULL; mp = mp->m_next)
	    slen += mp->m_len;
	clen = (*sc->sc_xcomp->compress)
	    (sc->sc_xc_state, &mcomp, m, slen,
	     (sc->sc_flags & SC_CCP_UP? sc->sc_if.if_mtu: 0));
	if (mcomp != NULL) {
	    m_freem(m);
	    m = mcomp;
	    cp = mtod(m, u_char *);
	    protocol = cp[3];
	}
d982 2
a983 2
#endif	/* PPP_COMPRESS */

d988 6
a993 6
	control == PPP_UI && protocol != PPP_ALLSTATIONS &&
	protocol != PPP_LCP) {
	/* can compress address/control */
	m->m_data += 2;
	m->m_len -= 2;
    }
d995 41
a1035 7
	/* can compress protocol */
	if (mtod(m, u_char *) == cp) {
	    cp[2] = cp[1];	/* move address/control up */
	    cp[1] = cp[0];
	}
	++m->m_data;
	--m->m_len;
d1037 4
a1041 3
    sc->sc_togo = m;
    (*sc->sc_start)(sc);
}
d1088 1
a1088 1
	    s = splhigh();
d1104 1
a1104 1
		    s = splhigh();
d1115 1
a1115 1
		    s = splhigh();
d1172 1
a1172 1
    int s = splhigh();
d1218 1
a1218 1
	s = splhigh();
d1250 1
a1250 1
	    s = splhigh();
d1281 1
a1281 1
	s = splhigh();
d1437 1
a1437 1
    s = splhigh();
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: if_ppp.c,v 1.30 1996/03/19 01:00:49 paulus Exp $	*/
d185 3
a187 2
	sc->sc_if.if_name = "ppp";
	sc->sc_if.if_unit = i++;
d340 1
a340 1
	*(int *)data = sc->sc_if.if_unit;
d418 2
a419 2
			    printf("ppp%d: comp_alloc failed\n",
			       sc->sc_if.if_unit);
d433 2
a434 2
			    printf("ppp%d: decomp_alloc failed\n",
			       sc->sc_if.if_unit);
d444 2
a445 2
	    printf("ppp%d: no compressor for [%x %x %x], %x\n",
		   sc->sc_if.if_unit, ccp_option[0], ccp_option[1],
d533 1
a533 1
    register struct ppp_softc *sc = &ppp_softc[ifp->if_unit];
d632 1
a632 1
    register struct ppp_softc *sc = &ppp_softc[ifp->if_unit];
d676 1
a676 1
	printf("ppp%d: af%d not supported\n", ifp->if_unit, dst->sa_family);
d719 1
a719 1
	printf("ppp%d output: ", ifp->if_unit);
d1086 1
a1086 1
			 sc->sc_if.if_unit, 0, sc->sc_flags & SC_DEBUG)) {
d1096 1
a1096 1
			 sc->sc_if.if_unit, 0, sc->sc_mru,
d1190 1
a1190 1
	printf("ppp%d: got %d bytes\n", ifp->if_unit, ilen);
d1232 1
a1232 1
		printf("ppp%d: decompress failed %d\n", ifp->if_unit, rv);
d1282 2
a1283 2
		printf("ppp%d: VJ uncompress failed on type comp\n",
			ifp->if_unit);
d1334 2
a1335 2
		printf("ppp%d: VJ uncompress failed on type uncomp\n",
			ifp->if_unit);
d1425 1
a1425 1
	    printf("ppp%d: input queue full\n", ifp->if_unit);
@


1.5
log
@According to the latest config stuff changes (as for if_ppp.c).
the other stuff is just for IPX support.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ppp.c,v 1.4 1996/03/03 21:07:07 niklas Exp $	*/
/*	$NetBSD: if_ppp.c,v 1.28 1996/02/13 22:00:18 christos Exp $	*/
d91 2
d98 1
d162 1
d165 1
a165 1
#ifdef PPP_BSDCOMP
d168 3
d228 1
d230 4
a233 1
    sl_compress_init(&sc->sc_comp, -1);
d292 16
d326 3
d376 1
d378 1
a378 1
	sl_compress_init(&sc->sc_comp, *(int *)data);
d380 1
d484 32
d569 5
a573 1
		switch (ifr->ifr_addr.sa_family) {
d587 12
a598 15
	psp->p.ppp_ibytes = sc->sc_bytesrcvd;
	psp->p.ppp_ipackets = ifp->if_ipackets;
	psp->p.ppp_ierrors = ifp->if_ierrors;
	psp->p.ppp_obytes = sc->sc_bytessent;
	psp->p.ppp_opackets = ifp->if_opackets;
	psp->p.ppp_oerrors = ifp->if_oerrors;
#ifdef VJC
	psp->vj.vjs_packets = sc->sc_comp.sls_packets;
	psp->vj.vjs_compressed = sc->sc_comp.sls_compressed;
	psp->vj.vjs_searches = sc->sc_comp.sls_searches;
	psp->vj.vjs_misses = sc->sc_comp.sls_misses;
	psp->vj.vjs_uncompressedin = sc->sc_comp.sls_uncompressedin;
	psp->vj.vjs_compressedin = sc->sc_comp.sls_compressedin;
	psp->vj.vjs_errorin = sc->sc_comp.sls_errorin;
	psp->vj.vjs_tossed = sc->sc_comp.sls_tossed;
d638 2
d713 4
d722 24
d765 1
a765 1
	if (IF_QFULL(ifq)) {
d769 1
d777 2
d821 1
d922 2
a934 5
	/*
	 * Update the time we sent the most recent packet.
	 */
	sc->sc_last_sent = time.tv_sec;

d939 1
a939 1
	if (sc->sc_flags & SC_COMP_TCP) {
d953 1
a953 1
		type = sl_compress_tcp(mp, ip, &sc->sc_comp,
d983 1
a983 1
	struct mbuf *mcomp;
d1177 1
a1177 1
    int s, ilen = 0, xlen, proto, rv;
d1179 1
a1179 1
    struct mbuf *mp, *dmp;
d1183 1
a1183 2
    ifp->if_ipackets++;
    ifp->if_lastchange = time;
d1186 1
a1186 1
	register int len = 0;
d1188 2
a1189 2
		len += mp->m_len;
	printf("ppp%d: got %d bytes\n", ifp->if_unit, len);
d1261 2
a1262 1
	sl_uncompress_tcp(NULL, 0, TYPE_ERROR, &sc->sc_comp);
d1272 1
a1272 1
	if (sc->sc_flags & SC_REJ_COMP_TCP)
d1277 1
a1277 1
				      &sc->sc_comp, &iphdr, &hlen);
d1324 1
a1324 1
	if (sc->sc_flags & SC_REJ_COMP_TCP)
d1329 1
a1329 1
				      &sc->sc_comp, &iphdr, &hlen);
d1359 21
a1403 1
	sc->sc_last_recv = time.tv_sec;	/* update time of last pkt rcvd */
d1430 3
d1442 1
@


1.4
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d161 1
a161 1
#if DO_BSD_COMPRESS
@


1.3
log
@from netbsd; ppp code no longer needs to recalculate intr masks on the i386
@
text
@d1 2
a2 1
/*	$NetBSD: if_ppp.c,v 1.24 1995/10/05 05:55:09 mycroft Exp $	*/
d90 1
a123 8
void	pppattach __P((void));
int	pppioctl __P((struct ppp_softc *sc, u_long cmd, caddr_t data, int flag,
		      struct proc *));
int	pppoutput __P((struct ifnet *ifp, struct mbuf *m0,
		       struct sockaddr *dst, struct rtentry *rtp));
int	pppsioctl __P((struct ifnet *ifp, u_long cmd, caddr_t data));
void	pppintr __P((void));

d126 1
a126 1
static int	ppp_ccp __P((struct ppp_softc *, struct mbuf *m, int rcvd));
d317 1
a317 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d331 1
a331 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d344 1
a344 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d353 1
a353 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d360 1
a360 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d366 1
a366 1
	if (error = copyin(odp->ptr, ccp_option, nb))
d430 1
a430 1
	    if (error = suser(p->p_ucred, &p->p_acflag))
d494 1
a494 1
	if (error = suser(p->p_ucred, &p->p_acflag))
a566 1
    struct ppp_header *ph;
d575 1
a575 1
	|| (ifp->if_flags & IFF_UP) == 0 && dst->sa_family != AF_UNSPEC) {
a808 1
    int s;
a811 1
    enum NPmode mode;
d934 1
a934 1
static int
d963 1
a963 1
	    printf("if_ppp/ccp: not enough data in mbuf (%x+%x > %x+%x)\n",
d1081 1
a1081 1
    int s, ilen, xlen, proto, rv;
d1091 4
a1094 1
	printf("ppp%d: got %d bytes\n", ifp->if_unit, ilen);
@


1.2
log
@enable multicast, so that multicast packets can flow through ppp links. idea from freebsd
@
text
@a89 4
#ifdef i386
#include <machine/psl.h>
#endif

a200 12

#ifdef i386
    /*
     * XXX kludge to fix the bug in the i386 interrupt handling code,
     * where software interrupts could be taken while hardware
     * interrupts were blocked.
     */
    if ((imask[IPL_TTY] & SIR_NETMASK) == 0) {
	imask[IPL_TTY] |= SIR_NETMASK;
	intr_calculatemasks();
    }
#endif
@


1.1
log
@Initial revision
@
text
@d191 1
a191 1
	sc->sc_if.if_flags = IFF_POINTOPOINT;
d524 13
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
