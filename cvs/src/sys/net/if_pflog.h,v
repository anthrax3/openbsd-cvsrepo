head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.26.0.12
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.10
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.4
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.6
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.12
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.14
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.10
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.8
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.27
date	2017.05.16.11.36.16;	author mpi;	state Exp;
branches;
next	1.26;
commitid	Ecvl7uW4tm7A68zm;

1.26
date	2015.02.12.01.24.10;	author henning;	state Exp;
branches;
next	1.25;
commitid	9O1PirN7lXfubwO8;

1.25
date	2014.07.09.11.03.04;	author henning;	state Exp;
branches;
next	1.24;
commitid	mfsvjrJC7UBF4ZGt;

1.24
date	2013.06.25.09.16.34;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2012.07.08.07.58.09;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2011.10.13.18.23.39;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2011.09.28.17.15.45;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2011.09.20.10.51.18;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.03.19.07.32;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.22.13.21.24;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.21.11.05.10;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.21.04.06.37;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.26.16.49.01;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.25.11.27.01;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.23.12.46.09;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.27.17.22.40;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.19.17.50.51;	author dhartmei;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.19.04.52.04;	author frantzen;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.15.20.27.27;	author dhartmei;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.14.08.42.00;	author canacar;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.29.19.51.04;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.08.22.02.11;	author mickey;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.06.26.21.03.28;	author provos;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.06.26.19.01.54;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.26.15.33.00;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.25.23.02.19;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.25.20.48.17;	author provos;	state Exp;
branches;
next	;

1.5.2.1
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove list member now that the global list is gone.
@
text
@/* $OpenBSD: if_pflog.h,v 1.26 2015/02/12 01:24:10 henning Exp $ */
/*
 * Copyright 2001 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _NET_IF_PFLOG_H_
#define _NET_IF_PFLOG_H_

#include <net/pfvar.h>

#define PFLOG_RULESET_NAME_SIZE	16

struct pfloghdr {
	u_int8_t	length;
	sa_family_t	af;
	u_int8_t	action;
	u_int8_t	reason;
	char		ifname[IFNAMSIZ];
	char		ruleset[PFLOG_RULESET_NAME_SIZE];
	u_int32_t	rulenr;
	u_int32_t	subrulenr;
	uid_t		uid;
	pid_t		pid;
	uid_t		rule_uid;
	pid_t		rule_pid;
	u_int8_t	dir;
	u_int8_t	rewritten;
	sa_family_t	naf;
	u_int8_t	pad[1];
	struct pf_addr	saddr;
	struct pf_addr	daddr;
	u_int16_t	sport;
	u_int16_t	dport;
};

#define PFLOG_HDRLEN		sizeof(struct pfloghdr)
/* used to be minus pad, also used as a signature */
#define PFLOG_REAL_HDRLEN	PFLOG_HDRLEN
#define PFLOG_OLD_HDRLEN	offsetof(struct pfloghdr, pad)

#ifdef _KERNEL

struct pflog_softc {
	struct ifnet		sc_if;		/* the interface */
	int			sc_unit;
};

#if NPFLOG > 0
#define	PFLOG_PACKET(a,b,c,d,e,f) pflog_packet(a,b,c,d,e,f)
#else
#define	PFLOG_PACKET(a,b,c,d,e,f) ((void)0)
#endif /* NPFLOG > 0 */
#endif /* _KERNEL */
#endif /* _NET_IF_PFLOG_H_ */
@


1.26
log
@change log(matches) semantics slightly to make it more useful. since it
is a debug tool change of semantics not considered problematic.
up until now, log(matches) forced logging on subsequent matching rules,
the actual logging used the log settings from that matched rule.
now, log(matches) causes subsequent matches to be logged with the log settings
from the log(matches) rule. in particular (this was the driving point),
log(matches, to pflog23) allows you to have the trace log going to a seperate
pflog interface, not clobbering your regular pflogs, actually not affecting
them at all.
long conversation with bluhm about it, which didn't lead to a single bit
changed in the diff but was very very helpful. ok bluhm as well.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.25 2014/07/09 11:03:04 henning Exp $ */
a66 1
	LIST_ENTRY(pflog_softc)	sc_list;
@


1.25
log
@tedu bpf_mtap_pflog().
now that it is a trivial wrapper around the extended bpf_mtap_hdr, we can
use bpf_mtap_hdr directly. added benefit: pflog_bpfcopy doesn't need to
be exported any more and can stay private to if_pflog.c
ok benno bluhm reyk
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.23 2012/07/08 07:58:09 henning Exp $ */
d71 1
a71 1
#define	PFLOG_PACKET(a,b,c,d,e) pflog_packet(a,b,c,d,e)
d73 1
a73 1
#define	PFLOG_PACKET(a,b,c,d,e) ((void)0)
@


1.24
log
@Protect various driver descriptors by _KERNEL to stop exposing to much
stuff to userland, especially the "struct ifnet".

ok sthen@@, henning@@, uebayasi@@
@
text
@a69 2
void	pflog_bpfcopy(const void *, void *, size_t);

@


1.23
log
@there was a limit on the number of pflog interfaces - 16. remove that.
mostly by dynamically allocating pflogifs instead of making that a static
array. ok claudio zinke
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.22 2011/10/13 18:23:39 claudio Exp $ */
a31 6
struct pflog_softc {
	struct ifnet		sc_if;		/* the interface */
	int			sc_unit;
	LIST_ENTRY(pflog_softc)	sc_list;
};

d63 7
@


1.22
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.21 2011/09/28 17:15:45 bluhm Exp $ */
a30 2

#define	PFLOGIFS_MAX	16
@


1.21
log
@As requested by henning, move the mbuf pointer into struct pf_pdesc.
Also sort pd to the beginning of the functions' parameter lists for
consistency.
ok henning
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.20 2011/09/20 10:51:18 bluhm Exp $ */
d57 2
a58 1
	u_int8_t	pad[2];
@


1.20
log
@Put kif and dir into pdesc an use this instead of passing the values
around.  This is a mechanical change.  Initialize pd2 and use it
where appropriate.
ok henning on an earlier version; ok mpf
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.19 2011/07/03 19:07:32 henning Exp $ */
d73 1
a73 1
#define	PFLOG_PACKET(b,d,e,f,g,h) pflog_packet(b,d,e,f,g,h)
d75 1
a75 1
#define	PFLOG_PACKET(b,d,e,f,g,h) ((void)0)
@


1.19
log
@reduce kernel compile time dramatically
(you don't need to fix this file for it to compile. oups. forgotten in the
last commit)
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.18 2011/05/22 13:21:24 claudio Exp $ */
d73 1
a73 1
#define	PFLOG_PACKET(i,b,c,d,e,f,g,h) pflog_packet(i,b,c,d,e,f,g,h)
d75 1
a75 1
#define	PFLOG_PACKET(i,b,c,d,e,f,g,h) ((void)0)
@


1.18
log
@Do not pass AF specific information to pf_test_rule() and PFLOG_PACKET()
because either the info is already available in struct pd or easy
to figure out.  Makes pf_test() and pf_test6() even more similar
(with the target to remove one of them in the near future).
OK henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.17 2010/09/21 11:05:10 henning Exp $ */
d73 1
a73 1
#define	PFLOG_PACKET(i,x,b,c,d,e,f,g,h) pflog_packet(i,b,c,d,e,f,g,h)
d75 1
a75 1
#define	PFLOG_PACKET(i,x,b,c,d,e,f,g,h) ((void)0)
@


1.17
log
@aye. that should not have been forgotten. add the rewritten indicator
to struct pflog. ok gcc
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.16 2010/09/21 04:06:37 henning Exp $ */
d73 1
a73 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g,h) pflog_packet(i,a,b,c,d,e,f,g,h)
d75 1
a75 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g,h) ((void)0)
@


1.16
log
@pflog overhaul
pflog was logging the "wrong" as in not yet rewritten (nat/rdr) addresses.
to address this without making an extra copy of the mbuf chain:
-introduce bpf_mtap_pflog, which is a 1:1 copy of bpf_mtap_hdr, except that
it supplies bpf_catchpacket with pflog_bpfcopy as copy function instead of
plain bcopy
-said new shiny pflog_bpfcopy knows what a pflog packet looks like, copies
everything into bpf's buffer, contructs a fake mbuf (which is allocated once
at attach time and reused over and over) which points to the bpf buffer
as data storage
-call pf_setup_pdesc on said fake mbuf
-then call pf_translate to rewrite the addresses as needed right in the
bpf buffer
this changes the pflog header as we have to pass the new addresses/ports
around. relies on canacar's awesome work in libpcap to work olrite with the
new, longer pflog header as well as with the old, shorter one.
almost completely written at c2k10 in canada, finished here at j2k10 in
japan. ok ryan dlg
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.15 2010/06/26 16:49:01 henning Exp $ */
d56 2
a57 1
	u_int8_t	pad[3];
@


1.15
log
@bye bye DLT_OLD_PFLOG & friends. dead since 2003. 7 years oughta be enough
ok ryan theo reyk
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.14 2006/10/25 11:27:01 henning Exp $ */
d30 2
d57 4
d64 3
a66 2
/* minus pad, also used as a signature */
#define PFLOG_REAL_HDRLEN	offsetof(struct pfloghdr, pad)
d69 1
@


1.14
log
@allow up to 16 pflog interfaces, ok mcbride
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.13 2006/10/23 12:46:09 henning Exp $ */
a59 11

/* XXX remove later when old format logs are no longer needed */
struct old_pfloghdr {
	u_int32_t af;
	char ifname[IFNAMSIZ];
	short rnr;
	u_short reason;
	u_short action;
	u_short dir;
};
#define OLD_PFLOG_HDRLEN	sizeof(struct old_pfloghdr)
@


1.13
log
@make the pflog interface clonable.
for now, only allow pflog0 to be created.
keep an array of ifps to the pflog interfaces with the unit # as index for
fast access.
if pflog0 does not exist, no logging is done (just like if it is down).
on machines without pf enabled, this makes the pflog0 interface go away,
on machines with pf, rc sets up pflog0 and starts pflogd, no change there.
idea old (pf2k4 or c2k5?), hacked at the hack.lu 2006 conference, ryan ok
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.12 2005/05/27 17:22:40 dhartmei Exp $ */
d30 1
a30 1
#define	PFLOGIFS_MAX	1
@


1.12
log
@log two pairs of uid/pid through pflog: the uid/pid of the process that
inserted the rule which causes the logging. secondly, the uid/pid of the
process in case the logged packet is delivered to/from a local socket.
a lookup of the local socket can be forced for logged packets with a new
option, 'log (user)'. make tcpdump print the additional information when
-e and -v is used. note: this changes the pflog header struct, rebuild all
dependancies. ok bob@@, henning@@.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.11 2004/05/19 17:50:51 dhartmei Exp $ */
d30 2
d33 3
a35 1
	struct ifnet	sc_if;  /* the interface */
@


1.11
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.10 2004/03/19 04:52:04 frantzen Exp $ */
d45 4
d71 1
a71 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g) pflog_packet(i,a,b,c,d,e,f,g)
d73 1
a73 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g)	((void)0)
@


1.10
log
@remove trailing ';' in PFLOG_REAL_HDRLEN definition.  ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.9 2003/07/15 20:27:27 dhartmei Exp $ */
d34 1
a34 4
/* XXX keep in sync with pfvar.h */
#ifndef PF_RULESET_NAME_SIZE
#define PF_RULESET_NAME_SIZE	 16
#endif
d42 1
a42 1
	char		ruleset[PF_RULESET_NAME_SIZE];
@


1.9
log
@Adjust pflog after recent byte order changes, fixes the 'truncated-ip'
errors on pflog0. Reported and tested by Ben Lovett. ok frantzen@@, cedric@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.8 2003/05/14 08:42:00 canacar Exp $ */
d54 1
a54 1
#define PFLOG_REAL_HDRLEN	offsetof(struct pfloghdr, pad);
@


1.8
log
@Use official (from pcap people) link type for pflog.
With this change, the log header format also changes.
The new log format is extendible and allows logging
of the originating anchor and ruleset information.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.7 2002/10/29 19:51:04 mickey Exp $ */
d70 1
a70 12
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g) \
	do { \
		if (b == AF_INET) { \
			HTONS(((struct ip *)x)->ip_len); \
			HTONS(((struct ip *)x)->ip_off); \
			pflog_packet(i,a,b,c,d,e,f,g); \
			NTOHS(((struct ip *)x)->ip_len); \
			NTOHS(((struct ip *)x)->ip_off); \
		} else { \
			pflog_packet(i,a,b,c,d,e,f,g); \
		} \
	} while (0)
@


1.7
log
@keep all pflog goodies in pflog sources, avoids code duplications; okski frantzen@@ and dhartmei@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.6 2001/11/08 22:02:11 mickey Exp $ */
d34 5
d40 18
d65 1
a65 2

#define PFLOG_HDRLEN	sizeof(struct pfloghdr)
d70 1
a70 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e) \
d75 1
a75 1
			pflog_packet(i,a,b,c,d,e); \
d79 1
a79 1
			pflog_packet(i,a,b,c,d,e); \
d83 1
a83 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e)	((void)0)
@


1.6
log
@fix the endif comment
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.5 2001/06/26 21:03:28 provos Exp $ */
d45 19
a63 1
extern struct pflog_softc pflogif[];
@


1.6.2.1
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a33 5
/* XXX keep in sync with pfvar.h */
#ifndef PF_RULESET_NAME_SIZE
#define PF_RULESET_NAME_SIZE	 16
#endif

a34 18
	u_int8_t	length;
	sa_family_t	af;
	u_int8_t	action;
	u_int8_t	reason;
	char		ifname[IFNAMSIZ];
	char		ruleset[PF_RULESET_NAME_SIZE];
	u_int32_t	rulenr;
	u_int32_t	subrulenr;
	u_int8_t	dir;
	u_int8_t	pad[3];
};

#define PFLOG_HDRLEN		sizeof(struct pfloghdr)
/* minus pad, also used as a signature */
#define PFLOG_REAL_HDRLEN	offsetof(struct pfloghdr, pad);

/* XXX remove later when old format logs are no longer needed */
struct old_pfloghdr {
a41 1
#define OLD_PFLOG_HDRLEN	sizeof(struct old_pfloghdr)
d43 1
a43 1
#ifdef _KERNEL
d45 1
a45 17
#if NPFLOG > 0
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g) \
	do { \
		if (b == AF_INET) { \
			HTONS(((struct ip *)x)->ip_len); \
			HTONS(((struct ip *)x)->ip_off); \
			pflog_packet(i,a,b,c,d,e,f,g); \
			NTOHS(((struct ip *)x)->ip_len); \
			NTOHS(((struct ip *)x)->ip_off); \
		} else { \
			pflog_packet(i,a,b,c,d,e,f,g); \
		} \
	} while (0)
#else
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g)	((void)0)
#endif /* NPFLOG > 0 */
#endif /* _KERNEL */
@


1.5
log
@clean up copyright
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.4 2001/06/26 19:01:54 provos Exp $ */
d31 1
a31 1
	struct ifnet		sc_if;  /* the interface */
d46 1
a46 1
#endif /* _NET_IF_ENC_H_ */
@


1.5.2.1
log
@merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 1
a31 1
	struct ifnet	sc_if;  /* the interface */
d46 1
a46 1
#endif /* _NET_IF_PFLOG_H_ */
@


1.5.2.2
log
@Sync the SMP branch with 3.3
@
text
@d45 1
a45 19
#ifdef _KERNEL

#if NPFLOG > 0
#define	PFLOG_PACKET(i,x,a,b,c,d,e) \
	do { \
		if (b == AF_INET) { \
			HTONS(((struct ip *)x)->ip_len); \
			HTONS(((struct ip *)x)->ip_off); \
			pflog_packet(i,a,b,c,d,e); \
			NTOHS(((struct ip *)x)->ip_len); \
			NTOHS(((struct ip *)x)->ip_off); \
		} else { \
			pflog_packet(i,a,b,c,d,e); \
		} \
	} while (0)
#else
#define	PFLOG_PACKET(i,x,a,b,c,d,e)	((void)0)
#endif /* NPFLOG > 0 */
#endif /* _KERNEL */
@


1.5.2.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a33 5
/* XXX keep in sync with pfvar.h */
#ifndef PF_RULESET_NAME_SIZE
#define PF_RULESET_NAME_SIZE	 16
#endif

a34 18
	u_int8_t	length;
	sa_family_t	af;
	u_int8_t	action;
	u_int8_t	reason;
	char		ifname[IFNAMSIZ];
	char		ruleset[PF_RULESET_NAME_SIZE];
	u_int32_t	rulenr;
	u_int32_t	subrulenr;
	u_int8_t	dir;
	u_int8_t	pad[3];
};

#define PFLOG_HDRLEN		sizeof(struct pfloghdr)
/* minus pad, also used as a signature */
#define PFLOG_REAL_HDRLEN	offsetof(struct pfloghdr, pad);

/* XXX remove later when old format logs are no longer needed */
struct old_pfloghdr {
d42 2
a43 1
#define OLD_PFLOG_HDRLEN	sizeof(struct old_pfloghdr)
d48 1
a48 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g) \
d53 1
a53 1
			pflog_packet(i,a,b,c,d,e,f,g); \
d57 1
a57 1
			pflog_packet(i,a,b,c,d,e,f,g); \
d61 1
a61 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g)	((void)0)
@


1.5.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d70 12
a81 1
#define	PFLOG_PACKET(i,x,a,b,c,d,e,f,g) pflog_packet(i,a,b,c,d,e,f,g)
@


1.5.2.5
log
@Merge with the trunk
@
text
@d34 4
a37 1
#define PFLOG_RULESET_NAME_SIZE	16
d45 1
a45 1
	char		ruleset[PFLOG_RULESET_NAME_SIZE];
d54 1
a54 1
#define PFLOG_REAL_HDRLEN	offsetof(struct pfloghdr, pad)
@


1.4
log
@use reasons in pull_hdr, default log if pull_hdr fails. okay deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.3 2001/06/26 15:33:00 provos Exp $ */
d3 2
a4 3
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
d6 19
a24 27
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
@


1.3
log
@add a subreason to the link header to allow us to determine why a packet was
dropped or passed.  from discussion with theo and me.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.2 2001/06/25 23:02:19 provos Exp $ */
d46 1
a46 1
	u_short rnr;
@


1.2
log
@extend the logging via a new link header type.  export interface, direction,
action and rule nr.
@
text
@d1 1
a1 1
/* $OpenBSD: if_pflog.h,v 1.1 2001/06/25 20:48:17 provos Exp $ */
d46 4
a49 3
	int rnr;
	short dir;
	short action;
@


1.1
log
@first stab at packet logging for pf.  inspired by late night dreams of art.
we just pass drop and passed packets to different pseudo interface that
can be listened to with bpf.
@
text
@d1 1
a1 1
/* $OpenBSD: if_enc.h,v 1.8 2001/06/25 05:14:00 angelos Exp $ */
a38 2
#define PFLOG_HDRLEN	4

d45 4
d50 2
@

