head	1.63;
access;
symbols
	OPENBSD_6_2:1.63.0.2
	OPENBSD_6_2_BASE:1.63
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.63
date	2017.08.12.20.27.28;	author mpi;	state Exp;
branches;
next	1.62;
commitid	ex07ODV5fGEkSmvx;

1.62
date	2017.08.11.21.24.19;	author mpi;	state Exp;
branches;
next	1.61;
commitid	qO4hXiGM2yDTtiTI;

1.61
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.60;
commitid	p51F2KIwIJB1dU8P;

1.60
date	2017.05.28.18.43.51;	author yasuoka;	state Exp;
branches;
next	1.59;
commitid	mNrUYdMVKiPpnA49;

1.59
date	2017.05.28.12.51.34;	author yasuoka;	state Exp;
branches;
next	1.58;
commitid	2vGVzcFLNmfkoMEp;

1.58
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.57;
commitid	Gef6NNDxonzfVaq2;

1.57
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.56;
commitid	6c6qq5OdS4VVnyVM;

1.56
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.55;
commitid	RlO92XR575sygHqm;

1.55
date	2016.09.15.01.37.34;	author dlg;	state Exp;
branches;
next	1.54;
commitid	6y8GIOiNxzKtzjdD;

1.54
date	2016.09.09.04.48.26;	author dlg;	state Exp;
branches;
next	1.53;
commitid	0yH1sj1oV22Ybe6w;

1.53
date	2016.09.05.07.41.22;	author dlg;	state Exp;
branches;
next	1.52;
commitid	sCJHkvGbY32VVqBs;

1.52
date	2016.08.23.12.37.11;	author dlg;	state Exp;
branches;
next	1.51;
commitid	oksHUu7XGqXmUkCH;

1.51
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.50;
commitid	Xo6g1xk26RWDGcjJ;

1.50
date	2016.01.31.13.54.13;	author stefan;	state Exp;
branches;
next	1.49;
commitid	R4X61RORL7hWwUvP;

1.49
date	2016.01.14.09.20.31;	author mpi;	state Exp;
branches;
next	1.48;
commitid	mmanJIPww2fqlSXb;

1.48
date	2015.12.05.16.09.09;	author yasuoka;	state Exp;
branches;
next	1.47;
commitid	eScyCzcQlMEbBURx;

1.47
date	2015.12.03.17.03.33;	author bluhm;	state Exp;
branches;
next	1.46;
commitid	XHyaGPvfq4igrzZS;

1.46
date	2015.11.20.05.31.24;	author dlg;	state Exp;
branches;
next	1.45;
commitid	P3dESHZ62UE2k9cN;

1.45
date	2015.11.03.12.02.59;	author dlg;	state Exp;
branches;
next	1.44;
commitid	FoA8fHBIBjP3x2DN;

1.44
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.43;
commitid	G2nTzngqgXpQqcJB;

1.43
date	2015.09.06.12.59.20;	author kettenis;	state Exp;
branches;
next	1.42;
commitid	iOs1zHADUd9zOPov;

1.42
date	2015.07.18.15.51.16;	author mpi;	state Exp;
branches;
next	1.41;
commitid	lwQKRpFyNEr7kjoF;

1.41
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	ncpqEGjDtSFuLAgn;

1.40
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.39;
commitid	9ERVupAoYqW4Iok9;

1.39
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.38;
commitid	fE8TgA9vpwdUU5Wy;

1.38
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.37;
commitid	1aiWjheMGhmTuiHL;

1.37
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.36;
commitid	c7ei8kPelCOOwHXy;

1.36
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.35;
commitid	C5iGb36LQxjM60Q3;

1.35
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.34;
commitid	zhW8jJrfVCoAthrR;

1.34
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.33;
commitid	ZqXwxwmeo3l29NOg;

1.33
date	2014.08.19.08.04.51;	author uebayasi;	state Exp;
branches;
next	1.32;
commitid	XDoSkV9k7uIJj8tJ;

1.32
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.31;
commitid	DQakU8LLWV6Iwx84;

1.31
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.30;
commitid	B4dZSbxas1X1IpXI;

1.30
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.08.04.26.53;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.05.13.30.59;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.04.03.34.41;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.19.14.46.30;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.17.16.27.41;	author bluhm;	state Exp;
branches;
next	1.24;

1.24
date	2013.08.08.07.39.13;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2013.06.24.09.34.59;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.18.09.15.13;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.31.19.16.52;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.10.01.35.55;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2013.02.06.22.58.18;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.19.17.50.17;	author yasuoka;	state Exp;
branches;
next	1.14;

1.14
date	2012.04.14.09.39.47;	author yasuoka;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.25.23.54.58;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2011.10.15.03.24.11;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2011.08.21.09.00.15;	author jmatthew;	state Exp;
branches;
next	1.10;

1.10
date	2011.08.20.06.21.32;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.07.20.42.56;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.14.05.13.45;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.02.11.52.44;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.02.11.49.19;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.28.06.43.00;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.24.00.56.08;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.29.08.22.27;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.22.13.03.48;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Use the NET_LOCK() macro instead of handrolling it.

Tested by Hrvoje Popovski.
@
text
@/*	$OpenBSD: if_pppx.c,v 1.62 2017/08/11 21:24:19 mpi Exp $ */

/*
 * Copyright (c) 2010 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2010 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/pool.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/vnode.h>
#include <sys/poll.h>
#include <sys/selinfo.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/if_dl.h>

#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/nd6.h>
#endif /* INET6 */

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <net/ppp_defs.h>
#include <net/ppp-comp.h>
#include <crypto/arc4.h>

#ifdef PIPEX
#include <net/radix.h>
#include <net/pipex.h>
#include <net/pipex_local.h>
#else
#error PIPEX option not enabled
#endif

#ifdef PPPX_DEBUG
#define PPPX_D_INIT	(1<<0)

int pppxdebug = 0;

#define DPRINTF(_m, _p...)	do { \
					if (ISSET(pppxdebug, (_m))) \
						printf(_p); \
				} while (0)
#else
#define DPRINTF(_m, _p...)	/* _m, _p */
#endif


struct pppx_if;

struct pppx_dev {
	LIST_ENTRY(pppx_dev)	pxd_entry;
	int			pxd_unit;

	/* kq shizz */
	struct selinfo		pxd_rsel;
	struct mutex		pxd_rsel_mtx;
	struct selinfo		pxd_wsel;
	struct mutex		pxd_wsel_mtx;

	/* queue of packets for userland to service - protected by splnet */
	struct mbuf_queue	pxd_svcq;
	int			pxd_waiting;
	LIST_HEAD(,pppx_if)	pxd_pxis;
};

struct rwlock			pppx_devs_lk = RWLOCK_INITIALIZER("pppxdevs");
LIST_HEAD(, pppx_dev)		pppx_devs = LIST_HEAD_INITIALIZER(pppx_devs);
struct pool			*pppx_if_pl;

struct pppx_dev			*pppx_dev_lookup(dev_t);
struct pppx_dev			*pppx_dev2pxd(dev_t);

struct pppx_if_key {
	int			pxik_session_id;
	int			pxik_protocol;
};

struct pppx_if {
	struct pppx_if_key	pxi_key; /* must be first in the struct */

	RBT_ENTRY(pppx_if)	pxi_entry;
	LIST_ENTRY(pppx_if)	pxi_list;

	int			pxi_unit;
	struct ifnet		pxi_if;
	struct pppx_dev		*pxi_dev;
	struct pipex_session	pxi_session;
	struct pipex_iface_context	pxi_ifcontext;
};

static inline int
pppx_if_cmp(const struct pppx_if *a, const struct pppx_if *b)
{
	return memcmp(&a->pxi_key, &b->pxi_key, sizeof(a->pxi_key));
}

struct rwlock			pppx_ifs_lk = RWLOCK_INITIALIZER("pppxifs");
RBT_HEAD(pppx_ifs, pppx_if)	pppx_ifs = RBT_INITIALIZER(&pppx_ifs);
RBT_PROTOTYPE(pppx_ifs, pppx_if, pxi_entry, pppx_if_cmp);

int		pppx_if_next_unit(void);
struct pppx_if *pppx_if_find(struct pppx_dev *, int, int);
int		pppx_add_session(struct pppx_dev *,
		    struct pipex_session_req *);
int		pppx_del_session(struct pppx_dev *,
		    struct pipex_session_close_req *);
int		pppx_set_session_descr(struct pppx_dev *,
		    struct pipex_session_descr_req *);

void		pppx_if_destroy(struct pppx_dev *, struct pppx_if *);
void		pppx_if_start(struct ifnet *);
int		pppx_if_output(struct ifnet *, struct mbuf *,
		    struct sockaddr *, struct rtentry *);
int		pppx_if_ioctl(struct ifnet *, u_long, caddr_t);


void		pppxattach(int);

void		filt_pppx_rdetach(struct knote *);
int		filt_pppx_read(struct knote *, long);

struct filterops pppx_rd_filtops = {
	1,
	NULL,
	filt_pppx_rdetach,
	filt_pppx_read
};

void		filt_pppx_wdetach(struct knote *);
int		filt_pppx_write(struct knote *, long);

struct filterops pppx_wr_filtops = {
	1,
	NULL,
	filt_pppx_wdetach,
	filt_pppx_write
};

struct pppx_dev *
pppx_dev_lookup(dev_t dev)
{
	struct pppx_dev *pxd;
	int unit = minor(dev);

	/* must hold pppx_devs_lk */

	LIST_FOREACH(pxd, &pppx_devs, pxd_entry) {
		if (pxd->pxd_unit == unit)
			return (pxd);
	}

	return (NULL);
}

struct pppx_dev *
pppx_dev2pxd(dev_t dev)
{
	struct pppx_dev *pxd;

	rw_enter_read(&pppx_devs_lk);
	pxd = pppx_dev_lookup(dev);
	rw_exit_read(&pppx_devs_lk);

	return (pxd);
}

void
pppxattach(int n)
{
	pipex_init();
}

int
pppxopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct pppx_dev *pxd;
	int rv = 0;

	rv = rw_enter(&pppx_devs_lk, RW_WRITE | RW_INTR);
	if (rv != 0)
		return (rv);

	pxd = pppx_dev_lookup(dev);
	if (pxd != NULL) {
		rv = EBUSY;
		goto out;
	}

	if (LIST_EMPTY(&pppx_devs) && pppx_if_pl == NULL) {
		pppx_if_pl = malloc(sizeof(*pppx_if_pl), M_DEVBUF, M_WAITOK);
		pool_init(pppx_if_pl, sizeof(struct pppx_if), 0, IPL_NONE,
		    PR_WAITOK, "pppxif", NULL);
	}

	pxd = malloc(sizeof(*pxd), M_DEVBUF, M_WAITOK | M_ZERO);

	pxd->pxd_unit = minor(dev);
	mtx_init(&pxd->pxd_rsel_mtx, IPL_NET);
	mtx_init(&pxd->pxd_wsel_mtx, IPL_NET);
	LIST_INIT(&pxd->pxd_pxis);

	mq_init(&pxd->pxd_svcq, 128, IPL_NET);
	LIST_INSERT_HEAD(&pppx_devs, pxd, pxd_entry);

out:
	rw_exit(&pppx_devs_lk);
	return (rv);
}

int
pppxread(dev_t dev, struct uio *uio, int ioflag)
{
	struct pppx_dev *pxd = pppx_dev2pxd(dev);
	struct mbuf *m, *m0;
	int error = 0;
	size_t len;

	if (!pxd)
		return (ENXIO);

	while ((m0 = mq_dequeue(&pxd->pxd_svcq)) == NULL) {
		if (ISSET(ioflag, IO_NDELAY))
			return (EWOULDBLOCK);

		NET_LOCK();
		pxd->pxd_waiting = 1;
		error = rwsleep(pxd, &netlock,
		    (PZERO + 1)|PCATCH, "pppxread", 0);
		NET_UNLOCK();
		if (error != 0) {
			return (error);
		}
	}

	while (m0 != NULL && uio->uio_resid > 0 && error == 0) {
		len = ulmin(uio->uio_resid, m0->m_len);
		if (len != 0)
			error = uiomove(mtod(m0, caddr_t), len, uio);
		m = m_free(m0);
		m0 = m;
	}

	m_freem(m0);

	return (error);
}

int
pppxwrite(dev_t dev, struct uio *uio, int ioflag)
{
	struct pppx_dev *pxd = pppx_dev2pxd(dev);
	struct pppx_hdr *th;
	struct pppx_if	*pxi;
	uint32_t proto;
	struct mbuf *top, **mp, *m;
	int tlen;
	int error = 0;
	size_t mlen;

	if (uio->uio_resid < sizeof(*th) + sizeof(uint32_t) ||
	    uio->uio_resid > MCLBYTES)
		return (EMSGSIZE);

	tlen = uio->uio_resid;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);
	mlen = MHLEN;
	if (uio->uio_resid >= MINCLSIZE) {
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_free(m);
			return (ENOBUFS);
		}
		mlen = MCLBYTES;
	}

	top = NULL;
	mp = &top;

	while (error == 0 && uio->uio_resid > 0) {
		m->m_len = ulmin(mlen, uio->uio_resid);
		error = uiomove(mtod (m, caddr_t), m->m_len, uio);
		*mp = m;
		mp = &m->m_next;
		if (error == 0 && uio->uio_resid > 0) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				error = ENOBUFS;
				break;
			}
			mlen = MLEN;
			if (uio->uio_resid >= MINCLSIZE) {
				MCLGET(m, M_DONTWAIT);
				if (!(m->m_flags & M_EXT)) {
					error = ENOBUFS;
					m_free(m);
					break;
				}
				mlen = MCLBYTES;
			}
		}
	}

	if (error) {
		m_freem(top);
		return (error);
	}

	top->m_pkthdr.len = tlen;

	/* Find the interface */
	th = mtod(top, struct pppx_hdr *);
	m_adj(top, sizeof(struct pppx_hdr));
	pxi = pppx_if_find(pxd, th->pppx_id, th->pppx_proto);
	if (pxi == NULL) {
		m_freem(top);
		return (EINVAL);
	}
	top->m_pkthdr.ph_ifidx = pxi->pxi_if.if_index;

#if NBPFILTER > 0
	if (pxi->pxi_if.if_bpf)
		bpf_mtap(pxi->pxi_if.if_bpf, top, BPF_DIRECTION_IN);
#endif
	/* strip the tunnel header */
	proto = ntohl(*(uint32_t *)(th + 1));
	m_adj(top, sizeof(uint32_t));

	switch (proto) {
	case AF_INET:
		ipv4_input(&pxi->pxi_if, top);
		break;
#ifdef INET6
	case AF_INET6:
		ipv6_input(&pxi->pxi_if, top);
		break;
#endif
	default:
		m_freem(top);
		return (EAFNOSUPPORT);
	}

	return (error);
}

int
pppxioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
{
	struct pppx_dev *pxd = pppx_dev2pxd(dev);
	int error = 0;

	NET_LOCK();
	switch (cmd) {
	case PIPEXSMODE:
		/*
		 * npppd always enables on open, and only disables before
		 * closing. we cheat and let open and close do that, so lie
		 * to npppd.
		 */
		break;
	case PIPEXGMODE:
		*(int *)addr = 1;
		break;

	case PIPEXASESSION:
		error = pppx_add_session(pxd,
		    (struct pipex_session_req *)addr);
		break;

	case PIPEXDSESSION:
		error = pppx_del_session(pxd,
		    (struct pipex_session_close_req *)addr);
		break;

	case PIPEXCSESSION:
		error = pipex_config_session(
		    (struct pipex_session_config_req *)addr);
		break;

	case PIPEXGSTAT:
		error = pipex_get_stat((struct pipex_session_stat_req *)addr);
		break;

	case PIPEXGCLOSED:
		error = pipex_get_closed((struct pipex_session_list_req *)addr);
		break;

	case PIPEXSIFDESCR:
		error = pppx_set_session_descr(pxd,
		    (struct pipex_session_descr_req *)addr);
		break;

	case FIONBIO:
	case FIOASYNC:
	case FIONREAD:
		break;

	default:
		error = ENOTTY;
		break;
	}
	NET_UNLOCK();

	return (error);
}

int
pppxpoll(dev_t dev, int events, struct proc *p)
{
	struct pppx_dev *pxd = pppx_dev2pxd(dev);
	int revents = 0;

	if (events & (POLLIN | POLLRDNORM)) {
		if (!mq_empty(&pxd->pxd_svcq))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM))
		revents |= events & (POLLOUT | POLLWRNORM);

	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &pxd->pxd_rsel);
	}

	return (revents);
}

int
pppxkqfilter(dev_t dev, struct knote *kn)
{
	struct pppx_dev *pxd = pppx_dev2pxd(dev);
	struct mutex *mtx;
	struct klist *klist;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		mtx = &pxd->pxd_rsel_mtx;
		klist = &pxd->pxd_rsel.si_note;
		kn->kn_fop = &pppx_rd_filtops;
		break;
	case EVFILT_WRITE:
		mtx = &pxd->pxd_wsel_mtx;
		klist = &pxd->pxd_wsel.si_note;
		kn->kn_fop = &pppx_wr_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)pxd;

	mtx_enter(mtx);
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	mtx_leave(mtx);

	return (0);
}

void
filt_pppx_rdetach(struct knote *kn)
{
	struct pppx_dev *pxd = (struct pppx_dev *)kn->kn_hook;
	struct klist *klist = &pxd->pxd_rsel.si_note;

	if (ISSET(kn->kn_status, KN_DETACHED))
		return;

	mtx_enter(&pxd->pxd_rsel_mtx);
	SLIST_REMOVE(klist, kn, knote, kn_selnext);
	mtx_leave(&pxd->pxd_rsel_mtx);
}

int
filt_pppx_read(struct knote *kn, long hint)
{
	struct pppx_dev *pxd = (struct pppx_dev *)kn->kn_hook;

	if (ISSET(kn->kn_status, KN_DETACHED)) {
		kn->kn_data = 0;
		return (1);
	}

	kn->kn_data = mq_len(&pxd->pxd_svcq);

	return (kn->kn_data > 0);
}

void
filt_pppx_wdetach(struct knote *kn)
{
	struct pppx_dev *pxd = (struct pppx_dev *)kn->kn_hook;
	struct klist *klist = &pxd->pxd_wsel.si_note;

	if (ISSET(kn->kn_status, KN_DETACHED))
		return;

	mtx_enter(&pxd->pxd_wsel_mtx);
	SLIST_REMOVE(klist, kn, knote, kn_selnext);
	mtx_leave(&pxd->pxd_wsel_mtx);
}

int
filt_pppx_write(struct knote *kn, long hint)
{
	/* We're always ready to accept a write. */
	return (1);
}

int
pppxclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct pppx_dev *pxd;
	struct pppx_if	*pxi;

	rw_enter_write(&pppx_devs_lk);

	pxd = pppx_dev_lookup(dev);

	/* XXX */
	while ((pxi = LIST_FIRST(&pxd->pxd_pxis)))
		pppx_if_destroy(pxd, pxi);

	LIST_REMOVE(pxd, pxd_entry);

	mq_purge(&pxd->pxd_svcq);

	free(pxd, M_DEVBUF, 0);

	if (LIST_EMPTY(&pppx_devs)) {
		pool_destroy(pppx_if_pl);
		free(pppx_if_pl, M_DEVBUF, 0);
		pppx_if_pl = NULL;
	}

	rw_exit_write(&pppx_devs_lk);
	return (0);
}

int
pppx_if_next_unit(void)
{
	struct pppx_if *pxi;
	int unit = 0;

	rw_assert_wrlock(&pppx_ifs_lk);

	/* this is safe without splnet since we're not modifying it */
	do {
		int found = 0;
		RBT_FOREACH(pxi, pppx_ifs, &pppx_ifs) {
			if (pxi->pxi_unit == unit) {
				found = 1;
				break;
			}
		}

		if (found == 0)
			break;
		unit++;
	} while (unit > 0);

	return (unit);
}

struct pppx_if *
pppx_if_find(struct pppx_dev *pxd, int session_id, int protocol)
{
	struct pppx_if *s, *p;
	s = malloc(sizeof(*s), M_DEVBUF, M_WAITOK | M_ZERO);

	s->pxi_key.pxik_session_id = session_id;
	s->pxi_key.pxik_protocol = protocol;

	rw_enter_read(&pppx_ifs_lk);
	p = RBT_FIND(pppx_ifs, &pppx_ifs, s);
	rw_exit_read(&pppx_ifs_lk);

	free(s, M_DEVBUF, 0);
	return (p);
}

int
pppx_add_session(struct pppx_dev *pxd, struct pipex_session_req *req)
{
	struct pppx_if *pxi;
	struct pipex_session *session;
	struct pipex_hash_head *chain;
	struct ifnet *ifp;
	int unit, error = 0;
	struct in_ifaddr *ia;
	struct sockaddr_in ifaddr;
#ifdef PIPEX_PPPOE
	struct ifnet *over_ifp = NULL;
#endif

	switch (req->pr_protocol) {
#ifdef PIPEX_PPPOE
	case PIPEX_PROTO_PPPOE:
		over_ifp = ifunit(req->pr_proto.pppoe.over_ifname);
		if (over_ifp == NULL)
			return (EINVAL);
		if (req->pr_peer_address.ss_family != AF_UNSPEC)
			return (EINVAL);
		break;
#endif
#ifdef PIPEX_PPTP
	case PIPEX_PROTO_PPTP:
#endif
#ifdef PIPEX_L2TP
	case PIPEX_PROTO_L2TP:
#endif
		switch (req->pr_peer_address.ss_family) {
		case AF_INET:
			if (req->pr_peer_address.ss_len != sizeof(struct sockaddr_in))
				return (EINVAL);
			break;
#ifdef INET6
		case AF_INET6:
			if (req->pr_peer_address.ss_len != sizeof(struct sockaddr_in6))
				return (EINVAL);
			break;
#endif
		default:
			return (EPROTONOSUPPORT);
		}
		if (req->pr_peer_address.ss_family !=
		    req->pr_local_address.ss_family ||
		    req->pr_peer_address.ss_len !=
		    req->pr_local_address.ss_len)
			return (EINVAL);
		break;
	default:
		return (EPROTONOSUPPORT);
	}

	pxi = pool_get(pppx_if_pl, PR_WAITOK | PR_ZERO);
	if (pxi == NULL)
		return (ENOMEM);

	session = &pxi->pxi_session;
	ifp = &pxi->pxi_if;

	/* fake a pipex interface context */
	session->pipex_iface = &pxi->pxi_ifcontext;
	session->pipex_iface->ifnet_this = ifp;
	session->pipex_iface->pipexmode = PIPEX_ENABLED;

	/* setup session */
	session->state = PIPEX_STATE_OPENED;
	session->protocol = req->pr_protocol;
	session->session_id = req->pr_session_id;
	session->peer_session_id = req->pr_peer_session_id;
	session->peer_mru = req->pr_peer_mru;
	session->timeout_sec = req->pr_timeout_sec;
	session->ppp_flags = req->pr_ppp_flags;
	session->ppp_id = req->pr_ppp_id;

	session->ip_forward = 1;

	session->ip_address.sin_family = AF_INET;
	session->ip_address.sin_len = sizeof(struct sockaddr_in);
	session->ip_address.sin_addr = req->pr_ip_address;

	session->ip_netmask.sin_family = AF_INET;
	session->ip_netmask.sin_len = sizeof(struct sockaddr_in);
	session->ip_netmask.sin_addr = req->pr_ip_netmask;

	if (session->ip_netmask.sin_addr.s_addr == 0L)
		session->ip_netmask.sin_addr.s_addr = 0xffffffffL;
	session->ip_address.sin_addr.s_addr &=
	    session->ip_netmask.sin_addr.s_addr;

	if (req->pr_peer_address.ss_len > 0)
		memcpy(&session->peer, &req->pr_peer_address,
		    MIN(req->pr_peer_address.ss_len, sizeof(session->peer)));
	if (req->pr_local_address.ss_len > 0)
		memcpy(&session->local, &req->pr_local_address,
		    MIN(req->pr_local_address.ss_len, sizeof(session->local)));
#ifdef PIPEX_PPPOE
	if (req->pr_protocol == PIPEX_PROTO_PPPOE)
		session->proto.pppoe.over_ifidx = over_ifp->if_index;
#endif
#ifdef PIPEX_PPTP
	if (req->pr_protocol == PIPEX_PROTO_PPTP) {
		struct pipex_pptp_session *sess_pptp = &session->proto.pptp;

		sess_pptp->snd_gap = 0;
		sess_pptp->rcv_gap = 0;
		sess_pptp->snd_una = req->pr_proto.pptp.snd_una;
		sess_pptp->snd_nxt = req->pr_proto.pptp.snd_nxt;
		sess_pptp->rcv_nxt = req->pr_proto.pptp.rcv_nxt;
		sess_pptp->rcv_acked = req->pr_proto.pptp.rcv_acked;

		sess_pptp->winsz = req->pr_proto.pptp.winsz;
		sess_pptp->maxwinsz = req->pr_proto.pptp.maxwinsz;
		sess_pptp->peer_maxwinsz = req->pr_proto.pptp.peer_maxwinsz;
		/* last ack number */
		sess_pptp->ul_snd_una = sess_pptp->snd_una - 1;
	}
#endif
#ifdef PIPEX_L2TP
	if (req->pr_protocol == PIPEX_PROTO_L2TP) {
		struct pipex_l2tp_session *sess_l2tp = &session->proto.l2tp;

		/* session keys */
		sess_l2tp->tunnel_id = req->pr_proto.l2tp.tunnel_id;
		sess_l2tp->peer_tunnel_id = req->pr_proto.l2tp.peer_tunnel_id;

		/* protocol options */
		sess_l2tp->option_flags = req->pr_proto.l2tp.option_flags;

		/* initial state of dynamic context */
		sess_l2tp->ns_gap = sess_l2tp->nr_gap = 0;
		sess_l2tp->ns_nxt = req->pr_proto.l2tp.ns_nxt;
		sess_l2tp->nr_nxt = req->pr_proto.l2tp.nr_nxt;
		sess_l2tp->ns_una = req->pr_proto.l2tp.ns_una;
		sess_l2tp->nr_acked = req->pr_proto.l2tp.nr_acked;
		/* last ack number */
		sess_l2tp->ul_ns_una = sess_l2tp->ns_una - 1;
	}
#endif
#ifdef PIPEX_MPPE
	if ((req->pr_ppp_flags & PIPEX_PPP_MPPE_ACCEPTED) != 0)
		pipex_session_init_mppe_recv(session,
		    req->pr_mppe_recv.stateless, req->pr_mppe_recv.keylenbits,
		    req->pr_mppe_recv.master_key);
	if ((req->pr_ppp_flags & PIPEX_PPP_MPPE_ENABLED) != 0)
		pipex_session_init_mppe_send(session,
		    req->pr_mppe_send.stateless, req->pr_mppe_send.keylenbits,
		    req->pr_mppe_send.master_key);

	if (pipex_session_is_mppe_required(session)) {
		if (!pipex_session_is_mppe_enabled(session) ||
		    !pipex_session_is_mppe_accepted(session)) {
			pool_put(pppx_if_pl, pxi);
			return (EINVAL);
		}
	}
#endif

	/* try to set the interface up */
	rw_enter_write(&pppx_ifs_lk);
	unit = pppx_if_next_unit();
	if (unit < 0) {
		pool_put(pppx_if_pl, pxi);
		error = ENOMEM;
		goto out;
	}

	pxi->pxi_unit = unit;
	pxi->pxi_key.pxik_session_id = req->pr_session_id;
	pxi->pxi_key.pxik_protocol = req->pr_protocol;
	pxi->pxi_dev = pxd;

	/* this is safe without splnet since we're not modifying it */
	if (RBT_FIND(pppx_ifs, &pppx_ifs, pxi) != NULL) {
		pool_put(pppx_if_pl, pxi);
		error = EADDRINUSE;
		goto out;
	}

	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d", "pppx", unit);
	ifp->if_mtu = req->pr_peer_mru;	/* XXX */
	ifp->if_flags = IFF_POINTOPOINT | IFF_MULTICAST | IFF_UP;
	ifp->if_start = pppx_if_start;
	ifp->if_output = pppx_if_output;
	ifp->if_ioctl = pppx_if_ioctl;
	ifp->if_rtrequest = p2p_rtrequest;
	ifp->if_type = IFT_PPP;
	IFQ_SET_MAXLEN(&ifp->if_snd, 1);
	ifp->if_softc = pxi;
	/* ifp->if_rdomain = req->pr_rdomain; */

	/* hook up pipex context */
	chain = PIPEX_ID_HASHTABLE(session->session_id);
	LIST_INSERT_HEAD(chain, session, id_chain);
	LIST_INSERT_HEAD(&pipex_session_list, session, session_list);
	switch (req->pr_protocol) {
	case PIPEX_PROTO_PPTP:
	case PIPEX_PROTO_L2TP:
		chain = PIPEX_PEER_ADDR_HASHTABLE(
		    pipex_sockaddr_hash_key(&session->peer.sa));
		LIST_INSERT_HEAD(chain, session, peer_addr_chain);
		break;
	}

	/* if first session is added, start timer */
	if (LIST_NEXT(session, session_list) == NULL)
		pipex_timer_start();

	/* XXXSMP breaks atomicity */
	NET_UNLOCK();
	if_attach(ifp);
	NET_LOCK();

	if_addgroup(ifp, "pppx");
	if_alloc_sadl(ifp);

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
#endif
	SET(ifp->if_flags, IFF_RUNNING);

	if (RBT_INSERT(pppx_ifs, &pppx_ifs, pxi) != NULL)
		panic("pppx_ifs modified while lock was held");
	LIST_INSERT_HEAD(&pxd->pxd_pxis, pxi, pxi_list);

	/* XXX ipv6 support?  how does the caller indicate it wants ipv6
	 * instead of ipv4?
	 */
	memset(&ifaddr, 0, sizeof(ifaddr));
	ifaddr.sin_family = AF_INET;
	ifaddr.sin_len = sizeof(ifaddr);
	ifaddr.sin_addr = req->pr_ip_srcaddr;

	ia = malloc(sizeof (*ia), M_IFADDR, M_WAITOK | M_ZERO);

	ia->ia_addr.sin_family = AF_INET;
	ia->ia_addr.sin_len = sizeof(struct sockaddr_in);
	ia->ia_addr.sin_addr = req->pr_ip_srcaddr;

	ia->ia_dstaddr.sin_family = AF_INET;
	ia->ia_dstaddr.sin_len = sizeof(struct sockaddr_in);
	ia->ia_dstaddr.sin_addr = req->pr_ip_address;

	ia->ia_sockmask.sin_family = AF_INET;
	ia->ia_sockmask.sin_len = sizeof(struct sockaddr_in);
	ia->ia_sockmask.sin_addr = req->pr_ip_netmask;

	ia->ia_ifa.ifa_addr = sintosa(&ia->ia_addr);
	ia->ia_ifa.ifa_dstaddr = sintosa(&ia->ia_dstaddr);
	ia->ia_ifa.ifa_netmask = sintosa(&ia->ia_sockmask);
	ia->ia_ifa.ifa_ifp = ifp;

	ia->ia_netmask = ia->ia_sockmask.sin_addr.s_addr;

	error = in_ifinit(ifp, ia, &ifaddr, 1);
	if (error) {
		printf("pppx: unable to set addresses for %s, error=%d\n",
		    ifp->if_xname, error);
	} else {
		dohooks(ifp->if_addrhooks, 0);
	}

out:
	rw_exit_write(&pppx_ifs_lk);

	return (error);
}

int
pppx_del_session(struct pppx_dev *pxd, struct pipex_session_close_req *req)
{
	struct pppx_if *pxi;

	pxi = pppx_if_find(pxd, req->pcr_session_id, req->pcr_protocol);
	if (pxi == NULL)
		return (EINVAL);

	req->pcr_stat = pxi->pxi_session.stat;

	pppx_if_destroy(pxd, pxi);
	return (0);
}

int
pppx_set_session_descr(struct pppx_dev *pxd,
    struct pipex_session_descr_req *req)
{
	struct pppx_if *pxi;

	pxi = pppx_if_find(pxd, req->pdr_session_id, req->pdr_protocol);
	if (pxi == NULL)
		return (EINVAL);

	(void)memset(pxi->pxi_if.if_description, 0, IFDESCRSIZE);
	strlcpy(pxi->pxi_if.if_description, req->pdr_descr, IFDESCRSIZE);

	return (0);
}

void
pppx_if_destroy(struct pppx_dev *pxd, struct pppx_if *pxi)
{
	struct ifnet *ifp;
	struct pipex_session *session;

	NET_ASSERT_LOCKED();
	session = &pxi->pxi_session;
	ifp = &pxi->pxi_if;

	LIST_REMOVE(session, id_chain);
	LIST_REMOVE(session, session_list);
	switch (session->protocol) {
	case PIPEX_PROTO_PPTP:
	case PIPEX_PROTO_L2TP:
		LIST_REMOVE((struct pipex_session *)session,
		    peer_addr_chain);
		break;
	}

	/* if final session is destroyed, stop timer */
	if (LIST_EMPTY(&pipex_session_list))
		pipex_timer_stop();

	/* XXXSMP breaks atomicity */
	NET_UNLOCK();
	if_detach(ifp);
	NET_LOCK();

	rw_enter_write(&pppx_ifs_lk);
	if (RBT_REMOVE(pppx_ifs, &pppx_ifs, pxi) == NULL)
		panic("pppx_ifs modified while lock was held");
	LIST_REMOVE(pxi, pxi_list);
	rw_exit_write(&pppx_ifs_lk);

	pool_put(pppx_if_pl, pxi);
}

void
pppx_if_start(struct ifnet *ifp)
{
	struct pppx_if *pxi = (struct pppx_if *)ifp->if_softc;
	struct mbuf *m;
	int proto;

	if (!ISSET(ifp->if_flags, IFF_RUNNING))
		return;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);

		if (m == NULL)
			break;

		proto = *mtod(m, int *);
		m_adj(m, sizeof(proto));

		ifp->if_obytes += m->m_pkthdr.len;
		ifp->if_opackets++;

		pipex_ppp_output(m, &pxi->pxi_session, proto);
	}
}

int
pppx_if_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	struct pppx_if *pxi = (struct pppx_if *)ifp->if_softc;
	struct pppx_hdr *th;
	int error = 0;
	int proto;

	NET_ASSERT_LOCKED();

	if (!ISSET(ifp->if_flags, IFF_UP)) {
		m_freem(m);
		error = ENETDOWN;
		goto out;
	}

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, dst->sa_family, m, BPF_DIRECTION_OUT);
#endif
	if (pipex_enable) {
		switch (dst->sa_family) {
		case AF_INET:
			proto = PPP_IP;
			break;
		default:
			m_freem(m);
			error = EPFNOSUPPORT;
			goto out;
		}
	} else
		proto = htonl(dst->sa_family);

	M_PREPEND(m, sizeof(int), M_DONTWAIT);
	if (m == NULL) {
		error = ENOBUFS;
		goto out;
	}
	*mtod(m, int *) = proto;

	if (pipex_enable)
		error = if_enqueue(ifp, m);
	else {
		M_PREPEND(m, sizeof(struct pppx_hdr), M_DONTWAIT);
		if (m == NULL) {
			error = ENOBUFS;
			goto out;
		}
		th = mtod(m, struct pppx_hdr *);
		th->pppx_proto = 0;	/* not used */
		th->pppx_id = pxi->pxi_session.ppp_id;
		rw_enter_read(&pppx_devs_lk);
		error = mq_enqueue(&pxi->pxi_dev->pxd_svcq, m);
		if (error == 0) {
			if (pxi->pxi_dev->pxd_waiting) {
				wakeup((caddr_t)pxi->pxi_dev);
				pxi->pxi_dev->pxd_waiting = 0;
			}
			selwakeup(&pxi->pxi_dev->pxd_rsel);
		}
		rw_exit_read(&pppx_devs_lk);
	}

out:
	if (error)
		ifp->if_oerrors++;
	return (error);
}

int
pppx_if_ioctl(struct ifnet *ifp, u_long cmd, caddr_t addr)
{
	struct pppx_if *pxi = (struct pppx_if *)ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)addr;
	int error = 0;

	switch (cmd) {
	case SIOCSIFADDR:
		break;

	case SIOCSIFFLAGS:
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu < 512 ||
		    ifr->ifr_mtu > pxi->pxi_session.peer_mru)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

	default:
		error = ENOTTY;
		break;
	}

	return (error);
}

RBT_GENERATE(pppx_ifs, pppx_if, pxi_entry, pppx_if_cmp);
@


1.62
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.61 2017/05/30 07:50:37 mpi Exp $ */
d858 1
a858 1
	rw_exit_write(&netlock);
d860 1
a860 1
	rw_enter_write(&netlock);
d973 1
a973 1
	rw_exit_write(&netlock);
d975 1
a975 1
	rw_enter_write(&netlock);
@


1.61
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.60 2017/05/28 18:43:51 yasuoka Exp $ */
a279 1
	int s;
d289 1
a289 1
		NET_LOCK(s);
d293 1
a293 1
		NET_UNLOCK(s);
d416 1
a416 1
	int s, error = 0;
d418 1
a418 1
	NET_LOCK(s);
d468 1
a468 1
	NET_UNLOCK(s);
@


1.60
log
@Use interface index and if_{put,get} instead of ifnet pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.59 2017/05/28 12:51:34 yasuoka Exp $ */
a320 1
	struct niqueue *ifq;
d398 1
a398 1
		ifq = &ipintrq;
d402 1
a402 1
		ifq = &ip6intrq;
a408 3

	if (niq_enqueue(ifq, top) != 0)
		return (ENOBUFS);
@


1.59
log
@Remove all splnet/splx from pipex(4) and pppx(4) and replace some of
them by NET_LOCK/NET_UNLOCK.  Also make the timeout for pipex_timer
run with a thread context and replace pipex softintr by NETISR_PIPEX.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.58 2017/05/04 15:00:24 bluhm Exp $ */
d752 1
a752 1
		session->proto.pppoe.over_ifp = over_ifp;
@


1.58
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.57 2017/01/24 10:08:30 krw Exp $ */
d290 1
a290 1
		s = splnet();
d292 3
a294 2
		error = tsleep(pxd, (PZERO + 1)|PCATCH, "pppxread", 0);
		splx(s);
a324 3
#if NBPFILTER > 0
	int s;
#endif
d390 1
a390 2
	if (pxi->pxi_if.if_bpf) {
		s = splnet();
a391 2
		splx(s);
	}
d421 1
a421 1
	int error = 0;
d423 1
d467 1
a467 1
		return (0);
d473 1
d660 1
a660 1
	int unit, s, error = 0;
a844 2
	s = splnet();

d862 2
d865 2
a914 1
	splx(s);
a957 1
	int s;
d959 1
a962 1
	s = splnet();
a975 1
	splx(s);
d977 2
d980 1
d1025 2
a1026 3
#if NBPFILTER > 0
	int s;
#endif
d1035 1
a1035 2
	if (ifp->if_bpf) {
		s = splnet();
a1036 2
		splx(s);
	}
a1071 1
			s = splnet();
a1075 1
			splx(s);
@


1.57
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.56 2016/09/15 02:00:18 dlg Exp $ */
d858 1
a858 1
		    pipex_sockaddr_hash_key((struct sockaddr *)&session->peer));
@


1.56
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.55 2016/09/15 01:37:34 dlg Exp $ */
d906 1
a906 1
	
@


1.55
log
@bring back r1.53

move pppx red-black trees from tree.h code to subr_tree.c code

this change and the same one for pools should have us breaking even for
the "extra" code in subr_tree. after this we will get more space back
by converting RB_ to RBT_ code, and any new red-black trees using RBT_
are free.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.53 2016/09/05 07:41:22 dlg Exp $ */
d255 2
a256 3
		pool_init(pppx_if_pl, sizeof(struct pppx_if), 0, 0, PR_WAITOK,
		    "pppxif", NULL);
		pool_setipl(pppx_if_pl, IPL_NONE);
@


1.54
log
@back out RBT for now
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.52 2016/08/23 12:37:11 dlg Exp $ */
a141 2
int				pppx_if_cmp(struct pppx_if *, struct pppx_if *);

d145 1
a145 1
	RB_ENTRY(pppx_if)	pxi_entry;
d155 6
d162 2
a163 2
RB_HEAD(pppx_ifs, pppx_if)	pppx_ifs = RB_INITIALIZER(&pppx_ifs);
RB_PROTOTYPE(pppx_ifs, pppx_if, pxi_entry, pppx_if_cmp);
a614 6
pppx_if_cmp(struct pppx_if *a, struct pppx_if *b)
{
	return memcmp(&a->pxi_key, &b->pxi_key, sizeof(a->pxi_key));
}

int
d625 1
a625 1
		RB_FOREACH(pxi, pppx_ifs, &pppx_ifs) {
d650 1
a650 1
	p = RB_FIND(pppx_ifs, &pppx_ifs, s);
d831 1
a831 1
	if (RB_FIND(pppx_ifs, &pppx_ifs, pxi) != NULL) {
d877 1
a877 1
	if (RB_INSERT(pppx_ifs, &pppx_ifs, pxi) != NULL)
d985 1
a985 1
	if (RB_REMOVE(pppx_ifs, &pppx_ifs, pxi) == NULL)
d1129 1
a1129 1
RB_GENERATE(pppx_ifs, pppx_if, pxi_entry, pppx_if_cmp);
@


1.53
log
@move pppx red-black trees from tree.h code to subr_tree.c code

this change and the same one for pools should have us breaking even for
the "extra" code in subr_tree. after this we will get more space back
by converting RB_ to RBT_ code, and any new red-black trees using RBT_
are free.
@
text
@d142 2
d147 1
a147 1
	RBT_ENTRY(pppx_if)	pxi_entry;
a156 6
static inline int
pppx_if_cmp(const struct pppx_if *a, const struct pppx_if *b)
{
	return memcmp(&a->pxi_key, &b->pxi_key, sizeof(a->pxi_key));
}

d158 2
a159 2
RBT_HEAD(pppx_ifs, pppx_if)	pppx_ifs = RBT_INITIALIZER(&pppx_ifs);
RBT_PROTOTYPE(pppx_ifs, pppx_if, pxi_entry, pppx_if_cmp);
d611 6
d627 1
a627 1
		RBT_FOREACH(pxi, pppx_ifs, &pppx_ifs) {
d652 1
a652 1
	p = RBT_FIND(pppx_ifs, &pppx_ifs, s);
d833 1
a833 1
	if (RBT_FIND(pppx_ifs, &pppx_ifs, pxi) != NULL) {
d879 1
a879 1
	if (RBT_INSERT(pppx_ifs, &pppx_ifs, pxi) != NULL)
d987 1
a987 1
	if (RBT_REMOVE(pppx_ifs, &pppx_ifs, pxi) == NULL)
d1131 1
a1131 1
RBT_GENERATE(pppx_ifs, pppx_if, pxi_entry, pppx_if_cmp);
@


1.52
log
@pool_setipl
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.51 2016/04/13 11:41:15 mpi Exp $ */
a141 2
int				pppx_if_cmp(struct pppx_if *, struct pppx_if *);

d145 1
a145 1
	RB_ENTRY(pppx_if)	pxi_entry;
d155 6
d162 2
a163 2
RB_HEAD(pppx_ifs, pppx_if)	pppx_ifs = RB_INITIALIZER(&pppx_ifs);
RB_PROTOTYPE(pppx_ifs, pppx_if, pxi_entry, pppx_if_cmp);
a614 6
pppx_if_cmp(struct pppx_if *a, struct pppx_if *b)
{
	return memcmp(&a->pxi_key, &b->pxi_key, sizeof(a->pxi_key));
}

int
d625 1
a625 1
		RB_FOREACH(pxi, pppx_ifs, &pppx_ifs) {
d650 1
a650 1
	p = RB_FIND(pppx_ifs, &pppx_ifs, s);
d831 1
a831 1
	if (RB_FIND(pppx_ifs, &pppx_ifs, pxi) != NULL) {
d877 1
a877 1
	if (RB_INSERT(pppx_ifs, &pppx_ifs, pxi) != NULL)
d985 1
a985 1
	if (RB_REMOVE(pppx_ifs, &pppx_ifs, pxi) == NULL)
d1129 1
a1129 1
RB_GENERATE(pppx_ifs, pppx_if, pxi_entry, pppx_if_cmp);
@


1.51
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.50 2016/01/31 13:54:13 stefan Exp $ */
d253 1
@


1.50
log
@Convert to ulmin and uiomove to prevent integer truncations.
Reviewed by Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.49 2016/01/14 09:20:31 mpi Exp $ */
a846 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.49
log
@No need for a splnet() dance around IFQ_DEQUEUE() anymore.

From David Hill, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.48 2015/12/05 16:09:09 yasuoka Exp $ */
d276 2
a277 1
	int len, s;
d296 1
a296 1
		len = min(uio->uio_resid, m0->m_len);
d298 1
a298 1
			error = uiomovei(mtod(m0, caddr_t), len, uio);
d317 1
a317 1
	int tlen, mlen;
d319 1
d347 2
a348 2
		m->m_len = min(mlen, uio->uio_resid);
		error = uiomovei(mtod (m, caddr_t), m->m_len, uio);
@


1.48
log
@Make pppx pass packets with npppd through the device.  This makes pppx work
without pipex.enable=1.  Also fix tun(4) not to pass the packets to pipex
when pipex.enable=0.

"go for it" dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.47 2015/12/03 17:03:33 bluhm Exp $ */
d998 1
a998 1
	int proto, s;
a1003 1
		s = splnet();
a1004 1
		splx(s);
@


1.47
log
@When enqueuing a mbuf chain, take the top instead of the last
element.  Otherwise the kernel paniced with "ipintr no HDR" if the
data passed to pppxwrite() had a certain length.
Bug reported and fix tested by Sevan / Venture37.
Debugged with and OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.46 2015/11/20 05:31:24 dlg Exp $ */
d152 1
d310 1
a310 1
/*	struct pppx_dev *pxd = pppx_dev2pxd(dev);	*/
d312 2
d318 3
d322 2
a323 1
	if (uio->uio_resid < sizeof(*th) || uio->uio_resid > MCLBYTES)
d375 1
a375 1
	/* strip the tunnel header */
d378 6
d385 12
a396 1
	switch (ntohl(th->pppx_proto)) {
d827 1
a1013 15
#if NBPFILTER > 0
		if (ifp->if_bpf) {
			switch (proto) {
			case PPP_IP:
				bpf_mtap_af(ifp->if_bpf, AF_INET, m,
					BPF_DIRECTION_OUT);
				break;
			case PPP_IPV6:
				bpf_mtap_af(ifp->if_bpf, AF_INET6, m,
					BPF_DIRECTION_OUT);
				break;
			}
		}
#endif

d1025 2
d1029 3
d1039 5
a1043 8
	switch (dst->sa_family) {
	case AF_INET:
		proto = PPP_IP;
		break;
	default:
		m_freem(m);
		error = EPFNOSUPPORT;
		goto out;
d1045 13
d1066 25
a1090 1
	error = if_enqueue(ifp, m);
@


1.46
log
@dont check for IFF_OACTIVE

only a driver sets or clears this flag. pppx never sets it, so it
will never be set when it checks it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.45 2015/11/03 12:02:59 dlg Exp $ */
d386 1
a386 1
	if (niq_enqueue(ifq, m) != 0)
@


1.45
log
@use an mbuf_queue for the svcq instead of an ifqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.44 2015/10/25 11:58:11 mpi Exp $ */
a974 2
	if (ISSET(ifp->if_flags, IFF_OACTIVE))
		return;
@


1.44
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.43 2015/09/06 12:59:20 kettenis Exp $ */
d125 1
a125 1
	struct ifqueue		pxd_svcq;
d261 1
a261 1
	IFQ_SET_MAXLEN(&pxd->pxd_svcq, 128);
d280 2
a281 8
	s = splnet();
	for (;;) {
		IF_DEQUEUE(&pxd->pxd_svcq, m0);
		if (m0 != NULL)
			break;

		if (ISSET(ioflag, IO_NDELAY)) {
			splx(s);
a282 1
		}
d284 1
d287 1
a288 1
			splx(s);
a291 1
	splx(s);
d455 1
a455 1
	int s, revents = 0;
d458 1
a458 2
		s = splnet();
		if (!IF_IS_EMPTY(&pxd->pxd_svcq))
a459 1
		splx(s);
a520 1
	int s, event = 0;
d527 1
a527 6
	s = splnet();
	if (!IF_IS_EMPTY(&pxd->pxd_svcq)) {
		event = 1;
		kn->kn_data = IF_LEN(&pxd->pxd_svcq);
	}
	splx(s);
d529 1
a529 1
	return (event);
a557 1
	int s;
d569 1
a569 3
	s = splnet();
	IF_PURGE(&pxd->pxd_svcq);
	splx(s);
@


1.43
log
@The pppx_if_pl pool will never be used in interrupt context, so pass the
PR_WAITOK flag to pool_init and pass NULL as the pool allocator.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.42 2015/07/18 15:51:16 mpi Exp $ */
d835 1
a1072 1
	struct ifaddr *ifa = (struct ifaddr *)addr;
a1076 1
		ifa->ifa_rtrequest = p2p_rtrequest;
@


1.42
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.41 2015/07/15 22:16:42 deraadt Exp $ */
d250 2
a251 2
		pool_init(pppx_if_pl, sizeof(struct pppx_if), 0, 0, 0,
		    "pppxif", &pool_allocator_nointr);
@


1.41
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.40 2015/07/08 07:21:50 mpi Exp $ */
a65 1
#include <net/radix.h>
d91 1
@


1.40
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.39 2015/06/30 13:54:42 mpi Exp $ */
d308 1
a308 2
	if (m0 != NULL)
		m_freem(m0);
d369 1
a369 2
		if (top != NULL)
			m_freem(top);
@


1.39
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.38 2015/05/15 10:15:13 mpi Exp $ */
d304 1
a304 1
		MFREE(m0, m);
@


1.38
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.37 2015/04/10 13:58:20 dlg Exp $ */
d1062 1
a1062 1
	error = if_output(ifp, m);
@


1.37
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.36 2015/02/10 21:56:10 miod Exp $ */
d1037 1
a1037 1
	int proto, s;
d1062 1
a1062 9
	s = splnet();
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		splx(s);
		goto out;
	}
	if_start(ifp);
	splx(s);

@


1.36
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.35 2014/12/19 17:14:39 tedu Exp $ */
d320 1
a320 1
	struct ifqueue *ifq;
d322 1
a322 1
	int isr, s, error = 0;
a383 1
		isr = NETISR_IP;
a387 1
		isr = NETISR_IPV6;
d395 1
a395 5
	s = splnet();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		splx(s);
		m_freem(top);
a396 4
	}
	IF_ENQUEUE(ifq, top);
	schednetisr(isr);
	splx(s);
@


1.35
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.34 2014/09/08 06:24:13 jsg Exp $ */
d303 1
a303 1
			error = uiomove(mtod(m0, caddr_t), len, uio);
d347 1
a347 1
		error = uiomove(mtod (m, caddr_t), m->m_len, uio);
@


1.34
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.33 2014/08/19 08:04:51 uebayasi Exp $ */
a71 1
#ifdef INET
a74 1
#endif
a381 1
#ifdef INET
a385 1
#endif
@


1.33
log
@pppx(4): Correct pppx_dev_lookup() and pppx_dev2pxd() local declarations

Those two functions take one dev_t argument, not int.  Match declarations
with reality.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d66 1
a66 1
#include <net/route.h>
@


1.32
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.31 2014/07/12 18:44:22 tedu Exp $ */
d136 2
a137 2
struct pppx_dev			*pppx_dev_lookup(int);
struct pppx_dev			*pppx_dev2pxd(int);
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.30 2014/05/05 11:44:33 mpi Exp $ */
a72 1
#include <netinet/in_systm.h>
@


1.30
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.29 2014/04/08 04:26:53 miod Exp $ */
d606 1
a606 1
	free(pxd, M_DEVBUF);
d610 1
a610 1
		free(pppx_if_pl, M_DEVBUF);
d663 1
a663 1
	free(s, M_DEVBUF);
@


1.29
log
@Revert 1.27 and 1.28, but make sure to initialize the pxd_unit field correctly
in pppxopen(). ok dlg@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.28 2014/04/05 13:30:59 miod Exp $ */
d1097 1
d1102 3
@


1.28
log
@Be sure to release rwlock when returning error in pppxclose().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.27 2014/04/04 03:34:41 jsg Exp $ */
d259 1
d594 1
a594 4
	if ((pxd = pppx_dev_lookup(dev)) == NULL) {
		rw_exit_write(&pppx_devs_lk);
		return (ENXIO);
	}
@


1.27
log
@Paul B. Henson discovered it was possible to hit a kernel
panic with pppx when using npppd with multiple pppx devices.

This is triggered when pppxclose() is called on device that hasn't
been opened causing a NULL dereference and panic.  Avoid
this by returning ENXIO if the device has not been opened.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.26 2013/10/19 14:46:30 mpi Exp $ */
d593 2
a594 1
	if ((pxd = pppx_dev_lookup(dev)) == NULL)
d596 1
@


1.26
log
@Uniformize drivers doing nothing with their multicast filters to make
them ignore the SIOC{ADD,DEL}MULTI ioctls.

ok reyk@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.25 2013/10/17 16:27:41 bluhm Exp $ */
d593 2
a594 1
	pxd = pppx_dev_lookup(dev);
@


1.25
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.24 2013/08/08 07:39:13 mpi Exp $ */
a1104 13
		switch (ifr->ifr_addr.sa_family) {
#ifdef INET
		case AF_INET:
			break;
#endif
#ifdef INET6
		case AF_INET6:
			break;
#endif
		default:
			error = EAFNOSUPPORT;
			break;
		}
@


1.24
log
@Insert new IPv4 addresses in only one place, no functional change.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.23 2013/06/24 09:34:59 mpi Exp $ */
d80 1
@


1.23
log
@Revert r1.20 for now, to make sure the newly created address is added
to the global list, until the issue with carp is addressed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.22 2013/06/20 12:03:40 mpi Exp $ */
a896 1
	TAILQ_INSERT_TAIL(&in_ifaddr, ia, ia_list);
@


1.22
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.21 2013/06/20 09:38:24 mpi Exp $ */
d897 1
a921 1
		ifafree(&ia->ia_ifa);
@


1.21
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.20 2013/06/18 09:15:13 mpi Exp $ */
d923 1
a923 1
		dohooks(&ifp->if_addrhooks, 0);
@


1.20
log
@Oops, forgot this file in previous. Should be part of adding/removing
IPv4 addresses consistently from the global list and tree, in.c r1.78
                                                                                ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.19 2013/05/31 19:16:52 mpi Exp $ */
d923 1
a923 1
		dohooks(ifp->if_addrhooks, 0);
@


1.19
log
@Remove the scrub argument from in_ifinit() and simply call in_ifscrub()
unconditionally for SIOCSIFADDR.

ok bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.18 2013/04/10 01:35:55 guenther Exp $ */
a896 1
	TAILQ_INSERT_TAIL(&in_ifaddr, ia, ia_list);
d921 1
@


1.18
log
@Fix various glitches in queue macro usage.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.17 2013/03/28 16:45:16 tedu Exp $ */
d918 1
a918 1
	error = in_ifinit(ifp, ia, &ifaddr, 0, 1);
@


1.17
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.16 2013/02/06 22:58:18 sthen Exp $ */
d133 1
a133 1
LIST_HEAD(, pppx_dev)		pppx_devs = LIST_HEAD_INITIALIZER(&pppx_devs);
@


1.16
log
@add pppx(4) interfaces to the "pppx" interface group, as done for various
other interface types. suggested/tested Mattieu Baptiste, ok dlg@@ yasuoka@@
giovanni@@, ifconfig(8) reminder jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.15 2012/09/19 17:50:17 yasuoka Exp $ */
a50 1
#include <sys/proc.h>
@


1.15
log
@cleanup around the pipex.  naming style, delete or update comments.
no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.14 2012/04/14 09:39:47 yasuoka Exp $ */
d877 1
@


1.14
log
@Use DLT_LOOP for all tunneling interfaces.
Byte order adjustment for bpf was hidden behind bpf_mtap_af() and
sizeof(u_int32_t) is used for length of the bpf header.

tested by sebastia and mxb at alumni.chalmers.se.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.13 2011/10/25 23:54:58 dlg Exp $ */
d686 1
a686 1
		if (req->peer_address.ss_family != AF_UNSPEC)
d696 1
a696 1
		switch (req->peer_address.ss_family) {
d698 1
a698 1
			if (req->peer_address.ss_len != sizeof(struct sockaddr_in))
d703 1
a703 1
			if (req->peer_address.ss_len != sizeof(struct sockaddr_in6))
d710 4
a713 4
		if (req->peer_address.ss_family !=
		    req->local_address.ss_family ||
		    req->peer_address.ss_len !=
		    req->local_address.ss_len)
d757 6
a762 6
	if (req->peer_address.ss_len > 0)
		memcpy(&session->peer, &req->peer_address,
		    MIN(req->peer_address.ss_len, sizeof(session->peer)));
	if (req->local_address.ss_len > 0)
		memcpy(&session->local, &req->local_address,
		    MIN(req->local_address.ss_len, sizeof(session->local)));
@


1.13
log
@i didnt copy the tun code properly. fix a use of an uninitted value found
by pedro/gcc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.12 2011/10/15 03:24:11 yasuoka Exp $ */
d880 1
a880 1
	bpfattach(&ifp->if_bpf, ifp, DLT_NULL, 0);
@


1.12
log
@Added "provision for rewound PPP frames" that allows receiving
reorder packets to pass to the upper layer without reorder.  It
will improve performance (throughput or loss rate) for PPTP or
L2TP(/IPesc) on networks that latency is unstable such as mobile
network.

As our test environment (bandwidth: 6Mbps, latency: 50ms for 97% of
traffic and 52ms for rest of traffic), throughput has changed from
0.76MB to 2.17MB on file upload by PPTP connected Windows Vista
ftp.exe.

Developed by UMEZAWA Takeshi at IIJ.

ok jmatthew@@
tested jmatthew@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.11 2011/08/21 09:00:15 jmatthew Exp $ */
d284 2
a285 2
		IF_DEQUEUE(&pxd->pxd_svcq, m);
		if (m != NULL)
@


1.11
log
@Use the lowest available unit number for new pppx ifs.  Somewhat
inefficient but doesn't matter with reasonable numbers of interfaces.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.10 2011/08/20 06:21:32 mcbride Exp $ */
d808 3
a810 1
		pipex_mppe_req_init(&req->pr_mppe_recv, &session->mppe_recv);
d812 3
a814 1
		pipex_mppe_req_init(&req->pr_mppe_send, &session->mppe_send);
@


1.10
log
@Fix packet accounting in error cases.

From Christiano F. Haesbaert.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.9 2011/07/07 20:42:56 henning Exp $ */
d632 13
a644 4
	RB_FOREACH(pxi, pppx_ifs, &pppx_ifs) {
		if (pxi->pxi_unit >= unit)
			unit = pxi->pxi_unit + 1;
	}
d824 5
@


1.9
log
@use IF_LEN/IFQ_LEN to access and ifqueue's length field. ryan ok
with this nothing in the tree fiddles if ifqueue internals any more, of
course except if.c and if.h (and some altq)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.8 2011/07/02 22:20:08 nicm Exp $ */
d1060 4
@


1.8
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.7 2011/04/14 05:13:45 dlg Exp $ */
d556 1
a556 1
		kn->kn_data = pxd->pxd_svcq.ifq_len;
@


1.7
log
@knf. remove extra spaces and wrap long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.6 2011/04/02 11:52:44 dlg Exp $ */
d516 1
a516 1
		return (1);
@


1.6
log
@add a pipex ioctl that lets you specify a description on pppx interfaces by
session id.

ok claudio@@ yasuoka@@ as part of a larger diff
code from jonathan matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.5 2011/04/02 11:49:19 dlg Exp $ */
d48 1
a48 1
#include <sys/kernel.h>  
d133 1
a133 1
struct rwlock			pppx_devs_lk = RWLOCK_INITIALIZER("pppxdevs"); 
d287 1
a287 1
 
d437 1
d446 1
a446 1
                return (error);
d448 7
a454 7
        case PIPEXGSTAT:
                error = pipex_get_stat((struct pipex_session_stat_req *)addr);
                return (error);

        case PIPEXGCLOSED:
                error = pipex_get_closed((struct pipex_session_list_req *)addr);
                return (error);
d457 3
a459 2
		error = pppx_set_session_descr(pxd, (struct pipex_session_descr_req *)addr);
		return (error);
d499 1
a499 1
{ 
d536 1
a536 1
 
d571 1
a571 1
 
d931 2
a932 1
pppx_set_session_descr(struct pppx_dev *pxd, struct pipex_session_descr_req *req)
@


1.5
log
@configure the addresses on the pppx interface when its created by npppd so
it is immediately functional.

ok claudio@@ yasuoka@@ as part of a larger diff
code by jonathan matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.4 2011/01/28 06:43:00 dlg Exp $ */
d169 2
d454 5
d925 15
@


1.4
log
@make sure that the size of the addresses userland is trying to configure
make sense, not just the family.

from jonathan matthew
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.3 2010/11/24 00:56:08 sthen Exp $ */
d656 2
d820 1
a820 1
	ifp->if_flags = IFF_POINTOPOINT | IFF_MULTICAST;
d860 38
@


1.3
log
@malloc the temporary struct pppx_if used in pppx_if_find (it's currently
only called from pppx_del_session); lets an amd64 pppx kernel build
(otherwise we hit excessive stack use warnings with -Werror).
if this ends up being called more frequently in future, then dlg
suggests making it static instead.  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.2 2010/09/29 08:22:27 claudio Exp $ */
d678 3
d683 1
a683 3
#endif
			if (req->peer_address.ss_family !=
			    req->local_address.ss_family)
d686 1
d690 5
d737 6
@


1.2
log
@Adjust to the pipex changes introduced during j2k10. Compiles again not
sure if all protocols work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pppx.c,v 1.1 2010/09/22 13:03:48 claudio Exp $ */
d634 2
a635 1
	struct pppx_if s, *p;
d637 2
a638 2
	s.pxi_key.pxik_session_id = session_id;
	s.pxi_key.pxik_protocol = protocol;
d641 1
a641 1
	p = RB_FIND(pppx_ifs, &pppx_ifs, &s);
d644 1
@


1.1
log
@Add a new interface pppx(4) -- the ppp multiplexer to be used with npppd
and pipex. pppx(4) creates an interface whenever a session is created
so that altq and pf can work on these.
Started by dlg@@ debugged and made usable by myself
OK dlg@@ yasuoka@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d71 1
a655 2
	struct ether_header *eh;
	struct sockaddr peer_addr;
a658 4
#ifdef PIPEX_PPTP
	case PIPEX_PROTO_PPTP:
		break;
#endif
d664 2
a665 6
		bzero(&peer_addr, sizeof(peer_addr));
		peer_addr.sa_family = AF_UNSPEC;
		eh = (struct ether_header *)&peer_addr.sa_data;
		eh->ether_type = htons(ETHERTYPE_PPPOE);
		memcpy(&eh->ether_dhost, &req->pr_proto.pppoe.peer_address,
		    sizeof(eh->ether_dhost));
d668 19
a727 1
	switch (req->pr_protocol) {
d729 1
a729 2
	case PIPEX_PROTO_PPPOE:
		session->proto.pppoe.peer_addr = peer_addr;
a730 1
		break;
d733 37
a769 16
	case PIPEX_PROTO_PPTP:
		session->proto.pptp.snd_gap = 0;
		session->proto.pptp.rcv_gap = 0;
		session->proto.pptp.snd_una = req->pr_proto.pptp.snd_una;
		session->proto.pptp.snd_nxt = req->pr_proto.pptp.snd_nxt;
                session->proto.pptp.rcv_nxt = req->pr_proto.pptp.rcv_nxt;
		session->proto.pptp.rcv_acked = req->pr_proto.pptp.rcv_acked;
		session->proto.pptp.winsz = req->pr_proto.pptp.winsz;
		session->proto.pptp.maxwinsz = req->pr_proto.pptp.maxwinsz;
		session->proto.pptp.peer_maxwinsz =
		    req->pr_proto.pptp.peer_maxwinsz;
		session->proto.pptp.peer_address =
		    req->pr_proto.pptp.peer_address;
		session->proto.pptp.our_address =
		    req->pr_proto.pptp.our_address;
		break;
a770 2
	}

d819 3
a821 2
#ifdef PIPEX_PPTP
	if (req->pr_protocol == PIPEX_PROTO_PPTP) {
d823 1
a823 1
		    session->proto.pptp.peer_address.s_addr);
d825 1
a826 1
#endif
d879 3
a881 2
#ifdef PIPEX_PPTP
	if (session->protocol == PIPEX_PROTO_PPTP)
d884 2
a885 1
#endif
@

