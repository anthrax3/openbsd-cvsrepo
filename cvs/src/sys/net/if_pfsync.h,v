head	1.52;
access;
symbols
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.48.0.10
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.4
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.6
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.6
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.4
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.2
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.6
	OPENBSD_5_0:1.44.0.4
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.2
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	UBC:1.2.0.6
	UBC_SYNC_A:1.2
	SMP:1.2.0.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.52
date	2017.02.20.06.30.39;	author jca;	state Exp;
branches;
next	1.51;
commitid	kEYANVo5IvTssoQm;

1.51
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	3e3CkrbYekyVOcxy;

1.50
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.49;
commitid	pVtptbHA3yk4jSpN;

1.49
date	2017.01.20.05.03.48;	author claudio;	state Exp;
branches;
next	1.48;
commitid	Q27bfMOYZAZ4a7pL;

1.48
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	VK3ncyiP3NS1N4Sy;

1.47
date	2013.10.24.11.14.33;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2012.06.29.15.12.21;	author mikeb;	state Exp;
branches;
next	1.45;

1.45
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.44;

1.44
date	2010.11.29.05.31.38;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.12.23.38.02;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.10.23.54.21;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.09.23.46.38;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.14.00.16.50;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.31.01.21.29;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2009.02.16.00.31.25;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.29.08.42.15;	author mcbride;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.17.05.03.29;	author mcbride;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.29.01.00.53;	author mcbride;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.14.18.33.37;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.31.04.11.42;	author mcbride;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.31.14.49.01;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.28.02.04.15;	author mcbride;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.04.08.24.14;	author mcbride;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.27.12.34.40;	author mcbride;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.28.01.46.32;	author pascoe;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.16.11.26.48;	author pascoe;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.16.11.22.43;	author pascoe;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.13.08.56.14;	author pascoe;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.03.01.12.19;	author pascoe;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.03.00.51.43;	author pascoe;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.28.15.10.07;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.20.17.47.38;	author mcbride;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.14.13.41.01;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.16.20.07.56;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.03.05.32.28;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.13.22.51.48;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.28.00.47.06;	author mcbride;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.22.04.54.17;	author mcbride;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.20.19.22.03;	author mcbride;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.10.09.21.54;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.22.09.25.25;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.18.19.55.52;	author mcbride;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.31.11.18.25;	author cedric;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.28.17.18.58;	author mcbride;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.15.21.49.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.15.07.28.25;	author mcbride;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.08.00.45.34;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.11.18.31.26;	author mickey;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.11.29.18.25.22;	author mickey;	state Exp;
branches;
next	;

1.2.4.1
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.52
log
@pfsync(4) percpu counters

ok florian@@
@
text
@/*	$OpenBSD: if_pfsync.h,v 1.51 2017/01/29 19:58:47 bluhm Exp $	*/

/*
 * Copyright (c) 2001 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 2008 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _NET_IF_PFSYNC_H_
#define _NET_IF_PFSYNC_H_

#define PFSYNC_VERSION		6
#define PFSYNC_DFLTTL		255

#define PFSYNC_ACT_CLR		0	/* clear all states */
#define PFSYNC_ACT_OINS		1	/* old insert state */
#define PFSYNC_ACT_INS_ACK	2	/* ack of insterted state */
#define PFSYNC_ACT_OUPD		3	/* old update state */
#define PFSYNC_ACT_UPD_C	4	/* "compressed" update state */
#define PFSYNC_ACT_UPD_REQ	5	/* request "uncompressed" state */
#define PFSYNC_ACT_DEL		6	/* delete state */
#define PFSYNC_ACT_DEL_C	7	/* "compressed" delete state */
#define PFSYNC_ACT_INS_F	8	/* insert fragment */
#define PFSYNC_ACT_DEL_F	9	/* delete fragments */
#define PFSYNC_ACT_BUS		10	/* bulk update status */
#define PFSYNC_ACT_OTDB		11	/* old TDB replay counter update */
#define PFSYNC_ACT_EOF		12	/* end of frame - DEPRECATED */
#define PFSYNC_ACT_INS		13	/* insert state */
#define PFSYNC_ACT_UPD		14	/* update state */
#define PFSYNC_ACT_TDB		15	/* TDB replay counter update */
#define PFSYNC_ACT_MAX		16

#define PFSYNC_ACTIONS		"CLR ST",		\
				"INS ST OLD",		\
				"INS ST ACK",		\
				"UPD ST OLD",		\
				"UPD ST COMP",		\
				"UPD ST REQ",		\
				"DEL ST",		\
				"DEL ST COMP",		\
				"INS FR",		\
				"DEL FR",		\
				"BULK UPD STAT",	\
				"UPD TDB OLD",		\
				"EOF",			\
				"INS ST",		\
				"UPD ST",		\
				"UPD TDB"

/*
 * A pfsync frame is built from a header followed by several sections which
 * are all prefixed with their own subheaders.
 *
 * | ...			|
 * | IP header			|
 * +============================+
 * | pfsync_header		|
 * +----------------------------+
 * | pfsync_subheader		|
 * +----------------------------+
 * | first action fields	|
 * | ...			|
 * +----------------------------+
 * | pfsync_subheader		|
 * +----------------------------+
 * | second action fields	|
 * | ...			|
 * +============================+
 */

/*
 * Frame header
 */

struct pfsync_header {
	u_int8_t			version;
	u_int8_t			_pad;
	u_int16_t			len; /* in bytes */
	u_int8_t			pfcksum[PF_MD5_DIGEST_LENGTH];
} __packed;

/*
 * Frame region subheader
 */

struct pfsync_subheader {
	u_int8_t			action;
	u_int8_t			len; /* in dwords */
	u_int16_t			count;
} __packed;

/*
 * CLR
 */

struct pfsync_clr {
	char				ifname[IFNAMSIZ];
	u_int32_t			creatorid;
} __packed;

/*
 * OINS, OUPD
 */

/* these messages are deprecated */

/*
 * INS, UPD, DEL
 */

/* these use struct pfsync_state in pfvar.h */

/*
 * INS_ACK
 */

struct pfsync_ins_ack {
	u_int64_t			id;
	u_int32_t			creatorid;
} __packed;

/*
 * UPD_C
 */

struct pfsync_upd_c {
	u_int64_t			id;
	struct pfsync_state_peer	src;
	struct pfsync_state_peer	dst;
	u_int32_t			creatorid;
	u_int32_t			expire;
	u_int8_t			timeout;
	u_int8_t			state_flags;
	u_int8_t			_pad[2];
} __packed;

/*
 * UPD_REQ
 */

struct pfsync_upd_req {
	u_int64_t			id;
	u_int32_t			creatorid;
} __packed;

/*
 * DEL_C
 */

struct pfsync_del_c {
	u_int64_t			id;
	u_int32_t			creatorid;
} __packed;

/* 
 * INS_F, DEL_F
 */

/* not implemented (yet) */

/*
 * BUS
 */

struct pfsync_bus {
	u_int32_t			creatorid;
	u_int32_t			endtime;
	u_int8_t			status;
#define PFSYNC_BUS_START			1
#define PFSYNC_BUS_END				2
	u_int8_t			_pad[3];
} __packed;

/*
 * TDB
 */
struct pfsync_tdb {
	u_int32_t			spi;
	union sockaddr_union		dst;
	u_int64_t			rpl;
	u_int64_t			cur_bytes;
	u_int8_t			sproto;
	u_int8_t			updates;
	u_int16_t			rdomain;
} __packed;

/*
 * EOF
 */

/* this message is deprecated */


#define PFSYNC_HDRLEN		sizeof(struct pfsync_header)


/*
 * Names for PFSYNC sysctl objects
 */
#define	PFSYNCCTL_STATS		1	/* PFSYNC stats */
#define	PFSYNCCTL_MAXID		2

#define	PFSYNCCTL_NAMES { \
	{ 0, 0 }, \
	{ "stats", CTLTYPE_STRUCT }, \
}

struct pfsyncstats {
	u_int64_t	pfsyncs_ipackets;	/* total input packets, IPv4 */
	u_int64_t	pfsyncs_ipackets6;	/* total input packets, IPv6 */
	u_int64_t	pfsyncs_badif;		/* not the right interface */
	u_int64_t	pfsyncs_badttl;		/* TTL is not PFSYNC_DFLTTL */
	u_int64_t	pfsyncs_hdrops;		/* packets shorter than hdr */
	u_int64_t	pfsyncs_badver;		/* bad (incl unsupp) version */
	u_int64_t	pfsyncs_badact;		/* bad action */
	u_int64_t	pfsyncs_badlen;		/* data length does not match */
	u_int64_t	pfsyncs_badauth;	/* bad authentication */
	u_int64_t	pfsyncs_stale;		/* stale state */
	u_int64_t	pfsyncs_badval;		/* bad values */
	u_int64_t	pfsyncs_badstate;	/* insert/lookup failed */

	u_int64_t	pfsyncs_opackets;	/* total output packets, IPv4 */
	u_int64_t	pfsyncs_opackets6;	/* total output packets, IPv6 */
	u_int64_t	pfsyncs_onomem;		/* no memory for an mbuf */
	u_int64_t	pfsyncs_oerrors;	/* ip output error */
};

/*
 * Configuration structure for SIOCSETPFSYNC SIOCGETPFSYNC
 */
struct pfsyncreq {
	char		 pfsyncr_syncdev[IFNAMSIZ];
	struct in_addr	 pfsyncr_syncpeer;
	int		 pfsyncr_maxupdates;
	int		 pfsyncr_defer;
};

#ifdef _KERNEL

#include <sys/percpu.h>

enum pfsync_counters {
	pfsyncs_ipackets,
	pfsyncs_ipackets6,
	pfsyncs_badif,
	pfsyncs_badttl,
	pfsyncs_hdrops,
	pfsyncs_badver,
	pfsyncs_badact,
	pfsyncs_badlen,
	pfsyncs_badauth,
	pfsyncs_stale,
	pfsyncs_badval,
	pfsyncs_badstate,
	pfsyncs_opackets,
	pfsyncs_opackets6,
	pfsyncs_onomem,
	pfsyncs_oerrors,
	pfsyncs_ncounters,
};

extern struct cpumem *pfsynccounters;

static inline void
pfsyncstat_inc(enum pfsync_counters c)
{
	counters_inc(pfsynccounters, c);
}

/*
 * this shows where a pf state is with respect to the syncing.
 */
#define PFSYNC_S_IACK	0x00
#define PFSYNC_S_UPD_C	0x01
#define PFSYNC_S_DEL	0x02
#define PFSYNC_S_INS	0x03
#define PFSYNC_S_UPD	0x04
#define PFSYNC_S_COUNT	0x05

#define PFSYNC_S_DEFER	0xfe
#define PFSYNC_S_NONE	0xff

int			pfsync_input(struct mbuf **, int *, int);
int			pfsync_sysctl(int *, u_int,  void *, size_t *,
			    void *, size_t);

#define	PFSYNC_SI_IOCTL		0x01
#define	PFSYNC_SI_CKSUM		0x02
#define	PFSYNC_SI_ACK		0x04
int			pfsync_state_import(struct pfsync_state *, int);
void			pfsync_state_export(struct pfsync_state *,
			    struct pf_state *);

void			pfsync_insert_state(struct pf_state *);
void			pfsync_update_state(struct pf_state *);
void			pfsync_delete_state(struct pf_state *);
void			pfsync_clear_states(u_int32_t, const char *);

void			pfsync_update_tdb(struct tdb *, int);
void			pfsync_delete_tdb(struct tdb *);

int			pfsync_defer(struct pf_state *, struct mbuf *);

int			pfsync_up(void);
int			pfsync_state_in_use(struct pf_state *);
#endif /* _KERNEL */

#endif /* _NET_IF_PFSYNC_H_ */
@


1.51
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.50 2017/01/25 17:34:31 bluhm Exp $	*/
d275 30
@


1.50
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.49 2017/01/20 05:03:48 claudio Exp $	*/
d289 1
a289 1
void			pfsync_input(struct mbuf *, int, int);
@


1.49
log
@Stop using pfsockaddr_union outside of pf so that we can remove its usage
inside pf later on. pfsync can use the one from ip_ipsp.h and bridge can
have its own version for now.
OK mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.48 2015/01/24 00:29:06 deraadt Exp $	*/
d289 1
a289 1
void			pfsync_input(struct mbuf *, ...);
@


1.48
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.47 2013/10/24 11:14:33 deraadt Exp $	*/
a212 1

d215 1
a215 1
	union pfsockaddr_union		dst;
@


1.47
log
@Move obvious kernel prototypes (and structure's with kernel pointers,
obviously only used in the kernel) behind #ifdef _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.46 2012/06/29 15:12:21 mikeb Exp $	*/
d216 1
a216 1
	union sockaddr_union		dst;
@


1.46
log
@add ESN-related bits missed in the previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.45 2012/06/29 14:48:04 mikeb Exp $	*/
d313 1
a313 1
#endif
@


1.45
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.44 2010/11/29 05:31:38 dlg Exp $	*/
d62 1
a62 1
#define PFSYNC_ACT_TDB		11	/* TDB replay counter update */
d66 2
a67 1
#define PFSYNC_ACT_MAX		15
d80 1
a80 1
				"TDB UPD",		\
d83 2
a84 1
				"UPD ST"
@


1.44
log
@get rid of struct pfsync_pkt. it was used to store data on the stack to
pass to all the submessage handlers, but only the flags part of it was
ever used. just pass the flags directly instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.43 2010/07/09 16:58:06 reyk Exp $	*/
d215 1
a215 1
	u_int32_t			rpl;
@


1.43
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.42 2010/01/12 23:38:02 dlg Exp $	*/
d295 1
a295 1
int			pfsync_state_import(struct pfsync_state *, u_int8_t);
@


1.42
log
@factor m_pulldown out of the message handlers up into pfsync_input now
that it knows how big the messages are.

rework the message handlers to use the pfsync_subheader.len value to
iterate over the message regions.

deprecate the EOF subheader since trying to pulldown a 0 byte buffer is
fail.

ok mcbride@@ sperreault@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.41 2010/01/10 23:54:21 dlg Exp $	*/
d219 1
a219 1
	u_int8_t			_pad[2];
@


1.41
log
@replace a pad in the pfsync subheader with a length field. it stores the
length of its message in dwords. multiply that by the count of the messages
to figure out how to skip to the next subheader.

"old" code still thinks the len field is a pad, which it doesnt look at, so
new messages with a filled in len are still parsed correctly by "old" code.

input and ok mcbride@@
sounds good! Simon Perreault
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.40 2009/11/09 23:46:38 dlg Exp $	*/
d63 1
a63 1
#define PFSYNC_ACT_EOF		12	/* end of frame */
a83 2
#define PFSYNC_HMAC_LEN	20

d86 1
a86 2
 * are all prefixed with their own subheaders. Frames must be terminated with
 * an EOF subheader.
a101 2
 * +----------------------------+
 * | EOF pfsync_subheader	|
d226 2
a227 3
struct pfsync_eof {
	u_int8_t			hmac[PFSYNC_HMAC_LEN];
} __packed;
a229 1

@


1.40
log
@bump pfsync protocol version

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.39 2009/11/03 10:59:04 claudio Exp $	*/
d117 1
a117 1
	u_int16_t			len;
d127 1
a127 1
	u_int8_t			_pad;
@


1.39
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.38 2009/06/14 00:16:50 dlg Exp $	*/
d48 1
a48 1
#define PFSYNC_VERSION		5
@


1.38
log
@enable support for deferring the packet that creates a state so that your
sync peers are able to get the states before the replies. previously there
was a race where the reply could hit a partner firewall before it had the
state for it, which caused the reply to get processed by the ruleset which
probably would drop it.

this behaviour is off by default because it does delay packets, which is
only wanted in active-active firewalls or when an upstream router is slow
to learn that you're moved the active member of the pfsync cluster. it also
uses memory keeping the packets in the kernel.

use "ifconfig pfsync0 defer" to enable it, "ifconfig pfsync0 -defer" to
disable.

tested by sthen@@ who loves it. he's got manpage changes coming up for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.35 2008/06/29 08:42:15 mcbride Exp $	*/
d52 1
a52 1
#define PFSYNC_ACT_INS		1	/* insert state */
d54 1
a54 1
#define PFSYNC_ACT_UPD		3	/* update state */
d64 3
a66 1
#define PFSYNC_ACT_MAX		13
d69 1
a69 1
				"INS ST",		\
d71 1
a71 1
				"UPD ST",		\
d80 3
a82 1
				"EOF"
d141 6
d285 5
a289 5
#define PFSYNC_S_INS	0x00
#define PFSYNC_S_IACK	0x01
#define PFSYNC_S_UPD	0x02
#define PFSYNC_S_UPD_C	0x03
#define PFSYNC_S_DEL	0x04
@


1.37
log
@do not include space in the end of the from for a hmac. after discussion
with deraadt@@, mcbride@@, and mpf@@ it is obvious that a hmac doesnt make
sense for pfsync.

this also firms up some of the input parsing so it handles short frames a
bit better.
@
text
@d162 2
a163 1
	u_int8_t			_pad[3];
d267 1
a267 1
	int		 pfsyncr_authlevel;
@


1.36
log
@pfsync v5, mostly written at n2k9, but based on work done at n2k8.

WARNING: THIS BREAKS COMPATIBILITY WITH THE PREVIOUS VERSION OF PFSYNC

this is a new variant of the protocol and a large reworking of the
pfsync code to address some performance issues. the single largest
benefit comes from having multiple pfsync messages of different
types handled in a single packet. pfsyncs handling of pf states is
highly optimised now, along with packet parsing and construction.

huggz for beck@@ for testing.
huge thanks to mcbride@@ for his help during development and for
finding all the bugs during the initial tests.
thanks to peter sutton for letting me get credit for this work.

ok beck@@ mcbride@@ "good." deraadt@@
@
text
@a102 2
 * +----------------------------+
 * | HMAC			|
@


1.35
log
@Simplify state creation code; merge state import/export code between pfsync
and the state-related pf(4) ioctls, and make functions in state creation and
destruction paths more robust in error conditions.

All values in struct pfsync_state now in network byte order, as with pfsync.

testing by david
ok henning, systat parts ok canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.34 2008/06/17 05:03:29 mcbride Exp $	*/
d29 16
d48 74
d123 5
a127 1
#define PFSYNC_ID_LEN	sizeof(u_int64_t)
d129 22
a150 8
struct pfsync_tdb {
	u_int32_t	spi;
	union sockaddr_union dst;
	u_int32_t	rpl;
	u_int64_t	cur_bytes;
	u_int8_t	sproto;
	u_int8_t	updates;
	u_int8_t	pad[2];
d153 6
a158 2
struct pfsync_state_upd {
	u_int32_t		id[2];
d161 4
a164 38
	u_int32_t		creatorid;
	u_int32_t		expire;
	u_int8_t		timeout;
	u_int8_t		updates;
	u_int8_t		pad[6];
} __packed;

struct pfsync_state_del {
	u_int32_t		id[2];
	u_int32_t		creatorid;
	struct {
		u_int8_t	state;
	} src;
	struct {
		u_int8_t	state;
	} dst;
	u_int8_t		pad[2];
} __packed;

struct pfsync_state_upd_req {
	u_int32_t		id[2];
	u_int32_t		creatorid;
	u_int32_t		pad;
} __packed;

struct pfsync_state_clr {
	char			ifname[IFNAMSIZ];
	u_int32_t		creatorid;
	u_int32_t		pad;
} __packed;

struct pfsync_state_bus {
	u_int32_t		creatorid;
	u_int32_t		endtime;
	u_int8_t		status;
#define PFSYNC_BUS_START	1
#define PFSYNC_BUS_END		2
	u_int8_t		pad[7];
d168 25
a192 1
 * Names for PFSYNC sysctl objects
a193 2
#define	PFSYNCCTL_STATS		1	/* PFSYNC stats */
#define	PFSYNCCTL_MAXID		2
d195 8
a202 4
#define	PFSYNCCTL_NAMES { \
	{ 0, 0 }, \
	{ "stats", CTLTYPE_STRUCT }, \
}
d204 3
a206 1
#ifdef _KERNEL
d208 9
a216 8
union sc_statep {
	struct pfsync_state	*s;
	struct pfsync_state_upd	*u;
	struct pfsync_state_del	*d;
	struct pfsync_state_clr	*c;
	struct pfsync_state_bus	*b;
	struct pfsync_state_upd_req	*r;
};
d218 3
a220 3
union sc_tdb_statep {
	struct pfsync_tdb	*t;
};
d222 3
a224 1
extern int	pfsync_sync_ok;
d226 1
a226 25
struct pfsync_softc {
	struct ifnet		 sc_if;
	struct ifnet		*sc_sync_ifp;

	struct ip_moptions	 sc_imo;
	struct timeout		 sc_tmo;
	struct timeout		 sc_tdb_tmo;
	struct timeout		 sc_bulk_tmo;
	struct timeout		 sc_bulkfail_tmo;
	struct in_addr		 sc_sync_peer;
	struct in_addr		 sc_sendaddr;
	struct mbuf		*sc_mbuf;	/* current cumulative mbuf */
	struct mbuf		*sc_mbuf_net;	/* current cumulative mbuf */
    	struct mbuf		*sc_mbuf_tdb;	/* dito for TDB updates */
	union sc_statep		 sc_statep;
	union sc_statep		 sc_statep_net;
	union sc_tdb_statep	 sc_statep_tdb;
	u_int32_t		 sc_ureq_received;
	u_int32_t		 sc_ureq_sent;
	struct pf_state		*sc_bulk_send_next;
	struct pf_state		*sc_bulk_terminator;
	int			 sc_bulk_tries;
	int			 sc_maxcount;	/* number of states in mtu */
	int			 sc_maxupdates;	/* number of updates/state */
};
a227 2
extern struct pfsync_softc	*pfsyncif;
#endif
d230 5
a234 28
struct pfsync_header {
	u_int8_t version;
#define	PFSYNC_VERSION	4
	u_int8_t af;
	u_int8_t action;
#define	PFSYNC_ACT_CLR		0	/* clear all states */
#define	PFSYNC_ACT_INS		1	/* insert state */
#define	PFSYNC_ACT_UPD		2	/* update state */
#define	PFSYNC_ACT_DEL		3	/* delete state */
#define	PFSYNC_ACT_UPD_C	4	/* "compressed" state update */
#define	PFSYNC_ACT_DEL_C	5	/* "compressed" state delete */
#define	PFSYNC_ACT_INS_F	6	/* insert fragment */
#define	PFSYNC_ACT_DEL_F	7	/* delete fragments */
#define	PFSYNC_ACT_UREQ		8	/* request "uncompressed" state */
#define PFSYNC_ACT_BUS		9	/* Bulk Update Status */
#define PFSYNC_ACT_TDB_UPD	10	/* TDB replay counter update */
#define	PFSYNC_ACT_MAX		11
	u_int8_t count;
	u_int8_t pf_chksum[PF_MD5_DIGEST_LENGTH];
} __packed;

#define PFSYNC_BULKPACKETS	1	/* # of packets per timeout */
#define PFSYNC_MAX_BULKTRIES	12
#define PFSYNC_HDRLEN	sizeof(struct pfsync_header)
#define	PFSYNC_ACTIONS \
	"CLR ST", "INS ST", "UPD ST", "DEL ST", \
	"UPD ST COMP", "DEL ST COMP", "INS FR", "DEL FR", \
	"UPD REQ", "BLK UPD STAT", "TDB UPD"
d236 4
a239 1
#define PFSYNC_DFLTTL		255
d272 14
a286 2
int			pfsync_clear_states(u_int32_t, char *);
int			pfsync_pack_state(u_int8_t, struct pf_state *, int);
a288 2
void			pfsync_state_export(struct pfsync_state *,
			    struct pf_state *);
d292 1
d294 12
d307 2
a308 21
#define pfsync_insert_state(st)	do {				\
	if ((st->rule.ptr->rule_flag & PFRULE_NOSYNC) ||	\
	    (st->key[PF_SK_WIRE]->proto == IPPROTO_PFSYNC))	\
		st->sync_flags |= PFSTATE_NOSYNC;		\
	else if (!st->sync_flags)				\
		pfsync_pack_state(PFSYNC_ACT_INS, (st), 	\
		    PFSYNC_FLAG_COMPRESS);			\
	st->sync_flags &= ~PFSTATE_FROMSYNC;			\
} while (0)
#define pfsync_update_state(st) do {				\
	if (!st->sync_flags)					\
		pfsync_pack_state(PFSYNC_ACT_UPD, (st), 	\
		    PFSYNC_FLAG_COMPRESS);			\
	st->sync_flags &= ~PFSTATE_FROMSYNC;			\
} while (0)
#define pfsync_delete_state(st) do {				\
	if (!st->sync_flags)					\
		pfsync_pack_state(PFSYNC_ACT_DEL, (st),		\
		    PFSYNC_FLAG_COMPRESS);			\
} while (0)
int pfsync_update_tdb(struct tdb *, int);
@


1.34
log
@Crank PFSYNC_VERSION, lots has changed in struct pfsync_state due to the
state table reorg.

discussed with deraadt and henning, reminded by david
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.33 2008/05/29 01:00:53 mcbride Exp $	*/
a207 47

/* for copies to/from network */
#define pf_state_peer_hton(s,d) do {		\
	(d)->seqlo = htonl((s)->seqlo);		\
	(d)->seqhi = htonl((s)->seqhi);		\
	(d)->seqdiff = htonl((s)->seqdiff);	\
	(d)->max_win = htons((s)->max_win);	\
	(d)->mss = htons((s)->mss);		\
	(d)->state = (s)->state;		\
	(d)->wscale = (s)->wscale;		\
	if ((s)->scrub) {						\
		(d)->scrub.pfss_flags = 				\
		    htons((s)->scrub->pfss_flags & PFSS_TIMESTAMP);	\
		(d)->scrub.pfss_ttl = (s)->scrub->pfss_ttl;		\
		(d)->scrub.pfss_ts_mod = htonl((s)->scrub->pfss_ts_mod);\
		(d)->scrub.scrub_flag = PFSYNC_SCRUB_FLAG_VALID;	\
	}								\
} while (0)

#define pf_state_peer_ntoh(s,d) do {		\
	(d)->seqlo = ntohl((s)->seqlo);		\
	(d)->seqhi = ntohl((s)->seqhi);		\
	(d)->seqdiff = ntohl((s)->seqdiff);	\
	(d)->max_win = ntohs((s)->max_win);	\
	(d)->mss = ntohs((s)->mss);		\
	(d)->state = (s)->state;		\
	(d)->wscale = (s)->wscale;		\
	if ((s)->scrub.scrub_flag == PFSYNC_SCRUB_FLAG_VALID && 	\
	    (d)->scrub != NULL) {					\
		(d)->scrub->pfss_flags =				\
		    ntohs((s)->scrub.pfss_flags) & PFSS_TIMESTAMP;	\
		(d)->scrub->pfss_ttl = (s)->scrub.pfss_ttl;		\
		(d)->scrub->pfss_ts_mod = ntohl((s)->scrub.pfss_ts_mod);\
	}								\
} while (0)

#define pf_state_counter_hton(s,d) do {				\
	d[0] = htonl((s>>32)&0xffffffff);			\
	d[1] = htonl(s&0xffffffff);				\
} while (0)

#define pf_state_counter_ntoh(s,d) do {				\
	d = ntohl(s[0]);					\
	d = d<<32;						\
	d += ntohl(s[1]);					\
} while (0)

d209 11
a219 4
void pfsync_input(struct mbuf *, ...);
int pfsync_clear_states(u_int32_t, char *);
int pfsync_pack_state(u_int8_t, struct pf_state *, int);
int pfsync_sysctl(int *, u_int,  void *, size_t *, void *, size_t);
@


1.33
log
@Second half of PF state table rearrangement.
- Mechanical change: Use arrays for state key pointers in pf_state, and
  addr/port in pf_state_key, to allow the use of indexes.
- Fix NAT, pfsync, pfctl, and tcpdump to handle the new state structures.
  In struct pfsync_state, both state keys are included even when identical.
- Also fix some bugs discovered in the existing code during testing.
  (in particular, "block return" for TCP packets was not returning an RST)

ok henning beck deraadt
tested by otto dlg beck laurent

Special thanks to users Manuel Pata and Emilio Perea who did enough testing
to actually find some bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.32 2007/12/14 18:33:37 deraadt Exp $	*/
d149 1
a149 1
#define	PFSYNC_VERSION	3
@


1.32
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.31 2007/05/31 04:11:42 mcbride Exp $	*/
a243 10
#define pf_state_host_hton(s,d) do {				\
	bcopy(&(s)->addr, &(d)->addr, sizeof((d)->addr));	\
	(d)->port = (s)->port;					\
} while (0)

#define pf_state_host_ntoh(s,d) do {				\
	bcopy(&(s)->addr, &(d)->addr, sizeof((d)->addr));	\
	(d)->port = (s)->port;					\
} while (0)

d263 1
a263 1
	    (st->state_key->proto == IPPROTO_PFSYNC))			\
@


1.31
log
@First step of rearranging pf's state table internals...

- Split pf_state into pf_state (used for tracking connection information),
  and pf_state_key (used for searching the state table)

- Use pfsync_state in the ioctl for userland access to the state
  table. This will sheild userland somewhat from future changes.

ok henning@@ toby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.30 2006/10/31 14:49:01 henning Exp $	*/
d89 11
d269 2
@


1.30
log
@make pfsync a clonable too, but prevent more than one instance from
beeing created for now - much more work would be required to change that
input & ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.29 2006/05/28 02:04:15 mcbride Exp $	*/
a34 56
struct pfsync_state_scrub {
	u_int16_t	pfss_flags;
	u_int8_t	pfss_ttl;	/* stashed TTL		*/
#define PFSYNC_SCRUB_FLAG_VALID 	0x01
	u_int8_t	scrub_flag;
	u_int32_t	pfss_ts_mod;	/* timestamp modulation	*/
} __packed;

struct pfsync_state_host {
	struct pf_addr	addr;
	u_int16_t	port;
	u_int16_t	pad[3];
} __packed;

struct pfsync_state_peer {
	struct pfsync_state_scrub scrub;	/* state is scrubbed	*/
	u_int32_t	seqlo;		/* Max sequence number sent	*/
	u_int32_t	seqhi;		/* Max the other end ACKd + win	*/
	u_int32_t	seqdiff;	/* Sequence number modulator	*/
	u_int16_t	max_win;	/* largest window (pre scaling)	*/
	u_int16_t	mss;		/* Maximum segment size option	*/
	u_int8_t	state;		/* active state level		*/
	u_int8_t	wscale;		/* window scaling factor	*/
	u_int8_t	pad[6];
} __packed;

struct pfsync_state {
	u_int32_t	 id[2];
	char		 ifname[IFNAMSIZ];
	struct pfsync_state_host lan;
	struct pfsync_state_host gwy;
	struct pfsync_state_host ext;
	struct pfsync_state_peer src;
	struct pfsync_state_peer dst;
	struct pf_addr	 rt_addr;
	u_int32_t	 rule;
	u_int32_t	 anchor;
	u_int32_t	 nat_rule;
	u_int32_t	 creation;
	u_int32_t	 expire;
	u_int32_t	 packets[2][2];
	u_int32_t	 bytes[2][2];
	u_int32_t	 creatorid;
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
	u_int8_t	 log;
	u_int8_t	 allow_opts;
	u_int8_t	 timeout;
	u_int8_t	 sync_flags;
	u_int8_t	 updates;
} __packed;

#define PFSYNC_FLAG_COMPRESS 	0x01
#define PFSYNC_FLAG_STALE	0x02

d198 1
d260 1
a260 1
	    (st->proto == IPPROTO_PFSYNC))			\
@


1.29
log
@Only preemptively increase the replay counter for outbound TDBs.

Another ipsec failover fix from nathanael at polymorpheus dot com.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.28 2005/11/04 08:24:14 mcbride Exp $	*/
d188 1
a188 1
extern struct pfsync_softc pfsyncif;
@


1.28
log
@crank pf_state and pf_src_node byte and packet counters to u_in64_t, since
we're breaking pfsync compatibility this cycle anyways.

Requested by djm@@, ok henning@@, 'wheee!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.27 2005/10/27 12:34:40 mcbride Exp $	*/
d333 1
a333 1
int pfsync_update_tdb(struct tdb *);
@


1.27
log
@Basic support for attaching states from pfsync to the correct rules.
Applies only to rules in the main ruleset (not anchors) if the ruleset
checksum matches. Necessary to fix the following for pfsync'd states:
	- per-rule limits on number of states
	- altq
	- rule-based settings such as timeouts

More work to do re: nat rules, src-nodes, etc.

NOTE: This is modifies the pfsync header and version number.
Tools which process pfsync packets must be recompiled, and firewalls with
different versions will not sync.

ok mpf@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.26 2005/09/28 01:46:32 pascoe Exp $	*/
d75 2
a76 2
	u_int32_t	 packets[2];
	u_int32_t	 bytes[2];
d296 11
@


1.26
log
@Improve the safety of pf IOCTLs, taking into account that some paths can sleep.

- Introduces a rw_lock in pfioctl so that we can have concurrent readers
  but only one process performing updates at a time;

- Separates state expiry into "unlink" and "free" parts; anyone can unlink
  a state/src node from the RB trees at any time, but a state can only be
  freed whilst the write lock is held;

- Converts state_updates into list state_list containing all states,
  regardless of whether they are "linked" or "unlinked";

- Introduces a new PFTM_UNLINKED state that is used on the "unlinked" states
  to signal that they can be freed;

- Converts pf_purge_expired_state to an "unlink" state routine, which only
  unlinks the state from the RB trees.  Freeing the state/src nodes is left
  to the purge thread, which runs whilst holding a write lock, such that all
  "next" references remain valid;

- Converts pfsync_bulk_update and DIOCGETSTATES to walk state_list rather
  than the RB trees;

- Converts the purge thread to use the new state_list and perform a partial
  purge every second, with the target rate a full state table walk every
  PFTM_INTERVAL seconds.

seen by mcbride, henning, dhartmei pre-3.8, but too intrusive for then
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.25 2005/08/16 11:26:48 pascoe Exp $	*/
d194 1
a194 1
#define	PFSYNC_VERSION	2
d210 1
@


1.25
log
@Only send the PFSS_TIMESTAMP timestamp bit across the wire, in case we
want to map the remaining bits to something else later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.24 2005/08/16 11:22:43 pascoe Exp $	*/
d181 2
d187 2
@


1.24
log
@Synchronise timestamp modulation and scrubbing min ttl information.

ok henning mcbride, looks good frantzen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.23 2005/08/13 08:56:14 pascoe Exp $	*/
d258 2
a259 1
		(d)->scrub.pfss_flags = htons((s)->scrub->pfss_flags);	\
@


1.23
log
@Partial backout of previous revision, reinstates the ability to propagate
a kill message for a state that was generated on another firewall.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.22 2005/08/03 01:12:19 pascoe Exp $	*/
d38 1
d58 1
a58 2
	u_int8_t	scrub_flag;
	u_int8_t	pad[5];
d257 6
d273 7
@


1.22
log
@Do not send "deletion" messages for states created by other pfsync peers when
they timeout.  Any other hosts that have also learnt these states will already
know that they are due to time out.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.21 2005/08/03 00:51:43 pascoe Exp $	*/
d299 1
a299 2
	if (!st->sync_flags &&					\
	    st->creatorid == pf_status.hostid)			\
@


1.21
log
@use flag macro instead of constant
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.20 2005/05/28 15:10:07 ho Exp $	*/
d299 2
a300 1
	if (!st->sync_flags)					\
a302 1
	st->sync_flags &= ~PFSTATE_FROMSYNC;			\
@


1.20
log
@Add SA replay counter synchronization to pfsync(4). Required for IPsec
failover gateways. ok mcbride@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.19 2005/01/20 17:47:38 mcbride Exp $	*/
d288 2
a289 1
		pfsync_pack_state(PFSYNC_ACT_INS, (st), 1);	\
@


1.19
log
@Use syncdev instead of syncif in ifconfig, and modify ioctl struct pfsyncreq
in kernel code to match.  Brings pfsync in line with carp, vlan and pppoe
devices. Old syncif and -syncif options still work, will be removed later.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.18 2004/12/14 13:41:01 mickey Exp $	*/
d91 10
d156 4
d168 1
d175 1
d178 1
d203 2
a204 1
#define	PFSYNC_ACT_MAX		10
d214 1
a214 1
	"UPD REQ", "BLK UPD STAT"
d303 1
@


1.18
log
@move the ioctls w/ all the other ifaces; mcbride@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.17 2004/11/16 20:07:56 mcbride Exp $	*/
d224 1
a224 1
	char		 pfsyncr_syncif[IFNAMSIZ];
@


1.17
log
@Fix for PR3983
- Add a new PFSTATE_STALE flag to uncompressed state updates sent as a result
  of a stale state being detected, and prevent updates with this flag from
  generating similar messages.
- For the specific case where the state->src in the recieved update is ok but
  the state.dst is not, take the partial update, then "fail" to let the other
  peers pick up the better data that we have. From Chris Pascoe.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.16 2004/08/03 05:32:28 mcbride Exp $	*/
a228 2
#define SIOCSETPFSYNC	_IOW('i', 247, struct ifreq)
#define SIOCGETPFSYNC	_IOWR('i', 248, struct ifreq)
@


1.16
log
@Allow a unicast ip address to be specified for pfsync to send it's state
updates to; this allows pairs of pfsync firewalls to protect the traffic
with IPSec.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.15 2004/07/13 22:51:48 deraadt Exp $	*/
d88 3
d277 2
a278 1
		pfsync_pack_state(PFSYNC_ACT_UPD, (st), 1);	\
d283 2
a284 1
		pfsync_pack_state(PFSYNC_ACT_DEL, (st), 1);	\
@


1.15
log
@spelling; dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.14 2004/04/28 00:47:06 mcbride Exp $	*/
d153 1
d188 1
a188 1
#define PFSYNC_MAX_BULKTRIES	12	
d221 4
a224 3
	char	pfsyncr_syncif[IFNAMSIZ];
	int	pfsyncr_maxupdates;
	int	pfsyncr_authlevel;
@


1.14
log
@pfsync stats fixups:
- convert counters to 64 bits
- add dedicated counters for sanity checks added right before release
- clean up netstat output
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.13 2004/03/22 04:54:17 mcbride Exp $	*/
d154 2
a155 2
	struct mbuf		*sc_mbuf;	/* current cummulative mbuf */
	struct mbuf		*sc_mbuf_net;	/* current cummulative mbuf */
@


1.13
log
@Support for best effort bulk transfers of states when pfsync syncif is
configured.  This this allows pfsync+carp clusters to come up gracefully
without killing active connections. pfsync now prevents carp from
preempting to become master until the state table has sync'd.

ABI change, any application which use struct pf_state must be recompiled.

Reminded about this by Christian Gut. Thanks to beck@@ cedric@@ and dhartmei@@
for testing and comments.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.12 2004/02/20 19:22:03 mcbride Exp $	*/
d197 17
a213 15
	u_long	pfsyncs_ipackets;	/* total input packets, IPv4 */
	u_long	pfsyncs_ipackets6;	/* total input packets, IPv6 */
	u_long	pfsyncs_badif;		/* not the right interface */
	u_long	pfsyncs_badttl;		/* TTL is not PFSYNC_DFLTTL */
	u_long	pfsyncs_hdrops;		/* packets shorter than header */
	u_long	pfsyncs_badver;		/* bad (incl unsupp) version */
	u_long	pfsyncs_badact;		/* bad action */
	u_long	pfsyncs_badlen;		/* data length does not match */
	u_long	pfsyncs_badauth;	/* bad authentication */
	u_long	pfsyncs_badstate;	/* insert/lookup failed */

	u_long	pfsyncs_opackets;	/* total output packets, IPv4 */
	u_long	pfsyncs_opackets6;	/* total output packets, IPv6 */
	u_long	pfsyncs_onomem;		/* no memory for an mbuf for a send */
	u_long	pfsyncs_oerrors;	/* ip output error */
@


1.12
log
@Make pfsync deal with clearing states bound to a group or interface (eg
pfctl -i fxp0 -Fs). Also don't send out individual state deletions if we're
sending a clear message, move pfsync_clear_states() inside splnet, and fix
if_pfsync.h includes in  pf.c and pf_ioctl.c.

ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.11 2004/02/10 09:21:54 mcbride Exp $	*/
d123 9
d139 1
d143 2
d151 2
d158 3
d181 2
a182 1
#define	PFSYNC_ACT_MAX		9
d186 2
d191 2
a192 1
	"UPD ST COMP", "DEL ST COMP", "INS FR", "DEL FR", "UPD REQ"
@


1.11
log
@Make pfsync work correctly with IP options on 64-bit alignment
sensitive CPUs. Pointed out by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.10 2004/01/22 09:25:25 mcbride Exp $	*/
d118 1
d237 1
a237 1
int pfsync_clear_states(u_int32_t);
d240 2
a241 1
	if (st->rule.ptr->rule_flag & PFRULE_NOSYNC)		\
@


1.10
log
@- Include the value of pf_state.timeout in pfsync messages
- Fix the expiry time calculations, for real
- Unbreak the collapsing of multiple updates into one
And a little KNF for good measure.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.9 2004/01/18 19:55:52 mcbride Exp $	*/
d32 3
d62 1
a62 1
	u_int64_t	 id;
d89 1
a89 1
	u_int64_t		id;
d100 1
a100 1
	u_int64_t		id;
d112 1
a112 1
	u_int64_t		id;
@


1.9
log
@Port is already stored in network byte order, no need to convert.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.8 2003/12/31 11:18:25 cedric Exp $	*/
d91 1
d93 1
a93 1
	u_int8_t		pad[7];
@


1.8
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.7 2003/12/28 17:18:58 mcbride Exp $	*/
d222 1
a222 1
	(d)->port = htons((s)->port);				\
d227 1
a227 1
	(d)->port = ntohs((s)->port);				\
@


1.7
log
@Add a new PFSYNC_ACT_UREQ message type.

A pfsync system which recieves a partial update for a state it cannot
find can now request a full version of the update, and insert it.
pfsync'd firewalls now converge more gracefully if one is missing some
states (due to reset, lost insert packets, etc).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.6 2003/12/15 21:49:38 deraadt Exp $	*/
d60 1
d147 1
a147 1
#define	PFSYNC_VERSION	1
@


1.6
log
@sc_sp is a #define on some architectures, use a different name
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.5 2003/12/15 07:28:25 mcbride Exp $	*/
d106 6
d124 1
d133 1
d157 2
a158 1
#define	PFSYNC_ACT_MAX		8
d165 1
a165 1
	"UPD ST COMP", "DEL ST COMP", "INS FR", "DEL FR"
d232 17
a248 17
int pfsync_pack_state(u_int8_t, struct pf_state *);
#define pfsync_insert_state(st)	do {			\
	if (st->rule.ptr->rule_flag & PFRULE_NOSYNC)	\
		st->sync_flags |= PFSTATE_NOSYNC;	\
	else if (!st->sync_flags)			\
		pfsync_pack_state(PFSYNC_ACT_INS, (st));\
	st->sync_flags &= ~PFSTATE_FROMSYNC;		\
} while (0)
#define pfsync_update_state(st) do {			\
	if (!st->sync_flags)				\
		pfsync_pack_state(PFSYNC_ACT_UPD, (st));\
	st->sync_flags &= ~PFSTATE_FROMSYNC;		\
} while (0)
#define pfsync_delete_state(st) do {			\
	if (!st->sync_flags)				\
		pfsync_pack_state(PFSYNC_ACT_DEL, (st));\
	st->sync_flags &= ~PFSTATE_FROMSYNC;		\
@


1.5
log
@Fix whitespace screwups before henning wakes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.4 2003/12/15 07:11:30 mcbride Exp $	*/
d113 1
a113 1
union sc_sp {
d128 2
a129 2
	union sc_sp		 sc_sp;
	union sc_sp		 sc_sp_net;
@


1.4
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.3 2003/11/08 00:45:34 mcbride Exp $	*/
d113 2
a114 2
union sc_sp {	
	struct pfsync_state	*s;	
d129 1
a129 1
	union sc_sp		 sc_sp_net;			
d144 1
a144 1
#define	PFSYNC_ACT_DEL		3	/* delete state */	
d158 1
a158 1
#define PFSYNC_DFLTTL             255
@


1.3
log
@Add 'no-sync' state option to prevent state transition messages for states
created by this rule from appearing on the pfsync(4) interface. e.g.

pass in proto tcp to self flags S/SA keep state (no-sync)

ok cedric@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.2 2002/12/11 18:31:26 mickey Exp $	*/
d32 79
d112 8
d121 2
a122 1
	struct ifnet	sc_if;
d124 8
a131 4
	struct timeout	sc_tmo;
	struct mbuf	*sc_mbuf;	/* current cummulative mbuf */
	struct pf_state	*sc_ptr;	/* current ongoing state */
	int		 sc_count;	/* number of states in one mtu */
d135 1
d141 9
a149 5
#define	PFSYNC_ACT_CLR	0
#define	PFSYNC_ACT_INS	1
#define	PFSYNC_ACT_UPD	2
#define	PFSYNC_ACT_DEL	3
#define	PFSYNC_ACT_MAX	4
d151 1
a151 1
};
d155 34
a188 1
	"CLR ST", "INS ST", "UPD ST", "DEL ST"
d195 1
d197 1
d205 1
d207 11
d221 2
a222 1
int pfsync_clear_state(struct pf_state *);
d225 3
a227 1
	if (!(st->rule.ptr->rule_flag & PFRULE_NOSYNC))	\
d229 1
d232 1
a232 1
	if (!(st->rule.ptr->rule_flag & PFRULE_NOSYNC))	\
d234 1
d237 1
a237 1
	if (!(st->rule.ptr->rule_flag & PFRULE_NOSYNC))	\
d239 1
@


1.2
log
@unpee
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.h,v 1.1 2002/11/29 18:25:22 mickey Exp $	*/
d79 12
a90 3
#define pfsync_insert_state(st)	pfsync_pack_state(PFSYNC_ACT_INS, (st))
#define pfsync_update_state(st)	pfsync_pack_state(PFSYNC_ACT_UPD, (st))
#define pfsync_delete_state(st)	pfsync_pack_state(PFSYNC_ACT_DEL, (st))
@


1.2.4.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 87
struct pfsync_state_scrub {
	u_int16_t	pfss_flags;
	u_int8_t	pfss_ttl;	/* stashed TTL		*/
	u_int8_t	scrub_flag;
	u_int32_t	pfss_ts_mod;	/* timestamp modulation	*/
} __packed;

struct pfsync_state_host {
	struct pf_addr	addr;
	u_int16_t	port;
	u_int16_t	pad[3];
} __packed;

struct pfsync_state_peer {
	struct pfsync_state_scrub scrub;	/* state is scrubbed	*/
	u_int32_t	seqlo;		/* Max sequence number sent	*/
	u_int32_t	seqhi;		/* Max the other end ACKd + win	*/
	u_int32_t	seqdiff;	/* Sequence number modulator	*/
	u_int16_t	max_win;	/* largest window (pre scaling)	*/
	u_int16_t	mss;		/* Maximum segment size option	*/
	u_int8_t	state;		/* active state level		*/
	u_int8_t	wscale;		/* window scaling factor	*/
	u_int8_t	scrub_flag;
	u_int8_t	pad[5];
} __packed;

struct pfsync_state {
	u_int64_t	 id;
	char		 ifname[IFNAMSIZ];
	struct pfsync_state_host lan;
	struct pfsync_state_host gwy;
	struct pfsync_state_host ext;
	struct pfsync_state_peer src;
	struct pfsync_state_peer dst;
	struct pf_addr	 rt_addr;
	u_int32_t	 rule;
	u_int32_t	 anchor;
	u_int32_t	 nat_rule;
	u_int32_t	 creation;
	u_int32_t	 expire;
	u_int32_t	 packets[2];
	u_int32_t	 bytes[2];
	u_int32_t	 creatorid;
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
	u_int8_t	 log;
	u_int8_t	 allow_opts;
	u_int8_t	 timeout;
	u_int8_t	 sync_flags;
	u_int8_t	 updates;
} __packed;

struct pfsync_state_upd {
	u_int64_t		id;
	struct pfsync_state_peer	src;
	struct pfsync_state_peer	dst;
	u_int32_t		creatorid;
	u_int32_t		expire;
	u_int8_t		timeout;
	u_int8_t		updates;
	u_int8_t		pad[6];
} __packed;

struct pfsync_state_del {
	u_int64_t		id;
	u_int32_t		creatorid;
	struct {
		u_int8_t	state;
	} src;
	struct {
		u_int8_t	state;
	} dst;
	u_int8_t		pad[2];
} __packed;

struct pfsync_state_upd_req {
	u_int64_t		id;
	u_int32_t		creatorid;
	u_int32_t		pad;
} __packed;

struct pfsync_state_clr {
	u_int32_t		creatorid;
	u_int32_t		pad;
} __packed;

a32 9

union sc_statep {
	struct pfsync_state	*s;
	struct pfsync_state_upd	*u;
	struct pfsync_state_del	*d;
	struct pfsync_state_clr	*c;
	struct pfsync_state_upd_req	*r;
};

d34 1
a34 2
	struct ifnet		 sc_if;
	struct ifnet		*sc_sync_ifp;
d36 4
a39 9
	struct ip_moptions	 sc_imo;
	struct timeout		 sc_tmo;
	struct in_addr		 sc_sendaddr;
	struct mbuf		*sc_mbuf;	/* current cummulative mbuf */
	struct mbuf		*sc_mbuf_net;	/* current cummulative mbuf */
	union sc_statep		 sc_statep;
	union sc_statep		 sc_statep_net;
	int			 sc_maxcount;	/* number of states in mtu */
	int			 sc_maxupdates;	/* number of updates/state */
a42 1

d45 1
a45 1
#define	PFSYNC_VERSION	2
d48 5
a52 10
#define	PFSYNC_ACT_CLR		0	/* clear all states */
#define	PFSYNC_ACT_INS		1	/* insert state */
#define	PFSYNC_ACT_UPD		2	/* update state */
#define	PFSYNC_ACT_DEL		3	/* delete state */
#define	PFSYNC_ACT_UPD_C	4	/* "compressed" state update */
#define	PFSYNC_ACT_DEL_C	5	/* "compressed" state delete */
#define	PFSYNC_ACT_INS_F	6	/* insert fragment */
#define	PFSYNC_ACT_DEL_F	7	/* delete fragments */
#define	PFSYNC_ACT_UREQ		8	/* request "uncompressed" state */
#define	PFSYNC_ACT_MAX		9
d54 1
a54 1
} __packed;
d58 1
a58 34
	"CLR ST", "INS ST", "UPD ST", "DEL ST", \
	"UPD ST COMP", "DEL ST COMP", "INS FR", "DEL FR", "UPD REQ"

#define PFSYNC_DFLTTL		255

struct pfsyncstats {
	u_long	pfsyncs_ipackets;	/* total input packets, IPv4 */
	u_long	pfsyncs_ipackets6;	/* total input packets, IPv6 */
	u_long	pfsyncs_badif;		/* not the right interface */
	u_long	pfsyncs_badttl;		/* TTL is not PFSYNC_DFLTTL */
	u_long	pfsyncs_hdrops;		/* packets shorter than header */
	u_long	pfsyncs_badver;		/* bad (incl unsupp) version */
	u_long	pfsyncs_badact;		/* bad action */
	u_long	pfsyncs_badlen;		/* data length does not match */
	u_long	pfsyncs_badauth;	/* bad authentication */
	u_long	pfsyncs_badstate;	/* insert/lookup failed */

	u_long	pfsyncs_opackets;	/* total output packets, IPv4 */
	u_long	pfsyncs_opackets6;	/* total output packets, IPv6 */
	u_long	pfsyncs_onomem;		/* no memory for an mbuf for a send */
	u_long	pfsyncs_oerrors;	/* ip output error */
};

/*
 * Configuration structure for SIOCSETPFSYNC SIOCGETPFSYNC
 */
struct pfsyncreq {
	char	pfsyncr_syncif[IFNAMSIZ];
	int	pfsyncr_maxupdates;
	int	pfsyncr_authlevel;
};
#define SIOCSETPFSYNC	_IOW('i', 247, struct ifreq)
#define SIOCGETPFSYNC	_IOWR('i', 248, struct ifreq)

a64 1
	(d)->mss = htons((s)->mss);		\
a65 1
	(d)->wscale = (s)->wscale;		\
a72 1
	(d)->mss = ntohs((s)->mss);		\
a73 11
	(d)->wscale = (s)->wscale;		\
} while (0)

#define pf_state_host_hton(s,d) do {				\
	bcopy(&(s)->addr, &(d)->addr, sizeof((d)->addr));	\
	(d)->port = (s)->port;					\
} while (0)

#define pf_state_host_ntoh(s,d) do {				\
	bcopy(&(s)->addr, &(d)->addr, sizeof((d)->addr));	\
	(d)->port = (s)->port;					\
d77 5
a81 20
void pfsync_input(struct mbuf *, ...);
int pfsync_clear_states(u_int32_t);
int pfsync_pack_state(u_int8_t, struct pf_state *, int);
#define pfsync_insert_state(st)	do {				\
	if (st->rule.ptr->rule_flag & PFRULE_NOSYNC)		\
		st->sync_flags |= PFSTATE_NOSYNC;		\
	else if (!st->sync_flags)				\
		pfsync_pack_state(PFSYNC_ACT_INS, (st), 1);	\
	st->sync_flags &= ~PFSTATE_FROMSYNC;			\
} while (0)
#define pfsync_update_state(st) do {				\
	if (!st->sync_flags)					\
		pfsync_pack_state(PFSYNC_ACT_UPD, (st), 1);	\
	st->sync_flags &= ~PFSTATE_FROMSYNC;			\
} while (0)
#define pfsync_delete_state(st) do {				\
	if (!st->sync_flags)					\
		pfsync_pack_state(PFSYNC_ACT_DEL, (st), 1);	\
	st->sync_flags &= ~PFSTATE_FROMSYNC;			\
} while (0)
@


1.2.4.2
log
@Merge with the trunk
@
text
@a31 3

#define PFSYNC_ID_LEN	sizeof(u_int64_t)

d59 1
a59 1
	u_int32_t	 id[2];
d86 1
a86 1
	u_int32_t		id[2];
d97 1
a97 1
	u_int32_t		id[2];
d109 1
a109 1
	u_int32_t		id[2];
a114 1
	char			ifname[IFNAMSIZ];
a118 9
struct pfsync_state_bus {
	u_int32_t		creatorid;
	u_int32_t		endtime;
	u_int8_t		status;
#define PFSYNC_BUS_START	1
#define PFSYNC_BUS_END		2
	u_int8_t		pad[7];
} __packed;

a125 1
	struct pfsync_state_bus	*b;
a128 2
extern int	pfsync_sync_ok;

a134 2
	struct timeout		 sc_bulk_tmo;
	struct timeout		 sc_bulkfail_tmo;
a139 3
	u_int32_t		 sc_ureq_received;
	u_int32_t		 sc_ureq_sent;
	int			 sc_bulk_tries;
d160 1
a160 2
#define PFSYNC_ACT_BUS		9	/* Bulk Update Status */
#define	PFSYNC_ACT_MAX		10
a163 2
#define PFSYNC_BULKPACKETS	1	/* # of packets per timeout */
#define PFSYNC_MAX_BULKTRIES	12	
d167 1
a167 2
	"UPD ST COMP", "DEL ST COMP", "INS FR", "DEL FR", \
	"UPD REQ", "BLK UPD STAT"
d172 15
a186 17
	u_int64_t	pfsyncs_ipackets;	/* total input packets, IPv4 */
	u_int64_t	pfsyncs_ipackets6;	/* total input packets, IPv6 */
	u_int64_t	pfsyncs_badif;		/* not the right interface */
	u_int64_t	pfsyncs_badttl;		/* TTL is not PFSYNC_DFLTTL */
	u_int64_t	pfsyncs_hdrops;		/* packets shorter than hdr */
	u_int64_t	pfsyncs_badver;		/* bad (incl unsupp) version */
	u_int64_t	pfsyncs_badact;		/* bad action */
	u_int64_t	pfsyncs_badlen;		/* data length does not match */
	u_int64_t	pfsyncs_badauth;	/* bad authentication */
	u_int64_t	pfsyncs_stale;		/* stale state */
	u_int64_t	pfsyncs_badval;		/* bad values */
	u_int64_t	pfsyncs_badstate;	/* insert/lookup failed */

	u_int64_t	pfsyncs_opackets;	/* total output packets, IPv4 */
	u_int64_t	pfsyncs_opackets6;	/* total output packets, IPv6 */
	u_int64_t	pfsyncs_onomem;		/* no memory for an mbuf */
	u_int64_t	pfsyncs_oerrors;	/* ip output error */
d233 1
a233 1
int pfsync_clear_states(u_int32_t, char *);
d236 1
a236 2
	if ((st->rule.ptr->rule_flag & PFRULE_NOSYNC) ||	\
	    (st->proto == IPPROTO_PFSYNC))			\
@


1.1
log
@expose state table changes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 2
a78 2
int pfsync_clear_state __P((struct pf_state *));
int pfsync_pack_state __P((u_int8_t, struct pf_state *));
@

