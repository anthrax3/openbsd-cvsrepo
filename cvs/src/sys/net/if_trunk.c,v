head	1.134;
access;
symbols
	OPENBSD_6_2_BASE:1.134
	OPENBSD_6_1:1.129.0.4
	OPENBSD_6_1_BASE:1.129
	OPENBSD_6_0:1.127.0.4
	OPENBSD_6_0_BASE:1.127
	OPENBSD_5_9:1.126.0.2
	OPENBSD_5_9_BASE:1.126
	OPENBSD_5_8:1.109.0.4
	OPENBSD_5_8_BASE:1.109
	OPENBSD_5_7:1.94.0.2
	OPENBSD_5_7_BASE:1.94
	OPENBSD_5_6:1.90.0.4
	OPENBSD_5_6_BASE:1.90
	OPENBSD_5_5:1.86.0.4
	OPENBSD_5_5_BASE:1.86
	OPENBSD_5_4:1.84.0.2
	OPENBSD_5_4_BASE:1.84
	OPENBSD_5_3:1.79.0.2
	OPENBSD_5_3_BASE:1.79
	OPENBSD_5_2:1.78.0.4
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.2
	OPENBSD_5_0:1.77.0.4
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.77.0.2
	OPENBSD_4_9_BASE:1.77
	OPENBSD_4_8:1.75.0.2
	OPENBSD_4_8_BASE:1.75
	OPENBSD_4_7:1.71.0.2
	OPENBSD_4_7_BASE:1.71
	OPENBSD_4_6:1.65.0.6
	OPENBSD_4_6_BASE:1.65
	OPENBSD_4_5:1.65.0.2
	OPENBSD_4_5_BASE:1.65
	OPENBSD_4_4:1.48.0.2
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.134
date	2017.08.14.08.31.00;	author reyk;	state Exp;
branches;
next	1.133;
commitid	tIOtsUBzVA3oQNED;

1.133
date	2017.08.11.21.24.19;	author mpi;	state Exp;
branches;
next	1.132;
commitid	qO4hXiGM2yDTtiTI;

1.132
date	2017.05.28.15.03.53;	author mpi;	state Exp;
branches;
next	1.131;
commitid	n19vmnwCCIlm64GC;

1.131
date	2017.05.28.14.26.38;	author mpi;	state Exp;
branches;
next	1.130;
commitid	Z3DjNealRgleodWW;

1.130
date	2017.05.28.09.38.32;	author mpi;	state Exp;
branches;
next	1.129;
commitid	9cMFwXpUiQKwkuZY;

1.129
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.128;
commitid	VyLWTsbepAOk7VQM;

1.128
date	2016.09.16.09.51.21;	author mikeb;	state Exp;
branches;
next	1.127;
commitid	vB1qIYLHLFwl6cUP;

1.127
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.126;
commitid	Xo6g1xk26RWDGcjJ;

1.126
date	2015.12.31.14.18.34;	author sthen;	state Exp;
branches;
next	1.125;
commitid	ADy5hfUT9RSrmVzd;

1.125
date	2015.11.21.11.02.23;	author dlg;	state Exp;
branches;
next	1.124;
commitid	N5p36YgyutlkxYcJ;

1.124
date	2015.11.20.05.33.54;	author dlg;	state Exp;
branches;
next	1.123;
commitid	rpxxRzFr14M2nANQ;

1.123
date	2015.11.12.10.07.14;	author mpi;	state Exp;
branches;
next	1.122;
commitid	DLHQ4NjCPIqpY9kD;

1.122
date	2015.10.25.12.05.40;	author mpi;	state Exp;
branches;
next	1.121;
commitid	iXTa9MhdGfWGiTE6;

1.121
date	2015.10.08.13.58.07;	author mikeb;	state Exp;
branches;
next	1.120;
commitid	40VYOGcRFoHFmvP2;

1.120
date	2015.10.08.11.39.59;	author dlg;	state Exp;
branches;
next	1.119;
commitid	kBcS8i3x5iDkFSlw;

1.119
date	2015.10.05.13.00.04;	author mikeb;	state Exp;
branches;
next	1.118;
commitid	49G7IYOLbXQgQ7Cs;

1.118
date	2015.09.29.10.11.40;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	L3Bwt4zBOCs33Zbo;

1.117
date	2015.09.28.08.24.53;	author mpi;	state Exp;
branches;
next	1.116;
commitid	Nw7RtPUfLwJqeuAc;

1.116
date	2015.09.24.14.46.22;	author mikeb;	state Exp;
branches;
next	1.115;
commitid	98BWoqTax8j05Zfa;

1.115
date	2015.09.24.14.01.20;	author mikeb;	state Exp;
branches;
next	1.114;
commitid	DHugk9hjYm6Xthvw;

1.114
date	2015.09.23.12.50.06;	author mikeb;	state Exp;
branches;
next	1.113;
commitid	h0DWO9TSRmNNDsmd;

1.113
date	2015.09.23.12.42.45;	author mikeb;	state Exp;
branches;
next	1.112;
commitid	yNRyWLPVgXQlDajo;

1.112
date	2015.09.23.12.40.12;	author mikeb;	state Exp;
branches;
next	1.111;
commitid	XbcW7OHbAl4AkrQy;

1.111
date	2015.09.10.16.41.30;	author mikeb;	state Exp;
branches;
next	1.110;
commitid	Dj2db8t0KelqURhl;

1.110
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.109;
commitid	JbEzJsyDrWqOW57C;

1.109
date	2015.07.17.23.32.18;	author mpi;	state Exp;
branches;
next	1.108;
commitid	NdSdQbSWY9r4Ffw9;

1.108
date	2015.07.02.10.02.40;	author mpi;	state Exp;
branches;
next	1.107;
commitid	nKROsdKiADu5GTos;

1.107
date	2015.07.02.09.40.02;	author mpi;	state Exp;
branches;
next	1.106;
commitid	eKXa0TkOIth1tkBS;

1.106
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.105;
commitid	fE8TgA9vpwdUU5Wy;

1.105
date	2015.06.29.10.32.29;	author dlg;	state Exp;
branches;
next	1.104;
commitid	rqyNfIORa1UIJQnb;

1.104
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.103;
commitid	MVWrtktB46JRxFWT;

1.103
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.102;
commitid	h7z8lokZ0dFyuWpg;

1.102
date	2015.06.15.15.55.08;	author mpi;	state Exp;
branches;
next	1.101;
commitid	Cp8mTDkAol2tmaI6;

1.101
date	2015.06.09.14.50.14;	author mpi;	state Exp;
branches;
next	1.100;
commitid	hzPq5pFo63wV6Ehi;

1.100
date	2015.05.26.11.39.07;	author mpi;	state Exp;
branches;
next	1.99;
commitid	VJjEISzzvhOYKF2A;

1.99
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.98;
commitid	1aiWjheMGhmTuiHL;

1.98
date	2015.05.14.10.55.28;	author mpi;	state Exp;
branches;
next	1.97;
commitid	xa3lMMK6DiUzaKDq;

1.97
date	2015.05.13.08.16.01;	author mpi;	state Exp;
branches;
next	1.96;
commitid	vrUnLjm6nwy7iRD7;

1.96
date	2015.05.11.08.41.43;	author mpi;	state Exp;
branches;
next	1.95;
commitid	clvzRlWWi271kseu;

1.95
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.94;
commitid	p4LJxGKbi0BU2cG6;

1.94
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.93;
commitid	zhW8jJrfVCoAthrR;

1.93
date	2014.12.04.00.01.53;	author tedu;	state Exp;
branches;
next	1.92;
commitid	wP6d1LFSgXabDbTH;

1.92
date	2014.12.01.15.06.54;	author mikeb;	state Exp;
branches;
next	1.91;
commitid	oohxazEA8Jchx2XI;

1.91
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.90;
commitid	Z1vcFtHO8wRH0yRt;

1.90
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.89;
commitid	DQakU8LLWV6Iwx84;

1.89
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.88;
commitid	B4dZSbxas1X1IpXI;

1.88
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.87;
commitid	Nnxg8ONtI4Ep9pUb;

1.87
date	2014.03.10.12.21.35;	author mpi;	state Exp;
branches;
next	1.86;

1.86
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.85;

1.85
date	2013.11.18.09.16.30;	author mpi;	state Exp;
branches;
next	1.84;

1.84
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.83;

1.83
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.82;

1.82
date	2013.05.11.11.18.27;	author sthen;	state Exp;
branches;
next	1.81;

1.81
date	2013.04.02.08.54.37;	author mpi;	state Exp;
branches;
next	1.80;

1.80
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.79;

1.79
date	2013.02.25.22.00.46;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2011.10.28.12.49.43;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2011.01.28.14.20.37;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2010.11.12.13.26.29;	author dhill;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.08.11.26.06;	author stsp;	state Exp;
branches;
next	1.74;

1.74
date	2010.04.23.13.51.31;	author stsp;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.72;

1.72
date	2010.04.17.17.47.03;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2010.01.12.01.36.33;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2009.11.18.02.09.59;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2009.09.17.13.13.56;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2009.09.09.15.01.18;	author reyk;	state Exp;
branches;
next	1.67;

1.67
date	2009.07.16.22.58.45;	author thib;	state Exp;
branches;
next	1.66;

1.66
date	2009.07.13.12.39.22;	author dlg;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.27.16.40.54;	author naddy;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.27.12.58.27;	author naddy;	state Exp;
branches;
next	1.63;

1.63
date	2008.12.14.23.08.52;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2008.12.14.23.04.06;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2008.11.16.03.42.13;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2008.11.08.01.00.01;	author mpf;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.04.13.44.11;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2008.10.30.20.44.02;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2008.10.28.07.18.45;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.28.07.14.45;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.28.07.13.01;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.28.07.11.03;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2008.10.28.07.10.09;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.17.20.10.37;	author chl;	state Exp;
branches;
next	1.49;

1.49
date	2008.08.07.18.06.17;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2008.08.06.17.04.28;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2008.07.30.10.15.35;	author mpf;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.15.06.56.09;	author mpf;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.14.01.18.53;	author mpf;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.13.23.24.21;	author mpf;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.08.17.25.46;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.07.13.45.35;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.10.09.52.04;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.20.20.42.11;	author canacar;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.22.17.02.03;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.22.14.48.52;	author pyr;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.07.11.00.47;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.06.16.22.55;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.06.16.14.05;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.26.17.13.31;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.26.08.57.59;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.31.06.20.19;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.28.01.14.15;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.23.04.56.55;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.23.04.35.52;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.20.22.03.24;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.20.20.52.57;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.16.20.23.10;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.11.03.12.36;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.04.17.51.39;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.21.18.44.21;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.21.18.41.55;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.18.17.59.59;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.17.23.44.29;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.27.15.53.50;	author mcbride;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.27.15.46.04;	author mcbride;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.27.09.29.42;	author mcbride;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.27.09.27.14;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.23.14.07.11;	author mpf;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.09.18.45.27;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.03.01.46.47;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.14.08.07.24;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.11.16.17.01;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.10.22.40.36;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.27.22.57.13;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.24.07.51.53;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.24.02.45.17;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.134
log
@The "ret" return value is reused and overwritten, potentially
returning 0 (success) on error instead of an error number.  The caller
doesn't evaluate the return value, so it is good enough to return
ENOBUFS (non-0) on error and to remove "ret" in trunk_cast_start().

Coverity CID 1453105; Severity: Minor

OK mpi@@
@
text
@/*	$OpenBSD: if_trunk.c,v 1.133 2017/08/11 21:24:19 mpi Exp $	*/

/*
 * Copyright (c) 2005, 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/systm.h>
#include <sys/task.h>
#include <sys/timeout.h>

#include <crypto/siphash.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_types.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif

#include <net/if_vlan_var.h>
#include <net/if_trunk.h>
#include <net/trunklacp.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

SLIST_HEAD(__trhead, trunk_softc) trunk_list;	/* list of trunks */

void	 trunkattach(int);
int	 trunk_clone_create(struct if_clone *, int);
int	 trunk_clone_destroy(struct ifnet *);
void	 trunk_lladdr(struct arpcom *, u_int8_t *);
int	 trunk_capabilities(struct trunk_softc *);
void	 trunk_port_lladdr(struct trunk_port *, u_int8_t *);
int	 trunk_port_create(struct trunk_softc *, struct ifnet *);
int	 trunk_port_destroy(struct trunk_port *);
void	 trunk_port_state(void *);
void	 trunk_port_ifdetach(void *);
int	 trunk_port_ioctl(struct ifnet *, u_long, caddr_t);
int	 trunk_port_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);
struct trunk_port *trunk_port_get(struct trunk_softc *, struct ifnet *);
int	 trunk_port_checkstacking(struct trunk_softc *);
void	 trunk_port2req(struct trunk_port *, struct trunk_reqport *);
int	 trunk_ioctl(struct ifnet *, u_long, caddr_t);
int	 trunk_ether_addmulti(struct trunk_softc *, struct ifreq *);
int	 trunk_ether_delmulti(struct trunk_softc *, struct ifreq *);
void	 trunk_ether_purgemulti(struct trunk_softc *);
int	 trunk_ether_cmdmulti(struct trunk_port *, u_long);
int	 trunk_ioctl_allports(struct trunk_softc *, u_long, caddr_t);
int	 trunk_input(struct ifnet *, struct mbuf *, void *);
void	 trunk_start(struct ifnet *);
void	 trunk_init(struct ifnet *);
void	 trunk_stop(struct ifnet *);
int	 trunk_media_change(struct ifnet *);
void	 trunk_media_status(struct ifnet *, struct ifmediareq *);
struct trunk_port *trunk_link_active(struct trunk_softc *,
	    struct trunk_port *);
const void *trunk_gethdr(struct mbuf *, u_int, u_int, void *);

struct if_clone trunk_cloner =
    IF_CLONE_INITIALIZER("trunk", trunk_clone_create, trunk_clone_destroy);

/* Simple round robin */
int	 trunk_rr_attach(struct trunk_softc *);
int	 trunk_rr_detach(struct trunk_softc *);
void	 trunk_rr_port_destroy(struct trunk_port *);
int	 trunk_rr_start(struct trunk_softc *, struct mbuf *);
int	 trunk_rr_input(struct trunk_softc *, struct trunk_port *,
	    struct mbuf *);

/* Active failover */
int	 trunk_fail_attach(struct trunk_softc *);
int	 trunk_fail_detach(struct trunk_softc *);
int	 trunk_fail_port_create(struct trunk_port *);
void	 trunk_fail_port_destroy(struct trunk_port *);
int	 trunk_fail_start(struct trunk_softc *, struct mbuf *);
int	 trunk_fail_input(struct trunk_softc *, struct trunk_port *,
	    struct mbuf *);
void	 trunk_fail_linkstate(struct trunk_port *);

/* Loadbalancing */
int	 trunk_lb_attach(struct trunk_softc *);
int	 trunk_lb_detach(struct trunk_softc *);
int	 trunk_lb_port_create(struct trunk_port *);
void	 trunk_lb_port_destroy(struct trunk_port *);
int	 trunk_lb_start(struct trunk_softc *, struct mbuf *);
int	 trunk_lb_input(struct trunk_softc *, struct trunk_port *,
	    struct mbuf *);
int	 trunk_lb_porttable(struct trunk_softc *, struct trunk_port *);

/* Broadcast mode */
int	 trunk_bcast_attach(struct trunk_softc *);
int	 trunk_bcast_detach(struct trunk_softc *);
int	 trunk_bcast_start(struct trunk_softc *, struct mbuf *);
int	 trunk_bcast_input(struct trunk_softc *, struct trunk_port *,
	    struct mbuf *);

/* 802.3ad LACP */
int	 trunk_lacp_attach(struct trunk_softc *);
int	 trunk_lacp_detach(struct trunk_softc *);
int	 trunk_lacp_start(struct trunk_softc *, struct mbuf *);
int	 trunk_lacp_input(struct trunk_softc *, struct trunk_port *,
	    struct mbuf *);

/* Trunk protocol table */
static const struct {
	enum trunk_proto	ti_proto;
	int			(*ti_attach)(struct trunk_softc *);
} trunk_protos[] = {
	{ TRUNK_PROTO_ROUNDROBIN,	trunk_rr_attach },
	{ TRUNK_PROTO_FAILOVER,		trunk_fail_attach },
	{ TRUNK_PROTO_LOADBALANCE,	trunk_lb_attach },
	{ TRUNK_PROTO_BROADCAST,	trunk_bcast_attach },
	{ TRUNK_PROTO_LACP,		trunk_lacp_attach },
	{ TRUNK_PROTO_NONE,		NULL }
};

void
trunkattach(int count)
{
	SLIST_INIT(&trunk_list);
	if_clone_attach(&trunk_cloner);
}

int
trunk_clone_create(struct if_clone *ifc, int unit)
{
	struct trunk_softc *tr;
	struct ifnet *ifp;
	int i, error = 0;

	if ((tr = malloc(sizeof *tr, M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	tr->tr_unit = unit;
	tr->tr_proto = TRUNK_PROTO_NONE;
	for (i = 0; trunk_protos[i].ti_proto != TRUNK_PROTO_NONE; i++) {
		if (trunk_protos[i].ti_proto == TRUNK_PROTO_DEFAULT) {
			tr->tr_proto = trunk_protos[i].ti_proto;
			if ((error = trunk_protos[i].ti_attach(tr)) != 0) {
				free(tr, M_DEVBUF, sizeof *tr);
				return (error);
			}
			break;
		}
	}
	SLIST_INIT(&tr->tr_ports);

	/* Initialise pseudo media types */
	ifmedia_init(&tr->tr_media, 0, trunk_media_change,
	    trunk_media_status);
	ifmedia_add(&tr->tr_media, IFM_ETHER | IFM_AUTO, 0, NULL);
	ifmedia_set(&tr->tr_media, IFM_ETHER | IFM_AUTO);

	ifp = &tr->tr_ac.ac_if;
	ifp->if_softc = tr;
	ifp->if_start = trunk_start;
	ifp->if_ioctl = trunk_ioctl;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	ifp->if_capabilities = trunk_capabilities(tr);

	IFQ_SET_MAXLEN(&ifp->if_snd, 1);

	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d",
	    ifc->ifc_name, unit);

	/*
	 * Attach as an ordinary ethernet device, children will be attached
	 * as special device IFT_IEEE8023ADLAG.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	/* Insert into the global list of trunks */
	SLIST_INSERT_HEAD(&trunk_list, tr, tr_entries);

	return (0);
}

int
trunk_clone_destroy(struct ifnet *ifp)
{
	struct trunk_softc *tr = (struct trunk_softc *)ifp->if_softc;
	struct trunk_port *tp;
	int error;

	/* Remove any multicast groups that we may have joined. */
	trunk_ether_purgemulti(tr);

	/* Shutdown and remove trunk ports, return on error */
	NET_LOCK();
	while ((tp = SLIST_FIRST(&tr->tr_ports)) != NULL) {
		if ((error = trunk_port_destroy(tp)) != 0) {
			NET_UNLOCK();
			return (error);
		}
	}
	NET_UNLOCK();

	ifmedia_delete_instance(&tr->tr_media, IFM_INST_ANY);
	ether_ifdetach(ifp);
	if_detach(ifp);

	SLIST_REMOVE(&trunk_list, tr, trunk_softc, tr_entries);
	free(tr, M_DEVBUF, sizeof *tr);

	return (0);
}

void
trunk_lladdr(struct arpcom *ac, u_int8_t *lladdr)
{
	struct ifnet *ifp = &ac->ac_if;
	struct sockaddr_dl *sdl;

	sdl = ifp->if_sadl;
	sdl->sdl_type = IFT_ETHER;
	sdl->sdl_alen = ETHER_ADDR_LEN;
	bcopy(lladdr, LLADDR(sdl), ETHER_ADDR_LEN);
	bcopy(lladdr, ac->ac_enaddr, ETHER_ADDR_LEN);
}

int
trunk_capabilities(struct trunk_softc *tr)
{
	struct trunk_port *tp;
	int cap = ~0, priv;

	/* Preserve private capabilities */
	priv = tr->tr_capabilities & IFCAP_TRUNK_MASK;

	/* Get capabilities from the trunk ports */
	SLIST_FOREACH(tp, &tr->tr_ports, tp_entries)
		cap &= tp->tp_capabilities;

	if (tr->tr_ifflags & IFF_DEBUG) {
		printf("%s: capabilities 0x%08x\n",
		    tr->tr_ifname, cap == ~0 ? priv : (cap | priv));
	}

	return (cap == ~0 ? priv : (cap | priv));
}

void
trunk_port_lladdr(struct trunk_port *tp, u_int8_t *lladdr)
{
	struct ifnet *ifp = tp->tp_if;

	/* Set the link layer address */
	trunk_lladdr((struct arpcom *)ifp, lladdr);

	/* Reset the port to update the lladdr */
	ifnewlladdr(ifp);
}

int
trunk_port_create(struct trunk_softc *tr, struct ifnet *ifp)
{
	struct trunk_softc *tr_ptr;
	struct trunk_port *tp;
	int error = 0;

	/* Limit the maximal number of trunk ports */
	if (tr->tr_count >= TRUNK_MAX_PORTS)
		return (ENOSPC);

	/* Check if port has already been associated to a trunk */
	if (trunk_port_get(NULL, ifp) != NULL)
		return (EBUSY);

	/* XXX Disallow non-ethernet interfaces (this should be any of 802) */
	if (ifp->if_type != IFT_ETHER)
		return (EPROTONOSUPPORT);

	/* Take MTU from the first member port */
	if (SLIST_EMPTY(&tr->tr_ports)) {
		if (tr->tr_ifflags & IFF_DEBUG)
			printf("%s: first port, setting trunk mtu %u\n",
			    tr->tr_ifname, ifp->if_mtu);
		tr->tr_ac.ac_if.if_mtu = ifp->if_mtu;
		tr->tr_ac.ac_if.if_hardmtu = ifp->if_mtu;
	} else if (tr->tr_ac.ac_if.if_mtu != ifp->if_mtu) {
		printf("%s: adding %s failed, MTU %u != %u\n", tr->tr_ifname,
		    ifp->if_xname, ifp->if_mtu, tr->tr_ac.ac_if.if_mtu);
		return (EINVAL);
	}

	if ((error = ifpromisc(ifp, 1)) != 0)
		return (error);

	if ((tp = malloc(sizeof *tp, M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	/* Check if port is a stacked trunk */
	SLIST_FOREACH(tr_ptr, &trunk_list, tr_entries) {
		if (ifp == &tr_ptr->tr_ac.ac_if) {
			tp->tp_flags |= TRUNK_PORT_STACK;
			if (trunk_port_checkstacking(tr_ptr) >=
			    TRUNK_MAX_STACKING) {
				free(tp, M_DEVBUF, sizeof *tp);
				return (E2BIG);
			}
		}
	}

	/* Change the interface type */
	tp->tp_iftype = ifp->if_type;
	ifp->if_type = IFT_IEEE8023ADLAG;

	tp->tp_ioctl = ifp->if_ioctl;
	ifp->if_ioctl = trunk_port_ioctl;

	tp->tp_output = ifp->if_output;
	ifp->if_output = trunk_port_output;

	tp->tp_if = ifp;
	tp->tp_trunk = tr;

	/* Save port link layer address */
	bcopy(((struct arpcom *)ifp)->ac_enaddr, tp->tp_lladdr, ETHER_ADDR_LEN);

	if (SLIST_EMPTY(&tr->tr_ports)) {
		tr->tr_primary = tp;
		tp->tp_flags |= TRUNK_PORT_MASTER;
		trunk_lladdr(&tr->tr_ac, tp->tp_lladdr);
	}

	/* Insert into the list of ports */
	SLIST_INSERT_HEAD(&tr->tr_ports, tp, tp_entries);
	tr->tr_count++;

	/* Update link layer address for this port */
	trunk_port_lladdr(tp,
	    ((struct arpcom *)(tr->tr_primary->tp_if))->ac_enaddr);

	/* Update trunk capabilities */
	tr->tr_capabilities = trunk_capabilities(tr);

	/* Add multicast addresses to this port */
	trunk_ether_cmdmulti(tp, SIOCADDMULTI);

	/* Register callback for physical link state changes */
	tp->lh_cookie = hook_establish(ifp->if_linkstatehooks, 1,
	    trunk_port_state, tp);

	/* Register callback if parent wants to unregister */
	tp->dh_cookie = hook_establish(ifp->if_detachhooks, 0,
	    trunk_port_ifdetach, tp);

	if (tr->tr_port_create != NULL)
		error = (*tr->tr_port_create)(tp);

	/* Change input handler of the physical interface. */
	if_ih_insert(ifp, trunk_input, tp);

	return (error);
}

int
trunk_port_checkstacking(struct trunk_softc *tr)
{
	struct trunk_softc *tr_ptr;
	struct trunk_port *tp;
	int m = 0;

	SLIST_FOREACH(tp, &tr->tr_ports, tp_entries) {
		if (tp->tp_flags & TRUNK_PORT_STACK) {
			tr_ptr = (struct trunk_softc *)tp->tp_if->if_softc;
			m = MAX(m, trunk_port_checkstacking(tr_ptr));
		}
	}

	return (m + 1);
}

int
trunk_port_destroy(struct trunk_port *tp)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;
	struct trunk_port *tp_ptr;
	struct ifnet *ifp = tp->tp_if;

	/* Restore previous input handler. */
	if_ih_remove(ifp, trunk_input, tp);

	/* Remove multicast addresses from this port */
	trunk_ether_cmdmulti(tp, SIOCDELMULTI);

	/* Port has to be down */
	if (ifp->if_flags & IFF_UP)
		if_down(ifp);

	ifpromisc(ifp, 0);

	if (tr->tr_port_destroy != NULL)
		(*tr->tr_port_destroy)(tp);

	/* Restore interface type. */
	ifp->if_type = tp->tp_iftype;

	ifp->if_ioctl = tp->tp_ioctl;
	ifp->if_output = tp->tp_output;

	hook_disestablish(ifp->if_linkstatehooks, tp->lh_cookie);
	hook_disestablish(ifp->if_detachhooks, tp->dh_cookie);

	/* Finally, remove the port from the trunk */
	SLIST_REMOVE(&tr->tr_ports, tp, trunk_port, tp_entries);
	tr->tr_count--;

	/* Update the primary interface */
	if (tp == tr->tr_primary) {
		u_int8_t lladdr[ETHER_ADDR_LEN];

		if ((tp_ptr = SLIST_FIRST(&tr->tr_ports)) == NULL) {
			bzero(&lladdr, ETHER_ADDR_LEN);
		} else {
			bcopy(((struct arpcom *)tp_ptr->tp_if)->ac_enaddr,
			    lladdr, ETHER_ADDR_LEN);
			tp_ptr->tp_flags = TRUNK_PORT_MASTER;
		}
		trunk_lladdr(&tr->tr_ac, lladdr);
		tr->tr_primary = tp_ptr;

		/* Update link layer address for each port */
		SLIST_FOREACH(tp_ptr, &tr->tr_ports, tp_entries)
			trunk_port_lladdr(tp_ptr, lladdr);
	}

	/* Reset the port lladdr */
	trunk_port_lladdr(tp, tp->tp_lladdr);

	free(tp, M_DEVBUF, sizeof *tp);

	/* Update trunk capabilities */
	tr->tr_capabilities = trunk_capabilities(tr);

	return (0);
}

int
trunk_port_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct trunk_reqport *rp = (struct trunk_reqport *)data;
	struct trunk_softc *tr;
	struct trunk_port *tp = NULL;
	int error = 0;

	/* Should be checked by the caller */
	if (ifp->if_type != IFT_IEEE8023ADLAG ||
	    (tp = trunk_port_get(NULL, ifp)) == NULL ||
	    (tr = (struct trunk_softc *)tp->tp_trunk) == NULL) {
		error = EINVAL;
		goto fallback;
	}

	switch (cmd) {
	case SIOCGTRUNKPORT:
		if (rp->rp_portname[0] == '\0' ||
		    ifunit(rp->rp_portname) != ifp) {
			error = EINVAL;
			break;
		}

		/* Search in all trunks if the global flag is set */
		if ((tp = trunk_port_get(rp->rp_flags & TRUNK_PORT_GLOBAL ?
		    NULL : tr, ifp)) == NULL) {
			error = ENOENT;
			break;
		}

		trunk_port2req(tp, rp);
		break;
	case SIOCSIFMTU:
		/* Do not allow the MTU to be changed once joined */
		error = EINVAL;
		break;
	default:
		error = ENOTTY;
		goto fallback;
	}

	return (error);

 fallback:
	if (tp != NULL)
		error = (*tp->tp_ioctl)(ifp, cmd, data);

	return (error);
}

int
trunk_port_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	/* restrict transmission on trunk members to bpf only */
	if (ifp->if_type == IFT_IEEE8023ADLAG &&
	    (m_tag_find(m, PACKET_TAG_DLT, NULL) == NULL)) {
		m_freem(m);
		return (EBUSY);
	}

	return (ether_output(ifp, m, dst, rt));
}

void
trunk_port_ifdetach(void *arg)
{
	struct trunk_port *tp = (struct trunk_port *)arg;

	trunk_port_destroy(tp);
}

struct trunk_port *
trunk_port_get(struct trunk_softc *tr, struct ifnet *ifp)
{
	struct trunk_port *tp;
	struct trunk_softc *tr_ptr;

	if (tr != NULL) {
		/* Search port in specified trunk */
		SLIST_FOREACH(tp, &tr->tr_ports, tp_entries) {
			if (tp->tp_if == ifp)
				return (tp);
		}
	} else {
		/* Search all trunks for the selected port */
		SLIST_FOREACH(tr_ptr, &trunk_list, tr_entries) {
			SLIST_FOREACH(tp, &tr_ptr->tr_ports, tp_entries) {
				if (tp->tp_if == ifp)
					return (tp);
			}
		}
	}

	return (NULL);
}

void
trunk_port2req(struct trunk_port *tp, struct trunk_reqport *rp)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;

	strlcpy(rp->rp_ifname, tr->tr_ifname, sizeof(rp->rp_ifname));
	strlcpy(rp->rp_portname, tp->tp_if->if_xname, sizeof(rp->rp_portname));
	rp->rp_prio = tp->tp_prio;
	if (tr->tr_portreq != NULL)
		(*tr->tr_portreq)(tp, (caddr_t)&rp->rp_psc);

	/* Add protocol specific flags */
	switch (tr->tr_proto) {
	case TRUNK_PROTO_FAILOVER:
		rp->rp_flags = tp->tp_flags;
		if (tp == trunk_link_active(tr, tr->tr_primary))
			rp->rp_flags |= TRUNK_PORT_ACTIVE;
		break;

	case TRUNK_PROTO_ROUNDROBIN:
	case TRUNK_PROTO_LOADBALANCE:
	case TRUNK_PROTO_BROADCAST:
		rp->rp_flags = tp->tp_flags;
		if (TRUNK_PORTACTIVE(tp))
			rp->rp_flags |= TRUNK_PORT_ACTIVE;
		break;

	case TRUNK_PROTO_LACP:
		/* LACP has a different definition of active */
		rp->rp_flags = lacp_port_status(tp);
		break;
	default:
		break;
	}
}

int
trunk_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct trunk_softc *tr = (struct trunk_softc *)ifp->if_softc;
	struct trunk_reqall *ra = (struct trunk_reqall *)data;
	struct trunk_reqport *rp = (struct trunk_reqport *)data, rpbuf;
	struct ifreq *ifr = (struct ifreq *)data;
	struct trunk_port *tp;
	struct ifnet *tpif;
	int i, error = 0;

	bzero(&rpbuf, sizeof(rpbuf));

	switch (cmd) {
	case SIOCGTRUNK:
		ra->ra_proto = tr->tr_proto;
		if (tr->tr_req != NULL)
			(*tr->tr_req)(tr, (caddr_t)&ra->ra_psc);
		ra->ra_ports = i = 0;
		tp = SLIST_FIRST(&tr->tr_ports);
		while (tp && ra->ra_size >=
		    i + sizeof(struct trunk_reqport)) {
			trunk_port2req(tp, &rpbuf);
			error = copyout(&rpbuf, (caddr_t)ra->ra_port + i,
			    sizeof(struct trunk_reqport));
			if (error)
				break;
			i += sizeof(struct trunk_reqport);
			ra->ra_ports++;
			tp = SLIST_NEXT(tp, tp_entries);
		}
		break;
	case SIOCSTRUNK:
		if ((error = suser(curproc, 0)) != 0) {
			error = EPERM;
			break;
		}
		if (ra->ra_proto >= TRUNK_PROTO_MAX) {
			error = EPROTONOSUPPORT;
			break;
		}
		/*
		 * Serialize modifications to the trunk and trunk
		 * ports via the ifih SRP: detaching trunk_input
		 * from the trunk port will require all currently
		 * running trunk_input's on this port to finish
		 * granting us an exclusive access to it.
		 */
		SLIST_FOREACH(tp, &tr->tr_ports, tp_entries)
			if_ih_remove(tp->tp_if, trunk_input, tp);
		if (tr->tr_proto != TRUNK_PROTO_NONE)
			error = tr->tr_detach(tr);
		if (error != 0)
			break;
		for (i = 0; i < nitems(trunk_protos); i++) {
			if (trunk_protos[i].ti_proto == ra->ra_proto) {
				if (tr->tr_ifflags & IFF_DEBUG)
					printf("%s: using proto %u\n",
					    tr->tr_ifname,
					    trunk_protos[i].ti_proto);
				tr->tr_proto = trunk_protos[i].ti_proto;
				if (tr->tr_proto != TRUNK_PROTO_NONE)
					error = trunk_protos[i].ti_attach(tr);
				SLIST_FOREACH(tp, &tr->tr_ports, tp_entries)
					if_ih_insert(tp->tp_if,
					    trunk_input, tp);
				/* Update trunk capabilities */
				tr->tr_capabilities = trunk_capabilities(tr);
				goto out;
			}
		}
		error = EPROTONOSUPPORT;
		break;
	case SIOCGTRUNKPORT:
		if (rp->rp_portname[0] == '\0' ||
		    (tpif = ifunit(rp->rp_portname)) == NULL) {
			error = EINVAL;
			break;
		}

		/* Search in all trunks if the global flag is set */
		if ((tp = trunk_port_get(rp->rp_flags & TRUNK_PORT_GLOBAL ?
		    NULL : tr, tpif)) == NULL) {
			error = ENOENT;
			break;
		}

		trunk_port2req(tp, rp);
		break;
	case SIOCSTRUNKPORT:
		if ((error = suser(curproc, 0)) != 0) {
			error = EPERM;
			break;
		}
		if (rp->rp_portname[0] == '\0' ||
		    (tpif = ifunit(rp->rp_portname)) == NULL) {
			error = EINVAL;
			break;
		}
		error = trunk_port_create(tr, tpif);
		break;
	case SIOCSTRUNKDELPORT:
		if ((error = suser(curproc, 0)) != 0) {
			error = EPERM;
			break;
		}
		if (rp->rp_portname[0] == '\0' ||
		    (tpif = ifunit(rp->rp_portname)) == NULL) {
			error = EINVAL;
			break;
		}

		/* Search in all trunks if the global flag is set */
		if ((tp = trunk_port_get(rp->rp_flags & TRUNK_PORT_GLOBAL ?
		    NULL : tr, tpif)) == NULL) {
			error = ENOENT;
			break;
		}

		error = trunk_port_destroy(tp);
		break;
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		error = ENETRESET;
		break;
	case SIOCADDMULTI:
		error = trunk_ether_addmulti(tr, ifr);
		break;
	case SIOCDELMULTI:
		error = trunk_ether_delmulti(tr, ifr);
		break;
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &tr->tr_media, cmd);
		break;
	case SIOCSIFLLADDR:
		/* Update the port lladdrs as well */
		SLIST_FOREACH(tp, &tr->tr_ports, tp_entries)
			trunk_port_lladdr(tp, ifr->ifr_addr.sa_data);
		error = ENETRESET;
		break;
	default:
		error = ether_ioctl(ifp, &tr->tr_ac, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0)
				trunk_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				trunk_stop(ifp);
		}
		error = 0;
	}

 out:
	return (error);
}

int
trunk_ether_addmulti(struct trunk_softc *tr, struct ifreq *ifr)
{
	struct trunk_mc *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	/* Ignore ENETRESET error code */
	if ((error = ether_addmulti(ifr, &tr->tr_ac)) != ENETRESET)
		return (error);

	if ((mc = malloc(sizeof(*mc), M_DEVBUF, M_NOWAIT)) == NULL) {
		error = ENOMEM;
		goto failed;
	}

	ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &tr->tr_ac, mc->mc_enm);
	bcopy(&ifr->ifr_addr, &mc->mc_addr, ifr->ifr_addr.sa_len);
	SLIST_INSERT_HEAD(&tr->tr_mc_head, mc, mc_entries);

	if ((error = trunk_ioctl_allports(tr, SIOCADDMULTI,
	    (caddr_t)ifr)) != 0) {
		trunk_ether_delmulti(tr, ifr);
		return (error);
	}

	return (error);

 failed:
	ether_delmulti(ifr, &tr->tr_ac);

	return (error);
}

int
trunk_ether_delmulti(struct trunk_softc *tr, struct ifreq *ifr)
{
	struct ether_multi *enm;
	struct trunk_mc *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	if ((error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi)) != 0)
		return (error);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &tr->tr_ac, enm);
	if (enm == NULL)
		return (EINVAL);

	SLIST_FOREACH(mc, &tr->tr_mc_head, mc_entries)
		if (mc->mc_enm == enm)
			break;

	/* We won't delete entries we didn't add */
	if (mc == NULL)
		return (EINVAL);

	if ((error = ether_delmulti(ifr, &tr->tr_ac)) != ENETRESET)
		return (error);

	/* We no longer use this multicast address.  Tell parent so. */
	error = trunk_ioctl_allports(tr, SIOCDELMULTI, (caddr_t)ifr);
	if (error == 0) {
		SLIST_REMOVE(&tr->tr_mc_head, mc, trunk_mc, mc_entries);
		free(mc, M_DEVBUF, sizeof(*mc));
	} else {
		/* XXX At least one port failed to remove the address */
		if (tr->tr_ifflags & IFF_DEBUG) {
			printf("%s: failed to remove multicast address "
			    "on all ports (%d)\n", tr->tr_ifname, error);
		}
		(void)ether_addmulti(ifr, &tr->tr_ac);
	}

	return (0);
}

void
trunk_ether_purgemulti(struct trunk_softc *tr)
{
	struct trunk_mc *mc;
	struct trunk_ifreq ifs;
	struct ifreq *ifr = &ifs.ifreq.ifreq;

	while ((mc = SLIST_FIRST(&tr->tr_mc_head)) != NULL) {
		bcopy(&mc->mc_addr, &ifr->ifr_addr, mc->mc_addr.ss_len);

		/* Try to remove multicast address on all ports */
		trunk_ioctl_allports(tr, SIOCDELMULTI, (caddr_t)ifr);

		SLIST_REMOVE(&tr->tr_mc_head, mc, trunk_mc, mc_entries);
		free(mc, M_DEVBUF, sizeof(*mc));
	}
}

int
trunk_ether_cmdmulti(struct trunk_port *tp, u_long cmd)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;
	struct trunk_mc *mc;
	struct trunk_ifreq ifs;
	struct ifreq *ifr = &ifs.ifreq.ifreq;
	int ret, error = 0;

	bcopy(tp->tp_ifname, ifr->ifr_name, IFNAMSIZ);
	SLIST_FOREACH(mc, &tr->tr_mc_head, mc_entries) {
		bcopy(&mc->mc_addr, &ifr->ifr_addr, mc->mc_addr.ss_len);

		if ((ret = tp->tp_ioctl(tp->tp_if, cmd, (caddr_t)ifr)) != 0) {
			if (tr->tr_ifflags & IFF_DEBUG) {
				printf("%s: ioctl %lu failed on %s: %d\n",
				    tr->tr_ifname, cmd, tp->tp_ifname, ret);
			}
			/* Store last known error and continue */
			error = ret;
		}
	}

	return (error);
}

int
trunk_ioctl_allports(struct trunk_softc *tr, u_long cmd, caddr_t data)
{
	struct ifreq *ifr = (struct ifreq *)data;
	struct trunk_port *tp;
	int ret, error = 0;

	SLIST_FOREACH(tp, &tr->tr_ports, tp_entries) {
		bcopy(tp->tp_ifname, ifr->ifr_name, IFNAMSIZ);
		if ((ret = tp->tp_ioctl(tp->tp_if, cmd, data)) != 0) {
			if (tr->tr_ifflags & IFF_DEBUG) {
				printf("%s: ioctl %lu failed on %s: %d\n",
				    tr->tr_ifname, cmd, tp->tp_ifname, ret);
			}
			/* Store last known error and continue */
			error = ret;
		}
	}

	return (error);
}

void
trunk_start(struct ifnet *ifp)
{
	struct trunk_softc *tr = (struct trunk_softc *)ifp->if_softc;
	struct mbuf *m;
	int error;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		if (tr->tr_proto != TRUNK_PROTO_NONE && tr->tr_count) {
			error = (*tr->tr_start)(tr, m);
			if (error != 0)
				ifp->if_oerrors++;
		} else {
			m_freem(m);
			if (tr->tr_proto != TRUNK_PROTO_NONE)
				ifp->if_oerrors++;
		}
	}
}

u_int32_t
trunk_hashmbuf(struct mbuf *m, SIPHASH_KEY *key)
{
	u_int16_t etype, ether_vtag;
	u_int32_t p = 0;
	u_int16_t *vlan, vlanbuf[2];
	int off;
	struct ether_header *eh;
	struct ip *ip, ipbuf;
#ifdef INET6
	u_int32_t flow;
	struct ip6_hdr *ip6, ip6buf;
#endif
	SIPHASH_CTX ctx;

	if (m->m_pkthdr.ph_flowid & M_FLOWID_VALID)
		return (m->m_pkthdr.ph_flowid & M_FLOWID_MASK);

	SipHash24_Init(&ctx, key);
	off = sizeof(*eh);
	if (m->m_len < off)
		goto done;
	eh = mtod(m, struct ether_header *);
	etype = ntohs(eh->ether_type);
	SipHash24_Update(&ctx, &eh->ether_shost, ETHER_ADDR_LEN);
	SipHash24_Update(&ctx, &eh->ether_dhost, ETHER_ADDR_LEN);

	/* Special handling for encapsulating VLAN frames */
	if (m->m_flags & M_VLANTAG) {
		ether_vtag = EVL_VLANOFTAG(m->m_pkthdr.ether_vtag);
		SipHash24_Update(&ctx, &ether_vtag, sizeof(ether_vtag));
	} else if (etype == ETHERTYPE_VLAN) {
		if ((vlan = (u_int16_t *)
		    trunk_gethdr(m, off, EVL_ENCAPLEN, &vlanbuf)) == NULL)
			return (p);
		ether_vtag = EVL_VLANOFTAG(*vlan);
		SipHash24_Update(&ctx, &ether_vtag, sizeof(ether_vtag));
		etype = ntohs(vlan[1]);
		off += EVL_ENCAPLEN;
	}

	switch (etype) {
	case ETHERTYPE_IP:
		if ((ip = (struct ip *)
		    trunk_gethdr(m, off, sizeof(*ip), &ipbuf)) == NULL)
			return (p);
		SipHash24_Update(&ctx, &ip->ip_src, sizeof(struct in_addr));
		SipHash24_Update(&ctx, &ip->ip_dst, sizeof(struct in_addr));
		break;
#ifdef INET6
	case ETHERTYPE_IPV6:
		if ((ip6 = (struct ip6_hdr *)
		    trunk_gethdr(m, off, sizeof(*ip6), &ip6buf)) == NULL)
			return (p);
		SipHash24_Update(&ctx, &ip6->ip6_src, sizeof(struct in6_addr));
		SipHash24_Update(&ctx, &ip6->ip6_dst, sizeof(struct in6_addr));
		flow = ip6->ip6_flow & IPV6_FLOWLABEL_MASK;
		SipHash24_Update(&ctx, &flow, sizeof(flow)); /* IPv6 flow label */
		break;
#endif
	}

done:
	return SipHash24_End(&ctx);
}

void
trunk_init(struct ifnet *ifp)
{
	struct trunk_softc *tr = (struct trunk_softc *)ifp->if_softc;

	ifp->if_flags |= IFF_RUNNING;

	if (tr->tr_init != NULL)
		(*tr->tr_init)(tr);
}

void
trunk_stop(struct ifnet *ifp)
{
	struct trunk_softc *tr = (struct trunk_softc *)ifp->if_softc;

	ifp->if_flags &= ~IFF_RUNNING;

	if (tr->tr_stop != NULL)
		(*tr->tr_stop)(tr);
}

int
trunk_input(struct ifnet *ifp, struct mbuf *m, void *cookie)
{
	struct trunk_softc *tr;
	struct trunk_port *tp;
	struct ifnet *trifp = NULL;
	struct ether_header *eh;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();

	eh = mtod(m, struct ether_header *);
	if (ETHER_IS_MULTICAST(eh->ether_dhost))
		ifp->if_imcasts++;

	/* Should be checked by the caller */
	if (ifp->if_type != IFT_IEEE8023ADLAG)
		goto bad;

	tp = (struct trunk_port *)cookie;
	if ((tr = (struct trunk_softc *)tp->tp_trunk) == NULL)
		goto bad;

	trifp = &tr->tr_ac.ac_if;
	if (tr->tr_proto == TRUNK_PROTO_NONE)
		goto bad;

	if ((*tr->tr_input)(tr, tp, m)) {
		/*
		 * We stop here if the packet has been consumed
		 * by the protocol routine.
		 */
		return (1);
	}

	if ((trifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		goto bad;

	/*
	 * Drop promiscuously received packets if we are not in
	 * promiscuous mode.
	 */
	if (!ETHER_IS_MULTICAST(eh->ether_dhost) &&
	    (ifp->if_flags & IFF_PROMISC) &&
	    (trifp->if_flags & IFF_PROMISC) == 0) {
		if (bcmp(&tr->tr_ac.ac_enaddr, eh->ether_dhost,
		    ETHER_ADDR_LEN)) {
			m_freem(m);
			return (1);
		}
	}


	ml_enqueue(&ml, m);
	if_input(trifp, &ml);
	return (1);

 bad:
	if (trifp != NULL)
		trifp->if_ierrors++;
	m_freem(m);
	return (1);
}

int
trunk_media_change(struct ifnet *ifp)
{
	struct trunk_softc *tr = (struct trunk_softc *)ifp->if_softc;

	if (tr->tr_ifflags & IFF_DEBUG)
		printf("%s\n", __func__);

	/* Ignore */
	return (0);
}

void
trunk_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct trunk_softc *tr = (struct trunk_softc *)ifp->if_softc;
	struct trunk_port *tp;

	imr->ifm_status = IFM_AVALID;
	imr->ifm_active = IFM_ETHER | IFM_AUTO;

	SLIST_FOREACH(tp, &tr->tr_ports, tp_entries) {
		if (TRUNK_PORTACTIVE(tp))
			imr->ifm_status |= IFM_ACTIVE;
	}
}

void
trunk_port_state(void *arg)
{
	struct trunk_port *tp = (struct trunk_port *)arg;
	struct trunk_softc *tr = NULL;

	if (tp != NULL)
		tr = (struct trunk_softc *)tp->tp_trunk;
	if (tr == NULL)
		return;
	if (tr->tr_linkstate != NULL)
		(*tr->tr_linkstate)(tp);
	trunk_link_active(tr, tp);
}

struct trunk_port *
trunk_link_active(struct trunk_softc *tr, struct trunk_port *tp)
{
	struct trunk_port *tp_next, *rval = NULL;
	int new_link = LINK_STATE_DOWN;

	/*
	 * Search a port which reports an active link state.
	 */

	if (tp == NULL)
		goto search;
	if (TRUNK_PORTACTIVE(tp)) {
		rval = tp;
		goto found;
	}
	if ((tp_next = SLIST_NEXT(tp, tp_entries)) != NULL &&
	    TRUNK_PORTACTIVE(tp_next)) {
		rval = tp_next;
		goto found;
	}

 search:
	SLIST_FOREACH(tp_next, &tr->tr_ports, tp_entries) {
		if (TRUNK_PORTACTIVE(tp_next)) {
			rval = tp_next;
			goto found;
		}
	}

 found:
	if (rval != NULL) {
		/*
		 * The IEEE 802.1D standard assumes that a trunk with
		 * multiple ports is always full duplex. This is valid
		 * for load sharing trunks and if at least two links
		 * are active. Unfortunately, checking the latter would
		 * be too expensive at this point.
		 */
		if ((tr->tr_capabilities & IFCAP_TRUNK_FULLDUPLEX) &&
		    (tr->tr_count > 1))
			new_link = LINK_STATE_FULL_DUPLEX;
		else
			new_link = rval->tp_link_state;
	}

	if (tr->tr_ac.ac_if.if_link_state != new_link) {
		tr->tr_ac.ac_if.if_link_state = new_link;
		if_link_state_change(&tr->tr_ac.ac_if);
	}

	return (rval);
}

const void *
trunk_gethdr(struct mbuf *m, u_int off, u_int len, void *buf)
{
	if (m->m_pkthdr.len < (off + len))
		return (NULL);
	else if (m->m_len < (off + len)) {
		m_copydata(m, off, len, buf);
		return (buf);
	}
	return (mtod(m, caddr_t) + off);
}

/*
 * Simple round robin trunking
 */

int
trunk_rr_attach(struct trunk_softc *tr)
{
	struct trunk_port *tp;

	tr->tr_detach = trunk_rr_detach;
	tr->tr_start = trunk_rr_start;
	tr->tr_input = trunk_rr_input;
	tr->tr_init = NULL;
	tr->tr_stop = NULL;
	tr->tr_linkstate = NULL;
	tr->tr_port_create = NULL;
	tr->tr_port_destroy = trunk_rr_port_destroy;
	tr->tr_capabilities = IFCAP_TRUNK_FULLDUPLEX;
	tr->tr_req = NULL;
	tr->tr_portreq = NULL;

	tp = SLIST_FIRST(&tr->tr_ports);
	tr->tr_psc = (caddr_t)tp;

	return (0);
}

int
trunk_rr_detach(struct trunk_softc *tr)
{
	tr->tr_psc = NULL;
	return (0);
}

void
trunk_rr_port_destroy(struct trunk_port *tp)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;

	if (tp == (struct trunk_port *)tr->tr_psc)
		tr->tr_psc = NULL;
}

int
trunk_rr_start(struct trunk_softc *tr, struct mbuf *m)
{
	struct trunk_port *tp = (struct trunk_port *)tr->tr_psc, *tp_next;
	int error = 0;

	if (tp == NULL && (tp = trunk_link_active(tr, NULL)) == NULL) {
		m_freem(m);
		return (ENOENT);
	}

	if ((error = if_enqueue(tp->tp_if, m)) != 0)
		return (error);

	/* Get next active port */
	tp_next = trunk_link_active(tr, SLIST_NEXT(tp, tp_entries));
	tr->tr_psc = (caddr_t)tp_next;

	return (0);
}

int
trunk_rr_input(struct trunk_softc *tr, struct trunk_port *tp, struct mbuf *m)
{
	/* Just pass in the packet to our trunk device */
	return (0);
}

/*
 * Active failover
 */

int
trunk_fail_attach(struct trunk_softc *tr)
{
	tr->tr_detach = trunk_fail_detach;
	tr->tr_start = trunk_fail_start;
	tr->tr_input = trunk_fail_input;
	tr->tr_init = NULL;
	tr->tr_stop = NULL;
	tr->tr_port_create = trunk_fail_port_create;
	tr->tr_port_destroy = trunk_fail_port_destroy;
	tr->tr_linkstate = trunk_fail_linkstate;
	tr->tr_req = NULL;
	tr->tr_portreq = NULL;

	/* Get primary or the next active port */
	tr->tr_psc = (caddr_t)trunk_link_active(tr, tr->tr_primary);

	return (0);
}

int
trunk_fail_detach(struct trunk_softc *tr)
{
	tr->tr_psc = NULL;
	return (0);
}

int
trunk_fail_port_create(struct trunk_port *tp)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;

	/* Get primary or the next active port */
	tr->tr_psc = (caddr_t)trunk_link_active(tr, tr->tr_primary);
	return (0);
}

void
trunk_fail_port_destroy(struct trunk_port *tp)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;
	struct trunk_port *tp_next;

	if ((caddr_t)tp == tr->tr_psc) {
		/* Get the next active port */
		tp_next = trunk_link_active(tr, SLIST_NEXT(tp, tp_entries));
		if (tp_next == tp)
			tr->tr_psc = NULL;
		else
			tr->tr_psc = (caddr_t)tp_next;
	} else {
		/* Get primary or the next active port */
		tr->tr_psc = (caddr_t)trunk_link_active(tr, tr->tr_primary);
	}
}

int
trunk_fail_start(struct trunk_softc *tr, struct mbuf *m)
{
	struct trunk_port *tp = (struct trunk_port *)tr->tr_psc;

	/* Use the master port if active or the next available port */
	if (tp == NULL) {
		m_freem(m);
		return (ENOENT);
	}

	return (if_enqueue(tp->tp_if, m));
}

int
trunk_fail_input(struct trunk_softc *tr, struct trunk_port *tp, struct mbuf *m)
{
	if ((caddr_t)tp == tr->tr_psc)
		return (0);
	m_freem(m);
	return (-1);
}

void
trunk_fail_linkstate(struct trunk_port *tp)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;

	tr->tr_psc = (caddr_t)trunk_link_active(tr, tr->tr_primary);
}

/*
 * Loadbalancing
 */

int
trunk_lb_attach(struct trunk_softc *tr)
{
	struct trunk_lb *lb;

	if ((lb = malloc(sizeof(*lb), M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	tr->tr_detach = trunk_lb_detach;
	tr->tr_start = trunk_lb_start;
	tr->tr_input = trunk_lb_input;
	tr->tr_port_create = trunk_lb_port_create;
	tr->tr_port_destroy = trunk_lb_port_destroy;
	tr->tr_linkstate = NULL;
	tr->tr_capabilities = IFCAP_TRUNK_FULLDUPLEX;
	tr->tr_req = NULL;
	tr->tr_portreq = NULL;
	tr->tr_init = NULL;
	tr->tr_stop = NULL;

	arc4random_buf(&lb->lb_key, sizeof(lb->lb_key));
	tr->tr_psc = (caddr_t)lb;

	return (0);
}

int
trunk_lb_detach(struct trunk_softc *tr)
{
	struct trunk_lb *lb = (struct trunk_lb *)tr->tr_psc;

	free(lb, M_DEVBUF, sizeof *lb);
	return (0);
}

int
trunk_lb_porttable(struct trunk_softc *tr, struct trunk_port *tp)
{
	struct trunk_lb *lb = (struct trunk_lb *)tr->tr_psc;
	struct trunk_port *tp_next;
	int i = 0;

	bzero(&lb->lb_ports, sizeof(lb->lb_ports));
	SLIST_FOREACH(tp_next, &tr->tr_ports, tp_entries) {
		if (tp_next == tp)
			continue;
		if (i >= TRUNK_MAX_PORTS)
			return (EINVAL);
		if (tr->tr_ifflags & IFF_DEBUG)
			printf("%s: port %s at index %d\n",
			    tr->tr_ifname, tp_next->tp_ifname, i);
		lb->lb_ports[i++] = tp_next;
	}

	return (0);
}

int
trunk_lb_port_create(struct trunk_port *tp)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;
	return (trunk_lb_porttable(tr, NULL));
}

void
trunk_lb_port_destroy(struct trunk_port *tp)
{
	struct trunk_softc *tr = (struct trunk_softc *)tp->tp_trunk;
	trunk_lb_porttable(tr, tp);
}

int
trunk_lb_start(struct trunk_softc *tr, struct mbuf *m)
{
	struct trunk_lb *lb = (struct trunk_lb *)tr->tr_psc;
	struct trunk_port *tp = NULL;
	u_int32_t p = 0;

	p = trunk_hashmbuf(m, &lb->lb_key);
	p %= tr->tr_count;
	tp = lb->lb_ports[p];

	/*
	 * Check the port's link state. This will return the next active
	 * port if the link is down or the port is NULL.
	 */
	if ((tp = trunk_link_active(tr, tp)) == NULL) {
		m_freem(m);
		return (ENOENT);
	}

	return (if_enqueue(tp->tp_if, m));
}

int
trunk_lb_input(struct trunk_softc *tr, struct trunk_port *tp, struct mbuf *m)
{
	/* Just pass in the packet to our trunk device */
	return (0);
}

/*
 * Broadcast mode
 */

int
trunk_bcast_attach(struct trunk_softc *tr)
{
	tr->tr_detach = trunk_bcast_detach;
	tr->tr_start = trunk_bcast_start;
	tr->tr_input = trunk_bcast_input;
	tr->tr_init = NULL;
	tr->tr_stop = NULL;
	tr->tr_port_create = NULL;
	tr->tr_port_destroy = NULL;
	tr->tr_linkstate = NULL;
	tr->tr_req = NULL;
	tr->tr_portreq = NULL;

	return (0);
}

int
trunk_bcast_detach(struct trunk_softc *tr)
{
	return (0);
}

int
trunk_bcast_start(struct trunk_softc *tr, struct mbuf *m0)
{
	int			 active_ports = 0;
	int			 errors = 0;
	struct trunk_port	*tp, *last = NULL;
	struct mbuf		*m;

	SLIST_FOREACH(tp, &tr->tr_ports, tp_entries) {
		if (!TRUNK_PORTACTIVE(tp))
			continue;

		active_ports++;

		if (last != NULL) {
			m = m_copym(m0, 0, M_COPYALL, M_DONTWAIT);
			if (m == NULL) {
				errors++;
				break;
			}

			if (if_enqueue(last->tp_if, m) != 0)
				errors++;
		}
		last = tp;
	}
	if (last == NULL) {
		m_freem(m0);
		return (ENOENT);
	}

	if (if_enqueue(last->tp_if, m0) != 0)
		errors++;

	if (errors == active_ports)
		return (ENOBUFS);

	return (0);
}

int
trunk_bcast_input(struct trunk_softc *tr, struct trunk_port *tp, struct mbuf *m)
{
	return (0);
}

/*
 * 802.3ad LACP
 */

int
trunk_lacp_attach(struct trunk_softc *tr)
{
	struct trunk_port *tp;
	int error;

	tr->tr_detach = trunk_lacp_detach;
	tr->tr_port_create = lacp_port_create;
	tr->tr_port_destroy = lacp_port_destroy;
	tr->tr_linkstate = lacp_linkstate;
	tr->tr_start = trunk_lacp_start;
	tr->tr_input = trunk_lacp_input;
	tr->tr_init = lacp_init;
	tr->tr_stop = lacp_stop;
	tr->tr_req = lacp_req;
	tr->tr_portreq = lacp_portreq;

	error = lacp_attach(tr);
	if (error)
		return (error);

	SLIST_FOREACH(tp, &tr->tr_ports, tp_entries)
		lacp_port_create(tp);

	return (error);
}

int
trunk_lacp_detach(struct trunk_softc *tr)
{
	struct trunk_port *tp;
	int error;

	SLIST_FOREACH(tp, &tr->tr_ports, tp_entries)
		lacp_port_destroy(tp);

	/* unlocking is safe here */
	error = lacp_detach(tr);

	return (error);
}

int
trunk_lacp_start(struct trunk_softc *tr, struct mbuf *m)
{
	struct trunk_port *tp;

	tp = lacp_select_tx_port(tr, m);
	if (tp == NULL) {
		m_freem(m);
		return (EBUSY);
	}

	return (if_enqueue(tp->tp_if, m));
}

int
trunk_lacp_input(struct trunk_softc *tr, struct trunk_port *tp, struct mbuf *m)
{
	return (lacp_input(tp, m));
}
@


1.133
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.132 2017/05/28 15:03:53 mpi Exp $	*/
a1493 1
	int			 ret;
a1505 1
				ret = ENOBUFS;
d1510 1
a1510 2
			ret = if_enqueue(last->tp_if, m);
			if (ret != 0)
d1520 1
a1520 2
	ret = if_enqueue(last->tp_if, m0);
	if (ret != 0)
d1524 1
a1524 1
		return (ret);
@


1.132
log
@Add missing NET_UNLOCK() in error path.

Spotted by sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.131 2017/05/28 14:26:38 mpi Exp $	*/
d213 1
a213 1
	int s, error;
d219 1
a219 1
	NET_LOCK(s);
d222 1
a222 1
			NET_UNLOCK(s);
d226 1
a226 1
	NET_UNLOCK(s);
@


1.131
log
@trunk_port_destroy() needs the NET_LOCK().

It brings the interface down and restore the original lladdr.

Found by Hrvoje Popovski
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.130 2017/05/28 09:38:32 mpi Exp $	*/
d221 2
a222 1
		if ((error = trunk_port_destroy(tp)) != 0)
d224 1
@


1.130
log
@Remove useless splnet()/splx() dances.

Data structures modified in the ioctl path are protected by the NET_LOCK().

ok sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.129 2017/01/22 10:17:39 dlg Exp $	*/
d213 1
a213 1
	int error;
d219 1
d224 1
@


1.129
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.128 2016/09/16 09:51:21 mikeb Exp $	*/
d213 1
a213 1
	int error, s;
a217 2
	s = splnet();

d220 1
a220 2
		if ((error = trunk_port_destroy(tp)) != 0) {
			splx(s);
a221 1
		}
a230 2
	splx(s);

d471 1
a471 3
	int s, error = 0;

	s = splnet();
a506 1
	splx(s);
a509 2
	splx(s);

d608 1
a608 3
	int s, i, error = 0;

	s = splnet();
a757 1
	splx(s);
a1002 3
	int s;

	s = splnet();
a1007 2

	splx(s);
a1013 3
	int s;

	s = splnet();
a1018 2

	splx(s);
@


1.128
log
@Reconfigure interface capabilities after switching trunkproto; ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.127 2016/04/13 11:41:15 mpi Exp $	*/
d937 1
a937 3
			if (error == 0)
				ifp->if_opackets++;
			else
@


1.127
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.126 2015/12/31 14:18:34 sthen Exp $	*/
d666 1
a666 2
		for (i = 0; i < (sizeof(trunk_protos) /
		    sizeof(trunk_protos[0])); i++) {
d678 2
@


1.126
log
@Move tr_port_destroy down; fixes 'lacp_compose_key protection fault trap'
when removing a port from a lacp trunk. Part of a larger diff from mpi,
as suggested by mikeb. ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.125 2015/11/21 11:02:23 dlg Exp $	*/
a190 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.125
log
@dont check IFF_OACTIVE to see if the port is busy.

dont check if its busy at all, actually.

fine with reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.123 2015/11/12 10:07:14 mpi Exp $	*/
a416 3
	if (tr->tr_port_destroy != NULL)
		(*tr->tr_port_destroy)(tp);

d425 3
@


1.124
log
@dont play with IFF_OACTIVE needlessly.

only a driver sets or clears it, and trunk never sets it. therefore it
never needs to clear it.
@
text
@a297 4
	/* New trunk port has to be in an idle state */
	if (ifp->if_flags & IFF_OACTIVE)
		return (EBUSY);

@


1.123
log
@Prefix flowid with ph_ and print it in m_print().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.122 2015/10/25 12:05:40 mpi Exp $	*/
a1027 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1043 1
a1043 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.122
log
@arp_ifinit() is no longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.121 2015/10/08 13:58:07 mikeb Exp $	*/
d968 2
a969 2
	if (m->m_pkthdr.flowid & M_FLOWID_VALID)
		return (m->m_pkthdr.flowid & M_FLOWID_MASK);
@


1.121
log
@Make sure that when trunk_port_ioctl is called to set a new
lladdr the trunk port is already on the list.

OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.120 2015/10/08 11:39:59 dlg Exp $	*/
a621 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d739 1
a739 4
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&tr->tr_ac, ifa);
		error = ENETRESET;
		break;
@


1.120
log
@if the mbuf has a valid flowid, use it instead of using siphash24
and a bunch of header fields we have to parse the mbuf for.

siphash24 is about 20% of the cost of sending a udp packet on a
trunk interface with tcpbench on my box. if there's a flowid set
we get all that back.

ok mpi@@ mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.119 2015/10/05 13:00:04 mikeb Exp $	*/
d363 4
a369 4

	/* Insert into the list of ports */
	SLIST_INSERT_HEAD(&tr->tr_ports, tp, tp_entries);
	tr->tr_count++;
@


1.119
log
@Factor LACP frame processing out to a separate task

This is slightly refactored version of the diff by jmatthew@@
that makes use of a single per-trunk task but retains per-port
mbuf queues.

Running LACP frame processing in a task context allows a simple
way to synchronize changes to the trunk ports and trunk itself
performed from the ioctl, timeout and task contexts with a kernel
lock.

OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.118 2015/09/29 10:11:40 deraadt Exp $	*/
d971 3
@


1.118
log
@add sizes to some of the simpler free calls
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.117 2015/09/28 08:24:53 mpi Exp $	*/
d27 1
@


1.117
log
@Remove "if_tp" from the "struct ifnet".

Instead of violating a layer of abstraction by keeping per pseudo-driver
informations in "struct ifnet", the port trunk is now passed as a cookie
to the interface input handler (ifih).

The time of per pseudo-driver hack in the network stack is over!

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.116 2015/09/24 14:46:22 mikeb Exp $	*/
d159 1
a159 2
	if ((tr = malloc(sizeof(struct trunk_softc),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
d168 1
a168 1
				free(tr, M_DEVBUF, 0);
d233 1
a233 1
	free(tr, M_DEVBUF, 0);
d325 1
a325 2
	if ((tp = malloc(sizeof(struct trunk_port),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
d334 1
a334 1
				free(tp, M_DEVBUF, 0);
d467 1
a467 1
	free(tp, M_DEVBUF, 0);
d1418 2
a1419 2
	if (lb != NULL)
		free(lb, M_DEVBUF, 0);
@


1.116
log
@add a comment explaining how we serialize when switching trunkproto;
requested by mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.115 2015/09/24 14:01:20 mikeb Exp $	*/
a345 1
	ifp->if_tp = (caddr_t)tp;
a438 1
	ifp->if_tp = NULL;
d489 1
a489 1
	    (tp = (struct trunk_port *)ifp->if_tp) == NULL ||
d1071 2
a1072 2
	if ((tp = (struct trunk_port *)ifp->if_tp) == NULL ||
	    (tr = (struct trunk_softc *)tp->tp_trunk) == NULL)
@


1.115
log
@Avoid a theoretical m_pullup(9) mishandling by delegating the mbuf
reclaiming to the PDU and marker input routines.

m_pullup may return a pointer to the newly allocated mbuf.  In this
case m_freem is called by the trunk_input, not by the proto specific
code and pointer to the mbuf is not passed by reference. Therefore
m_freem will either be called on the middle element of the chain
(when the m_pullup call succeeds) or on the stale pointer (when it
frees the chain in the failure case).  Fortunately we should never
hit this case as the receive path uniformly uses contiguous chunks
of memory.

Verified with and ok blambert, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.114 2015/09/23 12:50:06 mikeb Exp $	*/
d662 7
@


1.114
log
@Serialize trunk changes with input handler insertion and removal.

This moves around calls to if_ih_insert and if_ih_remove to ensure
that we either have completed port initialization or are going to
tear the port configuration down and don't want any input processes
to get hold of the port.

When trunk_port_destroy is called from the ioctl this would wait for
all input processes to finish and release their references to be able
to disestablish the input handler and ensure full control of the port.

When switching trunkproto it is required for the ioctl context to
be able to touch all trunk ports and the protocol (tr_psc).  The
easiest way do this is to disestablish all input handlers (while
making sure they all complete) and then reestablish them after the
trunk reconfiguration is completed.

This avoids getting trunk a separate locking protocol of its own.

ok mpi, suggested by and ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.113 2015/09/23 12:42:45 mikeb Exp $	*/
a1078 1
		m_freem(m);
d1369 1
@


1.113
log
@Keep track of an active port in the failover trunk to avoid list
iterations and additional locking protection in the future.

Suggested by and ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.112 2015/09/23 12:40:12 mikeb Exp $	*/
a345 3
	/* Change input handler of the physical interface. */
	if_ih_insert(ifp, trunk_input, NULL);

d390 3
d420 3
a437 3
	/* Restore previous input handler. */
	if_ih_remove(ifp, trunk_input, NULL);

d662 2
d678 3
@


1.112
log
@Remove trunk watchdog code since it doesn't do anything useful
and we want to limit the number of different places where we
access trunk port pointers.

trunk_watchdog should be never called as we don't set up it's
if_timer and trunk_port_watchdog just calls the if_watchdog
from the underlying interface.

It's possible that this is no longer needed due to if_slowtimo/
if_watchdog changes done earlier.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.111 2015/09/10 16:41:30 mikeb Exp $	*/
d101 2
d106 1
d1298 3
a1300 3
	tr->tr_port_create = NULL;
	tr->tr_port_destroy = NULL;
	tr->tr_linkstate = NULL;
d1304 3
d1313 1
d1318 29
d1349 1
a1349 1
	struct trunk_port *tp;
d1352 1
a1352 1
	if ((tp = trunk_link_active(tr, tr->tr_primary)) == NULL) {
d1363 4
a1366 2
	struct trunk_port *tmp_tp;
	int accept = 0;
d1368 4
a1371 13
	if (tp == tr->tr_primary) {
		accept = 1;
	} else if (tr->tr_primary->tp_link_state == LINK_STATE_DOWN) {
		tmp_tp = trunk_link_active(tr, NULL);
		/*
		 * If tmp_tp is null, we've received a packet when all
		 * our links are down. Weird, but process it anyways.
		 */
		if ((tmp_tp == NULL || tmp_tp == tp))
			accept = 1;
	}
	if (!accept)
		return (-1);
d1373 1
a1373 1
	return (0);
@


1.111
log
@pass a cookie argument to interface input handlers that can be used
to pass additional context or transient data with the similar life
time.

ok mpi, suggestions, hand holding and ok from dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.110 2015/09/10 13:32:19 dlg Exp $	*/
a62 1
void	 trunk_port_watchdog(struct ifnet *);
a80 1
void	 trunk_watchdog(struct ifnet *);
a182 1
	ifp->if_watchdog = trunk_watchdog;
a349 4
	timeout_del(ifp->if_slowtimo);
	tp->tp_watchdog = ifp->if_watchdog;
	ifp->if_watchdog = trunk_port_watchdog;

a434 1
	ifp->if_watchdog = tp->tp_watchdog;
a472 3
	/* Reestablish watchdog timeout */
	if_slowtimo(ifp);

a475 17
void
trunk_port_watchdog(struct ifnet *ifp)
{
	struct trunk_port *tp;

	/* Should be checked by the caller */
	if (ifp->if_type != IFT_IEEE8023ADLAG)
		return;
	if ((tp = (struct trunk_port *)ifp->if_tp) == NULL ||
	    tp->tp_trunk == NULL)
		return;

	if (tp->tp_watchdog != NULL)
		(*tp->tp_watchdog)(ifp);
}


a1038 12
}

void
trunk_watchdog(struct ifnet *ifp)
{
	struct trunk_softc *tr = (struct trunk_softc *)ifp->if_softc;

	if (tr->tr_proto != TRUNK_PROTO_NONE &&
	    (*tr->tr_watchdog)(tr) != 0) {
		ifp->if_oerrors++;
	}

@


1.110
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.109 2015/07/17 23:32:18 mpi Exp $	*/
d78 1
a78 1
int	 trunk_input(struct ifnet *, struct mbuf *);
d347 1
a347 1
	if_ih_insert(ifp, trunk_input);
d440 1
a440 1
	if_ih_remove(ifp, trunk_input);
d1082 1
a1082 1
trunk_input(struct ifnet *ifp, struct mbuf *m)
@


1.109
log
@Drop promiscuously received packets if the trunk(4) interface is not
in promiscuous mode.

The long story is that claudio@@ had his ssh session reset multiple
times in the hackroom because czarkoff@@'s machine was sending reset.
We figured out that the packet was reaching pf because of this missing
check.  pf would then not find any state and sent a reset.

Analyzed with and ok phessler@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.108 2015/07/02 10:02:40 mpi Exp $	*/
d347 1
a347 2
	tp->tp_ifih.ifih_input = trunk_input;
	SLIST_INSERT_HEAD(&ifp->if_inputs, &tp->tp_ifih, ifih_next);
d440 1
a440 1
	SLIST_REMOVE(&ifp->if_inputs, &tp->tp_ifih, ifih, ifih_next);
@


1.108
log
@Unify the check for up & running between all pseudo-drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.107 2015/07/02 09:40:02 mpi Exp $	*/
d1118 15
@


1.107
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.106 2015/06/30 13:54:42 mpi Exp $	*/
a1089 1
	int error;
d1096 1
a1096 2
	if (ifp->if_type != IFT_IEEE8023ADLAG) {
		error = EPROTONOSUPPORT;
d1098 1
a1098 1
	}
d1100 1
a1100 2
	    (tr = (struct trunk_softc *)tp->tp_trunk) == NULL) {
		error = ENOENT;
d1102 1
a1102 1
	}
d1104 1
a1104 2
	if (tr->tr_proto == TRUNK_PROTO_NONE) {
		error = ENOENT;
a1105 1
	}
d1116 3
d1127 1
a1127 1
	return (error);
@


1.106
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.105 2015/06/29 10:32:29 dlg Exp $	*/
d78 1
a78 1
int	 trunk_input(struct mbuf *);
d1083 1
a1083 1
trunk_input(struct mbuf *m)
a1084 1
	struct ifnet *ifp;
a1090 7

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	KASSERT(ifp != NULL);
	if ((ifp->if_flags & IFF_UP) == 0) {
		m_freem(m);
		return (1);
	}
@


1.105
log
@count if_ibytes in if_input like we do for if_ipackets.

tweaks and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.104 2015/06/24 09:40:54 mpi Exp $	*/
d1302 1
a1302 2
	/* Send mbuf */
	if ((error = if_output(tp->tp_if, m)) != 0)
d1357 1
a1357 2
	/* Send mbuf */
	return (if_output(tp->tp_if, m));
d1478 1
a1478 2
	/* Send mbuf */
	return (if_output(tp->tp_if, m));
d1538 1
a1538 1
			ret = if_output(last->tp_if, m);
d1549 1
a1549 1
	ret = if_output(last->tp_if, m0);
d1622 1
a1622 2
	/* Send mbuf */
	return (if_output(tp->tp_if, m));
@


1.104
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.103 2015/06/16 11:09:39 mpi Exp $	*/
a1102 2

	ifp->if_ibytes += m->m_pkthdr.len;
@


1.103
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.102 2015/06/15 15:55:08 mpi Exp $	*/
a1132 1
	trifp->if_ipackets++;
@


1.102
log
@Fix a double free in the destroy path triggered when a second process,
in my case dhclient(8), races with ifconfig(8) to free the descriptors
of the joined multicast groups.

While here reduce the difference with carp(4).

ok dms@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.101 2015/06/09 14:50:14 mpi Exp $	*/
d1093 7
a1099 1
	ifp = m->m_pkthdr.rcvif;
a1100 1

@


1.101
log
@Convert trunk(4) to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.100 2015/05/26 11:39:07 mpi Exp $	*/
d860 6
a865 2
	if ((error = trunk_ioctl_allports(tr, SIOCDELMULTI,
	    (caddr_t)ifr)) != 0) {
d869 1
a869 1
			    "on all ports\n", tr->tr_ifname);
d871 1
a873 3
	SLIST_REMOVE(&tr->tr_mc_head, mc, trunk_mc, mc_entries);
	free(mc, M_DEVBUF, 0);

d891 1
a891 1
		free(mc, M_DEVBUF, 0);
@


1.100
log
@Now that the Ethernet header is always passed as part of the mbuf, kill
the second (unused) argument of the input packet handlers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.99 2015/05/15 10:15:13 mpi Exp $	*/
a18 3
#include "bpfilter.h"
#include "trunk.h"

a34 3
#if NBPFILTER > 0
#include <net/bpf.h>
#endif
d48 4
d1088 1
a1114 5
#if NBPFILTER > 0
	if (trifp->if_bpf && tr->tr_proto != TRUNK_PROTO_FAILOVER)
		bpf_mtap_ether(trifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

d1124 2
d1127 1
a1127 2
	m->m_pkthdr.rcvif = trifp;
	return (0);
a1360 1
	struct ifnet *ifp = &tr->tr_ac.ac_if;
a1376 4
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
@


1.99
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.98 2015/05/14 10:55:28 mpi Exp $	*/
d80 1
a80 1
int	 trunk_input(struct mbuf *, void *);
d1083 1
a1083 1
trunk_input(struct mbuf *m, void *hdr)
d1089 1
a1089 1
	struct ether_header *eh = hdr;
d1093 1
a1093 3

	if (eh == NULL)
		eh = mtod(m, struct ether_header *);
@


1.98
log
@Allocate the input packet handler as part of the trunk_port structure
since they have the same lifetime.

Requested by and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.97 2015/05/13 08:16:01 mpi Exp $	*/
a973 23
int
trunk_enqueue(struct ifnet *ifp, struct mbuf *m)
{
	int len, error = 0;
	u_short mflags;

	splassert(IPL_NET);

	/* Send mbuf */
	mflags = m->m_flags;
	len = m->m_pkthdr.len;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error)
		return (error);
	if_start(ifp);

	ifp->if_obytes += len;
	if (mflags & M_MCAST)
		ifp->if_omcasts++;

	return (error);
}

d1306 1
a1306 1
	if ((error = trunk_enqueue(tp->tp_if, m)) != 0)
d1362 1
a1362 1
	return (trunk_enqueue(tp->tp_if, m));
d1489 1
a1489 1
	return (trunk_enqueue(tp->tp_if, m));
d1549 1
a1549 1
			ret = trunk_enqueue(last->tp_if, m);
d1560 1
a1560 1
	ret = trunk_enqueue(last->tp_if, m0);
d1634 1
a1634 1
	return (trunk_enqueue(tp->tp_if, m));
@


1.97
log
@Get rid of the last "#if NTRUNK" by overwriting trunk ports' output
function.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.96 2015/05/11 08:41:43 mpi Exp $	*/
a293 1
	struct ifih *trunk_ifih;
a331 6
	trunk_ifih = malloc(sizeof(*trunk_ifih), M_DEVBUF, M_NOWAIT);
	if (trunk_ifih == NULL) {
		free(tp, M_DEVBUF, 0);
		return (ENOMEM);
	}

a337 1
				free(trunk_ifih, M_DEVBUF, sizeof(*trunk_ifih));
d349 2
a350 2
	trunk_ifih->ifih_input = trunk_input;
	SLIST_INSERT_HEAD(&ifp->if_inputs, trunk_ifih, ifih_next);
a424 1
	struct ifih *trunk_ifih;
d443 1
a443 4
	trunk_ifih = SLIST_FIRST(&ifp->if_inputs);
	SLIST_REMOVE_HEAD(&ifp->if_inputs, ifih_next);
	KASSERT(trunk_ifih->ifih_input == trunk_input);
	free(trunk_ifih, M_DEVBUF, sizeof(*trunk_ifih));
@


1.96
log
@Take trunk(4) out of ether_input().

Each physical interface of a trunk now gets a specific ifih (interface
input handler) that runs before ether_input().

Tested by sthen@@, dlg@@, Theo Buehler and <mxb AT alumni.chalmers DOT se>

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.95 2015/03/14 03:38:51 jsg Exp $	*/
d69 2
d80 1
d368 3
d459 1
d573 14
@


1.95
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.94 2014/12/19 17:14:39 tedu Exp $	*/
d97 1
a97 1
	    struct ether_header *, struct mbuf *);
d104 1
a104 1
	    struct ether_header *, struct mbuf *);
d113 1
a113 1
	    struct ether_header *, struct mbuf *);
d121 1
a121 1
	    struct ether_header *, struct mbuf *);
d128 1
a128 1
	    struct ether_header *, struct mbuf *);
d291 1
d330 6
d342 1
d352 5
d427 1
d442 1
a442 1
	/* Restore interface */
d444 7
d1097 1
a1097 1
trunk_input(struct ifnet *ifp, struct ether_header *eh, struct mbuf *m)
d1099 1
d1103 12
a1114 1
	int error = 0;
d1134 1
a1134 2
		bpf_mtap_hdr(trifp->if_bpf, (char *)eh, ETHER_HDR_LEN, m,
		    BPF_DIRECTION_IN, NULL);
d1137 8
a1144 3
	error = (*tr->tr_input)(tr, tp, eh, m);
	if (error != 0)
		return (error);
d1147 1
d1151 1
a1151 1
	if (error > 0 && trifp != NULL)
d1331 1
a1331 2
trunk_rr_input(struct trunk_softc *tr, struct trunk_port *tp,
    struct ether_header *eh, struct mbuf *m)
a1332 2
	struct ifnet *ifp = &tr->tr_ac.ac_if;

a1333 2
	m->m_pkthdr.rcvif = ifp;

d1380 1
a1380 2
trunk_fail_input(struct trunk_softc *tr, struct trunk_port *tp,
    struct ether_header *eh, struct mbuf *m)
d1397 1
a1397 2
	if (!accept) {
		m_freem(m);
a1398 1
	}
d1401 1
a1401 2
		bpf_mtap_hdr(ifp->if_bpf, (char *)eh, ETHER_HDR_LEN, m,
		    BPF_DIRECTION_IN, NULL);
a1403 1
	m->m_pkthdr.rcvif = ifp;
d1507 1
a1507 2
trunk_lb_input(struct trunk_softc *tr, struct trunk_port *tp,
    struct ether_header *eh, struct mbuf *m)
a1508 2
	struct ifnet *ifp = &tr->tr_ac.ac_if;

a1509 2
	m->m_pkthdr.rcvif = ifp;

d1585 1
a1585 2
trunk_bcast_input(struct trunk_softc *tr, struct trunk_port *tp,
    struct ether_header *eh, struct mbuf *m)
a1586 3
	struct ifnet *ifp = &tr->tr_ac.ac_if;

	m->m_pkthdr.rcvif = ifp;
d1652 1
a1652 2
trunk_lacp_input(struct trunk_softc *tr, struct trunk_port *tp,
    struct ether_header *eh, struct mbuf *m)
d1654 1
a1654 8
	struct ifnet *ifp = &tr->tr_ac.ac_if;

	m = lacp_input(tp, eh, m);
	if (m == NULL)
		return (-1);

	m->m_pkthdr.rcvif = ifp;
	return (0);
@


1.94
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.93 2014/12/04 00:01:53 tedu Exp $	*/
a34 1
#include <net/if_arp.h>
@


1.93
log
@use siphash for trunk loadbalancing. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.92 2014/12/01 15:06:54 mikeb Exp $	*/
a42 1
#ifdef INET
a45 1
#endif
a729 1
#ifdef INET
a731 1
#endif /* INET */
a975 1
#ifdef INET
a976 1
#endif
a1006 1
#ifdef INET
a1013 1
#endif
@


1.92
log
@Make every interface with a watchdog register it's own slow timeout

This removes the system wide if_slowtimo timeout and lets every
interface with a valid if_watchdog method register it's own in
order to get rid of the ifnet loop in the softclock context and
avoid further complications with concurrent access to the ifnet
list.

ok deraadt, input and ok mpi, looked at by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.91 2014/11/18 02:37:31 tedu Exp $	*/
d31 2
a32 1
#include <sys/hash.h>
d973 1
a973 1
trunk_hashmbuf(struct mbuf *m, u_int32_t key)
d987 1
d989 1
d992 1
a992 1
		return (p);
d995 2
a996 2
	p = hash32_buf(&eh->ether_shost, ETHER_ADDR_LEN, key);
	p = hash32_buf(&eh->ether_dhost, ETHER_ADDR_LEN, p);
d1001 1
a1001 1
		p = hash32_buf(&ether_vtag, sizeof(ether_vtag), p);
d1007 1
a1007 1
		p = hash32_buf(&ether_vtag, sizeof(ether_vtag), p);
d1018 2
a1019 2
		p = hash32_buf(&ip->ip_src, sizeof(struct in_addr), p);
		p = hash32_buf(&ip->ip_dst, sizeof(struct in_addr), p);
d1027 2
a1028 2
		p = hash32_buf(&ip6->ip6_src, sizeof(struct in6_addr), p);
		p = hash32_buf(&ip6->ip6_dst, sizeof(struct in6_addr), p);
d1030 1
a1030 1
		p = hash32_buf(&flow, sizeof(flow), p); /* IPv6 flow label */
d1035 2
a1036 1
	return (p);
d1412 1
a1412 1
	lb->lb_key = arc4random();
d1470 1
a1470 1
	p = trunk_hashmbuf(m, lb->lb_key);
@


1.91
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.90 2014/07/22 11:06:09 mpi Exp $	*/
d347 4
a352 2
	tp->tp_ioctl = ifp->if_ioctl;
	ifp->if_ioctl = trunk_port_ioctl;
d469 3
@


1.90
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.89 2014/07/12 18:44:22 tedu Exp $	*/
a31 2

#include <dev/rndvar.h>
@


1.89
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.88 2014/07/09 09:30:49 henning Exp $	*/
a45 1
#include <netinet/in_systm.h>
@


1.88
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.86 2013/11/21 16:16:08 mpi Exp $	*/
d172 1
a172 1
				free(tr, M_DEVBUF);
d238 1
a238 1
	free(tr, M_DEVBUF);
d340 1
a340 1
				free(tp, M_DEVBUF);
d466 1
a466 1
	free(tp, M_DEVBUF);
d844 1
a844 1
	free(mc, M_DEVBUF);
d863 1
a863 1
		free(mc, M_DEVBUF);
d1417 1
a1417 1
		free(lb, M_DEVBUF);
@


1.87
log
@if_lladdr -> if_sadl, no functional change.

ok mikeb@@
@
text
@d1105 1
a1105 1
		    BPF_DIRECTION_IN);
d1375 1
a1375 1
		    BPF_DIRECTION_IN);
@


1.86
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.85 2013/11/18 09:16:30 mpi Exp $	*/
a248 1
	struct ifaddr *ifa;
d251 1
a251 2
	ifa = ifp->if_lladdr;
	sdl = (struct sockaddr_dl *)ifa->ifa_addr;
@


1.85
log
@Convert trunk(4) to use a detachhook, discussed at b2k13 with many.

While here add a comment explaining detach hooks' order of execution when
destroying/detaching an interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.84 2013/06/20 12:03:40 mpi Exp $	*/
a37 1
#include <net/if_llc.h>
@


1.84
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.83 2013/06/20 09:38:24 mpi Exp $	*/
d73 1
d385 6
a390 3
	if (ifp->if_linkstatehooks != NULL)
		tp->lh_cookie = hook_establish(ifp->if_linkstatehooks, 1,
		    trunk_port_state, tp);
d440 2
a441 2
	if (ifp->if_linkstatehooks != NULL)
		hook_disestablish(ifp->if_linkstatehooks, tp->lh_cookie);
d551 1
a551 1
trunk_port_ifdetach(struct ifnet *ifp)
d553 1
a553 4
	struct trunk_port *tp;

	if ((tp = (struct trunk_port *)ifp->if_tp) == NULL)
		return;
@


1.83
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.82 2013/05/11 11:18:27 sthen Exp $	*/
d384 3
a386 2
	tp->lh_cookie = hook_establish(&ifp->if_linkstatehooks, 1,
	    trunk_port_state, tp);
d436 2
a437 1
	hook_disestablish(&ifp->if_linkstatehooks, tp->lh_cookie);
@


1.82
log
@Set trunk(4)'s MTU to that of the first trunkport. Allows trunk to work with
jumbo/baby-jumbo frames. To avoid problems with mismatches between trunkports,
any additional ports must have the same MTU as already set on the trunk(4).
Based on changes made in FreeBSD. Tested by myself and jj@@, ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.81 2013/04/02 08:54:37 mpi Exp $	*/
d384 2
a385 3
	if (ifp->if_linkstatehooks != NULL)
		tp->lh_cookie = hook_establish(ifp->if_linkstatehooks, 1,
		    trunk_port_state, tp);
d435 1
a435 2
	if (ifp->if_linkstatehooks != NULL)
		hook_disestablish(ifp->if_linkstatehooks, tp->lh_cookie);
@


1.81
log
@Instead of storing the link-level address of every interface in a global
array indexed by interface numbers, add a new field to the interface
descriptor pointing to it.

claudio@@ and todd@@ like it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.80 2013/03/28 16:45:16 tedu Exp $	*/
d316 13
d524 4
@


1.80
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.79 2013/02/25 22:00:46 dlg Exp $	*/
a62 2
extern struct ifaddr **ifnet_addrs;

d252 1
a252 1
	ifa = ifnet_addrs[ifp->if_index];
@


1.79
log
@trunk_bcast_start sent packets on all its member interfaces by copying
the mbuf it just sent on the previous interface. this is bad because the
previous interface could have modified the mbuf chain, which can make the
subsequent m_copym()s panic.

this copies the dance that rtsock.c does for broadcasting mbufs which
copies the mbuf before transmit, except for the last interface which it
handles outside the loop.

tested by halex@@ who verified it fixes his panic.
ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.78 2011/10/28 12:49:43 krw Exp $	*/
d30 1
a30 1
#include <sys/proc.h>
@


1.78
log
@Take more care to ensure all callbacks are initialized. In particular
tr_linkstate() was not initialized in trunk_rr_attach(), and
tr_init() and tr_stop() were missing in trunk_lb_attach().

Fixes crash triggered by changing trunkproto, reported by Anders
Berggren on bugs@@.

ok mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.77 2011/01/28 14:20:37 reyk Exp $	*/
d1508 1
a1508 1
trunk_bcast_start(struct trunk_softc *tr, struct mbuf *m)
d1513 2
a1514 2
	struct trunk_port	*tp;
	struct mbuf		*n;
d1517 15
a1531 11
		if (TRUNK_PORTACTIVE(tp)) {
			if (active_ports) {
				n = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
				if (n == NULL) {
					m_freem(m);
					return (ENOBUFS);
				}
			} else
				n = m;
			active_ports++;
			if ((ret = trunk_enqueue(tp->tp_if, n)))
d1534 1
d1536 2
a1537 2
	if (active_ports == 0) {
		m_freem(m);
d1540 5
d1547 1
@


1.77
log
@Fix another memory leak by replacing m_free() with m_freem() in trunk's
broadcast mode.

ok blambert@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.76 2010/11/12 13:26:29 dhill Exp $	*/
d1231 1
d1390 2
@


1.76
log
@avoid pointer arithmetic on void *
no change in .o

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.75 2010/05/08 11:26:06 stsp Exp $	*/
d1518 1
a1518 1
					m_free(m);
d1529 1
a1529 1
		m_free(m);
@


1.75
log
@Upon changing the MAC address of an if_trunk interface, all ports are switched
to the new MAC. But subsequently added ports were still being assigned the
old MAC address because it was copied from the wrong place. Give newly added
trunk ports the current MAC of the master port, rather than the saved MAC of
the master port. The saved MAC should only be used to restore the original
MAC address of the interface when it is removed from the trunk.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.74 2010/04/23 13:51:31 stsp Exp $	*/
d1214 1
a1214 1
	return (mtod(m, const void *) + off);
@


1.74
log
@Use proper Queen's English in a comment. Drive-by fix, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.73 2010/04/20 22:05:43 tedu Exp $	*/
d359 2
a360 1
	trunk_port_lladdr(tp, tr->tr_primary->tp_lladdr);
@


1.73
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.72 2010/04/17 17:47:03 deraadt Exp $	*/
d203 1
a203 1
	 * Attach as an ordinary ethernet device, childs will be attached
@


1.72
log
@use ifnewlladdr() for trunk lladdr changes, too
ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.71 2010/01/12 01:36:33 dlg Exp $	*/
a28 1
#include <sys/sysctl.h>
@


1.71
log
@set the length of the send queue to 1.

this prevents the ultimate length of the queue of the underlying interface
from being artificially inflated while hte vlan/trunk queue is filled and
then dumped wholesale on the underlying interface, which will dump its
massive queue wholesale on the chip.

tx mitigation is only triggered on real interfaces now (which is where the
cost is)

ok beck@@ original diff ok kjc@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.70 2009/11/18 02:09:59 deraadt Exp $	*/
a287 2
	struct ifaddr *ifa;
	struct ifreq ifr;
d293 1
a293 13
	if (ifp->if_flags & IFF_UP) {
		int s = splnet();
		ifp->if_flags &= ~IFF_UP;
		(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifr);
		ifp->if_flags |= IFF_UP;
		(*ifp->if_ioctl)(ifp, SIOCSIFFLAGS, (caddr_t)&ifr);
		splx(s);
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr != NULL &&
			    ifa->ifa_addr->sa_family == AF_INET)
				arp_ifinit((struct arpcom *)ifp, ifa);
		}
	}
@


1.70
log
@do not do setup that ether_ifattach() takes care of; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.69 2009/09/17 13:13:56 claudio Exp $	*/
d197 1
a197 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.69
log
@Add an splassert check trunk_enqueue() calling this function at anything
below splnet() is a good recipe for doom.
OK henning, reyk, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.68 2009/09/09 15:01:18 reyk Exp $	*/
a189 2
	ifp->if_carp = NULL;
	ifp->if_type = IFT_ETHER;
a193 1
	ifp->if_output = ether_output;
d921 1
a921 1
	int error = 0;
d923 1
a923 1
	for (;; error = 0) {
@


1.68
log
@remove inline functions and move some code from the trunk_lacp_input()
API function directly to lacp_input() to simplify the code path.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.67 2009/07/16 22:58:45 thib Exp $	*/
d955 2
@


1.67
log
@Backout rev1.79 of if_vlan.c and rev1.66 of if_trunk.c;
Changes in those revision limited the send queue to one slot.

This breaks NFS over vlan(4) has discovered by sthen@@.

"just plain back it out." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.64 2009/01/27 12:58:27 naddy Exp $	*/
a611 1
		rp->rp_flags = 0;
d613 1
a613 6
		if (lacp_isactive(tp))
			rp->rp_flags |= TRUNK_PORT_ACTIVE;
		if (lacp_iscollecting(tp))
			rp->rp_flags |= TRUNK_PORT_COLLECTING;
		if (lacp_isdistributing(tp))
			rp->rp_flags |= TRUNK_PORT_DISTRIBUTING;
a1627 10
	u_short etype;

	etype = ntohs(eh->ether_type);

	/* Tap off LACP control messages */
	if (etype == ETHERTYPE_SLOW) {
		m = lacp_input(tp, eh, m);
		if (m == NULL)
			return (-1);
	}
d1629 2
a1630 6
	/*
	 * If the port is not collecting or not in the active aggregator then
	 * free and return.
	 */
	if (lacp_iscollecting(tp) == 0 || lacp_isactive(tp) == 0) {
		m_freem(m);
a1631 1
	}
@


1.66
log
@make the send queue one slot long. this forces packets off the virtual
interfaces down to the queue on the physical interface immediately.

this avoids having the tx mitigation code wasting cpu time dicking around
with simply shuffling packets off virtual interface queues and lets it
do its job of ammortising the cost of calling a real interfaces start
routine.

it also prevents an artificial inflation of the physical interfaces queue
length where packets could hide on the virtual interfaces queues during
softnet before being dumped en masse onto the hardware. this will smooth
out the rate at which packets are submitted to the hardware.

kjc@@ says this has no impact on altq. ya henning@@
@
text
@d200 1
a200 1
	IFQ_SET_MAXLEN(&ifp->if_snd, 1);
@


1.65
log
@handle HW VLAN tags being passed down; from Brad
@
text
@d200 1
a200 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.64
log
@make the hardware/no hardware tag stripping cases consistent and don't
hash the VLAN priority; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.63 2008/12/14 23:08:52 brad Exp $	*/
d939 1
a939 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
@


1.63
log
@Allow trunk_hashmbuf() to take HW VLAN tagging into consideration.

ok mpf@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.62 2008/12/14 23:04:06 brad Exp $	*/
d1009 2
a1010 1
		p = hash32_buf(vlan, sizeof(*vlan), p);
@


1.62
log
@Since trunk_hashmbuf() and thus trunk_lb_gethdr() are no longer specific
to the loadbalance code rename trunk_lb_gethdr() to just trunk_gethr().

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.61 2008/11/28 02:44:18 brad Exp $	*/
d980 1
a980 1
	u_int16_t etype;
d1002 4
a1005 1
	if (etype == ETHERTYPE_VLAN) {
@


1.61
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.60 2008/11/16 03:42:13 brad Exp $	*/
d94 1
a122 1
const void *trunk_lb_gethdr(struct mbuf *, u_int, u_int, void *);
d1004 1
a1004 1
		    trunk_lb_gethdr(m, off, EVL_ENCAPLEN, &vlanbuf)) == NULL)
d1015 1
a1015 1
		    trunk_lb_gethdr(m, off, sizeof(*ip), &ipbuf)) == NULL)
d1024 1
a1024 1
		    trunk_lb_gethdr(m, off, sizeof(*ip6), &ip6buf)) == NULL)
d1222 12
a1455 12
}

const void *
trunk_lb_gethdr(struct mbuf *m, u_int off, u_int len, void *buf)
{
	if (m->m_pkthdr.len < (off + len)) {
		return (NULL);
	} else if (m->m_len < (off + len)) {
		m_copydata(m, off, len, buf);
		return (buf);
	}
	return (mtod(m, const void *) + off);
@


1.60
log
@Make sure to increment the the output error counter if
not using TRUNK_PROTO_NONE and there are no member ports.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.59 2008/11/08 01:00:01 mpf Exp $	*/
a743 7
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU) {
			error = EINVAL;
			break;
		}
		ifp->if_mtu = ifr->ifr_mtu;
@


1.59
log
@Take into account that our ether_input() already strips the
ethernet header. This lets us actually process the incoming
LACP-Packets.  It should now work with a lot more switches.
At least a Catalyst 3500 seems happy.
OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.58 2008/11/04 13:44:11 brad Exp $	*/
d949 1
a949 1
		if (tr->tr_proto != TRUNK_PROTO_NONE && tr->tr_count)
d951 5
a955 1
		else
d957 3
a959 5

		if (error == 0)
			ifp->if_opackets++;
		else
			ifp->if_oerrors++;
@


1.58
log
@Move the trunk port count check from trunk_lb_start() to trunk_start()
before the protocol start routine is called so as to cover all protocols
with the same check.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.57 2008/10/30 20:44:02 brad Exp $	*/
d1641 1
a1641 1
		m = lacp_input(tp, m);
@


1.57
log
@Fix building with !INET6 kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.56 2008/10/28 07:18:45 brad Exp $	*/
d949 1
a949 1
		if (tr->tr_proto != TRUNK_PROTO_NONE)
a1468 5

	if (tr->tr_count == 0) {
		m_freem(m);
		return (EINVAL);
	}
@


1.56
log
@Remove return at the end of a void function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.55 2008/10/28 07:14:45 brad Exp $	*/
d986 1
a986 1
	u_int32_t flow, p = 0;
d994 1
@


1.55
log
@In trunk_media_status() mark the interface as active if any ports are
active rather than just the primary being UP.

From FreeBSD

Ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.54 2008/10/28 07:13:01 brad Exp $	*/
a958 2

	return;
@


1.54
log
@In trunk_lb_start() port % count will never be greater than
TRUNK_MAX_PORTS so nuke the test.

From FreeBSD

Ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.53 2008/10/28 07:11:03 brad Exp $	*/
d1153 4
a1156 3
	tp = tr->tr_primary;
	if (tp != NULL && tp->tp_if->if_flags & IFF_UP)
		imr->ifm_status |= IFM_ACTIVE;
@


1.53
log
@Feed IPv6 flow label to hash calculation.

From FreeBSD

Ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.52 2008/10/28 07:10:09 brad Exp $	*/
a1468 1
	int idx;
d1476 2
a1477 5
	if ((idx = p % tr->tr_count) >= TRUNK_MAX_PORTS) {
		m_freem(m);
		return (EINVAL);
	}
	tp = lb->lb_ports[idx];
@


1.52
log
@Show the ACTIVE flag in ifconfig for the single interface that is
actually active in failover mode rather than all interfaces with a
link. This makes it clear if the master interface is in use or one
of the backup links.

From FreeBSD

Tested by jmc@@
Ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.51 2008/10/02 20:21:14 brad Exp $	*/
d988 1
a988 1
	u_int32_t p = 0;
d1034 2
@


1.51
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.50 2008/09/17 20:10:37 chl Exp $	*/
d598 5
@


1.50
log
@remove dead stores and newly created unused variables.

fix potential use of uninitialized value in trunk_port_ioctl() function.

Found by LLVM/Clang Static Analyzer.

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.49 2008/08/07 18:06:17 damien Exp $	*/
a634 3
	if ((error = ether_ioctl(ifp, &tr->tr_ac, cmd, data)) > 0)
		goto out;

d767 1
a767 2
		error = EINVAL;
		break;
@


1.49
log
@do not touch m after IFQ_ENQUEUE()+if_start().

ok brad@@, mpf@@, henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.48 2008/08/06 17:04:28 reyk Exp $	*/
a481 1
	struct trunk_softc *tr;
d488 1
a488 1
	    (tr = (struct trunk_softc *)tp->tp_trunk) == NULL)
d501 1
a501 1
	struct trunk_port *tp;
@


1.48
log
@fix trunk breakage that sneaked in with the lacp diff:

- don't use in-kernel IFMEDIA ioctls in lacp and remove two KASSERTs
that caused reliable panics - the lacp key can be locally assigned and
we don't need to query the media subtype here.

- unbreak failover/loadbalance/broadcast status handling.

Reported by brad@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.47 2008/07/30 10:15:35 mpf Exp $	*/
d966 2
a967 1
	int error = 0;
d970 2
d977 2
a978 2
	ifp->if_obytes += m->m_pkthdr.len;
	if (m->m_flags & M_MCAST)
@


1.47
log
@Prevent a divide by zero panic if trunkproto loadbalance is
used w/out any trunkports. Patch from Dmitri Alenitchev.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.46 2008/06/15 06:56:09 mpf Exp $	*/
d602 1
d608 1
@


1.46
log
@Add 802.3ad LACP support for trunk(4).
Implementation from NetBSD. Ported via FreeBSD's version in trunk^Wlagg(4).
This is still work in progress.  Tested with a HP ProCurve 3500.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.45 2008/06/14 01:18:53 mpf Exp $	*/
d1463 5
@


1.45
log
@Move bpf_mtap_hdr() above the trunk_*_input() routines.
This makes it easier to add trunk protocols that consume some packets.
Add a special case for the failover protocol, to prevent shoving
duplicates to bpf. (Not beautiful, but it has to do for the moment).
OK reyk@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.44 2008/06/13 23:24:21 mpf Exp $	*/
d59 2
d131 7
d147 1
d589 1
d593 25
a617 3
	rp->rp_flags = tp->tp_flags;
	if (TRUNK_PORTACTIVE(tp))
		rp->rp_flags |= TRUNK_PORT_ACTIVE;
d642 2
a735 1

d1237 2
d1311 2
d1390 2
d1511 2
d1561 90
@


1.44
log
@Move the responsibility to free received packets on trunked interfaces
from ether_input() into trunk_input() where it can be handled in a smarter way.
OK claudio@@ and reyk@@ on an earlier version.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.43 2008/06/08 17:25:46 brad Exp $	*/
a1070 4
	error = (*tr->tr_input)(tr, tp, eh, m);
	if (error != 0)
		return (error);

d1072 1
a1072 1
	if (trifp->if_bpf)
d1077 4
d1306 1
d1309 2
a1310 5
		m->m_pkthdr.rcvif = ifp;
		return (0);
	}

	if (tr->tr_primary->tp_link_state == LINK_STATE_DOWN) {
d1316 6
a1321 4
		if ((tmp_tp == NULL || tmp_tp == tp)) {
			m->m_pkthdr.rcvif = ifp;
			return (0);
		}
d1323 8
a1330 2
	m_freem(m);
	return (-1);
@


1.43
log
@Use m_freem() instead of m_free() in trunk_start() to ensure that the
full mbuf chain is being free'd.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.42 2008/05/07 13:45:35 dlg Exp $	*/
d1065 3
a1067 1
	if (tr->tr_proto == TRUNK_PROTO_NONE)
d1069 1
a1069 1
	trifp = &tr->tr_ac.ac_if;
d1073 1
a1073 1
		goto bad;
a1081 1

d1087 1
d1323 1
a1323 1

@


1.42
log
@enable tx mitigation when putting packets on the wire by switching from
calls to ifp->if_start to if_start(). these are the obviously right cases
where we can do that, the less obvious ones may follow as theyre figured
out.

deraadt@@ said to go for it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.40 2007/11/26 09:28:33 martynas Exp $	*/
d916 1
a916 1
			m_free(m);
@


1.41
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests to trunk
ports.

ok reyk@@ dlg@@
@
text
@d936 1
a936 2
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
@


1.40
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.39 2007/11/20 20:42:11 canacar Exp $	*/
d500 2
a501 1
	    (tr = (struct trunk_softc *)tp->tp_trunk) == NULL)
d503 1
d523 1
d534 1
a534 1
		return ((*tp->tp_ioctl)(ifp, cmd, data));
d536 1
a536 1
	return (EINVAL);
@


1.39
log
@Fix possible mbuf leak on error. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.38 2007/10/22 17:02:03 reyk Exp $	*/
d1311 1
a1311 1
		 * If tmp_tp is null, we've recieved a packet when all
@


1.38
log
@use the input mbuf for the first active port instead of copying it in
the broadcast start routing.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.37 2007/10/22 14:48:52 pyr Exp $	*/
d1228 2
a1229 1
	if (tp == NULL && (tp = trunk_link_active(tr, NULL)) == NULL)
d1231 1
d1287 2
a1288 1
	if ((tp = trunk_link_active(tr, tr->tr_primary)) == NULL)
d1290 1
d1415 2
a1416 1
	if ((idx = p % tr->tr_count) >= TRUNK_MAX_PORTS)
d1418 1
d1425 2
a1426 1
	if ((tp = trunk_link_active(tr, tp)) == NULL)
d1428 1
@


1.37
log
@Add a broadcast mode to trunk(4). This mode sends frames on all
ports and receives frame on any port. This allows interaction with
some L2 configurations.
with input and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.36 2007/09/15 16:43:51 henning Exp $	*/
d1470 1
a1470 1
	struct mbuf		*newbuf;
d1474 8
a1481 8
			/*
			 * copy the mbuf everytime.
			 */
			newbuf = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
			if (newbuf == NULL) {
				m_free(m);
				return (ENOBUFS);
			}
d1483 1
a1483 1
			if ((ret = trunk_enqueue(tp->tp_if, newbuf)))
d1487 2
a1488 2
	m_free(m);
	if (active_ports == 0)
d1490 1
@


1.36
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.35 2007/09/07 11:00:47 reyk Exp $	*/
d122 7
d137 1
d1435 67
@


1.35
log
@use M_ZERO
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.34 2007/09/06 16:22:55 reyk Exp $	*/
d755 1
a755 2
	if ((mc = (struct trunk_mc *)malloc(sizeof(struct trunk_mc),
	    M_DEVBUF, M_NOWAIT)) == NULL) {
d1320 1
a1320 2
	if ((lb = (struct trunk_lb *)malloc(sizeof(struct trunk_lb),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
@


1.34
log
@bump the copyright while touching these files
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.33 2007/09/06 16:14:05 reyk Exp $	*/
d148 1
a148 1
	    M_DEVBUF, M_NOWAIT)) == NULL)
a150 2
	bzero(tr, sizeof(struct trunk_softc));

d322 1
a322 1
	    M_DEVBUF, M_NOWAIT)) == NULL)
a324 2
	bzero(tp, sizeof(struct trunk_port));

d1322 1
a1322 1
	    M_DEVBUF, M_NOWAIT)) == NULL)
a1323 1
	bzero(lb, sizeof(struct trunk_lb));
@


1.33
log
@With a trunk(4) interface in fail over mode the trunk(4) interface
will show input errors for packets received from any of the ports that
are part of a fail over interface but are not the "master" port at the
time. This fixes the problem by checking the error condition
correctly.

From brad at comstyle dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.32 2007/05/26 17:13:31 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005, 2006 Reyk Floeter <reyk@@openbsd.org>
@


1.32
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.31 2007/04/26 08:57:59 reyk Exp $	*/
d1079 1
a1079 1
	if (error && trifp != NULL)
@


1.31
log
@extend the trunk protocol API with some additional callbacks required
for future work. also move the repeated tx start code into a common
function.

parts of it are merged from FreeBSD's trunk(4) port. oh, wait... they
renamed it to 'lagg(4)' because a little green guy from Cizzco-Eeeh
told them "trunk is for VLANs, trunk is for VLANs". Bad FreeBSD, don't
listen to the little green guy from Cizzco-Eeeh!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.30 2007/01/31 06:20:19 reyk Exp $	*/
a62 1
extern int ifqmaxlen;
@


1.30
log
@handle the full duplex link state in trunk(4). load sharing trunks
with at least two ports are always handled as full fuplex links. this
change will allow trunks as edge ports in a rstp bridge(4).

ok brad@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.29 2006/05/28 01:14:15 reyk Exp $	*/
d86 2
d352 1
a352 1
	tp->tp_trunk = (caddr_t)tr;
a699 1

d726 1
d734 7
a740 9
		/*
		 * We don't need a trunk init at this point but we mark the
		 * interface as up and running or remove the running flag
		 * if it's down.
		 */
		if (ifp->if_flags & IFF_UP)
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
d922 109
d1121 2
a1122 1

d1192 2
a1223 1
	struct ifnet *ifp;
d1230 1
a1230 3
	ifp = tp->tp_if;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error)
a1231 6
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);

	ifp->if_obytes += m->m_pkthdr.len;
	if (m->m_flags & M_MCAST)
		ifp->if_omcasts++;
d1237 1
a1237 1
	return (error);
d1262 2
d1266 1
a1280 2
	struct ifnet *ifp;
	int error = 0;
d1287 1
a1287 12
	ifp = tp->tp_if;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error)
		return (error);
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);

	ifp->if_obytes += m->m_pkthdr.len;
	if (m->m_flags & M_MCAST)
		ifp->if_omcasts++;

	return (error);
d1336 1
a1406 2
	u_int16_t etype;
	struct ifnet *ifp;
d1408 1
a1408 30
	u_int16_t *vlan, vlanbuf[2];
	int error = 0, idx, off;
	struct ether_header *eh;
#ifdef INET
	struct ip *ip, ipbuf;
#endif
#ifdef INET6
	struct ip6_hdr *ip6, ip6buf;
#endif

	off = sizeof(*eh);
	if (m->m_len < off)
		goto send;
	eh = mtod(m, struct ether_header *);
	etype = ntohs(eh->ether_type);
	p = hash32_buf(&eh->ether_shost, ETHER_ADDR_LEN, lb->lb_key);
	p = hash32_buf(&eh->ether_dhost, ETHER_ADDR_LEN, p);

	/* Special handling for encapsulating VLAN frames */
	if (etype == ETHERTYPE_VLAN) {
		if ((vlan = (u_int16_t *)
		    trunk_lb_gethdr(m, off, EVL_ENCAPLEN, &vlanbuf)) == NULL) {
			if (m == NULL)
				goto merr;
			goto portidx;
		}
		p = hash32_buf(vlan, sizeof(*vlan), p);
		etype = ntohs(vlan[1]);
		off += EVL_ENCAPLEN;
	}
d1410 1
a1410 29
	switch (etype) {
#ifdef INET
	case ETHERTYPE_IP:
		if ((ip = (struct ip *)
		    trunk_lb_gethdr(m, off, sizeof(*ip), &ipbuf)) == NULL) {
			if (m == NULL)
				goto merr;
			goto portidx;
		}
		p = hash32_buf(&ip->ip_src, sizeof(struct in_addr), p);
		p = hash32_buf(&ip->ip_dst, sizeof(struct in_addr), p);
		break;
#endif
#ifdef INET6
	case ETHERTYPE_IPV6:
		if ((ip6 = (struct ip6_hdr *)
		    trunk_lb_gethdr(m, off, sizeof(*ip6), &ip6buf)) == NULL) {
			if (m == NULL)
				goto merr;
			goto portidx;
		}
		p = hash32_buf(&ip6->ip6_src, sizeof(struct in6_addr), p);
		p = hash32_buf(&ip6->ip6_dst, sizeof(struct in6_addr), p);
		break;
#endif
	}

 portidx:
	/* Finally get the physical port */
a1414 1
 send:
d1423 1
a1423 16
	ifp = tp->tp_if;
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error)
		return (error);
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);

	ifp->if_obytes += m->m_pkthdr.len;
	if (m->m_flags & M_MCAST)
		ifp->if_omcasts++;

	return (error);

 merr:
	m = NULL;
	return (ENOBUFS);
@


1.29
log
@check if the interface is active and UP. some, but not all, network
drivers report an active link state even if the interface is DOWN.
this should fix trunk with various ethernet devices.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.28 2006/05/23 04:56:55 reyk Exp $	*/
d253 1
a253 1
	int cap = ~0;
d255 4
d264 1
a264 1
		    tr->tr_ifname, cap == ~0 ? 0 : cap);
d267 1
a267 1
	return (cap == ~0 ? 0 : cap);
d1020 1
a1020 1
	int new_link = LINK_STATE_UP;
a1023 4
	 * Normally, this should be LINK_STATE_UP but not all
	 * drivers seem to report this correctly so we assume
	 * that LINK_STATE_DOWN is the opposite from
	 * LINK_STATE_UNKNOWN and LINK_STATE_UP.
d1047 14
a1060 2
	if (rval == NULL)
		new_link = LINK_STATE_DOWN;
d1084 1
d1243 1
@


1.28
log
@knf and remove an unneeded debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.27 2006/05/23 04:35:52 reyk Exp $	*/
d571 1
a571 1
	if (tp->tp_link_state != LINK_STATE_DOWN)
d1028 1
a1028 1
	if (tp->tp_link_state != LINK_STATE_DOWN) {
d1033 1
a1033 1
	    tp_next->tp_link_state != LINK_STATE_DOWN) {
d1040 1
a1040 1
		if (tp_next->tp_link_state != LINK_STATE_DOWN) {
@


1.27
log
@add
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.26 2006/05/20 22:03:24 reyk Exp $	*/
d1286 1
a1286 1
		return (NULL);		
a1364 3

	if (tr->tr_ifflags & IFF_DEBUG)	
		printf("%s: %d: port %u\n", __func__, __LINE__, p);
@


1.26
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.25 2006/05/20 20:52:57 reyk Exp $	*/
d32 3
d48 1
d50 5
d57 1
d110 11
d126 4
a129 3
	{ TRUNK_PROTO_ROUNDROBIN, trunk_rr_attach },
	{ TRUNK_PROTO_FAILOVER, trunk_fail_attach },
	{ TRUNK_PROTO_NONE, }
d278 1
a278 1
	        int s = splnet();
d1209 197
@


1.25
log
@drop packets received on inactive failover ports without increasing the
error counter. just silently drop them...

figured out by todd@@, ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.24 2006/05/16 20:23:10 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Reyk Floeter <reyk@@openbsd.org>
@


1.24
log
@the ifp->if_linkstatehooks may be NULL, add an extra check to avoid
possible kernel panic. this happened to me by using tun(4) in layer 2
mode (link0 flag) as a trunk port for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.23 2006/03/25 22:41:47 djm Exp $	*/
d945 1
a945 1
	if (trifp != NULL)
d1186 1
a1186 1
	return (ENETDOWN);
@


1.23
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.22 2006/03/11 03:12:36 brad Exp $	*/
d349 3
a351 2
	tp->lh_cookie = hook_establish(ifp->if_linkstatehooks, 1,
	    trunk_port_state, tp);
d401 2
a402 1
	hook_disestablish(ifp->if_linkstatehooks, tp->lh_cookie);
@


1.22
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.21 2006/03/04 22:40:16 brad Exp $	*/
d877 1
a877 1
			bpf_mtap(ifp->if_bpf, m);
d934 2
a935 1
		bpf_mtap_hdr(trifp->if_bpf, (char *)eh, ETHER_HDR_LEN, m);
@


1.21
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.20 2006/01/04 17:51:39 brad Exp $	*/
d256 1
a256 1
		int s = splimp();
@


1.20
log
@Move bpf_mtap_hdr() after trunk_*_input() so that we hopefully see only one
copy of the packet with bpf.

From mcbride@@

some testing by todd@@, ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.19 2006/01/04 06:04:42 canacar Exp $	*/
d462 1
a462 1
	s = splimp();
d563 1
a563 1
	s = splimp();
@


1.19
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.18 2005/12/21 18:44:21 reyk Exp $	*/
d928 4
a935 4

	error = (*tr->tr_input)(tr, tp, eh, m);
	if (error != 0)
		goto bad;
@


1.18
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.17 2005/12/21 18:41:55 reyk Exp $	*/
a200 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.17
log
@fix possible NULL pointer, thanks to Marco Molteni
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.16 2005/12/18 17:59:59 reyk Exp $	*/
d259 1
a259 1
	        int s = splimp();
d266 1
a266 1
		        if (ifa->ifa_addr != NULL &&
d268 1
a268 1
			        arp_ifinit((struct arpcom *)ifp, ifa);
d352 2
a353 2
        tp->lh_cookie = hook_establish(ifp->if_linkstatehooks, 1,
            trunk_port_state, tp);
d978 1
a978 1
{       
d980 1
a980 1
        struct trunk_softc *tr = NULL;
d1032 1
a1032 1
	
d1168 2
a1169 2
	
	if (tp == tr->tr_primary) { 
@


1.16
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.15 2005/12/17 23:44:29 brad Exp $	*/
d499 5
a503 1
	return ((*tp->tp_ioctl)(ifp, cmd, data));
d945 1
a945 1
	if (trifp)
d977 1
a977 1
trunk_port_state(void *v)
d979 2
a980 2
	struct trunk_port *tp = v;
        struct trunk_softc *tr;
d982 1
a982 1
	if (v)
d984 2
a986 3
	if (!tr)
		return;
	
@


1.15
log
@revert last commit as it introduced system panics due to improper use
of bpf_mtap().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.14 2005/11/27 15:53:50 mcbride Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.14
log
@Move bpf_mtap() after trunk_*_input() so that we hopefull see only one
copy of the packet with bpf.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.13 2005/11/27 15:46:04 mcbride Exp $	*/
d874 5
a882 5

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif
@


1.13
log
@Attempt to accept a packet only once when operating in failover mode.

Makes trunk usable with hubs or switches which don't have actual trunk support.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.12 2005/11/27 09:29:42 mcbride Exp $	*/
d874 5
a883 4
		if (tr->tr_proto != TRUNK_PROTO_NONE)
			error = (*tr->tr_start)(tr, m);
		else
			m_free(m);
@


1.12
log
@Fix dereference of uninitialised pointer in trunk_input() error path.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.11 2005/11/27 09:27:14 mcbride Exp $	*/
d1163 6
d1170 11
a1180 2
	/* Just pass in the packet to our trunk device */
	m->m_pkthdr.rcvif = ifp;
d1182 1
a1182 1
	return (0);
@


1.11
log
@Make the trunk interface link state depend on the link states of the
trunkports (link is UP as long as at least one of the trunkports is up)

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.10 2005/10/23 14:07:11 mpf Exp $	*/
d909 1
a909 1
	struct ifnet *trifp;
d940 2
a941 1
	trifp->if_ierrors++;
@


1.10
log
@Rework of multicast deletion code for vlan(4) and trunk(4).
The previous code could wrongly delete multicast groups
on the parent interface. Now we forward only remembered
delete requests.
OK mcbride, mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.9 2005/10/09 18:45:27 reyk Exp $	*/
d64 1
d351 4
d403 2
d970 15
d988 2
a989 1
	struct trunk_port *tp_next;
d1001 4
a1004 2
	if (tp->tp_link_state != LINK_STATE_DOWN)
		return (tp);
d1006 4
a1009 2
	    tp_next->tp_link_state != LINK_STATE_DOWN)
		return (tp_next);
d1013 4
a1016 2
		if (tp_next->tp_link_state != LINK_STATE_DOWN)
			return (tp_next);
d1019 10
a1028 1
	return (NULL);
@


1.9
log
@use label
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.8 2005/10/03 01:46:47 reyk Exp $	*/
d760 10
d783 2
a784 7
	SLIST_FOREACH(mc, &tr->tr_mc_head, mc_entries) {
		if (mc->mc_enm == enm) {
			SLIST_REMOVE(&tr->tr_mc_head, mc, trunk_mc, mc_entries);
			free(mc, M_DEVBUF);
			break;
		}
	}
@


1.8
log
@add a simple active "failover" trunk mode. port priorities will be
added later, currently the master port will always be the default
(active) port and the the next active port will be used as the
failover port.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.7 2005/09/14 08:07:24 reyk Exp $	*/
d557 2
a558 4
	if ((error = ether_ioctl(ifp, &tr->tr_ac, cmd, data)) > 0) {
		splx(s);
		return (error);
	}
a709 1

@


1.7
log
@correctly set IFF_RUNNING flag after device state changes.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.6 2005/09/11 16:17:01 brad Exp $	*/
d58 1
a58 1
void	 trunk_lladdr(struct trunk_softc *, u_int8_t *);
d60 1
a88 1
int	 trunk_rr_watchdog(struct trunk_softc *);
d92 7
d105 1
d215 1
a215 1
trunk_lladdr(struct trunk_softc *tr, u_int8_t *lladdr)
d217 1
a217 1
	struct ifnet *ifp = &tr->tr_ac.ac_if;
d226 1
a226 1
	bcopy(lladdr, tr->tr_ac.ac_enaddr, ETHER_ADDR_LEN);
d246 26
d328 3
d334 1
a334 1
		trunk_lladdr(tr, ((struct arpcom *)ifp)->ac_enaddr);
d337 4
a340 1
	/* Insert into the global list of trunks */
d404 2
a406 1
			u_int8_t lladdr[ETHER_ADDR_LEN];
a407 1
			trunk_lladdr(tr, lladdr);
d409 2
a410 2
			trunk_lladdr(tr,
			    ((struct arpcom *)tp_ptr->tp_if)->ac_enaddr);
d413 1
d415 4
d421 3
a444 3
	if (tr->tr_ifflags & IFF_DEBUG)
		printf("%s\n", __func__);

d537 1
d539 2
d687 5
d1058 17
a1074 1
trunk_rr_watchdog(struct trunk_softc *tr)
d1076 8
a1083 2
	if (tr->tr_ifflags & IFF_DEBUG)
		printf("%s\n", __func__);
d1085 3
d1092 27
a1118 1
trunk_rr_input(struct trunk_softc *tr, struct trunk_port *tp,
@


1.6
log
@when adding any IP addresses make sure to UP the interface.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.5 2005/09/10 22:40:36 reyk Exp $	*/
d616 2
d627 1
a627 4
		if (ifp->if_flags & IFF_UP)
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
d642 13
@


1.5
log
@update the trunk(4) driver

- add multicast support by passing multicast addresses to the ports.
this is a requirement for carp(4) over trunk(4).

- support the smallest common interface capabilities. ie., this adds
support for VLAN MTUs if all attached ports have this capability.

- add a port_destroy callback to the trunk protocol. this fixes a
potential crash if the master port has been detached while running.

discussed with deraadt@@, brad@@ and some others.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.4 2005/07/31 03:52:18 pascoe Exp $	*/
d610 2
d613 1
a613 1
		if (ifa->ifa_addr->sa_family == AF_INET) {
a614 1
		}
@


1.4
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.3 2005/05/27 22:57:13 reyk Exp $	*/
d59 1
d68 5
d86 1
d150 1
d178 3
d222 17
d304 10
a313 1
	return (0);
d322 1
a322 1
	
d340 6
d378 3
d630 1
a630 1
		error = ether_addmulti(ifr, &tr->tr_ac);
d633 1
a633 1
		error = ether_delmulti(ifr, &tr->tr_ac);
d650 137
a793 3
	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: start\n", ifp->if_xname);

d937 2
d951 9
@


1.3
log
@add missing free on error. thanks to Andrey Matveev.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.2 2005/05/24 07:51:53 reyk Exp $	*/
d672 2
a673 9
	if (trifp->if_bpf) {
		struct mbuf m0;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = ETHER_HDR_LEN;
		m0.m_data = (char *)eh;
		bpf_mtap(trifp->if_bpf, &m0);
	}
@


1.2
log
@support trunk stacking (trunks as trunk ports) and some fixes

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_trunk.c,v 1.1 2005/05/24 02:45:17 reyk Exp $	*/
d119 2
a120 1
			if ((error = trunk_protos[i].ti_attach(tr)) != 0)
d122 1
@


1.1
log
@initial import of a trunking (link aggregation and link failover)
implementation. it currently supports round robin mode with link state
checking, additional modes will be added later.

ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
d166 3
a168 1
	int error;
d171 3
a173 2
	while ((tp = SLIST_FIRST(&tr->tr_ports)) != NULL)
		if ((error = trunk_port_destroy(tp)) != 0)
d175 2
d188 2
d211 1
d240 12
d266 1
a266 1
		tp->tp_flags = TRUNK_PORT_MASTER;
d278 17
d407 1
a407 3
	if (SLIST_FIRST(&trunk_list) == NULL)
		return;
	if ((tp = trunk_port_get(NULL, ifp)) == NULL)
a690 2
	if (m)
		m_free(m);
@

