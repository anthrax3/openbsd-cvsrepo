head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.12
date	2017.03.10.02.12.46;	author phessler;	state Exp;
branches;
next	1.11;
commitid	pxPVXQfOW0bg8y30;

1.11
date	2017.03.10.01.38.07;	author phessler;	state Exp;
branches;
next	1.10;
commitid	MrAjkUsCwKSGPVVk;

1.10
date	2017.01.19.23.18.29;	author phessler;	state Exp;
branches;
next	1.9;
commitid	blN5b1tPhlkhcTy8;

1.9
date	2016.09.20.10.41.43;	author phessler;	state Exp;
branches;
next	1.8;
commitid	gdMBMn7Da5nVGRmQ;

1.8
date	2016.09.19.07.28.40;	author phessler;	state Exp;
branches;
next	1.7;
commitid	J6BMe1N7H8G0OaDK;

1.7
date	2016.09.17.07.35.05;	author phessler;	state Exp;
branches;
next	1.6;
commitid	XybSw76BMA6y6rFn;

1.6
date	2016.09.15.13.09.44;	author phessler;	state Exp;
branches;
next	1.5;
commitid	NmURLK3bsRiVEOqe;

1.5
date	2016.09.15.12.34.48;	author phessler;	state Exp;
branches;
next	1.4;
commitid	RI2snzzQDS1CfeE4;

1.4
date	2016.09.12.15.24.51;	author phessler;	state Exp;
branches;
next	1.3;
commitid	8BB6jad3LMaxMxeg;

1.3
date	2016.09.07.09.21.33;	author mpi;	state Exp;
branches;
next	1.2;
commitid	8XNPG0JQ4tuDPIfh;

1.2
date	2016.09.04.09.39.01;	author claudio;	state Exp;
branches;
next	1.1;
commitid	WcOp57BWVEJv93S4;

1.1
date	2016.09.03.14.14.20;	author phessler;	state Exp;
branches;
next	;
commitid	wvCqdCfoSx943JOG;


desc
@@


1.12
log
@move clearing the bfd config to a task.  while here, fix a typo
@
text
@/*	$OpenBSD: bfd.h,v 1.11 2017/03/10 01:38:07 phessler Exp $	*/

/*
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Support for Bi-directional Forwarding Detection (RFC 5880 / 5881)
 */

#ifndef _NET_BFD_H_
#define _NET_BFD_H_

/* Public Interface */

#define BFD_MODE_ASYNC			1
#define BFD_MODE_DEMAND			2

/* Diagnostic Code (RFC 5880 Page 8) */
#define BFD_DIAG_NONE			0
#define BFD_DIAG_EXPIRED		1
#define BFD_DIAG_ECHO_FAILED		2
#define BFD_DIAG_NEIGHBOR_SIGDOWN	3
#define BFD_DIAG_FIB_RESET		4
#define BFD_DIAG_PATH_DOWN		5
#define BFD_DIAG_CONCAT_PATH_DOWN	6
#define BFD_DIAG_ADMIN_DOWN		7
#define BFD_DIAG_CONCAT_REVERSE_DOWN	8

/* State (RFC 5880 Page 8) */
#define BFD_STATE_ADMINDOWN		0
#define BFD_STATE_DOWN			1
#define BFD_STATE_INIT			2
#define BFD_STATE_UP			3

/* Flags (RFC 5880 Page 8) */
#define BFD_FLAG_P			0x20
#define BFD_FLAG_F			0x10
#define BFD_FLAG_C			0x08
#define BFD_FLAG_A			0x04
#define BFD_FLAG_D			0x02
#define BFD_FLAG_M			0x01

struct sockaddr_bfd {
	uint8_t		bs_len;		/* total length */
	uint8_t		bs_family;	/* address family */
	/* above matches sockaddr_storage */

	/* Sorted for bit boundaries */
	uint16_t	bs_mode;
	uint32_t	bs_localdiscr;

	int64_t		bs_uptime;

	int64_t		bs_lastuptime;

	uint32_t	bs_mintx;
	uint32_t	bs_minrx;

	uint32_t	bs_minecho;
	uint32_t	bs_localdiag;

	uint32_t	bs_remotediscr;
	uint32_t	bs_remotediag;

	uint16_t	bs_multiplier;
	uint16_t	bs_pad0;
	int		bs_state;
	int		bs_remotestate;
	int		bs_laststate;
	int		bs_error;

	/* add padding to reach a power of two */
	uint64_t	bs_pad1;
};

struct bfd_msghdr {
	uint16_t	bm_msglen;
	uint8_t		bm_version;
	uint8_t		bm_type;
	uint16_t	bm_hdrlen;
	uint16_t	bm_index;

	uint16_t	bm_tableid;
	uint8_t		bm_priority;
	uint8_t		bm_mpls;
	int		bm_addrs;
	int		bm_flags;
	/* above matches rt_msghdr */
	uint16_t	bm_pad0;	/* for 4 byte boundary */

	struct sockaddr_bfd	bm_sa;	/* bfd msg for userland */
};

#ifdef _KERNEL
/* state machine from RFC 5880 6.8.1*/
struct bfd_neighbor {
	uint32_t	bn_lstate;		/* SessionState */
	uint32_t	bn_rstate;		/* RemoteSessionState */
	uint32_t	bn_ldiscr;		/* LocalDiscr */
	uint32_t	bn_rdiscr;		/* RemoteDiscr */
	uint32_t	bn_ldiag;		/* LocalDiag */
	uint32_t	bn_rdiag;		/* RemoteDiag */
	uint32_t	bn_mintx;		/* DesiredMinTxInterval */
	uint32_t	bn_req_minrx;		/* RequiredMinRxInterval */
	uint32_t	bn_rminrx;		/* RemoteMinRxInterval */
	uint32_t	bn_demand;		/* DemandMode */
	uint32_t	bn_rdemand;		/* RemoteDemandMode */
	uint32_t	bn_mult;		/* DetectMult */
	uint32_t	bn_authtype;		/* AuthType */
	uint32_t	bn_rauthseq;		/* RcvAuthSeq */
	uint32_t	bn_lauthseq;		/* XmitAuthSeq */
	uint32_t	bn_authseqknown;	/* AuthSeqKnown */
};

struct bfd_config {
	TAILQ_ENTRY(bfd_config)	 bc_entry;
	struct socket		*bc_so;
	struct socket		*bc_upcallso;
	struct socket		*bc_soecho;
	struct socket		*bc_sosend;
	struct rtentry		*bc_rt;
	struct bfd_neighbor	*bc_neighbor;
	struct timeval		*bc_time;
	struct task		 bc_bfd_task;
	struct task		 bc_bfd_send_task;
	struct task		 bc_upcall_task;
	struct task		 bc_clear_task;
	struct timeout		 bc_timo_rx;
	struct timeout		 bc_timo_tx;
	time_t			 bc_lastuptime;
	int			 bc_laststate;
	int			 bc_state;
	int			 bc_mode;
	int			 bc_poll;
	int			 bc_error;
	int			 bc_minrx;
	int			 bc_mintx;
	int			 bc_minecho;
	int			 bc_multiplier;
};

struct sockaddr *bfd2sa(struct rtentry *, struct sockaddr_bfd *);

int		 bfdset(struct rtentry *);
void		 bfdclear(struct rtentry *);
void		 bfdinit(void);

#endif /* _KERNEL */

#endif /* _NET_BFD_H_ */
@


1.11
log
@move receiving and processing the BFD packet into a task
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.10 2017/01/19 23:18:29 phessler Exp $	*/
d140 1
@


1.10
log
@add hooks so we can query the current state of a BFD session

bfd session details are visible with "route -n get 192.0.2.1 -bfd"

OK mpi@@ deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.9 2016/09/20 10:41:43 phessler Exp $	*/
d131 1
d139 1
@


1.9
log
@we will also want the echo timing paramater
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.8 2016/09/19 07:28:40 phessler Exp $	*/
d56 33
d90 9
a98 4
	unsigned short	bm_msglen;
	unsigned char	bm_version;
	unsigned char	bm_type;
	unsigned short	bm_hdrlen;
d100 3
a102 1
	/* above matches rtm_msghdr */
d104 1
a104 17
	uint16_t	bm_mode;
	uint32_t	bm_mintx;
	uint32_t	bm_minrx;
	uint32_t	bm_minecho;
	uint16_t	bm_multiplier;

	time_t		bm_uptime;
	time_t		bm_lastuptime;
	int		bm_state;
	int		bm_remotestate;
	int		bm_laststate;
	int		bm_error;

	uint32_t	bm_localdiscr;
	uint32_t	bm_localdiag;
	uint32_t	bm_remotediscr;
	uint32_t	bm_remotediag;
d151 2
@


1.8
log
@once again, fix the bfd state-machine.  this time, tested against a
juniper which rolled through several states during testing
(up->admindown->up->timeout->up)
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.7 2016/09/17 07:35:05 phessler Exp $	*/
d67 1
@


1.7
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.6 2016/09/15 13:09:44 phessler Exp $	*/
d61 1
d72 1
d119 1
d123 1
@


1.6
log
@adjust whitespace and remove an unused struct
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.5 2016/09/15 12:34:48 phessler Exp $	*/
d57 21
a77 20
	unsigned short rtm_msglen;     /* to skip over non-understood msgs */
	unsigned char  rtm_version;    /* future binary compatibility */
	unsigned char  rtm_type;       /* message type */
	unsigned short rtm_hdrlen;     /* to skip over the header */

	uint16_t	mode;		/* */
	uint32_t	mintx;		/* minimum time (us) to send */
	uint32_t	minrx;		/* minimum window (us) to receive */
	uint16_t	multiplier;	/* Retry backoff multiplier */

	time_t		uptime;
	time_t		lastuptime;
	int		state;
	int		laststate;
	int		error;

	uint32_t	localdiscr;
	uint32_t	localdiag;
	uint32_t	remotediscr;
	uint32_t	remotediag;
d81 40
a120 20
struct bfd_softc {
	TAILQ_ENTRY(bfd_softc)	 bfd_next;
	struct socket		*sc_so;
	struct socket		*sc_soecho;
	struct socket		*sc_sosend;
	struct rtentry		*sc_rt;
	struct bfd_state	*sc_peer;
	struct timeval		*sc_time;
	struct task		 sc_bfd_task;
	struct task		 sc_bfd_send_task;
	struct timeout		 sc_timo_rx;
	struct timeout		 sc_timo_tx;
	time_t			 lastuptime;
	int			 laststate;
	int			 state;
	int			 mode;
	int			 error;
	int			 minrx;
	int			 mintx;
	int			 multiplier;
a121 1
#endif /* _KERNEL */
d123 2
a124 2
int		 bfd_rtalloc(struct rtentry *);
void		 bfd_rtfree(struct rtentry *);
a125 1
void		 bfddestroy(void);
d127 1
a127 1
struct bfd_softc *bfd_lookup(struct rtentry *);
@


1.5
log
@protect a kernel only structure with _KERNEL, means userland doesn't
need extra includes
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.4 2016/09/12 15:24:51 phessler Exp $	*/
d28 2
a29 2
#define BFD_MODE_ASYNC		1
#define BFD_MODE_DEMAND		2
a55 1

a101 4

struct bfd_flags {
	int		 version;
};
@


1.4
log
@Add data about how long the session has been in the current state, and
the previous state.

Shuffle some headers so they can be used outside of our own engine.

While here, correct the spelling of the two modes for BFD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.3 2016/09/07 09:21:33 mpi Exp $	*/
d80 1
d102 1
@


1.3
log
@Use C99 types.

ok claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.2 2016/09/04 09:39:01 claudio Exp $	*/
a22 1

d28 29
d64 2
a65 2
	uint32_t	minimum;	/* minimum time (us) to send */
	uint32_t	rx;		/* minimum window (us) to receive */
d68 10
a79 1

d87 1
d92 2
d110 2
@


1.2
log
@Make it possible to toggle RTF_BFD via RTM_CHANGE and fix some minor things
in bfd.c. Make bfd_rtfree() a void function.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bfd.h,v 1.1 2016/09/03 14:14:20 phessler Exp $	*/
d30 9
a38 9
	u_short rtm_msglen;     /* to skip over non-understood messages */ 
	u_char  rtm_version;    /* future binary compatibility */
	u_char  rtm_type;       /* message type */
	u_short rtm_hdrlen;     /* sizeof(rt_msghdr) to skip over the header */

	u_int16_t	mode;		/* */
	u_int32_t	minimum;	/* minimum time (us) to send */
	u_int32_t	rx;		/* minimum window (us) to receive */
	u_int16_t	multiplier;	/* Retry backoff multiplier */
@


1.1
log
@add support for Bidirectional Forwarding Detection (RFC 5880/5881).
This is only the engine, the glue will come soon.

We can negotiate a BFD session against a Juniper MX, and against
ourselves.

Requires a lot of cleanup, but we can do that in the tree.

discussed with the network hackers
OK claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
a67 2
int		 bfd_rtalloc(struct rtentry *, struct bfd_flags *);
int		 bfd_rtfree(struct rtentry *);
@

