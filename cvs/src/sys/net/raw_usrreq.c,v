head	1.31;
access;
symbols
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.10
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.18
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.16
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.3.0.16
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.14
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.30;
commitid	ZsxSSZJSFxZH81LL;

1.30
date	2017.03.07.09.23.27;	author mpi;	state Exp;
branches;
next	1.29;
commitid	ilH9l7TRBZ95J9uu;

1.29
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.28;
commitid	LtQeAWkATeJFPv2t;

1.28
date	2017.01.23.16.31.24;	author bluhm;	state Exp;
branches;
next	1.27;
commitid	9EAe7cRTLFNc3XTC;

1.27
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.26;
commitid	QqHqT2WhCBWqYgGJ;

1.26
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.25;
commitid	wuzpseLx3Ntn9R7b;

1.25
date	2016.10.08.03.32.25;	author claudio;	state Exp;
branches;
next	1.24;
commitid	TwpI1hIUYPQuJA1f;

1.24
date	2016.09.05.16.07.01;	author claudio;	state Exp;
branches;
next	1.23;
commitid	SePp8JOpR5x9ssaB;

1.23
date	2016.09.05.15.12.30;	author claudio;	state Exp;
branches;
next	1.22;
commitid	9stAtK16gR2yeKoN;

1.22
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.21;
commitid	ILbVM1M3uPNjwswz;

1.21
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	ncpqEGjDtSFuLAgn;

1.20
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.19;
commitid	J4OPNuggl4DOKGzM;

1.19
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.18;
commitid	hN5bFCE56DrAjl99;

1.18
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.17;
commitid	p4LJxGKbi0BU2cG6;

1.17
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.16;
commitid	ZqXwxwmeo3l29NOg;

1.16
date	2012.12.12.17.23.53;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2012.11.27.17.29.07;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2012.01.11.23.47.06;	author bluhm;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.03.16.09.09;	author blambert;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.28.23.17.45;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.23.28.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.11.05.38.47;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.11.05.13.37;	author jason;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	98.09.17.12.29.55;	author deraadt;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	96.03.03.21.07.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.07;	author deraadt;	state Exp;
branches;
next	;

1.3.8.1
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.3.8.3;

1.3.8.3
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.3.8.4;

1.3.8.4
date	2003.06.07.11.06.07;	author ho;	state Exp;
branches;
next	1.3.8.5;

1.3.8.5
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@/*	$OpenBSD: raw_usrreq.c,v 1.30 2017/03/07 09:23:27 mpi Exp $	*/
/*	$NetBSD: raw_usrreq.c,v 1.11 1996/02/13 22:00:43 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)raw_usrreq.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/systm.h>

#include <net/netisr.h>
#include <net/raw_cb.h>

#include <sys/stdarg.h>
/*
 * Initialize raw connection block q.
 */
void
raw_init(void)
{

	LIST_INIT(&rawcb);
}

int
raw_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control, struct proc *p)
{
	struct rawcb *rp = sotorawcb(so);
	int error = 0;
	int len;

	soassertlocked(so);

	if (req == PRU_CONTROL)
		return (EOPNOTSUPP);
	if (control && control->m_len) {
		m_freem(m);
		return (EOPNOTSUPP);
	}
	if (rp == 0) {
		m_freem(m);
		return (EINVAL);
	}
	switch (req) {
	/*
	 * Destroy state just before socket deallocation.
	 * Flush data or not depending on the options.
	 */
	case PRU_DETACH:
		if (rp == 0) {
			error = ENOTCONN;
			break;
		}
		raw_detach(rp);
		break;

	case PRU_CONNECT:
	case PRU_BIND:
	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	case PRU_DISCONNECT:
		if (rp->rcb_faddr == 0) {
			error = ENOTCONN;
			break;
		}
		raw_disconnect(rp);
		soisdisconnected(so);
		break;

	/*
	 * Mark the connection as being incapable of further input.
	 */
	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	/*
	 * Ship a packet out.  The appropriate raw output
	 * routine handles any massaging necessary.
	 */
	case PRU_SEND:
		if (nam) {
			if (rp->rcb_faddr) {
				error = EISCONN;
				break;
			}
			rp->rcb_faddr = mtod(nam, struct sockaddr *);
		} else if (rp->rcb_faddr == 0) {
			error = ENOTCONN;
			break;
		}
		error = (*so->so_proto->pr_output)(m, so, NULL, NULL);
		m = NULL;
		if (nam)
			rp->rcb_faddr = 0;
		break;

	case PRU_ABORT:
		raw_disconnect(rp);
		sofree(so);
		soisdisconnected(so);
		break;

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize.
		 */
		return (0);

	/*
	 * Not supported.
	 */
	case PRU_RCVOOB:
	case PRU_RCVD:
		return (EOPNOTSUPP);

	case PRU_LISTEN:
	case PRU_ACCEPT:
	case PRU_SENDOOB:
		error = EOPNOTSUPP;
		break;

	case PRU_SOCKADDR:
		if (rp->rcb_laddr == 0) {
			error = EINVAL;
			break;
		}
		len = rp->rcb_laddr->sa_len;
		bcopy((caddr_t)rp->rcb_laddr, mtod(nam, caddr_t), (unsigned)len);
		nam->m_len = len;
		break;

	case PRU_PEERADDR:
		if (rp->rcb_faddr == 0) {
			error = ENOTCONN;
			break;
		}
		len = rp->rcb_faddr->sa_len;
		bcopy((caddr_t)rp->rcb_faddr, mtod(nam, caddr_t), (unsigned)len);
		nam->m_len = len;
		break;

	default:
		panic("raw_usrreq");
	}
	m_freem(m);
	return (error);
}
@


1.30
log
@Do not grab the NET_LOCK() for routing sockets operations.

The only function that need the lock is rtm_output() as it messes with
the routing table.  So grab the lock there since it is safe to sleep
in a process context.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.29 2017/03/03 15:48:02 bluhm Exp $	*/
a78 14

	/*
	 * Allocate a raw control block and fill in the
	 * necessary info to allow packets to be routed to
	 * the appropriate raw interface routine.
	 */
	case PRU_ATTACH:
		if ((so->so_state & SS_PRIV) == 0) {
			error = EACCES;
			break;
		}
		error = raw_attach(so, (int)(long)nam);
		break;

@


1.29
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.28 2017/01/23 16:31:24 bluhm Exp $	*/
d66 1
a66 1
	NET_ASSERT_LOCKED();
@


1.28
log
@The function raw_input() has not been called since netiso has been
removed in 2004.  The comment about raw_input() above rip_input()
was added in 1981, but it is wrong since 1992.  After that it has
been copied to rip6_input().  (*pr_input)() is never called with
the parameters (mbuf, sockproto, sockaddr, sockaddr).
So retire raw_input().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.27 2016/12/19 08:36:49 mpi Exp $	*/
d142 1
a142 1
		error = (*so->so_proto->pr_output)(m, so);
@


1.27
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.26 2016/11/21 09:09:06 mpi Exp $	*/
a55 76
}


/*
 * Raw protocol input routine.  Find the socket
 * associated with the packet(s) and move them over.  If
 * nothing exists for this packet, drop it.
 */
/*
 * Raw protocol interface.
 */
void
raw_input(struct mbuf *m0, ...)
{
	struct rawcb *rp;
	struct mbuf *m = m0;
	int sockets = 0;
	struct socket *last;
	va_list ap;
	struct sockproto *proto;
	struct sockaddr *src, *dst;
	
	va_start(ap, m0);
	proto = va_arg(ap, struct sockproto *);
	src = va_arg(ap, struct sockaddr *);
	dst = va_arg(ap, struct sockaddr *);
	va_end(ap);

	last = 0;
	LIST_FOREACH(rp, &rawcb, rcb_list) {
		if (rp->rcb_socket->so_state & SS_CANTRCVMORE)
			continue;
		if (rp->rcb_proto.sp_family != proto->sp_family)
			continue;
		if (rp->rcb_proto.sp_protocol  &&
		    rp->rcb_proto.sp_protocol != proto->sp_protocol)
			continue;
		/*
		 * We assume the lower level routines have
		 * placed the address in a canonical format
		 * suitable for a structure comparison.
		 *
		 * Note that if the lengths are not the same
		 * the comparison will fail at the first byte.
		 */
#define	equal(a1, a2) \
  (bcmp((caddr_t)(a1), (caddr_t)(a2), a1->sa_len) == 0)
		if (rp->rcb_laddr && !equal(rp->rcb_laddr, dst))
			continue;
		if (rp->rcb_faddr && !equal(rp->rcb_faddr, src))
			continue;
		if (last) {
			struct mbuf *n;
			if ((n = m_copym(m, 0, M_COPYALL, M_NOWAIT)) != NULL) {
				if (sbappendaddr(&last->so_rcv, src,
				    n, (struct mbuf *)NULL) == 0)
					/* should notify about lost packet */
					m_freem(n);
				else {
					sorwakeup(last);
					sockets++;
				}
			}
		}
		last = rp->rcb_socket;
	}
	if (last) {
		if (sbappendaddr(&last->so_rcv, src,
		    m, (struct mbuf *)NULL) == 0)
			m_freem(m);
		else {
			sorwakeup(last);
			sockets++;
		}
	} else
		m_freem(m);
@


1.26
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.25 2016/10/08 03:32:25 claudio Exp $	*/
d142 1
a142 1
	splsoftassert(IPL_SOFTNET);
@


1.25
log
@Instead of setting errno and then doing a goto do a m_freem() and return error.
Same thing but nicer to read. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.24 2016/09/05 16:07:01 claudio Exp $	*/
d140 3
a142 1
	int len, s;
a153 1
	s = splsoftnet();
a233 1
		splx(s);
a240 1
		splx(s);
a271 1
	splx(s);
@


1.24
log
@Remove code that was never enabled, it will not happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.23 2016/09/05 15:12:30 claudio Exp $	*/
d145 2
a146 2
		error = EOPNOTSUPP;
		goto release;
d149 2
a150 2
		error = EINVAL;
		goto release;
a273 1
release:
@


1.23
log
@Kill raw_ctlinput() this function is INCOMPLETE since rev 1.1 and is not
needed. All callers using the protosw pr_ctlinput pointer do a NULL check
before so there is no need to provide the function.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.22 2015/12/05 10:07:55 tedu Exp $	*/
a179 25
#ifdef notdef
	/*
	 * If a socket isn't bound to a single address,
	 * the raw input routine will hand it anything
	 * within that protocol family (assuming there's
	 * nothing else around it should go to). 
	 */
	case PRU_CONNECT:
		if (rp->rcb_faddr) {
			error = EISCONN;
			break;
		}
		nam = m_copym(nam, 0, M_COPYALL, M_WAIT);
		rp->rcb_faddr = mtod(nam, struct sockaddr *);
		soisconnected(so);
		break;

	case PRU_BIND:
		if (rp->rcb_laddr) {
			error = EINVAL;			/* XXX */
			break;
		}
		error = raw_bind(so, nam);
		break;
#else
a181 1
#endif
@


1.22
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.21 2015/07/15 22:16:42 deraadt Exp $	*/
a131 10
}

void *
raw_ctlinput(int cmd, struct sockaddr *arg, u_int rdomain, void *d)
{

	if (cmd < 0 || cmd >= PRC_NCMDS)
		return NULL;
	return NULL;
	/* INCOMPLETE */
@


1.21
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.20 2015/06/30 15:30:17 mpi Exp $	*/
a133 1
/*ARGSUSED*/
a143 1
/*ARGSUSED*/
@


1.20
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.19 2015/05/13 10:42:46 jsg Exp $	*/
d313 1
a313 2
	if (m != NULL)
		m_freem(m);
@


1.19
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.18 2015/03/14 03:38:51 jsg Exp $	*/
d109 1
a109 1
			if ((n = m_copy(m, 0, (int)M_COPYALL)) != NULL) {
@


1.18
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.17 2014/09/08 06:24:13 jsg Exp $	*/
d111 1
a111 1
				    n, (struct mbuf *)0) == 0)
d124 1
a124 1
		    m, (struct mbuf *)0) == 0)
@


1.17
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.16 2012/12/12 17:23:53 mikeb Exp $	*/
a43 1
#include <net/if.h>
@


1.16
log
@Rearrange the code a bit to prevent splx() from being called with an
uninitialized variable.  Found by Owain G. Ainsworth, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.15 2012/11/27 17:29:07 mikeb Exp $	*/
a44 1
#include <net/route.h>
@


1.15
log
@remove incorrect splnet usage in pfkey interface
and make raw_usrreq do an splsoftnet on its own;
joint work with david hill, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.14 2012/01/11 23:47:06 bluhm Exp $	*/
d224 1
a224 1
		goto release;
d313 1
a314 1
	splx(s);
@


1.14
log
@Ansify raw_... function definitions.  No binary change.
from Michael W. Bombardieri; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.13 2011/04/03 16:09:09 blambert Exp $	*/
d154 1
a154 1
	int len;
d166 1
d273 1
d281 1
d314 1
@


1.13
log
@Don't attempt to enqueue mbufs on sockets marked as SS_CANTRCVMORE, as
was done earlier for routing sockets.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.12 2009/11/13 20:54:05 claudio Exp $	*/
d54 1
a54 1
raw_init()
d138 1
a138 5
raw_ctlinput(cmd, arg, rdomain, d)
	int cmd;
	struct sockaddr *arg;
	u_int rdomain;
	void *d;
d149 2
a150 5
raw_usrreq(so, req, m, nam, control, p)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
	struct proc *p;
@


1.12
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.11 2008/05/23 15:51:12 thib Exp $	*/
d88 2
@


1.11
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.10 2004/01/03 14:08:53 espie Exp $	*/
d136 1
a136 1
raw_ctlinput(cmd, arg, d)
d139 1
@


1.10
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.9 2003/12/10 07:22:42 itojun Exp $	*/
d150 1
a150 1
raw_usrreq(so, req, m, nam, control)
d154 1
@


1.9
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.8 2003/09/28 23:17:45 cloder Exp $	*/
d49 1
a49 1
#include <machine/stdarg.h>
@


1.8
log
@Correct off-by-ones with respect to PRC_NCMDS.  Mostly from FreeBSD.
OK krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.7 2003/06/02 23:28:12 millert Exp $	*/
d72 3
a74 3
	register struct rawcb *rp;
	register struct mbuf *m = m0;
	register int sockets = 0;
d77 1
a77 1
	register struct sockproto *proto;
d155 2
a156 2
	register struct rawcb *rp = sotorawcb(so);
	register int error = 0;
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.6 2002/09/11 05:38:47 itojun Exp $	*/
d142 1
a142 1
	if (cmd < 0 || cmd > PRC_NCMDS)
@


1.6
log
@KNF - return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.5 2002/03/15 18:19:52 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.5
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.4 2001/12/11 05:13:37 jason Exp $	*/
d286 1
a286 1
		return(EOPNOTSUPP);
@


1.4
log
@Use queue.h macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.3 1998/09/17 12:29:55 deraadt Exp $	*/
a73 1
#if __STDC__
a74 5
#else
raw_input(m0, va_alist)
	struct mbuf *m0;
	va_dcl
#endif
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.4 2001/12/11 05:13:37 jason Exp $	*/
d74 1
d76 5
@


1.4.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.4.2.1 2002/06/11 03:30:46 art Exp $	*/
d286 1
a286 1
		return (EOPNOTSUPP);
@


1.3
log
@avoid panic; garath@@code.ridgefield.org
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.2 1996/03/03 21:07:18 niklas Exp $	*/
d97 1
a97 1
	for (rp = rawcb.lh_first; rp != 0; rp = rp->rcb_list.le_next) {
@


1.3.8.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 1
a97 1
	LIST_FOREACH(rp, &rawcb, rcb_list) {
@


1.3.8.2
log
@Merge in -current from roughly a week ago
@
text
@d74 1
d76 5
@


1.3.8.3
log
@Sync the SMP branch with 3.3
@
text
@d286 1
a286 1
		return (EOPNOTSUPP);
@


1.3.8.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_usrreq.c,v 1.3.8.3 2003/03/28 00:41:29 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.8.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
#include <sys/stdarg.h>
d72 3
a74 3
	struct rawcb *rp;
	struct mbuf *m = m0;
	int sockets = 0;
d77 1
a77 1
	struct sockproto *proto;
d142 1
a142 1
	if (cmd < 0 || cmd >= PRC_NCMDS)
d155 2
a156 2
	struct rawcb *rp = sotorawcb(so);
	int error = 0;
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d230 3
a233 1

@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: raw_usrreq.c,v 1.10 1995/06/12 00:46:55 mycroft Exp $	*/
d46 1
d53 1
d74 4
a77 1
raw_input(m0, proto, src, dst)
d79 2
a80 2
	register struct sockproto *proto;
	struct sockaddr *src, *dst;
d86 9
d119 1
a119 1
			if (n = m_copy(m, 0, (int)M_COPYALL)) {
d145 2
a146 2
void
raw_ctlinput(cmd, arg)
d149 1
d153 2
a154 1
		return;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
