head	1.74;
access;
symbols
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.72.0.6
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.69.0.4
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.64.0.6
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.63.0.2
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.62.0.2
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.61.0.2
	OPENBSD_5_2_BASE:1.61
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.6
	OPENBSD_5_0:1.60.0.4
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.58.0.2
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.56.0.12
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.56.0.14
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.56.0.10
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.56.0.8
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.56.0.6
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.56.0.4
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.55.0.6
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.55.0.4
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.55.0.2
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.52.0.2
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.51.0.2
	OPENBSD_3_6_BASE:1.51
	SMP_SYNC_A:1.50
	SMP_SYNC_B:1.50
	OPENBSD_3_5:1.50.0.2
	OPENBSD_3_5_BASE:1.50
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	UBC_SYNC_A:1.47
	OPENBSD_3_3:1.47.0.2
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.43.0.2
	OPENBSD_3_2_BASE:1.43
	OPENBSD_3_1:1.41.0.4
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.43
	UBC:1.41.0.2
	UBC_BASE:1.41
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.17.0.4
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.2
	SMP_BASE:1.17
	kame_19991208:1.13
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.74
date	2017.02.28.16.46.27;	author bluhm;	state Exp;
branches;
next	1.73;
commitid	rmbXKt3efXwOBuCw;

1.73
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.72;
commitid	6c6qq5OdS4VVnyVM;

1.72
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.71;
commitid	CLwtYUTkBZ3FXV1w;

1.71
date	2015.12.02.12.43.59;	author naddy;	state Exp;
branches;
next	1.70;
commitid	duHJNnO9Vx1nKUKx;

1.70
date	2015.11.03.01.50.36;	author mikeb;	state Exp;
branches;
next	1.69;
commitid	HPo8Yd5Adcuitvw4;

1.69
date	2015.05.23.12.38.53;	author markus;	state Exp;
branches;
next	1.68;
commitid	Mgx7ewWJ5ueyVCxt;

1.68
date	2015.04.17.10.04.37;	author mikeb;	state Exp;
branches;
next	1.67;
commitid	KP3L4W0chjmfJmS7;

1.67
date	2015.04.16.19.18.10;	author markus;	state Exp;
branches;
next	1.66;
commitid	95HrEjJkuhjwwAbo;

1.66
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.65;
commitid	bQi1IVHgugweH5gs;

1.65
date	2014.12.28.10.02.37;	author tedu;	state Exp;
branches;
next	1.64;
commitid	cPvnXrnDy9of9D0l;

1.64
date	2013.10.24.18.50.16;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.09.02.27.07;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2012.09.18.09.24.45;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.60;

1.60
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.59;

1.59
date	2010.09.22.12.48.52;	author mikeb;	state Exp;
branches;
next	1.58;

1.58
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.27.15.29.55;	author hshoexer;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.25.05.47.53;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.04.22.18.47;	author hshoexer;	state Exp;
branches;
next	1.52;

1.52
date	2004.11.26.18.02.22;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2004.08.10.16.17.05;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.27.09.27.17;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2003.07.24.09.59.02;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.24.21.34.39;	author jason;	state Exp;
branches;
next	1.46;

1.46
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.16.19.54.20;	author jason;	state Exp;
branches;
next	1.44;

1.44
date	2003.02.15.19.21.05;	author jason;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.07.04.47.06;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.31.01.39.05;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.18.23.07.49;	author deraadt;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.07.05.08.38.32;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.05.08.27.39;	author jjbg;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.09.06.16.39;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.08.19.37.18;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.08.02.53.49;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.05.00.17.49;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.30.18.22.10;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.30.16.44.11;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.30.11.27.33;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.30.10.46.59;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.05.00.33.46;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.28.20.03.01;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.04.20.50.40;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.14.18.07.29;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.18.03.19.23;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.17.04.08.44;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.11.05.07.32;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.11.05.00.33;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.09.22.20.02;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.14.06.23.51;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.09.22.16.54;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.19.08.38.58;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.19.03.19.39;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.27.08.09.06;	author angelos;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.01.13.00.34.59;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.12.21.39.26;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.10.04.28.44;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	99.12.04.23.20.55;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	99.11.04.11.17.08;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	99.07.06.20.17.52;	author cmetz;	state Exp;
branches;
next	1.10;

1.10
date	99.07.02.23.37.33;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.03.31.01.20.08;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.03.27.21.04.18;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	99.03.24.17.00.43;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.03.02.22.01.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.02.24.22.36.04;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.11.07.08.29.53;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.04.28.19.21.15;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.04.27.04.34.07;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	97.04.24.23.01.00;	author angelos;	state Exp;
branches;
next	;

1.17.2.1
date	2001.05.14.22.40.03;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.07.04.10.54.16;	author niklas;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.17.2.6;

1.17.2.6
date	2004.02.19.10.57.22;	author niklas;	state Exp;
branches;
next	;

1.41.2.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2003.05.19.22.29.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Depending on the addresses, ipsecctl(8) automatically groups sa
bundles together.  Extend the kernel interface to export the bundle
information to userland.  Then ipsecctl -ss -v can show the internal
relations.  Unfortunately the header SADB_X_EXT_PROTOCOL was reused
by SADB_X_GRPSPIS, so it cannot be used to transfer the second sa
type with sysctl.  Introduce a new SADB_X_EXT_SATYPE2 and use it
consistently.
OK hshoexer@@ markus@@
@
text
@/* $OpenBSD: pfkeyv2.h,v 1.73 2017/01/24 10:08:30 krw Exp $ */
/*
 *	@@(#)COPYRIGHT	1.1 (NRL) January 1998
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#ifndef _NET_PFKEY_V2_H_
#define _NET_PFKEY_V2_H_

#define PF_KEY_V2			2
#define PFKEYV2_REVISION		199806L

/* This should be updated whenever the API is altered.  */
#define _OPENBSD_IPSEC_API_VERSION	2

#define SADB_RESERVED      0
#define SADB_GETSPI        1
#define SADB_UPDATE        2
#define SADB_ADD           3
#define SADB_DELETE        4
#define SADB_GET           5
#define SADB_ACQUIRE       6
#define SADB_REGISTER      7
#define SADB_EXPIRE        8
#define SADB_FLUSH         9
#define SADB_DUMP          10
#define SADB_X_PROMISC     11
#define SADB_X_ADDFLOW     12
#define SADB_X_DELFLOW     13
#define SADB_X_GRPSPIS     14
#define SADB_X_ASKPOLICY   15
#define SADB_X_SPDDUMP     16
#define SADB_MAX           16

struct sadb_msg {
	uint8_t sadb_msg_version;
	uint8_t sadb_msg_type;
	uint8_t sadb_msg_errno;
	uint8_t sadb_msg_satype;
	uint16_t sadb_msg_len;
	uint16_t sadb_msg_reserved;
	uint32_t sadb_msg_seq;
	uint32_t sadb_msg_pid;
};

struct sadb_ext {
	uint16_t sadb_ext_len;
	uint16_t sadb_ext_type;
};

struct sadb_sa {
	uint16_t sadb_sa_len;
	uint16_t sadb_sa_exttype;
	uint32_t sadb_sa_spi;
	uint8_t sadb_sa_replay;
	uint8_t sadb_sa_state;
	uint8_t sadb_sa_auth;
	uint8_t sadb_sa_encrypt;
	uint32_t sadb_sa_flags;
};

struct sadb_lifetime {
	uint16_t sadb_lifetime_len;
	uint16_t sadb_lifetime_exttype;
	uint32_t sadb_lifetime_allocations;
	uint64_t sadb_lifetime_bytes;
	uint64_t sadb_lifetime_addtime;
	uint64_t sadb_lifetime_usetime;
};

struct sadb_address {
	uint16_t sadb_address_len;
	uint16_t sadb_address_exttype;
	uint32_t sadb_address_reserved;
};

struct sadb_key {
	uint16_t sadb_key_len;
	uint16_t sadb_key_exttype;
	uint16_t sadb_key_bits;
	uint16_t sadb_key_reserved;
};

struct sadb_ident {
	uint16_t sadb_ident_len;
	uint16_t sadb_ident_exttype;
	uint16_t sadb_ident_type;
	uint16_t sadb_ident_reserved;
	uint64_t sadb_ident_id;
};

struct sadb_sens {
	uint16_t sadb_sens_len;
	uint16_t sadb_sens_exttype;
	uint32_t sadb_sens_dpd;
	uint8_t sadb_sens_sens_level;
	uint8_t sadb_sens_sens_len;
	uint8_t sadb_sens_integ_level;
	uint8_t sadb_sens_integ_len;
	uint32_t sadb_sens_reserved;
};

struct sadb_prop {
	uint16_t sadb_prop_len;
	uint16_t sadb_prop_exttype;
	uint8_t sadb_prop_num;
	uint8_t sadb_prop_replay;
	uint16_t sadb_prop_reserved;
};

struct sadb_comb {
	uint8_t sadb_comb_auth;
	uint8_t sadb_comb_encrypt;
	uint16_t sadb_comb_flags;
	uint16_t sadb_comb_auth_minbits;
	uint16_t sadb_comb_auth_maxbits;
	uint16_t sadb_comb_encrypt_minbits;
	uint16_t sadb_comb_encrypt_maxbits;
	uint32_t sadb_comb_reserved;
	uint32_t sadb_comb_soft_allocations;
	uint32_t sadb_comb_hard_allocations;
	uint64_t sadb_comb_soft_bytes;
	uint64_t sadb_comb_hard_bytes;
	uint64_t sadb_comb_soft_addtime;
	uint64_t sadb_comb_hard_addtime;
	uint64_t sadb_comb_soft_usetime;
	uint64_t sadb_comb_hard_usetime;
};

struct sadb_supported {
	uint16_t sadb_supported_len;
	uint16_t sadb_supported_exttype;
	uint32_t sadb_supported_reserved;
};

struct sadb_alg {
	uint8_t sadb_alg_id;
	uint8_t sadb_alg_ivlen;
	uint16_t sadb_alg_minbits;
	uint16_t sadb_alg_maxbits;
	uint16_t sadb_alg_reserved;
};

struct sadb_spirange {
	uint16_t sadb_spirange_len;
	uint16_t sadb_spirange_exttype;
	uint32_t sadb_spirange_min;
	uint32_t sadb_spirange_max;
	uint32_t sadb_spirange_reserved;
};

struct sadb_protocol {
	uint16_t sadb_protocol_len;
	uint16_t sadb_protocol_exttype;
	uint8_t  sadb_protocol_proto;
	uint8_t  sadb_protocol_direction;
	uint8_t  sadb_protocol_flags;
	uint8_t  sadb_protocol_reserved2;
};

struct sadb_x_policy {
	uint16_t  sadb_x_policy_len;
	uint16_t  sadb_x_policy_exttype;
	u_int32_t sadb_x_policy_seq;
};

struct sadb_x_udpencap {
	uint16_t sadb_x_udpencap_len;
	uint16_t sadb_x_udpencap_exttype;
	uint16_t sadb_x_udpencap_port;
	uint16_t sadb_x_udpencap_reserved;
};

struct sadb_x_tag {
	uint16_t  sadb_x_tag_len;
	uint16_t  sadb_x_tag_exttype;
	u_int32_t sadb_x_tag_taglen;
};

struct sadb_x_tap {
	uint16_t  sadb_x_tap_len;
	uint16_t  sadb_x_tap_exttype;
	u_int32_t sadb_x_tap_unit;
};

#ifdef _KERNEL
#define SADB_X_GETSPROTO(x) \
	( (x) == SADB_SATYPE_AH ? IPPROTO_AH :\
	(x) == SADB_SATYPE_ESP ? IPPROTO_ESP :\
	(x) == SADB_X_SATYPE_TCPSIGNATURE ? IPPROTO_TCP :\
	(x) == SADB_X_SATYPE_IPCOMP ? IPPROTO_IPCOMP: IPPROTO_IPIP )
#endif

#define SADB_EXT_RESERVED             0
#define SADB_EXT_SA                   1
#define SADB_EXT_LIFETIME_CURRENT     2
#define SADB_EXT_LIFETIME_HARD        3
#define SADB_EXT_LIFETIME_SOFT        4
#define SADB_EXT_ADDRESS_SRC          5
#define SADB_EXT_ADDRESS_DST          6
#define SADB_EXT_ADDRESS_PROXY        7
#define SADB_EXT_KEY_AUTH             8
#define SADB_EXT_KEY_ENCRYPT          9
#define SADB_EXT_IDENTITY_SRC         10
#define SADB_EXT_IDENTITY_DST         11
#define SADB_EXT_SENSITIVITY          12
#define SADB_EXT_PROPOSAL             13
#define SADB_EXT_SUPPORTED_AUTH	      14
#define SADB_EXT_SUPPORTED_ENCRYPT    15
#define SADB_EXT_SPIRANGE             16
#define SADB_X_EXT_SRC_MASK           17
#define SADB_X_EXT_DST_MASK           18
#define SADB_X_EXT_PROTOCOL           19
#define SADB_X_EXT_FLOW_TYPE          20
#define SADB_X_EXT_SRC_FLOW           21
#define SADB_X_EXT_DST_FLOW           22
#define SADB_X_EXT_SA2                23
#define SADB_X_EXT_DST2               24
#define SADB_X_EXT_POLICY             25
#define SADB_X_EXT_LOCAL_CREDENTIALS  26
#define SADB_X_EXT_REMOTE_CREDENTIALS 27
#define SADB_X_EXT_LOCAL_AUTH         28
#define SADB_X_EXT_REMOTE_AUTH        29
#define SADB_X_EXT_SUPPORTED_COMP     30
#define SADB_X_EXT_UDPENCAP           31
#define SADB_X_EXT_LIFETIME_LASTUSE   32
#define SADB_X_EXT_TAG                33
#define SADB_X_EXT_TAP                34
#define SADB_X_EXT_SATYPE2            35
#define SADB_EXT_MAX                  35

/* Fix pfkeyv2.c struct pfkeyv2_socket if SATYPE_MAX > 31 */
#define SADB_SATYPE_UNSPEC		 0
#define SADB_SATYPE_AH			 1
#define SADB_SATYPE_ESP			 2
#define SADB_SATYPE_RSVP		 3
#define SADB_SATYPE_OSPFV2		 4
#define SADB_SATYPE_RIPV2		 5
#define SADB_SATYPE_MIP			 6
#define SADB_X_SATYPE_IPIP		 7
#define SADB_X_SATYPE_TCPSIGNATURE	 8
#define SADB_X_SATYPE_IPCOMP		 9
#define SADB_SATYPE_MAX			 9

#define SADB_SASTATE_LARVAL   0
#define SADB_SASTATE_MATURE   1
#define SADB_SASTATE_DYING    2
#define SADB_SASTATE_DEAD     3
#define SADB_SASTATE_MAX      3

#define SADB_AALG_NONE               0
#define SADB_AALG_MD5HMAC            2
#define SADB_AALG_SHA1HMAC           3
#define SADB_X_AALG_SHA2_256         5
#define SADB_X_AALG_SHA2_384         6
#define SADB_X_AALG_SHA2_512         7
#define SADB_X_AALG_RIPEMD160HMAC    8
#define SADB_X_AALG_AES128GMAC       9
#define SADB_X_AALG_AES192GMAC       10
#define SADB_X_AALG_AES256GMAC       11
#define SADB_X_AALG_CHACHA20POLY1305 12
#define SADB_AALG_MAX                12

#define SADB_EALG_NONE        0
#define SADB_EALG_3DESCBC     3
#define SADB_X_EALG_CAST      6
#define SADB_X_EALG_BLF       7
#define SADB_EALG_NULL        11
#define SADB_X_EALG_AES       12
#define SADB_X_EALG_AESCTR    13
#define SADB_X_EALG_AESGCM8   18
#define SADB_X_EALG_AESGCM12  19
#define SADB_X_EALG_AESGCM16  20
#define SADB_X_EALG_AESGMAC   21
#define SADB_X_EALG_CHACHA20POLY1305 22
#define SADB_EALG_MAX         22

#define SADB_X_CALG_NONE	0
#define SADB_X_CALG_OUI		1
#define SADB_X_CALG_DEFLATE	2
#define SADB_X_CALG_LZS		3
#define SADB_X_CALG_MAX		3

#define SADB_SAFLAGS_PFS		0x001	/* perfect forward secrecy */
#define SADB_X_SAFLAGS_TUNNEL		0x004	/* Force tunneling */
#define SADB_X_SAFLAGS_CHAINDEL		0x008	/* Delete whole SA chain */
#define SADB_X_SAFLAGS_UDPENCAP		0x200	/* ESP in UDP  */
#define SADB_X_SAFLAGS_ESN		0x400	/* Extended Sequence Number */

#define SADB_X_POLICYFLAGS_POLICY	0x0001	/* This is a static policy */

#define SADB_IDENTTYPE_RESERVED     0
#define SADB_IDENTTYPE_PREFIX       1
#define SADB_IDENTTYPE_FQDN         2
#define SADB_IDENTTYPE_USERFQDN     3
#define SADB_IDENTTYPE_MAX          3

#define SADB_KEY_FLAGS_MAX 0

#ifdef _KERNEL
#define PFKEYV2_LIFETIME_HARD      0
#define PFKEYV2_LIFETIME_SOFT      1
#define PFKEYV2_LIFETIME_CURRENT   2
#define PFKEYV2_LIFETIME_LASTUSE   3

#define PFKEYV2_IDENTITY_SRC       0
#define PFKEYV2_IDENTITY_DST       1

#define PFKEYV2_ENCRYPTION_KEY     0
#define PFKEYV2_AUTHENTICATION_KEY 1

#define PFKEYV2_SOCKETFLAGS_REGISTERED 1
#define PFKEYV2_SOCKETFLAGS_PROMISC    2

#define PFKEYV2_SENDMESSAGE_UNICAST    1
#define PFKEYV2_SENDMESSAGE_REGISTERED 2
#define PFKEYV2_SENDMESSAGE_BROADCAST  3
#endif /* _KERNEL */

#define SADB_X_FLOW_TYPE_USE           1
#define SADB_X_FLOW_TYPE_ACQUIRE       2
#define SADB_X_FLOW_TYPE_REQUIRE       3
#define SADB_X_FLOW_TYPE_BYPASS        4
#define SADB_X_FLOW_TYPE_DENY          5
#define SADB_X_FLOW_TYPE_DONTACQ       6

#ifdef _KERNEL
struct tdb;
struct socket;
struct mbuf;

#define EXTLEN(x) (((struct sadb_ext *)(x))->sadb_ext_len * sizeof(uint64_t))
#define PADUP(x) (((x) + sizeof(uint64_t) - 1) & ~(sizeof(uint64_t) - 1))

struct pfkey_version {
	int protocol;
	int (*create)(struct socket *socket);
	int (*release)(struct socket *socket);
	int (*send)(struct socket *socket, void *message, int len);
	int (*sysctl)(int *, u_int, void *, size_t *, void *, size_t);
};

struct pfkeyv2_socket {
	struct pfkeyv2_socket *next;
	struct socket *socket;
	int flags;
	uint32_t pid;
	uint32_t registration;    /* Increase size if SATYPE_MAX > 31 */
	uint rdomain;
};

struct dump_state {
	struct sadb_msg *sadb_msg;
	struct socket *socket;
};

int pfkeyv2_init(void);
int pfkeyv2_cleanup(void);
int pfkeyv2_parsemessage(void *, int, void **);
int pfkeyv2_expire(struct tdb *, u_int16_t);
int pfkeyv2_acquire(struct ipsec_policy *, union sockaddr_union *,
    union sockaddr_union *, u_int32_t *, struct sockaddr_encap *);

int pfkey_register(struct pfkey_version *version);
int pfkey_unregister(struct pfkey_version *version);
int pfkey_sendup(struct socket *socket, struct mbuf *packet, int more);

int pfkeyv2_create(struct socket *);
int pfkeyv2_get(struct tdb *, void **, void **, int *);
int pfkeyv2_policy(struct ipsec_acquire *, void **, void **);
int pfkeyv2_release(struct socket *);
int pfkeyv2_send(struct socket *, void *, int);
int pfkeyv2_sendmessage(void **, int, struct socket *, u_int8_t, int, u_int);
int pfkeyv2_dump_policy(struct ipsec_policy *, void **, void **, int *);
int pfkeyv2_dump_walker(struct tdb *, void *, int);
int pfkeyv2_flush_walker(struct tdb *, void *, int);
int pfkeyv2_get_proto_alg(u_int8_t, u_int8_t *, int *);
int pfkeyv2_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int pfkeyv2_sysctl_walker(struct tdb *, void *, int);
int pfkeyv2_ipo_walk(u_int, int (*)(struct ipsec_policy *, void *), void *);
int pfkeyv2_sysctl_dump(void *);
int pfkeyv2_sysctl_policydumper(struct ipsec_policy *, void *);

int pfdatatopacket(void *, int, struct mbuf **);

void export_address(void **, struct sockaddr *);
void export_identities(void **, struct ipsec_ids *, int, void **);
void export_lifetime(void **, struct tdb *, int);
void export_sa(void **, struct tdb *);
void export_flow(void **, u_int8_t, struct sockaddr_encap *,
    struct sockaddr_encap *, void **);
void export_key(void **, struct tdb *, int);
void export_udpencap(void **, struct tdb *);
void export_tag(void **, struct tdb *);
void export_tap(void **, struct tdb *);
void export_satype(void **, struct tdb *);

void import_address(struct sockaddr *, struct sadb_address *);
void import_identities(struct ipsec_ids **, int, struct sadb_ident *,
    struct sadb_ident *);
void import_key(struct ipsecinit *, struct sadb_key *, int);
void import_lifetime(struct tdb *, struct sadb_lifetime *, int);
void import_sa(struct tdb *, struct sadb_sa *, struct ipsecinit *);
void import_flow(struct sockaddr_encap *, struct sockaddr_encap *,
    struct sadb_address *, struct sadb_address *, struct sadb_address *,
    struct sadb_address *, struct sadb_protocol *, struct sadb_protocol *);
void import_udpencap(struct tdb *, struct sadb_x_udpencap *);
void import_tag(struct tdb *, struct sadb_x_tag *);
void import_tap(struct tdb *, struct sadb_x_tap *);
#endif /* _KERNEL */

#endif /* _NET_PFKEY_V2_H_ */
@


1.73
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.72 2015/12/09 21:41:50 naddy Exp $ */
d264 2
a265 1
#define SADB_EXT_MAX                  34
d431 1
@


1.72
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.71 2015/12/02 12:43:59 naddy Exp $ */
d4 1
a4 1
 * 
d8 1
a8 1
 * 
d16 4
a19 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d23 1
a23 1
 * 
d35 1
a35 1
 * 
@


1.71
log
@remove unimplemented PF_KEY algorithms; ok sthen@@ mpi@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.70 2015/11/03 01:50:36 mikeb Exp $ */
a298 1
#define SADB_EALG_DESCBC      2
@


1.70
log
@Plumb Chacha20-Poly1305 into the IPsec/ESP and PF_KEY frameworks

ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.69 2015/05/23 12:38:53 markus Exp $ */
a287 1
#define SADB_X_AALG_DES              4
a298 1
#define SADB_X_EALG_DES_IV64  1
a300 2
#define SADB_X_EALG_RC5       4
#define SADB_X_EALG_IDEA      5
a302 3
#define SADB_X_EALG_3IDEA     8
#define SADB_X_EALG_DES_IV32  9
#define SADB_X_EALG_RC4       10
@


1.69
log
@introduce ipsec-id bundles and use them for ipsecflowinfo,
fixes rekeying for l2tp/ipsec against multiple windows clients
and saves memory (for many SAs to same peers); feedback and ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.68 2015/04/17 10:04:37 mikeb Exp $ */
d296 2
a297 1
#define SADB_AALG_MAX                11
d317 2
a318 1
#define SADB_EALG_MAX         21
@


1.68
log
@Remove unsupported SADB_X_IDENTTYPE_CONNECTION;  OK markus, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.67 2015/04/16 19:18:10 markus Exp $ */
d427 1
a427 1
void export_identity(void **, struct ipsec_ref **);
d438 2
a439 1
void import_identity(struct ipsec_ref **, struct sadb_ident *);
@


1.67
log
@change {import,export}_identity so it can be used for policies; ok mikeb
(fixes sadb_ident_type conversion for policies)
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.66 2015/04/14 12:22:15 mikeb Exp $ */
d336 1
a336 2
#define SADB_X_IDENTTYPE_CONNECTION 4
#define SADB_IDENTTYPE_MAX          4
@


1.66
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.65 2014/12/28 10:02:37 tedu Exp $ */
d428 1
a428 1
void export_identity(void **, struct tdb *, int);
d439 1
a439 1
void import_identity(struct tdb *, struct sadb_ident *, int);
@


1.65
log
@remove KPDK. not really used, and a bad choice anyway. ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.64 2013/10/24 18:50:16 deraadt Exp $ */
a201 7
struct sadb_x_cred {
	uint16_t sadb_x_cred_len;
	uint16_t sadb_x_cred_exttype;
	uint16_t sadb_x_cred_type;
	uint16_t sadb_x_cred_reserved;
};

a360 18
#define SADB_X_CREDTYPE_NONE         0
#define SADB_X_CREDTYPE_X509         1   /* ASN1 encoding of the certificate */
#define SADB_X_CREDTYPE_KEYNOTE      2   /* NUL-terminated buffer */
#define SADB_X_CREDTYPE_MAX          3

#ifdef _KERNEL
#define PFKEYV2_AUTH_LOCAL           0
#define PFKEYV2_AUTH_REMOTE          1

#define PFKEYV2_CRED_LOCAL           0
#define PFKEYV2_CRED_REMOTE          1
#endif /* _KERNEL */

#define SADB_X_AUTHTYPE_NONE         0
#define SADB_X_AUTHTYPE_PASSPHRASE   1
#define SADB_X_AUTHTYPE_RSA          2
#define SADB_X_AUTHTYPE_MAX          2

a429 1
void export_credentials(void **, struct tdb *, int);
a433 1
void export_auth(void **, struct tdb *, int);
a437 1
void import_auth(struct tdb *, struct sadb_x_cred *, int);
a441 1
void import_credentials(struct tdb *, struct sadb_x_cred *, int);
@


1.64
log
@Move more stuff under _KERNEL
ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.63 2013/03/09 02:27:07 deraadt Exp $ */
d303 1
a303 3
#define SADB_X_AALG_MD5              249
#define SADB_X_AALG_SHA1             250
#define SADB_AALG_MAX                250
@


1.63
log
@normalize structure definitions
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.62 2012/09/18 09:24:45 markus Exp $ */
d481 1
@


1.62
log
@remove the SADB_X_SAFLAGS_{HALFIV,RANDOMPADDING,NOREPLAY} pfkey-API (not set
anywhere) as well as the matching TDBF_{HALFIV,RANDOMPADDING,NOREPLAY} code.
ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.61 2012/06/29 14:48:04 mikeb Exp $ */
d403 1
a403 2
struct pfkey_version
{
d411 1
a411 2
struct pfkeyv2_socket
{
d420 1
a420 2
struct dump_state
{
@


1.61
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.60 2010/10/06 22:19:20 mikeb Exp $ */
a333 1
#define SADB_X_SAFLAGS_HALFIV		0x002	/* Used for ESP-old */
a335 2
#define SADB_X_SAFLAGS_RANDOMPADDING	0x080	/* Random ESP padding */
#define SADB_X_SAFLAGS_NOREPLAY		0x100	/* No replay counter */
@


1.60
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.59 2010/09/22 12:48:52 mikeb Exp $ */
d333 8
a340 7
#define SADB_SAFLAGS_PFS         	0x001    /* perfect forward secrecy */
#define SADB_X_SAFLAGS_HALFIV    	0x002    /* Used for ESP-old */
#define SADB_X_SAFLAGS_TUNNEL	 	0x004    /* Force tunneling */
#define SADB_X_SAFLAGS_CHAINDEL  	0x008    /* Delete whole SA chain */
#define SADB_X_SAFLAGS_RANDOMPADDING    0x080    /* Random ESP padding */
#define SADB_X_SAFLAGS_NOREPLAY         0x100    /* No replay counter */
#define SADB_X_SAFLAGS_UDPENCAP         0x200    /* ESP in UDP  */
d342 1
a342 1
#define SADB_X_POLICYFLAGS_POLICY       0x0001	/* This is a static policy */
@


1.59
log
@Add AES-GCM Transform Identifiers as specified by IANA in
RFC 4106 and 4543.

Please note that although IKEv1 and IKEv2 identifiers are
different for ESP_NULL_AUTH_AES-GMAC (SADB_X_EALG_AESGMAC),
we use the IKEv2 one only (which is 21).  ipsecctl(8) will
be taught to handle exported SA correctly.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.58 2010/07/09 16:58:06 reyk Exp $ */
d325 1
a325 2
#define SADB_X_EALG_SKIPJACK  249
#define SADB_EALG_MAX         249
@


1.58
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.57 2010/07/01 02:09:45 reyk Exp $ */
d300 3
d321 4
@


1.57
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.55 2005/05/27 15:29:55 hshoexer Exp $ */
d415 1
d440 1
a440 1
int pfkeyv2_sendmessage(void **, int, struct socket *, u_int8_t, int);
d447 1
a447 1
int pfkeyv2_ipo_walk(int (*)(struct ipsec_policy *, void *), void *);
@


1.56
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d222 6
d270 2
a271 1
#define SADB_EXT_MAX                  33
d463 1
d477 1
@


1.55
log
@Use export_flow() to wrap policies retrieved via sysctl in pfkey message

ok ho markus
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.54 2005/05/25 05:47:53 markus Exp $ */
d216 6
d263 2
a264 1
#define SADB_EXT_MAX                  32
d455 1
d468 1
@


1.54
log
@AESCTR support for ESP (RFC 3686); ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.53 2005/04/04 22:18:47 hshoexer Exp $ */
d67 2
a68 1
#define SADB_MAX           15
d426 1
d432 1
d434 1
d443 2
@


1.53
log
@Add sysctl for dumping the SPD
ok deraadt, ok markus some time ago
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.52 2004/11/26 18:02:22 markus Exp $ */
d302 1
@


1.52
log
@implement net.key.v2.sadb_dump.{unspec,esp,ah,...} sysctl subtree
and use sysctl for 'ipsecadm show'; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.51 2004/08/10 16:17:05 ho Exp $ */
d429 1
@


1.51
log
@Add SADB_X_EXT_LIFETIME_LASTUSE for use with isakmpd/DPD, adding this
extends the bitmap to 64bits. Also repair SADB_GET. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.50 2004/01/27 09:27:17 markus Exp $ */
d389 1
d419 1
a419 1
int pfkeyv2_get(struct tdb *, void **, void **);
d427 2
@


1.50
log
@don't convert tcpmd5 to ip-over-ip in SADB_X_GETSPROTO; from hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.49 2003/12/02 23:16:29 markus Exp $ */
d255 2
a256 1
#define SADB_EXT_MAX                  31
d334 1
@


1.49
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.48 2003/07/24 09:59:02 itojun Exp $ */
d219 1
@


1.48
log
@conform to RFC2367 on SADB_xx naming (local name must be prefixed with
SADB_X_xx)
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.47 2003/02/24 21:34:39 jason Exp $ */
d208 7
d253 2
a254 1
#define SADB_EXT_MAX                  30
d315 1
d433 1
d445 1
@


1.47
log
@SADB_X_CALG_MAX is supposed to be the highest numbered supported algorithm
(prevents a crash in the debugging code in pfkeyv2_parsemessage.c)
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.46 2003/02/16 21:30:13 deraadt Exp $ */
d270 5
a274 5
#define SADB_AALG_DES                4
#define SADB_AALG_SHA2_256           5
#define SADB_AALG_SHA2_384           6
#define SADB_AALG_SHA2_512           7
#define SADB_AALG_RIPEMD160HMAC      8
d290 1
a290 1
#define SADB_X_EALG_NULL      11
@


1.46
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.45 2003/02/16 19:54:20 jason Exp $ */
d299 1
a299 1
#define SADB_X_CALG_MAX		4
@


1.45
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.44 2003/02/15 19:21:05 jason Exp $ */
d209 4
a212 4
#define SADB_X_GETSPROTO(x) ( (x) == SADB_SATYPE_AH ? IPPROTO_AH :\
                                (x) == SADB_SATYPE_ESP ? IPPROTO_ESP :\
                                    (x) == SADB_X_SATYPE_IPCOMP ? IPPROTO_IPCOMP:\
                                                         IPPROTO_IPIP )
@


1.44
log
@s/LSZ/LZS (consistent with linux and isakmpd *.cst)
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.43 2002/06/07 04:47:06 ho Exp $ */
d70 8
a77 8
  uint8_t sadb_msg_version;
  uint8_t sadb_msg_type;
  uint8_t sadb_msg_errno;
  uint8_t sadb_msg_satype;
  uint16_t sadb_msg_len;
  uint16_t sadb_msg_reserved;
  uint32_t sadb_msg_seq;
  uint32_t sadb_msg_pid;
d81 2
a82 2
  uint16_t sadb_ext_len;
  uint16_t sadb_ext_type;
d86 8
a93 8
  uint16_t sadb_sa_len;
  uint16_t sadb_sa_exttype;
  uint32_t sadb_sa_spi;
  uint8_t sadb_sa_replay;
  uint8_t sadb_sa_state;
  uint8_t sadb_sa_auth;
  uint8_t sadb_sa_encrypt;
  uint32_t sadb_sa_flags;
d97 6
a102 6
  uint16_t sadb_lifetime_len;
  uint16_t sadb_lifetime_exttype;
  uint32_t sadb_lifetime_allocations;
  uint64_t sadb_lifetime_bytes;
  uint64_t sadb_lifetime_addtime;
  uint64_t sadb_lifetime_usetime;
d106 3
a108 3
  uint16_t sadb_address_len;
  uint16_t sadb_address_exttype;
  uint32_t sadb_address_reserved;
d112 4
a115 4
  uint16_t sadb_key_len;
  uint16_t sadb_key_exttype;
  uint16_t sadb_key_bits;
  uint16_t sadb_key_reserved;
d119 5
a123 5
  uint16_t sadb_ident_len;
  uint16_t sadb_ident_exttype;
  uint16_t sadb_ident_type;
  uint16_t sadb_ident_reserved;
  uint64_t sadb_ident_id;
d127 8
a134 8
  uint16_t sadb_sens_len;
  uint16_t sadb_sens_exttype;
  uint32_t sadb_sens_dpd;
  uint8_t sadb_sens_sens_level;
  uint8_t sadb_sens_sens_len;
  uint8_t sadb_sens_integ_level;
  uint8_t sadb_sens_integ_len;
  uint32_t sadb_sens_reserved;
d138 5
a142 5
  uint16_t sadb_prop_len;
  uint16_t sadb_prop_exttype;
  uint8_t sadb_prop_num;
  uint8_t sadb_prop_replay;
  uint16_t sadb_prop_reserved;
d146 16
a161 16
  uint8_t sadb_comb_auth;
  uint8_t sadb_comb_encrypt;
  uint16_t sadb_comb_flags;
  uint16_t sadb_comb_auth_minbits;
  uint16_t sadb_comb_auth_maxbits;
  uint16_t sadb_comb_encrypt_minbits;
  uint16_t sadb_comb_encrypt_maxbits;
  uint32_t sadb_comb_reserved;
  uint32_t sadb_comb_soft_allocations;
  uint32_t sadb_comb_hard_allocations;
  uint64_t sadb_comb_soft_bytes;
  uint64_t sadb_comb_hard_bytes;
  uint64_t sadb_comb_soft_addtime;
  uint64_t sadb_comb_hard_addtime;
  uint64_t sadb_comb_soft_usetime;
  uint64_t sadb_comb_hard_usetime;
d165 3
a167 3
  uint16_t sadb_supported_len;
  uint16_t sadb_supported_exttype;
  uint32_t sadb_supported_reserved;
d171 5
a175 5
  uint8_t sadb_alg_id;
  uint8_t sadb_alg_ivlen;
  uint16_t sadb_alg_minbits;
  uint16_t sadb_alg_maxbits;
  uint16_t sadb_alg_reserved;
d179 5
a183 5
  uint16_t sadb_spirange_len;
  uint16_t sadb_spirange_exttype;
  uint32_t sadb_spirange_min;
  uint32_t sadb_spirange_max;
  uint32_t sadb_spirange_reserved;
d187 6
a192 6
  uint16_t sadb_protocol_len;
  uint16_t sadb_protocol_exttype;
  uint8_t  sadb_protocol_proto;
  uint8_t  sadb_protocol_direction;
  uint8_t  sadb_protocol_flags;
  uint8_t  sadb_protocol_reserved2;
d196 3
a198 3
  uint16_t  sadb_x_policy_len;
  uint16_t  sadb_x_policy_exttype;
  u_int32_t sadb_x_policy_seq;
d202 4
a205 4
  uint16_t sadb_x_cred_len;
  uint16_t sadb_x_cred_exttype;
  uint16_t sadb_x_cred_type;
  uint16_t sadb_x_cred_reserved;
d373 4
a376 4
    int protocol;
    int (*create)(struct socket *socket);
    int (*release)(struct socket *socket);
    int (*send)(struct socket *socket, void *message, int len);
d381 5
a385 5
    struct pfkeyv2_socket *next;
    struct socket *socket;
    int flags;
    uint32_t pid;
    uint32_t registration;    /* Increase size if SATYPE_MAX > 31 */
d390 2
a391 2
    struct sadb_msg *sadb_msg;
    struct socket *socket;
d399 1
a399 2
                    union sockaddr_union *, u_int32_t *,
		    struct sockaddr_encap *);
@


1.43
log
@Add flow type arg to import_flow()
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.42 2002/05/31 01:39:05 angelos Exp $ */
d298 1
a298 1
#define SADB_X_CALG_LSZ		3
@


1.42
log
@import_flow() prototype
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.41 2001/12/18 23:07:49 deraadt Exp $ */
d435 1
a435 1
    struct sadb_address *, struct sadb_protocol *);
@


1.41
log
@NRL license cleaning
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.40 2001/07/05 08:38:32 angelos Exp $ */
d433 3
@


1.41.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pfkeyv2.h,v 1.41 2001/12/18 23:07:49 deraadt Exp $ */
a432 3
void import_flow(struct sockaddr_encap *, struct sockaddr_encap *,
    struct sadb_address *, struct sadb_address *, struct sadb_address *,
    struct sadb_address *, struct sadb_protocol *, struct sadb_protocol *);
@


1.41.2.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d70 8
a77 8
	uint8_t sadb_msg_version;
	uint8_t sadb_msg_type;
	uint8_t sadb_msg_errno;
	uint8_t sadb_msg_satype;
	uint16_t sadb_msg_len;
	uint16_t sadb_msg_reserved;
	uint32_t sadb_msg_seq;
	uint32_t sadb_msg_pid;
d81 2
a82 2
	uint16_t sadb_ext_len;
	uint16_t sadb_ext_type;
d86 8
a93 8
	uint16_t sadb_sa_len;
	uint16_t sadb_sa_exttype;
	uint32_t sadb_sa_spi;
	uint8_t sadb_sa_replay;
	uint8_t sadb_sa_state;
	uint8_t sadb_sa_auth;
	uint8_t sadb_sa_encrypt;
	uint32_t sadb_sa_flags;
d97 6
a102 6
	uint16_t sadb_lifetime_len;
	uint16_t sadb_lifetime_exttype;
	uint32_t sadb_lifetime_allocations;
	uint64_t sadb_lifetime_bytes;
	uint64_t sadb_lifetime_addtime;
	uint64_t sadb_lifetime_usetime;
d106 3
a108 3
	uint16_t sadb_address_len;
	uint16_t sadb_address_exttype;
	uint32_t sadb_address_reserved;
d112 4
a115 4
	uint16_t sadb_key_len;
	uint16_t sadb_key_exttype;
	uint16_t sadb_key_bits;
	uint16_t sadb_key_reserved;
d119 5
a123 5
	uint16_t sadb_ident_len;
	uint16_t sadb_ident_exttype;
	uint16_t sadb_ident_type;
	uint16_t sadb_ident_reserved;
	uint64_t sadb_ident_id;
d127 8
a134 8
	uint16_t sadb_sens_len;
	uint16_t sadb_sens_exttype;
	uint32_t sadb_sens_dpd;
	uint8_t sadb_sens_sens_level;
	uint8_t sadb_sens_sens_len;
	uint8_t sadb_sens_integ_level;
	uint8_t sadb_sens_integ_len;
	uint32_t sadb_sens_reserved;
d138 5
a142 5
	uint16_t sadb_prop_len;
	uint16_t sadb_prop_exttype;
	uint8_t sadb_prop_num;
	uint8_t sadb_prop_replay;
	uint16_t sadb_prop_reserved;
d146 16
a161 16
	uint8_t sadb_comb_auth;
	uint8_t sadb_comb_encrypt;
	uint16_t sadb_comb_flags;
	uint16_t sadb_comb_auth_minbits;
	uint16_t sadb_comb_auth_maxbits;
	uint16_t sadb_comb_encrypt_minbits;
	uint16_t sadb_comb_encrypt_maxbits;
	uint32_t sadb_comb_reserved;
	uint32_t sadb_comb_soft_allocations;
	uint32_t sadb_comb_hard_allocations;
	uint64_t sadb_comb_soft_bytes;
	uint64_t sadb_comb_hard_bytes;
	uint64_t sadb_comb_soft_addtime;
	uint64_t sadb_comb_hard_addtime;
	uint64_t sadb_comb_soft_usetime;
	uint64_t sadb_comb_hard_usetime;
d165 3
a167 3
	uint16_t sadb_supported_len;
	uint16_t sadb_supported_exttype;
	uint32_t sadb_supported_reserved;
d171 5
a175 5
	uint8_t sadb_alg_id;
	uint8_t sadb_alg_ivlen;
	uint16_t sadb_alg_minbits;
	uint16_t sadb_alg_maxbits;
	uint16_t sadb_alg_reserved;
d179 5
a183 5
	uint16_t sadb_spirange_len;
	uint16_t sadb_spirange_exttype;
	uint32_t sadb_spirange_min;
	uint32_t sadb_spirange_max;
	uint32_t sadb_spirange_reserved;
d187 6
a192 6
	uint16_t sadb_protocol_len;
	uint16_t sadb_protocol_exttype;
	uint8_t  sadb_protocol_proto;
	uint8_t  sadb_protocol_direction;
	uint8_t  sadb_protocol_flags;
	uint8_t  sadb_protocol_reserved2;
d196 3
a198 3
	uint16_t  sadb_x_policy_len;
	uint16_t  sadb_x_policy_exttype;
	u_int32_t sadb_x_policy_seq;
d202 4
a205 4
	uint16_t sadb_x_cred_len;
	uint16_t sadb_x_cred_exttype;
	uint16_t sadb_x_cred_type;
	uint16_t sadb_x_cred_reserved;
d209 4
a212 4
#define SADB_X_GETSPROTO(x) \
	( (x) == SADB_SATYPE_AH ? IPPROTO_AH :\
	(x) == SADB_SATYPE_ESP ? IPPROTO_ESP :\
	(x) == SADB_X_SATYPE_IPCOMP ? IPPROTO_IPCOMP: IPPROTO_IPIP )
d298 2
a299 2
#define SADB_X_CALG_LZS		3
#define SADB_X_CALG_MAX		3
d373 4
a376 4
	int protocol;
	int (*create)(struct socket *socket);
	int (*release)(struct socket *socket);
	int (*send)(struct socket *socket, void *message, int len);
d381 5
a385 5
	struct pfkeyv2_socket *next;
	struct socket *socket;
	int flags;
	uint32_t pid;
	uint32_t registration;    /* Increase size if SATYPE_MAX > 31 */
d390 2
a391 2
	struct sadb_msg *sadb_msg;
	struct socket *socket;
d399 2
a400 1
    union sockaddr_union *, u_int32_t *, struct sockaddr_encap *);
@


1.40
log
@$OpenBSD$ tag
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d3 38
a40 8
%%% copyright-nrl-98
This software is Copyright 1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
a41 1
*/
@


1.39
log
@Include files for IPComp support. angelos@@ ok.
@
text
@d1 1
a217 1

@


1.38
log
@By popular demand, protect from multiple inclusion, and fix to use the
same naming style.
@
text
@d181 1
d215 3
a217 1
#define SADB_EXT_MAX                  29
d229 2
a230 1
#define SADB_SATYPE_MAX			 8
d265 6
@


1.37
log
@Flag field for flows.
@
text
@d12 2
a13 2
#ifndef _NET_PFKEY_V2_H
#define _NET_PFKEY_V2_H 1
d395 1
a395 1
#endif /* _NET_PFKEY_V2_H */
@


1.36
log
@Fork out some of the code in pfkeyv2.c to pfkeyv2_convert.c, to make
the former more managable/readable (an almost impossible task).
@
text
@d161 2
a162 1
  uint16_t sadb_protocol_reserved2;
d268 2
@


1.35
log
@Make our pfkeyv2.h more RFC2367 compliant.  Also fix some backwards
compatibility problems in isakmpd, at least 2.8 stable can compile current
isakmpd now.  angelos@@ ok
@
text
@d326 3
d363 28
@


1.34
log
@Add comments on what the credential types are.
@
text
@d15 5
a19 1
#define PF_KEY_V2 2
d164 4
a167 4
struct sadb_policy {
  uint16_t  sadb_policy_len;
  uint16_t  sadb_policy_exttype;
  u_int32_t sadb_policy_seq;
d170 5
a174 5
struct sadb_cred {
  uint16_t sadb_cred_len;
  uint16_t sadb_cred_exttype;
  uint16_t sadb_cred_type;
  uint16_t sadb_cred_reserved;
d177 2
a178 1
#define SADB_GETSPROTO(x) ( (x) == SADB_SATYPE_AH ? IPPROTO_AH :\
d181 1
d268 6
a273 6
#define SADB_IDENTTYPE_RESERVED   0
#define SADB_IDENTTYPE_PREFIX     1
#define SADB_IDENTTYPE_FQDN       2
#define SADB_IDENTTYPE_USERFQDN   3
#define SADB_IDENTTYPE_CONNECTION 4
#define SADB_IDENTTYPE_MAX        4
d277 1
d294 1
d296 4
a299 4
#define SADB_CREDTYPE_NONE           0
#define SADB_CREDTYPE_X509           1   /* ASN1 encoding of the certificate */
#define SADB_CREDTYPE_KEYNOTE        2   /* NUL-terminated buffer */
#define SADB_CREDTYPE_MAX            3
d301 1
d307 1
d309 11
a319 13
#define SADB_AUTHTYPE_NONE           0
#define SADB_AUTHTYPE_PASSPHRASE     1
#define SADB_AUTHTYPE_RSA            2
#define SADB_AUTHTYPE_MAX            2

#define FLOW_X_TYPE_USE                1
#define FLOW_X_TYPE_ACQUIRE            2
#define FLOW_X_TYPE_REQUIRE            3
#define FLOW_X_TYPE_BYPASS             4
#define FLOW_X_TYPE_DENY               5
#define FLOW_X_TYPE_DONTACQ            6

#define OPENBSD_IPSEC_API_VERSION      1
@


1.33
log
@MBOX->USERFQDN, noticed by markus@@
@
text
@d289 2
a290 2
#define SADB_CREDTYPE_X509           1
#define SADB_CREDTYPE_KEYNOTE        2
@


1.32
log
@Import/export authentication information for SA.
@
text
@d265 1
a265 1
#define SADB_IDENTTYPE_MBOX       3
@


1.31
log
@Add AUTH payload.
@
text
@d206 2
a207 1
#define SADB_EXT_MAX                  28
d292 6
@


1.30
log
@Use the new M_* malloc types
@
text
@d205 2
a206 1
#define SADB_EXT_MAX                  27
d291 5
@


1.29
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d203 2
a204 2
#define SADB_X_EXT_SRC_CREDENTIALS    26
#define SADB_X_EXT_DST_CREDENTIALS    27
@


1.28
log
@Import/export credentials from TDB.
@
text
@d203 3
a205 2
#define SADB_X_EXT_CREDENTIALS        26
#define SADB_EXT_MAX                  26
@


1.27
log
@sync with pfkey rfc.  you need to rebuild ipsecadm and isakmpd after this.
okay angelos@@
@
text
@d166 7
d203 2
a204 1
#define SADB_EXT_MAX                  25
d284 5
@


1.26
log
@Update list of algorithms (hshoexer@@rommelwood.de)
@
text
@d133 1
a133 3
  uint8_t sadb_supported_nauth;
  uint8_t sadb_supported_nencrypt;
  uint16_t sadb_supported_reserved;
d137 1
a137 1
  uint8_t sadb_alg_type;
d184 13
a196 12
#define SADB_EXT_SUPPORTED            14
#define SADB_EXT_SPIRANGE             15
#define SADB_X_EXT_SRC_MASK           16
#define SADB_X_EXT_DST_MASK           17
#define SADB_X_EXT_PROTOCOL           18
#define SADB_X_EXT_FLOW_TYPE          19
#define SADB_X_EXT_SRC_FLOW           20
#define SADB_X_EXT_DST_FLOW           21
#define SADB_X_EXT_SA2                22
#define SADB_X_EXT_DST2               23
#define SADB_X_EXT_POLICY             24
#define SADB_EXT_MAX                  24
@


1.25
log
@*HMAC96->*HMAC

Also, sync with IANA -- closes PR 1508.
@
text
@d220 1
d230 1
d233 2
d237 4
a240 1
#define SADB_X_EALG_SKIPJACK  5
d242 2
a243 1
#define SADB_EALG_MAX         12
@


1.24
log
@CAST128 should be 6 (again itojun@@openbsd.org)
@
text
@d218 9
a226 8
#define SADB_AALG_MD5HMAC            1
#define SADB_AALG_SHA1HMAC           2
#define SADB_AALG_MD5HMAC96          3
#define SADB_AALG_SHA1HMAC96         4
#define SADB_X_AALG_RIPEMD160HMAC96  5
#define SADB_X_AALG_MD5              6
#define SADB_X_AALG_SHA1             7
#define SADB_AALG_MAX                7
a230 1
#define SADB_X_EALG_SKIPJACK  5
d233 1
@


1.23
log
@AES should be 12 (from IANA) -- itojun@@openbsd.org

Note that you have to recompile ipsecadm and isakmpd if you use a new
kernel.
@
text
@a229 1
#define SADB_X_EALG_CAST      4
d231 1
@


1.22
log
@Conform to RFC 2367 numbering (hshoexer@@rommelwood.de)
@
text
@a231 1
#define SADB_X_EALG_AES       6
d233 2
a234 1
#define SADB_EALG_MAX         7
@


1.21
log
@ASKPOLICY message; used by key management to inquire about policy
triggering an ACQUIRE.
@
text
@d228 2
a229 3
#define SADB_EALG_DESCBC      1
#define SADB_EALG_3DESCBC     2
#define SADB_X_EALG_BLF       3
d233 2
a234 1
#define SADB_EALG_MAX         6
@


1.20
log
@AES number.
@
text
@d32 2
a33 1
#define SADB_MAX           14
d161 7
a167 1
    
d196 2
a197 1
#define SADB_EXT_MAX                  23
d311 2
a312 1
                    union sockaddr_union *);
@


1.19
log
@SA bundles.
@
text
@d225 2
a226 1
#define SADB_EALG_MAX         5
@


1.18
log
@SPD-driven IPsec.
@
text
@d31 2
a32 1
#define SADB_MAX           13
d187 3
a189 1
#define SADB_EXT_MAX                  21
@


1.17
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@d31 1
a31 3
#define SADB_X_GRPSPIS     14
#define SADB_X_BINDSA      15
#define SADB_MAX           15
d156 1
a156 1
  uint8_t  sadb_protocol_reserved1;
d162 1
a162 2
                                    (x) == SADB_X_SATYPE_BYPASS ? IPPROTO_IP :\
                                      IPPROTO_IPIP )
d183 1
a183 1
#define SADB_X_EXT_SA2                19
d186 1
a186 2
#define SADB_X_EXT_DST2               22
#define SADB_EXT_MAX                  22
d198 1
a198 2
#define SADB_X_SATYPE_BYPASS		 9
#define SADB_SATYPE_MAX			 9
a227 2
#define SADB_X_SAFLAGS_REPLACEFLOW	0x020    /* Replace existing flow */
#define SADB_X_SAFLAGS_INGRESS_FLOW     0x040    /* Ingress ACL entry */
d257 9
d298 2
a299 1
int pfkeyv2_acquire(struct tdb *, int);
@


1.17.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d32 1
a32 1
#define SADB_X_ASKPOLICY   15
d133 3
a135 1
  uint32_t sadb_supported_reserved;
d139 1
a139 1
  uint8_t sadb_alg_id;
d158 1
a158 1
  uint8_t  sadb_protocol_direction;
d161 1
a161 14

struct sadb_policy {
  uint16_t  sadb_policy_len;
  uint16_t  sadb_policy_exttype;
  u_int32_t sadb_policy_seq;
};

struct sadb_cred {
  uint16_t sadb_cred_len;
  uint16_t sadb_cred_exttype;
  uint16_t sadb_cred_type;
  uint16_t sadb_cred_reserved;
};

d164 2
a165 1
                                                         IPPROTO_IPIP )
d181 10
a190 15
#define SADB_EXT_SUPPORTED_AUTH	      14
#define SADB_EXT_SUPPORTED_ENCRYPT    15
#define SADB_EXT_SPIRANGE             16
#define SADB_X_EXT_SRC_MASK           17
#define SADB_X_EXT_DST_MASK           18
#define SADB_X_EXT_PROTOCOL           19
#define SADB_X_EXT_FLOW_TYPE          20
#define SADB_X_EXT_SRC_FLOW           21
#define SADB_X_EXT_DST_FLOW           22
#define SADB_X_EXT_SA2                23
#define SADB_X_EXT_DST2               24
#define SADB_X_EXT_POLICY             25
#define SADB_X_EXT_SRC_CREDENTIALS    26
#define SADB_X_EXT_DST_CREDENTIALS    27
#define SADB_EXT_MAX                  27
d202 2
a203 1
#define SADB_SATYPE_MAX			 8
d212 8
a219 10
#define SADB_AALG_MD5HMAC            2
#define SADB_AALG_SHA1HMAC           3
#define SADB_AALG_DES                4
#define SADB_AALG_SHA2_256           5
#define SADB_AALG_SHA2_384           6
#define SADB_AALG_SHA2_512           7
#define SADB_AALG_RIPEMD160HMAC      8
#define SADB_X_AALG_MD5              249
#define SADB_X_AALG_SHA1             250
#define SADB_AALG_MAX                250
d222 6
a227 14
#define SADB_X_EALG_DES_IV64  1
#define SADB_EALG_DESCBC      2
#define SADB_EALG_3DESCBC     3
#define SADB_X_EALG_RC5       4
#define SADB_X_EALG_IDEA      5
#define SADB_X_EALG_CAST      6
#define SADB_X_EALG_BLF       7
#define SADB_X_EALG_3IDEA     8
#define SADB_X_EALG_DES_IV32  9
#define SADB_X_EALG_RC4       10
#define SADB_X_EALG_NULL      11
#define SADB_X_EALG_AES       12
#define SADB_X_EALG_SKIPJACK  249
#define SADB_EALG_MAX         249
d233 2
a263 14
#define SADB_CREDTYPE_NONE           0
#define SADB_CREDTYPE_X509           1
#define SADB_CREDTYPE_KEYNOTE        2
#define SADB_CREDTYPE_MAX            3

#define FLOW_X_TYPE_USE                1
#define FLOW_X_TYPE_ACQUIRE            2
#define FLOW_X_TYPE_REQUIRE            3
#define FLOW_X_TYPE_BYPASS             4
#define FLOW_X_TYPE_DENY               5
#define FLOW_X_TYPE_DONTACQ            6

#define OPENBSD_IPSEC_API_VERSION      1

d296 1
a296 3
int pfkeyv2_acquire(struct ipsec_policy *, union sockaddr_union *,
                    union sockaddr_union *, u_int32_t *,
		    struct sockaddr_encap *);
@


1.17.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d12 2
a13 2
#ifndef _NET_PFKEY_V2_H_
#define _NET_PFKEY_V2_H_
d15 1
a15 5
#define PF_KEY_V2			2
#define PFKEYV2_REVISION		199806L

/* This should be updated whenever the API is altered.  */
#define _OPENBSD_IPSEC_API_VERSION	2
d157 1
a157 2
  uint8_t  sadb_protocol_flags;
  uint8_t  sadb_protocol_reserved2;
d160 4
a163 4
struct sadb_x_policy {
  uint16_t  sadb_x_policy_len;
  uint16_t  sadb_x_policy_exttype;
  u_int32_t sadb_x_policy_seq;
d166 5
a170 5
struct sadb_x_cred {
  uint16_t sadb_x_cred_len;
  uint16_t sadb_x_cred_exttype;
  uint16_t sadb_x_cred_type;
  uint16_t sadb_x_cred_reserved;
d173 1
a173 2
#ifdef _KERNEL
#define SADB_X_GETSPROTO(x) ( (x) == SADB_SATYPE_AH ? IPPROTO_AH :\
a175 1
#endif
d203 3
a205 5
#define SADB_X_EXT_LOCAL_CREDENTIALS  26
#define SADB_X_EXT_REMOTE_CREDENTIALS 27
#define SADB_X_EXT_LOCAL_AUTH         28
#define SADB_X_EXT_REMOTE_AUTH        29
#define SADB_EXT_MAX                  29
d260 6
a265 8
#define SADB_X_POLICYFLAGS_POLICY       0x0001	/* This is a static policy */

#define SADB_IDENTTYPE_RESERVED     0
#define SADB_IDENTTYPE_PREFIX       1
#define SADB_IDENTTYPE_FQDN         2
#define SADB_IDENTTYPE_USERFQDN     3
#define SADB_X_IDENTTYPE_CONNECTION 4
#define SADB_IDENTTYPE_MAX          4
a268 1
#ifdef _KERNEL
a284 1
#endif /* _KERNEL */
d286 11
a296 4
#define SADB_X_CREDTYPE_NONE         0
#define SADB_X_CREDTYPE_X509         1   /* ASN1 encoding of the certificate */
#define SADB_X_CREDTYPE_KEYNOTE      2   /* NUL-terminated buffer */
#define SADB_X_CREDTYPE_MAX          3
d298 1
a298 19
#ifdef _KERNEL
#define PFKEYV2_AUTH_LOCAL           0
#define PFKEYV2_AUTH_REMOTE          1

#define PFKEYV2_CRED_LOCAL           0
#define PFKEYV2_CRED_REMOTE          1
#endif /* _KERNEL */

#define SADB_X_AUTHTYPE_NONE         0
#define SADB_X_AUTHTYPE_PASSPHRASE   1
#define SADB_X_AUTHTYPE_RSA          2
#define SADB_X_AUTHTYPE_MAX          2

#define SADB_X_FLOW_TYPE_USE           1
#define SADB_X_FLOW_TYPE_ACQUIRE       2
#define SADB_X_FLOW_TYPE_REQUIRE       3
#define SADB_X_FLOW_TYPE_BYPASS        4
#define SADB_X_FLOW_TYPE_DENY          5
#define SADB_X_FLOW_TYPE_DONTACQ       6
a304 3
#define EXTLEN(x) (((struct sadb_ext *)(x))->sadb_ext_len * sizeof(uint64_t))
#define PADUP(x) (((x) + sizeof(uint64_t) - 1) & ~(sizeof(uint64_t) - 1))

a338 28

int pfkeyv2_create(struct socket *);
int pfkeyv2_get(struct tdb *, void **, void **);
int pfkeyv2_policy(struct ipsec_acquire *, void **, void **);
int pfkeyv2_release(struct socket *);
int pfkeyv2_send(struct socket *, void *, int);
int pfkeyv2_sendmessage(void **, int, struct socket *, u_int8_t, int);
int pfkeyv2_dump_walker(struct tdb *, void *, int);
int pfkeyv2_flush_walker(struct tdb *, void *, int);
int pfkeyv2_get_proto_alg(u_int8_t, u_int8_t *, int *);

int pfdatatopacket(void *, int, struct mbuf **);

void export_address(void **, struct sockaddr *);
void export_identity(void **, struct tdb *, int);
void export_lifetime(void **, struct tdb *, int);
void export_credentials(void **, struct tdb *, int);
void export_sa(void **, struct tdb *);
void export_key(void **, struct tdb *, int);
void export_auth(void **, struct tdb *, int);

void import_auth(struct tdb *, struct sadb_x_cred *, int);
void import_address(struct sockaddr *, struct sadb_address *);
void import_identity(struct tdb *, struct sadb_ident *, int);
void import_key(struct ipsecinit *, struct sadb_key *, int);
void import_lifetime(struct tdb *, struct sadb_lifetime *, int);
void import_credentials(struct tdb *, struct sadb_x_cred *, int);
void import_sa(struct tdb *, struct sadb_sa *, struct ipsecinit *);
d340 1
a340 1
#endif /* _NET_PFKEY_V2_H_ */
@


1.17.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/* $OpenBSD$ */
a180 1
                                    (x) == SADB_X_SATYPE_IPCOMP ? IPPROTO_IPCOMP:\
d214 1
a214 2
#define SADB_X_EXT_SUPPORTED_COMP     30
#define SADB_EXT_MAX                  30
d226 1
a226 2
#define SADB_X_SATYPE_IPCOMP		 9
#define SADB_SATYPE_MAX			 9
a260 6

#define SADB_X_CALG_NONE	0
#define SADB_X_CALG_OUI		1
#define SADB_X_CALG_DEFLATE	2
#define SADB_X_CALG_LSZ		3
#define SADB_X_CALG_MAX		4
@


1.17.2.4
log
@Merge in trunk
@
text
@d3 8
a10 38
 *	@@(#)COPYRIGHT	1.1 (NRL) January 1998
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d12 1
@


1.17.2.5
log
@Sync the SMP branch with 3.3
@
text
@d70 8
a77 8
	uint8_t sadb_msg_version;
	uint8_t sadb_msg_type;
	uint8_t sadb_msg_errno;
	uint8_t sadb_msg_satype;
	uint16_t sadb_msg_len;
	uint16_t sadb_msg_reserved;
	uint32_t sadb_msg_seq;
	uint32_t sadb_msg_pid;
d81 2
a82 2
	uint16_t sadb_ext_len;
	uint16_t sadb_ext_type;
d86 8
a93 8
	uint16_t sadb_sa_len;
	uint16_t sadb_sa_exttype;
	uint32_t sadb_sa_spi;
	uint8_t sadb_sa_replay;
	uint8_t sadb_sa_state;
	uint8_t sadb_sa_auth;
	uint8_t sadb_sa_encrypt;
	uint32_t sadb_sa_flags;
d97 6
a102 6
	uint16_t sadb_lifetime_len;
	uint16_t sadb_lifetime_exttype;
	uint32_t sadb_lifetime_allocations;
	uint64_t sadb_lifetime_bytes;
	uint64_t sadb_lifetime_addtime;
	uint64_t sadb_lifetime_usetime;
d106 3
a108 3
	uint16_t sadb_address_len;
	uint16_t sadb_address_exttype;
	uint32_t sadb_address_reserved;
d112 4
a115 4
	uint16_t sadb_key_len;
	uint16_t sadb_key_exttype;
	uint16_t sadb_key_bits;
	uint16_t sadb_key_reserved;
d119 5
a123 5
	uint16_t sadb_ident_len;
	uint16_t sadb_ident_exttype;
	uint16_t sadb_ident_type;
	uint16_t sadb_ident_reserved;
	uint64_t sadb_ident_id;
d127 8
a134 8
	uint16_t sadb_sens_len;
	uint16_t sadb_sens_exttype;
	uint32_t sadb_sens_dpd;
	uint8_t sadb_sens_sens_level;
	uint8_t sadb_sens_sens_len;
	uint8_t sadb_sens_integ_level;
	uint8_t sadb_sens_integ_len;
	uint32_t sadb_sens_reserved;
d138 5
a142 5
	uint16_t sadb_prop_len;
	uint16_t sadb_prop_exttype;
	uint8_t sadb_prop_num;
	uint8_t sadb_prop_replay;
	uint16_t sadb_prop_reserved;
d146 16
a161 16
	uint8_t sadb_comb_auth;
	uint8_t sadb_comb_encrypt;
	uint16_t sadb_comb_flags;
	uint16_t sadb_comb_auth_minbits;
	uint16_t sadb_comb_auth_maxbits;
	uint16_t sadb_comb_encrypt_minbits;
	uint16_t sadb_comb_encrypt_maxbits;
	uint32_t sadb_comb_reserved;
	uint32_t sadb_comb_soft_allocations;
	uint32_t sadb_comb_hard_allocations;
	uint64_t sadb_comb_soft_bytes;
	uint64_t sadb_comb_hard_bytes;
	uint64_t sadb_comb_soft_addtime;
	uint64_t sadb_comb_hard_addtime;
	uint64_t sadb_comb_soft_usetime;
	uint64_t sadb_comb_hard_usetime;
d165 3
a167 3
	uint16_t sadb_supported_len;
	uint16_t sadb_supported_exttype;
	uint32_t sadb_supported_reserved;
d171 5
a175 5
	uint8_t sadb_alg_id;
	uint8_t sadb_alg_ivlen;
	uint16_t sadb_alg_minbits;
	uint16_t sadb_alg_maxbits;
	uint16_t sadb_alg_reserved;
d179 5
a183 5
	uint16_t sadb_spirange_len;
	uint16_t sadb_spirange_exttype;
	uint32_t sadb_spirange_min;
	uint32_t sadb_spirange_max;
	uint32_t sadb_spirange_reserved;
d187 6
a192 6
	uint16_t sadb_protocol_len;
	uint16_t sadb_protocol_exttype;
	uint8_t  sadb_protocol_proto;
	uint8_t  sadb_protocol_direction;
	uint8_t  sadb_protocol_flags;
	uint8_t  sadb_protocol_reserved2;
d196 3
a198 3
	uint16_t  sadb_x_policy_len;
	uint16_t  sadb_x_policy_exttype;
	u_int32_t sadb_x_policy_seq;
d202 4
a205 4
	uint16_t sadb_x_cred_len;
	uint16_t sadb_x_cred_exttype;
	uint16_t sadb_x_cred_type;
	uint16_t sadb_x_cred_reserved;
d209 4
a212 4
#define SADB_X_GETSPROTO(x) \
	( (x) == SADB_SATYPE_AH ? IPPROTO_AH :\
	(x) == SADB_SATYPE_ESP ? IPPROTO_ESP :\
	(x) == SADB_X_SATYPE_IPCOMP ? IPPROTO_IPCOMP: IPPROTO_IPIP )
d298 2
a299 2
#define SADB_X_CALG_LZS		3
#define SADB_X_CALG_MAX		3
d373 4
a376 4
	int protocol;
	int (*create)(struct socket *socket);
	int (*release)(struct socket *socket);
	int (*send)(struct socket *socket, void *message, int len);
d381 5
a385 5
	struct pfkeyv2_socket *next;
	struct socket *socket;
	int flags;
	uint32_t pid;
	uint32_t registration;    /* Increase size if SATYPE_MAX > 31 */
d390 2
a391 2
	struct sadb_msg *sadb_msg;
	struct socket *socket;
d399 2
a400 1
    union sockaddr_union *, u_int32_t *, struct sockaddr_encap *);
a432 3
void import_flow(struct sockaddr_encap *, struct sockaddr_encap *,
    struct sadb_address *, struct sadb_address *, struct sadb_address *,
    struct sadb_address *, struct sadb_protocol *, struct sadb_protocol *);
@


1.17.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a207 7
struct sadb_x_udpencap {
	uint16_t sadb_x_udpencap_len;
	uint16_t sadb_x_udpencap_exttype;
	uint16_t sadb_x_udpencap_port;
	uint16_t sadb_x_udpencap_reserved;
};

a211 1
	(x) == SADB_X_SATYPE_TCPSIGNATURE ? IPPROTO_TCP :\
d246 1
a246 2
#define SADB_X_EXT_UDPENCAP           31
#define SADB_EXT_MAX                  31
d270 5
a274 5
#define SADB_X_AALG_DES              4
#define SADB_X_AALG_SHA2_256         5
#define SADB_X_AALG_SHA2_384         6
#define SADB_X_AALG_SHA2_512         7
#define SADB_X_AALG_RIPEMD160HMAC    8
d290 1
a290 1
#define SADB_EALG_NULL        11
a306 1
#define SADB_X_SAFLAGS_UDPENCAP         0x200    /* ESP in UDP  */
a423 1
void export_udpencap(void **, struct tdb *);
a434 1
void import_udpencap(struct tdb *, struct sadb_x_udpencap *);
@


1.16
log
@Ingress flow support.
@
text
@a162 1
                              (x) == SADB_X_SATYPE_AH_OLD ? IPPROTO_AH :\
a163 1
                                  (x) == SADB_X_SATYPE_ESP_OLD ? IPPROTO_ESP :\
d200 4
a203 6
#define SADB_X_SATYPE_AH_OLD		 7
#define SADB_X_SATYPE_ESP_OLD		 8
#define SADB_X_SATYPE_IPIP		 9
#define SADB_X_SATYPE_TCPSIGNATURE	10
#define SADB_X_SATYPE_BYPASS		11
#define SADB_SATYPE_MAX			11
d229 8
a236 6
#define SADB_SAFLAGS_PFS         	0x01    /* perfect forward secrecy */
#define SADB_X_SAFLAGS_HALFIV    	0x02    /* Used for ESP-old */
#define SADB_X_SAFLAGS_TUNNEL	 	0x04    /* Force tunneling */
#define SADB_X_SAFLAGS_CHAINDEL  	0x08    /* Delete whole SA chain */
#define SADB_X_SAFLAGS_REPLACEFLOW	0x20    /* Replace existing flow */
#define SADB_X_SAFLAGS_INGRESS_FLOW     0x40    /* Ingress ACL entry */
@


1.15
log
@Major style cleanup for pfkeyv2.c
@
text
@d238 1
@


1.14
log
@externalize pfkeyv2_acquire()
@
text
@d248 17
d267 25
d298 4
@


1.13
log
@IPv6 address support, get rid of the LOCALFLOW flag
@
text
@d255 1
@


1.12
log
@New SADB_SATYPE, IPsec bypass tdb.
@
text
@a236 1
#define SADB_X_SAFLAGS_LOCALFLOW 	0x10    /* Add flow with src=0.0.0.0 */
@


1.11
log
@Added support for TCP MD5 option (RFC 2385).
@
text
@d166 2
a167 1
                                    IPPROTO_IPIP )
d206 2
a207 1
#define SADB_SATYPE_MAX			10
@


1.10
log
@rename SADB_foo_X_bar to SADB_X_foo_bar
@
text
@d194 12
a205 11
#define SADB_SATYPE_UNSPEC    0
#define SADB_SATYPE_AH        1
#define SADB_SATYPE_ESP       2
#define SADB_SATYPE_RSVP      3
#define SADB_SATYPE_OSPFV2    4
#define SADB_SATYPE_RIPV2     5
#define SADB_SATYPE_MIP       6
#define SADB_X_SATYPE_AH_OLD  7
#define SADB_X_SATYPE_ESP_OLD 8
#define SADB_X_SATYPE_IPIP    9
#define SADB_SATYPE_MAX       9
@


1.9
log
@Implement SADB_SAFLAGS_X_REPLACEFLOW
@
text
@d163 1
a163 1
                              (x) == SADB_SATYPE_X_AH_OLD ? IPPROTO_AH :\
d165 1
a165 1
                                  (x) == SADB_SATYPE_X_ESP_OLD ? IPPROTO_ESP :\
d184 7
a190 7
#define SADB_EXT_X_SRC_MASK           16
#define SADB_EXT_X_DST_MASK           17
#define SADB_EXT_X_PROTOCOL           18
#define SADB_EXT_X_SA2                19
#define SADB_EXT_X_SRC_FLOW           20
#define SADB_EXT_X_DST_FLOW           21
#define SADB_EXT_X_DST2               22
d201 3
a203 3
#define SADB_SATYPE_X_AH_OLD  7
#define SADB_SATYPE_X_ESP_OLD 8
#define SADB_SATYPE_X_IPIP    9
d217 3
a219 3
#define SADB_AALG_X_RIPEMD160HMAC96  5
#define SADB_AALG_X_MD5              6
#define SADB_AALG_X_SHA1             7
d225 3
a227 3
#define SADB_EALG_X_BLF       3
#define SADB_EALG_X_CAST      4
#define SADB_EALG_X_SKIPJACK  5
d231 5
a235 5
#define SADB_SAFLAGS_X_HALFIV    	0x02    /* Used for ESP-old */
#define SADB_SAFLAGS_X_TUNNEL	 	0x04    /* Force tunneling */
#define SADB_SAFLAGS_X_CHAINDEL  	0x08    /* Delete whole SA chain */
#define SADB_SAFLAGS_X_LOCALFLOW 	0x10    /* Add flow with src=0.0.0.0 */
#define SADB_SAFLAGS_X_REPLACEFLOW	0x20    /* Replace existing flow */
@


1.8
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d230 6
a235 5
#define SADB_SAFLAGS_PFS         0x01    /* perfect forward secrecy */
#define SADB_SAFLAGS_X_HALFIV    0x02    /* Used for ESP-old */
#define SADB_SAFLAGS_X_TUNNEL	 0x04    /* Force tunneling */
#define SADB_SAFLAGS_X_CHAINDEL  0x08    /* Delete whole SA chain */
#define SADB_SAFLAGS_X_LOCALFLOW 0x10    /* Add flow with 0.0.0.0 as src */
@


1.7
log
@Implement lifetime expiration notifications.  Fix some typos.  Remove statics.
@
text
@d32 2
a33 1
#define SADB_MAX           14
@


1.6
log
@keep track of SATYPE registrations per PFKEY socket
@
text
@d233 1
a233 1
#define SADB_SAFLAGS_X_LOCALFLOW 0x10    /* Delete whole SA chain */
d244 3
a246 1
#ifdef KERNEL
d249 3
a251 2
int pfkeyv2_parsemessage(void *p, int len, void **headers);
#endif /* KERNEL */
@


1.5
log
@PF_KEY_V2, with local extensions for SPD management.
@
text
@d192 1
@


1.4
log
@$OpenBSD$
@
text
@a0 21
/*	$OpenBSD$	*/

/*
 * The author of this code is Angelos D. Keromytis, angelos@@openbsd.org
 * 	(except when noted otherwise).
 *
 * Copyright (C) 1997, 1998, 1999 by John Ioannidis and Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */


d2 247
a248 303
 * PF_KEYv2 definitions
 */

#define	PF_KEY_V2	0

struct pfkeycb
{
    LIST_ENTRY(pfkeycb) pfkey_list;
    struct socket      *pfkey_socket;
    struct sockaddr    *pfkey_faddr;
    struct sockaddr    *pfkey_laddr;
    struct sockproto    pfkey_proto;
    u_int32_t           pfkey_flags;
#define PFKEYv2_REGISTERED        0x1
};

struct sadb_msg
{
    u_int8_t  sadb_msg_version;   /* Must be PF_KEY_V2 */
    u_int8_t  sadb_msg_type;      
    u_int8_t  sadb_msg_errno;     /* Should be zero for messages to kernel */
    u_int8_t  sadb_msg_sa_type;   
    u_int16_t sadb_msg_len;       /* In 32-bit words, inclusive */
    u_int16_t sadb_msg_reserved;  /* Set to zero */
    u_int32_t sadb_msg_seq;       
    u_int32_t sadb_msg_pid;       /* PID of originating process, 0 if kernel */
};


struct sadb_hdr
{
    u_int16_t sadb_hdr_len;       /* In 32-bit words, inclusive */
    u_int16_t sadb_hdr_hdrtype;   /* 0 is reserved */
};

struct sadb_sa
{
    u_int16_t sadb_sa_len;                 /* In 32-bit words, inclusive */
    u_int16_t sadb_sa_hdrtype;             /* ASSOCIATION */
    u_int16_t sadb_sa_spi;                 /* Network byte order */
    u_int8_t  sadb_sa_replay_window_len;   /* Set to 0 if not in use */
    u_int8_t  sadb_sa_state;               /* Set to zero by sending process */
    u_int8_t  sadb_sa_encrypt;             /* Encryption algorithm */
    u_int8_t  sadb_sa_auth;                /* Authentication algorithm */
    u_int32_t sadb_sa_flags;               /* Bitmask */
};

struct sadb_lifetime 
{
    u_int16_t sadb_lifetime_len;          /* In 32-bit words, inclusive */
    u_int16_t sadb_lifetime_hdrtype;      /* LIFETIME */
    u_int8_t  sadb_lifetime_which;        /* Bitmask */
    u_int8_t  sadb_lifetime_reserved[3];  /* Padding */
};

struct sadb_lifetime_val
{
    u_int8_t  sadb_lifetime_val_which;      /* Corresponds to lifetime_which */
    u_int8_t  sadb_lifetime_val_reserved;
    u_int16_t sadb_lifetime_val_allocations; /* How many "flows" to use for */
    u_int32_t sadb_lifetime_val_bytes;       /* Number of bytes before expr */
    time_t    sadb_lifetime_val_absolute;
    time_t    sadb_lifetime_val_updatetime;
    time_t    sadb_lifetime_val_usetime;
};

struct sadb_address
{
    u_int16_t sadb_address_len;         /* In 32-bit words, inclusive */
    u_int16_t sadb_address_hdrtype;     /* ADDRESS */
    u_int8_t  sadb_address_which;       /* Bitmask */
    u_int8_t  sadb_address_reserved[3]; /* Padding */
    /* Followed by one or more sockaddr structures */
};

struct sadb_keyblk
{
    u_int16_t sadb_keyblk_len;          /* In 32-bit words, inclusive */
    u_int16_t sadb_keyblk_hdrtype;      /* KEY */
    u_int8_t  sadb_keyblk_which;        /* Bitmask */
    u_int8_t  sadb_keyblk_reserved[3];  /* Padding */
    /* Followed by sadb_key */
};

struct sadb_key
{
    u_int16_t sadb_key_len;             /* Length of key in bits */
    u_int16_t sadb_key_which;           /* Corresponds to keyblk_which */
    u_int8_t  sadb_key_type;            /* 3DES, DES, HMAC-MD5, etc. */
    /* Actual key follows */
};

struct sadb_id
{
    u_int16_t sadb_id_len;         /* In 32-bit words, inclusive */
    u_int16_t sadb_id_hdrtype;     /* IDENTITY */
    u_int8_t  sadb_id_which;       /* Bitmask */
    u_int8_t  sadb_id_reserved[3]; /* Padding */
    /* Followed by one or more sadb_certids */
};

struct sadb_certid
{
    u_int16_t sadb_certid_len;    /* In 32-bit words, inclusive */
    u_int16_t sadb_certid_type;
    /* Cert id. follows */
};

struct sadb_sens
{
    u_int16_t sadb_sens_len;              /* In 32-bit words, inclusive */
    u_int16_t sadb_sens_hdrtype;          /* SENSITIVITY */
    u_int32_t sadb_sens_dpd;              /* Protection Domain */
    u_int8_t  sadb_sens_level;
    u_int8_t  sadb_sens_sens_bitmap_len;  /* In 32-bit words */
    u_int8_t  sadb_sens_integ_level;
    u_int8_t  sadb_sens_integ_bitmap_len; /* In 32-bit words */
    /*
     * Followed by 2 u_int32_t arrays
     * u_int32_t sadb_sens_bitmap[sens_bitmap_len];
     * u_int32_t integ_bitmap[integ_bitmap_len];
     */
};

struct sadb_prop
{
    u_int16_t sadb_prop_len;        /* In 32-bit words, inclusive */
    u_int16_t sadb_prop_hdrtype;    /* PROPOSAL */
    u_int8_t  sadb_prop_num;
    u_int8_t  sadb_prop_replay;     /* Replay window size */
    u_int16_t sadb_prop_reserved;
};

struct sadb_comb
{
    u_int8_t  sadb_comb_auth;
    u_int8_t  sadb_comb_encr;
    u_int16_t sadb_comb_flags;
    u_int16_t sadb_comb_auth_keylen_min;
    u_int16_t sadb_comb_auth_keylen_max;
    u_int16_t sadb_comb_encr_keylen_min;
    u_int16_t sadb_comb_encr_keylen_max;
};

struct sadb_alg
{
    u_int16_t sadb_alg_len;        /* In 32-bit words, inclusive */
    u_int16_t sadb_alg_hdrtype;    /* SUPPORTED */
    u_int8_t  sadb_alg_num_auth;   /* Number of auth algorithms */
    u_int8_t  sadb_alg_num_encrypt;
    /* Followed by one or more sadb_algd */
};

struct sadb_algd
{
    u_int8_t  sadb_algd_type;        /* Algorithm type */
    u_int8_t  sadb_algd_ivlen;       /* IV len, in bits */
    u_int16_t sadb_algd_minlen;      /* Minimum key length, in bits */
    u_int16_t sadb_algd_maxlen;      /* Maximum key length, in bits */
    u_int16_t sadb_algd_reserved;
};

struct sadb_spirange
{
    u_int16_t sadb_spirage_len;      /* In 32-bit words, inclusive */
    u_int16_t sadb_spirage_hdrtype;  /* SPI_RANGE */
    u_int32_t sadb_spirange_low;
    u_int32_t sadb_spirange_hi;
};

/* Message types */

#define SADB_GETSPI     1
#define SADB_UPDATE     2
#define SADB_ADD        3
#define SADB_DELETE     4
#define SADB_GET        5
#define SADB_ACQUIRE    6
#define SADB_REGISTER   7
#define SADB_EXPIRE     8
#define SADB_FLUSH      9

#define SADB_DUMP       10   /* Not used normally */

#define SADB_MAX        10

/* Security association flags */

#define SA_USED         0x1   /* SA used/not used */
#define SA_UNIQUE       0x2   /* SA unique/reusable */
#define SA_INBOUND      0x4   /* SA for packets destined here */
#define SA_OUTBOUND     0x8   /* SA for packets sourced here */
#define SA_FORWARD      0x10  /* SA for packets forwarded through */
#define SA_PFS          0x20  /* Perfect Forward Secrecy ? */
#define SA_REPLAY       0x40  /* Replay protection ? */

/* Security association state */

#define SA_STATE_LARVAL  0
#define SA_STATE_MATURE  1
#define SA_STATE_DYING   2
#define SA_STATE_DEAD    3

#define SA_STATE_MAX     3

/* Security association type */

#define SADB_SATYPE_NONE   0
#define SADB_SATYPE_AH     1  /* RFC-1826 */
#define SADB_SATYPE_ESP    2  /* RFC-1827 */
#define SADB_SATYPE_RSVP   3  /* RVSP Authentication */
#define SADB_SATYPE_OSPFV2 4  /* OSPFv2 Authentication */
#define SADB_SATYPE_RIPV2  5  /* RIPv2 Authentication */
#define SADB_SATYPE_MIPV4  6  /* Mobile IPv4 Authentication */

#define SADB_SATYPE_MAX    6

/* Algorithm types */

/* Authentication algorithms */

#define SADB_AALG_NONE      0
#define SADB_AALG_MD5_HMAC  1
#define SADB_AALG_SHA1_HMAC 2

#define SADB_AALG_MAX       2

/* Encryption algorithms */

#define SADB_EALG_NONE      0
#define SADB_EALG_DES_CBC   1
#define SADB_EALG_3DES      2
#define SADB_EALG_RC5       3

#define SADB_EALG_MAX       3

/* Extension header values */

#define SA_EXT_ASSOCIATION  1
#define SA_EXT_LIFETIME     2
#define SA_EXT_ADDRESS      3
#define SA_EXT_KEY          4
#define SA_EXT_IDENTITY     5
#define SA_EXT_SENSITIVITY  6
#define SA_EXT_PROPOSAL     7
#define SA_EXT_SUPPORTED    8
#define SA_EXT_SPI_RANGE    9

#define SA_EXT_MAX          9

/* Address extension values */

#define SADB_ADDR_SRC       0x1  /* Source */
#define SADB_ADDR_DST       0x2  /* Destination */
#define SADB_ADDR_INNER_SRC 0x4  /* Inner-packet src */
#define SADB_ADDR_INNER_DST 0x8  /* Inner-packet dst */
#define SADB_ADDR_PROXY     0x10 /* Proxy address */

/* Lifetime extension values */

#define SADB_LIFETIME_HARD      0x1   /* Hard lifetime */
#define SADB_LIFETIME_SOFT      0x2   /* Soft lifetime */
#define SADB_LIFETIME_CURRENT   0x4   /* Current lifetime left */

/* Key extension values */

#define SADB_KEYBLK_AUTH      0x1     /* Authentication key */
#define SADB_KEYBLK_ENCRYPT   0x2     /* Encryption key */

/* Identity extension values */

#define SADB_ID_SRC    0x1
#define SADB_ID_DST    0x2

/* Identity type */

#define SADB_IDT_IPV4_ADDR    1
#define SADB_IDT_IPV6_ADDR    2
#define SADB_IDT_IPV4_RANGE   3
#define SADB_IDT_IPV6_RANGE   4
#define SADB_IDT_FQDN         5
#define SADB_IDT_USER_FQDN    6
#define SADB_IDT_IPV4_CONNID  7
#define SADB_IDT_IPV6_CONNID  8

#define SADB_IDT_MAX          8

/* Sensitivity extension values */

#define SADB_DPD_NONE        0
#define SADB_DPD_DOD_GENSER  1
#define SADB_DPD_DOD_SCI     2
#define SADB_DPD_DOE         3
#define SADB_DPD_NATO        4

#define SADB_DPD_MAX         4

#define sotopfkeycb(so)      ((structy pfkeycb *)(so)->so->pcb)

#ifdef _KERNEL
LIST_HEAD(, pfkeycb) pfkeycb;       /* head of list */
#endif

@


1.3
log
@Added faddr/laddr on the pfkeycb, for completeness.
@
text
@d1 2
@


1.2
log
@PFKEY protocol control blocks.
@
text
@a0 2
/*	$id$	*/

d30 2
@


1.1
log
@PF_KEYv2 definition as of the latest draft.
@
text
@d28 9
d317 7
@
