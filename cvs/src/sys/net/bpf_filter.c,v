head	1.32;
access;
symbols
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.18
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.16
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.12
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.10
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.8
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.6
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.8
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.8
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2016.09.13.12.09.53;	author krw;	state Exp;
branches;
next	1.31;
commitid	28e8pgOV6LUvqGys;

1.31
date	2016.09.12.14.05.40;	author krw;	state Exp;
branches;
next	1.30;
commitid	RbbtvGbp3ZbqTfV8;

1.30
date	2016.04.02.10.26.58;	author dlg;	state Exp;
branches;
next	1.29;
commitid	X0ORRLy2NXEourCO;

1.29
date	2016.04.02.09.05.16;	author dlg;	state Exp;
branches;
next	1.28;
commitid	H5lilsfaBbklUHtU;

1.28
date	2016.04.02.08.49.49;	author dlg;	state Exp;
branches;
next	1.27;
commitid	BPyrNLQIxS9UMvYc;

1.27
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.26;
commitid	hN5bFCE56DrAjl99;

1.26
date	2014.09.19.11.43.31;	author otto;	state Exp;
branches;
next	1.25;
commitid	prDmZHKX95sEiiQn;

1.25
date	2014.09.18.10.44.37;	author dlg;	state Exp;
branches;
next	1.24;
commitid	5dfO5TUWo58bz4aG;

1.24
date	2011.02.13.22.41.10;	author canacar;	state Exp;
branches;
next	1.23;

1.23
date	2011.02.12.20.58.28;	author canacar;	state Exp;
branches;
next	1.22;

1.22
date	2011.02.12.20.45.19;	author canacar;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.21.16.49.34;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.02.00.31.50;	author canacar;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.06.08.28.09;	author tom;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.28.06.34.19;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.27.14.32.49;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.08.08.49.30;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.28.20.53.56;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.26.08.10.10;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.23.19.06.50;	author markus;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2003.12.10.07.22.42;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.18.23.05.13;	author david;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2003.06.27.19.01.52;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.19.03.00.54;	author jason;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	99.09.13.22.35.44;	author niklas;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.06.01.17.54.31;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	96.08.22.00.35.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.21.07.02;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.10.23.12.41.04;	author davem;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.05;	author deraadt;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.39.59;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.7.8.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	;

1.11.2.1
date	2004.05.10.07.21.35;	author brad;	state Exp;
branches;
next	;

1.13.2.1
date	2004.05.10.04.16.03;	author brad;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Don't waste time zero'ing memory until there is some chance it might
be used.

Also noted by dlg@@.

ok phessler@@ mpi@@
@
text
@/*	$OpenBSD: bpf_filter.c,v 1.31 2016/09/12 14:05:40 krw Exp $	*/
/*	$NetBSD: bpf_filter.c,v 1.12 1996/02/13 22:00:00 christos Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from the Stanford/CMU enet packet filter,
 * (net/enet.c) distributed as part of 4.3BSD, and code contributed
 * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence
 * Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)bpf_filter.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/time.h>
#ifndef _KERNEL
#include <stdlib.h>
#include <string.h>
#include "pcap.h"
#else
#include <sys/systm.h>
#endif

#include <sys/endian.h>

#ifdef _KERNEL
extern int bpf_maxbufsize;
#define Static
#else /* _KERNEL */
#define Static static
#endif /* _KERNEL */

#include <net/bpf.h>

struct bpf_mem {
	const u_char	*pkt;
	u_int		 len;
};

Static u_int32_t	bpf_mem_ldw(const void *, u_int32_t, int *);
Static u_int32_t	bpf_mem_ldh(const void *, u_int32_t, int *);
Static u_int32_t	bpf_mem_ldb(const void *, u_int32_t, int *);

static const struct bpf_ops bpf_mem_ops = {
	bpf_mem_ldw,
	bpf_mem_ldh,
	bpf_mem_ldb,
};

Static u_int32_t
bpf_mem_ldw(const void *mem, u_int32_t k, int *err)
{
	const struct bpf_mem *bm = mem;
	u_int32_t v;

	*err = 1;

	if (k + sizeof(v) > bm->len)
		return (0);

	memcpy(&v, bm->pkt + k, sizeof(v));

	*err = 0;
	return ntohl(v);
}

Static u_int32_t
bpf_mem_ldh(const void *mem, u_int32_t k, int *err)
{
	const struct bpf_mem *bm = mem;
	u_int16_t v;

	*err = 1;

	if (k + sizeof(v) > bm->len)
		return (0);

	memcpy(&v, bm->pkt + k, sizeof(v));

	*err = 0;
	return ntohs(v);
}

Static u_int32_t
bpf_mem_ldb(const void *mem, u_int32_t k, int *err)
{
	const struct bpf_mem *bm = mem;

	*err = 1;

	if (k >= bm->len)
		return (0);

	*err = 0;
	return bm->pkt[k];
}

/*
 * Execute the filter program starting at pc on the packet p
 * wirelen is the length of the original packet
 * buflen is the amount of data present
 */
u_int
bpf_filter(const struct bpf_insn *pc, const u_char *pkt,
    u_int wirelen, u_int buflen)
{
	struct bpf_mem bm;

	bm.pkt = pkt;
	bm.len = buflen;

	return _bpf_filter(pc, &bpf_mem_ops, &bm, wirelen);
}

u_int
_bpf_filter(const struct bpf_insn *pc, const struct bpf_ops *ops,
    const void *pkt, u_int wirelen)
{
	u_int32_t A = 0, X = 0;
	u_int32_t k;
	int32_t mem[BPF_MEMWORDS];
	int err;

	if (pc == NULL) {
		/*
		 * No filter means accept all.
		 */
		return (u_int)-1;
	}

	memset(mem, 0, sizeof(mem));

	--pc;
	while (1) {
		++pc;
		switch (pc->code) {

		default:
#ifdef _KERNEL
			return 0;
#else
			abort();
#endif
		case BPF_RET|BPF_K:
			return (u_int)pc->k;

		case BPF_RET|BPF_A:
			return (u_int)A;

		case BPF_LD|BPF_W|BPF_ABS:
			A = ops->ldw(pkt, pc->k, &err);
			if (err != 0)
				return 0;
			continue;

		case BPF_LD|BPF_H|BPF_ABS:
			A = ops->ldh(pkt, pc->k, &err);
			if (err != 0)
				return 0;
			continue;

		case BPF_LD|BPF_B|BPF_ABS:
			A = ops->ldb(pkt, pc->k, &err);
			if (err != 0)
				return 0;
			continue;

		case BPF_LD|BPF_W|BPF_LEN:
			A = wirelen;
			continue;

		case BPF_LDX|BPF_W|BPF_LEN:
			X = wirelen;
			continue;

		case BPF_LD|BPF_W|BPF_IND:
			k = X + pc->k;
			A = ops->ldw(pkt, k, &err);
			if (err != 0)
				return 0;
			continue;

		case BPF_LD|BPF_H|BPF_IND:
			k = X + pc->k;
			A = ops->ldh(pkt, k, &err);
			if (err != 0)
				return 0;
			continue;

		case BPF_LD|BPF_B|BPF_IND:
			k = X + pc->k;
			A = ops->ldb(pkt, k, &err);
			if (err != 0)
				return 0;
			continue;

		case BPF_LDX|BPF_MSH|BPF_B:
			X = ops->ldb(pkt, pc->k, &err);
			if (err != 0)
				return 0;
			X &= 0xf;
			X <<= 2;
			continue;

		case BPF_LD|BPF_IMM:
			A = pc->k;
			continue;

		case BPF_LDX|BPF_IMM:
			X = pc->k;
			continue;

		case BPF_LD|BPF_MEM:
			A = mem[pc->k];
			continue;

		case BPF_LDX|BPF_MEM:
			X = mem[pc->k];
			continue;

		case BPF_ST:
			mem[pc->k] = A;
			continue;

		case BPF_STX:
			mem[pc->k] = X;
			continue;

		case BPF_JMP|BPF_JA:
			pc += pc->k;
			continue;

		case BPF_JMP|BPF_JGT|BPF_K:
			pc += (A > pc->k) ? pc->jt : pc->jf;
			continue;

		case BPF_JMP|BPF_JGE|BPF_K:
			pc += (A >= pc->k) ? pc->jt : pc->jf;
			continue;

		case BPF_JMP|BPF_JEQ|BPF_K:
			pc += (A == pc->k) ? pc->jt : pc->jf;
			continue;

		case BPF_JMP|BPF_JSET|BPF_K:
			pc += (A & pc->k) ? pc->jt : pc->jf;
			continue;

		case BPF_JMP|BPF_JGT|BPF_X:
			pc += (A > X) ? pc->jt : pc->jf;
			continue;

		case BPF_JMP|BPF_JGE|BPF_X:
			pc += (A >= X) ? pc->jt : pc->jf;
			continue;

		case BPF_JMP|BPF_JEQ|BPF_X:
			pc += (A == X) ? pc->jt : pc->jf;
			continue;

		case BPF_JMP|BPF_JSET|BPF_X:
			pc += (A & X) ? pc->jt : pc->jf;
			continue;

		case BPF_ALU|BPF_ADD|BPF_X:
			A += X;
			continue;

		case BPF_ALU|BPF_SUB|BPF_X:
			A -= X;
			continue;

		case BPF_ALU|BPF_MUL|BPF_X:
			A *= X;
			continue;

		case BPF_ALU|BPF_DIV|BPF_X:
			if (X == 0)
				return 0;
			A /= X;
			continue;

		case BPF_ALU|BPF_AND|BPF_X:
			A &= X;
			continue;

		case BPF_ALU|BPF_OR|BPF_X:
			A |= X;
			continue;

		case BPF_ALU|BPF_LSH|BPF_X:
			A <<= X;
			continue;

		case BPF_ALU|BPF_RSH|BPF_X:
			A >>= X;
			continue;

		case BPF_ALU|BPF_ADD|BPF_K:
			A += pc->k;
			continue;

		case BPF_ALU|BPF_SUB|BPF_K:
			A -= pc->k;
			continue;

		case BPF_ALU|BPF_MUL|BPF_K:
			A *= pc->k;
			continue;

		case BPF_ALU|BPF_DIV|BPF_K:
			A /= pc->k;
			continue;

		case BPF_ALU|BPF_AND|BPF_K:
			A &= pc->k;
			continue;

		case BPF_ALU|BPF_OR|BPF_K:
			A |= pc->k;
			continue;

		case BPF_ALU|BPF_LSH|BPF_K:
			A <<= pc->k;
			continue;

		case BPF_ALU|BPF_RSH|BPF_K:
			A >>= pc->k;
			continue;

		case BPF_ALU|BPF_NEG:
			A = -A;
			continue;

		case BPF_MISC|BPF_TAX:
			X = A;
			continue;

		case BPF_MISC|BPF_TXA:
			A = X;
			continue;
		}
	}
}

#ifdef _KERNEL
/*
 * Return true if the 'fcode' is a valid filter program.
 * The constraints are that each jump be forward and to a valid
 * code and memory operations use valid addresses.  The code
 * must terminate with either an accept or reject.
 *
 * The kernel needs to be able to verify an application's filter code.
 * Otherwise, a bogus program could easily crash the system.
 */
int
bpf_validate(struct bpf_insn *f, int len)
{
	u_int i, from;
	struct bpf_insn *p;

	if (len < 1 || len > BPF_MAXINSNS)
		return 0;

	for (i = 0; i < len; ++i) {
		p = &f[i];
		switch (BPF_CLASS(p->code)) {
		/*
		 * Check that memory operations use valid addresses.
		 */
		case BPF_LD:
		case BPF_LDX:
			switch (BPF_MODE(p->code)) {
			case BPF_IMM:
				break;
			case BPF_ABS:
			case BPF_IND:
			case BPF_MSH:
				/*
				 * More strict check with actual packet length
				 * is done runtime.
				 */
				if (p->k >= bpf_maxbufsize)
					return 0;
				break;
			case BPF_MEM:
				if (p->k >= BPF_MEMWORDS)
					return 0;
				break;
			case BPF_LEN:
				break;
			default:
				return 0;
			}
			break;
		case BPF_ST:
		case BPF_STX:
			if (p->k >= BPF_MEMWORDS)
				return 0;
			break;
		case BPF_ALU:
			switch (BPF_OP(p->code)) {
			case BPF_ADD:
			case BPF_SUB:
			case BPF_MUL:
			case BPF_OR:
			case BPF_AND:
			case BPF_LSH:
			case BPF_RSH:
			case BPF_NEG:
				break;
			case BPF_DIV:
				/*
				 * Check for constant division by 0.
				 */
				if (BPF_SRC(p->code) == BPF_K && p->k == 0)
					return 0;
				break;
			default:
				return 0;
			}
			break;
		case BPF_JMP:
			/*
			 * Check that jumps are forward, and within
			 * the code block.
			 */
			from = i + 1;
			switch (BPF_OP(p->code)) {
			case BPF_JA:
				if (from + p->k < from || from + p->k >= len)
					return 0;
				break;
			case BPF_JEQ:
			case BPF_JGT:
			case BPF_JGE:
			case BPF_JSET:
				if (from + p->jt >= len || from + p->jf >= len)
					return 0;
				break;
			default:
				return 0;
			}
			break;
		case BPF_RET:
			break;
		case BPF_MISC:
			break;
		default:
			return 0;
		}

	}
	return BPF_CLASS(f[len - 1].code) == BPF_RET;
}
#endif
@


1.31
log
@Kill some unsightly whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.30 2016/04/02 10:26:58 dlg Exp $	*/
a150 2
	bzero(mem, sizeof(mem));

d157 2
@


1.30
log
@mark the bpf_mem ops as Static.

Static is a nop in _KERNEL, but is static in userland and therefore libpcap
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.29 2016/04/02 09:05:16 dlg Exp $	*/
d170 1
a170 1
#endif			
d243 1
a243 1
			
d295 1
a295 1
			
d299 1
a299 1
			
d303 1
a303 1
			
d309 1
a309 1
			
d313 1
a313 1
			
d329 1
a329 1
			
d333 1
a333 1
			
d337 1
a337 1
			
d341 1
a341 1
			
d345 1
a345 1
			
d378 1
a378 1
 * must terminate with either an accept or reject. 
d452 1
a452 1
			 * Check that jumps are forward, and within 
@


1.29
log
@mark the program and buffer as const in bpf_filter()

other projects have already done this, and there's software (eg,
gopacket) which now expects it.

based on a discussion with jasper@@ and canacar@@
ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.28 2016/04/02 08:49:49 dlg Exp $	*/
d55 4
a58 1
#endif
d67 3
a69 3
u_int32_t	bpf_mem_ldw(const void *, u_int32_t, int *);
u_int32_t	bpf_mem_ldh(const void *, u_int32_t, int *);
u_int32_t	bpf_mem_ldb(const void *, u_int32_t, int *);
d71 1
a71 1
const struct bpf_ops bpf_mem_ops = {
d77 1
a77 1
u_int32_t
d94 1
a94 1
u_int32_t
d111 1
a111 1
u_int32_t
@


1.28
log
@refactor bpf_filter a bit.

the code was confusing around how it dealt with packets in mbufs
vs plain memory buffers with a lenght.

this renames bpf_filter to _bpf_filter, and changes it so the packet
memory is referred to by an opaque pointer, and callers have to
provide a set of operations to extra values from that opaque pointer.

bpf_filter is now provided as a wrapper around _bpf_filter. it
provides a set of operators that work on a straight buffer with a
lenght.

this also adds a bpf_mfilter function which takes an mbuf instead
of a buffer, and it provides explicit operations for extracting
values from mbufs.

if we want to use bpf filters against other data structures (usb
or scsi packets maybe?) we are able to provide functions for
extracting payloads from them and use _bpf_filter as is.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.27 2015/05/13 10:42:46 jsg Exp $	*/
d128 2
a129 1
bpf_filter(struct bpf_insn *pc, u_char *pkt, u_int wirelen, u_int buflen)
@


1.27
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.26 2014/09/19 11:43:31 otto Exp $	*/
d52 3
a54 2
#ifdef __STRICT_ALIGNMENT
#define BPF_ALIGN
d57 24
a80 14
#ifndef BPF_ALIGN
#define EXTRACT_SHORT(p)	((u_int16_t)ntohs(*(u_int16_t *)p))
#define EXTRACT_LONG(p)		(ntohl(*(u_int32_t *)p))
#else
#define EXTRACT_SHORT(p)\
	((u_int16_t)\
		((u_int16_t)*((u_char *)p+0)<<8|\
		 (u_int16_t)*((u_char *)p+1)<<0))
#define EXTRACT_LONG(p)\
		((u_int32_t)*((u_char *)p+0)<<24|\
		 (u_int32_t)*((u_char *)p+1)<<16|\
		 (u_int32_t)*((u_char *)p+2)<<8|\
		 (u_int32_t)*((u_char *)p+3)<<0)
#endif
d82 2
a83 13
#ifdef _KERNEL
#include <sys/mbuf.h>
#define MINDEX(len, m, k) \
{ \
	len = m->m_len; \
	while (k >= len) { \
		k -= len; \
		m = m->m_next; \
		if (m == NULL) \
			return 0; \
		len = m->m_len; \
	} \
}
d85 1
a85 1
extern int bpf_maxbufsize;
d87 3
a89 2
int	bpf_m_xword(struct mbuf *, u_int32_t, int *);
int	bpf_m_xhalf(struct mbuf *, u_int32_t, int *);
d91 2
a92 2
int
bpf_m_xword(struct mbuf *m, u_int32_t k, int *err)
d94 2
a95 3
	int len;
	u_char *cp, *np;
	struct mbuf *m0;
a97 12
	MINDEX(len, m, k);
	cp = mtod(m, u_char *) + k;
	if (len >= k + 4) {
		*err = 0;
		return EXTRACT_LONG(cp);
	}
	m0 = m->m_next;
	if (m0 == NULL || m0->m_len + len - k < 4)
		return 0;
	*err = 0;
	np = mtod(m0, u_char *);
	switch (len - k) {
d99 2
a100 2
	case 1:
		return (cp[0] << 24) | (np[0] << 16) | (np[1] << 8) | np[2];
d102 1
a102 2
	case 2:
		return (cp[0] << 24) | (cp[1] << 16) | (np[0] << 8) | np[1];
d104 2
a105 3
	default:
		return (cp[0] << 24) | (cp[1] << 16) | (cp[2] << 8) | np[0];
	}
d108 2
a109 2
int
bpf_m_xhalf(struct mbuf *m, u_int32_t k, int *err)
d111 1
a111 3
	int len;
	u_char *cp;
	struct mbuf *m0;
d114 4
a117 9
	MINDEX(len, m, k);
	cp = mtod(m, u_char *) + k;
	if (len >= k + 2) {
		*err = 0;
		return EXTRACT_SHORT(cp);
	}
	m0 = m->m_next;
	if (m0 == NULL)
		return 0;
d119 1
a119 1
	return (cp[0] << 8) | mtod(m0, u_char *)[0];
a120 3
#endif

#include <net/bpf.h>
d128 13
a140 1
bpf_filter(struct bpf_insn *pc, u_char *p, u_int wirelen, u_int buflen)
d145 1
d149 1
a149 1
	if (pc == 0)
d154 2
d174 2
a175 12
			k = pc->k;
			if (k > buflen || sizeof(int32_t) > buflen - k) {
#ifdef _KERNEL
				int merr;

				if (buflen != 0)
					return 0;
				A = bpf_m_xword((struct mbuf *)p, k, &merr);
				if (merr != 0)
					return 0;
				continue;
#else
a176 3
#endif
			}
			A = EXTRACT_LONG(&p[k]);
d180 2
a181 12
			k = pc->k;
			if (k > buflen || sizeof(int16_t) > buflen - k) {
#ifdef _KERNEL
				int merr;

				if (buflen != 0)
					return 0;
				A = bpf_m_xhalf((struct mbuf *)p, k, &merr);
				if (merr != 0)
					return 0;
				continue;
#else
a182 3
#endif
			}
			A = EXTRACT_SHORT(&p[k]);
d186 2
a187 13
			k = pc->k;
			if (k >= buflen) {
#ifdef _KERNEL
				struct mbuf *m;
				int len;

				if (buflen != 0)
					return 0;
				m = (struct mbuf *)p;
				MINDEX(len, m, k);
				A = mtod(m, u_char *)[k];
				continue;
#else
a188 3
#endif
			}
			A = p[k];
d201 2
a202 11
			if (k > buflen || sizeof(int32_t) > buflen - k) {
#ifdef _KERNEL
				int merr;

				if (buflen != 0)
					return 0;
				A = bpf_m_xword((struct mbuf *)p, k, &merr);
				if (merr != 0)
					return 0;
				continue;
#else
a203 3
#endif
			}
			A = EXTRACT_LONG(&p[k]);
d208 2
a209 11
			if (k > buflen || sizeof(int16_t) > buflen - k) {
#ifdef _KERNEL
				int merr;

				if (buflen != 0)
					return 0;
				A = bpf_m_xhalf((struct mbuf *)p, k, &merr);
				if (merr != 0)
					return 0;
				continue;
#else
a210 3
#endif
			}
			A = EXTRACT_SHORT(&p[k]);
d215 2
a216 12
			if (k >= buflen) {
#ifdef _KERNEL
				struct mbuf *m;
				int len;

				if (buflen != 0)
					return 0;
				m = (struct mbuf *)p;
				MINDEX(len, m, k);
				A = mtod(m, u_char *)[k];
				continue;
#else
a217 3
#endif
			}
			A = p[k];
d221 2
a222 13
			k = pc->k;
			if (k >= buflen) {
#ifdef _KERNEL
				struct mbuf *m;
				int len;

				if (buflen != 0)
					return 0;
				m = (struct mbuf *)p;
				MINDEX(len, m, k);
				X = (mtod(m, u_char *)[k] & 0xf) << 2;
				continue;
#else
d224 2
a225 3
#endif
			}
			X = (p[pc->k] & 0xf) << 2;
@


1.26
log
@better boundchecks in validation; from Guy Harris; ok millert@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.25 2014/09/18 10:44:37 dlg Exp $	*/
d79 1
a79 1
		if (m == 0) \
d105 1
a105 1
	if (m0 == 0 || m0->m_len + len - k < 4)
d137 1
a137 1
	if (m0 == 0)
@


1.25
log
@ansify function declaration things.

ok mpi@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.24 2011/02/13 22:41:10 canacar Exp $	*/
d184 1
a184 1
			if (k + sizeof(int32_t) > buflen) {
d203 1
a203 1
			if (k + sizeof(int16_t) > buflen) {
d250 1
a250 1
			if (k + sizeof(int32_t) > buflen) {
d269 1
a269 1
			if (k + sizeof(int16_t) > buflen) {
@


1.24
log
@Unbreak userland as well, since bpf_filter.c is also used in libpcap.
Noticed by robert at openbsd pap st, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.23 2011/02/12 20:58:28 canacar Exp $	*/
d91 1
a91 4
bpf_m_xword(m, k, err)
	struct mbuf *m;
	u_int32_t k;
	int *err;
d123 1
a123 4
bpf_m_xhalf(m, k, err)
	struct mbuf *m;
	u_int32_t k;
	int *err;
d152 1
a152 5
bpf_filter(pc, p, wirelen, buflen)
	struct bpf_insn *pc;
	u_char *p;
	u_int wirelen;
	u_int buflen;
d478 1
a478 3
bpf_validate(f, len)
	struct bpf_insn *f;
	int len;
@


1.23
log
@Unbreak previous commit by adding the proper header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.22 2011/02/12 20:45:19 canacar Exp $	*/
a40 1
#include <sys/systm.h>
d45 1
d47 2
@


1.22
log
@Clear the filter memory area before using it. Leaving it uninitialized may
leak previous kernel stack contents through a malicioius BPF filter.
Reported by Dan Rosenberg via Alistair Crooks. ok deraadt@@, krw@@,
claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.21 2010/04/21 16:49:34 otto Exp $	*/
d41 1
@


1.21
log
@Fix validation of div by constant; from Guy Harris; ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.20 2008/01/02 00:31:50 canacar Exp $	*/
d164 2
@


1.20
log
@Accept BPF_MUL as a valid instruction in bpf_validate() also improve
the comments. Based on diff from Guy Harris
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.19 2007/08/06 08:28:09 tom Exp $	*/
d544 1
a544 1
				if (BPF_RVAL(p->code) == BPF_K && p->k == 0)
@


1.19
log
@Fix some "that that"s.

ok miod@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.18 2006/10/28 06:34:19 otto Exp $	*/
d476 2
a477 3
 * code.  The code must terminate with either an accept or reject. 
 * 'valid' is an array for use by the routine (it must be at least
 * 'len' bytes long).  
d533 1
@


1.18
log
@Fix handling of errors wrt to MINDEX. From NetBSD bpf_filter 1.32;
ok henning@@ deraadt@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.17 2006/02/27 14:32:49 otto Exp $	*/
d553 1
a553 1
			 * Check that that jumps are forward, and within 
@


1.17
log
@add missing break; now filters containing a division can pass
validation; from NetBSD; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.16 2005/12/08 08:49:30 otto Exp $	*/
d97 1
d106 1
a106 1
		goto bad;
a119 3
    bad:
	*err = 1;
	return 0;
d132 1
d141 1
a141 1
		goto bad;
a143 3
 bad:
	*err = 1;
	return 0;
d215 2
@


1.16
log
@Avoid sign extend by casting to u_char *; from NetBSD via Guy Harris.
Also change another cast, for the sake of consistency, as prompted by djm@@
ok deraadt@@ djm@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.15 2005/09/28 20:53:56 miod Exp $	*/
d548 1
@


1.15
log
@No part of the code defines UNALIGNED_ACCESS, use reverted tests for
__STRICT_ALIGNMENT instead.

Help pedro@@ deraadt@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.14 2004/04/26 08:10:10 otto Exp $	*/
d304 1
a304 1
				A = mtod(m, char *)[k];
d324 1
a324 1
				X = (mtod(m, char *)[k] & 0xf) << 2;
@


1.14
log
@- make the k field in struct bpf_insn unsigned, as promised in the
manual page.
- more strict bpf code validation, preventing arbitrary kernel memory
read and writes.
Some help from frantzen@@ and canacar@@; testing jmc@@ markus@@;
ok canacar@@ henning@@ franzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.13 2004/02/23 19:06:50 markus Exp $	*/
d48 2
a49 1
#ifndef UNALIGNED_ACCESS
@


1.13
log
@prevent backward jumps; pls@@egsys.hu; ok canacar, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.12 2003/12/10 07:22:42 itojun Exp $	*/
d81 4
a84 2
int	bpf_m_xword(struct mbuf *, int, int *);
int	bpf_m_xhalf(struct mbuf *, int, int *);
d89 2
a90 1
	int k, *err;
d98 1
a98 1
	if (len - k >= 4) {
d126 2
a127 1
	int k, *err;
d135 1
a135 1
	if (len - k >= 2) {
d165 1
a165 1
	int k;
d489 1
a489 1
	int i;
d492 3
d496 2
d499 1
a499 2
		 * Check that that jumps are forward, and within 
		 * the code block.
d501 45
a545 7
		p = &f[i];
		if (BPF_CLASS(p->code) == BPF_JMP) {
			int from = i + 1;

			if (BPF_OP(p->code) == BPF_JA) {
				if (from + p->k < from ||
				    from + p->k >= len)
d547 2
d550 20
a569 1
			else if (from + p->jt >= len || from + p->jf >= len)
d571 8
d580 1
a580 13
		/*
		 * Check that memory operations use valid addresses.
		 */
		if ((BPF_CLASS(p->code) == BPF_ST ||
		     (BPF_CLASS(p->code) == BPF_LD && 
		      (p->code & 0xe0) == BPF_MEM)) &&
		    (p->k >= BPF_MEMWORDS || p->k < 0))
			return 0;
		/*
		 * Check for constant division by 0.
		 */
		if (p->code == (BPF_ALU|BPF_DIV|BPF_K) && p->k == 0)
			return 0;
@


1.13.2.1
log
@MFC:
Fix by otto@@

more strict bpf code validation, preventing arbitrary kernel memory
read and writes.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.13 2004/02/23 19:06:50 markus Exp $	*/
a82 1
extern int bpf_maxbufsize;
d485 1
a485 1
	int i, from;
a487 3
	if (len < 1 || len > BPF_MAXINSNS)
		return 0;

a488 2
		p = &f[i];
		switch (BPF_CLASS(p->code)) {
d490 2
a491 1
		 * Check that memory operations use valid addresses.
d493 7
a499 45
		case BPF_LD:
		case BPF_LDX:
			switch (BPF_MODE(p->code)) {
			case BPF_IMM:
				break;
			case BPF_ABS:
			case BPF_IND:
			case BPF_MSH:
				/*
				 * More strict check with actual packet length
				 * is done runtime.
				 */
				if (p->k < 0 || p->k >= bpf_maxbufsize)
					return 0;
				break;
			case BPF_MEM:
				if (p->k < 0 || p->k >= BPF_MEMWORDS)
					return 0;
				break;
			case BPF_LEN:
				break;
			default:
				return 0;
			}
			break;
		case BPF_ST:
		case BPF_STX:
			if (p->k < 0 || p->k >= BPF_MEMWORDS)
				return 0;
			break;
		case BPF_ALU:
			switch (BPF_OP(p->code)) {
			case BPF_ADD:
			case BPF_SUB:
			case BPF_OR:
			case BPF_AND:
			case BPF_LSH:
			case BPF_RSH:
			case BPF_NEG:
				break;
			case BPF_DIV:
				/*
				 * Check for constant division by 0.
				 */
				if (BPF_RVAL(p->code) == BPF_K && p->k == 0)
a500 2
			default:
				return 0;
d502 1
a502 20
			break;
		case BPF_JMP:
			/*
			 * Check that that jumps are forward, and within 
			 * the code block.
			 */
			from = i + 1;
			switch (BPF_OP(p->code)) {
			case BPF_JA:
				if (from + p->k < from || from + p->k >= len)
					return 0;
				break;
			case BPF_JEQ:
			case BPF_JGT:
			case BPF_JGE:
			case BPF_JSET:
				if (from + p->jt >= len || from + p->jf >= len)
					return 0;
				break;
			default:
d504 13
a516 7
			}
			break;
		case BPF_RET:
			break;
		case BPF_MISC:
			break;
		default:
a517 2
		}

@


1.12
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.11 2003/07/18 23:05:13 david Exp $	*/
d498 2
a499 1
				if (from + p->k >= len)
@


1.11
log
@add missing includes
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.10 2003/06/27 19:01:52 deraadt Exp $	*/
d86 2
a87 2
	register struct mbuf *m;
	register int k, *err;
d89 3
a91 3
	register int len;
	register u_char *cp, *np;
	register struct mbuf *m0;
d122 2
a123 2
	register struct mbuf *m;
	register int k, *err;
d125 3
a127 3
	register int len;
	register u_char *cp;
	register struct mbuf *m0;
d155 2
a156 2
	register struct bpf_insn *pc;
	register u_char *p;
d158 1
a158 1
	register u_int buflen;
d160 2
a161 2
	register u_int32_t A = 0, X = 0;
	register int k;
d226 2
a227 2
				register struct mbuf *m;
				register int len;
d292 2
a293 2
				register struct mbuf *m;
				register int len;
d312 2
a313 2
				register struct mbuf *m;
				register int len;
d485 2
a486 2
	register int i;
	register struct bpf_insn *p;
d495 1
a495 1
			register int from = i + 1;
@


1.11.2.1
log
@MFC:
Fix by otto@@

more strict bpf code validation, preventing arbitrary kernel memory
read and writes.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.11 2003/07/18 23:05:13 david Exp $	*/
d485 2
a486 5
	int i, from;
	struct bpf_insn *p;

	if (len < 1 || len > BPF_MAXINSNS)
		return 0;
a488 2
		p = &f[i];
		switch (BPF_CLASS(p->code)) {
d490 2
a491 1
		 * Check that memory operations use valid addresses.
d493 6
a498 45
		case BPF_LD:
		case BPF_LDX:
			switch (BPF_MODE(p->code)) {
			case BPF_IMM:
				break;
			case BPF_ABS:
			case BPF_IND:
			case BPF_MSH:
				/*
				 * More strict check with actual packet length
				 * is done runtime.
				 */
				if (p->k < 0 || p->k >= BPF_MAXBUFSIZE)
					return 0;
				break;
			case BPF_MEM:
				if (p->k < 0 || p->k >= BPF_MEMWORDS)
					return 0;
				break;
			case BPF_LEN:
				break;
			default:
				return 0;
			}
			break;
		case BPF_ST:
		case BPF_STX:
			if (p->k < 0 || p->k >= BPF_MEMWORDS)
				return 0;
			break;
		case BPF_ALU:
			switch (BPF_OP(p->code)) {
			case BPF_ADD:
			case BPF_SUB:
			case BPF_OR:
			case BPF_AND:
			case BPF_LSH:
			case BPF_RSH:
			case BPF_NEG:
				break;
			case BPF_DIV:
				/*
				 * Check for constant division by 0.
				 */
				if (BPF_RVAL(p->code) == BPF_K && p->k == 0)
a499 2
			default:
				return 0;
d501 1
a501 20
			break;
		case BPF_JMP:
			/*
			 * Check that that jumps are forward, and within 
			 * the code block.
			 */
			from = i + 1;
			switch (BPF_OP(p->code)) {
			case BPF_JA:
				if (from + p->k < from || from + p->k >= len)
					return 0;
				break;
			case BPF_JEQ:
			case BPF_JGT:
			case BPF_JGE:
			case BPF_JSET:
				if (from + p->jt >= len || from + p->jf >= len)
					return 0;
				break;
			default:
d503 13
a515 7
			}
			break;
		case BPF_RET:
			break;
		case BPF_MISC:
			break;
		default:
a516 2
		}

@


1.10
log
@protos for userland build
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.9 2003/06/02 23:28:11 millert Exp $	*/
d44 1
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.8 2002/03/14 01:27:09 millert Exp $	*/
d43 3
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.7 2000/06/19 03:00:54 jason Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@de-#ifdef-ize
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.6 1999/09/13 22:35:44 niklas Exp $	*/
d81 2
a82 2
int	bpf_m_xword __P((struct mbuf *, int, int *));
int	bpf_m_xhalf __P((struct mbuf *, int, int *));
@


1.7.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.7 2000/06/19 03:00:54 jason Exp $	*/
d81 2
a82 2
int	bpf_m_xword(struct mbuf *, int, int *);
int	bpf_m_xhalf(struct mbuf *, int, int *);
@


1.6
log
@Remove statics (required renames)
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.5 1999/06/01 17:54:31 pefo Exp $	*/
d48 1
a48 8
#ifdef sun
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#endif

#if defined(sparc) || defined(__mips__) || defined(ibm032) || \
    ((defined(__NetBSD__) || defined(__OpenBSD__)) && !defined(UNALIGNED_ACCESS))
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.7 2000/06/19 03:00:54 jason Exp $	*/
d48 8
a55 1
#ifndef UNALIGNED_ACCESS
@


1.6.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 2
a82 2
int	bpf_m_xword(struct mbuf *, int, int *);
int	bpf_m_xhalf(struct mbuf *, int, int *);
@


1.6.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.6.4.2 2002/03/28 14:57:36 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a42 4
#ifndef _KERNEL
#include <stdlib.h>
#include "pcap.h"
#endif
d82 2
a83 2
	struct mbuf *m;
	int k, *err;
d85 3
a87 3
	int len;
	u_char *cp, *np;
	struct mbuf *m0;
d118 2
a119 2
	struct mbuf *m;
	int k, *err;
d121 3
a123 3
	int len;
	u_char *cp;
	struct mbuf *m0;
d151 2
a152 2
	struct bpf_insn *pc;
	u_char *p;
d154 1
a154 1
	u_int buflen;
d156 2
a157 2
	u_int32_t A = 0, X = 0;
	int k;
d222 2
a223 2
				struct mbuf *m;
				int len;
d288 2
a289 2
				struct mbuf *m;
				int len;
d308 2
a309 2
				struct mbuf *m;
				int len;
d481 2
a482 2
	int i;
	struct bpf_insn *p;
d491 1
a491 1
			int from = i + 1;
@


1.6.4.5
log
@Merge with the trunk
@
text
@d81 2
a82 4
extern int bpf_maxbufsize;

int	bpf_m_xword(struct mbuf *, u_int32_t, int *);
int	bpf_m_xhalf(struct mbuf *, u_int32_t, int *);
d87 1
a87 2
	u_int32_t k;
	int *err;
d95 1
a95 1
	if (len >= k + 4) {
d123 1
a123 2
	u_int32_t k;
	int *err;
d131 1
a131 1
	if (len >= k + 2) {
d161 1
a161 1
	u_int32_t k;
d485 1
a485 1
	u_int i, from;
a487 3
	if (len < 1 || len > BPF_MAXINSNS)
		return 0;

a488 2
		p = &f[i];
		switch (BPF_CLASS(p->code)) {
d490 2
a491 1
		 * Check that memory operations use valid addresses.
d493 6
a498 45
		case BPF_LD:
		case BPF_LDX:
			switch (BPF_MODE(p->code)) {
			case BPF_IMM:
				break;
			case BPF_ABS:
			case BPF_IND:
			case BPF_MSH:
				/*
				 * More strict check with actual packet length
				 * is done runtime.
				 */
				if (p->k >= bpf_maxbufsize)
					return 0;
				break;
			case BPF_MEM:
				if (p->k >= BPF_MEMWORDS)
					return 0;
				break;
			case BPF_LEN:
				break;
			default:
				return 0;
			}
			break;
		case BPF_ST:
		case BPF_STX:
			if (p->k >= BPF_MEMWORDS)
				return 0;
			break;
		case BPF_ALU:
			switch (BPF_OP(p->code)) {
			case BPF_ADD:
			case BPF_SUB:
			case BPF_OR:
			case BPF_AND:
			case BPF_LSH:
			case BPF_RSH:
			case BPF_NEG:
				break;
			case BPF_DIV:
				/*
				 * Check for constant division by 0.
				 */
				if (BPF_RVAL(p->code) == BPF_K && p->k == 0)
a499 2
			default:
				return 0;
d501 1
a501 20
			break;
		case BPF_JMP:
			/*
			 * Check that that jumps are forward, and within 
			 * the code block.
			 */
			from = i + 1;
			switch (BPF_OP(p->code)) {
			case BPF_JA:
				if (from + p->k < from || from + p->k >= len)
					return 0;
				break;
			case BPF_JEQ:
			case BPF_JGT:
			case BPF_JGE:
			case BPF_JSET:
				if (from + p->jt >= len || from + p->jf >= len)
					return 0;
				break;
			default:
d503 13
a515 7
			}
			break;
		case BPF_RET:
			break;
		case BPF_MISC:
			break;
		default:
a516 2
		}

@


1.5
log
@Fix some mips -> __mips__ stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf_filter.c,v 1.4 1996/08/22 00:35:50 deraadt Exp $	*/
d88 2
a89 2
static int m_xword __P((struct mbuf *, int, int *));
static int m_xhalf __P((struct mbuf *, int, int *));
d91 2
a92 2
static int
m_xword(m, k, err)
d127 2
a128 2
static int
m_xhalf(m, k, err)
d201 1
a201 1
				A = m_xword((struct mbuf *)p, k, &merr);
d220 1
a220 1
				A = m_xhalf((struct mbuf *)p, k, &merr);
d265 1
a265 1
				A = m_xword((struct mbuf *)p, k, &merr);
d284 1
a284 1
				A = m_xhalf((struct mbuf *)p, k, &merr);
@


1.4
log
@__OpenBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
#if defined(sparc) || defined(mips) || defined(ibm032) || \
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d55 1
a55 1
    (defined(__NetBSD__) && !defined(UNALIGNED_ACCESS))
@


1.2
log
@For the '#ifdef sun [...] #endif' conditional we weren't bringing in the
proper definitions for 'struct mbuf' and friends for in.h, bringing in
'sys/socket.h' and 'net/if.h' fixes this.
@
text
@d1 2
a2 1
/*	$NetBSD: bpf_filter.c,v 1.11 1995/04/22 13:26:39 cgd Exp $	*/
d88 3
d167 1
a167 1
	register u_int32_t A, X;
a175 4
#ifdef lint
	A = 0;
	X = 0;
#endif
@


1.1
log
@Initial revision
@
text
@d48 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
