head	1.61;
access;
symbols
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.57.0.6
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.54.0.4
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.4
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.31.0.4
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.12
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.4.0.2;
locks; strict;
comment	@ * @;


1.61
date	2017.06.06.11.39.55;	author mpi;	state Exp;
branches;
next	1.60;
commitid	HoJqhJJDkl9tRoHt;

1.60
date	2017.05.05.11.04.18;	author bluhm;	state Exp;
branches;
next	1.59;
commitid	e7lFBlOrOiuLgJ3F;

1.59
date	2017.02.28.16.46.27;	author bluhm;	state Exp;
branches;
next	1.58;
commitid	rmbXKt3efXwOBuCw;

1.58
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.57;
commitid	6c6qq5OdS4VVnyVM;

1.57
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.56;
commitid	CLwtYUTkBZ3FXV1w;

1.56
date	2015.11.03.01.50.36;	author mikeb;	state Exp;
branches;
next	1.55;
commitid	HPo8Yd5Adcuitvw4;

1.55
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.54;
commitid	sTEWfQrcV5GjIWc0;

1.54
date	2015.06.11.15.59.17;	author mikeb;	state Exp;
branches;
next	1.53;
commitid	m5XqNI2MUatfnThg;

1.53
date	2015.05.25.22.18.38;	author benno;	state Exp;
branches;
next	1.52;
commitid	tVkHzua8hloyIYSM;

1.52
date	2015.05.25.18.48.17;	author benno;	state Exp;
branches;
next	1.51;
commitid	7uSlxio0pM7JMIzC;

1.51
date	2015.05.23.12.38.53;	author markus;	state Exp;
branches;
next	1.50;
commitid	Mgx7ewWJ5ueyVCxt;

1.50
date	2015.04.17.10.04.37;	author mikeb;	state Exp;
branches;
next	1.49;
commitid	KP3L4W0chjmfJmS7;

1.49
date	2015.04.16.19.18.10;	author markus;	state Exp;
branches;
next	1.48;
commitid	95HrEjJkuhjwwAbo;

1.48
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.47;
commitid	bQi1IVHgugweH5gs;

1.47
date	2015.02.06.03.04.49;	author blambert;	state Exp;
branches;
next	1.46;
commitid	yqVbq4n45c5kMHMd;

1.46
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	VK3ncyiP3NS1N4Sy;

1.45
date	2014.12.28.10.02.37;	author tedu;	state Exp;
branches;
next	1.44;
commitid	cPvnXrnDy9of9D0l;

1.44
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.43;
commitid	zhW8jJrfVCoAthrR;

1.43
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.42;
commitid	B4dZSbxas1X1IpXI;

1.42
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2013.10.12.11.55.46;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2013.06.05.02.03.15;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.09.16.51.30;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2012.09.18.09.24.45;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.13.11.28.47;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.22.12.48.52;	author mikeb;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.22.23.04.45;	author mpf;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.13.21.00.14;	author hshoexer;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.01.07.06.09;	author todd;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.30.17.41.44;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.27.17.59.22;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.27.15.27.27;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.25.05.47.53;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.24.02.30.03;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.10.13.42.11;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.10.16.17.05;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.21.20.44.54;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.24.09.59.02;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.24.08.03.19;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.23.18.45.32;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.16.21.30.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.15.22.57.59;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.09.23.15.42;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.07.23.18.29;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.04.47.06;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.07.01.51.54;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.31.01.38.04;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.12.04.46.42;	author angelos;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.12.06.22.52.10;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.05.16.48.04;	author jjbg;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.26.06.10.20;	author angelos;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.06.25.05.14.00;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.23.18.30.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.08.02.53.49;	author angelos;	state Exp;
branches;
next	;

1.4.2.1
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2004.02.19.10.57.22;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.30.46;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.22.29.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Fix build without PF.
@
text
@/*	$OpenBSD: pfkeyv2_convert.c,v 1.60 2017/05/05 11:04:18 bluhm Exp $	*/
/*
 * The author of this code is Angelos D. Keromytis (angelos@@keromytis.org)
 *
 * Part of this code is based on code written by Craig Metz (cmetz@@inner.net)
 * for NRL. Those licenses follow this one.
 *
 * Copyright (c) 2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Craig Metz. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "pf.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <net/route.h>
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
#include <net/pfkeyv2.h>
#include <crypto/cryptodev.h>
#include <crypto/xform.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

/*
 * (Partly) Initialize a TDB based on an SADB_SA payload. Other parts
 * of the TDB will be initialized by other import routines, and tdb_init().
 */
void
import_sa(struct tdb *tdb, struct sadb_sa *sadb_sa, struct ipsecinit *ii)
{
	if (!sadb_sa)
		return;

	if (ii) {
		ii->ii_encalg = sadb_sa->sadb_sa_encrypt;
		ii->ii_authalg = sadb_sa->sadb_sa_auth;
		ii->ii_compalg = sadb_sa->sadb_sa_encrypt; /* Yeurk! */

		tdb->tdb_spi = sadb_sa->sadb_sa_spi;
		tdb->tdb_wnd = sadb_sa->sadb_sa_replay;

		if (sadb_sa->sadb_sa_flags & SADB_SAFLAGS_PFS)
			tdb->tdb_flags |= TDBF_PFS;

		if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_TUNNEL)
			tdb->tdb_flags |= TDBF_TUNNELING;

		if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_UDPENCAP)
			tdb->tdb_flags |= TDBF_UDPENCAP;

		if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_ESN)
			tdb->tdb_flags |= TDBF_ESN;
	}

	if (sadb_sa->sadb_sa_state != SADB_SASTATE_MATURE)
		tdb->tdb_flags |= TDBF_INVALID;
}

/*
 * Export some of the information on a TDB.
 */
void
export_sa(void **p, struct tdb *tdb)
{
	struct sadb_sa *sadb_sa = (struct sadb_sa *) *p;

	sadb_sa->sadb_sa_len = sizeof(struct sadb_sa) / sizeof(uint64_t);

	sadb_sa->sadb_sa_spi = tdb->tdb_spi;
	sadb_sa->sadb_sa_replay = tdb->tdb_wnd;

	if (tdb->tdb_flags & TDBF_INVALID)
		sadb_sa->sadb_sa_state = SADB_SASTATE_LARVAL;
	else
		sadb_sa->sadb_sa_state = SADB_SASTATE_MATURE;

	if (tdb->tdb_sproto == IPPROTO_IPCOMP &&
	    tdb->tdb_compalgxform != NULL) {
		switch (tdb->tdb_compalgxform->type) {
		case CRYPTO_DEFLATE_COMP:
			sadb_sa->sadb_sa_encrypt = SADB_X_CALG_DEFLATE;
			break;
		case CRYPTO_LZS_COMP:
			sadb_sa->sadb_sa_encrypt = SADB_X_CALG_LZS;
			break;
		}
	}

	if (tdb->tdb_authalgxform) {
		switch (tdb->tdb_authalgxform->type) {
		case CRYPTO_MD5_HMAC:
			sadb_sa->sadb_sa_auth = SADB_AALG_MD5HMAC;
			break;

		case CRYPTO_SHA1_HMAC:
			sadb_sa->sadb_sa_auth = SADB_AALG_SHA1HMAC;
			break;

		case CRYPTO_RIPEMD160_HMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
			break;

		case CRYPTO_SHA2_256_HMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA2_256;
			break;

		case CRYPTO_SHA2_384_HMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA2_384;
			break;

		case CRYPTO_SHA2_512_HMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA2_512;
			break;

		case CRYPTO_AES_128_GMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_AES128GMAC;
			break;

		case CRYPTO_AES_192_GMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_AES192GMAC;
			break;

		case CRYPTO_AES_256_GMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_AES256GMAC;
			break;

		case CRYPTO_CHACHA20_POLY1305_MAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_CHACHA20POLY1305;
			break;
		}
	}

	if (tdb->tdb_encalgxform) {
		switch (tdb->tdb_encalgxform->type) {
		case CRYPTO_NULL:
			sadb_sa->sadb_sa_encrypt = SADB_EALG_NULL;
			break;

		case CRYPTO_3DES_CBC:
			sadb_sa->sadb_sa_encrypt = SADB_EALG_3DESCBC;
			break;

		case CRYPTO_AES_CBC:
			sadb_sa->sadb_sa_encrypt = SADB_X_EALG_AES;
			break;

		case CRYPTO_AES_CTR:
			sadb_sa->sadb_sa_encrypt = SADB_X_EALG_AESCTR;
			break;

		case CRYPTO_AES_GCM_16:
			sadb_sa->sadb_sa_encrypt = SADB_X_EALG_AESGCM16;
			break;

		case CRYPTO_AES_GMAC:
			sadb_sa->sadb_sa_encrypt = SADB_X_EALG_AESGMAC;
			break;

		case CRYPTO_CAST_CBC:
			sadb_sa->sadb_sa_encrypt = SADB_X_EALG_CAST;
			break;

		case CRYPTO_BLF_CBC:
			sadb_sa->sadb_sa_encrypt = SADB_X_EALG_BLF;
			break;

		case CRYPTO_CHACHA20_POLY1305:
			sadb_sa->sadb_sa_encrypt = SADB_X_EALG_CHACHA20POLY1305;
			break;
		}
	}

	if (tdb->tdb_flags & TDBF_PFS)
		sadb_sa->sadb_sa_flags |= SADB_SAFLAGS_PFS;

	if (tdb->tdb_flags & TDBF_TUNNELING)
		sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;

	if (tdb->tdb_flags & TDBF_UDPENCAP)
		sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_UDPENCAP;

	if (tdb->tdb_flags & TDBF_ESN)
		sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_ESN;

	*p += sizeof(struct sadb_sa);
}

/*
 * Initialize expirations and counters based on lifetime payload.
 */
void
import_lifetime(struct tdb *tdb, struct sadb_lifetime *sadb_lifetime, int type)
{
	if (!sadb_lifetime)
		return;

	switch (type) {
	case PFKEYV2_LIFETIME_HARD:
		if ((tdb->tdb_exp_allocations =
		    sadb_lifetime->sadb_lifetime_allocations) != 0)
			tdb->tdb_flags |= TDBF_ALLOCATIONS;
		else
			tdb->tdb_flags &= ~TDBF_ALLOCATIONS;

		if ((tdb->tdb_exp_bytes =
		    sadb_lifetime->sadb_lifetime_bytes) != 0)
			tdb->tdb_flags |= TDBF_BYTES;
		else
			tdb->tdb_flags &= ~TDBF_BYTES;

		if ((tdb->tdb_exp_timeout =
		    sadb_lifetime->sadb_lifetime_addtime) != 0) {
			tdb->tdb_flags |= TDBF_TIMER;
			timeout_add_sec(&tdb->tdb_timer_tmo,
			    tdb->tdb_exp_timeout);
		} else
			tdb->tdb_flags &= ~TDBF_TIMER;

		if ((tdb->tdb_exp_first_use =
		    sadb_lifetime->sadb_lifetime_usetime) != 0)
			tdb->tdb_flags |= TDBF_FIRSTUSE;
		else
			tdb->tdb_flags &= ~TDBF_FIRSTUSE;
		break;

	case PFKEYV2_LIFETIME_SOFT:
		if ((tdb->tdb_soft_allocations =
		    sadb_lifetime->sadb_lifetime_allocations) != 0)
			tdb->tdb_flags |= TDBF_SOFT_ALLOCATIONS;
		else
			tdb->tdb_flags &= ~TDBF_SOFT_ALLOCATIONS;

		if ((tdb->tdb_soft_bytes =
		    sadb_lifetime->sadb_lifetime_bytes) != 0)
			tdb->tdb_flags |= TDBF_SOFT_BYTES;
		else
			tdb->tdb_flags &= ~TDBF_SOFT_BYTES;

		if ((tdb->tdb_soft_timeout =
		    sadb_lifetime->sadb_lifetime_addtime) != 0) {
			tdb->tdb_flags |= TDBF_SOFT_TIMER;
			timeout_add_sec(&tdb->tdb_stimer_tmo,
			    tdb->tdb_soft_timeout);
		} else
			tdb->tdb_flags &= ~TDBF_SOFT_TIMER;

		if ((tdb->tdb_soft_first_use =
		    sadb_lifetime->sadb_lifetime_usetime) != 0)
			tdb->tdb_flags |= TDBF_SOFT_FIRSTUSE;
		else
			tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
		break;

	case PFKEYV2_LIFETIME_CURRENT:  /* Nothing fancy here. */
		tdb->tdb_cur_allocations =
		    sadb_lifetime->sadb_lifetime_allocations;
		tdb->tdb_cur_bytes = sadb_lifetime->sadb_lifetime_bytes;
		tdb->tdb_established = sadb_lifetime->sadb_lifetime_addtime;
		tdb->tdb_first_use = sadb_lifetime->sadb_lifetime_usetime;
	}
}

/*
 * Export TDB expiration information.
 */
void
export_lifetime(void **p, struct tdb *tdb, int type)
{
	struct sadb_lifetime *sadb_lifetime = (struct sadb_lifetime *) *p;

	sadb_lifetime->sadb_lifetime_len = sizeof(struct sadb_lifetime) /
	    sizeof(uint64_t);

	switch (type) {
	case PFKEYV2_LIFETIME_HARD:
		if (tdb->tdb_flags & TDBF_ALLOCATIONS)
			sadb_lifetime->sadb_lifetime_allocations =
			    tdb->tdb_exp_allocations;

		if (tdb->tdb_flags & TDBF_BYTES)
			sadb_lifetime->sadb_lifetime_bytes =
			    tdb->tdb_exp_bytes;

		if (tdb->tdb_flags & TDBF_TIMER)
			sadb_lifetime->sadb_lifetime_addtime =
			    tdb->tdb_exp_timeout;

		if (tdb->tdb_flags & TDBF_FIRSTUSE)
			sadb_lifetime->sadb_lifetime_usetime =
			    tdb->tdb_exp_first_use;
		break;

	case PFKEYV2_LIFETIME_SOFT:
		if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS)
			sadb_lifetime->sadb_lifetime_allocations =
			    tdb->tdb_soft_allocations;

		if (tdb->tdb_flags & TDBF_SOFT_BYTES)
			sadb_lifetime->sadb_lifetime_bytes =
			    tdb->tdb_soft_bytes;

		if (tdb->tdb_flags & TDBF_SOFT_TIMER)
			sadb_lifetime->sadb_lifetime_addtime =
			    tdb->tdb_soft_timeout;

		if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
			sadb_lifetime->sadb_lifetime_usetime =
			    tdb->tdb_soft_first_use;
		break;

	case PFKEYV2_LIFETIME_CURRENT:
		sadb_lifetime->sadb_lifetime_allocations =
		    tdb->tdb_cur_allocations;
		sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_cur_bytes;
		sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_established;
		sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_first_use;
		break;

	case PFKEYV2_LIFETIME_LASTUSE:
		sadb_lifetime->sadb_lifetime_allocations = 0;
		sadb_lifetime->sadb_lifetime_bytes = 0;
		sadb_lifetime->sadb_lifetime_addtime = 0;
		sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_last_used;
		break;
	}

	*p += sizeof(struct sadb_lifetime);
}

/*
 * Import flow information to two struct sockaddr_encap's. Either
 * all or none of the address arguments are NULL.
 */
void
import_flow(struct sockaddr_encap *flow, struct sockaddr_encap *flowmask,
    struct sadb_address *ssrc, struct sadb_address *ssrcmask,
    struct sadb_address *ddst, struct sadb_address *ddstmask,
    struct sadb_protocol *sab, struct sadb_protocol *ftype)
{
	u_int8_t transproto = 0;
	union sockaddr_union *src = (union sockaddr_union *)(ssrc + 1);
	union sockaddr_union *dst = (union sockaddr_union *)(ddst + 1);
	union sockaddr_union *srcmask = (union sockaddr_union *)(ssrcmask + 1);
	union sockaddr_union *dstmask = (union sockaddr_union *)(ddstmask + 1);

	if (ssrc == NULL)
		return; /* There wasn't any information to begin with. */

	bzero(flow, sizeof(*flow));
	bzero(flowmask, sizeof(*flowmask));

	if (sab != NULL)
		transproto = sab->sadb_protocol_proto;

	/*
	 * Check that all the address families match. We know they are
	 * valid and supported because pfkeyv2_parsemessage() checked that.
	 */
	if ((src->sa.sa_family != dst->sa.sa_family) ||
	    (src->sa.sa_family != srcmask->sa.sa_family) ||
	    (src->sa.sa_family != dstmask->sa.sa_family))
		return;

	/*
	 * We set these as an indication that tdb_filter/tdb_filtermask are
	 * in fact initialized.
	 */
	flow->sen_family = flowmask->sen_family = PF_KEY;
	flow->sen_len = flowmask->sen_len = SENT_LEN;

	switch (src->sa.sa_family) {
	case AF_INET:
		/* netmask handling */
		rt_maskedcopy(&src->sa, &src->sa, &srcmask->sa);
		rt_maskedcopy(&dst->sa, &dst->sa, &dstmask->sa);

		flow->sen_type = SENT_IP4;
		flow->sen_direction = ftype->sadb_protocol_direction;
		flow->sen_ip_src = src->sin.sin_addr;
		flow->sen_ip_dst = dst->sin.sin_addr;
		flow->sen_proto = transproto;
		flow->sen_sport = src->sin.sin_port;
		flow->sen_dport = dst->sin.sin_port;

		flowmask->sen_type = SENT_IP4;
		flowmask->sen_direction = 0xff;
		flowmask->sen_ip_src = srcmask->sin.sin_addr;
		flowmask->sen_ip_dst = dstmask->sin.sin_addr;
		flowmask->sen_sport = srcmask->sin.sin_port;
		flowmask->sen_dport = dstmask->sin.sin_port;
		if (transproto)
			flowmask->sen_proto = 0xff;
		break;

#ifdef INET6
	case AF_INET6:
		in6_embedscope(&src->sin6.sin6_addr, &src->sin6,
		    NULL);
		in6_embedscope(&dst->sin6.sin6_addr, &dst->sin6,
		    NULL);

		/* netmask handling */
		rt_maskedcopy(&src->sa, &src->sa, &srcmask->sa);
		rt_maskedcopy(&dst->sa, &dst->sa, &dstmask->sa);

		flow->sen_type = SENT_IP6;
		flow->sen_ip6_direction = ftype->sadb_protocol_direction;
		flow->sen_ip6_src = src->sin6.sin6_addr;
		flow->sen_ip6_dst = dst->sin6.sin6_addr;
		flow->sen_ip6_proto = transproto;
		flow->sen_ip6_sport = src->sin6.sin6_port;
		flow->sen_ip6_dport = dst->sin6.sin6_port;

		flowmask->sen_type = SENT_IP6;
		flowmask->sen_ip6_direction = 0xff;
		flowmask->sen_ip6_src = srcmask->sin6.sin6_addr;
		flowmask->sen_ip6_dst = dstmask->sin6.sin6_addr;
		flowmask->sen_ip6_sport = srcmask->sin6.sin6_port;
		flowmask->sen_ip6_dport = dstmask->sin6.sin6_port;
		if (transproto)
			flowmask->sen_ip6_proto = 0xff;
		break;
#endif /* INET6 */
	}
}

/*
 * Helper to export addresses from an struct sockaddr_encap.
 */
static void
export_encap(void **p, struct sockaddr_encap *encap, int type)
{
	struct sadb_address *saddr = (struct sadb_address *)*p;
	union sockaddr_union *sunion;

	*p += sizeof(struct sadb_address);
	sunion = (union sockaddr_union *)*p;

	switch (encap->sen_type) {
	case SENT_IP4:
		saddr->sadb_address_len = (sizeof(struct sadb_address) +
		    PADUP(sizeof(struct sockaddr_in))) / sizeof(uint64_t);
		sunion->sa.sa_len = sizeof(struct sockaddr_in);
		sunion->sa.sa_family = AF_INET;
		if (type == SADB_X_EXT_SRC_FLOW ||
		    type == SADB_X_EXT_SRC_MASK) {
			sunion->sin.sin_addr = encap->sen_ip_src;
			sunion->sin.sin_port = encap->sen_sport;
		} else {
			sunion->sin.sin_addr = encap->sen_ip_dst;
			sunion->sin.sin_port = encap->sen_dport;
		}
		*p += PADUP(sizeof(struct sockaddr_in));
		break;
        case SENT_IP6:
		saddr->sadb_address_len = (sizeof(struct sadb_address)
		    + PADUP(sizeof(struct sockaddr_in6))) / sizeof(uint64_t);
		sunion->sa.sa_len = sizeof(struct sockaddr_in6);
		sunion->sa.sa_family = AF_INET6;
		if (type == SADB_X_EXT_SRC_FLOW ||
		    type == SADB_X_EXT_SRC_MASK) {
			sunion->sin6.sin6_addr = encap->sen_ip6_src;
			sunion->sin6.sin6_port = encap->sen_ip6_sport;
		} else {
			sunion->sin6.sin6_addr = encap->sen_ip6_dst;
			sunion->sin6.sin6_port = encap->sen_ip6_dport;
		}
		*p += PADUP(sizeof(struct sockaddr_in6));
		break;
	}
}

/*
 * Export flow information from two struct sockaddr_encap's.
 */
void
export_flow(void **p, u_int8_t ftype, struct sockaddr_encap *flow,
    struct sockaddr_encap *flowmask, void **headers)
{
	struct sadb_protocol *sab;

	headers[SADB_X_EXT_FLOW_TYPE] = *p;
	sab = (struct sadb_protocol *)*p;
	sab->sadb_protocol_len = sizeof(struct sadb_protocol) /
	    sizeof(uint64_t);

	switch (ftype) {
	case IPSP_IPSEC_USE:
		sab->sadb_protocol_proto = SADB_X_FLOW_TYPE_USE;
		break;
	case IPSP_IPSEC_ACQUIRE:
		sab->sadb_protocol_proto = SADB_X_FLOW_TYPE_ACQUIRE;
		break;
	case IPSP_IPSEC_REQUIRE:
		sab->sadb_protocol_proto = SADB_X_FLOW_TYPE_REQUIRE;
		break;
	case IPSP_DENY:
		sab->sadb_protocol_proto = SADB_X_FLOW_TYPE_DENY;
		break;
	case IPSP_PERMIT:
		sab->sadb_protocol_proto = SADB_X_FLOW_TYPE_BYPASS;
		break;
	case IPSP_IPSEC_DONTACQ:
		sab->sadb_protocol_proto = SADB_X_FLOW_TYPE_DONTACQ;
		break;
	default:
		sab->sadb_protocol_proto = 0;
		break;
	}

	switch (flow->sen_type) {
	case SENT_IP4:
		sab->sadb_protocol_direction = flow->sen_direction;
		break;
#ifdef INET6
	case SENT_IP6:
		sab->sadb_protocol_direction = flow->sen_ip6_direction;
		break;
#endif /* INET6 */
	}
	*p += sizeof(struct sadb_protocol);

	headers[SADB_X_EXT_PROTOCOL] = *p;
	sab = (struct sadb_protocol *)*p;
	sab->sadb_protocol_len = sizeof(struct sadb_protocol) /
	    sizeof(uint64_t);
	switch (flow->sen_type) {
	case SENT_IP4:
		sab->sadb_protocol_proto = flow->sen_proto;
		break;
#ifdef INET6
	case SENT_IP6:
		sab->sadb_protocol_proto = flow->sen_ip6_proto;
		break;
#endif /* INET6 */
	}
	*p += sizeof(struct sadb_protocol);

	headers[SADB_X_EXT_SRC_FLOW] = *p;
	export_encap(p, flow, SADB_X_EXT_SRC_FLOW);

	headers[SADB_X_EXT_SRC_MASK] = *p;
	export_encap(p, flowmask, SADB_X_EXT_SRC_MASK);

	headers[SADB_X_EXT_DST_FLOW] = *p;
	export_encap(p, flow, SADB_X_EXT_DST_FLOW);

	headers[SADB_X_EXT_DST_MASK] = *p;
	export_encap(p, flowmask, SADB_X_EXT_DST_MASK);
}

/*
 * Copy an SADB_ADDRESS payload to a struct sockaddr.
 */
void
import_address(struct sockaddr *sa, struct sadb_address *sadb_address)
{
	int salen;
	struct sockaddr *ssa = (struct sockaddr *)((void *) sadb_address +
	    sizeof(struct sadb_address));

	if (!sadb_address)
		return;

	if (ssa->sa_len)
		salen = ssa->sa_len;
	else
		switch (ssa->sa_family) {
		case AF_INET:
			salen = sizeof(struct sockaddr_in);
			break;

#ifdef INET6
		case AF_INET6:
			salen = sizeof(struct sockaddr_in6);
			break;
#endif /* INET6 */

		default:
			return;
		}

	bcopy(ssa, sa, salen);
	sa->sa_len = salen;
}

/*
 * Export a struct sockaddr as an SADB_ADDRESS payload.
 */
void
export_address(void **p, struct sockaddr *sa)
{
	struct sadb_address *sadb_address = (struct sadb_address *) *p;

	sadb_address->sadb_address_len = (sizeof(struct sadb_address) +
	    PADUP(sa->sa_len)) / sizeof(uint64_t);

	*p += sizeof(struct sadb_address);
	bcopy(sa, *p, sa->sa_len);
	((struct sockaddr *) *p)->sa_family = sa->sa_family;
	*p += PADUP(sa->sa_len);
}

/*
 * Import an identity payload into the TDB.
 */
static void
import_identity(struct ipsec_id **id, struct sadb_ident *sadb_ident)
{
	if (!sadb_ident) {
		*id = NULL;
		return;
	}

	*id = malloc(EXTLEN(sadb_ident) - sizeof(struct sadb_ident) +
	    sizeof(struct ipsec_id), M_CREDENTIALS, M_WAITOK);
	(*id)->len = EXTLEN(sadb_ident) - sizeof(struct sadb_ident);

	switch (sadb_ident->sadb_ident_type) {
	case SADB_IDENTTYPE_PREFIX:
		(*id)->type = IPSP_IDENTITY_PREFIX;
		break;
	case SADB_IDENTTYPE_FQDN:
		(*id)->type = IPSP_IDENTITY_FQDN;
		break;
	case SADB_IDENTTYPE_USERFQDN:
		(*id)->type = IPSP_IDENTITY_USERFQDN;
		break;
	default:
		free(*id, M_CREDENTIALS, 0);
		*id = NULL;
		return;
	}
	bcopy((void *) sadb_ident + sizeof(struct sadb_ident), (*id) + 1,
	    (*id)->len);
}

void
import_identities(struct ipsec_ids **ids, int swapped,
    struct sadb_ident *srcid, struct sadb_ident *dstid)
{
	struct ipsec_ids *tmp;

	*ids = NULL;
	tmp = malloc(sizeof(struct ipsec_ids), M_CREDENTIALS, M_WAITOK);
	import_identity(&tmp->id_local, swapped ? dstid: srcid);
	import_identity(&tmp->id_remote, swapped ? srcid: dstid);
	if (tmp->id_local != NULL && tmp->id_remote != NULL) {
		*ids = ipsp_ids_insert(tmp);
		if (*ids == tmp)
			return;
	}
	free(tmp->id_local, M_CREDENTIALS, 0);
	free(tmp->id_remote, M_CREDENTIALS, 0);
	free(tmp, M_CREDENTIALS, 0);
}

static void
export_identity(void **p, struct ipsec_id *id)
{
	struct sadb_ident *sadb_ident = (struct sadb_ident *) *p;

	sadb_ident->sadb_ident_len = (sizeof(struct sadb_ident) +
	    PADUP(id->len)) / sizeof(uint64_t);

	switch (id->type) {
	case IPSP_IDENTITY_PREFIX:
		sadb_ident->sadb_ident_type = SADB_IDENTTYPE_PREFIX;
		break;
	case IPSP_IDENTITY_FQDN:
		sadb_ident->sadb_ident_type = SADB_IDENTTYPE_FQDN;
		break;
	case IPSP_IDENTITY_USERFQDN:
		sadb_ident->sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
		break;
	}
	*p += sizeof(struct sadb_ident);
	bcopy(id + 1, *p, id->len);
	*p += PADUP(id->len);
}

void
export_identities(void **p, struct ipsec_ids *ids, int swapped,
    void **headers)
{
	headers[SADB_EXT_IDENTITY_SRC] = *p;
	export_identity(p, swapped ? ids->id_remote : ids->id_local);
	headers[SADB_EXT_IDENTITY_DST] = *p;
	export_identity(p, swapped ? ids->id_local : ids->id_remote);
}

/* ... */
void
import_key(struct ipsecinit *ii, struct sadb_key *sadb_key, int type)
{
	if (!sadb_key)
		return;

	if (type == PFKEYV2_ENCRYPTION_KEY) { /* Encryption key */
		ii->ii_enckeylen = sadb_key->sadb_key_bits / 8;
		ii->ii_enckey = (void *)sadb_key + sizeof(struct sadb_key);
	} else {
		ii->ii_authkeylen = sadb_key->sadb_key_bits / 8;
		ii->ii_authkey = (void *)sadb_key + sizeof(struct sadb_key);
	}
}

void
export_key(void **p, struct tdb *tdb, int type)
{
	struct sadb_key *sadb_key = (struct sadb_key *) *p;

	if (type == PFKEYV2_ENCRYPTION_KEY) {
		sadb_key->sadb_key_len = (sizeof(struct sadb_key) +
		    PADUP(tdb->tdb_emxkeylen)) /
		    sizeof(uint64_t);
		sadb_key->sadb_key_bits = tdb->tdb_emxkeylen * 8;
		*p += sizeof(struct sadb_key);
		bcopy(tdb->tdb_emxkey, *p, tdb->tdb_emxkeylen);
		*p += PADUP(tdb->tdb_emxkeylen);
	} else {
		sadb_key->sadb_key_len = (sizeof(struct sadb_key) +
		    PADUP(tdb->tdb_amxkeylen)) /
		    sizeof(uint64_t);
		sadb_key->sadb_key_bits = tdb->tdb_amxkeylen * 8;
		*p += sizeof(struct sadb_key);
		bcopy(tdb->tdb_amxkey, *p, tdb->tdb_amxkeylen);
		*p += PADUP(tdb->tdb_amxkeylen);
	}
}

/* Import/Export remote port for UDP Encapsulation */
void
import_udpencap(struct tdb *tdb, struct sadb_x_udpencap *sadb_udpencap)
{
	if (sadb_udpencap)
		tdb->tdb_udpencap_port = sadb_udpencap->sadb_x_udpencap_port;
}

void
export_udpencap(void **p, struct tdb *tdb)
{
	struct sadb_x_udpencap *sadb_udpencap = (struct sadb_x_udpencap *) *p;

	sadb_udpencap->sadb_x_udpencap_port = tdb->tdb_udpencap_port;
	sadb_udpencap->sadb_x_udpencap_reserved = 0;
	sadb_udpencap->sadb_x_udpencap_len =
	    sizeof(struct sadb_x_udpencap) / sizeof(uint64_t);
	*p += sizeof(struct sadb_x_udpencap);
}

#if NPF > 0
/* Import PF tag information for SA */
void
import_tag(struct tdb *tdb, struct sadb_x_tag *stag)
{
	char *s;

	if (stag) {
		s = (char *)(stag + 1);
		tdb->tdb_tag = pf_tagname2tag(s, 1);
	}
}

/* Export PF tag information for SA */
void
export_tag(void **p, struct tdb *tdb)
{
	struct sadb_x_tag *stag = (struct sadb_x_tag *)*p;
	char *s = (char *)(stag + 1);

	pf_tag2tagname(tdb->tdb_tag, s);

	stag->sadb_x_tag_taglen = strlen(s) + 1;
	stag->sadb_x_tag_len = (sizeof(struct sadb_x_tag) +
	    PADUP(stag->sadb_x_tag_taglen)) / sizeof(uint64_t);
	*p += sizeof(struct sadb_x_tag) + PADUP(stag->sadb_x_tag_taglen);
}

/* Import enc(4) tap device information for SA */
void
import_tap(struct tdb *tdb, struct sadb_x_tap *stap)
{
	if (stap)
		tdb->tdb_tap = stap->sadb_x_tap_unit;
}

/* Export enc(4) tap device information for SA */
void
export_tap(void **p, struct tdb *tdb)
{
	struct sadb_x_tap *stag = (struct sadb_x_tap *)*p;

	stag->sadb_x_tap_unit = tdb->tdb_tap;
	stag->sadb_x_tap_len = sizeof(struct sadb_x_tap) / sizeof(uint64_t);
	*p += sizeof(struct sadb_x_tap);
}
#endif

void
export_satype(void **p, struct tdb *tdb)
{
	struct sadb_protocol *sab = *p;

	sab->sadb_protocol_len = sizeof(struct sadb_protocol) /
	    sizeof(uint64_t);
	sab->sadb_protocol_proto = tdb->tdb_satype;
}
@


1.60
log
@Expand SA_LEN(), there is no benefit for using the macro in the
kernel.  It was only used in IPsec sources.  No binary change
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.59 2017/02/28 16:46:27 bluhm Exp $	*/
d890 1
a900 1
#endif
@


1.59
log
@Depending on the addresses, ipsecctl(8) automatically groups sa
bundles together.  Extend the kernel interface to export the bundle
information to userland.  Then ipsecctl -ss -v can show the internal
relations.  Unfortunately the header SADB_X_EXT_PROTOCOL was reused
by SADB_X_GRPSPIS, so it cannot be used to transfer the second sa
type with sysctl.  Introduce a new SADB_X_EXT_SATYPE2 and use it
consistently.
OK hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.58 2017/01/24 10:08:30 krw Exp $	*/
d688 1
a688 1
	    PADUP(SA_LEN(sa))) / sizeof(uint64_t);
d691 1
a691 1
	bcopy(sa, *p, SA_LEN(sa));
d693 1
a693 1
	*p += PADUP(SA_LEN(sa));
@


1.58
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.57 2015/12/09 21:41:50 naddy Exp $	*/
d889 10
@


1.57
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.56 2015/11/03 01:50:36 mikeb Exp $	*/
d28 1
a28 1
 * 
d32 1
a32 1
 * 
d40 4
a43 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d47 1
a47 1
 * 
d59 1
a59 1
 * 
d602 1
a602 1
	
@


1.56
log
@Plumb Chacha20-Poly1305 into the IPsec/ESP and PF_KEY frameworks

ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.55 2015/09/11 07:42:35 claudio Exp $	*/
a228 4
			break;

		case CRYPTO_DES_CBC:
			sadb_sa->sadb_sa_encrypt = SADB_EALG_DESCBC;
@


1.55
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.54 2015/06/11 15:59:17 mikeb Exp $	*/
d218 4
d261 4
@


1.54
log
@Move away from using hzto(9);  OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.53 2015/05/25 22:18:38 benno Exp $	*/
d486 1
a486 1
		    NULL, NULL);
d488 1
a488 1
		    NULL, NULL);
@


1.53
log
@fix panic for real and revert previous rev 1.52
from markus@@
sorry for the mixup
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.52 2015/05/25 18:48:17 benno Exp $	*/
a281 2
	struct timeval tv;

a284 2
	getmicrotime(&tv);

d302 2
a303 5
			if (tv.tv_sec + tdb->tdb_exp_timeout < tv.tv_sec)
				tv.tv_sec = ((unsigned long) -1) / 2; /* XXX */
			else
				tv.tv_sec += tdb->tdb_exp_timeout;
			timeout_add(&tdb->tdb_timer_tmo, hzto(&tv));
d330 2
a331 5
			if (tv.tv_sec + tdb->tdb_soft_timeout < tv.tv_sec)
				tv.tv_sec = ((unsigned long) -1) / 2; /* XXX */
			else
				tv.tv_sec += tdb->tdb_soft_timeout;
			timeout_add(&tdb->tdb_stimer_tmo, hzto(&tv));
@


1.52
log
@fix a panic in import_identities() in case the ID isnt loaded
(triggered by bgpd).
ok marku@@s, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.51 2015/05/23 12:38:53 markus Exp $	*/
d708 2
a709 1
	if (!sadb_ident)
d711 1
d751 2
a752 4
	if (tmp->id_local != NULL)
		free(tmp->id_local, M_CREDENTIALS, 0);
	if (tmp->id_remote != NULL)
		free(tmp->id_remote, M_CREDENTIALS, 0);
@


1.51
log
@introduce ipsec-id bundles and use them for ipsecflowinfo,
fixes rekeying for l2tp/ipsec against multiple windows clients
and saves memory (for many SAs to same peers); feedback and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.50 2015/04/17 10:04:37 mikeb Exp $	*/
d749 4
a752 2
	free(tmp->id_local, M_CREDENTIALS, 0);
	free(tmp->id_remote, M_CREDENTIALS, 0);
@


1.50
log
@Remove unsupported SADB_X_IDENTTYPE_CONNECTION;  OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.49 2015/04/16 19:18:10 markus Exp $	*/
d705 2
a706 2
void
import_identity(struct ipsec_ref **ipr, struct sadb_ident *sadb_ident)
d711 3
a713 3
	*ipr = malloc(EXTLEN(sadb_ident) - sizeof(struct sadb_ident) +
	    sizeof(struct ipsec_ref), M_CREDENTIALS, M_WAITOK);
	(*ipr)->ref_len = EXTLEN(sadb_ident) - sizeof(struct sadb_ident);
d717 1
a717 1
		(*ipr)->ref_type = IPSP_IDENTITY_PREFIX;
d720 1
a720 1
		(*ipr)->ref_type = IPSP_IDENTITY_FQDN;
d723 1
a723 1
		(*ipr)->ref_type = IPSP_IDENTITY_USERFQDN;
d726 2
a727 2
		free(*ipr, M_CREDENTIALS, 0);
		*ipr = NULL;
d730 2
a731 4
	(*ipr)->ref_count = 1;
	(*ipr)->ref_malloctype = M_CREDENTIALS;
	bcopy((void *) sadb_ident + sizeof(struct sadb_ident), (*ipr) + 1,
	    (*ipr)->ref_len);
d735 21
a755 1
export_identity(void **p, struct ipsec_ref **ipr)
d760 1
a760 1
	    PADUP((*ipr)->ref_len)) / sizeof(uint64_t);
d762 1
a762 1
	switch ((*ipr)->ref_type) {
d774 12
a785 2
	bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
	*p += PADUP((*ipr)->ref_len);
@


1.49
log
@change {import,export}_identity so it can be used for policies; ok mikeb
(fixes sadb_ident_type conversion for policies)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.48 2015/04/14 12:22:15 mikeb Exp $	*/
a724 3
	case SADB_X_IDENTTYPE_CONNECTION:
		(*ipr)->ref_type = IPSP_IDENTITY_CONNECTION;
		break;
a752 3
		break;
	case IPSP_IDENTITY_CONNECTION:
		sadb_ident->sadb_ident_type = SADB_X_IDENTTYPE_CONNECTION;
@


1.48
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.47 2015/02/06 03:04:49 blambert Exp $	*/
d706 1
a706 1
import_identity(struct tdb *tdb, struct sadb_ident *sadb_ident, int type)
a707 2
	struct ipsec_ref **ipr;

a710 5
	if (type == PFKEYV2_IDENTITY_SRC)
		ipr = &tdb->tdb_srcid;
	else
		ipr = &tdb->tdb_dstid;

d740 1
a740 1
export_identity(void **p, struct tdb *tdb, int type)
a741 1
	struct ipsec_ref **ipr;
a742 5

	if (type == PFKEYV2_IDENTITY_SRC)
		ipr = &tdb->tdb_srcid;
	else
		ipr = &tdb->tdb_dstid;
@


1.47
log
@style(9) nit

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.46 2015/01/24 00:29:06 deraadt Exp $	*/
a702 76
 * Import authentication information into the TDB.
 */
void
import_auth(struct tdb *tdb, struct sadb_x_cred *sadb_auth, int dstauth)
{
	struct ipsec_ref **ipr;

	if (!sadb_auth)
		return;

	if (dstauth == PFKEYV2_AUTH_REMOTE)
		ipr = &tdb->tdb_remote_auth;
	else
		ipr = &tdb->tdb_local_auth;

	*ipr = malloc(EXTLEN(sadb_auth) - sizeof(struct sadb_x_cred) +
	    sizeof(struct ipsec_ref), M_CREDENTIALS, M_WAITOK);
	(*ipr)->ref_len = EXTLEN(sadb_auth) - sizeof(struct sadb_x_cred);

	switch (sadb_auth->sadb_x_cred_type) {
	case SADB_X_AUTHTYPE_PASSPHRASE:
		(*ipr)->ref_type = IPSP_AUTH_PASSPHRASE;
		break;
	case SADB_X_AUTHTYPE_RSA:
		(*ipr)->ref_type = IPSP_AUTH_RSA;
		break;
	default:
		free(*ipr, M_CREDENTIALS, 0);
		*ipr = NULL;
		return;
	}
	(*ipr)->ref_count = 1;
	(*ipr)->ref_malloctype = M_CREDENTIALS;
	bcopy((void *) sadb_auth + sizeof(struct sadb_x_cred),
	    (*ipr) + 1, (*ipr)->ref_len);
}

/*
 * Import a set of credentials into the TDB.
 */
void
import_credentials(struct tdb *tdb, struct sadb_x_cred *sadb_cred, int dstcred)
{
	struct ipsec_ref **ipr;

	if (!sadb_cred)
		return;

	if (dstcred == PFKEYV2_CRED_REMOTE)
		ipr = &tdb->tdb_remote_cred;
	else
		ipr = &tdb->tdb_local_cred;

	*ipr = malloc(EXTLEN(sadb_cred) - sizeof(struct sadb_x_cred) +
	    sizeof(struct ipsec_ref), M_CREDENTIALS, M_WAITOK);
	(*ipr)->ref_len = EXTLEN(sadb_cred) - sizeof(struct sadb_x_cred);

	switch (sadb_cred->sadb_x_cred_type) {
	case SADB_X_CREDTYPE_X509:
		(*ipr)->ref_type = IPSP_CRED_X509;
		break;
	case SADB_X_CREDTYPE_KEYNOTE:
		(*ipr)->ref_type = IPSP_CRED_KEYNOTE;
		break;
	default:
		free(*ipr, M_CREDENTIALS, 0);
		*ipr = NULL;
		return;
	}
	(*ipr)->ref_count = 1;
	(*ipr)->ref_malloctype = M_CREDENTIALS;
	bcopy((void *) sadb_cred + sizeof(struct sadb_x_cred),
	    (*ipr) + 1, (*ipr)->ref_len);
}

/*
a743 54
}

void
export_credentials(void **p, struct tdb *tdb, int dstcred)
{
	struct ipsec_ref **ipr;
	struct sadb_x_cred *sadb_cred = (struct sadb_x_cred *) *p;

	if (dstcred == PFKEYV2_CRED_REMOTE)
		ipr = &tdb->tdb_remote_cred;
	else
		ipr = &tdb->tdb_local_cred;

	sadb_cred->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
	    PADUP((*ipr)->ref_len)) / sizeof(uint64_t);

	switch ((*ipr)->ref_type) {
	case IPSP_CRED_KEYNOTE:
		sadb_cred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
		break;
	case IPSP_CRED_X509:
		sadb_cred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
		break;
	}
	*p += sizeof(struct sadb_x_cred);
	bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
	*p += PADUP((*ipr)->ref_len);
}

void
export_auth(void **p, struct tdb *tdb, int dstauth)
{
	struct ipsec_ref **ipr;
	struct sadb_x_cred *sadb_auth = (struct sadb_x_cred *) *p;

	if (dstauth == PFKEYV2_AUTH_REMOTE)
		ipr = &tdb->tdb_remote_auth;
	else
		ipr = &tdb->tdb_local_auth;

	sadb_auth->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
	    PADUP((*ipr)->ref_len)) / sizeof(uint64_t);

	switch ((*ipr)->ref_type) {
	case IPSP_AUTH_PASSPHRASE:
		sadb_auth->sadb_x_cred_type = SADB_X_AUTHTYPE_PASSPHRASE;
		break;
	case IPSP_AUTH_RSA:
		sadb_auth->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
		break;
	}
	*p += sizeof(struct sadb_x_cred);
	bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
	*p += PADUP((*ipr)->ref_len);
@


1.46
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.45 2014/12/28 10:02:37 tedu Exp $	*/
d469 1
a469 2
	switch (src->sa.sa_family)
	{
@


1.45
log
@remove KPDK. not really used, and a bad choice anyway. ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.44 2014/12/19 17:14:40 tedu Exp $	*/
d106 1
a106 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d111 4
@


1.44
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.43 2014/07/12 18:44:22 tedu Exp $	*/
a215 8
			break;

		case CRYPTO_MD5_KPDK:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_MD5;
			break;

		case CRYPTO_SHA1_KPDK:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA1;
@


1.43
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.42 2013/10/24 11:31:43 mpi Exp $	*/
a477 1
#ifdef INET
a499 1
#endif /* INET */
a617 1
#ifdef INET
a620 1
#endif /* INET */
a633 1
#ifdef INET
a636 1
#endif /* INET */
a674 1
#ifdef INET
a677 1
#endif /* INET */
@


1.42
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.41 2013/10/12 11:55:46 henning Exp $	*/
d746 1
a746 1
		free(*ipr, M_CREDENTIALS);
d784 1
a784 1
		free(*ipr, M_CREDENTIALS);
d828 1
a828 1
		free(*ipr, M_CREDENTIALS);
@


1.41
log
@give tagname2tag and its siblings an extra "create" parameter. if 1, it
behaves like before and creates the mapping if needed. if 0, lookup only.
looked over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.40 2013/06/05 02:03:15 reyk Exp $	*/
a110 3
#ifdef INET6
#include <netinet6/in6_var.h>
#endif
@


1.40
log
@Unbreak the kernel to userspace SADB_X_EXT_TAG message.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.39 2013/03/28 23:10:05 tedu Exp $	*/
d997 1
a997 1
		tdb->tdb_tag = pf_tagname2tag(s);
@


1.39
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.38 2013/03/09 16:51:30 deraadt Exp $	*/
d1008 2
a1012 1
	pf_tag2tagname(tdb->tdb_tag, s);
@


1.38
log
@re-arrange the pre-accounting of the objects in the buffer so it
is clearer; ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.37 2012/09/18 09:24:45 markus Exp $	*/
d102 1
@


1.37
log
@remove the SADB_X_SAFLAGS_{HALFIV,RANDOMPADDING,NOREPLAY} pfkey-API (not set
anywhere) as well as the matching TDBF_{HALFIV,RANDOMPADDING,NOREPLAY} code.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.36 2012/06/29 14:48:04 mikeb Exp $	*/
a1006 1
	pf_tag2tagname(tdb->tdb_tag, s);
d1010 2
a1011 1
	*p += PADUP(stag->sadb_x_tag_taglen) + sizeof(struct sadb_x_tag);
@


1.36
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.35 2011/04/13 11:28:47 markus Exp $	*/
a137 3
		if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_HALFIV)
			tdb->tdb_flags |= TDBF_HALFIV;

a140 6
		if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_RANDOMPADDING)
			tdb->tdb_flags |= TDBF_RANDOMPADDING;

		if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_NOREPLAY)
			tdb->tdb_flags |= TDBF_NOREPLAY;

a272 4
	/* Only relevant for the "old" IPsec transforms. */
	if (tdb->tdb_flags & TDBF_HALFIV)
		sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;

a274 6

	if (tdb->tdb_flags & TDBF_RANDOMPADDING)
		sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_RANDOMPADDING;

	if (tdb->tdb_flags & TDBF_NOREPLAY)
		sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;
@


1.35
log
@export udpencap state of SA to userland; unbreaks sasyncd(8) with NAT/T.
ok mikeb@@ fries@@ mpf@@ henning@@ dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.34 2010/10/06 22:19:20 mikeb Exp $	*/
d152 3
d297 3
@


1.34
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.33 2010/09/22 12:48:52 mikeb Exp $	*/
d291 3
@


1.33
log
@Add AES-GCM Transform Identifiers as specified by IANA in
RFC 4106 and 4543.

Please note that although IKEv1 and IKEv2 identifiers are
different for ESP_NULL_AUTH_AES-GMAC (SADB_X_EALG_AESGMAC),
we use the IKEv2 one only (which is 21).  ipsecctl(8) will
be taught to handle exported SA correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.32 2010/07/01 02:09:45 reyk Exp $	*/
a271 4
			break;

		case CRYPTO_SKIPJACK_CBC:
			sadb_sa->sadb_sa_encrypt = SADB_X_EALG_SKIPJACK;
@


1.32
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.30 2007/09/13 21:00:14 hshoexer Exp $	*/
d214 12
d256 8
@


1.31
log
@#if INET  => #ifdef INET
#if INET6 => #ifdef INET6
@
text
@d1007 19
@


1.30
log
@Convert MALLOC/FREE to malloc/free and use M_ZERO where applicable.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.29 2006/11/24 13:52:14 reyk Exp $	*/
d683 1
a683 1
#if INET6
@


1.29
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.28 2006/06/01 07:06:09 todd Exp $	*/
d730 2
a731 3
	MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_auth) -
	    sizeof(struct sadb_x_cred) + sizeof(struct ipsec_ref),
	    M_CREDENTIALS, M_WAITOK);
d742 1
a742 1
		FREE(*ipr, M_CREDENTIALS);
d768 2
a769 3
	MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_cred) -
	    sizeof(struct sadb_x_cred) + sizeof(struct ipsec_ref),
	    M_CREDENTIALS, M_WAITOK);
d780 1
a780 1
		FREE(*ipr, M_CREDENTIALS);
d806 2
a807 3
	MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_ident) -
	    sizeof(struct sadb_ident) + sizeof(struct ipsec_ref),
	    M_CREDENTIALS, M_WAITOK);
d824 1
a824 1
		FREE(*ipr, M_CREDENTIALS);
@


1.28
log
@observed by Naddy, found by claudio, strange constructs require strange defines
.. fixes proto display for the non zero case
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.27 2006/05/30 17:41:44 todd Exp $	*/
d94 2
d104 5
d983 28
@


1.27
log
@with Naddy prodding, claudio's peril sensitive glasses turning black, and
msf@@'s assistance with hexdumping, this bug was found.
do NOT access the wrong union member (sockaddr_in) when using v6 addresses
this fixes output errors when displaying v6 encap routes for ipsecctl, route,
and recently netstat
ok hshoexer@@ markus@@ claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.26 2005/05/27 17:59:22 ho Exp $	*/
d628 1
a628 1
	case AF_INET:
d633 1
a633 1
	case AF_INET6:
@


1.26
log
@Convert IPSP_IPSEC_x to SADB_X_FLOW_TYPE_x. hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.25 2005/05/27 15:27:27 hshoexer Exp $	*/
d626 12
a637 1
	sab->sadb_protocol_proto = flow->sen_proto;
@


1.25
log
@Add export_flow()

ok ho markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.24 2005/05/25 05:47:53 markus Exp $	*/
d583 25
a607 1
	sab->sadb_protocol_proto = ftype;
@


1.24
log
@AESCTR support for ESP (RFC 3686); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.23 2005/05/24 02:30:03 ho Exp $	*/
d522 94
@


1.23
log
@Better SA state reporting. markus@@, hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.22 2005/05/10 13:42:11 markus Exp $	*/
d233 4
@


1.22
log
@support NULL encryption for ESP; ok hshoexer, ho
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.21 2004/08/10 16:17:05 ho Exp $	*/
d166 2
@


1.21
log
@Add SADB_X_EXT_LIFETIME_LASTUSE for use with isakmpd/DPD, adding this
extends the bitmap to 64bits. Also repair SADB_GET. hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.20 2004/06/24 19:35:25 tholo Exp $	*/
d217 4
@


1.20
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.19 2004/06/21 20:44:54 itojun Exp $	*/
d401 7
@


1.19
log
@make it possble to use IPsec over link-local address (policy table uses
sin6_scope_id, IPsec porion uses embedded form).  beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.18 2003/12/02 23:16:29 markus Exp $	*/
a268 1
	int s;
d273 1
a273 3
	s = splhigh();
	tv = time;
	splx(s);
@


1.18
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.17 2003/07/24 09:59:02 itojun Exp $	*/
d101 1
d103 3
a443 4
	/* Generic netmask handling, works for IPv4 and IPv6. */
	rt_maskedcopy(&src->sa, &src->sa, &srcmask->sa);
	rt_maskedcopy(&dst->sa, &dst->sa, &dstmask->sa);

d455 4
d480 9
@


1.17
log
@conform to RFC2367 on SADB_xx naming (local name must be prefixed with
SADB_X_xx)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.16 2003/07/24 08:03:19 itojun Exp $	*/
d138 3
d799 20
@


1.16
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.15 2003/02/23 18:45:32 markus Exp $	*/
d183 1
a183 1
			sadb_sa->sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
d187 1
a187 1
			sadb_sa->sadb_sa_auth = SADB_AALG_SHA2_256;
d191 1
a191 1
			sadb_sa->sadb_sa_auth = SADB_AALG_SHA2_384;
d195 1
a195 1
			sadb_sa->sadb_sa_auth = SADB_AALG_SHA2_512;
@


1.15
log
@typo in export_auth; ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.14 2003/02/16 21:30:13 deraadt Exp $	*/
d184 12
@


1.14
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.13 2003/02/15 22:57:59 jason Exp $	*/
d701 2
a702 2
	case IPSP_CRED_KEYNOTE:
		sadb_auth->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
d704 2
a705 2
	case IPSP_CRED_X509:
		sadb_auth->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
@


1.13
log
@skeleton support for LZS compression
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.12 2002/06/09 23:15:42 angelos Exp $	*/
d498 1
a498 1
		switch(ssa->sa_family) {
@


1.12
log
@Export compression info only if the SA (xform) is initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.11 2002/06/07 23:18:29 angelos Exp $	*/
d165 3
@


1.11
log
@Detect wrap-around of timeout and set it to its maximum value. Hacky
way of getting the max value attributed to millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.10 2002/06/07 04:47:06 ho Exp $	*/
d160 3
a162 3
	if (tdb->tdb_sproto == IPPROTO_IPCOMP) {
		switch (tdb->tdb_compalgxform->type)
		{
@


1.10
log
@Add flow type arg to import_flow()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.9 2002/06/07 01:51:54 ho Exp $	*/
d273 5
a277 3
			tv.tv_sec += tdb->tdb_exp_timeout;
			timeout_add(&tdb->tdb_timer_tmo,
			    hzto(&tv));
d304 5
a308 3
			tv.tv_sec += tdb->tdb_soft_timeout;
			timeout_add(&tdb->tdb_stimer_tmo,
			    hzto(&tv));
@


1.9
log
@While src is rarely NULL, ssrc might be. Fixes PR#2721.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.8 2002/05/31 01:38:04 angelos Exp $	*/
d392 1
a392 1
    struct sadb_protocol *sab)
d434 1
a434 1
		flow->sen_direction = sab->sadb_protocol_direction;
d455 1
a455 1
		flow->sen_ip6_direction = sab->sadb_protocol_direction;
@


1.8
log
@Move code out of pfkeyv2.c into import_flow()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.7 2001/12/12 04:46:42 angelos Exp $	*/
d400 1
a400 1
	if (src == NULL)
@


1.7
log
@Remember to add the current time...problem noticed by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.6 2001/12/06 22:52:10 angelos Exp $	*/
d100 1
d382 91
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.7 2001/12/12 04:46:42 angelos Exp $	*/
a99 1
#include <net/route.h>
d272 3
a274 5
			if (tv.tv_sec + tdb->tdb_exp_timeout < tv.tv_sec)
				tv.tv_sec = ((unsigned long) -1) / 2; /* XXX */
			else
				tv.tv_sec += tdb->tdb_exp_timeout;
			timeout_add(&tdb->tdb_timer_tmo, hzto(&tv));
d301 3
a303 5
			if (tv.tv_sec + tdb->tdb_soft_timeout < tv.tv_sec)
				tv.tv_sec = ((unsigned long) -1) / 2; /* XXX */
			else
				tv.tv_sec += tdb->tdb_soft_timeout;
			timeout_add(&tdb->tdb_stimer_tmo, hzto(&tv));
a380 91
}

/*
 * Import flow information to two struct sockaddr_encap's. Either
 * all or none of the address arguments are NULL.
 */
void
import_flow(struct sockaddr_encap *flow, struct sockaddr_encap *flowmask,
    struct sadb_address *ssrc, struct sadb_address *ssrcmask,
    struct sadb_address *ddst, struct sadb_address *ddstmask,
    struct sadb_protocol *sab, struct sadb_protocol *ftype)
{
	u_int8_t transproto = 0;
	union sockaddr_union *src = (union sockaddr_union *)(ssrc + 1);
	union sockaddr_union *dst = (union sockaddr_union *)(ddst + 1);
	union sockaddr_union *srcmask = (union sockaddr_union *)(ssrcmask + 1);
	union sockaddr_union *dstmask = (union sockaddr_union *)(ddstmask + 1);

	if (ssrc == NULL)
		return; /* There wasn't any information to begin with. */

	bzero(flow, sizeof(*flow));
	bzero(flowmask, sizeof(*flowmask));

	if (sab != NULL)
		transproto = sab->sadb_protocol_proto;

	/*
	 * Check that all the address families match. We know they are
	 * valid and supported because pfkeyv2_parsemessage() checked that.
	 */
	if ((src->sa.sa_family != dst->sa.sa_family) ||
	    (src->sa.sa_family != srcmask->sa.sa_family) ||
	    (src->sa.sa_family != dstmask->sa.sa_family))
		return;

	/* Generic netmask handling, works for IPv4 and IPv6. */
	rt_maskedcopy(&src->sa, &src->sa, &srcmask->sa);
	rt_maskedcopy(&dst->sa, &dst->sa, &dstmask->sa);

	/*
	 * We set these as an indication that tdb_filter/tdb_filtermask are
	 * in fact initialized.
	 */
	flow->sen_family = flowmask->sen_family = PF_KEY;
	flow->sen_len = flowmask->sen_len = SENT_LEN;

	switch (src->sa.sa_family)
	{
#ifdef INET
	case AF_INET:
		flow->sen_type = SENT_IP4;
		flow->sen_direction = ftype->sadb_protocol_direction;
		flow->sen_ip_src = src->sin.sin_addr;
		flow->sen_ip_dst = dst->sin.sin_addr;
		flow->sen_proto = transproto;
		flow->sen_sport = src->sin.sin_port;
		flow->sen_dport = dst->sin.sin_port;

		flowmask->sen_type = SENT_IP4;
		flowmask->sen_direction = 0xff;
		flowmask->sen_ip_src = srcmask->sin.sin_addr;
		flowmask->sen_ip_dst = dstmask->sin.sin_addr;
		flowmask->sen_sport = srcmask->sin.sin_port;
		flowmask->sen_dport = dstmask->sin.sin_port;
		if (transproto)
			flowmask->sen_proto = 0xff;
		break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
		flow->sen_type = SENT_IP6;
		flow->sen_ip6_direction = ftype->sadb_protocol_direction;
		flow->sen_ip6_src = src->sin6.sin6_addr;
		flow->sen_ip6_dst = dst->sin6.sin6_addr;
		flow->sen_ip6_proto = transproto;
		flow->sen_ip6_sport = src->sin6.sin6_port;
		flow->sen_ip6_dport = dst->sin6.sin6_port;

		flowmask->sen_type = SENT_IP6;
		flowmask->sen_ip6_direction = 0xff;
		flowmask->sen_ip6_src = srcmask->sin6.sin6_addr;
		flowmask->sen_ip6_dst = dstmask->sin6.sin6_addr;
		flowmask->sen_ip6_sport = srcmask->sin6.sin6_port;
		flowmask->sen_ip6_dport = dstmask->sin6.sin6_port;
		if (transproto)
			flowmask->sen_ip6_proto = 0xff;
		break;
#endif /* INET6 */
	}
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.7.2.1 2002/06/11 03:30:46 art Exp $	*/
d160 3
a162 3
	if (tdb->tdb_sproto == IPPROTO_IPCOMP &&
	    tdb->tdb_compalgxform != NULL) {
		switch (tdb->tdb_compalgxform->type) {
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a165 3
		case CRYPTO_LZS_COMP:
			sadb_sa->sadb_sa_encrypt = SADB_X_CALG_LZS;
			break;
d495 1
a495 1
		switch (ssa->sa_family) {
d698 2
a699 2
	case IPSP_AUTH_PASSPHRASE:
		sadb_auth->sadb_x_cred_type = SADB_X_AUTHTYPE_PASSPHRASE;
d701 2
a702 2
	case IPSP_AUTH_RSA:
		sadb_auth->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
@


1.6
log
@Use hzto() to handle overflow of (hz * timeout) cases --- when using
extremely long SA expirations.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.5 2001/07/05 16:48:04 jjbg Exp $	*/
d246 1
d251 3
a253 2
	tv.tv_sec = 0;
	tv.tv_usec = 0;
d272 1
a272 1
			tv.tv_sec = tdb->tdb_exp_timeout;
d301 1
a301 1
			tv.tv_sec = tdb->tdb_soft_timeout;
@


1.5
log
@IPComp. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.4 2001/06/26 06:10:20 angelos Exp $	*/
d245 2
d250 3
d270 1
d272 1
a272 1
			    hz * tdb->tdb_exp_timeout);
d277 1
a277 1
		    sadb_lifetime->sadb_lifetime_usetime) != 0)	{
d279 1
a279 3
			timeout_add(&tdb->tdb_first_tmo,
			    hz * tdb->tdb_exp_first_use);
		} else
d299 1
d301 1
a301 1
			    hz * tdb->tdb_soft_timeout);
d306 1
a306 1
		    sadb_lifetime->sadb_lifetime_usetime) != 0)	{
a307 3
			timeout_add(&tdb->tdb_sfirst_tmo, hz *
			    tdb->tdb_soft_first_use);
		}
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.3 2001/06/25 05:14:00 angelos Exp $	*/
d118 1
d158 9
@


1.4.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.4 2001/06/26 06:10:20 angelos Exp $	*/
a117 1
		ii->ii_compalg = sadb_sa->sadb_sa_encrypt; /* Yeurk! */
a156 9

	if (tdb->tdb_sproto == IPPROTO_IPCOMP) {
		switch (tdb->tdb_compalgxform->type)
		{
		case CRYPTO_DEFLATE_COMP:
			sadb_sa->sadb_sa_encrypt = SADB_X_CALG_DEFLATE;
			break;
		}
	}
@


1.4.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a244 3
	struct timeval tv;
	int s;

a247 4
	s = splhigh();
	tv = time;
	splx(s);

a264 1
			tv.tv_sec += tdb->tdb_exp_timeout;
d266 1
a266 1
			    hzto(&tv));
d271 1
a271 1
		    sadb_lifetime->sadb_lifetime_usetime) != 0)
d273 3
a275 1
		else
a294 1
			tv.tv_sec += tdb->tdb_soft_timeout;
d296 1
a296 1
			    hzto(&tv));
d301 1
a301 1
		    sadb_lifetime->sadb_lifetime_usetime) != 0)
d303 3
@


1.4.2.3
log
@Sync the SMP branch with 3.3
@
text
@a99 1
#include <net/route.h>
d159 3
a161 3
	if (tdb->tdb_sproto == IPPROTO_IPCOMP &&
	    tdb->tdb_compalgxform != NULL) {
		switch (tdb->tdb_compalgxform->type) {
a164 3
		case CRYPTO_LZS_COMP:
			sadb_sa->sadb_sa_encrypt = SADB_X_CALG_LZS;
			break;
d272 3
a274 5
			if (tv.tv_sec + tdb->tdb_exp_timeout < tv.tv_sec)
				tv.tv_sec = ((unsigned long) -1) / 2; /* XXX */
			else
				tv.tv_sec += tdb->tdb_exp_timeout;
			timeout_add(&tdb->tdb_timer_tmo, hzto(&tv));
d301 3
a303 5
			if (tv.tv_sec + tdb->tdb_soft_timeout < tv.tv_sec)
				tv.tv_sec = ((unsigned long) -1) / 2; /* XXX */
			else
				tv.tv_sec += tdb->tdb_soft_timeout;
			timeout_add(&tdb->tdb_stimer_tmo, hzto(&tv));
a383 91
 * Import flow information to two struct sockaddr_encap's. Either
 * all or none of the address arguments are NULL.
 */
void
import_flow(struct sockaddr_encap *flow, struct sockaddr_encap *flowmask,
    struct sadb_address *ssrc, struct sadb_address *ssrcmask,
    struct sadb_address *ddst, struct sadb_address *ddstmask,
    struct sadb_protocol *sab, struct sadb_protocol *ftype)
{
	u_int8_t transproto = 0;
	union sockaddr_union *src = (union sockaddr_union *)(ssrc + 1);
	union sockaddr_union *dst = (union sockaddr_union *)(ddst + 1);
	union sockaddr_union *srcmask = (union sockaddr_union *)(ssrcmask + 1);
	union sockaddr_union *dstmask = (union sockaddr_union *)(ddstmask + 1);

	if (ssrc == NULL)
		return; /* There wasn't any information to begin with. */

	bzero(flow, sizeof(*flow));
	bzero(flowmask, sizeof(*flowmask));

	if (sab != NULL)
		transproto = sab->sadb_protocol_proto;

	/*
	 * Check that all the address families match. We know they are
	 * valid and supported because pfkeyv2_parsemessage() checked that.
	 */
	if ((src->sa.sa_family != dst->sa.sa_family) ||
	    (src->sa.sa_family != srcmask->sa.sa_family) ||
	    (src->sa.sa_family != dstmask->sa.sa_family))
		return;

	/* Generic netmask handling, works for IPv4 and IPv6. */
	rt_maskedcopy(&src->sa, &src->sa, &srcmask->sa);
	rt_maskedcopy(&dst->sa, &dst->sa, &dstmask->sa);

	/*
	 * We set these as an indication that tdb_filter/tdb_filtermask are
	 * in fact initialized.
	 */
	flow->sen_family = flowmask->sen_family = PF_KEY;
	flow->sen_len = flowmask->sen_len = SENT_LEN;

	switch (src->sa.sa_family)
	{
#ifdef INET
	case AF_INET:
		flow->sen_type = SENT_IP4;
		flow->sen_direction = ftype->sadb_protocol_direction;
		flow->sen_ip_src = src->sin.sin_addr;
		flow->sen_ip_dst = dst->sin.sin_addr;
		flow->sen_proto = transproto;
		flow->sen_sport = src->sin.sin_port;
		flow->sen_dport = dst->sin.sin_port;

		flowmask->sen_type = SENT_IP4;
		flowmask->sen_direction = 0xff;
		flowmask->sen_ip_src = srcmask->sin.sin_addr;
		flowmask->sen_ip_dst = dstmask->sin.sin_addr;
		flowmask->sen_sport = srcmask->sin.sin_port;
		flowmask->sen_dport = dstmask->sin.sin_port;
		if (transproto)
			flowmask->sen_proto = 0xff;
		break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
		flow->sen_type = SENT_IP6;
		flow->sen_ip6_direction = ftype->sadb_protocol_direction;
		flow->sen_ip6_src = src->sin6.sin6_addr;
		flow->sen_ip6_dst = dst->sin6.sin6_addr;
		flow->sen_ip6_proto = transproto;
		flow->sen_ip6_sport = src->sin6.sin6_port;
		flow->sen_ip6_dport = dst->sin6.sin6_port;

		flowmask->sen_type = SENT_IP6;
		flowmask->sen_ip6_direction = 0xff;
		flowmask->sen_ip6_src = srcmask->sin6.sin6_addr;
		flowmask->sen_ip6_dst = dstmask->sin6.sin6_addr;
		flowmask->sen_ip6_sport = srcmask->sin6.sin6_port;
		flowmask->sen_ip6_dport = dstmask->sin6.sin6_port;
		if (transproto)
			flowmask->sen_ip6_proto = 0xff;
		break;
#endif /* INET6 */
	}
}

/*
d399 1
a399 1
		switch (ssa->sa_family) {
d602 2
a603 2
	case IPSP_AUTH_PASSPHRASE:
		sadb_auth->sadb_x_cred_type = SADB_X_AUTHTYPE_PASSPHRASE;
d605 2
a606 2
	case IPSP_AUTH_RSA:
		sadb_auth->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
@


1.4.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a137 3

		if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_UDPENCAP)
			tdb->tdb_flags |= TDBF_UDPENCAP;
d183 1
a183 13
			sadb_sa->sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
			break;

		case CRYPTO_SHA2_256_HMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA2_256;
			break;

		case CRYPTO_SHA2_384_HMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA2_384;
			break;

		case CRYPTO_SHA2_512_HMAC:
			sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA2_512;
a783 20
}

/* Import/Export remote port for UDP Encapsulation */
void
import_udpencap(struct tdb *tdb, struct sadb_x_udpencap *sadb_udpencap)
{
	if (sadb_udpencap)
		tdb->tdb_udpencap_port = sadb_udpencap->sadb_x_udpencap_port;
}

void
export_udpencap(void **p, struct tdb *tdb)
{
	struct sadb_x_udpencap *sadb_udpencap = (struct sadb_x_udpencap *) *p;

	sadb_udpencap->sadb_x_udpencap_port = tdb->tdb_udpencap_port;
	sadb_udpencap->sadb_x_udpencap_reserved = 0;
	sadb_udpencap->sadb_x_udpencap_len =
	    sizeof(struct sadb_x_udpencap) / sizeof(uint64_t);
	*p += sizeof(struct sadb_x_udpencap);
@


1.3
log
@Copyright update.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkeyv2_convert.c,v 1.2 2001/06/23 18:30:37 deraadt Exp $	*/
d112 2
a113 2
    if (!sadb_sa)
      return;
d115 3
a117 4
    if (ii)
    {
	ii->ii_encalg = sadb_sa->sadb_sa_encrypt;
	ii->ii_authalg = sadb_sa->sadb_sa_auth;
d119 2
a120 2
	tdb->tdb_spi = sadb_sa->sadb_sa_spi;
	tdb->tdb_wnd = sadb_sa->sadb_sa_replay;
d122 2
a123 2
	if (sadb_sa->sadb_sa_flags & SADB_SAFLAGS_PFS)
	  tdb->tdb_flags |= TDBF_PFS;
d125 2
a126 2
	if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_HALFIV)
	  tdb->tdb_flags |= TDBF_HALFIV;
d128 2
a129 2
	if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_TUNNEL)
	  tdb->tdb_flags |= TDBF_TUNNELING;
d131 2
a132 2
	if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_RANDOMPADDING)
	  tdb->tdb_flags |= TDBF_RANDOMPADDING;
d134 3
a136 3
	if (sadb_sa->sadb_sa_flags & SADB_X_SAFLAGS_NOREPLAY)
	  tdb->tdb_flags |= TDBF_NOREPLAY;
    }
d138 2
a139 2
    if (sadb_sa->sadb_sa_state != SADB_SASTATE_MATURE)
      tdb->tdb_flags |= TDBF_INVALID;
d148 1
a148 9
    struct sadb_sa *sadb_sa = (struct sadb_sa *) *p;

    sadb_sa->sadb_sa_len = sizeof(struct sadb_sa) / sizeof(uint64_t);

    sadb_sa->sadb_sa_spi = tdb->tdb_spi;
    sadb_sa->sadb_sa_replay = tdb->tdb_wnd;

    if (tdb->tdb_flags & TDBF_INVALID)
      sadb_sa->sadb_sa_state = SADB_SASTATE_LARVAL;
d150 1
a150 11
    if (tdb->tdb_authalgxform)
    {
	switch (tdb->tdb_authalgxform->type)
	{
	    case CRYPTO_MD5_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_MD5HMAC;
		break;

	    case CRYPTO_SHA1_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_SHA1HMAC;
		break;
d152 2
a153 3
	    case CRYPTO_RIPEMD160_HMAC:
		sadb_sa->sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
		break;
d155 25
a179 7
	    case CRYPTO_MD5_KPDK:
		sadb_sa->sadb_sa_auth = SADB_X_AALG_MD5;
		break;

	    case CRYPTO_SHA1_KPDK:
		sadb_sa->sadb_sa_auth = SADB_X_AALG_SHA1;
		break;
a180 13
    }

    if (tdb->tdb_encalgxform)
    {
	switch (tdb->tdb_encalgxform->type)
	{
	    case CRYPTO_DES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_EALG_DESCBC;
		break;

	    case CRYPTO_3DES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_EALG_3DESCBC;
		break;
d182 26
a207 15
	    case CRYPTO_AES_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_AES;
		break;

	    case CRYPTO_CAST_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_CAST;
		break;

	    case CRYPTO_BLF_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_BLF;
		break;

	    case CRYPTO_SKIPJACK_CBC:
		sadb_sa->sadb_sa_encrypt = SADB_X_EALG_SKIPJACK;
		break;
a208 1
    }
d210 2
a211 2
    if (tdb->tdb_flags & TDBF_PFS)
      sadb_sa->sadb_sa_flags |= SADB_SAFLAGS_PFS;
d213 3
a215 3
    /* Only relevant for the "old" IPsec transforms */
    if (tdb->tdb_flags & TDBF_HALFIV)
      sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;
d217 2
a218 2
    if (tdb->tdb_flags & TDBF_TUNNELING)
      sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
d220 2
a221 2
    if (tdb->tdb_flags & TDBF_RANDOMPADDING)
      sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_RANDOMPADDING;
d223 2
a224 2
    if (tdb->tdb_flags & TDBF_NOREPLAY)
      sadb_sa->sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;
d226 1
a226 1
    *p += sizeof(struct sadb_sa);
d235 2
a236 2
    if (!sadb_lifetime)
      return;
d238 1
a238 2
    switch (type)
    {
d240 28
a267 28
	    if ((tdb->tdb_exp_allocations =
		 sadb_lifetime->sadb_lifetime_allocations) != 0)
	      tdb->tdb_flags |= TDBF_ALLOCATIONS;
	    else
	      tdb->tdb_flags &= ~TDBF_ALLOCATIONS;

	    if ((tdb->tdb_exp_bytes = sadb_lifetime->sadb_lifetime_bytes) != 0)
	      tdb->tdb_flags |= TDBF_BYTES;
	    else
	      tdb->tdb_flags &= ~TDBF_BYTES;

	    if ((tdb->tdb_exp_timeout =
		 sadb_lifetime->sadb_lifetime_addtime) != 0)
	    {
		tdb->tdb_flags |= TDBF_TIMER;
		timeout_add(&tdb->tdb_timer_tmo, hz * tdb->tdb_exp_timeout);
	    } else
	        tdb->tdb_flags &= ~TDBF_TIMER;

	    if ((tdb->tdb_exp_first_use =
		 sadb_lifetime->sadb_lifetime_usetime) != 0)
	    {
	        tdb->tdb_flags |= TDBF_FIRSTUSE;
	        timeout_add(&tdb->tdb_first_tmo, hz * tdb->tdb_exp_first_use);
	    }
	    else
	        tdb->tdb_flags &= ~TDBF_FIRSTUSE;
	    break;
d270 24
a293 26
	    if ((tdb->tdb_soft_allocations =
		 sadb_lifetime->sadb_lifetime_allocations) != 0)
	      tdb->tdb_flags |= TDBF_SOFT_ALLOCATIONS;
	    else
	      tdb->tdb_flags &= ~TDBF_SOFT_ALLOCATIONS;

	    if ((tdb->tdb_soft_bytes =
		 sadb_lifetime->sadb_lifetime_bytes) != 0)
	      tdb->tdb_flags |= TDBF_SOFT_BYTES;
	    else
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;

	    if ((tdb->tdb_soft_timeout =
		 sadb_lifetime->sadb_lifetime_addtime) != 0)
	    {
		tdb->tdb_flags |= TDBF_SOFT_TIMER;
		timeout_add(&tdb->tdb_stimer_tmo, hz * tdb->tdb_soft_timeout);
	    }
	    else
	      tdb->tdb_flags &= ~TDBF_SOFT_TIMER;

	    if ((tdb->tdb_soft_first_use =
		 sadb_lifetime->sadb_lifetime_usetime) != 0)
	    {
	        tdb->tdb_flags |= TDBF_SOFT_FIRSTUSE;
	        timeout_add(&tdb->tdb_sfirst_tmo, hz *
d295 12
a306 12
	    }
	    else
	        tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
	    break;

	case PFKEYV2_LIFETIME_CURRENT:  /* Nothing fancy here */
	    tdb->tdb_cur_allocations =
				      sadb_lifetime->sadb_lifetime_allocations;
	    tdb->tdb_cur_bytes = sadb_lifetime->sadb_lifetime_bytes;
	    tdb->tdb_established = sadb_lifetime->sadb_lifetime_addtime;
	    tdb->tdb_first_use = sadb_lifetime->sadb_lifetime_usetime;
    }
d315 1
a315 1
    struct sadb_lifetime *sadb_lifetime = (struct sadb_lifetime *) *p;
d317 2
a318 2
    sadb_lifetime->sadb_lifetime_len = sizeof(struct sadb_lifetime) /
				       sizeof(uint64_t);
d320 1
a320 2
    switch (type)
    {
d322 16
a337 13
	    if (tdb->tdb_flags & TDBF_ALLOCATIONS)
	      sadb_lifetime->sadb_lifetime_allocations =
						     tdb->tdb_exp_allocations;

	    if (tdb->tdb_flags & TDBF_BYTES)
	      sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_exp_bytes;

	    if (tdb->tdb_flags & TDBF_TIMER)
	      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_exp_timeout;

	    if (tdb->tdb_flags & TDBF_FIRSTUSE)
	      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_exp_first_use;
	    break;
d340 16
a355 13
	    if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS)
	      sadb_lifetime->sadb_lifetime_allocations =
						    tdb->tdb_soft_allocations;

	    if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	      sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_soft_bytes;

	    if (tdb->tdb_flags & TDBF_SOFT_TIMER)
	      sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_soft_timeout;

	    if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
	      sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_soft_first_use;
	    break;
d358 7
a364 7
	    sadb_lifetime->sadb_lifetime_allocations =
						      tdb->tdb_cur_allocations;
	    sadb_lifetime->sadb_lifetime_bytes = tdb->tdb_cur_bytes;
	    sadb_lifetime->sadb_lifetime_addtime = tdb->tdb_established;
	    sadb_lifetime->sadb_lifetime_usetime = tdb->tdb_first_use;
	    break;
    }
d366 1
a366 1
    *p += sizeof(struct sadb_lifetime);
d375 11
a385 12
    int salen;
    struct sockaddr *ssa = (struct sockaddr *)((void *) sadb_address +
					       sizeof(struct sadb_address));

    if (!sadb_address)
      return;

    if (ssa->sa_len)
      salen = ssa->sa_len;
    else
      switch(ssa->sa_family)
      {
d387 3
a389 3
	  case AF_INET:
	      salen = sizeof(struct sockaddr_in);
	      break;
d393 3
a395 3
	  case AF_INET6:
	      salen = sizeof(struct sockaddr_in6);
	      break;
d398 3
a400 3
	  default:
	      return;
    }
d402 2
a403 2
    bcopy(ssa, sa, salen);
    sa->sa_len = salen;
d412 1
a412 1
    struct sadb_address *sadb_address = (struct sadb_address *) *p;
d414 2
a415 2
    sadb_address->sadb_address_len = (sizeof(struct sadb_address) +
				      PADUP(SA_LEN(sa))) / sizeof(uint64_t);
d417 4
a420 4
    *p += sizeof(struct sadb_address);
    bcopy(sa, *p, SA_LEN(sa));
    ((struct sockaddr *) *p)->sa_family = sa->sa_family;
    *p += PADUP(SA_LEN(sa));
d429 1
a429 1
    struct ipsec_ref **ipr;
d431 2
a432 2
    if (!sadb_auth)
      return;
d434 11
a444 11
    if (dstauth == PFKEYV2_AUTH_REMOTE)
      ipr = &tdb->tdb_remote_auth;
    else
      ipr = &tdb->tdb_local_auth;

    MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_auth) -
	   sizeof(struct sadb_x_cred) + sizeof(struct ipsec_ref),
	   M_CREDENTIALS, M_WAITOK);
    (*ipr)->ref_len = EXTLEN(sadb_auth) - sizeof(struct sadb_x_cred);
    switch (sadb_auth->sadb_x_cred_type)
    {
d446 2
a447 2
	    (*ipr)->ref_type = IPSP_AUTH_PASSPHRASE;
	    break;
d449 2
a450 2
	    (*ipr)->ref_type = IPSP_AUTH_RSA;
	    break;
d452 8
a459 8
	    FREE(*ipr, M_CREDENTIALS);
	    *ipr = NULL;
	    return;
    }
    (*ipr)->ref_count = 1;
    (*ipr)->ref_malloctype = M_CREDENTIALS;
    bcopy((void *) sadb_auth + sizeof(struct sadb_x_cred),
	  (*ipr) + 1, (*ipr)->ref_len);
d468 1
a468 1
    struct ipsec_ref **ipr;
d470 2
a471 2
    if (!sadb_cred)
      return;
d473 11
a483 11
    if (dstcred == PFKEYV2_CRED_REMOTE)
      ipr = &tdb->tdb_remote_cred;
    else
      ipr = &tdb->tdb_local_cred;

    MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_cred) -
	   sizeof(struct sadb_x_cred) + sizeof(struct ipsec_ref),
	   M_CREDENTIALS, M_WAITOK);
    (*ipr)->ref_len = EXTLEN(sadb_cred) - sizeof(struct sadb_x_cred);
    switch (sadb_cred->sadb_x_cred_type)
    {
d485 2
a486 2
	    (*ipr)->ref_type = IPSP_CRED_X509;
	    break;
d488 2
a489 2
	    (*ipr)->ref_type = IPSP_CRED_KEYNOTE;
	    break;
d491 8
a498 8
	    FREE(*ipr, M_CREDENTIALS);
	    *ipr = NULL;
	    return;
    }
    (*ipr)->ref_count = 1;
    (*ipr)->ref_malloctype = M_CREDENTIALS;
    bcopy((void *) sadb_cred + sizeof(struct sadb_x_cred),
	  (*ipr) + 1, (*ipr)->ref_len);
d507 1
a507 1
    struct ipsec_ref **ipr;
d509 2
a510 2
    if (!sadb_ident)
      return;
d512 11
a522 11
    if (type == PFKEYV2_IDENTITY_SRC)
      ipr = &tdb->tdb_srcid;
    else
      ipr = &tdb->tdb_dstid;

    MALLOC(*ipr, struct ipsec_ref *, EXTLEN(sadb_ident) -
	   sizeof(struct sadb_ident) + sizeof(struct ipsec_ref), M_CREDENTIALS,
	   M_WAITOK);
    (*ipr)->ref_len = EXTLEN(sadb_ident) - sizeof(struct sadb_ident);
    switch (sadb_ident->sadb_ident_type)
    {
d524 2
a525 2
	    (*ipr)->ref_type = IPSP_IDENTITY_PREFIX;
	    break;
d527 2
a528 2
	    (*ipr)->ref_type = IPSP_IDENTITY_FQDN;
	    break;
d530 2
a531 2
	    (*ipr)->ref_type = IPSP_IDENTITY_USERFQDN;
	    break;
d533 2
a534 2
	    (*ipr)->ref_type = IPSP_IDENTITY_CONNECTION;
	    break;
d536 8
a543 8
	    FREE(*ipr, M_CREDENTIALS);
	    *ipr = NULL;
	    return;
    }
    (*ipr)->ref_count = 1;
    (*ipr)->ref_malloctype = M_CREDENTIALS;
    bcopy((void *) sadb_ident + sizeof(struct sadb_ident), (*ipr) + 1,
	  (*ipr)->ref_len);
d549 2
a550 2
    struct ipsec_ref **ipr;
    struct sadb_x_cred *sadb_cred = (struct sadb_x_cred *) *p;
d552 4
a555 4
    if (dstcred == PFKEYV2_CRED_REMOTE)
      ipr = &tdb->tdb_remote_cred;
    else
      ipr = &tdb->tdb_local_cred;
d557 2
a558 2
    sadb_cred->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
				  PADUP((*ipr)->ref_len)) / sizeof(uint64_t);
d560 1
a560 2
    switch ((*ipr)->ref_type)
    {
d562 2
a563 2
	    sadb_cred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
	    break;
d565 6
a570 6
	    sadb_cred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
	    break;
    }
    *p += sizeof(struct sadb_x_cred);
    bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
    *p += PADUP((*ipr)->ref_len);
d576 2
a577 2
    struct ipsec_ref **ipr;
    struct sadb_x_cred *sadb_auth = (struct sadb_x_cred *) *p;
d579 4
a582 4
    if (dstauth == PFKEYV2_AUTH_REMOTE)
      ipr = &tdb->tdb_remote_auth;
    else
      ipr = &tdb->tdb_local_auth;
d584 2
a585 2
    sadb_auth->sadb_x_cred_len = (sizeof(struct sadb_x_cred) +
				  PADUP((*ipr)->ref_len)) / sizeof(uint64_t);
d587 1
a587 2
    switch ((*ipr)->ref_type)
    {
d589 2
a590 2
	    sadb_auth->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
	    break;
d592 6
a597 6
	    sadb_auth->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
	    break;
    }
    *p += sizeof(struct sadb_x_cred);
    bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
    *p += PADUP((*ipr)->ref_len);
d603 10
a612 2
    struct ipsec_ref **ipr;
    struct sadb_ident *sadb_ident = (struct sadb_ident *) *p;
d614 1
a614 9
    if (type == PFKEYV2_IDENTITY_SRC)
      ipr = &tdb->tdb_srcid;
    else
      ipr = &tdb->tdb_dstid;

    sadb_ident->sadb_ident_len = (sizeof(struct sadb_ident) +
				  PADUP((*ipr)->ref_len)) / sizeof(uint64_t);
    switch ((*ipr)->ref_type)
    {
d616 2
a617 2
	    sadb_ident->sadb_ident_type = SADB_IDENTTYPE_PREFIX;
	    break;
d619 2
a620 2
	    sadb_ident->sadb_ident_type = SADB_IDENTTYPE_FQDN;
	    break;
d622 2
a623 2
	    sadb_ident->sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
	    break;
d625 6
a630 6
	    sadb_ident->sadb_ident_type = SADB_X_IDENTTYPE_CONNECTION;
	    break;
    }
    *p += sizeof(struct sadb_ident);
    bcopy((*ipr) + 1, *p, (*ipr)->ref_len);
    *p += PADUP((*ipr)->ref_len);
d637 2
a638 2
    if (!sadb_key)
      return;
d640 7
a646 10
    if (type == PFKEYV2_ENCRYPTION_KEY)
    { /* Encryption key */
	ii->ii_enckeylen = sadb_key->sadb_key_bits / 8;
	ii->ii_enckey = (void *)sadb_key + sizeof(struct sadb_key);
    }
    else
    {
	ii->ii_authkeylen = sadb_key->sadb_key_bits / 8;
	ii->ii_authkey = (void *)sadb_key + sizeof(struct sadb_key);
    }
d652 1
a652 1
    struct sadb_key *sadb_key = (struct sadb_key *) *p;
d654 17
a670 20
    if (type == PFKEYV2_ENCRYPTION_KEY)
    {
	sadb_key->sadb_key_len = (sizeof(struct sadb_key) +
				  PADUP(tdb->tdb_emxkeylen)) /
				 sizeof(uint64_t);
	sadb_key->sadb_key_bits = tdb->tdb_emxkeylen * 8;
	*p += sizeof(struct sadb_key);
	bcopy(tdb->tdb_emxkey, *p, tdb->tdb_emxkeylen);
	*p += PADUP(tdb->tdb_emxkeylen);
    }
    else
    {
	sadb_key->sadb_key_len = (sizeof(struct sadb_key) +
				  PADUP(tdb->tdb_amxkeylen)) /
				 sizeof(uint64_t);
	sadb_key->sadb_key_bits = tdb->tdb_amxkeylen * 8;
	*p += sizeof(struct sadb_key);
	bcopy(tdb->tdb_amxkey, *p, tdb->tdb_amxkeylen);
	*p += PADUP(tdb->tdb_amxkeylen);
    }
@


1.2
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 2
/*	$OpenBSD: pfkeyv2_convert.c,v 1.1 2001/06/08 02:53:49 angelos Exp $	*/

d10 1
a10 1
 * Permission to use, copy, and modify this software without fee
@


1.1
log
@Fork out some of the code in pfkeyv2.c to pfkeyv2_convert.c, to make
the former more managable/readable (an almost impossible task).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a103 1
#include <crypto/crypto.h>
@

