head	1.78;
access;
symbols
	OPENBSD_6_1_BASE:1.78
	OPENBSD_6_0:1.74.0.4
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.73.0.2
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.70.0.4
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.2
	OPENBSD_5_0:1.38.0.2
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.10
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.6
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.4
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.4.0.6
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	SMP:1.4.0.2;
locks; strict;
comment	@ * @;


1.78
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.77;
commitid	6c6qq5OdS4VVnyVM;

1.77
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.76;
commitid	F6oNrr9LCLUSAxgA;

1.76
date	2016.11.22.19.29.54;	author procter;	state Exp;
branches;
next	1.75;
commitid	Wwno1dT3ILCyVgb1;

1.75
date	2016.10.26.21.07.22;	author bluhm;	state Exp;
branches;
next	1.74;
commitid	aaKAr0kv3QWNHoVo;

1.74
date	2016.04.29.08.55.03;	author krw;	state Exp;
branches;
next	1.73;
commitid	OXPWeCN3XhMKFRzT;

1.73
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.72;
commitid	ILbVM1M3uPNjwswz;

1.72
date	2015.11.10.06.36.14;	author dlg;	state Exp;
branches;
next	1.71;
commitid	K5Jqf1WdzOhU2OVC;

1.71
date	2015.08.25.12.06.47;	author jsg;	state Exp;
branches;
next	1.70;
commitid	mxt8JnMERRG1Mvcj;

1.70
date	2015.07.15.22.16.41;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	ncpqEGjDtSFuLAgn;

1.69
date	2015.02.13.13.35.03;	author millert;	state Exp;
branches;
next	1.68;
commitid	AdfxL7vCLZYT5vxT;

1.68
date	2015.02.12.01.24.10;	author henning;	state Exp;
branches;
next	1.67;
commitid	9O1PirN7lXfubwO8;

1.67
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.66;
commitid	zhW8jJrfVCoAthrR;

1.66
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.65;
commitid	t9FBKDfc4VDxpEy2;

1.65
date	2014.12.02.18.11.56;	author tedu;	state Exp;
branches;
next	1.64;
commitid	R6VIBSqPh5FMhwGK;

1.64
date	2014.09.08.18.10.01;	author bluhm;	state Exp;
branches;
next	1.63;
commitid	tdFK7WByUuQ5GiDs;

1.63
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.62;
commitid	ZqXwxwmeo3l29NOg;

1.62
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.61;
commitid	DQakU8LLWV6Iwx84;

1.61
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.60;
commitid	B4dZSbxas1X1IpXI;

1.60
date	2014.07.09.11.03.04;	author henning;	state Exp;
branches;
next	1.59;
commitid	mfsvjrJC7UBF4ZGt;

1.59
date	2014.06.25.16.21.20;	author mikeb;	state Exp;
branches;
next	1.58;
commitid	jAxcy0jCm4KoeB0n;

1.58
date	2013.11.16.00.36.01;	author chl;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.56;

1.56
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.17.16.27.41;	author bluhm;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.26.09.12.39;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.26.13.19.25;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2012.11.06.12.32.41;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2012.11.01.07.55.55;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2012.07.08.07.58.09;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2012.02.03.01.57.50;	author bluhm;	state Exp;
branches;
next	1.48;

1.48
date	2012.01.27.15.30.16;	author bluhm;	state Exp;
branches;
next	1.47;

1.47
date	2012.01.15.22.55.35;	author bluhm;	state Exp;
branches;
next	1.46;

1.46
date	2011.12.21.14.46.24;	author mikeb;	state Exp;
branches;
next	1.45;

1.45
date	2011.10.21.15.45.55;	author mikeb;	state Exp;
branches;
next	1.44;

1.44
date	2011.10.13.18.23.39;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.28.17.15.45;	author bluhm;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.20.10.51.18;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.19.12.51.52;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.18.13.50.13;	author bluhm;	state Exp;
branches;
next	1.39;

1.39
date	2011.09.18.10.40.54;	author bluhm;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.07.00.47.18;	author mcbride;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.05.22.28.44;	author bluhm;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.20.19.03.41;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2011.05.22.13.21.24;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2010.12.07.11.39.40;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.21.22.49.14;	author sthen;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.21.11.29.12;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.21.10.45.26;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.21.04.06.37;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.12.02.47.07;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.18.21.58.18;	author mpf;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.16.16.00.27;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.26.17.13.30;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.19.09.40.13;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.15.09.31.20;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.01.23.39.34;	author mcbride;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.25.11.26.47;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2006.10.23.12.46.09;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.28.12.04.31;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.27.20.17.31;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.27.17.22.40;	author dhartmei;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.19.17.50.51;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.31.11.18.25;	author cedric;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.01.21.21.35;	author canacar;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.14.08.42.00;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.29.19.51.04;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.29.07.54.58;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.27.01.58.03;	author provos;	state Exp;
branches
	1.4.2.1
	1.4.6.1;
next	1.3;

1.3
date	2001.06.25.23.02.18;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.25.21.07.44;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.25.20.48.16;	author provos;	state Exp;
branches;
next	;

1.4.2.1
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2004.06.05.23.11.23;	author niklas;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.78
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: if_pflog.c,v 1.77 2017/01/23 11:37:29 mpi Exp $	*/
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece,
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
 * Copyright (c) 2001, Angelos D. Keromytis, Niels Provos.
 * Copyright (c) 2002 - 2010 Henning Brauer
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include "bpfilter.h"
#include "pflog.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/proc.h>
#include <sys/socket.h>
#include <sys/stdint.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#endif /* INET6 */

#include <net/pfvar.h>
#include <net/pfvar_priv.h>
#include <net/if_pflog.h>

#define PFLOGMTU	(32768 + MHLEN + MLEN)

#ifdef PFLOGDEBUG
#define DPRINTF(x)    do { if (pflogdebug) printf x ; } while (0)
#else
#define DPRINTF(x)
#endif

void	pflogattach(int);
int	pflogifs_resize(size_t);
int	pflogoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
		       struct rtentry *);
int	pflogioctl(struct ifnet *, u_long, caddr_t);
void	pflogstart(struct ifnet *);
int	pflog_clone_create(struct if_clone *, int);
int	pflog_clone_destroy(struct ifnet *);
void	pflog_bpfcopy(const void *, void *, size_t);

LIST_HEAD(, pflog_softc)	pflogif_list;
struct if_clone	pflog_cloner =
    IF_CLONE_INITIALIZER("pflog", pflog_clone_create, pflog_clone_destroy);

int		  npflogifs = 0;
struct ifnet	**pflogifs = NULL;	/* for fast access */
struct mbuf	 *pflog_mhdr = NULL, *pflog_mptr = NULL;

void
pflogattach(int npflog)
{
	LIST_INIT(&pflogif_list);
	if (pflog_mhdr == NULL)
		if ((pflog_mhdr = m_get(M_DONTWAIT, MT_HEADER)) == NULL)
			panic("pflogattach: no mbuf");
	if (pflog_mptr == NULL)
		if ((pflog_mptr = m_get(M_DONTWAIT, MT_DATA)) == NULL)
			panic("pflogattach: no mbuf");
	if_clone_attach(&pflog_cloner);
}

int
pflogifs_resize(size_t n)
{
	struct ifnet	**p;
	int		  i;

	if (n > SIZE_MAX / sizeof(*p))
		return (EINVAL);
	if (n == 0)
		p = NULL;
	else
		if ((p = mallocarray(n, sizeof(*p), M_DEVBUF,
		    M_NOWAIT|M_ZERO)) == NULL)
			return (ENOMEM);
	for (i = 0; i < n; i++)
		if (i < npflogifs)
			p[i] = pflogifs[i];
		else
			p[i] = NULL;

	if (pflogifs)
		free(pflogifs, M_DEVBUF, 0);
	pflogifs = p;
	npflogifs = n;
	return (0);
}

int
pflog_clone_create(struct if_clone *ifc, int unit)
{
	struct ifnet *ifp;
	struct pflog_softc *pflogif;
	int s;

	if ((pflogif = malloc(sizeof(*pflogif),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	pflogif->sc_unit = unit;
	ifp = &pflogif->sc_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "pflog%d", unit);
	ifp->if_softc = pflogif;
	ifp->if_mtu = PFLOGMTU;
	ifp->if_ioctl = pflogioctl;
	ifp->if_output = pflogoutput;
	ifp->if_start = pflogstart;
	ifp->if_xflags = IFXF_CLONED;
	ifp->if_type = IFT_PFLOG;
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	ifp->if_hdrlen = PFLOG_HDRLEN;
	if_attach(ifp);
	if_alloc_sadl(ifp);

#if NBPFILTER > 0
	bpfattach(&pflogif->sc_if.if_bpf, ifp, DLT_PFLOG, PFLOG_HDRLEN);
#endif

	s = splnet();
	LIST_INSERT_HEAD(&pflogif_list, pflogif, sc_list);
	if (unit + 1 > npflogifs && pflogifs_resize(unit + 1) != 0) {
		splx(s);
		return (ENOMEM);
	}
	pflogifs[unit] = ifp;
	splx(s);

	return (0);
}

int
pflog_clone_destroy(struct ifnet *ifp)
{
	struct pflog_softc	*pflogif = ifp->if_softc;
	int			 s, i;

	s = splnet();
	pflogifs[pflogif->sc_unit] = NULL;
	LIST_REMOVE(pflogif, sc_list);

	for (i = npflogifs; i > 0 && pflogifs[i - 1] == NULL; i--)
		; /* nothing */
	if (i < npflogifs)
		pflogifs_resize(i);	/* error harmless here */
	splx(s);

	if_detach(ifp);
	free(pflogif, M_DEVBUF, 0);
	return (0);
}

/*
 * Start output on the pflog interface.
 */
void
pflogstart(struct ifnet *ifp)
{
	IFQ_PURGE(&ifp->if_snd);
}

int
pflogoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
	struct rtentry *rt)
{
	m_freem(m);	/* drop packet */
	return (EAFNOSUPPORT);
}

int
pflogioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	switch (cmd) {
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP)
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
		break;
	default:
		return (ENOTTY);
	}

	return (0);
}

int
pflog_packet(struct pf_pdesc *pd, u_int8_t reason, struct pf_rule *rm,
    struct pf_rule *am, struct pf_ruleset *ruleset, struct pf_rule *trigger)
{
#if NBPFILTER > 0
	struct ifnet *ifn;
	struct pfloghdr hdr;

	if (rm == NULL || pd == NULL || pd->kif == NULL || pd->m == NULL)
		return (-1);
	if (trigger == NULL)
		trigger = rm;

	if (trigger->logif >= npflogifs || (ifn = pflogifs[trigger->logif]) ==
	    NULL || !ifn->if_bpf)
		return (0);

	bzero(&hdr, sizeof(hdr));
	hdr.length = PFLOG_REAL_HDRLEN;
	hdr.action = rm->action;
	hdr.reason = reason;
	memcpy(hdr.ifname, pd->kif->pfik_name, sizeof(hdr.ifname));

	if (am == NULL) {
		hdr.rulenr = htonl(rm->nr);
		hdr.subrulenr = -1;
	} else {
		hdr.rulenr = htonl(am->nr);
		hdr.subrulenr = htonl(rm->nr);
		if (ruleset != NULL && ruleset->anchor != NULL)
			strlcpy(hdr.ruleset, ruleset->anchor->name,
			    sizeof(hdr.ruleset));
	}
	if (trigger->log & PF_LOG_SOCKET_LOOKUP && !pd->lookup.done)
		pd->lookup.done = pf_socket_lookup(pd);
	if (pd->lookup.done > 0) {
		hdr.uid = pd->lookup.uid;
		hdr.pid = pd->lookup.pid;
	} else {
		hdr.uid = UID_MAX;
		hdr.pid = NO_PID;
	}
	hdr.rule_uid = rm->cuid;
	hdr.rule_pid = rm->cpid;
	hdr.dir = pd->dir;

	PF_ACPY(&hdr.saddr, &pd->nsaddr, pd->naf);
	PF_ACPY(&hdr.daddr, &pd->ndaddr, pd->naf);
	hdr.af = pd->af;
	hdr.naf = pd->naf;
	hdr.sport = pd->nsport;
	hdr.dport = pd->ndport;

	ifn->if_opackets++;
	ifn->if_obytes += pd->m->m_pkthdr.len;

	bpf_mtap_hdr(ifn->if_bpf, (caddr_t)&hdr, PFLOG_HDRLEN, pd->m,
	    BPF_DIRECTION_OUT, pflog_bpfcopy);
#endif

	return (0);
}

void
pflog_bpfcopy(const void *src_arg, void *dst_arg, size_t len)
{
	struct mbuf		*m, *mp, *mhdr, *mptr;
	struct pfloghdr		*pfloghdr;
	u_int			 count;
	u_char			*dst, *mdst;
	int			 afto, hlen, mlen, off;

	struct pf_pdesc		 pd;
	struct pf_addr		 osaddr, odaddr;
	u_int16_t		 osport = 0, odport = 0;
	u_int8_t		 proto = 0;

	m = (struct mbuf *)src_arg;
	dst = dst_arg;

	mhdr = pflog_mhdr;
	mptr = pflog_mptr;

	if (m == NULL)
		panic("pflog_bpfcopy got no mbuf");

	/* first mbuf holds struct pfloghdr */
	pfloghdr = mtod(m, struct pfloghdr *);
	afto = pfloghdr->af != pfloghdr->naf;
	count = min(m->m_len, len);
	bcopy(pfloghdr, dst, count);
	pfloghdr = (struct pfloghdr *)dst;
	dst += count;
	len -= count;
	m = m->m_next;

	if (len <= 0)
		return;

	/* second mbuf is pkthdr */
	if (m == NULL)
		panic("no second mbuf");

	/*
	 * temporary mbuf will hold an ip/ip6 header and 8 bytes
	 * of the protocol header
	 */
	m_inithdr(mhdr);
	mhdr->m_len = 0;	/* XXX not done in m_inithdr() */

#ifdef INET6
	/* offset for a new header */
	if (afto && pfloghdr->af == AF_INET)
		mhdr->m_data += sizeof(struct ip6_hdr) -
		    sizeof(struct ip);
#endif /* INET6 */

	mdst = mtod(mhdr, char *);
	switch (pfloghdr->af) {
	case AF_INET: {
		struct ip	*h;

		if (m->m_pkthdr.len < sizeof(*h))
			goto copy;
		m_copydata(m, 0, sizeof(*h), mdst);
		h = (struct ip *)mdst;
		hlen = h->ip_hl << 2;
		if (hlen > sizeof(*h) && (m->m_pkthdr.len >= hlen))
			m_copydata(m, sizeof(*h), hlen - sizeof(*h),
			    mdst + sizeof(*h));
		break;
	    }
#ifdef INET6
	case AF_INET6: {
		struct ip6_hdr	*h;

		if (m->m_pkthdr.len < sizeof(*h))
			goto copy;
		hlen = sizeof(struct ip6_hdr);
		m_copydata(m, 0, hlen, mdst);
		h = (struct ip6_hdr *)mdst;
		proto = h->ip6_nxt;
		break;
	    }
#endif /* INET6 */
	default:
		/* shouldn't happen ever :-) */
		goto copy;
	}

	if (m->m_pkthdr.len < hlen + 8 && proto != IPPROTO_NONE)
		goto copy;
	else if (proto != IPPROTO_NONE) {
		/* copy 8 bytes of the protocol header */
		m_copydata(m, hlen, 8, mdst + hlen);
		hlen += 8;
	}

	mhdr->m_len += hlen;
	mhdr->m_pkthdr.len = mhdr->m_len;

	/* create a chain mhdr -> mptr, mptr->m_data = (m->m_data+hlen) */
	mp = m_getptr(m, hlen, &off);
	if (mp != NULL) {
		bcopy(mp, mptr, sizeof(*mptr));
		mptr->m_data += off;
		mptr->m_len -= off;
		mptr->m_flags &= ~M_PKTHDR;
		mhdr->m_next = mptr;
		mhdr->m_pkthdr.len += m->m_pkthdr.len - hlen;
	}

	/*
	 * Rewrite addresses if needed. Reason pointer must be NULL to avoid
	 * counting the packet here again.
	 */
	if (pf_setup_pdesc(&pd, pfloghdr->af, pfloghdr->dir, NULL,
	    mhdr, NULL) != PF_PASS)
		goto copy;
	pd.naf = pfloghdr->naf;

	PF_ACPY(&osaddr, pd.src, pd.af);
	PF_ACPY(&odaddr, pd.dst, pd.af);
	if (pd.sport)
		osport = *pd.sport;
	if (pd.dport)
		odport = *pd.dport;

	if (pd.virtual_proto != PF_VPROTO_FRAGMENT &&
	    (pfloghdr->rewritten = pf_translate(&pd, &pfloghdr->saddr,
	    pfloghdr->sport, &pfloghdr->daddr, pfloghdr->dport, 0,
	    pfloghdr->dir))) {
		m_copyback(pd.m, pd.off, min(pd.m->m_len - pd.off, pd.hdrlen),
		    &pd.hdr, M_NOWAIT);
#ifdef INET6
		if (afto) {
			PF_ACPY(&pd.nsaddr, &pfloghdr->saddr, pd.naf);
			PF_ACPY(&pd.ndaddr, &pfloghdr->daddr, pd.naf);
		}
#endif /* INET6 */
		PF_ACPY(&pfloghdr->saddr, &osaddr, pd.af);
		PF_ACPY(&pfloghdr->daddr, &odaddr, pd.af);
		pfloghdr->sport = osport;
		pfloghdr->dport = odport;
	}

	pd.tot_len = min(pd.tot_len, len);
	pd.tot_len -= pd.m->m_data - pd.m->m_pktdat;

#ifdef INET6
	if (afto && pfloghdr->rewritten)
		pf_translate_af(&pd);
#endif /* INET6 */

	m = pd.m;
 copy:
	mlen = min(m->m_pkthdr.len, len);
	m_copydata(m, 0, mlen, dst);
	len -= mlen;
	if (len > 0)
		bzero(dst + mlen, len);
}
@


1.77
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.76 2016/11/22 19:29:54 procter Exp $	*/
d4 1
a4 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
d7 1
a7 1
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
d24 1
a24 1
 * modification of this software. 
d79 1
a79 1
	    	       struct rtentry *);
@


1.76
log
@Fold union pf_headers buffer into struct pf_pdesc (enabled by pfvar_priv.h).
Prevent pf_socket_lookup() reading uninitialised header buffers on fragments.
OK blum@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.75 2016/10/26 21:07:22 bluhm Exp $	*/
d153 1
@


1.75
log
@Put union pf_headers and struct pf_pdesc into separate header file
pfvar_priv.h.  The pf_headers had to be defined in multiple .c files
before.  In pfvar.h it would have unknown storage size, this file
is included in too many places.  The idea is to have a private pf
header that is only included in the pf part of the kernel.  For now
it contains pf_pdesc and pf_headers, it may be extended later.
discussion, input and OK henning@@ procter@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.74 2016/04/29 08:55:03 krw Exp $	*/
a300 1
	union pf_headers	 pdhdrs;
d406 1
a406 1
	if (pf_setup_pdesc(&pd, &pdhdrs, pfloghdr->af, pfloghdr->dir, NULL,
d423 1
a423 1
		    pd.hdr.any, M_NOWAIT);
@


1.74
log
@Make if_output() return EAFNOSUPPORT instead of just dropping packets
and pretending the output succeeded. Packets are still dropped!

Idea from jsg@@ following same change to bridge(4). ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.73 2015/12/05 10:07:55 tedu Exp $	*/
d55 1
a57 1
#include <netinet/ip_icmp.h>
d65 1
d301 1
a301 10
	union pf_headers {
		struct tcphdr		tcp;
		struct udphdr		udp;
		struct icmp		icmp;
#ifdef INET6
		struct icmp6_hdr	icmp6;
		struct mld_hdr		mld;
		struct nd_neighbor_solicit nd_ns;
#endif /* INET6 */
	} pdhdrs;
@


1.73
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.72 2015/11/10 06:36:14 dlg Exp $	*/
d208 2
a209 2
	m_freem(m);
	return (0);
@


1.72
log
@flush the send queue in start routines with IFQ_PURGE.

ok mpi@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.71 2015/08/25 12:06:47 jsg Exp $	*/
a211 1
/* ARGSUSED */
@


1.71
log
@#if INET && INET6 -> #ifdef INET6, the kernel no longer defines INET
since July.  The code involved deals with af-to handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.70 2015/07/15 22:16:41 deraadt Exp $	*/
d201 1
a201 13
	struct mbuf *m;
	int s;

	for (;;) {
		s = splnet();
		IF_DROP(&ifp->if_snd);
		IF_DEQUEUE(&ifp->if_snd, m);
		splx(s);

		if (m == NULL)
			return;
		m_freem(m);
	}
@


1.70
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.69 2015/02/13 13:35:03 millert Exp $	*/
d362 1
a362 1
#if INET && INET6
d367 1
a367 1
#endif /* INET && INET6 */
d446 1
a446 1
#if INET && INET6
d451 1
a451 1
#endif /* INET && INET6 */
d461 1
a461 1
#if INET && INET6
d464 1
a464 1
#endif /* INET && INET6 */
@


1.69
log
@Include sys/stdint.h for SIZE_MAX instead of relying on the misplaced
define in sys/limits.h.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.68 2015/02/12 01:24:10 henning Exp $	*/
d212 1
a212 2
		else
			m_freem(m);
@


1.68
log
@change log(matches) semantics slightly to make it more useful. since it
is a debug tool change of semantics not considered problematic.
up until now, log(matches) forced logging on subsequent matching rules,
the actual logging used the log settings from that matched rule.
now, log(matches) causes subsequent matches to be logged with the log settings
from the log(matches) rule. in particular (this was the driving point),
log(matches, to pflog23) allows you to have the trace log going to a seperate
pflog interface, not clobbering your regular pflogs, actually not affecting
them at all.
long conversation with bluhm about it, which didn't lead to a single bit
changed in the diff but was very very helpful. ok bluhm as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.66 2014/12/05 15:50:04 mpi Exp $	*/
d45 1
@


1.67
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d244 1
a244 1
    struct pf_rule *am, struct pf_ruleset *ruleset)
d252 2
d255 2
a256 2
	if (rm->logif >= npflogifs || (ifn = pflogifs[rm->logif]) == NULL ||
	    !ifn->if_bpf)
d275 1
a275 1
	if (rm->log & PF_LOG_SOCKET_LOOKUP && !pd->lookup.done)
@


1.66
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.65 2014/12/02 18:11:56 tedu Exp $	*/
a51 1
#ifdef	INET
a56 1
#endif
a58 3
#ifndef INET
#include <netinet/in.h>
#endif
@


1.65
log
@replace some malloc multiplies with mallocarry. ok deraadt henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.64 2014/09/08 18:10:01 bluhm Exp $	*/
d48 1
@


1.64
log
@When logging a packet to a listener on the pflog0 interface, the
function pflog_bpfcopy() is setting up a packet description with
pf_setup_pdesc().  When pf_setup_pdesc() is droppig a bad packet,
it increments the the pf status counters.  This way bad packets
could be accounted multiple times.  Now pflog_bpfcopy() passes a
reason pointer NULL to indicate that no accounting should be done.
From Florian Riehm; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.63 2014/09/08 06:24:13 jsg Exp $	*/
d120 1
a120 1
		if ((p = malloc(n * sizeof(*p), M_DEVBUF,
@


1.63
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.62 2014/07/22 11:06:09 mpi Exp $	*/
a313 1
	u_short			 reason;
d426 4
a429 1
	/* rewrite addresses if needed */
d431 1
a431 1
	    mhdr, &reason) != PF_PASS)
@


1.62
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.61 2014/07/12 18:44:22 tedu Exp $	*/
a48 1
#include <net/route.h>
@


1.61
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.60 2014/07/09 11:03:04 henning Exp $	*/
a53 1
#include <netinet/in_systm.h>
@


1.60
log
@tedu bpf_mtap_pflog().
now that it is a trivial wrapper around the extended bpf_mtap_hdr, we can
use bpf_mtap_hdr directly. added benefit: pflog_bpfcopy doesn't need to
be exported any more and can stay private to if_pflog.c
ok benno bluhm reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.58 2013/11/16 00:36:01 chl Exp $	*/
d132 1
a132 1
		free(pflogifs, M_DEVBUF);
d196 1
a196 1
	free(pflogif, M_DEVBUF);
@


1.59
log
@pf_translate doesn't use the mbuf argument anymore.

From Alexandr Nedvedicky <alexandr ! nedvedicky at oracle ! com>.  Thanks!
@
text
@d88 1
d302 2
a303 1
	bpf_mtap_pflog(ifn->if_bpf, (caddr_t)&hdr, pd->m);
@


1.58
log
@Remove dead assignments and now unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mikeb@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.57 2013/10/24 11:31:43 mpi Exp $	*/
d443 1
a443 1
	    pfloghdr->dir, pd.m))) {
@


1.57
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.56 2013/10/23 15:12:42 mpi Exp $	*/
d313 1
a313 1
	u_char			*dst, *mdst, *cp;
a419 1
		cp = mtod(mp, char *);
@


1.56
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.55 2013/10/17 16:27:41 bluhm Exp $	*/
a64 1
#include <netinet6/in6_var.h>
a65 1
#include <netinet6/nd6.h>
@


1.55
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.54 2013/06/26 09:12:39 henning Exp $	*/
a53 1
#include <netinet/in_var.h>
@


1.54
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.53 2013/03/26 13:19:25 mpi Exp $	*/
d66 1
@


1.53
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.52 2012/11/06 12:32:41 henning Exp $	*/
d446 1
a446 1
	    pfloghdr->dir))) {
@


1.52
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.51 2012/11/01 07:55:55 henning Exp $	*/
d159 1
a159 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.51
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.49 2012/02/03 01:57:50 bluhm Exp $	*/
d446 1
a446 1
	    pfloghdr->dir, pd.m))) {
@


1.50
log
@there was a limit on the number of pflog interfaces - 16. remove that.
mostly by dynamically allocating pflogifs instead of making that a static
array. ok claudio zinke
@
text
@d446 1
a446 1
	    pfloghdr->dir))) {
@


1.49
log
@The kernel did not compile without INET6.  Put some #ifdefs into
pf to fix that.
- add #ifdef INET6 in obvious places
- af translation is only possible with both INET and INET6
- interleave #endif /* INET6 */ and closing brace correctly
- it is not necessary to #ifdef function prototypes
- do not compile af translate functions at all instead of empty stub,
  then the linker will report inconsistencies
- pf_poolmask() actually takes an sa_family_t not an u_int8_t argument
No binary change for GENERIC compiled with -O2 and -UDIAGNOSTIC.
reported by Olivier Cochard-Labbe; ok mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.48 2012/01/27 15:30:16 bluhm Exp $	*/
d83 1
d95 3
a97 2
struct ifnet	*pflogifs[PFLOGIFS_MAX];	/* for fast access */
struct mbuf	*pflog_mhdr = NULL, *pflog_mptr = NULL;
a101 1
	int	i;
a102 2
	for (i = 0; i < PFLOGIFS_MAX; i++)
		pflogifs[i] = NULL;
d113 27
a145 3
	if (unit >= PFLOGIFS_MAX)
		return (EINVAL);

d170 4
d184 1
a184 1
	int			 s;
d189 5
d260 2
a261 1
	if ((ifn = pflogifs[rm->logif]) == NULL || !ifn->if_bpf)
@


1.48
log
@If some length checks in pflog_bpfcopy() failed, the function
returned early.  As a result tcpdump -i pflog0 printed uninitialized
kernel memory for short packets.  Fix this by copying the mbuf data
we have if we cannot decode the packet.
ok mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.47 2012/01/15 22:55:35 bluhm Exp $	*/
d334 1
d339 1
d356 1
d368 1
d416 1
d421 1
d431 1
d434 1
@


1.47
log
@Calling pf_normalize_ip() from pf_setup_pdesc() was bad as the
latter is called from pf packet logging.  This resulted in normalization
and reassembly of bad packets to be logged.  So rearrange the code
and move the call to pf_test().
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.46 2011/12/21 14:46:24 mikeb Exp $	*/
d345 1
a345 1
			return;
d358 1
a358 1
			return;
d367 1
a367 2
		m_copydata(m, 0, min(len, m->m_pkthdr.len), dst);
		return;
d371 1
a371 1
		return;
d396 1
a396 1
		return;
d428 4
a431 2
	mlen = min(pd.m->m_pkthdr.len, len);
	m_copydata(pd.m, 0, mlen, dst);
@


1.46
log
@don't attempt to run pf_translate on fragments: it will fail miserably.
also don't do af translation if pf_translate didn't succeed.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.45 2011/10/21 15:45:55 mikeb Exp $	*/
d283 1
a283 1
	u_short			 action, reason;
d396 1
a396 1
	    &mhdr, &action, &reason) == -1)
@


1.45
log
@strengthen some checks to prevent m_copy* routines from operating
on mbuf chains of insufficient length;  prevents crashes seen by
dhill.  also bring in some chunks omitted in the nat64 commit and
are essential for correct packet interpretation.

tested by dhill and me, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.44 2011/10/13 18:23:39 claudio Exp $	*/
d407 2
a408 1
	if ((pfloghdr->rewritten = pf_translate(&pd, &pfloghdr->saddr,
d426 1
a426 1
	if (afto)
@


1.44
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.43 2011/09/28 17:15:45 bluhm Exp $	*/
d299 1
d344 2
d349 1
a349 1
		if (hlen > sizeof(*h))
d355 4
d361 2
d367 1
a367 1
		m_copydata(m, 0, len, dst);
d371 7
a377 2
	/* copy 8 bytes of the protocol header */
	m_copydata(m, hlen, 8, mdst + hlen);
d379 1
a379 1
	mhdr->m_len += hlen + 8;
d382 2
a383 2
	/* create a chain mhdr -> mptr, mptr->m_data = (m->m_data+hlen+8) */
	mp = m_getptr(m, hlen + 8, &off);
d391 1
a391 1
		mhdr->m_pkthdr.len += m->m_pkthdr.len - (hlen + 8);
d422 3
d430 3
@


1.43
log
@As requested by henning, move the mbuf pointer into struct pf_pdesc.
Also sort pd to the beginning of the functions' parameter lists for
consistency.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.42 2011/09/20 10:51:18 bluhm Exp $	*/
d66 1
d95 1
a95 1
struct mbuf	*mfake = NULL;
d104 6
a109 2
	if (mfake == NULL)
		mfake = m_get(M_DONTWAIT, MT_HEADER);
a232 1
	hdr.af = pd->af;
d260 4
a263 2
	PF_ACPY(&hdr.saddr, &pd->nsaddr, pd->af);
	PF_ACPY(&hdr.daddr, &pd->ndaddr, pd->af);
d279 1
a279 1
	const struct mbuf	*m;
d282 1
a282 1
	u_char			*dst;
d284 1
d300 1
a300 1
	m = src_arg;
d303 3
d311 1
d319 3
d323 36
a358 10
	if (len > 0) {
		if (m == NULL)
			panic("no second mbuf");
		bcopy(m, mfake, sizeof(*mfake));
		mfake->m_flags &= ~(M_EXT|M_CLUSTER);
		mfake->m_next = NULL;
		mfake->m_nextpkt = NULL;
		mfake->m_data = dst;
		mfake->m_len = len;
	} else
d360 4
d365 13
a377 8
	while (len > 0) {
		if (m == 0)
			panic("bpf_mcopy");
		count = min(m->m_len, len);
		bcopy(mtod(m, caddr_t), (caddr_t)dst, count);
		m = m->m_next;
		dst += count;
		len -= count;
a379 3
	if (mfake->m_flags & M_PKTHDR)
		mfake->m_pkthdr.len = min(mfake->m_pkthdr.len, mfake->m_len);

d382 1
a382 1
	    &mfake, &action, &reason) == -1)
d384 1
d396 6
a401 2
		m_copyback(pd.m, pd.off, min(pd.m->m_len - pd.off,
		    pd.hdrlen), pd.hdr.any, M_NOWAIT);
d407 6
@


1.42
log
@Put kif and dir into pdesc an use this instead of passing the values
around.  This is a mechanical change.  Initialize pd2 and use it
where appropriate.
ok henning on an earlier version; ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.41 2011/09/19 12:51:52 bluhm Exp $	*/
d213 2
a214 2
pflog_packet(struct mbuf *m, u_int8_t reason, struct pf_rule *rm,
    struct pf_rule *am, struct pf_ruleset *ruleset, struct pf_pdesc *pd)
d220 1
a220 1
	if (m == NULL || rm == NULL || pd == NULL || pd->kif == NULL)
d262 1
a262 1
	ifn->if_obytes += m->m_pkthdr.len;
d264 1
a264 1
	bpf_mtap_pflog(ifn->if_bpf, (caddr_t)&hdr, m);
d335 1
a335 1
	if (pf_setup_pdesc(pfloghdr->af, pfloghdr->dir, NULL, &pd, &pdhdrs,
d349 1
a349 1
		m_copyback(mfake, pd.off, min(mfake->m_len - pd.off,
@


1.41
log
@Consolidate pf function parameters.  Move off and hdrlen into pdesc
and change their type from int to u_int32_t.  Do not pass struct
tcphdr *th and sa_family_t af, it is in pd anyway.  Do not use af
and pd->af intermixed, the latter makes clear where it comes from.
Do not calculate the packet length again if pd already has it.  Use
pd2.off instead of off2.
go go go go don't stop henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.40 2011/09/18 13:50:13 bluhm Exp $	*/
d213 2
a214 3
pflog_packet(struct pfi_kif *kif, struct mbuf *m, u_int8_t dir,
    u_int8_t reason, struct pf_rule *rm, struct pf_rule *am,
    struct pf_ruleset *ruleset, struct pf_pdesc *pd)
d220 1
a220 1
	if (kif == NULL || m == NULL || rm == NULL || pd == NULL)
d231 1
a231 1
	memcpy(hdr.ifname, kif->pfik_name, sizeof(hdr.ifname));
d244 1
a244 1
		pd->lookup.done = pf_socket_lookup(dir, pd);
d254 1
a254 1
	hdr.dir = dir;
d335 2
a336 2
	if (pf_setup_pdesc(pfloghdr->af, pfloghdr->dir, &pd, &pdhdrs, &mfake,
	    &action, &reason) == -1)
@


1.40
log
@Move the pdesc initialization code into pf_setup_pdesc().  Unify
some IPv4 and IPv6 code.  Make sure that both code paths set the
same fields in the same order.
ok mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.39 2011/09/18 10:40:54 bluhm Exp $	*/
a278 1
	int			 off = 0, hdrlen = 0;
d337 1
a337 1
	    &action, &reason, &off, &hdrlen) == -1)
d350 2
a351 2
		m_copyback(mfake, off, min(mfake->m_len - off, hdrlen),
		    pd.hdr.any, M_NOWAIT);
@


1.39
log
@Move the call to pf_test_rule() for fragments that have not been
reassembled by normalization from pf_setup_pdesc() to pf_test().
This simplifies the paramter list of pf_setup_pdesc() as it can
concentrate on its job filling the pf_pdesc struct.
ok henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.38 2011/07/07 00:47:18 mcbride Exp $	*/
d280 1
a280 1
	union {
d289 1
a289 1
	} pf_hdrs;
d337 2
a338 4
	memset(&pd, 0, sizeof(pd));
	pd.hdr.any = &pf_hdrs;
	if (pf_setup_pdesc(pfloghdr->af, pfloghdr->dir, &pd, &mfake, &action,
	    &reason, &off, &hdrlen) == -1)
@


1.38
log
@Fold pf_test_fragment() into pf_test_rule(), reduce code and fixes
a bunch of bugs with fragment handling not being in sync with the
rest of the ruleset.

Much feedback from mpf, bluhm & markus
Thanks to Tony Sarendal for help with testing

ok bluhm; various previous versions ok henning, claudio, mpf, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.37 2011/07/06 02:42:28 henning Exp $	*/
a275 1
	struct pf_state		*s = NULL;
d340 1
a340 1
	    &reason, NULL, NULL, NULL, &s, NULL, &off, &hdrlen) == -1)
@


1.37
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.36 2011/07/05 22:28:44 bluhm Exp $	*/
d276 1
d341 1
a341 1
	    &reason, NULL, NULL, NULL, NULL, &off, &hdrlen) == -1)
@


1.36
log
@Explicitly reserve space for special ICMP6 headers in pf_hdrs, like
it was done for pf_headers in pf.c.
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.35 2011/06/20 19:03:41 claudio Exp $	*/
d131 1
a131 1
	ifp->if_snd.ifq_maxlen = ifqmaxlen;
@


1.35
log
@More cleanup in pf_test/pf_test6 this time mostly the fragment
handling. More to come to make the two codepathes a bit more identical.
tested by many (esp. krw@@ and sthen@@) input and OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.34 2011/05/22 13:21:24 claudio Exp $	*/
d286 2
@


1.34
log
@Do not pass AF specific information to pf_test_rule() and PFLOG_PACKET()
because either the info is already available in struct pd or easy
to figure out.  Makes pf_test() and pf_test6() even more similar
(with the target to remove one of them in the near future).
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.33 2010/12/07 11:39:40 jsg Exp $	*/
d337 1
a337 1
	if (pf_setup_pdesc(pfloghdr->af, pfloghdr->dir, &pd, mfake, &action,
@


1.33
log
@remove a bunch of unused arguments
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.32 2010/09/21 22:49:14 sthen Exp $	*/
d213 1
a213 1
pflog_packet(struct pfi_kif *kif, struct mbuf *m, sa_family_t af, u_int8_t dir,
d229 1
a229 1
	hdr.af = af;
@


1.32
log
@Don't dereference null pointers for protocols without port numbers.
From henning@@, fixed pflog_bgpcopy crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.31 2010/09/21 11:29:12 henning Exp $	*/
d350 1
a350 1
	    pfloghdr->dir, mfake))) {
@


1.31
log
@assert copyrights / bump years
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.30 2010/09/21 10:45:26 henning Exp $	*/
d291 1
a291 1
	u_int16_t		 osport, odport;
d343 4
a346 2
	osport = *pd.sport;
	odport = *pd.dport;
@


1.30
log
@stuff the original (before rewriting) addresses into the already existant
address fields in the pflog header, same for ports, and add a "rewritten"
indicator. ok ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.29 2010/09/21 04:06:37 henning Exp $	*/
d19 1
@


1.29
log
@pflog overhaul
pflog was logging the "wrong" as in not yet rewritten (nat/rdr) addresses.
to address this without making an extra copy of the mbuf chain:
-introduce bpf_mtap_pflog, which is a 1:1 copy of bpf_mtap_hdr, except that
it supplies bpf_catchpacket with pflog_bpfcopy as copy function instead of
plain bcopy
-said new shiny pflog_bpfcopy knows what a pflog packet looks like, copies
everything into bpf's buffer, contructs a fake mbuf (which is allocated once
at attach time and reused over and over) which points to the bpf buffer
as data storage
-call pf_setup_pdesc on said fake mbuf
-then call pf_translate to rewrite the addresses as needed right in the
bpf buffer
this changes the pflog header as we have to pass the new addresses/ports
around. relies on canacar's awesome work in libpcap to work olrite with the
new, longer pflog header as well as with the old, shorter one.
almost completely written at c2k10 in canada, finished here at j2k10 in
japan. ok ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.28 2010/01/12 02:47:07 claudio Exp $	*/
d289 2
d302 1
d339 9
a347 2
	if (pf_translate(&pd, &pfloghdr->saddr, pfloghdr->sport,
	    &pfloghdr->daddr, pfloghdr->dport, 0, pfloghdr->dir, mfake))
d350 5
@


1.28
log
@Remove bpfdetach() call right in front of the if_detach() call since
bpfdetach() will be called in if_detach(). Diff by Gleydson Soares
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.27 2007/12/20 02:53:02 brad Exp $	*/
d56 3
d66 1
d93 1
d102 2
d256 4
a259 9
#ifdef INET
	if (af == AF_INET && dir == PF_OUT) {
		struct ip *ip;

		ip = mtod(m, struct ip *);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	}
#endif /* INET */
d263 2
a264 2
	bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, PFLOG_HDRLEN, m,
	    BPF_DIRECTION_OUT);
d268 72
@


1.27
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.26 2007/10/18 21:58:18 mpf Exp $	*/
a150 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.26
log
@There is no point for IP addresses on pflog(4)
OK dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.25 2007/09/16 16:00:27 pyr Exp $	*/
d201 1
a201 1
		return (EINVAL);
@


1.25
log
@another M_ZERO diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.24 2007/05/26 17:13:30 jason Exp $	*/
a193 3
	case SIOCSIFADDR:
	case SIOCAIFADDR:
	case SIOCSIFDSTADDR:
@


1.24
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.23 2007/03/19 09:40:13 henning Exp $	*/
d110 2
a111 1
	if ((pflogif = malloc(sizeof(*pflogif), M_DEVBUF, M_NOWAIT)) == NULL)
a112 1
	bzero(pflogif, sizeof(*pflogif));
@


1.23
log
@no longer create a pflog0 by default.
we had to put this workaround in since /etc/rc used to use the exit code
if "ifconfig pflog0" to decide wether we run on a kernel with pflog support.
rc has been fixed to explicitely create pflog0 when pf and pflogd are
enabled in November 2006, so now is the time to remove this compat hack.
pplz who haven't updated rc since 2006/11/16 lose pflogd. ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.22 2006/12/15 09:31:20 otto Exp $	*/
a88 2

extern int ifqmaxlen;
@


1.22
log
@make pflog(4) count; ok hennig@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.21 2006/11/01 23:39:34 mcbride Exp $	*/
a98 1
	(void) pflog_clone_create(&pflog_cloner, 0);
@


1.21
log
@Attach pfsync0 and pflog0 by default like they used to, /etc/rc depends on
them being there.

diff & ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.20 2006/10/25 11:26:47 henning Exp $	*/
d268 2
@


1.20
log
@add a "u_int8_t logif" to struct pfrule to select to which pflog interface
logs go. ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.19 2006/10/23 12:46:09 henning Exp $	*/
d99 1
@


1.19
log
@make the pflog interface clonable.
for now, only allow pflog0 to be created.
keep an array of ifps to the pflog interfaces with the unit # as index for
fast access.
if pflog0 does not exist, no logging is done (just like if it is down).
on machines without pf enabled, this makes the pflog0 interface go away,
on machines with pf, rc sets up pflog0 and starts pflogd, no change there.
idea old (pf2k4 or c2k5?), hacked at the hack.lu 2006 conference, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.18 2006/06/28 12:04:31 claudio Exp $	*/
d224 1
a224 1
	if ((ifn = pflogifs[0]) == NULL || !ifn->if_bpf)
@


1.18
log
@Another unused function bites the dust -- this time pflogrtrequest(). OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.17 2006/03/25 22:41:47 djm Exp $	*/
a75 2
struct pflog_softc pflogif[NPFLOG];

d81 8
d95 10
d106 23
a128 1
	int i;
d130 8
a137 1
	bzero(pflogif, sizeof(pflogif));
d139 13
a151 13
	for (i = 0; i < NPFLOG; i++) {
		ifp = &pflogif[i].sc_if;
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "pflog%d", i);
		ifp->if_softc = &pflogif[i];
		ifp->if_mtu = PFLOGMTU;
		ifp->if_ioctl = pflogioctl;
		ifp->if_output = pflogoutput;
		ifp->if_start = pflogstart;
		ifp->if_type = IFT_PFLOG;
		ifp->if_snd.ifq_maxlen = ifqmaxlen;
		ifp->if_hdrlen = PFLOG_HDRLEN;
		if_attach(ifp);
		if_alloc_sadl(ifp);
d154 1
a154 2
		bpfattach(&pflogif[i].sc_if.if_bpf, ifp, DLT_PFLOG,
			  PFLOG_HDRLEN);
d156 3
a158 1
	}
d224 1
a224 2
	ifn = &(pflogif[0].sc_if);
	if (!ifn->if_bpf)
@


1.17
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.16 2006/03/04 22:40:15 brad Exp $	*/
a81 1
void	pflogrtrequest(int, struct rtentry *, struct sockaddr *);
a142 8
}

/* ARGSUSED */
void
pflogrtrequest(int cmd, struct rtentry *rt, struct sockaddr *sa)
{
	if (rt)
		rt->rt_rmx.rmx_mtu = PFLOGMTU;
@


1.16
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.15 2005/07/31 03:52:18 pascoe Exp $	*/
d231 2
a232 1
	bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, PFLOG_HDRLEN, m);
@


1.15
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.14 2005/05/27 20:17:31 dhartmei Exp $	*/
d126 1
a126 1
		s = splimp();
@


1.14
log
@pass UID_MAX/NO_PID when the socket lookup failed, so tcpdump can
suppress output in this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.13 2005/05/27 17:22:40 dhartmei Exp $	*/
a182 1
	struct mbuf m1;
d187 4
d231 1
a231 8
	m1.m_next = m;
	m1.m_len = PFLOG_HDRLEN;
	m1.m_data = (char *) &hdr;

	ifn = &(pflogif[0].sc_if);

	if (ifn->if_bpf)
		bpf_mtap(ifn->if_bpf, &m1);
@


1.13
log
@log two pairs of uid/pid through pflog: the uid/pid of the process that
inserted the rule which causes the logging. secondly, the uid/pid of the
process in case the logged packet is delivered to/from a local socket.
a lookup of the local socket can be forced for logged packets with a new
option, 'log (user)'. make tcpdump print the additional information when
-e and -v is used. note: this changes the pflog header struct, rebuild all
dependancies. ok bob@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.12 2004/05/19 17:50:51 dhartmei Exp $	*/
d42 1
d207 7
a213 2
	hdr.uid = pd->lookup.uid;
	hdr.pid = pd->lookup.pid;
@


1.12
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.11 2003/12/31 11:18:25 cedric Exp $	*/
d177 1
a177 1
    struct pf_ruleset *ruleset)
d184 1
a184 1
	if (kif == NULL || m == NULL || rm == NULL)
d204 6
@


1.11
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.10 2003/10/01 21:21:35 canacar Exp $	*/
d200 2
a201 2
		if (ruleset != NULL)
			memcpy(hdr.ruleset, ruleset->name,
a202 2

			
@


1.10
log
@Fix stack leak into pfloghdr (the pad field is not initialized),
which ends up in the pflog pcap file. From dhartmei@@

ok dhartmei@@, frantzen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.9 2003/05/14 08:42:00 canacar Exp $	*/
d175 1
a175 1
pflog_packet(struct ifnet *ifp, struct mbuf *m, sa_family_t af, u_int8_t dir,
d184 1
a184 1
	if (ifp == NULL || m == NULL || rm == NULL)
d192 1
a192 1
	memcpy(hdr.ifname, ifp->if_xname, sizeof(hdr.ifname));
@


1.9
log
@Use official (from pcap people) link type for pflog.
With this change, the log header format also changes.
The new log format is extendible and allows logging
of the originating anchor and ruleset information.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.8 2003/05/03 21:15:11 deraadt Exp $	*/
d187 1
a196 1
		bzero(hdr.ruleset, sizeof(hdr.ruleset));
d200 1
a200 3
		if (ruleset == NULL)
			bzero(hdr.ruleset, sizeof(hdr.ruleset));
		else
@


1.8
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.7 2002/10/29 19:51:04 mickey Exp $	*/
d175 3
a177 2
pflog_packet(struct ifnet *ifp, struct mbuf *m, sa_family_t af, u_short dir,
    u_short reason, struct pf_rule *rm)
d187 4
a190 1
	hdr.af = htonl(af);
d193 16
a208 4
	hdr.rnr = htons(rm->nr);
	hdr.reason = htons(reason);
	hdr.dir = htons(dir);
	hdr.action = htons(rm->action);
@


1.7
log
@keep all pflog goodies in pflog sources, avoids code duplications; okski frantzen@@ and dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.6 2002/06/30 13:04:36 itojun Exp $	*/
d96 1
a96 1
		sprintf(ifp->if_xname, "pflog%d", i);
@


1.6
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.5 2002/05/29 07:54:58 itojun Exp $	*/
d36 3
a49 2
#include <net/if_pflog.h>

d53 2
d64 2
a65 2
#include "bpfilter.h"
#include "pflog.h"
d170 43
@


1.5
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.4 2001/06/27 01:58:03 provos Exp $	*/
d103 1
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.3 2001/06/25 23:02:18 provos Exp $	*/
a106 3
#endif
#ifdef INET6
		nd6_ifattach(ifp);
@


1.4.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 3
#include "bpfilter.h"
#include "pflog.h"

d47 2
a51 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
d61 2
a62 2
#include <net/pfvar.h>
#include <net/if_pflog.h>
a102 1
		if_alloc_sadl(ifp);
d108 3
a168 43

	return (0);
}

int
pflog_packet(struct ifnet *ifp, struct mbuf *m, sa_family_t af, u_short dir,
    u_short reason, struct pf_rule *rm)
{
#if NBPFILTER > 0
	struct ifnet *ifn;
	struct pfloghdr hdr;
	struct mbuf m1;

	if (ifp == NULL || m == NULL || rm == NULL)
		return (-1);

	hdr.af = htonl(af);
	memcpy(hdr.ifname, ifp->if_xname, sizeof(hdr.ifname));

	hdr.rnr = htons(rm->nr);
	hdr.reason = htons(reason);
	hdr.dir = htons(dir);
	hdr.action = htons(rm->action);

#ifdef INET
	if (af == AF_INET && dir == PF_OUT) {
		struct ip *ip;

		ip = mtod(m, struct ip *);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	}
#endif /* INET */

	m1.m_next = m;
	m1.m_len = PFLOG_HDRLEN;
	m1.m_data = (char *) &hdr;

	ifn = &(pflogif[0].sc_if);

	if (ifn->if_bpf)
		bpf_mtap(ifn->if_bpf, &m1);
#endif
@


1.4.2.2
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.4.2.1 2003/03/28 00:41:28 niklas Exp $	*/
d96 1
a96 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "pflog%d", i);
@


1.4.2.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d175 2
a176 3
pflog_packet(struct ifnet *ifp, struct mbuf *m, sa_family_t af, u_int8_t dir,
    u_int8_t reason, struct pf_rule *rm, struct pf_rule *am,
    struct pf_ruleset *ruleset)
d186 1
a186 4
	hdr.length = PFLOG_REAL_HDRLEN;
	hdr.af = af;
	hdr.action = rm->action;
	hdr.reason = reason;
d189 4
a192 16
	if (am == NULL) {
		hdr.rulenr = htonl(rm->nr);
		hdr.subrulenr = -1;
		bzero(hdr.ruleset, sizeof(hdr.ruleset));
	} else {
		hdr.rulenr = htonl(am->nr);
		hdr.subrulenr = htonl(rm->nr);
		if (ruleset == NULL)
			bzero(hdr.ruleset, sizeof(hdr.ruleset));
		else
			memcpy(hdr.ruleset, ruleset->name,
			    sizeof(hdr.ruleset));

			
	}
	hdr.dir = dir;
@


1.4.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d175 1
a175 1
pflog_packet(struct pfi_kif *kif, struct mbuf *m, sa_family_t af, u_int8_t dir,
d184 1
a184 1
	if (kif == NULL || m == NULL || rm == NULL)
a186 1
	bzero(&hdr, sizeof(hdr));
d191 1
a191 1
	memcpy(hdr.ifname, kif->pfik_name, sizeof(hdr.ifname));
d196 1
d200 3
a202 1
		if (ruleset != NULL)
@


1.4.2.5
log
@Merge with the trunk
@
text
@d200 2
a201 2
		if (ruleset != NULL && ruleset->anchor != NULL)
			strlcpy(hdr.ruleset, ruleset->anchor->name,
d203 2
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.4 2001/06/27 01:58:03 provos Exp $	*/
d107 3
@


1.4.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.4.6.1 2002/06/11 03:30:45 art Exp $	*/
a102 1
		if_alloc_sadl(ifp);
@


1.4.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 3
#include "bpfilter.h"
#include "pflog.h"

d47 2
a51 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
d61 2
a62 2
#include <net/pfvar.h>
#include <net/if_pflog.h>
d93 1
a93 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "pflog%d", i);
a166 59

	return (0);
}

int
pflog_packet(struct ifnet *ifp, struct mbuf *m, sa_family_t af, u_int8_t dir,
    u_int8_t reason, struct pf_rule *rm, struct pf_rule *am,
    struct pf_ruleset *ruleset)
{
#if NBPFILTER > 0
	struct ifnet *ifn;
	struct pfloghdr hdr;
	struct mbuf m1;

	if (ifp == NULL || m == NULL || rm == NULL)
		return (-1);

	hdr.length = PFLOG_REAL_HDRLEN;
	hdr.af = af;
	hdr.action = rm->action;
	hdr.reason = reason;
	memcpy(hdr.ifname, ifp->if_xname, sizeof(hdr.ifname));

	if (am == NULL) {
		hdr.rulenr = htonl(rm->nr);
		hdr.subrulenr = -1;
		bzero(hdr.ruleset, sizeof(hdr.ruleset));
	} else {
		hdr.rulenr = htonl(am->nr);
		hdr.subrulenr = htonl(rm->nr);
		if (ruleset == NULL)
			bzero(hdr.ruleset, sizeof(hdr.ruleset));
		else
			memcpy(hdr.ruleset, ruleset->name,
			    sizeof(hdr.ruleset));

			
	}
	hdr.dir = dir;

#ifdef INET
	if (af == AF_INET && dir == PF_OUT) {
		struct ip *ip;

		ip = mtod(m, struct ip *);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	}
#endif /* INET */

	m1.m_next = m;
	m1.m_len = PFLOG_HDRLEN;
	m1.m_data = (char *) &hdr;

	ifn = &(pflogif[0].sc_if);

	if (ifn->if_bpf)
		bpf_mtap(ifn->if_bpf, &m1);
#endif
@


1.3
log
@extend the logging via a new link header type.  export interface, direction,
action and rule nr.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.2 2001/06/25 21:07:44 art Exp $	*/
d141 1
a141 1
	return 0;
d167 1
a167 1
		return EINVAL;
@


1.2
log
@ANSIfy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pflog.c,v 1.1 2001/06/25 20:48:16 provos Exp $	*/
a71 4
#if NPFLOG != 2
#error "if_plog needs exactly two interfaces, fix sys/conf/GENERIC"
#endif

d99 1
a99 1
		ifp->if_type = IFT_LOOP;
d105 1
a105 1
		bpfattach(&pflogif[i].sc_if.if_bpf, ifp, DLT_LOOP,
@


1.1
log
@first stab at packet logging for pf.  inspired by late night dreams of art.
we just pass drop and passed packets to different pseudo interface that
can be listened to with bpf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.35 2001/06/25 05:14:00 angelos Exp $	*/
d18 1
a18 1
 * Copyright (c) 2001, Angelos D. Keromytis.
a35 4
/*
 * Encapsulation interface driver.
 */

a60 8
#ifdef ISO
extern struct ifqueue clnlintrq;
#endif

#ifdef NS
extern struct ifqueue nsintrq;
#endif

d78 6
a83 6
void	pflogattach __P((int));
int	pflogoutput __P((struct ifnet *, struct mbuf *, struct sockaddr *,
	    	       struct rtentry *));
int	pflogioctl __P((struct ifnet *, u_long, caddr_t));
void	pflogrtrequest __P((int, struct rtentry *, struct sockaddr *));
void	pflogstart __P((struct ifnet *));
d122 1
a122 2
pflogstart(ifp)
    struct ifnet *ifp;
d141 2
a142 5
pflogoutput(ifp, m, dst, rt)
    struct ifnet *ifp;
    register struct mbuf *m;
    struct sockaddr *dst;
    register struct rtentry *rt;
d150 1
a150 4
pflogrtrequest(cmd, rt, sa)
int cmd;
struct rtentry *rt;
struct sockaddr *sa;
d152 2
a153 2
    if (rt)
	    rt->rt_rmx.rmx_mtu = PFLOGMTU;
d158 1
a158 4
pflogioctl(ifp, cmd, data)
    register struct ifnet *ifp;
    u_long cmd;
    caddr_t data;
a169 1

@

