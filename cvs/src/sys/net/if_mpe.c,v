head	1.62;
access;
symbols
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.27.0.4
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9;
locks; strict;
comment	@ * @;


1.62
date	2017.08.14.16.14.02;	author reyk;	state Exp;
branches;
next	1.61;
commitid	jUP3WBiz4DzjBKsI;

1.61
date	2017.05.30.16.16.47;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	WNSqtNN7LaRHhCuc;

1.60
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.59;
commitid	p51F2KIwIJB1dU8P;

1.59
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.58;
commitid	Gef6NNDxonzfVaq2;

1.58
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.57;
commitid	6c6qq5OdS4VVnyVM;

1.57
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.56;
commitid	F6oNrr9LCLUSAxgA;

1.56
date	2016.12.20.12.18.44;	author mpi;	state Exp;
branches;
next	1.55;
commitid	NBiVrSI027L6H6zm;

1.55
date	2016.09.21.07.41.49;	author mpi;	state Exp;
branches;
next	1.54;
commitid	W19auu7eqXTbl8XK;

1.54
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.53;
commitid	Xo6g1xk26RWDGcjJ;

1.53
date	2016.01.14.09.20.31;	author mpi;	state Exp;
branches;
next	1.52;
commitid	mmanJIPww2fqlSXb;

1.52
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.51;
commitid	ILbVM1M3uPNjwswz;

1.51
date	2015.12.02.13.29.25;	author claudio;	state Exp;
branches;
next	1.50;
commitid	Hf3C2AvfIXmCAmHE;

1.50
date	2015.11.06.11.45.42;	author mpi;	state Exp;
branches;
next	1.49;
commitid	0J5ICG78xZT7kVOw;

1.49
date	2015.10.22.17.48.34;	author mpi;	state Exp;
branches;
next	1.48;
commitid	ToMJCJHoIWfUEPhu;

1.48
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.47;
commitid	tp9bS9eCrwvRYjyO;

1.47
date	2015.09.12.20.50.17;	author mpi;	state Exp;
branches;
next	1.46;
commitid	L7FukNYlBzoQuXvw;

1.46
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.45;
commitid	fE8TgA9vpwdUU5Wy;

1.45
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.44;
commitid	h7z8lokZ0dFyuWpg;

1.44
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.43;
commitid	1aiWjheMGhmTuiHL;

1.43
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.42;
commitid	c7ei8kPelCOOwHXy;

1.42
date	2015.03.26.11.02.44;	author mpi;	state Exp;
branches;
next	1.41;
commitid	0DQqDmKCmYNj6g7x;

1.41
date	2014.12.22.11.05.53;	author mpi;	state Exp;
branches;
next	1.40;
commitid	ZiNnf658AJiR4Tll;

1.40
date	2014.12.19.17.14.39;	author tedu;	state Exp;
branches;
next	1.39;
commitid	zhW8jJrfVCoAthrR;

1.39
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.38;
commitid	t9FBKDfc4VDxpEy2;

1.38
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.37;
commitid	w0MRp28dmfD1ZzO8;

1.37
date	2014.10.14.09.52.25;	author mpi;	state Exp;
branches;
next	1.36;
commitid	6AYfDT0Lpez1LFQp;

1.36
date	2014.10.07.08.59.50;	author mpi;	state Exp;
branches;
next	1.35;
commitid	eDbZTaMxNBU1b3dw;

1.35
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.34;
commitid	DQakU8LLWV6Iwx84;

1.34
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.33;
commitid	B4dZSbxas1X1IpXI;

1.33
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.17.16.27.41;	author bluhm;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.26.13.19.25;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2012.04.14.09.39.47;	author yasuoka;	state Exp;
branches;
next	1.26;

1.26
date	2011.08.20.06.21.32;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.28.14.58.24;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.21.17.42.57;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.21.06.13.06;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.25.13.57.07;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.31.11.46.02;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.28.12.09.09;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.09.20.29.42;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.26.12.34.41;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.13.12.41.46;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.28.22.18.44;	author michele;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.06.20.53.10;	author michele;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.01.16.37.55;	author michele;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.28.01.16.14;	author michele;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.18.12.30.40;	author michele;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.14.20.43.33;	author michele;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.08.09.52.36;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.08.03.41.29;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.08.03.18.39;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.08.01.55.49;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.07.08.37.25;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.07.08.00.50;	author pyr;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.07.07.16.49;	author pyr;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.07.06.53.42;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.06.13.33.50;	author pyr;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Remove unneeded null pointer check in mpe_input*: ifp cannot be NULL.

This was a bit confusing for the scanner and when reviewing the code.

Coverity CIDs 1453053 1453106; Severity: Insignificant

ok mpi@@
@
text
@/* $OpenBSD: if_mpe.c,v 1.61 2017/05/30 16:16:47 deraadt Exp $ */

/*
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@spootnik.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "mpe.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif /* INET6 */

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netmpls/mpls.h>

#ifdef MPLS_DEBUG
#define DPRINTF(x)    do { if (mpedebug) printf x ; } while (0)
#else
#define DPRINTF(x)
#endif

void	mpeattach(int);
int	mpeoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
		       struct rtentry *);
int	mpeioctl(struct ifnet *, u_long, caddr_t);
void	mpestart(struct ifnet *);
int	mpe_clone_create(struct if_clone *, int);
int	mpe_clone_destroy(struct ifnet *);

LIST_HEAD(, mpe_softc)	mpeif_list;
struct if_clone	mpe_cloner =
    IF_CLONE_INITIALIZER("mpe", mpe_clone_create, mpe_clone_destroy);

extern int	mpls_mapttl_ip;
#ifdef INET6
extern int	mpls_mapttl_ip6;
#endif

void
mpeattach(int nmpe)
{
	LIST_INIT(&mpeif_list);
	if_clone_attach(&mpe_cloner);
}

int
mpe_clone_create(struct if_clone *ifc, int unit)
{
	struct ifnet		*ifp;
	struct mpe_softc	*mpeif;

	if ((mpeif = malloc(sizeof(*mpeif),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOMEM);

	mpeif->sc_unit = unit;
	ifp = &mpeif->sc_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "mpe%d", unit);
	ifp->if_flags = IFF_POINTOPOINT;
	ifp->if_xflags = IFXF_CLONED;
	ifp->if_softc = mpeif;
	ifp->if_mtu = MPE_MTU;
	ifp->if_ioctl = mpeioctl;
	ifp->if_output = mpeoutput;
	ifp->if_start = mpestart;
	ifp->if_type = IFT_MPLS;
	ifp->if_hdrlen = MPE_HDRLEN;
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	if_attach(ifp);
	if_alloc_sadl(ifp);
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
#endif

	mpeif->sc_ifa.ifa_ifp = ifp;
	mpeif->sc_ifa.ifa_addr = sdltosa(ifp->if_sadl);
	mpeif->sc_smpls.smpls_len = sizeof(mpeif->sc_smpls);
	mpeif->sc_smpls.smpls_family = AF_MPLS;

	LIST_INSERT_HEAD(&mpeif_list, mpeif, sc_list);

	return (0);
}

int
mpe_clone_destroy(struct ifnet *ifp)
{
	struct mpe_softc	*mpeif = ifp->if_softc;

	LIST_REMOVE(mpeif, sc_list);

	if (mpeif->sc_smpls.smpls_label) {
		rt_ifa_del(&mpeif->sc_ifa, RTF_MPLS,
		    smplstosa(&mpeif->sc_smpls));
	}

	if_detach(ifp);
	free(mpeif, M_DEVBUF, sizeof *mpeif);
	return (0);
}

struct sockaddr_storage	 mpedst;
/*
 * Start output on the mpe interface.
 */
void
mpestart(struct ifnet *ifp0)
{
	struct mbuf		*m;
	struct sockaddr		*sa = sstosa(&mpedst);
	sa_family_t		 af;
	struct rtentry		*rt;
	struct ifnet		*ifp;

	for (;;) {
		IFQ_DEQUEUE(&ifp0->if_snd, m);
		if (m == NULL)
			return;

		af = *mtod(m, sa_family_t *);
		m_adj(m, sizeof(af));
		switch (af) {
		case AF_INET:
			bzero(sa, sizeof(struct sockaddr_in));
			satosin(sa)->sin_family = af;
			satosin(sa)->sin_len = sizeof(struct sockaddr_in);
			bcopy(mtod(m, caddr_t), &satosin(sa)->sin_addr,
			    sizeof(in_addr_t));
			m_adj(m, sizeof(in_addr_t));
			break;
		default:
			m_freem(m);
			continue;
		}

		rt = rtalloc(sa, RT_RESOLVE, 0);
		if (!rtisvalid(rt)) {
			m_freem(m);
			rtfree(rt);
			continue;
		}

		ifp = if_get(rt->rt_ifidx);
		if (ifp == NULL) {
			m_freem(m);
			rtfree(rt);
			continue;
		}

#if NBPFILTER > 0
		if (ifp0->if_bpf) {
			/* remove MPLS label before passing packet to bpf */
			m->m_data += sizeof(struct shim_hdr);
			m->m_len -= sizeof(struct shim_hdr);
			m->m_pkthdr.len -= sizeof(struct shim_hdr);
			bpf_mtap_af(ifp0->if_bpf, af, m, BPF_DIRECTION_OUT);
			m->m_data -= sizeof(struct shim_hdr);
			m->m_len += sizeof(struct shim_hdr);
			m->m_pkthdr.len += sizeof(struct shim_hdr);
		}
#endif
		/* XXX lie, but mpls_output will only look at sa_family */
		sa->sa_family = AF_MPLS;

		mpls_output(ifp, m, sa, rt);
		if_put(ifp);
		rtfree(rt);
	}
}

int
mpeoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
	struct rtentry *rt)
{
	struct shim_hdr	shim;
	int		error;
	int		off;
	u_int8_t	op = 0;

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.ph_rtableid));
	}
#endif
	m->m_pkthdr.ph_ifidx = ifp->if_index;
	/* XXX assumes MPLS is always in rdomain 0 */
	m->m_pkthdr.ph_rtableid = 0;

	error = 0;
	switch (dst->sa_family) {
	case AF_INET:
		if (rt && rt->rt_flags & RTF_MPLS) {
			shim.shim_label =
			    ((struct rt_mpls *)rt->rt_llinfo)->mpls_label;
			shim.shim_label |= MPLS_BOS_MASK;
			op =  ((struct rt_mpls *)rt->rt_llinfo)->mpls_operation;
		}
		if (op != MPLS_OP_PUSH) {
			m_freem(m);
			error = ENETUNREACH;
			goto out;
		}
		if (mpls_mapttl_ip) {
			struct ip	*ip;
			ip = mtod(m, struct ip *);
			shim.shim_label |= htonl(ip->ip_ttl) & MPLS_TTL_MASK;
		} else
			shim.shim_label |= htonl(mpls_defttl) & MPLS_TTL_MASK;
		off = sizeof(sa_family_t) + sizeof(in_addr_t);
		M_PREPEND(m, sizeof(shim) + off, M_DONTWAIT);
		if (m == NULL) {
			error = ENOBUFS;
			goto out;
		}
		*mtod(m, sa_family_t *) = AF_INET;
		m_copyback(m, sizeof(sa_family_t), sizeof(in_addr_t),
		    (caddr_t)&((satosin(dst)->sin_addr)), M_NOWAIT);
		break;
	default:
		m_freem(m);
		error = EPFNOSUPPORT;
		goto out;
	}

	m_copyback(m, off, sizeof(shim), (caddr_t)&shim, M_NOWAIT);

	error = if_enqueue(ifp, m);
out:
	if (error)
		ifp->if_oerrors++;
	return (error);
}

int
mpeioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct mpe_softc	*ifm;
	struct ifreq		*ifr;
	struct shim_hdr		 shim;
	int			 error = 0;

	ifr = (struct ifreq *)data;
	switch (cmd) {
	case SIOCSIFADDR:
		if (!ISSET(ifp->if_flags, IFF_UP))
			if_up(ifp);
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP)
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < MPE_MTU_MIN ||
		    ifr->ifr_mtu > MPE_MTU_MAX)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCGETLABEL:
		ifm = ifp->if_softc;
		shim.shim_label =
		    ((ntohl(ifm->sc_smpls.smpls_label & MPLS_LABEL_MASK)) >>
		    MPLS_LABEL_OFFSET);
		error = copyout(&shim, ifr->ifr_data, sizeof(shim));
		break;
	case SIOCSETLABEL:
		ifm = ifp->if_softc;
		if ((error = copyin(ifr->ifr_data, &shim, sizeof(shim))))
			break;
		if (shim.shim_label > MPLS_LABEL_MAX ||
		    shim.shim_label <= MPLS_LABEL_RESERVED_MAX) {
			error = EINVAL;
			break;
		}
		shim.shim_label = htonl(shim.shim_label << MPLS_LABEL_OFFSET);
		if (ifm->sc_smpls.smpls_label == shim.shim_label)
			break;
		LIST_FOREACH(ifm, &mpeif_list, sc_list) {
			if (ifm != ifp->if_softc &&
			    ifm->sc_smpls.smpls_label == shim.shim_label) {
				error = EEXIST;
				break;
			}
		}
		if (error)
			break;
		ifm = ifp->if_softc;
		if (ifm->sc_smpls.smpls_label) {
			/* remove old MPLS route */
			rt_ifa_del(&ifm->sc_ifa, RTF_MPLS,
			    smplstosa(&ifm->sc_smpls));
		}
		/* add new MPLS route */
		ifm->sc_smpls.smpls_label = shim.shim_label;
		error = rt_ifa_add(&ifm->sc_ifa, RTF_MPLS,
		    smplstosa(&ifm->sc_smpls));
		if (error) {
			ifm->sc_smpls.smpls_label = 0;
			break;
		}
		break;
	case SIOCSIFRDOMAIN:
		/* must readd the MPLS "route" for our label */
		ifm = ifp->if_softc;
		if (ifr->ifr_rdomainid != ifp->if_rdomain) {
			if (ifm->sc_smpls.smpls_label) {
				rt_ifa_add(&ifm->sc_ifa, RTF_MPLS,
				    smplstosa(&ifm->sc_smpls));
			}
		}
		/* return with ENOTTY so that the parent handler finishes */
		return (ENOTTY);
	default:
		return (ENOTTY);
	}

	return (error);
}

void
mpe_input(struct mbuf *m, struct ifnet *ifp, struct sockaddr_mpls *smpls,
    u_int8_t ttl)
{
	struct ip	*ip;
	int		 hlen;

	/* label -> AF lookup */

	if (mpls_mapttl_ip) {
		if (m->m_len < sizeof (struct ip) &&
		    (m = m_pullup(m, sizeof(struct ip))) == NULL)
			return;
		ip = mtod(m, struct ip *);
		hlen = ip->ip_hl << 2;
		if (m->m_len < hlen) {
			if ((m = m_pullup(m, hlen)) == NULL)
				return;
			ip = mtod(m, struct ip *);
		}

		if (in_cksum(m, hlen) != 0) {
			m_freem(m);
			return;
		}

		/* set IP ttl from MPLS ttl */
		ip->ip_ttl = ttl;

		/* recalculate checksum */
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, hlen);
	}

	/* new receive if and move into correct rtable */
	m->m_pkthdr.ph_ifidx = ifp->if_index;
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, AF_INET, m, BPF_DIRECTION_IN);
#endif

	ipv4_input(ifp, m);
}

#ifdef INET6
void
mpe_input6(struct mbuf *m, struct ifnet *ifp, struct sockaddr_mpls *smpls,
    u_int8_t ttl)
{
	struct ip6_hdr *ip6hdr;

	/* label -> AF lookup */

	if (mpls_mapttl_ip6) {
		if (m->m_len < sizeof (struct ip6_hdr) &&
		    (m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL)
			return;

		ip6hdr = mtod(m, struct ip6_hdr *);

		/* set IPv6 ttl from MPLS ttl */
		ip6hdr->ip6_hlim = ttl;
	}

	/* new receive if and move into correct rtable */
	m->m_pkthdr.ph_ifidx = ifp->if_index;
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, AF_INET6, m, BPF_DIRECTION_IN);
#endif

	ipv6_input(ifp, m);
}
#endif	/* INET6 */
@


1.61
log
@sizes for free()
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.60 2017/05/30 07:50:37 mpi Exp $ */
d395 1
a395 1
	if (ifp && ifp->if_bpf)
d427 1
a427 1
	if (ifp && ifp->if_bpf)
@


1.60
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.59 2017/05/04 15:00:24 bluhm Exp $ */
d130 1
a130 1
	free(mpeif, M_DEVBUF, 0);
@


1.59
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.58 2017/01/24 10:08:30 krw Exp $ */
d399 1
a399 1
	niq_enqueue(&ipintrq, m);
d431 1
a431 1
	niq_enqueue(&ip6intrq, m);
@


1.58
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.57 2017/01/23 11:37:29 mpi Exp $ */
d142 1
a142 1
	struct sockaddr		*sa = (struct sockaddr *)&mpedst;
@


1.57
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.56 2016/12/20 12:18:44 mpi Exp $ */
d56 1
a56 1
	    	       struct rtentry *);
d81 1
a81 1
	struct ifnet 		*ifp;
d141 1
a141 1
	struct mbuf 		*m;
d389 1
a389 1
	
@


1.56
log
@Kill recursive splsoftnet()/splx() dances in ioctl(2) path.

ok rzalamena@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.55 2016/09/21 07:41:49 mpi Exp $ */
d92 1
@


1.55
log
@Remove recursive splsoftnet() calls, from David Hill.
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.54 2016/04/13 11:41:15 mpi Exp $ */
d273 1
a273 1
	int			 s, error = 0;
a322 1
		s = splsoftnet();
a331 1
		splx(s);
a341 1
				s = splsoftnet();
a343 1
				splx(s);
@


1.54
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.53 2016/01/14 09:20:31 mpi Exp $ */
a119 1
	int			s;
a123 1
		s = splsoftnet();
a125 1
		splx(s);
@


1.53
log
@No need for a splnet() dance around IFQ_DEQUEUE() anymore.

From David Hill, ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.52 2015/12/05 10:07:55 tedu Exp $ */
a99 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.52
log
@remove old lint annotations
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.51 2015/12/02 13:29:25 claudio Exp $ */
a145 1
	int			 s;
a150 1
		s = splnet();
a151 2
		splx(s);

@


1.51
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.50 2015/11/06 11:45:42 mpi Exp $ */
a274 1
/* ARGSUSED */
@


1.50
log
@Do not use rt_ifp directly.

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.49 2015/10/22 17:48:34 mpi Exp $ */
d175 1
a175 1
		rt = rtalloc(sa, RT_REPORT|RT_RESOLVE, 0);
@


1.49
log
@Kill link_rtrequest(), introduce in 1990 to "fix" the result
of rt_getifa() when adding link level route from outside the
kernel.

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.48 2015/10/22 15:37:47 bluhm Exp $ */
d142 1
a142 1
mpestart(struct ifnet *ifp)
d149 1
d153 1
a153 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d176 1
a176 2
		if (rt == NULL) {
			/* no route give up */
d178 8
d190 1
a190 1
		if (ifp->if_bpf) {
d195 1
a195 1
			bpf_mtap_af(ifp->if_bpf, af, m, BPF_DIRECTION_OUT);
d204 2
a205 1
		mpls_output(rt->rt_ifp, m, sa, rt);
@


1.48
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.47 2015/09/12 20:50:17 mpi Exp $ */
a107 1
	mpeif->sc_ifa.ifa_rtrequest = link_rtrequest;
@


1.47
log
@Now that rtrequest1(9) properly sets RTF_UP for newly added route,
stop passing it in every rt_ifa_add(9) calls.

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.46 2015/06/30 13:54:42 mpi Exp $ */
d28 1
d109 1
a109 1
	mpeif->sc_ifa.ifa_addr = (struct sockaddr *) ifp->if_sadl;
@


1.46
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.45 2015/06/16 11:09:39 mpi Exp $ */
d127 1
a127 1
		rt_ifa_del(&mpeif->sc_ifa, RTF_MPLS | RTF_UP,
d326 1
a326 1
			rt_ifa_del(&ifm->sc_ifa, RTF_MPLS | RTF_UP,
d331 1
a331 1
		error = rt_ifa_add(&ifm->sc_ifa, RTF_MPLS | RTF_UP,
d345 1
a345 1
				rt_ifa_add(&ifm->sc_ifa, RTF_MPLS | RTF_UP,
@


1.45
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.44 2015/05/15 10:15:13 mpi Exp $ */
d259 1
a259 1
	error = if_output(ifp, m);
@


1.44
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.43 2015/04/10 13:58:20 dlg Exp $ */
d217 1
a217 1
	m->m_pkthdr.rcvif = ifp;
d394 1
a394 1
	m->m_pkthdr.rcvif = ifp;
d426 1
a426 1
	m->m_pkthdr.rcvif = ifp;
@


1.43
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.42 2015/03/26 11:02:44 mpi Exp $ */
a205 1
	int		s;
d259 1
a259 10
	s = splnet();
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		/* mbuf is already freed */
		splx(s);
		goto out;
	}
	if_start(ifp);
	splx(s);

@


1.42
log
@Use rt_ifa_add(9) and rt_ifa_del(9) to configure MPLS labels.

Since the removal of the link-layer ifa from "struct ifnet" it was
impossible to configure MPLS routes on mpe(4).  Because just like
enc(4), mpe(4) was abusing the link-layer ifa to attach its route
entries.

So explicitly pass a "glue" ifa to the routing layer.

From Rafael Zalamena who discovered this the hardway, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.41 2014/12/22 11:05:53 mpi Exp $ */
d374 1
a374 1
	int		 s, hlen;
d411 2
a412 4
	s = splnet();
	IF_INPUT_ENQUEUE(&ipintrq, m);
	schednetisr(NETISR_IP);
	splx(s);
a420 1
	int s;
d443 2
a444 4
	s = splnet();
	IF_INPUT_ENQUEUE(&ip6intrq, m);
	schednetisr(NETISR_IPV6);
	splx(s);
@


1.41
log
@Make sure rtrequest1(9) is called under splsoftnet().
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.40 2014/12/19 17:14:39 tedu Exp $ */
a59 1
int	mpe_newlabel(struct ifnet *, int, struct shim_hdr *);
a86 1
	mpeif->sc_shim.shim_label = 0;
d106 6
d121 1
d125 7
d307 1
a307 1
		    ((ntohl(ifm->sc_shim.shim_label & MPLS_LABEL_MASK)) >>
d321 1
a321 1
		if (ifm->sc_shim.shim_label == shim.shim_label)
d325 1
a325 1
			    ifm->sc_shim.shim_label == shim.shim_label) {
d334 1
a334 1
		if (ifm->sc_shim.shim_label) {
d336 2
a337 1
			mpe_newlabel(ifp, RTM_DELETE, &ifm->sc_shim);
d340 3
a342 1
		error = mpe_newlabel(ifp, RTM_ADD, &shim);
d344 2
a345 1
		if (error)
d347 1
a347 1
		ifm->sc_shim.shim_label = shim.shim_label;
d353 1
a353 2
			if (ifm->sc_shim.shim_label) {
				shim.shim_label = ifm->sc_shim.shim_label;
d355 2
a356 1
				error = mpe_newlabel(ifp, RTM_ADD, &shim);
a451 35

int
mpe_newlabel(struct ifnet *ifp, int cmd, struct shim_hdr *shim)
{
	struct rtentry *nrt;
	struct sockaddr_mpls dst;
	struct rt_addrinfo info;
	int error;

	bzero(&dst, sizeof(dst));
	dst.smpls_len = sizeof(dst);
	dst.smpls_family = AF_MPLS;
	dst.smpls_label = shim->shim_label;

	bzero(&info, sizeof(info));
	info.rti_flags = RTF_UP | RTF_MPLS;
	info.rti_mpls = MPLS_OP_POP;
	info.rti_info[RTAX_DST] = smplstosa(&dst);
	info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)ifp->if_sadl;

	error = rtrequest1(cmd, &info, RTP_CONNECTED, &nrt, 0);
	rt_missmsg(cmd, &info, error ? 0 : nrt->rt_flags, ifp, error, 0);
	if (cmd == RTM_DELETE) {
		if (error == 0 && nrt != NULL) {
			if (nrt->rt_refcnt <= 0) {
				nrt->rt_refcnt++;
				rtfree(nrt);
			}
		}
	}
	if (cmd == RTM_ADD && error == 0 && nrt != NULL) {
		nrt->rt_refcnt--;
	}
	return (error);
}
@


1.40
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.39 2014/12/05 15:50:04 mpi Exp $ */
a267 1
	int			 error;
d271 1
a273 1
	error = 0;
d321 1
d328 1
d339 1
d341 1
@


1.39
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.38 2014/11/01 21:40:38 mpi Exp $ */
a32 1
#ifdef	INET
a34 1
#endif
a37 3
#ifndef INET
#include <netinet/in.h>
#endif
a211 1
#ifdef INET
a239 1
#endif
@


1.38
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.37 2014/10/14 09:52:25 mpi Exp $ */
d28 1
@


1.37
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.36 2014/10/07 08:59:50 mpi Exp $ */
d166 1
a166 1
		rt = rtalloc1(sa, RT_REPORT, 0);
@


1.36
log
@Since the list of mpe(4) interfaces is only accessed in process context,
it does not need to be protected by splnet().

Rafael Zalamena agrees, no objection from the MPLS gang.
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.35 2014/07/22 11:06:09 mpi Exp $ */
d189 1
a189 1
		RTFREE(rt);
@


1.35
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.34 2014/07/12 18:44:22 tedu Exp $ */
a86 1
	int 			 s;
a111 1
	s = splnet();
a112 1
	splx(s);
a120 1
	int			 s;
a121 1
	s = splnet();
a122 1
	splx(s);
@


1.34
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.33 2014/04/14 09:06:42 mpi Exp $ */
a33 1
#include <netinet/in_systm.h>
@


1.33
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.32 2013/10/24 11:31:43 mpi Exp $ */
d132 1
a132 1
	free(mpeif, M_DEVBUF);
@


1.32
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.31 2013/10/23 15:12:42 mpi Exp $ */
d211 1
a211 1
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
d214 1
a214 1
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain));
d219 1
a219 1
	m->m_pkthdr.rdomain = 0;
d397 1
a397 1
	/* new receive if and move into correct rdomain */
d399 1
a399 1
	m->m_pkthdr.rdomain = ifp->if_rdomain;
d432 1
a432 1
	/* new receive if and move into correct rdomain */
d434 1
a434 1
	m->m_pkthdr.rdomain = ifp->if_rdomain;
@


1.31
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.30 2013/10/17 16:27:41 bluhm Exp $ */
a38 1
#include <netinet6/in6_var.h>
@


1.30
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.29 2013/03/28 16:45:16 tedu Exp $ */
a33 1
#include <netinet/in_var.h>
@


1.29
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.28 2013/03/26 13:19:25 mpi Exp $ */
d40 1
@


1.28
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.27 2012/04/14 09:39:47 yasuoka Exp $ */
a22 1
#include <sys/proc.h>
@


1.27
log
@Use DLT_LOOP for all tunneling interfaces.
Byte order adjustment for bpf was hidden behind bpf_mtap_af() and
sizeof(u_int32_t) is used for length of the bpf header.

tested by sebastia and mxb at alumni.chalmers.se.
ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.26 2011/08/20 06:21:32 mcbride Exp $ */
d108 1
a108 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.26
log
@Fix packet accounting in error cases.

From Christiano F. Haesbaert.
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.25 2011/01/28 14:58:24 reyk Exp $ */
d113 1
a113 1
	bpfattach(&ifp->if_bpf, ifp, DLT_NULL, sizeof(u_int32_t));
@


1.25
log
@Replace another m_free() with m_freem() to plug an mbuf leak in mpe_input().

ok gollo@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.24 2011/01/21 17:42:57 mikeb Exp $ */
d268 1
a268 1
		return (error);
@


1.24
log
@make mpls compile w/o errors when inet6 is not defined

diff from form@@ who's too busy drinking vodka with pelmeni to commit this;
ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.23 2010/09/21 06:13:06 claudio Exp $ */
d387 1
a387 1
			m_free(m);
@


1.23
log
@No need to m_freem() a NULL pointer and change the error for unknown
protocols to EPFNOSUPPORT.
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.22 2010/08/25 13:57:07 claudio Exp $ */
d74 1
d76 1
d413 1
d447 1
@


1.22
log
@Move the iface specific ioctl call for SIOCSIFRDOMAIN further down so that
all the magic cleanup happens before. This is needed because mpe(4) needs
to add a route which would be removed by the cleanup code.
OK henning
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.21 2010/07/02 02:40:16 blambert Exp $ */
a244 1
			m_freem(m);
d255 1
a255 1
		error = ENETDOWN;
@


1.21
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.20 2010/05/31 11:46:02 claudio Exp $ */
d346 11
@


1.20
log
@Do not use IF_ENQUEUE() but IF_INPUT_ENQUEUE() instead. The first makro
does no overflow checking and does not set the congestion flag. Protocol
input queues (inet, inet6, ...) should always use IF_INPUT_ENQUEUE().
OK henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.19 2010/05/28 12:09:09 claudio Exp $ */
d251 1
a251 1
		    (caddr_t)&((satosin(dst)->sin_addr)));
d260 1
a260 1
	m_copyback(m, off, sizeof(shim), (caddr_t)&shim);
@


1.19
log
@Rework the way we handle MPLS in the kernel. Instead of fumbling MPLS into
ether_output() and later on other L2 output functions use a trick and over-
load the ifp->if_output() function pointer on MPLS enabled interfaces to
go through mpls_output() which will then call the link level output function.
By setting IFXF_MPLS on an interface the output pointers are switched.
This now allows to cleanup the MPLS input and output pathes and fix mpe(4)
so that the MPLS code now actually works for both P and PE systems.
Tested by myself and michele
(A custom kernel with MPLS and mpe enabled is still needed).
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.18 2010/01/09 20:29:42 claudio Exp $ */
d396 1
a396 1
	IF_ENQUEUE(&ipintrq, m);
d430 1
a430 1
	IF_ENQUEUE(&ip6intrq, m);
@


1.18
log
@No need to call bpfdetach() in mpe_clone_destroy() since this is done in
if_detach() which is called right afterwards.
Found by Gleydson Soares (gleydson (at) trusted.com.br)
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.17 2009/12/26 12:34:41 claudio Exp $ */
d67 1
d94 1
a94 1
	mpeif->sc_shim.shim_label = MPLS_BOS_MASK | htonl(mpls_defttl);
d111 1
a111 1
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, MPE_HDRLEN);
d136 1
d144 1
a144 2
	struct mpe_softc	*ifm;
	struct shim_hdr		 shim;
d146 2
d157 21
a177 5
#ifdef DIAGNOSTIC
		if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
			printf("%s: trying to send packet on wrong domain. "
			    "if %d vs. mbuf %d\n", ifp->if_xname,
			    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain));
a178 1
#endif
d181 10
a190 2
		if (ifp->if_bpf)
			bpf_mtap_af(ifp->if_bpf, AF_INET, m, BPF_DIRECTION_OUT);
d192 5
a196 12
		ifm = ifp->if_softc;
		shim.shim_label = ifm->sc_shim.shim_label;
		M_PREPEND(m, sizeof(shim), M_DONTWAIT);
		m_copyback(m, 0, sizeof(shim), (caddr_t)&shim);
		if (m == NULL) {
			ifp->if_ierrors++;
			continue;
		}
		m->m_pkthdr.rcvif = ifp;
		/* XXX assumes MPLS is always in rdomain 0 */
		m->m_pkthdr.rdomain = 0;
		mpls_output(m, NULL);
d204 16
a219 2
	int	s;
	int	error;
d223 1
d225 27
d253 2
a254 5
	case AF_MPLS:
		/*
		 * drop MPLS packets entering here. This is a hack to prevent
		 * loops because of misconfiguration.
		 */
a255 3
		error = ENETUNREACH;
		return (error);
	default:
d259 3
d271 1
a285 1
	u_int32_t		 ttl = htonl(mpls_defttl);
d291 2
a292 1
		ifp->if_flags |= IFF_UP;
d323 1
a323 2
		shim.shim_label = (htonl(shim.shim_label << MPLS_LABEL_OFFSET))
		    | MPLS_BOS_MASK | ttl;
d336 8
d393 1
a393 1
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
d427 1
a427 1
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
d433 35
@


1.17
log
@Initial rdomain support for mpe(4). Caveat: assumes MPLS is always in
rdomain 0 for now.  OK michele@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.16 2009/07/13 12:41:46 dlg Exp $ */
a129 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.16
log
@dont initialise ifp->if_snd.ifq_maxlen, and then follow it by
IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen).

the first was deprecated by the use of IFQ_SET_MAXLEN.
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.14 2008/11/06 20:53:10 michele Exp $ */
d157 8
d178 2
d324 4
d357 4
@


1.15
log
@Get rid of the ugly rtentry hack.

We can now act as edge node and allow ipv4 packets to
enter a Label Switched Path and not just forwarding
MPLS packets.

OK claudio@@
@
text
@a103 1
	ifp->if_snd.ifq_maxlen = ifqmaxlen;
@


1.14
log
@Introduced IPv6 support of uniform model for TTL handling.

OK claudio@@ laurent@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.13 2008/11/01 16:37:55 michele Exp $ */
d171 1
a171 1
		mpls_output(m);
@


1.13
log
@Introduced Uniform Model for TTL handling.
MPLS TTL is mapped into network layer one as the packet exits the LSP.
Just IPv4 support for now.
Added the relevant sysctls to enable this behaviour.

Input and OK claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.12 2008/10/28 01:16:14 michele Exp $ */
d41 1
a44 1
#include <netinet6/nd6.h>
d329 2
a330 1
	int		 s;
d335 8
a342 1
		/* XXX: fixup IPv6 ttl */
@


1.12
log
@Added mpls_output() used to output mpls packets originating from local host.
Strictly similar to mpls_input().

Input and OK claudio@@, OK laurent@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.11 2008/10/18 12:30:40 michele Exp $ */
d72 3
d283 1
a283 1
    u_int32_t ttl)
d285 2
a286 1
	int		 s;
a287 1
	/* fixup ttl */
d289 25
d327 1
a327 1
    u_int32_t ttl)
a330 1
	/* fixup ttl */
d332 5
a336 1
	
@


1.11
log
@Prevent the user to assign reserved labels to mpe(4) interfaces.

OK claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.10 2008/10/14 20:43:33 michele Exp $ */
d168 1
a168 1
		mpls_input(m);
a291 3
	/*
	 * assume we only get fed ipv4 packets for now.
	 */
a310 3
	/*
	 * assume we only get fed ipv4 packets for now.
	 */
@


1.10
log
@Now mpls_input() handles ipv4 and ipv6 explicit null labels.
Added mpe_input6 to manage also ipv6 packets insted of just ipv4 ones.

OK claudio@@ laurent@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_mpe.c,v 1.9 2008/05/08 09:52:36 pyr Exp $ */
d250 2
a251 1
		if (shim.shim_label > MPLS_LABEL_MAX) {
@


1.9
log
@Add license and OpenBSD RCS Tag to the file, spotted by Dries Schellekens.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d156 2
a157 2
	if (ifp->if_bpf)
		bpf_mtap_af(ifp->if_bpf, AF_INET, m, BPF_DIRECTION_OUT);
d287 1
a287 1
	if (ifp->if_bpf)
d296 22
@


1.8
log
@Start at making mpe tap to bpf.  While there move if_start() call inside
splnet.
The DLT_MPLS will not go away and will be used for display in tcpdump -y
mpls when the code is there, as suggested by reyk.
@
text
@d1 17
@


1.7
log
@Hook mpe(4) correctly into mpls so that it is possible to tunnel packets over
MPLS. Still a bit hackish but getting closer. hai norby@@
@
text
@d30 5
a89 1

d91 1
a91 1
	bpfattach(&mpeif->sc_if.if_bpf, ifp, DLT_MPLS, MPE_HDRLEN);
d132 1
a132 1
		IF_DEQUEUE(&ifp->if_snd, m);
d138 4
d163 8
a170 5
	/*
	 * drop MPLS packets entering here. This is a hack to prevent
	 * loops because of misconfiguration.
	 */
	if (dst->sa_family == AF_MPLS) {
d174 3
d185 1
d187 3
a189 1
	if_start(ifp);
d269 4
@


1.6
log
@UP mpe interfaces.

ok claudio@@
@
text
@d155 9
d244 2
a245 1
mpe_input(struct mbuf *m)
a247 10
	struct shim_hdr	*shim;

	shim = mtod(m, struct shim_hdr *);
	if (!(MPLS_BOS_ISSET(shim->shim_label))) {
#ifdef MPLS_DEBUG
		printf("mpe_input: invalid packet with non BoS label\n");
#endif
		m_free(m);
		return;
	}
d249 2
a250 6
	
#ifdef MPLS_DEBUG
	printf("mpe_input: got packet with label: %d\n",
	    ((ntohl(shim->shim_label & MPLS_LABEL_MASK)) >> MPLS_LABEL_OFFSET));
#endif
	m_adj(m, sizeof(shim));
@


1.5
log
@Missing return and correctly indent a debug printf.
@
text
@d181 1
@


1.4
log
@add mpe_input() to be able to be fed packets that will reenter ip.
no consumers yet, they should come soon.

ok norby@@
@
text
@d245 1
d250 2
a251 3
		printf("mpe_input: got packet with label: %d\n",
		    ((ntohl(shim->shim_label & MPLS_LABEL_MASK)) >>
		    MPLS_LABEL_OFFSET));
@


1.3
log
@Make mpe a point-to-point interface.
Make the mtu user definable.
ok claudio@@
@
text
@d13 1
d231 31
@


1.2
log
@Correctly initialize labels by byte-swapping and inserting BoS and TTL.
While there bump MTU to 1500 and set the receiving interface before
calling mpls_input. mpestart will eventually call mpls_output when it
exists.

``yaaaaayyy'' and ok claudio@@ and norby@@
@
text
@d71 1
d73 1
a73 1
	ifp->if_mtu = 1500;
d186 7
@


1.1
log
@bring in the mpe interface - for ``MPLS Provider Edge'' - this is a work
in progress and some bits need to be cleaned up but will be in-tree for
convenience.

ok claudio@@, norby@@
@
text
@d67 1
a67 1
	mpeif->sc_shim.shim_label = 0;
d72 1
a72 1
	ifp->if_mtu = 0;
d140 1
d173 1
d188 4
a191 2
		error = copyout(&ifm->sc_shim, ifr->ifr_data,
		    sizeof(ifm->sc_shim));
a196 2
		if (ifm->sc_shim.shim_label == shim.shim_label)
			break;
d201 4
@

