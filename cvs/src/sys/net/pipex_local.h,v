head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.2
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.6
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.8
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.29
date	2017.07.27.05.57.04;	author yasuoka;	state Exp;
branches;
next	1.28;
commitid	pOMlZg6kCFnF2Fwr;

1.28
date	2017.05.28.21.57.19;	author mlarkin;	state Exp;
branches;
next	1.27;
commitid	1ojhaXHuHSV8vkMl;

1.27
date	2017.05.28.18.43.51;	author yasuoka;	state Exp;
branches;
next	1.26;
commitid	mNrUYdMVKiPpnA49;

1.26
date	2017.05.28.12.51.34;	author yasuoka;	state Exp;
branches;
next	1.25;
commitid	2vGVzcFLNmfkoMEp;

1.25
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.24;
commitid	Gef6NNDxonzfVaq2;

1.24
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.23;
commitid	6c6qq5OdS4VVnyVM;

1.23
date	2015.11.14.14.53.13;	author miod;	state Exp;
branches;
next	1.22;
commitid	F4YvjgeZAdPdFa0q;

1.22
date	2015.04.23.09.45.24;	author dlg;	state Exp;
branches;
next	1.21;
commitid	BpkIGymqTMK3ZEHF;

1.21
date	2014.12.01.06.55.05;	author yasuoka;	state Exp;
branches;
next	1.20;
commitid	J6mEszBKqi5g0A9d;

1.20
date	2014.10.21.10.52.53;	author yasuoka;	state Exp;
branches;
next	1.19;
commitid	yUVe4HyafiEJIH3w;

1.19
date	2013.04.20.07.54.28;	author yasuoka;	state Exp;
branches
	1.19.6.1
	1.19.8.1;
next	1.18;

1.18
date	2013.04.16.07.36.55;	author yasuoka;	state Exp;
branches;
next	1.17;

1.17
date	2012.09.19.17.50.17;	author yasuoka;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.17.03.18.57;	author yasuoka;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.04.04.31.38;	author yasuoka;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.25.13.05.06;	author yasuoka;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.15.03.24.11;	author yasuoka;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.08.19.34.04;	author yasuoka;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.14.06.36.17;	author yasuoka;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.20.20.11.19;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.14.50.30;	author hsuenaga;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.22.13.03.48;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.09.08.36.31;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.08.08.40.29;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.03.00.16.07;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.13.07.23.38;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.13.06.05.47;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.12.02.26.37;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.03.50.56;	author yasuoka;	state Exp;
branches;
next	;

1.19.6.1
date	2014.12.01.06.59.03;	author yasuoka;	state Exp;
branches;
next	;
commitid	0ySGdQmz0Su3q2qP;

1.19.8.1
date	2014.12.01.06.57.33;	author yasuoka;	state Exp;
branches;
next	;
commitid	osz9lx24s4ChW0bH;


desc
@@


1.29
log
@SEQ16_* macros weren't able to compare properly if one of the sequences is
wrapped around. Fix them to cast the proper width of integer when
comparison.  found goda@@
@
text
@/*	$OpenBSD: pipex_local.h,v 1.28 2017/05/28 21:57:19 mlarkin Exp $	*/

/*
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef __OpenBSD__
#define Static
#else
#define Static static
#endif

#define	PIPEX_PPTP	1
#define	PIPEX_L2TP	1
#define	PIPEX_PPPOE	1
#define	PIPEX_MPPE	1

#define PIPEX_REWIND_LIMIT		64

#define PIPEX_ENABLED			0x0001

/* compile time option constants */
#ifndef	PIPEX_MAX_SESSION
#define PIPEX_MAX_SESSION		512
#endif
#define PIPEX_HASH_DIV			8
#define PIPEX_HASH_SIZE			(PIPEX_MAX_SESSION/PIPEX_HASH_DIV)
#define PIPEX_HASH_MASK			(PIPEX_HASH_SIZE-1)
#define PIPEX_CLOSE_TIMEOUT		30
#define	PIPEX_PPPMINLEN			5
	/* minimum PPP header length is 1 and minimum ppp payload length is 4 */

#ifndef	NNBY		/* usually defined on the <sys/types.h> */
#define	NNBY	8	/* number of bits of a byte */
#endif

#define PIPEX_MPPE_NOLDKEY		64 /* should be power of two */
#define PIPEX_MPPE_OLDKEYMASK		(PIPEX_MPPE_NOLDKEY - 1)

#ifdef PIPEX_MPPE
/* mppe rc4 key */
struct pipex_mppe {
	int16_t	stateless:1,			/* key change mode */
		resetreq:1,
		reserved:14;
	int16_t	keylenbits;			/* key length */
	int16_t keylen;
	uint16_t coher_cnt;			/* cohency counter */
	struct  rc4_ctx rc4ctx;
	u_char master_key[PIPEX_MPPE_KEYLEN];	/* master key of MPPE */
	u_char session_key[PIPEX_MPPE_KEYLEN];	/* session key of MPPE */
	u_char (*old_session_keys)[PIPEX_MPPE_KEYLEN];	/* old session keys */
};
#endif /* PIPEX_MPPE */

#ifdef PIPEX_PPPOE
struct pipex_pppoe_session {
	u_int	 over_ifidx;                 /* ether interface */
};
#endif /* PIPEX_PPPOE */

#ifdef PIPEX_PPTP
struct pipex_pptp_session {
	/* sequence number gap between pipex and userland */
	int32_t	snd_gap;			/* gap of our sequence */
	int32_t rcv_gap;			/* gap of peer's sequence */
	int32_t ul_snd_una;			/* userland send acked seq */

	uint32_t snd_nxt;			/* send next */
	uint32_t rcv_nxt;			/* receive next */
	uint32_t snd_una;			/* send acked sequence */
	uint32_t rcv_acked;			/* recv acked sequence */

	int winsz;				/* windows size */
	int maxwinsz;				/* max windows size */
	int peer_maxwinsz;			/* peer's max windows size */
};
#endif /* PIPEX_PPTP */

#ifdef PIPEX_L2TP
/*
 * L2TP Packet headers
 *
 *   +----+---+----+---+----+--------+
 *   |IPv4|UDP|L2TP|PPP|IPv4|Data....|
 *   +----+---+----+---+----+--------+
 *
 * Session Data
 *
 *   IPv4    IP_SRC         <-- required for encap.
 *           IP_DST         <-- required for encap.
 *
 *   UDP     SPort          <-- required for encap.
 *           DPort          <-- required for encap.
 *
 *   L2TP    FLAGS          <-- only handle TYPE=0 (data)
 *           Tunnel ID      <-- ID per tunnel(NOT a key: differed from RFC)
 *           Session ID     <-- ID per PPP session(KEY to look up session)
 *           Ns(SEND SEQ)   <-- sequence number of packet to send(opt.)
 *           Nr(RECV SEQ)   <-- sequence number of packet to recv(opt.)
 *
 * - Recv Session lookup key is (Tunnnel ID, Session ID) in RFC.
 *   - BUT (Session ID) in PIPEX. SESSION ID MUST BE UNIQ.
 *
 * - We must update (Ns, Nr) of data channel. and we must adjust (Ns, Nr)
 *   in packets from/to userland.
 */
struct pipex_l2tp_session {
	/* KEYS for session lookup (host byte order) */
	uint16_t tunnel_id;		/* our tunnel-id */
	uint16_t peer_tunnel_id;	/* peer's tunnel-id */

	/* protocol options */
	uint32_t option_flags;

	int16_t ns_gap;		/* gap between userland and pipex */
	int16_t nr_gap;		/* gap between userland and pipex */
	uint16_t ul_ns_una;	/* unacked sequence number (userland) */

	uint16_t ns_nxt;	/* next sequence number to send */
	uint16_t ns_una;	/* unacked sequence number to send*/

	uint16_t nr_nxt;	/* next sequence number to recv */
	uint16_t nr_acked;	/* acked sequence number to recv */
	uint32_t ipsecflowinfo;	/* IPsec SA flow id for NAT-T */
};
#endif /* PIPEX_L2TP */

/* pppac ip-extension sessoin table */
struct pipex_session {
	struct radix_node	ps4_rn[2];  /* tree glue, and other values */
	struct radix_node	ps6_rn[2];  /* tree glue, and other values */
	LIST_ENTRY(pipex_session) session_list;	/* all session chain */
	LIST_ENTRY(pipex_session) state_list;	/* state list chain */
	LIST_ENTRY(pipex_session) id_chain;	/* id hash chain */
	LIST_ENTRY(pipex_session) peer_addr_chain;
						/* peer's address hash chain */
	uint16_t	state;			/* pipex session state */
#define PIPEX_STATE_INITIAL		0x0000
#define PIPEX_STATE_OPENED		0x0001
#define PIPEX_STATE_CLOSE_WAIT		0x0002
#define PIPEX_STATE_CLOSE_WAIT2		0x0003
#define PIPEX_STATE_CLOSED		0x0004

	uint16_t	ip_forward:1,		/* {en|dis}ableIP forwarding */
			ip6_forward:1,		/* {en|dis}able IPv6 forwarding */
			is_multicast:1,		/* virtual entry for multicast */
			reserved:13;
	uint16_t	protocol;		/* tunnel protocol (PK) */
	uint16_t	session_id;		/* session-id (PK) */
	uint16_t	peer_session_id;	/* peer's session-id */
	uint16_t	peer_mru;		/* peer's MRU */
	uint32_t	timeout_sec;		/* idle timeout */
	int		ppp_id;			/* PPP id */

	struct sockaddr_in ip_address;		/* remote address (AK) */
	struct sockaddr_in ip_netmask;		/* remote address mask (AK) */
	struct sockaddr_in6 ip6_address; /* remote IPv6 address */
	int		ip6_prefixlen;   /* remote IPv6 prefixlen */

	struct pipex_iface_context* pipex_iface;/* context for interface */

	uint32_t	ppp_flags;		/* configure flags */
#ifdef PIPEX_MPPE
	int ccp_id;				/* CCP packet id */
	struct pipex_mppe
	    mppe_recv,				/* MPPE context for incoming */
	    mppe_send;				/* MPPE context for outgoing */ 
#endif /*PIPEXMPPE */
	struct pipex_statistics stat;		/* statistics */
	union {
#ifdef PIPEX_PPPOE
		struct pipex_pppoe_session pppoe;	/* context for PPPoE */
#endif /* PIPEX_PPPOE */
#ifdef PIPEX_PPTP
		struct pipex_pptp_session pptp;		/* context for PPTP */
#endif /* PIPEX_PPTP */
#ifdef PIPEX_L2TP
		struct pipex_l2tp_session l2tp;
#endif
		char _proto_unknown[0];
	} proto;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sin4;
		struct sockaddr_in6	sin6;
		struct sockaddr_dl	sdl;
	} peer, local;
};

/* gre header */
struct pipex_gre_header {
	uint16_t flags;				/* flags and version*/
#define PIPEX_GRE_KFLAG			0x2000	/* keys present */
#define PIPEX_GRE_SFLAG			0x1000	/* seq present */
#define PIPEX_GRE_AFLAG			0x0080	/* ack present */
#define PIPEX_GRE_VER			0x0001	/* gre version code */
#define PIPEX_GRE_VERMASK		0x0007	/* gre version mask */
#define PIPEX_GRE_UNUSEDFLAGS		0xcf78	/* unused at pptp. set 0 in rfc2637 */

	uint16_t type;
#define PIPEX_GRE_PROTO_PPP		0x880b	/* gre/ppp */

	uint16_t len;			/* length not include gre header */
	uint16_t call_id;			/* call_id */
} __packed;

/* pppoe header */
struct pipex_pppoe_header {
	uint8_t vertype;			/* version and type */
#define PIPEX_PPPOE_VERTYPE		0x11	/* version and type code */

	uint8_t code;				/* code */
#define PIPEX_PPPOE_CODE_SESSION	0x00	/* code session */

	uint16_t session_id;			/* session id */
	uint16_t length;			/* length */
} __packed;

/* l2tp header */
struct pipex_l2tp_header {
	uint16_t flagsver;
#define PIPEX_L2TP_FLAG_MASK		0xfff0
#define PIPEX_L2TP_FLAG_TYPE		0x8000
#define PIPEX_L2TP_FLAG_LENGTH		0x4000
#define PIPEX_L2TP_FLAG_SEQUENCE	0x0800
#define PIPEX_L2TP_FLAG_OFFSET		0x0200
#define PIPEX_L2TP_FLAG_PRIORITY	0x0100
#define PIPEX_L2TP_VER_MASK		0x000f
#define PIPEX_L2TP_VER			2
	uint16_t length; /* optional */
	uint16_t tunnel_id;
	uint16_t session_id;
	/* can be followed by option header */
} __packed;

/* l2tp option header */
struct pipex_l2tp_seq_header {
	uint16_t ns;
	uint16_t nr;
} __packed;

struct pipex_l2tp_offset_header {
	uint16_t offset_size;
	/* uint8_t offset_pad[] */
} __packed;

#ifdef PIPEX_DEBUG
#define PIPEX_DBG(a) if (pipex_debug & 1) pipex_session_log a
/* #define PIPEX_MPPE_DBG(a) if (pipex_debug & 1) pipex_session_log a */
#define PIPEX_MPPE_DBG(a)
#else
#define PIPEX_DBG(a)
#define PIPEX_MPPE_DBG(a)
#endif /* PIPEX_DEBUG */

LIST_HEAD(pipex_hash_head, pipex_session);

extern struct pipex_hash_head	pipex_session_list;
extern struct pipex_hash_head	pipex_close_wait_list;
extern struct pipex_hash_head	pipex_peer_addr_hashtable[];
extern struct pipex_hash_head	pipex_id_hashtable[];


#define PIPEX_ID_HASHTABLE(key)						\
	(&pipex_id_hashtable[(key) & PIPEX_HASH_MASK])
#define PIPEX_PEER_ADDR_HASHTABLE(key)					\
	(&pipex_peer_addr_hashtable[(key) & PIPEX_HASH_MASK])

#define GETCHAR(c, cp) do {						\
	(c) = *(cp)++;							\
} while (0)

#define PUTCHAR(s, cp) do {						\
	*(cp)++ = (u_char)(s);						\
} while (0)

#define GETSHORT(s, cp) do {						\
	(s) = *(cp)++ << 8;						\
	(s) |= *(cp)++;							\
} while (0)

#define PUTSHORT(s, cp) do {						\
	*(cp)++ = (u_char) ((s) >> 8);					\
	*(cp)++ = (u_char) (s);						\
} while (0)

#define GETLONG(l, cp) do {						\
	(l) = *(cp)++ << 8;						\
	(l) |= *(cp)++; (l) <<= 8;					\
	(l) |= *(cp)++; (l) <<= 8;					\
	(l) |= *(cp)++;							\
} while (0)

#define PUTLONG(l, cp) do {						\
	*(cp)++ = (u_char) ((l) >> 24);					\
	*(cp)++ = (u_char) ((l) >> 16);					\
	*(cp)++ = (u_char) ((l) >> 8);					\
	*(cp)++ = (u_char) (l);						\
} while (0)

#define PIPEX_PULLUP(m0, l)						\
	if ((m0)->m_len < (l)) {					\
		if ((m0)->m_pkthdr.len < (l)) {				\
			PIPEX_DBG((NULL, LOG_DEBUG,			\
			    "<%s> received packet is too short.",	\
			    __func__));					\
			m_freem(m0);					\
			(m0) = NULL;					\
		} else  {						\
			(m0) = m_pullup((m0), (l));			\
			KASSERT((m0) != NULL);				\
		}							\
	}
#define PIPEX_SEEK_NEXTHDR(ptr, len, t)					\
    ((t) (((char *)ptr) + len))
#define SEQ32_LT(a,b)	((int32_t)((a) - (b)) <  0)
#define SEQ32_LE(a,b)	((int32_t)((a) - (b)) <= 0)
#define SEQ32_GT(a,b)	((int32_t)((a) - (b)) >  0)
#define SEQ32_GE(a,b)	((int32_t)((a) - (b)) >= 0)
#define SEQ32_SUB(a,b)	((int32_t)((a) - (b)))

#define SEQ16_LT(a,b)	((int16_t)((a) - (b)) <  0)
#define SEQ16_LE(a,b)	((int16_t)((a) - (b)) <= 0)
#define SEQ16_GT(a,b)	((int16_t)((a) - (b)) >  0)
#define SEQ16_GE(a,b)	((int16_t)((a) - (b)) >= 0)
#define SEQ16_SUB(a,b)	((int16_t)((a) - (b)))

#define	pipex_session_is_acfc_accepted(s)				\
    (((s)->ppp_flags & PIPEX_PPP_ACFC_ACCEPTED)? 1 : 0)
#define	pipex_session_is_pfc_accepted(s)				\
    (((s)->ppp_flags & PIPEX_PPP_PFC_ACCEPTED)? 1 : 0)
#define	pipex_session_is_acfc_enabled(s)				\
    (((s)->ppp_flags & PIPEX_PPP_ACFC_ENABLED)? 1 : 0)
#define	pipex_session_is_pfc_enabled(s)					\
    (((s)->ppp_flags & PIPEX_PPP_PFC_ENABLED)? 1 : 0)
#define	pipex_session_has_acf(s)					\
    (((s)->ppp_flags & PIPEX_PPP_HAS_ACF)? 1 : 0)
#define	pipex_session_is_mppe_accepted(s)				\
    (((s)->ppp_flags & PIPEX_PPP_MPPE_ACCEPTED)? 1 : 0)
#define	pipex_session_is_mppe_enabled(s)				\
    (((s)->ppp_flags & PIPEX_PPP_MPPE_ENABLED)? 1 : 0)
#define	pipex_session_is_mppe_required(s)				\
    (((s)->ppp_flags & PIPEX_PPP_MPPE_REQUIRED)? 1 : 0)
#define pipex_mppe_rc4_keybits(r) ((r)->keylen << 3)
#define pipex_session_is_l2tp_data_sequencing_on(s)			\
    (((s)->proto.l2tp.option_flags & PIPEX_L2TP_USE_SEQUENCING) ? 1 : 0)

#define PIPEX_IPGRE_HDRLEN (sizeof(struct ip) + sizeof(struct pipex_gre_header))
#define PIPEX_TCP_OPTLEN 40
#define	PIPEX_L2TP_MINLEN	8

/*
 * static function prototypes
 */
Static void                  pipex_iface_start (struct pipex_iface_context *);
Static void                  pipex_iface_stop (struct pipex_iface_context *);
Static int                   pipex_add_session (struct pipex_session_req *, struct pipex_iface_context *);
Static int                   pipex_close_session (struct pipex_session_close_req *);
Static int                   pipex_config_session (struct pipex_session_config_req *);
Static int                   pipex_get_stat (struct pipex_session_stat_req *);
Static int                   pipex_get_closed (struct pipex_session_list_req *);
Static int                   pipex_destroy_session (struct pipex_session *);
Static struct pipex_session  *pipex_lookup_by_ip_address (struct in_addr);
Static struct pipex_session  *pipex_lookup_by_session_id (int, int);
Static void                  pipex_ip_output (struct mbuf *, struct pipex_session *);
Static void                  pipex_ppp_output (struct mbuf *, struct pipex_session *, int);
Static inline int            pipex_ppp_proto (struct mbuf *, struct pipex_session *, int, int *);
Static void                  pipex_ppp_input (struct mbuf *, struct pipex_session *, int);
Static void                  pipex_ip_input (struct mbuf *, struct pipex_session *);
#ifdef INET6
Static void                  pipex_ip6_input (struct mbuf *, struct pipex_session *);
#endif
Static struct mbuf           *pipex_common_input(struct pipex_session *, struct mbuf *, int, int, int);

#ifdef PIPEX_PPPOE
Static void                  pipex_pppoe_output (struct mbuf *, struct pipex_session *);
#endif

#ifdef PIPEX_PPTP
Static void                  pipex_pptp_output (struct mbuf *, struct pipex_session *, int, int);
Static struct pipex_session  *pipex_pptp_userland_lookup_session(struct mbuf *, struct sockaddr *);
#endif

#ifdef PIPEX_L2TP
Static void                  pipex_l2tp_output (struct mbuf *, struct pipex_session *);
#endif

#ifdef PIPEX_MPPE
Static void                  pipex_mppe_init (struct pipex_mppe *, int, int, u_char *, int);
Static void                  GetNewKeyFromSHA (u_char *, u_char *, int, u_char *);
Static void                  pipex_mppe_reduce_key (struct pipex_mppe *);
Static void                  mppe_key_change (struct pipex_mppe *);
Static void                  pipex_mppe_input (struct mbuf *, struct pipex_session *);
Static void                  pipex_mppe_output (struct mbuf *, struct pipex_session *, uint16_t);
Static void                  pipex_ccp_input (struct mbuf *, struct pipex_session *);
Static int                   pipex_ccp_output (struct pipex_session *, int, int);
Static inline int            pipex_mppe_setkey(struct pipex_mppe *);
Static inline int            pipex_mppe_setoldkey(struct pipex_mppe *, uint16_t);
Static inline void           pipex_mppe_crypt(struct pipex_mppe *, int, u_char *, u_char *);
#endif

Static struct mbuf           *adjust_tcp_mss (struct mbuf *, int);
Static struct mbuf           *ip_is_idle_packet (struct mbuf *, int *);
Static void                  pipex_session_log (struct pipex_session *, int, const char *, ...)  __attribute__((__format__(__printf__,3,4)));
Static uint32_t              pipex_sockaddr_hash_key(struct sockaddr *);
Static int                   pipex_sockaddr_compar_addr(struct sockaddr *, struct sockaddr *);
Static int                   pipex_ppp_enqueue (struct mbuf *, struct pipex_session *, struct mbuf_queue *);
Static void                  pipex_timer_start (void);
Static void                  pipex_timer_stop (void);
Static void                  pipex_timer (void *);
@


1.28
log
@fix broken include on previous pipex commit

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.27 2017/05/28 18:43:51 yasuoka Exp $	*/
d339 4
a342 4
#define SEQ32_LT(a,b)	((int)((a) - (b)) <  0)
#define SEQ32_LE(a,b)	((int)((a) - (b)) <= 0)
#define SEQ32_GT(a,b)	((int)((a) - (b)) >  0)
#define SEQ32_GE(a,b)	((int)((a) - (b)) >= 0)
d345 4
a348 4
#define SEQ16_LT(a,b)	((int)((a) - (b)) <  0)
#define SEQ16_LE(a,b)	((int)((a) - (b)) <= 0)
#define SEQ16_GT(a,b)	((int)((a) - (b)) >  0)
#define SEQ16_GE(a,b)	((int)((a) - (b)) >= 0)
@


1.27
log
@Use interface index and if_{put,get} instead of ifnet pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.26 2017/05/28 12:51:34 yasuoka Exp $	*/
d396 1
a396 1
Static struct mbuf           *pipex_common_input(struct pipex_session *, struct mbuf *, int, int);
@


1.26
log
@Remove all splnet/splx from pipex(4) and pppx(4) and replace some of
them by NET_LOCK/NET_UNLOCK.  Also make the timeout for pipex_timer
run with a thread context and replace pipex softintr by NETISR_PIPEX.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.25 2017/05/04 15:00:24 bluhm Exp $	*/
d80 1
a80 1
	struct ifnet *over_ifp;                 /* ether interface */
@


1.25
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.24 2017/01/24 10:08:30 krw Exp $	*/
a430 1
Static void                  pipex_ppp_dequeue (void);
@


1.24
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.23 2015/11/14 14:53:13 miod Exp $	*/
d206 1
@


1.23
log
@mutli -> multi
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.22 2015/04/23 09:45:24 dlg Exp $	*/
d50 1
a50 1
#define PIPEX_HASH_MASK			(PIPEX_HASH_SIZE-1)	
d87 1
a87 1
	int32_t	snd_gap;			/* gap of our sequence */ 
d299 1
a299 1
#define GETSHORT(s, cp) do { 						\
d305 1
a305 1
	*(cp)++ = (u_char) ((s) >> 8); 					\
@


1.22
log
@replace the use of struct ifqueue in pipex with mbuf_queues.

this has a slight semantic change. previously pipex would only
process up to 128 packets on the input and output queues at a time
and would reschedule the softint if there were any left. now it
mq_delists the current set of pending packets and only processes
them. if anything is added to the queues later they'll cause the
softint to run again.

this in turn lets us deprecate sysctl_ifq since nothing uses it
anymore. because niqueues are mostly wrappers around mbuf_queues,
we can provide sysctl_mq and just #define sysctl_niq to it.

pipex bits are ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.21 2014/12/01 06:55:05 yasuoka Exp $	*/
d169 1
a169 1
			is_multicast:1,		/* virtual entry for mutlicast */
@


1.21
log
@Check the header fields of GRE and MPPE packets strictly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.20 2014/10/21 10:52:53 yasuoka Exp $	*/
a51 1
#define PIPEX_DEQUEUE_LIMIT		(IFQ_MAXLEN >> 1)
d429 1
a429 1
Static int                   pipex_ppp_enqueue (struct mbuf *, struct pipex_session *, struct ifqueue *);
@


1.20
log
@tun(4) has a pipex session which is used for multicast internally, it
wasn't freeed when the interface is destroyed.  Free it properly.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.19 2013/04/20 07:54:28 yasuoka Exp $	*/
d220 2
a221 1
#define PIPEX_GRE_VERMASK		0x0003	/* gre version mask */
@


1.19
log
@Remove unused macro function.

diff from Michael W. Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.18 2013/04/16 07:36:55 yasuoka Exp $	*/
d377 2
@


1.19.6.1
log
@Check the header fields of GRE and MPPE packets strictly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.19 2013/04/20 07:54:28 yasuoka Exp $	*/
d220 1
a220 2
#define PIPEX_GRE_VERMASK		0x0007	/* gre version mask */
#define PIPEX_GRE_UNUSEDFLAGS		0xcf78	/* unused at pptp. set 0 in rfc2637 */
@


1.19.8.1
log
@Check the header fields of GRE and MPPE packets strictly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.19 2013/04/20 07:54:28 yasuoka Exp $	*/
d220 1
a220 2
#define PIPEX_GRE_VERMASK		0x0007	/* gre version mask */
#define PIPEX_GRE_UNUSEDFLAGS		0xcf78	/* unused at pptp. set 0 in rfc2637 */
@


1.18
log
@When pipex session is terminated by idle timer, there was a problem that
the session is removed from the pipex_closed_wait_list twice, fixed it.
It always causes panic because QUEUE_MACRO_DEBUG is enabled by default.
Also remove some needless (struct pipex_session *) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.17 2012/09/19 17:50:17 yasuoka Exp $	*/
a349 1
#define RUPDIV(n,d)     (((n) + (d) - ((n) % (d))) / (d))
@


1.17
log
@cleanup around the pipex.  naming style, delete or update comments.
no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.16 2012/07/17 03:18:57 yasuoka Exp $	*/
d165 2
a166 1
#define PIPEX_STATE_CLOSED		0x0003
@


1.16
log
@use IPsec flowinfo on pipex(4) to select the IPsec tunnel for sending
L2TP packets.

ok markus henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.15 2012/04/04 04:31:38 yasuoka Exp $	*/
a42 4

#ifndef	LOG_PPPAC
#define	LOG_PPPAC	LOG_KERN
#endif
@


1.15
log
@pipex hook in udp_usrreq() mistakenly assumed that `inp' is connected.
It could not use the destination address properly, so it failed to
find the pipex session.  This bug caused LCP keepalive failures on some
clients.

found and tested by sebastia@@ and mxb at alumni.chalmers.se.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.14 2011/11/25 13:05:06 yasuoka Exp $	*/
d152 1
@


1.14
log
@fix compile errors without INET6.  no binary change.

pointed out by Julien Crapovich on misc@@
ok deraadt mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.13 2011/10/15 03:24:11 yasuoka Exp $	*/
a408 1
Static struct pipex_session  *pipex_l2tp_userland_lookup_session(struct mbuf *, struct sockaddr *);
@


1.13
log
@Added "provision for rewound PPP frames" that allows receiving
reorder packets to pass to the upper layer without reorder.  It
will improve performance (throughput or loss rate) for PPTP or
L2TP(/IPesc) on networks that latency is unstable such as mobile
network.

As our test environment (bandwidth: 6Mbps, latency: 50ms for 97% of
traffic and 52ms for rest of traffic), throughput has changed from
0.76MB to 2.17MB on file upload by PPTP connected Windows Vista
ftp.exe.

Developed by UMEZAWA Takeshi at IIJ.

ok jmatthew@@
tested jmatthew@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.12 2011/07/08 19:34:04 yasuoka Exp $	*/
d393 1
d395 1
@


1.12
log
@Last part of pipex_{pppoe,l2tp,pptp}_input() are almost identical.
Integrate them into pipex_common_input().

ok hsuenaga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.11 2011/03/14 06:36:17 yasuoka Exp $	*/
d40 2
d64 3
d79 1
d411 1
a411 1
Static void                  pipex_mppe_req_init (struct pipex_mppe_req *, struct pipex_mppe *);
d419 3
a421 2
Static inline int            rc4_key(struct pipex_mppe *, int, u_char *);
Static inline void           rc4(struct pipex_mppe *, int, u_char *, u_char *);
@


1.11
log
@fix typo
patch from Gleydson Soares

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.10 2010/11/20 20:11:19 miod Exp $	*/
d388 1
@


1.10
log
@__attribute__((packed)) -> __packed. The ioprbs.c chunk was commented out, and
uncommenting it is intentional.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.9 2010/09/24 14:50:30 hsuenaga Exp $	*/
d79 1
a79 1
	struct ifnet *over_ifp;			/* ether inteface */
@


1.9
log
@Add L2TP support to PIPEX.
We can use IPv6 address as outer header of L2TP.

Kernel ABI is changed. You must update npppd.

OK @@claudio, yasuoka@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.8 2010/09/22 13:03:48 claudio Exp $	*/
d223 1
a223 1
} __attribute__((__packed__));
d235 1
a235 1
} __attribute__((__packed__));
d252 1
a252 1
} __attribute__((__packed__));
d258 1
a258 1
} __attribute__((__packed__));
d263 1
a263 1
} __attribute__((__packed__));
@


1.8
log
@Add a new interface pppx(4) -- the ppp multiplexer to be used with npppd
and pipex. pppx(4) creates an interface whenever a session is created
so that altq and pf can work on these.
Started by dlg@@ debugged and made usable by myself
OK dlg@@ yasuoka@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.7 2010/07/09 08:36:31 yasuoka Exp $	*/
d36 1
a79 1
	struct sockaddr peer_addr;		/* peer's sockaddr */
d98 45
d144 2
a145 2
	struct in_addr peer_address;		/* inet destination address */
	struct in_addr our_address;		/* inet source address */
d147 1
a147 1
#endif /* PIPEX_PPTP */
d152 1
d165 1
d167 1
a167 1
			reserved:14;
d177 2
d197 3
d202 5
d237 28
d285 1
a285 3
	(&pipex_peer_addr_hashtable[ntohl((key)) & PIPEX_HASH_MASK])
#define PIPEX_ADDR_HASHTABLE(key)					\
	(&pipex_addr_hashtable[ntohl((key)) & PIPEX_HASH_MASK])
d340 7
d364 3
d369 1
d387 1
d395 6
d412 2
d419 2
@


1.7
log
@Modified to make sure that pipex_mppe_ouput() keeps the packet 32bit
aligned.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.6 2010/07/08 08:40:29 yasuoka Exp $	*/
d188 8
@


1.6
log
@pipex didn't work on output.  Fixed following problems:
 - pipex failed to lookup the radix tree because address and netmask
   were not initialized.
 - pipex used wrong place as a ip header because it didn't adjust
   32bit address family header that are added at tun_output.
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.5 2010/07/03 00:16:07 yasuoka Exp $	*/
d300 1
a300 1
Static void                  pipex_mppe_output (struct mbuf *, struct pipex_session *);
@


1.5
log
@s/$Id$/$OpenBSD$/
@
text
@d1 1
a1 1
/*	$OpenBSD: pipex_local.h,v 1.4 2010/01/13 07:23:38 yasuoka Exp $	*/
d280 1
@


1.4
log
@cleanup pipex code.  ok henning@@
@
text
@d1 2
a2 1
/*	$Id: pipex_local.h,v 1.3 2010/01/13 06:05:47 dlg Exp $	*/
@


1.3
log
@replace static on functions with Static so openbsd can define it away
to nothing. this lets us see functions in ddb, while not hurting the
ability to share the code with other projects.

idea borrowed from the usb stack.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$Id: pipex_local.h,v 1.2 2010/01/12 02:26:37 yasuoka Exp $	*/
a47 5
#ifdef	NBSAFE_RC4
#define PIPEX_RC4_CTXLEN		288
#else
#define PIPEX_RC4_CTXLEN		1152
#endif
d69 1
a69 3
	struct {
		u_char rc4ctx_space[PIPEX_RC4_CTXLEN]; /* space for rc4ctx */
	} rc4ctx;				/* rc4ctx */
d195 9
a203 3
#define GETCHAR(c, cp) { (c) = *(cp)++; }
#define PUTCHAR(s, cp) { *(cp)++ = (u_char) (s); }
#define GETSHORT(s, cp) { 						\
d206 3
a208 2
}
#define PUTSHORT(s, cp) {						\
d211 3
a213 2
}
#define GETLONG(l, cp) {						\
d218 3
a220 2
}
#define PUTLONG(l, cp) {						\
d225 2
a226 1
}
a247 1
#define RUPDIV(n,d)     (((n) + (d) - ((n) % (d))) / (d))
a294 4
Static inline int            rc4_key (struct pipex_mppe *, int, u_char *);
Static inline void           rc4 (struct pipex_mppe *, int, u_char *, u_char *);
Static int                   rc4_key (struct pipex_mppe *, int, u_char *);
Static void                  rc4 (struct pipex_mppe *, int, u_char *, u_char *);
@


1.2
log
@Delete unused structures.  Pointed out by deraadt@@.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$Id: pipex_local.h,v 1.1 2010/01/11 03:50:56 yasuoka Exp $	*/
d27 7
d269 12
a280 12
static int                   pipex_add_session (struct pipex_session_req *, struct pipex_iface_context *);
static int                   pipex_close_session (struct pipex_session_close_req *);
static int                   pipex_config_session (struct pipex_session_config_req *);
static int                   pipex_get_stat (struct pipex_session_stat_req *);
static int                   pipex_get_closed (struct pipex_session_list_req *);
static int                   pipex_destroy_session (struct pipex_session *);
static struct pipex_session  *pipex_lookup_by_ip_address (struct in_addr);
static struct pipex_session  *pipex_lookup_by_session_id (int, int);
static void                  pipex_ppp_output (struct mbuf *, struct pipex_session *, int);
static inline int            pipex_ppp_proto (struct mbuf *, struct pipex_session *, int, int *);
static void                  pipex_ppp_input (struct mbuf *, struct pipex_session *, int);
static void                  pipex_ip_input (struct mbuf *, struct pipex_session *);
d283 1
a283 1
static void                  pipex_pppoe_output (struct mbuf *, struct pipex_session *);
d287 1
a287 1
static void                  pipex_pptp_output (struct mbuf *, struct pipex_session *, int, int);
d291 12
a302 12
static void                  pipex_mppe_req_init (struct pipex_mppe_req *, struct pipex_mppe *);
static void                  GetNewKeyFromSHA (u_char *, u_char *, int, u_char *);
static inline int            rc4_key (struct pipex_mppe *, int, u_char *);
static inline void           rc4 (struct pipex_mppe *, int, u_char *, u_char *);
static int                   rc4_key (struct pipex_mppe *, int, u_char *);
static void                  rc4 (struct pipex_mppe *, int, u_char *, u_char *);
static void                  pipex_mppe_reduce_key (struct pipex_mppe *);
static void                  mppe_key_change (struct pipex_mppe *);
static void                  pipex_mppe_input (struct mbuf *, struct pipex_session *);
static void                  pipex_mppe_output (struct mbuf *, struct pipex_session *);
static void                  pipex_ccp_input (struct mbuf *, struct pipex_session *);
static int                   pipex_ccp_output (struct pipex_session *, int, int);
d305 8
a312 8
static struct mbuf           *adjust_tcp_mss (struct mbuf *, int);
static struct mbuf           *ip_is_idle_packet (struct mbuf *, int *);
static void                  pipex_session_log (struct pipex_session *, int, const char *, ...)  __attribute__((__format__(__printf__,3,4)));
static int                   pipex_ppp_enqueue (struct mbuf *, struct pipex_session *, struct ifqueue *);
static void                  pipex_ppp_dequeue (void);
static void                  pipex_timer_start (void);
static void                  pipex_timer_stop (void);
static void                  pipex_timer (void *);
@


1.1
log
@Initial import PIPEX.  PIPEX(Pppac IP EXtension) is a IP forwarding
acceleration for PPP access concentrator.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d1 1
a1 1
/*	$Id: pipex_local.h,v 1.25 2008-08-28 07:46:53 uebayasi Exp $	*/
a165 14

/* ppp/ccp header */
struct pipex_ccp_header {
	uint8_t code;
	uint8_t id;
	uint16_t len;
} __attribute__((__packed__));

/* ppp header */
struct pipex_ppp_header {
	uint8_t		c[0];			/* ppp proto */
	uint16_t	code;			/* ppp proto (2 oct) */
} __attribute__((__packed__));

@

