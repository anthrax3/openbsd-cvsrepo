head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.22
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.20
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.16
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.14
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.12
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.10
	OPENBSD_5_0:1.31.0.8
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.29.0.8
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.7.0.8
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.39
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.38;
commitid	6c6qq5OdS4VVnyVM;

1.38
date	2016.12.14.08.16.56;	author sthen;	state Exp;
branches;
next	1.37;
commitid	AuudDWg1NdnERzkO;

1.37
date	2016.12.13.21.06.28;	author mikeb;	state Exp;
branches;
next	1.36;
commitid	TbHI1Ih5DBmrxdFn;

1.36
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.35;
commitid	1npmDuWgN1zBR6BQ;

1.35
date	2015.11.15.00.17.47;	author stsp;	state Exp;
branches;
next	1.34;
commitid	STPyVQgL2oSXEE06;

1.34
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.33;
commitid	6vhYvh5CxZAHMnsN;

1.33
date	2015.09.09.15.57.15;	author stsp;	state Exp;
branches;
next	1.32;
commitid	yNCLQDHEU8avY6r8;

1.32
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.31;
commitid	t9FBKDfc4VDxpEy2;

1.31
date	2010.02.09.13.18.04;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.02.22.31.50;	author sobrado;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.19.08.39.33;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.05.19.28.26;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.19.03.50.25;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.17.17.34.22;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.29.22.11.57;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.29.20.06.31;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.27.12.00.17;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.21.07.08.41;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.10.15.10.35;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.10.08.45.11;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.05.01.48.50;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.02.02.12.16;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.28.20.35.44;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.07.22.21.20;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.27.03.44.50;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.19.16.01.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.24.12.23.57;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.10.19.25.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.28.18.23.07;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.26.20.04.16;	author nate;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	2000.03.21.23.18.13;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.26.01.16.30;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.18.14.42.06;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.08.05.28.38;	author jason;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.21.19.55.59;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.09.03.06.24.20;	author jason;	state Exp;
branches;
next	;

1.3.2.1
date	2000.02.20.11.57.20;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2000.03.02.07.04.41;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2000.03.24.09.09.32;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2001.05.14.22.40.01;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	;

1.7.8.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.39
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@/*	$OpenBSD: if_media.h,v 1.38 2016/12/14 08:16:56 sthen Exp $	*/
/*	$NetBSD: if_media.h,v 1.22 2000/02/17 21:53:16 sommerfeld Exp $	*/

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997
 *	Jonathan Stone and Jason R. Thorpe.  All rights reserved.
 *
 * This software is derived from information provided by Matt Thomas.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jonathan Stone
 *	and Jason R. Thorpe for the NetBSD Project.
 * 4. The names of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _NET_IF_MEDIA_H_
#define _NET_IF_MEDIA_H_

#ifdef _KERNEL

struct ifnet;

#include <sys/queue.h>
/*
 * Driver callbacks for media status and change requests.
 */
typedef	int (*ifm_change_cb_t)(struct ifnet *);
typedef	void (*ifm_stat_cb_t)(struct ifnet *, struct ifmediareq *);

/*
 * In-kernel representation of a single supported media type.
 */
struct ifmedia_entry {
	TAILQ_ENTRY(ifmedia_entry) ifm_list;
	uint64_t	ifm_media;	/* description of this media attachment */
	u_int	ifm_data;	/* for driver-specific use */
	void	*ifm_aux;	/* for driver-specific use */
};

/*
 * One of these goes into a network interface's softc structure.
 * It is used to keep general media state.
 */
struct ifmedia {
	uint64_t	ifm_mask;	/* mask of changes we don't care about */
	uint64_t	ifm_media;	/* current user-set media word */
	struct ifmedia_entry *ifm_cur;	/* currently selected media */
	TAILQ_HEAD(, ifmedia_entry) ifm_list; /* list of all supported media */
	ifm_change_cb_t	ifm_change;	/* media change driver callback */
	ifm_stat_cb_t	ifm_status;	/* media status driver callback */
};

/* Initialize an interface's struct if_media field. */
void	ifmedia_init(struct ifmedia *, uint64_t, ifm_change_cb_t,
	     ifm_stat_cb_t);

/* Add one supported medium to a struct ifmedia. */
void	ifmedia_add(struct ifmedia *, uint64_t, int, void *);

/* Add an array (of ifmedia_entry) media to a struct ifmedia. */
void	ifmedia_list_add(struct ifmedia *, struct ifmedia_entry *,
	    int);

/* Set default media type on initialization. */
void	ifmedia_set(struct ifmedia *, uint64_t);

/* Common ioctl function for getting/setting media, called by driver. */
int	ifmedia_ioctl(struct ifnet *, struct ifreq *, struct ifmedia *,
	    u_long);

/* Locate a media entry */
struct	ifmedia_entry *ifmedia_match(struct ifmedia *, uint64_t, uint64_t);

/* Delete all media for a given media instance */
void	ifmedia_delete_instance(struct ifmedia *, uint64_t);

/* Compute baudrate for a given media. */
uint64_t	ifmedia_baudrate(uint64_t);
#endif /*_KERNEL */

/*
 * if_media Options word:
 *	Bits	Use
 *	----	-------
 *	0-7	Media subtype		MAX SUBTYPE == 255!
 *	8-15	Media type
 *	16-31	Type specific options
 *	32-39	Mode (for multi-mode devices)
 *	40-55	Shared (global) options
 *	56-63	Instance
 */

/*
 * Ethernet
 */
#define IFM_ETHER	0x0000000000000100ULL
#define	IFM_10_T	3		/* 10BaseT - RJ45 */
#define	IFM_10_2	4		/* 10Base2 - Thinnet */
#define	IFM_10_5	5		/* 10Base5 - AUI */
#define	IFM_100_TX	6		/* 100BaseTX - RJ45 */
#define	IFM_100_FX	7		/* 100BaseFX - Fiber */
#define	IFM_100_T4	8		/* 100BaseT4 - 4 pair cat 3 */
#define	IFM_100_VG	9		/* 100VG-AnyLAN */
#define	IFM_100_T2	10		/* 100BaseT2 */
#define	IFM_1000_SX	11		/* 1000BaseSX - multi-mode fiber */
#define	IFM_10_STP	12		/* 10BaseT over shielded TP */
#define	IFM_10_FL	13		/* 10BaseFL - Fiber */
#define	IFM_1000_LX	14		/* 1000baseLX - single-mode fiber */
#define	IFM_1000_CX	15		/* 1000baseCX - 150ohm STP */
#define	IFM_1000_T	16		/* 1000baseT - 4 pair cat 5 */
#define	IFM_1000_TX	IFM_1000_T	/* for backwards compatibility */
#define	IFM_HPNA_1	17		/* HomePNA 1.0 (1Mb/s) */
#define	IFM_10G_LR	18		/* 10GBase-LR - single-mode fiber */
#define	IFM_10G_SR	19		/* 10GBase-SR - multi-mode fiber */
#define	IFM_10G_CX4	20		/* 10GBase-CX4 - copper */
#define	IFM_2500_SX	21		/* 2500baseSX - multi-mode fiber */
#define	IFM_10G_T	22		/* 10GbaseT cat 6 */
#define	IFM_10G_SFP_CU	23		/* 10G SFP+ direct attached cable */
#define	IFM_10G_LRM	24		/* 10GBase-LRM 850nm Multi-mode */
#define	IFM_40G_CR4	25		/* 40GBase-CR4 */
#define	IFM_40G_SR4	26		/* 40GBase-SR4 */
#define	IFM_40G_LR4	27		/* 40GBase-LR4 */
#define	IFM_1000_KX	28		/* 1000Base-KX backplane */
#define	IFM_10G_KX4	29		/* 10GBase-KX4 backplane */
#define	IFM_10G_KR	30		/* 10GBase-KR backplane */
#define	IFM_10G_CR1	31		/* 10GBase-CR1 Twinax splitter */
#define	IFM_20G_KR2	32		/* 20GBase-KR2 backplane */
#define	IFM_2500_KX	33		/* 2500Base-KX backplane */
#define	IFM_2500_T	34		/* 2500Base-T - RJ45 (NBaseT) */
#define	IFM_5000_T	35		/* 5000Base-T - RJ45 (NBaseT) */
#define	IFM_1000_SGMII	36		/* 1G media interface */
#define	IFM_10G_SFI	37		/* 10G media interface */
#define	IFM_40G_XLPPI	38		/* 40G media interface */
#define	IFM_1000_CX_SGMII 39		/* 1000Base-CX-SGMII */
#define	IFM_40G_KR4	40		/* 40GBase-KR4 */
#define	IFM_10G_ER	41		/* 10GBase-ER */
#define	IFM_100G_CR4	42		/* 100GBase-CR4 */
#define	IFM_100G_SR4	43		/* 100GBase-SR4 */
#define	IFM_100G_KR4	44		/* 100GBase-KR4 */
#define	IFM_100G_LR4	45		/* 100GBase-LR4 */
#define	IFM_56G_R4	46		/* 56GBase-R4 */
#define	IFM_25G_CR	47		/* 25GBase-CR */
#define	IFM_25G_KR	48		/* 25GBase-KR */
#define	IFM_25G_SR	49		/* 25GBase-SR */
#define	IFM_50G_CR2	50		/* 50GBase-CR2 */
#define	IFM_50G_KR2	51		/* 50GBase-KR2 */

#define	IFM_ETH_MASTER	0x0000000000010000ULL	/* master mode (1000baseT) */
#define	IFM_ETH_RXPAUSE	0x0000000000020000ULL	/* receive PAUSE frames */
#define	IFM_ETH_TXPAUSE	0x0000000000040000ULL	/* transmit PAUSE frames */

/*
 * FDDI
 */
#define	IFM_FDDI	0x0000000000000300ULL
#define	IFM_FDDI_SMF	3		/* Single-mode fiber */
#define	IFM_FDDI_MMF	4		/* Multi-mode fiber */
#define IFM_FDDI_UTP	5		/* CDDI / UTP */
#define IFM_FDDI_DA	0x00000100	/* Dual attach / single attach */

/*
 * IEEE 802.11 Wireless
 */
#define	IFM_IEEE80211	0x0000000000000400ULL
#define	IFM_IEEE80211_FH1	3	/* Frequency Hopping 1Mbps */
#define	IFM_IEEE80211_FH2	4	/* Frequency Hopping 2Mbps */
#define	IFM_IEEE80211_DS2	5	/* Direct Sequence 2Mbps */
#define	IFM_IEEE80211_DS5	6	/* Direct Sequence 5Mbps*/
#define	IFM_IEEE80211_DS11	7	/* Direct Sequence 11Mbps*/
#define	IFM_IEEE80211_DS1	8	/* Direct Sequence  1Mbps*/
#define IFM_IEEE80211_DS22	9	/* Direct Sequence 22Mbps */ 
#define IFM_IEEE80211_OFDM6	10	/* OFDM 6Mbps */
#define IFM_IEEE80211_OFDM9	11	/* OFDM 9Mbps */
#define IFM_IEEE80211_OFDM12	12	/* OFDM 12Mbps */
#define IFM_IEEE80211_OFDM18	13	/* OFDM 18Mbps */
#define IFM_IEEE80211_OFDM24	14	/* OFDM 24Mbps */
#define IFM_IEEE80211_OFDM36	15	/* OFDM 36Mbps */
#define IFM_IEEE80211_OFDM48	16	/* OFDM 48Mbps */
#define IFM_IEEE80211_OFDM54	17	/* OFDM 54Mbps */
#define IFM_IEEE80211_OFDM72	18	/* OFDM 72Mbps */
#define IFM_IEEE80211_HT_MCS0	19	/* 11n MCS 0 */
#define IFM_IEEE80211_HT_MCS1	20	/* 11n MCS 1 */
#define IFM_IEEE80211_HT_MCS2	21	/* 11n MCS 2 */
#define IFM_IEEE80211_HT_MCS3	22	/* 11n MCS 3 */
#define IFM_IEEE80211_HT_MCS4	23	/* 11n MCS 4 */
#define IFM_IEEE80211_HT_MCS5	24	/* 11n MCS 5 */
#define IFM_IEEE80211_HT_MCS6	25	/* 11n MCS 6 */
#define IFM_IEEE80211_HT_MCS7	26	/* 11n MCS 7 */
#define IFM_IEEE80211_HT_MCS8	27	/* 11n MCS 8 */
#define IFM_IEEE80211_HT_MCS9	28	/* 11n MCS 9 */
#define IFM_IEEE80211_HT_MCS10	29	/* 11n MCS 10 */
#define IFM_IEEE80211_HT_MCS11	30	/* 11n MCS 11 */
#define IFM_IEEE80211_HT_MCS12	31	/* 11n MCS 12 */
#define IFM_IEEE80211_HT_MCS13	32	/* 11n MCS 13 */
#define IFM_IEEE80211_HT_MCS14	33	/* 11n MCS 14 */
#define IFM_IEEE80211_HT_MCS15	34	/* 11n MCS 15 */
#define IFM_IEEE80211_HT_MCS16	35	/* 11n MCS 16 */
#define IFM_IEEE80211_HT_MCS17	36	/* 11n MCS 17 */
#define IFM_IEEE80211_HT_MCS18	37	/* 11n MCS 18 */
#define IFM_IEEE80211_HT_MCS19	38	/* 11n MCS 19 */
#define IFM_IEEE80211_HT_MCS20	39	/* 11n MCS 20 */
#define IFM_IEEE80211_HT_MCS21	40	/* 11n MCS 21 */
#define IFM_IEEE80211_HT_MCS22	41	/* 11n MCS 22 */
#define IFM_IEEE80211_HT_MCS23	42	/* 11n MCS 23 */
#define IFM_IEEE80211_HT_MCS24	43	/* 11n MCS 24 */
#define IFM_IEEE80211_HT_MCS25	44	/* 11n MCS 25 */
#define IFM_IEEE80211_HT_MCS26	45	/* 11n MCS 26 */
#define IFM_IEEE80211_HT_MCS27	46	/* 11n MCS 27 */
#define IFM_IEEE80211_HT_MCS28	47	/* 11n MCS 28 */
#define IFM_IEEE80211_HT_MCS29	48	/* 11n MCS 29 */
#define IFM_IEEE80211_HT_MCS30	49	/* 11n MCS 30 */
#define IFM_IEEE80211_HT_MCS31	50	/* 11n MCS 31 */
#define IFM_IEEE80211_HT_MCS32	51	/* 11n MCS 32 */
#define IFM_IEEE80211_HT_MCS33	52	/* 11n MCS 33 */
#define IFM_IEEE80211_HT_MCS34	53	/* 11n MCS 34 */
#define IFM_IEEE80211_HT_MCS35	54	/* 11n MCS 35 */
#define IFM_IEEE80211_HT_MCS36	55	/* 11n MCS 36 */
#define IFM_IEEE80211_HT_MCS37	56	/* 11n MCS 37 */
#define IFM_IEEE80211_HT_MCS38	57	/* 11n MCS 38 */
#define IFM_IEEE80211_HT_MCS39	58	/* 11n MCS 39 */
#define IFM_IEEE80211_HT_MCS40	59	/* 11n MCS 40 */
#define IFM_IEEE80211_HT_MCS41	60	/* 11n MCS 41 */
#define IFM_IEEE80211_HT_MCS42	61	/* 11n MCS 42 */
#define IFM_IEEE80211_HT_MCS43	62	/* 11n MCS 43 */
#define IFM_IEEE80211_HT_MCS44	63	/* 11n MCS 44 */
#define IFM_IEEE80211_HT_MCS45	64	/* 11n MCS 45 */
#define IFM_IEEE80211_HT_MCS46	65	/* 11n MCS 46 */
#define IFM_IEEE80211_HT_MCS47	66	/* 11n MCS 47 */
#define IFM_IEEE80211_HT_MCS48	67	/* 11n MCS 48 */
#define IFM_IEEE80211_HT_MCS49	68	/* 11n MCS 49 */
#define IFM_IEEE80211_HT_MCS50	69	/* 11n MCS 50 */
#define IFM_IEEE80211_HT_MCS51	70	/* 11n MCS 51 */
#define IFM_IEEE80211_HT_MCS52	71	/* 11n MCS 52 */
#define IFM_IEEE80211_HT_MCS53	72	/* 11n MCS 53 */
#define IFM_IEEE80211_HT_MCS54	73	/* 11n MCS 54 */
#define IFM_IEEE80211_HT_MCS55	74	/* 11n MCS 55 */
#define IFM_IEEE80211_HT_MCS56	75	/* 11n MCS 56 */
#define IFM_IEEE80211_HT_MCS57	76	/* 11n MCS 57 */
#define IFM_IEEE80211_HT_MCS58	77	/* 11n MCS 58 */
#define IFM_IEEE80211_HT_MCS59	78	/* 11n MCS 59 */
#define IFM_IEEE80211_HT_MCS60	79	/* 11n MCS 60 */
#define IFM_IEEE80211_HT_MCS61	80	/* 11n MCS 61 */
#define IFM_IEEE80211_HT_MCS62	81	/* 11n MCS 62 */
#define IFM_IEEE80211_HT_MCS63	82	/* 11n MCS 63 */
#define IFM_IEEE80211_HT_MCS64	83	/* 11n MCS 64 */
#define IFM_IEEE80211_HT_MCS65	84	/* 11n MCS 65 */
#define IFM_IEEE80211_HT_MCS66	85	/* 11n MCS 66 */
#define IFM_IEEE80211_HT_MCS67	86	/* 11n MCS 67 */
#define IFM_IEEE80211_HT_MCS68	87	/* 11n MCS 68 */
#define IFM_IEEE80211_HT_MCS69	88	/* 11n MCS 69 */
#define IFM_IEEE80211_HT_MCS70	89	/* 11n MCS 70 */
#define IFM_IEEE80211_HT_MCS71	90	/* 11n MCS 71 */
#define IFM_IEEE80211_HT_MCS72	91	/* 11n MCS 72 */
#define IFM_IEEE80211_HT_MCS73	92	/* 11n MCS 73 */
#define IFM_IEEE80211_HT_MCS74	93	/* 11n MCS 74 */
#define IFM_IEEE80211_HT_MCS75	94	/* 11n MCS 75 */
#define IFM_IEEE80211_HT_MCS76	95	/* 11n MCS 76 */

#define	IFM_IEEE80211_ADHOC	0x0000000000010000ULL	/* Operate in Adhoc mode */
#define	IFM_IEEE80211_HOSTAP	0x0000000000020000ULL	/* Operate in Host AP mode */
#define	IFM_IEEE80211_IBSS	0x0000000000040000ULL	/* Operate in IBSS mode */
#define	IFM_IEEE80211_IBSSMASTER 0x0000000000080000ULL	/* Operate as an IBSS master */
#define	IFM_IEEE80211_MONITOR	0x0000000000100000ULL	/* Operate in Monitor mode */

/* operating mode for multi-mode devices */
#define IFM_IEEE80211_11A	0x0000000100000000ULL	/* 5GHz, OFDM mode */
#define IFM_IEEE80211_11B	0x0000000200000000ULL	/* Direct Sequence mode */
#define IFM_IEEE80211_11G	0x0000000300000000ULL	/* 2GHz, CCK mode */
#define IFM_IEEE80211_FH	0x0000000400000000ULL	/* 2GHz, GFSK mode */
#define IFM_IEEE80211_11N	0x0000000800000000ULL	/* 11n/HT 2GHz/5GHz */

/*
 * Digitally multiplexed "Carrier" Serial Interfaces
 */
#define	IFM_TDM		0x0000000000000500ULL
#define IFM_TDM_T1		3	/* T1 B8ZS+ESF 24 ts */
#define IFM_TDM_T1_AMI		4	/* T1 AMI+SF 24 ts */
#define IFM_TDM_E1		5	/* E1 HDB3+G.703 clearchannel 32 ts */
#define IFM_TDM_E1_G704		6	/* E1 HDB3+G.703+G.704 channelized 31 ts */
#define IFM_TDM_E1_AMI		7	/* E1 AMI+G.703 32 ts */
#define IFM_TDM_E1_AMI_G704	8	/* E1 AMI+G.703+G.704 31 ts */
#define IFM_TDM_T3		9	/* T3 B3ZS+C-bit 672 ts */
#define IFM_TDM_T3_M13		10	/* T3 B3ZS+M13 672 ts */
#define IFM_TDM_E3		11	/* E3 HDB3+G.751 512? ts */
#define IFM_TDM_E3_G751		12	/* E3 G.751 512 ts */
#define IFM_TDM_E3_G832		13	/* E3 G.832 512 ts */
#define IFM_TDM_E1_G704_CRC4	14	/* E1 HDB3+G.703+G.704 31 ts + CRC4 */
/*
 * 6 major ways that networks talk: Drivers enforce independent selection,
 * meaning, a driver will ensure that only one of these is set at a time.
 * Default is cisco hdlc mode with 32 bit CRC.
 */
#define IFM_TDM_HDLC_CRC16	0x0100	/* Use 16-bit CRC for HDLC instead */
#define IFM_TDM_PPP		0x0200	/* SPPP (dumb) */
#define IFM_TDM_FR_ANSI		0x0400	/* Frame Relay + LMI ANSI "Annex D" */
#define IFM_TDM_FR_CISCO	0x0800	/* Frame Relay + LMI Cisco */
#define IFM_TDM_FR_ITU		0x1000	/* Frame Relay + LMI ITU "Q933A" */

/* operating mode */
#define IFM_TDM_MASTER		0x0000000100000000ULL	/* aka clock source internal */

/*
 * Common Access Redundancy Protocol
 */
#define	IFM_CARP		0x0000000000000600ULL

/*
 * Shared media sub-types
 */
#define	IFM_AUTO	0ULL		/* Autoselect best media */
#define	IFM_MANUAL	1ULL		/* Jumper/dipswitch selects media */
#define	IFM_NONE	2ULL		/* Deselect all media */

/*
 * Shared options
 */
#define IFM_FDX		0x0000010000000000ULL	/* Force full duplex */
#define	IFM_HDX		0x0000020000000000ULL	/* Force half duplex */
#define	IFM_FLOW	0x0000040000000000ULL	/* enable hardware flow control */
#define IFM_FLAG0	0x0000100000000000ULL	/* Driver defined flag */
#define IFM_FLAG1	0x0000200000000000ULL	/* Driver defined flag */
#define IFM_FLAG2	0x0000400000000000ULL	/* Driver defined flag */
#define	IFM_LOOP	0x0000800000000000ULL	/* Put hardware in loopback */

/*
 * Masks
 */
#define	IFM_NMASK	0x000000000000ff00ULL	/* Network type */
#define	IFM_NSHIFT	8			/* Network type shift */
#define	IFM_TMASK	0x00000000000000ffULL	/* Media sub-type */
#define	IFM_TSHIFT	0			/* Sub-type shift */
#define	IFM_IMASK	0xff00000000000000ULL	/* Instance */
#define	IFM_ISHIFT	56			/* Instance shift */
#define	IFM_OMASK	0x00000000ffff0000ULL	/* Type specific options */
#define	IFM_OSHIFT	16			/* Specific options shift */
#define	IFM_MMASK	0x000000ff00000000ULL	/* Mode */
#define	IFM_MSHIFT	32			/* Mode shift */
#define	IFM_GMASK	0x00ffff0000000000ULL	/* Global options */
#define	IFM_GSHIFT	40			/* Global options shift */

/* Ethernet flow control mask */
#define	IFM_ETH_FMASK	(IFM_FLOW|IFM_ETH_RXPAUSE|IFM_ETH_TXPAUSE)

#define	IFM_NMIN	IFM_ETHER	/* lowest Network type */
#define	IFM_NMAX	IFM_NMASK	/* highest Network type */

/*
 * Status bits
 */
#define	IFM_AVALID	0x0000000000000001ULL	/* Active bit valid */
#define	IFM_ACTIVE	0x0000000000000002ULL	/* Interface attached to working net */

/* Mask of "status valid" bits, for ifconfig(8). */
#define	IFM_STATUS_VALID	IFM_AVALID

/* List of "status valid" bits, for ifconfig(8). */
#define	IFM_STATUS_VALID_LIST {						\
	IFM_AVALID,							\
	0								\
}

/*
 * Macros to extract various bits of information from the media word.
 */
#define	IFM_TYPE(x)	((x) & IFM_NMASK)
#define	IFM_SUBTYPE(x)	((x) & IFM_TMASK)
#define	IFM_INST(x)	(((x) & IFM_IMASK) >> IFM_ISHIFT)
#define	IFM_OPTIONS(x)	((x) & (IFM_OMASK|IFM_GMASK))
#define	IFM_MODE(x)	((x) & IFM_MMASK)

#define	IFM_INST_MAX	IFM_INST(IFM_IMASK)
#define	IFM_INST_ANY	((uint64_t) -1)

/*
 * Macro to create a media word.
 * All arguments are IFM_* macros, except 'instance' which is a 64-bit integer.
 * XXX 'operating mode' is not included here?!?
 */
#define	IFM_MAKEWORD(type, subtype, options, instance)			\
	((type) | (subtype) | (options) | \
	((uint64_t)(instance) << IFM_ISHIFT))

/*
 * NetBSD extension not defined in the BSDI API.  This is used in various
 * places to get the canonical description for a given type/subtype.
 *
 * In the subtype and mediaopt descriptions, the valid TYPE bits are OR'd
 * in to indicate which TYPE the subtype/option corresponds to.  If no
 * TYPE is present, it is a shared media/mediaopt.
 *
 * Note that these are parsed case-insensitive.
 *
 * Order is important.  The first matching entry is the canonical name
 * for a media type; subsequent matches are aliases.
 */
struct ifmedia_description {
	uint64_t	ifmt_word;	/* word value; may be masked */
	const char	*ifmt_string;	/* description */
};

#define	IFM_TYPE_DESCRIPTIONS {						\
	{ IFM_ETHER,			"Ethernet" },			\
	{ IFM_ETHER,			"ether" },			\
	{ IFM_FDDI,			"FDDI" },			\
	{ IFM_IEEE80211,		"IEEE802.11" },			\
	{ IFM_TDM,			"TDM" },			\
	{ IFM_CARP,			"CARP" },			\
	{ 0, NULL },							\
}

#define	IFM_TYPE_MATCH(dt, t)						\
	(IFM_TYPE((dt)) == 0 || IFM_TYPE((dt)) == IFM_TYPE((t)))

#define	IFM_SUBTYPE_DESCRIPTIONS {					\
	{ IFM_AUTO,			"autoselect" },			\
	{ IFM_AUTO,			"auto" },			\
	{ IFM_MANUAL,			"manual" },			\
	{ IFM_NONE,			"none" },			\
									\
	{ IFM_ETHER|IFM_10_T,		"10baseT" },			\
	{ IFM_ETHER|IFM_10_T,		"10baseT/UTP" },		\
	{ IFM_ETHER|IFM_10_T,		"UTP" },			\
	{ IFM_ETHER|IFM_10_T,		"10UTP" },			\
	{ IFM_ETHER|IFM_10_2,		"10base2" },			\
	{ IFM_ETHER|IFM_10_2,		"10base2/BNC" },		\
	{ IFM_ETHER|IFM_10_2,		"BNC" },			\
	{ IFM_ETHER|IFM_10_2,		"10BNC" },			\
	{ IFM_ETHER|IFM_10_5,		"10base5" },			\
	{ IFM_ETHER|IFM_10_5,		"10base5/AUI" },		\
	{ IFM_ETHER|IFM_10_5,		"AUI" },			\
	{ IFM_ETHER|IFM_10_5,		"10AUI" },			\
	{ IFM_ETHER|IFM_100_TX,		"100baseTX" },			\
	{ IFM_ETHER|IFM_100_TX,		"100TX" },			\
	{ IFM_ETHER|IFM_100_FX,		"100baseFX" },			\
	{ IFM_ETHER|IFM_100_FX,		"100FX" },			\
	{ IFM_ETHER|IFM_100_T4,		"100baseT4" },			\
	{ IFM_ETHER|IFM_100_T4,		"100T4" },			\
	{ IFM_ETHER|IFM_100_VG,		"100baseVG" },			\
	{ IFM_ETHER|IFM_100_VG,		"100VG" },			\
	{ IFM_ETHER|IFM_100_T2,		"100baseT2" },			\
	{ IFM_ETHER|IFM_100_T2,		"100T2" },			\
	{ IFM_ETHER|IFM_1000_SX,	"1000baseSX" },			\
	{ IFM_ETHER|IFM_1000_SX,	"1000SX" },			\
	{ IFM_ETHER|IFM_10_STP,		"10baseSTP" },			\
	{ IFM_ETHER|IFM_10_STP,		"STP" },			\
	{ IFM_ETHER|IFM_10_STP,		"10STP" },			\
	{ IFM_ETHER|IFM_10_FL,		"10baseFL" },			\
	{ IFM_ETHER|IFM_10_FL,		"FL" },				\
	{ IFM_ETHER|IFM_10_FL,		"10FL" },			\
	{ IFM_ETHER|IFM_1000_LX,	"1000baseLX" },			\
	{ IFM_ETHER|IFM_1000_LX,	"1000LX" },			\
	{ IFM_ETHER|IFM_1000_CX,	"1000baseCX" },			\
	{ IFM_ETHER|IFM_1000_CX,	"1000CX" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000baseT" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000T" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000baseTX" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000TX" },			\
	{ IFM_ETHER|IFM_HPNA_1,		"HomePNA1" },			\
	{ IFM_ETHER|IFM_HPNA_1,		"HPNA1" },			\
	{ IFM_ETHER|IFM_10G_LR,		"10GbaseLR" },			\
	{ IFM_ETHER|IFM_10G_LR,		"10GLR" },			\
	{ IFM_ETHER|IFM_10G_LR,		"10GBASE-LR" },			\
	{ IFM_ETHER|IFM_10G_SR,		"10GbaseSR" },			\
	{ IFM_ETHER|IFM_10G_SR,		"10GSR" },			\
	{ IFM_ETHER|IFM_10G_SR,		"10GBASE-SR" },			\
	{ IFM_ETHER|IFM_10G_CX4,	"10GbaseCX4" },			\
	{ IFM_ETHER|IFM_10G_CX4,	"10GCX4" },			\
	{ IFM_ETHER|IFM_10G_CX4,	"10GBASE-CX4" },		\
	{ IFM_ETHER|IFM_2500_SX,	"2500baseSX" },			\
	{ IFM_ETHER|IFM_2500_SX,	"2500SX" },			\
	{ IFM_ETHER|IFM_10G_T,		"10GbaseT" },			\
	{ IFM_ETHER|IFM_10G_T,		"10GT" },			\
	{ IFM_ETHER|IFM_10G_T,		"10GBASE-T" },			\
	{ IFM_ETHER|IFM_10G_SFP_CU,	"10GSFP+Cu" },			\
	{ IFM_ETHER|IFM_10G_SFP_CU,	"10GCu" },			\
	{ IFM_ETHER|IFM_10G_LRM,	"10GbaseLRM" },			\
	{ IFM_ETHER|IFM_10G_LRM,	"10GBASE-LRM" },		\
	{ IFM_ETHER|IFM_40G_CR4,	"40GbaseCR4" },			\
	{ IFM_ETHER|IFM_40G_CR4,	"40GBASE-CR4" },		\
	{ IFM_ETHER|IFM_40G_SR4,	"40GbaseSR4" },			\
	{ IFM_ETHER|IFM_40G_SR4,	"40GBASE-SR4" },		\
	{ IFM_ETHER|IFM_40G_LR4,	"40GbaseLR4" },			\
	{ IFM_ETHER|IFM_40G_LR4,	"40GBASE-LR4" },		\
	{ IFM_ETHER|IFM_1000_KX,	"1000base-KX" },		\
	{ IFM_ETHER|IFM_1000_KX,	"1000BASE-KX" },		\
	{ IFM_ETHER|IFM_10G_KX4,	"10GbaseKX4" },			\
	{ IFM_ETHER|IFM_10G_KX4,	"10GBASE-KX4" },		\
	{ IFM_ETHER|IFM_10G_KR,		"10GbaseKR" },			\
	{ IFM_ETHER|IFM_10G_KR,		"10GBASE-KR" },			\
	{ IFM_ETHER|IFM_10G_CR1,	"10GbaseCR1" },			\
	{ IFM_ETHER|IFM_10G_CR1,	"10GBASE-CR1" },		\
	{ IFM_ETHER|IFM_20G_KR2,	"20GbaseKR2" },			\
	{ IFM_ETHER|IFM_20G_KR2,	"20GBASE-KR2" },		\
	{ IFM_ETHER|IFM_2500_KX,	"2500baseKX" },			\
	{ IFM_ETHER|IFM_2500_KX,	"2500BASE-KX" },		\
	{ IFM_ETHER|IFM_2500_T,		"2500baseT" },			\
	{ IFM_ETHER|IFM_2500_T,		"2500BASE-T" },			\
	{ IFM_ETHER|IFM_5000_T,		"5000baseT" },			\
	{ IFM_ETHER|IFM_5000_T,		"5000BASE-T" },			\
	{ IFM_ETHER|IFM_1000_SGMII,	"1000base-SGMII" },		\
	{ IFM_ETHER|IFM_1000_SGMII,	"1000BASE-SGMII" },		\
	{ IFM_ETHER|IFM_10G_SFI,	"10GbaseSFI" },			\
	{ IFM_ETHER|IFM_10G_SFI,	"10GBASE-SFI" },		\
	{ IFM_ETHER|IFM_40G_XLPPI,	"40GbaseXLPPI" },		\
	{ IFM_ETHER|IFM_40G_XLPPI,	"40GBASE-XLPPI" },		\
	{ IFM_ETHER|IFM_1000_CX_SGMII,	"1000baseCX-SGMII" },		\
	{ IFM_ETHER|IFM_1000_CX_SGMII,	"1000BASE-CX-SGMII" },		\
	{ IFM_ETHER|IFM_40G_KR4,	"40GbaseKR4" },			\
	{ IFM_ETHER|IFM_40G_KR4,	"40GBASE-KR4" },		\
	{ IFM_ETHER|IFM_10G_ER,		"10GbaseER" },			\
	{ IFM_ETHER|IFM_10G_ER,		"10GBASE-ER" },			\
	{ IFM_ETHER|IFM_100G_CR4,	"100GbaseCR4" },		\
	{ IFM_ETHER|IFM_100G_CR4,	"100GBASE-CR4" },		\
	{ IFM_ETHER|IFM_100G_SR4,	"100GbaseSR4" },		\
	{ IFM_ETHER|IFM_100G_SR4,	"100GBASE-SR4" },		\
	{ IFM_ETHER|IFM_100G_KR4,	"100GbaseKR4" },		\
	{ IFM_ETHER|IFM_100G_KR4,	"100GBASE-KR4" },		\
	{ IFM_ETHER|IFM_100G_LR4,	"100GbaseLR4" },		\
	{ IFM_ETHER|IFM_100G_LR4,	"100GBASE-LR4" },		\
	{ IFM_ETHER|IFM_56G_R4,		"56GbaseR4" },			\
	{ IFM_ETHER|IFM_56G_R4,		"56GBASE-R4" },			\
	{ IFM_ETHER|IFM_25G_CR,		"25GbaseCR" },			\
	{ IFM_ETHER|IFM_25G_CR,		"25GBASE-CR" },			\
	{ IFM_ETHER|IFM_25G_KR,		"25GbaseKR" },			\
	{ IFM_ETHER|IFM_25G_KR,		"25GBASE-KR" },			\
	{ IFM_ETHER|IFM_25G_SR,		"25GbaseSR" },			\
	{ IFM_ETHER|IFM_25G_SR,		"25GBASE-SR" },			\
	{ IFM_ETHER|IFM_50G_CR2,	"50GbaseCR2" },			\
	{ IFM_ETHER|IFM_50G_CR2,	"50GBASE-CR2" },		\
	{ IFM_ETHER|IFM_50G_KR2,	"50GbaseKR2" },			\
	{ IFM_ETHER|IFM_50G_KR2,	"50GBASE-KR2" },		\
									\
	{ IFM_FDDI|IFM_FDDI_SMF,	"Single-mode" },		\
	{ IFM_FDDI|IFM_FDDI_SMF,	"SMF" },			\
	{ IFM_FDDI|IFM_FDDI_MMF,	"Multi-mode" },			\
	{ IFM_FDDI|IFM_FDDI_MMF,	"MMF" },			\
	{ IFM_FDDI|IFM_FDDI_UTP,	"UTP" },			\
	{ IFM_FDDI|IFM_FDDI_UTP,	"CDDI" },			\
									\
	{ IFM_IEEE80211|IFM_IEEE80211_FH1,	"FH1" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_FH2,	"FH2" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS2,	"DS2" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS5,	"DS5" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS11,	"DS11" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS1,	"DS1" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS22,	"DS22" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM6,	"OFDM6" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM9,	"OFDM9" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM12,	"OFDM12" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM18,	"OFDM18" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM24,	"OFDM24" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM36,	"OFDM36" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM48,	"OFDM48" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM54,	"OFDM54" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM72,	"OFDM72" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS0,	"HT-MCS0" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS1,	"HT-MCS1" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS2,	"HT-MCS2" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS3,	"HT-MCS3" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS4,	"HT-MCS4" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS5,	"HT-MCS5" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS6,	"HT-MCS6" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS7,	"HT-MCS7" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS8,	"HT-MCS8" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS9,	"HT-MCS9" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS10,	"HT-MCS10" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS11,	"HT-MCS11" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS12,	"HT-MCS12" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS13,	"HT-MCS13" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS14,	"HT-MCS14" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS15,	"HT-MCS15" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS16,	"HT-MCS16" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS17,	"HT-MCS17" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS18,	"HT-MCS18" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS19,	"HT-MCS19" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS20,	"HT-MCS20" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS21,	"HT-MCS21" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS22,	"HT-MCS22" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS23,	"HT-MCS23" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS24,	"HT-MCS24" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS25,	"HT-MCS25" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS26,	"HT-MCS26" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS27,	"HT-MCS27" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS28,	"HT-MCS28" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS29,	"HT-MCS29" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS30,	"HT-MCS30" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS31,	"HT-MCS31" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS32,	"HT-MCS32" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS33,	"HT-MCS33" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS34,	"HT-MCS34" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS35,	"HT-MCS35" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS36,	"HT-MCS36" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS37,	"HT-MCS37" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS38,	"HT-MCS38" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS39,	"HT-MCS39" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS40,	"HT-MCS40" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS41,	"HT-MCS41" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS42,	"HT-MCS42" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS43,	"HT-MCS43" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS44,	"HT-MCS44" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS45,	"HT-MCS45" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS46,	"HT-MCS46" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS47,	"HT-MCS47" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS48,	"HT-MCS48" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS49,	"HT-MCS49" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS50,	"HT-MCS50" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS51,	"HT-MCS51" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS52,	"HT-MCS52" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS53,	"HT-MCS53" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS54,	"HT-MCS54" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS55,	"HT-MCS55" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS56,	"HT-MCS56" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS57,	"HT-MCS57" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS58,	"HT-MCS58" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS59,	"HT-MCS59" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS60,	"HT-MCS60" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS61,	"HT-MCS61" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS62,	"HT-MCS62" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS63,	"HT-MCS63" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS64,	"HT-MCS64" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS65,	"HT-MCS65" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS66,	"HT-MCS66" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS67,	"HT-MCS67" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS68,	"HT-MCS68" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS69,	"HT-MCS69" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS70,	"HT-MCS70" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS71,	"HT-MCS71" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS72,	"HT-MCS72" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS73,	"HT-MCS73" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS74,	"HT-MCS74" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS75,	"HT-MCS75" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS76,	"HT-MCS76" },		\
									\
	{ IFM_TDM|IFM_TDM_T1,		"t1" },				\
	{ IFM_TDM|IFM_TDM_T1_AMI,	"t1-ami" },			\
	{ IFM_TDM|IFM_TDM_E1,		"e1" },				\
	{ IFM_TDM|IFM_TDM_E1_G704,	"e1-g.704" },			\
	{ IFM_TDM|IFM_TDM_E1_AMI,	"e1-ami" },			\
	{ IFM_TDM|IFM_TDM_E1_AMI_G704,	"e1-ami-g.704" },		\
	{ IFM_TDM|IFM_TDM_T3,		"t3" },				\
	{ IFM_TDM|IFM_TDM_T3_M13,	"t3-m13" },			\
	{ IFM_TDM|IFM_TDM_E3,		"e3" },				\
	{ IFM_TDM|IFM_TDM_E3_G751,	"e3-g.751" },			\
	{ IFM_TDM|IFM_TDM_E3_G832,	"e3-g.832" },			\
	{ IFM_TDM|IFM_TDM_E1_G704_CRC4,	"e1-g.704-crc4" },		\
									\
	{ 0, NULL },							\
}

#define IFM_MODE_DESCRIPTIONS {						\
	{ IFM_AUTO,				"autoselect" },		\
	{ IFM_AUTO,				"auto" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_11A,	"11a" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_11B,	"11b" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_11G,	"11g" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_FH,	"fh" },			\
	{ IFM_IEEE80211|IFM_IEEE80211_11N,	"11n" },		\
	{ IFM_TDM|IFM_TDM_MASTER,		"master" },		\
	{ 0, NULL },							\
}

#define	IFM_OPTION_DESCRIPTIONS {					\
	{ IFM_FDX,			"full-duplex" },		\
	{ IFM_FDX,			"fdx" },			\
	{ IFM_HDX,			"half-duplex" },		\
	{ IFM_HDX,			"hdx" },			\
	{ IFM_FLAG0,			"flag0" },			\
	{ IFM_FLAG1,			"flag1" },			\
	{ IFM_FLAG2,			"flag2" },			\
	{ IFM_LOOP,			"loopback" },			\
	{ IFM_LOOP,			"hw-loopback"},			\
	{ IFM_LOOP,			"loop" },			\
									\
	{ IFM_ETHER|IFM_ETH_MASTER,	"master" },			\
	{ IFM_ETHER|IFM_ETH_RXPAUSE,	"rxpause" },			\
	{ IFM_ETHER|IFM_ETH_TXPAUSE,	"txpause" },			\
									\
	{ IFM_FDDI|IFM_FDDI_DA,		"dual-attach" },		\
	{ IFM_FDDI|IFM_FDDI_DA,		"das" },			\
									\
	{ IFM_IEEE80211|IFM_IEEE80211_ADHOC,	"adhoc" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HOSTAP,	"hostap" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_IBSS,	"ibss" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_IBSSMASTER, "ibss-master" },	\
	{ IFM_IEEE80211|IFM_IEEE80211_MONITOR,	"monitor" },		\
									\
	{ IFM_TDM|IFM_TDM_HDLC_CRC16,	"hdlc-crc16" },			\
	{ IFM_TDM|IFM_TDM_PPP,		"ppp" },			\
	{ IFM_TDM|IFM_TDM_FR_ANSI,	"framerelay-ansi" },		\
	{ IFM_TDM|IFM_TDM_FR_CISCO,	"framerelay-cisco" },		\
	{ IFM_TDM|IFM_TDM_FR_ANSI,	"framerelay-itu" },		\
									\
	{ 0, NULL },							\
}

/*
 * Baudrate descriptions for the various media types.
 */
struct ifmedia_baudrate {
	uint64_t	ifmb_word;		/* media word */
	uint64_t	ifmb_baudrate;		/* corresponding baudrate */
};

#define	IFM_BAUDRATE_DESCRIPTIONS {					\
	{ IFM_ETHER|IFM_10_T,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_10_2,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_10_5,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_100_TX,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_100_FX,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_100_T4,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_100_VG,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_100_T2,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_1000_SX,	IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_10_STP,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_10_FL,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_1000_LX,	IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_1000_CX,	IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_1000_T,		IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_HPNA_1,		IF_Mbps(1) },			\
	{ IFM_ETHER|IFM_10G_LR,		IF_Gbps(10) },			\
	{ IFM_ETHER|IFM_10G_SR,		IF_Gbps(10) },			\
	{ IFM_ETHER|IFM_10G_CX4,	IF_Gbps(10) },			\
	{ IFM_ETHER|IFM_2500_SX,	IF_Mbps(2500) },		\
	{ IFM_ETHER|IFM_10G_T,		IF_Gbps(10) },			\
	{ IFM_ETHER|IFM_10G_SFP_CU,	IF_Gbps(10) },			\
									\
	{ IFM_FDDI|IFM_FDDI_SMF,	IF_Mbps(100) },			\
	{ IFM_FDDI|IFM_FDDI_MMF,	IF_Mbps(100) },			\
	{ IFM_FDDI|IFM_FDDI_UTP,	IF_Mbps(100) },			\
									\
	{ IFM_IEEE80211|IFM_IEEE80211_FH1, IF_Mbps(1) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_FH2, IF_Mbps(2) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS1, IF_Mbps(1) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS2, IF_Mbps(2) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS5, IF_Mbps(5) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS11, IF_Mbps(11) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS22, IF_Mbps(22) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM6, IF_Mbps(6) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM9, IF_Mbps(9) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM12, IF_Mbps(12) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM18, IF_Mbps(18) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM24, IF_Mbps(24) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM36, IF_Mbps(36) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM48, IF_Mbps(48) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM54, IF_Mbps(54) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_OFDM72, IF_Mbps(72) },		\
	/* These HT rates correspond to 20 MHz channel with no SGI. */	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS0, IF_Kbps(6500) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS1, IF_Mbps(13) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS2, IF_Kbps(19500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS3, IF_Mbps(26) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS4, IF_Mbps(39) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS5, IF_Mbps(52) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS6, IF_Kbps(58500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS7, IF_Mbps(65) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS8, IF_Mbps(13) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS9, IF_Mbps(26) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS10, IF_Mbps(39) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS11, IF_Mbps(52) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS12, IF_Mbps(78) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS13, IF_Mbps(104) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS14, IF_Mbps(117) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS15, IF_Mbps(130) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS16, IF_Kbps(19500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS17, IF_Mbps(39) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS18, IF_Kbps(58500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS19, IF_Mbps(78) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS20, IF_Mbps(117) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS21, IF_Mbps(156) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS22, IF_Kbps(175500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS23, IF_Mbps(195) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS24, IF_Mbps(26) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS25, IF_Mbps(52) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS26, IF_Mbps(78) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS27, IF_Mbps(104) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS28, IF_Mbps(156) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS29, IF_Mbps(208) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS30, IF_Mbps(234) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS31, IF_Mbps(260) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS32, IF_Mbps(0) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS33, IF_Mbps(39) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS34, IF_Mbps(52) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS35, IF_Mbps(65) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS36, IF_Kbps(58500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS37, IF_Mbps(78) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS38, IF_Kbps(97500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS39, IF_Mbps(52) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS40, IF_Mbps(65) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS41, IF_Mbps(65) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS42, IF_Mbps(78) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS43, IF_Mbps(91) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS44, IF_Mbps(91) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS45, IF_Mbps(104) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS46, IF_Mbps(78) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS47, IF_Kbps(97500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS48, IF_Kbps(97500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS49, IF_Mbps(117) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS50, IF_Kbps(136500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS51, IF_Kbps(136500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS52, IF_Mbps(156) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS53, IF_Mbps(65) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS54, IF_Mbps(78) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS55, IF_Mbps(91) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS56, IF_Mbps(78) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS57, IF_Mbps(91) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS58, IF_Mbps(104) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS59, IF_Mbps(117) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS60, IF_Mbps(104) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS61, IF_Mbps(117) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS62, IF_Mbps(130) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS63, IF_Mbps(130) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS64, IF_Mbps(143) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS65, IF_Kbps(97500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS66, IF_Mbps(117) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS67, IF_Kbps(136500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS68, IF_Mbps(117) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS69, IF_Kbps(136500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS70, IF_Mbps(156) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS71, IF_Kbps(175500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS72, IF_Mbps(156) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS73, IF_Kbps(175500) },	\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS74, IF_Mbps(195) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS75, IF_Mbps(195) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_HT_MCS76, IF_Kbps(214500) },	\
									\
	{ IFM_TDM|IFM_TDM_T1,		IF_Kbps(1536) },		\
	{ IFM_TDM|IFM_TDM_T1_AMI,	IF_Kbps(1536) },		\
	{ IFM_TDM|IFM_TDM_E1,		IF_Kbps(2048) },		\
	{ IFM_TDM|IFM_TDM_E1_G704,	IF_Kbps(2048) },		\
	{ IFM_TDM|IFM_TDM_E1_AMI,	IF_Kbps(2048) },		\
	{ IFM_TDM|IFM_TDM_E1_AMI_G704,	IF_Kbps(2048) },		\
	{ IFM_TDM|IFM_TDM_T3,		IF_Kbps(44736) },		\
	{ IFM_TDM|IFM_TDM_T3_M13,	IF_Kbps(44736) },		\
	{ IFM_TDM|IFM_TDM_E3,		IF_Kbps(34368) },		\
	{ IFM_TDM|IFM_TDM_E3_G751,	IF_Kbps(34368) },		\
	{ IFM_TDM|IFM_TDM_E3_G832,	IF_Kbps(34368) },		\
	{ IFM_TDM|IFM_TDM_E1_G704_CRC4,	IF_Kbps(2048) },		\
									\
	{ 0, 0 },							\
}

/*
 * Status bit descriptions for the various media types.
 */
struct ifmedia_status_description {
	uint64_t	ifms_type;
	uint64_t	ifms_valid;
	uint64_t	ifms_bit;
	const char *ifms_string[2];
};

#define	IFM_STATUS_DESC(ifms, bit)					\
	(ifms)->ifms_string[((ifms)->ifms_bit & (bit)) ? 1 : 0]

#define	IFM_STATUS_DESCRIPTIONS {					\
	{ IFM_ETHER,		IFM_AVALID,	IFM_ACTIVE,		\
	    { "no carrier", "active" } },				\
	{ IFM_FDDI,		IFM_AVALID,	IFM_ACTIVE,		\
	    { "no ring", "inserted" } },				\
	{ IFM_IEEE80211,	IFM_AVALID,	IFM_ACTIVE,		\
	    { "no network", "active" } },				\
	{ IFM_TDM,		IFM_AVALID,	IFM_ACTIVE,		\
	    { "no carrier", "active" } },				\
	{ IFM_CARP,		IFM_AVALID,	IFM_ACTIVE,		\
	    { "backup", "master" } },					\
	{ 0,			0,		0,			\
	    { NULL, NULL } }						\
}
#endif	/* _NET_IF_MEDIA_H_ */
@


1.38
log
@fix typo (bas->base), "please commit" mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.37 2016/12/13 21:06:28 mikeb Exp $	*/
d799 1
a799 1
	/* These HT rates correspond to 20 MHz channel with no SGI. */ 	\
@


1.37
log
@New media types from FreeBSD

No objections from deraadt@@, OK dlg
Thanks to stsp@@ who has extended ifm_media field to 64 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.36 2016/01/12 09:28:09 stsp Exp $	*/
d536 1
a536 1
	{ IFM_ETHER|IFM_1000_KX,	"1000bas-KX" },			\
@


1.36
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.35 2015/11/15 00:17:47 stsp Exp $	*/
d171 28
d528 56
@


1.35
log
@Add ifmedia definitions for 802.11n.
ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.34 2015/09/11 13:02:28 stsp Exp $	*/
a287 1
#define	IFM_IEEE80211_TURBO	0x0000000000200000ULL	/* Operate in Turbo mode */
a653 1
	{ IFM_IEEE80211|IFM_IEEE80211_TURBO,	"turbo" },		\
@


1.34
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.33 2015/09/09 15:57:15 stsp Exp $	*/
d205 77
d295 1
d525 77
d626 1
d717 78
@


1.33
log
@Remove IFM_MAKEMODE. It is unused in base and ports and there doesn't seem
to be a way of feeding it with a valid argument without peeking into the
internals of ifmedia macros.
ok mpi miod deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.32 2014/12/05 15:50:04 mpi Exp $	*/
a70 12
/*
 * Prototypes and definitions for BSD/OS-compatible network interface
 * media selection.
 *
 * Where it is safe to do so, this code strays slightly from the BSD/OS
 * design.  Software which uses the API (device drivers, basically)
 * shouldn't notice any difference.
 *
 * Many thanks to Matt Thomas for providing the information necessary
 * to implement this interface.
 */

d87 1
a87 1
	u_int	ifm_media;	/* description of this media attachment */
d97 2
a98 2
	u_int	ifm_mask;	/* mask of changes we don't care about */
	u_int	ifm_media;	/* current user-set media word */
d106 1
a106 1
void	ifmedia_init(struct ifmedia *, int, ifm_change_cb_t,
d110 1
a110 1
void	ifmedia_add(struct ifmedia *, int, int, void *);
d117 1
a117 1
void	ifmedia_set(struct ifmedia *, int);
d124 1
a124 1
struct	ifmedia_entry *ifmedia_match(struct ifmedia *, u_int, u_int);
d127 1
a127 1
void	ifmedia_delete_instance(struct ifmedia *, u_int);
d130 1
a130 1
u_int64_t	ifmedia_baudrate(int);
d137 6
a142 6
 *	0-4	Media subtype		MAX SUBTYPE == 31!
 *	5-7	Media type
 *	8-15	Type specific options
 *	16-19	RFU
 *	20-27	Shared (global) options
 *	28-31	Instance
d148 1
a148 1
#define IFM_ETHER	0x00000020
d172 3
a174 3
#define	IFM_ETH_MASTER	0x00000100	/* master mode (1000baseT) */
#define	IFM_ETH_RXPAUSE	0x00000200	/* receive PAUSE frames */
#define	IFM_ETH_TXPAUSE	0x00000400	/* transmit PAUSE frames */
d179 1
a179 1
#define	IFM_FDDI	0x00000060
d188 1
a188 1
#define	IFM_IEEE80211	0x00000080
d206 6
a211 6
#define	IFM_IEEE80211_ADHOC	0x100	/* Operate in Adhoc mode */
#define	IFM_IEEE80211_HOSTAP	0x200	/* Operate in Host AP mode */
#define	IFM_IEEE80211_IBSS	0x400	/* Operate in IBSS mode */
#define	IFM_IEEE80211_IBSSMASTER 0x800	/* Operate as an IBSS master */
#define	IFM_IEEE80211_MONITOR	0x1000	/* Operate in Monitor mode */
#define	IFM_IEEE80211_TURBO	0x2000	/* Operate in Turbo mode */
d214 4
a217 4
#define IFM_IEEE80211_11A	0x00010000	/* 5GHz, OFDM mode */
#define IFM_IEEE80211_11B	0x00020000	/* Direct Sequence mode */
#define IFM_IEEE80211_11G	0x00030000	/* 2GHz, CCK mode */
#define IFM_IEEE80211_FH	0x00040000	/* 2GHz, GFSK mode */
d222 1
a222 1
#define	IFM_TDM		0x000000a0
d247 1
a247 1
#define IFM_TDM_MASTER		0x00010000	/* aka clock source internal */
d252 1
a252 1
#define	IFM_CARP		0x000000c0
d257 3
a259 3
#define	IFM_AUTO	0		/* Autoselect best media */
#define	IFM_MANUAL	1		/* Jumper/dipswitch selects media */
#define	IFM_NONE	2		/* Deselect all media */
d264 7
a270 7
#define IFM_FDX		0x00100000	/* Force full duplex */
#define	IFM_HDX		0x00200000	/* Force half duplex */
#define	IFM_FLOW	0x00400000	/* enable hardware flow control */
#define IFM_FLAG0	0x01000000	/* Driver defined flag */
#define IFM_FLAG1	0x02000000	/* Driver defined flag */
#define IFM_FLAG2	0x04000000	/* Driver defined flag */
#define	IFM_LOOP	0x08000000	/* Put hardware in loopback */
d275 12
a286 8
#define	IFM_NMASK	0x000000e0	/* Network type */
#define	IFM_TMASK	0x0000001f	/* Media sub-type */
#define	IFM_IMASK	0xf0000000	/* Instance */
#define	IFM_ISHIFT	28		/* Instance shift */
#define	IFM_OMASK	0x0000ff00	/* Type specific options */
#define	IFM_MMASK	0x00070000	/* Mode */
#define	IFM_MSHIFT	16		/* Mode shift */
#define	IFM_GMASK	0x0ff00000	/* Global options */
d297 2
a298 2
#define	IFM_AVALID	0x00000001	/* Active bit valid */
#define	IFM_ACTIVE	0x00000002	/* Interface attached to working net */
d319 1
a319 1
#define	IFM_INST_ANY	((u_int) -1)
d323 2
d327 2
a328 1
	((type) | (subtype) | (options) | ((instance) << IFM_ISHIFT))
d344 2
a345 2
	int	ifmt_word;		/* word value; may be masked */
	const char *ifmt_string;	/* description */
d514 2
a515 2
	int	ifmb_word;		/* media word */
	u_int64_t	ifmb_baudrate;		/* corresponding baudrate */
d582 3
a584 3
	int	ifms_type;
	int	ifms_valid;
	int	ifms_bit;
@


1.32
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.31 2010/02/09 13:18:04 claudio Exp $	*/
d334 1
a334 2
#define IFM_MAKEMODE(mode)						\
	(((mode) << IFM_MSHIFT) & IFM_MMASK)
@


1.31
log
@Add 10GSFP+Cu to the Ethernet media types. This is for 10G direct attached
cables. OK jsg@@, krw@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.30 2009/11/02 22:31:50 sobrado Exp $	*/
d85 2
a87 1

@


1.30
log
@s/hz/Hz/ on multiples of the SI unit hertz other than MHz.

reminded by STeve Andre.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.29 2008/06/26 05:42:20 ray Exp $	*/
d181 1
d426 2
d544 1
@


1.29
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.28 2008/06/19 08:39:33 reyk Exp $	*/
d224 1
a224 1
#define IFM_IEEE80211_11A	0x00010000	/* 5Ghz, OFDM mode */
d226 2
a227 2
#define IFM_IEEE80211_11G	0x00030000	/* 2Ghz, CCK mode */
#define IFM_IEEE80211_FH	0x00040000	/* 2Ghz, GFSK mode */
@


1.28
log
@add 10GbaseT media type, 10 Gigabit Ethernet over CAT 6 unshielded or
shielded twisted pair cables. this is an upcoming standard.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.27 2007/10/05 19:28:26 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.27
log
@add a 2.5 Gbps fiber media type.

From FreeBSD

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.26 2007/09/19 03:50:25 brad Exp $	*/
d187 1
d429 3
d547 1
@


1.26
log
@Use the proper baudrate for 10Gb hw now that it can fit into the buadrate
field.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.25 2007/09/17 17:34:22 brad Exp $	*/
d186 1
d426 2
d542 1
@


1.25
log
@- Use a 64-bit int for the baudrate within the ifmedia_baudrate struct and
return a 64-bit int for ifmedia_baudrate().
- Fix consumers of ifmedia_baudrate() to deal with the change.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.24 2007/05/29 22:11:57 henning Exp $	*/
d536 3
a538 3
	{ IFM_ETHER|IFM_10G_LR,		IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_10G_SR,		IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_10G_CX4,	IF_Mbps(1000) },		\
@


1.24
log
@remove token ring leftovers, ok mcbride pval
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.23 2006/12/29 20:06:31 kettenis Exp $	*/
d148 1
a148 1
int	ifmedia_baudrate(int);
d517 1
a517 1
	int	ifmb_baudrate;		/* corresponding baudrate */
@


1.23
log
@Add IFM_ETH_FMASK.  From NetBSD.

Requested by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.22 2006/12/27 12:00:17 kettenis Exp $	*/
a191 12
 * Token ring
 */
#define	IFM_TOKEN	0x00000040
#define	IFM_TOK_STP4	3		/* Shielded twisted pair 4m - DB9 */
#define	IFM_TOK_STP16	4		/* Shielded twisted pair 16m - DB9 */
#define	IFM_TOK_UTP4	5		/* Unshielded twisted pair 4m - RJ45 */
#define	IFM_TOK_UTP16	6		/* Unshielded twisted pair 16m - RJ45 */
#define	IFM_TOK_ETR	0x00000200	/* Early token release */
#define	IFM_TOK_SRCRT	0x00000400	/* Enable source routing features */
#define	IFM_TOK_ALLR	0x00000800	/* All routes / Single route bcast */

/*
a359 2
	{ IFM_TOKEN,			"TokenRing" },			\
	{ IFM_TOKEN,			"token" },			\
a425 9
	{ IFM_TOKEN|IFM_TOK_STP4,	"DB9/4Mbit" },			\
	{ IFM_TOKEN|IFM_TOK_STP4,	"4STP" },			\
	{ IFM_TOKEN|IFM_TOK_STP16,	"DB9/16Mbit" },			\
	{ IFM_TOKEN|IFM_TOK_STP16,	"16STP" },			\
	{ IFM_TOKEN|IFM_TOK_UTP4,	"UTP/4Mbit" },			\
	{ IFM_TOKEN|IFM_TOK_UTP4,	"4UTP" },			\
	{ IFM_TOKEN|IFM_TOK_UTP16,	"UTP/16Mbit" },			\
	{ IFM_TOKEN|IFM_TOK_UTP16,	"16UTP" },			\
									\
a492 7
	{ IFM_TOKEN|IFM_TOK_ETR,	"EarlyTokenRelease" },		\
	{ IFM_TOKEN|IFM_TOK_ETR,	"ETR" },			\
	{ IFM_TOKEN|IFM_TOK_SRCRT,	"SourceRouting" },		\
	{ IFM_TOKEN|IFM_TOK_SRCRT,	"SRCRT" },			\
	{ IFM_TOKEN|IFM_TOK_ALLR,	"AllRoutes" },			\
	{ IFM_TOKEN|IFM_TOK_ALLR,	"ALLR" },			\
									\
a539 5
	{ IFM_TOKEN|IFM_TOK_STP4,	IF_Mbps(4) },			\
	{ IFM_TOKEN|IFM_TOK_STP16,	IF_Mbps(16) },			\
	{ IFM_TOKEN|IFM_TOK_UTP4,	IF_Mbps(4) },			\
	{ IFM_TOKEN|IFM_TOK_UTP16,	IF_Mbps(16) },			\
									\
a593 2
	    { "no ring", "inserted" } },				\
	{ IFM_TOKEN,		IFM_AVALID,	IFM_ACTIVE,		\
@


1.22
log
@Add IFM_ETH_RXPAUSE and IFM_ETH_TXPAUSE.  From NetBSD.

ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.21 2006/06/21 07:08:41 brad Exp $	*/
d310 3
@


1.21
log
@add media types for 10Gb Ethernet, though only using a baudrate
of 1Gbps, until the size of the baudrate field has been increased.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.20 2005/08/10 15:10:35 claudio Exp $	*/
d188 2
d510 2
@


1.20
log
@kill spaces OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.19 2005/08/10 08:45:11 claudio Exp $	*/
d183 3
d425 9
d559 3
@


1.19
log
@Add an additional media subtype IFM_TDM_E1_G704_CRC4 for TDM interfaces.
This makes it possible to distinguish between E1 G.704 mode with and without
CRC4 checksum. Also add an operating mode IFM_TDM_MASTER to specify that
the card has to provide the clock source for the line.
OK deraadt@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.18 2005/07/05 01:48:50 brad Exp $	*/
d217 10
a226 10
#define IFM_IEEE80211_DS22      9	/* Direct Sequence 22Mbps */ 
#define IFM_IEEE80211_OFDM6     10	/* OFDM 6Mbps */
#define IFM_IEEE80211_OFDM9     11	/* OFDM 9Mbps */
#define IFM_IEEE80211_OFDM12    12	/* OFDM 12Mbps */
#define IFM_IEEE80211_OFDM18    13	/* OFDM 18Mbps */
#define IFM_IEEE80211_OFDM24    14	/* OFDM 24Mbps */
#define IFM_IEEE80211_OFDM36    15	/* OFDM 36Mbps */
#define IFM_IEEE80211_OFDM48    16	/* OFDM 48Mbps */
#define IFM_IEEE80211_OFDM54    17	/* OFDM 54Mbps */
#define IFM_IEEE80211_OFDM72    18	/* OFDM 72Mbps */
d245 1
a245 1
#define IFM_TDM_T1		3	/* T1 B8ZS+ESF 24 ts  */
d340 3
a342 3
    ((type) | (subtype) | (options) | ((instance) << IFM_ISHIFT))
#define IFM_MAKEMODE(mode)                                              \
           (((mode) << IFM_MSHIFT) & IFM_MMASK)
d472 7
a478 7
#define IFM_MODE_DESCRIPTIONS {                                         \
        { IFM_AUTO,                             "autoselect" },         \
        { IFM_AUTO,                             "auto" },               \
        { IFM_IEEE80211|IFM_IEEE80211_11A,      "11a" },                \
        { IFM_IEEE80211|IFM_IEEE80211_11B,      "11b" },                \
        { IFM_IEEE80211|IFM_IEEE80211_11G,      "11g" },                \
        { IFM_IEEE80211|IFM_IEEE80211_FH,       "fh" },                 \
d480 1
a480 1
        { 0, NULL },                                                    \
@


1.18
log
@- prototype must not have variable name.

From itojun NetBSD

- Fix signed/unsigned comparison warnings.
- Make ifm_data unsigned.
- Make media and mask unsigned.

From thorpej NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.17 2004/11/02 02:12:16 reyk Exp $	*/
d256 1
d260 1
d268 3
d467 1
d479 1
d585 1
@


1.17
log
@added new commands to ifconfig used by net80211 interfaces:
mode (set mode for multi-mode interfaces) and chan (set the radio channel).
some additional output will be printed by "ifconfig -m".

ok deraadt@@ millert@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.16 2004/10/28 20:35:44 henning Exp $	*/
d97 2
a98 2
typedef	int (*ifm_change_cb_t)(struct ifnet *ifp);
typedef	void (*ifm_stat_cb_t)(struct ifnet *ifp, struct ifmediareq *req);
d105 2
a106 2
	int	ifm_media;	/* description of this media attachment */
	int	ifm_data;	/* for driver-specific use */
d115 2
a116 2
	int	ifm_mask;	/* mask of changes we don't care about */
	int	ifm_media;	/* current user-set media word */
d124 2
a125 2
void	ifmedia_init(struct ifmedia *ifm, int dontcare_mask,
	    ifm_change_cb_t change_callback, ifm_stat_cb_t status_callback);
d128 1
a128 1
void	ifmedia_add(struct ifmedia *ifm, int mword, int data, void *aux);
d131 2
a132 2
void	ifmedia_list_add(struct ifmedia *mp, struct ifmedia_entry *lp,
	    int count);
d135 1
a135 1
void	ifmedia_set(struct ifmedia *ifm, int mword);
d138 2
a139 2
int	ifmedia_ioctl(struct ifnet *ifp, struct ifreq *ifr,
	    struct ifmedia *ifm, u_long cmd);
d142 1
a142 2
struct	ifmedia_entry *ifmedia_match(struct ifmedia *ifm,
	     int flags, int mask);
d145 1
a145 1
void	ifmedia_delete_instance(struct ifmedia *, int);
d329 1
a329 1
#define	IFM_INST_ANY	(-1)
@


1.16
log
@media descriptions and such for carp, ryan daniel ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.15 2004/10/07 22:21:20 brad Exp $	*/
d337 2
a338 1

a436 1
	{ IFM_IEEE80211|IFM_IEEE80211_DS1,	"DS1" },		\
d440 1
d467 10
d506 1
d553 1
d557 10
a566 1
	{ IFM_IEEE80211|IFM_IEEE80211_DS1, IF_Mbps(1) },		\
@


1.15
log
@Add an Ethernet option bit for master mode (for 1000baseT, the link
master provides the clock -- this is normally the switch, but if you
are doing back-to-back NICs, you need to tell one side to be the master).

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.14 2004/06/27 03:44:50 millert Exp $	*/
d268 5
d364 1
d585 2
@


1.14
log
@Media support for the 802.11 framework, missing in that commit the other day.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.13 2004/06/19 16:01:42 deraadt Exp $	*/
d185 2
d471 2
@


1.13
log
@starting TDM T1->E3->whatever media interface model we will attempt
to program to over the next week; thanks for feedback in developing
this from cedric, claudio, chris, alex
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.12 2003/08/24 12:23:57 fgsch Exp $	*/
d216 11
d232 7
d291 2
d320 1
d432 10
@


1.12
log
@defines and struct for the ieee80211 framework; deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.10 2002/04/10 19:25:07 millert Exp $	*/
d223 25
d335 1
d412 12
d455 6
d505 12
d542 2
@


1.11
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d220 1
d415 1
@


1.10
log
@o Add ibss and ibss-master mediaopt for ifconfig
o Map port type 4 to ibss regardless of firmware type.  This gives
us a consistent way to set ibss mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.9 2002/03/28 18:23:07 mickey Exp $	*/
d181 2
a182 1
#define	IFM_1000_TX	16		/* 1000baseTX - 4 pair cat 5 */
d355 4
a358 2
	{ IFM_ETHER|IFM_1000_TX,	"1000baseTX" },			\
	{ IFM_ETHER|IFM_1000_TX,	"1000TX" },			\
d440 1
a440 1
	{ IFM_ETHER|IFM_1000_TX,	IF_Mbps(1000) },		\
@


1.9
log
@i forgot these for if_wi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.8 2002/03/14 01:27:09 millert Exp $	*/
d217 2
d409 2
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.7 2000/08/26 20:04:16 nate Exp $	*/
d216 1
d406 1
@


1.7
log
@sync mii code with netbsd
adds detach functionality for phys
some code cleanup

Nobody really had time to test all of this out, but theo said commit anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.6 2000/03/21 23:18:13 mickey Exp $	*/
d97 2
a98 2
typedef	int (*ifm_change_cb_t) __P((struct ifnet *ifp));
typedef	void (*ifm_stat_cb_t) __P((struct ifnet *ifp, struct ifmediareq *req));
d124 2
a125 2
void	ifmedia_init __P((struct ifmedia *ifm, int dontcare_mask,
	    ifm_change_cb_t change_callback, ifm_stat_cb_t status_callback));
d128 1
a128 1
void	ifmedia_add __P((struct ifmedia *ifm, int mword, int data, void *aux));
d135 1
a135 1
void	ifmedia_set __P((struct ifmedia *ifm, int mword));
d138 2
a139 2
int	ifmedia_ioctl __P((struct ifnet *ifp, struct ifreq *ifr,
	    struct ifmedia *ifm, u_long cmd));
d142 2
a143 2
struct	ifmedia_entry *ifmedia_match __P((struct ifmedia *ifm,
	     int flags, int mask));
d146 1
a146 1
void	ifmedia_delete_instance __P((struct ifmedia *, int));
d149 1
a149 1
int	ifmedia_baudrate __P((int));
@


1.7.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.7 2000/08/26 20:04:16 nate Exp $	*/
d97 2
a98 2
typedef	int (*ifm_change_cb_t)(struct ifnet *ifp);
typedef	void (*ifm_stat_cb_t)(struct ifnet *ifp, struct ifmediareq *req);
d124 2
a125 2
void	ifmedia_init(struct ifmedia *ifm, int dontcare_mask,
	    ifm_change_cb_t change_callback, ifm_stat_cb_t status_callback);
d128 1
a128 1
void	ifmedia_add(struct ifmedia *ifm, int mword, int data, void *aux);
d135 1
a135 1
void	ifmedia_set(struct ifmedia *ifm, int mword);
d138 2
a139 2
int	ifmedia_ioctl(struct ifnet *ifp, struct ifreq *ifr,
	    struct ifmedia *ifm, u_long cmd);
d142 2
a143 2
struct	ifmedia_entry *ifmedia_match(struct ifmedia *ifm,
	     int flags, int mask);
d146 1
a146 1
void	ifmedia_delete_instance(struct ifmedia *, int);
d149 1
a149 1
int	ifmedia_baudrate(int);
a215 3
#define	IFM_IEEE80211_HOSTAP	0x200	/* Operate in Host AP mode */
#define	IFM_IEEE80211_IBSS	0x400	/* Operate in IBSS mode */
#define	IFM_IEEE80211_IBSSMASTER 0x800	/* Operate as an IBSS master */
a404 3
	{ IFM_IEEE80211|IFM_IEEE80211_HOSTAP,	"hostap" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_IBSS,	"ibss" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_IBSSMASTER, "ibss-master" },	\
@


1.7.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d181 1
a181 2
#define	IFM_1000_T	16		/* 1000baseT - 4 pair cat 5 */
#define	IFM_1000_TX	IFM_1000_T	/* for backwards compatibility */
d354 2
a355 4
	{ IFM_ETHER|IFM_1000_T,		"1000baseT" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000T" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000baseTX" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000TX" },			\
d437 1
a437 1
	{ IFM_ETHER|IFM_1000_T,		IF_Mbps(1000) },		\
@


1.6
log
@small knits in .c, more media definitions from netbsd in .h
@
text
@d1 2
a2 2
/*	$OpenBSD: if_media.h,v 1.5 2000/02/26 01:16:30 mickey Exp $	*/
/*	$NetBSD: if_media.h,v 1.11 1998/08/12 23:23:29 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d104 1
a104 1
	LIST_ENTRY(ifmedia_entry) ifm_list;
d118 1
a118 1
	LIST_HEAD(, ifmedia_entry) ifm_list; /* list of all supported media */
d148 2
d156 1
a156 1
 *	0-4	Media variant		MAX SUBTYPE == 31!
d176 1
a176 1
#define	IFM_1000_FX	11		/* 1000BaseFX - gigabit over fiber */
d179 4
a182 5
#define	IFM_1000_SX	14		/* 1000baseSX Multi-mode Fiber */
#define	IFM_1000_LX	15		/* 1000baseLX Single-mode Fiber */
#define	IFM_1000_CX	16		/* 1000baseCX 150ohm STP */
#define	IFM_1000_TX	17		/* 1000baseTX 4 pair cat 5 */
#define	IFM_HPNA_1	18		/* HomePNA 1.0 (1Mb/s) */
d339 2
a340 2
	{ IFM_ETHER|IFM_1000_FX,	"1000baseFX" },			\
	{ IFM_ETHER|IFM_1000_FX,	"1000FX" },			\
a346 1
	{ IFM_ETHER|IFM_1000_SX,	"1000baseSX" },			\
d348 1
d350 1
d352 1
d407 44
@


1.5
log
@use LIST_* macros where appropriate instead of using LIST* internals.
From netbsd
add 802.11 media types and options
add ifmedia_delete_instance() to be used in *detach() routines.
a few minor knits.
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.4 2000/02/18 14:42:06 jason Exp $	*/
d213 1
d228 1
d253 9
d371 1
d406 25
@


1.4
log
@From NetBSD:
Bump media variant bits and alter IFM_TMASK accordingly
Add IFM_HPNA_1 (HomePNA 1.0)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.3 2000/01/08 05:28:38 jason Exp $	*/
d145 3
d205 11
d260 1
d292 1
d358 6
d388 2
@


1.3
log
@expose ifmedia_match
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.2 1999/07/21 19:55:59 jason Exp $	*/
d151 1
a151 2
 *	0-3	Media variant
 *	4	RFU
d178 1
d222 1
a222 1
#define	IFM_TMASK	0x0000000f	/* Media sub-type */
d323 2
@


1.3.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.4 2000/02/18 14:42:06 jason Exp $	*/
d151 2
a152 1
 *	0-4	Media variant		MAX SUBTYPE == 31!
a178 1
#define	IFM_HPNA_1	18		/* HomePNA 1.0 (1Mb/s) */
d222 1
a222 1
#define	IFM_TMASK	0x0000001f	/* Media sub-type */
a322 2
	{ IFM_ETHER|IFM_HPNA_1,		"HomePNA1" },			\
	{ IFM_ETHER|IFM_HPNA_1,		"HPNA1" },			\
@


1.3.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a144 3
/* Delete all media for a given media instance */
void	ifmedia_delete_instance __P((struct ifmedia *, int));

a201 11
 * IEEE 802.11 Wireless
 */
#define	IFM_IEEE80211	0x00000080
#define	IFM_IEEE80211_FH1	3	/* Frequency Hopping 1Mbps */
#define	IFM_IEEE80211_FH2	4	/* Frequency Hopping 2Mbps */
#define	IFM_IEEE80211_DS2	5	/* Direct Sequence 2Mbps */
#define	IFM_IEEE80211_DS5	6	/* Direct Sequence 5Mbps*/
#define	IFM_IEEE80211_DS11	7	/* Direct Sequence 11Mbps*/
#define	IFM_IEEE80211_ADHOC	0x100	/* Operate in Adhoc mode */

/*
a245 1
#define	IFM_INST_ANY	(-1)
a276 1
	{ IFM_IEEE80211,		"IEEE802.11" },			\
a341 6
	{ IFM_IEEE80211|IFM_IEEE80211_FH1,	"FH1" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_FH2,	"FH2" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS2,	"DS2" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS5,	"DS5" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS11,	"DS11" },		\
									\
a365 2
									\
	{ IFM_IEEE80211|IFM_IEEE80211_ADHOC,	"adhoc" },		\
@


1.3.2.3
log
@Sync with -current
@
text
@a212 1
#define	IFM_IEEE80211_DS1	8	/* Direct Sequence  1Mbps*/
a226 1
#define	IFM_FLOW	0x00400000	/* enable hardware flow control */
a250 9
/* Mask of "status valid" bits, for ifconfig(8). */
#define	IFM_STATUS_VALID	IFM_AVALID

/* List of "status valid" bits, for ifconfig(8). */
#define	IFM_STATUS_VALID_LIST {						\
	IFM_AVALID,							\
	0								\
}

a359 1
	{ IFM_IEEE80211|IFM_IEEE80211_DS1,	"DS1" },		\
a393 25
/*
 * Status bit descriptions for the various media types.
 */
struct ifmedia_status_description {
	int	ifms_type;
	int	ifms_valid;
	int	ifms_bit;
	const char *ifms_string[2];
};

#define	IFM_STATUS_DESC(ifms, bit)					\
	(ifms)->ifms_string[((ifms)->ifms_bit & (bit)) ? 1 : 0]

#define	IFM_STATUS_DESCRIPTIONS {					\
	{ IFM_ETHER,		IFM_AVALID,	IFM_ACTIVE,		\
	    { "no carrier", "active" } },				\
	{ IFM_FDDI,		IFM_AVALID,	IFM_ACTIVE,		\
	    { "no ring", "inserted" } },				\
	{ IFM_TOKEN,		IFM_AVALID,	IFM_ACTIVE,		\
	    { "no ring", "inserted" } },				\
	{ IFM_IEEE80211,	IFM_AVALID,	IFM_ACTIVE,		\
	    { "no network", "active" } },				\
	{ 0,			0,		0,			\
	    { NULL, NULL } }						\
}
@


1.3.2.4
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: if_media.h,v 1.7 2000/08/26 20:04:16 nate Exp $	*/
/*	$NetBSD: if_media.h,v 1.22 2000/02/17 21:53:16 sommerfeld Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
d104 1
a104 1
	TAILQ_ENTRY(ifmedia_entry) ifm_list;
d118 1
a118 1
	TAILQ_HEAD(, ifmedia_entry) ifm_list; /* list of all supported media */
a147 2
/* Compute baudrate for a given media. */
int	ifmedia_baudrate __P((int));
d154 1
a154 1
 *	0-4	Media subtype		MAX SUBTYPE == 31!
d174 1
a174 1
#define	IFM_1000_SX	11		/* 1000BaseSX - multi-mode fiber */
d177 5
a181 4
#define	IFM_1000_LX	14		/* 1000baseLX - single-mode fiber */
#define	IFM_1000_CX	15		/* 1000baseCX - 150ohm STP */
#define	IFM_1000_TX	16		/* 1000baseTX - 4 pair cat 5 */
#define	IFM_HPNA_1	17		/* HomePNA 1.0 (1Mb/s) */
d338 2
a339 2
	{ IFM_ETHER|IFM_1000_SX,	"1000baseSX" },			\
	{ IFM_ETHER|IFM_1000_SX,	"1000SX" },			\
d346 1
a347 1
	{ IFM_ETHER|IFM_1000_LX,	"1000LX" },			\
a348 1
	{ IFM_ETHER|IFM_1000_CX,	"1000CX" },			\
a349 1
	{ IFM_ETHER|IFM_1000_TX,	"1000TX" },			\
a403 44
}

/*
 * Baudrate descriptions for the various media types.
 */
struct ifmedia_baudrate {
	int	ifmb_word;		/* media word */
	int	ifmb_baudrate;		/* corresponding baudrate */
};

#define	IFM_BAUDRATE_DESCRIPTIONS {					\
	{ IFM_ETHER|IFM_10_T,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_10_2,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_10_5,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_100_TX,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_100_FX,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_100_T4,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_100_VG,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_100_T2,		IF_Mbps(100) },			\
	{ IFM_ETHER|IFM_1000_SX,	IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_10_STP,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_10_FL,		IF_Mbps(10) },			\
	{ IFM_ETHER|IFM_1000_LX,	IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_1000_CX,	IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_1000_TX,	IF_Mbps(1000) },		\
	{ IFM_ETHER|IFM_HPNA_1,		IF_Mbps(1) },			\
									\
	{ IFM_TOKEN|IFM_TOK_STP4,	IF_Mbps(4) },			\
	{ IFM_TOKEN|IFM_TOK_STP16,	IF_Mbps(16) },			\
	{ IFM_TOKEN|IFM_TOK_UTP4,	IF_Mbps(4) },			\
	{ IFM_TOKEN|IFM_TOK_UTP16,	IF_Mbps(16) },			\
									\
	{ IFM_FDDI|IFM_FDDI_SMF,	IF_Mbps(100) },			\
	{ IFM_FDDI|IFM_FDDI_MMF,	IF_Mbps(100) },			\
	{ IFM_FDDI|IFM_FDDI_UTP,	IF_Mbps(100) },			\
									\
	{ IFM_IEEE80211|IFM_IEEE80211_FH1, IF_Mbps(1) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_FH2, IF_Mbps(2) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS2, IF_Mbps(2) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS5, IF_Mbps(5) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS11, IF_Mbps(11) },		\
	{ IFM_IEEE80211|IFM_IEEE80211_DS1, IF_Mbps(1) },		\
									\
	{ 0, 0 },							\
@


1.3.2.5
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 2
a98 2
typedef	int (*ifm_change_cb_t)(struct ifnet *ifp);
typedef	void (*ifm_stat_cb_t)(struct ifnet *ifp, struct ifmediareq *req);
d124 2
a125 2
void	ifmedia_init(struct ifmedia *ifm, int dontcare_mask,
	    ifm_change_cb_t change_callback, ifm_stat_cb_t status_callback);
d128 1
a128 1
void	ifmedia_add(struct ifmedia *ifm, int mword, int data, void *aux);
d135 1
a135 1
void	ifmedia_set(struct ifmedia *ifm, int mword);
d138 2
a139 2
int	ifmedia_ioctl(struct ifnet *ifp, struct ifreq *ifr,
	    struct ifmedia *ifm, u_long cmd);
d142 2
a143 2
struct	ifmedia_entry *ifmedia_match(struct ifmedia *ifm,
	     int flags, int mask);
d146 1
a146 1
void	ifmedia_delete_instance(struct ifmedia *, int);
d149 1
a149 1
int	ifmedia_baudrate(int);
@


1.3.2.6
log
@Sync the SMP branch with 3.3
@
text
@d181 1
a181 2
#define	IFM_1000_T	16		/* 1000baseT - 4 pair cat 5 */
#define	IFM_1000_TX	IFM_1000_T	/* for backwards compatibility */
a215 3
#define	IFM_IEEE80211_HOSTAP	0x200	/* Operate in Host AP mode */
#define	IFM_IEEE80211_IBSS	0x400	/* Operate in IBSS mode */
#define	IFM_IEEE80211_IBSSMASTER 0x800	/* Operate as an IBSS master */
d351 2
a352 4
	{ IFM_ETHER|IFM_1000_T,		"1000baseT" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000T" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000baseTX" },			\
	{ IFM_ETHER|IFM_1000_T,		"1000TX" },			\
a404 3
	{ IFM_IEEE80211|IFM_IEEE80211_HOSTAP,	"hostap" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_IBSS,	"ibss" },		\
	{ IFM_IEEE80211|IFM_IEEE80211_IBSSMASTER, "ibss-master" },	\
d431 1
a431 1
	{ IFM_ETHER|IFM_1000_T,		IF_Mbps(1000) },		\
@


1.3.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a219 1
#define	IFM_IEEE80211_MONITOR	0x1000	/* Operate in Monitor mode */
a413 1
	{ IFM_IEEE80211|IFM_IEEE80211_MONITOR,	"monitor" },		\
@


1.2
log
@1000baseXX media
@
text
@d1 1
a1 1
/*	$OpenBSD: if_media.h,v 1.1 1998/09/03 06:24:20 jason Exp $	*/
d140 4
@


1.1
log
@o OpenBSD gets if_media support (from NetBSD)
o rework/simplify if_xl to use it
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d171 4
d247 1
a247 1
	((type) | (subtype) | (options) | ((instance) << IFM_ISHIFT))
d315 4
@

