head	1.174;
access;
symbols
	OPENBSD_6_1:1.171.0.4
	OPENBSD_6_1_BASE:1.171
	OPENBSD_6_0:1.165.0.4
	OPENBSD_6_0_BASE:1.165
	OPENBSD_5_9:1.151.0.2
	OPENBSD_5_9_BASE:1.151
	OPENBSD_5_8:1.135.0.4
	OPENBSD_5_8_BASE:1.135
	OPENBSD_5_7:1.112.0.2
	OPENBSD_5_7_BASE:1.112
	OPENBSD_5_6:1.108.0.4
	OPENBSD_5_6_BASE:1.108
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.97.0.2
	OPENBSD_5_4_BASE:1.97
	OPENBSD_5_3:1.93.0.2
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.91.0.4
	OPENBSD_5_2_BASE:1.91
	OPENBSD_5_1_BASE:1.91
	OPENBSD_5_1:1.91.0.2
	OPENBSD_5_0:1.87.0.4
	OPENBSD_5_0_BASE:1.87
	OPENBSD_4_9:1.87.0.2
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.85.0.2
	OPENBSD_4_8_BASE:1.85
	OPENBSD_4_7:1.82.0.2
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.78.0.6
	OPENBSD_4_6_BASE:1.78
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.72.0.2
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.70.0.2
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.68.0.4
	OPENBSD_4_1_BASE:1.68
	OPENBSD_4_0:1.68.0.2
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.63.0.2
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.59.0.2
	OPENBSD_3_8_BASE:1.59
	OPENBSD_3_7:1.47.0.2
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.46.0.4
	OPENBSD_3_6_BASE:1.46
	SMP_SYNC_A:1.46
	SMP_SYNC_B:1.46
	OPENBSD_3_5:1.46.0.2
	OPENBSD_3_5_BASE:1.46
	OPENBSD_3_4:1.41.0.2
	OPENBSD_3_4_BASE:1.41
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.35.0.2
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.32
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	SMP:1.16.0.4
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.174
date	2017.06.22.11.34.51;	author tom;	state Exp;
branches;
next	1.173;
commitid	UB6ah54suwoUhGTY;

1.173
date	2017.05.31.05.14.51;	author dlg;	state Exp;
branches;
next	1.172;
commitid	sCWYLsIzBCW2FeYe;

1.172
date	2017.05.29.06.44.54;	author mpi;	state Exp;
branches;
next	1.171;
commitid	WuEEZme95HbUhl2V;

1.171
date	2017.01.24.10.08.30;	author krw;	state Exp;
branches;
next	1.170;
commitid	6c6qq5OdS4VVnyVM;

1.170
date	2017.01.24.03.57.35;	author dlg;	state Exp;
branches;
next	1.169;
commitid	PERtGPXCvlLRRBr8;

1.169
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.168;
commitid	F6oNrr9LCLUSAxgA;

1.168
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.167;
commitid	VyLWTsbepAOk7VQM;

1.167
date	2016.10.10.02.44.17;	author dlg;	state Exp;
branches;
next	1.166;
commitid	3csUIPZAhZyJvnWM;

1.166
date	2016.09.03.13.46.57;	author reyk;	state Exp;
branches;
next	1.165;
commitid	3QjHFZLzmkdTcUlc;

1.165
date	2016.05.18.03.46.03;	author dlg;	state Exp;
branches;
next	1.164;
commitid	q5zkugIMulsP5tHa;

1.164
date	2016.04.19.23.32.15;	author dlg;	state Exp;
branches;
next	1.163;
commitid	gf6dXLZoyrQebcDj;

1.163
date	2016.04.19.23.31.32;	author dlg;	state Exp;
branches;
next	1.162;
commitid	93MUidRpqx4pZPJ8;

1.162
date	2016.04.15.04.34.10;	author dlg;	state Exp;
branches;
next	1.161;
commitid	0O1Y287nJPLHW6S4;

1.161
date	2016.04.15.04.29.59;	author dlg;	state Exp;
branches;
next	1.160;
commitid	hKkyenFOj9CU9NHC;

1.160
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.159;
commitid	Xo6g1xk26RWDGcjJ;

1.159
date	2016.04.04.01.55.44;	author dlg;	state Exp;
branches;
next	1.158;
commitid	1WAcuE0eyn7Lg8Vy;

1.158
date	2016.03.29.13.55.42;	author dlg;	state Exp;
branches;
next	1.157;
commitid	XeIYDZ7NKO77SGBl;

1.157
date	2016.03.29.04.33.16;	author dlg;	state Exp;
branches;
next	1.156;
commitid	R8i1nZFb0dqDaPyx;

1.156
date	2016.03.28.13.05.22;	author dlg;	state Exp;
branches;
next	1.155;
commitid	skJ1NokXHFFyE2fu;

1.155
date	2016.03.18.02.40.04;	author dlg;	state Exp;
branches;
next	1.154;
commitid	P2DLDlwAkN6wmKpR;

1.154
date	2016.03.13.11.44.22;	author dlg;	state Exp;
branches;
next	1.153;
commitid	uqqy5G4X4e2RPGVm;

1.153
date	2016.03.13.04.37.37;	author dlg;	state Exp;
branches;
next	1.152;
commitid	xLq3NlYF0J3Whm33;

1.152
date	2016.03.03.02.53.28;	author dlg;	state Exp;
branches;
next	1.151;
commitid	M35igGA556wbKd8U;

1.151
date	2016.01.13.03.18.26;	author dlg;	state Exp;
branches;
next	1.150;
commitid	5AUxjUMP5Wkrq7vi;

1.150
date	2015.12.08.11.35.42;	author dlg;	state Exp;
branches;
next	1.149;
commitid	rc1J03sYyymkH0p6;

1.149
date	2015.12.05.10.07.55;	author tedu;	state Exp;
branches;
next	1.148;
commitid	ILbVM1M3uPNjwswz;

1.148
date	2015.12.03.16.27.32;	author mpi;	state Exp;
branches;
next	1.147;
commitid	wK6td35Fr7xdNzh3;

1.147
date	2015.11.10.06.34.35;	author dlg;	state Exp;
branches;
next	1.146;
commitid	hzwo6DiiDUse3MSm;

1.146
date	2015.10.25.12.05.40;	author mpi;	state Exp;
branches;
next	1.145;
commitid	iXTa9MhdGfWGiTE6;

1.145
date	2015.10.05.19.05.09;	author uebayasi;	state Exp;
branches;
next	1.144;
commitid	KaQeg2gqRFHdXmok;

1.144
date	2015.10.05.15.52.46;	author uebayasi;	state Exp;
branches;
next	1.143;
commitid	Jb3hy8KXZkqIykJt;

1.143
date	2015.09.29.10.11.40;	author deraadt;	state Exp;
branches;
next	1.142;
commitid	L3Bwt4zBOCs33Zbo;

1.142
date	2015.09.13.10.02.36;	author dlg;	state Exp;
branches;
next	1.141;
commitid	ni4mL2tUxr2APTrc;

1.141
date	2015.09.13.09.46.45;	author dlg;	state Exp;
branches;
next	1.140;
commitid	ddAkZEA4GEAJac0m;

1.140
date	2015.09.13.06.25.46;	author dlg;	state Exp;
branches;
next	1.139;
commitid	J3q16OkmNmNp1ekn;

1.139
date	2015.09.12.20.46.40;	author dlg;	state Exp;
branches;
next	1.138;
commitid	uUy9Ynsuv11KW4On;

1.138
date	2015.09.10.17.32.32;	author dlg;	state Exp;
branches;
next	1.137;
commitid	Kisu6nBcd6pjkJrs;

1.137
date	2015.09.10.16.41.30;	author mikeb;	state Exp;
branches;
next	1.136;
commitid	Dj2db8t0KelqURhl;

1.136
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.135;
commitid	JbEzJsyDrWqOW57C;

1.135
date	2015.07.20.22.16.41;	author rzalamena;	state Exp;
branches
	1.135.4.1;
next	1.134;
commitid	yaHvJbufOxtjWSFd;

1.134
date	2015.07.02.09.40.02;	author mpi;	state Exp;
branches;
next	1.133;
commitid	eKXa0TkOIth1tkBS;

1.133
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.132;
commitid	fE8TgA9vpwdUU5Wy;

1.132
date	2015.06.29.10.32.29;	author dlg;	state Exp;
branches;
next	1.131;
commitid	rqyNfIORa1UIJQnb;

1.131
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.130;
commitid	MVWrtktB46JRxFWT;

1.130
date	2015.06.23.09.42.23;	author mpi;	state Exp;
branches;
next	1.129;
commitid	p9JxIlTsQMWvTdAT;

1.129
date	2015.06.16.11.09.39;	author mpi;	state Exp;
branches;
next	1.128;
commitid	h7z8lokZ0dFyuWpg;

1.128
date	2015.06.08.13.44.08;	author mpi;	state Exp;
branches;
next	1.127;
commitid	QBkAtlGdp82XwFPf;

1.127
date	2015.05.27.12.23.44;	author dlg;	state Exp;
branches;
next	1.126;
commitid	Sg9ZmNYzVQIl35dE;

1.126
date	2015.05.26.11.39.07;	author mpi;	state Exp;
branches;
next	1.125;
commitid	VJjEISzzvhOYKF2A;

1.125
date	2015.05.26.03.01.54;	author dlg;	state Exp;
branches;
next	1.124;
commitid	zaep1rSlVMt8ydd3;

1.124
date	2015.05.23.08.32.12;	author mpi;	state Exp;
branches;
next	1.123;
commitid	gyh8Wtm8gRTt77r9;

1.123
date	2015.05.20.08.54.37;	author mpi;	state Exp;
branches;
next	1.122;
commitid	sJVAsE8GKiZxjUOj;

1.122
date	2015.05.20.08.28.54;	author mpi;	state Exp;
branches;
next	1.121;
commitid	fTNkviHPk3FLJmC5;

1.121
date	2015.05.19.11.21.42;	author mpi;	state Exp;
branches;
next	1.120;
commitid	2yedtQB8aG4XpxCB;

1.120
date	2015.05.19.11.09.24;	author mpi;	state Exp;
branches;
next	1.119;
commitid	i7YRRkkCxLwyGmml;

1.119
date	2015.05.15.10.15.13;	author mpi;	state Exp;
branches;
next	1.118;
commitid	1aiWjheMGhmTuiHL;

1.118
date	2015.04.22.06.42.11;	author mpi;	state Exp;
branches;
next	1.117;
commitid	kQOcElUOqjqBYLjv;

1.117
date	2015.04.15.09.58.44;	author mpi;	state Exp;
branches;
next	1.116;
commitid	mX8tUNUL6fZpCzfZ;

1.116
date	2015.04.13.08.52.51;	author mpi;	state Exp;
branches;
next	1.115;
commitid	eIjCB6UMjE3earTB;

1.115
date	2015.04.10.02.08.08;	author dlg;	state Exp;
branches;
next	1.114;
commitid	S1ATYKCHsyKSBspR;

1.114
date	2015.04.07.10.46.20;	author mpi;	state Exp;
branches;
next	1.113;
commitid	m3c6YErI0cVMQeYc;

1.113
date	2015.03.31.11.47.09;	author dlg;	state Exp;
branches;
next	1.112;
commitid	aA6pOH4gTq3z9ztJ;

1.112
date	2015.02.06.08.07.09;	author henning;	state Exp;
branches;
next	1.111;
commitid	sfr97reGA6A1eDSZ;

1.111
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.110;
commitid	zhW8jJrfVCoAthrR;

1.110
date	2014.11.23.07.39.02;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	mdGXHklUZmESVFlY;

1.109
date	2014.10.07.11.16.23;	author dlg;	state Exp;
branches;
next	1.108;
commitid	p6HaTuy2dxbTD4Pm;

1.108
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.107;
commitid	B4dZSbxas1X1IpXI;

1.107
date	2014.07.11.10.48.50;	author henning;	state Exp;
branches;
next	1.106;
commitid	WwgSeFXGh1gDsEm4;

1.106
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.105;
commitid	Nnxg8ONtI4Ep9pUb;

1.105
date	2014.05.14.21.48.50;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2014.05.05.10.00.45;	author henning;	state Exp;
branches;
next	1.103;

1.103
date	2014.04.22.11.43.07;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2014.03.10.12.21.35;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2013.11.08.09.18.27;	author mpi;	state Exp;
branches;
next	1.100;

1.100
date	2013.11.07.11.19.32;	author mpi;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.19.14.05.14;	author reyk;	state Exp;
branches;
next	1.98;

1.98
date	2013.09.17.13.34.18;	author mpi;	state Exp;
branches;
next	1.97;

1.97
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.95;

1.95
date	2013.04.02.08.54.37;	author mpi;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.93;

1.93
date	2012.09.30.12.11.50;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2012.09.19.15.29.53;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2011.11.27.00.46.07;	author haesbaert;	state Exp;
branches;
next	1.90;

1.90
date	2011.11.26.23.38.18;	author haesbaert;	state Exp;
branches;
next	1.89;

1.89
date	2011.09.18.11.17.57;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2011.08.20.06.21.32;	author mcbride;	state Exp;
branches;
next	1.87;

1.87
date	2011.02.18.17.06.45;	author reyk;	state Exp;
branches;
next	1.86;

1.86
date	2011.01.03.11.18.13;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.03.16.15.00;	author naddy;	state Exp;
branches;
next	1.83;

1.83
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.12.01.36.33;	author dlg;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.18.02.09.59;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2009.07.16.22.58.45;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2009.07.13.12.39.22;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2009.01.27.15.56.58;	author naddy;	state Exp;
branches;
next	1.77;

1.77
date	2008.10.16.19.18.03;	author naddy;	state Exp;
branches;
next	1.76;

1.76
date	2008.10.16.19.12.51;	author naddy;	state Exp;
branches;
next	1.75;

1.75
date	2008.10.16.14.23.35;	author naddy;	state Exp;
branches;
next	1.74;

1.74
date	2008.09.02.17.35.16;	author chl;	state Exp;
branches;
next	1.73;

1.73
date	2008.05.07.13.45.35;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.15.16.43.51;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.06.14.05.58;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.26.17.13.31;	author jason;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.22.23.25.15;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.09.19.43.02;	author mpf;	state Exp;
branches;
next	1.66;

1.66
date	2006.04.11.13.29.37;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2006.02.09.00.05.55;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2006.01.05.14.57.24;	author norby;	state Exp;
branches;
next	1.61;

1.61
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.23.14.07.11;	author mpf;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.58;

1.58
date	2005.07.19.11.50.20;	author camield;	state Exp;
branches;
next	1.57;

1.57
date	2005.07.18.19.18.33;	author camield;	state Exp;
branches;
next	1.56;

1.56
date	2005.06.07.07.09.42;	author camield;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.27.08.33.25;	author mpf;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.25.01.34.26;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.24.10.16.10;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2005.04.20.23.02.22;	author mpf;	state Exp;
branches;
next	1.51;

1.51
date	2005.04.18.04.07.17;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2005.04.18.03.29.18;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.17.23.02.02;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.25.03.23.51;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2004.10.09.19.55.29;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.27.23.41.04;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.12.18.07.29;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.16.20.33.25;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.06.09.23.25;	author grange;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.03.14.55.58;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.15.20.32.19;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.14.19.00.12;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.25.03.45.42;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.13.00.55.12;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.24.17.59.48;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.01.00.14.40;	author chris;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.07.09.00.34;	author kjc;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.12.01.42.29;	author chris;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.24.19.17.27;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.13.20.38.29;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.11.05.13.37;	author jason;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.10.05.06.32.34;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2001.10.01.09.27.31;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.01.00.50.49;	author chris;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.03.23.21.19;	author chris;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.27.06.07.46;	author kjc;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.27.03.49.53;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.25.02.53.29;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.24.22.52.07;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.23.23.01.26;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.23.04.01.19;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.22.14.28.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.27.11.58.25;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.30.16.02.13;	author jason;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2001.03.28.00.16.28;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.26.23.07.38;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.26.19.00.58;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.23.07.45.42;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.23.07.37.21;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.23.07.14.53;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.22.05.26.35;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.20.19.39.48;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.02.14.46.34;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.18.15.55.48;	author chris;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.15.22.21.17;	author chris;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.15.19.15.00;	author chris;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.27.00.00.24;	author chris;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.22.57.27;	author chris;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.26.19.03.11;	author chris;	state Exp;
branches;
next	;

1.16.4.1
date	2001.05.14.22.40.02;	author niklas;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2001.07.04.10.54.12;	author niklas;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2001.10.31.03.29.02;	author nate;	state Exp;
branches;
next	1.16.4.4;

1.16.4.4
date	2002.03.06.02.15.06;	author niklas;	state Exp;
branches;
next	1.16.4.5;

1.16.4.5
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.16.4.6;

1.16.4.6
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	1.16.4.7;

1.16.4.7
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.16.4.8;

1.16.4.8
date	2004.02.19.10.57.21;	author niklas;	state Exp;
branches;
next	1.16.4.9;

1.16.4.9
date	2004.06.05.23.11.24;	author niklas;	state Exp;
branches;
next	;

1.29.2.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2003.05.19.22.30.41;	author tedu;	state Exp;
branches;
next	;

1.135.4.1
date	2016.01.25.12.39.00;	author bluhm;	state Exp;
branches;
next	1.135.4.2;
commitid	SYcIzQHGusFHqgzu;

1.135.4.2
date	2016.02.09.17.24.15;	author bluhm;	state Exp;
branches;
next	;
commitid	SqCXEzkugz0qVfj5;


desc
@@


1.174
log
@Fix the remaining ';;'s in sys/
@
text
@/*	$OpenBSD: if_vlan.c,v 1.173 2017/05/31 05:14:51 dlg Exp $	*/

/*
 * Copyright 1998 Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby
 * granted, provided that both the above copyright notice and this
 * permission notice appear in all copies, that both the above
 * copyright notice and this permission notice appear in all
 * supporting documentation, and that the name of M.I.T. not be used
 * in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.  M.I.T. makes
 * no representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS
 * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
 * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/net/if_vlan.c,v 1.16 2000/03/26 15:21:40 charnier Exp $
 */

/*
 * if_vlan.c - pseudo-device driver for IEEE 802.1Q virtual LANs.
 * This is sort of sneaky in the implementation, since
 * we need to pretend to be enough of an Ethernet implementation
 * to make arp work.  The way we do this is by telling everyone
 * that we are an Ethernet, and then catch the packets that
 * ether_output() left on our output queue when it calls
 * if_start(), rewrite them for use by the real outgoing interface,
 * and ask it to send them.
 *
 * Some devices support 802.1Q tag insertion in firmware.  The
 * vlan interface behavior changes when the IFCAP_VLAN_HWTAGGING
 * capability is set on the parent.  In this case, vlan_start()
 * will not modify the ethernet header.
 */

#include "mpw.h"

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/systm.h>
#include <sys/rwlock.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_vlan_var.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#define TAG_HASH_BITS		5
#define TAG_HASH_SIZE		(1 << TAG_HASH_BITS)
#define TAG_HASH_MASK		(TAG_HASH_SIZE - 1)
#define TAG_HASH(tag)		(tag & TAG_HASH_MASK)
SRPL_HEAD(, ifvlan) *vlan_tagh, *svlan_tagh;
struct rwlock vlan_tagh_lk = RWLOCK_INITIALIZER("vlantag");

void	vlanattach(int count);
int	vlan_clone_create(struct if_clone *, int);
int	vlan_clone_destroy(struct ifnet *);

int	vlan_input(struct ifnet *, struct mbuf *, void *);
void	vlan_start(struct ifqueue *ifq);
int	vlan_ioctl(struct ifnet *ifp, u_long cmd, caddr_t addr);

int	vlan_up(struct ifvlan *);
int	vlan_parent_up(struct ifvlan *, struct ifnet *);
int	vlan_down(struct ifvlan *);

void	vlan_ifdetach(void *);
void	vlan_link_hook(void *);
void	vlan_link_state(struct ifvlan *, u_char, u_int64_t);

int	vlan_set_vnetid(struct ifvlan *, uint16_t);
int	vlan_set_parent(struct ifvlan *, const char *);
int	vlan_del_parent(struct ifvlan *);
int	vlan_inuse(uint16_t, unsigned int, uint16_t);
int	vlan_inuse_locked(uint16_t, unsigned int, uint16_t);

int	vlan_multi_add(struct ifvlan *, struct ifreq *);
int	vlan_multi_del(struct ifvlan *, struct ifreq *);
void	vlan_multi_apply(struct ifvlan *, struct ifnet *, u_long);
void	vlan_multi_free(struct ifvlan *);

int	vlan_media_get(struct ifvlan *, struct ifreq *);

int	vlan_iff(struct ifvlan *);
int	vlan_setlladdr(struct ifvlan *, struct ifreq *);

int	vlan_set_compat(struct ifnet *, struct ifreq *);
int	vlan_get_compat(struct ifnet *, struct ifreq *);

struct if_clone vlan_cloner =
    IF_CLONE_INITIALIZER("vlan", vlan_clone_create, vlan_clone_destroy);
struct if_clone svlan_cloner =
    IF_CLONE_INITIALIZER("svlan", vlan_clone_create, vlan_clone_destroy);

void vlan_ref(void *, void *);
void vlan_unref(void *, void *);

struct srpl_rc vlan_tagh_rc = SRPL_RC_INITIALIZER(vlan_ref, vlan_unref, NULL);

void
vlanattach(int count)
{
	u_int i;

	/* Normal VLAN */
	vlan_tagh = mallocarray(TAG_HASH_SIZE, sizeof(*vlan_tagh),
	    M_DEVBUF, M_NOWAIT);
	if (vlan_tagh == NULL)
		panic("vlanattach: hashinit");

	/* Service-VLAN for QinQ/802.1ad provider bridges */
	svlan_tagh = mallocarray(TAG_HASH_SIZE, sizeof(*svlan_tagh),
	    M_DEVBUF, M_NOWAIT);
	if (svlan_tagh == NULL)
		panic("vlanattach: hashinit");

	for (i = 0; i < TAG_HASH_SIZE; i++) {
		SRPL_INIT(&vlan_tagh[i]);
		SRPL_INIT(&svlan_tagh[i]);
	}

	if_clone_attach(&vlan_cloner);
	if_clone_attach(&svlan_cloner);
}

int
vlan_clone_create(struct if_clone *ifc, int unit)
{
	struct ifvlan	*ifv;
	struct ifnet	*ifp;

	ifv = malloc(sizeof(*ifv), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (ifv == NULL)
		return (ENOMEM);

	LIST_INIT(&ifv->vlan_mc_listhead);
	ifp = &ifv->ifv_if;
	ifp->if_softc = ifv;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name,
	    unit);
	/* NB: flags are not set here */
	/* NB: mtu is not set here */

	/* Special handling for the IEEE 802.1ad QinQ variant */
	if (strcmp("svlan", ifc->ifc_name) == 0)
		ifv->ifv_type = ETHERTYPE_QINQ;
	else
		ifv->ifv_type = ETHERTYPE_VLAN;

	refcnt_init(&ifv->ifv_refcnt);

	ifp->if_flags = IFF_BROADCAST | IFF_MULTICAST;
	ifp->if_xflags = IFXF_CLONED|IFXF_MPSAFE;
	ifp->if_qstart = vlan_start;
	ifp->if_ioctl = vlan_ioctl;
	ifp->if_hardmtu = 0xffff;
	ifp->if_link_state = LINK_STATE_DOWN;
	if_attach(ifp);
	ether_ifattach(ifp);
	ifp->if_hdrlen = EVL_ENCAPLEN;

	return (0);
}

void
vlan_ref(void *null, void *v)
{
	struct ifvlan *ifv = v;

	refcnt_take(&ifv->ifv_refcnt);
}

void
vlan_unref(void *null, void *v)
{
	struct ifvlan *ifv = v;

	refcnt_rele_wake(&ifv->ifv_refcnt);
}

int
vlan_clone_destroy(struct ifnet *ifp)
{
	struct ifvlan	*ifv = ifp->if_softc;

	if (ISSET(ifp->if_flags, IFF_RUNNING))
		vlan_down(ifv);

	ether_ifdetach(ifp);
	if_detach(ifp);
	refcnt_finalize(&ifv->ifv_refcnt, "vlanrefs");
	vlan_multi_free(ifv);
	free(ifv, M_DEVBUF, sizeof(*ifv));

	return (0);
}

static inline int
vlan_mplstunnel(int ifidx)
{
#if NMPW > 0
	struct ifnet *ifp;
	int rv = 0;

	ifp = if_get(ifidx);
	if (ifp != NULL) {
		rv = ifp->if_type == IFT_MPLSTUNNEL;
		if_put(ifp);
	}
	return (rv);
#else
	return (0);
#endif
}

void
vlan_start(struct ifqueue *ifq)
{
	struct ifnet	*ifp = ifq->ifq_if;
	struct ifvlan   *ifv;
	struct ifnet	*ifp0;
	struct mbuf	*m;
	uint8_t		 prio;

	ifv = ifp->if_softc;
	ifp0 = if_get(ifv->ifv_ifp0);
	if (ifp0 == NULL || (ifp0->if_flags & (IFF_UP|IFF_RUNNING)) !=
	    (IFF_UP|IFF_RUNNING)) {
		ifq_purge(ifq);
		goto leave;
	}

	while ((m = ifq_dequeue(ifq)) != NULL) {
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif /* NBPFILTER > 0 */


		/* IEEE 802.1p has prio 0 and 1 swapped */
		prio = m->m_pkthdr.pf.prio;
		if (prio <= 1)
			prio = !prio;

		/*
		 * If this packet came from a pseudowire it means it already
		 * has all tags it needs, so just output it.
		 */
		if (vlan_mplstunnel(m->m_pkthdr.ph_ifidx)) {
			/* NOTHING */

		/*
		 * If the underlying interface cannot do VLAN tag insertion
		 * itself, create an encapsulation header.
		 */
		} else if ((ifp0->if_capabilities & IFCAP_VLAN_HWTAGGING) &&
		    (ifv->ifv_type == ETHERTYPE_VLAN)) {
			m->m_pkthdr.ether_vtag = ifv->ifv_tag +
			    (prio << EVL_PRIO_BITS);
			m->m_flags |= M_VLANTAG;
		} else {
			m = vlan_inject(m, ifv->ifv_type, ifv->ifv_tag |
			    (prio << EVL_PRIO_BITS));
			if (m == NULL) {
				ifp->if_oerrors++;
				continue;
			}
		}

		if (if_enqueue(ifp0, m)) {
			ifp->if_oerrors++;
			ifq->ifq_errors++;
			continue;
		}
	}

leave:
	if_put(ifp0);
}

struct mbuf *
vlan_inject(struct mbuf *m, uint16_t type, uint16_t tag)
{
	struct ether_vlan_header evh;

	m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&evh);
	evh.evl_proto = evh.evl_encap_proto;
	evh.evl_encap_proto = htons(type);
	evh.evl_tag = htons(tag);
	m_adj(m, ETHER_HDR_LEN);
	M_PREPEND(m, sizeof(evh) + ETHER_ALIGN, M_DONTWAIT);
	if (m == NULL)
		return (NULL);

	m_adj(m, ETHER_ALIGN);

	m_copyback(m, 0, sizeof(evh), &evh, M_NOWAIT);
	CLR(m->m_flags, M_VLANTAG);

	return (m);
 }

/*
 * vlan_input() returns 1 if it has consumed the packet, 0 otherwise.
 */
int
vlan_input(struct ifnet *ifp0, struct mbuf *m, void *cookie)
{
	struct ifvlan			*ifv;
	struct ether_vlan_header	*evl;
	struct ether_header		*eh;
	SRPL_HEAD(, ifvlan)		*tagh, *list;
	struct srp_ref			 sr;
	u_int				 tag;
	struct mbuf_list		 ml = MBUF_LIST_INITIALIZER();
	u_int16_t			 etype;

	eh = mtod(m, struct ether_header *);
	etype = ntohs(eh->ether_type);

	if (m->m_flags & M_VLANTAG) {
		etype = ETHERTYPE_VLAN;
		tagh = vlan_tagh;
	} else if ((etype == ETHERTYPE_VLAN) || (etype == ETHERTYPE_QINQ)) {
		if (m->m_len < sizeof(*evl) &&
		    (m = m_pullup(m, sizeof(*evl))) == NULL) {
			ifp0->if_ierrors++;
			return (1);
		}

		evl = mtod(m, struct ether_vlan_header *);
		m->m_pkthdr.ether_vtag = ntohs(evl->evl_tag);
		tagh = etype == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;
	} else {
		/* Skip non-VLAN packets. */
		return (0);
	}

	/* From now on ether_vtag is fine */
	tag = EVL_VLANOFTAG(m->m_pkthdr.ether_vtag);
	m->m_pkthdr.pf.prio = EVL_PRIOFTAG(m->m_pkthdr.ether_vtag);

	/* IEEE 802.1p has prio 0 and 1 swapped */
	if (m->m_pkthdr.pf.prio <= 1)
		m->m_pkthdr.pf.prio = !m->m_pkthdr.pf.prio;

	list = &tagh[TAG_HASH(tag)];
	SRPL_FOREACH(ifv, &sr, list, ifv_list) {
		if (ifp0->if_index == ifv->ifv_ifp0 && tag == ifv->ifv_tag &&
		    etype == ifv->ifv_type)
			break;
	}

	if (ifv == NULL) {
		ifp0->if_noproto++;
		goto drop;
	}

	if ((ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
	    (IFF_UP|IFF_RUNNING))
		goto drop;

	/*
	 * Having found a valid vlan interface corresponding to
	 * the given source interface and vlan tag, remove the
	 * encapsulation.
	 */
	if (m->m_flags & M_VLANTAG) {
		m->m_flags &= ~M_VLANTAG;
	} else {
		eh->ether_type = evl->evl_proto;
		memmove((char *)eh + EVL_ENCAPLEN, eh, sizeof(*eh));
		m_adj(m, EVL_ENCAPLEN);
	}

	ml_enqueue(&ml, m);
	if_input(&ifv->ifv_if, &ml);
	SRPL_LEAVE(&sr);
	return (1);

drop:
	SRPL_LEAVE(&sr);
	m_freem(m);
	return (1);
}

int
vlan_parent_up(struct ifvlan *ifv, struct ifnet *ifp0)
{
	int error;

	if (ISSET(ifv->ifv_flags, IFVF_PROMISC)) {
		error = ifpromisc(ifp0, 1);
		if (error != 0)
			return (error);
	}

	/* Register callback for physical link state changes */
	ifv->lh_cookie = hook_establish(ifp0->if_linkstatehooks, 1,
	    vlan_link_hook, ifv);

	/* Register callback if parent wants to unregister */
	ifv->dh_cookie = hook_establish(ifp0->if_detachhooks, 0,
	    vlan_ifdetach, ifv);

	vlan_multi_apply(ifv, ifp0, SIOCADDMULTI);

	if_ih_insert(ifp0, vlan_input, NULL);

	return (0);
}

int
vlan_up(struct ifvlan *ifv)
{
	SRPL_HEAD(, ifvlan) *tagh, *list;
	struct ifnet *ifp = &ifv->ifv_if;
	struct ifnet *ifp0;
	int error = 0;
	u_int hardmtu;

	KASSERT(!ISSET(ifp->if_flags, IFF_RUNNING));

	tagh = ifv->ifv_type == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;
	list = &tagh[TAG_HASH(ifv->ifv_tag)];

	ifp0 = if_get(ifv->ifv_ifp0);
	if (ifp0 == NULL)
		return (ENXIO);

	/* check vlan will work on top of the parent */
	if (ifp0->if_type != IFT_ETHER) {
		error = EPROTONOSUPPORT;
		goto put;
	}

	hardmtu = ifp0->if_hardmtu;
	if (!ISSET(ifp0->if_capabilities, IFCAP_VLAN_MTU))
		hardmtu -= EVL_ENCAPLEN;

	if (ifp->if_mtu > hardmtu) {
		error = ENOBUFS;
		goto put;
	}

	/* parent is fine, let's prepare the ifv to handle packets */
	ifp->if_hardmtu = hardmtu;
	SET(ifp->if_flags, ifp0->if_flags & IFF_SIMPLEX);

	if (ifv->ifv_type != ETHERTYPE_VLAN) {
		/*
		 * Hardware offload only works with the default VLAN
		 * ethernet type (0x8100).
		 */
		ifp->if_capabilities = 0;
	} else if (ISSET(ifp0->if_capabilities, IFCAP_VLAN_HWTAGGING)) {
		/*
		 * If the parent interface can do hardware-assisted
		 * VLAN encapsulation, then propagate its hardware-
		 * assisted checksumming flags.
		 *
		 * If the card cannot handle hardware tagging, it cannot
		 * possibly compute the correct checksums for tagged packets.
		 */
		ifp->if_capabilities = ifp0->if_capabilities & IFCAP_CSUM_MASK;
	}

	/* commit the ifv */
	error = rw_enter(&vlan_tagh_lk, RW_WRITE | RW_INTR);
	if (error != 0)
		goto scrub;

	error = vlan_inuse_locked(ifv->ifv_type, ifv->ifv_ifp0, ifv->ifv_tag);
	if (error != 0)
		goto leave;

	SRPL_INSERT_HEAD_LOCKED(&vlan_tagh_rc, list, ifv, ifv_list);
	rw_exit(&vlan_tagh_lk);

	/* configure the parent to handle packets for this vlan */
	error = vlan_parent_up(ifv, ifp0);
	if (error != 0)
		goto remove;

	/* we're running now */
	SET(ifp->if_flags, IFF_RUNNING);
	vlan_link_state(ifv, ifp0->if_link_state, ifp0->if_baudrate);

	if_put(ifp0);

	return (0);

remove:
	rw_enter(&vlan_tagh_lk, RW_WRITE);
	SRPL_REMOVE_LOCKED(&vlan_tagh_rc, list, ifv, ifvlan, ifv_list);
leave:
	rw_exit(&vlan_tagh_lk);
scrub:
	ifp->if_capabilities = 0;
	CLR(ifp->if_flags, IFF_SIMPLEX);
	ifp->if_hardmtu = 0xffff;
put:
	if_put(ifp0);

	return (error);
}

int
vlan_down(struct ifvlan *ifv)
{
	SRPL_HEAD(, ifvlan) *tagh, *list;
	struct ifnet *ifp = &ifv->ifv_if;
	struct ifnet *ifp0;

	tagh = ifv->ifv_type == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;
	list = &tagh[TAG_HASH(ifv->ifv_tag)];

	KASSERT(ISSET(ifp->if_flags, IFF_RUNNING));

	vlan_link_state(ifv, LINK_STATE_DOWN, 0);
	CLR(ifp->if_flags, IFF_RUNNING);

	ifq_barrier(&ifp->if_snd);

	ifp0 = if_get(ifv->ifv_ifp0);
	if (ifp0 != NULL) {
		if_ih_remove(ifp0, vlan_input, NULL);
		if (ISSET(ifv->ifv_flags, IFVF_PROMISC))
			ifpromisc(ifp0, 0);
		vlan_multi_apply(ifv, ifp0, SIOCDELMULTI);
		hook_disestablish(ifp0->if_detachhooks, ifv->dh_cookie);
		hook_disestablish(ifp0->if_linkstatehooks, ifv->lh_cookie);
	}
	if_put(ifp0);

	rw_enter_write(&vlan_tagh_lk);
	SRPL_REMOVE_LOCKED(&vlan_tagh_rc, list, ifv, ifvlan, ifv_list);
	rw_exit_write(&vlan_tagh_lk);

	ifp->if_capabilities = 0;
	CLR(ifp->if_flags, IFF_SIMPLEX);
	ifp->if_hardmtu = 0xffff;

	return (0);
}

void
vlan_ifdetach(void *v)
{
	struct ifvlan *ifv = v;
	struct ifnet *ifp = &ifv->ifv_if;

	if (ISSET(ifp->if_flags, IFF_RUNNING)) {
		vlan_down(ifv);
		CLR(ifp->if_flags, IFF_UP);
	}

	ifv->ifv_ifp0 = 0;
}

void
vlan_link_hook(void *v)
{
	struct ifvlan *ifv = v;
	struct ifnet *ifp0;

	u_char link = LINK_STATE_DOWN;
	uint64_t baud = 0;

	ifp0 = if_get(ifv->ifv_ifp0);
	if (ifp0 != NULL) {
		link = ifp0->if_link_state;
		baud = ifp0->if_baudrate;
	}
	if_put(ifp0);

	vlan_link_state(ifv, link, baud);
}

void
vlan_link_state(struct ifvlan *ifv, u_char link, uint64_t baud)
{
	if (ifv->ifv_if.if_link_state == link)
		return;

	ifv->ifv_if.if_link_state = link;
	ifv->ifv_if.if_baudrate = baud;

	if_link_state_change(&ifv->ifv_if);
}

int
vlan_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ifvlan *ifv = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	struct if_parent *parent = (struct if_parent *)data;
	struct ifnet *ifp0;
	uint16_t tag;
	int error = 0;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		if (ISSET(ifp->if_flags, IFF_UP)) {
			if (!ISSET(ifp->if_flags, IFF_RUNNING))
				error = vlan_up(ifv);
			else
				error = ENETRESET;
		} else {
			if (ISSET(ifp->if_flags, IFF_RUNNING))
				error = vlan_down(ifv);
		}
		break;

	case SIOCSVNETID:
		if (ifr->ifr_vnetid < EVL_VLID_MIN ||
		    ifr->ifr_vnetid > EVL_VLID_MAX) {
			error = EINVAL;
			break;
		}

		tag = ifr->ifr_vnetid;
		if (tag == ifv->ifv_tag)
			break;

		error = vlan_set_vnetid(ifv, tag);
		break;

	case SIOCGVNETID:
		if (ifv->ifv_tag == EVL_VLID_NULL)
			error = EADDRNOTAVAIL;
		else
			ifr->ifr_vnetid = (int64_t)ifv->ifv_tag;
		break;

	case SIOCDVNETID:
		error = vlan_set_vnetid(ifv, 0);
		break;

	case SIOCSIFPARENT:
		error = vlan_set_parent(ifv, parent->ifp_parent);
		break;

	case SIOCGIFPARENT:
		ifp0 = if_get(ifv->ifv_ifp0);
		if (ifp0 == NULL)
			error = EADDRNOTAVAIL;
		else {
			memcpy(parent->ifp_parent, ifp0->if_xname,
			    sizeof(parent->ifp_parent));
		}
		if_put(ifp0);
		break;

	case SIOCDIFPARENT:
		error = vlan_del_parent(ifv);
		break;

	case SIOCADDMULTI:
		error = vlan_multi_add(ifv, ifr);
		break;

	case SIOCDELMULTI:
		error = vlan_multi_del(ifv, ifr);
		break;

	case SIOCGIFMEDIA:
		error = vlan_media_get(ifv, ifr);
		break;

	case SIOCSIFMEDIA:
		error = ENOTTY;
		break;

	case SIOCSIFLLADDR:
		error = vlan_setlladdr(ifv, ifr);
		break;

	case SIOCSETVLAN:
		error = vlan_set_compat(ifp, ifr);
		break;
	case SIOCGETVLAN:
		error = vlan_get_compat(ifp, ifr);
		break;

	default:
		error = ether_ioctl(ifp, &ifv->ifv_ac, cmd, data);
		break;
	}

	if (error == ENETRESET) {
		vlan_iff(ifv);
		error = 0;
	}

	return error;
}

int
vlan_iff(struct ifvlan *ifv)
{
	struct ifnet *ifp0;
	int promisc = 0;
	int error = 0;

	if (ISSET(ifv->ifv_if.if_flags, IFF_PROMISC) ||
	    ISSET(ifv->ifv_flags, IFVF_LLADDR))
		promisc = IFVF_PROMISC;

	if (ISSET(ifv->ifv_flags, IFVF_PROMISC) == promisc)
		return (0);

	if (ISSET(ifv->ifv_if.if_flags, IFF_RUNNING)) {
		ifp0 = if_get(ifv->ifv_ifp0);
		if (ifp0 != NULL)
			error = ifpromisc(ifp0, promisc);
		if_put(ifp0);
	}

	if (error == 0) {
		CLR(ifv->ifv_flags, IFVF_PROMISC);
		SET(ifv->ifv_flags, promisc);
	}

	return (error);
}

int
vlan_setlladdr(struct ifvlan *ifv, struct ifreq *ifr)
{
	struct ifnet *ifp = &ifv->ifv_if;
	struct ifnet *ifp0;
	uint8_t lladdr[ETHER_ADDR_LEN];
	int flag;

	memcpy(lladdr, ifr->ifr_addr.sa_data, sizeof(lladdr));

	/* setting the mac addr to 00:00:00:00:00:00 means reset lladdr */
	if (memcmp(lladdr, etheranyaddr, sizeof(lladdr)) == 0) {
		ifp0 = if_get(ifv->ifv_ifp0);
		if (ifp0 != NULL)
			memcpy(lladdr, LLADDR(ifp0->if_sadl), sizeof(lladdr));
		if_put(ifp0);

		flag = 0;
	} else
		flag = IFVF_LLADDR;

	if (memcmp(lladdr, LLADDR(ifp->if_sadl), sizeof(lladdr)) == 0 &&
	    ISSET(ifv->ifv_flags, IFVF_LLADDR) == flag) {
		/* nop */
		return (0);
	}

	/* commit */
	if_setlladdr(ifp, lladdr);
	CLR(ifv->ifv_flags, IFVF_LLADDR);
	SET(ifv->ifv_flags, flag);

	return (ENETRESET);
}

int
vlan_set_vnetid(struct ifvlan *ifv, uint16_t tag)
{
	struct ifnet *ifp = &ifv->ifv_if;
	SRPL_HEAD(, ifvlan) *tagh, *list;
	u_char link = ifp->if_link_state;
	uint64_t baud = ifp->if_baudrate;
	int error;

	tagh = ifv->ifv_type == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;

	if (ISSET(ifp->if_flags, IFF_RUNNING) && LINK_STATE_IS_UP(link))
		vlan_link_state(ifv, LINK_STATE_DOWN, 0);

	error = rw_enter(&vlan_tagh_lk, RW_WRITE);
	if (error != 0)
		return (error);

	error = vlan_inuse_locked(ifv->ifv_type, ifv->ifv_ifp0, tag);
	if (error != 0)
		goto unlock;

	if (ISSET(ifp->if_flags, IFF_RUNNING)) {
		list = &tagh[TAG_HASH(ifv->ifv_tag)];
		SRPL_REMOVE_LOCKED(&vlan_tagh_rc, list, ifv, ifvlan, ifv_list);

		ifv->ifv_tag = tag;

		list = &tagh[TAG_HASH(ifv->ifv_tag)];
		SRPL_INSERT_HEAD_LOCKED(&vlan_tagh_rc, list, ifv, ifv_list);
	} else
		ifv->ifv_tag = tag;

unlock:
	rw_exit(&vlan_tagh_lk);

	if (ISSET(ifp->if_flags, IFF_RUNNING) && LINK_STATE_IS_UP(link))
		vlan_link_state(ifv, link, baud);

	return (error);
}

int
vlan_set_parent(struct ifvlan *ifv, const char *parent)
{
	struct ifnet *ifp = &ifv->ifv_if;
	struct ifnet *ifp0;
	int error = 0;

	ifp0 = ifunit(parent); /* doesn't need an if_put */
	if (ifp0 == NULL)
		return (EINVAL);

	if (ifp0->if_type != IFT_ETHER)
		return (EPROTONOSUPPORT);

	if (ifv->ifv_ifp0 == ifp0->if_index) {
		/* nop */
		return (0);
	}

	if (ISSET(ifp->if_flags, IFF_RUNNING))
		return (EBUSY);

	error = vlan_inuse(ifv->ifv_type, ifp0->if_index, ifv->ifv_tag);
	if (error != 0)
		return (error);

	/* commit */
	ifv->ifv_ifp0 = ifp0->if_index;
	if (!ISSET(ifv->ifv_flags, IFVF_LLADDR))
		if_setlladdr(ifp, LLADDR(ifp0->if_sadl));

	return (0);
}

int
vlan_del_parent(struct ifvlan *ifv)
{
	struct ifnet *ifp = &ifv->ifv_if;

	if (ISSET(ifp->if_flags, IFF_RUNNING))
		return (EBUSY);

	/* commit */
	ifv->ifv_ifp0 = 0;
	if (!ISSET(ifv->ifv_flags, IFVF_LLADDR))
		if_setlladdr(ifp, etheranyaddr);

	return (0);
}

int
vlan_set_compat(struct ifnet *ifp, struct ifreq *ifr)
{
	struct vlanreq vlr;
	struct ifreq req;
	struct if_parent parent;

	int error;

	error = suser(curproc, 0);
	if (error != 0)
		return (error);

	error = copyin(ifr->ifr_data, &vlr, sizeof(vlr));
	if (error != 0)
		return (error);

	if (vlr.vlr_parent[0] == '\0')
		return (vlan_ioctl(ifp, SIOCDIFPARENT, (caddr_t)ifr));

	memset(&req, 0, sizeof(req));
	memcpy(req.ifr_name, ifp->if_xname, sizeof(req.ifr_name));
	req.ifr_vnetid = vlr.vlr_tag;

	error = vlan_ioctl(ifp, SIOCSVNETID, (caddr_t)&req);
	if (error != 0)
		return (error);

	memset(&parent, 0, sizeof(parent));
	memcpy(parent.ifp_name, ifp->if_xname, sizeof(parent.ifp_name));
	memcpy(parent.ifp_parent, vlr.vlr_parent, sizeof(parent.ifp_parent));
	error = vlan_ioctl(ifp, SIOCSIFPARENT, (caddr_t)&parent);
	if (error != 0)
		return (error);

	memset(&req, 0, sizeof(req));
	memcpy(req.ifr_name, ifp->if_xname, sizeof(req.ifr_name));
	SET(ifp->if_flags, IFF_UP);
	return (vlan_ioctl(ifp, SIOCSIFFLAGS, (caddr_t)&req));
}

int
vlan_get_compat(struct ifnet *ifp, struct ifreq *ifr)
{
	struct ifvlan *ifv = ifp->if_softc;
	struct vlanreq vlr;
	struct ifnet *p;

	memset(&vlr, 0, sizeof(vlr));
	p = if_get(ifv->ifv_ifp0);
	if (p != NULL)
		memcpy(vlr.vlr_parent, p->if_xname, sizeof(vlr.vlr_parent));
	if_put(p);

	vlr.vlr_tag = ifv->ifv_tag;

	return (copyout(&vlr, ifr->ifr_data, sizeof(vlr)));
}

/*
 * do a quick check of up and running vlans for existing configurations.
 *
 * NOTE: this does allow the same config on down vlans, but vlan_up()
 * will catch them.
 */
int
vlan_inuse(uint16_t type, unsigned int ifidx, uint16_t tag)
{
	int error = 0;

	error = rw_enter(&vlan_tagh_lk, RW_READ | RW_INTR);
	if (error != 0)
		return (error);

	error = vlan_inuse_locked(type, ifidx, tag);

	rw_exit(&vlan_tagh_lk);

	return (error);
}

int
vlan_inuse_locked(uint16_t type, unsigned int ifidx, uint16_t tag)
{
	SRPL_HEAD(, ifvlan) *tagh, *list;
	struct ifvlan *ifv;

	tagh = type == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;
	list = &tagh[TAG_HASH(tag)];

	SRPL_FOREACH_LOCKED(ifv, list, ifv_list) {
		if (ifv->ifv_tag == tag &&
		    ifv->ifv_type == type && /* wat */
		    ifv->ifv_ifp0 == ifidx)
			return (EADDRINUSE);
	}

	return (0);
}

int
vlan_multi_add(struct ifvlan *ifv, struct ifreq *ifr)
{
	struct ifnet		*ifp0;
	struct vlan_mc_entry	*mc;
	u_int8_t		 addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int			 error;

	error = ether_addmulti(ifr, &ifv->ifv_ac);
	if (error != ENETRESET)
		return (error);

	/*
	 * This is new multicast address.  We have to tell parent
	 * about it.  Also, remember this multicast address so that
	 * we can delete them on unconfigure.
	 */
	if ((mc = malloc(sizeof(*mc), M_DEVBUF, M_NOWAIT)) == NULL) {
		error = ENOMEM;
		goto alloc_failed;
	}

	/*
	 * As ether_addmulti() returns ENETRESET, following two
	 * statement shouldn't fail.
	 */
	(void)ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &ifv->ifv_ac, mc->mc_enm);
	memcpy(&mc->mc_addr, &ifr->ifr_addr, ifr->ifr_addr.sa_len);
	LIST_INSERT_HEAD(&ifv->vlan_mc_listhead, mc, mc_entries);

	ifp0 = if_get(ifv->ifv_ifp0);
	error = (ifp0 == NULL) ? 0 :
	    (*ifp0->if_ioctl)(ifp0, SIOCADDMULTI, (caddr_t)ifr);
	if_put(ifp0);

	if (error != 0)
		goto ioctl_failed;

	return (error);

 ioctl_failed:
	LIST_REMOVE(mc, mc_entries);
	free(mc, M_DEVBUF, sizeof(*mc));
 alloc_failed:
	(void)ether_delmulti(ifr, &ifv->ifv_ac);

	return (error);
}

int
vlan_multi_del(struct ifvlan *ifv, struct ifreq *ifr)
{
	struct ifnet		*ifp0;
	struct ether_multi	*enm;
	struct vlan_mc_entry	*mc;
	u_int8_t		 addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int			 error;

	/*
	 * Find a key to lookup vlan_mc_entry.  We have to do this
	 * before calling ether_delmulti for obvious reason.
	 */
	if ((error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi)) != 0)
		return (error);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &ifv->ifv_ac, enm);
	if (enm == NULL)
		return (EINVAL);

	LIST_FOREACH(mc, &ifv->vlan_mc_listhead, mc_entries) {
		if (mc->mc_enm == enm)
			break;
	}

	/* We won't delete entries we didn't add */
	if (mc == NULL)
		return (EINVAL);

	error = ether_delmulti(ifr, &ifv->ifv_ac);
	if (error != ENETRESET)
		return (error);

	if (!ISSET(ifv->ifv_if.if_flags, IFF_RUNNING))
		goto forget;

	ifp0 = if_get(ifv->ifv_ifp0);
	error = (ifp0 == NULL) ? 0 :
	    (*ifp0->if_ioctl)(ifp0, SIOCDELMULTI, (caddr_t)ifr);
	if_put(ifp0);

	if (error != 0) {
		(void)ether_addmulti(ifr, &ifv->ifv_ac);
		return (error);
	}

forget:
	/* forget about this address */
	LIST_REMOVE(mc, mc_entries);
	free(mc, M_DEVBUF, sizeof(*mc));

	return (0);
}

int
vlan_media_get(struct ifvlan *ifv, struct ifreq *ifr)
{
	struct ifnet		*ifp0;
	int			 error;

	ifp0 = if_get(ifv->ifv_ifp0);
	error = (ifp0 == NULL) ? ENOTTY :
	    (*ifp0->if_ioctl)(ifp0, SIOCGIFMEDIA, (caddr_t)ifr);
	if_put(ifp0);

	return (error);
}

void
vlan_multi_apply(struct ifvlan *ifv, struct ifnet *ifp0, u_long cmd)
{
	struct vlan_mc_entry	*mc;
	union {
		struct ifreq ifreq;
		struct {
			char			ifr_name[IFNAMSIZ];
			struct sockaddr_storage	ifr_ss;
		} ifreq_storage;
	} ifreq;
	struct ifreq	*ifr = &ifreq.ifreq;

	memcpy(ifr->ifr_name, ifp0->if_xname, IFNAMSIZ);
	LIST_FOREACH(mc, &ifv->vlan_mc_listhead, mc_entries) {
		memcpy(&ifr->ifr_addr, &mc->mc_addr, mc->mc_addr.ss_len);

		(void)(*ifp0->if_ioctl)(ifp0, cmd, (caddr_t)ifr);
	}
}

void
vlan_multi_free(struct ifvlan *ifv)
{
	struct vlan_mc_entry	*mc;

	while ((mc = LIST_FIRST(&ifv->vlan_mc_listhead)) != NULL) {
		LIST_REMOVE(mc, mc_entries);
		free(mc, M_DEVBUF, sizeof(*mc));
	}
}
@


1.173
log
@make vlan use their parents lladdr all the time, not just when theyre up.

krw@@ has been having issues with dhclient on vlan interfaces because
i made them only configure the lladdr when they were brought up.
dhclient likes to read the mac address and then bring them up.

this makes vlan copy the parents lladdr onto the vlan interface
when the parent is configured. this probably helps with v6 addresses
on vlan interfaces too.

the new code still supports configuring a custom lladdr on a vlan
interface. this can be done both before and after a parent is
configured, and if a parent is removed.

while here, if the parent is reconfigured while the vlan is up, dont
error if the new parent is the same as the current one. this should
make running netstart again less noisy.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.172 2017/05/29 06:44:54 mpi Exp $	*/
d763 1
a763 1
	struct ifnet *ifp = &ifv->ifv_if;;
@


1.172
log
@Pass SIOCGIFMEDIA to vlan's parent interface.

ok krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.171 2017/01/24 10:08:30 krw Exp $	*/
d100 2
a476 2
	if (!ISSET(ifv->ifv_flags, IFVF_LLADDR))
		if_setlladdr(ifp, LLADDR(ifp0->if_sadl));
a527 2
	if (!ISSET(ifv->ifv_flags, IFVF_LLADDR))
		if_setlladdr(ifp, etheranyaddr);
a568 2
	if (!ISSET(ifv->ifv_flags, IFVF_LLADDR))
		if_setlladdr(ifp, etheranyaddr);
d673 1
a673 26
		if (ISSET(ifp->if_flags, IFF_RUNNING)) {
			error = EBUSY;
			break;
		}

		ifp0 = ifunit(parent->ifp_parent);
		if (ifp0 == NULL) {
			error = EINVAL;
			break;
		}

		if (ifv->ifv_ifp0 == ifp0->if_index) {
			/* nop */
			break;
		}

		if (ifp0->if_type != IFT_ETHER) {
			error = EPROTONOSUPPORT;
			break;
		}

		error = vlan_inuse(ifv->ifv_type, ifp0->if_index, ifv->ifv_tag);
		if (error != 0)
			break;

		ifv->ifv_ifp0 = ifp0->if_index;
d688 1
a688 6
		if (ISSET(ifp->if_flags, IFF_RUNNING)) {
			error = EBUSY;
			break;
		}

		ifv->ifv_ifp0 = 0;
d765 4
a768 1
	int flag = IFVF_LLADDR;
d771 6
a776 1
	if (memcmp(ifr->ifr_addr.sa_data, etheranyaddr, ETHER_ADDR_LEN) == 0)
d778 2
d781 3
a783 1
	if (ISSET(ifv->ifv_flags, IFVF_LLADDR) == flag)
a784 7

	/* if we're up and the mac is reset, inherit the parents mac */
	if (ISSET(ifp->if_flags, IFF_RUNNING) && flag == 0) {
		ifp0 = if_get(ifv->ifv_ifp0);
		if (ifp0 != NULL)
			if_setlladdr(ifp, LLADDR(ifp0->if_sadl));
		if_put(ifp0);
d787 2
d835 50
@


1.171
log
@A space here, a space there. Soon we're talking real whitespace
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.170 2017/01/24 03:57:35 dlg Exp $	*/
d108 2
d728 1
d733 8
d1065 14
@


1.170
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.169 2017/01/23 11:37:29 mpi Exp $	*/
d17 1
a17 1
 * 
d77 1
a77 1
#define TAG_HASH_SIZE		(1 << TAG_HASH_BITS) 
d989 1
a989 1
	if (error != 0) 
@


1.169
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.168 2017/01/22 10:17:39 dlg Exp $	*/
d88 1
a88 1
void	vlan_start(struct ifnet *ifp);
d178 1
a178 1
	ifp->if_start = vlan_start;
d241 1
a241 1
vlan_start(struct ifnet *ifp)
d243 1
d253 1
a253 1
		ifq_purge(&ifp->if_snd);
d257 1
a257 5
	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

d296 1
@


1.168
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.167 2016/10/10 02:44:17 dlg Exp $	*/
d177 1
a177 1
	ifp->if_xflags = IFXF_MPSAFE;
@


1.167
log
@ensure prepended ethernet headers are placed on ETHER_ALIGN boundaries,
even if m_prepend allocates a new mbuf in front of the current one.

this is done by asking M_PREPEND for ETHER_HDR_LEN + ETHER_ALIGN bytes,
and then calling m_adj(ETHER_ALIGN) after.

in the case M_PREPEND does not allocate a new mbuf and ends up with the
same layout as before.

in the allocation case, the requested length is provided on a long
boundary. an ETHER_HDR_LEN request would therefore be 6 bytes
allocated on a long boundary, when we want it to be at ETHER_ALIGN.
by asking for ETHER_HDR_LEN plus ETHER_ALIGN, we can m_adj ETHER_ALIGN
off to get us to the ETHER_ALIGN offset.

ok yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.166 2016/09/03 13:46:57 reyk Exp $	*/
a300 1
		ifp->if_opackets++;
@


1.166
log
@Add support for a multipoint-to-multipoint mode in vxlan(4).  In this
mode, vxlan(4) must be configured to accept any virtual network
identifier with "vnetid any" and added to a bridge(4) or switch(4).
This way the driver will dynamically learn the tunnel endpoints and
their vnetids for the responses and can be used to dynamically bridge
between VXLANs.  It is also being used in combination with switch(4)
and the OpenFlow tunnel classifiers.

With input from yasuoka@@ goda@@
OK deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.165 2016/05/18 03:46:03 dlg Exp $	*/
d318 1
a318 1
	M_PREPEND(m, sizeof(evh), M_DONTWAIT);
d321 2
@


1.165
log
@rework the srp api so it takes an srp_ref struct that the caller provides.

the srp_ref struct is used to track the location of the callers
hazard pointer so later calls to srp_follow and srp_enter already
know what to clear. this in turn means most of the caveats around
using srps go away. specifically, you can now:

- switch cpus while holding an srp ref
  - ie, you can sleep while holding an srp ref
- you can take and release srp refs in any order

the original intent was to simplify use of the api when dealing
with complicated data structures. the caller now no longer has to
track the location of the srp a value was fetched from, the srp_ref
effectively does that for you.

srp lists have been refactored to use srp_refs instead of srpl_iter
structs.

this is in preparation of using srps inside the ART code. ART is a
complicated data structure, and lookups require overlapping holds
of srp references.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.164 2016/04/19 23:32:15 dlg Exp $	*/
d651 6
a660 5
		if (tag < EVL_VLID_MIN || tag > EVL_VLID_MAX) {
			error = EINVAL;
			break;
		}

d668 1
a668 1
			ifr->ifr_vnetid = (uint32_t)ifv->ifv_tag;
@


1.164
log
@tabs, not spaces

no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.163 2016/04/19 23:31:32 dlg Exp $	*/
d338 1
a338 1
	struct srpl_iter		 i;
d373 1
a373 1
	SRPL_FOREACH(ifv, list, &i, ifv_list) {
d403 1
a403 1
	SRPL_LEAVE(&i, ifv);
d407 1
a407 1
	SRPL_LEAVE(&i, ifv);
@


1.163
log
@make setting a vlan interfaces lladdr more likely to work

the recent vlan code sets the vlan interfaces mac address to the
parent interfaces mac address when it is brought up, and resets it
when the vlan interface is brought down.

now, if you set a mac address manually (eg, ifconfig vlanX lladdr
f0:0b:a7:ba:2b:00), vlan(4) ignores the parents mac address and
never resets its own.

to make this work, setting a custom lladdr on a vlan interface makes
the parent interface promisc so the packets wont be filtered by the
hardware interface.

setting the mac address to 00:00:00:00:00:00 resets this behavior
and makes the interface inherit the parents mac again.

issue reported by and fix tested by paul de weerd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.162 2016/04/15 04:34:10 dlg Exp $	*/
d290 1
a290 1
                            (prio << EVL_PRIO_BITS));
d423 1
a423 1
        /* Register callback for physical link state changes */
@


1.162
log
@rename ifv_p to ifv_ifp0

this makes it more clear to the casual reader that it refers to the
parent interface, which is consistently referred to as ifp0 in the
rest of the vlan (and carp) code.

this is a good idea from mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.161 2016/04/15 04:29:59 dlg Exp $	*/
a94 2
int	vlan_promisc(struct ifvlan *, int);

d108 3
d474 2
a475 1
	if_setlladdr(ifp, LLADDR(ifp0->if_sadl));
d527 2
a528 1
	if_setlladdr(ifp, etheranyaddr);
d570 2
a571 1
	if_setlladdr(ifp, etheranyaddr);
a623 23
vlan_promisc(struct ifvlan *ifv, int promisc)
{
	struct ifnet *ifp0;
	int error = 0;

	if ((ISSET(ifv->ifv_flags, IFVF_PROMISC) ? 1 : 0) == promisc)
		return (0);

	ifp0 = if_get(ifv->ifv_ifp0);
	if (ifp0 != NULL) {
		error = ifpromisc(ifp0, promisc);
	}
	if_put(ifp0);

	if (error == 0) {
		CLR(ifv->ifv_flags, IFVF_PROMISC);
		SET(ifv->ifv_flags, promisc ? IFVF_PROMISC : 0);
	}

	return (error);
}

int
a638 5
		error = vlan_promisc(ifv,
		    ISSET(ifp->if_flags, IFF_PROMISC) ? 1 : 0);
		if (error != 0)
			break;

d642 2
d730 4
d746 5
d752 57
@


1.161
log
@rework vlan config to make it mpsafe and done by standard ioctls

configuration of the vlan parent interface and the vlan id should
come via the IFPARENT and VNETID ioctls now. the vlan specific
ioctls are still available via a compat layer, but that will go
away a bit further into this release cycle.

the parent interface may only be configured while the vlan is down.
the vnetid may be changed at runtime, but will generate link state
changes across that event.

the vlan is implicitily brought up when an address is assigned,
which brings it in line with all our other network drivers. the
legacy vlan ioctl still imply bringing the interface up because
that's what it used to do.

the code that brings vlans up and down is now simplified because
it no longer supports changing the parent at run time. most of that
code now adds state to the parent when bringing the vlan up, and
bringing the interface down just removes it in reverse.

these simplifications in turn make it possible for us to transmit
packets on vlan interfaces without holding the big lock, so its now
marked as MPSAFE.

ok jmatthew@@ sthen@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.160 2016/04/13 11:41:15 mpi Exp $	*/
d248 1
a248 1
	ifp0 = if_get(ifv->ifv_p);
d373 1
a373 1
		if (ifp0->if_index == ifv->ifv_p && tag == ifv->ifv_tag &&
d451 1
a451 1
	ifp0 = if_get(ifv->ifv_p);
d498 1
a498 1
	error = vlan_inuse_locked(ifv->ifv_type, ifv->ifv_p, ifv->ifv_tag);
d551 1
a551 1
	ifp0 = if_get(ifv->ifv_p);
d585 1
a585 1
	ifv->ifv_p = 0;
d597 1
a597 1
	ifp0 = if_get(ifv->ifv_p);
d628 1
a628 1
	ifp0 = if_get(ifv->ifv_p);
d708 1
a708 1
		if (ifv->ifv_p == ifp0->if_index) {
d722 1
a722 1
		ifv->ifv_p = ifp0->if_index;
d726 1
a726 1
		ifp0 = if_get(ifv->ifv_p);
d742 1
a742 1
		ifv->ifv_p = 0;
d785 1
a785 1
	error = vlan_inuse_locked(ifv->ifv_type, ifv->ifv_p, tag);
d858 1
a858 1
	p = if_get(ifv->ifv_p);
d902 1
a902 1
		    ifv->ifv_p == ifidx)
d940 1
a940 1
	ifp0 = if_get(ifv->ifv_p);
d994 1
a994 1
	ifp0 = if_get(ifv->ifv_p);
@


1.160
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.159 2016/04/04 01:55:44 dlg Exp $	*/
d83 4
d90 7
a96 7
int	vlan_unconfig(struct ifnet *ifp, struct ifnet *newp);
int	vlan_config(struct ifvlan *, struct ifnet *, u_int16_t);
void	vlan_vlandev_state(void *);
void	vlanattach(int count);
int	vlan_set_promisc(struct ifnet *ifp);
int	vlan_clone_create(struct if_clone *, int);
int	vlan_clone_destroy(struct ifnet *);
d98 6
d110 3
d175 2
d179 2
a180 1
	IFQ_SET_MAXLEN(&ifp->if_snd, 1);
d209 3
a211 1
	vlan_unconfig(ifp, NULL);
a220 7
void
vlan_ifdetach(void *ptr)
{
	struct ifvlan	*ifv = ptr;
	vlan_clone_destroy(&ifv->ifv_if);
}

d412 27
a438 1
vlan_config(struct ifvlan *ifv, struct ifnet *ifp0, u_int16_t tag)
d440 14
a453 8
	struct sockaddr_dl	*sdl1, *sdl2;
	SRPL_HEAD(, ifvlan)	*tagh, *list;
	u_int			 flags;

	if (ifp0->if_type != IFT_ETHER)
		return EPROTONOSUPPORT;
	if (ifp0->if_index == ifv->ifv_p && ifv->ifv_tag == tag) /* noop */
		return (0);
d455 4
a458 12
	/* Remember existing interface flags and reset the interface */
	flags = ifv->ifv_flags;
	vlan_unconfig(&ifv->ifv_if, ifp0);
	ifv->ifv_p = ifp0->if_index;
	ifv->ifv_if.if_baudrate = ifp0->if_baudrate;

	if (ifp0->if_capabilities & IFCAP_VLAN_MTU) {
		ifv->ifv_if.if_mtu = ifp0->if_mtu;
		ifv->ifv_if.if_hardmtu = ifp0->if_hardmtu;
	} else {
		ifv->ifv_if.if_mtu = ifp0->if_mtu - EVL_ENCAPLEN;
		ifv->ifv_if.if_hardmtu = ifp0->if_hardmtu - EVL_ENCAPLEN;
d461 3
a463 2
	ifv->ifv_if.if_flags = ifp0->if_flags &
	    (IFF_UP | IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST);
d465 3
a467 4
	/* Reset promisc mode on the interface and its parent */
	if (flags & IFVF_PROMISC) {
		ifv->ifv_if.if_flags |= IFF_PROMISC;
		vlan_set_promisc(&ifv->ifv_if);
d470 5
d480 2
a481 2
		ifv->ifv_if.if_capabilities = 0;
	} else if (ifp0->if_capabilities & IFCAP_VLAN_HWTAGGING) {
d490 1
a490 2
		ifv->ifv_if.if_capabilities = ifp0->if_capabilities &
		    IFCAP_CSUM_MASK;
d493 11
a503 10
	/*
	 * Set up our ``Ethernet address'' to reflect the underlying
	 * physical interface's.
	 */
	sdl1 = ifv->ifv_if.if_sadl;
	sdl2 = ifp0->if_sadl;
	sdl1->sdl_type = IFT_ETHER;
	sdl1->sdl_alen = ETHER_ADDR_LEN;
	bcopy(LLADDR(sdl2), LLADDR(sdl1), ETHER_ADDR_LEN);
	bcopy(LLADDR(sdl2), ifv->ifv_ac.ac_enaddr, ETHER_ADDR_LEN);
d505 8
a512 1
	ifv->ifv_tag = tag;
d514 1
a514 3
	/* Register callback for physical link state changes */
	ifv->lh_cookie = hook_establish(ifp0->if_linkstatehooks, 1,
	    vlan_vlandev_state, ifv);
d516 1
a516 3
	/* Register callback if parent wants to unregister */
	ifv->dh_cookie = hook_establish(ifp0->if_detachhooks, 0,
	    vlan_ifdetach, ifv);
d518 12
a529 1
	vlan_multi_apply(ifv, ifp0, SIOCADDMULTI);
d531 2
a532 1
	vlan_vlandev_state(ifv);
d534 6
a539 2
	/* Change input handler of the physical interface. */
	if_ih_insert(ifp0, vlan_input, NULL);
d542 1
a542 1
	list = &tagh[TAG_HASH(tag)];
d544 1
a544 3
	rw_enter_write(&vlan_tagh_lk);
	SRPL_INSERT_HEAD_LOCKED(&vlan_tagh_rc, list, ifv, ifv_list);
	rw_exit_write(&vlan_tagh_lk);
d546 2
a547 2
	return (0);
}
d549 1
a549 7
int
vlan_unconfig(struct ifnet *ifp, struct ifnet *newifp0)
{
	struct sockaddr_dl	*sdl;
	struct ifvlan		*ifv;
	SRPL_HEAD(, ifvlan)	*tagh, *list;
	struct ifnet		*ifp0;
a550 1
	ifv = ifp->if_softc;
d552 7
a558 7
	if (ifp0 == NULL)
		goto disconnect;

	/* Unset promisc mode on the interface and its parent */
	if (ifv->ifv_flags & IFVF_PROMISC) {
		ifp->if_flags &= ~IFF_PROMISC;
		vlan_set_promisc(ifp);
d560 1
a560 3

	tagh = ifv->ifv_type == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;
	list = &tagh[TAG_HASH(ifv->ifv_tag)];
d566 13
a578 2
	/* Restore previous input handler. */
	if_ih_remove(ifp0, vlan_input, NULL);
d580 3
a582 6
	hook_disestablish(ifp0->if_linkstatehooks, ifv->lh_cookie);
	hook_disestablish(ifp0->if_detachhooks, ifv->dh_cookie);
	/* Reset link state */
	if (newifp0 != NULL) {
		ifp->if_link_state = LINK_STATE_INVALID;
		if_link_state_change(ifp);
a584 10
	/*
 	 * Since the interface is being unconfigured, we need to
	 * empty the list of multicast groups that we may have joined
	 * while we were alive and remove them from the parent's list
	 * as well.
	 */
	vlan_multi_apply(ifv, ifp0, SIOCDELMULTI);

disconnect:
	/* Disconnect from parent. */
a585 14
	ifv->ifv_if.if_mtu = ETHERMTU;
	ifv->ifv_if.if_hardmtu = ETHERMTU;
	ifv->ifv_flags = 0;

	/* Clear our MAC address. */
	sdl = ifv->ifv_if.if_sadl;
	sdl->sdl_type = IFT_ETHER;
	sdl->sdl_alen = ETHER_ADDR_LEN;
	bzero(LLADDR(sdl), ETHER_ADDR_LEN);
	bzero(ifv->ifv_ac.ac_enaddr, ETHER_ADDR_LEN);

	if_put(ifp0);

	return (0);
d589 1
a589 1
vlan_vlandev_state(void *v)
d591 5
a595 4
	struct ifvlan	*ifv = v;
	struct ifnet	*ifp0;
	int		 link_state = LINK_STATE_DOWN;
	uint64_t	 baudrate = 0;
d599 2
a600 2
		link_state = ifp0->if_link_state;
		baudrate = ifp0->if_baudrate;
d604 7
a610 1
	if (ifv->ifv_if.if_link_state == link_state)
d613 3
a615 2
	ifv->ifv_if.if_link_state = link_state;
	ifv->ifv_if.if_baudrate = baudrate;
d620 1
a620 1
vlan_set_promisc(struct ifnet *ifp)
d622 5
a626 3
	struct ifvlan	*ifv = ifp->if_softc;
	struct ifnet	*ifp0;
	int		 error = 0;
d629 4
a632 2
	if (ifp0 == NULL)
		goto leave;
d634 3
a636 8
	if ((ifp->if_flags & IFF_PROMISC) != 0) {
		if ((ifv->ifv_flags & IFVF_PROMISC) == 0)
			if ((error = ifpromisc(ifp0, 1)) == 0)
				ifv->ifv_flags |= IFVF_PROMISC;
	} else {
		if ((ifv->ifv_flags & IFVF_PROMISC) != 0)
			if ((error = ifpromisc(ifp0, 0)) == 0)
				ifv->ifv_flags &= ~IFVF_PROMISC;
d639 1
a639 4
leave:
	if_put(ifp0);

	return (0);
d645 6
a650 11
	struct proc	*p = curproc;	/* XXX */
	struct ifaddr	*ifa;
	struct ifnet	*ifp0;
	struct ifreq	*ifr;
	struct ifvlan	*ifv;
	struct vlanreq	 vlr;
	int		 error = 0, s;

	ifr = (struct ifreq *)data;
	ifa = (struct ifaddr *)data;
	ifv = ifp->if_softc;
d654 24
a677 3
		if (ifv->ifv_p != 0)
			ifp->if_flags |= IFF_UP;
		else
d679 4
d685 6
a690 9
	case SIOCSIFMTU:
		if (ifv->ifv_p != 0) {
			if (ifr->ifr_mtu < ETHERMIN ||
			    ifr->ifr_mtu > ifv->ifv_if.if_hardmtu)
				error = EINVAL;
			else
				ifp->if_mtu = ifr->ifr_mtu;
		} else
			error = EINVAL;
d692 2
d696 3
a698 2
	case SIOCSETVLAN:
		if ((error = suser(p, 0)) != 0)
d700 5
a704 9
		if ((error = copyin(ifr->ifr_data, &vlr, sizeof vlr)))
			break;
		if (vlr.vlr_parent[0] == '\0') {
			s = splnet();
			vlan_unconfig(ifp, NULL);
			if (ifp->if_flags & IFF_UP)
				if_down(ifp);
			ifp->if_flags &= ~IFF_RUNNING;
			splx(s);
d707 3
a709 3
		ifp0 = ifunit(vlr.vlr_parent);
		if (ifp0 == NULL) {
			error = ENOENT;
d712 3
a714 6
		/*
		 * Don't let the caller set up a VLAN tag with
		 * anything except VLID bits.
		 */
		if (vlr.vlr_tag & ~EVL_VLID_MASK) {
			error = EINVAL;
d717 3
a719 2
		error = vlan_config(ifv, ifp0, vlr.vlr_tag);
		if (error)
a720 1
		ifp->if_flags |= IFF_RUNNING;
d722 1
a722 2
		/* Update promiscuous mode, if necessary. */
		vlan_set_promisc(ifp);
d724 2
a725 3
		
	case SIOCGETVLAN:
		bzero(&vlr, sizeof vlr);
d727 5
a731 4
		if (ifp0) {
			snprintf(vlr.vlr_parent, sizeof(vlr.vlr_parent),
			    "%s", ifp0->if_xname);
			vlr.vlr_tag = ifv->ifv_tag;
a733 1
		error = copyout(&vlr, ifr->ifr_data, sizeof vlr);
d735 8
a742 7
	case SIOCSIFFLAGS:
		/*
		 * For promiscuous mode, we enable promiscuous mode on
		 * the parent if we need promiscuous on the VLAN interface.
		 */
		if (ifv->ifv_p != 0)
			error = vlan_set_promisc(ifp);
a747 1

d751 8
d760 2
a761 1
		error = ENOTTY;
d763 1
d767 141
@


1.159
log
@turns out EVL_ENCAPLEN is 4, not 18 or sizeof(*evl).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.158 2016/03/29 13:55:42 dlg Exp $	*/
a164 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.158
log
@the stack checks the mac address of rxed packets, so vlan(4) doesnt have to

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.157 2016/03/29 04:33:16 dlg Exp $	*/
d386 2
a387 2
		memmove((char *)eh + sizeof(*evl), eh, sizeof(*eh));
		m_adj(m, sizeof(*evl));
@


1.157
log
@use sizeof(*evl) instead of EVL_ENCAPLEN in vlan_input
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.156 2016/03/28 13:05:22 dlg Exp $	*/
a375 12

	/*
	 * Drop promiscuously received packets if we are not in
	 * promiscuous mode.
	 */
	if (!ETHER_IS_MULTICAST(eh->ether_dhost) &&
	    (ifp0->if_flags & IFF_PROMISC) &&
	    (ifv->ifv_if.if_flags & IFF_PROMISC) == 0) {
		if (bcmp(&ifv->ifv_ac.ac_enaddr, eh->ether_dhost,
		    ETHER_ADDR_LEN))
			goto drop;
	}
@


1.156
log
@turn ifv_p into an interface index instead of a real pointer to the parent

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.155 2016/03/18 02:40:04 dlg Exp $	*/
d339 2
a340 2
		if (m->m_len < EVL_ENCAPLEN &&
		    (m = m_pullup(m, EVL_ENCAPLEN)) == NULL) {
d398 2
a399 2
		memmove((char *)eh + EVL_ENCAPLEN, eh, sizeof(*eh));
		m_adj(m, EVL_ENCAPLEN);
@


1.155
log
@refactor the vlan multicast list handling.

the previous code had vlan_ether_purgemulti and vlan_ether_resetmulti,
both of which did too many things. purgemulti would try and remove
the multicast entries from the parent, and then free the local
copies of the addresses. resetmulti would try to remove the address
from the parent, and then optionally try to add them to a new parent.

resetmulti in particular makes the overall vlan config steps fairly
twisty.

the refactor offers vlan_multi_apply, and vlan_multi_free. multi_apply
simply adds or removes the multicast addresses from a parent
interface. it is now up to the config steps to call them appropriately
when configuring a parent or a new parent. vlan_multi_free only
deletes the memory associated with the vlans multicast addresses.

vlan_multi_apply is called when a parent is configured (ie, ifconfig
vlan0 up), or unconfigured (ifconfig vlan0 down or a detach of the
parent). vlan_multi_free is called when a vlan interface is destroyed
(ifconfig vlan0 destroy).

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.154 2016/03/13 11:44:22 dlg Exp $	*/
d238 6
a243 1
	ifp0 = ifv->ifv_p;
a254 6
		if ((ifp0->if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING)) {
			ifp->if_oerrors++;
			m_freem(m);
			continue;
		}
d292 3
d363 1
a363 1
		if (ifp0 == ifv->ifv_p && tag == ifv->ifv_tag &&
d422 1
a422 1
	if (ifv->ifv_p == ifp0 && ifv->ifv_tag == tag) /* noop */
d428 1
a428 1
	ifv->ifv_p = ifp0;
d514 3
a516 2
	if ((ifp0 = ifv->ifv_p) == NULL)
		return 0;
d550 1
d552 1
a552 1
	ifv->ifv_p = NULL;
d564 2
d573 3
d577 8
a584 1
	if (ifv->ifv_if.if_link_state == ifv->ifv_p->if_link_state)
d587 2
a588 2
	ifv->ifv_if.if_link_state = ifv->ifv_p->if_link_state;
	ifv->ifv_if.if_baudrate = ifv->ifv_p->if_baudrate;
d596 1
d599 4
d605 1
a605 1
			if ((error = ifpromisc(ifv->ifv_p, 1)) == 0)
d609 1
a609 1
			if ((error = ifpromisc(ifv->ifv_p, 0)) == 0)
d612 4
d636 1
a636 1
		if (ifv->ifv_p != NULL)
d643 1
a643 1
		if (ifv->ifv_p != NULL) {
d692 2
a693 1
		if (ifv->ifv_p) {
d695 1
a695 1
			    "%s", ifv->ifv_p->if_xname);
d698 1
d706 1
a706 1
		if (ifv->ifv_p != NULL)
d755 1
a755 1
	ifp0 = ifv->ifv_p;
d758 1
d809 1
a809 1
	ifp0 = ifv->ifv_p;
d812 1
@


1.154
log
@i forgot to rename p to ifp0 in vlan_config

still no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.153 2016/03/13 04:37:37 dlg Exp $	*/
a90 4
int	vlan_ether_addmulti(struct ifvlan *, struct ifreq *);
int	vlan_ether_delmulti(struct ifvlan *, struct ifreq *);
void	vlan_ether_purgemulti(struct ifvlan *);
void	vlan_ether_resetmulti(struct ifvlan *, struct ifnet *);
d95 5
d198 1
d486 2
d545 1
a545 1
	vlan_ether_resetmulti(ifv, newifp0);
d684 1
a684 2
		error = (ifv->ifv_p != NULL) ?
		    vlan_ether_addmulti(ifv, ifr) : EINVAL;
d688 1
a688 2
		error = (ifv->ifv_p != NULL) ?
		    vlan_ether_delmulti(ifv, ifr) : EINVAL;
d698 1
a698 1
vlan_ether_addmulti(struct ifvlan *ifv, struct ifreq *ifr)
d700 1
a700 1
	struct ifnet		*ifp0 = ifv->ifv_p;
d705 1
a705 1
	error = ether_addmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
d728 5
a732 1
	if ((error = (*ifp0->if_ioctl)(ifp0, SIOCADDMULTI, (caddr_t)ifr)) != 0)
d739 1
a739 1
	free(mc, M_DEVBUF, sizeof *mc);
d741 1
a741 1
	(void)ether_delmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
d747 1
a747 1
vlan_ether_delmulti(struct ifvlan *ifv, struct ifreq *ifr)
d749 1
a749 1
	struct ifnet		*ifp0 = ifv->ifv_p;
d765 1
a765 1
	LIST_FOREACH(mc, &ifv->vlan_mc_listhead, mc_entries)
d768 1
d774 2
a775 1
	if ((error = ether_delmulti(ifr, (struct arpcom *)&ifv->ifv_ac)) != 0)
d778 18
a795 8
	/* We no longer use this multicast address.  Tell parent so. */
	if ((error = (*ifp0->if_ioctl)(ifp0, SIOCDELMULTI, (caddr_t)ifr)) != 0) {
		/* And forget about this address. */
		LIST_REMOVE(mc, mc_entries);
		free(mc, M_DEVBUF, sizeof *mc);
	} else
		(void)ether_addmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	return (error);
a797 4
/*
 * Delete any multicast address we have asked to add from parent
 * interface.  Called when the vlan is being unconfigured.
 */
d799 1
a799 1
vlan_ether_purgemulti(struct ifvlan *ifv)
a800 1
	struct ifnet		*ifp0 = ifv->ifv_p;
d812 1
a812 1
	while ((mc = LIST_FIRST(&ifv->vlan_mc_listhead)) != NULL) {
d814 2
a815 3
		(void)(*ifp0->if_ioctl)(ifp0, SIOCDELMULTI, (caddr_t)ifr);
		LIST_REMOVE(mc, mc_entries);
		free(mc, M_DEVBUF, sizeof *mc);
d820 1
a820 1
vlan_ether_resetmulti(struct ifvlan *ifv, struct ifnet *newifp0)
a821 1
	struct ifnet		*ifp0 = ifv->ifv_p;
a822 8
	union {
		struct ifreq ifreq;
		struct {
			char			ifr_name[IFNAMSIZ];
			struct sockaddr_storage	ifr_ss;
		} ifreq_storage;
	} ifreq;
	struct ifreq	*ifr = &ifreq.ifreq;
d824 3
a826 16
	if (newifp0 == NULL) {
		vlan_ether_purgemulti(ifv);
		return;
	} else if (ifp0 == newifp0)
		return;

	LIST_FOREACH(mc, &ifv->vlan_mc_listhead, mc_entries) {
		memcpy(&ifr->ifr_addr, &mc->mc_addr, mc->mc_addr.ss_len);
	
		/* Remove from the old parent */
		memcpy(ifr->ifr_name, ifp0->if_xname, IFNAMSIZ);
		(void)(*ifp0->if_ioctl)(ifp0, SIOCDELMULTI, (caddr_t)ifr);

		/* Try to add to the new parent */
		memcpy(ifr->ifr_name, newifp0->if_xname, IFNAMSIZ);
		(void)(*newifp0->if_ioctl)(newifp0, SIOCADDMULTI, (caddr_t)ifr);
@


1.153
log
@consistencly name ifnet pointers like we did in carp

the vlan interface is ifp, the vlans parent interface is ifp0, the new
interface parent is newifp0.

requested by mpi@@
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.152 2016/03/03 02:53:28 dlg Exp $	*/
d410 1
a410 1
vlan_config(struct ifvlan *ifv, struct ifnet *p, u_int16_t tag)
d416 1
a416 1
	if (p->if_type != IFT_ETHER)
d418 1
a418 1
	if (ifv->ifv_p == p && ifv->ifv_tag == tag) /* noop */
d423 7
a429 7
	vlan_unconfig(&ifv->ifv_if, p);
	ifv->ifv_p = p;
	ifv->ifv_if.if_baudrate = p->if_baudrate;

	if (p->if_capabilities & IFCAP_VLAN_MTU) {
		ifv->ifv_if.if_mtu = p->if_mtu;
		ifv->ifv_if.if_hardmtu = p->if_hardmtu;
d431 2
a432 2
		ifv->ifv_if.if_mtu = p->if_mtu - EVL_ENCAPLEN;
		ifv->ifv_if.if_hardmtu = p->if_hardmtu - EVL_ENCAPLEN;
d435 1
a435 1
	ifv->ifv_if.if_flags = p->if_flags &
d450 1
a450 1
	} else if (p->if_capabilities & IFCAP_VLAN_HWTAGGING) {
d459 1
a459 1
		ifv->ifv_if.if_capabilities = p->if_capabilities &
d468 1
a468 1
	sdl2 = p->if_sadl;
d477 1
a477 1
	ifv->lh_cookie = hook_establish(p->if_linkstatehooks, 1,
d481 1
a481 1
	ifv->dh_cookie = hook_establish(p->if_detachhooks, 0,
d487 1
a487 1
	if_ih_insert(p, vlan_input, NULL);
@


1.152
log
@factor out the injection of a vlan shim into an ethernet frame

vlan_inject() will be reused by mpw(4) in the future.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.151 2016/01/13 03:18:26 dlg Exp $	*/
d231 1
a231 1
	struct ifnet	*p;
d236 1
a236 1
	p = ifv->ifv_p;
d248 1
a248 1
		if ((p->if_flags & (IFF_UP|IFF_RUNNING)) !=
d271 1
a271 1
		} else if ((p->if_capabilities & IFCAP_VLAN_HWTAGGING) &&
d285 1
a285 1
		if (if_enqueue(p, m)) {
d317 1
a317 1
vlan_input(struct ifnet *ifp, struct mbuf *m, void *cookie)
d337 1
a337 1
			ifp->if_ierrors++;
d359 1
a359 1
		if (ifp == ifv->ifv_p && tag == ifv->ifv_tag &&
d365 1
a365 1
		ifp->if_noproto++;
d378 1
a378 1
	    (ifp->if_flags & IFF_PROMISC) &&
d500 1
a500 1
vlan_unconfig(struct ifnet *ifp, struct ifnet *newp)
d505 1
a505 1
	struct ifnet		*p;
d508 1
a508 1
	if ((p = ifv->ifv_p) == NULL)
d525 1
a525 1
	if_ih_remove(p, vlan_input, NULL);
d527 2
a528 2
	hook_disestablish(p->if_linkstatehooks, ifv->lh_cookie);
	hook_disestablish(p->if_detachhooks, ifv->dh_cookie);
d530 1
a530 1
	if (newp != NULL) {
d541 1
a541 1
	vlan_ether_resetmulti(ifv, newp);
d595 1
a595 1
	struct ifnet	*pr;
d639 2
a640 2
		pr = ifunit(vlr.vlr_parent);
		if (pr == NULL) {
d652 1
a652 1
		error = vlan_config(ifv, pr, vlr.vlr_tag);
d698 1
a698 1
	struct ifnet		*ifp = ifv->ifv_p;
d726 1
a726 1
	if ((error = (*ifp->if_ioctl)(ifp, SIOCADDMULTI, (caddr_t)ifr)) != 0)
d743 1
a743 1
	struct ifnet		*ifp = ifv->ifv_p;
d771 1
a771 1
	if ((error = (*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr)) != 0) {
d787 1
a787 1
	struct ifnet		*ifp = ifv->ifv_p;
d798 1
a798 1
	memcpy(ifr->ifr_name, ifp->if_xname, IFNAMSIZ);
d801 1
a801 1
		(void)(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
d808 1
a808 1
vlan_ether_resetmulti(struct ifvlan *ifv, struct ifnet *p)
d810 1
a810 1
	struct ifnet		*ifp = ifv->ifv_p;
d821 1
a821 1
	if (p == NULL) {
d824 1
a824 1
	} else if (ifp == p)
d831 2
a832 2
		memcpy(ifr->ifr_name, ifp->if_xname, IFNAMSIZ);
		(void)(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
d835 2
a836 2
		memcpy(ifr->ifr_name, p->if_xname, IFNAMSIZ);
		(void)(*p->if_ioctl)(p, SIOCADDMULTI, (caddr_t)ifr);
@


1.151
log
@dont propagate any of the parent interfaces offload features on svlan

this avoids confusion about checksum offload if you configure ips
on svlan interfaces on top of interfaces that do offload, like bge
or em.

the problem was reported by and this fix was tested by denis fondras
analyzed by naddy@@
thanks guys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.150 2015/12/08 11:35:42 dlg Exp $	*/
d277 2
a278 9
			struct ether_vlan_header evh;

			m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&evh);
			evh.evl_proto = evh.evl_encap_proto;
			evh.evl_encap_proto = htons(ifv->ifv_type);
			evh.evl_tag = htons(ifv->ifv_tag +
			    (prio << EVL_PRIO_BITS));
			m_adj(m, ETHER_HDR_LEN);
			M_PREPEND(m, sizeof(evh), M_DONTWAIT);
a282 2
			m_copyback(m, 0, sizeof(evh), &evh, M_NOWAIT);
			m->m_flags &= ~M_VLANTAG;
d292 20
@


1.150
log
@vlan doenst have to handle SIOCGIFADDR cos the stack does it.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.149 2015/12/05 10:07:55 tedu Exp $	*/
d433 15
a447 9
	/*
	 * If the parent interface can do hardware-assisted
	 * VLAN encapsulation, then propagate its hardware-
	 * assisted checksumming flags.
	 *
	 * If the card cannot handle hardware tagging, it cannot
	 * possibly compute the correct checksums for tagged packets.
	 */
	if (p->if_capabilities & IFCAP_VLAN_HWTAGGING)
d450 1
a450 7

	/*
	 * Hardware VLAN tagging only works with the default VLAN
	 * ethernet type (0x8100).
	 */
	if (ifv->ifv_type != ETHERTYPE_VLAN)
		ifv->ifv_if.if_capabilities &= ~IFCAP_VLAN_HWTAGGING;
@


1.149
log
@remove old lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.148 2015/12/03 16:27:32 mpi Exp $	*/
a599 10
		break;

	case SIOCGIFADDR:
		{
			struct sockaddr	*sa;

			sa = (struct sockaddr *)&ifr->ifr_data;
			bcopy(((struct arpcom *)ifp->if_softc)->ac_enaddr,
			    (caddr_t) sa->sa_data, ETHER_ADDR_LEN);
		}
@


1.148
log
@Use SRPL_HEAD() and SRPL_ENTRY() to be consistent with and allow to
fallback to a SLIST.

ok dlg@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.147 2015/11/10 06:34:35 dlg Exp $	*/
a108 1
/* ARGSUSED */
@


1.147
log
@dont use IF_DROP when there was some arbitary problem sending a packet.

IF_DROP increments the drop counter on the send queue, it exists
to indicate a drop on the send queue. if there was an error sending
a packet be content incrementing if_oerrors.

ok mpi@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.146 2015/10/25 12:05:40 mpi Exp $	*/
d80 1
a80 1
struct srpl *vlan_tagh, *svlan_tagh;
d312 1
a312 1
	struct srpl			*tagh, *list;
d403 1
a403 1
	struct srpl		*tagh, *list;
d494 1
a494 1
	struct srpl		*tagh, *list;
@


1.146
log
@arp_ifinit() is no longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.145 2015/10/05 19:05:09 uebayasi Exp $	*/
a250 1
			IF_DROP(&p->if_snd);
@


1.145
log
@Revert if_oqdrops accounting changes done in kernel, per request from mpi@@.

(Especially adding IF_DROP() after IFQ_ENQUEUE() was completely wrong because
IFQ_ENQUEUE() already does it.  Oops.)

After this revert, the situation becomes:

- if_snd.ifq_drops is incremented in either IFQ_ENQUEUE() or IF_DROP(), but
  it is not shown to userland, and

- if_data.ifi_oqdrops is shown to userland, but it is not incremented by
  anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d598 1
a598 1
		if (ifv->ifv_p != NULL) {
d600 1
a600 3
			if (ifa->ifa_addr->sa_family == AF_INET)
				arp_ifinit(&ifv->ifv_ac, ifa);
		} else
@


1.144
log
@Don't count IF_DROP()'ed packets as if_oerrors too.

mpi@@ plans to clean-up IF_DROP()'s, but fix consistent use of it for now.

OK dlg@@
@
text
@d252 1
@


1.143
log
@add sizes to some of the simpler free calls
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.142 2015/09/13 10:02:36 dlg Exp $	*/
a251 1
			ifp->if_oerrors++;
@


1.142
log
@replace hand rolled reference counting with refcnts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.141 2015/09/13 09:46:45 dlg Exp $	*/
d736 1
a736 1
	free(mc, M_DEVBUF, 0);
d777 1
a777 1
		free(mc, M_DEVBUF, 0);
d806 1
a806 1
		free(mc, M_DEVBUF, 0);
@


1.141
log
@reintroduce mpsafe vlan_input.

the last commit was missing SRPL_INITs of the vlan_tagh buckets,
which was in a different tree to the one i committed from.

apologise to naddy@@ again
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.139 2015/09/12 20:46:40 dlg Exp $	*/
a59 2
#include <sys/atomic.h>
#include <sys/proc.h>
d160 1
a160 1
	ifv->ifv_refs = 1;
d178 1
a178 1
	atomic_inc_int(&ifv->ifv_refs);
d186 1
a186 2
	if (atomic_dec_int_nv(&ifv->ifv_refs) == 0)
		wakeup(&ifv->ifv_refs);
a192 2
	struct sleep_state sls;
	u_int refs;
d197 1
a197 11

	refs = atomic_dec_int_nv(&ifv->ifv_refs);
	while (refs) {
		sleep_setup(&sls, &ifv->ifv_refs, PWAIT, "vlandel");

		membar_consumer();
		refs = ifv->ifv_refs;

		sleep_finish(&sls, refs);
	}

@


1.140
log
@back out mpsafe vlans while i chase down a panic when operations
are done in a certain order.

panic found by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.138 2015/09/10 17:32:32 dlg Exp $	*/
d60 3
d78 6
a83 6
u_long vlan_tagmask, svlan_tagmask;

#define TAG_HASH_SIZE		32
#define TAG_HASH(tag)		(tag & vlan_tagmask)
LIST_HEAD(vlan_taghash, ifvlan)	*vlan_tagh, *svlan_tagh;

d106 5
d115 2
d118 2
a119 2
	vlan_tagh = hashinit(TAG_HASH_SIZE, M_DEVBUF, M_NOWAIT,
	    &vlan_tagmask);
a121 1
	if_clone_attach(&vlan_cloner);
d124 2
a125 2
	svlan_tagh = hashinit(TAG_HASH_SIZE, M_DEVBUF, M_NOWAIT,
	    &svlan_tagmask);
d128 7
d144 2
a145 1
	if ((ifv = malloc(sizeof(*ifv), M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
d162 2
d175 17
d196 2
d202 11
d214 1
d328 2
a329 1
	struct vlan_taghash		*tagh;
d363 2
a364 1
	LIST_FOREACH(ifv, &tagh[TAG_HASH(tag)], ifv_list) {
d372 1
a372 2
		m_freem(m);
		return (1);
d376 2
a377 4
	    (IFF_UP|IFF_RUNNING)) {
		m_freem(m);
		return (1);
	}
d387 2
a388 4
		    ETHER_ADDR_LEN)) {
			m_freem(m);
			return (1);
		}
d406 6
d419 1
a419 1
	struct vlan_taghash	*tagh;
a420 1
	int			 s;
d492 3
d496 1
d498 3
a500 6
	s = splnet();
	LIST_INSERT_HEAD(&tagh[TAG_HASH(tag)], ifv, ifv_list);
	splx(s);

        /* Change input handler of the physical interface. */
	if_ih_insert(p, vlan_input, NULL);
d510 1
a511 1
	int			 s;
d523 6
a528 3
	s = splnet();
	LIST_REMOVE(ifv, ifv_list);
	splx(s);
@


1.139
log
@make vlan_input mpsafe by using srp lists in the vlan tag hash buckets.

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.135 2015/07/20 22:16:41 rzalamena Exp $	*/
a59 3
#include <sys/atomic.h>
#include <sys/proc.h>
#include <sys/rwlock.h>
d75 6
a80 6
#define TAG_HASH_BITS		5
#define TAG_HASH_SIZE		(1 << TAG_HASH_BITS) 
#define TAG_HASH_MASK		(TAG_HASH_SIZE - 1)
#define TAG_HASH(tag)		(tag & TAG_HASH_MASK)
struct srpl *vlan_tagh, *svlan_tagh;
struct rwlock vlan_tagh_lk = RWLOCK_INITIALIZER("vlantag");
a102 5
void vlan_ref(void *, void *);
void vlan_unref(void *, void *);

struct srpl_rc vlan_tagh_rc = SRPL_RC_INITIALIZER(vlan_ref, vlan_unref, NULL);

d108 2
a109 2
	vlan_tagh = mallocarray(TAG_HASH_SIZE, sizeof(*vlan_tagh),
	    M_DEVBUF, M_NOWAIT);
d115 2
a116 2
	svlan_tagh = mallocarray(TAG_HASH_SIZE, sizeof(*svlan_tagh),
	    M_DEVBUF, M_NOWAIT);
d128 1
a128 2
	ifv = malloc(sizeof(*ifv), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (ifv == NULL)
a144 2
	ifv->ifv_refs = 1;

a155 17
void
vlan_ref(void *null, void *v)
{
	struct ifvlan *ifv = v;

	atomic_inc_int(&ifv->ifv_refs);
}

void
vlan_unref(void *null, void *v)
{
	struct ifvlan *ifv = v;

	if (atomic_dec_int_nv(&ifv->ifv_refs) == 0)
		wakeup(&ifv->ifv_refs);
}

a159 2
	struct sleep_state sls;
	u_int refs;
a163 11

	refs = atomic_dec_int_nv(&ifv->ifv_refs);
	while (refs) {
		sleep_setup(&sls, &ifv->ifv_refs, PWAIT, "vlandel");

		membar_consumer();
		refs = ifv->ifv_refs;

		sleep_finish(&sls, refs);
	}

a164 1

d278 1
a278 2
	struct srpl			*tagh, *list;
	struct srpl_iter		 i;
d312 1
a312 2
	list = &tagh[TAG_HASH(tag)];
	SRPL_FOREACH(ifv, list, &i, ifv_list) {
d320 2
a321 1
		goto drop;
d325 4
a328 2
	    (IFF_UP|IFF_RUNNING))
		goto drop;
d338 4
a341 2
		    ETHER_ADDR_LEN))
			goto drop;
a358 6
	SRPL_LEAVE(&i, ifv);
	return (1);

drop:
	SRPL_LEAVE(&i, ifv);
	m_freem(m);
d366 1
a366 1
	struct srpl		*tagh, *list;
d368 1
d440 1
a440 2
	/* Change input handler of the physical interface. */
	if_ih_insert(p, vlan_input, NULL);
d442 3
a444 2
	tagh = ifv->ifv_type == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;
	list = &tagh[TAG_HASH(tag)];
d446 2
a447 3
	rw_enter_write(&vlan_tagh_lk);
	SRPL_INSERT_HEAD_LOCKED(&vlan_tagh_rc, list, ifv, ifv_list);
	rw_exit_write(&vlan_tagh_lk);
a456 1
	struct srpl		*tagh, *list;
d458 1
d470 3
a472 6
	tagh = ifv->ifv_type == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;
	list = &tagh[TAG_HASH(ifv->ifv_tag)];

	rw_enter_write(&vlan_tagh_lk);
	SRPL_REMOVE_LOCKED(&vlan_tagh_rc, list, ifv, ifvlan, ifv_list);
	rw_exit_write(&vlan_tagh_lk);
@


1.138
log
@if_put after if_get

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.137 2015/09/10 16:41:30 mikeb Exp $	*/
d60 3
d78 6
a83 6
u_long vlan_tagmask, svlan_tagmask;

#define TAG_HASH_SIZE		32
#define TAG_HASH(tag)		(tag & vlan_tagmask)
LIST_HEAD(vlan_taghash, ifvlan)	*vlan_tagh, *svlan_tagh;

d106 5
d116 2
a117 2
	vlan_tagh = hashinit(TAG_HASH_SIZE, M_DEVBUF, M_NOWAIT,
	    &vlan_tagmask);
d123 2
a124 2
	svlan_tagh = hashinit(TAG_HASH_SIZE, M_DEVBUF, M_NOWAIT,
	    &svlan_tagmask);
d136 2
a137 1
	if ((ifv = malloc(sizeof(*ifv), M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
d154 2
d167 17
d188 2
d194 11
d206 1
d320 2
a321 1
	struct vlan_taghash		*tagh;
d355 2
a356 1
	LIST_FOREACH(ifv, &tagh[TAG_HASH(tag)], ifv_list) {
d364 1
a364 2
		m_freem(m);
		return (1);
d368 2
a369 4
	    (IFF_UP|IFF_RUNNING)) {
		m_freem(m);
		return (1);
	}
d379 2
a380 4
		    ETHER_ADDR_LEN)) {
			m_freem(m);
			return (1);
		}
d398 6
d411 1
a411 1
	struct vlan_taghash	*tagh;
a412 1
	int			 s;
d484 3
d488 1
d490 3
a492 6
	s = splnet();
	LIST_INSERT_HEAD(&tagh[TAG_HASH(tag)], ifv, ifv_list);
	splx(s);

        /* Change input handler of the physical interface. */
	if_ih_insert(p, vlan_input, NULL);
d502 1
a503 1
	int			 s;
d515 6
a520 3
	s = splnet();
	LIST_REMOVE(ifv, ifv_list);
	splx(s);
@


1.137
log
@pass a cookie argument to interface input handlers that can be used
to pass additional context or transient data with the similar life
time.

ok mpi, suggestions, hand holding and ok from dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.136 2015/09/10 13:32:19 dlg Exp $	*/
d175 18
a226 2
#if NMPW > 0
		struct ifnet *ifpn = if_get(m->m_pkthdr.ph_ifidx);
d231 1
a231 1
		if (ifpn && ifpn->if_type == IFT_MPLSTUNNEL) {
d233 1
a233 2
		} else
#endif /* NMPW */
d238 1
a238 1
		if ((p->if_capabilities & IFCAP_VLAN_HWTAGGING) &&
@


1.136
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.135 2015/07/20 22:16:41 rzalamena Exp $	*/
d82 1
a82 1
int	vlan_input(struct ifnet *, struct mbuf *);
d258 1
a258 1
vlan_input(struct ifnet *ifp, struct mbuf *m)
d432 1
a432 1
	if_ih_insert(p, vlan_input);
d458 1
a458 1
 
d460 1
a460 1
	if_ih_remove(p, vlan_input);
@


1.135
log
@Implemented MPLS pseudowire (mpw(4)) to be used with VPLS and VPWS.

ok mpi@@, claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.134 2015/07/02 09:40:02 mpi Exp $	*/
a359 11
	/* Can we share an ifih between multiple vlan(4) instances? */
	ifv->ifv_ifih = SLIST_FIRST(&p->if_inputs);
	if (ifv->ifv_ifih->ifih_input != vlan_input) {
		ifv->ifv_ifih = malloc(sizeof(*ifv->ifv_ifih), M_DEVBUF,
		    M_NOWAIT);
		if (ifv->ifv_ifih == NULL)
			return (ENOMEM);
		ifv->ifv_ifih->ifih_input = vlan_input;
		ifv->ifv_ifih->ifih_refcnt = 0;
	}

a427 4
	/* Change input handler of the physical interface. */
	if (++ifv->ifv_ifih->ifih_refcnt == 1)
		SLIST_INSERT_HEAD(&p->if_inputs, ifv->ifv_ifih, ifih_next);

d431 3
d457 2
a458 1

d460 1
a460 5
	if (--ifv->ifv_ifih->ifih_refcnt == 0) {
		SLIST_REMOVE(&p->if_inputs, ifv->ifv_ifih, ifih, ifih_next);
		free(ifv->ifv_ifih, M_DEVBUF, sizeof(*ifv->ifv_ifih));
	}
	splx(s);
@


1.135.4.1
log
@By creating, changing and destroying vlan interfaces multiple times,
root could crash the OpenBSD 5.8 kernel with ifconfig.  The reference
counting of ifv_ifih in vlan_config() was wrong, so a use after
free was possible.  Reordering the operations fixes it.
Neither 5.7 nor -current is affected.
OK mpi@@ sthen@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.135 2015/07/20 22:16:41 rzalamena Exp $	*/
a349 1
	struct ifih		*vlan_ifih;
d361 3
a363 3
	vlan_ifih = SLIST_FIRST(&p->if_inputs);
	if (vlan_ifih->ifih_input != vlan_input) {
		vlan_ifih = malloc(sizeof(*vlan_ifih), M_DEVBUF,
d365 1
a365 1
		if (vlan_ifih == NULL)
d367 2
a368 2
		vlan_ifih->ifih_input = vlan_input;
		vlan_ifih->ifih_refcnt = 0;
a369 2
	/* Do not free our reference during vlan_unconfig() */
	++vlan_ifih->ifih_refcnt;
d440 2
a441 3
	ifv->ifv_ifih = vlan_ifih;
	if (vlan_ifih->ifih_refcnt == 1)
		SLIST_INSERT_HEAD(&p->if_inputs, vlan_ifih, ifih_next);
@


1.135.4.2
log
@There was another bug in vlan and carp ifih refcounting.  An ifih
could be inserted twice into the the parent's list.  Then the kernel
will panic if root does an ifconfig destroy of the parent interface.
This affects OpenBSD 5.8 only.
From markus@@; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.135.4.1 2016/01/25 12:39:00 bluhm Exp $	*/
a353 1
	int			 insert = 0;
a369 1
		insert = 1;
d444 1
a444 1
	if (insert)
@


1.134
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.133 2015/06/30 13:54:42 mpi Exp $	*/
d50 2
d209 10
@


1.133
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.132 2015/06/29 10:32:29 dlg Exp $	*/
d80 1
a80 1
int	vlan_input(struct mbuf *);
d246 1
a246 1
vlan_input(struct mbuf *m)
a248 1
	struct ifnet			*ifp;
a254 7

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	KASSERT(ifp != NULL);
	if ((ifp->if_flags & IFF_UP) == 0) {
		m_freem(m);
		return (1);
	}
@


1.132
log
@count if_ibytes in if_input like we do for if_ipackets.

tweaks and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.131 2015/06/24 09:40:54 mpi Exp $	*/
d234 1
a234 1
		if (if_output(p, m)) {
@


1.131
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.130 2015/06/23 09:42:23 mpi Exp $	*/
a283 2

	ifp->if_ibytes += m->m_pkthdr.len;
@


1.130
log
@Adapt bridge(4) to the new if_input() framework.

Move bridge_input() outside of ether_input() in order to duplicate packets
flowing through a bridge port before applying any transformation on mbufs.

This saves a various m_adj(9)/M_PREPEND(9) dances and remove the bridge(4)
hack from vlan(4).

Tested by mxb <mxb AT alumni DOT chalmers DOT se> and kettenis@@

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.129 2015/06/16 11:09:39 mpi Exp $	*/
a341 1
	ifv->ifv_if.if_ipackets++;
@


1.129
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.128 2015/06/08 13:44:08 mpi Exp $	*/
a72 5
#include "bridge.h"
#if NBRIDGE > 0
#include <net/if_bridge.h>
#endif

a301 8
#if NBRIDGE > 0
		/*
		 * If the packet hasn't been through its bridge(4) give
		 * it a chance.
		 */
		if (ifp->if_bridgeport && (m->m_flags & M_PROTO1) == 0)
			return (0);
#endif
@


1.128
log
@Merge multiple copies of the code doing VLAN tag insertion back into
vlan_start().

ok sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.127 2015/05/27 12:23:44 dlg Exp $	*/
d262 7
a268 1
	ifp = m->m_pkthdr.rcvif;
a269 1

@


1.127
log
@check if the packet is for us or if we're promisc before we cut the
vlan header out of the packet.

fixes rx on top of trunks on top of nics that dont do hw vlan tagging.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.126 2015/05/26 11:39:07 mpi Exp $	*/
a49 3
#include "bridge.h"
#include "vlan.h"

a58 5
#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

d68 10
a85 2
int	vlan_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);
a154 1
	ifp->if_output = vlan_output;
a177 12
int
vlan_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	/*
	 * we have to use a custom output function because ether_output
	 * can't figure out ifp is a vlan in a reasonable way
	 */
	m->m_flags |= M_VLANTAG;
	return (ether_output(ifp, m, dst, rt));
}

d181 1
a181 1
	struct ifvlan	*ifv;
d184 1
d194 5
d207 27
a233 34
#if NBPFILTER > 0
		if (ifp->if_bpf) {
			if ((p->if_capabilities & IFCAP_VLAN_HWTAGGING) &&
			    (ifv->ifv_type == ETHERTYPE_VLAN))
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
			else {
				struct mbuf *m0;
				u_int off;
				struct m_hdr mh;
				struct {
					uint8_t dst[ETHER_ADDR_LEN];
					uint8_t src[ETHER_ADDR_LEN];
				} hdr;

				/* copy the ether addresses off the front */
				m_copydata(m, 0, sizeof(hdr), (caddr_t)&hdr);

				/* find the ethertype after the vlan subhdr*/
				m0 = m_getptr(m,
				    offsetof(struct ether_vlan_header,
				    evl_proto), &off);
				KASSERT(m0 != NULL);

				/* pretend the vlan subhdr isnt there */
				mh.mh_flags = 0;
				mh.mh_data = mtod(m0, caddr_t) + off;
				mh.mh_len = m0->m_len - off;
				mh.mh_next = m0->m_next;

				/* dst+src + ethertype == ethernet header */
				bpf_mtap_hdr(ifp->if_bpf,
				    (caddr_t)&hdr, sizeof(hdr),
				    (struct mbuf *)&mh, BPF_DIRECTION_OUT,
				    NULL);
d235 2
a237 1
#endif /* NBPFILTER > 0 */
@


1.126
log
@Now that the Ethernet header is always passed as part of the mbuf, kill
the second (unused) argument of the input packet handlers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.125 2015/05/26 03:01:54 dlg Exp $	*/
a334 13
	 * Having found a valid vlan interface corresponding to
	 * the given source interface and vlan tag, remove the
	 * encapsulation.
	 */
	if (m->m_flags & M_VLANTAG) {
		m->m_flags &= ~M_VLANTAG;
	} else {
		eh->ether_type = evl->evl_proto;
		memmove((char *)eh + EVL_ENCAPLEN, eh, sizeof(*eh));
		m_adj(m, EVL_ENCAPLEN);
	}

	/*
d346 13
@


1.125
log
@make vlans inherit their parents hardmtu as well as mtu.

from brad@@ and tested locally.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.124 2015/05/23 08:32:12 mpi Exp $	*/
d83 1
a83 1
int	vlan_input(struct mbuf *, void *);
d264 1
a264 1
vlan_input(struct mbuf *m, void *hdr)
@


1.124
log
@Call if_input() instead of setting the "rcvif" pointer ourself.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.123 2015/05/20 08:54:37 mpi Exp $	*/
d397 1
a397 1
	if (p->if_capabilities & IFCAP_VLAN_MTU)
d399 2
a400 1
	else
d402 2
d516 1
d569 1
a569 1
	int		 error = 0, p_mtu = 0, s;
d597 2
a598 6
			if (ifv->ifv_p->if_capabilities & IFCAP_VLAN_MTU)
				p_mtu = ifv->ifv_p->if_hardmtu;
			else
				p_mtu = ifv->ifv_p->if_hardmtu - EVL_ENCAPLEN;
			
			if (ifr->ifr_mtu > p_mtu || ifr->ifr_mtu < ETHERMIN)
@


1.123
log
@Keep track of the ifih corresponding to a vlan instance to ease its
removal.

As soon as carp(4) will be converted to the new if_input() API it
will be possible to add multiple vlan(4) and carp(4) pseudo-ifps on
top of the same parent interface.  When such thing happens we can no
longer assume that the first pseudo-ifp to be destroyed will be the
last configured.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.122 2015/05/20 08:28:54 mpi Exp $	*/
d272 1
a346 5
#if NBPFILTER > 0
	if (ifv->ifv_if.if_bpf)
		bpf_mtap_ether(ifv->ifv_if.if_bpf, m, BPF_DIRECTION_IN);
#endif

d361 2
d364 1
a364 2
	m->m_pkthdr.rcvif = &ifv->ifv_if;
	return (0);
@


1.122
log
@Do not increment if_opackets in if_output().  It might make sense to do
that later but all drivers should be adapated.

Should fix a double output packet accounting, reported by Hrvoje Popovski.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.121 2015/05/19 11:21:42 mpi Exp $	*/
a372 1
	struct ifih		*vlan_ifih;
d383 6
a388 5
	/* Share an ifih between multiple vlan(4) instances. */
	vlan_ifih = SLIST_FIRST(&p->if_inputs);
	if (vlan_ifih->ifih_input != vlan_input) {
		vlan_ifih = malloc(sizeof(*vlan_ifih), M_DEVBUF, M_NOWAIT);
		if (vlan_ifih == NULL)
d390 2
a391 2
		vlan_ifih->ifih_input = vlan_input;
		vlan_ifih->ifih_refcnt = 0;
a445 4
	/* Change input handler of the physical interface. */
	if (++vlan_ifih->ifih_refcnt == 1)
		SLIST_INSERT_HEAD(&p->if_inputs, vlan_ifih, ifih_next);

d457 1
d459 4
a471 1
	struct ifih		*vlan_ifih;
d489 6
a502 8
	}

	/* Restore previous input handler. */
	vlan_ifih = SLIST_FIRST(&p->if_inputs);
	KASSERT(vlan_ifih->ifih_input == vlan_input);
	if (--vlan_ifih->ifih_refcnt == 0) {
		SLIST_REMOVE_HEAD(&p->if_inputs, ifih_next);
		free(vlan_ifih, M_DEVBUF, sizeof(*vlan_ifih));
@


1.121
log
@We cannot check for M_BCAST or M_MCAST now that vlan_input() is ran
before ether_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.120 2015/05/19 11:09:24 mpi Exp $	*/
d256 1
@


1.120
log
@Take vlan(4) out of ether_input().

To keep the list of input handlers short, multiple vlans share the
same ifih.

if_input_process() now looks if the interface of a mbuf changed to
make sure the corresponding handlers are executed.  This is a hack
and will be improved later.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.119 2015/05/15 10:15:13 mpi Exp $	*/
d354 1
a354 1
	if ((m->m_flags & (M_BCAST|M_MCAST)) == 0 &&
@


1.119
log
@Introduce if_output(), a function do to the last steps before enqueuing
a packet on the sending queue of an interface.

Tested by many, thanks a lot!

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.118 2015/04/22 06:42:11 mpi Exp $	*/
d82 2
d260 1
a260 1
 * vlan_input() returns 0 if it has consumed the packet, 1 otherwise.
d263 1
a263 1
vlan_input(struct ether_header *eh, struct mbuf *m)
d265 12
a276 6
	struct ifvlan		*ifv;
	struct ifnet		*ifp = m->m_pkthdr.rcvif;
	struct vlan_taghash	*tagh;
	u_int			 tag;
	u_int16_t		 etype;
	struct ether_header	*eh1;
d281 1
a281 1
	} else {
d285 1
a285 1
			return (0);
d288 2
a289 1
		etype = ntohs(eh->ether_type);
d291 3
a293 1
		m->m_pkthdr.ether_vtag = ntohs(*mtod(m, u_int16_t *));
d295 3
d307 1
a307 1
		if (m->m_pkthdr.rcvif == ifv->ifv_p && tag == ifv->ifv_tag &&
d319 1
a319 1
			return (1);
d323 1
a323 1
		return (0);
d329 1
a329 1
		return (0);
d335 1
a335 3
	 * encapsulation, and run the real packet through
	 * ether_input() a second time (it had better be
	 * reentrant!).
a336 1
	m->m_pkthdr.rcvif = &ifv->ifv_if;
d340 3
a342 4
		eh->ether_type = mtod(m, u_int16_t *)[1];
		m->m_len -= EVL_ENCAPLEN;
		m->m_data += EVL_ENCAPLEN;
		m->m_pkthdr.len -= EVL_ENCAPLEN;
d347 1
a347 2
		bpf_mtap_hdr(ifv->ifv_if.if_bpf, (char *)eh, ETHER_HDR_LEN, m,
		    BPF_DIRECTION_IN, NULL);
d360 1
a360 1
			return (0);
a363 6
	M_PREPEND(m, sizeof(*eh1), M_DONTWAIT);
	if (m == NULL)
		return (-1);
	eh1 = mtod(m, struct ether_header *);
	memmove(eh1, eh, sizeof(*eh1));

d365 1
a365 2
	ether_input_mbuf(&ifv->ifv_if, m);

d372 1
d383 10
d444 4
a447 3
	s = splnet();
	tagh = ifv->ifv_type == ETHERTYPE_QINQ ? svlan_tagh : vlan_tagh;
	LIST_INSERT_HEAD(&tagh[TAG_HASH(tag)], ifv, ifv_list);
d458 4
d470 1
d496 8
@


1.118
log
@Add missing header for NBRIDGE chunk, found the hardway and diff from
Rafael Zalamena.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.117 2015/04/15 09:58:44 mpi Exp $	*/
a194 1
	int		 error;
d250 1
a250 7
		/*
		 * Send it, precisely as ether_output() would have.
		 * We are already running at splnet.
		 */
		IFQ_ENQUEUE(&p->if_snd, m, NULL, error);
		if (error) {
			/* mbuf is already freed */
a253 6
		p->if_obytes += m->m_pkthdr.len;
		if (m->m_flags & M_MCAST)
			p->if_omcasts++;

		ifp->if_opackets++;
		if_start(p);
@


1.117
log
@Add the necessary glue to keep vlan(4) working while other pseudo-drivers
are converted to if_input().

Reviewed by Rafael Zalamena.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.116 2015/04/13 08:52:51 mpi Exp $	*/
d50 1
@


1.116
log
@Move one "#ifdef NVLAN" chunk needed only if you're running bridge(4) on
to of vlan(4) from ether_input() to bridge_input().

One of the goal of the if_input() plumbing is to stop doing all possible
pseudo-drivers checks on every packets.  There's no reason that even if
you're not running a bridge(4) you've to run this code.

This change also will also makes it easier to convert vlan(4) to if_input().

Reviewed by Rafael Zalamena and mikeb@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.115 2015/04/10 02:08:08 dlg Exp $	*/
d280 1
d367 6
d374 1
a374 1
	ether_input(m, eh);
@


1.115
log
@dont inherit the parent interfaces hardmtu as the vlan interfaces
mtu when it gets set up. instead, allow the vlan interfaces mtu to
be raised to the parents hardmtu in SIOCSIFMTU handling.

pointed out by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.114 2015/04/07 10:46:20 mpi Exp $	*/
d308 14
a321 2
	if (ifv == NULL)
		return (1);
@


1.114
log
@Do not pass an `ifp' argument to interface input handlers since it
might be overwritten by pseudo-drivers.

ok dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.113 2015/03/31 11:47:09 dlg Exp $	*/
d380 1
a380 1
		ifv->ifv_if.if_mtu = p->if_hardmtu;
d382 1
a382 1
		ifv->ifv_if.if_mtu = p->if_hardmtu - EVL_ENCAPLEN;
d564 1
a564 1
				p_mtu = ifv->ifv_p->if_mtu;
d566 1
a566 1
				p_mtu = ifv->ifv_p->if_mtu - EVL_ENCAPLEN;
@


1.113
log
@let vlan(4) mtu be limited by the parents hardmtu, not current mtu.

this lets you have networks on the "native" (untagged) vlan on an
interface at 1500, while setting a child vlan interfaces mtu to
jumbos.

ok sthen@@ henning@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.112 2015/02/06 08:07:09 henning Exp $	*/
d355 1
a355 1
	ether_input(&ifv->ifv_if, eh, m);
@


1.112
log
@IEEE sez that 0 is bigger than 1, and IEEE is always right.
When mapping 802.1p prio from the vlan header to our priority levels, we
have to swap 0 and 1, since in 802.1p, 1 is the lowest prio, and 0 the
2nd lowest. But 2..7 are in the expected order!
Pointed out to me at BSDcan and I forgot by whom, sorry for that and the
delay. ok phessler pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.110 2014/11/23 07:39:02 deraadt Exp $	*/
d380 1
a380 1
		ifv->ifv_if.if_mtu = p->if_mtu;
d382 1
a382 1
		ifv->ifv_if.if_mtu = p->if_mtu - EVL_ENCAPLEN;
@


1.111
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d299 4
@


1.110
log
@length argument for some free() calls; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.109 2014/10/07 11:16:23 dlg Exp $	*/
a69 1
#ifdef INET
a71 1
#endif
a540 1
#ifdef INET
a542 1
#endif
@


1.109
log
@when running bpf on an outgoing vlan interface that doesnt have a
parent that doesnt offload the tag insertion, we need to chop the
vlan subheader out before the filter is run, not after.

this moves the mbuf surgery out from the bpf layer into the vlan
layer.

ok henning@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.108 2014/07/12 18:44:22 tedu Exp $	*/
d167 1
a167 1
	free(ifv, M_DEVBUF, 0);
@


1.108
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.107 2014/07/11 10:48:50 henning Exp $	*/
d215 36
a250 3
		if (ifp->if_bpf)
			bpf_mtap_stripvlan(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
@


1.107
log
@switch from bpf_mtap to the shiny new bpf_mtap_stripvlan.
bpf listeners on a vlan interface don't expect to see a vlan header (you
expect those on the underlaying if). since we no longer prepend an ethernet
header to later throw it away and prepend an ether_vlan_header, we prepend
a ether_vlan_header right away. to unconfuse bpf listeners we need to cut
the 4 extra bytes out, which is what bpf_mtap_stripvlan does.
problem noticed by dlg with dhcrelay, ok benno dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.106 2014/07/09 09:30:49 henning Exp $	*/
d167 1
a167 1
	free(ifv, M_DEVBUF);
d652 1
a652 1
	free(mc, M_DEVBUF);
d693 1
a693 1
		free(mc, M_DEVBUF);
d722 1
a722 1
		free(mc, M_DEVBUF);
@


1.106
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.104 2014/05/05 10:00:45 henning Exp $	*/
d216 1
a216 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
@


1.105
log
@improve style - basically, what my fingers did at Marrakesh airport when
waiting for the flight home from m2k14. ok reyk
@
text
@d302 1
a302 1
		    BPF_DIRECTION_IN);
@


1.104
log
@remove dead code: calling ether_attach which sets if_type to IFT_ETHER,
just to set it to IFT_L2VLAN right afterwards, just to set if_type
to the parent's if_type which can be anything as long as it is IFT_ETHER
at config time doesn't make any sense and has zero effect. stop fiddling
with if_type alltogether.
also remove a question in a comment that has been answered by the last 14
years.
from Marrakesh airport, ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.101 2013/11/08 09:18:27 mpi Exp $	*/
d127 2
a128 2
	struct ifvlan *ifv;
	struct ifnet *ifp;
d130 1
a130 2
	ifv = malloc(sizeof(*ifv), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!ifv)
d162 1
a162 1
	struct ifvlan *ifv = ifp->if_softc;
a166 1

d174 1
a174 2
	struct ifvlan *ifv = (struct ifvlan *)ptr;

d193 4
a196 4
	struct ifvlan *ifv;
	struct ifnet *p;
	struct mbuf *m;
	int error;
a208 1
				/* XXX stats */
a235 2

	return;
d244 5
a248 5
	struct ifvlan *ifv;
	struct ifnet *ifp = m->m_pkthdr.rcvif;
	struct vlan_taghash *tagh;
	u_int tag;
	u_int16_t etype;
d301 2
a302 2
		bpf_mtap_hdr(ifv->ifv_if.if_bpf, (char *)eh, ETHER_HDR_LEN,
		    m, BPF_DIRECTION_IN);
d312 2
a313 2
		struct arpcom *ac = &ifv->ifv_ac;
		if (bcmp(ac->ac_enaddr, eh->ether_dhost, ETHER_ADDR_LEN)) {
d328 4
a331 4
	struct sockaddr_dl *sdl1, *sdl2;
	struct vlan_taghash *tagh;
	u_int flags;
	int s;
a340 1

d342 1
d346 1
a346 5
	else {
		/*
		 * This will be incompatible with strict
		 * 802.1Q implementations
		 */
a347 6
#ifdef DIAGNOSTIC
		printf("%s: initialized with non-standard mtu %u (parent %s)\n",
		    ifv->ifv_if.if_xname, ifv->ifv_if.if_mtu,
		    ifv->ifv_p->if_xname);
#endif
	}
a358 6
	 * Inherit baudrate from the parent.  An SNMP agent would use this
	 * information.
	 */
	ifv->ifv_if.if_baudrate = p->if_baudrate;

	/*
d404 1
a404 1
	return 0;
d410 4
a413 4
	struct sockaddr_dl *sdl;
	struct ifvlan *ifv;
	struct ifnet *p;
	int s;
d416 1
a416 2
	p = ifv->ifv_p;
	if (p == NULL)
d457 1
a457 1
	return 0;
d463 1
a463 1
	struct ifvlan *ifv = v;
d476 2
a477 2
	struct ifvlan *ifv = ifp->if_softc;
	int error = 0;
d480 2
a481 3
		if ((ifv->ifv_flags & IFVF_PROMISC) == 0) {
			error = ifpromisc(ifv->ifv_p, 1);
			if (error == 0)
a482 1
		}
d484 2
a485 3
		if ((ifv->ifv_flags & IFVF_PROMISC) != 0) {
			error = ifpromisc(ifv->ifv_p, 0);
			if (error == 0)
a486 1
		}
a487 1

d494 7
a500 7
	struct proc *p = curproc;	/* XXX */
	struct ifaddr *ifa;
	struct ifnet *pr;
	struct ifreq *ifr;
	struct ifvlan *ifv;
	struct vlanreq vlr;
	int error = 0, p_mtu = 0, s;
a509 2

			switch (ifa->ifa_addr->sa_family) {
d511 1
a511 1
			case AF_INET:
a512 1
				break;
d514 1
a514 4
			default:
				break;
			}
		} else {
a515 1
		}
d520 1
a520 1
			struct sockaddr *sa;
d522 1
a522 1
			sa = (struct sockaddr *) &ifr->ifr_data;
d617 4
a620 9
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
	struct vlan_mc_entry *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	/* XXX: sa_len is too small for such comparison
	if (ifr->ifr_addr.sa_len > sizeof(struct sockaddr_storage))
		return (EINVAL);
	*/
d631 1
a631 2
	mc = malloc(sizeof(*mc), M_DEVBUF, M_NOWAIT);
	if (mc == NULL) {
d645 1
a645 2
	error = (*ifp->if_ioctl)(ifp, SIOCADDMULTI, (caddr_t)ifr);
	if (error != 0)
d662 5
a666 5
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
	struct ether_multi *enm;
	struct vlan_mc_entry *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;
d686 1
a686 2
	error = ether_delmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	if (error != ENETRESET)
d690 1
a690 2
	error = (*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
	if (error == 0) {
d706 2
a707 2
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
	struct vlan_mc_entry *mc;
d711 2
a712 2
			char ifr_name[IFNAMSIZ];
			struct sockaddr_storage ifr_ss;
d715 1
a715 1
	struct ifreq *ifr = &ifreq.ifreq;
d729 2
a730 2
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
	struct vlan_mc_entry *mc;
d734 2
a735 2
			char ifr_name[IFNAMSIZ];
			struct sockaddr_storage ifr_ss;
d738 1
a738 1
	struct ifreq *ifr = &ifreq.ifreq;
@


1.103
log
@we used to handle the vlan tag etc insertion very very very late,
on al already ass embed ethernet frame, which meant:
-copy (most of) the existing ethernet header into a ether_vlan_header
on the stack
-fill the extra fields in ether_vlan_header
-set the ether type
-m_adj() to make room for the extra space ether_vlan_header needs
-m_copyback the ether_vlan_header into the mbuf
that involves moving data around, which isn't all that cheap.
cleaner & easier to have ether_output prepend the ether_vlan_header instead
of the regular ethernet header, which makes the vlan tagging essentially
free in most cases.
help & ok reyk, naddy; waste of time bikeshedding tech@@
@
text
@a153 2
	/* Now undo some of the damage... */
	ifp->if_type = IFT_L2VLAN;
a374 6
	 * Inherit the if_type from the parent.  This allows us to
	 * participate in bridges of that type.
	 */
	ifv->ifv_if.if_type = p->if_type;

	/*
a386 3
	 *
	 * This brings up another possibility, do cards exist which
	 * have all of these capabilities but cannot utilize them together?
@


1.102
log
@if_lladdr -> if_sadl, no functional change.

ok mikeb@@
@
text
@d83 2
d157 1
d183 12
a223 30

		/*
		 * If the IFCAP_VLAN_HWTAGGING capability is set on the parent,
		 * it can do VLAN tag insertion itself and doesn't require us
	 	 * to create a special header for it. In this case, we just pass
		 * the packet along.
		 */
		if ((p->if_capabilities & IFCAP_VLAN_HWTAGGING) &&
		    (ifv->ifv_type == ETHERTYPE_VLAN)) {
			m->m_pkthdr.ether_vtag = ifv->ifv_tag +
			    (m->m_pkthdr.pf.prio << EVL_PRIO_BITS);
			m->m_flags |= M_VLANTAG;
		} else {
			struct ether_vlan_header evh;

			m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&evh);
			evh.evl_proto = evh.evl_encap_proto;
			evh.evl_encap_proto = htons(ifv->ifv_type);
			evh.evl_tag = htons(ifv->ifv_tag +
			    (m->m_pkthdr.pf.prio << EVL_PRIO_BITS));

			m_adj(m, ETHER_HDR_LEN);
			M_PREPEND(m, sizeof(evh), M_DONTWAIT);
			if (m == NULL) {
				ifp->if_oerrors++;
				continue;
			}

			m_copyback(m, 0, sizeof(evh), &evh, M_NOWAIT);
		}
@


1.101
log
@To make sure detach hooks are executed in reverse order they were added,
they must be appended to the head of the list.  It doesn't really matter
right now since most of our pseudo drivers use their own custom detach
procedure, but teach vlan(4) to do the right thing since more conversion
are coming.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.100 2013/11/07 11:19:32 mpi Exp $	*/
a350 1
	struct ifaddr *ifa1, *ifa2;
d429 2
a430 4
	ifa1 = ifv->ifv_if.if_lladdr;
	ifa2 = p->if_lladdr;
	sdl1 = (struct sockaddr_dl *)ifa1->ifa_addr;
	sdl2 = (struct sockaddr_dl *)ifa2->ifa_addr;
a457 1
	struct ifaddr *ifa;
d500 1
a500 2
	ifa = ifv->ifv_if.if_lladdr;
	sdl = (struct sockaddr_dl *)ifa->ifa_addr;
@


1.100
log
@Now that it is safe to disestablish a hook from itself, do not leak the
detach hook when the parent interface is destroy/removed.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.99 2013/10/19 14:05:14 reyk Exp $	*/
d449 1
a449 1
	ifv->dh_cookie = hook_establish(p->if_detachhooks, 1,
@


1.99
log
@Bring back the if_detachhook.  We're going to have more users now.

ok mpi@@ henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.98 2013/09/17 13:34:18 mpi Exp $	*/
d176 1
a176 7
	/*
	 * Destroy the vlan interface because the parent has been
	 * detached. Set the dh_cookie to NULL because we're running
	 * inside of dohooks which is told to disestablish the hook
	 * for us (otherwise we would kill the TAILQ element...).
	 */
	ifv->dh_cookie = NULL;
d480 4
a483 5
	if (ifv->lh_cookie != NULL)
		hook_disestablish(p->if_linkstatehooks, ifv->lh_cookie);
	/* The cookie is NULL if disestablished externally */
	if (ifv->dh_cookie != NULL)
		hook_disestablish(p->if_detachhooks, ifv->dh_cookie);
a488 1
	splx(s);
@


1.98
log
@Change vlan(4) detach procedure to not use a hook but a list of vlans
on the parent interface.  This is similar to what bridge(4), trunk(4)
or carp(4) are doing and allows us to get rid of the detachhook.

ok reyk@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.97 2013/06/20 12:03:40 mpi Exp $	*/
d96 1
d173 1
a173 1
vlan_ifdetach(struct ifnet *ifp)
d175 1
a175 2
	struct ifvlan *ifv, *nifv;

d177 4
a180 2
	 * Destroy the vlan interfaces because the parent has been
	 * detached.
d182 2
a183 2
	LIST_FOREACH_SAFE(ifv, &ifp->if_vlist, ifv_next, nifv)
		vlan_clone_destroy(&ifv->ifv_if);
d455 2
a456 1
	LIST_INSERT_HEAD(&p->if_vlist, ifv, ifv_next);
d488 3
a490 1
	LIST_REMOVE(ifv, ifv_next);
@


1.97
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.96 2013/06/20 09:38:24 mpi Exp $	*/
a95 1
void	vlan_ifdetach(void *);
d172 1
a172 1
vlan_ifdetach(void *ptr)
d174 2
a175 1
	struct ifvlan *ifv = (struct ifvlan *)ptr;
d177 2
a178 4
	 * Destroy the vlan interface because the parent has been
	 * detached. Set the dh_cookie to NULL because we're running
	 * inside of dohooks which is told to disestablish the hook
	 * for us (otherwise we would kill the TAILQ element...).
d180 2
a181 2
	ifv->dh_cookie = NULL;
	vlan_clone_destroy(&ifv->ifv_if);
d453 1
a453 2
	ifv->dh_cookie = hook_establish(p->if_detachhooks, 1,
	    vlan_ifdetach, ifv);
d485 1
a485 3
	/* The cookie is NULL if disestablished externally */
	if (ifv->dh_cookie != NULL)
		hook_disestablish(p->if_detachhooks, ifv->dh_cookie);
@


1.96
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.95 2013/04/02 08:54:37 mpi Exp $	*/
d451 1
a451 1
	ifv->lh_cookie = hook_establish(&p->if_linkstatehooks, 1,
d455 1
a455 1
	ifv->dh_cookie = hook_establish(&p->if_detachhooks, 1,
d487 1
a487 1
		hook_disestablish(&p->if_linkstatehooks, ifv->lh_cookie);
d490 1
a490 1
		hook_disestablish(&p->if_detachhooks, ifv->dh_cookie);
@


1.95
log
@Instead of storing the link-level address of every interface in a global
array indexed by interface numbers, add a new field to the interface
descriptor pointing to it.

claudio@@ and todd@@ like it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.94 2013/03/28 16:45:16 tedu Exp $	*/
d451 1
a451 1
	ifv->lh_cookie = hook_establish(p->if_linkstatehooks, 1,
d455 1
a455 1
	ifv->dh_cookie = hook_establish(p->if_detachhooks, 1,
d487 1
a487 1
		hook_disestablish(p->if_linkstatehooks, ifv->lh_cookie);
d490 1
a490 1
		hook_disestablish(p->if_detachhooks, ifv->dh_cookie);
@


1.94
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.93 2012/09/30 12:11:50 claudio Exp $	*/
a76 1
extern struct	ifaddr	**ifnet_addrs;
d436 2
a437 2
	ifa1 = ifnet_addrs[ifv->ifv_if.if_index];
	ifa2 = ifnet_addrs[p->if_index];
d512 1
a512 1
	ifa = ifnet_addrs[ifv->ifv_if.if_index];
@


1.93
log
@There is no need to set IFF_OACTIVE in vlan, since there is no DMA ring
that can be filled. OK dlg@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.92 2012/09/19 15:29:53 henning Exp $	*/
a59 1
#include <sys/proc.h>
@


1.92
log
@defina an IFCAP_CSUM_MASK, covering IFCAP_CSUM_*, and use it in if_vlan.c
to replace the list of them.
this actually makes vlan inherit the IPv6 CSUM flags from it's parent, that
had been commented out since this code was committed back in 2001.
ok benno mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.90 2011/11/26 23:38:18 haesbaert Exp $	*/
a198 1
	ifp->if_flags |= IFF_OACTIVE;
a264 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.91
log
@Kill old comment, we already do 802.1p tagging.
@
text
@d427 1
a427 3
		    (IFCAP_CSUM_IPv4|IFCAP_CSUM_TCPv4|
		    IFCAP_CSUM_UDPv4);
		/* (IFCAP_CSUM_TCPv6|IFCAP_CSUM_UDPv6); */
@


1.90
log
@Tie the 802.1p (CoS) value in vlan(4) with the new prio scheme in pf.

When transmitting through vlan(4), it will now use the prio value in
pf packet header. When receiving, we save the incoming Cos in the same
place, this gives us the hability to preserve the CoS value across two
different vlan interfaces.

This kills the SIOC[GS]VLANPRIO ioctls and removes the corresponding
buttons from ifconfig(8).

ok henning@@ claudio@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.89 2011/09/18 11:17:57 miod Exp $	*/
d36 1
a36 2
 * Might be extended some day to also handle IEEE 802.1p priority
 * tagging.  This is sort of sneaky in the implementation, since
@


1.89
log
@Fix various format string types to as a minimum match the width of the
variables being processed.
ok bluhm@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.88 2011/08/20 06:21:32 mcbride Exp $	*/
d229 1
a229 1
			    (ifv->ifv_prio << EVL_PRIO_BITS);
d238 1
a238 1
			    (ifv->ifv_prio << EVL_PRIO_BITS));
a286 1
		tag = EVL_VLANOFTAG(m->m_pkthdr.ether_vtag);
d296 1
a296 1
		tag = EVL_VLANOFTAG(ntohs(*mtod(m, u_int16_t *)));
d298 3
a667 23
		error = copyout(&vlr, ifr->ifr_data, sizeof vlr);
		break;
	case SIOCSETVLANPRIO:
		if ((error = suser(p, 0)) != 0)
			break;
		if ((error = copyin(ifr->ifr_data, &vlr, sizeof vlr)))
			break;
		/*
		 * Don't let the caller set up a VLAN priority
		 * outside the range 0-7
		 */
		if (vlr.vlr_tag > EVL_PRIO_MAX) {
			error = EINVAL;
			break;
		}
		ifv->ifv_prio = vlr.vlr_tag;
		break;
	case SIOCGETVLANPRIO:
		bzero(&vlr, sizeof vlr);
		if (ifv->ifv_p)
			strlcpy(vlr.vlr_parent, ifv->ifv_p->if_xname,
                            sizeof(vlr.vlr_parent));
		vlr.vlr_tag = ifv->ifv_prio;
@


1.88
log
@Fix packet accounting in error cases.

From Christiano F. Haesbaert.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.87 2011/02/18 17:06:45 reyk Exp $	*/
d386 1
a386 1
		printf("%s: initialized with non-standard mtu %lu (parent %s)\n",
@


1.87
log
@when changing the vlandev of a running vlan(4) interface, we also need to
move the configured multicast addresses and preserve the promisc mode
settings of the parent.  this fixes an issue when carp stopped working on
a vlan after the vlandev was manually changed.

ok naddy@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.86 2011/01/03 11:18:13 reyk Exp $	*/
a253 3
		p->if_obytes += m->m_pkthdr.len;
		if (m->m_flags & M_MCAST)
			p->if_omcasts++;
d260 3
@


1.86
log
@Allow to change vlan options of existing vlan(4)/svlan(4) devices at
runtime instead of forcing the user to-recreate the interface with the
changed options.  The code now re-configures the interface instead of
returning EBUSY.  For example, it is now possible to run "ifconfig
vlan1 vlandev em0; ifconfig vlan1 vlandev em1" in a sequence.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.85 2010/07/02 02:40:16 blambert Exp $	*/
d88 1
a88 1
int	vlan_unconfig(struct ifnet *ifp);
d96 1
d167 1
a167 1
	vlan_unconfig(ifp);
d363 1
d371 3
a373 2
	/* Reset the interface */
	vlan_unconfig(&ifv->ifv_if);
d395 6
d470 1
a470 1
vlan_unconfig(struct ifnet *ifp)
d483 6
d496 5
d509 1
a509 1
	vlan_ether_purgemulti(ifv);
d514 1
d630 1
a630 1
			vlan_unconfig(ifp);
d834 33
@


1.85
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.84 2010/06/03 16:15:00 naddy Exp $	*/
d368 3
a370 2
	if (ifv->ifv_p)
		return EBUSY;
@


1.84
log
@Add support for 802.1ad-style QinQ nested VLANs.

QinQ-compliant svlan (service VLAN) interfaces are implemented as
a new cloner type, use Ethernet type 0x88a8, and have a dedicated
VLAN tag hash to avoid ID conflicts.  vlan(4) interfaces can be
stacked on top of svlan(4).

Originally from reyk@@, input from claudio@@ and deraadt@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.83 2010/04/20 22:05:43 tedu Exp $	*/
d246 1
a246 1
			m_copyback(m, 0, sizeof(evh), &evh);
@


1.83
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.82 2010/01/12 01:36:33 dlg Exp $	*/
d80 1
a80 1
u_long vlan_tagmask;
d82 8
a89 8
#define TAG_HASH_SIZE	32
#define TAG_HASH(tag)	(tag & vlan_tagmask)
LIST_HEAD(, ifvlan)	*vlan_tagh;

void	vlan_start (struct ifnet *ifp);
int	vlan_ioctl (struct ifnet *ifp, u_long cmd, caddr_t addr);
int	vlan_unconfig (struct ifnet *ifp);
int	vlan_config (struct ifvlan *, struct ifnet *, u_int16_t);
d91 2
a92 2
void	vlanattach (int count);
int	vlan_set_promisc (struct ifnet *ifp);
d102 2
d109 3
a111 1
	vlan_tagh = hashinit(TAG_HASH_SIZE, M_DEVBUF, M_NOWAIT, &vlan_tagmask);
d114 1
d116 6
a121 1
	if_clone_attach(&vlan_cloner);
d142 6
d225 2
a226 1
		if (p->if_capabilities & IFCAP_VLAN_HWTAGGING) {
d235 1
a235 1
			evh.evl_encap_proto = htons(ETHERTYPE_VLAN);
d275 1
a275 3
vlan_input(eh, m)
	struct ether_header *eh;
	struct mbuf *m;
d278 2
d281 1
a281 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d284 2
d294 2
d299 3
a301 2
	LIST_FOREACH(ifv, &vlan_tagh[TAG_HASH(tag)], ifv_list) {
		if (m->m_pkthdr.rcvif == ifv->ifv_p && tag == ifv->ifv_tag)
d361 1
d421 7
d442 2
a443 1
	LIST_INSERT_HEAD(&vlan_tagh[TAG_HASH(tag)], ifv, ifv_list);
@


1.82
log
@set the length of the send queue to 1.

this prevents the ultimate length of the queue of the underlying interface
from being artificially inflated while hte vlan/trunk queue is filled and
then dumped wholesale on the underlying interface, which will dump its
massive queue wholesale on the chip.

tx mitigation is only triggered on real interfaces now (which is where the
cost is)

ok beck@@ original diff ok kjc@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.81 2009/11/18 02:09:59 deraadt Exp $	*/
a59 1
#include <sys/sysctl.h>
@


1.81
log
@do not do setup that ether_ifattach() takes care of; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.80 2009/07/16 22:58:45 thib Exp $	*/
d135 1
a135 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.80
log
@Backout rev1.79 of if_vlan.c and rev1.66 of if_trunk.c;
Changes in those revision limited the send queue to one slot.

This breaks NFS over vlan(4) has discovered by sthen@@.

"just plain back it out." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.77 2008/10/16 19:18:03 naddy Exp $	*/
a134 1
	ifp->if_output = ether_output;
@


1.79
log
@make the send queue one slot long. this forces packets off the virtual
interfaces down to the queue on the physical interface immediately.

this avoids having the tx mitigation code wasting cpu time dicking around
with simply shuffling packets off virtual interface queues and lets it
do its job of ammortising the cost of calling a real interfaces start
routine.

it also prevents an artificial inflation of the physical interfaces queue
length where packets could hide on the virtual interfaces queues during
softnet before being dumped en masse onto the hardware. this will smooth
out the rate at which packets are submitted to the hardware.

kjc@@ says this has no impact on altq. ya henning@@
@
text
@d136 1
a136 1
	IFQ_SET_MAXLEN(&ifp->if_snd, 1);
@


1.78
log
@include the VLAN priority for hardware tagging, too; ok claudio@@
@
text
@d136 1
a136 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.77
log
@Switch the existing TX VLAN hardware support over to having the
tag in the header.  Convert TX tagging in the drivers.

Help and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.76 2008/10/16 19:12:51 naddy Exp $	*/
d212 2
a213 1
			m->m_pkthdr.ether_vtag = ifv->ifv_tag;
@


1.76
log
@* Allow ether_input() and vlan_input() to handle incoming packets
  where the tag is stored in the mbuf header.
* Make bridge(4) handle interfaces with and without hardware tag
  support and forward packets inbetween.

Help and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.75 2008/10/16 14:23:35 naddy Exp $	*/
d209 1
a209 13
		 * the packet along. However, we need some way to tell the
		 * interface where the packet came from so that it knows how
		 * to find the VLAN tag to use, so we set the rcvif in the
		 * mbuf header to our ifnet.
		 *
		 * Note: we also set the M_PROTO1 flag in the mbuf to let
		 * the parent driver know that the rcvif pointer is really
		 * valid. We need to do this because sometimes mbufs will
		 * be allocated by other parts of the system that contain
		 * garbage in the rcvif pointer. Using the M_PROTO1 flag
		 * lets the driver perform a proper sanity check and avoid
		 * following potentially bogus rcvif pointers off into
		 * never-never land.
d212 2
a213 2
			m->m_pkthdr.rcvif = ifp;
			m->m_flags |= M_PROTO1;
@


1.75
log
@Drop promiscuously received packets if the vlan interface is not in
promiscuous mode itself.  Closes PR 5012.  With claudio@@.

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.74 2008/09/02 17:35:16 chl Exp $	*/
d279 10
a288 4
	if (m->m_len < EVL_ENCAPLEN &&
	    (m = m_pullup(m, EVL_ENCAPLEN)) == NULL) {
		ifp->if_ierrors++;
		return (0);
a290 2
	tag = EVL_VLANOFTAG(ntohs(*mtod(m, u_int16_t *)));

d312 8
a319 4
	eh->ether_type = mtod(m, u_int16_t *)[1];
	m->m_len -= EVL_ENCAPLEN;
	m->m_data += EVL_ENCAPLEN;
	m->m_pkthdr.len -= EVL_ENCAPLEN;
@


1.74
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.73 2008/05/07 13:45:35 dlg Exp $	*/
d318 15
@


1.73
log
@enable tx mitigation when putting packets on the wire by switching from
calls to ifp->if_start to if_start(). these are the obviously right cases
where we can do that, the less obvious ones may follow as theyre figured
out.

deraadt@@ said to go for it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.71 2007/09/15 16:43:51 henning Exp $	*/
a424 1
	struct ifreq *ifr, *ifr_p;
a430 3

	ifr = (struct ifreq *)&ifp->if_data;
	ifr_p = (struct ifreq *)&ifv->ifv_p->if_data;
@


1.72
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d260 1
a260 2
		if ((p->if_flags & (IFF_RUNNING|IFF_OACTIVE)) == IFF_RUNNING)
			p->if_start(p);
@


1.71
log
@malloc sweep:
-remove useless casts
-MALLOC/FREE -> malloc/free
-use M_ZERO where appropriate instead of seperate bzero
feedback & ok krw, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.70 2007/06/06 14:05:58 henning Exp $	*/
d652 1
a652 1
		error = EINVAL;
@


1.70
log
@vlan interfaces do not allow the parent interface and the vlan number to be
reconfigured after they are set. so they bail out when you try to. so when
you re-run netstart on a machine with vlans, it bails out with
ifconfig: SIOCSETVLAN: Device busy
and IP changes are not done.
make vlan_config() notice when both parent interface and vlan number stay
the same and just return success without doing anything in that case.
allows the IP config thereafter to happen. ok markus jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.69 2007/05/26 17:13:31 jason Exp $	*/
d121 1
a121 1
	ifv = malloc(sizeof(*ifv), M_DEVBUF, M_NOWAIT);
a123 1
	bzero(ifv, sizeof(*ifv));
d680 1
a680 2
	MALLOC(mc, struct vlan_mc_entry *, sizeof(struct vlan_mc_entry),
	    M_DEVBUF, M_NOWAIT);
d703 1
a703 1
	FREE(mc, M_DEVBUF);
d746 1
a746 1
		FREE(mc, M_DEVBUF);
d775 1
a775 1
		FREE(mc, M_DEVBUF);
@


1.69
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.68 2006/05/22 23:25:15 krw Exp $	*/
d335 2
@


1.68
log
@Check for NULL cookies before calling hook_disestablish(). Just in case
the establish calls were bypassed or failed.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.67 2006/05/09 19:43:02 mpf Exp $	*/
a80 1
extern int ifqmaxlen;
@


1.67
log
@Remove unnecessary check for the parent interface when setting
the vlan priority. Relaxes the order of the vlanprio parameter in ifconfig.
OK claudio, brad, norby
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.66 2006/04/11 13:29:37 henning Exp $	*/
d439 2
a440 1
	hook_disestablish(p->if_linkstatehooks, ifv->lh_cookie);
@


1.66
log
@on link state changes, copy baudrate (negotiated link speed) from parent
device. previously this was only done at config time, so vlan if's baudrate
could easily get out of sync with parent's. ok camield brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.65 2006/03/25 22:41:48 djm Exp $	*/
a613 8
		if (vlr.vlr_parent[0] == '\0')
			break;

		pr = ifunit(vlr.vlr_parent);
		if (pr == NULL) {
			error = ENOENT;
			break;
		}
a621 1

d626 1
a626 1
		if (ifv->ifv_p) {
d629 1
a629 2
			vlr.vlr_tag = ifv->ifv_prio;
		}
@


1.65
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.64 2006/03/04 22:40:16 brad Exp $	*/
d477 1
@


1.64
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.63 2006/02/09 00:05:55 reyk Exp $	*/
d204 1
a204 1
			bpf_mtap(ifp->if_bpf, m);
d318 2
a319 1
		bpf_mtap_hdr(ifv->ifv_if.if_bpf, (char *)eh, ETHER_HDR_LEN, m);
@


1.63
log
@add an interface detach hook and use it with the vlan(4) driver. this
fixes a possible crash if the parent interface has been destroyed
(like vlan on trunk) before destroying the vlan interface.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.62 2006/01/05 14:57:24 norby Exp $	*/
d249 1
a249 1
		 * We are already running at splimp.
d568 1
a568 1
			s = splimp();
d648 1
@


1.62
log
@Make it possible to set a default vlan priority for vlan interfaces.

ok claudio@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.61 2006/01/04 06:04:42 canacar Exp $	*/
d100 1
d163 14
d407 5
d430 3
a435 3
	if (p == NULL)
		return 0;

d439 3
@


1.61
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.60 2005/10/23 14:07:11 mpf Exp $	*/
d219 2
a220 1
			evh.evl_tag = htons(ifv->ifv_tag);
d584 33
a616 1
		
@


1.60
log
@Rework of multicast deletion code for vlan(4) and trunk(4).
The previous code could wrongly delete multicast groups
on the parent interface. Now we forward only remembered
delete requests.
OK mcbride, mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.59 2005/07/31 03:52:18 pascoe Exp $	*/
a153 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif  
@


1.59
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.58 2005/07/19 11:50:20 camield Exp $	*/
d680 10
d699 2
a700 9
		for (mc = LIST_FIRST(&ifv->vlan_mc_listhead); mc != NULL;
		    mc = LIST_NEXT(mc, mc_entries)) {
			if (mc->mc_enm == enm) {
				LIST_REMOVE(mc, mc_entries);
				FREE(mc, M_DEVBUF);
				break;
			}
		}
		KASSERT(mc != NULL);
@


1.58
log
@Remove vlan_input_tag() since all four drivers that used it have been
reworked to not strip vlan tags in hardware anymore.

ok brad henning jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.57 2005/07/18 19:18:33 camield Exp $	*/
d304 2
a305 15
	if (ifv->ifv_if.if_bpf) {
		/*
		 * Do the usual BPF fakery.  Note that we don't support
		 * promiscuous mode here, since it would require the
		 * drivers to know about VLANs and we're not ready for
		 * that yet.
		 */
		struct mbuf m0;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = ETHER_HDR_LEN;
		m0.m_data = (char *)eh;
		bpf_mtap(ifv->ifv_if.if_bpf, &m0);
	}
@


1.57
log
@Use M_PREPEND to take advantage of any slack leading space in the mbuf.

ok markus jason henning brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.56 2005/06/07 07:09:42 camield Exp $	*/
d45 4
a48 6
 * Some devices support 802.1Q tag insertion and extraction in firmware.
 * The vlan interface behavior changes when the IFCAP_VLAN_HWTAGGING
 * capability is set on the parent.  In this case, vlan_start() will not
 * modify the ethernet header.  On input, the parent can call vlan_input_tag()
 * directly in order to supply us with an incoming mbuf and the vlan
 * tag value that goes with it.
a254 63
}

int
vlan_input_tag(struct mbuf *m, u_int16_t t)
{
	struct ifvlan *ifv;
	struct ether_vlan_header vh;

	t = EVL_VLANOFTAG(t);
	LIST_FOREACH(ifv, &vlan_tagh[TAG_HASH(t)], ifv_list) {
		if (m->m_pkthdr.rcvif == ifv->ifv_p && t == ifv->ifv_tag)
			break;
	}

	if (ifv == NULL) {
		if (m->m_pkthdr.len < ETHER_HDR_LEN) {
			m_freem(m);
			return (-1);
		}
		m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&vh);
		vh.evl_proto = vh.evl_encap_proto;
		vh.evl_tag = htons(t);
		vh.evl_encap_proto = htons(ETHERTYPE_VLAN);
		m_adj(m, ETHER_HDR_LEN);
		m = m_prepend(m, sizeof(struct ether_vlan_header), M_DONTWAIT);
		if (m == NULL)
			return (-1);
		m->m_pkthdr.len += sizeof(struct ether_vlan_header);
		if (m->m_len < sizeof(struct ether_vlan_header) &&
		    (m = m_pullup(m, sizeof(struct ether_vlan_header))) == NULL)
			return (-1);
		m_copyback(m, 0, sizeof(struct ether_vlan_header), &vh);
		ether_input_mbuf(m->m_pkthdr.rcvif, m);
		return (-1);
	}

	if ((ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
	    (IFF_UP|IFF_RUNNING)) {
		m_freem(m);
		return (-1);
	}

	/*
	 * Having found a valid vlan interface corresponding to
	 * the given source interface and vlan tag, run the
	 * the real packet through ether_input().
	 */
	m->m_pkthdr.rcvif = &ifv->ifv_if;

#if NBPFILTER > 0
	if (ifv->ifv_if.if_bpf) {
		/*
		 * Do the usual BPF fakery.  Note that we don't support
		 * promiscuous mode here, since it would require the
		 * drivers to know about VLANs and we're not ready for
		 * that yet.
		 */
		bpf_mtap(ifv->ifv_if.if_bpf, m);
	}
#endif
	ifv->ifv_if.if_ipackets++;
	ether_input_mbuf(&ifv->ifv_if, m);
	return 0;
@


1.56
log
@Run vlan_input before bridge_input, and change vlan_input to not
consume vlan frames that no vlan interface wants, so they can
still be bridged.

This way, the bridge can bridge encapsulated frames _and_ bridge
between vlan interfaces.

ok henning markus
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.55 2005/05/27 08:33:25 mpf Exp $	*/
d171 1
a171 1
	struct mbuf *m, *m0;
d225 1
d227 2
a228 4

			m0 = m_prepend(m, sizeof(struct ether_vlan_header),
			    M_DONTWAIT);
			if (m0 == NULL) {
d233 1
a233 9
			/* m_prepend() doesn't adjust m_pkthdr.len */
			if (m0->m_flags & M_PKTHDR)
				m0->m_pkthdr.len +=
				    sizeof(struct ether_vlan_header);

			m_copyback(m0, 0, sizeof(struct ether_vlan_header),
			    &evh);

			m = m0;
@


1.55
log
@only access if_linkstatehooks inside splnet.
with pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.54 2005/04/25 01:34:26 brad Exp $	*/
d331 3
d355 2
d358 1
a358 1
	if (ifv == NULL || (ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
d361 1
a361 1
		return -1;	/* so ether_input can take note */
d397 1
a397 1
	return 0;
@


1.54
log
@Use ETHERTYPE_VLAN.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.53 2005/04/24 10:16:10 brad Exp $	*/
d502 1
a515 1
	hook_disestablish(p->if_linkstatehooks, ifv->lh_cookie);
@


1.53
log
@Use the IANA assignment IFT_L2VLAN.

From FreeBSD/NetBSD

Tested by camield@@ and Alexey E. Suslikov <cruel at texnika dot com dot ua>
ok camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.52 2005/04/20 23:02:22 mpf Exp $	*/
d223 1
a223 1
			evh.evl_encap_proto = htons(ETHERTYPE_8021Q);
d288 1
a288 1
		vh.evl_encap_proto = htons(ETHERTYPE_8021Q);
@


1.52
log
@Make vlan(4) aware of its physical interface link state.
Changes are reported to userland and to other
interfaces sitting on top of us.

OK henning@@, camield@@
Tested by camield@@ and Alexey E. Suslikov
@
text
@d1 2
a2 1
/*	$OpenBSD: if_vlan.c,v 1.51 2005/04/18 04:07:17 brad Exp $ */
d144 1
a144 1
	ifp->if_type = IFT_8021_VLAN;
@


1.51
log
@If the parent interface is not IFF_RUNNING, do not call its start function.
This prevent a variety of fun panics.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.50 2005/04/18 03:29:18 brad Exp $ */
d93 1
d471 5
d514 1
d525 12
@


1.50
log
@revert a change in the previous commit to appease henning@@ for the time
being..
- Set the interface speed back to zero after ether_ifattach(). RFC 2863
  says: "For a sub-layer which has no concept of bandwidth, [ifSpeed]
  should be zero."
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.49 2005/04/17 23:02:02 brad Exp $ */
d258 1
a258 1
		if ((p->if_flags & IFF_OACTIVE) == 0)
@


1.49
log
@- In vlan_input()/vlan_input_tag(), always mask off all but the VLID
  bits from tags extracted from received frames. (Some drivers may
  already do this masking internally, but doing it here doesn't hurt
  and insures consistency.)
- In vlan_ioctl(), don't let the user set a VLAN ID value with anything
  besides the VLID bits set, otherwise we will have trouble matching
  an interface in vlan_input() later.
- Set the interface speed back to zero after ether_ifattach(). RFC 2863
  says: "For a sub-layer which has no concept of bandwidth, [ifSpeed]
  should be zero."
- Do not call if_down() on a parent interface if it's already down.

From FreeBSD

Tested by camield@@ and Alexey E. Suslikov <cruel at texnika dot com dot ua>
ok camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.48 2005/03/25 03:23:51 brad Exp $ */
a141 1
	ifp->if_baudrate = 0;
d430 6
@


1.48
log
@increment the right counter on error.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.47 2004/10/09 19:55:29 brad Exp $ */
a90 1
int	vlan_setmulti (struct ifnet *ifp);
a140 1

d142 1
d405 1
a432 6
	 * Inherit baudrate from the parent.  An SNMP agent would use this
	 * information.
	 */
	ifv->ifv_if.if_baudrate = p->if_baudrate;

	/*
d606 3
a608 2
			if_down(ifp);
			ifp->if_flags &= ~(IFF_UP|IFF_RUNNING);
a611 4
		if (vlr.vlr_tag != EVL_VLANOFTAG(vlr.vlr_tag)) {
			error = EINVAL;		 /* check for valid tag */
			break;
		}
d615 8
@


1.47
log
@sizeof(struct ether_header) -> ETHER_HDR_LEN

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.46 2004/03/27 23:41:04 deraadt Exp $ */
d230 1
a230 1
				ifp->if_ierrors++;
@


1.46
log
@wrap if_down() in splimp; tholo ran into splassert, miod tholo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.45 2004/02/12 18:07:29 henning Exp $ */
d221 1
a221 2
			m_copydata(m, 0, sizeof(struct ether_header),
			    (caddr_t)&evh);
d225 1
a225 1
			m_adj(m, sizeof(struct ether_header));
d281 1
a281 1
		if (m->m_pkthdr.len < sizeof(struct ether_header)) {
d285 1
a285 1
		m_copydata(m, 0, sizeof(struct ether_header), (caddr_t)&vh);
d289 1
a289 1
		m_adj(m, sizeof(struct ether_header));
d384 1
a384 1
		m0.m_len = sizeof(struct ether_header);
@


1.45
log
@from camield:
se hash instead of linked list to speed up tag to vlan interface mapping
ok markus@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.44 2003/12/16 20:33:25 markus Exp $ */
d554 1
a554 1
	int error = 0, p_mtu = 0;
d611 1
d615 1
@


1.44
log
@return error in ifc_destroy; ok deraadt, itojun, cedric, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.43 2003/12/06 09:23:25 grange Exp $ */
d83 5
d93 1
a93 1
int	vlan_config (struct ifvlan *ifv, struct ifnet *p);
a101 2
LIST_HEAD(, ifvlan) vlan_list;

d109 4
a112 1
	LIST_INIT(&vlan_list);
a120 1
	int s;
a146 4
	s = splnet();
	LIST_INSERT_HEAD(&vlan_list, ifv, ifv_list);
	splx(s);

a153 5
	int s;

	s = splnet();
	LIST_REMOVE(ifv, ifv_list);
	splx(s);
d276 1
a276 1
	LIST_FOREACH(ifv, &vlan_list, ifv_list) {
d349 1
a349 1
	LIST_FOREACH(ifv, &vlan_list, ifv_list) {
d397 1
a397 1
vlan_config(struct ifvlan *ifv, struct ifnet *p)
d401 1
d468 6
d485 1
d495 4
d625 1
a625 1
		error = vlan_config(ifv, pr);
a627 1
		ifv->ifv_tag = vlr.vlr_tag;
@


1.43
log
@u_int8_t variable can't be > 255; pointed out by Mr. GCC3.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.42 2003/12/03 14:55:58 markus Exp $ */
d95 1
a95 1
void	vlan_clone_destroy(struct ifnet *);
d149 1
a149 1
void
d167 1
@


1.42
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.41 2003/08/15 20:32:19 tedu Exp $ */
d668 1
d671 1
@


1.41
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.40 2003/08/14 19:00:12 jason Exp $ */
a81 4

struct ifvlan *ifv_softc;
int nifvlan;

d94 4
d99 4
d106 8
d115 30
a144 1
	int i;
d146 21
a166 27
	MALLOC(ifv_softc, struct ifvlan *, count * sizeof(struct ifvlan),
	    M_DEVBUF, M_NOWAIT);
	if (ifv_softc == NULL)
		panic("vlanattach: MALLOC failed");
	nifvlan = count;
	bzero(ifv_softc, nifvlan * sizeof(struct ifvlan));

	for (i = 0; i < nifvlan; i++) {
		LIST_INIT(&ifv_softc[i].vlan_mc_listhead);
		ifp = &ifv_softc[i].ifv_if;
		ifp->if_softc = &ifv_softc[i];
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "vlan%d", i);
		/* NB: flags are not set here */
		/* NB: mtu is not set here */

		ifp->if_start = vlan_start;
		ifp->if_ioctl = vlan_ioctl;
		ifp->if_output = ether_output;
		IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
		IFQ_SET_READY(&ifp->if_snd);
		if_attach(ifp);
		ether_ifattach(ifp);

		/* Now undo some of the damage... */
		ifp->if_type = IFT_8021_VLAN;
		ifp->if_hdrlen = EVL_ENCAPLEN;
	}
a274 1
	int i;
d279 1
a279 2
	for (i = 0; i < nifvlan; i++) {
		ifv = &ifv_softc[i];
d284 1
a284 1
	if (i >= nifvlan) {
a339 1
	int i;
d352 1
a352 2
	for (i = 0; i < nifvlan; i++) {
		ifv = &ifv_softc[i];
d357 1
a357 1
	if (i >= nifvlan || (ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
@


1.40
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.39 2003/07/25 03:45:42 jason Exp $ */
d566 1
a566 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.39
log
@%lu for u_long arg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.38 2003/05/13 00:55:12 jason Exp $ */
d209 1
a209 1
			    (caddr_t)&evh);
d268 1
a268 1
		m_copyback(m, 0, sizeof(struct ether_vlan_header), (caddr_t)&vh);
@


1.38
log
@nuke common: ifnet_addrs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.37 2003/05/03 21:15:11 deraadt Exp $ */
d389 1
a389 1
		printf("%s: initialized with non-standard mtu %d (parent %s)\n",
@


1.37
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.36 2003/05/03 01:43:07 itojun Exp $ */
d81 1
a81 1
struct	ifaddr	**ifnet_addrs;
@


1.36
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.35 2003/03/24 17:59:48 jason Exp $ */
d116 1
a116 1
		sprintf(ifp->if_xname, "vlan%d", i);
@


1.35
log
@Tree patches from c.pascoe at itee dot uq dot edu dot au:
- mask of vlan tag to ensure upper bit isn't present from hardware
- avoid mbuf leak on error
- make sure sizeof(ether_header) bytes are present in the firest mbuf
before passing it up to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.34 2003/02/01 00:14:40 chris Exp $ */
d354 2
@


1.34
log
@from Chris Pascoe <c.pascoe@@itee.uq.edu.au>:

Fix multicast bug; internal multicast members' list was not initialized
correctly.  Also, begin to make vlan less ether specific - TR and FDDI
could also be supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.33 2003/01/07 09:00:34 kjc Exp $ */
d244 1
d252 2
a253 1
		if (m->m_pkthdr.len < sizeof(struct ether_header))
d255 1
d260 2
a261 1
		M_PREPEND(m, EVL_ENCAPLEN, M_DONTWAIT);
d263 4
@


1.33
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.32 2002/06/12 01:42:29 chris Exp $ */
d113 1
a143 1
	LIST_INIT(&ifv->vlan_mc_listhead);
d622 1
d655 1
a655 2
	error = ether_ioctl(ifv->ifv_p, &ifv->ifv_ac, SIOCADDMULTI,
	    (caddr_t)ifr);
d658 1
d666 1
d673 1
d692 1
a692 2
	error = ether_ioctl(ifv->ifv_p, &ifv->ifv_ac, SIOCDELMULTI,
	    (caddr_t)ifr);
d729 1
a729 1
		memcpy(&ifr->ifr_addr, &mc->mc_addr, ETHER_ADDR_LEN);
@


1.32
log
@import of netbsd's vlan multicast code
this works better than what we have now, although i have not been
able to extensively test it.  several folks thought it should be added
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.31 2002/03/24 19:17:27 niklas Exp $ */
a139 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a159 20
#ifdef ALTQ
		/*
		 * If ALTQ is enabled on the parent interface, do
		 * classification; the queueing discipline might
		 * not require classification, but might require
		 * the address family/header pointer in the pktattr.
		 */
		if (ALTQ_IS_ENABLED(&p->if_snd)) {
			switch (p->if_type) {
			case IFT_ETHER:
				altq_etherclassify(&p->if_snd, m, &pktattr);
				break;
#ifdef DIAGNOSTIC
			default:
				panic("vlan_start: impossible (altq)");
#endif
			}
		}
#endif /* ALTQ */

d221 1
a221 1
		IFQ_ENQUEUE(&p->if_snd, m, &pktattr, error);
@


1.31
log
@deref of NULL in out of mbuf situation, ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.31 2002/03/24 18:55:43 niklas Exp $ */
d95 3
a97 48

/*
 * Program our multicast filter. What we're actually doing is
 * programming the multicast filter of the parent. This has the
 * side effect of causing the parent interface to receive multicast
 * traffic that it doesn't really want, which ends up being discarded
 * later by the upper protocol layers. Unfortunately, there's no way
 * to avoid this: there really is only one physical interface.
 */

int vlan_setmulti(struct ifnet *ifp)
{
	struct ifreq		*ifr_p;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	struct ifvlan		*sc;
	struct vlan_mc_entry	*mc = NULL;
	int			error;

	/* Find the parent. */
	sc = ifp->if_softc;
	ifr_p = (struct ifreq *)&sc->ifv_p->if_data;

	/* First, remove any existing filter entries. */
	while (!SLIST_EMPTY(&sc->vlan_mc_listhead)) {
		mc = SLIST_FIRST(&sc->vlan_mc_listhead);
		error = ether_delmulti(ifr_p, &sc->ifv_ac);
		if (error)
			return(error);
		SLIST_REMOVE_HEAD(&sc->vlan_mc_listhead, mc_entries);
		free(mc, M_DEVBUF);
	}

	/* Now program new ones. */
	ETHER_FIRST_MULTI(step, &sc->ifv_ac, enm);
	while (enm != NULL) {
		mc = malloc(sizeof(struct vlan_mc_entry), M_DEVBUF, M_NOWAIT);
		bcopy(enm->enm_addrlo,
		    (void *) &mc->mc_addr, ETHER_ADDR_LEN);
		SLIST_INSERT_HEAD(&sc->vlan_mc_listhead, mc, mc_entries);
		error = ether_addmulti(ifr_p, &sc->ifv_ac);
		if (error)
			return(error);
		ETHER_NEXT_MULTI(step, enm);
	}

	return(0);
}
d144 1
a460 2
	struct vlan_mc_entry *mc;
	int error;
d467 3
d476 1
a476 9
	while (!SLIST_EMPTY(&ifv->vlan_mc_listhead)) {
		mc = SLIST_FIRST(&ifv->vlan_mc_listhead);
		error = ether_delmulti(ifr_p, &ifv->ifv_ac);
		error = ether_delmulti(ifr, &ifv->ifv_ac);
		if (error)
			return(error);
		SLIST_REMOVE_HEAD(&ifv->vlan_mc_listhead, mc_entries);
		free(mc, M_DEVBUF);
	}
d625 4
d630 2
a631 5
		if (ifv->ifv_p != NULL) {
			error = vlan_setmulti(ifp);
		} else {
			error = EINVAL;
		}
d637 116
@


1.30
log
@Be -really- careful not to modify the payload when replacing the ethernet
header with the 802.1Q header.  The reason for this is if_vlan is called
by the bridge (via if_start).  It cannot modify the mbuf because it might
be shared copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.29 2001/12/11 05:13:37 jason Exp $ */
d367 1
d371 1
a371 1
		m->m_pkthdr.rcvif->if_ierrors++;
@


1.29
log
@Use queue.h macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.28 2001/10/05 06:32:34 drahn Exp $ */
a182 1
	struct ether_vlan_header *evl;
d252 1
a252 6
			if (m->m_len < sizeof(struct ether_header) &&
			    (m = m_pullup(m, sizeof(struct ether_header)))
			    == NULL) {
				ifp->if_ierrors++;
				continue;
			}
d254 6
a259 5
			if (m->m_flags & M_PKTHDR) {
				MGETHDR(m0, MT_DATA, M_DONTWAIT);
			} else {
				MGET(m0, MT_DATA, M_DONTWAIT);
			}
d261 2
a264 1
				m_freem(m);
d268 1
d270 2
a271 12
				M_MOVE_PKTHDR(m0, m);

			m0->m_flags &= ~M_PROTO1;
			m0->m_next = m;
			m0->m_len = sizeof(struct ether_vlan_header);

			evl = mtod(m0, struct ether_vlan_header *);
			bcopy(mtod(m, char *),
			    evl, sizeof(struct ether_header));
			evl->evl_proto = evl->evl_encap_proto;
			evl->evl_encap_proto = htons(ETHERTYPE_8021Q);
			evl->evl_tag = htons(ifv->ifv_tag);
d273 2
a274 2
			m->m_len -= sizeof(struct ether_header);
			m->m_data += sizeof(struct ether_header);
@


1.29.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.29 2001/12/11 05:13:37 jason Exp $ */
d183 1
d253 6
a258 1
			struct ether_vlan_header evh;
d260 5
a264 6
			m_copydata(m, 0, sizeof(struct ether_header),
			    (caddr_t)&evh);
			evh.evl_proto = evh.evl_encap_proto;
			evh.evl_encap_proto = htons(ETHERTYPE_8021Q);
			evh.evl_tag = htons(ifv->ifv_tag);
			m_adj(m, sizeof(struct ether_header));
a265 2
			m0 = m_prepend(m, sizeof(struct ether_vlan_header),
			    M_DONTWAIT);
d268 1
a271 1
			/* m_prepend() doesn't adjust m_pkthdr.len */
d273 12
a284 2
				m0->m_pkthdr.len +=
				    sizeof(struct ether_vlan_header);
d286 2
a287 2
			m_copyback(m0, 0, sizeof(struct ether_vlan_header),
			    (caddr_t)&evh);
a379 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d383 1
a383 1
		ifp->if_ierrors++;
@


1.29.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.29.2.1 2002/06/11 03:30:45 art Exp $ */
d95 48
a142 3
int	vlan_ether_addmulti(struct ifvlan *, struct ifreq *);
int	vlan_ether_delmulti(struct ifvlan *, struct ifreq *);
void	vlan_ether_purgemulti(struct ifvlan *);
a188 1
	LIST_INIT(&ifv->vlan_mc_listhead);
d505 2
a512 3
	if (p == NULL)
		return 0;

d519 9
a527 1
	vlan_ether_purgemulti(ifv);
a675 4
		error = (ifv->ifv_p != NULL) ?
		    vlan_ether_addmulti(ifv, ifr) : EINVAL;
		break;

d677 5
a681 2
		error = (ifv->ifv_p != NULL) ?
		    vlan_ether_delmulti(ifv, ifr) : EINVAL;
a686 116
}


int
vlan_ether_addmulti(struct ifvlan *ifv, struct ifreq *ifr)
{
	struct vlan_mc_entry *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	if (ifr->ifr_addr.sa_len > sizeof(struct sockaddr_storage))
		return (EINVAL);

	error = ether_addmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	if (error != ENETRESET)
		return (error);

	/*
	 * This is new multicast address.  We have to tell parent
	 * about it.  Also, remember this multicast address so that
	 * we can delete them on unconfigure.
	 */
	MALLOC(mc, struct vlan_mc_entry *, sizeof(struct vlan_mc_entry),
	    M_DEVBUF, M_NOWAIT);
	if (mc == NULL) {
		error = ENOMEM;
		goto alloc_failed;
	}

	/*
	 * As ether_addmulti() returns ENETRESET, following two
	 * statement shouldn't fail.
	 */
	(void)ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &ifv->ifv_ac, mc->mc_enm);
	memcpy(&mc->mc_addr, &ifr->ifr_addr, ifr->ifr_addr.sa_len);
	LIST_INSERT_HEAD(&ifv->vlan_mc_listhead, mc, mc_entries);

	error = ether_ioctl(ifv->ifv_p, &ifv->ifv_ac, SIOCADDMULTI,
	    (caddr_t)ifr);
	if (error != 0)
		goto ioctl_failed;
	return (error);

 ioctl_failed:
	LIST_REMOVE(mc, mc_entries);
	FREE(mc, M_DEVBUF);
 alloc_failed:
	(void)ether_delmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	return (error);
}

int
vlan_ether_delmulti(struct ifvlan *ifv, struct ifreq *ifr)
{
	struct ether_multi *enm;
	struct vlan_mc_entry *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	/*
	 * Find a key to lookup vlan_mc_entry.  We have to do this
	 * before calling ether_delmulti for obvious reason.
	 */
	if ((error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi)) != 0)
		return (error);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &ifv->ifv_ac, enm);

	error = ether_delmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	if (error != ENETRESET)
		return (error);

	/* We no longer use this multicast address.  Tell parent so. */
	error = ether_ioctl(ifv->ifv_p, &ifv->ifv_ac, SIOCDELMULTI,
	    (caddr_t)ifr);
	if (error == 0) {
		/* And forget about this address. */
		for (mc = LIST_FIRST(&ifv->vlan_mc_listhead); mc != NULL;
		    mc = LIST_NEXT(mc, mc_entries)) {
			if (mc->mc_enm == enm) {
				LIST_REMOVE(mc, mc_entries);
				FREE(mc, M_DEVBUF);
				break;
			}
		}
		KASSERT(mc != NULL);
	} else
		(void)ether_addmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	return (error);
}

/*
 * Delete any multicast address we have asked to add from parent
 * interface.  Called when the vlan is being unconfigured.
 */
void
vlan_ether_purgemulti(struct ifvlan *ifv)
{
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
	struct vlan_mc_entry *mc;
	union {
		struct ifreq ifreq;
		struct {
			char ifr_name[IFNAMSIZ];
			struct sockaddr_storage ifr_ss;
		} ifreq_storage;
	} ifreq;
	struct ifreq *ifr = &ifreq.ifreq;

	memcpy(ifr->ifr_name, ifp->if_xname, IFNAMSIZ);
	while ((mc = LIST_FIRST(&ifv->vlan_mc_listhead)) != NULL) {
		memcpy(&ifr->ifr_addr, &mc->mc_addr, ETHER_ADDR_LEN);
		(void)(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
		LIST_REMOVE(mc, mc_entries);
		FREE(mc, M_DEVBUF);
	}
@


1.29.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d81 1
a81 1
extern struct	ifaddr	**ifnet_addrs;
a112 1
		LIST_INIT(&ifv_softc[i].vlan_mc_listhead);
d115 1
a115 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "vlan%d", i);
d140 1
d144 1
d161 20
d242 1
a242 1
		IFQ_ENQUEUE(&p->if_snd, m, NULL, error);
a264 1
	t = EVL_VLANOFTAG(t);
d272 1
a272 2
		if (m->m_pkthdr.len < sizeof(struct ether_header)) {
			m_freem(m);
a273 1
		}
d278 1
a278 2
		m_adj(m, sizeof(struct ether_header));
		m = m_prepend(m, sizeof(struct ether_vlan_header), M_DONTWAIT);
a280 4
		m->m_pkthdr.len += sizeof(struct ether_vlan_header);
		if (m->m_len < sizeof(struct ether_vlan_header) &&
		    (m = m_pullup(m, sizeof(struct ether_vlan_header))) == NULL)
			return (-1);
a366 2

		m0.m_flags = 0;
a642 1
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
d675 2
a676 1
	error = (*ifp->if_ioctl)(ifp, SIOCADDMULTI, (caddr_t)ifr);
a678 1

a685 1

a691 1
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
d710 2
a711 1
	error = (*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
d748 1
a748 1
		memcpy(&ifr->ifr_addr, &mc->mc_addr, mc->mc_addr.ss_len);
@


1.28
log
@Fix bug in if_vlan which could cause crashes in timeouts and 'ifconfig -a'
ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.27 2001/10/01 09:27:31 niklas Exp $ */
d119 2
a120 2
	while(sc->vlan_mc_listhead.slh_first != NULL) {
		mc = sc->vlan_mc_listhead.slh_first;
d531 2
a532 3
	while(ifv->vlan_mc_listhead.slh_first != NULL) {

		mc = ifv->vlan_mc_listhead.slh_first;
@


1.27
log
@Make number of vlan interfaces configurable from UKC.
ok jason@@, chris@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.27 2001/10/01 09:22:01 niklas Exp $ */
d155 1
a155 1
	bzero(ifv_softc, nifvlan * sizeof(ifv_softc));
@


1.26
log
@Inherit baudrate from parent.  Now MRTG will show vlan interfaces ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.25 2001/08/03 23:21:19 chris Exp $ */
a52 1
#if NVLAN > 0
d83 2
a84 1
struct ifvlan ifv_softc[NVLAN];
d93 1
a93 1
void	vlanattach (void *dummy);
d145 1
a145 1
vlanattach(void *dummy)
d150 6
a155 1
	bzero(ifv_softc, sizeof(ifv_softc));
d157 1
a157 1
	for (i = 0; i < NVLAN; i++) {
d322 1
a322 1
	for (i = 0; i < NVLAN; i++) {
d328 1
a328 1
	if (i >= NVLAN) {
d389 1
a389 1
	for (i = 0; i < NVLAN; i++) {
d395 1
a395 1
	if (i >= NVLAN || (ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
a700 2

#endif /* NVLAN > 0 */
@


1.25
log
@Use IFCAP_VLAN_MTU and IFCAP_VLAN_HWTAGGING capabilities:

LINK0 disappears; we now set IFCAP_VLAN_HWTAGGING at ifnet->if_capabilities
in the Ethernet driver for cards/drivers which support hardware tagging.

MTU ambiguity disppears; we now set IFCAP_VLAN_MTU in the Ethernet driver
when we know the chip will not truncate/discard vlan-sized frames.

Only allow the MTU to be changed within the scope of the parent interface's
MTU.  (Here we also take into account IFCAP_VLAN_MTU)

Propagate hardware-assisted IP/TCP/UDP checksumming flags to the vlan interface
if the card supports hardware tagging (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.24 2001/06/27 06:07:46 kjc Exp $ */
d465 6
@


1.24
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.23 2001/06/27 03:49:53 angelos Exp $ */
d44 4
a47 10
 *
 * XXX It's incorrect to assume that we must always kludge up
 * headers on the physical device's behalf: some devices support
 * VLAN tag insersion and extraction in firmware. For these cases,
 * one can change the behavior of the vlan interface by setting
 * the LINK0 flag on it (that is setting the vlan interface's LINK0
 * flag, _not_ the parent's LINK0 flag; we try to leave the parent
 * alone). If the interface has the LINK0 flag set, then it will
 * not modify the ethernet header on output because the parent
 * can do that for itself. On input, the parent can call vlan_input_tag()
d227 3
a229 3
		 * If the LINK0 flag is set, it means the underlying interface
		 * can do VLAN tag insertion itself and doesn't require us to
	 	 * create a special header for it. In this case, we just pass
d244 1
a244 1
		if (ifp->if_flags & IFF_LINK0) {
d441 16
a456 1
	ifv->ifv_if.if_mtu = p->if_data.ifi_mtu;
d467 17
d578 1
a578 1
	int error = 0;
d614 11
a624 7
		/*
		 * XXX Set the interface MTU.
		 * This is bogus. The underlying interface might support
	 	 * jumbo frames.  It would be nice to replace ETHERMTU
		 * with the parent interface's MTU in the following statement.
		 */
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
d626 1
a626 3
		} else {
			ifp->if_mtu = ifr->ifr_mtu;
		}
@


1.23
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.22 2001/06/25 02:53:29 angelos Exp $ */
d168 2
a169 1
		ifp->if_snd.ifq_maxlen = ifqmaxlen;
d186 2
d194 1
a194 1
		IF_DEQUEUE(&ifp->if_snd, m);
d207 20
d297 6
a302 3
		if (IF_QFULL(&p->if_snd)) {
			IF_DROP(&p->if_snd);
				/* XXX stats */
a303 1
			m_freem(m);
d306 1
a306 4
		p->if_obytes += m->m_pkthdr.len;
		if (m->m_flags & M_MCAST)
			p->if_omcasts++;
		IF_ENQUEUE(&p->if_snd, m);
@


1.22
log
@No need to double-clear the mbuf flags and tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.21 2001/06/24 22:52:07 jason Exp $ */
d251 1
a251 1
				M_COPY_PKTHDR(m0, m);
@


1.21
log
@- redefine vlan_input_tag to take mbuf * and tag only
- call ether_input_mbuf() instead of ether_input()
- most work done by fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.20 2001/06/23 23:01:26 jason Exp $ */
d250 1
a250 1
			if (m0->m_flags & M_PKTHDR) {
d252 1
a252 3
				m->m_flags &= ~M_PKTHDR;
				m_tag_init(m);
			}
@


1.20
log
@Ok, when cards with vlan hw tagging are used in bridged configurations
and the tag doesn't match a child interface, reinsert the tag and call
ether_input() so that bridges can still function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.19 2001/06/23 04:01:19 aaron Exp $ */
d297 1
a297 1
vlan_input_tag(struct ether_header *eh, struct mbuf *m, u_int16_t t)
d301 1
d310 6
a315 13
		struct ether_header neh;
		u_int16_t ntype, *np;

		/*
		 * Reinsert tag and pass it up to ether_input().
		 * This allows bridging to continue to work with
		 * cards that do automatic vlan tagging.  NOTE:
		 * we're very careful to not disturb possibly
		 * overlapping memory.
		 */
		bcopy(eh, &neh, sizeof(neh));
		ntype = neh.ether_type;
		neh.ether_type = htons(ETHERTYPE_8021Q);
d319 2
a320 4
		np = mtod(m, u_int16_t *);
		np[0] = htons(t);
		np[1] = ntype;
		ether_input(m->m_pkthdr.rcvif, &neh, m);
d345 1
a345 5
		struct mbuf m0;
		m0.m_next = m;
		m0.m_len = sizeof(struct ether_header);
		m0.m_data = (char *)eh;
		bpf_mtap(ifv->ifv_if.if_bpf, &m0);
d349 1
a349 1
	ether_input(&ifv->ifv_if, eh, m);
@


1.19
log
@Use standard defined macros to access inner ifnet data structure members.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.18 2001/06/22 14:28:58 deraadt Exp $ */
d308 25
a332 1
	if (i >= NVLAN || (ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
d335 1
a335 1
		return -1;	/* so the parent can take note */
d341 1
a341 1
	 * the real packet through ethert_input().
@


1.18
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.17 2001/05/27 11:58:25 angelos Exp $ */
d173 2
a174 2
		ifp->if_data.ifi_type = IFT_8021_VLAN;
		ifp->if_data.ifi_hdrlen = EVL_ENCAPLEN;
d410 1
a410 1
	if (p->if_data.ifi_type != IFT_ETHER)
@


1.17
log
@Initialize old mbuf chain head tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.16 2001/03/30 16:02:13 jason Exp $ */
d139 1
a139 1
		      (void *) &mc->mc_addr, ETHER_ADDR_LEN);
d551 1
a551 1
			      (caddr_t) sa->sa_data, ETHER_ADDR_LEN);
@


1.16
log
@increase ierrors if m_pullup fails in vlan_input(); pointed out by chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.15 2001/03/28 00:16:28 jason Exp $ */
d253 1
@


1.16.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.16 2001/03/30 16:02:13 jason Exp $ */
@


1.16.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.16.4.1 2001/05/14 22:40:02 niklas Exp $ */
d139 1
a139 1
		    (void *) &mc->mc_addr, ETHER_ADDR_LEN);
d168 1
a168 2
		IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
		IFQ_SET_READY(&ifp->if_snd);
d173 2
a174 2
		ifp->if_type = IFT_8021_VLAN;
		ifp->if_hdrlen = EVL_ENCAPLEN;
a184 2
	int error;
	ALTQ_DECL(struct altq_pktattr pktattr;)
d191 1
a191 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
a203 20
#ifdef ALTQ
		/*
		 * If ALTQ is enabled on the parent interface, do
		 * classification; the queueing discipline might
		 * not require classification, but might require
		 * the address family/header pointer in the pktattr.
		 */
		if (ALTQ_IS_ENABLED(&p->if_snd)) {
			switch (p->if_type) {
			case IFT_ETHER:
				altq_etherclassify(&p->if_snd, m, &pktattr);
				break;
#ifdef DIAGNOSTIC
			default:
				panic("vlan_start: impossible (altq)");
#endif
			}
		}
#endif /* ALTQ */

d250 4
a253 3
			if (m0->m_flags & M_PKTHDR)
				M_MOVE_PKTHDR(m0, m);

d275 7
d285 1
a285 7
		IFQ_ENQUEUE(&p->if_snd, m, &pktattr, error);
		if (error) {
			/* mbuf is already freed */
			ifp->if_oerrors++;
			continue;
		}

d296 1
a296 1
vlan_input_tag(struct mbuf *m, u_int16_t t)
a299 1
	struct ether_vlan_header vh;
d307 1
a307 16
	if (i >= NVLAN) {
		if (m->m_pkthdr.len < sizeof(struct ether_header))
			return (-1);
		m_copydata(m, 0, sizeof(struct ether_header), (caddr_t)&vh);
		vh.evl_proto = vh.evl_encap_proto;
		vh.evl_tag = htons(t);
		vh.evl_encap_proto = htons(ETHERTYPE_8021Q);
		M_PREPEND(m, EVL_ENCAPLEN, M_DONTWAIT);
		if (m == NULL)
			return (-1);
		m_copyback(m, 0, sizeof(struct ether_vlan_header), (caddr_t)&vh);
		ether_input_mbuf(m->m_pkthdr.rcvif, m);
		return (-1);
	}

	if ((ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
d310 1
a310 1
		return (-1);
d316 1
a316 1
	 * the real packet through ether_input().
d328 5
a332 1
		bpf_mtap(ifv->ifv_if.if_bpf, m);
d336 1
a336 1
	ether_input_mbuf(&ifv->ifv_if, m);
d409 1
a409 1
	if (p->if_type != IFT_ETHER)
d550 1
a550 1
			    (caddr_t) sa->sa_data, ETHER_ADDR_LEN);
@


1.16.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.16.4.2 2001/07/04 10:54:12 niklas Exp $ */
d44 10
a53 4
 * Some devices support 802.1Q tag insertion and extraction in firmware.
 * The vlan interface behavior changes when the IFCAP_VLAN_HWTAGGING
 * capability is set on the parent.  In this case, vlan_start() will not
 * modify the ethernet header.  On input, the parent can call vlan_input_tag()
d59 1
d90 1
a90 2
struct ifvlan *ifv_softc;
int nifvlan;
d99 1
a99 1
void	vlanattach (int count);
d151 1
a151 1
vlanattach(int count)
d156 1
a156 6
	MALLOC(ifv_softc, struct ifvlan *, count * sizeof(struct ifvlan),
	    M_DEVBUF, M_NOWAIT);
	if (ifv_softc == NULL)
		panic("vlanattach: MALLOC failed");
	nifvlan = count;
	bzero(ifv_softc, nifvlan * sizeof(struct ifvlan));
d158 1
a158 1
	for (i = 0; i < nifvlan; i++) {
d233 3
a235 3
		 * If the IFCAP_VLAN_HWTAGGING capability is set on the parent,
		 * it can do VLAN tag insertion itself and doesn't require us
	 	 * to create a special header for it. In this case, we just pass
d250 1
a250 1
		if (p->if_capabilities & IFCAP_VLAN_HWTAGGING) {
d323 1
a323 1
	for (i = 0; i < nifvlan; i++) {
d329 1
a329 1
	if (i >= nifvlan) {
d390 1
a390 1
	for (i = 0; i < nifvlan; i++) {
d396 1
a396 1
	if (i >= nifvlan || (ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
d447 1
a447 16

	if (p->if_capabilities & IFCAP_VLAN_MTU)
		ifv->ifv_if.if_mtu = p->if_mtu;
	else {
		/*
		 * This will be incompatible with strict
		 * 802.1Q implementations
		 */
		ifv->ifv_if.if_mtu = p->if_mtu - EVL_ENCAPLEN;
#ifdef DIAGNOSTIC
		printf("%s: initialized with non-standard mtu %d (parent %s)\n",
		    ifv->ifv_if.if_xname, ifv->ifv_if.if_mtu,
		    ifv->ifv_p->if_xname);
#endif
	}

a457 23
	 * Inherit baudrate from the parent.  An SNMP agent would use this
	 * information.
	 */
	ifv->ifv_if.if_baudrate = p->if_baudrate;

	/*
	 * If the parent interface can do hardware-assisted
	 * VLAN encapsulation, then propagate its hardware-
	 * assisted checksumming flags.
	 *
	 * If the card cannot handle hardware tagging, it cannot
	 * possibly compute the correct checksums for tagged packets.
	 *
	 * This brings up another possibility, do cards exist which
	 * have all of these capabilities but cannot utilize them together?
	 */
	if (p->if_capabilities & IFCAP_VLAN_HWTAGGING)
		ifv->ifv_if.if_capabilities = p->if_capabilities &
		    (IFCAP_CSUM_IPv4|IFCAP_CSUM_TCPv4|
		    IFCAP_CSUM_UDPv4);
		/* (IFCAP_CSUM_TCPv6|IFCAP_CSUM_UDPv6); */

	/*
d552 1
a552 1
	int error = 0, p_mtu = 0;
d588 7
a594 11
		if (ifv->ifv_p != NULL) {
			if (ifv->ifv_p->if_capabilities & IFCAP_VLAN_MTU)
				p_mtu = ifv->ifv_p->if_mtu;
			else
				p_mtu = ifv->ifv_p->if_mtu - EVL_ENCAPLEN;
			
			if (ifr->ifr_mtu > p_mtu || ifr->ifr_mtu < ETHERMIN)
				error = EINVAL;
			else
				ifp->if_mtu = ifr->ifr_mtu;
		} else
d596 3
a598 1

d662 2
@


1.16.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d119 2
a120 2
	while (!SLIST_EMPTY(&sc->vlan_mc_listhead)) {
		mc = SLIST_FIRST(&sc->vlan_mc_listhead);
d183 1
d253 6
a258 1
			struct ether_vlan_header evh;
d260 5
a264 6
			m_copydata(m, 0, sizeof(struct ether_header),
			    (caddr_t)&evh);
			evh.evl_proto = evh.evl_encap_proto;
			evh.evl_encap_proto = htons(ETHERTYPE_8021Q);
			evh.evl_tag = htons(ifv->ifv_tag);
			m_adj(m, sizeof(struct ether_header));
a265 2
			m0 = m_prepend(m, sizeof(struct ether_vlan_header),
			    M_DONTWAIT);
d268 1
a271 1
			/* m_prepend() doesn't adjust m_pkthdr.len */
d273 12
a284 2
				m0->m_pkthdr.len +=
				    sizeof(struct ether_vlan_header);
d286 2
a287 2
			m_copyback(m0, 0, sizeof(struct ether_vlan_header),
			    (caddr_t)&evh);
d531 3
a533 2
	while (!SLIST_EMPTY(&ifv->vlan_mc_listhead)) {
		mc = SLIST_FIRST(&ifv->vlan_mc_listhead);
@


1.16.4.5
log
@Sync the SMP branch with 3.3
@
text
@d95 48
a142 3
int	vlan_ether_addmulti(struct ifvlan *, struct ifreq *);
int	vlan_ether_delmulti(struct ifvlan *, struct ifreq *);
void	vlan_ether_purgemulti(struct ifvlan *);
a157 1
		LIST_INIT(&ifv_softc[i].vlan_mc_listhead);
d185 1
d205 20
d286 1
a286 1
		IFQ_ENQUEUE(&p->if_snd, m, NULL, error);
a308 1
	t = EVL_VLANOFTAG(t);
d316 1
a316 2
		if (m->m_pkthdr.len < sizeof(struct ether_header)) {
			m_freem(m);
a317 1
		}
d322 1
a322 2
		m_adj(m, sizeof(struct ether_header));
		m = m_prepend(m, sizeof(struct ether_vlan_header), M_DONTWAIT);
a324 4
		m->m_pkthdr.len += sizeof(struct ether_vlan_header);
		if (m->m_len < sizeof(struct ether_vlan_header) &&
		    (m = m_pullup(m, sizeof(struct ether_vlan_header))) == NULL)
			return (-1);
a366 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d370 1
a370 1
		ifp->if_ierrors++;
d504 2
a511 3
	if (p == NULL)
		return 0;

d518 9
a526 1
	vlan_ether_purgemulti(ifv);
a674 4
		error = (ifv->ifv_p != NULL) ?
		    vlan_ether_addmulti(ifv, ifr) : EINVAL;
		break;

d676 5
a680 2
		error = (ifv->ifv_p != NULL) ?
		    vlan_ether_delmulti(ifv, ifr) : EINVAL;
a685 118
}


int
vlan_ether_addmulti(struct ifvlan *ifv, struct ifreq *ifr)
{
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
	struct vlan_mc_entry *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	if (ifr->ifr_addr.sa_len > sizeof(struct sockaddr_storage))
		return (EINVAL);

	error = ether_addmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	if (error != ENETRESET)
		return (error);

	/*
	 * This is new multicast address.  We have to tell parent
	 * about it.  Also, remember this multicast address so that
	 * we can delete them on unconfigure.
	 */
	MALLOC(mc, struct vlan_mc_entry *, sizeof(struct vlan_mc_entry),
	    M_DEVBUF, M_NOWAIT);
	if (mc == NULL) {
		error = ENOMEM;
		goto alloc_failed;
	}

	/*
	 * As ether_addmulti() returns ENETRESET, following two
	 * statement shouldn't fail.
	 */
	(void)ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &ifv->ifv_ac, mc->mc_enm);
	memcpy(&mc->mc_addr, &ifr->ifr_addr, ifr->ifr_addr.sa_len);
	LIST_INSERT_HEAD(&ifv->vlan_mc_listhead, mc, mc_entries);

	error = (*ifp->if_ioctl)(ifp, SIOCADDMULTI, (caddr_t)ifr);
	if (error != 0)
		goto ioctl_failed;

	return (error);

 ioctl_failed:
	LIST_REMOVE(mc, mc_entries);
	FREE(mc, M_DEVBUF);
 alloc_failed:
	(void)ether_delmulti(ifr, (struct arpcom *)&ifv->ifv_ac);

	return (error);
}

int
vlan_ether_delmulti(struct ifvlan *ifv, struct ifreq *ifr)
{
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
	struct ether_multi *enm;
	struct vlan_mc_entry *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	/*
	 * Find a key to lookup vlan_mc_entry.  We have to do this
	 * before calling ether_delmulti for obvious reason.
	 */
	if ((error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi)) != 0)
		return (error);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &ifv->ifv_ac, enm);

	error = ether_delmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	if (error != ENETRESET)
		return (error);

	/* We no longer use this multicast address.  Tell parent so. */
	error = (*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
	if (error == 0) {
		/* And forget about this address. */
		for (mc = LIST_FIRST(&ifv->vlan_mc_listhead); mc != NULL;
		    mc = LIST_NEXT(mc, mc_entries)) {
			if (mc->mc_enm == enm) {
				LIST_REMOVE(mc, mc_entries);
				FREE(mc, M_DEVBUF);
				break;
			}
		}
		KASSERT(mc != NULL);
	} else
		(void)ether_addmulti(ifr, (struct arpcom *)&ifv->ifv_ac);
	return (error);
}

/*
 * Delete any multicast address we have asked to add from parent
 * interface.  Called when the vlan is being unconfigured.
 */
void
vlan_ether_purgemulti(struct ifvlan *ifv)
{
	struct ifnet *ifp = ifv->ifv_p;		/* Parent. */
	struct vlan_mc_entry *mc;
	union {
		struct ifreq ifreq;
		struct {
			char ifr_name[IFNAMSIZ];
			struct sockaddr_storage ifr_ss;
		} ifreq_storage;
	} ifreq;
	struct ifreq *ifr = &ifreq.ifreq;

	memcpy(ifr->ifr_name, ifp->if_xname, IFNAMSIZ);
	while ((mc = LIST_FIRST(&ifv->vlan_mc_listhead)) != NULL) {
		memcpy(&ifr->ifr_addr, &mc->mc_addr, mc->mc_addr.ss_len);
		(void)(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
		LIST_REMOVE(mc, mc_entries);
		FREE(mc, M_DEVBUF);
	}
@


1.16.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.16.4.5 2003/03/28 00:41:28 niklas Exp $ */
d116 1
a116 1
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "vlan%d", i);
a353 2

		m0.m_flags = 0;
@


1.16.4.7
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d81 1
a81 1
extern struct	ifaddr	**ifnet_addrs;
@


1.16.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d82 4
a97 4
int	vlan_clone_create(struct if_clone *, int);
int	vlan_clone_destroy(struct ifnet *);

LIST_HEAD(, ifvlan) vlan_list;
a98 4
struct if_clone vlan_cloner =
    IF_CLONE_INITIALIZER("vlan", vlan_clone_create, vlan_clone_destroy);

/* ARGSUSED */
a101 8
	LIST_INIT(&vlan_list);
	if_clone_attach(&vlan_cloner);
}

int
vlan_clone_create(struct if_clone *ifc, int unit)
{
	struct ifvlan *ifv;
d103 1
a103 1
	int s;
d105 27
a131 51
	ifv = malloc(sizeof(*ifv), M_DEVBUF, M_NOWAIT);
	if (!ifv)
		return (ENOMEM);
	bzero(ifv, sizeof(*ifv));

	LIST_INIT(&ifv->vlan_mc_listhead);
	ifp = &ifv->ifv_if;
	ifp->if_softc = ifv;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name,
	    unit);
	/* NB: flags are not set here */
	/* NB: mtu is not set here */

	ifp->if_start = vlan_start;
	ifp->if_ioctl = vlan_ioctl;
	ifp->if_output = ether_output;
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
	IFQ_SET_READY(&ifp->if_snd);
	if_attach(ifp);
	ether_ifattach(ifp);

	/* Now undo some of the damage... */
	ifp->if_type = IFT_8021_VLAN;
	ifp->if_hdrlen = EVL_ENCAPLEN;

	s = splnet();
	LIST_INSERT_HEAD(&vlan_list, ifv, ifv_list);
	splx(s);

	return (0);
}

int
vlan_clone_destroy(struct ifnet *ifp)
{
	struct ifvlan *ifv = ifp->if_softc;
	int s;

	s = splnet();
	LIST_REMOVE(ifv, ifv_list);
	splx(s);

	vlan_unconfig(ifp);
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif  
	ether_ifdetach(ifp);
	if_detach(ifp);

	free(ifv, M_DEVBUF);
	return (0);
d209 1
a209 1
			    &evh);
d240 1
d245 2
a246 1
	LIST_FOREACH(ifv, &vlan_list, ifv_list) {
d251 1
a251 1
	if (ifv == NULL) {
d268 1
a268 1
		m_copyback(m, 0, sizeof(struct ether_vlan_header), &vh);
d307 1
d320 2
a321 1
	LIST_FOREACH(ifv, &vlan_list, ifv_list) {
d326 1
a326 1
	if (ifv == NULL || (ifv->ifv_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
d389 1
a389 1
		printf("%s: initialized with non-standard mtu %lu (parent %s)\n",
d566 1
a566 1
		if ((error = suser(p, 0)) != 0)
a636 1
	/* XXX: sa_len is too small for such comparison
a638 1
	*/
@


1.16.4.9
log
@Merge with the trunk
@
text
@a82 5
u_long vlan_tagmask;

#define TAG_HASH_SIZE	32
#define TAG_HASH(tag)	(tag & vlan_tagmask)
LIST_HEAD(, ifvlan)	*vlan_tagh;
d88 1
a88 1
int	vlan_config (struct ifvlan *, struct ifnet *, u_int16_t);
d97 2
d106 1
a106 4
	vlan_tagh = hashinit(TAG_HASH_SIZE, M_DEVBUF, M_NOWAIT, &vlan_tagmask);
	if (vlan_tagh == NULL)
		panic("vlanattach: hashinit");

d115 1
d142 4
d153 5
d280 1
a280 1
	LIST_FOREACH(ifv, &vlan_tagh[TAG_HASH(t)], ifv_list) {
d353 1
a353 1
	LIST_FOREACH(ifv, &vlan_tagh[TAG_HASH(tag)], ifv_list) {
d401 1
a401 1
vlan_config(struct ifvlan *ifv, struct ifnet *p, u_int16_t tag)
a404 1
	int s;
a470 6

	ifv->ifv_tag = tag;
	s = splnet();
	LIST_INSERT_HEAD(&vlan_tagh[TAG_HASH(tag)], ifv, ifv_list);
	splx(s);

a481 1
	int s;
a490 4
	s = splnet();
	LIST_REMOVE(ifv, ifv_list);
	splx(s);

d546 1
a546 1
	int error = 0, p_mtu = 0, s;
a602 1
			s = splimp();
a605 1
			splx(s);
d617 1
a617 1
		error = vlan_config(ifv, pr, vlr.vlr_tag);
d620 1
@


1.15
log
@Rework vlan_start() to make sure it -never- munges the packet internals (eg.
shared mbuf clusters)
Revert the deleted m_adj() call in vlan_input() back to inline mbuf
manipulation, all of the checks really are there by API/convention.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.14 2001/03/26 23:07:38 jason Exp $ */
d350 4
a353 2
	    (m = m_pullup(m, EVL_ENCAPLEN)) == NULL)
		return (-1);
@


1.14
log
@Fix bug I introduced... if m_pullup fails, don't try to free the result.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.13 2001/03/26 19:00:58 jason Exp $ */
d184 1
a184 1
	struct mbuf *m;
d231 3
a233 7
			m->m_flags &= ~M_PROTO1;
			M_PREPEND(m, EVL_ENCAPLEN, M_DONTWAIT);
			if (m == NULL) {
#ifdef DEBUG
				printf("%s: M_PREPEND failed\n",
				    ifv->ifv_p->if_xname);
#endif
a236 1
			/* M_PREPEND takes care of m_len, m_pkthdr.len for us */
d238 7
a244 6
			m = m_pullup(m, ETHER_HDR_LEN + EVL_ENCAPLEN);
			if (m == NULL) {
#ifdef DEBUG
				printf("%s: m_pullup failed\n",
				    ifv->ifv_p->if_xname);
#endif
d246 1
d250 11
a260 7
			/*
			 * Transform the Ethernet header into an Ethernet header
			 * with 802.1Q encapsulation.
			 */
			bcopy(mtod(m, char *) + EVL_ENCAPLEN, mtod(m, char *),
			      sizeof(struct ether_header));
			evl = mtod(m, struct ether_vlan_header *);
d264 5
a268 4
#ifdef DEBUG
			printf("vlan_start: %*D\n", sizeof *evl,
			    (char *)evl, ":");
#endif
d376 3
a378 1
	m_adj(m, EVL_ENCAPLEN);
@


1.13
log
@- move if_vlan back to a default if_type of IFT_PROPVIRTUAL
- change if_type to match parent at vlan_configure time
- comment typo
- implement promiscuous mode for vlan interfaces (from NetBSD)
- change if_flags inheritance mask to UP|BROADCAST|SIMPLE|MULTICAST
(upshot of all this: bridging vlan interfaces works, with some limitations...
documentation soon)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.12 2001/03/23 07:45:42 jason Exp $ */
d348 1
a348 2
	    (m = m_pullup(m, EVL_ENCAPLEN)) == NULL) {
		m_freem(m);
a349 1
	}
@


1.12
log
@check rcvif and tag for vlan_input_tag() [Same check as in vlan_input()]
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.11 2001/03/23 07:37:21 jason Exp $ */
d51 1
a51 1
 * alone). If the interface as the LINK0 flag set, then it will
d100 1
d411 2
d415 2
a416 1
	 * Preserve the state of the LINK0 flag for ourselves.
d418 1
a418 1
	ifv->ifv_if.if_flags = (p->if_flags & ~(IFF_LINK0));
d484 23
d589 3
d606 2
a607 3
		 * We don't support promiscuous mode
		 * right now because it would require help from the
		 * underlying drivers, which hasn't been implemented.
d609 2
a610 4
		if (ifr->ifr_flags & (IFF_PROMISC)) {
			ifp->if_flags &= ~(IFF_PROMISC);
			error = EINVAL;
		}
@


1.11
log
@m_freem not m_free
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.10 2001/03/23 07:14:53 jason Exp $ */
d300 1
a300 1
		if (ifv->ifv_tag == t)
@


1.10
log
@check packet length in vlan_input() and pullup if necessary
use m_adj instead of twiddling everything ourselves
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.9 2001/03/22 05:26:35 jason Exp $ */
d306 1
a306 1
		m_free(m);
@


1.9
log
@remove vlan_proto variable, replace with ETHERTYPE_8021Q
define if_type for vlan interfaces (IFT_8021_VLAN)
#ifdef DEBUG some debugging printf's
protect against other uses of M_PROTO1
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.8 2001/02/20 19:39:48 mickey Exp $ */
d346 6
d375 1
a375 3
	m->m_data += EVL_ENCAPLEN;
	m->m_len -= EVL_ENCAPLEN;
	m->m_pkthdr.len -= EVL_ENCAPLEN;
@


1.8
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.7 2000/12/02 14:46:34 jason Exp $ */
a89 2
u_int	vlan_proto = ETHERTYPE_8021Q;

d191 1
a191 1
		if (m == 0)
d230 1
d233 4
a236 1
				printf("%s: M_PREPEND failed", ifv->ifv_p->if_xname);
d244 4
a247 1
				printf("%s: m_pullup failed", ifv->ifv_p->if_xname);
d260 1
a260 1
			evl->evl_encap_proto = htons(vlan_proto);
d549 1
a549 1
		if (pr == 0) {
@


1.7
log
@vlan devices should not try to emit packets if the parent interface is
not running and not up.
From NetBSD: move if_opackets to that it's incremented even if the parent
interface is oactive.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.6 2000/10/18 15:55:48 chris Exp $ */
d172 1
a172 3
#if NBPFILTER > 0
		bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.6
log
@From the NetBSD port of if_vlan, prevent a panic by not allowing
SIOCSIFADDR/SIOCADDMULTI/SIOCDELMULTI until the vlan is configured, make
the loop at the top of vlan_input() easier to read
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.5 2000/08/15 22:21:17 chris Exp $ */
d197 10
d280 2
a281 1
		if ((p->if_flags & IFF_OACTIVE) == 0) {
a282 2
			ifp->if_opackets++;
		}
@


1.5
log
@Increase if_obytes and if_omcasts in the output routine,
as it replaces ether_output and ether_output does this...
(peter.jeremy@@alcatel.com.au FreeBSD PR 20611)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.4 2000/05/15 19:15:00 chris Exp $ */
d332 3
d338 1
a338 3
		if (m->m_pkthdr.rcvif == ifv->ifv_p
		    && (EVL_VLANOFTAG(ntohs(*mtod(m, u_int16_t *)))
			== ifv->ifv_tag))
d480 2
a481 1
		ifp->if_flags |= IFF_UP;
d483 1
a483 1
		switch (ifa->ifa_addr->sa_family) {
d485 3
a487 3
		case AF_INET:
			arp_ifinit(&ifv->ifv_ac, ifa);
			break;
d489 5
a493 2
		default:
			break;
d571 5
a575 1
		error = vlan_setmulti(ifp);
@


1.4
log
@Check to make sure vlan tag is valid (12bit) in SIOCSETVLAN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.3 2000/04/27 00:00:24 chris Exp $ */
d266 3
@


1.3
log
@Fix SIOCSIFMTU
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.2 2000/04/26 22:57:27 chris Exp $ */
d522 4
@


1.2
log
@Remove redundant superuser check in SIOCSIFMTU
(already done in if.c) and modify comments
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vlan.c,v 1.1 2000/04/26 19:03:11 chris Exp $ */
d506 1
a506 1
		if (ifr->ifr_mtu > ETHERMTU) {
@


1.1
log
@if_vlan from FreeBSD and a few modifications
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d501 1
a501 1
		 * Set the interface MTU.
d503 2
a504 1
	 	 * jumbo frames.
a505 2
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
			break;
@

