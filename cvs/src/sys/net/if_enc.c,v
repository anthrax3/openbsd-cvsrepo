head	1.67;
access;
symbols
	OPENBSD_6_1:1.67.0.4
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.64.0.6
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.52.0.14
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.12
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.52.0.10
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.8
	OPENBSD_5_0:1.52.0.6
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.52.0.4
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.47.0.8
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.47.0.10
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.6
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.4
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.42.0.4
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.40.0.6
	OPENBSD_3_6_BASE:1.40
	SMP_SYNC_A:1.40
	SMP_SYNC_B:1.40
	OPENBSD_3_5:1.40.0.4
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.39.0.4
	OPENBSD_3_3_BASE:1.39
	OPENBSD_3_2:1.39.0.2
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	UBC_SYNC_B:1.39
	UBC:1.36.0.4
	UBC_BASE:1.36
	OPENBSD_3_0:1.36.0.2
	OPENBSD_3_0_BASE:1.36
	OPENBSD_2_9_BASE:1.33
	OPENBSD_2_9:1.33.0.2
	OPENBSD_2_8:1.31.0.2
	OPENBSD_2_8_BASE:1.31
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.13
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.67
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.66;
commitid	F6oNrr9LCLUSAxgA;

1.66
date	2017.01.20.00.51.56;	author mpi;	state Exp;
branches;
next	1.65;
commitid	ASQosbhukUA3DGlR;

1.65
date	2016.09.04.21.46.36;	author krw;	state Exp;
branches;
next	1.64;
commitid	6ClKVqGVUyppaldq;

1.64
date	2015.11.09.10.19.10;	author dlg;	state Exp;
branches;
next	1.63;
commitid	qfv15RLJHn2K4MpV;

1.63
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.62;
commitid	7wrRch1SS813fOcY;

1.62
date	2015.10.22.17.48.34;	author mpi;	state Exp;
branches;
next	1.61;
commitid	ToMJCJHoIWfUEPhu;

1.61
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.60;
commitid	tp9bS9eCrwvRYjyO;

1.60
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.59;
commitid	p4LJxGKbi0BU2cG6;

1.59
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.58;
commitid	20ZyHa9gTJxHxhwD;

1.58
date	2014.12.08.10.46.14;	author mpi;	state Exp;
branches;
next	1.57;
commitid	ExaN0TCQ4X0c1lo6;

1.57
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.56;
commitid	t9FBKDfc4VDxpEy2;

1.56
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.55;
commitid	ZqXwxwmeo3l29NOg;

1.55
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.54;
commitid	B4dZSbxas1X1IpXI;

1.54
date	2014.05.21.14.48.28;	author mpi;	state Exp;
branches;
next	1.53;

1.53
date	2013.09.27.14.10.01;	author bluhm;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.01.01.55.03;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.29.21.28.37;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.09.20.59.07;	author oga;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.20.02.53.02;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.26.17.13.30;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2006.12.12.15.08.36;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.28.12.02.26;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.08.06.35.04;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.09.15.17.46.44;	author grange;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.03.21.15.11;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.29.07.54.58;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.14.01.27.09;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.27.02.00.30;	author provos;	state Exp;
branches
	1.36.4.1;
next	1.35;

1.35
date	2001.06.25.05.14.00;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.08.04.02.19;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.06.04.42.07;	author csapuntz;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.30.22.56.23;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.20.04.17.31;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.18.06.41.23;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.18.06.35.02;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.12.18.05.47;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.10.07.34.53;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.10.04.39.41;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.10.02.34.07;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.10.02.33.32;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.10.01.56.49;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.08.16.55.58;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.17.10.25.21;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.07.06.09.08;	author itojun;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.01.25.17.18.59;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.15.19.38.09;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.07.20.14.51;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.02.09.22.58;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	99.12.27.04.35.09;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	99.12.27.03.06.40;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	99.11.02.00.15.56;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	99.10.29.05.22.41;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	99.07.05.20.17.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.05.16.21.35.54;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	98.06.28.18.49.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.06.10.23.57.10;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	98.05.18.21.10.19;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.11.04.09.10.55;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.07.11.23.37.53;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.07.01.22.12.39;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.02.27.04.05.45;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.24.13.33.58;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.41;	author deraadt;	state Exp;
branches;
next	;

1.20.2.1
date	2000.03.24.09.09.31;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.05.14.22.40.00;	author niklas;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.07.04.10.53.58;	author niklas;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2002.03.28.14.57.36;	author niklas;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2003.03.28.00.41.28;	author niklas;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2003.05.13.19.36.15;	author ho;	state Exp;
branches;
next	;

1.36.4.1
date	2002.06.11.03.30.45;	author art;	state Exp;
branches;
next	1.36.4.2;

1.36.4.2
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.36.4.3;

1.36.4.3
date	2003.05.19.22.30.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.67
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@/*	$OpenBSD: if_enc.c,v 1.66 2017/01/20 00:51:56 mpi Exp $	*/

/*
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "enc.h"
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_var.h>
#include <net/if_enc.h>
#include <net/if_types.h>
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

struct ifnet			**enc_ifps;	/* rdomain-mapped enc ifs */
u_int				  enc_max_id;
struct ifnet			**enc_allifps;	/* unit-mapped enc ifs */
u_int				  enc_max_unit;
#define ENC_MAX_UNITS		  4096		/* XXX n per rdomain */

void	 encattach(int);

int	 enc_clone_create(struct if_clone *, int);
int	 enc_clone_destroy(struct ifnet *);
void	 enc_start(struct ifnet *);
int	 enc_output(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);
int	 enc_ioctl(struct ifnet *, u_long, caddr_t);

int	 enc_setif(struct ifnet *, u_int);
void	 enc_unsetif(struct ifnet *);

struct if_clone enc_cloner =
    IF_CLONE_INITIALIZER("enc", enc_clone_create, enc_clone_destroy);

void
encattach(int count)
{
	/* Create enc0 by default */
	(void)enc_clone_create(&enc_cloner, 0);

	if_clone_attach(&enc_cloner);
}

int
enc_clone_create(struct if_clone *ifc, int unit)
{
	struct enc_softc	*sc;
	struct ifnet		*ifp;
	struct ifnet		**new;
	size_t			 newlen;
	int			 error;

	if (unit > ENC_MAX_UNITS)
		return (EINVAL);

	if ((sc = malloc(sizeof(struct enc_softc),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOBUFS);

	sc->sc_unit = unit;

	ifp = &sc->sc_if;
	ifp->if_softc = sc;
	ifp->if_type = IFT_ENC;
	ifp->if_xflags = IFXF_CLONED;
	ifp->if_start = enc_start;
	ifp->if_output = enc_output;
	ifp->if_ioctl = enc_ioctl;
	ifp->if_hdrlen = ENC_HDRLEN;

	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d",
	    ifc->ifc_name, unit);

	if_attach(ifp);
	if (unit == 0)
		if_addgroup(ifp, ifc->ifc_name);
	/*
	 * enc(4) does not have a link-layer address but rtrequest()
	 * wants an ifa for every route entry.  So let's setup a fake
	 * and empty ifa of type AF_LINK for this purpose.
	 */
	if_alloc_sadl(ifp);
	sc->sc_ifa.ifa_ifp = ifp;
	sc->sc_ifa.ifa_addr = sdltosa(ifp->if_sadl);
	sc->sc_ifa.ifa_netmask = NULL;

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_ENC, ENC_HDRLEN);
#endif

	if ((error = enc_setif(ifp, 0)) != 0) {
		if_detach(ifp);
		free(sc, M_DEVBUF, 0);
		return (error);
	}

	if (unit == 0 || unit > enc_max_unit) {
		if ((new = mallocarray(unit + 1, sizeof(struct ifnet *),
		    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
			return (ENOBUFS);
		newlen = sizeof(struct ifnet *) * (unit + 1);

		if (enc_allifps != NULL) {
			memcpy(new, enc_allifps,
			    sizeof(struct ifnet *) * (enc_max_unit + 1));
			free(enc_allifps, M_DEVBUF, 0);
		}
		enc_allifps = new;
		enc_max_unit = unit;
	}
	enc_allifps[unit] = ifp;

	return (0);
}

int
enc_clone_destroy(struct ifnet *ifp)
{
	struct enc_softc	*sc = ifp->if_softc;
	int			 s;

	/* Protect users from removing enc0 */
	if (sc->sc_unit == 0)
		return (EPERM);

	s = splnet();
	enc_allifps[sc->sc_unit] = NULL;
	enc_unsetif(ifp);
	if_detach(ifp);
	free(sc, M_DEVBUF, 0);
	splx(s);

	return (0);
}

void
enc_start(struct ifnet *ifp)
{
	struct mbuf	*m;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
		m_freem(m);
	}
}

int
enc_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *sa,
    struct rtentry *rt)
{
	m_freem(m);	/* drop packet */
	return (EAFNOSUPPORT);
}

int
enc_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ifreq	*ifr = (struct ifreq *)data;
	int		 error;

	switch (cmd) {
	case SIOCSIFADDR:
	case SIOCSIFDSTADDR:
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP)
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
		break;
	case SIOCSIFRDOMAIN:
		if ((error = enc_setif(ifp, ifr->ifr_rdomainid)) != 0)
			return (error);
		/* FALLTHROUGH */
	default:
		return (ENOTTY);
	}

	return (0);
}

struct ifnet *
enc_getif(u_int id, u_int unit)
{
	struct ifnet	*ifp;

	/* Check if the caller wants to get a non-default enc interface */
	if (unit > 0) {
		if (unit > enc_max_unit)
			return (NULL);
		ifp = enc_allifps[unit];
		if (ifp == NULL || ifp->if_rdomain != id)
			return (NULL);
		return (ifp);
	}

	/* Otherwise return the default enc interface for this rdomain */
	if (enc_ifps == NULL)
		return (NULL);
	else if (id > RT_TABLEID_MAX)
		return (NULL);
	else if (id > enc_max_id)
		return (NULL);
	return (enc_ifps[id]);
}

struct ifaddr
*enc_getifa(u_int id, u_int unit)
{
	struct ifnet		*ifp;
	struct enc_softc	*sc;

	ifp = enc_getif(id, unit);
	if (ifp == NULL)
		return (NULL);

	sc = ifp->if_softc;
	return (&sc->sc_ifa);
}
int
enc_setif(struct ifnet *ifp, u_int id)
{
	struct ifnet	**new;
	size_t		 newlen;

	enc_unsetif(ifp);

	/*
	 * There can only be one default encif per rdomain -
	 * Don't overwrite the existing enc iface that is stored
	 * for this rdomain, so only the first enc interface that
	 * was added for this rdomain becomes the default.
	 */
	if (enc_getif(id, 0) != NULL)
		return (0);

	if (id > RT_TABLEID_MAX)
		return (EINVAL);

	if (id == 0 || id > enc_max_id) {
		if ((new = mallocarray(id + 1, sizeof(struct ifnet *),
		    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
			return (ENOBUFS);
		newlen = sizeof(struct ifnet *) * (id + 1);

		if (enc_ifps != NULL) {
			memcpy(new, enc_ifps,
			    sizeof(struct ifnet *) * (enc_max_id + 1));
			free(enc_ifps, M_DEVBUF, 0);
		}
		enc_ifps = new;
		enc_max_id = id;
	}

	enc_ifps[id] = ifp;

	/* Indicate that this interface is the rdomain default */
	ifp->if_link_state = LINK_STATE_UP;

	return (0);
}

void
enc_unsetif(struct ifnet *ifp)
{
	u_int			 id = ifp->if_rdomain, i;
	struct ifnet		*oifp, *nifp;

	if ((oifp = enc_getif(id, 0)) == NULL || oifp != ifp)
		return;

	/* Clear slot for this rdomain */
	enc_ifps[id] = NULL;
	ifp->if_link_state = LINK_STATE_UNKNOWN;

	/*
	 * Now find the next available encif to be the default interface
	 * for this rdomain.
	 */
	for (i = 0; i < (enc_max_unit + 1); i++) {
		nifp = enc_allifps[i];

		if (nifp == NULL || nifp == ifp || nifp->if_rdomain != id)
			continue;

		enc_ifps[id] = nifp;
		nifp->if_link_state = LINK_STATE_UP;
		break;
	}
}
@


1.66
log
@No need to handle SIOCAIFADDR in drivers, it's never passed down to
them.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.65 2016/09/04 21:46:36 krw Exp $	*/
d89 1
@


1.65
log
@Make enc_output() return EAFNOSUPPORT after dropping the packet,
instead of 0. Makes it consistent with other similar interfaces.

ok mpi@@ vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.64 2015/11/09 10:19:10 dlg Exp $	*/
a186 1
	case SIOCAIFADDR:
@


1.64
log
@use IFQ_DEQUEUE to pull of the send queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.63 2015/10/30 09:39:42 bluhm Exp $	*/
d177 1
a177 1
	return (0);
@


1.63
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.62 2015/10/22 17:48:34 mpi Exp $	*/
d165 1
a165 2
		IF_DROP(&ifp->if_snd);
		IF_DEQUEUE(&ifp->if_snd, m);
@


1.62
log
@Kill link_rtrequest(), introduce in 1990 to "fix" the result
of rt_getifa() when adding link level route from outside the
kernel.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.61 2015/10/22 15:37:47 bluhm Exp $	*/
d101 1
a101 1
	 * enc(4) does not have a link-layer address but rtrequest1()
@


1.61
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.60 2015/03/14 03:38:51 jsg Exp $	*/
a106 1
	sc->sc_ifa.ifa_rtrequest = link_rtrequest;
@


1.60
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.59 2014/12/13 21:05:33 doug Exp $	*/
d30 1
d108 1
a108 1
	sc->sc_ifa.ifa_addr = (struct sockaddr *)ifp->if_sadl;
@


1.59
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.58 2014/12/08 10:46:14 mpi Exp $	*/
a23 1
#include <sys/kernel.h>
@


1.58
log
@There's no good reason to keep into "struct ifnet" a pointer that's only
used by enc(4) devices to attach their routes.

ok sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.57 2014/12/05 15:50:04 mpi Exp $	*/
d122 3
a126 2
		if ((new = malloc(newlen, M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
			return (ENOBUFS);
d268 3
a272 2
		if ((new = malloc(newlen, M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
			return (ENOBUFS);
@


1.57
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.56 2014/09/08 06:24:13 jsg Exp $	*/
d102 2
a103 2
	 * wants an ifa for every route entry.  So let's allocate
	 * a fake and empty ifa of type AF_LINK for this purpose.
d106 4
d233 13
@


1.56
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.55 2014/07/12 18:44:22 tedu Exp $	*/
d31 1
@


1.55
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.54 2014/05/21 14:48:28 mpi Exp $	*/
a32 1
#include <net/route.h>
@


1.54
log
@Fix IPsec route addition broken since the removal of the link-layer
addresses from the per-ifp list.

While here document why enc(4) needs a link-layer address, or at
least something that seems to be one.

Found the hard way and fix tested by naddy@@, ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.53 2013/09/27 14:10:01 bluhm Exp $	*/
d113 1
a113 1
		free(sc, M_DEVBUF);
d125 1
a125 1
			free(enc_allifps, M_DEVBUF);
d149 1
a149 1
	free(sc, M_DEVBUF);
d257 1
a257 1
			free(enc_ifps, M_DEVBUF);
@


1.53
log
@The error return codes for the enc interface were inconsistent.
Always return the appropriate errno.
OK reyk@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.52 2010/07/03 04:44:51 guenther Exp $	*/
d100 5
@


1.52
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.51 2010/07/01 02:09:45 reyk Exp $	*/
d75 1
d82 1
a82 1
		return (ENOMEM);
d106 1
a106 1
	if (enc_setif(ifp, 0) != 0) {
d109 1
a109 1
		return (-1);
d116 1
a116 1
			return (-1);
d176 1
a176 1
	int		 error = 0;
d242 1
a242 1
		return (-1);
d248 1
a248 1
			return (-1);
@


1.51
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.50 2010/07/01 01:55:03 reyk Exp $	*/
d187 1
a187 1
	case SIOCSIFRTABLEID:
@


1.50
log
@We have to add enc0 to the "enc" interface group manually on boot.
Adopted from the loop lo0 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.49 2010/06/29 21:28:37 reyk Exp $	*/
a37 1
TAILQ_HEAD(__enchead, enc_softc) enc_list;	/* all enc interfaces */
d39 4
a42 1
u_int				 enc_max_id;
a61 2
	TAILQ_INIT(&enc_list);

d73 5
d111 15
a125 1
	TAILQ_INSERT_TAIL(&enc_list, sc, sc_entry);
d140 1
a140 1
	TAILQ_REMOVE(&enc_list, sc, sc_entry);
d199 1
a199 1
enc_getif(u_int id)
d201 13
d237 1
a237 1
	if (enc_getif(id) != NULL)
d268 2
a269 3
	u_int			 id = ifp->if_rdomain;
	struct ifnet		*oifp;
	struct enc_softc	*sc;
d271 1
a271 1
	if ((oifp = enc_getif(id)) == NULL || oifp != ifp)
d282 4
a285 2
	TAILQ_FOREACH(sc, &enc_list, sc_entry) {
		if (&sc->sc_if == ifp || sc->sc_if.if_rdomain != id)
d288 2
a289 2
		enc_ifps[id] = &sc->sc_if;
		sc->sc_if.if_link_state = LINK_STATE_UP;
@


1.49
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 2
@


1.48
log
@encif is a global variable and thus pre-zeroed, don't bother bzero()ing
it after the fact.

ok henning@@, claudio@@
@
text
@d1 2
a2 1
/*	$OpenBSD: if_enc.c,v 1.47 2007/12/20 02:53:02 brad Exp $	*/
d4 1
a4 16
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
 * Copyright (c) 2001, Angelos D. Keromytis.
d6 3
a8 8
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
d10 7
a16 5
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
d19 2
a20 3
/*
 * Encapsulation interface driver.
 */
d24 4
a28 2
#include <sys/socket.h>
#include <sys/ioctl.h>
d31 1
d34 1
d36 1
d38 15
a52 1
#include <net/if_enc.h>
d54 2
a55 4
#ifdef	INET
#include <netinet/in.h>
#include <netinet/in_var.h>
#endif
d57 4
a60 6
#ifdef INET6
#ifndef INET
#include <netinet/in.h>
#endif
#include <netinet6/nd6.h>
#endif /* INET6 */
d62 2
a63 2
#include "bpfilter.h"
#include "enc.h"
d65 2
a66 5
#ifdef ENCDEBUG
#define DPRINTF(x)    do { if (encdebug) printf x ; } while (0)
#else
#define DPRINTF(x)
#endif
d68 5
a72 1
struct enc_softc encif[NENC];
d74 13
a86 5
void	encattach(int);
int	encoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);
int	encioctl(struct ifnet *, u_long, caddr_t);
void	encstart(struct ifnet *);
d88 2
a89 5
void
encattach(int nenc)
{
	struct ifnet *ifp;
	int i;
d91 2
a92 13
	for (i = 0; i < NENC; i++) {
		ifp = &encif[i].sc_if;
		snprintf(ifp->if_xname, sizeof ifp->if_xname, "enc%d", i);
		ifp->if_softc = &encif[i];
		ifp->if_mtu = ENCMTU;
		ifp->if_ioctl = encioctl;
		ifp->if_output = encoutput;
		ifp->if_start = encstart;
		ifp->if_type = IFT_ENC;
		ifp->if_snd.ifq_maxlen = ifqmaxlen;
		ifp->if_hdrlen = ENC_HDRLEN;
		if_attach(ifp);
		if_alloc_sadl(ifp);
d95 1
a95 1
		bpfattach(&encif[i].sc_if.if_bpf, ifp, DLT_ENC, ENC_HDRLEN);
d97 5
d103 23
a127 3
/*
 * Start output on the enc interface.
 */
d129 1
a129 1
encstart(struct ifnet *ifp)
d131 1
a131 2
	struct mbuf *m;
	int s;
a133 1
		s = splnet();
a135 2
		splx(s);

d137 2
a138 3
			return;
		else
			m_freem(m);
d143 1
a143 1
encoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
d146 1
a146 1
	m_freem(m);
a149 1
/* ARGSUSED */
d151 1
a151 1
encioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
d153 3
d157 1
a158 1
	case SIOCAIFADDR:
d166 4
d174 83
a256 1
	return 0;
@


1.47
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ jason@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.46 2007/05/26 17:13:30 jason Exp $	*/
a86 2

	bzero(encif, sizeof(encif));
@


1.46
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.45 2006/12/12 15:08:36 reyk Exp $	*/
d155 1
a155 1
		return (EINVAL);
@


1.45
log
@ansify the enc code

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.44 2006/06/28 12:02:26 claudio Exp $	*/
a80 2

extern int ifqmaxlen;
@


1.44
log
@Kill unused encrtrequest(). OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.43 2006/03/04 22:40:15 brad Exp $	*/
d78 1
a78 1
	    	       struct rtentry *);
d87 2
a88 2
    struct ifnet *ifp;
    int i;
d90 1
a90 1
    bzero(encif, sizeof(encif));
d92 13
a104 14
    for (i = 0; i < NENC; i++)
    {
	ifp = &encif[i].sc_if;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "enc%d", i);
	ifp->if_softc = &encif[i];
	ifp->if_mtu = ENCMTU;
	ifp->if_ioctl = encioctl;
	ifp->if_output = encoutput;
	ifp->if_start = encstart;
	ifp->if_type = IFT_ENC;
	ifp->if_snd.ifq_maxlen = ifqmaxlen;
	ifp->if_hdrlen = ENC_HDRLEN;
	if_attach(ifp);
	if_alloc_sadl(ifp);
d107 1
a107 1
	bpfattach(&encif[i].sc_if.if_bpf, ifp, DLT_ENC, ENC_HDRLEN);
d109 1
a109 1
    }
d116 1
a116 2
encstart(ifp)
struct ifnet *ifp;
d118 2
a119 2
    struct mbuf *m;
    int s;
d121 11
a131 12
    for (;;)
    {
        s = splnet();
	IF_DROP(&ifp->if_snd);
        IF_DEQUEUE(&ifp->if_snd, m);
        splx(s);

        if (m == NULL)
          return;
        else
          m_freem(m);
    }
d135 2
a136 5
encoutput(ifp, m, dst, rt)
struct ifnet *ifp;
register struct mbuf *m;
struct sockaddr *dst;
register struct rtentry *rt;
d138 2
a139 2
    m_freem(m);
    return (0);
d144 1
a144 4
encioctl(ifp, cmd, data)
register struct ifnet *ifp;
u_long cmd;
caddr_t data;
d146 1
a146 2
    switch (cmd) 
    {
d151 5
a155 6
	    if (ifp->if_flags & IFF_UP)
	      ifp->if_flags |= IFF_RUNNING;
	    else
	      ifp->if_flags &= ~IFF_RUNNING;
	    break;

d157 2
a158 2
	    return (EINVAL);
    }
d160 1
a160 1
    return 0;
@


1.43
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.42 2005/06/08 06:35:04 henning Exp $	*/
a79 1
void	encrtrequest(int, struct rtentry *, struct sockaddr *);
a145 11
}

/* ARGSUSED */
void
encrtrequest(cmd, rt, sa)
int cmd;
struct rtentry *rt;
struct sockaddr *sa;
{
    if (rt)
      rt->rt_rmx.rmx_mtu = ENCMTU;
@


1.42
log
@no more netns handling for the various tunnel devices and loopback
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.41 2004/09/15 17:46:44 grange Exp $	*/
d126 1
a126 1
        s = splimp();
@


1.41
log
@Kill more netiso ghosts.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.40 2003/05/03 21:15:11 deraadt Exp $	*/
a63 4

#ifdef NS
extern struct ifqueue nsintrq;
#endif
@


1.40
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.39 2002/06/30 13:04:36 itojun Exp $	*/
a63 4

#ifdef ISO
extern struct ifqueue clnlintrq;
#endif
@


1.39
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.38 2002/05/29 07:54:58 itojun Exp $	*/
d104 1
a104 1
	sprintf(ifp->if_xname, "enc%d", i);
@


1.38
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.37 2002/03/14 01:27:09 millert Exp $	*/
d114 1
@


1.37
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.36 2001/06/27 02:00:30 provos Exp $	*/
a116 3
#endif
#ifdef INET6
	nd6_ifattach(ifp);
@


1.36
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.35 2001/06/25 05:14:00 angelos Exp $	*/
d84 6
a89 6
void	encattach __P((int));
int	encoutput __P((struct ifnet *, struct mbuf *, struct sockaddr *,
	    	       struct rtentry *));
int	encioctl __P((struct ifnet *, u_long, caddr_t));
void	encrtrequest __P((int, struct rtentry *, struct sockaddr *));
void	encstart __P((struct ifnet *));
@


1.36.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.36 2001/06/27 02:00:30 provos Exp $	*/
d84 6
a89 6
void	encattach(int);
int	encoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
	    	       struct rtentry *);
int	encioctl(struct ifnet *, u_long, caddr_t);
void	encrtrequest(int, struct rtentry *, struct sockaddr *);
void	encstart(struct ifnet *);
d117 3
@


1.36.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.36.4.1 2002/06/11 03:30:45 art Exp $	*/
a113 1
	if_alloc_sadl(ifp);
@


1.36.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 1
a104 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "enc%d", i);
@


1.35
log
@Copyright update.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.34 2001/06/08 04:02:19 angelos Exp $	*/
d156 1
a156 1
    return 0;
d190 1
a190 1
	    return EINVAL;
@


1.34
log
@One more include cleanup, just to piss off Aaron :-)
@
text
@d1 1
a1 2
/*	$OpenBSD: if_enc.c,v 1.33 2001/04/06 04:42:07 csapuntz Exp $	*/

d18 3
a20 2
 *	
 * Permission to use, copy, and modify this software without fee
@


1.33
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.32 2000/12/30 22:56:23 angelos Exp $	*/
a41 1
#include <sys/kernel.h>
a43 1
#include <sys/errno.h>
a44 3
#include <sys/proc.h>

#include <machine/cpu.h>
a47 1
#include <net/netisr.h>
a50 1
#include <netinet/ip_ipsp.h>
a54 1
#include <netinet/in_systm.h>
a55 2
#include <netinet/ip_var.h>
#include <netinet/ip.h>
a61 2
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
@


1.32
log
@For bridged IPsec, use the gif* interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.31 2000/06/20 04:17:31 itojun Exp $	*/
a91 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.31
log
@initialize mtu/hlim for enc interface at encattach().

backgronud: inbound ipsec packet will have enc* as m->m_pkthdr.rcvif.
when we try to reflect the packet back in the kernel (like icmp6 echo),
we'd generate packet toward enc* interface.  icmp6_reflect() will take
hoplimit value from nd_ifinfo[enc*], which was not initialized by the old code.

XXX the change to m->m_pkthdr.rcvif violates IPv6 scoped routing.
we will need to disable it, for at least IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.30 2000/04/18 06:41:23 angelos Exp $	*/
a149 1
#ifndef IPSEC
a161 139
#else /* IPSEC */
    struct enc_softc *enc = ifp->if_softc;
    int err = 0, protoflag;
    struct mbuf *mp;
    struct tdb *tdb;

    /* If the interface is not setup, flush the queue */
    if ((enc->sc_spi == 0) && (enc->sc_sproto == 0) &&
	(enc->sc_dst.sa.sa_family != AF_INET) &&
	(enc->sc_dst.sa.sa_family != AF_INET6))
    {
	DPRINTF(("%s: not initialized with SA\n", ifp->if_xname));

	for (;;)
	{
	    s = splimp();
            IF_DROP(&ifp->if_snd);
	    IF_DEQUEUE(&ifp->if_snd, m);
	    splx(s);
	    if (m == NULL)
	      return;
	    else
	      m_freem(m);
	}

	/* Unreachable */
    }

    /* Find what type of processing we need to do */
    tdb = gettdb(enc->sc_spi, &(enc->sc_dst), enc->sc_sproto);
    if (tdb == NULL)
    {
	DPRINTF(("%s: SA non-existant\n", ifp->if_xname));

	/* Flush the queue */
	for (;;)
	{
	    s = splimp();
            IF_DROP(&ifp->if_snd);
	    IF_DEQUEUE(&ifp->if_snd, m);
	    splx(s);
	    if (m == NULL)
	      return;
	    else
	      m_freem(m);
	}
    }

    /* See if we need to notify a key mgmt. daemon to setup SAs */
    if (ntohl(enc->sc_spi) == SPI_LOCAL_USE)
    {
#ifdef notyet
	/* XXX Currently unsupported */ 
	if (tdb->tdb_satype != SADB_X_SATYPE_BYPASS)
	  pfkeyv2_acquire(tdb, 0); /* No point checking for errors */
#endif

	/* Flush the queue */
	for (;;)
	{
	    s = splimp();
            IF_DROP(&ifp->if_snd);
	    IF_DEQUEUE(&ifp->if_snd, m);
	    splx(s);
	    if (m == NULL)
	      return;
	    else
	      m_freem(m);
	}

	/* Unreachable */
    }

    /* IPsec-process all packets in the queue */
    for (;;)
    {
	/* Get a packet from the queue */
	s = splimp();
	IF_DEQUEUE(&ifp->if_snd, m);
	splx(s);

	if (m == NULL) /* Empty queue */
	  return;
 
	/* Sanity check */
	if ((m->m_flags & M_PKTHDR) == 0)
	{
	    m_freem(m);
	    continue;
	}

	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;

	m->m_pkthdr.rcvif = ifp;
	mp = NULL;

	/* Encapsulate in etherip or ip-in-ip, depending on interface flag */
	if (ifp->if_flags & IFF_LINK0)
	  err = ipip_output(m, tdb, &mp, 0, 0); /* Last 2 args not used */
	else
	  err = etherip_output(m, tdb, &mp, 0, 0); /* Last 2 args not used */
	if ((mp == NULL) || err)
	{
	    /* Just skip this frame */
            IF_DROP(&ifp->if_snd);
	    if (mp)
	      m_freem(mp);
	    continue;
	}
	else
	{
	    m = mp;
	    mp = NULL;
	}

#ifdef INET
	/* Fix header checksum for IPv4 */
        if (tdb->tdb_dst.sa.sa_family == AF_INET)
	{
	    struct ip *ip;

	    ip = mtod(m, struct ip *);
	    ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
        }
#endif

	protoflag = tdb->tdb_dst.sa.sa_family;

	/* IPsec packet processing -- skip encapsulation */
	ipsp_process_packet(m, tdb, protoflag, 1);

	/*
	 * XXX
	 * Should find a way to avoid bridging/routing-loops,
	 * perhaps use some mbuf flag ?
	 */
    }
#endif /* IPSEC */
d171 2
a172 29
    int s;

    if ((m->m_flags & M_PKTHDR) == 0)
      panic("encoutput(): no HDR");

    ifp->if_lastchange = time;
    m->m_pkthdr.rcvif = ifp;
    
    if (rt && rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE))
    {
	m_freem(m);
	return (rt->rt_flags & RTF_BLACKHOLE ? 0 :
		rt->rt_flags & RTF_HOST ? EHOSTUNREACH : ENETUNREACH);
    }

    s = splimp();
    if (IF_QFULL(&ifp->if_snd)) {
	ifp->if_oerrors++;
	m_freem(m);
	splx(s);
	return 0;
    }

    IF_ENQUEUE(&ifp->if_snd, m);
    splx(s);

    (ifp->if_start)(ifp);

    return (0);
a192 14
#ifdef IPSEC
    struct enc_softc *enc = (struct enc_softc *) ifp->if_softc;
    struct ifsa *ifsa = (struct ifsa *) data;
    struct proc *prc = curproc;             /* XXX */
    struct tdb *tdb;
    int s, error = 0;

    /*
     * enc0 does not allow binding of SAs, as it's used for all non-bound
     * SAs.
     */
    if (ifp->if_softc == &encif[0])
	return EOPNOTSUPP;

a204 144
	case SIOCGENCSA:
	    ifsa->sa_spi = enc->sc_spi;
	    ifsa->sa_proto = enc->sc_sproto;
	    bcopy(&enc->sc_dst, &ifsa->sa_dst, enc->sc_dst.sa.sa_len);
	    break;

	case SIOCSENCCLEARSA:
	    /* Check for superuser */
	    if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
	      break;

	    if (ifsa->sa_proto == 0)
	    {
		/* Clear SA if requested */
		if (enc->sc_sproto != 0)
		{
		    s = spltdb();
		    tdb = gettdb(enc->sc_spi, &enc->sc_dst, enc->sc_sproto);
		    if (tdb != NULL)
		      tdb->tdb_interface = 0;
		    splx(s);
		}
		
		bzero(&enc->sc_dst, sizeof(union sockaddr_union));
		enc->sc_spi = 0;
		enc->sc_sproto = 0;
		break;
	    }

	    s = spltdb();
	    tdb = gettdb(ifsa->sa_spi, &ifsa->sa_dst, ifsa->sa_proto);
	    if (tdb == NULL)
	    {
		splx(s);
		error = ENOENT;
		break;
	    }

	    tdb->tdb_interface = 0;
	    splx(s);
	    break;

	case SIOCSENCSRCSA:
	    /* Check for superuser */
	    if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
	      break;

	    if (ifsa->sa_proto == 0)
	    {
		error = ENOENT;
		break;
	    }

	    s = spltdb();
	    tdb = gettdb(ifsa->sa_spi, &ifsa->sa_dst, ifsa->sa_proto);
	    if (tdb == NULL)
	    {
		splx(s);
		error = ENOENT;
		break;
	    }

	    /* Is it already bound ? */
	    if (tdb->tdb_interface)
	    {
		splx(s);
		error = EEXIST;
		break;
	    }

	    tdb->tdb_interface = (caddr_t) ifp;
	    splx(s);
	    break;

	case SIOCSENCDSTSA:
	    /* Check for superuser */
	    if ((error = suser(prc->p_ucred, &prc->p_acflag)) != 0)
	      break;

	    /* Check for pre-existing TDB */
	    if (enc->sc_sproto != 0)
	    {
		error = EEXIST;
		break;
	    }

	    s = spltdb();

	    if (ifsa->sa_proto != 0)
	    {
		tdb = gettdb(ifsa->sa_spi, &ifsa->sa_dst, ifsa->sa_proto);
		if (tdb == NULL)
		{
		    splx(s);
		    error = ENOENT;
		    break;
		}
	    }
	    else
	    {
		/* Clear SA if requested */
		if (enc->sc_sproto != 0)
		{
		    tdb = gettdb(enc->sc_spi, &enc->sc_dst, enc->sc_sproto);
		    if (tdb != NULL)
		      tdb->tdb_interface = 0;
		}

		bzero(&enc->sc_dst, sizeof(enc->sc_dst));
		enc->sc_spi = 0;
		enc->sc_sproto = 0;

		splx(s);
		break;
	    }

#ifdef INET
	    if ((ifsa->sa_dst.sa.sa_family == AF_INET) &&
		(ifsa->sa_dst.sa.sa_len != sizeof(struct sockaddr_in)))
	    {
		splx(s);
	    	error = EINVAL;
		break;
	    }
#endif /* INET */

#ifdef INET6
	    if ((ifsa->sa_dst.sa.sa_family == AF_INET6) &&
		(ifsa->sa_dst.sa.sa_len != sizeof(struct sockaddr_in6)))
	    {
		splx(s);
		error = EINVAL;
		break;
	    }
#endif /* INET6 */

	    bcopy(&ifsa->sa_dst, &enc->sc_dst, ifsa->sa_dst.sa.sa_len);
	    enc->sc_spi = ifsa->sa_spi;
	    enc->sc_sproto = ifsa->sa_proto;
	    tdb->tdb_interface = (caddr_t) ifp;

	    splx(s);
	    break;

d206 1
a206 2
	    error = EINVAL;
	    break;
d209 1
a209 4
    return (error);
#else /* IPSEC */
    return EOPNOTSUPP;
#endif /* IPSEC */
@


1.30
log
@Stats for bridge output too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.29 2000/04/18 06:35:02 angelos Exp $	*/
d74 1
d133 3
@


1.29
log
@Sanity check on dequeued mbufs, also keep track of correct interface
for statistics purposes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.28 2000/04/12 18:05:47 angelos Exp $	*/
d250 3
a328 3

    ifp->if_opackets++;
    ifp->if_obytes += m->m_pkthdr.len;
@


1.28
log
@Fix checksum for outgoing etherip/ipip packets from enc interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.27 2000/04/10 07:34:53 angelos Exp $	*/
d242 7
d250 1
@


1.27
log
@Minor oops in sanity logic, IFF_RUNNING is set/unset with IFF_UP,
be paranoid with uninitialized variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.26 2000/04/10 04:39:41 angelos Exp $	*/
d263 11
@


1.26
log
@output routine enqueues and calls start, rather than requeueing for input.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.25 2000/04/10 02:34:07 angelos Exp $	*/
d167 2
a168 2
	((enc->sc_dst.sa.sa_family == AF_INET) ||
	 (enc->sc_dst.sa.sa_family == AF_INET6)))
d243 2
d357 4
@


1.25
log
@Typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.24 2000/04/10 02:33:32 angelos Exp $	*/
a209 5
	/*
	 * XXX Can't do this for now, as there's no way for
	 * XXX key mgmt. to specify link-layer properties
	 * XXX (e.g., encrypt everything on this interface)
	 */ 
d211 1
a275 3
/*
 * Shamelessly stolen from looutput()
 */
d283 1
a283 2
    register struct ifqueue *ifq = 0;
    int s, isr;
a297 34
    ifp->if_opackets++;
    ifp->if_obytes += m->m_pkthdr.len;

    switch (dst->sa_family)
    {
#ifdef INET
	case AF_INET:
	    ifq = &ipintrq;
	    isr = NETISR_IP;
	    break;
#endif
#ifdef INET6
	case AF_INET6:
	    ifq = &ip6intrq;
	    isr = NETISR_IPV6;
	    break;
#endif
#ifdef NS
	case AF_NS:
	    ifq = &nsintrq;
	    isr = NETISR_NS;
	    break;
#endif
#ifdef ISO
	case AF_ISO:
	    ifq = &clnlintrq;
	    isr = NETISR_ISO;
	    break;
#endif
	default:
	    m_freem(m);
	    return (EAFNOSUPPORT);
    }

d299 2
a300 3
    if (IF_QFULL(ifq))
    {
	IF_DROP(ifq);
d303 1
a303 1
	return (ENOBUFS);
d305 5
a309 7
	
    IF_ENQUEUE(ifq, m);
    schednetisr(isr);

    /* Statistics */
    ifp->if_ipackets++;
    ifp->if_ibytes += m->m_pkthdr.len;
d311 3
d354 1
@


1.24
log
@SIOCAIFADDR.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.23 2000/04/10 01:56:49 angelos Exp $	*/
d394 1
a394 1
	case SIOCAIFADDR
@


1.23
log
@Allow setting address.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.22 2000/04/08 16:55:58 angelos Exp $	*/
d394 1
@


1.22
log
@If IFF_LINK0 is set, do IP-in-IP instead of Ethernet-in-IP. This will
be used to implement overlay networks and more flexible road-warrior
support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.21 2000/03/17 10:25:21 angelos Exp $	*/
d382 1
a382 1
    int s, error;
d394 2
a395 1
	    return EOPNOTSUPP;
@


1.21
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.20 2000/02/07 06:09:08 itojun Exp $	*/
d247 5
a251 2
	/* First, we encapsulate in etherip */
	err = etherip_output(m, tdb, &mp, 0, 0); /* Last 2 args not used */
d271 5
a275 1
	/* XXX Should find a way to avoid bridging-loops, some mbuf flag ? */
@


1.20
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.19 2000/01/25 17:18:59 espie Exp $	*/
d266 1
a266 26
	err = ipsp_process_packet(m, &mp, tdb, &protoflag, 1);
	if ((mp == NULL) || err)
	{
            IF_DROP(&ifp->if_snd);
	    if (mp)
	      m_freem(mp);
	    continue;
	}
	else
	{
	    m = mp;
	    mp = NULL;
	}

#ifdef INET
	/* Send the packet on its way, no point checking for errors here */
	if (protoflag == AF_INET)
	  ip_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT, NULL, NULL);
#endif /* INET */

#ifdef INET6
	/* Send the packet on its way, no point checking for errors here */
	if (protoflag == AF_INET6)
	  ip6_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT,
		     NULL, NULL);
#endif /* INET6 */
@


1.20.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d266 26
a291 1
	ipsp_process_packet(m, tdb, protoflag, 1);
@


1.20.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.33 2001/04/06 04:42:07 csapuntz Exp $	*/
a73 1
#include <netinet6/nd6.h>
d93 4
a132 3
#ifdef INET6
	nd6_ifattach(ifp);
#endif
d146 1
d159 112
d273 3
d283 67
a349 2
    m_freem(m);
    return 0;
d370 14
d387 100
a486 5
	case SIOCAIFADDR:
	case SIOCSIFDSTADDR:
	case SIOCSIFFLAGS:
	    if (ifp->if_flags & IFF_UP)
	      ifp->if_flags |= IFF_RUNNING;
d488 43
a530 1
	      ifp->if_flags &= ~IFF_RUNNING;
d534 2
a535 1
	    return EINVAL;
d538 4
a541 1
    return 0;
@


1.20.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d19 2
a20 3
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
d42 1
d45 1
d47 3
d53 1
d57 1
d62 1
d64 2
d72 2
d168 1
a168 1
    return (0);
d202 1
a202 1
	    return (EINVAL);
@


1.20.2.4
log
@Merge in -current from roughly a week ago
@
text
@d84 6
a89 6
void	encattach(int);
int	encoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
	    	       struct rtentry *);
int	encioctl(struct ifnet *, u_long, caddr_t);
void	encrtrequest(int, struct rtentry *, struct sockaddr *);
void	encstart(struct ifnet *);
@


1.20.2.5
log
@Sync the SMP branch with 3.3
@
text
@a113 1
	if_alloc_sadl(ifp);
d117 3
@


1.20.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.20.2.5 2003/03/28 00:41:28 niklas Exp $	*/
d104 1
a104 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "enc%d", i);
@


1.19
log
@Ok, so setsoftnet is md.

Well, on the amiga, setsoftnet *REQUIRES* machine/cpu.h to work...
and no include mentioned in those files pulls machine/cpu.h...

Nit-fix: / * INET6 */ -> /* INET6 */
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.18 2000/01/15 19:38:09 angelos Exp $	*/
d69 4
a72 2
#include <netinet6/in6.h>
#include <netinet6/ip6.h>
@


1.18
log
@Can't bind SAs to enc0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.17 2000/01/07 20:14:51 angelos Exp $	*/
d48 2
@


1.17
log
@Add missing IF_DROPs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.16 2000/01/02 09:22:58 angelos Exp $	*/
d397 7
@


1.16
log
@Properly handle non-IPSEC case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.15 1999/12/27 04:35:09 angelos Exp $	*/
d146 1
d171 1
d193 1
d220 1
d248 1
d265 1
@


1.15
log
@Add SRCSA and CLEARSA ioctls.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.14 1999/12/27 03:06:40 angelos Exp $	*/
d139 16
d156 2
a157 2
    int s, err = 0, protoflag;
    struct mbuf *m, *mp;
d285 1
d385 1
d394 3
d547 3
@


1.14
log
@Implement ioctls for binding SAs to enc interfaces (to be used with
the bridge).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.13 1999/11/02 00:15:56 angelos Exp $	*/
d382 1
a382 1
	case SIOCSENCSA:
d387 18
a404 1
	    /* Check for valid TDB */
d406 7
d414 42
a455 1
	    /* Clear interface pointer in pre-existing TDB */
d458 2
a459 3
		tdb = gettdb(enc->sc_spi, &enc->sc_dst, enc->sc_sproto);
		if (tdb)
		  tdb->tdb_interface = NULL;
d462 2
d475 8
a482 1
	      tdb = NULL;
d484 1
a484 4
	    /* Clear SA if requested */
	    if ((ifsa->sa_spi == 0) && (ifsa->sa_proto == 0))
	    {
		bzero(&enc->sc_dst, sizeof(union sockaddr_union));
a488 7
		break;
	    }

	    if (tdb == NULL)
	    {
		splx(s);
		error = ENOENT;
@


1.13
log
@Fix *stupid* typo/error that was causing the panics in post 2.6, found
by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.12 1999/10/29 05:22:41 angelos Exp $	*/
d47 1
a47 2
#include <sys/time.h>
#include <machine/cpu.h>
d62 1
d66 6
d83 10
d112 2
a113 1
    for (i = 0; i < NENC; i++) {
d139 130
a268 1
    /* XXX Code needed */
d290 2
a291 1
    if (rt && rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE)) {
d300 2
a301 1
    switch (dst->sa_family) {
d308 6
d332 2
a333 1
    if (IF_QFULL(ifq)) {
d368 60
a427 2
    register struct ifaddr *ifa;
    register int error = 0;
d429 26
a454 7
    switch (cmd) {
	case SIOCSIFADDR:
	    /*
	     * Everything else is done at a higher level.
	     */
	    ifp->if_flags |= IFF_UP;
	    ifa = (struct ifaddr *) data;
d461 1
@


1.12
log
@Use enc_softc instead of ifnet for encif.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.11 1999/07/05 20:17:05 deraadt Exp $	*/
d94 1
a94 1
    bzero(encif, NENC * sizeof(encif));
@


1.11
log
@remove bogus entry from if_enc address list; and rename enc_softc to encif
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.10 1999/05/16 21:35:54 niklas Exp $	*/
d55 2
d75 1
d77 1
a77 1
struct ifnet encif;
d84 3
d91 2
a92 1
	bzero(&encif, sizeof(encif));
d94 1
a94 2
	/* We only need one interface anyway under the new mode of operation */
	encif.if_index = 0;
d96 12
a107 11
	encif.if_softc = &encif;
	sprintf(encif.if_xname, "enc0");
	encif.if_list.tqe_next = NULL;
	encif.if_mtu = ENCMTU;
	encif.if_flags = 0;
	encif.if_type = IFT_ENC;
	encif.if_ioctl = encioctl;
	encif.if_output = encoutput;
	encif.if_hdrlen = ENC_HDRLEN;
	encif.if_addrlen = 0;
	if_attach(&encif);
d110 1
a110 1
	bpfattach(&encif.if_bpf, &encif, DLT_ENC, ENC_HDRLEN);
d112 11
d135 2
a136 2
	register struct ifqueue *ifq = 0;
	int s, isr;
d138 2
a139 2
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("encoutput(): no HDR");
d141 2
a142 2
	ifp->if_lastchange = time;
	m->m_pkthdr.rcvif = ifp;
d144 5
a148 5
	if (rt && rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE)) {
		m_freem(m);
		return (rt->rt_flags & RTF_BLACKHOLE ? 0 :
		    rt->rt_flags & RTF_HOST ? EHOSTUNREACH : ENETUNREACH);
	}
d150 2
a151 2
	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;
d153 1
a153 1
	switch (dst->sa_family) {
d156 3
a158 3
		ifq = &ipintrq;
		isr = NETISR_IP;
		break;
d162 3
a164 3
		ifq = &nsintrq;
		isr = NETISR_NS;
		break;
d168 3
a170 3
		ifq = &clnlintrq;
		isr = NETISR_ISO;
		break;
d173 11
a183 11
		m_freem(m);
		return (EAFNOSUPPORT);
	}
    
	s = splimp();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
		splx(s);
		return (ENOBUFS);
	}
d185 2
a186 2
	IF_ENQUEUE(ifq, m);
	schednetisr(isr);
d188 5
a192 5
	/* Statistics */
	ifp->if_ipackets++;
	ifp->if_ibytes += m->m_pkthdr.len;
	splx(s);
	return (0);
d198 3
a200 3
	int cmd;
	struct rtentry *rt;
	struct sockaddr *sa;
d202 2
a203 2
	if (rt)
		rt->rt_rmx.rmx_mtu = ENCMTU;
d209 3
a211 3
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d213 2
a214 2
	register struct ifaddr *ifa;
	register int error = 0;
d216 1
a216 1
	switch (cmd) {
d218 6
a223 6
		/*
		 * Everything else is done at a higher level.
		 */
		ifp->if_flags |= IFF_UP;
		ifa = (struct ifaddr *) data;
		break;
d226 4
a229 4
		error = EINVAL;
		break;
	}
	return (error);
@


1.10
log
@The enc interface should not be IFF_LOOPBACK, as AH and ESP uses that
as receiving interface for filtering
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.9 1998/06/28 18:49:40 deraadt Exp $	*/
d74 1
a74 1
struct ifnet enc_softc;
d85 1
a85 3
	struct ifaddr *ifa;

	bzero(&enc_softc, sizeof(struct ifnet));
d88 1
a88 1
	enc_softc.if_index = 0;
d90 11
a100 10
	sprintf(enc_softc.if_xname, "enc0");
	enc_softc.if_list.tqe_next = NULL;
	enc_softc.if_mtu = ENCMTU;
	enc_softc.if_flags = 0;
	enc_softc.if_type = IFT_ENC;
	enc_softc.if_ioctl = encioctl;
	enc_softc.if_output = encoutput;
	enc_softc.if_hdrlen = ENC_HDRLEN;
	enc_softc.if_addrlen = 0;
	if_attach(&enc_softc);
d103 1
a103 1
	bpfattach(&enc_softc.if_bpf, &enc_softc, DLT_ENC, ENC_HDRLEN);
a104 8

	/* Just a bogus entry */
	ifa = (struct ifaddr *) malloc(sizeof(struct ifaddr) + 
	    sizeof(struct sockaddr), M_IFADDR, M_WAITOK);
	bzero(ifa, sizeof(struct ifaddr) + sizeof(struct sockaddr));
	ifa->ifa_addr = ifa->ifa_dstaddr = (struct sockaddr *) (ifa + 1);
	ifa->ifa_ifp = &enc_softc;
	TAILQ_INSERT_HEAD(&(enc_softc.if_addrlist), ifa, ifa_list);
@


1.9
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.8 1998/06/10 23:57:10 provos Exp $	*/
d95 1
a95 1
	enc_softc.if_flags = IFF_LOOPBACK;
@


1.8
log
@make the packets which were successfully processed by IPSec available to
bpf via the enc0 interface, using linktype DLT_ENC.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.7 1998/05/18 21:10:19 provos Exp $	*/
d85 1
a85 1
    struct ifaddr *ifa;
d87 1
a87 1
    bzero(&enc_softc, sizeof(struct ifnet));
d89 2
a90 2
    /* We only need one interface anyway under the new mode of operation */
    enc_softc.if_index = 0;
d92 10
a101 12
    sprintf(enc_softc.if_xname, "enc0");

    enc_softc.if_list.tqe_next = NULL;
    enc_softc.if_mtu = ENCMTU;
    enc_softc.if_flags = IFF_LOOPBACK;
    enc_softc.if_type = IFT_ENC;
    enc_softc.if_ioctl = encioctl;
    enc_softc.if_output = encoutput;
    enc_softc.if_hdrlen = ENC_HDRLEN;
    enc_softc.if_addrlen = 0;

    if_attach(&enc_softc);
d104 1
a104 1
    bpfattach(&(enc_softc.if_bpf), &enc_softc, DLT_ENC, ENC_HDRLEN);
d107 7
a113 7
    /* Just a bogus entry */
    ifa = (struct ifaddr *) malloc(sizeof(struct ifaddr) + 
			           sizeof(struct sockaddr), M_IFADDR, M_WAITOK);
    bzero(ifa, sizeof(struct ifaddr) + sizeof(struct sockaddr));
    ifa->ifa_addr = ifa->ifa_dstaddr = (struct sockaddr *) (ifa + 1);
    ifa->ifa_ifp = &enc_softc;
    TAILQ_INSERT_HEAD(&(enc_softc.if_addrlist), ifa, ifa_list);
d126 2
a127 5
    register struct ifqueue *ifq = 0;
    int s, isr;

    if ((m->m_flags & M_PKTHDR) == 0)
      panic("encoutput(): no HDR");
d129 2
a130 1
    ifp->if_lastchange = time;
d132 2
a133 1
    m->m_pkthdr.rcvif = ifp;
d135 5
a139 6
    if (rt && rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE)) 
    {
	m_freem(m);
	return (rt->rt_flags & RTF_BLACKHOLE ? 0 :
		rt->rt_flags & RTF_HOST ? EHOSTUNREACH : ENETUNREACH);
    }
d141 2
a142 2
    ifp->if_opackets++;
    ifp->if_obytes += m->m_pkthdr.len;
d144 1
a144 2
    switch (dst->sa_family) 
    {
d147 3
a149 3
	    ifq = &ipintrq;
	    isr = NETISR_IP;
	    break;
d153 3
a155 3
	    ifq = &nsintrq;
	    isr = NETISR_NS;
	    break;
d159 2
a160 2
	    ifq = &clnlintrq;
	    isr = NETISR_ISO;
d164 3
a166 3
	    m_freem(m);
	    return (EAFNOSUPPORT);
    }
d168 10
a177 1
    s = splimp();
d179 3
a181 4
    if (IF_QFULL(ifq)) 
    {
	IF_DROP(ifq);
	m_freem(m);
d183 1
a183 13
	return (ENOBUFS);
    }
	
    IF_ENQUEUE(ifq, m);
    schednetisr(isr);

    /* Statistics */
    ifp->if_ipackets++;
    ifp->if_ibytes += m->m_pkthdr.len;

    splx(s);

    return (0);
d189 3
a191 3
int cmd;
struct rtentry *rt;
struct sockaddr *sa;
d193 2
a194 2
    if (rt)
      rt->rt_rmx.rmx_mtu = ENCMTU;
a196 6

/*
 * Process an ioctl request.
 * Also shamelessly stolen from loioctl()
 */

d200 3
a202 3
register struct ifnet *ifp;
u_long cmd;
caddr_t data;
d204 2
a205 2
    register struct ifaddr *ifa;
    register int error = 0;
d207 1
a207 2
    switch (cmd)
    {
d209 6
a214 8
	    /*
	     * Everything else is done at a higher level.
	     */

	    ifp->if_flags |= IFF_UP;
	    ifa = (struct ifaddr *) data;

	    break;
d217 4
a220 4
	    error = EINVAL;
    }

    return error;
@


1.7
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.6 1997/11/04 09:10:55 provos Exp $	*/
d55 1
a73 2
#define	ENCMTU	(1024+512)

d100 1
a100 1
    enc_softc.if_hdrlen = 0;
d106 1
a106 1
    bpfattach(&(enc_softc.if_bpf), &enc_softc, DLT_NULL, sizeof(u_int32_t));
a134 21

#if NBPFILTER > 0
    if (ifp->if_bpf) 
    {
	/*
	 * We need to prepend the address family as
	 * a four byte field.  Cons up a dummy header
	 * to pacify bpf.  This is safe because bpf
	 * will only read from the mbuf (i.e., it won't
	 * try to free it or keep a pointer a to it).
	 */
	struct mbuf m0;
	u_int af = dst->sa_family;

	m0.m_next = m;
	m0.m_len = 4;
	m0.m_data = (char *) &af;
	
	bpf_mtap(ifp->if_bpf, &m0);
    }
#endif
@


1.6
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.5 1997/07/11 23:37:53 provos Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
@


1.5
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.4 1997/07/01 22:12:39 provos Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
@


1.4
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.3 1997/02/27 04:05:45 angelos Exp $	*/
d69 1
a69 1
	    struct rtentry *));
d101 2
a102 2
    ifa = (struct ifaddr *)malloc(sizeof(struct ifaddr) + 
			sizeof(struct sockaddr), M_IFADDR, M_WAITOK);
d104 1
a104 1
    ifa->ifa_addr = ifa->ifa_dstaddr = (struct sockaddr *)(ifa + 1);
d123 1
a123 1
      panic("encoutput no HDR");
d142 1
a142 1
	m0.m_data = (char *)&af;
d242 1
a242 1
	    ifa = (struct ifaddr *)data;
@


1.3
log
@BPF support ifdefed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_enc.c,v 1.2 1997/02/24 13:33:58 niklas Exp $	*/
d65 1
a65 12
/*
 * Called from boot code to establish enc interfaces.
 */

struct enc_softc
{
	struct ifnet enc_if;
} ;

struct enc_softc *enc_softc;

int nencap;
d76 19
a94 2
	register struct enc_softc *enc;
	register int i = 0;
a95 17
	nencap = nenc;
	
	enc_softc = malloc(nenc * sizeof (*enc_softc), M_DEVBUF, M_WAIT);
	bzero(enc_softc, nenc * sizeof (*enc_softc));
	for (enc = enc_softc; i < nenc; enc++)
	{
		enc->enc_if.if_index = i;
		sprintf(enc->enc_if.if_xname, "enc%d", i++);
		enc->enc_if.if_list.tqe_next = NULL;
		enc->enc_if.if_mtu = ENCMTU;
		enc->enc_if.if_flags = IFF_LOOPBACK;
		enc->enc_if.if_type = IFT_ENC;
		enc->enc_if.if_ioctl = encioctl;
		enc->enc_if.if_output = encoutput;
		enc->enc_if.if_hdrlen = 0;
		enc->enc_if.if_addrlen = 0;
		if_attach(&enc->enc_if);
d97 1
a97 1
		bpfattach(&enc->enc_if.if_bpf, &enc->enc_if, DLT_NULL, sizeof(u_int));
d99 8
a106 1
	}
d119 5
a123 2
	int s, isr;
	register struct ifqueue *ifq = 0;
d125 18
a142 1
	/* register struct enc_softc *ec = &enc_softc[ifp->if_index]; */
d144 15
a158 32
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("encoutput no HDR");
	ifp->if_lastchange = time;
#if NBPFILTER > 0
	if (ifp->if_bpf) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer a to it).
		 */
		struct mbuf m0;
		u_int af = dst->sa_family;

		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *)&af;
		
		bpf_mtap(ifp->if_bpf, &m0);
	}
#endif
	m->m_pkthdr.rcvif = ifp;

	if (rt && rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE)) {
		m_freem(m);
		return (rt->rt_flags & RTF_BLACKHOLE ? 0 :
		        rt->rt_flags & RTF_HOST ? EHOSTUNREACH : ENETUNREACH);
	}
	ifp->if_opackets++;
	ifp->if_obytes += m->m_pkthdr.len;
	switch (dst->sa_family) {
d160 2
d164 3
a166 3
		ifq = &ipintrq;
		isr = NETISR_IP;
		break;
d170 3
a172 3
		ifq = &nsintrq;
		isr = NETISR_NS;
		break;
d176 2
a177 2
		ifq = &clnlintrq;
		isr = NETISR_ISO;
d181 10
a190 14
		m_freem(m);
		return (EAFNOSUPPORT);
	}
	s = splimp();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
		splx(s);
		return (ENOBUFS);
	}
	IF_ENQUEUE(ifq, m);
	schednetisr(isr);
	ifp->if_ipackets++;
	ifp->if_ibytes += m->m_pkthdr.len;
d192 13
a204 1
	return (0);
d210 3
a212 3
	int cmd;
	struct rtentry *rt;
	struct sockaddr *sa;
d214 3
a217 3
	if (rt)
		rt->rt_rmx.rmx_mtu = ENCMTU;
}
d227 3
a229 3
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d231 12
a242 13
	register struct ifaddr *ifa;
	register struct ifreq *ifr;
	register int error = 0;

	switch (cmd)
	{
	      case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		ifa = (struct ifaddr *)data;
		/*
		 * Everything else is done at a higher level.
		 */
		break;
d244 1
a244 1
		switch (ifr->ifr_addr.sa_family) {
d246 3
a248 12
#ifdef INET
		      case AF_INET:
			break;
#endif
		      case AF_ENCAP:
			break;
			
		      default:
			error = EAFNOSUPPORT;
			break;
		}
		break;
d250 1
a250 4
	      default:
		error = EINVAL;
	}
	return error;
@


1.2
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
d109 1
d131 1
d149 1
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 2
d78 5
a82 3
int encoutput(struct ifnet *, struct mbuf *, struct sockaddr *, struct rtentry *);
int encioctl(struct ifnet *, u_long, caddr_t);
void encrtrequest(int, struct rtentry *, struct sockaddr *);
@
