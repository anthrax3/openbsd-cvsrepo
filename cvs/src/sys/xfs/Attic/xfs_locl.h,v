head	1.9;
access;
symbols
	OPENBSD_4_5:1.8.0.14
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.12
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.10
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.8;

1.8
date	2005.11.21.18.16.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.12.10.11.56;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.27.04.58.49;	author art;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2000.09.11.14.26.52;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.03.00.54.58;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.00;	author art;	state Exp;
branches
	1.1.1.1
	1.1.4.1;
next	;

1.1.1.1
date	2002.06.07.03.32.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.51;	author hin;	state Exp;
branches;
next	;

1.1.4.1
date	2000.03.24.09.09.55;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.05.14.22.47.52;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.07.04.11.01.33;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.11.01.48;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* $arla: xfs_locl.h,v 1.72 2003/02/15 16:40:00 lha Exp $ */

#ifdef HAVE_CONFIG_H
#include <config.h>
#else
#include <xfs/xfs_config.h>
#endif

#ifndef RCSID
#define RCSID(x)
#endif

#ifdef __osf__

#ifdef __GNUC__
#define asm __foo_asm
#endif
#include <sys/types.h>
#include <sys/errno.h>
#include <sys/uio.h>
#include <machine/cpu.h>
#include <sys/conf.h>
#include <sys/sysconfig.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/poll.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/vfs_proto.h>
#include <io/common/devdriver.h>
#include <vm/vm_page.h>
#include <vm/vm_vppage.h>
#include <vm/vm_ubc.h>

typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned int uint32_t;

#define VT_AFS VT_ADDON
#define MOUNT_NNPFS MOUNT_PC

typedef struct nameidata xfs_componentname;

/* XXX this is gross, but makes the code considerably more readable */
#if 0
#define componentname	nameidata
#endif

#define cn_nameptr	ni_ptr
#define cn_namelen	ni_namelen
#define cn_hash		ni_hash
#define cn_cred		ni_cred
#define cn_nameiop	ni_nameiop
#define cn_flags	ni_flags

#define mnt_stat m_stat
#define mnt_flag m_flag

#define NDINIT(ndp, op, flags, segflg, namep, p)	\
	(ndp)->ni_nameiop = (op) | (flags);		\
	(ndp)->ni_segflg = segflg;			\
	(ndp)->ni_dirp = namep;

#define LOCKLEAF 0

#define FFLAGS(mode) ((mode) - FOPEN)

/* 4.4BSD vput does VOP_UNLOCK + vrele, but it seems as if we only
   should do a vrele here */
#define vput(VP) vrele(VP)

#define xfs_uio_to_proc(uiop) (u.u_procp)
#define xfs_cnp_to_proc(cnp) (u.u_procp)
#define xfs_proc_to_cred(p) ((p)->p_rcred)
#define xfs_proc_to_euid(p) ((p)->p_rcred->cr_uid)

#define xfs_curproc() (u.u_procp)

#define xfs_vop_read VOP_READ
#define xfs_vop_write VOP_WRITE
#define xfs_vop_getattr(t, attr, cred, proc, error) VOP_GETATTR((t), (attr), (cred), (error))
#define xfs_vop_access(dvp, mode, cred, proc, error) VOP_ACCESS((dvp), (mode), (cred), (error))

struct vop_generic_args;

typedef u_long va_size_t;

#else /* !__osf__ */

typedef struct componentname xfs_componentname;

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#ifdef HAVE_SYS_MODULE_H
#include <sys/module.h>
#endif
#include <sys/systm.h>
#include <sys/fcntl.h>
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#include <sys/conf.h>
#include <sys/mount.h>
#include <sys/exec.h>
#ifdef HAVE_SYS_SYSENT_H
#include <sys/sysent.h>
#endif
#ifdef HAVE_SYS_LKM_H
#include <sys/lkm.h>
#endif
#ifdef HAVE_SYS_LOCK_H
#include <sys/lock.h>
#endif
#ifdef HAVE_SYS_MUTEX_H
#include <sys/mutex.h>
#endif
#include <sys/vnode.h>
#include <sys/errno.h>
#include <sys/file.h>
#include <sys/namei.h>
#include <sys/dirent.h>
#include <sys/ucred.h>
#include <sys/selinfo.h>
#include <sys/uio.h>
#ifdef HAVE_SYS_POLL_H
#include <sys/poll.h>
#endif
#ifdef HAVE_SYS_SIGNALVAR_H
#include <sys/signalvar.h>
#endif
#ifdef HAVE_SYS_INTTYPES_H
#include <sys/inttypes.h>
#endif
#include <sys/syscall.h>
#include <sys/queue.h>
#include <sys/malloc.h>
#ifdef HAVE_SYS_SYSCALLARGS_H
#include <sys/syscallargs.h>
#endif
#ifdef HAVE_SYS_ATTR_H
#include <sys/attr.h>
#endif

#ifdef HAVE_MISCFS_GENFS_GENFS_H
#include <miscfs/genfs/genfs.h>
#endif
#ifdef HAVE_MISCFS_SYNCFS_SYNCFS_H
#include <miscfs/syncfs/syncfs.h>
#endif
#ifndef HAVE_KERNEL_UVM_ONLY
#ifdef HAVE_VM_VM_H
#include <vm/vm.h>
#endif
#ifdef HAVE_VM_VM_EXTERN_H
#include <vm/vm_extern.h>
#endif
#ifdef HAVE_VM_VM_ZONE_H
#include <vm/vm_zone.h>
#endif
#ifdef HAVE_VM_VM_OBJECT_H
#include <vm/vm_object.h>
#endif
#endif
#ifdef HAVE_UVM_UVM_EXTERN_H
#include <uvm/uvm_extern.h>
#endif
#ifdef HAVE_VM_UMA_H
#include <vm/uma.h>
#endif

#if defined(__APPLE__)
#include <machine/machine_routines.h>
#include <mach/machine/vm_types.h>
#include <sys/ubc.h>
void cache_purge(struct vnode *);
int cache_lookup(struct vnode *, struct vnode **, struct componentname *);
void cache_enter(struct vnode *, struct vnode *, struct componentname *);
void cache_purgevfs(struct mount *);
#endif

#define xfs_vop_read(t, uio, ioflag, cred, error) (error) = VOP_READ((t), (uio), (ioflag), (cred))
#define xfs_vop_write(t, uio, ioflag, cred, error) (error) = VOP_WRITE((t), (uio), (ioflag), (cred))
#define xfs_vop_getattr(t, attr, cred, proc, error) (error) = VOP_GETATTR((t), (attr), (cred), (proc))
#define xfs_vop_access(dvp, mode, cred, proc, error) (error) = VOP_ACCESS((dvp), (mode), (cred), (proc))

typedef u_quad_t va_size_t;

#endif /* !__osf__ */

#ifdef __FreeBSD_version
#if __FreeBSD_version < 400000
# error This version is unsupported
#elif __FreeBSD_version < 440001 || (__FreeBSD_version >= 500000 && __FreeBSD_version < 500023)
typedef struct proc d_thread_t;
#elif __FreeBSD_version == 500023
#   define HAVE_FREEBSD_THREAD
typedef struct thread d_thread_t;
#elif __FreeBSD_version >= 500024
#   define HAVE_FREEBSD_THREAD
#endif
typedef d_thread_t syscall_d_thread_t;
#define syscall_thread_to_thread(x) (x)
#else /* !__FreeBSD_version */
#if defined(__NetBSD__) && __NetBSD_Version__ >= 106130000
typedef struct lwp syscall_d_thread_t;
#define syscall_thread_to_thread(x) ((x)->l_proc)
#else
typedef struct proc syscall_d_thread_t;
#define syscall_thread_to_thread(x) (x)
#endif
typedef struct proc d_thread_t;
#endif /* !__FreeBSD_version */

#ifdef VV_ROOT
#define NNPFS_MAKE_VROOT(v) ((v)->v_vflag |= VV_ROOT) /* FreeBSD 5 */
#else
#define NNPFS_MAKE_VROOT(v) ((v)->v_flag |= VROOT)
#endif

#if defined(__NetBSD__) && __NetBSD_Version__ >= 105280000
#include <miscfs/genfs/genfs.h>
#include <miscfs/genfs/genfs_node.h>

struct genfs_ops xfs_genfsops;
#endif


#if defined(HAVE_FREEBSD_THREAD)
#define xfs_uio_to_thread(uiop) ((uiop)->uio_td)
#define xfs_cnp_to_thread(cnp) ((cnp)->cn_thread)
#define xfs_thread_to_cred(td) ((td)->td_proc->p_ucred)
#define xfs_thread_to_euid(td) ((td)->td_proc->p_ucred->cr_uid)
#else
#define xfs_uio_to_proc(uiop) ((uiop)->uio_procp)
#define xfs_cnp_to_proc(cnp) ((cnp)->cn_proc)
#define xfs_proc_to_cred(p) ((p)->p_ucred)
#define xfs_proc_to_euid(p) ((p)->p_ucred->cr_uid)
#endif

#if defined(__FreeBSD_version) && __FreeBSD_version >= 500043
extern const char *VT_AFS;
#endif

#if defined(__FreeBSD__)
typedef void * xfs_malloc_type;
#elif defined(__NetBSD__) && __NetBSD_Version__ >= 106140000 /* 1.6N */
typedef struct malloc_type * xfs_malloc_type;
#else
typedef int xfs_malloc_type;
#endif

#ifdef __APPLE__
#define xfs_curproc() (current_proc())
#else
#if defined(HAVE_FREEBSD_THREAD)
#define xfs_curthread() (curthread)
#else
#define xfs_curproc() (curproc)
#endif
#endif

#ifdef __osf__
#define xfs_pushdirty(vp, cred, p)
#else
void	xfs_pushdirty(struct vnode *, struct ucred *, d_thread_t *);
#endif


#if defined(HAVE_UINTPTR_T) /* c99 enviroment */
#define xfs_uintptr_t		uintptr_t
#else
#if defined(_LP64) || defined(alpha) || defined(__alpha__) || defined(__sparc64__) || defined(__sparcv9__)
#define xfs_uintptr_t		unsigned long long
#else /* !LP64 */
#define xfs_uintptr_t		unsigned long
#endif /* LP64 */
#endif

/*
 * XXX
 */

#ifndef SCARG
#if defined(__FreeBSD_version) && __FreeBSD_version >  500042
#define SCARG(a, b) ((a)->b)
#define syscallarg(x)   x
#else
#define SCARG(a, b) ((a)->b.datum)
#define syscallarg(x)   union { x datum; register_t pad; }
#endif /* __FreeBSD_version */
#endif /* SCARG */

#ifndef syscallarg
#define syscallarg(x)   x
#endif

#ifndef HAVE_REGISTER_T
typedef int register_t;
#endif

/* malloc(9) waits by default, freebsd post 5.0 choose to remove the flag */
#ifndef M_WAITOK
#define M_WAITOK 0
#endif

#if defined(HAVE_DEF_STRUCT_SETGROUPS_ARGS)
#define xfs_setgroups_args setgroups_args
#elif defined(HAVE_DEF_STRUCT_SYS_SETGROUPS_ARGS)
#define xfs_setgroups_args sys_setgroups_args
#elif __osf__
struct xfs_setgroups_args {
    syscallarg(int) gidsetsize;
    syscallarg(gid_t) *gidset;
};
#elif defined(__APPLE__)
struct xfs_setgroups_args{
        syscallarg(u_int)   gidsetsize;
        syscallarg(gid_t)   *gidset;
};
#else
#error what is you setgroups named ?
#endif


#ifdef HAVE_KERNEL_VFS_GETVFS
#define xfs_vfs_getvfs vfs_getvfs
#else
#define xfs_vfs_getvfs getvfs
#endif

#ifdef HAVE_FOUR_ARGUMENT_VFS_OBJECT_CREATE
#define xfs_vfs_object_create(vp,proc,ucred) vfs_object_create(vp,proc,ucred,TRUE)
#else
#define xfs_vfs_object_create(vp,proc,ucred) vfs_object_create(vp,proc,ucred)
#endif

#if  defined(UVM) || (defined(__NetBSD__) && __NetBSD_Version__ >= 105280000)
#define xfs_set_vp_size(vp, sz) uvm_vnp_setsize(vp, sz)
#elif HAVE_KERNEL_VNODE_PAGER_SETSIZE
#define xfs_set_vp_size(vp, sz) vnode_pager_setsize(vp, sz)
#elif defined(__APPLE__)
#define xfs_set_vp_size(vp, sz) ubc_setsize(vp, sz)
#else
#define xfs_set_vp_size(vp, sz)
#endif

/* namei flag */
#ifdef LOCKLEAF
#define NNPFS_LOCKLEAF LOCKLEAF
#else
#define NNPFS_LOCKLEAF 0
#endif

#ifdef NEED_VGONEL_PROTO
void    vgonel (struct vnode *vp, d_thread_t *p);
#endif

#ifdef NEED_ISSIGNAL_PROTO
int	issignal (d_thread_t *);
#endif

#ifdef NEED_STRNCMP_PROTO
int	strncmp (const char *, const char *, size_t);
#endif

#ifdef NEED_VN_WRITECHK_PROTO
int	vn_writechk (struct vnode *);
#endif

#ifdef NEED_UBC_PUSHDIRTY_PROTO
int     ubc_pushdirty (struct vnode *);
#endif

#include <xfs/xfs_syscalls.h>

/* 
 *  The VOP table
 *
 *    What VOPs do we have today ? 
 */

#define NNPFS_VOP_DEF(n)	\
	struct vop_##n##_args; \
	int xfs_##n(struct vop_##n##_args *);

#include "xfs/xfs_vopdefs.h"
@


1.8
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@@


1.7
log
@fix GENERIC compilation.
@
text
@d161 1
a161 1
#include <sys/select.h>
@


1.6
log
@Merge
@
text
@d38 2
@


1.5
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d34 1
a34 1
/* $Id: xfs_locl.h,v 1.4 2001/06/27 04:58:49 art Exp $ */
a37 2
#else
#include <xfs/xfs_config.h>
d67 1
a67 1
typedef unsigned short u_int16_t;
d69 1
a69 1
typedef unsigned int u_int32_t;
d72 1
a72 1
#define MOUNT_XFS MOUNT_PC
d126 1
a126 3
#if 0
#include <sys/ioctl.h>
#endif
d147 7
d167 3
d183 3
d203 3
d217 53
d274 13
d291 3
d296 1
d298 5
a302 4
#define xfs_vop_read(t, uio, ioflag, cred, error) (error) = VOP_READ((t), (uio), (ioflag), (cred))
#define xfs_vop_write(t, uio, ioflag, cred, error) (error) = VOP_WRITE((t), (uio), (ioflag), (cred))
#define xfs_vop_getattr(t, attr, cred, proc, error) (error) = VOP_GETATTR((t), (attr), (cred), (proc))
#define xfs_vop_access(dvp, mode, cred, proc, error) (error) = VOP_ACCESS((dvp), (mode), (cred), (proc))
a303 1
typedef u_quad_t va_size_t;
d305 9
a313 1
#endif /* !__osf__ */
d320 4
d326 2
a327 1
#endif
d337 5
d373 1
a373 1
#ifdef UVM
d383 27
d417 4
@


1.4
log
@Remove old vm.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
d34 1
a34 1
/* $Id: xfs_locl.h,v 1.3 2000/09/11 14:26:52 art Exp $ */
d109 1
a109 1
#define xfs_proc_to_ruid(p) ((p)->p_ruid)
d120 2
d177 1
d190 1
d198 1
d208 1
a208 1
#define xfs_proc_to_ruid(p) ((p)->p_cred->p_ruid)
d221 2
d273 1
a273 1
#ifdef __OpenBSD__
d277 2
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d39 1
a39 1
/* $Id: xfs_locl.h,v 1.4 2001/06/27 04:58:49 art Exp $ */
d114 1
a114 1
#define xfs_proc_to_euid(p) ((p)->p_rcred->cr_uid)
a124 2
typedef u_long va_size_t;

a179 1
#ifndef HAVE_KERNEL_UVM_ONLY
a191 1
#endif
a198 1
#include <sys/ubc.h>
d208 1
a208 1
#define xfs_proc_to_euid(p) ((p)->p_ucred->cr_uid)
a220 2
typedef u_quad_t va_size_t;

d271 1
a271 1
#ifdef UVM
a274 2
#elif defined(__APPLE__)
#define xfs_set_vp_size(vp, sz) ubc_setsize(vp, sz)
@


1.3
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d39 1
a39 1
/* $Id: xfs_locl.h,v 1.39 2000/08/16 10:43:17 assar Exp $ */
d271 1
a271 1
#ifdef UVM
@


1.2
log
@$OpenBSD$
@
text
@a0 1
/* $OpenBSD: xfs_locl.h,v 1.1 1999/04/30 01:59:00 art Exp $ */
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d39 1
d41 3
a43 1
#if 1 /* XXX - ugly hack */
d74 1
d114 1
d118 8
a125 1
#else /* __osf__ */
d131 3
d151 1
d153 1
d164 3
d170 7
d189 15
d208 1
d210 3
d214 64
d279 1
a279 1
#endif /* __osf__ */
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 1
a39 1
/* $Id: xfs_locl.h,v 1.21 1999/01/19 19:55:21 art Exp $ */
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d39 1
a39 1
/* $Id: xfs_locl.h,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $ */
d41 1
a41 3
#ifdef HAVE_CONFIG_H
#include <config.h>
#else
a71 1
typedef unsigned short u_int16_t;
a110 1
#define xfs_proc_to_euid(p) ((p)->p_rcred->cr_uid)
d114 1
a114 10
#define xfs_vop_read VOP_READ
#define xfs_vop_write VOP_WRITE
#define xfs_vop_getattr(t, attr, cred, proc, error) VOP_GETATTR((t), (attr), (cred), (error))
#define xfs_vop_access(dvp, mode, cred, proc, error) VOP_ACCESS((dvp), (mode), (cred), (error))

struct vop_generic_args;

typedef u_long va_size_t;

#else /* !__osf__ */
a119 3
#if 0
#include <sys/ioctl.h>
#endif
a136 1
#ifdef HAVE_SYS_LKM_H
a137 1
#endif
a147 3
#ifdef HAVE_SYS_SIGNALVAR_H
#include <sys/signalvar.h>
#endif
a150 7
#ifdef HAVE_SYS_SYSCALLARGS_H
#include <sys/syscallargs.h>
#endif
#ifdef HAVE_SYS_ATTR_H
#include <sys/attr.h>
#endif

a153 1
#ifndef HAVE_KERNEL_UVM_ONLY
a162 17
#ifdef HAVE_VM_VM_OBJECT_H
#include <vm/vm_object.h>
#endif
#endif
#ifdef HAVE_UVM_UVM_EXTERN_H
#include <uvm/uvm_extern.h>
#endif

#if defined(__APPLE__)
#include <machine/machine_routines.h>
#include <mach/machine/vm_types.h>
#include <sys/ubc.h>
void cache_purge(struct vnode *);
int cache_lookup(struct vnode *, struct vnode **, struct componentname *);
void cache_enter(struct vnode *, struct vnode *, struct componentname *);
void cache_purgevfs(struct mount *);
#endif
a166 1
#define xfs_proc_to_euid(p) ((p)->p_ucred->cr_uid)
a167 3
#ifdef __APPLE__
#define xfs_curproc() (current_proc())
#else
a168 68
#endif

#define xfs_vop_read(t, uio, ioflag, cred, error) (error) = VOP_READ((t), (uio), (ioflag), (cred))
#define xfs_vop_write(t, uio, ioflag, cred, error) (error) = VOP_WRITE((t), (uio), (ioflag), (cred))
#define xfs_vop_getattr(t, attr, cred, proc, error) (error) = VOP_GETATTR((t), (attr), (cred), (proc))
#define xfs_vop_access(dvp, mode, cred, proc, error) (error) = VOP_ACCESS((dvp), (mode), (cred), (proc))

typedef u_quad_t va_size_t;

#endif /* !__osf__ */

/*
 * XXX
 */

#ifndef SCARG
#define SCARG(a, b) ((a)->b.datum)
#define syscallarg(x)   union { x datum; register_t pad; }
#endif

#ifndef syscallarg
#define syscallarg(x)   x
#endif

#ifndef HAVE_REGISTER_T
typedef int register_t;
#endif

#if defined(HAVE_DEF_STRUCT_SETGROUPS_ARGS)
#define xfs_setgroups_args setgroups_args
#elif defined(HAVE_DEF_STRUCT_SYS_SETGROUPS_ARGS)
#define xfs_setgroups_args sys_setgroups_args
#elif __osf__
struct xfs_setgroups_args {
    syscallarg(int) gidsetsize;
    syscallarg(gid_t) *gidset;
};
#elif defined(__APPLE__)
struct xfs_setgroups_args{
        syscallarg(u_int)   gidsetsize;
        syscallarg(gid_t)   *gidset;
};
#else
#error what is you setgroups named ?
#endif


#ifdef HAVE_KERNEL_VFS_GETVFS
#define xfs_vfs_getvfs vfs_getvfs
#else
#define xfs_vfs_getvfs getvfs
#endif

#ifdef HAVE_FOUR_ARGUMENT_VFS_OBJECT_CREATE
#define xfs_vfs_object_create(vp,proc,ucred) vfs_object_create(vp,proc,ucred,TRUE)
#else
#define xfs_vfs_object_create(vp,proc,ucred) vfs_object_create(vp,proc,ucred)
#endif

#ifdef UVM
#define xfs_set_vp_size(vp, sz) uvm_vnp_setsize(vp, sz)
#elif HAVE_KERNEL_VNODE_PAGER_SETSIZE
#define xfs_set_vp_size(vp, sz) vnode_pager_setsize(vp, sz)
#elif defined(__APPLE__)
#define xfs_set_vp_size(vp, sz) ubc_setsize(vp, sz)
#else
#define xfs_set_vp_size(vp, sz)
#endif
d170 1
a170 1
#include <xfs/xfs_syscalls.h>
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d34 1
a34 1
/* $arla: xfs_locl.h,v 1.72 2003/02/15 16:40:00 lha Exp $ */
d38 2
d69 1
a69 1
typedef unsigned short uint16_t;
d71 1
a71 1
typedef unsigned int uint32_t;
d74 1
a74 1
#define MOUNT_NNPFS MOUNT_PC
d128 3
a130 1
#include <sys/time.h>
a150 7
#ifdef HAVE_SYS_LOCK_H
#include <sys/lock.h>
#endif
#ifdef HAVE_SYS_MUTEX_H
#include <sys/mutex.h>
#endif
#include <sys/vnode.h>
a163 3
#ifdef HAVE_SYS_INTTYPES_H
#include <sys/inttypes.h>
#endif
a176 3
#ifdef HAVE_MISCFS_SYNCFS_SYNCFS_H
#include <miscfs/syncfs/syncfs.h>
#endif
a193 3
#ifdef HAVE_VM_UMA_H
#include <vm/uma.h>
#endif
a204 53
#define xfs_vop_read(t, uio, ioflag, cred, error) (error) = VOP_READ((t), (uio), (ioflag), (cred))
#define xfs_vop_write(t, uio, ioflag, cred, error) (error) = VOP_WRITE((t), (uio), (ioflag), (cred))
#define xfs_vop_getattr(t, attr, cred, proc, error) (error) = VOP_GETATTR((t), (attr), (cred), (proc))
#define xfs_vop_access(dvp, mode, cred, proc, error) (error) = VOP_ACCESS((dvp), (mode), (cred), (proc))

typedef u_quad_t va_size_t;

#endif /* !__osf__ */

#ifdef __FreeBSD_version
#if __FreeBSD_version < 400000
# error This version is unsupported
#elif __FreeBSD_version < 440001 || (__FreeBSD_version >= 500000 && __FreeBSD_version < 500023)
typedef struct proc d_thread_t;
#elif __FreeBSD_version == 500023
#   define HAVE_FREEBSD_THREAD
typedef struct thread d_thread_t;
#elif __FreeBSD_version >= 500024
#   define HAVE_FREEBSD_THREAD
#endif
typedef d_thread_t syscall_d_thread_t;
#define syscall_thread_to_thread(x) (x)
#else /* !__FreeBSD_version */
#if defined(__NetBSD__) && __NetBSD_Version__ >= 106130000
typedef struct lwp syscall_d_thread_t;
#define syscall_thread_to_thread(x) ((x)->l_proc)
#else
typedef struct proc syscall_d_thread_t;
#define syscall_thread_to_thread(x) (x)
#endif
typedef struct proc d_thread_t;
#endif /* !__FreeBSD_version */

#ifdef VV_ROOT
#define NNPFS_MAKE_VROOT(v) ((v)->v_vflag |= VV_ROOT) /* FreeBSD 5 */
#else
#define NNPFS_MAKE_VROOT(v) ((v)->v_flag |= VROOT)
#endif

#if defined(__NetBSD__) && __NetBSD_Version__ >= 105280000
#include <miscfs/genfs/genfs.h>
#include <miscfs/genfs/genfs_node.h>

struct genfs_ops xfs_genfsops;
#endif


#if defined(HAVE_FREEBSD_THREAD)
#define xfs_uio_to_thread(uiop) ((uiop)->uio_td)
#define xfs_cnp_to_thread(cnp) ((cnp)->cn_thread)
#define xfs_thread_to_cred(td) ((td)->td_proc->p_ucred)
#define xfs_thread_to_euid(td) ((td)->td_proc->p_ucred->cr_uid)
#else
a208 13
#endif

#if defined(__FreeBSD_version) && __FreeBSD_version >= 500043
extern const char *VT_AFS;
#endif

#if defined(__FreeBSD__)
typedef void * xfs_malloc_type;
#elif defined(__NetBSD__) && __NetBSD_Version__ >= 106140000 /* 1.6N */
typedef struct malloc_type * xfs_malloc_type;
#else
typedef int xfs_malloc_type;
#endif
a212 3
#if defined(HAVE_FREEBSD_THREAD)
#define xfs_curthread() (curthread)
#else
a214 1
#endif
d216 4
a219 5
#ifdef __osf__
#define xfs_pushdirty(vp, cred, p)
#else
void	xfs_pushdirty(struct vnode *, struct ucred *, d_thread_t *);
#endif
d221 1
d223 1
a223 9
#if defined(HAVE_UINTPTR_T) /* c99 enviroment */
#define xfs_uintptr_t		uintptr_t
#else
#if defined(_LP64) || defined(alpha) || defined(__alpha__) || defined(__sparc64__) || defined(__sparcv9__)
#define xfs_uintptr_t		unsigned long long
#else /* !LP64 */
#define xfs_uintptr_t		unsigned long
#endif /* LP64 */
#endif
a229 4
#if defined(__FreeBSD_version) && __FreeBSD_version >  500042
#define SCARG(a, b) ((a)->b)
#define syscallarg(x)   x
#else
d232 1
a232 2
#endif /* __FreeBSD_version */
#endif /* SCARG */
a241 5
/* malloc(9) waits by default, freebsd post 5.0 choose to remove the flag */
#ifndef M_WAITOK
#define M_WAITOK 0
#endif

d273 1
a273 1
#if  defined(UVM) || (defined(__NetBSD__) && __NetBSD_Version__ >= 105280000)
a282 27
/* namei flag */
#ifdef LOCKLEAF
#define NNPFS_LOCKLEAF LOCKLEAF
#else
#define NNPFS_LOCKLEAF 0
#endif

#ifdef NEED_VGONEL_PROTO
void    vgonel (struct vnode *vp, d_thread_t *p);
#endif

#ifdef NEED_ISSIGNAL_PROTO
int	issignal (d_thread_t *);
#endif

#ifdef NEED_STRNCMP_PROTO
int	strncmp (const char *, const char *, size_t);
#endif

#ifdef NEED_VN_WRITECHK_PROTO
int	vn_writechk (struct vnode *);
#endif

#ifdef NEED_UBC_PUSHDIRTY_PROTO
int     ubc_pushdirty (struct vnode *);
#endif

a289 4

#define NNPFS_VOP_DEF(n)	\
	struct vop_##n##_args; \
	int xfs_##n(struct vop_##n##_args *);
@


1.1.4.1
log
@Sync with -current
@
text
@a0 1
/* $OpenBSD$ */
d39 1
@


1.1.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
a39 1
/* $Id: xfs_locl.h,v 1.3 2000/09/11 14:26:52 art Exp $ */
d41 1
a41 3
#ifdef HAVE_CONFIG_H
#include <config.h>
#else
a71 1
typedef unsigned short u_int16_t;
a110 1
#define xfs_proc_to_ruid(p) ((p)->p_ruid)
d114 1
a114 8
#define xfs_vop_read VOP_READ
#define xfs_vop_write VOP_WRITE
#define xfs_vop_getattr(t, attr, cred, proc, error) VOP_GETATTR((t), (attr), (cred), (error))
#define xfs_vop_access(dvp, mode, cred, proc, error) VOP_ACCESS((dvp), (mode), (cred), (error))

struct vop_generic_args;

#else /* !__osf__ */
a119 3
#if 0
#include <sys/ioctl.h>
#endif
a136 1
#ifdef HAVE_SYS_LKM_H
a137 1
#endif
a147 3
#ifdef HAVE_SYS_SIGNALVAR_H
#include <sys/signalvar.h>
#endif
a150 7
#ifdef HAVE_SYS_SYSCALLARGS_H
#include <sys/syscallargs.h>
#endif
#ifdef HAVE_SYS_ATTR_H
#include <sys/attr.h>
#endif

a162 15
#ifdef HAVE_VM_VM_OBJECT_H
#include <vm/vm_object.h>
#endif
#ifdef HAVE_UVM_UVM_EXTERN_H
#include <uvm/uvm_extern.h>
#endif

#if defined(__APPLE__)
#include <machine/machine_routines.h>
#include <mach/machine/vm_types.h>
void cache_purge(struct vnode *);
int cache_lookup(struct vnode *, struct vnode **, struct componentname *);
void cache_enter(struct vnode *, struct vnode *, struct componentname *);
void cache_purgevfs(struct mount *);
#endif
a166 1
#define xfs_proc_to_ruid(p) ((p)->p_cred->p_ruid)
a167 3
#ifdef __APPLE__
#define xfs_curproc() (current_proc())
#else
a168 64
#endif

#define xfs_vop_read(t, uio, ioflag, cred, error) (error) = VOP_READ((t), (uio), (ioflag), (cred))
#define xfs_vop_write(t, uio, ioflag, cred, error) (error) = VOP_WRITE((t), (uio), (ioflag), (cred))
#define xfs_vop_getattr(t, attr, cred, proc, error) (error) = VOP_GETATTR((t), (attr), (cred), (proc))
#define xfs_vop_access(dvp, mode, cred, proc, error) (error) = VOP_ACCESS((dvp), (mode), (cred), (proc))

#endif /* !__osf__ */

/*
 * XXX
 */

#ifndef SCARG
#define SCARG(a, b) ((a)->b.datum)
#define syscallarg(x)   union { x datum; register_t pad; }
#endif

#ifndef syscallarg
#define syscallarg(x)   x
#endif

#ifndef HAVE_REGISTER_T
typedef int register_t;
#endif

#if defined(HAVE_DEF_STRUCT_SETGROUPS_ARGS)
#define xfs_setgroups_args setgroups_args
#elif defined(HAVE_DEF_STRUCT_SYS_SETGROUPS_ARGS)
#define xfs_setgroups_args sys_setgroups_args
#elif __osf__
struct xfs_setgroups_args {
    syscallarg(int) gidsetsize;
    syscallarg(gid_t) *gidset;
};
#elif defined(__APPLE__)
struct xfs_setgroups_args{
        syscallarg(u_int)   gidsetsize;
        syscallarg(gid_t)   *gidset;
};
#else
#error what is you setgroups named ?
#endif


#ifdef HAVE_KERNEL_VFS_GETVFS
#define xfs_vfs_getvfs vfs_getvfs
#else
#define xfs_vfs_getvfs getvfs
#endif

#ifdef HAVE_FOUR_ARGUMENT_VFS_OBJECT_CREATE
#define xfs_vfs_object_create(vp,proc,ucred) vfs_object_create(vp,proc,ucred,TRUE)
#else
#define xfs_vfs_object_create(vp,proc,ucred) vfs_object_create(vp,proc,ucred)
#endif

#ifdef UVM
#define xfs_set_vp_size(vp, sz) uvm_vnp_setsize(vp, sz)
#elif HAVE_KERNEL_VNODE_PAGER_SETSIZE
#define xfs_set_vp_size(vp, sz) vnode_pager_setsize(vp, sz)
#else
#define xfs_set_vp_size(vp, sz)
#endif
d170 1
a170 1
#include <xfs/xfs_syscalls.h>
@


1.1.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d39 1
a39 1
/* $Id: xfs_locl.h,v 1.1.4.2 2001/05/14 22:47:52 niklas Exp $ */
d271 1
a271 1
#ifdef __OpenBSD__
@


1.1.4.4
log
@Sync the SMP branch with 3.3
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d39 1
a39 1
/* $Id$ */
d114 1
a114 1
#define xfs_proc_to_euid(p) ((p)->p_rcred->cr_uid)
a124 2
typedef u_long va_size_t;

a179 1
#ifndef HAVE_KERNEL_UVM_ONLY
a191 1
#endif
a198 1
#include <sys/ubc.h>
d208 1
a208 1
#define xfs_proc_to_euid(p) ((p)->p_ucred->cr_uid)
a220 2
typedef u_quad_t va_size_t;

d271 1
a271 1
#ifdef UVM
a274 2
#elif defined(__APPLE__)
#define xfs_set_vp_size(vp, sz) ubc_setsize(vp, sz)
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d34 1
a34 1
/* $arla: xfs_locl.h,v 1.72 2003/02/15 16:40:00 lha Exp $ */
d69 1
a69 1
typedef unsigned short uint16_t;
d71 1
a71 1
typedef unsigned int uint32_t;
d74 1
a74 1
#define MOUNT_NNPFS MOUNT_PC
d128 3
a130 1
#include <sys/time.h>
a150 7
#ifdef HAVE_SYS_LOCK_H
#include <sys/lock.h>
#endif
#ifdef HAVE_SYS_MUTEX_H
#include <sys/mutex.h>
#endif
#include <sys/vnode.h>
a163 3
#ifdef HAVE_SYS_INTTYPES_H
#include <sys/inttypes.h>
#endif
a176 3
#ifdef HAVE_MISCFS_SYNCFS_SYNCFS_H
#include <miscfs/syncfs/syncfs.h>
#endif
a193 3
#ifdef HAVE_VM_UMA_H
#include <vm/uma.h>
#endif
a204 53
#define xfs_vop_read(t, uio, ioflag, cred, error) (error) = VOP_READ((t), (uio), (ioflag), (cred))
#define xfs_vop_write(t, uio, ioflag, cred, error) (error) = VOP_WRITE((t), (uio), (ioflag), (cred))
#define xfs_vop_getattr(t, attr, cred, proc, error) (error) = VOP_GETATTR((t), (attr), (cred), (proc))
#define xfs_vop_access(dvp, mode, cred, proc, error) (error) = VOP_ACCESS((dvp), (mode), (cred), (proc))

typedef u_quad_t va_size_t;

#endif /* !__osf__ */

#ifdef __FreeBSD_version
#if __FreeBSD_version < 400000
# error This version is unsupported
#elif __FreeBSD_version < 440001 || (__FreeBSD_version >= 500000 && __FreeBSD_version < 500023)
typedef struct proc d_thread_t;
#elif __FreeBSD_version == 500023
#   define HAVE_FREEBSD_THREAD
typedef struct thread d_thread_t;
#elif __FreeBSD_version >= 500024
#   define HAVE_FREEBSD_THREAD
#endif
typedef d_thread_t syscall_d_thread_t;
#define syscall_thread_to_thread(x) (x)
#else /* !__FreeBSD_version */
#if defined(__NetBSD__) && __NetBSD_Version__ >= 106130000
typedef struct lwp syscall_d_thread_t;
#define syscall_thread_to_thread(x) ((x)->l_proc)
#else
typedef struct proc syscall_d_thread_t;
#define syscall_thread_to_thread(x) (x)
#endif
typedef struct proc d_thread_t;
#endif /* !__FreeBSD_version */

#ifdef VV_ROOT
#define NNPFS_MAKE_VROOT(v) ((v)->v_vflag |= VV_ROOT) /* FreeBSD 5 */
#else
#define NNPFS_MAKE_VROOT(v) ((v)->v_flag |= VROOT)
#endif

#if defined(__NetBSD__) && __NetBSD_Version__ >= 105280000
#include <miscfs/genfs/genfs.h>
#include <miscfs/genfs/genfs_node.h>

struct genfs_ops xfs_genfsops;
#endif


#if defined(HAVE_FREEBSD_THREAD)
#define xfs_uio_to_thread(uiop) ((uiop)->uio_td)
#define xfs_cnp_to_thread(cnp) ((cnp)->cn_thread)
#define xfs_thread_to_cred(td) ((td)->td_proc->p_ucred)
#define xfs_thread_to_euid(td) ((td)->td_proc->p_ucred->cr_uid)
#else
a208 13
#endif

#if defined(__FreeBSD_version) && __FreeBSD_version >= 500043
extern const char *VT_AFS;
#endif

#if defined(__FreeBSD__)
typedef void * xfs_malloc_type;
#elif defined(__NetBSD__) && __NetBSD_Version__ >= 106140000 /* 1.6N */
typedef struct malloc_type * xfs_malloc_type;
#else
typedef int xfs_malloc_type;
#endif
a212 3
#if defined(HAVE_FREEBSD_THREAD)
#define xfs_curthread() (curthread)
#else
a214 1
#endif
d216 4
a219 5
#ifdef __osf__
#define xfs_pushdirty(vp, cred, p)
#else
void	xfs_pushdirty(struct vnode *, struct ucred *, d_thread_t *);
#endif
d221 1
d223 1
a223 9
#if defined(HAVE_UINTPTR_T) /* c99 enviroment */
#define xfs_uintptr_t		uintptr_t
#else
#if defined(_LP64) || defined(alpha) || defined(__alpha__) || defined(__sparc64__) || defined(__sparcv9__)
#define xfs_uintptr_t		unsigned long long
#else /* !LP64 */
#define xfs_uintptr_t		unsigned long
#endif /* LP64 */
#endif
a229 4
#if defined(__FreeBSD_version) && __FreeBSD_version >  500042
#define SCARG(a, b) ((a)->b)
#define syscallarg(x)   x
#else
d232 1
a232 2
#endif /* __FreeBSD_version */
#endif /* SCARG */
a241 5
/* malloc(9) waits by default, freebsd post 5.0 choose to remove the flag */
#ifndef M_WAITOK
#define M_WAITOK 0
#endif

d273 1
a273 1
#if  defined(UVM) || (defined(__NetBSD__) && __NetBSD_Version__ >= 105280000)
a282 27
/* namei flag */
#ifdef LOCKLEAF
#define NNPFS_LOCKLEAF LOCKLEAF
#else
#define NNPFS_LOCKLEAF 0
#endif

#ifdef NEED_VGONEL_PROTO
void    vgonel (struct vnode *vp, d_thread_t *p);
#endif

#ifdef NEED_ISSIGNAL_PROTO
int	issignal (d_thread_t *);
#endif

#ifdef NEED_STRNCMP_PROTO
int	strncmp (const char *, const char *, size_t);
#endif

#ifdef NEED_VN_WRITECHK_PROTO
int	vn_writechk (struct vnode *);
#endif

#ifdef NEED_UBC_PUSHDIRTY_PROTO
int     ubc_pushdirty (struct vnode *);
#endif

a289 4

#define NNPFS_VOP_DEF(n)	\
	struct vop_##n##_args; \
	int xfs_##n(struct vop_##n##_args *);
@


