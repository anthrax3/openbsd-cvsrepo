head	1.13;
access;
symbols
	OPENBSD_4_5:1.12.0.6
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.12;

1.12
date	2007.10.08.04.15.15;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.11.16.08.50;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.04.16.12.32;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.03.12.10.48;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.12.10.55.09;	author hin;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.03.16.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.11.14.26.54;	author art;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	2000.03.03.00.54.59;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.19.49.37;	author art;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.04.30.01.59.01;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.03.33.00;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.49;	author hin;	state Exp;
branches;
next	;

1.2.4.1
date	2000.03.24.09.09.56;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.05.14.22.47.54;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.03.28.00.41.31;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2004.02.19.11.01.52;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * NNPFS operations.
 */

#include <xfs/xfs_locl.h>
#include <xfs/xfs_message.h>
#include <xfs/xfs_common.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_dev.h>
#include <xfs/xfs_deb.h>
#include <xfs/xfs_syscalls.h>
#include <xfs/xfs_vnodeops.h>

RCSID("$arla: xfs_vnodeops-common.c,v 1.94 2003/01/27 11:58:50 lha Exp $");

static void
xfs_handle_stale(struct xfs_node *xn)
{
#if __APPLE__
    struct vnode *vp = XNODE_TO_VNODE(xn);
#endif

    if ((xn->flags & NNPFS_STALE) == 0)
	return;

#if __APPLE__
    if (UBCISVALID(vp) && !ubc_isinuse(vp, 1)) {
	xn->flags &= ~NNPFS_STALE;
	ubc_setsize(vp, 0);
	NNPFS_TOKEN_CLEAR(xn, ~0,
			NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
			NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
    }
#endif
}

int
xfs_open_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
	       u_int tok)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int error = 0;

    NNPFSDEB(XDEBVFOPS, ("xfs_open_valid\n"));

    xfs_handle_stale(xn);

    do {
	if (!NNPFS_TOKEN_GOT(xn, tok)) {
	    struct xfs_message_open msg;

	    msg.header.opcode = NNPFS_MSG_OPEN;
	    msg.cred.uid = cred->cr_uid;
	    msg.cred.pag = xfs_get_pag(cred);
	    msg.handle = xn->handle;
	    msg.tokens = tok;

	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);

	    if (error == 0)
		error = ((struct xfs_message_wakeup *) & msg)->error;
	} else {
	    goto done;
	}
    } while (error == 0);

done:
    NNPFSDEB(XDEBVFOPS, ("xfs_open_valid: error = %d\n", error));

    return error;
}

int
xfs_attr_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
	       u_int tok)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int error = 0;
    xfs_pag_t pag = xfs_get_pag(cred);

    do {
	if (!NNPFS_TOKEN_GOT(xn, tok) || !xfs_has_pag(xn, pag)) {
	    struct xfs_message_getattr msg;

	    msg.header.opcode = NNPFS_MSG_GETATTR;
	    msg.cred.uid = cred->cr_uid;
	    msg.cred.pag = pag;
	    msg.handle = xn->handle;
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	    if (error == 0)
		error = ((struct xfs_message_wakeup *) & msg)->error;
	} else {
	    goto done;
	}
    } while (error == 0);

done:
    return error;
}

int
xfs_data_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
	       u_int tok, uint32_t want_offset)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int error = 0;
    uint32_t offset;
    struct xfs_message_getdata msg;

    do {
	offset = want_offset;
	if (NNPFS_TOKEN_GOT(xn, tok|NNPFS_ATTR_R) && offset > xn->attr.va_size) {
	    offset = xn->attr.va_size;
	}
    
	NNPFSDEB(XDEBVNOPS, ("xfs_data_valid: offset: want %ld has %ld, "
			   "tokens: want %lx has %lx length: %ld\n",
			   (long) offset, (long) xn->offset,
			   (long) tok, (long) xn->tokens,
			   (long) xn->attr.va_size));

	if (NNPFS_TOKEN_GOT(xn, tok)) {
	    if (offset <= xn->offset || xn->attr.va_type == VDIR) {
		break;
	    }
	}

	msg.header.opcode = NNPFS_MSG_GETDATA;
	msg.cred.uid = cred->cr_uid;
	msg.cred.pag = xfs_get_pag(cred);
	msg.handle = xn->handle;
	msg.tokens = tok;
	msg.offset = offset;
	
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
	
    } while (error == 0);

    return error;
}

int
xfs_open_common(struct vnode *vp,
		int mode,
		struct ucred *cred,
		d_thread_t *p)
{
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int ret;

    NNPFSDEB(XDEBVNOPS, ("xfs_open\n"));

    if (mode & FWRITE) {
	ret = xfs_open_valid(vp, cred, p, NNPFS_OPEN_NW);
    } else {
	ret = xfs_open_valid(vp, cred, p, NNPFS_OPEN_NR);
    }

    /* always update the read cred */

    if (mode & FWRITE)
	xfs_update_write_cred(xn, cred);
    xfs_update_read_cred(xn, cred);

    return ret;
}

static int
do_fsync(struct xfs *xfsp,
	 struct xfs_node *xn,
	 struct ucred *cred,
	 d_thread_t *p,
	 u_int flag)
{
    int error;
    struct xfs_message_putdata msg;

    msg.header.opcode = NNPFS_MSG_PUTDATA;
    if (cred != NOCRED) {
	msg.cred.uid = cred->cr_uid;
	msg.cred.pag = xfs_get_pag(cred);
    } else {
	msg.cred.uid = 0;
	msg.cred.pag = NNPFS_ANONYMOUSID;
    }
    msg.handle = xn->handle;
    vattr2xfs_attr(&xn->attr, &msg.attr);
    msg.flag   = flag;

    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);

    if (error == 0)
	error = ((struct xfs_message_wakeup *) & msg)->error;

    if (error == 0)
	xn->flags &= ~NNPFS_DATA_DIRTY;

    return error;
}

int
xfs_fsync_common(struct vnode *vp, struct ucred *cred,
		 int waitfor, d_thread_t *proc)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_fsync: %lx\n", (unsigned long)vp));

    /*
     * It seems that fsync is sometimes called after reclaiming a node.
     * In that case we just look happy.
     */

    if (xn == NULL) {
	printf("NNPFS PANIC WARNING! xfs_fsync called after reclaiming!\n");
	return 0;
    }
    
    xfs_pushdirty(vp, cred, proc);

    if (xn->flags & NNPFS_DATA_DIRTY) {
#ifdef FSYNC_RECLAIM
	/* writing back the data from this vnode failed */
	if (waitfor & FSYNC_RECLAIM) {
	    printf("xfs_fsync: data lost, failed to write back\n");
	    xn->flags &= ~NNPFS_DATA_DIRTY;
	    return 0;
	}
#endif    
	error = do_fsync(xfsp, xn, cred, proc, NNPFS_WRITE | NNPFS_FSYNC);
    }

    return error;
}

int
xfs_close_common(struct vnode *vp, int fflag,
		 d_thread_t *proc, struct ucred *cred)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int error = 0;
    
    NNPFSDEB(XDEBVNOPS,
	   ("xfs_close cred = %lx, fflag = %x, xn->flags = %x\n",
	    (unsigned long)cred, fflag, xn->flags));

    if (vp->v_type == VREG)
	xfs_pushdirty(vp, cred, proc);

    if (fflag & FWRITE && xn->flags & NNPFS_DATA_DIRTY)
	error = do_fsync(xfsp, xn, cred, proc, NNPFS_WRITE);

    return error;
}

size_t
xfs_uio_end_length (struct uio *uio)
{
#ifdef DIAGNOSTIC
    size_t sz = 0;
    int i;

    for (i = 0; i < uio->uio_iovcnt; i++)
	sz += uio->uio_iov[i].iov_len;
    if (sz != uio->uio_resid)
	panic("xfs_uio_end_length");
#endif
    return uio->uio_offset + uio->uio_resid;
}


int
xfs_read_common(struct vnode *vp, struct uio *uio, int ioflag,
		struct ucred *cred)
{
    int error = 0;
    int i;

    NNPFSDEB(XDEBVNOPS, ("xfs_read\n"));

    xfs_update_read_cred(VNODE_TO_XNODE(vp), cred);

#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uio), NNPFS_DATA_R,
			   xfs_uio_end_length(uio));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uio), NNPFS_DATA_R,
			   xfs_uio_end_length(uio));
#endif

    NNPFSDEB(XDEBVNOPS, ("xfs_read: iovcnt: %d\n", uio->uio_iovcnt));
    for (i = 0; i < uio->uio_iovcnt; i++)
	NNPFSDEB(XDEBVNOPS, ("  base: %lx len: %lu\n",
			   (unsigned long)uio->uio_iov[i].iov_base,
			   (unsigned long)uio->uio_iov[i].iov_len));

    if (error == 0) {
	struct vnode *t = DATA_FROM_VNODE(vp);

#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uio));
	xfs_vop_read(t, uio, ioflag, cred, error);
	xfs_vfs_unlock(t, xfs_uio_to_thread(uio));
#else
	xfs_vfs_readlock(t, xfs_uio_to_proc(uio));
	xfs_vop_read(t, uio, ioflag, cred, error);
	xfs_vfs_unlock(t, xfs_uio_to_proc(uio));
#endif
    }

    NNPFSDEB(XDEBVNOPS, ("xfs_read offset: %lu resid: %lu\n",
		       (unsigned long)uio->uio_offset,
		       (unsigned long)uio->uio_resid));
    NNPFSDEB(XDEBVNOPS, ("xfs_read error: %d\n", error));

    return error;
}

int
xfs_write_common(struct vnode *vp, struct uio *uiop, int ioflag,
		 struct ucred *cred)
{
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_write\n"));

    xfs_update_write_cred(xn, cred);

#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_W,
			   VNODE_TO_XNODE(vp)->attr.va_size);
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_W,
			   VNODE_TO_XNODE(vp)->attr.va_size);
#endif

    if (error == 0) {
	struct vnode *t = DATA_FROM_XNODE(xn);
	struct vattr sub_attr;
	int error2 = 0;
 
 #ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_writelock(t, xfs_uio_to_thread(uiop));
	xfs_vop_write(t, uiop, ioflag, cred, error);
	VNODE_TO_XNODE(vp)->flags |= NNPFS_DATA_DIRTY;
	xfs_vop_getattr(t, &sub_attr, cred, xfs_uio_to_thread(uiop), error2);
 #else
	xfs_vfs_writelock(t, xfs_uio_to_proc(uiop));
	xfs_vop_write(t, uiop, ioflag, cred, error);
	VNODE_TO_XNODE(vp)->flags |= NNPFS_DATA_DIRTY;
	xfs_vop_getattr(t, &sub_attr, cred, xfs_uio_to_proc(uiop), error2);
 #endif

	if (error2 == 0) {
	    xn->attr.va_size  = sub_attr.va_size;
	    xn->attr.va_bytes = sub_attr.va_size;
	    xn->attr.va_mtime = sub_attr.va_mtime;
	    xfs_set_vp_size(vp, sub_attr.va_size);
	    xn->offset = sub_attr.va_size;
	}
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
	xfs_vfs_unlock(t, xfs_uio_to_proc(uiop));
#endif
    }

    return error;
}

int
xfs_getattr_common(struct vnode *vp, struct vattr *vap,
		   struct ucred *cred, d_thread_t *p)
{
    int error = 0;

    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    NNPFSDEB(XDEBVNOPS, ("xfs_getattr\n"));

    error = xfs_attr_valid(vp, cred, p, NNPFS_ATTR_R);
    if (error == 0)
	*vap = xn->attr;
    return error;
}

int
xfs_setattr_common(struct vnode *vp, struct vattr *vap,
		   struct ucred *cred, d_thread_t *p)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_setattr\n"));

#define CHECK_NNPFSATTR(A, cast) (vap->A == cast VNOVAL || vap->A == xn->attr.A)
	if (CHECK_NNPFSATTR(va_mode,(mode_t)) &&
	    CHECK_NNPFSATTR(va_nlink,(short)) &&
	    CHECK_NNPFSATTR(va_size,(va_size_t)) &&
	    CHECK_NNPFSATTR(va_uid,(uid_t)) &&
	    CHECK_NNPFSATTR(va_gid,(gid_t)) &&
	    CHECK_NNPFSATTR(va_mtime.tv_sec,(unsigned int)) &&
	    CHECK_NNPFSATTR(va_fileid,(long)) &&
	    CHECK_NNPFSATTR(va_type,(enum vtype)))
		return 0;		/* Nothing to do */
#undef CHECK_NNPFSATTR

    if (NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_W)) {
	/* Update attributes and mark them dirty. */
	VNODE_TO_XNODE(vp)->flags |= NNPFS_ATTR_DIRTY;
	error = EINVAL;		       /* XXX not yet implemented */
	goto done;
    } else {
	struct xfs_message_putattr msg;

	msg.header.opcode = NNPFS_MSG_PUTATTR;
	if (cred != NOCRED) {
	    msg.cred.uid = cred->cr_uid;
	    msg.cred.pag = xfs_get_pag(cred);
	} else {
	    msg.cred.uid = 0;
	    msg.cred.pag = NNPFS_ANONYMOUSID;
	}
	msg.handle = xn->handle;
	vattr2xfs_attr(vap, &msg.attr);
	if (NNPFS_TOKEN_GOT(xn, NNPFS_DATA_R)) {
	    if (vp->v_type == VREG) {
		if (vap->va_size != (va_size_t)VNOVAL)
		    XA_SET_SIZE(&msg.attr, vap->va_size);
		else
		    XA_SET_SIZE(&msg.attr, xn->attr.va_size);
#ifdef __APPLE__
		/* XXX needed ? */
		if (UBCINFOEXISTS(vp))
		    ubc_setsize(vp, msg.attr.xa_size);
#endif
	    }
	    if (vap->va_mtime.tv_sec != (unsigned int)VNOVAL)
		XA_SET_MTIME(&msg.attr, vap->va_mtime.tv_sec);
	    else
		XA_SET_MTIME(&msg.attr, xn->attr.va_mtime.tv_sec);
	}

	NNPFS_TOKEN_CLEAR(xn, NNPFS_ATTR_VALID, NNPFS_ATTR_MASK);
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
    }

done:
    return error;
}

static int
check_rights (u_char rights, int mode)
{
    int error = 0;

    if (mode & VREAD)
	if ((rights & NNPFS_RIGHT_R) == 0)
	    error = EACCES;
    if (mode & VWRITE)
	if ((rights & NNPFS_RIGHT_W) == 0)
	    error = EACCES;
    if (mode & VEXEC)
	if ((rights & NNPFS_RIGHT_X) == 0)
	    error = EACCES;
    return error;
}

int
xfs_access_common(struct vnode *vp, int mode, struct ucred *cred,
		  d_thread_t *p)
{
    int error = 0;
    xfs_pag_t pag = xfs_get_pag(cred);

    NNPFSDEB(XDEBVNOPS, ("xfs_access mode = 0%o\n", mode));

    error = xfs_attr_valid(vp, cred, p, NNPFS_ATTR_R);
    if (error == 0) {
	struct xfs_node *xn = VNODE_TO_XNODE(vp);
	int i;

	error = check_rights (xn->anonrights, mode);

	if (error == 0)
	    goto done;

	NNPFSDEB(XDEBVNOPS, ("xfs_access anonaccess failed\n"));

	error = EACCES;		/* default to EACCES if pag isn't in xn->id */

	for (i = 0; i < MAXRIGHTS; i++)
	    if (xn->id[i] == pag) {
		error = check_rights (xn->rights[i], mode);
		break;
	    }
    }

done:
    NNPFSDEB(XDEBVNOPS, ("xfs_access(0%o) = %d\n", mode, error));

    return error;
}

int
xfs_lookup_common(struct vnode *dvp, 
		  xfs_componentname *cnp, 
		  struct vnode **vpp)
{
    struct xfs_message_getnode msg;
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
    struct xfs_node *d = VNODE_TO_XNODE(dvp);
    int error = 0;
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *proc  = xfs_cnp_to_thread(cnp);
    struct ucred *cred = xfs_thread_to_cred(proc);
#else
    d_thread_t *proc  = xfs_cnp_to_proc(cnp);
    struct ucred *cred = xfs_proc_to_cred(proc);
#endif

    NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: enter\n"));

    *vpp = NULL;

    if (cnp->cn_namelen >= NNPFS_MAX_NAME)
	return ENAMETOOLONG;
	
    if (dvp->v_type != VDIR)
	return ENOTDIR;

    if (cnp->cn_namelen == 1 && cnp->cn_nameptr[0] == '.') {
	*vpp = dvp;
	VREF(*vpp);
	return 0;
    }
    
    do {
	xfs_vop_access(dvp, VEXEC, cred, proc, error);
	if (error != 0)
	    goto done;

	NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: dvp = %lx\n",
			   (unsigned long) dvp));
	NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: cnp = %lx, "
			   "cnp->cn_nameiop = %d\n", 
			   (unsigned long) cnp, (int)cnp->cn_nameiop));
	

	error = xfs_dnlc_lookup(dvp, cnp, vpp);
	if (error == 0) {

	    /*
	     * Doesn't quite work.
	     */

#if 0
	    if ((cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME)
		&& (cnp->cn_flags & ISLASTCN)) {
		error = EJUSTRETURN;
		goto done;
	    }
#endif

	    msg.header.opcode = NNPFS_MSG_GETNODE;
	    if (cnp->cn_cred != NOCRED) {
		msg.cred.uid = cnp->cn_cred->cr_uid;
		msg.cred.pag = xfs_get_pag(cnp->cn_cred);
	    } else {
		msg.cred.uid = 0;
		msg.cred.pag = NNPFS_ANONYMOUSID;
	    }
	    msg.parent_handle = d->handle;
	    memcpy(msg.name, cnp->cn_nameptr, cnp->cn_namelen);
	    msg.name[cnp->cn_namelen] = '\0';
	    error = xfs_message_rpc(xfsp->fd, &msg.header,
				    sizeof(msg), proc);
	    if (error == 0)
		error = ((struct xfs_message_wakeup *) & msg)->error;
	    if(error == ENOENT && cnp->cn_nameiop != CREATE) {
		NNPFSDEB(XDEBVNOPS, ("xfs_lookup: neg cache %lx (%s, %ld)\n",
				   (unsigned long)dvp,
				   cnp->cn_nameptr, cnp->cn_namelen));
		xfs_dnlc_enter (dvp, cnp, NULL);
	    }
	} else if (error == -1) {
	    error = 0;
	    goto done;
	}
    } while (error == 0);

done:
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: return error = %d\n", error));
    return error;
}

int
xfs_create_common(struct vnode *dvp,
		  const char *name,
		  struct vattr *vap, 
		  struct ucred *cred,
		  d_thread_t *p)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
    struct xfs_node *xn = VNODE_TO_XNODE(dvp);
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_create: (%lx, %s)\n",
		       (unsigned long)dvp, name));
    {
	struct xfs_message_create msg;

	msg.header.opcode = NNPFS_MSG_CREATE;
	msg.parent_handle = xn->handle;
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
	    return ENAMETOOLONG;
	vattr2xfs_attr(vap, &msg.attr);

	msg.mode = 0;		       /* XXX - mode */
	if (cred != NOCRED) {
	    msg.cred.uid = cred->cr_uid;
	    msg.cred.pag = xfs_get_pag(cred);
	} else {
	    msg.cred.uid = 0;
	    msg.cred.pag = NNPFS_ANONYMOUSID;
	}


	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);

	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
    }

#if 0
    if (error == EEXIST)
	error = 0;
#endif

    return error;
}

int
xfs_remove_common(struct vnode *dvp,
		  struct vnode *vp,
		  const char *name,
		  struct ucred *cred,
		  d_thread_t *p)
{
    struct xfs *xfsp  = NNPFS_FROM_VNODE(dvp);
    struct xfs_node *xn = VNODE_TO_XNODE(dvp);
    struct xfs_message_remove msg;
    int error;

    NNPFSDEB(XDEBVNOPS, ("xfs_remove: %s\n", name));

    msg.header.opcode = NNPFS_MSG_REMOVE;
    msg.parent_handle = xn->handle;
    msg.cred.uid = cred->cr_uid;
    msg.cred.pag = xfs_get_pag(cred);
    
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
	error = ENAMETOOLONG;
    else
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
    if (error == 0)
	error = ((struct xfs_message_wakeup *) &msg)->error;

    if (error == 0)
	xfs_dnlc_purge (vp);

    return error;
}

int
xfs_rename_common(struct vnode *fdvp, 
		  struct vnode *fvp,
		  const char *fname,
		  struct vnode *tdvp,
		  struct vnode *tvp,
		  const char *tname,
		  struct ucred *cred,
		  d_thread_t *p)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(fdvp);
    int error;

    NNPFSDEB(XDEBVNOPS, ("xfs_rename: %s %s\n", fname, tname));

    if ((fvp->v_mount != tdvp->v_mount)
	|| (tvp && (fvp->v_mount != tvp->v_mount))) {
	return  EXDEV;
    }

    {
	struct xfs_message_rename msg;

	msg.header.opcode = NNPFS_MSG_RENAME;
	msg.old_parent_handle = VNODE_TO_XNODE(fdvp)->handle;
	if (strlcpy(msg.old_name, fname, sizeof(msg.old_name)) >= NNPFS_MAX_NAME)
	    return ENAMETOOLONG;
	msg.new_parent_handle = VNODE_TO_XNODE(tdvp)->handle;
	if (strlcpy(msg.new_name, tname, sizeof(msg.new_name)) >= NNPFS_MAX_NAME)
	    return ENAMETOOLONG;
	msg.cred.uid = cred->cr_uid;
	msg.cred.pag = xfs_get_pag(cred);
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) &msg)->error;

    }

    NNPFSDEB(XDEBVNOPS, ("xfs_rename: error = %d\n", error));

    return error;
}

int
xfs_mkdir_common(struct vnode *dvp, 
		 const char *name,
		 struct vattr *vap, 
		 struct ucred *cred,
		 d_thread_t *p)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
    struct xfs_node *xn = VNODE_TO_XNODE(dvp);
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_mkdir: %s\n", name));
    {
	struct xfs_message_mkdir msg;

	msg.header.opcode = NNPFS_MSG_MKDIR;
	msg.parent_handle = xn->handle;
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
	    return ENAMETOOLONG;
	vattr2xfs_attr(vap, &msg.attr);
	if (cred != NOCRED) {
	    msg.cred.uid = cred->cr_uid;
	    msg.cred.pag = xfs_get_pag(cred);
	} else {
	    msg.cred.uid = 0;
	    msg.cred.pag = NNPFS_ANONYMOUSID;
	}
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
    }

    return error;
}

int
xfs_rmdir_common(struct vnode *dvp,
		 struct vnode *vp,
		 const char *name,
		 struct ucred *cred,
		 d_thread_t *p)
{
    struct xfs *xfsp  = NNPFS_FROM_VNODE(dvp);
    struct xfs_node *xn = VNODE_TO_XNODE(dvp);
    struct xfs_message_rmdir msg;
    int error;

    NNPFSDEB(XDEBVNOPS, ("xfs_rmdir: %s\n", name));

    msg.header.opcode = NNPFS_MSG_RMDIR;
    msg.parent_handle = xn->handle;
    msg.cred.uid = cred->cr_uid;
    msg.cred.pag = xfs_get_pag(cred);
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
	error = ENAMETOOLONG;
    else
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
    if (error == 0)
	error = ((struct xfs_message_wakeup *) &msg)->error;

    if (error == 0)
	xfs_dnlc_purge (vp);

    NNPFSDEB(XDEBVNOPS, ("xfs_rmdir error: %d\n", error));

    return error;
}

int
xfs_readdir_common(struct vnode *vp, 
		   struct uio *uiop, 
		   struct ucred *cred,
		   d_thread_t *p,
		   int *eofflag)
{
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_readdir\n"));

    if(eofflag)
	*eofflag = 0;
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#endif
    if (error == 0) {
	struct vnode *t = DATA_FROM_VNODE(vp);

#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uiop));
#else
	xfs_vfs_readlock(t, xfs_uio_to_proc(uiop));
#endif
	xfs_vop_read(t, uiop, 0, cred, error);
	if (eofflag) {
	    struct vattr t_attr;
	    int error2;

#ifdef HAVE_FREEBSD_THREAD
	    xfs_vop_getattr(t, &t_attr, cred, xfs_uio_to_thread(uiop), error2);
#else
	    xfs_vop_getattr(t, &t_attr, cred, xfs_uio_to_proc(uiop), error2);
#endif
	    if (error2 == 0)
		*eofflag = t_attr.va_size <= uiop->uio_offset;
	}
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
	xfs_vfs_unlock(t, xfs_uio_to_proc(uiop));
#endif
    }
    return error;
}

int
xfs_link_common(struct vnode *dvp, 
		struct vnode *vp, 
		const char *name,
		struct ucred *cred,
		d_thread_t *p)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
    struct xfs_node *xn = VNODE_TO_XNODE(dvp);
    struct xfs_node *xn2 = VNODE_TO_XNODE(vp);
    struct xfs_message_link msg;
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_link: %s\n", name));
    
    msg.header.opcode = NNPFS_MSG_LINK;
    msg.parent_handle = xn->handle;
    msg.from_handle   = xn2->handle;
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
	return ENAMETOOLONG;
    msg.cred.uid = cred->cr_uid;
    msg.cred.pag = xfs_get_pag(cred);

    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
    if (error == 0)
	error = ((struct xfs_message_wakeup *) & msg)->error;
    
    return error;
}

int
xfs_symlink_common(struct vnode *dvp,
		   struct vnode **vpp,
		   xfs_componentname *cnp,
		   struct vattr *vap,
		   char *target)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
    struct xfs_node *xn = VNODE_TO_XNODE(dvp);
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *proc  = xfs_cnp_to_thread(cnp);
    struct ucred *cred = xfs_thread_to_cred(proc);
#else
    d_thread_t *proc  = xfs_cnp_to_proc(cnp);
    struct ucred *cred = xfs_proc_to_cred(proc);
#endif
    struct xfs_message_symlink *msg = NULL;
    const char *name = cnp->cn_nameptr;
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_symlink: %s\n", name));

    msg = malloc(sizeof(*msg), M_TEMP, M_WAITOK | M_ZERO);
    if (msg == NULL) {
        error = ENOMEM;
	goto done;
    }

    msg->header.opcode = NNPFS_MSG_SYMLINK;
    msg->parent_handle = xn->handle;
    vattr2xfs_attr(vap, &msg->attr);
    msg->cred.uid = cred->cr_uid;
    msg->cred.pag = xfs_get_pag(cred);
    if (strlcpy (msg->contents, target, sizeof(msg->contents)) >= NNPFS_MAX_SYMLINK_CONTENT) {
	error = ENAMETOOLONG;
	goto done;
    }
    if (strlcpy(msg->name, name, sizeof(msg->name)) >= NNPFS_MAX_NAME) {
	error = ENAMETOOLONG;
	goto done;
    }
    error = xfs_message_rpc(xfsp->fd, &msg->header, sizeof(*msg), proc);
    if (error == 0)
	error = ((struct xfs_message_wakeup *) msg)->error;

 done:
    free(msg, M_TEMP);
    return error;
}

int
xfs_readlink_common(struct vnode *vp, struct uio *uiop, struct ucred *cred)
{
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_readlink\n"));

#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#endif
    if (error == 0) {
	struct vnode *t = DATA_FROM_VNODE(vp);

#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uiop));
	xfs_vop_read(t, uiop, 0, cred, error);
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
	xfs_vfs_readlock(t, xfs_uio_to_proc(uiop));
	xfs_vop_read(t, uiop, 0, cred, error);
	xfs_vfs_unlock(t, xfs_uio_to_proc(uiop));
#endif
    }
    return error;
}

int
xfs_inactive_common(struct vnode *vp, d_thread_t *p)
{
    int error;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    NNPFSDEB(XDEBVNOPS, ("xfs_inactive, %lx\n",
		       (unsigned long)vp));

    /*
     * This seems rather bogus, but sometimes we get an already
     * cleaned node to be made inactive.  Just ignoring it seems safe.
     */

    if (xn == NULL) {
	NNPFSDEB(XDEBVNOPS, ("xfs_inactive: clean node\n"));
	return 0;
    }

    /* xn->wr_cred not set -> NOCRED */

    if (vp->v_type == VREG)
	xfs_pushdirty(vp, xn->wr_cred, p);

    error = xfs_fsync_common(vp, xn->wr_cred, /* XXX */ 0, p);
    if (error) {
	printf ("xfs_inactive: failed writing back data: %d\n", error);
	xn->flags &= ~NNPFS_DATA_DIRTY;
    }

    /* If this node is no longer valid, recycle immediately. */
    if (!NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_R | NNPFS_ATTR_W)
	|| (xn->flags & NNPFS_STALE) == NNPFS_STALE)
    {
#ifndef __osf__
	xfs_vfs_unlock(vp, p);
        NNPFSDEB(XDEBVNOPS, ("xfs_inactive: vrecycle\n"));
        vrecycle(vp, p);
#else /* __osf__ */
	NNPFSDEB(XDEBVNOPS, ("xfs_inactive: vp = %lx vp->v_usecount= %d\n",
			     (unsigned long)vp, vp?vp->v_usecount:0));
#endif /* __osf__ */
    } else {
#ifndef __osf__
	xfs_vfs_unlock(vp, p);
#endif
	xn->flags &= ~NNPFS_STALE;
    }

    NNPFSDEB(XDEBVNOPS, ("return: xfs_inactive\n"));

    return 0;
}

int
xfs_reclaim_common(struct vnode *vp)
{
    struct xfs_message_inactivenode msg;
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    NNPFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx\n",
		       (unsigned long)vp));

    NNPFS_TOKEN_CLEAR(xn,
		    ~0,
		    NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
		    NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
    /* Release, data if we still have it. */
    if (DATA_FROM_XNODE(xn) != 0) {
        vrele(DATA_FROM_XNODE(xn));
	DATA_FROM_XNODE(xn) = 0;
    }

    xfs_remove_node(&xfsp->nodehead, xn);

    msg.header.opcode = NNPFS_MSG_INACTIVENODE;
    msg.handle = xn->handle;
    msg.flag   = NNPFS_NOREFS | NNPFS_DELETE;
    xfs_message_send(xfsp->fd, &msg.header, sizeof(msg));

    xfs_dnlc_purge(vp);
    free_xfs_node(xn);
    return 0;
}

/*
 *
 */

#if 0

int
xfs_advlock_common(struct vnode *dvp, 
		   int locktype,
		   unsigned long lockid, /* XXX this good ? */
		   struct ucred *cred)
{
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
    struct xfs_node *xn = VNODE_TO_XNODE(dvp);
    int error = 0;

    NNPFSDEB(XDEBVNOPS, ("xfs_advlock\n"));
    {
	struct xfs_message_advlock msg;

	msg.header.opcode = NNPFS_MSG_ADVLOCK;
	msg.handle = xn->handle;
	msg.locktype = locktype;
	msg.lockid = lockid;

	if (cred != NOCRED) {
	    msg.cred.uid = cred->cr_uid;
	    msg.cred.pag = xfs_get_pag(cred);
	} else {
	    msg.cred.uid = 0;
	    msg.cred.pag = NNPFS_ANONYMOUSID;
	}
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
    }

    if (error == 0) {
	
	/* sleep until woken */

    } else {

	/* die */
    }

    return error;
}

#endif

/*
 *
 */

void
xfs_printnode_common (struct vnode *vp)
{
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    printf ("xnode: fid: %d.%d.%d.%d\n", 
	    xn->handle.a, xn->handle.b, xn->handle.c, xn->handle.d);
    printf ("\tattr: %svalid\n", 
	    NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_VALID) ? "": "in");
    printf ("\tdata: %svalid\n", 
	    NNPFS_TOKEN_GOT(xn, NNPFS_DATA_VALID) ? "": "in");
    printf ("\tflags: 0x%x\n", xn->flags);
    printf ("\toffset: %d\n", xn->offset);
}
@


1.12
log
@More simple memset(,0,) -> M_ZERO changes. In this batch move to
size(*p) as the first malloc() parameter where p is declared locally
and thus easy to check. Add M_ZERO to gpe_table allocation in acpi.c
even though there is no obvious bzero or memset nearby.
@
text
@@


1.11
log
@Remove the simplelock argument from vrecycle();

ok pedro@@, sturm@@
@
text
@d934 1
a934 1
    msg = malloc(sizeof(struct xfs_message_symlink), M_TEMP, M_WAITOK);
a938 1
    memset(msg, 0, sizeof(*msg));
@


1.10
log
@fix worst three kernel stack pigs in xfs by moving stack allocation of
xfs message structures to malloc M_TEMP.
ok art@@
@
text
@d1030 1
a1030 1
        vrecycle(vp, 0, p);
@


1.9
log
@the rest of the '#if DIAGNOSTIC' -> '#ifdef DIAGNOSTIC' in the kernel; ok miod@@
@
text
@d928 1
a928 1
    struct xfs_message_symlink msg;
d934 13
a946 6
    msg.header.opcode = NNPFS_MSG_SYMLINK;
    msg.parent_handle = xn->handle;
    vattr2xfs_attr(vap, &msg.attr);
    msg.cred.uid = cred->cr_uid;
    msg.cred.pag = xfs_get_pag(cred);
    if (strlcpy (msg.contents, target, sizeof(msg.contents)) >= NNPFS_MAX_SYMLINK_CONTENT) {
d950 1
a950 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME) {
d954 1
a954 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), proc);
d956 1
a956 1
	error = ((struct xfs_message_wakeup *) & msg)->error;
d959 1
@


1.8
log
@Fix include stuff, unused variables and statics and other small things needed
to compile in our tree.
@
text
@d301 1
a301 1
#if DIAGNOSTIC
@


1.7
log
@Merge
@
text
@d52 1
d54 1
@


1.6
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d35 1
a35 1
 * XFS operations.
d47 1
a47 1
RCSID("$Id: xfs_vnodeops-common.c,v 1.1.1.1 2002/06/07 03:33:00 hin Exp $");
a51 1
#ifndef __OpenBSD__
a52 1
#endif
d54 1
a54 1
    if ((xn->flags & XFS_STALE) == 0)
d59 5
a63 4
	xn->flags &= ~XFS_STALE;
	XFS_TOKEN_CLEAR(xn, ~0,
			XFS_OPEN_MASK | XFS_ATTR_MASK |
			XFS_DATA_MASK | XFS_LOCK_MASK);
d69 1
a69 1
xfs_open_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
d72 1
a72 1
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
d76 1
a76 1
    XFSDEB(XDEBVFOPS, ("xfs_open_valid\n"));
d81 1
a81 1
	if (!XFS_TOKEN_GOT(xn, tok)) {
d84 1
a84 1
	    msg.header.opcode = XFS_MSG_OPEN;
d100 1
a100 1
    XFSDEB(XDEBVFOPS, ("xfs_open_valid: error = %d\n", error));
d106 1
a106 1
xfs_attr_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
d109 1
a109 1
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
d115 1
a115 1
	if (!XFS_TOKEN_GOT(xn, tok)) {
d118 1
a118 1
	    msg.header.opcode = XFS_MSG_GETATTR;
d135 2
a136 1
xfs_fetch_rights(struct vnode *vp, struct ucred *cred, struct proc *p)
d138 1
a138 1
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
d141 2
a142 2

    xfs_pag_t pag = xfs_get_pag(cred);
d145 10
a154 2
	if (!xfs_has_pag(xn, pag)) {
	    struct xfs_message_getattr msg;
d156 4
a159 9
	    msg.header.opcode = XFS_MSG_GETATTR;
	    msg.cred.uid = cred->cr_uid;
	    msg.cred.pag = pag;
	    msg.handle = xn->handle;
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	    if (error == 0)
		error = ((struct xfs_message_wakeup *) & msg)->error;
	} else {
	    goto done;
a160 1
    } while (error == 0);
d162 12
a173 30
done:

    return error;
}

int
xfs_data_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
	       u_int tok)
{
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    int error = 0;

    do {
	if (!XFS_TOKEN_GOT(xn, tok)) {
	    struct xfs_message_getdata msg;

	    msg.header.opcode = XFS_MSG_GETDATA;
	    msg.cred.uid = cred->cr_uid;
	    msg.cred.pag = xfs_get_pag(cred);
	    msg.handle = xn->handle;
	    msg.tokens = tok;

	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);

	    if (error == 0)
		error = ((struct xfs_message_wakeup *) & msg)->error;
	} else {
	    goto done;
	}
a175 1
done:
d183 1
a183 1
		struct proc *p)
d186 1
d188 1
a188 1
    XFSDEB(XDEBVNOPS, ("xfs_open\n"));
d191 1
a191 5
	if (xn->cred)
	    crfree (xn->cred);
	crhold (cred);
	xn->cred = cred;
	return xfs_open_valid(vp, cred, p, XFS_OPEN_NW);
d193 1
a193 1
	return xfs_open_valid(vp, cred, p, XFS_OPEN_NR);
d195 8
d209 1
a209 1
	 struct proc *p,
a213 5
#if 0
    struct vnode *vp = XNODE_TO_VNODE(xn);
    struct vnode *t  = DATA_FROM_XNODE(xn);

    vinvalbuf (vp, V_SAVE, cred, p, 0, 0);
d215 1
a215 6
    xfs_vfs_writelock(t, p);
    vinvalbuf(t, V_SAVE, cred, p, 0, 0);
    xfs_vfs_unlock(t, p);
#endif

    msg.header.opcode = XFS_MSG_PUTDATA;
d221 1
a221 1
	msg.cred.pag = XFS_ANONYMOUSID;
d233 1
a233 1
	xn->flags &= ~XFS_DATA_DIRTY;
d240 1
a240 1
		 int waitfor, struct proc *proc)
d242 1
a242 1
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
d246 1
a246 1
    XFSDEB(XDEBVNOPS, ("xfs_fsync: %lx\n", (unsigned long)vp));
d254 1
a254 1
	printf("XFS PANIC WARNING! xfs_fsync called after reclaiming!\n");
d258 3
a260 4
#ifdef __APPLE__
    ubc_pushdirty(vp);
#endif
    if (xn->flags & XFS_DATA_DIRTY) {
d265 1
a265 1
	    xn->flags &= ~XFS_DATA_DIRTY;
d269 1
a269 1
	error = do_fsync(xfsp, xn, cred, proc, XFS_WRITE | XFS_FSYNC);
d277 1
a277 1
		 struct proc *proc, struct ucred *cred)
d279 1
a279 1
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
d283 1
a283 1
    XFSDEB(XDEBVNOPS,
d287 5
a291 2
    if (fflag & FWRITE && xn->flags & XFS_DATA_DIRTY)
	error = do_fsync(xfsp, xn, cred, proc, XFS_WRITE);
d296 16
d319 1
a319 1
    XFSDEB(XDEBVNOPS, ("xfs_read\n"));
d321 1
a321 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uio), XFS_DATA_R);
d323 9
a331 1
    XFSDEB(XDEBVNOPS, ("xfs_read: iovcnt: %d\n", uio->uio_iovcnt));
d333 3
a335 3
      XFSDEB(XDEBVNOPS, ("  base: %lx len: %d\n",
			 (unsigned long)uio->uio_iov[i].iov_base,
			 uio->uio_iov[i].iov_len));
d340 5
d348 1
d351 1
a351 1
    XFSDEB(XDEBVNOPS, ("xfs_read offset: %lu resid: %d\n",
d353 2
a354 2
		       uio->uio_resid));
    XFSDEB(XDEBVNOPS, ("xfs_read error: %d\n", error));
d363 1
d366 3
a368 1
    XFSDEB(XDEBVNOPS, ("xfs_write\n"));
d370 7
a376 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_W);
a378 1
	struct xfs_node *xn = VNODE_TO_XNODE(vp);
d383 6
d391 1
a391 1
	VNODE_TO_XNODE(vp)->flags |= XFS_DATA_DIRTY;
d393 1
d397 1
d400 1
d402 3
d406 1
d414 1
a414 1
		   struct ucred *cred, struct proc *p)
d420 1
a420 1
    XFSDEB(XDEBVNOPS, ("xfs_getattr\n"));
d422 1
a422 1
    error = xfs_attr_valid(vp, cred, p, XFS_ATTR_R);
d430 1
a430 1
		   struct ucred *cred, struct proc *p)
d432 1
a432 1
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
d436 1
a436 1
    XFSDEB(XDEBVNOPS, ("xfs_setattr\n"));
d438 9
a446 9
#define CHECK_XFSATTR(A, cast) (vap->A == cast VNOVAL || vap->A == xn->attr.A)
	if (CHECK_XFSATTR(va_mode,(mode_t)) &&
	    CHECK_XFSATTR(va_nlink,(short)) &&
	    CHECK_XFSATTR(va_size,(va_size_t)) &&
	    CHECK_XFSATTR(va_uid,(uid_t)) &&
	    CHECK_XFSATTR(va_gid,(gid_t)) &&
	    CHECK_XFSATTR(va_mtime.tv_sec,(unsigned int)) &&
	    CHECK_XFSATTR(va_fileid,(long)) &&
	    CHECK_XFSATTR(va_type,(enum vtype)))
d448 1
a448 1
#undef CHECK_XFSATTR
d450 1
a450 1
    if (XFS_TOKEN_GOT(xn, XFS_ATTR_W)) {
d452 1
a452 1
	VNODE_TO_XNODE(vp)->flags |= XFS_ATTR_DIRTY;
d458 1
a458 1
	msg.header.opcode = XFS_MSG_PUTATTR;
d464 1
a464 1
	    msg.cred.pag = XFS_ANONYMOUSID;
d468 1
a468 1
	if (XFS_TOKEN_GOT(xn, XFS_DATA_R)) {
d475 1
d486 1
a486 1
	XFS_TOKEN_CLEAR(xn, XFS_ATTR_VALID, XFS_ATTR_MASK);
d502 1
a502 1
	if ((rights & XFS_RIGHT_R) == 0)
d505 1
a505 1
	if ((rights & XFS_RIGHT_W) == 0)
d508 1
a508 1
	if ((rights & XFS_RIGHT_X) == 0)
d515 1
a515 1
		  struct proc *p)
d520 1
a520 1
    XFSDEB(XDEBVNOPS, ("xfs_access mode = 0%o\n", mode));
d522 1
a522 1
    error = xfs_attr_valid(vp, cred, p, XFS_ATTR_R);
d532 1
a532 3
	XFSDEB(XDEBVNOPS, ("xfs_access anonaccess failed\n"));

	xfs_fetch_rights(vp, cred, p); /* ignore error */
d544 1
a544 1
    XFSDEB(XDEBVNOPS, ("xfs_access(0%o) = %d\n", mode, error));
d555 1
a555 1
    struct xfs *xfsp = XFS_FROM_VNODE(dvp);
d558 5
a562 1
    struct proc *proc  = xfs_cnp_to_proc(cnp);
d564 1
d566 1
a566 1
    XFSDEB(XDEBVNOPS, ("xfs_lookup_common: enter\n"));
d570 1
a570 1
    if (cnp->cn_namelen >= XFS_MAX_NAME)
d587 5
a591 1
	XFSDEB(XDEBVNOPS, ("xfs_lookup_common: dvp = %lx\n", (unsigned long) dvp));
d609 1
a609 1
	    msg.header.opcode = XFS_MSG_GETNODE;
d615 1
a615 1
		msg.cred.pag = XFS_ANONYMOUSID;
d625 1
a625 1
		XFSDEB(XDEBVNOPS, ("xfs_lookup: neg cache %lx (%s, %ld)\n",
d637 1
a637 1
    XFSDEB(XDEBVNOPS, ("xfs_lookup_common: return\n"));
d646 1
a646 1
		  struct proc *p)
d648 1
a648 1
    struct xfs *xfsp = XFS_FROM_VNODE(dvp);
d652 1
a652 1
    XFSDEB(XDEBVNOPS, ("xfs_create: (%lx, %s)\n",
d657 1
a657 1
	msg.header.opcode = XFS_MSG_CREATE;
d659 1
a659 1
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
d669 1
a669 1
	    msg.cred.pag = XFS_ANONYMOUSID;
d692 1
a692 1
		  struct proc *p)
d694 1
a694 1
    struct xfs *xfsp  = XFS_FROM_VNODE(dvp);
d699 1
a699 1
    XFSDEB(XDEBVNOPS, ("xfs_remove: %s\n", name));
d701 1
a701 1
    msg.header.opcode = XFS_MSG_REMOVE;
d706 1
a706 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
d727 1
a727 1
		  struct proc *p)
d729 1
a729 1
    struct xfs *xfsp = XFS_FROM_VNODE(fdvp);
d732 1
a732 1
    XFSDEB(XDEBVNOPS, ("xfs_rename: %s %s\n", fname, tname));
d742 1
a742 1
	msg.header.opcode = XFS_MSG_RENAME;
d744 1
a744 1
	if (strlcpy(msg.old_name, fname, sizeof(msg.old_name)) >= XFS_MAX_NAME)
d747 1
a747 1
	if (strlcpy(msg.new_name, tname, sizeof(msg.new_name)) >= XFS_MAX_NAME)
d757 1
a757 1
    XFSDEB(XDEBVNOPS, ("xfs_rename: error = %d\n", error));
d767 1
a767 1
		 struct proc *p)
d769 1
a769 1
    struct xfs *xfsp = XFS_FROM_VNODE(dvp);
d773 1
a773 1
    XFSDEB(XDEBVNOPS, ("xfs_mkdir: %s\n", name));
d777 1
a777 1
	msg.header.opcode = XFS_MSG_MKDIR;
d779 1
a779 1
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
d787 1
a787 1
	    msg.cred.pag = XFS_ANONYMOUSID;
d802 1
a802 1
		 struct proc *p)
d804 1
a804 1
    struct xfs *xfsp  = XFS_FROM_VNODE(dvp);
d809 1
a809 1
    XFSDEB(XDEBVNOPS, ("xfs_rmdir: %s\n", name));
d811 1
a811 1
    msg.header.opcode = XFS_MSG_RMDIR;
d815 1
a815 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
d825 1
a825 1
    XFSDEB(XDEBVNOPS, ("xfs_rmdir error: %d\n", error));
d834 1
a834 1
		   struct proc *p,
d839 1
a839 1
    XFSDEB(XDEBVNOPS, ("xfs_readdir\n"));
d843 7
a849 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_R);
d853 3
d857 1
d863 3
d867 1
d871 3
d875 1
d885 1
a885 1
		struct proc *p)
d887 1
a887 1
    struct xfs *xfsp = XFS_FROM_VNODE(dvp);
d893 1
a893 1
    XFSDEB(XDEBVNOPS, ("xfs_link: %s\n", name));
d895 1
a895 1
    msg.header.opcode = XFS_MSG_LINK;
d898 1
a898 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
d917 1
a917 1
    struct xfs *xfsp = XFS_FROM_VNODE(dvp);
d919 5
a923 1
    struct proc *proc  = xfs_cnp_to_proc(cnp);
d925 1
d930 1
a930 1
    XFSDEB(XDEBVNOPS, ("xfs_symlink: %s\n", name));
d932 1
a932 1
    msg.header.opcode = XFS_MSG_SYMLINK;
d937 1
a937 1
    if (strlcpy (msg.contents, target, sizeof(msg.contents)) >= XFS_MAX_SYMLINK_CONTENT) {
d941 1
a941 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME) {
d958 1
a958 1
    XFSDEB(XDEBVNOPS, ("xfs_readlink\n"));
d960 7
a966 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_R);
d970 5
d978 1
d984 1
a984 1
xfs_inactive_common(struct vnode *vp, struct proc *p)
d989 1
a989 1
    XFSDEB(XDEBVNOPS, ("xfs_inactive, %lx\n",
d998 1
a998 1
	XFSDEB(XDEBVNOPS, ("xfs_inactive: clean node\n"));
d1002 4
a1005 1
    /* xn->cred not set -> NOCRED */
d1007 1
a1007 1
    error = xfs_fsync_common(vp, xn->cred, /* XXX */ 0, p);
d1010 1
a1010 1
	xn->flags &= ~XFS_DATA_DIRTY;
d1013 4
d1018 2
a1019 5
    xfs_vfs_unlock(vp, p);
    /* If this node is no longer valid, recycle immediately. */
    if (!XFS_TOKEN_GOT(xn, XFS_ATTR_R | XFS_ATTR_W)
	|| (xn->flags & XFS_STALE) == XFS_STALE) {
        XFSDEB(XDEBVNOPS, ("xfs_inactive: vrecycle\n"));
d1021 9
a1030 1
#else
d1032 1
a1032 6
    XFSDEB(XDEBVNOPS, ("xfs_inactive: vp = %lx vp->v_usecount= %d\n",
		       (unsigned long)vp, vp?vp->v_usecount:0));
#endif
    xn->flags &= ~XFS_STALE;

    XFSDEB(XDEBVNOPS, ("return: xfs_inactive\n"));
d1041 1
a1041 1
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
d1044 1
a1044 1
    XFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx\n",
d1047 1
a1047 1
    XFS_TOKEN_CLEAR(xn,
d1049 2
a1050 2
		    XFS_OPEN_MASK | XFS_ATTR_MASK |
		    XFS_DATA_MASK | XFS_LOCK_MASK);
d1057 3
a1059 1
    msg.header.opcode = XFS_MSG_INACTIVENODE;
d1061 1
a1061 1
    msg.flag   = XFS_NOREFS | XFS_DELETE;
d1081 1
a1081 1
    struct xfs *xfsp = XFS_FROM_VNODE(dvp);
d1085 1
a1085 1
    XFSDEB(XDEBVNOPS, ("xfs_advlock\n"));
d1089 1
a1089 1
	msg.header.opcode = XFS_MSG_ADVLOCK;
d1099 1
a1099 1
	    msg.cred.pag = XFS_ANONYMOUSID;
d1132 1
a1132 1
	    XFS_TOKEN_GOT(xn, XFS_ATTR_VALID) ? "": "in");
d1134 1
a1134 1
	    XFS_TOKEN_GOT(xn, XFS_DATA_VALID) ? "": "in");
d1136 1
@


1.5
log
@Final __P removal plus some cosmetic fixups
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
d47 21
a67 1
RCSID("$Id: xfs_vnodeops-common.c,v 1.4 2000/09/11 14:26:54 art Exp $");
d79 2
d91 1
a91 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
d123 1
a123 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
d152 1
a152 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
d183 1
a183 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
d249 1
a249 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
d280 3
a338 4

	if (uio->uio_iovcnt && uio->uio_iov[0].iov_len > 0)
	    XFSDEB(XDEBVNOPS, ("xfs_read: byte: %d\n",
			       ((char *)uio->uio_iov[0].iov_base)[0]));
d410 1
a410 1
	    CHECK_XFSATTR(va_size,(u_quad_t)) &&
d439 1
a439 1
		if (vap->va_size != (u_quad_t)VNOVAL)
d443 4
d455 1
a455 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
d531 2
d535 3
d552 3
d579 1
a579 2

	    bcopy(cnp->cn_nameptr, msg.name, cnp->cn_namelen);
d581 2
a582 3

	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));

d598 1
d620 2
a621 1
	strncpy(msg.name, name, 256);
d634 1
a634 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
a663 1
    strncpy(msg.name, name, 256);
d666 5
a670 2

    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
a676 8
#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif
    
d705 2
a706 1
	strncpy(msg.old_name, fname, 256);
d708 2
a709 1
	strncpy(msg.new_name, tname, 256);
d712 1
a712 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
d740 2
a741 1
	strncpy(msg.name, name, 256);
d750 1
a750 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
a773 1
    strncpy(msg.name, name, 256);
d776 4
a779 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
a785 8
#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif

d841 2
a842 1
    strncpy(msg.name, name, 256);
d846 1
a846 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
a871 2
    strncpy(msg.name, name, sizeof(msg.name));
    msg.name[sizeof(msg.name) - 1] = '\0';
d875 9
a883 4
    strncpy (msg.contents, target, sizeof(msg.contents));
    msg.contents[sizeof(msg.contents) - 1] = '\0';

    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
d887 1
a887 12
    if (error == 0) {
	error = xfs_lookup_common(dvp, cnp, vpp);
#if !defined(__FreeBSD__) || __FreeBSD_version < 400012
	if (error == 0)
	    vput (*vpp);
#endif
    }

#if !defined(__FreeBSD__)
    vput(dvp);
#endif

d933 1
d939 2
a940 1
    if (!XFS_TOKEN_GOT(xn, XFS_ATTR_R | XFS_ATTR_W)) {
d945 3
a947 1
    /* XXX ? */
d949 1
d963 1
a963 1
    XFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx",
d1018 1
a1018 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
@


1.4
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d52 1
a52 1
RCSID("$Id: xfs_vnodeops-common.c,v 1.59 2000/08/17 00:38:36 assar Exp $");
d322 1
a322 1
			       ((char*)uio->uio_iov[0].iov_base)[0]));
@


1.4.8.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d52 1
a52 21
RCSID("$Id: xfs_vnodeops-common.c,v 1.4 2000/09/11 14:26:54 art Exp $");

static void
xfs_handle_stale(struct xfs_node *xn)
{
#ifndef __OpenBSD__
    struct vnode *vp = XNODE_TO_VNODE(xn);
#endif

    if ((xn->flags & XFS_STALE) == 0)
	return;

#if __APPLE__
    if (UBCISVALID(vp) && !ubc_isinuse(vp, 1)) {
	xn->flags &= ~XFS_STALE;
	XFS_TOKEN_CLEAR(xn, ~0,
			XFS_OPEN_MASK | XFS_ATTR_MASK |
			XFS_DATA_MASK | XFS_LOCK_MASK);
    }
#endif
}
a63 2
    xfs_handle_stale(xn);

d74 1
a74 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d106 1
a106 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d135 1
a135 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d166 1
a166 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d232 1
a232 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
a262 3
#ifdef __APPLE__
    ubc_pushdirty(vp);
#endif
d319 4
d394 1
a394 1
	    CHECK_XFSATTR(va_size,(va_size_t)) &&
d423 1
a423 1
		if (vap->va_size != (va_size_t)VNOVAL)
a426 4
#ifdef __APPLE__
		if (UBCINFOEXISTS(vp))
		    ubc_setsize(vp, msg.attr.xa_size);
#endif
d435 1
a435 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
a510 2
    XFSDEB(XDEBVNOPS, ("xfs_lookup_common: enter\n"));

a512 3
    if (cnp->cn_namelen >= XFS_MAX_NAME)
	return ENAMETOOLONG;
	
a526 3
	XFSDEB(XDEBVNOPS, ("xfs_lookup_common: dvp = %lx\n", (unsigned long) dvp));
	

d551 2
a552 1
	    memcpy(msg.name, cnp->cn_nameptr, cnp->cn_namelen);
d554 3
a556 2
	    error = xfs_message_rpc(xfsp->fd, &msg.header,
				    sizeof(msg), proc);
a571 1
    XFSDEB(XDEBVNOPS, ("xfs_lookup_common: return\n"));
d593 1
a593 2
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d606 1
a606 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d636 1
d639 2
a640 5
    
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	error = ENAMETOOLONG;
    else
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d647 8
d683 1
a683 2
	if (strlcpy(msg.old_name, fname, sizeof(msg.old_name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d685 1
a685 2
	if (strlcpy(msg.new_name, tname, sizeof(msg.new_name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d688 1
a688 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d716 1
a716 2
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d725 1
a725 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d749 1
d752 1
a752 4
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	error = ENAMETOOLONG;
    else
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d759 8
d822 1
a822 2
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	return ENAMETOOLONG;
d826 1
a826 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d852 2
d857 4
a860 9
    if (strlcpy (msg.contents, target, sizeof(msg.contents)) >= XFS_MAX_SYMLINK_CONTENT) {
	error = ENAMETOOLONG;
	goto done;
    }
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME) {
	error = ENAMETOOLONG;
	goto done;
    }
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), proc);
d864 12
a875 1
 done:
a920 1
	xn->flags &= ~XFS_DATA_DIRTY;
d926 1
a926 2
    if (!XFS_TOKEN_GOT(xn, XFS_ATTR_R | XFS_ATTR_W)
	|| (xn->flags & XFS_STALE) == XFS_STALE) {
d931 1
a931 3

    XFSDEB(XDEBVNOPS, ("xfs_inactive: vp = %lx vp->v_usecount= %d\n",
		       (unsigned long)vp, vp?vp->v_usecount:0));
a932 1
    xn->flags &= ~XFS_STALE;
d946 1
a946 1
    XFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx\n",
d1001 1
a1001 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
@


1.3
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d52 1
a52 1
RCSID("$OpenBSD: xfs_vnodeops-common.c,v 1.2 1999/06/03 19:49:37 art Exp $");
d55 2
a56 1
xfs_open_valid(struct vnode * vp, struct ucred * cred, u_int tok)
d73 1
d75 1
d90 2
a91 1
xfs_attr_valid(struct vnode * vp, struct ucred * cred, u_int tok)
d96 1
a96 1
    pag_t pag = xfs_get_pag(cred);
d119 1
a119 1
xfs_fetch_rights(struct vnode * vp, struct ucred * cred)
d125 1
a125 1
    pag_t pag = xfs_get_pag(cred);
d149 2
a150 1
xfs_data_valid(struct vnode * vp, struct ucred * cred, u_int tok)
d165 1
d167 1
d179 21
d201 4
a204 3
do_fsync(struct xfs * xfsp,
	 struct xfs_node * xn,
	 struct ucred * cred,
d209 10
d233 1
d251 1
a251 1
    XFSDEB(XDEBVNOPS, ("xfs_fsync: %p\n", vp));
d263 11
a273 2
    if (xn->flags & XFS_DATA_DIRTY)
	error = do_fsync(xfsp, xn, cred, XFS_WRITE);
d286 3
a288 1
    XFSDEB(XDEBVNOPS, ("xfs_close cred = %p\n", cred));
d291 1
a291 1
	error = do_fsync(xfsp, xn, cred, XFS_WRITE);
d297 2
a298 1
xfs_read_common(struct vnode *vp, struct uio *uio, int ioflag, struct ucred *cred)
d301 1
d305 7
a311 1
    error = xfs_data_valid(vp, cred, XFS_DATA_R);
d317 1
a317 5
#ifdef __osf__
	VOP_READ(t, uio, ioflag, cred, error);
#else /* __osf__ */
	error = VOP_READ(t, uio, ioflag, cred);
#endif /* __osf__ */
d319 4
d324 6
d334 2
a335 1
xfs_write_common(struct vnode *vp, struct uio *uiop, int ioflag, struct ucred *cred)
d341 1
a341 1
    error = xfs_data_valid(vp, cred, XFS_DATA_W);
d350 1
a350 6
#ifdef __osf__
	VOP_WRITE(t, uiop, ioflag, cred, error);
	VNODE_TO_XNODE(vp)->flags |= XFS_DATA_DIRTY;
	VOP_GETATTR(t, &sub_attr, cred, error2);
#else /* __osf__ */
	error = VOP_WRITE(t, uiop, ioflag, cred);
d352 1
a352 2
	error2 = VOP_GETATTR(t, &sub_attr, cred, uiop->uio_procp);
#endif /* __osf__ */
d357 1
a357 7
#ifdef UVM
	    uvm_vnp_setsize(vp, sub_attr.va_size);
#else
#ifdef HAVE_KERNEL_VNODE_PAGER_SETSIZE
	    vnode_pager_setsize(vp, sub_attr.va_size);
#endif
#endif
d366 2
a367 1
xfs_getattr_common(struct vnode *vp, struct vattr *vap, struct ucred *cred)
d375 1
a375 1
    error = xfs_attr_valid(vp, cred, XFS_ATTR_R);
d382 2
a383 1
xfs_setattr_common(struct vnode *vp, struct vattr *vap, struct ucred *cred)
d393 7
a399 7
	    CHECK_XFSATTR(va_nlink,) &&
	    CHECK_XFSATTR(va_size,) &&
	    CHECK_XFSATTR(va_uid,) &&
	    CHECK_XFSATTR(va_gid,) &&
	    CHECK_XFSATTR(va_mtime.tv_sec,) &&
	    CHECK_XFSATTR(va_fileid,) &&
	    CHECK_XFSATTR(va_type,))
d421 12
d462 2
a463 1
xfs_access_common(struct vnode *vp, int mode, struct ucred *cred)
d466 1
a466 1
    pag_t pag = xfs_get_pag(cred);
d470 1
a470 1
    error = xfs_attr_valid(vp, cred, XFS_ATTR_R);
d482 1
a482 1
	xfs_fetch_rights(vp, cred); /* ignore error */
d515 6
a521 2
 again:

d523 1
a523 5
#ifdef __osf__
	VOP_ACCESS(dvp, VEXEC, cred, error);
#else
	error = VOP_ACCESS(dvp, VEXEC, cred, xfs_cnp_to_proc(cnp));
#endif
d560 2
a561 2
		XFSDEB(XDEBVNOPS, ("xfs_lookup: neg cache %p (%s, %ld)\n",
				   dvp,
a565 2
	    if (xfs_do_vget(*vpp, LK_EXCLUSIVE, xfs_cnp_to_proc(cnp)))
		    goto again;
a575 13
xfs_lookup_name(struct vnode *dvp, 
		const char *name,
		struct proc *proc,
		struct ucred *cred,
		struct vnode **vpp)
{
    xfs_componentname cn;

    xfs_cnp_init (&cn, name, NULL, dvp, proc, cred, CREATE);
    return xfs_lookup_common (dvp, &cn, vpp);
}    

int
d579 2
a580 1
		  struct ucred *cred)
d586 2
a587 1
    XFSDEB(XDEBVNOPS, ("xfs_create: (%s)\n", name));
d605 1
d607 1
d624 2
a625 1
		  struct ucred *cred)
d639 1
d665 2
a666 1
		  struct ucred *cred)
d703 2
a704 1
		 struct ucred *cred)
d737 2
a738 1
		 struct ucred *cred)
d767 2
d776 1
d785 1
a785 1
    error = xfs_data_valid(vp, cred, XFS_DATA_R);
d790 9
a798 7
#ifdef __osf__
	VOP_READ(t, uiop, 0, cred, error);
#else
	error = VOP_READ(t, uiop, 0, cred);
#endif
	if(eofflag)
	    *eofflag = VNODE_TO_XNODE(vp)->attr.va_size <= uiop->uio_offset;
d808 2
a809 1
		struct ucred *cred)
d836 1
a836 3
		   const char *name,
		   struct proc *proc,
		   struct ucred *cred,
d842 2
d845 1
d865 2
a866 1
	error = xfs_lookup_name(dvp, name, proc, cred, vpp);
d869 1
d872 1
a872 1
#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
d886 1
a886 1
    error = xfs_data_valid(vp, cred, XFS_DATA_R);
d891 1
a891 5
#ifdef __osf__
	VOP_READ(t, uiop, 0, cred, error);
#else
	error = VOP_READ(t, uiop, 0, cred);
#endif
d900 1
a900 2
    struct xfs_message_inactivenode msg;
    struct xfs *xfsp = XFS_FROM_VNODE(vp);
d903 2
a904 1
    XFSDEB(XDEBVNOPS, ("xfs_inactive, %p\n", vp));
d916 6
a921 5
    xn->tokens = 0;
    msg.header.opcode = XFS_MSG_INACTIVENODE;
    msg.handle = xn->handle;
    msg.flag   = XFS_NOREFS;
    xfs_message_send(xfsp->fd, &msg.header, sizeof(msg));
d925 5
d946 12
a957 1
    XFSDEB(XDEBVNOPS, ("xfs_reclaim: %p\n", vp));
a965 1

@


1.2
log
@use uvm_vnp_setsize when uvm (workaround)
@
text
@d1 2
d54 1
a54 1
RCSID("$Id: xfs_vnodeops-common.c,v 1.1 1999/04/30 01:59:01 art Exp $");
@


1.2.4.1
log
@Sync with -current
@
text
@a0 2
/*	$OpenBSD$	*/

d52 1
a52 1
RCSID("$OpenBSD$");
@


1.2.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d54 1
a54 1
RCSID("$Id: xfs_vnodeops-common.c,v 1.4 2000/09/11 14:26:54 art Exp $");
d57 1
a57 2
xfs_open_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
	       u_int tok)
a73 1

a74 1

d89 1
a89 2
xfs_attr_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
	       u_int tok)
d94 1
a94 1
    xfs_pag_t pag = xfs_get_pag(cred);
d117 1
a117 1
xfs_fetch_rights(struct vnode *vp, struct ucred *cred, struct proc *p)
d123 1
a123 1
    xfs_pag_t pag = xfs_get_pag(cred);
d147 1
a147 2
xfs_data_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
	       u_int tok)
a161 1

a162 1

a173 21
int
xfs_open_common(struct vnode *vp,
		int mode,
		struct ucred *cred,
		struct proc *p)
{
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    XFSDEB(XDEBVNOPS, ("xfs_open\n"));

    if (mode & FWRITE) {
	if (xn->cred)
	    crfree (xn->cred);
	crhold (cred);
	xn->cred = cred;
	return xfs_open_valid(vp, cred, p, XFS_OPEN_NW);
    } else {
	return xfs_open_valid(vp, cred, p, XFS_OPEN_NR);
    }
}

d175 3
a177 4
do_fsync(struct xfs *xfsp,
	 struct xfs_node *xn,
	 struct ucred *cred,
	 struct proc *p,
a181 10
#if 0
    struct vnode *vp = XNODE_TO_VNODE(xn);
    struct vnode *t  = DATA_FROM_XNODE(xn);

    vinvalbuf (vp, V_SAVE, cred, p, 0, 0);

    xfs_vfs_writelock(t, p);
    vinvalbuf(t, V_SAVE, cred, p, 0, 0);
    xfs_vfs_unlock(t, p);
#endif
a195 1

d213 1
a213 1
    XFSDEB(XDEBVNOPS, ("xfs_fsync: %lx\n", (unsigned long)vp));
d225 2
a226 11
    if (xn->flags & XFS_DATA_DIRTY) {
#ifdef FSYNC_RECLAIM
	/* writing back the data from this vnode failed */
	if (waitfor & FSYNC_RECLAIM) {
	    printf("xfs_fsync: data lost, failed to write back\n");
	    xn->flags &= ~XFS_DATA_DIRTY;
	    return 0;
	}
#endif    
	error = do_fsync(xfsp, xn, cred, proc, XFS_WRITE | XFS_FSYNC);
    }
d239 1
a239 3
    XFSDEB(XDEBVNOPS,
	   ("xfs_close cred = %lx, fflag = %x, xn->flags = %x\n",
	    (unsigned long)cred, fflag, xn->flags));
d242 1
a242 1
	error = do_fsync(xfsp, xn, cred, proc, XFS_WRITE);
d248 1
a248 2
xfs_read_common(struct vnode *vp, struct uio *uio, int ioflag,
		struct ucred *cred)
a250 1
    int i;
d254 1
a254 7
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uio), XFS_DATA_R);

    XFSDEB(XDEBVNOPS, ("xfs_read: iovcnt: %d\n", uio->uio_iovcnt));
    for (i = 0; i < uio->uio_iovcnt; i++)
      XFSDEB(XDEBVNOPS, ("  base: %lx len: %d\n",
			 (unsigned long)uio->uio_iov[i].iov_base,
			 uio->uio_iov[i].iov_len));
d260 5
a264 1
	xfs_vop_read(t, uio, ioflag, cred, error);
a265 4

	if (uio->uio_iovcnt && uio->uio_iov[0].iov_len > 0)
	    XFSDEB(XDEBVNOPS, ("xfs_read: byte: %d\n",
			       ((char*)uio->uio_iov[0].iov_base)[0]));
a266 6

    XFSDEB(XDEBVNOPS, ("xfs_read offset: %lu resid: %d\n",
		       (unsigned long)uio->uio_offset,
		       uio->uio_resid));
    XFSDEB(XDEBVNOPS, ("xfs_read error: %d\n", error));

d271 1
a271 2
xfs_write_common(struct vnode *vp, struct uio *uiop, int ioflag,
		 struct ucred *cred)
d277 1
a277 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_W);
d286 6
a291 1
	xfs_vop_write(t, uiop, ioflag, cred, error);
d293 2
a294 1
	xfs_vop_getattr(t, &sub_attr, cred, xfs_uio_to_proc(uiop), error2);
d299 7
a305 1
	    xfs_set_vp_size(vp, sub_attr.va_size);
d314 1
a314 2
xfs_getattr_common(struct vnode *vp, struct vattr *vap,
		   struct ucred *cred, struct proc *p)
d322 1
a322 1
    error = xfs_attr_valid(vp, cred, p, XFS_ATTR_R);
d329 1
a329 2
xfs_setattr_common(struct vnode *vp, struct vattr *vap,
		   struct ucred *cred, struct proc *p)
d339 7
a345 7
	    CHECK_XFSATTR(va_nlink,(short)) &&
	    CHECK_XFSATTR(va_size,(u_quad_t)) &&
	    CHECK_XFSATTR(va_uid,(uid_t)) &&
	    CHECK_XFSATTR(va_gid,(gid_t)) &&
	    CHECK_XFSATTR(va_mtime.tv_sec,(unsigned int)) &&
	    CHECK_XFSATTR(va_fileid,(long)) &&
	    CHECK_XFSATTR(va_type,(enum vtype)))
a366 12
	if (XFS_TOKEN_GOT(xn, XFS_DATA_R)) {
	    if (vp->v_type == VREG) {
		if (vap->va_size != (u_quad_t)VNOVAL)
		    XA_SET_SIZE(&msg.attr, vap->va_size);
		else
		    XA_SET_SIZE(&msg.attr, xn->attr.va_size);
	    }
	    if (vap->va_mtime.tv_sec != (unsigned int)VNOVAL)
		XA_SET_MTIME(&msg.attr, vap->va_mtime.tv_sec);
	    else
		XA_SET_MTIME(&msg.attr, xn->attr.va_mtime.tv_sec);
	}
d396 1
a396 2
xfs_access_common(struct vnode *vp, int mode, struct ucred *cred,
		  struct proc *p)
d399 1
a399 1
    xfs_pag_t pag = xfs_get_pag(cred);
d403 1
a403 1
    error = xfs_attr_valid(vp, cred, p, XFS_ATTR_R);
d415 1
a415 1
	xfs_fetch_rights(vp, cred, p); /* ignore error */
d448 2
a450 6
    if (cnp->cn_namelen == 1 && cnp->cn_nameptr[0] == '.') {
	*vpp = dvp;
	VREF(*vpp);
	return 0;
    }
    
d452 5
a456 1
	xfs_vop_access(dvp, VEXEC, cred, proc, error);
d493 2
a494 2
		XFSDEB(XDEBVNOPS, ("xfs_lookup: neg cache %lx (%s, %ld)\n",
				   (unsigned long)dvp,
d499 2
d511 13
d527 1
a527 2
		  struct ucred *cred,
		  struct proc *p)
d533 1
a533 2
    XFSDEB(XDEBVNOPS, ("xfs_create: (%lx, %s)\n",
		       (unsigned long)dvp, name));
a550 1

a551 1

d568 1
a568 2
		  struct ucred *cred,
		  struct proc *p)
a581 1

d607 1
a607 2
		  struct ucred *cred,
		  struct proc *p)
d644 1
a644 2
		 struct ucred *cred,
		 struct proc *p)
d677 1
a677 2
		 struct ucred *cred,
		 struct proc *p)
a705 2
    XFSDEB(XDEBVNOPS, ("xfs_rmdir error: %d\n", error));

a712 1
		   struct proc *p,
d721 1
a721 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_R);
d726 7
a732 9
	xfs_vop_read(t, uiop, 0, cred, error);
	if (eofflag) {
	    struct vattr t_attr;
	    int error2;

	    xfs_vop_getattr(t, &t_attr, cred, xfs_uio_to_proc(uiop), error2);
	    if (error2 == 0)
		*eofflag = t_attr.va_size <= uiop->uio_offset;
	}
d742 1
a742 2
		struct ucred *cred,
		struct proc *p)
d769 3
a771 1
		   xfs_componentname *cnp,
a776 2
    struct proc *proc  = xfs_cnp_to_proc(cnp);
    struct ucred *cred = xfs_proc_to_cred(proc);
a777 1
    const char *name = cnp->cn_nameptr;
d797 1
a797 2
	error = xfs_lookup_common(dvp, cnp, vpp);
#if !defined(__FreeBSD__) || __FreeBSD_version < 400012
a799 1
#endif
d802 1
a802 1
#if !defined(__FreeBSD__)
d816 1
a816 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_R);
d821 5
a825 1
	xfs_vop_read(t, uiop, 0, cred, error);
d834 2
a835 1
    int error;
d838 1
a838 2
    XFSDEB(XDEBVNOPS, ("xfs_inactive, %lx\n",
		       (unsigned long)vp));
d850 5
a854 6
    /* xn->cred not set -> NOCRED */

    error = xfs_fsync_common(vp, xn->cred, /* XXX */ 0, p);
    if (error) {
	printf ("xfs_inactive: failed writing back data: %d\n", error);
    }
a857 5
    /* If this node is no longer valid, recycle immediately. */
    if (!XFS_TOKEN_GOT(xn, XFS_ATTR_R | XFS_ATTR_W)) {
        XFSDEB(XDEBVNOPS, ("xfs_inactive: vrecycle\n"));
        vrecycle(vp, 0, p);
    }
d874 1
a874 12
    XFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx",
		       (unsigned long)vp));

    XFS_TOKEN_CLEAR(xn,
		    ~0,
		    XFS_OPEN_MASK | XFS_ATTR_MASK |
		    XFS_DATA_MASK | XFS_LOCK_MASK);
    /* Release, data if we still have it. */
    if (DATA_FROM_XNODE(xn) != 0) {
        vrele(DATA_FROM_XNODE(xn));
	DATA_FROM_XNODE(xn) = 0;
    }
d883 1
@


1.2.4.3
log
@Merge in -current from roughly a week ago
@
text
@d52 1
a52 1
RCSID("$Id$");
d322 1
a322 1
			       ((char *)uio->uio_iov[0].iov_base)[0]));
@


1.2.4.4
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
a53 20
static void
xfs_handle_stale(struct xfs_node *xn)
{
#ifndef __OpenBSD__
    struct vnode *vp = XNODE_TO_VNODE(xn);
#endif

    if ((xn->flags & XFS_STALE) == 0)
	return;

#if __APPLE__
    if (UBCISVALID(vp) && !ubc_isinuse(vp, 1)) {
	xn->flags &= ~XFS_STALE;
	XFS_TOKEN_CLEAR(xn, ~0,
			XFS_OPEN_MASK | XFS_ATTR_MASK |
			XFS_DATA_MASK | XFS_LOCK_MASK);
    }
#endif
}

a63 2
    xfs_handle_stale(xn);

d74 1
a74 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d106 1
a106 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d135 1
a135 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d166 1
a166 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d232 1
a232 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
a262 3
#ifdef __APPLE__
    ubc_pushdirty(vp);
#endif
d319 4
d394 1
a394 1
	    CHECK_XFSATTR(va_size,(va_size_t)) &&
d423 1
a423 1
		if (vap->va_size != (va_size_t)VNOVAL)
a426 4
#ifdef __APPLE__
		if (UBCINFOEXISTS(vp))
		    ubc_setsize(vp, msg.attr.xa_size);
#endif
d435 1
a435 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
a510 2
    XFSDEB(XDEBVNOPS, ("xfs_lookup_common: enter\n"));

a512 3
    if (cnp->cn_namelen >= XFS_MAX_NAME)
	return ENAMETOOLONG;
	
a526 3
	XFSDEB(XDEBVNOPS, ("xfs_lookup_common: dvp = %lx\n", (unsigned long) dvp));
	

d551 2
a552 1
	    memcpy(msg.name, cnp->cn_nameptr, cnp->cn_namelen);
d554 3
a556 2
	    error = xfs_message_rpc(xfsp->fd, &msg.header,
				    sizeof(msg), proc);
a571 1
    XFSDEB(XDEBVNOPS, ("xfs_lookup_common: return\n"));
d593 1
a593 2
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d606 1
a606 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d636 1
d639 2
a640 5
    
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	error = ENAMETOOLONG;
    else
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d647 8
d683 1
a683 2
	if (strlcpy(msg.old_name, fname, sizeof(msg.old_name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d685 1
a685 2
	if (strlcpy(msg.new_name, tname, sizeof(msg.new_name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d688 1
a688 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d716 1
a716 2
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d725 1
a725 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d749 1
d752 1
a752 4
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	error = ENAMETOOLONG;
    else
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d759 8
d822 1
a822 2
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	return ENAMETOOLONG;
d826 1
a826 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d852 2
d857 4
a860 9
    if (strlcpy (msg.contents, target, sizeof(msg.contents)) >= XFS_MAX_SYMLINK_CONTENT) {
	error = ENAMETOOLONG;
	goto done;
    }
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME) {
	error = ENAMETOOLONG;
	goto done;
    }
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), proc);
d864 12
a875 1
 done:
a920 1
	xn->flags &= ~XFS_DATA_DIRTY;
d926 1
a926 2
    if (!XFS_TOKEN_GOT(xn, XFS_ATTR_R | XFS_ATTR_W)
	|| (xn->flags & XFS_STALE) == XFS_STALE) {
d931 1
a931 3

    XFSDEB(XDEBVNOPS, ("xfs_inactive: vp = %lx vp->v_usecount= %d\n",
		       (unsigned long)vp, vp?vp->v_usecount:0));
a932 1
    xn->flags &= ~XFS_STALE;
d946 1
a946 1
    XFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx\n",
d1001 1
a1001 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
@


1.2.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d35 1
a35 1
 * NNPFS operations.
d47 1
a47 1
RCSID("$arla: xfs_vnodeops-common.c,v 1.94 2003/01/27 11:58:50 lha Exp $");
d52 1
a52 1
#if __APPLE__
d56 1
a56 1
    if ((xn->flags & NNPFS_STALE) == 0)
d61 4
a64 5
	xn->flags &= ~NNPFS_STALE;
	ubc_setsize(vp, 0);
	NNPFS_TOKEN_CLEAR(xn, ~0,
			NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
			NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
d70 1
a70 1
xfs_open_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
d73 1
a73 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d77 1
a77 1
    NNPFSDEB(XDEBVFOPS, ("xfs_open_valid\n"));
d82 1
a82 1
	if (!NNPFS_TOKEN_GOT(xn, tok)) {
d85 1
a85 1
	    msg.header.opcode = NNPFS_MSG_OPEN;
d101 1
a101 1
    NNPFSDEB(XDEBVFOPS, ("xfs_open_valid: error = %d\n", error));
d107 1
a107 1
xfs_attr_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
d110 1
a110 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d116 1
a116 1
	if (!NNPFS_TOKEN_GOT(xn, tok) || !xfs_has_pag(xn, pag)) {
d119 1
a119 1
	    msg.header.opcode = NNPFS_MSG_GETATTR;
d136 1
a136 2
xfs_data_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
	       u_int tok, uint32_t want_offset)
d138 1
a138 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d141 2
a142 2
    uint32_t offset;
    struct xfs_message_getdata msg;
d145 12
a156 3
	offset = want_offset;
	if (NNPFS_TOKEN_GOT(xn, tok|NNPFS_ATTR_R) && offset > xn->attr.va_size) {
	    offset = xn->attr.va_size;
d158 26
a183 6
    
	NNPFSDEB(XDEBVNOPS, ("xfs_data_valid: offset: want %ld has %ld, "
			   "tokens: want %lx has %lx length: %ld\n",
			   (long) offset, (long) xn->offset,
			   (long) tok, (long) xn->tokens,
			   (long) xn->attr.va_size));
d185 4
a188 4
	if (NNPFS_TOKEN_GOT(xn, tok)) {
	    if (offset <= xn->offset || xn->attr.va_type == VDIR) {
		break;
	    }
a189 13

	msg.header.opcode = NNPFS_MSG_GETDATA;
	msg.cred.uid = cred->cr_uid;
	msg.cred.pag = xfs_get_pag(cred);
	msg.handle = xn->handle;
	msg.tokens = tok;
	msg.offset = offset;
	
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
	
d192 1
d200 1
a200 1
		d_thread_t *p)
a202 1
    int ret;
d204 1
a204 1
    NNPFSDEB(XDEBVNOPS, ("xfs_open\n"));
d207 5
a211 1
	ret = xfs_open_valid(vp, cred, p, NNPFS_OPEN_NW);
d213 1
a213 1
	ret = xfs_open_valid(vp, cred, p, NNPFS_OPEN_NR);
a214 8

    /* always update the read cred */

    if (mode & FWRITE)
	xfs_update_write_cred(xn, cred);
    xfs_update_read_cred(xn, cred);

    return ret;
d221 1
a221 1
	 d_thread_t *p,
d226 5
d232 6
a237 1
    msg.header.opcode = NNPFS_MSG_PUTDATA;
d243 1
a243 1
	msg.cred.pag = NNPFS_ANONYMOUSID;
d255 1
a255 1
	xn->flags &= ~NNPFS_DATA_DIRTY;
d262 1
a262 1
		 int waitfor, d_thread_t *proc)
d264 1
a264 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d268 1
a268 1
    NNPFSDEB(XDEBVNOPS, ("xfs_fsync: %lx\n", (unsigned long)vp));
d276 1
a276 1
	printf("NNPFS PANIC WARNING! xfs_fsync called after reclaiming!\n");
d280 4
a283 3
    xfs_pushdirty(vp, cred, proc);

    if (xn->flags & NNPFS_DATA_DIRTY) {
d288 1
a288 1
	    xn->flags &= ~NNPFS_DATA_DIRTY;
d292 1
a292 1
	error = do_fsync(xfsp, xn, cred, proc, NNPFS_WRITE | NNPFS_FSYNC);
d300 1
a300 1
		 d_thread_t *proc, struct ucred *cred)
d302 1
a302 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d306 1
a306 1
    NNPFSDEB(XDEBVNOPS,
d310 2
a311 5
    if (vp->v_type == VREG)
	xfs_pushdirty(vp, cred, proc);

    if (fflag & FWRITE && xn->flags & NNPFS_DATA_DIRTY)
	error = do_fsync(xfsp, xn, cred, proc, NNPFS_WRITE);
a315 16
size_t
xfs_uio_end_length (struct uio *uio)
{
#if DIAGNOSTIC
    size_t sz = 0;
    int i;

    for (i = 0; i < uio->uio_iovcnt; i++)
	sz += uio->uio_iov[i].iov_len;
    if (sz != uio->uio_resid)
	panic("xfs_uio_end_length");
#endif
    return uio->uio_offset + uio->uio_resid;
}


d323 1
a323 1
    NNPFSDEB(XDEBVNOPS, ("xfs_read\n"));
d325 1
a325 1
    xfs_update_read_cred(VNODE_TO_XNODE(vp), cred);
d327 1
a327 9
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uio), NNPFS_DATA_R,
			   xfs_uio_end_length(uio));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uio), NNPFS_DATA_R,
			   xfs_uio_end_length(uio));
#endif

    NNPFSDEB(XDEBVNOPS, ("xfs_read: iovcnt: %d\n", uio->uio_iovcnt));
d329 3
a331 3
	NNPFSDEB(XDEBVNOPS, ("  base: %lx len: %lu\n",
			   (unsigned long)uio->uio_iov[i].iov_base,
			   (unsigned long)uio->uio_iov[i].iov_len));
a335 5
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uio));
	xfs_vop_read(t, uio, ioflag, cred, error);
	xfs_vfs_unlock(t, xfs_uio_to_thread(uio));
#else
a338 1
#endif
d341 1
a341 1
    NNPFSDEB(XDEBVNOPS, ("xfs_read offset: %lu resid: %lu\n",
d343 2
a344 2
		       (unsigned long)uio->uio_resid));
    NNPFSDEB(XDEBVNOPS, ("xfs_read error: %d\n", error));
a352 1
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
d355 1
a355 3
    NNPFSDEB(XDEBVNOPS, ("xfs_write\n"));

    xfs_update_write_cred(xn, cred);
d357 1
a357 7
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_W,
			   VNODE_TO_XNODE(vp)->attr.va_size);
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_W,
			   VNODE_TO_XNODE(vp)->attr.va_size);
#endif
d360 1
a364 6
 #ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_writelock(t, xfs_uio_to_thread(uiop));
	xfs_vop_write(t, uiop, ioflag, cred, error);
	VNODE_TO_XNODE(vp)->flags |= NNPFS_DATA_DIRTY;
	xfs_vop_getattr(t, &sub_attr, cred, xfs_uio_to_thread(uiop), error2);
 #else
d367 1
a367 1
	VNODE_TO_XNODE(vp)->flags |= NNPFS_DATA_DIRTY;
a368 1
 #endif
a371 1
	    xn->attr.va_bytes = sub_attr.va_size;
a373 1
	    xn->offset = sub_attr.va_size;
a374 3
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
a375 1
#endif
d383 1
a383 1
		   struct ucred *cred, d_thread_t *p)
d389 1
a389 1
    NNPFSDEB(XDEBVNOPS, ("xfs_getattr\n"));
d391 1
a391 1
    error = xfs_attr_valid(vp, cred, p, NNPFS_ATTR_R);
d399 1
a399 1
		   struct ucred *cred, d_thread_t *p)
d401 1
a401 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d405 1
a405 1
    NNPFSDEB(XDEBVNOPS, ("xfs_setattr\n"));
d407 9
a415 9
#define CHECK_NNPFSATTR(A, cast) (vap->A == cast VNOVAL || vap->A == xn->attr.A)
	if (CHECK_NNPFSATTR(va_mode,(mode_t)) &&
	    CHECK_NNPFSATTR(va_nlink,(short)) &&
	    CHECK_NNPFSATTR(va_size,(va_size_t)) &&
	    CHECK_NNPFSATTR(va_uid,(uid_t)) &&
	    CHECK_NNPFSATTR(va_gid,(gid_t)) &&
	    CHECK_NNPFSATTR(va_mtime.tv_sec,(unsigned int)) &&
	    CHECK_NNPFSATTR(va_fileid,(long)) &&
	    CHECK_NNPFSATTR(va_type,(enum vtype)))
d417 1
a417 1
#undef CHECK_NNPFSATTR
d419 1
a419 1
    if (NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_W)) {
d421 1
a421 1
	VNODE_TO_XNODE(vp)->flags |= NNPFS_ATTR_DIRTY;
d427 1
a427 1
	msg.header.opcode = NNPFS_MSG_PUTATTR;
d433 1
a433 1
	    msg.cred.pag = NNPFS_ANONYMOUSID;
d437 1
a437 1
	if (NNPFS_TOKEN_GOT(xn, NNPFS_DATA_R)) {
a443 1
		/* XXX needed ? */
d454 1
a454 1
	NNPFS_TOKEN_CLEAR(xn, NNPFS_ATTR_VALID, NNPFS_ATTR_MASK);
d470 1
a470 1
	if ((rights & NNPFS_RIGHT_R) == 0)
d473 1
a473 1
	if ((rights & NNPFS_RIGHT_W) == 0)
d476 1
a476 1
	if ((rights & NNPFS_RIGHT_X) == 0)
d483 1
a483 1
		  d_thread_t *p)
d488 1
a488 1
    NNPFSDEB(XDEBVNOPS, ("xfs_access mode = 0%o\n", mode));
d490 1
a490 1
    error = xfs_attr_valid(vp, cred, p, NNPFS_ATTR_R);
d500 3
a502 1
	NNPFSDEB(XDEBVNOPS, ("xfs_access anonaccess failed\n"));
d514 1
a514 1
    NNPFSDEB(XDEBVNOPS, ("xfs_access(0%o) = %d\n", mode, error));
d525 1
a525 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d528 1
a528 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *proc  = xfs_cnp_to_thread(cnp);
    struct ucred *cred = xfs_thread_to_cred(proc);
#else
    d_thread_t *proc  = xfs_cnp_to_proc(cnp);
a529 1
#endif
d531 1
a531 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: enter\n"));
d535 1
a535 1
    if (cnp->cn_namelen >= NNPFS_MAX_NAME)
d552 1
a552 5
	NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: dvp = %lx\n",
			   (unsigned long) dvp));
	NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: cnp = %lx, "
			   "cnp->cn_nameiop = %d\n", 
			   (unsigned long) cnp, (int)cnp->cn_nameiop));
d570 1
a570 1
	    msg.header.opcode = NNPFS_MSG_GETNODE;
d576 1
a576 1
		msg.cred.pag = NNPFS_ANONYMOUSID;
d586 1
a586 1
		NNPFSDEB(XDEBVNOPS, ("xfs_lookup: neg cache %lx (%s, %ld)\n",
d598 1
a598 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: return error = %d\n", error));
d607 1
a607 1
		  d_thread_t *p)
d609 1
a609 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d613 1
a613 1
    NNPFSDEB(XDEBVNOPS, ("xfs_create: (%lx, %s)\n",
d618 1
a618 1
	msg.header.opcode = NNPFS_MSG_CREATE;
d620 1
a620 1
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d630 1
a630 1
	    msg.cred.pag = NNPFS_ANONYMOUSID;
d653 1
a653 1
		  d_thread_t *p)
d655 1
a655 1
    struct xfs *xfsp  = NNPFS_FROM_VNODE(dvp);
d660 1
a660 1
    NNPFSDEB(XDEBVNOPS, ("xfs_remove: %s\n", name));
d662 1
a662 1
    msg.header.opcode = NNPFS_MSG_REMOVE;
d667 1
a667 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d688 1
a688 1
		  d_thread_t *p)
d690 1
a690 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(fdvp);
d693 1
a693 1
    NNPFSDEB(XDEBVNOPS, ("xfs_rename: %s %s\n", fname, tname));
d703 1
a703 1
	msg.header.opcode = NNPFS_MSG_RENAME;
d705 1
a705 1
	if (strlcpy(msg.old_name, fname, sizeof(msg.old_name)) >= NNPFS_MAX_NAME)
d708 1
a708 1
	if (strlcpy(msg.new_name, tname, sizeof(msg.new_name)) >= NNPFS_MAX_NAME)
d718 1
a718 1
    NNPFSDEB(XDEBVNOPS, ("xfs_rename: error = %d\n", error));
d728 1
a728 1
		 d_thread_t *p)
d730 1
a730 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d734 1
a734 1
    NNPFSDEB(XDEBVNOPS, ("xfs_mkdir: %s\n", name));
d738 1
a738 1
	msg.header.opcode = NNPFS_MSG_MKDIR;
d740 1
a740 1
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d748 1
a748 1
	    msg.cred.pag = NNPFS_ANONYMOUSID;
d763 1
a763 1
		 d_thread_t *p)
d765 1
a765 1
    struct xfs *xfsp  = NNPFS_FROM_VNODE(dvp);
d770 1
a770 1
    NNPFSDEB(XDEBVNOPS, ("xfs_rmdir: %s\n", name));
d772 1
a772 1
    msg.header.opcode = NNPFS_MSG_RMDIR;
d776 1
a776 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d786 1
a786 1
    NNPFSDEB(XDEBVNOPS, ("xfs_rmdir error: %d\n", error));
d795 1
a795 1
		   d_thread_t *p,
d800 1
a800 1
    NNPFSDEB(XDEBVNOPS, ("xfs_readdir\n"));
d804 1
a804 7
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#endif
a807 3
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uiop));
#else
a808 1
#endif
a813 3
#ifdef HAVE_FREEBSD_THREAD
	    xfs_vop_getattr(t, &t_attr, cred, xfs_uio_to_thread(uiop), error2);
#else
a814 1
#endif
a817 3
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
a818 1
#endif
d828 1
a828 1
		d_thread_t *p)
d830 1
a830 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d836 1
a836 1
    NNPFSDEB(XDEBVNOPS, ("xfs_link: %s\n", name));
d838 1
a838 1
    msg.header.opcode = NNPFS_MSG_LINK;
d841 1
a841 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d860 1
a860 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d862 1
a862 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *proc  = xfs_cnp_to_thread(cnp);
    struct ucred *cred = xfs_thread_to_cred(proc);
#else
    d_thread_t *proc  = xfs_cnp_to_proc(cnp);
a863 1
#endif
d868 1
a868 1
    NNPFSDEB(XDEBVNOPS, ("xfs_symlink: %s\n", name));
d870 1
a870 1
    msg.header.opcode = NNPFS_MSG_SYMLINK;
d875 1
a875 1
    if (strlcpy (msg.contents, target, sizeof(msg.contents)) >= NNPFS_MAX_SYMLINK_CONTENT) {
d879 1
a879 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME) {
d896 1
a896 1
    NNPFSDEB(XDEBVNOPS, ("xfs_readlink\n"));
d898 1
a898 7
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#endif
a901 5
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uiop));
	xfs_vop_read(t, uiop, 0, cred, error);
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
a904 1
#endif
d910 1
a910 1
xfs_inactive_common(struct vnode *vp, d_thread_t *p)
d915 1
a915 1
    NNPFSDEB(XDEBVNOPS, ("xfs_inactive, %lx\n",
d924 1
a924 1
	NNPFSDEB(XDEBVNOPS, ("xfs_inactive: clean node\n"));
d928 1
a928 4
    /* xn->wr_cred not set -> NOCRED */

    if (vp->v_type == VREG)
	xfs_pushdirty(vp, xn->wr_cred, p);
d930 1
a930 1
    error = xfs_fsync_common(vp, xn->wr_cred, /* XXX */ 0, p);
d933 1
a933 1
	xn->flags &= ~NNPFS_DATA_DIRTY;
d936 2
d939 3
a941 6
    if (!NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_R | NNPFS_ATTR_W)
	|| (xn->flags & NNPFS_STALE) == NNPFS_STALE)
    {
#ifndef __osf__
	xfs_vfs_unlock(vp, p);
        NNPFSDEB(XDEBVNOPS, ("xfs_inactive: vrecycle\n"));
d943 5
a947 7
#else /* __osf__ */
	NNPFSDEB(XDEBVNOPS, ("xfs_inactive: vp = %lx vp->v_usecount= %d\n",
			     (unsigned long)vp, vp?vp->v_usecount:0));
#endif /* __osf__ */
    } else {
#ifndef __osf__
	xfs_vfs_unlock(vp, p);
d949 1
a949 2
	xn->flags &= ~NNPFS_STALE;
    }
d951 1
a951 1
    NNPFSDEB(XDEBVNOPS, ("return: xfs_inactive\n"));
d960 1
a960 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d963 1
a963 1
    NNPFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx\n",
d966 1
a966 1
    NNPFS_TOKEN_CLEAR(xn,
d968 2
a969 2
		    NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
		    NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
d976 1
a976 3
    xfs_remove_node(&xfsp->nodehead, xn);

    msg.header.opcode = NNPFS_MSG_INACTIVENODE;
d978 1
a978 1
    msg.flag   = NNPFS_NOREFS | NNPFS_DELETE;
d998 1
a998 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d1002 1
a1002 1
    NNPFSDEB(XDEBVNOPS, ("xfs_advlock\n"));
d1006 1
a1006 1
	msg.header.opcode = NNPFS_MSG_ADVLOCK;
d1016 1
a1016 1
	    msg.cred.pag = NNPFS_ANONYMOUSID;
d1049 1
a1049 1
	    NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_VALID) ? "": "in");
d1051 1
a1051 1
	    NNPFS_TOKEN_GOT(xn, NNPFS_DATA_VALID) ? "": "in");
a1052 1
    printf ("\toffset: %d\n", xn->offset);
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d52 1
a52 1
RCSID("$Id: xfs_vnodeops-common.c,v 1.31 1999/03/19 04:53:22 lha Exp $");
d297 3
d302 1
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d52 1
a52 21
RCSID("$Id: xfs_vnodeops-common.c,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $");

static void
xfs_handle_stale(struct xfs_node *xn)
{
#ifndef __OpenBSD__
    struct vnode *vp = XNODE_TO_VNODE(xn);
#endif

    if ((xn->flags & XFS_STALE) == 0)
	return;

#if __APPLE__
    if (UBCISVALID(vp) && !ubc_isinuse(vp, 1)) {
	xn->flags &= ~XFS_STALE;
	XFS_TOKEN_CLEAR(xn, ~0,
			XFS_OPEN_MASK | XFS_ATTR_MASK |
			XFS_DATA_MASK | XFS_LOCK_MASK);
    }
#endif
}
d55 1
a55 2
xfs_open_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
	       u_int tok)
a62 2
    xfs_handle_stale(xn);

d72 1
a72 3

	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);

d87 1
a87 2
xfs_attr_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
	       u_int tok)
d92 1
a92 1
    xfs_pag_t pag = xfs_get_pag(cred);
d102 1
a102 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d115 1
a115 1
xfs_fetch_rights(struct vnode *vp, struct ucred *cred, struct proc *p)
d121 1
a121 1
    xfs_pag_t pag = xfs_get_pag(cred);
d131 1
a131 1
	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d145 1
a145 2
xfs_data_valid(struct vnode *vp, struct ucred *cred, struct proc *p,
	       u_int tok)
d160 1
a160 3

	    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);

a171 21
int
xfs_open_common(struct vnode *vp,
		int mode,
		struct ucred *cred,
		struct proc *p)
{
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    XFSDEB(XDEBVNOPS, ("xfs_open\n"));

    if (mode & FWRITE) {
	if (xn->cred)
	    crfree (xn->cred);
	crhold (cred);
	xn->cred = cred;
	return xfs_open_valid(vp, cred, p, XFS_OPEN_NW);
    } else {
	return xfs_open_valid(vp, cred, p, XFS_OPEN_NR);
    }
}

d173 3
a175 4
do_fsync(struct xfs *xfsp,
	 struct xfs_node *xn,
	 struct ucred *cred,
	 struct proc *p,
a179 10
#if 0
    struct vnode *vp = XNODE_TO_VNODE(xn);
    struct vnode *t  = DATA_FROM_XNODE(xn);

    vinvalbuf (vp, V_SAVE, cred, p, 0, 0);

    xfs_vfs_writelock(t, p);
    vinvalbuf(t, V_SAVE, cred, p, 0, 0);
    xfs_vfs_unlock(t, p);
#endif
d193 1
a193 2
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);

d211 1
a211 1
    XFSDEB(XDEBVNOPS, ("xfs_fsync: %lx\n", (unsigned long)vp));
d223 2
a224 14
#ifdef __APPLE__
    ubc_pushdirty(vp);
#endif
    if (xn->flags & XFS_DATA_DIRTY) {
#ifdef FSYNC_RECLAIM
	/* writing back the data from this vnode failed */
	if (waitfor & FSYNC_RECLAIM) {
	    printf("xfs_fsync: data lost, failed to write back\n");
	    xn->flags &= ~XFS_DATA_DIRTY;
	    return 0;
	}
#endif    
	error = do_fsync(xfsp, xn, cred, proc, XFS_WRITE | XFS_FSYNC);
    }
d237 1
a237 3
    XFSDEB(XDEBVNOPS,
	   ("xfs_close cred = %lx, fflag = %x, xn->flags = %x\n",
	    (unsigned long)cred, fflag, xn->flags));
d240 1
a240 1
	error = do_fsync(xfsp, xn, cred, proc, XFS_WRITE);
d246 1
a246 2
xfs_read_common(struct vnode *vp, struct uio *uio, int ioflag,
		struct ucred *cred)
a248 1
    int i;
d252 1
a252 7
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uio), XFS_DATA_R);

    XFSDEB(XDEBVNOPS, ("xfs_read: iovcnt: %d\n", uio->uio_iovcnt));
    for (i = 0; i < uio->uio_iovcnt; i++)
      XFSDEB(XDEBVNOPS, ("  base: %lx len: %d\n",
			 (unsigned long)uio->uio_iov[i].iov_base,
			 uio->uio_iov[i].iov_len));
d258 5
a262 1
	xfs_vop_read(t, uio, ioflag, cred, error);
a264 6

    XFSDEB(XDEBVNOPS, ("xfs_read offset: %lu resid: %d\n",
		       (unsigned long)uio->uio_offset,
		       uio->uio_resid));
    XFSDEB(XDEBVNOPS, ("xfs_read error: %d\n", error));

d269 1
a269 2
xfs_write_common(struct vnode *vp, struct uio *uiop, int ioflag,
		 struct ucred *cred)
d275 1
a275 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_W);
d284 2
a285 1
	xfs_vop_write(t, uiop, ioflag, cred, error);
d287 6
a292 1
	xfs_vop_getattr(t, &sub_attr, cred, xfs_uio_to_proc(uiop), error2);
d297 3
a299 1
	    xfs_set_vp_size(vp, sub_attr.va_size);
d308 1
a308 2
xfs_getattr_common(struct vnode *vp, struct vattr *vap,
		   struct ucred *cred, struct proc *p)
d316 1
a316 1
    error = xfs_attr_valid(vp, cred, p, XFS_ATTR_R);
d323 1
a323 2
xfs_setattr_common(struct vnode *vp, struct vattr *vap,
		   struct ucred *cred, struct proc *p)
d333 7
a339 7
	    CHECK_XFSATTR(va_nlink,(short)) &&
	    CHECK_XFSATTR(va_size,(va_size_t)) &&
	    CHECK_XFSATTR(va_uid,(uid_t)) &&
	    CHECK_XFSATTR(va_gid,(gid_t)) &&
	    CHECK_XFSATTR(va_mtime.tv_sec,(unsigned int)) &&
	    CHECK_XFSATTR(va_fileid,(long)) &&
	    CHECK_XFSATTR(va_type,(enum vtype)))
a360 16
	if (XFS_TOKEN_GOT(xn, XFS_DATA_R)) {
	    if (vp->v_type == VREG) {
		if (vap->va_size != (va_size_t)VNOVAL)
		    XA_SET_SIZE(&msg.attr, vap->va_size);
		else
		    XA_SET_SIZE(&msg.attr, xn->attr.va_size);
#ifdef __APPLE__
		if (UBCINFOEXISTS(vp))
		    ubc_setsize(vp, msg.attr.xa_size);
#endif
	    }
	    if (vap->va_mtime.tv_sec != (unsigned int)VNOVAL)
		XA_SET_MTIME(&msg.attr, vap->va_mtime.tv_sec);
	    else
		XA_SET_MTIME(&msg.attr, xn->attr.va_mtime.tv_sec);
	}
d363 1
a363 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d390 1
a390 2
xfs_access_common(struct vnode *vp, int mode, struct ucred *cred,
		  struct proc *p)
d393 1
a393 1
    xfs_pag_t pag = xfs_get_pag(cred);
d397 1
a397 1
    error = xfs_attr_valid(vp, cred, p, XFS_ATTR_R);
d409 1
a409 1
	xfs_fetch_rights(vp, cred, p); /* ignore error */
a437 2
    XFSDEB(XDEBVNOPS, ("xfs_lookup_common: enter\n"));

a439 3
    if (cnp->cn_namelen >= XFS_MAX_NAME)
	return ENAMETOOLONG;
	
d442 2
a444 6
    if (cnp->cn_namelen == 1 && cnp->cn_nameptr[0] == '.') {
	*vpp = dvp;
	VREF(*vpp);
	return 0;
    }
    
d446 5
a450 1
	xfs_vop_access(dvp, VEXEC, cred, proc, error);
a453 3
	XFSDEB(XDEBVNOPS, ("xfs_lookup_common: dvp = %lx\n", (unsigned long) dvp));
	

d478 2
a479 1
	    memcpy(msg.name, cnp->cn_nameptr, cnp->cn_namelen);
d481 3
a483 2
	    error = xfs_message_rpc(xfsp->fd, &msg.header,
				    sizeof(msg), proc);
d487 2
a488 2
		XFSDEB(XDEBVNOPS, ("xfs_lookup: neg cache %lx (%s, %ld)\n",
				   (unsigned long)dvp,
d493 2
a500 1
    XFSDEB(XDEBVNOPS, ("xfs_lookup_common: return\n"));
d505 13
d521 1
a521 2
		  struct ucred *cred,
		  struct proc *p)
d527 1
a527 2
    XFSDEB(XDEBVNOPS, ("xfs_create: (%lx, %s)\n",
		       (unsigned long)dvp, name));
d533 1
a533 2
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d545 1
a545 3

	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);

d562 1
a562 2
		  struct ucred *cred,
		  struct proc *p)
d573 1
d576 1
a576 5
    
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	error = ENAMETOOLONG;
    else
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d583 8
d601 1
a601 2
		  struct ucred *cred,
		  struct proc *p)
d618 1
a618 2
	if (strlcpy(msg.old_name, fname, sizeof(msg.old_name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d620 1
a620 2
	if (strlcpy(msg.new_name, tname, sizeof(msg.new_name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d623 1
a623 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d638 1
a638 2
		 struct ucred *cred,
		 struct proc *p)
d650 1
a650 2
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	    return ENAMETOOLONG;
d659 1
a659 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d671 1
a671 2
		 struct ucred *cred,
		 struct proc *p)
d682 1
d685 1
a685 4
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	error = ENAMETOOLONG;
    else
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d692 7
a698 1
    XFSDEB(XDEBVNOPS, ("xfs_rmdir error: %d\n", error));
a706 1
		   struct proc *p,
d715 1
a715 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_R);
d720 7
a726 9
	xfs_vop_read(t, uiop, 0, cred, error);
	if (eofflag) {
	    struct vattr t_attr;
	    int error2;

	    xfs_vop_getattr(t, &t_attr, cred, xfs_uio_to_proc(uiop), error2);
	    if (error2 == 0)
		*eofflag = t_attr.va_size <= uiop->uio_offset;
	}
d736 1
a736 2
		struct ucred *cred,
		struct proc *p)
d749 1
a749 2
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME)
	return ENAMETOOLONG;
d753 1
a753 1
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
d763 3
a765 1
		   xfs_componentname *cnp,
a770 2
    struct proc *proc  = xfs_cnp_to_proc(cnp);
    struct ucred *cred = xfs_proc_to_cred(proc);
a771 1
    const char *name = cnp->cn_nameptr;
d778 2
d783 4
a786 9
    if (strlcpy (msg.contents, target, sizeof(msg.contents)) >= XFS_MAX_SYMLINK_CONTENT) {
	error = ENAMETOOLONG;
	goto done;
    }
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= XFS_MAX_NAME) {
	error = ENAMETOOLONG;
	goto done;
    }
    error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), proc);
d790 10
a799 1
 done:
d810 1
a810 1
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), XFS_DATA_R);
d815 5
a819 1
	xfs_vop_read(t, uiop, 0, cred, error);
d828 2
a829 1
    int error;
d832 1
a832 2
    XFSDEB(XDEBVNOPS, ("xfs_inactive, %lx\n",
		       (unsigned long)vp));
d844 5
a848 7
    /* xn->cred not set -> NOCRED */

    error = xfs_fsync_common(vp, xn->cred, /* XXX */ 0, p);
    if (error) {
	printf ("xfs_inactive: failed writing back data: %d\n", error);
	xn->flags &= ~XFS_DATA_DIRTY;
    }
a851 6
    /* If this node is no longer valid, recycle immediately. */
    if (!XFS_TOKEN_GOT(xn, XFS_ATTR_R | XFS_ATTR_W)
	|| (xn->flags & XFS_STALE) == XFS_STALE) {
        XFSDEB(XDEBVNOPS, ("xfs_inactive: vrecycle\n"));
        vrecycle(vp, 0, p);
    }
d853 1
a853 3

    XFSDEB(XDEBVNOPS, ("xfs_inactive: vp = %lx vp->v_usecount= %d\n",
		       (unsigned long)vp, vp?vp->v_usecount:0));
a854 1
    xn->flags &= ~XFS_STALE;
d868 1
a868 12
    XFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx\n",
		       (unsigned long)vp));

    XFS_TOKEN_CLEAR(xn,
		    ~0,
		    XFS_OPEN_MASK | XFS_ATTR_MASK |
		    XFS_DATA_MASK | XFS_LOCK_MASK);
    /* Release, data if we still have it. */
    if (DATA_FROM_XNODE(xn) != 0) {
        vrele(DATA_FROM_XNODE(xn));
	DATA_FROM_XNODE(xn) = 0;
    }
d877 1
d913 1
a913 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d35 1
a35 1
 * NNPFS operations.
d47 1
a47 1
RCSID("$arla: xfs_vnodeops-common.c,v 1.94 2003/01/27 11:58:50 lha Exp $");
d52 1
d54 1
d56 1
a56 1
    if ((xn->flags & NNPFS_STALE) == 0)
d61 4
a64 5
	xn->flags &= ~NNPFS_STALE;
	ubc_setsize(vp, 0);
	NNPFS_TOKEN_CLEAR(xn, ~0,
			NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
			NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
d70 1
a70 1
xfs_open_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
d73 1
a73 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d77 1
a77 1
    NNPFSDEB(XDEBVFOPS, ("xfs_open_valid\n"));
d82 1
a82 1
	if (!NNPFS_TOKEN_GOT(xn, tok)) {
d85 1
a85 1
	    msg.header.opcode = NNPFS_MSG_OPEN;
d101 1
a101 1
    NNPFSDEB(XDEBVFOPS, ("xfs_open_valid: error = %d\n", error));
d107 1
a107 1
xfs_attr_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
d110 1
a110 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d116 1
a116 1
	if (!NNPFS_TOKEN_GOT(xn, tok) || !xfs_has_pag(xn, pag)) {
d119 1
a119 1
	    msg.header.opcode = NNPFS_MSG_GETATTR;
d136 1
a136 2
xfs_data_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
	       u_int tok, uint32_t want_offset)
d138 1
a138 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d141 2
a142 2
    uint32_t offset;
    struct xfs_message_getdata msg;
d145 12
a156 3
	offset = want_offset;
	if (NNPFS_TOKEN_GOT(xn, tok|NNPFS_ATTR_R) && offset > xn->attr.va_size) {
	    offset = xn->attr.va_size;
d158 26
a183 6
    
	NNPFSDEB(XDEBVNOPS, ("xfs_data_valid: offset: want %ld has %ld, "
			   "tokens: want %lx has %lx length: %ld\n",
			   (long) offset, (long) xn->offset,
			   (long) tok, (long) xn->tokens,
			   (long) xn->attr.va_size));
d185 4
a188 4
	if (NNPFS_TOKEN_GOT(xn, tok)) {
	    if (offset <= xn->offset || xn->attr.va_type == VDIR) {
		break;
	    }
a189 13

	msg.header.opcode = NNPFS_MSG_GETDATA;
	msg.cred.uid = cred->cr_uid;
	msg.cred.pag = xfs_get_pag(cred);
	msg.handle = xn->handle;
	msg.tokens = tok;
	msg.offset = offset;
	
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), p);
	
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
	
d192 1
d200 1
a200 1
		d_thread_t *p)
a202 1
    int ret;
d204 1
a204 1
    NNPFSDEB(XDEBVNOPS, ("xfs_open\n"));
d207 5
a211 1
	ret = xfs_open_valid(vp, cred, p, NNPFS_OPEN_NW);
d213 1
a213 1
	ret = xfs_open_valid(vp, cred, p, NNPFS_OPEN_NR);
a214 8

    /* always update the read cred */

    if (mode & FWRITE)
	xfs_update_write_cred(xn, cred);
    xfs_update_read_cred(xn, cred);

    return ret;
d221 1
a221 1
	 d_thread_t *p,
d226 5
d232 6
a237 1
    msg.header.opcode = NNPFS_MSG_PUTDATA;
d243 1
a243 1
	msg.cred.pag = NNPFS_ANONYMOUSID;
d255 1
a255 1
	xn->flags &= ~NNPFS_DATA_DIRTY;
d262 1
a262 1
		 int waitfor, d_thread_t *proc)
d264 1
a264 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d268 1
a268 1
    NNPFSDEB(XDEBVNOPS, ("xfs_fsync: %lx\n", (unsigned long)vp));
d276 1
a276 1
	printf("NNPFS PANIC WARNING! xfs_fsync called after reclaiming!\n");
d280 4
a283 3
    xfs_pushdirty(vp, cred, proc);

    if (xn->flags & NNPFS_DATA_DIRTY) {
d288 1
a288 1
	    xn->flags &= ~NNPFS_DATA_DIRTY;
d292 1
a292 1
	error = do_fsync(xfsp, xn, cred, proc, NNPFS_WRITE | NNPFS_FSYNC);
d300 1
a300 1
		 d_thread_t *proc, struct ucred *cred)
d302 1
a302 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d306 1
a306 1
    NNPFSDEB(XDEBVNOPS,
d310 2
a311 5
    if (vp->v_type == VREG)
	xfs_pushdirty(vp, cred, proc);

    if (fflag & FWRITE && xn->flags & NNPFS_DATA_DIRTY)
	error = do_fsync(xfsp, xn, cred, proc, NNPFS_WRITE);
a315 16
size_t
xfs_uio_end_length (struct uio *uio)
{
#if DIAGNOSTIC
    size_t sz = 0;
    int i;

    for (i = 0; i < uio->uio_iovcnt; i++)
	sz += uio->uio_iov[i].iov_len;
    if (sz != uio->uio_resid)
	panic("xfs_uio_end_length");
#endif
    return uio->uio_offset + uio->uio_resid;
}


d323 1
a323 1
    NNPFSDEB(XDEBVNOPS, ("xfs_read\n"));
d325 1
a325 1
    xfs_update_read_cred(VNODE_TO_XNODE(vp), cred);
d327 1
a327 9
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uio), NNPFS_DATA_R,
			   xfs_uio_end_length(uio));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uio), NNPFS_DATA_R,
			   xfs_uio_end_length(uio));
#endif

    NNPFSDEB(XDEBVNOPS, ("xfs_read: iovcnt: %d\n", uio->uio_iovcnt));
d329 3
a331 3
	NNPFSDEB(XDEBVNOPS, ("  base: %lx len: %lu\n",
			   (unsigned long)uio->uio_iov[i].iov_base,
			   (unsigned long)uio->uio_iov[i].iov_len));
a335 5
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uio));
	xfs_vop_read(t, uio, ioflag, cred, error);
	xfs_vfs_unlock(t, xfs_uio_to_thread(uio));
#else
a338 1
#endif
d341 1
a341 1
    NNPFSDEB(XDEBVNOPS, ("xfs_read offset: %lu resid: %lu\n",
d343 2
a344 2
		       (unsigned long)uio->uio_resid));
    NNPFSDEB(XDEBVNOPS, ("xfs_read error: %d\n", error));
a352 1
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
d355 1
a355 3
    NNPFSDEB(XDEBVNOPS, ("xfs_write\n"));

    xfs_update_write_cred(xn, cred);
d357 1
a357 7
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_W,
			   VNODE_TO_XNODE(vp)->attr.va_size);
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_W,
			   VNODE_TO_XNODE(vp)->attr.va_size);
#endif
d360 1
a364 6
 #ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_writelock(t, xfs_uio_to_thread(uiop));
	xfs_vop_write(t, uiop, ioflag, cred, error);
	VNODE_TO_XNODE(vp)->flags |= NNPFS_DATA_DIRTY;
	xfs_vop_getattr(t, &sub_attr, cred, xfs_uio_to_thread(uiop), error2);
 #else
d367 1
a367 1
	VNODE_TO_XNODE(vp)->flags |= NNPFS_DATA_DIRTY;
a368 1
 #endif
a371 1
	    xn->attr.va_bytes = sub_attr.va_size;
a373 1
	    xn->offset = sub_attr.va_size;
a374 3
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
a375 1
#endif
d383 1
a383 1
		   struct ucred *cred, d_thread_t *p)
d389 1
a389 1
    NNPFSDEB(XDEBVNOPS, ("xfs_getattr\n"));
d391 1
a391 1
    error = xfs_attr_valid(vp, cred, p, NNPFS_ATTR_R);
d399 1
a399 1
		   struct ucred *cred, d_thread_t *p)
d401 1
a401 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d405 1
a405 1
    NNPFSDEB(XDEBVNOPS, ("xfs_setattr\n"));
d407 9
a415 9
#define CHECK_NNPFSATTR(A, cast) (vap->A == cast VNOVAL || vap->A == xn->attr.A)
	if (CHECK_NNPFSATTR(va_mode,(mode_t)) &&
	    CHECK_NNPFSATTR(va_nlink,(short)) &&
	    CHECK_NNPFSATTR(va_size,(va_size_t)) &&
	    CHECK_NNPFSATTR(va_uid,(uid_t)) &&
	    CHECK_NNPFSATTR(va_gid,(gid_t)) &&
	    CHECK_NNPFSATTR(va_mtime.tv_sec,(unsigned int)) &&
	    CHECK_NNPFSATTR(va_fileid,(long)) &&
	    CHECK_NNPFSATTR(va_type,(enum vtype)))
d417 1
a417 1
#undef CHECK_NNPFSATTR
d419 1
a419 1
    if (NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_W)) {
d421 1
a421 1
	VNODE_TO_XNODE(vp)->flags |= NNPFS_ATTR_DIRTY;
d427 1
a427 1
	msg.header.opcode = NNPFS_MSG_PUTATTR;
d433 1
a433 1
	    msg.cred.pag = NNPFS_ANONYMOUSID;
d437 1
a437 1
	if (NNPFS_TOKEN_GOT(xn, NNPFS_DATA_R)) {
a443 1
		/* XXX needed ? */
d454 1
a454 1
	NNPFS_TOKEN_CLEAR(xn, NNPFS_ATTR_VALID, NNPFS_ATTR_MASK);
d470 1
a470 1
	if ((rights & NNPFS_RIGHT_R) == 0)
d473 1
a473 1
	if ((rights & NNPFS_RIGHT_W) == 0)
d476 1
a476 1
	if ((rights & NNPFS_RIGHT_X) == 0)
d483 1
a483 1
		  d_thread_t *p)
d488 1
a488 1
    NNPFSDEB(XDEBVNOPS, ("xfs_access mode = 0%o\n", mode));
d490 1
a490 1
    error = xfs_attr_valid(vp, cred, p, NNPFS_ATTR_R);
d500 3
a502 1
	NNPFSDEB(XDEBVNOPS, ("xfs_access anonaccess failed\n"));
d514 1
a514 1
    NNPFSDEB(XDEBVNOPS, ("xfs_access(0%o) = %d\n", mode, error));
d525 1
a525 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d528 1
a528 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *proc  = xfs_cnp_to_thread(cnp);
    struct ucred *cred = xfs_thread_to_cred(proc);
#else
    d_thread_t *proc  = xfs_cnp_to_proc(cnp);
a529 1
#endif
d531 1
a531 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: enter\n"));
d535 1
a535 1
    if (cnp->cn_namelen >= NNPFS_MAX_NAME)
d552 1
a552 5
	NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: dvp = %lx\n",
			   (unsigned long) dvp));
	NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: cnp = %lx, "
			   "cnp->cn_nameiop = %d\n", 
			   (unsigned long) cnp, (int)cnp->cn_nameiop));
d570 1
a570 1
	    msg.header.opcode = NNPFS_MSG_GETNODE;
d576 1
a576 1
		msg.cred.pag = NNPFS_ANONYMOUSID;
d586 1
a586 1
		NNPFSDEB(XDEBVNOPS, ("xfs_lookup: neg cache %lx (%s, %ld)\n",
d598 1
a598 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup_common: return error = %d\n", error));
d607 1
a607 1
		  d_thread_t *p)
d609 1
a609 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d613 1
a613 1
    NNPFSDEB(XDEBVNOPS, ("xfs_create: (%lx, %s)\n",
d618 1
a618 1
	msg.header.opcode = NNPFS_MSG_CREATE;
d620 1
a620 1
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d630 1
a630 1
	    msg.cred.pag = NNPFS_ANONYMOUSID;
d653 1
a653 1
		  d_thread_t *p)
d655 1
a655 1
    struct xfs *xfsp  = NNPFS_FROM_VNODE(dvp);
d660 1
a660 1
    NNPFSDEB(XDEBVNOPS, ("xfs_remove: %s\n", name));
d662 1
a662 1
    msg.header.opcode = NNPFS_MSG_REMOVE;
d667 1
a667 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d688 1
a688 1
		  d_thread_t *p)
d690 1
a690 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(fdvp);
d693 1
a693 1
    NNPFSDEB(XDEBVNOPS, ("xfs_rename: %s %s\n", fname, tname));
d703 1
a703 1
	msg.header.opcode = NNPFS_MSG_RENAME;
d705 1
a705 1
	if (strlcpy(msg.old_name, fname, sizeof(msg.old_name)) >= NNPFS_MAX_NAME)
d708 1
a708 1
	if (strlcpy(msg.new_name, tname, sizeof(msg.new_name)) >= NNPFS_MAX_NAME)
d718 1
a718 1
    NNPFSDEB(XDEBVNOPS, ("xfs_rename: error = %d\n", error));
d728 1
a728 1
		 d_thread_t *p)
d730 1
a730 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d734 1
a734 1
    NNPFSDEB(XDEBVNOPS, ("xfs_mkdir: %s\n", name));
d738 1
a738 1
	msg.header.opcode = NNPFS_MSG_MKDIR;
d740 1
a740 1
	if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d748 1
a748 1
	    msg.cred.pag = NNPFS_ANONYMOUSID;
d763 1
a763 1
		 d_thread_t *p)
d765 1
a765 1
    struct xfs *xfsp  = NNPFS_FROM_VNODE(dvp);
d770 1
a770 1
    NNPFSDEB(XDEBVNOPS, ("xfs_rmdir: %s\n", name));
d772 1
a772 1
    msg.header.opcode = NNPFS_MSG_RMDIR;
d776 1
a776 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d786 1
a786 1
    NNPFSDEB(XDEBVNOPS, ("xfs_rmdir error: %d\n", error));
d795 1
a795 1
		   d_thread_t *p,
d800 1
a800 1
    NNPFSDEB(XDEBVNOPS, ("xfs_readdir\n"));
d804 1
a804 7
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#endif
a807 3
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uiop));
#else
a808 1
#endif
a813 3
#ifdef HAVE_FREEBSD_THREAD
	    xfs_vop_getattr(t, &t_attr, cred, xfs_uio_to_thread(uiop), error2);
#else
a814 1
#endif
a817 3
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
a818 1
#endif
d828 1
a828 1
		d_thread_t *p)
d830 1
a830 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d836 1
a836 1
    NNPFSDEB(XDEBVNOPS, ("xfs_link: %s\n", name));
d838 1
a838 1
    msg.header.opcode = NNPFS_MSG_LINK;
d841 1
a841 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME)
d860 1
a860 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d862 1
a862 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *proc  = xfs_cnp_to_thread(cnp);
    struct ucred *cred = xfs_thread_to_cred(proc);
#else
    d_thread_t *proc  = xfs_cnp_to_proc(cnp);
a863 1
#endif
d868 1
a868 1
    NNPFSDEB(XDEBVNOPS, ("xfs_symlink: %s\n", name));
d870 1
a870 1
    msg.header.opcode = NNPFS_MSG_SYMLINK;
d875 1
a875 1
    if (strlcpy (msg.contents, target, sizeof(msg.contents)) >= NNPFS_MAX_SYMLINK_CONTENT) {
d879 1
a879 1
    if (strlcpy(msg.name, name, sizeof(msg.name)) >= NNPFS_MAX_NAME) {
d896 1
a896 1
    NNPFSDEB(XDEBVNOPS, ("xfs_readlink\n"));
d898 1
a898 7
#ifdef HAVE_FREEBSD_THREAD
    error = xfs_data_valid(vp, cred, xfs_uio_to_thread(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#else
    error = xfs_data_valid(vp, cred, xfs_uio_to_proc(uiop), NNPFS_DATA_R,
			   xfs_uio_end_length(uiop));
#endif
a901 5
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_readlock(t, xfs_uio_to_thread(uiop));
	xfs_vop_read(t, uiop, 0, cred, error);
	xfs_vfs_unlock(t, xfs_uio_to_thread(uiop));
#else
a904 1
#endif
d910 1
a910 1
xfs_inactive_common(struct vnode *vp, d_thread_t *p)
d915 1
a915 1
    NNPFSDEB(XDEBVNOPS, ("xfs_inactive, %lx\n",
d924 1
a924 1
	NNPFSDEB(XDEBVNOPS, ("xfs_inactive: clean node\n"));
d928 1
a928 4
    /* xn->wr_cred not set -> NOCRED */

    if (vp->v_type == VREG)
	xfs_pushdirty(vp, xn->wr_cred, p);
d930 1
a930 1
    error = xfs_fsync_common(vp, xn->wr_cred, /* XXX */ 0, p);
d933 1
a933 1
	xn->flags &= ~NNPFS_DATA_DIRTY;
d936 2
d939 3
a941 6
    if (!NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_R | NNPFS_ATTR_W)
	|| (xn->flags & NNPFS_STALE) == NNPFS_STALE)
    {
#ifndef __osf__
	xfs_vfs_unlock(vp, p);
        NNPFSDEB(XDEBVNOPS, ("xfs_inactive: vrecycle\n"));
d943 5
a947 7
#else /* __osf__ */
	NNPFSDEB(XDEBVNOPS, ("xfs_inactive: vp = %lx vp->v_usecount= %d\n",
			     (unsigned long)vp, vp?vp->v_usecount:0));
#endif /* __osf__ */
    } else {
#ifndef __osf__
	xfs_vfs_unlock(vp, p);
d949 1
a949 2
	xn->flags &= ~NNPFS_STALE;
    }
d951 1
a951 1
    NNPFSDEB(XDEBVNOPS, ("return: xfs_inactive\n"));
d960 1
a960 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(vp);
d963 1
a963 1
    NNPFSDEB(XDEBVNOPS, ("xfs_reclaim: %lx\n",
d966 1
a966 1
    NNPFS_TOKEN_CLEAR(xn,
d968 2
a969 2
		    NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
		    NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
d976 1
a976 3
    xfs_remove_node(&xfsp->nodehead, xn);

    msg.header.opcode = NNPFS_MSG_INACTIVENODE;
d978 1
a978 1
    msg.flag   = NNPFS_NOREFS | NNPFS_DELETE;
d998 1
a998 1
    struct xfs *xfsp = NNPFS_FROM_VNODE(dvp);
d1002 1
a1002 1
    NNPFSDEB(XDEBVNOPS, ("xfs_advlock\n"));
d1006 1
a1006 1
	msg.header.opcode = NNPFS_MSG_ADVLOCK;
d1016 1
a1016 1
	    msg.cred.pag = NNPFS_ANONYMOUSID;
d1049 1
a1049 1
	    NNPFS_TOKEN_GOT(xn, NNPFS_ATTR_VALID) ? "": "in");
d1051 1
a1051 1
	    NNPFS_TOKEN_GOT(xn, NNPFS_DATA_VALID) ? "": "in");
a1052 1
    printf ("\toffset: %d\n", xn->offset);
@


