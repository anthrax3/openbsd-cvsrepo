head	1.13;
access;
symbols
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.12;

1.12
date	2007.05.30.04.27.43;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.29.21.28.05;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.29.05.28.54;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.28.22.17.21;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.12.10.55.09;	author hin;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.26.53;	author art;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	2000.03.03.00.54.58;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.00;	author art;	state Exp;
branches
	1.1.1.1
	1.1.4.1;
next	;

1.1.1.1
date	2002.06.07.03.32.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.50;	author hin;	state Exp;
branches;
next	;

1.1.4.1
date	2000.03.24.09.09.55;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.05.14.22.47.52;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.41.31;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.11.01.49;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2003.05.19.22.28.37;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/queue.h>
#include <xfs/xfs_locl.h>
#include <xfs/xfs_common.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_deb.h>
#include <xfs/xfs_vnodeops.h>

RCSID("$arla: xfs_node-bsd.c,v 1.70 2003/02/28 02:01:06 lha Exp $");

extern vop_t **xfs_vnodeop_p;

#ifndef LK_NOPAUSE
#define LK_NOPAUSE 0
#endif

/*
 * Allocate a new vnode with handle `handle' in `mp' and return it in
 * `vpp'.  Return 0 or error.
 */

int
xfs_getnewvnode(struct xfs *xfsp, struct vnode **vpp, 
		struct xfs_handle *handle)
{
    struct xfs_node *result, *check;
    int error;

    error = getnewvnode(VT_XFS, NNPFS_TO_VFS(xfsp), xfs_vnodeop_p, vpp);
    if (error)
	return error;
    
    result = xfs_alloc(sizeof(*result), M_NNPFS_NODE);
    bzero(result, sizeof(*result));
    
    (*vpp)->v_data = result;
    result->vn = *vpp;
    
    result->handle = *handle;
    result->flags = 0;
    result->tokens = 0;
    result->offset = 0;
#if defined(HAVE_KERNEL_LOCKMGR) || defined(HAVE_KERNEL_DEBUGLOCKMGR)
    lockinit (&result->lock, PVFS, "xfs_lock", 0, LK_NOPAUSE);
#else
    result->vnlocks = 0;
#endif
    result->anonrights = 0;
    result->rd_cred = NULL;
    result->wr_cred = NULL;

#if defined(__NetBSD_Version__) && __NetBSD_Version__ >= 105280000
    genfs_node_init(*vpp, &xfs_genfsops);
#endif

    check = xfs_node_find(&xfsp->nodehead, handle);
    if (check) {
	vput(*vpp);
	*vpp = result->vn;
	return 0;
    }

    xfs_insert(&xfs->nodehead, result);

    return 0;
}

/*
 * Create a new xfs_node and make a vget
 *
 * Also prevents creation of duplicates. This happens
 * whenever there are more than one name to a file,
 * "." and ".." are common cases.  */

int
new_xfs_node(struct xfs *xfsp,
	     struct xfs_msg_node *node,
	     struct xfs_node **xpp,
	     d_thread_t *p)
{
    struct xfs_node *result;

    NNPFSDEB(XDEBNODE, ("new_xfs_node (%d,%d,%d,%d)\n",
		      node->handle.a,
		      node->handle.b,
		      node->handle.c,
		      node->handle.d));

retry:
    /* Does not allow duplicates */
    result = xfs_node_find(&xfsp->nodehead, &node->handle);
    if (result == 0) {
	int error;
	struct vnode *v;

	error = xfs_getnewvnode(xfsp, &v, &node->handle);
	if (error)
	    return error;

	result = VNODE_TO_XNODE(v);
	result->anonrights = node->anonrights;

	xfsp->nnodes++;
    } else {
	/* Node is already cached */
	if(xfs_do_vget(XNODE_TO_VNODE(result), 0, p))
	    goto retry;
    }

    /* Init other fields */
    xfs_attr2vattr(&node->attr, &result->attr, 1);
    result->vn->v_type = result->attr.va_type;
    result->tokens = node->tokens;
    bcopy(node->id, result->id, sizeof(result->id));
    bcopy(node->rights, result->rights, sizeof(result->rights));

#ifdef __APPLE__
    if (result->vn->v_type == VREG && (!UBCINFOEXISTS(result->vn)))
	ubc_info_init(result->vn);
#endif

    *xpp = result;
    NNPFSDEB(XDEBNODE, ("return: new_xfs_node\n"));
    return 0;
}

void
free_xfs_node(struct xfs_node *node)
{
    struct xfs *xfsp = NNPFS_FROM_XNODE(node);

    NNPFSDEB(XDEBNODE, ("free_xfs_node(%lx) (%d,%d,%d,%d)\n",
		      (unsigned long)node,
		      node->handle.a,
		      node->handle.b,
		      node->handle.c,
		      node->handle.d));

    /* XXX Really need to put back dirty data first. */

    if (DATA_FROM_XNODE(node)) {
	vrele(DATA_FROM_XNODE(node));
	DATA_FROM_XNODE(node) = NULL;
    }
    xfsp->nnodes--;
    XNODE_TO_VNODE(node)->v_data = NULL;
    if (node->rd_cred) {
	crfree (node->rd_cred);
	node->rd_cred = NULL;
    }
    if (node->wr_cred) {
	crfree (node->wr_cred);
	node->wr_cred = NULL;
    }

    xfs_free(node, sizeof(*node), M_NNPFS_NODE);

    NNPFSDEB(XDEBNODE, ("free_xfs_node done\n"));
}

/*
 * FreeBSD 4.4 and newer changed to API to vflush around June 2001
 */

static int
xfs_vflush(struct mount *mp, int flags)
{
#if __FreeBSD__ && __FreeBSD_version > 430000
    return vflush(mp, 0, flags);
#else
    return vflush(mp, NULL, flags);
#endif
}

int
free_all_xfs_nodes(struct xfs *xfsp, int flags, int unmountp)
{
    int error = 0;
    struct mount *mp = NNPFS_TO_VFS(xfsp);

    if (mp == NULL) {
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes already freed\n"));
	return 0;
    }

    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes starting\n"));

    xfs_dnlc_purge_mp(mp);

    if (xfsp->root) {
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes now removing root\n"));

	vgone(XNODE_TO_VNODE(xfsp->root));
	xfsp->root = NULL;
    }

    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes root removed\n"));
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes now killing all remaining nodes\n"));

    /*
     * If we have a syncer vnode, release it (to emulate dounmount)
     * and the create it again when if we are going to need it.
     */

#ifdef HAVE_STRUCT_MOUNT_MNT_SYNCER
    if (!unmountp) {
	if (mp->mnt_syncer != NULL) {
#ifdef HAVE_KERNEL_VFS_DEALLOCATE_SYNCVNODE
	    vfs_deallocate_syncvnode(mp);
#else
	    /* 
	     * FreeBSD and OpenBSD uses different semantics,
	     * FreeBSD does vrele, and OpenBSD does vgone.
	     */
#if defined(__OpenBSD__)
	    vgone(mp->mnt_syncer);
#elif defined(__FreeBSD__)
	    vrele(mp->mnt_syncer);
#else
#error what os do you use ?
#endif
	    mp->mnt_syncer = NULL;
#endif
	}
    }
#endif
    error = xfs_vflush(mp, flags);
#ifdef HAVE_STRUCT_MOUNT_MNT_SYNCER
    if (!unmountp) {
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes not flushing syncer vnode\n"));
	if (mp->mnt_syncer == NULL)
	    if (vfs_allocate_syncvnode(mp))
		panic("failed to allocate syncer node when xfs daemon died");
    }
#endif

    if (error) {
	NNPFSDEB(XDEBNODE, ("xfree_all_xfs_nodes: vflush() error == %d\n",
			  error));
	return error;
    }

    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes done\n"));
    return error;
}

void
vattr2xfs_attr(const struct vattr *va, struct xfs_attr *xa)
{
    bzero(xa, sizeof(*xa));
    if (va->va_mode != (mode_t)VNOVAL)
	XA_SET_MODE(xa, va->va_mode);
    if (va->va_nlink != VNOVAL)
	XA_SET_NLINK(xa, va->va_nlink);
    if (va->va_size != VNOVAL)
	XA_SET_SIZE(xa, va->va_size);
    if (va->va_uid != VNOVAL)
	XA_SET_UID(xa, va->va_uid);
    if (va->va_gid != VNOVAL)
	XA_SET_GID(xa, va->va_gid);
    if (va->va_atime.tv_sec != VNOVAL)
	XA_SET_ATIME(xa, va->va_atime.tv_sec);
    if (va->va_mtime.tv_sec != VNOVAL)
	XA_SET_MTIME(xa, va->va_mtime.tv_sec);
    if (va->va_ctime.tv_sec != VNOVAL)
	XA_SET_CTIME(xa, va->va_ctime.tv_sec);
    if (va->va_fileid != VNOVAL)
	XA_SET_FILEID(xa, va->va_fileid);
    switch (va->va_type) {
    case VNON:
	xa->xa_type = NNPFS_FILE_NON;
	break;
    case VREG:
	xa->xa_type = NNPFS_FILE_REG;
	break;
    case VDIR:
	xa->xa_type = NNPFS_FILE_DIR;
	break;
    case VBLK:
	xa->xa_type = NNPFS_FILE_BLK;
	break;
    case VCHR:
	xa->xa_type = NNPFS_FILE_CHR;
	break;
    case VLNK:
	xa->xa_type = NNPFS_FILE_LNK;
	break;
    case VSOCK:
	xa->xa_type = NNPFS_FILE_SOCK;
	break;
    case VFIFO:
	xa->xa_type = NNPFS_FILE_FIFO;
	break;
    case VBAD:
	xa->xa_type = NNPFS_FILE_BAD;
	break;
    default:
	panic("xfs_attr2attr: bad value");
    }
}

#define SET_TIMEVAL(X, S, N) do { (X)->tv_sec = (S); (X)->tv_nsec = (N); } while(0)

void
xfs_attr2vattr(const struct xfs_attr *xa, struct vattr *va, int clear_node)
{
    if (clear_node)
	VATTR_NULL(va);
    if (XA_VALID_MODE(xa))
	va->va_mode = xa->xa_mode;
    if (XA_VALID_NLINK(xa))
	va->va_nlink = xa->xa_nlink;
    if (XA_VALID_SIZE(xa)) {
	va->va_size = xa->xa_size;
	va->va_bytes = va->va_size;
    }
    if (XA_VALID_UID(xa))
	va->va_uid = xa->xa_uid;
    if (XA_VALID_GID(xa))
	va->va_gid = xa->xa_gid;
    if (XA_VALID_ATIME(xa)) {
	SET_TIMEVAL(&va->va_atime, xa->xa_atime, 0);
    }
    if (XA_VALID_MTIME(xa)) {
	SET_TIMEVAL(&va->va_mtime, xa->xa_mtime, 0);
    }
    if (XA_VALID_CTIME(xa)) {
	SET_TIMEVAL(&va->va_ctime, xa->xa_ctime, 0);
    }
    if (XA_VALID_FILEID(xa)) {
	va->va_fileid = xa->xa_fileid;
    }
    if (XA_VALID_TYPE(xa)) {
	switch (xa->xa_type) {
	case NNPFS_FILE_NON:
	    va->va_type = VNON;
	    break;
	case NNPFS_FILE_REG:
	    va->va_type = VREG;
	    break;
	case NNPFS_FILE_DIR:
	    va->va_type = VDIR;
	    break;
	case NNPFS_FILE_BLK:
	    va->va_type = VBLK;
	    break;
	case NNPFS_FILE_CHR:
	    va->va_type = VCHR;
	    break;
	case NNPFS_FILE_LNK:
	    va->va_type = VLNK;
	    break;
	case NNPFS_FILE_SOCK:
	    va->va_type = VSOCK;
	    break;
	case NNPFS_FILE_FIFO:
	    va->va_type = VFIFO;
	    break;
	case NNPFS_FILE_BAD:
	    va->va_type = VBAD;
	    break;
	default:
	    panic("xfs_attr2vattr: bad value");
	}
    }
    va->va_flags = 0;
    va->va_blocksize = 8192;
}

/*
 * A single entry DNLC for systems for handling long names that don't
 * get put into the system DNLC.
 */

struct long_entry {
    struct vnode *dvp, *vp;
    char name[MAXNAMLEN + 1];
    size_t len;
    u_long dvpid, vpid;
};

static struct long_entry tbl;

/*
 * Nuke the `tbl'
 */

static void
tbl_clear (void)
{
    tbl.dvp = tbl.vp = NULL;
    tbl.name[0] = '\0';
    tbl.len = 0;
    tbl.dvpid = tbl.vpid = 0;
}

/*
 * Set the entry in the `tbl'
 */

static void
tbl_enter (size_t len, const char *name, struct vnode *dvp, struct vnode *vp)
{
    tbl.len = len;
    bcopy(name, tbl.name, len);
    tbl.dvp = dvp;
    tbl.vp = vp;
    tbl.dvpid = dvp->v_id;
    tbl.vpid = vp->v_id;
}

/*
 * Lookup in tbl (`dvp', `name', `len') and return result in `res'.
 * Return -1 if successful, otherwise 0.
 */

static int
tbl_lookup (struct componentname *cnp,
	    struct vnode *dvp,
	    struct vnode **res)
{
    if (tbl.dvp == dvp
	&& tbl.len == cnp->cn_namelen
	&& strncmp(tbl.name, cnp->cn_nameptr, tbl.len) == 0
	&& tbl.dvpid == tbl.dvp->v_id
	&& tbl.vpid == tbl.vp->v_id) {

	*res = tbl.vp;
	return -1;
    } else
	return 0;
}

/*
 * Store a componentname in the DNLC
 */

int
xfs_dnlc_enter(struct vnode *dvp,
	       xfs_componentname *cnp,
	       struct vnode *vp)
{
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter_cnp(%lx, %lx, %lx)\n",
		      (unsigned long)dvp,
		      (unsigned long)cnp,
		      (unsigned long)vp));
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter: v_id = %lu\n", (u_long)dvp->v_id));

    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter: calling cache_enter:"
		      "dvp = %lx, vp = %lx, cnp = (%s, %ld), "
		      "nameiop = %lu, flags = %lx\n",
		      (unsigned long)dvp,
		      (unsigned long)vp,
		      cnp->cn_nameptr, cnp->cn_namelen,
		      cnp->cn_nameiop, cnp->cn_flags));

#ifdef NCHNAMLEN
    if (cnp->cn_namelen <= NCHNAMLEN)
#endif
    {
	/*
	 * This is to make sure there's no negative entry already in the dnlc
	 */
	u_long save_nameiop;
	u_long save_flags;
	struct vnode *dummy;

	save_nameiop    = cnp->cn_nameiop;
	save_flags      = cnp->cn_flags;
	cnp->cn_nameiop = CREATE;
	cnp->cn_flags  &= ~MAKEENTRY;

/*
 * The version number here is not entirely correct, but it's conservative.
 * The real change is sys/kern/vfs_cache:1.20
 */

#if __NetBSD_Version__ >= 104120000 || OpenBSD > 200211
	if (cache_lookup(dvp, &dummy, cnp) != -1) {
	    xfs_vfs_unlock(dummy, xfs_cnp_to_proc(cnp));
	    printf ("NNPFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
		    cnp->cn_nameptr);
	}
#else
	if (cache_lookup(dvp, &dummy, cnp) != 0) {
	    printf ("NNPFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
		    cnp->cn_nameptr);
	}
#endif


	cnp->cn_nameiop = save_nameiop;
	cnp->cn_flags   = save_flags;
	cache_enter(dvp, vp, cnp);
    }

    if (vp != NULL)
	tbl_enter (cnp->cn_namelen, cnp->cn_nameptr, dvp, vp);

    return 0;
}
		   

static void
xfs_cnp_init (struct componentname *cn,
	      const char *name,
	      d_thread_t *proc, struct ucred *cred,
	      int nameiop)
{
    bzero(cn, sizeof(*cn));
    cn->cn_nameptr = (char *)name;
    cn->cn_namelen = strlen(name);
    cn->cn_flags   = 0;
#if __APPLE__
    {
	const unsigned char *p;
	int i;

	cn->cn_hash = 0;
	for (p = cn->cn_nameptr, i = 1; *p; ++p, ++i)
	    cn->cn_hash += *p * i;
    }
#elif defined(HAVE_KERNEL_NAMEI_HASH)
    {
	const char *cp = name + cn->cn_namelen;
	cn->cn_hash = namei_hash(name, &cp);
    }
#elif defined(HAVE_STRUCT_COMPONENTNAME_CN_HASH)
    {
	const unsigned char *p;

	cn->cn_hash = 0;
	for (p = cn->cn_nameptr; *p; ++p)
	    cn->cn_hash += *p;
    }
#endif
    cn->cn_nameiop = nameiop;
#ifdef HAVE_FREEBSD_THREAD
    cn->cn_thread = proc;
#else
    cn->cn_proc = proc;
#endif
    cn->cn_cred = cred;
}


/*
 * Store (dvp, name, vp) in the DNLC
 */

int
xfs_dnlc_enter_name(struct vnode *dvp,
		    const char *name,
		    struct vnode *vp)
{
    struct componentname cn;

    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter_name(%lx, \"%s\", %lx)\n",
		      (unsigned long)dvp,
		      name,
		      (unsigned long)vp));

    xfs_cnp_init (&cn, name, NULL, NULL, LOOKUP);
    return xfs_dnlc_enter (dvp, &cn, vp);
}

/*
 * Lookup (dvp, cnp) in the DNLC and return the result in `res'.
 * Return the result from cache_lookup.
 */

static int
xfs_dnlc_lookup_int(struct vnode *dvp,
		    xfs_componentname *cnp,
		    struct vnode **res)
{
    int error;
    u_long saved_flags;

    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup(%lx, \"%s\")\n",
		      (unsigned long)dvp, cnp->cn_nameptr));
    
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: v_id = %lu\n", (u_long)dvp->v_id));
    
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: calling cache_lookup:"
		      "dvp = %lx, cnp = (%s, %ld), flags = %lx\n",
		      (unsigned long)dvp,
		      cnp->cn_nameptr, cnp->cn_namelen,
		      cnp->cn_flags));

    saved_flags = cnp->cn_flags;
    cnp->cn_flags |= MAKEENTRY | LOCKPARENT | ISLASTCN;

    error = cache_lookup(dvp, res, cnp);

    cnp->cn_flags = saved_flags;

    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: cache_lookup returned. "
		      "error = %d, *res = %lx\n", error,
		      (unsigned long)*res));
    return error;
}

/*
 * do the last (and locking protocol) portion of xnlc_lookup
 *
 * return:
 * -1 for successful
 * 0  for failed
 */

static int
xfs_dnlc_lock(struct vnode *dvp,
	      xfs_componentname *cnp,
	      struct vnode **res)
{
    int error = 0;

    /*
     * Try to handle the (complex) BSD locking protocol.
     */

    if (*res == dvp) {		/* "." */
	VREF(dvp);
    } else if (cnp->cn_flags & ISDOTDOT) { /* ".." */
	u_long vpid = dvp->v_id;

#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(dvp, xfs_cnp_to_thread(cnp));
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_thread(cnp));
	xfs_vfs_writelock(dvp, xfs_cnp_to_thread(cnp));
#else
	xfs_vfs_unlock(dvp, xfs_cnp_to_proc(cnp));
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_proc(cnp));
	xfs_vfs_writelock(dvp, xfs_cnp_to_proc(cnp));
#endif

	if (error == 0 && dvp->v_id != vpid) {
	    vput(*res);
	    return 0;
	}
    } else {
#ifdef HAVE_FREEBSD_THREAD
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_thread(cnp));
#else
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_proc(cnp));
#endif
    }

    if (error == 0)
	return -1;
    else
	return 0;
}

/*
 * Lookup (`dvp', `cnp') in the DNLC (and the local cache).
 *
 * Return -1 if successful, 0 if not and ENOENT if the entry is known
 * not to exist.
 *
 * On modern NetBSD, cache_lookup has been changed to return 0 for
 * successful and -1 for not.
 * (see the comment above for version information).
 */

#if __NetBSD_Version__ >= 104120000 || defined(__OpenBSD__)

int
xfs_dnlc_lookup(struct vnode *dvp,
		xfs_componentname *cnp,
		struct vnode **res)
{
    int error = xfs_dnlc_lookup_int (dvp, cnp, res);

    if (error == 0)
	return -1;
    else if (error == ENOENT)
	return error;

    error = tbl_lookup (cnp, dvp, res);

    if (error != -1)
	return error;

    return xfs_dnlc_lock (dvp, cnp, res);
}

#else /* !  __NetBSD_Version__ >= 104120000 && ! OpenBSD > 200211 */

int
xfs_dnlc_lookup(struct vnode *dvp,
		xfs_componentname *cnp,
		struct vnode **res)
{
    int error = xfs_dnlc_lookup_int (dvp, cnp, res);

    if (error == 0)
	error = tbl_lookup (cnp, dvp, res);

    if (error != -1)
	return error;

    return xfs_dnlc_lock (dvp, cnp, res);
}

#endif /*  __NetBSD_Version__ >= 104120000 || OpenBSD > 200211 */

/*
 * Remove one entry from the DNLC
 */

void
xfs_dnlc_purge (struct vnode *vp)
{
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_purge\n"));

    if (tbl.dvp == vp || tbl.vp == vp)
	tbl_clear ();

    cache_purge(vp);
}

/*
 * Remove all entries belong to `mp' from the DNLC
 */

void
xfs_dnlc_purge_mp(struct mount *mp)
{
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_purge_mp()\n"));

    tbl_clear ();
    cache_purgevfs(mp);
}

/*
 * Returns 1 if pag has any rights set in the node
 */

int
xfs_has_pag(const struct xfs_node *xn, xfs_pag_t pag)
{
    int i;

    for (i = 0; i < MAXRIGHTS; i++)
	if (xn->id[i] == pag)
	    return 1;

    return 0;
}

void
xfs_update_write_cred(struct xfs_node *xn, struct ucred *cred)
{
    if (xn->wr_cred)
	crfree (xn->wr_cred);
    crhold (cred);
    xn->wr_cred = cred;
}

void
xfs_update_read_cred(struct xfs_node *xn, struct ucred *cred)
{
    if (xn->rd_cred)
	crfree (xn->rd_cred);
    crhold (cred);
    xn->rd_cred = cred;
}
@


1.12
log
@back out vfs change - todd fries has seen afs issues, and I'm suspicious
this can cause other problems.
@
text
@@


1.11
log
@make xfs use VT_XFS instead of VT_AFS when getting vnodes
via getnewvnode();

ok art@@,tedu@@
tested by todd@@
@
text
@a422 2
    vdrop(tbl.vp);
    vdrop(tbl.dvp);  
a435 2
    vhold(vp);
    vhold(dvp);  
d456 4
a459 9
	&& strncmp(tbl.name, cnp->cn_nameptr, tbl.len) == 0) {
#ifdef DIAGNOSTIC
	if (tbl.vpid != tbl.vp->v_id)
		panic("tbl.vpid %x != tbl.vp->v_id %x", tbl.vpid,
		    tbl.vp->v_id);
	if (tbl.dvpid != tbl.dvp->v_id)
		panic("tbl.dvpid %x != tbl.dvp->v_id %x", tbl.dvpid,
		    tbl.dvp->v_id);
#endif
d670 4
a673 4
#ifdef DIAGNOSTIC
	if (dvp->v_id != vpid)
		panic("dvp->v_id %x != vpid %x", dvp->v_id, vpid);
#endif	
@


1.10
log
@
	Step one of some vnode improvements - change getnewvnode to
actually allocate "desiredvnodes" - add a vdrop to un-hold a vnode held
with vhold, and change the name cache to make use of vhold/vdrop, while
keeping track of which vnodes are referred to by which cache entries to
correctly hold/drop vnodes when the cache uses them.
ok thib@@, tedu@@, art@@
@
text
@d61 1
a61 1
    error = getnewvnode(VT_AFS, NNPFS_TO_VFS(xfsp), xfs_vnodeop_p, vpp);
@


1.9
log
@avoid bypassing sys/queue.h in many places in the kernel.
many assumptions were made about the way the various list types are
implemented.

lots of suggestions and help from otto and miod.
ok otto@@
@
text
@d423 2
d438 2
d460 9
a468 4
	&& strncmp(tbl.name, cnp->cn_nameptr, tbl.len) == 0
	&& tbl.dvpid == tbl.dvp->v_id
	&& tbl.vpid == tbl.vp->v_id) {

d679 4
a682 4
	if (error == 0 && dvp->v_id != vpid) {
	    vput(*res);
	    return 0;
	}
@


1.8
log
@typos from Jonathon Gray;
@
text
@d34 1
a277 7

#ifndef LIST_FOREACH
#define LIST_FOREACH(var, head, field)					\
	for ((var) = ((head)->lh_first);				\
		(var);							\
		(var) = ((var)->field.le_next))
#endif
@


1.7
log
@Fix include stuff, unused variables and statics and other small things needed
to compile in our tree.
@
text
@d452 1
a452 1
 * Return -1 if succesful, otherwise 0.
d646 1
a646 1
 * -1 for succesful
d697 1
a697 1
 * Return -1 if succesful, 0 if not and ENOENT if the entry is known
d701 1
a701 1
 * succesful and -1 for not.
@


1.6
log
@Merge
@
text
@a57 1
    struct mount *mp;
@


1.5
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d40 1
a40 1
RCSID("$Id: xfs_node-bsd.c,v 1.4 2002/06/07 04:10:32 hin Exp $");
d54 1
a54 1
xfs_getnewvnode(struct mount *mp, struct vnode **vpp, 
d57 2
a58 1
    struct xfs_node *result;
d61 1
a61 1
    error = getnewvnode(VT_AFS, mp, xfs_vnodeop_p, vpp);
d65 1
a65 1
    result = xfs_alloc(sizeof(*result));
d74 1
d81 15
a95 1
    result->cred = NULL;
d111 1
a111 1
	     struct proc *p)
d115 1
a115 1
    XFSDEB(XDEBNODE, ("new_xfs_node (%d,%d,%d,%d)\n",
d123 1
a123 1
    result = xfs_node_find(xfsp, &node->handle);
d128 1
a128 1
	error = xfs_getnewvnode(XFS_TO_VFS(xfsp), &v, &node->handle);
d155 1
a155 1
    XFSDEB(XDEBNODE, ("return: new_xfs_node\n"));
d162 1
a162 1
    struct xfs *xfsp = XFS_FROM_XNODE(node);
d164 1
a164 1
    XFSDEB(XDEBNODE, ("free_xfs_node(%lx) (%d,%d,%d,%d)\n",
d179 7
a185 3
    if (node->cred) {
	crfree (node->cred);
	node->cred = NULL;
d188 1
a188 1
    xfs_free(node, sizeof(*node));
d190 1
a190 1
    XFSDEB(XDEBNODE, ("free_xfs_node done\n"));
d211 1
a211 1
    struct mount *mp = XFS_TO_VFS(xfsp);
d214 1
a214 1
	XFSDEB(XDEBNODE, ("free_all_xfs_nodes already freed\n"));
d218 1
a218 1
    XFSDEB(XDEBNODE, ("free_all_xfs_nodes starting\n"));
d223 1
a223 1
	XFSDEB(XDEBNODE, ("free_all_xfs_nodes now removing root\n"));
d229 2
a230 2
    XFSDEB(XDEBNODE, ("free_all_xfs_nodes root removed\n"));
    XFSDEB(XDEBNODE, ("free_all_xfs_nodes now killing all remaining nodes\n"));
d243 4
a246 4
           /* 
            * FreeBSD and OpenBSD uses different semantics,
            * FreeBSD does vrele, and OpenBSD does vgone.
            */
d248 1
a248 1
           vgone(mp->mnt_syncer);
d250 1
a250 1
            vrele(mp->mnt_syncer);
d262 1
a262 1
	XFSDEB(XDEBNODE, ("free_all_xfs_nodes not flushing syncer vnode\n"));
d270 1
a270 1
	XFSDEB(XDEBNODE, ("xfree_all_xfs_nodes: vflush() error == %d\n",
d275 1
a275 1
    XFSDEB(XDEBNODE, ("free_all_xfs_nodes done\n"));
d279 5
a283 39
struct xfs_node *
xfs_node_find(struct xfs *xfsp, xfs_handle *handlep)
{
    struct vnode *t;
    struct xfs_node *xn = NULL;

    XFSDEB(XDEBNODE, ("xfs_node_find: xfsp = %lx "
		      " handlep = (%d,%d,%d,%d)\n", 
		      (unsigned long)xfsp,
		      handlep->a,
		      handlep->b,
		      handlep->c,
		      handlep->d));

    /*
     * XXXSMP - the vnodes on mnt_vnodelist are invalid unless we hold
     *          mntvnode_slock (same on Open,Free and Net - current).
     * XXX - Another problem here is that the data in the vnode doesn't
     *       have to be correct unless we do a vget first (if usecount on
     *       vnode == 0). This should only be a problem when someone uses
     *       revoke, when unmounting or when arlad dies or on systems
     *       with a shortage of vnodes.
     *       We might want to vget here, but that was a problem
     *       on FreeBSD once.
     */

/* FreeBSD 4.5 and above did rename mnt_vnodelist to mnt_nvnodelist */
#ifdef HAVE_STRUCT_MOUNT_MNT_NVNODELIST
    TAILQ_FOREACH(t, &XFS_TO_VFS(xfsp)->mnt_nvnodelist, v_nmntvnodes) {
	xn = VNODE_TO_XNODE(t);
	if (xn && xfs_handle_eq(&xn->handle, handlep))
	    break;
    }
#else
    LIST_FOREACH(t, &XFS_TO_VFS(xfsp)->mnt_vnodelist, v_mntvnodes) {
	xn = VNODE_TO_XNODE(t);
	if (xn && xfs_handle_eq(&xn->handle, handlep))
	    break;
    }
a285 6
    if (t != NULL)
	return xn;
    else
	return NULL;
}

d310 1
a310 1
	xa->xa_type = XFS_FILE_NON;
d313 1
a313 1
	xa->xa_type = XFS_FILE_REG;
d316 1
a316 1
	xa->xa_type = XFS_FILE_DIR;
d319 1
a319 1
	xa->xa_type = XFS_FILE_BLK;
d322 1
a322 1
	xa->xa_type = XFS_FILE_CHR;
d325 1
a325 1
	xa->xa_type = XFS_FILE_LNK;
d328 1
a328 1
	xa->xa_type = XFS_FILE_SOCK;
d331 1
a331 1
	xa->xa_type = XFS_FILE_FIFO;
d334 1
a334 1
	xa->xa_type = XFS_FILE_BAD;
d352 1
a352 1
    if (XA_VALID_SIZE(xa))
d354 2
d374 1
a374 1
	case XFS_FILE_NON:
d377 1
a377 1
	case XFS_FILE_REG:
d380 1
a380 1
	case XFS_FILE_DIR:
d383 1
a383 1
	case XFS_FILE_BLK:
d386 1
a386 1
	case XFS_FILE_CHR:
d389 1
a389 1
	case XFS_FILE_LNK:
d392 1
a392 1
	case XFS_FILE_SOCK:
d395 1
a395 1
	case XFS_FILE_FIFO:
d398 1
a398 1
	case XFS_FILE_BAD:
a406 1
    va->va_bytes = va->va_size;
d482 1
a482 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter_cnp(%lx, %lx, %lx)\n",
d486 1
a486 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter: v_id = %ld\n", dvp->v_id));
d488 1
a488 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter: calling cache_enter:"
d517 1
a517 1
#if __NetBSD_Version__ >= 104120000 || defined(__OpenBSD__)
d519 2
a520 2
	    VOP_UNLOCK(dummy, 0, cnp->cn_proc);
	    printf ("XFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
d525 1
a525 1
	    printf ("XFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
d546 1
a546 1
	      struct proc *proc, struct ucred *cred,
a548 2
    const unsigned char *p;

d555 1
d562 5
d568 7
a574 3
    cn->cn_hash = 0;
    for (p = cn->cn_nameptr; *p; ++p)
	cn->cn_hash += *p;
d577 3
d581 1
d597 1
a597 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter_name(%lx, \"%s\", %lx)\n",
d619 1
a619 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_lookup(%lx, \"%s\")\n",
d622 1
a622 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: v_id = %ld\n", dvp->v_id));
d624 1
a624 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: calling cache_lookup:"
d637 1
a637 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: cache_lookup returned. "
d667 5
d675 1
d682 3
d686 1
d728 1
a728 1
#else /* !  __NetBSD_Version__ >= 104120000 */
d746 1
a746 1
#endif /*  __NetBSD_Version__ >= 104120000 */
d755 1
a755 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_purge\n"));
d770 1
a770 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_purge_mp()\n"));
d790 18
@


1.4
log
@merge
@
text
@d40 1
a40 1
RCSID("$Id: xfs_node-bsd.c,v 1.1.1.1 2002/06/07 03:32:59 hin Exp $");
d536 1
a536 1
#if __NetBSD_Version__ >= 104120000
d538 1
a538 1
	    VOP_UNLOCK(dummy, 0);
d703 1
a703 1
#if __NetBSD_Version__ >= 104120000
@


1.3
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
d40 1
a40 1
RCSID("$Id: xfs_node-bsd.c,v 1.45 2000/08/02 00:57:01 assar Exp $");
d127 1
a127 1
    xfs_attr2vattr(&node->attr, &result->attr);
d129 1
a129 1
    XFS_TOKEN_SET(result, XFS_ATTR_R, XFS_ATTR_MASK);
d133 5
d173 14
d206 1
a206 1
	xfsp->root = 0;
d212 28
d243 4
a246 2
	error = vflush(mp, mp->mnt_syncer, flags);
    } else
a247 3
    {
	error = vflush(mp, NULL, flags);
    }
d285 3
a287 3
    for(t = XFS_TO_VFS(xfsp)->mnt_vnodelist.lh_first;
	t != NULL; 
	t = t->v_mntvnodes.le_next) {
d292 7
d364 1
a364 1
xfs_attr2vattr(const struct xfs_attr *xa, struct vattr *va)
d366 2
a367 1
    VATTR_NULL(va);
@


1.3.8.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d45 1
a45 1
RCSID("$Id: xfs_node-bsd.c,v 1.3 2000/09/11 14:26:53 art Exp $");
d132 1
a132 1
    xfs_attr2vattr(&node->attr, &result->attr, 1);
d134 1
a134 1
    result->tokens = node->tokens;
a137 5
#ifdef __APPLE__
    if (result->vn->v_type == VREG && (!UBCINFOEXISTS(result->vn)))
	ubc_info_init(result->vn);
#endif

a172 14
/*
 * FreeBSD 4.4 and newer changed to API to vflush around June 2001
 */

static int
xfs_vflush(struct mount *mp, int flags)
{
#if __FreeBSD__ && __FreeBSD_version > 430000
    return vflush(mp, 0, flags);
#else
    return vflush(mp, NULL, flags);
#endif
}

d192 1
a192 1
	xfsp->root = NULL;
a197 5
    /*
     * If we have a syncer vnode, release it (to emulate dounmount)
     * and the create it again when if we are going to need it.
     */

d200 3
a202 19
	if (mp->mnt_syncer != NULL) {
#ifdef HAVE_KERNEL_VFS_DEALLOCATE_SYNCVNODE
	    vfs_deallocate_syncvnode(mp);
#else
           /* 
            * FreeBSD and OpenBSD uses different semantics,
            * FreeBSD does vrele, and OpenBSD does vgone.
            */
#if defined(__OpenBSD__)
           vgone(mp->mnt_syncer);
#elif defined(__FreeBSD__)
            vrele(mp->mnt_syncer);
#else
#error what os do you use ?
#endif
	    mp->mnt_syncer = NULL;
#endif
	}
    }
d204 2
a205 7
    error = xfs_vflush(mp, flags);
#ifdef HAVE_STRUCT_MOUNT_MNT_SYNCER
    if (!unmountp) {
	XFSDEB(XDEBNODE, ("free_all_xfs_nodes not flushing syncer vnode\n"));
	if (mp->mnt_syncer == NULL)
	    if (vfs_allocate_syncvnode(mp))
		panic("failed to allocate syncer node when xfs daemon died");
a206 1
#endif
d244 3
a246 3
/* FreeBSD 4.5 and above did rename mnt_vnodelist to mnt_nvnodelist */
#ifdef HAVE_STRUCT_MOUNT_MNT_NVNODELIST
    TAILQ_FOREACH(t, &XFS_TO_VFS(xfsp)->mnt_nvnodelist, v_nmntvnodes) {
a250 7
#else
    LIST_FOREACH(t, &XFS_TO_VFS(xfsp)->mnt_vnodelist, v_mntvnodes) {
	xn = VNODE_TO_XNODE(t);
	if (xn && xfs_handle_eq(&xn->handle, handlep))
	    break;
    }
#endif
d316 1
a316 1
xfs_attr2vattr(const struct xfs_attr *xa, struct vattr *va, int clear_node)
d318 1
a318 2
    if (clear_node)
	VATTR_NULL(va);
@


1.3.8.2
log
@sync
@
text
@d40 1
a40 1
RCSID("$Id$");
d536 1
a536 1
#if __NetBSD_Version__ >= 104120000 || defined(__OpenBSD__)
d538 1
a538 1
	    VOP_UNLOCK(dummy, 0, cnp->cn_proc);
d703 1
a703 1
#if __NetBSD_Version__ >= 104120000 || defined(__OpenBSD__)
@


1.2
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d43 1
d45 1
a45 1
RCSID("$OpenBSD: xfs_node-bsd.c,v 1.1 1999/04/30 01:59:00 art Exp $");
d49 4
d78 3
d82 3
a85 2
    result->anonrights = 0;
    
a101 1
    int do_vget = 0;
d104 1
a104 1
    XFSDEB(XDEBNODE, ("new_xfs_node %d.%d.%d.%d\n",
d109 2
a110 1
 again:
a112 1

d127 2
a128 4
#ifdef HAVE_LK_INTERLOCK
	simple_lock(&(XNODE_TO_VNODE(result)->v_interlock));
#endif
	do_vget = 1;
a137 11
    /*
     * We need to postpone this until here because (on FreeBSD) vget
     * tries to install a pager on the vnode and for that it wants to
     * retrieve the size with getattr.
     */

    if (do_vget) {
	if (xfs_do_vget(XNODE_TO_VNODE(result), LK_INTERLOCK, p))
	    goto again;
    }

d148 6
a153 1
    XFSDEB(XDEBNODE, ("free_xfs_node starting: node = %p\n", node));
d163 5
d224 19
a242 2
    XFSDEB(XDEBNODE, ("xfs_node_find: xfsp = %p handlep = %p\n", 
		      xfsp, handlep));
d422 2
a423 1
 * Lookup in tbl
d427 3
a429 1
tbl_lookup (size_t len, const char *name, struct vnode *dvp, struct vnode **res)
d432 2
a433 2
	&& tbl.len == len
	&& strncmp(tbl.name, name, len) == 0
d436 1
d452 4
a455 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter_cnp(%p, %p, %p)\n", dvp, cnp, vp));
d459 1
a459 1
		      "dvp = %p, vp = %p, cnp = (%s, %ld, %lu), "
d461 3
a463 1
		      dvp, vp, cnp->cn_nameptr, cnp->cn_namelen, cnp->cn_hash,
d474 1
d477 2
a478 1
	save_nameiop = cnp->cn_nameiop;
d480 6
d487 7
d498 2
d502 1
d513 1
a513 1
void
d515 1
a515 1
	      const char *name, struct vnode *vp, struct vnode *dvp,
d519 1
a519 1
    char *p ;
d525 9
d537 1
a553 1
    const char *p;
d555 4
a558 9
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter_name(%p, \"%s\", %p)\n", dvp, name, vp));

    cn.cn_nameiop = LOOKUP;
    cn.cn_flags   = 0;
    cn.cn_namelen = strlen(name);
    cn.cn_nameptr = (char *)name;
    cn.cn_hash = 0;
    for (p = cn.cn_nameptr; *p; ++p)
	cn.cn_hash += *p;
d560 1
d566 1
a566 1
 * Return -1 if succesful, 0 if not and ENOENT if we're sure it doesn't exist.
d569 4
a572 4
int
xfs_dnlc_lookup(struct vnode *dvp,
		xfs_componentname *cnp,
		struct vnode **res)
d577 2
a578 1
    XFSDEB(XDEBDNLC, ("xfs_dnlc_lookup(%p, \"%s\")\n", dvp, cnp->cn_nameptr));
d583 3
a585 2
		      "dvp = %p, cnp = (%s, %ld, %lu), flags = %lx\n",
		      dvp, cnp->cn_nameptr, cnp->cn_namelen, cnp->cn_hash,
d589 1
a589 1
    cnp->cn_flags |= MAKEENTRY;
d596 57
a652 1
		      "error = %d, *res = %p\n", error, *res));
d654 35
a688 1
    if (error == -1 || error == ENOENT)
d691 1
a691 1
    return tbl_lookup (cnp->cn_namelen, cnp->cn_nameptr, dvp, res);
d694 2
d729 1
a729 1
xfs_has_pag(const struct xfs_node *xn, pag_t pag)
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 2
d46 1
a46 1
RCSID("$Id: xfs_node-bsd.c,v 1.24 1999/02/26 00:47:48 lha Exp $");
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
a42 1
#include <xfs/xfs_vnodeops.h>
d44 1
a44 1
RCSID("$Id: xfs_node-bsd.c,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $");
a47 4
#ifndef LK_NOPAUSE
#define LK_NOPAUSE 0
#endif

a72 3
#if defined(HAVE_KERNEL_LOCKMGR) || defined(HAVE_KERNEL_DEBUGLOCKMGR)
    lockinit (&result->lock, PVFS, "xfs_lock", 0, LK_NOPAUSE);
#else
d74 1
a74 1
#endif
d76 1
a76 2
    result->cred = NULL;

d93 1
d96 1
a96 1
    XFSDEB(XDEBNODE, ("new_xfs_node (%d,%d,%d,%d)\n",
d101 1
a101 2

retry:
d104 1
d119 4
a122 2
	if(xfs_do_vget(XNODE_TO_VNODE(result), 0, p))
	    goto retry;
d126 1
a126 1
    xfs_attr2vattr(&node->attr, &result->attr, 1);
d128 1
a128 1
    result->tokens = node->tokens;
d132 10
a141 4
#ifdef __APPLE__
    if (result->vn->v_type == VREG && (!UBCINFOEXISTS(result->vn)))
	ubc_info_init(result->vn);
#endif
d153 1
a153 6
    XFSDEB(XDEBNODE, ("free_xfs_node(%lx) (%d,%d,%d,%d)\n",
		      (unsigned long)node,
		      node->handle.a,
		      node->handle.b,
		      node->handle.c,
		      node->handle.d));
a162 5
    if (node->cred) {
	crfree (node->cred);
	node->cred = NULL;
    }

a167 14
/*
 * FreeBSD 4.4 and newer changed to API to vflush around June 2001
 */

static int
xfs_vflush(struct mount *mp, int flags)
{
#if __FreeBSD__ && __FreeBSD_version > 430000
    return vflush(mp, 0, flags);
#else
    return vflush(mp, NULL, flags);
#endif
}

d187 1
a187 1
	xfsp->root = NULL;
a192 5
    /*
     * If we have a syncer vnode, release it (to emulate dounmount)
     * and the create it again when if we are going to need it.
     */

d195 3
a197 14
	if (mp->mnt_syncer != NULL) {
#ifdef HAVE_KERNEL_VFS_DEALLOCATE_SYNCVNODE
	    vfs_deallocate_syncvnode(mp);
#else
           /* 
            * FreeBSD and OpenBSD uses different semantics,
            * FreeBSD does vrele, and OpenBSD does vgone.
            */
#if defined(__OpenBSD__)
           vgone(mp->mnt_syncer);
#elif defined(__FreeBSD__)
            vrele(mp->mnt_syncer);
#else
#error what os do you use ?
d199 2
a200 12
	    mp->mnt_syncer = NULL;
#endif
	}
    }
#endif
    error = xfs_vflush(mp, flags);
#ifdef HAVE_STRUCT_MOUNT_MNT_SYNCER
    if (!unmountp) {
	XFSDEB(XDEBNODE, ("free_all_xfs_nodes not flushing syncer vnode\n"));
	if (mp->mnt_syncer == NULL)
	    if (vfs_allocate_syncvnode(mp))
		panic("failed to allocate syncer node when xfs daemon died");
a201 1
#endif
d219 2
a220 7
    XFSDEB(XDEBNODE, ("xfs_node_find: xfsp = %lx "
		      " handlep = (%d,%d,%d,%d)\n", 
		      (unsigned long)xfsp,
		      handlep->a,
		      handlep->b,
		      handlep->c,
		      handlep->d));
d222 3
a224 15
    /*
     * XXXSMP - the vnodes on mnt_vnodelist are invalid unless we hold
     *          mntvnode_slock (same on Open,Free and Net - current).
     * XXX - Another problem here is that the data in the vnode doesn't
     *       have to be correct unless we do a vget first (if usecount on
     *       vnode == 0). This should only be a problem when someone uses
     *       revoke, when unmounting or when arlad dies or on systems
     *       with a shortage of vnodes.
     *       We might want to vget here, but that was a problem
     *       on FreeBSD once.
     */

/* FreeBSD 4.5 and above did rename mnt_vnodelist to mnt_nvnodelist */
#ifdef HAVE_STRUCT_MOUNT_MNT_NVNODELIST
    TAILQ_FOREACH(t, &XFS_TO_VFS(xfsp)->mnt_nvnodelist, v_nmntvnodes) {
a228 7
#else
    LIST_FOREACH(t, &XFS_TO_VFS(xfsp)->mnt_vnodelist, v_mntvnodes) {
	xn = VNODE_TO_XNODE(t);
	if (xn && xfs_handle_eq(&xn->handle, handlep))
	    break;
    }
#endif
d294 1
a294 1
xfs_attr2vattr(const struct xfs_attr *xa, struct vattr *va, int clear_node)
d296 1
a296 2
    if (clear_node)
	VATTR_NULL(va);
d400 1
a400 2
 * Lookup in tbl (`dvp', `name', `len') and return result in `res'.
 * Return -1 if succesful, otherwise 0.
d404 1
a404 3
tbl_lookup (struct componentname *cnp,
	    struct vnode *dvp,
	    struct vnode **res)
d407 2
a408 2
	&& tbl.len == cnp->cn_namelen
	&& strncmp(tbl.name, cnp->cn_nameptr, tbl.len) == 0
a410 1

d426 1
a426 4
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter_cnp(%lx, %lx, %lx)\n",
		      (unsigned long)dvp,
		      (unsigned long)cnp,
		      (unsigned long)vp));
d430 1
a430 1
		      "dvp = %lx, vp = %lx, cnp = (%s, %ld), "
d432 1
a432 3
		      (unsigned long)dvp,
		      (unsigned long)vp,
		      cnp->cn_nameptr, cnp->cn_namelen,
a442 1
	u_long save_flags;
d445 1
a445 2
	save_nameiop    = cnp->cn_nameiop;
	save_flags      = cnp->cn_flags;
a446 6
	cnp->cn_flags  &= ~MAKEENTRY;

/*
 * The version number here is not entirely correct, but it's conservative.
 * The real change is sys/kern/vfs_cache:1.20
 */
a447 7
#if __NetBSD_Version__ >= 104120000
	if (cache_lookup(dvp, &dummy, cnp) != -1) {
	    VOP_UNLOCK(dummy, 0);
	    printf ("XFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
		    cnp->cn_nameptr);
	}
#else
a451 2
#endif

a453 1
	cnp->cn_flags   = save_flags;
d464 1
a464 1
static void
d466 1
a466 1
	      const char *name,
d470 1
a470 1
    const unsigned char *p;
a475 9
#if __APPLE__
    {
	int i;

	cn->cn_hash = 0;
	for (p = cn->cn_nameptr, i = 1; *p; ++p, ++i)
	    cn->cn_hash += *p * i;
    }
#elif defined(HAVE_STRUCT_COMPONENTNAME_CN_HASH)
a478 1
#endif
d495 1
d497 9
a505 4
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter_name(%lx, \"%s\", %lx)\n",
		      (unsigned long)dvp,
		      name,
		      (unsigned long)vp));
a506 1
    xfs_cnp_init (&cn, name, NULL, NULL, LOOKUP);
d512 1
a512 1
 * Return the result from cache_lookup.
d515 4
a518 4
static int
xfs_dnlc_lookup_int(struct vnode *dvp,
		    xfs_componentname *cnp,
		    struct vnode **res)
d523 1
a523 2
    XFSDEB(XDEBDNLC, ("xfs_dnlc_lookup(%lx, \"%s\")\n",
		      (unsigned long)dvp, cnp->cn_nameptr));
d528 2
a529 3
		      "dvp = %lx, cnp = (%s, %ld), flags = %lx\n",
		      (unsigned long)dvp,
		      cnp->cn_nameptr, cnp->cn_namelen,
d533 1
a533 1
    cnp->cn_flags |= MAKEENTRY | LOCKPARENT | ISLASTCN;
d540 1
a540 12
		      "error = %d, *res = %lx\n", error,
		      (unsigned long)*res));
    return error;
}

/*
 * do the last (and locking protocol) portion of xnlc_lookup
 *
 * return:
 * -1 for succesful
 * 0  for failed
 */
d542 1
a542 62
static int
xfs_dnlc_lock(struct vnode *dvp,
	      xfs_componentname *cnp,
	      struct vnode **res)
{
    int error = 0;

    /*
     * Try to handle the (complex) BSD locking protocol.
     */

    if (*res == dvp) {		/* "." */
	VREF(dvp);
    } else if (cnp->cn_flags & ISDOTDOT) { /* ".." */
	u_long vpid = dvp->v_id;

	xfs_vfs_unlock(dvp, xfs_cnp_to_proc(cnp));
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_proc(cnp));
	xfs_vfs_writelock(dvp, xfs_cnp_to_proc(cnp));

	if (error == 0 && dvp->v_id != vpid) {
	    vput(*res);
	    return 0;
	}
    } else {
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_proc(cnp));
    }

    if (error == 0)
	return -1;
    else
	return 0;
}

/*
 * Lookup (`dvp', `cnp') in the DNLC (and the local cache).
 *
 * Return -1 if succesful, 0 if not and ENOENT if the entry is known
 * not to exist.
 *
 * On modern NetBSD, cache_lookup has been changed to return 0 for
 * succesful and -1 for not.
 * (see the comment above for version information).
 */

#if __NetBSD_Version__ >= 104120000

int
xfs_dnlc_lookup(struct vnode *dvp,
		xfs_componentname *cnp,
		struct vnode **res)
{
    int error = xfs_dnlc_lookup_int (dvp, cnp, res);

    if (error == 0)
	return -1;
    else if (error == ENOENT)
	return error;

    error = tbl_lookup (cnp, dvp, res);

    if (error != -1)
d545 1
a545 1
    return xfs_dnlc_lock (dvp, cnp, res);
a547 20
#else /* !  __NetBSD_Version__ >= 104120000 */

int
xfs_dnlc_lookup(struct vnode *dvp,
		xfs_componentname *cnp,
		struct vnode **res)
{
    int error = xfs_dnlc_lookup_int (dvp, cnp, res);

    if (error == 0)
	error = tbl_lookup (cnp, dvp, res);

    if (error != -1)
	return error;

    return xfs_dnlc_lock (dvp, cnp, res);
}

#endif /*  __NetBSD_Version__ >= 104120000 */

d581 1
a581 1
xfs_has_pag(const struct xfs_node *xn, xfs_pag_t pag)
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d40 1
a40 1
RCSID("$arla: xfs_node-bsd.c,v 1.70 2003/02/28 02:01:06 lha Exp $");
d54 1
a54 1
xfs_getnewvnode(struct xfs *xfsp, struct vnode **vpp, 
d57 1
a57 2
    struct xfs_node *result, *check;
    struct mount *mp;
d60 1
a60 1
    error = getnewvnode(VT_AFS, NNPFS_TO_VFS(xfsp), xfs_vnodeop_p, vpp);
d64 1
a64 1
    result = xfs_alloc(sizeof(*result), M_NNPFS_NODE);
a72 1
    result->offset = 0;
d79 1
a79 15
    result->rd_cred = NULL;
    result->wr_cred = NULL;

#if defined(__NetBSD_Version__) && __NetBSD_Version__ >= 105280000
    genfs_node_init(*vpp, &xfs_genfsops);
#endif

    check = xfs_node_find(&xfsp->nodehead, handle);
    if (check) {
	vput(*vpp);
	*vpp = result->vn;
	return 0;
    }

    xfs_insert(&xfs->nodehead, result);
d95 1
a95 1
	     d_thread_t *p)
d99 1
a99 1
    NNPFSDEB(XDEBNODE, ("new_xfs_node (%d,%d,%d,%d)\n",
d107 1
a107 1
    result = xfs_node_find(&xfsp->nodehead, &node->handle);
d112 1
a112 1
	error = xfs_getnewvnode(xfsp, &v, &node->handle);
d139 1
a139 1
    NNPFSDEB(XDEBNODE, ("return: new_xfs_node\n"));
d146 1
a146 1
    struct xfs *xfsp = NNPFS_FROM_XNODE(node);
d148 1
a148 1
    NNPFSDEB(XDEBNODE, ("free_xfs_node(%lx) (%d,%d,%d,%d)\n",
d163 3
a165 7
    if (node->rd_cred) {
	crfree (node->rd_cred);
	node->rd_cred = NULL;
    }
    if (node->wr_cred) {
	crfree (node->wr_cred);
	node->wr_cred = NULL;
d168 1
a168 1
    xfs_free(node, sizeof(*node), M_NNPFS_NODE);
d170 1
a170 1
    NNPFSDEB(XDEBNODE, ("free_xfs_node done\n"));
d191 1
a191 1
    struct mount *mp = NNPFS_TO_VFS(xfsp);
d194 1
a194 1
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes already freed\n"));
d198 1
a198 1
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes starting\n"));
d203 1
a203 1
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes now removing root\n"));
d209 2
a210 2
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes root removed\n"));
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes now killing all remaining nodes\n"));
d223 4
a226 4
	    /* 
	     * FreeBSD and OpenBSD uses different semantics,
	     * FreeBSD does vrele, and OpenBSD does vgone.
	     */
d228 1
a228 1
	    vgone(mp->mnt_syncer);
d230 1
a230 1
	    vrele(mp->mnt_syncer);
d242 1
a242 1
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes not flushing syncer vnode\n"));
d250 1
a250 1
	NNPFSDEB(XDEBNODE, ("xfree_all_xfs_nodes: vflush() error == %d\n",
d255 1
a255 1
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes done\n"));
d259 39
a297 5
#ifndef LIST_FOREACH
#define LIST_FOREACH(var, head, field)					\
	for ((var) = ((head)->lh_first);				\
		(var);							\
		(var) = ((var)->field.le_next))
d300 6
d330 1
a330 1
	xa->xa_type = NNPFS_FILE_NON;
d333 1
a333 1
	xa->xa_type = NNPFS_FILE_REG;
d336 1
a336 1
	xa->xa_type = NNPFS_FILE_DIR;
d339 1
a339 1
	xa->xa_type = NNPFS_FILE_BLK;
d342 1
a342 1
	xa->xa_type = NNPFS_FILE_CHR;
d345 1
a345 1
	xa->xa_type = NNPFS_FILE_LNK;
d348 1
a348 1
	xa->xa_type = NNPFS_FILE_SOCK;
d351 1
a351 1
	xa->xa_type = NNPFS_FILE_FIFO;
d354 1
a354 1
	xa->xa_type = NNPFS_FILE_BAD;
d372 1
a372 1
    if (XA_VALID_SIZE(xa)) {
a373 2
	va->va_bytes = va->va_size;
    }
d392 1
a392 1
	case NNPFS_FILE_NON:
d395 1
a395 1
	case NNPFS_FILE_REG:
d398 1
a398 1
	case NNPFS_FILE_DIR:
d401 1
a401 1
	case NNPFS_FILE_BLK:
d404 1
a404 1
	case NNPFS_FILE_CHR:
d407 1
a407 1
	case NNPFS_FILE_LNK:
d410 1
a410 1
	case NNPFS_FILE_SOCK:
d413 1
a413 1
	case NNPFS_FILE_FIFO:
d416 1
a416 1
	case NNPFS_FILE_BAD:
d425 1
d501 1
a501 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter_cnp(%lx, %lx, %lx)\n",
d505 1
a505 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter: v_id = %lu\n", (u_long)dvp->v_id));
d507 1
a507 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter: calling cache_enter:"
d536 1
a536 1
#if __NetBSD_Version__ >= 104120000 || OpenBSD > 200211
d538 2
a539 2
	    xfs_vfs_unlock(dummy, xfs_cnp_to_proc(cnp));
	    printf ("NNPFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
d544 1
a544 1
	    printf ("NNPFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
d565 1
a565 1
	      d_thread_t *proc, struct ucred *cred,
d568 2
a575 1
	const unsigned char *p;
a581 5
#elif defined(HAVE_KERNEL_NAMEI_HASH)
    {
	const char *cp = name + cn->cn_namelen;
	cn->cn_hash = namei_hash(name, &cp);
    }
d583 3
a585 7
    {
	const unsigned char *p;

	cn->cn_hash = 0;
	for (p = cn->cn_nameptr; *p; ++p)
	    cn->cn_hash += *p;
    }
a587 3
#ifdef HAVE_FREEBSD_THREAD
    cn->cn_thread = proc;
#else
a588 1
#endif
d604 1
a604 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter_name(%lx, \"%s\", %lx)\n",
d626 1
a626 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup(%lx, \"%s\")\n",
d629 1
a629 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: v_id = %lu\n", (u_long)dvp->v_id));
d631 1
a631 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: calling cache_lookup:"
d644 1
a644 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: cache_lookup returned. "
a673 5
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(dvp, xfs_cnp_to_thread(cnp));
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_thread(cnp));
	xfs_vfs_writelock(dvp, xfs_cnp_to_thread(cnp));
#else
a676 1
#endif
a682 3
#ifdef HAVE_FREEBSD_THREAD
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_thread(cnp));
#else
a683 1
#endif
d703 1
a703 1
#if __NetBSD_Version__ >= 104120000 || OpenBSD > 200211
d725 1
a725 1
#else /* !  __NetBSD_Version__ >= 104120000 && ! OpenBSD > 200211 */
d743 1
a743 1
#endif /*  __NetBSD_Version__ >= 104120000 || OpenBSD > 200211 */
d752 1
a752 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_purge\n"));
d767 1
a767 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_purge_mp()\n"));
a786 18
}

void
xfs_update_write_cred(struct xfs_node *xn, struct ucred *cred)
{
    if (xn->wr_cred)
	crfree (xn->wr_cred);
    crhold (cred);
    xn->wr_cred = cred;
}

void
xfs_update_read_cred(struct xfs_node *xn, struct ucred *cred)
{
    if (xn->rd_cred)
	crfree (xn->rd_cred);
    crhold (cred);
    xn->rd_cred = cred;
@


1.1.4.1
log
@Sync with -current
@
text
@a0 2
/*	$OpenBSD$	*/

d44 1
a44 1
RCSID("$OpenBSD$");
@


1.1.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
a44 1
#include <xfs/xfs_vnodeops.h>
d46 1
a46 1
RCSID("$Id: xfs_node-bsd.c,v 1.3 2000/09/11 14:26:53 art Exp $");
a49 4
#ifndef LK_NOPAUSE
#define LK_NOPAUSE 0
#endif

a74 3
#if defined(HAVE_KERNEL_LOCKMGR) || defined(HAVE_KERNEL_DEBUGLOCKMGR)
    lockinit (&result->lock, PVFS, "xfs_lock", 0, LK_NOPAUSE);
#else
d76 1
a76 1
#endif
d78 1
a78 2
    result->cred = NULL;

d95 1
d98 1
a98 1
    XFSDEB(XDEBNODE, ("new_xfs_node (%d,%d,%d,%d)\n",
d103 1
a103 2

retry:
d106 1
d121 4
a124 2
	if(xfs_do_vget(XNODE_TO_VNODE(result), 0, p))
	    goto retry;
d134 11
d155 1
a155 6
    XFSDEB(XDEBNODE, ("free_xfs_node(%lx) (%d,%d,%d,%d)\n",
		      (unsigned long)node,
		      node->handle.a,
		      node->handle.b,
		      node->handle.c,
		      node->handle.d));
a164 5
    if (node->cred) {
	crfree (node->cred);
	node->cred = NULL;
    }

d221 2
a222 19
    XFSDEB(XDEBNODE, ("xfs_node_find: xfsp = %lx "
		      " handlep = (%d,%d,%d,%d)\n", 
		      (unsigned long)xfsp,
		      handlep->a,
		      handlep->b,
		      handlep->c,
		      handlep->d));

    /*
     * XXXSMP - the vnodes on mnt_vnodelist are invalid unless we hold
     *          mntvnode_slock (same on Open,Free and Net - current).
     * XXX - Another problem here is that the data in the vnode doesn't
     *       have to be correct unless we do a vget first (if usecount on
     *       vnode == 0). This should only be a problem when someone uses
     *       revoke, when unmounting or when arlad dies or on systems
     *       with a shortage of vnodes.
     *       We might want to vget here, but that was a problem
     *       on FreeBSD once.
     */
d402 1
a402 2
 * Lookup in tbl (`dvp', `name', `len') and return result in `res'.
 * Return -1 if succesful, otherwise 0.
d406 1
a406 3
tbl_lookup (struct componentname *cnp,
	    struct vnode *dvp,
	    struct vnode **res)
d409 2
a410 2
	&& tbl.len == cnp->cn_namelen
	&& strncmp(tbl.name, cnp->cn_nameptr, tbl.len) == 0
a412 1

d428 1
a428 4
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter_cnp(%lx, %lx, %lx)\n",
		      (unsigned long)dvp,
		      (unsigned long)cnp,
		      (unsigned long)vp));
d432 1
a432 1
		      "dvp = %lx, vp = %lx, cnp = (%s, %ld), "
d434 1
a434 3
		      (unsigned long)dvp,
		      (unsigned long)vp,
		      cnp->cn_nameptr, cnp->cn_namelen,
a444 1
	u_long save_flags;
d447 1
a447 2
	save_nameiop    = cnp->cn_nameiop;
	save_flags      = cnp->cn_flags;
a448 6
	cnp->cn_flags  &= ~MAKEENTRY;

/*
 * The version number here is not entirely correct, but it's conservative.
 * The real change is sys/kern/vfs_cache:1.20
 */
a449 7
#if __NetBSD_Version__ >= 104120000
	if (cache_lookup(dvp, &dummy, cnp) != -1) {
	    VOP_UNLOCK(dummy, 0);
	    printf ("XFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
		    cnp->cn_nameptr);
	}
#else
a453 2
#endif

a455 1
	cnp->cn_flags   = save_flags;
d466 1
a466 1
static void
d468 1
a468 1
	      const char *name,
d472 1
a472 1
    const unsigned char *p;
a477 9
#if __APPLE__
    {
	int i;

	cn->cn_hash = 0;
	for (p = cn->cn_nameptr, i = 1; *p; ++p, ++i)
	    cn->cn_hash += *p * i;
    }
#elif defined(HAVE_STRUCT_COMPONENTNAME_CN_HASH)
a480 1
#endif
d497 1
d499 9
a507 4
    XFSDEB(XDEBDNLC, ("xfs_dnlc_enter_name(%lx, \"%s\", %lx)\n",
		      (unsigned long)dvp,
		      name,
		      (unsigned long)vp));
a508 1
    xfs_cnp_init (&cn, name, NULL, NULL, LOOKUP);
d514 1
a514 1
 * Return the result from cache_lookup.
d517 4
a520 4
static int
xfs_dnlc_lookup_int(struct vnode *dvp,
		    xfs_componentname *cnp,
		    struct vnode **res)
d525 1
a525 2
    XFSDEB(XDEBDNLC, ("xfs_dnlc_lookup(%lx, \"%s\")\n",
		      (unsigned long)dvp, cnp->cn_nameptr));
d530 2
a531 3
		      "dvp = %lx, cnp = (%s, %ld), flags = %lx\n",
		      (unsigned long)dvp,
		      cnp->cn_nameptr, cnp->cn_namelen,
d535 1
a535 1
    cnp->cn_flags |= MAKEENTRY | LOCKPARENT | ISLASTCN;
d542 1
a542 57
		      "error = %d, *res = %lx\n", error,
		      (unsigned long)*res));
    return error;
}

/*
 * do the last (and locking protocol) portion of xnlc_lookup
 *
 * return:
 * -1 for succesful
 * 0  for failed
 */

static int
xfs_dnlc_lock(struct vnode *dvp,
	      xfs_componentname *cnp,
	      struct vnode **res)
{
    int error = 0;

    /*
     * Try to handle the (complex) BSD locking protocol.
     */

    if (*res == dvp) {		/* "." */
	VREF(dvp);
    } else if (cnp->cn_flags & ISDOTDOT) { /* ".." */
	u_long vpid = dvp->v_id;

	xfs_vfs_unlock(dvp, xfs_cnp_to_proc(cnp));
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_proc(cnp));
	xfs_vfs_writelock(dvp, xfs_cnp_to_proc(cnp));

	if (error == 0 && dvp->v_id != vpid) {
	    vput(*res);
	    return 0;
	}
    } else {
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_proc(cnp));
    }

    if (error == 0)
	return -1;
    else
	return 0;
}

/*
 * Lookup (`dvp', `cnp') in the DNLC (and the local cache).
 *
 * Return -1 if succesful, 0 if not and ENOENT if the entry is known
 * not to exist.
 *
 * On modern NetBSD, cache_lookup has been changed to return 0 for
 * succesful and -1 for not.
 * (see the comment above for version information).
 */
d544 1
a544 35
#if __NetBSD_Version__ >= 104120000

int
xfs_dnlc_lookup(struct vnode *dvp,
		xfs_componentname *cnp,
		struct vnode **res)
{
    int error = xfs_dnlc_lookup_int (dvp, cnp, res);

    if (error == 0)
	return -1;
    else if (error == ENOENT)
	return error;

    error = tbl_lookup (cnp, dvp, res);

    if (error != -1)
	return error;

    return xfs_dnlc_lock (dvp, cnp, res);
}

#else /* !  __NetBSD_Version__ >= 104120000 */

int
xfs_dnlc_lookup(struct vnode *dvp,
		xfs_componentname *cnp,
		struct vnode **res)
{
    int error = xfs_dnlc_lookup_int (dvp, cnp, res);

    if (error == 0)
	error = tbl_lookup (cnp, dvp, res);

    if (error != -1)
d547 1
a547 1
    return xfs_dnlc_lock (dvp, cnp, res);
a549 2
#endif /*  __NetBSD_Version__ >= 104120000 */

d583 1
a583 1
xfs_has_pag(const struct xfs_node *xn, xfs_pag_t pag)
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d45 1
a45 1
RCSID("$Id$");
d132 1
a132 1
    xfs_attr2vattr(&node->attr, &result->attr, 1);
d134 1
a134 1
    result->tokens = node->tokens;
a137 5
#ifdef __APPLE__
    if (result->vn->v_type == VREG && (!UBCINFOEXISTS(result->vn)))
	ubc_info_init(result->vn);
#endif

a172 14
/*
 * FreeBSD 4.4 and newer changed to API to vflush around June 2001
 */

static int
xfs_vflush(struct mount *mp, int flags)
{
#if __FreeBSD__ && __FreeBSD_version > 430000
    return vflush(mp, 0, flags);
#else
    return vflush(mp, NULL, flags);
#endif
}

d192 1
a192 1
	xfsp->root = NULL;
a197 5
    /*
     * If we have a syncer vnode, release it (to emulate dounmount)
     * and the create it again when if we are going to need it.
     */

d200 3
a202 14
	if (mp->mnt_syncer != NULL) {
#ifdef HAVE_KERNEL_VFS_DEALLOCATE_SYNCVNODE
	    vfs_deallocate_syncvnode(mp);
#else
           /* 
            * FreeBSD and OpenBSD uses different semantics,
            * FreeBSD does vrele, and OpenBSD does vgone.
            */
#if defined(__OpenBSD__)
           vgone(mp->mnt_syncer);
#elif defined(__FreeBSD__)
            vrele(mp->mnt_syncer);
#else
#error what os do you use ?
d204 2
a205 3
	    mp->mnt_syncer = NULL;
#endif
	}
a206 10
#endif
    error = xfs_vflush(mp, flags);
#ifdef HAVE_STRUCT_MOUNT_MNT_SYNCER
    if (!unmountp) {
	XFSDEB(XDEBNODE, ("free_all_xfs_nodes not flushing syncer vnode\n"));
	if (mp->mnt_syncer == NULL)
	    if (vfs_allocate_syncvnode(mp))
		panic("failed to allocate syncer node when xfs daemon died");
    }
#endif
d244 3
a246 9
/* FreeBSD 4.5 and above did rename mnt_vnodelist to mnt_nvnodelist */
#ifdef HAVE_STRUCT_MOUNT_MNT_NVNODELIST
    TAILQ_FOREACH(t, &XFS_TO_VFS(xfsp)->mnt_nvnodelist, v_nmntvnodes) {
	xn = VNODE_TO_XNODE(t);
	if (xn && xfs_handle_eq(&xn->handle, handlep))
	    break;
    }
#else
    LIST_FOREACH(t, &XFS_TO_VFS(xfsp)->mnt_vnodelist, v_mntvnodes) {
a250 1
#endif
d316 1
a316 1
xfs_attr2vattr(const struct xfs_attr *xa, struct vattr *va, int clear_node)
d318 1
a318 2
    if (clear_node)
	VATTR_NULL(va);
d487 1
a487 1
#if __NetBSD_Version__ >= 104120000 || defined(__OpenBSD__)
d489 1
a489 1
	    VOP_UNLOCK(dummy, 0, cnp->cn_proc);
d654 1
a654 1
#if __NetBSD_Version__ >= 104120000 || defined(__OpenBSD__)
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d40 1
a40 1
RCSID("$arla: xfs_node-bsd.c,v 1.70 2003/02/28 02:01:06 lha Exp $");
d54 1
a54 1
xfs_getnewvnode(struct xfs *xfsp, struct vnode **vpp, 
d57 1
a57 1
    struct xfs_node *result, *check;
d60 1
a60 1
    error = getnewvnode(VT_AFS, NNPFS_TO_VFS(xfsp), xfs_vnodeop_p, vpp);
d64 1
a64 1
    result = xfs_alloc(sizeof(*result), M_NNPFS_NODE);
a72 1
    result->offset = 0;
d79 1
a79 15
    result->rd_cred = NULL;
    result->wr_cred = NULL;

#if defined(__NetBSD_Version__) && __NetBSD_Version__ >= 105280000
    genfs_node_init(*vpp, &xfs_genfsops);
#endif

    check = xfs_node_find(&xfsp->nodehead, handle);
    if (check) {
	vput(*vpp);
	*vpp = result->vn;
	return 0;
    }

    xfs_insert(&xfs->nodehead, result);
d95 1
a95 1
	     d_thread_t *p)
d99 1
a99 1
    NNPFSDEB(XDEBNODE, ("new_xfs_node (%d,%d,%d,%d)\n",
d107 1
a107 1
    result = xfs_node_find(&xfsp->nodehead, &node->handle);
d112 1
a112 1
	error = xfs_getnewvnode(xfsp, &v, &node->handle);
d139 1
a139 1
    NNPFSDEB(XDEBNODE, ("return: new_xfs_node\n"));
d146 1
a146 1
    struct xfs *xfsp = NNPFS_FROM_XNODE(node);
d148 1
a148 1
    NNPFSDEB(XDEBNODE, ("free_xfs_node(%lx) (%d,%d,%d,%d)\n",
d163 3
a165 7
    if (node->rd_cred) {
	crfree (node->rd_cred);
	node->rd_cred = NULL;
    }
    if (node->wr_cred) {
	crfree (node->wr_cred);
	node->wr_cred = NULL;
d168 1
a168 1
    xfs_free(node, sizeof(*node), M_NNPFS_NODE);
d170 1
a170 1
    NNPFSDEB(XDEBNODE, ("free_xfs_node done\n"));
d191 1
a191 1
    struct mount *mp = NNPFS_TO_VFS(xfsp);
d194 1
a194 1
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes already freed\n"));
d198 1
a198 1
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes starting\n"));
d203 1
a203 1
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes now removing root\n"));
d209 2
a210 2
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes root removed\n"));
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes now killing all remaining nodes\n"));
d223 4
a226 4
	    /* 
	     * FreeBSD and OpenBSD uses different semantics,
	     * FreeBSD does vrele, and OpenBSD does vgone.
	     */
d228 1
a228 1
	    vgone(mp->mnt_syncer);
d230 1
a230 1
	    vrele(mp->mnt_syncer);
d242 1
a242 1
	NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes not flushing syncer vnode\n"));
d250 1
a250 1
	NNPFSDEB(XDEBNODE, ("xfree_all_xfs_nodes: vflush() error == %d\n",
d255 1
a255 1
    NNPFSDEB(XDEBNODE, ("free_all_xfs_nodes done\n"));
d259 39
a297 5
#ifndef LIST_FOREACH
#define LIST_FOREACH(var, head, field)					\
	for ((var) = ((head)->lh_first);				\
		(var);							\
		(var) = ((var)->field.le_next))
d300 6
d330 1
a330 1
	xa->xa_type = NNPFS_FILE_NON;
d333 1
a333 1
	xa->xa_type = NNPFS_FILE_REG;
d336 1
a336 1
	xa->xa_type = NNPFS_FILE_DIR;
d339 1
a339 1
	xa->xa_type = NNPFS_FILE_BLK;
d342 1
a342 1
	xa->xa_type = NNPFS_FILE_CHR;
d345 1
a345 1
	xa->xa_type = NNPFS_FILE_LNK;
d348 1
a348 1
	xa->xa_type = NNPFS_FILE_SOCK;
d351 1
a351 1
	xa->xa_type = NNPFS_FILE_FIFO;
d354 1
a354 1
	xa->xa_type = NNPFS_FILE_BAD;
d372 1
a372 1
    if (XA_VALID_SIZE(xa)) {
a373 2
	va->va_bytes = va->va_size;
    }
d392 1
a392 1
	case NNPFS_FILE_NON:
d395 1
a395 1
	case NNPFS_FILE_REG:
d398 1
a398 1
	case NNPFS_FILE_DIR:
d401 1
a401 1
	case NNPFS_FILE_BLK:
d404 1
a404 1
	case NNPFS_FILE_CHR:
d407 1
a407 1
	case NNPFS_FILE_LNK:
d410 1
a410 1
	case NNPFS_FILE_SOCK:
d413 1
a413 1
	case NNPFS_FILE_FIFO:
d416 1
a416 1
	case NNPFS_FILE_BAD:
d425 1
d472 1
a472 1
 * Return -1 if successful, otherwise 0.
d501 1
a501 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter_cnp(%lx, %lx, %lx)\n",
d505 1
a505 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter: v_id = %lu\n", (u_long)dvp->v_id));
d507 1
a507 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter: calling cache_enter:"
d536 1
a536 1
#if __NetBSD_Version__ >= 104120000 || OpenBSD > 200211
d538 2
a539 2
	    xfs_vfs_unlock(dummy, xfs_cnp_to_proc(cnp));
	    printf ("NNPFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
d544 1
a544 1
	    printf ("NNPFS PANIC WARNING! xfs_dnlc_enter: %s already in cache\n",
d565 1
a565 1
	      d_thread_t *proc, struct ucred *cred,
d568 2
a575 1
	const unsigned char *p;
a581 5
#elif defined(HAVE_KERNEL_NAMEI_HASH)
    {
	const char *cp = name + cn->cn_namelen;
	cn->cn_hash = namei_hash(name, &cp);
    }
d583 3
a585 7
    {
	const unsigned char *p;

	cn->cn_hash = 0;
	for (p = cn->cn_nameptr; *p; ++p)
	    cn->cn_hash += *p;
    }
a587 3
#ifdef HAVE_FREEBSD_THREAD
    cn->cn_thread = proc;
#else
a588 1
#endif
d604 1
a604 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_enter_name(%lx, \"%s\", %lx)\n",
d626 1
a626 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup(%lx, \"%s\")\n",
d629 1
a629 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: v_id = %lu\n", (u_long)dvp->v_id));
d631 1
a631 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: calling cache_lookup:"
d644 1
a644 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_lookup: cache_lookup returned. "
d654 1
a654 1
 * -1 for successful
a673 5
#ifdef HAVE_FREEBSD_THREAD
	xfs_vfs_unlock(dvp, xfs_cnp_to_thread(cnp));
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_thread(cnp));
	xfs_vfs_writelock(dvp, xfs_cnp_to_thread(cnp));
#else
a676 1
#endif
a682 3
#ifdef HAVE_FREEBSD_THREAD
	error = xfs_do_vget(*res, LK_EXCLUSIVE, xfs_cnp_to_thread(cnp));
#else
a683 1
#endif
d695 1
a695 1
 * Return -1 if successful, 0 if not and ENOENT if the entry is known
d699 1
a699 1
 * successful and -1 for not.
d725 1
a725 1
#else /* !  __NetBSD_Version__ >= 104120000 && ! OpenBSD > 200211 */
d743 1
a743 1
#endif /*  __NetBSD_Version__ >= 104120000 || OpenBSD > 200211 */
d752 1
a752 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_purge\n"));
d767 1
a767 1
    NNPFSDEB(XDEBDNLC, ("xfs_dnlc_purge_mp()\n"));
a786 18
}

void
xfs_update_write_cred(struct xfs_node *xn, struct ucred *cred)
{
    if (xn->wr_cred)
	crfree (xn->wr_cred);
    crhold (cred);
    xn->wr_cred = cred;
}

void
xfs_update_read_cred(struct xfs_node *xn, struct ucred *cred)
{
    if (xn->rd_cred)
	crfree (xn->rd_cred);
    crhold (cred);
    xn->rd_cred = cred;
@


