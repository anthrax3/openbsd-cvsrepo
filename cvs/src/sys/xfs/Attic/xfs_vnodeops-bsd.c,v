head	1.15;
access;
symbols
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.9.0.12
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.10
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.14;

1.14
date	2009.06.01.17.42.33;	author ariane;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.29.17.09.15;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.02.00.52.41;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.28.00.10.47;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.14.04.00.34;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.09.04.55.53;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.12.10.55.09;	author hin;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.26.54;	author art;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	2000.03.03.00.54.59;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.01;	author art;	state Exp;
branches
	1.1.1.1
	1.1.4.1;
next	;

1.1.1.1
date	2002.06.07.03.33.00;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.50;	author hin;	state Exp;
branches;
next	;

1.1.4.1
date	2000.03.24.09.09.56;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.05.14.22.47.53;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.41.31;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.11.01.51;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.06.05.23.13.13;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	;

1.6.2.1
date	2003.12.24.02.35.37;	author brad;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * NNPFS operations.
 */

#ifdef __APPLE__
#define MACH_KERNEL 1
#endif

#include <xfs/xfs_locl.h>
#include <xfs/xfs_message.h>
#include <xfs/xfs_common.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_dev.h>
#include <xfs/xfs_deb.h>
#include <xfs/xfs_syscalls.h>
#include <xfs/xfs_vnodeops.h>
#ifdef HAVE_VM_VNODE_PAGER_H
#include <vm/vnode_pager.h>
#endif

#include <sys/pool.h>

RCSID("$arla: xfs_vnodeops-bsd.c,v 1.123 2003/02/15 16:40:36 lha Exp $");

/*
 * vnode functions
 */

#ifdef HAVE_VOP_OPEN
int
xfs_open(struct vop_open_args * ap)
     /*
  struct vop_open {
          struct vnode *vp;
          int mode;
          struct ucred *cred;
          struct proc *p;
  }; */
{
#ifdef HAVE_FREEBSD_THREAD
    return xfs_open_common (ap->a_vp, ap->a_mode, ap->a_cred, ap->a_td);
#else
    return xfs_open_common (ap->a_vp, ap->a_mode, ap->a_cred, ap->a_p);
#endif
}
#endif /* HAVE_VOP_OPEN */

#ifdef HAVE_VOP_FSYNC
int
xfs_fsync(struct vop_fsync_args * ap)
     /*
  vop_fsync {
	struct vnode *vp;
	struct ucred *cred;
	int waitfor;
	struct proc *p;
};  */
{
#ifdef HAVE_STRUCT_VOP_FSYNC_ARGS_A_FLAGS
    return xfs_fsync_common(ap->a_vp, ap->a_cred, ap->a_flags, ap->a_p);
#else
#ifdef HAVE_FREEBSD_THREAD
    return xfs_fsync_common(ap->a_vp, ap->a_cred, ap->a_waitfor, ap->a_td);
#else
    return xfs_fsync_common(ap->a_vp, ap->a_cred, ap->a_waitfor, ap->a_p);
#endif
#endif
}
#endif /* HAVE_VOP_FSYNC */

#ifdef HAVE_VOP_CLOSE 
int
xfs_close(struct vop_close_args * ap)
     /* vop_close {
	IN struct vnode *vp;
	IN int fflag;
	IN struct ucred *cred;
	IN struct proc *p;
  }; */
{
#ifdef HAVE_FREEBSD_THREAD
    return xfs_close_common(ap->a_vp, ap->a_fflag, ap->a_td, ap->a_cred);
#else
    return xfs_close_common(ap->a_vp, ap->a_fflag, ap->a_p, ap->a_cred);
#endif
}
#endif /* HAVE_VOP_CLOSE */

#ifdef HAVE_VOP_READ
int
xfs_read(struct vop_read_args * ap)
     /* vop_read {
	IN struct vnode *vp;
	INOUT struct uio *uio;
	IN int ioflag;
	IN struct ucred *cred;
   }; */
{
    return xfs_read_common(ap->a_vp, ap->a_uio, ap->a_ioflag, ap->a_cred);
}
#endif /* HAVE_VOP_READ */

#ifdef HAVE_VOP_WRITE
int
xfs_write(struct vop_write_args * ap)
     /* vop_write {
	IN struct vnode *vp;
	INOUT struct uio *uio;
	IN int ioflag;
	IN struct ucred *cred;
   }; */
{
    return xfs_write_common(ap->a_vp, ap->a_uio, ap->a_ioflag, ap->a_cred);
}
#endif /* HAVE_VOP_WRITE */

#ifdef HAVE_VOP_IOCTL
int
xfs_ioctl(struct vop_ioctl_args * ap)
     /* struct vnode *vp,
	  int com,
	  caddr_t data,
	  int flag,
	  struct ucred *cred) */
{
    NNPFSDEB(XDEBVNOPS, ("xfs_ioctl\n"));

    return EOPNOTSUPP;
}
#endif /* HAVE_VOP_IOCTL */

#ifdef HAVE_VOP_SELECT
int
xfs_select(struct vop_select_args * ap)
     /* struct vnode *vp,
	   int which,
	   struct ucred *cred ) */
{
    NNPFSDEB(XDEBVNOPS, ("xfs_select\n"));

    return EOPNOTSUPP;
}
#endif /* HAVE_VOP_SELECT */

#ifdef HAVE_VOP_SEEK
int
xfs_seek(struct vop_seek_args * ap)
     /*
struct vop_seek_args {
        struct vnodeop_desc *a_desc;
        struct vnode *a_vp;
        off_t a_oldoff;
        off_t a_newoff;
        struct ucred *a_cred;
};
*/
{
    NNPFSDEB(XDEBVNOPS, ("xfs_seek\n"));
    return 0;
}
#endif /* HAVE_VOP_SEEK */

#ifdef HAVE_VOP_POLL
int
xfs_poll(struct vop_poll_args * ap)
     /* vop_poll {
	IN struct vnode *vp;
	IN int events;
	IN struct proc *p;
   }; */
{
    NNPFSDEB(XDEBVNOPS, ("xfs_poll\n"));
    return EOPNOTSUPP;
}
#endif /* HAVE_VOP_POLL */

#ifdef HAVE_VOP_GETATTR
int
xfs_getattr(struct vop_getattr_args * ap)
     /* struct vnode *vp,
	    struct vattr *vap,
	    struct ucred *cred,
	    struct proc *p) */
{
#ifdef HAVE_FREEBSD_THREAD
    return xfs_getattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_td);
#else
    return xfs_getattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_p);
#endif
}
#endif /* HAVE_VOP_GETATTR */

#ifdef HAVE_VOP_SETATTR
int
xfs_setattr(struct vop_setattr_args * ap)
     /* struct vnode *vp,
	    struct vattr *vap,
	    struct ucred *cred,
	    struct proc *p)
	    */
{
#ifdef HAVE_FREEBSD_THREAD
    return xfs_setattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_td);
#else
    return xfs_setattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_p);
#endif
}
#endif /* HAVE_VOP_SETATTR */

#ifdef HAVE_VOP_ACCESS
int
xfs_access(struct vop_access_args * ap)
     /*
struct vnode *vp,
	   int mode,
	   struct ucred *cred,
	   struct proc *p)
	   */
{
#ifdef HAVE_FREEBSD_THREAD
    return xfs_access_common(ap->a_vp, ap->a_mode, ap->a_cred, ap->a_td);
#else
    return xfs_access_common(ap->a_vp, ap->a_mode, ap->a_cred, ap->a_p);
#endif
}
#endif /* HAVE_VOP_ACCESS */

#ifdef HAVE_VOP_LOOKUP
int
xfs_lookup(struct vop_lookup_args * ap)
     /* struct vop_lookup_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
}; */
{
    struct componentname *cnp = ap->a_cnp;
    int error;
    int lockparent = (cnp->cn_flags & (LOCKPARENT | ISLASTCN))
	== (LOCKPARENT | ISLASTCN);

    NNPFSDEB(XDEBVNOPS, ("xfs_lookup: (%s, %ld), nameiop = %lu, flags = %lu\n",
		       cnp->cn_nameptr,
		       cnp->cn_namelen,
		       cnp->cn_nameiop,
		       cnp->cn_flags));

#ifdef PDIRUNLOCK
    cnp->cn_flags &= ~PDIRUNLOCK;
#endif

    error = xfs_lookup_common(ap->a_dvp, cnp, ap->a_vpp);

    if (error == ENOENT
	&& (cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME)
	&& (cnp->cn_flags & ISLASTCN)) {
	error = EJUSTRETURN;
    }

    if (cnp->cn_nameiop != LOOKUP && cnp->cn_flags & ISLASTCN)
	cnp->cn_flags |= SAVENAME;

    if (error == 0 || error == EJUSTRETURN) {
	if (ap->a_dvp == *(ap->a_vpp)) {
	    /* if we looked up ourself, do nothing */
	} else if (!(cnp->cn_flags & ISLASTCN) || !lockparent) {
	    /* if we isn't last component and is isn't requested,
	     * return parent unlocked */
#ifdef HAVE_FREEBSD_THREAD
	    xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_thread(cnp));
#else
	    xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_proc(cnp));
#endif
#ifdef PDIRUNLOCK
	    cnp->cn_flags |= PDIRUNLOCK;
#endif
	}
    } else {
	/* in case of a error do nothing  */
    } 
    
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup: error = %d\n", error));

    return error;
}
#endif /* HAVE_VOP_LOOKUP */

#ifdef HAVE_VOP_CACHEDLOOKUP
int
xfs_cachedlookup(struct vop_cachedlookup_args * ap)
     /* struct vop_cachedlookup_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
}; */
{
    return xfs_lookup((struct vop_lookup_args *)ap);
}
#endif /* HAVE_VOP_CACHEDLOOKUP */

/*
 * whatever clean-ups are needed for a componentname.
 */

static void
cleanup_cnp (struct componentname *cnp, int error)
{
    if (error != 0 || (cnp->cn_flags & SAVESTART) == 0) {
#if defined(HAVE_KERNEL_ZFREEI)
	zfreei(namei_zone, cnp->cn_pnbuf);
	cnp->cn_flags &= ~HASBUF;
#elif defined(HAVE_KERNEL_UMA_ZFREE_ARG)
	uma_zfree_arg(namei_zone, cnp->cn_pnbuf, NULL);
	cnp->cn_flags &= ~HASBUF;
#elif defined(FREE_ZONE)
	FREE_ZONE(cnp->cn_pnbuf, cnp->cn_pnlen, M_NAMEI);
#elif defined(HAVE_KERNEL_ZFREE)
	zfree(namei_zone, cnp->cn_pnbuf);
	cnp->cn_flags &= ~HASBUF;
#elif defined(PNBUF_PUT)
	PNBUF_PUT(cnp->cn_pnbuf);
#else
	pool_put(&namei_pool, cnp->cn_pnbuf);
#endif
    }
}

#ifdef HAVE_VOP_CREATE
int
xfs_create(struct vop_create_args *ap)
{
    struct vnode *dvp  = ap->a_dvp;
    struct componentname *cnp = ap->a_cnp;
    const char *name   = cnp->cn_nameptr;
    struct ucred *cred = cnp->cn_cred;
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p     = xfs_cnp_to_thread(cnp);
#else
    d_thread_t *p     = xfs_cnp_to_proc(cnp);
#endif
    int error;

    error = xfs_create_common(dvp, name, ap->a_vap, cred, p);

    if (error == 0) {
	error = xfs_lookup_common(dvp, cnp, ap->a_vpp);
    }

    cleanup_cnp (cnp, error);

#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
    vput (dvp);
#endif

    NNPFSDEB(XDEBVNOPS, ("xfs_create: error = %d\n", error));
    
    return error;
}
#endif /* HAVE_VOP_CREATE */

#ifdef HAVE_VOP_REMOVE
int
xfs_remove(struct vop_remove_args * ap)
     /* struct vnode *dvp,
   struct vnode *vp,
   struct componentname *cnp */
{
    struct componentname *cnp = ap->a_cnp;
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp  = ap->a_vp;

#ifdef HAVE_FREEBSD_THREAD
    int error = xfs_remove_common(dvp, vp, cnp->cn_nameptr, 
				  cnp->cn_cred, xfs_cnp_to_thread(cnp));
#else
    int error = xfs_remove_common(dvp, vp, cnp->cn_nameptr, 
				  cnp->cn_cred, xfs_cnp_to_proc(cnp));
#endif

    cleanup_cnp (cnp, error);

#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif
    
#ifdef __APPLE__
    if (error == 0) {
	if (UBCINFOEXISTS(vp)) {
	    ubc_setsize(vp, 0);
	    ubc_release(vp);
	    ubc_uncache(vp);
	}
    }
#endif

    return error;
}
#endif /* HAVE_VOP_REMOVE */

#ifdef HAVE_VOP_RENAME
int
xfs_rename(struct vop_rename_args * ap)
     /* vop_rename {
	IN WILLRELE struct vnode *fdvp;
	IN WILLRELE struct vnode *fvp;
	IN struct componentname *fcnp;
	IN WILLRELE struct vnode *tdvp;
	IN WILLRELE struct vnode *tvp;
	IN struct componentname *tcnp;
  }; */
{
    struct vnode *tdvp = ap->a_tdvp;
    struct vnode *tvp  = ap->a_tvp;
    struct vnode *fdvp = ap->a_fdvp;
    struct vnode *fvp  = ap->a_fvp;

    int error = xfs_rename_common(fdvp,
				  fvp,
				  ap->a_fcnp->cn_nameptr,
				  tdvp,
				  tvp,
				  ap->a_tcnp->cn_nameptr,
				  ap->a_tcnp->cn_cred,
#ifdef HAVE_FREEBSD_THREAD
				  xfs_cnp_to_thread (ap->a_fcnp));
#else
				  xfs_cnp_to_proc (ap->a_fcnp));
#endif
    if(tdvp == tvp)
	vrele(tdvp);
    else
	vput(tdvp);
    if(tvp)
	vput(tvp);
    vrele(fdvp);
    vrele(fvp);
    return error;
}
#endif /* HAVE_VOP_RENAME */

#ifdef HAVE_VOP_MKDIR
int
xfs_mkdir(struct vop_mkdir_args * ap)
     /* struct vnode *dvp,
	  char *nm,
	  struct vattr *va,
	  struct vnode **vpp,
	  struct ucred *cred)      */
{
    struct vnode *dvp  = ap->a_dvp;
    struct componentname *cnp = ap->a_cnp;
    const char *name   = cnp->cn_nameptr;
    struct ucred *cred = cnp->cn_cred;
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p     = xfs_cnp_to_thread(cnp);
#else
    d_thread_t *p     = xfs_cnp_to_proc(cnp);
#endif
    int error;

    error = xfs_mkdir_common(dvp, name, ap->a_vap, cred, p);

    if (error == 0)
	error = xfs_lookup_common(dvp, cnp, ap->a_vpp);

    cleanup_cnp (cnp, error);

#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)
    vput(dvp);
#endif

    NNPFSDEB(XDEBVNOPS, ("xfs_mkdir: error = %d\n", error));

    return error;
}
#endif /* HAVE_VOP_MKDIR */

#ifdef HAVE_VOP_RMDIR
int
xfs_rmdir(struct vop_rmdir_args * ap)
     /* struct vnode *dvp,
   struct vnode *vp,
   struct componentname *cnp */
{
    struct componentname *cnp = ap->a_cnp;
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp  = ap->a_vp;
    int error = xfs_rmdir_common(ap->a_dvp, ap->a_vp, 
				 cnp->cn_nameptr,
				 cnp->cn_cred,
#ifdef HAVE_FREEBSD_THREAD
				 xfs_cnp_to_thread(cnp));
#else
				 xfs_cnp_to_proc(cnp));
#endif

    cleanup_cnp (cnp, error);
#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif

    return error;
}
#endif /* HAVE_VOP_RMDIR */

#ifdef HAVE_VOP_READDIR

#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
typedef u_long xfs_cookie_t;
#elif defined(__NetBSD__)
typedef off_t xfs_cookie_t;
#else
#error dunno want kind of cookies you have
#endif

int
xfs_readdir(struct vop_readdir_args * ap)
     /* struct vnode *vp,
	    struct uio *uiop,
	    struct ucred *cred) */
{
    int error;
    off_t off;

    off = ap->a_uio->uio_offset;

    error = xfs_readdir_common(ap->a_vp, ap->a_uio, ap->a_cred,
#ifdef HAVE_FREEBSD_THREAD
			       xfs_uio_to_thread (ap->a_uio),
#else
			       xfs_uio_to_proc (ap->a_uio),
#endif
			       ap->a_eofflag);

    if (!error && ap->a_ncookies != NULL) {
	struct uio *uio = ap->a_uio;
	const struct dirent *dp, *dp_start, *dp_end;
	int ncookies;
	xfs_cookie_t *cookies, *cookiep;

	if (uio->uio_segflg != UIO_SYSSPACE || uio->uio_iovcnt != 1)
	    panic("xfs_readdir: mail arla-drinkers and tell them to bake burned cookies");
	dp = (const struct dirent *)
	    ((const char *)uio->uio_iov->iov_base - (uio->uio_offset - off));

	dp_end = (const struct dirent *) uio->uio_iov->iov_base;
	for (dp_start = dp, ncookies = 0;
	     dp < dp_end;
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen)) {
	    if (dp->d_reclen <= 0)
		break;
	    ncookies++;
	}

	cookies = malloc(ncookies * sizeof(xfs_cookie_t), M_TEMP, M_WAITOK);
	for (dp = dp_start, cookiep = cookies;
	     dp < dp_end;
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen)) {
	    if (dp->d_reclen <= 0)
		break;
	    off += dp->d_reclen;
	    *cookiep++ = off;
	}
	*ap->a_cookies = cookies;
	*ap->a_ncookies = ncookies;
    }
    return error;
}
#endif /* HAVE_VOP_READDIR */

#ifdef HAVE_VOP_LINK
int
xfs_link(struct vop_link_args * ap)
     /*
	WILLRELE struct vnode *tdvp;
	struct vnode *vp;
	struct componentname *cnp;
	*/
{
    struct componentname *cnp = ap->a_cnp;
    struct vnode *vp = ap->a_vp;
    struct vnode *dvp;
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p = cnp->cn_thread;
#else
    d_thread_t *p = cnp->cn_proc;
#endif
    int error;

#if defined (__OpenBSD__) || defined(__NetBSD__)
    dvp = ap->a_dvp;
#elif defined(__FreeBSD__) || defined(__APPLE__)
    dvp = ap->a_tdvp;
#else
#error what kind of BSD is this?
#endif

    if (vp->v_type == VDIR) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
#endif
	    error = EPERM;
	    goto out;
    }
    if (dvp->v_mount != vp->v_mount) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
#endif
	    error = EXDEV;
	    goto out;
    }
    /* FreeBSD 5.0 doesn't need to lock the vnode in VOP_LINK */
#if !defined(__FreeBSD_version) || __FreeBSD_version < 500043

    if (dvp != vp && (error = xfs_vfs_writelock(vp, p))) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
#endif
	    goto out;
    }
#endif /* defined(__FreeBSD_version) || __FreeBSD_version < 500043 */

    error = xfs_link_common(
			   dvp,
			   vp,
			   cnp->cn_nameptr,
			   cnp->cn_cred,
#ifdef HAVE_FREEBSD_THREAD
			   xfs_cnp_to_thread (cnp));
#else
			   xfs_cnp_to_proc (cnp));
#endif

    cleanup_cnp (cnp, error);

    if (dvp != vp)
	xfs_vfs_unlock(vp, p);

out:
#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)
    vput(dvp);
#endif

    return error;
}
#endif /* HAVE_VOP_LINK */

#ifdef HAVE_VOP_SYMLINK
int
xfs_symlink(struct vop_symlink_args * ap)
     /*
  IN WILLRELE struct vnode *dvp;
  OUT WILLRELE struct vnode **vpp;
  IN struct componentname *cnp;
  IN struct vattr *vap;
  IN char *target;
  */
{
    struct componentname *cnp = ap->a_cnp;
    struct vnode *dvp  = ap->a_dvp;
    struct vnode **vpp = ap->a_vpp;
    
    int error = xfs_symlink_common(dvp,
				   vpp,
				   cnp,
				   ap->a_vap,
				   ap->a_target);

    if (error == 0) {
	error = xfs_lookup_common(dvp, cnp, vpp);
	if (error == 0)
	    vput (*vpp);
    }
    cleanup_cnp (cnp, error);
#if !defined(__FreeBSD__)
    vput(dvp);
#endif
    return error;
}
#endif /* HAVE_VOP_SYMLINK */


#ifdef HAVE_VOP_READLINK
int
xfs_readlink(struct vop_readlink_args * ap)
     /* struct vnode *vp,
	     struct uio *uiop,
	     struct ucred *cred) */
{
    return xfs_readlink_common(ap->a_vp, ap->a_uio, ap->a_cred);
}
#endif /* HAVE_VOP_READLINK */

#ifdef HAVE_VOP_INACTIVE
int
xfs_inactive(struct vop_inactive_args * ap)
     /*struct vnode *vp,
	     struct ucred *cred)*/
{
#ifdef HAVE_FREEBSD_THREAD
    return xfs_inactive_common(ap->a_vp, xfs_curthread());
#else
    return xfs_inactive_common(ap->a_vp, xfs_curproc());
#endif
}
#endif /* HAVE_VOP_INACTICE */

#ifdef HAVE_VOP_RECLAIM
int
xfs_reclaim(struct vop_reclaim_args * ap)
     /*struct vop_reclaim_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
};*/
{
    struct vnode *vp = ap->a_vp;
    int ret;

    ret = xfs_reclaim_common(vp);
    vp->v_data = NULL;
    return ret;
}
#endif /* HAVE_VOP_RECLAIM */

/*
 * Do lock, unlock, and islocked with lockmgr if we have it.
 */

#if defined(HAVE_KERNEL_LOCKMGR) || defined(HAVE_KERNEL_DEBUGLOCKMGR)

#ifdef HAVE_VOP_LOCK
int
xfs_lock(struct vop_lock_args * ap)
{               
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    xfs_vnode_lock *l   = &xn->lock;
    int flags           = ap->a_flags;
    int ret;

    NNPFSDEB(XDEBVNOPS, ("xfs_lock: %lx, flags 0x%x\n",
		       (unsigned long)vp, flags));

    if (l == NULL)
      panic("xfs_lock: lock NULL");

    NNPFSDEB(XDEBVNOPS, ("xfs_lock before: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%llx\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount,
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));

#ifndef	DEBUG_LOCKS
#ifdef HAVE_FOUR_ARGUMENT_LOCKMGR
#ifdef HAVE_FREEBSD_THREAD
    ret = lockmgr(l, flags, &vp->v_interlock, ap->a_td);
#else
    ret = lockmgr(l, flags, &vp->v_interlock, ap->a_p);
#endif
#else
    ret = lockmgr(l, flags, NULL);
#endif
#else
#ifdef HAVE_FREEBSD_THREAD
    ret = debuglockmgr(l, flags, &vp->v_interlock, ap->a_td,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#else
    ret = debuglockmgr(l, flags, &vp->v_interlock, ap->a_p,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#endif
#endif
    NNPFSDEB(XDEBVNOPS, ("xfs_lock: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%llx\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount, 
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));
    return ret;
}
#endif /* HAVE_VOP_LOCK */

#ifdef HAVE_VOP_UNLOCK
int
xfs_unlock(struct vop_unlock_args * ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    xfs_vnode_lock *l   = &xn->lock;
    int flags           = ap->a_flags;
    int ret;

    if (l == NULL)
      panic("xfs_unlock: lock NULL");

    NNPFSDEB(XDEBVNOPS,
	   ("xfs_unlock: %lx, flags 0x%x, l %lx, ap %lx\n",
	    (unsigned long)vp, flags,
	    (unsigned long)l,
	    (unsigned long)ap));

    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%lld\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount, 
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));
#ifndef	DEBUG_LOCKS
#ifdef HAVE_FOUR_ARGUMENT_LOCKMGR
#ifdef HAVE_FREEBSD_THREAD
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_td);
#else
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_p);
#endif
#else
    ret = lockmgr (l, flags | LK_RELEASE, NULL);
#endif
#else
#ifdef HAVE_FREEBSD_THREAD
    ret = debuglockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_td,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#else
    ret = debuglockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_p,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#endif
#endif
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: return %d\n", ret));
    return ret;
}
#endif /* HAVE_VOP_UNLOCK */

#ifdef HAVE_VOP_ISLOCKED
int
xfs_islocked (struct vop_islocked_args *ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    xfs_vnode_lock *l   = &xn->lock;

    NNPFSDEB(XDEBVNOPS, ("xfs_islocked: %lx\n",
		       (unsigned long)vp));

#if defined(HAVE_TWO_ARGUMENT_LOCKSTATUS)
#ifdef HAVE_FREEBSD_THREAD
    return lockstatus (l, ap->a_td);
#else
    return lockstatus (l, ap->a_p);
#endif
#elif defined(HAVE_ONE_ARGUMENT_LOCKSTATUS)
    return lockstatus (l);
#else
#error what lockstatus?
#endif
}
#endif /* HAVE_VOP_ISLOCKED */

#else /* !HAVE_KERNEL_LOCKMGR && !HAVE_KERNEL_DEBUGLOCKMGR */

#ifdef HAVE_VOP_LOCK
int
xfs_lock(struct vop_lock_args * ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    NNPFSDEB(XDEBVNOPS, ("xfs_lock: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));

    while (vp->v_flag & VXLOCK) {
	vp->v_flag |= VXWANT;
	(void) tsleep((caddr_t)vp, PINOD, "xfs_vnlock", 0);
    }
    if (vp->v_tag == VT_NON)
	return (ENOENT);
    ++xn->vnlocks;
    return 0;
}
#endif /* HAVE_VOP_LOCK */

#ifdef HAVE_VOP_UNLOCK
int
xfs_unlock(struct vop_unlock_args * ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));

    --xn->vnlocks;
    if (xn->vnlocks < 0) {
	printf ("PANIC: xfs_unlock: unlocking unlocked\n");
	xn->vnlocks = 0;
    }
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: return\n"));

    return 0;
}
#endif /* HAVE_VOP_UNLOCK */

#ifdef HAVE_VOP_ISLOCKED
int
xfs_islocked (struct vop_islocked_args *ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    NNPFSDEB(XDEBVNOPS, ("xfs_islocked: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));

    return xn->vnlocks;
}
#endif /* HAVE_VOP_ISLOCKED */
#endif /* !HAVE_KERNEL_LOCKMGR */

#ifdef HAVE_VOP_ABORTOP
int
xfs_abortop (struct vop_abortop_args *ap)
     /* struct vnode *dvp;
   struct componentname *cnp; */
{
    struct componentname *cnp = ap->a_cnp;

    if ((cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
#if defined(HAVE_KERNEL_ZFREEI)
	zfreei(namei_zone, cnp->cn_pnbuf);
	ap->a_cnp->cn_flags &= ~HASBUF;
#elif defined(HAVE_KERNEL_UMA_ZFREE_ARG)
	uma_zfree_arg(namei_zone, cnp->cn_pnbuf, NULL);
	cnp->cn_flags &= ~HASBUF;
#elif defined(FREE_ZONE)
	FREE_ZONE(cnp->cn_pnbuf, cnp->cn_pnlen, M_NAMEI);
#elif defined(HAVE_KERNEL_ZFREE)
	zfree(namei_zone, cnp->cn_pnbuf);
	ap->a_cnp->cn_flags &= ~HASBUF;
#elif defined(PNBUF_PUT)
	PNBUF_PUT(cnp->cn_pnbuf);
#else
	pool_put(&namei_pool, cnp->cn_pnbuf);
#endif
    return 0;
}
#endif /* HAVE_VOP_ABORTOP */

#ifdef HAVE_VOP_MMAP
int
xfs_mmap(struct vop_mmap_args *ap)
     /*
	IN struct vnode *vp;
	IN int fflags;
	IN struct ucred *cred;
	IN struct proc *p;
	*/
{
    NNPFSDEB(XDEBVNOPS, ("xfs_mmap\n"));
#ifdef HAVE_KERNEL_GENFS_MMAP
    return genfs_mmap(ap);
#else
    return EOPNOTSUPP;
#endif
}
#endif /* HAVE_VOP_MMAP */

#ifdef HAVE_VOP_BMAP
int
xfs_bmap(struct vop_bmap_args *ap)
     /*	IN struct vnode *vp;
	IN daddr64_t bn;
	OUT struct vnode **vpp;
	IN daddr64_t *bnp;
	OUT int *runp;
	OUT int *runb;
	*/
{
    NNPFSDEB(XDEBVNOPS, ("xfs_bmap\n"));
    return EOPNOTSUPP;
}
#endif /* HAVE_VOP_BMAP */

#ifdef HAVE_VOP_GETPAGES

static size_t
get_pages_endlength (struct vop_getpages_args *ap)
{
#ifdef HAVE_STRUCT_VOP_GETPAGES_ARGS_A_OFFSET
    /* NetBSD ubc */
    return (ap->a_offset << PAGE_SHIFT) + *ap->a_count * PAGE_SIZE;
#else
    return (ap->a_reqpage << PAGE_SHIFT) +  ap->a_count * PAGE_SIZE;
#endif
}

int
xfs_getpages (struct vop_getpages_args *ap)
     /* Old BSD
	IN struct vnode *vp;
	IN vm_page_t *m;
	IN int count;
	IN int reqpage;
	IN vm_ooffset_t offset;
     */
    /* NetBSD UBC
	IN struct vnode *vp;
	IN voff_t offset;
	IN vm_page_t *m;
	IN int *count;
	IN int centeridx;
	IN vm_prot_t access_type;
	IN int advice;
	IN int flags;
    */
{
    int error;

    NNPFSDEB(XDEBVNOPS, ("xfs_getpages\n"));

#if HAVE_KERNEL_VNODE_PAGER_GENERIC_GETPAGES
    error = vnode_pager_generic_getpages (ap->a_vp, ap->a_m, 
					  ap->a_count, ap->a_reqpage);
#else
    error = xfs_data_valid (ap->a_vp, VNODE_TO_XNODE(ap->a_vp)->rd_cred,
			    xfs_curproc(), NNPFS_DATA_R,
			    get_pages_endlength(ap));
    if (error == 0)
	error = VOP_GETPAGES(DATA_FROM_VNODE(ap->a_vp), 
			     ap->a_offset, ap->a_m,
			     ap->a_count, ap->a_centeridx, ap->a_access_type,
			     ap->a_advice, ap->a_flags);
#endif
    NNPFSDEB(XDEBVNOPS, ("xfs_getpages = %d\n", error));
    return error;
}
#endif /* HAVE_VOP_GETPAGES */

#ifdef HAVE_VOP_PUTPAGES
int
xfs_putpages (struct vop_putpages_args *ap)
     /* Old BSD
        IN struct vnode *vp;
        IN vm_page_t *m;
        IN int count;
        IN int sync;
        IN int *rtvals;
        IN vm_ooffset_t offset;
     */
    /* NetBSD UBC (>= 1.5Y)
	IN struct vnode *vp;
	IN voff_t offlo;
	IN voff_t offhi;
	IN int flags;
    */
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    struct vnode *t     = DATA_FROM_XNODE(xn);
    int error;

    NNPFSDEB(XDEBVNOPS, ("xfs_putpages\n"));

    if (t == NULL)
	return 0;

#ifdef HAVE_STRUCT_VOP_PUTPAGES_ARGS_A_SYNC /* FreeBSD-style */
    xn->flags |= NNPFS_DATA_DIRTY;

    return VOP_PUTPAGES(t, ap->a_m, ap->a_count, ap->a_sync, ap->a_rtvals,
			ap->a_offset);
#else /* NetBSD-style */
#if defined(__NetBSD__) && __NetBSD_Version__  >= 105250000 
    /* XXX should only walk over those pages that is requested */
    if (vp->v_type == VREG && ap->a_flags & PGO_CLEANIT) {
	struct uvm_object *uobj = &t->v_uobj;
	struct vm_page *pg;
	int dirty = 0;

	pg = TAILQ_FIRST(&uobj->memq);

	while (pg && !dirty) {
	    dirty = pmap_is_modified(pg) || (pg->flags & PG_CLEAN) == 0;
	    pg = TAILQ_NEXT(pg, fq.queues.listq);
	}	

	if (dirty)
	    xn->flags |= NNPFS_DATA_DIRTY;
    }

    return VOP_PUTPAGES(t, ap->a_offlo, ap->a_offhi, ap->a_flags);
#else
    xn->flags |= NNPFS_DATA_DIRTY;
    return VOP_PUTPAGES(t, ap->a_m, ap->a_count, ap->a_flags, ap->a_rtvals);
#endif
#endif /* HAVE_STRUCT_VOP_PUTPAGES_ARGS_A_SYNC */
}
#endif /* HAVE_VOP_PUTPAGES */

#ifdef HAVE_VOP_CMP
int
xfs_cmp(struct vnode * vp1, struct vnode * vp2)
{
    NNPFSDEB(XDEBVNOPS, ("xfs_cmp\n"));
    return EOPNOTSUPP;
}
#endif /* HAVE_VOP_CMP */

#ifdef HAVE_VOP_REALVP
int
xfs_realvp(struct vnode * vp,
	   struct vnode ** vpp)
{
    NNPFSDEB(XDEBVNOPS, ("xfs_realvp\n"));
    return EOPNOTSUPP;
}
#endif /* HAVE_VOP_REALVP */

#ifdef HAVE_VOP_CNTL
int
xfs_cntl(struct vnode * vp,
	 int cmd,
	 caddr_t idata,
	 caddr_t odata,
	 int iflag,
	 int oflag)
{
    NNPFSDEB(XDEBVNOPS, ("xfs_cntl\n"));
    return EOPNOTSUPP;
}
#endif /* HAVE_VOP_CNTL */

#ifdef HAVE_VOP_PRINT
int
xfs_print (struct vop_print_args *v)
{
    struct vop_print_args *ap = v;
    xfs_printnode_common (ap->a_vp);
    return 0;
}
#endif

#ifdef HAVE_VOP_ADVLOCK
int
xfs_advlock(struct vop_advlock_args *v)
{
    struct vop_advlock_args *ap = v;
#if defined(HAVE_KERNEL_LF_ADVLOCK) && !defined(__APPLE__)
    struct xfs_node *xn = VNODE_TO_XNODE(ap->a_vp);
 
    return (lf_advlock(&xn->lockf, xn->attr.va_size, ap->a_id, ap->a_op,
	    ap->a_fl, ap->a_flags));
#else
     return EOPNOTSUPP;
#endif
}
#endif /* HAVE_VOP_ADVOCK */

#ifdef HAVE_VOP_REVOKE
int
xfs_revoke(struct vop_revoke_args *v)
{
#if defined(HAVE_KERNEL_GENFS_REVOKE)
    return genfs_revoke (v);
#elif defined(HAVE_KERNEL_VOP_REVOKE)
    return vop_revoke (v);
#else
    return EOPNOTSUPP;
#endif
}
#endif /* HAVE_VOP_REVOKE */

#ifdef HAVE_VOP_PAGEIN
int
xfs_pagein(struct vop_pagein_args *ap)
{
#ifdef __APPLE__
    struct uio uio;
    struct iovec iov;
    int ret;

    kernel_upl_map(kernel_map, ap->a_pl, &iov.iov_base);
    iov.iov_base+=ap->a_pl_offset;
    iov.iov_len=ap->a_size;

    uio.uio_iov=&iov;
    uio.uio_iovcnt=1;
    uio.uio_offset=ap->a_f_offset;
    uio.uio_resid=ap->a_size;
    uio.uio_segflg=UIO_SYSSPACE; /* XXX what is it? */
    uio.uio_rw=UIO_READ;
    uio.uio_procp=xfs_curproc();

    ret = VOP_READ(ap->a_vp, &uio, 0, ap->a_cred);

    /* Zero out rest of last page if there wasn't enough data in the file */
    if (ret == 0 && uio.uio_resid > 0)
	bzero(iov.iov_base, uio.uio_resid);
    
    kernel_upl_unmap(kernel_map, ap->a_pl);

    if (ret) {
	kernel_upl_abort_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
			       UPL_ABORT_ERROR | UPL_ABORT_FREE_ON_EMPTY);
    } else {
	kernel_upl_commit_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
				UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY,
				UPL_GET_INTERNAL_PAGE_LIST(ap->a_pl));
    }

    return ret;
#else
#error pagein on non apple ?
#endif
}
  
#endif

#ifdef HAVE_VOP_PAGEOUT
int
xfs_pageout(struct vop_pageout_args *ap)
{
#ifdef __APPLE__
    struct uio uio;
    struct iovec iov;
    int ret;

    kernel_upl_map(kernel_map, ap->a_pl, &iov.iov_base);
    iov.iov_base+=ap->a_pl_offset;
    iov.iov_len=ap->a_size;

    uio.uio_iov=&iov;
    uio.uio_iovcnt=1;
    uio.uio_offset=ap->a_f_offset;
    uio.uio_resid=ap->a_size;
    uio.uio_segflg=UIO_SYSSPACE; /* XXX what is it? */
    uio.uio_rw=UIO_WRITE;
    uio.uio_procp=xfs_curproc();

    ret = VOP_WRITE(ap->a_vp, &uio, 0, ap->a_cred);

    kernel_upl_unmap(kernel_map, ap->a_pl);

    if (ret) {
	kernel_upl_abort_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
			       UPL_ABORT_FREE_ON_EMPTY);
    } else {
	kernel_upl_commit_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
				UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY,
				UPL_GET_INTERNAL_PAGE_LIST(ap->a_pl));
    }

    return ret;
#else
#error pageout on non apple ?
#endif
}
#endif

#ifdef HAVE_VOP_CREATEVOBJECT
int
xfs_createvobject(struct vop_createvobject_args *ap)
/*
struct vop_createvobject_args {
	struct vnode *vp;
	struct ucred *cred;
	struct proc *p;
};
 */
{
    NNPFSDEB(XDEBVNOPS, ("xfs_createvobject\n"));

    return vop_stdcreatevobject (ap);
}
#endif /* HAVE_VOP_CREATEVOBJECT */

#ifdef HAVE_VOP_DESTROYVOBJECT
int
xfs_destroyvobject(struct vop_destroyvobject_args *ap)
/*
struct vop_destroyvobject_args {
	struct vnode *vp;
};
 */
{
    NNPFSDEB(XDEBVNOPS, ("xfs_destroyvobject\n"));

    return vop_stddestroyvobject (ap);
}
#endif /* HAVE_VOP_DESTROYVOBJECT */

#ifdef HAVE_VOP_GETVOBJECT
int
xfs_getvobject(struct vop_getvobject_args *ap)
/*
struct vop_getvobject_args {
	struct vnode *vp;
	struct vm_object **objpp;
};
 */
{
    NNPFSDEB(XDEBVNOPS, ("xfs_getvobject\n"));

    return vop_stdgetvobject (ap);
}
#endif /* HAVE_VOP_GETVOBJECT */

#ifdef HAVE_VOP_PATHCONF
int
xfs_pathconf(struct vop_pathconf_args *ap)
/*
struct vop_pathconf_args {
        struct vnodeop_desc *a_desc;
        struct vnode *a_vp;
        int a_name;
};
*/
{
    NNPFSDEB(XDEBVNOPS, ("xfs_pathconf\n"));

#ifdef HAVE_KERNEL_VOP_STDPATHCONF
    return vop_stdpathconf(ap);
#else
    return EOPNOTSUPP;
#endif
}
#endif



vop_t **xfs_vnodeop_p;

int
xfs_eopnotsupp (struct vop_generic_args *ap)
{
    NNPFSDEB(XDEBVNOPS, ("xfs_eopnotsupp %s\n", ap->a_desc->vdesc_name));
    return EOPNOTSUPP;
}

int
xfs_returnzero (struct vop_generic_args *ap)
{
    NNPFSDEB(XDEBVNOPS, ("xfs_returnzero %s\n", ap->a_desc->vdesc_name));
    return 0;
}

void
xfs_pushdirty(struct vnode *vp, struct ucred *cred, d_thread_t *p)
{
#if defined(__NetBSD_Version__) && __NetBSD_Version__ >= 105280000
    VOP_PUTPAGES(vp, 0, 0, PGO_ALLPAGES|PGO_SYNCIO|PGO_CLEANIT);
#elif defined(__APPLE__)
    ubc_pushdirty(vp);
#endif
}



static struct vnodeopv_entry_desc xfs_vnodeop_entries[] = {
    {&vop_default_desc, (vop_t *) xfs_eopnotsupp},
#ifdef HAVE_VOP_LOOKUP
#ifdef HAVE_KERNEL_VFS_CACHE_LOOKUP
    {&vop_lookup_desc, (vop_t *) vfs_cache_lookup },
#else
    {&vop_lookup_desc, (vop_t *) xfs_lookup },
#endif
#endif
#ifdef HAVE_VOP_CACHEDLOOKUP
    {&vop_cachedlookup_desc, (vop_t *) xfs_cachedlookup },
#endif
#ifdef HAVE_VOP_OPEN
    {&vop_open_desc, (vop_t *) xfs_open },
#endif
#ifdef HAVE_VOP_FSYNC
    {&vop_fsync_desc, (vop_t *) xfs_fsync },
#endif
#ifdef HAVE_VOP_CLOSE
    {&vop_close_desc, (vop_t *) xfs_close },
#endif
#ifdef HAVE_VOP_READ
    {&vop_read_desc, (vop_t *) xfs_read },
#endif
#ifdef HAVE_VOP_WRITE
    {&vop_write_desc, (vop_t *) xfs_write },
#endif
#ifdef HAVE_VOP_MMAP
    {&vop_mmap_desc, (vop_t *) xfs_mmap },
#endif
#ifdef HAVE_VOP_BMAP
    {&vop_bmap_desc, (vop_t *) xfs_bmap },
#endif
#ifdef HAVE_VOP_IOCTL
    {&vop_ioctl_desc, (vop_t *) xfs_ioctl },
#endif
#ifdef HAVE_VOP_SELECT
    {&vop_select_desc, (vop_t *) xfs_select },
#endif
#ifdef HAVE_VOP_SEEK
    {&vop_seek_desc, (vop_t *) xfs_seek },
#endif
#ifdef HAVE_VOP_POLL
    {&vop_poll_desc, (vop_t *) xfs_poll },
#endif
#ifdef HAVE_VOP_GETATTR
    {&vop_getattr_desc, (vop_t *) xfs_getattr },
#endif
#ifdef HAVE_VOP_SETATTR
    {&vop_setattr_desc, (vop_t *) xfs_setattr },
#endif
#ifdef HAVE_VOP_ACCESS
    {&vop_access_desc, (vop_t *) xfs_access },
#endif
#ifdef HAVE_VOP_CREATE
    {&vop_create_desc, (vop_t *) xfs_create },
#endif
#ifdef HAVE_VOP_REMOVE
    {&vop_remove_desc, (vop_t *) xfs_remove },
#endif
#ifdef HAVE_VOP_LINK
    {&vop_link_desc, (vop_t *) xfs_link },
#endif
#ifdef HAVE_VOP_RENAME
    {&vop_rename_desc, (vop_t *) xfs_rename },
#endif
#ifdef HAVE_VOP_MKDIR
    {&vop_mkdir_desc, (vop_t *) xfs_mkdir },
#endif
#ifdef HAVE_VOP_RMDIR
    {&vop_rmdir_desc, (vop_t *) xfs_rmdir },
#endif
#ifdef HAVE_VOP_READDIR
    {&vop_readdir_desc, (vop_t *) xfs_readdir },
#endif
#ifdef HAVE_VOP_SYMLINK
    {&vop_symlink_desc, (vop_t *) xfs_symlink },
#endif
#ifdef HAVE_VOP_READLINK
    {&vop_readlink_desc, (vop_t *) xfs_readlink },
#endif
#ifdef HAVE_VOP_INACTIVE
    {&vop_inactive_desc, (vop_t *) xfs_inactive },
#endif
#ifdef HAVE_VOP_RECLAIM
    {&vop_reclaim_desc, (vop_t *) xfs_reclaim },
#endif
#ifdef HAVE_VOP_LOCK
    {&vop_lock_desc, (vop_t *) xfs_lock },
#endif
#ifdef HAVE_VOP_UNLOCK
    {&vop_unlock_desc, (vop_t *) xfs_unlock },
#endif
#ifdef HAVE_VOP_ISLOCKED
    {&vop_islocked_desc, (vop_t *) xfs_islocked },
#endif
#ifdef HAVE_VOP_ABORTOP
    {&vop_abortop_desc, (vop_t *) xfs_abortop },
#endif
#ifdef HAVE_VOP_GETPAGES
    {&vop_getpages_desc, (vop_t *) xfs_getpages },
#endif
#ifdef HAVE_VOP_PUTPAGES
    {&vop_putpages_desc, (vop_t *) xfs_putpages },
#endif
#ifdef HAVE_VOP_REVOKE
    {&vop_revoke_desc, (vop_t *) xfs_revoke },
#endif
#ifdef HAVE_VOP_PRINT
    {&vop_print_desc, (vop_t *) xfs_print}, 
#endif
#ifdef HAVE_VOP_ADVLOCK
    {&vop_advlock_desc, (vop_t *) xfs_advlock },
#endif
#ifdef HAVE_VOP_PAGEIN
    {&vop_pagein_desc, (vop_t *) xfs_pagein },
#endif
#ifdef HAVE_VOP_PAGEOUT
    {&vop_pageout_desc, (vop_t *) xfs_pageout },
#endif
#ifdef HAVE_VOP_CREATEVOBJECT
    {&vop_createvobject_desc, (vop_t *) xfs_createvobject },
#endif
#ifdef HAVE_VOP_DESTROYVOBJECT
    {&vop_destroyvobject_desc, (vop_t *) xfs_destroyvobject },
#endif
#ifdef HAVE_VOP_GETVOBJECT
    {&vop_getvobject_desc, (vop_t *) xfs_getvobject },
#endif
#ifdef HAVE_VOP_PATHCONF
    {&vop_pathconf_desc, (vop_t *) xfs_pathconf },
#endif
    {(struct vnodeop_desc *) NULL, (int (*) (void *)) NULL}
};

struct vnodeopv_desc xfs_vnodeop_opv_desc =
{&xfs_vnodeop_p, xfs_vnodeop_entries};

#ifdef VNODEOP_SET
VNODEOP_SET(xfs_vnodeop_opv_desc);
#endif
@


1.14
log
@physmem allocator: change the view of free memory from single free pages
to free ranges.
Classify memory based on region with associated use-counter (which is used
to construct a priority list of where to allocate memory).

Based on code from tedu@@, help from many.
Ok art@@
@
text
@@


1.13
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1122 1
a1122 1
	    pg = TAILQ_NEXT(pg, listq);
@


1.12
log
@daddr64_t (in comments)
@
text
@d598 1
a598 2
	MALLOC(cookies, xfs_cookie_t *, ncookies * sizeof(xfs_cookie_t),
	       M_TEMP, M_WAITOK);
@


1.11
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1011 1
a1011 1
	IN daddr_t bn;
d1013 1
a1013 1
	IN daddr_t *bnp;
@


1.10
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1176 1
a1176 3
    struct vop_print_args /* {
	struct vnode	*a_vp;
    } */ *ap = v;
d1186 1
a1186 7
    struct vop_advlock_args /* {
	struct vnode *a_vp;
	caddr_t  a_id;
	int  a_op;
	struct flock *a_fl;
	int  a_flags;
    } */ *ap = v;
@


1.9
log
@Make lf_advlock glue work for AFS so flock/fcntl lock requests will work
on the local machine (like NFS). This does not yet implement whole file AFS
locking (arla doesn't do that yet).
ok tedu@@ art@@
@
text
@d806 1
a806 1
    ret = lockmgr(l, flags, &vp->v_interlock);
d860 1
a860 1
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock);
@


1.8
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@a1187 1
#if 0
d1195 1
a1195 20

    struct xfs_node *xn = VNODE_TO_XNODE(ap->a_vp);
    int ret;
    xfs_locktype_t locktype;

/*     if (NNPFS_TOKEN_GOT(xn,  */

    if (ap->a_fl.l_start != 0 ||
	ap->a_fl.l_end != 0)
	printf ("WARN: someone is trying byte-range locking\n");
    
    switch (ap->a_op) {
    case F_SETLCK:
	locktype = NNPFS_READLOCK;
	break;

    ret = xfs_advlock_common (xn, );

    return ret;
#elif defined(HAVE_KERNEL_LF_ADVLOCK) && !defined(__OpenBSD__) && !defined(__APPLE__)
d1198 3
a1200 2
    return lf_advlock(ap, &xn->lockf, xn->attr.va_size);
  #else
@


1.7
log
@fix PR 3552 by removing ifdef cruft
ok (and sent earlier by) tedu@@
@
text
@d54 2
d358 1
a358 1
	FREE (cnp->cn_pnbuf, M_NAMEI);
d982 1
a982 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
@


1.6
log
@Fix include stuff, unused variables and statics and other small things needed
to compile in our tree.
@
text
@a712 1
#if (!defined(__FreeBSD__) || __FreeBSD_version < 400012) && (!defined(__NetBSD__) || __NetBSD_Version__ < 105240000) && (!defined(__OpenBSD__) || OpenBSD <= 200211)
a714 1
#endif
@


1.6.2.1
log
@MFC:
Fix by beck@@

fix PR 3552 by removing ifdef cruft

ok deraadt@@ beck@@
@
text
@d713 1
d716 1
@


1.5
log
@Merge
@
text
@d1188 1
d1196 1
a1196 1
#if 0
@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d35 1
a35 1
 * XFS operations.
d54 1
a54 1
RCSID("$Id: xfs_vnodeops-bsd.c,v 1.1.1.1 2002/06/07 03:33:00 hin Exp $");
d61 1
a61 1
static int
d71 3
d75 1
d80 1
a80 1
static int
d93 3
d98 1
d103 1
a103 1
static int
d112 3
d116 1
d121 1
a121 1
static int
d135 1
a135 1
static int
d149 1
a149 1
static int
d157 1
a157 1
    XFSDEB(XDEBVNOPS, ("xfs_ioctl\n"));
d164 1
a164 1
static int
d170 1
a170 1
    XFSDEB(XDEBVNOPS, ("xfs_select\n"));
d177 1
a177 1
static int
d189 1
a189 1
    XFSDEB(XDEBVNOPS, ("xfs_seek\n"));
d195 1
a195 1
static int
d203 1
a203 1
    XFSDEB(XDEBVNOPS, ("xfs_poll\n"));
d209 1
a209 1
static int
d216 3
d220 1
d225 1
a225 1
static int
d233 3
d237 1
d242 1
a242 1
static int
d251 3
d255 1
d260 1
a260 1
static int
d274 1
a274 1
    XFSDEB(XDEBVNOPS, ("xfs_lookup: (%s, %ld), nameiop = %lu, flags = %lu\n",
d301 3
d305 1
d314 1
a314 1
    XFSDEB(XDEBVNOPS, ("xfs_lookup: error = %d\n", error));
d321 1
a321 1
static int
d342 1
a342 1
#ifdef HAVE_KERNEL_ZFREEI
d345 3
d350 3
d362 1
a362 1
static int
d369 5
a373 1
    struct proc *p     = xfs_cnp_to_proc(cnp);
d388 1
a388 1
    XFSDEB(XDEBVNOPS, ("xfs_create: error = %d\n", error));
d395 1
a395 1
static int
d405 4
d411 1
d438 1
a438 1
static int
d461 3
d465 1
d479 1
a479 1
static int
d491 5
a495 1
    struct proc *p     = xfs_cnp_to_proc(cnp);
d509 1
a509 1
    XFSDEB(XDEBVNOPS, ("xfs_mkdir: error = %d\n", error));
d516 1
a516 1
static int
d528 3
d532 1
d557 1
a557 1
static int
d569 3
d573 1
d614 1
a614 1
static int
d625 5
a629 1
    struct proc *p = cnp->cn_proc;
d654 3
d663 1
d670 3
d674 1
d691 1
a691 1
static int
d713 1
a713 1
#if (!defined(__FreeBSD__) || __FreeBSD_version < 400012) && (!defined(__NetBSD__) || __NetBSD_Version__ < 105240000) && (!defined(__OpenBSD__) || OpenBSD < 200107)
d728 1
a728 1
static int
d739 1
a739 1
static int
d744 3
d748 1
d753 1
a753 1
static int
d776 1
a776 1
static int
d785 1
a785 1
    XFSDEB(XDEBVNOPS, ("xfs_lock: %lx, flags 0x%x\n",
d791 6
a796 4
    XFSDEB(XDEBVNOPS, ("xfs_lock before: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));
d800 3
d804 1
d809 4
d816 7
a822 4
    XFSDEB(XDEBVNOPS, ("xfs_lock: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));
d828 1
a828 1
static int
d840 1
a840 1
    XFSDEB(XDEBVNOPS,
d846 6
a851 4
    XFSDEB(XDEBVNOPS, ("xfs_unlock: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));
d854 3
d858 1
d863 4
d870 2
a871 1
    XFSDEB(XDEBVNOPS, ("xfs_unlock: return %d\n", ret));
d877 1
a877 1
static int
d884 1
a884 1
    XFSDEB(XDEBVNOPS, ("xfs_islocked: %lx\n",
d888 3
d892 1
d904 1
a904 1
static int
d910 1
a910 1
    XFSDEB(XDEBVNOPS, ("xfs_lock: %lx, %d\n",
d925 1
a925 1
static int
d930 1
a930 1
    XFSDEB(XDEBVNOPS, ("xfs_unlock: %lx, %d\n",
d938 1
a938 1
    XFSDEB(XDEBVNOPS, ("xfs_unlock: return\n"));
d945 1
a945 1
static int
d951 1
a951 1
    XFSDEB(XDEBVNOPS, ("xfs_islocked: %lx, %d\n",
d960 1
a960 1
static int
d968 1
a968 1
#ifdef HAVE_KERNEL_ZFREEI
d971 3
d976 3
d989 1
a989 1
static int
d998 4
a1001 1
    XFSDEB(XDEBVNOPS, ("xfs_mmap\n"));
d1003 1
d1008 1
a1008 1
static int
d1018 1
a1018 1
    XFSDEB(XDEBVNOPS, ("xfs_bmap\n"));
d1024 13
a1036 1
static int
d1058 1
a1058 1
    XFSDEB(XDEBVNOPS, ("xfs_getpages\n"));
d1064 3
a1066 2
    error = xfs_data_valid (ap->a_vp, VNODE_TO_XNODE(ap->a_vp)->cred,
			    xfs_curproc(), XFS_DATA_R);
d1073 1
a1073 1
    XFSDEB(XDEBVNOPS, ("xfs_getpages = %d\n", error));
d1079 1
a1079 1
static int
d1101 1
a1101 1
    XFSDEB(XDEBVNOPS, ("xfs_putpages\n"));
d1103 2
a1104 1
    xn->flags |= XFS_DATA_DIRTY;
d1107 2
d1113 17
d1132 1
d1140 1
a1140 1
static int
d1143 1
a1143 1
    XFSDEB(XDEBVNOPS, ("xfs_cmp\n"));
d1149 1
a1149 1
static int
d1153 1
a1153 1
    XFSDEB(XDEBVNOPS, ("xfs_realvp\n"));
d1159 1
a1159 1
static int
d1167 1
a1167 1
    XFSDEB(XDEBVNOPS, ("xfs_cntl\n"));
d1173 2
a1174 2
static int
xfs_print (struct vnode *vp)
d1176 4
a1179 1
    xfs_printnode_common (vp);
a1183 1
#if 0
d1185 2
a1186 2
static int
xfs_advlock(void *v)
d1195 1
a1195 1

d1200 1
a1200 1
/*     if (XFS_TOKEN_GOT(xn,  */
a1201 1
#if 0
d1208 1
a1208 1
	locktype = XFS_READLOCK;
d1214 7
a1220 3
#else
    return 0;
#endif 			      
a1222 1
#endif
d1225 2
a1226 2
static int
xfs_revoke(void *v)
d1239 1
a1239 1
static int
d1261 4
d1278 1
a1278 1
    return (VOP_READ(ap->a_vp, ap->a_uio, ap->a_ioflag, ap->a_cred));
d1285 1
a1285 1
static int
d1320 1
a1320 1
    return (VOP_WRITE(ap->a_vp, ap->a_uio, ap->a_ioflag, ap->a_cred));
d1326 1
a1326 1
static int
d1336 1
a1336 1
    XFSDEB(XDEBVNOPS, ("xfs_createvobject\n"));
d1343 1
a1343 1
static int
d1351 1
a1351 1
    XFSDEB(XDEBVNOPS, ("xfs_destroyvobject\n"));
d1358 1
a1358 1
static int
d1367 1
a1367 1
    XFSDEB(XDEBVNOPS, ("xfs_getvobject\n"));
d1373 23
d1401 1
a1401 1
    XFSDEB(XDEBVNOPS, ("xfs_eopnotsupp %s\n", ap->a_desc->vdesc_name));
d1408 1
a1408 1
    XFSDEB(XDEBVNOPS, ("xfs_returnzero %s\n", ap->a_desc->vdesc_name));
d1412 12
a1534 1
#if 0
a1537 1
#endif
d1552 3
@


1.3
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
d38 4
d54 1
a54 1
RCSID("$Id: xfs_vnodeops-bsd.c,v 1.76 2000/08/02 00:57:19 assar Exp $");
d256 4
a267 9
    if ((error != 0 && error != EJUSTRETURN)
	|| (!lockparent
	    && ap->a_dvp != *(ap->a_vpp)
#ifdef PDIRUNLOCK
	    && (cnp->cn_flags & PDIRUNLOCK) == 0
#endif
	))
	xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_proc(cnp));

d271 15
d319 2
d364 4
a367 1
    int error = xfs_remove_common(ap->a_dvp, ap->a_vp, cnp->cn_nameptr, 
d371 19
d472 2
d480 8
d531 3
a533 1
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen))
d535 1
d542 2
d631 5
a635 2
    int error = xfs_symlink_common(ap->a_dvp,
				   ap->a_vpp,
d640 7
d648 3
d835 1
a835 2
    XFSDEB(XDEBVNOPS, ("xfs_unlock: lock = %x\n",
		       vp->v_interlock.lock_data));
d870 2
d913 1
a913 1
     /*
d919 11
a929 1
	*/
d939 7
a945 1
    error = EOPNOTSUPP;
d955 1
a955 1
     /*
d962 7
a968 1
	*/
d979 1
d982 7
d1091 32
d1124 1
d1133 32
d1166 1
d1170 48
d1355 9
@


1.3.8.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
a42 4
#ifdef __APPLE__
#define MACH_KERNEL 1
#endif

d55 1
a55 1
RCSID("$Id: xfs_vnodeops-bsd.c,v 1.3 2000/09/11 14:26:54 art Exp $");
a256 4
#ifdef PDIRUNLOCK
    cnp->cn_flags &= ~PDIRUNLOCK;
#endif

d265 9
a276 15
    if (error == 0 || error == EJUSTRETURN) {
	if (ap->a_dvp == *(ap->a_vpp)) {
	    /* if we looked up ourself, do nothing */
	} else if (!(cnp->cn_flags & ISLASTCN) || !lockparent) {
	    /* if we isn't last component and is isn't requested,
	     * return parent unlocked */
	    xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_proc(cnp));
#ifdef PDIRUNLOCK
	    cnp->cn_flags |= PDIRUNLOCK;
#endif
	}
    } else {
	/* in case of a error do nothing  */
    } 
    
a309 2
#elif defined(PNBUF_PUT)
	PNBUF_PUT(cnp->cn_pnbuf);
d353 1
a353 4
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp  = ap->a_vp;

    int error = xfs_remove_common(dvp, vp, cnp->cn_nameptr, 
a356 19

#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif
    
#ifdef __APPLE__
    if (error == 0) {
	if (UBCINFOEXISTS(vp)) {
	    ubc_setsize(vp, 0);
	    ubc_release(vp);
	    ubc_uncache(vp);
	}
    }
#endif

a438 2
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp  = ap->a_vp;
a444 8
#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif

d488 1
a488 3
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen)) {
	    if (dp->d_reclen <= 0)
		break;
a489 1
	}
a495 2
	    if (dp->d_reclen <= 0)
		break;
d583 2
a584 5
    struct vnode *dvp  = ap->a_dvp;
    struct vnode **vpp = ap->a_vpp;
    
    int error = xfs_symlink_common(dvp,
				   vpp,
a588 7
    if (error == 0) {
	error = xfs_lookup_common(dvp, cnp, vpp);
#if (!defined(__FreeBSD__) || __FreeBSD_version < 400012) && (!defined(__NetBSD__) || __NetBSD_Version__ < 105240000) && (!defined(__OpenBSD__) || OpenBSD < 200107)
	if (error == 0)
	    vput (*vpp);
#endif
    }
a589 3
#if !defined(__FreeBSD__)
    vput(dvp);
#endif
d774 2
a775 1
    XFSDEB(XDEBVNOPS, ("xfs_unlock: return\n"));
a809 2
#elif defined(PNBUF_PUT)
	PNBUF_PUT(cnp->cn_pnbuf);
d851 1
a851 1
     /* Old BSD
d857 1
a857 11
     */
    /* NetBSD UBC
	IN struct vnode *vp;
	IN voff_t offset;
	IN vm_page_t *m;
	IN int *count;
	IN int centeridx;
	IN vm_prot_t access_type;
	IN int advice;
	IN int flags;
    */
d867 1
a867 7
    error = xfs_data_valid (ap->a_vp, VNODE_TO_XNODE(ap->a_vp)->cred,
			    xfs_curproc(), XFS_DATA_R);
    if (error == 0)
	error = VOP_GETPAGES(DATA_FROM_VNODE(ap->a_vp), 
			     ap->a_offset, ap->a_m,
			     ap->a_count, ap->a_centeridx, ap->a_access_type,
			     ap->a_advice, ap->a_flags);
d877 1
a877 1
     /* Old BSD
d884 1
a884 7
     */
    /* NetBSD UBC (>= 1.5Y)
	IN struct vnode *vp;
	IN voff_t offlo;
	IN voff_t offhi;
	IN int flags;
    */
a894 1
#ifdef HAVE_STRUCT_VOP_PUTPAGES_ARGS_A_SYNC /* FreeBSD-style */
a896 7
#else /* NetBSD-style */
#if defined(__NetBSD__) && __NetBSD_Version__  >= 105250000 
    return VOP_PUTPAGES(t, ap->a_offlo, ap->a_offhi, ap->a_flags);
#else
    return VOP_PUTPAGES(t, ap->a_m, ap->a_count, ap->a_flags, ap->a_rtvals);
#endif
#endif /* HAVE_STRUCT_VOP_PUTPAGES_ARGS_A_SYNC */
a998 32
#ifdef __APPLE__
    struct uio uio;
    struct iovec iov;
    int ret;

    kernel_upl_map(kernel_map, ap->a_pl, &iov.iov_base);
    iov.iov_base+=ap->a_pl_offset;
    iov.iov_len=ap->a_size;

    uio.uio_iov=&iov;
    uio.uio_iovcnt=1;
    uio.uio_offset=ap->a_f_offset;
    uio.uio_resid=ap->a_size;
    uio.uio_segflg=UIO_SYSSPACE; /* XXX what is it? */
    uio.uio_rw=UIO_READ;
    uio.uio_procp=xfs_curproc();

    ret = VOP_READ(ap->a_vp, &uio, 0, ap->a_cred);

    kernel_upl_unmap(kernel_map, ap->a_pl);

    if (ret) {
	kernel_upl_abort_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
			       UPL_ABORT_ERROR | UPL_ABORT_FREE_ON_EMPTY);
    } else {
	kernel_upl_commit_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
				UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY,
				UPL_GET_INTERNAL_PAGE_LIST(ap->a_pl));
    }

    return ret;
#else
a999 1
#endif
a1007 32
#ifdef __APPLE__
    struct uio uio;
    struct iovec iov;
    int ret;

    kernel_upl_map(kernel_map, ap->a_pl, &iov.iov_base);
    iov.iov_base+=ap->a_pl_offset;
    iov.iov_len=ap->a_size;

    uio.uio_iov=&iov;
    uio.uio_iovcnt=1;
    uio.uio_offset=ap->a_f_offset;
    uio.uio_resid=ap->a_size;
    uio.uio_segflg=UIO_SYSSPACE; /* XXX what is it? */
    uio.uio_rw=UIO_WRITE;
    uio.uio_procp=xfs_curproc();

    ret = VOP_WRITE(ap->a_vp, &uio, 0, ap->a_cred);

    kernel_upl_unmap(kernel_map, ap->a_pl);

    if (ret) {
	kernel_upl_abort_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
			       UPL_ABORT_FREE_ON_EMPTY);
    } else {
	kernel_upl_commit_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
				UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY,
				UPL_GET_INTERNAL_PAGE_LIST(ap->a_pl));
    }

    return ret;
#else
a1008 1
#endif
a1011 48
#ifdef HAVE_VOP_CREATEVOBJECT
static int
xfs_createvobject(struct vop_createvobject_args *ap)
/*
struct vop_createvobject_args {
	struct vnode *vp;
	struct ucred *cred;
	struct proc *p;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_createvobject\n"));

    return vop_stdcreatevobject (ap);
}
#endif /* HAVE_VOP_CREATEVOBJECT */

#ifdef HAVE_VOP_DESTROYVOBJECT
static int
xfs_destroyvobject(struct vop_destroyvobject_args *ap)
/*
struct vop_destroyvobject_args {
	struct vnode *vp;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_destroyvobject\n"));

    return vop_stddestroyvobject (ap);
}
#endif /* HAVE_VOP_DESTROYVOBJECT */

#ifdef HAVE_VOP_GETVOBJECT
static int
xfs_getvobject(struct vop_getvobject_args *ap)
/*
struct vop_getvobject_args {
	struct vnode *vp;
	struct vm_object **objpp;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_getvobject\n"));

    return vop_stdgetvobject (ap);
}
#endif /* HAVE_VOP_GETVOBJECT */

a1148 9
#endif
#ifdef HAVE_VOP_CREATEVOBJECT
    {&vop_createvobject_desc, (vop_t *) xfs_createvobject },
#endif
#ifdef HAVE_VOP_DESTROYVOBJECT
    {&vop_destroyvobject_desc, (vop_t *) xfs_destroyvobject },
#endif
#ifdef HAVE_VOP_GETVOBJECT
    {&vop_getvobject_desc, (vop_t *) xfs_getvobject },
@


1.2
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d51 1
a51 1
#include <vm/vm.h>
d53 1
d55 1
a55 1
RCSID("$OpenBSD: xfs_vnodeops-bsd.c,v 1.1 1999/04/30 01:59:01 art Exp $");
d72 1
a72 6
    XFSDEB(XDEBVNOPS, ("xfs_open\n"));

    if (ap->a_mode & FWRITE)
	return xfs_open_valid(ap->a_vp, ap->a_cred, XFS_OPEN_NW);
    else
	return xfs_open_valid(ap->a_vp, ap->a_cred, XFS_OPEN_NR);
d202 2
a203 1
	    struct ucred *cred) */
d205 1
a205 1
    return xfs_getattr_common(ap->a_vp, ap->a_vap, ap->a_cred);
d212 1
a212 2
     /*
struct vnode *vp,
d214 2
a215 1
	    struct ucred *cred)
d218 1
a218 1
    return xfs_setattr_common(ap->a_vp, ap->a_vap, ap->a_cred);
d228 2
a229 1
	   struct ucred *cred)
d232 1
a232 1
    return xfs_access_common(ap->a_vp, ap->a_mode, ap->a_cred);
d248 2
d265 9
d293 1
a293 1
    return xfs_lookup(ap);
d297 19
d318 1
a318 1
xfs_create(struct vop_create_args * ap)
d324 1
d327 1
a327 4
    error = xfs_create_common(dvp,
			      name,
			      ap->a_vap,
			      cred);
d329 5
a333 3
    if (error == 0)
	error = xfs_lookup_name(dvp, name, xfs_cnp_to_proc(cnp),
				cred, ap->a_vpp);
d335 2
a336 5
    if (error != 0 || (ap->a_cnp->cn_flags & SAVESTART) == 0)
#ifdef HAVE_KERNEL_ZFREEI
	zfreei(namei_zone, ap->a_cnp->cn_pnbuf);
#else
	free (ap->a_cnp->cn_pnbuf, M_NAMEI);
d354 1
a354 8
				  cnp->cn_cred);

    if (error != 0 || (cnp->cn_flags & SAVESTART) == 0)
#ifdef HAVE_KERNEL_ZFREEI
	zfreei(namei_zone, cnp->cn_pnbuf);
#else
	free (cnp->cn_pnbuf, M_NAMEI);
#endif
d356 1
d384 2
a385 1
				  ap->a_tcnp->cn_cred);
d411 1
d414 1
a414 4
    error = xfs_mkdir_common(dvp,
			     name,
			     ap->a_vap,
			     cred);
d417 1
a417 2
	error = xfs_lookup_name(dvp, name, xfs_cnp_to_proc(cnp),
				cred, ap->a_vpp);
d419 1
a419 7
    if (error != 0 || (ap->a_cnp->cn_flags & SAVESTART) == 0) {
#ifdef HAVE_KERNEL_ZFREEI
	zfreei(namei_zone, ap->a_cnp->cn_pnbuf);
#else
	free (ap->a_cnp->cn_pnbuf, M_NAMEI);
#endif
    }
d421 2
a422 2
#if defined(__OpenBSD__) 
    vput(ap->a_dvp);
d425 1
a425 1
    XFSDEB(XDEBVNOPS, ("xfs_create: error = %d\n", error));
d440 3
a442 8
				 cnp->cn_nameptr, cnp->cn_cred);

    if (error != 0 || (cnp->cn_flags & SAVESTART) == 0)
#ifdef HAVE_KERNEL_ZFREEI
	zfreei(namei_zone, cnp->cn_pnbuf);
#else
	free (cnp->cn_pnbuf, M_NAMEI);
#endif
d444 1
d450 9
d468 1
a468 1
    off =  ap->a_uio->uio_offset;
d471 2
a472 1
			      ap->a_eofflag);
d476 1
a476 1
	struct dirent* dp;
d478 2
a479 10
#if defined(__FreeBSD__) || defined (__OpenBSD__)
	u_long *cookies;
	struct dirent* dpStart;
	struct dirent* dpEnd;
	u_long *cookiep;
#else
	off_t *cookies;
	cookies = ap->a_cookies;
	ncookies = ap->a_ncookies;
#endif	
d482 7
a488 7
	dp = (struct dirent *)
	    (uio->uio_iov->iov_base - (uio->uio_offset - off));
#if defined(__FreeBSD__) || defined (__OpenBSD__)
	dpEnd = (struct dirent *) uio->uio_iov->iov_base;
	for (dpStart = dp, ncookies = 0;
	     dp < dpEnd;
	     dp = (struct dirent *)((caddr_t) dp + dp->d_reclen))
d490 6
a495 5
	MALLOC(cookies, u_long *, ncookies * sizeof(u_long),
		       M_TEMP, M_WAITOK);
	for (dp = dpStart, cookiep = cookies;
	     dp < dpEnd;
	     dp = (struct dirent *)((caddr_t) dp + dp->d_reclen)) {
d497 1
a497 1
	    *cookiep++ = (u_int) off;
a500 9
#else /* __NetBSD__ */
	while (ncookies-- && off < uio->uio_offset) {
	    if (dp->d_reclen == 0)
		break;
	    off += dp->d_reclen;
	    *(cookies++) = off;
	    dp = (struct dirent *)((caddr_t)dp + dp->d_reclen);
	}
#endif
d516 5
a520 1
    int error = xfs_link_common(
d522 5
a526 3
			   ap->a_dvp, 
#elif defined(__FreeBSD__)
			   ap->a_tdvp, 
d528 25
a552 1
			   ap->a_vp, 
d554 7
a560 1
			   cnp->cn_cred);
d562 3
a564 5
    if (error != 0 || (cnp->cn_flags & SAVESTART) == 0)
#ifdef HAVE_KERNEL_ZFREEI
	zfreei(namei_zone, cnp->cn_pnbuf);
#else
	free (cnp->cn_pnbuf, M_NAMEI);
d585 1
a585 3
				   cnp->cn_nameptr,
				   xfs_cnp_to_proc(cnp),
				   cnp->cn_cred,
d589 1
a589 7
    if (error != 0 || (cnp->cn_flags & SAVESTART) == 0) {
#ifdef HAVE_KERNEL_ZFREEI
	zfreei(namei_zone, cnp->cn_pnbuf);
#else
	free (cnp->cn_pnbuf, M_NAMEI);
#endif
    }
a611 5
#if 0
    /*
     * This break freebsd 2.2.x
     */
    
a612 3
#else
    return 0;
#endif
d624 6
a629 1
    return xfs_reclaim_common(ap->a_vp);
d634 1
a634 13
 * The lock, unlock, islocked vnode operations.
 *
 * This should be done with the generic locking function for the
 * appropriate dialect of BSD (vop_nolock, genfs_nolock, ...).  But,
 * most of these functions are commented out and don't work enough to
 * allow xfs_islocked to figure if the vnode is locked or not, which
 * other parts of the kernel depend on.
 *
 * We try do locking the folling way:
 *  If we have LK_INTERLOCK & co:
 *    Do no locking with (we should use lockmgr)
 *  else
 *    When VXLOCK is set loop
d637 2
d642 39
d684 3
d688 2
a689 1
    XFSDEB(XDEBVNOPS, ("xfs_lock: %p, %d\n", vp, xn->vnlocks));
d691 24
a714 3
#if defined(HAVE_LK_INTERLOCK) && !defined(HAVE_ONE_ARGUMENT_VOP_LOCK)
    {
	int flags = ap->a_flags;
d716 7
a722 2
	if (flags & LK_INTERLOCK)
	    simple_unlock(&vp->v_interlock);
d724 7
a730 3
	if (!(flags & LK_TYPE_MASK))
	    return 0;
    }
d732 17
a754 1
#endif
d766 2
a767 1
    XFSDEB(XDEBVNOPS, ("xfs_unlock: %p, %d\n", vp, xn->vnlocks));
a768 10
#if defined(HAVE_LK_INTERLOCK) && !defined(HAVE_ONE_ARGUMENT_VOP_LOCK)
    {
	int flags = ap->a_flags;

	if (flags & LK_INTERLOCK)
	    simple_unlock(&vp->v_interlock);
	if (!(flags & LK_TYPE_MASK))
	    return 0;
    }
#endif
d774 3
d788 2
a789 1
    XFSDEB(XDEBVNOPS, ("xfs_islocked: %p, %d\n", vp, xn->vnlocks));
d794 1
d807 3
d886 5
d893 4
a896 6
#if HAVE_KERNEL_VNODE_PAGER_GENERIC_PUTPAGES
    return vnode_pager_generic_putpages (ap->a_vp, ap->a_m, ap->a_count, 
					 ap->a_sync, ap->a_rtvals);
#else
    return EOPNOTSUPP;
#endif
d995 17
d1015 1
a1015 1
xfs_eopnotsupp (void *v)
d1017 1
a1017 1
    XFSDEB(XDEBVNOPS, ("xfs_eopnotsupp\n"));
d1022 1
a1022 1
xfs_returnzero (void *v)
d1024 1
a1024 1
    XFSDEB(XDEBVNOPS, ("xfs_returnzero\n"));
d1143 6
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 2
d56 1
a56 1
RCSID("$Id: xfs_vnodeops-bsd.c,v 1.47 1999/03/01 08:57:15 assar Exp $");
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
a42 4
#ifdef __APPLE__
#define MACH_KERNEL 1
#endif

d51 1
a51 1
#ifdef HAVE_VM_VNODE_PAGER_H
a52 1
#endif
d54 1
a54 1
RCSID("$Id: xfs_vnodeops-bsd.c,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $");
d71 6
a76 1
    return xfs_open_common (ap->a_vp, ap->a_mode, ap->a_cred, ap->a_p);
d206 1
a206 2
	    struct ucred *cred,
	    struct proc *p) */
d208 1
a208 1
    return xfs_getattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_p);
d215 2
a216 1
     /* struct vnode *vp,
d218 1
a218 2
	    struct ucred *cred,
	    struct proc *p)
d221 1
a221 1
    return xfs_setattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_p);
d231 1
a231 2
	   struct ucred *cred,
	   struct proc *p)
d234 1
a234 1
    return xfs_access_common(ap->a_vp, ap->a_mode, ap->a_cred, ap->a_p);
a249 2
    int lockparent = (cnp->cn_flags & (LOCKPARENT | ISLASTCN))
	== (LOCKPARENT | ISLASTCN);
a256 4
#ifdef PDIRUNLOCK
    cnp->cn_flags &= ~PDIRUNLOCK;
#endif

a267 15
    if (error == 0 || error == EJUSTRETURN) {
	if (ap->a_dvp == *(ap->a_vpp)) {
	    /* if we looked up ourself, do nothing */
	} else if (!(cnp->cn_flags & ISLASTCN) || !lockparent) {
	    /* if we isn't last component and is isn't requested,
	     * return parent unlocked */
	    xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_proc(cnp));
#ifdef PDIRUNLOCK
	    cnp->cn_flags |= PDIRUNLOCK;
#endif
	}
    } else {
	/* in case of a error do nothing  */
    } 
    
d284 1
a284 1
    return xfs_lookup((struct vop_lookup_args *)ap);
a287 21
/*
 * whatever clean-ups are needed for a componentname.
 */

static void
cleanup_cnp (struct componentname *cnp, int error)
{
    if (error != 0 || (cnp->cn_flags & SAVESTART) == 0) {
#ifdef HAVE_KERNEL_ZFREEI
	zfreei(namei_zone, cnp->cn_pnbuf);
	cnp->cn_flags &= ~HASBUF;
#elif defined(FREE_ZONE)
	FREE_ZONE(cnp->cn_pnbuf, cnp->cn_pnlen, M_NAMEI);
#elif defined(PNBUF_PUT)
	PNBUF_PUT(cnp->cn_pnbuf);
#else
	FREE (cnp->cn_pnbuf, M_NAMEI);
#endif
    }
}

d290 1
a290 1
xfs_create(struct vop_create_args *ap)
a295 1
    struct proc *p     = xfs_cnp_to_proc(cnp);
d298 4
a301 1
    error = xfs_create_common(dvp, name, ap->a_vap, cred, p);
d303 3
a305 3
    if (error == 0) {
	error = xfs_lookup_common(dvp, cnp, ap->a_vpp);
    }
d307 5
a311 4
    cleanup_cnp (cnp, error);

#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
    vput (dvp);
d328 2
a329 2
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp  = ap->a_vp;
d331 5
a335 21
    int error = xfs_remove_common(dvp, vp, cnp->cn_nameptr, 
				  cnp->cn_cred, xfs_cnp_to_proc(cnp));

    cleanup_cnp (cnp, error);

#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif
    
#ifdef __APPLE__
    if (error == 0) {
	if (UBCINFOEXISTS(vp)) {
	    ubc_setsize(vp, 0);
	    ubc_release(vp);
	    ubc_uncache(vp);
	}
    }
d365 1
a365 2
				  ap->a_tcnp->cn_cred,
				  xfs_cnp_to_proc (ap->a_fcnp));
a390 1
    struct proc *p     = xfs_cnp_to_proc(cnp);
d393 4
a396 1
    error = xfs_mkdir_common(dvp, name, ap->a_vap, cred, p);
d399 2
a400 1
	error = xfs_lookup_common(dvp, cnp, ap->a_vpp);
d402 7
a408 1
    cleanup_cnp (cnp, error);
d410 2
a411 2
#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)
    vput(dvp);
d414 1
a414 1
    XFSDEB(XDEBVNOPS, ("xfs_mkdir: error = %d\n", error));
a427 2
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp  = ap->a_vp;
d429 7
a435 11
				 cnp->cn_nameptr,
				 cnp->cn_cred,
				 xfs_cnp_to_proc(cnp));

    cleanup_cnp (cnp, error);
#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
a442 9

#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
typedef u_long xfs_cookie_t;
#elif defined(__NetBSD__)
typedef off_t xfs_cookie_t;
#else
#error dunno want kind of cookies you have
#endif

d452 1
a452 1
    off = ap->a_uio->uio_offset;
d455 1
a455 2
			       xfs_uio_to_proc (ap->a_uio),
			       ap->a_eofflag);
d459 1
a459 1
	const struct dirent *dp, *dp_start, *dp_end;
d461 10
a470 2
	xfs_cookie_t *cookies, *cookiep;

d473 7
a479 9
	dp = (const struct dirent *)
	    ((const char *)uio->uio_iov->iov_base - (uio->uio_offset - off));

	dp_end = (const struct dirent *) uio->uio_iov->iov_base;
	for (dp_start = dp, ncookies = 0;
	     dp < dp_end;
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen)) {
	    if (dp->d_reclen <= 0)
		break;
d481 7
d489 5
a493 7

	MALLOC(cookies, xfs_cookie_t *, ncookies * sizeof(xfs_cookie_t),
	       M_TEMP, M_WAITOK);
	for (dp = dp_start, cookiep = cookies;
	     dp < dp_end;
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen)) {
	    if (dp->d_reclen <= 0)
d496 2
a497 1
	    *cookiep++ = off;
d499 1
a499 2
	*ap->a_cookies = cookies;
	*ap->a_ncookies = ncookies;
d515 1
a515 5
    struct vnode *vp = ap->a_vp;
    struct vnode *dvp;
    struct proc *p = cnp->cn_proc;
    int error;

d517 3
a519 10
    dvp = ap->a_dvp;
#elif defined(__FreeBSD__) || defined(__APPLE__)
    dvp = ap->a_tdvp;
#else
#error what kind of BSD is this?
#endif

    if (vp->v_type == VDIR) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
d521 1
a521 20
	    error = EPERM;
	    goto out;
    }
    if (dvp->v_mount != vp->v_mount) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
#endif
	    error = EXDEV;
	    goto out;
    }
    if (dvp != vp && (error = xfs_vfs_writelock(vp, p))) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
#endif
	    goto out;
    }

    error = xfs_link_common(
			   dvp,
			   vp,
d523 1
a523 2
			   cnp->cn_cred,
			   xfs_cnp_to_proc (cnp));
d525 5
a529 8
    cleanup_cnp (cnp, error);

    if (dvp != vp)
	xfs_vfs_unlock(vp, p);

out:
#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)
    vput(dvp);
d548 5
a552 6
    struct vnode *dvp  = ap->a_dvp;
    struct vnode **vpp = ap->a_vpp;
    
    int error = xfs_symlink_common(dvp,
				   vpp,
				   cnp,
d556 5
a560 5
    if (error == 0) {
	error = xfs_lookup_common(dvp, cnp, vpp);
#if (!defined(__FreeBSD__) || __FreeBSD_version < 400012) && (!defined(__NetBSD__) || __NetBSD_Version__ < 105240000) && (!defined(__OpenBSD__) || OpenBSD < 200107)
	if (error == 0)
	    vput (*vpp);
a562 4
    cleanup_cnp (cnp, error);
#if !defined(__FreeBSD__)
    vput(dvp);
#endif
d585 5
d591 3
d605 1
a605 6
    struct vnode *vp = ap->a_vp;
    int ret;

    ret = xfs_reclaim_common(vp);
    vp->v_data = NULL;
    return ret;
d610 13
a622 1
 * Do lock, unlock, and islocked with lockmgr if we have it.
a624 2
#if defined(HAVE_KERNEL_LOCKMGR) || defined(HAVE_KERNEL_DEBUGLOCKMGR)

a627 39
{               
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    xfs_vnode_lock *l   = &xn->lock;
    int flags           = ap->a_flags;
    int ret;

    XFSDEB(XDEBVNOPS, ("xfs_lock: %lx, flags 0x%x\n",
		       (unsigned long)vp, flags));

    if (l == NULL)
      panic("xfs_lock: lock NULL");

    XFSDEB(XDEBVNOPS, ("xfs_lock before: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));

#ifndef	DEBUG_LOCKS
#ifdef HAVE_FOUR_ARGUMENT_LOCKMGR
    ret = lockmgr(l, flags, &vp->v_interlock, ap->a_p);
#else
    ret = lockmgr(l, flags, &vp->v_interlock);
#endif
#else
    ret = debuglockmgr(l, flags, &vp->v_interlock, ap->a_p,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#endif
    XFSDEB(XDEBVNOPS, ("xfs_lock: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));
    return ret;
}
#endif /* HAVE_VOP_LOCK */

#ifdef HAVE_VOP_UNLOCK
static int
xfs_unlock(struct vop_unlock_args * ap)
a630 3
    xfs_vnode_lock *l   = &xn->lock;
    int flags           = ap->a_flags;
    int ret;
d632 1
a632 2
    if (l == NULL)
      panic("xfs_unlock: lock NULL");
d634 3
a636 24
    XFSDEB(XDEBVNOPS,
	   ("xfs_unlock: %lx, flags 0x%x, l %lx, ap %lx\n",
	    (unsigned long)vp, flags,
	    (unsigned long)l,
	    (unsigned long)ap));

    XFSDEB(XDEBVNOPS, ("xfs_unlock: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));
#ifndef	DEBUG_LOCKS
#ifdef HAVE_FOUR_ARGUMENT_LOCKMGR
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_p);
#else
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock);
#endif
#else
    ret = debuglockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_p,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#endif
    XFSDEB(XDEBVNOPS, ("xfs_unlock: return %d\n", ret));
    return ret;
}
#endif /* HAVE_VOP_UNLOCK */
d638 2
a639 7
#ifdef HAVE_VOP_ISLOCKED
static int
xfs_islocked (struct vop_islocked_args *ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    xfs_vnode_lock *l   = &xn->lock;
d641 3
a643 7
    XFSDEB(XDEBVNOPS, ("xfs_islocked: %lx\n",
		       (unsigned long)vp));

#if defined(HAVE_TWO_ARGUMENT_LOCKSTATUS)
    return lockstatus (l, ap->a_p);
#elif defined(HAVE_ONE_ARGUMENT_LOCKSTATUS)
    return lockstatus (l);
a644 17
#error what lockstatus?
#endif
}
#endif /* HAVE_VOP_ISLOCKED */

#else /* !HAVE_KERNEL_LOCKMGR && !HAVE_KERNEL_DEBUGLOCKMGR */

#ifdef HAVE_VOP_LOCK
static int
xfs_lock(struct vop_lock_args * ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    XFSDEB(XDEBVNOPS, ("xfs_lock: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));

d651 1
d663 1
a663 2
    XFSDEB(XDEBVNOPS, ("xfs_unlock: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));
d665 10
a679 2
    XFSDEB(XDEBVNOPS, ("xfs_unlock: return\n"));

d691 1
a691 2
    XFSDEB(XDEBVNOPS, ("xfs_islocked: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));
a695 1
#endif /* !HAVE_KERNEL_LOCKMGR */
a707 5
	ap->a_cnp->cn_flags &= ~HASBUF;
#elif defined(FREE_ZONE)
	FREE_ZONE(cnp->cn_pnbuf, cnp->cn_pnlen, M_NAMEI);
#elif defined(PNBUF_PUT)
	PNBUF_PUT(cnp->cn_pnbuf);
d749 1
a749 1
     /* Old BSD
d755 1
a755 11
     */
    /* NetBSD UBC
	IN struct vnode *vp;
	IN voff_t offset;
	IN vm_page_t *m;
	IN int *count;
	IN int centeridx;
	IN vm_prot_t access_type;
	IN int advice;
	IN int flags;
    */
d765 1
a765 7
    error = xfs_data_valid (ap->a_vp, VNODE_TO_XNODE(ap->a_vp)->cred,
			    xfs_curproc(), XFS_DATA_R);
    if (error == 0)
	error = VOP_GETPAGES(DATA_FROM_VNODE(ap->a_vp), 
			     ap->a_offset, ap->a_m,
			     ap->a_count, ap->a_centeridx, ap->a_access_type,
			     ap->a_advice, ap->a_flags);
d775 1
a775 1
     /* Old BSD
d782 1
a782 7
     */
    /* NetBSD UBC (>= 1.5Y)
	IN struct vnode *vp;
	IN voff_t offlo;
	IN voff_t offhi;
	IN int flags;
    */
a783 5
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    struct vnode *t     = DATA_FROM_XNODE(xn);
    int error;

d786 3
a788 8
    xn->flags |= XFS_DATA_DIRTY;

#ifdef HAVE_STRUCT_VOP_PUTPAGES_ARGS_A_SYNC /* FreeBSD-style */
    return VOP_PUTPAGES(t, ap->a_m, ap->a_count, ap->a_sync, ap->a_rtvals,
			ap->a_offset);
#else /* NetBSD-style */
#if defined(__NetBSD__) && __NetBSD_Version__  >= 105250000 
    return VOP_PUTPAGES(t, ap->a_offlo, ap->a_offhi, ap->a_flags);
d790 1
a790 1
    return VOP_PUTPAGES(t, ap->a_m, ap->a_count, ap->a_flags, ap->a_rtvals);
a791 1
#endif /* HAVE_STRUCT_VOP_PUTPAGES_ARGS_A_SYNC */
a889 131
#ifdef HAVE_VOP_PAGEIN
static int
xfs_pagein(struct vop_pagein_args *ap)
{
#ifdef __APPLE__
    struct uio uio;
    struct iovec iov;
    int ret;

    kernel_upl_map(kernel_map, ap->a_pl, &iov.iov_base);
    iov.iov_base+=ap->a_pl_offset;
    iov.iov_len=ap->a_size;

    uio.uio_iov=&iov;
    uio.uio_iovcnt=1;
    uio.uio_offset=ap->a_f_offset;
    uio.uio_resid=ap->a_size;
    uio.uio_segflg=UIO_SYSSPACE; /* XXX what is it? */
    uio.uio_rw=UIO_READ;
    uio.uio_procp=xfs_curproc();

    ret = VOP_READ(ap->a_vp, &uio, 0, ap->a_cred);

    kernel_upl_unmap(kernel_map, ap->a_pl);

    if (ret) {
	kernel_upl_abort_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
			       UPL_ABORT_ERROR | UPL_ABORT_FREE_ON_EMPTY);
    } else {
	kernel_upl_commit_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
				UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY,
				UPL_GET_INTERNAL_PAGE_LIST(ap->a_pl));
    }

    return ret;
#else
    return (VOP_READ(ap->a_vp, ap->a_uio, ap->a_ioflag, ap->a_cred));
#endif
}
  
#endif

#ifdef HAVE_VOP_PAGEOUT
static int
xfs_pageout(struct vop_pageout_args *ap)
{
#ifdef __APPLE__
    struct uio uio;
    struct iovec iov;
    int ret;

    kernel_upl_map(kernel_map, ap->a_pl, &iov.iov_base);
    iov.iov_base+=ap->a_pl_offset;
    iov.iov_len=ap->a_size;

    uio.uio_iov=&iov;
    uio.uio_iovcnt=1;
    uio.uio_offset=ap->a_f_offset;
    uio.uio_resid=ap->a_size;
    uio.uio_segflg=UIO_SYSSPACE; /* XXX what is it? */
    uio.uio_rw=UIO_WRITE;
    uio.uio_procp=xfs_curproc();

    ret = VOP_WRITE(ap->a_vp, &uio, 0, ap->a_cred);

    kernel_upl_unmap(kernel_map, ap->a_pl);

    if (ret) {
	kernel_upl_abort_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
			       UPL_ABORT_FREE_ON_EMPTY);
    } else {
	kernel_upl_commit_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
				UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY,
				UPL_GET_INTERNAL_PAGE_LIST(ap->a_pl));
    }

    return ret;
#else
    return (VOP_WRITE(ap->a_vp, ap->a_uio, ap->a_ioflag, ap->a_cred));
#endif
}
#endif

#ifdef HAVE_VOP_CREATEVOBJECT
static int
xfs_createvobject(struct vop_createvobject_args *ap)
/*
struct vop_createvobject_args {
	struct vnode *vp;
	struct ucred *cred;
	struct proc *p;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_createvobject\n"));

    return vop_stdcreatevobject (ap);
}
#endif /* HAVE_VOP_CREATEVOBJECT */

#ifdef HAVE_VOP_DESTROYVOBJECT
static int
xfs_destroyvobject(struct vop_destroyvobject_args *ap)
/*
struct vop_destroyvobject_args {
	struct vnode *vp;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_destroyvobject\n"));

    return vop_stddestroyvobject (ap);
}
#endif /* HAVE_VOP_DESTROYVOBJECT */

#ifdef HAVE_VOP_GETVOBJECT
static int
xfs_getvobject(struct vop_getvobject_args *ap)
/*
struct vop_getvobject_args {
	struct vnode *vp;
	struct vm_object **objpp;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_getvobject\n"));

    return vop_stdgetvobject (ap);
}
#endif /* HAVE_VOP_GETVOBJECT */

d893 1
a893 1
xfs_eopnotsupp (struct vop_generic_args *ap)
d895 1
a895 1
    XFSDEB(XDEBVNOPS, ("xfs_eopnotsupp %s\n", ap->a_desc->vdesc_name));
d900 1
a900 1
xfs_returnzero (struct vop_generic_args *ap)
d902 1
a902 1
    XFSDEB(XDEBVNOPS, ("xfs_returnzero %s\n", ap->a_desc->vdesc_name));
a1020 15
#endif
#ifdef HAVE_VOP_PAGEIN
    {&vop_pagein_desc, (vop_t *) xfs_pagein },
#endif
#ifdef HAVE_VOP_PAGEOUT
    {&vop_pageout_desc, (vop_t *) xfs_pageout },
#endif
#ifdef HAVE_VOP_CREATEVOBJECT
    {&vop_createvobject_desc, (vop_t *) xfs_createvobject },
#endif
#ifdef HAVE_VOP_DESTROYVOBJECT
    {&vop_destroyvobject_desc, (vop_t *) xfs_destroyvobject },
#endif
#ifdef HAVE_VOP_GETVOBJECT
    {&vop_getvobject_desc, (vop_t *) xfs_getvobject },
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d35 1
a35 1
 * NNPFS operations.
d54 1
a54 1
RCSID("$arla: xfs_vnodeops-bsd.c,v 1.123 2003/02/15 16:40:36 lha Exp $");
d61 1
a61 1
int
a70 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_open_common (ap->a_vp, ap->a_mode, ap->a_cred, ap->a_td);
#else
a71 1
#endif
d76 1
a76 1
int
a88 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_fsync_common(ap->a_vp, ap->a_cred, ap->a_waitfor, ap->a_td);
#else
a90 1
#endif
d95 1
a95 1
int
a103 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_close_common(ap->a_vp, ap->a_fflag, ap->a_td, ap->a_cred);
#else
a104 1
#endif
d109 1
a109 1
int
d123 1
a123 1
int
d137 1
a137 1
int
d145 1
a145 1
    NNPFSDEB(XDEBVNOPS, ("xfs_ioctl\n"));
d152 1
a152 1
int
d158 1
a158 1
    NNPFSDEB(XDEBVNOPS, ("xfs_select\n"));
d165 1
a165 1
int
d177 1
a177 1
    NNPFSDEB(XDEBVNOPS, ("xfs_seek\n"));
d183 1
a183 1
int
d191 1
a191 1
    NNPFSDEB(XDEBVNOPS, ("xfs_poll\n"));
d197 1
a197 1
int
a203 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_getattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_td);
#else
a204 1
#endif
d209 1
a209 1
int
a216 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_setattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_td);
#else
a217 1
#endif
d222 1
a222 1
int
a230 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_access_common(ap->a_vp, ap->a_mode, ap->a_cred, ap->a_td);
#else
a231 1
#endif
d236 1
a236 1
int
d250 1
a250 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup: (%s, %ld), nameiop = %lu, flags = %lu\n",
a276 3
#ifdef HAVE_FREEBSD_THREAD
	    xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_thread(cnp));
#else
a277 1
#endif
d286 1
a286 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup: error = %d\n", error));
d293 1
a293 1
int
d314 1
a314 1
#if defined(HAVE_KERNEL_ZFREEI)
a316 3
#elif defined(HAVE_KERNEL_UMA_ZFREE_ARG)
	uma_zfree_arg(namei_zone, cnp->cn_pnbuf, NULL);
	cnp->cn_flags &= ~HASBUF;
a318 3
#elif defined(HAVE_KERNEL_ZFREE)
	zfree(namei_zone, cnp->cn_pnbuf);
	cnp->cn_flags &= ~HASBUF;
d328 1
a328 1
int
d335 1
a335 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p     = xfs_cnp_to_thread(cnp);
#else
    d_thread_t *p     = xfs_cnp_to_proc(cnp);
#endif
d350 1
a350 1
    NNPFSDEB(XDEBVNOPS, ("xfs_create: error = %d\n", error));
d357 1
a357 1
int
a366 4
#ifdef HAVE_FREEBSD_THREAD
    int error = xfs_remove_common(dvp, vp, cnp->cn_nameptr, 
				  cnp->cn_cred, xfs_cnp_to_thread(cnp));
#else
a368 1
#endif
d395 1
a395 1
int
a417 3
#ifdef HAVE_FREEBSD_THREAD
				  xfs_cnp_to_thread (ap->a_fcnp));
#else
a418 1
#endif
d432 1
a432 1
int
d444 1
a444 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p     = xfs_cnp_to_thread(cnp);
#else
    d_thread_t *p     = xfs_cnp_to_proc(cnp);
#endif
d458 1
a458 1
    NNPFSDEB(XDEBVNOPS, ("xfs_mkdir: error = %d\n", error));
d465 1
a465 1
int
a476 3
#ifdef HAVE_FREEBSD_THREAD
				 xfs_cnp_to_thread(cnp));
#else
a477 1
#endif
d502 1
a502 1
int
a513 3
#ifdef HAVE_FREEBSD_THREAD
			       xfs_uio_to_thread (ap->a_uio),
#else
a514 1
#endif
d555 1
a555 1
int
d566 1
a566 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p = cnp->cn_thread;
#else
    d_thread_t *p = cnp->cn_proc;
#endif
a590 3
    /* FreeBSD 5.0 doesn't need to lock the vnode in VOP_LINK */
#if !defined(__FreeBSD_version) || __FreeBSD_version < 500043

a596 1
#endif /* defined(__FreeBSD_version) || __FreeBSD_version < 500043 */
a602 3
#ifdef HAVE_FREEBSD_THREAD
			   xfs_cnp_to_thread (cnp));
#else
a603 1
#endif
d620 1
a620 1
int
d642 1
a642 1
#if (!defined(__FreeBSD__) || __FreeBSD_version < 400012) && (!defined(__NetBSD__) || __NetBSD_Version__ < 105240000) && (!defined(__OpenBSD__) || OpenBSD <= 200211)
d657 1
a657 1
int
d668 1
a668 1
int
a672 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_inactive_common(ap->a_vp, xfs_curthread());
#else
a673 1
#endif
d678 1
a678 1
int
d701 1
a701 1
int
d710 1
a710 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lock: %lx, flags 0x%x\n",
d716 4
a719 6
    NNPFSDEB(XDEBVNOPS, ("xfs_lock before: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%llx\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount,
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));
a722 3
#ifdef HAVE_FREEBSD_THREAD
    ret = lockmgr(l, flags, &vp->v_interlock, ap->a_td);
#else
a723 1
#endif
a727 4
#ifdef HAVE_FREEBSD_THREAD
    ret = debuglockmgr(l, flags, &vp->v_interlock, ap->a_td,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#else
d731 4
a734 7
#endif
    NNPFSDEB(XDEBVNOPS, ("xfs_lock: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%llx\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount, 
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));
d740 1
a740 1
int
d752 1
a752 1
    NNPFSDEB(XDEBVNOPS,
d758 4
a761 6
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%lld\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount, 
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));
a763 3
#ifdef HAVE_FREEBSD_THREAD
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_td);
#else
a764 1
#endif
a768 4
#ifdef HAVE_FREEBSD_THREAD
    ret = debuglockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_td,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#else
d772 1
a772 2
#endif
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: return %d\n", ret));
d778 1
a778 1
int
d785 1
a785 1
    NNPFSDEB(XDEBVNOPS, ("xfs_islocked: %lx\n",
a788 3
#ifdef HAVE_FREEBSD_THREAD
    return lockstatus (l, ap->a_td);
#else
a789 1
#endif
d801 1
a801 1
int
d807 1
a807 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lock: %lx, %d\n",
d822 1
a822 1
int
d827 1
a827 1
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: %lx, %d\n",
d835 1
a835 1
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: return\n"));
d842 1
a842 1
int
d848 1
a848 1
    NNPFSDEB(XDEBVNOPS, ("xfs_islocked: %lx, %d\n",
d857 1
a857 1
int
d865 1
a865 1
#if defined(HAVE_KERNEL_ZFREEI)
a867 3
#elif defined(HAVE_KERNEL_UMA_ZFREE_ARG)
	uma_zfree_arg(namei_zone, cnp->cn_pnbuf, NULL);
	cnp->cn_flags &= ~HASBUF;
a869 3
#elif defined(HAVE_KERNEL_ZFREE)
	zfree(namei_zone, cnp->cn_pnbuf);
	ap->a_cnp->cn_flags &= ~HASBUF;
d880 1
a880 1
int
d889 1
a889 4
    NNPFSDEB(XDEBVNOPS, ("xfs_mmap\n"));
#ifdef HAVE_KERNEL_GENFS_MMAP
    return genfs_mmap(ap);
#else
a890 1
#endif
d895 1
a895 1
int
d905 1
a905 1
    NNPFSDEB(XDEBVNOPS, ("xfs_bmap\n"));
d911 1
a911 13

static size_t
get_pages_endlength (struct vop_getpages_args *ap)
{
#ifdef HAVE_STRUCT_VOP_GETPAGES_ARGS_A_OFFSET
    /* NetBSD ubc */
    return (ap->a_offset << PAGE_SHIFT) + *ap->a_count * PAGE_SIZE;
#else
    return (ap->a_reqpage << PAGE_SHIFT) +  ap->a_count * PAGE_SIZE;
#endif
}

int
d933 1
a933 1
    NNPFSDEB(XDEBVNOPS, ("xfs_getpages\n"));
d939 2
a940 3
    error = xfs_data_valid (ap->a_vp, VNODE_TO_XNODE(ap->a_vp)->rd_cred,
			    xfs_curproc(), NNPFS_DATA_R,
			    get_pages_endlength(ap));
d947 1
a947 1
    NNPFSDEB(XDEBVNOPS, ("xfs_getpages = %d\n", error));
d953 1
a953 1
int
d975 1
a975 1
    NNPFSDEB(XDEBVNOPS, ("xfs_putpages\n"));
d977 1
a977 2
    if (t == NULL)
	return 0;
a979 2
    xn->flags |= NNPFS_DATA_DIRTY;

a983 17
    /* XXX should only walk over those pages that is requested */
    if (vp->v_type == VREG && ap->a_flags & PGO_CLEANIT) {
	struct uvm_object *uobj = &t->v_uobj;
	struct vm_page *pg;
	int dirty = 0;

	pg = TAILQ_FIRST(&uobj->memq);

	while (pg && !dirty) {
	    dirty = pmap_is_modified(pg) || (pg->flags & PG_CLEAN) == 0;
	    pg = TAILQ_NEXT(pg, listq);
	}	

	if (dirty)
	    xn->flags |= NNPFS_DATA_DIRTY;
    }

a985 1
    xn->flags |= NNPFS_DATA_DIRTY;
d993 1
a993 1
int
d996 1
a996 1
    NNPFSDEB(XDEBVNOPS, ("xfs_cmp\n"));
d1002 1
a1002 1
int
d1006 1
a1006 1
    NNPFSDEB(XDEBVNOPS, ("xfs_realvp\n"));
d1012 1
a1012 1
int
d1020 1
a1020 1
    NNPFSDEB(XDEBVNOPS, ("xfs_cntl\n"));
d1026 2
a1027 2
int
xfs_print (struct vop_print_args *v)
d1029 1
a1029 4
    struct vop_print_args /* {
	struct vnode	*a_vp;
    } */ *ap = v;
    xfs_printnode_common (ap->a_vp);
d1034 1
d1036 2
a1037 2
int
xfs_advlock(struct vop_advlock_args *v)
d1046 1
a1046 1
#if 0
d1051 1
a1051 1
/*     if (NNPFS_TOKEN_GOT(xn,  */
d1053 1
d1060 1
a1060 1
	locktype = NNPFS_READLOCK;
d1066 3
a1068 7
#elif defined(HAVE_KERNEL_LF_ADVLOCK) && !defined(__OpenBSD__) && !defined(__APPLE__)
    struct xfs_node *xn = VNODE_TO_XNODE(ap->a_vp);
 
    return lf_advlock(ap, &xn->lockf, xn->attr.va_size);
  #else
     return EOPNOTSUPP;
#endif
d1071 1
d1074 2
a1075 2
int
xfs_revoke(struct vop_revoke_args *v)
d1088 1
a1088 1
int
a1109 4
    /* Zero out rest of last page if there wasn't enough data in the file */
    if (ret == 0 && uio.uio_resid > 0)
	bzero(iov.iov_base, uio.uio_resid);
    
d1123 1
a1123 1
#error pagein on non apple ?
d1130 1
a1130 1
int
d1165 1
a1165 1
#error pageout on non apple ?
d1171 1
a1171 1
int
d1181 1
a1181 1
    NNPFSDEB(XDEBVNOPS, ("xfs_createvobject\n"));
d1188 1
a1188 1
int
d1196 1
a1196 1
    NNPFSDEB(XDEBVNOPS, ("xfs_destroyvobject\n"));
d1203 1
a1203 1
int
d1212 1
a1212 1
    NNPFSDEB(XDEBVNOPS, ("xfs_getvobject\n"));
a1217 23
#ifdef HAVE_VOP_PATHCONF
int
xfs_pathconf(struct vop_pathconf_args *ap)
/*
struct vop_pathconf_args {
        struct vnodeop_desc *a_desc;
        struct vnode *a_vp;
        int a_name;
};
*/
{
    NNPFSDEB(XDEBVNOPS, ("xfs_pathconf\n"));

#ifdef HAVE_KERNEL_VOP_STDPATHCONF
    return vop_stdpathconf(ap);
#else
    return EOPNOTSUPP;
#endif
}
#endif



d1223 1
a1223 1
    NNPFSDEB(XDEBVNOPS, ("xfs_eopnotsupp %s\n", ap->a_desc->vdesc_name));
d1230 1
a1230 1
    NNPFSDEB(XDEBVNOPS, ("xfs_returnzero %s\n", ap->a_desc->vdesc_name));
a1233 12
void
xfs_pushdirty(struct vnode *vp, struct ucred *cred, d_thread_t *p)
{
#if defined(__NetBSD_Version__) && __NetBSD_Version__ >= 105280000
    VOP_PUTPAGES(vp, 0, 0, PGO_ALLPAGES|PGO_SYNCIO|PGO_CLEANIT);
#elif defined(__APPLE__)
    ubc_pushdirty(vp);
#endif
}



d1345 1
d1349 1
a1363 3
#endif
#ifdef HAVE_VOP_PATHCONF
    {&vop_pathconf_desc, (vop_t *) xfs_pathconf },
@


1.1.4.1
log
@Sync with -current
@
text
@a0 2
/*	$OpenBSD$	*/

d54 1
a54 1
RCSID("$OpenBSD$");
@


1.1.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d53 1
a53 1
#ifdef HAVE_VM_VNODE_PAGER_H
a54 1
#endif
d56 1
a56 1
RCSID("$Id: xfs_vnodeops-bsd.c,v 1.3 2000/09/11 14:26:54 art Exp $");
d73 6
a78 1
    return xfs_open_common (ap->a_vp, ap->a_mode, ap->a_cred, ap->a_p);
d208 1
a208 2
	    struct ucred *cred,
	    struct proc *p) */
d210 1
a210 1
    return xfs_getattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_p);
d217 2
a218 1
     /* struct vnode *vp,
d220 1
a220 2
	    struct ucred *cred,
	    struct proc *p)
d223 1
a223 1
    return xfs_setattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_p);
d233 1
a233 2
	   struct ucred *cred,
	   struct proc *p)
d236 1
a236 1
    return xfs_access_common(ap->a_vp, ap->a_mode, ap->a_cred, ap->a_p);
a251 2
    int lockparent = (cnp->cn_flags & (LOCKPARENT | ISLASTCN))
	== (LOCKPARENT | ISLASTCN);
a266 9
    if ((error != 0 && error != EJUSTRETURN)
	|| (!lockparent
	    && ap->a_dvp != *(ap->a_vpp)
#ifdef PDIRUNLOCK
	    && (cnp->cn_flags & PDIRUNLOCK) == 0
#endif
	))
	xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_proc(cnp));

d286 1
a286 1
    return xfs_lookup((struct vop_lookup_args *)ap);
a289 19
/*
 * whatever clean-ups are needed for a componentname.
 */

static void
cleanup_cnp (struct componentname *cnp, int error)
{
    if (error != 0 || (cnp->cn_flags & SAVESTART) == 0) {
#ifdef HAVE_KERNEL_ZFREEI
	zfreei(namei_zone, cnp->cn_pnbuf);
	cnp->cn_flags &= ~HASBUF;
#elif defined(FREE_ZONE)
	FREE_ZONE(cnp->cn_pnbuf, cnp->cn_pnlen, M_NAMEI);
#else
	FREE (cnp->cn_pnbuf, M_NAMEI);
#endif
    }
}

d292 1
a292 1
xfs_create(struct vop_create_args *ap)
a297 1
    struct proc *p     = xfs_cnp_to_proc(cnp);
d300 4
a303 1
    error = xfs_create_common(dvp, name, ap->a_vap, cred, p);
d305 3
a307 3
    if (error == 0) {
	error = xfs_lookup_common(dvp, cnp, ap->a_vpp);
    }
d309 5
a313 4
    cleanup_cnp (cnp, error);

#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
    vput (dvp);
d331 8
a338 1
				  cnp->cn_cred, xfs_cnp_to_proc(cnp));
a339 1
    cleanup_cnp (cnp, error);
d367 1
a367 2
				  ap->a_tcnp->cn_cred,
				  xfs_cnp_to_proc (ap->a_fcnp));
a392 1
    struct proc *p     = xfs_cnp_to_proc(cnp);
d395 4
a398 1
    error = xfs_mkdir_common(dvp, name, ap->a_vap, cred, p);
d401 2
a402 1
	error = xfs_lookup_common(dvp, cnp, ap->a_vpp);
d404 7
a410 1
    cleanup_cnp (cnp, error);
d412 2
a413 2
#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)
    vput(dvp);
d416 1
a416 1
    XFSDEB(XDEBVNOPS, ("xfs_mkdir: error = %d\n", error));
d431 8
a438 3
				 cnp->cn_nameptr,
				 cnp->cn_cred,
				 xfs_cnp_to_proc(cnp));
a439 1
    cleanup_cnp (cnp, error);
a444 9

#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
typedef u_long xfs_cookie_t;
#elif defined(__NetBSD__)
typedef off_t xfs_cookie_t;
#else
#error dunno want kind of cookies you have
#endif

d454 1
a454 1
    off = ap->a_uio->uio_offset;
d457 1
a457 2
			       xfs_uio_to_proc (ap->a_uio),
			       ap->a_eofflag);
d461 1
a461 1
	const struct dirent *dp, *dp_start, *dp_end;
d463 10
a472 2
	xfs_cookie_t *cookies, *cookiep;

d475 7
a481 7
	dp = (const struct dirent *)
	    ((const char *)uio->uio_iov->iov_base - (uio->uio_offset - off));

	dp_end = (const struct dirent *) uio->uio_iov->iov_base;
	for (dp_start = dp, ncookies = 0;
	     dp < dp_end;
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen))
d483 5
a487 6

	MALLOC(cookies, xfs_cookie_t *, ncookies * sizeof(xfs_cookie_t),
	       M_TEMP, M_WAITOK);
	for (dp = dp_start, cookiep = cookies;
	     dp < dp_end;
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen)) {
d489 1
a489 1
	    *cookiep++ = off;
d493 9
d517 1
a517 5
    struct vnode *vp = ap->a_vp;
    struct vnode *dvp;
    struct proc *p = cnp->cn_proc;
    int error;

d519 3
a521 5
    dvp = ap->a_dvp;
#elif defined(__FreeBSD__) || defined(__APPLE__)
    dvp = ap->a_tdvp;
#else
#error what kind of BSD is this?
d523 1
a523 25

    if (vp->v_type == VDIR) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
#endif
	    error = EPERM;
	    goto out;
    }
    if (dvp->v_mount != vp->v_mount) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
#endif
	    error = EXDEV;
	    goto out;
    }
    if (dvp != vp && (error = xfs_vfs_writelock(vp, p))) {
#ifdef HAVE_VOP_ABORTOP
	    VOP_ABORTOP(dvp, cnp);
#endif
	    goto out;
    }

    error = xfs_link_common(
			   dvp,
			   vp,
d525 1
a525 2
			   cnp->cn_cred,
			   xfs_cnp_to_proc (cnp));
d527 5
a531 8
    cleanup_cnp (cnp, error);

    if (dvp != vp)
	xfs_vfs_unlock(vp, p);

out:
#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)
    vput(dvp);
d552 3
a554 1
				   cnp,
d558 7
a564 1
    cleanup_cnp (cnp, error);
d587 5
d593 3
d607 1
a607 6
    struct vnode *vp = ap->a_vp;
    int ret;

    ret = xfs_reclaim_common(vp);
    vp->v_data = NULL;
    return ret;
d612 13
a624 1
 * Do lock, unlock, and islocked with lockmgr if we have it.
a626 2
#if defined(HAVE_KERNEL_LOCKMGR) || defined(HAVE_KERNEL_DEBUGLOCKMGR)

a629 39
{               
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    xfs_vnode_lock *l   = &xn->lock;
    int flags           = ap->a_flags;
    int ret;

    XFSDEB(XDEBVNOPS, ("xfs_lock: %lx, flags 0x%x\n",
		       (unsigned long)vp, flags));

    if (l == NULL)
      panic("xfs_lock: lock NULL");

    XFSDEB(XDEBVNOPS, ("xfs_lock before: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));

#ifndef	DEBUG_LOCKS
#ifdef HAVE_FOUR_ARGUMENT_LOCKMGR
    ret = lockmgr(l, flags, &vp->v_interlock, ap->a_p);
#else
    ret = lockmgr(l, flags, &vp->v_interlock);
#endif
#else
    ret = debuglockmgr(l, flags, &vp->v_interlock, ap->a_p,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#endif
    XFSDEB(XDEBVNOPS, ("xfs_lock: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));
    return ret;
}
#endif /* HAVE_VOP_LOCK */

#ifdef HAVE_VOP_UNLOCK
static int
xfs_unlock(struct vop_unlock_args * ap)
a632 3
    xfs_vnode_lock *l   = &xn->lock;
    int flags           = ap->a_flags;
    int ret;
d634 1
a634 2
    if (l == NULL)
      panic("xfs_unlock: lock NULL");
d636 3
a638 24
    XFSDEB(XDEBVNOPS,
	   ("xfs_unlock: %lx, flags 0x%x, l %lx, ap %lx\n",
	    (unsigned long)vp, flags,
	    (unsigned long)l,
	    (unsigned long)ap));

    XFSDEB(XDEBVNOPS, ("xfs_unlock: lk flags: %d share: %d "
		       "wait: %d excl: %d holder: %d\n",
		       l->lk_flags, l->lk_sharecount, l->lk_waitcount,
		       l->lk_exclusivecount, l->lk_lockholder));
#ifndef	DEBUG_LOCKS
#ifdef HAVE_FOUR_ARGUMENT_LOCKMGR
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_p);
#else
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock);
#endif
#else
    ret = debuglockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_p,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#endif
    XFSDEB(XDEBVNOPS, ("xfs_unlock: return %d\n", ret));
    return ret;
}
#endif /* HAVE_VOP_UNLOCK */
d640 2
a641 7
#ifdef HAVE_VOP_ISLOCKED
static int
xfs_islocked (struct vop_islocked_args *ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    xfs_vnode_lock *l   = &xn->lock;
d643 3
a645 7
    XFSDEB(XDEBVNOPS, ("xfs_islocked: %lx\n",
		       (unsigned long)vp));

#if defined(HAVE_TWO_ARGUMENT_LOCKSTATUS)
    return lockstatus (l, ap->a_p);
#elif defined(HAVE_ONE_ARGUMENT_LOCKSTATUS)
    return lockstatus (l);
a646 17
#error what lockstatus?
#endif
}
#endif /* HAVE_VOP_ISLOCKED */

#else /* !HAVE_KERNEL_LOCKMGR && !HAVE_KERNEL_DEBUGLOCKMGR */

#ifdef HAVE_VOP_LOCK
static int
xfs_lock(struct vop_lock_args * ap)
{
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);

    XFSDEB(XDEBVNOPS, ("xfs_lock: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));

d653 1
d665 1
a665 2
    XFSDEB(XDEBVNOPS, ("xfs_unlock: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));
d667 10
a681 3
    XFSDEB(XDEBVNOPS, ("xfs_unlock: lock = %x\n",
		       vp->v_interlock.lock_data));

d693 1
a693 2
    XFSDEB(XDEBVNOPS, ("xfs_islocked: %lx, %d\n",
		       (unsigned long)vp, xn->vnlocks));
a697 1
#endif /* !HAVE_KERNEL_LOCKMGR */
a709 3
	ap->a_cnp->cn_flags &= ~HASBUF;
#elif defined(FREE_ZONE)
	FREE_ZONE(cnp->cn_pnbuf, cnp->cn_pnlen, M_NAMEI);
a785 5
    struct vnode *vp    = ap->a_vp;
    struct xfs_node *xn = VNODE_TO_XNODE(vp);
    struct vnode *t     = DATA_FROM_XNODE(xn);
    int error;

d788 6
a793 4
    xn->flags |= XFS_DATA_DIRTY;

    return VOP_PUTPAGES(t, ap->a_m, ap->a_count, ap->a_sync, ap->a_rtvals,
			ap->a_offset);
a891 17
#ifdef HAVE_VOP_PAGEIN
static int
xfs_pagein(struct vop_pagein_args *ap)
{
    return (VOP_READ(ap->a_vp, ap->a_uio, ap->a_ioflag, ap->a_cred));
}
  
#endif

#ifdef HAVE_VOP_PAGEOUT
static int
xfs_pageout(struct vop_pageout_args *ap)
{
    return (VOP_WRITE(ap->a_vp, ap->a_uio, ap->a_ioflag, ap->a_cred));
}
#endif

d895 1
a895 1
xfs_eopnotsupp (struct vop_generic_args *ap)
d897 1
a897 1
    XFSDEB(XDEBVNOPS, ("xfs_eopnotsupp %s\n", ap->a_desc->vdesc_name));
d902 1
a902 1
xfs_returnzero (struct vop_generic_args *ap)
d904 1
a904 1
    XFSDEB(XDEBVNOPS, ("xfs_returnzero %s\n", ap->a_desc->vdesc_name));
a1022 6
#endif
#ifdef HAVE_VOP_PAGEIN
    {&vop_pagein_desc, (vop_t *) xfs_pagein },
#endif
#ifdef HAVE_VOP_PAGEOUT
    {&vop_pageout_desc, (vop_t *) xfs_pageout },
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
a42 4
#ifdef __APPLE__
#define MACH_KERNEL 1
#endif

d55 1
a55 1
RCSID("$Id$");
a256 4
#ifdef PDIRUNLOCK
    cnp->cn_flags &= ~PDIRUNLOCK;
#endif

d265 9
a276 15
    if (error == 0 || error == EJUSTRETURN) {
	if (ap->a_dvp == *(ap->a_vpp)) {
	    /* if we looked up ourself, do nothing */
	} else if (!(cnp->cn_flags & ISLASTCN) || !lockparent) {
	    /* if we isn't last component and is isn't requested,
	     * return parent unlocked */
	    xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_proc(cnp));
#ifdef PDIRUNLOCK
	    cnp->cn_flags |= PDIRUNLOCK;
#endif
	}
    } else {
	/* in case of a error do nothing  */
    } 
    
a309 2
#elif defined(PNBUF_PUT)
	PNBUF_PUT(cnp->cn_pnbuf);
d353 1
a353 4
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp  = ap->a_vp;

    int error = xfs_remove_common(dvp, vp, cnp->cn_nameptr, 
a356 19

#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif
    
#ifdef __APPLE__
    if (error == 0) {
	if (UBCINFOEXISTS(vp)) {
	    ubc_setsize(vp, 0);
	    ubc_release(vp);
	    ubc_uncache(vp);
	}
    }
#endif

a438 2
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp  = ap->a_vp;
a444 8
#if !defined(__FreeBSD__) || __FreeBSD_version < 300000
    if (dvp == vp)
	vrele(vp);
    else
	vput(vp);
    vput(dvp);
#endif

d488 1
a488 3
	     dp = (const struct dirent *)((const char *) dp + dp->d_reclen)) {
	    if (dp->d_reclen <= 0)
		break;
a489 1
	}
a495 2
	    if (dp->d_reclen <= 0)
		break;
d583 2
a584 5
    struct vnode *dvp  = ap->a_dvp;
    struct vnode **vpp = ap->a_vpp;
    
    int error = xfs_symlink_common(dvp,
				   vpp,
a588 7
    if (error == 0) {
	error = xfs_lookup_common(dvp, cnp, vpp);
#if (!defined(__FreeBSD__) || __FreeBSD_version < 400012) && (!defined(__NetBSD__) || __NetBSD_Version__ < 105240000) && (!defined(__OpenBSD__) || OpenBSD < 200107)
	if (error == 0)
	    vput (*vpp);
#endif
    }
a589 3
#if !defined(__FreeBSD__)
    vput(dvp);
#endif
d774 2
a775 1
    XFSDEB(XDEBVNOPS, ("xfs_unlock: return\n"));
a809 2
#elif defined(PNBUF_PUT)
	PNBUF_PUT(cnp->cn_pnbuf);
d851 1
a851 1
     /* Old BSD
d857 1
a857 11
     */
    /* NetBSD UBC
	IN struct vnode *vp;
	IN voff_t offset;
	IN vm_page_t *m;
	IN int *count;
	IN int centeridx;
	IN vm_prot_t access_type;
	IN int advice;
	IN int flags;
    */
d867 1
a867 7
    error = xfs_data_valid (ap->a_vp, VNODE_TO_XNODE(ap->a_vp)->cred,
			    xfs_curproc(), XFS_DATA_R);
    if (error == 0)
	error = VOP_GETPAGES(DATA_FROM_VNODE(ap->a_vp), 
			     ap->a_offset, ap->a_m,
			     ap->a_count, ap->a_centeridx, ap->a_access_type,
			     ap->a_advice, ap->a_flags);
d877 1
a877 1
     /* Old BSD
d884 1
a884 7
     */
    /* NetBSD UBC (>= 1.5Y)
	IN struct vnode *vp;
	IN voff_t offlo;
	IN voff_t offhi;
	IN int flags;
    */
a894 1
#ifdef HAVE_STRUCT_VOP_PUTPAGES_ARGS_A_SYNC /* FreeBSD-style */
a896 7
#else /* NetBSD-style */
#if defined(__NetBSD__) && __NetBSD_Version__  >= 105250000 
    return VOP_PUTPAGES(t, ap->a_offlo, ap->a_offhi, ap->a_flags);
#else
    return VOP_PUTPAGES(t, ap->a_m, ap->a_count, ap->a_flags, ap->a_rtvals);
#endif
#endif /* HAVE_STRUCT_VOP_PUTPAGES_ARGS_A_SYNC */
a998 32
#ifdef __APPLE__
    struct uio uio;
    struct iovec iov;
    int ret;

    kernel_upl_map(kernel_map, ap->a_pl, &iov.iov_base);
    iov.iov_base+=ap->a_pl_offset;
    iov.iov_len=ap->a_size;

    uio.uio_iov=&iov;
    uio.uio_iovcnt=1;
    uio.uio_offset=ap->a_f_offset;
    uio.uio_resid=ap->a_size;
    uio.uio_segflg=UIO_SYSSPACE; /* XXX what is it? */
    uio.uio_rw=UIO_READ;
    uio.uio_procp=xfs_curproc();

    ret = VOP_READ(ap->a_vp, &uio, 0, ap->a_cred);

    kernel_upl_unmap(kernel_map, ap->a_pl);

    if (ret) {
	kernel_upl_abort_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
			       UPL_ABORT_ERROR | UPL_ABORT_FREE_ON_EMPTY);
    } else {
	kernel_upl_commit_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
				UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY,
				UPL_GET_INTERNAL_PAGE_LIST(ap->a_pl));
    }

    return ret;
#else
a999 1
#endif
a1007 32
#ifdef __APPLE__
    struct uio uio;
    struct iovec iov;
    int ret;

    kernel_upl_map(kernel_map, ap->a_pl, &iov.iov_base);
    iov.iov_base+=ap->a_pl_offset;
    iov.iov_len=ap->a_size;

    uio.uio_iov=&iov;
    uio.uio_iovcnt=1;
    uio.uio_offset=ap->a_f_offset;
    uio.uio_resid=ap->a_size;
    uio.uio_segflg=UIO_SYSSPACE; /* XXX what is it? */
    uio.uio_rw=UIO_WRITE;
    uio.uio_procp=xfs_curproc();

    ret = VOP_WRITE(ap->a_vp, &uio, 0, ap->a_cred);

    kernel_upl_unmap(kernel_map, ap->a_pl);

    if (ret) {
	kernel_upl_abort_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
			       UPL_ABORT_FREE_ON_EMPTY);
    } else {
	kernel_upl_commit_range(ap->a_pl, ap->a_pl_offset, ap->a_size,
				UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY,
				UPL_GET_INTERNAL_PAGE_LIST(ap->a_pl));
    }

    return ret;
#else
a1008 1
#endif
a1011 48
#ifdef HAVE_VOP_CREATEVOBJECT
static int
xfs_createvobject(struct vop_createvobject_args *ap)
/*
struct vop_createvobject_args {
	struct vnode *vp;
	struct ucred *cred;
	struct proc *p;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_createvobject\n"));

    return vop_stdcreatevobject (ap);
}
#endif /* HAVE_VOP_CREATEVOBJECT */

#ifdef HAVE_VOP_DESTROYVOBJECT
static int
xfs_destroyvobject(struct vop_destroyvobject_args *ap)
/*
struct vop_destroyvobject_args {
	struct vnode *vp;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_destroyvobject\n"));

    return vop_stddestroyvobject (ap);
}
#endif /* HAVE_VOP_DESTROYVOBJECT */

#ifdef HAVE_VOP_GETVOBJECT
static int
xfs_getvobject(struct vop_getvobject_args *ap)
/*
struct vop_getvobject_args {
	struct vnode *vp;
	struct vm_object **objpp;
};
 */
{
    XFSDEB(XDEBVNOPS, ("xfs_getvobject\n"));

    return vop_stdgetvobject (ap);
}
#endif /* HAVE_VOP_GETVOBJECT */

a1148 9
#endif
#ifdef HAVE_VOP_CREATEVOBJECT
    {&vop_createvobject_desc, (vop_t *) xfs_createvobject },
#endif
#ifdef HAVE_VOP_DESTROYVOBJECT
    {&vop_destroyvobject_desc, (vop_t *) xfs_destroyvobject },
#endif
#ifdef HAVE_VOP_GETVOBJECT
    {&vop_getvobject_desc, (vop_t *) xfs_getvobject },
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d35 1
a35 1
 * NNPFS operations.
d54 1
a54 1
RCSID("$arla: xfs_vnodeops-bsd.c,v 1.123 2003/02/15 16:40:36 lha Exp $");
d61 1
a61 1
int
a70 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_open_common (ap->a_vp, ap->a_mode, ap->a_cred, ap->a_td);
#else
a71 1
#endif
d76 1
a76 1
int
a88 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_fsync_common(ap->a_vp, ap->a_cred, ap->a_waitfor, ap->a_td);
#else
a90 1
#endif
d95 1
a95 1
int
a103 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_close_common(ap->a_vp, ap->a_fflag, ap->a_td, ap->a_cred);
#else
a104 1
#endif
d109 1
a109 1
int
d123 1
a123 1
int
d137 1
a137 1
int
d145 1
a145 1
    NNPFSDEB(XDEBVNOPS, ("xfs_ioctl\n"));
d152 1
a152 1
int
d158 1
a158 1
    NNPFSDEB(XDEBVNOPS, ("xfs_select\n"));
d165 1
a165 1
int
d177 1
a177 1
    NNPFSDEB(XDEBVNOPS, ("xfs_seek\n"));
d183 1
a183 1
int
d191 1
a191 1
    NNPFSDEB(XDEBVNOPS, ("xfs_poll\n"));
d197 1
a197 1
int
a203 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_getattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_td);
#else
a204 1
#endif
d209 1
a209 1
int
a216 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_setattr_common(ap->a_vp, ap->a_vap, ap->a_cred, ap->a_td);
#else
a217 1
#endif
d222 1
a222 1
int
a230 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_access_common(ap->a_vp, ap->a_mode, ap->a_cred, ap->a_td);
#else
a231 1
#endif
d236 1
a236 1
int
d250 1
a250 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup: (%s, %ld), nameiop = %lu, flags = %lu\n",
a276 3
#ifdef HAVE_FREEBSD_THREAD
	    xfs_vfs_unlock (ap->a_dvp, xfs_cnp_to_thread(cnp));
#else
a277 1
#endif
d286 1
a286 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lookup: error = %d\n", error));
d293 1
a293 1
int
d314 1
a314 1
#if defined(HAVE_KERNEL_ZFREEI)
a316 3
#elif defined(HAVE_KERNEL_UMA_ZFREE_ARG)
	uma_zfree_arg(namei_zone, cnp->cn_pnbuf, NULL);
	cnp->cn_flags &= ~HASBUF;
a318 3
#elif defined(HAVE_KERNEL_ZFREE)
	zfree(namei_zone, cnp->cn_pnbuf);
	cnp->cn_flags &= ~HASBUF;
d328 1
a328 1
int
d335 1
a335 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p     = xfs_cnp_to_thread(cnp);
#else
    d_thread_t *p     = xfs_cnp_to_proc(cnp);
#endif
d350 1
a350 1
    NNPFSDEB(XDEBVNOPS, ("xfs_create: error = %d\n", error));
d357 1
a357 1
int
a366 4
#ifdef HAVE_FREEBSD_THREAD
    int error = xfs_remove_common(dvp, vp, cnp->cn_nameptr, 
				  cnp->cn_cred, xfs_cnp_to_thread(cnp));
#else
a368 1
#endif
d395 1
a395 1
int
a417 3
#ifdef HAVE_FREEBSD_THREAD
				  xfs_cnp_to_thread (ap->a_fcnp));
#else
a418 1
#endif
d432 1
a432 1
int
d444 1
a444 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p     = xfs_cnp_to_thread(cnp);
#else
    d_thread_t *p     = xfs_cnp_to_proc(cnp);
#endif
d458 1
a458 1
    NNPFSDEB(XDEBVNOPS, ("xfs_mkdir: error = %d\n", error));
d465 1
a465 1
int
a476 3
#ifdef HAVE_FREEBSD_THREAD
				 xfs_cnp_to_thread(cnp));
#else
a477 1
#endif
d502 1
a502 1
int
a513 3
#ifdef HAVE_FREEBSD_THREAD
			       xfs_uio_to_thread (ap->a_uio),
#else
a514 1
#endif
d555 1
a555 1
int
d566 1
a566 5
#ifdef HAVE_FREEBSD_THREAD
    d_thread_t *p = cnp->cn_thread;
#else
    d_thread_t *p = cnp->cn_proc;
#endif
a590 3
    /* FreeBSD 5.0 doesn't need to lock the vnode in VOP_LINK */
#if !defined(__FreeBSD_version) || __FreeBSD_version < 500043

a596 1
#endif /* defined(__FreeBSD_version) || __FreeBSD_version < 500043 */
a602 3
#ifdef HAVE_FREEBSD_THREAD
			   xfs_cnp_to_thread (cnp));
#else
a603 1
#endif
d620 1
a620 1
int
d642 1
d645 1
d657 1
a657 1
int
d668 1
a668 1
int
a672 3
#ifdef HAVE_FREEBSD_THREAD
    return xfs_inactive_common(ap->a_vp, xfs_curthread());
#else
a673 1
#endif
d678 1
a678 1
int
d701 1
a701 1
int
d710 1
a710 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lock: %lx, flags 0x%x\n",
d716 4
a719 6
    NNPFSDEB(XDEBVNOPS, ("xfs_lock before: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%llx\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount,
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));
a722 3
#ifdef HAVE_FREEBSD_THREAD
    ret = lockmgr(l, flags, &vp->v_interlock, ap->a_td);
#else
a723 1
#endif
a727 4
#ifdef HAVE_FREEBSD_THREAD
    ret = debuglockmgr(l, flags, &vp->v_interlock, ap->a_td,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#else
d731 4
a734 7
#endif
    NNPFSDEB(XDEBVNOPS, ("xfs_lock: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%llx\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount, 
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));
d740 1
a740 1
int
d752 1
a752 1
    NNPFSDEB(XDEBVNOPS,
d758 4
a761 6
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: lk flags: %d share: %d "
			 "wait: %d excl: %d holder: 0x%lld\n",
			 l->lk_flags, l->lk_sharecount, l->lk_waitcount,
			 l->lk_exclusivecount, 
			 (unsigned long long)
			 (xfs_uintptr_t)l->lk_lockholder));
a763 3
#ifdef HAVE_FREEBSD_THREAD
    ret = lockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_td);
#else
a764 1
#endif
a768 4
#ifdef HAVE_FREEBSD_THREAD
    ret = debuglockmgr (l, flags | LK_RELEASE, &vp->v_interlock, ap->a_td,
			"xfs_lock", ap->a_vp->filename, ap->a_vp->line);
#else
d772 1
a772 2
#endif
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: return %d\n", ret));
d778 1
a778 1
int
d785 1
a785 1
    NNPFSDEB(XDEBVNOPS, ("xfs_islocked: %lx\n",
a788 3
#ifdef HAVE_FREEBSD_THREAD
    return lockstatus (l, ap->a_td);
#else
a789 1
#endif
d801 1
a801 1
int
d807 1
a807 1
    NNPFSDEB(XDEBVNOPS, ("xfs_lock: %lx, %d\n",
d822 1
a822 1
int
d827 1
a827 1
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: %lx, %d\n",
d835 1
a835 1
    NNPFSDEB(XDEBVNOPS, ("xfs_unlock: return\n"));
d842 1
a842 1
int
d848 1
a848 1
    NNPFSDEB(XDEBVNOPS, ("xfs_islocked: %lx, %d\n",
d857 1
a857 1
int
d865 1
a865 1
#if defined(HAVE_KERNEL_ZFREEI)
a867 3
#elif defined(HAVE_KERNEL_UMA_ZFREE_ARG)
	uma_zfree_arg(namei_zone, cnp->cn_pnbuf, NULL);
	cnp->cn_flags &= ~HASBUF;
a869 3
#elif defined(HAVE_KERNEL_ZFREE)
	zfree(namei_zone, cnp->cn_pnbuf);
	ap->a_cnp->cn_flags &= ~HASBUF;
d880 1
a880 1
int
d889 1
a889 4
    NNPFSDEB(XDEBVNOPS, ("xfs_mmap\n"));
#ifdef HAVE_KERNEL_GENFS_MMAP
    return genfs_mmap(ap);
#else
a890 1
#endif
d895 1
a895 1
int
d905 1
a905 1
    NNPFSDEB(XDEBVNOPS, ("xfs_bmap\n"));
d911 1
a911 13

static size_t
get_pages_endlength (struct vop_getpages_args *ap)
{
#ifdef HAVE_STRUCT_VOP_GETPAGES_ARGS_A_OFFSET
    /* NetBSD ubc */
    return (ap->a_offset << PAGE_SHIFT) + *ap->a_count * PAGE_SIZE;
#else
    return (ap->a_reqpage << PAGE_SHIFT) +  ap->a_count * PAGE_SIZE;
#endif
}

int
d933 1
a933 1
    NNPFSDEB(XDEBVNOPS, ("xfs_getpages\n"));
d939 2
a940 3
    error = xfs_data_valid (ap->a_vp, VNODE_TO_XNODE(ap->a_vp)->rd_cred,
			    xfs_curproc(), NNPFS_DATA_R,
			    get_pages_endlength(ap));
d947 1
a947 1
    NNPFSDEB(XDEBVNOPS, ("xfs_getpages = %d\n", error));
d953 1
a953 1
int
d975 1
a975 1
    NNPFSDEB(XDEBVNOPS, ("xfs_putpages\n"));
d977 1
a977 2
    if (t == NULL)
	return 0;
a979 2
    xn->flags |= NNPFS_DATA_DIRTY;

a983 17
    /* XXX should only walk over those pages that is requested */
    if (vp->v_type == VREG && ap->a_flags & PGO_CLEANIT) {
	struct uvm_object *uobj = &t->v_uobj;
	struct vm_page *pg;
	int dirty = 0;

	pg = TAILQ_FIRST(&uobj->memq);

	while (pg && !dirty) {
	    dirty = pmap_is_modified(pg) || (pg->flags & PG_CLEAN) == 0;
	    pg = TAILQ_NEXT(pg, listq);
	}	

	if (dirty)
	    xn->flags |= NNPFS_DATA_DIRTY;
    }

a985 1
    xn->flags |= NNPFS_DATA_DIRTY;
d993 1
a993 1
int
d996 1
a996 1
    NNPFSDEB(XDEBVNOPS, ("xfs_cmp\n"));
d1002 1
a1002 1
int
d1006 1
a1006 1
    NNPFSDEB(XDEBVNOPS, ("xfs_realvp\n"));
d1012 1
a1012 1
int
d1020 1
a1020 1
    NNPFSDEB(XDEBVNOPS, ("xfs_cntl\n"));
d1026 2
a1027 2
int
xfs_print (struct vop_print_args *v)
d1029 1
a1029 4
    struct vop_print_args /* {
	struct vnode	*a_vp;
    } */ *ap = v;
    xfs_printnode_common (ap->a_vp);
d1034 1
d1036 2
a1037 2
int
xfs_advlock(struct vop_advlock_args *v)
a1038 1
#if 0
d1051 1
a1051 1
/*     if (NNPFS_TOKEN_GOT(xn,  */
d1053 1
d1060 1
a1060 1
	locktype = NNPFS_READLOCK;
d1066 3
a1068 7
#elif defined(HAVE_KERNEL_LF_ADVLOCK) && !defined(__OpenBSD__) && !defined(__APPLE__)
    struct xfs_node *xn = VNODE_TO_XNODE(ap->a_vp);
 
    return lf_advlock(ap, &xn->lockf, xn->attr.va_size);
  #else
     return EOPNOTSUPP;
#endif
d1071 1
d1074 2
a1075 2
int
xfs_revoke(struct vop_revoke_args *v)
d1088 1
a1088 1
int
a1109 4
    /* Zero out rest of last page if there wasn't enough data in the file */
    if (ret == 0 && uio.uio_resid > 0)
	bzero(iov.iov_base, uio.uio_resid);
    
d1123 1
a1123 1
#error pagein on non apple ?
d1130 1
a1130 1
int
d1165 1
a1165 1
#error pageout on non apple ?
d1171 1
a1171 1
int
d1181 1
a1181 1
    NNPFSDEB(XDEBVNOPS, ("xfs_createvobject\n"));
d1188 1
a1188 1
int
d1196 1
a1196 1
    NNPFSDEB(XDEBVNOPS, ("xfs_destroyvobject\n"));
d1203 1
a1203 1
int
d1212 1
a1212 1
    NNPFSDEB(XDEBVNOPS, ("xfs_getvobject\n"));
a1217 23
#ifdef HAVE_VOP_PATHCONF
int
xfs_pathconf(struct vop_pathconf_args *ap)
/*
struct vop_pathconf_args {
        struct vnodeop_desc *a_desc;
        struct vnode *a_vp;
        int a_name;
};
*/
{
    NNPFSDEB(XDEBVNOPS, ("xfs_pathconf\n"));

#ifdef HAVE_KERNEL_VOP_STDPATHCONF
    return vop_stdpathconf(ap);
#else
    return EOPNOTSUPP;
#endif
}
#endif



d1223 1
a1223 1
    NNPFSDEB(XDEBVNOPS, ("xfs_eopnotsupp %s\n", ap->a_desc->vdesc_name));
d1230 1
a1230 1
    NNPFSDEB(XDEBVNOPS, ("xfs_returnzero %s\n", ap->a_desc->vdesc_name));
a1233 12
void
xfs_pushdirty(struct vnode *vp, struct ucred *cred, d_thread_t *p)
{
#if defined(__NetBSD_Version__) && __NetBSD_Version__ >= 105280000
    VOP_PUTPAGES(vp, 0, 0, PGO_ALLPAGES|PGO_SYNCIO|PGO_CLEANIT);
#elif defined(__APPLE__)
    ubc_pushdirty(vp);
#endif
}



d1345 1
d1349 1
a1363 3
#endif
#ifdef HAVE_VOP_PATHCONF
    {&vop_pathconf_desc, (vop_t *) xfs_pathconf },
@


1.1.4.5
log
@Merge with the trunk
@
text
@a53 2
#include <sys/pool.h>

d356 1
a356 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d980 1
a980 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1186 1
d1194 20
a1213 1
#if defined(HAVE_KERNEL_LF_ADVLOCK) && !defined(__APPLE__)
d1216 2
a1217 3
    return (lf_advlock(&xn->lockf, xn->attr.va_size, ap->a_id, ap->a_op,
	    ap->a_fl, ap->a_flags));
#else
@


