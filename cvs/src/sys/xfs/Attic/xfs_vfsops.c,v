head	1.5;
access;
symbols
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	UBC_SYNC_A:1.5
	UBC_SYNC_B:1.5
	SMP:1.5.0.2
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.5
date	99.04.30.02.13.24;	author art;	state dead;
branches;
next	1.4;

1.4
date	99.01.11.05.12.40;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.09.06.01.48.58;	author art;	state Exp;
branches;
next	1.2;

1.2
date	98.08.31.05.13.19;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.08.30.16.47.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.5
log
@gc old files
@
text
@/*	$OpenBSD: xfs_vfsops.c,v 1.4 1999/01/11 05:12:40 millert Exp $	*/
/*
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/uio.h>
#include <sys/mount.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/conf.h>
#include <sys/proc.h>
#include <sys/vnode.h>

#include <xfs/xfs_common.h>
#include <xfs/xfs_message.h>
#include <xfs/xfs_dev.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_deb.h>

RCSID("$KTH: xfs_vfsops.c,v 1.22 1998/08/13 01:38:49 art Exp $");

/*
 * XFS vfs operations.
 */

static struct vnode *make_dead_vnode(struct mount *mp);

struct xfs xfs[NXFS];

static int
xfs_mount(struct mount *mp,
	const char *user_path,
	caddr_t user_data,
	struct nameidata *ndp,
	struct proc *p)
{
	struct vnode	*devvp;
	dev_t		dev;
	int		error;
	struct vattr	vat;
	char		path[MAXPATHLEN];
	char		data[MAXPATHLEN];
	size_t		len;

	error = copyinstr(user_path, path, MAXPATHLEN, &len);
	if (error)
		return error;

	error = copyinstr(user_data, data, MAXPATHLEN, &len);
	if (error)
		return error;

	XFSDEB(XDEBVFOPS, ("xfs_mount: "
			   "struct mount mp = %p path = %s data = '%s'\n",
			   mp, path, data));

	NDINIT(ndp, LOOKUP, FOLLOW | LOCKLEAF,
	       UIO_SYSSPACE, data, p);

	error = namei(ndp);
	if (error)
		return error;

	devvp = ndp->ni_vp;

	if (devvp->v_type != VCHR) {
		vput(devvp);
		return ENXIO;
	}
	error = VOP_GETATTR(devvp, &vat, p->p_ucred, p);
	if (error) {
		vput(devvp);
		return error;
	}
	dev = vat.va_rdev;
	vput(devvp);

	/* Check that this device really is an xfs_dev */
	if (major(dev) < 0 || nchrdev < major(dev))
		return ENXIO;
	if (minor(dev) < 0 || NXFS < minor(dev))
		return ENXIO;
#if defined(__NetBSD__) || defined(__OpenBSD__)
	if (cdevsw[major(dev)].d_open != xfs_devopen)
		return ENXIO;
#elif defined(__FreeBSD__)
	if (cdevsw[major(dev)] == NULL
	    || cdevsw[major(dev)]->d_open != xfs_devopen)
		return ENXIO;
#endif

	if (xfs[minor(dev)].status & XFS_MOUNTED)
		return EBUSY;

	xfs[minor(dev)].status = XFS_MOUNTED;
	xfs[minor(dev)].mp = mp;
	xfs[minor(dev)].root = 0;
	xfs[minor(dev)].nnodes = 0;
	xfs[minor(dev)].fd = minor(dev);

	VFS_TO_XFS(mp) = &xfs[minor(dev)];
	vfs_getnewfsid(mp);

	mp->mnt_stat.f_bsize = DEV_BSIZE;
	mp->mnt_stat.f_iosize = DEV_BSIZE;
	mp->mnt_stat.f_blocks = 4711 * 4711;
	mp->mnt_stat.f_bfree = 4711 * 4711;
	mp->mnt_stat.f_bavail = 4711 * 4711;
	mp->mnt_stat.f_files = 4711;
	mp->mnt_stat.f_ffree = 4711;
	mp->mnt_stat.f_owner = 0;
	mp->mnt_stat.f_flags = mp->mnt_flag;

	strncpy(mp->mnt_stat.f_mntonname, path,
		sizeof(mp->mnt_stat.f_mntonname));

	/* XXX - It shouldn't be arla, but that will be solved later */
	strncpy(mp->mnt_stat.f_mntfromname, "arla",
		sizeof(mp->mnt_stat.f_mntfromname));

	strncpy(mp->mnt_stat.f_fstypename, "xfs",
		sizeof(mp->mnt_stat.f_fstypename));

	return 0;
}

static int
xfs_start(struct mount *mp, int flags, struct proc *p)
{
	XFSDEB(XDEBVFOPS, ("xfs_start mp = 0x%x\n", (u_int) mp));
	return 0;
}

static int
xfs_unmount(struct mount *mp, int mntflags, struct proc *p)
{
	struct xfs	*xfsp = VFS_TO_XFS(mp);
	extern int	doforce;
	int		flags = 0;
	int		error;

	XFSDEB(XDEBVFOPS, ("xfs_unmount mp = 0x%x\n", (u_int) mp));

	if (mntflags & MNT_FORCE) {
		if (!doforce)
			return EINVAL;
		flags |= FORCECLOSE;
	}

	error = free_all_xfs_nodes(xfsp, flags);
	if (error)
		return error;

	xfsp->status = 0;

	return 0;
}

static int
xfs_root(struct mount *mp, struct vnode **vpp)
{
	struct xfs	*xfsp = VFS_TO_XFS(mp);
	struct xfs_message_getroot msg;
	int		error;

	XFSDEB(XDEBVFOPS, ("xfs_root mp = 0x%x\n", (u_int) mp));

	do {
		if (xfsp->root != NULL) {
			*vpp = XNODE_TO_VNODE(xfsp->root);
			VREF(*vpp);
			return 0;
		}
		msg.header.opcode = XFS_MSG_GETROOT;
		msg.cred.uid = curproc->p_ucred->cr_uid;
		msg.cred.pag = 0;	       /* XXX */
		error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
		if (error == 0)
			error = ((struct xfs_message_wakeup *) & msg)->error;
	} while (error == 0);
	/*
	 * Failed to get message through, need to pretend that all went well
	 * and return a fake dead vnode to be able to unmount.
	 */
	*vpp = make_dead_vnode(mp);
	(*vpp)->v_flag |= VROOT;

	return 0;
}

static int
xfs_quotactl(struct mount *mp, int cmd, uid_t uid, caddr_t arg, struct proc *p)
{
	XFSDEB(XDEBVFOPS, ("xfs_quotactl\n"));

	return (EOPNOTSUPP);
}

static int
xfs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	XFSDEB(XDEBVFOPS, ("xfs_statfs\n"));

	bcopy(&mp->mnt_stat, sbp, sizeof(*sbp));
	return 0;
}

static int
xfs_sync(struct mount *mp, int waitfor, struct ucred *cred, struct proc *p)
{
	XFSDEB(XDEBVFOPS, ("xfs_sync\n"));

	return 0;
}

/*
 * This could be implemented by searching if ino_t was bigger.
 */
static int
xfs_vget(struct mount *mp, ino_t ino, struct vnode **vpp)
{
	XFSDEB(XDEBVFOPS, ("xfs_vget\n"));

	return EOPNOTSUPP;
}

static int
xfs_fhtovp(struct mount *mp, struct fid *fhp, struct mbuf *nam,
	   struct vnode **vpp, int *exflagsp, struct ucred **credanonp)
{
	XFSDEB(XDEBVFOPS, ("xfs_fhtovp\n"));

	return EOPNOTSUPP;
}

static int
xfs_vptofh(struct vnode *vp, struct fid *fhp)
{
	XFSDEB(XDEBVFOPS, ("xfs_vptofh\n"));

	return EOPNOTSUPP;
}

/* sysctl()able variables :-) */
static int
xfs_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
	   void *newp, size_t newlen, struct proc *p)
{
	/* Supposed to be terminal... */
	if (namelen != 1)
		return (ENOTDIR);

	return (EOPNOTSUPP);
}

static int
xfs_init(struct vfsconf *vfsp)
{
	XFSDEB(XDEBVFOPS, ("xfs_init\n"));

	return (0);
}

struct vfsops xfs_vfsops = {
	xfs_mount,
	xfs_start,
	xfs_unmount,
	xfs_root,
	xfs_quotactl,
	xfs_statfs,
	xfs_sync,
	xfs_vget,
	xfs_fhtovp,
	xfs_vptofh,
	xfs_init,
	xfs_sysctl
};

/*
 *
 */
static int
xfs_uprintf_filsys(void)
{
	return 0;
}

/*
 * Install and uninstall filesystem.
 */

extern struct vnodeopv_desc xfs_vnodeop_opv_desc;

int
xfs_install_filesys(void)
{
	struct vfsconf *vfsp;
	struct vfsconf **vfspp;

	/* Check if filesystem already known */
	for (vfspp = &vfsconf, vfsp = vfsconf;
	     vfsp;
	     vfspp = &vfsp->vfc_next, vfsp = vfsp->vfc_next)
		if (strncmp(vfsp->vfc_name,
			    "xfs", MFSNAMELEN) == 0)
			return (EEXIST);

	/* Allocate and initialize */
	MALLOC(vfsp, struct vfsconf *, sizeof(struct vfsconf),
	       M_VFS, M_WAITOK);

	vfsp->vfc_vfsops = &xfs_vfsops;
	strncpy(vfsp->vfc_name, "xfs", MFSNAMELEN);
	vfsp->vfc_typenum = 0;
	vfsp->vfc_refcount = 0;
	vfsp->vfc_flags = 0;
	vfsp->vfc_mountroot = 0;
	vfsp->vfc_next = NULL;

	maxvfsconf++;

	/* Add to the end of the list */
	*vfspp = vfsp;

	/* Call vfs_init() */
	printf("Calling vfs_init()\n");
	(*(vfsp->vfc_vfsops->vfs_init)) (vfsp);

	/* done! */

	return 0;
}

int
xfs_uninstall_filesys(void)
{
	struct vfsconf *vfsp;
	struct vfsconf **vfspp;

	/* Find our vfsconf struct */
	for (vfspp = &vfsconf, vfsp = vfsconf;
	     vfsp;
	     vfspp = &vfsp->vfc_next, vfsp = vfsp->vfc_next)
		if (strncmp(vfsp->vfc_name,
			    "xfs",
			    MFSNAMELEN) == 0)
			break;

	if (!vfsp)		       /* Not found */
		return (EEXIST);

	if (vfsp->vfc_refcount)	       /* In use */
		return (EBUSY);

	/* Remove from list and free  */
	*vfspp = vfsp->vfc_next;
	FREE(vfsp, M_VFS);

	maxvfsconf--;

	return 0;
}

int
xfs_stat_filesys(void)
{
	return xfs_uprintf_filsys();
}

/*
 * To be able to unmount when the XFS daemon is not
 * responding we need a root vnode, use a dead vnode!
 */
extern int (**dead_vnodeop_p) (void *);

static struct vnode *
make_dead_vnode(struct mount *mp)
{
	struct vnode	*dead;
	int		error;

	XFSDEB(XDEBNODE, ("make_dead_vnode mp = 0x%x\n", (u_int) mp));

	if ((error = getnewvnode(VT_NON, mp, dead_vnodeop_p, &dead)))
		panic("make_dead_vnode: getnewvnode failed: error = %d",
		      error);

	return dead;
}
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_vfsops.c,v 1.3 1998/09/06 01:48:58 art Exp $	*/
@


1.3
log
@ * reorganize some includes
 * start using the VT_XFS tag on vnodes
 * be more paranoid about closed channel when going to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_vfsops.c,v 1.2 1998/08/31 05:13:19 art Exp $	*/
d421 1
a421 1
		panic("make_dead_vnode: getnewvnode failed: error = %d\n",
@


1.2
log
@indent the code and move around some includes, after discussion with Theo
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_vfsops.c,v 1.1 1998/08/30 16:47:22 art Exp $	*/
d48 1
d51 4
a60 6

#include <xfs/xfs_common.h>
#include <xfs/xfs_message.h>
#include <xfs/xfs_dev.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_deb.h>
@


1.1
log
@xfs - a filesystem using a user-land cache manager. Designed for AFS.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
#include <sys/xfs_message.h>
d63 1
a63 1
static struct vnode *make_dead_vnode(struct mount * mp);
d68 46
a113 33
xfs_mount(struct mount * mp,
	  const char *user_path,
	  caddr_t user_data,
	  struct nameidata * ndp,
	  struct proc * p)
{
    struct vnode *devvp;
    dev_t dev;
    int error;
    struct vattr vat;
    char path[MAXPATHLEN];
    char data[MAXPATHLEN];
    size_t len;

    error = copyinstr(user_path, path, MAXPATHLEN, &len);
    if (error)
	return error;

    error = copyinstr(user_data, data, MAXPATHLEN, &len);
    if (error)
	return error;

    XFSDEB(XDEBVFOPS, ("xfs_mount: "
		       "struct mount mp = %p path = %s data = '%s'\n",
		       mp, path, data));

    NDINIT(ndp, LOOKUP, FOLLOW | LOCKLEAF,
	   UIO_SYSSPACE, data, p);
    error = namei(ndp);
    if (error)
	return error;

    devvp = ndp->ni_vp;
d115 5
a119 17
    if (devvp->v_type != VCHR) {
	vput(devvp);
	return ENXIO;
    }
    error = VOP_GETATTR(devvp, &vat, p->p_ucred, p);
    if (error) {
	vput(devvp);
	return error;
    }
    dev = vat.va_rdev;
    vput(devvp);

    /* Check that this device really is an xfs_dev */
    if (major(dev) < 0 || nchrdev < major(dev))
	return ENXIO;
    if (minor(dev) < 0 || NXFS < minor(dev))
	return ENXIO;
d121 2
a122 2
    if (cdevsw[major(dev)].d_open != xfs_devopen)
	return ENXIO;
d124 3
a126 3
    if (cdevsw[major(dev)] == NULL
	|| cdevsw[major(dev)]->d_open != xfs_devopen)
	return ENXIO;
d129 2
a130 2
    if (xfs[minor(dev)].status & XFS_MOUNTED)
	return EBUSY;
d132 5
a136 5
    xfs[minor(dev)].status = XFS_MOUNTED;
    xfs[minor(dev)].mp = mp;
    xfs[minor(dev)].root = 0;
    xfs[minor(dev)].nnodes = 0;
    xfs[minor(dev)].fd = minor(dev);
d138 2
a139 2
    VFS_TO_XFS(mp) = &xfs[minor(dev)];
    vfs_getnewfsid(mp);
d141 9
a149 9
    mp->mnt_stat.f_bsize = DEV_BSIZE;
    mp->mnt_stat.f_iosize = DEV_BSIZE;
    mp->mnt_stat.f_blocks = 4711 * 4711;
    mp->mnt_stat.f_bfree = 4711 * 4711;
    mp->mnt_stat.f_bavail = 4711 * 4711;
    mp->mnt_stat.f_files = 4711;
    mp->mnt_stat.f_ffree = 4711;
    mp->mnt_stat.f_owner = 0;
    mp->mnt_stat.f_flags = mp->mnt_flag;
d151 2
a152 3
    strncpy(mp->mnt_stat.f_mntonname,
	    path,
	    sizeof(mp->mnt_stat.f_mntonname));
d154 3
a156 3
    strncpy(mp->mnt_stat.f_mntfromname,
	    "arla",
	    sizeof(mp->mnt_stat.f_mntfromname));
d158 2
a159 3
    strncpy(mp->mnt_stat.f_fstypename,
	    "xfs",
	    sizeof(mp->mnt_stat.f_fstypename));
d161 1
a161 1
    return 0;
d165 1
a165 1
xfs_start(struct mount * mp, int flags, struct proc * p)
d167 2
a168 2
    XFSDEB(XDEBVFOPS, ("xfs_start mp = 0x%x\n", (u_int) mp));
    return 0;
d172 1
a172 1
xfs_unmount(struct mount * mp, int mntflags, struct proc * p)
d174 4
a177 4
    struct xfs *xfsp = VFS_TO_XFS(mp);
    extern int doforce;
    int flags = 0;
    int error;
d179 1
a179 1
    XFSDEB(XDEBVFOPS, ("xfs_unmount mp = 0x%x\n", (u_int) mp));
d181 5
a185 5
    if (mntflags & MNT_FORCE) {
	if (!doforce)
	    return EINVAL;
	flags |= FORCECLOSE;
    }
d187 3
a189 3
    error = free_all_xfs_nodes(xfsp, flags);
    if (error)
	return error;
d191 1
a191 1
    xfsp->status = 0;
d193 1
a193 1
    return 0;
d197 1
a197 1
xfs_root(struct mount * mp, struct vnode ** vpp)
d199 3
a201 3
    struct xfs *xfsp = VFS_TO_XFS(mp);
    struct xfs_message_getroot msg;
    int error;
d203 1
a203 1
    XFSDEB(XDEBVFOPS, ("xfs_root mp = 0x%x\n", (u_int) mp));
d205 21
a225 20
    do {
	if (xfsp->root != NULL) {
	    *vpp = XNODE_TO_VNODE(xfsp->root);
	    VREF(*vpp);
	    return 0;
	}
	msg.header.opcode = XFS_MSG_GETROOT;
	msg.cred.uid = curproc->p_ucred->cr_uid;
	msg.cred.pag = 0;	       /* XXX */
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
    } while (error == 0);
    /*
     * Failed to get message through, need to pretend that all went well
     * and return a fake dead vnode to be able to unmount.
     */
    *vpp = make_dead_vnode(mp);
    (*vpp)->v_flag |= VROOT;
    return 0;
d229 1
a229 5
xfs_quotactl(struct mount * mp,
	     int cmd,
	     uid_t uid,
	     caddr_t arg,
	     struct proc * p)
d231 3
a233 2
    XFSDEB(XDEBVFOPS, ("xfs_quotactl\n"));
    return (EOPNOTSUPP);
d237 1
a237 3
xfs_statfs(struct mount * mp,
	   struct statfs * sbp,
	   struct proc * p)
d239 1
a239 1
    XFSDEB(XDEBVFOPS, ("xfs_statfs\n"));
d241 2
a242 2
    bcopy(&mp->mnt_stat, sbp, sizeof(*sbp));
    return 0;
d246 1
a246 4
xfs_sync(struct mount * mp,
	 int waitfor,
	 struct ucred * cred,
	 struct proc * p)
d248 3
a250 2
    XFSDEB(XDEBVFOPS, ("xfs_sync\n"));
    return 0;
d253 3
d257 1
a257 3
xfs_vget(struct mount * mp,
	 ino_t ino,
	 struct vnode ** vpp)
d259 3
a261 2
    XFSDEB(XDEBVFOPS, ("xfs_vget\n"));
    return EOPNOTSUPP;
d265 2
a266 6
xfs_fhtovp(struct mount * mp,
	   struct fid * fhp,
	   struct mbuf * nam,
	   struct vnode ** vpp,
	   int *exflagsp,
	   struct ucred ** credanonp)
d268 3
a270 2
    XFSDEB(XDEBVFOPS, ("xfs_fhtovp\n"));
    return EOPNOTSUPP;
d274 1
a274 2
xfs_vptofh(struct vnode * vp,
	   struct fid * fhp)
d276 3
a278 2
    XFSDEB(XDEBVFOPS, ("xfs_vptofh\n"));
    return EOPNOTSUPP;
a280 1

d283 2
a284 2
xfs_sysctl(int *name, u_int namelen, void *oldp, size_t * oldlenp,
	   void *newp, size_t newlen, struct proc * p)
d286 3
a288 3
    /* Supposed to be terminal... */
    if (namelen != 1)
	return (ENOTDIR);
d290 1
a290 1
    return (EOPNOTSUPP);
d294 1
a294 1
xfs_init(struct vfsconf * vfsp)
d296 1
a296 1
    XFSDEB(XDEBVFOPS, ("xfs_init\n"));
d298 1
a298 1
    return (0);
a300 1

d302 12
a313 12
    xfs_mount,
    xfs_start,
    xfs_unmount,
    xfs_root,
    xfs_quotactl,
    xfs_statfs,
    xfs_sync,
    xfs_vget,
    xfs_fhtovp,
    xfs_vptofh,
    xfs_init,
    xfs_sysctl
d322 1
a322 1
    return 0;
d334 2
d337 28
a364 2
    struct vfsconf *vfsp;
    struct vfsconf **vfspp;
d366 1
d368 1
a368 32
    /* Check if filesystem already known */
    for (vfspp = &vfsconf, vfsp = vfsconf;
	 vfsp;
	 vfspp = &vfsp->vfc_next, vfsp = vfsp->vfc_next)
	if (strncmp(vfsp->vfc_name,
		    "xfs", MFSNAMELEN) == 0)
	    return (EEXIST);

    /* Allocate and initialize */
    MALLOC(vfsp, struct vfsconf *, sizeof(struct vfsconf),
	   M_VFS, M_WAITOK);

    vfsp->vfc_vfsops = &xfs_vfsops;
    strncpy(vfsp->vfc_name, "xfs", MFSNAMELEN);
    vfsp->vfc_typenum = 0;
    vfsp->vfc_refcount = 0;
    vfsp->vfc_flags = 0;
    vfsp->vfc_mountroot = 0;
    vfsp->vfc_next = NULL;

    maxvfsconf++;

    /* Add to the end of the list */
    *vfspp = vfsp;

    /* Call vfs_init() */
    printf("Calling vfs_init()\n");
    (*(vfsp->vfc_vfsops->vfs_init)) (vfsp);

    /* done! */

    return 0;
d374 2
d377 18
a394 3
    struct vfsconf *vfsp;
    struct vfsconf **vfspp;

d396 1
a396 8
    /* Find our vfsconf struct */
    for (vfspp = &vfsconf, vfsp = vfsconf;
	 vfsp;
	 vfspp = &vfsp->vfc_next, vfsp = vfsp->vfc_next)
	if (strncmp(vfsp->vfc_name,
		    "xfs",
		    MFSNAMELEN) == 0)
	    break;
d398 1
a398 13
    if (!vfsp)			       /* Not found */
	return (EEXIST);

    if (vfsp->vfc_refcount)	       /* In use */
	return (EBUSY);

    /* Remove from list and free  */
    *vfspp = vfsp->vfc_next;
    FREE(vfsp, M_VFS);

    maxvfsconf--;

    return 0;
a400 2


d404 1
a404 1
    return xfs_uprintf_filsys();
d414 1
a414 1
make_dead_vnode(struct mount * mp)
d416 2
a417 2
    struct vnode *dead;
    int error;
d419 1
a419 1
    XFSDEB(XDEBNODE, ("make_dead_vnode mp = 0x%x\n", (u_int) mp));
d421 3
a423 2
    if ((error = getnewvnode(VT_NON, mp, dead_vnodeop_p, &dead)))
	panic("make_dead_vnode: getnewvnode failed: error = %d\n", error);
d425 1
a425 1
    return dead;
@

