head	1.10;
access;
symbols
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.5
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.9;

1.9
date	2006.06.25.15.01.54;	author sturm;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.14.20.01.50;	author sturm;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.30.14.20.08;	author sturm;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.02.19.38.55;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.26.51;	author art;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	2000.03.03.00.54.58;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.00;	author art;	state Exp;
branches
	1.1.1.1
	1.1.4.1;
next	;

1.1.1.1
date	2002.06.07.03.32.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.52;	author hin;	state Exp;
branches;
next	;

1.1.4.1
date	2000.03.24.09.09.54;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.05.14.22.47.52;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.11.01.47;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include <xfs/xfs_locl.h>
#include <xfs/xfs_message.h>
#include <xfs/xfs_msg_locl.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_dev.h>
#include <xfs/xfs_deb.h>

RCSID("$arla: xfs_dev-common.c,v 1.61 2003/07/15 16:25:42 lha Exp $");

struct xfs_channel xfs_channel[NNNPFS];

void
xfs_initq(struct xfs_link *q)
{
    q->next = q;
    q->prev = q;
}

/* Is this queue empty? */
int
xfs_emptyq(const struct xfs_link *q)
{
    return q->next == q;
}

/* Is this link on any queue? Link *must* be inited! */
int
xfs_onq(const struct xfs_link *link)
{
    return link->next != NULL || link->prev != NULL;
}

/* Append q with p */
void
xfs_appendq(struct xfs_link *q, struct xfs_link *p)
{
    p->next = q;
    p->prev = q->prev;
    p->prev->next = p;
    q->prev = p;
}

/* remove `p' from its queue */
void
xfs_outq(struct xfs_link *p)
{
    p->next->prev = p->prev;
    p->prev->next = p->next;
    p->next = p->prev = NULL;
}

/*
 * Only allow one open.
 */
int
xfs_devopen_common(dev_t dev)
{
    struct xfs_channel *chan;

    if (minor(dev) < 0 || minor(dev) >= NNNPFS)
	return ENXIO;

    chan = &xfs_channel[minor(dev)];

    /* Only allow one reader/writer */
    if (chan->status & CHANNEL_OPENED) {
	NNPFSDEB(XDEBDEV, ("xfs_devopen: already open\n"));
	return EBUSY;
    } else {
	chan->status |= CHANNEL_OPENED;
    }

    chan->message_buffer = xfs_alloc(MAX_XMSG_SIZE, M_NNPFS_MSG);

    /* initialize the queues if they have not been initialized before */
    xfs_initq(&chan->sleepq);
    xfs_initq(&chan->messageq);

    return 0;
}

#if defined(HAVE_TWO_ARGUMENT_VFS_BUSY)
#define xfs_vfs_busy(mp, flags, lock, proc) vfs_busy((mp), (flags))
#define xfs_vfs_unbusy(mp, proc) vfs_unbusy((mp))
#elif defined(HAVE_THREE_ARGUMENT_VFS_BUSY)
#define xfs_vfs_busy(mp, flags, lock, proc) vfs_busy((mp), (flags), (lock))
#define xfs_vfs_unbusy(mp, proc) vfs_unbusy((mp))
#elif defined(HAVE_FOUR_ARGUMENT_VFS_BUSY)
#define xfs_vfs_busy(mp, flags, lock, proc) vfs_busy((mp), (flags), (lock), (proc))
#define xfs_vfs_unbusy(mp, proc) vfs_unbusy((mp), (proc))
#elif defined(__osf__)
#define xfs_vfs_busy(mp, flags, lock, proc) (0)
#define xfs_vfs_unbusy(mp, proc) (0)
#else
#define xfs_vfs_busy(mp, flags, lock, proc) vfs_busy((mp))
#define xfs_vfs_unbusy(mp, proc) vfs_unbusy((mp))
#endif

/*
 * Wakeup all sleepers and cleanup.
 */
int
xfs_devclose_common(dev_t dev, d_thread_t *proc)
{
    struct xfs_channel *chan = &xfs_channel[minor(dev)];
    struct xfs_link *first;
    
    /* Sanity check, paranoia? */
    if (!(chan->status & CHANNEL_OPENED))
	panic("xfs_devclose never opened?");

    chan->status &= ~CHANNEL_OPENED;

    /* No one is going to read those messages so empty queue! */
    while (!xfs_emptyq(&chan->messageq)) {
	NNPFSDEB(XDEBDEV, ("before outq(messageq)\n"));

	first = chan->messageq.next;
	xfs_outq(first);
	if (first->error_or_size != 0)
	    xfs_free(first, first->error_or_size, M_NNPFS_LINK);

	NNPFSDEB(XDEBDEV, ("after outq(messageq)\n"));
    }

    /* Wakeup those waiting for replies that will never arrive. */
    while (!xfs_emptyq(&chan->sleepq)) {
	NNPFSDEB(XDEBDEV, ("before outq(sleepq)\n"));
	first = chan->sleepq.next;
	xfs_outq(first);
	first->error_or_size = ENODEV;
	wakeup((caddr_t) first);
	NNPFSDEB(XDEBDEV, ("after outq(sleepq)\n"));
    }

    if (chan->status & CHANNEL_WAITING)
	wakeup((caddr_t) chan);

    if (chan->message_buffer) {
	xfs_free(chan->message_buffer, MAX_XMSG_SIZE, M_NNPFS_MSG);
	chan->message_buffer = NULL;
    }

    /*
     * Free all xfs nodes.
     */

    if (xfs[minor(dev)].mp != NULL) {
	if (xfs_vfs_busy(xfs[minor(dev)].mp, VB_READ|VB_WAIT, NULL, proc)) {
	    NNPFSDEB(XDEBNODE, ("xfs_dev_close: vfs_busy() --> BUSY\n"));
	    return EBUSY;
	}
	free_all_xfs_nodes(&xfs[minor(dev)], FORCECLOSE, 0);

	xfs_vfs_unbusy(xfs[minor(dev)].mp, proc);
    }
    
    return 0;
}

#ifdef NNPFS_DEBUG
/*
 * debugging glue for CURSIG
 */

static long
xfs_cursig (d_thread_t *p)
{
#if defined(__osf__)
    thread_t th 	= current_thread();
    struct np_uthread	*npu = thread_to_np_uthread(th);
    return CURSIG(p,npu);
#elif defined(HAVE_FREEBSD_THREAD)
#ifndef CURSIG
    return 0; /* XXX we would like to use sig_ffs, but that isn't
	       * exported */
#else
    return CURSIG(p->td_proc);
#endif
#else
#if defined(__NetBSD__) && __NetBSD_Version__ >= 106130000
    return 0; /* XXX CURSIG operates on a struct lwp */
#else
    return CURSIG(p);
#endif
#endif
}
#endif

/*
 * Move messages from kernel to user space.
 */

int
xfs_devread(dev_t dev, struct uio * uiop, int ioflag)
{
    struct xfs_channel *chan = &xfs_channel[minor(dev)];
    struct xfs_link *first;
    int error = 0;
#ifdef NNPFS_DEBUG
    char devname[64];
#endif

    NNPFSDEB(XDEBDEV, ("xfs_devread dev = %s\n",
		     xfs_devtoname_r(dev, devname, sizeof(devname))));

    NNPFSDEB(XDEBDEV, ("xfs_devread: m = %lx, m->prev = %lx, m->next = %lx\n",
		     (unsigned long)&chan->messageq,
		     (unsigned long)chan->messageq.prev,
		     (unsigned long)chan->messageq.next));

#ifdef HAVE_FREEBSD_THREAD
    chan->proc = xfs_uio_to_thread(uiop);
#else
    chan->proc = xfs_uio_to_proc(uiop);
#endif

 again:

    if (!xfs_emptyq (&chan->messageq)) {
	while (!xfs_emptyq (&chan->messageq)) {
	    /* Remove message */
	    first = chan->messageq.next;
	    NNPFSDEB(XDEBDEV, ("xfs_devread: first = %lx, "
			     "first->prev = %lx, first->next = %lx\n",
			     (unsigned long)first,
			     (unsigned long)first->prev,
			     (unsigned long)first->next));
	    
	    NNPFSDEB(XDEBDEV, ("xfs_devread: message->size = %u\n",
			     first->message->size));
	    
	    if (first->message->size > uiop->uio_resid)
		break;

	    error = uiomove((caddr_t) first->message, first->message->size, 
			    uiop);
	    if (error)
		break;
	    
	    xfs_outq(first);
	    
	    if (first->error_or_size != 0)
		xfs_free(first, first->error_or_size, M_NNPFS_LINK);
	}
    } else {
	chan->status |= CHANNEL_WAITING;
	if (tsleep((caddr_t) chan, (PZERO + 1) | PCATCH, "xfsread", 0)) {
#ifdef HAVE_FREEBSD_THREAD
	    NNPFSDEB(XDEBMSG,
		   ("caught signal xfs_devread: %ld\n",
		    xfs_cursig(xfs_uio_to_thread(uiop))));
#else
	    NNPFSDEB(XDEBMSG,
		   ("caught signal xfs_devread: %ld\n",
		    xfs_cursig(xfs_uio_to_proc(uiop))));
#endif
	    error = EINTR;
	} else if ((chan->status & CHANNEL_WAITING) == 0) {
	    goto again;
	} else
	    error = EIO;
    }
    
    NNPFSDEB(XDEBDEV, ("xfs_devread done error = %d\n", error));

    return error;
}

/*
 * Move messages from user space to kernel space,
 * wakeup sleepers, insert new data in VFS.
 */
int
xfs_devwrite(dev_t dev, struct uio *uiop, int ioflag)
{
    struct xfs_channel *chan = &xfs_channel[minor(dev)];
    char *p;
    int error;
    u_int cnt;
    struct xfs_message_header *msg_buf;
#ifdef NNPFS_DEBUG
    char devname[64];
#endif

    NNPFSDEB(XDEBDEV, ("xfs_devwrite dev = %s\n",
		     xfs_devtoname_r (dev, devname, sizeof(devname))));

#ifdef HAVE_FREEBSD_THREAD
    chan->proc = xfs_uio_to_thread(uiop);
#else
    chan->proc = xfs_uio_to_proc(uiop);
#endif
    cnt = uiop->uio_resid;
    error = uiomove((caddr_t) chan->message_buffer, MAX_XMSG_SIZE, uiop);
    if (error != 0)
	return error;

    cnt -= uiop->uio_resid;

    /*
     * This thread handles the received message.
     */
    for (p = (char *)chan->message_buffer;
	 cnt > 0;
	 p += msg_buf->size, cnt -= msg_buf->size) {
#ifdef HAVE_FREEBSD_THREAD
	d_thread_t *pp = xfs_uio_to_thread(uiop);
#else
	d_thread_t *pp = xfs_uio_to_proc(uiop);
#endif

	msg_buf = (struct xfs_message_header *)p;
	error = xfs_message_receive (minor(dev),
				     msg_buf,
				     msg_buf->size,
				     pp);
    }
    NNPFSDEB(XDEBDEV, ("xfs_devwrite error = %d\n", error));
    return error;
}

/*
 * Send a message to user space.
 */
int
xfs_message_send(int fd, struct xfs_message_header * message, u_int size)
{
    struct xfs_channel *chan = &xfs_channel[fd];
    struct {
	struct xfs_link this_message;
	struct xfs_message_header msg;
    } *t;

    NNPFSDEB(XDEBMSG, ("xfs_message_send opcode = %d\n", message->opcode));

    if (!(chan->status & CHANNEL_OPENED))	/* No receiver? */
	return ENODEV;

    /* Prepare message and copy it later */
    message->size = size;
    message->sequence_num = chan->nsequence++;

    t = xfs_alloc(sizeof(t->this_message) + size, M_NNPFS);
    t->this_message.error_or_size = sizeof(t->this_message) + size;
    bcopy(message, &t->msg, size);

    t->this_message.message = &t->msg;
    xfs_appendq(&chan->messageq, &t->this_message);
    if (chan->status & CHANNEL_WAITING) {
	chan->status &= ~CHANNEL_WAITING;
	wakeup((caddr_t) chan);
    }
    xfs_select_wakeup(chan);

    return 0;
}

#if defined(SWEXIT)
#define NNPFS_P_EXIT SWEXIT
#elif defined(P_WEXIT)
#define NNPFS_P_EXIT P_WEXIT
#else
#error what is your exit named ?
#endif

#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(HAVE_STRUCT_PROC_P_SIGWAITMASK) || defined(__osf__) || defined(HAVE_FREEBSD_THREAD)
static void
xfs_block_sigset (sigset_t *sigset)
{

#if defined(__sigaddset)
#define xfs_sig_block(ss,signo) __sigaddset((ss), (signo))
#elif defined(SIGADDSET)
#define xfs_sig_block(ss,signo) SIGADDSET(*(ss), (signo))
#else
#define xfs_sig_block(ss,signo) *(ss) |= sigmask(signo)
#endif

    xfs_sig_block(sigset, SIGIO);
    xfs_sig_block(sigset, SIGALRM);
    xfs_sig_block(sigset, SIGVTALRM);
    xfs_sig_block(sigset, SIGCHLD);
#ifdef SIGINFO
    xfs_sig_block(sigset, SIGINFO);
#endif
#undef xfs_sig_block
}
#endif

/*
 * Send a message to user space and wait for reply.
 */

int
xfs_message_rpc(int fd, struct xfs_message_header * message, u_int size,
		d_thread_t *proc)
{
    int ret;
    struct xfs_channel *chan = &xfs_channel[fd];
    struct xfs_link *this_message;
    struct xfs_link *this_process;
    struct xfs_message_header *msg;
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(__osf__) || defined(HAVE_FREEBSD_THREAD)
    sigset_t oldsigmask;
#endif
    int catch;

    NNPFSDEB(XDEBMSG, ("xfs_message_rpc opcode = %d\n", message->opcode));

    if (proc == NULL) {
#ifdef HAVE_FREEBSD_THREAD
	proc = xfs_curthread();
#else
	proc = xfs_curproc();
#endif
    }
    if (!(chan->status & CHANNEL_OPENED))	/* No receiver? */
	return ENODEV;

#ifdef HAVE_FREEBSD_THREAD
    if (chan->proc != NULL && chan->proc->td_proc != NULL &&
      proc->td_proc->p_pid == chan->proc->td_proc->p_pid) {
	printf("xfs_message_rpc: deadlock avoided "
	       "pid = %u == %u\n", proc->td_proc->p_pid, chan->proc->td_proc->p_pid);
#else
    if (chan->proc != NULL && proc->p_pid == chan->proc->p_pid) {
	printf("xfs_message_rpc: deadlock avoided "
	       "pid = %u == %u\n", proc->p_pid, chan->proc->p_pid);
#endif
#if 0
	psignal (proc, SIGABRT);
#endif
	return EDEADLK;
    }

    if (size < sizeof(struct xfs_message_wakeup)) {
	printf("NNPFS PANIC Error: Message to small to receive wakeup, opcode = %d\n", message->opcode);
	return ENOMEM;
    }
    this_message = xfs_alloc(sizeof(struct xfs_link), M_NNPFS_LINK);
    this_process = xfs_alloc(sizeof(struct xfs_link), M_NNPFS_LINK);
    msg = xfs_alloc(size, M_NNPFS_MSG);
    bcopy(message, msg, size);

    msg->size = size;
    msg->sequence_num = chan->nsequence++;
    this_message->error_or_size = 0;
    this_message->message = msg;
    this_process->message = msg;
    xfs_appendq(&chan->messageq, this_message);
    xfs_appendq(&chan->sleepq, this_process);
    xfs_select_wakeup(chan);
    this_process->error_or_size = 0;

    if (chan->status & CHANNEL_WAITING) {
	chan->status &= ~CHANNEL_WAITING;
	wakeup((caddr_t) chan);
    }

    /*
     * Remove signals from the sigmask so no IO will wake us up from
     * tsleep(). We don't want to wake up from since program (emacs,
     * bash & co can't handle them.
     */

#ifdef HAVE_FREEBSD_THREAD
    /* FreeBSD 5.1 */
    oldsigmask = proc->td_sigmask;
    xfs_block_sigset (&proc->td_sigmask);
#elif HAVE_STRUCT_PROC_P_SIGMASK
    /* NetBSD 1.5, Darwin 1.3, FreeBSD 4.3, 5.0, OpenBSD 2.8 */
    oldsigmask = proc->p_sigmask;
    xfs_block_sigset (&proc->p_sigmask);
#elif defined(HAVE_STRUCT_PROC_P_SIGCTX)
    /* NetBSD 1.6 */
    oldsigmask = proc->p_sigctx.ps_sigmask;
    xfs_block_sigset (&proc->p_sigctx.ps_sigmask);
#elif defined(HAVE_STRUCT_PROC_P_SIGWAITMASK)
    /* OSF 4.0 */
    oldsigmask = proc->p_sigwaitmask;
    xfs_block_sigset (&proc->p_sigwaitmask);
#elif defined(__osf__)
    /* OSF 5.0 */
    oldsigmask = u.u_sigmask;
    xfs_block_sigset (&u.u_sigmask);
#endif

    /*
     * if we are exiting we should not try to catch signals, since
     * there might not be enough context left in the process to handle
     * signal delivery, and besides, most BSD-variants ignore all
     * signals while closing anyway.
     */

    catch = 0;
#ifdef HAVE_FREEBSD_THREAD
    if (!(proc->td_proc->p_flag & NNPFS_P_EXIT))
#else
    if (!(proc->p_flag & NNPFS_P_EXIT))
#endif
	catch |= PCATCH;

    /*
     * We have to check if we have a receiver here too because the
     * daemon could have terminated before we sleep. This seems to
     * happen sometimes when rebooting.  */

    if (!(chan->status & CHANNEL_OPENED)) {
	NNPFSDEB(XDEBMSG, ("xfs_message_rpc: channel went away\n"));
	this_process->error_or_size = EINTR;
    } else if ((ret = tsleep((caddr_t) this_process,
			     (PZERO + 1) | catch, "xfs", 0)) != 0) {
	NNPFSDEB(XDEBMSG, ("caught signal (%d): %ld\n",
			 ret, xfs_cursig(proc)));
	this_process->error_or_size = EINTR;
    }

#ifdef HAVE_FREEBSD_THREAD
    proc->td_sigmask = oldsigmask;
#elif HAVE_STRUCT_PROC_P_SIGMASK
    proc->p_sigmask = oldsigmask;
#elif defined(HAVE_STRUCT_PROC_P_SIGCTX)
    proc->p_sigctx.ps_sigmask = oldsigmask;
#elif defined(HAVE_STRUCT_PROC_P_SIGWAITMASK)
    proc->p_sigwaitmask = oldsigmask;
#elif defined(__osf__)
    u.u_sigmask = oldsigmask;
#endif

    /*
     * Caught signal, got reply message or device was closed.
     * Need to clean up both messageq and sleepq.
     */
    if (xfs_onq(this_message)) {
	xfs_outq(this_message);
    }
    if (xfs_onq(this_process)) {
	xfs_outq(this_process);
    }
    ret = this_process->error_or_size;

    NNPFSDEB(XDEBMSG, ("xfs_message_rpc this_process->error_or_size = %d\n",
		     this_process->error_or_size));
    NNPFSDEB(XDEBMSG, ("xfs_message_rpc opcode ((xfs_message_wakeup*)(this_process->message))->error = %d\n", ((struct xfs_message_wakeup *) (this_process->message))->error));

    bcopy(msg, message, size);

    xfs_free(this_message, sizeof(*this_message), M_NNPFS_LINK);
    xfs_free(this_process, sizeof(*this_process), M_NNPFS_LINK);
    xfs_free(msg, size, M_NNPFS_MSG);

    return ret;
}

/*
 * For each message type there is a message handler
 * that implements its action, xfs_message_receive
 * invokes the correct function.
 */
int
xfs_message_receive(int fd,
		    struct xfs_message_header *message,
		    u_int size,
		    d_thread_t *p)
{
    NNPFSDEB(XDEBMSG, ("xfs_message_receive opcode = %d\n", message->opcode));

    /* Dispatch and coerce message type */
    switch (message->opcode) {
    case NNPFS_MSG_WAKEUP:
	return xfs_message_wakeup(fd,
				  (struct xfs_message_wakeup *) message,
				  message->size,
				  p);
    case NNPFS_MSG_WAKEUP_DATA:
	return xfs_message_wakeup_data(fd,
				 (struct xfs_message_wakeup_data *) message,
				       message->size,
				       p);
    case NNPFS_MSG_INSTALLROOT:
	return xfs_message_installroot(fd,
				 (struct xfs_message_installroot *) message,
				       message->size,
				       p);
    case NNPFS_MSG_INSTALLNODE:
	return xfs_message_installnode(fd,
				 (struct xfs_message_installnode *) message,
				       message->size,
				       p);
    case NNPFS_MSG_INSTALLATTR:
	return xfs_message_installattr(fd,
				 (struct xfs_message_installattr *) message,
				       message->size,
				       p);
    case NNPFS_MSG_INSTALLDATA:
	return xfs_message_installdata(fd,
				 (struct xfs_message_installdata *) message,
				       message->size,
				       p);
    case NNPFS_MSG_INVALIDNODE:
	return xfs_message_invalidnode(fd,
				 (struct xfs_message_invalidnode *) message,
				       message->size,
				       p);
    case NNPFS_MSG_UPDATEFID:
	return xfs_message_updatefid(fd,
				     (struct xfs_message_updatefid *)message,
				     message->size,
				     p);
    case NNPFS_MSG_GC_NODES:
	return xfs_message_gc_nodes(fd,
				    (struct xfs_message_gc_nodes *)message,
				    message->size,
				    p);
    case NNPFS_MSG_VERSION:
	return xfs_message_version(fd,
				   (struct xfs_message_version *)message,
				   message->size,
				   p);
    default:
	printf("NNPFS PANIC Warning xfs_dev: Unknown message opcode == %d\n",
	       message->opcode);
	return EINVAL;
    }
}

int
xfs_message_wakeup(int fd,
		   struct xfs_message_wakeup *message,
		   u_int size,
		   d_thread_t *p)
{
    struct xfs_channel *chan = &xfs_channel[fd];
    struct xfs_link *sleepq = &chan->sleepq;
    struct xfs_link *t = chan->sleepq.next;	/* Really first in q */

    NNPFSDEB(XDEBMSG, ("xfs_message_wakeup error: %d\n", message->error));

    for (; t != sleepq; t = t->next)
	if (t->message->sequence_num == message->sleepers_sequence_num) {
	    if (t->message->size < size) {
		printf("NNPFS PANIC Error: Could not wakeup requestor with opcode = %d properly, to small receive buffer.\n", t->message->opcode);
		t->error_or_size = ENOMEM;
	    } else
		bcopy(message, t->message, size);

	    wakeup((caddr_t) t);
	    break;
	}

    return 0;
}

int
xfs_message_wakeup_data(int fd,
			struct xfs_message_wakeup_data * message,
			u_int size,
			d_thread_t *p)
{
    struct xfs_channel *chan = &xfs_channel[fd];
    struct xfs_link *sleepq = &chan->sleepq;
    struct xfs_link *t = chan->sleepq.next;	/* Really first in q */

    NNPFSDEB(XDEBMSG, ("xfs_message_wakeup_data error: %d\n", message->error));

    for (; t != sleepq; t = t->next)
	if (t->message->sequence_num == message->sleepers_sequence_num) {
	    if (t->message->size < size) {
		printf("NNPFS PANIC Error: Could not wakeup requestor with opcode = %d properly, to small receive buffer.\n", t->message->opcode);
		t->error_or_size = ENOMEM;
	    } else
		bcopy(message, t->message, size);
	    wakeup((caddr_t) t);
	    break;
	}
    return 0;
}

/*
 *
 */
int
xfs_uprintf_device(void)
{
#if 0
    int i;

    for (i = 0; i < NNNPFS; i++) {
	uprintf("xfs_channel[%d] = {\n", i);
	uprintf("messageq.next = %lx ", xfs_channel[i].messageq.next);
	uprintf("messageq.prev = %lx ", xfs_channel[i].messageq.prev);
	uprintf("sleepq.next = %lx ", xfs_channel[i].sleepq.next);
	uprintf("sleepq.prev = %lx ", xfs_channel[i].sleepq.prev);
	uprintf("nsequence = %d status = %d\n",
		xfs_channel[i].nsequence,
		xfs_channel[i].status);
	uprintf("}\n");
    }
#endif
    return 0;
}
@


1.9
log
@rename vfs_busy() flags VB_UMIGNORE/VB_UMWAIT to VB_NOWAIT/VB_WAIT

requested by and ok pedro
@
text
@@


1.8
log
@move vfs_busy() to rwlocks and properly hide the locking api from vfs

ok tedu, pedro
@
text
@d183 1
a183 1
	if (xfs_vfs_busy(xfs[minor(dev)].mp, VB_READ|VB_UMWAIT, NULL, proc)) {
@


1.7
log
@remove the simplelock argument from vfs_busy() which is currently not
used and will never be used this way in VFS

requested by and ok pedro, ok krw, biorn
@
text
@d183 1
a183 1
	if (xfs_vfs_busy(xfs[minor(dev)].mp, 0, NULL, proc)) {
@


1.6
log
@Merge
@
text
@d116 4
a119 1
#if defined(HAVE_THREE_ARGUMENT_VFS_BUSY)
@


1.5
log
@inital -> initial
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$Id: xfs_dev-common.c,v 1.4 2002/06/07 04:10:32 hin Exp $");
d44 1
a44 1
struct xfs_channel xfs_channel[NXFS];
d90 1
a90 1
xfs_devopen_common(dev_t dev, struct proc *p)
d94 1
a94 1
    if (minor(dev) < 0 || minor(dev) >= NXFS)
d101 1
a101 1
	XFSDEB(XDEBDEV, ("xfs_devopen: already open\n"));
d107 1
a107 1
    chan->message_buffer = xfs_alloc(MAX_XMSG_SIZE);
d134 1
a134 1
xfs_devclose_common(dev_t dev, struct proc *proc)
d147 1
a147 1
	XFSDEB(XDEBDEV, ("before outq(messageq)\n"));
d152 1
a152 1
	    xfs_free(first, first->error_or_size);
d154 1
a154 1
	XFSDEB(XDEBDEV, ("after outq(messageq)\n"));
d159 1
a159 1
	XFSDEB(XDEBDEV, ("before outq(sleepq)\n"));
d164 1
a164 1
	XFSDEB(XDEBDEV, ("after outq(sleepq)\n"));
d171 1
a171 1
	xfs_free(chan->message_buffer, MAX_XMSG_SIZE);
d181 1
a181 1
	    XFSDEB(XDEBNODE, ("xfs_dev_close: vfs_busy() --> BUSY\n"));
d192 1
a192 1
#ifdef XFS_DEBUG
d194 1
a194 1
 * osf glue for CURSIG
d198 1
a198 1
xfs_cursig (struct proc *p)
d200 1
a200 1
#ifdef __osf__
d204 10
d217 1
d231 1
a231 1
#ifdef XFS_DEBUG
d235 1
a235 1
    XFSDEB(XDEBDEV, ("xfs_devread dev = %s\n",
d238 1
a238 1
    XFSDEB(XDEBDEV, ("xfs_devread: m = %lx, m->prev = %lx, m->next = %lx\n",
d243 3
d247 1
d255 1
a255 1
	    XFSDEB(XDEBDEV, ("xfs_devread: first = %lx, "
d261 1
a261 1
	    XFSDEB(XDEBDEV, ("xfs_devread: message->size = %u\n",
d275 1
a275 1
		xfs_free(first, first->error_or_size);
d280 6
a285 1
	    XFSDEB(XDEBMSG,
d288 1
d296 1
a296 1
    XFSDEB(XDEBDEV, ("xfs_devread done error = %d\n", error));
d313 1
a313 1
#ifdef XFS_DEBUG
d317 1
a317 1
    XFSDEB(XDEBDEV, ("xfs_devwrite dev = %s\n",
d320 3
d324 1
d338 5
a342 1
	struct proc *pp = xfs_uio_to_proc(uiop);
d350 1
a350 1
    XFSDEB(XDEBDEV, ("xfs_devwrite error = %d\n", error));
d366 1
a366 1
    XFSDEB(XDEBMSG, ("xfs_message_send opcode = %d\n", message->opcode));
d375 1
a375 1
    t = xfs_alloc(sizeof(t->this_message) + size);
d391 1
a391 1
#define XFS_P_EXIT SWEXIT
d393 1
a393 1
#define XFS_P_EXIT P_WEXIT
d398 1
a398 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX)
d402 1
d404 1
a404 3
    __sigaddset(sigset, SIGIO);
    __sigaddset(sigset, SIGALRM);
    __sigaddset(sigset, SIGVTALRM);
d406 13
a418 8
    SIGADDSET(*sigset, SIGIO);
    SIGADDSET(*sigset, SIGALRM);
    SIGADDSET(*sigset, SIGVTALRM);
#else
    *sigset |= sigmask(SIGIO);
    *sigset |= sigmask(SIGALRM);
    *sigset |= sigmask(SIGVTALRM);
#endif /* __sigaddset */
d428 1
a428 1
		struct proc *proc)
d435 1
a435 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(__osf__)
d440 1
a440 1
    XFSDEB(XDEBMSG, ("xfs_message_rpc opcode = %d\n", message->opcode));
d442 4
a445 1
    if (proc == NULL)
d447 2
a448 1

d452 6
d461 1
d469 1
a469 1
	printf("XFS PANIC Error: Message to small to receive wakeup, opcode = %d\n", message->opcode);
d472 3
a474 3
    this_message = xfs_alloc(sizeof(struct xfs_link));
    this_process = xfs_alloc(sizeof(struct xfs_link));
    msg = xfs_alloc(size);
d493 3
a495 2
     * Remove SIGIO from the sigmask so no IO will
     * wake us up from tsleep()
d498 5
a502 1
#ifdef HAVE_STRUCT_PROC_P_SIGMASK
d513 1
a513 3
    sigaddset(&proc->p_sigwaitmask, SIGIO);
    sigaddset(&proc->p_sigwaitmask, SIGALRM);
    sigaddset(&proc->p_sigwaitmask, SIGVTALRM);
d515 1
d517 1
a517 3
    sigaddset(&u.u_sigmask, SIGIO);
    sigaddset(&u.u_sigmask, SIGALRM);
    sigaddset(&u.u_sigmask, SIGVTALRM);
d528 5
a532 1
    if (!(proc->p_flag & XFS_P_EXIT))
d541 1
a541 1
	XFSDEB(XDEBMSG, ("xfs_message_rpc: channel went away\n"));
d545 1
a545 1
	XFSDEB(XDEBMSG, ("caught signal (%d): %ld\n",
d550 3
a552 1
#ifdef HAVE_STRUCT_PROC_P_SIGMASK
d574 1
a574 1
    XFSDEB(XDEBMSG, ("xfs_message_rpc this_process->error_or_size = %d\n",
d576 1
a576 1
    XFSDEB(XDEBMSG, ("xfs_message_rpc opcode ((xfs_message_wakeup*)(this_process->message))->error = %d\n", ((struct xfs_message_wakeup *) (this_process->message))->error));
d580 3
a582 3
    xfs_free(this_message, sizeof(*this_message));
    xfs_free(this_process, sizeof(*this_process));
    xfs_free(msg, size);
d596 1
a596 1
		    struct proc *p)
d598 1
a598 1
    XFSDEB(XDEBMSG, ("xfs_message_receive opcode = %d\n", message->opcode));
d602 1
a602 1
    case XFS_MSG_WAKEUP:
d607 1
a607 1
    case XFS_MSG_WAKEUP_DATA:
d612 1
a612 1
    case XFS_MSG_INSTALLROOT:
d617 1
a617 1
    case XFS_MSG_INSTALLNODE:
d622 1
a622 1
    case XFS_MSG_INSTALLATTR:
d627 1
a627 1
    case XFS_MSG_INSTALLDATA:
d632 1
a632 1
    case XFS_MSG_INVALIDNODE:
d637 1
a637 1
    case XFS_MSG_UPDATEFID:
d642 1
a642 1
    case XFS_MSG_GC_NODES:
d647 1
a647 1
    case XFS_MSG_VERSION:
d653 1
a653 1
	printf("XFS PANIC Warning xfs_dev: Unknown message opcode == %d\n",
d663 1
a663 1
		   struct proc *p)
d669 1
a669 1
    XFSDEB(XDEBMSG, ("xfs_message_wakeup error: %d\n", message->error));
d674 1
a674 1
		printf("XFS PANIC Error: Could not wakeup requestor with opcode = %d properly, to small receive buffer.\n", t->message->opcode);
d690 1
a690 1
			struct proc *p)
d696 1
a696 1
    XFSDEB(XDEBMSG, ("xfs_message_wakeup_data error: %d\n", message->error));
d701 1
a701 1
		printf("XFS PANIC Error: Could not wakeup requestor with opcode = %d properly, to small receive buffer.\n", t->message->opcode);
d720 1
a720 1
    for (i = 0; i < NXFS; i++) {
@


1.4
log
@merge
@
text
@d42 1
a42 1
RCSID("$Id: xfs_dev-common.c,v 1.1.1.1 2002/06/07 03:32:59 hin Exp $");
d109 1
a109 1
    /* initalize the queues if they have not been initialized before */
@


1.3
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
d42 1
a42 1
RCSID("$Id: xfs_dev-common.c,v 1.39 2000/07/17 16:23:47 art Exp $");
d90 1
a90 1
xfs_devopen_common(dev_t dev)
d103 1
a103 1
    } else
d105 1
d232 2
d299 1
d369 20
d394 2
a395 1
xfs_message_rpc(int fd, struct xfs_message_header * message, u_int size)
d402 1
a402 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK)
d404 1
a404 1
#endif /* HAVE_STRUCT_PROC_P_SIGMASK */
a405 1
    struct proc *proc = xfs_curproc ();
d409 3
d415 9
d454 1
d456 5
a460 13
#if defined(__sigaddset)
    __sigaddset(&proc->p_sigmask, SIGIO);
    __sigaddset(&proc->p_sigmask, SIGALRM);
    __sigaddset(&proc->p_sigmask, SIGVTALRM);
#elif defined(SIGADDSET)
    SIGADDSET(proc->p_sigmask, SIGIO);
    SIGADDSET(proc->p_sigmask, SIGALRM);
    SIGADDSET(proc->p_sigmask, SIGVTALRM);
#else
    proc->p_sigmask |= sigmask(SIGIO);
    proc->p_sigmask |= sigmask(SIGALRM);
    proc->p_sigmask |= sigmask(SIGVTALRM);
#endif /* __sigaddset */
d462 1
d467 5
d502 2
d506 2
@


1.3.8.1
log
@Sync UBC branch to -current
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d47 1
a47 1
RCSID("$Id: xfs_dev-common.c,v 1.3 2000/09/11 14:26:51 art Exp $");
d95 1
a95 1
xfs_devopen_common(dev_t dev, struct proc *p)
d108 1
a108 1
    } else {
a109 1
    }
a235 2
    chan->proc = xfs_uio_to_proc(uiop);

a300 1
    chan->proc = xfs_uio_to_proc(uiop);
a369 20
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX)
static void
xfs_block_sigset (sigset_t *sigset)
{
#if defined(__sigaddset)
    __sigaddset(sigset, SIGIO);
    __sigaddset(sigset, SIGALRM);
    __sigaddset(sigset, SIGVTALRM);
#elif defined(SIGADDSET)
    SIGADDSET(*sigset, SIGIO);
    SIGADDSET(*sigset, SIGALRM);
    SIGADDSET(*sigset, SIGVTALRM);
#else
    *sigset |= sigmask(SIGIO);
    *sigset |= sigmask(SIGALRM);
    *sigset |= sigmask(SIGVTALRM);
#endif /* __sigaddset */
}
#endif

d375 1
a375 2
xfs_message_rpc(int fd, struct xfs_message_header * message, u_int size,
		struct proc *proc)
d382 1
a382 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(__osf__)
d384 1
a384 1
#endif
d386 1
a389 3
    if (proc == NULL)
	proc = xfs_curproc();

a392 9
    if (chan->proc != NULL && proc->p_pid == chan->proc->p_pid) {
	printf("xfs_message_rpc: deadlock avoided "
	       "pid = %u == %u\n", proc->p_pid, chan->proc->p_pid);
#if 0
	psignal (proc, SIGABRT);
#endif
	return EDEADLK;
    }

a422 1
    /* NetBSD 1.5, Darwin 1.3, FreeBSD 4.3, 5.0, OpenBSD 2.8 */
d424 13
a436 5
    xfs_block_sigset (&proc->p_sigmask);
#elif defined(HAVE_STRUCT_PROC_P_SIGCTX)
    /* NetBSD 1.6 */
    oldsigmask = proc->p_sigctx.ps_sigmask;
    xfs_block_sigset (&proc->p_sigctx.ps_sigmask);
a437 1
    /* OSF 4.0 */
a441 5
#elif defined(__osf__)
    oldsigmask = u.u_sigmask;
    sigaddset(&u.u_sigmask, SIGIO);
    sigaddset(&u.u_sigmask, SIGALRM);
    sigaddset(&u.u_sigmask, SIGVTALRM);
a471 2
#elif defined(HAVE_STRUCT_PROC_P_SIGCTX)
    proc->p_sigctx.ps_sigmask = oldsigmask;
a473 2
#elif defined(__osf__)
    u.u_sigmask = oldsigmask;
@


1.3.8.2
log
@sync to -current
@
text
@d42 1
a42 1
RCSID("$Id: xfs_dev-common.c,v 1.3.8.1 2002/06/11 03:33:13 art Exp $");
d109 1
a109 1
    /* initialize the queues if they have not been initialized before */
@


1.2
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d47 1
a47 1
RCSID("$OpenBSD: xfs_dev-common.c,v 1.1 1999/04/30 01:59:00 art Exp $");
d60 1
a60 1
xfs_emptyq(struct xfs_link *q)
d67 1
a67 1
xfs_onq(struct xfs_link *link)
d82 1
d88 1
a88 1
    p->next = p->prev = 0;
d196 18
d217 1
d224 3
d228 2
a229 1
    XFSDEB(XDEBDEV, ("xfs_devread dev = %d\n", dev));
d231 4
a234 2
    XFSDEB(XDEBDEV, ("xfs_devread: m = %p, m->prev = %p, m->next = %p\n",
		&chan->messageq, chan->messageq.prev, chan->messageq.next));
d242 5
a246 3
	    XFSDEB(XDEBDEV, ("xfs_devread: first = %p, "
			     "first->prev = %p, first->next = %p\n",
			     first, first->prev, first->next));
d251 3
d266 4
a269 2
	if (tsleep((caddr_t) chan, (PZERO + 1) | PCATCH, "xfsr", 0)) {
	    XFSDEB(XDEBMSG, ("caught signal xfs_devread\n"));
a276 1
    
d294 3
d298 2
a299 1
    XFSDEB(XDEBDEV, ("xfs_devwrite dev = %d\n", dev));
d362 8
d373 1
d385 2
d423 9
a431 3
    oldsigmask = xfs_curproc()->p_sigmask;
#ifdef __sigaddset
    __sigaddset(&xfs_curproc()->p_sigmask, SIGIO);
d433 3
a435 1
    xfs_curproc()->p_sigmask |= sigmask(SIGIO);
d438 4
a441 2
    oldsigmask = xfs_curproc()->p_sigwaitmask;
    sigaddset(&xfs_curproc()->p_sigwaitmask, SIGIO);
d443 12
d458 9
a466 5
     * happen sometimes when rebooting.
     */
    if (!(chan->status & CHANNEL_OPENED) ||
	tsleep((caddr_t) this_process, (PZERO + 1) | PCATCH, "xfs", 0)) {
	XFSDEB(XDEBMSG, ("caught signal\n"));
d471 1
a471 1
    xfs_curproc()->p_sigmask = oldsigmask;
d473 1
a473 1
    xfs_curproc()->p_sigwaitmask = oldsigmask;
d556 10
d636 4
a639 4
	uprintf("messageq.next = %p ", xfs_channel[i].messageq.next);
	uprintf("messageq.prev = %p ", xfs_channel[i].messageq.prev);
	uprintf("sleepq.next = %p ", xfs_channel[i].sleepq.next);
	uprintf("sleepq.prev = %p ", xfs_channel[i].sleepq.prev);
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 2
d49 1
a49 1
RCSID("$Id: xfs_dev-common.c,v 1.22 1999/04/06 13:58:12 lha Exp $");
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d47 1
a47 1
RCSID("$Id: xfs_dev-common.c,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $");
d60 1
a60 1
xfs_emptyq(const struct xfs_link *q)
d67 1
a67 1
xfs_onq(const struct xfs_link *link)
a81 1
/* remove `p' from its queue */
d87 1
a87 1
    p->next = p->prev = NULL;
d94 1
a94 1
xfs_devopen_common(dev_t dev, struct proc *p)
d107 1
a107 1
    } else {
a108 1
    }
a194 18
#ifdef XFS_DEBUG
/*
 * osf glue for CURSIG
 */

static long
xfs_cursig (struct proc *p)
{
#ifdef __osf__
    thread_t th 	= current_thread();
    struct np_uthread	*npu = thread_to_np_uthread(th);
    return CURSIG(p,npu);
#else
    return CURSIG(p);
#endif
}
#endif

a197 1

a203 6
#ifdef XFS_DEBUG
    char devname[64];
#endif

    XFSDEB(XDEBDEV, ("xfs_devread dev = %s\n",
		     xfs_devtoname_r(dev, devname, sizeof(devname))));
d205 1
a205 4
    XFSDEB(XDEBDEV, ("xfs_devread: m = %lx, m->prev = %lx, m->next = %lx\n",
		     (unsigned long)&chan->messageq,
		     (unsigned long)chan->messageq.prev,
		     (unsigned long)chan->messageq.next));
d207 2
a208 1
    chan->proc = xfs_uio_to_proc(uiop);
d216 3
a218 5
	    XFSDEB(XDEBDEV, ("xfs_devread: first = %lx, "
			     "first->prev = %lx, first->next = %lx\n",
			     (unsigned long)first,
			     (unsigned long)first->prev,
			     (unsigned long)first->next));
a222 3
	    if (first->message->size > uiop->uio_resid)
		break;

d235 2
a236 4
	if (tsleep((caddr_t) chan, (PZERO + 1) | PCATCH, "xfsread", 0)) {
	    XFSDEB(XDEBMSG,
		   ("caught signal xfs_devread: %ld\n",
		    xfs_cursig(xfs_uio_to_proc(uiop))));
d244 1
a261 3
#ifdef XFS_DEBUG
    char devname[64];
#endif
d263 1
a263 2
    XFSDEB(XDEBDEV, ("xfs_devwrite dev = %s\n",
		     xfs_devtoname_r (dev, devname, sizeof(devname))));
a264 1
    chan->proc = xfs_uio_to_proc(uiop);
a325 28
#if defined(SWEXIT)
#define XFS_P_EXIT SWEXIT
#elif defined(P_WEXIT)
#define XFS_P_EXIT P_WEXIT
#else
#error what is your exit named ?
#endif

#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX)
static void
xfs_block_sigset (sigset_t *sigset)
{
#if defined(__sigaddset)
    __sigaddset(sigset, SIGIO);
    __sigaddset(sigset, SIGALRM);
    __sigaddset(sigset, SIGVTALRM);
#elif defined(SIGADDSET)
    SIGADDSET(*sigset, SIGIO);
    SIGADDSET(*sigset, SIGALRM);
    SIGADDSET(*sigset, SIGVTALRM);
#else
    *sigset |= sigmask(SIGIO);
    *sigset |= sigmask(SIGALRM);
    *sigset |= sigmask(SIGVTALRM);
#endif /* __sigaddset */
}
#endif

a328 1

d330 1
a330 2
xfs_message_rpc(int fd, struct xfs_message_header * message, u_int size,
		struct proc *proc)
d337 1
a337 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(__osf__)
d339 1
a339 2
#endif
    int catch;
a342 3
    if (proc == NULL)
	proc = xfs_curproc();

a345 9
    if (chan->proc != NULL && proc->p_pid == chan->proc->p_pid) {
	printf("xfs_message_rpc: deadlock avoided "
	       "pid = %u == %u\n", proc->p_pid, chan->proc->p_pid);
#if 0
	psignal (proc, SIGABRT);
#endif
	return EDEADLK;
    }

d376 6
a381 7
    /* NetBSD 1.5, Darwin 1.3, FreeBSD 4.3, 5.0, OpenBSD 2.8 */
    oldsigmask = proc->p_sigmask;
    xfs_block_sigset (&proc->p_sigmask);
#elif defined(HAVE_STRUCT_PROC_P_SIGCTX)
    /* NetBSD 1.6 */
    oldsigmask = proc->p_sigctx.ps_sigmask;
    xfs_block_sigset (&proc->p_sigctx.ps_sigmask);
d383 2
a384 10
    /* OSF 4.0 */
    oldsigmask = proc->p_sigwaitmask;
    sigaddset(&proc->p_sigwaitmask, SIGIO);
    sigaddset(&proc->p_sigwaitmask, SIGALRM);
    sigaddset(&proc->p_sigwaitmask, SIGVTALRM);
#elif defined(__osf__)
    oldsigmask = u.u_sigmask;
    sigaddset(&u.u_sigmask, SIGIO);
    sigaddset(&u.u_sigmask, SIGALRM);
    sigaddset(&u.u_sigmask, SIGVTALRM);
a385 12

    /*
     * if we are exiting we should not try to catch signals, since
     * there might not be enough context left in the process to handle
     * signal delivery, and besides, most BSD-variants ignore all
     * signals while closing anyway.
     */

    catch = 0;
    if (!(proc->p_flag & XFS_P_EXIT))
	catch |= PCATCH;

d389 5
a393 9
     * happen sometimes when rebooting.  */

    if (!(chan->status & CHANNEL_OPENED)) {
	XFSDEB(XDEBMSG, ("xfs_message_rpc: channel went away\n"));
	this_process->error_or_size = EINTR;
    } else if ((ret = tsleep((caddr_t) this_process,
			     (PZERO + 1) | catch, "xfs", 0)) != 0) {
	XFSDEB(XDEBMSG, ("caught signal (%d): %ld\n",
			 ret, xfs_cursig(proc)));
d398 1
a398 3
    proc->p_sigmask = oldsigmask;
#elif defined(HAVE_STRUCT_PROC_P_SIGCTX)
    proc->p_sigctx.ps_sigmask = oldsigmask;
d400 1
a400 3
    proc->p_sigwaitmask = oldsigmask;
#elif defined(__osf__)
    u.u_sigmask = oldsigmask;
a482 10
    case XFS_MSG_GC_NODES:
	return xfs_message_gc_nodes(fd,
				    (struct xfs_message_gc_nodes *)message,
				    message->size,
				    p);
    case XFS_MSG_VERSION:
	return xfs_message_version(fd,
				   (struct xfs_message_version *)message,
				   message->size,
				   p);
d553 4
a556 4
	uprintf("messageq.next = %lx ", xfs_channel[i].messageq.next);
	uprintf("messageq.prev = %lx ", xfs_channel[i].messageq.prev);
	uprintf("sleepq.next = %lx ", xfs_channel[i].sleepq.next);
	uprintf("sleepq.prev = %lx ", xfs_channel[i].sleepq.prev);
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$arla: xfs_dev-common.c,v 1.61 2003/07/15 16:25:42 lha Exp $");
d44 1
a44 1
struct xfs_channel xfs_channel[NNNPFS];
d90 1
a90 1
xfs_devopen_common(dev_t dev)
d94 1
a94 1
    if (minor(dev) < 0 || minor(dev) >= NNNPFS)
d101 1
a101 1
	NNPFSDEB(XDEBDEV, ("xfs_devopen: already open\n"));
d107 1
a107 1
    chan->message_buffer = xfs_alloc(MAX_XMSG_SIZE, M_NNPFS_MSG);
d134 1
a134 1
xfs_devclose_common(dev_t dev, d_thread_t *proc)
d147 1
a147 1
	NNPFSDEB(XDEBDEV, ("before outq(messageq)\n"));
d152 1
a152 1
	    xfs_free(first, first->error_or_size, M_NNPFS_LINK);
d154 1
a154 1
	NNPFSDEB(XDEBDEV, ("after outq(messageq)\n"));
d159 1
a159 1
	NNPFSDEB(XDEBDEV, ("before outq(sleepq)\n"));
d164 1
a164 1
	NNPFSDEB(XDEBDEV, ("after outq(sleepq)\n"));
d171 1
a171 1
	xfs_free(chan->message_buffer, MAX_XMSG_SIZE, M_NNPFS_MSG);
d181 1
a181 1
	    NNPFSDEB(XDEBNODE, ("xfs_dev_close: vfs_busy() --> BUSY\n"));
d192 1
a192 1
#ifdef NNPFS_DEBUG
d194 1
a194 1
 * debugging glue for CURSIG
d198 1
a198 1
xfs_cursig (d_thread_t *p)
d200 1
a200 1
#if defined(__osf__)
a203 10
#elif defined(HAVE_FREEBSD_THREAD)
#ifndef CURSIG
    return 0; /* XXX we would like to use sig_ffs, but that isn't
	       * exported */
#else
    return CURSIG(p->td_proc);
#endif
#else
#if defined(__NetBSD__) && __NetBSD_Version__ >= 106130000
    return 0; /* XXX CURSIG operates on a struct lwp */
a206 1
#endif
d220 1
a220 1
#ifdef NNPFS_DEBUG
d224 1
a224 1
    NNPFSDEB(XDEBDEV, ("xfs_devread dev = %s\n",
d227 1
a227 1
    NNPFSDEB(XDEBDEV, ("xfs_devread: m = %lx, m->prev = %lx, m->next = %lx\n",
a231 3
#ifdef HAVE_FREEBSD_THREAD
    chan->proc = xfs_uio_to_thread(uiop);
#else
a232 1
#endif
d240 1
a240 1
	    NNPFSDEB(XDEBDEV, ("xfs_devread: first = %lx, "
d246 1
a246 1
	    NNPFSDEB(XDEBDEV, ("xfs_devread: message->size = %u\n",
d260 1
a260 1
		xfs_free(first, first->error_or_size, M_NNPFS_LINK);
d265 1
a265 6
#ifdef HAVE_FREEBSD_THREAD
	    NNPFSDEB(XDEBMSG,
		   ("caught signal xfs_devread: %ld\n",
		    xfs_cursig(xfs_uio_to_thread(uiop))));
#else
	    NNPFSDEB(XDEBMSG,
a267 1
#endif
d275 1
a275 1
    NNPFSDEB(XDEBDEV, ("xfs_devread done error = %d\n", error));
d292 1
a292 1
#ifdef NNPFS_DEBUG
d296 1
a296 1
    NNPFSDEB(XDEBDEV, ("xfs_devwrite dev = %s\n",
a298 3
#ifdef HAVE_FREEBSD_THREAD
    chan->proc = xfs_uio_to_thread(uiop);
#else
a299 1
#endif
d313 1
a313 5
#ifdef HAVE_FREEBSD_THREAD
	d_thread_t *pp = xfs_uio_to_thread(uiop);
#else
	d_thread_t *pp = xfs_uio_to_proc(uiop);
#endif
d321 1
a321 1
    NNPFSDEB(XDEBDEV, ("xfs_devwrite error = %d\n", error));
d337 1
a337 1
    NNPFSDEB(XDEBMSG, ("xfs_message_send opcode = %d\n", message->opcode));
d346 1
a346 1
    t = xfs_alloc(sizeof(t->this_message) + size, M_NNPFS);
d362 1
a362 1
#define NNPFS_P_EXIT SWEXIT
d364 1
a364 1
#define NNPFS_P_EXIT P_WEXIT
d369 1
a369 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(HAVE_STRUCT_PROC_P_SIGWAITMASK) || defined(__osf__) || defined(HAVE_FREEBSD_THREAD)
a372 1

d374 3
a376 1
#define xfs_sig_block(ss,signo) __sigaddset((ss), (signo))
d378 8
a385 13
#define xfs_sig_block(ss,signo) SIGADDSET(*(ss), (signo))
#else
#define xfs_sig_block(ss,signo) *(ss) |= sigmask(signo)
#endif

    xfs_sig_block(sigset, SIGIO);
    xfs_sig_block(sigset, SIGALRM);
    xfs_sig_block(sigset, SIGVTALRM);
    xfs_sig_block(sigset, SIGCHLD);
#ifdef SIGINFO
    xfs_sig_block(sigset, SIGINFO);
#endif
#undef xfs_sig_block
d395 1
a395 1
		d_thread_t *proc)
d402 1
a402 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(__osf__) || defined(HAVE_FREEBSD_THREAD)
d407 1
a407 1
    NNPFSDEB(XDEBMSG, ("xfs_message_rpc opcode = %d\n", message->opcode));
d409 1
a409 4
    if (proc == NULL) {
#ifdef HAVE_FREEBSD_THREAD
	proc = xfs_curthread();
#else
d411 1
a411 2
#endif
    }
a414 6
#ifdef HAVE_FREEBSD_THREAD
    if (chan->proc != NULL && chan->proc->td_proc != NULL &&
      proc->td_proc->p_pid == chan->proc->td_proc->p_pid) {
	printf("xfs_message_rpc: deadlock avoided "
	       "pid = %u == %u\n", proc->td_proc->p_pid, chan->proc->td_proc->p_pid);
#else
a417 1
#endif
d425 1
a425 1
	printf("NNPFS PANIC Error: Message to small to receive wakeup, opcode = %d\n", message->opcode);
d428 3
a430 3
    this_message = xfs_alloc(sizeof(struct xfs_link), M_NNPFS_LINK);
    this_process = xfs_alloc(sizeof(struct xfs_link), M_NNPFS_LINK);
    msg = xfs_alloc(size, M_NNPFS_MSG);
d449 2
a450 3
     * Remove signals from the sigmask so no IO will wake us up from
     * tsleep(). We don't want to wake up from since program (emacs,
     * bash & co can't handle them.
d453 1
a453 5
#ifdef HAVE_FREEBSD_THREAD
    /* FreeBSD 5.1 */
    oldsigmask = proc->td_sigmask;
    xfs_block_sigset (&proc->td_sigmask);
#elif HAVE_STRUCT_PROC_P_SIGMASK
d464 3
a466 1
    xfs_block_sigset (&proc->p_sigwaitmask);
a467 1
    /* OSF 5.0 */
d469 3
a471 1
    xfs_block_sigset (&u.u_sigmask);
d482 1
a482 5
#ifdef HAVE_FREEBSD_THREAD
    if (!(proc->td_proc->p_flag & NNPFS_P_EXIT))
#else
    if (!(proc->p_flag & NNPFS_P_EXIT))
#endif
d491 1
a491 1
	NNPFSDEB(XDEBMSG, ("xfs_message_rpc: channel went away\n"));
d495 1
a495 1
	NNPFSDEB(XDEBMSG, ("caught signal (%d): %ld\n",
d500 1
a500 3
#ifdef HAVE_FREEBSD_THREAD
    proc->td_sigmask = oldsigmask;
#elif HAVE_STRUCT_PROC_P_SIGMASK
d522 1
a522 1
    NNPFSDEB(XDEBMSG, ("xfs_message_rpc this_process->error_or_size = %d\n",
d524 1
a524 1
    NNPFSDEB(XDEBMSG, ("xfs_message_rpc opcode ((xfs_message_wakeup*)(this_process->message))->error = %d\n", ((struct xfs_message_wakeup *) (this_process->message))->error));
d528 3
a530 3
    xfs_free(this_message, sizeof(*this_message), M_NNPFS_LINK);
    xfs_free(this_process, sizeof(*this_process), M_NNPFS_LINK);
    xfs_free(msg, size, M_NNPFS_MSG);
d544 1
a544 1
		    d_thread_t *p)
d546 1
a546 1
    NNPFSDEB(XDEBMSG, ("xfs_message_receive opcode = %d\n", message->opcode));
d550 1
a550 1
    case NNPFS_MSG_WAKEUP:
d555 1
a555 1
    case NNPFS_MSG_WAKEUP_DATA:
d560 1
a560 1
    case NNPFS_MSG_INSTALLROOT:
d565 1
a565 1
    case NNPFS_MSG_INSTALLNODE:
d570 1
a570 1
    case NNPFS_MSG_INSTALLATTR:
d575 1
a575 1
    case NNPFS_MSG_INSTALLDATA:
d580 1
a580 1
    case NNPFS_MSG_INVALIDNODE:
d585 1
a585 1
    case NNPFS_MSG_UPDATEFID:
d590 1
a590 1
    case NNPFS_MSG_GC_NODES:
d595 1
a595 1
    case NNPFS_MSG_VERSION:
d601 1
a601 1
	printf("NNPFS PANIC Warning xfs_dev: Unknown message opcode == %d\n",
d611 1
a611 1
		   d_thread_t *p)
d617 1
a617 1
    NNPFSDEB(XDEBMSG, ("xfs_message_wakeup error: %d\n", message->error));
d622 1
a622 1
		printf("NNPFS PANIC Error: Could not wakeup requestor with opcode = %d properly, to small receive buffer.\n", t->message->opcode);
d638 1
a638 1
			d_thread_t *p)
d644 1
a644 1
    NNPFSDEB(XDEBMSG, ("xfs_message_wakeup_data error: %d\n", message->error));
d649 1
a649 1
		printf("NNPFS PANIC Error: Could not wakeup requestor with opcode = %d properly, to small receive buffer.\n", t->message->opcode);
d668 1
a668 1
    for (i = 0; i < NNNPFS; i++) {
@


1.1.4.1
log
@Sync with -current
@
text
@a0 2
/*	$OpenBSD$	*/

d47 1
a47 1
RCSID("$OpenBSD$");
@


1.1.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d49 1
a49 1
RCSID("$Id: xfs_dev-common.c,v 1.3 2000/09/11 14:26:51 art Exp $");
d62 1
a62 1
xfs_emptyq(const struct xfs_link *q)
d69 1
a69 1
xfs_onq(const struct xfs_link *link)
a83 1
/* remove `p' from its queue */
d89 1
a89 1
    p->next = p->prev = NULL;
a196 18
#ifdef XFS_DEBUG
/*
 * osf glue for CURSIG
 */

static long
xfs_cursig (struct proc *p)
{
#ifdef __osf__
    thread_t th 	= current_thread();
    struct np_uthread	*npu = thread_to_np_uthread(th);
    return CURSIG(p,npu);
#else
    return CURSIG(p);
#endif
}
#endif

a199 1

a205 3
#ifdef XFS_DEBUG
    char devname[64];
#endif
d207 1
a207 2
    XFSDEB(XDEBDEV, ("xfs_devread dev = %s\n",
		     xfs_devtoname_r(dev, devname, sizeof(devname))));
d209 2
a210 4
    XFSDEB(XDEBDEV, ("xfs_devread: m = %lx, m->prev = %lx, m->next = %lx\n",
		     (unsigned long)&chan->messageq,
		     (unsigned long)chan->messageq.prev,
		     (unsigned long)chan->messageq.next));
d218 3
a220 5
	    XFSDEB(XDEBDEV, ("xfs_devread: first = %lx, "
			     "first->prev = %lx, first->next = %lx\n",
			     (unsigned long)first,
			     (unsigned long)first->prev,
			     (unsigned long)first->next));
a224 3
	    if (first->message->size > uiop->uio_resid)
		break;

d237 2
a238 4
	if (tsleep((caddr_t) chan, (PZERO + 1) | PCATCH, "xfsread", 0)) {
	    XFSDEB(XDEBMSG,
		   ("caught signal xfs_devread: %ld\n",
		    xfs_cursig(xfs_uio_to_proc(uiop))));
d246 1
a263 3
#ifdef XFS_DEBUG
    char devname[64];
#endif
d265 1
a265 2
    XFSDEB(XDEBDEV, ("xfs_devwrite dev = %s\n",
		     xfs_devtoname_r (dev, devname, sizeof(devname))));
a327 8
#if defined(SWEXIT)
#define XFS_P_EXIT SWEXIT
#elif defined(P_WEXIT)
#define XFS_P_EXIT P_WEXIT
#else
#error what is your exit named ?
#endif

a330 1

a341 2
    int catch;
    struct proc *proc = xfs_curproc ();
d378 3
a380 9
    oldsigmask = proc->p_sigmask;
#if defined(__sigaddset)
    __sigaddset(&proc->p_sigmask, SIGIO);
    __sigaddset(&proc->p_sigmask, SIGALRM);
    __sigaddset(&proc->p_sigmask, SIGVTALRM);
#elif defined(SIGADDSET)
    SIGADDSET(proc->p_sigmask, SIGIO);
    SIGADDSET(proc->p_sigmask, SIGALRM);
    SIGADDSET(proc->p_sigmask, SIGVTALRM);
d382 1
a382 3
    proc->p_sigmask |= sigmask(SIGIO);
    proc->p_sigmask |= sigmask(SIGALRM);
    proc->p_sigmask |= sigmask(SIGVTALRM);
d385 2
a386 4
    oldsigmask = proc->p_sigwaitmask;
    sigaddset(&proc->p_sigwaitmask, SIGIO);
    sigaddset(&proc->p_sigwaitmask, SIGALRM);
    sigaddset(&proc->p_sigwaitmask, SIGVTALRM);
a387 12

    /*
     * if we are exiting we should not try to catch signals, since
     * there might not be enough context left in the process to handle
     * signal delivery, and besides, most BSD-variants ignore all
     * signals while closing anyway.
     */

    catch = 0;
    if (!(proc->p_flag & XFS_P_EXIT))
	catch |= PCATCH;

d391 5
a395 9
     * happen sometimes when rebooting.  */

    if (!(chan->status & CHANNEL_OPENED)) {
	XFSDEB(XDEBMSG, ("xfs_message_rpc: channel went away\n"));
	this_process->error_or_size = EINTR;
    } else if ((ret = tsleep((caddr_t) this_process,
			     (PZERO + 1) | catch, "xfs", 0)) != 0) {
	XFSDEB(XDEBMSG, ("caught signal (%d): %ld\n",
			 ret, xfs_cursig(proc)));
d400 1
a400 1
    proc->p_sigmask = oldsigmask;
d402 1
a402 1
    proc->p_sigwaitmask = oldsigmask;
a484 10
    case XFS_MSG_GC_NODES:
	return xfs_message_gc_nodes(fd,
				    (struct xfs_message_gc_nodes *)message,
				    message->size,
				    p);
    case XFS_MSG_VERSION:
	return xfs_message_version(fd,
				   (struct xfs_message_version *)message,
				   message->size,
				   p);
d555 4
a558 4
	uprintf("messageq.next = %lx ", xfs_channel[i].messageq.next);
	uprintf("messageq.prev = %lx ", xfs_channel[i].messageq.prev);
	uprintf("sleepq.next = %lx ", xfs_channel[i].sleepq.next);
	uprintf("sleepq.prev = %lx ", xfs_channel[i].sleepq.prev);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d47 1
a47 1
RCSID("$Id$");
d95 1
a95 1
xfs_devopen_common(dev_t dev, struct proc *p)
d108 1
a108 1
    } else {
a109 1
    }
d113 1
a113 1
    /* initialize the queues if they have not been initialized before */
a235 2
    chan->proc = xfs_uio_to_proc(uiop);

a300 1
    chan->proc = xfs_uio_to_proc(uiop);
a369 20
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX)
static void
xfs_block_sigset (sigset_t *sigset)
{
#if defined(__sigaddset)
    __sigaddset(sigset, SIGIO);
    __sigaddset(sigset, SIGALRM);
    __sigaddset(sigset, SIGVTALRM);
#elif defined(SIGADDSET)
    SIGADDSET(*sigset, SIGIO);
    SIGADDSET(*sigset, SIGALRM);
    SIGADDSET(*sigset, SIGVTALRM);
#else
    *sigset |= sigmask(SIGIO);
    *sigset |= sigmask(SIGALRM);
    *sigset |= sigmask(SIGVTALRM);
#endif /* __sigaddset */
}
#endif

d375 1
a375 2
xfs_message_rpc(int fd, struct xfs_message_header * message, u_int size,
		struct proc *proc)
d382 1
a382 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(__osf__)
d384 1
a384 1
#endif
d386 1
a389 3
    if (proc == NULL)
	proc = xfs_curproc();

a392 9
    if (chan->proc != NULL && proc->p_pid == chan->proc->p_pid) {
	printf("xfs_message_rpc: deadlock avoided "
	       "pid = %u == %u\n", proc->p_pid, chan->proc->p_pid);
#if 0
	psignal (proc, SIGABRT);
#endif
	return EDEADLK;
    }

a422 1
    /* NetBSD 1.5, Darwin 1.3, FreeBSD 4.3, 5.0, OpenBSD 2.8 */
d424 13
a436 5
    xfs_block_sigset (&proc->p_sigmask);
#elif defined(HAVE_STRUCT_PROC_P_SIGCTX)
    /* NetBSD 1.6 */
    oldsigmask = proc->p_sigctx.ps_sigmask;
    xfs_block_sigset (&proc->p_sigctx.ps_sigmask);
a437 1
    /* OSF 4.0 */
a441 5
#elif defined(__osf__)
    oldsigmask = u.u_sigmask;
    sigaddset(&u.u_sigmask, SIGIO);
    sigaddset(&u.u_sigmask, SIGALRM);
    sigaddset(&u.u_sigmask, SIGVTALRM);
a471 2
#elif defined(HAVE_STRUCT_PROC_P_SIGCTX)
    proc->p_sigctx.ps_sigmask = oldsigmask;
a473 2
#elif defined(__osf__)
    u.u_sigmask = oldsigmask;
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$arla: xfs_dev-common.c,v 1.61 2003/07/15 16:25:42 lha Exp $");
d44 1
a44 1
struct xfs_channel xfs_channel[NNNPFS];
d90 1
a90 1
xfs_devopen_common(dev_t dev)
d94 1
a94 1
    if (minor(dev) < 0 || minor(dev) >= NNNPFS)
d101 1
a101 1
	NNPFSDEB(XDEBDEV, ("xfs_devopen: already open\n"));
d107 1
a107 1
    chan->message_buffer = xfs_alloc(MAX_XMSG_SIZE, M_NNPFS_MSG);
d134 1
a134 1
xfs_devclose_common(dev_t dev, d_thread_t *proc)
d147 1
a147 1
	NNPFSDEB(XDEBDEV, ("before outq(messageq)\n"));
d152 1
a152 1
	    xfs_free(first, first->error_or_size, M_NNPFS_LINK);
d154 1
a154 1
	NNPFSDEB(XDEBDEV, ("after outq(messageq)\n"));
d159 1
a159 1
	NNPFSDEB(XDEBDEV, ("before outq(sleepq)\n"));
d164 1
a164 1
	NNPFSDEB(XDEBDEV, ("after outq(sleepq)\n"));
d171 1
a171 1
	xfs_free(chan->message_buffer, MAX_XMSG_SIZE, M_NNPFS_MSG);
d181 1
a181 1
	    NNPFSDEB(XDEBNODE, ("xfs_dev_close: vfs_busy() --> BUSY\n"));
d192 1
a192 1
#ifdef NNPFS_DEBUG
d194 1
a194 1
 * debugging glue for CURSIG
d198 1
a198 1
xfs_cursig (d_thread_t *p)
d200 1
a200 1
#if defined(__osf__)
a203 10
#elif defined(HAVE_FREEBSD_THREAD)
#ifndef CURSIG
    return 0; /* XXX we would like to use sig_ffs, but that isn't
	       * exported */
#else
    return CURSIG(p->td_proc);
#endif
#else
#if defined(__NetBSD__) && __NetBSD_Version__ >= 106130000
    return 0; /* XXX CURSIG operates on a struct lwp */
a206 1
#endif
d220 1
a220 1
#ifdef NNPFS_DEBUG
d224 1
a224 1
    NNPFSDEB(XDEBDEV, ("xfs_devread dev = %s\n",
d227 1
a227 1
    NNPFSDEB(XDEBDEV, ("xfs_devread: m = %lx, m->prev = %lx, m->next = %lx\n",
a231 3
#ifdef HAVE_FREEBSD_THREAD
    chan->proc = xfs_uio_to_thread(uiop);
#else
a232 1
#endif
d240 1
a240 1
	    NNPFSDEB(XDEBDEV, ("xfs_devread: first = %lx, "
d246 1
a246 1
	    NNPFSDEB(XDEBDEV, ("xfs_devread: message->size = %u\n",
d260 1
a260 1
		xfs_free(first, first->error_or_size, M_NNPFS_LINK);
d265 1
a265 6
#ifdef HAVE_FREEBSD_THREAD
	    NNPFSDEB(XDEBMSG,
		   ("caught signal xfs_devread: %ld\n",
		    xfs_cursig(xfs_uio_to_thread(uiop))));
#else
	    NNPFSDEB(XDEBMSG,
a267 1
#endif
d275 1
a275 1
    NNPFSDEB(XDEBDEV, ("xfs_devread done error = %d\n", error));
d292 1
a292 1
#ifdef NNPFS_DEBUG
d296 1
a296 1
    NNPFSDEB(XDEBDEV, ("xfs_devwrite dev = %s\n",
a298 3
#ifdef HAVE_FREEBSD_THREAD
    chan->proc = xfs_uio_to_thread(uiop);
#else
a299 1
#endif
d313 1
a313 5
#ifdef HAVE_FREEBSD_THREAD
	d_thread_t *pp = xfs_uio_to_thread(uiop);
#else
	d_thread_t *pp = xfs_uio_to_proc(uiop);
#endif
d321 1
a321 1
    NNPFSDEB(XDEBDEV, ("xfs_devwrite error = %d\n", error));
d337 1
a337 1
    NNPFSDEB(XDEBMSG, ("xfs_message_send opcode = %d\n", message->opcode));
d346 1
a346 1
    t = xfs_alloc(sizeof(t->this_message) + size, M_NNPFS);
d362 1
a362 1
#define NNPFS_P_EXIT SWEXIT
d364 1
a364 1
#define NNPFS_P_EXIT P_WEXIT
d369 1
a369 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(HAVE_STRUCT_PROC_P_SIGWAITMASK) || defined(__osf__) || defined(HAVE_FREEBSD_THREAD)
a372 1

d374 3
a376 1
#define xfs_sig_block(ss,signo) __sigaddset((ss), (signo))
d378 8
a385 13
#define xfs_sig_block(ss,signo) SIGADDSET(*(ss), (signo))
#else
#define xfs_sig_block(ss,signo) *(ss) |= sigmask(signo)
#endif

    xfs_sig_block(sigset, SIGIO);
    xfs_sig_block(sigset, SIGALRM);
    xfs_sig_block(sigset, SIGVTALRM);
    xfs_sig_block(sigset, SIGCHLD);
#ifdef SIGINFO
    xfs_sig_block(sigset, SIGINFO);
#endif
#undef xfs_sig_block
d395 1
a395 1
		d_thread_t *proc)
d402 1
a402 1
#if defined(HAVE_STRUCT_PROC_P_SIGMASK) || defined(HAVE_STRUCT_PROC_P_SIGCTX) || defined(__osf__) || defined(HAVE_FREEBSD_THREAD)
d407 1
a407 1
    NNPFSDEB(XDEBMSG, ("xfs_message_rpc opcode = %d\n", message->opcode));
d409 1
a409 4
    if (proc == NULL) {
#ifdef HAVE_FREEBSD_THREAD
	proc = xfs_curthread();
#else
d411 1
a411 2
#endif
    }
a414 6
#ifdef HAVE_FREEBSD_THREAD
    if (chan->proc != NULL && chan->proc->td_proc != NULL &&
      proc->td_proc->p_pid == chan->proc->td_proc->p_pid) {
	printf("xfs_message_rpc: deadlock avoided "
	       "pid = %u == %u\n", proc->td_proc->p_pid, chan->proc->td_proc->p_pid);
#else
a417 1
#endif
d425 1
a425 1
	printf("NNPFS PANIC Error: Message to small to receive wakeup, opcode = %d\n", message->opcode);
d428 3
a430 3
    this_message = xfs_alloc(sizeof(struct xfs_link), M_NNPFS_LINK);
    this_process = xfs_alloc(sizeof(struct xfs_link), M_NNPFS_LINK);
    msg = xfs_alloc(size, M_NNPFS_MSG);
d449 2
a450 3
     * Remove signals from the sigmask so no IO will wake us up from
     * tsleep(). We don't want to wake up from since program (emacs,
     * bash & co can't handle them.
d453 1
a453 5
#ifdef HAVE_FREEBSD_THREAD
    /* FreeBSD 5.1 */
    oldsigmask = proc->td_sigmask;
    xfs_block_sigset (&proc->td_sigmask);
#elif HAVE_STRUCT_PROC_P_SIGMASK
d464 3
a466 1
    xfs_block_sigset (&proc->p_sigwaitmask);
a467 1
    /* OSF 5.0 */
d469 3
a471 1
    xfs_block_sigset (&u.u_sigmask);
d482 1
a482 5
#ifdef HAVE_FREEBSD_THREAD
    if (!(proc->td_proc->p_flag & NNPFS_P_EXIT))
#else
    if (!(proc->p_flag & NNPFS_P_EXIT))
#endif
d491 1
a491 1
	NNPFSDEB(XDEBMSG, ("xfs_message_rpc: channel went away\n"));
d495 1
a495 1
	NNPFSDEB(XDEBMSG, ("caught signal (%d): %ld\n",
d500 1
a500 3
#ifdef HAVE_FREEBSD_THREAD
    proc->td_sigmask = oldsigmask;
#elif HAVE_STRUCT_PROC_P_SIGMASK
d522 1
a522 1
    NNPFSDEB(XDEBMSG, ("xfs_message_rpc this_process->error_or_size = %d\n",
d524 1
a524 1
    NNPFSDEB(XDEBMSG, ("xfs_message_rpc opcode ((xfs_message_wakeup*)(this_process->message))->error = %d\n", ((struct xfs_message_wakeup *) (this_process->message))->error));
d528 3
a530 3
    xfs_free(this_message, sizeof(*this_message), M_NNPFS_LINK);
    xfs_free(this_process, sizeof(*this_process), M_NNPFS_LINK);
    xfs_free(msg, size, M_NNPFS_MSG);
d544 1
a544 1
		    d_thread_t *p)
d546 1
a546 1
    NNPFSDEB(XDEBMSG, ("xfs_message_receive opcode = %d\n", message->opcode));
d550 1
a550 1
    case NNPFS_MSG_WAKEUP:
d555 1
a555 1
    case NNPFS_MSG_WAKEUP_DATA:
d560 1
a560 1
    case NNPFS_MSG_INSTALLROOT:
d565 1
a565 1
    case NNPFS_MSG_INSTALLNODE:
d570 1
a570 1
    case NNPFS_MSG_INSTALLATTR:
d575 1
a575 1
    case NNPFS_MSG_INSTALLDATA:
d580 1
a580 1
    case NNPFS_MSG_INVALIDNODE:
d585 1
a585 1
    case NNPFS_MSG_UPDATEFID:
d590 1
a590 1
    case NNPFS_MSG_GC_NODES:
d595 1
a595 1
    case NNPFS_MSG_VERSION:
d601 1
a601 1
	printf("NNPFS PANIC Warning xfs_dev: Unknown message opcode == %d\n",
d611 1
a611 1
		   d_thread_t *p)
d617 1
a617 1
    NNPFSDEB(XDEBMSG, ("xfs_message_wakeup error: %d\n", message->error));
d622 1
a622 1
		printf("NNPFS PANIC Error: Could not wakeup requestor with opcode = %d properly, to small receive buffer.\n", t->message->opcode);
d638 1
a638 1
			d_thread_t *p)
d644 1
a644 1
    NNPFSDEB(XDEBMSG, ("xfs_message_wakeup_data error: %d\n", message->error));
d649 1
a649 1
		printf("NNPFS PANIC Error: Could not wakeup requestor with opcode = %d properly, to small receive buffer.\n", t->message->opcode);
d668 1
a668 1
    for (i = 0; i < NNNPFS; i++) {
@


