head	1.7;
access;
symbols
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	UBC_SYNC_A:1.7
	UBC_SYNC_B:1.7
	SMP:1.7.0.2
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6;
locks; strict;
comment	@ * @;


1.7
date	99.04.30.02.13.24;	author art;	state dead;
branches;
next	1.6;

1.6
date	98.09.18.02.41.44;	author art;	state Exp;
branches;
next	1.5;

1.5
date	98.09.17.20.50.25;	author art;	state Exp;
branches;
next	1.4;

1.4
date	98.09.06.01.48.58;	author art;	state Exp;
branches;
next	1.3;

1.3
date	98.08.31.05.13.17;	author art;	state Exp;
branches;
next	1.2;

1.2
date	98.08.30.18.06.19;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.08.30.16.47.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.7
log
@gc old files
@
text
@/*	$OpenBSD: xfs_syscalls.c,v 1.6 1998/09/18 02:41:44 art Exp $	*/
/*
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/uio.h>
#include <sys/namei.h>
#include <sys/ucred.h>
#include <sys/mount.h>
#include <sys/signal.h>
#include <sys/syscall.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/syscallargs.h>

#ifndef XFS
int
sys_xfspioctl(struct proc *p, void *v, register_t *i)
{
	return ENOSYS;
}
#else

#include <xfs/xfs_common.h>

RCSID("$KTH: xfs_syscalls.c,v 1.20 1998/07/19 21:18:30 art Exp $");

/*
 * XFS system calls.
 */
#include <xfs/xfs_message.h>
#include <xfs/xfs_syscalls.h>
#include <xfs/xfs_dev.h>
#include <xfs/xfs_node.h>
#include <xfs/xfs_deb.h>

/* Misc syscalls */
#include <xfs/xfs_pioctl.h>

#ifdef ACTUALLY_LKM_NOT_KERNEL

/* XXX really defined in kern/kern_lkm.c */
extern int sys_lkmnosys(struct proc *p, void *v, register_t *retval);

#ifndef SYS_MAXSYSCALL		       /* Workaround for OpenBSD */
#define SYS_MAXSYSCALL 255
#endif

#endif /* ACTUALLY_LKM_NOT_KERNEL */


/*
 * Def pag:
 *  33536 <= g0 <= 34560
 *  32512 <= g1 <= 48896
 */

#define XFS_PAG1_LLIM 33536
#define XFS_PAG1_ULIM 34560
#define XFS_PAG2_LLIM 32512
#define XFS_PAG2_ULIM 48896

static gid_t pag_part_one = XFS_PAG1_LLIM;
static gid_t pag_part_two = XFS_PAG2_LLIM;

static int
xfs_is_pag(struct ucred *cred)
{
	/* The first group is the gid of the user ? */

	if (cred->cr_ngroups >= 3 &&
		cred->cr_groups[1] >= XFS_PAG1_LLIM &&
		cred->cr_groups[1] <= XFS_PAG1_ULIM &&
		cred->cr_groups[2] >= XFS_PAG2_LLIM &&
		cred->cr_groups[2] <= XFS_PAG2_ULIM)
		return 1;
	else
		return 0;
}


pag_t
xfs_get_pag(struct ucred *cred)
{
	if (xfs_is_pag(cred)) {
		return (((cred->cr_groups[1] << 16) & 0xFFFF0000) |
			((cred->cr_groups[2] & 0x0000FFFF)));
	} else
		return cred->cr_uid;	       /* XXX */
}

static int
xfs_setpag_call(struct ucred **ret_cred)
{
	struct ucred	*cred = *ret_cred;
	int		i;

	if (!xfs_is_pag(cred)) {
		/* Check if it fits */
		if (cred->cr_ngroups + 2 >= NGROUPS)
			return E2BIG;	       /* XXX Hmmm, better error ? */

		cred = crcopy (cred);

		/* Copy the groups */
		for (i = cred->cr_ngroups - 1; i > 0; i--) {
			cred->cr_groups[i + 2] = cred->cr_groups[i];
		}
		cred->cr_ngroups += 2;

	} else
		cred = crcopy(cred);

	cred->cr_groups[1] = pag_part_one;
	cred->cr_groups[2] = pag_part_two++;

	if (pag_part_two > XFS_PAG2_ULIM) {
		pag_part_one++;
		pag_part_two = XFS_PAG2_LLIM;
	}
	*ret_cred = cred;

	return 0;
}

#ifdef ACTUALLY_LKM_NOT_KERNEL
#if defined(__NetBSD__) || defined(__OpenBSD__)

#define syscallarg(x)   union { x datum; register_t pad; }

struct sys_xfspioctl_args {
	syscallarg(int) operation;
	syscallarg(char *) a_pathP;
	syscallarg(int) a_opcode;
	syscallarg(struct ViceIoctl *) a_paramsP;
	syscallarg(int) a_followSymlinks;
};

#elif defined(__FreeBSD__)

struct sys_xfspioctl_args {
	int operation;
	char *a_pathP;
	int a_opcode;
	struct ViceIoctl *a_paramsP;
	int a_followSymlinks;
};

#ifndef SCARG
#define SCARG(a, b) (a->b)
#endif

#endif
#endif /* ACTUALLY_LKM_NOT_KERNEL */

static int
xfs_pioctl_call(struct proc *p, void *v, register_t *i)
{
	int error;
	struct ViceIoctl vice_ioctl;
	struct xfs_message_pioctl msg;
	struct xfs_message_wakeup_data *msg2;
	char *pathptr;

	struct sys_xfspioctl_args *arg = (struct sys_xfspioctl_args *) v;

	/* Copy in the data structure for us */

	error = copyin(SCARG(arg, a_paramsP),
		       &vice_ioctl,
		       sizeof(vice_ioctl));
	if (error)
		return error;

	if (vice_ioctl.in_size > 2048) {
		printf("xfs_pioctl_call: got a humongous inpacket: opcode: %d",
		       SCARG(arg, a_opcode));
		return EINVAL;
	}
	if (vice_ioctl.in_size != 0) {
		error = copyin(vice_ioctl.in,
			       &msg.msg,
			       vice_ioctl.in_size);

		if (error)
			return error;
	}

	pathptr = SCARG(arg, a_pathP);

	if (pathptr != NULL) {
		char		path[MAXPATHLEN];
		struct xfs_node	*xn;
		struct nameidata nd;
		struct vnode	*vp;
		size_t		done;

		XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %p\n", pathptr));

		error = copyinstr(pathptr, path, sizeof(path) - 1, &done);
		path[sizeof(path) - 1] = '\0';
		XFSDEB(XDEBSYS, ("xfs_syscall: path: %s len: %d error: %d\n", 
				 path, done, error));

		if (error)
			return error;

		NDINIT(&nd, LOOKUP,
		       SCARG(arg, a_followSymlinks) ? FOLLOW : 0,
		       UIO_SYSSPACE, path, p);

		error = namei(&nd);
		if (error != 0) {
			XFSDEB(XDEBSYS, ("xfs_syscall: error in namei: %d\n",
					error));
			return EINVAL;
		}

		vp = nd.ni_vp;

		if (vp->v_tag != VT_XFS) {
			XFSDEB(XDEBSYS, ("xfs_syscall: %s not in xfs\n",
					path));
			vrele(vp);
			return EINVAL;
		}

		xn = VNODE_TO_XNODE(vp);

		msg.handle = xn->handle;
		vrele(vp);
	}

	msg.header.opcode = XFS_MSG_PIOCTL;
	msg.opcode = SCARG(arg, a_opcode);
	msg.insize = vice_ioctl.in_size;
	msg.outsize = vice_ioctl.out_size;
	msg.cred.uid = p->p_cred->p_ruid;
	msg.cred.pag = xfs_get_pag(p->p_ucred);

	error = xfs_message_rpc(0, &msg.header, sizeof(msg)); /* XXX */
	msg2 = (struct xfs_message_wakeup_data *) &msg;
	if (error == 0)
		error = msg2->error;
	else
		error = EINVAL; /* return EINVAL to not confuse applications */

	if (error == 0 && msg2->header.opcode == XFS_MSG_WAKEUP_DATA)
		error = copyout(msg2->msg, vice_ioctl.out,
				min(msg2->len, vice_ioctl.out_size));
	return error;
}


#ifdef ACTUALLY_LKM_NOT_KERNEL
static int
xfs_syscall(struct proc *p, void *v, register_t *i)
#else
int
sys_xfspioctl(struct proc *p, void *v, register_t *i)
#endif
{
	struct sys_xfspioctl_args *arg = (struct sys_xfspioctl_args *) v;
	int		error = EINVAL;

	switch (SCARG(arg, operation)) {
	case AFSCALL_PROBE:
		error = 0;
		break;
	case AFSCALL_PIOCTL:
		error = xfs_pioctl_call(p, v, i);
		break;
	case AFSCALL_SETPAG:
		error = xfs_setpag_call(&p->p_cred->pc_ucred);
		break;
	default:
		uprintf("Unimplemeted call: %d\n", SCARG(arg, operation));
		error = EINVAL;
		break;
	}

	return error;
}

#ifdef ACTUALLY_LKM_NOT_KERNEL
#if defined(__NetBSD__) || defined(__OpenBSD__)

static int syscall_offset;
static struct sysent syscall_oldent;

static struct sysent xfs_syscallent = {
	4,					/* number of args */
	sizeof(struct sys_xfspioctl_args),	/* size of args */
	xfs_syscall				/* function pointer */
};

static int
find_first_free_syscall(int *ret)
{
	int i;

	/*
	 * Search the table looking for a slot...
	 */
	for (i = 0; i < SYS_MAXSYSCALL; i++)
		if (sysent[i].sy_call == sys_lkmnosys) {
			*ret = i;
			return 0;
		}

	return ENFILE;
}

int
xfs_install_syscalls(void)
{
	int error;

#ifdef AFS_SYSCALL
	syscall_offset = AFS_SYSCALL;
#else
	error = find_first_free_syscall(&syscall_offset);
	if (error)
		return error;
#endif

	syscall_oldent = sysent[syscall_offset];

	/* replace with new */

	sysent[syscall_offset] = xfs_syscallent;

	printf("syscall %d\n", syscall_offset);
	return 0;
}

int
xfs_uninstall_syscalls(void)
{
	/* replace current slot contents with old contents */
	if (syscall_offset)
		sysent[syscall_offset] = syscall_oldent;

	return 0;
}

int
xfs_stat_syscalls(void)
{
	return 0;
}

#elif defined(__FreeBSD__)

static int syscall_offset;
static struct sysent syscall_oldent;

static struct sysent xfs_syscallent = {
	4,
	xfs_syscall
};

static int
find_first_free_syscall(int *ret)
{
	int i;

	/*
	 * Search the table looking for a slot...
	 */
	for (i = 0; i < aout_sysvec.sv_size; i++)
		if (aout_sysvec.sv_table[i].sy_call ==
		    (sy_call_t *) lkmnosys) {
			*ret = i;
			return 0;
		}

	return ENFILE;
}

int
xfs_install_syscalls(void)
{
	int i;
	int error;

#ifdef AFS_SYSCALL
	i = AFS_SYSCALL;
#else
	error = find_first_free_syscall(&i);
	if (error)
		return error;
#endif

	syscall_oldent = aout_sysvec.sv_table[i];

	aout_sysvec.sv_table[i] = xfs_syscallent;

	syscall_offset = i;
	printf("syscall %d\n", i);

	return 0;
}

int
xfs_uninstall_syscalls(void)
{
	if (syscall_offset) {
		aout_sysvec.sv_table[syscall_offset].sy_call =
			(sy_call_t *) lkmnosys;
	}
	return 0;
}

int
xfs_stat_syscalls(void)
{
    return 0;
}

#endif
#endif /* ACTUALLY_LKM_NOT_KERNEL */
#endif /* !XFS */
@


1.6
log
@the third arguemnt to a syscall is register_t not int. From Todd Fries
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_syscalls.c,v 1.5 1998/09/17 20:50:25 art Exp $	*/
@


1.5
log
@implement a dummy syscall when XFS is not defined and add PROBE
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_syscalls.c,v 1.4 1998/09/06 01:48:58 art Exp $	*/
d55 1
a55 1
sys_xfspioctl(struct proc *p, void *v, int *i)
d194 1
a194 1
xfs_pioctl_call(struct proc *p, void *v, int *i)
d294 1
a294 1
xfs_syscall(struct proc *p, void *v, int *i)
d297 1
a297 1
sys_xfspioctl(struct proc *p, void *v, int *i)
@


1.4
log
@ * reorganize some includes
 * start using the VT_XFS tag on vnodes
 * be more paranoid about closed channel when going to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_syscalls.c,v 1.3 1998/08/31 05:13:17 art Exp $	*/
d51 9
a75 1
#include <sys/syscallargs.h>
d304 3
d460 1
@


1.3
log
@indent the code and move around some includes, after discussion with Theo
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_syscalls.c,v 1.2 1998/08/30 18:06:19 art Exp $	*/
d50 1
d250 2
a251 2
		if (vp->v_tag != VT_AFS) {
			XFSDEB(XDEBSYS, ("xfs_syscall: %s not in afs\n",
@


1.2
log
@rename pioctl to xfspioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_syscalls.c,v 1.1 1998/08/30 16:47:21 art Exp $	*/
d58 1
a58 2

#include <sys/xfs_message.h>
d65 1
a65 1
#include <sys/xfs_pioctl.h>
d69 1
d76 1
d97 1
a97 1
    /* The first group is the gid of the user ? */
d99 8
a106 8
    if (cred->cr_ngroups >= 3 &&
	cred->cr_groups[1] >= XFS_PAG1_LLIM &&
	cred->cr_groups[1] <= XFS_PAG1_ULIM &&
	cred->cr_groups[2] >= XFS_PAG2_LLIM &&
	cred->cr_groups[2] <= XFS_PAG2_ULIM)
	return 1;
    else
	return 0;
d113 5
a117 7
    if (xfs_is_pag(cred)) {

	return (((cred->cr_groups[1] << 16) & 0xFFFF0000) |
		((cred->cr_groups[2] & 0x0000FFFF)));

    } else
	return cred->cr_uid;	       /* XXX */
d123 2
a124 2
    struct ucred *cred = *ret_cred;
    int i;
d126 22
a147 11
    if (!xfs_is_pag(cred)) {

	/* Check if it fits */
	if (cred->cr_ngroups + 2 >= NGROUPS)
	    return E2BIG;	       /* XXX Hmmm, better error ? */

	cred = crcopy (cred);

	/* Copy the groups */
	for (i = cred->cr_ngroups - 1; i > 0; i--) {
	    cred->cr_groups[i + 2] = cred->cr_groups[i];
d149 1
a149 1
	cred->cr_ngroups += 2;
d151 1
a151 12
    } else
	cred = crcopy(cred);

    cred->cr_groups[1] = pag_part_one;
    cred->cr_groups[2] = pag_part_two++;

    if (pag_part_two > XFS_PAG2_ULIM) {
	pag_part_one++;
	pag_part_two = XFS_PAG2_LLIM;
    }
    *ret_cred = cred;
    return 0;
d160 5
a164 5
    syscallarg(int) operation;
    syscallarg(char *) a_pathP;
    syscallarg(int) a_opcode;
    syscallarg(struct ViceIoctl *) a_paramsP;
    syscallarg(int) a_followSymlinks;
d170 5
a174 5
    int operation;
    char *a_pathP;
    int a_opcode;
    struct ViceIoctl *a_paramsP;
    int a_followSymlinks;
d182 1
a182 1
#endif
d187 13
a199 27
    int error;
    struct ViceIoctl vice_ioctl;
    struct xfs_message_pioctl msg;
    struct xfs_message_wakeup_data *msg2;
    char *pathptr;

    struct sys_xfspioctl_args *arg = (struct sys_xfspioctl_args *) v;

    /* Copy in the data structure for us */

    error = copyin(SCARG(arg, a_paramsP),
		   &vice_ioctl,
		   sizeof(vice_ioctl));

    if (error)
	return error;

    if (vice_ioctl.in_size > 2048) {
	printf("xfs_pioctl_call: got a humongous in packet: opcode: %d",
	       SCARG(arg, a_opcode));
	return EINVAL;
    }
    if (vice_ioctl.in_size != 0) {
	error = copyin(vice_ioctl.in,
		       &msg.msg,
		       vice_ioctl.in_size);

d201 1
a201 2
	    return error;
    }
d203 9
a211 1
    pathptr = SCARG(arg, a_pathP);
d213 3
a215 6
    if (pathptr != NULL) {
	char path[MAXPATHLEN];
	struct xfs_node *xn;
	struct nameidata nd;
	struct vnode *vp;
	size_t done;
d217 1
a217 1
	XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %p\n", pathptr));
d219 36
a254 1
	error = copyinstr(pathptr, path, MAXPATHLEN, &done);
d256 1
a256 2
	XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %s len: %d error: %d\n", 
			 path, done, error));
d258 2
a259 12
	if (error)
	    return error;

	NDINIT(&nd, LOOKUP,
	       SCARG(arg, a_followSymlinks) ? FOLLOW : 0,
	       UIO_SYSSPACE, path, p);

	error = namei(&nd);
	
	if (error != 0) {
	    XFSDEB(XDEBSYS, ("xfs_syscall: error during namei: %d\n", error));
	    return EINVAL;
d262 18
a279 34
	vp = nd.ni_vp;

	if (vp->v_tag != VT_AFS) {
	    XFSDEB(XDEBSYS, ("xfs_syscall: %s not in afs\n", path));
	    vrele(vp);
	    return EINVAL;
	}

	xn = VNODE_TO_XNODE(vp);

	msg.handle = xn->handle;
	vrele(vp);
    }

    msg.header.opcode = XFS_MSG_PIOCTL;
    msg.opcode = SCARG(arg, a_opcode);

    msg.insize = vice_ioctl.in_size;
    msg.outsize = vice_ioctl.out_size;
    msg.cred.uid = p->p_cred->p_ruid;
    msg.cred.pag = xfs_get_pag(p->p_ucred);

    error = xfs_message_rpc(0, &msg.header, sizeof(msg)); /* XXX */
    msg2 = (struct xfs_message_wakeup_data *) &msg;

    if (error == 0)
        error = msg2->error;
    else
        error = EINVAL; /* return EINVAL to not confuse applications */

    if (error == 0 && msg2->header.opcode == XFS_MSG_WAKEUP_DATA)
        error = copyout(msg2->msg, vice_ioctl.out,
			min(msg2->len, vice_ioctl.out_size));
    return error;
d291 2
a292 2
    struct sys_xfspioctl_args *arg = (struct sys_xfspioctl_args *) v;
    int error = EINVAL;
d294 12
a305 12
    switch (SCARG(arg, operation)) {
    case AFSCALL_PIOCTL:
	error = xfs_pioctl_call(p, v, i);
	break;
    case AFSCALL_SETPAG:
	error = xfs_setpag_call(&p->p_cred->pc_ucred);
	break;
    default:
	uprintf("Unimplemeted call: %d\n", SCARG(arg, operation));
	error = EINVAL;
	break;
    }
d307 1
a307 1
    return error;
d317 3
a319 3
    4,				       /* number of args */
    sizeof(struct sys_xfspioctl_args), /* size of args */
    xfs_syscall			       /* function pointer */
d325 10
a334 1
    int i;
d336 1
a336 9
    /*
     * Search the table looking for a slot...
     */
    for (i = 0; i < SYS_MAXSYSCALL; i++)
	if (sysent[i].sy_call == sys_lkmnosys) {
	    *ret = i;
	    return 0;
	}
    return ENFILE;
d342 1
a342 1
    int error;
d345 1
a345 1
    syscall_offset = AFS_SYSCALL;
d347 3
a349 3
    error = find_first_free_syscall(&syscall_offset);
    if (error)
	return error;
d352 1
a352 1
    syscall_oldent = sysent[syscall_offset];
d354 1
a354 1
    /* replace with new */
d356 1
a356 1
    sysent[syscall_offset] = xfs_syscallent;
d358 2
a359 2
    printf("syscall %d\n", syscall_offset);
    return 0;
d365 3
a367 3
    /* replace current slot contents with old contents */
    if (syscall_offset)
	sysent[syscall_offset] = syscall_oldent;
d369 1
a369 1
    return 0;
d375 1
a375 1
    return 0;
d384 2
a385 2
    4,
    xfs_syscall
d391 1
a391 1
    int i;
d393 11
a403 9
    /*
     * Search the table looking for a slot...
     */
    for (i = 0; i < aout_sysvec.sv_size; i++)
	if (aout_sysvec.sv_table[i].sy_call == (sy_call_t *) lkmnosys) {
	    *ret = i;
	    return 0;
	}
    return ENFILE;
d409 2
a410 2
    int i;
    int error;
d413 1
a413 1
    i = AFS_SYSCALL;
d415 3
a417 3
    error = find_first_free_syscall(&i);
    if (error)
	return error;
d420 3
a422 1
    syscall_oldent = aout_sysvec.sv_table[i];
d424 2
a425 1
    aout_sysvec.sv_table[i] = xfs_syscallent;
d427 1
a427 3
    syscall_offset = i;
    printf("syscall %d\n", i);
    return 0;
d433 5
a437 4
    if (syscall_offset) {
	aout_sysvec.sv_table[syscall_offset].sy_call = (sy_call_t *) lkmnosys;
    }
    return 0;
@


1.1
log
@xfs - a filesystem using a user-land cache manager. Designed for AFS.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 1
a66 1
#include <sys/pioctl.h>
d160 1
a160 1
struct sys_pioctl_args {
d170 1
a170 1
struct sys_pioctl_args {
d194 1
a194 1
    struct sys_pioctl_args *arg = (struct sys_pioctl_args *) v;
d291 1
a291 1
sys_pioctl(struct proc *p, void *v, int *i)
d294 1
a294 1
    struct sys_pioctl_args *arg = (struct sys_pioctl_args *) v;
d321 1
a321 1
    sizeof(struct sys_pioctl_args),    /* size of args */
@

