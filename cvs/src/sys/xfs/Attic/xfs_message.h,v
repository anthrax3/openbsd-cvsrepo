head	1.8;
access;
symbols
	OPENBSD_4_5:1.7.0.22
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.7;

1.7
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.11.14.26.52;	author art;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	2000.03.03.00.54.58;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.00;	author art;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	98.08.31.05.13.27;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.03.32.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.51;	author hin;	state Exp;
branches;
next	;

1.2.4.1
date	2000.03.24.09.09.55;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.05.14.22.47.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.11.01.49;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* $arla: xfs_message.h,v 1.55 2002/09/27 09:43:21 lha Exp $ */

#ifndef _xmsg_h
#define _xmsg_h

/* bump this for any incompatible changes */

#define NNPFS_VERSION 18

#include <xfs/xfs_attr.h>

/* Temporary hack? */
#define MAX_XMSG_SIZE (1024*64)

typedef uint32_t xfs_pag_t;

/*
 * The xfs_cred, if pag == 0, use uid 
 */
typedef struct xfs_cred {
    uint32_t uid;
    xfs_pag_t pag;
} xfs_cred;

typedef uint32_t xfs_locktype_t;
typedef uint32_t xfs_lockid_t;


#define MAXHANDLE (4*4)
#define MAXRIGHTS 8

#define NNPFS_ANONYMOUSID 32766

typedef struct xfs_handle {
    uint32_t a, b, c, d;
} xfs_handle;

#define xfs_handle_eq(p, q) \
((p)->a == (q)->a && (p)->b == (q)->b && (p)->c == (q)->c && (p)->d == (q)->d)

/*
 * This should be the maximum size of any `file handle'
 */

#define CACHEHANDLESIZE 80

typedef struct xfs_cache_handle {
    u_char data[CACHEHANDLESIZE];
} xfs_cache_handle;

/*
 * Tokens that apply to nodes, open modes and attributes. Shared
 * reading might be used for exec and exclusive write for remove.
 */
#define NNPFS_OPEN_MASK	0x000f
#define NNPFS_OPEN_NR	0x0001	       /* Normal reading, data might change */
#define NNPFS_OPEN_SR	0x0002	       /* Shared reading, data won't change */
#define NNPFS_OPEN_NW	0x0004	       /* Normal writing, multiple writers */
#define NNPFS_OPEN_EW	0x0008	       /* Exclusive writing (open really) */

#define NNPFS_ATTR_MASK	0x0030
#define NNPFS_ATTR_R	0x0010	       /* Attributes valid */
#define NNPFS_ATTR_W	0x0020	       /* Attributes valid and modifiable */

/*
 * Tokens that apply to node data.
 */
#define NNPFS_DATA_MASK	0x00c0
#define NNPFS_DATA_R	0x0040	       /* Data valid */
#define NNPFS_DATA_W	0x0080	       /* Data valid and modifiable */
#define NNPFS_LOCK_MASK	0x0300
#define NNPFS_LOCK_R	0x0100	       /* Data Shared locks */
#define NNPFS_LOCK_W	0x0200	       /* Data Exclusive locks */

#define NNPFS_ATTR_VALID		NNPFS_ATTR_R
#define NNPFS_DATA_VALID		NNPFS_DATA_W

/* xfs_node.flags
 * The lower 16 bit flags are reserved for common xfs flags
 * The upper 16 bit flags are reserved for operating system dependent
 * flags.
 */

#define NNPFS_DATA_DIRTY	0x0001
#define NNPFS_ATTR_DIRTY	0x0002
#define NNPFS_AFSDIR		0x0004
#define NNPFS_STALE		0x0008
#define NNPFS_XDELETED		0x0010
#define NNPFS_VMOPEN		0x0020

/*
 * Token match macros, NNPFS_TOKEN_GOT is depricated and
 * NNPFS_TOKEN_GOT_* should be used instead.
 */

/* Are necessary tokens available? */
#define NNPFS_TOKEN_GOT(xn, tok)      ((xn)->tokens & (tok))          /* deprecated */
#define NNPFS_TOKEN_GOT_ANY(xn, tok)  ((xn)->tokens & (tok))          /* at least one must match */
#define NNPFS_TOKEN_GOT_ALL(xn, tok)  (((xn)->tokens & (tok)) == (tok)) /* all tokens must match */
#define NNPFS_TOKEN_SET(xn, tok, mask)	((xn)->tokens |= ((tok) & (mask)))
#define NNPFS_TOKEN_CLEAR(xn, tok, mask)	((xn)->tokens &= ~((tok) & (mask)))

/* definitions for the rights fields */
#define NNPFS_RIGHT_R	0x01		/* may read? */
#define NNPFS_RIGHT_W	0x02		/* may write? */
#define NNPFS_RIGHT_X	0x04		/* may execute? */

/* Max name length passed in xfs messages */

#define NNPFS_MAX_NAME 256
#define NNPFS_MAX_SYMLINK_CONTENT 2048

struct xfs_msg_node {
    xfs_handle handle;
    uint32_t tokens;
    uint32_t pad1;
    struct xfs_attr attr;
    xfs_pag_t id[MAXRIGHTS];
    u_char rights[MAXRIGHTS];
    u_char anonrights;
    uint16_t pad2;
    uint32_t pad3;
};

/*
 * Messages passed through the  xfs_dev.
 */
struct xfs_message_header {
  uint32_t size;
  uint32_t opcode;
  uint32_t sequence_num;		/* Private */
  uint32_t pad1;
};

/*
 * Used by putdata flag
 */
enum { NNPFS_READ     = 0x01,
       NNPFS_WRITE    = 0x02,
       NNPFS_NONBLOCK = 0x04,
       NNPFS_APPEND   = 0x08,
       NNPFS_FSYNC    = 0x10};

/*
 * Flags for inactivenode
 */
enum { NNPFS_NOREFS = 1, NNPFS_DELETE = 2 };

/*
 * Flags for installdata
 */

enum { NNPFS_ID_INVALID_DNLC = 0x01, NNPFS_ID_AFSDIR = 0x02,
       NNPFS_ID_HANDLE_VALID = 0x04 };

/*
 * Defined message types and their opcodes.
 */
#define NNPFS_MSG_VERSION		0
#define NNPFS_MSG_WAKEUP		1

#define NNPFS_MSG_GETROOT		2
#define NNPFS_MSG_INSTALLROOT	3

#define NNPFS_MSG_GETNODE		4
#define NNPFS_MSG_INSTALLNODE	5

#define NNPFS_MSG_GETATTR		6
#define NNPFS_MSG_INSTALLATTR	7

#define NNPFS_MSG_GETDATA		8
#define NNPFS_MSG_INSTALLDATA	9

#define NNPFS_MSG_INACTIVENODE	10
#define NNPFS_MSG_INVALIDNODE	11
		/* XXX Must handle dropped/revoked tokens better */

#define NNPFS_MSG_OPEN		12

#define NNPFS_MSG_PUTDATA		13
#define NNPFS_MSG_PUTATTR		14

/* Directory manipulating messages. */
#define NNPFS_MSG_CREATE		15
#define NNPFS_MSG_MKDIR		16
#define NNPFS_MSG_LINK		17
#define NNPFS_MSG_SYMLINK		18

#define NNPFS_MSG_REMOVE		19
#define NNPFS_MSG_RMDIR		20

#define NNPFS_MSG_RENAME		21

#define NNPFS_MSG_PIOCTL		22
#define NNPFS_MSG_WAKEUP_DATA	23

#define NNPFS_MSG_UPDATEFID	24

#define NNPFS_MSG_ADVLOCK		25

#define NNPFS_MSG_GC_NODES	26

#define NNPFS_MSG_COUNT		27

/* NNPFS_MESSAGE_VERSION */
struct xfs_message_version {
  struct xfs_message_header header;
  uint32_t ret;
};

/* NNPFS_MESSAGE_WAKEUP */
struct xfs_message_wakeup {
  struct xfs_message_header header;
  uint32_t sleepers_sequence_num;	/* Where to send wakeup */
  uint32_t error;			/* Return value */
};

/* NNPFS_MESSAGE_GETROOT */
struct xfs_message_getroot {
  struct xfs_message_header header;
  struct xfs_cred cred;
};

/* NNPFS_MESSAGE_INSTALLROOT */
struct xfs_message_installroot {
  struct xfs_message_header header;
  struct xfs_msg_node node;
};

/* NNPFS_MESSAGE_GETNODE */
struct xfs_message_getnode {
  struct xfs_message_header header;
  struct xfs_cred cred;
  xfs_handle parent_handle;
  char name[NNPFS_MAX_NAME];
};

/* NNPFS_MESSAGE_INSTALLNODE */
struct xfs_message_installnode {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[NNPFS_MAX_NAME];
  struct xfs_msg_node node;
};

/* NNPFS_MESSAGE_GETATTR */
struct xfs_message_getattr {
  struct xfs_message_header header;
  struct xfs_cred cred;
  xfs_handle handle;
};

/* NNPFS_MESSAGE_INSTALLATTR */
struct xfs_message_installattr {
  struct xfs_message_header header;
  struct xfs_msg_node node;
};

/* NNPFS_MESSAGE_GETDATA */
struct xfs_message_getdata {
  struct xfs_message_header header;
  struct xfs_cred cred;
  xfs_handle handle;
  uint32_t tokens;
  uint32_t pad1;
  uint32_t offset;
  uint32_t pad2;
};

/* NNPFS_MESSAGE_INSTALLDATA */
struct xfs_message_installdata {
  struct xfs_message_header header;
  struct xfs_msg_node node;
  char cache_name[NNPFS_MAX_NAME];
  struct xfs_cache_handle cache_handle;
  uint32_t flag;
  uint32_t pad1;
  uint32_t offset;
  uint32_t pad2;
};

/* NNPFS_MSG_INACTIVENODE */
struct xfs_message_inactivenode {
  struct xfs_message_header header;
  xfs_handle handle;
  uint32_t flag;
  uint32_t pad1;
};

/* NNPFS_MSG_INVALIDNODE */
struct xfs_message_invalidnode {
  struct xfs_message_header header;
  xfs_handle handle;
};

/* NNPFS_MSG_OPEN */
struct xfs_message_open {
  struct xfs_message_header header;
  struct xfs_cred cred;
  xfs_handle handle;
  uint32_t tokens;
  uint32_t pad1;
};

/* NNPFS_MSG_PUTDATA */
struct xfs_message_putdata {
  struct xfs_message_header header;
  xfs_handle handle;
  struct xfs_attr attr;		/* XXX ??? */
  struct xfs_cred cred;
  uint32_t flag;
  uint32_t pad1;
};

/* NNPFS_MSG_PUTATTR */
struct xfs_message_putattr {
  struct xfs_message_header header;
  xfs_handle handle;
  struct xfs_attr attr;
  struct xfs_cred cred;
};

/* NNPFS_MSG_CREATE */
struct xfs_message_create {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[NNPFS_MAX_NAME];
  struct xfs_attr attr;
  uint32_t mode;
  uint32_t pad1;
  struct xfs_cred cred;
};

/* NNPFS_MSG_MKDIR */
struct xfs_message_mkdir {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[NNPFS_MAX_NAME];
  struct xfs_attr attr;
  struct xfs_cred cred;
};

/* NNPFS_MSG_LINK */
struct xfs_message_link {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[NNPFS_MAX_NAME];
  xfs_handle from_handle;
  struct xfs_cred cred;
};

/* NNPFS_MSG_SYMLINK */
struct xfs_message_symlink {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[NNPFS_MAX_NAME];
  char contents[NNPFS_MAX_SYMLINK_CONTENT];
  struct xfs_attr attr;
  struct xfs_cred cred;
};

/* NNPFS_MSG_REMOVE */
struct xfs_message_remove {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[NNPFS_MAX_NAME];
  struct xfs_cred cred;
};

/* NNPFS_MSG_RMDIR */
struct xfs_message_rmdir {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[NNPFS_MAX_NAME];
  struct xfs_cred cred;
};

/* NNPFS_MSG_RENAME */
struct xfs_message_rename {
  struct xfs_message_header header;
  xfs_handle old_parent_handle;
  char old_name[NNPFS_MAX_NAME];
  xfs_handle new_parent_handle;
  char new_name[NNPFS_MAX_NAME];
  struct xfs_cred cred;
};

#define NNPFS_MSG_MAX_DATASIZE	2048

/* NNPFS_MSG_PIOCTL */
struct xfs_message_pioctl {
  struct xfs_message_header header;
  uint32_t opcode ;
  uint32_t pad1;
  xfs_cred cred;
  uint32_t insize;
  uint32_t outsize;
  char msg[NNPFS_MSG_MAX_DATASIZE];
  xfs_handle handle;
};


/* NNPFS_MESSAGE_WAKEUP_DATA */
struct xfs_message_wakeup_data {
  struct xfs_message_header header;
  uint32_t sleepers_sequence_num;	/* Where to send wakeup */
  uint32_t error;			/* Return value */
  uint32_t len;
  uint32_t pad1;
  char msg[NNPFS_MSG_MAX_DATASIZE];
};

/* NNPFS_MESSAGE_UPDATEFID */
struct xfs_message_updatefid {
  struct xfs_message_header header;
  xfs_handle old_handle;
  xfs_handle new_handle;
};

/* NNPFS_MESSAGE_ADVLOCK */
struct xfs_message_advlock {
  struct xfs_message_header header;
  xfs_handle handle;
  struct xfs_cred cred;
  xfs_locktype_t locktype;
#define NNPFS_WR_LOCK 1 /* Write lock */
#define NNPFS_RD_LOCK 2 /* Read lock */
#define NNPFS_UN_LOCK 3 /* Unlock */
#define NNPFS_BR_LOCK 4 /* Break lock (inform that we don't want the lock) */
  xfs_lockid_t lockid;
};

/* NNPFS_MESSAGE_GC_NODES */
struct xfs_message_gc_nodes {
  struct xfs_message_header header;
#define NNPFS_GC_NODES_MAX_HANDLE 50
  uint32_t len;
  uint32_t pad1;
  xfs_handle handle[NNPFS_GC_NODES_MAX_HANDLE];
};

#if 0 
struct xfs_name {
    u_int16_t name;
    char name[1];
};
#endif

struct xfs_message_bulkgetnode {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  uint32_t flags;
#define NNPFS_BGN_LAZY		0x1
  uint32_t numnodes;
  struct xfs_handle handles[1];
};

#endif /* _xmsg_h */
@


1.7
log
@typos from Jonathon Gray;
@
text
@@


1.6
log
@Merge
@
text
@d113 1
a113 1
 * The upper 16 bit flags are reserved for operting system dependant
@


1.5
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d34 1
a34 1
/* $Id: xfs_message.h,v 1.4 2000/09/11 14:26:52 art Exp $ */
d41 1
a41 23
#define XFS_VERSION 17

#if defined(WIN32)
#ifdef i386
#ifndef __CYGWIN__
typedef int int32_t;
typedef unsigned int u_int32_t;
typedef short int16_t;
typedef unsigned char u_char;
#endif
#else
#error not a i386
#endif
#elif !defined(__LINUX__) && !defined(HAVE_GLIBC)
#include <sys/types.h>
#if !defined(__OpenBSD__) && defined(_KERNEL)
#include <atypes.h>
#endif
#include <sys/param.h>
#else
#include <linux/types.h>
#include <linux/param.h>
#endif
d48 1
a48 1
typedef u_int32_t xfs_pag_t;
d54 1
a54 1
    u_int32_t uid;
d58 2
a59 2
typedef u_int32_t xfs_locktype_t;
typedef u_int32_t xfs_lockid_t;
d65 1
a65 1
#define XFS_ANONYMOUSID 32766
d68 1
a68 1
    u_int32_t a, b, c, d;
d88 9
a96 9
#define XFS_OPEN_MASK	0x000f
#define XFS_OPEN_NR	0x0001	       /* Normal reading, data might change */
#define XFS_OPEN_SR	0x0002	       /* Shared reading, data won't change */
#define XFS_OPEN_NW	0x0004	       /* Normal writing, multiple writers */
#define XFS_OPEN_EW	0x0008	       /* Exclusive writing (open really) */

#define XFS_ATTR_MASK	0x0030
#define XFS_ATTR_R	0x0010	       /* Attributes valid */
#define XFS_ATTR_W	0x0020	       /* Attributes valid and modifiable */
d101 27
a127 16
#define XFS_DATA_MASK	0x00c0
#define XFS_DATA_R	0x0040	       /* Data valid */
#define XFS_DATA_W	0x0080	       /* Data valid and modifiable */
#define XFS_LOCK_MASK	0x0300
#define XFS_LOCK_R	0x0100	       /* Data Shared locks */
#define XFS_LOCK_W	0x0200	       /* Data Exclusive locks */

#define XFS_ATTR_VALID		XFS_ATTR_R
#define XFS_DATA_VALID		XFS_DATA_W

/* xfs_node.flags */
#define XFS_DATA_DIRTY	0x0001
#define XFS_ATTR_DIRTY	0x0002
#define XFS_AFSDIR	0x0004
#define XFS_STALE	0x0008
#define XFS_XDELETED	0x0010
d130 5
a134 3
#define XFS_TOKEN_GOT(xn, tok)		((xn)->tokens & (tok))
#define XFS_TOKEN_SET(xn, tok, mask)	((xn)->tokens |= ((tok) & (mask)))
#define XFS_TOKEN_CLEAR(xn, tok, mask)	((xn)->tokens &= ~((tok) & (mask)))
d137 3
a139 3
#define XFS_RIGHT_R	0x01		/* may read? */
#define XFS_RIGHT_W	0x02		/* may write? */
#define XFS_RIGHT_X	0x04		/* may execute? */
d143 2
a144 2
#define XFS_MAX_NAME 256
#define XFS_MAX_SYMLINK_CONTENT 2048
d148 2
a149 2
    u_int32_t tokens;
    u_int32_t pad1;
d154 2
a155 2
    u_int16_t pad2;
    u_int32_t pad3;
d162 4
a165 4
  u_int32_t size;
  u_int32_t opcode;
  u_int32_t sequence_num;		/* Private */
  u_int32_t pad1;
d171 5
a175 5
enum { XFS_READ     = 0x01,
       XFS_WRITE    = 0x02,
       XFS_NONBLOCK = 0x04,
       XFS_APPEND   = 0x08,
       XFS_FSYNC    = 0x10};
d180 1
a180 1
enum { XFS_NOREFS = 1, XFS_DELETE = 2 };
d186 2
a187 2
enum { XFS_ID_INVALID_DNLC = 0x01, XFS_ID_AFSDIR = 0x02,
       XFS_ID_HANDLE_VALID = 0x04 };
d192 2
a193 2
#define XFS_MSG_VERSION		0
#define XFS_MSG_WAKEUP		1
d195 2
a196 2
#define XFS_MSG_GETROOT		2
#define XFS_MSG_INSTALLROOT	3
d198 2
a199 2
#define XFS_MSG_GETNODE		4
#define XFS_MSG_INSTALLNODE	5
d201 2
a202 2
#define XFS_MSG_GETATTR		6
#define XFS_MSG_INSTALLATTR	7
d204 2
a205 2
#define XFS_MSG_GETDATA		8
#define XFS_MSG_INSTALLDATA	9
d207 2
a208 2
#define XFS_MSG_INACTIVENODE	10
#define XFS_MSG_INVALIDNODE	11
d211 1
a211 1
#define XFS_MSG_OPEN		12
d213 2
a214 2
#define XFS_MSG_PUTDATA		13
#define XFS_MSG_PUTATTR		14
d217 4
a220 4
#define XFS_MSG_CREATE		15
#define XFS_MSG_MKDIR		16
#define XFS_MSG_LINK		17
#define XFS_MSG_SYMLINK		18
d222 2
a223 2
#define XFS_MSG_REMOVE		19
#define XFS_MSG_RMDIR		20
d225 1
a225 1
#define XFS_MSG_RENAME		21
d227 2
a228 2
#define XFS_MSG_PIOCTL		22
#define XFS_MSG_WAKEUP_DATA	23
d230 1
a230 1
#define XFS_MSG_UPDATEFID	24
d232 1
a232 1
#define XFS_MSG_ADVLOCK		25
d234 1
a234 1
#define XFS_MSG_GC_NODES	26
d236 1
a236 1
#define XFS_MSG_COUNT		27
d238 1
a238 1
/* XFS_MESSAGE_VERSION */
d241 1
a241 1
  u_int32_t ret;
d244 1
a244 1
/* XFS_MESSAGE_WAKEUP */
d247 2
a248 2
  u_int32_t sleepers_sequence_num;	/* Where to send wakeup */
  u_int32_t error;			/* Return value */
d251 1
a251 1
/* XFS_MESSAGE_GETROOT */
d257 1
a257 1
/* XFS_MESSAGE_INSTALLROOT */
d263 1
a263 1
/* XFS_MESSAGE_GETNODE */
d268 1
a268 1
  char name[XFS_MAX_NAME];
d271 1
a271 1
/* XFS_MESSAGE_INSTALLNODE */
d275 1
a275 1
  char name[XFS_MAX_NAME];
d279 1
a279 1
/* XFS_MESSAGE_GETATTR */
d286 1
a286 1
/* XFS_MESSAGE_INSTALLATTR */
d292 1
a292 1
/* XFS_MESSAGE_GETDATA */
d297 4
a300 2
  u_int32_t tokens;
  u_int32_t pad1;
d303 1
a303 1
/* XFS_MESSAGE_INSTALLDATA */
d307 1
a307 1
  char cache_name[XFS_MAX_NAME];
d309 4
a312 2
  u_int32_t flag;
  u_int32_t pad1;
d315 1
a315 1
/* XFS_MSG_INACTIVENODE */
d319 2
a320 2
  u_int32_t flag;
  u_int32_t pad1;
d323 1
a323 1
/* XFS_MSG_INVALIDNODE */
d329 1
a329 1
/* XFS_MSG_OPEN */
d334 2
a335 2
  u_int32_t tokens;
  u_int32_t pad1;
d338 1
a338 1
/* XFS_MSG_PUTDATA */
d344 2
a345 2
  u_int32_t flag;
  u_int32_t pad1;
d348 1
a348 1
/* XFS_MSG_PUTATTR */
d356 1
a356 1
/* XFS_MSG_CREATE */
d360 1
a360 1
  char name[XFS_MAX_NAME];
d362 2
a363 2
  u_int32_t mode;
  u_int32_t pad1;
d367 1
a367 1
/* XFS_MSG_MKDIR */
d371 1
a371 1
  char name[XFS_MAX_NAME];
d376 1
a376 1
/* XFS_MSG_LINK */
d380 1
a380 1
  char name[XFS_MAX_NAME];
d385 1
a385 1
/* XFS_MSG_SYMLINK */
d389 2
a390 2
  char name[XFS_MAX_NAME];
  char contents[XFS_MAX_SYMLINK_CONTENT];
d395 1
a395 1
/* XFS_MSG_REMOVE */
d399 1
a399 1
  char name[XFS_MAX_NAME];
d403 1
a403 1
/* XFS_MSG_RMDIR */
d407 1
a407 1
  char name[XFS_MAX_NAME];
d411 1
a411 1
/* XFS_MSG_RENAME */
d415 1
a415 1
  char old_name[XFS_MAX_NAME];
d417 1
a417 1
  char new_name[XFS_MAX_NAME];
d421 3
a423 1
/* XFS_MSG_PIOCTL */
d426 2
a427 2
  u_int32_t opcode ;
  u_int32_t pad1;
d429 3
a431 3
  u_int32_t insize;
  u_int32_t outsize;
  char msg[2048] ;    /* XXX */
d436 1
a436 1
/* XFS_MESSAGE_WAKEUP_DATA */
d439 5
a443 5
  u_int32_t sleepers_sequence_num;	/* Where to send wakeup */
  u_int32_t error;			/* Return value */
  u_int32_t len;
  u_int32_t pad1;
  char msg[2048] ;    /* XXX */
d446 1
a446 1
/* XFS_MESSAGE_UPDATEFID */
d453 1
a453 1
/* XFS_MESSAGE_ADVLOCK */
d459 4
a462 4
#define XFS_WR_LOCK 1 /* Write lock */
#define XFS_RD_LOCK 2 /* Read lock */
#define XFS_UN_LOCK 3 /* Unlock */
#define XFS_BR_LOCK 4 /* Break lock (inform that we don't want the lock) */
d466 1
a466 1
/* XFS_MESSAGE_GC_NODES */
d469 10
a478 4
#define XFS_GC_NODES_MAX_HANDLE 50
  u_int32_t len;
  u_int32_t pad1;
  xfs_handle handle[XFS_GC_NODES_MAX_HANDLE];
d480 11
@


1.4
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d34 1
a34 1
/* $Id: xfs_message.h,v 1.39 2000/08/02 21:19:04 assar Exp $ */
d137 2
d150 5
d195 2
a196 1
enum { XFS_ID_INVALID_DNLC = 0x01, XFS_ID_AFSDIR = 0x02 };
d277 1
a277 1
  char name[256];		/* XXX */
d284 1
a284 1
  char name[256];		/* XXX */
d314 1
a314 1
  char cache_name[256];		/* XXX */
d365 1
a365 1
  char name[256];		/* XXX */
d376 1
a376 1
  char name[256];		/* XXX */
d385 1
a385 1
  char name[256];		/* XXX */
d394 2
a395 2
  char name[256];		/* XXX */
  char contents[2048];		/* XXX */
d404 1
a404 1
  char name[256];		/* XXX */
d412 1
a412 1
  char name[256];		/* XXX */
d420 1
a420 1
  char old_name[256];		/* XXX */
d422 1
a422 1
  char new_name[256];		/* XXX */
@


1.4.8.1
log
@Sync UBC branch to -current
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d39 1
a39 1
/* $Id: xfs_message.h,v 1.4 2000/09/11 14:26:52 art Exp $ */
a141 2
#define XFS_STALE	0x0008
#define XFS_XDELETED	0x0010
a152 5
/* Max name length passed in xfs messages */

#define XFS_MAX_NAME 256
#define XFS_MAX_SYMLINK_CONTENT 2048

d193 1
a193 2
enum { XFS_ID_INVALID_DNLC = 0x01, XFS_ID_AFSDIR = 0x02,
       XFS_ID_HANDLE_VALID = 0x04 };
d274 1
a274 1
  char name[XFS_MAX_NAME];
d281 1
a281 1
  char name[XFS_MAX_NAME];
d311 1
a311 1
  char cache_name[XFS_MAX_NAME];
d362 1
a362 1
  char name[XFS_MAX_NAME];
d373 1
a373 1
  char name[XFS_MAX_NAME];
d382 1
a382 1
  char name[XFS_MAX_NAME];
d391 2
a392 2
  char name[XFS_MAX_NAME];
  char contents[XFS_MAX_SYMLINK_CONTENT];
d401 1
a401 1
  char name[XFS_MAX_NAME];
d409 1
a409 1
  char name[XFS_MAX_NAME];
d417 1
a417 1
  char old_name[XFS_MAX_NAME];
d419 1
a419 1
  char new_name[XFS_MAX_NAME];
@


1.3
log
@$OpenBSD$
@
text
@a0 1
/* $OpenBSD: xfs_message.h,v 1.2 1999/04/30 01:59:00 art Exp $ */
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d39 1
d44 16
a59 1
#if !defined(__LINUX__) && !defined(HAVE_GLIBC)
d61 3
d75 1
a75 1
typedef u_int32_t pag_t;
d81 2
a82 2
    __kernel_uid_t uid;
    pag_t pag;
d85 2
a86 2
typedef unsigned long xfs_locktype_t;
typedef unsigned long xfs_lockid_t;
d95 1
a95 1
    u_int a, b, c, d;
d141 1
d155 2
a156 1
    u_int tokens;
d158 1
a158 1
    pag_t id[MAXRIGHTS];
d161 2
d169 4
a172 3
  u_int size;
  u_int opcode;
  u_int sequence_num;		/* Private */
d178 5
a182 1
enum { XFS_READ = 1, XFS_WRITE = 2, XFS_NONBLOCK = 4, XFS_APPEND = 8};
d193 1
a193 1
enum { XFS_INVALID_DNLC = 1 };
d240 9
a248 1
#define XFS_MSG_COUNT		26
d253 2
a254 2
  int sleepers_sequence_num;	/* Where to send wakeup */
  int error;			/* Return value */
d303 2
a304 1
  u_int tokens;
d313 2
a314 1
  u_int flag;
d321 2
a322 1
  u_int flag;
d336 2
a337 1
  u_int tokens;
d346 2
a347 1
  u_int flag;
d364 2
a365 1
  int mode;
d426 2
a427 1
  int opcode ;
d429 2
a430 2
  int insize;
  int outsize;
d439 4
a442 3
  int sleepers_sequence_num;	/* Where to send wakeup */
  int error;			/* Return value */
  int len;
d466 8
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 1
a39 1
/* $Id: xfs_message.h,v 1.29 1999/01/12 05:00:22 assar Exp $ */
@


1.2.4.1
log
@Sync with -current
@
text
@a0 1
/* $OpenBSD$ */
d39 1
@


1.2.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
a39 1
/* $Id: xfs_message.h,v 1.4 2000/09/11 14:26:52 art Exp $ */
d44 1
a44 16
/* bump this for any incompatible changes */

#define XFS_VERSION 17

#if defined(WIN32)
#ifdef i386
#ifndef __CYGWIN__
typedef int int32_t;
typedef unsigned int u_int32_t;
typedef short int16_t;
typedef unsigned char u_char;
#endif
#else
#error not a i386
#endif
#elif !defined(__LINUX__) && !defined(HAVE_GLIBC)
a45 3
#if !defined(__OpenBSD__) && defined(_KERNEL)
#include <atypes.h>
#endif
d57 1
a57 1
typedef u_int32_t xfs_pag_t;
d63 2
a64 2
    u_int32_t uid;
    xfs_pag_t pag;
d67 2
a68 2
typedef u_int32_t xfs_locktype_t;
typedef u_int32_t xfs_lockid_t;
d77 1
a77 1
    u_int32_t a, b, c, d;
a122 1
#define XFS_AFSDIR	0x0004
d136 1
a136 2
    u_int32_t tokens;
    u_int32_t pad1;
d138 1
a138 1
    xfs_pag_t id[MAXRIGHTS];
a140 2
    u_int16_t pad2;
    u_int32_t pad3;
d147 3
a149 4
  u_int32_t size;
  u_int32_t opcode;
  u_int32_t sequence_num;		/* Private */
  u_int32_t pad1;
d155 1
a155 5
enum { XFS_READ     = 0x01,
       XFS_WRITE    = 0x02,
       XFS_NONBLOCK = 0x04,
       XFS_APPEND   = 0x08,
       XFS_FSYNC    = 0x10};
d166 1
a166 1
enum { XFS_ID_INVALID_DNLC = 0x01, XFS_ID_AFSDIR = 0x02 };
d213 1
a213 9
#define XFS_MSG_GC_NODES	26

#define XFS_MSG_COUNT		27

/* XFS_MESSAGE_VERSION */
struct xfs_message_version {
  struct xfs_message_header header;
  u_int32_t ret;
};
d218 2
a219 2
  u_int32_t sleepers_sequence_num;	/* Where to send wakeup */
  u_int32_t error;			/* Return value */
d268 1
a268 2
  u_int32_t tokens;
  u_int32_t pad1;
d277 1
a277 2
  u_int32_t flag;
  u_int32_t pad1;
d284 1
a284 2
  u_int32_t flag;
  u_int32_t pad1;
d298 1
a298 2
  u_int32_t tokens;
  u_int32_t pad1;
d307 1
a307 2
  u_int32_t flag;
  u_int32_t pad1;
d324 1
a324 2
  u_int32_t mode;
  u_int32_t pad1;
d385 1
a385 2
  u_int32_t opcode ;
  u_int32_t pad1;
d387 2
a388 2
  u_int32_t insize;
  u_int32_t outsize;
d397 3
a399 4
  u_int32_t sleepers_sequence_num;	/* Where to send wakeup */
  u_int32_t error;			/* Return value */
  u_int32_t len;
  u_int32_t pad1;
a422 8
/* XFS_MESSAGE_GC_NODES */
struct xfs_message_gc_nodes {
  struct xfs_message_header header;
#define XFS_GC_NODES_MAX_HANDLE 50
  u_int32_t len;
  u_int32_t pad1;
  xfs_handle handle[XFS_GC_NODES_MAX_HANDLE];
};
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d39 1
a39 1
/* $Id$ */
a141 2
#define XFS_STALE	0x0008
#define XFS_XDELETED	0x0010
a152 5
/* Max name length passed in xfs messages */

#define XFS_MAX_NAME 256
#define XFS_MAX_SYMLINK_CONTENT 2048

d193 1
a193 2
enum { XFS_ID_INVALID_DNLC = 0x01, XFS_ID_AFSDIR = 0x02,
       XFS_ID_HANDLE_VALID = 0x04 };
d274 1
a274 1
  char name[XFS_MAX_NAME];
d281 1
a281 1
  char name[XFS_MAX_NAME];
d311 1
a311 1
  char cache_name[XFS_MAX_NAME];
d362 1
a362 1
  char name[XFS_MAX_NAME];
d373 1
a373 1
  char name[XFS_MAX_NAME];
d382 1
a382 1
  char name[XFS_MAX_NAME];
d391 2
a392 2
  char name[XFS_MAX_NAME];
  char contents[XFS_MAX_SYMLINK_CONTENT];
d401 1
a401 1
  char name[XFS_MAX_NAME];
d409 1
a409 1
  char name[XFS_MAX_NAME];
d417 1
a417 1
  char old_name[XFS_MAX_NAME];
d419 1
a419 1
  char new_name[XFS_MAX_NAME];
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d34 1
a34 1
/* $arla: xfs_message.h,v 1.55 2002/09/27 09:43:21 lha Exp $ */
d41 23
a63 1
#define NNPFS_VERSION 18
d70 1
a70 1
typedef uint32_t xfs_pag_t;
d76 1
a76 1
    uint32_t uid;
d80 2
a81 2
typedef uint32_t xfs_locktype_t;
typedef uint32_t xfs_lockid_t;
d87 1
a87 1
#define NNPFS_ANONYMOUSID 32766
d90 1
a90 1
    uint32_t a, b, c, d;
d110 9
a118 9
#define NNPFS_OPEN_MASK	0x000f
#define NNPFS_OPEN_NR	0x0001	       /* Normal reading, data might change */
#define NNPFS_OPEN_SR	0x0002	       /* Shared reading, data won't change */
#define NNPFS_OPEN_NW	0x0004	       /* Normal writing, multiple writers */
#define NNPFS_OPEN_EW	0x0008	       /* Exclusive writing (open really) */

#define NNPFS_ATTR_MASK	0x0030
#define NNPFS_ATTR_R	0x0010	       /* Attributes valid */
#define NNPFS_ATTR_W	0x0020	       /* Attributes valid and modifiable */
d123 16
a138 27
#define NNPFS_DATA_MASK	0x00c0
#define NNPFS_DATA_R	0x0040	       /* Data valid */
#define NNPFS_DATA_W	0x0080	       /* Data valid and modifiable */
#define NNPFS_LOCK_MASK	0x0300
#define NNPFS_LOCK_R	0x0100	       /* Data Shared locks */
#define NNPFS_LOCK_W	0x0200	       /* Data Exclusive locks */

#define NNPFS_ATTR_VALID		NNPFS_ATTR_R
#define NNPFS_DATA_VALID		NNPFS_DATA_W

/* xfs_node.flags
 * The lower 16 bit flags are reserved for common xfs flags
 * The upper 16 bit flags are reserved for operating system dependent
 * flags.
 */

#define NNPFS_DATA_DIRTY	0x0001
#define NNPFS_ATTR_DIRTY	0x0002
#define NNPFS_AFSDIR		0x0004
#define NNPFS_STALE		0x0008
#define NNPFS_XDELETED		0x0010
#define NNPFS_VMOPEN		0x0020

/*
 * Token match macros, NNPFS_TOKEN_GOT is depricated and
 * NNPFS_TOKEN_GOT_* should be used instead.
 */
d141 3
a143 5
#define NNPFS_TOKEN_GOT(xn, tok)      ((xn)->tokens & (tok))          /* deprecated */
#define NNPFS_TOKEN_GOT_ANY(xn, tok)  ((xn)->tokens & (tok))          /* at least one must match */
#define NNPFS_TOKEN_GOT_ALL(xn, tok)  (((xn)->tokens & (tok)) == (tok)) /* all tokens must match */
#define NNPFS_TOKEN_SET(xn, tok, mask)	((xn)->tokens |= ((tok) & (mask)))
#define NNPFS_TOKEN_CLEAR(xn, tok, mask)	((xn)->tokens &= ~((tok) & (mask)))
d146 3
a148 3
#define NNPFS_RIGHT_R	0x01		/* may read? */
#define NNPFS_RIGHT_W	0x02		/* may write? */
#define NNPFS_RIGHT_X	0x04		/* may execute? */
d152 2
a153 2
#define NNPFS_MAX_NAME 256
#define NNPFS_MAX_SYMLINK_CONTENT 2048
d157 2
a158 2
    uint32_t tokens;
    uint32_t pad1;
d163 2
a164 2
    uint16_t pad2;
    uint32_t pad3;
d171 4
a174 4
  uint32_t size;
  uint32_t opcode;
  uint32_t sequence_num;		/* Private */
  uint32_t pad1;
d180 5
a184 5
enum { NNPFS_READ     = 0x01,
       NNPFS_WRITE    = 0x02,
       NNPFS_NONBLOCK = 0x04,
       NNPFS_APPEND   = 0x08,
       NNPFS_FSYNC    = 0x10};
d189 1
a189 1
enum { NNPFS_NOREFS = 1, NNPFS_DELETE = 2 };
d195 2
a196 2
enum { NNPFS_ID_INVALID_DNLC = 0x01, NNPFS_ID_AFSDIR = 0x02,
       NNPFS_ID_HANDLE_VALID = 0x04 };
d201 2
a202 2
#define NNPFS_MSG_VERSION		0
#define NNPFS_MSG_WAKEUP		1
d204 2
a205 2
#define NNPFS_MSG_GETROOT		2
#define NNPFS_MSG_INSTALLROOT	3
d207 2
a208 2
#define NNPFS_MSG_GETNODE		4
#define NNPFS_MSG_INSTALLNODE	5
d210 2
a211 2
#define NNPFS_MSG_GETATTR		6
#define NNPFS_MSG_INSTALLATTR	7
d213 2
a214 2
#define NNPFS_MSG_GETDATA		8
#define NNPFS_MSG_INSTALLDATA	9
d216 2
a217 2
#define NNPFS_MSG_INACTIVENODE	10
#define NNPFS_MSG_INVALIDNODE	11
d220 1
a220 1
#define NNPFS_MSG_OPEN		12
d222 2
a223 2
#define NNPFS_MSG_PUTDATA		13
#define NNPFS_MSG_PUTATTR		14
d226 4
a229 4
#define NNPFS_MSG_CREATE		15
#define NNPFS_MSG_MKDIR		16
#define NNPFS_MSG_LINK		17
#define NNPFS_MSG_SYMLINK		18
d231 2
a232 2
#define NNPFS_MSG_REMOVE		19
#define NNPFS_MSG_RMDIR		20
d234 1
a234 1
#define NNPFS_MSG_RENAME		21
d236 2
a237 2
#define NNPFS_MSG_PIOCTL		22
#define NNPFS_MSG_WAKEUP_DATA	23
d239 1
a239 1
#define NNPFS_MSG_UPDATEFID	24
d241 1
a241 1
#define NNPFS_MSG_ADVLOCK		25
d243 1
a243 1
#define NNPFS_MSG_GC_NODES	26
d245 1
a245 1
#define NNPFS_MSG_COUNT		27
d247 1
a247 1
/* NNPFS_MESSAGE_VERSION */
d250 1
a250 1
  uint32_t ret;
d253 1
a253 1
/* NNPFS_MESSAGE_WAKEUP */
d256 2
a257 2
  uint32_t sleepers_sequence_num;	/* Where to send wakeup */
  uint32_t error;			/* Return value */
d260 1
a260 1
/* NNPFS_MESSAGE_GETROOT */
d266 1
a266 1
/* NNPFS_MESSAGE_INSTALLROOT */
d272 1
a272 1
/* NNPFS_MESSAGE_GETNODE */
d277 1
a277 1
  char name[NNPFS_MAX_NAME];
d280 1
a280 1
/* NNPFS_MESSAGE_INSTALLNODE */
d284 1
a284 1
  char name[NNPFS_MAX_NAME];
d288 1
a288 1
/* NNPFS_MESSAGE_GETATTR */
d295 1
a295 1
/* NNPFS_MESSAGE_INSTALLATTR */
d301 1
a301 1
/* NNPFS_MESSAGE_GETDATA */
d306 2
a307 4
  uint32_t tokens;
  uint32_t pad1;
  uint32_t offset;
  uint32_t pad2;
d310 1
a310 1
/* NNPFS_MESSAGE_INSTALLDATA */
d314 1
a314 1
  char cache_name[NNPFS_MAX_NAME];
d316 2
a317 4
  uint32_t flag;
  uint32_t pad1;
  uint32_t offset;
  uint32_t pad2;
d320 1
a320 1
/* NNPFS_MSG_INACTIVENODE */
d324 2
a325 2
  uint32_t flag;
  uint32_t pad1;
d328 1
a328 1
/* NNPFS_MSG_INVALIDNODE */
d334 1
a334 1
/* NNPFS_MSG_OPEN */
d339 2
a340 2
  uint32_t tokens;
  uint32_t pad1;
d343 1
a343 1
/* NNPFS_MSG_PUTDATA */
d349 2
a350 2
  uint32_t flag;
  uint32_t pad1;
d353 1
a353 1
/* NNPFS_MSG_PUTATTR */
d361 1
a361 1
/* NNPFS_MSG_CREATE */
d365 1
a365 1
  char name[NNPFS_MAX_NAME];
d367 2
a368 2
  uint32_t mode;
  uint32_t pad1;
d372 1
a372 1
/* NNPFS_MSG_MKDIR */
d376 1
a376 1
  char name[NNPFS_MAX_NAME];
d381 1
a381 1
/* NNPFS_MSG_LINK */
d385 1
a385 1
  char name[NNPFS_MAX_NAME];
d390 1
a390 1
/* NNPFS_MSG_SYMLINK */
d394 2
a395 2
  char name[NNPFS_MAX_NAME];
  char contents[NNPFS_MAX_SYMLINK_CONTENT];
d400 1
a400 1
/* NNPFS_MSG_REMOVE */
d404 1
a404 1
  char name[NNPFS_MAX_NAME];
d408 1
a408 1
/* NNPFS_MSG_RMDIR */
d412 1
a412 1
  char name[NNPFS_MAX_NAME];
d416 1
a416 1
/* NNPFS_MSG_RENAME */
d420 1
a420 1
  char old_name[NNPFS_MAX_NAME];
d422 1
a422 1
  char new_name[NNPFS_MAX_NAME];
d426 1
a426 3
#define NNPFS_MSG_MAX_DATASIZE	2048

/* NNPFS_MSG_PIOCTL */
d429 2
a430 2
  uint32_t opcode ;
  uint32_t pad1;
d432 3
a434 3
  uint32_t insize;
  uint32_t outsize;
  char msg[NNPFS_MSG_MAX_DATASIZE];
d439 1
a439 1
/* NNPFS_MESSAGE_WAKEUP_DATA */
d442 5
a446 5
  uint32_t sleepers_sequence_num;	/* Where to send wakeup */
  uint32_t error;			/* Return value */
  uint32_t len;
  uint32_t pad1;
  char msg[NNPFS_MSG_MAX_DATASIZE];
d449 1
a449 1
/* NNPFS_MESSAGE_UPDATEFID */
d456 1
a456 1
/* NNPFS_MESSAGE_ADVLOCK */
d462 4
a465 4
#define NNPFS_WR_LOCK 1 /* Write lock */
#define NNPFS_RD_LOCK 2 /* Read lock */
#define NNPFS_UN_LOCK 3 /* Unlock */
#define NNPFS_BR_LOCK 4 /* Break lock (inform that we don't want the lock) */
d469 1
a469 1
/* NNPFS_MESSAGE_GC_NODES */
d472 4
a475 10
#define NNPFS_GC_NODES_MAX_HANDLE 50
  uint32_t len;
  uint32_t pad1;
  xfs_handle handle[NNPFS_GC_NODES_MAX_HANDLE];
};

#if 0 
struct xfs_name {
    u_int16_t name;
    char name[1];
a476 11
#endif

struct xfs_message_bulkgetnode {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  uint32_t flags;
#define NNPFS_BGN_LAZY		0x1
  uint32_t numnodes;
  struct xfs_handle handles[1];
};

@


1.1
log
@indent the code and move around some includes, after discussion with Theo
@
text
@a0 1
/*	$OpenBSD: xfs_message.h,v 1.2 1998/08/30 17:35:43 art Exp $	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d39 1
a39 1
/* $KTH: xfs_message.h,v 1.21 1998/06/27 11:05:24 assar Exp $ */
d41 2
a42 2
#ifndef _SYS_XFS_MESSAGE_H_
#define _SYS_XFS_MESSAGE_H_
d44 1
d47 4
d54 1
d62 8
a69 4
struct xfs_cred {
	__kernel_uid_t	uid;
	pag_t		pag;
};
d71 2
a72 1
typedef struct xfs_cred xfs_cred;
d74 1
a74 2
#define MAXHANDLE	(4*4)
#define MAXRIGHTS	8
a75 1
#define XFS_ANONYMOUSID	32766
d77 1
a77 1
	u_int a, b, c, d;
d79 1
d83 5
d89 3
a91 5
#define CACHEHANDLESIZE	4
struct xfs_cache_handle {
	u_char	data[CACHEHANDLESIZE];
};
typedef struct xfs_cache_handle xfs_cache_handle;
d114 2
a115 2
#define XFS_LOCK_R	0x0100	       /* Data Shared locks? */
#define XFS_LOCK_W	0x0200	       /* Data Exclusive locks? */
d117 2
a118 2
#define XFS_ATTR_VALID	XFS_ATTR_R
#define XFS_DATA_VALID	XFS_DATA_W
d135 6
a140 6
	xfs_handle	handle;
	u_int		tokens;
	struct xfs_attr	attr;
	pag_t		id[MAXRIGHTS];
	u_char		rights[MAXRIGHTS];
	u_char		anonrights;
d147 3
a149 3
	u_int	size;
	u_int	opcode;
	u_int	sequence_num;		/* Private */
d163 6
d209 5
a213 1
#define XFS_MSG_COUNT		24
d217 3
a219 3
	struct xfs_message_header	header;
	int		sleepers_sequence_num;	/* Where to send wakeup */
	int				error;		/* Return value */
d224 2
a225 2
	struct xfs_message_header	header;
	struct xfs_cred			cred;
d230 2
a231 2
	struct xfs_message_header	header;
	struct xfs_msg_node		node;
d236 4
a239 4
	struct xfs_message_header	header;
	struct xfs_cred			cred;
	xfs_handle			parent_handle;
	char				name[256];	/* XXX */
d244 4
a247 4
	struct xfs_message_header	header;
	xfs_handle			parent_handle;
	char				name[256];	/* XXX */
	struct xfs_msg_node		node;
d252 3
a254 3
	struct xfs_message_header	header;
	struct xfs_cred			cred;
	xfs_handle			handle;
d259 2
a260 2
	struct xfs_message_header	header;
	struct xfs_msg_node		node;
d265 4
a268 4
	struct xfs_message_header	header;
	struct xfs_cred			cred;
	xfs_handle			handle;
	u_int				tokens;
d273 5
a277 3
	struct xfs_message_header	header;
	struct xfs_msg_node		node;
	struct xfs_cache_handle		cache_handle;
d282 3
a284 3
	struct xfs_message_header	header;
	xfs_handle			handle;
	u_int				flag;
d289 2
a290 2
	struct xfs_message_header	header;
	xfs_handle			handle;
d295 4
a298 4
	struct xfs_message_header	header;
	struct xfs_cred			cred;
	xfs_handle			handle;
	u_int				tokens;
d303 5
a307 5
	struct xfs_message_header	header;
	xfs_handle			handle;
	struct xfs_attr			attr;
	struct xfs_cred			cred;
	u_int				flag;
d312 4
a315 4
	struct xfs_message_header	header;
	xfs_handle			handle;
	struct xfs_attr			attr;
	struct xfs_cred			cred;
d320 6
a325 9
	struct xfs_message_header	header;
	xfs_handle			parent_handle;
	char				name[256];	/* XXX */
	struct xfs_attr			attr;
#if 0 /* XXX ??? */
	enum vcexcl			exclusive;
#endif
	int				mode;
	struct xfs_cred			cred;
d330 5
a334 5
	struct xfs_message_header	header;
	xfs_handle			parent_handle;
	char				name[256];	/* XXX */
	struct xfs_attr			attr;
	struct xfs_cred			cred;
d339 5
a343 5
	struct xfs_message_header	header;
	xfs_handle			parent_handle;
	char				name[256];	/* XXX */
	xfs_handle			from_handle;
	struct xfs_cred			cred;
d348 6
a353 6
	struct xfs_message_header	header;
	xfs_handle			parent_handle;
	char				name[256];	/* XXX */
	char				contents[2048];	/* XXX */
	struct xfs_attr			attr;
	struct xfs_cred			cred;
d358 4
a361 4
	struct xfs_message_header	header;
	xfs_handle			parent_handle;
	char				name[256];	/* XXX */
	struct xfs_cred			cred;
d366 4
a369 4
	struct xfs_message_header	header;
	xfs_handle			parent_handle;
	char				name[256];	/* XXX */
	struct xfs_cred			cred;
d374 6
a379 6
	struct xfs_message_header	header;
	xfs_handle			old_parent_handle;
	char				old_name[256];	/* XXX */
	xfs_handle			new_parent_handle;
	char				new_name[256];	/* XXX */
	struct xfs_cred			cred;
d384 7
a390 7
	struct xfs_message_header	header;
	int				opcode ;
	xfs_cred			cred;
	int				insize;
	int				outsize;
	char				msg[2048];    /* XXX */
	xfs_handle			handle;
d396 25
a420 5
	struct xfs_message_header	header;
	int		sleepers_sequence_num;	/* Where to send wakeup */
	int				error;		/* Return value */
	int				len;
	char				msg[2048];    /* XXX */
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d40 1
a40 4
/* $Id: xfs_message.h,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $ */

#ifndef _xmsg_h
#define _xmsg_h
d42 2
a43 1
/* bump this for any incompatible changes */
a44 14
#define XFS_VERSION 17

#if defined(WIN32)
#ifdef i386
#ifndef __CYGWIN__
typedef int int32_t;
typedef unsigned int u_int32_t;
typedef short int16_t;
typedef unsigned char u_char;
#endif
#else
#error not a i386
#endif
#elif !defined(__LINUX__) && !defined(HAVE_GLIBC)
a45 3
#if !defined(__OpenBSD__) && defined(_KERNEL)
#include <atypes.h>
#endif
a46 4
#else
#include <linux/types.h>
#include <linux/param.h>
#endif
a49 1
/* Temporary hack? */
d52 1
a52 1
typedef u_int32_t xfs_pag_t;
d57 4
a60 7
typedef struct xfs_cred {
    u_int32_t uid;
    xfs_pag_t pag;
} xfs_cred;

typedef u_int32_t xfs_locktype_t;
typedef u_int32_t xfs_lockid_t;
d62 1
d64 2
a65 4
#define MAXHANDLE (4*4)
#define MAXRIGHTS 8

#define XFS_ANONYMOUSID 32766
d67 1
d69 1
a69 1
    u_int32_t a, b, c, d;
a70 1

a73 3
/*
 * This should be the maximum size of any `file handle'
 */
d75 5
a79 5
#define CACHEHANDLESIZE 80

typedef struct xfs_cache_handle {
    u_char data[CACHEHANDLESIZE];
} xfs_cache_handle;
d102 2
a103 2
#define XFS_LOCK_R	0x0100	       /* Data Shared locks */
#define XFS_LOCK_W	0x0200	       /* Data Exclusive locks */
d105 2
a106 2
#define XFS_ATTR_VALID		XFS_ATTR_R
#define XFS_DATA_VALID		XFS_DATA_W
a110 3
#define XFS_AFSDIR	0x0004
#define XFS_STALE	0x0008
#define XFS_XDELETED	0x0010
a121 5
/* Max name length passed in xfs messages */

#define XFS_MAX_NAME 256
#define XFS_MAX_SYMLINK_CONTENT 2048

d123 6
a128 9
    xfs_handle handle;
    u_int32_t tokens;
    u_int32_t pad1;
    struct xfs_attr attr;
    xfs_pag_t id[MAXRIGHTS];
    u_char rights[MAXRIGHTS];
    u_char anonrights;
    u_int16_t pad2;
    u_int32_t pad3;
d135 3
a137 4
  u_int32_t size;
  u_int32_t opcode;
  u_int32_t sequence_num;		/* Private */
  u_int32_t pad1;
d143 1
a143 5
enum { XFS_READ     = 0x01,
       XFS_WRITE    = 0x02,
       XFS_NONBLOCK = 0x04,
       XFS_APPEND   = 0x08,
       XFS_FSYNC    = 0x10};
a150 7
 * Flags for installdata
 */

enum { XFS_ID_INVALID_DNLC = 0x01, XFS_ID_AFSDIR = 0x02,
       XFS_ID_HANDLE_VALID = 0x04 };

/*
d191 1
a191 13
#define XFS_MSG_UPDATEFID	24

#define XFS_MSG_ADVLOCK		25

#define XFS_MSG_GC_NODES	26

#define XFS_MSG_COUNT		27

/* XFS_MESSAGE_VERSION */
struct xfs_message_version {
  struct xfs_message_header header;
  u_int32_t ret;
};
d195 3
a197 3
  struct xfs_message_header header;
  u_int32_t sleepers_sequence_num;	/* Where to send wakeup */
  u_int32_t error;			/* Return value */
d202 2
a203 2
  struct xfs_message_header header;
  struct xfs_cred cred;
d208 2
a209 2
  struct xfs_message_header header;
  struct xfs_msg_node node;
d214 4
a217 4
  struct xfs_message_header header;
  struct xfs_cred cred;
  xfs_handle parent_handle;
  char name[XFS_MAX_NAME];
d222 4
a225 4
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[XFS_MAX_NAME];
  struct xfs_msg_node node;
d230 3
a232 3
  struct xfs_message_header header;
  struct xfs_cred cred;
  xfs_handle handle;
d237 2
a238 2
  struct xfs_message_header header;
  struct xfs_msg_node node;
d243 4
a246 5
  struct xfs_message_header header;
  struct xfs_cred cred;
  xfs_handle handle;
  u_int32_t tokens;
  u_int32_t pad1;
d251 3
a253 6
  struct xfs_message_header header;
  struct xfs_msg_node node;
  char cache_name[XFS_MAX_NAME];
  struct xfs_cache_handle cache_handle;
  u_int32_t flag;
  u_int32_t pad1;
d258 3
a260 4
  struct xfs_message_header header;
  xfs_handle handle;
  u_int32_t flag;
  u_int32_t pad1;
d265 2
a266 2
  struct xfs_message_header header;
  xfs_handle handle;
d271 4
a274 5
  struct xfs_message_header header;
  struct xfs_cred cred;
  xfs_handle handle;
  u_int32_t tokens;
  u_int32_t pad1;
d279 5
a283 6
  struct xfs_message_header header;
  xfs_handle handle;
  struct xfs_attr attr;		/* XXX ??? */
  struct xfs_cred cred;
  u_int32_t flag;
  u_int32_t pad1;
d288 4
a291 4
  struct xfs_message_header header;
  xfs_handle handle;
  struct xfs_attr attr;
  struct xfs_cred cred;
d296 9
a304 7
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[XFS_MAX_NAME];
  struct xfs_attr attr;
  u_int32_t mode;
  u_int32_t pad1;
  struct xfs_cred cred;
d309 5
a313 5
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[XFS_MAX_NAME];
  struct xfs_attr attr;
  struct xfs_cred cred;
d318 5
a322 5
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[XFS_MAX_NAME];
  xfs_handle from_handle;
  struct xfs_cred cred;
d327 6
a332 6
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[XFS_MAX_NAME];
  char contents[XFS_MAX_SYMLINK_CONTENT];
  struct xfs_attr attr;
  struct xfs_cred cred;
d337 4
a340 4
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[XFS_MAX_NAME];
  struct xfs_cred cred;
d345 4
a348 4
  struct xfs_message_header header;
  xfs_handle parent_handle;
  char name[XFS_MAX_NAME];
  struct xfs_cred cred;
d353 6
a358 6
  struct xfs_message_header header;
  xfs_handle old_parent_handle;
  char old_name[XFS_MAX_NAME];
  xfs_handle new_parent_handle;
  char new_name[XFS_MAX_NAME];
  struct xfs_cred cred;
d363 7
a369 8
  struct xfs_message_header header;
  u_int32_t opcode ;
  u_int32_t pad1;
  xfs_cred cred;
  u_int32_t insize;
  u_int32_t outsize;
  char msg[2048] ;    /* XXX */
  xfs_handle handle;
d375 5
a379 35
  struct xfs_message_header header;
  u_int32_t sleepers_sequence_num;	/* Where to send wakeup */
  u_int32_t error;			/* Return value */
  u_int32_t len;
  u_int32_t pad1;
  char msg[2048] ;    /* XXX */
};

/* XFS_MESSAGE_UPDATEFID */
struct xfs_message_updatefid {
  struct xfs_message_header header;
  xfs_handle old_handle;
  xfs_handle new_handle;
};

/* XFS_MESSAGE_ADVLOCK */
struct xfs_message_advlock {
  struct xfs_message_header header;
  xfs_handle handle;
  struct xfs_cred cred;
  xfs_locktype_t locktype;
#define XFS_WR_LOCK 1 /* Write lock */
#define XFS_RD_LOCK 2 /* Read lock */
#define XFS_UN_LOCK 3 /* Unlock */
#define XFS_BR_LOCK 4 /* Break lock (inform that we don't want the lock) */
  xfs_lockid_t lockid;
};

/* XFS_MESSAGE_GC_NODES */
struct xfs_message_gc_nodes {
  struct xfs_message_header header;
#define XFS_GC_NODES_MAX_HANDLE 50
  u_int32_t len;
  u_int32_t pad1;
  xfs_handle handle[XFS_GC_NODES_MAX_HANDLE];
d381 1
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d34 1
a34 1
/* $arla: xfs_message.h,v 1.55 2002/09/27 09:43:21 lha Exp $ */
d41 23
a63 1
#define NNPFS_VERSION 18
d70 1
a70 1
typedef uint32_t xfs_pag_t;
d76 1
a76 1
    uint32_t uid;
d80 2
a81 2
typedef uint32_t xfs_locktype_t;
typedef uint32_t xfs_lockid_t;
d87 1
a87 1
#define NNPFS_ANONYMOUSID 32766
d90 1
a90 1
    uint32_t a, b, c, d;
d110 9
a118 9
#define NNPFS_OPEN_MASK	0x000f
#define NNPFS_OPEN_NR	0x0001	       /* Normal reading, data might change */
#define NNPFS_OPEN_SR	0x0002	       /* Shared reading, data won't change */
#define NNPFS_OPEN_NW	0x0004	       /* Normal writing, multiple writers */
#define NNPFS_OPEN_EW	0x0008	       /* Exclusive writing (open really) */

#define NNPFS_ATTR_MASK	0x0030
#define NNPFS_ATTR_R	0x0010	       /* Attributes valid */
#define NNPFS_ATTR_W	0x0020	       /* Attributes valid and modifiable */
d123 16
a138 27
#define NNPFS_DATA_MASK	0x00c0
#define NNPFS_DATA_R	0x0040	       /* Data valid */
#define NNPFS_DATA_W	0x0080	       /* Data valid and modifiable */
#define NNPFS_LOCK_MASK	0x0300
#define NNPFS_LOCK_R	0x0100	       /* Data Shared locks */
#define NNPFS_LOCK_W	0x0200	       /* Data Exclusive locks */

#define NNPFS_ATTR_VALID		NNPFS_ATTR_R
#define NNPFS_DATA_VALID		NNPFS_DATA_W

/* xfs_node.flags
 * The lower 16 bit flags are reserved for common xfs flags
 * The upper 16 bit flags are reserved for operting system dependant
 * flags.
 */

#define NNPFS_DATA_DIRTY	0x0001
#define NNPFS_ATTR_DIRTY	0x0002
#define NNPFS_AFSDIR		0x0004
#define NNPFS_STALE		0x0008
#define NNPFS_XDELETED		0x0010
#define NNPFS_VMOPEN		0x0020

/*
 * Token match macros, NNPFS_TOKEN_GOT is depricated and
 * NNPFS_TOKEN_GOT_* should be used instead.
 */
d141 3
a143 5
#define NNPFS_TOKEN_GOT(xn, tok)      ((xn)->tokens & (tok))          /* deprecated */
#define NNPFS_TOKEN_GOT_ANY(xn, tok)  ((xn)->tokens & (tok))          /* at least one must match */
#define NNPFS_TOKEN_GOT_ALL(xn, tok)  (((xn)->tokens & (tok)) == (tok)) /* all tokens must match */
#define NNPFS_TOKEN_SET(xn, tok, mask)	((xn)->tokens |= ((tok) & (mask)))
#define NNPFS_TOKEN_CLEAR(xn, tok, mask)	((xn)->tokens &= ~((tok) & (mask)))
d146 3
a148 3
#define NNPFS_RIGHT_R	0x01		/* may read? */
#define NNPFS_RIGHT_W	0x02		/* may write? */
#define NNPFS_RIGHT_X	0x04		/* may execute? */
d152 2
a153 2
#define NNPFS_MAX_NAME 256
#define NNPFS_MAX_SYMLINK_CONTENT 2048
d157 2
a158 2
    uint32_t tokens;
    uint32_t pad1;
d163 2
a164 2
    uint16_t pad2;
    uint32_t pad3;
d171 4
a174 4
  uint32_t size;
  uint32_t opcode;
  uint32_t sequence_num;		/* Private */
  uint32_t pad1;
d180 5
a184 5
enum { NNPFS_READ     = 0x01,
       NNPFS_WRITE    = 0x02,
       NNPFS_NONBLOCK = 0x04,
       NNPFS_APPEND   = 0x08,
       NNPFS_FSYNC    = 0x10};
d189 1
a189 1
enum { NNPFS_NOREFS = 1, NNPFS_DELETE = 2 };
d195 2
a196 2
enum { NNPFS_ID_INVALID_DNLC = 0x01, NNPFS_ID_AFSDIR = 0x02,
       NNPFS_ID_HANDLE_VALID = 0x04 };
d201 2
a202 2
#define NNPFS_MSG_VERSION		0
#define NNPFS_MSG_WAKEUP		1
d204 2
a205 2
#define NNPFS_MSG_GETROOT		2
#define NNPFS_MSG_INSTALLROOT	3
d207 2
a208 2
#define NNPFS_MSG_GETNODE		4
#define NNPFS_MSG_INSTALLNODE	5
d210 2
a211 2
#define NNPFS_MSG_GETATTR		6
#define NNPFS_MSG_INSTALLATTR	7
d213 2
a214 2
#define NNPFS_MSG_GETDATA		8
#define NNPFS_MSG_INSTALLDATA	9
d216 2
a217 2
#define NNPFS_MSG_INACTIVENODE	10
#define NNPFS_MSG_INVALIDNODE	11
d220 1
a220 1
#define NNPFS_MSG_OPEN		12
d222 2
a223 2
#define NNPFS_MSG_PUTDATA		13
#define NNPFS_MSG_PUTATTR		14
d226 4
a229 4
#define NNPFS_MSG_CREATE		15
#define NNPFS_MSG_MKDIR		16
#define NNPFS_MSG_LINK		17
#define NNPFS_MSG_SYMLINK		18
d231 2
a232 2
#define NNPFS_MSG_REMOVE		19
#define NNPFS_MSG_RMDIR		20
d234 1
a234 1
#define NNPFS_MSG_RENAME		21
d236 2
a237 2
#define NNPFS_MSG_PIOCTL		22
#define NNPFS_MSG_WAKEUP_DATA	23
d239 1
a239 1
#define NNPFS_MSG_UPDATEFID	24
d241 1
a241 1
#define NNPFS_MSG_ADVLOCK		25
d243 1
a243 1
#define NNPFS_MSG_GC_NODES	26
d245 1
a245 1
#define NNPFS_MSG_COUNT		27
d247 1
a247 1
/* NNPFS_MESSAGE_VERSION */
d250 1
a250 1
  uint32_t ret;
d253 1
a253 1
/* NNPFS_MESSAGE_WAKEUP */
d256 2
a257 2
  uint32_t sleepers_sequence_num;	/* Where to send wakeup */
  uint32_t error;			/* Return value */
d260 1
a260 1
/* NNPFS_MESSAGE_GETROOT */
d266 1
a266 1
/* NNPFS_MESSAGE_INSTALLROOT */
d272 1
a272 1
/* NNPFS_MESSAGE_GETNODE */
d277 1
a277 1
  char name[NNPFS_MAX_NAME];
d280 1
a280 1
/* NNPFS_MESSAGE_INSTALLNODE */
d284 1
a284 1
  char name[NNPFS_MAX_NAME];
d288 1
a288 1
/* NNPFS_MESSAGE_GETATTR */
d295 1
a295 1
/* NNPFS_MESSAGE_INSTALLATTR */
d301 1
a301 1
/* NNPFS_MESSAGE_GETDATA */
d306 2
a307 4
  uint32_t tokens;
  uint32_t pad1;
  uint32_t offset;
  uint32_t pad2;
d310 1
a310 1
/* NNPFS_MESSAGE_INSTALLDATA */
d314 1
a314 1
  char cache_name[NNPFS_MAX_NAME];
d316 2
a317 4
  uint32_t flag;
  uint32_t pad1;
  uint32_t offset;
  uint32_t pad2;
d320 1
a320 1
/* NNPFS_MSG_INACTIVENODE */
d324 2
a325 2
  uint32_t flag;
  uint32_t pad1;
d328 1
a328 1
/* NNPFS_MSG_INVALIDNODE */
d334 1
a334 1
/* NNPFS_MSG_OPEN */
d339 2
a340 2
  uint32_t tokens;
  uint32_t pad1;
d343 1
a343 1
/* NNPFS_MSG_PUTDATA */
d349 2
a350 2
  uint32_t flag;
  uint32_t pad1;
d353 1
a353 1
/* NNPFS_MSG_PUTATTR */
d361 1
a361 1
/* NNPFS_MSG_CREATE */
d365 1
a365 1
  char name[NNPFS_MAX_NAME];
d367 2
a368 2
  uint32_t mode;
  uint32_t pad1;
d372 1
a372 1
/* NNPFS_MSG_MKDIR */
d376 1
a376 1
  char name[NNPFS_MAX_NAME];
d381 1
a381 1
/* NNPFS_MSG_LINK */
d385 1
a385 1
  char name[NNPFS_MAX_NAME];
d390 1
a390 1
/* NNPFS_MSG_SYMLINK */
d394 2
a395 2
  char name[NNPFS_MAX_NAME];
  char contents[NNPFS_MAX_SYMLINK_CONTENT];
d400 1
a400 1
/* NNPFS_MSG_REMOVE */
d404 1
a404 1
  char name[NNPFS_MAX_NAME];
d408 1
a408 1
/* NNPFS_MSG_RMDIR */
d412 1
a412 1
  char name[NNPFS_MAX_NAME];
d416 1
a416 1
/* NNPFS_MSG_RENAME */
d420 1
a420 1
  char old_name[NNPFS_MAX_NAME];
d422 1
a422 1
  char new_name[NNPFS_MAX_NAME];
d426 1
a426 3
#define NNPFS_MSG_MAX_DATASIZE	2048

/* NNPFS_MSG_PIOCTL */
d429 2
a430 2
  uint32_t opcode ;
  uint32_t pad1;
d432 3
a434 3
  uint32_t insize;
  uint32_t outsize;
  char msg[NNPFS_MSG_MAX_DATASIZE];
d439 1
a439 1
/* NNPFS_MESSAGE_WAKEUP_DATA */
d442 5
a446 5
  uint32_t sleepers_sequence_num;	/* Where to send wakeup */
  uint32_t error;			/* Return value */
  uint32_t len;
  uint32_t pad1;
  char msg[NNPFS_MSG_MAX_DATASIZE];
d449 1
a449 1
/* NNPFS_MESSAGE_UPDATEFID */
d456 1
a456 1
/* NNPFS_MESSAGE_ADVLOCK */
d462 4
a465 4
#define NNPFS_WR_LOCK 1 /* Write lock */
#define NNPFS_RD_LOCK 2 /* Read lock */
#define NNPFS_UN_LOCK 3 /* Unlock */
#define NNPFS_BR_LOCK 4 /* Break lock (inform that we don't want the lock) */
d469 1
a469 1
/* NNPFS_MESSAGE_GC_NODES */
d472 4
a475 10
#define NNPFS_GC_NODES_MAX_HANDLE 50
  uint32_t len;
  uint32_t pad1;
  xfs_handle handle[NNPFS_GC_NODES_MAX_HANDLE];
};

#if 0 
struct xfs_name {
    u_int16_t name;
    char name[1];
a476 11
#endif

struct xfs_message_bulkgetnode {
  struct xfs_message_header header;
  xfs_handle parent_handle;
  uint32_t flags;
#define NNPFS_BGN_LAZY		0x1
  uint32_t numnodes;
  struct xfs_handle handles[1];
};

@


