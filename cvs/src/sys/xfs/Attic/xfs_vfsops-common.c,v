head	1.11;
access;
symbols
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.10
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.10;

1.10
date	2009.01.15.07.47.05;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.09.21.26.57;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.25.16.40.03;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.04.16.12.32;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.19.19.17.28;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.26.53;	author art;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	2000.03.03.00.54.59;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.01;	author art;	state Exp;
branches
	1.1.1.1
	1.1.4.1;
next	;

1.1.1.1
date	2002.06.07.03.32.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.49;	author hin;	state Exp;
branches;
next	;

1.1.4.1
date	2000.03.24.09.09.55;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.05.14.22.47.53;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.41.31;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.11.01.51;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.06.05.23.13.13;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <xfs/xfs_locl.h>

RCSID("$arla: xfs_vfsops-common.c,v 1.40 2003/06/02 18:26:40 lha Exp $");

/*
 * NNPFS vfs operations.
 */

#include <xfs/xfs_common.h>
#include <xfs/xfs_message.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_dev.h>
#include <xfs/xfs_deb.h>
#include <xfs/xfs_syscalls.h>
#include <xfs/xfs_vfsops.h>

#ifdef HAVE_KERNEL_UDEV2DEV
#define VA_RDEV_TO_DEV(x) udev2dev(x, 0) /* XXX what is the 0 */
#else
#define VA_RDEV_TO_DEV(x) x
#endif


struct xfs xfs[NNNPFS];

/*
 * path and data is in system memory
 */

int
xfs_mount_common_sys(struct mount *mp,
		     const char *path,
		     void *data,
		     struct nameidata *ndp,
		     d_thread_t *p)
{
    struct vnode *devvp;
    dev_t dev;
    int error;
    struct vattr vat;

    NNPFSDEB(XDEBVFOPS, ("xfs_mount: "
		       "struct mount mp = %lx path = '%s' data = '%s'\n",
		       (unsigned long)mp, path, (char *)data));

#ifdef ARLA_KNFS
    NNPFSDEB(XDEBVFOPS, ("xfs_mount: mount flags = %x\n", mp->mnt_flag));

    /*
     * mountd(8) flushes all export entries when it starts
     * right now we ignore it (but should not)
     */

    if (mp->mnt_flag & MNT_UPDATE ||
	mp->mnt_flag & MNT_DELEXPORT) {

	NNPFSDEB(XDEBVFOPS, 
	       ("xfs_mount: ignoring MNT_UPDATE or MNT_DELEXPORT\n"));
	return 0;
    }
#endif

    NDINIT(ndp, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, data, p);
    error = namei(ndp);
    if (error) {
	NNPFSDEB(XDEBVFOPS, ("namei failed, errno = %d\n", error));
	return error;
    }

    devvp = ndp->ni_vp;

    if (devvp->v_type != VCHR) {
	vput(devvp);
	NNPFSDEB(XDEBVFOPS, ("not VCHR (%d)\n", devvp->v_type));
	return ENXIO;
    }
#if defined(__osf__)
    VOP_GETATTR(devvp, &vat, ndp->ni_cred, error);
#elif defined(HAVE_FREEBSD_THREAD)
    error = VOP_GETATTR(devvp, &vat, p->td_proc->p_ucred, p);
#else
    error = VOP_GETATTR(devvp, &vat, p->p_ucred, p);
#endif
    vput(devvp);
    if (error) {
	NNPFSDEB(XDEBVFOPS, ("VOP_GETATTR failed, error = %d\n", error));
	return error;
    }

    dev = VA_RDEV_TO_DEV(vat.va_rdev);

    NNPFSDEB(XDEBVFOPS, ("dev = %d.%d\n", major(dev), minor(dev)));

    if (!xfs_is_xfs_dev (dev)) {
	NNPFSDEB(XDEBVFOPS, ("%s is not a xfs device\n", (char *)data));
	return ENXIO;
    }

    if (xfs[minor(dev)].status & NNPFS_MOUNTED)
	return EBUSY;

    xfs[minor(dev)].status = NNPFS_MOUNTED;
    xfs[minor(dev)].mp = mp;
    xfs[minor(dev)].root = 0;
    xfs[minor(dev)].nnodes = 0;
    xfs[minor(dev)].fd = minor(dev);

    nnfs_init_head(&xfs[minor(dev)].nodehead);

    VFS_ASSIGN(mp, &xfs[minor(dev)]);
#if defined(HAVE_KERNEL_VFS_GETNEWFSID)
#if defined(HAVE_TWO_ARGUMENT_VFS_GETNEWFSID)
    vfs_getnewfsid(mp, MOUNT_AFS);
#else
    vfs_getnewfsid(mp);
#endif /* HAVE_TWO_ARGUMENT_VFS_GETNEWFSID */
#endif /* HAVE_KERNEL_VFS_GETNEWFSID */

    mp->mnt_stat.f_bsize = DEV_BSIZE;
#ifndef __osf__
    mp->mnt_stat.f_iosize = DEV_BSIZE;
    mp->mnt_stat.f_owner = 0;
#endif
    mp->mnt_stat.f_blocks = 4711 * 4711;
    mp->mnt_stat.f_bfree = 4711 * 4711;
    mp->mnt_stat.f_bavail = 4711 * 4711;
    mp->mnt_stat.f_files = 4711;
    mp->mnt_stat.f_ffree = 4711;
    mp->mnt_stat.f_flags = mp->mnt_flag;

#ifdef __osf__
    mp->mnt_stat.f_fsid.val[0] = dev;
    mp->mnt_stat.f_fsid.val[1] = MOUNT_NNPFS;
	
    mp->m_stat.f_mntonname = malloc(strlen(path) + 1, M_PATHNAME, M_WAITOK);
    strcpy(mp->m_stat.f_mntonname, path);

    mp->m_stat.f_mntfromname = malloc(sizeof("arla"), M_PATHNAME, M_WAITOK);
    strcpy(mp->m_stat.f_mntfromname, "arla");
#else /* __osf__ */
    strncpy(mp->mnt_stat.f_mntonname,
	    path,
	    sizeof(mp->mnt_stat.f_mntonname));

    strncpy(mp->mnt_stat.f_mntfromname,
	    data,
	    sizeof(mp->mnt_stat.f_mntfromname));

    strncpy(mp->mnt_stat.f_fstypename,
	    "xfs",
	    sizeof(mp->mnt_stat.f_fstypename));
#endif /* __osf__ */

    return 0;
}

int
xfs_mount_common(struct mount *mp,
		 const char *user_path,
		 void *user_data,
		 struct nameidata *ndp,
		 d_thread_t *p)
{
    char *path = NULL;
    char *data = NULL;
    size_t count;
    int error = 0;

    data = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
    if (data == NULL) {
        error = ENOMEM;
	goto done;
    }
    path = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
    if (path == NULL) {
        error = ENOMEM;
	goto done;
    }

    error = copyinstr(user_path, path, MAXPATHLEN, &count);
    if (error)
        goto done;      

    error = copyinstr(user_data, data, MAXPATHLEN, &count);
    if (error)
	goto done;
    error = xfs_mount_common_sys (mp, path, data, ndp, p);
done:
    free(data, M_TEMP);
    free(path, M_TEMP);		   	
    return(error);	
}

#ifdef HAVE_KERNEL_DOFORCE
extern int doforce;
#endif

int
xfs_unmount_common(struct mount *mp, int mntflags)
{
    struct xfs *xfsp = VFS_TO_NNPFS(mp);
    int flags = 0;
    int error;

    if (mntflags & MNT_FORCE) {
#ifdef HAVE_KERNEL_DOFORCE
	if (!doforce)
	    return EINVAL;
#endif
	flags |= FORCECLOSE;
    }

    error = free_all_xfs_nodes(xfsp, flags, 1);
    if (error)
	return error;

    xfsp->status = 0;
    NNPFS_TO_VFS(xfsp) = NULL;
    return 0;
}

int
xfs_root_common(struct mount *mp, struct vnode **vpp,
		d_thread_t *proc, struct ucred *cred)
{
    struct xfs *xfsp = VFS_TO_NNPFS(mp);
    struct xfs_message_getroot msg;
    int error;

    do {
	if (xfsp->root != NULL) {
	    *vpp = XNODE_TO_VNODE(xfsp->root);
	    xfs_do_vget(*vpp, LK_EXCLUSIVE, proc);
	    return 0;
	}
	msg.header.opcode = NNPFS_MSG_GETROOT;
	msg.cred.uid = cred->cr_uid;
	msg.cred.pag = xfs_get_pag(cred);
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), proc);
	if (error == 0)
	    error = ((struct xfs_message_wakeup *) & msg)->error;
    } while (error == 0);
    /*
     * Failed to get message through, need to pretend that all went well
     * and return a fake dead vnode to be able to unmount.
     */

    if ((error = xfs_make_dead_vnode(mp, vpp)))
	return error;

    NNPFS_MAKE_VROOT(*vpp);
    return 0;
}
@


1.10
log
@Don't use (type *)var as an lvalue in assigment, it's incorrect.
Provide proper assignment macro instead. No binary change.

ok beck@@
@
text
@@


1.9
log
@MALLOC/FREE -> malloc/free

ok gilles
@
text
@d143 1
a143 1
    VFS_TO_NNPFS(mp) = &xfs[minor(dev)];
@


1.8
log
@spelling fixes, from Martynas Venckus;
@
text
@d168 1
a168 2
    MALLOC(mp->m_stat.f_mntonname, char *, strlen(path) + 1, 
	   M_PATHNAME, M_WAITOK);
d171 1
a171 2
    MALLOC(mp->m_stat.f_mntfromname, char *, sizeof("arla"),
	   M_PATHNAME, M_WAITOK);
@


1.7
log
@fix worst three kernel stack pigs in xfs by moving stack allocation of
xfs message structures to malloc M_TEMP.
ok art@@
@
text
@d91 1
a91 1
	       ("xfs_mount: ignoreing MNT_UPDATE or MNT_DELEXPORT\n"));
@


1.6
log
@Set sensible value for mntfromname, to make 'mount' report the
xfs device that was actually mounted, not just 'arla'.

Issue noted by deraadt@@. Thanks to Jan Johansson (janj+openbsd at wenf.org)
for testing on i386 and sparc64.
@
text
@d199 2
a200 2
    char path[MAXPATHLEN];
    char data[MAXPATHLEN];
d202 12
a213 1
    int error;
d217 1
a217 1
	return error;
d221 6
a226 2
	return error;
    return xfs_mount_common_sys (mp, path, data, ndp, p);
@


1.5
log
@Merge
@
text
@d181 1
a181 1
	    "arla",
@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$Id: xfs_vfsops-common.c,v 1.1.1.1 2002/06/07 03:32:59 hin Exp $");
d39 1
a39 1
 * XFS vfs operations.
d57 5
a61 1
struct xfs xfs[NXFS];
d64 5
a68 5
xfs_mount_common(struct mount *mp,
		 const char *user_path,
		 caddr_t user_data,
		 struct nameidata *ndp,
		 struct proc *p)
a73 3
    char path[MAXPATHLEN];
    char data[MAXPATHLEN];
    size_t count;
d75 1
a75 9
    error = copyinstr(user_path, path, MAXPATHLEN, &count);
    if (error)
	return error;

    error = copyinstr(user_data, data, MAXPATHLEN, &count);
    if (error)
	return error;

    XFSDEB(XDEBVFOPS, ("xfs_mount: "
d77 1
a77 1
		       (unsigned long)mp, path, data));
d80 1
a80 1
    XFSDEB(XDEBVFOPS, ("xfs_mount: mount flags = %x\n", mp->mnt_flag));
d90 1
a90 1
	XFSDEB(XDEBVFOPS, 
d99 1
a99 1
	XFSDEB(XDEBVFOPS, ("namei failed, errno = %d\n", error));
d107 1
a107 1
	XFSDEB(XDEBVFOPS, ("not VCHR (%d)\n", devvp->v_type));
d110 1
a110 1
#ifdef __osf__
d112 2
d119 1
a119 1
	XFSDEB(XDEBVFOPS, ("VOP_GETATTR failed, error = %d\n", error));
d125 1
a125 1
    XFSDEB(XDEBVFOPS, ("dev = %d.%d\n", major(dev), minor(dev)));
d128 1
a128 2
	XFSDEB(XDEBVFOPS, ("%s is not a xfs device\n",
			   data));
d132 1
a132 1
    if (xfs[minor(dev)].status & XFS_MOUNTED)
d135 1
a135 1
    xfs[minor(dev)].status = XFS_MOUNTED;
d141 3
a143 1
    VFS_TO_XFS(mp) = &xfs[minor(dev)];
d149 2
a150 2
#endif HAVE_TWO_ARGUMENT_VFS_GETNEWFSID
#endif HAVE_KERNEL_VFS_GETNEWFSID
d166 1
a166 1
    mp->mnt_stat.f_fsid.val[1] = MOUNT_XFS;
d192 22
d221 1
a221 1
    struct xfs *xfsp = VFS_TO_XFS(mp);
d238 1
a238 1
    XFS_TO_VFS(xfsp) = NULL;
d244 1
a244 1
		struct proc *proc, struct ucred *cred)
d246 1
a246 1
    struct xfs *xfsp = VFS_TO_XFS(mp);
d256 1
a256 1
	msg.header.opcode = XFS_MSG_GETROOT;
d268 1
a268 1
    if ((error = make_dead_vnode(mp, vpp)))
d271 1
a271 1
    (*vpp)->v_flag |= VROOT;
@


1.3
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
d36 1
a36 1
RCSID("$Id: xfs_vfsops-common.c,v 1.27 2000/08/01 20:36:56 assar Exp $");
d72 1
d74 1
a74 1
    error = copyinstr(user_path, path, MAXPATHLEN, NULL);
d78 1
a78 1
    error = copyinstr(user_data, data, MAXPATHLEN, NULL);
d148 1
d153 2
a154 1
#endif
d241 1
a241 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg));
@


1.3.8.1
log
@Sync UBC branch to -current
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$Id: xfs_vfsops-common.c,v 1.3 2000/09/11 14:26:53 art Exp $");
a76 1
    size_t count;
d78 1
a78 1
    error = copyinstr(user_path, path, MAXPATHLEN, &count);
d82 1
a82 1
    error = copyinstr(user_data, data, MAXPATHLEN, &count);
a151 1
#if defined(HAVE_KERNEL_VFS_GETNEWFSID)
d156 1
a156 2
#endif HAVE_TWO_ARGUMENT_VFS_GETNEWFSID
#endif HAVE_KERNEL_VFS_GETNEWFSID
d243 1
a243 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), proc);
@


1.2
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d41 1
a41 1
RCSID("$OpenBSD: xfs_vfsops-common.c,v 1.1 1999/04/30 01:59:01 art Exp $");
d55 7
a76 1
    size_t len;
d78 1
a78 1
    error = copyinstr(user_path, path, MAXPATHLEN, &len);
d82 1
a82 1
    error = copyinstr(user_data, data, MAXPATHLEN, &len);
d87 2
a88 2
		       "struct mount mp = %p path = '%s' data = '%s'\n",
		       mp, path, data));
d131 3
a133 1
    dev = vat.va_rdev;
d136 3
a138 9
    /* Check that this device really is an xfs_dev */
    if (major(dev) < 0 || major(dev) > nchrdev) {
	XFSDEB(XDEBVFOPS, ("major out of range (0 < %d < %d)\n", 
			   major(dev), nchrdev));
	return ENXIO;
    }
    if (minor(dev) < 0 || NXFS < minor(dev)) {
	XFSDEB(XDEBVFOPS, ("minor out of range (0 < %d < %d)\n", 
			   minor(dev), NXFS));
a140 8
#if defined(__NetBSD__) || defined(__OpenBSD__)
    if(!xfs_func_is_devopen(cdevsw[major(dev)].d_open))
	return ENXIO;
#elif defined(__FreeBSD__)
    if (cdevsw[major(dev)] == NULL
	|| !xfs_func_is_devopen(cdevsw[major(dev)]->d_open))
	return ENXIO;
#endif
a151 1
#if defined(HAVE_KERNEL_VFS_GETNEWFSID)
a156 6
#elif defined(__NetBSD__) || defined(__OpenBSD__)
    getnewfsid(mp, makefstype(MOUNT_AFS));
#elif defined(__FreeBSD__)
    getnewfsid(mp, MOUNT_AFS);
    mp->mnt_stat.f_type = MOUNT_AFS;
#endif
a189 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a192 1
#endif
d198 4
a210 1
	extern int doforce;
d237 1
a237 1
	    xfs_do_vget(*vpp, LK_INTERLOCK|LK_EXCLUSIVE, proc);
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 2
d43 1
a43 1
RCSID("$Id: xfs_vfsops-common.c,v 1.18 1999/03/19 04:54:55 lha Exp $");
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$Id: xfs_vfsops-common.c,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $");
a54 7
#ifdef HAVE_KERNEL_UDEV2DEV
#define VA_RDEV_TO_DEV(x) udev2dev(x, 0) /* XXX what is the 0 */
#else
#define VA_RDEV_TO_DEV(x) x
#endif


d70 1
a70 1
    size_t count;
d72 1
a72 1
    error = copyinstr(user_path, path, MAXPATHLEN, &count);
d76 1
a76 1
    error = copyinstr(user_data, data, MAXPATHLEN, &count);
d81 2
a82 2
		       "struct mount mp = %lx path = '%s' data = '%s'\n",
		       (unsigned long)mp, path, data));
d125 1
a125 3

    dev = VA_RDEV_TO_DEV(vat.va_rdev);

d128 9
a136 3
    if (!xfs_is_xfs_dev (dev)) {
	XFSDEB(XDEBVFOPS, ("%s is not a xfs device\n",
			   data));
d139 8
d163 7
a169 2
#endif HAVE_TWO_ARGUMENT_VFS_GETNEWFSID
#endif HAVE_KERNEL_VFS_GETNEWFSID
d203 1
d207 1
a212 4
#ifdef HAVE_KERNEL_DOFORCE
extern int doforce;
#endif

d222 1
d249 1
a249 1
	    xfs_do_vget(*vpp, LK_EXCLUSIVE, proc);
d255 1
a255 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), proc);
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$arla: xfs_vfsops-common.c,v 1.40 2003/06/02 18:26:40 lha Exp $");
d39 1
a39 1
 * NNPFS vfs operations.
d57 1
a57 5
struct xfs xfs[NNNPFS];

/*
 * path and data is in system memory
 */
d60 5
a64 5
xfs_mount_common_sys(struct mount *mp,
		     const char *path,
		     void *data,
		     struct nameidata *ndp,
		     d_thread_t *p)
d70 3
d74 9
a82 1
    NNPFSDEB(XDEBVFOPS, ("xfs_mount: "
d84 1
a84 1
		       (unsigned long)mp, path, (char *)data));
d87 1
a87 1
    NNPFSDEB(XDEBVFOPS, ("xfs_mount: mount flags = %x\n", mp->mnt_flag));
d97 1
a97 1
	NNPFSDEB(XDEBVFOPS, 
d106 1
a106 1
	NNPFSDEB(XDEBVFOPS, ("namei failed, errno = %d\n", error));
d114 1
a114 1
	NNPFSDEB(XDEBVFOPS, ("not VCHR (%d)\n", devvp->v_type));
d117 1
a117 1
#if defined(__osf__)
a118 2
#elif defined(HAVE_FREEBSD_THREAD)
    error = VOP_GETATTR(devvp, &vat, p->td_proc->p_ucred, p);
d124 1
a124 1
	NNPFSDEB(XDEBVFOPS, ("VOP_GETATTR failed, error = %d\n", error));
d130 1
a130 1
    NNPFSDEB(XDEBVFOPS, ("dev = %d.%d\n", major(dev), minor(dev)));
d133 2
a134 1
	NNPFSDEB(XDEBVFOPS, ("%s is not a xfs device\n", (char *)data));
d138 1
a138 1
    if (xfs[minor(dev)].status & NNPFS_MOUNTED)
d141 1
a141 1
    xfs[minor(dev)].status = NNPFS_MOUNTED;
d147 1
a147 3
    nnfs_init_head(&xfs[minor(dev)].nodehead);

    VFS_TO_NNPFS(mp) = &xfs[minor(dev)];
d153 2
a154 2
#endif /* HAVE_TWO_ARGUMENT_VFS_GETNEWFSID */
#endif /* HAVE_KERNEL_VFS_GETNEWFSID */
d170 1
a170 1
    mp->mnt_stat.f_fsid.val[1] = MOUNT_NNPFS;
a195 22
int
xfs_mount_common(struct mount *mp,
		 const char *user_path,
		 void *user_data,
		 struct nameidata *ndp,
		 d_thread_t *p)
{
    char path[MAXPATHLEN];
    char data[MAXPATHLEN];
    size_t count;
    int error;

    error = copyinstr(user_path, path, MAXPATHLEN, &count);
    if (error)
	return error;

    error = copyinstr(user_data, data, MAXPATHLEN, &count);
    if (error)
	return error;
    return xfs_mount_common_sys (mp, path, data, ndp, p);
}

d203 1
a203 1
    struct xfs *xfsp = VFS_TO_NNPFS(mp);
d220 1
a220 1
    NNPFS_TO_VFS(xfsp) = NULL;
d226 1
a226 1
		d_thread_t *proc, struct ucred *cred)
d228 1
a228 1
    struct xfs *xfsp = VFS_TO_NNPFS(mp);
d238 1
a238 1
	msg.header.opcode = NNPFS_MSG_GETROOT;
d250 1
a250 1
    if ((error = xfs_make_dead_vnode(mp, vpp)))
d253 1
a253 1
    NNPFS_MAKE_VROOT(*vpp);
@


1.1.4.1
log
@Sync with -current
@
text
@a0 2
/*	$OpenBSD$	*/

d41 1
a41 1
RCSID("$OpenBSD$");
@


1.1.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d43 1
a43 1
RCSID("$Id: xfs_vfsops-common.c,v 1.3 2000/09/11 14:26:53 art Exp $");
a56 7
#ifdef HAVE_KERNEL_UDEV2DEV
#define VA_RDEV_TO_DEV(x) udev2dev(x, 0) /* XXX what is the 0 */
#else
#define VA_RDEV_TO_DEV(x) x
#endif


d72 1
d74 1
a74 1
    error = copyinstr(user_path, path, MAXPATHLEN, NULL);
d78 1
a78 1
    error = copyinstr(user_data, data, MAXPATHLEN, NULL);
d83 2
a84 2
		       "struct mount mp = %lx path = '%s' data = '%s'\n",
		       (unsigned long)mp, path, data));
d127 1
a127 3

    dev = VA_RDEV_TO_DEV(vat.va_rdev);

d130 9
a138 3
    if (!xfs_is_xfs_dev (dev)) {
	XFSDEB(XDEBVFOPS, ("%s is not a xfs device\n",
			   data));
d141 8
d160 1
d166 6
d205 1
d209 1
a214 4
#ifdef HAVE_KERNEL_DOFORCE
extern int doforce;
#endif

d224 1
d251 1
a251 1
	    xfs_do_vget(*vpp, LK_EXCLUSIVE, proc);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$Id$");
a76 1
    size_t count;
d78 1
a78 1
    error = copyinstr(user_path, path, MAXPATHLEN, &count);
d82 1
a82 1
    error = copyinstr(user_data, data, MAXPATHLEN, &count);
a151 1
#if defined(HAVE_KERNEL_VFS_GETNEWFSID)
d156 1
a156 2
#endif HAVE_TWO_ARGUMENT_VFS_GETNEWFSID
#endif HAVE_KERNEL_VFS_GETNEWFSID
d243 1
a243 1
	error = xfs_message_rpc(xfsp->fd, &msg.header, sizeof(msg), proc);
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$arla: xfs_vfsops-common.c,v 1.40 2003/06/02 18:26:40 lha Exp $");
d39 1
a39 1
 * NNPFS vfs operations.
d57 1
a57 5
struct xfs xfs[NNNPFS];

/*
 * path and data is in system memory
 */
d60 5
a64 5
xfs_mount_common_sys(struct mount *mp,
		     const char *path,
		     void *data,
		     struct nameidata *ndp,
		     d_thread_t *p)
d70 3
d74 9
a82 1
    NNPFSDEB(XDEBVFOPS, ("xfs_mount: "
d84 1
a84 1
		       (unsigned long)mp, path, (char *)data));
d87 1
a87 1
    NNPFSDEB(XDEBVFOPS, ("xfs_mount: mount flags = %x\n", mp->mnt_flag));
d97 1
a97 1
	NNPFSDEB(XDEBVFOPS, 
d106 1
a106 1
	NNPFSDEB(XDEBVFOPS, ("namei failed, errno = %d\n", error));
d114 1
a114 1
	NNPFSDEB(XDEBVFOPS, ("not VCHR (%d)\n", devvp->v_type));
d117 1
a117 1
#if defined(__osf__)
a118 2
#elif defined(HAVE_FREEBSD_THREAD)
    error = VOP_GETATTR(devvp, &vat, p->td_proc->p_ucred, p);
d124 1
a124 1
	NNPFSDEB(XDEBVFOPS, ("VOP_GETATTR failed, error = %d\n", error));
d130 1
a130 1
    NNPFSDEB(XDEBVFOPS, ("dev = %d.%d\n", major(dev), minor(dev)));
d133 2
a134 1
	NNPFSDEB(XDEBVFOPS, ("%s is not a xfs device\n", (char *)data));
d138 1
a138 1
    if (xfs[minor(dev)].status & NNPFS_MOUNTED)
d141 1
a141 1
    xfs[minor(dev)].status = NNPFS_MOUNTED;
d147 1
a147 3
    nnfs_init_head(&xfs[minor(dev)].nodehead);

    VFS_TO_NNPFS(mp) = &xfs[minor(dev)];
d153 2
a154 2
#endif /* HAVE_TWO_ARGUMENT_VFS_GETNEWFSID */
#endif /* HAVE_KERNEL_VFS_GETNEWFSID */
d170 1
a170 1
    mp->mnt_stat.f_fsid.val[1] = MOUNT_NNPFS;
a195 22
int
xfs_mount_common(struct mount *mp,
		 const char *user_path,
		 void *user_data,
		 struct nameidata *ndp,
		 d_thread_t *p)
{
    char path[MAXPATHLEN];
    char data[MAXPATHLEN];
    size_t count;
    int error;

    error = copyinstr(user_path, path, MAXPATHLEN, &count);
    if (error)
	return error;

    error = copyinstr(user_data, data, MAXPATHLEN, &count);
    if (error)
	return error;
    return xfs_mount_common_sys (mp, path, data, ndp, p);
}

d203 1
a203 1
    struct xfs *xfsp = VFS_TO_NNPFS(mp);
d220 1
a220 1
    NNPFS_TO_VFS(xfsp) = NULL;
d226 1
a226 1
		d_thread_t *proc, struct ucred *cred)
d228 1
a228 1
    struct xfs *xfsp = VFS_TO_NNPFS(mp);
d238 1
a238 1
	msg.header.opcode = NNPFS_MSG_GETROOT;
d250 1
a250 1
    if ((error = xfs_make_dead_vnode(mp, vpp)))
d253 1
a253 1
    NNPFS_MAKE_VROOT(*vpp);
@


1.1.4.5
log
@Merge with the trunk
@
text
@d181 1
a181 1
	    data,
@


