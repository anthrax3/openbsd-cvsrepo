head	1.10;
access;
symbols
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.9;

1.9
date	2007.10.08.17.09.32;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.29.21.28.05;	author thib;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.04.16.12.32;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.12.10.55.09;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.26.53;	author art;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	2000.03.03.00.54.58;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.01;	author art;	state Exp;
branches
	1.1.1.1
	1.1.4.1;
next	;

1.1.1.1
date	2002.06.07.03.32.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.52;	author hin;	state Exp;
branches;
next	;

1.1.4.1
date	2000.03.24.09.09.55;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.05.14.22.47.53;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.41.31;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.11.01.50;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <xfs/xfs_locl.h>

RCSID("$arla: xfs_syscalls-common.c,v 1.72 2003/01/19 20:53:49 lha Exp $");

/*
 * NNPFS system calls.
 */

#include <xfs/xfs_syscalls.h>
#include <xfs/xfs_message.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_dev.h>
#include <xfs/xfs_node.h>
#include <xfs/xfs_vfsops.h>
#include <xfs/xfs_deb.h>

/* Misc syscalls */
#ifdef HAVE_SYS_IOCCOM_H
#include <sys/ioccom.h>
#elif defined(HAVE_SYS_IOCTL_H)
#include <sys/ioctl.h>
#endif
/*
 * XXX - horrible kludge.  If we are openbsd and not building an lkm,
 *     then use their headerfile.
 */
#if (defined(__OpenBSD__) || defined(__NetBSD__)) && !defined(_LKM)
#define NNPFS_NOT_LKM 1
#elif defined(__FreeBSD__) && !defined(KLD_MODULE)
#define NNPFS_NOT_LKM 1
#endif

#ifdef NNPFS_NOT_LKM
#include <xfs/xfs_pioctl.h>
#else
#include <kafs.h>
#endif

int (*old_setgroups_func)(syscall_d_thread_t *p, void *v, register_t *retval);

#if defined(__FreeBSD__) && __FreeBSD_version >= 500026
/*
 * XXX This is wrong
 */
static struct ucred *
xfs_crcopy(struct ucred *cr)
{
    struct ucred *ncr;

    if (crshared(cr)) {
	ncr = crdup(cr);
	crfree(cr);
	return ncr;
    }
    return cr;
}
#else
#define xfs_crcopy crcopy
#endif


/*
 * the syscall entry point
 */

#ifdef NNPFS_NOT_LKM
int
sys_xfspioctl(syscall_d_thread_t *proc, void *varg, register_t *return_value)
#else
int
xfspioctl(syscall_d_thread_t *proc, void *varg, register_t *return_value)
#endif
{
#ifdef NNPFS_NOT_LKM
    struct sys_xfspioctl_args *arg = (struct sys_xfspioctl_args *) varg;
#else
    struct sys_pioctl_args *arg = (struct sys_pioctl_args *) varg;
#endif
    int error = EINVAL;

    switch (SCARG(arg, operation)) {
    case AFSCALL_PIOCTL:
	error = xfs_pioctl_call(syscall_thread_to_thread(proc),
				  varg, return_value);
	break;
    case AFSCALL_SETPAG:
#ifdef HAVE_FREEBSD_THREAD
	error = xfs_setpag_call(&xfs_thread_to_cred(proc));
#else
	error = xfs_setpag_call(&xfs_proc_to_cred(syscall_thread_to_thread(proc)));
#endif
	break;
    default:
	NNPFSDEB(XDEBSYS, ("Unimplemeted xfspioctl: %d\n",
			 SCARG(arg, operation)));
	error = EINVAL;
	break;
    }

    return error;
}

/*
 * Def pag:
 *  33536 <= g0 <= 34560
 *  32512 <= g1 <= 48896
 */

#define NNPFS_PAG1_LLIM 33536
#define NNPFS_PAG1_ULIM 34560
#define NNPFS_PAG2_LLIM 32512
#define NNPFS_PAG2_ULIM 48896

static gid_t pag_part_one = NNPFS_PAG1_LLIM;
static gid_t pag_part_two = NNPFS_PAG2_LLIM;

/*
 * Is `cred' member of a PAG?
 */

static int
xfs_is_pag(struct ucred *cred)
{
    /* The first group is the gid of the user ? */

    if (cred->cr_ngroups >= 3 &&
	cred->cr_groups[1] >= NNPFS_PAG1_LLIM &&
	cred->cr_groups[1] <= NNPFS_PAG1_ULIM &&
	cred->cr_groups[2] >= NNPFS_PAG2_LLIM &&
	cred->cr_groups[2] <= NNPFS_PAG2_ULIM)
	return 1;
    else
	return 0;
}

/*
 * Return the pag used by `cred'
 */

xfs_pag_t
xfs_get_pag(struct ucred *cred)
{
    if (xfs_is_pag(cred)) {

	return (((cred->cr_groups[1] << 16) & 0xFFFF0000) |
		((cred->cr_groups[2] & 0x0000FFFF)));

    } else
	return cred->cr_uid;	       /* XXX */
}

/*
 * Set the pag in `ret_cred' and return a new cred.
 */

static int
store_pag (struct ucred **ret_cred, gid_t part1, gid_t part2)
{
    struct ucred *cred = *ret_cred;

    if (!xfs_is_pag (cred)) {
	int i;

	if (cred->cr_ngroups + 2 >= NGROUPS)
	    return E2BIG;

	cred = xfs_crcopy (cred);

	for (i = cred->cr_ngroups - 1; i > 0; i--) {
	    cred->cr_groups[i + 2] = cred->cr_groups[i];
	}
	cred->cr_ngroups += 2;
    } else {
	cred = xfs_crcopy (cred);
    }
    cred->cr_groups[1] = part1;
    cred->cr_groups[2] = part2;
    *ret_cred = cred;

    return 0;
}

/*
 * Acquire a new pag in `ret_cred'
 */

int
xfs_setpag_call(struct ucred **ret_cred)
{
    int ret;

    ret = store_pag (ret_cred, pag_part_one, pag_part_two++);
    if (ret)
	return ret;

    if (pag_part_two > NNPFS_PAG2_ULIM) {
	pag_part_one++;
	pag_part_two = NNPFS_PAG2_LLIM;
    }
    return 0;
}

#ifndef NNPFS_NOT_LKM
/*
 * remove a pag
 */

static int
xfs_unpag (struct ucred *cred)
{
    while (xfs_is_pag (cred)) {
	int i;

	for (i = 0; i < cred->cr_ngroups - 2; ++i)
	    cred->cr_groups[i] = cred->cr_groups[i+2];
	cred->cr_ngroups -= 2;
    }
    return 0;
}

/*
 * A wrapper around setgroups that preserves the pag.
 */

int
xfs_setgroups (syscall_d_thread_t *p,
	       void *varg,
	       register_t *retval)
{
    struct xfs_setgroups_args *uap = (struct xfs_setgroups_args *)varg;
#ifdef HAVE_FREEBSD_THREAD
    struct ucred **cred = &xfs_thread_to_cred(p);
#else
    struct ucred **cred = &xfs_proc_to_cred(syscall_thread_to_thread(p));
#endif

    if (xfs_is_pag (*cred)) {
	gid_t part1, part2;
	int ret;

	if (SCARG(uap,gidsetsize) + 2 > NGROUPS)
	    return EINVAL;

	part1 = (*cred)->cr_groups[1];
	part2 = (*cred)->cr_groups[2];
	ret = (*old_setgroups_func) (p, uap, retval);
	if (ret)
	    return ret;
	return store_pag (cred, part1, part2);
    } else {
	int ret;

	ret = (*old_setgroups_func) (p, uap, retval);
	/* don't support setting a PAG */
	if (xfs_is_pag (*cred)) {
	    xfs_unpag (*cred);
	    return EINVAL;
	}
	return ret;
    }
}
#endif /* !NNPFS_NOT_LKM */

/*
 * Return the vnode corresponding to `pathptr'
 */

static int
lookup_node (const char *pathptr,
	     int follow_links_p,
	     struct vnode **res,
	     d_thread_t *proc)
{
    int error;
    char path[MAXPATHLEN];
#ifdef __osf__
    struct nameidata *ndp = &u.u_nd;
#else
    struct nameidata nd, *ndp = &nd;
#endif
    struct vnode *vp;
    size_t count;

    NNPFSDEB(XDEBSYS, ("xfs_syscall: looking up: %lx\n",
		     (unsigned long)pathptr));

    error = copyinstr((char *) pathptr, path, MAXPATHLEN, &count);

    NNPFSDEB(XDEBSYS, ("xfs_syscall: looking up: %s, error: %d\n", path, error));

    if (error)
	return error;

    NDINIT(ndp, LOOKUP,
	   follow_links_p ? FOLLOW : 0,
	   UIO_SYSSPACE, path, proc);

    error = namei(ndp);
	
    if (error != 0) {
	NNPFSDEB(XDEBSYS, ("xfs_syscall: error during namei: %d\n", error));
	return EINVAL;
    }

    vp = ndp->ni_vp;

    *res = vp;
    return 0;
}

/*
 * implement xfs fhget in a way that should be compatible with the native
 * getfh
 */

static int
getfh_compat (d_thread_t *p,
	      struct ViceIoctl *vice_ioctl,
	      struct vnode *vp)
{
    /* This is to be same as getfh */
    fhandle_t fh;
    int error;
	
    bzero((caddr_t)&fh, sizeof(fh));
    fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
#if __osf__
    VFS_VPTOFH(vp, &fh.fh_fid, error);
#else
    error = VFS_VPTOFH(vp, &fh.fh_fid);
#endif
    if (error)
	return error;

    if (vice_ioctl->out_size < sizeof(fh))
	return EINVAL;
	
    return copyout((caddr_t)&fh, vice_ioctl->out, sizeof (fh));
}

/*
 * implement xfs fhget by combining (dev, ino, generation)
 */

#ifndef __OpenBSD__
static int
trad_fhget (d_thread_t *p,
	    struct ViceIoctl *vice_ioctl,
	    struct vnode *vp)
{
    int error;
    struct mount *mnt;
    struct vattr vattr;
    size_t len;
    struct xfs_fhandle_t xfs_handle;
    struct xfs_fh_args fh_args;

#ifdef HAVE_FREEBSD_THREAD
    xfs_vop_getattr(vp, &vattr, xfs_thread_to_cred(p), p, error);
#else
    xfs_vop_getattr(vp, &vattr, xfs_proc_to_cred(p), p, error);
#endif
    if (error)
	return error;

    mnt = vp->v_mount;

    SCARG(&fh_args, fsid)   = mnt->mnt_stat.f_fsid;
    SCARG(&fh_args, fileid) = vattr.va_fileid;
    SCARG(&fh_args, gen)    = vattr.va_gen;
    
    xfs_handle.len = sizeof(fh_args);
    memcpy (xfs_handle.fhdata, &fh_args, sizeof(fh_args));
    len = sizeof(xfs_handle);

    if (vice_ioctl->out_size < len)
	return EINVAL;

    error = copyout (&xfs_handle, vice_ioctl->out, len);
    if (error) {
	NNPFSDEB(XDEBSYS, ("fhget_call: copyout failed: %d\n", error));
    }
    return error;
}
#endif  /* ! __OpenBSD__ */

/*
 * return file handle of `vp' in vice_ioctl->out
 * vp is vrele:d
 */

static int
fhget_call (d_thread_t *p,
	    struct ViceIoctl *vice_ioctl,
	    struct vnode *vp)
{
    int error;

    NNPFSDEB(XDEBSYS, ("fhget_call\n"));

    if (vp == NULL)
	return EBADF;

#if defined(__APPLE__) || defined(__osf__)
    error = EINVAL; /* XXX: Leaks vnodes if fhget/fhopen is used */
    goto out;
#endif

    error = xfs_suser (p);
    if (error)
	goto out;

#if (defined(HAVE_GETFH) && defined(HAVE_FHOPEN)) || defined(__osf__)
    error = getfh_compat (p, vice_ioctl, vp);
#else
    error = trad_fhget (p, vice_ioctl, vp);
#endif /* HAVE_GETFH && HAVE_FHOPEN */
out:
    vrele(vp);
    return error;
}

/*
 * open the file specified in `vice_ioctl->in'
 */

static int
fhopen_call (d_thread_t *p,
	     struct ViceIoctl *vice_ioctl,
	     struct vnode *vp,
	     int flags,
	     register_t *retval)
{

    NNPFSDEB(XDEBSYS, ("fhopen_call: flags = %d\n", flags));

    if (vp != NULL) {
	vrele (vp);
	return EINVAL;
    }

#if defined(__APPLE__) || defined(__osf__)
    return EINVAL; /* XXX: Leaks vnodes if fhget/fhopen is used */
#endif

    return xfs_fhopen (p,
		       (struct xfs_fhandle_t *)vice_ioctl->in,
		       flags,
		       retval);
}

/*
 * Send the pioctl to arlad
 */

static int
remote_pioctl (d_thread_t *p,
	       struct sys_pioctl_args *arg,
	       struct ViceIoctl *vice_ioctl,
	       struct vnode *vp)
{
    int error = 0;
    struct xfs_message_pioctl *msg = NULL;
    struct xfs_message_wakeup_data *msg2;

    msg = malloc(sizeof(*msg), M_TEMP, M_WAITOK | M_ZERO);
    if (msg == NULL) {
        error = ENOMEM;
	goto done;
    }

    if (vp != NULL) {
	struct xfs_node *xn;

	if (vp->v_tag != VT_XFS) {
	    NNPFSDEB(XDEBSYS, ("xfs_syscall: file is not in afs\n"));
	    vrele(vp);
	    error = EINVAL;
	    goto done;
	}

	xn = VNODE_TO_XNODE(vp);

	msg->handle = xn->handle;
	vrele(vp);
    }

    if (vice_ioctl->in_size < 0) {
	printf("xfs: remote pioctl: got a negative data size: opcode: %d",
	       SCARG(arg, a_opcode));
	error = EINVAL;
	goto done;
    }

    if (vice_ioctl->in_size > NNPFS_MSG_MAX_DATASIZE) {
	printf("xfs_pioctl_call: got a humongous in packet: opcode: %d",
	       SCARG(arg, a_opcode));
	error = EINVAL;
	goto done;
    }
    if (vice_ioctl->in_size != 0) {
	error = copyin(vice_ioctl->in, msg->msg, vice_ioctl->in_size);
	if (error)
	  goto done;
    }

    msg->header.opcode = NNPFS_MSG_PIOCTL;
    msg->header.size = sizeof(*msg);
    msg->opcode = SCARG(arg, a_opcode);

    msg->insize = vice_ioctl->in_size;
    msg->outsize = vice_ioctl->out_size;
#ifdef HAVE_FREEBSD_THREAD
    msg->cred.uid = xfs_thread_to_euid(p);
    msg->cred.pag = xfs_get_pag(xfs_thread_to_cred(p));
#else
    msg->cred.uid = xfs_proc_to_euid(p);
    msg->cred.pag = xfs_get_pag(xfs_proc_to_cred(p));
#endif

    error = xfs_message_rpc(0, &(msg->header), sizeof(*msg), p); /* XXX */
    msg2 = (struct xfs_message_wakeup_data *) msg;

    if (error == 0)
	error = msg2->error;
    if (error == ENODEV)
	error = EINVAL;

    if (error == 0 && msg2->header.opcode == NNPFS_MSG_WAKEUP_DATA) {
	int len;

	len = msg2->len;
	if (len > vice_ioctl->out_size)
	    len = vice_ioctl->out_size;
	if (len > NNPFS_MSG_MAX_DATASIZE)
	    len = NNPFS_MSG_MAX_DATASIZE;
	if (len < 0)
	    len = 0;

	error = copyout(msg2->msg, vice_ioctl->out, len);
    }
 done:
    free(msg, M_TEMP);
    return error;
}

static int
xfs_debug (d_thread_t *p,
	   struct ViceIoctl *vice_ioctl)
{
    int32_t flags;
    int error;

    if (vice_ioctl->in_size != 0) {
	if (vice_ioctl->in_size < sizeof(int32_t))
	    return EINVAL;
	
	error = xfs_suser (p);
	if (error)
	    return error;

	error = copyin (vice_ioctl->in,
			&flags,
			sizeof(flags));
	if (error)
	    return error;
	
	xfsdeb = flags;
    }
    
    if (vice_ioctl->out_size != 0) {
	if (vice_ioctl->out_size < sizeof(int32_t))
	    return EINVAL;
	
	error = copyout (&xfsdeb,
			 vice_ioctl->out,
			 sizeof(int32_t));
	if (error)
	    return error;
    }

    return 0;
}


/*
 * Handle `pioctl'
 */

int
xfs_pioctl_call(d_thread_t *proc,
		struct sys_pioctl_args *arg,
		register_t *return_value)
{
    int error;
    struct ViceIoctl vice_ioctl;
    char *pathptr;
    struct vnode *vp = NULL;

    NNPFSDEB(XDEBSYS, ("xfs_syscall(%d, %lx, %d, %lx, %d)\n", 
		     SCARG(arg, operation),
		     (unsigned long)SCARG(arg, a_pathP),
		     SCARG(arg, a_opcode),
		     (unsigned long)SCARG(arg, a_paramsP),
		     SCARG(arg, a_followSymlinks)));

    /* Copy in the data structure for us */

    error = copyin(SCARG(arg, a_paramsP),
		   &vice_ioctl,
		   sizeof(vice_ioctl));

    if (error)
	return error;

    pathptr = SCARG(arg, a_pathP);

    if (pathptr != NULL) {
	error = lookup_node (pathptr, SCARG(arg, a_followSymlinks), &vp,
			     proc);
	if(error)
	    return error;
    }
	
    switch (SCARG(arg, a_opcode)) {
    case VIOC_FHGET :
	return fhget_call (proc, &vice_ioctl, vp);
    case VIOC_FHOPEN :
	return fhopen_call (proc, &vice_ioctl, vp,
			    SCARG(arg, a_followSymlinks), return_value);
    case VIOC_XFSDEBUG :
	if (vp != NULL)
	    vrele (vp);
	return xfs_debug (proc, &vice_ioctl);
    default :
	NNPFSDEB(XDEBSYS, ("a_opcode = %x\n", SCARG(arg, a_opcode)));
	return remote_pioctl (proc, arg, &vice_ioctl, vp);
    }
}
@


1.9
log
@A memset(,0,) -> M_ZERO change which also fixes a possible bug with
malloc'ing one struct size but zero'ing the memory with another struct
size.

Feedback from todd@@ tedu@@ miod@@
@
text
@@


1.8
log
@make xfs use VT_XFS instead of VT_AFS when getting vnodes
via getnewvnode();

ok art@@,tedu@@
tested by todd@@
@
text
@d499 1
a499 1
    msg = malloc(sizeof(struct xfs_message_symlink), M_TEMP, M_WAITOK);
a503 1
    memset(msg, 0, sizeof(*msg));
@


1.7
log
@fix worst three kernel stack pigs in xfs by moving stack allocation of
xfs message structures to malloc M_TEMP.
ok art@@
@
text
@d509 1
a509 1
	if (vp->v_tag != VT_AFS) {
@


1.6
log
@Fix include stuff, unused variables and statics and other small things needed
to compile in our tree.
@
text
@d495 2
a496 2
    int error;
    struct xfs_message_pioctl msg;
d499 7
d512 2
a513 1
	    return EINVAL;
d518 1
a518 1
	msg.handle = xn->handle;
d525 2
a526 1
	return EINVAL;
d532 2
a533 1
	return EINVAL;
d536 1
a536 1
	error = copyin(vice_ioctl->in, msg.msg, vice_ioctl->in_size);
d538 1
a538 1
	    return error;
d541 3
a543 3
    msg.header.opcode = NNPFS_MSG_PIOCTL;
    msg.header.size = sizeof(msg);
    msg.opcode = SCARG(arg, a_opcode);
d545 2
a546 2
    msg.insize = vice_ioctl->in_size;
    msg.outsize = vice_ioctl->out_size;
d548 2
a549 2
    msg.cred.uid = xfs_thread_to_euid(p);
    msg.cred.pag = xfs_get_pag(xfs_thread_to_cred(p));
d551 2
a552 2
    msg.cred.uid = xfs_proc_to_euid(p);
    msg.cred.pag = xfs_get_pag(xfs_proc_to_cred(p));
d555 2
a556 2
    error = xfs_message_rpc(0, &msg.header, sizeof(msg), p); /* XXX */
    msg2 = (struct xfs_message_wakeup_data *) &msg;
d576 2
@


1.5
log
@Merge
@
text
@d378 1
d418 1
d653 1
a653 1
    case VIOC_NNPFSDEBUG :
@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$Id: xfs_syscalls-common.c,v 1.1.1.1 2002/06/07 03:32:59 hin Exp $");
d39 1
a39 1
 * XFS system calls.
d57 2
a58 2
 * XXX - horrible kludge. If we're built without HAVE_CONFIG_H we assume that
 *       we're built inside the kernel on OpenBSD.
d60 9
a68 1
#ifdef HAVE_CONFIG_H
d70 20
d91 1
a91 1
#include <xfs/xfs_pioctl.h>
d94 1
d99 1
a99 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
d101 1
a101 1
xfspioctl(struct proc *proc, void *varg, register_t *return_value)
d104 1
a104 1
sys_xfspioctl(struct proc *proc, void *varg, register_t *return_value)
d107 3
a109 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
a110 2
#else
    struct sys_xfspioctl_args *arg = (struct sys_xfspioctl_args *) varg;
d116 2
a117 1
	error = xfs_pioctl_call(proc, varg, return_value);
d120 5
a124 1
	error = xfs_setpag_call(&xfs_proc_to_cred(proc));
d127 1
a127 1
	XFSDEB(XDEBSYS, ("Unimplemeted xfspioctl: %d\n",
d142 4
a145 4
#define XFS_PAG1_LLIM 33536
#define XFS_PAG1_ULIM 34560
#define XFS_PAG2_LLIM 32512
#define XFS_PAG2_ULIM 48896
d147 2
a148 2
static gid_t pag_part_one = XFS_PAG1_LLIM;
static gid_t pag_part_two = XFS_PAG2_LLIM;
d160 4
a163 4
	cred->cr_groups[1] >= XFS_PAG1_LLIM &&
	cred->cr_groups[1] <= XFS_PAG1_ULIM &&
	cred->cr_groups[2] >= XFS_PAG2_LLIM &&
	cred->cr_groups[2] <= XFS_PAG2_ULIM)
d200 1
a200 1
	cred = crcopy (cred);
d207 1
a207 1
	cred = crcopy (cred);
d229 1
a229 1
    if (pag_part_two > XFS_PAG2_ULIM) {
d231 1
a231 1
	pag_part_two = XFS_PAG2_LLIM;
d236 1
a236 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
d259 3
a261 2
xfs_setgroups (struct proc *p,
	       void *varg)
d264 5
a268 1
    struct ucred **cred = &xfs_proc_to_cred(p);
d279 1
a279 1
	ret = (*old_setgroups_func) (p, uap);
d286 1
a286 1
	ret = (*old_setgroups_func) (p, uap);
d295 1
a295 1
#endif
d305 1
a305 1
	     struct proc *proc)
d317 1
a317 1
    XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %lx\n",
d322 1
a322 1
    XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %s, error: %d\n", path, error));
d334 1
a334 1
	XFSDEB(XDEBSYS, ("xfs_syscall: error during namei: %d\n", error));
d350 1
a350 1
getfh_compat (struct proc *p,
a377 1
#ifndef __OpenBSD__
d379 1
a379 1
trad_fhget (struct proc *p,
d390 3
d394 1
d413 1
a413 1
	XFSDEB(XDEBSYS, ("fhget_call: copyout failed: %d\n", error));
a416 1
#endif /* !__OpenBSD__ */
d424 1
a424 1
fhget_call (struct proc *p,
d430 1
a430 1
    XFSDEB(XDEBSYS, ("fhget_call\n"));
d459 1
a459 1
fhopen_call (struct proc *p,
d466 1
a466 1
    XFSDEB(XDEBSYS, ("fhopen_call: flags = %d\n", flags));
d488 1
a488 1
remote_pioctl (struct proc *p,
d501 1
a501 1
	    XFSDEB(XDEBSYS, ("xfs_syscall: file is not in afs\n"));
d512 7
a518 1
    if (vice_ioctl->in_size > 2048) {
d524 1
a524 4
	error = copyin(vice_ioctl->in,
		       &msg.msg,
		       vice_ioctl->in_size);

d529 2
a530 1
    msg.header.opcode = XFS_MSG_PIOCTL;
d535 4
d541 1
d551 13
a563 3
    if (error == 0 && msg2->header.opcode == XFS_MSG_WAKEUP_DATA)
	error = copyout(msg2->msg, vice_ioctl->out, 
			min(msg2->len, vice_ioctl->out_size));
d568 1
a568 1
xfs_debug (struct proc *p,
d611 1
a611 1
xfs_pioctl_call(struct proc *proc,
d620 1
a620 1
    XFSDEB(XDEBSYS, ("xfs_syscall(%d, %lx, %d, %lx, %d)\n", 
d651 1
a651 1
    case VIOC_XFSDEBUG :
d656 1
a656 1
	XFSDEB(XDEBSYS, ("a_opcode = %x\n", SCARG(arg, a_opcode)));
@


1.3
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
d36 1
a36 1
RCSID("$Id: xfs_syscalls-common.c,v 1.51 2000/08/02 00:06:16 assar Exp $");
d70 1
a70 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__)
d78 1
a78 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__)
d202 1
a202 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__)
d276 1
d281 1
a281 1
    error = copyinstr((char *) pathptr, path, MAXPATHLEN, NULL);
d306 31
a336 1
 * return file handle of `vp' in vice_ioctl->out
d339 1
d341 1
a341 1
fhget_call (struct proc *p,
a345 1
#if !((defined(HAVE_GETFH) && defined(HAVE_FHOPEN)) || defined(__osf__))
a350 1
#endif
d352 1
a352 6
    XFSDEB(XDEBSYS, ("fhget_call\n"));

    if (vp == NULL)
	return EBADF;

    error = xfs_suser (p);
a355 26
#if (defined(HAVE_GETFH) && defined(HAVE_FHOPEN)) || defined(__osf__)
    {
	/* This is to be same as getfh */
	fhandle_t fh;
	
	bzero((caddr_t)&fh, sizeof(fh));
	fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
#if __osf__
	VFS_VPTOFH(vp, &fh.fh_fid, error);
#else
        error = VFS_VPTOFH(vp, &fh.fh_fid);
#endif
        if (error)
	    return (error);

	if (vice_ioctl->out_size < sizeof(fh))
	    return EINVAL;
	
	error = copyout((caddr_t)&fh, vice_ioctl->out, sizeof (fh));
	return (error);
    }
#else
    xfs_vop_getattr(vp, &vattr, xfs_proc_to_cred(p), p, error);
    if (error)
	goto out;

d366 2
a367 4
    if (vice_ioctl->out_size < len) {
	error = EINVAL;
	goto out;
    }
a372 3
    
 out:
    vrele (vp);
d374 33
d408 3
a410 1
    
d432 4
d490 1
a490 1
    msg.cred.uid = xfs_proc_to_ruid(p);
d493 1
a493 1
    error = xfs_message_rpc(0, &msg.header, sizeof(msg)); /* XXX */
d591 3
a593 1
    case VIOC_XFSDEBUG:
@


1.3.8.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$Id: xfs_syscalls-common.c,v 1.3 2000/09/11 14:26:53 art Exp $");
d75 1
a75 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
d83 1
a83 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
d207 1
a207 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
a280 1
    size_t count;
d285 1
a285 1
    error = copyinstr((char *) pathptr, path, MAXPATHLEN, &count);
d310 1
a310 2
 * implement xfs fhget in a way that should be compatible with the native
 * getfh
d314 1
a314 31
getfh_compat (struct proc *p,
	      struct ViceIoctl *vice_ioctl,
	      struct vnode *vp)
{
    /* This is to be same as getfh */
    fhandle_t fh;
    int error;
	
    bzero((caddr_t)&fh, sizeof(fh));
    fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
#if __osf__
    VFS_VPTOFH(vp, &fh.fh_fid, error);
#else
    error = VFS_VPTOFH(vp, &fh.fh_fid);
#endif
    if (error)
	return error;

    if (vice_ioctl->out_size < sizeof(fh))
	return EINVAL;
	
    return copyout((caddr_t)&fh, vice_ioctl->out, sizeof (fh));
}

/*
 * implement xfs fhget by combining (dev, ino, generation)
 */

#ifndef __OpenBSD__
static int
trad_fhget (struct proc *p,
d319 1
d325 10
d336 22
d360 1
a360 1
	return error;
d372 4
a375 2
    if (vice_ioctl->out_size < len)
	return EINVAL;
d381 3
a384 33
}
#endif /* !__OpenBSD__ */

/*
 * return file handle of `vp' in vice_ioctl->out
 * vp is vrele:d
 */

static int
fhget_call (struct proc *p,
	    struct ViceIoctl *vice_ioctl,
	    struct vnode *vp)
{
    int error;

    XFSDEB(XDEBSYS, ("fhget_call\n"));

    if (vp == NULL)
	return EBADF;

#if defined(__APPLE__) || defined(__osf__)
    error = EINVAL; /* XXX: Leaks vnodes if fhget/fhopen is used */
    goto out;
#endif

    error = xfs_suser (p);
    if (error)
	goto out;

#if (defined(HAVE_GETFH) && defined(HAVE_FHOPEN)) || defined(__osf__)
    error = getfh_compat (p, vice_ioctl, vp);
#else
    error = trad_fhget (p, vice_ioctl, vp);
d386 1
a386 3
out:
    vrele(vp);
    return error;
a407 4
#if defined(__APPLE__) || defined(__osf__)
    return EINVAL; /* XXX: Leaks vnodes if fhget/fhopen is used */
#endif

d462 1
a462 1
    msg.cred.uid = xfs_proc_to_euid(p);
d465 1
a465 1
    error = xfs_message_rpc(0, &msg.header, sizeof(msg), p); /* XXX */
d563 1
a563 3
    case VIOC_XFSDEBUG :
	if (vp != NULL)
	    vrele (vp);
@


1.2
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d41 1
a41 1
RCSID("$OpenBSD: xfs_syscalls-common.c,v 1.1 1999/04/30 01:59:01 art Exp $");
d61 7
d69 1
d75 4
d81 1
d83 1
d85 3
d144 1
a144 1
pag_t
d157 1
a157 1
 * Acquire a new pag in `ret_cred'
d160 2
a161 2
int
xfs_setpag_call(struct ucred **ret_cred)
a163 1
    int i;
d165 2
a166 1
    if (!xfs_is_pag(cred)) {
a167 1
	/* Check if it fits */
d169 1
a169 1
	    return E2BIG;	       /* XXX Hmmm, better error ? */
a172 1
	/* Copy the groups */
d177 9
d187 8
a194 2
    } else
	cred = crcopy(cred);
d196 3
a198 2
    cred->cr_groups[1] = pag_part_one;
    cred->cr_groups[2] = pag_part_two++;
d204 18
a221 1
    *ret_cred = cred;
d226 38
a280 1
    size_t done;
d282 2
a283 1
    XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %p\n", pathptr));
d285 1
a285 1
    error = copyinstr(pathptr, path, MAXPATHLEN, &done);
d287 1
a287 2
    XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %s len: %lu error: %d\n", 
		     path, (unsigned long)done, error));
d319 1
d323 1
d325 1
d332 1
a332 1
    error = suser (xfs_proc_to_cred(p), NULL);
d336 9
a344 2
#ifdef __osf__
    VOP_GETATTR(vp, &vattr, p->p_rcred, error);
d346 1
a346 1
    error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
d348 11
d368 3
a370 1
    len = sizeof(fh_args);
d377 1
a377 1
    error = copyout (&fh_args, vice_ioctl->out, len);
d381 2
a382 2

out:
d385 2
a399 2
    int error;
    struct xfs_fh_args fh_args;
a407 9
    if (vice_ioctl->in_size < sizeof(fh_args))
	return EINVAL;

    error = copyin (vice_ioctl->in,
		    &fh_args,
		    sizeof(fh_args));
    if (error)
	return error;

d409 1
a409 3
		       SCARG(&fh_args, fsid),
		       SCARG(&fh_args, fileid),
		       SCARG(&fh_args, gen),
d462 2
a463 7
#ifdef __osf__
    msg.cred.uid = p->p_ruid;
    msg.cred.pag = xfs_get_pag(p->p_rcred);
#else
    msg.cred.uid = p->p_cred->p_ruid;
    msg.cred.pag = xfs_get_pag(p->p_ucred);
#endif
d470 2
a471 2
    else
	error = EINVAL; /* return EINVAL to not confuse applications */
d490 1
a490 1
	error = suser (xfs_proc_to_cred(p), NULL);
d532 1
a532 1
    XFSDEB(XDEBSYS, ("xfs_syscall(%d, %p, %d, %p, %d)\n", 
d534 1
a534 1
		     SCARG(arg, a_pathP),
d536 1
a536 1
		     SCARG(arg, a_paramsP),
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 2
d43 1
a43 1
RCSID("$Id: xfs_syscalls-common.c,v 1.27 1999/03/27 04:17:45 assar Exp $");
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$Id: xfs_syscalls-common.c,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $");
a60 7
/*
 * XXX - horrible kludge. If we're built without HAVE_CONFIG_H we assume that
 *       we're built inside the kernel on OpenBSD.
 */
#ifdef HAVE_CONFIG_H
#include <kafs.h>
#else
a61 1
#endif
a66 4
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
int
xfspioctl(struct proc *proc, void *varg, register_t *return_value)
#else
a68 1
#endif
a69 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
a70 3
#else
    struct sys_xfspioctl_args *arg = (struct sys_xfspioctl_args *) varg;
#endif
d127 1
a127 1
xfs_pag_t
d140 1
a140 1
 * Set the pag in `ret_cred' and return a new cred.
d143 2
a144 2
static int
store_pag (struct ucred **ret_cred, gid_t part1, gid_t part2)
d147 1
d149 1
a149 2
    if (!xfs_is_pag (cred)) {
	int i;
d151 1
d153 1
a153 1
	    return E2BIG;
d157 1
a161 6
    } else {
	cred = crcopy (cred);
    }
    cred->cr_groups[1] = part1;
    cred->cr_groups[2] = part2;
    *ret_cred = cred;
d163 2
a164 2
    return 0;
}
d166 2
a167 12
/*
 * Acquire a new pag in `ret_cred'
 */

int
xfs_setpag_call(struct ucred **ret_cred)
{
    int ret;

    ret = store_pag (ret_cred, pag_part_one, pag_part_two++);
    if (ret)
	return ret;
d173 1
a173 18
    return 0;
}

#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
/*
 * remove a pag
 */

static int
xfs_unpag (struct ucred *cred)
{
    while (xfs_is_pag (cred)) {
	int i;

	for (i = 0; i < cred->cr_ngroups - 2; ++i)
	    cred->cr_groups[i] = cred->cr_groups[i+2];
	cred->cr_ngroups -= 2;
    }
a177 38
 * A wrapper around setgroups that preserves the pag.
 */

int
xfs_setgroups (struct proc *p,
	       void *varg)
{
    struct xfs_setgroups_args *uap = (struct xfs_setgroups_args *)varg;
    struct ucred **cred = &xfs_proc_to_cred(p);

    if (xfs_is_pag (*cred)) {
	gid_t part1, part2;
	int ret;

	if (SCARG(uap,gidsetsize) + 2 > NGROUPS)
	    return EINVAL;

	part1 = (*cred)->cr_groups[1];
	part2 = (*cred)->cr_groups[2];
	ret = (*old_setgroups_func) (p, uap);
	if (ret)
	    return ret;
	return store_pag (cred, part1, part2);
    } else {
	int ret;

	ret = (*old_setgroups_func) (p, uap);
	/* don't support setting a PAG */
	if (xfs_is_pag (*cred)) {
	    xfs_unpag (*cred);
	    return EINVAL;
	}
	return ret;
    }
}
#endif

/*
d195 1
a195 1
    size_t count;
d197 1
a197 2
    XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %lx\n",
		     (unsigned long)pathptr));
d199 1
a199 1
    error = copyinstr((char *) pathptr, path, MAXPATHLEN, &count);
d201 2
a202 1
    XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %s, error: %d\n", path, error));
d225 1
a225 2
 * implement xfs fhget in a way that should be compatible with the native
 * getfh
d229 1
a229 31
getfh_compat (struct proc *p,
	      struct ViceIoctl *vice_ioctl,
	      struct vnode *vp)
{
    /* This is to be same as getfh */
    fhandle_t fh;
    int error;
	
    bzero((caddr_t)&fh, sizeof(fh));
    fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
#if __osf__
    VFS_VPTOFH(vp, &fh.fh_fid, error);
#else
    error = VFS_VPTOFH(vp, &fh.fh_fid);
#endif
    if (error)
	return error;

    if (vice_ioctl->out_size < sizeof(fh))
	return EINVAL;
	
    return copyout((caddr_t)&fh, vice_ioctl->out, sizeof (fh));
}

/*
 * implement xfs fhget by combining (dev, ino, generation)
 */

#ifndef __OpenBSD__
static int
trad_fhget (struct proc *p,
a236 1
    struct xfs_fhandle_t xfs_handle;
d239 6
a244 1
    xfs_vop_getattr(vp, &vattr, xfs_proc_to_cred(p), p, error);
d248 8
d262 1
a262 3
    xfs_handle.len = sizeof(fh_args);
    memcpy (xfs_handle.fhdata, &fh_args, sizeof(fh_args));
    len = sizeof(xfs_handle);
d264 4
a267 2
    if (vice_ioctl->out_size < len)
	return EINVAL;
d269 1
a269 1
    error = copyout (&xfs_handle, vice_ioctl->out, len);
a272 8
    return error;
}
#endif /* !__OpenBSD__ */

/*
 * return file handle of `vp' in vice_ioctl->out
 * vp is vrele:d
 */
a273 26
static int
fhget_call (struct proc *p,
	    struct ViceIoctl *vice_ioctl,
	    struct vnode *vp)
{
    int error;

    XFSDEB(XDEBSYS, ("fhget_call\n"));

    if (vp == NULL)
	return EBADF;

#if defined(__APPLE__) || defined(__osf__)
    error = EINVAL; /* XXX: Leaks vnodes if fhget/fhopen is used */
    goto out;
#endif

    error = xfs_suser (p);
    if (error)
	goto out;

#if (defined(HAVE_GETFH) && defined(HAVE_FHOPEN)) || defined(__osf__)
    error = getfh_compat (p, vice_ioctl, vp);
#else
    error = trad_fhget (p, vice_ioctl, vp);
#endif /* HAVE_GETFH && HAVE_FHOPEN */
d275 1
a275 1
    vrele(vp);
d290 2
d300 8
a307 3
#if defined(__APPLE__) || defined(__osf__)
    return EINVAL; /* XXX: Leaks vnodes if fhget/fhopen is used */
#endif
d310 3
a312 1
		       (struct xfs_fhandle_t *)vice_ioctl->in,
d365 7
a371 2
    msg.cred.uid = xfs_proc_to_euid(p);
    msg.cred.pag = xfs_get_pag(xfs_proc_to_cred(p));
d373 1
a373 1
    error = xfs_message_rpc(0, &msg.header, sizeof(msg), p); /* XXX */
d378 2
a379 2
    if (error == ENODEV)
	error = EINVAL;
d398 1
a398 1
	error = xfs_suser (p);
d440 1
a440 1
    XFSDEB(XDEBSYS, ("xfs_syscall(%d, %lx, %d, %lx, %d)\n", 
d442 1
a442 1
		     (unsigned long)SCARG(arg, a_pathP),
d444 1
a444 1
		     (unsigned long)SCARG(arg, a_paramsP),
d471 1
a471 3
    case VIOC_XFSDEBUG :
	if (vp != NULL)
	    vrele (vp);
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$arla: xfs_syscalls-common.c,v 1.72 2003/01/19 20:53:49 lha Exp $");
d39 1
a39 1
 * NNPFS system calls.
d57 2
a58 2
 * XXX - horrible kludge.  If we are openbsd and not building an lkm,
 *     then use their headerfile.
d60 1
a60 9
#if (defined(__OpenBSD__) || defined(__NetBSD__)) && !defined(_LKM)
#define NNPFS_NOT_LKM 1
#elif defined(__FreeBSD__) && !defined(KLD_MODULE)
#define NNPFS_NOT_LKM 1
#endif

#ifdef NNPFS_NOT_LKM
#include <xfs/xfs_pioctl.h>
#else
a61 20
#endif

int (*old_setgroups_func)(syscall_d_thread_t *p, void *v, register_t *retval);

#if defined(__FreeBSD__) && __FreeBSD_version >= 500026
/*
 * XXX This is wrong
 */
static struct ucred *
xfs_crcopy(struct ucred *cr)
{
    struct ucred *ncr;

    if (crshared(cr)) {
	ncr = crdup(cr);
	crfree(cr);
	return ncr;
    }
    return cr;
}
d63 1
a63 1
#define xfs_crcopy crcopy
a65 1

d70 1
a70 1
#ifdef NNPFS_NOT_LKM
d72 1
a72 1
sys_xfspioctl(syscall_d_thread_t *proc, void *varg, register_t *return_value)
d75 1
a75 1
xfspioctl(syscall_d_thread_t *proc, void *varg, register_t *return_value)
d78 3
a80 1
#ifdef NNPFS_NOT_LKM
a81 2
#else
    struct sys_pioctl_args *arg = (struct sys_pioctl_args *) varg;
d87 1
a87 2
	error = xfs_pioctl_call(syscall_thread_to_thread(proc),
				  varg, return_value);
d90 1
a90 5
#ifdef HAVE_FREEBSD_THREAD
	error = xfs_setpag_call(&xfs_thread_to_cred(proc));
#else
	error = xfs_setpag_call(&xfs_proc_to_cred(syscall_thread_to_thread(proc)));
#endif
d93 1
a93 1
	NNPFSDEB(XDEBSYS, ("Unimplemeted xfspioctl: %d\n",
d108 4
a111 4
#define NNPFS_PAG1_LLIM 33536
#define NNPFS_PAG1_ULIM 34560
#define NNPFS_PAG2_LLIM 32512
#define NNPFS_PAG2_ULIM 48896
d113 2
a114 2
static gid_t pag_part_one = NNPFS_PAG1_LLIM;
static gid_t pag_part_two = NNPFS_PAG2_LLIM;
d126 4
a129 4
	cred->cr_groups[1] >= NNPFS_PAG1_LLIM &&
	cred->cr_groups[1] <= NNPFS_PAG1_ULIM &&
	cred->cr_groups[2] >= NNPFS_PAG2_LLIM &&
	cred->cr_groups[2] <= NNPFS_PAG2_ULIM)
d166 1
a166 1
	cred = xfs_crcopy (cred);
d173 1
a173 1
	cred = xfs_crcopy (cred);
d195 1
a195 1
    if (pag_part_two > NNPFS_PAG2_ULIM) {
d197 1
a197 1
	pag_part_two = NNPFS_PAG2_LLIM;
d202 1
a202 1
#ifndef NNPFS_NOT_LKM
d225 2
a226 3
xfs_setgroups (syscall_d_thread_t *p,
	       void *varg,
	       register_t *retval)
d229 1
a229 5
#ifdef HAVE_FREEBSD_THREAD
    struct ucred **cred = &xfs_thread_to_cred(p);
#else
    struct ucred **cred = &xfs_proc_to_cred(syscall_thread_to_thread(p));
#endif
d240 1
a240 1
	ret = (*old_setgroups_func) (p, uap, retval);
d247 1
a247 1
	ret = (*old_setgroups_func) (p, uap, retval);
d256 1
a256 1
#endif /* !NNPFS_NOT_LKM */
d266 1
a266 1
	     d_thread_t *proc)
d278 1
a278 1
    NNPFSDEB(XDEBSYS, ("xfs_syscall: looking up: %lx\n",
d283 1
a283 1
    NNPFSDEB(XDEBSYS, ("xfs_syscall: looking up: %s, error: %d\n", path, error));
d295 1
a295 1
	NNPFSDEB(XDEBSYS, ("xfs_syscall: error during namei: %d\n", error));
d311 1
a311 1
getfh_compat (d_thread_t *p,
d339 1
d341 1
a341 1
trad_fhget (d_thread_t *p,
a351 3
#ifdef HAVE_FREEBSD_THREAD
    xfs_vop_getattr(vp, &vattr, xfs_thread_to_cred(p), p, error);
#else
a352 1
#endif
d371 1
a371 1
	NNPFSDEB(XDEBSYS, ("fhget_call: copyout failed: %d\n", error));
d375 1
d383 1
a383 1
fhget_call (d_thread_t *p,
d389 1
a389 1
    NNPFSDEB(XDEBSYS, ("fhget_call\n"));
d418 1
a418 1
fhopen_call (d_thread_t *p,
d425 1
a425 1
    NNPFSDEB(XDEBSYS, ("fhopen_call: flags = %d\n", flags));
d447 1
a447 1
remote_pioctl (d_thread_t *p,
d460 1
a460 1
	    NNPFSDEB(XDEBSYS, ("xfs_syscall: file is not in afs\n"));
d471 1
a471 7
    if (vice_ioctl->in_size < 0) {
	printf("xfs: remote pioctl: got a negative data size: opcode: %d",
	       SCARG(arg, a_opcode));
	return EINVAL;
    }

    if (vice_ioctl->in_size > NNPFS_MSG_MAX_DATASIZE) {
d477 4
a480 1
	error = copyin(vice_ioctl->in, msg.msg, vice_ioctl->in_size);
d485 1
a485 2
    msg.header.opcode = NNPFS_MSG_PIOCTL;
    msg.header.size = sizeof(msg);
a489 4
#ifdef HAVE_FREEBSD_THREAD
    msg.cred.uid = xfs_thread_to_euid(p);
    msg.cred.pag = xfs_get_pag(xfs_thread_to_cred(p));
#else
a491 1
#endif
d501 3
a503 13
    if (error == 0 && msg2->header.opcode == NNPFS_MSG_WAKEUP_DATA) {
	int len;

	len = msg2->len;
	if (len > vice_ioctl->out_size)
	    len = vice_ioctl->out_size;
	if (len > NNPFS_MSG_MAX_DATASIZE)
	    len = NNPFS_MSG_MAX_DATASIZE;
	if (len < 0)
	    len = 0;

	error = copyout(msg2->msg, vice_ioctl->out, len);
    }
d508 1
a508 1
xfs_debug (d_thread_t *p,
d551 1
a551 1
xfs_pioctl_call(d_thread_t *proc,
d560 1
a560 1
    NNPFSDEB(XDEBSYS, ("xfs_syscall(%d, %lx, %d, %lx, %d)\n", 
d591 1
a591 1
    case VIOC_NNPFSDEBUG :
d596 1
a596 1
	NNPFSDEB(XDEBSYS, ("a_opcode = %x\n", SCARG(arg, a_opcode)));
@


1.1.4.1
log
@Sync with -current
@
text
@a0 2
/*	$OpenBSD$	*/

d41 1
a41 1
RCSID("$OpenBSD$");
@


1.1.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d43 1
a43 1
RCSID("$Id: xfs_syscalls-common.c,v 1.3 2000/09/11 14:26:53 art Exp $");
a62 7
/*
 * XXX - horrible kludge. If we're built without HAVE_CONFIG_H we assume that
 *       we're built inside the kernel on OpenBSD.
 */
#ifdef HAVE_CONFIG_H
#include <kafs.h>
#else
a63 1
#endif
a68 4
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__)
int
xfspioctl(struct proc *proc, void *varg, register_t *return_value)
#else
a70 1
#endif
a71 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__)
a72 3
#else
    struct sys_xfspioctl_args *arg = (struct sys_xfspioctl_args *) varg;
#endif
d129 1
a129 1
xfs_pag_t
d142 1
a142 1
 * Set the pag in `ret_cred' and return a new cred.
d145 2
a146 2
static int
store_pag (struct ucred **ret_cred, gid_t part1, gid_t part2)
d149 1
d151 1
a151 2
    if (!xfs_is_pag (cred)) {
	int i;
d153 1
d155 1
a155 1
	    return E2BIG;
d159 1
a163 6
    } else {
	cred = crcopy (cred);
    }
    cred->cr_groups[1] = part1;
    cred->cr_groups[2] = part2;
    *ret_cred = cred;
d165 2
a166 2
    return 0;
}
d168 2
a169 12
/*
 * Acquire a new pag in `ret_cred'
 */

int
xfs_setpag_call(struct ucred **ret_cred)
{
    int ret;

    ret = store_pag (ret_cred, pag_part_one, pag_part_two++);
    if (ret)
	return ret;
d175 1
a175 18
    return 0;
}

#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__)
/*
 * remove a pag
 */

static int
xfs_unpag (struct ucred *cred)
{
    while (xfs_is_pag (cred)) {
	int i;

	for (i = 0; i < cred->cr_ngroups - 2; ++i)
	    cred->cr_groups[i] = cred->cr_groups[i+2];
	cred->cr_ngroups -= 2;
    }
a179 38
 * A wrapper around setgroups that preserves the pag.
 */

int
xfs_setgroups (struct proc *p,
	       void *varg)
{
    struct xfs_setgroups_args *uap = (struct xfs_setgroups_args *)varg;
    struct ucred **cred = &xfs_proc_to_cred(p);

    if (xfs_is_pag (*cred)) {
	gid_t part1, part2;
	int ret;

	if (SCARG(uap,gidsetsize) + 2 > NGROUPS)
	    return EINVAL;

	part1 = (*cred)->cr_groups[1];
	part2 = (*cred)->cr_groups[2];
	ret = (*old_setgroups_func) (p, uap);
	if (ret)
	    return ret;
	return store_pag (cred, part1, part2);
    } else {
	int ret;

	ret = (*old_setgroups_func) (p, uap);
	/* don't support setting a PAG */
	if (xfs_is_pag (*cred)) {
	    xfs_unpag (*cred);
	    return EINVAL;
	}
	return ret;
    }
}
#endif

/*
d197 1
d199 1
a199 2
    XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %lx\n",
		     (unsigned long)pathptr));
d201 1
a201 1
    error = copyinstr((char *) pathptr, path, MAXPATHLEN, NULL);
d203 2
a204 1
    XFSDEB(XDEBSYS, ("xfs_syscall: looking up: %s, error: %d\n", path, error));
a235 1
#if !((defined(HAVE_GETFH) && defined(HAVE_FHOPEN)) || defined(__osf__))
a238 1
    struct xfs_fhandle_t xfs_handle;
a239 1
#endif
d246 1
a246 1
    error = xfs_suser (p);
d250 2
a251 9
#if (defined(HAVE_GETFH) && defined(HAVE_FHOPEN)) || defined(__osf__)
    {
	/* This is to be same as getfh */
	fhandle_t fh;
	
	bzero((caddr_t)&fh, sizeof(fh));
	fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
#if __osf__
	VFS_VPTOFH(vp, &fh.fh_fid, error);
d253 1
a253 1
        error = VFS_VPTOFH(vp, &fh.fh_fid);
a254 11
        if (error)
	    return (error);

	if (vice_ioctl->out_size < sizeof(fh))
	    return EINVAL;
	
	error = copyout((caddr_t)&fh, vice_ioctl->out, sizeof (fh));
	return (error);
    }
#else
    xfs_vop_getattr(vp, &vattr, xfs_proc_to_cred(p), p, error);
d264 1
a264 3
    xfs_handle.len = sizeof(fh_args);
    memcpy (xfs_handle.fhdata, &fh_args, sizeof(fh_args));
    len = sizeof(xfs_handle);
d271 1
a271 1
    error = copyout (&xfs_handle, vice_ioctl->out, len);
d275 2
a276 2
    
 out:
a278 2
#endif /* HAVE_GETFH && HAVE_FHOPEN */
    
d292 2
d302 9
d312 3
a314 1
		       (struct xfs_fhandle_t *)vice_ioctl->in,
d367 7
a373 2
    msg.cred.uid = xfs_proc_to_ruid(p);
    msg.cred.pag = xfs_get_pag(xfs_proc_to_cred(p));
d380 2
a381 2
    if (error == ENODEV)
	error = EINVAL;
d400 1
a400 1
	error = xfs_suser (p);
d442 1
a442 1
    XFSDEB(XDEBSYS, ("xfs_syscall(%d, %lx, %d, %lx, %d)\n", 
d444 1
a444 1
		     (unsigned long)SCARG(arg, a_pathP),
d446 1
a446 1
		     (unsigned long)SCARG(arg, a_paramsP),
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$Id$");
d75 1
a75 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
d83 1
a83 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
d207 1
a207 1
#if defined(_LKM) || defined(KLD_MODULE) || defined(__osf__) || defined(__APPLE__)
a280 1
    size_t count;
d285 1
a285 1
    error = copyinstr((char *) pathptr, path, MAXPATHLEN, &count);
d310 1
a310 2
 * implement xfs fhget in a way that should be compatible with the native
 * getfh
d314 1
a314 31
getfh_compat (struct proc *p,
	      struct ViceIoctl *vice_ioctl,
	      struct vnode *vp)
{
    /* This is to be same as getfh */
    fhandle_t fh;
    int error;
	
    bzero((caddr_t)&fh, sizeof(fh));
    fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
#if __osf__
    VFS_VPTOFH(vp, &fh.fh_fid, error);
#else
    error = VFS_VPTOFH(vp, &fh.fh_fid);
#endif
    if (error)
	return error;

    if (vice_ioctl->out_size < sizeof(fh))
	return EINVAL;
	
    return copyout((caddr_t)&fh, vice_ioctl->out, sizeof (fh));
}

/*
 * implement xfs fhget by combining (dev, ino, generation)
 */

#ifndef __OpenBSD__
static int
trad_fhget (struct proc *p,
d319 1
d325 10
d336 22
d360 1
a360 1
	return error;
d372 4
a375 2
    if (vice_ioctl->out_size < len)
	return EINVAL;
d381 3
a384 33
}
#endif /* !__OpenBSD__ */

/*
 * return file handle of `vp' in vice_ioctl->out
 * vp is vrele:d
 */

static int
fhget_call (struct proc *p,
	    struct ViceIoctl *vice_ioctl,
	    struct vnode *vp)
{
    int error;

    XFSDEB(XDEBSYS, ("fhget_call\n"));

    if (vp == NULL)
	return EBADF;

#if defined(__APPLE__) || defined(__osf__)
    error = EINVAL; /* XXX: Leaks vnodes if fhget/fhopen is used */
    goto out;
#endif

    error = xfs_suser (p);
    if (error)
	goto out;

#if (defined(HAVE_GETFH) && defined(HAVE_FHOPEN)) || defined(__osf__)
    error = getfh_compat (p, vice_ioctl, vp);
#else
    error = trad_fhget (p, vice_ioctl, vp);
d386 1
a386 3
out:
    vrele(vp);
    return error;
a407 4
#if defined(__APPLE__) || defined(__osf__)
    return EINVAL; /* XXX: Leaks vnodes if fhget/fhopen is used */
#endif

d462 1
a462 1
    msg.cred.uid = xfs_proc_to_euid(p);
d465 1
a465 1
    error = xfs_message_rpc(0, &msg.header, sizeof(msg), p); /* XXX */
d563 1
a563 3
    case VIOC_XFSDEBUG :
	if (vp != NULL)
	    vrele (vp);
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$arla: xfs_syscalls-common.c,v 1.72 2003/01/19 20:53:49 lha Exp $");
d39 1
a39 1
 * NNPFS system calls.
d57 2
a58 2
 * XXX - horrible kludge.  If we are openbsd and not building an lkm,
 *     then use their headerfile.
d60 1
a60 9
#if (defined(__OpenBSD__) || defined(__NetBSD__)) && !defined(_LKM)
#define NNPFS_NOT_LKM 1
#elif defined(__FreeBSD__) && !defined(KLD_MODULE)
#define NNPFS_NOT_LKM 1
#endif

#ifdef NNPFS_NOT_LKM
#include <xfs/xfs_pioctl.h>
#else
a61 20
#endif

int (*old_setgroups_func)(syscall_d_thread_t *p, void *v, register_t *retval);

#if defined(__FreeBSD__) && __FreeBSD_version >= 500026
/*
 * XXX This is wrong
 */
static struct ucred *
xfs_crcopy(struct ucred *cr)
{
    struct ucred *ncr;

    if (crshared(cr)) {
	ncr = crdup(cr);
	crfree(cr);
	return ncr;
    }
    return cr;
}
d63 1
a63 1
#define xfs_crcopy crcopy
a65 1

d70 1
a70 1
#ifdef NNPFS_NOT_LKM
d72 1
a72 1
sys_xfspioctl(syscall_d_thread_t *proc, void *varg, register_t *return_value)
d75 1
a75 1
xfspioctl(syscall_d_thread_t *proc, void *varg, register_t *return_value)
d78 3
a80 1
#ifdef NNPFS_NOT_LKM
a81 2
#else
    struct sys_pioctl_args *arg = (struct sys_pioctl_args *) varg;
d87 1
a87 2
	error = xfs_pioctl_call(syscall_thread_to_thread(proc),
				  varg, return_value);
d90 1
a90 5
#ifdef HAVE_FREEBSD_THREAD
	error = xfs_setpag_call(&xfs_thread_to_cred(proc));
#else
	error = xfs_setpag_call(&xfs_proc_to_cred(syscall_thread_to_thread(proc)));
#endif
d93 1
a93 1
	NNPFSDEB(XDEBSYS, ("Unimplemeted xfspioctl: %d\n",
d108 4
a111 4
#define NNPFS_PAG1_LLIM 33536
#define NNPFS_PAG1_ULIM 34560
#define NNPFS_PAG2_LLIM 32512
#define NNPFS_PAG2_ULIM 48896
d113 2
a114 2
static gid_t pag_part_one = NNPFS_PAG1_LLIM;
static gid_t pag_part_two = NNPFS_PAG2_LLIM;
d126 4
a129 4
	cred->cr_groups[1] >= NNPFS_PAG1_LLIM &&
	cred->cr_groups[1] <= NNPFS_PAG1_ULIM &&
	cred->cr_groups[2] >= NNPFS_PAG2_LLIM &&
	cred->cr_groups[2] <= NNPFS_PAG2_ULIM)
d166 1
a166 1
	cred = xfs_crcopy (cred);
d173 1
a173 1
	cred = xfs_crcopy (cred);
d195 1
a195 1
    if (pag_part_two > NNPFS_PAG2_ULIM) {
d197 1
a197 1
	pag_part_two = NNPFS_PAG2_LLIM;
d202 1
a202 1
#ifndef NNPFS_NOT_LKM
d225 2
a226 3
xfs_setgroups (syscall_d_thread_t *p,
	       void *varg,
	       register_t *retval)
d229 1
a229 5
#ifdef HAVE_FREEBSD_THREAD
    struct ucred **cred = &xfs_thread_to_cred(p);
#else
    struct ucred **cred = &xfs_proc_to_cred(syscall_thread_to_thread(p));
#endif
d240 1
a240 1
	ret = (*old_setgroups_func) (p, uap, retval);
d247 1
a247 1
	ret = (*old_setgroups_func) (p, uap, retval);
d256 1
a256 1
#endif /* !NNPFS_NOT_LKM */
d266 1
a266 1
	     d_thread_t *proc)
d278 1
a278 1
    NNPFSDEB(XDEBSYS, ("xfs_syscall: looking up: %lx\n",
d283 1
a283 1
    NNPFSDEB(XDEBSYS, ("xfs_syscall: looking up: %s, error: %d\n", path, error));
d295 1
a295 1
	NNPFSDEB(XDEBSYS, ("xfs_syscall: error during namei: %d\n", error));
d311 1
a311 1
getfh_compat (d_thread_t *p,
d341 1
a341 1
trad_fhget (d_thread_t *p,
a351 3
#ifdef HAVE_FREEBSD_THREAD
    xfs_vop_getattr(vp, &vattr, xfs_thread_to_cred(p), p, error);
#else
a352 1
#endif
d371 1
a371 1
	NNPFSDEB(XDEBSYS, ("fhget_call: copyout failed: %d\n", error));
d375 1
a375 1
#endif  /* ! __OpenBSD__ */
d383 1
a383 1
fhget_call (d_thread_t *p,
d389 1
a389 1
    NNPFSDEB(XDEBSYS, ("fhget_call\n"));
d418 1
a418 1
fhopen_call (d_thread_t *p,
d425 1
a425 1
    NNPFSDEB(XDEBSYS, ("fhopen_call: flags = %d\n", flags));
d447 1
a447 1
remote_pioctl (d_thread_t *p,
d460 1
a460 1
	    NNPFSDEB(XDEBSYS, ("xfs_syscall: file is not in afs\n"));
d471 1
a471 7
    if (vice_ioctl->in_size < 0) {
	printf("xfs: remote pioctl: got a negative data size: opcode: %d",
	       SCARG(arg, a_opcode));
	return EINVAL;
    }

    if (vice_ioctl->in_size > NNPFS_MSG_MAX_DATASIZE) {
d477 4
a480 1
	error = copyin(vice_ioctl->in, msg.msg, vice_ioctl->in_size);
d485 1
a485 2
    msg.header.opcode = NNPFS_MSG_PIOCTL;
    msg.header.size = sizeof(msg);
a489 4
#ifdef HAVE_FREEBSD_THREAD
    msg.cred.uid = xfs_thread_to_euid(p);
    msg.cred.pag = xfs_get_pag(xfs_thread_to_cred(p));
#else
a491 1
#endif
d501 3
a503 13
    if (error == 0 && msg2->header.opcode == NNPFS_MSG_WAKEUP_DATA) {
	int len;

	len = msg2->len;
	if (len > vice_ioctl->out_size)
	    len = vice_ioctl->out_size;
	if (len > NNPFS_MSG_MAX_DATASIZE)
	    len = NNPFS_MSG_MAX_DATASIZE;
	if (len < 0)
	    len = 0;

	error = copyout(msg2->msg, vice_ioctl->out, len);
    }
d508 1
a508 1
xfs_debug (d_thread_t *p,
d551 1
a551 1
xfs_pioctl_call(d_thread_t *proc,
d560 1
a560 1
    NNPFSDEB(XDEBSYS, ("xfs_syscall(%d, %lx, %d, %lx, %d)\n", 
d596 1
a596 1
	NNPFSDEB(XDEBSYS, ("a_opcode = %x\n", SCARG(arg, a_opcode)));
@


