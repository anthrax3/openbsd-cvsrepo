head	1.13;
access;
symbols
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	arla-20030805:1.1.1.2
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.7.0.10
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.7.0.8
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2009.06.03.14.45.55;	author jj;	state dead;
branches;
next	1.12;

1.12
date	2007.04.11.16.08.50;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.09.12.43.17;	author pedro;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.12.10.55.09;	author hin;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.12.07.53.47;	author hin;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.07.04.10.32;	author hin;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.11.14.26.52;	author art;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	2000.03.03.00.54.58;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	99.06.03.19.49.38;	author art;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	99.04.30.01.59.00;	author art;	state Exp;
branches;
next	1.3;

1.3
date	98.09.06.01.48.58;	author art;	state Exp;
branches;
next	1.2;

1.2
date	98.08.31.05.13.15;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.08.30.16.47.21;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.03.32.59;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.12.07.43.51;	author hin;	state Exp;
branches;
next	;

1.5.4.1
date	2000.03.24.09.09.55;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.05.14.22.47.52;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2004.02.19.11.01.48;	author niklas;	state Exp;
branches;
next	;

1.7.8.1
date	2002.06.11.03.33.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <xfs/xfs_locl.h>
#include <xfs/xfs_deb.h>
#include <xfs/xfs_fs.h>
#include <xfs/xfs_message.h>
#include <xfs/xfs_msg_locl.h>
#include <xfs/xfs_syscalls.h>
#include <xfs/xfs_vfsops.h>
#include <xfs/xfs_vnodeops.h>
#include <xfs/xfs_dev.h>

RCSID("$arla: xfs_message.c,v 1.84 2003/06/02 18:25:20 lha Exp $");

static void
send_inactive_node(int fd, xfs_handle *handle)
{
    struct xfs_message_inactivenode msg;
    
    msg.header.opcode = NNPFS_MSG_INACTIVENODE;
    msg.handle = *handle;
    msg.flag   = NNPFS_NOREFS | NNPFS_DELETE;
    xfs_message_send(fd, &msg.header, sizeof(msg));
}


int
xfs_message_installroot(int fd,
			struct xfs_message_installroot * message,
			u_int size,
			d_thread_t *p)
{
    int error = 0;

    NNPFSDEB(XDEBMSG, ("xfs_message_installroot (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));

    if (xfs[fd].root != NULL) {
	printf("NNPFS PANIC WARNING! xfs_message_installroot: called again!\n");
	error = EBUSY;
    } else {
	error = new_xfs_node(&xfs[fd], &message->node, &xfs[fd].root, p);
	if (error)
	    return error;
	NNPFS_MAKE_VROOT(xfs[fd].root->vn);
    }
    return error;
}

int
xfs_message_installnode(int fd,
			struct xfs_message_installnode * message,
			u_int size,
			d_thread_t *p)
{
    int error = 0;
    struct xfs_node *n, *dp;

    NNPFSDEB(XDEBMSG, ("xfs_message_installnode (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));

retry:
    dp = xfs_node_find(&xfs[fd].nodehead, &message->parent_handle);
    if (dp) {
	struct vnode *t_vnode = XNODE_TO_VNODE(dp);

	NNPFSDEB(XDEBMSG, ("xfs_message_installnode: t_vnode = %lx\n",
			   (unsigned long)t_vnode));

	if (xfs_do_vget(t_vnode, 0 /* LK_SHARED */, p))
		goto retry;

	error = new_xfs_node(&xfs[fd], &message->node, &n, p);
	if (error) {
	    vrele (t_vnode);
	    return error;
	}

	xfs_dnlc_enter_name(t_vnode,
			    message->name,
			    XNODE_TO_VNODE(n));
	vrele (XNODE_TO_VNODE(n));
	vrele (t_vnode);
    } else {
	printf("NNPFS PANIC WARNING! xfs_message_installnode: no parent\n");
	error = ENOENT;
    }
    NNPFSDEB(XDEBMSG, ("return: xfs_message_installnode: %d\n", error));

    return error;
}

int
xfs_message_installattr(int fd,
			struct xfs_message_installattr * message,
			u_int size,
			d_thread_t *p)
{
    int error = 0;
    struct xfs_node *t;

    NNPFSDEB(XDEBMSG, ("xfs_message_installattr (%d,%d,%d,%d) \n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));

    t = xfs_node_find(&xfs[fd].nodehead, &message->node.handle);
    if (t != 0) {
	t->tokens = message->node.tokens;
	if ((t->tokens & NNPFS_DATA_MASK) && DATA_FROM_XNODE(t) == NULL) {
	    printf ("xfs_message_installattr: tokens and no data\n");
	    t->tokens &= ~NNPFS_DATA_MASK;
	}
	xfs_attr2vattr(&message->node.attr, &t->attr, 0);
	if ((t->flags & NNPFS_VMOPEN) == 0)
	    xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
	bcopy(message->node.id, t->id, sizeof(t->id));
	bcopy(message->node.rights, t->rights, sizeof(t->rights));
	t->anonrights = message->node.anonrights;
    } else {
	NNPFSDEB(XDEBMSG, ("xfs_message_installattr: no such node\n"));
    }
    
    return error;
}

int
xfs_message_installdata(int fd,
			struct xfs_message_installdata * message,
			u_int size,
			d_thread_t *p)
{
    struct xfs_node *t;
    int error = 0;

    NNPFSDEB(XDEBMSG, ("xfs_message_installdata (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));

retry:
    t = xfs_node_find(&xfs[fd].nodehead, &message->node.handle);
    if (t != NULL) {
	struct xfs_fhandle_t *fh = 
	    (struct xfs_fhandle_t *)&message->cache_handle;
	struct vnode *t_vnode = XNODE_TO_VNODE(t);
	struct vnode *vp;

	message->cache_name[sizeof(message->cache_name)-1] = '\0';
	NNPFSDEB(XDEBMSG, ("cache_name = '%s'\n", message->cache_name));

	if (xfs_do_vget(t_vnode, 0 /* LK_SHARED */, p))
		goto retry;

	if (message->flag & NNPFS_ID_HANDLE_VALID) {
	    error = xfs_fhlookup (p, fh, &vp);
	} else {
	    error = EINVAL;
	}
	if (error != 0) {
#ifdef __osf__
	    struct nameidata *ndp = &u.u_nd;
#else
	    struct nameidata nd;
	    struct nameidata *ndp = &nd;
#endif

	    NNPFSDEB(XDEBMSG,
		   ("xfs_message_installdata: fhlookup failed: %d, "
		    "opening by name\n", error));

	    NDINIT(ndp, LOOKUP, FOLLOW | NNPFS_LOCKLEAF, UIO_SYSSPACE,
		   message->cache_name, p);
	    error = namei(ndp);
	    vp = ndp->ni_vp;
	}

	if (error == 0) {
#ifndef __osf__
	    xfs_vfs_unlock(vp, p);
#endif
	    if (DATA_FROM_XNODE(t))
		vrele(DATA_FROM_XNODE(t));
	    DATA_FROM_XNODE(t) = vp;

	    NNPFSDEB(XDEBMSG, ("xfs_message_installdata: t = %lx;"
			     " tokens = %x\n",
			     (unsigned long)t, message->node.tokens));

	    t->tokens = message->node.tokens;
	    xfs_attr2vattr(&message->node.attr, &t->attr, 1);
	    if ((t->flags & NNPFS_VMOPEN) == 0)
		xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
	    if (XNODE_TO_VNODE(t)->v_type == VDIR
		&& (message->flag & NNPFS_ID_INVALID_DNLC))
		xfs_dnlc_purge (XNODE_TO_VNODE(t));
	    bcopy(message->node.id, t->id, sizeof(t->id));
	    bcopy(message->node.rights, t->rights, sizeof(t->rights));
	    t->anonrights = message->node.anonrights;
	    t->offset = message->offset;
#if 0
	    if (message->flag & NNPFS_ID_AFSDIR)
		t->flags |= NNPFS_AFSDIR;
#endif
	} else {
	    printf("NNPFS PANIC WARNING! xfs_message_installdata failed!\n");
	    printf("Reason: lookup failed on cache file '%s', error = %d\n",
		   message->cache_name, error);
	}
	vrele (t_vnode);
    } else {
	printf("NNPFS PANIC WARNING! xfs_message_installdata failed\n");
	printf("Reason: No node to install the data into!\n");
	error = ENOENT;
    }

    return error;
}

#ifdef __osf__
#define xfs_writecount v_wrcnt
#else
#define xfs_writecount v_writecount
#endif

int
xfs_message_invalidnode(int fd,
			struct xfs_message_invalidnode * message,
			u_int size,
			d_thread_t *p)
{
    int error = 0;
    struct xfs_node *t;

    NNPFSDEB(XDEBMSG, ("xfs_message_invalidnode (%d,%d,%d,%d)\n",
		     message->handle.a,
		     message->handle.b,
		     message->handle.c,
		     message->handle.d));

#ifdef __APPLE__
 retry:
#endif
    t = xfs_node_find(&xfs[fd].nodehead, &message->handle);
    if (t != 0) {
	struct vnode *vp = XNODE_TO_VNODE(t);

        /* If open for writing, return immediately. Last close:er wins! */
	if (vp->v_usecount >= 0 && vp->xfs_writecount >= 1)
            return 0;

#ifdef __FreeBSD__
	{
	    vm_object_t obj = vp->v_object;

	    if (obj != NULL
		&& (obj->ref_count != 0
#ifdef OBJ_MIGHTBEDIRTY
		|| (obj->flags & OBJ_MIGHTBEDIRTY) != 0
#endif
		    ))
		return 0;

	}
#endif /* __FreeBSD__ */

	/* If node is in use, mark as stale */
	if (vp->v_usecount > 0 && vp->v_type != VDIR) {
#ifdef __APPLE__
	    if (vget(vp, 0, p))
		goto retry;

	    if (UBCISVALID(vp) && !ubc_isinuse(vp, 1)) {
		ubc_setsize(vp, 0);
		vrele(vp);
	    } else {
		vrele(vp);
		t->flags |= NNPFS_STALE;
		return 0;
	    }
#else
	    t->flags |= NNPFS_STALE;
	    return 0;
#endif
	}

	if (DATA_FROM_XNODE(t)) {
	    vrele(DATA_FROM_XNODE(t));
	    DATA_FROM_XNODE(t) = (struct vnode *) 0;
	}
	NNPFS_TOKEN_CLEAR(t, ~0,
			NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
			NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
	/* Dir changed, must invalidate DNLC. */
	if (vp->v_type == VDIR)
	    xfs_dnlc_purge(vp);
	if (vp->v_usecount == 0) {
#ifndef __osf__
	    NNPFSDEB(XDEBVNOPS, ("xfs_message_invalidnode: vrecycle\n"));
	    vrecycle(vp, p);
#else
	    /* XXX */
#endif /* __osf__ */
	}
    } else {
	NNPFSDEB(XDEBMSG, ("xfs_message_invalidnode: no such node\n"));
	send_inactive_node(fd, &message->handle);
	error = ENOENT;
    }

    return error;
}

int
xfs_message_updatefid(int fd,
		      struct xfs_message_updatefid * message,
		      u_int size,
		      d_thread_t *p)
{
    int error = 0;

    NNPFSDEB(XDEBMSG, ("xfs_message_updatefid (%d,%d,%d,%d) (%d,%d,%d,%d)\n",
		       message->old_handle.a,
		       message->old_handle.b,
		       message->old_handle.c,
		       message->old_handle.d,
		       message->new_handle.a,
		       message->new_handle.b,
		       message->new_handle.c,
		       message->new_handle.d));

    error = xfs_update_handle(&xfs[fd].nodehead, 
				&message->old_handle,
				&message->new_handle);
    if (error)
	printf ("NNPFS PANIC WARNING! xfs_message_updatefid: %d\n", error);
    return error;
}

#if __osf__

/*
 * Try to clean out nodes for the userland daemon
 */

static void
gc_vnode (struct vnode *vp,
	  d_thread_t *p)
{
    /* This node is on the freelist */
    if (vp->v_usecount <= 0) {
	
	/*  DIAGNOSTIC */
	if (vp->v_usecount < 0) {
		    vprint("vrele: bad ref count", vp);
		    panic("vrele: ref cnt");
	}
	
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
	
	vgone(vp, VX_NOSLEEP, NULL);
    } else {
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
    }

}


#else /* !__osf__ */

/*
 * Try to clean out nodes for the userland daemon
 */

static void
gc_vnode (struct vnode *vp,
	  d_thread_t *p)
{
#ifdef HAVE_SYS_MUTEX_H
    mtx_lock(&vp->v_interlock);
#else
    simple_lock(&vp->v_interlock);
#endif
    
    /* This node is on the freelist */
    if (vp->v_usecount <= 0) {
#if __FreeBSD__
	vm_object_t obj;

	obj = vp->v_object;

	if (obj != NULL
	    && (obj->ref_count != 0
#ifdef OBJ_MIGHTBEDIRTY
		|| (obj->flags & OBJ_MIGHTBEDIRTY) != 0
#endif
		)) {
#ifdef HAVE_SYS_MUTEX_H
	    mtx_unlock(&vp->v_interlock);
#else
	    simple_unlock (&vp->v_interlock);
#endif
	    return;
	}
#endif /* __FreeBSD__ */

#ifdef DIAGNOSTIC
	if (vp->v_usecount < 0 || vp->v_writecount != 0) {
		    vprint("vrele: bad ref count", vp);
		    panic("vrele: ref cnt");
	}
#endif /* DIAGNOSTIC */
	
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
	
#ifdef HAVE_KERNEL_VGONEL
	vgonel (vp, p);
#else
#ifdef HAVE_SYS_MUTEX_H
	mtx_unlock(&vp->v_interlock);
#else
	simple_unlock(&vp->v_interlock); 
#endif
	vgone (vp);
#endif

    } else {
#ifdef HAVE_SYS_MUTEX_H
	mtx_unlock(&vp->v_interlock);
#else
	simple_unlock(&vp->v_interlock);
#endif
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
    }

}

#endif

int
xfs_message_gc_nodes(int fd,
		       struct xfs_message_gc_nodes *message,
		       u_int size,
		       d_thread_t *p)
{
    struct xfs_node *node;
    int i;

    NNPFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    for (i = 0; i < message->len; i++) {
	node = xfs_node_find (&xfs[fd].nodehead, &message->handle[i]);
	if (node)
	    gc_vnode(XNODE_TO_VNODE(node), p);
	else {
	    NNPFSDEB(XDEBMSG, ("xfs_message_gc_nodes: no such node\n"));
	    send_inactive_node(fd, &message->handle[i]);
	}
    }

    return 0;
}


/*
 * Probe what version of xfs this support
 */

int
xfs_message_version(int fd,
		    struct xfs_message_version *message,
		    u_int size,
		    d_thread_t *p)
{
    struct xfs_message_wakeup msg;
    int ret;

    ret = NNPFS_VERSION;

    msg.header.opcode = NNPFS_MSG_WAKEUP;
    msg.sleepers_sequence_num = message->header.sequence_num;
    msg.error = ret;

    return xfs_message_send(fd, 
			      (struct xfs_message_header *) &msg, sizeof(msg));
}
@


1.12
log
@Remove the simplelock argument from vrecycle();

ok pedro@@, sturm@@
@
text
@@


1.11
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d339 1
a339 1
	    vrecycle(vp, 0, p);
@


1.10
log
@Fix include stuff, unused variables and statics and other small things needed
to compile in our tree.
@
text
@d445 2
a446 2
	
	/*  DIAGNOSTIC */
d451 1
@


1.9
log
@Merge
@
text
@a359 1
    struct xfs_node *t;
@


1.8
log
@merge
@
text
@d44 13
a56 1
RCSID("$Id: xfs_message.c,v 1.1.1.1 2002/06/07 03:32:59 hin Exp $");
d62 1
a62 1
			struct proc *p)
d66 1
a66 1
    XFSDEB(XDEBMSG, ("xfs_message_installroot (%d,%d,%d,%d)\n",
d73 1
a73 1
	printf("XFS PANIC WARNING! xfs_message_installroot: called again!\n");
d79 1
a79 1
	xfs[fd].root->vn->v_flag |= VROOT;
d88 1
a88 1
			struct proc *p)
d93 1
a93 1
    XFSDEB(XDEBMSG, ("xfs_message_installnode (%d,%d,%d,%d)\n",
d100 1
a100 1
    dp = xfs_node_find(&xfs[fd], &message->parent_handle);
d104 3
d122 1
a122 1
	printf("XFS PANIC WARNING! xfs_message_installnode: no parent\n");
d125 1
a125 1
    XFSDEB(XDEBMSG, ("return: xfs_message_installnode: %d\n", error));
d134 1
a134 1
			struct proc *p)
d139 1
a139 1
    XFSDEB(XDEBMSG, ("xfs_message_installattr (%d,%d,%d,%d) \n",
d145 1
a145 1
    t = xfs_node_find(&xfs[fd], &message->node.handle);
d148 1
a148 1
	if ((t->tokens & XFS_DATA_MASK) && DATA_FROM_XNODE(t) == NULL) {
d150 1
a150 1
	    t->tokens &= ~XFS_DATA_MASK;
d153 2
a154 1
	xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d159 1
a159 1
	XFSDEB(XDEBMSG, ("xfs_message_installattr: no such node\n"));
d169 1
a169 1
			struct proc *p)
d174 1
a174 1
    XFSDEB(XDEBMSG, ("xfs_message_installdata (%d,%d,%d,%d)\n",
d181 1
a181 1
    t = xfs_node_find(&xfs[fd], &message->node.handle);
d183 3
a185 1
	struct xfs_fhandle_t *fh = (struct xfs_fhandle_t *)&message->cache_handle;
a186 1
	struct vnode *t_vnode = XNODE_TO_VNODE(t);
d189 1
a189 1
	XFSDEB(XDEBMSG, ("cache_name = '%s'\n", message->cache_name));
d194 1
a194 1
	if (message->flag & XFS_ID_HANDLE_VALID) {
d207 1
a207 1
	    XFSDEB(XDEBMSG,
d211 1
a211 1
	    NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE,
d225 1
a225 1
	    XFSDEB(XDEBMSG, ("xfs_message_installdata: t = %lx;"
d231 2
a232 1
	    xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d234 2
a235 2
		&& (message->flag & XFS_ID_INVALID_DNLC))
		cache_purge (XNODE_TO_VNODE(t));
d239 1
d241 2
a242 2
	    if (message->flag & XFS_ID_AFSDIR)
		t->flags |= XFS_AFSDIR;
d245 1
a245 1
	    printf("XFS PANIC WARNING! xfs_message_installdata failed!\n");
d251 1
a251 1
	printf("XFS PANIC WARNING! xfs_message_installdata failed\n");
d269 1
a269 1
			struct proc *p)
d274 1
a274 1
    XFSDEB(XDEBMSG, ("xfs_message_invalidnode (%d,%d,%d,%d)\n",
d280 4
a283 1
    t = xfs_node_find(&xfs[fd], &message->handle);
d309 4
a312 1
	    if (UBCISVALID(vp) && !ubc_isinuse(vp, 0)) {
d314 1
d316 2
a317 1
		t->flags |= XFS_STALE;
d321 1
a321 1
	    t->flags |= XFS_STALE;
d330 3
a332 3
	XFS_TOKEN_CLEAR(t, ~0,
			XFS_OPEN_MASK | XFS_ATTR_MASK |
			XFS_DATA_MASK | XFS_LOCK_MASK);
a336 1
	    XFSDEB(XDEBVNOPS, ("xfs_message_invalidnode: vrecycle\n"));
d338 1
d340 3
a342 1
#endif
d345 2
d357 1
a357 1
		      struct proc *p)
d362 15
a376 13
    XFSDEB(XDEBMSG, ("xfs_message_updatefid (%d,%d,%d,%d)\n",
		     message->old_handle.a,
		     message->old_handle.b,
		     message->old_handle.c,
		     message->old_handle.d));

    t = xfs_node_find (&xfs[fd], &message->old_handle);
    if (t != NULL) {
	t->handle = message->new_handle;
    } else {
	printf ("XFS PANIC WARNING! xfs_message_updatefid: no node!\n");
	error = ENOENT;
    }
d388 1
a388 1
	  struct proc *p)
d399 1
a399 1
	XFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
d403 1
a403 1
	XFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
a407 34
int
xfs_message_gc_nodes(int fd,
		     struct xfs_message_gc_nodes *message,
		     u_int size,
		     struct proc *p)
{
    XFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    if (message->len == 0) {
	struct vnode *vp;

	/* XXX see comment in xfs_node_find */

	for(vp = XFS_TO_VFS(&xfs[fd])->m_mounth;
	    vp != NULL; 
	    vp = vp->v_mountf) {
	    gc_vnode (vp, p);
	}

    } else {
	struct xfs_node *t;
	int i;

	for (i = 0; i < message->len; i++) {
	    t = xfs_node_find (&xfs[fd], &message->handle[i]);
	    if (t == NULL)
		continue;

	    gc_vnode(XNODE_TO_VNODE(t), p);
	}
    }

    return 0;
}
d417 1
a417 1
	  struct proc *p)
d419 3
d423 1
d438 3
d442 1
d449 2
a450 2
		    vprint("Pjäxomatic-4700: bad ref count", vp);
		    panic("Pjäxomatic-4650: ref cnt");
d453 1
a453 1
	XFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
d455 1
a455 1
#ifdef HAVE_KERNEL_FUNC_VGONEL
d458 3
d462 1
d467 3
d471 2
a472 1
	XFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
d477 2
d481 16
a496 40
		     struct xfs_message_gc_nodes *message,
		     u_int size,
		     struct proc *p)
{
    XFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    if (message->len == 0) {
	struct vnode *vp, *next;

	/* XXX see comment in xfs_node_find */
	/* XXXSMP do gone[l] need to get mntvnode_slock ? */

/* FreeBSD 4.5 and above did rename mnt_vnodelist to mnt_nvnodelist */
#ifdef HAVE_STRUCT_MOUNT_MNT_NVNODELIST
	for(vp = TAILQ_FIRST(&XFS_TO_VFS(&xfs[fd])->mnt_nvnodelist);
	    vp != NULL; 
	    vp = next) {

	    next = TAILQ_NEXT(vp, v_nmntvnodes);
	    gc_vnode (vp, p);
	}
#else
	for(vp = XFS_TO_VFS(&xfs[fd])->mnt_vnodelist.lh_first;
	    vp != NULL; 
	    vp = next) {

	    next = vp->v_mntvnodes.le_next;
	    gc_vnode (vp, p);
	}
#endif
    } else {
	struct xfs_node *t;
	int i;

	for (i = 0; i < message->len; i++) {
	    t = xfs_node_find (&xfs[fd], &message->handle[i]);
	    if (t == NULL)
		continue;

	    gc_vnode(XNODE_TO_VNODE(t), p);
a503 2
#endif

d512 1
a512 1
		    struct proc *p)
d517 1
a517 1
    ret = XFS_VERSION;
d519 1
a519 1
    msg.header.opcode = XFS_MSG_WAKEUP;
d523 2
a524 1
    return xfs_message_send(fd, (struct xfs_message_header *) &msg, sizeof(msg));
@


1.7
log
@New xfs from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 *
 * 4. Neither the name of the Institute nor the names of its contributors
d44 1
a44 1
RCSID("$Id: xfs_message.c,v 1.58 2000/07/19 08:35:55 art Exp $");
d137 1
a137 1
	xfs_attr2vattr(&message->node.attr, &t->attr);
d145 1
a145 1

d171 1
d177 5
a181 1
	error = xfs_fhlookup (p, fh, &vp);
d213 1
a213 1
	    xfs_attr2vattr(&message->node.attr, &t->attr);
d284 15
d311 1
d313 1
a315 3
#if 0
	printf("XFS PANIC WARNING! xfs_message_invalidnode: no node!\n");
#endif
d442 2
a443 2
		    vprint("vrele: bad ref count", vp);
		    panic("vrele: ref cnt");
d476 10
d493 1
@


1.7.8.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d49 1
a49 1
RCSID("$Id: xfs_message.c,v 1.7 2000/09/11 14:26:52 art Exp $");
d142 1
a142 1
	xfs_attr2vattr(&message->node.attr, &t->attr, 0);
d150 1
a150 1
    
a175 1
	message->cache_name[sizeof(message->cache_name)-1] = '\0';
d181 1
a181 5
	if (message->flag & XFS_ID_HANDLE_VALID) {
	    error = xfs_fhlookup (p, fh, &vp);
	} else {
	    error = EINVAL;
	}
d213 1
a213 1
	    xfs_attr2vattr(&message->node.attr, &t->attr, 1);
a283 15
	/* If node is in use, mark as stale */
	if (vp->v_usecount > 0 && vp->v_type != VDIR) {
#ifdef __APPLE__
	    if (UBCISVALID(vp) && !ubc_isinuse(vp, 0)) {
		ubc_setsize(vp, 0);
	    } else {
		t->flags |= XFS_STALE;
		return 0;
	    }
#else
	    t->flags |= XFS_STALE;
	    return 0;
#endif
	}

a295 1
#ifndef __osf__
a296 1
#endif
d299 3
d428 2
a429 2
		    vprint("Pjäxomatic-4700: bad ref count", vp);
		    panic("Pjäxomatic-4650: ref cnt");
a461 10
/* FreeBSD 4.5 and above did rename mnt_vnodelist to mnt_nvnodelist */
#ifdef HAVE_STRUCT_MOUNT_MNT_NVNODELIST
	for(vp = TAILQ_FIRST(&XFS_TO_VFS(&xfs[fd])->mnt_nvnodelist);
	    vp != NULL; 
	    vp = next) {

	    next = TAILQ_NEXT(vp, v_nmntvnodes);
	    gc_vnode (vp, p);
	}
#else
a468 1
#endif
@


1.6
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d47 1
d49 1
a49 1
RCSID("$OpenBSD: xfs_message.c,v 1.5 1999/06/03 19:49:38 art Exp $");
d59 5
a63 1
    XFSDEB(XDEBMSG, ("xfs_message_installroot\n"));
d86 5
a90 1
    XFSDEB(XDEBMSG, ("xfs_message_installnode\n"));
d92 1
d97 2
a98 1
	xfs_do_vget (t_vnode, LK_INTERLOCK|LK_SHARED, p);
d109 2
a110 2
	vrele(XNODE_TO_VNODE(n));
	vput (t_vnode);
d129 6
d138 4
d143 1
a143 7
#ifdef UVM
	uvm_vnp_setsize(XNODE_TO_VNODE(t), t->attr.va_size);
#else
#ifdef HAVE_KERNEL_VNODE_PAGER_SETSIZE
	vnode_pager_setsize(XNODE_TO_VNODE(t), t->attr.va_size);
#endif
#endif
d148 1
a148 2
	printf("XFS PANIC WARNING! xfs_message_installattr: no node!\n");
	error = ENOENT;
d163 5
a167 1
    XFSDEB(XDEBMSG, ("xfs_message_installdata\n"));
d169 1
a170 1

d172 1
a172 1
	struct xfs_fh_args *fh_args = (struct xfs_fh_args *)&message->cache_handle;
a176 11
	XFSDEB(XDEBMSG, ("fileno = %ld, gen = %ld\n", 
			 SCARG(fh_args, fileid),
			 SCARG(fh_args, gen)));

	xfs_do_vget (t_vnode, LK_INTERLOCK|LK_SHARED, p);

	error = xfs_fhlookup (p,
			      SCARG(fh_args,fsid),
			      SCARG(fh_args,fileid),
			      SCARG(fh_args,gen),
			      &vp);
d178 4
d201 1
d203 1
d208 1
a208 1
	    XFSDEB(XDEBMSG, ("xfs_message_installdata: t = %p;"
d210 1
a210 1
			     t, message->node.tokens));
d214 1
a214 7
#ifdef UVM
	    uvm_vnp_setsize(XNODE_TO_VNODE(t), t->attr.va_size);
#else
#ifdef HAVE_KERNEL_VNODE_PAGER_SETSIZE
	    vnode_pager_setsize(XNODE_TO_VNODE(t), t->attr.va_size);
#endif
#endif
d216 1
a216 1
		&& (message->flag & XFS_INVALID_DNLC))
d221 4
d230 1
a230 1
	vput (t_vnode);
d240 6
d255 5
a259 1
    XFSDEB(XDEBMSG, ("xfs_message_invalidnode\n"));
d263 21
a283 1
	/* XXX Really need to put back dirty data first. */
d291 7
a297 1
	cache_purge(XNODE_TO_VNODE(t));
d299 1
d301 1
d317 6
a322 1
    XFSDEB(XDEBMSG, ("xfs_message_updatefid\n"));
d331 177
@


1.5
log
@use uvm_vnp_setsize when uvm (workaround)
@
text
@d1 2
d50 1
a50 1
RCSID("$Id: xfs_message.c,v 1.4 1999/04/30 01:59:00 art Exp $");
@


1.5.4.1
log
@Sync with -current
@
text
@a0 2
/*	$OpenBSD$	*/

d48 1
a48 1
RCSID("$OpenBSD$");
@


1.5.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
a48 1
#include <xfs/xfs_dev.h>
d50 1
a50 1
RCSID("$Id: xfs_message.c,v 1.7 2000/09/11 14:26:52 art Exp $");
d60 1
a60 5
    XFSDEB(XDEBMSG, ("xfs_message_installroot (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));
d83 1
a83 5
    XFSDEB(XDEBMSG, ("xfs_message_installnode (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));
a84 1
retry:
d89 1
a89 2
	if (xfs_do_vget(t_vnode, 0 /* LK_SHARED */, p))
		goto retry;
d100 2
a101 2
	vrele (XNODE_TO_VNODE(n));
	vrele (t_vnode);
a119 6
    XFSDEB(XDEBMSG, ("xfs_message_installattr (%d,%d,%d,%d) \n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));

a122 4
	if ((t->tokens & XFS_DATA_MASK) && DATA_FROM_XNODE(t) == NULL) {
	    printf ("xfs_message_installattr: tokens and no data\n");
	    t->tokens &= ~XFS_DATA_MASK;
	}
d124 7
a130 1
	xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d135 2
a136 1
	XFSDEB(XDEBMSG, ("xfs_message_installattr: no such node\n"));
d151 1
a151 5
    XFSDEB(XDEBMSG, ("xfs_message_installdata (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));
a152 1
retry:
d154 1
d156 1
a156 1
	struct xfs_fhandle_t *fh = (struct xfs_fhandle_t *)&message->cache_handle;
d161 11
a172 4
	if (xfs_do_vget(t_vnode, 0 /* LK_SHARED */, p))
		goto retry;

	error = xfs_fhlookup (p, fh, &vp);
a191 1
#ifndef __osf__
a192 1
#endif
d197 1
a197 1
	    XFSDEB(XDEBMSG, ("xfs_message_installdata: t = %lx;"
d199 1
a199 1
			     (unsigned long)t, message->node.tokens));
d203 7
a209 1
	    xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d211 1
a211 1
		&& (message->flag & XFS_ID_INVALID_DNLC))
a215 4
#if 0
	    if (message->flag & XFS_ID_AFSDIR)
		t->flags |= XFS_AFSDIR;
#endif
d221 1
a221 1
	vrele (t_vnode);
a230 6
#ifdef __osf__
#define xfs_writecount v_wrcnt
#else
#define xfs_writecount v_writecount
#endif

d240 1
a240 5
    XFSDEB(XDEBMSG, ("xfs_message_invalidnode (%d,%d,%d,%d)\n",
		     message->handle.a,
		     message->handle.b,
		     message->handle.c,
		     message->handle.d));
d244 1
a244 21
	struct vnode *vp = XNODE_TO_VNODE(t);

        /* If open for writing, return immediately. Last close:er wins! */
	if (vp->v_usecount >= 0 && vp->xfs_writecount >= 1)
            return 0;

#ifdef __FreeBSD__
	{
	    vm_object_t obj = vp->v_object;

	    if (obj != NULL
		&& (obj->ref_count != 0
#ifdef OBJ_MIGHTBEDIRTY
		|| (obj->flags & OBJ_MIGHTBEDIRTY) != 0
#endif
		    ))
		return 0;

	}
#endif /* __FreeBSD__ */

d252 1
a252 7
	/* Dir changed, must invalidate DNLC. */
	if (vp->v_type == VDIR)
	    xfs_dnlc_purge(vp);
	if (vp->v_usecount == 0) {
	    XFSDEB(XDEBVNOPS, ("xfs_message_invalidnode: vrecycle\n"));
	    vrecycle(vp, 0, p);
	}
a253 1
#if 0
a254 1
#endif
d270 1
a270 6
    XFSDEB(XDEBMSG, ("xfs_message_updatefid (%d,%d,%d,%d)\n",
		     message->old_handle.a,
		     message->old_handle.b,
		     message->old_handle.c,
		     message->old_handle.d));

a278 177
}

#if __osf__

/*
 * Try to clean out nodes for the userland daemon
 */

static void
gc_vnode (struct vnode *vp,
	  struct proc *p)
{
    /* This node is on the freelist */
    if (vp->v_usecount <= 0) {
	
	/*  DIAGNOSTIC */
	if (vp->v_usecount < 0) {
		    vprint("vrele: bad ref count", vp);
		    panic("vrele: ref cnt");
	}
	
	XFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
	
	vgone(vp, VX_NOSLEEP, NULL);
    } else {
	XFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
    }

}

int
xfs_message_gc_nodes(int fd,
		     struct xfs_message_gc_nodes *message,
		     u_int size,
		     struct proc *p)
{
    XFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    if (message->len == 0) {
	struct vnode *vp;

	/* XXX see comment in xfs_node_find */

	for(vp = XFS_TO_VFS(&xfs[fd])->m_mounth;
	    vp != NULL; 
	    vp = vp->v_mountf) {
	    gc_vnode (vp, p);
	}

    } else {
	struct xfs_node *t;
	int i;

	for (i = 0; i < message->len; i++) {
	    t = xfs_node_find (&xfs[fd], &message->handle[i]);
	    if (t == NULL)
		continue;

	    gc_vnode(XNODE_TO_VNODE(t), p);
	}
    }

    return 0;
}

#else /* !__osf__ */

/*
 * Try to clean out nodes for the userland daemon
 */

static void
gc_vnode (struct vnode *vp,
	  struct proc *p)
{
    simple_lock(&vp->v_interlock);
    
    /* This node is on the freelist */
    if (vp->v_usecount <= 0) {
#if __FreeBSD__
	vm_object_t obj;

	obj = vp->v_object;

	if (obj != NULL
	    && (obj->ref_count != 0
#ifdef OBJ_MIGHTBEDIRTY
		|| (obj->flags & OBJ_MIGHTBEDIRTY) != 0
#endif
		)) {
	    simple_unlock (&vp->v_interlock);
	    return;
	}
#endif /* __FreeBSD__ */
	
	/*  DIAGNOSTIC */
	if (vp->v_usecount < 0 || vp->v_writecount != 0) {
		    vprint("vrele: bad ref count", vp);
		    panic("vrele: ref cnt");
	}
	
	XFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
	
#ifdef HAVE_KERNEL_FUNC_VGONEL
	vgonel (vp, p);
#else
	simple_unlock(&vp->v_interlock); 
	vgone (vp);
#endif

    } else {
	simple_unlock(&vp->v_interlock);
	XFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
    }

}

int
xfs_message_gc_nodes(int fd,
		     struct xfs_message_gc_nodes *message,
		     u_int size,
		     struct proc *p)
{
    XFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    if (message->len == 0) {
	struct vnode *vp, *next;

	/* XXX see comment in xfs_node_find */
	/* XXXSMP do gone[l] need to get mntvnode_slock ? */

	for(vp = XFS_TO_VFS(&xfs[fd])->mnt_vnodelist.lh_first;
	    vp != NULL; 
	    vp = next) {

	    next = vp->v_mntvnodes.le_next;
	    gc_vnode (vp, p);
	}
    } else {
	struct xfs_node *t;
	int i;

	for (i = 0; i < message->len; i++) {
	    t = xfs_node_find (&xfs[fd], &message->handle[i]);
	    if (t == NULL)
		continue;

	    gc_vnode(XNODE_TO_VNODE(t), p);
	}
    }

    return 0;
}


#endif

/*
 * Probe what version of xfs this support
 */

int
xfs_message_version(int fd,
		    struct xfs_message_version *message,
		    u_int size,
		    struct proc *p)
{
    struct xfs_message_wakeup msg;
    int ret;

    ret = XFS_VERSION;

    msg.header.opcode = XFS_MSG_WAKEUP;
    msg.sleepers_sequence_num = message->header.sequence_num;
    msg.error = ret;

    return xfs_message_send(fd, (struct xfs_message_header *) &msg, sizeof(msg));
@


1.5.4.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d49 1
a49 1
RCSID("$Id$");
d142 1
a142 1
	xfs_attr2vattr(&message->node.attr, &t->attr, 0);
d150 1
a150 1
    
a175 1
	message->cache_name[sizeof(message->cache_name)-1] = '\0';
d181 1
a181 5
	if (message->flag & XFS_ID_HANDLE_VALID) {
	    error = xfs_fhlookup (p, fh, &vp);
	} else {
	    error = EINVAL;
	}
d213 1
a213 1
	    xfs_attr2vattr(&message->node.attr, &t->attr, 1);
a283 15
	/* If node is in use, mark as stale */
	if (vp->v_usecount > 0 && vp->v_type != VDIR) {
#ifdef __APPLE__
	    if (UBCISVALID(vp) && !ubc_isinuse(vp, 0)) {
		ubc_setsize(vp, 0);
	    } else {
		t->flags |= XFS_STALE;
		return 0;
	    }
#else
	    t->flags |= XFS_STALE;
	    return 0;
#endif
	}

a295 1
#ifndef __osf__
a296 1
#endif
d299 3
d428 2
a429 2
		    vprint("Pjäxomatic-4700: bad ref count", vp);
		    panic("Pjäxomatic-4650: ref cnt");
a461 10
/* FreeBSD 4.5 and above did rename mnt_vnodelist to mnt_nvnodelist */
#ifdef HAVE_STRUCT_MOUNT_MNT_NVNODELIST
	for(vp = TAILQ_FIRST(&XFS_TO_VFS(&xfs[fd])->mnt_nvnodelist);
	    vp != NULL; 
	    vp = next) {

	    next = TAILQ_NEXT(vp, v_nmntvnodes);
	    gc_vnode (vp, p);
	}
#else
a468 1
#endif
@


1.5.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d44 1
a44 13
RCSID("$arla: xfs_message.c,v 1.84 2003/06/02 18:25:20 lha Exp $");

static void
send_inactive_node(int fd, xfs_handle *handle)
{
    struct xfs_message_inactivenode msg;
    
    msg.header.opcode = NNPFS_MSG_INACTIVENODE;
    msg.handle = *handle;
    msg.flag   = NNPFS_NOREFS | NNPFS_DELETE;
    xfs_message_send(fd, &msg.header, sizeof(msg));
}

d50 1
a50 1
			d_thread_t *p)
d54 1
a54 1
    NNPFSDEB(XDEBMSG, ("xfs_message_installroot (%d,%d,%d,%d)\n",
d61 1
a61 1
	printf("NNPFS PANIC WARNING! xfs_message_installroot: called again!\n");
d67 1
a67 1
	NNPFS_MAKE_VROOT(xfs[fd].root->vn);
d76 1
a76 1
			d_thread_t *p)
d81 1
a81 1
    NNPFSDEB(XDEBMSG, ("xfs_message_installnode (%d,%d,%d,%d)\n",
d88 1
a88 1
    dp = xfs_node_find(&xfs[fd].nodehead, &message->parent_handle);
a91 3
	NNPFSDEB(XDEBMSG, ("xfs_message_installnode: t_vnode = %lx\n",
			   (unsigned long)t_vnode));

d107 1
a107 1
	printf("NNPFS PANIC WARNING! xfs_message_installnode: no parent\n");
d110 1
a110 1
    NNPFSDEB(XDEBMSG, ("return: xfs_message_installnode: %d\n", error));
d119 1
a119 1
			d_thread_t *p)
d124 1
a124 1
    NNPFSDEB(XDEBMSG, ("xfs_message_installattr (%d,%d,%d,%d) \n",
d130 1
a130 1
    t = xfs_node_find(&xfs[fd].nodehead, &message->node.handle);
d133 1
a133 1
	if ((t->tokens & NNPFS_DATA_MASK) && DATA_FROM_XNODE(t) == NULL) {
d135 1
a135 1
	    t->tokens &= ~NNPFS_DATA_MASK;
d138 1
a138 2
	if ((t->flags & NNPFS_VMOPEN) == 0)
	    xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d143 1
a143 1
	NNPFSDEB(XDEBMSG, ("xfs_message_installattr: no such node\n"));
d153 1
a153 1
			d_thread_t *p)
d158 1
a158 1
    NNPFSDEB(XDEBMSG, ("xfs_message_installdata (%d,%d,%d,%d)\n",
d165 1
a165 1
    t = xfs_node_find(&xfs[fd].nodehead, &message->node.handle);
d167 2
a168 2
	struct xfs_fhandle_t *fh = 
	    (struct xfs_fhandle_t *)&message->cache_handle;
a169 1
	struct vnode *vp;
d172 1
a172 1
	NNPFSDEB(XDEBMSG, ("cache_name = '%s'\n", message->cache_name));
d177 1
a177 1
	if (message->flag & NNPFS_ID_HANDLE_VALID) {
d190 1
a190 1
	    NNPFSDEB(XDEBMSG,
d194 1
a194 1
	    NDINIT(ndp, LOOKUP, FOLLOW | NNPFS_LOCKLEAF, UIO_SYSSPACE,
d208 1
a208 1
	    NNPFSDEB(XDEBMSG, ("xfs_message_installdata: t = %lx;"
d214 1
a214 2
	    if ((t->flags & NNPFS_VMOPEN) == 0)
		xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d216 2
a217 2
		&& (message->flag & NNPFS_ID_INVALID_DNLC))
		xfs_dnlc_purge (XNODE_TO_VNODE(t));
a220 1
	    t->offset = message->offset;
d222 2
a223 2
	    if (message->flag & NNPFS_ID_AFSDIR)
		t->flags |= NNPFS_AFSDIR;
d226 1
a226 1
	    printf("NNPFS PANIC WARNING! xfs_message_installdata failed!\n");
d232 1
a232 1
	printf("NNPFS PANIC WARNING! xfs_message_installdata failed\n");
d250 1
a250 1
			d_thread_t *p)
d255 1
a255 1
    NNPFSDEB(XDEBMSG, ("xfs_message_invalidnode (%d,%d,%d,%d)\n",
d261 1
a261 4
#ifdef __APPLE__
 retry:
#endif
    t = xfs_node_find(&xfs[fd].nodehead, &message->handle);
d287 1
a287 4
	    if (vget(vp, 0, p))
		goto retry;

	    if (UBCISVALID(vp) && !ubc_isinuse(vp, 1)) {
a288 1
		vrele(vp);
d290 1
a290 2
		vrele(vp);
		t->flags |= NNPFS_STALE;
d294 1
a294 1
	    t->flags |= NNPFS_STALE;
d303 3
a305 3
	NNPFS_TOKEN_CLEAR(t, ~0,
			NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
			NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
d310 1
a311 1
	    NNPFSDEB(XDEBVNOPS, ("xfs_message_invalidnode: vrecycle\n"));
d313 1
a313 3
#else
	    /* XXX */
#endif /* __osf__ */
a315 2
	NNPFSDEB(XDEBMSG, ("xfs_message_invalidnode: no such node\n"));
	send_inactive_node(fd, &message->handle);
d326 1
a326 1
		      d_thread_t *p)
d329 1
d331 13
a343 15
    NNPFSDEB(XDEBMSG, ("xfs_message_updatefid (%d,%d,%d,%d) (%d,%d,%d,%d)\n",
		       message->old_handle.a,
		       message->old_handle.b,
		       message->old_handle.c,
		       message->old_handle.d,
		       message->new_handle.a,
		       message->new_handle.b,
		       message->new_handle.c,
		       message->new_handle.d));

    error = xfs_update_handle(&xfs[fd].nodehead, 
				&message->old_handle,
				&message->new_handle);
    if (error)
	printf ("NNPFS PANIC WARNING! xfs_message_updatefid: %d\n", error);
d355 1
a355 1
	  d_thread_t *p)
d366 1
a366 1
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
d370 1
a370 1
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
d375 34
d418 1
a418 1
	  d_thread_t *p)
a419 3
#ifdef HAVE_SYS_MUTEX_H
    mtx_lock(&vp->v_interlock);
#else
a420 1
#endif
a434 3
#ifdef HAVE_SYS_MUTEX_H
	    mtx_unlock(&vp->v_interlock);
#else
a435 1
#endif
d442 2
a443 2
		    vprint("vrele: bad ref count", vp);
		    panic("vrele: ref cnt");
d446 1
a446 1
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
d448 1
a448 1
#ifdef HAVE_KERNEL_VGONEL
a450 3
#ifdef HAVE_SYS_MUTEX_H
	mtx_unlock(&vp->v_interlock);
#else
a451 1
#endif
a455 3
#ifdef HAVE_SYS_MUTEX_H
	mtx_unlock(&vp->v_interlock);
#else
d457 1
a457 2
#endif
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
d462 31
d494 3
d498 6
a503 18
int
xfs_message_gc_nodes(int fd,
		       struct xfs_message_gc_nodes *message,
		       u_int size,
		       d_thread_t *p)
{
    struct xfs_node *node;
    int i;

    NNPFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    for (i = 0; i < message->len; i++) {
	node = xfs_node_find (&xfs[fd].nodehead, &message->handle[i]);
	if (node)
	    gc_vnode(XNODE_TO_VNODE(node), p);
	else {
	    NNPFSDEB(XDEBMSG, ("xfs_message_gc_nodes: no such node\n"));
	    send_inactive_node(fd, &message->handle[i]);
d511 2
d521 1
a521 1
		    d_thread_t *p)
d526 1
a526 1
    ret = NNPFS_VERSION;
d528 1
a528 1
    msg.header.opcode = NNPFS_MSG_WAKEUP;
d532 1
a532 2
    return xfs_message_send(fd, 
			      (struct xfs_message_header *) &msg, sizeof(msg));
@


1.4
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d48 1
a48 1
RCSID("$Id: xfs_message.c,v 1.35 1999/03/20 01:18:48 lha Exp $");
d122 3
d128 1
d201 3
d206 1
@


1.3
log
@ * reorganize some includes
 * start using the VT_XFS tag on vnodes
 * be more paranoid about closed channel when going to sleep.
@
text
@a0 1
/*	$OpenBSD: xfs_message.c,v 1.2 1998/08/31 05:13:15 art Exp $	*/
d39 1
a39 8
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/namei.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/vnode.h>

#include <xfs/xfs_common.h>
d44 3
d48 1
a48 1
RCSID("$KTH: xfs_message.c,v 1.16 1998/07/19 00:19:54 art Exp $");
d52 1
a52 1
			struct xfs_message_installroot *message,
d56 1
a56 1
	int error = 0;
d58 1
a58 1
	XFSDEB(XDEBMSG, ("xfs_message_installroot\n"));
d60 10
a69 12
	if (xfs[fd].root != NULL) {
		printf("XFS WARNING! xfs_message_installroot: again!\n");
		error = EBUSY;
	} else {
		error = new_xfs_node(&xfs[fd], &message->node, &xfs[fd].root,
				     p);
		if (error)
			return error;
		xfs[fd].root->vn->v_flag |= VROOT;
	}

	return error;
d74 1
a74 1
			struct xfs_message_installnode *message,
d78 4
a81 2
	int		error = 0;
	struct xfs_node	*n, *dp;
d83 3
a85 1
	XFSDEB(XDEBMSG, ("xfs_message_installnode\n"));
d87 6
a92 12
	dp = xfs_node_find(&xfs[fd], &message->parent_handle);
	if (dp) {
		error = new_xfs_node(&xfs[fd], &message->node, &n, p);
		if (error)
			return error;
		cache_purge (XNODE_TO_VNODE(dp));
		xfs_dnlc_enter(XNODE_TO_VNODE(dp), message->name,
			       XNODE_TO_VNODE(n));
		vrele(XNODE_TO_VNODE(n));
	} else {
		printf("XFS WARNING! xfs_message_installnode: no parent\n");
		error = ENOENT;
a93 1
	XFSDEB(XDEBMSG, ("return: xfs_message_installnode: %d\n", error));
d95 12
a106 1
	return error;
d111 1
a111 1
			struct xfs_message_installattr *message,
d115 2
a116 2
	int error = 0;
	struct xfs_node *t;
d118 14
a131 11
	t = xfs_node_find(&xfs[fd], &message->node.handle);
	if (t != 0) {
		t->tokens = message->node.tokens;
		xfs_attr2vattr(&message->node.attr, &t->attr);
		bcopy(message->node.id, t->id, sizeof(t->id));
		bcopy(message->node.rights, t->rights, sizeof(t->rights));
		t->anonrights = message->node.anonrights;
	} else {
		printf("XFS WARNING! xfs_message_installattr: no node!\n");
		error = ENOENT;
	}
d133 1
a133 1
	return error;
d138 1
a138 1
			struct xfs_message_installdata *message,
d142 2
a143 2
	struct xfs_node	*t;
	int		error = 0;
d145 1
a145 1
	XFSDEB(XDEBMSG, ("xfs_message_installdata\n"));
d147 59
a205 37
	t = xfs_node_find(&xfs[fd], &message->node.handle);
	if (t != NULL) {
		struct nameidata	nd;
		char			tmp[CACHEHANDLESIZE + 1];
		struct vnode		*vp;

		bcopy((char *) &message->cache_handle.data, tmp, sizeof(tmp));
		tmp[CACHEHANDLESIZE] = '\0';

		XFSDEB(XDEBMSG, ("cache_handle = '%s'\n", tmp));

		NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, tmp, p);
		error = namei(&nd);
		vp = nd.ni_vp;
		if (error == 0) {
			if (DATA_FROM_XNODE(t))
				vrele(DATA_FROM_XNODE(t));
			VOP_UNLOCK(vp, 0, p);
			DATA_FROM_XNODE(t) = vp;
			XFSDEB(XDEBMSG,
			       ("xfs_message_installdata: t= %p tokens= %x\n",
				t, message->node.tokens));

			t->tokens = message->node.tokens;
			xfs_attr2vattr(&message->node.attr, &t->attr);
			if (XNODE_TO_VNODE(t)->v_type == VDIR)
				cache_purge (XNODE_TO_VNODE(t));

			bcopy(message->node.id, t->id, sizeof(t->id));
			bcopy(message->node.rights, t->rights,
			      sizeof(t->rights));
			t->anonrights = message->node.anonrights;
		} else {
			printf("XFS WARNING! xfs_message_installdata fail!\n");
			printf("Reason: lookup failed on cache file '%s', "
			       "error = %d\n", tmp, error);
		}
d207 3
a209 3
		printf("XFS WARNING! xfs_message_installdata failed\n");
		printf("Reason: No node to install the data into!\n");
		error = ENOENT;
d211 6
d218 1
a218 1
	return error;
d223 1
a223 1
			struct xfs_message_invalidnode *message,
d227 2
a228 2
	int		error = 0;
	struct xfs_node	*t;
d230 1
a230 1
	XFSDEB(XDEBMSG, ("xfs_message_invalidnode\n"));
d232 6
a237 14
	t = xfs_node_find(&xfs[fd], &message->handle);
	if (t != 0) {
		/* XXX Really need to put back dirty data first. */
		if (DATA_FROM_XNODE(t)) {
			vrele(DATA_FROM_XNODE(t));
			DATA_FROM_XNODE(t) = (struct vnode *) 0;
		}
		XFS_TOKEN_CLEAR(t, ~0,
				XFS_OPEN_MASK | XFS_ATTR_MASK |
				XFS_DATA_MASK | XFS_LOCK_MASK);
		cache_purge(XNODE_TO_VNODE(t));
	} else {
		printf("XFS WARNING! xfs_message_invalidnode: no node!\n");
		error = ENOENT;
d239 20
d260 9
a268 1
	return error;
@


1.2
log
@indent the code and move around some includes, after discussion with Theo
@
text
@d1 1
a1 1
/*	$OpenBSD: xfs_message.c,v 1.1 1998/08/30 16:47:21 art Exp $	*/
d44 2
@


1.1
log
@xfs - a filesystem using a user-land cache manager. Designed for AFS.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#include <sys/xfs_message.h>
d55 1
a55 1
			struct xfs_message_installroot * message,
d59 1
a59 1
    int error = 0;
d61 1
a61 1
    XFSDEB(XDEBMSG, ("xfs_message_installroot\n"));
d63 12
a74 10
    if (xfs[fd].root != NULL) {
	printf("XFS PANIC WARNING! xfs_message_installroot: called again!\n");
	error = EBUSY;
    } else {
	error = new_xfs_node(&xfs[fd], &message->node, &xfs[fd].root, p);
	if (error)
	    return error;
	xfs[fd].root->vn->v_flag |= VROOT;
    }
    return error;
d79 1
a79 1
			struct xfs_message_installnode * message,
d83 2
a84 2
    int error = 0;
    struct xfs_node *n, *dp;
d86 1
a86 1
    XFSDEB(XDEBMSG, ("xfs_message_installnode\n"));
d88 14
a101 13
    dp = xfs_node_find(&xfs[fd], &message->parent_handle);
    if (dp) {
	error = new_xfs_node(&xfs[fd], &message->node, &n, p);
	if (error)
	    return error;
	cache_purge (XNODE_TO_VNODE(dp));
	xfs_dnlc_enter(XNODE_TO_VNODE(dp), message->name, XNODE_TO_VNODE(n));
	vrele(XNODE_TO_VNODE(n));
    } else {
	printf("XFS PANIC WARNING! xfs_message_installnode: no parent\n");
	error = ENOENT;
    }
    XFSDEB(XDEBMSG, ("return: xfs_message_installnode: %d\n", error));
d103 1
a103 1
    return error;
d108 1
a108 1
			struct xfs_message_installattr * message,
d112 2
a113 2
    int error = 0;
    struct xfs_node *t;
d115 11
a125 11
    t = xfs_node_find(&xfs[fd], &message->node.handle);
    if (t != 0) {
	t->tokens = message->node.tokens;
	xfs_attr2vattr(&message->node.attr, &t->attr);
	bcopy(message->node.id, t->id, sizeof(t->id));
	bcopy(message->node.rights, t->rights, sizeof(t->rights));
	t->anonrights = message->node.anonrights;
    } else {
	printf("XFS PANIC WARNING! xfs_message_installattr: no node!\n");
	error = ENOENT;
    }
d127 1
a127 1
    return error;
d132 1
a132 1
			struct xfs_message_installdata * message,
d136 2
a137 2
    struct xfs_node *t;
    int error = 0;
d139 1
a139 1
    XFSDEB(XDEBMSG, ("xfs_message_installdata\n"));
d141 37
a177 31
    t = xfs_node_find(&xfs[fd], &message->node.handle);

    if (t != NULL) {
	struct nameidata nd;
	char tmp[CACHEHANDLESIZE + 1];
	struct vnode *vp;

	bcopy((char *) &message->cache_handle.data, tmp, CACHEHANDLESIZE);
	tmp[CACHEHANDLESIZE] = '\0';

	XFSDEB(XDEBMSG, ("cache_handle = '%s'\n", tmp));

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, tmp, p);
	error = namei(&nd);
	vp = nd.ni_vp;

	if (error == 0) {
	    if (DATA_FROM_XNODE(t))
		vrele(DATA_FROM_XNODE(t));
	    VOP_UNLOCK(vp, 0, p);
	    DATA_FROM_XNODE(t) = vp;
	    XFSDEB(XDEBMSG, ("xfs_message_installdata: t = %p ; tokens = %x\n",
			     t, message->node.tokens));

	    t->tokens = message->node.tokens;
	    xfs_attr2vattr(&message->node.attr, &t->attr);
	    if (XNODE_TO_VNODE(t)->v_type == VDIR)
		cache_purge (XNODE_TO_VNODE(t));
	    bcopy(message->node.id, t->id, sizeof(t->id));
	    bcopy(message->node.rights, t->rights, sizeof(t->rights));
	    t->anonrights = message->node.anonrights;
d179 3
a181 3
	    printf("XFS PANIC WARNING! xfs_message_installdata failed!\n");
	    printf("Reason: lookup failed on cache file '%s', error = %d\n",
		   tmp, error);
a182 5
    } else {
	printf("XFS PANIC WARNING! xfs_message_installdata failed\n");
	printf("Reason: No node to install the data into!\n");
	error = ENOENT;
    }
d184 1
a184 1
    return error;
d189 1
a189 1
			struct xfs_message_invalidnode * message,
d193 2
a194 2
    int error = 0;
    struct xfs_node *t;
d196 1
a196 1
    XFSDEB(XDEBMSG, ("xfs_message_invalidnode\n"));
d198 14
a211 6
    t = xfs_node_find(&xfs[fd], &message->handle);
    if (t != 0) {
	/* XXX Really need to put back dirty data first. */
	if (DATA_FROM_XNODE(t)) {
	    vrele(DATA_FROM_XNODE(t));
	    DATA_FROM_XNODE(t) = (struct vnode *) 0;
a212 8
	XFS_TOKEN_CLEAR(t, ~0,
			XFS_OPEN_MASK | XFS_ATTR_MASK |
			XFS_DATA_MASK | XFS_LOCK_MASK);
	cache_purge(XNODE_TO_VNODE(t));
    } else {
	printf("XFS PANIC WARNING! xfs_message_invalidnode: no node!\n");
	error = ENOENT;
    }
d214 1
a214 1
    return error;
@


1.1.1.1
log
@Import of xfs from arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d40 6
a45 1
#include <xfs/xfs_locl.h>
d48 1
a48 1
#include <xfs/xfs_message.h>
a49 4
#include <xfs/xfs_syscalls.h>
#include <xfs/xfs_vfsops.h>
#include <xfs/xfs_vnodeops.h>
#include <xfs/xfs_dev.h>
d51 1
a51 1
RCSID("$Id: xfs_message.c,v 1.1.1.1 2002/06/05 17:24:11 hin Exp $");
d61 1
a61 5
    XFSDEB(XDEBMSG, ("xfs_message_installroot (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));
d84 1
a84 5
    XFSDEB(XDEBMSG, ("xfs_message_installnode (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));
a85 1
retry:
a87 5
	struct vnode *t_vnode = XNODE_TO_VNODE(dp);

	if (xfs_do_vget(t_vnode, 0 /* LK_SHARED */, p))
		goto retry;

d89 1
a89 2
	if (error) {
	    vrele (t_vnode);
d91 3
a93 7
	}

	xfs_dnlc_enter_name(t_vnode,
			    message->name,
			    XNODE_TO_VNODE(n));
	vrele (XNODE_TO_VNODE(n));
	vrele (t_vnode);
a111 6
    XFSDEB(XDEBMSG, ("xfs_message_installattr (%d,%d,%d,%d) \n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));

d115 1
a115 6
	if ((t->tokens & XFS_DATA_MASK) && DATA_FROM_XNODE(t) == NULL) {
	    printf ("xfs_message_installattr: tokens and no data\n");
	    t->tokens &= ~XFS_DATA_MASK;
	}
	xfs_attr2vattr(&message->node.attr, &t->attr, 0);
	xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d120 2
a121 1
	XFSDEB(XDEBMSG, ("xfs_message_installattr: no such node\n"));
d123 1
a123 1
    
d136 1
a136 5
    XFSDEB(XDEBMSG, ("xfs_message_installdata (%d,%d,%d,%d)\n",
		     message->node.handle.a,
		     message->node.handle.b,
		     message->node.handle.c,
		     message->node.handle.d));
a137 1
retry:
d139 1
d141 2
a142 1
	struct xfs_fhandle_t *fh = (struct xfs_fhandle_t *)&message->cache_handle;
a143 1
	struct vnode *t_vnode = XNODE_TO_VNODE(t);
d145 2
a146 2
	message->cache_name[sizeof(message->cache_name)-1] = '\0';
	XFSDEB(XDEBMSG, ("cache_name = '%s'\n", message->cache_name));
d148 1
a148 2
	if (xfs_do_vget(t_vnode, 0 /* LK_SHARED */, p))
		goto retry;
d150 3
a152 22
	if (message->flag & XFS_ID_HANDLE_VALID) {
	    error = xfs_fhlookup (p, fh, &vp);
	} else {
	    error = EINVAL;
	}
	if (error != 0) {
#ifdef __osf__
	    struct nameidata *ndp = &u.u_nd;
#else
	    struct nameidata nd;
	    struct nameidata *ndp = &nd;
#endif

	    XFSDEB(XDEBMSG,
		   ("xfs_message_installdata: fhlookup failed: %d, "
		    "opening by name\n", error));

	    NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE,
		   message->cache_name, p);
	    error = namei(ndp);
	    vp = ndp->ni_vp;
	}
a154 3
#ifndef __osf__
	    xfs_vfs_unlock(vp, p);
#endif
d157 1
d159 2
a160 4

	    XFSDEB(XDEBMSG, ("xfs_message_installdata: t = %lx;"
			     " tokens = %x\n",
			     (unsigned long)t, message->node.tokens));
d163 2
a164 4
	    xfs_attr2vattr(&message->node.attr, &t->attr, 1);
	    xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
	    if (XNODE_TO_VNODE(t)->v_type == VDIR
		&& (message->flag & XFS_ID_INVALID_DNLC))
a168 4
#if 0
	    if (message->flag & XFS_ID_AFSDIR)
		t->flags |= XFS_AFSDIR;
#endif
d172 1
a172 1
		   message->cache_name, error);
a173 1
	vrele (t_vnode);
a182 6
#ifdef __osf__
#define xfs_writecount v_wrcnt
#else
#define xfs_writecount v_writecount
#endif

d192 1
a192 5
    XFSDEB(XDEBMSG, ("xfs_message_invalidnode (%d,%d,%d,%d)\n",
		     message->handle.a,
		     message->handle.b,
		     message->handle.c,
		     message->handle.d));
d196 1
a196 36
	struct vnode *vp = XNODE_TO_VNODE(t);

        /* If open for writing, return immediately. Last close:er wins! */
	if (vp->v_usecount >= 0 && vp->xfs_writecount >= 1)
            return 0;

#ifdef __FreeBSD__
	{
	    vm_object_t obj = vp->v_object;

	    if (obj != NULL
		&& (obj->ref_count != 0
#ifdef OBJ_MIGHTBEDIRTY
		|| (obj->flags & OBJ_MIGHTBEDIRTY) != 0
#endif
		    ))
		return 0;

	}
#endif /* __FreeBSD__ */

	/* If node is in use, mark as stale */
	if (vp->v_usecount > 0 && vp->v_type != VDIR) {
#ifdef __APPLE__
	    if (UBCISVALID(vp) && !ubc_isinuse(vp, 0)) {
		ubc_setsize(vp, 0);
	    } else {
		t->flags |= XFS_STALE;
		return 0;
	    }
#else
	    t->flags |= XFS_STALE;
	    return 0;
#endif
	}

d204 1
a204 9
	/* Dir changed, must invalidate DNLC. */
	if (vp->v_type == VDIR)
	    xfs_dnlc_purge(vp);
	if (vp->v_usecount == 0) {
	    XFSDEB(XDEBVNOPS, ("xfs_message_invalidnode: vrecycle\n"));
#ifndef __osf__
	    vrecycle(vp, 0, p);
#endif
	}
d206 1
a210 213
}

int
xfs_message_updatefid(int fd,
		      struct xfs_message_updatefid * message,
		      u_int size,
		      struct proc *p)
{
    int error = 0;
    struct xfs_node *t;

    XFSDEB(XDEBMSG, ("xfs_message_updatefid (%d,%d,%d,%d)\n",
		     message->old_handle.a,
		     message->old_handle.b,
		     message->old_handle.c,
		     message->old_handle.d));

    t = xfs_node_find (&xfs[fd], &message->old_handle);
    if (t != NULL) {
	t->handle = message->new_handle;
    } else {
	printf ("XFS PANIC WARNING! xfs_message_updatefid: no node!\n");
	error = ENOENT;
    }
    return error;
}

#if __osf__

/*
 * Try to clean out nodes for the userland daemon
 */

static void
gc_vnode (struct vnode *vp,
	  struct proc *p)
{
    /* This node is on the freelist */
    if (vp->v_usecount <= 0) {
	
	/*  DIAGNOSTIC */
	if (vp->v_usecount < 0) {
		    vprint("vrele: bad ref count", vp);
		    panic("vrele: ref cnt");
	}
	
	XFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
	
	vgone(vp, VX_NOSLEEP, NULL);
    } else {
	XFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
    }

}

int
xfs_message_gc_nodes(int fd,
		     struct xfs_message_gc_nodes *message,
		     u_int size,
		     struct proc *p)
{
    XFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    if (message->len == 0) {
	struct vnode *vp;

	/* XXX see comment in xfs_node_find */

	for(vp = XFS_TO_VFS(&xfs[fd])->m_mounth;
	    vp != NULL; 
	    vp = vp->v_mountf) {
	    gc_vnode (vp, p);
	}

    } else {
	struct xfs_node *t;
	int i;

	for (i = 0; i < message->len; i++) {
	    t = xfs_node_find (&xfs[fd], &message->handle[i]);
	    if (t == NULL)
		continue;

	    gc_vnode(XNODE_TO_VNODE(t), p);
	}
    }

    return 0;
}

#else /* !__osf__ */

/*
 * Try to clean out nodes for the userland daemon
 */

static void
gc_vnode (struct vnode *vp,
	  struct proc *p)
{
    simple_lock(&vp->v_interlock);
    
    /* This node is on the freelist */
    if (vp->v_usecount <= 0) {
#if __FreeBSD__
	vm_object_t obj;

	obj = vp->v_object;

	if (obj != NULL
	    && (obj->ref_count != 0
#ifdef OBJ_MIGHTBEDIRTY
		|| (obj->flags & OBJ_MIGHTBEDIRTY) != 0
#endif
		)) {
	    simple_unlock (&vp->v_interlock);
	    return;
	}
#endif /* __FreeBSD__ */
	
	/*  DIAGNOSTIC */
	if (vp->v_usecount < 0 || vp->v_writecount != 0) {
		    vprint("Pjäxomatic-4700: bad ref count", vp);
		    panic("Pjäxomatic-4650: ref cnt");
	}
	
	XFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
	
#ifdef HAVE_KERNEL_FUNC_VGONEL
	vgonel (vp, p);
#else
	simple_unlock(&vp->v_interlock); 
	vgone (vp);
#endif

    } else {
	simple_unlock(&vp->v_interlock);
	XFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
    }

}

int
xfs_message_gc_nodes(int fd,
		     struct xfs_message_gc_nodes *message,
		     u_int size,
		     struct proc *p)
{
    XFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    if (message->len == 0) {
	struct vnode *vp, *next;

	/* XXX see comment in xfs_node_find */
	/* XXXSMP do gone[l] need to get mntvnode_slock ? */

/* FreeBSD 4.5 and above did rename mnt_vnodelist to mnt_nvnodelist */
#ifdef HAVE_STRUCT_MOUNT_MNT_NVNODELIST
	for(vp = TAILQ_FIRST(&XFS_TO_VFS(&xfs[fd])->mnt_nvnodelist);
	    vp != NULL; 
	    vp = next) {

	    next = TAILQ_NEXT(vp, v_nmntvnodes);
	    gc_vnode (vp, p);
	}
#else
	for(vp = XFS_TO_VFS(&xfs[fd])->mnt_vnodelist.lh_first;
	    vp != NULL; 
	    vp = next) {

	    next = vp->v_mntvnodes.le_next;
	    gc_vnode (vp, p);
	}
#endif
    } else {
	struct xfs_node *t;
	int i;

	for (i = 0; i < message->len; i++) {
	    t = xfs_node_find (&xfs[fd], &message->handle[i]);
	    if (t == NULL)
		continue;

	    gc_vnode(XNODE_TO_VNODE(t), p);
	}
    }

    return 0;
}


#endif

/*
 * Probe what version of xfs this support
 */

int
xfs_message_version(int fd,
		    struct xfs_message_version *message,
		    u_int size,
		    struct proc *p)
{
    struct xfs_message_wakeup msg;
    int ret;

    ret = XFS_VERSION;

    msg.header.opcode = XFS_MSG_WAKEUP;
    msg.sleepers_sequence_num = message->header.sequence_num;
    msg.error = ret;

    return xfs_message_send(fd, (struct xfs_message_header *) &msg, sizeof(msg));
@


1.1.1.2
log
@Import xfs from arla-current as of 5 Aug 2003.

ok deraadt@@
@
text
@d44 1
a44 14
RCSID("$arla: xfs_message.c,v 1.84 2003/06/02 18:25:20 lha Exp $");

static void
send_inactive_node(int fd, xfs_handle *handle)
{
    struct xfs_message_inactivenode msg;
    
    msg.header.opcode = NNPFS_MSG_INACTIVENODE;
    msg.handle = *handle;
    msg.flag   = NNPFS_NOREFS | NNPFS_DELETE;
    xfs_message_send(fd, &msg.header, sizeof(msg));
}


d50 1
a50 1
			d_thread_t *p)
d54 1
a54 1
    NNPFSDEB(XDEBMSG, ("xfs_message_installroot (%d,%d,%d,%d)\n",
d61 1
a61 1
	printf("NNPFS PANIC WARNING! xfs_message_installroot: called again!\n");
d67 1
a67 1
	NNPFS_MAKE_VROOT(xfs[fd].root->vn);
d76 1
a76 1
			d_thread_t *p)
d81 1
a81 1
    NNPFSDEB(XDEBMSG, ("xfs_message_installnode (%d,%d,%d,%d)\n",
d88 1
a88 1
    dp = xfs_node_find(&xfs[fd].nodehead, &message->parent_handle);
a91 3
	NNPFSDEB(XDEBMSG, ("xfs_message_installnode: t_vnode = %lx\n",
			   (unsigned long)t_vnode));

d107 1
a107 1
	printf("NNPFS PANIC WARNING! xfs_message_installnode: no parent\n");
d110 1
a110 1
    NNPFSDEB(XDEBMSG, ("return: xfs_message_installnode: %d\n", error));
d119 1
a119 1
			d_thread_t *p)
d124 1
a124 1
    NNPFSDEB(XDEBMSG, ("xfs_message_installattr (%d,%d,%d,%d) \n",
d130 1
a130 1
    t = xfs_node_find(&xfs[fd].nodehead, &message->node.handle);
d133 1
a133 1
	if ((t->tokens & NNPFS_DATA_MASK) && DATA_FROM_XNODE(t) == NULL) {
d135 1
a135 1
	    t->tokens &= ~NNPFS_DATA_MASK;
d138 1
a138 2
	if ((t->flags & NNPFS_VMOPEN) == 0)
	    xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d143 1
a143 1
	NNPFSDEB(XDEBMSG, ("xfs_message_installattr: no such node\n"));
d153 1
a153 1
			d_thread_t *p)
d158 1
a158 1
    NNPFSDEB(XDEBMSG, ("xfs_message_installdata (%d,%d,%d,%d)\n",
d165 1
a165 1
    t = xfs_node_find(&xfs[fd].nodehead, &message->node.handle);
d167 2
a168 2
	struct xfs_fhandle_t *fh = 
	    (struct xfs_fhandle_t *)&message->cache_handle;
a169 1
	struct vnode *vp;
d172 1
a172 1
	NNPFSDEB(XDEBMSG, ("cache_name = '%s'\n", message->cache_name));
d177 1
a177 1
	if (message->flag & NNPFS_ID_HANDLE_VALID) {
d190 1
a190 1
	    NNPFSDEB(XDEBMSG,
d194 1
a194 1
	    NDINIT(ndp, LOOKUP, FOLLOW | NNPFS_LOCKLEAF, UIO_SYSSPACE,
d208 1
a208 1
	    NNPFSDEB(XDEBMSG, ("xfs_message_installdata: t = %lx;"
d214 1
a214 2
	    if ((t->flags & NNPFS_VMOPEN) == 0)
		xfs_set_vp_size(XNODE_TO_VNODE(t), t->attr.va_size);
d216 2
a217 2
		&& (message->flag & NNPFS_ID_INVALID_DNLC))
		xfs_dnlc_purge (XNODE_TO_VNODE(t));
a220 1
	    t->offset = message->offset;
d222 2
a223 2
	    if (message->flag & NNPFS_ID_AFSDIR)
		t->flags |= NNPFS_AFSDIR;
d226 1
a226 1
	    printf("NNPFS PANIC WARNING! xfs_message_installdata failed!\n");
d232 1
a232 1
	printf("NNPFS PANIC WARNING! xfs_message_installdata failed\n");
d250 1
a250 1
			d_thread_t *p)
d255 1
a255 1
    NNPFSDEB(XDEBMSG, ("xfs_message_invalidnode (%d,%d,%d,%d)\n",
d261 1
a261 4
#ifdef __APPLE__
 retry:
#endif
    t = xfs_node_find(&xfs[fd].nodehead, &message->handle);
d287 1
a287 4
	    if (vget(vp, 0, p))
		goto retry;

	    if (UBCISVALID(vp) && !ubc_isinuse(vp, 1)) {
a288 1
		vrele(vp);
d290 1
a290 2
		vrele(vp);
		t->flags |= NNPFS_STALE;
d294 1
a294 1
	    t->flags |= NNPFS_STALE;
d303 3
a305 3
	NNPFS_TOKEN_CLEAR(t, ~0,
			NNPFS_OPEN_MASK | NNPFS_ATTR_MASK |
			NNPFS_DATA_MASK | NNPFS_LOCK_MASK);
d310 1
a311 1
	    NNPFSDEB(XDEBVNOPS, ("xfs_message_invalidnode: vrecycle\n"));
d313 1
a313 3
#else
	    /* XXX */
#endif /* __osf__ */
a315 2
	NNPFSDEB(XDEBMSG, ("xfs_message_invalidnode: no such node\n"));
	send_inactive_node(fd, &message->handle);
d326 1
a326 1
		      d_thread_t *p)
d331 13
a343 15
    NNPFSDEB(XDEBMSG, ("xfs_message_updatefid (%d,%d,%d,%d) (%d,%d,%d,%d)\n",
		       message->old_handle.a,
		       message->old_handle.b,
		       message->old_handle.c,
		       message->old_handle.d,
		       message->new_handle.a,
		       message->new_handle.b,
		       message->new_handle.c,
		       message->new_handle.d));

    error = xfs_update_handle(&xfs[fd].nodehead, 
				&message->old_handle,
				&message->new_handle);
    if (error)
	printf ("NNPFS PANIC WARNING! xfs_message_updatefid: %d\n", error);
d355 1
a355 1
	  d_thread_t *p)
d366 1
a366 1
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
d370 1
a370 1
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
d375 34
d418 1
a418 1
	  d_thread_t *p)
a419 3
#ifdef HAVE_SYS_MUTEX_H
    mtx_lock(&vp->v_interlock);
#else
a420 1
#endif
a434 3
#ifdef HAVE_SYS_MUTEX_H
	    mtx_unlock(&vp->v_interlock);
#else
a435 1
#endif
d442 2
a443 2
		    vprint("vrele: bad ref count", vp);
		    panic("vrele: ref cnt");
d446 1
a446 1
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: success\n"));
d448 1
a448 1
#ifdef HAVE_KERNEL_VGONEL
a450 3
#ifdef HAVE_SYS_MUTEX_H
	mtx_unlock(&vp->v_interlock);
#else
a451 1
#endif
a455 3
#ifdef HAVE_SYS_MUTEX_H
	mtx_unlock(&vp->v_interlock);
#else
d457 1
a457 2
#endif
	NNPFSDEB(XDEBMSG, ("xfs_message_gc: used\n"));
d462 31
d494 3
d498 6
a503 18
int
xfs_message_gc_nodes(int fd,
		       struct xfs_message_gc_nodes *message,
		       u_int size,
		       d_thread_t *p)
{
    struct xfs_node *node;
    int i;

    NNPFSDEB(XDEBMSG, ("xfs_message_gc\n"));

    for (i = 0; i < message->len; i++) {
	node = xfs_node_find (&xfs[fd].nodehead, &message->handle[i]);
	if (node)
	    gc_vnode(XNODE_TO_VNODE(node), p);
	else {
	    NNPFSDEB(XDEBMSG, ("xfs_message_gc_nodes: no such node\n"));
	    send_inactive_node(fd, &message->handle[i]);
d511 2
d521 1
a521 1
		    d_thread_t *p)
d526 1
a526 1
    ret = NNPFS_VERSION;
d528 1
a528 1
    msg.header.opcode = NNPFS_MSG_WAKEUP;
d532 1
a532 2
    return xfs_message_send(fd, 
			      (struct xfs_message_header *) &msg, sizeof(msg));
@


