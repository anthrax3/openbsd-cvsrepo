head	1.171;
access;
symbols
	OPENBSD_6_2:1.171.0.2
	OPENBSD_6_2_BASE:1.171
	OPENBSD_6_1:1.171.0.4
	OPENBSD_6_1_BASE:1.171
	OPENBSD_6_0:1.170.0.2
	OPENBSD_6_0_BASE:1.170
	OPENBSD_5_9:1.167.0.2
	OPENBSD_5_9_BASE:1.167
	OPENBSD_5_8:1.164.0.4
	OPENBSD_5_8_BASE:1.164
	OPENBSD_5_7:1.161.0.2
	OPENBSD_5_7_BASE:1.161
	OPENBSD_5_6:1.152.0.4
	OPENBSD_5_6_BASE:1.152
	OPENBSD_5_5:1.150.0.4
	OPENBSD_5_5_BASE:1.150
	OPENBSD_5_4:1.144.0.2
	OPENBSD_5_4_BASE:1.144
	OPENBSD_5_3:1.140.0.2
	OPENBSD_5_3_BASE:1.140
	OPENBSD_5_2:1.139.0.2
	OPENBSD_5_2_BASE:1.139
	OPENBSD_5_1_BASE:1.138
	OPENBSD_5_1:1.138.0.4
	OPENBSD_5_0:1.138.0.2
	OPENBSD_5_0_BASE:1.138
	OPENBSD_4_9:1.133.0.2
	OPENBSD_4_9_BASE:1.133
	OPENBSD_4_8:1.130.0.2
	OPENBSD_4_8_BASE:1.130
	OPENBSD_4_7:1.127.0.2
	OPENBSD_4_7_BASE:1.127
	OPENBSD_4_6:1.115.0.4
	OPENBSD_4_6_BASE:1.115
	OPENBSD_4_5:1.111.0.2
	OPENBSD_4_5_BASE:1.111
	OPENBSD_4_4:1.98.0.2
	OPENBSD_4_4_BASE:1.98
	OPENBSD_4_3:1.80.0.2
	OPENBSD_4_3_BASE:1.80
	OPENBSD_4_2:1.75.0.2
	OPENBSD_4_2_BASE:1.75
	OPENBSD_4_1:1.72.0.2
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.67.0.2
	OPENBSD_4_0_BASE:1.67
	OPENBSD_3_9:1.65.0.2
	OPENBSD_3_9_BASE:1.65
	OPENBSD_3_8:1.64.0.2
	OPENBSD_3_8_BASE:1.64
	OPENBSD_3_7:1.63.0.4
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.63.0.2
	OPENBSD_3_6_BASE:1.63
	SMP_SYNC_A:1.60
	SMP_SYNC_B:1.60
	OPENBSD_3_5:1.58.0.2
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.55.0.2
	OPENBSD_3_4_BASE:1.55
	UBC_SYNC_A:1.54
	OPENBSD_3_3:1.53.0.2
	OPENBSD_3_3_BASE:1.53
	OPENBSD_3_2:1.51.0.2
	OPENBSD_3_2_BASE:1.51
	OPENBSD_3_1:1.50.0.2
	OPENBSD_3_1_BASE:1.50
	UBC_SYNC_B:1.51
	UBC:1.44.0.2
	UBC_BASE:1.44
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.26.0.6
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.26.0.4
	OPENBSD_2_7_BASE:1.26
	SMP:1.26.0.2
	SMP_BASE:1.26
	kame_19991208:1.25
	OPENBSD_2_6:1.25.0.4
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.22.0.2
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.171
date	2017.02.22.11.42.46;	author mpi;	state Exp;
branches;
next	1.170;
commitid	QPdM5oUknMlUIDue;

1.170
date	2016.06.13.19.00.22;	author tedu;	state Exp;
branches;
next	1.169;
commitid	RTAddrE8gckT9gf8;

1.169
date	2016.04.29.14.40.36;	author beck;	state Exp;
branches;
next	1.168;
commitid	p3EbVWCYrcYkiFMB;

1.168
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.167;
commitid	gAjwyca5TfuoJAhn;

1.167
date	2016.02.13.15.45.05;	author stefan;	state Exp;
branches;
next	1.166;
commitid	TfAXGeazXTFF4kij;

1.166
date	2015.12.22.21.36.57;	author mmcc;	state Exp;
branches;
next	1.165;
commitid	ea5GZDc4EQ86MZA8;

1.165
date	2015.12.07.01.51.39;	author beck;	state Exp;
branches;
next	1.164;
commitid	ma9fkxuuxVWSoU7s;

1.164
date	2015.05.03.02.02.15;	author guenther;	state Exp;
branches
	1.164.4.1;
next	1.163;
commitid	NAAakWCdJjcqPXcS;

1.163
date	2015.04.17.04.43.21;	author guenther;	state Exp;
branches;
next	1.162;
commitid	zOwbm07fp3gPB2qr;

1.162
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.161;
commitid	p4LJxGKbi0BU2cG6;

1.161
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.160;
commitid	C5iGb36LQxjM60Q3;

1.160
date	2014.12.29.05.29.28;	author miod;	state Exp;
branches;
next	1.159;
commitid	UbmX4MifiudCV4qQ;

1.159
date	2014.12.18.20.59.21;	author tedu;	state Exp;
branches;
next	1.158;
commitid	A8MlA6JGDExx7uTs;

1.158
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.157;
commitid	P6Av4XGqOi3rFasL;

1.157
date	2014.12.03.04.16.58;	author tedu;	state Exp;
branches;
next	1.156;
commitid	TRJYjgUxeQ0dX39o;

1.156
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.155;
commitid	Z1vcFtHO8wRH0yRt;

1.155
date	2014.11.15.02.42.38;	author doug;	state Exp;
branches;
next	1.154;
commitid	X2CLLbsOKPKbdBJq;

1.154
date	2014.11.14.23.11.35;	author tedu;	state Exp;
branches;
next	1.153;
commitid	ROGCZ2tQWlMtAexK;

1.153
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.152;
commitid	uzzBR7hz9ncd4O6G;

1.152
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.151;
commitid	FE3DG5cICjyI4jWx;

1.151
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.150;
commitid	EF98ch02VpFassUi;

1.150
date	2014.01.18.07.10.26;	author deraadt;	state Exp;
branches;
next	1.149;

1.149
date	2013.12.26.07.17.15;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2013.10.17.16.27.47;	author bluhm;	state Exp;
branches;
next	1.147;

1.147
date	2013.10.02.21.28.11;	author sf;	state Exp;
branches;
next	1.146;

1.146
date	2013.09.14.01.35.01;	author guenther;	state Exp;
branches;
next	1.145;

1.145
date	2013.08.13.05.52.25;	author guenther;	state Exp;
branches;
next	1.144;

1.144
date	2013.03.28.03.29.44;	author guenther;	state Exp;
branches;
next	1.143;

1.143
date	2013.03.28.02.27.27;	author tedu;	state Exp;
branches;
next	1.142;

1.142
date	2013.03.28.02.17.16;	author tedu;	state Exp;
branches;
next	1.141;

1.141
date	2013.03.27.01.56.50;	author tedu;	state Exp;
branches;
next	1.140;

1.140
date	2012.11.17.22.28.26;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.138;

1.138
date	2011.07.09.00.24.44;	author beck;	state Exp;
branches;
next	1.137;

1.137
date	2011.07.08.23.06.54;	author beck;	state Exp;
branches;
next	1.136;

1.136
date	2011.07.05.00.37.59;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2011.07.04.21.00.10;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.133;

1.133
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.132;

1.132
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.131;

1.131
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.130;

1.130
date	2010.05.19.08.31.23;	author thib;	state Exp;
branches;
next	1.129;

1.129
date	2010.04.12.16.37.38;	author beck;	state Exp;
branches;
next	1.128;

1.128
date	2010.03.29.23.33.39;	author krw;	state Exp;
branches;
next	1.127;

1.127
date	2009.12.15.15.53.48;	author beck;	state Exp;
branches;
next	1.126;

1.126
date	2009.12.10.16.41.45;	author beck;	state Exp;
branches;
next	1.125;

1.125
date	2009.10.19.22.24.18;	author jsg;	state Exp;
branches;
next	1.124;

1.124
date	2009.09.02.18.20.54;	author thib;	state Exp;
branches;
next	1.123;

1.123
date	2009.08.20.15.04.24;	author thib;	state Exp;
branches;
next	1.122;

1.122
date	2009.08.13.15.18.16;	author blambert;	state Exp;
branches;
next	1.121;

1.121
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.120;

1.120
date	2009.08.04.17.12.39;	author thib;	state Exp;
branches;
next	1.119;

1.119
date	2009.07.20.16.49.40;	author thib;	state Exp;
branches;
next	1.118;

1.118
date	2009.07.18.14.40.31;	author thib;	state Exp;
branches;
next	1.117;

1.117
date	2009.07.13.15.39.55;	author thib;	state Exp;
branches;
next	1.116;

1.116
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.115;

1.115
date	2009.06.25.15.49.26;	author thib;	state Exp;
branches;
next	1.114;

1.114
date	2009.06.06.18.06.22;	author art;	state Exp;
branches;
next	1.113;

1.113
date	2009.06.04.00.31.42;	author blambert;	state Exp;
branches;
next	1.112;

1.112
date	2009.04.13.17.51.57;	author blambert;	state Exp;
branches;
next	1.111;

1.111
date	2009.01.24.23.37.56;	author thib;	state Exp;
branches;
next	1.110;

1.110
date	2009.01.24.23.30.42;	author thib;	state Exp;
branches;
next	1.109;

1.109
date	2009.01.24.23.25.17;	author thib;	state Exp;
branches;
next	1.108;

1.108
date	2009.01.19.23.40.36;	author thib;	state Exp;
branches;
next	1.107;

1.107
date	2009.01.18.15.42.31;	author bluhm;	state Exp;
branches;
next	1.106;

1.106
date	2009.01.13.19.44.20;	author grange;	state Exp;
branches;
next	1.105;

1.105
date	2008.12.24.02.43.52;	author thib;	state Exp;
branches;
next	1.104;

1.104
date	2008.10.16.07.57.06;	author blambert;	state Exp;
branches;
next	1.103;

1.103
date	2008.09.12.16.17.57;	author thib;	state Exp;
branches;
next	1.102;

1.102
date	2008.08.21.01.17.39;	author pedro;	state Exp;
branches;
next	1.101;

1.101
date	2008.08.09.10.14.02;	author thib;	state Exp;
branches;
next	1.100;

1.100
date	2008.08.08.20.44.38;	author blambert;	state Exp;
branches;
next	1.99;

1.99
date	2008.08.08.20.40.24;	author blambert;	state Exp;
branches;
next	1.98;

1.98
date	2008.07.25.14.56.47;	author beck;	state Exp;
branches;
next	1.97;

1.97
date	2008.07.23.17.40.29;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2008.07.23.16.24.43;	author beck;	state Exp;
branches;
next	1.95;

1.95
date	2008.07.23.11.53.07;	author art;	state Exp;
branches;
next	1.94;

1.94
date	2008.07.06.16.54.48;	author thib;	state Exp;
branches;
next	1.93;

1.93
date	2008.06.14.22.44.07;	author blambert;	state Exp;
branches;
next	1.92;

1.92
date	2008.06.13.22.11.32;	author blambert;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.13.17.21.13;	author thib;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.12.20.24.06;	author blambert;	state Exp;
branches;
next	1.89;

1.89
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.10.22.59.09;	author thib;	state Exp;
branches;
next	1.85;

1.85
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.09.23.38.37;	author millert;	state Exp;
branches;
next	1.83;

1.83
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.82;

1.82
date	2008.04.22.20.59.37;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2008.04.14.13.46.13;	author blambert;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.06.17.38.23;	author blambert;	state Exp;
branches;
next	1.79;

1.79
date	2007.12.13.18.32.55;	author blambert;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.26.16.00.55;	author blambert;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.11.13.41.52;	author blambert;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.01.07.13.47;	author thib;	state Exp;
branches;
next	1.73;

1.73
date	2007.03.18.15.05.33;	author mickey;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.23.14.27.06;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.21.15.52.39;	author pedro;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.69;

1.69
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.68;

1.68
date	2006.12.06.17.49.58;	author thib;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.26.21.37.37;	author pedro;	state Exp;
branches;
next	1.66;

1.66
date	2006.04.20.14.43.32;	author pedro;	state Exp;
branches;
next	1.65;

1.65
date	2005.09.29.00.45.51;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.21.23.29.04;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2004.08.03.17.11.48;	author marius;	state Exp;
branches;
next	1.62;

1.62
date	2004.07.21.17.30.56;	author marius;	state Exp;
branches;
next	1.61;

1.61
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.14.04.00.34;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.26.18.57.36;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.02.05.46.00;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.27.17.40.17;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.02.23.28.20;	author millert;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2003.05.06.21.43.26;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.31.17.37.50;	author art;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2002.11.08.04.34.17;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2002.05.21.21.07.09;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.23.23.47.13;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.22.20.19.14;	author csapuntz;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.22.09.58.04;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.11.09.32.46;	author art;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2001.12.10.04.45.31;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.04.22.44.32;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.15.23.15.15;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.26.20.24.47;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.26.02.10.41;	author assar;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.03.01.55.13;	author csapuntz;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.27.04.58.46;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.25.03.28.13;	author csapuntz;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.25.02.15.48;	author csapuntz;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.23.02.14.26;	author csapuntz;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.05.21.56.14;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.24.19.07.11;	author csapuntz;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.23.14.52.51;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.09.22.26.05;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.02.04.59.07;	author millert;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	99.02.26.03.16.26;	author art;	state Exp;
branches;
next	1.24;

1.24
date	99.02.06.23.07.46;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	99.01.10.20.06.51;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.08.19.22.26.57;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	98.08.06.19.35.00;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	98.05.11.05.42.01;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.12.02.16.57.59;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	97.11.06.05.59.05;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	97.10.06.20.20.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.10.06.15.23.45;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	97.04.18.09.57.29;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.04.08.22.46.50;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.31.10.33.46;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.11.12.15.51.34;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.07.27.11.08.48;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.07.23.21.32.33;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.06.14.04.41.09;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.05.22.11.47.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.30.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.17.04.50.35;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.31.13.16.03;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.02.29.09.24.59;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.12.21.14.42.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.38.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.26.2.1
date	2001.05.14.22.44.58;	author niklas;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2001.07.04.10.55.52;	author niklas;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2001.11.13.22.59.59;	author niklas;	state Exp;
branches;
next	1.26.2.5;

1.26.2.5
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.26.2.6;

1.26.2.6
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.26.2.7;

1.26.2.7
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.26.2.8;

1.26.2.8
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	1.26.2.9;

1.26.2.9
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.26.2.10;

1.26.2.10
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.26.2.11;

1.26.2.11
date	2004.02.19.10.57.27;	author niklas;	state Exp;
branches;
next	1.26.2.12;

1.26.2.12
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.44.2.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2002.06.11.03.32.04;	author art;	state Exp;
branches;
next	1.44.2.4;

1.44.2.4
date	2002.10.29.18.31.51;	author art;	state Exp;
branches;
next	1.44.2.5;

1.44.2.5
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.44.2.6;

1.44.2.6
date	2003.05.19.22.36.43;	author tedu;	state Exp;
branches;
next	;

1.53.2.1
date	2004.03.01.08.33.36;	author brad;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2004.03.03.08.50.13;	author brad;	state Exp;
branches;
next	;

1.55.2.1
date	2004.03.01.03.12.56;	author brad;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2004.03.03.08.32.11;	author brad;	state Exp;
branches;
next	;

1.164.4.1
date	2015.12.08.03.38.10;	author beck;	state Exp;
branches;
next	;
commitid	vOGdxukwj5FCXNKa;


desc
@@


1.171
log
@Keep local definitions local.

"good work" deraadt@@, ok visa@@
@
text
@/*	$OpenBSD: nfs_vnops.c,v 1.170 2016/06/13 19:00:22 tedu Exp $	*/
/*	$NetBSD: nfs_vnops.c,v 1.62.4.1 1996/07/08 20:26:52 jtc Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_vnops.c	8.16 (Berkeley) 5/27/95
 */


/*
 * vnode op calls for Sun NFS version 2 and 3
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/resourcevar.h>
#include <sys/poll.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/mbuf.h>
#include <sys/conf.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/dirent.h>
#include <sys/fcntl.h>
#include <sys/lockf.h>
#include <sys/queue.h>
#include <sys/specdev.h>
#include <sys/unistd.h>

#include <miscfs/fifofs/fifo.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/nfsnode.h>
#include <nfs/nfsmount.h>
#include <nfs/xdr_subs.h>
#include <nfs/nfsm_subs.h>
#include <nfs/nfs_var.h>

#include <uvm/uvm_extern.h>

#include <netinet/in.h>

int nfs_access(void *);
int nfs_advlock(void *);
int nfs_bmap(void *);
int nfs_bwrite(void *);
int nfs_close(void *);
int nfs_commit(struct vnode *, u_quad_t, int, struct proc *);
int nfs_create(void *);
int nfs_flush(struct vnode *, struct ucred *, int, struct proc *, int);
int nfs_fsync(void *);
int nfs_getattr(void *);
int nfs_getreq(struct nfsrv_descript *, struct nfsd *, int);
int nfs_link(void *);
int nfs_lookitup(struct vnode *, char *, int, struct ucred *, struct proc *,
	struct nfsnode **);
int nfs_lookup(void *);
int nfs_mkdir(void *);
int nfs_mknod(void *);
int nfs_mknodrpc(struct vnode *, struct vnode **, struct componentname *,
	struct vattr *);
int nfs_null(struct vnode *, struct ucred *, struct proc *);
int nfs_open(void *);
int nfs_pathconf(void *);
int nfs_poll(void *);
int nfs_print(void *);
int nfs_read(void *);
int nfs_readdir(void *);
int nfs_readdirplusrpc(struct vnode *, struct uio *, struct ucred *, int *,
	struct proc *);
int nfs_readdirrpc(struct vnode *, struct uio *, struct ucred *, int *);
int nfs_remove(void *);
int nfs_removerpc(struct vnode *, char *, int, struct ucred *, struct proc *);
int nfs_rename(void *);
int nfs_renameit(struct vnode *, struct componentname *, struct sillyrename *);
int nfs_renamerpc(struct vnode *, char *, int, struct vnode *, char *, int,
	struct ucred *, struct proc *);
int nfs_rmdir(void *);
int nfs_setattr(void *);
int nfs_setattrrpc(struct vnode *, struct vattr *, struct ucred *,
	struct proc *);
int nfs_sillyrename(struct vnode *, struct vnode *,
			 struct componentname *);
int nfs_strategy(void *);
int nfs_symlink(void *);

void nfs_cache_enter(struct vnode *, struct vnode *, struct componentname *);

int nfsfifo_close(void *);
int nfsfifo_read(void *);
int nfsfifo_reclaim(void *);
int nfsfifo_write(void *);

int nfsspec_access(void *);
int nfsspec_close(void *);
int nfsspec_read(void *);
int nfsspec_write(void *);

/* Global vfs data structures for nfs. */
struct vops nfs_vops = {
	.vop_lookup	= nfs_lookup,
	.vop_create	= nfs_create,
	.vop_mknod	= nfs_mknod,
	.vop_open	= nfs_open,
	.vop_close	= nfs_close,
	.vop_access	= nfs_access,
	.vop_getattr	= nfs_getattr,
	.vop_setattr	= nfs_setattr,
	.vop_read	= nfs_read,
	.vop_write	= nfs_write,
	.vop_ioctl	= nfs_ioctl,
	.vop_poll	= nfs_poll,
	.vop_kqfilter	= nfs_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= nfs_fsync,
	.vop_remove	= nfs_remove,
	.vop_link	= nfs_link,
	.vop_rename	= nfs_rename,
	.vop_mkdir	= nfs_mkdir,
	.vop_rmdir	= nfs_rmdir,
	.vop_symlink	= nfs_symlink,
	.vop_readdir	= nfs_readdir,
	.vop_readlink	= nfs_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= nfs_inactive,
	.vop_reclaim	= nfs_reclaim,
	.vop_lock	= vop_generic_lock,	/* XXX: beck@@ must fix this. */
	.vop_unlock	= vop_generic_unlock,
	.vop_bmap	= nfs_bmap,
	.vop_strategy	= nfs_strategy,
	.vop_print	= nfs_print,
	.vop_islocked	= vop_generic_islocked,
	.vop_pathconf	= nfs_pathconf,
	.vop_advlock	= nfs_advlock,
	.vop_bwrite	= nfs_bwrite
};

/* Special device vnode ops. */
struct vops nfs_specvops = {
	.vop_close	= nfsspec_close,
	.vop_access	= nfsspec_access,
	.vop_getattr	= nfs_getattr,
	.vop_setattr	= nfs_setattr,
	.vop_read	= nfsspec_read,
	.vop_write	= nfsspec_write,
	.vop_fsync	= nfs_fsync,
	.vop_inactive	= nfs_inactive,
	.vop_reclaim	= nfs_reclaim,
	.vop_lock	= vop_generic_lock,
	.vop_unlock	= vop_generic_unlock,
	.vop_print	= nfs_print,
	.vop_islocked	= vop_generic_islocked,

	/* XXX: Keep in sync with spec_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
};

#ifdef FIFO
struct vops nfs_fifovops = {
	.vop_close	= nfsfifo_close,
	.vop_access	= nfsspec_access,
	.vop_getattr	= nfs_getattr,
	.vop_setattr	= nfs_setattr,
	.vop_read	= nfsfifo_read,
	.vop_write	= nfsfifo_write,
	.vop_fsync	= nfs_fsync,
	.vop_inactive	= nfs_inactive,
	.vop_reclaim	= nfsfifo_reclaim,
	.vop_lock	= vop_generic_lock,
	.vop_unlock	= vop_generic_unlock,
	.vop_print	= nfs_print,
	.vop_islocked	= vop_generic_islocked,
	.vop_bwrite	= vop_generic_bwrite,

	/* XXX: Keep in sync with fifo_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock,
};
#endif /* FIFO */

/*
 * Global variables
 */
extern u_int32_t nfs_true, nfs_false;
extern u_int32_t nfs_xdrneg1;
extern struct nfsstats nfsstats;
extern nfstype nfsv3_type[9];
int nfs_numasync = 0;

void
nfs_cache_enter(struct vnode *dvp, struct vnode *vp, struct componentname *cnp)
{
	struct nfsnode *np;

	if (vp != NULL) {
		np = VTONFS(vp);
		np->n_ctime = np->n_vattr.va_ctime.tv_sec;
	} else {
		np = VTONFS(dvp);
		if (!np->n_ctime)
			np->n_ctime = np->n_vattr.va_mtime.tv_sec;
	}

	cache_enter(dvp, vp, cnp);
}

/*
 * nfs null call from vfs.
 */
int
nfs_null(struct vnode *vp, struct ucred *cred, struct proc *procp)
{
	struct nfsm_info	 info;
	int			 error = 0;

	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(0);
	error = nfs_request(vp, NFSPROC_NULL, &info);
	m_freem(info.nmi_mrep);
	return (error);
}

/*
 * nfs access vnode op.
 * For nfs version 2, just return ok. File accesses may fail later.
 * For nfs version 3, use the access rpc to check accessibility. If file modes
 * are changed on the server, accesses might still fail later.
 */
int
nfs_access(void *v)
{
	struct vop_access_args *ap = v;
	struct vnode *vp = ap->a_vp;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	int error = 0, attrflag;
	u_int32_t mode, rmode;
	int v3 = NFS_ISV3(vp);
	int cachevalid;
	struct nfsm_info	info;

	struct nfsnode *np = VTONFS(vp);

	/*
	 * Disallow write attempts on filesystems mounted read-only;
	 * unless the file is a socket, fifo, or a block or character
	 * device resident on the filesystem.
	 */
	if ((ap->a_mode & VWRITE) && (vp->v_mount->mnt_flag & MNT_RDONLY)) {
		switch (vp->v_type) {
		case VREG:
		case VDIR:
		case VLNK:
			return (EROFS);
		default:
			break;
		}
	}

	/*
	 * Check access cache first. If a request has been made for this uid
	 * shortly before, use the cached result.
	 */
	 cachevalid = (np->n_accstamp != -1 &&
	     (time_second - np->n_accstamp) < nfs_attrtimeo(np) &&
	     np->n_accuid == ap->a_cred->cr_uid);

	if (cachevalid) {
		if (!np->n_accerror) {
			if ((np->n_accmode & ap->a_mode) == ap->a_mode)
				return (np->n_accerror);
		} else if ((np->n_accmode & ap->a_mode) == np->n_accmode)
			return (np->n_accerror);
	}

	/*
	 * For nfs v3, do an access rpc, otherwise you are stuck emulating
	 * ufs_access() locally using the vattr. This may not be correct,
	 * since the server may apply other access criteria such as
	 * client uid-->server uid mapping that we do not know about, but
	 * this is better than just returning anything that is lying about
	 * in the cache.
	 */
	if (v3) {
		nfsstats.rpccnt[NFSPROC_ACCESS]++;
		info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_UNSIGNED);
		nfsm_fhtom(&info, vp, v3);
		tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
		if (ap->a_mode & VREAD)
			mode = NFSV3ACCESS_READ;
		else
			mode = 0;
		if (vp->v_type == VDIR) {
			if (ap->a_mode & VWRITE)
				mode |= (NFSV3ACCESS_MODIFY | NFSV3ACCESS_EXTEND |
					 NFSV3ACCESS_DELETE);
			if (ap->a_mode & VEXEC)
				mode |= NFSV3ACCESS_LOOKUP;
		} else {
			if (ap->a_mode & VWRITE)
				mode |= (NFSV3ACCESS_MODIFY | NFSV3ACCESS_EXTEND);
			if (ap->a_mode & VEXEC)
				mode |= NFSV3ACCESS_EXECUTE;
		}
		*tl = txdr_unsigned(mode);

		info.nmi_procp = ap->a_p;
		info.nmi_cred = ap->a_cred;
		error = nfs_request(vp, NFSPROC_ACCESS, &info);

		nfsm_postop_attr(vp, attrflag);
		if (error) {
			m_freem(info.nmi_mrep);
			goto nfsmout;
		}

		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		rmode = fxdr_unsigned(u_int32_t, *tl);
		/*
		 * The NFS V3 spec does not clarify whether or not
		 * the returned access bits can be a superset of
		 * the ones requested, so...
		 */
		if ((rmode & mode) != mode)
			error = EACCES;

		m_freem(info.nmi_mrep);
	} else
		return (nfsspec_access(ap));


	/*
	 * If we got the same result as for a previous, different request, OR
	 * it in. Don't update the timestamp in that case.
	 */
	 if (!error || error == EACCES) {
		if (cachevalid && np->n_accstamp != -1 &&
		    error == np->n_accerror) {
			if (!error)
				np->n_accmode |= ap->a_mode;
			else {
				if ((np->n_accmode & ap->a_mode) == ap->a_mode)
					np->n_accmode = ap->a_mode;
			}
		} else {
			np->n_accstamp = time_second;
			np->n_accuid = ap->a_cred->cr_uid;
			np->n_accmode = ap->a_mode;
			np->n_accerror = error;
		}
	}
nfsmout:
	return (error);
}

/*
 * nfs open vnode op
 * Check to see if the type is ok
 * and that deletion is not in progress.
 * For paged in text files, you will need to flush the page cache
 * if consistency is lost.
 */
int
nfs_open(void *v)
{
	struct vop_open_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct vattr vattr;
	int error;

	if (vp->v_type != VREG && vp->v_type != VDIR && vp->v_type != VLNK) {
#ifdef DIAGNOSTIC
		printf("open eacces vtyp=%d\n",vp->v_type);
#endif
		return (EACCES);
	}

	/*
	 * Initialize read and write creds here, for swapfiles
	 * and other paths that don't set the creds themselves.
	 */

	if (ap->a_mode & FREAD) {
		if (np->n_rcred) {
			crfree(np->n_rcred);
		}
		np->n_rcred = ap->a_cred;
		crhold(np->n_rcred);
	}
	if (ap->a_mode & FWRITE) {
		if (np->n_wcred) {
			crfree(np->n_wcred);
		}
		np->n_wcred = ap->a_cred;
		crhold(np->n_wcred);
	}

	if (np->n_flag & NMODIFIED) {
		error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p);
		if (error == EINTR)
			return (error);
		uvm_vnp_uncache(vp);
		NFS_INVALIDATE_ATTRCACHE(np);
		if (vp->v_type == VDIR)
			np->n_direofoffset = 0;
		error = VOP_GETATTR(vp, &vattr, ap->a_cred, ap->a_p);
		if (error)
			return (error);
		np->n_mtime = vattr.va_mtime;
	} else {
		error = VOP_GETATTR(vp, &vattr, ap->a_cred, ap->a_p);
		if (error)
			return (error);
		if (timespeccmp(&np->n_mtime, &vattr.va_mtime, !=)) {
			if (vp->v_type == VDIR)
				np->n_direofoffset = 0;
			error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p);
			if (error == EINTR)
				return (error);
			uvm_vnp_uncache(vp);
			np->n_mtime = vattr.va_mtime;
		}
	}
	/* For open/close consistency. */
	NFS_INVALIDATE_ATTRCACHE(np);
	return (0);
}

/*
 * nfs close vnode op
 * What an NFS client should do upon close after writing is a debatable issue.
 * Most NFS clients push delayed writes to the server upon close, basically for
 * two reasons:
 * 1 - So that any write errors may be reported back to the client process
 *     doing the close system call. By far the two most likely errors are
 *     NFSERR_NOSPC and NFSERR_DQUOT to indicate space allocation failure.
 * 2 - To put a worst case upper bound on cache inconsistency between
 *     multiple clients for the file.
 * There is also a consistency problem for Version 2 of the protocol w.r.t.
 * not being able to tell if other clients are writing a file concurrently,
 * since there is no way of knowing if the changed modify time in the reply
 * is only due to the write for this client.
 * (NFS Version 3 provides weak cache consistency data in the reply that
 *  should be sufficient to detect and handle this case.)
 *
 * The current code does the following:
 * for NFS Version 2 - play it safe and flush/invalidate all dirty buffers
 * for NFS Version 3 - flush dirty buffers to the server but don't invalidate
 *		       or commit them (this satisfies 1 and 2 except for the
 *		       case where the server crashes after this close but
 *		       before the commit RPC, which is felt to be "good
 *		       enough". Changing the last argument to nfs_flush() to
 *		       a 1 would force a commit operation, if it is felt a
 *		       commit is necessary now.
 */
int
nfs_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	int error = 0;

	if (vp->v_type == VREG) {
	    if (np->n_flag & NMODIFIED) {
		if (NFS_ISV3(vp)) {
		    error = nfs_flush(vp, ap->a_cred, MNT_WAIT, ap->a_p, 0);
		    np->n_flag &= ~NMODIFIED;
		} else
		    error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p);
		NFS_INVALIDATE_ATTRCACHE(np);
	    }
	    if (np->n_flag & NWRITEERR) {
		np->n_flag &= ~NWRITEERR;
		error = np->n_error;
	    }
	}
	return (error);
}

/*
 * nfs getattr call from vfs.
 */
int
nfs_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct nfsm_info	info;
	int32_t t1;
	int error = 0;

	info.nmi_v3 = NFS_ISV3(vp);

	/*
	 * Update local times for special files.
	 */
	if (np->n_flag & (NACC | NUPD))
		np->n_flag |= NCHG;
	/*
	 * First look in the cache.
	 */
	if (nfs_getattrcache(vp, ap->a_vap) == 0)
		return (0);

	nfsstats.rpccnt[NFSPROC_GETATTR]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3));
	nfsm_fhtom(&info, vp, info.nmi_v3);
	info.nmi_procp = ap->a_p;
	info.nmi_cred = ap->a_cred;
	error = nfs_request(vp, NFSPROC_GETATTR, &info);
	if (!error)
		nfsm_loadattr(vp, ap->a_vap);
	m_freem(info.nmi_mrep);
nfsmout: 
	return (error);
}

/*
 * nfs setattr call.
 */
int
nfs_setattr(void *v)
{
	struct vop_setattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct vattr *vap = ap->a_vap;
	int hint = NOTE_ATTRIB;
	int error = 0;
	u_quad_t tsize = 0;

	/*
	 * Setting of flags is not supported.
	 */
	if (vap->va_flags != VNOVAL)
		return (EOPNOTSUPP);

	/*
	 * Disallow write attempts if the filesystem is mounted read-only.
	 */
	if ((vap->va_uid != (uid_t)VNOVAL ||
	    vap->va_gid != (gid_t)VNOVAL ||
	    vap->va_atime.tv_nsec != VNOVAL ||
	    vap->va_mtime.tv_nsec != VNOVAL ||
	    vap->va_mode != (mode_t)VNOVAL) &&
	    (vp->v_mount->mnt_flag & MNT_RDONLY))
		return (EROFS);
	if (vap->va_size != VNOVAL) {
		switch (vp->v_type) {
		case VDIR:
			return (EISDIR);
		case VCHR:
		case VBLK:
		case VSOCK:
		case VFIFO:
			if (vap->va_mtime.tv_nsec == VNOVAL &&
			    vap->va_atime.tv_nsec == VNOVAL &&
			    vap->va_mode == (mode_t)VNOVAL &&
			    vap->va_uid == (uid_t)VNOVAL &&
			    vap->va_gid == (gid_t)VNOVAL)
				return (0);
			vap->va_size = VNOVAL;
			break;
		default:
			/*
			 * Disallow write attempts if the filesystem is
			 * mounted read-only.
			 */
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
			if (vap->va_size == 0)
				error = nfs_vinvalbuf(vp, 0,
				     ap->a_cred, ap->a_p);
			else
				error = nfs_vinvalbuf(vp, V_SAVE,
				     ap->a_cred, ap->a_p);
			if (error)
				return (error);
			tsize = np->n_size;
			np->n_size = np->n_vattr.va_size = vap->va_size;
			uvm_vnp_setsize(vp, np->n_size);
		};
	} else if ((vap->va_mtime.tv_nsec != VNOVAL ||
		vap->va_atime.tv_nsec != VNOVAL) &&
		vp->v_type == VREG &&
		(error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred,
		    ap->a_p)) == EINTR)
		return (error);
	error = nfs_setattrrpc(vp, vap, ap->a_cred, ap->a_p);
	if (error && vap->va_size != VNOVAL) {
		np->n_size = np->n_vattr.va_size = tsize;
		uvm_vnp_setsize(vp, np->n_size);
	}

	if (vap->va_size != VNOVAL && vap->va_size < tsize)
		hint |= NOTE_TRUNCATE;

	VN_KNOTE(vp, hint); /* XXX setattrrpc? */

	return (error);
}

/*
 * Do an nfs setattr rpc.
 */
int
nfs_setattrrpc(struct vnode *vp, struct vattr *vap, struct ucred *cred,
    struct proc *procp)
{
	struct nfsv2_sattr *sp;
	struct nfsm_info	info;
	int32_t t1;
	caddr_t cp2;
	u_int32_t *tl;
	int error = 0, wccflag = NFSV3_WCCRATTR;
	int v3 = NFS_ISV3(vp);

	info.nmi_v3 = NFS_ISV3(vp);

	nfsstats.rpccnt[NFSPROC_SETATTR]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_SATTR(v3));
	nfsm_fhtom(&info, vp, v3);

	if (info.nmi_v3) {
		nfsm_v3attrbuild(&info.nmi_mb, vap, 1);
		tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
		*tl = nfs_false;
	} else {
		sp = nfsm_build(&info.nmi_mb, NFSX_V2SATTR);
		if (vap->va_mode == (mode_t)VNOVAL)
			sp->sa_mode = nfs_xdrneg1;
		else
			sp->sa_mode = vtonfsv2_mode(vp->v_type, vap->va_mode);
		if (vap->va_uid == (uid_t)VNOVAL)
			sp->sa_uid = nfs_xdrneg1;
		else
			sp->sa_uid = txdr_unsigned(vap->va_uid);
		if (vap->va_gid == (gid_t)VNOVAL)
			sp->sa_gid = nfs_xdrneg1;
		else
			sp->sa_gid = txdr_unsigned(vap->va_gid);
		sp->sa_size = txdr_unsigned(vap->va_size);
		txdr_nfsv2time(&vap->va_atime, &sp->sa_atime);
		txdr_nfsv2time(&vap->va_mtime, &sp->sa_mtime);
	}

	info.nmi_procp = procp;
	info.nmi_cred = cred;
	error = nfs_request(vp, NFSPROC_SETATTR, &info);

	if (info.nmi_v3)
		nfsm_wcc_data(vp, wccflag);
	else if (error == 0)
		nfsm_loadattr(vp, NULL);

	m_freem(info.nmi_mrep);
nfsmout: 
	return (error);
}

/*
 * nfs lookup call, one step at a time...
 * First look in cache
 * If not found, unlock the directory nfsnode and do the rpc
 */
int
nfs_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct componentname *cnp = ap->a_cnp;
	struct vnode *dvp = ap->a_dvp;
	struct vnode **vpp = ap->a_vpp;
	struct proc *p = cnp->cn_proc;
	struct nfsm_info	info;
	int flags;
	struct vnode *newvp;
	u_int32_t *tl;
	int32_t t1;
	struct nfsmount *nmp;
	caddr_t cp2;
	long len;
	nfsfh_t *fhp;
	struct nfsnode *np;
	int lockparent, wantparent, error = 0, attrflag, fhsize;

	info.nmi_v3 = NFS_ISV3(dvp);

	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

	*vpp = NULLVP;
	if ((flags & ISLASTCN) && (dvp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);
	if (dvp->v_type != VDIR)
		return (ENOTDIR);
	lockparent = flags & LOCKPARENT;
	wantparent = flags & (LOCKPARENT|WANTPARENT);
	nmp = VFSTONFS(dvp->v_mount);
	np = VTONFS(dvp);

	/*
	 * Before tediously performing a linear scan of the directory,
	 * check the name cache to see if the directory/name pair
	 * we are looking for is known already.
	 * If the directory/name pair is found in the name cache,
	 * we have to ensure the directory has not changed from
	 * the time the cache entry has been created. If it has,
	 * the cache entry has to be ignored.
	 */
	if ((error = cache_lookup(dvp, vpp, cnp)) >= 0) {
		struct vattr vattr;
		int err2;

		if (error && error != ENOENT) {
			*vpp = NULLVP;
			return (error);
		}

		if (cnp->cn_flags & PDIRUNLOCK) {
			err2 = vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
			if (err2 != 0) {
				*vpp = NULLVP;
				return (err2);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}

		err2 = VOP_ACCESS(dvp, VEXEC, cnp->cn_cred, cnp->cn_proc);
		if (err2 != 0) {
			if (error == 0) {
				if (*vpp != dvp)
					vput(*vpp);
				else
					vrele(*vpp);
			}
			*vpp = NULLVP;
			return (err2);
		}

		if (error == ENOENT) {
			if (!VOP_GETATTR(dvp, &vattr, cnp->cn_cred,
			    cnp->cn_proc) && vattr.va_mtime.tv_sec ==
			    VTONFS(dvp)->n_ctime)
				return (ENOENT);
			cache_purge(dvp);
			np->n_ctime = 0;
			goto dorpc;
		}

		newvp = *vpp;
		if (!VOP_GETATTR(newvp, &vattr, cnp->cn_cred, cnp->cn_proc)
			&& vattr.va_ctime.tv_sec == VTONFS(newvp)->n_ctime)
		{
			nfsstats.lookupcache_hits++;
			if (cnp->cn_nameiop != LOOKUP && (flags & ISLASTCN))
				cnp->cn_flags |= SAVENAME;
			if ((!lockparent || !(flags & ISLASTCN)) &&
			     newvp != dvp)
				VOP_UNLOCK(dvp, p);
			return (0);
		}
		cache_purge(newvp);
		if (newvp != dvp)
			vput(newvp);
		else
			vrele(newvp);
		*vpp = NULLVP;
	}
dorpc:
	error = 0;
	newvp = NULLVP;
	nfsstats.lookupcache_misses++;
	nfsstats.rpccnt[NFSPROC_LOOKUP]++;
	len = cnp->cn_namelen;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) +
	    NFSX_UNSIGNED + nfsm_rndup(len));
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(cnp->cn_nameptr, len, NFS_MAXNAMLEN);

	info.nmi_procp = cnp->cn_proc;
	info.nmi_cred = cnp->cn_cred;
	error = nfs_request(dvp, NFSPROC_LOOKUP, &info);

	if (error) {
		if (info.nmi_v3)
			nfsm_postop_attr(dvp, attrflag);
		m_freem(info.nmi_mrep);
		goto nfsmout;
	}

	nfsm_getfh(fhp, fhsize, info.nmi_v3);

	/*
	 * Handle RENAME case...
	 */
	if (cnp->cn_nameiop == RENAME && wantparent && (flags & ISLASTCN)) {
		if (NFS_CMPFH(np, fhp, fhsize)) {
			m_freem(info.nmi_mrep);
			return (EISDIR);
		}
		error = nfs_nget(dvp->v_mount, fhp, fhsize, &np);
		if (error) {
			m_freem(info.nmi_mrep);
			return (error);
		}
		newvp = NFSTOV(np);
		if (info.nmi_v3) {
			nfsm_postop_attr(newvp, attrflag);
			nfsm_postop_attr(dvp, attrflag);
		} else
			nfsm_loadattr(newvp, NULL);
		*vpp = newvp;
		m_freem(info.nmi_mrep);
		cnp->cn_flags |= SAVENAME;
		if (!lockparent) {
			VOP_UNLOCK(dvp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (0);
	}

	/*
	 * The postop attr handling is duplicated for each if case,
	 * because it should be done while dvp is locked (unlocking
	 * dvp is different for each case).
	 */

	if (NFS_CMPFH(np, fhp, fhsize)) {
		vref(dvp);
		newvp = dvp;
		if (info.nmi_v3) {
			nfsm_postop_attr(newvp, attrflag);
			nfsm_postop_attr(dvp, attrflag);
		} else
			nfsm_loadattr(newvp, NULL);
	} else if (flags & ISDOTDOT) {
		VOP_UNLOCK(dvp, p);
		cnp->cn_flags |= PDIRUNLOCK;

		error = nfs_nget(dvp->v_mount, fhp, fhsize, &np);
		if (error) {
			if (vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
			m_freem(info.nmi_mrep);
			return (error);
		}
		newvp = NFSTOV(np);

		if (info.nmi_v3) {
			nfsm_postop_attr(newvp, attrflag);
			nfsm_postop_attr(dvp, attrflag);
		} else
			nfsm_loadattr(newvp, NULL);

		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(dvp, LK_EXCLUSIVE, p))) {
				m_freem(info.nmi_mrep);
				vput(newvp);
				return error;
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}

	} else {
		error = nfs_nget(dvp->v_mount, fhp, fhsize, &np);
		if (error) {
			m_freem(info.nmi_mrep);
			return error;
		}
		newvp = NFSTOV(np);
		if (info.nmi_v3) {
			nfsm_postop_attr(newvp, attrflag);
			nfsm_postop_attr(dvp, attrflag);
		} else
			nfsm_loadattr(newvp, NULL);
		if (!lockparent || !(flags & ISLASTCN)) {
			VOP_UNLOCK(dvp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
	}

	if (cnp->cn_nameiop != LOOKUP && (flags & ISLASTCN))
		cnp->cn_flags |= SAVENAME;
	if ((cnp->cn_flags & MAKEENTRY) &&
	    (cnp->cn_nameiop != DELETE || !(flags & ISLASTCN))) {
		nfs_cache_enter(dvp, newvp, cnp);
	}

	*vpp = newvp;
	m_freem(info.nmi_mrep);

nfsmout: 
	if (error) {
		/*
		 * We get here only because of errors returned by
		 * the RPC. Otherwise we'll have returned above
		 * (the nfsm_* macros will jump to nfsmout
		 * on error).
		 */
		if (error == ENOENT && (cnp->cn_flags & MAKEENTRY) &&
		    cnp->cn_nameiop != CREATE) {
			nfs_cache_enter(dvp, NULL, cnp);
		}
		if (newvp != NULLVP) {
			vrele(newvp);
			if (newvp != dvp)
				VOP_UNLOCK(newvp, p);
		}
		if ((cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME) &&
		    (flags & ISLASTCN) && error == ENOENT) {
			if (dvp->v_mount->mnt_flag & MNT_RDONLY)
				error = EROFS;
			else
				error = EJUSTRETURN;
		}
		if (cnp->cn_nameiop != LOOKUP && (flags & ISLASTCN))
			cnp->cn_flags |= SAVENAME;
		*vpp = NULL;
	}
	return (error);
}

/*
 * nfs read call.
 * Just call nfs_bioread() to do the work.
 */
int
nfs_read(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp = ap->a_vp;

	if (vp->v_type != VREG)
		return (EPERM);
	return (nfs_bioread(vp, ap->a_uio, ap->a_ioflag, ap->a_cred));
}

/*
 * nfs readlink call
 */
int
nfs_readlink(void *v)
{
	struct vop_readlink_args *ap = v;
	struct vnode *vp = ap->a_vp;

	if (vp->v_type != VLNK)
		return (EPERM);
	return (nfs_bioread(vp, ap->a_uio, 0, ap->a_cred));
}

/*
 * Do a readlink rpc.
 * Called by nfs_doio() from below the buffer cache.
 */
int
nfs_readlinkrpc(struct vnode *vp, struct uio *uiop, struct ucred *cred)
{
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	int error = 0, len, attrflag;

	info.nmi_v3 = NFS_ISV3(vp);

	nfsstats.rpccnt[NFSPROC_READLINK]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3));
	nfsm_fhtom(&info, vp, info.nmi_v3);

	info.nmi_procp = curproc;
	info.nmi_cred = cred;
	error = nfs_request(vp, NFSPROC_READLINK, &info);

	if (info.nmi_v3)
		nfsm_postop_attr(vp, attrflag);
	if (!error) {
		nfsm_strsiz(len, NFS_MAXPATHLEN);
		nfsm_mtouio(uiop, len);
	}

	m_freem(info.nmi_mrep);

nfsmout: 
	return (error);
}

/*
 * nfs read rpc call
 * Ditto above
 */
int
nfs_readrpc(struct vnode *vp, struct uio *uiop)
{
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	struct nfsmount *nmp;
	int error = 0, len, retlen, tsiz, eof, attrflag;

	info.nmi_v3 = NFS_ISV3(vp);

	eof = 0;

	nmp = VFSTONFS(vp->v_mount);
	tsiz = uiop->uio_resid;
	if (uiop->uio_offset + tsiz > 0xffffffff && !info.nmi_v3)
		return (EFBIG);
	while (tsiz > 0) {
		nfsstats.rpccnt[NFSPROC_READ]++;
		len = (tsiz > nmp->nm_rsize) ? nmp->nm_rsize : tsiz;
		info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) +
		    NFSX_UNSIGNED * 3);
		nfsm_fhtom(&info, vp, info.nmi_v3);
		tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED * 3);
		if (info.nmi_v3) {
			txdr_hyper(uiop->uio_offset, tl);
			*(tl + 2) = txdr_unsigned(len);
		} else {
			*tl++ = txdr_unsigned(uiop->uio_offset);
			*tl++ = txdr_unsigned(len);
			*tl = 0;
		}

		info.nmi_procp = curproc;
		info.nmi_cred = VTONFS(vp)->n_rcred;
		error = nfs_request(vp, NFSPROC_READ, &info);
		if (info.nmi_v3)
			nfsm_postop_attr(vp, attrflag);
		if (error) {
			m_freem(info.nmi_mrep);
			goto nfsmout;
		}

		if (info.nmi_v3) {
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			eof = fxdr_unsigned(int, *(tl + 1));
		} else {
			nfsm_loadattr(vp, NULL);
		}

		nfsm_strsiz(retlen, nmp->nm_rsize);
		nfsm_mtouio(uiop, retlen);
		m_freem(info.nmi_mrep);
		tsiz -= retlen;
		if (info.nmi_v3) {
			if (eof || retlen == 0)
				tsiz = 0;
		} else if (retlen < len)
			tsiz = 0;
	}

nfsmout:
	return (error);
}

/*
 * nfs write call
 */
int
nfs_writerpc(struct vnode *vp, struct uio *uiop, int *iomode, int *must_commit)
{
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1, backup;
	caddr_t cp2;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	int error = 0, len, tsiz, wccflag = NFSV3_WCCRATTR, rlen, commit;
	int committed = NFSV3WRITE_FILESYNC;

	info.nmi_v3 = NFS_ISV3(vp);

#ifdef DIAGNOSTIC
	if (uiop->uio_iovcnt != 1)
		panic("nfs: writerpc iovcnt > 1");
#endif
	*must_commit = 0;
	tsiz = uiop->uio_resid;
	if (uiop->uio_offset + tsiz > 0xffffffff && !info.nmi_v3)
		return (EFBIG);
	while (tsiz > 0) {
		nfsstats.rpccnt[NFSPROC_WRITE]++;
		len = (tsiz > nmp->nm_wsize) ? nmp->nm_wsize : tsiz;
		info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3)
		    + 5 * NFSX_UNSIGNED + nfsm_rndup(len));
		nfsm_fhtom(&info, vp, info.nmi_v3);
		if (info.nmi_v3) {
			tl = nfsm_build(&info.nmi_mb, 5 * NFSX_UNSIGNED);
			txdr_hyper(uiop->uio_offset, tl);
			tl += 2;
			*tl++ = txdr_unsigned(len);
			*tl++ = txdr_unsigned(*iomode);
			*tl = txdr_unsigned(len);
		} else {
			u_int32_t x;

			tl = nfsm_build(&info.nmi_mb, 4 * NFSX_UNSIGNED);
			/* Set both "begin" and "current" to non-garbage. */
			x = txdr_unsigned((u_int32_t)uiop->uio_offset);
			*tl++ = x;	/* "begin offset" */
			*tl++ = x;	/* "current offset" */
			x = txdr_unsigned(len);
			*tl++ = x;	/* total to this offset */
			*tl = x;	/* size of this write */

		}
		nfsm_uiotombuf(&info.nmi_mb, uiop, len);

		info.nmi_procp = curproc;
		info.nmi_cred = VTONFS(vp)->n_wcred;
		error = nfs_request(vp, NFSPROC_WRITE, &info);
		if (info.nmi_v3) {
			wccflag = NFSV3_WCCCHK;
			nfsm_wcc_data(vp, wccflag);
		}

		if (error) {
			m_freem(info.nmi_mrep);
			goto nfsmout;
		}

		if (info.nmi_v3) {
			wccflag = NFSV3_WCCCHK;
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED
				+ NFSX_V3WRITEVERF);
			rlen = fxdr_unsigned(int, *tl++);
			if (rlen == 0) {
				error = NFSERR_IO;
				break;
			} else if (rlen < len) {
				backup = len - rlen;
				uiop->uio_iov->iov_base =
				    (char *)uiop->uio_iov->iov_base -
				    backup;
				uiop->uio_iov->iov_len += backup;
				uiop->uio_offset -= backup;
				uiop->uio_resid += backup;
				len = rlen;
			}
			commit = fxdr_unsigned(int, *tl++);

			/*
			 * Return the lowest committment level
			 * obtained by any of the RPCs.
			 */
			if (committed == NFSV3WRITE_FILESYNC)
				committed = commit;
			else if (committed == NFSV3WRITE_DATASYNC &&
				commit == NFSV3WRITE_UNSTABLE)
				committed = commit;
			if ((nmp->nm_flag & NFSMNT_HASWRITEVERF) == 0) {
				bcopy(tl, nmp->nm_verf,
				    NFSX_V3WRITEVERF);
				nmp->nm_flag |= NFSMNT_HASWRITEVERF;
			} else if (bcmp(tl,
			    nmp->nm_verf, NFSX_V3WRITEVERF)) {
				*must_commit = 1;
				bcopy(tl, nmp->nm_verf,
				    NFSX_V3WRITEVERF);
			}
		} else {
			nfsm_loadattr(vp, NULL);
		}
		if (wccflag)
		    VTONFS(vp)->n_mtime = VTONFS(vp)->n_vattr.va_mtime;
		m_freem(info.nmi_mrep);
		tsiz -= len;
	}
nfsmout:
	*iomode = committed;
	if (error)
		uiop->uio_resid = tsiz;
	return (error);
}

/*
 * nfs mknod rpc
 * For NFS v2 this is a kludge. Use a create rpc but with the IFMT bits of the
 * mode set to specify the file type and the size field for rdev.
 */
int
nfs_mknodrpc(struct vnode *dvp, struct vnode **vpp, struct componentname *cnp,
    struct vattr *vap)
{
	struct nfsv2_sattr *sp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	struct vnode *newvp = NULL;
	struct nfsnode *np = NULL;
	char *cp2;
	int error = 0, wccflag = NFSV3_WCCRATTR, gotvp = 0;
	u_int32_t rdev;

	info.nmi_v3 = NFS_ISV3(dvp);

	if (vap->va_type == VCHR || vap->va_type == VBLK)
		rdev = txdr_unsigned(vap->va_rdev);
	else if (vap->va_type == VFIFO || vap->va_type == VSOCK)
		rdev = nfs_xdrneg1;
	else {
		VOP_ABORTOP(dvp, cnp);
		vput(dvp);
		return (EOPNOTSUPP);
	}
	nfsstats.rpccnt[NFSPROC_MKNOD]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) +
	    4 * NFSX_UNSIGNED + nfsm_rndup(cnp->cn_namelen) +
	    NFSX_SATTR(info.nmi_v3));
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(cnp->cn_nameptr, cnp->cn_namelen, NFS_MAXNAMLEN);

	if (info.nmi_v3) {
		tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
		*tl++ = vtonfsv3_type(vap->va_type);
		nfsm_v3attrbuild(&info.nmi_mb, vap, 0);
		if (vap->va_type == VCHR || vap->va_type == VBLK) {
			tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED);
			*tl++ = txdr_unsigned(major(vap->va_rdev));
			*tl = txdr_unsigned(minor(vap->va_rdev));
		}
	} else {
		sp = nfsm_build(&info.nmi_mb, NFSX_V2SATTR);
		sp->sa_mode = vtonfsv2_mode(vap->va_type, vap->va_mode);
		sp->sa_uid = nfs_xdrneg1;
		sp->sa_gid = nfs_xdrneg1;
		sp->sa_size = rdev;
		txdr_nfsv2time(&vap->va_atime, &sp->sa_atime);
		txdr_nfsv2time(&vap->va_mtime, &sp->sa_mtime);
	}

	KASSERT(cnp->cn_proc == curproc);
	info.nmi_procp = cnp->cn_proc;
	info.nmi_cred = cnp->cn_cred;
	error = nfs_request(dvp, NFSPROC_MKNOD, &info);
	if (!error) {
		nfsm_mtofh(dvp, newvp, info.nmi_v3, gotvp);
		if (!gotvp) {
			if (newvp) {
				vrele(newvp);
				newvp = NULL;
			}
			error = nfs_lookitup(dvp, cnp->cn_nameptr,
			    cnp->cn_namelen, cnp->cn_cred, cnp->cn_proc, &np);
			if (!error)
				newvp = NFSTOV(np);
		}
	}
	if (info.nmi_v3)
		nfsm_wcc_data(dvp, wccflag);
	m_freem(info.nmi_mrep);

nfsmout: 
	if (error) {
		if (newvp)
			vrele(newvp);
	} else {
		if (cnp->cn_flags & MAKEENTRY)
			nfs_cache_enter(dvp, newvp, cnp);
		*vpp = newvp;
	}
	pool_put(&namei_pool, cnp->cn_pnbuf);
	VTONFS(dvp)->n_flag |= NMODIFIED;
	if (!wccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(dvp));
	vrele(dvp);
	return (error);
}

/*
 * nfs mknod vop
 * just call nfs_mknodrpc() to do the work.
 */
int
nfs_mknod(void *v)
{
	struct vop_mknod_args *ap = v;
	struct vnode *newvp;
	int error;

	error = nfs_mknodrpc(ap->a_dvp, &newvp, ap->a_cnp, ap->a_vap);
	if (!error)
		vrele(newvp);

	VN_KNOTE(ap->a_dvp, NOTE_WRITE);

	return (error);
}

int
nfs_create(void *v)
{
	struct vop_create_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	struct nfsnode *np = NULL;
	struct vnode *newvp = NULL;
	caddr_t cp2;
	int error = 0, wccflag = NFSV3_WCCRATTR, gotvp = 0, fmode = 0;

	info.nmi_v3 = NFS_ISV3(dvp);

	/*
	 * Oops, not for me..
	 */
	if (vap->va_type == VSOCK)
		return (nfs_mknodrpc(dvp, ap->a_vpp, cnp, vap));

	if (vap->va_vaflags & VA_EXCLUSIVE)
		fmode |= O_EXCL;

again:
	nfsstats.rpccnt[NFSPROC_CREATE]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) +
	    2 * NFSX_UNSIGNED + nfsm_rndup(cnp->cn_namelen) +
	    NFSX_SATTR(info.nmi_v3));
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(cnp->cn_nameptr, cnp->cn_namelen, NFS_MAXNAMLEN);
	if (info.nmi_v3) {
		tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
		if (fmode & O_EXCL) {
			*tl = txdr_unsigned(NFSV3CREATE_EXCLUSIVE);
			tl = nfsm_build(&info.nmi_mb, NFSX_V3CREATEVERF);
			arc4random_buf(tl, sizeof(*tl) * 2);
		} else {
			*tl = txdr_unsigned(NFSV3CREATE_UNCHECKED);
			nfsm_v3attrbuild(&info.nmi_mb, vap, 0);
		}
	} else {
		sp = nfsm_build(&info.nmi_mb, NFSX_V2SATTR);
		sp->sa_mode = vtonfsv2_mode(vap->va_type, vap->va_mode);
		sp->sa_uid = nfs_xdrneg1;
		sp->sa_gid = nfs_xdrneg1;
		sp->sa_size = 0;
		txdr_nfsv2time(&vap->va_atime, &sp->sa_atime);
		txdr_nfsv2time(&vap->va_mtime, &sp->sa_mtime);
	}

	KASSERT(cnp->cn_proc == curproc);
	info.nmi_procp = cnp->cn_proc;
	info.nmi_cred = cnp->cn_cred;
	error = nfs_request(dvp, NFSPROC_CREATE, &info);
	if (!error) {
		nfsm_mtofh(dvp, newvp, info.nmi_v3, gotvp);
		if (!gotvp) {
			if (newvp) {
				vrele(newvp);
				newvp = NULL;
			}
			error = nfs_lookitup(dvp, cnp->cn_nameptr,
			    cnp->cn_namelen, cnp->cn_cred, cnp->cn_proc, &np);
			if (!error)
				newvp = NFSTOV(np);
		}
	}
	if (info.nmi_v3)
		nfsm_wcc_data(dvp, wccflag);
	m_freem(info.nmi_mrep);

nfsmout: 
	if (error) {
		if (info.nmi_v3 && (fmode & O_EXCL) && error == NFSERR_NOTSUPP) {
			fmode &= ~O_EXCL;
			goto again;
		}
		if (newvp)
			vrele(newvp);
	} else if (info.nmi_v3 && (fmode & O_EXCL))
		error = nfs_setattrrpc(newvp, vap, cnp->cn_cred, cnp->cn_proc);
	if (!error) {
		if (cnp->cn_flags & MAKEENTRY)
			nfs_cache_enter(dvp, newvp, cnp);
		*ap->a_vpp = newvp;
	}
	pool_put(&namei_pool, cnp->cn_pnbuf);
	VTONFS(dvp)->n_flag |= NMODIFIED;
	if (!wccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(dvp));
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	vrele(dvp);
	return (error);
}

/*
 * nfs file remove call
 * To try and make nfs semantics closer to ufs semantics, a file that has
 * other processes using the vnode is renamed instead of removed and then
 * removed later on the last close.
 * - If v_usecount > 1
 *	  If a rename is not already in the works
 *	     call nfs_sillyrename() to set it up
 *     else
 *	  do the remove rpc
 */
int
nfs_remove(void *v)
{
	struct vop_remove_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct nfsnode *np = VTONFS(vp);
	int error = 0;
	struct vattr vattr;

#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("nfs_remove: no name");
	if (vp->v_usecount < 1)
		panic("nfs_remove: bad v_usecount");
#endif
	if (vp->v_type == VDIR)
		error = EPERM;
	else if (vp->v_usecount == 1 || (np->n_sillyrename &&
	    VOP_GETATTR(vp, &vattr, cnp->cn_cred, cnp->cn_proc) == 0 &&
	    vattr.va_nlink > 1)) {
		/*
		 * Purge the name cache so that the chance of a lookup for
		 * the name succeeding while the remove is in progress is
		 * minimized. Without node locking it can still happen, such
		 * that an I/O op returns ESTALE, but since you get this if
		 * another host removes the file..
		 */
		cache_purge(vp);
		/*
		 * throw away biocache buffers, mainly to avoid
		 * unnecessary delayed writes later.
		 */
		error = nfs_vinvalbuf(vp, 0, cnp->cn_cred, cnp->cn_proc);
		/* Do the rpc */
		if (error != EINTR)
			error = nfs_removerpc(dvp, cnp->cn_nameptr,
				cnp->cn_namelen, cnp->cn_cred, cnp->cn_proc);
		/*
		 * Kludge City: If the first reply to the remove rpc is lost..
		 *   the reply to the retransmitted request will be ENOENT
		 *   since the file was in fact removed
		 *   Therefore, we cheat and return success.
		 */
		if (error == ENOENT)
			error = 0;
	} else if (!np->n_sillyrename)
		error = nfs_sillyrename(dvp, vp, cnp);
	pool_put(&namei_pool, cnp->cn_pnbuf);
	NFS_INVALIDATE_ATTRCACHE(np);
	vrele(dvp);
	vrele(vp);

	VN_KNOTE(vp, NOTE_DELETE);
	VN_KNOTE(dvp, NOTE_WRITE);

	return (error);
}

/*
 * nfs file remove rpc called from nfs_inactive
 */
int
nfs_removeit(struct sillyrename *sp)
{
	/*
	 * Make sure that the directory vnode is still valid.
	 * XXX we should lock sp->s_dvp here.
	 *
	 * NFS can potentially try to nuke a silly *after* the directory
	 * has already been pushed out on a forced unmount. Since the silly
	 * is going to go away anyway, this is fine.
	 */
	if (sp->s_dvp->v_type == VBAD)
		return (0);
	return (nfs_removerpc(sp->s_dvp, sp->s_name, sp->s_namlen, sp->s_cred,
		NULL));
}

/*
 * Nfs remove rpc, called from nfs_remove() and nfs_removeit().
 */
int
nfs_removerpc(struct vnode *dvp, char *name, int namelen, struct ucred *cred,
    struct proc *proc)
{
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	int error = 0, wccflag = NFSV3_WCCRATTR;

	info.nmi_v3 = NFS_ISV3(dvp);

	nfsstats.rpccnt[NFSPROC_REMOVE]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) +
	     NFSX_UNSIGNED + nfsm_rndup(namelen));
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(name, namelen, NFS_MAXNAMLEN);

	info.nmi_procp = proc;
	info.nmi_cred = cred;
	error = nfs_request(dvp, NFSPROC_REMOVE, &info);
	if (info.nmi_v3)
		nfsm_wcc_data(dvp, wccflag);
	m_freem(info.nmi_mrep);

nfsmout: 
	VTONFS(dvp)->n_flag |= NMODIFIED;
	if (!wccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(dvp));
	return (error);
}

/*
 * nfs file rename call
 */
int
nfs_rename(void *v)
{
	struct vop_rename_args	*ap = v;
	struct vnode *fvp = ap->a_fvp;
	struct vnode *tvp = ap->a_tvp;
	struct vnode *fdvp = ap->a_fdvp;
	struct vnode *tdvp = ap->a_tdvp;
	struct componentname *tcnp = ap->a_tcnp;
	struct componentname *fcnp = ap->a_fcnp;
	int error;

#ifdef DIAGNOSTIC
	if ((tcnp->cn_flags & HASBUF) == 0 ||
	    (fcnp->cn_flags & HASBUF) == 0)
		panic("nfs_rename: no name");
#endif
	/* Check for cross-device rename */
	if ((fvp->v_mount != tdvp->v_mount) ||
	    (tvp && (fvp->v_mount != tvp->v_mount))) {
		error = EXDEV;
		goto out;
	}

	/*
	 * If the tvp exists and is in use, sillyrename it before doing the
	 * rename of the new file over it.
	 */
	if (tvp && tvp->v_usecount > 1 && !VTONFS(tvp)->n_sillyrename &&
	    tvp->v_type != VDIR && !nfs_sillyrename(tdvp, tvp, tcnp)) {
		VN_KNOTE(tvp, NOTE_DELETE);
		vrele(tvp);
		tvp = NULL;
	}

	error = nfs_renamerpc(fdvp, fcnp->cn_nameptr, fcnp->cn_namelen,
		tdvp, tcnp->cn_nameptr, tcnp->cn_namelen, tcnp->cn_cred,
		tcnp->cn_proc);

	VN_KNOTE(fdvp, NOTE_WRITE);
	VN_KNOTE(tdvp, NOTE_WRITE);

	if (fvp->v_type == VDIR) {
		if (tvp != NULL && tvp->v_type == VDIR)
			cache_purge(tdvp);
		cache_purge(fdvp);
	}
out:
	if (tdvp == tvp)
		vrele(tdvp);
	else
		vput(tdvp);
	if (tvp)
		vput(tvp);
	vrele(fdvp);
	vrele(fvp);
	/*
	 * Kludge: Map ENOENT => 0 assuming that it is a reply to a retry.
	 */
	if (error == ENOENT)
		error = 0;
	return (error);
}

/*
 * nfs file rename rpc called from nfs_remove() above
 */
int
nfs_renameit(struct vnode *sdvp, struct componentname *scnp,
    struct sillyrename *sp)
{
	return (nfs_renamerpc(sdvp, scnp->cn_nameptr, scnp->cn_namelen,
		sdvp, sp->s_name, sp->s_namlen, scnp->cn_cred, curproc));
}

/*
 * Do an nfs rename rpc. Called from nfs_rename() and nfs_renameit().
 */
int
nfs_renamerpc(struct vnode *fdvp, char *fnameptr, int fnamelen,
    struct vnode *tdvp, char *tnameptr, int tnamelen, struct ucred *cred,
    struct proc *proc)
{
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	int error = 0, fwccflag = NFSV3_WCCRATTR, twccflag = NFSV3_WCCRATTR;

	info.nmi_v3 = NFS_ISV3(fdvp);

	nfsstats.rpccnt[NFSPROC_RENAME]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead((NFSX_FH(info.nmi_v3) +
	    NFSX_UNSIGNED) * 2 + nfsm_rndup(fnamelen) + nfsm_rndup(tnamelen));
	nfsm_fhtom(&info, fdvp, info.nmi_v3);
	nfsm_strtom(fnameptr, fnamelen, NFS_MAXNAMLEN);
	nfsm_fhtom(&info, tdvp, info.nmi_v3);
	nfsm_strtom(tnameptr, tnamelen, NFS_MAXNAMLEN);

	info.nmi_procp = proc;
	info.nmi_cred = cred;
	error = nfs_request(fdvp, NFSPROC_RENAME, &info);
	if (info.nmi_v3) {
		nfsm_wcc_data(fdvp, fwccflag);
		nfsm_wcc_data(tdvp, twccflag);
	}
	m_freem(info.nmi_mrep);

nfsmout: 
	VTONFS(fdvp)->n_flag |= NMODIFIED;
	VTONFS(tdvp)->n_flag |= NMODIFIED;
	if (!fwccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(fdvp));
	if (!twccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(tdvp));
	return (error);
}

/*
 * nfs hard link create call
 */
int
nfs_link(void *v)
{
	struct vop_link_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	int error = 0, wccflag = NFSV3_WCCRATTR, attrflag = 0;

	info.nmi_v3 = NFS_ISV3(vp);

	if (dvp->v_mount != vp->v_mount) {
		pool_put(&namei_pool, cnp->cn_pnbuf);
		vput(dvp);
		return (EXDEV);
	}

	/*
	 * Push all writes to the server, so that the attribute cache
	 * doesn't get "out of sync" with the server.
	 * XXX There should be a better way!
	 */
	VOP_FSYNC(vp, cnp->cn_cred, MNT_WAIT, cnp->cn_proc);

	nfsstats.rpccnt[NFSPROC_LINK]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(2 * NFSX_FH(info.nmi_v3) +
	    NFSX_UNSIGNED + nfsm_rndup(cnp->cn_namelen));
	nfsm_fhtom(&info, vp, info.nmi_v3);
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(cnp->cn_nameptr, cnp->cn_namelen, NFS_MAXNAMLEN);

	info.nmi_procp = cnp->cn_proc;
	info.nmi_cred = cnp->cn_cred;
	error = nfs_request(vp, NFSPROC_LINK, &info);
	if (info.nmi_v3) {
		nfsm_postop_attr(vp, attrflag);
		nfsm_wcc_data(dvp, wccflag);
	}
	m_freem(info.nmi_mrep);
nfsmout: 
	pool_put(&namei_pool, cnp->cn_pnbuf);
	VTONFS(dvp)->n_flag |= NMODIFIED;
	if (!attrflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(vp));
	if (!wccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(dvp));

	VN_KNOTE(vp, NOTE_LINK);
	VN_KNOTE(dvp, NOTE_WRITE);
	vput(dvp);
	return (error);
}

/*
 * nfs symbolic link create call
 */
int
nfs_symlink(void *v)
{
	struct vop_symlink_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	int slen, error = 0, wccflag = NFSV3_WCCRATTR, gotvp;
	struct vnode *newvp = NULL;

	info.nmi_v3 = NFS_ISV3(dvp);

	nfsstats.rpccnt[NFSPROC_SYMLINK]++;
	slen = strlen(ap->a_target);
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) +
	    2 * NFSX_UNSIGNED + nfsm_rndup(cnp->cn_namelen) + nfsm_rndup(slen) +
	    NFSX_SATTR(info.nmi_v3));
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(cnp->cn_nameptr, cnp->cn_namelen, NFS_MAXNAMLEN);
	if (info.nmi_v3)
		nfsm_v3attrbuild(&info.nmi_mb, vap, 0);
	nfsm_strtom(ap->a_target, slen, NFS_MAXPATHLEN);
	if (!info.nmi_v3) {
		sp = nfsm_build(&info.nmi_mb, NFSX_V2SATTR);
		sp->sa_mode = vtonfsv2_mode(VLNK, vap->va_mode);
		sp->sa_uid = nfs_xdrneg1;
		sp->sa_gid = nfs_xdrneg1;
		sp->sa_size = nfs_xdrneg1;
		txdr_nfsv2time(&vap->va_atime, &sp->sa_atime);
		txdr_nfsv2time(&vap->va_mtime, &sp->sa_mtime);
	}

	info.nmi_procp = cnp->cn_proc;
	info.nmi_cred = cnp->cn_cred;
	error = nfs_request(dvp, NFSPROC_SYMLINK, &info);
	if (info.nmi_v3) {
		if (!error)
			nfsm_mtofh(dvp, newvp, info.nmi_v3, gotvp);
		nfsm_wcc_data(dvp, wccflag);
	}
	m_freem(info.nmi_mrep);

nfsmout: 
	if (newvp)
		vrele(newvp);
	pool_put(&namei_pool, cnp->cn_pnbuf);
	VTONFS(dvp)->n_flag |= NMODIFIED;
	if (!wccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(dvp));
	VN_KNOTE(dvp, NOTE_WRITE);
	vrele(dvp);
	return (error);
}

/*
 * nfs make dir call
 */
int
nfs_mkdir(void *v)
{
	struct vop_mkdir_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	int len;
	struct nfsnode *np = NULL;
	struct vnode *newvp = NULL;
	caddr_t cp2;
	int error = 0, wccflag = NFSV3_WCCRATTR;
	int gotvp = 0;

	info.nmi_v3 = NFS_ISV3(dvp);

	len = cnp->cn_namelen;
	nfsstats.rpccnt[NFSPROC_MKDIR]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) +
	    NFSX_UNSIGNED + nfsm_rndup(len) + NFSX_SATTR(info.nmi_v3));
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(cnp->cn_nameptr, len, NFS_MAXNAMLEN);

	if (info.nmi_v3) {
		nfsm_v3attrbuild(&info.nmi_mb, vap, 0);
	} else {
		sp = nfsm_build(&info.nmi_mb, NFSX_V2SATTR);
		sp->sa_mode = vtonfsv2_mode(VDIR, vap->va_mode);
		sp->sa_uid = nfs_xdrneg1;
		sp->sa_gid = nfs_xdrneg1;
		sp->sa_size = nfs_xdrneg1;
		txdr_nfsv2time(&vap->va_atime, &sp->sa_atime);
		txdr_nfsv2time(&vap->va_mtime, &sp->sa_mtime);
	}

	info.nmi_procp = cnp->cn_proc;
	info.nmi_cred = cnp->cn_cred;
	error = nfs_request(dvp, NFSPROC_MKDIR, &info);
	if (!error)
		nfsm_mtofh(dvp, newvp, info.nmi_v3, gotvp);
	if (info.nmi_v3)
		nfsm_wcc_data(dvp, wccflag);
	m_freem(info.nmi_mrep);

nfsmout: 
	VTONFS(dvp)->n_flag |= NMODIFIED;
	if (!wccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(dvp));

	if (error == 0 && newvp == NULL) {
		error = nfs_lookitup(dvp, cnp->cn_nameptr, len, cnp->cn_cred,
			cnp->cn_proc, &np);
		if (!error) {
			newvp = NFSTOV(np);
			if (newvp->v_type != VDIR)
				error = EEXIST;
		}
	}
	if (error) {
		if (newvp)
			vrele(newvp);
	} else {
		VN_KNOTE(dvp, NOTE_WRITE|NOTE_LINK);
		if (cnp->cn_flags & MAKEENTRY)
			nfs_cache_enter(dvp, newvp, cnp);
		*ap->a_vpp = newvp;
	}
	pool_put(&namei_pool, cnp->cn_pnbuf);
	vrele(dvp);
	return (error);
}

/*
 * nfs remove directory call
 */
int
nfs_rmdir(void *v)
{
	struct vop_rmdir_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	int error = 0, wccflag = NFSV3_WCCRATTR;

	info.nmi_v3 = NFS_ISV3(dvp);

	if (dvp == vp) {
		vrele(dvp);
		vrele(dvp);
		pool_put(&namei_pool, cnp->cn_pnbuf);
		return (EINVAL);
	}

	nfsstats.rpccnt[NFSPROC_RMDIR]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) +
	    NFSX_UNSIGNED + nfsm_rndup(cnp->cn_namelen));
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(cnp->cn_nameptr, cnp->cn_namelen, NFS_MAXNAMLEN);

	info.nmi_procp = cnp->cn_proc;
	info.nmi_cred = cnp->cn_cred;
	error = nfs_request(dvp,  NFSPROC_RMDIR, &info);
	if (info.nmi_v3)
		nfsm_wcc_data(dvp, wccflag);
	m_freem(info.nmi_mrep);

nfsmout: 
	pool_put(&namei_pool, cnp->cn_pnbuf);
	VTONFS(dvp)->n_flag |= NMODIFIED;
	if (!wccflag)
		NFS_INVALIDATE_ATTRCACHE(VTONFS(dvp));

	VN_KNOTE(dvp, NOTE_WRITE|NOTE_LINK);
	VN_KNOTE(vp, NOTE_DELETE);

	cache_purge(vp);
	vrele(vp);
	vrele(dvp);
	/*
	 * Kludge: Map ENOENT => 0 assuming that you have a reply to a retry.
	 */
	if (error == ENOENT)
		error = 0;
	return (error);
}


/*
 * The readdir logic below has a big design bug. It stores the NFS cookie in 
 * the returned uio->uio_offset but does not store the verifier (it cannot).
 * Instead, the code stores the verifier in the nfsnode and applies that
 * verifies to all cookies, no matter what verifier was originally with
 * the cookie.
 *
 * From a practical standpoint, this is not a problem since almost all
 * NFS servers do not change the validity of cookies across deletes
 * and inserts.
 */

struct nfs_dirent {
	u_int32_t cookie[2];
	struct dirent dirent;
};

#define	NFS_DIRHDSIZ	(sizeof (struct nfs_dirent) - (MAXNAMLEN + 1))
#define NFS_DIRENT_OVERHEAD  offsetof(struct nfs_dirent, dirent)

/*
 * nfs readdir call
 */
int
nfs_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct uio *uio = ap->a_uio;
	int tresid, error = 0;
	struct vattr vattr;
	int cnt;
	u_int64_t  newoff = uio->uio_offset;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	struct uio readdir_uio;
	struct iovec readdir_iovec;
	struct proc * p = uio->uio_procp;
	int done = 0, eof = 0;
	struct ucred *cred = ap->a_cred;
	void *data;

	if (vp->v_type != VDIR)
		return (EPERM);
	/*
	 * First, check for hit on the EOF offset cache
	 */
	if (np->n_direofoffset != 0 && 
	    uio->uio_offset == np->n_direofoffset) {
		if (VOP_GETATTR(vp, &vattr, ap->a_cred, uio->uio_procp) == 0 &&
		    timespeccmp(&np->n_mtime, &vattr.va_mtime, ==)) {
			nfsstats.direofcache_hits++;
			*ap->a_eofflag = 1;
			return (0);
		}
	}

	if (uio->uio_resid < NFS_FABLKSIZE)
		return (EINVAL);

	tresid = uio->uio_resid;

	if (uio->uio_rw != UIO_READ)
		return (EINVAL);

	if ((nmp->nm_flag & (NFSMNT_NFSV3 | NFSMNT_GOTFSINFO)) == NFSMNT_NFSV3)
		(void)nfs_fsinfo(nmp, vp, cred, p);

	cnt = 5;

	/* M_ZERO to avoid leaking kernel data in dirent padding */
	data = malloc(NFS_DIRBLKSIZ, M_TEMP, M_WAITOK|M_ZERO);
	do {
		struct nfs_dirent *ndp = data;

		readdir_iovec.iov_len = NFS_DIRBLKSIZ;
		readdir_iovec.iov_base = data;
		readdir_uio.uio_offset = newoff;
		readdir_uio.uio_iov = &readdir_iovec;
		readdir_uio.uio_iovcnt = 1;
		readdir_uio.uio_segflg = UIO_SYSSPACE;
		readdir_uio.uio_rw = UIO_READ;
		readdir_uio.uio_resid = NFS_DIRBLKSIZ;
		readdir_uio.uio_procp = curproc;

		if (nmp->nm_flag & NFSMNT_RDIRPLUS) {
			error = nfs_readdirplusrpc(vp, &readdir_uio, cred,
			    &eof, p);
			if (error == NFSERR_NOTSUPP)
				nmp->nm_flag &= ~NFSMNT_RDIRPLUS;
		}
		if ((nmp->nm_flag & NFSMNT_RDIRPLUS) == 0)
			error = nfs_readdirrpc(vp, &readdir_uio, cred, &eof);

		if (error == NFSERR_BAD_COOKIE)
			error = EINVAL;

		while (error == 0 &&
		    ndp < (struct nfs_dirent *)readdir_iovec.iov_base) {
			struct dirent *dp = &ndp->dirent;
			int reclen = dp->d_reclen;

			dp->d_reclen -= NFS_DIRENT_OVERHEAD;
			dp->d_off = fxdr_hyper(&ndp->cookie[0]);

			if (uio->uio_resid < dp->d_reclen) {
				eof = 0;
				done = 1;
				break;
			}

			if ((error = uiomove(dp, dp->d_reclen, uio)))
				break;

			newoff = fxdr_hyper(&ndp->cookie[0]);

			ndp = (struct nfs_dirent *)((u_int8_t *)ndp + reclen);
		}
	} while (!error && !done && !eof && cnt--);

	free(data, M_TEMP, NFS_DIRBLKSIZ);
	data = NULL;

	uio->uio_offset = newoff;

	if (!error && (eof || uio->uio_resid == tresid)) {
		nfsstats.direofcache_misses++;
		*ap->a_eofflag = 1;
		return (0);
	}

	*ap->a_eofflag = 0;
	return (error);
}


/*
 * The function below stuff the cookies in after the name
 */

/*
 * Readdir rpc call.
 */
int
nfs_readdirrpc(struct vnode *vp, struct uio *uiop, struct ucred *cred,
    int *end_of_directory)
{
	int len, left;
	struct nfs_dirent *ndp = NULL;
	struct dirent *dp = NULL;
	struct nfsm_info	info;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1;
	caddr_t cp2;
	nfsuint64 cookie;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	struct nfsnode *dnp = VTONFS(vp);
	u_quad_t fileno;
	int error = 0, tlen, more_dirs = 1, blksiz = 0, bigenough = 1;
	int attrflag;

	info.nmi_v3 = NFS_ISV3(vp);

#ifdef DIAGNOSTIC
	if (uiop->uio_iovcnt != 1 ||
		(uiop->uio_resid & (NFS_DIRBLKSIZ - 1)))
		panic("nfs readdirrpc bad uio");
#endif

	txdr_hyper(uiop->uio_offset, &cookie.nfsuquad[0]);

	/*
	 * Loop around doing readdir rpc's of size nm_readdirsize
	 * truncated to a multiple of NFS_READDIRBLKSIZ.
	 * The stopping criteria is EOF or buffer full.
	 */
	while (more_dirs && bigenough) {
		nfsstats.rpccnt[NFSPROC_READDIR]++;
		info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3)
		    + NFSX_READDIR(info.nmi_v3));
		nfsm_fhtom(&info, vp, info.nmi_v3);
		if (info.nmi_v3) {
			tl = nfsm_build(&info.nmi_mb, 5 * NFSX_UNSIGNED);
			*tl++ = cookie.nfsuquad[0];
			*tl++ = cookie.nfsuquad[1];
			if (cookie.nfsuquad[0] == 0 &&
			    cookie.nfsuquad[1] == 0) {
				*tl++ = 0;
				*tl++ = 0;
			} else {
				*tl++ = dnp->n_cookieverf.nfsuquad[0];
				*tl++ = dnp->n_cookieverf.nfsuquad[1];
			}
		} else {
			tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED);
			*tl++ = cookie.nfsuquad[1];
		}
		*tl = txdr_unsigned(nmp->nm_readdirsize);

		info.nmi_procp = uiop->uio_procp;
		info.nmi_cred = cred;
		error = nfs_request(vp, NFSPROC_READDIR, &info);
		if (info.nmi_v3)
			nfsm_postop_attr(vp, attrflag);

		if (error) {
			m_freem(info.nmi_mrep);
			goto nfsmout;
		}

		if (info.nmi_v3) {
			nfsm_dissect(tl, u_int32_t *,
			    2 * NFSX_UNSIGNED);
			dnp->n_cookieverf.nfsuquad[0] = *tl++;
			dnp->n_cookieverf.nfsuquad[1] = *tl;
		}

		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		more_dirs = fxdr_unsigned(int, *tl);

		/* loop thru the dir entries, doctoring them to dirent form */
		while (more_dirs && bigenough) {
			if (info.nmi_v3) {
				nfsm_dissect(tl, u_int32_t *,
				    3 * NFSX_UNSIGNED);
				fileno = fxdr_hyper(tl);
				len = fxdr_unsigned(int, *(tl + 2));
			} else {
				nfsm_dissect(tl, u_int32_t *,
				    2 * NFSX_UNSIGNED);
				fileno = fxdr_unsigned(u_quad_t, *tl++);
				len = fxdr_unsigned(int, *tl);
			}
			if (len <= 0 || len > NFS_MAXNAMLEN) {
				error = EBADRPC;
				m_freem(info.nmi_mrep);
				goto nfsmout;
			}
			tlen = DIRENT_RECSIZE(len) + NFS_DIRENT_OVERHEAD;
			left = NFS_READDIRBLKSIZ - blksiz;
			if (tlen > left) {
				dp->d_reclen += left;
				uiop->uio_iov->iov_base += left;
				uiop->uio_iov->iov_len -= left;
				uiop->uio_resid -= left;
				blksiz = 0;
			}
			if (tlen > uiop->uio_resid)
				bigenough = 0;
			if (bigenough) {
				ndp = (struct nfs_dirent *)
				    uiop->uio_iov->iov_base;
				dp = &ndp->dirent;
				dp->d_fileno = fileno;
				dp->d_namlen = len;
				dp->d_reclen = tlen;
				dp->d_type = DT_UNKNOWN;
				blksiz += tlen;
				if (blksiz == NFS_READDIRBLKSIZ)
					blksiz = 0;
				uiop->uio_resid -= NFS_DIRHDSIZ;
				uiop->uio_iov->iov_base =
				    (char *)uiop->uio_iov->iov_base +
				    NFS_DIRHDSIZ;
				uiop->uio_iov->iov_len -= NFS_DIRHDSIZ;
				nfsm_mtouio(uiop, len);
				cp = uiop->uio_iov->iov_base;
				tlen -= NFS_DIRHDSIZ + len;
				*cp = '\0';	/* null terminate */
				uiop->uio_iov->iov_base += tlen;
				uiop->uio_iov->iov_len -= tlen;
				uiop->uio_resid -= tlen;
			} else
				nfsm_adv(nfsm_rndup(len));
			if (info.nmi_v3) {
				nfsm_dissect(tl, u_int32_t *,
				    3 * NFSX_UNSIGNED);
			} else {
				nfsm_dissect(tl, u_int32_t *,
				    2 * NFSX_UNSIGNED);
			}
			if (bigenough) {
				if (info.nmi_v3) {
					ndp->cookie[0] = cookie.nfsuquad[0] =
					    *tl++;
				} else
					ndp->cookie[0] = 0;

				ndp->cookie[1] = cookie.nfsuquad[1] = *tl++;
			} else if (info.nmi_v3)
				tl += 2;
			else
				tl++;
			more_dirs = fxdr_unsigned(int, *tl);
		}
		/*
		 * If at end of rpc data, get the eof boolean
		 */
		if (!more_dirs) {
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
			more_dirs = (fxdr_unsigned(int, *tl) == 0);
		}
		m_freem(info.nmi_mrep);
	}
	/*
	 * Fill last record, iff any, out to a multiple of NFS_READDIRBLKSIZ
	 * by increasing d_reclen for the last record.
	 */
	if (blksiz > 0) {
		left = NFS_READDIRBLKSIZ - blksiz;
		dp->d_reclen += left;
		uiop->uio_iov->iov_base = (char *)uiop->uio_iov->iov_base +
		    left;
		uiop->uio_iov->iov_len -= left;
		uiop->uio_resid -= left;
	}

	/*
	 * We are now either at the end of the directory or have filled the
	 * block.
	 */
	if (bigenough) {
		dnp->n_direofoffset = fxdr_hyper(&cookie.nfsuquad[0]);
		if (end_of_directory) *end_of_directory = 1;
	} else {
		if (uiop->uio_resid > 0)
			printf("EEK! readdirrpc resid > 0\n");
	}

nfsmout:
	return (error);
}

/*
 * NFS V3 readdir plus RPC. Used in place of nfs_readdirrpc().
 */
int
nfs_readdirplusrpc(struct vnode *vp, struct uio *uiop, struct ucred *cred,
    int *end_of_directory, struct proc *p)
{
	int len, left;
	struct nfs_dirent *ndirp = NULL;
	struct dirent *dp = NULL;
	struct nfsm_info	info;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1;
	struct vnode *newvp;
	caddr_t cp2, dpossav1, dpossav2;
	struct mbuf *mdsav1, *mdsav2;
	struct nameidata nami, *ndp = &nami;
	struct componentname *cnp = &ndp->ni_cnd;
	nfsuint64 cookie;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	struct nfsnode *dnp = VTONFS(vp), *np;
	nfsfh_t *fhp;
	u_quad_t fileno;
	int error = 0, tlen, more_dirs = 1, blksiz = 0, doit, bigenough = 1, i;
	int attrflag, fhsize;

#ifdef DIAGNOSTIC
	if (uiop->uio_iovcnt != 1 ||
		(uiop->uio_resid & (NFS_DIRBLKSIZ - 1)))
		panic("nfs readdirplusrpc bad uio");
#endif
	NDINIT(ndp, 0, 0, UIO_SYSSPACE, NULL, p);
	ndp->ni_dvp = vp;
	newvp = NULLVP;

	txdr_hyper(uiop->uio_offset, &cookie.nfsuquad[0]);

	/*
	 * Loop around doing readdir rpc's of size nm_readdirsize
	 * truncated to a multiple of NFS_READDIRBLKSIZ.
	 * The stopping criteria is EOF or buffer full.
	 */
	while (more_dirs && bigenough) {
		nfsstats.rpccnt[NFSPROC_READDIRPLUS]++;
		info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(1) + 6 * NFSX_UNSIGNED);
		nfsm_fhtom(&info, vp, 1);
		tl = nfsm_build(&info.nmi_mb, 6 * NFSX_UNSIGNED);
		*tl++ = cookie.nfsuquad[0];
		*tl++ = cookie.nfsuquad[1];
		if (cookie.nfsuquad[0] == 0 &&
		    cookie.nfsuquad[1] == 0) {
			*tl++ = 0;
			*tl++ = 0;
		} else {
			*tl++ = dnp->n_cookieverf.nfsuquad[0];
			*tl++ = dnp->n_cookieverf.nfsuquad[1];
		}
		*tl++ = txdr_unsigned(nmp->nm_readdirsize);
		*tl = txdr_unsigned(nmp->nm_rsize);

		info.nmi_procp = uiop->uio_procp;
		info.nmi_cred = cred;
		error = nfs_request(vp, NFSPROC_READDIRPLUS, &info);
		nfsm_postop_attr(vp, attrflag);
		if (error) {
			m_freem(info.nmi_mrep);
			goto nfsmout;
		}

		nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
		dnp->n_cookieverf.nfsuquad[0] = *tl++;
		dnp->n_cookieverf.nfsuquad[1] = *tl++;
		more_dirs = fxdr_unsigned(int, *tl);

		/* loop thru the dir entries, doctoring them to 4bsd form */
		while (more_dirs && bigenough) {
			nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
			fileno = fxdr_hyper(tl);
			len = fxdr_unsigned(int, *(tl + 2));
			if (len <= 0 || len > NFS_MAXNAMLEN) {
				error = EBADRPC;
				m_freem(info.nmi_mrep);
				goto nfsmout;
			}
			tlen = DIRENT_RECSIZE(len) + NFS_DIRENT_OVERHEAD;
			left = NFS_READDIRBLKSIZ - blksiz;
			if (tlen > left) {
				dp->d_reclen += left;
				uiop->uio_iov->iov_base =
				    (char *)uiop->uio_iov->iov_base + left;
				uiop->uio_iov->iov_len -= left;
				uiop->uio_resid -= left;
				blksiz = 0;
			}
			if (tlen > uiop->uio_resid)
				bigenough = 0;
			if (bigenough) {
				ndirp = (struct nfs_dirent *)
				    uiop->uio_iov->iov_base;
				dp = &ndirp->dirent;
				dp->d_fileno = fileno;
				dp->d_namlen = len;
				dp->d_reclen = tlen;
				dp->d_type = DT_UNKNOWN;
				blksiz += tlen;
				if (blksiz == NFS_READDIRBLKSIZ)
					blksiz = 0;
				uiop->uio_resid -= NFS_DIRHDSIZ;
				uiop->uio_iov->iov_base =
				    (char *)uiop->uio_iov->iov_base +
				    NFS_DIRHDSIZ;
				uiop->uio_iov->iov_len -= NFS_DIRHDSIZ;
				cnp->cn_nameptr = uiop->uio_iov->iov_base;
				cnp->cn_namelen = len;
				nfsm_mtouio(uiop, len);
				cp = uiop->uio_iov->iov_base;
				tlen -= NFS_DIRHDSIZ + len;
				*cp = '\0';
				uiop->uio_iov->iov_base += tlen;
				uiop->uio_iov->iov_len -= tlen;
				uiop->uio_resid -= tlen;
			} else
				nfsm_adv(nfsm_rndup(len));
			nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
			if (bigenough) {
				ndirp->cookie[0] = cookie.nfsuquad[0] = *tl++;
				ndirp->cookie[1] = cookie.nfsuquad[1] = *tl++;
			} else
				tl += 2;

			/*
			 * Since the attributes are before the file handle
			 * (sigh), we must skip over the attributes and then
			 * come back and get them.
			 */
			attrflag = fxdr_unsigned(int, *tl);
			if (attrflag) {
				dpossav1 = info.nmi_dpos;
				mdsav1 = info.nmi_md;
				nfsm_adv(NFSX_V3FATTR);
				nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
				doit = fxdr_unsigned(int, *tl);
				if (doit) {
					nfsm_getfh(fhp, fhsize, 1);
					if (NFS_CMPFH(dnp, fhp, fhsize)) {
						vref(vp);
						newvp = vp;
						np = dnp;
					} else {
						error = nfs_nget(vp->v_mount,
						    fhp, fhsize, &np);
						if (error)
							doit = 0;
						else
							newvp = NFSTOV(np);
					}
				}
				if (doit && bigenough) {
					dpossav2 = info.nmi_dpos;
					info.nmi_dpos = dpossav1;
					mdsav2 = info.nmi_md;
					info.nmi_md = mdsav1;
					nfsm_loadattr(newvp, NULL);
					info.nmi_dpos = dpossav2;
					info.nmi_md = mdsav2;
					dp->d_type = IFTODT(
						VTTOIF(np->n_vattr.va_type));
					if (cnp->cn_namelen <=
					    NAMECACHE_MAXLEN) {
						ndp->ni_vp = newvp;
						cache_purge(ndp->ni_dvp);
						nfs_cache_enter(ndp->ni_dvp,
						    ndp->ni_vp, cnp);
					}
				}
			} else {
				/* Just skip over the file handle */
				nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
				i = fxdr_unsigned(int, *tl);
				nfsm_adv(nfsm_rndup(i));
			}
			if (newvp != NULLVP) {
				vrele(newvp);
				newvp = NULLVP;
			}
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
			more_dirs = fxdr_unsigned(int, *tl);
		}
		/*
		 * If at end of rpc data, get the eof boolean
		 */
		if (!more_dirs) {
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
			more_dirs = (fxdr_unsigned(int, *tl) == 0);
		}
		m_freem(info.nmi_mrep);
	}
	/*
	 * Fill last record, iff any, out to a multiple of NFS_READDIRBLKSIZ
	 * by increasing d_reclen for the last record.
	 */
	if (blksiz > 0) {
		left = NFS_READDIRBLKSIZ - blksiz;
		dp->d_reclen += left;
		uiop->uio_iov->iov_base = (char *)uiop->uio_iov->iov_base +
		    left;
		uiop->uio_iov->iov_len -= left;
		uiop->uio_resid -= left;
	}

	/*
	 * We are now either at the end of the directory or have filled the
	 * block.
	 */
	if (bigenough) {
		dnp->n_direofoffset = fxdr_hyper(&cookie.nfsuquad[0]);
		if (end_of_directory) *end_of_directory = 1;
	} else {
		if (uiop->uio_resid > 0)
			printf("EEK! readdirplusrpc resid > 0\n");
	}

nfsmout:
	if (newvp != NULLVP)
		vrele(newvp);
	return (error);
}

/*
 * Silly rename. To make the NFS filesystem that is stateless look a little
 * more like the "ufs" a remove of an active vnode is translated to a rename
 * to a funny looking filename that is removed by nfs_inactive on the
 * nfsnode. There is the potential for another process on a different client
 * to create the same funny name between the nfs_lookitup() fails and the
 * nfs_rename() completes, but...
 */
int
nfs_sillyrename(struct vnode *dvp, struct vnode *vp, struct componentname *cnp)
{
	struct sillyrename *sp;
	struct nfsnode *np;
	int error;

	cache_purge(dvp);
	np = VTONFS(vp);
	sp = malloc(sizeof(*sp), M_NFSREQ, M_WAITOK);
	sp->s_cred = crdup(cnp->cn_cred);
	sp->s_dvp = dvp;
	vref(dvp);

	if (vp->v_type == VDIR) {
#ifdef DIAGNOSTIC
		printf("nfs: sillyrename dir\n");
#endif
		error = EINVAL;
		goto bad;
	}

	/* Try lookitups until we get one that isn't there */
	while (1) {
		/* Fudge together a funny name */
		u_int32_t rnd[2];

		arc4random_buf(&rnd, sizeof rnd);
		sp->s_namlen = snprintf(sp->s_name, sizeof sp->s_name,
		    ".nfs%08X%08X", rnd[0], rnd[1]);
		if (sp->s_namlen > sizeof sp->s_name)
			sp->s_namlen = strlen(sp->s_name);

		if (nfs_lookitup(dvp, sp->s_name, sp->s_namlen, sp->s_cred,
		    cnp->cn_proc, NULL))
			break;
	}

	error = nfs_renameit(dvp, cnp, sp);
	if (error)
		goto bad;
	error = nfs_lookitup(dvp, sp->s_name, sp->s_namlen, sp->s_cred,
		cnp->cn_proc, &np);
	np->n_sillyrename = sp;
	return (0);
bad:
	vrele(sp->s_dvp);
	crfree(sp->s_cred);
	free(sp, M_NFSREQ, sizeof(*sp));
	return (error);
}

/*
 * Look up a file name and optionally either update the file handle or
 * allocate an nfsnode, depending on the value of npp.
 * npp == NULL	--> just do the lookup
 * *npp == NULL --> allocate a new nfsnode and make sure attributes are
 *			handled too
 * *npp != NULL --> update the file handle in the vnode
 */
int
nfs_lookitup(struct vnode *dvp, char *name, int len, struct ucred *cred,
    struct proc *procp, struct nfsnode **npp)
{
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	struct vnode *newvp = NULL;
	struct nfsnode *np, *dnp = VTONFS(dvp);
	caddr_t cp2;
	int error = 0, fhlen, attrflag = 0;
	nfsfh_t *nfhp;

	info.nmi_v3 = NFS_ISV3(dvp);

	nfsstats.rpccnt[NFSPROC_LOOKUP]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3) + NFSX_UNSIGNED +
	    nfsm_rndup(len));
	nfsm_fhtom(&info, dvp, info.nmi_v3);
	nfsm_strtom(name, len, NFS_MAXNAMLEN);

	info.nmi_procp = procp;
	info.nmi_cred = cred;
	error = nfs_request(dvp, NFSPROC_LOOKUP, &info);
	if (error && !info.nmi_v3) {
		m_freem(info.nmi_mrep);
		goto nfsmout;
	}

	if (npp && !error) {
		nfsm_getfh(nfhp, fhlen, info.nmi_v3);
		if (*npp) {
			np = *npp;
			np->n_fhp = &np->n_fh;
			bcopy(nfhp, np->n_fhp, fhlen);
			np->n_fhsize = fhlen;
			newvp = NFSTOV(np);
		} else if (NFS_CMPFH(dnp, nfhp, fhlen)) {
			vref(dvp);
			newvp = dvp;
			np = dnp;
		} else {
			error = nfs_nget(dvp->v_mount, nfhp, fhlen, &np);
			if (error) {
				m_freem(info.nmi_mrep);
				return (error);
			}
			newvp = NFSTOV(np);
		}
		if (info.nmi_v3) {
			nfsm_postop_attr(newvp, attrflag);
			if (!attrflag && *npp == NULL) {
				m_freem(info.nmi_mrep);
				vrele(newvp);
				return (ENOENT);
			}
		} else
			nfsm_loadattr(newvp, NULL);
	}
	m_freem(info.nmi_mrep);
nfsmout:
	if (npp && *npp == NULL) {
		if (error) {
			if (newvp)
				vrele(newvp);
		} else
			*npp = np;
	}
	return (error);
}

/*
 * Nfs Version 3 commit rpc
 */
int
nfs_commit(struct vnode *vp, u_quad_t offset, int cnt, struct proc *procp)
{
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	caddr_t cp2;
	int error = 0, wccflag = NFSV3_WCCRATTR;

	if ((nmp->nm_flag & NFSMNT_HASWRITEVERF) == 0)
		return (0);
	nfsstats.rpccnt[NFSPROC_COMMIT]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(1));
	nfsm_fhtom(&info, vp, 1);

	tl = nfsm_build(&info.nmi_mb, 3 * NFSX_UNSIGNED);
	txdr_hyper(offset, tl);
	tl += 2;
	*tl = txdr_unsigned(cnt);

	info.nmi_procp = procp;
	info.nmi_cred = VTONFS(vp)->n_wcred;
	error = nfs_request(vp, NFSPROC_COMMIT, &info);
	nfsm_wcc_data(vp, wccflag);

	if (!error) {
		nfsm_dissect(tl, u_int32_t *, NFSX_V3WRITEVERF);
		if (bcmp(nmp->nm_verf, tl,
			NFSX_V3WRITEVERF)) {
			bcopy(tl, nmp->nm_verf,
				NFSX_V3WRITEVERF);
			error = NFSERR_STALEWRITEVERF;
		}
	}
	m_freem(info.nmi_mrep);

nfsmout:
	return (error);
}

/*
 * Kludge City..
 * - make nfs_bmap() essentially a no-op that does no translation
 * - do nfs_strategy() by doing I/O with nfs_readrpc/nfs_writerpc
 *   (Maybe I could use the process's page mapping, but I was concerned that
 *    Kernel Write might not be enabled and also figured copyout() would do
 *    a lot more work than bcopy() and also it currently happens in the
 *    context of the swapper process (2).
 */
int
nfs_bmap(void *v)
{
	struct vop_bmap_args *ap = v;
	struct vnode *vp = ap->a_vp;

	if (ap->a_vpp != NULL)
		*ap->a_vpp = vp;
	if (ap->a_bnp != NULL)
		*ap->a_bnp = ap->a_bn * btodb(vp->v_mount->mnt_stat.f_iosize);
	return (0);
}

/*
 * Strategy routine.
 * For async requests when nfsiod(s) are running, queue the request by
 * calling nfs_asyncio(), otherwise just all nfs_doio() to do the
 * request.
 */
int
nfs_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	struct buf *bp = ap->a_bp;
	struct proc *p;
	int error = 0;

	if ((bp->b_flags & (B_PHYS|B_ASYNC)) == (B_PHYS|B_ASYNC))
		panic("nfs physio/async");
	if (bp->b_flags & B_ASYNC)
		p = NULL;
	else
		p = curproc;	/* XXX */
	/*
	 * If the op is asynchronous and an i/o daemon is waiting
	 * queue the request, wake it up and wait for completion
	 * otherwise just do it ourselves.
	 */
	if ((bp->b_flags & B_ASYNC) == 0 || nfs_asyncio(bp, 0))
		error = nfs_doio(bp, p);
	return (error);
}

/*
 * fsync vnode op. Just call nfs_flush() with commit == 1.
 */
int
nfs_fsync(void *v)
{
	struct vop_fsync_args *ap = v;

	return (nfs_flush(ap->a_vp, ap->a_cred, ap->a_waitfor, ap->a_p, 1));
}

/*
 * Flush all the blocks associated with a vnode.
 *	Walk through the buffer pool and push any dirty pages
 *	associated with the vnode.
 */
int
nfs_flush(struct vnode *vp, struct ucred *cred, int waitfor, struct proc *p,
    int commit)
{
	struct nfsnode *np = VTONFS(vp);
	struct buf *bp;
	int i;
	struct buf *nbp;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	int s, error = 0, slptimeo = 0, slpflag = 0, retv, bvecpos;
	int passone = 1;
	u_quad_t off = (u_quad_t)-1, endoff = 0, toff;
#ifndef NFS_COMMITBVECSIZ
#define NFS_COMMITBVECSIZ	20
#endif
	struct buf *bvec[NFS_COMMITBVECSIZ];

	if (nmp->nm_flag & NFSMNT_INT)
		slpflag = PCATCH;
	if (!commit)
		passone = 0;
	/*
	 * A b_flags == (B_DELWRI | B_NEEDCOMMIT) block has been written to the
	 * server, but nas not been committed to stable storage on the server
	 * yet. On the first pass, the byte range is worked out and the commit
	 * rpc is done. On the second pass, nfs_writebp() is called to do the
	 * job.
	 */
again:
	bvecpos = 0;
	if (NFS_ISV3(vp) && commit) {
		s = splbio();
		for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp != NULL; bp = nbp) {
			if (bvecpos >= NFS_COMMITBVECSIZ)
				break;
			if ((bp->b_flags & (B_BUSY | B_DELWRI | B_NEEDCOMMIT))
			    != (B_DELWRI | B_NEEDCOMMIT)) {
				nbp = LIST_NEXT(bp, b_vnbufs);
				continue;
			}
			bremfree(bp);
			bp->b_flags |= B_WRITEINPROG;
			buf_acquire(bp);
			nbp = LIST_NEXT(bp, b_vnbufs);

			/*
			 * A list of these buffers is kept so that the
			 * second loop knows which buffers have actually
			 * been committed. This is necessary, since there
			 * may be a race between the commit rpc and new
			 * uncommitted writes on the file.
			 */
			bvec[bvecpos++] = bp;
			toff = ((u_quad_t)bp->b_blkno) * DEV_BSIZE +
				bp->b_dirtyoff;
			if (toff < off)
				off = toff;
			toff += (u_quad_t)(bp->b_dirtyend - bp->b_dirtyoff);
			if (toff > endoff)
				endoff = toff;
		}
		splx(s);
	}
	if (bvecpos > 0) {
		/*
		 * Commit data on the server, as required.
		 */
		bcstats.pendingwrites++;
		bcstats.numwrites++;
		retv = nfs_commit(vp, off, (int)(endoff - off), p);
		if (retv == NFSERR_STALEWRITEVERF)
			nfs_clearcommit(vp->v_mount);
		/*
		 * Now, either mark the blocks I/O done or mark the
		 * blocks dirty, depending on whether the commit
		 * succeeded.
		 */
		for (i = 0; i < bvecpos; i++) {
			bp = bvec[i];
			bp->b_flags &= ~(B_NEEDCOMMIT | B_WRITEINPROG);
			if (retv) {
				if (i == 0)
					bcstats.pendingwrites--;
				brelse(bp);
			} else {
				if (i > 0)
					bcstats.pendingwrites++;
				s = splbio();
				buf_undirty(bp);
				vp->v_numoutput++;
				bp->b_flags |= B_ASYNC;
				bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
				bp->b_dirtyoff = bp->b_dirtyend = 0;
				biodone(bp);
				splx(s);
			}
		}
	}

	/*
	 * Start/do any write(s) that are required.
	 */
loop:
	s = splbio();
	for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp != NULL; bp = nbp) {
		nbp = LIST_NEXT(bp, b_vnbufs);
		if (bp->b_flags & B_BUSY) {
			if (waitfor != MNT_WAIT || passone)
				continue;
			bp->b_flags |= B_WANTED;
			error = tsleep(bp, slpflag | (PRIBIO + 1),
				"nfsfsync", slptimeo);
			splx(s);
			if (error) {
				if (nfs_sigintr(nmp, NULL, p))
					return (EINTR);
				if (slpflag == PCATCH) {
					slpflag = 0;
					slptimeo = 2 * hz;
				}
			}
			goto loop;
		}
		if ((bp->b_flags & B_DELWRI) == 0)
			panic("nfs_fsync: not dirty");
		if ((passone || !commit) && (bp->b_flags & B_NEEDCOMMIT))
			continue;
		bremfree(bp);
		if (passone || !commit) {
			bp->b_flags |= B_ASYNC;
		} else {
			bp->b_flags |= (B_ASYNC|B_WRITEINPROG|B_NEEDCOMMIT);
		}
		buf_acquire(bp);
		splx(s);
		VOP_BWRITE(bp);
		goto loop;
	}
	splx(s);
	if (passone) {
		passone = 0;
		goto again;
	}
	if (waitfor == MNT_WAIT) {
 loop2:
		s = splbio();
		error = vwaitforio(vp, slpflag, "nfs_fsync", slptimeo);
		splx(s);
		if (error) {
			if (nfs_sigintr(nmp, NULL, p))
				return (EINTR);
			if (slpflag == PCATCH) {
				slpflag = 0;
				slptimeo = 2 * hz;
			}
			goto loop2;
		}

		if (LIST_FIRST(&vp->v_dirtyblkhd) && commit) {
#if 0
			vprint("nfs_fsync: dirty", vp);
#endif
			goto loop;
		}
	}
	if (np->n_flag & NWRITEERR) {
		error = np->n_error;
		np->n_flag &= ~NWRITEERR;
	}
	return (error);
}

/*
 * Return POSIX pathconf information applicable to nfs.
 * Fake it. For v3 we could ask the server, but such code
 * hasn't been written yet.
 */
/* ARGSUSED */
int
nfs_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	struct nfsmount *nmp = VFSTONFS(ap->a_vp->v_mount);
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		break;
	case _PC_NAME_MAX:
		*ap->a_retval = NAME_MAX;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	case _PC_NO_TRUNC:
		*ap->a_retval = 1;
		break;
	case _PC_ALLOC_SIZE_MIN:
		*ap->a_retval = NFS_FABLKSIZE;
		break;
	case _PC_FILESIZEBITS:
		*ap->a_retval = 64;
		break;
	case _PC_REC_INCR_XFER_SIZE:
		*ap->a_retval = min(nmp->nm_rsize, nmp->nm_wsize);
		break;
	case _PC_REC_MAX_XFER_SIZE:
		*ap->a_retval = -1; /* means ``unlimited'' */
		break;
	case _PC_REC_MIN_XFER_SIZE:
		*ap->a_retval = min(nmp->nm_rsize, nmp->nm_wsize);
		break;
	case _PC_REC_XFER_ALIGN:
		*ap->a_retval = PAGE_SIZE;
		break;
	case _PC_SYMLINK_MAX:
		*ap->a_retval = MAXPATHLEN;
		break;
	case _PC_2_SYMLINKS:
		*ap->a_retval = 1;
		break;
	case _PC_TIMESTAMP_RESOLUTION:
		*ap->a_retval = NFS_ISV3(ap->a_vp) ? 1 : 1000;
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * NFS advisory byte-level locks.
 */
int
nfs_advlock(void *v)
{
	struct vop_advlock_args *ap = v;
	struct nfsnode *np = VTONFS(ap->a_vp);

	return (lf_advlock(&np->n_lockf, np->n_size, ap->a_id, ap->a_op,
	    ap->a_fl, ap->a_flags));
}

/*
 * Print out the contents of an nfsnode.
 */
int
nfs_print(void *v)
{
	struct vop_print_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);

	printf("tag VT_NFS, fileid %lld fsid 0x%lx",
		np->n_vattr.va_fileid, np->n_vattr.va_fsid);
#ifdef FIFO
	if (vp->v_type == VFIFO)
		fifo_printinfo(vp);
#endif
	printf("\n");
	return (0);
}

/*
 * Just call nfs_writebp() with the force argument set to 1.
 */
int
nfs_bwrite(void *v)
{
	struct vop_bwrite_args *ap = v;

	return (nfs_writebp(ap->a_bp, 1));
}

/*
 * This is a clone of vop_generic_bwrite(), except that B_WRITEINPROG isn't set unless
 * the force flag is one and it also handles the B_NEEDCOMMIT flag.
 */
int
nfs_writebp(struct buf *bp, int force)
{
	int oldflags = bp->b_flags, retv = 1;
	struct proc *p = curproc;	/* XXX */
	off_t off;
	size_t cnt;
	int   s;
	struct vnode *vp;
	struct nfsnode *np;

	if(!(bp->b_flags & B_BUSY))
		panic("bwrite: buffer is not busy???");

	vp = bp->b_vp;
	np = VTONFS(vp);

	bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);

	s = splbio();
	buf_undirty(bp);

	if ((oldflags & B_ASYNC) && !(oldflags & B_DELWRI) && p)
		++p->p_ru.ru_oublock;

	bp->b_vp->v_numoutput++;
	splx(s);

	/*
	 * If B_NEEDCOMMIT is set, a commit rpc may do the trick. If not
	 * an actual write will have to be scheduled via. VOP_STRATEGY().
	 * If B_WRITEINPROG is already set, then push it with a write anyhow.
	 */
	if ((oldflags & (B_NEEDCOMMIT | B_WRITEINPROG)) == B_NEEDCOMMIT) {
		off = ((u_quad_t)bp->b_blkno) * DEV_BSIZE + bp->b_dirtyoff;
		cnt = bp->b_dirtyend - bp->b_dirtyoff;

		rw_enter_write(&np->n_commitlock);
		if (!(bp->b_flags & B_NEEDCOMMIT)) {
			rw_exit_write(&np->n_commitlock);
			return (0);
		}

		/*
		 * If it's already been committed by somebody else,
		 * bail.
		 */
		if (!nfs_in_committed_range(vp, bp)) {
			int pushedrange = 0;
			/*
			 * Since we're going to do this, push as much
			 * as we can.
			 */

			if (nfs_in_tobecommitted_range(vp, bp)) {
				pushedrange = 1;
				off = np->n_pushlo;
				cnt = np->n_pushhi - np->n_pushlo;
			}

			bp->b_flags |= B_WRITEINPROG;
			bcstats.pendingwrites++;
			bcstats.numwrites++;
			retv = nfs_commit(bp->b_vp, off, cnt, curproc);
			bp->b_flags &= ~B_WRITEINPROG;

			if (retv == 0) {
				if (pushedrange)
					nfs_merge_commit_ranges(vp);
				else
					nfs_add_committed_range(vp, bp);
			} else
				bcstats.pendingwrites--;
		} else
			retv = 0; /* It has already been commited. */

		rw_exit_write(&np->n_commitlock);
		if (!retv) {
			bp->b_dirtyoff = bp->b_dirtyend = 0;
			bp->b_flags &= ~B_NEEDCOMMIT;
			s = splbio();
			biodone(bp);
			splx(s);
		} else if (retv == NFSERR_STALEWRITEVERF)
			nfs_clearcommit(bp->b_vp->v_mount);
	}
	if (retv) {
		buf_flip_dma(bp);
		if (force)
			bp->b_flags |= B_WRITEINPROG;
		VOP_STRATEGY(bp);
	}

	if( (oldflags & B_ASYNC) == 0) {
		int rtval;

		bp->b_flags |= B_RAW;
		rtval = biowait(bp);
		if (!(oldflags & B_DELWRI) && p) {
			++p->p_ru.ru_oublock;
		}
		brelse(bp);
		return (rtval);
	}

	return (0);
}

/*
 * nfs special file access vnode op.
 * Essentially just get vattr and then imitate iaccess() since the device is
 * local to the client.
 */
int
nfsspec_access(void *v)
{
	struct vop_access_args *ap = v;
	struct vattr va;
	struct vnode *vp = ap->a_vp;
	int error;

	/*
	 * Disallow write attempts on filesystems mounted read-only;
	 * unless the file is a socket, fifo, or a block or character
	 * device resident on the filesystem.
	 */
	if ((ap->a_mode & VWRITE) && (vp->v_mount->mnt_flag & MNT_RDONLY)) {
		switch (vp->v_type) {
		case VREG:
		case VDIR:
		case VLNK:
			return (EROFS);
		default:
			break;
		}
	}

	error = VOP_GETATTR(vp, &va, ap->a_cred, ap->a_p);
	if (error)
		return (error);

	return (vaccess(vp->v_type, va.va_mode, va.va_uid, va.va_gid,
	    ap->a_mode, ap->a_cred));
}

int
nfs_poll(void *v)
{
	struct vop_poll_args *ap = v;

	/*
	 * We should really check to see if I/O is possible.
	 */
	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}

/*
 * Read wrapper for special devices.
 */
int
nfsspec_read(void *v)
{
	struct vop_read_args *ap = v;
	struct nfsnode *np = VTONFS(ap->a_vp);

	/*
	 * Set access flag.
	 */
	np->n_flag |= NACC;
	getnanotime(&np->n_atim);
	return (spec_read(ap));
}

/*
 * Write wrapper for special devices.
 */
int
nfsspec_write(void *v)
{
	struct vop_write_args *ap = v;
	struct nfsnode *np = VTONFS(ap->a_vp);

	/*
	 * Set update flag.
	 */
	np->n_flag |= NUPD;
	getnanotime(&np->n_mtim);
	return (spec_write(ap));
}

/*
 * Close wrapper for special devices.
 *
 * Update the times on the nfsnode then do device close.
 */
int
nfsspec_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct vattr vattr;

	if (np->n_flag & (NACC | NUPD)) {
		np->n_flag |= NCHG;
		if (vp->v_usecount == 1 &&
		    (vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
			VATTR_NULL(&vattr);
			if (np->n_flag & NACC)
				vattr.va_atime = np->n_atim;
			if (np->n_flag & NUPD)
				vattr.va_mtime = np->n_mtim;
			(void)VOP_SETATTR(vp, &vattr, ap->a_cred, ap->a_p);
		}
	}
	return (spec_close(ap));
}

#ifdef FIFO
/*
 * Read wrapper for fifos.
 */
int
nfsfifo_read(void *v)
{
	struct vop_read_args *ap = v;
	struct nfsnode *np = VTONFS(ap->a_vp);

	/*
	 * Set access flag.
	 */
	np->n_flag |= NACC;
	getnanotime(&np->n_atim);
	return (fifo_read(ap));
}

/*
 * Write wrapper for fifos.
 */
int
nfsfifo_write(void *v)
{
	struct vop_write_args *ap = v;
	struct nfsnode *np = VTONFS(ap->a_vp);

	/*
	 * Set update flag.
	 */
	np->n_flag |= NUPD;
	getnanotime(&np->n_mtim);
	return (fifo_write(ap));
}

/*
 * Close wrapper for fifos.
 *
 * Update the times on the nfsnode then do fifo close.
 */
int
nfsfifo_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct vattr vattr;

	if (np->n_flag & (NACC | NUPD)) {
		if (np->n_flag & NACC) {
			getnanotime(&np->n_atim);
		}
		if (np->n_flag & NUPD) {
			getnanotime(&np->n_mtim);
		}
		np->n_flag |= NCHG;
		if (vp->v_usecount == 1 &&
		    (vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
			VATTR_NULL(&vattr);
			if (np->n_flag & NACC)
				vattr.va_atime = np->n_atim;
			if (np->n_flag & NUPD)
				vattr.va_mtime = np->n_mtim;
			(void)VOP_SETATTR(vp, &vattr, ap->a_cred, ap->a_p);
		}
	}
	return (fifo_close(ap));
}

int
nfsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (nfs_reclaim(v));
}
#endif /* ! FIFO */
@


1.170
log
@make sure attrflag is initialized. from clang via david hill
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.169 2016/04/29 14:40:36 beck Exp $	*/
d80 44
d125 10
@


1.169
log
@Fix some gibbering horrors due to uninitialized struct nameidata's

1) turn NDINITAT into a function and make the macros point to it
with the later goal of getting rid of them.

2) Sweep the kernel for places where people make a struct nameidata manually
on the stack and fill in what they hope are the required fields and count
on prayer and clean living to always get them right. Instead use NDINIT
everywhere. NFS was especially bad for this and there have likely
been things lurking there for a while.

3) Add a couple of strategic KASSERT's to catch future offenders.

ok krw@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.168 2016/03/19 12:04:16 natano Exp $	*/
d2565 1
a2565 1
	int error = 0, fhlen, attrflag;
@


1.168
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.167 2016/02/13 15:45:05 stefan Exp $	*/
d2011 1
a2011 1
			    &eof);
d2263 1
a2263 1
    int *end_of_directory)
d2290 1
@


1.167
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.166 2015/12/22 21:36:57 mmcc Exp $	*/
d786 1
a786 1
				VOP_UNLOCK(dvp, 0, p);
d843 1
a843 1
			VOP_UNLOCK(dvp, 0, p);
d864 1
a864 1
		VOP_UNLOCK(dvp, 0, p);
d904 1
a904 1
			VOP_UNLOCK(dvp, 0, p);
d934 1
a934 1
				VOP_UNLOCK(newvp, 0, p);
@


1.166
log
@commited -> committed
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.165 2015/12/07 01:51:39 beck Exp $	*/
d2035 1
a2035 1
			if ((error = uiomovei(dp, dp->d_reclen, uio)))
@


1.165
log
@NFS can pass a buffer cache buffer straight to VOP_STRATEGY here, so dma_flip is
needed.   Found by henning@@ - thanks!
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.164 2015/05/03 02:02:15 guenther Exp $	*/
d3062 1
a3062 1
		 * If it's already been commited by somebody else,
@


1.164
log
@Make sure we don't leak bytes from malloced memory in the padding of struct
dirent.  (The memset in previous commit was both wrong and insufficient.)

problem with memset noted by brad@@ and jsg@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.163 2015/04/17 04:43:21 guenther Exp $	*/
d3105 1
@


1.164.4.1
log
@Bring in fix for NFS panic from current.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.165 2015/12/07 01:51:39 beck Exp $	*/
a3104 1
		buf_flip_dma(bp);
@


1.163
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.162 2015/03/14 03:38:52 jsg Exp $	*/
d1994 2
a1995 1
	data = malloc(NFS_DIRBLKSIZ, M_TEMP, M_WAITOK);
a2177 1
				memset(dp, 0, sizeof(dp));
@


1.162
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.161 2015/02/10 21:56:10 miod Exp $	*/
d568 4
a571 2
	    vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_sec != VNOVAL ||
	    vap->va_mtime.tv_sec != VNOVAL || vap->va_mode != (mode_t)VNOVAL) &&
d582 2
a583 2
			if (vap->va_mtime.tv_sec == VNOVAL &&
			    vap->va_atime.tv_sec == VNOVAL &&
d609 2
a610 2
	} else if ((vap->va_mtime.tv_sec != VNOVAL ||
		vap->va_atime.tv_sec != VNOVAL) &&
d2177 1
@


1.161
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.160 2014/12/29 05:29:28 miod Exp $	*/
a77 1
#include <net/if.h>
@


1.160
log
@Explicitely include <uvm/uvm_extern.h> in order to build on variable page size
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.159 2014/12/18 20:59:21 tedu Exp $	*/
d2033 1
a2033 1
			if ((error = uiomove(dp, dp->d_reclen, uio)))
@


1.159
log
@delete a whole mess of unnecessary caddr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.158 2014/12/16 18:30:04 tedu Exp $	*/
d75 2
@


1.158
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.157 2014/12/03 04:16:58 tedu Exp $	*/
d1177 1
a1177 1
				bcopy((caddr_t)tl, (caddr_t)nmp->nm_verf,
d1180 2
a1181 2
			} else if (bcmp((caddr_t)tl,
			    (caddr_t)nmp->nm_verf, NFSX_V3WRITEVERF)) {
d1183 1
a1183 1
				bcopy((caddr_t)tl, (caddr_t)nmp->nm_verf,
d2584 1
a2584 1
			bcopy((caddr_t)nfhp, (caddr_t)np->n_fhp, fhlen);
d2652 1
a2652 1
		if (bcmp((caddr_t)nmp->nm_verf, (caddr_t)tl,
d2654 1
a2654 1
			bcopy((caddr_t)tl, (caddr_t)nmp->nm_verf,
d2843 1
a2843 1
			error = tsleep((caddr_t)bp, slpflag | (PRIBIO + 1),
@


1.157
log
@stale header: this code hasn't used hash.h in a while
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.156 2014/11/18 02:37:31 tedu Exp $	*/
d57 1
@


1.156
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.155 2014/11/15 02:42:38 doug Exp $	*/
a59 1
#include <sys/hash.h>
@


1.155
log
@Fix a mistake in a comment.

Revert NFS_DIRBLKSIZE back to data.  This matches an identical comment
in another part of this file.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.154 2014/11/14 23:11:35 tedu Exp $	*/
a77 2

#include <dev/rndvar.h>
@


1.154
log
@simplest free(size)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.153 2014/09/14 14:17:26 jsg Exp $	*/
d2219 1
a2219 1
		 * If at end of rpc NFS_DIRBLKSIZ, get the eof boolean
@


1.153
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.152 2014/07/12 18:43:52 tedu Exp $	*/
d2042 1
a2042 1
	free(data, M_TEMP, 0);
d2219 1
a2219 1
		 * If at end of rpc data, get the eof boolean
d2501 1
a2501 1
	sp = malloc(sizeof(struct sillyrename), M_NFSREQ, M_WAITOK);
d2540 1
a2540 1
	free(sp, M_NFSREQ, 0);
@


1.152
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.151 2014/07/08 17:19:26 deraadt Exp $	*/
a43 1
#include <sys/proc.h>
@


1.151
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.150 2014/01/18 07:10:26 deraadt Exp $	*/
d2043 1
a2043 1
	free(data, M_TEMP);
d2541 1
a2541 1
	free(sp, M_NFSREQ);
@


1.150
log
@Use arc4random_buf() for fetching 64-bits of data because it is faster
than calling arc4random() twice
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.149 2013/12/26 07:17:15 espie Exp $	*/
a64 2

#include <uvm/uvm_extern.h>
@


1.149
log
@either dvp == vp or dvp != vp: zap extra test.
okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.148 2013/10/17 16:27:47 bluhm Exp $	*/
d1359 1
a1359 2
			*tl++ = arc4random();
			*tl = arc4random();
d2520 3
d2524 1
a2524 1
		    ".nfs%08X%08X", arc4random(), arc4random());
@


1.148
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.147 2013/10/02 21:28:11 sf Exp $	*/
d1687 1
a1687 4
		if (vp == dvp)
			vrele(dvp);
		else
			vput(dvp);
@


1.147
log
@format string fix: int64_t
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.146 2013/09/14 01:35:01 guenther Exp $	*/
a80 1
#include <netinet/in_var.h>
@


1.146
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.145 2013/08/13 05:52:25 guenther Exp $	*/
d2996 1
a2996 1
	printf("tag VT_NFS, fileid %ld fsid 0x%lx",
@


1.145
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.144 2013/03/28 03:29:44 guenther Exp $	*/
a84 5
#ifdef T32
/* t32_sys_getdirentries() returns struct direct-style entries */
#include <ufs/ufs/dir.h>
#endif

a1971 6
#if T32
	int t32 = (uio->uio_segflg & 0x10);
	struct direct dc;

	uio->uio_segflg &= ~0x10;
#endif
d2032 2
a2033 28
#if T32
			if (t32) {
				dc.d_reclen = roundup(dp->d_namlen + 1 +
				    offsetof(struct direct, d_name), 4);

				if (uio->uio_resid < dc.d_reclen) {
					eof = 0;
					done = 1;
					break;
				}

				dc.d_ino = (u_int32_t)dp->d_fileno;
				dc.d_type = dp->d_type;
				dc.d_namlen = dp->d_namlen;
				bcopy(&dp->d_name, &dc.d_name,
				    dp->d_namlen + 1);
				error = uiomove(&dc, dc.d_reclen, uio);
			} else
#endif
			{
				dp->d_reclen -= NFS_DIRENT_OVERHEAD;
				dp->d_off = fxdr_hyper(&ndp->cookie[0]);

				if (uio->uio_resid < dp->d_reclen) {
					eof = 0;
					done = 1;
					break;
				}
d2035 4
a2038 1
				error = uiomove(dp, dp->d_reclen, uio);
d2040 2
a2041 1
			if (error)
@


1.144
log
@Add support for _PC_TIMESTAMP_RESOLUTION for ffs/mfs, cd9600, ext2,
msdos, NFS, fifos and devices, plus support for querying it in
getconf(2) and the requisite pathconf(2) manpage blurb

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.143 2013/03/28 02:27:27 tedu Exp $	*/
d85 5
d1968 1
a1968 2
	u_long *cookies = NULL;
	int ncookies = 0, cnt;
d1977 6
a2006 9
	if (ap->a_cookies) {
		ncookies = uio->uio_resid / 20;

		cookies = malloc(sizeof(*cookies) * ncookies, M_TEMP,
		    M_WAITOK);
		*ap->a_ncookies = ncookies;
		*ap->a_cookies = cookies;
	}

a2038 1
		    (ap->a_cookies == NULL || ncookies != 0) &&
d2043 28
a2070 1
			dp->d_reclen -= NFS_DIRENT_OVERHEAD;
d2072 1
a2072 4
			if (uio->uio_resid < dp->d_reclen) {
				eof = 0;
				done = 1;
				break;
a2073 2

			error = uiomove((caddr_t)dp, dp->d_reclen, uio);
a2078 6
			if (ap->a_cookies != NULL) {
				*cookies = newoff;
				cookies++;
				ncookies--;
			}

d2086 1
a2086 12
	if (ap->a_cookies) {
		if (error) {
			free(*ap->a_cookies, M_TEMP);
			*ap->a_cookies = NULL;
			*ap->a_ncookies = 0;
		} else {
			*ap->a_ncookies -= ncookies;
		}
	}

	if (!error)
		uio->uio_offset = newoff;
d2184 1
a2184 1
		/* loop thru the dir entries, doctoring them to 4bsd form */
d2202 1
a2202 1
			tlen = nfsm_rndup(len + 1);
d2204 1
a2204 1
			if ((tlen + NFS_DIRHDSIZ) > left) {
d2211 1
a2211 1
			if ((tlen + NFS_DIRHDSIZ) > uiop->uio_resid)
d2217 1
a2217 1
				dp->d_fileno = (int)fileno;
d2219 1
a2219 1
				dp->d_reclen = tlen + NFS_DIRHDSIZ;
d2221 1
a2221 1
				blksiz += dp->d_reclen;
d2231 1
a2231 1
				tlen -= len;
d2381 1
a2381 1
			tlen = nfsm_rndup(len + 1);
d2383 1
a2383 1
			if ((tlen + NFS_DIRHDSIZ) > left) {
d2391 1
a2391 1
			if ((tlen + NFS_DIRHDSIZ) > uiop->uio_resid)
d2397 1
a2397 1
				dp->d_fileno = (int)fileno;
d2399 1
a2399 1
				dp->d_reclen = tlen + NFS_DIRHDSIZ;
d2401 1
a2401 1
				blksiz += dp->d_reclen;
d2413 1
a2413 1
				tlen -= len;
@


1.143
log
@add a comment that we are faking it until code to ask the server is written.
requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.142 2013/03/28 02:17:16 tedu Exp $	*/
d2989 3
@


1.142
log
@a better try at pathconf for nfs. there may be lies, but they are better
lies than EINVAL, until we can uncover the truth.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.141 2013/03/27 01:56:50 tedu Exp $	*/
d2942 2
@


1.141
log
@rename NCHNAMLEN to NAMECACHE_MAXLEN. easier to read, easier to type.
ok beck deraadt after a style issue noticed by kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.140 2012/11/17 22:28:26 deraadt Exp $	*/
d64 1
a2941 3
 *
 * The NFS V2 protocol doesn't support this, so just return EINVAL
 * for V2.
a2946 1
#if 0
d2948 44
a2991 1
#endif
d2993 1
a2993 1
	return (EINVAL);
@


1.140
log
@buf_acquire() can sleep, so advance down b_vnbufs afterwards
ok beck guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.139 2012/03/23 15:51:26 guenther Exp $	*/
d2458 2
a2459 1
					if (cnp->cn_namelen <= NCHNAMLEN) {
@


1.139
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.138 2011/07/09 00:24:44 beck Exp $	*/
a2798 1
			nbp = LIST_NEXT(bp, b_vnbufs);
d2802 2
a2803 1
				!= (B_DELWRI | B_NEEDCOMMIT))
d2805 1
d2809 2
@


1.138
log
@KNF
ok md5  "can't be worse" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.137 2011/07/08 23:06:54 beck Exp $	*/
d3023 1
a3023 1
		++p->p_stats->p_ru.ru_oublock;
d3098 1
a3098 1
			++p->p_stats->p_ru.ru_oublock;
@


1.137
log
@fix nfs pending writes, which were not handled correctly in the commit
case.

ok guenther@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.136 2011/07/05 00:37:59 guenther Exp $	*/
d88 35
a122 35
        .vop_lookup     = nfs_lookup,
        .vop_create     = nfs_create,
        .vop_mknod      = nfs_mknod,
        .vop_open       = nfs_open,
        .vop_close      = nfs_close,
        .vop_access     = nfs_access,
        .vop_getattr    = nfs_getattr,
        .vop_setattr    = nfs_setattr,
        .vop_read       = nfs_read,
        .vop_write      = nfs_write,
        .vop_ioctl      = nfs_ioctl,
        .vop_poll       = nfs_poll,
        .vop_kqfilter   = nfs_kqfilter,
        .vop_revoke     = vop_generic_revoke,
        .vop_fsync      = nfs_fsync,
        .vop_remove     = nfs_remove,
        .vop_link       = nfs_link,
        .vop_rename     = nfs_rename,
        .vop_mkdir      = nfs_mkdir,
        .vop_rmdir      = nfs_rmdir,
        .vop_symlink    = nfs_symlink,
        .vop_readdir    = nfs_readdir,
        .vop_readlink   = nfs_readlink,
        .vop_abortop    = vop_generic_abortop,
        .vop_inactive   = nfs_inactive,
        .vop_reclaim    = nfs_reclaim,
        .vop_lock       = vop_generic_lock,     /* XXX: beck@@ must fix this. */
        .vop_unlock     = vop_generic_unlock,
        .vop_bmap       = nfs_bmap,
        .vop_strategy   = nfs_strategy,
        .vop_print      = nfs_print,
        .vop_islocked   = vop_generic_islocked,
        .vop_pathconf   = nfs_pathconf,
        .vop_advlock    = nfs_advlock,
        .vop_bwrite     = nfs_bwrite
d127 13
a139 13
        .vop_close      = nfsspec_close,
        .vop_access     = nfsspec_access,
        .vop_getattr    = nfs_getattr,
        .vop_setattr    = nfs_setattr,
        .vop_read       = nfsspec_read,
        .vop_write      = nfsspec_write,
        .vop_fsync      = nfs_fsync,
        .vop_inactive   = nfs_inactive,
        .vop_reclaim    = nfs_reclaim,
        .vop_lock       = vop_generic_lock,
        .vop_unlock     = vop_generic_unlock,
        .vop_print      = nfs_print,
        .vop_islocked   = vop_generic_islocked,
d141 1
a141 1
        /* XXX: Keep in sync with spec_vops. */
d168 14
a181 14
        .vop_close      = nfsfifo_close,
        .vop_access     = nfsspec_access,
        .vop_getattr    = nfs_getattr,
        .vop_setattr    = nfs_setattr,
        .vop_read       = nfsfifo_read,
        .vop_write      = nfsfifo_write,
        .vop_fsync      = nfs_fsync,
        .vop_inactive   = nfs_inactive,
        .vop_reclaim    = nfsfifo_reclaim,
        .vop_lock       = vop_generic_lock,
        .vop_unlock     = vop_generic_unlock,
        .vop_print      = nfs_print,
        .vop_islocked   = vop_generic_islocked,
        .vop_bwrite     = vop_generic_bwrite,
d183 1
a183 1
        /* XXX: Keep in sync with fifo_vops. */
d242 1
a242 1
	
d358 1
a358 1
	
d364 1
a364 1
	 	if (cachevalid && np->n_accstamp != -1 &&
d366 1
a366 1
		    	if (!error)
d477 6
a482 6
 *                     or commit them (this satisfies 1 and 2 except for the
 *                     case where the server crashes after this close but
 *                     before the commit RPC, which is felt to be "good
 *                     enough". Changing the last argument to nfs_flush() to
 *                     a 1 would force a commit operation, if it is felt a
 *                     commit is necessary now.
d571 1
a571 1
  	if ((vap->va_uid != (uid_t)VNOVAL ||
d577 7
a583 7
 		switch (vp->v_type) {
 		case VDIR:
 			return (EISDIR);
 		case VCHR:
 		case VBLK:
 		case VSOCK:
 		case VFIFO:
d590 3
a592 3
 			vap->va_size = VNOVAL;
 			break;
 		default:
d599 3
a601 3
 			if (vap->va_size == 0)
 				error = nfs_vinvalbuf(vp, 0,
 				     ap->a_cred, ap->a_p);
d604 1
a604 1
 				     ap->a_cred, ap->a_p);
d607 2
a608 2
 			tsize = np->n_size;
 			np->n_size = np->n_vattr.va_size = vap->va_size;
d610 2
a611 2
  		};
  	} else if ((vap->va_mtime.tv_sec != VNOVAL ||
d614 1
a614 1
  		(error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred,
d1130 2
a1131 2
			*tl++ = x;      /* "begin offset" */
			*tl++ = x;      /* "current offset" */
d1133 2
a1134 2
			*tl++ = x;      /* total to this offset */
			*tl = x;        /* size of this write */
d1182 3
a1184 3
			    bcopy((caddr_t)tl, (caddr_t)nmp->nm_verf,
				NFSX_V3WRITEVERF);
			    nmp->nm_flag |= NFSMNT_HASWRITEVERF;
d1187 3
a1189 3
			    *must_commit = 1;
			    bcopy((caddr_t)tl, (caddr_t)nmp->nm_verf,
				NFSX_V3WRITEVERF);
d1552 1
a1552 1
	struct vop_rename_args  *ap = v;
d1947 1
a1947 1
#define	NFS_DIRHDSIZ    (sizeof (struct nfs_dirent) - (MAXNAMLEN + 1))
d2025 1
a2025 1
			error = nfs_readdirplusrpc(vp, &readdir_uio, cred, 
d2036 1
a2036 1
		while (error == 0 && 
d2051 1
a2051 1
			if (error) 
d2053 1
a2053 1
			
d2055 1
a2055 1
			
d2068 1
a2068 1
	
d2078 2
a2079 2
	
	if (!error) 
d2122 1
a2122 1
	if (uiop->uio_iovcnt != 1 || 
d2177 1
a2177 1
	
d2295 1
a2295 1
nfs_readdirplusrpc(struct vnode *vp, struct uio *uiop, struct ucred *cred, 
d2319 1
a2319 1
	if (uiop->uio_iovcnt != 1 || 
d2327 2
a2328 2
	
        /*
d2337 1
a2337 1
 		tl = nfsm_build(&info.nmi_mb, 6 * NFSX_UNSIGNED);
d2364 1
a2364 1
	
d2428 19
a2446 18
			    dpossav1 = info.nmi_dpos;
			    mdsav1 = info.nmi_md;
			    nfsm_adv(NFSX_V3FATTR);
			    nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
			    doit = fxdr_unsigned(int, *tl);
			    if (doit) {
				nfsm_getfh(fhp, fhsize, 1);
				if (NFS_CMPFH(dnp, fhp, fhsize)) {
				    vref(vp);
				    newvp = vp;
				    np = dnp;
				} else {
				    error = nfs_nget(vp->v_mount, fhp,
					fhsize, &np);
				    if (error)
					doit = 0;
				    else
					newvp = NFSTOV(np);
d2448 16
a2463 16
			    }
			    if (doit && bigenough) {
				dpossav2 = info.nmi_dpos;
				info.nmi_dpos = dpossav1;
				mdsav2 = info.nmi_md;
				info.nmi_md = mdsav1;
				nfsm_loadattr(newvp, NULL);
				info.nmi_dpos = dpossav2;
				info.nmi_md = mdsav2;
				dp->d_type =
				    IFTODT(VTTOIF(np->n_vattr.va_type));
				if (cnp->cn_namelen <= NCHNAMLEN) {
					ndp->ni_vp = newvp;
					cache_purge(ndp->ni_dvp);
					nfs_cache_enter(ndp->ni_dvp, ndp->ni_vp,
					    cnp);
a2464 1
			    }
d2466 4
a2469 4
			    /* Just skip over the file handle */
			    nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
			    i = fxdr_unsigned(int, *tl);
			    nfsm_adv(nfsm_rndup(i));
d2472 2
a2473 2
			    vrele(newvp);
			    newvp = NULLVP;
d2615 5
a2619 5
		    np = *npp;
		    np->n_fhp = &np->n_fh;
		    bcopy((caddr_t)nfhp, (caddr_t)np->n_fhp, fhlen);
		    np->n_fhsize = fhlen;
		    newvp = NFSTOV(np);
d2621 3
a2623 3
		    vref(dvp);
		    newvp = dvp;
		    np = dnp;
d2625 6
a2630 6
		    error = nfs_nget(dvp->v_mount, nfhp, fhlen, &np);
		    if (error) {
			m_freem(info.nmi_mrep);
			return (error);
		    }
		    newvp = NFSTOV(np);
d2643 1
a2643 1
nfsmout: 
d2666 1
a2666 1
	
d2694 1
a2694 1
nfsmout: 
d2763 1
a2763 1
 * 	Walk through the buffer pool and push any dirty pages
d2844 3
a2846 3
			    if (i == 0)
			        bcstats.pendingwrites--;
			    brelse(bp);
d2848 10
a2857 10
			    if (i > 0)
			        bcstats.pendingwrites++;
			    s = splbio();
			    buf_undirty(bp);
			    vp->v_numoutput++;
			    bp->b_flags |= B_ASYNC;
			    bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
			    bp->b_dirtyoff = bp->b_dirtyend = 0;
			    biodone(bp);
			    splx(s);
d2877 6
a2882 6
			    if (nfs_sigintr(nmp, NULL, p))
				return (EINTR);
			    if (slpflag == PCATCH) {
				slpflag = 0;
				slptimeo = 2 * hz;
			    }
d2908 1
a2908 1
	        s = splbio();
d3102 1
a3102 1
	} 
d3120 1
a3120 1
        /*
@


1.136
log
@When calling nfs_request() for what could be an async request, pass
down curproc instead of the struct proc from the I/O request...which
may gone away behind our back.  Assert that the supplied request
*is* curproc in a couple other places.

Reproduction and testing by sthen@@
ok deraadt@@, beck@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.135 2011/07/04 21:00:10 deraadt Exp $	*/
d2830 2
d2843 3
a2845 1
			if (retv)
d2847 3
a2849 1
			else {
d3061 2
d3069 1
a3069 1
				else 
d3071 2
a3072 1
			}
@


1.135
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.134 2011/04/05 14:14:07 thib Exp $	*/
d1000 1
a1000 1
	info.nmi_procp = uiop->uio_procp;
d1055 1
a1055 1
		info.nmi_procp = uiop->uio_procp;
d1139 1
a1139 1
		info.nmi_procp = uiop->uio_procp;
d1262 1
d1375 1
d1621 1
a1621 1
		sdvp, sp->s_name, sp->s_namlen, scnp->cn_cred, scnp->cn_proc));
d3055 1
a3055 1
			retv = nfs_commit(bp->b_vp, off, cnt, bp->b_proc);
@


1.134
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.133 2010/12/21 20:14:43 thib Exp $	*/
d63 1
a66 1
#include <miscfs/specfs/specdev.h>
@


1.133
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.132 2010/09/10 16:34:09 thib Exp $	*/
a87 1
        .vop_default    = eopnotsupp,
a126 1
        .vop_default    = eopnotsupp,
a167 1
        .vop_default    = eopnotsupp,
@


1.132
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.131 2010/09/06 23:44:10 thib Exp $	*/
d86 38
a123 42
/*
 * Global vfs data structures for nfs
 */
int (**nfsv2_vnodeop_p)(void *);
struct vnodeopv_entry_desc nfsv2_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, nfs_lookup },
	{ &vop_create_desc, nfs_create },
	{ &vop_mknod_desc, nfs_mknod },
	{ &vop_open_desc, nfs_open },
	{ &vop_close_desc, nfs_close },
	{ &vop_access_desc, nfs_access },
	{ &vop_getattr_desc, nfs_getattr },
	{ &vop_setattr_desc, nfs_setattr },
	{ &vop_read_desc, nfs_read },
	{ &vop_write_desc, nfs_write },
	{ &vop_ioctl_desc, nfs_ioctl },
	{ &vop_poll_desc, nfs_poll },
	{ &vop_kqfilter_desc, nfs_kqfilter },
	{ &vop_revoke_desc, vop_generic_revoke },
	{ &vop_fsync_desc, nfs_fsync },
	{ &vop_remove_desc, nfs_remove },
	{ &vop_link_desc, nfs_link },
	{ &vop_rename_desc, nfs_rename },
	{ &vop_mkdir_desc, nfs_mkdir },
	{ &vop_rmdir_desc, nfs_rmdir },
	{ &vop_symlink_desc, nfs_symlink },
	{ &vop_readdir_desc, nfs_readdir },
	{ &vop_readlink_desc, nfs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, nfs_inactive },
	{ &vop_reclaim_desc, nfs_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, nfs_bmap },
	{ &vop_strategy_desc, nfs_strategy },
	{ &vop_print_desc, nfs_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, nfs_pathconf },
	{ &vop_advlock_desc, nfs_advlock },
	{ &vop_bwrite_desc, nfs_bwrite },
	{ NULL, NULL }
a124 2
struct vnodeopv_desc nfsv2_vnodeop_opv_desc =
	{ &nfsv2_vnodeop_p, nfsv2_vnodeop_entries };
d126 40
a165 20
/*
 * Special device vnode ops
 */
int (**spec_nfsv2nodeop_p)(void *);
struct vnodeopv_entry_desc spec_nfsv2nodeop_entries[] = {
	{ &vop_default_desc, spec_vnoperate },
	{ &vop_close_desc, nfsspec_close },
	{ &vop_access_desc, nfsspec_access },
	{ &vop_getattr_desc, nfs_getattr },
	{ &vop_setattr_desc, nfs_setattr },
	{ &vop_read_desc, nfsspec_read },
	{ &vop_write_desc, nfsspec_write },
	{ &vop_fsync_desc, nfs_fsync },
	{ &vop_inactive_desc, nfs_inactive },
	{ &vop_reclaim_desc, nfs_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_print_desc, nfs_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ NULL, NULL }
a166 2
struct vnodeopv_desc spec_nfsv2nodeop_opv_desc =
	{ &spec_nfsv2nodeop_p, spec_nfsv2nodeop_entries };
d169 39
a207 18
int (**fifo_nfsv2nodeop_p)(void *);
struct vnodeopv_entry_desc fifo_nfsv2nodeop_entries[] = {
	{ &vop_default_desc, fifo_vnoperate },
	{ &vop_close_desc, nfsfifo_close },
	{ &vop_access_desc, nfsspec_access },
	{ &vop_getattr_desc, nfs_getattr },
	{ &vop_setattr_desc, nfs_setattr },
	{ &vop_read_desc, nfsfifo_read },
	{ &vop_write_desc, nfsfifo_write },
	{ &vop_fsync_desc, nfs_fsync },
	{ &vop_inactive_desc, nfs_inactive },
	{ &vop_reclaim_desc, nfsfifo_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_print_desc, nfs_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a208 2
struct vnodeopv_desc fifo_nfsv2nodeop_opv_desc =
	{ &fifo_nfsv2nodeop_p, fifo_nfsv2nodeop_entries };
d3161 1
a3161 1
	return (VOCALL(spec_vnodeop_p, VOFFSET(vop_read), ap));
d3178 1
a3178 1
	return (VOCALL(spec_vnodeop_p, VOFFSET(vop_write), ap));
d3206 1
a3206 1
	return (VOCALL(spec_vnodeop_p, VOFFSET(vop_close), ap));
a3216 1
	extern int (**fifo_vnodeop_p)(void *);
d3224 1
a3224 1
	return (VOCALL(fifo_vnodeop_p, VOFFSET(vop_read), ap));
a3233 1
	extern int (**fifo_vnodeop_p)(void *);
d3241 1
a3241 1
	return (VOCALL(fifo_vnodeop_p, VOFFSET(vop_write), ap));
a3255 1
	extern int (**fifo_vnodeop_p)(void *);
d3275 1
a3275 1
	return (VOCALL(fifo_vnodeop_p, VOFFSET(vop_close), ap));
@


1.131
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.130 2010/05/19 08:31:23 thib Exp $	*/
d86 42
a127 38
/* Global vfs data structures for nfs. */
struct vops nfs_vops = {
        .vop_default    = eopnotsupp,
        .vop_lookup     = nfs_lookup,
        .vop_create     = nfs_create,
        .vop_mknod      = nfs_mknod,
        .vop_open       = nfs_open,
        .vop_close      = nfs_close,
        .vop_access     = nfs_access,
        .vop_getattr    = nfs_getattr,
        .vop_setattr    = nfs_setattr,
        .vop_read       = nfs_read,
        .vop_write      = nfs_write,
        .vop_ioctl      = nfs_ioctl,
        .vop_poll       = nfs_poll,
        .vop_kqfilter   = nfs_kqfilter,
        .vop_revoke     = vop_generic_revoke,
        .vop_fsync      = nfs_fsync,
        .vop_remove     = nfs_remove,
        .vop_link       = nfs_link,
        .vop_rename     = nfs_rename,
        .vop_mkdir      = nfs_mkdir,
        .vop_rmdir      = nfs_rmdir,
        .vop_symlink    = nfs_symlink,
        .vop_readdir    = nfs_readdir,
        .vop_readlink   = nfs_readlink,
        .vop_abortop    = vop_generic_abortop,
        .vop_inactive   = nfs_inactive,
        .vop_reclaim    = nfs_reclaim,
        .vop_lock       = vop_generic_lock,     /* XXX: beck@@ must fix this. */
        .vop_unlock     = vop_generic_unlock,
        .vop_bmap       = nfs_bmap,
        .vop_strategy   = nfs_strategy,
        .vop_print      = nfs_print,
        .vop_islocked   = vop_generic_islocked,
        .vop_pathconf   = nfs_pathconf,
        .vop_advlock    = nfs_advlock,
        .vop_bwrite     = nfs_bwrite
d129 2
d132 20
a151 40
/* Special device vnode ops. */
struct vops nfs_specvops = {
        .vop_default    = eopnotsupp,
        .vop_close      = nfsspec_close,
        .vop_access     = nfsspec_access,
        .vop_getattr    = nfs_getattr,
        .vop_setattr    = nfs_setattr,
        .vop_read       = nfsspec_read,
        .vop_write      = nfsspec_write,
        .vop_fsync      = nfs_fsync,
        .vop_inactive   = nfs_inactive,
        .vop_reclaim    = nfs_reclaim,
        .vop_lock       = vop_generic_lock,
        .vop_unlock     = vop_generic_unlock,
        .vop_print      = nfs_print,
        .vop_islocked   = vop_generic_islocked,

        /* XXX: Keep in sync with spec_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
d153 2
d157 18
a174 39
struct vops nfs_fifovops = {
        .vop_default    = eopnotsupp,
        .vop_close      = nfsfifo_close,
        .vop_access     = nfsspec_access,
        .vop_getattr    = nfs_getattr,
        .vop_setattr    = nfs_setattr,
        .vop_read       = nfsfifo_read,
        .vop_write      = nfsfifo_write,
        .vop_fsync      = nfs_fsync,
        .vop_inactive   = nfs_inactive,
        .vop_reclaim    = nfsfifo_reclaim,
        .vop_lock       = vop_generic_lock,
        .vop_unlock     = vop_generic_unlock,
        .vop_print      = nfs_print,
        .vop_islocked   = vop_generic_islocked,
        .vop_bwrite     = vop_generic_bwrite,

        /* XXX: Keep in sync with fifo_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock,
d176 2
d3130 1
a3130 1
	return (spec_read(ap));
d3147 1
a3147 1
	return (spec_write(ap));
d3175 1
a3175 1
	return (spec_close(ap));
d3186 1
d3194 1
a3194 1
	return (fifo_read(ap));
d3204 1
d3212 1
a3212 1
	return (fifo_write(ap));
d3227 1
d3247 1
a3247 1
	return (fifo_close(ap));
@


1.130
log
@clean up a few things that where left to rot after bob's vfs cache work.
sync a few comments to reality (or remove them), remove the cn_hash member
from struct componentname, spacing.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.129 2010/04/12 16:37:38 beck Exp $	*/
d86 38
a123 42
/*
 * Global vfs data structures for nfs
 */
int (**nfsv2_vnodeop_p)(void *);
struct vnodeopv_entry_desc nfsv2_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, nfs_lookup },
	{ &vop_create_desc, nfs_create },
	{ &vop_mknod_desc, nfs_mknod },
	{ &vop_open_desc, nfs_open },
	{ &vop_close_desc, nfs_close },
	{ &vop_access_desc, nfs_access },
	{ &vop_getattr_desc, nfs_getattr },
	{ &vop_setattr_desc, nfs_setattr },
	{ &vop_read_desc, nfs_read },
	{ &vop_write_desc, nfs_write },
	{ &vop_ioctl_desc, nfs_ioctl },
	{ &vop_poll_desc, nfs_poll },
	{ &vop_kqfilter_desc, nfs_kqfilter },
	{ &vop_revoke_desc, vop_generic_revoke },
	{ &vop_fsync_desc, nfs_fsync },
	{ &vop_remove_desc, nfs_remove },
	{ &vop_link_desc, nfs_link },
	{ &vop_rename_desc, nfs_rename },
	{ &vop_mkdir_desc, nfs_mkdir },
	{ &vop_rmdir_desc, nfs_rmdir },
	{ &vop_symlink_desc, nfs_symlink },
	{ &vop_readdir_desc, nfs_readdir },
	{ &vop_readlink_desc, nfs_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, nfs_inactive },
	{ &vop_reclaim_desc, nfs_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, nfs_bmap },
	{ &vop_strategy_desc, nfs_strategy },
	{ &vop_print_desc, nfs_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, nfs_pathconf },
	{ &vop_advlock_desc, nfs_advlock },
	{ &vop_bwrite_desc, nfs_bwrite },
	{ NULL, NULL }
a124 2
struct vnodeopv_desc nfsv2_vnodeop_opv_desc =
	{ &nfsv2_vnodeop_p, nfsv2_vnodeop_entries };
d126 40
a165 20
/*
 * Special device vnode ops
 */
int (**spec_nfsv2nodeop_p)(void *);
struct vnodeopv_entry_desc spec_nfsv2nodeop_entries[] = {
	{ &vop_default_desc, spec_vnoperate },
	{ &vop_close_desc, nfsspec_close },
	{ &vop_access_desc, nfsspec_access },
	{ &vop_getattr_desc, nfs_getattr },
	{ &vop_setattr_desc, nfs_setattr },
	{ &vop_read_desc, nfsspec_read },
	{ &vop_write_desc, nfsspec_write },
	{ &vop_fsync_desc, nfs_fsync },
	{ &vop_inactive_desc, nfs_inactive },
	{ &vop_reclaim_desc, nfs_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_print_desc, nfs_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ NULL, NULL }
a166 2
struct vnodeopv_desc spec_nfsv2nodeop_opv_desc =
	{ &spec_nfsv2nodeop_p, spec_nfsv2nodeop_entries };
d169 39
a207 18
int (**fifo_nfsv2nodeop_p)(void *);
struct vnodeopv_entry_desc fifo_nfsv2nodeop_entries[] = {
	{ &vop_default_desc, fifo_vnoperate },
	{ &vop_close_desc, nfsfifo_close },
	{ &vop_access_desc, nfsspec_access },
	{ &vop_getattr_desc, nfs_getattr },
	{ &vop_setattr_desc, nfs_setattr },
	{ &vop_read_desc, nfsfifo_read },
	{ &vop_write_desc, nfsfifo_write },
	{ &vop_fsync_desc, nfs_fsync },
	{ &vop_inactive_desc, nfs_inactive },
	{ &vop_reclaim_desc, nfsfifo_reclaim },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_print_desc, nfs_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a208 2
struct vnodeopv_desc fifo_nfsv2nodeop_opv_desc =
	{ &fifo_nfsv2nodeop_p, fifo_nfsv2nodeop_entries };
d3161 1
a3161 1
	return (VOCALL(spec_vnodeop_p, VOFFSET(vop_read), ap));
d3178 1
a3178 1
	return (VOCALL(spec_vnodeop_p, VOFFSET(vop_write), ap));
d3206 1
a3206 1
	return (VOCALL(spec_vnodeop_p, VOFFSET(vop_close), ap));
a3216 1
	extern int (**fifo_vnodeop_p)(void *);
d3224 1
a3224 1
	return (VOCALL(fifo_vnodeop_p, VOFFSET(vop_read), ap));
a3233 1
	extern int (**fifo_vnodeop_p)(void *);
d3241 1
a3241 1
	return (VOCALL(fifo_vnodeop_p, VOFFSET(vop_write), ap));
a3255 1
	extern int (**fifo_vnodeop_p)(void *);
d3275 1
a3275 1
	return (VOCALL(fifo_vnodeop_p, VOFFSET(vop_close), ap));
@


1.129
log
@
Don't jump the queue if we have to wait on the client side because
the nfs_bufq is full - instead tsleep waiting for one of our nfsiod's
to free up space for us in the queue so we can enqueue on the end.

ok blambert@@, tedu@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.128 2010/03/29 23:33:39 krw Exp $	*/
a2429 3
					cnp->cn_hash =
					    hash32_str(cnp->cn_nameptr,
					        HASHINIT);
@


1.128
log
@Initialize various uninitialized variables. Found by jsg@@ via Clang.

Feedback from miod@@ and kettenis@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.127 2009/12/15 15:53:48 beck Exp $	*/
d2718 1
a2718 1
	if ((bp->b_flags & B_ASYNC) == 0 || nfs_asyncio(bp))
@


1.127
log
@
Make sillyrename not so damn silly. The kindergarten algorithm here for
picking a name meant that more than 58 sillys in a directory and we fail
with EINVAL, resulting in strange problems for nfs which in turn causes
pain and stress in building, and PTSD in nfs and vfs hackers. Has bit us
in the butt since the vienna f2k7 hackathon.

good suggestions from deraadt@@ guenther@@ and otto@@

ok deraadt@@,oga@@,blambert@@,krw@@,guenther@@, and a "very special ok" tedu@@

Oh god, I'm an nfs hacker..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.126 2009/12/10 16:41:45 beck Exp $	*/
d1930 1
a1930 1
	int tresid, error;
@


1.126
log
@"fix" from freebsd to hide potential race in silly renames, where
a directory gets reclaimed on a forced unmount before the silly file
in it gets blown away...  fixes an issue seen by phessler@@

ok oga@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.125 2009/10/19 22:24:18 jsg Exp $	*/
a188 1

d2521 7
a2527 5
	/* Fudge together a funny name */
	sp->s_namlen = snprintf(sp->s_name, sizeof sp->s_name,
	    ".nfsA%05x4.4", cnp->cn_proc->p_pid);
	if (sp->s_namlen > sizeof sp->s_name)
		sp->s_namlen = strlen(sp->s_name);
d2529 3
a2531 8
	/* Try lookitups until we get one that isn't there */
	while (nfs_lookitup(dvp, sp->s_name, sp->s_namlen, sp->s_cred,
		cnp->cn_proc, NULL) == 0) {
		sp->s_name[4]++;
		if (sp->s_name[4] > 'z') {
			error = EINVAL;
			goto bad;
		}
d2533 1
@


1.125
log
@antsy
no binary change apart from nfsm_reqhead() which is clearly correct.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.124 2009/09/02 18:20:54 thib Exp $	*/
d1468 10
a1477 1

@


1.124
log
@Backout the asyncio/aiod change, as it causes buf's to get hung.
problem noticed by deraadt@@

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.121 2009/08/13 15:00:14 jasper Exp $	*/
d211 1
a211 4
nfs_null(vp, cred, procp)
	struct vnode *vp;
	struct ucred *cred;
	struct proc *procp;
d229 1
a229 2
nfs_access(v)
	void *v;
d364 1
a364 2
nfs_open(v)
	void *v;
d458 1
a458 2
nfs_close(v)
	void *v;
d486 1
a486 2
nfs_getattr(v)
	void *v;
d525 1
a525 2
nfs_setattr(v)
	void *v;
d608 2
a609 5
nfs_setattrrpc(vp, vap, cred, procp)
	struct vnode *vp;
	struct vattr *vap;
	struct ucred *cred;
	struct proc *procp;
d668 1
a668 2
nfs_lookup(v)
	void *v;
d930 1
a930 2
nfs_read(v)
	void *v;
d944 1
a944 2
nfs_readlink(v)
	void *v;
d959 1
a959 4
nfs_readlinkrpc(vp, uiop, cred)
	struct vnode *vp;
	struct uio *uiop;
	struct ucred *cred;
d995 1
a995 3
nfs_readrpc(vp, uiop)
	struct vnode *vp;
	struct uio *uiop;
d1064 1
a1064 4
nfs_writerpc(vp, uiop, iomode, must_commit)
	struct vnode *vp;
	struct uio *uiop;
	int *iomode, *must_commit;
d1185 2
a1186 5
nfs_mknodrpc(dvp, vpp, cnp, vap)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
d1277 1
a1277 2
nfs_mknod(v)
	void *v;
d1293 1
a1293 2
nfs_create(v)
	void *v;
d1403 1
a1403 2
nfs_remove(v)
	void *v;
d1466 1
a1466 2
nfs_removeit(sp)
	struct sillyrename *sp;
d1477 2
a1478 6
nfs_removerpc(dvp, name, namelen, cred, proc)
	struct vnode *dvp;
	char *name;
	int namelen;
	struct ucred *cred;
	struct proc *proc;
d1512 1
a1512 2
nfs_rename(v)
	void *v;
d1579 2
a1580 4
nfs_renameit(sdvp, scnp, sp)
	struct vnode *sdvp;
	struct componentname *scnp;
	struct sillyrename *sp;
d1590 3
a1592 9
nfs_renamerpc(fdvp, fnameptr, fnamelen, tdvp, tnameptr, tnamelen, cred, proc)
	struct vnode *fdvp;
	char *fnameptr;
	int fnamelen;
	struct vnode *tdvp;
	char *tnameptr;
	int tnamelen;
	struct ucred *cred;
	struct proc *proc;
d1633 1
a1633 2
nfs_link(v)
	void *v;
d1696 1
a1696 2
nfs_symlink(v)
	void *v;
d1758 1
a1758 2
nfs_mkdir(v)
	void *v;
d1837 1
a1837 2
nfs_rmdir(v)
	void *v;
d1916 1
a1916 2
nfs_readdir(v)
	void *v;
d2063 1
a2063 3
nfs_readdirrpc(struct vnode *vp, 
    struct uio *uiop, 
    struct ucred *cred,
d2492 1
a2492 3
nfs_sillyrename(dvp, vp, cnp)
	struct vnode *dvp, *vp;
	struct componentname *cnp;
d2551 2
a2552 7
nfs_lookitup(dvp, name, len, cred, procp, npp)
	struct vnode *dvp;
	char *name;
	int len;
	struct ucred *cred;
	struct proc *procp;
	struct nfsnode **npp;
d2625 1
a2625 5
nfs_commit(vp, offset, cnt, procp)
	struct vnode *vp;
	u_quad_t offset;
	int cnt;
	struct proc *procp;
d2675 1
a2675 2
nfs_bmap(v)
	void *v;
d2694 1
a2694 2
nfs_strategy(v)
	void *v;
d2721 1
a2721 2
nfs_fsync(v)
	void *v;
d2734 2
a2735 6
nfs_flush(vp, cred, waitfor, p, commit)
	struct vnode *vp;
	struct ucred *cred;
	int waitfor;
	struct proc *p;
	int commit;
d2904 1
a2904 2
nfs_pathconf(v)
	void *v;
d2917 1
a2917 2
nfs_advlock(v)
	void *v;
d2930 1
a2930 2
nfs_print(v)
	void *v;
d2950 1
a2950 2
nfs_bwrite(v)
	void *v;
d2962 1
a2962 3
nfs_writebp(bp, force)
	struct buf *bp;
	int force;
d3071 1
a3071 2
nfsspec_access(v)
	void *v;
d3103 1
a3103 2
nfs_poll(v)
        void *v;
d3117 1
a3117 2
nfsspec_read(v)
	void *v;
d3134 1
a3134 2
nfsspec_write(v)
	void *v;
d3153 1
a3153 2
nfsspec_close(v)
	void *v;
d3180 1
a3180 2
nfsfifo_read(v)
	void *v;
d3198 1
a3198 2
nfsfifo_write(v)
	void *v;
d3218 1
a3218 2
nfsfifo_close(v)
	void *v;
@


1.123
log
@Rework the way we do async I/O in nfs. Introduce separate buf queues for
each mount, and when work is "found", peg an aiod to that mount todo the
I/O. Make nfs_asyncio() a bit smarter when deciding when to do asyncio
and when to force it sync, this is done by keeping the aiod's one two lists,
an "idle" and an "all" list, so asyncio is only done when there are aiods
hanging around todo it for us or are already pegged to the mount.

Idea liked by at least beck@@ (and I think art@@).
Extensive testing done by myself and jasper and a few others on various
arch's.

Ideas/Code from Net/Free.

OK blambert@@.
@
text
@d187 2
@


1.122
log
@Teach nfsm_fhtom about nfsm_info structs

ok thib@@
@
text
@a186 2
int nfs_numasync = 0;

@


1.121
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.120 2009/08/04 17:12:39 thib Exp $	*/
d291 1
a291 1
		nfsm_fhtom(&info.nmi_mb, vp, v3);
d517 1
a517 1
	nfsm_fhtom(&info.nmi_mb, vp, info.nmi_v3);
d634 1
a634 1
	nfsm_fhtom(&info.nmi_mb, vp, v3);
d791 1
a791 1
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d988 1
a988 1
	nfsm_fhtom(&info.nmi_mb, vp, info.nmi_v3);
d1036 1
a1036 1
		nfsm_fhtom(&info.nmi_mb, vp, info.nmi_v3);
d1111 1
a1111 1
		nfsm_fhtom(&info.nmi_mb, vp, info.nmi_v3);
d1238 1
a1238 1
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d1351 1
a1351 1
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d1524 1
a1524 1
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d1647 1
a1647 1
	nfsm_fhtom(&info.nmi_mb, fdvp, info.nmi_v3);
d1649 1
a1649 1
	nfsm_fhtom(&info.nmi_mb, tdvp, info.nmi_v3);
d1709 2
a1710 2
	nfsm_fhtom(&info.nmi_mb, vp, info.nmi_v3);
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d1761 1
a1761 1
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d1826 1
a1826 1
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d1907 1
a1907 1
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d2149 1
a2149 1
		nfsm_fhtom(&info.nmi_mb, vp, info.nmi_v3);
d2347 1
a2347 1
		nfsm_fhtom(&info.nmi_mb, vp, 1);
d2624 1
a2624 1
	nfsm_fhtom(&info.nmi_mb, dvp, info.nmi_v3);
d2698 1
a2698 1
	nfsm_fhtom(&info.nmi_mb, vp, 1);
@


1.120
log
@group all of the on-stack variables that are uses by the nfsm_macros
to keep the data munging "state" into an nfsm_info structure. Each
function now has this structure on its stack, and it and its members
are now passed around so that the macros/functions can work there magic.

this will make removing the nfsm_* macros way easier.

Idea/code picked up from DragonflyBSD.

Tested by krw@@, jacekm@@ and myself.

OK blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.113 2009/06/04 00:31:42 blambert Exp $	*/
d92 34
a125 34
	{ &vop_lookup_desc, nfs_lookup },	/* lookup */
	{ &vop_create_desc, nfs_create },	/* create */
	{ &vop_mknod_desc, nfs_mknod },		/* mknod */
	{ &vop_open_desc, nfs_open },		/* open */
	{ &vop_close_desc, nfs_close },		/* close */
	{ &vop_access_desc, nfs_access },	/* access */
	{ &vop_getattr_desc, nfs_getattr },	/* getattr */
	{ &vop_setattr_desc, nfs_setattr },	/* setattr */
	{ &vop_read_desc, nfs_read },		/* read */
	{ &vop_write_desc, nfs_write },		/* write */
	{ &vop_ioctl_desc, nfs_ioctl },		/* ioctl */
	{ &vop_poll_desc, nfs_poll },		/* poll */
	{ &vop_kqfilter_desc, nfs_kqfilter },	/* kqfilter */
	{ &vop_revoke_desc, vop_generic_revoke },	/* revoke */
	{ &vop_fsync_desc, nfs_fsync },		/* fsync */
	{ &vop_remove_desc, nfs_remove },	/* remove */
	{ &vop_link_desc, nfs_link },		/* link */
	{ &vop_rename_desc, nfs_rename },	/* rename */
	{ &vop_mkdir_desc, nfs_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, nfs_rmdir },		/* rmdir */
	{ &vop_symlink_desc, nfs_symlink },	/* symlink */
	{ &vop_readdir_desc, nfs_readdir },	/* readdir */
	{ &vop_readlink_desc, nfs_readlink },	/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },	/* abortop */
	{ &vop_inactive_desc, nfs_inactive },	/* inactive */
	{ &vop_reclaim_desc, nfs_reclaim },	/* reclaim */
	{ &vop_lock_desc, vop_generic_lock },	/* lock */
	{ &vop_unlock_desc, vop_generic_unlock },	/* unlock */
	{ &vop_bmap_desc, nfs_bmap },		/* bmap */
	{ &vop_strategy_desc, nfs_strategy },	/* strategy */
	{ &vop_print_desc, nfs_print },		/* print */
	{ &vop_islocked_desc, vop_generic_islocked },	/* islocked */
	{ &vop_pathconf_desc, nfs_pathconf },	/* pathconf */
	{ &vop_advlock_desc, nfs_advlock },	/* advlock */
d138 13
a150 13
	{ &vop_close_desc, nfsspec_close },	/* close */
	{ &vop_access_desc, nfsspec_access },	/* access */
	{ &vop_getattr_desc, nfs_getattr },	/* getattr */
	{ &vop_setattr_desc, nfs_setattr },	/* setattr */
	{ &vop_read_desc, nfsspec_read },	/* read */
	{ &vop_write_desc, nfsspec_write },	/* write */
	{ &vop_fsync_desc, nfs_fsync },		/* fsync */
	{ &vop_inactive_desc, nfs_inactive },	/* inactive */
	{ &vop_reclaim_desc, nfs_reclaim },	/* reclaim */
	{ &vop_lock_desc, vop_generic_lock },	/* lock */
	{ &vop_unlock_desc, vop_generic_unlock },	/* unlock */
	{ &vop_print_desc, nfs_print },		/* print */
	{ &vop_islocked_desc, vop_generic_islocked },	/* islocked */
d160 13
a172 13
	{ &vop_close_desc, nfsfifo_close },	/* close */
	{ &vop_access_desc, nfsspec_access },	/* access */
	{ &vop_getattr_desc, nfs_getattr },	/* getattr */
	{ &vop_setattr_desc, nfs_setattr },	/* setattr */
	{ &vop_read_desc, nfsfifo_read },	/* read */
	{ &vop_write_desc, nfsfifo_write },	/* write */
	{ &vop_fsync_desc, nfs_fsync },		/* fsync */
	{ &vop_inactive_desc, nfs_inactive },	/* inactive */
	{ &vop_reclaim_desc, nfsfifo_reclaim },	/* reclaim */
	{ &vop_lock_desc, vop_generic_lock },	/* lock */
	{ &vop_unlock_desc, vop_generic_unlock },	/* unlock */
	{ &vop_print_desc, nfs_print },		/* print */
	{ &vop_islocked_desc, vop_generic_islocked },	/* islocked */
@


1.119
log
@(struct foo *)0 -> NULL, every where I could find it.

OK blambert@@
@
text
@d216 2
a217 3
	caddr_t dpos;
	int error = 0;
	struct mbuf *mreq, *mrep, *md, *mb;
d219 3
a221 4
	mb = mreq = nfsm_reqhead(0);
	error = nfs_request(vp, mreq, NFSPROC_NULL, procp, cred, &mrep,
	    &md, &dpos);
	m_freem(mrep);
d239 1
a239 1
	caddr_t dpos, cp2;
a240 1
	struct mbuf *mreq, *mrep, *md, *mb;
d244 1
d290 3
a292 3
		mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_UNSIGNED);
		nfsm_fhtom(&mb, vp, v3);
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
d311 3
a313 2
		error = nfs_request(vp, mreq, NFSPROC_ACCESS, ap->a_p,
		    ap->a_cred, &mrep, &md, &dpos);
d317 1
a317 1
			m_freem(mrep);
d331 1
a331 1
		m_freem(mrep);
d498 1
a499 1
	caddr_t dpos;
d501 3
a503 3
	struct mbuf *mreq, *mrep, *md, *mb;
	int v3 = NFS_ISV3(vp);
	
d514 1
d516 5
a520 4
	mb = mreq = nfsm_reqhead(NFSX_FH(v3));
	nfsm_fhtom(&mb, vp, v3);
	error = nfs_request(vp, mreq, NFSPROC_GETATTR, ap->a_p,
	    ap->a_cred, &mrep, &md, &dpos);
d523 1
a523 1
	m_freem(mrep);
d623 1
d625 1
a625 1
	caddr_t dpos, cp2;
a627 1
	struct mbuf *mreq, *mrep, *md, *mb;
d630 2
d633 2
a634 2
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_SATTR(v3));
	nfsm_fhtom(&mb, vp, v3);
d636 3
a638 3
	if (v3) {
		nfsm_v3attrbuild(&mb, vap, 1);
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
d641 1
a641 1
		sp = nfsm_build(&mb, NFSX_V2SATTR);
d659 3
a661 2
	error = nfs_request(vp, mreq, NFSPROC_SETATTR, procp, cred, &mrep,
	    &md, &dpos);
d663 1
a663 1
	if (v3)
d668 1
a668 1
	m_freem(mrep);
d687 1
d693 1
a693 2
	caddr_t dpos, cp2;
	struct mbuf *mreq, *mrep, *md, *mb;
d698 2
a699 1
	int v3 = NFS_ISV3(dvp);
d789 3
a791 2
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_UNSIGNED + nfsm_rndup(len));
	nfsm_fhtom(&mb, dvp, v3);
d794 3
a796 2
	error = nfs_request(dvp, mreq, NFSPROC_LOOKUP, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos);
d799 1
a799 1
		if (v3)
d801 1
a801 1
		m_freem(mrep);
d805 1
a805 1
	nfsm_getfh(fhp, fhsize, v3);
d812 1
a812 1
			m_freem(mrep);
d817 1
a817 1
			m_freem(mrep);
d821 1
a821 1
		if (v3) {
d827 1
a827 1
		m_freem(mrep);
d845 1
a845 1
		if (v3) {
d858 1
a858 1
			m_freem(mrep);
d863 1
a863 1
		if (v3) {
d871 1
a871 1
				m_freem(mrep);
d881 1
a881 1
			m_freem(mrep);
d885 1
a885 1
		if (v3) {
d904 1
a904 1
	m_freem(mrep);
d978 1
d981 1
a981 1
	caddr_t dpos, cp2;
d983 2
a984 2
	struct mbuf *mreq, *mrep, *md, *mb;
	int v3 = NFS_ISV3(vp);
d987 2
a988 2
	mb = mreq = nfsm_reqhead(NFSX_FH(v3));
	nfsm_fhtom(&mb, vp, v3);
d990 3
a992 2
	error = nfs_request(vp, mreq, NFSPROC_READLINK, uiop->uio_procp,
	    cred, &mrep, &md, &dpos);
d994 1
a994 1
	if (v3)
d1001 2
a1002 1
	m_freem(mrep);
d1016 1
d1019 1
a1019 2
	caddr_t dpos, cp2;
	struct mbuf *mreq, *mrep, *md, *mb;
d1022 2
a1023 1
	int v3 = NFS_ISV3(vp);
d1029 1
a1029 1
	if (uiop->uio_offset + tsiz > 0xffffffff && !v3)
d1034 5
a1038 4
		mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_UNSIGNED * 3);
		nfsm_fhtom(&mb, vp, v3);
		tl = nfsm_build(&mb, NFSX_UNSIGNED * 3);
		if (v3) {
d1047 4
a1050 3
		error = nfs_request(vp, mreq, NFSPROC_READ, uiop->uio_procp,
		    VTONFS(vp)->n_rcred, &mrep, &md, &dpos);
		if (v3)
d1053 1
a1053 1
			m_freem(mrep);
d1057 1
a1057 1
		if (v3) {
d1066 1
a1066 1
		m_freem(mrep);
d1068 1
a1068 1
		if (v3) {
d1074 1
d1088 1
d1091 1
a1091 2
	caddr_t dpos, cp2;
	struct mbuf *mreq, *mrep, *md, *mb;
d1094 3
a1096 1
	int v3 = NFS_ISV3(vp), committed = NFSV3WRITE_FILESYNC;
d1104 1
a1104 1
	if (uiop->uio_offset + tsiz > 0xffffffff && !v3)
d1109 5
a1113 5
		mb = mreq = nfsm_reqhead(NFSX_FH(v3) + 5 * NFSX_UNSIGNED +
		    nfsm_rndup(len));
		nfsm_fhtom(&mb, vp, v3);
		if (v3) {
			tl = nfsm_build(&mb, 5 * NFSX_UNSIGNED);
d1122 1
a1122 1
			tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED);
d1132 1
a1132 1
		nfsm_uiotombuf(&mb, uiop, len);
d1134 4
a1137 3
		error = nfs_request(vp, mreq, NFSPROC_WRITE, uiop->uio_procp,
		    VTONFS(vp)->n_wcred, &mrep, &md, &dpos);
		if (v3) {
d1143 1
a1143 1
			m_freem(mrep);
d1147 1
a1147 1
		if (v3) {
d1191 1
a1191 1
		m_freem(mrep);
d1214 1
a1219 1
	caddr_t dpos;
a1220 1
	struct mbuf *mreq, *mrep, *md, *mb;
d1222 2
a1223 1
	int v3 = NFS_ISV3(dvp);
d1235 4
a1238 3
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + 4 * NFSX_UNSIGNED +
	    nfsm_rndup(cnp->cn_namelen) + NFSX_SATTR(v3));
	nfsm_fhtom(&mb, dvp, v3);
d1241 2
a1242 2
	if (v3) {
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
d1244 1
a1244 1
		nfsm_v3attrbuild(&mb, vap, 0);
d1246 1
a1246 1
			tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
d1251 1
a1251 1
		sp = nfsm_build(&mb, NFSX_V2SATTR);
d1260 3
a1262 2
	error = nfs_request(dvp, mreq, NFSPROC_MKNOD, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos);
d1264 1
a1264 1
		nfsm_mtofh(dvp, newvp, v3, gotvp);
d1276 1
a1276 1
	if (v3)
d1278 2
a1279 1
	m_freem(mrep);
d1327 1
d1332 1
a1332 1
	caddr_t dpos, cp2;
d1334 2
a1335 2
	struct mbuf *mreq, *mrep, *md, *mb;
	int v3 = NFS_ISV3(dvp);
d1348 4
a1351 3
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + 2 * NFSX_UNSIGNED +
	    nfsm_rndup(cnp->cn_namelen) + NFSX_SATTR(v3));
	nfsm_fhtom(&mb, dvp, v3);
d1353 2
a1354 2
	if (v3) {
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
d1357 1
a1357 1
			tl = nfsm_build(&mb, NFSX_V3CREATEVERF);
d1362 1
a1362 1
			nfsm_v3attrbuild(&mb, vap, 0);
d1365 1
a1365 1
		sp = nfsm_build(&mb, NFSX_V2SATTR);
d1374 3
a1376 2
	error = nfs_request(dvp, mreq, NFSPROC_CREATE, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos);
d1378 1
a1378 1
		nfsm_mtofh(dvp, newvp, v3, gotvp);
d1390 1
a1390 1
	if (v3)
d1392 2
a1393 1
	m_freem(mrep);
d1396 1
a1396 1
		if (v3 && (fmode & O_EXCL) && error == NFSERR_NOTSUPP) {
d1402 1
a1402 1
	} else if (v3 && (fmode & O_EXCL))
d1513 1
d1516 1
a1516 1
	caddr_t dpos, cp2;
d1518 2
a1519 2
	struct mbuf *mreq, *mrep, *md, *mb;
	int v3 = NFS_ISV3(dvp);
d1522 3
a1524 3
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_UNSIGNED +
	     nfsm_rndup(namelen));
	nfsm_fhtom(&mb, dvp, v3);
d1526 5
a1530 3
	error = nfs_request(dvp, mreq, NFSPROC_REMOVE, proc, cred, &mrep,
	    &md, &dpos);
	if (v3)
d1532 2
a1533 1
	m_freem(mrep);
d1636 1
d1639 1
a1639 1
	caddr_t dpos, cp2;
d1641 2
a1642 2
	struct mbuf *mreq, *mrep, *md, *mb;
	int v3 = NFS_ISV3(fdvp);
d1645 3
a1647 3
	mb = mreq = nfsm_reqhead((NFSX_FH(v3) + NFSX_UNSIGNED)*2 +
	    nfsm_rndup(fnamelen) + nfsm_rndup(tnamelen));
	nfsm_fhtom(&mb, fdvp, v3);
d1649 1
a1649 1
	nfsm_fhtom(&mb, tdvp, v3);
d1651 5
a1655 3
	error = nfs_request(fdvp, mreq, NFSPROC_RENAME, proc, cred, &mrep,
	    &md, &dpos);
	if (v3) {
d1659 2
a1660 1
	m_freem(mrep);
d1682 1
d1685 1
a1685 1
	caddr_t dpos, cp2;
d1687 2
a1688 2
	struct mbuf *mreq, *mrep, *md, *mb;
	int v3;
a1705 1
	v3 = NFS_ISV3(vp);
d1707 4
a1710 4
	mb = mreq = nfsm_reqhead(2 * NFSX_FH(v3) + NFSX_UNSIGNED +
	    nfsm_rndup(cnp->cn_namelen));
	nfsm_fhtom(&mb, vp, v3);
	nfsm_fhtom(&mb, dvp, v3);
d1712 5
a1716 3
	error = nfs_request(vp, mreq, NFSPROC_LINK, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos);
	if (v3) {
d1720 1
a1720 1
	m_freem(mrep);
d1747 1
d1750 1
a1750 1
	caddr_t dpos, cp2;
a1751 1
	struct mbuf *mreq, *mrep, *md, *mb;
d1753 2
a1754 1
	int v3 = NFS_ISV3(dvp);
d1758 4
a1761 3
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + 2 * NFSX_UNSIGNED +
	    nfsm_rndup(cnp->cn_namelen) + nfsm_rndup(slen) + NFSX_SATTR(v3));
	nfsm_fhtom(&mb, dvp, v3);
d1763 2
a1764 2
	if (v3)
		nfsm_v3attrbuild(&mb, vap, 0);
d1766 2
a1767 2
	if (!v3) {
		sp = nfsm_build(&mb, NFSX_V2SATTR);
d1775 5
a1779 3
	error = nfs_request(dvp, mreq, NFSPROC_SYMLINK, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos);
	if (v3) {
d1781 1
a1781 1
			nfsm_mtofh(dvp, newvp, v3, gotvp);
d1784 2
a1785 1
	m_freem(mrep);
d1810 1
d1816 1
a1816 1
	caddr_t dpos, cp2;
d1819 2
a1820 2
	struct mbuf *mreq, *mrep, *md, *mb;
	int v3 = NFS_ISV3(dvp);
d1824 3
a1826 3
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_UNSIGNED +
	    nfsm_rndup(len) + NFSX_SATTR(v3));
	nfsm_fhtom(&mb, dvp, v3);
d1829 2
a1830 2
	if (v3) {
		nfsm_v3attrbuild(&mb, vap, 0);
d1832 1
a1832 1
		sp = nfsm_build(&mb, NFSX_V2SATTR);
d1841 3
a1843 2
	error = nfs_request(dvp, mreq, NFSPROC_MKDIR, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos);
d1845 2
a1846 2
		nfsm_mtofh(dvp, newvp, v3, gotvp);
	if (v3)
d1848 2
a1849 1
	m_freem(mrep);
d1889 1
d1892 1
a1892 1
	caddr_t dpos, cp2;
d1894 2
a1895 2
	struct mbuf *mreq, *mrep, *md, *mb;
	int v3 = NFS_ISV3(dvp);
d1903 1
d1905 3
a1907 3
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_UNSIGNED +
	    nfsm_rndup(cnp->cn_namelen));
	nfsm_fhtom(&mb, dvp, v3);
d1909 5
a1913 3
	error = nfs_request(dvp, mreq, NFSPROC_RMDIR, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos);
	if (v3)
d1915 2
a1916 1
	m_freem(mrep);
d2118 1
d2122 1
a2122 2
	caddr_t dpos, cp2;
	struct mbuf *mreq, *mrep, *md, *mb;
d2129 2
a2130 1
	int v3 = NFS_ISV3(vp);
d2147 5
a2151 4
		mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_READDIR(v3));
		nfsm_fhtom(&mb, vp, v3);
		if (v3) {
			tl = nfsm_build(&mb, 5 * NFSX_UNSIGNED);
d2163 1
a2163 1
			tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
d2168 4
a2171 3
		error = nfs_request(vp, mreq, NFSPROC_READDIR,
		    uiop->uio_procp, cred, &mrep, &md, &dpos);
		if (v3)
d2175 1
a2175 1
			m_freem(mrep);
d2179 1
a2179 1
		if (v3) {
d2191 1
a2191 1
			if (v3) {
d2204 1
a2204 1
				m_freem(mrep);
d2243 1
a2243 1
			if (v3) {
d2251 1
a2251 1
				if (v3) {
d2258 1
a2258 1
			} else if (v3)
d2271 1
a2271 1
		m_freem(mrep);
d2312 1
d2317 2
a2318 2
	caddr_t dpos, cp2, dpossav1, dpossav2;
	struct mbuf *mreq, *mrep, *md, *mb, *mdsav1, *mdsav2;
d2346 3
a2348 3
		mb = mreq = nfsm_reqhead(NFSX_FH(1) + 6 * NFSX_UNSIGNED);
		nfsm_fhtom(&mb, vp, 1);
 		tl = nfsm_build(&mb, 6 * NFSX_UNSIGNED);
d2362 3
a2364 2
		error = nfs_request(vp, mreq, NFSPROC_READDIRPLUS,
		    uiop->uio_procp, cred, &mrep, &md, &dpos);
d2367 1
a2367 1
			m_freem(mrep);
d2383 1
a2383 1
				m_freem(mrep);
d2439 2
a2440 2
			    dpossav1 = dpos;
			    mdsav1 = md;
d2460 4
a2463 4
				dpossav2 = dpos;
				dpos = dpossav1;
				mdsav2 = md;
				md = mdsav1;
d2465 2
a2466 2
				dpos = dpossav2;
				md = mdsav2;
d2499 1
a2499 1
		m_freem(mrep);
d2610 1
d2615 1
a2615 1
	caddr_t dpos, cp2;
a2616 1
	struct mbuf *mreq, *mrep, *md, *mb;
d2618 2
a2619 1
	int v3 = NFS_ISV3(dvp);
d2622 1
a2622 1
	mb = mreq = nfsm_reqhead(NFSX_FH(v3) + NFSX_UNSIGNED +
d2624 1
a2624 1
	nfsm_fhtom(&mb, dvp, v3);
d2627 5
a2631 4
	error = nfs_request(dvp, mreq, NFSPROC_LOOKUP, procp, cred, &mrep,
	    &md, &dpos);
	if (error && !v3) {
		m_freem(mrep);
d2636 1
a2636 1
		nfsm_getfh(nfhp, fhlen, v3);
d2650 1
a2650 1
			m_freem(mrep);
d2655 1
a2655 1
		if (v3) {
d2658 1
a2658 1
				m_freem(mrep);
d2665 1
a2665 1
	m_freem(mrep);
d2687 1
d2691 1
a2691 1
	caddr_t dpos, cp2;
a2692 1
	struct mbuf *mreq, *mrep, *md, *mb;
d2697 2
a2698 2
	mb = mreq = nfsm_reqhead(NFSX_FH(1));
	nfsm_fhtom(&mb, vp, 1);
d2700 1
a2700 1
	tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED);
d2705 3
a2707 3
	error = nfs_request(vp, mreq, NFSPROC_COMMIT, procp,
	    VTONFS(vp)->n_wcred, &mrep, &md, &dpos);

d2719 2
a2720 1
	m_freem(mrep);
@


1.118
log
@Fixes for the NFSERR_RETERR commit.

- Make sure to set the mbuf pointers and the dpos pointer correctly
in nfs_request() before returning an error.

- Fix potential mbufs leaks in nfs_{read,write}rpc for v2. The reply
mbuf was not being freed before the jump to nfsmout.
- Reorder error handling to prevent an error case being treated as a
non-error case.

Fixes issues noticed by sthen@@ and ajacoutot@@. Tested by both of them.
Reviewd by oga@@
OK blambert@@
@
text
@d818 1
a818 1
			nfsm_loadattr(newvp, (struct vattr *)0);
d842 1
a842 1
			nfsm_loadattr(newvp, (struct vattr *)0);
d860 1
a860 1
			nfsm_loadattr(newvp, (struct vattr *)0);
d882 1
a882 1
			nfsm_loadattr(newvp, (struct vattr *)0);
d1199 1
a1199 1
	struct vnode *newvp = (struct vnode *)0;
d1249 1
a1249 1
				newvp = (struct vnode *)0;
d1309 2
a1310 2
	struct nfsnode *np = (struct nfsnode *)0;
	struct vnode *newvp = (struct vnode *)0;
d1359 1
a1359 1
				newvp = (struct vnode *)0;
d1475 1
a1475 1
		(struct proc *)0));
d1718 1
a1718 1
	struct vnode *newvp = (struct vnode *)0;
d1774 2
a1775 2
	struct nfsnode *np = (struct nfsnode *)0;
	struct vnode *newvp = (struct vnode *)0;
d2412 1
a2412 1
				nfsm_loadattr(newvp, (struct vattr *)0);
d2520 1
a2520 1
		cnp->cn_proc, (struct nfsnode **)0) == 0) {
d2560 1
a2560 1
	struct vnode *newvp = (struct vnode *)0;
d2609 1
a2609 1
			nfsm_loadattr(newvp, (struct vattr *)0);
d2850 1
a2850 1
			    if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
d2885 1
a2885 1
			if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
@


1.117
log
@Make the callers of nfs_request() responsible for freeing the reply mbuf,
if the reply is an error and retire the NFS_RETERR hack. For NFSv3 mounts
the flag was set and reply mbuf not freed to allow the callers to handle
the post-op attributes, or just free the mbuf for NFSv2.

Tested by myself and jasper@@ on various arch's.
OK blambert@@.
@
text
@d1037 6
a1044 5
			nfsm_postop_attr(vp, attrflag);
			if (error) {
				m_freem(mrep);
				goto nfsmout;
			}
d1047 1
a1047 1
		} else if (error == 0)
d1049 1
d1120 4
d1125 2
a1126 1
		if (error && !v3)
d1128 1
d1132 36
a1167 39
			nfsm_wcc_data(vp, wccflag);
			if (!error) {
				nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED
					+ NFSX_V3WRITEVERF);
				rlen = fxdr_unsigned(int, *tl++);
				if (rlen == 0) {
					error = NFSERR_IO;
					break;
				} else if (rlen < len) {
					backup = len - rlen;
					uiop->uio_iov->iov_base =
					    (char *)uiop->uio_iov->iov_base -
					    backup;
					uiop->uio_iov->iov_len += backup;
					uiop->uio_offset -= backup;
					uiop->uio_resid += backup;
					len = rlen;
				}
				commit = fxdr_unsigned(int, *tl++);

				/*
				 * Return the lowest committment level
				 * obtained by any of the RPCs.
				 */
				if (committed == NFSV3WRITE_FILESYNC)
					committed = commit;
				else if (committed == NFSV3WRITE_DATASYNC &&
					commit == NFSV3WRITE_UNSTABLE)
					committed = commit;
				if ((nmp->nm_flag & NFSMNT_HASWRITEVERF) == 0) {
				    bcopy((caddr_t)tl, (caddr_t)nmp->nm_verf,
					NFSX_V3WRITEVERF);
				    nmp->nm_flag |= NFSMNT_HASWRITEVERF;
				} else if (bcmp((caddr_t)tl,
				    (caddr_t)nmp->nm_verf, NFSX_V3WRITEVERF)) {
				    *must_commit = 1;
				    bcopy((caddr_t)tl, (caddr_t)nmp->nm_verf,
					NFSX_V3WRITEVERF);
				}
a1171 1

@


1.116
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d221 2
a222 7
	if ((error = nfs_request(vp, mreq, NFSPROC_NULL, procp, cred, &mrep,
	    &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
a223 1
nfsmout: 
d312 4
a315 7
		if ((error = nfs_request(vp, mreq, NFSPROC_ACCESS, ap->a_p,
		    ap->a_cred, &mrep, &md, &dpos)) != 0) {
			if (error & NFSERR_RETERR)
				error &= ~NFSERR_RETERR;
			else
				goto nfsmout;
		}
d317 3
a319 10
		if (!error) {
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
			rmode = fxdr_unsigned(u_int32_t, *tl);
			/*
			 * The NFS V3 spec does not clarify whether or not
			 * the returned access bits can be a superset of
			 * the ones requested, so...
			 */
			if ((rmode & mode) != mode)
				error = EACCES;
d321 11
d518 2
a519 7
	if ((error = nfs_request(vp, mreq, NFSPROC_GETATTR, ap->a_p,
	    ap->a_cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d632 1
d655 5
a659 8
	if ((error = nfs_request(vp, mreq, NFSPROC_SETATTR, procp, cred, &mrep,
	    &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
	if (v3) {
d661 3
a663 2
	} else
		nfsm_loadattr(vp, (struct vattr *)0);
d787 4
a790 7
	if ((error = nfs_request(dvp, mreq, NFSPROC_LOOKUP, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d792 2
a793 1
		nfsm_postop_attr(dvp, attrflag);
d797 1
d888 1
d895 1
d898 1
d981 4
a984 7
	if ((error = nfs_request(vp, mreq, NFSPROC_READLINK, uiop->uio_procp,
	    cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d991 1
d1034 4
a1037 7
		if ((error = nfs_request(vp, mreq, NFSPROC_READ,
		    uiop->uio_procp, VTONFS(vp)->n_rcred, &mrep, &md, &dpos)) != 0) {
			if (error & NFSERR_RETERR)
				error &= ~NFSERR_RETERR;
			else
				goto nfsmout;
		}
d1046 3
a1048 2
		} else
			nfsm_loadattr(vp, (struct vattr *)0);
d1115 7
a1121 7
		if ((error = nfs_request(vp, mreq, NFSPROC_WRITE,
		    uiop->uio_procp, VTONFS(vp)->n_wcred, &mrep, &md, &dpos)) != 0) {
			if (error & NFSERR_RETERR)
				error &= ~NFSERR_RETERR;
			else
				goto nfsmout;
		}
d1164 4
a1167 2
		} else
		    nfsm_loadattr(vp, (struct vattr *)0);
d1218 1
d1237 3
a1239 7
	if ((error = nfs_request(dvp, mreq, NFSPROC_MKNOD, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d1347 3
a1349 7
	if ((error = nfs_request(dvp, mreq, NFSPROC_CREATE, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d1497 2
a1498 7
	if ((error = nfs_request(dvp, mreq, NFSPROC_REMOVE, proc, cred, &mrep,
	    &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d1618 2
a1619 7
	if ((error = nfs_request(fdvp, mreq, NFSPROC_RENAME, proc, cred, &mrep,
	    &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d1676 2
a1677 7
	if ((error = nfs_request(vp, mreq, NFSPROC_LINK, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d1735 2
a1736 7
	if ((error = nfs_request(dvp, mreq, NFSPROC_SYMLINK, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d1784 1
d1796 3
a1798 7
	if ((error = nfs_request(dvp, mreq, NFSPROC_MKDIR, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d1861 2
a1862 7
	if ((error = nfs_request(dvp, mreq, NFSPROC_RMDIR, cnp->cn_proc,
	    cnp->cn_cred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d2114 9
a2122 6
		if ((error = nfs_request(vp, mreq, NFSPROC_READDIR,
		    uiop->uio_procp, cred, &mrep, &md, &dpos)) != 0) {
			if (error & NFSERR_RETERR)
				error &= ~NFSERR_RETERR;
			else
				goto nfsmout;
d2124 1
d2126 4
a2129 10
			nfsm_postop_attr(vp, attrflag);
			if (!error) {
				nfsm_dissect(tl, u_int32_t *,
				    2 * NFSX_UNSIGNED);
				dnp->n_cookieverf.nfsuquad[0] = *tl++;
				dnp->n_cookieverf.nfsuquad[1] = *tl;
			} else {
				m_freem(mrep);
				goto nfsmout;
			}
d2131 1
d2306 3
a2308 7
		if ((error = nfs_request(vp, mreq, NFSPROC_READDIRPLUS,
		    uiop->uio_procp, cred, &mrep, &md, &dpos)) != 0) {
			if (error & NFSERR_RETERR)
				error &= ~NFSERR_RETERR;
			else
				goto nfsmout;
		}
d2314 1
d2569 6
a2574 6
	if ((error = nfs_request(dvp, mreq, NFSPROC_LOOKUP, procp, cred, &mrep,
	    &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
d2576 1
d2641 1
d2646 4
a2649 7
	if ((error = nfs_request(vp, mreq, NFSPROC_COMMIT, procp,
	    VTONFS(vp)->n_wcred, &mrep, &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d2651 1
@


1.115
log
@backout the buf_acquire() does the bremfree() since all callers
where doing bremfree() befure calling buf_acquire().

This is causing us headache pinning down a bug that showed up
when deraadt@@ too cvs to current, and will have to be done
anyway as a preperation for backouts.

OK deraadt@@
@
text
@d848 1
a848 1
		VREF(dvp);
d2441 1
a2441 1
				    VREF(vp);
d2548 1
a2548 1
	VREF(dvp);
d2635 1
a2635 1
		    VREF(dvp);
@


1.114
log
@All caller of buf_acquire were doing bremfree before the call.
Just put it in the buf_acquire function.
oga@@ ok
@
text
@d2830 1
d2909 1
@


1.113
log
@Demacro nfsm_lookup for great justice.

Thanks to ckuethe for saving much typing with a drive-by perl script.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.112 2009/04/13 17:51:57 blambert Exp $	*/
a2829 1
			bremfree(bp);
a2907 1
		bremfree(bp);
@


1.112
log
@Convert macros to functions to reduce kernel memory usage.

In snaps for a while (way too long, according to deraadt@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.111 2009/01/24 23:37:56 thib Exp $	*/
d221 7
a227 1
	nfsm_request(vp, NFSPROC_NULL, procp, cred);
d318 7
a324 1
		nfsm_request(vp, NFSPROC_ACCESS, ap->a_p, ap->a_cred);
d523 7
a529 1
	nfsm_request(vp, NFSPROC_GETATTR, ap->a_p, ap->a_cred);
d664 7
a670 1
	nfsm_request(vp, NFSPROC_SETATTR, procp, cred);
d798 7
a804 1
	nfsm_request(dvp, NFSPROC_LOOKUP, cnp->cn_proc, cnp->cn_cred);
d990 7
a996 1
	nfsm_request(vp, NFSPROC_READLINK, uiop->uio_procp, cred);
d1045 7
a1051 2
		nfsm_request(vp, NFSPROC_READ, uiop->uio_procp,
		    VTONFS(vp)->n_rcred);
d1128 7
a1134 2
		nfsm_request(vp, NFSPROC_WRITE, uiop->uio_procp,
		    VTONFS(vp)->n_wcred);
d1247 7
a1253 1
	nfsm_request(dvp, NFSPROC_MKNOD, cnp->cn_proc, cnp->cn_cred);
d1361 7
a1367 1
	nfsm_request(dvp, NFSPROC_CREATE, cnp->cn_proc, cnp->cn_cred);
d1515 7
a1521 1
	nfsm_request(dvp, NFSPROC_REMOVE, proc, cred);
d1641 7
a1647 1
	nfsm_request(fdvp, NFSPROC_RENAME, proc, cred);
d1704 7
a1710 1
	nfsm_request(vp, NFSPROC_LINK, cnp->cn_proc, cnp->cn_cred);
d1768 7
a1774 1
	nfsm_request(dvp, NFSPROC_SYMLINK, cnp->cn_proc, cnp->cn_cred);
d1833 7
a1839 1
	nfsm_request(dvp, NFSPROC_MKDIR, cnp->cn_proc, cnp->cn_cred);
d1902 7
a1908 1
	nfsm_request(dvp, NFSPROC_RMDIR, cnp->cn_proc, cnp->cn_cred);
d2160 7
a2166 1
		nfsm_request(vp, NFSPROC_READDIR, uiop->uio_procp, cred);
d2353 7
a2359 1
		nfsm_request(vp, NFSPROC_READDIRPLUS, uiop->uio_procp, cred);
d2619 7
a2625 1
	nfsm_request(dvp, NFSPROC_LOOKUP, procp, cred);
d2694 7
a2700 1
	nfsm_request(vp, NFSPROC_COMMIT, procp, VTONFS(vp)->n_wcred);
@


1.111
log
@oops. forgot to remove a debug printf from the diff.
(that I applied to a clean tree to commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.110 2009/01/24 23:30:42 thib Exp $	*/
d293 1
a293 1
		nfsm_fhtom(vp, v3);
d510 1
a510 1
	nfsm_fhtom(vp, v3);
d623 1
a623 1
	nfsm_fhtom(vp, v3);
d772 1
a772 1
	nfsm_fhtom(dvp, v3);
d959 1
a959 1
	nfsm_fhtom(vp, v3);
d999 1
a999 1
		nfsm_fhtom(vp, v3);
d1065 1
a1065 1
		nfsm_fhtom(vp, v3);
d1181 1
a1181 1
	nfsm_fhtom(dvp, v3);
d1287 1
a1287 1
	nfsm_fhtom(dvp, v3);
d1455 1
a1455 1
	nfsm_fhtom(dvp, v3);
d1573 1
a1573 1
	nfsm_fhtom(fdvp, v3);
d1575 1
a1575 1
	nfsm_fhtom(tdvp, v3);
d1631 2
a1632 2
	nfsm_fhtom(vp, v3);
	nfsm_fhtom(dvp, v3);
d1678 1
a1678 1
	nfsm_fhtom(dvp, v3);
d1738 1
a1738 1
	nfsm_fhtom(dvp, v3);
d1812 1
a1812 1
	nfsm_fhtom(dvp, v3);
d2048 1
a2048 1
		nfsm_fhtom(vp, v3);
d2239 1
a2239 1
		nfsm_fhtom(vp, 1);
d2511 1
a2511 1
	nfsm_fhtom(dvp, v3);
d2577 1
a2577 1
	nfsm_fhtom(vp, 1);
@


1.110
log
@Use a timespec instead of a time_t for the clients nfsnode
mtime, gives us better granularity, helps with cache consistency.

Idea lifted from NetBSD.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.109 2009/01/24 23:25:17 thib Exp $	*/
a1291 1
			printf("%s: O_EXCL!\n", __func__);
@


1.109
log
@propagate the O_EXCL flag down to the file systems, by setting
VA_EXCLUSIVE. Handle this in NFS, also in NFS use arc4random()
for the create verifier instead of an uninitialized long and
the address of the first interface (which is likely to be lo0).

Lifted from NetBSD with small tweaks;
"looks good", miod@@
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.108 2009/01/19 23:40:36 thib Exp $	*/
d409 1
a409 1
		np->n_mtime = vattr.va_mtime.tv_sec;
d414 1
a414 1
		if (np->n_mtime != vattr.va_mtime.tv_sec) {
d421 1
a421 1
			np->n_mtime = vattr.va_mtime.tv_sec;
d1134 1
a1134 1
		    VTONFS(vp)->n_mtime = VTONFS(vp)->n_vattr.va_mtime.tv_sec;
d1892 1
a1892 1
		    np->n_mtime == vattr.va_mtime.tv_sec) {
@


1.108
log
@Introduce a macro to invalidate the attribute
cache instead of setting n_attrstamp to 0 directly.

Lift the macro name from NetBSD.
prompted by and OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.107 2009/01/18 15:42:31 bluhm Exp $	*/
d82 2
a1255 4
static u_long create_verf;
/*
 * nfs file create call
 */
a1279 1
#ifdef VA_EXCLUSIVE
d1282 1
a1282 1
#endif
d1292 1
d1295 2
a1296 5
			if (TAILQ_FIRST(&in_ifaddr))
				*tl++ = TAILQ_FIRST(&in_ifaddr)->ia_addr.sin_addr.s_addr;
			else
				*tl++ = create_verf;
			*tl = ++create_verf;
@


1.107
log
@Replace #ifndef DIAGNOSTIC with #ifdef to make the additional checks
in diagnostic kernels.  The typo comes from 4.4BSD-Lite2 via NetBSD.

Found with pedro@@,  ok pedro@@, blambert@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.106 2009/01/13 19:44:20 grange Exp $	*/
d401 1
a401 1
		np->n_attrstamp = 0;
d422 2
a423 1
	np->n_attrstamp = 0; /* For Open/Close consistency */
d470 1
a470 1
		np->n_attrstamp = 0;
d1228 1
a1228 1
		VTONFS(dvp)->n_attrstamp = 0;
d1350 1
a1350 1
		VTONFS(dvp)->n_attrstamp = 0;
d1418 1
a1418 1
	np->n_attrstamp = 0;
d1470 1
a1470 1
		VTONFS(dvp)->n_attrstamp = 0;
d1593 1
a1593 1
		VTONFS(fdvp)->n_attrstamp = 0;
d1595 1
a1595 1
		VTONFS(tdvp)->n_attrstamp = 0;
d1650 1
a1650 1
		VTONFS(vp)->n_attrstamp = 0;
d1652 1
a1652 1
		VTONFS(dvp)->n_attrstamp = 0;
d1711 1
a1711 1
		VTONFS(dvp)->n_attrstamp = 0;
d1766 1
a1766 1
		VTONFS(dvp)->n_attrstamp = 0;
d1828 1
a1828 1
		VTONFS(dvp)->n_attrstamp = 0;
@


1.106
log
@Trivial lvalue abuse fixes, no binary changes.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.105 2008/12/24 02:43:52 thib Exp $	*/
d1049 1
a1049 1
#ifndef DIAGNOSTIC
d1378 1
a1378 1
#ifndef DIAGNOSTIC
d1489 1
a1489 1
#ifndef DIAGNOSTIC
d2037 1
a2037 1
#ifndef DIAGNOSTIC
d2226 1
a2226 1
#ifndef DIAGNOSTIC
@


1.105
log
@Replace the TRUE/FALSE defines with 1/0 respectively. This doesn't
hurt readability and it was just plain annoying seeing them defined
in every other .c file.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.104 2008/10/16 07:57:06 blambert Exp $	*/
d1098 3
a1100 1
					(char *)uiop->uio_iov->iov_base -= backup;
d2128 3
a2130 1
				(char *)uiop->uio_iov->iov_base += NFS_DIRHDSIZ;
d2178 2
a2179 1
		(char *)uiop->uio_iov->iov_base += left;
d2283 2
a2284 1
				(char *)uiop->uio_iov->iov_base += left;
d2303 3
a2305 1
				(char *)uiop->uio_iov->iov_base += NFS_DIRHDSIZ;
d2401 2
a2402 1
		(char *)uiop->uio_iov->iov_base += left;
@


1.104
log
@Don't hide the fact that NFS uses vop_generic_* functions behind
#define's in nfs_var.h

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.103 2008/09/12 16:17:57 thib Exp $	*/
a81 4
/* Defs */
#define	TRUE	1
#define	FALSE	0

d622 1
a622 1
		nfsm_v3attrbuild(&mb, vap, TRUE);
d1181 1
a1181 1
		nfsm_v3attrbuild(&mb, vap, FALSE);
d1301 1
a1301 1
			nfsm_v3attrbuild(&mb, vap, FALSE);
d1684 1
a1684 1
		nfsm_v3attrbuild(&mb, vap, FALSE);
d1744 1
a1744 1
		nfsm_v3attrbuild(&mb, vap, FALSE);
@


1.103
log
@provide a NOTE_TRUNCATED kq hint in nfs_setattr() if the file
shrinks, same thing as UFS does.

ok/pointers pedro@@
ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.102 2008/08/21 01:17:39 pedro Exp $	*/
d107 1
a107 1
	{ &vop_revoke_desc, nfs_revoke },	/* revoke */
d120 2
a121 2
	{ &vop_lock_desc, nfs_lock },		/* lock */
	{ &vop_unlock_desc, nfs_unlock },	/* unlock */
d125 1
a125 1
	{ &vop_islocked_desc, nfs_islocked },	/* islocked */
d149 2
a150 2
	{ &vop_lock_desc, nfs_lock },		/* lock */
	{ &vop_unlock_desc, nfs_unlock },	/* unlock */
d152 1
a152 1
	{ &vop_islocked_desc, nfs_islocked },	/* islocked */
d171 2
a172 2
	{ &vop_lock_desc, nfs_lock },		/* lock */
	{ &vop_unlock_desc, nfs_unlock },	/* unlock */
d174 1
a174 1
	{ &vop_islocked_desc, nfs_islocked },	/* islocked */
@


1.102
log
@Fix 'if ();' construction introduced in last commit, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.101 2008/08/09 10:14:02 thib Exp $	*/
d531 1
d596 4
a599 1
	VN_KNOTE(vp, NOTE_ATTRIB); /* XXX setattrrpc? */
@


1.101
log
@o nfs_vinvalbuf() is always called with the intrflag as 1, and then
  checks if the mount is actually interrutable, and if not sets it 0.
  remove this argument from nfs_vinvalbuf and just do the checking inside
  the function.
o give nfs_vinvalbuf() a makeover so it looks nice. (spacing, casts, &c);
o Actually pass PCATCH too tsleep() if the mount it interrutable.

ok art@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.100 2008/08/08 20:44:38 blambert Exp $	*/
d420 1
a420 1
			if (error == EINTR);
@


1.100
log
@After beck@@ changed the way nfsiod's are notified of work, the
nfs_iodwant array became unused. Garbage collect and free up
a few bytes.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.99 2008/08/08 20:40:24 blambert Exp $	*/
d401 2
a402 2
		if ((error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred,
			 ap->a_p, 1)) == EINTR)
d419 2
a420 2
			if ((error = nfs_vinvalbuf(vp, V_SAVE,
				 ap->a_cred, ap->a_p, 1)) == EINTR)
d472 1
a472 1
		    error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p, 1);
d573 1
a573 1
 				     ap->a_cred, ap->a_p, 1);
d576 1
a576 1
 				     ap->a_cred, ap->a_p, 1);
d587 1
a587 1
		 ap->a_p, 1)) == EINTR)
d1399 1
a1399 1
		error = nfs_vinvalbuf(vp, 0, cnp->cn_cred, cnp->cn_proc, 1);
@


1.99
log
@Remove code for variable-sized allocations of NFS filehandles by malloc(),
as it was never used because there were 64-bit buffers already allocated
for filehandles in nfsnode structs.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.98 2008/07/25 14:56:47 beck Exp $	*/
a188 1
struct proc *nfs_iodwant[NFS_MAXASYNCDAEMON];
@


1.98
log
@much more correct way of dealing with nfs pending reads/writes
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.97 2008/07/23 17:40:29 deraadt Exp $	*/
d2515 1
a2515 5
		    if (np->n_fhsize > NFS_SMALLFH && fhlen <= NFS_SMALLFH) {
			free((caddr_t)np->n_fhp, M_NFSBIGFH);
			np->n_fhp = &np->n_fh;
		    } else if (np->n_fhsize <= NFS_SMALLFH && fhlen>NFS_SMALLFH)
			np->n_fhp =(nfsfh_t *)malloc(fhlen,M_NFSBIGFH,M_WAITOK);
@


1.97
log
@make this real C
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.96 2008/07/23 16:24:43 beck Exp $	*/
a2993 2
		bcstats.pendingwrites++;
		bcstats.numwrites++;
@


1.96
log
@
Correct cases of mishandling of pending reads and writes to prevent
them going negative - this consists of identifying a number of cases of
IO not going through the buffer cache and marking those buffers with
B_RAW - as well as fixing nfs_bio to show pending writes and reads through
the buffer cache via NFS

still has a problem with mishandling the counters I believe in the
async/sync fallback case where counters stay positive which will be
addressed seperately.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.95 2008/07/23 11:53:07 art Exp $	*/
d3000 2
d3003 1
a3003 1
		int rtval = biowait(bp);
@


1.95
log
@ - in nfs_mknodrpc - initialize the node we pass to nfs_lookitup. It's
   not just a return value, nfs_lookitup treats it specially when *npp
   is not NULL.
 - nfs_lookitup - When we match the file handle to the directory
   filehandle (lookup on '.'), initialize np so that we don't return
   stack garbage to the caller. The function shouldn't ever be
   called with '.' at this moment, but that's no reason to not do the
   right thing in case future callers use it that way.

blambert@@ thib@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.94 2008/07/06 16:54:48 thib Exp $	*/
d3000 1
@


1.94
log
@
remove #ifndef nolint goo

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.93 2008/06/14 22:44:07 blambert Exp $	*/
d1157 1
a1157 1
	struct nfsnode *np;
d2526 1
@


1.93
log
@Replace nfsm_build/bcopy with nfsm_{buf,str}tombuf functions in
filehandle -> mbuf write macros.

Removes `magic' variable cp which was used only in these macros,
and should lead to marginally better mbuf packing as well.

`slap it in' thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.92 2008/06/13 22:11:32 blambert Exp $	*/
a986 1
#ifndef nolint
d988 1
a988 1
#endif
@


1.92
log
@Kill one-liner macro which obfuscated mbuf pointer assignment.

Rescue nfsm_reqhead macro name and rename nfsm_reqh.

End of one-liners from nfsm_subs.h.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.91 2008/06/13 17:21:13 thib Exp $	*/
a242 1
	caddr_t cp;
a493 1
	caddr_t cp;
a611 1
	caddr_t cp;
a670 1
	caddr_t cp;
a948 1
	caddr_t cp;
a979 1
	caddr_t cp;
a1043 1
	caddr_t cp;
a1155 1
	caddr_t cp;
a1266 1
	caddr_t cp;
a1450 1
	caddr_t cp;
a1568 1
	caddr_t cp;
a1609 1
	caddr_t cp;
a1671 1
	caddr_t cp;
a1728 1
	caddr_t cp;
a1801 1
	caddr_t cp;
a2496 1
	caddr_t cp;
a2566 1
	caddr_t cp;
@


1.91
log
@nuke a bunch of bogus ARGSUSED;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.90 2008/06/12 20:24:06 blambert Exp $	*/
d223 1
a223 1
	nfsm_reqhead(vp, NFSPROC_NULL, 0);
d296 1
a296 1
		nfsm_reqhead(vp, NFSPROC_ACCESS, NFSX_FH(v3) + NFSX_UNSIGNED);
d513 1
a513 1
	nfsm_reqhead(vp, NFSPROC_GETATTR, NFSX_FH(v3));
d623 1
a623 1
	nfsm_reqhead(vp, NFSPROC_SETATTR, NFSX_FH(v3) + NFSX_SATTR(v3));
d773 1
a773 2
	nfsm_reqhead(dvp, NFSPROC_LOOKUP,
		NFSX_FH(v3) + NFSX_UNSIGNED + nfsm_rndup(len));
d961 1
a961 1
	nfsm_reqhead(vp, NFSPROC_READLINK, NFSX_FH(v3));
d1003 1
a1003 1
		nfsm_reqhead(vp, NFSPROC_READ, NFSX_FH(v3) + NFSX_UNSIGNED * 3);
d1069 2
a1070 2
		nfsm_reqhead(vp, NFSPROC_WRITE,
			NFSX_FH(v3) + 5 * NFSX_UNSIGNED + nfsm_rndup(len));
d1184 2
a1185 2
	nfsm_reqhead(dvp, NFSPROC_MKNOD, NFSX_FH(v3) + 4 * NFSX_UNSIGNED +
		+ nfsm_rndup(cnp->cn_namelen) + NFSX_SATTR(v3));
d1296 2
a1297 2
	nfsm_reqhead(dvp, NFSPROC_CREATE, NFSX_FH(v3) + 2 * NFSX_UNSIGNED +
		nfsm_rndup(cnp->cn_namelen) + NFSX_SATTR(v3));
d1468 2
a1469 2
	nfsm_reqhead(dvp, NFSPROC_REMOVE,
		NFSX_FH(v3) + NFSX_UNSIGNED + nfsm_rndup(namelen));
d1587 2
a1588 3
	nfsm_reqhead(fdvp, NFSPROC_RENAME,
		(NFSX_FH(v3) + NFSX_UNSIGNED)*2 + nfsm_rndup(fnamelen) +
		nfsm_rndup(tnamelen));
d1646 2
a1647 2
	nfsm_reqhead(vp, NFSPROC_LINK,
		NFSX_FH(v3)*2 + NFSX_UNSIGNED + nfsm_rndup(cnp->cn_namelen));
d1694 1
a1694 1
	nfsm_reqhead(dvp, NFSPROC_SYMLINK, NFSX_FH(v3) + 2*NFSX_UNSIGNED +
d1755 2
a1756 2
	nfsm_reqhead(dvp, NFSPROC_MKDIR,
	  NFSX_FH(v3) + NFSX_UNSIGNED + nfsm_rndup(len) + NFSX_SATTR(v3));
d1830 2
a1831 2
	nfsm_reqhead(dvp, NFSPROC_RMDIR,
		NFSX_FH(v3) + NFSX_UNSIGNED + nfsm_rndup(cnp->cn_namelen));
d2067 1
a2067 2
		nfsm_reqhead(vp, NFSPROC_READDIR, NFSX_FH(v3) +
			NFSX_READDIR(v3));
d2255 1
a2255 2
		nfsm_reqhead(vp, NFSPROC_READDIRPLUS,
			NFSX_FH(1) + 6 * NFSX_UNSIGNED);
d2523 2
a2524 2
	nfsm_reqhead(dvp, NFSPROC_LOOKUP,
		NFSX_FH(v3) + NFSX_UNSIGNED + nfsm_rndup(len));
d2594 1
a2594 1
	nfsm_reqhead(vp, NFSPROC_COMMIT, NFSX_FH(1));
@


1.90
log
@Remove now-vestigial bpos pointer from NFS. For building outgoing
NFS mbufs, mbufs now contain all their internal buffer state internally,
the way god intended.

ok thib@@

testing johan@@ (and possibly merdely@@; this diff's been around for a bit...)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.89 2008/06/12 06:58:40 deraadt Exp $	*/
a364 1
/* ARGSUSED */
a458 1
/* ARGSUSED */
a1244 1
/* ARGSUSED */
a2676 1
/* ARGSUSED */
a3069 1
/* ARGSUSED */
@


1.89
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.85 2008/06/10 20:14:37 beck Exp $	*/
d219 1
a219 1
	caddr_t bpos, dpos;
d245 1
a245 1
	caddr_t bpos, dpos, cp2;
d298 1
a298 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d499 1
a499 1
	caddr_t bpos, dpos;
d618 1
a618 1
	caddr_t bpos, dpos, cp2;
d628 2
a629 2
		nfsm_v3attrbuild(&mb, vap, TRUE, &bpos);
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d632 1
a632 1
		sp = nfsm_build(&mb, NFSX_V2SATTR, &bpos);
d679 1
a679 1
	caddr_t bpos, dpos, cp2;
d958 1
a958 1
	caddr_t bpos, dpos, cp2;
d990 1
a990 1
	caddr_t bpos, dpos, cp2;
d1008 1
a1008 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED * 3, &bpos);
d1055 1
a1055 1
	caddr_t bpos, dpos, cp2;
d1076 1
a1076 1
			tl = nfsm_build(&mb, 5 * NFSX_UNSIGNED, &bpos);
d1085 1
a1085 1
			tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED, &bpos);
d1095 1
a1095 1
		nfsm_uiotombuf(&mb, uiop, len, &bpos);
d1171 1
a1171 1
	caddr_t bpos, dpos;
d1192 1
a1192 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1194 1
a1194 1
		nfsm_v3attrbuild(&mb, vap, FALSE, &bpos);
d1196 1
a1196 1
			tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d1201 1
a1201 1
		sp = nfsm_build(&mb, NFSX_V2SATTR, &bpos);
d1283 1
a1283 1
	caddr_t bpos, dpos, cp2;
d1305 1
a1305 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1308 1
a1308 1
			tl = nfsm_build(&mb, NFSX_V3CREATEVERF, &bpos);
d1316 1
a1316 1
			nfsm_v3attrbuild(&mb, vap, FALSE, &bpos);
d1319 1
a1319 1
		sp = nfsm_build(&mb, NFSX_V2SATTR, &bpos);
d1466 1
a1466 1
	caddr_t bpos, dpos, cp2;
d1585 1
a1585 1
	caddr_t bpos, dpos, cp2;
d1628 1
a1628 1
	caddr_t bpos, dpos, cp2;
d1691 1
a1691 1
	caddr_t bpos, dpos, cp2;
d1704 1
a1704 1
		nfsm_v3attrbuild(&mb, vap, FALSE, &bpos);
d1707 1
a1707 1
		sp = nfsm_build(&mb, NFSX_V2SATTR, &bpos);
d1752 1
a1752 1
	caddr_t bpos, dpos, cp2;
d1765 1
a1765 1
		nfsm_v3attrbuild(&mb, vap, FALSE, &bpos);
d1767 1
a1767 1
		sp = nfsm_build(&mb, NFSX_V2SATTR, &bpos);
d1823 1
a1823 1
	caddr_t bpos, dpos, cp2;
d2047 1
a2047 1
	caddr_t bpos, dpos, cp2;
d2076 1
a2076 1
			tl = nfsm_build(&mb, 5 * NFSX_UNSIGNED, &bpos);
d2088 1
a2088 1
			tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d2232 1
a2232 1
	caddr_t bpos, dpos, cp2, dpossav1, dpossav2;
d2264 1
a2264 1
 		tl = nfsm_build(&mb, 6 * NFSX_UNSIGNED, &bpos);
d2523 1
a2523 1
	caddr_t bpos, dpos, cp2;
d2594 1
a2594 1
	caddr_t bpos, dpos, cp2;
d2603 1
a2603 1
	tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED, &bpos);
@


1.88
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.84 2008/06/09 23:38:37 millert Exp $	*/
d2739 2
a2740 1
			bp->b_flags |= (B_BUSY | B_WRITEINPROG);
d2818 6
a2823 4
		if (passone || !commit)
		    bp->b_flags |= (B_BUSY|B_ASYNC);
		else
		    bp->b_flags |= (B_BUSY|B_ASYNC|B_WRITEINPROG|B_NEEDCOMMIT);
d3019 2
@


1.87
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.86 2008/06/10 22:59:09 thib Exp $	*/
d2739 1
a2739 2
			bp->b_flags |= B_WRITEINPROG;
			buf_acquire(bp);
d2817 4
a2820 6
		if (passone || !commit) {
			bp->b_flags |= B_ASYNC;
		} else {
			bp->b_flags |= (B_ASYNC|B_WRITEINPROG|B_NEEDCOMMIT);
		}
		buf_acquire(bp);
a3015 2
		bcstats.pendingwrites++;
		bcstats.numwrites++;
@


1.86
log
@
o Avoid putting duplicate entries into the name cache,
  add a function to handle cache_enter()'s for us since
  we need to update the appropriate timestamps so we don't
  miss on lookup;
o Do not purge the dvp in nfs_rmdir(), since there's no need;
o cache the new entry created in nfs_mkdir();
o Do caching of the access modes, this drastically reduces the
  amount of over the wire access RPCs we do in the NFSv3 case.

This diff was written by Pedro Martelletto, sometime in 2004.
A lot of people have been running with it at one time or another,
this includes at least markus and matthieu.

OK deraadt@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.85 2008/06/10 20:14:37 beck Exp $	*/
d62 1
@


1.85
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.84 2008/06/09 23:38:37 millert Exp $	*/
d85 2
d191 18
d249 3
d268 17
d328 1
a328 3
	m_freem(mrep);
nfsmout: 
		return (error);
d331 24
d878 1
a878 2
		np->n_ctime = np->n_vattr.va_ctime.tv_sec;
		cache_enter(dvp, newvp, cnp);
d892 1
a892 4
			if (VTONFS(dvp)->n_ctime == 0)
				VTONFS(dvp)->n_ctime =
				    VTONFS(dvp)->n_vattr.va_mtime.tv_sec;
			cache_enter(dvp, NULL, cnp);
d1231 1
a1231 1
			cache_enter(dvp, newvp, cnp);
d1355 1
a1355 1
			cache_enter(dvp, newvp, cnp);
d1799 2
a1850 1
	cache_purge(dvp);
d2382 2
a2383 1
					cache_enter(ndp->ni_dvp, ndp->ni_vp,
@


1.84
log
@Update access(2) to have modern semantics with respect to X_OK and
the superuser.  access(2) will now only indicate success for X_OK on
non-directories if there is at least one execute bit set on the file.
OK deraadt@@ thib@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.83 2008/05/08 17:45:45 thib Exp $	*/
d2678 2
a2679 1
			bp->b_flags |= (B_BUSY | B_WRITEINPROG);
d2757 6
a2762 4
		if (passone || !commit)
		    bp->b_flags |= (B_BUSY|B_ASYNC);
		else
		    bp->b_flags |= (B_BUSY|B_ASYNC|B_WRITEINPROG|B_NEEDCOMMIT);
d2958 2
@


1.83
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.82 2008/04/22 20:59:37 thib Exp $	*/
d3004 2
a3005 2
	return (vaccess(va.va_mode, va.va_uid, va.va_gid, ap->a_mode,
	    ap->a_cred));
@


1.82
log
@Remove kludges that map EEXIST errors too a 0 return (success) for certain
operations (non-idempotent ones) under the assumption that the reply from
the server is for a duplicate of the original request.

However, most (all) NFS server today have a duplicate reply cache that
address this problem and these kludges have been shown to cause problems
with some applications (most notably dovecot as pointed out by brad@@).

For more information:
http://lists.freebsd.org/pipermail/freebsd-current/2007-November/079961.html
And revision 1.277 of sys/nfsclient/nfs_vnops.c in FreeBSD.

Diff from rwatson@@freebsd.org

OK blambert@@, "no objections" krw@@
tested by many;
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.81 2008/04/14 13:46:13 blambert Exp $	*/
d90 1
a90 1
	{ &vop_default_desc, vn_default_error },
@


1.81
log
@Rework NFS mbuf write routines:

nfsm_uiotombuf():
- no meaningful return, function becomes void
- replace frankensteined uiomove/MGET with actual call to uiomove

nfsm_strtmbuf():
- no meaningful return, becomes void
- rename and reorder parameters to be consistent with other functions
- becomes wrapper to nfsm_uiotombuf

nfsm_buftombuf():
- new function; unused but slated for future use
- wrapper to nfsm_uiotombuf

As a bonus, making these functions void removes much unneeded code and
garbage collects `magic' variable t2 which was only used (invisibly)
by the macros from nfsm_subs.h

Preps the way for removing much more NFS goo...

testing by myself, thib@@ and merdely@@
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.80 2008/01/06 17:38:23 blambert Exp $	*/
a1613 5
	/*
	 * Kludge: Map EEXIST => 0 assuming that it is a reply to a retry.
	 */
	if (error == EEXIST)
		error = 0;
a1671 5
	/*
	 * Kludge: Map EEXIST => 0 assuming that it is a reply to a retry.
	 */
	if (error == EEXIST)
		error = 0;
d1726 2
a1727 9
	/*
	 * Kludge: Map EEXIST => 0 assuming that you have a reply to a retry
	 * if we can succeed in looking up the directory.
	 */
	if (error == EEXIST || (!error && !gotvp)) {
		if (newvp) {
			vrele(newvp);
			newvp = (struct vnode *)0;
		}
@


1.80
log
@More NFS-related kernel shrinkage...

When you use a macro ~200 times, it tends to bloat your code, so make a
function out of it.

Shaves ~8.5 kB from my kernel.

ok thib@@, "looks good" krw@@

In snaps for 1+ week with no negative reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.79 2007/12/13 18:32:55 blambert Exp $	*/
d223 1
a223 1
	int32_t t1, t2;
d435 1
a435 2
	u_int32_t *tl;
	int32_t t1, t2;
d554 1
a554 1
	int32_t t1, t2;
d614 1
a614 1
	int32_t t1, t2;
d898 1
a898 1
	int32_t t1, t2;
d930 1
a930 1
	int32_t t1, t2;
d995 1
a995 1
	int32_t t1, t2, backup;
d1036 1
a1036 5
		if ((t1 = nfsm_uiotombuf(uiop, &mb, len, &bpos)) != 0) {
			error = t1;
			m_freem(mreq);
			goto nfsmout;
		}
d1108 1
a1108 1
	int32_t t1, t2;
d1221 1
a1221 1
	int32_t t1, t2;
d1406 1
a1406 1
	int32_t t1, t2;
d1525 1
a1525 1
	int32_t t1, t2;
d1568 1
a1568 1
	int32_t t1, t2;
d1636 1
a1636 1
	int32_t t1, t2;
d1699 1
a1699 1
	int32_t t1, t2;
d1778 1
a1778 1
	int32_t t1, t2;
d2003 1
a2003 1
	int32_t t1, t2;
d2187 1
a2187 1
	int32_t t1, t2;
d2476 1
a2476 1
	int32_t t1, t2;
d2548 1
a2548 1
	int32_t t1, t2;
@


1.79
log
@convert massive (expanded to 150+ lines) nfsm_v3attr macro to a function

shaves an insane (~8K) amount from an i386 kernel

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.78 2007/09/26 16:00:55 blambert Exp $	*/
d226 1
a226 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d257 1
a257 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d439 1
a439 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d559 1
a559 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d567 1
a567 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d570 1
a570 1
		nfsm_build(sp, struct nfsv2_sattr *, NFSX_V2SATTR);
d618 1
a618 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d902 1
a902 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d933 1
a933 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d950 1
a950 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED * 3);
d998 1
a998 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1018 1
a1018 1
			nfsm_build(tl, u_int32_t *, 5 * NFSX_UNSIGNED);
d1027 1
a1027 1
			nfsm_build(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
d1119 1
a1119 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1138 1
a1138 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1142 1
a1142 1
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d1147 1
a1147 1
		nfsm_build(sp, struct nfsv2_sattr *, NFSX_V2SATTR);
d1231 1
a1231 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1251 1
a1251 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1254 1
a1254 1
			nfsm_build(tl, u_int32_t *, NFSX_V3CREATEVERF);
d1265 1
a1265 1
		nfsm_build(sp, struct nfsv2_sattr *, NFSX_V2SATTR);
d1414 1
a1414 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1533 1
a1533 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1576 1
a1576 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1644 1
a1644 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1658 1
a1658 1
		nfsm_build(sp, struct nfsv2_sattr *, NFSX_V2SATTR);
d1711 1
a1711 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1723 1
a1723 1
		nfsm_build(sp, struct nfsv2_sattr *, NFSX_V2SATTR);
d1786 1
a1786 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d2010 1
a2010 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d2038 1
a2038 1
			nfsm_build(tl, u_int32_t *, 5 * NFSX_UNSIGNED);
d2050 1
a2050 1
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d2195 1
a2195 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2, *mdsav1, *mdsav2;
d2226 1
a2226 1
 		nfsm_build(tl, u_int32_t *, 6 * NFSX_UNSIGNED);
d2486 1
a2486 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d2557 1
a2557 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d2564 1
a2564 1
	nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
@


1.78
log
@nfsm_uiotom macro does nothing but hide error-handling code; replace
inline in the one place that it's called

ok thib@@, weingart@@
"I don't see why not" fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.77 2007/09/20 12:54:31 thib Exp $	*/
d566 1
a566 1
		nfsm_v3attrbuild(vap, TRUE);
d1140 1
a1140 1
		nfsm_v3attrbuild(vap, FALSE);
d1262 1
a1262 1
			nfsm_v3attrbuild(vap, FALSE);
d1655 1
a1655 1
		nfsm_v3attrbuild(vap, FALSE);
d1721 1
a1721 1
		nfsm_v3attrbuild(vap, FALSE);
@


1.77
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.76 2007/09/11 13:41:52 blambert Exp $	*/
d1037 5
a1041 1
		nfsm_uiotom(uiop, len);
@


1.76
log
@Replace nfsm_reqdone and nfsm_srvdone macros inline. No binary change.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.75 2007/06/01 23:47:57 deraadt Exp $	*/
d1892 2
a1893 2
		MALLOC(cookies, u_long *, sizeof(*cookies) * ncookies,
		       M_TEMP, M_WAITOK);
d1903 1
a1903 3
	MALLOC(data, void *, NFS_DIRBLKSIZ, M_TEMP, 
	    M_WAITOK);

d1958 2
a1959 2
	
	FREE(data, M_TEMP);
d1964 1
a1964 1
			FREE(*ap->a_cookies, M_TEMP); 
d2416 1
a2416 2
	MALLOC(sp, struct sillyrename *, sizeof (struct sillyrename),
		M_NFSREQ, M_WAITOK);
d2454 1
a2454 1
	FREE((caddr_t)sp, M_NFSREQ);
@


1.75
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.74 2007/06/01 07:13:47 thib Exp $	*/
d204 2
a205 1
	nfsm_reqdone;
d288 2
a289 1
		nfsm_reqdone;
d458 2
a459 1
	nfsm_reqdone;
d592 2
a593 1
	nfsm_reqdone;
d821 2
a822 1
	nfsm_reqdone;
d827 1
a827 1
		 * (the nfsm_* macros will jump to nfsm_reqdone
d915 2
a916 1
	nfsm_reqdone;
d1167 2
a1168 1
	nfsm_reqdone;
d1285 2
a1286 1
	nfsm_reqdone;
d1421 2
a1422 1
	nfsm_reqdone;
d1545 2
a1546 1
	nfsm_reqdone;
d1603 2
a1604 1
	nfsm_reqdone;
d1668 2
a1669 1
	nfsm_reqdone;
d1732 2
a1733 1
	nfsm_reqdone;
d1799 2
a1800 1
	nfsm_reqdone;
d2528 2
a2529 1
	nfsm_reqdone;
d2578 2
a2579 1
	nfsm_reqdone;
@


1.74
log
@daddr_t -> daddr64_t;
Basically the usage of daddr_t was to math out arguments to
nfs_getcacheblk, wich calls getblk();

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.73 2007/03/18 15:05:33 mickey Exp $	*/
d218 1
a218 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d305 1
a305 6
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d400 1
a400 7
	struct vop_close_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d429 1
a429 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d467 1
a467 7
	struct vop_setattr_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d602 1
a602 6
	struct vop_lookup_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap = v;
d859 1
a859 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d874 1
a874 5
	struct vop_readlink_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *ap = v;
d1187 1
a1187 6
	struct vop_mknod_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d1208 1
a1208 6
	struct vop_create_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d1317 1
a1317 6
	struct vop_remove_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode * a_dvp;
		struct vnode * a_vp;
		struct componentname * a_cnp;
	} */ *ap = v;
d1427 1
a1427 8
	struct vop_rename_args  /* {
		struct vnode *a_fdvp;
		struct vnode *a_fvp;
		struct componentname *a_fcnp;
		struct vnode *a_tdvp;
		struct vnode *a_tvp;
		struct componentname *a_tcnp;
	} */ *ap = v;
d1553 1
a1553 5
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d1619 1
a1619 7
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
d1681 1
a1681 6
	struct vop_mkdir_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d1760 1
a1760 5
	struct vop_rmdir_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d1835 1
a1835 8
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long **a_cookies;
		int *a_ncookies;
	} */ *ap = v;
d2580 1
a2580 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr64_t  a_bn;
		struct vnode **a_vpp;
		daddr64_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
d2629 1
a2629 7
	struct vop_fsync_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode * a_vp;
		struct ucred * a_cred;
		int  a_waitfor;
		struct proc * a_p;
	} */ *ap = v;
d2815 1
a2815 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
d2828 1
a2828 7
	struct vop_advlock_args /* {
		struct vnode *a_vp;
		caddr_t  a_id;
		int  a_op;
		struct flock *a_fl;
		int  a_flags;
	} */ *ap = v;
d2842 1
a2842 3
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d2863 1
a2863 3
	struct vop_bwrite_args /* {
		struct buf *a_bp;
	} */ *ap = v;
d2984 1
a2984 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d3018 1
a3018 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int  a_events;
		struct proc *a_p;
	} */ *ap = v;
d3033 1
a3033 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d3051 1
a3051 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d3071 1
a3071 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d3099 1
a3099 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d3118 1
a3118 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d3139 1
a3139 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
@


1.73
log
@get rid of noop vop_reallocblks; pedro@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.72 2007/02/23 14:27:06 deraadt Exp $	*/
d2671 1
a2671 1
		daddr_t  a_bn;
d2673 1
a2673 1
		daddr_t *a_bnp;
@


1.72
log
@backout previous revision -- on nfs2 mounts (perhaps only automounted?) it
tends to .nfs silly files lying around during high filesystem activity.
whatever bug it was trying to fix, it made things worse.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.70 2007/01/16 17:52:18 thib Exp $	*/
a124 1
	{ &vop_reallocblks_desc, nfs_reallocblks },	/* reallocblks */
@


1.71
log
@don't assume our directory vnode will be flushed out after us, fixes
crash when unmounting nfs volumes, okay thib@@, krw@@ and mickey@@
@
text
@d1460 1
a1460 10
	int v3;

	/*
	 * It is possible for our directory vnode to have been flushed out
	 * before us. If that's the case, we can't remove the file.
	 */
	if (dvp->v_type == VBAD)
		return (EIO);

	v3 = NFS_ISV3(dvp);
@


1.70
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.69 2006/12/29 13:04:37 pedro Exp $	*/
d1460 10
a1469 1
	int v3 = NFS_ISV3(dvp);
@


1.69
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.68 2006/12/06 17:49:58 thib Exp $	*/
a100 1
	{ &vop_lease_desc, nfs_lease_check },	/* lease */
@


1.68
log
@nfs_readdirplusrpc():
Replace the pointer aerobics used to construct the
namecache hash with a more saner approach since the
former could lead to a null deref (PR5305).

Also make sure that the current buf is bigenough
before caching the current entry.

comments&ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.67 2006/04/26 21:37:37 pedro Exp $	*/
d1089 1
a1089 1
					uiop->uio_iov->iov_base -= backup;
d2186 1
a2186 1
				uiop->uio_iov->iov_base += NFS_DIRHDSIZ;
d2234 1
a2234 1
		uiop->uio_iov->iov_base += left;
d2339 1
a2339 1
				uiop->uio_iov->iov_base += left;
d2358 1
a2358 1
				uiop->uio_iov->iov_base += NFS_DIRHDSIZ;
d2453 1
a2453 1
		uiop->uio_iov->iov_base += left;
@


1.67
log
@In nfs_readdir(), if the buffer provided by the user is not big enough
to hold all the entries a directory has, we can't signal EOF.
Okay deraadt@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.66 2006/04/20 14:43:32 pedro Exp $	*/
d61 1
d2405 1
a2405 1
			    if (doit) {
d2415 8
a2422 7
				ndp->ni_vp = newvp;
				cnp->cn_hash = 0;
				for (cp = cnp->cn_nameptr, i = 1; i <= len;
				    i++, cp++)
				    cnp->cn_hash += (unsigned char)*cp * i;
				if (cnp->cn_namelen <= NCHNAMLEN)
				    cache_enter(ndp->ni_dvp, ndp->ni_vp, cnp);
@


1.66
log
@Remove unused debug code that sneaked in by accident long ago
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.65 2005/09/29 00:45:51 deraadt Exp $	*/
d2016 1
@


1.65
log
@toast cast of lvalue; pr 4289
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.64 2005/04/21 23:29:04 deraadt Exp $	*/
a3004 5
#ifdef fvdl_debug
	printf("nfs_writebp(%x): vp %x voff %d vend %d doff %d dend %d\n",
	    bp, bp->b_vp, bp->b_validoff, bp->b_validend, bp->b_dirtyoff,
	    bp->b_dirtyend);
#endif
@


1.64
log
@careful strlcpy and snprintf return handling; ok pedro beck
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.63 2004/08/03 17:11:48 marius Exp $	*/
d2165 1
a2165 1
				(caddr_t)uiop->uio_iov->iov_base += left;
d2190 1
a2190 1
				(caddr_t)uiop->uio_iov->iov_base += tlen;
@


1.63
log
@NFS commit coalescion: instead of sending a commit for each block, coalesce
these into larger ranges wherever possible.

this should speed up NFS writes quite a bit.

ok art@@ millert@@ pedro@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.62 2004/07/21 17:30:56 marius Exp $	*/
d2509 2
@


1.62
log
@kqueue support for NFS, adapted from netbsd.

ok art@@ pedro@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.61 2004/06/24 19:35:26 tholo Exp $	*/
d2992 1
d2994 2
d3000 3
d3026 39
a3064 4
		bp->b_flags |= B_WRITEINPROG;
		retv = nfs_commit(bp->b_vp, off, bp->b_dirtyend-bp->b_dirtyoff,
			bp->b_proc);
		bp->b_flags &= ~B_WRITEINPROG;
@


1.61
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.60 2004/05/14 04:00:34 tedu Exp $	*/
d103 1
a103 1
	{ &vop_kqfilter_desc, vop_generic_kqfilter },	/* kqfilter */
d562 3
d1241 3
d1349 1
d1424 4
d1518 1
d1527 3
d1668 3
d1738 1
d1823 2
a1824 1
	} else
d1826 1
d1874 4
@


1.60
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.59 2004/04/26 18:57:36 millert Exp $	*/
d3105 1
a3105 2
	np->n_atim.tv_sec = time.tv_sec;
	np->n_atim.tv_nsec = time.tv_usec * 1000;
d3128 1
a3128 2
	np->n_mtim.tv_sec = time.tv_sec;
	np->n_mtim.tv_nsec = time.tv_usec * 1000;
d3187 1
a3187 2
	np->n_atim.tv_sec = time.tv_sec;
	np->n_atim.tv_nsec = time.tv_usec * 1000;
d3211 1
a3211 2
	np->n_mtim.tv_sec = time.tv_sec;
	np->n_mtim.tv_nsec = time.tv_usec * 1000;
d3237 1
a3237 2
			np->n_atim.tv_sec = time.tv_sec;
			np->n_atim.tv_nsec = time.tv_usec * 1000;
d3240 1
a3240 2
			np->n_mtim.tv_sec = time.tv_sec;
			np->n_mtim.tv_nsec = time.tv_usec * 1000;
@


1.59
log
@nfs_poll cannot simply be defined to seltrue so use a stub nfs_poll
duplicated from UFS.  Closes PR 3757; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.58 2004/03/02 05:46:00 tedu Exp $	*/
d53 1
d1209 1
a1209 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d1339 1
a1339 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d1413 1
a1413 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d1619 1
a1619 1
		FREE(cnp->cn_pnbuf, M_NAMEI);
d1647 1
a1647 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d1716 1
a1716 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d1806 1
a1806 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d1837 1
a1837 1
		FREE(cnp->cn_pnbuf, M_NAMEI);
d1849 1
a1849 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
@


1.58
log
@silly fifos aren't a real fs, so we have to be sure to call reclaim
in the host fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.57 2004/02/27 17:40:17 millert Exp $	*/
d48 1
d3066 17
@


1.57
log
@Defer use of NFS_ISV3 macro in nfs_link until sanity checks have been done.
Fixes a panic that can occur when trying to link from a local filesystem
to an nfs-mounted one.  Problem pointed out by Jim Rees, fix exists
in Net and Free.  OK tedu@@ csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.56 2003/09/23 16:51:13 millert Exp $	*/
d166 1
a166 1
	{ &vop_reclaim_desc, nfs_reclaim },	/* reclaim */
d3241 7
@


1.56
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.55 2003/06/02 23:28:20 millert Exp $	*/
d1614 1
a1614 2
	int v3 = NFS_ISV3(vp);

d1632 1
@


1.55
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.54 2003/05/06 21:43:26 deraadt Exp $	*/
d100 1
a100 1
	{ &vop_select_desc, nfs_select },	/* select */
@


1.55.2.1
log
@MFC:
Fix by millert@@

Defer use of NFS_ISV3 macro in nfs_link until sanity checks have been done.
Fixes a panic that can occur when trying to link from a local filesystem
to an nfs-mounted one.  Problem pointed out by Jim Rees, fix exists
in Net and Free.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.55 2003/06/02 23:28:20 millert Exp $	*/
d1614 2
a1615 1
	int v3;
a1632 1
	v3 = NFS_ISV3(vp);
@


1.55.2.2
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.55.2.1 2004/03/01 03:12:56 brad Exp $	*/
d166 1
a166 1
	{ &vop_reclaim_desc, nfsfifo_reclaim },	/* reclaim */
a3240 7
}

int
nfsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (nfs_reclaim(v));
@


1.54
log
@string cleaning; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.53 2003/01/31 17:37:50 art Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.53
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.52 2002/11/08 04:34:17 art Exp $	*/
d2484 2
a2485 1
	sp->s_namlen = sprintf(sp->s_name, ".nfsA%05x4.4", cnp->cn_proc->p_pid);
@


1.53.2.1
log
@MFC:
Fix by millert@@

Defer use of NFS_ISV3 macro in nfs_link until sanity checks have been done.
Fixes a panic that can occur when trying to link from a local filesystem
to an nfs-mounted one.  Problem pointed out by Jim Rees, fix exists
in Net and Free.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.53 2003/01/31 17:37:50 art Exp $	*/
d1618 2
a1619 1
	int v3;
a1636 1
	v3 = NFS_ISV3(vp);
@


1.53.2.2
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.53.2.1 2004/03/01 08:33:36 brad Exp $	*/
d170 1
a170 1
	{ &vop_reclaim_desc, nfsfifo_reclaim },	/* reclaim */
a3243 7
}

int
nfsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (nfs_reclaim(v));
@


1.52
log
@Implement simple vnodeop inheritance for specfs and fifofs.

The inheritace is implemented by setting the default vnodeop to a
bypass op that repeats the operation on the spec/fifo vnodeop vector.
The overhead of one extra indirect function call is worth the cleanup
and improved correctness.

This actually solves a few bugs where some vnode ops were missing from
some vectors (like kqfilter or revoke). (and even more on the ubc
branch).

Inspired by the same thing done in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.51 2002/05/21 21:07:09 art Exp $	*/
d639 1
a639 1
	int flags = cnp->cn_flags;
d653 3
d666 11
a676 1
	if ((error = cache_lookup(dvp, vpp, cnp)) != 0 && error != ENOENT) {
d678 1
a678 1
		int vpid;
d680 13
a692 11
		newvp = *vpp;
		vpid = newvp->v_id;
		/*
		 * See the comment starting `Step through' in ufs/ufs_lookup.c
		 * for an explanation of the locking protocol
		 */
		if (dvp == newvp) {
			VREF(newvp);
			error = 0;
		} else
			error = vget(newvp, LK_EXCLUSIVE, p);
d694 7
a700 11
		if (!error) {
			if (vpid == newvp->v_id) {
			   if (!VOP_GETATTR(newvp, &vattr, cnp->cn_cred, cnp->cn_proc)
			    && vattr.va_ctime.tv_sec == VTONFS(newvp)->n_ctime) {
				nfsstats.lookupcache_hits++;
				if (cnp->cn_nameiop != LOOKUP &&
				    (flags & ISLASTCN))
					cnp->cn_flags |= SAVENAME;
				return (0);
			   }
			   cache_purge(newvp);
d702 30
a732 1
		}
d735 1
d775 4
d782 6
d791 33
d828 1
a828 1
			return (error);
d831 9
a840 5
	if (v3) {
		nfsm_postop_attr(newvp, attrflag);
		nfsm_postop_attr(dvp, attrflag);
	} else
		nfsm_loadattr(newvp, (struct vattr *)0);
d851 14
a864 1
		if (newvp != NULLVP)
d866 3
d878 1
@


1.51
log
@Protect calls to biodone with splbio. Some functions called
by biodone assume splbio (probably just on other filesystems) and some
callbacks from b_iodone assume it too. It's just much safer.
costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.50 2002/03/14 01:27:13 millert Exp $	*/
d129 1
a129 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d139 1
a139 5
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, spec_lookup },	/* lookup */
	{ &vop_create_desc, spec_create },	/* create */
	{ &vop_mknod_desc, spec_mknod },	/* mknod */
	{ &vop_open_desc, spec_open },		/* open */
a145 4
	{ &vop_lease_desc, spec_lease_check },	/* lease */
	{ &vop_ioctl_desc, spec_ioctl },	/* ioctl */
	{ &vop_select_desc, spec_select },	/* select */
	{ &vop_revoke_desc, spec_revoke },	/* revoke */
a146 9
	{ &vop_remove_desc, spec_remove },	/* remove */
	{ &vop_link_desc, spec_link },		/* link */
	{ &vop_rename_desc, spec_rename },	/* rename */
	{ &vop_mkdir_desc, spec_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, spec_rmdir },	/* rmdir */
	{ &vop_symlink_desc, spec_symlink },	/* symlink */
	{ &vop_readdir_desc, spec_readdir },	/* readdir */
	{ &vop_readlink_desc, spec_readlink },	/* readlink */
	{ &vop_abortop_desc, spec_abortop },	/* abortop */
a150 2
	{ &vop_bmap_desc, spec_bmap },		/* bmap */
	{ &vop_strategy_desc, spec_strategy },	/* strategy */
d153 1
a153 5
	{ &vop_pathconf_desc, spec_pathconf },	/* pathconf */
	{ &vop_advlock_desc, spec_advlock },	/* advlock */
	{ &vop_reallocblks_desc, spec_reallocblks },	/* reallocblks */
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d161 1
a161 5
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, fifo_lookup },	/* lookup */
	{ &vop_create_desc, fifo_create },	/* create */
	{ &vop_mknod_desc, fifo_mknod },	/* mknod */
	{ &vop_open_desc, fifo_open },		/* open */
a167 4
	{ &vop_lease_desc, fifo_lease_check },	/* lease */
	{ &vop_ioctl_desc, fifo_ioctl },	/* ioctl */
	{ &vop_select_desc, fifo_select },	/* select */
	{ &vop_revoke_desc, fifo_revoke },	/* revoke */
a168 9
	{ &vop_remove_desc, fifo_remove },	/* remove */
	{ &vop_link_desc, fifo_link },		/* link */
	{ &vop_rename_desc, fifo_rename },	/* rename */
	{ &vop_mkdir_desc, fifo_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, fifo_rmdir },	/* rmdir */
	{ &vop_symlink_desc, fifo_symlink },	/* symlink */
	{ &vop_readdir_desc, fifo_readdir },	/* readdir */
	{ &vop_readlink_desc, fifo_readlink },	/* readlink */
	{ &vop_abortop_desc, fifo_abortop },	/* abortop */
a172 2
	{ &vop_bmap_desc, fifo_bmap },		/* bmap */
	{ &vop_strategy_desc, fifo_badop },	/* strategy */
a174 3
	{ &vop_pathconf_desc, fifo_pathconf },	/* pathconf */
	{ &vop_advlock_desc, fifo_advlock },	/* advlock */
	{ &vop_reallocblks_desc, fifo_reallocblks },	/* reallocblks */
d176 1
a176 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.50
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.49 2002/02/23 23:47:13 art Exp $	*/
d2740 1
a2741 1
			    biodone(bp);
d2943 1
d2945 1
@


1.49
log
@Sigh. The diff is out for testing for three months without a single problem.
Two days after commit people report serious lockups all over the place.
Back out nfs locking changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.47 2002/01/16 21:51:16 ericj Exp $	*/
d89 1
a89 1
int (**nfsv2_vnodeop_p) __P((void *));
d129 1
a129 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d137 1
a137 1
int (**spec_nfsv2nodeop_p) __P((void *));
d176 1
a176 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d182 1
a182 1
int (**fifo_nfsv2nodeop_p) __P((void *));
d221 1
a221 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d3104 1
a3104 1
	extern int (**fifo_vnodeop_p) __P((void *));
d3129 1
a3129 1
	extern int (**fifo_vnodeop_p) __P((void *));
d3159 1
a3159 1
	extern int (**fifo_vnodeop_p) __P((void *));
@


1.48
log
@More locking in the NFS code
@
text
@a695 1
	int dvp_locked = 1;
d704 1
a704 1
	lockparent = ((flags & (LOCKPARENT | ISLASTCN)) == (LOCKPARENT | ISLASTCN));
d707 1
d721 1
a721 7
		} else if (flags & ISDOTDOT) {
			VOP_UNLOCK(dvp, 0, p);
			dvp_locked = 0;
			error = vget(newvp, LK_EXCLUSIVE, p);
			if (error != 0)
				newvp = NULL;
		} else {
a722 3
			if (error != 0)
				newvp = NULL;
		}
d724 1
a724 1
		if (error == 0) {
d732 1
a732 1
				goto exit;
d736 1
a738 16

		if (newvp == dvp)
			vrele(newvp);
		else if (newvp != NULL) 
			vput(newvp);
		
		if (!dvp_locked) {
			vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
			dvp_locked = 1;
		}
	}
  
	np = VTONFS(dvp);
	if (np == NULL) {
		error = ERESTART;
		goto exit;
d740 1
a740 1
    	error = 0;
d763 1
a763 2
			error = EISDIR;
			goto exit;
d768 1
a768 1
			goto exit;
d779 1
a779 2
		error = 0;
		goto exit;
d789 1
a789 1
			goto exit;
d808 2
a819 19

 exit:
	if (error != 0) {
		if (newvp == dvp) {
			vrele(newvp);
		} else if (newvp != NULL) {
			vput(newvp);
		}
	}

	if (!dvp_locked) {
		if (error != 0 || lockparent) {
			vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
		}
	} else {
		if (error == 0 && !lockparent) {
			VOP_UNLOCK(dvp, 0, p);
		}
	}
d1131 1
a1131 1
				vput(newvp);
d1144 2
a1145 4
		if (newvp) {
			vput(newvp);
			newvp = NULL;
		}
d1155 1
a1155 1
	vput(dvp);
d1178 2
a1179 3
	if (error == 0)
		vput(newvp);

d1255 1
a1255 1
				vput(newvp);
d1273 1
a1273 1
			vput(newvp);
d1285 1
a1285 1
	vput(dvp);
d1357 2
a1358 2
	vput(dvp);
	vput(vp);
d1369 1
a1369 1
	
d1449 1
a1449 1
		vput(tvp);
d1657 1
a1657 1
		vput(newvp);
d1662 1
a1662 1
	vput(dvp);
d1732 1
a1732 1
			vput(newvp);
d1745 1
a1745 1
			vput(newvp);
d1749 1
a1749 1
	vput(dvp);
d1778 1
a1778 1
		vput(dvp);
d1797 2
a1798 2
	vput(vp);
	vput(dvp);
d2345 1
a2345 1
			    vput(newvp);
d2386 1
a2386 1
		vput(newvp);
d2510 1
a2510 1
				vput(newvp);
d2520 1
a2520 1
				vput(newvp);
a3183 43


int
nfs_lock(v)
	void *v;
{
        struct vop_lock_args /* {
                struct vnode *a_vp;
                int a_flags;
                sturct proc *a_p;
		} */ *ap = v;
        struct vnode *vp = ap->a_vp;

        return (lockmgr(&VTONFS(vp)->n_lock, ap->a_flags, &vp->v_interlock,
		    ap->a_p));
}

int
nfs_unlock(v)
        void *v;
{
        struct vop_unlock_args /* {
                struct vnode *a_vp;
                int a_flags;
                struct proc *a_p;
		} */ *ap = v;
        struct vnode *vp = ap->a_vp;

        return (lockmgr(&VTONFS(vp)->n_lock, ap->a_flags | LK_RELEASE,
		    &vp->v_interlock, ap->a_p));
}

int
nfs_islocked(v)
        void *v;
{
        struct vop_islocked_args /* {
                struct vnode *a_vp;
		} */ *ap = v;

        return (lockstatus(&VTONFS(ap->a_vp)->n_lock));
}

@


1.47
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.46 2001/12/22 09:58:04 art Exp $	*/
d696 1
d705 1
a705 1
	lockparent = flags & LOCKPARENT;
a707 1
	np = VTONFS(dvp);
d721 7
a727 1
		} else
d729 3
d733 1
a733 1
		if (!error) {
d741 1
a741 1
				return (0);
d745 4
d750 6
a756 1
		*vpp = NULLVP;
d758 7
a764 1
	error = 0;
d787 2
a788 1
			return (EISDIR);
d793 1
a793 1
			return (error);
d804 2
a805 1
		return (0);
d815 1
a815 1
			return (error);
a833 2
		if (newvp != NULLVP)
			vrele(newvp);
d844 19
d1174 1
a1174 1
				vrele(newvp);
d1187 4
a1190 2
		if (newvp)
			vrele(newvp);
d1200 1
a1200 1
	vrele(dvp);
d1223 3
a1225 2
	if (!error)
		vrele(newvp);
d1301 1
a1301 1
				vrele(newvp);
d1319 1
a1319 1
			vrele(newvp);
d1331 1
a1331 1
	vrele(dvp);
d1403 2
a1404 2
	vrele(dvp);
	vrele(vp);
d1415 1
a1415 1

d1495 1
a1495 1
		vrele(tvp);
d1703 1
a1703 1
		vrele(newvp);
d1708 1
a1708 1
	vrele(dvp);
d1778 1
a1778 1
			vrele(newvp);
d1791 1
a1791 1
			vrele(newvp);
d1795 1
a1795 1
	vrele(dvp);
d1824 1
a1824 1
		vrele(dvp);
d1843 2
a1844 2
	vrele(vp);
	vrele(dvp);
d2391 1
a2391 1
			    vrele(newvp);
d2432 1
a2432 1
		vrele(newvp);
d2556 1
a2556 1
				vrele(newvp);
d2566 1
a2566 1
				vrele(newvp);
d3230 43
@


1.46
log
@Init the creds in nfs_open too.
Repairs swap over nfs. Tested by hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.45 2001/12/19 08:58:06 art Exp $	*/
d272 4
a275 4
	register struct vnode *vp = ap->a_vp;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d364 1
a364 1
	register struct vnode *vp = ap->a_vp;
d465 2
a466 2
	register struct vnode *vp = ap->a_vp;
	register struct nfsnode *np = VTONFS(vp);
d499 5
a503 5
	register struct vnode *vp = ap->a_vp;
	register struct nfsnode *np = VTONFS(vp);
	register caddr_t cp;
	register u_int32_t *tl;
	register int32_t t1, t2;
d543 3
a545 3
	register struct vnode *vp = ap->a_vp;
	register struct nfsnode *np = VTONFS(vp);
	register struct vattr *vap = ap->a_vap;
d622 3
a624 3
	register struct nfsv2_sattr *sp;
	register caddr_t cp;
	register int32_t t1, t2;
d680 3
a682 3
	register struct componentname *cnp = ap->a_cnp;
	register struct vnode *dvp = ap->a_dvp;
	register struct vnode **vpp = ap->a_vpp;
d684 5
a688 5
	register int flags = cnp->cn_flags;
	register struct vnode *newvp;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d837 1
a837 1
	register struct vnode *vp = ap->a_vp;
d856 1
a856 1
	register struct vnode *vp = ap->a_vp;
d869 1
a869 1
	register struct vnode *vp;
d873 3
a875 3
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d1000 1
a1000 1
			register u_int32_t x;
d1076 9
a1084 9
	register struct vnode *dvp;
	register struct vnode **vpp;
	register struct componentname *cnp;
	register struct vattr *vap;
{
	register struct nfsv2_sattr *sp;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d1197 7
a1203 7
	register struct vnode *dvp = ap->a_dvp;
	register struct vattr *vap = ap->a_vap;
	register struct componentname *cnp = ap->a_cnp;
	register struct nfsv2_sattr *sp;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d1232 2
a1233 2
			if (in_ifaddr.tqh_first)
				*tl++ = in_ifaddr.tqh_first->ia_addr.sin_addr.s_addr;
d1310 4
a1313 4
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
	register struct componentname *cnp = ap->a_cnp;
	register struct nfsnode *np = VTONFS(vp);
d1367 1
a1367 1
	register struct sillyrename *sp;
d1379 1
a1379 1
	register struct vnode *dvp;
d1385 3
a1387 3
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d1423 6
a1428 6
	register struct vnode *fvp = ap->a_fvp;
	register struct vnode *tvp = ap->a_tvp;
	register struct vnode *fdvp = ap->a_fdvp;
	register struct vnode *tdvp = ap->a_tdvp;
	register struct componentname *tcnp = ap->a_tcnp;
	register struct componentname *fcnp = ap->a_fcnp;
d1486 1
a1486 1
	register struct sillyrename *sp;
d1497 1
a1497 1
	register struct vnode *fdvp;
d1500 1
a1500 1
	register struct vnode *tdvp;
d1506 3
a1508 3
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d1549 6
a1554 6
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
	register struct componentname *cnp = ap->a_cnp;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d1618 7
a1624 7
	register struct vnode *dvp = ap->a_dvp;
	register struct vattr *vap = ap->a_vap;
	register struct componentname *cnp = ap->a_cnp;
	register struct nfsv2_sattr *sp;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d1684 8
a1691 8
	register struct vnode *dvp = ap->a_dvp;
	register struct vattr *vap = ap->a_vap;
	register struct componentname *cnp = ap->a_cnp;
	register struct nfsv2_sattr *sp;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
	register int len;
d1765 6
a1770 6
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
	register struct componentname *cnp = ap->a_cnp;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d1993 1
a1993 1
	register int len, left;
d1995 4
a1998 4
	register struct dirent *dp = NULL;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d2177 1
a2177 1
	register int len, left;
d2179 5
a2183 5
	register struct dirent *dp = NULL;
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
	register struct vnode *newvp;
d2403 1
a2403 1
	register struct sillyrename *sp;
d2459 1
a2459 1
	register struct vnode *dvp;
d2466 3
a2468 3
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d2589 1
a2589 1
	register struct vnode *vp = ap->a_vp;
d2689 2
a2690 2
		for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
			nbp = bp->b_vnbufs.le_next;
d2751 2
a2752 2
	for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
		nbp = bp->b_vnbufs.le_next;
d2802 2
a2803 2
			
		if (vp->v_dirtyblkhd.lh_first && commit) {
d2853 1
a2853 1
	register struct nfsnode *np = VTONFS(ap->a_vp);
d2869 2
a2870 2
	register struct vnode *vp = ap->a_vp;
	register struct nfsnode *np = VTONFS(vp);
d2902 1
a2902 1
	register struct buf *bp;
d2905 2
a2906 2
	register int oldflags = bp->b_flags, retv = 1;
	register struct proc *p = curproc;	/* XXX */
d3021 1
a3021 1
	register struct nfsnode *np = VTONFS(ap->a_vp);
d3045 1
a3045 1
	register struct nfsnode *np = VTONFS(ap->a_vp);
d3071 2
a3072 2
	register struct vnode *vp = ap->a_vp;
	register struct nfsnode *np = VTONFS(vp);
d3105 1
a3105 1
	register struct nfsnode *np = VTONFS(ap->a_vp);
d3130 1
a3130 1
	register struct nfsnode *np = VTONFS(ap->a_vp);
d3156 2
a3157 2
	register struct vnode *vp = ap->a_vp;
	register struct nfsnode *np = VTONFS(vp);
@


1.45
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.39 2001/11/15 23:15:15 art Exp $	*/
d374 20
@


1.44
log
@minor fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.43 2001/12/10 04:45:31 art Exp $	*/
d129 1
a129 4
	{ &vop_getpages_desc, nfs_getpages },		/* getpages */
	{ &vop_putpages_desc, nfs_putpages },		/* putpages */
	{ &vop_mmap_desc, vop_generic_mmap },
	{ NULL, NULL }
d154 1
a154 1
	{ &vop_fsync_desc, spec_fsync },	/* fsync */
d176 1
a176 2
	{ &vop_mmap_desc, spec_mmap },
	{ NULL, NULL }
d221 1
a221 2
	{ &vop_mmap_desc, fifo_mmap },
	{ NULL, NULL }
a375 20
	/*
	 * Initialize read and write creds here, for swapfiles
	 * and other paths that don't set the creds themselves.
	 */

	if (ap->a_mode & FREAD) {
		if (np->n_rcred) {
			crfree(np->n_rcred);
		}
		np->n_rcred = ap->a_cred;
		crhold(np->n_rcred);
	}
	if (ap->a_mode & FWRITE) {
		if (np->n_wcred) {
			crfree(np->n_wcred);
		}
		np->n_wcred = ap->a_cred;
		crhold(np->n_wcred);
	}

d380 1
d398 1
d2514 1
a2514 1
	unsigned cnt;
d2569 1
a2569 1
	struct vnode *vp = ap->a_vp;
d2629 3
a2631 1
 * Flush all the data associated with a vnode.
a2640 1
	struct uvm_object *uobj = &vp->v_uobj;
d2642 11
a2652 3
	int error;
	int flushflags = PGO_ALLPAGES|PGO_CLEANIT|PGO_SYNCIO;
	int rv;
d2654 71
a2724 1
	error = 0;
d2726 63
a2788 5
	simple_lock(&uobj->vmobjlock);
	rv = (uobj->pgops->pgo_flush)(uobj, 0, 0, flushflags);
	simple_unlock(&uobj->vmobjlock);
	if (!rv) {
		error = EIO;
d2863 1
a2863 1
 * Just call bwrite().
d2873 70
a2942 1
	return (bwrite(ap->a_bp));
@


1.44.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.47 2002/01/16 21:51:16 ericj Exp $	*/
d277 4
a280 4
	struct vnode *vp = ap->a_vp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d369 1
a369 1
	struct vnode *vp = ap->a_vp;
d468 2
a469 2
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
d502 5
a506 5
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1, t2;
d546 3
a548 3
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct vattr *vap = ap->a_vap;
d625 3
a627 3
	struct nfsv2_sattr *sp;
	caddr_t cp;
	int32_t t1, t2;
d683 3
a685 3
	struct componentname *cnp = ap->a_cnp;
	struct vnode *dvp = ap->a_dvp;
	struct vnode **vpp = ap->a_vpp;
d687 5
a691 5
	int flags = cnp->cn_flags;
	struct vnode *newvp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d840 1
a840 1
	struct vnode *vp = ap->a_vp;
d859 1
a859 1
	struct vnode *vp = ap->a_vp;
d872 1
a872 1
	struct vnode *vp;
d876 3
a878 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1003 1
a1003 1
			u_int32_t x;
d1079 9
a1087 9
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
{
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1200 7
a1206 7
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1235 2
a1236 2
			if (TAILQ_FIRST(&in_ifaddr))
				*tl++ = TAILQ_FIRST(&in_ifaddr)->ia_addr.sin_addr.s_addr;
d1313 4
a1316 4
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct nfsnode *np = VTONFS(vp);
d1370 1
a1370 1
	struct sillyrename *sp;
d1382 1
a1382 1
	struct vnode *dvp;
d1388 3
a1390 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1426 6
a1431 6
	struct vnode *fvp = ap->a_fvp;
	struct vnode *tvp = ap->a_tvp;
	struct vnode *fdvp = ap->a_fdvp;
	struct vnode *tdvp = ap->a_tdvp;
	struct componentname *tcnp = ap->a_tcnp;
	struct componentname *fcnp = ap->a_fcnp;
d1489 1
a1489 1
	struct sillyrename *sp;
d1500 1
a1500 1
	struct vnode *fdvp;
d1503 1
a1503 1
	struct vnode *tdvp;
d1509 3
a1511 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1552 6
a1557 6
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1621 7
a1627 7
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1687 8
a1694 8
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
	int len;
d1768 6
a1773 6
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1996 1
a1996 1
	int len, left;
d1998 4
a2001 4
	struct dirent *dp = NULL;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d2180 1
a2180 1
	int len, left;
d2182 5
a2186 5
	struct dirent *dp = NULL;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
	struct vnode *newvp;
d2406 1
a2406 1
	struct sillyrename *sp;
d2462 1
a2462 1
	struct vnode *dvp;
d2469 3
a2471 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d2719 1
a2719 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2735 2
a2736 2
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
d2818 1
a2818 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2842 1
a2842 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2868 2
a2869 2
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
d2902 1
a2902 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2927 1
a2927 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2953 2
a2954 2
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
@


1.44.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.44.2.1 2002/01/31 22:55:47 niklas Exp $	*/
d129 2
a130 2
	{ &vop_getpages_desc, nfs_getpages },
	{ &vop_putpages_desc, genfs_putpages },
a588 1
			uvm_vnp_setsize(vp, vap->va_size);
d595 1
a595 2
			if (error) {
				uvm_vnp_setsize(vp, np->n_size);
a596 1
			}
d599 2
a600 1
  		}
a701 1
	newvp = NULLVP;
a706 1

d2597 1
a2597 3
		*ap->a_bnp = ap->a_bn;
	if (ap->a_runp != NULL)
		*ap->a_runp = 1024 * 1024; /* XXX */
d2666 3
d2671 5
a2675 1
	error = (uobj->pgops->pgo_put)(uobj, 0, 0, flushflags);
@


1.44.2.3
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.44.2.2 2002/02/02 03:28:26 art Exp $	*/
d89 1
a89 1
int (**nfsv2_vnodeop_p)(void *);
d140 1
a140 1
int (**spec_nfsv2nodeop_p)(void *);
d186 1
a186 1
int (**fifo_nfsv2nodeop_p)(void *);
d2541 1
a2541 1
	unsigned int cnt;
d2900 1
a2900 1
	extern int (**fifo_vnodeop_p)(void *);
d2925 1
a2925 1
	extern int (**fifo_vnodeop_p)(void *);
d2955 1
a2955 1
	extern int (**fifo_vnodeop_p)(void *);
@


1.44.2.4
log
@Resurrect Costas nfs locking on the UBC branch. It's needed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.48 2002/02/22 20:19:14 csapuntz Exp $	*/
a700 1
	int dvp_locked = 1;
d711 1
a711 1
	lockparent = ((flags & (LOCKPARENT | ISLASTCN)) == (LOCKPARENT | ISLASTCN));
d714 1
d728 1
a728 3
		} else if (flags & ISDOTDOT) {
			VOP_UNLOCK(dvp, 0, p);
			dvp_locked = 0;
a729 7
			if (error != 0)
				newvp = NULL;
		} else {
			error = vget(newvp, LK_EXCLUSIVE, p);
			if (error != 0)
				newvp = NULL;
		}
d731 1
a731 1
		if (error == 0) {
d739 1
a739 1
				goto exit;
d743 1
a745 16

		if (newvp == dvp)
			vrele(newvp);
		else if (newvp != NULL) 
			vput(newvp);
		
		if (!dvp_locked) {
			vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
			dvp_locked = 1;
		}
	}
  
	np = VTONFS(dvp);
	if (np == NULL) {
		error = ERESTART;
		goto exit;
d747 1
a747 1
    	error = 0;
d770 1
a770 2
			error = EISDIR;
			goto exit;
d775 1
a775 1
			goto exit;
d786 1
a786 2
		error = 0;
		goto exit;
d796 1
a796 1
			goto exit;
d815 2
a826 19

 exit:
	if (error != 0) {
		if (newvp == dvp) {
			vrele(newvp);
		} else if (newvp != NULL) {
			vput(newvp);
		}
	}

	if (!dvp_locked) {
		if (error != 0 || lockparent) {
			vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
		}
	} else {
		if (error == 0 && !lockparent) {
			VOP_UNLOCK(dvp, 0, p);
		}
	}
d1138 1
a1138 1
				vput(newvp);
d1151 2
a1152 4
		if (newvp) {
			vput(newvp);
			newvp = NULL;
		}
d1162 1
a1162 1
	vput(dvp);
d1185 2
a1186 3
	if (error == 0)
		vput(newvp);

d1262 1
a1262 1
				vput(newvp);
d1280 1
a1280 1
			vput(newvp);
d1292 1
a1292 1
	vput(dvp);
d1364 2
a1365 2
	vput(dvp);
	vput(vp);
d1376 1
a1376 1
	
d1456 1
a1456 1
		vput(tvp);
d1664 1
a1664 1
		vput(newvp);
d1669 1
a1669 1
	vput(dvp);
d1739 1
a1739 1
			vput(newvp);
d1752 1
a1752 1
			vput(newvp);
d1756 1
a1756 1
	vput(dvp);
d1785 1
a1785 1
		vput(dvp);
d1804 2
a1805 2
	vput(vp);
	vput(dvp);
d2352 1
a2352 1
			    vput(newvp);
d2393 1
a2393 1
		vput(newvp);
d2517 1
a2517 1
				vput(newvp);
d2527 1
a2527 1
				vput(newvp);
a2979 43


int
nfs_lock(v)
	void *v;
{
        struct vop_lock_args /* {
                struct vnode *a_vp;
                int a_flags;
                sturct proc *a_p;
		} */ *ap = v;
        struct vnode *vp = ap->a_vp;

        return (lockmgr(&VTONFS(vp)->n_lock, ap->a_flags, &vp->v_interlock,
		    ap->a_p));
}

int
nfs_unlock(v)
        void *v;
{
        struct vop_unlock_args /* {
                struct vnode *a_vp;
                int a_flags;
                struct proc *a_p;
		} */ *ap = v;
        struct vnode *vp = ap->a_vp;

        return (lockmgr(&VTONFS(vp)->n_lock, ap->a_flags | LK_RELEASE,
		    &vp->v_interlock, ap->a_p));
}

int
nfs_islocked(v)
        void *v;
{
        struct vop_islocked_args /* {
                struct vnode *a_vp;
		} */ *ap = v;

        return (lockstatus(&VTONFS(ap->a_vp)->n_lock));
}

@


1.44.2.5
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.44.2.4 2002/10/29 18:31:51 art Exp $	*/
d143 4
d153 4
d158 9
d171 2
d175 5
a179 1
	SPEC_VNODEOP_DESCS,
d189 4
d199 4
d204 9
d218 1
d221 3
d225 1
a225 1
	FIFO_VNODEOP_DESCS,
d333 1
a333 1
		nfsm_postop_attr(vp, attrflag, 0);
d527 1
a527 1
		nfsm_loadattr(vp, ap->a_vap, 0);
a589 2
			tsize = np->n_size;
			np->n_size = vap->va_size;
d597 1
a597 1
				uvm_vnp_setsize(vp, tsize);
d600 2
a601 1
 			np->n_vattr.va_size = vap->va_size;
d663 1
a663 1
		nfsm_wcc_data(vp, wccflag, 0);
d665 1
a665 1
		nfsm_loadattr(vp, (struct vattr *)0, 0);
d782 1
a782 1
		nfsm_postop_attr(dvp, attrflag, 0);
d804 2
a805 2
			nfsm_postop_attr(newvp, attrflag, 0);
			nfsm_postop_attr(dvp, attrflag, 0);
d807 1
a807 1
			nfsm_loadattr(newvp, (struct vattr *)0, 0);
d827 2
a828 2
		nfsm_postop_attr(newvp, attrflag, 0);
		nfsm_postop_attr(dvp, attrflag, 0);
d830 1
a830 1
		nfsm_loadattr(newvp, (struct vattr *)0, 0);
d936 1
a936 1
		nfsm_postop_attr(vp, attrflag, 0);
d987 1
a987 1
			nfsm_postop_attr(vp, attrflag, NAC_NOTRUNC);
d995 1
a995 1
			nfsm_loadattr(vp, (struct vattr *)0, NAC_NOTRUNC);
d1067 1
a1067 1
			nfsm_wcc_data(vp, wccflag, NAC_NOTRUNC);
d1106 1
a1106 1
		    nfsm_loadattr(vp, (struct vattr *)0, NAC_NOTRUNC);
d1191 1
a1191 1
		nfsm_wcc_data(dvp, wccflag, 0);
d1318 1
a1318 1
		nfsm_wcc_data(dvp, wccflag, 0);
a1409 4
	if (dvp == vp)
		vrele(vp);
	else
		vput(vp);
d1411 1
d1453 1
a1453 1
		nfsm_wcc_data(dvp, wccflag, 0);
d1577 2
a1578 2
		nfsm_wcc_data(fdvp, fwccflag, 0);
		nfsm_wcc_data(tdvp, twccflag, 0);
d1638 2
a1639 2
		nfsm_postop_attr(vp, attrflag, 0);
		nfsm_wcc_data(dvp, wccflag, 0);
d1706 1
a1706 1
		nfsm_wcc_data(dvp, wccflag, 0);
d1774 1
a1774 1
		nfsm_wcc_data(dvp, wccflag, 0);
d1842 1
a1842 1
		nfsm_wcc_data(dvp, wccflag, 0);
d2099 1
a2099 1
			nfsm_postop_attr(vp, attrflag, 0);
d2283 1
a2283 1
		nfsm_postop_attr(vp, attrflag, 0);
d2378 1
a2378 1
				nfsm_loadattr(newvp, (struct vattr *)0, 0);
d2397 3
a2399 7
			if (newvp != NULL) {
			    if (newvp == vp)
				vrele(newvp);
			    else
				vput(newvp);
			    vrele(newvp);
			    newvp = NULL;
d2438 2
a2439 6
	if (newvp != NULL) {
		if (newvp == vp)
			vrele(newvp);
		else
			vput(newvp);
	}
d2560 1
a2560 1
			nfsm_postop_attr(newvp, attrflag, 0);
d2567 1
a2567 1
			nfsm_loadattr(newvp, (struct vattr *)0, 0);
d2608 1
a2608 1
	nfsm_wcc_data(vp, wccflag, 0);
d3032 6
a3037 6
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
		sturct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
d3039 2
a3040 2
	return (lockmgr(&VTONFS(vp)->n_lock, ap->a_flags, &vp->v_interlock,
	    ap->a_p));
d3047 6
a3052 16
	struct vop_unlock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;

	/*
	 * VOP_UNLOCK can be called by nfs_loadattrcache
	 * with v_data == 0.
	 */
	if (VTONFS(vp) == NULL) {
		return (0);	/* XXX */
	}

	nfs_delayedtruncate(vp);
d3054 2
a3055 2
	return (lockmgr(&VTONFS(vp)->n_lock, ap->a_flags | LK_RELEASE,
	    &vp->v_interlock, ap->a_p));
@


1.44.2.6
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d142 1
a142 1
	{ &vop_default_desc, spec_vnoperate },
d149 1
d156 1
d165 1
a165 1
	{ &vop_default_desc, fifo_vnoperate },
d177 1
d181 1
d646 1
a646 1
	int flags;
d658 1
a660 3
	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

d668 2
a669 1
	lockparent = flags & LOCKPARENT;
d672 1
a672 12
	np = VTONFS(dvp);

	/*
	 * Before tediously performing a linear scan of the directory,
	 * check the name cache to see if the directory/name pair
	 * we are looking for is known already.
	 * If the directory/name pair is found in the name cache,
	 * we have to ensure the directory has not changed from
	 * the time the cache entry has been created. If it has,
	 * the cache entry has to be ignored.
	 */
	if ((error = cache_lookup(dvp, vpp, cnp)) >= 0) {
d674 1
a674 1
		int err2;
d676 32
a707 10
		if (error && error != ENOENT) {
			*vpp = NULLVP;
			return (error);
		}

		if (cnp->cn_flags & PDIRUNLOCK) {
			err2 = vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
			if (err2 != 0) {
				*vpp = NULLVP;
				return (err2);
a708 1
			cnp->cn_flags &= ~PDIRUNLOCK;
d710 1
d712 8
a719 10
		err2 = VOP_ACCESS(dvp, VEXEC, cnp->cn_cred, cnp->cn_proc);
		if (err2 != 0) {
			if (error == 0) {
				if (*vpp != dvp)
					vput(*vpp);
				else
					vrele(*vpp);
			}
			*vpp = NULLVP;
			return (err2);
a720 29

		if (error == ENOENT) {
			if (!VOP_GETATTR(dvp, &vattr, cnp->cn_cred,
			    cnp->cn_proc) && vattr.va_mtime.tv_sec ==
			    VTONFS(dvp)->n_ctime)
				return (ENOENT);
			cache_purge(dvp);
			np->n_ctime = 0;
			goto dorpc;
		}

		newvp = *vpp;
		if (!VOP_GETATTR(newvp, &vattr, cnp->cn_cred, cnp->cn_proc)
			&& vattr.va_ctime.tv_sec == VTONFS(newvp)->n_ctime)
		{
			nfsstats.lookupcache_hits++;
			if (cnp->cn_nameiop != LOOKUP && (flags & ISLASTCN))
				cnp->cn_flags |= SAVENAME;
			if ((!lockparent || !(flags & ISLASTCN)) &&
			     newvp != dvp)
				VOP_UNLOCK(dvp, 0, p);
			return (0);
		}
		cache_purge(newvp);
		if (newvp != dvp)
			vput(newvp);
		else
			vrele(newvp);
		*vpp = NULLVP;
d722 7
a728 2
dorpc:
	error = 0;
d751 2
a752 1
			return (EISDIR);
d757 1
a757 1
			return (error);
d768 2
a769 5
		if (!lockparent) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (0);
a771 6
	/*
	 * The postop attr handling is duplicated for each if case,
	 * because it should be done while dvp is locked (unlocking
	 * dvp is different for each case).
	 */

a774 33
		if (v3) {
			nfsm_postop_attr(newvp, attrflag, 0);
			nfsm_postop_attr(dvp, attrflag, 0);
		} else
			nfsm_loadattr(newvp, (struct vattr *)0, 0);
	} else if (flags & ISDOTDOT) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;

		error = nfs_nget(dvp->v_mount, fhp, fhsize, &np);
		if (error) {
			if (vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
			m_freem(mrep);
			return (error);
		}
		newvp = NFSTOV(np);

		if (v3) {
			nfsm_postop_attr(newvp, attrflag, 0);
			nfsm_postop_attr(dvp, attrflag, 0);
		} else
			nfsm_loadattr(newvp, (struct vattr *)0, 0);

		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(dvp, LK_EXCLUSIVE, p))) {
				m_freem(mrep);
				vput(newvp);
				return error;
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}

d779 1
a779 1
			return error;
a781 9
		if (v3) {
			nfsm_postop_attr(newvp, attrflag, 0);
			nfsm_postop_attr(dvp, attrflag, 0);
		} else
			nfsm_loadattr(newvp, (struct vattr *)0, 0);
		if (!lockparent || !(flags & ISLASTCN)) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
d783 5
a797 18
		/*
		 * We get here only because of errors returned by
		 * the RPC. Otherwise we'll have returned above
		 * (the nfsm_* macros will jump to nfsm_reqdone
		 * on error).
		 */
		if (error == ENOENT && (cnp->cn_flags & MAKEENTRY) &&
		    cnp->cn_nameiop != CREATE) {
			if (VTONFS(dvp)->n_ctime == 0)
				VTONFS(dvp)->n_ctime =
				    VTONFS(dvp)->n_vattr.va_mtime.tv_sec;
			cache_enter(dvp, NULL, cnp);
		}
		if (newvp != NULLVP) {
			vrele(newvp);
			if (newvp != dvp)
				VOP_UNLOCK(newvp, 0, p);
		}
d807 19
a825 1
		*vpp = NULL;
d2445 1
a2445 2
	sp->s_namlen = snprintf(sp->s_name, sizeof sp->s_name,
	    ".nfsA%05x4.4", cnp->cn_proc->p_pid);
d3026 5
a3030 2
	if (VTONFS(vp))
		nfs_delayedtruncate(vp);
@


1.43
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.42 2001/12/10 02:19:34 art Exp $	*/
d2592 1
a2592 1
	register struct vnode *vp = ap->a_vp;
@


1.42
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.41 2001/12/04 22:44:32 art Exp $	*/
d131 1
a131 1
	{ &vop_mmap_desc, genfs_mmap },
@


1.41
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.40 2001/11/27 05:27:12 art Exp $	*/
d2662 1
a2662 1
	struct uvm_object *uobj = &vp->v_uvm.u_obj;
@


1.40
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.39 2001/11/15 23:15:15 art Exp $	*/
d131 1
d179 2
a180 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d225 2
a226 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.39
log
@Remove creds from struct buf, move the creds that nfs need into the nfs node.
While in the area, convert nfs node allocation from malloc to pool and do
some cleanups.
Based on the UBC changes in NetBSD. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.38 2001/11/06 19:53:21 miod Exp $	*/
d129 3
a131 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d156 1
a156 1
	{ &vop_fsync_desc, nfs_fsync },		/* fsync */
d378 20
a401 1
		uvm_vnp_uncache(vp);
a418 1
			uvm_vnp_uncache(vp);
d2534 1
a2534 1
	int cnt;
d2649 1
a2649 3
 * Flush all the blocks associated with a vnode.
 * 	Walk through the buffer pool and push any dirty pages
 *	associated with the vnode.
d2659 1
d2661 3
a2663 11
	struct buf *bp;
	int i;
	struct buf *nbp;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	int s, error = 0, slptimeo = 0, slpflag = 0, retv, bvecpos;
	int passone = 1;
	u_quad_t off = (u_quad_t)-1, endoff = 0, toff;
#ifndef NFS_COMMITBVECSIZ
#define NFS_COMMITBVECSIZ	20
#endif
	struct buf *bvec[NFS_COMMITBVECSIZ];
d2665 1
a2665 71
	if (nmp->nm_flag & NFSMNT_INT)
		slpflag = PCATCH;
	if (!commit)
		passone = 0;
	/*
	 * A b_flags == (B_DELWRI | B_NEEDCOMMIT) block has been written to the
	 * server, but nas not been committed to stable storage on the server
	 * yet. On the first pass, the byte range is worked out and the commit
	 * rpc is done. On the second pass, nfs_writebp() is called to do the
	 * job.
	 */
again:
	bvecpos = 0;
	if (NFS_ISV3(vp) && commit) {
		s = splbio();
		for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
			nbp = bp->b_vnbufs.le_next;
			if (bvecpos >= NFS_COMMITBVECSIZ)
				break;
			if ((bp->b_flags & (B_BUSY | B_DELWRI | B_NEEDCOMMIT))
				!= (B_DELWRI | B_NEEDCOMMIT))
				continue;
			bremfree(bp);
			bp->b_flags |= (B_BUSY | B_WRITEINPROG);
			/*
			 * A list of these buffers is kept so that the
			 * second loop knows which buffers have actually
			 * been committed. This is necessary, since there
			 * may be a race between the commit rpc and new
			 * uncommitted writes on the file.
			 */
			bvec[bvecpos++] = bp;
			toff = ((u_quad_t)bp->b_blkno) * DEV_BSIZE +
				bp->b_dirtyoff;
			if (toff < off)
				off = toff;
			toff += (u_quad_t)(bp->b_dirtyend - bp->b_dirtyoff);
			if (toff > endoff)
				endoff = toff;
		}
		splx(s);
	}
	if (bvecpos > 0) {
		/*
		 * Commit data on the server, as required.
		 */
		retv = nfs_commit(vp, off, (int)(endoff - off), p);
		if (retv == NFSERR_STALEWRITEVERF)
			nfs_clearcommit(vp->v_mount);
		/*
		 * Now, either mark the blocks I/O done or mark the
		 * blocks dirty, depending on whether the commit
		 * succeeded.
		 */
		for (i = 0; i < bvecpos; i++) {
			bp = bvec[i];
			bp->b_flags &= ~(B_NEEDCOMMIT | B_WRITEINPROG);
			if (retv)
			    brelse(bp);
			else {
			    s = splbio();
			    buf_undirty(bp);
			    vp->v_numoutput++;
			    bp->b_flags |= B_ASYNC;
			    bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
			    bp->b_dirtyoff = bp->b_dirtyend = 0;
			    splx(s);
			    biodone(bp);
			}
		}
	}
d2667 5
a2671 63
	/*
	 * Start/do any write(s) that are required.
	 */
loop:
	s = splbio();
	for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
		nbp = bp->b_vnbufs.le_next;
		if (bp->b_flags & B_BUSY) {
			if (waitfor != MNT_WAIT || passone)
				continue;
			bp->b_flags |= B_WANTED;
			error = tsleep((caddr_t)bp, slpflag | (PRIBIO + 1),
				"nfsfsync", slptimeo);
			splx(s);
			if (error) {
			    if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
				return (EINTR);
			    if (slpflag == PCATCH) {
				slpflag = 0;
				slptimeo = 2 * hz;
			    }
			}
			goto loop;
		}
		if ((bp->b_flags & B_DELWRI) == 0)
			panic("nfs_fsync: not dirty");
		if ((passone || !commit) && (bp->b_flags & B_NEEDCOMMIT))
			continue;
		bremfree(bp);
		if (passone || !commit)
		    bp->b_flags |= (B_BUSY|B_ASYNC);
		else
		    bp->b_flags |= (B_BUSY|B_ASYNC|B_WRITEINPROG|B_NEEDCOMMIT);
		splx(s);
		VOP_BWRITE(bp);
		goto loop;
	}
	splx(s);
	if (passone) {
		passone = 0;
		goto again;
	}
	if (waitfor == MNT_WAIT) {
 loop2:
	        s = splbio();
		error = vwaitforio(vp, slpflag, "nfs_fsync", slptimeo);
		splx(s);
		if (error) {
			if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
				return (EINTR);
			if (slpflag == PCATCH) {
				slpflag = 0;
				slptimeo = 2 * hz;
			}
			goto loop2;
		}
			
		if (vp->v_dirtyblkhd.lh_first && commit) {
#if 0
			vprint("nfs_fsync: dirty", vp);
#endif
			goto loop;
		}
d2746 1
a2746 1
 * Just call nfs_writebp() with the force argument set to 1.
d2756 1
a2756 70
	return (nfs_writebp(ap->a_bp, 1));
}

/*
 * This is a clone of vop_generic_bwrite(), except that B_WRITEINPROG isn't set unless
 * the force flag is one and it also handles the B_NEEDCOMMIT flag.
 */
int
nfs_writebp(bp, force)
	register struct buf *bp;
	int force;
{
	register int oldflags = bp->b_flags, retv = 1;
	register struct proc *p = curproc;	/* XXX */
	off_t off;
	int   s;

	if(!(bp->b_flags & B_BUSY))
		panic("bwrite: buffer is not busy???");

#ifdef fvdl_debug
	printf("nfs_writebp(%x): vp %x voff %d vend %d doff %d dend %d\n",
	    bp, bp->b_vp, bp->b_validoff, bp->b_validend, bp->b_dirtyoff,
	    bp->b_dirtyend);
#endif
	bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);

	s = splbio();
	buf_undirty(bp);

	if ((oldflags & B_ASYNC) && !(oldflags & B_DELWRI) && p)
		++p->p_stats->p_ru.ru_oublock;

	bp->b_vp->v_numoutput++;
	splx(s);

	/*
	 * If B_NEEDCOMMIT is set, a commit rpc may do the trick. If not
	 * an actual write will have to be scheduled via. VOP_STRATEGY().
	 * If B_WRITEINPROG is already set, then push it with a write anyhow.
	 */
	if ((oldflags & (B_NEEDCOMMIT | B_WRITEINPROG)) == B_NEEDCOMMIT) {
		off = ((u_quad_t)bp->b_blkno) * DEV_BSIZE + bp->b_dirtyoff;
		bp->b_flags |= B_WRITEINPROG;
		retv = nfs_commit(bp->b_vp, off, bp->b_dirtyend-bp->b_dirtyoff,
			bp->b_proc);
		bp->b_flags &= ~B_WRITEINPROG;
		if (!retv) {
			bp->b_dirtyoff = bp->b_dirtyend = 0;
			bp->b_flags &= ~B_NEEDCOMMIT;
			biodone(bp);
		} else if (retv == NFSERR_STALEWRITEVERF)
			nfs_clearcommit(bp->b_vp->v_mount);
	}
	if (retv) {
		if (force)
			bp->b_flags |= B_WRITEINPROG;
		VOP_STRATEGY(bp);
	}

	if( (oldflags & B_ASYNC) == 0) {
		int rtval = biowait(bp);
		if (!(oldflags & B_DELWRI) && p) {
			++p->p_stats->p_ru.ru_oublock;
		}
		brelse(bp);
		return (rtval);
	} 

	return (0);
@


1.38
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.37 2001/07/26 20:24:47 millert Exp $	*/
d597 2
a598 2
	register struct vnode *vp;
	register struct vattr *vap;
d880 2
a881 2
nfs_readrpc(vp, uiop, cred)
	register struct vnode *vp;
a882 1
	struct ucred *cred;
d884 3
a886 3
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
d914 2
a915 1
		nfsm_request(vp, NFSPROC_READ, uiop->uio_procp, cred);
d944 3
a946 4
nfs_writerpc(vp, uiop, cred, iomode, must_commit)
	register struct vnode *vp;
	register struct uio *uiop;
	struct ucred *cred;
d949 3
a951 3
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2, backup;
d993 2
a994 1
		nfsm_request(vp, NFSPROC_WRITE, uiop->uio_procp, cred);
d2511 2
a2512 2
nfs_commit(vp, offset, cnt, cred, procp)
	register struct vnode *vp;
a2514 1
	struct ucred *cred;
d2517 4
a2520 4
	register caddr_t cp;
	register u_int32_t *tl;
	register int32_t t1, t2;
	register struct nfsmount *nmp = VFSTONFS(vp->v_mount);
d2534 1
a2534 1
	nfsm_request(vp, NFSPROC_COMMIT, procp, cred);
d2589 1
a2589 2
	register struct buf *bp = ap->a_bp;
	struct ucred *cr;
d2596 1
a2596 1
		p = (struct proc *)0;
a2598 4
	if (bp->b_flags & B_READ)
		cr = bp->b_rcred;
	else
		cr = bp->b_wcred;
d2604 2
a2605 3
	if ((bp->b_flags & B_ASYNC) == 0 ||
		nfs_asyncio(bp, NOCRED))
		error = nfs_doio(bp, cr, p);
d2635 1
a2635 1
	register struct vnode *vp;
d2641 3
a2643 3
	register struct nfsnode *np = VTONFS(vp);
	register struct buf *bp;
	register int i;
a2648 1
	struct ucred* wcred = NULL;
a2676 8
			/*
			 * Work out if all buffers are using the same cred
			 * so we can deal with them all with one commit.
			 */
			if (wcred == NULL)
				wcred = bp->b_wcred;
			else if (wcred != bp->b_wcred)
				wcred = NOCRED;
a2698 3
		 * If all bufs are using the same wcred, then use that with
		 * one call for all of them, otherwise commit each one
		 * separately.
d2700 1
a2700 18
		if (wcred != NOCRED)
			retv = nfs_commit(vp, off, (int)(endoff - off),
					  wcred, p);
		else {
			retv = 0;
			for (i = 0; i < bvecpos; i++) {
				off_t off, size;
				bp = bvec[i];
				off = ((u_quad_t)bp->b_blkno) * DEV_BSIZE +
					bp->b_dirtyoff;
				size = (u_quad_t)(bp->b_dirtyend
						  - bp->b_dirtyoff);
				retv = nfs_commit(vp, off, (int)size,
						  bp->b_wcred, p);
				if (retv) break;
			}
		}

d2918 1
a2918 1
			bp->b_wcred, bp->b_proc);
@


1.37
log
@Back out changes to symlink and mknod that were not well tested.
A simple mknod at causes a kernel panic (uvm_fault).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.35 2001/07/03 01:55:13 csapuntz Exp $	*/
d64 1
a64 1
#include <vm/vm.h>
@


1.36
log
@change vop_symlink and vop_mknod to return vpp (the created node)
refed, so that the caller can actually use it.  update callers and
file systems that implement these vnode operations

ok'd by art
@
text
@d1158 2
d1636 7
a1647 19
	if (error == 0 && newvp == NULL) {
		struct nfsnode *np = NULL;

		error = nfs_lookitup(dvp, cnp->cn_nameptr, cnp->cn_namelen,
		    cnp->cn_cred, cnp->cn_proc, &np);
		if (error == 0)
			newvp = NFSTOV(np);
	}
	if (error) {
		if (newvp != NULL)
			vput(newvp);
	} else {
		*ap->a_vpp = newvp;
	}
	FREE(cnp->cn_pnbuf, M_NAMEI);
	VTONFS(dvp)->n_flag |= NMODIFIED;
	if (!wccflag)
		VTONFS(dvp)->n_attrstamp = 0;
	vrele(dvp);
@


1.35
log
@

In readdir, set the calling process in the constructed uio structures.
Fixes problems with interruptible NFS mounts.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.34 2001/06/27 04:58:46 art Exp $	*/
a1157 2
	if (!error)
		vrele(newvp);
d1634 19
a1652 2
	if (newvp)
		vrele(newvp);
a1657 5
	/*
	 * Kludge: Map EEXIST => 0 assuming that it is a reply to a retry.
	 */
	if (error == EEXIST)
		error = 0;
@


1.34
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.33 2001/06/25 03:28:13 csapuntz Exp $	*/
d1890 1
@


1.33
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.32 2001/06/25 02:15:48 csapuntz Exp $	*/
a379 1
#if defined(UVM)
a380 3
#else
		(void) vnode_pager_uncache(vp);
#endif
a397 1
#if defined(UVM)
a398 3
#else
			(void) vnode_pager_uncache(vp);
#endif
a575 1
#if defined(UVM)
a576 3
#else
 			vnode_pager_setsize(vp, (u_long)np->n_size);
#endif
a586 1
#if defined(UVM)
a587 3
#else
		vnode_pager_setsize(vp, (u_long)np->n_size);
#endif
@


1.32
log
@
Get rid of old directory caching scheme which caused persistent duplicates.

Still not correct for NFSv3 but that's hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.31 2001/06/23 02:14:26 csapuntz Exp $	*/
a75 1
#include <nfs/nqnfs.h>
a365 1
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
d375 4
a378 10
	/*
	 * Get a valid lease. If cached data is stale, flush it.
	 */
	if (nmp->nm_flag & NFSMNT_NQNFS) {
		if (NQNFS_CKINVALID(vp, np, ND_READ)) {
		    do {
			error = nqnfs_getlease(vp, ND_READ, ap->a_cred,
			    ap->a_p);
		    } while (error == NQNFS_EXPIRED);
		    if (error)
a379 5
		    if (np->n_lrev != np->n_brev ||
			(np->n_flag & NQNFSNONCACHE)) {
			if ((error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred,
				ap->a_p, 1)) == EINTR)
				return (error);
d381 1
a381 1
			uvm_vnp_uncache(vp);
d383 1
a383 1
			(void) vnode_pager_uncache(vp);
d385 7
a391 3
			np->n_brev = np->n_lrev;
		    }
		}
d393 8
a400 3
		if (np->n_flag & NMODIFIED) {
			if ((error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred,
				ap->a_p, 1)) == EINTR)
a406 6
			np->n_attrstamp = 0;
			if (vp->v_type == VDIR)
				np->n_direofoffset = 0;
			error = VOP_GETATTR(vp, &vattr, ap->a_cred, ap->a_p);
			if (error)
				return (error);
a407 17
		} else {
			error = VOP_GETATTR(vp, &vattr, ap->a_cred, ap->a_p);
			if (error)
				return (error);
			if (np->n_mtime != vattr.va_mtime.tv_sec) {
				if (vp->v_type == VDIR)
					np->n_direofoffset = 0;
				if ((error = nfs_vinvalbuf(vp, V_SAVE,
					ap->a_cred, ap->a_p, 1)) == EINTR)
					return (error);
#if defined(UVM)
				uvm_vnp_uncache(vp);
#else
				(void) vnode_pager_uncache(vp);
#endif
				np->n_mtime = vattr.va_mtime.tv_sec;
			}
d410 1
a410 2
	if ((nmp->nm_flag & NFSMNT_NQNFS) == 0)
		np->n_attrstamp = 0; /* For Open/Close consistency */
a439 3
 * for NQNFS         - do nothing now, since 2 is dealt with via leases and
 *                     1 should be dealt with via an fsync() system call for
 *                     cases where write errors are important.
d458 1
a458 2
	    if ((VFSTONFS(vp->v_mount)->nm_flag & NFSMNT_NQNFS) == 0 &&
		(np->n_flag & NMODIFIED)) {
d1861 3
a1863 11
	    uio->uio_offset == np->n_direofoffset &&
	    (np->n_flag & NMODIFIED) == 0) {
		if (VFSTONFS(vp->v_mount)->nm_flag & NFSMNT_NQNFS) {
			if (NQNFS_CKCACHABLE(vp, ND_READ)) {
				nfsstats.direofcache_hits++;
				*ap->a_eofflag = 1;
				return (0);
			}
		} else if (
			VOP_GETATTR(vp, &vattr, ap->a_cred, uio->uio_procp) == 0 &&
			np->n_mtime == vattr.va_mtime.tv_sec) {
@


1.31
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.30 2001/06/05 21:56:14 provos Exp $	*/
a236 1
#define	DIRHDSIZ	(sizeof (struct dirent) - (MAXNAMLEN + 1))
d1835 21
d1868 2
a1869 2
		u_long *a_cookies;
		int a_ncookies;
d1871 3
a1873 5
	register struct vnode *vp = ap->a_vp;
	register struct nfsnode *np = VTONFS(vp);
	register struct uio *uio = ap->a_uio;
	char *base = uio->uio_iov->iov_base;
	off_t off = uio->uio_offset;
d1876 10
d1892 2
a1893 1
	if (np->n_direofoffset > 0 && uio->uio_offset >= np->n_direofoffset &&
d1901 2
a1902 1
		} else if (VOP_GETATTR(vp, &vattr, ap->a_cred, uio->uio_procp) == 0 &&
d1910 3
a1912 3
	/*
	 * Call nfs_bioread() to do the real work.
	 */
a1913 1
	error = nfs_bioread(vp, uio, 0, ap->a_cred);
d1915 2
a1916 5
	if (!error && uio->uio_resid == tresid) {
		nfsstats.direofcache_misses++;
		*ap->a_eofflag = 1;
		return (0);
	}
d1918 2
a1919 6
	if (!error && ap->a_cookies) {
		struct dirent *dp;
		u_long *cookies;
		/* XXX - over-estimate - see UFS code for how to do it
		   right */
		int ncookies = ((caddr_t)uio->uio_iov->iov_base - base) / 12;
d1923 3
a1925 2
                *ap->a_ncookies = ncookies;
                *ap->a_cookies = cookies;
d1927 47
a1973 9
		/* Only the NFS server and emulations use cookies, and they
		 * load the directory block into system space, so we can
		 * just look at it directly.
		 */
		if (uio->uio_segflg != UIO_SYSSPACE || uio->uio_iovcnt != 1)
			panic("nfs_readdir: lost in space");
		while (ncookies-- && base < (caddr_t)uio->uio_iov->iov_base) {
			dp = (struct dirent *) base;
			if (dp->d_reclen == 0)
d1975 23
a1997 3
			off += dp->d_reclen;
			*(cookies++) = off;
			base += dp->d_reclen;
d1999 4
d2004 4
a2007 4
		*ap->a_ncookies -= ncookies;
		uio->uio_resid += ((caddr_t)uio->uio_iov->iov_base - base);
		uio->uio_iov->iov_len += ((caddr_t)uio->uio_iov->iov_base - base);
		uio->uio_iov->iov_base = base;
d2014 5
a2020 1
 * Called from below the buffer cache by nfs_doio().
d2023 4
a2026 4
nfs_readdirrpc(vp, uiop, cred)
	struct vnode *vp;
	register struct uio *uiop;
	struct ucred *cred;
d2029 1
a2033 1
	register nfsuint64 *cookiep;
d2045 1
a2045 1
	if (uiop->uio_iovcnt != 1 || (uiop->uio_offset & (NFS_DIRBLKSIZ - 1)) ||
d2050 2
a2051 8
	/*
	 * If there is no cookie, assume end of directory.
	 */
	cookiep = nfs_getcookie(dnp, uiop->uio_offset, 0);
	if (cookiep)
		cookie = *cookiep;
	else
		return (0);
d2066 8
a2073 2
			*tl++ = dnp->n_cookieverf.nfsuquad[0];
			*tl++ = dnp->n_cookieverf.nfsuquad[1];
d2076 1
a2076 1
			*tl++ = cookie.nfsuquad[0];
d2113 1
a2113 3
			tlen = nfsm_rndup(len);
			if (tlen == len)
				tlen += 4;	/* To ensure null termination */
d2115 1
a2115 1
			if ((tlen + DIRHDSIZ) > left) {
a2118 1
				uiop->uio_offset += left;
d2122 1
a2122 1
			if ((tlen + DIRHDSIZ) > uiop->uio_resid)
d2125 3
a2127 1
				dp = (struct dirent *)uiop->uio_iov->iov_base;
d2130 1
a2130 1
				dp->d_reclen = tlen + DIRHDSIZ;
d2135 3
a2137 4
				uiop->uio_offset += DIRHDSIZ;
				uiop->uio_resid -= DIRHDSIZ;
				(caddr_t)uiop->uio_iov->iov_base += DIRHDSIZ;
				uiop->uio_iov->iov_len -= DIRHDSIZ;
a2143 1
				uiop->uio_offset += tlen;
d2155 7
a2161 3
				cookie.nfsuquad[0] = *tl++;
				if (v3)
					cookie.nfsuquad[1] = *tl++;
a2185 1
		uiop->uio_offset += left;
d2193 4
a2196 3
	if (bigenough)
		dnp->n_direofoffset = uiop->uio_offset;
	else {
a2198 2
		cookiep = nfs_getcookie(dnp, uiop->uio_offset, 1);
		*cookiep = cookie;
d2200 1
d2209 2
a2210 4
nfs_readdirplusrpc(vp, uiop, cred)
	struct vnode *vp;
	register struct uio *uiop;
	struct ucred *cred;
d2213 1
a2218 1
	register nfsuint64 *cookiep;
d2232 1
a2232 1
	if (uiop->uio_iovcnt != 1 || (uiop->uio_offset & (NFS_DIRBLKSIZ - 1)) ||
d2239 3
a2241 9
	/*
	 * If there is no cookie, assume end of directory.
	 */
	cookiep = nfs_getcookie(dnp, uiop->uio_offset, 0);
	if (cookiep)
		cookie = *cookiep;
	else
		return (0);
	/*
d2254 8
a2261 2
		*tl++ = dnp->n_cookieverf.nfsuquad[0];
		*tl++ = dnp->n_cookieverf.nfsuquad[1];
d2285 1
a2285 3
			tlen = nfsm_rndup(len);
			if (tlen == len)
				tlen += 4;	/* To ensure null termination*/
d2287 1
a2287 1
			if ((tlen + DIRHDSIZ) > left) {
a2290 1
				uiop->uio_offset += left;
d2294 1
a2294 1
			if ((tlen + DIRHDSIZ) > uiop->uio_resid)
d2297 3
a2299 1
				dp = (struct dirent *)uiop->uio_iov->iov_base;
d2302 1
a2302 1
				dp->d_reclen = tlen + DIRHDSIZ;
d2307 3
a2309 4
				uiop->uio_offset += DIRHDSIZ;
				uiop->uio_resid -= DIRHDSIZ;
				uiop->uio_iov->iov_base += DIRHDSIZ;
				uiop->uio_iov->iov_len -= DIRHDSIZ;
a2317 1
				uiop->uio_offset += tlen;
d2323 2
a2324 2
				cookie.nfsuquad[0] = *tl++;
				cookie.nfsuquad[1] = *tl++;
a2403 1
		uiop->uio_offset += left;
d2411 4
a2414 3
	if (bigenough)
		dnp->n_direofoffset = uiop->uio_offset;
	else {
a2416 2
		cookiep = nfs_getcookie(dnp, uiop->uio_offset, 1);
		*cookiep = cookie;
d2418 1
@


1.30
log
@make kqueue behave like select
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.29 2001/02/24 19:07:11 csapuntz Exp $	*/
a107 1
	{ &vop_mmap_desc, nfs_mmap },		/* mmap */
a108 1
	{ &vop_seek_desc, nfs_seek },		/* seek */
a127 2
	{ &vop_blkatoff_desc, nfs_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, nfs_valloc },	/* valloc */
a128 3
	{ &vop_vfree_desc, nfs_vfree },		/* vfree */
	{ &vop_truncate_desc, nfs_truncate },	/* truncate */
	{ &vop_update_desc, nfs_update },	/* update */
a154 1
	{ &vop_mmap_desc, spec_mmap },		/* mmap */
a155 1
	{ &vop_seek_desc, spec_seek },		/* seek */
a174 2
	{ &vop_blkatoff_desc, spec_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, spec_valloc },	/* valloc */
a175 3
	{ &vop_vfree_desc, spec_vfree },	/* vfree */
	{ &vop_truncate_desc, spec_truncate },	/* truncate */
	{ &vop_update_desc, nfs_update },	/* update */
a199 1
	{ &vop_mmap_desc, fifo_mmap },		/* mmap */
a200 1
	{ &vop_seek_desc, fifo_seek },		/* seek */
a219 2
	{ &vop_blkatoff_desc, fifo_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, fifo_valloc },	/* valloc */
a220 3
	{ &vop_vfree_desc, fifo_vfree },	/* vfree */
	{ &vop_truncate_desc, fifo_truncate },	/* truncate */
	{ &vop_update_desc, nfs_update },	/* update */
a2588 22
 * Mmap a file
 *
 * NB Currently unsupported.
 */
/* ARGSUSED */
int
nfs_mmap(v)
	void *v;
{
#if 0
	struct vop_mmap_args /* {
		struct vnode *a_vp;
		int  a_fflags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
#endif

	return (EINVAL);
}

/*
a2867 100
}

/*
 * NFS directory offset lookup.
 * Currently unsupported.
 */
int
nfs_blkatoff(v)
	void *v;
{
#if 0
	struct vop_blkatoff_args /* {
		struct vnode *a_vp;
		off_t a_offset;
		char **a_res;
		struct buf **a_bpp;
	} */ *ap = v;
#endif

	return (EOPNOTSUPP);
}

/*
 * NFS flat namespace allocation.
 * Currently unsupported.
 */
int
nfs_valloc(v)
	void *v;
{
#if 0
	struct vop_valloc_args /* {
		struct vnode *a_pvp;
		int a_mode;
		struct ucred *a_cred;
		struct vnode **a_vpp;
	} */ *ap = v;
#endif

	return (EOPNOTSUPP);
}

/*
 * NFS flat namespace free.
 * Currently unsupported.
 */
int
nfs_vfree(v)
	void *v;
{
#if 0
	struct vop_vfree_args /* {
		struct vnode *a_pvp;
		ino_t a_ino;
		int a_mode;
	} */ *ap = v;
#endif

	return (EOPNOTSUPP);
}

/*
 * NFS file truncation.
 */
int
nfs_truncate(v)
	void *v;
{
#if 0
	struct vop_truncate_args /* {
		struct vnode *a_vp;
		off_t a_length;
		int a_flags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
#endif

	/* Use nfs_setattr */
	return (EOPNOTSUPP);
}

/*
 * NFS update.
 */
int
nfs_update(v)
	void *v;
#if 0
	struct vop_update_args /* {
		struct vnode *a_vp;
		struct timespec *a_ta;
		struct timespec *a_tm;
		int a_waitfor;
	} */ *ap = v;
#endif
{

	/* Use nfs_setattr */
	return (EOPNOTSUPP);
@


1.29
log
@

Cleanup of vnode interface continues. Get rid of VHOLD/HOLDRELE.
Change VM/UVM to use buf_replacevnode to change the vnode associated
with a buffer.

Addition v_bioflag for flags written in interrupt handlers
(and read at splbio, though not strictly necessary)

Add vwaitforio and use it instead of a while loop of v_numoutput.

Fix race conditions when manipulation vnode free list
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.28 2001/02/23 14:52:51 csapuntz Exp $	*/
d106 1
@


1.28
log
@

Change the B_DELWRI flag using buf_dirty and buf_undirty instead of
manually twiddling it. This allows the buffer cache to more easily
keep track of dirty buffers and decide when it is appropriate to speed
up the syncer.

Insipired by FreeBSD.
Look over by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.27 2001/02/09 22:26:05 mickey Exp $	*/
d2819 1
d2821 4
a2824 7
		while (vp->v_numoutput) {
			vp->v_flag |= VBWAIT;
			error = tsleep((caddr_t)&vp->v_numoutput,
				slpflag | (PRIBIO + 1), "nfsfsync", slptimeo);
			if (error) {
                            splx(s);
			    if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
d2826 1
a2826 1
			    if (slpflag == PCATCH) {
a2828 2
			    }
			    s = splbio();
d2830 1
a2831 1
		splx(s);
@


1.27
log
@use correct FREE() do dispose sillyrename on fail; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.26 2000/02/02 04:59:07 millert Exp $	*/
d2765 1
d2768 1
a2768 1
			    bp->b_flags &= ~(B_READ|B_DONE|B_ERROR|B_DELWRI);
a2769 1
			    reassignbuf(bp, vp);
d3052 1
a3052 1
	bp->b_flags &= ~(B_READ|B_DONE|B_ERROR|B_DELWRI);
d3055 5
a3059 7
	if (oldflags & B_ASYNC) {
		if (oldflags & B_DELWRI) {
			reassignbuf(bp, bp->b_vp);
		} else if (p) {
			++p->p_stats->p_ru.ru_oublock;
		}
	}
d3089 1
a3089 5
		if (oldflags & B_DELWRI) {
		        s = splbio();
			reassignbuf(bp, bp->b_vp);
			splx(s);
		} else if (p) {
@


1.26
log
@o Don't call nfs_sillyrename() form nfs_remove if v_type == VDIR
  (from FreeBSD).  This avoids the panic described below.
o In nfs_sillyrename(), change a panic if v_type == VDIR to just
  a printf (ifdef DIAGNOSTIC) and return EINVAL.
o When building the .nfs file in nfs_sillyrename() don't assume a pid
  is only 4 chars long since PID_MAX is 5 chars and use sprintf()
  instead of converting the pid to ascii by hand.
Thanks to Theo for assistance and sanity checking.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.25 1999/02/26 03:16:26 art Exp $	*/
d2417 1
a2417 1
	free((caddr_t)sp, M_NFSREQ);
@


1.26.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.29 2001/02/24 19:07:11 csapuntz Exp $	*/
d2417 1
a2417 1
	FREE((caddr_t)sp, M_NFSREQ);
a2764 1
			    buf_undirty(bp);
d2767 1
a2767 1
			    bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
d2769 1
a2818 1
 loop2:
d2820 7
a2826 4
		error = vwaitforio(vp, slpflag, "nfs_fsync", slptimeo);
		splx(s);
		if (error) {
			if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
d2828 1
a2828 1
			if (slpflag == PCATCH) {
d2831 2
a2833 1
			goto loop2;
d2835 1
d3052 1
a3052 1
	bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
d3055 7
a3061 5
	buf_undirty(bp);

	if ((oldflags & B_ASYNC) && !(oldflags & B_DELWRI) && p)
		++p->p_stats->p_ru.ru_oublock;

d3091 5
a3095 1
		if (!(oldflags & B_DELWRI) && p) {
@


1.26.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.26.2.1 2001/05/14 22:44:58 niklas Exp $	*/
d76 1
a105 1
	{ &vop_kqfilter_desc, vop_generic_kqfilter },	/* kqfilter */
d107 1
d109 1
d129 2
d132 3
d161 1
d163 1
d183 2
d186 3
d213 1
d215 1
d235 2
d238 3
d257 1
d388 1
d398 10
a407 4

	if (np->n_flag & NMODIFIED) {
		if ((error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred,
			 ap->a_p, 1)) == EINTR)
d409 13
a421 8
		uvm_vnp_uncache(vp);
		np->n_attrstamp = 0;
		if (vp->v_type == VDIR)
			np->n_direofoffset = 0;
		error = VOP_GETATTR(vp, &vattr, ap->a_cred, ap->a_p);
		if (error)
			return (error);
		np->n_mtime = vattr.va_mtime.tv_sec;
d423 10
a432 4
		error = VOP_GETATTR(vp, &vattr, ap->a_cred, ap->a_p);
		if (error)
			return (error);
		if (np->n_mtime != vattr.va_mtime.tv_sec) {
d435 2
a436 2
			if ((error = nfs_vinvalbuf(vp, V_SAVE,
				 ap->a_cred, ap->a_p, 1)) == EINTR)
a437 1
			uvm_vnp_uncache(vp);
d439 17
d458 2
a459 1
	np->n_attrstamp = 0; /* For Open/Close consistency */
d489 3
d510 2
a511 1
	    if (np->n_flag & NMODIFIED) {
d637 1
d639 3
d652 1
d654 3
a1855 21

/*
 * The readdir logic below has a big design bug. It stores the NFS cookie in 
 * the returned uio->uio_offset but does not store the verifier (it cannot).
 * Instead, the code stores the verifier in the nfsnode and applies that
 * verifies to all cookies, no matter what verifier was originally with
 * the cookie.
 *
 * From a practical standpoint, this is not a problem since almost all
 * NFS servers do not change the validity of cookies across deletes
 * and inserts.
 */

struct nfs_dirent {
	u_int32_t cookie[2];
	struct dirent dirent;
};

#define	NFS_DIRHDSIZ    (sizeof (struct nfs_dirent) - (MAXNAMLEN + 1))
#define NFS_DIRENT_OVERHEAD  offsetof(struct nfs_dirent, dirent)

d1868 2
a1869 2
		u_long **a_cookies;
		int *a_ncookies;
d1871 5
a1875 3
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct uio *uio = ap->a_uio;
a1877 10
	u_long *cookies = NULL;
	int ncookies = 0, cnt;
	u_int64_t  newoff = uio->uio_offset;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	struct uio readdir_uio;
	struct iovec readdir_iovec;
	struct proc * p = uio->uio_procp;
	int done = 0, eof = 0;
	struct ucred *cred = ap->a_cred;
	void *data;
d1884 10
a1893 4
	if (np->n_direofoffset != 0 && 
	    uio->uio_offset == np->n_direofoffset) {
		if (VOP_GETATTR(vp, &vattr, ap->a_cred, uio->uio_procp) == 0 &&
		    np->n_mtime == vattr.va_mtime.tv_sec) {
d1900 3
a1902 3
	if (uio->uio_resid < NFS_FABLKSIZE)
		return (EINVAL);

d1904 1
d1906 5
a1910 2
	if (uio->uio_rw != UIO_READ)
		return (EINVAL);
d1912 6
a1917 2
	if (ap->a_cookies) {
		ncookies = uio->uio_resid / 20;
d1921 2
a1922 3
		*ap->a_ncookies = ncookies;
		*ap->a_cookies = cookies;
	}
d1924 9
a1932 47
	if ((nmp->nm_flag & (NFSMNT_NFSV3 | NFSMNT_GOTFSINFO)) == NFSMNT_NFSV3)
		(void)nfs_fsinfo(nmp, vp, cred, p);

	cnt = 5;

	MALLOC(data, void *, NFS_DIRBLKSIZ, M_TEMP, 
	    M_WAITOK);

	do {
		struct nfs_dirent *ndp = data;

		readdir_iovec.iov_len = NFS_DIRBLKSIZ;
		readdir_iovec.iov_base = data;
		readdir_uio.uio_offset = newoff;
		readdir_uio.uio_iov = &readdir_iovec;
		readdir_uio.uio_iovcnt = 1;
		readdir_uio.uio_segflg = UIO_SYSSPACE;
		readdir_uio.uio_rw = UIO_READ;
		readdir_uio.uio_resid = NFS_DIRBLKSIZ;

		if (nmp->nm_flag & NFSMNT_RDIRPLUS) {
			error = nfs_readdirplusrpc(vp, &readdir_uio, cred, 
			    &eof);
			if (error == NFSERR_NOTSUPP)
				nmp->nm_flag &= ~NFSMNT_RDIRPLUS;
		}
		if ((nmp->nm_flag & NFSMNT_RDIRPLUS) == 0)
			error = nfs_readdirrpc(vp, &readdir_uio, cred, &eof);

		if (error == NFSERR_BAD_COOKIE)
			error = EINVAL;

		while (error == 0 && 
		    (ap->a_cookies == NULL || ncookies != 0) &&
		    ndp < (struct nfs_dirent *)readdir_iovec.iov_base) {
			struct dirent *dp = &ndp->dirent;
			int reclen = dp->d_reclen;

			dp->d_reclen -= NFS_DIRENT_OVERHEAD;

			if (uio->uio_resid < dp->d_reclen) {
				done = 1;
				break;
			}

			error = uiomove((caddr_t)dp, dp->d_reclen, uio);
			if (error) 
d1934 3
a1936 10
			
			newoff = fxdr_hyper(&ndp->cookie[0]);
			
			if (ap->a_cookies != NULL) {
				*cookies = newoff;
				cookies++;
				ncookies--;
			}

			ndp = (struct nfs_dirent *)((u_int8_t *)ndp + reclen);
a1937 17
	} while (!error && !done && !eof && cnt--);
	
	FREE(data, M_TEMP);
	data = NULL;
	
	if (ap->a_cookies) {
		if (error) {
			FREE(*ap->a_cookies, M_TEMP); 
			*ap->a_cookies = NULL;
			*ap->a_ncookies = 0;
		} else {
			*ap->a_ncookies -= ncookies;
		}
	}
	
	if (!error) 
		uio->uio_offset = newoff;
d1939 4
a1942 4
	if (!error && (eof || uio->uio_resid == tresid)) {
		nfsstats.direofcache_misses++;
		*ap->a_eofflag = 1;
		return (0);
a1948 5

/*
 * The function below stuff the cookies in after the name
 */

d1951 1
d1954 4
a1957 4
nfs_readdirrpc(struct vnode *vp, 
    struct uio *uiop, 
    struct ucred *cred,
    int *end_of_directory)
a1959 1
	struct nfs_dirent *ndp = NULL;
d1964 1
d1976 1
a1976 1
	if (uiop->uio_iovcnt != 1 || 
d1981 8
a1988 2
	txdr_hyper(uiop->uio_offset, &cookie.nfsuquad[0]);

d2003 2
a2004 8
			if (cookie.nfsuquad[0] == 0 &&
			    cookie.nfsuquad[1] == 0) {
				*tl++ = 0;
				*tl++ = 0;
			} else {
				*tl++ = dnp->n_cookieverf.nfsuquad[0];
				*tl++ = dnp->n_cookieverf.nfsuquad[1];
			}
d2007 1
a2007 1
			*tl++ = cookie.nfsuquad[1];
d2044 3
a2046 1
			tlen = nfsm_rndup(len + 1);
d2048 1
a2048 1
			if ((tlen + NFS_DIRHDSIZ) > left) {
d2052 1
d2056 1
a2056 1
			if ((tlen + NFS_DIRHDSIZ) > uiop->uio_resid)
d2059 1
a2059 3
				ndp = (struct nfs_dirent *)
				    uiop->uio_iov->iov_base;
				dp = &ndp->dirent;
d2062 1
a2062 1
				dp->d_reclen = tlen + NFS_DIRHDSIZ;
d2067 4
a2070 3
				uiop->uio_resid -= NFS_DIRHDSIZ;
				uiop->uio_iov->iov_base += NFS_DIRHDSIZ;
				uiop->uio_iov->iov_len -= NFS_DIRHDSIZ;
d2077 1
d2089 3
a2091 7
				if (v3) {
					ndp->cookie[0] = cookie.nfsuquad[0] =
					    *tl++;
				} else
					ndp->cookie[0] = 0;

				ndp->cookie[1] = cookie.nfsuquad[1] = *tl++;
d2116 1
d2124 3
a2126 4
	if (bigenough) {
		dnp->n_direofoffset = fxdr_hyper(&cookie.nfsuquad[0]);
		if (end_of_directory) *end_of_directory = 1;
	} else {
d2129 2
a2131 1

d2140 4
a2143 2
nfs_readdirplusrpc(struct vnode *vp, struct uio *uiop, struct ucred *cred, 
    int *end_of_directory)
a2145 1
	struct nfs_dirent *ndirp = NULL;
d2151 1
d2165 1
a2165 1
	if (uiop->uio_iovcnt != 1 || 
d2172 9
a2180 3
	txdr_hyper(uiop->uio_offset, &cookie.nfsuquad[0]);
	
        /*
d2193 2
a2194 8
		if (cookie.nfsuquad[0] == 0 &&
		    cookie.nfsuquad[1] == 0) {
			*tl++ = 0;
			*tl++ = 0;
		} else {
			*tl++ = dnp->n_cookieverf.nfsuquad[0];
			*tl++ = dnp->n_cookieverf.nfsuquad[1];
		}
d2218 3
a2220 1
			tlen = nfsm_rndup(len + 1);
d2222 1
a2222 1
			if ((tlen + NFS_DIRHDSIZ) > left) {
d2226 1
d2230 1
a2230 1
			if ((tlen + NFS_DIRHDSIZ) > uiop->uio_resid)
d2233 1
a2233 3
				ndirp = (struct nfs_dirent *)
				    uiop->uio_iov->iov_base;
				dp = &ndirp->dirent;
d2236 1
a2236 1
				dp->d_reclen = tlen + NFS_DIRHDSIZ;
d2241 4
a2244 3
				uiop->uio_resid -= NFS_DIRHDSIZ;
				uiop->uio_iov->iov_base += NFS_DIRHDSIZ;
				uiop->uio_iov->iov_len -= NFS_DIRHDSIZ;
d2253 1
d2259 2
a2260 2
				ndirp->cookie[0] = cookie.nfsuquad[0] = *tl++;
				ndirp->cookie[1] = cookie.nfsuquad[1] = *tl++;
d2340 1
d2348 3
a2350 4
	if (bigenough) {
		dnp->n_direofoffset = fxdr_hyper(&cookie.nfsuquad[0]);
		if (end_of_directory) *end_of_directory = 1;
	} else {
d2353 2
a2355 1

d2609 22
d2910 100
@


1.26.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.26.2.2 2001/07/04 10:55:52 niklas Exp $	*/
a1889 1
		readdir_uio.uio_procp = curproc;
@


1.26.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
#include <uvm/uvm_extern.h>
@


1.26.2.5
log
@Merge in -current
@
text
@d129 1
a129 3
	{ &vop_getpages_desc, nfs_getpages },		/* getpages */
	{ &vop_putpages_desc, nfs_putpages },		/* putpages */
	{ NULL, NULL }
d154 1
a154 1
	{ &vop_fsync_desc, spec_fsync },	/* fsync */
a375 20
	/*
	 * Initialize read and write creds here, for swapfiles
	 * and other paths that don't set the creds themselves.
	 */

	if (ap->a_mode & FREAD) {
		if (np->n_rcred) {
			crfree(np->n_rcred);
		}
		np->n_rcred = ap->a_cred;
		crhold(np->n_rcred);
	}
	if (ap->a_mode & FWRITE) {
		if (np->n_wcred) {
			crfree(np->n_wcred);
		}
		np->n_wcred = ap->a_cred;
		crhold(np->n_wcred);
	}

d380 1
d398 1
d597 2
a598 2
	struct vnode *vp;
	struct vattr *vap;
d880 2
a881 2
nfs_readrpc(vp, uiop)
	struct vnode *vp;
d883 1
d885 3
a887 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d915 1
a915 2
		nfsm_request(vp, NFSPROC_READ, uiop->uio_procp,
		    VTONFS(vp)->n_rcred);
d944 4
a947 3
nfs_writerpc(vp, uiop, iomode, must_commit)
	struct vnode *vp;
	struct uio *uiop;
d950 3
a952 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2, backup;
d994 1
a994 2
		nfsm_request(vp, NFSPROC_WRITE, uiop->uio_procp,
		    VTONFS(vp)->n_wcred);
d2511 2
a2512 2
nfs_commit(vp, offset, cnt, procp)
	struct vnode *vp;
d2514 2
a2515 1
	unsigned cnt;
d2518 4
a2521 4
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1, t2;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
d2535 1
a2535 1
	nfsm_request(vp, NFSPROC_COMMIT, procp, VTONFS(vp)->n_wcred);
d2590 2
a2591 1
	struct buf *bp = ap->a_bp;
d2598 1
a2598 1
		p = NULL;
d2601 4
d2610 3
a2612 2
	if ((bp->b_flags & B_ASYNC) == 0 || nfs_asyncio(bp))
		error = nfs_doio(bp, p);
d2636 3
a2638 1
 * Flush all the data associated with a vnode.
d2642 1
a2642 1
	struct vnode *vp;
d2648 88
a2735 5
	struct uvm_object *uobj = &vp->v_uvm.u_obj;
	struct nfsnode *np = VTONFS(vp);
	int error;
	int flushflags = PGO_ALLPAGES|PGO_CLEANIT|PGO_SYNCIO;
	int rv;
d2737 24
a2760 1
	error = 0;
d2762 63
a2824 5
	simple_lock(&uobj->vmobjlock);
	rv = (uobj->pgops->pgo_flush)(uobj, 0, 0, flushflags);
	simple_unlock(&uobj->vmobjlock);
	if (!rv) {
		error = EIO;
d2899 1
a2899 1
 * Just call bwrite().
d2909 70
a2978 1
	return (bwrite(ap->a_bp));
@


1.26.2.6
log
@Merge in trunk
@
text
@d129 3
a131 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d156 1
a156 1
	{ &vop_fsync_desc, nfs_fsync },		/* fsync */
d274 4
a277 4
	struct vnode *vp = ap->a_vp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d366 1
a366 1
	struct vnode *vp = ap->a_vp;
a401 1
		uvm_vnp_uncache(vp);
a418 1
			uvm_vnp_uncache(vp);
d465 2
a466 2
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
d499 5
a503 5
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1, t2;
d543 3
a545 3
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct vattr *vap = ap->a_vap;
d622 3
a624 3
	struct nfsv2_sattr *sp;
	caddr_t cp;
	int32_t t1, t2;
d680 3
a682 3
	struct componentname *cnp = ap->a_cnp;
	struct vnode *dvp = ap->a_dvp;
	struct vnode **vpp = ap->a_vpp;
d684 5
a688 5
	int flags = cnp->cn_flags;
	struct vnode *newvp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d837 1
a837 1
	struct vnode *vp = ap->a_vp;
d856 1
a856 1
	struct vnode *vp = ap->a_vp;
d869 1
a869 1
	struct vnode *vp;
d873 3
a875 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1000 1
a1000 1
			u_int32_t x;
d1076 9
a1084 9
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
{
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1197 7
a1203 7
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1232 2
a1233 2
			if (TAILQ_FIRST(&in_ifaddr))
				*tl++ = TAILQ_FIRST(&in_ifaddr)->ia_addr.sin_addr.s_addr;
d1310 4
a1313 4
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct nfsnode *np = VTONFS(vp);
d1367 1
a1367 1
	struct sillyrename *sp;
d1379 1
a1379 1
	struct vnode *dvp;
d1385 3
a1387 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1423 6
a1428 6
	struct vnode *fvp = ap->a_fvp;
	struct vnode *tvp = ap->a_tvp;
	struct vnode *fdvp = ap->a_fdvp;
	struct vnode *tdvp = ap->a_tdvp;
	struct componentname *tcnp = ap->a_tcnp;
	struct componentname *fcnp = ap->a_fcnp;
d1486 1
a1486 1
	struct sillyrename *sp;
d1497 1
a1497 1
	struct vnode *fdvp;
d1500 1
a1500 1
	struct vnode *tdvp;
d1506 3
a1508 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1549 6
a1554 6
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1618 7
a1624 7
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1684 8
a1691 8
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
	int len;
d1765 6
a1770 6
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d1993 1
a1993 1
	int len, left;
d1995 4
a1998 4
	struct dirent *dp = NULL;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d2177 1
a2177 1
	int len, left;
d2179 5
a2183 5
	struct dirent *dp = NULL;
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
	struct vnode *newvp;
d2403 1
a2403 1
	struct sillyrename *sp;
d2459 1
a2459 1
	struct vnode *dvp;
d2466 3
a2468 3
	u_int32_t *tl;
	caddr_t cp;
	int32_t t1, t2;
d2534 1
a2534 1
	int cnt;
d2589 1
a2589 1
	struct vnode *vp = ap->a_vp;
d2649 1
a2649 3
 * Flush all the blocks associated with a vnode.
 * 	Walk through the buffer pool and push any dirty pages
 *	associated with the vnode.
d2659 1
d2661 3
a2663 11
	struct buf *bp;
	int i;
	struct buf *nbp;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	int s, error = 0, slptimeo = 0, slpflag = 0, retv, bvecpos;
	int passone = 1;
	u_quad_t off = (u_quad_t)-1, endoff = 0, toff;
#ifndef NFS_COMMITBVECSIZ
#define NFS_COMMITBVECSIZ	20
#endif
	struct buf *bvec[NFS_COMMITBVECSIZ];
d2665 1
a2665 71
	if (nmp->nm_flag & NFSMNT_INT)
		slpflag = PCATCH;
	if (!commit)
		passone = 0;
	/*
	 * A b_flags == (B_DELWRI | B_NEEDCOMMIT) block has been written to the
	 * server, but nas not been committed to stable storage on the server
	 * yet. On the first pass, the byte range is worked out and the commit
	 * rpc is done. On the second pass, nfs_writebp() is called to do the
	 * job.
	 */
again:
	bvecpos = 0;
	if (NFS_ISV3(vp) && commit) {
		s = splbio();
		for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp != NULL; bp = nbp) {
			nbp = LIST_NEXT(bp, b_vnbufs);
			if (bvecpos >= NFS_COMMITBVECSIZ)
				break;
			if ((bp->b_flags & (B_BUSY | B_DELWRI | B_NEEDCOMMIT))
				!= (B_DELWRI | B_NEEDCOMMIT))
				continue;
			bremfree(bp);
			bp->b_flags |= (B_BUSY | B_WRITEINPROG);
			/*
			 * A list of these buffers is kept so that the
			 * second loop knows which buffers have actually
			 * been committed. This is necessary, since there
			 * may be a race between the commit rpc and new
			 * uncommitted writes on the file.
			 */
			bvec[bvecpos++] = bp;
			toff = ((u_quad_t)bp->b_blkno) * DEV_BSIZE +
				bp->b_dirtyoff;
			if (toff < off)
				off = toff;
			toff += (u_quad_t)(bp->b_dirtyend - bp->b_dirtyoff);
			if (toff > endoff)
				endoff = toff;
		}
		splx(s);
	}
	if (bvecpos > 0) {
		/*
		 * Commit data on the server, as required.
		 */
		retv = nfs_commit(vp, off, (int)(endoff - off), p);
		if (retv == NFSERR_STALEWRITEVERF)
			nfs_clearcommit(vp->v_mount);
		/*
		 * Now, either mark the blocks I/O done or mark the
		 * blocks dirty, depending on whether the commit
		 * succeeded.
		 */
		for (i = 0; i < bvecpos; i++) {
			bp = bvec[i];
			bp->b_flags &= ~(B_NEEDCOMMIT | B_WRITEINPROG);
			if (retv)
			    brelse(bp);
			else {
			    s = splbio();
			    buf_undirty(bp);
			    vp->v_numoutput++;
			    bp->b_flags |= B_ASYNC;
			    bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
			    bp->b_dirtyoff = bp->b_dirtyend = 0;
			    splx(s);
			    biodone(bp);
			}
		}
	}
d2667 5
a2671 63
	/*
	 * Start/do any write(s) that are required.
	 */
loop:
	s = splbio();
	for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp != NULL; bp = nbp) {
		nbp = LIST_NEXT(bp, b_vnbufs);
		if (bp->b_flags & B_BUSY) {
			if (waitfor != MNT_WAIT || passone)
				continue;
			bp->b_flags |= B_WANTED;
			error = tsleep((caddr_t)bp, slpflag | (PRIBIO + 1),
				"nfsfsync", slptimeo);
			splx(s);
			if (error) {
			    if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
				return (EINTR);
			    if (slpflag == PCATCH) {
				slpflag = 0;
				slptimeo = 2 * hz;
			    }
			}
			goto loop;
		}
		if ((bp->b_flags & B_DELWRI) == 0)
			panic("nfs_fsync: not dirty");
		if ((passone || !commit) && (bp->b_flags & B_NEEDCOMMIT))
			continue;
		bremfree(bp);
		if (passone || !commit)
		    bp->b_flags |= (B_BUSY|B_ASYNC);
		else
		    bp->b_flags |= (B_BUSY|B_ASYNC|B_WRITEINPROG|B_NEEDCOMMIT);
		splx(s);
		VOP_BWRITE(bp);
		goto loop;
	}
	splx(s);
	if (passone) {
		passone = 0;
		goto again;
	}
	if (waitfor == MNT_WAIT) {
 loop2:
	        s = splbio();
		error = vwaitforio(vp, slpflag, "nfs_fsync", slptimeo);
		splx(s);
		if (error) {
			if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
				return (EINTR);
			if (slpflag == PCATCH) {
				slpflag = 0;
				slptimeo = 2 * hz;
			}
			goto loop2;
		}

		if (LIST_FIRST(&vp->v_dirtyblkhd) && commit) {
#if 0
			vprint("nfs_fsync: dirty", vp);
#endif
			goto loop;
		}
d2716 1
a2716 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2732 2
a2733 2
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
d2746 1
a2746 1
 * Just call nfs_writebp() with the force argument set to 1.
d2756 1
a2756 70
	return (nfs_writebp(ap->a_bp, 1));
}

/*
 * This is a clone of vop_generic_bwrite(), except that B_WRITEINPROG isn't set unless
 * the force flag is one and it also handles the B_NEEDCOMMIT flag.
 */
int
nfs_writebp(bp, force)
	struct buf *bp;
	int force;
{
	int oldflags = bp->b_flags, retv = 1;
	struct proc *p = curproc;	/* XXX */
	off_t off;
	int   s;

	if(!(bp->b_flags & B_BUSY))
		panic("bwrite: buffer is not busy???");

#ifdef fvdl_debug
	printf("nfs_writebp(%x): vp %x voff %d vend %d doff %d dend %d\n",
	    bp, bp->b_vp, bp->b_validoff, bp->b_validend, bp->b_dirtyoff,
	    bp->b_dirtyend);
#endif
	bp->b_flags &= ~(B_READ|B_DONE|B_ERROR);

	s = splbio();
	buf_undirty(bp);

	if ((oldflags & B_ASYNC) && !(oldflags & B_DELWRI) && p)
		++p->p_stats->p_ru.ru_oublock;

	bp->b_vp->v_numoutput++;
	splx(s);

	/*
	 * If B_NEEDCOMMIT is set, a commit rpc may do the trick. If not
	 * an actual write will have to be scheduled via. VOP_STRATEGY().
	 * If B_WRITEINPROG is already set, then push it with a write anyhow.
	 */
	if ((oldflags & (B_NEEDCOMMIT | B_WRITEINPROG)) == B_NEEDCOMMIT) {
		off = ((u_quad_t)bp->b_blkno) * DEV_BSIZE + bp->b_dirtyoff;
		bp->b_flags |= B_WRITEINPROG;
		retv = nfs_commit(bp->b_vp, off, bp->b_dirtyend-bp->b_dirtyoff,
			bp->b_proc);
		bp->b_flags &= ~B_WRITEINPROG;
		if (!retv) {
			bp->b_dirtyoff = bp->b_dirtyend = 0;
			bp->b_flags &= ~B_NEEDCOMMIT;
			biodone(bp);
		} else if (retv == NFSERR_STALEWRITEVERF)
			nfs_clearcommit(bp->b_vp->v_mount);
	}
	if (retv) {
		if (force)
			bp->b_flags |= B_WRITEINPROG;
		VOP_STRATEGY(bp);
	}

	if( (oldflags & B_ASYNC) == 0) {
		int rtval = biowait(bp);
		if (!(oldflags & B_DELWRI) && p) {
			++p->p_stats->p_ru.ru_oublock;
		}
		brelse(bp);
		return (rtval);
	} 

	return (0);
d2815 1
a2815 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2839 1
a2839 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2865 2
a2866 2
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
d2899 1
a2899 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2924 1
a2924 1
	struct nfsnode *np = VTONFS(ap->a_vp);
d2950 2
a2951 2
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
@


1.26.2.7
log
@Merge in -current from roughly a week ago
@
text
@d89 1
a89 1
int (**nfsv2_vnodeop_p)(void *);
d129 1
a129 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d137 1
a137 1
int (**spec_nfsv2nodeop_p)(void *);
d176 1
a176 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d182 1
a182 1
int (**fifo_nfsv2nodeop_p)(void *);
d221 1
a221 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d3104 1
a3104 1
	extern int (**fifo_vnodeop_p)(void *);
d3129 1
a3129 1
	extern int (**fifo_vnodeop_p)(void *);
d3159 1
a3159 1
	extern int (**fifo_vnodeop_p)(void *);
@


1.26.2.8
log
@Sync the SMP branch with 3.3
@
text
@d129 1
a129 1
	{ NULL, NULL }
d139 5
a143 1
	{ &vop_default_desc, spec_vnoperate },
d150 4
d155 9
d168 2
d172 5
a176 1
	{ NULL, NULL }
d184 5
a188 1
	{ &vop_default_desc, fifo_vnoperate },
d195 4
d200 9
d213 2
d217 3
d221 1
a221 1
	{ NULL, NULL }
d684 1
a684 1
	int flags;
a697 3
	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

d708 1
a708 11

	/*
	 * Before tediously performing a linear scan of the directory,
	 * check the name cache to see if the directory/name pair
	 * we are looking for is known already.
	 * If the directory/name pair is found in the name cache,
	 * we have to ensure the directory has not changed from
	 * the time the cache entry has been created. If it has,
	 * the cache entry has to be ignored.
	 */
	if ((error = cache_lookup(dvp, vpp, cnp)) >= 0) {
d710 1
a710 1
		int err2;
d712 11
a722 4
		if (error && error != ENOENT) {
			*vpp = NULLVP;
			return (error);
		}
d724 13
a736 29
		if (cnp->cn_flags & PDIRUNLOCK) {
			err2 = vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p);
			if (err2 != 0) {
				*vpp = NULLVP;
				return (err2);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}

		err2 = VOP_ACCESS(dvp, VEXEC, cnp->cn_cred, cnp->cn_proc);
		if (err2 != 0) {
			if (error == 0) {
				if (*vpp != dvp)
					vput(*vpp);
				else
					vrele(*vpp);
			}
			*vpp = NULLVP;
			return (err2);
		}

		if (error == ENOENT) {
			if (!VOP_GETATTR(dvp, &vattr, cnp->cn_cred,
			    cnp->cn_proc) && vattr.va_mtime.tv_sec ==
			    VTONFS(dvp)->n_ctime)
				return (ENOENT);
			cache_purge(dvp);
			np->n_ctime = 0;
			goto dorpc;
a737 18

		newvp = *vpp;
		if (!VOP_GETATTR(newvp, &vattr, cnp->cn_cred, cnp->cn_proc)
			&& vattr.va_ctime.tv_sec == VTONFS(newvp)->n_ctime)
		{
			nfsstats.lookupcache_hits++;
			if (cnp->cn_nameiop != LOOKUP && (flags & ISLASTCN))
				cnp->cn_flags |= SAVENAME;
			if ((!lockparent || !(flags & ISLASTCN)) &&
			     newvp != dvp)
				VOP_UNLOCK(dvp, 0, p);
			return (0);
		}
		cache_purge(newvp);
		if (newvp != dvp)
			vput(newvp);
		else
			vrele(newvp);
a739 1
dorpc:
a778 4
		if (!lockparent) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
a781 6
	/*
	 * The postop attr handling is duplicated for each if case,
	 * because it should be done while dvp is locked (unlocking
	 * dvp is different for each case).
	 */

d785 1
a785 9
		if (v3) {
			nfsm_postop_attr(newvp, attrflag);
			nfsm_postop_attr(dvp, attrflag);
		} else
			nfsm_loadattr(newvp, (struct vattr *)0);
	} else if (flags & ISDOTDOT) {
		VOP_UNLOCK(dvp, 0, p);
		cnp->cn_flags |= PDIRUNLOCK;

a787 2
			if (vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
a791 32

		if (v3) {
			nfsm_postop_attr(newvp, attrflag);
			nfsm_postop_attr(dvp, attrflag);
		} else
			nfsm_loadattr(newvp, (struct vattr *)0);

		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(dvp, LK_EXCLUSIVE, p))) {
				m_freem(mrep);
				vput(newvp);
				return error;
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}

	} else {
		error = nfs_nget(dvp->v_mount, fhp, fhsize, &np);
		if (error) {
			m_freem(mrep);
			return error;
		}
		newvp = NFSTOV(np);
		if (v3) {
			nfsm_postop_attr(newvp, attrflag);
			nfsm_postop_attr(dvp, attrflag);
		} else
			nfsm_loadattr(newvp, (struct vattr *)0);
		if (!lockparent || !(flags & ISLASTCN)) {
			VOP_UNLOCK(dvp, 0, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
d793 5
d808 1
a808 14
		/*
		 * We get here only because of errors returned by
		 * the RPC. Otherwise we'll have returned above
		 * (the nfsm_* macros will jump to nfsm_reqdone
		 * on error).
		 */
		if (error == ENOENT && (cnp->cn_flags & MAKEENTRY) &&
		    cnp->cn_nameiop != CREATE) {
			if (VTONFS(dvp)->n_ctime == 0)
				VTONFS(dvp)->n_ctime =
				    VTONFS(dvp)->n_vattr.va_mtime.tv_sec;
			cache_enter(dvp, NULL, cnp);
		}
		if (newvp != NULLVP) {
a809 3
			if (newvp != dvp)
				VOP_UNLOCK(newvp, 0, p);
		}
a818 1
		*vpp = NULL;
d2740 1
a2741 1
			    splx(s);
a2942 1
			s = splbio();
a2943 1
			splx(s);
@


1.26.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.26.2.8 2003/03/28 00:08:46 niklas Exp $	*/
d2484 1
a2484 2
	sp->s_namlen = snprintf(sp->s_name, sizeof sp->s_name,
	    ".nfsA%05x4.4", cnp->cn_proc->p_pid);
@


1.26.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.26.2.9 2003/05/13 19:36:57 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.26.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
a100 1
	{ &vop_poll_desc, nfs_poll },		/* poll */
@


1.26.2.12
log
@Merge with the trunk
@
text
@a47 1
#include <sys/poll.h>
a51 1
#include <sys/pool.h>
d166 1
a166 1
	{ &vop_reclaim_desc, nfsfifo_reclaim },	/* reclaim */
d1207 1
a1207 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1337 1
a1337 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1411 1
a1411 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1614 2
a1615 1
	int v3;
d1618 1
a1618 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
a1632 1
	v3 = NFS_ISV3(vp);
d1645 1
a1645 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1714 1
a1714 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1804 1
a1804 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d1835 1
a1835 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d1847 1
a1847 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
a3066 17
/* ARGSUSED */
int
nfs_poll(v)
        void *v;
{
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int  a_events;
		struct proc *a_p;
	} */ *ap = v;

	/*
	 * We should really check to see if I/O is possible.
	 */
	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}

a3240 7
}

int
nfsfifo_reclaim(void *v)
{
	fifo_reclaim(v);
	return (nfs_reclaim(v));
@


1.25
log
@compatibility with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.24 1999/02/06 23:07:46 millert Exp $	*/
d1372 3
a1374 1
	if (vp->v_usecount == 1 || (np->n_sillyrename &&
a2360 1
static char hextoasc[] = "0123456789abcdef";
a2377 1
	short pid;
a2380 4
#ifndef DIAGNOSTIC
	if (vp->v_type == VDIR)
		panic("nfs: sillyrename dir");
#endif
d2387 8
d2396 1
a2396 7
	pid = cnp->cn_proc->p_pid;
	bcopy(".nfsAxxxx4.4", sp->s_name, 13);
	sp->s_namlen = 12;
	sp->s_name[8] = hextoasc[pid & 0xf];
	sp->s_name[7] = hextoasc[(pid >> 4) & 0xf];
	sp->s_name[6] = hextoasc[(pid >> 8) & 0xf];
	sp->s_name[5] = hextoasc[(pid >> 12) & 0xf];
@


1.24
log
@Use bitwise operations to extract high and low words from the quad
in txdr_hyper.  This should be more portable than casting to an array
of ints and pulling out the two 32-bit words (this produced incorrect
results on alpha for the high word for filesystems < 4gig).  As a side
effect, txdr_hyper now takes a u_quad_t as its first arg, not u_quad_t *.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.23 1999/01/10 20:06:51 millert Exp $	*/
d414 3
d418 1
d427 3
d431 1
d449 3
d453 1
d637 3
d641 1
d652 3
d656 1
@


1.23
log
@Fix for creating files on a Solaris 7 server with NFSv3 (the request was
slightly garbled but older servers seemed to understand it); dfr@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.22 1998/08/19 22:26:57 csapuntz Exp $	*/
d957 1
a957 1
			txdr_hyper(&uiop->uio_offset, tl);
d1024 1
a1024 1
			txdr_hyper(&uiop->uio_offset, tl);
d2506 1
a2506 1
	txdr_hyper(&offset, tl);
@


1.22
log
@

Change fxdr_hyper to return a u_quad_t. This minimizes the evil clobbering
of lvalues that ANSI abhors.

And it fixes df on NFS version 3 mounts on Sparcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.21 1998/08/06 19:35:00 csapuntz Exp $	*/
d602 1
a602 1
			    vap->va_mode == (u_short)VNOVAL &&
d664 1
a664 58
		if (vap->va_mode != (u_short)VNOVAL) {
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			*tl++ = nfs_true;
			*tl = txdr_unsigned(vap->va_mode);
		} else {
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
			*tl = nfs_false;
		}
		if (vap->va_uid != (uid_t)VNOVAL) {
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			*tl++ = nfs_true;
			*tl = txdr_unsigned(vap->va_uid);
		} else {
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
			*tl = nfs_false;
		}
		if (vap->va_gid != (gid_t)VNOVAL) {
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			*tl++ = nfs_true;
			*tl = txdr_unsigned(vap->va_gid);
		} else {
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
			*tl = nfs_false;
		}
		if (vap->va_size != VNOVAL) {
			nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
			*tl++ = nfs_true;
			txdr_hyper(&vap->va_size, tl);
		} else {
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
			*tl = nfs_false;
		}
		if (vap->va_atime.tv_sec != VNOVAL) {
			if (vap->va_atime.tv_sec != time.tv_sec) {
				nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
				*tl++ = txdr_unsigned(NFSV3SATTRTIME_TOCLIENT);
				txdr_nfsv3time(&vap->va_mtime, tl);
			} else {
				nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
				*tl = txdr_unsigned(NFSV3SATTRTIME_TOSERVER);
			}
		} else {
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
			*tl = txdr_unsigned(NFSV3SATTRTIME_DONTCHANGE);
		}
		if (vap->va_mtime.tv_sec != VNOVAL) {
			if (vap->va_mtime.tv_sec != time.tv_sec) {
				nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
				*tl++ = txdr_unsigned(NFSV3SATTRTIME_TOCLIENT);
				txdr_nfsv3time(&vap->va_mtime, tl);
			} else {
				nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
				*tl = txdr_unsigned(NFSV3SATTRTIME_TOSERVER);
			}
		} else {
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
			*tl = txdr_unsigned(NFSV3SATTRTIME_DONTCHANGE);
		}
d669 1
a669 1
		if (vap->va_mode == (u_short)VNOVAL)
a1110 1
	register struct nfsv3_sattr *sp3;
d1138 1
a1138 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED + NFSX_V3SRVSATTR);
d1140 1
a1140 2
		sp3 = (struct nfsv3_sattr *)tl;
		nfsm_v3sattr(sp3, vap);
a1229 1
	register struct nfsv3_sattr *sp3;
d1259 7
a1265 7
		    *tl = txdr_unsigned(NFSV3CREATE_EXCLUSIVE);
		    nfsm_build(tl, u_int32_t *, NFSX_V3CREATEVERF);
		    if (in_ifaddr.tqh_first)
			*tl++ = in_ifaddr.tqh_first->ia_addr.sin_addr.s_addr;
		    else
			*tl++ = create_verf;
		    *tl = ++create_verf;
d1267 2
a1268 4
		    *tl = txdr_unsigned(NFSV3CREATE_UNCHECKED);
		    nfsm_build(tl, u_int32_t *, NFSX_V3SRVSATTR);
		    sp3 = (struct nfsv3_sattr *)tl;
		    nfsm_v3sattr(sp3, vap);
a1648 1
	register struct nfsv3_sattr *sp3;
d1664 2
a1665 4
	if (v3) {
		nfsm_build(sp3, struct nfsv3_sattr *, NFSX_V3SRVSATTR);
		nfsm_v3sattr(sp3, vap);
	}
a1714 1
	register struct nfsv3_sattr *sp3;
d1734 1
a1734 2
		nfsm_build(sp3, struct nfsv3_sattr *, NFSX_V3SRVSATTR);
		nfsm_v3sattr(sp3, vap);
@


1.21
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.20 1998/05/11 05:42:01 deraadt Exp $	*/
d2076 1
a2076 1
				fxdr_hyper(tl, &fileno);
d2256 1
a2256 1
			fxdr_hyper(tl, &fileno);
@


1.20
log
@compile if iov_base is void *
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.19 1997/12/02 16:57:59 csapuntz Exp $	*/
d118 1
a118 1
	{ &vop_abortop_desc, nfs_abortop },	/* abortop */
d189 1
a189 1
	{ &vop_bwrite_desc, vn_bwrite },
d241 1
a241 1
	{ &vop_bwrite_desc, vn_bwrite },
d3080 1
a3080 1
 * This is a clone of vn_bwrite(), except that B_WRITEINPROG isn't set unless
@


1.19
log
@More splbio()'s added so that reassignbuf can do its thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.18 1997/11/06 05:59:05 csapuntz Exp $	*/
d1962 1
a1962 1
		int ncookies = (uio->uio_iov->iov_base - base) / 12;
d1975 1
a1975 1
		while (ncookies-- && base < uio->uio_iov->iov_base) {
d1985 2
a1986 2
		uio->uio_resid += (uio->uio_iov->iov_base - base);
		uio->uio_iov->iov_len += (uio->uio_iov->iov_base - base);
d2095 1
a2095 1
				uiop->uio_iov->iov_base += left;
d2114 1
a2114 1
				uiop->uio_iov->iov_base += DIRHDSIZ;
d2120 1
a2120 1
				uiop->uio_iov->iov_base += tlen;
@


1.18
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.17 1997/10/06 20:20:54 deraadt Exp $	*/
d2813 1
d2819 1
d2868 1
d2874 1
d2881 1
d2884 2
d3091 1
d3103 1
d3112 1
d3141 1
d3143 1
@


1.17
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.15 1997/04/18 09:57:29 deraadt Exp $	*/
a105 1
#ifdef Lite2_integrated
a106 1
#endif
a159 1
#ifdef Lite2_integrated
a160 1
#endif
a211 1
#ifdef Lite2_integrated
a212 1
#endif
d769 1
a807 1
#ifdef Lite2_integrated
d809 1
a809 3
#else
			error = vget(newvp, 1);
#endif
d1959 9
a1967 2
		u_long *cookies = ap->a_cookies;
		int ncookies = ap->a_ncookies;
d1969 1
a1969 2
		/*
		 * Only the NFS server and emulations use cookies, and they
d1983 2
a2814 2
			    if (bp->b_flags & B_DELWRI)
				TAILQ_REMOVE(&bdirties, bp, b_synclist);
a3092 2
	if (bp->b_flags & B_DELWRI)
	    TAILQ_REMOVE(&bdirties, bp, b_synclist);
@


1.16
log
@VFS Lite2 Changes
@
text
@d106 1
d108 1
d162 1
d164 1
d216 1
d218 1
a774 1
	struct proc *p = cnp->cn_proc;
d813 1
d815 3
a817 1

d1967 2
a1968 9
		u_long *cookies;
		/* XXX - over-estimate - see UFS code for how to do it
		   right */
		int ncookies = (uio->uio_iov->iov_base - base) / 12;

		MALLOC(cookies, u_long *, sizeof(*cookies) * ncookies,
		       M_TEMP, M_WAITOK);
                *ap->a_ncookies = ncookies;
                *ap->a_cookies = cookies;
d1970 2
a1971 1
		/* Only the NFS server and emulations use cookies, and they
a1984 2

		*ap->a_ncookies -= ncookies;
d2815 2
d3095 2
@


1.15
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.14 1997/04/08 22:46:50 deraadt Exp $	*/
a105 1
#ifdef Lite2_integrated
a106 1
#endif
a159 1
#ifdef Lite2_integrated
a160 1
#endif
a211 1
#ifdef Lite2_integrated
a212 1
#endif
d769 1
a807 1
#ifdef Lite2_integrated
d809 1
a809 3
#else
			error = vget(newvp, 1);
#endif
d1959 9
a1967 2
		u_long *cookies = ap->a_cookies;
		int ncookies = ap->a_ncookies;
d1969 1
a1969 2
		/*
		 * Only the NFS server and emulations use cookies, and they
d1983 2
a2814 2
			    if (bp->b_flags & B_DELWRI)
				TAILQ_REMOVE(&bdirties, bp, b_synclist);
a3092 2
	if (bp->b_flags & B_DELWRI)
	    TAILQ_REMOVE(&bdirties, bp, b_synclist);
@


1.14
log
@chflags not permitted
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.13 1997/01/31 10:33:46 deraadt Exp $	*/
d1545 1
a1545 1
		tvp->v_type != VDIR && !nfs_sillyrename(tdvp, tvp, tcnp)) {
@


1.13
log
@do not sillyrename directories; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.12 1996/11/12 15:51:34 mickey Exp $	*/
d585 6
d593 1
a593 1
  	if ((vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
@


1.12
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.11 1996/07/27 11:08:48 deraadt Exp $	*/
d1539 1
a1539 1
		!nfs_sillyrename(tdvp, tvp, tcnp)) {
@


1.11
log
@use mtime for v3 setattr
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.10 1996/07/23 21:32:33 deraadt Exp $	*/
d3062 1
a3062 1
		struct vnode *a_bp;
@


1.10
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_vnops.c,v 1.9 1996/06/14 04:41:09 tholo Exp $	*/
/*	$NetBSD: nfs_vnops.c,v 1.62 1996/05/11 18:26:49 mycroft Exp $	*/
d713 1
a713 1
				txdr_nfsv3time(&vap->va_atime, tl);
@


1.9
log
@Keep dirty list used by in-kernel update(8) in sync with buffers
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.8 1996/05/22 11:47:16 deraadt Exp $	*/
d700 1
a700 1
				txdr_nfsv3time(&vap->va_atime, tl);
@


1.8
log
@Change VOP_UPDATE() semantics:
* Make 2nd and 3rd args timespecs, not timevals.
* Consistently pass a Boolean as the 4th arg (except in LFS).
Also, fix ffs_update() and lfs_update() to actually change the nsec fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.6 1996/04/17 04:50:35 mickey Exp $	*/
d2809 2
d3089 2
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: nfs_vnops.c,v 1.61 1996/04/03 23:25:42 thorpej Exp $	*/
d3041 2
a3042 2
		struct timeval *a_ta;
		struct timeval *a_tm;
@


1.6
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_vnops.c,v 1.5 1996/03/31 13:16:03 mickey Exp $	*/
/*	$NetBSD: nfs_vnops.c,v 1.60 1996/03/05 05:30:09 jtk Exp $	*/
d199 1
d252 1
a591 1

d615 5
a619 2
 			error = nfs_vinvalbuf(vp,
				((vap->va_size == 0)? 0 : V_SAVE),
a632 1

d746 1
a746 1
		nfsm_loadattr(vp, (struct vattr *)NULL);
d863 1
a863 1
			nfsm_loadattr(newvp, (struct vattr *)NULL);
d885 1
a885 1
		nfsm_loadattr(newvp, (struct vattr *)NULL);
d1033 1
a1033 1
			nfsm_loadattr(vp, (struct vattr *)NULL);
d1144 1
a1144 1
		    nfsm_loadattr(vp, (struct vattr *)NULL);
d1174 1
a1174 1
	struct vnode *newvp = NULL;
d1222 1
a1222 1
				newvp = (struct vnode *)NULL;
d1295 2
a1296 2
	struct nfsnode *np = NULL;
	struct vnode *newvp = NULL;
d1349 1
a1349 1
				newvp = (struct vnode *)NULL;
d1462 1
a1462 1
		(struct proc *)NULL));
d1720 1
a1720 1
	struct vnode *newvp = NULL;
d1787 2
a1788 2
	struct nfsnode *np = NULL;
	struct vnode *newvp = NULL;
d1829 1
a1829 1
			newvp = (struct vnode *)NULL;
d2335 1
a2335 1
				nfsm_loadattr(newvp, (struct vattr *)NULL);
d2443 1
a2443 1
		cnp->cn_proc, (struct nfsnode **)NULL) == 0) {
d2484 1
a2484 1
	struct vnode *newvp = NULL;
d2529 1
a2529 1
			nfsm_loadattr(newvp, (struct vattr *)NULL);
d2633 1
a2633 1
		p = (struct proc *)NULL;
d2832 1
a2832 1
			    if (nfs_sigintr(nmp, (struct nfsreq *)NULL, p))
d2865 1
a2865 1
			    if (nfs_sigintr(nmp, (struct nfsreq *)NULL, p))
d2944 1
d2947 1
d3261 1
d3354 1
@


1.5
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vnops.c,v 1.4 1996/02/29 09:24:59 niklas Exp $	*/
d590 1
d614 2
a615 2
 			if (vap->va_size == 0)
 				error = nfs_vinvalbuf(vp, 0,
a616 3
			else
				error = nfs_vinvalbuf(vp, V_SAVE,
				     ap->a_cred, ap->a_p, 1);
d629 1
d743 1
a743 1
		nfsm_loadattr(vp, (struct vattr *)0);
d860 1
a860 1
			nfsm_loadattr(newvp, (struct vattr *)0);
d882 1
a882 1
		nfsm_loadattr(newvp, (struct vattr *)0);
d1030 1
a1030 1
			nfsm_loadattr(vp, (struct vattr *)0);
d1141 1
a1141 1
		    nfsm_loadattr(vp, (struct vattr *)0);
d1171 1
a1171 1
	struct vnode *newvp = (struct vnode *)0;
d1219 1
a1219 1
				newvp = (struct vnode *)0;
d1292 2
a1293 2
	struct nfsnode *np = (struct nfsnode *)0;
	struct vnode *newvp = (struct vnode *)0;
d1346 1
a1346 1
				newvp = (struct vnode *)0;
d1459 1
a1459 1
		(struct proc *)0));
d1717 1
a1717 1
	struct vnode *newvp = (struct vnode *)0;
d1784 2
a1785 2
	struct nfsnode *np = (struct nfsnode *)0;
	struct vnode *newvp = (struct vnode *)0;
d1826 1
a1826 1
			newvp = (struct vnode *)0;
d2332 1
a2332 1
				nfsm_loadattr(newvp, (struct vattr *)0);
d2440 1
a2440 1
		cnp->cn_proc, (struct nfsnode **)0) == 0) {
d2481 1
a2481 1
	struct vnode *newvp = (struct vnode *)0;
d2526 1
a2526 1
			nfsm_loadattr(newvp, (struct vattr *)0);
d2630 1
a2630 1
		p = (struct proc *)0;
d2829 1
a2829 1
			    if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
d2862 1
a2862 1
			    if (nfs_sigintr(nmp, (struct nfsreq *)0, p))
@


1.4
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_vnops.c,v 1.58 1996/02/09 21:48:41 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfs_vnops.c	8.10 (Berkeley) 8/11/94
d42 1
d44 1
a44 1
 * vnode op calls for sun nfs version 2
d51 2
a59 1
#include <sys/map.h>
d61 1
d70 1
a70 1
#include <nfs/nfsv2.h>
d79 4
d106 3
d137 1
a137 1
	{ &vop_bwrite_desc, vn_bwrite },
d162 3
a198 1
#ifdef FIFO
d215 3
a250 1
#endif /* FIFO */
d255 1
a255 1
extern u_int32_t nfs_procids[NFS_NPROCS];
d257 2
a258 1
extern u_int32_t nfs_prog, nfs_vers, nfs_true, nfs_false;
d284 3
a286 3
 * For nfs, just return ok. File accesses may fail later.
 * For nqnfs, use the access rpc to check accessibility. If file modes are
 * changed on the server, accesses might still fail later.
d301 3
a303 2
	caddr_t bpos, dpos;
	int error = 0;
d305 2
d309 16
a324 1
	 * For nqnfs, do an access rpc, otherwise you are stuck emulating
d331 5
a335 5
	if (VFSTONFS(vp->v_mount)->nm_flag & NFSMNT_NQNFS) {
		nfsstats.rpccnt[NQNFSPROC_ACCESS]++;
		nfsm_reqhead(vp, NQNFSPROC_ACCESS, NFSX_FH + 3 * NFSX_UNSIGNED);
		nfsm_fhtom(vp);
		nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
d337 1
a337 1
			*tl++ = nfs_true;
d339 27
a365 10
			*tl++ = nfs_false;
		if (ap->a_mode & VWRITE)
			*tl++ = nfs_true;
		else
			*tl++ = nfs_false;
		if (ap->a_mode & VEXEC)
			*tl = nfs_true;
		else
			*tl = nfs_false;
		nfsm_request(vp, NQNFSPROC_ACCESS, ap->a_p, ap->a_cred);
d396 4
a399 1
	if (vp->v_type != VREG && vp->v_type != VDIR && vp->v_type != VLNK)
d401 6
a406 6
	if (vp->v_flag & VTEXT) {
	    /*
	     * Get a valid lease. If cached data is stale, flush it.
	     */
	    if (nmp->nm_flag & NFSMNT_NQNFS) {
		if (NQNFS_CKINVALID(vp, np, NQL_READ)) {
d408 2
a409 1
			error = nqnfs_getlease(vp, NQL_READ, ap->a_cred, ap->a_p);
d422 1
a422 1
	    } else {
d429 2
a430 1
			np->n_direofoffset = 0;
d440 2
a441 1
				np->n_direofoffset = 0;
d449 2
a450 2
	    }
	} else if ((nmp->nm_flag & NFSMNT_NQNFS) == 0)
d457 27
a483 1
 * For reg files, invalidate any buffer cache entries.
d504 5
a508 1
		error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p, 1);
d535 2
d540 1
d553 2
a554 2
	nfsm_reqhead(vp, NFSPROC_GETATTR, NFSX_FH);
	nfsm_fhtom(vp);
d556 2
a557 1
	nfsm_loadattr(vp, ap->a_vap);
a575 7
	register struct nfsv2_sattr *sp;
	register caddr_t cp;
	register int32_t t1;
	caddr_t bpos, dpos, cp2;
	u_int32_t *tl;
	int error = 0, isnq;
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d579 2
a580 1
	u_quad_t frev, tsize = 0;
d582 8
d591 7
a597 5
		switch (vp->v_type) {
		case VDIR:
			return (EISDIR);
		case VCHR:
		case VBLK:
d601 2
a602 2
			    vap->va_uid == VNOVAL &&
			    vap->va_gid == VNOVAL)
d604 31
a634 22
			vap->va_size = VNOVAL;
			break;
		default:
			if (np->n_flag & NMODIFIED) {
				if (vap->va_size == 0)
					error = nfs_vinvalbuf(vp, 0,
						ap->a_cred, ap->a_p, 1);
				else
					error = nfs_vinvalbuf(vp, V_SAVE,
						ap->a_cred, ap->a_p, 1);
				if (error)
					return (error);
			}
			tsize = np->n_size;
			np->n_size = np->n_vattr.va_size = vap->va_size;
			vnode_pager_setsize(vp, (u_long)np->n_size);
		}
	} else if ((vap->va_mtime.tv_sec != VNOVAL ||
	    vap->va_atime.tv_sec != VNOVAL) && (np->n_flag & NMODIFIED)) {
		error = nfs_vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p, 1);
		if (error == EINTR)
			return (error);
d636 22
d659 63
a721 22
	isnq = (VFSTONFS(vp->v_mount)->nm_flag & NFSMNT_NQNFS);
	nfsm_reqhead(vp, NFSPROC_SETATTR, NFSX_FH+NFSX_SATTR(isnq));
	nfsm_fhtom(vp);
	nfsm_build(sp, struct nfsv2_sattr *, NFSX_SATTR(isnq));
	if (vap->va_mode == (u_short)VNOVAL)
		sp->sa_mode = nfs_xdrneg1;
	else
		sp->sa_mode = vtonfs_mode(vp->v_type, vap->va_mode);
	if (vap->va_uid == VNOVAL)
		sp->sa_uid = nfs_xdrneg1;
	else
		sp->sa_uid = txdr_unsigned(vap->va_uid);
	if (vap->va_gid == VNOVAL)
		sp->sa_gid = nfs_xdrneg1;
	else
		sp->sa_gid = txdr_unsigned(vap->va_gid);
	if (isnq) {
		txdr_hyper(&vap->va_size, &sp->sa_nqsize);
		txdr_nqtime(&vap->va_atime, &sp->sa_nqatime);
		txdr_nqtime(&vap->va_mtime, &sp->sa_nqmtime);
		sp->sa_nqflags = txdr_unsigned(vap->va_flags);
		sp->sa_nqrdev = nfs_xdrneg1;
d723 22
a744 13
		sp->sa_nfssize = txdr_unsigned(vap->va_size);
		txdr_nfstime(&vap->va_atime, &sp->sa_nfsatime);
		txdr_nfstime(&vap->va_mtime, &sp->sa_nfsmtime);
	}
	nfsm_request(vp, NFSPROC_SETATTR, ap->a_p, ap->a_cred);
	nfsm_loadattr(vp, (struct vattr *)0);
	if ((VFSTONFS(vp->v_mount)->nm_flag & NFSMNT_NQNFS) &&
	    NQNFS_CKCACHABLE(vp, NQL_WRITE)) {
		nfsm_dissect(tl, u_int32_t *, 2*NFSX_UNSIGNED);
		fxdr_hyper(tl, &frev);
		if (frev > np->n_brev)
			np->n_brev = frev;
	}
a745 4
	if (error) {
		np->n_size = np->n_vattr.va_size = tsize;
		vnode_pager_setsize(vp, (u_long)np->n_size);
	}
d768 1
a768 1
	register struct vnode *vdp;
a773 1
	time_t reqtime = 0;
a774 1
	struct vnode *newvp;
d776 1
a776 1
	nfsv2fh_t *fhp;
d778 2
a779 3
	int lockparent, wantparent, error = 0;
	int nqlflag = 0, cachable = 0;
	u_quad_t frev;
d781 4
a784 1
	*vpp = NULL;
d791 1
a791 1
	if ((error = cache_lookup(dvp, vpp, cnp)) && error != ENOENT) {
d795 2
a796 2
		vdp = *vpp;
		vpid = vdp->v_id;
d801 2
a802 2
		if (dvp == vdp) {
			VREF(vdp);
d805 5
a809 1
			error = vget(vdp, 1);
d811 10
a820 27
			if (vpid == vdp->v_id) {
			   if (nmp->nm_flag & NFSMNT_NQNFS) {
				if ((nmp->nm_flag & NFSMNT_NQLOOKLEASE) == 0) {
				cachehit:
					nfsstats.lookupcache_hits++;
					if (cnp->cn_nameiop != LOOKUP &&
					    (flags & ISLASTCN))
						cnp->cn_flags |= SAVENAME;
					return (0);
			        } else if (NQNFS_CKCACHABLE(dvp, NQL_READ)) {
					if (np->n_lrev != np->n_brev ||
					    (np->n_flag & NMODIFIED)) {
						np->n_direofoffset = 0;
						cache_purge(dvp);
						error = nfs_vinvalbuf(dvp, 0,
						    cnp->cn_cred, cnp->cn_proc,
						    1);
						if (error == EINTR)
							return (error);
						np->n_brev = np->n_lrev;
					} else
						goto cachehit;
				}
			   } else if (!VOP_GETATTR(vdp, &vattr, cnp->cn_cred, cnp->cn_proc) &&
			       vattr.va_ctime.tv_sec == VTONFS(vdp)->n_ctime)
				goto cachehit;
			   cache_purge(vdp);
d822 1
a822 1
			vrele(vdp);
d827 1
d831 3
a833 16
	nfsm_reqhead(dvp, NFSPROC_LOOKUP, NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(len));

	/*
	 * For nqnfs optionally piggyback a getlease request for the name
	 * being looked up.
	 */
	if (nmp->nm_flag & NFSMNT_NQNFS) {
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
		if ((nmp->nm_flag & NFSMNT_NQLOOKLEASE) &&
		    ((cnp->cn_flags & MAKEENTRY) &&
		    (cnp->cn_nameiop != DELETE || !(flags & ISLASTCN))))
			*tl = txdr_unsigned(nmp->nm_leaseterm);
		else
			*tl = 0;
	}
	nfsm_fhtom(dvp);
a834 1
	reqtime = time.tv_sec;
a835 1
nfsmout:
d837 3
a839 17
		if ((cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME) &&
		    (flags & ISLASTCN) && error == ENOENT)
			error = EJUSTRETURN;
		if (cnp->cn_nameiop != LOOKUP && (flags & ISLASTCN))
			cnp->cn_flags |= SAVENAME;
		return (error);
	}
	if (nmp->nm_flag & NFSMNT_NQNFS) {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		if (*tl) {
			nqlflag = fxdr_unsigned(int, *tl);
			nfsm_dissect(tl, u_int32_t *, 4*NFSX_UNSIGNED);
			cachable = fxdr_unsigned(int, *tl++);
			reqtime += fxdr_unsigned(int, *tl++);
			fxdr_hyper(tl, &frev);
		} else
			nqlflag = 0;
d841 1
a841 1
	nfsm_dissect(fhp, nfsv2fh_t *, NFSX_FH);
d847 1
a847 1
		if (!bcmp(np->n_fh.fh_bytes, (caddr_t)fhp, NFSX_FH)) {
d851 2
a852 1
		if ((error = nfs_nget(dvp->v_mount, fhp, &np)) != 0) {
d857 5
a861 6
		error = nfs_loadattrcache(&newvp, &md, &dpos, NULL);
		if (error) {
			vrele(newvp);
			m_freem(mrep);
			return (error);
		}
d868 1
a868 1
	if (!bcmp(np->n_fh.fh_bytes, (caddr_t)fhp, NFSX_FH)) {
d872 2
a873 1
		if ((error = nfs_nget(dvp->v_mount, fhp, &np)) != 0) {
d879 5
a883 8
	error = nfs_loadattrcache(&newvp, &md, &dpos, (struct vattr *)0);
	if (error) {
		vrele(newvp);
		m_freem(mrep);
		return (error);
	}
	m_freem(mrep);
	*vpp = newvp;
d888 2
a889 6
		if ((nmp->nm_flag & NFSMNT_NQNFS) == 0)
			np->n_ctime = np->n_vattr.va_ctime.tv_sec;
		else if (nqlflag && reqtime > time.tv_sec)
			nqnfs_clientlease(nmp, np, nqlflag, cachable, reqtime,
				frev);
		cache_enter(dvp, *vpp, cnp);
d891 16
a906 1
	return (0);
d961 1
a961 1
	register int32_t t1;
d963 1
a963 1
	int error = 0;
d965 1
a965 1
	long len;
d968 2
a969 2
	nfsm_reqhead(vp, NFSPROC_READLINK, NFSX_FH);
	nfsm_fhtom(vp);
d971 6
a976 2
	nfsm_strsiz(len, NFS_MAXPATHLEN);
	nfsm_mtouio(uiop, len);
d993 1
a993 1
	register int32_t t1;
a994 1
	int error = 0;
d997 2
a998 1
	long len, retlen, tsiz;
d1000 3
d1005 1
a1005 2
	if (uiop->uio_offset + tsiz > 0xffffffff &&
	    (nmp->nm_flag & NFSMNT_NQNFS) == 0)
d1010 4
a1013 4
		nfsm_reqhead(vp, NFSPROC_READ, NFSX_FH+NFSX_UNSIGNED*3);
		nfsm_fhtom(vp);
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED*3);
		if (nmp->nm_flag & NFSMNT_NQNFS) {
d1022 10
a1031 1
		nfsm_loadattr(vp, (struct vattr *)0);
d1035 5
a1039 1
		if (retlen < len)
a1040 2
		else
			tsiz -= len;
d1050 1
a1050 1
nfs_writerpc(vp, uiop, cred, ioflags)
d1052 1
a1052 1
	struct uio *uiop;
d1054 1
a1054 1
	int ioflags;
d1058 1
a1058 1
	register int32_t t1;
a1059 1
	int error = 0;
d1061 3
a1063 4
	struct nfsmount *nmp;
	struct nfsnode *np = VTONFS(vp);
	u_quad_t frev;
	long len, tsiz;
d1065 5
a1069 1
	nmp = VFSTONFS(vp->v_mount);
d1071 1
a1071 2
	if (uiop->uio_offset + tsiz > 0xffffffff &&
	    (nmp->nm_flag & NFSMNT_NQNFS) == 0)
d1077 4
a1080 4
			NFSX_FH+NFSX_UNSIGNED*4+nfsm_rndup(len));
		nfsm_fhtom(vp);
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED * 4);
		if (nmp->nm_flag & NFSMNT_NQNFS) {
d1083 2
a1084 1
			*tl++ = 0;
d1088 2
d1092 2
a1093 2
			*tl++ = x;	/* "begin offset" */
			*tl++ = x;	/* "current offset" */
d1095 3
a1097 2
			*tl++ = x;	/* total to this offset */
			*tl = x;	/* size of this write */
d1101 44
a1144 10
		nfsm_loadattr(vp, (struct vattr *)0);
		if (nmp->nm_flag & NFSMNT_MYWRITE)
			VTONFS(vp)->n_mtime = VTONFS(vp)->n_vattr.va_mtime.tv_sec;
		else if ((nmp->nm_flag & NFSMNT_NQNFS) &&
			 NQNFS_CKCACHABLE(vp, NQL_WRITE)) {
			nfsm_dissect(tl, u_int32_t *, 2*NFSX_UNSIGNED);
			fxdr_hyper(tl, &frev);
			if (frev > np->n_brev)
				np->n_brev = frev;
		}
d1149 1
d1156 3
a1158 3
 * nfs mknod call
 * This is a kludge. Use a create rpc but with the IFMT bits of the mode
 * set to specify the file type and the size field for rdev.
a1159 1
/* ARGSUSED */
d1161 5
a1165 2
nfs_mknod(v)
	void *v;
a1166 9
	struct vop_mknod_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
	register struct vnode *dvp = ap->a_dvp;
	register struct vattr *vap = ap->a_vap;
	register struct componentname *cnp = ap->a_cnp;
d1168 1
d1172 2
a1173 1
	struct vnode *newvp;
d1176 1
a1176 1
	int error = 0, isnq;
d1179 1
d1183 2
a1184 4
#ifdef FIFO
	else if (vap->va_type == VFIFO)
		rdev = 0xffffffff;
#endif /* FIFO */
d1190 4
a1193 6
	newvp = NULLVP;
	nfsstats.rpccnt[NFSPROC_CREATE]++;
	isnq = (VFSTONFS(dvp->v_mount)->nm_flag & NFSMNT_NQNFS);
	nfsm_reqhead(dvp, NFSPROC_CREATE,
	  NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(cnp->cn_namelen)+NFSX_SATTR(isnq));
	nfsm_fhtom(dvp);
d1195 10
a1204 9
	nfsm_build(sp, struct nfsv2_sattr *, NFSX_SATTR(isnq));
	sp->sa_mode = vtonfs_mode(vap->va_type, vap->va_mode);
	sp->sa_uid = nfs_xdrneg1;
	sp->sa_gid = nfs_xdrneg1;
	if (isnq) {
		sp->sa_nqrdev = rdev;
		sp->sa_nqflags = 0;
		txdr_nqtime(&vap->va_atime, &sp->sa_nqatime);
		txdr_nqtime(&vap->va_mtime, &sp->sa_nqmtime);
d1206 21
a1226 3
		sp->sa_nfssize = rdev;
		txdr_nfstime(&vap->va_atime, &sp->sa_nfsatime);
		txdr_nfstime(&vap->va_mtime, &sp->sa_nfsmtime);
d1228 2
a1229 2
	nfsm_request(dvp, NFSPROC_CREATE, cnp->cn_proc, cnp->cn_cred);
	nfsm_mtofh(dvp, newvp);
d1231 8
a1238 2
	if (!error && (cnp->cn_flags & MAKEENTRY))
		cache_enter(dvp, newvp, cnp);
d1241 2
a1242 1
	VTONFS(dvp)->n_attrstamp = 0;
d1244 23
a1266 1
	if (newvp != NULLVP)
d1271 1
d1289 1
d1293 2
d1296 1
a1296 1
	int error = 0, isnq;
d1298 7
d1306 5
d1312 3
a1314 4
	isnq = (VFSTONFS(dvp->v_mount)->nm_flag & NFSMNT_NQNFS);
	nfsm_reqhead(dvp, NFSPROC_CREATE,
	  NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(cnp->cn_namelen)+NFSX_SATTR(isnq));
	nfsm_fhtom(dvp);
d1316 16
a1331 12
	nfsm_build(sp, struct nfsv2_sattr *, NFSX_SATTR(isnq));
	sp->sa_mode = vtonfs_mode(vap->va_type, vap->va_mode);
	sp->sa_uid = nfs_xdrneg1;
	sp->sa_gid = nfs_xdrneg1;
	if (isnq) {
		u_quad_t qval = 0;

		txdr_hyper(&qval, &sp->sa_nqsize);
		sp->sa_nqrdev = nfs_xdrneg1;
		sp->sa_nqflags = 0;
		txdr_nqtime(&vap->va_atime, &sp->sa_nqatime);
		txdr_nqtime(&vap->va_mtime, &sp->sa_nqmtime);
d1333 7
a1339 3
		sp->sa_nfssize = 0;
		txdr_nfstime(&vap->va_atime, &sp->sa_nfsatime);
		txdr_nfstime(&vap->va_mtime, &sp->sa_nfsmtime);
d1342 15
a1356 1
	nfsm_mtofh(dvp, *ap->a_vpp);
d1358 14
a1371 2
	if (!error && (cnp->cn_flags & MAKEENTRY))
		cache_enter(dvp, *ap->a_vpp, cnp);
d1374 2
a1375 1
	VTONFS(dvp)->n_attrstamp = 0;
a1404 4
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t2;
	caddr_t bpos, dpos;
a1405 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1408 9
a1416 15
	if (vp->v_usecount > 1) {
		if (!np->n_sillyrename)
			error = nfs_sillyrename(dvp, vp, cnp);
		else if (VOP_GETATTR(vp, &vattr, cnp->cn_cred, cnp->cn_proc)
			 == 0 && vattr.va_nlink > 1)
			/*
			 * If we already have a silly name but there are more
			 * than one links, just proceed with the NFS remove
			 * request, as the bits will remain available (modulo
			 * network races). This avoids silently ignoring the
			 * attempted removal of a non-silly entry.
			 */
			goto doit;
	} else {
	doit:
d1426 2
a1427 2
		 * Throw away biocache buffers. Mainly to avoid
		 * unnecessary delayed writes.
a1429 2
		if (error == EINTR)
			return (error);
d1431 3
a1433 10
		nfsstats.rpccnt[NFSPROC_REMOVE]++;
		nfsm_reqhead(dvp, NFSPROC_REMOVE,
			NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(cnp->cn_namelen));
		nfsm_fhtom(dvp);
		nfsm_strtom(cnp->cn_nameptr, cnp->cn_namelen, NFS_MAXNAMLEN);
		nfsm_request(dvp, NFSPROC_REMOVE, cnp->cn_proc, cnp->cn_cred);
		nfsm_reqdone;
		FREE(cnp->cn_pnbuf, M_NAMEI);
		VTONFS(dvp)->n_flag |= NMODIFIED;
		VTONFS(dvp)->n_attrstamp = 0;
d1442 3
a1444 1
	}
d1458 16
d1476 3
a1478 3
	register int32_t t2;
	caddr_t bpos, dpos;
	int error = 0;
d1480 1
d1483 7
a1489 5
	nfsm_reqhead(sp->s_dvp, NFSPROC_REMOVE,
		NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(sp->s_namlen));
	nfsm_fhtom(sp->s_dvp);
	nfsm_strtom(sp->s_name, sp->s_namlen, NFS_MAXNAMLEN);
	nfsm_request(sp->s_dvp, NFSPROC_REMOVE, NULL, sp->s_cred);
d1491 3
a1493 2
	VTONFS(sp->s_dvp)->n_flag |= NMODIFIED;
	VTONFS(sp->s_dvp)->n_attrstamp = 0;
d1518 1
a1518 6
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t2;
	caddr_t bpos, dpos;
	int error = 0;
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d1520 5
d1532 13
a1545 14
	nfsstats.rpccnt[NFSPROC_RENAME]++;
	nfsm_reqhead(fdvp, NFSPROC_RENAME,
		(NFSX_FH+NFSX_UNSIGNED)*2+nfsm_rndup(fcnp->cn_namelen)+
		nfsm_rndup(fcnp->cn_namelen)); /* or fcnp->cn_cred?*/
	nfsm_fhtom(fdvp);
	nfsm_strtom(fcnp->cn_nameptr, fcnp->cn_namelen, NFS_MAXNAMLEN);
	nfsm_fhtom(tdvp);
	nfsm_strtom(tcnp->cn_nameptr, tcnp->cn_namelen, NFS_MAXNAMLEN);
	nfsm_request(fdvp, NFSPROC_RENAME, tcnp->cn_proc, tcnp->cn_cred);
	nfsm_reqdone;
	VTONFS(fdvp)->n_flag |= NMODIFIED;
	VTONFS(fdvp)->n_attrstamp = 0;
	VTONFS(tdvp)->n_flag |= NMODIFIED;
	VTONFS(tdvp)->n_attrstamp = 0;
d1577 18
d1597 3
a1599 3
	register int32_t t2;
	caddr_t bpos, dpos;
	int error = 0;
d1601 1
d1604 12
a1615 8
	nfsm_reqhead(sdvp, NFSPROC_RENAME,
		(NFSX_FH+NFSX_UNSIGNED)*2+nfsm_rndup(scnp->cn_namelen)+
		nfsm_rndup(sp->s_namlen));
	nfsm_fhtom(sdvp);
	nfsm_strtom(scnp->cn_nameptr, scnp->cn_namelen, NFS_MAXNAMLEN);
	nfsm_fhtom(sdvp);
	nfsm_strtom(sp->s_name, sp->s_namlen, NFS_MAXNAMLEN);
	nfsm_request(sdvp, NFSPROC_RENAME, scnp->cn_proc, scnp->cn_cred);
d1617 6
a1622 3
	FREE(scnp->cn_pnbuf, M_NAMEI);
	VTONFS(sdvp)->n_flag |= NMODIFIED;
	VTONFS(sdvp)->n_attrstamp = 0;
d1638 1
a1639 1
	register struct vnode *vp = ap->a_vp;
d1643 3
a1645 3
	register int32_t t2;
	caddr_t bpos, dpos;
	int error = 0;
d1647 2
d1651 1
a1651 1
		/*VOP_ABORTOP(dvp, cnp);*/
d1668 3
a1670 3
		NFSX_FH*2+NFSX_UNSIGNED+nfsm_rndup(cnp->cn_namelen));
	nfsm_fhtom(vp);
	nfsm_fhtom(dvp);
d1673 4
a1678 1
	VTONFS(vp)->n_attrstamp = 0;
d1680 5
a1684 2
	VTONFS(dvp)->n_attrstamp = 0;
	vrele(dvp);
a1695 1
/* start here */
d1711 1
d1714 3
a1716 3
	register int32_t t2;
	caddr_t bpos, dpos;
	int slen, error = 0, isnq;
d1718 2
d1723 3
a1725 4
	isnq = (VFSTONFS(dvp->v_mount)->nm_flag & NFSMNT_NQNFS);
	nfsm_reqhead(dvp, NFSPROC_SYMLINK, NFSX_FH+2*NFSX_UNSIGNED+
	    nfsm_rndup(cnp->cn_namelen)+nfsm_rndup(slen)+NFSX_SATTR(isnq));
	nfsm_fhtom(dvp);
d1727 4
d1732 8
a1739 15
	nfsm_build(sp, struct nfsv2_sattr *, NFSX_SATTR(isnq));
	sp->sa_mode = vtonfs_mode(VLNK, vap->va_mode);
	sp->sa_uid = nfs_xdrneg1;
	sp->sa_gid = nfs_xdrneg1;
	if (isnq) {
		quad_t qval = -1;

		txdr_hyper(&qval, &sp->sa_nqsize);
		sp->sa_nqflags = 0;
		txdr_nqtime(&vap->va_atime, &sp->sa_nqatime);
		txdr_nqtime(&vap->va_mtime, &sp->sa_nqmtime);
	} else {
		sp->sa_nfssize = nfs_xdrneg1;
		txdr_nfstime(&vap->va_atime, &sp->sa_nfsatime);
		txdr_nfstime(&vap->va_mtime, &sp->sa_nfsmtime);
d1742 5
d1748 2
d1752 2
a1753 1
	VTONFS(dvp)->n_attrstamp = 0;
a1778 1
	register struct vnode **vpp = ap->a_vpp;
d1780 1
d1785 2
d1788 2
a1789 1
	int error = 0, firsttry = 1, isnq;
d1791 1
a1793 1
	isnq = (VFSTONFS(dvp->v_mount)->nm_flag & NFSMNT_NQNFS);
d1796 2
a1797 2
	  NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(len)+NFSX_SATTR(isnq));
	nfsm_fhtom(dvp);
d1799 3
a1801 11
	nfsm_build(sp, struct nfsv2_sattr *, NFSX_SATTR(isnq));
	sp->sa_mode = vtonfs_mode(VDIR, vap->va_mode);
	sp->sa_uid = nfs_xdrneg1;
	sp->sa_gid = nfs_xdrneg1;
	if (isnq) {
		quad_t qval = -1;

		txdr_hyper(&qval, &sp->sa_nqsize);
		sp->sa_nqflags = 0;
		txdr_nqtime(&vap->va_atime, &sp->sa_nqatime);
		txdr_nqtime(&vap->va_mtime, &sp->sa_nqmtime);
d1803 7
a1809 3
		sp->sa_nfssize = nfs_xdrneg1;
		txdr_nfstime(&vap->va_atime, &sp->sa_nfsatime);
		txdr_nfstime(&vap->va_mtime, &sp->sa_nfsmtime);
d1812 4
a1815 1
	nfsm_mtofh(dvp, *vpp);
d1818 2
a1819 1
	VTONFS(dvp)->n_attrstamp = 0;
a1822 2
	 * "firsttry" is necessary since the macros may "goto nfsmout" which
	 * is above the if on errors. (Ugh)
d1824 11
a1834 14
	if (error == EEXIST && firsttry) {
		firsttry = 0;
		error = 0;
		nfsstats.rpccnt[NFSPROC_LOOKUP]++;
		*vpp = NULL;
		nfsm_reqhead(dvp, NFSPROC_LOOKUP,
		    NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(len));
		nfsm_fhtom(dvp);
		nfsm_strtom(cnp->cn_nameptr, len, NFS_MAXNAMLEN);
		nfsm_request(dvp, NFSPROC_LOOKUP, cnp->cn_proc, cnp->cn_cred);
		nfsm_mtofh(dvp, *vpp);
		if ((*vpp)->v_type != VDIR) {
			vput(*vpp);
			error = EEXIST;
a1835 1
		m_freem(mrep);
d1837 5
d1864 3
a1866 3
	register int32_t t2;
	caddr_t bpos, dpos;
	int error = 0;
d1868 1
d1878 2
a1879 2
		NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(cnp->cn_namelen));
	nfsm_fhtom(dvp);
d1882 2
d1887 2
a1888 1
	VTONFS(dvp)->n_attrstamp = 0;
a1902 3
 * Although cookie is defined as opaque, I translate it to/from net byte
 * order so that it looks more sensible. This appears consistent with the
 * Ultrix implementation of NFS.
d1920 1
d1929 1
a1929 1
	if (uio->uio_offset != 0 && uio->uio_offset == np->n_direofoffset &&
d1932 1
a1932 1
			if (NQNFS_CKCACHABLE(vp, NQL_READ)) {
d1934 1
d1940 1
d1951 1
a1951 1
	if (!error && uio->uio_resid == tresid)
d1953 3
d1959 1
a1959 1
		u_long *cptr, *cookies = ap->a_cookies;
d1968 1
a1968 1
			panic("ufs_readdir: lost in space");
d1973 2
a1974 3
			cptr = (u_long *)((caddr_t)dp + dp->d_reclen -
					  sizeof(u_long));
			*(cookies++) = *cptr;
d1982 1
d1992 2
a1993 2
	register struct vnode *vp;
	struct uio *uiop;
d1996 1
a1996 1
	register long len;
d2000 2
a2001 2
	register int32_t t1;
	long tlen, lastlen = 0;
a2002 1
	int error = 0;
d2004 13
a2016 9
	struct mbuf *md2;
	caddr_t dpos2;
	int siz;
	int more_dirs = 1;
	u_long off = 0, savoff = 0;
	struct dirent *savdp = NULL;
	struct nfsmount *nmp;
	struct nfsnode *np = VTONFS(vp);
	long tresid, extra;
a2017 4
	nmp = VFSTONFS(vp->v_mount);
	extra = uiop->uio_resid & (NFS_DIRBLKSIZ - 1);
	uiop->uio_resid -= extra;
	tresid = uiop->uio_resid;
d2019 10
a2028 2
	 * Loop around doing readdir rpc's of size uio_resid or nm_rsize,
	 * whichever is smaller, truncated to a multiple of NFS_DIRBLKSIZ.
d2031 1
a2031 1
	while (more_dirs && uiop->uio_resid >= NFS_DIRBLKSIZ) {
d2033 14
a2046 8
		nfsm_reqhead(vp, NFSPROC_READDIR,
			NFSX_FH + 2 * NFSX_UNSIGNED);
		nfsm_fhtom(vp);
		nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		off = (u_long)uiop->uio_offset;
		*tl++ = txdr_unsigned(off);
		*tl = txdr_unsigned(((uiop->uio_resid > nmp->nm_rsize) ?
			nmp->nm_rsize : uiop->uio_resid) & ~(NFS_DIRBLKSIZ-1));
d2048 12
a2059 1
		siz = 0;
a2062 4
		/* Save the position so that we can do nfsm_mtouio() later */
		dpos2 = dpos;
		md2 = md;
	
d2064 12
a2075 10
#ifdef lint
		dp = (struct dirent *)0;
#endif /* lint */
		while (more_dirs && siz < uiop->uio_resid) {
			savoff = off;		/* Hold onto offset and dp */
			savdp = dp;
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			dp = (struct dirent *)tl;
			dp->d_fileno = fxdr_unsigned(u_int32_t, *tl++);
			len = fxdr_unsigned(int, *tl);
a2080 3
			dp->d_namlen = (u_char)len;
			dp->d_type = DT_UNKNOWN;
			nfsm_adv(len);		/* Point past name */
d2082 42
a2123 8
			/*
			 * This should not be necessary, but some servers have
			 * broken XDR such that these bytes are not null filled.
			 */
			if (tlen != len) {
				*dpos = '\0';	/* Null-terminate */
				nfsm_adv(tlen - len);
				len = tlen;
d2125 8
a2132 3
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			off = fxdr_unsigned(u_int32_t, *tl);
			*tl++ = 0;	/* Ensures null termination of name */
a2133 3
			*tl = off;	/* Store offset for cookie retrieval */
			dp->d_reclen = len + 4 * NFSX_UNSIGNED;
			siz += dp->d_reclen;
a2140 6

			/*
			 * If at EOF, cache directory offset
			 */
			if (!more_dirs)
				np->n_direofoffset = off;
a2141 19
		/*
		 * If there is too much to fit in the data buffer, use savoff and
		 * savdp to trim off the last record.
		 * --> we are not at eof
		 */
		if (siz > uiop->uio_resid) {
			off = savoff;
			siz -= dp->d_reclen;
			dp = savdp;
			more_dirs = 0;	/* Paranoia */
		}
		if (siz > 0) {
			lastlen = dp->d_reclen;
			md = md2;
			dpos = dpos2;
			nfsm_mtouio(uiop, siz);
			uiop->uio_offset = (off_t)off;
		} else
			more_dirs = 0;	/* Ugh, never happens, but in case.. */
d2145 1
a2145 1
	 * Fill last record, iff any, out to a multiple of NFS_DIRBLKSIZ
d2148 20
a2167 12
	if (uiop->uio_resid < tresid) {
		len = uiop->uio_resid & (NFS_DIRBLKSIZ - 1);
		if (len > 0) {
			dp = (struct dirent *)
				(uiop->uio_iov->iov_base - lastlen);
			dp->d_reclen += len;
			*(u_long *)((caddr_t)dp + dp->d_reclen -
				    sizeof(u_long)) = off;
			uiop->uio_iov->iov_base += len;
			uiop->uio_iov->iov_len -= len;
			uiop->uio_resid -= len;
		}
a2169 1
	uiop->uio_resid += extra;
d2174 1
a2174 1
 * Nqnfs readdir_and_lookup RPC. Used in place of nfs_readdirrpc().
d2177 1
a2177 1
nfs_readdirlookrpc(vp, uiop, cred)
d2182 1
a2182 1
	register int len;
d2186 5
a2190 3
	register int32_t t1;
	caddr_t bpos, dpos, cp2;
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
d2193 13
a2205 14
	u_long off = 0, endoff = 0, fileno;
	time_t reqtime, ltime = 0;
	struct nfsmount *nmp;
	struct nfsnode *np;
	struct vnode *newvp;
	nfsv2fh_t *fhp;
	u_quad_t frev;
	int error = 0, tlen, more_dirs = 1, tresid, doit, bigenough, i;
	int cachable = 0;

	if (uiop->uio_iovcnt != 1)
		panic("nfs rdirlook");
	nmp = VFSTONFS(vp->v_mount);
	tresid = uiop->uio_resid;
d2208 9
d2218 2
a2219 2
	 * Loop around doing readdir rpc's of size uio_resid or nm_rsize,
	 * whichever is smaller, truncated to a multiple of NFS_DIRBLKSIZ.
d2222 21
a2242 17
	while (more_dirs && uiop->uio_resid >= NFS_DIRBLKSIZ) {
		nfsstats.rpccnt[NQNFSPROC_READDIRLOOK]++;
		nfsm_reqhead(vp, NQNFSPROC_READDIRLOOK,
			NFSX_FH + 3 * NFSX_UNSIGNED);
		nfsm_fhtom(vp);
 		nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
		off = (u_long)uiop->uio_offset;
		*tl++ = txdr_unsigned(off);
		*tl++ = txdr_unsigned(((uiop->uio_resid > nmp->nm_rsize) ?
			nmp->nm_rsize : uiop->uio_resid) & ~(NFS_DIRBLKSIZ-1));
		if (nmp->nm_flag & NFSMNT_NQLOOKLEASE)
			*tl = txdr_unsigned(nmp->nm_leaseterm);
		else
			*tl = 0;
		reqtime = time.tv_sec;
		nfsm_request(vp, NQNFSPROC_READDIRLOOK, uiop->uio_procp, cred);
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
a2245 1
		bigenough = 1;
d2247 3
a2249 24
			doit = 1;
			nfsm_dissect(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
			if (nmp->nm_flag & NFSMNT_NQLOOKLEASE) {
				cachable = fxdr_unsigned(int, *tl++);
				ltime = reqtime + fxdr_unsigned(int, *tl++);
				fxdr_hyper(tl, &frev);
			}
			nfsm_dissect(fhp, nfsv2fh_t *, NFSX_FH);
			if (!bcmp(VTONFS(vp)->n_fh.fh_bytes, (caddr_t)fhp, NFSX_FH)) {
				VREF(vp);
				newvp = vp;
				np = VTONFS(vp);
			} else {
				error = nfs_nget(vp->v_mount, fhp, &np);
				if (error)
					doit = 0;
				newvp = NFSTOV(np);
			}
			error = nfs_loadattrcache(&newvp, &md, &dpos, NULL);
			if (error)
				doit = 0;
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			fileno = fxdr_unsigned(u_int32_t, *tl++);
			len = fxdr_unsigned(int, *tl);
d2255 12
a2266 1
			tlen = (len + 4) & ~0x3;
d2269 1
a2269 1
			if (bigenough && doit) {
d2271 1
a2271 1
				dp->d_fileno = fileno;
d2274 5
a2278 2
				dp->d_type =
				    IFTODT(VTTOIF(np->n_vattr.va_type));
a2283 1
				ndp->ni_vp = newvp;
d2287 1
a2287 2
				for (i = 0; i < tlen; i++)
					*cp++ = '\0';
d2290 1
d2292 47
d2340 3
a2342 6
				for (cp = cnp->cn_nameptr, i = 1; i <= len; i++, cp++)
					cnp->cn_hash += (unsigned char)*cp * i;
				if ((nmp->nm_flag & NFSMNT_NQLOOKLEASE) &&
					ltime > time.tv_sec)
					nqnfs_clientlease(nmp, np, NQL_READ,
						cachable, ltime, frev);
d2345 1
d2347 4
a2350 1
				nfsm_adv(nfsm_rndup(len));
d2353 2
a2354 2
				vrele(newvp);
				newvp = NULLVP;
d2356 1
a2356 5
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			if (bigenough)
				endoff = off = fxdr_unsigned(u_int32_t, *tl++);
			else
				endoff = fxdr_unsigned(u_int32_t, *tl++);
a2357 1
			*tl = endoff;	/* Store offset for cookies. */
a2364 6

			/*
			 * If at EOF, cache directory offset
			 */
			if (!more_dirs)
				VTONFS(vp)->n_direofoffset = endoff;
a2365 4
		if (uiop->uio_resid < tresid)
			uiop->uio_offset = (off_t)off;
		else
			more_dirs = 0;
d2369 1
a2369 1
	 * Fill last record, iff any, out to a multiple of NFS_DIRBLKSIZ
d2372 20
a2391 10
	if (uiop->uio_resid < tresid) {
		len = uiop->uio_resid & (NFS_DIRBLKSIZ - 1);
		if (len > 0) {
			dp->d_reclen += len;
			*(u_long *)((caddr_t)dp + dp->d_reclen -
				    sizeof(u_long)) = off;
			uiop->uio_iov->iov_base += len;
			uiop->uio_iov->iov_len -= len;
			uiop->uio_resid -= len;
		}
a2412 1
	register struct nfsnode *np;
d2414 1
d2420 4
a2423 1
#ifdef SILLYSEPARATE
a2425 3
#else
	sp = &np->n_silly;
#endif
d2440 2
a2441 1
	while (nfs_lookitup(sp, (nfsv2fh_t *)0, cnp->cn_proc) == 0) {
d2448 2
a2449 1
	if ((error = nfs_renameit(dvp, cnp, sp)) != 0)
d2451 2
a2452 1
	nfs_lookitup(sp, &np->n_fh, cnp->cn_proc);
a2457 1
#ifdef SILLYSEPARATE
a2458 1
#endif
d2463 6
a2468 4
 * Look up a file name for silly rename stuff.
 * Just like nfs_lookup() except that it doesn't load returned values
 * into the nfsnode table.
 * If fhp != NULL it copies the returned file handle out
d2471 5
a2475 3
nfs_lookitup(sp, fhp, procp)
	register struct sillyrename *sp;
	nfsv2fh_t *fhp;
d2477 1
a2478 1
	register struct vnode *vp = sp->s_dvp;
d2482 2
d2485 1
a2485 1
	int error = 0, isnq;
d2487 2
a2488 1
	long len;
a2489 1
	isnq = (VFSTONFS(vp->v_mount)->nm_flag & NFSMNT_NQNFS);
d2491 45
a2535 5
	len = sp->s_namlen;
	nfsm_reqhead(vp, NFSPROC_LOOKUP, NFSX_FH+NFSX_UNSIGNED+nfsm_rndup(len));
	if (isnq) {
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
		*tl = 0;
d2537 41
a2577 8
	nfsm_fhtom(vp);
	nfsm_strtom(sp->s_name, len, NFS_MAXNAMLEN);
	nfsm_request(vp, NFSPROC_LOOKUP, procp, sp->s_cred);
	if (fhp != NULL) {
		if (isnq)
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		nfsm_dissect(cp, caddr_t, NFSX_FH);
		bcopy(cp, (caddr_t)fhp, NFSX_FH);
d2586 1
a2586 3
 * - do nfs_strategy() by faking physical I/O with nfs_readrpc/nfs_writerpc
 *   after mapping the physical addresses into Kernel Virtual space in the
 *   nfsiobuf area.
d2672 1
a2672 3
 * Flush all the blocks associated with a vnode.
 * 	Walk through the buffer pool and push any dirty pages
 *	associated with the vnode.
d2686 17
a2702 1
	register struct vnode *vp = ap->a_vp;
d2705 1
d2707 9
a2715 2
	struct nfsmount *nmp;
	int s, error = 0, slptimeo = 0, slpflag = 0;
a2716 1
	nmp = VFSTONFS(vp->v_mount);
d2719 99
d2823 1
a2823 1
			if (ap->a_waitfor != MNT_WAIT)
d2830 1
a2830 1
			    if (nfs_sigintr(nmp, (struct nfsreq *)0, ap->a_p))
d2841 2
d2844 4
a2847 1
		bp->b_flags |= B_BUSY;
a2848 1
		bp->b_flags |= B_ASYNC;
d2853 5
a2857 1
	if (ap->a_waitfor == MNT_WAIT) {
d2863 1
a2863 1
			    if (nfs_sigintr(nmp, (struct nfsreq *)0, ap->a_p))
d2871 2
a2872 2
		if (vp->v_dirtyblkhd.lh_first) {
#ifdef DIAGNOSTIC
d2888 2
a2889 2
 * Currently the NFS protocol does not support getting such
 * information from the remote server.
d2940 1
a2940 1
	printf("tag VT_NFS, fileid %d fsid 0x%x",
a2941 1
#ifdef FIFO
a2943 1
#endif /* FIFO */
d2945 1
a2945 1
	return 0;
a3024 1
	printf("nfs_truncate: need to implement!!");
a3033 1
{
d3042 1
a3044 1
	printf("nfs_update: need to implement!!");
d3049 84
d3148 1
d3151 18
a3168 1
	if ((error = VOP_GETATTR(ap->a_vp, &va, ap->a_cred, ap->a_p)) != 0)
d3194 2
a3195 1
	np->n_atim = time;
d3218 2
a3219 1
	np->n_mtim = time;
d3247 4
a3250 10
			if (np->n_flag & NACC) {
				vattr.va_atime.tv_sec = np->n_atim.tv_sec;
				vattr.va_atime.tv_nsec =
				    np->n_atim.tv_usec * 1000;
			}
			if (np->n_flag & NUPD) {
				vattr.va_mtime.tv_sec = np->n_mtim.tv_sec;
				vattr.va_mtime.tv_nsec =
				    np->n_mtim.tv_usec * 1000;
			}
a3256 1
#ifdef FIFO
d3277 2
a3278 1
	np->n_atim = time;
d3302 2
a3303 1
	np->n_mtim = time;
d3328 8
a3335 4
		if (np->n_flag & NACC)
			np->n_atim = time;
		if (np->n_flag & NUPD)
			np->n_mtim = time;
d3340 4
a3343 10
			if (np->n_flag & NACC) {
				vattr.va_atime.tv_sec = np->n_atim.tv_sec;
				vattr.va_atime.tv_nsec =
				    np->n_atim.tv_usec * 1000;
			}
			if (np->n_flag & NUPD) {
				vattr.va_mtime.tv_sec = np->n_mtim.tv_sec;
				vattr.va_mtime.tv_nsec =
				    np->n_mtim.tv_usec * 1000;
			}
a3348 1
#endif /* FIFO */
@


1.3
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_vnops.c,v 1.53 1995/12/19 23:07:54 cgd Exp $	*/
d74 1
d83 1
a83 1
int (**nfsv2_vnodeop_p)();
d128 1
a128 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d136 1
a136 1
int (**spec_nfsv2nodeop_p)();
d181 1
a181 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d187 1
a187 1
int (**fifo_nfsv2nodeop_p)();
d232 1
a232 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
a237 2
void nqnfs_clientlease();

d242 1
d274 3
a276 1
nfs_access(ap)
d282 1
a282 2
	} */ *ap;
{
d331 3
a333 1
nfs_open(ap)
d339 1
a339 2
	} */ *ap;
{
d376 2
a377 1
			if (error = VOP_GETATTR(vp, &vattr, ap->a_cred, ap->a_p))
d379 1
a379 1
			np->n_mtime = vattr.va_mtime.ts_sec;
d381 2
a382 1
			if (error = VOP_GETATTR(vp, &vattr, ap->a_cred, ap->a_p))
d384 1
a384 1
			if (np->n_mtime != vattr.va_mtime.ts_sec) {
d390 1
a390 1
				np->n_mtime = vattr.va_mtime.ts_sec;
d405 3
a407 1
nfs_close(ap)
d414 1
a414 2
	} */ *ap;
{
d437 3
a439 1
nfs_getattr(ap)
d445 1
a445 2
	} */ *ap;
{
d476 3
a478 1
nfs_setattr(ap)
d485 1
a485 2
	} */ *ap;
{
d496 1
a496 1
	u_quad_t frev, tsize;
d504 2
a505 2
			if (vap->va_mtime.ts_sec == VNOVAL &&
			    vap->va_atime.ts_sec == VNOVAL &&
d527 2
a528 2
	} else if ((vap->va_mtime.ts_sec != VNOVAL ||
	    vap->va_atime.ts_sec != VNOVAL) && (np->n_flag & NMODIFIED)) {
d538 2
a539 2
	if (vap->va_mode == (u_short)-1)
		sp->sa_mode = VNOVAL;
d542 2
a543 2
	if (vap->va_uid == (uid_t)-1)
		sp->sa_uid = VNOVAL;
d546 2
a547 2
	if (vap->va_gid == (gid_t)-1)
		sp->sa_gid = VNOVAL;
d555 1
a555 1
		sp->sa_nqrdev = VNOVAL;
d584 3
a586 1
nfs_lookup(ap)
d592 1
a592 2
	} */ *ap;
{
d603 1
a603 1
	time_t reqtime;
d610 1
a610 1
	int nqlflag, cachable;
d660 1
a660 1
			       vattr.va_ctime.ts_sec == VTONFS(vdp)->n_ctime)
d721 1
a721 1
		if (error = nfs_nget(dvp->v_mount, fhp, &np)) {
d726 2
a727 2
		if (error =
		    nfs_loadattrcache(&newvp, &md, &dpos, (struct vattr *)0)) {
d742 1
a742 1
		if (error = nfs_nget(dvp->v_mount, fhp, &np)) {
d748 2
a749 1
	if (error = nfs_loadattrcache(&newvp, &md, &dpos, (struct vattr *)0)) {
d761 1
a761 1
			np->n_ctime = np->n_vattr.va_ctime.ts_sec;
d775 3
a777 1
nfs_read(ap)
d783 1
a783 2
	} */ *ap;
{
d795 3
a797 1
nfs_readlink(ap)
d802 1
a802 2
	} */ *ap;
{
d942 1
a942 1
			VTONFS(vp)->n_mtime = VTONFS(vp)->n_vattr.va_mtime.ts_sec;
d966 3
a968 1
nfs_mknod(ap)
d974 1
a974 2
	} */ *ap;
{
a982 1
	struct vattr vattr;
a999 5
	if (error = VOP_GETATTR(dvp, &vattr, cnp->cn_cred, cnp->cn_proc)) {
		VOP_ABORTOP(dvp, cnp);
		vput(dvp);
		return (error);
	}
d1009 2
a1010 2
	sp->sa_uid = txdr_unsigned(cnp->cn_cred->cr_uid);
	sp->sa_gid = txdr_unsigned(vattr.va_gid);
d1039 3
a1041 1
nfs_create(ap)
d1047 1
a1047 2
	} */ *ap;
{
a1057 1
	struct vattr vattr;
a1058 5
	if (error = VOP_GETATTR(dvp, &vattr, cnp->cn_cred, cnp->cn_proc)) {
		VOP_ABORTOP(dvp, cnp);
		vput(dvp);
		return (error);
	}
d1067 2
a1068 2
	sp->sa_uid = txdr_unsigned(cnp->cn_cred->cr_uid);
	sp->sa_gid = txdr_unsigned(vattr.va_gid);
d1073 1
a1073 1
		sp->sa_nqrdev = -1;
d1106 3
a1108 1
nfs_remove(ap)
d1114 1
a1114 2
	} */ *ap;
{
d1213 3
a1215 1
nfs_rename(ap)
d1223 1
a1223 2
	} */ *ap;
{
d1317 3
a1319 1
nfs_link(ap)
d1321 1
a1322 1
		struct vnode *a_tdvp;
d1324 2
a1325 2
	} */ *ap;
{
a1326 1
	register struct vnode *tdvp = ap->a_tdvp;
d1335 4
a1338 4
	if (vp->v_mount != tdvp->v_mount) {
		/*VOP_ABORTOP(vp, cnp);*/
		if (tdvp == vp)
			vrele(vp);
d1340 1
a1340 1
			vput(vp);
d1349 1
a1349 1
	VOP_FSYNC(tdvp, cnp->cn_cred, MNT_WAIT, cnp->cn_proc);
d1352 1
a1352 1
	nfsm_reqhead(tdvp, NFSPROC_LINK,
a1353 1
	nfsm_fhtom(tdvp);
d1355 1
d1357 1
a1357 1
	nfsm_request(tdvp, NFSPROC_LINK, cnp->cn_proc, cnp->cn_cred);
a1359 2
	VTONFS(tdvp)->n_attrstamp = 0;
	VTONFS(vp)->n_flag |= NMODIFIED;
d1361 3
a1363 1
	vrele(vp);
d1377 3
a1379 1
nfs_symlink(ap)
d1386 1
a1386 2
	} */ *ap;
{
d1408 2
a1409 2
	sp->sa_uid = txdr_unsigned(cnp->cn_cred->cr_uid);
	sp->sa_gid = txdr_unsigned(cnp->cn_cred->cr_gid);
d1418 1
a1418 1
		sp->sa_nfssize = -1;
d1440 3
a1442 1
nfs_mkdir(ap)
d1448 1
a1448 2
	} */ *ap;
{
a1460 1
	struct vattr vattr;
a1461 5
	if (error = VOP_GETATTR(dvp, &vattr, cnp->cn_cred, cnp->cn_proc)) {
		VOP_ABORTOP(dvp, cnp);
		vput(dvp);
		return (error);
	}
d1471 2
a1472 2
	sp->sa_uid = txdr_unsigned(cnp->cn_cred->cr_uid);
	sp->sa_gid = txdr_unsigned(vattr.va_gid);
d1481 1
a1481 1
		sp->sa_nfssize = -1;
d1522 3
a1524 1
nfs_rmdir(ap)
d1529 1
a1529 2
	} */ *ap;
{
d1575 3
a1577 1
nfs_readdir(ap)
d1585 1
a1585 2
	} */ *ap;
{
d1606 1
a1606 1
			np->n_mtime == vattr.va_mtime.ts_sec) {
d1661 1
a1661 1
	register struct dirent *dp;
d1665 1
a1665 1
	long tlen, lastlen;
d1673 2
a1674 2
	u_long off, savoff;
	struct dirent *savdp;
d1810 1
a1810 1
	register struct dirent *dp;
d1818 2
a1819 2
	u_long off, endoff, fileno;
	time_t reqtime, ltime;
d1826 1
a1826 1
	int cachable;
d1874 2
a1875 1
				if (error = nfs_nget(vp->v_mount, fhp, &np))
d1879 2
a1880 2
			if (error = nfs_loadattrcache(&newvp, &md, &dpos,
				(struct vattr *)0))
d2026 1
a2026 1
	if (error = nfs_renameit(dvp, cnp, sp))
d2094 3
a2096 1
nfs_bmap(ap)
d2103 1
a2103 2
	} */ *ap;
{
d2120 2
a2121 2
nfs_strategy(ap)
	struct vop_strategy_args *ap;
d2123 1
d2157 4
a2160 1
nfs_mmap(ap)
d2166 2
a2167 2
	} */ *ap;
{
d2179 3
a2181 1
nfs_fsync(ap)
d2188 1
a2188 2
	} */ *ap;
{
d2265 5
a2269 1
nfs_pathconf(ap)
d2274 2
a2275 2
	} */ *ap;
{
d2284 3
a2286 1
nfs_advlock(ap)
d2293 1
a2293 2
	} */ *ap;
{
d2304 3
a2306 1
nfs_print(ap)
d2309 1
a2309 2
	} */ *ap;
{
d2320 1
d2328 4
a2331 1
nfs_blkatoff(ap)
d2337 2
a2338 2
	} */ *ap;
{
d2348 4
a2351 1
nfs_valloc(ap)
d2357 2
a2358 2
	} */ *ap;
{
d2368 4
a2371 1
nfs_vfree(ap)
d2376 2
a2377 2
	} */ *ap;
{
d2386 4
a2389 1
nfs_truncate(ap)
d2396 2
a2397 2
	} */ *ap;
{
d2408 4
a2411 1
nfs_update(ap)
d2417 2
a2418 2
	} */ *ap;
{
d2431 3
a2433 1
nfsspec_access(ap)
d2439 1
a2439 2
	} */ *ap;
{
d2443 1
a2443 1
	if (error = VOP_GETATTR(ap->a_vp, &va, ap->a_cred, ap->a_p))
d2454 3
a2456 1
nfsspec_read(ap)
d2462 1
a2462 2
	} */ *ap;
{
d2477 3
a2479 1
nfsspec_write(ap)
d2485 1
a2485 2
	} */ *ap;
{
d2502 3
a2504 1
nfsspec_close(ap)
d2510 1
a2510 2
	} */ *ap;
{
d2521 2
a2522 2
				vattr.va_atime.ts_sec = np->n_atim.tv_sec;
				vattr.va_atime.ts_nsec =
d2526 2
a2527 2
				vattr.va_mtime.ts_sec = np->n_mtim.tv_sec;
				vattr.va_mtime.ts_nsec =
d2541 3
a2543 1
nfsfifo_read(ap)
d2549 2
a2550 3
	} */ *ap;
{
	extern int (**fifo_vnodeop_p)();
d2565 3
a2567 1
nfsfifo_write(ap)
d2573 2
a2574 3
	} */ *ap;
{
	extern int (**fifo_vnodeop_p)();
d2591 3
a2593 1
nfsfifo_close(ap)
d2599 1
a2599 2
	} */ *ap;
{
d2603 1
a2603 1
	extern int (**fifo_vnodeop_p)();
d2615 2
a2616 2
				vattr.va_atime.ts_sec = np->n_atim.tv_sec;
				vattr.va_atime.ts_nsec =
d2620 2
a2621 2
				vattr.va_mtime.ts_sec = np->n_mtim.tv_sec;
				vattr.va_mtime.ts_nsec =
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_vnops.c,v 1.51.2.1 1995/10/17 15:36:26 ghudson Exp $	*/
d241 2
a242 2
extern u_long nfs_procids[NFS_NPROCS];
extern u_long nfs_prog, nfs_vers, nfs_true, nfs_false;
d282 1
a282 1
	register u_long *tl;
d300 1
a300 1
		nfsm_build(tl, u_long *, 3 * NFSX_UNSIGNED);
d480 1
a480 1
	register long t1;
d482 1
a482 1
	u_long *tl;
d557 1
a557 1
		nfsm_dissect(tl, u_long *, 2*NFSX_UNSIGNED);
d589 1
a589 1
	register u_long *tl;
d591 1
a591 1
	register long t1, t2;
d670 1
a670 1
		nfsm_build(tl, u_long *, NFSX_UNSIGNED);
d692 1
a692 1
		nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d695 1
a695 1
			nfsm_dissect(tl, u_long *, 4*NFSX_UNSIGNED);
d808 1
a808 1
	register u_long *tl;
d810 1
a810 1
	register long t1;
d836 1
a836 1
	register u_long *tl;
d838 1
a838 1
	register long t1;
d855 1
a855 1
		nfsm_build(tl, u_long *, NFSX_UNSIGNED*3);
d888 1
a888 1
	register u_long *tl;
d890 1
a890 1
	register long t1;
d910 1
a910 1
		nfsm_build(tl, u_long *, NFSX_UNSIGNED * 4);
d933 1
a933 1
			nfsm_dissect(tl, u_long *, 2*NFSX_UNSIGNED);
d966 1
a966 1
	register u_long *tl;
d968 1
a968 1
	register long t1, t2;
d975 1
a975 1
	u_long rdev;
d1044 1
a1044 1
	register u_long *tl;
d1046 1
a1046 1
	register long t1, t2;
d1116 1
a1116 1
	register u_long *tl;
d1118 1
a1118 1
	register long t2;
d1187 1
a1187 1
	register u_long *tl;
d1189 1
a1189 1
	register long t2;
d1226 1
a1226 1
	register u_long *tl;
d1228 1
a1228 1
	register long t2;
d1286 1
a1286 1
	register u_long *tl;
d1288 1
a1288 1
	register long t2;
d1323 1
a1323 1
	register u_long *tl;
d1325 1
a1325 1
	register long t2;
d1385 1
a1385 1
	register u_long *tl;
d1387 1
a1387 1
	register long t2;
d1447 1
a1447 1
	register u_long *tl;
d1449 1
a1449 1
	register long t1, t2;
d1531 1
a1531 1
	register u_long *tl;
d1533 1
a1533 1
	register long t2;
d1659 1
a1659 1
	register u_long *tl;
d1661 1
a1661 1
	register long t1;
d1690 1
a1690 1
		nfsm_build(tl, u_long *, 2 * NFSX_UNSIGNED);
d1697 1
a1697 1
		nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d1711 1
a1711 1
			nfsm_dissect(tl, u_long *, 2 * NFSX_UNSIGNED);
d1713 1
a1713 1
			dp->d_fileno = fxdr_unsigned(u_long, *tl++);
d1733 2
a1734 2
			nfsm_dissect(tl, u_long *, 2 * NFSX_UNSIGNED);
			off = fxdr_unsigned(u_long, *tl);
d1745 1
a1745 1
			nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d1808 1
a1808 1
	register u_long *tl;
d1810 1
a1810 1
	register long t1;
d1841 1
a1841 1
 		nfsm_build(tl, u_long *, 3 * NFSX_UNSIGNED);
d1852 1
a1852 1
		nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d1859 1
a1859 1
			nfsm_dissect(tl, u_long *, 4 * NFSX_UNSIGNED);
d1878 2
a1879 2
			nfsm_dissect(tl, u_long *, 2 * NFSX_UNSIGNED);
			fileno = fxdr_unsigned(u_long, *tl++);
d1926 1
a1926 1
			nfsm_dissect(tl, u_long *, 2 * NFSX_UNSIGNED);
d1928 1
a1928 1
				endoff = off = fxdr_unsigned(u_long, *tl++);
d1930 1
a1930 1
				endoff = fxdr_unsigned(u_long, *tl++);
d1938 1
a1938 1
			nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d2049 1
a2049 1
	register u_long *tl;
d2051 1
a2051 1
	register long t1, t2;
d2062 1
a2062 1
		nfsm_build(tl, u_long *, NFSX_UNSIGNED);
d2070 1
a2070 1
			nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_vnops.c,v 1.51 1995/10/09 11:25:30 mycroft Exp $	*/
d1586 1
a1589 7
	/*
	 * XXX
	 * We don't support cookies here, yet.
	 */
	if (ap->a_ncookies)
		return (EINVAL);

d1617 27
d1737 1
d1785 2
d1932 1
d1961 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
