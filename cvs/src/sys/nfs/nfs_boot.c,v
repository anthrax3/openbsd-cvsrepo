head	1.41;
access;
symbols
	OPENBSD_6_1:1.41.0.2
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.12
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.10
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.10
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.8
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.14
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.12
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.40;
commitid	QqHqT2WhCBWqYgGJ;

1.40
date	2016.11.22.12.11.38;	author mpi;	state Exp;
branches;
next	1.39;
commitid	1eYjfhjvOxaukV3n;

1.39
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.38;
commitid	RRi5waWu1LaKRicG;

1.38
date	2015.08.14.18.07.28;	author bluhm;	state Exp;
branches;
next	1.37;
commitid	mu9yDScTa557hRQD;

1.37
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	ncpqEGjDtSFuLAgn;

1.36
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.35;
commitid	t9FBKDfc4VDxpEy2;

1.35
date	2014.11.14.23.01.44;	author tedu;	state Exp;
branches;
next	1.34;
commitid	IWzLFxf7O2DJPe2b;

1.34
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.33;
commitid	uzzBR7hz9ncd4O6G;

1.33
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.32;
commitid	ZqXwxwmeo3l29NOg;

1.32
date	2014.05.07.08.26.38;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2014.03.20.09.18.01;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2013.09.20.23.51.44;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2013.09.12.13.12.33;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.22.09.13.36;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.03.20.03.38;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.19.22.24.18;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.27.04.30.50;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.20.12.43.57;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.09.15.50.51;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.31.22.27.43;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.19.05.47.47;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.17.14.14.12;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.26.01.10.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.04.13.14.29;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.02.01.47.08;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.14.23.37.33;	author mickey;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.01.03.10.07.19;	author deraadt;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	97.01.22.18.20.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.20.09.42.18;	author graichen;	state Exp;
branches;
next	1.8;

1.8
date	97.01.20.09.13.22;	author graichen;	state Exp;
branches;
next	1.7;

1.7
date	96.10.20.17.07.27;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.10.20.17.05.21;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.05.10.12.31.01;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.31.13.15.34;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.09.24.49;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.21;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.06.11.03.32.03;	author art;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@/*	$OpenBSD: nfs_boot.c,v 1.40 2016/11/22 12:11:38 mpi Exp $ */
/*	$NetBSD: nfs_boot.c,v 1.26 1996/05/07 02:51:25 thorpej Exp $	*/

/*
 * Copyright (c) 1995 Adam Glass, Gordon Ross
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/mbuf.h>
#include <sys/reboot.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_var.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/if_ether.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/nfsdiskless.h>
#include <nfs/krpc.h>
#include <nfs/xdr_subs.h>
#include <nfs/nfs_var.h>

#include "ether.h"

#if !defined(NFSCLIENT) || (NETHER == 0 && NFDDI == 0)

int
nfs_boot_init(struct nfs_diskless *nd, struct proc *procp)
{
	panic("nfs_boot_init: NFSCLIENT not enabled in kernel");
}

int
nfs_boot_getfh(struct sockaddr_in *bpsin, char *key,
    struct nfs_dlmount *ndmntp, int retries)
{
	/* can not get here */
	return (EOPNOTSUPP);
}

#else

/*
 * Support for NFS diskless booting, specifically getting information
 * about where to boot from, what pathnames, etc.
 *
 * This implementation uses RARP and the bootparam RPC.
 * We are forced to implement RPC anyway (to get file handles)
 * so we might as well take advantage of it for bootparam too.
 *
 * The diskless boot sequence goes as follows:
 * (1) Use RARP to get our interface address
 * (2) Use RPC/bootparam/whoami to get our hostname,
 *     our IP address, and the server's IP address.
 * (3) Use RPC/bootparam/getfile to get the root path
 * (4) Use RPC/mountd to get the root file handle
 * (5) Use RPC/bootparam/getfile to get the swap path
 * (6) Use RPC/mountd to get the swap file handle
 *
 * (This happens to be the way Sun does it too.)
 */

/* bootparam RPC */
static int bp_whoami(struct sockaddr_in *bpsin,
	struct in_addr *my_ip, struct in_addr *gw_ip);
static int bp_getfile(struct sockaddr_in *bpsin, char *key,
	struct sockaddr_in *mdsin, char *servname, char *path, int retries);

/* mountd RPC */
static int md_mount(struct sockaddr_in *mdsin, char *path,
	struct nfs_args *argp);

char	*nfsbootdevname;

/*
 * Called with an empty nfs_diskless struct to be filled in.
 */
int
nfs_boot_init(struct nfs_diskless *nd, struct proc *procp)
{
	struct ifreq ireq;
	struct in_aliasreq ifra;
	struct in_addr my_ip, gw_ip;
	struct sockaddr_in bp_sin;
	struct sockaddr_in *sin;
	struct ifnet *ifp;
	struct socket *so;
	struct ifaddr *ifa;
	char addr[INET_ADDRSTRLEN];
	int s, error;

	/*
	 * Find an interface, rarp for its ip address, stuff it, the
	 * implied broadcast addr, and netmask into a nfs_diskless struct.
	 *
	 * This was moved here from nfs_vfsops.c because this procedure
	 * would be quite different if someone decides to write (i.e.) a
	 * BOOTP version of this file (might not use RARP, etc.)
	 */

	/*
	 * Find a network interface.
	 */
	if (nfsbootdevname)
		ifp = ifunit(nfsbootdevname);
	else {
		TAILQ_FOREACH(ifp, &ifnet, if_list) {
			if ((ifp->if_flags &
			     (IFF_LOOPBACK|IFF_POINTOPOINT)) == 0)
				break;
		}
	}
	if (ifp == NULL)
		panic("nfs_boot: no suitable interface");
	bcopy(ifp->if_xname, ireq.ifr_name, IFNAMSIZ);
	printf("nfs_boot: using interface %s, with revarp & bootparams\n",
	    ireq.ifr_name);

	/*
	 * Bring up the interface.
	 *
	 * Get the old interface flags and or IFF_UP into them; if
	 * IFF_UP set blindly, interface selection can be clobbered.
	 */
	if ((error = socreate(AF_INET, &so, SOCK_DGRAM, 0)) != 0)
		panic("nfs_boot: socreate, error=%d", error);
	NET_LOCK(s);
	error = ifioctl(so, SIOCGIFFLAGS, (caddr_t)&ireq, procp);
	NET_UNLOCK(s);
	if (error)
		panic("nfs_boot: GIFFLAGS, error=%d", error);
	ireq.ifr_flags |= IFF_UP;
	NET_LOCK(s);
	error = ifioctl(so, SIOCSIFFLAGS, (caddr_t)&ireq, procp);
	NET_UNLOCK(s);
	if (error)
		panic("nfs_boot: SIFFLAGS, error=%d", error);

	/*
	 * Do RARP for the interface address.
	 */
	if ((error = revarpwhoami(&my_ip, ifp)) != 0)
		panic("reverse arp not answered by rarpd(8) or dhcpd(8)");
	inet_ntop(AF_INET, &my_ip, addr, sizeof(addr));
	printf("nfs_boot: client_addr=%s\n", addr);

	/*
	 * Do enough of ifconfig(8) so that the chosen interface
	 * can talk to the servers.  (just set the address)
	 */
	memset(&ifra, 0, sizeof(ifra));
	bcopy(ifp->if_xname, ifra.ifra_name, sizeof(ifra.ifra_name));

	sin = &ifra.ifra_addr;
	sin->sin_len = sizeof(*sin);
	sin->sin_family = AF_INET;
	sin->sin_addr.s_addr = my_ip.s_addr;
	NET_LOCK(s);
	error = ifioctl(so, SIOCAIFADDR, (caddr_t)&ifra, procp);
	NET_UNLOCK(s);
	if (error)
		panic("nfs_boot: set if addr, error=%d", error);

	soclose(so);

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET)
			break;
	}
	if (ifa == NULL)
		panic("nfs_boot: address not configured on %s", ifp->if_xname);

	/*
	 * Get client name and gateway address.
	 * RPC: bootparam/whoami
	 * The server address returned by the WHOAMI call
	 * is used for all subsequent bootparam RPCs.
	 */
	memset(&bp_sin, 0, sizeof(bp_sin));
	bp_sin.sin_len = sizeof(bp_sin);
	bp_sin.sin_family = AF_INET;
	bp_sin.sin_addr.s_addr = ifatoia(ifa)->ia_broadaddr.sin_addr.s_addr;
	hostnamelen = MAXHOSTNAMELEN;

	/* this returns gateway IP address */
	error = bp_whoami(&bp_sin, &my_ip, &gw_ip);
	if (error)
		panic("nfs_boot: bootparam whoami, error=%d", error);
	inet_ntop(AF_INET, &bp_sin.sin_addr, addr, sizeof(addr));
	printf("nfs_boot: server_addr=%s hostname=%s\n", addr, hostname);

	bcopy(&bp_sin, &nd->nd_boot, sizeof(bp_sin));

	return (0);
}

/*
 * bpsin:	bootparam server
 * key:		root or swap
 * ndmntp:	output
 */
int
nfs_boot_getfh(struct sockaddr_in *bpsin, char *key,
    struct nfs_dlmount *ndmntp, int retries)
{
	struct nfs_args *args;
	char pathname[MAXPATHLEN];
	char *sp, *dp, *endp;
	struct sockaddr_in *sin;
	int error;

	args = &ndmntp->ndm_args;

	/* Initialize mount args. */
	memset(args, 0, sizeof(*args));
	args->addr     = sintosa(&ndmntp->ndm_saddr);
	args->addrlen  = args->addr->sa_len;
	args->sotype   = SOCK_DGRAM;
	args->fh       = ndmntp->ndm_fh;
	args->hostname = ndmntp->ndm_host;
	args->flags    = NFSMNT_NFSV3;
#ifdef	NFS_BOOT_OPTIONS
	args->flags    |= NFS_BOOT_OPTIONS;
#endif
#ifdef	NFS_BOOT_RWSIZE
	/*
	 * Reduce rsize,wsize for interfaces that consistently
	 * drop fragments of long UDP messages.	 (i.e. wd8003).
	 * You can always change these later via remount.
	 */
	args->flags   |= NFSMNT_WSIZE | NFSMNT_RSIZE;
	args->wsize    = NFS_BOOT_RWSIZE;
	args->rsize    = NFS_BOOT_RWSIZE;
#endif

	sin = &ndmntp->ndm_saddr;

	/*
	 * Get server:pathname for "key" (root or swap)
	 * using RPC to bootparam/getfile
	 */
	error = bp_getfile(bpsin, key, sin, ndmntp->ndm_host, pathname,
	    retries);
	if (error) {
		printf("nfs_boot: bootparam get %s: %d\n", key, error);
		return (error);
	}

	/*
	 * Get file handle for "key" (root or swap)
	 * using RPC to mountd/mount
	 */
	error = md_mount(sin, pathname, args);
	if (error) {
		printf("nfs_boot: mountd %s, error=%d\n", key, error);
		return (error);
	}

	/* Set port number for NFS use. */
	/* XXX: NFS port is always 2049, right? */
	error = krpc_portmap(sin, NFS_PROG,
	    (args->flags & NFSMNT_NFSV3) ? NFS_VER3 : NFS_VER2,
	    &sin->sin_port);
	if (error) {
		printf("nfs_boot: portmap NFS, error=%d\n", error);
		return (error);
	}

	/* Construct remote path (for getmntinfo(3)) */
	dp = ndmntp->ndm_host;
	endp = dp + MNAMELEN - 1;
	dp += strlen(dp);
	*dp++ = ':';
	for (sp = pathname; *sp && dp < endp;)
		*dp++ = *sp++;
	*dp = '\0';

	return (0);
}


/*
 * RPC: bootparam/whoami
 * Given client IP address, get:
 *	client name	(hostname)
 *	domain name (domainname)
 *	gateway address
 *
 * The hostname and domainname are set here for convenience.
 *
 * Note - bpsin is initialized to the broadcast address,
 * and will be replaced with the bootparam server address
 * after this call is complete.  Have to use PMAP_PROC_CALL
 * to make sure we get responses only from a servers that
 * know about us (don't want to broadcast a getport call).
 */
static int
bp_whoami(struct sockaddr_in *bpsin, struct in_addr *my_ip,
    struct in_addr *gw_ip)
{
	/* RPC structures for PMAPPROC_CALLIT */
	struct whoami_call {
		u_int32_t call_prog;
		u_int32_t call_vers;
		u_int32_t call_proc;
		u_int32_t call_arglen;
	} *call;
	struct callit_reply {
		u_int32_t port;
		u_int32_t encap_len;
		/* encapsulated data here */
	} *reply;

	struct mbuf *m, *from;
	struct sockaddr_in *sin;
	int error, msg_len;
	int16_t port;

	/*
	 * Build request message for PMAPPROC_CALLIT.
	 */
	m = m_get(M_WAIT, MT_DATA);
	call = mtod(m, struct whoami_call *);
	m->m_len = sizeof(*call);
	call->call_prog = txdr_unsigned(BOOTPARAM_PROG);
	call->call_vers = txdr_unsigned(BOOTPARAM_VERS);
	call->call_proc = txdr_unsigned(BOOTPARAM_WHOAMI);

	/*
	 * append encapsulated data (client IP address)
	 */
	m->m_next = xdr_inaddr_encode(my_ip);
	call->call_arglen = txdr_unsigned(m->m_next->m_len);

	/* RPC: portmap/callit */
	bpsin->sin_port = htons(PMAPPORT);
	from = NULL;
	error = krpc_call(bpsin, PMAPPROG, PMAPVERS,
			PMAPPROC_CALLIT, &m, &from, -1);
	if (error)
		return error;

	/*
	 * Parse result message.
	 */
	if (m->m_len < sizeof(*reply)) {
		m = m_pullup(m, sizeof(*reply));
		if (m == NULL)
			goto bad;
	}
	reply = mtod(m, struct callit_reply *);
	port = fxdr_unsigned(u_int32_t, reply->port);
	msg_len = fxdr_unsigned(u_int32_t, reply->encap_len);
	m_adj(m, sizeof(*reply));

	/*
	 * Save bootparam server address
	 */
	sin = mtod(from, struct sockaddr_in *);
	bpsin->sin_port = htons(port);
	bpsin->sin_addr.s_addr = sin->sin_addr.s_addr;

	/* client name */
	hostnamelen = MAXHOSTNAMELEN-1;
	m = xdr_string_decode(m, hostname, &hostnamelen);
	if (m == NULL)
		goto bad;

	/* domain name */
	domainnamelen = MAXHOSTNAMELEN-1;
	m = xdr_string_decode(m, domainname, &domainnamelen);
	if (m == NULL)
		goto bad;

	/* gateway address */
	m = xdr_inaddr_decode(m, gw_ip);
	if (m == NULL)
		goto bad;

	/* success */
	goto out;

bad:
	printf("nfs_boot: bootparam_whoami: bad reply\n");
	error = EBADRPC;

out:
	m_freem(from);
	m_freem(m);
	return(error);
}


/*
 * RPC: bootparam/getfile
 * Given client name and file "key", get:
 *	server name
 *	server IP address
 *	server pathname
 */
static int
bp_getfile(struct sockaddr_in *bpsin, char *key, struct sockaddr_in *md_sin,
    char *serv_name, char *pathname, int retries)
{
	struct mbuf *m;
	struct sockaddr_in *sin;
	struct in_addr inaddr;
	int error, sn_len, path_len;

	/*
	 * Build request message.
	 */

	/* client name (hostname) */
	m  = xdr_string_encode(hostname, hostnamelen);
	if (m == NULL)
		return (ENOMEM);

	/* key name (root or swap) */
	m->m_next = xdr_string_encode(key, strlen(key));
	if (m->m_next == NULL)
		return (ENOMEM);

	/* RPC: bootparam/getfile */
	error = krpc_call(bpsin, BOOTPARAM_PROG, BOOTPARAM_VERS,
			BOOTPARAM_GETFILE, &m, NULL, retries);
	if (error)
		return error;

	/*
	 * Parse result message.
	 */

	/* server name */
	sn_len = MNAMELEN-1;
	m = xdr_string_decode(m, serv_name, &sn_len);
	if (m == NULL)
		goto bad;

	/* server IP address (mountd/NFS) */
	m = xdr_inaddr_decode(m, &inaddr);
	if (m == NULL)
		goto bad;

	/* server pathname */
	path_len = MAXPATHLEN-1;
	m = xdr_string_decode(m, pathname, &path_len);
	if (m == NULL)
		goto bad;

	/* setup server socket address */
	sin = md_sin;
	memset(sin, 0, sizeof(*sin));
	sin->sin_len = sizeof(*sin);
	sin->sin_family = AF_INET;
	sin->sin_addr = inaddr;

	/* success */
	goto out;

bad:
	printf("nfs_boot: bootparam_getfile: bad reply\n");
	error = EBADRPC;

out:
	m_freem(m);
	return(error);
}


/*
 * RPC: mountd/mount
 * Given a server pathname, get an NFS file handle.
 * Also, sets sin->sin_port to the NFS service port.
 * mdsin:	mountd server address
 */
static int
md_mount(struct sockaddr_in *mdsin, char *path, struct nfs_args *argp)
{
	/* The RPC structures */
	struct rdata {
		u_int32_t errno;
		union {
			u_int8_t v2fh[NFSX_V2FH];
			struct {
				u_int32_t fhlen;
				u_int8_t fh[1];
			} v3fh;
		} fh;
	} *rdata;
	struct mbuf *m;
	u_int8_t *fh;
	int minlen, error;
	int mntver;

	mntver = (argp->flags & NFSMNT_NFSV3) ? 3 : 2;
	do {
		error = krpc_portmap(mdsin, RPCPROG_MNT, mntver,
		    &mdsin->sin_port);
		if (error)
			continue;

		m = xdr_string_encode(path, strlen(path));
		if (m == NULL)
			return ENOMEM;

		/* Do RPC to mountd. */
		error = krpc_call(mdsin, RPCPROG_MNT, mntver,
		    RPCMNT_MOUNT, &m, NULL, -1);

		if (error != EPROGMISMATCH)
			break;
		/* Try lower version of mountd. */
	} while (--mntver >= 1);
	if (error)
		return error;	/* message already freed */

	if (mntver != 3)
		argp->flags &= ~NFSMNT_NFSV3;

	/* The reply might have only the errno. */
	if (m->m_len < 4)
		goto bad;
	/* Have at least errno, so check that. */
	rdata = mtod(m, struct rdata *);
	error = fxdr_unsigned(u_int32_t, rdata->errno);
	if (error)
		goto out;

	 /* Have errno==0, so the fh must be there. */
	if (mntver == 3) {
		argp->fhsize = fxdr_unsigned(u_int32_t, rdata->fh.v3fh.fhlen);
		if (argp->fhsize > NFSX_V3FHMAX)
			goto bad;
		minlen = 2 * sizeof(u_int32_t) + argp->fhsize;
	} else {
		argp->fhsize = NFSX_V2FH;
		minlen = sizeof(u_int32_t) + argp->fhsize;
	}

	if (m->m_len < minlen) {
		m = m_pullup(m, minlen);
		if (m == NULL)
			return (EBADRPC);
		rdata = mtod(m, struct rdata *);
	}

	fh = (mntver == 3) ? rdata->fh.v3fh.fh : rdata->fh.v2fh;
	bcopy(fh, argp->fh, argp->fhsize);

	goto out;

bad:
	error = EBADRPC;

out:
	m_freem(m);
	return error;
}

#endif /* ifdef NFSCLIENT */
@


1.40
log
@Enforce that ifioctl() is called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.39 2015/09/01 21:24:04 bluhm Exp $ */
d162 1
a162 1
	s = splsoftnet();
d164 1
a164 1
	splx(s);
d168 1
a168 1
	s = splsoftnet();
d170 1
a170 1
	splx(s);
d193 1
a193 1
	s = splsoftnet();
d195 1
a195 1
	splx(s);
@


1.39
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.38 2015/08/14 18:07:28 bluhm Exp $ */
d125 1
a125 1
	int error;
d162 1
d164 1
d168 1
d170 1
d193 1
d195 1
@


1.38
log
@Replace sockaddr casts with the proper satosin() or satosin6() calls.
From David Hill;  OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.37 2015/07/15 22:16:42 deraadt Exp $ */
d245 1
a245 1
	args->addr     = (struct sockaddr *)&ndmntp->ndm_saddr;
@


1.37
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.36 2014/12/05 15:50:04 mpi Exp $ */
d185 1
a185 1
	sin = (struct sockaddr_in *)&ifra.ifra_addr;
@


1.36
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.35 2014/11/14 23:01:44 tedu Exp $ */
d417 2
a418 4
	if (from)
		m_freem(from);
	if (m)
		m_freem(m);
@


1.35
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.34 2014/09/14 14:17:26 jsg Exp $ */
d44 1
@


1.34
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.33 2014/09/08 06:24:13 jsg Exp $ */
d181 1
a181 1
	bzero(&ifra, sizeof(ifra));
d207 1
a207 1
	bzero((caddr_t)&bp_sin, sizeof(bp_sin));
d243 1
a243 1
	bzero((caddr_t) args, sizeof(*args));
d483 1
a483 1
	bzero((caddr_t)sin, sizeof(*sin));
@


1.33
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.32 2014/05/07 08:26:38 mpi Exp $ */
a35 1
#include <sys/proc.h>
@


1.32
log
@Remove the last hacks concerning the global list of IPv4 addresses in the
source address selection logic.

These hacks were only relevant for the NFS diskless boot code in order to
pick the local broadcast address of the only configured interface.  So, be
explicit and set this address directly.

Tested by florian@@, ok henning@@, beck@@, chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.31 2014/03/20 09:18:01 mpi Exp $ */
a44 1
#include <net/route.h>
@


1.31
log
@Kill NFS_BOOT_GATEWAY, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.30 2013/11/11 09:15:35 mpi Exp $ */
d124 1
d196 7
a205 2
	 * Use the old broadcast address for the WHOAMI
	 * call because we do not yet know our netmask.
d212 1
a212 1
	bp_sin.sin_addr.s_addr = INADDR_BROADCAST;
@


1.30
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.29 2013/09/20 23:51:44 fgsch Exp $ */
a214 44

#ifdef	NFS_BOOT_GATEWAY
	/*
	 * XXX - This code is conditionally compiled only because
	 * many bootparam servers (in particular, SunOS 4.1.3)
	 * always set the gateway address to their own address.
	 * The bootparam server is not necessarily the gateway.
	 * We could just believe the server, and at worst you would
	 * need to delete the incorrect default route before adding
	 * the correct one, but for simplicity, ignore the gateway.
	 * If your server is OK, you can turn on this option.
	 *
	 * If the gateway address is set, add a default route.
	 * (The mountd RPCs may go across a gateway.)
	 */
	if (gw_ip.s_addr) {
		struct sockaddr dst, gw, mask;
		struct rt_addrinfo info;
		/* Destination: (default) */
		bzero((caddr_t)&dst, sizeof(dst));
		dst.sa_len = sizeof(dst);
		dst.sa_family = AF_INET;
		/* Gateway: */
		bzero((caddr_t)&gw, sizeof(gw));
		sin = (struct sockaddr_in *)&gw;
		sin->sin_len = sizeof(gw);
		sin->sin_family = AF_INET;
		sin->sin_addr.s_addr = gw_ip.s_addr;
		/* Mask: (zero length) */
		bzero(&mask, sizeof(mask));
		bzero(&info, sizeof(info));
		info.rti_info[RTAX_DST] = &dst;
		info.rti_info[RTAX_GATEWAY] = &gw;
		info.rti_info[RTAX_NETMASK] = &mask;
		info.rti_flags = (RTF_UP | RTF_GATEWAY | RTF_STATIC);

		inet_ntop(AF_INET, gw_ip, addr, sizeof(addr));
		printf("nfs_boot: gateway=%s\n", addr);
		/* add, dest, gw, mask, flags, 0 */
		error = rtrequest1(RTM_ADD, &info, RTP_STATIC, NULL, 0);
		if (error)
			printf("nfs_boot: add route, error=%d\n", error);
	}
#endif
@


1.29
log
@Add support for root on nfs using v3. Code adapted from NetBSD.
Tested on sparc by miod, octeon by aalm and armv7 by me.
miod ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.28 2013/09/12 13:12:33 deraadt Exp $ */
d124 1
d175 2
a176 1
	printf("nfs_boot: client_addr=%s\n", inet_ntoa(my_ip));
d213 2
a214 2
	printf("nfs_boot: server_addr=%s hostname=%s\n",
	    inet_ntoa(bp_sin.sin_addr), hostname);
d251 2
a252 1
		printf("nfs_boot: gateway=%s\n", inet_ntoa(gw_ip));
@


1.28
log
@typo; Eivind Evensen
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.27 2013/05/22 09:13:36 mpi Exp $ */
d107 1
a107 1
	u_char *fh);
d271 1
d277 24
d318 1
a318 1
	error = md_mount(sin, pathname, ndmntp->ndm_fh);
d326 3
a328 1
	error = krpc_portmap(sin, NFS_PROG, NFS_VER2, &sin->sin_port);
d330 1
a330 1
		printf("nfs_boot: portmap NFS/v2, error=%d\n", error);
d545 1
a545 1
md_mount(struct sockaddr_in *mdsin, char *path, u_char *fhp)
d550 7
a556 1
		u_int8_t  fh[NFSX_V2FH];
d559 10
a568 1
	int error;
d570 3
a572 4
	/* Get port number for MOUNTD. */
	error = krpc_portmap(mdsin, RPCPROG_MNT, RPCMNT_VER1,
						 &mdsin->sin_port);
	if (error) return error;
d574 8
a581 7
	m = xdr_string_encode(path, strlen(path));
	if (m == NULL)
		return ENOMEM;

	/* Do RPC to mountd. */
	error = krpc_call(mdsin, RPCPROG_MNT, RPCMNT_VER1,
			RPCMNT_MOUNT, &m, NULL, -1);
d585 3
d598 12
a609 2
	if (m->m_len < sizeof(*rdata)) {
		m = m_pullup(m, sizeof(*rdata));
d611 1
a611 1
			goto bad;
d614 4
a617 1
	bcopy(rdata->fh, fhp, NFSX_V2FH);
@


1.27
log
@Use SIOCAIFADDR rather than SIOCSIFADDR to set the address.

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.26 2010/04/03 20:03:38 krw Exp $ */
d199 1
a199 1
	 * is used for all subsequent booptaram RPCs.
@


1.26
log
@Don't return 0 if error is set to EBADRPC. Found by jsg@@ and clang.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.25 2009/10/19 22:24:18 jsg Exp $ */
d48 1
d118 1
d180 4
a183 2
	sin = (struct sockaddr_in *)&ireq.ifr_addr;
	bzero((caddr_t)sin, sizeof(*sin));
d187 1
a187 1
	error = ifioctl(so, SIOCSIFADDR, (caddr_t)&ireq, procp);
@


1.25
log
@antsy
no binary change apart from nfsm_reqhead() which is clearly correct.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.24 2008/06/11 04:52:27 blambert Exp $ */
d503 1
a503 1
	return(0);
@


1.24
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.23 2008/05/27 04:30:50 deraadt Exp $ */
d63 1
a63 3
nfs_boot_init(nd, procp)
	struct nfs_diskless *nd;
	struct proc *procp;
d69 2
a70 5
nfs_boot_getfh(bpsin, key, ndmntp, retries)
	struct sockaddr_in *bpsin;
	char *key;
	struct nfs_dlmount *ndmntp;
	int retries;
d114 1
a114 3
nfs_boot_init(nd, procp)
	struct nfs_diskless *nd;
	struct proc *procp;
d258 5
d264 2
a265 5
nfs_boot_getfh(bpsin, key, ndmntp, retries)
	struct sockaddr_in *bpsin;	/* bootparam server */
	char *key;			/* root or swap */
	struct nfs_dlmount *ndmntp;	/* output */
	int retries;
d332 2
a333 4
bp_whoami(bpsin, my_ip, gw_ip)
	struct sockaddr_in *bpsin;
	struct in_addr *my_ip;
	struct in_addr *gw_ip;
d438 2
a439 7
bp_getfile(bpsin, key, md_sin, serv_name, pathname, retries)
	struct sockaddr_in *bpsin;
	char *key;
	struct sockaddr_in *md_sin;
	char *serv_name;
	char *pathname;
	int retries;
d511 1
d514 1
a514 4
md_mount(mdsin, path, fhp)
	struct sockaddr_in *mdsin;		/* mountd server address */
	char *path;
	u_char *fhp;
@


1.23
log
@be much more clear about revarp failures; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.22 2008/05/20 12:43:57 claudio Exp $ */
d42 1
d146 1
a146 2
		for (ifp = TAILQ_FIRST(&ifnet); ifp != NULL;
		    ifp = TAILQ_NEXT(ifp, if_list)) {
@


1.22
log
@Fix last commit, it is rtrequest1() and not rtrequest(). Lucky me it seems
that the code is ifdef-ed out all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.21 2008/05/09 15:50:51 claudio Exp $ */
d178 1
a178 1
		panic("revarp failed, error=%d", error);
@


1.21
log
@Another rtrequest() rtrequest1() replacement.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.20 2008/03/31 22:27:43 deraadt Exp $ */
d254 1
a254 1
		error = rtrequest(RTM_ADD, &info, RTP_STATIC, NULL, 0);
@


1.20
log
@Refine "netboot" interface group semantics to indicate the interface we
booted from to the most precision; preferring the boot device, or if that
is not known, the root device
discussed with miod and reyk
tested by beck
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.19 2008/03/19 05:47:47 deraadt Exp $ */
d233 1
d246 5
d254 1
a254 2
		error = rtrequest(RTM_ADD, &dst, (struct sockaddr *)&gw,
		    &mask, (RTF_UP | RTF_GATEWAY | RTF_STATIC), NULL, 0);
@


1.19
log
@label all interfaces we netboot from in group "netboot", in a MI fashion
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.18 2006/06/17 14:14:12 henning Exp $ */
a156 1
	if_addgroup(ifp, "netboot");
@


1.18
log
@adopt to extended rtrequest / rtalloc1 api
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.17 2006/05/26 01:10:01 deraadt Exp $ */
d157 1
@


1.17
log
@prettier printing
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.16 2004/11/04 13:14:29 pedro Exp $ */
d249 1
a249 1
		    &mask, (RTF_UP | RTF_GATEWAY | RTF_STATIC), NULL);
@


1.16
log
@implememtation -> implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.15 2002/06/02 01:47:08 deraadt Exp $ */
d155 2
a156 1
	printf("nfs_boot: using network interface '%s'\n", ireq.ifr_name);
@


1.15
log
@correct fake nfs_boot_getfh(); ski@@wuhjuhbuh.2y.net
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.14 2002/03/14 01:27:13 millert Exp $ */
d86 1
a86 1
 * This implememtation uses RARP and the bootparam RPC.
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.13 2002/01/16 21:51:16 ericj Exp $ */
d70 1
a70 1
nfs_boot_getfh(bpsin, key, ndmntp)
d74 1
@


1.13
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.12 2001/11/14 23:37:33 mickey Exp $ */
d102 4
a105 4
static int bp_whoami __P((struct sockaddr_in *bpsin,
	struct in_addr *my_ip, struct in_addr *gw_ip));
static int bp_getfile __P((struct sockaddr_in *bpsin, char *key,
	struct sockaddr_in *mdsin, char *servname, char *path, int retries));
d108 2
a109 2
static int md_mount __P((struct sockaddr_in *mdsin, char *path,
	u_char *fh));
@


1.12
log
@allow swaples diskless configs; deradt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.11 1999/01/03 10:07:19 deraadt Exp $ */
d143 3
a145 2
	else
		for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
d149 2
d154 1
a154 2
	printf("nfs_boot: using network interface '%s'\n",
	    ireq.ifr_name);
@


1.12.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.13 2002/01/16 21:51:16 ericj Exp $ */
d143 2
a144 3
	else {
		for (ifp = TAILQ_FIRST(&ifnet); ifp != NULL;
		    ifp = TAILQ_NEXT(ifp, if_list)) {
a147 2
		}
	}
d151 2
a152 1
	printf("nfs_boot: using network interface '%s'\n", ireq.ifr_name);
@


1.12.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.12.2.1 2002/01/31 22:55:47 niklas Exp $ */
d70 1
a70 1
nfs_boot_getfh(bpsin, key, ndmntp, retries)
a73 1
	int retries;
d102 4
a105 4
static int bp_whoami(struct sockaddr_in *bpsin,
	struct in_addr *my_ip, struct in_addr *gw_ip);
static int bp_getfile(struct sockaddr_in *bpsin, char *key,
	struct sockaddr_in *mdsin, char *servname, char *path, int retries);
d108 2
a109 2
static int md_mount(struct sockaddr_in *mdsin, char *path,
	u_char *fh);
@


1.11
log
@print addresses using inet_ntoa ( )
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.10 1997/01/22 18:20:49 deraadt Exp $ */
d69 1
a69 1
void
d76 1
d105 1
a105 1
	struct sockaddr_in *mdsin, char *servname, char *path));
d256 2
a257 2
void
nfs_boot_getfh(bpsin, key, ndmntp)
d261 1
d274 6
a279 3
	error = bp_getfile(bpsin, key, sin, ndmntp->ndm_host, pathname);
	if (error)
		panic("nfs_boot: bootparam get %s: %d", key, error);
d286 4
a289 2
	if (error)
		panic("nfs_boot: mountd %s, error=%d", key, error);
d294 4
a297 2
	if (error)
		panic("nfs_boot: portmap NFS/v2, error=%d", error);
d308 1
d371 1
a371 1
			PMAPPROC_CALLIT, &m, &from);
d436 1
a436 1
bp_getfile(bpsin, key, md_sin, serv_name, pathname)
d442 1
d465 1
a465 1
			BOOTPARAM_GETFILE, &m, NULL);
d540 1
a540 1
			RPCMNT_MOUNT, &m, NULL);
@


1.11.6.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d69 1
a69 1
int
a75 1
	return (EOPNOTSUPP);
d104 1
a104 1
	struct sockaddr_in *mdsin, char *servname, char *path, int retries));
d255 2
a256 2
int
nfs_boot_getfh(bpsin, key, ndmntp, retries)
a259 1
	int retries;
d272 3
a274 6
	error = bp_getfile(bpsin, key, sin, ndmntp->ndm_host, pathname,
	    retries);
	if (error) {
		printf("nfs_boot: bootparam get %s: %d\n", key, error);
		return (error);
	}
d281 2
a282 4
	if (error) {
		printf("nfs_boot: mountd %s, error=%d\n", key, error);
		return (error);
	}
d287 2
a288 4
	if (error) {
		printf("nfs_boot: portmap NFS/v2, error=%d\n", error);
		return (error);
	}
a298 1
	return (0);
d361 1
a361 1
			PMAPPROC_CALLIT, &m, &from, -1);
d426 1
a426 1
bp_getfile(bpsin, key, md_sin, serv_name, pathname, retries)
a431 1
	int retries;
d454 1
a454 1
			BOOTPARAM_GETFILE, &m, NULL, retries);
d529 1
a529 1
			RPCMNT_MOUNT, &m, NULL, -1);
@


1.11.6.2
log
@Merge in trunk
@
text
@d143 2
a144 3
	else {
		for (ifp = TAILQ_FIRST(&ifnet); ifp != NULL;
		    ifp = TAILQ_NEXT(ifp, if_list)) {
a147 2
		}
	}
d151 2
a152 1
	printf("nfs_boot: using network interface '%s'\n", ireq.ifr_name);
@


1.11.6.3
log
@Merge in -current from roughly a week ago
@
text
@d102 4
a105 4
static int bp_whoami(struct sockaddr_in *bpsin,
	struct in_addr *my_ip, struct in_addr *gw_ip);
static int bp_getfile(struct sockaddr_in *bpsin, char *key,
	struct sockaddr_in *mdsin, char *servname, char *path, int retries);
d108 2
a109 2
static int md_mount(struct sockaddr_in *mdsin, char *path,
	u_char *fh);
@


1.11.6.4
log
@Sync the SMP branch with 3.3
@
text
@d70 1
a70 1
nfs_boot_getfh(bpsin, key, ndmntp, retries)
a73 1
	int retries;
@


1.10
log
@get the ethernet/fddi issue half right. This needs to be fixed better
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.9 1997/01/20 09:42:18 graichen Exp $ */
d174 1
a174 1
	printf("nfs_boot: client_addr=0x%x\n", (u_int32_t)ntohl(my_ip.s_addr));
d209 2
a210 3
	printf("nfs_boot: server_addr=0x%x\n",
		   (u_int32_t)ntohl(bp_sin.sin_addr.s_addr));
	printf("nfs_boot: hostname=%s\n", hostname);
d241 1
a241 1
		printf("nfs_boot: gateway=0x%x\n", ntohl(gw_ip.s_addr));
@


1.9
log
@better use (NETHER == 0) instead of NETHER == 0
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.8 1997/01/20 09:13:22 graichen Exp $ */
d57 1
a57 1
#if !defined(NFSCLIENT) || (NETHER == 0)
d59 4
a62 1
int nfs_boot_init(nd, procp)
d78 1
a78 1
#else /* (if !defined(NFSCLIENT) || (NETHER == 0)) */
@


1.8
log
@replace #ifndef NFSCLIENT with #if !defined(NFSCLIENT) || NETHER == 0
because revarpwhoami is defined in if_ether.c and netbooting without
an ethernet card is very unusual :-)

p.s.: seems like nobody uses OpenBSD in machines without a network
card - because due to this it was'nt possible to build a kernel for
such a configuration ...
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.7 1996/10/20 17:07:27 briggs Exp $ */
d57 1
a57 1
#if !defined(NFSCLIENT) || NETHER == 0
d75 1
a75 1
#else /* (if !defined(NFSCLIENT) || NETHER == 0) */
@


1.7
log
@Fix panic message if NFSCLIENT is not defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.6 1996/10/20 17:05:21 briggs Exp $ */
d57 1
a57 1
#ifndef NFSCLIENT
d75 1
a75 1
#else /* (ifdef NFSCLIENT) */
@


1.6
log
@Make support for booting over NFS dependent on NFSCLIENT instead of NETHER.
Suggested in a NetBSD PR from Paul Goyette.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.5 1996/05/10 12:31:01 deraadt Exp $ */
d63 1
a63 1
	panic("nfs_boot_init: no ether");
@


1.5
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_boot.c,v 1.3 1996/02/29 09:24:49 niklas Exp $ */
d57 1
a57 2
#include "ether.h"
#if NETHER == 0
d75 1
a75 1
#else /* NETHER */
d558 1
a558 1
#endif /* NETHER */
@


1.4
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d2 1
a2 1
/*	$NetBSD: nfs_boot.c,v 1.25 1996/02/18 11:53:41 fvdl Exp $	*/
d147 1
a147 1
	sprintf(ireq.ifr_name, "%s%d", ifp->if_name, ifp->if_unit);
@


1.3
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: nfs_boot.c,v 1.23 1996/02/13 17:53:33 gwr Exp $ */
d50 1
a50 1
#include <nfs/nfsv2.h>
d67 9
a107 4
/* other helpers */
static void get_path_and_handle __P((struct sockaddr_in *bpsin,
	char *key, struct nfs_dlmount *ndmntp));

d172 1
a172 1
	printf("nfs_boot: client_addr=0x%x\n", ntohl(my_ip.s_addr));
d208 1
a208 1
		   ntohl(bp_sin.sin_addr.s_addr));
d271 1
a271 2
	error = bp_getfile(bpsin, key, sin,
	    ndmntp->ndm_host, pathname);
d512 1
a512 1
		u_int8_t  fh[NFS_FHSIZE];
d524 1
a524 1
		return (ENOMEM);
d541 1
a541 1
	/* Have errno==0, so the fh must be there. */
d548 1
a548 1
	bcopy(rdata->fh, fhp, NFS_FHSIZE);
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 2
a2 1
/*    $NetBSD: nfs_boot.c,v 1.20 1995/12/19 23:07:24 cgd Exp $ */
d55 1
d244 1
a244 2
	get_path_and_handle(&bp_sin, "root", &nd->nd_root);
	get_path_and_handle(&bp_sin, "swap", &nd->nd_swap);
d249 2
a250 2
static void
get_path_and_handle(bpsin, key, ndmntp)
d257 1
d260 2
d266 1
a266 1
	error = bp_getfile(bpsin, key, &ndmntp->ndm_saddr,
d275 1
a275 1
	error = md_mount(&ndmntp->ndm_saddr, pathname, ndmntp->ndm_fh);
d279 6
d439 2
d444 2
d519 2
d528 10
d542 1
a543 4
	rdata = mtod(m, struct rdata *);
	error = fxdr_unsigned(u_int32_t, rdata->errno);
	if (error)
		goto bad;
a544 4

	/* Set port number for NFS use. */
	error = krpc_portmap(mdsin, NFS_PROG, NFS_VER2,
						 &mdsin->sin_port);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*    $NetBSD: nfs_boot.c,v 1.19 1995/06/12 00:48:31 mycroft Exp $ */
d493 2
a494 2
		u_int32_t	errno;
		u_char	fh[NFS_FHSIZE];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
