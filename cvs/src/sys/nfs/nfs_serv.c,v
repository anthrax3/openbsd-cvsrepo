head	1.111;
access;
symbols
	OPENBSD_6_2:1.111.0.2
	OPENBSD_6_2_BASE:1.111
	OPENBSD_6_1:1.111.0.4
	OPENBSD_6_1_BASE:1.111
	OPENBSD_6_0:1.109.0.2
	OPENBSD_6_0_BASE:1.109
	OPENBSD_5_9:1.106.0.2
	OPENBSD_5_9_BASE:1.106
	OPENBSD_5_8:1.105.0.4
	OPENBSD_5_8_BASE:1.105
	OPENBSD_5_7:1.101.0.2
	OPENBSD_5_7_BASE:1.101
	OPENBSD_5_6:1.97.0.4
	OPENBSD_5_6_BASE:1.97
	OPENBSD_5_5:1.94.0.4
	OPENBSD_5_5_BASE:1.94
	OPENBSD_5_4:1.93.0.2
	OPENBSD_5_4_BASE:1.93
	OPENBSD_5_3:1.92.0.4
	OPENBSD_5_3_BASE:1.92
	OPENBSD_5_2:1.92.0.2
	OPENBSD_5_2_BASE:1.92
	OPENBSD_5_1_BASE:1.91
	OPENBSD_5_1:1.91.0.6
	OPENBSD_5_0:1.91.0.4
	OPENBSD_5_0_BASE:1.91
	OPENBSD_4_9:1.91.0.2
	OPENBSD_4_9_BASE:1.91
	OPENBSD_4_8:1.90.0.2
	OPENBSD_4_8_BASE:1.90
	OPENBSD_4_7:1.89.0.2
	OPENBSD_4_7_BASE:1.89
	OPENBSD_4_6:1.75.0.4
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.63.0.2
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.58.0.2
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.40.0.6
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.4
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.39.0.4
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.38.0.4
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.36.0.4
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.34
	OPENBSD_3_3:1.34.0.4
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.34
	UBC:1.28.0.2
	UBC_BASE:1.28
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.20.0.10
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.8
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.6
	SMP_BASE:1.20
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.4
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.111
date	2017.02.22.11.42.46;	author mpi;	state Exp;
branches;
next	1.110;
commitid	QPdM5oUknMlUIDue;

1.110
date	2016.09.21.13.22.44;	author jsg;	state Exp;
branches;
next	1.109;
commitid	iVsAqecFaIzOE1FK;

1.109
date	2016.07.04.18.34.03;	author natano;	state Exp;
branches;
next	1.108;
commitid	AMCtH4Vq59IQsZ7h;

1.108
date	2016.04.29.14.40.36;	author beck;	state Exp;
branches;
next	1.107;
commitid	p3EbVWCYrcYkiFMB;

1.107
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.106;
commitid	gAjwyca5TfuoJAhn;

1.106
date	2015.08.30.02.18.28;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	356MzYW9ynv9cMpJ;

1.105
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.104;
commitid	ncpqEGjDtSFuLAgn;

1.104
date	2015.06.11.08.39.51;	author blambert;	state Exp;
branches;
next	1.103;
commitid	jajfmpTP0vonGO2Z;

1.103
date	2015.05.06.02.19.40;	author jsg;	state Exp;
branches;
next	1.102;
commitid	OXWVQUvjpA72LiFW;

1.102
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.101;
commitid	p4LJxGKbi0BU2cG6;

1.101
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.100;
commitid	P6Av4XGqOi3rFasL;

1.100
date	2014.11.18.02.22.33;	author tedu;	state Exp;
branches;
next	1.99;
commitid	wzFnowS2QaVjmtib;

1.99
date	2014.11.14.23.01.44;	author tedu;	state Exp;
branches;
next	1.98;
commitid	IWzLFxf7O2DJPe2b;

1.98
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.97;
commitid	EkuwmBeHv2Tqmdnx;

1.97
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.96;
commitid	FE3DG5cICjyI4jWx;

1.96
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	EF98ch02VpFassUi;

1.95
date	2014.04.21.12.49.34;	author beck;	state Exp;
branches;
next	1.94;

1.94
date	2013.08.13.05.52.25;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.92;

1.92
date	2012.03.21.16.33.21;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.09.10.37.04;	author thib;	state Exp;
branches;
next	1.90;

1.90
date	2010.03.29.23.33.39;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2009.10.19.22.24.18;	author jsg;	state Exp;
branches;
next	1.88;

1.88
date	2009.08.30.15.16.19;	author thib;	state Exp;
branches;
next	1.87;

1.87
date	2009.08.14.13.53.16;	author blambert;	state Exp;
branches;
next	1.86;

1.86
date	2009.08.14.11.06.35;	author blambert;	state Exp;
branches;
next	1.85;

1.85
date	2009.08.13.15.03.19;	author blambert;	state Exp;
branches;
next	1.84;

1.84
date	2009.08.11.11.07.36;	author thib;	state Exp;
branches;
next	1.83;

1.83
date	2009.08.10.09.44.44;	author blambert;	state Exp;
branches;
next	1.82;

1.82
date	2009.08.10.09.38.44;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.09.17.35.31;	author blambert;	state Exp;
branches;
next	1.80;

1.80
date	2009.08.09.15.13.48;	author blambert;	state Exp;
branches;
next	1.79;

1.79
date	2009.08.09.13.34.41;	author thib;	state Exp;
branches;
next	1.78;

1.78
date	2009.08.04.17.12.39;	author thib;	state Exp;
branches;
next	1.77;

1.77
date	2009.07.20.16.49.40;	author thib;	state Exp;
branches;
next	1.76;

1.76
date	2009.07.17.12.36.21;	author blambert;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.06.23.40.30;	author blambert;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.06.22.59.17;	author blambert;	state Exp;
branches;
next	1.73;

1.73
date	2009.06.06.02.23.33;	author blambert;	state Exp;
branches;
next	1.72;

1.72
date	2009.06.05.21.35.33;	author thib;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.05.20.10.51;	author naddy;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.05.03.24.20;	author thib;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.04.18.55.49;	author blambert;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.04.18.44.27;	author blambert;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.21.12.24.22;	author thib;	state Exp;
branches;
next	1.66;

1.66
date	2009.04.13.17.51.57;	author blambert;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.30.19.58.50;	author blambert;	state Exp;
branches;
next	1.64;

1.64
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2009.01.27.23.40.14;	author blambert;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.24.23.35.47;	author thib;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.18.13.54.27;	author thib;	state Exp;
branches;
next	1.60;

1.60
date	2008.12.24.16.53.20;	author thib;	state Exp;
branches;
next	1.59;

1.59
date	2008.12.24.02.43.52;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2008.07.06.16.54.48;	author thib;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.15.04.03.40;	author thib;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.14.22.44.07;	author blambert;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.14.00.26.13;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.13.03.49.26;	author blambert;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.12.20.24.06;	author blambert;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.51;

1.51
date	2008.05.27.19.06.28;	author blambert;	state Exp;
branches;
next	1.50;

1.50
date	2008.04.22.18.53.34;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2008.03.16.19.42.57;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.06.17.38.23;	author blambert;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.27.00.08.33;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.08.19.20.09;	author blambert;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.07.23.40.52;	author thib;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.06.19.36.44;	author thib;	state Exp;
branches;
next	1.43;

1.43
date	2007.10.28.14.12.41;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.11.13.41.52;	author blambert;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.02.18.35.11;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2005.06.18.18.09.43;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.14.04.00.34;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.15.20.32.20;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.28.19;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.03.20.57.00;	author nate;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.11.05.14.54;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.10.22.07.08;	author csapuntz;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.29.07.36.32;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.26.20.24.47;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.26.02.10.41;	author assar;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.06.21.51.13;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.27.04.58.46;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.25.03.28.08;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.25.08.26.17;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	99.03.15.15.58.09;	author deraadt;	state Exp;
branches
	1.20.6.1;
next	1.19;

1.19
date	99.02.26.03.16.25;	author art;	state Exp;
branches;
next	1.18;

1.18
date	99.02.06.23.07.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.02.01.17.44.17;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.08.19.22.26.52;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	98.02.22.01.21.31;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.11.06.05.59.02;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	97.10.06.20.20.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.15.23.42;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.04.18.09.22.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.01.31.10.30.48;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.28.18.50.21;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.14.15.36.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.11.08.23.20.14;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.30.23;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.17.04.50.27;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.31.13.15.41;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.09.24.52;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.20.6.1
date	2001.05.14.22.44.57;	author niklas;	state Exp;
branches;
next	1.20.6.2;

1.20.6.2
date	2001.07.04.10.55.47;	author niklas;	state Exp;
branches;
next	1.20.6.3;

1.20.6.3
date	2001.10.31.03.30.29;	author nate;	state Exp;
branches;
next	1.20.6.4;

1.20.6.4
date	2001.11.13.22.59.59;	author niklas;	state Exp;
branches;
next	1.20.6.5;

1.20.6.5
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.20.6.6;

1.20.6.6
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.20.6.7;

1.20.6.7
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	1.20.6.8;

1.20.6.8
date	2003.06.07.11.07.43;	author ho;	state Exp;
branches;
next	1.20.6.9;

1.20.6.9
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	1.20.6.10;

1.20.6.10
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.28.2.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2002.06.11.03.32.03;	author art;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;

1.30.2.1
date	2002.05.11.15.17.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.111
log
@Keep local definitions local.

"good work" deraadt@@, ok visa@@
@
text
@/*	$OpenBSD: nfs_serv.c,v 1.110 2016/09/21 13:22:44 jsg Exp $	*/
/*     $NetBSD: nfs_serv.c,v 1.34 1997/05/12 23:37:12 fvdl Exp $       */

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_serv.c	8.7 (Berkeley) 5/14/95
 */

/*
 * nfs version 2 and 3 server calls to vnode ops
 * - these routines generally have 3 phases
 *   1 - break down and validate rpc request in mbuf list
 *   2 - do the vnode ops for the request
 *       (surprisingly ?? many are very similar to syscalls in vfs_syscalls.c)
 *   3 - build the rpc reply in an mbuf list
 *   nb:
 *	- do not mix the phases, since the nfsm_?? macros can return failures
 *	  on a bad rpc or similar and do not do any vrele() or vput()'s
 *
 *      - the nfsm_reply() macro generates an nfs rpc reply with the nfs
 *	error number iff error != 0 whereas
 *	returning an error from the server function implies a fatal error
 *	such as a badly constructed rpc request that should be dropped without
 *	a reply.
 *	For Version 3, nfsm_reply() does not return for the error case, since
 *	most version 3 rpcs return more than the status for error cases.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/mbuf.h>
#include <sys/dirent.h>
#include <sys/stat.h>
#include <sys/kernel.h>
#include <sys/pool.h>
#include <sys/queue.h>
#include <sys/unistd.h>

#include <ufs/ufs/dir.h>

#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/xdr_subs.h>
#include <nfs/nfsm_subs.h>
#include <nfs/nfs_var.h>

/* Global vars */
extern u_int32_t nfs_xdrneg1;
extern u_int32_t nfs_false, nfs_true;
extern enum vtype nv3tov_type[8];
extern struct nfsstats nfsstats;
extern nfstype nfsv2_type[9];
extern nfstype nfsv3_type[9];

int nfsrv_access(struct vnode *, int, struct ucred *, int, struct proc *, int);

/*
 * nfs v3 access service
 */
int
nfsrv3_access(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct nfsm_info	info;
	struct ucred *cred = &nfsd->nd_cr;
	struct vnode *vp;
	nfsfh_t nfh;
	fhandle_t *fhp;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly, getret;
	char *cp2;
	struct vattr va;
	u_long testmode, nfsmode;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, 1, NULL, &info);
		error = 0;
		goto nfsmout;
	}
	nfsmode = fxdr_unsigned(u_int32_t, *tl);
	if ((nfsmode & NFSV3ACCESS_READ) &&
		nfsrv_access(vp, VREAD, cred, rdonly, procp, 0))
		nfsmode &= ~NFSV3ACCESS_READ;
	if (vp->v_type == VDIR)
		testmode = (NFSV3ACCESS_MODIFY | NFSV3ACCESS_EXTEND |
			NFSV3ACCESS_DELETE);
	else
		testmode = (NFSV3ACCESS_MODIFY | NFSV3ACCESS_EXTEND);
	if ((nfsmode & testmode) &&
		nfsrv_access(vp, VWRITE, cred, rdonly, procp, 0))
		nfsmode &= ~testmode;
	if (vp->v_type == VDIR)
		testmode = NFSV3ACCESS_LOOKUP;
	else
		testmode = NFSV3ACCESS_EXECUTE;
	if ((nfsmode & testmode) &&
		nfsrv_access(vp, VEXEC, cred, rdonly, procp, 0))
		nfsmode &= ~testmode;
	getret = VOP_GETATTR(vp, &va, cred, procp);
	vput(vp);
	nfsm_reply(NFSX_POSTOPATTR(1) + NFSX_UNSIGNED);
	nfsm_srvpostop_attr(nfsd, getret, &va, &info);
	tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
	*tl = txdr_unsigned(nfsmode);
nfsmout:
	return(error);
}

/*
 * nfs getattr service
 */
int
nfsrv_getattr(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct nfsm_info	info;
	struct ucred *cred = &nfsd->nd_cr;
	struct nfs_fattr *fp;
	struct vattr va;
	struct vnode *vp;
	nfsfh_t nfh;
	fhandle_t *fhp;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly;
	char *cp2;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(0);
		error = 0;
		goto nfsmout;
	}
	error = VOP_GETATTR(vp, &va, cred, procp);
	vput(vp);
	nfsm_reply(NFSX_FATTR(nfsd->nd_flag & ND_NFSV3));
	if (error) {
		error = 0;
		goto nfsmout;
	}
	fp = nfsm_build(&info.nmi_mb, NFSX_FATTR(nfsd->nd_flag & ND_NFSV3));
	nfsm_srvfattr(nfsd, &va, fp);
nfsmout:
	return(error);
}

/*
 * nfs setattr service
 */
int
nfsrv_setattr(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct nfsm_info	info;
	struct ucred *cred = &nfsd->nd_cr;
	struct vattr va, preat;
	struct nfsv2_sattr *sp;
	struct nfs_fattr *fp;
	struct vnode *vp;
	nfsfh_t nfh;
	fhandle_t *fhp;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly, preat_ret = 1, postat_ret = 1;
	int gcheck = 0;
	char *cp2;
	struct timespec guard;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	VATTR_NULL(&va);
	if (info.nmi_v3) {
		va.va_vaflags |= VA_UTIMES_NULL;
		error = nfsm_srvsattr(&info.nmi_md, &va, info.nmi_mrep, &info.nmi_dpos);
		if (error)
			goto nfsmout;
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		gcheck = fxdr_unsigned(int, *tl);
		if (gcheck) {
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			fxdr_nfsv3time(tl, &guard);
		}
	} else {
		nfsm_dissect(sp, struct nfsv2_sattr *, NFSX_V2SATTR);
		/*
		 * Nah nah nah nah na nah
		 * There is a bug in the Sun client that puts 0xffff in the mode
		 * field of sattr when it should put in 0xffffffff. The u_short
		 * doesn't sign extend.
		 * --> check the low order 2 bytes for 0xffff
		 */
		if ((fxdr_unsigned(int, sp->sa_mode) & 0xffff) != 0xffff)
			va.va_mode = nfstov_mode(sp->sa_mode);
		if (sp->sa_uid != nfs_xdrneg1)
			va.va_uid = fxdr_unsigned(uid_t, sp->sa_uid);
		if (sp->sa_gid != nfs_xdrneg1)
			va.va_gid = fxdr_unsigned(gid_t, sp->sa_gid);
		if (sp->sa_size != nfs_xdrneg1)
			va.va_size = fxdr_unsigned(u_quad_t, sp->sa_size);
		if (sp->sa_atime.nfsv2_sec != nfs_xdrneg1) {
#ifdef notyet
			fxdr_nfsv2time(&sp->sa_atime, &va.va_atime);
#else
			va.va_atime.tv_sec =
				fxdr_unsigned(u_int32_t,sp->sa_atime.nfsv2_sec);
			va.va_atime.tv_nsec = 0;
#endif
		}
		if (sp->sa_mtime.nfsv2_sec != nfs_xdrneg1)
			fxdr_nfsv2time(&sp->sa_mtime, &va.va_mtime);

	}

	/*
	 * Now that we have all the fields, lets do it.
	 */
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(2 * NFSX_UNSIGNED);
		nfsm_srvwcc(nfsd, preat_ret, &preat, postat_ret, &va, &info);
		error = 0;
		goto nfsmout;
	}
	if (info.nmi_v3) {
		error = preat_ret = VOP_GETATTR(vp, &preat, cred, procp);
		if (!error && gcheck &&
			(preat.va_ctime.tv_sec != guard.tv_sec ||
			 preat.va_ctime.tv_nsec != guard.tv_nsec))
			error = NFSERR_NOT_SYNC;
		if (error) {
			vput(vp);
			nfsm_reply(NFSX_WCCDATA(info.nmi_v3));
			nfsm_srvwcc(nfsd, preat_ret, &preat, postat_ret, &va,
			    &info);
			error = 0;
			goto nfsmout;
		}
	}

	/*
	 * If the size is being changed write acces is required, otherwise
	 * just check for a read only file system.
	 */
	if (va.va_size == ((u_quad_t)((quad_t) -1))) {
		if (rdonly || (vp->v_mount->mnt_flag & MNT_RDONLY)) {
			error = EROFS;
			goto out;
		}
	} else {
		if (vp->v_type == VDIR) {
			error = EISDIR;
			goto out;
		} else if ((error = nfsrv_access(vp, VWRITE, cred, rdonly,
			procp, 1)) != 0)
			goto out;
	}
	error = VOP_SETATTR(vp, &va, cred, procp);
	postat_ret = VOP_GETATTR(vp, &va, cred, procp);
	if (!error)
		error = postat_ret;
out:
	vput(vp);
	nfsm_reply(NFSX_WCCORFATTR(info.nmi_v3));
	if (info.nmi_v3) {
		nfsm_srvwcc(nfsd, preat_ret, &preat, postat_ret, &va,
		    &info);
		error = 0;
		goto nfsmout;
	} else {
		fp = nfsm_build(&info.nmi_mb, NFSX_V2FATTR);
		nfsm_srvfattr(nfsd, &va, fp);
	}
nfsmout:
	return(error);
}

/*
 * nfs lookup rpc
 */
int
nfsrv_lookup(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct nfs_fattr *fp;
	struct nameidata nd;
	struct vnode *vp, *dirp;
	struct nfsm_info	info;
	nfsfh_t nfh;
	fhandle_t *fhp;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, len, dirattr_ret = 1;
	int v3 = (nfsd->nd_flag & ND_NFSV3);
	char *cp2;
	struct vattr va, dirattr;

	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_mreq = NULL;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_srvnamesiz(len);

	NDINIT(&nd, LOOKUP, LOCKLEAF | SAVESTART, UIO_SYSSPACE, NULL, procp);
	nd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&nd, fhp, len, slp, nam, &info.nmi_md, &info.nmi_dpos, &dirp, procp);
	if (dirp) {
		if (info.nmi_v3)
			dirattr_ret = VOP_GETATTR(dirp, &dirattr, cred,
				procp);
		vrele(dirp);
	}
	if (error) {
		nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3));
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &info);
		return (0);
	}
	vrele(nd.ni_startdir);
	pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
	vp = nd.ni_vp;
	memset(fhp, 0, sizeof(nfh));
	fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
	error = VFS_VPTOFH(vp, &fhp->fh_fid);
	if (!error)
		error = VOP_GETATTR(vp, &va, cred, procp);
	vput(vp);
	nfsm_reply(NFSX_SRVFH(info.nmi_v3) + NFSX_POSTOPORFATTR(info.nmi_v3)
	    + NFSX_POSTOPATTR(info.nmi_v3));
	if (error) {
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &info);
		error = 0;
		goto nfsmout;
	}
	nfsm_srvfhtom(&info.nmi_mb, fhp, info.nmi_v3);
	if (v3) {
		nfsm_srvpostop_attr(nfsd, 0, &va, &info);
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &info);
	} else {
		fp = nfsm_build(&info.nmi_mb, NFSX_V2FATTR);
		nfsm_srvfattr(nfsd, &va, fp);
	}
nfsmout:
	return(error);
}

/*
 * nfs readlink service
 */
int
nfsrv_readlink(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct iovec iov;
	struct mbuf *mp = NULL;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly, tlen, len = 0, getret;
	char *cp2;
	struct vnode *vp;
	struct vattr attr;
	nfsfh_t nfh;
	fhandle_t *fhp;
	struct uio uio;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	memset(&uio, 0, sizeof(uio));

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(2 * NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, 1, NULL, &info);
		error = 0;
		goto nfsmout;
	}
	if (vp->v_type != VLNK) {
		if (info.nmi_v3)
			error = EINVAL;
		else
			error = ENXIO;
		goto out;
	}

	MGET(mp, M_WAIT, MT_DATA);
	MCLGET(mp, M_WAIT);		/* MLEN < NFS_MAXPATHLEN < MCLBYTES */
	mp->m_len = NFS_MAXPATHLEN;
	len = NFS_MAXPATHLEN;
	iov.iov_base = mtod(mp, caddr_t);
	iov.iov_len = mp->m_len;

	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = 0;
	uio.uio_resid = NFS_MAXPATHLEN;
	uio.uio_rw = UIO_READ;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_procp = NULL;

	error = VOP_READLINK(vp, &uio, cred);
out:
	getret = VOP_GETATTR(vp, &attr, cred, procp);
	vput(vp);
	if (error)
		m_freem(mp);
	nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3) + NFSX_UNSIGNED);
	if (info.nmi_v3) {
		nfsm_srvpostop_attr(nfsd, getret, &attr, &info);
		if (error) {
			error = 0;
			goto nfsmout;
		}
	}
	if (uio.uio_resid > 0) {
		len -= uio.uio_resid;
		tlen = nfsm_rndup(len);
		nfsm_adj(mp, NFS_MAXPATHLEN-tlen, tlen-len);
	}
	tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
	*tl = txdr_unsigned(len);
	info.nmi_mb->m_next = mp;

nfsmout:
	return (error);
}

/*
 * nfs read service
 */
int
nfsrv_read(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct mbuf *m;
	struct nfs_fattr *fp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	int i, reqlen;
	int error = 0, rdonly, cnt, len, left, siz, tlen, getret = 1;
	char *cp2;
	struct mbuf *m2;
	struct vnode *vp;
	nfsfh_t nfh;
	fhandle_t *fhp;
	struct uio io, *uiop = &io;
	struct vattr va;
	off_t off;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	if (info.nmi_v3) {
		nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		off = fxdr_hyper(tl);
	} else {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		off = (off_t)fxdr_unsigned(u_int32_t, *tl);
	}

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	reqlen = fxdr_unsigned(int32_t, *tl);
	if (reqlen > (NFS_SRVMAXDATA(nfsd)) || reqlen <= 0) {
		error = EBADRPC;
		nfsm_reply(0);
	}

	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error)
		goto bad;

	if (vp->v_type != VREG) {
		if (info.nmi_v3)
			error = EINVAL;
		else
			error = (vp->v_type == VDIR) ? EISDIR : EACCES;
	}
	if (!error) {
	    if ((error = nfsrv_access(vp, VREAD, cred, rdonly, procp, 1)) != 0)
		error = nfsrv_access(vp, VEXEC, cred, rdonly, procp, 1);
	}
	getret = VOP_GETATTR(vp, &va, cred, procp);
	if (!error)
		error = getret;
	if (error)
		goto vbad;

	if (off >= va.va_size)
		cnt = 0;
	else if ((off + reqlen) > va.va_size)
		cnt = va.va_size - off;
	else
		cnt = reqlen;
	nfsm_reply(NFSX_POSTOPORFATTR(info.nmi_v3) + 3 * NFSX_UNSIGNED+nfsm_rndup(cnt));
	if (info.nmi_v3) {
		tl = nfsm_build(&info.nmi_mb, NFSX_V3FATTR + 4 * NFSX_UNSIGNED);
		*tl++ = nfs_true;
		fp = (struct nfs_fattr *)tl;
		tl += (NFSX_V3FATTR / sizeof (u_int32_t));
	} else {
		tl = nfsm_build(&info.nmi_mb, NFSX_V2FATTR + NFSX_UNSIGNED);
		fp = (struct nfs_fattr *)tl;
		tl += (NFSX_V2FATTR / sizeof (u_int32_t));
	}
	len = left = nfsm_rndup (cnt);
	if (cnt > 0) {
		struct iovec *iv, *iv2;
		size_t ivlen;
		/*
		 * Generate the mbuf list with the uio_iov ref. to it.
		 */
		i = 0;
		m = m2 = info.nmi_mb;
		while (left > 0) {
			siz = min(M_TRAILINGSPACE(m), left);
			if (siz > 0) {
				left -= siz;
				i++;
			}
			if (left > 0) {
				MGET(m, M_WAIT, MT_DATA);
				if (left >= MINCLSIZE)
					MCLGET(m, M_WAIT);
				m->m_len = 0;
				m2->m_next = m;
				m2 = m;
			}
		}
		iv = mallocarray(i, sizeof(*iv), M_TEMP, M_WAITOK);
		ivlen = i * sizeof(*iv);
		uiop->uio_iov = iv2 = iv;
		m = info.nmi_mb;
		left = len;
		i = 0;
		while (left > 0) {
			if (m == NULL)
				panic("nfsrv_read iov");
			siz = min(M_TRAILINGSPACE(m), left);
			if (siz > 0) {
				iv->iov_base = mtod(m, caddr_t) + m->m_len;
				iv->iov_len = siz;
				m->m_len += siz;
				left -= siz;
				iv++;
				i++;
			}
			m = m->m_next;
		}
		uiop->uio_iovcnt = i;
		uiop->uio_offset = off;
		uiop->uio_resid = len;
		uiop->uio_rw = UIO_READ;
		uiop->uio_segflg = UIO_SYSSPACE;
		error = VOP_READ(vp, uiop, IO_NODELOCKED, cred);
		off = uiop->uio_offset;
		free(iv2, M_TEMP, ivlen);
		if (error || (getret = VOP_GETATTR(vp, &va, cred, procp)) != 0){
			if (!error)
				error = getret;
			m_freem(info.nmi_mreq);
			goto vbad;
		}
	} else
		uiop->uio_resid = 0;
	vput(vp);
	nfsm_srvfattr(nfsd, &va, fp);
	tlen = len - uiop->uio_resid;
	cnt = cnt < tlen ? cnt : tlen;
	tlen = nfsm_rndup (cnt);
	if (len != tlen || tlen != cnt)
		nfsm_adj(info.nmi_mb, len - tlen, tlen - cnt);
	if (info.nmi_v3) {
		*tl++ = txdr_unsigned(cnt);
		if (len < reqlen)
			*tl++ = nfs_true;
		else
			*tl++ = nfs_false;
	}
	*tl = txdr_unsigned(cnt);
nfsmout:
	return(error);

vbad:
	vput(vp);
bad:
	nfsm_reply(0);
	nfsm_srvpostop_attr(nfsd, getret, &va, &info);
	return (0);
}

/*
 * nfs write service
 */
int
nfsrv_write(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct nfsm_info	info;
	int i, cnt;
	struct mbuf *mp;
	struct nfs_fattr *fp;
	struct vattr va, forat;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly, len, forat_ret = 1;
	int ioflags, aftat_ret = 1, retlen, zeroing, adjust;
	int stable = NFSV3WRITE_FILESYNC;
	char *cp2;
	struct vnode *vp;
	nfsfh_t nfh;
	fhandle_t *fhp;
	struct uio io, *uiop = &io;
	off_t off;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	if (info.nmi_mrep == NULL) {
		*mrq = NULL;
		return (0);
	}
	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	if (info.nmi_v3) {
		nfsm_dissect(tl, u_int32_t *, 5 * NFSX_UNSIGNED);
		off = fxdr_hyper(tl);
		tl += 3;
		stable = fxdr_unsigned(int, *tl++);
	} else {
		nfsm_dissect(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
		off = (off_t)fxdr_unsigned(u_int32_t, *++tl);
		tl += 2;
	}
	retlen = len = fxdr_unsigned(int32_t, *tl);
	cnt = i = 0;

	/*
	 * For NFS Version 2, it is not obvious what a write of zero length
	 * should do, but I might as well be consistent with Version 3,
	 * which is to return ok so long as there are no permission problems.
	 */
	if (len > 0) {
	    zeroing = 1;
	    mp = info.nmi_mrep;
	    while (mp) {
		if (mp == info.nmi_md) {
			zeroing = 0;
			adjust = info.nmi_dpos - mtod(mp, caddr_t);
			mp->m_len -= adjust;
			if (mp->m_len > 0 && adjust > 0)
				mp->m_data += adjust;
		}
		if (zeroing)
			mp->m_len = 0;
		else if (mp->m_len > 0) {
			i += mp->m_len;
			if (i > len) {
				mp->m_len -= (i - len);
				zeroing	= 1;
			}
			if (mp->m_len > 0)
				cnt++;
		}
		mp = mp->m_next;
	    }
	}
	if (len > NFS_MAXDATA || len < 0 || i < len) {
		error = EIO;
		goto bad;
	}
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error)
		goto bad;
	if (info.nmi_v3)
		forat_ret = VOP_GETATTR(vp, &forat, cred, procp);
	if (vp->v_type != VREG) {
		if (info.nmi_v3)
			error = EINVAL;
		else
			error = (vp->v_type == VDIR) ? EISDIR : EACCES;
		goto vbad;
	}
	error = nfsrv_access(vp, VWRITE, cred, rdonly, procp, 1);
	if (error)
		goto vbad;

	if (len > 0) {
	    struct iovec *iv, *ivp;
	    size_t ivlen;

	    ivp = mallocarray(cnt, sizeof(*ivp), M_TEMP, M_WAITOK);
	    ivlen = cnt * sizeof(*ivp);
	    uiop->uio_iov = iv = ivp;
	    uiop->uio_iovcnt = cnt;
	    mp = info.nmi_mrep;
	    while (mp) {
		if (mp->m_len > 0) {
			ivp->iov_base = mtod(mp, caddr_t);
			ivp->iov_len = mp->m_len;
			ivp++;
		}
		mp = mp->m_next;
	    }

	    if (stable == NFSV3WRITE_UNSTABLE)
		ioflags = IO_NODELOCKED;
	    else if (stable == NFSV3WRITE_DATASYNC)
		ioflags = (IO_SYNC | IO_NODELOCKED);
	    else
		ioflags = (IO_SYNC | IO_NODELOCKED);
	    uiop->uio_resid = len;
	    uiop->uio_rw = UIO_WRITE;
	    uiop->uio_segflg = UIO_SYSSPACE;
	    uiop->uio_procp = NULL;
	    uiop->uio_offset = off;
	    error = VOP_WRITE(vp, uiop, ioflags, cred);
	    nfsstats.srvvop_writes++;
	    free(iv, M_TEMP, ivlen);
	}
	aftat_ret = VOP_GETATTR(vp, &va, cred, procp);
	vput(vp);
	if (!error)
		error = aftat_ret;
	nfsm_reply(NFSX_PREOPATTR(info.nmi_v3) + NFSX_POSTOPORFATTR(info.nmi_v3) +
		2 * NFSX_UNSIGNED + NFSX_WRITEVERF(info.nmi_v3));
	if (info.nmi_v3) {
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &info);
		if (error) {
			error = 0;
			goto nfsmout;
		}
		tl = nfsm_build(&info.nmi_mb, 4 * NFSX_UNSIGNED);
		*tl++ = txdr_unsigned(retlen);
		if (stable == NFSV3WRITE_UNSTABLE)
			*tl++ = txdr_unsigned(stable);
		else
			*tl++ = txdr_unsigned(NFSV3WRITE_FILESYNC);
		/*
		 * Actually, there is no need to txdr these fields,
		 * but it may make the values more human readable,
		 * for debugging purposes.
		 */
		*tl++ = txdr_unsigned(boottime.tv_sec);
		*tl = txdr_unsigned(boottime.tv_nsec/1000);
	} else {
		fp = nfsm_build(&info.nmi_mb, NFSX_V2FATTR);
		nfsm_srvfattr(nfsd, &va, fp);
	}
nfsmout:
	return(error);

vbad:
	vput(vp);
bad:
	nfsm_reply(0);
	nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &info);
	return (0);
}

/*
 * nfs create service
 * now does a truncate to 0 length via. setattr if it already exists
 */
int
nfsrv_create(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct nfs_fattr *fp;
	struct vattr va, dirfor, diraft;
	struct nfsv2_sattr *sp;
	struct nfsm_info	info;
	u_int32_t *tl;
	struct nameidata nd;
	caddr_t cp;
	int32_t t1;
	int error = 0, len, tsize, dirfor_ret = 1, diraft_ret = 1;
	dev_t rdev = 0;
	int how, exclusive_flag = 0;
	char *cp2;
	struct vnode *vp = NULL, *dirp = NULL;
	nfsfh_t nfh;
	fhandle_t *fhp;
	u_quad_t tempsize;
	u_char cverf[NFSX_V3CREATEVERF];

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_srvnamesiz(len);

	NDINIT(&nd, CREATE, LOCKPARENT | LOCKLEAF | SAVESTART, UIO_SYSSPACE,
	    NULL, procp);
	nd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&nd, fhp, len, slp, nam, &info.nmi_md,
	    &info.nmi_dpos, &dirp, procp);
	if (dirp) {
		if (info.nmi_v3)
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred, procp);
		else {
			vrele(dirp);
			dirp = NULL;
		}
	}
	if (error) {
		nfsm_reply(NFSX_WCCDATA(info.nmi_v3));
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
		if (dirp)
			vrele(dirp);
		return (0);
	}

	VATTR_NULL(&va);
	if (info.nmi_v3) {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		how = fxdr_unsigned(int, *tl);
		switch (how) {
		case NFSV3CREATE_GUARDED:
			if (nd.ni_vp) {
				error = EEXIST;
				break;
			}
		case NFSV3CREATE_UNCHECKED:
			error = nfsm_srvsattr(&info.nmi_md, &va, info.nmi_mrep,
			    &info.nmi_dpos);
			if (error)
				goto nfsmout;
			break;
		case NFSV3CREATE_EXCLUSIVE:
			nfsm_dissect(cp, caddr_t, NFSX_V3CREATEVERF);
			bcopy(cp, cverf, NFSX_V3CREATEVERF);
			exclusive_flag = 1;
			if (nd.ni_vp == NULL)
				va.va_mode = 0;
			break;
		};
		va.va_type = VREG;
	} else {
		nfsm_dissect(sp, struct nfsv2_sattr *, NFSX_V2SATTR);
		va.va_type = IFTOVT(fxdr_unsigned(u_int32_t, sp->sa_mode));
		if (va.va_type == VNON)
			va.va_type = VREG;
		va.va_mode = nfstov_mode(sp->sa_mode);
		switch (va.va_type) {
		case VREG:
			tsize = fxdr_unsigned(int32_t, sp->sa_size);
			if (tsize != -1)
				va.va_size = (u_quad_t)tsize;
			break;
		case VCHR:
		case VBLK:
		case VFIFO:
			rdev = (dev_t)fxdr_unsigned(int32_t, sp->sa_size);
			break;
		default:
			break;
		};
	}

	/*
	 * Iff doesn't exist, create it
	 * otherwise just truncate to 0 length
	 *   should I set the mode too ??
	 */
	if (nd.ni_vp == NULL) {
		if (va.va_type == VREG || va.va_type == VSOCK) {
			vrele(nd.ni_startdir);
			error = VOP_CREATE(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va);
			if (!error) {
				pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
				if (exclusive_flag) {
					exclusive_flag = 0;
					VATTR_NULL(&va);
					bcopy(cverf, (caddr_t)&va.va_atime,
						NFSX_V3CREATEVERF);
					error = VOP_SETATTR(nd.ni_vp, &va, cred,
						procp);
				}
			}
		} else if (va.va_type == VCHR || va.va_type == VBLK ||
			va.va_type == VFIFO) {
			if (va.va_type == VCHR && rdev == 0xffffffff)
				va.va_type = VFIFO;
			if (va.va_type != VFIFO &&
			    (error = suser_ucred(cred))) {
				vrele(nd.ni_startdir);
				if (nd.ni_cnd.cn_flags & HASBUF) {
					pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
					nd.ni_cnd.cn_flags &= ~HASBUF;
				}
				VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
				vput(nd.ni_dvp);
				nfsm_reply(0);
				error = 0;
				goto nfsmout;
			} else
				va.va_rdev = (dev_t)rdev;
			error = VOP_MKNOD(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd,
			    &va);
			if (error) {
				vrele(nd.ni_startdir);
				if (nd.ni_cnd.cn_flags & HASBUF) {
					pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
					nd.ni_cnd.cn_flags &= ~HASBUF;
				}
				nfsm_reply(0);
				error = 0;
				goto nfsmout;
			}
			nd.ni_cnd.cn_nameiop = LOOKUP;
			nd.ni_cnd.cn_flags &= ~(LOCKPARENT | SAVESTART);
			nd.ni_cnd.cn_proc = procp;
			nd.ni_cnd.cn_cred = cred;
			if ((error = vfs_lookup(&nd)) != 0) {
				if (nd.ni_cnd.cn_flags & HASBUF) {
					pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
					nd.ni_cnd.cn_flags &= ~HASBUF;
				}
				nfsm_reply(0);
				error = 0;
				goto nfsmout;
			}

			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
			if (nd.ni_cnd.cn_flags & ISSYMLINK) {
				vrele(nd.ni_dvp);
				vput(nd.ni_vp);
				VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
				error = EINVAL;
				nfsm_reply(0);
				error = 0;
				goto nfsmout;
			}
		} else {
			vrele(nd.ni_startdir);
			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
			nd.ni_cnd.cn_flags &= ~HASBUF;
			VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
			vput(nd.ni_dvp);
			error = ENXIO;
		}
		vp = nd.ni_vp;
	} else {
		vrele(nd.ni_startdir);
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
		nd.ni_cnd.cn_flags &= ~HASBUF;
		vp = nd.ni_vp;
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (va.va_size != -1) {
			error = nfsrv_access(vp, VWRITE, cred,
			    (nd.ni_cnd.cn_flags & RDONLY), procp, 0);
			if (!error) {
				tempsize = va.va_size;
				VATTR_NULL(&va);
				va.va_size = tempsize;
				error = VOP_SETATTR(vp, &va, cred,
					 procp);
			}
			if (error)
				vput(vp);
		}
	}
	if (!error) {
		memset(fhp, 0, sizeof(nfh));
		fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
		error = VFS_VPTOFH(vp, &fhp->fh_fid);
		if (!error)
			error = VOP_GETATTR(vp, &va, cred, procp);
		vput(vp);
	}
	if (info.nmi_v3) {
		if (exclusive_flag && !error &&
			bcmp(cverf, (caddr_t)&va.va_atime, NFSX_V3CREATEVERF))
			error = EEXIST;
		diraft_ret = VOP_GETATTR(dirp, &diraft, cred, procp);
		vrele(dirp);
	}
	nfsm_reply(NFSX_SRVFH(info.nmi_v3) + NFSX_FATTR(info.nmi_v3)
	    + NFSX_WCCDATA(info.nmi_v3));
	if (info.nmi_v3) {
		if (!error) {
			nfsm_srvpostop_fh(fhp);
			nfsm_srvpostop_attr(nfsd, 0, &va, &info);
		}
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
	} else {
		nfsm_srvfhtom(&info.nmi_mb, fhp, info.nmi_v3);
		fp = nfsm_build(&info.nmi_mb, NFSX_V2FATTR);
		nfsm_srvfattr(nfsd, &va, fp);
	}
	return (0);
nfsmout:
	if (dirp)
		vrele(dirp);
	if (nd.ni_cnd.cn_nameiop != LOOKUP) {
		vrele(nd.ni_startdir);
		if (nd.ni_cnd.cn_flags & HASBUF) {
			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
			nd.ni_cnd.cn_flags &= ~HASBUF;
		}
	}
	VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
	if (nd.ni_dvp == nd.ni_vp)
		vrele(nd.ni_dvp);
	else
		vput(nd.ni_dvp);
	if (nd.ni_vp)
		vput(nd.ni_vp);
	return (error);
}

/*
 * nfs v3 mknod service
 */
int
nfsrv_mknod(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct vattr va, dirfor, diraft;
	struct nfsm_info	info;
	u_int32_t *tl;
	struct nameidata nd;
	int32_t t1;
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
	u_int32_t major, minor;
	enum vtype vtyp;
	char *cp2;
	struct vnode *vp, *dirp = NULL;
	nfsfh_t nfh;
	fhandle_t *fhp;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_srvnamesiz(len);

	NDINIT(&nd, CREATE, LOCKPARENT | LOCKLEAF | SAVESTART, UIO_SYSSPACE,
	    NULL, procp);
	nd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&nd, fhp, len, slp, nam, &info.nmi_md, &info.nmi_dpos, &dirp, procp);
	if (dirp)
		dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred, procp);
	if (error) {
		nfsm_reply(NFSX_WCCDATA(1));
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
		if (dirp)
			vrele(dirp);
		return (0);
	}

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	vtyp = nfsv3tov_type(*tl);
	if (vtyp != VCHR && vtyp != VBLK && vtyp != VSOCK && vtyp != VFIFO) {
		vrele(nd.ni_startdir);
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
		error = NFSERR_BADTYPE;
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		if (nd.ni_vp)
			vput(nd.ni_vp);
		goto out;
	}
	VATTR_NULL(&va);
	error = nfsm_srvsattr(&info.nmi_md, &va, info.nmi_mrep, &info.nmi_dpos);
	if (error)
		goto nfsmout;
	if (vtyp == VCHR || vtyp == VBLK) {
		nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		major = fxdr_unsigned(u_int32_t, *tl++);
		minor = fxdr_unsigned(u_int32_t, *tl);
		va.va_rdev = makedev(major, minor);
	}

	/*
	 * Iff doesn't exist, create it.
	 */
	if (nd.ni_vp) {
		vrele(nd.ni_startdir);
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
		error = EEXIST;
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vput(nd.ni_vp);
		goto out;
	}
	va.va_type = vtyp;
	if (vtyp == VSOCK) {
		vrele(nd.ni_startdir);
		error = VOP_CREATE(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va);
		if (!error)
			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
	} else {
		if (va.va_type != VFIFO &&
		    (error = suser_ucred(cred))) {
			vrele(nd.ni_startdir);
			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
			VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
			vput(nd.ni_dvp);
			goto out;
		}
		error = VOP_MKNOD(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va);
		if (error) {
			vrele(nd.ni_startdir);
			goto out;
		}
		nd.ni_cnd.cn_nameiop = LOOKUP;
		nd.ni_cnd.cn_flags &= ~(LOCKPARENT | SAVESTART);
		nd.ni_cnd.cn_proc = procp;
		nd.ni_cnd.cn_cred = procp->p_ucred;
		error = vfs_lookup(&nd);
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
		if (error)
			goto out;
		if (nd.ni_cnd.cn_flags & ISSYMLINK) {
			vrele(nd.ni_dvp);
			vput(nd.ni_vp);
			VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
			error = EINVAL;
		}
	}
out:
	vp = nd.ni_vp;
	if (!error) {
		memset(fhp, 0, sizeof(nfh));
		fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
		error = VFS_VPTOFH(vp, &fhp->fh_fid);
		if (!error)
			error = VOP_GETATTR(vp, &va, cred, procp);
		vput(vp);
	}
	diraft_ret = VOP_GETATTR(dirp, &diraft, cred, procp);
	vrele(dirp);
	nfsm_reply(NFSX_SRVFH(1) + NFSX_POSTOPATTR(1) + NFSX_WCCDATA(1));
	if (!error) {
		nfsm_srvpostop_fh(fhp);
		nfsm_srvpostop_attr(nfsd, 0, &va, &info);
	}
	nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft, &info);
	return (0);
nfsmout:
	if (dirp)
		vrele(dirp);
	if (nd.ni_cnd.cn_nameiop) {
		vrele(nd.ni_startdir);
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
	}
	VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
	if (nd.ni_dvp == nd.ni_vp)
		vrele(nd.ni_dvp);
	else
		vput(nd.ni_dvp);
	if (nd.ni_vp)
		vput(nd.ni_vp);
	return (error);
}

/*
 * nfs remove service
 */
int
nfsrv_remove(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct nameidata nd;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
	char *cp2;
	struct vnode *vp, *dirp;
	struct vattr dirfor, diraft;
	nfsfh_t nfh;
	fhandle_t *fhp;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	vp = NULL;

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_srvnamesiz(len);

 	NDINIT(&nd, DELETE, LOCKPARENT | LOCKLEAF, UIO_SYSSPACE, NULL, procp);
	nd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&nd, fhp, len, slp, nam, &info.nmi_md, &info.nmi_dpos, &dirp, procp);
	if (dirp) {
		if (info.nmi_v3)
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred, procp);
		else {
			vrele(dirp);
			dirp = NULL;
		}
	}

	if (!error) {
		vp = nd.ni_vp;
		if (vp->v_type == VDIR &&
		    (error = suser_ucred(cred)) != 0)
			goto out;
		/*
		 * The root of a mounted filesystem cannot be deleted.
		 */
		if (vp->v_flag & VROOT) {
			error = EBUSY;
			goto out;
		}
		if (vp->v_flag & VTEXT)
			uvm_vnp_uncache(vp);
out:
		if (!error) {
			error = VOP_REMOVE(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
		} else {
			VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
			if (nd.ni_dvp == vp)
				vrele(nd.ni_dvp);
			else
				vput(nd.ni_dvp);
			vput(vp);
		}
	}
	if (dirp && info.nmi_v3) {
		diraft_ret = VOP_GETATTR(dirp, &diraft, cred, procp);
		vrele(dirp);
	}
	nfsm_reply(NFSX_WCCDATA(info.nmi_v3));
	if (info.nmi_v3) {
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
		return (0);
	}

nfsmout:
	return(error);
}

/*
 * nfs rename service
 */
int
nfsrv_rename(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, len, len2, fdirfor_ret = 1, fdiraft_ret = 1;
	int tdirfor_ret = 1, tdiraft_ret = 1;
	char *cp2;
	struct nameidata fromnd, tond;
	struct vnode *fvp = NULL, *tvp, *tdvp, *fdirp = NULL;
	struct vnode *tdirp = NULL;
	struct vattr fdirfor, fdiraft, tdirfor, tdiraft;
	nfsfh_t fnfh, tnfh;
	fhandle_t *ffhp, *tfhp;
	uid_t saved_uid;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	ffhp = &fnfh.fh_generic;
	tfhp = &tnfh.fh_generic;
	nfsm_srvmtofh(ffhp);
	nfsm_srvnamesiz(len);

	/*
	 * Remember our original uid so that we can reset cr_uid before
	 * the second nfs_namei() call, in case it is remapped.
	 */
	saved_uid = cred->cr_uid;

	NDINIT(&fromnd, DELETE, WANTPARENT | SAVESTART, UIO_SYSSPACE, NULL,
	    procp);
	fromnd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&fromnd, ffhp, len, slp, nam, &info.nmi_md,
	    &info.nmi_dpos, &fdirp, procp);
	if (fdirp) {
		if (info.nmi_v3)
			fdirfor_ret = VOP_GETATTR(fdirp, &fdirfor, cred,
				procp);
		else {
			vrele(fdirp);
			fdirp = NULL;
		}
	}
	if (error) {
		nfsm_reply(2 * NFSX_WCCDATA(info.nmi_v3));
		nfsm_srvwcc(nfsd, fdirfor_ret, &fdirfor, fdiraft_ret, &fdiraft,
		    &info);
		nfsm_srvwcc(nfsd, tdirfor_ret, &tdirfor, tdiraft_ret, &tdiraft,
		    &info);
		if (fdirp)
			vrele(fdirp);
		return (0);
	}

	fvp = fromnd.ni_vp;
	nfsm_srvmtofh(tfhp);
	nfsm_strsiz(len2, NFS_MAXNAMLEN);
	cred->cr_uid = saved_uid;

	NDINIT(&tond, RENAME, LOCKPARENT | LOCKLEAF| NOCACHE | SAVESTART,
	    UIO_SYSSPACE, NULL, procp);
	tond.ni_cnd.cn_cred = cred;
	error = nfs_namei(&tond, tfhp, len2, slp, nam, &info.nmi_md,
	    &info.nmi_dpos, &tdirp, procp);
	if (tdirp) {
		if (info.nmi_v3)
			tdirfor_ret = VOP_GETATTR(tdirp, &tdirfor, cred,
				procp);
		else {
			vrele(tdirp);
			tdirp = NULL;
		}
	}
	if (error) {
		VOP_ABORTOP(fromnd.ni_dvp, &fromnd.ni_cnd);
		vrele(fromnd.ni_dvp);
		vrele(fvp);
		goto out1;
	}
	tdvp = tond.ni_dvp;
	tvp = tond.ni_vp;
	if (tvp != NULL) {
		if (fvp->v_type == VDIR && tvp->v_type != VDIR) {
			error = info.nmi_v3 ? EEXIST : EISDIR;
			goto out;
		} else if (fvp->v_type != VDIR && tvp->v_type == VDIR) {
			error = info.nmi_v3 ? EEXIST : ENOTDIR;
			goto out;
		}
		if (tvp->v_type == VDIR && tvp->v_mountedhere) {
			error = info.nmi_v3 ? EXDEV : ENOTEMPTY;
			goto out;
		}
	}
	if (fvp->v_type == VDIR && fvp->v_mountedhere) {
		error = info.nmi_v3 ? EXDEV : ENOTEMPTY;
		goto out;
	}
	if (fvp->v_mount != tdvp->v_mount) {
		error = info.nmi_v3 ? EXDEV : ENOTEMPTY;
		goto out;
	}
	if (fvp == tdvp)
		error = info.nmi_v3 ? EINVAL : ENOTEMPTY;
	/*
	 * If source is the same as the destination (that is the
	 * same vnode with the same name in the same directory),
	 * then there is nothing to do.
	 */
	if (fvp == tvp && fromnd.ni_dvp == tdvp &&
	    fromnd.ni_cnd.cn_namelen == tond.ni_cnd.cn_namelen &&
	    !bcmp(fromnd.ni_cnd.cn_nameptr, tond.ni_cnd.cn_nameptr,
	      fromnd.ni_cnd.cn_namelen))
		error = -1;
out:
	if (!error) {
		error = VOP_RENAME(fromnd.ni_dvp, fromnd.ni_vp, &fromnd.ni_cnd,
				   tond.ni_dvp, tond.ni_vp, &tond.ni_cnd);
	} else {
		VOP_ABORTOP(tond.ni_dvp, &tond.ni_cnd);
		if (tdvp == tvp)
			vrele(tdvp);
		else
			vput(tdvp);
		if (tvp)
			vput(tvp);
		VOP_ABORTOP(fromnd.ni_dvp, &fromnd.ni_cnd);
		vrele(fromnd.ni_dvp);
		vrele(fvp);
		if (error == -1)
			error = 0;
	}
	vrele(tond.ni_startdir);
	pool_put(&namei_pool, tond.ni_cnd.cn_pnbuf);
out1:
	if (fdirp) {
		fdiraft_ret = VOP_GETATTR(fdirp, &fdiraft, cred, procp);
		vrele(fdirp);
	}
	if (tdirp) {
		tdiraft_ret = VOP_GETATTR(tdirp, &tdiraft, cred, procp);
		vrele(tdirp);
	}
	vrele(fromnd.ni_startdir);
	pool_put(&namei_pool, fromnd.ni_cnd.cn_pnbuf);
	nfsm_reply(2 * NFSX_WCCDATA(info.nmi_v3));
	if (info.nmi_v3) {
		nfsm_srvwcc(nfsd, fdirfor_ret, &fdirfor, fdiraft_ret, &fdiraft,
		    &info);
		nfsm_srvwcc(nfsd, tdirfor_ret, &tdirfor, tdiraft_ret, &tdiraft,
		    &info);
	}
	return (0);

nfsmout:
	if (fdirp)
		vrele(fdirp);
	if (tdirp)
		vrele(tdirp);
	if (tond.ni_cnd.cn_nameiop) {
		vrele(tond.ni_startdir);
		pool_put(&namei_pool, tond.ni_cnd.cn_pnbuf);
	}
	if (fromnd.ni_cnd.cn_nameiop) {
		if (fromnd.ni_startdir)
			vrele(fromnd.ni_startdir);
		VOP_ABORTOP(fromnd.ni_dvp, &fromnd.ni_cnd);

		/*
		 * XXX: Workaround the fact that fromnd.ni_dvp can point
		 * to the same vnode as fdirp.
		 */
		if (fromnd.ni_dvp != NULL && fromnd.ni_dvp != fdirp)
			vrele(fromnd.ni_dvp);
		if (fvp)
			vrele(fvp);
	}
	return (error);
}

/*
 * nfs link service
 */
int
nfsrv_link(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct nfsm_info	info;
	struct ucred *cred = &nfsd->nd_cr;
	struct nameidata nd;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly, len, dirfor_ret = 1, diraft_ret = 1;
	int getret = 1;
	char *cp2;
	struct vnode *vp, *xp, *dirp = NULL;
	struct vattr dirfor, diraft, at;
	nfsfh_t nfh, dnfh;
	fhandle_t *fhp, *dfhp;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	dfhp = &dnfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_srvmtofh(dfhp);
	nfsm_srvnamesiz(len);

	error = nfsrv_fhtovp(fhp, 0, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3) +
		    NFSX_WCCDATA(info.nmi_v3));
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
		error = 0;
		goto nfsmout;
	}
	if (vp->v_type == VDIR && (error = suser_ucred(cred)) != 0)
		goto out1;

	NDINIT(&nd, CREATE, LOCKPARENT, UIO_SYSSPACE, NULL, procp);
	nd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&nd, dfhp, len, slp, nam, &info.nmi_md,
	    &info.nmi_dpos, &dirp, procp);
	if (dirp) {
		if (info.nmi_v3)
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred,
				procp);
		else {
			vrele(dirp);
			dirp = NULL;
		}
	}
	if (error)
		goto out1;
	xp = nd.ni_vp;
	if (xp != NULL) {
		error = EEXIST;
		goto out;
	}
	xp = nd.ni_dvp;
	if (vp->v_mount != xp->v_mount)
		error = EXDEV;
out:
	if (!error) {
		error = VOP_LINK(nd.ni_dvp, vp, &nd.ni_cnd);
	} else {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		if (nd.ni_vp)
			vrele(nd.ni_vp);
	}
out1:
	if (info.nmi_v3)
		getret = VOP_GETATTR(vp, &at, cred, procp);
	if (dirp) {
		diraft_ret = VOP_GETATTR(dirp, &diraft, cred, procp);
		vrele(dirp);
	}
	vrele(vp);
	nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3) + NFSX_WCCDATA(info.nmi_v3));
	if (info.nmi_v3) {
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		     &info);
		error = 0;
	}
nfsmout:
	return(error);
}

/*
 * nfs symbolic link service
 */
int
nfsrv_symlink(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct vattr va, dirfor, diraft;
	struct nameidata nd;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	struct nfsv2_sattr *sp;
	char *pathcp = NULL, *cp2;
	struct uio io;
	struct iovec iv;
	int error = 0, len, pathlen, len2, dirfor_ret = 1, diraft_ret = 1;
	struct vnode *dirp = NULL;
	nfsfh_t nfh;
	fhandle_t *fhp;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_srvnamesiz(len);

	NDINIT(&nd, CREATE, LOCKPARENT | SAVESTART, UIO_SYSSPACE, NULL, procp);
	nd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&nd, fhp, len, slp, nam, &info.nmi_md,
	    &info.nmi_dpos, &dirp, procp);
	if (dirp) {
		if (info.nmi_v3)
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred,
				procp);
		else {
			vrele(dirp);
			dirp = NULL;
		}
	}
	if (error)
		goto out;
	VATTR_NULL(&va);
	if (info.nmi_v3) {
		error = nfsm_srvsattr(&info.nmi_md, &va, info.nmi_mrep,
		    &info.nmi_dpos);
		if (error)
			goto nfsmout;
	}
	nfsm_strsiz(len2, NFS_MAXPATHLEN);
	pathlen = len2 + 1;
	pathcp = malloc(pathlen, M_TEMP, M_WAITOK);
	iv.iov_base = pathcp;
	iv.iov_len = len2;
	io.uio_resid = len2;
	io.uio_offset = 0;
	io.uio_iov = &iv;
	io.uio_iovcnt = 1;
	io.uio_segflg = UIO_SYSSPACE;
	io.uio_rw = UIO_READ;
	io.uio_procp = NULL;
	nfsm_mtouio(&io, len2);
	if (!info.nmi_v3) {
		nfsm_dissect(sp, struct nfsv2_sattr *, NFSX_V2SATTR);
		va.va_mode = fxdr_unsigned(u_int16_t, sp->sa_mode);
	}
	*(pathcp + len2) = '\0';
	if (nd.ni_vp) {
		vrele(nd.ni_startdir);
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(nd.ni_vp);
		error = EEXIST;
		goto out;
	}
	error = VOP_SYMLINK(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va, pathcp);
	if (error)
		vrele(nd.ni_startdir);
	else {
		if (info.nmi_v3) {
			nd.ni_cnd.cn_nameiop = LOOKUP;
			nd.ni_cnd.cn_flags &= ~(LOCKPARENT | SAVESTART |
			    FOLLOW);
			nd.ni_cnd.cn_flags |= (NOFOLLOW | LOCKLEAF);
			nd.ni_cnd.cn_proc = procp;
			nd.ni_cnd.cn_cred = cred;
			error = vfs_lookup(&nd);
			if (!error) {
				memset(fhp, 0, sizeof(nfh));
				fhp->fh_fsid =
				    nd.ni_vp->v_mount->mnt_stat.f_fsid;
				error = VFS_VPTOFH(nd.ni_vp, &fhp->fh_fid);
				if (!error)
					error = VOP_GETATTR(nd.ni_vp, &va, cred,
					    procp);
				vput(nd.ni_vp);
			}
		} else
			vrele(nd.ni_startdir);
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
	}
out:
	if (pathcp)
		free(pathcp, M_TEMP, pathlen);
	if (dirp) {
		diraft_ret = VOP_GETATTR(dirp, &diraft, cred, procp);
		vrele(dirp);
	}
	nfsm_reply(NFSX_SRVFH(info.nmi_v3) + NFSX_POSTOPATTR(info.nmi_v3)
	    + NFSX_WCCDATA(info.nmi_v3));
	if (info.nmi_v3) {
		if (!error) {
			nfsm_srvpostop_fh(fhp);
			nfsm_srvpostop_attr(nfsd, 0, &va, &info);
		}
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
	}
	return (0);
nfsmout:
	if (nd.ni_cnd.cn_nameiop) {
		vrele(nd.ni_startdir);
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
	}
	if (dirp)
		vrele(dirp);
	VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
	if (nd.ni_dvp == nd.ni_vp)
		vrele(nd.ni_dvp);
	else
		vput(nd.ni_dvp);
	if (nd.ni_vp)
		vrele(nd.ni_vp);
	if (pathcp)
		free(pathcp, M_TEMP, pathlen);
	return (error);
}

/*
 * nfs mkdir service
 */
int
nfsrv_mkdir(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct vattr va, dirfor, diraft;
	struct nfs_fattr *fp;
	struct nameidata nd;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
	char *cp2;
	struct vnode *vp, *dirp = NULL;
	nfsfh_t nfh;
	fhandle_t *fhp;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_srvnamesiz(len);

	NDINIT(&nd, CREATE, LOCKPARENT, UIO_SYSSPACE, NULL, procp);
	nd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&nd, fhp, len, slp, nam, &info.nmi_md,
	    &info.nmi_dpos, &dirp, procp);
	if (dirp) {
		if (info.nmi_v3)
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred, procp);
		else {
			vrele(dirp);
			dirp = NULL;
		}
	}
	if (error) {
		nfsm_reply(NFSX_WCCDATA(info.nmi_v3));
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
		if (dirp)
			vrele(dirp);
		return (0);
	}

	VATTR_NULL(&va);
	if (info.nmi_v3) {
		error = nfsm_srvsattr(&info.nmi_md, &va, info.nmi_mrep,
		    &info.nmi_dpos);
		if (error)
			goto nfsmout;
	} else {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		va.va_mode = nfstov_mode(*tl++);
	}
	va.va_type = VDIR;
	vp = nd.ni_vp;
	if (vp != NULL) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(vp);
		error = EEXIST;
		goto out;
	}
	error = VOP_MKDIR(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va);
	if (!error) {
		vp = nd.ni_vp;
		memset(fhp, 0, sizeof(nfh));
		fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
		error = VFS_VPTOFH(vp, &fhp->fh_fid);
		if (!error)
			error = VOP_GETATTR(vp, &va, cred, procp);
		vput(vp);
	}
out:
	if (dirp) {
		diraft_ret = VOP_GETATTR(dirp, &diraft, cred, procp);
		vrele(dirp);
	}
	nfsm_reply(NFSX_SRVFH(info.nmi_v3) + NFSX_POSTOPATTR(info.nmi_v3) +
	    NFSX_WCCDATA(info.nmi_v3));
	if (info.nmi_v3) {
		if (!error) {
			nfsm_srvpostop_fh(fhp);
			nfsm_srvpostop_attr(nfsd, 0, &va, &info);
		}
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
	} else {
		nfsm_srvfhtom(&info.nmi_mb, fhp, info.nmi_v3);
		fp = nfsm_build(&info.nmi_mb, NFSX_V2FATTR);
		nfsm_srvfattr(nfsd, &va, fp);
	}
	return (0);
nfsmout:
	if (dirp)
		vrele(dirp);
	VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
	if (nd.ni_dvp == nd.ni_vp)
		vrele(nd.ni_dvp);
	else
		vput(nd.ni_dvp);
	if (nd.ni_vp)
		vrele(nd.ni_vp);
	return (error);
}

/*
 * nfs rmdir service
 */
int
nfsrv_rmdir(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
	char *cp2;
	struct vnode *vp, *dirp = NULL;
	struct vattr dirfor, diraft;
	nfsfh_t nfh;
	fhandle_t *fhp;
	struct nameidata nd;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_srvnamesiz(len);

	NDINIT(&nd, DELETE, LOCKPARENT | LOCKLEAF, UIO_SYSSPACE, NULL, procp);
	nd.ni_cnd.cn_cred = cred;
	error = nfs_namei(&nd, fhp, len, slp, nam, &info.nmi_md,
	    &info.nmi_dpos, &dirp, procp);
	if (dirp) {
		if (info.nmi_v3)
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred,
				procp);
		else {
			vrele(dirp);
			dirp = NULL;
		}
	}
	if (error) {
		nfsm_reply(NFSX_WCCDATA(info.nmi_v3));
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
		if (dirp)
			vrele(dirp);
		return (0);
	}
	vp = nd.ni_vp;
	if (vp->v_type != VDIR) {
		error = ENOTDIR;
		goto out;
	}
	/*
	 * No rmdir "." please.
	 */
	if (nd.ni_dvp == vp) {
		error = EINVAL;
		goto out;
	}
	/*
	 * The root of a mounted filesystem cannot be deleted.
	 */
	if (vp->v_flag & VROOT)
		error = EBUSY;
out:
	if (!error) {
		error = VOP_RMDIR(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
	} else {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vput(vp);
	}
	if (dirp) {
		diraft_ret = VOP_GETATTR(dirp, &diraft, cred, procp);
		vrele(dirp);
	}
	nfsm_reply(NFSX_WCCDATA(info.nmi_v3));
	if (info.nmi_v3) {
		nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft,
		    &info);
		error = 0;
	}
nfsmout:
	return(error);
}

/*
 * nfs readdir service
 * - mallocs what it thinks is enough to read
 *	count rounded up to a multiple of NFS_DIRBLKSIZ <= NFS_MAXREADDIR
 * - calls VOP_READDIR()
 * - loops around building the reply
 *	if the output generated exceeds count break out of loop
 * - it only knows that it has encountered eof when the VOP_READDIR()
 *	reads nothing
 * - as such one readdir rpc will return eof false although you are there
 *	and then the next will return eof
 * - it trims out records with d_fileno == 0
 *	this doesn't matter for Unix clients, but they might confuse clients
 *	for other os'.
 * NB: It is tempting to set eof to true if the VOP_READDIR() reads less
 *	than requested, but this may not apply to all filesystems. For
 *	example, client NFS does not { although it is never remote mounted
 *	anyhow }
 *     The alternate call nfsrv_readdirplus() does lookups as well.
 * PS: The NFS protocol spec. does not clarify what the "count" byte
 *	argument is a count of.. just name strings and file id's or the
 *	entire reply rpc or ...
 *	I tried just file name and id sizes and it confused the Sun client,
 *	so I am using the full rpc size now. The "paranoia.." comment refers
 *	to including the status longwords that are not a part of the dir.
 *	"entry" structures, but are in the rpc.
 */
struct flrep {
	nfsuint64 fl_off;
	u_int32_t fl_postopok;
	u_int32_t fl_fattr[NFSX_V3FATTR / sizeof (u_int32_t)];
	u_int32_t fl_fhok;
	u_int32_t fl_fhsize;
	u_int32_t fl_nfh[NFSX_V3FH / sizeof (u_int32_t)];
};

int
nfsrv_readdir(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct dirent *dp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	char *cpos, *cend, *cp2, *rbuf;
	struct vnode *vp;
	struct vattr at;
	nfsfh_t nfh;
	fhandle_t *fhp;
	struct uio io;
	struct iovec iv;
	int len, nlen, pad, xfer, error = 0, getret = 1;
	int siz, cnt, fullsiz, eofflag, rdonly;
	u_quad_t off, toff, verf;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	if (info.nmi_v3) {
		nfsm_dissect(tl, u_int32_t *, 5 * NFSX_UNSIGNED);
		toff = fxdr_hyper(tl);
		tl += 2;
		verf = fxdr_hyper(tl);
		tl += 2;
	} else {
		nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		toff = fxdr_unsigned(u_quad_t, *tl++);
	}
	off = toff;
	cnt = fxdr_unsigned(int, *tl);
	siz = ((cnt + DIRBLKSIZ - 1) & ~(DIRBLKSIZ - 1));
	xfer = NFS_SRVMAXDATA(nfsd);
	if (siz > xfer)
		siz = xfer;
	if (cnt > xfer)
		cnt = xfer;
	fullsiz = siz;
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	if (info.nmi_v3)
		error = getret = VOP_GETATTR(vp, &at, cred, procp);
	if (!error)
		error = nfsrv_access(vp, VEXEC, cred, rdonly, procp, 0);
	if (error) {
		vput(vp);
		nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3));
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	VOP_UNLOCK(vp, procp);
	rbuf = malloc(fullsiz, M_TEMP, M_WAITOK);
again:
	iv.iov_base = rbuf;
	iv.iov_len = fullsiz;
	io.uio_iov = &iv;
	io.uio_iovcnt = 1;
	io.uio_offset = (off_t)off;
	io.uio_resid = fullsiz;
	io.uio_segflg = UIO_SYSSPACE;
	io.uio_rw = UIO_READ;
	io.uio_procp = NULL;
	eofflag = 0;

	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, procp);
	error = VOP_READDIR(vp, &io, cred, &eofflag);

	off = (off_t)io.uio_offset;
	if (info.nmi_v3) {
		getret = VOP_GETATTR(vp, &at, cred, procp);
		if (!error)
			error = getret;
	}

	VOP_UNLOCK(vp, procp);
	if (error) {
		vrele(vp);
		free(rbuf, M_TEMP, fullsiz);
		nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3));
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	if (io.uio_resid) {
		siz -= io.uio_resid;

		/*
		 * If nothing read, return eof
		 * rpc reply
		 */
		if (siz == 0) {
			vrele(vp);
			nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3) + NFSX_COOKIEVERF(info.nmi_v3) +
				2 * NFSX_UNSIGNED);
			if (info.nmi_v3) {
				nfsm_srvpostop_attr(nfsd, getret, &at, &info);
				tl = nfsm_build(&info.nmi_mb, 4 * NFSX_UNSIGNED);
				txdr_hyper(at.va_filerev, tl);
				tl += 2;
			} else
				tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED);
			*tl++ = nfs_false;
			*tl = nfs_true;
			free(rbuf, M_TEMP, fullsiz);
			error = 0;
			goto nfsmout;
		}
	}

	/*
	 * Check for degenerate cases of nothing useful read.
	 * If so go try again
	 */
	cpos = rbuf;
	cend = rbuf + siz;
	dp = (struct dirent *)cpos;

	while (cpos < cend && dp->d_fileno == 0) {
		cpos += dp->d_reclen;
		dp = (struct dirent *)cpos;
	}
	if (cpos >= cend) {
		toff = off;
		siz = fullsiz;
		goto again;
	}

	len = 3 * NFSX_UNSIGNED;	/* paranoia, probably can be 0 */
	nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3) + NFSX_COOKIEVERF(info.nmi_v3) + siz);
	if (info.nmi_v3) {
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED);
		txdr_hyper(at.va_filerev, tl);
	}

	/* Loop through the records and build reply */
	while (cpos < cend) {
		if (dp->d_fileno != 0) {
			nlen = dp->d_namlen;
			pad = nfsm_padlen(nlen);
			len += (4 * NFSX_UNSIGNED + nlen + pad);
			if (info.nmi_v3)
				len += 2 * NFSX_UNSIGNED;
			if (len > cnt) {
				eofflag = 0;
				break;
			}
			/*
			 * Build the directory record xdr from
			 * the dirent entry.
			 */
			tl = nfsm_build(&info.nmi_mb,
			    (info.nmi_v3 ? 3 : 2) * NFSX_UNSIGNED);
			*tl++ = nfs_true;
			if (info.nmi_v3)
				txdr_hyper(dp->d_fileno, tl);
			else
				*tl = txdr_unsigned((u_int32_t)dp->d_fileno);
	
			/* And copy the name */
			nfsm_strtombuf(&info.nmi_mb, dp->d_name, nlen);
	
			/* Finish off the record */
			if (info.nmi_v3) {
				tl = nfsm_build(&info.nmi_mb, 2*NFSX_UNSIGNED);
				txdr_hyper(dp->d_off, tl);
			} else {
				tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
				*tl = txdr_unsigned((u_int32_t)dp->d_off);
			}
		}
		cpos += dp->d_reclen;
		dp = (struct dirent *)cpos;
	}
	vrele(vp);
	tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED);
	*tl++ = nfs_false;
	if (eofflag)
		*tl = nfs_true;
	else
		*tl = nfs_false;
	free(rbuf, M_TEMP, fullsiz);
nfsmout:
	return(error);
}

int
nfsrv_readdirplus(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct dirent *dp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	char *cpos, *cend, *cp2, *rbuf;
	struct vnode *vp, *nvp;
	struct flrep fl;
	nfsfh_t nfh;
	fhandle_t *fhp, *nfhp = (fhandle_t *)fl.fl_nfh;
	struct uio io;
	struct iovec iv;
	struct vattr va, at, *vap = &va;
	struct nfs_fattr *fp;
	int len, nlen, pad, xfer, error = 0, getret = 1;
	int siz, cnt, fullsiz, eofflag, rdonly, dirlen;
	u_quad_t off, toff, verf;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_dissect(tl, u_int32_t *, 6 * NFSX_UNSIGNED);
	toff = fxdr_hyper(tl);
	tl += 2;
	verf = fxdr_hyper(tl);
	tl += 2;
	siz = fxdr_unsigned(int, *tl++);
	cnt = fxdr_unsigned(int, *tl);
	off = toff;
	siz = ((siz + DIRBLKSIZ - 1) & ~(DIRBLKSIZ - 1));
	xfer = NFS_SRVMAXDATA(nfsd);
	if (siz > xfer)
		siz = xfer;
	if (cnt > xfer)
		cnt = xfer;
	fullsiz = siz;
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	error = getret = VOP_GETATTR(vp, &at, cred, procp);
	if (!error)
		error = nfsrv_access(vp, VEXEC, cred, rdonly, procp, 0);
	if (error) {
		vput(vp);
		nfsm_reply(NFSX_V3POSTOPATTR);
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	VOP_UNLOCK(vp, procp);

	rbuf = malloc(fullsiz, M_TEMP, M_WAITOK);
again:
	iv.iov_base = rbuf;
	iv.iov_len = fullsiz;
	io.uio_iov = &iv;
	io.uio_iovcnt = 1;
	io.uio_offset = (off_t)off;
	io.uio_resid = fullsiz;
	io.uio_segflg = UIO_SYSSPACE;
	io.uio_rw = UIO_READ;
	io.uio_procp = NULL;
	eofflag = 0;

	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, procp);
	error = VOP_READDIR(vp, &io, cred, &eofflag);

	off = (u_quad_t)io.uio_offset;
	getret = VOP_GETATTR(vp, &at, cred, procp);

	VOP_UNLOCK(vp, procp);

	if (!error)
		error = getret;
	if (error) {
		vrele(vp);
		free(rbuf, M_TEMP, fullsiz);
		nfsm_reply(NFSX_V3POSTOPATTR);
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	if (io.uio_resid) {
		siz -= io.uio_resid;

		/*
		 * If nothing read, return eof
		 * rpc reply
		 */
		if (siz == 0) {
			vrele(vp);
			nfsm_reply(NFSX_V3POSTOPATTR + NFSX_V3COOKIEVERF +
				2 * NFSX_UNSIGNED);
			nfsm_srvpostop_attr(nfsd, getret, &at, &info);
			tl = nfsm_build(&info.nmi_mb, 4 * NFSX_UNSIGNED);
			txdr_hyper(at.va_filerev, tl);
			tl += 2;
			*tl++ = nfs_false;
			*tl = nfs_true;
			free(rbuf, M_TEMP, fullsiz);
			error = 0;
			goto nfsmout;
		}
	}

	/*
	 * Check for degenerate cases of nothing useful read.
	 * If so go try again
	 */
	cpos = rbuf;
	cend = rbuf + siz;
	dp = (struct dirent *)cpos;

	while (cpos < cend && dp->d_fileno == 0) {
		cpos += dp->d_reclen;
		dp = (struct dirent *)cpos;
	}
	if (cpos >= cend) {
		toff = off;
		siz = fullsiz;
		goto again;
	}

	/*
	 * struct READDIRPLUS3resok {
	 *     postop_attr dir_attributes;
	 *     cookieverf3 cookieverf;
	 *     dirlistplus3 reply;
	 * }
	 *
	 * struct dirlistplus3 {
	 *     entryplus3  *entries;
	 *     bool eof;
	 *  }
	 */	
	dirlen = len = NFSX_V3POSTOPATTR + NFSX_V3COOKIEVERF + 2 * NFSX_UNSIGNED;
	nfsm_reply(cnt);
	nfsm_srvpostop_attr(nfsd, getret, &at, &info);
	tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED);
	txdr_hyper(at.va_filerev, tl);

	/* Loop through the records and build reply */
	while (cpos < cend) {
		if (dp->d_fileno != 0) {
			nlen = dp->d_namlen;
			pad = nfsm_padlen(nlen);

			/*
			 * For readdir_and_lookup get the vnode using
			 * the file number.
			 */
			if (VFS_VGET(vp->v_mount, dp->d_fileno, &nvp))
				goto invalid;
			memset(nfhp, 0, NFSX_V3FH);
			nfhp->fh_fsid =
				nvp->v_mount->mnt_stat.f_fsid;
			if (VFS_VPTOFH(nvp, &nfhp->fh_fid)) {
				vput(nvp);
				goto invalid;
			}
			if (VOP_GETATTR(nvp, vap, cred, procp)) {
				vput(nvp);
				goto invalid;
			}
			vput(nvp);

			/*
			 * If either the dircount or maxcount will be
			 * exceeded, get out now. Both of these lengths
			 * are calculated conservatively, including all
			 * XDR overheads.
			 *
			 * Each entry:
			 * 2 * NFSX_UNSIGNED for fileid3
			 * 1 * NFSX_UNSIGNED for length of name
			 * nlen + pad == space the name takes up
			 * 2 * NFSX_UNSIGNED for the cookie
			 * 1 * NFSX_UNSIGNED to indicate if file handle present
			 * 1 * NFSX_UNSIGNED for the file handle length
			 * NFSX_V3FH == space our file handle takes up
			 * NFSX_V3POSTOPATTR == space the attributes take up
			 * 1 * NFSX_UNSIGNED for next pointer
			 */
			len += (8 * NFSX_UNSIGNED + nlen + pad + NFSX_V3FH +
				NFSX_V3POSTOPATTR);
			dirlen += (6 * NFSX_UNSIGNED + nlen + pad);
			if (len > cnt || dirlen > fullsiz) {
				eofflag = 0;
				break;
			}

			tl = nfsm_build(&info.nmi_mb, 3 * NFSX_UNSIGNED);
			*tl++ = nfs_true;
			txdr_hyper(dp->d_fileno, tl);

			/* And copy the name */
			nfsm_strtombuf(&info.nmi_mb, dp->d_name, nlen);

			/*
			 * Build the directory record xdr from
			 * the dirent entry.
			 */
			fp = (struct nfs_fattr *)&fl.fl_fattr;
			nfsm_srvfattr(nfsd, vap, fp);
			fl.fl_fhsize = txdr_unsigned(NFSX_V3FH);
			fl.fl_fhok = nfs_true;
			fl.fl_postopok = nfs_true;
			txdr_hyper(dp->d_off, fl.fl_off.nfsuquad);

			/* Now copy the flrep structure out. */
			nfsm_buftombuf(&info.nmi_mb, &fl, sizeof(struct flrep));
		}
invalid:
		cpos += dp->d_reclen;
		dp = (struct dirent *)cpos;
	}
	vrele(vp);
	tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED);
	*tl++ = nfs_false;
	if (eofflag)
		*tl = nfs_true;
	else
		*tl = nfs_false;
	free(rbuf, M_TEMP, fullsiz);
nfsmout:
	return(error);
}

/*
 * nfs commit service
 */
int
nfsrv_commit(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct vattr bfor, aft;
	struct vnode *vp;
	struct nfsm_info	info;
	nfsfh_t nfh;
	fhandle_t *fhp;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly, for_ret = 1, aft_ret = 1, cnt;
	char *cp2;
	u_quad_t off;
	
	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);

	/*
	 * XXX At this time VOP_FSYNC() does not accept offset and byte
	 * count parameters, so these arguments are useless (someday maybe).
	 */
	off = fxdr_hyper(tl);
	tl += 2;
	cnt = fxdr_unsigned(int, *tl);
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(2 * NFSX_UNSIGNED);
		nfsm_srvwcc(nfsd, for_ret, &bfor, aft_ret, &aft, &info);
		error = 0;
		goto nfsmout;
	}
	for_ret = VOP_GETATTR(vp, &bfor, cred, procp);
	error = VOP_FSYNC(vp, cred, MNT_WAIT, procp);
	aft_ret = VOP_GETATTR(vp, &aft, cred, procp);
	vput(vp);
	nfsm_reply(NFSX_V3WCCDATA + NFSX_V3WRITEVERF);
	nfsm_srvwcc(nfsd, for_ret, &bfor, aft_ret, &aft, &info);
	if (!error) {
		tl = nfsm_build(&info.nmi_mb, NFSX_V3WRITEVERF);
		*tl++ = txdr_unsigned(boottime.tv_sec);
		*tl = txdr_unsigned(boottime.tv_nsec/1000);
	} else
		error = 0;
nfsmout:
	return(error);
}

/*
 * nfs statfs service
 */
int
nfsrv_statfs(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct statfs *sf;
	struct nfs_statfs *sfp;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly, getret = 1;
	char *cp2;
	struct vnode *vp;
	struct vattr at;
	nfsfh_t nfh;
	fhandle_t *fhp;
	struct statfs statfs;
	u_quad_t tval;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	sf = &statfs;
	error = VFS_STATFS(vp->v_mount, sf, procp);
	getret = VOP_GETATTR(vp, &at, cred, procp);
	vput(vp);
	nfsm_reply(NFSX_POSTOPATTR(info.nmi_v3) + NFSX_STATFS(info.nmi_v3));
	if (info.nmi_v3)
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
	if (error) {
		error = 0;
		goto nfsmout;
	}
	sfp = nfsm_build(&info.nmi_mb, NFSX_STATFS(info.nmi_v3));
	if (info.nmi_v3) {
		tval = (u_quad_t)sf->f_blocks;
		tval *= (u_quad_t)sf->f_bsize;
		txdr_hyper(tval, &sfp->sf_tbytes);
		tval = (u_quad_t)sf->f_bfree;
		tval *= (u_quad_t)sf->f_bsize;
		txdr_hyper(tval, &sfp->sf_fbytes);
		tval = (u_quad_t)sf->f_bavail;
		tval *= (u_quad_t)sf->f_bsize;
		txdr_hyper(tval, &sfp->sf_abytes);
		tval = (u_quad_t)sf->f_files;
		txdr_hyper(tval, &sfp->sf_tfiles);
		tval = (u_quad_t)sf->f_ffree;
		txdr_hyper(tval, &sfp->sf_ffiles);
		txdr_hyper(tval, &sfp->sf_afiles);
		sfp->sf_invarsec = 0;
	} else {
		sfp->sf_tsize = txdr_unsigned(NFS_MAXDGRAMDATA);
		sfp->sf_bsize = txdr_unsigned(sf->f_bsize);
		sfp->sf_blocks = txdr_unsigned(sf->f_blocks);
		sfp->sf_bfree = txdr_unsigned(sf->f_bfree);
		sfp->sf_bavail = txdr_unsigned(sf->f_bavail);
	}
nfsmout:
	return(error);
}

/*
 * nfs fsinfo service
 */
int
nfsrv_fsinfo(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct nfsm_info	info;
	u_int32_t *tl;
	struct nfsv3_fsinfo *sip;
	int32_t t1;
	int error = 0, rdonly, getret = 1, pref;
	char *cp2;
	struct vnode *vp;
	struct vattr at;
	nfsfh_t nfh;
	fhandle_t *fhp;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	getret = VOP_GETATTR(vp, &at, cred, procp);
	vput(vp);
	nfsm_reply(NFSX_V3POSTOPATTR + NFSX_V3FSINFO);
	nfsm_srvpostop_attr(nfsd, getret, &at, &info);
	sip = nfsm_build(&info.nmi_mb, NFSX_V3FSINFO);

	/*
	 * XXX
	 * There should be file system VFS OP(s) to get this information.
	 * For now, assume ufs.
	 */
	if (slp->ns_so->so_type == SOCK_DGRAM)
		pref = NFS_MAXDGRAMDATA;
	else
		pref = NFS_MAXDATA;
	sip->fs_rtmax = txdr_unsigned(NFS_MAXDATA);
	sip->fs_rtpref = txdr_unsigned(pref);
	sip->fs_rtmult = txdr_unsigned(NFS_FABLKSIZE);
	sip->fs_wtmax = txdr_unsigned(NFS_MAXDATA);
	sip->fs_wtpref = txdr_unsigned(pref);
	sip->fs_wtmult = txdr_unsigned(NFS_FABLKSIZE);
	sip->fs_dtpref = txdr_unsigned(pref);
	sip->fs_maxfilesize.nfsuquad[0] = 0xffffffff;
	sip->fs_maxfilesize.nfsuquad[1] = 0xffffffff;
	sip->fs_timedelta.nfsv3_sec = 0;
	sip->fs_timedelta.nfsv3_nsec = txdr_unsigned(1);
	sip->fs_properties = txdr_unsigned(NFSV3FSINFO_LINK |
		NFSV3FSINFO_SYMLINK | NFSV3FSINFO_HOMOGENEOUS |
		NFSV3FSINFO_CANSETTIME);
nfsmout:
	return(error);
}

/*
 * nfs pathconf service
 */
int
nfsrv_pathconf(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct mbuf *nam = nfsd->nd_nam;
	struct ucred *cred = &nfsd->nd_cr;
	struct nfsm_info	info;
	u_int32_t *tl;
	struct nfsv3_pathconf *pc;
	int32_t t1;
	int error = 0, rdonly, getret = 1;
	register_t linkmax, namemax, chownres, notrunc;
	char *cp2;
	struct vnode *vp;
	struct vattr at;
	nfsfh_t nfh;
	fhandle_t *fhp;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		nfsm_reply(NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, getret, &at, &info);
		error = 0;
		goto nfsmout;
	}
	error = VOP_PATHCONF(vp, _PC_LINK_MAX, &linkmax);
	if (!error)
		error = VOP_PATHCONF(vp, _PC_NAME_MAX, &namemax);
	if (!error)
		error = VOP_PATHCONF(vp, _PC_CHOWN_RESTRICTED, &chownres);
	if (!error)
		error = VOP_PATHCONF(vp, _PC_NO_TRUNC, &notrunc);
	getret = VOP_GETATTR(vp, &at, cred, procp);
	vput(vp);
	nfsm_reply(NFSX_V3POSTOPATTR + NFSX_V3PATHCONF);
	nfsm_srvpostop_attr(nfsd, getret, &at, &info);
	if (error) {
		error = 0;
		goto nfsmout;
	}
	pc = nfsm_build(&info.nmi_mb, NFSX_V3PATHCONF);

	pc->pc_linkmax = txdr_unsigned(linkmax);
	pc->pc_namemax = txdr_unsigned(namemax);
	pc->pc_notrunc = txdr_unsigned(notrunc);
	pc->pc_chownrestricted = txdr_unsigned(chownres);

	/*
	 * These should probably be supported by VOP_PATHCONF(), but
	 * until msdosfs is exportable (why would you want to?), the
	 * Unix defaults should be ok.
	 */
	pc->pc_caseinsensitive = nfs_false;
	pc->pc_casepreserving = nfs_true;
nfsmout:
	return(error);
}

/*
 * Null operation, used by clients to ping server
 */
/* ARGSUSED */
int
nfsrv_null(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{
	struct nfsm_info	info;
	int error = NFSERR_RETVOID;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	nfsm_reply(0);
	return (0);
}

/*
 * No operation, used for obsolete procedures
 */
/* ARGSUSED */
int
nfsrv_noop(struct nfsrv_descript *nfsd, struct nfssvc_sock *slp,
    struct proc *procp, struct mbuf **mrq)
{	
	struct nfsm_info	info;
	int error;

	info.nmi_mreq = NULL;
	info.nmi_mrep = nfsd->nd_mrep;
	info.nmi_md = nfsd->nd_md;
	info.nmi_dpos = nfsd->nd_dpos;
	info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);

	if (nfsd->nd_repstat)
		error = nfsd->nd_repstat;
	else
		error = EPROCUNAVAIL;
	nfsm_reply(0);
	return (0);
}

/*
 * Perform access checking for vnodes obtained from file handles that would
 * refer to files already opened by a Unix client.
 * You cannot just use vn_writechk() and VOP_ACCESS() for two reasons:
 * 1 - You must check for exported rdonly as well as MNT_RDONLY for the
 *     write case
 * 2 - The owner is to be given access irrespective of mode bits for some
 *     operations, so that processes that chmod after opening a file don't
 *     break. I don't like this because it opens a security hole, but since
 *     the nfs server opens a security hole the size of a barn door anyhow,
 *     what the heck. A notable exception to this rule is when VOP_ACCESS()
 *     returns EPERM (e.g. when a file is immutable) which is always an
 *     error.
 */
int
nfsrv_access(struct vnode *vp, int flags, struct ucred *cred, int rdonly,
    struct proc *p, int override)
{
	struct vattr vattr;
	int error;

	if (flags & VWRITE) {
		/* Just vn_writechk() changed to check rdonly */
		/*
		 * Disallow write attempts on read-only file systems;
		 * unless the file is a socket or a block or character
		 * device resident on the file system.
		 */
		if (rdonly || (vp->v_mount->mnt_flag & MNT_RDONLY)) {
			switch (vp->v_type) {
			case VREG:
			case VDIR:
			case VLNK:
				return (EROFS);
			default:
				break;
			}
		}
		/*
		 * If there's shared text associated with
		 * the inode, try to free it up once.  If
		 * we fail, we can't allow writing.
		 */
		if ((vp->v_flag & VTEXT) && !uvm_vnp_uncache(vp))
			return (ETXTBSY);
	}
	error = VOP_ACCESS(vp, flags, cred, p);
	/*
	 * Allow certain operations for the owner (reads and writes
	 * on files that are already open).
	 */
	if (override && error == EACCES &&
	    VOP_GETATTR(vp, &vattr, cred, p) == 0 &&
	    cred->cr_uid == vattr.va_uid)
		error = 0;
	return error;
}
@


1.110
log
@Fix nfsrv_symlink() indentation.  No binary change.
ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.109 2016/07/04 18:34:03 natano Exp $	*/
d91 2
@


1.109
log
@Add missing vput() in error path to prevent a vnode getting stuck with a
stale reference and lock, while it shouldn't hold either.

"makes sense to me" beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.108 2016/04/29 14:40:36 beck Exp $	*/
d1736 20
a1755 18
	    if (info.nmi_v3) {
		nd.ni_cnd.cn_nameiop = LOOKUP;
		nd.ni_cnd.cn_flags &= ~(LOCKPARENT | SAVESTART | FOLLOW);
		nd.ni_cnd.cn_flags |= (NOFOLLOW | LOCKLEAF);
		nd.ni_cnd.cn_proc = procp;
		nd.ni_cnd.cn_cred = cred;
		error = vfs_lookup(&nd);
		if (!error) {
			memset(fhp, 0, sizeof(nfh));
			fhp->fh_fsid = nd.ni_vp->v_mount->mnt_stat.f_fsid;
			error = VFS_VPTOFH(nd.ni_vp, &fhp->fh_fid);
			if (!error)
				error = VOP_GETATTR(nd.ni_vp, &va, cred,
					procp);
			vput(nd.ni_vp);
		}
	    } else
		vrele(nd.ni_startdir);
@


1.108
log
@Fix some gibbering horrors due to uninitialized struct nameidata's

1) turn NDINITAT into a function and make the macros point to it
with the later goal of getting rid of them.

2) Sweep the kernel for places where people make a struct nameidata manually
on the stack and fill in what they hope are the required fields and count
on prayer and clean living to always get them right. Instead use NDINIT
everywhere. NFS was especially bad for this and there have likely
been things lurking there for a while.

3) Add a couple of strategic KASSERT's to catch future offenders.

ok krw@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.107 2016/03/19 12:04:16 natano Exp $	*/
d1166 6
a1171 1
		vput(nd.ni_dvp);
d1193 5
a1197 1
		vput(nd.ni_dvp);
@


1.107
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.106 2015/08/30 02:18:28 deraadt Exp $	*/
d371 2
a373 2
	nd.ni_cnd.cn_nameiop = LOOKUP;
	nd.ni_cnd.cn_flags = LOCKLEAF | SAVESTART;
d885 3
a888 2
	nd.ni_cnd.cn_nameiop = CREATE;
	nd.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF | SAVESTART;
a1139 1
	nd.ni_cnd.cn_nameiop = 0;
d1143 3
a1146 2
	nd.ni_cnd.cn_nameiop = CREATE;
	nd.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF | SAVESTART;
d1293 2
a1295 2
	nd.ni_cnd.cn_nameiop = DELETE;
	nd.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF;
a1377 2
	fromnd.ni_cnd.cn_nameiop = 0;
	tond.ni_cnd.cn_nameiop = 0;
d1386 3
a1389 2
	fromnd.ni_cnd.cn_nameiop = DELETE;
	fromnd.ni_cnd.cn_flags = WANTPARENT | SAVESTART;
d1416 3
a1419 2
	tond.ni_cnd.cn_nameiop = RENAME;
	tond.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF | NOCACHE | SAVESTART;
d1583 2
a1585 2
	nd.ni_cnd.cn_nameiop = CREATE;
	nd.ni_cnd.cn_flags = LOCKPARENT;
a1666 1
	nd.ni_cnd.cn_nameiop = 0;
d1671 1
a1672 2
	nd.ni_cnd.cn_nameiop = CREATE;
	nd.ni_cnd.cn_flags = LOCKPARENT | SAVESTART;
d1815 1
a1816 2
	nd.ni_cnd.cn_nameiop = CREATE;
	nd.ni_cnd.cn_flags = LOCKPARENT;
d1930 2
a1932 2
	nd.ni_cnd.cn_nameiop = DELETE;
	nd.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF;
@


1.106
log
@Keep track of a length for free() in error paths.  Be careful,
because the nfsm_strsiz() macro sneakily modifies a parameter!
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.105 2015/07/15 22:16:42 deraadt Exp $	*/
d2098 1
a2098 1
	VOP_UNLOCK(vp, 0, procp);
d2122 1
a2122 1
	VOP_UNLOCK(vp, 0, procp);
d2297 1
a2297 1
	VOP_UNLOCK(vp, 0, procp);
d2318 1
a2318 1
	VOP_UNLOCK(vp, 0, procp);
@


1.105
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.104 2015/06/11 08:39:51 blambert Exp $	*/
d1655 1
a1655 1
	int error = 0, len, len2, dirfor_ret = 1, diraft_ret = 1;
d1695 2
a1696 1
	pathcp = malloc(len2 + 1, M_TEMP, M_WAITOK);
d1750 1
a1750 1
		free(pathcp, M_TEMP, 0);
d1781 1
a1781 1
		free(pathcp, M_TEMP, 0);
@


1.104
log
@Avoid double-free in error path by cribbing the HASBUF flag
logic from the rest of the kernel that deals with filename
lookups.

In snaps for some time.

Initially found by jsg@@
Prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.103 2015/05/06 02:19:40 jsg Exp $	*/
d480 1
a480 1
	if (error && mp)
@


1.103
log
@add missing braces
ok guenther@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.102 2015/03/14 03:38:52 jsg Exp $	*/
a881 1
	nd.ni_cnd.cn_nameiop = 0;
d981 4
a984 1
				pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d996 4
a999 1
				pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1009 4
a1012 1
				pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1017 1
a1017 1
			
d1031 1
d1040 1
d1094 1
a1094 1
	if (nd.ni_cnd.cn_nameiop) {
d1096 4
a1099 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
@


1.102
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.101 2014/12/16 18:30:04 tedu Exp $	*/
d1675 1
a1675 1
	if (info.nmi_v3)
d1680 1
@


1.101
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.100 2014/11/18 02:22:33 tedu Exp $	*/
a78 1
#include <nfs/rpcv2.h>
@


1.100
log
@Reduce scope of iovec variables, use mallocarray, and record size for
free. Change rbuf malloc argument to fullsiz, which then makes clear it's
the correct size to pass to free. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.99 2014/11/14 23:01:44 tedu Exp $	*/
d64 1
@


1.99
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.98 2014/11/03 21:28:35 tedu Exp $	*/
a511 2
	struct iovec *iv;
	struct iovec *iv2;
d590 2
d612 2
a613 1
		iv = malloc(i * sizeof(struct iovec), M_TEMP, M_WAITOK);
d639 1
a639 1
		free(iv2, M_TEMP, 0);
a682 1
	struct iovec *ivp;
a686 1
	struct iovec *iv;
d776 5
a780 1
	    ivp = malloc(cnt * sizeof(struct iovec), M_TEMP, M_WAITOK);
d806 1
a806 1
	    free(iv, M_TEMP, 0);
d2084 1
a2084 1
	rbuf = malloc(siz, M_TEMP, M_WAITOK);
d2110 1
a2110 1
		free((caddr_t)rbuf, M_TEMP, 0);
d2136 1
a2136 1
			free(rbuf, M_TEMP, 0);
d2214 1
a2214 1
	free(rbuf, M_TEMP, 0);
d2284 1
a2284 1
	rbuf = malloc(siz, M_TEMP, M_WAITOK);
d2309 1
a2309 1
		free((caddr_t)rbuf, M_TEMP, 0);
d2332 1
a2332 1
			free(rbuf, M_TEMP, 0);
d2456 1
a2456 1
	free(rbuf, M_TEMP, 0);
@


1.98
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.97 2014/07/12 18:43:52 tedu Exp $	*/
d389 1
a389 1
	bzero((caddr_t)fhp, sizeof(nfh));
d1049 1
a1049 1
		bzero((caddr_t)fhp, sizeof(nfh));
d1212 1
a1212 1
		bzero((caddr_t)fhp, sizeof(nfh));
d1718 1
a1718 1
			bzero((caddr_t)fhp, sizeof(nfh));
d1845 1
a1845 1
		bzero((caddr_t)fhp, sizeof(nfh));
d2383 1
a2383 1
			bzero((caddr_t)nfhp, NFSX_V3FH);
@


1.97
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.96 2014/07/08 17:19:26 deraadt Exp $	*/
d73 2
@


1.96
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.95 2014/04/21 12:49:34 beck Exp $	*/
d636 1
a636 1
		free(iv2, M_TEMP);
d801 1
a801 1
	    free(iv, M_TEMP);
d1730 1
a1730 1
		free(pathcp, M_TEMP);
d1761 1
a1761 1
		free(pathcp, M_TEMP);
d2105 1
a2105 1
		free((caddr_t)rbuf, M_TEMP);
d2131 1
a2131 1
			free(rbuf, M_TEMP);
d2209 1
a2209 1
	free(rbuf, M_TEMP);
d2304 1
a2304 1
		free((caddr_t)rbuf, M_TEMP);
d2327 1
a2327 1
			free(rbuf, M_TEMP);
d2451 1
a2451 1
	free(rbuf, M_TEMP);
@


1.95
log
@Back out most of v1.47 changes which mess up the block size on these
reads.
ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.46 2007/11/08 19:20:09 blambert Exp $	*/
a73 2

#include <uvm/uvm_extern.h>
@


1.94
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.93 2013/06/03 16:55:22 guenther Exp $	*/
d2053 9
a2061 1

d2069 2
a2070 2

	error = getret = VOP_GETATTR(vp, &at, cred, procp);
a2079 10

	off = toff;
	cnt = fxdr_unsigned(int, *tl);
	siz = ((cnt + at.va_blocksize - 1) & ~(at.va_blocksize - 1));
	xfer = NFS_SRVMAXDATA(nfsd);
	if (siz > xfer)
		siz = xfer;
	if (cnt > xfer)
		cnt = xfer;
	fullsiz = siz;
d2252 10
a2261 1

a2268 1

d2279 1
a2280 11
	siz = fxdr_unsigned(int, *tl++);
	cnt = fxdr_unsigned(int, *tl);
	off = toff;
	siz = ((siz + at.va_blocksize - 1) & ~(at.va_blocksize - 1));
	xfer = NFS_SRVMAXDATA(nfsd);
	if (siz > xfer)
		siz = xfer;
	if (cnt > xfer)
		cnt = xfer;
	fullsiz = siz;
	VOP_UNLOCK(vp, 0, procp);
@


1.93
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.92 2012/03/21 16:33:21 kettenis Exp $	*/
d2032 1
a2032 1
	int siz, cnt, fullsiz, eofflag, rdonly, ncookies;
a2033 1
	u_long *cookies = NULL, *cookiep;
a2095 5
	if (cookies) {
		free((caddr_t)cookies, M_TEMP);
		cookies = NULL;
	}

d2097 1
a2097 1
	error = VOP_READDIR(vp, &io, cred, &eofflag, &ncookies, &cookies);
a2099 2
	if (!cookies && !error)
		error = NFSERR_PERM;
a2109 2
		if (cookies)
			free((caddr_t)cookies, M_TEMP);
a2135 1
			free(cookies, M_TEMP);
a2147 1
	cookiep = cookies;
d2149 1
a2149 1
	while (cpos < cend && ncookies > 0 && dp->d_fileno == 0) {
a2151 2
		cookiep++;
		ncookies--;
d2153 1
a2153 1
	if (cpos >= cend || ncookies == 0) {
d2168 1
a2168 1
	while (cpos < cend && ncookies > 0) {
d2183 2
a2184 1
			tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED);
d2186 4
a2189 5
			if (info.nmi_v3) {
				*tl = 0;
				tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
			}
			*tl = txdr_unsigned(dp->d_fileno);
d2196 3
d2200 1
a2200 1
				*tl = 0;
a2201 2
			tl = nfsm_build(&info.nmi_mb, NFSX_UNSIGNED);
			*tl = txdr_unsigned(*cookiep);
a2204 2
		cookiep++;
		ncookies--;
a2213 1
	free(cookies, M_TEMP);
d2238 1
a2238 1
	int siz, cnt, fullsiz, eofflag, rdonly, dirlen, ncookies;
a2239 1
	u_long *cookies = NULL, *cookiep;
a2297 5
	if (cookies) {
		free((caddr_t)cookies, M_TEMP);
		cookies = NULL;
	}

d2299 1
a2299 1
	error = VOP_READDIR(vp, &io, cred, &eofflag, &ncookies, &cookies);
a2305 2
	if (!cookies && !error)
		error = NFSERR_PERM;
a2309 2
		if (cookies)
			free((caddr_t)cookies, M_TEMP);
a2332 1
			free(cookies, M_TEMP);
a2345 1
	cookiep = cookies;
d2347 1
a2347 1
	while (cpos < cend && ncookies > 0 && dp->d_fileno == 0) {
a2349 2
		cookiep++;
		ncookies--;
d2351 1
a2351 1
	if (cpos >= cend || ncookies == 0) {
d2376 1
a2376 1
	while (cpos < cend && ncookies > 0) {
d2427 1
a2427 2
			*tl++ = 0;
			*tl = txdr_unsigned(dp->d_fileno);
d2441 1
a2441 2
			fl.fl_off.nfsuquad[0] = 0;
			fl.fl_off.nfsuquad[1] = txdr_unsigned(*cookiep);
a2448 2
		cookiep++;
		ncookies--;
a2456 1
	free(cookies, M_TEMP);
@


1.92
log
@Prevent vrele() being called with a NULL argument if nfs_namei() returns an
error in several places.

Should fix the "vrele: null vp" panic that henning@@ has been seeing lately.

ok tedu@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.91 2010/09/09 10:37:04 thib Exp $	*/
d829 1
a829 1
		*tl = txdr_unsigned(boottime.tv_usec);
d2550 1
a2550 1
		*tl = txdr_unsigned(boottime.tv_usec);
@


1.91
log
@Rename lookup/relookup to vfs_lookup/vfs_relookup.

OK oga@@, beck@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.90 2010/03/29 23:33:39 krw Exp $	*/
d900 1
a900 1
		if (info.nmi_v3)
d1137 2
a1138 1
		vrele(dirp);
d1391 1
a1391 1
		if (info.nmi_v3)
d1815 1
a1815 1
		if (info.nmi_v3)
d1932 1
a1932 1
		if (info.nmi_v3)
@


1.90
log
@Initialize various uninitialized variables. Found by jsg@@ via Clang.

Feedback from miod@@ and kettenis@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.89 2009/10/19 22:24:18 jsg Exp $	*/
d1000 1
a1000 1
			if ((error = lookup(&nd)) != 0) {
d1197 1
a1197 1
		error = lookup(&nd);
d1715 1
a1715 1
		error = lookup(&nd);
@


1.89
log
@antsy
no binary change apart from nfsm_reqhead() which is clearly correct.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.88 2009/08/30 15:16:19 thib Exp $	*/
d441 2
@


1.88
log
@if nfs_namei() fails, there's no ni_startdir and the pathname buffer has
already been freed, thus make the callers of nfs_namei() bail out early,
instead of jumping to nfsmout as there they will try to vrele() vnodes
that don't exists (NULL pointers) and free the pathname buffer.

this is way nicer then adding checks after the nfsmout label.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.86 2009/08/14 11:06:35 blambert Exp $	*/
d96 2
a97 5
nfsrv3_access(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d160 2
a161 5
nfsrv_getattr(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d207 2
a208 5
nfsrv_setattr(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d344 2
a345 5
nfsrv_lookup(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d418 2
a419 5
nfsrv_readlink(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d505 2
a506 5
nfsrv_read(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d675 2
a676 5
nfsrv_write(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d848 2
a849 5
nfsrv_create(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d1097 2
a1098 5
nfsrv_mknod(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d1246 2
a1247 5
nfsrv_remove(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d1331 2
a1332 5
nfsrv_rename(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d1522 2
a1523 5
nfsrv_link(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d1622 2
a1623 5
nfsrv_symlink(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d1768 2
a1769 5
nfsrv_mkdir(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d1886 2
a1887 5
nfsrv_rmdir(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2012 2
a2013 5
nfsrv_readdir(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2232 2
a2233 5
nfsrv_readdirplus(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2498 2
a2499 5
nfsrv_commit(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2558 2
a2559 5
nfsrv_statfs(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2635 2
a2636 5
nfsrv_fsinfo(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2703 2
a2704 5
nfsrv_pathconf(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2773 2
a2774 5
nfsrv_null(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2794 2
a2795 5
nfsrv_noop(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
d2829 2
a2830 7
nfsrv_access(vp, flags, cred, rdonly, p, override)
	struct vnode *vp;
	int flags;
	struct ucred *cred;
	int rdonly;
	struct proc *p;
	int override;
@


1.87
log
@Avoid double-release of vnodes in several functions

ok thib@@
@
text
@d396 1
a396 2
		error = 0;
		goto nfsmout;
d912 1
a912 2
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred,
				procp);
d922 3
a924 2
		error = 0;
		goto nfsmout;
d926 1
d1162 2
a1163 2
		error = 0;
		goto nfsmout;
d1165 1
d1309 2
a1310 3
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred,
				procp);
		else
d1312 2
d1315 1
d1350 1
a1350 2
		error = 0;
		goto nfsmout;
d1352 1
d1421 3
a1423 2
		error = 0;
		goto nfsmout;
d1425 1
d1541 1
a1541 2
		 * to the same vnode as fdirp. The real fix is to not have
		 * multiple pointers to the same object.
d1844 1
a1844 2
			dirfor_ret = VOP_GETATTR(dirp, &dirfor, cred,
				procp);
d1854 3
a1856 2
		error = 0;
		goto nfsmout;
d1858 1
d1974 1
a1974 1
		if (dirp)
d1976 1
a1976 2
		error = 0;
		goto nfsmout;
@


1.86
log
@Initialize len variable; found by Martynas Venckus

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.85 2009/08/13 15:03:19 blambert Exp $	*/
a923 2
		if (dirp)
			vrele(dirp);
a1161 4
		if (dirp) {
			vrele(dirp);
			dirp = NULL;
		}
a1850 2
		if (dirp)
			vrele(dirp);
@


1.85
log
@change version 3 post-operation attribute building function to not
use mbufs directly, but the shiny new nfsm_info struct

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.84 2009/08/11 11:07:36 thib Exp $	*/
d444 1
a444 1
	int error = 0, rdonly, tlen, len, getret;
@


1.84
log
@Fix a few bugs in nfsrv_rename() error recovery code.

- Prevent a double vrele() by setting the vnode pointer to NULL.
- Check if vnode pointers have been set to NULL before trying to
  vrele().
- don't double free the component path name buffer.
- Add a workaround for multiple vnode pointers all pointing to the
  same vnode and the code doing vrele() on all of them, leading to
  botched refcounts. This is a horrible hack, but a real fix is being
  worked on.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.82 2009/08/10 09:38:44 thib Exp $	*/
d126 1
a126 1
		nfsm_srvpostop_attr(nfsd, 1, NULL, &info.nmi_mb);
d152 1
a152 1
	nfsm_srvpostop_attr(nfsd, getret, &va, &info.nmi_mb);
d292 1
a292 1
		nfsm_srvwcc(nfsd, preat_ret, &preat, postat_ret, &va, &info.nmi_mb);
d306 1
a306 1
			    &info.nmi_mb);
d338 1
a338 1
		    &info.nmi_mb);
d395 1
a395 1
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &info.nmi_mb);
d411 1
a411 1
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &info.nmi_mb);
d417 2
a418 2
		nfsm_srvpostop_attr(nfsd, 0, &va, &info.nmi_mb);
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &info.nmi_mb);
d463 1
a463 1
		nfsm_srvpostop_attr(nfsd, 1, NULL, &info.nmi_mb);
d498 1
a498 1
		nfsm_srvpostop_attr(nfsd, getret, &attr, &info.nmi_mb);
d686 1
a686 1
	nfsm_srvpostop_attr(nfsd, getret, &va, &info.nmi_mb);
d832 1
a832 1
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &info.nmi_mb);
d861 1
a861 1
	nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &info.nmi_mb);
d923 1
a923 1
		    &info.nmi_mb);
d1092 1
a1092 1
			nfsm_srvpostop_attr(nfsd, 0, &va, &info.nmi_mb);
d1095 1
a1095 1
		    &info.nmi_mb);
d1163 1
a1163 1
		    &info.nmi_mb);
d1253 1
a1253 1
		nfsm_srvpostop_attr(nfsd, 0, &va, &info.nmi_mb);
d1255 1
a1255 1
	nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft, &info.nmi_mb);
d1352 1
a1352 1
		    &info.nmi_mb);
d1421 1
a1421 1
		    &info.nmi_mb);
d1423 1
a1423 1
		    &info.nmi_mb);
d1520 1
a1520 1
		    &info.nmi_mb);
d1522 1
a1522 1
		    &info.nmi_mb);
d1593 1
a1593 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d1595 1
a1595 1
		    &info.nmi_mb);
d1647 1
a1647 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d1649 1
a1649 1
		     &info.nmi_mb);
d1780 1
a1780 1
			nfsm_srvpostop_attr(nfsd, 0, &va, &info.nmi_mb);
d1783 1
a1783 1
		    &info.nmi_mb);
d1856 1
a1856 1
		    &info.nmi_mb);
d1904 1
a1904 1
			nfsm_srvpostop_attr(nfsd, 0, &va, &info.nmi_mb);
d1907 1
a1907 1
		    &info.nmi_mb);
d1976 1
a1976 1
		    &info.nmi_mb);
d2017 1
a2017 1
		    &info.nmi_mb);
d2107 1
a2107 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2118 1
a2118 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2170 1
a2170 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2186 1
a2186 1
				nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2225 1
a2225 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2327 1
a2327 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2338 1
a2338 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2390 1
a2390 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2405 1
a2405 1
			nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2453 1
a2453 1
	nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2592 1
a2592 2
		nfsm_srvwcc(nfsd, for_ret, &bfor, aft_ret, &aft,
		    &info.nmi_mb);
d2601 1
a2601 1
	nfsm_srvwcc(nfsd, for_ret, &bfor, aft_ret, &aft, &info.nmi_mb);
d2649 1
a2649 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2659 1
a2659 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2726 1
a2726 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2733 1
a2733 1
	nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2798 1
a2798 1
		nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
d2812 1
a2812 1
	nfsm_srvpostop_attr(nfsd, getret, &at, &info.nmi_mb);
@


1.83
log
@Another

error = operation();
memory = malloc();
if (error) free(memory);

gets relegated to the dustbin of history

ok thib@@
@
text
@d1164 1
a1164 1
		if (dirp)
d1166 2
a1423 2
		if (fdirp)
			vrele(fdirp);
d1536 2
a1537 2
		vrele(fromnd.ni_startdir);
		pool_put(&namei_pool, fromnd.ni_cnd.cn_pnbuf);
d1539 10
a1548 2
		vrele(fromnd.ni_dvp);
		vrele(fvp);
@


1.82
log
@Remove the v2 writegather code. It did help alot back in the 80s
but extensive performance benchmarking done by myself and jasper@@
has shown that it doesn't help, at all - even on vaxens and in some
cases it makes things significantly slower.

"this excites me sexually" jetpack@@
Tested by jasper@@.
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.80 2009/08/09 15:13:48 blambert Exp $	*/
d467 7
d489 1
a489 7
	if (vp->v_type != VLNK) {
		if (info.nmi_v3)
			error = EINVAL;
		else
			error = ENXIO;
		goto out;
	}
d494 1
a494 1
	if (error)
@


1.81
log
@MLEN < NFS_MAXPATHLEN < MCLBYTES, so there's no need to
loop over allocating a chain of mbufs to store <= NFS_MAXPATHLEN
bytes.

Clean up some variables, which thib@@ likes.

ok thib@@
@
text
@a90 5
int nfsrvw_procrastinate = NFS_GATHERDELAY * 1000;
struct timeval nfsrvw_procrastinate_tv = {
	(NFS_GATHERDELAY * 1000) / 1000000,	/* tv_sec */
	(NFS_GATHERDELAY * 1000) % 1000000	/* tv_usec */
};
a861 366
}

/*
 * NFS write service with write gathering support. Called when
 * nfsrvw_procrastinate > 0.
 * See: Chet Juszczak, "Improving the Write Performance of an NFS Server",
 * in Proc. of the Winter 1994 Usenix Conference, pg. 247-259, San Franscisco,
 * Jan. 1994.
 */
int
nfsrv_writegather(ndp, slp, procp, mrq)
	struct nfsrv_descript **ndp;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
{
	struct iovec *ivp;
	struct mbuf *mp;
	struct nfsrv_descript *wp, *nfsd, *nnfsd, *owp, *swp;
	struct nfs_fattr *fp;
	struct nfsm_info	info;
	int i = 0;
	struct iovec *iov;
	struct nfsrvw_delayhash *wpp;
	struct ucred *cred;
	struct vattr va, forat;
	u_int32_t *tl;
	int32_t t1;
	int error = 0, rdonly, len = 0, forat_ret = 1;
	int ioflags, aftat_ret = 1, s, adjust, zeroing;
	char *cp2;
	struct vnode *vp;
	struct uio io, *uiop = &io;
	struct timeval tv;

	*mrq = NULL;
	if (*ndp) {
	    nfsd = *ndp;
	    *ndp = NULL;
	    info.nmi_mreq = NULL;
	    info.nmi_mrep = nfsd->nd_mrep;
	    info.nmi_md = nfsd->nd_md;
	    info.nmi_dpos = nfsd->nd_dpos;
	    cred = &nfsd->nd_cr;
	    info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);
	    LIST_INIT(&nfsd->nd_coalesce);
	    nfsd->nd_mreq = NULL;
	    nfsd->nd_stable = NFSV3WRITE_FILESYNC;
	    getmicrotime(&tv);
	    timeradd(&tv, &nfsrvw_procrastinate_tv, &nfsd->nd_time);
    
	    /*
	     * Now, get the write header..
	     */
	    nfsm_srvmtofh(&nfsd->nd_fh);
	    if (info.nmi_v3) {
		nfsm_dissect(tl, u_int32_t *, 5 * NFSX_UNSIGNED);
		nfsd->nd_off = fxdr_hyper(tl);
		tl += 3;
		nfsd->nd_stable = fxdr_unsigned(int, *tl++);
	    } else {
		nfsm_dissect(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
		nfsd->nd_off = (off_t)fxdr_unsigned(u_int32_t, *++tl);
		tl += 2;
	    }
	    len = fxdr_unsigned(int32_t, *tl);
	    nfsd->nd_len = len;
	    nfsd->nd_eoff = nfsd->nd_off + len;
    
	    /*
	     * Trim the header out of the mbuf list and trim off any trailing
	     * junk so that the mbuf list has only the write data.
	     */
	    zeroing = 1;
	    i = 0;
	    mp = info.nmi_mrep;
	    while (mp) {
		if (mp == info.nmi_md) {
		    zeroing = 0;
		    adjust = info.nmi_dpos - mtod(mp, caddr_t);
		    mp->m_len -= adjust;
		    if (mp->m_len > 0 && adjust > 0)
		    	mp->m_data += adjust;
		}
		if (zeroing)
		    mp->m_len = 0;
		else {
		    i += mp->m_len;
		    if (i > len) {
			mp->m_len -= (i - len);
			zeroing = 1;
		    }
		}
		mp = mp->m_next;
	    }
	    if (len > NFS_MAXDATA || len < 0  || i < len) {
		m_freem(info.nmi_mrep);
nfsmout:
		error = EIO;
		nfsm_writereply(2 * NFSX_UNSIGNED, info.nmi_v3);
		if (info.nmi_v3)
		    nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va,
		        &info.nmi_mb);
		nfsd->nd_mreq = info.nmi_mreq;
		nfsd->nd_mrep = NULL;
		timerclear(&nfsd->nd_time);
	    }
    
	    /*
	     * Add this entry to the hash and time queues.
	     */
	    s = splsoftclock();
	    owp = NULL;
	    wp = LIST_FIRST(&slp->ns_tq);
	    while (wp && timercmp(&wp->nd_time, &nfsd->nd_time, <)) {
		owp = wp;
		wp = LIST_NEXT(wp, nd_tq);
	    }
	    if (owp) {
		LIST_INSERT_AFTER(owp, nfsd, nd_tq);
	    } else {
		LIST_INSERT_HEAD(&slp->ns_tq, nfsd, nd_tq);
	    }
	    if (nfsd->nd_mrep) {
		wpp = NWDELAYHASH(slp, nfsd->nd_fh.fh_fid.fid_data);
		owp = NULL;
		wp = LIST_FIRST(wpp);
		while (wp &&
		    bcmp((caddr_t)&nfsd->nd_fh,(caddr_t)&wp->nd_fh,NFSX_V3FH)) {
		    owp = wp;
		    wp = LIST_NEXT(wp, nd_hash);
		}
		while (wp && wp->nd_off < nfsd->nd_off &&
		   !bcmp((caddr_t)&nfsd->nd_fh,(caddr_t)&wp->nd_fh,NFSX_V3FH)) {
		    owp = wp;
		    wp = LIST_NEXT(wp, nd_hash);
		}
		if (owp) {
		    LIST_INSERT_AFTER(owp, nfsd, nd_hash);

		    /*
		     * Search the hash list for overlapping entries and
		     * coalesce.
		     */
		    for(; nfsd && NFSW_CONTIG(owp, nfsd); nfsd = wp) {
			wp = LIST_NEXT(nfsd, nd_hash);
			if (NFSW_SAMECRED(owp, nfsd))
			    nfsrvw_coalesce(owp, nfsd);
		    }
		} else {
		    LIST_INSERT_HEAD(wpp, nfsd, nd_hash);
		}
	    }
	    splx(s);
	}
    
	/*
	 * Now, do VOP_WRITE()s for any one(s) that need to be done now
	 * and generate the associated reply mbuf list(s).
	 */
loop1:
	getmicrotime(&tv);
	s = splsoftclock();
	for (nfsd = LIST_FIRST(&slp->ns_tq); nfsd != NULL; nfsd = owp) {
		owp = LIST_NEXT(nfsd, nd_tq);
		if (timercmp(&nfsd->nd_time, &tv, >))
		    break;
		if (nfsd->nd_mreq)
		    continue;
		LIST_REMOVE(nfsd, nd_tq);
		LIST_REMOVE(nfsd, nd_hash);
		splx(s);
		info.nmi_mrep = nfsd->nd_mrep;
		nfsd->nd_mrep = NULL;
		cred = &nfsd->nd_cr;
		info.nmi_v3 = (nfsd->nd_flag & ND_NFSV3);
		forat_ret = aftat_ret = 1;
		error = nfsrv_fhtovp(&nfsd->nd_fh, 1, &vp, cred, slp,
		    nfsd->nd_nam, &rdonly);
		if (!error) {
		    if (info.nmi_v3)
			forat_ret = VOP_GETATTR(vp, &forat, cred, procp);
		    if (vp->v_type != VREG) {
			if (info.nmi_v3)
			    error = EINVAL;
			else
			    error = (vp->v_type == VDIR) ? EISDIR : EACCES;
		    }
		} else
		    vp = NULL;
		if (!error) {
		    error = nfsrv_access(vp, VWRITE, cred, rdonly, procp, 1);
		}
    
		if (nfsd->nd_stable == NFSV3WRITE_UNSTABLE)
		    ioflags = IO_NODELOCKED;
		else if (nfsd->nd_stable == NFSV3WRITE_DATASYNC)
		    ioflags = (IO_SYNC | IO_NODELOCKED);
		else
		    ioflags = (IO_SYNC | IO_NODELOCKED);
		uiop->uio_rw = UIO_WRITE;
		uiop->uio_segflg = UIO_SYSSPACE;
		uiop->uio_procp = NULL;
		uiop->uio_offset = nfsd->nd_off;
		uiop->uio_resid = nfsd->nd_eoff - nfsd->nd_off;
		if (uiop->uio_resid > 0) {
		    mp = info.nmi_mrep;
		    i = 0;
		    while (mp) {
			if (mp->m_len > 0)
			    i++;
			mp = mp->m_next;
		    }
		    uiop->uio_iovcnt = i;
		    iov = malloc(i * sizeof(struct iovec), M_TEMP, M_WAITOK);
		    uiop->uio_iov = ivp = iov;
		    mp = info.nmi_mrep;
		    while (mp) {
			if (mp->m_len > 0) {
			    ivp->iov_base = mtod(mp, caddr_t);
			    ivp->iov_len = mp->m_len;
			    ivp++;
			}
			mp = mp->m_next;
		    }
		    if (!error) {
			error = VOP_WRITE(vp, uiop, ioflags, cred);
			nfsstats.srvvop_writes++;
		    }
		    free(iov, M_TEMP);
		}
		m_freem(info.nmi_mrep);
		if (vp) {
		    aftat_ret = VOP_GETATTR(vp, &va, cred, procp);
		    vput(vp);
		}

		/*
		 * Loop around generating replies for all write rpcs that have
		 * now been completed.
		 */
		swp = nfsd;
		do {
		    if (error) {
			nfsm_writereply(NFSX_WCCDATA(info.nmi_v3), info.nmi_v3);
			if (info.nmi_v3) {
			    nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret,
			        &va, &info.nmi_mb);
			}
		    } else {
			nfsm_writereply(NFSX_PREOPATTR(info.nmi_v3) +
			    NFSX_POSTOPORFATTR(info.nmi_v3) + 2 * NFSX_UNSIGNED +
			    NFSX_WRITEVERF(info.nmi_v3), info.nmi_v3);
			if (info.nmi_v3) {
			    nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret,
			        &va, &info.nmi_mb);
			    tl = nfsm_build(&info.nmi_mb, 4 * NFSX_UNSIGNED);
			    *tl++ = txdr_unsigned(nfsd->nd_len);
			    *tl++ = txdr_unsigned(swp->nd_stable);
			    /*
			     * Actually, there is no need to txdr these fields,
			     * but it may make the values more human readable,
			     * for debugging purposes.
			     */
			    *tl++ = txdr_unsigned(boottime.tv_sec);
			    *tl = txdr_unsigned(boottime.tv_usec);
			} else {
			    fp = nfsm_build(&info.nmi_mb, NFSX_V2FATTR);
			    nfsm_srvfattr(nfsd, &va, fp);
			}
		    }
		    nfsd->nd_mreq = info.nmi_mreq;
		    if (nfsd->nd_mrep)
			panic("nfsrv_write: nd_mrep not free");

		    /*
		     * Done. Put it at the head of the timer queue so that
		     * the final phase can return the reply.
		     */
		    s = splsoftclock();
		    if (nfsd != swp) {
			timerclear(&nfsd->nd_time);
			LIST_INSERT_HEAD(&slp->ns_tq, nfsd, nd_tq);
		    }
		    nfsd = LIST_FIRST(&swp->nd_coalesce);
		    if (nfsd) {
			LIST_REMOVE(nfsd, nd_tq);
		    }
		    splx(s);
		} while (nfsd);
		s = splsoftclock();
		timerclear(&swp->nd_time);
		LIST_INSERT_HEAD(&slp->ns_tq, swp, nd_tq);
		splx(s);
		goto loop1;
	}
	splx(s);

	/*
	 * Search for a reply to return.
	 */
	s = splsoftclock();
	for (nfsd = LIST_FIRST(&slp->ns_tq); nfsd != NULL; nfsd = nnfsd) {
		nnfsd = LIST_NEXT(nfsd, nd_tq);
		if (nfsd->nd_mreq) {
		    LIST_REMOVE(nfsd, nd_tq);
		    *mrq = nfsd->nd_mreq;
		    *ndp = nfsd;
		    break;
		}
	}
	splx(s);
	return (0);
}

/*
 * Coalesce the write request nfsd into owp. To do this we must:
 * - remove nfsd from the queues
 * - merge nfsd->nd_mrep into owp->nd_mrep
 * - update the nd_eoff and nd_stable for owp
 * - put nfsd on owp's nd_coalesce list
 * NB: Must be called at splsoftclock().
 */
void
nfsrvw_coalesce(struct nfsrv_descript *owp, struct nfsrv_descript *nfsd)
{
        int overlap;
        struct mbuf *mp;

	splsoftassert(IPL_SOFTCLOCK);

        LIST_REMOVE(nfsd, nd_hash);
        LIST_REMOVE(nfsd, nd_tq);
        if (owp->nd_eoff < nfsd->nd_eoff) {
            overlap = owp->nd_eoff - nfsd->nd_off;
            if (overlap < 0)
                panic("nfsrv_coalesce: bad off");
            if (overlap > 0)
                m_adj(nfsd->nd_mrep, overlap);
            mp = owp->nd_mrep;
            while (mp->m_next)
                mp = mp->m_next;
            mp->m_next = nfsd->nd_mrep;
            owp->nd_eoff = nfsd->nd_eoff;
        } else
            m_freem(nfsd->nd_mrep);
        nfsd->nd_mrep = NULL;
        if (nfsd->nd_stable == NFSV3WRITE_FILESYNC)
            owp->nd_stable = NFSV3WRITE_FILESYNC;
        else if (nfsd->nd_stable == NFSV3WRITE_DATASYNC &&
            owp->nd_stable == NFSV3WRITE_UNSTABLE)
            owp->nd_stable = NFSV3WRITE_DATASYNC;
        LIST_INSERT_HEAD(&owp->nd_coalesce, nfsd, nd_tq);

	/*
	 * nfsd might hold coalesce elements! Move them to owp.
	 * Otherwise, requests may be lost and clients will be stuck.
	 */
	if (LIST_FIRST(&nfsd->nd_coalesce) != NULL) {
		struct nfsrv_descript *m;

		while ((m = LIST_FIRST(&nfsd->nd_coalesce)) != NULL) {
			LIST_REMOVE(m, nd_tq);
			LIST_INSERT_HEAD(&owp->nd_coalesce, m, nd_tq);
		}
	}
@


1.80
log
@error = operation();
memory = malloc();
if (error) free(memory);

makes no sense; move error checking to above memory allocation

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.79 2009/08/09 13:34:41 thib Exp $	*/
d444 2
a445 3
	struct iovec iv[(NFS_MAXPATHLEN+MLEN-1)/MLEN];
	struct iovec *ivp = iv;
	struct mbuf *mp;
d449 1
a449 1
	int error = 0, rdonly, i, tlen, len, getret;
a450 1
	struct mbuf *mp2 = NULL, *mp3 = NULL;
d455 1
a455 1
	struct uio io, *uiop = &io;
d472 15
a486 29
	len = 0;
	i = 0;
	while (len < NFS_MAXPATHLEN) {
		MGET(mp, M_WAIT, MT_DATA);
		MCLGET(mp, M_WAIT);
		mp->m_len = NFSMSIZ(mp);
		if (len == 0)
			mp3 = mp2 = mp;
		else {
			mp2->m_next = mp;
			mp2 = mp;
		}
		if ((len+mp->m_len) > NFS_MAXPATHLEN) {
			mp->m_len = NFS_MAXPATHLEN-len;
			len = NFS_MAXPATHLEN;
		} else
			len += mp->m_len;
		ivp->iov_base = mtod(mp, caddr_t);
		ivp->iov_len = mp->m_len;
		i++;
		ivp++;
	}
	uiop->uio_iov = iv;
	uiop->uio_iovcnt = i;
	uiop->uio_offset = 0;
	uiop->uio_resid = len;
	uiop->uio_rw = UIO_READ;
	uiop->uio_segflg = UIO_SYSSPACE;
	uiop->uio_procp = NULL;
d494 1
a494 1
	error = VOP_READLINK(vp, uiop, cred);
d499 1
a499 1
		m_freem(mp3);
d508 2
a509 2
	if (uiop->uio_resid > 0) {
		len -= uiop->uio_resid;
d511 1
a511 1
		nfsm_adj(mp3, NFS_MAXPATHLEN-tlen, tlen-len);
d515 1
a515 1
	info.nmi_mb->m_next = mp3;
d518 1
a518 1
	return(error);
@


1.79
log
@set the mrq pointer (request) in the nfsm_reply() macro, as we can return from it.
This can cause us to follow garbage in the nfsd loop, causing two kinds of hell.

problem noticed by nicm@@. OK blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.75 2009/06/06 23:40:30 blambert Exp $	*/
d467 7
a502 8
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly);
	if (error) {
		m_freem(mp3);
		nfsm_reply(2 * NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, 1, NULL, &info.nmi_mb);
		error = 0;
		goto nfsmout;
	}
@


1.78
log
@group all of the on-stack variables that are uses by the nfsm_macros
to keep the data munging "state" into an nfsm_info structure. Each
function now has this structure on its stack, and it and its members
are now passed around so that the macros/functions can work there magic.

this will make removing the nfsm_* macros way easier.

Idea/code picked up from DragonflyBSD.

Tested by krw@@, jacekm@@ and myself.

OK blambert@@.
@
text
@a160 1
	*mrq = info.nmi_mreq;
a210 1
	*mrq = info.nmi_mreq;
a350 1
	*mrq = info.nmi_mreq;
a428 1
	*mrq = info.nmi_mreq;
a534 1
	*mrq = info.nmi_mreq;
a700 1
	*mrq = info.nmi_mreq;
a707 1
	*mrq = info.nmi_mreq;
a875 1
	*mrq = info.nmi_mreq;
a882 1
	*mrq = info.nmi_mreq;
a1195 1
	*mrq = info.nmi_mreq;
a1487 1
	*mrq = info.nmi_mreq;
a1489 1
	*mrq = info.nmi_mreq;
a1640 1
	*mrq = info.nmi_mreq;
a1642 1
	*mrq = info.nmi_mreq;
a1741 1
	*mrq = info.nmi_mreq;
a1910 1
	*mrq = info.nmi_mreq;
a1913 1
	*mrq = info.nmi_mreq;
a2031 1
	*mrq = info.nmi_mreq;
a2163 1
	*mrq = info.nmi_mreq;
a2165 1
	*mrq = info.nmi_mreq;
a2291 1
	*mrq = info.nmi_mreq;
a2293 1
	*mrq = info.nmi_mreq;
a2399 1
	*mrq = info.nmi_mreq;
a2658 1
	*mrq = info.nmi_mreq;
a2924 1
	*mrq = info.nmi_mreq;
a2988 1
	*mrq = info.nmi_mreq;
a3068 1
	*mrq = info.nmi_mreq;
a3139 1
	*mrq = info.nmi_mreq;
a3211 1
	*mrq = info.nmi_mreq;
a3235 1
	*mrq = info.nmi_mreq;
a3263 1
	*mrq = info.nmi_mreq;
@


1.77
log
@(struct foo *)0 -> NULL, every where I could find it.

OK blambert@@
@
text
@a106 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
d108 1
a108 1
	caddr_t dpos = nfsd->nd_dpos;
a116 1
	struct mbuf *mb, *mreq;
d120 5
d131 3
a133 2
		nfsm_srvpostop_attr(nfsd, 1, NULL, &mb);
		return (0);
d157 2
a158 2
	nfsm_srvpostop_attr(nfsd, getret, &va, &mb);
	tl = nfsm_build(&mb, NFSX_UNSIGNED);
d161 1
a174 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
d176 1
a176 1
	caddr_t dpos = nfsd->nd_dpos;
d187 6
a192 1
	struct mbuf *mb, *mreq;
d199 2
a200 1
		return (0);
d205 5
a209 3
	if (error)
		return (0);
	fp = nfsm_build(&mb, NFSX_FATTR(nfsd->nd_flag & ND_NFSV3));
d212 1
a225 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
d227 1
a227 1
	caddr_t dpos = nfsd->nd_dpos;
d238 1
a238 1
	int v3 = (nfsd->nd_flag & ND_NFSV3), gcheck = 0;
a239 1
	struct mbuf *mb, *mreq;
d242 6
d251 1
a251 1
	if (v3) {
d253 1
a253 1
		error = nfsm_srvsattr(&md, &va, mrep, &dpos);
d299 3
a301 2
		nfsm_srvwcc(nfsd, preat_ret, &preat, postat_ret, &va, &mb);
		return (0);
d303 1
a303 1
	if (v3) {
d311 1
a311 1
			nfsm_reply(NFSX_WCCDATA(v3));
d313 3
a315 2
			    &mb);
			return (0);
d342 6
a347 4
	nfsm_reply(NFSX_WCCORFATTR(v3));
	if (v3) {
		nfsm_srvwcc(nfsd, preat_ret, &preat, postat_ret, &va, &mb);
		return (0);
d349 1
a349 1
		fp = nfsm_build(&mb, NFSX_V2FATTR);
d353 1
a366 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a367 1
	caddr_t dpos = nfsd->nd_dpos;
d372 1
a379 1
	struct mbuf *mb, *mreq;
d382 6
d394 1
a394 1
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos, &dirp, procp);
d396 1
a396 1
		if (v3)
d402 4
a405 3
		nfsm_reply(NFSX_POSTOPATTR(v3));
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &mb);
		return (0);
d416 2
a417 1
	nfsm_reply(NFSX_SRVFH(v3) + NFSX_POSTOPORFATTR(v3) + NFSX_POSTOPATTR(v3));
d419 3
a421 2
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &mb);
		return (0);
d423 1
a423 1
	nfsm_srvfhtom(&mb, fhp, v3);
d425 2
a426 2
		nfsm_srvpostop_attr(nfsd, 0, &va, &mb);
		nfsm_srvpostop_attr(nfsd, dirattr_ret, &dirattr, &mb);
d428 1
a428 1
		fp = nfsm_build(&mb, NFSX_V2FATTR);
d432 1
a445 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a446 1
	caddr_t dpos = nfsd->nd_dpos;
d451 1
a454 1
	int v3 = (nfsd->nd_flag & ND_NFSV3);
d456 1
a456 1
	struct mbuf *mb, *mp2 = NULL, *mp3 = NULL, *mreq;
d463 6
d504 3
a506 2
		nfsm_srvpostop_attr(nfsd, 1, NULL, &mb);
		return (0);
d509 1
a509 1
		if (v3)
d521 7
a527 5
	nfsm_reply(NFSX_POSTOPATTR(v3) + NFSX_UNSIGNED);
	if (v3) {
		nfsm_srvpostop_attr(nfsd, getret, &attr, &mb);
		if (error)
			return (0);
d534 1
a534 1
	tl = nfsm_build(&mb, NFSX_UNSIGNED);
d536 2
a537 1
	mb->m_next = mp3;
d539 1
a552 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a553 1
	caddr_t dpos = nfsd->nd_dpos;
d559 1
d562 1
a562 1
	int i;
a563 1
	int v3 = (nfsd->nd_flag & ND_NFSV3), reqlen;
a564 1
	struct mbuf *mb, *mreq;
d573 6
d581 1
a581 1
	if (v3) {
d601 1
a601 1
		if (v3)
d622 3
a624 3
	nfsm_reply(NFSX_POSTOPORFATTR(v3) + 3 * NFSX_UNSIGNED+nfsm_rndup(cnt));
	if (v3) {
		tl = nfsm_build(&mb, NFSX_V3FATTR + 4 * NFSX_UNSIGNED);
d629 1
a629 1
		tl = nfsm_build(&mb, NFSX_V2FATTR + NFSX_UNSIGNED);
d639 1
a639 1
		m = m2 = mb;
d657 1
a657 1
		m = mb;
d685 1
a685 1
			m_freem(mreq);
d696 2
a697 2
		nfsm_adj(mb, len - tlen, tlen - cnt);
	if (v3) {
d706 1
d713 2
a714 1
	nfsm_srvpostop_attr(nfsd, getret, &va, &mb);
a727 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a728 1
	caddr_t dpos = nfsd->nd_dpos;
d731 1
a741 1
	int v3 = (nfsd->nd_flag & ND_NFSV3);
a742 1
	struct mbuf *mb, *mreq;
d749 7
a755 1
	if (mrep == NULL) {
d761 1
a761 1
	if (v3) {
d781 1
a781 1
	    mp = mrep;
d783 1
a783 1
		if (mp == md) {
d785 1
a785 1
			adjust = dpos - mtod(mp, caddr_t);
d811 1
a811 1
	if (v3)
d814 1
a814 1
		if (v3)
d828 1
a828 1
	    mp = mrep;
d857 9
a865 7
	nfsm_reply(NFSX_PREOPATTR(v3) + NFSX_POSTOPORFATTR(v3) +
		2 * NFSX_UNSIGNED + NFSX_WRITEVERF(v3));
	if (v3) {
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb);
		if (error)
			return (0);
		tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED);
d879 1
a879 1
		fp = nfsm_build(&mb, NFSX_V2FATTR);
d883 1
d890 2
a891 1
	nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb);
d913 1
a920 1
	caddr_t dpos;
d922 1
a922 1
	int ioflags, aftat_ret = 1, s, adjust, v3, zeroing;
a923 1
	struct mbuf *mb, *mreq, *mrep, *md;
d932 4
a935 3
	    mrep = nfsd->nd_mrep;
	    md = nfsd->nd_md;
	    dpos = nfsd->nd_dpos;
d937 1
a937 1
	    v3 = (nfsd->nd_flag & ND_NFSV3);
d948 1
a948 1
	    if (v3) {
d968 1
a968 1
	    mp = mrep;
d970 1
a970 1
		if (mp == md) {
d972 1
a972 1
		    adjust = dpos - mtod(mp, caddr_t);
d989 1
a989 1
		m_freem(mrep);
d992 5
a996 4
		nfsm_writereply(2 * NFSX_UNSIGNED, v3);
		if (v3)
		    nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb);
		nfsd->nd_mreq = mreq;
d1065 1
a1065 1
		mrep = nfsd->nd_mrep;
d1068 1
a1068 1
		v3 = (nfsd->nd_flag & ND_NFSV3);
d1073 1
a1073 1
		    if (v3)
d1076 1
a1076 1
			if (v3)
d1099 1
a1099 1
		    mp = mrep;
d1109 1
a1109 1
		    mp = mrep;
d1124 1
a1124 1
		m_freem(mrep);
d1137 2
a1138 2
			nfsm_writereply(NFSX_WCCDATA(v3), v3);
			if (v3) {
d1140 1
a1140 1
			        &va, &mb);
d1143 4
a1146 4
			nfsm_writereply(NFSX_PREOPATTR(v3) +
			    NFSX_POSTOPORFATTR(v3) + 2 * NFSX_UNSIGNED +
			    NFSX_WRITEVERF(v3), v3);
			if (v3) {
d1148 2
a1149 2
			        &va, &mb);
			    tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED);
d1160 1
a1160 1
			    fp = nfsm_build(&mb, NFSX_V2FATTR);
d1164 1
a1164 1
		    nfsd->nd_mreq = mreq;
d1205 1
a1272 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a1273 1
	caddr_t dpos = nfsd->nd_dpos;
d1278 1
d1285 1
a1285 1
	int v3 = (nfsd->nd_flag & ND_NFSV3), how, exclusive_flag = 0;
a1286 1
	struct mbuf *mb, *mreq;
d1293 6
d1306 2
a1307 1
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos, &dirp, procp);
d1309 1
a1309 1
		if (v3)
d1318 1
a1318 1
		nfsm_reply(NFSX_WCCDATA(v3));
d1320 1
a1320 1
		    &mb);
d1323 2
a1324 1
		return (0);
d1327 1
a1327 1
	if (v3) {
d1337 2
a1338 1
			error = nfsm_srvsattr(&md, &va, mrep, &dpos);
d1404 2
a1405 1
				return (0);
d1414 2
a1415 1
				return (0);
d1424 2
a1425 1
				return (0);
d1435 2
a1436 1
				return (0);
d1477 1
a1477 1
	if (v3) {
d1484 3
a1486 2
	nfsm_reply(NFSX_SRVFH(v3) + NFSX_FATTR(v3) + NFSX_WCCDATA(v3));
	if (v3) {
d1489 1
a1489 1
			nfsm_srvpostop_attr(nfsd, 0, &va, &mb);
d1492 1
a1492 1
		    &mb);
d1494 2
a1495 2
		nfsm_srvfhtom(&mb, fhp, v3);
		fp = nfsm_build(&mb, NFSX_V2FATTR);
d1498 1
d1501 1
a1527 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a1528 1
	caddr_t dpos = nfsd->nd_dpos;
d1531 1
a1538 1
	struct mbuf *mb, *mreq;
d1543 6
d1556 1
a1556 1
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos, &dirp, procp);
d1562 1
a1562 1
		    &mb);
d1565 2
a1566 1
		return (0);
d1579 1
a1579 1
	error = nfsm_srvsattr(&md, &va, mrep, &dpos);
d1650 1
a1650 1
		nfsm_srvpostop_attr(nfsd, 0, &va, &mb);
d1652 2
a1653 1
	nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft, &mb);
d1656 1
a1682 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a1683 1
	caddr_t dpos = nfsd->nd_dpos;
d1686 1
a1689 1
	int v3 = (nfsd->nd_flag & ND_NFSV3);
a1690 1
	struct mbuf *mb, *mreq;
d1696 6
d1710 1
a1710 1
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos, &dirp, procp);
d1712 1
a1712 1
		if (v3)
d1744 1
a1744 1
	if (dirp && v3) {
d1748 2
a1749 2
	nfsm_reply(NFSX_WCCDATA(v3));
	if (v3) {
d1751 3
a1753 2
		    &mb);
		return (0);
d1756 1
a1769 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a1770 1
	caddr_t dpos = nfsd->nd_dpos;
d1772 1
a1776 1
	int v3 = (nfsd->nd_flag & ND_NFSV3);
a1777 1
	struct mbuf *mb, *mreq;
d1786 6
d1798 1
d1807 2
a1808 1
	error = nfs_namei(&fromnd, ffhp, len, slp, nam, &md, &dpos, &fdirp, procp);
d1810 1
a1810 1
		if (v3)
d1819 1
a1819 1
		nfsm_reply(2 * NFSX_WCCDATA(v3));
d1821 1
a1821 1
		    &mb);
d1823 1
a1823 1
		    &mb);
d1826 2
a1827 1
		return (0);
d1836 2
a1837 1
	error = nfs_namei(&tond, tfhp, len2, slp, nam, &md, &dpos, &tdirp, procp);
d1839 1
a1839 1
		if (v3)
d1857 1
a1857 1
			error = v3 ? EEXIST : EISDIR;
d1860 1
a1860 1
			error = v3 ? EEXIST : ENOTDIR;
d1864 1
a1864 1
			error = v3 ? EXDEV : ENOTEMPTY;
d1869 1
a1869 1
		error = v3 ? EXDEV : ENOTEMPTY;
d1873 1
a1873 1
		error = v3 ? EXDEV : ENOTEMPTY;
d1877 1
a1877 1
		error = v3 ? EINVAL : ENOTEMPTY;
d1919 2
a1920 2
	nfsm_reply(2 * NFSX_WCCDATA(v3));
	if (v3) {
d1922 1
a1922 1
		    &mb);
d1924 1
a1924 1
		    &mb);
d1926 1
d1930 1
a1958 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
d1960 1
a1960 1
	caddr_t dpos = nfsd->nd_dpos;
d1966 1
a1966 1
	int getret = 1, v3 = (nfsd->nd_flag & ND_NFSV3);
a1967 1
	struct mbuf *mb, *mreq;
d1973 6
d1984 1
d1987 3
a1989 2
		nfsm_reply(NFSX_POSTOPATTR(v3) + NFSX_WCCDATA(v3));
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
d1991 3
a1993 2
		    &mb);
		return (0);
d2000 2
a2001 1
	error = nfs_namei(&nd, dfhp, len, slp, nam, &md, &dpos, &dirp, procp);
d2003 1
a2003 1
		if (v3)
d2034 1
a2034 1
	if (v3)
d2041 3
a2043 3
	nfsm_reply(NFSX_POSTOPATTR(v3) + NFSX_WCCDATA(v3));
	if (v3) {
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
d2045 2
a2046 2
		     &mb);
		return (0);
d2049 1
a2062 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a2063 1
	caddr_t dpos = nfsd->nd_dpos;
d2067 1
a2074 2
	int v3 = (nfsd->nd_flag & ND_NFSV3);
	struct mbuf *mb, *mreq;
d2079 6
d2089 1
d2093 2
a2094 1
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos, &dirp, procp);
d2096 1
a2096 1
		if (v3)
d2107 3
a2109 2
	if (v3)
		error = nfsm_srvsattr(&md, &va, mrep, &dpos);
d2124 1
a2124 1
	if (!v3) {
d2145 1
a2145 1
	    if (v3) {
d2172 3
a2174 2
	nfsm_reply(NFSX_SRVFH(v3) + NFSX_POSTOPATTR(v3) + NFSX_WCCDATA(v3));
	if (v3) {
d2177 1
a2177 1
			nfsm_srvpostop_attr(nfsd, 0, &va, &mb);
d2180 1
a2180 1
		    &mb);
d2182 1
d2185 1
a2213 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a2214 1
	caddr_t dpos = nfsd->nd_dpos;
d2219 1
a2222 1
	int v3 = (nfsd->nd_flag & ND_NFSV3);
a2223 1
	struct mbuf *mb, *mreq;
d2228 6
d2237 1
d2241 2
a2242 1
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos, &dirp, procp);
d2244 1
a2244 1
		if (v3)
d2253 1
a2253 1
		nfsm_reply(NFSX_WCCDATA(v3));
d2255 1
a2255 1
		    &mb);
d2258 2
a2259 1
		return (0);
d2262 3
a2264 2
	if (v3) {
		error = nfsm_srvsattr(&md, &va, mrep, &dpos);
d2298 3
a2300 2
	nfsm_reply(NFSX_SRVFH(v3) + NFSX_POSTOPATTR(v3) + NFSX_WCCDATA(v3));
	if (v3) {
d2303 1
a2303 1
			nfsm_srvpostop_attr(nfsd, 0, &va, &mb);
d2306 1
a2306 1
		    &mb);
d2308 2
a2309 2
		nfsm_srvfhtom(&mb, fhp, v3);
		fp = nfsm_build(&mb, NFSX_V2FATTR);
d2312 1
d2315 1
a2337 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a2338 1
	caddr_t dpos = nfsd->nd_dpos;
d2340 1
a2343 1
	int v3 = (nfsd->nd_flag & ND_NFSV3);
a2344 1
	struct mbuf *mb, *mreq;
d2351 6
d2363 2
a2364 1
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos, &dirp, procp);
d2366 1
a2366 1
		if (v3)
d2375 1
a2375 1
		nfsm_reply(NFSX_WCCDATA(v3));
d2377 1
a2377 1
		    &mb);
d2380 2
a2381 1
		return (0);
d2415 2
a2416 2
	nfsm_reply(NFSX_WCCDATA(v3));
	if (v3) {
d2418 2
a2419 2
		    &mb);
		return (0);
d2422 1
a2468 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a2469 1
	caddr_t dpos = nfsd->nd_dpos;
d2472 1
a2474 1
	struct mbuf *mb, *mreq;
a2483 1
	int v3 = (nfsd->nd_flag & ND_NFSV3);
d2487 6
d2495 1
a2495 1
	if (v3) {
d2509 3
a2511 2
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d2519 4
a2522 3
		nfsm_reply(NFSX_POSTOPATTR(v3));
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d2559 1
a2559 1
	if (v3) {
d2571 4
a2574 3
		nfsm_reply(NFSX_POSTOPATTR(v3));
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d2585 1
a2585 1
			nfsm_reply(NFSX_POSTOPATTR(v3) + NFSX_COOKIEVERF(v3) +
d2587 3
a2589 3
			if (v3) {
				nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
				tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED);
d2593 1
a2593 1
				tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
d2598 2
a2599 1
			return (0);
d2625 4
a2628 4
	nfsm_reply(NFSX_POSTOPATTR(v3) + NFSX_COOKIEVERF(v3) + siz);
	if (v3) {
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
d2638 1
a2638 1
			if (v3)
d2648 1
a2648 1
			tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
d2650 1
a2650 1
			if (v3) {
d2652 1
a2652 1
				tl = nfsm_build(&mb, NFSX_UNSIGNED);
d2657 1
a2657 1
			nfsm_strtombuf(&mb, dp->d_name, nlen);
d2660 2
a2661 2
			if (v3) {
				tl = nfsm_build(&mb, NFSX_UNSIGNED);
d2664 1
a2664 1
			tl = nfsm_build(&mb, NFSX_UNSIGNED);
d2673 1
a2673 1
	tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
d2682 1
a2692 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a2693 1
	caddr_t dpos = nfsd->nd_dpos;
d2696 1
a2698 1
	struct mbuf *mb, *mreq;
d2713 6
d2730 3
a2732 2
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d2741 3
a2743 2
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d2793 3
a2795 2
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d2808 2
a2809 2
			nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
			tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED);
d2816 2
a2817 1
			return (0);
d2856 2
a2857 2
	nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
	tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
d2910 1
a2910 1
			tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED);
d2916 1
a2916 1
			nfsm_strtombuf(&mb, dp->d_name, nlen);
d2931 1
a2931 1
			nfsm_buftombuf(&mb, &fl, sizeof(struct flrep));
d2940 1
a2940 1
	tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
d2949 1
a2962 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a2963 1
	caddr_t dpos = nfsd->nd_dpos;
d2967 1
a2973 1
	struct mbuf *mb, *mreq;
d2975 6
d2996 4
a2999 2
		nfsm_srvwcc(nfsd, for_ret, &bfor, aft_ret, &aft, &mb);
		return (0);
d3006 1
a3006 1
	nfsm_srvwcc(nfsd, for_ret, &bfor, aft_ret, &aft, &mb);
d3008 1
a3008 1
		tl = nfsm_build(&mb, NFSX_V3WRITEVERF);
d3012 1
a3012 1
		return (0);
d3014 1
a3027 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a3028 1
	caddr_t dpos = nfsd->nd_dpos;
d3032 1
a3035 1
	int v3 = (nfsd->nd_flag & ND_NFSV3);
a3036 1
	struct mbuf *mb, *mreq;
d3044 6
d3055 3
a3057 2
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d3063 9
a3071 7
	nfsm_reply(NFSX_POSTOPATTR(v3) + NFSX_STATFS(v3));
	if (v3)
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
	if (error)
		return (0);
	sfp = nfsm_build(&mb, NFSX_STATFS(v3));
	if (v3) {
d3095 1
a3108 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a3109 1
	caddr_t dpos = nfsd->nd_dpos;
d3111 1
a3116 1
	struct mbuf *mb, *mreq;
d3122 6
d3133 3
a3135 2
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d3140 2
a3141 2
	nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
	sip = nfsm_build(&mb, NFSX_V3FSINFO);
d3167 1
a3180 1
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
a3181 1
	caddr_t dpos = nfsd->nd_dpos;
d3183 1
a3189 1
	struct mbuf *mb, *mreq;
d3195 6
d3206 3
a3208 2
		nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
		return (0);
d3220 6
a3225 4
	nfsm_srvpostop_attr(nfsd, getret, &at, &mb);
	if (error)
		return (0);
	pc = nfsm_build(&mb, NFSX_V3PATHCONF);
d3240 1
d3255 1
a3255 1
	struct mbuf *mrep = nfsd->nd_mrep;
d3257 6
a3262 1
	struct mbuf *mb, *mreq;
d3265 1
d3279 2
a3280 2
{
	struct mbuf *mrep = nfsd->nd_mrep;
d3282 6
a3287 1
	struct mbuf *mb, *mreq;
d3294 1
@


1.76
log
@Initialize a variable that was previously using a mystery value in
some error cases

ok thib@@
@
text
@d465 1
a465 1
	uiop->uio_procp = (struct proc *)0;
d800 1
a800 1
	    uiop->uio_procp = (struct proc *)0;
d1043 1
a1043 1
		uiop->uio_procp = (struct proc *)0;
d1256 1
a1256 1
			dirp = (struct vnode *)0;
d1474 1
a1474 1
	struct vnode *vp, *dirp = (struct vnode *)0;
d1731 1
a1731 1
			fdirp = (struct vnode *)0;
d1758 1
a1758 1
			tdirp = (struct vnode *)0;
d1882 1
a1882 1
	struct vnode *vp, *xp, *dirp = (struct vnode *)0;
d1912 1
a1912 1
			dirp = (struct vnode *)0;
d1981 1
a1981 1
	struct vnode *dirp = (struct vnode *)0;
d1999 1
a1999 1
			dirp = (struct vnode *)0;
d2019 1
a2019 1
	io.uio_procp = (struct proc *)0;
d2121 1
a2121 1
	struct vnode *vp, *dirp = (struct vnode *)0;
d2138 1
a2138 1
			dirp = (struct vnode *)0;
d2232 1
a2232 1
	struct vnode *vp, *dirp = (struct vnode *)0;
d2251 1
a2251 1
			dirp = (struct vnode *)0;
d2418 1
a2418 1
	io.uio_procp = (struct proc *)0;
d2631 1
a2631 1
	io.uio_procp = (struct proc *)0;
@


1.75
log
@Don't allocate an mbuf cluster without checking to see if it will
actually get us anything.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.74 2009/06/06 22:59:17 blambert Exp $	*/
d525 1
a525 1
	int error = 0, rdonly, cnt, len, left, siz, tlen, getret;
@


1.74
log
@Consolidate error handling in read case.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.73 2009/06/06 02:23:33 blambert Exp $	*/
d606 2
a607 1
				MCLGET(m, M_WAIT);
@


1.73
log
@Consolidate error handling code. Much less atrocious than before.

"get it in" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.72 2009/06/05 21:35:33 thib Exp $	*/
d555 3
a557 5
	if (error) {
		nfsm_reply(2 * NFSX_UNSIGNED);
		nfsm_srvpostop_attr(nfsd, 1, NULL, &mb);
		return (0);
	}
d571 3
a573 6
	if (error) {
		vput(vp);
		nfsm_reply(NFSX_POSTOPATTR(v3));
		nfsm_srvpostop_attr(nfsd, getret, &va, &mb);
		return (0);
	}
d643 1
a643 4
			vput(vp);
			nfsm_reply(NFSX_POSTOPATTR(v3));
			nfsm_srvpostop_attr(nfsd, getret, &va, &mb);
			return (0);
d664 7
@


1.72
log
@bring back rev1.70
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.71 2009/06/05 20:10:51 naddy Exp $	*/
d759 1
a759 3
		nfsm_reply(2 * NFSX_UNSIGNED);
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb);
		return (0);
d762 2
a763 5
	if (error) {
		nfsm_reply(2 * NFSX_UNSIGNED);
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb);
		return (0);
	}
d771 1
d773 3
a775 9
	if (!error) {
		error = nfsrv_access(vp, VWRITE, cred, rdonly, procp, 1);
	}
	if (error) {
		vput(vp);
		nfsm_reply(NFSX_WCCDATA(v3));
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb);
		return (0);
	}
d835 7
@


1.71
log
@revert to 1.67 to unbreak NFS writes; ok beck@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.67 2009/05/21 12:24:22 thib Exp $	*/
d3124 4
a3127 3
 * refer to files already opened by a Unix client. You cannot just use
 * vn_writechk() and VOP_ACCESS() for two reasons.
 * 1 - You must check for exported rdonly as well as MNT_RDONLY for the write case
d3132 3
a3134 1
 *     what the heck.
d3178 1
a3178 1
	if (override && (error == EPERM || error == EACCES) &&
@


1.70
log
@EPERM from VOP_ACCESS() is always an error, so don't hide it.

Diff from FreeBSD.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.69 2009/06/04 18:55:49 blambert Exp $	*/
d727 30
a786 5
	/*
	 * For NFS Version 2, it is not obvious what a write of zero length
	 * should do, but I might as well be consistent with Version 3,
	 * which is to return ok so long as there are no permission problems.
	 */
a787 23
	    zeroing = 1;
	    mp = mrep;
	    while (mp) {
		if (mp == md) {
			zeroing = 0;
			adjust = dpos - mtod(mp, caddr_t);
			mp->m_len -= adjust;
			if (mp->m_len > 0 && adjust > 0)
				mp->m_data += adjust;
		}
		if (zeroing)
			mp->m_len = 0;
		else if (mp->m_len > 0) {
			i += mp->m_len;
			if (i > len) {
				mp->m_len -= (i - len);
				zeroing	= 1;
			}
			if (mp->m_len > 0)
				cnt++;
		}
		mp = mp->m_next;
	    }
a2172 1

d2174 9
a2182 11
	if (error)
		goto out;

	vp = nd.ni_vp;
	bzero((caddr_t)fhp, sizeof(nfh));
	fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
	error = VFS_VPTOFH(vp, &fhp->fh_fid);
	if (!error)
		error = VOP_GETATTR(vp, &va, cred, procp);
	vput(vp);

d3124 3
a3126 4
 * refer to files already opened by a Unix client.
 * You cannot just use vn_writechk() and VOP_ACCESS() for two reasons:
 * 1 - You must check for exported rdonly as well as MNT_RDONLY for the
 *     write case
d3131 1
a3131 3
 *     what the heck. A notable exception to this rule is when VOP_ACCESS()
 *     returns EPERM (e.g. when a file is immutable) which is always an
 *     error.
d3175 1
a3175 1
	if (override && error == EACCES &&
@


1.69
log
@the following:

error = foo();
if (!error)
	bar();

is an alien construct; replace with one from this planet

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.68 2009/06/04 18:44:27 blambert Exp $	*/
d3125 4
a3128 3
 * refer to files already opened by a Unix client. You cannot just use
 * vn_writechk() and VOP_ACCESS() for two reasons.
 * 1 - You must check for exported rdonly as well as MNT_RDONLY for the write case
d3133 3
a3135 1
 *     what the heck.
d3179 1
a3179 1
	if (override && (error == EPERM || error == EACCES) &&
@


1.68
log
@Move code that logically belongs together to be together.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.67 2009/05/21 12:24:22 thib Exp $	*/
d2171 1
d2173 11
a2183 9
	if (!error) {
		vp = nd.ni_vp;
		bzero((caddr_t)fhp, sizeof(nfh));
		fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
		error = VFS_VPTOFH(vp, &fhp->fh_fid);
		if (!error)
			error = VOP_GETATTR(vp, &va, cred, procp);
		vput(vp);
	}
@


1.67
log
@IO_METASYNC has been a noop since around 4.4BSD-Lite, the
idea never really caught on anywhere so retire it.

"gank this shizzle", blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.65 2009/03/30 19:58:50 blambert Exp $	*/
a726 30
	/*
	 * For NFS Version 2, it is not obvious what a write of zero length
	 * should do, but I might as well be consistent with Version 3,
	 * which is to return ok so long as there are no permission problems.
	 */
	if (len > 0) {
	    zeroing = 1;
	    mp = mrep;
	    while (mp) {
		if (mp == md) {
			zeroing = 0;
			adjust = dpos - mtod(mp, caddr_t);
			mp->m_len -= adjust;
			if (mp->m_len > 0 && adjust > 0)
				mp->m_data += adjust;
		}
		if (zeroing)
			mp->m_len = 0;
		else if (mp->m_len > 0) {
			i += mp->m_len;
			if (i > len) {
				mp->m_len -= (i - len);
				zeroing	= 1;
			}
			if (mp->m_len > 0)
				cnt++;
		}
		mp = mp->m_next;
	    }
	}
d757 5
d763 23
@


1.66
log
@Convert macros to functions to reduce kernel memory usage.

In snaps for a while (way too long, according to deraadt@@)
@
text
@a800 7
	    /*
	     * XXX
	     * The IO_METASYNC flag indicates that all metadata (and not just
	     * enough to ensure data integrity) mus be written to stable storage
	     * synchronously.
	     * (IO_METASYNC is not yet implemented in 4.4BSD-Lite.)
	     */
d806 1
a806 1
		ioflags = (IO_METASYNC | IO_SYNC | IO_NODELOCKED);
d1043 1
a1043 1
		    ioflags = (IO_METASYNC | IO_SYNC | IO_NODELOCKED);
@


1.65
log
@Convert a sizeable macro to a much-leaner function. Saves (IIRC) 5k on i386.

In snaps for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.64 2009/03/15 19:40:41 miod Exp $	*/
d394 1
a394 1
	nfsm_srvfhtom(fhp, v3);
d1439 1
a1439 1
		nfsm_srvfhtom(fhp, v3);
d2204 1
a2204 1
		nfsm_srvfhtom(fhp, v3);
@


1.64
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.63 2009/01/27 23:40:14 blambert Exp $	*/
d236 3
a238 1
		nfsm_srvsattr(&va);
d1288 3
a1290 1
			nfsm_srvsattr(&va);
d1517 3
a1519 1
	nfsm_srvsattr(&va);
d2016 3
a2018 1
		nfsm_srvsattr(&va);
d2161 3
a2163 1
		nfsm_srvsattr(&va);
@


1.63
log
@Correct my timeradd() thinko in nfsrv_writegather()

pointed out by bluhm@@, "obvious" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.62 2009/01/24 23:35:47 thib Exp $	*/
d1178 1
a1178 1
	splassert(IPL_SOFTCLOCK);
@


1.62
log
@Use a timespec for the server write deadline and procrastination
timeouts. Rrids us of the ugly cur_sec variable, and some shadows.
Also helps with granularity.

Diff from blambert@@ who asked me to commit this since he's away for
some days and we wanted to put this in with the timespec changes in
the nfsnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.61 2009/01/18 13:54:27 thib Exp $	*/
d899 1
a899 1
	    timeradd(&nfsd->nd_time, &nfsrvw_procrastinate_tv, &nfsd->nd_time);
@


1.61
log
@Perform the same access enforcements for set attributes
as for open/read/write etc, that is assume that the file
as already been opened proper, this fixes an ancient
ftruncate bug, that is if ftruncate was called on a file
with no write modes, we'd return EACCES, this breaks posixy
behavior. however, for e.g. truncate() we'll return EACCESS
as we should.

Diff from PR5880 by mickey.
I had forgotten about this PR, and the fix but niklas@@ ran
into similar issues which prompted another review of this.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.60 2008/12/24 16:53:20 thib Exp $	*/
d92 4
a883 1
	u_quad_t cur_usec;
d899 1
a899 2
	    cur_usec = (u_quad_t)tv.tv_sec * 1000000 + (u_quad_t)tv.tv_usec;
	    nfsd->nd_time = cur_usec + nfsrvw_procrastinate;
d954 1
a954 1
		nfsd->nd_time = 0;
d963 1
a963 1
	    while (wp && wp->nd_time < nfsd->nd_time) {
a1010 1
	cur_usec = (u_quad_t)tv.tv_sec * 1000000 + (u_quad_t)tv.tv_usec;
d1014 1
a1014 1
		if (nfsd->nd_time > cur_usec)
d1130 1
a1130 1
			nfsd->nd_time = 0;
d1140 1
a1140 1
		swp->nd_time = 0;
@


1.60
log
@Low hanging macro fruit. Inline the nfsm_srvstrsiz macro since
its used only once and nuke its definition.

Stolen from blambert's bag'o'diffs.

OK blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.59 2008/12/24 02:43:52 thib Exp $	*/
d308 1
a308 1
			procp, 0)) != 0)
@


1.59
log
@Replace the TRUE/FALSE defines with 1/0 respectively. This doesn't
hurt readability and it was just plain annoying seeing them defined
in every other .c file.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.58 2008/07/06 16:54:48 thib Exp $	*/
d540 8
a547 1
	nfsm_srvstrsiz(reqlen, NFS_SRVMAXDATA(nfsd));
@


1.58
log
@
remove #ifndef nolint goo

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.57 2008/06/15 04:03:40 thib Exp $	*/
d1888 1
a1888 1
	error = nfsrv_fhtovp(fhp, FALSE, &vp, cred, slp, nam, &rdonly);
@


1.57
log
@unroll the NFSMADV() macro and nuke it

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.56 2008/06/14 22:44:07 blambert Exp $	*/
d1621 2
a1622 3
#ifndef nolint
	vp = (struct vnode *)0;
#endif
@


1.56
log
@Replace nfsm_build/bcopy with nfsm_{buf,str}tombuf functions in
filehandle -> mbuf write macros.

Removes `magic' variable cp which was used only in these macros,
and should lead to marginally better mbuf packing as well.

`slap it in' thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.55 2008/06/14 00:26:13 thib Exp $	*/
d728 1
a728 1
				NFSMADV(mp, adjust);
d923 1
a923 1
			NFSMADV(mp, adjust);
@


1.55
log
@use nfsm_padlen() where appropriate;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.54 2008/06/13 03:49:26 blambert Exp $	*/
a347 1
	caddr_t cp;
a2109 1
	caddr_t cp;
@


1.54
log
@Replace one-line macro which only obfuscated the fact that
the function it was named after took 4 arguments instead of 2.

"get it in; get it in; get it in" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.53 2008/06/12 20:24:06 blambert Exp $	*/
d2502 1
a2502 1
			pad = nfsm_rndup(nlen) - nlen;
d2721 1
a2721 1
			pad = nfsm_rndup(nlen) - nlen;
@


1.53
log
@Remove now-vestigial bpos pointer from NFS. For building outgoing
NFS mbufs, mbufs now contain all their internal buffer state internally,
the way god intended.

ok thib@@

testing johan@@ (and possibly merdely@@; this diff's been around for a bit...)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.52 2008/06/11 04:52:27 blambert Exp $	*/
d124 1
a124 1
		nfsm_srvpostop_attr(1, (struct vattr *)0);
d149 1
a149 1
	nfsm_srvpostop_attr(getret, &va);
d372 1
a372 1
		nfsm_srvpostop_attr(dirattr_ret, &dirattr);
d386 1
a386 1
		nfsm_srvpostop_attr(dirattr_ret, &dirattr);
d391 2
a392 2
		nfsm_srvpostop_attr(0, &va);
		nfsm_srvpostop_attr(dirattr_ret, &dirattr);
d465 1
a465 1
		nfsm_srvpostop_attr(1, (struct vattr *)0);
d483 1
a483 1
		nfsm_srvpostop_attr(getret, &attr);
d545 1
a545 1
		nfsm_srvpostop_attr(1, (struct vattr *)0);
d564 1
a564 1
		nfsm_srvpostop_attr(getret, &va);
d638 1
a638 1
			nfsm_srvpostop_attr(getret, &va);
d1423 1
a1423 1
			nfsm_srvpostop_attr(0, &va);
d1575 1
a1575 1
		nfsm_srvpostop_attr(0, &va);
d1893 1
a1893 1
		nfsm_srvpostop_attr(getret, &at);
d1945 1
a1945 1
		nfsm_srvpostop_attr(getret, &at);
d2069 1
a2069 1
			nfsm_srvpostop_attr(0, &va);
d2184 1
a2184 1
			nfsm_srvpostop_attr(0, &va);
d2379 1
a2379 1
		nfsm_srvpostop_attr(getret, &at);
d2389 1
a2389 1
		nfsm_srvpostop_attr(getret, &at);
d2440 1
a2440 1
		nfsm_srvpostop_attr(getret, &at);
d2455 1
a2455 1
				nfsm_srvpostop_attr(getret, &at);
d2493 1
a2493 1
		nfsm_srvpostop_attr(getret, &at);
d2591 1
a2591 1
		nfsm_srvpostop_attr(getret, &at);
d2601 1
a2601 1
		nfsm_srvpostop_attr(getret, &at);
d2652 1
a2652 1
		nfsm_srvpostop_attr(getret, &at);
d2666 1
a2666 1
			nfsm_srvpostop_attr(getret, &at);
d2713 1
a2713 1
	nfsm_srvpostop_attr(getret, &at);
d2901 1
a2901 1
		nfsm_srvpostop_attr(getret, &at);
d2910 1
a2910 1
		nfsm_srvpostop_attr(getret, &at);
d2971 1
a2971 1
		nfsm_srvpostop_attr(getret, &at);
d2977 1
a2977 1
	nfsm_srvpostop_attr(getret, &at);
d3038 1
a3038 1
		nfsm_srvpostop_attr(getret, &at);
d3051 1
a3051 1
	nfsm_srvpostop_attr(getret, &at);
@


1.52
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.51 2008/05/27 19:06:28 blambert Exp $	*/
a111 1
	caddr_t bpos;
d150 1
a150 1
	tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
a176 1
	caddr_t bpos;
d193 1
a193 1
	fp = nfsm_build(&mb, NFSX_FATTR(nfsd->nd_flag & ND_NFSV3), &bpos);
a220 1
	caddr_t bpos;
d276 1
a276 2
		nfsm_srvwcc(nfsd, preat_ret, &preat, postat_ret, &va, &mb,
		    &bpos);
d289 1
a289 1
			    &mb, &bpos);
d319 1
a319 2
		nfsm_srvwcc(nfsd, preat_ret, &preat, postat_ret, &va, &mb,
		    &bpos);
d322 1
a322 1
		fp = nfsm_build(&mb, NFSX_V2FATTR, &bpos);
a350 1
	caddr_t bpos;
d394 1
a394 1
		fp = nfsm_build(&mb, NFSX_V2FATTR, &bpos);
a419 1
	caddr_t bpos;
d492 1
a492 1
	tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
a519 1
	caddr_t bpos;
d575 1
a575 1
		tl = nfsm_build(&mb, NFSX_V3FATTR + 4 * NFSX_UNSIGNED, &bpos);
d580 1
a580 1
		tl = nfsm_build(&mb, NFSX_V2FATTR + NFSX_UNSIGNED, &bpos);
a683 1
	caddr_t bpos;
d748 1
a748 2
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb,
		    &bpos);
d754 1
a754 2
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va,  &mb,
		    &bpos);
d771 1
a771 2
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb,
		    &bpos);
d818 1
a818 2
		nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb,
		    &bpos);
d821 1
a821 1
		tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED, &bpos);
d835 1
a835 1
		fp = nfsm_build(&mb, NFSX_V2FATTR, &bpos);
d867 1
a867 1
	caddr_t bpos, dpos;
d943 1
a943 2
		    nfsm_srvwcc(nfsd, forat_ret, &forat, aftat_ret, &va, &mb,
		        &bpos);
d1089 1
a1089 1
			        &va, &mb, &bpos);
d1097 2
a1098 2
			        &va, &mb, &bpos);
			    tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED, &bpos);
d1109 1
a1109 1
			    fp = nfsm_build(&mb, NFSX_V2FATTR, &bpos);
a1231 1
	caddr_t bpos;
d1263 1
a1263 1
		    &mb, &bpos);
d1426 1
a1426 1
		    &mb, &bpos);
d1429 1
a1429 1
		fp = nfsm_build(&mb, NFSX_V2FATTR, &bpos);
a1467 1
	caddr_t bpos;
d1490 1
a1490 1
		    &mb, &bpos);
d1577 1
a1577 2
	nfsm_srvwcc(nfsd, dirfor_ret, &dirfor, diraft_ret, &diraft, &mb,
	    &bpos);
a1612 1
	caddr_t bpos;
d1672 1
a1672 1
		    &mb, &bpos);
a1694 1
	caddr_t bpos;
d1735 1
a1735 1
		    &mb, &bpos);
d1737 1
a1737 1
		    &mb, &bpos);
d1834 1
a1834 1
		    &mb, &bpos);
d1836 1
a1836 1
		    &mb, &bpos);
a1875 1
	caddr_t bpos;
d1895 1
a1895 1
		    &mb, &bpos);
d1947 1
a1947 1
		     &mb, &bpos);
d1973 1
a1973 1
	char *bpos, *pathcp = NULL, *cp2;
d2072 1
a2072 1
		    &mb, &bpos);
a2113 1
	caddr_t bpos;
d2141 1
a2141 1
		    &mb, &bpos);
d2187 1
a2187 1
		    &mb, &bpos);
d2190 1
a2190 1
		fp = nfsm_build(&mb, NFSX_V2FATTR, &bpos);
a2222 1
	caddr_t bpos;
d2252 1
a2252 1
		    &mb, &bpos);
d2292 1
a2292 1
		    &mb, &bpos);
a2348 1
	caddr_t bpos;
d2456 1
a2456 1
				tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED, &bpos);
d2460 1
a2460 1
				tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d2494 1
a2494 1
		tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d2514 1
a2514 1
			tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d2518 1
a2518 1
				tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d2523 1
a2523 1
			nfsm_strtombuf(&mb, dp->d_name, nlen, &bpos);
d2527 1
a2527 1
				tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d2530 1
a2530 1
			tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d2539 1
a2539 1
	tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
a2564 1
	caddr_t bpos;
d2667 1
a2667 1
			tl = nfsm_build(&mb, 4 * NFSX_UNSIGNED, &bpos);
d2714 1
a2714 1
	tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d2767 1
a2767 1
			tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED, &bpos);
d2773 1
a2773 1
			nfsm_strtombuf(&mb, dp->d_name, nlen, &bpos);
d2788 1
a2788 1
			nfsm_buftombuf(&mb, &fl, sizeof(struct flrep), &bpos);
d2797 1
a2797 1
	tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
a2828 1
	caddr_t bpos;
d2848 1
a2848 1
		nfsm_srvwcc(nfsd, for_ret, &bfor, aft_ret, &aft, &mb, &bpos);
d2856 1
a2856 1
	nfsm_srvwcc(nfsd, for_ret, &bfor, aft_ret, &aft, &mb, &bpos);
d2858 1
a2858 1
		tl = nfsm_build(&mb, NFSX_V3WRITEVERF, &bpos);
a2884 1
	caddr_t bpos;
d2913 1
a2913 1
	sfp = nfsm_build(&mb, NFSX_STATFS(v3), &bpos);
a2957 1
	caddr_t bpos;
d2978 1
a2978 1
	sip = nfsm_build(&mb, NFSX_V3FSINFO, &bpos);
a3023 1
	caddr_t bpos;
d3054 1
a3054 1
	pc = nfsm_build(&mb, NFSX_V3PATHCONF, &bpos);
a3083 1
	caddr_t bpos;
a3102 1
	caddr_t bpos;
@


1.51
log
@Remove bloated and nasty nfsm_clget macro; while here, replace some
handrolled loops with nfsm_strtombuf and nfsm_buftombuf.

ok deraadt@@ via thib@@; ok 'nfs buddy' thib@@
testing johan@@, merdely@@; thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.50 2008/04/22 18:53:34 thib Exp $	*/
d72 1
@


1.50
log
@remove the "kerbflag" argument from nfsrv_fhtovp() and nfs_namei()
(the latter only had it to pass it to nfsrv_fhtovp()).

appropriate cleanup also;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.49 2008/03/16 19:42:57 otto Exp $	*/
a2326 2
 *	The nfsm_clget macro is used here so that the reply will be packed
 *	tightly in mbuf clusters.
a2366 2
	char *bp, *be;
	struct mbuf *mp;
a2367 1
	caddr_t cp;
d2371 1
a2371 1
	struct mbuf *mb, *mreq, *mp2;
d2379 1
a2379 1
	int len, nlen, rem, xfer, tsiz, i, error = 0, getret = 1;
a2518 3
	mp = mp2 = mb;
	bp = bpos;
	be = bp + M_TRAILINGSPACE(mp);
d2524 2
a2525 2
			rem = nfsm_rndup(nlen)-nlen;
			len += (4 * NFSX_UNSIGNED + nlen + rem);
d2536 2
a2537 3
			nfsm_clget;
			*tl = nfs_true;
			bp += NFSX_UNSIGNED;
a2538 1
				nfsm_clget;
d2540 1
a2540 1
				bp += NFSX_UNSIGNED;
a2541 1
			nfsm_clget;
a2542 4
			bp += NFSX_UNSIGNED;
			nfsm_clget;
			*tl = txdr_unsigned(nlen);
			bp += NFSX_UNSIGNED;
d2544 2
a2545 19
			/* And loop around copying the name */
			xfer = nlen;
			cp = dp->d_name;
			while (xfer > 0) {
				nfsm_clget;
				if ((bp+xfer) > be)
					tsiz = be-bp;
				else
					tsiz = xfer;
				bcopy(cp, bp, tsiz);
				bp += tsiz;
				xfer -= tsiz;
				if (xfer > 0)
					cp += tsiz;
			}
			/* And null pad to an int32_t boundary */
			for (i = 0; i < rem; i++)
				*bp++ = '\0';
			nfsm_clget;
d2549 1
a2550 2
				bp += NFSX_UNSIGNED;
				nfsm_clget;
d2552 1
a2553 1
			bp += NFSX_UNSIGNED;
d2561 2
a2562 4
	nfsm_clget;
	*tl = nfs_false;
	bp += NFSX_UNSIGNED;
	nfsm_clget;
a2566 6
	bp += NFSX_UNSIGNED;
	if (mp != mb) {
		if (bp < be)
			mp->m_len = bp - mtod(mp, caddr_t);
	} else
		mp->m_len += bp - bpos;
a2583 2
	char *bp, *be;
	struct mbuf *mp;
a2584 1
	caddr_t cp;
d2588 1
a2588 1
	struct mbuf *mb, *mreq, *mp2;
d2598 1
a2598 1
	int len, nlen, rem, xfer, tsiz, i, error = 0, getret = 1;
a2738 3
	mp = mp2 = mb;
	bp = bpos;
	be = bp + M_TRAILINGSPACE(mp);
d2744 2
a2745 2
			rem = nfsm_rndup(nlen)-nlen;
	
d2774 1
a2774 1
			 * nlen + rem == space the name takes up
d2782 1
a2782 1
			len += (8 * NFSX_UNSIGNED + nlen + rem + NFSX_V3FH +
d2784 1
a2784 1
			dirlen += (6 * NFSX_UNSIGNED + nlen + rem);
d2790 8
d2810 2
a2811 49
			nfsm_clget;
			*tl = nfs_true;
			bp += NFSX_UNSIGNED;
			nfsm_clget;
			*tl = 0;
			bp += NFSX_UNSIGNED;
			nfsm_clget;
			*tl = txdr_unsigned(dp->d_fileno);
			bp += NFSX_UNSIGNED;
			nfsm_clget;
			*tl = txdr_unsigned(nlen);
			bp += NFSX_UNSIGNED;
	
			/* And loop around copying the name */
			xfer = nlen;
			cp = dp->d_name;
			while (xfer > 0) {
				nfsm_clget;
				if ((bp + xfer) > be)
					tsiz = be - bp;
				else
					tsiz = xfer;
				bcopy(cp, bp, tsiz);
				bp += tsiz;
				xfer -= tsiz;
				if (xfer > 0)
					cp += tsiz;
			}
			/* And null pad to an int32_t boundary */
			for (i = 0; i < rem; i++)
				*bp++ = '\0';
	
			/*
			 * Now copy the flrep structure out.
			 */
			xfer = sizeof (struct flrep);
			cp = (caddr_t)&fl;
			while (xfer > 0) {
				nfsm_clget;
				if ((bp + xfer) > be)
					tsiz = be - bp;
				else
					tsiz = xfer;
				bcopy(cp, bp, tsiz);
				bp += tsiz;
				xfer -= tsiz;
				if (xfer > 0)
					cp += tsiz;
			}
d2820 2
a2821 4
	nfsm_clget;
	*tl = nfs_false;
	bp += NFSX_UNSIGNED;
	nfsm_clget;
a2825 6
	bp += NFSX_UNSIGNED;
	if (mp != mb) {
		if (bp < be)
			mp->m_len = bp - mtod(mp, caddr_t);
	} else
		mp->m_len += bp - bpos;
@


1.49
log
@Widen some struct statfs fields to support large filesystem stata
and add some to be able to support statvfs(2). Do the compat dance
to provide backward compatibility.  ok thib@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.48 2008/01/06 17:38:23 blambert Exp $	*/
d121 1
a121 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly,
	    (nfsd->nd_flag & ND_KERBAUTH));
d184 1
a184 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly,
	    (nfsd->nd_flag & ND_KERBAUTH));
d275 1
a275 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly,
	    (nfsd->nd_flag & ND_KERBAUTH));
d368 1
a368 2
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos,
		&dirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d467 1
a467 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d549 1
a549 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d760 1
a760 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d1032 2
a1033 2
		error = nfsrv_fhtovp(&nfsd->nd_fh, 1, &vp, cred, slp, 
		    nfsd->nd_nam, &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d1264 1
a1264 2
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos,
		&dirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d1499 1
a1499 2
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos,
		&dirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d1648 1
a1648 2
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos,
		&dirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d1740 1
a1740 2
	error = nfs_namei(&fromnd, ffhp, len, slp, nam, &md,
		&dpos, &fdirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d1767 1
a1767 2
	error = nfs_namei(&tond, tfhp, len2, slp, nam, &md,
		&dpos, &tdirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d1909 1
a1909 2
	error = nfsrv_fhtovp(fhp, FALSE, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d1922 1
a1922 2
	error = nfs_namei(&nd, dfhp, len, slp, nam, &md, &dpos,
		&dirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d2009 1
a2009 2
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos,
		&dirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d2148 1
a2148 2
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos,
		&dirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d2260 1
a2260 2
	error = nfs_namei(&nd, fhp, len, slp, nam, &md, &dpos,
		&dirp, procp, (nfsd->nd_flag & ND_KERBAUTH));
d2403 1
a2403 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d2655 1
a2655 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d2963 1
a2963 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d3017 1
a3017 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d3088 1
a3088 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
d3156 1
a3156 2
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam,
		 &rdonly, (nfsd->nd_flag & ND_KERBAUTH));
@


1.48
log
@More NFS-related kernel shrinkage...

When you use a macro ~200 times, it tends to bloat your code, so make a
function out of it.

Shaves ~8.5 kB from my kernel.

ok thib@@, "looks good" krw@@

In snaps for 1+ week with no negative reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.47 2007/12/27 00:08:33 thib Exp $	*/
d3064 5
a3068 6
		sfp->sf_tfiles.nfsuquad[0] = 0;
		sfp->sf_tfiles.nfsuquad[1] = txdr_unsigned(sf->f_files);
		sfp->sf_ffiles.nfsuquad[0] = 0;
		sfp->sf_ffiles.nfsuquad[1] = txdr_unsigned(sf->f_ffree);
		sfp->sf_afiles.nfsuquad[0] = 0;
		sfp->sf_afiles.nfsuquad[1] = txdr_unsigned(sf->f_ffree);
@


1.47
log
@Fix for PR5365.
Use the va_blocksize, that is the blocksize of the underlying exported
file system instead of the DIRBLKSIZ constant to size the chunks.

Diff from Enache Adrian <3n4ch3@@gmail.com>

Tested by myself and a few others.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.46 2007/11/08 19:20:09 blambert Exp $	*/
d114 1
a114 1
	struct mbuf *mb, *mreq, *mb2;
d151 1
a151 1
	nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d181 1
a181 1
	struct mbuf *mb, *mb2, *mreq;
d196 1
a196 1
	nfsm_build(fp, struct nfs_fattr *, NFSX_FATTR(nfsd->nd_flag & ND_NFSV3));
d228 1
a228 1
	struct mbuf *mb, *mb2, *mreq;
d329 1
a329 1
		nfsm_build(fp, struct nfs_fattr *, NFSX_V2FATTR);
d362 1
a362 1
	struct mbuf *mb, *mb2, *mreq;
d403 1
a403 1
		nfsm_build(fp, struct nfs_fattr *, NFSX_V2FATTR);
d433 1
a433 1
	struct mbuf *mb, *mb2, *mp2 = NULL, *mp3 = NULL, *mreq;
d503 1
a503 1
	nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d535 1
a535 1
	struct mbuf *mb, *mb2, *mreq;
d588 1
a588 1
		nfsm_build(tl, u_int32_t *, NFSX_V3FATTR + 4 * NFSX_UNSIGNED);
d593 1
a593 1
		nfsm_build(tl, u_int32_t *, NFSX_V2FATTR + NFSX_UNSIGNED);
d703 1
a703 1
	struct mbuf *mb, *mb2, *mreq;
d840 1
a840 1
		nfsm_build(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
d854 1
a854 1
		nfsm_build(fp, struct nfs_fattr *, NFSX_V2FATTR);
d890 1
a890 1
	struct mbuf *mb, *mb2, *mreq, *mrep, *md;
d1118 1
a1118 1
			    nfsm_build(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
d1129 1
a1129 1
			    nfsm_build(fp, struct nfs_fattr *, NFSX_V2FATTR);
d1257 1
a1257 1
	struct mbuf *mb, *mb2, *mreq;
d1451 1
a1451 1
		nfsm_build(fp, struct nfs_fattr *, NFSX_V2FATTR);
d1495 1
a1495 1
	struct mbuf *mb, *mb2, *mreq;
d2011 1
a2011 1
	struct mbuf *mb, *mreq, *mb2;
d2152 1
a2152 1
	struct mbuf *mb, *mb2, *mreq;
d2226 1
a2226 1
		nfsm_build(fp, struct nfs_fattr *, NFSX_V2FATTR);
d2393 1
a2393 1
	struct mbuf *mb, *mb2, *mreq, *mp2;
d2501 1
a2501 1
				nfsm_build(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
d2505 1
a2505 1
				nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d2539 1
a2539 1
		nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d2650 1
a2650 1
	struct mbuf *mb, *mb2, *mreq, *mp2;
d2753 1
a2753 1
			nfsm_build(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
d2800 1
a2800 1
	nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d2968 1
a2968 1
	struct mbuf *mb, *mb2, *mreq;
d2996 1
a2996 1
		nfsm_build(tl, u_int32_t *, NFSX_V3WRITEVERF);
d3027 1
a3027 1
	struct mbuf *mb, *mb2, *mreq;
d3053 1
a3053 1
	nfsm_build(sfp, struct nfs_statfs *, NFSX_STATFS(v3));
d3102 1
a3102 1
	struct mbuf *mb, *mb2, *mreq;
d3121 1
a3121 1
	nfsm_build(sip, struct nfsv3_fsinfo *, NFSX_V3FSINFO);
d3171 1
a3171 1
	struct mbuf *mb, *mb2, *mreq;
d3199 1
a3199 1
	nfsm_build(pc, struct nfsv3_pathconf *, NFSX_V3PATHCONF);
@


1.46
log
@Fix unsafe queue macro use

ok thib@@ 'emphatic' ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.45 2007/11/07 23:40:52 thib Exp $	*/
d2419 1
a2419 9
	off = toff;
	cnt = fxdr_unsigned(int, *tl);
	siz = ((cnt + DIRBLKSIZ - 1) & ~(DIRBLKSIZ - 1));
	xfer = NFS_SRVMAXDATA(nfsd);
	if (siz > xfer)
		siz = xfer;
	if (cnt > xfer)
		cnt = xfer;
	fullsiz = siz;
d2427 2
a2428 10
	if (v3) {
		error = getret = VOP_GETATTR(vp, &at, cred, procp);
#ifdef NFS3_STRICTVERF
		/*
		 * XXX This check is too strict for Solaris 2.5 clients.
		 */
		if (!error && toff && verf != at.va_filerev)
			error = NFSERR_BAD_COOKIE;
#endif
	}
d2437 10
d2672 1
a2672 10
	siz = fxdr_unsigned(int, *tl++);
	cnt = fxdr_unsigned(int, *tl);
	off = toff;
	siz = ((siz + DIRBLKSIZ - 1) & ~(DIRBLKSIZ - 1));
	xfer = NFS_SRVMAXDATA(nfsd);
	if (siz > xfer)
		siz = xfer;
	if (cnt > xfer)
		cnt = xfer;
	fullsiz = siz;
d2680 1
d2682 1
a2682 8
#ifdef NFS3_STRICTVERF
	/*
	 * XXX This check is too strict for Solaris 2.5 clients.
	 */
	if (!error && toff && verf != at.va_filerev)
		error = NFSERR_BAD_COOKIE;
#endif
	if (!error) {
a2683 1
	}
d2690 11
a2701 1

@


1.45
log
@more low hanging fruit; Expand the nfsm_srvwcc_data() macro
and nuke it's definition.

OK krw@@, blamers@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.44 2007/11/06 19:36:44 thib Exp $	*/
d877 1
a877 1
	struct nfsrv_descript *wp, *nfsd, *owp, *swp;
d1164 2
a1165 2
	for (nfsd = LIST_FIRST(&slp->ns_tq); nfsd != NULL;
	    nfsd = LIST_NEXT(nfsd, nd_tq)) {
@


1.44
log
@Expand the nfsm_srvfillattr() macro and
nuke it's definition.

OK krw@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.43 2007/10/28 14:12:41 thib Exp $	*/
d281 2
a282 1
		nfsm_srvwcc_data(preat_ret, &preat, postat_ret, &va);
d294 2
a295 1
			nfsm_srvwcc_data(preat_ret, &preat, postat_ret, &va);
d325 2
a326 1
		nfsm_srvwcc_data(preat_ret, &preat, postat_ret, &va);
d762 2
a763 1
		nfsm_srvwcc_data(forat_ret, &forat, aftat_ret, &va);
d770 2
a771 1
		nfsm_srvwcc_data(forat_ret, &forat, aftat_ret, &va);
d788 2
a789 1
		nfsm_srvwcc_data(forat_ret, &forat, aftat_ret, &va);
d836 2
a837 1
		nfsm_srvwcc_data(forat_ret, &forat, aftat_ret, &va);
d962 2
a963 1
		    nfsm_srvwcc_data(forat_ret, &forat, aftat_ret, &va);
d1108 2
a1109 1
			    nfsm_srvwcc_data(forat_ret, &forat, aftat_ret, &va);
d1116 2
a1117 1
			    nfsm_srvwcc_data(forat_ret, &forat, aftat_ret, &va);
d1284 2
a1285 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d1447 2
a1448 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d1513 2
a1514 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d1601 2
a1602 1
	nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d1698 2
a1699 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d1763 4
a1766 2
		nfsm_srvwcc_data(fdirfor_ret, &fdirfor, fdiraft_ret, &fdiraft);
		nfsm_srvwcc_data(tdirfor_ret, &tdirfor, tdiraft_ret, &tdiraft);
d1863 4
a1866 2
		nfsm_srvwcc_data(fdirfor_ret, &fdirfor, fdiraft_ret, &fdiraft);
		nfsm_srvwcc_data(tdirfor_ret, &tdirfor, tdiraft_ret, &tdiraft);
d1926 2
a1927 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d1979 2
a1980 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d2105 2
a2106 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d2176 2
a2177 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d2222 2
a2223 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d2289 2
a2290 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d2329 2
a2330 1
		nfsm_srvwcc_data(dirfor_ret, &dirfor, diraft_ret, &diraft);
d2998 1
a2998 1
		nfsm_srvwcc_data(for_ret, &bfor, aft_ret, &aft);
d3006 1
a3006 1
	nfsm_srvwcc_data(for_ret, &bfor, aft_ret, &aft);
@


1.43
log
@Remove the "frev" argument from nfs_rephead(); and clean up the "frev"
variables, that are declared all over, since they are passed via macros
to nfs_rephead(); which doesn't do anything with it.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.42 2007/09/20 12:54:31 thib Exp $	*/
d197 1
a197 1
	nfsm_srvfillattr(&va, fp);
d327 1
a327 1
		nfsm_srvfillattr(&va, fp);
d401 1
a401 1
		nfsm_srvfillattr(&va, fp);
d654 1
a654 1
	nfsm_srvfillattr(&va, fp);
d848 1
a848 1
		nfsm_srvfillattr(&va, fp);
d1120 1
a1120 1
			    nfsm_srvfillattr(&va, fp);
d1440 1
a1440 1
		nfsm_srvfillattr(&va, fp);
d2203 1
a2203 1
		nfsm_srvfillattr(&va, fp);
d2847 1
a2847 1
			nfsm_srvfillattr(vap, fp);
@


1.42
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.41 2007/09/11 13:41:52 blambert Exp $	*/
a116 1
	u_quad_t frev;
a181 1
	u_quad_t frev;
a228 1
	u_quad_t frev;
a360 1
	u_quad_t frev;
a435 1
	u_quad_t frev;
a539 1
	u_quad_t frev;
a705 1
	u_quad_t frev;
d886 1
a886 1
	u_quad_t frev, cur_usec;
d1251 1
a1251 1
	u_quad_t frev, tempsize;
a1486 1
	u_quad_t frev;
a1632 1
	u_quad_t frev;
a1718 1
	u_quad_t frev;
a1895 1
	u_quad_t frev;
a1993 1
	u_quad_t frev;
a2133 1
	u_quad_t frev;
a2244 1
	u_quad_t frev;
d2378 1
a2378 1
	u_quad_t frev, off, toff, verf;
d2642 1
a2642 1
	u_quad_t frev, off, toff, verf;
d2955 1
a2955 1
	u_quad_t frev, off;
d3019 1
a3019 1
	u_quad_t frev, tval;
a3092 1
	u_quad_t frev;
a3161 1
	u_quad_t frev;
a3217 1
	u_quad_t frev;
a3237 1
	u_quad_t frev;
@


1.41
log
@Replace nfsm_reqdone and nfsm_srvdone macros inline. No binary change.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.40 2006/04/02 18:35:11 otto Exp $	*/
d621 1
a621 2
		MALLOC(iv, struct iovec *, i * sizeof (struct iovec),
		       M_TEMP, M_WAITOK);
d647 1
a647 1
		FREE((caddr_t)iv2, M_TEMP);
d795 1
a795 2
	    MALLOC(ivp, struct iovec *, cnt * sizeof (struct iovec), M_TEMP,
		M_WAITOK);
d828 1
a828 1
	    FREE((caddr_t)iv, M_TEMP);
d1075 1
a1075 2
		    MALLOC(iov, struct iovec *, i * sizeof (struct iovec), 
			M_TEMP, M_WAITOK);
d1090 1
a1090 1
		    FREE((caddr_t)iov, M_TEMP);
d2031 1
a2031 1
	MALLOC(pathcp, caddr_t, len2 + 1, M_TEMP, M_WAITOK);
d2085 1
a2085 1
		FREE(pathcp, M_TEMP);
d2114 1
a2114 1
		FREE(pathcp, M_TEMP);
d2442 1
a2442 1
	MALLOC(rbuf, caddr_t, siz, M_TEMP, M_WAITOK);
d2502 2
a2503 2
			FREE((caddr_t)rbuf, M_TEMP);
			FREE((caddr_t)cookies, M_TEMP);
d2620 2
a2621 2
	FREE((caddr_t)rbuf, M_TEMP);
	FREE((caddr_t)cookies, M_TEMP);
d2702 1
a2702 1
	MALLOC(rbuf, caddr_t, siz, M_TEMP, M_WAITOK);
d2758 2
a2759 2
			FREE((caddr_t)cookies, M_TEMP);
			FREE((caddr_t)rbuf, M_TEMP);
d2939 2
a2940 2
	FREE((caddr_t)cookies, M_TEMP);
	FREE((caddr_t)rbuf, M_TEMP);
@


1.40
log
@When setting timestamps TOSERVER having write permissions is adaquate;
problem experienced by Han Boetes; fix with "nfs4" rick at snowhite
dot cis dot uoguelph dot ca. ok pedro@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.39 2005/06/18 18:09:43 millert Exp $	*/
d154 2
a155 1
	nfsm_srvdone;
d200 2
a201 1
	nfsm_srvdone;
d332 2
a333 1
	nfsm_srvdone;
d407 2
a408 1
	nfsm_srvdone;
d508 2
a509 1
	nfsm_srvdone;
d675 2
a676 1
	nfsm_srvdone;
d859 2
a860 1
	nfsm_srvdone;
d1699 2
a1700 1
	nfsm_srvdone;
d1976 2
a1977 1
	nfsm_srvdone;
d2324 2
a2325 1
	nfsm_srvdone;
d2625 2
a2626 1
	nfsm_srvdone;
d2944 2
a2945 1
	nfsm_srvdone;
d3004 2
a3005 1
	nfsm_srvdone;
d3081 2
a3082 1
	nfsm_srvdone;
d3150 2
a3151 1
	nfsm_srvdone;
d3218 2
a3219 1
	nfsm_srvdone;
@


1.39
log
@Remove remaining whiteout tentacles; OK deraadt@@ miod@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.38 2004/06/24 19:35:26 tholo Exp $	*/
d236 1
@


1.38
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.37 2004/05/14 04:00:34 tedu Exp $	*/
a2332 2
 * - it trims out records with d_type == DT_WHT
 *	these cannot be seen through NFS (unless we extend the protocol)
d2509 1
a2509 2
	while (cpos < cend && ncookies > 0 &&
	    (dp->d_fileno == 0 || dp->d_type == DT_WHT)) {
d2534 1
a2534 1
		if (dp->d_fileno != 0 && dp->d_type != DT_WHT) {
d2764 1
a2764 2
	while (cpos < cend && ncookies > 0 &&
	    (dp->d_fileno == 0 || dp->d_type == DT_WHT)) {
d2799 1
a2799 1
		if (dp->d_fileno != 0 && dp->d_type != DT_WHT) {
@


1.37
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.36 2003/08/15 20:32:20 tedu Exp $	*/
d888 1
d902 2
a903 1
	    cur_usec = (u_quad_t)time.tv_sec * 1000000 + (u_quad_t)time.tv_usec;
d1015 2
a1016 1
	cur_usec = (u_quad_t)time.tv_sec * 1000000 + (u_quad_t)time.tv_usec;
@


1.36
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.35 2003/06/02 23:28:19 millert Exp $	*/
d71 1
d382 1
a382 1
	FREE(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1332 1
a1332 1
				FREE(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1349 1
a1349 1
				free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1360 1
a1360 1
				free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1369 1
a1369 1
				free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1374 1
a1374 1
			FREE(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1385 1
a1385 1
			free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1393 1
a1393 1
		free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1447 1
a1447 1
		free((caddr_t)nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1510 1
a1510 1
		free((caddr_t)nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1530 1
a1530 1
		free((caddr_t)nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1541 1
a1541 1
			FREE(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1546 1
a1546 1
			free((caddr_t)nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1561 1
a1561 1
		FREE(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1595 1
a1595 1
		free((caddr_t)nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1833 1
a1833 1
	FREE(tond.ni_cnd.cn_pnbuf, M_NAMEI);
d1844 1
a1844 1
	FREE(fromnd.ni_cnd.cn_pnbuf, M_NAMEI);
d1859 1
a1859 1
		FREE(tond.ni_cnd.cn_pnbuf, M_NAMEI);
d1863 1
a1863 1
		FREE(fromnd.ni_cnd.cn_pnbuf, M_NAMEI);
d2039 1
a2039 1
		free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d2071 1
a2071 1
	    FREE(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d2092 1
a2092 1
		free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.34 2002/07/03 20:57:00 nate Exp $	*/
d1346 1
a1346 1
			    (error = suser(cred, (u_short *)0))) {
d1543 1
a1543 1
		    (error = suser(cred, (u_short *)0))) {
d1655 1
a1655 1
		    (error = suser(cred, (u_short *)0)) != 0)
d1911 1
a1911 1
	if (vp->v_type == VDIR && (error = suser(cred, (u_short *)0)) != 0)
@


1.34
log
@Remove unused function parameter 'cache' from nfs_rephead
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.33 2002/06/11 05:14:54 art Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.33
log
@splassert where comments tell us to.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.32 2002/05/10 22:07:08 csapuntz Exp $	*/
d115 1
a115 1
	int error = 0, rdonly, cache = 0, getret;
d182 1
a182 1
	int error = 0, rdonly, cache;
d228 1
a228 1
	int error = 0, rdonly, cache, preat_ret = 1, postat_ret = 1;
d358 1
a358 1
	int error = 0, cache, len, dirattr_ret = 1;
d429 1
a429 1
	int error = 0, rdonly, cache, i, tlen, len, getret;
d531 1
a531 1
	int error = 0, rdonly, cache, cnt, len, left, siz, tlen, getret;
d698 1
a698 1
	int error = 0, rdonly, cache, len, forat_ret = 1;
d884 1
a884 1
	int error = 0, rdonly, cache, len = 0, forat_ret = 1;
d1245 1
a1245 1
	int error = 0, cache, len, tsize, dirfor_ret = 1, diraft_ret = 1;
d1481 1
a1481 1
	int error = 0, cache, len, dirfor_ret = 1, diraft_ret = 1;
d1628 1
a1628 1
	int error = 0, cache, len, dirfor_ret = 1, diraft_ret = 1;
d1711 1
a1711 1
	int error = 0, cache, len, len2, fdirfor_ret = 1, fdiraft_ret = 1;
d1892 1
a1892 1
	int error = 0, rdonly, cache, len, dirfor_ret = 1, diraft_ret = 1;
d1992 1
a1992 1
	int error = 0, cache, len, len2, dirfor_ret = 1, diraft_ret = 1;
d2132 1
a2132 1
	int error = 0, cache, len, dirfor_ret = 1, diraft_ret = 1;
d2242 1
a2242 1
	int error = 0, cache, len, dirfor_ret = 1, diraft_ret = 1;
d2384 1
a2384 1
	int siz, cnt, fullsiz, eofflag, rdonly, cache, ncookies;
d2649 1
a2649 1
	int siz, cnt, fullsiz, eofflag, rdonly, cache, dirlen, ncookies;
d2960 1
a2960 1
	int error = 0, rdonly, for_ret = 1, aft_ret = 1, cnt, cache;
a2964 3
#ifndef nolint
	cache = 0;
#endif
d3017 1
a3017 1
	int error = 0, rdonly, cache, getret = 1;
a3027 3
#ifndef nolint
	cache = 0;
#endif
d3092 1
a3092 1
	int error = 0, rdonly, cache, getret = 1, pref;
a3100 3
#ifndef nolint
	cache = 0;
#endif
d3160 1
a3160 1
	int error = 0, rdonly, cache, getret = 1;
a3169 3
#ifndef nolint
	cache = 0;
#endif
d3222 1
a3222 1
	int error = NFSERR_RETVOID, cache = 0;
d3243 1
a3243 1
	int error, cache = 0;
@


1.32
log
@Fix for PR2641. Length calculation was wrong in loop. Include comment
describing fixed length calculation
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.31 2002/04/29 07:36:32 deraadt Exp $	*/
d1178 1
a1178 3
nfsrvw_coalesce(owp, nfsd)
        struct nfsrv_descript *owp;
        struct nfsrv_descript *nfsd;
d1182 2
@


1.31
log
@constrain readdirplus request count; j@@pureftpd.org, ok costa
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.30 2002/01/16 21:51:16 ericj Exp $	*/
d2780 12
d2831 11
d2843 1
a2843 1
			len += (7 * NFSX_UNSIGNED + nlen + rem + NFSX_V3FH +
@


1.30
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.29 2001/12/19 08:58:06 art Exp $	*/
d2407 2
d2667 2
@


1.30.2.1
log
@Pull in patch from current:
Fix (csapuntz):
Fix for PR2641. Length calculation was wrong in loop. Include comment
describing fixed length calculation
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.30 2002/01/16 21:51:16 ericj Exp $	*/
a2775 12
	/*
	 * struct READDIRPLUS3resok {
	 *     postop_attr dir_attributes;
	 *     cookieverf3 cookieverf;
	 *     dirlistplus3 reply;
	 * }
	 *
	 * struct dirlistplus3 {
	 *     entryplus3  *entries;
	 *     bool eof;
	 *  }
	 */	
a2814 11
			 *
			 * Each entry:
			 * 2 * NFSX_UNSIGNED for fileid3
			 * 1 * NFSX_UNSIGNED for length of name
			 * nlen + rem == space the name takes up
			 * 2 * NFSX_UNSIGNED for the cookie
			 * 1 * NFSX_UNSIGNED to indicate if file handle present
			 * 1 * NFSX_UNSIGNED for the file handle length
			 * NFSX_V3FH == space our file handle takes up
			 * NFSX_V3POSTOPATTR == space the attributes take up
			 * 1 * NFSX_UNSIGNED for next pointer
d2816 1
a2816 1
			len += (8 * NFSX_UNSIGNED + nlen + rem + NFSX_V3FH +
@


1.29
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.27 2001/11/06 19:53:21 miod Exp $	*/
d112 2
a113 2
	register u_int32_t *tl;
	register int32_t t1;
d174 1
a174 1
	register struct nfs_fattr *fp;
d179 2
a180 2
	register u_int32_t *tl;
	register int32_t t1;
d220 2
a221 2
	register struct nfsv2_sattr *sp;
	register struct nfs_fattr *fp;
d225 2
a226 2
	register u_int32_t *tl;
	register int32_t t1;
d349 1
a349 1
	register struct nfs_fattr *fp;
d354 3
a356 3
	register caddr_t cp;
	register u_int32_t *tl;
	register int32_t t1;
d424 4
a427 4
	register struct iovec *ivp = iv;
	register struct mbuf *mp;
	register u_int32_t *tl;
	register int32_t t1;
d523 1
a523 1
	register struct iovec *iv;
d525 5
a529 5
	register struct mbuf *m;
	register struct nfs_fattr *fp;
	register u_int32_t *tl;
	register int32_t t1;
	register int i;
d689 4
a692 4
	register struct iovec *ivp;
	register int i, cnt;
	register struct mbuf *mp;
	register struct nfs_fattr *fp;
d695 2
a696 2
	register u_int32_t *tl;
	register int32_t t1;
d872 5
a876 5
	register struct iovec *ivp;
	register struct mbuf *mp;
	register struct nfsrv_descript *wp, *nfsd, *owp, *swp;
	register struct nfs_fattr *fp;
	register int i = 0;
d881 2
a882 2
	register u_int32_t *tl;
	register int32_t t1;
d968 1
a968 1
	    wp = slp->ns_tq.lh_first;
d971 1
a971 1
		wp = wp->nd_tq.le_next;
d981 1
a981 1
		wp = wpp->lh_first;
d985 1
a985 1
		    wp = wp->nd_hash.le_next;
d988 1
a988 1
		    !bcmp((caddr_t)&nfsd->nd_fh,(caddr_t)&wp->nd_fh,NFSX_V3FH)) {
d990 1
a990 1
		    wp = wp->nd_hash.le_next;
d1000 1
a1000 1
			wp = nfsd->nd_hash.le_next;
d1018 2
a1019 2
	for (nfsd = slp->ns_tq.lh_first; nfsd; nfsd = owp) {
		owp = nfsd->nd_tq.le_next;
d1138 1
a1138 1
		    nfsd = swp->nd_coalesce.lh_first;
d1156 2
a1157 1
	for (nfsd = slp->ns_tq.lh_first; nfsd; nfsd = nfsd->nd_tq.le_next)
d1164 1
d1179 2
a1180 2
        register struct nfsrv_descript *owp;
        register struct nfsrv_descript *nfsd;
d1182 2
a1183 2
        register int overlap;
        register struct mbuf *mp;
d1237 1
a1237 1
	register struct nfs_fattr *fp;
d1239 2
a1240 2
	register struct nfsv2_sattr *sp;
	register u_int32_t *tl;
d1242 2
a1243 2
	register caddr_t cp;
	register int32_t t1;
d1477 1
a1477 1
	register u_int32_t *tl;
d1479 1
a1479 1
	register int32_t t1;
d1625 2
a1626 2
	register u_int32_t *tl;
	register int32_t t1;
d1708 2
a1709 2
	register u_int32_t *tl;
	register int32_t t1;
d1889 2
a1890 2
	register u_int32_t *tl;
	register int32_t t1;
d1986 2
a1987 2
	register u_int32_t *tl;
	register int32_t t1;
d2126 1
a2126 1
	register struct nfs_fattr *fp;
d2128 3
a2130 3
	register caddr_t cp;
	register u_int32_t *tl;
	register int32_t t1;
d2239 2
a2240 2
	register u_int32_t *tl;
	register int32_t t1;
d2368 6
a2373 6
	register char *bp, *be;
	register struct mbuf *mp;
	register struct dirent *dp;
	register caddr_t cp;
	register u_int32_t *tl;
	register int32_t t1;
d2629 6
a2634 6
	register char *bp, *be;
	register struct mbuf *mp;
	register struct dirent *dp;
	register caddr_t cp;
	register u_int32_t *tl;
	register int32_t t1;
d2930 2
a2931 2
	register u_int32_t *tl;
	register int32_t t1;
d2988 4
a2991 4
	register struct statfs *sf;
	register struct nfs_statfs *sfp;
	register u_int32_t *tl;
	register int32_t t1;
d3067 3
a3069 3
	register u_int32_t *tl;
	register struct nfsv3_fsinfo *sip;
	register int32_t t1;
d3138 3
a3140 3
	register u_int32_t *tl;
	register struct nfsv3_pathconf *pc;
	register int32_t t1;
d3253 1
a3253 1
	register struct vnode *vp;
d3255 1
a3255 1
	register struct ucred *cred;
@


1.28
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1666 2
d3279 3
a3281 2
		 * If the vnode is in use as a process's text,
		 * we can't allow writing.
d3283 1
a3283 1
		if ((vp->v_flag & VTEXT))
@


1.28.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.30 2002/01/16 21:51:16 ericj Exp $	*/
d112 2
a113 2
	u_int32_t *tl;
	int32_t t1;
d174 1
a174 1
	struct nfs_fattr *fp;
d179 2
a180 2
	u_int32_t *tl;
	int32_t t1;
d220 2
a221 2
	struct nfsv2_sattr *sp;
	struct nfs_fattr *fp;
d225 2
a226 2
	u_int32_t *tl;
	int32_t t1;
d349 1
a349 1
	struct nfs_fattr *fp;
d354 3
a356 3
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1;
d424 4
a427 4
	struct iovec *ivp = iv;
	struct mbuf *mp;
	u_int32_t *tl;
	int32_t t1;
d523 1
a523 1
	struct iovec *iv;
d525 5
a529 5
	struct mbuf *m;
	struct nfs_fattr *fp;
	u_int32_t *tl;
	int32_t t1;
	int i;
d689 4
a692 4
	struct iovec *ivp;
	int i, cnt;
	struct mbuf *mp;
	struct nfs_fattr *fp;
d695 2
a696 2
	u_int32_t *tl;
	int32_t t1;
d872 5
a876 5
	struct iovec *ivp;
	struct mbuf *mp;
	struct nfsrv_descript *wp, *nfsd, *owp, *swp;
	struct nfs_fattr *fp;
	int i = 0;
d881 2
a882 2
	u_int32_t *tl;
	int32_t t1;
d968 1
a968 1
	    wp = LIST_FIRST(&slp->ns_tq);
d971 1
a971 1
		wp = LIST_NEXT(wp, nd_tq);
d981 1
a981 1
		wp = LIST_FIRST(wpp);
d985 1
a985 1
		    wp = LIST_NEXT(wp, nd_hash);
d988 1
a988 1
		   !bcmp((caddr_t)&nfsd->nd_fh,(caddr_t)&wp->nd_fh,NFSX_V3FH)) {
d990 1
a990 1
		    wp = LIST_NEXT(wp, nd_hash);
d1000 1
a1000 1
			wp = LIST_NEXT(nfsd, nd_hash);
d1018 2
a1019 2
	for (nfsd = LIST_FIRST(&slp->ns_tq); nfsd != NULL; nfsd = owp) {
		owp = LIST_NEXT(nfsd, nd_tq);
d1138 1
a1138 1
		    nfsd = LIST_FIRST(&swp->nd_coalesce);
d1156 1
a1156 2
	for (nfsd = LIST_FIRST(&slp->ns_tq); nfsd != NULL;
	    nfsd = LIST_NEXT(nfsd, nd_tq)) {
a1162 1
	}
d1177 2
a1178 2
        struct nfsrv_descript *owp;
        struct nfsrv_descript *nfsd;
d1180 2
a1181 2
        int overlap;
        struct mbuf *mp;
d1235 1
a1235 1
	struct nfs_fattr *fp;
d1237 2
a1238 2
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
d1240 2
a1241 2
	caddr_t cp;
	int32_t t1;
d1475 1
a1475 1
	u_int32_t *tl;
d1477 1
a1477 1
	int32_t t1;
d1623 2
a1624 2
	u_int32_t *tl;
	int32_t t1;
d1704 2
a1705 2
	u_int32_t *tl;
	int32_t t1;
d1885 2
a1886 2
	u_int32_t *tl;
	int32_t t1;
d1982 2
a1983 2
	u_int32_t *tl;
	int32_t t1;
d2122 1
a2122 1
	struct nfs_fattr *fp;
d2124 3
a2126 3
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1;
d2235 2
a2236 2
	u_int32_t *tl;
	int32_t t1;
d2364 6
a2369 6
	char *bp, *be;
	struct mbuf *mp;
	struct dirent *dp;
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1;
d2625 6
a2630 6
	char *bp, *be;
	struct mbuf *mp;
	struct dirent *dp;
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1;
d2926 2
a2927 2
	u_int32_t *tl;
	int32_t t1;
d2984 4
a2987 4
	struct statfs *sf;
	struct nfs_statfs *sfp;
	u_int32_t *tl;
	int32_t t1;
d3063 3
a3065 3
	u_int32_t *tl;
	struct nfsv3_fsinfo *sip;
	int32_t t1;
d3134 3
a3136 3
	u_int32_t *tl;
	struct nfsv3_pathconf *pc;
	int32_t t1;
d3249 1
a3249 1
	struct vnode *vp;
d3251 1
a3251 1
	struct ucred *cred;
@


1.28.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.28.2.1 2002/01/31 22:55:47 niklas Exp $	*/
a2404 2
	if (cnt > xfer)
		cnt = xfer;
a2662 2
	if (cnt > xfer)
		cnt = xfer;
a2773 12
	/*
	 * struct READDIRPLUS3resok {
	 *     postop_attr dir_attributes;
	 *     cookieverf3 cookieverf;
	 *     dirlistplus3 reply;
	 * }
	 *
	 * struct dirlistplus3 {
	 *     entryplus3  *entries;
	 *     bool eof;
	 *  }
	 */	
a2812 11
			 *
			 * Each entry:
			 * 2 * NFSX_UNSIGNED for fileid3
			 * 1 * NFSX_UNSIGNED for length of name
			 * nlen + rem == space the name takes up
			 * 2 * NFSX_UNSIGNED for the cookie
			 * 1 * NFSX_UNSIGNED to indicate if file handle present
			 * 1 * NFSX_UNSIGNED for the file handle length
			 * NFSX_V3FH == space our file handle takes up
			 * NFSX_V3POSTOPATTR == space the attributes take up
			 * 1 * NFSX_UNSIGNED for next pointer
d2814 1
a2814 1
			len += (8 * NFSX_UNSIGNED + nlen + rem + NFSX_V3FH +
@


1.28.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.28.2.2 2002/06/11 03:32:03 art Exp $	*/
d115 1
a115 1
	int error = 0, rdonly, getret;
d182 1
a182 1
	int error = 0, rdonly;
d228 1
a228 1
	int error = 0, rdonly, preat_ret = 1, postat_ret = 1;
d358 1
a358 1
	int error = 0, len, dirattr_ret = 1;
d429 1
a429 1
	int error = 0, rdonly, i, tlen, len, getret;
d531 1
a531 1
	int error = 0, rdonly, cnt, len, left, siz, tlen, getret;
d698 1
a698 1
	int error = 0, rdonly, len, forat_ret = 1;
d884 1
a884 1
	int error = 0, rdonly, len = 0, forat_ret = 1;
d1178 3
a1180 1
nfsrvw_coalesce(struct nfsrv_descript *owp, struct nfsrv_descript *nfsd)
a1184 2
	splassert(IPL_SOFTCLOCK);

d1245 1
a1245 1
	int error = 0, len, tsize, dirfor_ret = 1, diraft_ret = 1;
d1481 1
a1481 1
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
d1628 1
a1628 1
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
d1709 1
a1709 1
	int error = 0, len, len2, fdirfor_ret = 1, fdiraft_ret = 1;
d1890 1
a1890 1
	int error = 0, rdonly, len, dirfor_ret = 1, diraft_ret = 1;
d1990 1
a1990 1
	int error = 0, len, len2, dirfor_ret = 1, diraft_ret = 1;
d2130 1
a2130 1
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
d2240 1
a2240 1
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
d2382 1
a2382 1
	int siz, cnt, fullsiz, eofflag, rdonly, ncookies;
d2647 1
a2647 1
	int siz, cnt, fullsiz, eofflag, rdonly, dirlen, ncookies;
d2958 1
a2958 1
	int error = 0, rdonly, for_ret = 1, aft_ret = 1, cnt;
d2963 3
d3018 1
a3018 1
	int error = 0, rdonly, getret = 1;
d3029 3
d3096 1
a3096 1
	int error = 0, rdonly, getret = 1, pref;
d3105 3
d3167 1
a3167 1
	int error = 0, rdonly, getret = 1;
d3177 3
d3232 1
a3232 1
	int error = NFSERR_RETVOID;
d3253 1
a3253 1
	int error;
@


1.27
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.26 2001/07/26 20:24:47 millert Exp $	*/
a1665 2
		if (vp->v_flag & VTEXT)
			uvm_vnp_uncache(vp);
d3277 2
a3278 3
		 * If there's shared text associated with
		 * the inode, try to free it up once.  If
		 * we fail, we can't allow writing.
d3280 1
a3280 1
		if ((vp->v_flag & VTEXT) && !uvm_vnp_uncache(vp))
@


1.26
log
@Back out changes to symlink and mknod that were not well tested.
A simple mknod at causes a kernel panic (uvm_fault).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.24 2001/07/06 21:51:13 niklas Exp $	*/
d77 1
a77 1
#include <vm/vm.h>
@


1.25
log
@change vop_symlink and vop_mknod to return vpp (the created node)
refed, so that the caller can actually use it.  update callers and
file systems that implement these vnode operations

ok'd by art
@
text
@d1365 10
d1557 5
d1563 2
d2055 16
a2070 8
		    bzero((caddr_t)fhp, sizeof(nfh));
		    fhp->fh_fsid = nd.ni_vp->v_mount->mnt_stat.f_fsid;
		    error = VFS_VPTOFH(nd.ni_vp, &fhp->fh_fid);
		    if (!error)
			    error = VOP_GETATTR(nd.ni_vp, &va, cred,
						procp);
		    vput(nd.ni_vp);
	    } else {
a2071 2
		vput(nd.ni_vp);
	    }
@


1.24
log
@From NetBSD; Server could lose requests during write-gathering, causing client
hangs.  Fixes the old typical pwd_mkdb waiting on getblk hang during
make release over NFS.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.23 2001/06/27 04:58:46 art Exp $	*/
a1364 10
			nd.ni_cnd.cn_nameiop = LOOKUP;
			nd.ni_cnd.cn_flags &= ~(LOCKPARENT | SAVESTART);
			nd.ni_cnd.cn_proc = procp;
			nd.ni_cnd.cn_cred = cred;
			if ((error = lookup(&nd)) != 0) {
				free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
				nfsm_reply(0);
				return (0);
			}
			
a1546 5
		nd.ni_cnd.cn_nameiop = LOOKUP;
		nd.ni_cnd.cn_flags &= ~(LOCKPARENT | SAVESTART);
		nd.ni_cnd.cn_proc = procp;
		nd.ni_cnd.cn_cred = procp->p_ucred;
		error = lookup(&nd);
a1547 2
		if (error)
			goto out;
d2038 8
a2045 16
		nd.ni_cnd.cn_nameiop = LOOKUP;
		nd.ni_cnd.cn_flags &= ~(LOCKPARENT | SAVESTART | FOLLOW);
		nd.ni_cnd.cn_flags |= (NOFOLLOW | LOCKLEAF);
		nd.ni_cnd.cn_proc = procp;
		nd.ni_cnd.cn_cred = cred;
		error = lookup(&nd);
		if (!error) {
			bzero((caddr_t)fhp, sizeof(nfh));
			fhp->fh_fsid = nd.ni_vp->v_mount->mnt_stat.f_fsid;
			error = VFS_VPTOFH(nd.ni_vp, &fhp->fh_fid);
			if (!error)
				error = VOP_GETATTR(nd.ni_vp, &va, cred,
					procp);
			vput(nd.ni_vp);
		}
	    } else
d2047 2
@


1.23
log
@Remove old vm.
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_serv.c,v 1.22 2001/06/25 03:28:08 csapuntz Exp $	*/
/*	$NetBSD: nfs_serv.c,v 1.25 1996/03/02 15:55:52 jtk Exp $	*/
d1205 13
@


1.22
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.21 2001/03/25 08:26:17 csapuntz Exp $	*/
a1653 1
#if defined(UVM)
a1654 3
#else
			(void) vnode_pager_uncache(vp);
#endif
a3269 1
#if defined(UVM)
a3270 3
#else
		if ((vp->v_flag & VTEXT) && !vnode_pager_uncache(vp))
#endif
@


1.21
log
@

Fix v3 double-free, potential mrep double-free. Thanks to dawson and Team for
finding these

Found a potential vnode leak in there too.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.20 1999/03/15 15:58:09 deraadt Exp $	*/
a83 1
#include <nfs/nqnfs.h>
a194 1
	nqsrv_getl(vp, ND_READ);
a286 1
	nqsrv_getl(vp, ND_WRITE);
a383 1
	nqsrv_getl(nd.ni_startdir, ND_READ);
a485 1
	nqsrv_getl(vp, ND_READ);
a567 1
	    nqsrv_getl(vp, ND_READ);
a781 1
		nqsrv_getl(vp, ND_WRITE);
a1045 1
		    nqsrv_getl(vp, ND_WRITE);
a1317 1
			nqsrv_getl(nd.ni_dvp, ND_WRITE);
a1343 1
			nqsrv_getl(nd.ni_dvp, ND_WRITE);
a1391 1
				nqsrv_getl(vp, ND_WRITE);
a1526 1
		nqsrv_getl(nd.ni_dvp, ND_WRITE);
a1538 1
		nqsrv_getl(nd.ni_dvp, ND_WRITE);
a1660 2
			nqsrv_getl(nd.ni_dvp, ND_WRITE);
			nqsrv_getl(vp, ND_WRITE);
a1807 4
		nqsrv_getl(fromnd.ni_dvp, ND_WRITE);
		nqsrv_getl(tdvp, ND_WRITE);
		if (tvp)
			nqsrv_getl(tvp, ND_WRITE);
a1931 2
		nqsrv_getl(vp, ND_WRITE);
		nqsrv_getl(xp, ND_WRITE);
a2040 1
	nqsrv_getl(nd.ni_dvp, ND_WRITE);
a2172 1
	nqsrv_getl(nd.ni_dvp, ND_WRITE);
a2284 2
		nqsrv_getl(nd.ni_dvp, ND_WRITE);
		nqsrv_getl(vp, ND_WRITE);
a2403 1
	nqsrv_getl(vp, ND_READ);
a2670 1
		nqsrv_getl(vp, ND_READ);
@


1.20
log
@do not call nfsm_adj() with negative values; dm
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.19 1999/02/26 03:16:25 art Exp $	*/
d959 1
a960 1
		m_freem(mrep);
d1350 1
a1350 1
				return (error);
d1358 1
d1360 1
d1369 1
d1371 1
d1379 1
@


1.20.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.21 2001/03/25 08:26:17 csapuntz Exp $	*/
d959 1
a960 1
nfsmout:
d1350 1
a1350 1
				return (0);
a1357 1
				free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
a1358 1
				return (0);
a1366 1
				return (0);
a1367 1
			
a1374 1
				return (0);
@


1.20.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.20.6.1 2001/05/14 22:44:57 niklas Exp $	*/
d84 1
d196 1
d289 1
d387 1
d490 1
d573 1
d788 1
d1053 1
d1326 1
d1353 1
d1402 1
d1538 1
d1551 1
d1667 1
d1669 3
d1674 2
d1823 4
d1951 2
d2062 1
d2195 1
d2308 2
d2429 1
d2697 1
d3301 1
d3303 3
@


1.20.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_serv.c,v 1.20.6.2 2001/07/04 10:55:47 niklas Exp $	*/
/*     $NetBSD: nfs_serv.c,v 1.34 1997/05/12 23:37:12 fvdl Exp $       */
a1204 13

	/*
	 * nfsd might hold coalesce elements! Move them to owp.
	 * Otherwise, requests may be lost and clients will be stuck.
	 */
	if (LIST_FIRST(&nfsd->nd_coalesce) != NULL) {
		struct nfsrv_descript *m;

		while ((m = LIST_FIRST(&nfsd->nd_coalesce)) != NULL) {
			LIST_REMOVE(m, nd_tq);
			LIST_INSERT_HEAD(&owp->nd_coalesce, m, nd_tq);
		}
	}
@


1.20.6.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 1
a77 1
#include <uvm/uvm_extern.h>
@


1.20.6.5
log
@Merge in -current
@
text
@d1666 2
d3279 3
a3281 2
		 * If the vnode is in use as a process's text,
		 * we can't allow writing.
d3283 1
a3283 1
		if ((vp->v_flag & VTEXT))
@


1.20.6.6
log
@Merge in trunk
@
text
@d112 2
a113 2
	u_int32_t *tl;
	int32_t t1;
d174 1
a174 1
	struct nfs_fattr *fp;
d179 2
a180 2
	u_int32_t *tl;
	int32_t t1;
d220 2
a221 2
	struct nfsv2_sattr *sp;
	struct nfs_fattr *fp;
d225 2
a226 2
	u_int32_t *tl;
	int32_t t1;
d349 1
a349 1
	struct nfs_fattr *fp;
d354 3
a356 3
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1;
d424 4
a427 4
	struct iovec *ivp = iv;
	struct mbuf *mp;
	u_int32_t *tl;
	int32_t t1;
d523 1
a523 1
	struct iovec *iv;
d525 5
a529 5
	struct mbuf *m;
	struct nfs_fattr *fp;
	u_int32_t *tl;
	int32_t t1;
	int i;
d689 4
a692 4
	struct iovec *ivp;
	int i, cnt;
	struct mbuf *mp;
	struct nfs_fattr *fp;
d695 2
a696 2
	u_int32_t *tl;
	int32_t t1;
d872 5
a876 5
	struct iovec *ivp;
	struct mbuf *mp;
	struct nfsrv_descript *wp, *nfsd, *owp, *swp;
	struct nfs_fattr *fp;
	int i = 0;
d881 2
a882 2
	u_int32_t *tl;
	int32_t t1;
d968 1
a968 1
	    wp = LIST_FIRST(&slp->ns_tq);
d971 1
a971 1
		wp = LIST_NEXT(wp, nd_tq);
d981 1
a981 1
		wp = LIST_FIRST(wpp);
d985 1
a985 1
		    wp = LIST_NEXT(wp, nd_hash);
d988 1
a988 1
		   !bcmp((caddr_t)&nfsd->nd_fh,(caddr_t)&wp->nd_fh,NFSX_V3FH)) {
d990 1
a990 1
		    wp = LIST_NEXT(wp, nd_hash);
d1000 1
a1000 1
			wp = LIST_NEXT(nfsd, nd_hash);
d1018 2
a1019 2
	for (nfsd = LIST_FIRST(&slp->ns_tq); nfsd != NULL; nfsd = owp) {
		owp = LIST_NEXT(nfsd, nd_tq);
d1138 1
a1138 1
		    nfsd = LIST_FIRST(&swp->nd_coalesce);
d1156 1
a1156 2
	for (nfsd = LIST_FIRST(&slp->ns_tq); nfsd != NULL;
	    nfsd = LIST_NEXT(nfsd, nd_tq)) {
a1162 1
	}
d1177 2
a1178 2
        struct nfsrv_descript *owp;
        struct nfsrv_descript *nfsd;
d1180 2
a1181 2
        int overlap;
        struct mbuf *mp;
d1235 1
a1235 1
	struct nfs_fattr *fp;
d1237 2
a1238 2
	struct nfsv2_sattr *sp;
	u_int32_t *tl;
d1240 2
a1241 2
	caddr_t cp;
	int32_t t1;
d1475 1
a1475 1
	u_int32_t *tl;
d1477 1
a1477 1
	int32_t t1;
d1623 2
a1624 2
	u_int32_t *tl;
	int32_t t1;
a1665 2
		if (vp->v_flag & VTEXT)
			uvm_vnp_uncache(vp);
d1704 2
a1705 2
	u_int32_t *tl;
	int32_t t1;
d1885 2
a1886 2
	u_int32_t *tl;
	int32_t t1;
d1982 2
a1983 2
	u_int32_t *tl;
	int32_t t1;
d2122 1
a2122 1
	struct nfs_fattr *fp;
d2124 3
a2126 3
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1;
d2235 2
a2236 2
	u_int32_t *tl;
	int32_t t1;
d2364 6
a2369 6
	char *bp, *be;
	struct mbuf *mp;
	struct dirent *dp;
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1;
d2625 6
a2630 6
	char *bp, *be;
	struct mbuf *mp;
	struct dirent *dp;
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1;
d2926 2
a2927 2
	u_int32_t *tl;
	int32_t t1;
d2984 4
a2987 4
	struct statfs *sf;
	struct nfs_statfs *sfp;
	u_int32_t *tl;
	int32_t t1;
d3063 3
a3065 3
	u_int32_t *tl;
	struct nfsv3_fsinfo *sip;
	int32_t t1;
d3134 3
a3136 3
	u_int32_t *tl;
	struct nfsv3_pathconf *pc;
	int32_t t1;
d3249 1
a3249 1
	struct vnode *vp;
d3251 1
a3251 1
	struct ucred *cred;
d3277 2
a3278 3
		 * If there's shared text associated with
		 * the inode, try to free it up once.  If
		 * we fail, we can't allow writing.
d3280 1
a3280 1
		if ((vp->v_flag & VTEXT) && !uvm_vnp_uncache(vp))
@


1.20.6.7
log
@Sync the SMP branch with 3.3
@
text
@d115 1
a115 1
	int error = 0, rdonly, getret;
d182 1
a182 1
	int error = 0, rdonly;
d228 1
a228 1
	int error = 0, rdonly, preat_ret = 1, postat_ret = 1;
d358 1
a358 1
	int error = 0, len, dirattr_ret = 1;
d429 1
a429 1
	int error = 0, rdonly, i, tlen, len, getret;
d531 1
a531 1
	int error = 0, rdonly, cnt, len, left, siz, tlen, getret;
d698 1
a698 1
	int error = 0, rdonly, len, forat_ret = 1;
d884 1
a884 1
	int error = 0, rdonly, len = 0, forat_ret = 1;
d1178 3
a1180 1
nfsrvw_coalesce(struct nfsrv_descript *owp, struct nfsrv_descript *nfsd)
a1184 2
	splassert(IPL_SOFTCLOCK);

d1245 1
a1245 1
	int error = 0, len, tsize, dirfor_ret = 1, diraft_ret = 1;
d1481 1
a1481 1
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
d1628 1
a1628 1
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
d1711 1
a1711 1
	int error = 0, len, len2, fdirfor_ret = 1, fdiraft_ret = 1;
d1892 1
a1892 1
	int error = 0, rdonly, len, dirfor_ret = 1, diraft_ret = 1;
d1992 1
a1992 1
	int error = 0, len, len2, dirfor_ret = 1, diraft_ret = 1;
d2132 1
a2132 1
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
d2242 1
a2242 1
	int error = 0, len, dirfor_ret = 1, diraft_ret = 1;
d2384 1
a2384 1
	int siz, cnt, fullsiz, eofflag, rdonly, ncookies;
a2406 2
	if (cnt > xfer)
		cnt = xfer;
d2647 1
a2647 1
	int siz, cnt, fullsiz, eofflag, rdonly, dirlen, ncookies;
a2664 2
	if (cnt > xfer)
		cnt = xfer;
a2775 12
	/*
	 * struct READDIRPLUS3resok {
	 *     postop_attr dir_attributes;
	 *     cookieverf3 cookieverf;
	 *     dirlistplus3 reply;
	 * }
	 *
	 * struct dirlistplus3 {
	 *     entryplus3  *entries;
	 *     bool eof;
	 *  }
	 */	
a2814 11
			 *
			 * Each entry:
			 * 2 * NFSX_UNSIGNED for fileid3
			 * 1 * NFSX_UNSIGNED for length of name
			 * nlen + rem == space the name takes up
			 * 2 * NFSX_UNSIGNED for the cookie
			 * 1 * NFSX_UNSIGNED to indicate if file handle present
			 * 1 * NFSX_UNSIGNED for the file handle length
			 * NFSX_V3FH == space our file handle takes up
			 * NFSX_V3POSTOPATTR == space the attributes take up
			 * 1 * NFSX_UNSIGNED for next pointer
d2816 1
a2816 1
			len += (8 * NFSX_UNSIGNED + nlen + rem + NFSX_V3FH +
d2933 1
a2933 1
	int error = 0, rdonly, for_ret = 1, aft_ret = 1, cnt;
d2938 3
d2993 1
a2993 1
	int error = 0, rdonly, getret = 1;
d3004 3
d3071 1
a3071 1
	int error = 0, rdonly, getret = 1, pref;
d3080 3
d3142 1
a3142 1
	int error = 0, rdonly, getret = 1;
d3152 3
d3207 1
a3207 1
	int error = NFSERR_RETVOID;
d3228 1
a3228 1
	int error;
@


1.20.6.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.20.6.7 2003/03/28 00:08:46 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.20.6.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1346 1
a1346 1
			    (error = suser_ucred(cred))) {
d1543 1
a1543 1
		    (error = suser_ucred(cred))) {
d1655 1
a1655 1
		    (error = suser_ucred(cred)) != 0)
d1911 1
a1911 1
	if (vp->v_type == VDIR && (error = suser_ucred(cred)) != 0)
@


1.20.6.10
log
@Merge with the trunk
@
text
@a70 1
#include <sys/pool.h>
d381 1
a381 1
	pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1331 1
a1331 1
				pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1348 1
a1348 1
				pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1359 1
a1359 1
				pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1368 1
a1368 1
				pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1373 1
a1373 1
			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1384 1
a1384 1
			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1392 1
a1392 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1446 1
a1446 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1509 1
a1509 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1529 1
a1529 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1540 1
a1540 1
			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1545 1
a1545 1
			pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1560 1
a1560 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1594 1
a1594 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d1832 1
a1832 1
	pool_put(&namei_pool, tond.ni_cnd.cn_pnbuf);
d1843 1
a1843 1
	pool_put(&namei_pool, fromnd.ni_cnd.cn_pnbuf);
d1858 1
a1858 1
		pool_put(&namei_pool, tond.ni_cnd.cn_pnbuf);
d1862 1
a1862 1
		pool_put(&namei_pool, fromnd.ni_cnd.cn_pnbuf);
d2038 1
a2038 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d2070 1
a2070 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
d2091 1
a2091 1
		pool_put(&namei_pool, nd.ni_cnd.cn_pnbuf);
@


1.19
log
@compatibility with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.18 1999/02/06 23:07:42 millert Exp $	*/
d589 1
a589 1
		cnt = nfsm_rndup(va.va_size - off);
d603 1
a603 1
	len = left = cnt;
d628 1
a628 1
		left = cnt;
d646 1
a646 1
		uiop->uio_resid = cnt;
d665 5
a669 4
	len -= uiop->uio_resid;
	tlen = nfsm_rndup(len);
	if (cnt != tlen || tlen != len)
		nfsm_adj(mb, cnt - tlen, tlen - len);
d671 1
a671 1
		*tl++ = txdr_unsigned(len);
d677 1
a677 1
	*tl = txdr_unsigned(len);
@


1.18
log
@Use bitwise operations to extract high and low words from the quad
in txdr_hyper.  This should be more portable than casting to an array
of ints and pulling out the two 32-bit words (this produced incorrect
results on alpha for the high word for filesystems < 4gig).  As a side
effect, txdr_hyper now takes a u_quad_t as its first arg, not u_quad_t *.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.17 1999/02/01 17:44:17 millert Exp $	*/
d1661 3
d1665 1
d3295 3
d3299 1
@


1.17
log
@non-root users can mkfifo over NFS; mrg@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.16 1998/08/19 22:26:52 csapuntz Exp $	*/
d2493 1
a2493 1
				txdr_hyper(&at.va_filerev, tl);
d2532 1
a2532 1
		txdr_hyper(&at.va_filerev, tl);
d2750 1
a2750 1
			txdr_hyper(&at.va_filerev, tl);
d2786 1
a2786 1
	txdr_hyper(&at.va_filerev, tl);
d3035 1
a3035 1
		txdr_hyper(&tval, &sfp->sf_tbytes);
d3038 1
a3038 1
		txdr_hyper(&tval, &sfp->sf_fbytes);
d3041 1
a3041 1
		txdr_hyper(&tval, &sfp->sf_abytes);
@


1.16
log
@

Change fxdr_hyper to return a u_quad_t. This minimizes the evil clobbering
of lvalues that ANSI abhors.

And it fixes df on NFS version 3 mounts on Sparcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.15 1998/02/22 01:21:31 niklas Exp $	*/
d1342 2
a1343 2
			error = suser(cred, (u_short *)0);
			if (error) {
d1537 2
a1538 2
		error = suser(cred, (u_short *)0);
		if (error) {
@


1.15
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.14 1997/11/06 05:59:02 csapuntz Exp $	*/
d553 1
a553 1
		fxdr_hyper(tl, &off);
d724 1
a724 1
		fxdr_hyper(tl, &off);
d919 1
a919 1
		fxdr_hyper(tl, &nfsd->nd_off);
d2397 1
a2397 1
		fxdr_hyper(tl, &toff);
d2399 1
a2399 1
		fxdr_hyper(tl, &verf);
d2659 1
a2659 1
	fxdr_hyper(tl, &toff);
d2661 1
a2661 1
	fxdr_hyper(tl, &verf);
d2955 1
a2955 1
	fxdr_hyper(tl, &off);
@


1.14
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.13 1997/10/06 20:20:47 deraadt Exp $	*/
d1780 1
a1780 4
			if (v3)
				error = EEXIST;
			else
				error = EISDIR;
d1783 1
a1783 4
			if (v3)
				error = EEXIST;
			else
				error = ENOTDIR;
d1787 1
a1787 4
			if (v3)
				error = EXDEV;
			else
				error = ENOTEMPTY;
d1792 1
a1792 4
		if (v3)
			error = EXDEV;
		else
			error = ENOTEMPTY;
d1796 1
a1796 4
		if (v3)
			error = EXDEV;
		else
			error = ENOTEMPTY;
d1800 1
a1800 4
		if (v3)
			error = EINVAL;
		else
			error = ENOTEMPTY;
@


1.13
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.11 1997/04/18 09:22:45 deraadt Exp $	*/
a2455 1
#ifdef Lite2_integrated
a2456 3
#else
	VOP_UNLOCK(vp);
#endif
a2457 3
	ncookies = siz / (5 * NFSX_UNSIGNED); /*7 for V3, but it's an est. so*/
	MALLOC(cookies, u_long *, ncookies * sizeof (u_long *), M_TEMP,
		M_WAITOK);
a2468 5
#ifdef Lite2_integrated
	VOP_LOCK(vp, 0, procp);
#else
	VOP_LOCK(vp);
#endif
d2470 7
a2476 1
	error = VOP_READDIR(vp, &io, cred, &eofflag, cookies, ncookies);
a2486 1
#ifdef Lite2_integrated
a2487 3
#else
	VOP_UNLOCK(vp);
#endif
a2713 1
#ifdef Lite2_integrated
a2714 3
#else
	VOP_UNLOCK(vp);
#endif
a2716 3
	ncookies = siz / (7 * NFSX_UNSIGNED);
	MALLOC(cookies, u_long *, ncookies * sizeof (u_long *), M_TEMP,
		M_WAITOK);
d2729 7
a2735 6
#ifdef Lite2_integrated
	VOP_LOCK(vp, 0, procp);
#else
	VOP_LOCK(vp);
#endif
	error = VOP_READDIR(vp, &io, cred, &eofflag, cookies, ncookies);
a2739 1
#ifdef Lite2_integrated
d2741 1
a2741 3
#else
	VOP_UNLOCK(vp);
#endif
@


1.12
log
@VFS Lite2 Changes
@
text
@d2456 1
d2458 3
d2462 3
d2476 5
d2482 1
a2482 7
	if (cookies) {
		free((caddr_t)cookies, M_TEMP);
		cookies = NULL;
	}

	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, procp);
	error = VOP_READDIR(vp, &io, cred, &eofflag, &ncookies, &cookies);
d2493 1
d2495 3
d2724 1
d2726 3
d2731 3
d2746 6
a2751 7
	if (cookies) {
		free((caddr_t)cookies, M_TEMP);
		cookies = NULL;
	}

	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, procp);
	error = VOP_READDIR(vp, &io, cred, &eofflag, &ncookies, &cookies);
d2756 1
d2758 3
a2760 1

@


1.11
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.10 1997/01/31 10:30:48 deraadt Exp $	*/
a2455 1
#ifdef Lite2_integrated
a2456 3
#else
	VOP_UNLOCK(vp);
#endif
a2457 3
	ncookies = siz / (5 * NFSX_UNSIGNED); /*7 for V3, but it's an est. so*/
	MALLOC(cookies, u_long *, ncookies * sizeof (u_long *), M_TEMP,
		M_WAITOK);
a2468 5
#ifdef Lite2_integrated
	VOP_LOCK(vp, 0, procp);
#else
	VOP_LOCK(vp);
#endif
d2470 7
a2476 1
	error = VOP_READDIR(vp, &io, cred, &eofflag, cookies, ncookies);
a2486 1
#ifdef Lite2_integrated
a2487 3
#else
	VOP_UNLOCK(vp);
#endif
a2713 1
#ifdef Lite2_integrated
a2714 3
#else
	VOP_UNLOCK(vp);
#endif
a2716 3
	ncookies = siz / (7 * NFSX_UNSIGNED);
	MALLOC(cookies, u_long *, ncookies * sizeof (u_long *), M_TEMP,
		M_WAITOK);
d2729 7
a2735 6
#ifdef Lite2_integrated
	VOP_LOCK(vp, 0, procp);
#else
	VOP_LOCK(vp);
#endif
	error = VOP_READDIR(vp, &io, cred, &eofflag, cookies, ncookies);
a2739 1
#ifdef Lite2_integrated
d2741 1
a2741 3
#else
	VOP_UNLOCK(vp);
#endif
@


1.10
log
@do not walk off the end of a directory info buffer; netbsd pr#3170, mhitch@@gemini.oscs.montana.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.9 1997/01/28 18:50:21 niklas Exp $	*/
d2806 2
a2807 2
	while (cpos < cend && ncookies > 0
	       && (dp->d_fileno == 0 || dp->d_type == DT_WHT)) {
@


1.9
log
@Put back lost VOP_GETATTR call, but in a better place
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.8 1996/12/14 15:36:50 deraadt Exp $	*/
d2806 2
a2807 2
	while ((dp->d_fileno == 0 || dp->d_type == DT_WHT)
	       && cpos < cend && ncookies > 0) {
@


1.8
log
@better nfsrv_access() control, from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.7 1996/11/08 23:20:14 niklas Exp $	*/
d3305 1
d3337 1
@


1.7
log
@Rearrange condition so invalid dereferences can't happen
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.6 1996/04/21 22:30:23 deraadt Exp $	*/
d135 1
a135 1
		nfsrv_access(vp, VREAD, cred, rdonly, procp))
d143 1
a143 1
		nfsrv_access(vp, VWRITE, cred, rdonly, procp))
d150 1
a150 1
		nfsrv_access(vp, VEXEC, cred, rdonly, procp))
d318 1
a318 1
			procp)) != 0)
d574 2
a575 2
	    if ((error = nfsrv_access(vp, VREAD, cred, rdonly, procp)) != 0)
		error = nfsrv_access(vp, VEXEC, cred, rdonly, procp);
d788 1
a788 1
		error = nfsrv_access(vp, VWRITE, cred, rdonly, procp);
d1053 1
a1053 1
		    error = nfsrv_access(vp, VWRITE, cred, rdonly, procp);
d1394 1
a1394 1
			    (nd.ni_cnd.cn_flags & RDONLY), procp);
d2449 1
a2449 1
		error = nfsrv_access(vp, VEXEC, cred, rdonly, procp);
d2716 1
a2716 1
		error = nfsrv_access(vp, VEXEC, cred, rdonly, procp);
d3288 5
a3292 4
 * 2 - The owner is to be given access irrespective of mode bits so that
 *     processes that chmod after opening a file don't break. I don't like
 *     this because it opens a security hole, but since the nfs server opens
 *     a security hole the size of a barn door anyhow, what the heck.
d3295 1
a3295 1
nfsrv_access(vp, flags, cred, rdonly, p)
d3301 1
d3330 9
a3338 7
	error = VOP_GETATTR(vp, &vattr, cred, p);
	if (error)
		return (error);
	if ((error = VOP_ACCESS(vp, flags, cred, p)) != 0 &&
	    cred->cr_uid != vattr.va_uid)
		return (error);
	return (0);
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.5 1996/04/17 04:50:27 mickey Exp $	*/
d2542 2
a2543 2
	while ((dp->d_fileno == 0 || dp->d_type == DT_WHT) &&
	       cpos < cend && ncookies > 0) {
@


1.5
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.4 1996/03/31 13:15:41 mickey Exp $	*/
d130 1
a130 1
		nfsm_srvpostop_attr(1, (struct vattr *)NULL);
d474 1
a474 1
	uiop->uio_procp = (struct proc *)NULL;
d480 1
a480 1
		nfsm_srvpostop_attr(1, (struct vattr *)NULL);
d563 1
a563 1
		nfsm_srvpostop_attr(1, (struct vattr *)NULL);
d828 1
a828 1
	    uiop->uio_procp = (struct proc *)NULL;
d1064 1
a1064 1
		uiop->uio_procp = (struct proc *)NULL;
d1263 1
a1263 1
			dirp = (struct vnode *)NULL;
d1342 2
a1343 1
			if ((error = suser(cred, NULL)) != 0) {
d1476 1
a1476 1
	struct vnode *vp, *dirp = NULL;
d1537 2
a1538 1
		if ((error = suser(cred, NULL)) != 0) {
d1624 1
a1624 1
	struct vnode *vp = NULL, *dirp;
d1630 3
d1651 1
a1651 1
		    (error = suser(cred, NULL)) != 0)
d1741 1
a1741 1
			fdirp = (struct vnode *)NULL;
d1767 1
a1767 1
			tdirp = (struct vnode *)NULL;
d1912 1
a1912 1
	struct vnode *vp, *xp, *dirp = NULL;
d1931 1
a1931 1
	if (vp->v_type == VDIR && (error = suser(cred, NULL)) != 0)
d1944 1
a1944 1
			dirp = (struct vnode *)NULL;
d2013 1
a2013 1
	struct vnode *dirp = NULL;
d2033 1
a2033 1
			dirp = (struct vnode *)NULL;
d2051 1
a2051 1
	io.uio_procp = (struct proc *)NULL;
d2155 1
a2155 1
	struct vnode *vp, *dirp = NULL;
d2174 1
a2174 1
			dirp = (struct vnode *)NULL;
d2266 1
a2266 1
	struct vnode *vp, *dirp = (struct vnode *)NULL;
d2287 1
a2287 1
			dirp = (struct vnode *)NULL;
d2474 1
a2474 1
	io.uio_procp = (struct proc *)NULL;
d2743 1
a2743 1
	io.uio_procp = (struct proc *)NULL;
@


1.4
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_serv.c,v 1.3 1996/02/29 09:24:52 niklas Exp $	*/
d130 1
a130 1
		nfsm_srvpostop_attr(1, (struct vattr *)0);
d474 1
a474 1
	uiop->uio_procp = (struct proc *)0;
d480 1
a480 1
		nfsm_srvpostop_attr(1, (struct vattr *)0);
d563 1
a563 1
		nfsm_srvpostop_attr(1, (struct vattr *)0);
d828 1
a828 1
	    uiop->uio_procp = (struct proc *)0;
d1064 1
a1064 1
		uiop->uio_procp = (struct proc *)0;
d1238 1
a1238 1
	int rdev = 0;
d1263 1
a1263 1
			dirp = (struct vnode *)0;
d1310 1
a1310 1
			rdev = fxdr_unsigned(int32_t, sp->sa_size);
d1342 1
a1342 2
			error = suser(cred, (u_short *)0);
			if (error) {
d1475 1
a1475 1
	struct vnode *vp, *dirp = (struct vnode *)0;
d1536 1
a1536 2
		error = suser(cred, (u_short *)0);
		if (error) {
d1622 1
a1622 1
	struct vnode *vp, *dirp;
a1627 3
#ifndef nolint
	vp = (struct vnode *)0;
#endif
d1646 1
a1646 1
		    (error = suser(cred, (u_short *)0)) != 0)
d1706 2
a1707 2
	struct vnode *fvp, *tvp, *tdvp, *fdirp = (struct vnode *)0;
	struct vnode *tdirp = (struct vnode *)0;
a1713 3
#ifndef nolint
	fvp = (struct vnode *)0;
#endif
d1736 1
a1736 1
			fdirp = (struct vnode *)0;
d1762 1
a1762 1
			tdirp = (struct vnode *)0;
d1907 1
a1907 1
	struct vnode *vp, *xp, *dirp = (struct vnode *)0;
d1926 1
a1926 1
	if (vp->v_type == VDIR && (error = suser(cred, (u_short *)0)) != 0)
d1939 1
a1939 1
			dirp = (struct vnode *)0;
d2008 1
a2008 1
	struct vnode *dirp = (struct vnode *)0;
d2028 1
a2028 1
			dirp = (struct vnode *)0;
d2046 1
a2046 1
	io.uio_procp = (struct proc *)0;
d2150 1
a2150 1
	struct vnode *vp, *dirp = (struct vnode *)0;
d2169 1
a2169 1
			dirp = (struct vnode *)0;
d2261 1
a2261 1
	struct vnode *vp, *dirp = (struct vnode *)0;
d2282 1
a2282 1
			dirp = (struct vnode *)0;
d2469 1
a2469 1
	io.uio_procp = (struct proc *)0;
d2738 1
a2738 1
	io.uio_procp = (struct proc *)0;
@


1.3
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_serv.c,v 1.22 1996/02/09 21:48:27 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfs_serv.c	8.4 (Berkeley) 6/4/94
d43 1
a43 1
 * nfs version 2 server calls to vnode ops
d58 2
d69 2
d74 2
d79 1
a79 1
#include <nfs/nfsv2.h>
a86 4
/* Defs */
#define	TRUE	1
#define	FALSE	0

a87 1
extern u_long nfs_procids[NFS_NPROCS];
d90 5
a94 2
nfstype nfs_type[9] = { NFNON, NFREG, NFDIR, NFBLK, NFCHR, NFLNK, NFNON,
		      NFCHR, NFNON };
d97 1
a97 1
 * nqnfs access service
d100 5
a104 6
nqnfsrv_access(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d106 4
d111 1
a111 1
	nfsv2fh_t nfh;
d116 1
a116 1
	int error = 0, rdonly, cache = 0, mode = 0;
d118 3
a120 1
	struct mbuf *mb, *mreq;
d125 28
a152 11
	nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
		nfsm_reply(0);
	if (*tl++ == nfs_true)
		mode |= VREAD;
	if (*tl++ == nfs_true)
		mode |= VWRITE;
	if (*tl == nfs_true)
		mode |= VEXEC;
	error = nfsrv_access(vp, mode, cred, rdonly, nfsd->nd_procp);
d154 4
a157 1
	nfsm_reply(0);
d165 5
a169 6
nfsrv_getattr(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d171 5
a175 1
	register struct nfsv2_fattr *fp;
d178 1
a178 1
	nfsv2fh_t nfh;
d190 3
a192 2
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
d194 4
a197 2
	nqsrv_getl(vp, NQL_READ);
	error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp);
d199 5
a203 3
	nfsm_reply(NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_build(fp, struct nfsv2_fattr *, NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_srvfillattr;
d211 5
a215 6
nfsrv_setattr(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d217 5
a221 1
	struct vattr va;
d223 1
a223 1
	register struct nfsv2_fattr *fp;
d225 1
a225 1
	nfsv2fh_t nfh;
d230 2
a231 1
	int error = 0, rdonly, cache;
d234 2
a235 1
	u_quad_t frev, frev2;
a238 6
	nfsm_dissect(sp, struct nfsv2_sattr *,
		     NFSX_SATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
		nfsm_reply(0);
	nqsrv_getl(vp, NQL_WRITE);
d240 26
a265 17
	/*
	 * Nah nah nah nah na nah
	 * There is a bug in the Sun client that puts 0xffff in the mode
	 * field of sattr when it should put in 0xffffffff. The u_short
	 * doesn't sign extend.
	 * --> check the low order 2 bytes for 0xffff
	 */
	if ((fxdr_unsigned(int, sp->sa_mode) & 0xffff) != 0xffff)
		va.va_mode = nfstov_mode(sp->sa_mode);
	if (sp->sa_uid != nfs_xdrneg1)
		va.va_uid = fxdr_unsigned(uid_t, sp->sa_uid);
	if (sp->sa_gid != nfs_xdrneg1)
		va.va_gid = fxdr_unsigned(gid_t, sp->sa_gid);
	if (nfsd->nd_nqlflag == NQL_NOVAL) {
		if (sp->sa_nfssize != nfs_xdrneg1)
			va.va_size = fxdr_unsigned(u_quad_t, sp->sa_nfssize);
		if (sp->sa_nfsatime.nfs_sec != nfs_xdrneg1) {
d267 1
a267 1
			fxdr_nfstime(&sp->sa_nfsatime, &va.va_atime);
d270 1
a270 1
				fxdr_unsigned(int32_t, sp->sa_nfsatime.nfs_sec);
d274 28
a301 7
		if (sp->sa_nfsmtime.nfs_sec != nfs_xdrneg1)
			fxdr_nfstime(&sp->sa_nfsmtime, &va.va_mtime);
	} else {
		fxdr_hyper(&sp->sa_nqsize, &va.va_size);
		fxdr_nqtime(&sp->sa_nqatime, &va.va_atime);
		fxdr_nqtime(&sp->sa_nqmtime, &va.va_mtime);
		va.va_flags = fxdr_unsigned(u_int32_t, sp->sa_nqflags);
d318 1
a318 1
						 nfsd->nd_procp)) != 0)
d321 4
a324 5
	if ((error = VOP_SETATTR(vp, &va, cred, nfsd->nd_procp)) != 0) {
		vput(vp);
		nfsm_reply(0);
	}
	error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp);
d327 7
a333 6
	nfsm_reply(NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL) + 2*NFSX_UNSIGNED);
	nfsm_build(fp, struct nfsv2_fattr *, NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_srvfillattr;
	if (nfsd->nd_nqlflag != NQL_NOVAL) {
		nfsm_build(tl, u_int32_t *, 2*NFSX_UNSIGNED);
		txdr_hyper(&frev2, tl);
d342 5
a346 6
nfsrv_lookup(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d348 5
a352 1
	register struct nfsv2_fattr *fp;
d354 2
a355 2
	struct vnode *vp;
	nfsv2fh_t nfh;
d361 2
a362 1
	int error = 0, cache, duration2, cache2, len;
d365 2
a366 2
	struct vattr va;
	u_quad_t frev, frev2;
a368 5
	duration2 = 0;
	if (nfsd->nd_nqlflag != NQL_NOVAL) {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		duration2 = fxdr_unsigned(int, *tl);
	}
d370 1
a370 1
	nfsm_srvstrsiz(len, NFS_MAXNAMLEN);
d374 14
a387 4
	if ((error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
			       nfsd->nd_procp)) != 0)
		nfsm_reply(0);
	nqsrv_getl(nd.ni_startdir, NQL_READ);
d393 8
a400 3
	if ((error = VFS_VPTOFH(vp, &fhp->fh_fid)) != 0) {
		vput(vp);
		nfsm_reply(0);
d402 7
a408 17
	if (duration2)
		(void) nqsrv_getlease(vp, &duration2, NQL_READ, nfsd,
			nam, &cache2, &frev2, cred);
	error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp);
	vput(vp);
	nfsm_reply(NFSX_FH + NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL) + 5*NFSX_UNSIGNED);
	if (nfsd->nd_nqlflag != NQL_NOVAL) {
		if (duration2) {
			nfsm_build(tl, u_int32_t *, 5*NFSX_UNSIGNED);
			*tl++ = txdr_unsigned(NQL_READ);
			*tl++ = txdr_unsigned(cache2);
			*tl++ = txdr_unsigned(duration2);
			txdr_hyper(&frev2, tl);
		} else {
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
			*tl = 0;
		}
a409 3
	nfsm_srvfhtom(fhp);
	nfsm_build(fp, struct nfsv2_fattr *, NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_srvfillattr;
d417 5
a421 6
nfsrv_readlink(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d423 4
d433 2
a434 1
	int error = 0, rdonly, cache, i, tlen, len;
d438 2
a439 1
	nfsv2fh_t nfh;
d475 2
a476 1
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
d479 3
a481 1
		nfsm_reply(0);
d484 4
a487 1
		error = EINVAL;
d490 1
a490 1
	nqsrv_getl(vp, NQL_READ);
d493 1
d497 6
a502 1
	nfsm_reply(NFSX_UNSIGNED);
d518 5
a522 6
nfsrv_read(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d524 4
d531 1
a531 1
	register struct nfsv2_fattr *fp;
d534 1
d536 2
a537 1
	int error = 0, rdonly, cache, i, cnt, len, left, siz, tlen;
d542 1
a542 1
	nfsv2fh_t nfh;
d551 4
a554 1
	if (nfsd->nd_nqlflag == NQL_NOVAL) {
a556 3
	} else {
		nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		fxdr_hyper(tl, &off);
d558 8
a565 4
	nfsm_srvstrsiz(cnt, NFS_MAXDATA);
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
		nfsm_reply(0);
d567 4
a570 3
		error = (vp->v_type == VDIR) ? EISDIR : EACCES;
		vput(vp);
		nfsm_reply(0);
d572 8
a579 9
	nqsrv_getl(vp, NQL_READ);
	error = nfsrv_access(vp, VREAD, cred, rdonly, nfsd->nd_procp);
	if (error)
		goto out;
	error = nfsrv_access(vp, VEXEC, cred, rdonly, nfsd->nd_procp);
	if (error)
		goto out;
	error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp);

a580 1
out:
d582 3
a584 1
		nfsm_reply(0);
d588 1
a588 1
	else if ((off + cnt) > va.va_size)
d590 13
a602 3
	nfsm_reply(NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL)+NFSX_UNSIGNED+nfsm_rndup(cnt));
	nfsm_build(fp, struct nfsv2_fattr *, NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
a609 4
		MALLOC(iv, struct iovec *,
		       ((NFS_MAXDATA+MLEN-1)/MLEN) * sizeof (struct iovec),
		       M_TEMP, M_WAITOK);
		iv2 = iv;
d613 1
a613 4
				m->m_len += siz;
				iv->iov_base = bpos;
				iv->iov_len = siz;
				iv++;
a614 1
				left -= siz;
a621 1
				bpos = mtod(m, caddr_t);
d624 20
a643 1
		uiop->uio_iov = iv2;
d652 3
a654 1
		if (error || (error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp))) {
d657 3
a659 1
			nfsm_reply(0);
d664 1
a664 1
	nfsm_srvfillattr;
d668 8
a675 1
		nfsm_adj(mb, cnt-tlen, tlen-len);
d684 5
a688 6
nfsrv_write(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d690 4
d695 1
d697 3
a699 3
	register struct nfsv2_fattr *fp;
	struct iovec iv[NFS_MAXIOVEC];
	struct vattr va;
d703 4
a706 2
	int error = 0, rdonly, cache, siz, len, xfer;
	int ioflags = IO_SYNC | IO_NODELOCKED;
d710 1
a710 1
	nfsv2fh_t nfh;
d716 4
d722 7
a728 2
	nfsm_dissect(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
	if (nfsd->nd_nqlflag == NQL_NOVAL) {
a730 5
	} else {
		fxdr_hyper(tl, &off);
		tl += 2;
		if (fxdr_unsigned(u_int32_t, *tl++))
			ioflags |= IO_APPEND;
d732 38
a769 4
	len = fxdr_unsigned(int32_t, *tl);
	if (len > NFS_MAXDATA || len <= 0) {
		error = EBADRPC;
		nfsm_reply(0);
d771 6
a776 11
	if (dpos == (mtod(md, caddr_t)+md->m_len)) {
		mp = md->m_next;
		if (mp == NULL) {
			error = EBADRPC;
			nfsm_reply(0);
		}
	} else {
		mp = md;
		siz = dpos-mtod(mp, caddr_t);
		mp->m_len -= siz;
		NFSMADV(mp, siz);
d778 2
a779 3
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
		nfsm_reply(0);
d781 8
a788 3
		error = (vp->v_type == VDIR) ? EISDIR : EACCES;
		vput(vp);
		nfsm_reply(0);
a789 2
	nqsrv_getl(vp, NQL_WRITE);
	error = nfsrv_access(vp, VWRITE, cred, rdonly, nfsd->nd_procp);
d792 223
a1014 1
		nfsm_reply(0);
d1016 1
a1016 4
	uiop->uio_resid = 0;
	uiop->uio_rw = UIO_WRITE;
	uiop->uio_segflg = UIO_SYSSPACE;
	uiop->uio_procp = (struct proc *)0;
d1018 2
a1019 2
	 * Do up to NFS_MAXIOVEC mbufs of write each iteration of the
	 * loop until done.
d1021 25
a1045 10
	while (len > 0 && uiop->uio_resid == 0) {
		ivp = iv;
		siz = 0;
		uiop->uio_iov = ivp;
		uiop->uio_iovcnt = 0;
		uiop->uio_offset = off;
		while (len > 0 && uiop->uio_iovcnt < NFS_MAXIOVEC && mp != NULL) {
			ivp->iov_base = mtod(mp, caddr_t);
			if (len < mp->m_len)
				ivp->iov_len = xfer = len;
d1047 39
a1085 12
				ivp->iov_len = xfer = mp->m_len;
#ifdef notdef
			/* Not Yet .. */
			if (M_HASCL(mp) && (((u_long)ivp->iov_base) & CLOFSET) == 0)
				ivp->iov_op = NULL;	/* what should it be ?? */
			else
				ivp->iov_op = NULL;
#endif
			uiop->uio_iovcnt++;
			ivp++;
			len -= xfer;
			siz += xfer;
d1087 6
d1094 4
a1097 4
		if (len > 0 && mp == NULL) {
			error = EBADRPC;
			vput(vp);
			nfsm_reply(0);
d1099 70
a1168 4
		uiop->uio_resid = siz;
		if ((error = VOP_WRITE(vp, uiop, ioflags, cred)) != 0) {
			vput(vp);
			nfsm_reply(0);
d1170 42
a1211 12
		off = uiop->uio_offset;
	}
	error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp);
	vput(vp);
	nfsm_reply(NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_build(fp, struct nfsv2_fattr *, NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_srvfillattr;
	if (nfsd->nd_nqlflag != NQL_NOVAL) {
		nfsm_build(tl, u_int32_t *, 2*NFSX_UNSIGNED);
		txdr_hyper(&va.va_filerev, tl);
	}
	nfsm_srvdone;
d1219 5
a1223 6
nfsrv_create(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d1225 6
a1230 2
	register struct nfsv2_fattr *fp;
	struct vattr va;
d1237 3
a1239 1
	int error = 0, rdev, cache, len, tsize;
d1242 2
a1243 2
	struct vnode *vp = NULL;
	nfsv2fh_t nfh;
d1245 2
a1246 1
	u_quad_t frev;
d1251 1
a1251 1
	nfsm_srvstrsiz(len, NFS_MAXNAMLEN);
d1255 18
a1272 4
	error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
			  nfsd->nd_procp);
	if (error)
		nfsm_reply(0);
d1274 43
a1316 1
	nfsm_dissect(sp, struct nfsv2_sattr *, NFSX_SATTR(nfsd->nd_nqlflag != NQL_NOVAL));
a1322 8
		va.va_type = IFTOVT(fxdr_unsigned(u_int32_t, sp->sa_mode));
		if (va.va_type == VNON)
			va.va_type = VREG;
		va.va_mode = nfstov_mode(sp->sa_mode);
		if (nfsd->nd_nqlflag == NQL_NOVAL)
			rdev = fxdr_unsigned(int32_t, sp->sa_nfssize);
		else
			rdev = fxdr_unsigned(int32_t, sp->sa_nqrdev);
d1325 13
a1337 6
			nqsrv_getl(nd.ni_dvp, NQL_WRITE);
			error = VOP_CREATE(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd,
					   &va);
			if (error)
				nfsm_reply(0);
			FREE(nd.ni_cnd.cn_pnbuf, M_NAMEI);
d1342 4
a1345 2
			if (va.va_type == VFIFO) {
#ifndef FIFO
d1348 2
a1349 7
				error = ENXIO;
				goto out;
#endif /* FIFO */
			} else if ((error = suser(cred, (u_short *)0)) != 0) {
				VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
				vput(nd.ni_dvp);
				goto out;
d1352 1
a1352 1
			nqsrv_getl(nd.ni_dvp, NQL_WRITE);
d1354 1
a1354 1
					  &va);
d1361 2
a1362 2
			nd.ni_cnd.cn_proc = nfsd->nd_procp;
			nd.ni_cnd.cn_cred = nfsd->nd_procp->p_ucred;
d1376 2
a1380 1
			goto out;
a1391 8
		if (nfsd->nd_nqlflag == NQL_NOVAL) {
			tsize = fxdr_unsigned(int32_t, sp->sa_nfssize);
			if (tsize != -1)
				va.va_size = (u_quad_t)tsize;
			else
				va.va_size = -1;
		} else
			fxdr_hyper(&sp->sa_nqsize, &va.va_size);
d1394 8
a1401 5
					     (nd.ni_cnd.cn_flags & RDONLY),
					     nfsd->nd_procp);
			if (error) {
				vput(vp);
				nfsm_reply(0);
d1403 1
a1403 3
			nqsrv_getl(vp, NQL_WRITE);
			error = VOP_SETATTR(vp, &va, cred, nfsd->nd_procp);
			if (error) {
a1404 2
				nfsm_reply(0);
			}
d1407 6
a1412 3
	bzero((caddr_t)fhp, sizeof(nfh));
	fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
	if ((error = VFS_VPTOFH(vp, &fhp->fh_fid)) != 0) {
a1413 1
		nfsm_reply(0);
d1415 20
a1434 7
	error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp);
	vput(vp);
	nfsm_reply(NFSX_FH+NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_srvfhtom(fhp);
	nfsm_build(fp, struct nfsv2_fattr *, NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_srvfillattr;
	return (error);
d1436 3
a1438 1
	if (nd.ni_cnd.cn_nameiop || nd.ni_cnd.cn_flags)
d1440 2
d1450 67
d1518 48
d1567 33
a1599 4
	vrele(nd.ni_startdir);
	free(nd.ni_cnd.cn_pnbuf, M_NAMEI);
	nfsm_reply(0);
	return 0;
d1606 5
a1610 6
nfsrv_remove(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d1612 4
d1620 2
a1621 1
	int error = 0, cache, len;
d1624 3
a1626 2
	struct vnode *vp;
	nfsv2fh_t nfh;
d1630 3
d1635 1
a1635 1
	nfsm_srvstrsiz(len, NFS_MAXNAMLEN);
d1639 6
a1644 12
	error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
			  nfsd->nd_procp);
	if (error)
		nfsm_reply(0);
	vp = nd.ni_vp;
	/*
	 * The root of a mounted filesystem cannot be deleted.
	 */
	if (vp->v_flag & VROOT) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
d1646 1
a1646 4
			vput(nd.ni_dvp);
		vput(vp);
		error = EBUSY;
		goto out;
d1648 14
a1661 5
	if (vp->v_flag & VTEXT)
		(void) vnode_pager_uncache(vp);
	nqsrv_getl(nd.ni_dvp, NQL_WRITE);
	nqsrv_getl(vp, NQL_WRITE);
	error = VOP_REMOVE(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
d1663 22
a1684 1
	nfsm_reply(0);
d1692 5
a1696 6
nfsrv_rename(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d1698 4
d1705 3
a1707 1
	int error = 0, cache, len, len2;
d1711 4
a1714 2
	struct vnode *fvp = NULL, *tvp, *tdvp;
	nfsv2fh_t fnfh, tnfh;
d1719 3
d1727 1
a1727 1
	nfsm_srvstrsiz(len, NFS_MAXNAMLEN);
d1736 19
a1754 4
	error = nfs_namei(&fromnd, ffhp, len, nfsd->nd_slp, nam, &md,
			  &dpos, nfsd->nd_procp);
	if (error)
		nfsm_reply(0);
d1762 11
a1772 2
	error = nfs_namei(&tond, tfhp, len2, nfsd->nd_slp, nam, &md,
			  &dpos, nfsd->nd_procp);
d1783 4
a1786 1
			error = EISDIR;
d1789 4
a1792 1
			error = ENOTDIR;
d1796 4
a1799 1
			error = EXDEV;
d1804 4
a1807 1
		error = EBUSY;
d1811 4
a1814 1
		error = EXDEV;
d1818 4
a1821 1
		error = EINVAL;
d1834 2
a1835 2
		nqsrv_getl(fromnd.ni_dvp, NQL_WRITE);
		nqsrv_getl(tdvp, NQL_WRITE);
d1837 1
a1837 1
			nqsrv_getl(tvp, NQL_WRITE);
d1851 2
d1857 8
d1867 6
a1872 2
	nfsm_reply(0);
	return (error);
d1875 5
a1879 1
	if (tond.ni_cnd.cn_nameiop || tond.ni_cnd.cn_flags) {
d1883 1
a1883 1
	if (fromnd.ni_cnd.cn_nameiop || fromnd.ni_cnd.cn_flags) {
d1897 5
a1901 6
nfsrv_link(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d1903 4
d1911 2
a1912 1
	int error = 0, rdonly, cache, len;
d1915 3
a1917 2
	struct vnode *vp;
	nfsv2fh_t nfh, dnfh;
d1925 11
a1935 4
	nfsm_srvstrsiz(len, NFS_MAXNAMLEN);
	error = nfsrv_fhtovp(fhp, FALSE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
		nfsm_reply(0);
d1939 11
a1949 2
	error = nfs_namei(&nd, dfhp, len, nfsd->nd_slp, nam, &md, &dpos,
			  nfsd->nd_procp);
d1951 4
d1956 10
a1965 1
	if (nd.ni_vp) {
d1971 9
a1979 3
		vrele(nd.ni_vp);
		error = EEXIST;
		goto out;
a1980 4
	nqsrv_getl(nd.ni_dvp, NQL_WRITE);
	nqsrv_getl(vp, NQL_WRITE);
	error = VOP_LINK(nd.ni_dvp, vp, &nd.ni_cnd);
out:
d1982 6
a1987 1
	nfsm_reply(0);
d1995 5
a1999 6
nfsrv_symlink(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d2001 5
a2005 1
	struct vattr va;
d2010 1
a2010 1
	caddr_t bpos;
d2013 5
a2017 4
	int error = 0, cache, len, len2;
	char *pathcp, *cp2;
	struct mbuf *mb, *mreq;
	nfsv2fh_t nfh;
d2021 1
a2021 1
	pathcp = (char *)0;
d2024 1
a2024 1
	nfsm_srvstrsiz(len, NFS_MAXNAMLEN);
d2027 12
a2038 3
	nd.ni_cnd.cn_flags = LOCKPARENT;
	error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
			  nfsd->nd_procp);
d2041 3
d2056 4
a2059 1
	nfsm_dissect(sp, struct nfsv2_sattr *, NFSX_SATTR(nfsd->nd_nqlflag != NQL_NOVAL));
d2062 2
d2073 25
a2097 4
	VATTR_NULL(&va);
	va.va_mode = fxdr_unsigned(u_int16_t, sp->sa_mode);
	nqsrv_getl(nd.ni_dvp, NQL_WRITE);
	error = VOP_SYMLINK(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va, pathcp);
d2101 13
a2113 2
	nfsm_reply(0);
	return (error);
d2115 6
d2137 5
a2141 6
nfsrv_mkdir(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d2143 6
a2148 2
	struct vattr va;
	register struct nfsv2_fattr *fp;
d2154 2
a2155 1
	int error = 0, cache, len;
d2158 2
a2159 2
	struct vnode *vp;
	nfsv2fh_t nfh;
d2165 1
a2165 1
	nfsm_srvstrsiz(len, NFS_MAXNAMLEN);
d2169 18
a2186 5
	error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
			  nfsd->nd_procp);
	if (error)
		nfsm_reply(0);
	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
d2188 6
a2194 1
	va.va_mode = nfstov_mode(*tl++);
d2204 1
a2204 1
		nfsm_reply(0);
d2206 9
a2214 7
	nqsrv_getl(nd.ni_dvp, NQL_WRITE);
	if ((error = VOP_MKDIR(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va)) != 0)
		nfsm_reply(0);
	vp = nd.ni_vp;
	bzero((caddr_t)fhp, sizeof(nfh));
	fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
	if ((error = VFS_VPTOFH(vp, &fhp->fh_fid)) != 0) {
a2215 1
		nfsm_reply(0);
d2217 18
a2234 7
	error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp);
	vput(vp);
	nfsm_reply(NFSX_FH+NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_srvfhtom(fhp);
	nfsm_build(fp, struct nfsv2_fattr *, NFSX_FATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	nfsm_srvfillattr;
	return (error);
d2236 2
d2252 5
a2256 6
nfsrv_rmdir(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d2258 4
d2265 2
a2266 1
	int error = 0, cache, len;
d2269 3
a2271 2
	struct vnode *vp;
	nfsv2fh_t nfh;
d2278 1
a2278 1
	nfsm_srvstrsiz(len, NFS_MAXNAMLEN);
d2282 18
a2299 4
	error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
			  nfsd->nd_procp);
	if (error)
		nfsm_reply(0);
d2319 2
a2320 2
		nqsrv_getl(nd.ni_dvp, NQL_WRITE);
		nqsrv_getl(vp, NQL_WRITE);
d2330 9
a2338 1
	nfsm_reply(0);
d2358 2
d2364 1
a2364 1
 *     The alternate call nqnfsrv_readdirlook() does lookups as well.
d2374 6
a2379 5
	u_int32_t fl_cachable;
	u_int32_t fl_duration;
	u_int32_t fl_frev[2];
	nfsv2fh_t fl_nfh;
	u_int32_t fl_fattr[NFSX_NQFATTR / sizeof (u_int32_t)];
d2383 5
a2387 6
nfsrv_readdir(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d2389 4
d2395 1
a2395 1
	register struct dirent *dp = NULL;
d2403 2
a2404 1
	nfsv2fh_t nfh;
d2408 5
a2412 5
	int len, nlen, rem, xfer, tsiz, i, error = 0;
	int siz, cnt, fullsiz, eofflag, rdonly, cache;
	u_quad_t frev;
	u_long off, *cookiebuf, *cookie;
	int ncookies;
d2416 11
a2426 2
	nfsm_dissect(tl, u_int32_t *, 2*NFSX_UNSIGNED);
	off = fxdr_unsigned(u_int32_t, *tl++);
d2428 4
a2431 3
	siz = ((cnt+NFS_DIRBLKSIZ-1) & ~(NFS_DIRBLKSIZ-1));
	if (cnt > NFS_MAXREADDIR)
		siz = NFS_MAXREADDIR;
d2433 20
a2452 6
	ncookies = siz / 16;	/* Guess at the number of cookies needed. */
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
		nfsm_reply(0);
	nqsrv_getl(vp, NQL_READ);
	error = nfsrv_access(vp, VEXEC, cred, rdonly, nfsd->nd_procp);
d2455 3
a2457 1
		nfsm_reply(0);
d2459 3
d2463 1
d2465 3
a2467 2
	MALLOC(cookiebuf, u_long *, ncookies * sizeof(*cookiebuf), M_TEMP,
	    M_WAITOK);
d2478 9
a2486 2
	error = VOP_READDIR(vp, &io, cred, &eofflag, cookiebuf, ncookies);
	cookie = cookiebuf;
d2488 13
a2502 1
		free((caddr_t)cookiebuf, M_TEMP);
d2504 5
a2508 1
		nfsm_reply(0);
d2519 9
a2527 2
			nfsm_reply(2*NFSX_UNSIGNED);
			nfsm_build(tl, u_int32_t *, 2*NFSX_UNSIGNED);
a2529 1
			FREE((caddr_t)cookiebuf, M_TEMP);
d2531 1
d2542 6
a2547 1
	while (cpos < cend) {
d2549 2
a2550 5
		if (dp->d_fileno == 0) {
			cpos += dp->d_reclen;
			cookie++;
		} else
			break;
d2552 2
a2553 1
	if (cpos >= cend) {
d2558 7
a2564 2
	len = 3*NFSX_UNSIGNED;	/* paranoia, probably can be 0 */
	nfsm_reply(siz);
d2570 2
a2571 2
	while (cpos < cend) {
		if (dp->d_fileno != 0) {
d2574 3
a2576 1
			len += (4*NFSX_UNSIGNED + nlen + rem);
d2588 5
d2615 1
a2615 1
			/* And null pad to a int32_t boundary */
d2621 6
a2626 1
			*tl = txdr_unsigned(*cookie);
d2631 2
a2632 1
		cookie++;
d2649 2
a2650 2
	FREE(cookiebuf, M_TEMP);
	FREE(rbuf, M_TEMP);
d2655 5
a2659 6
nqnfsrv_readdirlook(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d2661 4
d2667 1
a2667 1
	register struct dirent *dp = NULL;
d2676 2
a2677 2
	nfsv2fh_t nfh;
	fhandle_t *fhp;
d2680 6
a2685 7
	struct vattr va;
	struct nfsv2_fattr *fp;
	int len, nlen, rem, xfer, tsiz, i, error = 0, duration2, cache2;
	int siz, cnt, fullsiz, eofflag, rdonly, cache;
	u_quad_t frev, frev2;
	u_long off, *cookiebuf, *cookie;
	int ncookies;
d2689 12
a2700 7
	nfsm_dissect(tl, u_int32_t *, 3*NFSX_UNSIGNED);
	off = fxdr_unsigned(u_int32_t, *tl++);
	cnt = fxdr_unsigned(int, *tl++);
	duration2 = fxdr_unsigned(int, *tl);
	siz = ((cnt+NFS_DIRBLKSIZ-1) & ~(NFS_DIRBLKSIZ-1));
	if (cnt > NFS_MAXREADDIR)
		siz = NFS_MAXREADDIR;
d2702 19
a2720 6
	ncookies = siz / 16;	/* Guess at the number of cookies needed. */
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
		nfsm_reply(0);
	nqsrv_getl(vp, NQL_READ);
	error = nfsrv_access(vp, VEXEC, cred, rdonly, nfsd->nd_procp);
d2723 3
a2725 1
		nfsm_reply(0);
d2727 3
d2731 2
d2734 3
a2736 2
	MALLOC(cookiebuf, u_long *, ncookies * sizeof(*cookiebuf), M_TEMP,
	    M_WAITOK);
d2747 21
a2767 3
	error = VOP_READDIR(vp, &io, cred, &eofflag, cookiebuf, ncookies);
	cookie = cookiebuf;
	off = (u_long)io.uio_offset;
d2770 2
a2771 1
		free((caddr_t)cookiebuf, M_TEMP);
d2773 3
a2775 1
		nfsm_reply(0);
d2786 6
a2791 2
			nfsm_reply(2 * NFSX_UNSIGNED);
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d2794 1
a2794 1
			FREE((caddr_t)cookiebuf, M_TEMP);
d2806 6
a2811 1
	while (cpos < cend) {
d2813 2
a2814 5
		if (dp->d_fileno == 0) {
			cpos += dp->d_reclen;
			cookie++;
		} else
			break;
d2816 2
a2817 1
	if (cpos >= cend) {
d2822 5
a2826 2
	len = 3 * NFSX_UNSIGNED;	/* paranoia, probably can be 0 */
	nfsm_reply(siz);
d2832 2
a2833 2
	while (cpos < cend) {
		if (dp->d_fileno != 0) {
d2843 2
a2844 2
			bzero((caddr_t)&fl.fl_nfh, sizeof (nfsv2fh_t));
			fl.fl_nfh.fh_generic.fh_fsid =
d2846 1
a2846 1
			if (VFS_VPTOFH(nvp, &fl.fl_nfh.fh_generic.fh_fid)) {
d2850 1
a2850 9
			if (duration2) {
				(void) nqsrv_getlease(nvp, &duration2, NQL_READ,
					nfsd, nam, &cache2, &frev2, cred);
				fl.fl_duration = txdr_unsigned(duration2);
				fl.fl_cachable = txdr_unsigned(cache2);
				txdr_hyper(&frev2, fl.fl_frev);
			} else
				fl.fl_duration = 0;
			if (VOP_GETATTR(nvp, &va, cred, nfsd->nd_procp)) {
d2855 11
a2865 5
			fp = (struct nfsv2_fattr *)&fl.fl_fattr;
			nfsm_srvfillattr;
			len += (4*NFSX_UNSIGNED + nlen + rem + NFSX_FH
				+ NFSX_NQFATTR);
			if (len > cnt) {
d2869 1
d2874 8
d2885 3
a2887 18

			/*
			 * For readdir_and_lookup copy the stuff out.
			 */
			xfer = sizeof (struct flrep);
			cp = (caddr_t)&fl;
			while (xfer > 0) {
				nfsm_clget;
				if ((bp+xfer) > be)
					tsiz = be-bp;
				else
					tsiz = xfer;
				bcopy(cp, bp, tsiz);
				bp += tsiz;
				xfer -= tsiz;
				if (xfer > 0)
					cp += tsiz;
			}
d2900 2
a2901 2
				if ((bp+xfer) > be)
					tsiz = be-bp;
d2910 1
a2910 1
			/* And null pad to a int32_t boundary */
a2912 1
			nfsm_clget;
d2914 17
a2930 3
			/* Finish off the record */
			*tl = txdr_unsigned(*cookie);
			bp += NFSX_UNSIGNED;
d2935 2
a2936 1
		cookie++;
d2953 64
a3016 2
	FREE(cookiebuf, M_TEMP);
	FREE(rbuf, M_TEMP);
d3024 5
a3028 6
nfsrv_statfs(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d3030 4
d3035 1
a3035 1
	register struct nfsv2_statfs *sfp;
d3039 2
a3040 1
	int error = 0, rdonly, cache = 0, isnq;
d3044 2
a3045 1
	nfsv2fh_t nfh;
d3048 1
a3048 1
	u_quad_t frev;
d3050 3
a3053 1
	isnq = (nfsd->nd_nqlflag != NQL_NOVAL);
d3055 7
a3061 3
	error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
	if (error)
		nfsm_reply(0);
d3063 2
a3064 1
	error = VFS_STATFS(vp->v_mount, sf, nfsd->nd_procp);
d3066 71
a3136 10
	nfsm_reply(NFSX_STATFS(isnq));
	nfsm_build(sfp, struct nfsv2_statfs *, NFSX_STATFS(isnq));
	sfp->sf_tsize = txdr_unsigned(NFS_MAXDGRAMDATA);
	sfp->sf_bsize = txdr_unsigned(sf->f_bsize);
	sfp->sf_blocks = txdr_unsigned(sf->f_blocks);
	sfp->sf_bfree = txdr_unsigned(sf->f_bfree);
	sfp->sf_bavail = txdr_unsigned(sf->f_bavail);
	if (isnq) {
		sfp->sf_files = txdr_unsigned(sf->f_files);
		sfp->sf_ffree = txdr_unsigned(sf->f_ffree);
d3138 99
d3245 5
a3249 6
nfsrv_null(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d3251 1
d3253 1
a3253 1
	int error = VNOVAL, cache = 0;
d3258 1
a3258 1
	return (error);
d3266 5
a3270 6
nfsrv_noop(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d3272 1
d3283 1
a3283 1
	return (error);
d3315 3
a3317 1
			case VREG: case VDIR: case VLNK:
d3319 1
a3319 6
			case VNON:
			case VBLK:
			case VCHR:
			case VSOCK:
			case VFIFO:
			case VBAD:
d3331 2
a3332 1
	if ((error = VOP_GETATTR(vp, &vattr, cred, p)) != 0)
d3334 1
a3334 1
	if ((error = VOP_ACCESS(vp, flags, cred, p)) &&
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_serv.c,v 1.19 1995/12/19 23:07:32 cgd Exp $	*/
d79 1
d95 1
d109 1
a109 1
	int error = 0, rdonly, cache, mode = 0;
d117 2
a118 1
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d135 1
d158 2
a159 1
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d173 1
d197 4
a200 2
	nfsm_dissect(sp, struct nfsv2_sattr *, NFSX_SATTR(nfsd->nd_nqlflag != NQL_NOVAL));
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d224 1
a224 1
			va.va_atime.ts_sec =
d226 1
a226 1
			va.va_atime.ts_nsec = 0;
d251 2
a252 2
		} else if (error = nfsrv_access(vp, VWRITE, cred, rdonly,
			nfsd->nd_procp))
d255 1
a255 1
	if (error = VOP_SETATTR(vp, &va, cred, nfsd->nd_procp)) {
d275 1
d309 2
a310 2
	if (error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
	    nfsd->nd_procp))
d318 1
a318 1
	if (error = VFS_VPTOFH(vp, &fhp->fh_fid)) {
d349 1
d365 1
a365 1
	struct mbuf *mb, *mb2, *mp2, *mp3, *mreq;
d403 2
a404 1
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly)) {
d433 1
d470 2
a471 1
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d479 10
a488 6
	if ((error = nfsrv_access(vp, VREAD, cred, rdonly, nfsd->nd_procp)) &&
	    (error = nfsrv_access(vp, VEXEC, cred, rdonly, nfsd->nd_procp))) {
		vput(vp);
		nfsm_reply(0);
	}
	if (error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp)) {
d558 1
d614 2
a615 1
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d623 2
a624 1
	if (error = nfsrv_access(vp, VWRITE, cred, rdonly, nfsd->nd_procp)) {
d667 1
a667 1
		if (error = VOP_WRITE(vp, uiop, ioflags, cred)) {
d689 1
d708 1
a708 1
	struct vnode *vp;
d720 3
a722 2
	if (error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
	    nfsd->nd_procp))
d743 3
a745 1
			if (error = VOP_CREATE(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va))
d759 1
a759 1
			} else if (error = suser(cred, (u_short *)0)) {
d766 3
a768 1
			if (error = VOP_MKNOD(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va)) {
d776 1
a776 1
			if (error = lookup(&nd)) {
d813 4
a816 2
			if (error = nfsrv_access(vp, VWRITE, cred,
			    (nd.ni_cnd.cn_flags & RDONLY), nfsd->nd_procp)) {
d821 2
a822 1
			if (error = VOP_SETATTR(vp, &va, cred, nfsd->nd_procp)) {
d830 1
a830 1
	if (error = VFS_VPTOFH(vp, &fhp->fh_fid)) {
d857 1
d863 1
d889 3
a891 2
	if (error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
	    nfsd->nd_procp))
a893 3
	if (vp->v_type == VDIR &&
		(error = suser(cred, (u_short *)0)))
		goto out;
a897 11
		error = EBUSY;
		goto out;
	}
	if (vp->v_flag & VTEXT)
		(void) vnode_pager_uncache(vp);
out:
	if (!error) {
		nqsrv_getl(nd.ni_dvp, NQL_WRITE);
		nqsrv_getl(vp, NQL_WRITE);
		error = VOP_REMOVE(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
	} else {
d904 2
d907 6
d920 1
d935 1
a935 1
	struct vnode *fvp, *tvp, *tdvp;
d955 3
a957 2
	if (error = nfs_namei(&fromnd, ffhp, len, nfsd->nd_slp, nam, &md,
	    &dpos, nfsd->nd_procp))
d966 3
a968 2
	if (error = nfs_namei(&tond, tfhp, len2, nfsd->nd_slp, nam, &md,
	    &dpos, nfsd->nd_procp)) {
d1055 1
d1070 1
a1070 1
	struct vnode *vp, *xp;
d1080 2
a1081 1
	if (error = nfsrv_fhtovp(fhp, FALSE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
a1082 2
	if (vp->v_type == VDIR && (error = suser(cred, (u_short *)0)))
		goto out1;
d1086 3
a1088 6
	if (error = nfs_namei(&nd, dfhp, len, nfsd->nd_slp, nam, &md, &dpos,
	    nfsd->nd_procp))
		goto out1;
	xp = nd.ni_vp;
	if (xp != NULL) {
		error = EEXIST;
d1090 1
a1090 10
	}
	xp = nd.ni_dvp;
	if (vp->v_mount != xp->v_mount)
		error = EXDEV;
out:
	if (!error) {
		nqsrv_getl(vp, NQL_WRITE);
		nqsrv_getl(xp, NQL_WRITE);
		error = VOP_LINK(nd.ni_dvp, vp, &nd.ni_cnd);
	} else {
d1096 3
a1098 2
		if (nd.ni_vp)
			vrele(nd.ni_vp);
d1100 4
a1103 1
out1:
d1112 1
d1142 3
a1144 2
	if (error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
	    nfsd->nd_procp))
d1195 1
d1224 3
a1226 2
	if (error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
	    nfsd->nd_procp))
d1244 1
a1244 1
	if (error = VOP_MKDIR(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &va))
d1249 1
a1249 1
	if (error = VFS_VPTOFH(vp, &fhp->fh_fid)) {
d1274 1
d1300 3
a1302 2
	if (error = nfs_namei(&nd, fhp, len, nfsd->nd_slp, nam, &md, &dpos,
	    nfsd->nd_procp))
d1375 1
d1385 1
a1385 1
	register struct dirent *dp;
d1413 2
a1414 1
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d1417 2
a1418 1
	if (error = nfsrv_access(vp, VEXEC, cred, rdonly, nfsd->nd_procp)) {
d1561 1
d1571 1
a1571 1
	register struct dirent *dp;
d1603 2
a1604 1
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d1607 2
a1608 1
	if (error = nfsrv_access(vp, VEXEC, cred, rdonly, nfsd->nd_procp)) {
d1803 1
d1816 1
a1816 1
	int error = 0, rdonly, cache, isnq;
d1828 2
a1829 1
	if (error = nfsrv_fhtovp(fhp, TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d1852 1
d1861 1
a1861 1
	int error = VNOVAL, cache;
d1873 1
d1882 1
a1882 1
	int error, cache;
d1904 1
d1925 7
d1942 1
a1942 1
	if (error = VOP_GETATTR(vp, &vattr, cred, p))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_serv.c,v 1.18 1995/05/23 06:22:47 mycroft Exp $	*/
d85 2
a86 2
extern u_long nfs_xdrneg1;
extern u_long nfs_false, nfs_true;
d103 2
a104 2
	register u_long *tl;
	register long t1;
d113 1
a113 1
	nfsm_dissect(tl, u_long *, 3 * NFSX_UNSIGNED);
d143 2
a144 2
	register u_long *tl;
	register long t1;
d180 2
a181 2
	register u_long *tl;
	register long t1;
d216 1
a216 1
				fxdr_unsigned(long, sp->sa_nfsatime.nfs_sec);
d226 1
a226 1
		va.va_flags = fxdr_unsigned(u_long, sp->sa_nqflags);
d257 1
a257 1
		nfsm_build(tl, u_long *, 2*NFSX_UNSIGNED);
d279 2
a280 2
	register u_long *tl;
	register long t1;
d291 1
a291 1
		nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d320 1
a320 1
			nfsm_build(tl, u_long *, 5*NFSX_UNSIGNED);
d326 1
a326 1
			nfsm_build(tl, u_long *, NFSX_UNSIGNED);
d349 2
a350 2
	register u_long *tl;
	register long t1;
d412 1
a412 1
	nfsm_build(tl, u_long *, NFSX_UNSIGNED);
d432 2
a433 2
	register u_long *tl;
	register long t1;
d450 2
a451 2
		nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
		off = (off_t)fxdr_unsigned(u_long, *tl);
d453 1
a453 1
		nfsm_dissect(tl, u_long *, 2 * NFSX_UNSIGNED);
d480 1
a480 1
	nfsm_build(tl, u_long *, NFSX_UNSIGNED);
d552 2
a553 2
	register u_long *tl;
	register long t1;
d568 1
a568 1
	nfsm_dissect(tl, u_long *, 4 * NFSX_UNSIGNED);
d570 1
a570 1
		off = (off_t)fxdr_unsigned(u_long, *++tl);
d575 1
a575 1
		if (fxdr_unsigned(u_long, *tl++))
d578 1
a578 1
	len = fxdr_unsigned(long, *tl);
d658 1
a658 1
		nfsm_build(tl, u_long *, 2*NFSX_UNSIGNED);
d678 1
a678 1
	register u_long *tl;
d681 1
a681 1
	register long t1;
d709 1
a709 1
		va.va_type = IFTOVT(fxdr_unsigned(u_long, sp->sa_mode));
d714 1
a714 1
			rdev = fxdr_unsigned(long, sp->sa_nfssize);
d716 1
a716 1
			rdev = fxdr_unsigned(long, sp->sa_nqrdev);
d778 1
a778 1
			tsize = fxdr_unsigned(long, sp->sa_nfssize);
d840 2
a841 2
	register u_long *tl;
	register long t1;
d900 2
a901 2
	register u_long *tl;
	register long t1;
d1033 2
a1034 2
	register u_long *tl;
	register long t1;
d1099 2
a1100 2
	register u_long *tl;
	register long t1;
d1147 1
a1147 1
	va.va_mode = fxdr_unsigned(u_short, sp->sa_mode);
d1182 2
a1183 2
	register u_long *tl;
	register long t1;
d1202 1
a1202 1
	nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d1255 2
a1256 2
	register u_long *tl;
	register long t1;
d1340 3
a1342 3
	u_long fl_cachable;
	u_long fl_duration;
	u_long fl_frev[2];
d1344 1
a1344 1
	u_long fl_fattr[NFSX_NQFATTR / sizeof (u_long)];
d1358 2
a1359 2
	register u_long *tl;
	register long t1;
d1376 2
a1377 2
	nfsm_dissect(tl, u_long *, 2*NFSX_UNSIGNED);
	off = fxdr_unsigned(u_long, *tl++);
d1424 1
a1424 1
			nfsm_build(tl, u_long *, 2*NFSX_UNSIGNED);
d1497 1
a1497 1
			/* And null pad to a long boundary */
d1541 2
a1542 2
	register u_long *tl;
	register long t1;
d1562 2
a1563 2
	nfsm_dissect(tl, u_long *, 3*NFSX_UNSIGNED);
	off = fxdr_unsigned(u_long, *tl++);
d1611 1
a1611 1
			nfsm_build(tl, u_long *, 2 * NFSX_UNSIGNED);
d1732 1
a1732 1
			/* And null pad to a long boundary */
d1778 2
a1779 2
	register u_long *tl;
	register long t1;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
