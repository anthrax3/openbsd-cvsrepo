head	1.53;
access;
symbols
	OPENBSD_6_2:1.53.0.2
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.52.0.10
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.6
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.52.0.8
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.51.0.20
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.51.0.16
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.14
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.12
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.10
	OPENBSD_5_0:1.51.0.8
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.51.0.6
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.51.0.4
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.28.0.6
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2017.02.22.11.42.46;	author mpi;	state Exp;
branches;
next	1.52;
commitid	QPdM5oUknMlUIDue;

1.52
date	2014.03.24.00.19.48;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2009.09.02.18.20.54;	author thib;	state Exp;
branches;
next	1.50;

1.50
date	2009.08.25.13.41.29;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2009.08.20.15.04.24;	author thib;	state Exp;
branches;
next	1.48;

1.48
date	2009.08.14.21.16.13;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2009.08.10.10.59.11;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2009.08.10.09.38.44;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.14.16.40.29;	author thib;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.04.02.06.40;	author blambert;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.03.03.55.23;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2009.06.03.00.12.34;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2009.06.02.23.16.59;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2009.05.22.00.19.25;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.21.12.24.22;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.24.23.35.47;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.24.23.25.17;	author thib;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.18.21.15.53;	author blambert;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.12.16.55.37;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.31.16.58.01;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.05.17.34.26;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.05.12.51.04;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.12.19.14.15;	author thib;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.08.18.23.03;	author thib;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.22.18.31.12;	author blambert;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.20.21.56.21;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.29.16.49.42;	author avsm;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.28.23.29.32;	author avsm;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.08.04.17.14;	author marius;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.02.01.00.38;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.22.04.45.54;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.28.19;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.28.10.14.27;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.29.12.47.06;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.10.22.02.05;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.11.01.20.56;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.09.16.00.42.44;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.19.18.16.31;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.25.03.28.05;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.22.17.33.18;	author mickey;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2000.05.19.16.54.52;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.19.16.36.03;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	98.05.25.09.12.26;	author deraadt;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	96.12.17.03.46.37;	author dm;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.07.28.52;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.17.04.50.23;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.31.13.15.29;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.21;	author deraadt;	state Exp;
branches;
next	;

1.7.8.1
date	2001.05.14.22.44.56;	author niklas;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2001.07.04.10.55.45;	author niklas;	state Exp;
branches;
next	1.7.8.3;

1.7.8.3
date	2001.10.31.03.30.29;	author nate;	state Exp;
branches;
next	1.7.8.4;

1.7.8.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.7.8.5;

1.7.8.5
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.7.8.6;

1.7.8.6
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	1.7.8.7;

1.7.8.7
date	2003.05.13.19.36.56;	author ho;	state Exp;
branches;
next	1.7.8.8;

1.7.8.8
date	2003.06.07.11.07.43;	author ho;	state Exp;
branches;
next	1.7.8.9;

1.7.8.9
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2001.09.16.15.22.03;	author miod;	state Exp;
branches;
next	;

1.10.4.1
date	2001.10.14.20.44.49;	author jason;	state Exp;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.06.11.03.32.03;	author art;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2003.05.19.22.36.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Keep local definitions local.

"good work" deraadt@@, ok visa@@
@
text
@/*	$OpenBSD: nfs.h,v 1.52 2014/03/24 00:19:48 guenther Exp $	*/
/*	$NetBSD: nfs.h,v 1.10.4.1 1996/05/27 11:23:56 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs.h	8.4 (Berkeley) 5/1/95
 */

#ifndef _NFS_NFS_H_
#define _NFS_NFS_H_

#define NFS_TICKINTVL	5		/* Desired time for a tick (msec) */
#define NFS_HZ		(hz / nfs_ticks) /* Ticks/sec */
#define	NFS_TIMEO	(1 * NFS_HZ)	/* Default timeout = 1 second */
#define	NFS_MINTIMEO	(1 * NFS_HZ)	/* Min timeout to use */
#define	NFS_MAXTIMEO	(60 * NFS_HZ)	/* Max timeout to backoff to */
#define	NFS_MINIDEMTIMEO (5 * NFS_HZ)	/* Min timeout for non-idempotent ops*/
#define	NFS_TIMEOUTMUL	2		/* Timeout/Delay multiplier */
#define	NFS_MAXREXMIT	100		/* Stop counting after this many */
#define	NFS_RETRANS	10		/* Num of retrans for soft mounts */
#define	NFS_MAXGRPS	16		/* Max. size of groups list */
#define	NFS_MINATTRTIMO 5		/* Attribute cache timeout in sec */
#define	NFS_MAXATTRTIMO 60
#define	NFS_WSIZE	8192		/* Def. write data size <= 8192 */
#define	NFS_RSIZE	8192		/* Def. read data size <= 8192 */
#define NFS_READDIRSIZE	8192		/* Def. readdir size */
#define	NFS_DEFRAHEAD	1		/* Def. read ahead # blocks */
#define	NFS_MAXRAHEAD	4		/* Max. read ahead # blocks */
#define	NFS_MAXASYNCDAEMON 	20	/* Max. number async_daemons runable */

/*
 * Ideally, NFS_DIRBLKSIZ should be bigger, but I've seen servers with
 * broken NFS/ethernet drivers that won't work with anything bigger (Linux..)
 */
#define	NFS_DIRBLKSIZ	1024		/* Must be a multiple of DIRBLKSIZ */
#define NFS_READDIRBLKSIZ	512	/* Size of read dir blocks. XXX */

/*
 * Oddballs
 */
#define NFS_CMPFH(n, f, s) \
	((n)->n_fhsize == (s) && !bcmp((caddr_t)(n)->n_fhp, (caddr_t)(f), (s)))
#define NFS_ISV3(v)	(VFSTONFS((v)->v_mount)->nm_flag & NFSMNT_NFSV3)
#define NFS_SRVMAXDATA(n) \
		(((n)->nd_flag & ND_NFSV3) ? (((n)->nd_nam2) ? \
		 NFS_MAXDGRAMDATA : NFS_MAXDATA) : NFS_V2MAXDATA)

/*
 * sys/malloc.h needs M_NFSDIROFF, M_NFSRVDESC and M_NFSBIGFH added.
 */
#ifndef M_NFSRVDESC
#define M_NFSRVDESC	M_TEMP
#endif
#ifndef M_NFSDIROFF
#define M_NFSDIROFF	M_TEMP
#endif
#ifndef M_NFSBIGFH
#define M_NFSBIGFH	M_TEMP
#endif

/*
 * The B_INVAFTERWRITE flag should be set to whatever is required by the
 * buffer cache code to say "Invalidate the block after it is written back".
 */
#define	B_INVAFTERWRITE	B_INVAL

/*
 * Structures for the nfssvc(2) syscall.
 * Not that anyone besides nfsd(8) should ever use it.
 */
struct nfsd_args {
	int	sock;		/* Socket to serve */
	caddr_t	name;		/* Client addr for connection based sockets */
	int	namelen;	/* Length of name */
};

struct nfsd_srvargs {
	struct nfsd	*nsd_nfsd;	/* Pointer to in kernel nfsd struct */
	uid_t		nsd_uid;	/* Effective uid mapped to cred */
	u_int32_t	nsd_haddr;	/* IP address of client */
	struct xucred	nsd_cr;		/* Cred. uid maps to */
	int		nsd_authlen;	/* Length of auth string (ret) */
	u_char		*nsd_authstr;	/* Auth string (ret) */
	int		nsd_verflen;	/* and the verifier */
	u_char		*nsd_verfstr;
	struct timeval	nsd_timestamp;	/* timestamp from verifier */
	u_int32_t	nsd_ttl;	/* credential ttl (sec) */
};

/*
 * Stats structure
 */
struct nfsstats {
	uint64_t	attrcache_hits;
	uint64_t	attrcache_misses;
	uint64_t	lookupcache_hits;
	uint64_t	lookupcache_misses;
	uint64_t	direofcache_hits;
	uint64_t	direofcache_misses;
	uint64_t	biocache_reads;
	uint64_t	read_bios;
	uint64_t	read_physios;
	uint64_t	biocache_writes;
	uint64_t	write_bios;
	uint64_t	write_physios;
	uint64_t	biocache_readlinks;
	uint64_t	readlink_bios;
	uint64_t	biocache_readdirs;
	uint64_t	readdir_bios;
	uint64_t	rpccnt[NFS_NPROCS];
	uint64_t	rpcretries;
	uint64_t	srvrpccnt[NFS_NPROCS];
	uint64_t	srvrpc_errs;
	uint64_t	srv_errs;
	uint64_t	rpcrequests;
	uint64_t	rpctimeouts;
	uint64_t	rpcunexpected;
	uint64_t	rpcinvalid;
	uint64_t	srvcache_inproghits;
	uint64_t	srvcache_idemdonehits;
	uint64_t	srvcache_nonidemdonehits;
	uint64_t	srvcache_misses;
	uint64_t	forcedsync;
	uint64_t	srvnqnfs_leases;
	uint64_t	srvnqnfs_maxleases;
	uint64_t	srvnqnfs_getleases;
	uint64_t	srvvop_writes;
};

/*
 * Flags for nfssvc() system call.
 */
#define	NFSSVC_BIOD	0x002
#define	NFSSVC_NFSD	0x004
#define	NFSSVC_ADDSOCK	0x008
#define	NFSSVC_AUTHIN	0x010
#define	NFSSVC_GOTAUTH	0x040
#define	NFSSVC_AUTHINFAIL 0x080
#define	NFSSVC_MNTD	0x100

/*
 * fs.nfs sysctl(3) identifiers
 */
#define	NFS_NFSSTATS	1	/* struct: struct nfsstats */
#define	NFS_NIOTHREADS	2	/* number of i/o threads */
#define	NFS_MAXID	3

#define FS_NFS_NAMES { \
			{ 0, 0 }, \
			{ "nfsstats", CTLTYPE_STRUCT }, \
			{ "iothreads", CTLTYPE_INT } \
}

/*
 * The set of signals the interrupt an I/O in progress for NFSMNT_INT mounts.
 * What should be in this set is open to debate, but I believe that since
 * I/O system calls on ufs are never interrupted by signals the set should
 * be minimal. My reasoning is that many current programs that use signals
 * such as SIGALRM will not expect file I/O system calls to be interrupted
 * by them and break.
 */
#ifdef _KERNEL
extern int nfs_niothreads;

struct uio; struct buf; struct vattr; struct nameidata;	/* XXX */

#define	NFSINT_SIGMASK	(sigmask(SIGINT)|sigmask(SIGTERM)|sigmask(SIGKILL)| \
			 sigmask(SIGHUP)|sigmask(SIGQUIT))

/*
 * Socket errors ignored for connectionless sockets??
 * For now, ignore them all
 */
#define	NFSIGNORE_SOERROR(s, e) \
		((e) != EINTR && (e) != ERESTART && (e) != EWOULDBLOCK && \
		((s) & PR_CONNREQUIRED) == 0)

/*
 * Nfs outstanding request list element
 */
struct nfsreq {
	TAILQ_ENTRY(nfsreq) r_chain;
	struct mbuf	*r_mreq;
	struct mbuf	*r_mrep;
	struct mbuf	*r_md;
	caddr_t		r_dpos;
	struct nfsmount *r_nmp;
	struct vnode	*r_vp;
	u_int32_t	r_xid;
	int		r_flags;	/* flags on request, see below */
	int		r_rexmit;	/* current retrans count */
	int		r_timer;	/* tick counter on reply */
	int		r_procnum;	/* NFS procedure number */
	int		r_rtt;		/* RTT for rpc */
	struct proc	*r_procp;	/* Proc that did I/O system call */
};

/* Flag values for r_flags */
#define R_TIMING	0x01		/* timing request (in mntp) */
#define R_SENT		0x02		/* request has been sent */
#define	R_SOFTTERM	0x04		/* soft mnt, too many retries */
#define	R_INTR		0x08		/* intr mnt, signal pending */
#define	R_SOCKERR	0x10		/* Fatal error on socket */
#define	R_TPRINTFMSG	0x20		/* Did a tprintf msg. */
#define	R_MUSTRESEND	0x40		/* Must resend request */

/*
 * On fast networks, the estimator will try to reduce the
 * timeout lower than the latency of the server's disks,
 * which results in too many timeouts, so cap the lower
 * bound.
 */
#define NFS_MINRTO	(NFS_HZ >> 2)

/*
 * Keep the RTO from increasing to unreasonably large values
 * when a server is not responding.
 */
#define NFS_MAXRTO	(20 * NFS_HZ)

enum nfs_rto_timers {
	NFS_DEFAULT_TIMER,
	NFS_GETATTR_TIMER,
	NFS_LOOKUP_TIMER,
	NFS_READ_TIMER,
	NFS_WRITE_TIMER,
};
#define NFS_MAX_TIMER	(NFS_WRITE_TIMER)

#define NFS_INITRTT	(NFS_HZ << 3)

/*
 * Network address hash list element
 */
union nethostaddr {
	u_int32_t had_inetaddr;
	struct mbuf *had_nam;
};

struct nfssvc_sock {
	TAILQ_ENTRY(nfssvc_sock) ns_chain; /* List of all nfssvc_sock's */
	struct file	*ns_fp;		/* fp from the... */
	struct socket	*ns_so;		/* ...socket this struct wraps */
	struct mbuf	*ns_nam;	/* MT_SONAME of client */
	struct mbuf	*ns_raw;	/* head of unpeeked mbufs */
	struct mbuf	*ns_rawend;	/* tail of unpeeked mbufs */
	struct mbuf	*ns_rec;	/* queued RPC records */
	struct mbuf	*ns_recend;	/* last queued RPC record */
	struct mbuf	*ns_frag;	/* end of record fragment */
	int		ns_flag;	/* socket status flags */
	int		ns_solock;	/* lock for connected socket */
	int		ns_cc;		/* actual chars queued */
	int		ns_reclen;	/* length of first queued record */
	u_int32_t	ns_sref;	/* # of refs to this struct */
};

/* Bits for "ns_flag" */
#define	SLP_VALID	0x01	/* connection is usable */
#define	SLP_DOREC	0x02	/* receive operation required */
#define	SLP_NEEDQ	0x04	/* connection has data to queue from socket */
#define	SLP_DISCONN	0x08	/* connection is closed */
#define	SLP_GETSTREAM	0x10	/* extracting RPC from TCP connection */
#define	SLP_LASTFRAG	0x20	/* last fragment received on TCP connection */
#define	SLP_ALLFLAGS	0xff	/* convenience */

/*
 * One of these structures is allocated for each nfsd.
 */
struct nfsd {
	TAILQ_ENTRY(nfsd) nfsd_chain;	/* List of all nfsd's */
	int		nfsd_flag;	/* NFSD_ flags */
	struct nfssvc_sock *nfsd_slp;	/* Current socket */
	struct proc	*nfsd_procp;	/* Proc ptr */
	struct nfsrv_descript *nfsd_nd;	/* Associated nfsrv_descript */
};

/* Bits for "nfsd_flag" */
#define	NFSD_WAITING	0x01
#define	NFSD_REQINPROG	0x02
#define	NFSD_NEEDAUTH	0x04
#define	NFSD_AUTHFAIL	0x08

/*
 * This structure is used by the server for describing each request.
 */
struct nfsrv_descript {
	struct mbuf		*nd_mrep;	/* Request mbuf list */
	struct mbuf		*nd_md;		/* Current dissect mbuf */
	struct mbuf		*nd_nam;	/* and socket addr */
	struct mbuf		*nd_nam2;	/* return socket addr */
	caddr_t			nd_dpos;	/* Current dissect pos */
	unsigned int		nd_procnum;	/* RPC # */
	int			nd_flag;	/* nd_flag */
	int			nd_repstat;	/* Reply status */
	u_int32_t		nd_retxid;	/* Reply xid */
	struct ucred		nd_cr;		/* Credentials */
};

/* Bits for "nd_flag" */
#define ND_NFSV3	0x08

extern struct pool nfsreqpl;
extern struct pool nfs_node_pool;
extern TAILQ_HEAD(nfsdhead, nfsd) nfsd_head;
extern int nfsd_head_flag;
#define	NFSD_CHECKSLP	0x01

#endif	/* _KERNEL */
#endif /* _NFS_NFS_H */
@


1.52
log
@Split the API: struct ucred remains the kernel internal structure while
struct xucred becomes the structure for syscalls (mount(2) and nfssvc(2)).

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.51 2009/09/02 18:20:54 thib Exp $	*/
a293 5

extern TAILQ_HEAD(nfssvc_sockhead, nfssvc_sock) nfssvc_sockhead;
extern int nfssvc_sockhead_flag;
#define	SLP_INIT	0x01	/* NFS data undergoing initialization */
#define	SLP_WANTINIT	0x02	/* thread waiting on NFS initialization */
@


1.51
log
@Backout the asyncio/aiod change, as it causes buf's to get hung.
problem noticed by deraadt@@

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.46 2009/08/10 09:38:44 thib Exp $	*/
d110 1
a110 1
	struct ucred	nsd_cr;		/* Cred. uid maps to */
@


1.50
log
@move to having requests on a per nfsmount tailq instead of one global one.
also make the rexmit timeout per nfsmount, and make sure to start/stop the
timer appropriately.

now the nfs_timer() only fires if there is work todo, not always at nfs_ticks
(it did, even if there where no nfsmounts in the system!).

OK blambert@@
@
text
@d58 1
a58 2
#define NFS_MAXASYNCDAEMON	64	/* Max. # of aiods runnable. */
#define NFS_DEFASYNCDAEMON	4	/* Def. # of aiods runnable. */
d192 2
@


1.49
log
@Rework the way we do async I/O in nfs. Introduce separate buf queues for
each mount, and when work is "found", peg an aiod to that mount todo the
I/O. Make nfs_asyncio() a bit smarter when deciding when to do asyncio
and when to force it sync, this is done by keeping the aiod's one two lists,
an "idle" and an "all" list, so asyncio is only done when there are aiods
hanging around todo it for us or are already pegged to the mount.

Idea liked by at least beck@@ (and I think art@@).
Extensive testing done by myself and jasper and a few others on various
arch's.

Ideas/Code from Net/Free.

OK blambert@@.
@
text
@a225 5
/*
 * Queue head for nfsreq's
 */
extern TAILQ_HEAD(nfsreqhead, nfsreq) nfs_reqq;

@


1.48
log
@add ddb functions to be able to show all the nfsnodes in the system
and rewrite the nfsreq code to use pool_walk().

OK beck@@, blambert@@
@
text
@d58 2
a59 1
#define	NFS_MAXASYNCDAEMON 	20	/* Max. number async_daemons runable */
a192 2
extern int nfs_niothreads;

@


1.47
log
@Use an RB tree instead of a hashtable for fh/node lookups.

Idea from NetBSD.

OK blambert@@
@
text
@d342 1
@


1.46
log
@Remove the v2 writegather code. It did help alot back in the 80s
but extensive performance benchmarking done by myself and jasper@@
has shown that it doesn't help, at all - even on vaxens and in some
cases it makes things significantly slower.

"this excites me sexually" jetpack@@
Tested by jasper@@.
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.43 2009/06/03 03:55:23 thib Exp $	*/
a264 3

#define	NFSNOHASH(fhsum) \
	(&nfsnodehashtbl[(fhsum) & nfsnodehash])
@


1.45
log
@don't give people any ideas. nfssvc(2) should not be used
by anyone besides nfsd(8).

ok  blambert@@
@
text
@a58 2
#define NFS_MAXGATHERDELAY	100	/* Max. write gather delay (msec) */
#define NFS_GATHERDELAY		10	/* Default write gather delay (msec) */
a265 9
/*
 * A list of nfssvc_sock structures is maintained with all the sockets
 * that require service by the nfsd.
 */
#ifndef NFS_WDELAYHASHSIZ
#define	NFS_WDELAYHASHSIZ 16	/* and with this */
#endif
#define	NWDELAYHASH(sock, f) \
	(&(sock)->ns_wdelayhashtbl[(*((u_int32_t *)(f))) % NFS_WDELAYHASHSIZ])
a291 3
	LIST_HEAD(, nfsrv_descript) ns_tq; /* Write gather lists */
	LIST_HEAD(nfsrvw_delayhash, nfsrv_descript)
			ns_wdelayhashtbl[NFS_WDELAYHASHSIZ];
a326 1
 * Some fields are used only when write request gathering is performed.
a328 6
	struct timeval		nd_time;	/* Write deadline */
	off_t			nd_off;		/* Start byte offset */
	off_t			nd_eoff;	/* and end byte offset */
	LIST_ENTRY(nfsrv_descript) nd_hash;	/* Hash list */
	LIST_ENTRY(nfsrv_descript) nd_tq;	/* and timer list */
	LIST_HEAD(,nfsrv_descript) nd_coalesce;	/* coalesced writes */
a330 1
	struct mbuf		*nd_mreq;	/* Reply mbuf list */
a334 1
	int			nd_stable;	/* storage type */
a335 1
	int			nd_len;		/* Length of this write */
a337 1
	fhandle_t		nd_fh;		/* File handle */
a342 3
#define ND_KERBNICK	0x20
#define ND_KERBFULL	0x40
#define ND_KERBAUTH	(ND_KERBNICK | ND_KERBFULL)
a347 12

/*
 * These macros compare nfsrv_descript structures.
 */
#define NFSW_CONTIG(o, n) \
		((o)->nd_eoff >= (n)->nd_off && \
		 !bcmp((caddr_t)&(o)->nd_fh, (caddr_t)&(n)->nd_fh, NFSX_V3FH))

#define NFSW_SAMECRED(o, n) \
	(((o)->nd_flag & ND_KERBAUTH) == ((n)->nd_flag & ND_KERBAUTH) && \
 	 !bcmp((caddr_t)&(o)->nd_cr, (caddr_t)&(n)->nd_cr, \
		sizeof (struct ucred)))
@


1.44
log
@Add some descriptive comments, because not having to read NFS code
is good for the brain.

ok thib@@
@
text
@d99 2
a100 2
 * Structures for the nfssvc(2) syscall. Not that anyone but nfsd and mount_nfs
 * should ever try and use it.
@


1.43
log
@
kill some unused defines, don't do an ifndef dance for
things that should be defined here and remove a silly
comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.42 2009/06/03 00:12:34 thib Exp $	*/
d289 17
a305 16
	TAILQ_ENTRY(nfssvc_sock) ns_chain;	/* List of all nfssvc_sock's */
	struct file	*ns_fp;
	struct socket	*ns_so;
	struct mbuf	*ns_nam;
	struct mbuf	*ns_raw;
	struct mbuf	*ns_rawend;
	struct mbuf	*ns_rec;
	struct mbuf	*ns_recend;
	struct mbuf	*ns_frag;
	int		ns_flag;
	int		ns_solock;
	int		ns_cc;
	int		ns_reclen;
	u_int32_t	ns_sref;
	LIST_HEAD(, nfsrv_descript) ns_tq;	/* Write gather lists */
	LIST_HEAD(nfsrvw_delayhash, nfsrv_descript) ns_wdelayhashtbl[NFS_WDELAYHASHSIZ];
d348 1
a348 1
	LIST_ENTRY(nfsrv_descript) nd_tq;		/* and timer list */
@


1.42
log
@Lift the NFS over UDP retransmit logic from FreeBSD.

OK blambert@@

FreeBSD commit message:
Refactor the NFS over UDP retransmit timeout estimation logic to allow
the estimator to be more easily tuned and maintained.

There should be no functional change except there is now a lower limit
on the retransmit timeout to prevent the client from retransmitting
faster than the server's disks can fill requests, and an upper limit
to prevent the estimator from taking to long to retransmit during a
server outage.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.41 2009/06/02 23:16:59 thib Exp $	*/
a40 5
/*
 * Tunable constants for nfs
 */

#define	NFS_MAXIOVEC	34
a48 1
#define	NFS_MAXWINDOW	1024		/* Max number of outstanding requests */
a50 1
#ifndef NFS_MINATTRTIMO
a51 2
#endif
#ifndef NFS_MAXATTRTIMO
a52 1
#endif
a59 1
#ifndef NFS_GATHERDELAY
d61 1
a61 1
#endif
@


1.41
log
@give the retransmission count booking keeping a facelift,
just store the maximun amount of rexmits in one place and
cleanup. Also make sure this only effects soft mounts.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.37 2009/01/24 23:25:17 thib Exp $	*/
d253 25
@


1.40
log
@retire the nfs rtt log code, this isnt really all that
usefull, and has been disabled for a long long time.
Cleans house a bit.

OK blambert@@
@
text
@a232 1
	int		r_retry;	/* max retransmission count */
@


1.39
log
@IO_METASYNC has been a noop since around 4.4BSD-Lite, the
idea never really caught on anywhere so retire it.

"gank this shizzle", blambert@@
@
text
@a347 1
	struct timeval		nd_starttime;	/* Time RPC initiated */
@


1.38
log
@Use a timespec for the server write deadline and procrastination
timeouts. Rrids us of the ugly cur_sec variable, and some shadows.
Also helps with granularity.

Diff from blambert@@ who asked me to commit this since he's away for
some days and we wanted to put this in with the timespec changes in
the nfsnode.
@
text
@a109 8
 * The IO_METASYNC flag should be implemented for local file systems.
 * (Until then, it is nothin at all.)
 */
#ifndef IO_METASYNC
#define IO_METASYNC	0
#endif

/*
@


1.37
log
@propagate the O_EXCL flag down to the file systems, by setting
VA_EXCLUSIVE. Handle this in NFS, also in NFS use arc4random()
for the create verifier instead of an uninitialized long and
the address of the first interface (which is likely to be lo0).

Lifted from NetBSD with small tweaks;
"looks good", miod@@
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.36 2009/01/18 21:15:53 blambert Exp $	*/
d338 1
a338 1
	u_quad_t		nd_time;	/* Write deadline (usec) */
@


1.36
log
@Remove unused members from struct nfsd.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.35 2008/09/12 16:55:37 thib Exp $	*/
a91 2
 * The VA_EXCLUSIVE flag should be added for va_vaflags and set for an
 * exclusive create.
a100 3
#endif
#ifndef VA_EXCLUSIVE
#define VA_EXCLUSIVE	0
@


1.35
log
@zap a deprecated macro, NMOD.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.34 2008/08/31 16:58:01 thib Exp $	*/
a327 4
	int		nfsd_authlen;	/* Authenticator len */
	u_char		nfsd_authstr[RPCAUTH_MAXSIZ]; /* Authenticator data */
	int		nfsd_verflen;	/* and the Verifier */
	u_char		nfsd_verfstr[RPCVERF_MAXSIZ];
@


1.34
log
@remove the #if 0'ed NFS_ATTRTIMEO() macro since it was
replaced by a function long ago..

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.33 2008/07/05 17:34:26 thib Exp $	*/
a82 1
#define	NMOD(a)		((a) % nfs_asyncdaemons)
@


1.33
log
@
Remove R_GETONEREP and the code that checks if its set
(its never set).

"please kill it" blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.32 2008/07/05 12:51:04 thib Exp $	*/
a120 11
#endif

/*
 * Set the attribute timeout based on how recently the file has been modified.
 */
#if 0 /* replaced by nfs_attrtimeo() in nfs_subs.c */
#define	NFS_ATTRTIMEO(np) \
	((((np)->n_flag & NMODIFIED) || \
	 (time_second - (np)->n_mtime) / 10 < NFS_MINATTRTIMO) ? NFS_MINATTRTIMO : \
	 ((time_second - (np)->n_mtime) / 10 > NFS_MAXATTRTIMO ? NFS_MAXATTRTIMO : \
	  (time_second - (np)->n_mtime) / 10))
@


1.32
log
@
Clean up some old dead code, mostly nqnfs and kerberos leftovers
for uid goo, mostly zapping unused members from various structures.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.31 2008/06/12 19:14:15 thib Exp $	*/
a278 1
#define	R_GETONEREP	0x80		/* Probe for one reply only */
@


1.31
log
@add a statistic bit to count how often we change async to sync

you need to upgrade nfsstat and the relevant header files

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.30 2008/06/08 18:23:03 thib Exp $	*/
a67 1
#define	NFS_MAXUIDHASH	64		/* Max. # of hashed uid entries/mp */
a156 10
struct nfsd_cargs {
	char		*ncd_dirp;	/* Mount dir path */
	uid_t		ncd_authuid;	/* Effective uid */
	int		ncd_authtype;	/* Type of authenticator */
	u_int		ncd_authlen;	/* Length of authenticator string */
	u_char		*ncd_authstr;	/* Authenticator string */
	u_int		ncd_verflen;	/* and the verifier */
	u_char		*ncd_verfstr;
};

a283 2
 * The nfsuid structs hang off of the nfssvc_sock structs in both lru
 * and uid hash lists.
a284 5
#ifndef NFS_UIDHASHSIZ
#define	NFS_UIDHASHSIZ	29	/* Tune the size of nfssvc_sock with this */
#endif
#define	NUIDHASH(sock, uid) \
	(&(sock)->ns_uidhashtbl[(uid) % NFS_UIDHASHSIZ])
a289 5
#ifndef NFS_MUIDHASHSIZ
#define NFS_MUIDHASHSIZ	67	/* Tune the size of nfsmount with this */
#endif
#define	NMUIDHASH(nmp, uid) \
	(&(nmp)->nm_uidhashtbl[(uid) % NFS_MUIDHASHSIZ])
a300 18
struct nfsuid {
	TAILQ_ENTRY(nfsuid) nu_lru;	/* LRU chain */
	LIST_ENTRY(nfsuid) nu_hash;	/* Hash list */
	int		nu_flag;	/* Flags */
	union nethostaddr nu_haddr;	/* Host addr. for dgram sockets */
	struct ucred	nu_cr;		/* Cred uid mapped to */
	int		nu_expire;	/* Expiry time (sec) */
	struct timeval	nu_timestamp;	/* Kerb. timestamp */
	u_int32_t	nu_nickname;	/* Nickname on server */
};

#define	nu_inetaddr	nu_haddr.had_inetaddr
#define	nu_nam		nu_haddr.had_nam
/* Bits for nu_flag */
#define	NU_INETADDR	0x1
#define NU_NAM		0x2
#define NU_NETFAM(u)	(((u)->nu_flag & NU_INETADDR) ? AF_INET : AF_ISO)

a302 1
	TAILQ_HEAD(, nfsuid) ns_uidlruhead;
a314 1
	int		ns_numuids;
a316 1
	LIST_HEAD(, nfsuid) ns_uidhashtbl[NFS_UIDHASHSIZ];
@


1.30
log
@remove a bunch of kerberos definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.29 2008/04/22 18:31:12 blambert Exp $	*/
d201 1
@


1.29
log
@Add comments detailing what the SLP_* flag #define's mean

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.28 2007/01/16 17:52:18 thib Exp $	*/
a155 1
	NFSKERBKEY_T	nsd_key;	/* Session key */
a165 1
	NFSKERBKEY_T	ncd_key;	/* Session key */
a331 1
	NFSKERBKEY_T	nu_key;		/* and session key */
@


1.28
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.27 2006/09/20 21:56:21 thib Exp $	*/
d367 7
a373 7
#define	SLP_VALID	0x01
#define	SLP_DOREC	0x02
#define	SLP_NEEDQ	0x04
#define	SLP_DISCONN	0x08
#define	SLP_GETSTREAM	0x10
#define	SLP_LASTFRAG	0x20
#define SLP_ALLFLAGS	0xff
d377 2
a378 2
#define	SLP_INIT	0x01
#define	SLP_WANTINIT	0x02
@


1.27
log
@Fix the way delays between request retransmissions are calculated
in the case where NFSERR_TRYLATER is received from the server.

Adapted from NetBSD.
ok pedro@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.26 2006/05/29 16:49:42 avsm Exp $	*/
a429 4
#define	ND_READ		LEASE_READ
#define ND_WRITE	LEASE_WRITE
#define ND_CHECK	0x04
#define ND_LEASE	(ND_READ | ND_WRITE | ND_CHECK)
@


1.26
log
@revert vfs.nfs.privport sysctl, broke a few architectures
requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.24 2005/06/08 04:17:14 marius Exp $	*/
d52 1
@


1.25
log
@Add support for NFS mounts to be from non-reserved ports:

- new sysctl vfs.nfs.privport to require NFS mount requests to be on
reserved ports when set to 1 (the default).
- mountd now automatically sets the sysctl depending on the -n flag.
- add mountd_flags to rc.conf to enable the -n flag at boot.
deraadt@@ ok
@
text
@d224 1
a224 2
#define	NFS_PRIVPORT	3	/* whether priv ports are needed */
#define	NFS_MAXID	4
d229 1
a229 2
			{ "iothreads", CTLTYPE_INT }, \
			{ "privport", CTLTYPE_INT } \
@


1.24
log
@make nfsstats counters 64 bit.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.23 2005/04/02 01:00:38 mickey Exp $	*/
d224 2
a225 1
#define	NFS_MAXID	3
d230 2
a231 1
			{ "iothreads", CTLTYPE_INT } \
@


1.23
log
@use pool for struct nfsreq; tedu@@ pedro@@ ok and testing by mark patruck <mark@@2ls4agd.net> on several archs
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.22 2004/06/21 23:50:37 tholo Exp $	*/
d173 33
a205 33
	int	attrcache_hits;
	int	attrcache_misses;
	int	lookupcache_hits;
	int	lookupcache_misses;
	int	direofcache_hits;
	int	direofcache_misses;
	int	biocache_reads;
	int	read_bios;
	int	read_physios;
	int	biocache_writes;
	int	write_bios;
	int	write_physios;
	int	biocache_readlinks;
	int	readlink_bios;
	int	biocache_readdirs;
	int	readdir_bios;
	int	rpccnt[NFS_NPROCS];
	int	rpcretries;
	int	srvrpccnt[NFS_NPROCS];
	int	srvrpc_errs;
	int	srv_errs;
	int	rpcrequests;
	int	rpctimeouts;
	int	rpcunexpected;
	int	rpcinvalid;
	int	srvcache_inproghits;
	int	srvcache_idemdonehits;
	int	srvcache_nonidemdonehits;
	int	srvcache_misses;
	int	srvnqnfs_leases;
	int	srvnqnfs_maxleases;
	int	srvnqnfs_getleases;
	int	srvvop_writes;
@


1.22
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.21 2003/10/22 04:45:54 jmc Exp $	*/
d438 1
@


1.21
log
@typos from Jared Yanovich;
also sync with header, and change spacing a little to prevent
line breaks;
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.20 2003/06/02 23:28:19 millert Exp $	*/
d129 3
a131 3
	 (time.tv_sec - (np)->n_mtime) / 10 < NFS_MINATTRTIMO) ? NFS_MINATTRTIMO : \
	 ((time.tv_sec - (np)->n_mtime) / 10 > NFS_MAXATTRTIMO ? NFS_MAXATTRTIMO : \
	  (time.tv_sec - (np)->n_mtime) / 10))
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.19 2003/03/28 10:14:27 jmc Exp $	*/
d151 1
a151 1
	int		nsd_verflen;	/* and the verfier */
@


1.19
log
@Ip -> IP;

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.18 2002/10/29 12:47:06 art Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@Get rid of some commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.17 2002/02/10 22:02:05 nate Exp $	*/
d151 1
a151 1
	u_int32_t	nsd_haddr;	/* Ip address of client */
@


1.17
log
@theo doesn't like this code
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.16 2002/01/11 01:20:56 nate Exp $	*/
d284 1
a284 1
TAILQ_HEAD(, nfsreq) nfs_reqq;
d378 2
a379 2
TAILQ_HEAD(, nfssvc_sock) nfssvc_sockhead;
int nfssvc_sockhead_flag;
d442 2
a443 2
TAILQ_HEAD(, nfsd) nfsd_head;
int nfsd_head_flag;
@


1.16
log
@Add a new sysctl that removes the requirement for reserved ports to be
used by the nfs server.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.15 2001/12/19 08:58:06 art Exp $	*/
d228 1
a228 2
#define NFS_NORSVPORT	3	/* if > 0, don't require reserved port */
#define	NFS_MAXID	4
d233 1
a233 2
			{ "iothreads", CTLTYPE_INT }, \
			{ "norsvport", CTLTYPE_INT } \
a245 1
extern int nfs_norsvport;
@


1.15
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.13 2001/09/16 00:42:44 millert Exp $	*/
d228 2
a229 1
#define	NFS_MAXID	3
d234 2
a235 1
			{ "iothreads", CTLTYPE_INT } \
d248 1
@


1.14
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d81 1
a81 10
#if 1
/*
 * XXXUBC temp hack because of the removal of b_validend.
 * eventually we'll store NFS VDIR data in the page cache as well,
 * we'll fix this at that point.
 */
#define	NFS_DIRBLKSIZ		PAGE_SIZE
#define	NFS_READDIRBLKSIZ	PAGE_SIZE
#else
#define	NFS_DIRBLKSIZ		1024	/* Must be a multiple of DIRBLKSIZ */
a82 1
#endif
d114 2
a115 2
 * Use the vm_page flag reserved for pager use to indicate pages
 * which have been written to the server but not yet committed.
d117 1
a117 1
#define	PG_NEEDCOMMIT	PG_PAGER1
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.16 2002/01/11 01:20:56 nate Exp $	*/
d238 1
a238 2
#define NFS_NORSVPORT	3	/* if > 0, don't require reserved port */
#define	NFS_MAXID	4
d243 1
a243 2
			{ "iothreads", CTLTYPE_INT }, \
			{ "norsvport", CTLTYPE_INT } \
a255 1
extern int nfs_norsvport;
@


1.14.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.14.2.1 2002/01/31 22:55:47 niklas Exp $	*/
d81 9
d92 1
d127 1
a127 1
#define PG_NEEDCOMMIT	PG_PAGER1
@


1.14.2.3
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.14.2.2 2002/02/02 03:28:26 art Exp $	*/
d228 2
a229 1
#define	NFS_MAXID	3
d234 2
a235 1
			{ "iothreads", CTLTYPE_INT } \
d248 1
@


1.14.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d151 1
a151 1
	u_int32_t	nsd_haddr;	/* IP address of client */
d284 1
a284 1
extern TAILQ_HEAD(nfsreqhead, nfsreq) nfs_reqq;
d378 2
a379 2
extern TAILQ_HEAD(nfssvc_sockhead, nfssvc_sock) nfssvc_sockhead;
extern int nfssvc_sockhead_flag;
d442 2
a443 2
extern TAILQ_HEAD(nfsdhead, nfsd) nfsd_head;
extern int nfsd_head_flag;
@


1.13
log
@Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.12 2001/08/19 18:16:31 art Exp $	*/
d81 10
a90 1
#define	NFS_DIRBLKSIZ	1024		/* Must be a multiple of DIRBLKSIZ */
d92 1
d124 2
a125 2
 * The B_INVAFTERWRITE flag should be set to whatever is required by the
 * buffer cache code to say "Invalidate the block after it is written back".
d127 1
a127 1
#define	B_INVAFTERWRITE	B_INVAL
@


1.12
log
@Remove some more.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.11 2001/06/25 03:28:05 csapuntz Exp $	*/
d166 1
a166 1
	int		ncd_authlen;	/* Length of authenticator string */
d168 1
a168 1
	int		ncd_verflen;	/* and the verifier */
@


1.11
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.10 2000/05/22 17:33:18 mickey Exp $	*/
a136 14

/*
 * Expected allocation sizes for major data structures. If the actual size
 * of the structure exceeds these sizes, then malloc() will be allocating
 * almost twice the memory required. This is used in nfs_init() to warn
 * the sysadmin that the size of a structure should be reduced.
 * (These sizes are always a power of 2. If the kernel malloc() changes
 *  to one that does not allocate space in powers of 2 size, then this all
 *  becomes bunk!)
 */
#define NFS_NODEALLOC	256
#define NFS_MNTALLOC	512
#define NFS_SVCALLOC	256
#define NFS_UIDALLOC	128
@


1.10
log
@NFS_MAXID
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.9 2000/05/19 16:54:52 mickey Exp $	*/
a440 1
	u_int32_t		nd_duration;	/* Lease duration */
a451 1
#define ND_NQNFS	0x10
@


1.10.4.1
log
@MFS (from millert):
Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.10 2000/05/22 17:33:18 mickey Exp $	*/
d180 1
a180 1
	u_int		ncd_authlen;	/* Length of authenticator string */
d182 1
a182 1
	u_int		ncd_verflen;	/* and the verifier */
@


1.10.2.1
log
@MFC:
Add some missing lengths checks when passing data from userland to the
kernel. From NetBSD via millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.13 2001/09/16 00:42:44 millert Exp $	*/
d180 1
a180 1
	u_int		ncd_authlen;	/* Length of authenticator string */
d182 1
a182 1
	u_int		ncd_verflen;	/* and the verifier */
@


1.9
log
@oops, s/niothreads/iothreads/ in FS_NFS_NAMES
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.8 2000/05/19 16:36:03 mickey Exp $	*/
d242 1
@


1.8
log
@from tsarna@@netbsd.org (sysctl changes to come later):
Death to nfsiod!

It is replaced by kernel threads that do the same thing. The number of
kernel threads used is set with the vfs.nfs.iothreads sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.7 1998/05/25 09:12:26 deraadt Exp $	*/
d246 1
a246 1
			{ "niothreads", CTLTYPE_INT } \
@


1.7
log
@nd_procnum should be unsigned; ovg@@nusun.jinr.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.6 1996/12/17 03:46:37 dm Exp $	*/
d240 2
a241 1
#define NFS_NFSSTATS	1		/* struct: struct nfsstats */
d244 3
a246 2
		       { 0, 0 }, \
		       { "nfsstats", CTLTYPE_STRUCT }, \
d258 1
a473 1

@


1.7.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.10 2000/05/22 17:33:18 mickey Exp $	*/
d240 1
a240 3
#define	NFS_NFSSTATS	1	/* struct: struct nfsstats */
#define	NFS_NIOTHREADS	2	/* number of i/o threads */
#define	NFS_MAXID	3
d243 2
a244 3
			{ 0, 0 }, \
			{ "nfsstats", CTLTYPE_STRUCT }, \
			{ "iothreads", CTLTYPE_INT } \
a255 1
extern int nfs_niothreads;
d471 1
@


1.7.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.7.8.1 2001/05/14 22:44:56 niklas Exp $	*/
d441 1
d453 1
@


1.7.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.7.8.2 2001/07/04 10:55:45 niklas Exp $	*/
d139 14
d180 1
a180 1
	u_int		ncd_authlen;	/* Length of authenticator string */
d182 1
a182 1
	u_int		ncd_verflen;	/* and the verifier */
@


1.7.8.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
a81 10
#if 1
/*
 * XXXUBC temp hack because of the removal of b_validend.
 * eventually we'll store NFS VDIR data in the page cache as well,
 * we'll fix this at that point.
 */
#define	NFS_DIRBLKSIZ		PAGE_SIZE
#define	NFS_READDIRBLKSIZ	PAGE_SIZE
#else
#define	NFS_DIRBLKSIZ		1024	/* Must be a multiple of DIRBLKSIZ */
a82 1
#endif
d114 2
a115 2
 * Use the vm_page flag reserved for pager use to indicate pages
 * which have been written to the server but not yet committed.
d117 1
a117 1
#define	PG_NEEDCOMMIT	PG_PAGER1
@


1.7.8.5
log
@Merge in trunk
@
text
@d81 10
a90 1
#define	NFS_DIRBLKSIZ	1024		/* Must be a multiple of DIRBLKSIZ */
d92 1
d124 2
a125 2
 * The B_INVAFTERWRITE flag should be set to whatever is required by the
 * buffer cache code to say "Invalidate the block after it is written back".
d127 1
a127 1
#define	B_INVAFTERWRITE	B_INVAL
@


1.7.8.6
log
@Sync the SMP branch with 3.3
@
text
@d284 1
a284 1
extern TAILQ_HEAD(nfsreqhead, nfsreq) nfs_reqq;
d378 2
a379 2
extern TAILQ_HEAD(nfssvc_sockhead, nfssvc_sock) nfssvc_sockhead;
extern int nfssvc_sockhead_flag;
d442 2
a443 2
extern TAILQ_HEAD(nfsdhead, nfsd) nfsd_head;
extern int nfsd_head_flag;
@


1.7.8.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.7.8.6 2003/03/28 00:08:46 niklas Exp $	*/
d151 1
a151 1
	u_int32_t	nsd_haddr;	/* IP address of client */
@


1.7.8.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.7.8.7 2003/05/13 19:36:56 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.8.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d151 1
a151 1
	int		nsd_verflen;	/* and the verifier */
@


1.6
log
@NFS attribute cache timeout mount param
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.h,v 1.5 1996/06/10 07:28:52 deraadt Exp $	*/
d431 1
a431 1
	int			nd_procnum;	/* RPC # */
@


1.5
log
@align correct for 64 bit in NWDELAYHASH
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 1
d136 1
@


1.4
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d2 1
a2 1
/*	$NetBSD: nfs.h,v 1.10 1996/02/18 11:53:38 fvdl Exp $	*/
d319 1
a319 1
	(&(sock)->ns_wdelayhashtbl[(*((u_long *)(f))) % NFS_WDELAYHASHSIZ])
@


1.3
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
d3 1
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 1
a1 2
/*	$NetBSD: nfs.h,v 1.9 1995/12/19 23:07:21 cgd Exp $	*/

d3 1
a3 1
 * Copyright (c) 1989, 1993
d37 1
a37 1
 *	@@(#)nfs.h	8.1 (Berkeley) 6/10/93
d40 3
d48 6
a53 5
#define NFS_HZ		25		/* Ticks per second for NFS timeouts */
#define	NFS_TIMEO	(1*NFS_HZ)	/* Default timeout = 1 second */
#define	NFS_MINTIMEO	(1*NFS_HZ)	/* Min timeout to use */
#define	NFS_MAXTIMEO	(60*NFS_HZ)	/* Max timeout to backoff to */
#define	NFS_MINIDEMTIMEO (5*NFS_HZ)	/* Min timeout for non-idempotent ops*/
d58 1
d60 2
d63 1
d66 1
a68 1
#define	NFS_MAXREADDIR	NFS_MAXDATA	/* Max. size of directory read */
d70 15
a84 2
#define	NFS_MAXASYNCDAEMON 20	/* Max. number async_daemons runable */
#define	NFS_DIRBLKSIZ	1024		/* Size of an NFS directory block */
d86 38
d135 14
d154 1
a154 1
	caddr_t	name;		/* Client address for connection based sockets */
d164 6
a169 1
	char		*nsd_authstr;	/* Auth string (ret) */
d177 4
a180 1
	char		*ncd_authstr;	/* Authenticator string */
d219 1
d234 10
d252 3
a301 2
struct nfsstats nfsstats;

d308 3
a310 1
#define	NUIDHASHSIZ	32
d312 13
a324 1
	(&(sock)->ns_uidhashtbl[(uid) & (sock)->ns_uidhash])
a337 1
	uid_t		nu_uid;		/* Uid mapped by this entry */
d340 4
d350 2
a355 5
	LIST_HEAD(, nfsuid) *ns_uidhashtbl;
	u_long		ns_uidhash;

	int		ns_flag;
	u_int32_t	ns_sref;
a357 1
	int		ns_solock;
a358 1
	int		ns_cc;
a360 1
	int		ns_reclen;
d363 5
d369 4
d381 1
d393 9
a401 16
	TAILQ_ENTRY(nfsd) nd_chain;	/* List of all nfsd's */
	int		nd_flag;	/* NFSD_ flags */
	struct nfssvc_sock *nd_slp;	/* Current socket */
	struct mbuf	*nd_nam;	/* Client addr for datagram req. */
	struct mbuf	*nd_mrep;	/* Req. mbuf list */
	struct mbuf	*nd_md;
	caddr_t		nd_dpos;	/* Position in list */
	int		nd_procnum;	/* RPC procedure number */
	u_int32_t	nd_retxid;	/* RPC xid */
	int		nd_repstat;	/* Reply status value */
	struct ucred	nd_cr;		/* Credentials for req. */
	int		nd_nqlflag;	/* Leasing flag */
	int		nd_duration;	/* Lease duration */
	int		nd_authlen;	/* Authenticator len */
	u_char		nd_authstr[RPCAUTH_MAXSIZ]; /* Authenticator data */
	struct proc	*nd_procp;	/* Proc ptr */
d404 1
a404 1
/* Bits for "nd_flag" */
d410 40
d454 12
d467 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfs.h,v 1.8 1995/03/26 20:37:29 jtc Exp $	*/
d89 1
a89 1
	u_long		nsd_haddr;	/* Ip address of client */
d183 1
a183 1
	u_long		r_xid;
d224 1
a224 1
	u_long had_inetaddr;
d249 1
a249 1
	u_long		ns_sref;
d288 1
a288 1
	u_long		nd_retxid;	/* RPC xid */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
