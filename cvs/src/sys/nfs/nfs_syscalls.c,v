head	1.111;
access;
symbols
	OPENBSD_6_1:1.107.0.4
	OPENBSD_6_1_BASE:1.107
	OPENBSD_6_0:1.104.0.4
	OPENBSD_6_0_BASE:1.104
	OPENBSD_5_9:1.104.0.2
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.103.0.4
	OPENBSD_5_8_BASE:1.103
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.97.0.4
	OPENBSD_5_6_BASE:1.97
	OPENBSD_5_5:1.96.0.4
	OPENBSD_5_5_BASE:1.96
	OPENBSD_5_4:1.95.0.2
	OPENBSD_5_4_BASE:1.95
	OPENBSD_5_3:1.94.0.2
	OPENBSD_5_3_BASE:1.94
	OPENBSD_5_2:1.93.0.2
	OPENBSD_5_2_BASE:1.93
	OPENBSD_5_1_BASE:1.92
	OPENBSD_5_1:1.92.0.6
	OPENBSD_5_0:1.92.0.4
	OPENBSD_5_0_BASE:1.92
	OPENBSD_4_9:1.92.0.2
	OPENBSD_4_9_BASE:1.92
	OPENBSD_4_8:1.91.0.2
	OPENBSD_4_8_BASE:1.91
	OPENBSD_4_7:1.88.0.2
	OPENBSD_4_7_BASE:1.88
	OPENBSD_4_6:1.82.0.4
	OPENBSD_4_6_BASE:1.82
	OPENBSD_4_5:1.76.0.2
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.70.0.2
	OPENBSD_4_4_BASE:1.70
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.55.0.2
	OPENBSD_4_2_BASE:1.55
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.38
	SMP_SYNC_B:1.38
	OPENBSD_3_5:1.38.0.4
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	UBC_SYNC_A:1.36
	OPENBSD_3_3:1.35.0.2
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.34
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.8
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.111
date	2017.09.01.15.05.31;	author mpi;	state Exp;
branches;
next	1.110;
commitid	gLJLYG7mRiAwqMZc;

1.110
date	2017.08.09.14.22.58;	author mpi;	state Exp;
branches;
next	1.109;
commitid	GJO8GK5dYKFAsbOx;

1.109
date	2017.06.27.12.02.43;	author mpi;	state Exp;
branches;
next	1.108;
commitid	yfTuwTXinKA8ckkX;

1.108
date	2017.05.17.08.59.05;	author mpi;	state Exp;
branches;
next	1.107;
commitid	op8dYC5Ko5T3xuC5;

1.107
date	2017.02.22.11.42.46;	author mpi;	state Exp;
branches;
next	1.106;
commitid	QPdM5oUknMlUIDue;

1.106
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.105;
commitid	RlO92XR575sygHqm;

1.105
date	2016.08.30.07.12.49;	author dlg;	state Exp;
branches;
next	1.104;
commitid	Azi9BJ1uL9Pnlws6;

1.104
date	2015.09.04.11.50.33;	author kettenis;	state Exp;
branches;
next	1.103;
commitid	kJ0oNATF7GAMvrie;

1.103
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	ncpqEGjDtSFuLAgn;

1.102
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.101;
commitid	9ERVupAoYqW4Iok9;

1.101
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.100;
commitid	h7z8lokZ0dFyuWpg;

1.100
date	2015.05.06.08.52.17;	author mpi;	state Exp;
branches;
next	1.99;
commitid	8Nt1erARPXBfs0Oe;

1.99
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.98;
commitid	p4LJxGKbi0BU2cG6;

1.98
date	2014.11.15.00.03.12;	author tedu;	state Exp;
branches;
next	1.97;
commitid	DARBwcixOE2oqaWx;

1.97
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.96;
commitid	FE3DG5cICjyI4jWx;

1.96
date	2013.11.03.13.50.24;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2013.06.25.02.53.47;	author beck;	state Exp;
branches;
next	1.94;

1.94
date	2012.12.10.22.34.53;	author beck;	state Exp;
branches;
next	1.93;

1.93
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.92;

1.92
date	2010.12.05.12.18.00;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.31.20.48.32;	author blambert;	state Exp;
branches;
next	1.89;

1.89
date	2010.04.12.16.37.38;	author beck;	state Exp;
branches;
next	1.88;

1.88
date	2009.10.19.22.24.18;	author jsg;	state Exp;
branches;
next	1.87;

1.87
date	2009.09.02.18.20.54;	author thib;	state Exp;
branches;
next	1.86;

1.86
date	2009.08.20.15.04.24;	author thib;	state Exp;
branches;
next	1.85;

1.85
date	2009.08.10.09.38.44;	author thib;	state Exp;
branches;
next	1.84;

1.84
date	2009.07.20.16.49.40;	author thib;	state Exp;
branches;
next	1.83;

1.83
date	2009.07.20.11.47.58;	author blambert;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.25.15.49.26;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2009.06.06.18.06.22;	author art;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.04.01.02.42;	author blambert;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.03.22.14.29;	author blambert;	state Exp;
branches;
next	1.78;

1.78
date	2009.05.30.17.20.29;	author thib;	state Exp;
branches;
next	1.77;

1.77
date	2009.05.22.00.19.25;	author thib;	state Exp;
branches;
next	1.76;

1.76
date	2009.01.28.12.02.00;	author bluhm;	state Exp;
branches;
next	1.75;

1.75
date	2009.01.24.23.35.47;	author thib;	state Exp;
branches;
next	1.74;

1.74
date	2009.01.18.21.04.41;	author blambert;	state Exp;
branches;
next	1.73;

1.73
date	2008.12.24.02.43.52;	author thib;	state Exp;
branches;
next	1.72;

1.72
date	2008.09.12.15.41.40;	author thib;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.08.20.44.38;	author blambert;	state Exp;
branches;
next	1.70;

1.70
date	2008.07.06.16.54.48;	author thib;	state Exp;
branches;
next	1.69;

1.69
date	2008.07.06.13.33.54;	author thib;	state Exp;
branches;
next	1.68;

1.68
date	2008.07.05.12.51.04;	author thib;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.26.23.56.26;	author blambert;	state Exp;
branches;
next	1.66;

1.66
date	2008.06.14.19.33.58;	author beck;	state Exp;
branches;
next	1.65;

1.65
date	2008.06.13.22.19.35;	author blambert;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.11.00.44.53;	author thib;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.02.13.26.27;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2008.04.22.19.18.24;	author blambert;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.14.19.34.41;	author thib;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.25.20.40.00;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.31.20.03.43;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.31.03.01.12;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.28.06.13.07;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.27.21.14.41;	author thib;	state Exp;
branches;
next	1.50;

1.50
date	2006.11.29.12.24.18;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.10.04.12.04.40;	author pedro;	state Exp;
branches;
next	1.48;

1.48
date	2006.06.25.15.01.54;	author sturm;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.14.20.01.50;	author sturm;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.30.14.20.07;	author sturm;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.30.10.35.08;	author pedro;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.01.02.54.57;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.26.21.22.14;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.07.16.15.01.51;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.25.00.54.28;	author tholo;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.15.20.32.20;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.02.23.28.20;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.07.02.06.31;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.29.12.47.06;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2002.08.23.22.21.44;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.24.23.32.11;	author nordin;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.12.14.02.23;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.11.15.45.44;	author hin;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.12.13.05.32;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.10.22.02.05;	author nate;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.05.16.02.27;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.20.23.51.29;	author hugh;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.11.01.20.56;	author nate;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.11.15.23.15.15;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.26.05.19.35;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.25.03.28.11;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.23.14.52.51;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.09.17.23.38;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.24.17.41.12;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.19.16.36.03;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.07.04.47.53;	author assar;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	97.12.02.16.57.58;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.11.06.05.59.03;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.20.20.50;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.15.23.43;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.03.30.20.02.32;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.06.14.04.41.08;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.30.33;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.17.04.50.33;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.31.13.15.56;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.09.24.57;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2001.05.14.22.44.57;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.07.04.10.55.50;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.13.2.9;

1.13.2.9
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.06.11.03.32.04;	author art;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2003.05.19.22.36.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.111
log
@Change sosetopt() to no longer free the mbuf it receives and change
all the callers to call m_freem(9).

Support from deraadt@@ and tedu@@, ok visa@@, bluhm@@
@
text
@/*	$OpenBSD: nfs_syscalls.c,v 1.110 2017/08/09 14:22:58 mpi Exp $	*/
/*	$NetBSD: nfs_syscalls.c,v 1.19 1996/02/18 11:53:52 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_syscalls.c	8.5 (Berkeley) 3/30/95
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/namei.h>
#include <sys/syslog.h>
#include <sys/filedesc.h>
#include <sys/signalvar.h>
#include <sys/kthread.h>
#include <sys/queue.h>

#include <sys/syscallargs.h>

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <nfs/xdr_subs.h>
#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/nfsrvcache.h>
#include <nfs/nfsmount.h>
#include <nfs/nfsnode.h>
#include <nfs/nfs_var.h>

/* Global defs. */
extern int nfs_numasync;
extern struct nfsstats nfsstats;
struct nfssvc_sock *nfs_udpsock;
int nfsd_waiting = 0;

#ifdef NFSSERVER
struct pool nfsrv_descript_pl;

int nfsrv_getslp(struct nfsd *nfsd);

static int nfs_numnfsd = 0;
int (*nfsrv3_procs[NFS_NPROCS])(struct nfsrv_descript *,
    struct nfssvc_sock *, struct proc *, struct mbuf **) = {
	nfsrv_null,
	nfsrv_getattr,
	nfsrv_setattr,
	nfsrv_lookup,
	nfsrv3_access,
	nfsrv_readlink,
	nfsrv_read,
	nfsrv_write,
	nfsrv_create,
	nfsrv_mkdir,
	nfsrv_symlink,
	nfsrv_mknod,
	nfsrv_remove,
	nfsrv_rmdir,
	nfsrv_rename,
	nfsrv_link,
	nfsrv_readdir,
	nfsrv_readdirplus,
	nfsrv_statfs,
	nfsrv_fsinfo,
	nfsrv_pathconf,
	nfsrv_commit,
	nfsrv_noop
};
#endif

TAILQ_HEAD(, nfssvc_sock) nfssvc_sockhead;
struct nfsdhead nfsd_head;

int nfssvc_sockhead_flag;
#define	SLP_INIT	0x01	/* NFS data undergoing initialization */
#define	SLP_WANTINIT	0x02	/* thread waiting on NFS initialization */
int nfsd_head_flag;

#ifdef NFSCLIENT
struct proc *nfs_asyncdaemon[NFS_MAXASYNCDAEMON];
int nfs_niothreads = -1;
#endif

int nfssvc_addsock(struct file *, struct mbuf *);
int nfssvc_nfsd(struct nfsd *);
void nfsrv_slpderef(struct nfssvc_sock *);
void nfsrv_zapsock(struct nfssvc_sock *);
void nfssvc_iod(void *);

/*
 * NFS server pseudo system call for the nfsd's
 * Based on the flag value it either:
 * - adds a socket to the selection list
 * - remains in the kernel as an nfsd
 */
int
sys_nfssvc(struct proc *p, void *v, register_t *retval)
{
	int error = 0;
#ifdef NFSSERVER
	struct sys_nfssvc_args /* {
		syscallarg(int) flag;
		syscallarg(caddr_t) argp;
	} */ *uap = v;
	int flags = SCARG(uap, flag);
	struct file *fp;
	struct mbuf *nam;
	struct nfsd_args nfsdarg;
	struct nfsd_srvargs nfsd_srvargs, *nsd = &nfsd_srvargs;
	struct nfsd *nfsd;
#endif

	/* Must be super user */
	error = suser(p, 0);
	if (error)
		return (error);

#ifndef NFSSERVER
	error = ENOSYS;
#else

	while (nfssvc_sockhead_flag & SLP_INIT) {
		nfssvc_sockhead_flag |= SLP_WANTINIT;
		tsleep(&nfssvc_sockhead, PSOCK, "nfsd init", 0);
	}

	switch (flags) {
	case NFSSVC_ADDSOCK:
		error = copyin(SCARG(uap, argp), &nfsdarg, sizeof(nfsdarg));
		if (error)
			return (error);

		error = getsock(p, nfsdarg.sock, &fp);
		if (error)
			return (error);

		/*
		 * Get the client address for connected sockets.
		 */
		if (nfsdarg.name == NULL || nfsdarg.namelen == 0)
			nam = NULL;
		else {
			error = sockargs(&nam, nfsdarg.name, nfsdarg.namelen,
				MT_SONAME);
			if (error) {
				FRELE(fp, p);
				return (error);
			}
		}
		error = nfssvc_addsock(fp, nam);
		FRELE(fp, p);
		break;
	case NFSSVC_NFSD:
		error = copyin(SCARG(uap, argp), nsd, sizeof(*nsd));
		if (error)
			return (error);

		nfsd = malloc(sizeof(*nfsd), M_NFSD, M_WAITOK|M_ZERO);
		nfsd->nfsd_procp = p;
		nfsd->nfsd_slp = NULL;

		error = nfssvc_nfsd(nfsd);
		break;
	default:
		error = EINVAL;
		break;
	}

	if (error == EINTR || error == ERESTART)
		error = 0;
#endif	/* !NFSSERVER */

	return (error);
}

#ifdef NFSSERVER
/*
 * Adds a socket to the list for servicing by nfsds.
 */
int
nfssvc_addsock(struct file *fp, struct mbuf *mynam)
{
	struct mbuf *m;
	int siz;
	struct nfssvc_sock *slp;
	struct socket *so;
	struct nfssvc_sock *tslp;
	int s, error;

	so = (struct socket *)fp->f_data;
	tslp = NULL;
	/*
	 * Add it to the list, as required.
	 */
	if (so->so_proto->pr_protocol == IPPROTO_UDP) {
		tslp = nfs_udpsock;
		if (tslp->ns_flag & SLP_VALID) {
			m_freem(mynam);
			return (EPERM);
		}
	}
	if (so->so_type == SOCK_STREAM)
		siz = NFS_MAXPACKET + sizeof (u_long);
	else
		siz = NFS_MAXPACKET;
	s = solock(so);
	error = soreserve(so, siz, siz); 
	if (error) {
		sounlock(s);
		m_freem(mynam);
		return (error);
	}

	/*
	 * Set protocol specific options { for now TCP only } and
	 * reserve some space. For datagram sockets, this can get called
	 * repeatedly for the same socket, but that isn't harmful.
	 */
	if (so->so_type == SOCK_STREAM) {
		MGET(m, M_WAIT, MT_SOOPTS);
		*mtod(m, int32_t *) = 1;
		m->m_len = sizeof(int32_t);
		sosetopt(so, SOL_SOCKET, SO_KEEPALIVE, m);
		m_freem(m);
	}
	if (so->so_proto->pr_domain->dom_family == AF_INET &&
	    so->so_proto->pr_protocol == IPPROTO_TCP) {
		MGET(m, M_WAIT, MT_SOOPTS);
		*mtod(m, int32_t *) = 1;
		m->m_len = sizeof(int32_t);
		sosetopt(so, IPPROTO_TCP, TCP_NODELAY, m);
		m_freem(m);
	}
	so->so_rcv.sb_flags &= ~SB_NOINTR;
	so->so_rcv.sb_timeo = 0;
	so->so_snd.sb_flags &= ~SB_NOINTR;
	so->so_snd.sb_timeo = 0;
	sounlock(s);
	if (tslp)
		slp = tslp;
	else {
		slp = malloc(sizeof(*slp), M_NFSSVC, M_WAITOK|M_ZERO);
		TAILQ_INSERT_TAIL(&nfssvc_sockhead, slp, ns_chain);
	}
	slp->ns_so = so;
	slp->ns_nam = mynam;
	fp->f_count++;
	slp->ns_fp = fp;
	so->so_upcallarg = (caddr_t)slp;
	so->so_upcall = nfsrv_rcv;
	slp->ns_flag = (SLP_VALID | SLP_NEEDQ);
	nfsrv_wakenfsd(slp);
	return (0);
}

/*
 * Called by nfssvc() for nfsds. Just loops around servicing rpc requests
 * until it is killed by a signal.
 */
int
nfssvc_nfsd(struct nfsd *nfsd)
{
	struct mbuf *m;
	int siz;
	struct nfssvc_sock *slp;
	struct socket *so;
	int *solockp;
	struct nfsrv_descript *nd = NULL;
	struct mbuf *mreq;
	int error = 0, cacherep, sotype;

	cacherep = RC_DOIT;

	TAILQ_INSERT_TAIL(&nfsd_head, nfsd, nfsd_chain);
	nfs_numnfsd++;

	/* Loop getting rpc requests until SIGKILL. */
loop:
	if (!ISSET(nfsd->nfsd_flag, NFSD_REQINPROG)) {

		/* attach an nfssvc_sock to nfsd */
		error = nfsrv_getslp(nfsd);
		if (error)
			goto done;

		slp = nfsd->nfsd_slp;

		if (ISSET(slp->ns_flag, SLP_VALID)) {
			if (ISSET(slp->ns_flag, SLP_DISCONN)) {
				nfsrv_zapsock(slp);
			} else if (ISSET(slp->ns_flag, SLP_NEEDQ)) {
				CLR(slp->ns_flag, SLP_NEEDQ);
				nfs_sndlock(&slp->ns_solock, NULL);
				nfsrv_rcv(slp->ns_so, (caddr_t)slp, M_WAIT);
				nfs_sndunlock(&slp->ns_solock);
			}

			error = nfsrv_dorec(slp, nfsd, &nd);
			SET(nfsd->nfsd_flag, NFSD_REQINPROG);
		}
	} else {
		error = 0;
		slp = nfsd->nfsd_slp;
	}

	if (error || !ISSET(slp->ns_flag, SLP_VALID)) {
		if (nd != NULL) {
			pool_put(&nfsrv_descript_pl, nd);
			nd = NULL;
		}
		nfsd->nfsd_slp = NULL;
		CLR(nfsd->nfsd_flag, NFSD_REQINPROG);
		nfsrv_slpderef(slp);
		goto loop;
	}

	so = slp->ns_so;
	sotype = so->so_type;
	if (ISSET(so->so_proto->pr_flags, PR_CONNREQUIRED))
		solockp = &slp->ns_solock;
	else
		solockp = NULL;

	if (nd) {
		if (nd->nd_nam2)
			nd->nd_nam = nd->nd_nam2;
		else
			nd->nd_nam = slp->ns_nam;
	}

	cacherep = nfsrv_getcache(nd, slp, &mreq);
	switch (cacherep) {
	case RC_DOIT:
		error = (*(nfsrv3_procs[nd->nd_procnum]))(nd, slp, nfsd->nfsd_procp, &mreq);
		if (mreq == NULL) {
			if (nd != NULL) {
				m_freem(nd->nd_nam2);
				m_freem(nd->nd_mrep);
			}
			break;
		}
		if (error) {
			nfsstats.srv_errs++;
			nfsrv_updatecache(nd, 0, mreq);
			m_freem(nd->nd_nam2);
			break;
		}
		nfsstats.srvrpccnt[nd->nd_procnum]++;
		nfsrv_updatecache(nd, 1, mreq);
		nd->nd_mrep = NULL;

		/* FALLTHROUGH */
	case RC_REPLY:
		m = mreq;
		siz = 0;
		while (m) {
			siz += m->m_len;
			m = m->m_next;
		}

		if (siz <= 0 || siz > NFS_MAXPACKET)
			panic("bad nfs svc reply, siz = %i", siz);

		m = mreq;
		m->m_pkthdr.len = siz;
		m->m_pkthdr.ph_ifidx = 0;

		/* For stream protocols, prepend a Sun RPC Record Mark. */
		if (sotype == SOCK_STREAM) {
			M_PREPEND(m, NFSX_UNSIGNED, M_WAIT);
			*mtod(m, u_int32_t *) = htonl(0x80000000 | siz);
		}

		if (solockp)
			nfs_sndlock(solockp, NULL);

		if (ISSET(slp->ns_flag, SLP_VALID))
		    error = nfs_send(so, nd->nd_nam2, m, NULL);
		else {
		    error = EPIPE;
		    m_freem(m);
		}
		m_freem(nd->nd_nam2);
		m_freem(nd->nd_mrep);
		if (error == EPIPE)
			nfsrv_zapsock(slp);
		if (solockp)
			nfs_sndunlock(solockp);
		if (error == EINTR || error == ERESTART) {
			pool_put(&nfsrv_descript_pl, nd);
			nfsrv_slpderef(slp);
			goto done;
		}
		break;
	case RC_DROPIT:
		m_freem(nd->nd_mrep);
		m_freem(nd->nd_nam2);
		break;
	};

	if (nd) {
		pool_put(&nfsrv_descript_pl, nd);
		nd = NULL;
	}

	if (nfsrv_dorec(slp, nfsd, &nd)) {
		nfsd->nfsd_flag &= ~NFSD_REQINPROG;
		nfsd->nfsd_slp = NULL;
		nfsrv_slpderef(slp);
	}
	goto loop;

done:
	TAILQ_REMOVE(&nfsd_head, nfsd, nfsd_chain);
	free(nfsd, M_NFSD, sizeof(*nfsd));
	if (--nfs_numnfsd == 0)
		nfsrv_init(1);	/* Reinitialize everything */
	return (error);
}

/*
 * Shut down a socket associated with an nfssvc_sock structure.
 * Should be called with the send lock set, if required.
 * The trick here is to increment the sref at the start, so that the nfsds
 * will stop using it and clear ns_flag at the end so that it will not be
 * reassigned during cleanup.
 */
void
nfsrv_zapsock(struct nfssvc_sock *slp)
{
	struct socket *so;
	struct file *fp;
	struct mbuf *m, *n;

	slp->ns_flag &= ~SLP_ALLFLAGS;
	fp = slp->ns_fp;
	if (fp) {
		FREF(fp);
		slp->ns_fp = NULL;
		so = slp->ns_so;
		so->so_upcall = NULL;
		soshutdown(so, SHUT_RDWR);
		closef(fp, NULL);
		if (slp->ns_nam)
	    		m = m_free(slp->ns_nam);
		m_freem(slp->ns_raw);
		m = slp->ns_rec;
		while (m) {
			n = m->m_nextpkt;
			m_freem(m);
			m = n;
		}
	}
}

/*
 * Derefence a server socket structure. If it has no more references and
 * is no longer valid, you can throw it away.
 */
void
nfsrv_slpderef(struct nfssvc_sock *slp)
{
	if (--(slp->ns_sref) == 0 && (slp->ns_flag & SLP_VALID) == 0) {
		TAILQ_REMOVE(&nfssvc_sockhead, slp, ns_chain);
		free(slp, M_NFSSVC, sizeof(*slp));
	}
}

/*
 * Initialize the data structures for the server.
 * Handshake with any new nfsds starting up to avoid any chance of
 * corruption.
 */
void
nfsrv_init(int terminating)
{
	struct nfssvc_sock *slp, *nslp;

	if (nfssvc_sockhead_flag & SLP_INIT)
		panic("nfsd init");
	nfssvc_sockhead_flag |= SLP_INIT;
	if (terminating) {
		for (slp = TAILQ_FIRST(&nfssvc_sockhead); slp != NULL;
		    slp = nslp) {
			nslp = TAILQ_NEXT(slp, ns_chain);
			if (slp->ns_flag & SLP_VALID)
				nfsrv_zapsock(slp);
			TAILQ_REMOVE(&nfssvc_sockhead, slp, ns_chain);
			free(slp, M_NFSSVC, sizeof(*slp));
		}
		nfsrv_cleancache();	/* And clear out server cache */
	}

	TAILQ_INIT(&nfssvc_sockhead);
	nfssvc_sockhead_flag &= ~SLP_INIT;
	if (nfssvc_sockhead_flag & SLP_WANTINIT) {
		nfssvc_sockhead_flag &= ~SLP_WANTINIT;
		wakeup((caddr_t)&nfssvc_sockhead);
	}

	TAILQ_INIT(&nfsd_head);
	nfsd_head_flag &= ~NFSD_CHECKSLP;

	nfs_udpsock =  malloc(sizeof(*nfs_udpsock), M_NFSSVC,
	    M_WAITOK|M_ZERO);
	TAILQ_INSERT_HEAD(&nfssvc_sockhead, nfs_udpsock, ns_chain);

	if (!terminating) {
		pool_init(&nfsrv_descript_pl, sizeof(struct nfsrv_descript),
		    0, IPL_NONE, PR_WAITOK, "ndscpl", NULL);
	}
}
#endif /* NFSSERVER */

#ifdef NFSCLIENT
/*
 * Asynchronous I/O threads for client nfs.
 * They do read-ahead and write-behind operations on the block I/O cache.
 * Never returns unless it fails or gets killed.
 */
void
nfssvc_iod(void *arg)
{
	struct proc *p = curproc;
	struct buf *bp, *nbp;
	int i, myiod;
	struct vnode *vp;
	int error = 0, s, bufcount;

	bufcount = MIN(256, bcstats.kvaslots / 8);
	bufcount = MIN(bufcount, bcstats.numbufs / 8);

	/* Assign my position or return error if too many already running. */
	myiod = -1;
	for (i = 0; i < NFS_MAXASYNCDAEMON; i++) {
		if (nfs_asyncdaemon[i] == NULL) {
			myiod = i;
			break;
		}
	}
	if (myiod == -1)
		kthread_exit(EBUSY);

	nfs_asyncdaemon[myiod] = p;
	nfs_numasync++;

	/* Upper limit on how many bufs we'll queue up for this iod. */
	if (nfs_bufqmax > bcstats.kvaslots / 4) {
		nfs_bufqmax = bcstats.kvaslots / 4;
		bufcount = 0;
	} 
	if (nfs_bufqmax > bcstats.numbufs / 4) {
		nfs_bufqmax = bcstats.numbufs / 4;
		bufcount = 0;
	}

	nfs_bufqmax += bufcount;
	wakeup(&nfs_bufqlen); /* wake up anyone waiting for room to enqueue IO */

	/* Just loop around doin our stuff until SIGKILL. */
	for (;;) {
	    while (TAILQ_FIRST(&nfs_bufq) == NULL && error == 0) {
		    error = tsleep(&nfs_bufq,
			PWAIT | PCATCH, "nfsidl", 0);
	    }
	    while ((bp = TAILQ_FIRST(&nfs_bufq)) != NULL) {
		/* Take one off the front of the list */
		TAILQ_REMOVE(&nfs_bufq, bp, b_freelist);
		nfs_bufqlen--;
		wakeup_one(&nfs_bufqlen);
		if (bp->b_flags & B_READ)
		    (void) nfs_doio(bp, NULL);
		else do {
		    /*
		     * Look for a delayed write for the same vnode, so I can do 
		     * it now. We must grab it before calling nfs_doio() to
		     * avoid any risk of the vnode getting vclean()'d while
		     * we are doing the write rpc.
		     */
		    vp = bp->b_vp;
		    s = splbio();
		    LIST_FOREACH(nbp, &vp->v_dirtyblkhd, b_vnbufs) {
			if ((nbp->b_flags &
			    (B_BUSY|B_DELWRI|B_NEEDCOMMIT|B_NOCACHE))!=B_DELWRI)
			    continue;
			nbp->b_flags |= B_ASYNC;
			bremfree(nbp);
			buf_acquire(nbp);
			break;
		    }
		    /*
		     * For the delayed write, do the first part of nfs_bwrite()
		     * up to, but not including nfs_strategy().
		     */
		    if (nbp) {
			nbp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
			buf_undirty(nbp);
			nbp->b_vp->v_numoutput++;
		    }
		    splx(s);

		    (void) nfs_doio(bp, NULL);
		} while ((bp = nbp) != NULL);
	    }
	    if (error) {
		nfs_asyncdaemon[myiod] = NULL;
		nfs_numasync--;
		nfs_bufqmax -= bufcount;
		kthread_exit(error);
	    }
	}
}

void
nfs_getset_niothreads(int set)
{
	int i, have, start;
	
	for (have = 0, i = 0; i < NFS_MAXASYNCDAEMON; i++)
		if (nfs_asyncdaemon[i] != NULL)
			have++;

	if (set) {
		/* clamp to sane range */
		nfs_niothreads = max(0, min(nfs_niothreads, NFS_MAXASYNCDAEMON));

		start = nfs_niothreads - have;

		while (start > 0) {
			kthread_create(nfssvc_iod, NULL, NULL, "nfsio");
			start--;
		}

		for (i = 0; (start < 0) && (i < NFS_MAXASYNCDAEMON); i++)
			if (nfs_asyncdaemon[i] != NULL) {
				psignal(nfs_asyncdaemon[i], SIGKILL);
				start++;
			}
	} else {
		if (nfs_niothreads >= 0)
			nfs_niothreads = have;
	}
}
#endif /* NFSCLIENT */

#ifdef NFSSERVER
/*
 * Find an nfssrv_sock for nfsd, sleeping if needed.
 */
int
nfsrv_getslp(struct nfsd *nfsd)
{
	struct nfssvc_sock *slp;
	int error;

again:
	while (nfsd->nfsd_slp == NULL &&
	    (nfsd_head_flag & NFSD_CHECKSLP) == 0) {
		nfsd->nfsd_flag |= NFSD_WAITING;
		nfsd_waiting++;
		error = tsleep(nfsd, PSOCK | PCATCH, "nfsd", 0);
		nfsd_waiting--;
		if (error)
			return (error);
	}

	if (nfsd->nfsd_slp == NULL &&
	    (nfsd_head_flag & NFSD_CHECKSLP) != 0) {
		TAILQ_FOREACH(slp, &nfssvc_sockhead, ns_chain) {
			if ((slp->ns_flag & (SLP_VALID | SLP_DOREC)) ==
			    (SLP_VALID | SLP_DOREC)) {
				slp->ns_flag &= ~SLP_DOREC;
				slp->ns_sref++;
				nfsd->nfsd_slp = slp;
				break;
			}
		}
		if (slp == NULL)
			nfsd_head_flag &= ~NFSD_CHECKSLP;
	}

	if (nfsd->nfsd_slp == NULL)
		goto again;

	return (0);
}
#endif /* NFSSERVER */
@


1.110
log
@Move the socket lock "above" sosetopt(), sogetopt() and sosplice().

Protect the fields modifieds by sosetopt() and simplify the dance
with the stars.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.109 2017/06/27 12:02:43 mpi Exp $	*/
d268 1
d276 1
@


1.109
log
@Add missing solock()/sounlock() dances around sbreserve().

While here document an abuse of parent socket's lock.

Problem reported by krw@@, analysis and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.108 2017/05/17 08:59:05 mpi Exp $	*/
a251 1
	sounlock(s);
d253 1
d280 1
d284 1
a284 2
		slp = malloc(sizeof(*slp), M_NFSSVC,
		    M_WAITOK|M_ZERO);
@


1.108
log
@Remove useless splsoftnet().

Outside of USB, no code is executed in a softnet interrupt context.  So
what's protecting NFS data structures is the KERNEL_LOCK().

But more importantly, since r1.114 of nfs_socket.c, the 'softnet' thread
is no longer executing NFS code.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.107 2017/02/22 11:42:46 mpi Exp $	*/
d232 1
a232 1
	int error;
d250 1
d252 1
@


1.107
log
@Keep local definitions local.

"good work" deraadt@@, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.106 2016/09/15 02:00:18 dlg Exp $	*/
d232 1
a232 1
	int error, s;
a288 1
	s = splsoftnet();
a292 1
	splx(s);
d310 1
a310 1
	int error = 0, cacherep, s, sotype;
a313 1
	s = splsoftnet();
a356 2
	splx(s);

a431 1
			s = splsoftnet();
a445 1
	s = splsoftnet();
a454 1
	splx(s);
@


1.106
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.105 2016/08/30 07:12:49 dlg Exp $	*/
d115 1
a115 1
struct nfssvc_sockhead nfssvc_sockhead;
d119 2
d127 6
@


1.105
log
@pool_setipl for nfs pools

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.104 2015/09/04 11:50:33 kettenis Exp $	*/
d550 1
a550 2
		    0, 0, PR_WAITOK, "ndscpl", NULL);
		pool_setipl(&nfsrv_descript_pl, IPL_NONE);
@


1.104
log
@The nfsrv_descript_pl pool never gets used in interrupt context.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.103 2015/07/15 22:16:42 deraadt Exp $	*/
d548 1
a548 1
	if (!terminating)
d551 2
@


1.103
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.102 2015/07/08 07:21:50 mpi Exp $	*/
d550 1
a550 1
		    0, 0, 0, "ndscpl", &pool_allocator_nointr);
@


1.102
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.101 2015/06/16 11:09:40 mpi Exp $	*/
d382 1
a382 2
			if (nd->nd_nam2)
				m_freem(nd->nd_nam2);
d420 2
a421 4
		if (nd->nd_nam2)
			m_freem(nd->nd_nam2);
		if (nd->nd_mrep)
			m_freem(nd->nd_mrep);
@


1.101
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.100 2015/05/06 08:52:17 mpi Exp $	*/
d488 1
a488 1
			MFREE(slp->ns_nam, m);
@


1.100
log
@Pass a thread pointer instead of its file descriptor table to getsock(9).

Diff from Vitaliy Makkoveev.

Manpage tweak and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.99 2015/03/14 03:38:52 jsg Exp $	*/
d404 1
a404 1
		m->m_pkthdr.rcvif = NULL;
@


1.99
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.98 2014/11/15 00:03:12 tedu Exp $	*/
d169 1
a169 1
		error = getsock(p->p_fd, nfsdarg.sock, &fp);
@


1.98
log
@add sizes for free(ptr, sizeof(*ptr)). use sizeof(*ptr) for malloc sizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.97 2014/07/12 18:43:52 tedu Exp $	*/
a69 1
#include <nfs/nfsm_subs.h>
@


1.97
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.96 2013/11/03 13:50:24 miod Exp $	*/
d274 1
a274 1
		slp = malloc(sizeof(struct nfssvc_sock), M_NFSSVC,
d459 1
a459 1
	free((caddr_t)nfsd, M_NFSD, 0);
d509 1
a509 1
		free((caddr_t)slp, M_NFSSVC, 0);
d533 1
a533 1
			free((caddr_t)slp, M_NFSSVC, 0);
d548 1
a548 1
	nfs_udpsock =  malloc(sizeof(struct nfssvc_sock), M_NFSSVC,
@


1.96
log
@Fix bogus kthread_create() usage leading to wrong struct proc * pointer
usage in the nfs kthreads. Spotted by fgsch@@, similar diff by guenther@@,
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.95 2013/06/25 02:53:47 beck Exp $	*/
d459 1
a459 1
	free((caddr_t)nfsd, M_NFSD);
d509 1
a509 1
		free((caddr_t)slp, M_NFSSVC);
d533 1
a533 1
			free((caddr_t)slp, M_NFSSVC);
@


1.95
log
@When we remove work from the nfs queue, wake up people waiting for
room to queue IO right away, rather than waiting for us to complete the IO
we are working on and potentially do a many buffers DELWRI dance before
waking up the sleepers so they can continue.

ok guether@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.94 2012/12/10 22:34:53 beck Exp $	*/
d567 1
a567 1
	struct proc *p = (struct proc *)arg;
a659 1
	struct proc *p;
d673 1
a673 1
			kthread_create(nfssvc_iod, p, &p, "nfsio");
@


1.94
log
@Ensure NFS will only consume up to 1/4 of the available buffer
mapping kva when busying up buffers in an nfsiod. (this in
addition to the previous check for 1/4 of the total buffer space)
This makes sparc installs work over nfsv2.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.93 2012/04/22 05:43:14 guenther Exp $	*/
d613 1
a646 1
		wakeup_one(&nfs_bufqlen); /* wake up anyone waiting for room to enqueue IO */
@


1.93
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.92 2010/12/05 12:18:00 kettenis Exp $	*/
d573 2
a574 1
	bufcount = 256;	/* XXX: Big enough? sysctl, constant ? */
d591 4
d596 1
a596 1
		nfs_bufqmax = bcstats.numbufs / 4; /* limit to 1/4 of bufs */
@


1.92
log
@Make sure we only initialize the nfsrv_descript_pl pool once.
Re-initializing the pool everytime nfsd(8) terminates is very bad since it
screws up the list of pools resulting in infinite loops when traversing that
list.  Issue found by Daniel Melameth.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.91 2010/08/07 03:50:02 krw Exp $	*/
d183 1
a183 1
				FRELE(fp);
d188 1
a188 1
		FRELE(fp);
@


1.91
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.90 2010/07/31 20:48:32 blambert Exp $	*/
d552 3
a554 2
	pool_init(&nfsrv_descript_pl, sizeof(struct nfsrv_descript), 0, 0, 0,
	    "ndscpl", &pool_allocator_nointr);
@


1.90
log
@another pair of files which relied on mbuf.h for pool.h; should be the last,
as the kernel now compiles w/o ``#include <sys/pool.h>'' in mbuf.h; removing
that line, though, is for another day, as a userland program (systat, IIRC)
fails to build without it there.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.89 2010/04/12 16:37:38 beck Exp $	*/
d401 1
a401 1
			panic("bad nfs svc reply, siz = %i\n", siz);
@


1.89
log
@
Don't jump the queue if we have to wait on the client side because
the nfs_bufq is full - instead tsleep waiting for one of our nfsiod's
to free up space for us in the queue so we can enqueue on the end.

ok blambert@@, tedu@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.88 2009/10/19 22:24:18 jsg Exp $	*/
d45 1
@


1.88
log
@antsy
no binary change apart from nfsm_reqhead() which is clearly correct.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.87 2009/09/02 18:20:54 thib Exp $	*/
d594 1
d639 1
@


1.87
log
@Backout the asyncio/aiod change, as it causes buf's to get hung.
problem noticed by deraadt@@

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.83 2009/07/20 11:47:58 blambert Exp $	*/
d217 1
a217 3
nfssvc_addsock(fp, mynam)
	struct file *fp;
	struct mbuf *mynam;
d472 1
a472 2
nfsrv_zapsock(slp)
	struct nfssvc_sock *slp;
d504 1
a504 2
nfsrv_slpderef(slp)
	struct nfssvc_sock *slp;
d518 1
a518 2
nfsrv_init(terminating)
	int terminating;
d649 1
a649 2
nfs_getset_niothreads(set)
	int set;
@


1.86
log
@Rework the way we do async I/O in nfs. Introduce separate buf queues for
each mount, and when work is "found", peg an aiod to that mount todo the
I/O. Make nfs_asyncio() a bit smarter when deciding when to do asyncio
and when to force it sync, this is done by keeping the aiod's one two lists,
an "idle" and an "all" list, so asyncio is only done when there are aiods
hanging around todo it for us or are already pegged to the mount.

Idea liked by at least beck@@ (and I think art@@).
Extensive testing done by myself and jasper and a few others on various
arch's.

Ideas/Code from Net/Free.

OK blambert@@.
@
text
@d76 1
d121 5
d559 32
d592 96
@


1.85
log
@Remove the v2 writegather code. It did help alot back in the 80s
but extensive performance benchmarking done by myself and jasper@@
has shown that it doesn't help, at all - even on vaxens and in some
cases it makes things significantly slower.

"this excites me sexually" jetpack@@
Tested by jasper@@.
OK blambert@@
@
text
@a75 1
extern int nfs_numasync;
a119 5
#ifdef NFSCLIENT
struct proc *nfs_asyncdaemon[NFS_MAXASYNCDAEMON];
int nfs_niothreads = -1;
#endif

a552 32
#endif /* NFSSERVER */

#ifdef NFSCLIENT
/*
 * Asynchronous I/O threads for client nfs.
 * They do read-ahead and write-behind operations on the block I/O cache.
 * Never returns unless it fails or gets killed.
 */
void
nfssvc_iod(void *arg)
{
	struct proc *p = (struct proc *)arg;
	struct buf *bp, *nbp;
	int i, myiod;
	struct vnode *vp;
	int error = 0, s, bufcount;

	bufcount = 256;	/* XXX: Big enough? sysctl, constant ? */

	/* Assign my position or return error if too many already running. */
	myiod = -1;
	for (i = 0; i < NFS_MAXASYNCDAEMON; i++) {
		if (nfs_asyncdaemon[i] == NULL) {
			myiod = i;
			break;
		}
	}
	if (myiod == -1)
		kthread_exit(EBUSY);

	nfs_asyncdaemon[myiod] = p;
	nfs_numasync++;
a553 96
	/* Upper limit on how many bufs we'll queue up for this iod. */
	if (nfs_bufqmax > bcstats.numbufs / 4) {
		nfs_bufqmax = bcstats.numbufs / 4; /* limit to 1/4 of bufs */
		bufcount = 0;
	}

	nfs_bufqmax += bufcount;

	/* Just loop around doin our stuff until SIGKILL. */
	for (;;) {
	    while (TAILQ_FIRST(&nfs_bufq) == NULL && error == 0) {
		    error = tsleep(&nfs_bufq,
			PWAIT | PCATCH, "nfsidl", 0);
	    }
	    while ((bp = TAILQ_FIRST(&nfs_bufq)) != NULL) {
		/* Take one off the front of the list */
		TAILQ_REMOVE(&nfs_bufq, bp, b_freelist);
		nfs_bufqlen--;
		if (bp->b_flags & B_READ)
		    (void) nfs_doio(bp, NULL);
		else do {
		    /*
		     * Look for a delayed write for the same vnode, so I can do 
		     * it now. We must grab it before calling nfs_doio() to
		     * avoid any risk of the vnode getting vclean()'d while
		     * we are doing the write rpc.
		     */
		    vp = bp->b_vp;
		    s = splbio();
		    LIST_FOREACH(nbp, &vp->v_dirtyblkhd, b_vnbufs) {
			if ((nbp->b_flags &
			    (B_BUSY|B_DELWRI|B_NEEDCOMMIT|B_NOCACHE))!=B_DELWRI)
			    continue;
			nbp->b_flags |= B_ASYNC;
			bremfree(nbp);
			buf_acquire(nbp);
			break;
		    }
		    /*
		     * For the delayed write, do the first part of nfs_bwrite()
		     * up to, but not including nfs_strategy().
		     */
		    if (nbp) {
			nbp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
			buf_undirty(nbp);
			nbp->b_vp->v_numoutput++;
		    }
		    splx(s);

		    (void) nfs_doio(bp, NULL);
		} while ((bp = nbp) != NULL);
	    }
	    if (error) {
		nfs_asyncdaemon[myiod] = NULL;
		nfs_numasync--;
		nfs_bufqmax -= bufcount;
		kthread_exit(error);
	    }
	}
}

void
nfs_getset_niothreads(set)
	int set;
{
	struct proc *p;
	int i, have, start;
	
	for (have = 0, i = 0; i < NFS_MAXASYNCDAEMON; i++)
		if (nfs_asyncdaemon[i] != NULL)
			have++;

	if (set) {
		/* clamp to sane range */
		nfs_niothreads = max(0, min(nfs_niothreads, NFS_MAXASYNCDAEMON));

		start = nfs_niothreads - have;

		while (start > 0) {
			kthread_create(nfssvc_iod, p, &p, "nfsio");
			start--;
		}

		for (i = 0; (start < 0) && (i < NFS_MAXASYNCDAEMON); i++)
			if (nfs_asyncdaemon[i] != NULL) {
				psignal(nfs_asyncdaemon[i], SIGKILL);
				start++;
			}
	} else {
		if (nfs_niothreads >= 0)
			nfs_niothreads = have;
	}
}
#endif /* NFSCLIENT */

#ifdef NFSSERVER
@


1.84
log
@(struct foo *)0 -> NULL, every where I could find it.

OK blambert@@
@
text
@a77 2
extern int nfsrvw_procrastinate;
extern struct timeval nfsrvw_procrastinate_tv;
d306 1
a306 2
	int error = 0, cacherep, s, sotype, writes_todo;
	struct timeval tv;
a308 1
	writes_todo = 0;
a312 5
	/*
	 * Loop getting rpc requests until SIGKILL.
	 */
	for (;;) {
		if ((nfsd->nfsd_flag & NFSD_REQINPROG) == 0) {
d314 19
a332 28
			/* attach an nfssvc_sock to nfsd */
			error = nfsrv_getslp(nfsd);
			if (error)
				goto done;
			slp = nfsd->nfsd_slp;

			if (slp->ns_flag & SLP_VALID) {
				if (slp->ns_flag & SLP_DISCONN)
					nfsrv_zapsock(slp);
				else if (slp->ns_flag & SLP_NEEDQ) {
					slp->ns_flag &= ~SLP_NEEDQ;
					(void) nfs_sndlock(&slp->ns_solock,
						NULL);
					nfsrv_rcv(slp->ns_so, (caddr_t)slp,
						M_WAIT);
					nfs_sndunlock(&slp->ns_solock);
				}
				error = nfsrv_dorec(slp, nfsd, &nd);
				getmicrotime(&tv);
				if (error && LIST_FIRST(&slp->ns_tq) &&
				    timercmp(&LIST_FIRST(&slp->ns_tq)->nd_time,
				    &tv, <=)) {
					error = 0;
					cacherep = RC_DOIT;
					writes_todo = 1;
				} else
					writes_todo = 0;
				nfsd->nfsd_flag |= NFSD_REQINPROG;
d334 13
a346 13
		} else {
			error = 0;
			slp = nfsd->nfsd_slp;
		}
		if (error || (slp->ns_flag & SLP_VALID) == 0) {
			if (nd) {
				pool_put(&nfsrv_descript_pl, nd);
				nd = NULL;
			}
			nfsd->nfsd_slp = NULL;
			nfsd->nfsd_flag &= ~NFSD_REQINPROG;
			nfsrv_slpderef(slp);
			continue;
d348 18
a365 5
		splx(s);
		so = slp->ns_so;
		sotype = so->so_type;
		if (so->so_proto->pr_flags & PR_CONNREQUIRED)
			solockp = &slp->ns_solock;
a366 5
			solockp = NULL;
		if (nd) {
		    if (nd->nd_nam2)
			nd->nd_nam = nd->nd_nam2;
		    else
d368 1
d370 6
a375 68
		    cacherep = nfsrv_getcache(nd, slp, &mreq);
		}

		/*
		 * Loop to get all the write rpc relies that have been
		 * gathered together.
		 */
		do {
		    switch (cacherep) {
		    case RC_DOIT:
			if (writes_todo || (!(nd->nd_flag & ND_NFSV3) &&
			    nd->nd_procnum == NFSPROC_WRITE &&
			    nfsrvw_procrastinate > 0))
				error = nfsrv_writegather(&nd, slp,
				    nfsd->nfsd_procp, &mreq);
			else
				error = (*(nfsrv3_procs[nd->nd_procnum]))(nd,
				    slp, nfsd->nfsd_procp, &mreq);
			if (mreq == NULL) {
				if (nd != NULL) {
					m_freem(nd->nd_nam2);
					m_freem(nd->nd_mrep);
				}
				break;
			}
			if (error) {
				nfsstats.srv_errs++;
				nfsrv_updatecache(nd, 0, mreq);
				if (nd->nd_nam2)
					m_freem(nd->nd_nam2);
				break;
			}
			nfsstats.srvrpccnt[nd->nd_procnum]++;
			nfsrv_updatecache(nd, 1, mreq);
			nd->nd_mrep = NULL;

			/* FALLTHROUGH */
		    case RC_REPLY:
			m = mreq;
			siz = 0;
			while (m) {
				siz += m->m_len;
				m = m->m_next;
			}
			if (siz <= 0 || siz > NFS_MAXPACKET) {
				printf("mbuf siz=%d\n",siz);
				panic("Bad nfs svc reply");
			}
			m = mreq;
			m->m_pkthdr.len = siz;
			m->m_pkthdr.rcvif = NULL;
			/*
			 * For stream protocols, prepend a Sun RPC
			 * Record Mark.
			 */
			if (sotype == SOCK_STREAM) {
				M_PREPEND(m, NFSX_UNSIGNED, M_WAIT);
				*mtod(m, u_int32_t *) = htonl(0x80000000 | siz);
			}
			if (solockp)
				(void) nfs_sndlock(solockp, NULL);
			if (slp->ns_flag & SLP_VALID)
			    error = nfs_send(so, nd->nd_nam2, m, NULL);
			else {
			    error = EPIPE;
			    m_freem(m);
			}
			if (nd->nd_nam2)
a376 1
			if (nd->nd_mrep)
a377 9
			if (error == EPIPE)
				nfsrv_zapsock(slp);
			if (solockp)
				nfs_sndunlock(solockp);
			if (error == EINTR || error == ERESTART) {
		    		pool_put(&nfsrv_descript_pl, nd);
				nfsrv_slpderef(slp);
				s = splsoftnet();
				goto done;
d380 6
a385 3
		    case RC_DROPIT:
			m_freem(nd->nd_mrep);
			m_freem(nd->nd_nam2);
d387 29
a415 5
		    };
		    if (nd) {
		    	pool_put(&nfsrv_descript_pl, nd);
			nd = NULL;
		    }
d417 16
a432 18
		    /*
		     * Check to see if there are outstanding writes that
		     * need to be serviced.
		     */
		    getmicrotime(&tv);
		    s = splsoftclock();
		    if (LIST_FIRST(&slp->ns_tq) &&
			timercmp(&LIST_FIRST(&slp->ns_tq)->nd_time, &tv, <=)) {
			cacherep = RC_DOIT;
			writes_todo = 1;
		    } else
			writes_todo = 0;
		    splx(s);
		} while (writes_todo);
		s = splsoftnet();
		if (nfsrv_dorec(slp, nfsd, &nd)) {
			nfsd->nfsd_flag &= ~NFSD_REQINPROG;
			nfsd->nfsd_slp = NULL;
d434 2
d437 17
d455 2
a476 1
	struct nfsrv_descript *nwp, *nnwp;
a479 1
	int s;
a498 8
		s = splsoftclock();
		for (nwp = LIST_FIRST(&slp->ns_tq); nwp != NULL; nwp = nnwp) {
			nnwp = LIST_NEXT(nwp, nd_tq);
			LIST_REMOVE(nwp, nd_tq);
			pool_put(&nfsrv_descript_pl, nwp);
		}
		LIST_INIT(&slp->ns_tq);
		splx(s);
@


1.83
log
@For memory that gets allocated for every NFS request, pools make more
sense than malloc.

ok thib@@, who says the puffin still gets it either way
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.82 2009/06/25 15:49:26 thib Exp $	*/
d231 1
a231 1
	tslp = (struct nfssvc_sock *)0;
d335 1
a335 1
						(struct nfsreq *)0);
d361 1
a361 1
			nfsd->nfsd_slp = (struct nfssvc_sock *)0;
d372 1
a372 1
			solockp = (int *)0;
d413 1
a413 1
			nd->nd_mrep = (struct mbuf *)0;
d429 1
a429 1
			m->m_pkthdr.rcvif = (struct ifnet *)0;
d439 1
a439 1
				(void) nfs_sndlock(solockp, (struct nfsreq *)0);
@


1.82
log
@backout the buf_acquire() does the bremfree() since all callers
where doing bremfree() befure calling buf_acquire().

This is causing us headache pinning down a bug that showed up
when deraadt@@ too cvs to current, and will have to be done
anyway as a preperation for backouts.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.80 2009/06/04 01:02:42 blambert Exp $	*/
d84 2
d358 1
a358 1
				free((caddr_t)nd, M_NFSRVDESC);
d455 1
a455 1
				free((caddr_t)nd, M_NFSRVDESC);
d467 1
a467 1
		    	free(nd, M_NFSRVDESC);
d540 1
a540 1
			free((caddr_t)nwp, M_NFSRVDESC);
d600 3
@


1.81
log
@All caller of buf_acquire were doing bremfree before the call.
Just put it in the buf_acquire function.
oga@@ ok
@
text
@d666 1
@


1.80
log
@simplify argument list for nfssvc_nfsd()

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.79 2009/06/03 22:14:29 blambert Exp $	*/
a664 1
			bremfree(nbp);
@


1.79
log
@Place code to search for/sleep waiting for an nfs socket into its own
code; makes the cleaned-up function much more legible.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.78 2009/05/30 17:20:29 thib Exp $	*/
d146 1
d194 5
a198 1
		error = nfssvc_nfsd(nsd, SCARG(uap, argp), p);
d297 1
a297 4
nfssvc_nfsd(nsd, argp, p)
	struct nfsd_srvargs *nsd;
	caddr_t argp;
	struct proc *p;
a303 1
	struct nfsd *nfsd = nsd->nsd_nfsd;
d313 2
a314 7
	if (nfsd == NULL) {
		nsd->nsd_nfsd = nfsd = malloc(sizeof(struct nfsd), M_NFSD,
		    M_WAITOK|M_ZERO);
		nfsd->nfsd_procp = p;
		TAILQ_INSERT_TAIL(&nfsd_head, nfsd, nfsd_chain);
		nfs_numnfsd++;
	}
a493 1
	nsd->nsd_nfsd = (struct nfsd *)0;
@


1.78
log
@Remove unused procnums (NQNFS leftovers) and cleanup.

OK blambert@@ sometime ago
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.75 2009/01/24 23:35:47 thib Exp $	*/
d84 2
d324 7
a330 26
			while (nfsd->nfsd_slp == (struct nfssvc_sock *)0 &&
			    (nfsd_head_flag & NFSD_CHECKSLP) == 0) {
				nfsd->nfsd_flag |= NFSD_WAITING;
				nfsd_waiting++;
				error = tsleep((caddr_t)nfsd, PSOCK | PCATCH,
				    "nfsd", 0);
				nfsd_waiting--;
				if (error)
					goto done;
			}
			if (nfsd->nfsd_slp == NULL &&
			    (nfsd_head_flag & NFSD_CHECKSLP) != 0) {
				TAILQ_FOREACH(slp, &nfssvc_sockhead, ns_chain) {
				    if ((slp->ns_flag & (SLP_VALID | SLP_DOREC))
					== (SLP_VALID | SLP_DOREC)) {
					    slp->ns_flag &= ~SLP_DOREC;
					    slp->ns_sref++;
					    nfsd->nfsd_slp = slp;
					    break;
				    }
				}
				if (slp == 0)
					nfsd_head_flag &= ~NFSD_CHECKSLP;
			}
			if ((slp = nfsd->nfsd_slp) == (struct nfssvc_sock *)0)
				continue;
d731 43
@


1.77
log
@retire the nfs rtt log code, this isnt really all that
usefull, and has been disabled for a long long time.
Cleans house a bit.

OK blambert@@
@
text
@a108 3
	nfsrv_noop,
	nfsrv_noop,
	nfsrv_noop,
@


1.76
log
@Remove cur_usec variable that is no longer used.

ok blambert@@
@
text
@a72 1
#include <nfs/nfsrtt.h>
a76 1
extern int nfsrtton;
a84 1
static struct nfsdrt nfsdrt;
a126 4
#ifdef NFSSERVER
static void nfsd_rt(int, struct nfsrv_descript *, int);
#endif

a395 1
		    getmicrotime(&nd->nd_starttime);
a467 2
			if (nfsrtton)
				nfsd_rt(sotype, nd, cacherep);
a483 2
			if (nfsrtton)
				nfsd_rt(sotype, nd, cacherep);
a622 34
}

/*
 * Add entries to the server monitor log.
 */
static void
nfsd_rt(sotype, nd, cacherep)
	int sotype;
	struct nfsrv_descript *nd;
	int cacherep;
{
	struct drt *rt;

	rt = &nfsdrt.drt[nfsdrt.pos];
	if (cacherep == RC_DOIT)
		rt->flag = 0;
	else if (cacherep == RC_REPLY)
		rt->flag = DRT_CACHEREPLY;
	else
		rt->flag = DRT_CACHEDROP;
	if (sotype == SOCK_STREAM)
		rt->flag |= DRT_TCP;
	else if (nd->nd_flag & ND_NFSV3)
		rt->flag |= DRT_NFSV3;
	rt->proc = nd->nd_procnum;
	if (mtod(nd->nd_nam, struct sockaddr *)->sa_family == AF_INET)
		rt->ipadr = mtod(nd->nd_nam, struct sockaddr_in *)->sin_addr.s_addr;
	else
		rt->ipadr = INADDR_ANY;
	getmicrotime(&rt->tstamp);
	rt->resptime =
	    ((rt->tstamp.tv_sec - nd->nd_starttime.tv_sec) * 1000000) +
		(rt->tstamp.tv_usec - nd->nd_starttime.tv_usec);
	nfsdrt.pos = (nfsdrt.pos + 1) % NFSRTTLOGSIZ;
@


1.75
log
@Use a timespec for the server write deadline and procrastination
timeouts. Rrids us of the ugly cur_sec variable, and some shadows.
Also helps with granularity.

Diff from blambert@@ who asked me to commit this since he's away for
some days and we wanted to put this in with the timespec changes in
the nfsnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.74 2009/01/18 21:04:41 blambert Exp $	*/
a313 1
	u_quad_t cur_usec;
a370 2
				cur_usec = (u_quad_t)tv.tv_sec * 1000000 +
					(u_quad_t)tv.tv_usec;
a509 2
		    cur_usec = (u_quad_t)tv.tv_sec * 1000000 +
			(u_quad_t)tv.tv_usec;
@


1.74
log
@remove function which only called nfssvc_iod(), and pass nfssvc_iod()
to kthread_create()

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.73 2008/12/24 02:43:52 thib Exp $	*/
d81 1
a359 2
				struct timeval tv;

d375 2
a376 2
				    LIST_FIRST(&slp->ns_tq)->nd_time
				    <= cur_usec) {
d517 1
a517 1
			LIST_FIRST(&slp->ns_tq)->nd_time <= cur_usec) {
@


1.73
log
@Replace the TRUE/FALSE defines with 1/0 respectively. This doesn't
hurt readability and it was just plain annoying seeing them defined
in every other .c file.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.72 2008/09/12 15:41:40 thib Exp $	*/
d684 2
a685 3
int
nfssvc_iod(p)
	struct proc *p;
d687 1
d704 1
a704 1
		return (EBUSY);
d765 1
a765 1
		return (error);
a770 9
start_nfsio(arg)
	void *arg;
{
	nfssvc_iod(curproc);
	
	kthread_exit(0);
}

void
d774 1
d788 1
a788 1
			kthread_create(start_nfsio, NULL, NULL, "nfsio");
@


1.72
log
@move the declaration of nfsrv3_procs to nfs_syscalls.c

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.71 2008/08/08 20:44:38 blambert Exp $	*/
a123 3
#define	TRUE	1
#define	FALSE	0

d440 1
a440 1
				nfsrv_updatecache(nd, FALSE, mreq);
d446 1
a446 1
			nfsrv_updatecache(nd, TRUE, mreq);
d538 1
a538 1
		nfsrv_init(TRUE);	/* Reinitialize everything */
@


1.71
log
@After beck@@ changed the way nfsiod's are notified of work, the
nfs_iodwant array became unused. Garbage collect and free up
a few bytes.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.70 2008/07/06 16:54:48 thib Exp $	*/
a76 3
extern int32_t (*nfsrv3_procs[NFS_NPROCS])(struct nfsrv_descript *,
						struct nfssvc_sock *,
						struct proc *, struct mbuf **);
d83 1
d87 29
@


1.70
log
@
remove #ifndef nolint goo

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.69 2008/07/06 13:33:54 thib Exp $	*/
a79 1
extern struct proc *nfs_iodwant[NFS_MAXASYNCDAEMON];
@


1.69
log
@
Zap redundant prototype for nfsrv_zapsock();
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.68 2008/07/05 12:51:04 thib Exp $	*/
a292 1
#ifndef nolint
d295 1
a295 1
#endif
@


1.68
log
@
Clean up some old dead code, mostly nqnfs and kerberos leftovers
for uid goo, mostly zapping unused members from various structures.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.67 2008/06/26 23:56:26 blambert Exp $	*/
a74 2

void	nfsrv_zapsock(struct nfssvc_sock *);
@


1.67
log
@Label switch statement with /* FALLTHROUGH */; inspired by two
wasted hours tracking down a phantom mbuf leak.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.66 2008/06/14 19:33:58 beck Exp $	*/
a257 1
		TAILQ_INIT(&slp->ns_uidlruhead);
a532 1
	struct nfsuid *nuidp, *nnuidp;
a556 9
		for (nuidp = TAILQ_FIRST(&slp->ns_uidlruhead); nuidp != NULL;
		    nuidp = nnuidp) {
			nnuidp = TAILQ_NEXT(nuidp, nu_lru);
			LIST_REMOVE(nuidp, nu_hash);
			TAILQ_REMOVE(&slp->ns_uidlruhead, nuidp, nu_lru);
			if (nuidp->nu_flag & NU_NAM)
				m_freem(nuidp->nu_nam);
			free((caddr_t)nuidp, M_NFSUID);
		}
a619 1
	TAILQ_INIT(&nfs_udpsock->ns_uidlruhead);
@


1.66
log
@
Ensure each nfsiod can actually enqueue more than one asynchio - this mirrors
the accidental situation that used to happen when it leaked buffers and allowed
the syncer to do it, however this puts a limit on how much of the buffer cache
it is allowed to consume to a sensible amount - improves nfs write performance
since we don't have to do tons of them synch now.

Modifies the existing code to use wakeup_one instead of cruft, and now
all nfsiod's tsleep the same way.

ok thib@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.65 2008/06/13 22:19:35 blambert Exp $	*/
d429 2
@


1.65
log
@NFSD_NEEDAUTH and NFSD_AUTHFAIL are never set, so cull code that
depends on them being set. This should be the removal of the original
return-to-userland-to-authenticate code that was apparently an unfinished
experiment.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.64 2008/06/12 06:58:40 deraadt Exp $	*/
d681 1
a681 1
	int error = 0, s;
d683 3
a685 3
	/*
	 * Assign my position or return error if too many already running
	 */
d687 1
a687 1
	for (i = 0; i < NFS_MAXASYNCDAEMON; i++)
d692 1
d695 1
d698 10
a707 3
	/*
	 * Just loop around doin our stuff until SIGKILL
	 */
d710 1
a710 2
		nfs_iodwant[myiod] = p;
		error = tsleep((caddr_t)&nfs_iodwant[myiod],
d716 1
d754 1
@


1.64
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.60 2008/06/10 20:14:37 beck Exp $	*/
d394 1
a394 26
		    /*
		     * Check to see if authorization is needed.
		     */
		    if (nfsd->nfsd_flag & NFSD_NEEDAUTH) {
			nfsd->nfsd_flag &= ~NFSD_NEEDAUTH;
			nsd->nsd_haddr = mtod(nd->nd_nam,
			    struct sockaddr_in *)->sin_addr.s_addr;
			nsd->nsd_authlen = nfsd->nfsd_authlen;
			nsd->nsd_verflen = nfsd->nfsd_verflen;
			if (!copyout(nfsd->nfsd_authstr,nsd->nsd_authstr,
				nfsd->nfsd_authlen) &&
			    !copyout(nfsd->nfsd_verfstr, nsd->nsd_verfstr,
				nfsd->nfsd_verflen) &&
			    !copyout((caddr_t)nsd, argp, sizeof (*nsd))) {
			    return (ENEEDAUTH);
			}
			cacherep = RC_DROPIT;
		    } else
			cacherep = nfsrv_getcache(nd, slp, &mreq);

		    if (nfsd->nfsd_flag & NFSD_AUTHFAIL) {
			    nfsd->nfsd_flag &= ~NFSD_AUTHFAIL;
			    nd->nd_procnum = NFSPROC_NOOP;
			    nd->nd_repstat = (NFSERR_AUTHERR | AUTH_TOOWEAK);
			    cacherep = RC_DOIT;
		    }
@


1.63
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.59 2008/05/02 13:26:27 thib Exp $	*/
d749 2
a750 1
			nbp->b_flags |= (B_BUSY|B_ASYNC);
@


1.62
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.61 2008/06/11 00:44:53 thib Exp $	*/
d749 1
a749 2
			nbp->b_flags |= B_ASYNC;
			buf_acquire(nbp);
@


1.61
log
@remove an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.60 2008/06/10 20:14:37 beck Exp $	*/
d59 1
d325 1
a325 2
				for (slp = TAILQ_FIRST(&nfssvc_sockhead);
				    slp != 0; slp = TAILQ_NEXT(slp, ns_chain)) {
d744 1
a744 2
		    for (nbp = LIST_FIRST(&vp->v_dirtyblkhd); nbp != NULL;
			nbp = LIST_NEXT(nbp, b_vnbufs)) {
@


1.60
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.59 2008/05/02 13:26:27 thib Exp $	*/
a86 1
int nuidhash_max = NFS_MAXUIDHASH;
@


1.59
log
@plug potential mbuf leaks;

Parts from NetBSD;

OK blambert@@;
tested by johan@@, sthen@@ and a few others.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.58 2008/04/22 19:18:24 blambert Exp $	*/
d751 2
a752 1
			nbp->b_flags |= (B_BUSY|B_ASYNC);
@


1.58
log
@Close potential mbuf leak by iterating over the mbuf packet chain
and m_freem()'ing vice doing so only on the first packet.

From a similar change in NetBSD.

"yes please" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.57 2007/10/14 19:34:41 thib Exp $	*/
d438 5
a442 1
			if (mreq == NULL)
d444 1
d488 1
a488 1
				MFREE(nd->nd_nam2, m);
@


1.57
log
@Remove now unused functions dealing with kerberos
authentication.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.56 2007/09/20 12:54:31 thib Exp $	*/
d557 1
a557 1
	struct mbuf *m;
d572 6
a577 1
		m_freem(slp->ns_rec);
@


1.56
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.55 2007/06/25 20:40:00 thib Exp $	*/
a804 191
}

/*
 * Get an authorization string for the uid by having the mount_nfs sitting
 * on this mount point porpoise out of the kernel and do it.
 */
int
nfs_getauth(nmp, rep, cred, auth_str, auth_len, verf_str, verf_len, key)
	struct nfsmount *nmp;
	struct nfsreq *rep;
	struct ucred *cred;
	char **auth_str;
	int *auth_len;
	char *verf_str;
	int *verf_len;
	NFSKERBKEY_T key;		/* return session key */
{
	int error = 0;

	while ((nmp->nm_flag & NFSMNT_WAITAUTH) == 0) {
		nmp->nm_flag |= NFSMNT_WANTAUTH;
		(void) tsleep((caddr_t)&nmp->nm_authtype, PSOCK,
			"nfsauth1", 2 * hz);
		error = nfs_sigintr(nmp, rep, rep->r_procp);
		if (error) {
			nmp->nm_flag &= ~NFSMNT_WANTAUTH;
			return (error);
		}
	}
	nmp->nm_flag &= ~(NFSMNT_WAITAUTH | NFSMNT_WANTAUTH);
	nmp->nm_authstr = *auth_str = (char *)malloc(RPCAUTH_MAXSIZ, M_TEMP, M_WAITOK);
	nmp->nm_authlen = RPCAUTH_MAXSIZ;
	nmp->nm_verfstr = verf_str;
	nmp->nm_verflen = *verf_len;
	nmp->nm_authuid = cred->cr_uid;
	wakeup((caddr_t)&nmp->nm_authstr);

	/*
	 * And wait for mount_nfs to do its stuff.
	 */
	while ((nmp->nm_flag & NFSMNT_HASAUTH) == 0 && error == 0) {
		(void) tsleep((caddr_t)&nmp->nm_authlen, PSOCK,
			"nfsauth2", 2 * hz);
		error = nfs_sigintr(nmp, rep, rep->r_procp);
	}
	if (nmp->nm_flag & NFSMNT_AUTHERR) {
		nmp->nm_flag &= ~NFSMNT_AUTHERR;
		error = EAUTH;
	}
	if (error)
		free((caddr_t)*auth_str, M_TEMP);
	else {
		*auth_len = nmp->nm_authlen;
		*verf_len = nmp->nm_verflen;
		bcopy((caddr_t)nmp->nm_key, (caddr_t)key, sizeof (NFSKERBKEY_T));
	}
	nmp->nm_flag &= ~NFSMNT_HASAUTH;
	nmp->nm_flag |= NFSMNT_WAITAUTH;
	if (nmp->nm_flag & NFSMNT_WANTAUTH) {
		nmp->nm_flag &= ~NFSMNT_WANTAUTH;
		wakeup((caddr_t)&nmp->nm_authtype);
	}
	return (error);
}

/*
 * Get a nickname authenticator and verifier.
 */
int
nfs_getnickauth(nmp, cred, auth_str, auth_len, verf_str, verf_len)
	struct nfsmount *nmp;
	struct ucred *cred;
	char **auth_str;
	int *auth_len;
	char *verf_str;
	int verf_len;
{
	struct nfsuid *nuidp;
	u_int32_t *nickp, *verfp;
	struct timeval ktvin, ktvout;
	struct timeval tv;

#ifdef DIAGNOSTIC
	if (verf_len < (4 * NFSX_UNSIGNED))
		panic("nfs_getnickauth verf too small");
#endif
	LIST_FOREACH(nuidp, NMUIDHASH(nmp, cred->cr_uid), nu_hash) {
		if (nuidp->nu_cr.cr_uid == cred->cr_uid)
			break;
	}
	if (!nuidp || nuidp->nu_expire < time_second)
		return (EACCES);

	/*
	 * Move to the end of the lru list (end of lru == most recently used).
	 */
	TAILQ_REMOVE(&nmp->nm_uidlruhead, nuidp, nu_lru);
	TAILQ_INSERT_TAIL(&nmp->nm_uidlruhead, nuidp, nu_lru);

	nickp = (u_int32_t *)malloc(2 * NFSX_UNSIGNED, M_TEMP, M_WAITOK);
	*nickp++ = txdr_unsigned(RPCAKN_NICKNAME);
	*nickp = txdr_unsigned(nuidp->nu_nickname);
	*auth_str = (char *)nickp;
	*auth_len = 2 * NFSX_UNSIGNED;

	/*
	 * Now we must encrypt the verifier and package it up.
	 */
	verfp = (u_int32_t *)verf_str;
	*verfp++ = txdr_unsigned(RPCAKN_NICKNAME);
	getmicrotime(&tv);
	if (tv.tv_sec > nuidp->nu_timestamp.tv_sec ||
	    (tv.tv_sec == nuidp->nu_timestamp.tv_sec &&
	     tv.tv_usec > nuidp->nu_timestamp.tv_usec))
		nuidp->nu_timestamp = tv;
	else
		nuidp->nu_timestamp.tv_usec++;
	ktvin.tv_sec = txdr_unsigned(nuidp->nu_timestamp.tv_sec);
	ktvin.tv_usec = txdr_unsigned(nuidp->nu_timestamp.tv_usec);

	*verfp++ = ktvout.tv_sec;
	*verfp++ = ktvout.tv_usec;
	*verfp = 0;
	return (0);
}

/*
 * Save the current nickname in a hash list entry on the mount point.
 */
int
nfs_savenickauth(nmp, cred, len, key, mdp, dposp, mrep)
	struct nfsmount *nmp;
	struct ucred *cred;
	int len;
	NFSKERBKEY_T key;
	struct mbuf **mdp;
	char **dposp;
	struct mbuf *mrep;
{
	struct nfsuid *nuidp;
	u_int32_t *tl;
	int32_t t1;
	struct mbuf *md = *mdp;
	struct timeval ktvin, ktvout;
	u_int32_t nick;
	char *dpos = *dposp, *cp2;
	int deltasec, error = 0;

	if (len == (3 * NFSX_UNSIGNED)) {
		nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
		ktvin.tv_sec = *tl++;
		ktvin.tv_usec = *tl++;
		nick = fxdr_unsigned(u_int32_t, *tl);

		ktvout.tv_sec = fxdr_unsigned(long, ktvout.tv_sec);
		ktvout.tv_usec = fxdr_unsigned(long, ktvout.tv_usec);
		deltasec = time_second - ktvout.tv_sec;
		if (deltasec < 0)
			deltasec = -deltasec;
		/*
		 * If ok, add it to the hash list for the mount point.
		 */
		if (deltasec <= NFS_KERBCLOCKSKEW) {
			if (nmp->nm_numuids < nuidhash_max) {
				nmp->nm_numuids++;
				nuidp = (struct nfsuid *)
				   malloc(sizeof (struct nfsuid), M_NFSUID,
					M_WAITOK);
			} else {
				nuidp = TAILQ_FIRST(&nmp->nm_uidlruhead);
				LIST_REMOVE(nuidp, nu_hash);
				TAILQ_REMOVE(&nmp->nm_uidlruhead, nuidp,
					nu_lru);
			}
			nuidp->nu_flag = 0;
			nuidp->nu_cr.cr_uid = cred->cr_uid;
			nuidp->nu_expire = time_second + NFS_KERBTTL;
			nuidp->nu_timestamp = ktvout;
			nuidp->nu_nickname = nick;
			bcopy(key, nuidp->nu_key, sizeof (NFSKERBKEY_T));
			TAILQ_INSERT_TAIL(&nmp->nm_uidlruhead, nuidp,
				nu_lru);
			LIST_INSERT_HEAD(NMUIDHASH(nmp, cred->cr_uid),
				nuidp, nu_hash);
		}
	} else
		nfsm_adv(nfsm_rndup(len));
nfsmout:
	*mdp = md;
	*dposp = dpos;
	return (error);
@


1.55
log
@replace magic number with a define.
(2 -> SHUT_RDWR in calls to soshutdown()).

From Iruata Souza.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.54 2007/05/31 20:03:43 thib Exp $	*/
d256 2
a257 3
		slp = (struct nfssvc_sock *)
			malloc(sizeof (struct nfssvc_sock), M_NFSSVC, M_WAITOK);
		bzero((caddr_t)slp, sizeof (struct nfssvc_sock));
d301 3
a303 4
	if (nfsd == (struct nfsd *)0) {
		nsd->nsd_nfsd = nfsd = (struct nfsd *)
			malloc(sizeof (struct nfsd), M_NFSD, M_WAITOK);
		bzero((caddr_t)nfsd, sizeof (struct nfsd));
d505 1
a505 1
			FREE((caddr_t)nd, M_NFSRVDESC);
d643 2
a644 3
	nfs_udpsock = (struct nfssvc_sock *)
	    malloc(sizeof (struct nfssvc_sock), M_NFSSVC, M_WAITOK);
	bzero((caddr_t)nfs_udpsock, sizeof (struct nfssvc_sock));
@


1.54
log
@zap nfs_cltpsock; Unused since NQNFS died.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.53 2007/05/31 03:01:12 thib Exp $	*/
d569 1
a569 1
		soshutdown(so, 2);
@


1.53
log
@This is not the buffer you are looking for,
vintage 6 year old NFS bug.

ok beck@@, looked at three times by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.52 2007/05/28 06:13:07 krw Exp $	*/
d86 1
a86 1
struct nfssvc_sock *nfs_udpsock, *nfs_cltpsock;
a649 6

	nfs_cltpsock = (struct nfssvc_sock *)
	    malloc(sizeof (struct nfssvc_sock), M_NFSSVC, M_WAITOK);
	bzero((caddr_t)nfs_cltpsock, sizeof (struct nfssvc_sock));
	TAILQ_INIT(&nfs_cltpsock->ns_uidlruhead);
	TAILQ_INSERT_TAIL(&nfssvc_sockhead, nfs_cltpsock, ns_chain);
@


1.52
log
@Fix tree breakage. Variables only used inside #ifdef NFSSERVER should
be defined inside same. ramdisk_cd (has nfs, but is not a server)
compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.51 2007/05/27 21:14:41 thib Exp $	*/
d759 1
a759 1
			buf_undirty(bp);
@


1.51
log
@cleanup the nfssvc() system call.
* Remove alot of dead kerberos code like
  the options for NFSSVC_AUTHIN and NFSSVC_AUTHFAIL wich where
  originally to get the kerberos auth info into the kernel.
  (that hasnt worked for long, if ever.)
  Also remove some helper functions and associated goo, however
  theres still alot of it left.
* Remove NFSSVC_BIOD, biod's where replaced with kernel threads
  a long time ago.
* NFSSVC_MNTD wich was is NQNFS leftover.

Update the man page and nfsd(8).

nfssvc(2) besides being special has only one user in the tree
nfsd(8), therefore no library bumps are needed.
(discussed with deraadt@@).

ok beck@@, "go a head" deraadt@@
Tested by ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.50 2006/11/29 12:24:18 miod Exp $	*/
d121 2
a127 2
	int error = 0;
#ifdef NFSSERVER
@


1.50
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.49 2006/10/04 12:04:40 pedro Exp $	*/
a111 95
int nfs_clientd(struct nfsmount *nmp, struct ucred *cred, 
    struct nfsd_cargs *ncd, int flag, caddr_t argp, struct proc *p);

/*
 * Nfs client helper daemon.
 * It also get authorization strings for "kerb" mounts.
 * It must start at the beginning of the list again after any potential
 * "sleep" since nfs_reclaim() called from vclean() can pull a node off
 * the list asynchronously.
 */
int
nfs_clientd(struct nfsmount *nmp, struct ucred *cred, struct nfsd_cargs *ncd, 
    int flag, caddr_t argp, struct proc *p)
{
	struct nfsuid *nuidp, *nnuidp;
	int error = 0;

	/*
	 * First initialize some variables
	 */

	/*
	 * If an authorization string is being passed in, get it.
	 */
	if ((flag & NFSSVC_GOTAUTH) &&
	    (nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_DISMNT)) == 0) {
	    if (nmp->nm_flag & NFSMNT_HASAUTH)
		panic("cld kerb");
	    if ((flag & NFSSVC_AUTHINFAIL) == 0) {
		if (ncd->ncd_authlen <= nmp->nm_authlen &&
		    ncd->ncd_verflen <= nmp->nm_verflen &&
		    !copyin(ncd->ncd_authstr,nmp->nm_authstr,ncd->ncd_authlen)&&
		    !copyin(ncd->ncd_verfstr,nmp->nm_verfstr,ncd->ncd_verflen)){
		    nmp->nm_authtype = ncd->ncd_authtype;
		    nmp->nm_authlen = ncd->ncd_authlen;
		    nmp->nm_verflen = ncd->ncd_verflen;
		} else
		    nmp->nm_flag |= NFSMNT_AUTHERR;
	    } else
		nmp->nm_flag |= NFSMNT_AUTHERR;
	    nmp->nm_flag |= NFSMNT_HASAUTH;
	    wakeup((caddr_t)&nmp->nm_authlen);
	} else
	    nmp->nm_flag |= NFSMNT_WAITAUTH;

	/*
	 * Loop every second updating queue until there is a termination sig.
	 */
	while ((nmp->nm_flag & NFSMNT_DISMNT) == 0) {
	    /*
	     * Get an authorization string, if required.
	     */
	    if ((nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_DISMNT | NFSMNT_HASAUTH)) == 0) {
		ncd->ncd_authuid = nmp->nm_authuid;
		if (copyout((caddr_t)ncd, argp, sizeof (struct nfsd_cargs)))
			nmp->nm_flag |= NFSMNT_WAITAUTH;
		else
			return (ENEEDAUTH);
	    }

	    /*
	     * Wait a bit (no pun) and do it again.
	     */
	    if ((nmp->nm_flag & NFSMNT_DISMNT) == 0 &&
		(nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_HASAUTH))) {
		    error = tsleep((caddr_t)&nmp->nm_authstr, PSOCK | PCATCH,
			"nqnfstimr", hz / 3);
		    if (error == EINTR || error == ERESTART) {
			if (vfs_busy(nmp->nm_mountp, VB_WRITE|VB_WAIT) == 0)
			    dounmount(nmp->nm_mountp, MNT_FORCE, p, NULL);
		    }
	    }
	}

	/*
	 * Finally, we can free up the mount structure.
	 */
	for (nuidp = TAILQ_FIRST(&nmp->nm_uidlruhead); nuidp != NULL;
	    nuidp = nnuidp) {
		nnuidp = TAILQ_NEXT(nuidp, nu_lru);
		LIST_REMOVE(nuidp, nu_hash);
		TAILQ_REMOVE(&nmp->nm_uidlruhead, nuidp, nu_lru);
		free((caddr_t)nuidp, M_NFSUID);
	}
	free((caddr_t)nmp, M_NFSMNT);
	if (error == EWOULDBLOCK)
		error = 0;
	return (error);
}


/*
 * NFS server system calls
 */

d113 1
a113 1
 * Nfs server pseudo system call for the nfsd's
a116 1
 * - remains in the kernel as an nfsiod
d119 1
a119 4
sys_nfssvc(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d125 2
a126 6
#ifdef NFSCLIENT
	struct nameidata nd;
	struct nfsmount *nmp;
	struct nfsd_cargs ncd;
#endif
	int error;
a131 3
	struct nfsd *nfsd;
	struct nfssvc_sock *slp;
	struct nfsuid *nuidp;
d134 1
a134 3
	/*
	 * Must be super user
	 */
d136 1
a136 1
	if(error)
d138 5
d144 2
a145 2
		 nfssvc_sockhead_flag |= SLP_WANTINIT;
		(void) tsleep((caddr_t)&nfssvc_sockhead, PSOCK, "nfsd init", 0);
d147 4
a150 33
	if (SCARG(uap, flag) & NFSSVC_BIOD) {
		error = ENOSYS;
	} else if (SCARG(uap, flag) & NFSSVC_MNTD) {
#ifndef NFSCLIENT
		error = ENOSYS;
#else
		error = copyin(SCARG(uap, argp), (caddr_t)&ncd, sizeof (ncd));
		if (error)
			return (error);
		NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
			ncd.ncd_dirp, p);
		error = namei(&nd);
		if (error)
			return (error);
		if ((nd.ni_vp->v_flag & VROOT) == 0)
			error = EINVAL;
		nmp = VFSTONFS(nd.ni_vp->v_mount);
		vput(nd.ni_vp);
		if (error)
			return (error);
		if ((nmp->nm_flag & NFSMNT_MNTD) &&
			(SCARG(uap, flag) & NFSSVC_GOTAUTH) == 0)
			return (0);
		nmp->nm_flag |= NFSMNT_MNTD;
		error = nfs_clientd(nmp, p->p_ucred, &ncd, SCARG(uap, flag),
			SCARG(uap, argp), p);
#endif /* NFSCLIENT */
	} else if (SCARG(uap, flag) & NFSSVC_ADDSOCK) {
#ifndef NFSSERVER
		error = ENOSYS;
#else
		error = copyin(SCARG(uap, argp), (caddr_t)&nfsdarg,
		    sizeof(nfsdarg));
d153 1
d157 1
d162 1
a162 1
			nam = (struct mbuf *)0;
d173 3
a175 6
#endif /* !NFSSERVER */
	} else {
#ifndef NFSSERVER
		error = ENOSYS;
#else
		error = copyin(SCARG(uap, argp), (caddr_t)nsd, sizeof (*nsd));
d178 1
a178 87
		if ((SCARG(uap, flag) & NFSSVC_AUTHIN) &&
		    ((nfsd = nsd->nsd_nfsd)) != NULL &&
		    (nfsd->nfsd_slp->ns_flag & SLP_VALID)) {
			slp = nfsd->nfsd_slp;

			/*
			 * First check to see if another nfsd has already
			 * added this credential.
			 */
			LIST_FOREACH(nuidp, NUIDHASH(slp,nsd->nsd_cr.cr_uid),
			    nu_hash) {
				if (nuidp->nu_cr.cr_uid == nsd->nsd_cr.cr_uid &&
				    (!nfsd->nfsd_nd->nd_nam2 ||
				     netaddr_match(NU_NETFAM(nuidp),
				     &nuidp->nu_haddr, nfsd->nfsd_nd->nd_nam2)))
					break;
			}
			if (nuidp) {
			    nfsrv_setcred(&nuidp->nu_cr,&nfsd->nfsd_nd->nd_cr);
			    nfsd->nfsd_nd->nd_flag |= ND_KERBFULL;
			} else {
			    /*
			     * Nope, so we will.
			     */
			    if (slp->ns_numuids < nuidhash_max) {
				slp->ns_numuids++;
				nuidp = (struct nfsuid *)
				   malloc(sizeof (struct nfsuid), M_NFSUID,
					M_WAITOK);
			    } else
				nuidp = (struct nfsuid *)0;
			    if ((slp->ns_flag & SLP_VALID) == 0) {
				if (nuidp)
				    free((caddr_t)nuidp, M_NFSUID);
			    } else {
				if (nuidp == (struct nfsuid *)0) {
				    nuidp = TAILQ_FIRST(&slp->ns_uidlruhead);
				    LIST_REMOVE(nuidp, nu_hash);
				    TAILQ_REMOVE(&slp->ns_uidlruhead, nuidp,
					nu_lru);
				    if (nuidp->nu_flag & NU_NAM)
					m_freem(nuidp->nu_nam);
			        }
				nuidp->nu_flag = 0;
				nuidp->nu_cr = nsd->nsd_cr;
				if (nuidp->nu_cr.cr_ngroups > NGROUPS)
				    nuidp->nu_cr.cr_ngroups = NGROUPS;
				nuidp->nu_cr.cr_ref = 1;
				nuidp->nu_timestamp = nsd->nsd_timestamp;
				nuidp->nu_expire = time_second + nsd->nsd_ttl;
				/*
				 * and save the session key in nu_key.
				 */
				bcopy(nsd->nsd_key, nuidp->nu_key,
				    sizeof (nsd->nsd_key));
				if (nfsd->nfsd_nd->nd_nam2) {
				    struct sockaddr_in *saddr;

				    saddr = mtod(nfsd->nfsd_nd->nd_nam2,
					 struct sockaddr_in *);
				    switch (saddr->sin_family) {
				    case AF_INET:
					nuidp->nu_flag |= NU_INETADDR;
					nuidp->nu_inetaddr =
					     saddr->sin_addr.s_addr;
					break;
				    default:
					nuidp->nu_flag |= NU_NAM;
					nuidp->nu_nam = m_copym(
					    nfsd->nfsd_nd->nd_nam2, 0,
					     M_COPYALL, M_WAIT);
					break;
				    };
				}
				TAILQ_INSERT_TAIL(&slp->ns_uidlruhead, nuidp,
					nu_lru);
				LIST_INSERT_HEAD(NUIDHASH(slp, nsd->nsd_uid),
					nuidp, nu_hash);
				nfsrv_setcred(&nuidp->nu_cr,
				    &nfsd->nfsd_nd->nd_cr);
				nfsd->nfsd_nd->nd_flag |= ND_KERBFULL;
			    }
			}
		}
		if ((SCARG(uap, flag) & NFSSVC_AUTHINFAIL) &&
		    (nfsd = nsd->nsd_nfsd))
			nfsd->nfsd_flag |= NFSD_AUTHFAIL;
d180 4
a183 1
#endif /* !NFSSERVER */
d185 1
d188 2
@


1.49
log
@typo, from Bret Lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.48 2006/06/25 15:01:54 sturm Exp $	*/
a522 1
	PHOLD(p);
a623 1
			    PRELE(p);
a747 1
	PRELE(p);
a933 1
	PHOLD(p);
a980 1
		PRELE(p);
@


1.48
log
@rename vfs_busy() flags VB_UMIGNORE/VB_UMWAIT to VB_NOWAIT/VB_WAIT

requested by and ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.47 2006/06/14 20:01:50 sturm Exp $	*/
d1036 1
a1036 1
 * on this mount point porpous out of the kernel and do it.
@


1.47
log
@move vfs_busy() to rwlocks and properly hide the locking api from vfs

ok tedu, pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.46 2006/04/30 14:20:07 sturm Exp $	*/
d180 1
a180 1
			if (vfs_busy(nmp->nm_mountp, VB_WRITE|VB_UMWAIT) == 0)
@


1.46
log
@remove the simplelock argument from vfs_busy() which is currently not
used and will never be used this way in VFS

requested by and ok pedro, ok krw, biorn
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.45 2005/11/30 10:35:08 pedro Exp $	*/
d180 1
a180 1
			if (vfs_busy(nmp->nm_mountp, LK_EXCLUSIVE) == 0)
@


1.45
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.44 2005/04/01 02:54:57 tedu Exp $	*/
d180 1
a180 1
			if (vfs_busy(nmp->nm_mountp, LK_EXCLUSIVE, NULL) == 0)
@


1.44
log
@at long last, disable write gathering for v3.  ok like everyone
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.43 2004/12/26 21:22:14 miod Exp $	*/
d180 1
a180 1
			if (vfs_busy(nmp->nm_mountp, LK_EXCLUSIVE, NULL, p) == 0)
@


1.43
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.42 2004/07/16 15:01:51 henning Exp $	*/
d647 2
a648 1
			if (writes_todo || (nd->nd_procnum == NFSPROC_WRITE &&
d650 2
a651 2
			    error = nfsrv_writegather(&nd, slp,
				nfsd->nfsd_procp, &mreq);
d653 2
a654 2
			    error = (*(nfsrv3_procs[nd->nd_procnum]))(nd,
				slp, nfsd->nfsd_procp, &mreq);
@


1.42
log
@kill netiso stuff here as well, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.41 2004/06/25 00:54:28 tholo Exp $	*/
d320 2
a321 2
			for (nuidp = NUIDHASH(slp,nsd->nsd_cr.cr_uid)->lh_first;
			    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d1117 1
a1117 2
	for (nuidp = NMUIDHASH(nmp, cred->cr_uid)->lh_first;
	    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
@


1.41
log
@Minor fixes suggested by nordin@@ and henning@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.40 2004/06/24 19:35:26 tholo Exp $	*/
a63 3
#ifdef ISO
#include <netiso/iso.h>
#endif
a376 1
				    case AF_ISO:
a432 8
#ifdef ISO
	} else if (so->so_proto->pr_protocol == ISOPROTO_CLTP) {
		tslp = nfs_cltpsock;
		if (tslp->ns_flag & SLP_VALID) {
			m_freem(mynam);
			return (EPERM);
		}
#endif /* ISO */
@


1.40
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.39 2004/06/21 23:50:38 tholo Exp $	*/
a894 1
	struct timeval tv;
d909 1
a909 1
	    rt->ipadr = mtod(nd->nd_nam, struct sockaddr_in *)->sin_addr.s_addr;
d911 5
a915 5
	    rt->ipadr = INADDR_ANY;
	getmicrotime(&tv);
	rt->resptime = ((tv.tv_sec - nd->nd_starttime.tv_sec) * 1000000) +
		(tv.tv_usec - nd->nd_starttime.tv_usec);
	rt->tstamp = tv;
@


1.39
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.38 2003/08/15 20:32:20 tedu Exp $	*/
d520 1
d569 2
d582 3
a584 2
				cur_usec = (u_quad_t)time.tv_sec * 1000000 +
					(u_quad_t)time.tv_usec;
d617 1
a617 1
		    nd->nd_starttime = time;
d741 3
a743 2
		    cur_usec = (u_quad_t)time.tv_sec * 1000000 +
			(u_quad_t)time.tv_usec;
d895 1
d913 4
a916 3
	rt->resptime = ((time.tv_sec - nd->nd_starttime.tv_sec) * 1000000) +
		(time.tv_usec - nd->nd_starttime.tv_usec);
	rt->tstamp = time;
d1124 1
d1155 5
a1159 4
	if (time.tv_sec > nuidp->nu_timestamp.tv_sec ||
	    (time.tv_sec == nuidp->nu_timestamp.tv_sec &&
	     time.tv_usec > nuidp->nu_timestamp.tv_usec))
		nuidp->nu_timestamp = time;
@


1.38
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.37 2003/06/02 23:28:20 millert Exp $	*/
d363 1
a363 1
				nuidp->nu_expire = time.tv_sec + nsd->nsd_ttl;
d1127 1
a1127 1
	if (!nuidp || nuidp->nu_expire < time.tv_sec)
d1192 1
a1192 1
		deltasec = time.tv_sec - ktvout.tv_sec;
d1212 1
a1212 1
			nuidp->nu_expire = time.tv_sec + NFS_KERBTTL;
@


1.37
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.36 2003/05/07 02:06:31 mickey Exp $	*/
d246 1
a246 1
	error = suser(p->p_ucred, &p->p_acflag);
@


1.36
log
@make this at least compile ...
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.35 2002/10/29 12:47:06 art Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.35
log
@Get rid of some commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.34 2002/08/23 22:21:44 art Exp $	*/
d188 1
a188 1
			    dounmount(nmp->nm_mountp, MNT_FORCE, p);
@


1.34
log
@Just like getvnode, make getsock FREF the file so that we can't get away
with not refing it.

Eyeballed by lurene@@daemonkitty.net, fries@@, nordin@@ and fries@@
Some additional cleanups by nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.33 2002/07/24 23:32:11 nordin Exp $	*/
d100 6
@


1.33
log
@Use sizeof(array) instead of sizeof(array *) for bcopy length. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.32 2002/07/12 14:02:23 art Exp $	*/
a288 1
		FREF(fp);
@


1.32
log
@Change the locking on the mountpoint slightly. Instead of using mnt_lock
to get shared locks for lookup and get the exclusive lock only with
LK_DRAIN on unmount and do the real exclusive locking with flags in
mnt_flags, we now use shared locks for lookup and an exclusive lock for
unmount.

This is accomplished by slightly changing the semantics of vfs_busy.
Old vfs_busy behavior:
 - with LK_NOWAIT set in flags, a shared lock was obtained if the
   mountpoint wasn't being unmounted, otherwise we just returned an error.
 - with no flags, a shared lock was obtained if the mountpoint was being
   unmounted, otherwise we slept until the unmount was done and returned
   an error.
LK_NOWAIT was used for sync(2) and some statistics code where it isn't really
critical that we get the correct results.
0 was used in fchdir and lookup where it's critical that we get the right
directory vnode for the filesystem root.

After this change vfs_busy keeps the same behavior for no flags and LK_NOWAIT.
But if some other flags are passed into it, they are passed directly
into lockmgr (actually LK_SLEEPFAIL is always added to those flags because
if we sleep for the lock, that means someone was holding the exclusive lock
and the exclusive lock is only held when the filesystem is being unmounted.

More changes:
 dounmount must now be called with the exclusive lock held. (before this
 the caller was supposed to hold the vfs_busy lock, but that wasn't always
 true).
 Zap some (now) unused mount flags.
And the highlight of this change:
 Add some vfs_busy calls to match some vfs_unbusy calls, especially in
 sys_mount. (lockmgr doesn't detect the case where we release a lock noone
 holds (it will do that soon)).

If you've seen hangs on reboot with mfs this should solve it (I repeat this
for the fourth time now, but this time I spent two months fixing and
redesigning this and reading the code so this time I must have gotten
this right).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.31 2002/06/11 15:45:44 hin Exp $	*/
d1090 1
a1090 1
		bcopy((caddr_t)nmp->nm_key, (caddr_t)key, sizeof (key));
d1214 1
a1214 1
			bcopy(key, nuidp->nu_key, sizeof (key));
@


1.31
log
@Remove some unused code for dealing with nfs over kerberos. No actual change,
just some #ifdef'ed out code removed.

ok deraadt@@, art@@ and csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.30 2002/03/14 01:27:13 millert Exp $	*/
d180 4
a183 2
		    if (error == EINTR || error == ERESTART)
			(void) dounmount(nmp->nm_mountp, MNT_FORCE, p);
@


1.30
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.29 2002/02/12 13:05:32 art Exp $	*/
a148 3
#ifdef NFSKERB
		    nmp->nm_key = ncd->ncd_key;
#endif
a1152 8
	/*
	 * Now encrypt the timestamp verifier in ecb mode using the session
	 * key.
	 */
#ifdef NFSKERB
	XXX
#endif

a1186 6
		/*
		 * Decrypt the timestamp in ecb mode.
		 */
#ifdef NFSKERB
		XXX
#endif
@


1.29
log
@Fix all users of getsock to use FREF/FRELE properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.28 2002/02/10 22:02:05 nate Exp $	*/
d82 1
a82 1
void	nfsrv_zapsock	__P((struct nfssvc_sock *));
d85 1
a85 1
extern int32_t (*nfsrv3_procs[NFS_NPROCS]) __P((struct nfsrv_descript *,
d87 1
a87 1
						struct proc *, struct mbuf **));
d110 1
a110 1
static void nfsd_rt __P((int, struct nfsrv_descript *, int));
@


1.28
log
@theo doesn't like this code
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.27 2002/02/08 13:53:28 art Exp $	*/
d290 1
d299 2
a300 1
			if (error)
d302 1
d305 1
@


1.27
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.26 2002/02/05 16:02:27 art Exp $	*/
a95 1
int nfs_norsvport = 0;
@


1.26
log
@Add counting of temporary references to a struct file (as opposed to references
from fd tables and other long-lived objects). This is to avoid races between
using a file descriptor and having another process (with shared fd table)
close it. We use a separate refence count so that error values from close(2)
will be correctly returned to the caller of close(2).

The macros for those reference counts are FILE_USE(fp) and FILE_UNUSE(fp).

Make sure that the cases where closef can be called "incorrectly" (most notably
dup2(2)) are handled.

Right now only callers of closef (and {,p}read) use FILE_{,UN}USE correctly,
more fixes incoming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.25 2002/01/20 23:51:29 hugh Exp $	*/
d784 1
a784 1
		FILE_USE(fp);
@


1.25
log
@Move nfs_norsvport out from behind #ifdef NFSSERVER so ramdisk
kernels with only NFSCLIENT defined can build.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.24 2002/01/16 21:51:16 ericj Exp $	*/
d784 2
a785 1
		slp->ns_fp = (struct file *)0;
d789 1
a789 1
		closef(fp, (struct proc *)0);
@


1.24
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.23 2002/01/11 01:20:56 nate Exp $	*/
d96 1
a111 1
int nfs_norsvport = 0;
@


1.23
log
@Add a new sysctl that removes the requirement for reserved ports to be
used by the nfs server.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.22 2001/12/19 08:58:06 art Exp $	*/
d192 3
a194 2
	for (nuidp = nmp->nm_uidlruhead.tqh_first; nuidp != 0; nuidp = nnuidp) {
		nnuidp = nuidp->nu_lru.tqe_next;
d223 1
a223 1
	register struct sys_nfssvc_args /* {
d321 1
a321 1
			    nuidp != 0; nuidp = nuidp->nu_hash.le_next) {
d347 1
a347 1
				    nuidp = slp->ns_uidlruhead.tqh_first;
d416 4
a419 4
	register struct mbuf *m;
	register int siz;
	register struct nfssvc_sock *slp;
	register struct socket *so;
d507 5
a511 5
	register struct mbuf *m;
	register int siz;
	register struct nfssvc_sock *slp;
	register struct socket *so;
	register int *solockp;
d547 1
a547 1
			if (nfsd->nfsd_slp == (struct nfssvc_sock *)0 &&
d549 2
a550 2
				for (slp = nfssvc_sockhead.tqh_first; slp != 0;
				    slp = slp->ns_chain.tqe_next) {
d578 3
a580 2
				if (error && slp->ns_tq.lh_first &&
				    slp->ns_tq.lh_first->nd_time <= cur_usec) {
d737 2
a738 2
		    if (slp->ns_tq.lh_first &&
			slp->ns_tq.lh_first->nd_time <= cur_usec) {
d772 1
a772 1
	register struct nfssvc_sock *slp;
d774 2
a775 2
	register struct nfsuid *nuidp, *nnuidp;
	register struct nfsrv_descript *nwp, *nnwp;
d793 1
a793 1
		for (nuidp = slp->ns_uidlruhead.tqh_first; nuidp != 0;
d795 1
a795 1
			nnuidp = nuidp->nu_lru.tqe_next;
d803 2
a804 2
		for (nwp = slp->ns_tq.lh_first; nwp; nwp = nnwp) {
			nnwp = nwp->nd_tq.le_next;
d819 1
a819 1
	register struct nfssvc_sock *slp;
d836 1
a836 1
	register struct nfssvc_sock *slp, *nslp;
d842 3
a844 2
		for (slp = nfssvc_sockhead.tqh_first; slp != 0; slp = nslp) {
			nslp = slp->ns_chain.tqe_next;
d882 1
a882 1
	register struct nfsrv_descript *nd;
d885 1
a885 1
	register struct drt *rt;
d920 2
a921 2
	register struct buf *bp, *nbp;
	register int i, myiod;
d943 1
a943 1
	    while (nfs_bufq.tqh_first == NULL && error == 0) {
d948 1
a948 1
	    while ((bp = nfs_bufq.tqh_first) != NULL) {
d962 2
a963 2
		    for (nbp = vp->v_dirtyblkhd.lh_first; nbp;
			nbp = nbp->b_vnbufs.le_next) {
d1041 1
a1041 1
	register struct nfsmount *nmp;
d1110 2
a1111 2
	register struct nfsuid *nuidp;
	register u_int32_t *nickp, *verfp;
d1119 1
a1119 1
	    nuidp != 0; nuidp = nuidp->nu_hash.le_next) {
d1171 1
a1171 1
	register struct nfsmount *nmp;
d1179 3
a1181 3
	register struct nfsuid *nuidp;
	register u_int32_t *tl;
	register int32_t t1;
d1215 1
a1215 1
				nuidp = nmp->nm_uidlruhead.tqh_first;
@


1.22
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.20 2001/11/15 23:15:15 art Exp $	*/
d111 1
@


1.21
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d916 4
a919 3
	struct buf *bp;
	int i, myiod;
	int error = 0;
d947 33
a979 1
		(void) nfs_doio(bp, NULL);
@


1.21.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.25 2002/01/20 23:51:29 hugh Exp $	*/
a95 1
int nfs_norsvport = 0;
d191 2
a192 3
	for (nuidp = TAILQ_FIRST(&nmp->nm_uidlruhead); nuidp != NULL;
	    nuidp = nnuidp) {
		nnuidp = TAILQ_NEXT(nuidp, nu_lru);
d221 1
a221 1
	struct sys_nfssvc_args /* {
d319 1
a319 1
			    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d345 1
a345 1
				    nuidp = TAILQ_FIRST(&slp->ns_uidlruhead);
d414 4
a417 4
	struct mbuf *m;
	int siz;
	struct nfssvc_sock *slp;
	struct socket *so;
d505 5
a509 5
	struct mbuf *m;
	int siz;
	struct nfssvc_sock *slp;
	struct socket *so;
	int *solockp;
d545 1
a545 1
			if (nfsd->nfsd_slp == NULL &&
d547 2
a548 2
				for (slp = TAILQ_FIRST(&nfssvc_sockhead);
				    slp != 0; slp = TAILQ_NEXT(slp, ns_chain)) {
d576 2
a577 3
				if (error && LIST_FIRST(&slp->ns_tq) &&
				    LIST_FIRST(&slp->ns_tq)->nd_time
				    <= cur_usec) {
d734 2
a735 2
		    if (LIST_FIRST(&slp->ns_tq) &&
			LIST_FIRST(&slp->ns_tq)->nd_time <= cur_usec) {
d769 1
a769 1
	struct nfssvc_sock *slp;
d771 2
a772 2
	struct nfsuid *nuidp, *nnuidp;
	struct nfsrv_descript *nwp, *nnwp;
d790 1
a790 1
		for (nuidp = TAILQ_FIRST(&slp->ns_uidlruhead); nuidp != NULL;
d792 1
a792 1
			nnuidp = TAILQ_NEXT(nuidp, nu_lru);
d800 2
a801 2
		for (nwp = LIST_FIRST(&slp->ns_tq); nwp != NULL; nwp = nnwp) {
			nnwp = LIST_NEXT(nwp, nd_tq);
d816 1
a816 1
	struct nfssvc_sock *slp;
d833 1
a833 1
	struct nfssvc_sock *slp, *nslp;
d839 2
a840 3
		for (slp = TAILQ_FIRST(&nfssvc_sockhead); slp != NULL;
		    slp = nslp) {
			nslp = TAILQ_NEXT(slp, ns_chain);
d878 1
a878 1
	struct nfsrv_descript *nd;
d881 1
a881 1
	struct drt *rt;
d938 1
a938 1
	    while (TAILQ_FIRST(&nfs_bufq) == NULL && error == 0) {
d943 1
a943 1
	    while ((bp = TAILQ_FIRST(&nfs_bufq)) != NULL) {
d1004 1
a1004 1
	struct nfsmount *nmp;
d1073 2
a1074 2
	struct nfsuid *nuidp;
	u_int32_t *nickp, *verfp;
d1082 1
a1082 1
	    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d1134 1
a1134 1
	struct nfsmount *nmp;
d1142 3
a1144 3
	struct nfsuid *nuidp;
	u_int32_t *tl;
	int32_t t1;
d1178 1
a1178 1
				nuidp = TAILQ_FIRST(&nmp->nm_uidlruhead);
@


1.21.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.21.2.1 2002/01/31 22:55:47 niklas Exp $	*/
d82 1
a82 1
void	nfsrv_zapsock(struct nfssvc_sock *);
d85 1
a85 1
extern int32_t (*nfsrv3_procs[NFS_NPROCS])(struct nfsrv_descript *,
d87 1
a87 1
						struct proc *, struct mbuf **);
d96 1
d111 1
a111 1
static void nfsd_rt(int, struct nfsrv_descript *, int);
a290 1
		FREF(fp);
d299 1
a299 2
			if (error) {
				FRELE(fp);
a300 1
			}
a302 1
		FRELE(fp);
d784 1
a784 2
		FREF(fp);
		slp->ns_fp = NULL;
d788 1
a788 1
		closef(fp, NULL);
@


1.21.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.21.2.2 2002/06/11 03:32:04 art Exp $	*/
d149 3
d183 2
a184 4
		    if (error == EINTR || error == ERESTART) {
			if (vfs_busy(nmp->nm_mountp, LK_EXCLUSIVE, NULL, p) == 0)
			    dounmount(nmp->nm_mountp, MNT_FORCE, p);
		    }
d290 1
d1058 1
a1058 1
		bcopy((caddr_t)nmp->nm_key, (caddr_t)key, sizeof (NFSKERBKEY_T));
d1123 8
d1165 6
d1196 1
a1196 1
			bcopy(key, nuidp->nu_key, sizeof (NFSKERBKEY_T));
@


1.21.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a100 6
struct nfssvc_sockhead nfssvc_sockhead;
struct nfsdhead nfsd_head;

int nfssvc_sockhead_flag;
int nfsd_head_flag;

d182 1
a182 1
			    dounmount(nmp->nm_mountp, MNT_FORCE, p, NULL);
@


1.20
log
@Remove creds from struct buf, move the creds that nfs need into the nfs node.
While in the area, convert nfs node allocation from malloc to pool and do
some cleanups.
Based on the UBC changes in NetBSD. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.19 2001/06/26 05:19:35 csapuntz Exp $	*/
d916 3
a918 4
	register struct buf *bp, *nbp;
	register int i, myiod;
	struct vnode *vp;
	int error = 0, s;
d946 1
a946 33
		if (bp->b_flags & B_READ)
		    (void) nfs_doio(bp, NULL);
		else do {
		    /*
		     * Look for a delayed write for the same vnode, so I can do 
		     * it now. We must grab it before calling nfs_doio() to
		     * avoid any risk of the vnode getting vclean()'d while
		     * we are doing the write rpc.
		     */
		    vp = bp->b_vp;
		    s = splbio();
		    for (nbp = vp->v_dirtyblkhd.lh_first; nbp;
			nbp = nbp->b_vnbufs.le_next) {
			if ((nbp->b_flags &
			    (B_BUSY|B_DELWRI|B_NEEDCOMMIT|B_NOCACHE))!=B_DELWRI)
			    continue;
			bremfree(nbp);
			nbp->b_flags |= (B_BUSY|B_ASYNC);
			break;
		    }
		    /*
		     * For the delayed write, do the first part of nfs_bwrite()
		     * up to, but not including nfs_strategy().
		     */
		    if (nbp) {
			nbp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
			buf_undirty(bp);
			nbp->b_vp->v_numoutput++;
		    }
		    splx(s);

		    (void) nfs_doio(bp, NULL);
		} while ((bp = nbp) != NULL);
@


1.19
log
@Remove left-over code from cleaning that was causing servers to fail to respond
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.18 2001/06/25 03:28:11 csapuntz Exp $	*/
d948 1
a948 1
		    (void) nfs_doio(bp, bp->b_rcred, (struct proc *)0);
d978 1
a978 1
		    (void) nfs_doio(bp, bp->b_wcred, (struct proc *)0);
@


1.18
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.17 2001/02/23 14:52:51 csapuntz Exp $	*/
a97 1
static int notstarted = 1;
d634 1
a634 3
		    if (notstarted) {
			    cacherep = RC_DROPIT;
		    } else if (nfsd->nfsd_flag & NFSD_AUTHFAIL) {
d650 1
a650 1
			    nfsrvw_procrastinate > 0 && !notstarted))
@


1.17
log
@

Change the B_DELWRI flag using buf_dirty and buf_undirty instead of
manually twiddling it. This allows the buffer cache to more easily
keep track of dirty buffers and decide when it is appropriate to speed
up the syncer.

Insipired by FreeBSD.
Look over by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.16 2000/11/09 17:23:38 art Exp $	*/
a78 1
#include <nfs/nqnfs.h>
a89 2
extern time_t nqnfsstarttime;
extern int nqsrv_writeslack;
a98 1
static int modify_flag = 0;
d114 91
d276 1
a276 1
		error = nqnfs_clientd(nmp, p->p_ucred, &ncd, SCARG(uap, flag),
a634 11
		    /*
		     * Check for just starting up for NQNFS and send
		     * fake "try again later" replies to the NQNFS clients.
		     */
		    if (notstarted && nqnfsstarttime <= time.tv_sec) {
			if (modify_flag) {
				nqnfsstarttime = time.tv_sec + nqsrv_writeslack;
				modify_flag = 0;
			} else
				notstarted = 0;
		    }
d636 1
a636 8
			if ((nd->nd_flag & ND_NQNFS) == 0)
				cacherep = RC_DROPIT;
			else if (nd->nd_procnum != NFSPROC_WRITE) {
				nd->nd_procnum = NFSPROC_NOOP;
				nd->nd_repstat = NQNFS_TRYLATER;
				cacherep = RC_DOIT;
			} else
				modify_flag = 1;
d638 4
a641 4
			nfsd->nfsd_flag &= ~NFSD_AUTHFAIL;
			nd->nd_procnum = NFSPROC_NOOP;
			nd->nd_repstat = (NFSERR_AUTHERR | AUTH_TOOWEAK);
			cacherep = RC_DOIT;
d662 1
a662 2
				if (nd->nd_procnum != NQNFSPROC_VACATED)
					nfsstats.srv_errs++;
a894 2
	if (nd->nd_flag & ND_NQNFS)
		rt->flag |= DRT_NQNFS;
@


1.16
log
@PHOLD the nfsd.
PRELE the nfsiod when it exits (shouldn't be necessary to PHOLD it because
it's a kernel thread, but it doesn't hurt.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.15 2000/05/24 17:41:12 mickey Exp $	*/
d909 2
a910 2
			nbp->b_flags &= ~(B_READ|B_DONE|B_ERROR|B_DELWRI);
			reassignbuf(nbp, nbp->b_vp);
@


1.15
log
@return ENOSYS for NFSSVC_BIOD request. since none to call it anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.14 2000/05/19 16:36:03 mickey Exp $	*/
d443 1
d540 2
a541 1
			    !copyout((caddr_t)nsd, argp, sizeof (*nsd)))
d543 1
d685 1
d871 1
a871 1
	p->p_holdcnt++;
d919 1
@


1.14
log
@from tsarna@@netbsd.org (sysctl changes to come later):
Death to nfsiod!

It is replaced by kernel threads that do the same thing. The number of
kernel threads used is set with the vfs.nfs.iothreads sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.13 2000/02/07 04:47:53 assar Exp $	*/
a165 3
#ifdef NFSCLIENT
		error = nfssvc_iod(p);
#else
a166 1
#endif
@


1.13
log
@moved sys_getfh to vfs_syscalls.c
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.12 1997/12/02 16:57:58 csapuntz Exp $	*/
d61 2
d110 2
a111 1
static int nfs_asyncdaemon[NFS_MAXASYNCDAEMON];
d845 1
a845 1
 * Asynchronous I/O daemons for client nfs.
d863 1
a863 2
		if (nfs_asyncdaemon[i] == 0) {
			nfs_asyncdaemon[i]++;
d869 1
d871 1
d919 1
a919 1
		nfs_asyncdaemon[myiod] = 0;
d926 40
@


1.13.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.17 2001/02/23 14:52:51 csapuntz Exp $	*/
a60 2
#include <sys/signalvar.h>
#include <sys/kthread.h>
d108 1
a108 2
struct proc *nfs_asyncdaemon[NFS_MAXASYNCDAEMON];
int nfs_niothreads = -1;
d163 3
d167 1
a443 1
	PHOLD(p);
d540 1
a540 2
			    !copyout((caddr_t)nsd, argp, sizeof (*nsd))) {
			    PRELE(p);
a541 1
			}
a682 1
	PRELE(p);
d842 1
a842 1
 * Asynchronous I/O threads for client nfs.
d860 2
a861 1
		if (nfs_asyncdaemon[i] == NULL) {
a866 1
	nfs_asyncdaemon[myiod] = p;
a867 1
	PHOLD(p);
d905 2
a906 2
			nbp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
			buf_undirty(bp);
d915 1
a915 2
		PRELE(p);
		nfs_asyncdaemon[myiod] = NULL;
a921 40
void
start_nfsio(arg)
	void *arg;
{
	nfssvc_iod(curproc);
	
	kthread_exit(0);
}

void
nfs_getset_niothreads(set)
	int set;
{
	int i, have, start;
	
	for (have = 0, i = 0; i < NFS_MAXASYNCDAEMON; i++)
		if (nfs_asyncdaemon[i] != NULL)
			have++;

	if (set) {
		/* clamp to sane range */
		nfs_niothreads = max(0, min(nfs_niothreads, NFS_MAXASYNCDAEMON));

		start = nfs_niothreads - have;

		while (start > 0) {
			kthread_create(start_nfsio, NULL, NULL, "nfsio");
			start--;
		}

		for (i = 0; (start < 0) && (i < NFS_MAXASYNCDAEMON); i++)
			if (nfs_asyncdaemon[i] != NULL) {
				psignal(nfs_asyncdaemon[i], SIGKILL);
				start++;
			}
	} else {
		if (nfs_niothreads >= 0)
			nfs_niothreads = have;
	}
}
@


1.13.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.13.2.1 2001/05/14 22:44:57 niklas Exp $	*/
d79 1
d91 2
d101 2
a117 91
int nfs_clientd(struct nfsmount *nmp, struct ucred *cred, 
    struct nfsd_cargs *ncd, int flag, caddr_t argp, struct proc *p);

/*
 * Nfs client helper daemon.
 * It also get authorization strings for "kerb" mounts.
 * It must start at the beginning of the list again after any potential
 * "sleep" since nfs_reclaim() called from vclean() can pull a node off
 * the list asynchronously.
 */
int
nfs_clientd(struct nfsmount *nmp, struct ucred *cred, struct nfsd_cargs *ncd, 
    int flag, caddr_t argp, struct proc *p)
{
	struct nfsuid *nuidp, *nnuidp;
	int error = 0;

	/*
	 * First initialize some variables
	 */

	/*
	 * If an authorization string is being passed in, get it.
	 */
	if ((flag & NFSSVC_GOTAUTH) &&
	    (nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_DISMNT)) == 0) {
	    if (nmp->nm_flag & NFSMNT_HASAUTH)
		panic("cld kerb");
	    if ((flag & NFSSVC_AUTHINFAIL) == 0) {
		if (ncd->ncd_authlen <= nmp->nm_authlen &&
		    ncd->ncd_verflen <= nmp->nm_verflen &&
		    !copyin(ncd->ncd_authstr,nmp->nm_authstr,ncd->ncd_authlen)&&
		    !copyin(ncd->ncd_verfstr,nmp->nm_verfstr,ncd->ncd_verflen)){
		    nmp->nm_authtype = ncd->ncd_authtype;
		    nmp->nm_authlen = ncd->ncd_authlen;
		    nmp->nm_verflen = ncd->ncd_verflen;
#ifdef NFSKERB
		    nmp->nm_key = ncd->ncd_key;
#endif
		} else
		    nmp->nm_flag |= NFSMNT_AUTHERR;
	    } else
		nmp->nm_flag |= NFSMNT_AUTHERR;
	    nmp->nm_flag |= NFSMNT_HASAUTH;
	    wakeup((caddr_t)&nmp->nm_authlen);
	} else
	    nmp->nm_flag |= NFSMNT_WAITAUTH;

	/*
	 * Loop every second updating queue until there is a termination sig.
	 */
	while ((nmp->nm_flag & NFSMNT_DISMNT) == 0) {
	    /*
	     * Get an authorization string, if required.
	     */
	    if ((nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_DISMNT | NFSMNT_HASAUTH)) == 0) {
		ncd->ncd_authuid = nmp->nm_authuid;
		if (copyout((caddr_t)ncd, argp, sizeof (struct nfsd_cargs)))
			nmp->nm_flag |= NFSMNT_WAITAUTH;
		else
			return (ENEEDAUTH);
	    }

	    /*
	     * Wait a bit (no pun) and do it again.
	     */
	    if ((nmp->nm_flag & NFSMNT_DISMNT) == 0 &&
		(nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_HASAUTH))) {
		    error = tsleep((caddr_t)&nmp->nm_authstr, PSOCK | PCATCH,
			"nqnfstimr", hz / 3);
		    if (error == EINTR || error == ERESTART)
			(void) dounmount(nmp->nm_mountp, MNT_FORCE, p);
	    }
	}

	/*
	 * Finally, we can free up the mount structure.
	 */
	for (nuidp = nmp->nm_uidlruhead.tqh_first; nuidp != 0; nuidp = nnuidp) {
		nnuidp = nuidp->nu_lru.tqe_next;
		LIST_REMOVE(nuidp, nu_hash);
		TAILQ_REMOVE(&nmp->nm_uidlruhead, nuidp, nu_lru);
		free((caddr_t)nuidp, M_NFSUID);
	}
	free((caddr_t)nmp, M_NFSMNT);
	if (error == EWOULDBLOCK)
		error = 0;
	return (error);
}


d189 1
a189 1
		error = nfs_clientd(nmp, p->p_ucred, &ncd, SCARG(uap, flag),
d548 25
a572 5
		    if (nfsd->nfsd_flag & NFSD_AUTHFAIL) {
			    nfsd->nfsd_flag &= ~NFSD_AUTHFAIL;
			    nd->nd_procnum = NFSPROC_NOOP;
			    nd->nd_repstat = (NFSERR_AUTHERR | AUTH_TOOWEAK);
			    cacherep = RC_DOIT;
d584 1
a584 1
			    nfsrvw_procrastinate > 0))
d593 2
a594 1
				nfsstats.srv_errs++;
d827 2
@


1.13.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d916 4
a919 3
	struct buf *bp;
	int i, myiod;
	int error = 0;
d947 33
a979 1
		(void) nfs_doio(bp, NULL);
@


1.13.2.4
log
@Merge in trunk
@
text
@d191 2
a192 3
	for (nuidp = TAILQ_FIRST(&nmp->nm_uidlruhead); nuidp != NULL;
	    nuidp = nnuidp) {
		nnuidp = TAILQ_NEXT(nuidp, nu_lru);
d221 1
a221 1
	struct sys_nfssvc_args /* {
a288 1
		FREF(fp);
d297 1
a297 2
			if (error) {
				FRELE(fp);
a298 1
			}
a300 1
		FRELE(fp);
d319 1
a319 1
			    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d345 1
a345 1
				    nuidp = TAILQ_FIRST(&slp->ns_uidlruhead);
d414 4
a417 4
	struct mbuf *m;
	int siz;
	struct nfssvc_sock *slp;
	struct socket *so;
d505 5
a509 5
	struct mbuf *m;
	int siz;
	struct nfssvc_sock *slp;
	struct socket *so;
	int *solockp;
d545 1
a545 1
			if (nfsd->nfsd_slp == NULL &&
d547 2
a548 2
				for (slp = TAILQ_FIRST(&nfssvc_sockhead);
				    slp != 0; slp = TAILQ_NEXT(slp, ns_chain)) {
d576 2
a577 3
				if (error && LIST_FIRST(&slp->ns_tq) &&
				    LIST_FIRST(&slp->ns_tq)->nd_time
				    <= cur_usec) {
d734 2
a735 2
		    if (LIST_FIRST(&slp->ns_tq) &&
			LIST_FIRST(&slp->ns_tq)->nd_time <= cur_usec) {
d769 1
a769 1
	struct nfssvc_sock *slp;
d771 2
a772 2
	struct nfsuid *nuidp, *nnuidp;
	struct nfsrv_descript *nwp, *nnwp;
d781 1
a781 2
		FREF(fp);
		slp->ns_fp = NULL;
d785 1
a785 1
		closef(fp, NULL);
d790 1
a790 1
		for (nuidp = TAILQ_FIRST(&slp->ns_uidlruhead); nuidp != NULL;
d792 1
a792 1
			nnuidp = TAILQ_NEXT(nuidp, nu_lru);
d800 2
a801 2
		for (nwp = LIST_FIRST(&slp->ns_tq); nwp != NULL; nwp = nnwp) {
			nnwp = LIST_NEXT(nwp, nd_tq);
d816 1
a816 1
	struct nfssvc_sock *slp;
d833 1
a833 1
	struct nfssvc_sock *slp, *nslp;
d839 2
a840 3
		for (slp = TAILQ_FIRST(&nfssvc_sockhead); slp != NULL;
		    slp = nslp) {
			nslp = TAILQ_NEXT(slp, ns_chain);
d878 1
a878 1
	struct nfsrv_descript *nd;
d881 1
a881 1
	struct drt *rt;
d916 1
a916 1
	struct buf *bp, *nbp;
d918 1
a918 2
	struct vnode *vp;
	int error = 0, s;
d938 1
a938 1
	    while (TAILQ_FIRST(&nfs_bufq) == NULL && error == 0) {
d943 1
a943 1
	    while ((bp = TAILQ_FIRST(&nfs_bufq)) != NULL) {
d946 1
a946 33
		if (bp->b_flags & B_READ)
		    (void) nfs_doio(bp, NULL);
		else do {
		    /*
		     * Look for a delayed write for the same vnode, so I can do 
		     * it now. We must grab it before calling nfs_doio() to
		     * avoid any risk of the vnode getting vclean()'d while
		     * we are doing the write rpc.
		     */
		    vp = bp->b_vp;
		    s = splbio();
		    for (nbp = LIST_FIRST(&vp->v_dirtyblkhd); nbp != NULL;
			nbp = LIST_NEXT(nbp, b_vnbufs)) {
			if ((nbp->b_flags &
			    (B_BUSY|B_DELWRI|B_NEEDCOMMIT|B_NOCACHE))!=B_DELWRI)
			    continue;
			bremfree(nbp);
			nbp->b_flags |= (B_BUSY|B_ASYNC);
			break;
		    }
		    /*
		     * For the delayed write, do the first part of nfs_bwrite()
		     * up to, but not including nfs_strategy().
		     */
		    if (nbp) {
			nbp->b_flags &= ~(B_READ|B_DONE|B_ERROR);
			buf_undirty(bp);
			nbp->b_vp->v_numoutput++;
		    }
		    splx(s);

		    (void) nfs_doio(bp, NULL);
		} while ((bp = nbp) != NULL);
d1004 1
a1004 1
	struct nfsmount *nmp;
d1073 2
a1074 2
	struct nfsuid *nuidp;
	u_int32_t *nickp, *verfp;
d1082 1
a1082 1
	    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d1134 1
a1134 1
	struct nfsmount *nmp;
d1142 3
a1144 3
	struct nfsuid *nuidp;
	u_int32_t *tl;
	int32_t t1;
d1178 1
a1178 1
				nuidp = TAILQ_FIRST(&nmp->nm_uidlruhead);
@


1.13.2.5
log
@Merge in -current from roughly a week ago
@
text
@d82 1
a82 1
void	nfsrv_zapsock(struct nfssvc_sock *);
d85 1
a85 1
extern int32_t (*nfsrv3_procs[NFS_NPROCS])(struct nfsrv_descript *,
d87 1
a87 1
						struct proc *, struct mbuf **);
d110 1
a110 1
static void nfsd_rt(int, struct nfsrv_descript *, int);
@


1.13.2.6
log
@Sync the SMP branch with 3.3
@
text
@a100 6
struct nfssvc_sockhead nfssvc_sockhead;
struct nfsdhead nfsd_head;

int nfssvc_sockhead_flag;
int nfsd_head_flag;

d149 3
d183 2
a184 4
		    if (error == EINTR || error == ERESTART) {
			if (vfs_busy(nmp->nm_mountp, LK_EXCLUSIVE, NULL, p) == 0)
			    dounmount(nmp->nm_mountp, MNT_FORCE, p);
		    }
d290 1
d1091 1
a1091 1
		bcopy((caddr_t)nmp->nm_key, (caddr_t)key, sizeof (NFSKERBKEY_T));
d1156 8
d1198 6
d1229 1
a1229 1
			bcopy(key, nuidp->nu_key, sizeof (NFSKERBKEY_T));
@


1.13.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.13.2.6 2003/03/28 00:08:46 niklas Exp $	*/
d188 1
a188 1
			    dounmount(nmp->nm_mountp, MNT_FORCE, p, NULL);
@


1.13.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.13.2.7 2003/05/13 19:36:57 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.13.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d246 1
a246 1
	error = suser(p, 0);
@


1.12
log
@More splbio()'s added so that reassignbuf can do its thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.11 1997/11/06 05:59:03 csapuntz Exp $	*/
a116 1
 * getfh() lives here too, but maybe should move to kern/vfs_syscalls.c
a117 40

/*
 * Get file handle system call
 */
int
sys_getfh(p, v, retval)
	struct proc *p;
	register void *v;
	register_t *retval;
{
	register struct sys_getfh_args /* {
		syscallarg(char *) fname;
		syscallarg(fhandle_t *) fhp;
	} */ *uap = v;
	register struct vnode *vp;
	fhandle_t fh;
	int error;
	struct nameidata nd;

	/*
	 * Must be super user
	 */
	error = suser(p->p_ucred, &p->p_acflag);
	if(error)
		return (error);
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, fname), p);
	error = namei(&nd);
	if (error)
		return (error);
	vp = nd.ni_vp;
	bzero((caddr_t)&fh, sizeof(fh));
	fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
	error = VFS_VPTOFH(vp, &fh.fh_fid);
	vput(vp);
	if (error)
		return (error);
	error = copyout((caddr_t)&fh, (caddr_t)SCARG(uap, fhp), sizeof (fh));
	return (error);
}
@


1.11
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.10 1997/10/06 20:20:50 deraadt Exp $	*/
a940 1
		    splx(s);
d950 2
@


1.10
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.8 1997/03/30 20:02:32 mickey Exp $	*/
a946 2
			if (nbp->b_flags & B_DELWRI)
			    TAILQ_REMOVE(&bdirties, nbp, b_synclist);
@


1.9
log
@VFS Lite2 Changes
@
text
@d947 2
@


1.8
log
@ifdef out some vars used only w/ NFSCLIENT defined
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.7 1996/06/14 04:41:08 tholo Exp $	*/
a946 2
			if (nbp->b_flags & B_DELWRI)
			    TAILQ_REMOVE(&bdirties, nbp, b_synclist);
@


1.7
log
@Keep dirty list used by in-kernel update(8) in sync with buffers
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.5 1996/04/17 04:50:33 mickey Exp $	*/
d107 1
d109 1
d177 1
a179 2
	int error;
#ifdef NFSCLIENT
d182 1
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d945 2
@


1.5
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.4 1996/03/31 13:15:56 mickey Exp $	*/
d247 1
a247 1
			nam = (struct mbuf *)NULL;
d293 1
a293 1
				nuidp = (struct nfsuid *)NULL;
d298 1
a298 1
				if (nuidp == NULL) {
d376 1
a376 1
	tslp = (struct nfssvc_sock *)NULL;
d475 1
a475 1
	if (nfsd == NULL) {
d488 1
a488 1
			while (nfsd->nfsd_slp == NULL &&
d498 1
a498 1
			if (nfsd->nfsd_slp == NULL &&
d513 1
a513 1
			if ((slp = nfsd->nfsd_slp) == NULL)
d521 1
a521 1
						NULL);
d547 1
a547 1
			nfsd->nfsd_slp = (struct nfssvc_sock *)NULL;
d558 1
a558 1
			solockp = (int *)NULL;
d639 1
a639 1
			nd->nd_mrep = (struct mbuf *)NULL;
d653 1
a653 1
			m->m_pkthdr.rcvif = (struct ifnet *)NULL;
d663 1
a663 1
				(void) nfs_sndlock(solockp, (struct nfsreq *)NULL);
d725 1
a725 1
	nsd->nsd_nfsd = (struct nfsd *)NULL;
d752 1
a752 1
		slp->ns_fp = (struct file *)NULL;
d756 1
a756 1
		closef(fp, (struct proc *)NULL);
d920 1
a920 1
		    (void) nfs_doio(bp, bp->b_rcred, (struct proc *)NULL);
d949 1
a949 1
		    (void) nfs_doio(bp, bp->b_wcred, (struct proc *)NULL);
@


1.4
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_syscalls.c,v 1.3 1996/02/29 09:24:57 niklas Exp $	*/
d247 1
a247 1
			nam = (struct mbuf *)0;
d293 1
a293 1
				nuidp = (struct nfsuid *)0;
d298 1
a298 1
				if (nuidp == (struct nfsuid *)0) {
d376 1
a376 1
	tslp = (struct nfssvc_sock *)0;
d475 1
a475 1
	if (nfsd == (struct nfsd *)0) {
d488 1
a488 1
			while (nfsd->nfsd_slp == (struct nfssvc_sock *)0 &&
d498 1
a498 1
			if (nfsd->nfsd_slp == (struct nfssvc_sock *)0 &&
d513 1
a513 1
			if ((slp = nfsd->nfsd_slp) == (struct nfssvc_sock *)0)
d521 1
a521 1
						(struct nfsreq *)0);
d547 1
a547 1
			nfsd->nfsd_slp = (struct nfssvc_sock *)0;
d558 1
a558 1
			solockp = (int *)0;
d639 1
a639 1
			nd->nd_mrep = (struct mbuf *)0;
d653 1
a653 1
			m->m_pkthdr.rcvif = (struct ifnet *)0;
d663 1
a663 1
				(void) nfs_sndlock(solockp, (struct nfsreq *)0);
d725 1
a725 1
	nsd->nsd_nfsd = (struct nfsd *)0;
d752 1
a752 1
		slp->ns_fp = (struct file *)0;
d756 1
a756 1
		closef(fp, (struct proc *)0);
d920 1
a920 1
		    (void) nfs_doio(bp, bp->b_rcred, (struct proc *)0);
d949 1
a949 1
		    (void) nfs_doio(bp, bp->b_wcred, (struct proc *)0);
@


1.3
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_syscalls.c,v 1.18 1996/02/09 21:48:36 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfs_syscalls.c	8.3 (Berkeley) 1/4/94
d69 1
d71 1
a71 1
#include <nfs/nfsv2.h>
d73 1
d81 2
d84 3
a86 5
extern u_int32_t nfs_prog, nfs_vers;
extern int32_t (*nfsrv_procs[NFS_NPROCS]) __P((struct nfsd *, struct mbuf *,
					       struct mbuf *, caddr_t,
					       struct ucred *, struct mbuf *,
					       struct mbuf **));
d92 2
d108 1
d110 1
a110 2
static void nfsd_rt __P((struct timeval *, int, struct nfsd *, struct mbuf *,
			 int));
d112 1
d139 2
a140 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d144 2
a145 1
	if ((error = namei(&nd)) != 0)
d159 1
a159 1
 * Nfs server psuedo system call for the nfsd's
d178 3
a189 1
	struct nfsd_cargs ncd;
d194 2
a195 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d198 1
a198 1
		nfssvc_sockhead_flag |= SLP_WANTINIT;
d202 3
a204 1
#ifndef NFSCLIENT
d206 1
a206 3
#else /* !NFSCLIENT */
		error = nfssvc_iod(p);
#endif /* !NFSCLIENT */
d210 1
a210 1
#else /* !NFSCLIENT */
d216 2
a217 1
		if ((error = namei(&nd)) != 0)
d226 1
a226 1
		    (SCARG(uap, flag) & NFSSVC_GOTAUTH) == 0)
d230 2
a231 2
		    SCARG(uap, argp), p);
#endif /* !NFSCLIENT */
d235 1
a235 1
#else /* !NFSSERVER */
d237 1
a237 1
			       sizeof(nfsdarg));
d240 2
a241 1
		if ((error = getsock(p->p_fd, nfsdarg.sock, &fp)) != 0)
d250 1
a250 1
					 MT_SONAME);
d259 1
a259 1
#else /* !NFSSERVER */
d264 3
a266 3
		    (nfsd = nsd->nsd_nfsd) &&
		    (nfsd->nd_slp->ns_flag & SLP_VALID)) {
			slp = nfsd->nd_slp;
d272 1
a272 1
			for (nuidp = NUIDHASH(slp, nsd->nsd_uid)->lh_first;
d274 4
a277 1
				if (nuidp->nu_uid == nsd->nsd_uid)
d280 4
a283 1
			if (nuidp == 0) {
d303 2
d306 1
d309 1
a309 1
					nuidp->nu_cr.cr_ngroups = NGROUPS;
d311 27
a337 1
				nuidp->nu_uid = nsd->nsd_uid;
d339 1
a339 1
				    nu_lru);
d341 4
a344 1
				    nuidp, nu_hash);
d350 1
a350 1
			nfsd->nd_flag |= NFSD_AUTHFAIL;
d396 1
a396 1
		siz = NFS_MAXPACKET + sizeof (u_int32_t);
d399 2
a400 1
	if ((error = soreserve(so, siz, siz)) != 0) {
d412 2
a413 2
		*mtod(m, int *) = 1;
		m->m_len = sizeof(int);
d419 2
a420 2
		*mtod(m, int *) = 1;
		m->m_len = sizeof(int);
a432 2
		slp->ns_uidhashtbl =
		    hashinit(NUIDHASHSIZ, M_NFSSVC, &slp->ns_uidhash);
d459 1
a459 1
	register struct mbuf *m, *nam2;
d464 10
a473 7
	struct nfsd *nd = nsd->nsd_nfsd;
	struct mbuf *mreq, *nam;
	struct timeval starttime;
	struct nfsuid *uidp;
	int error = 0, cacherep, s;
	int sotype;

d475 2
a476 2
	if (nd == (struct nfsd *)0) {
		nsd->nsd_nfsd = nd = (struct nfsd *)
d478 3
a480 5
		bzero((caddr_t)nd, sizeof (struct nfsd));
		nd->nd_procp = p;
		nd->nd_cr.cr_ref = 1;
		TAILQ_INSERT_TAIL(&nfsd_head, nd, nd_chain);
		nd->nd_nqlflag = NQL_NOVAL;
d487 2
a488 2
		if ((nd->nd_flag & NFSD_REQINPROG) == 0) {
			while (nd->nd_slp == (struct nfssvc_sock *)0 &&
d490 1
a490 1
				nd->nd_flag |= NFSD_WAITING;
d492 2
a493 1
				error = tsleep((caddr_t)nd, PSOCK | PCATCH, "nfsd", 0);
d498 1
a498 1
			if (nd->nd_slp == (struct nfssvc_sock *)0 &&
d506 1
a506 1
					    nd->nd_slp = slp;
d513 1
a513 1
			if ((slp = nd->nd_slp) == (struct nfssvc_sock *)0)
d526 11
a536 2
				error = nfsrv_dorec(slp, nd);
				nd->nd_flag |= NFSD_REQINPROG;
d540 1
a540 1
			slp = nd->nd_slp;
d543 6
a548 2
			nd->nd_slp = (struct nfssvc_sock *)0;
			nd->nd_flag &= ~NFSD_REQINPROG;
a554 1
		starttime = time;
d559 31
a589 50
		/*
		 * nam == nam2 for connectionless protocols such as UDP
		 * nam2 == NULL for connection based protocols to disable
		 *    recent request caching.
		 */
		if ((nam2 = nd->nd_nam) != NULL) {
			nam = nam2;
			cacherep = RC_CHECKIT;
		} else {
			nam = slp->ns_nam;
			cacherep = RC_DOIT;
		}

		/*
		 * Check to see if authorization is needed.
		 */
		if (nd->nd_flag & NFSD_NEEDAUTH) {
			static int logauth = 0;

			nd->nd_flag &= ~NFSD_NEEDAUTH;
			/*
			 * Check for a mapping already installed.
			 */
			for (uidp = NUIDHASH(slp, nd->nd_cr.cr_uid)->lh_first;
			    uidp != 0; uidp = uidp->nu_hash.le_next) {
				if (uidp->nu_uid == nd->nd_cr.cr_uid)
					break;
			}
			if (uidp == 0) {
			    nsd->nsd_uid = nd->nd_cr.cr_uid;
			    if (nam2 && logauth++ == 0)
				log(LOG_WARNING, "Kerberized NFS using UDP\n");
			    nsd->nsd_haddr =
			      mtod(nam, struct sockaddr_in *)->sin_addr.s_addr;
			    nsd->nsd_authlen = nd->nd_authlen;
			    if (copyout(nd->nd_authstr, nsd->nsd_authstr,
				nd->nd_authlen) == 0 &&
				copyout((caddr_t)nsd, argp, sizeof (*nsd)) == 0)
				return (ENEEDAUTH);
			    cacherep = RC_DROPIT;
			}
		}
		if (cacherep == RC_CHECKIT)
			cacherep = nfsrv_getcache(nam2, nd, &mreq);

		/*
		 * Check for just starting up for NQNFS and send
		 * fake "try again later" replies to the NQNFS clients.
		 */
		if (notstarted && nqnfsstarttime <= time.tv_sec) {
d595 3
a597 3
		}
		if (notstarted) {
			if (nd->nd_nqlflag == NQL_NOVAL)
d605 2
a606 2
		} else if (nd->nd_flag & NFSD_AUTHFAIL) {
			nd->nd_flag &= ~NFSD_AUTHFAIL;
d608 1
a608 1
			nd->nd_repstat = NQNFS_AUTHERR;
d610 1
d613 16
a628 9
		switch (cacherep) {
		case RC_DOIT:
			error = (*(nfsrv_procs[nd->nd_procnum]))(nd,
				nd->nd_mrep, nd->nd_md, nd->nd_dpos, &nd->nd_cr,
				nam, &mreq);
			if (nd->nd_cr.cr_ref != 1) {
				printf("nfssvc cref=%d\n", nd->nd_cr.cr_ref);
				panic("nfssvc cref");
			}
d632 3
a634 4
				if (nam2) {
					nfsrv_updatecache(nam2, nd, FALSE, mreq);
					m_freem(nam2);
				}
d638 1
a638 2
			if (nam2)
				nfsrv_updatecache(nam2, nd, TRUE, mreq);
d640 1
a640 1
		case RC_REPLY:
d665 1
a665 1
			    error = nfs_send(so, nam2, m, (struct nfsreq *)0);
d671 3
a673 3
				nfsd_rt(&starttime, sotype, nd, nam, cacherep);
			if (nam2)
				MFREE(nam2, m);
d681 1
d687 1
a687 1
		case RC_DROPIT:
d689 1
a689 1
				nfsd_rt(&starttime, sotype, nd, nam, cacherep);
d691 1
a691 1
			m_freem(nam2);
d693 21
a713 1
		};
d715 3
a717 3
		if (nfsrv_dorec(slp, nd)) {
			nd->nd_flag &= ~NFSD_REQINPROG;
			nd->nd_slp = (struct nfssvc_sock *)0;
d722 1
a722 1
	TAILQ_REMOVE(&nfsd_head, nd, nd_chain);
d724 1
a724 1
	free((caddr_t)nd, M_NFSD);
d743 1
d747 1
d750 2
a751 1
	if ((fp = slp->ns_fp) != NULL) {
d766 2
d770 8
a832 2
	nfs_udpsock->ns_uidhashtbl =
	    hashinit(NUIDHASHSIZ, M_NFSSVC, &nfs_udpsock->ns_uidhash);
a838 2
	nfs_cltpsock->ns_uidhashtbl =
	    hashinit(NUIDHASHSIZ, M_NFSSVC, &nfs_cltpsock->ns_uidhash);
d847 1
a847 2
nfsd_rt(startp, sotype, nd, nam, cacherep)
	struct timeval *startp;
d849 1
a849 2
	register struct nfsd *nd;
	struct mbuf *nam;
d863 1
a863 1
	if (nd->nd_nqlflag != NQL_NOVAL)
d865 2
d868 2
a869 2
	if (mtod(nam, struct sockaddr *)->sa_family == AF_INET)
		rt->ipadr = mtod(nam, struct sockaddr_in *)->sin_addr.s_addr;
d871 3
a873 3
		rt->ipadr = INADDR_ANY;
	rt->resptime = ((time.tv_sec - startp->tv_sec) * 1000000) +
		(time.tv_usec - startp->tv_usec);
d889 1
a889 1
	register struct buf *bp;
d891 2
a892 1
	int error = 0;
d911 46
a956 18
		while (nfs_bufq.tqh_first == NULL && error == 0) {
			nfs_iodwant[myiod] = p;
			error = tsleep((caddr_t)&nfs_iodwant[myiod],
				PWAIT | PCATCH, "nfsidl", 0);
		}
		while ((bp = nfs_bufq.tqh_first) != NULL) {
			/* Take one off the front of the list */
			TAILQ_REMOVE(&nfs_bufq, bp, b_freelist);
			if (bp->b_flags & B_READ)
			    (void) nfs_doio(bp, bp->b_rcred, (struct proc *)0);
			else
			    (void) nfs_doio(bp, bp->b_wcred, (struct proc *)0);
		}
		if (error) {
			nfs_asyncdaemon[myiod] = 0;
			nfs_numasync--;
			return (error);
		}
d960 1
d966 1
a966 1
nfs_getauth(nmp, rep, cred, auth_type, auth_str, auth_len)
a969 1
	int *auth_type;
d972 3
d990 3
a1010 1
		*auth_type = nmp->nm_authtype;
d1012 2
d1021 141
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_syscalls.c,v 1.17 1995/12/19 23:07:46 cgd Exp $	*/
d60 1
d77 1
d81 4
a84 1
extern int32_t (*nfsrv_procs[NFS_NPROCS])();
d92 2
a94 1
int nfsd_waiting = 0;
d98 1
a98 3
void nfsrv_cleancache(), nfsrv_rcv(), nfsrv_wakenfsd(), nfs_sndunlock();
static void nfsd_rt();
void nfsrv_slpderef(), nfsrv_init();
d104 4
d116 1
d119 1
a119 1
	void *v;
d134 1
a134 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d138 1
a138 1
	if (error = namei(&nd))
d158 1
d169 3
a175 1
	struct nfsd_cargs ncd;
d178 3
a180 3
	struct nfsuid *nuidp, **nuh;
	struct nfsmount *nmp;
	int error;
d185 1
a185 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d201 2
a202 2
		if (error =
		    copyin(SCARG(uap, argp), (caddr_t)&ncd, sizeof (ncd)))
d206 1
a206 1
		if (error = namei(&nd))
d225 3
a227 2
		if (error = copyin(SCARG(uap, argp), (caddr_t)&nfsdarg,
		    sizeof(nfsdarg)))
d229 1
a229 1
		if (error = getsock(p->p_fd, nfsdarg.sock, &fp))
d236 6
a241 3
		else if (error = sockargs(&nam, nfsdarg.name, nfsdarg.namelen,
			MT_SONAME))
			return (error);
d248 2
a249 2
		if (error = copyin(SCARG(uap, argp), (caddr_t)nsd,
		    sizeof (*nsd)))
d313 1
d349 1
a349 1
	if (error = soreserve(so, siz, siz)) {
d404 1
d419 1
a419 1
	int error, cacherep, s;
d501 1
a501 1
		if (nam2 = nd->nd_nam) {
d667 1
a671 1
	register int i;
d677 1
a677 1
	if (fp = slp->ns_fp) {
d805 1
d855 1
d870 2
a871 1
		if (error = nfs_sigintr(nmp, rep, rep->r_procp)) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_syscalls.c,v 1.16 1995/10/07 06:28:57 mycroft Exp $	*/
d77 2
a78 2
extern u_long nfs_prog, nfs_vers;
extern int (*nfsrv_procs[NFS_NPROCS])();
d328 1
a328 1
		siz = NFS_MAXPACKET + sizeof (u_long);
d591 1
a591 1
				*mtod(m, u_long *) = htonl(0x80000000 | siz);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
